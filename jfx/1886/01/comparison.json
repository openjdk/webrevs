{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## xmlsoft.org: libxml2 v2.13.8\n+## xmlsoft.org: libxml2 v2.14.5\n","filename":"modules\/javafx.web\/src\/main\/legal\/libxml2.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -13,2 +13,1 @@\n-        > cscript configure.js compiler=msvc catalog=no xml_debug=no docb=no ftp=no http=no iconv=no legacy=no mem_debug=no modules=no regexps=no run_debug=no schemas=no schematron=no valid=no xinclude=no xptr=no zlib=no\n-\n+        > cscript configure.js compiler=msvc catalog=no xml_debug=no http=no iconv=no legacy=no modules=no regexps=no schemas=no schematron=no valid=no xinclude=no xptr=no zlib=no\n@@ -16,0 +15,1 @@\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/UPDATING.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,2 +4,3 @@\n-\/* A form that will not confuse apibuild.py *\/\n-#define ATTRIBUTE_DESTRUCTOR __attribute__((destructor))\n+\/* Define to 1 if you have the declaration of `getentropy', and to 0 if you\n+   don't. *\/\n+#define HAVE_DECL_GETENTROPY 0\n@@ -7,2 +8,3 @@\n-\/* Define to 1 if you have the <arpa\/inet.h> header file. *\/\n-\/* #undef HAVE_ARPA_INET_H *\/\n+\/* Define to 1 if you have the declaration of `glob', and to 0 if you don't.\n+   *\/\n+#define HAVE_DECL_GLOB 1\n@@ -10,2 +12,3 @@\n-\/* Define if __attribute__((destructor)) is accepted *\/\n-#define HAVE_ATTRIBUTE_DESTRUCTOR 1\n+\/* Define to 1 if you have the declaration of `mmap', and to 0 if you don't.\n+   *\/\n+#define HAVE_DECL_MMAP 1\n@@ -19,17 +22,2 @@\n-\/* Define to 1 if you have the <dl.h> header file. *\/\n-\/* #undef HAVE_DL_H *\/\n-\n-\/* Define to 1 if you have the <fcntl.h> header file. *\/\n-#define HAVE_FCNTL_H 1\n-\n-\/* Define to 1 if you have the `ftime' function. *\/\n-#define HAVE_FTIME 1\n-\n-\/* getentropy *\/\n-\/* #undef HAVE_GETENTROPY *\/\n-\n-\/* Define to 1 if you have the `gettimeofday' function. *\/\n-#define HAVE_GETTIMEOFDAY 1\n-\n-\/* Define to 1 if you have the <glob.h> header file. *\/\n-#define HAVE_GLOB_H 1\n+\/* Define to 1 if the system has the `destructor' function attribute *\/\n+#define HAVE_FUNC_ATTRIBUTE_DESTRUCTOR 1\n@@ -40,1 +28,1 @@\n-\/* Define if history library is there (-lhistory) *\/\n+\/* Define if history library is available *\/\n@@ -43,1 +31,1 @@\n-\/* Define if readline library is there (-lreadline) *\/\n+\/* Define if readline library is available *\/\n@@ -49,17 +37,0 @@\n-\/* Define to 1 if you have the `mmap' function. *\/\n-#define HAVE_MMAP 1\n-\n-\/* Define to 1 if you have the `munmap' function. *\/\n-#define HAVE_MUNMAP 1\n-\n-\/* mmap() is no good without munmap() *\/\n-#if defined(HAVE_MMAP) && !defined(HAVE_MUNMAP)\n-#  undef \/**\/ HAVE_MMAP\n-#endif\n-\n-\/* Define to 1 if you have the <netdb.h> header file. *\/\n-\/* #undef HAVE_NETDB_H *\/\n-\n-\/* Define to 1 if you have the <netinet\/in.h> header file. *\/\n-\/* #undef HAVE_NETINET_IN_H *\/\n-\n@@ -70,1 +41,1 @@\n-#define HAVE_PTHREAD_H \/**\/\n+#define HAVE_PTHREAD_H 1\n@@ -75,3 +46,0 @@\n-\/* Define to 1 if you have the `stat' function. *\/\n-#define HAVE_STAT 1\n-\n@@ -93,12 +61,0 @@\n-\/* Define to 1 if you have the <sys\/mman.h> header file. *\/\n-#define HAVE_SYS_MMAN_H 1\n-\n-\/* Define to 1 if you have the <sys\/random.h> header file. *\/\n-\/* #define HAVE_SYS_RANDOM_H *\/\n-\n-\/* Define to 1 if you have the <sys\/select.h> header file. *\/\n-\/* #undef HAVE_SYS_SELECT_H *\/\n-\n-\/* Define to 1 if you have the <sys\/socket.h> header file. *\/\n-\/* #undef HAVE_SYS_SOCKET_H *\/\n-\n@@ -108,6 +64,0 @@\n-\/* Define to 1 if you have the <sys\/timeb.h> header file. *\/\n-#define HAVE_SYS_TIMEB_H 1\n-\n-\/* Define to 1 if you have the <sys\/time.h> header file. *\/\n-#define HAVE_SYS_TIME_H 1\n-\n@@ -136,1 +86,1 @@\n-#define PACKAGE_STRING \"libxml2 2.13.6\"\n+#define PACKAGE_STRING \"libxml2 2.14.5\"\n@@ -145,1 +95,1 @@\n-#define PACKAGE_VERSION \"2.13.6\"\n+#define PACKAGE_VERSION \"2.14.5\"\n@@ -152,3 +102,0 @@\n-\/* Support for IPv6 *\/\n-\/* #undef SUPPORT_IP6 *\/\n-\n@@ -156,1 +103,1 @@\n-#define VERSION \"2.13.6\"\n+#define VERSION \"2.14.5\"\n@@ -158,2 +105,2 @@\n-\/* Determine what socket length (socklen_t) data type is *\/\n-\/* #undef XML_SOCKLEN_T *\/\n+\/* System configuration directory (\/etc) *\/\n+#define XML_SYSCONFDIR \"\/usr\/local\/etc\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/linux\/config.h","additions":19,"deletions":72,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-#define LIBXML_DOTTED_VERSION \"2.13.6\"\n+#define LIBXML_DOTTED_VERSION \"2.14.5\"\n@@ -25,1 +25,1 @@\n-#define LIBXML_VERSION 21306\n+#define LIBXML_VERSION 21405\n@@ -47,1 +47,1 @@\n-#define LIBXML_TEST_VERSION xmlCheckVersion(21306);\n+#define LIBXML_TEST_VERSION xmlCheckVersion(21405);\n@@ -70,1 +70,1 @@\n- * Whether the DOM like tree manipulation API support is configured in\n+ * Always enabled since 2.14.0\n@@ -72,1 +72,0 @@\n-#if 1\n@@ -74,1 +73,0 @@\n-#endif\n@@ -130,9 +128,0 @@\n-\/**\n- * LIBXML_FTP_ENABLED:\n- *\n- * Whether the FTP support is configured in\n- *\/\n-#if 0\n-#define LIBXML_FTP_ENABLED\n-#endif\n-\n@@ -169,1 +158,1 @@\n- * Whether the deprecated APIs are compiled in for compatibility\n+ * Removed in 2.14\n@@ -171,3 +160,1 @@\n-#if 0\n-#define LIBXML_LEGACY_ENABLED\n-#endif\n+#undef LIBXML_LEGACY_ENABLED\n@@ -211,9 +198,0 @@\n-\/**\n- * LIBXML_XPTR_LOCS_ENABLED:\n- *\n- * Whether support for XPointer locations is configured in\n- *\/\n-#if 0\n-#define LIBXML_XPTR_LOCS_ENABLED\n-#endif\n-\n@@ -268,1 +246,1 @@\n- * Whether the Unicode related interfaces are compiled in\n+ * Removed in 2.14\n@@ -270,3 +248,1 @@\n-#if 0\n-#define LIBXML_UNICODE_ENABLED\n-#endif\n+#undef LIBXML_UNICODE_ENABLED\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/linux\/include\/libxml\/xmlversion.h","additions":8,"deletions":32,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -4,2 +4,3 @@\n-\/* A form that will not confuse apibuild.py *\/\n-#define ATTRIBUTE_DESTRUCTOR __attribute__((destructor))\n+\/* Define to 1 if you have the declaration of `getentropy', and to 0 if you\n+   don't. *\/\n+#define HAVE_DECL_GETENTROPY 1\n@@ -7,2 +8,3 @@\n-\/* Define to 1 if you have the <arpa\/inet.h> header file. *\/\n-\/* #undef HAVE_ARPA_INET_H *\/\n+\/* Define to 1 if you have the declaration of `glob', and to 0 if you don't.\n+   *\/\n+#define HAVE_DECL_GLOB 1\n@@ -10,2 +12,3 @@\n-\/* Define if __attribute__((destructor)) is accepted *\/\n-#define HAVE_ATTRIBUTE_DESTRUCTOR 1\n+\/* Define to 1 if you have the declaration of `mmap', and to 0 if you don't.\n+   *\/\n+#define HAVE_DECL_MMAP 1\n@@ -19,17 +22,2 @@\n-\/* Define to 1 if you have the <dl.h> header file. *\/\n-\/* #undef HAVE_DL_H *\/\n-\n-\/* Define to 1 if you have the <fcntl.h> header file. *\/\n-#define HAVE_FCNTL_H 1\n-\n-\/* Define to 1 if you have the 'ftime' function. *\/\n-#define HAVE_FTIME 1\n-\n-\/* getentropy *\/\n-#define HAVE_GETENTROPY 1\n-\n-\/* Define to 1 if you have the 'gettimeofday' function. *\/\n-#define HAVE_GETTIMEOFDAY 1\n-\n-\/* Define to 1 if you have the <glob.h> header file. *\/\n-#define HAVE_GLOB_H 1\n+\/* Define to 1 if the system has the `destructor' function attribute *\/\n+#define HAVE_FUNC_ATTRIBUTE_DESTRUCTOR 1\n@@ -49,17 +37,0 @@\n-\/* Define to 1 if you have the 'mmap' function. *\/\n-#define HAVE_MMAP 1\n-\n-\/* Define to 1 if you have the 'munmap' function. *\/\n-#define HAVE_MUNMAP 1\n-\n-\/* mmap() is no good without munmap() *\/\n-#if defined(HAVE_MMAP) && !defined(HAVE_MUNMAP)\n-#  undef \/**\/ HAVE_MMAP\n-#endif\n-\n-\/* Define to 1 if you have the <netdb.h> header file. *\/\n-\/* #undef HAVE_NETDB_H *\/\n-\n-\/* Define to 1 if you have the <netinet\/in.h> header file. *\/\n-\/* #undef HAVE_NETINET_IN_H *\/\n-\n@@ -70,1 +41,1 @@\n-#define HAVE_PTHREAD_H \/**\/\n+#define HAVE_PTHREAD_H 1\n@@ -75,3 +46,0 @@\n-\/* Define to 1 if you have the 'stat' function. *\/\n-#define HAVE_STAT 1\n-\n@@ -93,12 +61,0 @@\n-\/* Define to 1 if you have the <sys\/mman.h> header file. *\/\n-#define HAVE_SYS_MMAN_H 1\n-\n-\/* Define to 1 if you have the <sys\/random.h> header file. *\/\n-#define HAVE_SYS_RANDOM_H 1\n-\n-\/* Define to 1 if you have the <sys\/select.h> header file. *\/\n-\/* #undef HAVE_SYS_SELECT_H *\/\n-\n-\/* Define to 1 if you have the <sys\/socket.h> header file. *\/\n-\/* #undef HAVE_SYS_SOCKET_H *\/\n-\n@@ -108,6 +64,0 @@\n-\/* Define to 1 if you have the <sys\/timeb.h> header file. *\/\n-#define HAVE_SYS_TIMEB_H 1\n-\n-\/* Define to 1 if you have the <sys\/time.h> header file. *\/\n-#define HAVE_SYS_TIME_H 1\n-\n@@ -136,1 +86,1 @@\n-#define PACKAGE_STRING \"libxml2 2.13.6\"\n+#define PACKAGE_STRING \"libxml2 2.14.5\"\n@@ -145,1 +95,1 @@\n-#define PACKAGE_VERSION \"2.13.6\"\n+#define PACKAGE_VERSION \"2.14.5\"\n@@ -147,1 +97,1 @@\n-\/* Define to 1 if all of the C89 standard headers exist (not just the ones\n+\/* Define to 1 if all of the C90 standard headers exist (not just the ones\n@@ -152,3 +102,0 @@\n-\/* Support for IPv6 *\/\n-\/* #undef SUPPORT_IP6 *\/\n-\n@@ -156,1 +103,1 @@\n-#define VERSION \"2.13.6\"\n+#define VERSION \"2.14.5\"\n@@ -158,2 +105,2 @@\n-\/* Determine what socket length (socklen_t) data type is *\/\n-\/* #undef XML_SOCKLEN_T *\/\n+\/* System configuration directory (\/etc) *\/\n+#define XML_SYSCONFDIR \"\/usr\/local\/etc\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/mac\/config.h","additions":18,"deletions":71,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-#define LIBXML_DOTTED_VERSION \"2.13.6\"\n+#define LIBXML_DOTTED_VERSION \"2.14.5\"\n@@ -25,1 +25,1 @@\n-#define LIBXML_VERSION 21306\n+#define LIBXML_VERSION 21405\n@@ -32,1 +32,1 @@\n-#define LIBXML_VERSION_STRING \"21306\"\n+#define LIBXML_VERSION_STRING \"21405\"\n@@ -39,1 +39,1 @@\n-#define LIBXML_VERSION_EXTRA \"-GITv2.13.6\"\n+#define LIBXML_VERSION_EXTRA \"\"\n@@ -47,1 +47,1 @@\n-#define LIBXML_TEST_VERSION xmlCheckVersion(21306);\n+#define LIBXML_TEST_VERSION xmlCheckVersion(21405);\n@@ -70,1 +70,1 @@\n- * Whether the DOM like tree manipulation API support is configured in\n+ * Always enabled since 2.14.0\n@@ -72,1 +72,0 @@\n-#if 1\n@@ -74,1 +73,0 @@\n-#endif\n@@ -130,9 +128,0 @@\n-\/**\n- * LIBXML_FTP_ENABLED:\n- *\n- * Whether the FTP support is configured in\n- *\/\n-#if 0\n-#define LIBXML_FTP_ENABLED\n-#endif\n-\n@@ -169,1 +158,1 @@\n- * Whether the deprecated APIs are compiled in for compatibility\n+ * Removed in 2.14\n@@ -171,3 +160,1 @@\n-#if 0\n-#define LIBXML_LEGACY_ENABLED\n-#endif\n+#undef LIBXML_LEGACY_ENABLED\n@@ -211,9 +198,0 @@\n-\/**\n- * LIBXML_XPTR_LOCS_ENABLED:\n- *\n- * Whether support for XPointer locations is configured in\n- *\/\n-#if 0\n-#define LIBXML_XPTR_LOCS_ENABLED\n-#endif\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/mac\/include\/libxml\/xmlversion.h","additions":8,"deletions":30,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+ Copyright (C) The Libxml2 Contributors.\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/Copyright","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,10 @@\n- * HTMLparser.c : an HTML 4.0 non-verifying parser\n+ * HTMLparser.c : an HTML parser\n+ *\n+ * References:\n+ *   HTML Living Standard\n+ *     https:\/\/html.spec.whatwg.org\/multipage\/parsing.html\n+ *\n+ * Tokenization now conforms to HTML5. Tree construction still follows\n+ * a custom, non-standard implementation. See:\n+ *\n+ *     https:\/\/gitlab.gnome.org\/GNOME\/libxml2\/-\/issues\/211\n@@ -30,0 +39,1 @@\n+#include \"private\/dict.h\"\n@@ -34,0 +44,1 @@\n+#include \"private\/memory.h\"\n@@ -38,0 +49,1 @@\n+#define HTML_MAX_ATTRS 100000000 \/* 100 million *\/\n@@ -41,0 +53,51 @@\n+#define IS_WS_HTML(c) \\\n+    (((c) == 0x20) || \\\n+     (((c) >= 0x09) && ((c) <= 0x0D) && ((c) != 0x0B)))\n+\n+#define IS_HEX_DIGIT(c) \\\n+    ((IS_ASCII_DIGIT(c)) || \\\n+     ((((c) | 0x20) >= 'a') && (((c) | 0x20) <= 'f')))\n+\n+#define IS_UPPER(c) \\\n+    (((c) >= 'A') && ((c) <= 'Z'))\n+\n+#define IS_ALNUM(c) \\\n+    (IS_ASCII_LETTER(c) || IS_ASCII_DIGIT(c))\n+\n+typedef enum {\n+    INSERT_INITIAL = 1,\n+    INSERT_IN_HEAD = 3,\n+    INSERT_IN_BODY = 10\n+} htmlInsertMode;\n+\n+typedef const unsigned htmlAsciiMask[2];\n+\n+static htmlAsciiMask MASK_DQ = {\n+    0,\n+    1u << ('\"' - 32),\n+};\n+static htmlAsciiMask MASK_SQ = {\n+    0,\n+    1u << ('\\'' - 32),\n+};\n+static htmlAsciiMask MASK_GT = {\n+    0,\n+    1u << ('>' - 32),\n+};\n+static htmlAsciiMask MASK_DASH = {\n+    0,\n+    1u << ('-' - 32),\n+};\n+static htmlAsciiMask MASK_WS_GT = {\n+    1u << 0x09 | 1u << 0x0A | 1u << 0x0C | 1u << 0x0D,\n+    1u << (' ' - 32) | 1u << ('>' - 32),\n+};\n+static htmlAsciiMask MASK_DQ_GT = {\n+    0,\n+    1u << ('\"' - 32) | 1u << ('>' - 32),\n+};\n+static htmlAsciiMask MASK_SQ_GT = {\n+    0,\n+    1u << ('\\'' - 32) | 1u << ('>' - 32),\n+};\n+\n@@ -43,3 +106,2 @@\n-xmlChar * htmlDecodeEntities(htmlParserCtxtPtr ctxt, int len,\n-                 xmlChar end, xmlChar  end2, xmlChar end3);\n-static void htmlParseComment(htmlParserCtxtPtr ctxt);\n+static int\n+htmlParseElementInternal(htmlParserCtxtPtr ctxt);\n@@ -48,3 +110,3 @@\n- *                                    *\n- *        Some factorized error routines                *\n- *                                    *\n+ *                                                                      *\n+ *              Some factorized error routines                          *\n+ *                                                                      *\n@@ -84,17 +146,0 @@\n-\/**\n- * htmlParseErrInt:\n- * @ctxt:  an HTML parser context\n- * @error:  the error number\n- * @msg:  the error message\n- * @val:  integer info\n- *\n- * Handle a fatal parser error, i.e. violating Well-Formedness constraints\n- *\/\n-static void LIBXML_ATTR_FORMAT(3,0)\n-htmlParseErrInt(xmlParserCtxtPtr ctxt, xmlParserErrors error,\n-             const char *msg, int val)\n-{\n-    xmlCtxtErr(ctxt, NULL, XML_FROM_HTML, error, XML_ERR_ERROR,\n-               NULL, NULL, NULL, val, msg, val);\n-}\n-\n@@ -102,3 +147,3 @@\n- *                                    *\n- *    Parser stacks related functions and macros        *\n- *                                    *\n+ *                                                                      *\n+ *      Parser stacks related functions and macros              *\n+ *                                                                      *\n@@ -119,4 +164,4 @@\n-    if ((ctxt->html < 3) && (xmlStrEqual(value, BAD_CAST \"head\")))\n-        ctxt->html = 3;\n-    if ((ctxt->html < 10) && (xmlStrEqual(value, BAD_CAST \"body\")))\n-        ctxt->html = 10;\n+    if ((ctxt->html < INSERT_IN_HEAD) && (xmlStrEqual(value, BAD_CAST \"head\")))\n+        ctxt->html = INSERT_IN_HEAD;\n+    if ((ctxt->html < INSERT_IN_BODY) && (xmlStrEqual(value, BAD_CAST \"body\")))\n+        ctxt->html = INSERT_IN_BODY;\n@@ -124,1 +169,0 @@\n-        size_t newSize = ctxt->nameMax * 2;\n@@ -126,0 +170,1 @@\n+        int newSize;\n@@ -127,3 +172,3 @@\n-        tmp = xmlRealloc((xmlChar **) ctxt->nameTab,\n-                         newSize * sizeof(ctxt->nameTab[0]));\n-        if (tmp == NULL) {\n+        newSize = xmlGrowCapacity(ctxt->nameMax, sizeof(tmp[0]),\n+                                  10, XML_MAX_ITEMS);\n+        if (newSize < 0) {\n@@ -133,0 +178,5 @@\n+        tmp = xmlRealloc(ctxt->nameTab, newSize * sizeof(tmp[0]));\n+        if (tmp == NULL) {\n+            htmlErrMemory(ctxt);\n+            return(-1);\n+        }\n@@ -180,8 +230,11 @@\n-        if (ctxt->nodeInfoMax == 0)\n-                ctxt->nodeInfoMax = 5;\n-        ctxt->nodeInfoMax *= 2;\n-        ctxt->nodeInfoTab = (htmlParserNodeInfo *)\n-                         xmlRealloc((htmlParserNodeInfo *)ctxt->nodeInfoTab,\n-                                    ctxt->nodeInfoMax *\n-                                    sizeof(ctxt->nodeInfoTab[0]));\n-        if (ctxt->nodeInfoTab == NULL) {\n+        xmlParserNodeInfo *tmp;\n+        int newSize;\n+\n+        newSize = xmlGrowCapacity(ctxt->nodeInfoMax, sizeof(tmp[0]),\n+                                  5, XML_MAX_ITEMS);\n+        if (newSize < 0) {\n+            htmlErrMemory(ctxt);\n+            return (0);\n+        }\n+        tmp = xmlRealloc(ctxt->nodeInfoTab, newSize * sizeof(tmp[0]));\n+        if (tmp == NULL) {\n@@ -191,0 +244,2 @@\n+        ctxt->nodeInfoTab = tmp;\n+        ctxt->nodeInfoMax = newSize;\n@@ -241,3 +296,0 @@\n- *   NEXT    Skip to the next character, this does the proper decoding\n- *           in UTF-8 mode. It also pop-up unfinished entities on the fly.\n- *   NEXTL(l) Skip the current unicode character of l xmlChars long.\n@@ -261,2 +313,2 @@\n-    (ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \\\n-    xmlParserShrink(ctxt);\n+        (ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \\\n+        xmlParserShrink(ctxt);\n@@ -267,1 +319,1 @@\n-    xmlParserGrow(ctxt);\n+        xmlParserGrow(ctxt);\n@@ -274,23 +326,0 @@\n-#define NEXT xmlNextChar(ctxt)\n-\n-#define RAW (*ctxt->input->cur)\n-\n-\n-#define NEXTL(l) do {                            \\\n-    if (*(ctxt->input->cur) == '\\n') {                    \\\n-    ctxt->input->line++; ctxt->input->col = 1;            \\\n-    } else ctxt->input->col++;                        \\\n-    ctxt->input->cur += l;                        \\\n-  } while (0)\n-\n-\/************\n-    \\\n-    if (*ctxt->input->cur == '%') xmlParserHandlePEReference(ctxt);    \\\n-    if (*ctxt->input->cur == '&') xmlParserHandleReference(ctxt);\n- ************\/\n-\n-#define CUR_CHAR(l) htmlCurrentChar(ctxt, &l)\n-\n-#define COPY_BUF(l,b,i,v)                        \\\n-    if (l == 1) b[i++] = v;                        \\\n-    else i += xmlCopyChar(l,&b[i],v)\n@@ -340,3 +369,1 @@\n-    while (((*cur >= 'A') && (*cur <= 'Z')) ||\n-           ((*cur >= 'a') && (*cur <= 'z')) ||\n-           ((*cur >= '0') && (*cur <= '9')) ||\n+    while ((IS_ALNUM(*cur)) ||\n@@ -353,13 +380,6 @@\n-\/**\n- * htmlCurrentChar:\n- * @ctxt:  the HTML parser context\n- * @len:  pointer to the length of the char read\n- *\n- * The current char value, if using UTF-8 this may actually span multiple\n- * bytes in the input buffer. Implement the end of line normalization:\n- * 2.11 End-of-Line Handling\n- * If the encoding is unspecified, in the case we find an ISO-Latin-1\n- * char, then the encoding converter is plugged in automatically.\n- *\n- * Returns the current char value and its length\n- *\/\n+static int\n+htmlMaskMatch(htmlAsciiMask mask, unsigned c) {\n+    if (c >= 64)\n+        return(0);\n+    return((mask[c\/32] >> (c & 31)) & 1);\n+}\n@@ -368,4 +388,30 @@\n-htmlCurrentChar(xmlParserCtxtPtr ctxt, int *len) {\n-    const unsigned char *cur;\n-    unsigned char c;\n-    unsigned int val;\n+htmlValidateUtf8(xmlParserCtxtPtr ctxt, const xmlChar *str, size_t len,\n+                 int partial) {\n+    unsigned c = str[0];\n+    int size;\n+\n+    if (c < 0xC2) {\n+        goto invalid;\n+    } else if (c < 0xE0) {\n+        if (len < 2)\n+            goto incomplete;\n+        if ((str[1] & 0xC0) != 0x80)\n+            goto invalid;\n+        size = 2;\n+    } else if (c < 0xF0) {\n+        unsigned v;\n+\n+        if (len < 3)\n+            goto incomplete;\n+\n+        v = str[1] << 8 | str[2]; \/* hint to generate 16-bit load *\/\n+        v |= c << 16;\n+\n+        if (((v & 0x00C0C0) != 0x008080) ||\n+            ((v & 0x0F2000) == 0x000000) ||\n+            ((v & 0x0F2000) == 0x0D2000))\n+            goto invalid;\n+\n+        size = 3;\n+    } else {\n+        unsigned v;\n@@ -373,2 +419,2 @@\n-    if (ctxt->input->end - ctxt->input->cur < INPUT_CHUNK)\n-        xmlParserGrow(ctxt);\n+        if (len < 4)\n+            goto incomplete;\n@@ -376,2 +422,1 @@\n-    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0) {\n-        xmlChar * guess;\n+        v = c << 24 | str[1] << 16 | str[2] << 8 | str[3];\n@@ -379,20 +424,3 @@\n-        \/*\n-         * Assume it's a fixed length encoding (1) with\n-         * a compatible encoding for the ASCII set, since\n-         * HTML constructs only use < 128 chars\n-         *\/\n-        if (*ctxt->input->cur < 0x80) {\n-            if (*ctxt->input->cur == 0) {\n-                if (ctxt->input->cur < ctxt->input->end) {\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-                                    \"Char 0x%X out of allowed range\\n\", 0);\n-                    *len = 1;\n-                    return(' ');\n-                } else {\n-                    *len = 0;\n-                    return(0);\n-                }\n-            }\n-            *len = 1;\n-            return(*ctxt->input->cur);\n-        }\n+        if (((v & 0x00C0C0C0) != 0x00808080) ||\n+            (v < 0xF0900000) || (v >= 0xF4900000))\n+            goto invalid;\n@@ -400,11 +428,1 @@\n-        \/*\n-         * Humm this is bad, do an automatic flow conversion\n-         *\/\n-        guess = htmlFindEncoding(ctxt);\n-        if (guess == NULL) {\n-            xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);\n-        } else {\n-            xmlSwitchEncodingName(ctxt, (const char *) guess);\n-            xmlFree(guess);\n-        }\n-        ctxt->input->flags |= XML_INPUT_HAS_ENCODING;\n+        size = 4;\n@@ -413,15 +431,1 @@\n-    \/*\n-     * We are supposed to handle UTF8, check it's valid\n-     * From rfc2044: encoding of the Unicode values on UTF-8:\n-     *\n-     * UCS-4 range (hex.)           UTF-8 octet sequence (binary)\n-     * 0000 0000-0000 007F   0xxxxxxx\n-     * 0000 0080-0000 07FF   110xxxxx 10xxxxxx\n-     * 0000 0800-0000 FFFF   1110xxxx 10xxxxxx 10xxxxxx\n-     *\n-     * Check for the 0x110000 limit too\n-     *\/\n-    cur = ctxt->input->cur;\n-    c = *cur;\n-    if (c & 0x80) {\n-        size_t avail;\n+    return(size);\n@@ -429,60 +433,3 @@\n-        if ((c & 0x40) == 0)\n-            goto encoding_error;\n-\n-        avail = ctxt->input->end - ctxt->input->cur;\n-\n-        if ((avail < 2) || ((cur[1] & 0xc0) != 0x80))\n-            goto encoding_error;\n-        if ((c & 0xe0) == 0xe0) {\n-            if ((avail < 3) || ((cur[2] & 0xc0) != 0x80))\n-                goto encoding_error;\n-            if ((c & 0xf0) == 0xf0) {\n-                if (((c & 0xf8) != 0xf0) ||\n-                    (avail < 4) || ((cur[3] & 0xc0) != 0x80))\n-                    goto encoding_error;\n-                \/* 4-byte code *\/\n-                *len = 4;\n-                val = (cur[0] & 0x7) << 18;\n-                val |= (cur[1] & 0x3f) << 12;\n-                val |= (cur[2] & 0x3f) << 6;\n-                val |= cur[3] & 0x3f;\n-                if (val < 0x10000)\n-                    goto encoding_error;\n-            } else {\n-              \/* 3-byte code *\/\n-                *len = 3;\n-                val = (cur[0] & 0xf) << 12;\n-                val |= (cur[1] & 0x3f) << 6;\n-                val |= cur[2] & 0x3f;\n-                if (val < 0x800)\n-                    goto encoding_error;\n-            }\n-        } else {\n-          \/* 2-byte code *\/\n-            *len = 2;\n-            val = (cur[0] & 0x1f) << 6;\n-            val |= cur[1] & 0x3f;\n-            if (val < 0x80)\n-                goto encoding_error;\n-        }\n-        if (!IS_CHAR(val)) {\n-            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-                            \"Char 0x%X out of allowed range\\n\", val);\n-        }\n-        return(val);\n-    } else {\n-        if (*ctxt->input->cur == 0) {\n-            if (ctxt->input->cur < ctxt->input->end) {\n-                htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-                                \"Char 0x%X out of allowed range\\n\", 0);\n-                *len = 1;\n-                return(' ');\n-            } else {\n-                *len = 0;\n-                return(0);\n-            }\n-        }\n-        \/* 1-byte code *\/\n-        *len = 1;\n-        return(*ctxt->input->cur);\n-    }\n+incomplete:\n+    if (partial)\n+        return(0);\n@@ -490,2 +437,7 @@\n-encoding_error:\n-    xmlCtxtErrIO(ctxt, XML_ERR_INVALID_ENCODING, NULL);\n+invalid:\n+    \/* Only report the first error *\/\n+    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {\n+        htmlParseErr(ctxt, XML_ERR_INVALID_ENCODING,\n+                     \"Invalid bytes in character encoding\\n\", NULL, NULL);\n+        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;\n+    }\n@@ -493,4 +445,1 @@\n-    if ((ctxt->input->flags & XML_INPUT_HAS_ENCODING) == 0)\n-        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);\n-    *len = 1;\n-    return(*ctxt->input->cur);\n+    return(-1);\n@@ -510,0 +459,2 @@\n+    const xmlChar *cur = ctxt->input->cur;\n+    size_t avail = ctxt->input->end - cur;\n@@ -511,0 +462,2 @@\n+    int line = ctxt->input->line;\n+    int col = ctxt->input->col;\n@@ -512,9 +465,25 @@\n-    while (IS_BLANK_CH(*(ctxt->input->cur))) {\n-        if (*(ctxt->input->cur) == '\\n') {\n-            ctxt->input->line++; ctxt->input->col = 1;\n-        } else ctxt->input->col++;\n-        ctxt->input->cur++;\n-        if (*ctxt->input->cur == 0)\n-            xmlParserGrow(ctxt);\n-    if (res < INT_MAX)\n-        res++;\n+    while (!PARSER_STOPPED(ctxt)) {\n+        if (avail == 0) {\n+            ctxt->input->cur = cur;\n+            GROW;\n+            cur = ctxt->input->cur;\n+            avail = ctxt->input->end - cur;\n+\n+            if (avail == 0)\n+                break;\n+        }\n+\n+        if (*cur == '\\n') {\n+            line++;\n+            col = 1;\n+        } else if (IS_WS_HTML(*cur)) {\n+            col++;\n+        } else {\n+            break;\n+        }\n+\n+        cur += 1;\n+        avail -= 1;\n+\n+        if (res < INT_MAX)\n+            res++;\n@@ -522,0 +491,8 @@\n+\n+    ctxt->input->cur = cur;\n+    ctxt->input->line = line;\n+    ctxt->input->col = col;\n+\n+    if (res > 8)\n+        GROW;\n+\n@@ -528,3 +505,3 @@\n- *                                    *\n- *    The list of HTML elements and their properties        *\n- *                                    *\n+ *                                                                      *\n+ *      The list of HTML elements and their properties          *\n+ *                                                                      *\n@@ -543,1 +520,0 @@\n-    , subElements , impliedsubelt , Attributes, userdata\n@@ -546,151 +522,6 @@\n-\/* Definitions and a couple of vars for HTML Elements *\/\n-\n-#define FONTSTYLE \"tt\", \"i\", \"b\", \"u\", \"s\", \"strike\", \"big\", \"small\"\n-#define NB_FONTSTYLE 8\n-#define PHRASE \"em\", \"strong\", \"dfn\", \"code\", \"samp\", \"kbd\", \"var\", \"cite\", \"abbr\", \"acronym\"\n-#define NB_PHRASE 10\n-#define SPECIAL \"a\", \"img\", \"applet\", \"embed\", \"object\", \"font\", \"basefont\", \"br\", \"script\", \"map\", \"q\", \"sub\", \"sup\", \"span\", \"bdo\", \"iframe\"\n-#define NB_SPECIAL 16\n-#define INLINE FONTSTYLE, PHRASE, SPECIAL, FORMCTRL\n-#define NB_INLINE NB_PCDATA + NB_FONTSTYLE + NB_PHRASE + NB_SPECIAL + NB_FORMCTRL\n-#define BLOCK HEADING, LIST, \"pre\", \"p\", \"dl\", \"div\", \"center\", \"noscript\", \"noframes\", \"blockquote\", \"form\", \"isindex\", \"hr\", \"table\", \"fieldset\", \"address\"\n-#define NB_BLOCK NB_HEADING + NB_LIST + 14\n-#define FORMCTRL \"input\", \"select\", \"textarea\", \"label\", \"button\"\n-#define NB_FORMCTRL 5\n-#define PCDATA\n-#define NB_PCDATA 0\n-#define HEADING \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"\n-#define NB_HEADING 6\n-#define LIST \"ul\", \"ol\", \"dir\", \"menu\"\n-#define NB_LIST 4\n-#define MODIFIER\n-#define NB_MODIFIER 0\n-#define FLOW BLOCK,INLINE\n-#define NB_FLOW NB_BLOCK + NB_INLINE\n-#define EMPTY NULL\n-\n-\n-static const char* const html_flow[] = { FLOW, NULL } ;\n-static const char* const html_inline[] = { INLINE, NULL } ;\n-\n-\/* placeholders: elts with content but no subelements *\/\n-static const char* const html_pcdata[] = { NULL } ;\n-#define html_cdata html_pcdata\n-\n-\n-\/* ... and for HTML Attributes *\/\n-\n-#define COREATTRS \"id\", \"class\", \"style\", \"title\"\n-#define NB_COREATTRS 4\n-#define I18N \"lang\", \"dir\"\n-#define NB_I18N 2\n-#define EVENTS \"onclick\", \"ondblclick\", \"onmousedown\", \"onmouseup\", \"onmouseover\", \"onmouseout\", \"onkeypress\", \"onkeydown\", \"onkeyup\"\n-#define NB_EVENTS 9\n-#define ATTRS COREATTRS,I18N,EVENTS\n-#define NB_ATTRS NB_NB_COREATTRS + NB_I18N + NB_EVENTS\n-#define CELLHALIGN \"align\", \"char\", \"charoff\"\n-#define NB_CELLHALIGN 3\n-#define CELLVALIGN \"valign\"\n-#define NB_CELLVALIGN 1\n-\n-static const char* const html_attrs[] = { ATTRS, NULL } ;\n-static const char* const core_i18n_attrs[] = { COREATTRS, I18N, NULL } ;\n-static const char* const core_attrs[] = { COREATTRS, NULL } ;\n-static const char* const i18n_attrs[] = { I18N, NULL } ;\n-\n-\n-\/* Other declarations that should go inline ... *\/\n-static const char* const a_attrs[] = { ATTRS, \"charset\", \"type\", \"name\",\n-    \"href\", \"hreflang\", \"rel\", \"rev\", \"accesskey\", \"shape\", \"coords\",\n-    \"tabindex\", \"onfocus\", \"onblur\", NULL } ;\n-static const char* const target_attr[] = { \"target\", NULL } ;\n-static const char* const rows_cols_attr[] = { \"rows\", \"cols\", NULL } ;\n-static const char* const alt_attr[] = { \"alt\", NULL } ;\n-static const char* const src_alt_attrs[] = { \"src\", \"alt\", NULL } ;\n-static const char* const href_attrs[] = { \"href\", NULL } ;\n-static const char* const clear_attrs[] = { \"clear\", NULL } ;\n-static const char* const inline_p[] = { INLINE, \"p\", NULL } ;\n-\n-static const char* const flow_param[] = { FLOW, \"param\", NULL } ;\n-static const char* const applet_attrs[] = { COREATTRS , \"codebase\",\n-        \"archive\", \"alt\", \"name\", \"height\", \"width\", \"align\",\n-        \"hspace\", \"vspace\", NULL } ;\n-static const char* const area_attrs[] = { \"shape\", \"coords\", \"href\", \"nohref\",\n-    \"tabindex\", \"accesskey\", \"onfocus\", \"onblur\", NULL } ;\n-static const char* const basefont_attrs[] =\n-    { \"id\", \"size\", \"color\", \"face\", NULL } ;\n-static const char* const quote_attrs[] = { ATTRS, \"cite\", NULL } ;\n-static const char* const body_contents[] = { FLOW, \"ins\", \"del\", NULL } ;\n-static const char* const body_attrs[] = { ATTRS, \"onload\", \"onunload\", NULL } ;\n-static const char* const body_depr[] = { \"background\", \"bgcolor\", \"text\",\n-    \"link\", \"vlink\", \"alink\", NULL } ;\n-static const char* const button_attrs[] = { ATTRS, \"name\", \"value\", \"type\",\n-    \"disabled\", \"tabindex\", \"accesskey\", \"onfocus\", \"onblur\", NULL } ;\n-\n-\n-static const char* const col_attrs[] = { ATTRS, \"span\", \"width\", CELLHALIGN, CELLVALIGN, NULL } ;\n-static const char* const col_elt[] = { \"col\", NULL } ;\n-static const char* const edit_attrs[] = { ATTRS, \"datetime\", \"cite\", NULL } ;\n-static const char* const compact_attrs[] = { ATTRS, \"compact\", NULL } ;\n-static const char* const dl_contents[] = { \"dt\", \"dd\", NULL } ;\n-static const char* const compact_attr[] = { \"compact\", NULL } ;\n-static const char* const label_attr[] = { \"label\", NULL } ;\n-static const char* const fieldset_contents[] = { FLOW, \"legend\" } ;\n-static const char* const font_attrs[] = { COREATTRS, I18N, \"size\", \"color\", \"face\" , NULL } ;\n-static const char* const form_contents[] = { HEADING, LIST, INLINE, \"pre\", \"p\", \"div\", \"center\", \"noscript\", \"noframes\", \"blockquote\", \"isindex\", \"hr\", \"table\", \"fieldset\", \"address\", NULL } ;\n-static const char* const form_attrs[] = { ATTRS, \"method\", \"enctype\", \"accept\", \"name\", \"onsubmit\", \"onreset\", \"accept-charset\", NULL } ;\n-static const char* const frame_attrs[] = { COREATTRS, \"longdesc\", \"name\", \"src\", \"frameborder\", \"marginwidth\", \"marginheight\", \"noresize\", \"scrolling\" , NULL } ;\n-static const char* const frameset_attrs[] = { COREATTRS, \"rows\", \"cols\", \"onload\", \"onunload\", NULL } ;\n-static const char* const frameset_contents[] = { \"frameset\", \"frame\", \"noframes\", NULL } ;\n-static const char* const head_attrs[] = { I18N, \"profile\", NULL } ;\n-static const char* const head_contents[] = { \"title\", \"isindex\", \"base\", \"script\", \"style\", \"meta\", \"link\", \"object\", NULL } ;\n-static const char* const hr_depr[] = { \"align\", \"noshade\", \"size\", \"width\", NULL } ;\n-static const char* const version_attr[] = { \"version\", NULL } ;\n-static const char* const html_content[] = { \"head\", \"body\", \"frameset\", NULL } ;\n-static const char* const iframe_attrs[] = { COREATTRS, \"longdesc\", \"name\", \"src\", \"frameborder\", \"marginwidth\", \"marginheight\", \"scrolling\", \"align\", \"height\", \"width\", NULL } ;\n-static const char* const img_attrs[] = { ATTRS, \"longdesc\", \"name\", \"height\", \"width\", \"usemap\", \"ismap\", NULL } ;\n-static const char* const embed_attrs[] = { COREATTRS, \"align\", \"alt\", \"border\", \"code\", \"codebase\", \"frameborder\", \"height\", \"hidden\", \"hspace\", \"name\", \"palette\", \"pluginspace\", \"pluginurl\", \"src\", \"type\", \"units\", \"vspace\", \"width\", NULL } ;\n-static const char* const input_attrs[] = { ATTRS, \"type\", \"name\", \"value\", \"checked\", \"disabled\", \"readonly\", \"size\", \"maxlength\", \"src\", \"alt\", \"usemap\", \"ismap\", \"tabindex\", \"accesskey\", \"onfocus\", \"onblur\", \"onselect\", \"onchange\", \"accept\", NULL } ;\n-static const char* const prompt_attrs[] = { COREATTRS, I18N, \"prompt\", NULL } ;\n-static const char* const label_attrs[] = { ATTRS, \"for\", \"accesskey\", \"onfocus\", \"onblur\", NULL } ;\n-static const char* const legend_attrs[] = { ATTRS, \"accesskey\", NULL } ;\n-static const char* const align_attr[] = { \"align\", NULL } ;\n-static const char* const link_attrs[] = { ATTRS, \"charset\", \"href\", \"hreflang\", \"type\", \"rel\", \"rev\", \"media\", NULL } ;\n-static const char* const map_contents[] = { BLOCK, \"area\", NULL } ;\n-static const char* const name_attr[] = { \"name\", NULL } ;\n-static const char* const action_attr[] = { \"action\", NULL } ;\n-static const char* const blockli_elt[] = { BLOCK, \"li\", NULL } ;\n-static const char* const meta_attrs[] = { I18N, \"http-equiv\", \"name\", \"scheme\", \"charset\", NULL } ;\n-static const char* const content_attr[] = { \"content\", NULL } ;\n-static const char* const type_attr[] = { \"type\", NULL } ;\n-static const char* const noframes_content[] = { \"body\", FLOW MODIFIER, NULL } ;\n-static const char* const object_contents[] = { FLOW, \"param\", NULL } ;\n-static const char* const object_attrs[] = { ATTRS, \"declare\", \"classid\", \"codebase\", \"data\", \"type\", \"codetype\", \"archive\", \"standby\", \"height\", \"width\", \"usemap\", \"name\", \"tabindex\", NULL } ;\n-static const char* const object_depr[] = { \"align\", \"border\", \"hspace\", \"vspace\", NULL } ;\n-static const char* const ol_attrs[] = { \"type\", \"compact\", \"start\", NULL} ;\n-static const char* const option_elt[] = { \"option\", NULL } ;\n-static const char* const optgroup_attrs[] = { ATTRS, \"disabled\", NULL } ;\n-static const char* const option_attrs[] = { ATTRS, \"disabled\", \"label\", \"selected\", \"value\", NULL } ;\n-static const char* const param_attrs[] = { \"id\", \"value\", \"valuetype\", \"type\", NULL } ;\n-static const char* const width_attr[] = { \"width\", NULL } ;\n-static const char* const pre_content[] = { PHRASE, \"tt\", \"i\", \"b\", \"u\", \"s\", \"strike\", \"a\", \"br\", \"script\", \"map\", \"q\", \"span\", \"bdo\", \"iframe\", NULL } ;\n-static const char* const script_attrs[] = { \"charset\", \"src\", \"defer\", \"event\", \"for\", NULL } ;\n-static const char* const language_attr[] = { \"language\", NULL } ;\n-static const char* const select_content[] = { \"optgroup\", \"option\", NULL } ;\n-static const char* const select_attrs[] = { ATTRS, \"name\", \"size\", \"multiple\", \"disabled\", \"tabindex\", \"onfocus\", \"onblur\", \"onchange\", NULL } ;\n-static const char* const style_attrs[] = { I18N, \"media\", \"title\", NULL } ;\n-static const char* const table_attrs[] = { ATTRS, \"summary\", \"width\", \"border\", \"frame\", \"rules\", \"cellspacing\", \"cellpadding\", \"datapagesize\", NULL } ;\n-static const char* const table_depr[] = { \"align\", \"bgcolor\", NULL } ;\n-static const char* const table_contents[] = { \"caption\", \"col\", \"colgroup\", \"thead\", \"tfoot\", \"tbody\", \"tr\", NULL} ;\n-static const char* const tr_elt[] = { \"tr\", NULL } ;\n-static const char* const talign_attrs[] = { ATTRS, CELLHALIGN, CELLVALIGN, NULL} ;\n-static const char* const th_td_depr[] = { \"nowrap\", \"bgcolor\", \"width\", \"height\", NULL } ;\n-static const char* const th_td_attr[] = { ATTRS, \"abbr\", \"axis\", \"headers\", \"scope\", \"rowspan\", \"colspan\", CELLHALIGN, CELLVALIGN, NULL } ;\n-static const char* const textarea_attrs[] = { ATTRS, \"name\", \"disabled\", \"readonly\", \"tabindex\", \"accesskey\", \"onfocus\", \"onblur\", \"onselect\", \"onchange\", NULL } ;\n-static const char* const tr_contents[] = { \"th\", \"td\", NULL } ;\n-static const char* const bgcolor_attr[] = { \"bgcolor\", NULL } ;\n-static const char* const li_elt[] = { \"li\", NULL } ;\n-static const char* const ul_depr[] = { \"type\", \"compact\", NULL} ;\n-static const char* const dir_attr[] = { \"dir\", NULL} ;\n-\n-#define DECL (const char**)\n+#define DATA_RCDATA         1\n+#define DATA_RAWTEXT        2\n+#define DATA_PLAINTEXT      3\n+#define DATA_SCRIPT         4\n+#define DATA_SCRIPT_ESC1    5\n+#define DATA_SCRIPT_ESC2    6\n@@ -700,2 +531,3 @@\n-{ \"a\",        0, 0, 0, 0, 0, 0, 1, \"anchor \",\n-    DECL html_inline , NULL , DECL a_attrs , DECL target_attr, NULL\n+{ \"a\",          0, 0, 0, 0, 0, 0, 1, \"anchor \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -703,2 +535,3 @@\n-{ \"abbr\",    0, 0, 0, 0, 0, 0, 1, \"abbreviated form\",\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+{ \"abbr\",       0, 0, 0, 0, 0, 0, 1, \"abbreviated form\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -707,1 +540,2 @@\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -710,1 +544,2 @@\n-    DECL inline_p  , NULL , DECL html_attrs, NULL, NULL\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -712,2 +547,3 @@\n-{ \"applet\",    0, 0, 0, 0, 1, 1, 2, \"java applet \",\n-    DECL flow_param , NULL , NULL , DECL applet_attrs, NULL\n+{ \"applet\",     0, 0, 0, 0, 1, 1, 2, \"java applet \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -715,2 +551,3 @@\n-{ \"area\",    0, 2, 2, 1, 0, 0, 0, \"client-side image map area \",\n-    EMPTY ,  NULL , DECL area_attrs , DECL target_attr, DECL alt_attr\n+{ \"area\",       0, 2, 2, 1, 0, 0, 0, \"client-side image map area \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -718,2 +555,3 @@\n-{ \"b\",        0, 3, 0, 0, 0, 0, 1, \"bold text style\",\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+{ \"b\",          0, 3, 0, 0, 0, 0, 1, \"bold text style\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -721,2 +559,3 @@\n-{ \"base\",    0, 2, 2, 1, 0, 0, 0, \"document base uri \",\n-    EMPTY , NULL , NULL , DECL target_attr, DECL href_attrs\n+{ \"base\",       0, 2, 2, 1, 0, 0, 0, \"document base uri \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -724,2 +563,3 @@\n-{ \"basefont\",    0, 2, 2, 1, 1, 1, 1, \"base font size \" ,\n-    EMPTY , NULL , NULL, DECL basefont_attrs, NULL\n+{ \"basefont\",   0, 2, 2, 1, 1, 1, 1, \"base font size \" ,\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -727,2 +567,3 @@\n-{ \"bdo\",    0, 0, 0, 0, 0, 0, 1, \"i18n bidi over-ride \",\n-    DECL html_inline , NULL , DECL core_i18n_attrs, NULL, DECL dir_attr\n+{ \"bdo\",        0, 0, 0, 0, 0, 0, 1, \"i18n bidi over-ride \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -730,2 +571,3 @@\n-{ \"big\",    0, 3, 0, 0, 0, 0, 1, \"large text style\",\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+{ \"big\",        0, 3, 0, 0, 0, 0, 1, \"large text style\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -733,2 +575,3 @@\n-{ \"blockquote\",    0, 0, 0, 0, 0, 0, 0, \"long quotation \",\n-    DECL html_flow , NULL , DECL quote_attrs , NULL, NULL\n+{ \"blockquote\", 0, 0, 0, 0, 0, 0, 0, \"long quotation \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -736,2 +579,3 @@\n-{ \"body\",    1, 1, 0, 0, 0, 0, 0, \"document body \",\n-    DECL body_contents , \"div\" , DECL body_attrs, DECL body_depr, NULL\n+{ \"body\",       1, 1, 0, 0, 0, 0, 0, \"document body \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -739,2 +583,3 @@\n-{ \"br\",        0, 2, 2, 1, 0, 0, 1, \"forced line break \",\n-    EMPTY , NULL , DECL core_attrs, DECL clear_attrs , NULL\n+{ \"br\",         0, 2, 2, 1, 0, 0, 1, \"forced line break \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -742,2 +587,3 @@\n-{ \"button\",    0, 0, 0, 0, 0, 0, 2, \"push button \",\n-    DECL html_flow MODIFIER , NULL , DECL button_attrs, NULL, NULL\n+{ \"button\",     0, 0, 0, 0, 0, 0, 2, \"push button \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -746,1 +592,2 @@\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -748,2 +595,3 @@\n-{ \"center\",    0, 3, 0, 0, 1, 1, 0, \"shorthand for div align=center \",\n-    DECL html_flow , NULL , NULL, DECL html_attrs, NULL\n+{ \"center\",     0, 3, 0, 0, 1, 1, 0, \"shorthand for div align=center \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -751,2 +599,3 @@\n-{ \"cite\",    0, 0, 0, 0, 0, 0, 1, \"citation\",\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+{ \"cite\",       0, 0, 0, 0, 0, 0, 1, \"citation\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -754,2 +603,3 @@\n-{ \"code\",    0, 0, 0, 0, 0, 0, 1, \"computer code fragment\",\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+{ \"code\",       0, 0, 0, 0, 0, 0, 1, \"computer code fragment\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -757,2 +607,3 @@\n-{ \"col\",    0, 2, 2, 1, 0, 0, 0, \"table column \",\n-    EMPTY , NULL , DECL col_attrs , NULL, NULL\n+{ \"col\",        0, 2, 2, 1, 0, 0, 0, \"table column \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -760,2 +611,3 @@\n-{ \"colgroup\",    0, 1, 0, 0, 0, 0, 0, \"table column group \",\n-    DECL col_elt , \"col\" , DECL col_attrs , NULL, NULL\n+{ \"colgroup\",   0, 1, 0, 0, 0, 0, 0, \"table column group \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -763,2 +615,3 @@\n-{ \"dd\",        0, 1, 0, 0, 0, 0, 0, \"definition description \",\n-    DECL html_flow , NULL , DECL html_attrs, NULL, NULL\n+{ \"dd\",         0, 1, 0, 0, 0, 0, 0, \"definition description \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -766,2 +619,3 @@\n-{ \"del\",    0, 0, 0, 0, 0, 0, 2, \"deleted text \",\n-    DECL html_flow , NULL , DECL edit_attrs , NULL, NULL\n+{ \"del\",        0, 0, 0, 0, 0, 0, 2, \"deleted text \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -769,2 +623,3 @@\n-{ \"dfn\",    0, 0, 0, 0, 0, 0, 1, \"instance definition\",\n-    DECL html_inline , NULL , DECL html_attrs, NULL, NULL\n+{ \"dfn\",        0, 0, 0, 0, 0, 0, 1, \"instance definition\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -772,2 +627,3 @@\n-{ \"dir\",    0, 0, 0, 0, 1, 1, 0, \"directory list\",\n-    DECL blockli_elt, \"li\" , NULL, DECL compact_attrs, NULL\n+{ \"dir\",        0, 0, 0, 0, 1, 1, 0, \"directory list\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -775,2 +631,3 @@\n-{ \"div\",    0, 0, 0, 0, 0, 0, 0, \"generic language\/style container\",\n-    DECL html_flow, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"div\",        0, 0, 0, 0, 0, 0, 0, \"generic language\/style container\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -778,2 +635,3 @@\n-{ \"dl\",        0, 0, 0, 0, 0, 0, 0, \"definition list \",\n-    DECL dl_contents , \"dd\" , DECL html_attrs, DECL compact_attr, NULL\n+{ \"dl\",         0, 0, 0, 0, 0, 0, 0, \"definition list \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -781,2 +639,3 @@\n-{ \"dt\",        0, 1, 0, 0, 0, 0, 0, \"definition term \",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"dt\",         0, 1, 0, 0, 0, 0, 0, \"definition term \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -784,2 +643,3 @@\n-{ \"em\",        0, 3, 0, 0, 0, 0, 1, \"emphasis\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"em\",         0, 3, 0, 0, 0, 0, 1, \"emphasis\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -787,2 +647,3 @@\n-{ \"embed\",    0, 1, 0, 0, 1, 1, 1, \"generic embedded object \",\n-    EMPTY, NULL, DECL embed_attrs, NULL, NULL\n+{ \"embed\",      0, 1, 0, 0, 1, 1, 1, \"generic embedded object \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -790,2 +651,3 @@\n-{ \"fieldset\",    0, 0, 0, 0, 0, 0, 0, \"form control group \",\n-    DECL fieldset_contents , NULL, DECL html_attrs, NULL, NULL\n+{ \"fieldset\",   0, 0, 0, 0, 0, 0, 0, \"form control group \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -793,2 +655,3 @@\n-{ \"font\",    0, 3, 0, 0, 1, 1, 1, \"local change to font \",\n-    DECL html_inline, NULL, NULL, DECL font_attrs, NULL\n+{ \"font\",       0, 3, 0, 0, 1, 1, 1, \"local change to font \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -796,2 +659,3 @@\n-{ \"form\",    0, 0, 0, 0, 0, 0, 0, \"interactive form \",\n-    DECL form_contents, \"fieldset\", DECL form_attrs , DECL target_attr, DECL action_attr\n+{ \"form\",       0, 0, 0, 0, 0, 0, 0, \"interactive form \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -799,2 +663,3 @@\n-{ \"frame\",    0, 2, 2, 1, 0, 2, 0, \"subwindow \" ,\n-    EMPTY, NULL, NULL, DECL frame_attrs, NULL\n+{ \"frame\",      0, 2, 2, 1, 0, 2, 0, \"subwindow \" ,\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -802,2 +667,3 @@\n-{ \"frameset\",    0, 0, 0, 0, 0, 2, 0, \"window subdivision\" ,\n-    DECL frameset_contents, \"noframes\" , NULL , DECL frameset_attrs, NULL\n+{ \"frameset\",   0, 0, 0, 0, 0, 2, 0, \"window subdivision\" ,\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -805,2 +671,3 @@\n-{ \"h1\",        0, 0, 0, 0, 0, 0, 0, \"heading \",\n-    DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"h1\",         0, 0, 0, 0, 0, 0, 0, \"heading \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -808,2 +675,3 @@\n-{ \"h2\",        0, 0, 0, 0, 0, 0, 0, \"heading \",\n-    DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"h2\",         0, 0, 0, 0, 0, 0, 0, \"heading \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -811,2 +679,3 @@\n-{ \"h3\",        0, 0, 0, 0, 0, 0, 0, \"heading \",\n-    DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"h3\",         0, 0, 0, 0, 0, 0, 0, \"heading \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -814,2 +683,3 @@\n-{ \"h4\",        0, 0, 0, 0, 0, 0, 0, \"heading \",\n-    DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"h4\",         0, 0, 0, 0, 0, 0, 0, \"heading \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -817,2 +687,3 @@\n-{ \"h5\",        0, 0, 0, 0, 0, 0, 0, \"heading \",\n-    DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"h5\",         0, 0, 0, 0, 0, 0, 0, \"heading \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -820,2 +691,3 @@\n-{ \"h6\",        0, 0, 0, 0, 0, 0, 0, \"heading \",\n-    DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"h6\",         0, 0, 0, 0, 0, 0, 0, \"heading \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -823,2 +695,3 @@\n-{ \"head\",    1, 1, 0, 0, 0, 0, 0, \"document head \",\n-    DECL head_contents, NULL, DECL head_attrs, NULL, NULL\n+{ \"head\",       1, 1, 0, 0, 0, 0, 0, \"document head \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -826,2 +699,3 @@\n-{ \"hr\",        0, 2, 2, 1, 0, 0, 0, \"horizontal rule \" ,\n-    EMPTY, NULL, DECL html_attrs, DECL hr_depr, NULL\n+{ \"hr\",         0, 2, 2, 1, 0, 0, 0, \"horizontal rule \" ,\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -829,2 +703,3 @@\n-{ \"html\",    1, 1, 0, 0, 0, 0, 0, \"document root element \",\n-    DECL html_content , NULL , DECL i18n_attrs, DECL version_attr, NULL\n+{ \"html\",       1, 1, 0, 0, 0, 0, 0, \"document root element \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -832,2 +707,3 @@\n-{ \"i\",        0, 3, 0, 0, 0, 0, 1, \"italic text style\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"i\",          0, 3, 0, 0, 0, 0, 1, \"italic text style\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -835,2 +711,3 @@\n-{ \"iframe\",    0, 0, 0, 0, 0, 1, 2, \"inline subwindow \",\n-    DECL html_flow, NULL, NULL, DECL iframe_attrs, NULL\n+{ \"iframe\",     0, 0, 0, 0, 0, 1, 2, \"inline subwindow \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        DATA_RAWTEXT\n@@ -838,2 +715,3 @@\n-{ \"img\",    0, 2, 2, 1, 0, 0, 1, \"embedded image \",\n-    EMPTY, NULL, DECL img_attrs, DECL align_attr, DECL src_alt_attrs\n+{ \"img\",        0, 2, 2, 1, 0, 0, 1, \"embedded image \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -841,2 +719,3 @@\n-{ \"input\",    0, 2, 2, 1, 0, 0, 1, \"form control \",\n-    EMPTY, NULL, DECL input_attrs , DECL align_attr, NULL\n+{ \"input\",      0, 2, 2, 1, 0, 0, 1, \"form control \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -844,2 +723,3 @@\n-{ \"ins\",    0, 0, 0, 0, 0, 0, 2, \"inserted text\",\n-    DECL html_flow, NULL, DECL edit_attrs, NULL, NULL\n+{ \"ins\",        0, 0, 0, 0, 0, 0, 2, \"inserted text\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -848,1 +728,14 @@\n-    EMPTY, NULL, NULL, DECL prompt_attrs, NULL\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n+},\n+{ \"kbd\",        0, 0, 0, 0, 0, 0, 1, \"text to be entered by the user\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n+},\n+{ \"label\",      0, 0, 0, 0, 0, 0, 1, \"form field label text \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n+},\n+{ \"legend\",     0, 0, 0, 0, 0, 0, 0, \"fieldset legend \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -850,2 +743,3 @@\n-{ \"kbd\",    0, 0, 0, 0, 0, 0, 1, \"text to be entered by the user\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"li\",         0, 1, 1, 0, 0, 0, 0, \"list item \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -853,2 +747,3 @@\n-{ \"label\",    0, 0, 0, 0, 0, 0, 1, \"form field label text \",\n-    DECL html_inline MODIFIER, NULL, DECL label_attrs , NULL, NULL\n+{ \"link\",       0, 2, 2, 1, 0, 0, 0, \"a media-independent link \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -856,2 +751,3 @@\n-{ \"legend\",    0, 0, 0, 0, 0, 0, 0, \"fieldset legend \",\n-    DECL html_inline, NULL, DECL legend_attrs , DECL align_attr, NULL\n+{ \"map\",        0, 0, 0, 0, 0, 0, 2, \"client-side image map \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -859,2 +755,3 @@\n-{ \"li\",        0, 1, 1, 0, 0, 0, 0, \"list item \",\n-    DECL html_flow, NULL, DECL html_attrs, NULL, NULL\n+{ \"menu\",       0, 0, 0, 0, 1, 1, 0, \"menu list \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -862,2 +759,3 @@\n-{ \"link\",    0, 2, 2, 1, 0, 0, 0, \"a media-independent link \",\n-    EMPTY, NULL, DECL link_attrs, DECL target_attr, NULL\n+{ \"meta\",       0, 2, 2, 1, 0, 0, 0, \"generic metainformation \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -865,2 +763,3 @@\n-{ \"map\",    0, 0, 0, 0, 0, 0, 2, \"client-side image map \",\n-    DECL map_contents , NULL, DECL html_attrs , NULL, DECL name_attr\n+{ \"noembed\",    0, 0, 0, 0, 0, 0, 0, \"\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        DATA_RAWTEXT\n@@ -868,2 +767,3 @@\n-{ \"menu\",    0, 0, 0, 0, 1, 1, 0, \"menu list \",\n-    DECL blockli_elt , NULL, NULL, DECL compact_attrs, NULL\n+{ \"noframes\",   0, 0, 0, 0, 0, 2, 0, \"alternate content container for non frame-based rendering \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        DATA_RAWTEXT\n@@ -871,2 +771,3 @@\n-{ \"meta\",    0, 2, 2, 1, 0, 0, 0, \"generic metainformation \",\n-    EMPTY, NULL, DECL meta_attrs , NULL , DECL content_attr\n+{ \"noscript\",   0, 0, 0, 0, 0, 0, 0, \"alternate content container for non script-based rendering \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -874,2 +775,3 @@\n-{ \"noframes\",    0, 0, 0, 0, 0, 2, 0, \"alternate content container for non frame-based rendering \",\n-    DECL noframes_content, \"body\" , DECL html_attrs, NULL, NULL\n+{ \"object\",     0, 0, 0, 0, 0, 0, 2, \"generic embedded object \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -877,2 +779,3 @@\n-{ \"noscript\",    0, 0, 0, 0, 0, 0, 0, \"alternate content container for non script-based rendering \",\n-    DECL html_flow, \"div\", DECL html_attrs, NULL, NULL\n+{ \"ol\",         0, 0, 0, 0, 0, 0, 0, \"ordered list \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -880,2 +783,3 @@\n-{ \"object\",    0, 0, 0, 0, 0, 0, 2, \"generic embedded object \",\n-    DECL object_contents , \"div\" , DECL object_attrs, DECL object_depr, NULL\n+{ \"optgroup\",   0, 0, 0, 0, 0, 0, 0, \"option group \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -883,2 +787,3 @@\n-{ \"ol\",        0, 0, 0, 0, 0, 0, 0, \"ordered list \",\n-    DECL li_elt , \"li\" , DECL html_attrs, DECL ol_attrs, NULL\n+{ \"option\",     0, 1, 0, 0, 0, 0, 0, \"selectable choice \" ,\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -886,2 +791,3 @@\n-{ \"optgroup\",    0, 0, 0, 0, 0, 0, 0, \"option group \",\n-    DECL option_elt , \"option\", DECL optgroup_attrs, NULL, DECL label_attr\n+{ \"p\",          0, 1, 0, 0, 0, 0, 0, \"paragraph \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -889,2 +795,3 @@\n-{ \"option\",    0, 1, 0, 0, 0, 0, 0, \"selectable choice \" ,\n-    DECL html_pcdata, NULL, DECL option_attrs, NULL, NULL\n+{ \"param\",      0, 2, 2, 1, 0, 0, 0, \"named property value \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -892,2 +799,3 @@\n-{ \"p\",        0, 1, 0, 0, 0, 0, 0, \"paragraph \",\n-    DECL html_inline, NULL, DECL html_attrs, DECL align_attr, NULL\n+{ \"plaintext\",  0, 0, 0, 0, 0, 0, 0, \"\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        DATA_PLAINTEXT\n@@ -895,2 +803,3 @@\n-{ \"param\",    0, 2, 2, 1, 0, 0, 0, \"named property value \",\n-    EMPTY, NULL, DECL param_attrs, NULL, DECL name_attr\n+{ \"pre\",        0, 0, 0, 0, 0, 0, 0, \"preformatted text \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -898,2 +807,3 @@\n-{ \"pre\",    0, 0, 0, 0, 0, 0, 0, \"preformatted text \",\n-    DECL pre_content, NULL, DECL html_attrs, DECL width_attr, NULL\n+{ \"q\",          0, 0, 0, 0, 0, 0, 1, \"short inline quotation \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -901,2 +811,3 @@\n-{ \"q\",        0, 0, 0, 0, 0, 0, 1, \"short inline quotation \",\n-    DECL html_inline, NULL, DECL quote_attrs, NULL, NULL\n+{ \"s\",          0, 3, 0, 0, 1, 1, 1, \"strike-through text style\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -904,2 +815,3 @@\n-{ \"s\",        0, 3, 0, 0, 1, 1, 1, \"strike-through text style\",\n-    DECL html_inline, NULL, NULL, DECL html_attrs, NULL\n+{ \"samp\",       0, 0, 0, 0, 0, 0, 1, \"sample program output, scripts, etc.\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -907,2 +819,3 @@\n-{ \"samp\",    0, 0, 0, 0, 0, 0, 1, \"sample program output, scripts, etc.\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"script\",     0, 0, 0, 0, 0, 0, 2, \"script statements \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        DATA_SCRIPT\n@@ -910,2 +823,3 @@\n-{ \"script\",    0, 0, 0, 0, 0, 0, 2, \"script statements \",\n-    DECL html_cdata, NULL, DECL script_attrs, DECL language_attr, DECL type_attr\n+{ \"select\",     0, 0, 0, 0, 0, 0, 1, \"option selector \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -913,2 +827,3 @@\n-{ \"select\",    0, 0, 0, 0, 0, 0, 1, \"option selector \",\n-    DECL select_content, NULL, DECL select_attrs, NULL, NULL\n+{ \"small\",      0, 3, 0, 0, 0, 0, 1, \"small text style\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -916,2 +831,3 @@\n-{ \"small\",    0, 3, 0, 0, 0, 0, 1, \"small text style\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"span\",       0, 0, 0, 0, 0, 0, 1, \"generic language\/style container \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -919,2 +835,3 @@\n-{ \"span\",    0, 0, 0, 0, 0, 0, 1, \"generic language\/style container \",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"strike\",     0, 3, 0, 0, 1, 1, 1, \"strike-through text\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -922,2 +839,3 @@\n-{ \"strike\",    0, 3, 0, 0, 1, 1, 1, \"strike-through text\",\n-    DECL html_inline, NULL, NULL, DECL html_attrs, NULL\n+{ \"strong\",     0, 3, 0, 0, 0, 0, 1, \"strong emphasis\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -925,2 +843,3 @@\n-{ \"strong\",    0, 3, 0, 0, 0, 0, 1, \"strong emphasis\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"style\",      0, 0, 0, 0, 0, 0, 0, \"style info \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        DATA_RAWTEXT\n@@ -928,2 +847,3 @@\n-{ \"style\",    0, 0, 0, 0, 0, 0, 0, \"style info \",\n-    DECL html_cdata, NULL, DECL style_attrs, NULL, DECL type_attr\n+{ \"sub\",        0, 3, 0, 0, 0, 0, 1, \"subscript\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -931,2 +851,3 @@\n-{ \"sub\",    0, 3, 0, 0, 0, 0, 1, \"subscript\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"sup\",        0, 3, 0, 0, 0, 0, 1, \"superscript \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -934,2 +855,3 @@\n-{ \"sup\",    0, 3, 0, 0, 0, 0, 1, \"superscript \",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"table\",      0, 0, 0, 0, 0, 0, 0, \"\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -937,2 +859,3 @@\n-{ \"table\",    0, 0, 0, 0, 0, 0, 0, \"\",\n-    DECL table_contents , \"tr\" , DECL table_attrs , DECL table_depr, NULL\n+{ \"tbody\",      1, 0, 0, 0, 0, 0, 0, \"table body \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -940,2 +863,3 @@\n-{ \"tbody\",    1, 0, 0, 0, 0, 0, 0, \"table body \",\n-    DECL tr_elt , \"tr\" , DECL talign_attrs, NULL, NULL\n+{ \"td\",         0, 0, 0, 0, 0, 0, 0, \"table data cell\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -943,2 +867,3 @@\n-{ \"td\",        0, 0, 0, 0, 0, 0, 0, \"table data cell\",\n-    DECL html_flow, NULL, DECL th_td_attr, DECL th_td_depr, NULL\n+{ \"textarea\",   0, 0, 0, 0, 0, 0, 1, \"multi-line text field \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        DATA_RCDATA\n@@ -946,2 +871,3 @@\n-{ \"textarea\",    0, 0, 0, 0, 0, 0, 1, \"multi-line text field \",\n-    DECL html_pcdata, NULL, DECL textarea_attrs, NULL, DECL rows_cols_attr\n+{ \"tfoot\",      0, 1, 0, 0, 0, 0, 0, \"table footer \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -949,2 +875,3 @@\n-{ \"tfoot\",    0, 1, 0, 0, 0, 0, 0, \"table footer \",\n-    DECL tr_elt , \"tr\" , DECL talign_attrs, NULL, NULL\n+{ \"th\",         0, 1, 0, 0, 0, 0, 0, \"table header cell\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -952,2 +879,3 @@\n-{ \"th\",        0, 1, 0, 0, 0, 0, 0, \"table header cell\",\n-    DECL html_flow, NULL, DECL th_td_attr, DECL th_td_depr, NULL\n+{ \"thead\",      0, 1, 0, 0, 0, 0, 0, \"table header \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -955,2 +883,3 @@\n-{ \"thead\",    0, 1, 0, 0, 0, 0, 0, \"table header \",\n-    DECL tr_elt , \"tr\" , DECL talign_attrs, NULL, NULL\n+{ \"title\",      0, 0, 0, 0, 0, 0, 0, \"document title \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        DATA_RCDATA\n@@ -958,2 +887,3 @@\n-{ \"title\",    0, 0, 0, 0, 0, 0, 0, \"document title \",\n-    DECL html_pcdata, NULL, DECL i18n_attrs, NULL, NULL\n+{ \"tr\",         0, 0, 0, 0, 0, 0, 0, \"table row \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -961,2 +891,3 @@\n-{ \"tr\",        0, 0, 0, 0, 0, 0, 0, \"table row \",\n-    DECL tr_contents , \"td\" , DECL talign_attrs, DECL bgcolor_attr, NULL\n+{ \"tt\",         0, 3, 0, 0, 0, 0, 1, \"teletype or monospaced text style\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -964,2 +895,3 @@\n-{ \"tt\",        0, 3, 0, 0, 0, 0, 1, \"teletype or monospaced text style\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"u\",          0, 3, 0, 0, 1, 1, 1, \"underlined text style\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -967,2 +899,3 @@\n-{ \"u\",        0, 3, 0, 0, 1, 1, 1, \"underlined text style\",\n-    DECL html_inline, NULL, NULL, DECL html_attrs, NULL\n+{ \"ul\",         0, 0, 0, 0, 0, 0, 0, \"unordered list \",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -970,2 +903,3 @@\n-{ \"ul\",        0, 0, 0, 0, 0, 0, 0, \"unordered list \",\n-    DECL li_elt , \"li\" , DECL html_attrs, DECL ul_depr, NULL\n+{ \"var\",        0, 0, 0, 0, 0, 0, 1, \"instance of a variable or program argument\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        0\n@@ -973,2 +907,3 @@\n-{ \"var\",    0, 0, 0, 0, 0, 0, 1, \"instance of a variable or program argument\",\n-    DECL html_inline, NULL, DECL html_attrs, NULL, NULL\n+{ \"xmp\",        0, 0, 0, 0, 0, 0, 1, \"\",\n+        NULL, NULL, NULL, NULL, NULL,\n+        DATA_RAWTEXT\n@@ -1238,13 +1173,0 @@\n-\/*\n- * The list of HTML elements which are supposed not to have\n- * CDATA content and where a p element will be implied\n- *\n- * TODO: extend that list by reading the HTML SGML DTD on\n- *       implied paragraph\n- *\/\n-static const char *const htmlNoContentElements[] = {\n-    \"html\",\n-    \"head\",\n-    NULL\n-};\n-\n@@ -1306,3 +1228,3 @@\n- *                                    *\n- *    functions to handle HTML specific data            *\n- *                                    *\n+ *                                                                      *\n+ *      functions to handle HTML specific data                  *\n+ *                                                                      *\n@@ -1311,0 +1233,15 @@\n+static void\n+htmlParserFinishElementParsing(htmlParserCtxtPtr ctxt) {\n+    \/*\n+     * Capture end position and add node\n+     *\/\n+    if ( ctxt->node != NULL && ctxt->record_info ) {\n+       ctxt->nodeInfo->end_pos = ctxt->input->consumed +\n+                                (CUR_PTR - ctxt->input->base);\n+       ctxt->nodeInfo->end_line = ctxt->input->line;\n+       ctxt->nodeInfo->node = ctxt->node;\n+       xmlParserAddNodeInfo(ctxt, ctxt->nodeInfo);\n+       htmlNodeInfoPop(ctxt);\n+    }\n+}\n+\n@@ -1357,2 +1294,2 @@\n-       (!xmlStrEqual((const xmlChar *)htmlEndPriority[i].name, name)))\n-    i++;\n+           (!xmlStrEqual((const xmlChar *)htmlEndPriority[i].name, name)))\n+        i++;\n@@ -1415,0 +1352,3 @@\n+    if (ctxt->options & HTML_PARSE_HTML5)\n+        return;\n+\n@@ -1437,2 +1377,2 @@\n-                     \"Opening and ending tag mismatch: %s and %s\\n\",\n-             newtag, ctxt->name);\n+                         \"Opening and ending tag mismatch: %s and %s\\n\",\n+                         newtag, ctxt->name);\n@@ -1440,0 +1380,1 @@\n+        htmlParserFinishElementParsing(ctxt);\n@@ -1442,1 +1383,1 @@\n-    htmlnamePop(ctxt);\n+        htmlnamePop(ctxt);\n@@ -1457,0 +1398,3 @@\n+    if (ctxt->options & HTML_PARSE_HTML5)\n+        return;\n+\n@@ -1460,0 +1404,1 @@\n+        htmlParserFinishElementParsing(ctxt);\n@@ -1462,1 +1407,1 @@\n-    htmlnamePop(ctxt);\n+        htmlnamePop(ctxt);\n@@ -1481,0 +1426,3 @@\n+    if (ctxt->options & HTML_PARSE_HTML5)\n+        return;\n+\n@@ -1486,0 +1434,1 @@\n+        htmlParserFinishElementParsing(ctxt);\n@@ -1488,1 +1437,1 @@\n-    htmlnamePop(ctxt);\n+        htmlnamePop(ctxt);\n@@ -1498,0 +1447,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -1515,1 +1466,1 @@\n-    child = child->next;\n+        child = child->next;\n@@ -1525,0 +1476,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -1538,2 +1491,2 @@\n-    if (htmlAutoCloseTag(doc, elem->name, child)) return(1);\n-    child = child->next;\n+        if (htmlAutoCloseTag(doc, elem->name, child)) return(1);\n+        child = child->next;\n@@ -1557,1 +1510,1 @@\n-    if (ctxt->options & HTML_PARSE_NOIMPLIED)\n+    if (ctxt->options & (HTML_PARSE_NOIMPLIED | HTML_PARSE_HTML5))\n@@ -1560,1 +1513,1 @@\n-    return;\n+        return;\n@@ -1562,1 +1515,1 @@\n-    return;\n+        return;\n@@ -1564,3 +1517,3 @@\n-    htmlnamePush(ctxt, BAD_CAST\"html\");\n-    if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))\n-        ctxt->sax->startElement(ctxt->userData, BAD_CAST\"html\", NULL);\n+        htmlnamePush(ctxt, BAD_CAST\"html\");\n+        if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))\n+            ctxt->sax->startElement(ctxt->userData, BAD_CAST\"html\", NULL);\n@@ -1572,6 +1525,6 @@\n-     (xmlStrEqual(newtag, BAD_CAST\"style\")) ||\n-     (xmlStrEqual(newtag, BAD_CAST\"meta\")) ||\n-     (xmlStrEqual(newtag, BAD_CAST\"link\")) ||\n-     (xmlStrEqual(newtag, BAD_CAST\"title\")) ||\n-     (xmlStrEqual(newtag, BAD_CAST\"base\")))) {\n-        if (ctxt->html >= 3) {\n+         (xmlStrEqual(newtag, BAD_CAST\"style\")) ||\n+         (xmlStrEqual(newtag, BAD_CAST\"meta\")) ||\n+         (xmlStrEqual(newtag, BAD_CAST\"link\")) ||\n+         (xmlStrEqual(newtag, BAD_CAST\"title\")) ||\n+         (xmlStrEqual(newtag, BAD_CAST\"base\")))) {\n+        if (ctxt->html >= INSERT_IN_HEAD) {\n@@ -1589,3 +1542,3 @@\n-           (!xmlStrEqual(newtag, BAD_CAST\"frame\")) &&\n-           (!xmlStrEqual(newtag, BAD_CAST\"frameset\"))) {\n-        if (ctxt->html >= 10) {\n+               (!xmlStrEqual(newtag, BAD_CAST\"frame\")) &&\n+               (!xmlStrEqual(newtag, BAD_CAST\"frameset\"))) {\n+        if (ctxt->html >= INSERT_IN_BODY) {\n@@ -1595,6 +1548,7 @@\n-    for (i = 0;i < ctxt->nameNr;i++) {\n-        if (xmlStrEqual(ctxt->nameTab[i], BAD_CAST\"body\")) {\n-        return;\n-        }\n-        if (xmlStrEqual(ctxt->nameTab[i], BAD_CAST\"head\")) {\n-        return;\n+        for (i = 0;i < ctxt->nameNr;i++) {\n+            if (xmlStrEqual(ctxt->nameTab[i], BAD_CAST\"body\")) {\n+                return;\n+            }\n+            if (xmlStrEqual(ctxt->nameTab[i], BAD_CAST\"head\")) {\n+                return;\n+            }\n@@ -1602,1 +1556,0 @@\n-    }\n@@ -1604,3 +1557,3 @@\n-    htmlnamePush(ctxt, BAD_CAST\"body\");\n-    if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))\n-        ctxt->sax->startElement(ctxt->userData, BAD_CAST\"body\", NULL);\n+        htmlnamePush(ctxt, BAD_CAST\"body\");\n+        if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))\n+            ctxt->sax->startElement(ctxt->userData, BAD_CAST\"body\", NULL);\n@@ -1611,1 +1564,1 @@\n- * htmlCheckParagraph\n+ * htmlStartCharData\n@@ -1614,5 +1567,1 @@\n- * Check whether a p element need to be implied before inserting\n- * characters in the current element.\n- *\n- * Returns 1 if a paragraph has been inserted, 0 if not and -1\n- *         in case of error.\n+ * Prepare for non-whitespace character data.\n@@ -1621,16 +1570,4 @@\n-static int\n-htmlCheckParagraph(htmlParserCtxtPtr ctxt) {\n-    const xmlChar *tag;\n-    int i;\n-\n-    if (ctxt == NULL)\n-    return(-1);\n-    tag = ctxt->name;\n-    if (tag == NULL) {\n-    htmlAutoClose(ctxt, BAD_CAST\"p\");\n-    htmlCheckImplied(ctxt, BAD_CAST\"p\");\n-    htmlnamePush(ctxt, BAD_CAST\"p\");\n-    if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))\n-        ctxt->sax->startElement(ctxt->userData, BAD_CAST\"p\", NULL);\n-    return(1);\n-    }\n+static void\n+htmlStartCharData(htmlParserCtxtPtr ctxt) {\n+    if (ctxt->options & (HTML_PARSE_NOIMPLIED | HTML_PARSE_HTML5))\n+        return;\n@@ -1638,12 +1575,5 @@\n-    return(0);\n-    for (i = 0; htmlNoContentElements[i] != NULL; i++) {\n-    if (xmlStrEqual(tag, BAD_CAST htmlNoContentElements[i])) {\n-        htmlAutoClose(ctxt, BAD_CAST\"p\");\n-        htmlCheckImplied(ctxt, BAD_CAST\"p\");\n-        htmlnamePush(ctxt, BAD_CAST\"p\");\n-        if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL))\n-        ctxt->sax->startElement(ctxt->userData, BAD_CAST\"p\", NULL);\n-        return(1);\n-    }\n-    }\n-    return(0);\n+        return;\n+\n+    if (xmlStrEqual(ctxt->name, BAD_CAST \"head\"))\n+        htmlAutoClose(ctxt, BAD_CAST \"p\");\n+    htmlCheckImplied(ctxt, BAD_CAST \"p\");\n@@ -1672,4 +1602,4 @@\n-     i < sizeof(htmlScriptAttributes)\/sizeof(htmlScriptAttributes[0]);\n-     i++) {\n-    if (xmlStrEqual(name, (const xmlChar *) htmlScriptAttributes[i]))\n-        return(1);\n+         i < sizeof(htmlScriptAttributes)\/sizeof(htmlScriptAttributes[0]);\n+         i++) {\n+        if (xmlStrEqual(name, (const xmlChar *) htmlScriptAttributes[i]))\n+            return(1);\n@@ -1681,3 +1611,3 @@\n- *                                    *\n- *    The list of HTML predefined entities            *\n- *                                    *\n+ *                                                                      *\n+ *      The list of HTML predefined entities                    *\n+ *                                                                      *\n@@ -1691,5 +1621,5 @@\n-{ 34,    \"quot\",    \"quotation mark = APL quote, U+0022 ISOnum\" },\n-{ 38,    \"amp\",    \"ampersand, U+0026 ISOnum\" },\n-{ 39,    \"apos\",    \"single quote\" },\n-{ 60,    \"lt\",    \"less-than sign, U+003C ISOnum\" },\n-{ 62,    \"gt\",    \"greater-than sign, U+003E ISOnum\" },\n+{ 34,   \"quot\", \"quotation mark = APL quote, U+0022 ISOnum\" },\n+{ 38,   \"amp\",  \"ampersand, U+0026 ISOnum\" },\n+{ 39,   \"apos\", \"single quote\" },\n+{ 60,   \"lt\",   \"less-than sign, U+003C ISOnum\" },\n+{ 62,   \"gt\",   \"greater-than sign, U+003E ISOnum\" },\n@@ -1701,102 +1631,102 @@\n-{ 160,    \"nbsp\",    \"no-break space = non-breaking space, U+00A0 ISOnum\" },\n-{ 161,    \"iexcl\",\"inverted exclamation mark, U+00A1 ISOnum\" },\n-{ 162,    \"cent\",    \"cent sign, U+00A2 ISOnum\" },\n-{ 163,    \"pound\",\"pound sign, U+00A3 ISOnum\" },\n-{ 164,    \"curren\",\"currency sign, U+00A4 ISOnum\" },\n-{ 165,    \"yen\",    \"yen sign = yuan sign, U+00A5 ISOnum\" },\n-{ 166,    \"brvbar\",\"broken bar = broken vertical bar, U+00A6 ISOnum\" },\n-{ 167,    \"sect\",    \"section sign, U+00A7 ISOnum\" },\n-{ 168,    \"uml\",    \"diaeresis = spacing diaeresis, U+00A8 ISOdia\" },\n-{ 169,    \"copy\",    \"copyright sign, U+00A9 ISOnum\" },\n-{ 170,    \"ordf\",    \"feminine ordinal indicator, U+00AA ISOnum\" },\n-{ 171,    \"laquo\",\"left-pointing double angle quotation mark = left pointing guillemet, U+00AB ISOnum\" },\n-{ 172,    \"not\",    \"not sign, U+00AC ISOnum\" },\n-{ 173,    \"shy\",    \"soft hyphen = discretionary hyphen, U+00AD ISOnum\" },\n-{ 174,    \"reg\",    \"registered sign = registered trade mark sign, U+00AE ISOnum\" },\n-{ 175,    \"macr\",    \"macron = spacing macron = overline = APL overbar, U+00AF ISOdia\" },\n-{ 176,    \"deg\",    \"degree sign, U+00B0 ISOnum\" },\n-{ 177,    \"plusmn\",\"plus-minus sign = plus-or-minus sign, U+00B1 ISOnum\" },\n-{ 178,    \"sup2\",    \"superscript two = superscript digit two = squared, U+00B2 ISOnum\" },\n-{ 179,    \"sup3\",    \"superscript three = superscript digit three = cubed, U+00B3 ISOnum\" },\n-{ 180,    \"acute\",\"acute accent = spacing acute, U+00B4 ISOdia\" },\n-{ 181,    \"micro\",\"micro sign, U+00B5 ISOnum\" },\n-{ 182,    \"para\",    \"pilcrow sign = paragraph sign, U+00B6 ISOnum\" },\n-{ 183,    \"middot\",\"middle dot = Georgian comma Greek middle dot, U+00B7 ISOnum\" },\n-{ 184,    \"cedil\",\"cedilla = spacing cedilla, U+00B8 ISOdia\" },\n-{ 185,    \"sup1\",    \"superscript one = superscript digit one, U+00B9 ISOnum\" },\n-{ 186,    \"ordm\",    \"masculine ordinal indicator, U+00BA ISOnum\" },\n-{ 187,    \"raquo\",\"right-pointing double angle quotation mark right pointing guillemet, U+00BB ISOnum\" },\n-{ 188,    \"frac14\",\"vulgar fraction one quarter = fraction one quarter, U+00BC ISOnum\" },\n-{ 189,    \"frac12\",\"vulgar fraction one half = fraction one half, U+00BD ISOnum\" },\n-{ 190,    \"frac34\",\"vulgar fraction three quarters = fraction three quarters, U+00BE ISOnum\" },\n-{ 191,    \"iquest\",\"inverted question mark = turned question mark, U+00BF ISOnum\" },\n-{ 192,    \"Agrave\",\"latin capital letter A with grave = latin capital letter A grave, U+00C0 ISOlat1\" },\n-{ 193,    \"Aacute\",\"latin capital letter A with acute, U+00C1 ISOlat1\" },\n-{ 194,    \"Acirc\",\"latin capital letter A with circumflex, U+00C2 ISOlat1\" },\n-{ 195,    \"Atilde\",\"latin capital letter A with tilde, U+00C3 ISOlat1\" },\n-{ 196,    \"Auml\",    \"latin capital letter A with diaeresis, U+00C4 ISOlat1\" },\n-{ 197,    \"Aring\",\"latin capital letter A with ring above = latin capital letter A ring, U+00C5 ISOlat1\" },\n-{ 198,    \"AElig\",\"latin capital letter AE = latin capital ligature AE, U+00C6 ISOlat1\" },\n-{ 199,    \"Ccedil\",\"latin capital letter C with cedilla, U+00C7 ISOlat1\" },\n-{ 200,    \"Egrave\",\"latin capital letter E with grave, U+00C8 ISOlat1\" },\n-{ 201,    \"Eacute\",\"latin capital letter E with acute, U+00C9 ISOlat1\" },\n-{ 202,    \"Ecirc\",\"latin capital letter E with circumflex, U+00CA ISOlat1\" },\n-{ 203,    \"Euml\",    \"latin capital letter E with diaeresis, U+00CB ISOlat1\" },\n-{ 204,    \"Igrave\",\"latin capital letter I with grave, U+00CC ISOlat1\" },\n-{ 205,    \"Iacute\",\"latin capital letter I with acute, U+00CD ISOlat1\" },\n-{ 206,    \"Icirc\",\"latin capital letter I with circumflex, U+00CE ISOlat1\" },\n-{ 207,    \"Iuml\",    \"latin capital letter I with diaeresis, U+00CF ISOlat1\" },\n-{ 208,    \"ETH\",    \"latin capital letter ETH, U+00D0 ISOlat1\" },\n-{ 209,    \"Ntilde\",\"latin capital letter N with tilde, U+00D1 ISOlat1\" },\n-{ 210,    \"Ograve\",\"latin capital letter O with grave, U+00D2 ISOlat1\" },\n-{ 211,    \"Oacute\",\"latin capital letter O with acute, U+00D3 ISOlat1\" },\n-{ 212,    \"Ocirc\",\"latin capital letter O with circumflex, U+00D4 ISOlat1\" },\n-{ 213,    \"Otilde\",\"latin capital letter O with tilde, U+00D5 ISOlat1\" },\n-{ 214,    \"Ouml\",    \"latin capital letter O with diaeresis, U+00D6 ISOlat1\" },\n-{ 215,    \"times\",\"multiplication sign, U+00D7 ISOnum\" },\n-{ 216,    \"Oslash\",\"latin capital letter O with stroke latin capital letter O slash, U+00D8 ISOlat1\" },\n-{ 217,    \"Ugrave\",\"latin capital letter U with grave, U+00D9 ISOlat1\" },\n-{ 218,    \"Uacute\",\"latin capital letter U with acute, U+00DA ISOlat1\" },\n-{ 219,    \"Ucirc\",\"latin capital letter U with circumflex, U+00DB ISOlat1\" },\n-{ 220,    \"Uuml\",    \"latin capital letter U with diaeresis, U+00DC ISOlat1\" },\n-{ 221,    \"Yacute\",\"latin capital letter Y with acute, U+00DD ISOlat1\" },\n-{ 222,    \"THORN\",\"latin capital letter THORN, U+00DE ISOlat1\" },\n-{ 223,    \"szlig\",\"latin small letter sharp s = ess-zed, U+00DF ISOlat1\" },\n-{ 224,    \"agrave\",\"latin small letter a with grave = latin small letter a grave, U+00E0 ISOlat1\" },\n-{ 225,    \"aacute\",\"latin small letter a with acute, U+00E1 ISOlat1\" },\n-{ 226,    \"acirc\",\"latin small letter a with circumflex, U+00E2 ISOlat1\" },\n-{ 227,    \"atilde\",\"latin small letter a with tilde, U+00E3 ISOlat1\" },\n-{ 228,    \"auml\",    \"latin small letter a with diaeresis, U+00E4 ISOlat1\" },\n-{ 229,    \"aring\",\"latin small letter a with ring above = latin small letter a ring, U+00E5 ISOlat1\" },\n-{ 230,    \"aelig\",\"latin small letter ae = latin small ligature ae, U+00E6 ISOlat1\" },\n-{ 231,    \"ccedil\",\"latin small letter c with cedilla, U+00E7 ISOlat1\" },\n-{ 232,    \"egrave\",\"latin small letter e with grave, U+00E8 ISOlat1\" },\n-{ 233,    \"eacute\",\"latin small letter e with acute, U+00E9 ISOlat1\" },\n-{ 234,    \"ecirc\",\"latin small letter e with circumflex, U+00EA ISOlat1\" },\n-{ 235,    \"euml\",    \"latin small letter e with diaeresis, U+00EB ISOlat1\" },\n-{ 236,    \"igrave\",\"latin small letter i with grave, U+00EC ISOlat1\" },\n-{ 237,    \"iacute\",\"latin small letter i with acute, U+00ED ISOlat1\" },\n-{ 238,    \"icirc\",\"latin small letter i with circumflex, U+00EE ISOlat1\" },\n-{ 239,    \"iuml\",    \"latin small letter i with diaeresis, U+00EF ISOlat1\" },\n-{ 240,    \"eth\",    \"latin small letter eth, U+00F0 ISOlat1\" },\n-{ 241,    \"ntilde\",\"latin small letter n with tilde, U+00F1 ISOlat1\" },\n-{ 242,    \"ograve\",\"latin small letter o with grave, U+00F2 ISOlat1\" },\n-{ 243,    \"oacute\",\"latin small letter o with acute, U+00F3 ISOlat1\" },\n-{ 244,    \"ocirc\",\"latin small letter o with circumflex, U+00F4 ISOlat1\" },\n-{ 245,    \"otilde\",\"latin small letter o with tilde, U+00F5 ISOlat1\" },\n-{ 246,    \"ouml\",    \"latin small letter o with diaeresis, U+00F6 ISOlat1\" },\n-{ 247,    \"divide\",\"division sign, U+00F7 ISOnum\" },\n-{ 248,    \"oslash\",\"latin small letter o with stroke, = latin small letter o slash, U+00F8 ISOlat1\" },\n-{ 249,    \"ugrave\",\"latin small letter u with grave, U+00F9 ISOlat1\" },\n-{ 250,    \"uacute\",\"latin small letter u with acute, U+00FA ISOlat1\" },\n-{ 251,    \"ucirc\",\"latin small letter u with circumflex, U+00FB ISOlat1\" },\n-{ 252,    \"uuml\",    \"latin small letter u with diaeresis, U+00FC ISOlat1\" },\n-{ 253,    \"yacute\",\"latin small letter y with acute, U+00FD ISOlat1\" },\n-{ 254,    \"thorn\",\"latin small letter thorn with, U+00FE ISOlat1\" },\n-{ 255,    \"yuml\",    \"latin small letter y with diaeresis, U+00FF ISOlat1\" },\n-\n-{ 338,    \"OElig\",\"latin capital ligature OE, U+0152 ISOlat2\" },\n-{ 339,    \"oelig\",\"latin small ligature oe, U+0153 ISOlat2\" },\n-{ 352,    \"Scaron\",\"latin capital letter S with caron, U+0160 ISOlat2\" },\n-{ 353,    \"scaron\",\"latin small letter s with caron, U+0161 ISOlat2\" },\n-{ 376,    \"Yuml\",    \"latin capital letter Y with diaeresis, U+0178 ISOlat2\" },\n+{ 160,  \"nbsp\", \"no-break space = non-breaking space, U+00A0 ISOnum\" },\n+{ 161,  \"iexcl\",\"inverted exclamation mark, U+00A1 ISOnum\" },\n+{ 162,  \"cent\", \"cent sign, U+00A2 ISOnum\" },\n+{ 163,  \"pound\",\"pound sign, U+00A3 ISOnum\" },\n+{ 164,  \"curren\",\"currency sign, U+00A4 ISOnum\" },\n+{ 165,  \"yen\",  \"yen sign = yuan sign, U+00A5 ISOnum\" },\n+{ 166,  \"brvbar\",\"broken bar = broken vertical bar, U+00A6 ISOnum\" },\n+{ 167,  \"sect\", \"section sign, U+00A7 ISOnum\" },\n+{ 168,  \"uml\",  \"diaeresis = spacing diaeresis, U+00A8 ISOdia\" },\n+{ 169,  \"copy\", \"copyright sign, U+00A9 ISOnum\" },\n+{ 170,  \"ordf\", \"feminine ordinal indicator, U+00AA ISOnum\" },\n+{ 171,  \"laquo\",\"left-pointing double angle quotation mark = left pointing guillemet, U+00AB ISOnum\" },\n+{ 172,  \"not\",  \"not sign, U+00AC ISOnum\" },\n+{ 173,  \"shy\",  \"soft hyphen = discretionary hyphen, U+00AD ISOnum\" },\n+{ 174,  \"reg\",  \"registered sign = registered trade mark sign, U+00AE ISOnum\" },\n+{ 175,  \"macr\", \"macron = spacing macron = overline = APL overbar, U+00AF ISOdia\" },\n+{ 176,  \"deg\",  \"degree sign, U+00B0 ISOnum\" },\n+{ 177,  \"plusmn\",\"plus-minus sign = plus-or-minus sign, U+00B1 ISOnum\" },\n+{ 178,  \"sup2\", \"superscript two = superscript digit two = squared, U+00B2 ISOnum\" },\n+{ 179,  \"sup3\", \"superscript three = superscript digit three = cubed, U+00B3 ISOnum\" },\n+{ 180,  \"acute\",\"acute accent = spacing acute, U+00B4 ISOdia\" },\n+{ 181,  \"micro\",\"micro sign, U+00B5 ISOnum\" },\n+{ 182,  \"para\", \"pilcrow sign = paragraph sign, U+00B6 ISOnum\" },\n+{ 183,  \"middot\",\"middle dot = Georgian comma Greek middle dot, U+00B7 ISOnum\" },\n+{ 184,  \"cedil\",\"cedilla = spacing cedilla, U+00B8 ISOdia\" },\n+{ 185,  \"sup1\", \"superscript one = superscript digit one, U+00B9 ISOnum\" },\n+{ 186,  \"ordm\", \"masculine ordinal indicator, U+00BA ISOnum\" },\n+{ 187,  \"raquo\",\"right-pointing double angle quotation mark right pointing guillemet, U+00BB ISOnum\" },\n+{ 188,  \"frac14\",\"vulgar fraction one quarter = fraction one quarter, U+00BC ISOnum\" },\n+{ 189,  \"frac12\",\"vulgar fraction one half = fraction one half, U+00BD ISOnum\" },\n+{ 190,  \"frac34\",\"vulgar fraction three quarters = fraction three quarters, U+00BE ISOnum\" },\n+{ 191,  \"iquest\",\"inverted question mark = turned question mark, U+00BF ISOnum\" },\n+{ 192,  \"Agrave\",\"latin capital letter A with grave = latin capital letter A grave, U+00C0 ISOlat1\" },\n+{ 193,  \"Aacute\",\"latin capital letter A with acute, U+00C1 ISOlat1\" },\n+{ 194,  \"Acirc\",\"latin capital letter A with circumflex, U+00C2 ISOlat1\" },\n+{ 195,  \"Atilde\",\"latin capital letter A with tilde, U+00C3 ISOlat1\" },\n+{ 196,  \"Auml\", \"latin capital letter A with diaeresis, U+00C4 ISOlat1\" },\n+{ 197,  \"Aring\",\"latin capital letter A with ring above = latin capital letter A ring, U+00C5 ISOlat1\" },\n+{ 198,  \"AElig\",\"latin capital letter AE = latin capital ligature AE, U+00C6 ISOlat1\" },\n+{ 199,  \"Ccedil\",\"latin capital letter C with cedilla, U+00C7 ISOlat1\" },\n+{ 200,  \"Egrave\",\"latin capital letter E with grave, U+00C8 ISOlat1\" },\n+{ 201,  \"Eacute\",\"latin capital letter E with acute, U+00C9 ISOlat1\" },\n+{ 202,  \"Ecirc\",\"latin capital letter E with circumflex, U+00CA ISOlat1\" },\n+{ 203,  \"Euml\", \"latin capital letter E with diaeresis, U+00CB ISOlat1\" },\n+{ 204,  \"Igrave\",\"latin capital letter I with grave, U+00CC ISOlat1\" },\n+{ 205,  \"Iacute\",\"latin capital letter I with acute, U+00CD ISOlat1\" },\n+{ 206,  \"Icirc\",\"latin capital letter I with circumflex, U+00CE ISOlat1\" },\n+{ 207,  \"Iuml\", \"latin capital letter I with diaeresis, U+00CF ISOlat1\" },\n+{ 208,  \"ETH\",  \"latin capital letter ETH, U+00D0 ISOlat1\" },\n+{ 209,  \"Ntilde\",\"latin capital letter N with tilde, U+00D1 ISOlat1\" },\n+{ 210,  \"Ograve\",\"latin capital letter O with grave, U+00D2 ISOlat1\" },\n+{ 211,  \"Oacute\",\"latin capital letter O with acute, U+00D3 ISOlat1\" },\n+{ 212,  \"Ocirc\",\"latin capital letter O with circumflex, U+00D4 ISOlat1\" },\n+{ 213,  \"Otilde\",\"latin capital letter O with tilde, U+00D5 ISOlat1\" },\n+{ 214,  \"Ouml\", \"latin capital letter O with diaeresis, U+00D6 ISOlat1\" },\n+{ 215,  \"times\",\"multiplication sign, U+00D7 ISOnum\" },\n+{ 216,  \"Oslash\",\"latin capital letter O with stroke latin capital letter O slash, U+00D8 ISOlat1\" },\n+{ 217,  \"Ugrave\",\"latin capital letter U with grave, U+00D9 ISOlat1\" },\n+{ 218,  \"Uacute\",\"latin capital letter U with acute, U+00DA ISOlat1\" },\n+{ 219,  \"Ucirc\",\"latin capital letter U with circumflex, U+00DB ISOlat1\" },\n+{ 220,  \"Uuml\", \"latin capital letter U with diaeresis, U+00DC ISOlat1\" },\n+{ 221,  \"Yacute\",\"latin capital letter Y with acute, U+00DD ISOlat1\" },\n+{ 222,  \"THORN\",\"latin capital letter THORN, U+00DE ISOlat1\" },\n+{ 223,  \"szlig\",\"latin small letter sharp s = ess-zed, U+00DF ISOlat1\" },\n+{ 224,  \"agrave\",\"latin small letter a with grave = latin small letter a grave, U+00E0 ISOlat1\" },\n+{ 225,  \"aacute\",\"latin small letter a with acute, U+00E1 ISOlat1\" },\n+{ 226,  \"acirc\",\"latin small letter a with circumflex, U+00E2 ISOlat1\" },\n+{ 227,  \"atilde\",\"latin small letter a with tilde, U+00E3 ISOlat1\" },\n+{ 228,  \"auml\", \"latin small letter a with diaeresis, U+00E4 ISOlat1\" },\n+{ 229,  \"aring\",\"latin small letter a with ring above = latin small letter a ring, U+00E5 ISOlat1\" },\n+{ 230,  \"aelig\",\"latin small letter ae = latin small ligature ae, U+00E6 ISOlat1\" },\n+{ 231,  \"ccedil\",\"latin small letter c with cedilla, U+00E7 ISOlat1\" },\n+{ 232,  \"egrave\",\"latin small letter e with grave, U+00E8 ISOlat1\" },\n+{ 233,  \"eacute\",\"latin small letter e with acute, U+00E9 ISOlat1\" },\n+{ 234,  \"ecirc\",\"latin small letter e with circumflex, U+00EA ISOlat1\" },\n+{ 235,  \"euml\", \"latin small letter e with diaeresis, U+00EB ISOlat1\" },\n+{ 236,  \"igrave\",\"latin small letter i with grave, U+00EC ISOlat1\" },\n+{ 237,  \"iacute\",\"latin small letter i with acute, U+00ED ISOlat1\" },\n+{ 238,  \"icirc\",\"latin small letter i with circumflex, U+00EE ISOlat1\" },\n+{ 239,  \"iuml\", \"latin small letter i with diaeresis, U+00EF ISOlat1\" },\n+{ 240,  \"eth\",  \"latin small letter eth, U+00F0 ISOlat1\" },\n+{ 241,  \"ntilde\",\"latin small letter n with tilde, U+00F1 ISOlat1\" },\n+{ 242,  \"ograve\",\"latin small letter o with grave, U+00F2 ISOlat1\" },\n+{ 243,  \"oacute\",\"latin small letter o with acute, U+00F3 ISOlat1\" },\n+{ 244,  \"ocirc\",\"latin small letter o with circumflex, U+00F4 ISOlat1\" },\n+{ 245,  \"otilde\",\"latin small letter o with tilde, U+00F5 ISOlat1\" },\n+{ 246,  \"ouml\", \"latin small letter o with diaeresis, U+00F6 ISOlat1\" },\n+{ 247,  \"divide\",\"division sign, U+00F7 ISOnum\" },\n+{ 248,  \"oslash\",\"latin small letter o with stroke, = latin small letter o slash, U+00F8 ISOlat1\" },\n+{ 249,  \"ugrave\",\"latin small letter u with grave, U+00F9 ISOlat1\" },\n+{ 250,  \"uacute\",\"latin small letter u with acute, U+00FA ISOlat1\" },\n+{ 251,  \"ucirc\",\"latin small letter u with circumflex, U+00FB ISOlat1\" },\n+{ 252,  \"uuml\", \"latin small letter u with diaeresis, U+00FC ISOlat1\" },\n+{ 253,  \"yacute\",\"latin small letter y with acute, U+00FD ISOlat1\" },\n+{ 254,  \"thorn\",\"latin small letter thorn with, U+00FE ISOlat1\" },\n+{ 255,  \"yuml\", \"latin small letter y with diaeresis, U+00FF ISOlat1\" },\n+\n+{ 338,  \"OElig\",\"latin capital ligature OE, U+0152 ISOlat2\" },\n+{ 339,  \"oelig\",\"latin small ligature oe, U+0153 ISOlat2\" },\n+{ 352,  \"Scaron\",\"latin capital letter S with caron, U+0160 ISOlat2\" },\n+{ 353,  \"scaron\",\"latin small letter s with caron, U+0161 ISOlat2\" },\n+{ 376,  \"Yuml\", \"latin capital letter Y with diaeresis, U+0178 ISOlat2\" },\n@@ -1807,160 +1737,160 @@\n-{ 402,    \"fnof\",    \"latin small f with hook = function = florin, U+0192 ISOtech\" },\n-\n-{ 710,    \"circ\",    \"modifier letter circumflex accent, U+02C6 ISOpub\" },\n-{ 732,    \"tilde\",\"small tilde, U+02DC ISOdia\" },\n-\n-{ 913,    \"Alpha\",\"greek capital letter alpha, U+0391\" },\n-{ 914,    \"Beta\",    \"greek capital letter beta, U+0392\" },\n-{ 915,    \"Gamma\",\"greek capital letter gamma, U+0393 ISOgrk3\" },\n-{ 916,    \"Delta\",\"greek capital letter delta, U+0394 ISOgrk3\" },\n-{ 917,    \"Epsilon\",\"greek capital letter epsilon, U+0395\" },\n-{ 918,    \"Zeta\",    \"greek capital letter zeta, U+0396\" },\n-{ 919,    \"Eta\",    \"greek capital letter eta, U+0397\" },\n-{ 920,    \"Theta\",\"greek capital letter theta, U+0398 ISOgrk3\" },\n-{ 921,    \"Iota\",    \"greek capital letter iota, U+0399\" },\n-{ 922,    \"Kappa\",\"greek capital letter kappa, U+039A\" },\n-{ 923,    \"Lambda\", \"greek capital letter lambda, U+039B ISOgrk3\" },\n-{ 924,    \"Mu\",    \"greek capital letter mu, U+039C\" },\n-{ 925,    \"Nu\",    \"greek capital letter nu, U+039D\" },\n-{ 926,    \"Xi\",    \"greek capital letter xi, U+039E ISOgrk3\" },\n-{ 927,    \"Omicron\",\"greek capital letter omicron, U+039F\" },\n-{ 928,    \"Pi\",    \"greek capital letter pi, U+03A0 ISOgrk3\" },\n-{ 929,    \"Rho\",    \"greek capital letter rho, U+03A1\" },\n-{ 931,    \"Sigma\",\"greek capital letter sigma, U+03A3 ISOgrk3\" },\n-{ 932,    \"Tau\",    \"greek capital letter tau, U+03A4\" },\n-{ 933,    \"Upsilon\",\"greek capital letter upsilon, U+03A5 ISOgrk3\" },\n-{ 934,    \"Phi\",    \"greek capital letter phi, U+03A6 ISOgrk3\" },\n-{ 935,    \"Chi\",    \"greek capital letter chi, U+03A7\" },\n-{ 936,    \"Psi\",    \"greek capital letter psi, U+03A8 ISOgrk3\" },\n-{ 937,    \"Omega\",\"greek capital letter omega, U+03A9 ISOgrk3\" },\n-\n-{ 945,    \"alpha\",\"greek small letter alpha, U+03B1 ISOgrk3\" },\n-{ 946,    \"beta\",    \"greek small letter beta, U+03B2 ISOgrk3\" },\n-{ 947,    \"gamma\",\"greek small letter gamma, U+03B3 ISOgrk3\" },\n-{ 948,    \"delta\",\"greek small letter delta, U+03B4 ISOgrk3\" },\n-{ 949,    \"epsilon\",\"greek small letter epsilon, U+03B5 ISOgrk3\" },\n-{ 950,    \"zeta\",    \"greek small letter zeta, U+03B6 ISOgrk3\" },\n-{ 951,    \"eta\",    \"greek small letter eta, U+03B7 ISOgrk3\" },\n-{ 952,    \"theta\",\"greek small letter theta, U+03B8 ISOgrk3\" },\n-{ 953,    \"iota\",    \"greek small letter iota, U+03B9 ISOgrk3\" },\n-{ 954,    \"kappa\",\"greek small letter kappa, U+03BA ISOgrk3\" },\n-{ 955,    \"lambda\",\"greek small letter lambda, U+03BB ISOgrk3\" },\n-{ 956,    \"mu\",    \"greek small letter mu, U+03BC ISOgrk3\" },\n-{ 957,    \"nu\",    \"greek small letter nu, U+03BD ISOgrk3\" },\n-{ 958,    \"xi\",    \"greek small letter xi, U+03BE ISOgrk3\" },\n-{ 959,    \"omicron\",\"greek small letter omicron, U+03BF NEW\" },\n-{ 960,    \"pi\",    \"greek small letter pi, U+03C0 ISOgrk3\" },\n-{ 961,    \"rho\",    \"greek small letter rho, U+03C1 ISOgrk3\" },\n-{ 962,    \"sigmaf\",\"greek small letter final sigma, U+03C2 ISOgrk3\" },\n-{ 963,    \"sigma\",\"greek small letter sigma, U+03C3 ISOgrk3\" },\n-{ 964,    \"tau\",    \"greek small letter tau, U+03C4 ISOgrk3\" },\n-{ 965,    \"upsilon\",\"greek small letter upsilon, U+03C5 ISOgrk3\" },\n-{ 966,    \"phi\",    \"greek small letter phi, U+03C6 ISOgrk3\" },\n-{ 967,    \"chi\",    \"greek small letter chi, U+03C7 ISOgrk3\" },\n-{ 968,    \"psi\",    \"greek small letter psi, U+03C8 ISOgrk3\" },\n-{ 969,    \"omega\",\"greek small letter omega, U+03C9 ISOgrk3\" },\n-{ 977,    \"thetasym\",\"greek small letter theta symbol, U+03D1 NEW\" },\n-{ 978,    \"upsih\",\"greek upsilon with hook symbol, U+03D2 NEW\" },\n-{ 982,    \"piv\",    \"greek pi symbol, U+03D6 ISOgrk3\" },\n-\n-{ 8194,    \"ensp\",    \"en space, U+2002 ISOpub\" },\n-{ 8195,    \"emsp\",    \"em space, U+2003 ISOpub\" },\n-{ 8201,    \"thinsp\",\"thin space, U+2009 ISOpub\" },\n-{ 8204,    \"zwnj\",    \"zero width non-joiner, U+200C NEW RFC 2070\" },\n-{ 8205,    \"zwj\",    \"zero width joiner, U+200D NEW RFC 2070\" },\n-{ 8206,    \"lrm\",    \"left-to-right mark, U+200E NEW RFC 2070\" },\n-{ 8207,    \"rlm\",    \"right-to-left mark, U+200F NEW RFC 2070\" },\n-{ 8211,    \"ndash\",\"en dash, U+2013 ISOpub\" },\n-{ 8212,    \"mdash\",\"em dash, U+2014 ISOpub\" },\n-{ 8216,    \"lsquo\",\"left single quotation mark, U+2018 ISOnum\" },\n-{ 8217,    \"rsquo\",\"right single quotation mark, U+2019 ISOnum\" },\n-{ 8218,    \"sbquo\",\"single low-9 quotation mark, U+201A NEW\" },\n-{ 8220,    \"ldquo\",\"left double quotation mark, U+201C ISOnum\" },\n-{ 8221,    \"rdquo\",\"right double quotation mark, U+201D ISOnum\" },\n-{ 8222,    \"bdquo\",\"double low-9 quotation mark, U+201E NEW\" },\n-{ 8224,    \"dagger\",\"dagger, U+2020 ISOpub\" },\n-{ 8225,    \"Dagger\",\"double dagger, U+2021 ISOpub\" },\n-\n-{ 8226,    \"bull\",    \"bullet = black small circle, U+2022 ISOpub\" },\n-{ 8230,    \"hellip\",\"horizontal ellipsis = three dot leader, U+2026 ISOpub\" },\n-\n-{ 8240,    \"permil\",\"per mille sign, U+2030 ISOtech\" },\n-\n-{ 8242,    \"prime\",\"prime = minutes = feet, U+2032 ISOtech\" },\n-{ 8243,    \"Prime\",\"double prime = seconds = inches, U+2033 ISOtech\" },\n-\n-{ 8249,    \"lsaquo\",\"single left-pointing angle quotation mark, U+2039 ISO proposed\" },\n-{ 8250,    \"rsaquo\",\"single right-pointing angle quotation mark, U+203A ISO proposed\" },\n-\n-{ 8254,    \"oline\",\"overline = spacing overscore, U+203E NEW\" },\n-{ 8260,    \"frasl\",\"fraction slash, U+2044 NEW\" },\n-\n-{ 8364,    \"euro\",    \"euro sign, U+20AC NEW\" },\n-\n-{ 8465,    \"image\",\"blackletter capital I = imaginary part, U+2111 ISOamso\" },\n-{ 8472,    \"weierp\",\"script capital P = power set = Weierstrass p, U+2118 ISOamso\" },\n-{ 8476,    \"real\",    \"blackletter capital R = real part symbol, U+211C ISOamso\" },\n-{ 8482,    \"trade\",\"trade mark sign, U+2122 ISOnum\" },\n-{ 8501,    \"alefsym\",\"alef symbol = first transfinite cardinal, U+2135 NEW\" },\n-{ 8592,    \"larr\",    \"leftwards arrow, U+2190 ISOnum\" },\n-{ 8593,    \"uarr\",    \"upwards arrow, U+2191 ISOnum\" },\n-{ 8594,    \"rarr\",    \"rightwards arrow, U+2192 ISOnum\" },\n-{ 8595,    \"darr\",    \"downwards arrow, U+2193 ISOnum\" },\n-{ 8596,    \"harr\",    \"left right arrow, U+2194 ISOamsa\" },\n-{ 8629,    \"crarr\",\"downwards arrow with corner leftwards = carriage return, U+21B5 NEW\" },\n-{ 8656,    \"lArr\",    \"leftwards double arrow, U+21D0 ISOtech\" },\n-{ 8657,    \"uArr\",    \"upwards double arrow, U+21D1 ISOamsa\" },\n-{ 8658,    \"rArr\",    \"rightwards double arrow, U+21D2 ISOtech\" },\n-{ 8659,    \"dArr\",    \"downwards double arrow, U+21D3 ISOamsa\" },\n-{ 8660,    \"hArr\",    \"left right double arrow, U+21D4 ISOamsa\" },\n-\n-{ 8704,    \"forall\",\"for all, U+2200 ISOtech\" },\n-{ 8706,    \"part\",    \"partial differential, U+2202 ISOtech\" },\n-{ 8707,    \"exist\",\"there exists, U+2203 ISOtech\" },\n-{ 8709,    \"empty\",\"empty set = null set = diameter, U+2205 ISOamso\" },\n-{ 8711,    \"nabla\",\"nabla = backward difference, U+2207 ISOtech\" },\n-{ 8712,    \"isin\",    \"element of, U+2208 ISOtech\" },\n-{ 8713,    \"notin\",\"not an element of, U+2209 ISOtech\" },\n-{ 8715,    \"ni\",    \"contains as member, U+220B ISOtech\" },\n-{ 8719,    \"prod\",    \"n-ary product = product sign, U+220F ISOamsb\" },\n-{ 8721,    \"sum\",    \"n-ary summation, U+2211 ISOamsb\" },\n-{ 8722,    \"minus\",\"minus sign, U+2212 ISOtech\" },\n-{ 8727,    \"lowast\",\"asterisk operator, U+2217 ISOtech\" },\n-{ 8730,    \"radic\",\"square root = radical sign, U+221A ISOtech\" },\n-{ 8733,    \"prop\",    \"proportional to, U+221D ISOtech\" },\n-{ 8734,    \"infin\",\"infinity, U+221E ISOtech\" },\n-{ 8736,    \"ang\",    \"angle, U+2220 ISOamso\" },\n-{ 8743,    \"and\",    \"logical and = wedge, U+2227 ISOtech\" },\n-{ 8744,    \"or\",    \"logical or = vee, U+2228 ISOtech\" },\n-{ 8745,    \"cap\",    \"intersection = cap, U+2229 ISOtech\" },\n-{ 8746,    \"cup\",    \"union = cup, U+222A ISOtech\" },\n-{ 8747,    \"int\",    \"integral, U+222B ISOtech\" },\n-{ 8756,    \"there4\",\"therefore, U+2234 ISOtech\" },\n-{ 8764,    \"sim\",    \"tilde operator = varies with = similar to, U+223C ISOtech\" },\n-{ 8773,    \"cong\",    \"approximately equal to, U+2245 ISOtech\" },\n-{ 8776,    \"asymp\",\"almost equal to = asymptotic to, U+2248 ISOamsr\" },\n-{ 8800,    \"ne\",    \"not equal to, U+2260 ISOtech\" },\n-{ 8801,    \"equiv\",\"identical to, U+2261 ISOtech\" },\n-{ 8804,    \"le\",    \"less-than or equal to, U+2264 ISOtech\" },\n-{ 8805,    \"ge\",    \"greater-than or equal to, U+2265 ISOtech\" },\n-{ 8834,    \"sub\",    \"subset of, U+2282 ISOtech\" },\n-{ 8835,    \"sup\",    \"superset of, U+2283 ISOtech\" },\n-{ 8836,    \"nsub\",    \"not a subset of, U+2284 ISOamsn\" },\n-{ 8838,    \"sube\",    \"subset of or equal to, U+2286 ISOtech\" },\n-{ 8839,    \"supe\",    \"superset of or equal to, U+2287 ISOtech\" },\n-{ 8853,    \"oplus\",\"circled plus = direct sum, U+2295 ISOamsb\" },\n-{ 8855,    \"otimes\",\"circled times = vector product, U+2297 ISOamsb\" },\n-{ 8869,    \"perp\",    \"up tack = orthogonal to = perpendicular, U+22A5 ISOtech\" },\n-{ 8901,    \"sdot\",    \"dot operator, U+22C5 ISOamsb\" },\n-{ 8968,    \"lceil\",\"left ceiling = apl upstile, U+2308 ISOamsc\" },\n-{ 8969,    \"rceil\",\"right ceiling, U+2309 ISOamsc\" },\n-{ 8970,    \"lfloor\",\"left floor = apl downstile, U+230A ISOamsc\" },\n-{ 8971,    \"rfloor\",\"right floor, U+230B ISOamsc\" },\n-{ 9001,    \"lang\",    \"left-pointing angle bracket = bra, U+2329 ISOtech\" },\n-{ 9002,    \"rang\",    \"right-pointing angle bracket = ket, U+232A ISOtech\" },\n-{ 9674,    \"loz\",    \"lozenge, U+25CA ISOpub\" },\n-\n-{ 9824,    \"spades\",\"black spade suit, U+2660 ISOpub\" },\n-{ 9827,    \"clubs\",\"black club suit = shamrock, U+2663 ISOpub\" },\n-{ 9829,    \"hearts\",\"black heart suit = valentine, U+2665 ISOpub\" },\n-{ 9830,    \"diams\",\"black diamond suit, U+2666 ISOpub\" },\n+{ 402,  \"fnof\", \"latin small f with hook = function = florin, U+0192 ISOtech\" },\n+\n+{ 710,  \"circ\", \"modifier letter circumflex accent, U+02C6 ISOpub\" },\n+{ 732,  \"tilde\",\"small tilde, U+02DC ISOdia\" },\n+\n+{ 913,  \"Alpha\",\"greek capital letter alpha, U+0391\" },\n+{ 914,  \"Beta\", \"greek capital letter beta, U+0392\" },\n+{ 915,  \"Gamma\",\"greek capital letter gamma, U+0393 ISOgrk3\" },\n+{ 916,  \"Delta\",\"greek capital letter delta, U+0394 ISOgrk3\" },\n+{ 917,  \"Epsilon\",\"greek capital letter epsilon, U+0395\" },\n+{ 918,  \"Zeta\", \"greek capital letter zeta, U+0396\" },\n+{ 919,  \"Eta\",  \"greek capital letter eta, U+0397\" },\n+{ 920,  \"Theta\",\"greek capital letter theta, U+0398 ISOgrk3\" },\n+{ 921,  \"Iota\", \"greek capital letter iota, U+0399\" },\n+{ 922,  \"Kappa\",\"greek capital letter kappa, U+039A\" },\n+{ 923,  \"Lambda\", \"greek capital letter lambda, U+039B ISOgrk3\" },\n+{ 924,  \"Mu\",   \"greek capital letter mu, U+039C\" },\n+{ 925,  \"Nu\",   \"greek capital letter nu, U+039D\" },\n+{ 926,  \"Xi\",   \"greek capital letter xi, U+039E ISOgrk3\" },\n+{ 927,  \"Omicron\",\"greek capital letter omicron, U+039F\" },\n+{ 928,  \"Pi\",   \"greek capital letter pi, U+03A0 ISOgrk3\" },\n+{ 929,  \"Rho\",  \"greek capital letter rho, U+03A1\" },\n+{ 931,  \"Sigma\",\"greek capital letter sigma, U+03A3 ISOgrk3\" },\n+{ 932,  \"Tau\",  \"greek capital letter tau, U+03A4\" },\n+{ 933,  \"Upsilon\",\"greek capital letter upsilon, U+03A5 ISOgrk3\" },\n+{ 934,  \"Phi\",  \"greek capital letter phi, U+03A6 ISOgrk3\" },\n+{ 935,  \"Chi\",  \"greek capital letter chi, U+03A7\" },\n+{ 936,  \"Psi\",  \"greek capital letter psi, U+03A8 ISOgrk3\" },\n+{ 937,  \"Omega\",\"greek capital letter omega, U+03A9 ISOgrk3\" },\n+\n+{ 945,  \"alpha\",\"greek small letter alpha, U+03B1 ISOgrk3\" },\n+{ 946,  \"beta\", \"greek small letter beta, U+03B2 ISOgrk3\" },\n+{ 947,  \"gamma\",\"greek small letter gamma, U+03B3 ISOgrk3\" },\n+{ 948,  \"delta\",\"greek small letter delta, U+03B4 ISOgrk3\" },\n+{ 949,  \"epsilon\",\"greek small letter epsilon, U+03B5 ISOgrk3\" },\n+{ 950,  \"zeta\", \"greek small letter zeta, U+03B6 ISOgrk3\" },\n+{ 951,  \"eta\",  \"greek small letter eta, U+03B7 ISOgrk3\" },\n+{ 952,  \"theta\",\"greek small letter theta, U+03B8 ISOgrk3\" },\n+{ 953,  \"iota\", \"greek small letter iota, U+03B9 ISOgrk3\" },\n+{ 954,  \"kappa\",\"greek small letter kappa, U+03BA ISOgrk3\" },\n+{ 955,  \"lambda\",\"greek small letter lambda, U+03BB ISOgrk3\" },\n+{ 956,  \"mu\",   \"greek small letter mu, U+03BC ISOgrk3\" },\n+{ 957,  \"nu\",   \"greek small letter nu, U+03BD ISOgrk3\" },\n+{ 958,  \"xi\",   \"greek small letter xi, U+03BE ISOgrk3\" },\n+{ 959,  \"omicron\",\"greek small letter omicron, U+03BF NEW\" },\n+{ 960,  \"pi\",   \"greek small letter pi, U+03C0 ISOgrk3\" },\n+{ 961,  \"rho\",  \"greek small letter rho, U+03C1 ISOgrk3\" },\n+{ 962,  \"sigmaf\",\"greek small letter final sigma, U+03C2 ISOgrk3\" },\n+{ 963,  \"sigma\",\"greek small letter sigma, U+03C3 ISOgrk3\" },\n+{ 964,  \"tau\",  \"greek small letter tau, U+03C4 ISOgrk3\" },\n+{ 965,  \"upsilon\",\"greek small letter upsilon, U+03C5 ISOgrk3\" },\n+{ 966,  \"phi\",  \"greek small letter phi, U+03C6 ISOgrk3\" },\n+{ 967,  \"chi\",  \"greek small letter chi, U+03C7 ISOgrk3\" },\n+{ 968,  \"psi\",  \"greek small letter psi, U+03C8 ISOgrk3\" },\n+{ 969,  \"omega\",\"greek small letter omega, U+03C9 ISOgrk3\" },\n+{ 977,  \"thetasym\",\"greek small letter theta symbol, U+03D1 NEW\" },\n+{ 978,  \"upsih\",\"greek upsilon with hook symbol, U+03D2 NEW\" },\n+{ 982,  \"piv\",  \"greek pi symbol, U+03D6 ISOgrk3\" },\n+\n+{ 8194, \"ensp\", \"en space, U+2002 ISOpub\" },\n+{ 8195, \"emsp\", \"em space, U+2003 ISOpub\" },\n+{ 8201, \"thinsp\",\"thin space, U+2009 ISOpub\" },\n+{ 8204, \"zwnj\", \"zero width non-joiner, U+200C NEW RFC 2070\" },\n+{ 8205, \"zwj\",  \"zero width joiner, U+200D NEW RFC 2070\" },\n+{ 8206, \"lrm\",  \"left-to-right mark, U+200E NEW RFC 2070\" },\n+{ 8207, \"rlm\",  \"right-to-left mark, U+200F NEW RFC 2070\" },\n+{ 8211, \"ndash\",\"en dash, U+2013 ISOpub\" },\n+{ 8212, \"mdash\",\"em dash, U+2014 ISOpub\" },\n+{ 8216, \"lsquo\",\"left single quotation mark, U+2018 ISOnum\" },\n+{ 8217, \"rsquo\",\"right single quotation mark, U+2019 ISOnum\" },\n+{ 8218, \"sbquo\",\"single low-9 quotation mark, U+201A NEW\" },\n+{ 8220, \"ldquo\",\"left double quotation mark, U+201C ISOnum\" },\n+{ 8221, \"rdquo\",\"right double quotation mark, U+201D ISOnum\" },\n+{ 8222, \"bdquo\",\"double low-9 quotation mark, U+201E NEW\" },\n+{ 8224, \"dagger\",\"dagger, U+2020 ISOpub\" },\n+{ 8225, \"Dagger\",\"double dagger, U+2021 ISOpub\" },\n+\n+{ 8226, \"bull\", \"bullet = black small circle, U+2022 ISOpub\" },\n+{ 8230, \"hellip\",\"horizontal ellipsis = three dot leader, U+2026 ISOpub\" },\n+\n+{ 8240, \"permil\",\"per mille sign, U+2030 ISOtech\" },\n+\n+{ 8242, \"prime\",\"prime = minutes = feet, U+2032 ISOtech\" },\n+{ 8243, \"Prime\",\"double prime = seconds = inches, U+2033 ISOtech\" },\n+\n+{ 8249, \"lsaquo\",\"single left-pointing angle quotation mark, U+2039 ISO proposed\" },\n+{ 8250, \"rsaquo\",\"single right-pointing angle quotation mark, U+203A ISO proposed\" },\n+\n+{ 8254, \"oline\",\"overline = spacing overscore, U+203E NEW\" },\n+{ 8260, \"frasl\",\"fraction slash, U+2044 NEW\" },\n+\n+{ 8364, \"euro\", \"euro sign, U+20AC NEW\" },\n+\n+{ 8465, \"image\",\"blackletter capital I = imaginary part, U+2111 ISOamso\" },\n+{ 8472, \"weierp\",\"script capital P = power set = Weierstrass p, U+2118 ISOamso\" },\n+{ 8476, \"real\", \"blackletter capital R = real part symbol, U+211C ISOamso\" },\n+{ 8482, \"trade\",\"trade mark sign, U+2122 ISOnum\" },\n+{ 8501, \"alefsym\",\"alef symbol = first transfinite cardinal, U+2135 NEW\" },\n+{ 8592, \"larr\", \"leftwards arrow, U+2190 ISOnum\" },\n+{ 8593, \"uarr\", \"upwards arrow, U+2191 ISOnum\" },\n+{ 8594, \"rarr\", \"rightwards arrow, U+2192 ISOnum\" },\n+{ 8595, \"darr\", \"downwards arrow, U+2193 ISOnum\" },\n+{ 8596, \"harr\", \"left right arrow, U+2194 ISOamsa\" },\n+{ 8629, \"crarr\",\"downwards arrow with corner leftwards = carriage return, U+21B5 NEW\" },\n+{ 8656, \"lArr\", \"leftwards double arrow, U+21D0 ISOtech\" },\n+{ 8657, \"uArr\", \"upwards double arrow, U+21D1 ISOamsa\" },\n+{ 8658, \"rArr\", \"rightwards double arrow, U+21D2 ISOtech\" },\n+{ 8659, \"dArr\", \"downwards double arrow, U+21D3 ISOamsa\" },\n+{ 8660, \"hArr\", \"left right double arrow, U+21D4 ISOamsa\" },\n+\n+{ 8704, \"forall\",\"for all, U+2200 ISOtech\" },\n+{ 8706, \"part\", \"partial differential, U+2202 ISOtech\" },\n+{ 8707, \"exist\",\"there exists, U+2203 ISOtech\" },\n+{ 8709, \"empty\",\"empty set = null set = diameter, U+2205 ISOamso\" },\n+{ 8711, \"nabla\",\"nabla = backward difference, U+2207 ISOtech\" },\n+{ 8712, \"isin\", \"element of, U+2208 ISOtech\" },\n+{ 8713, \"notin\",\"not an element of, U+2209 ISOtech\" },\n+{ 8715, \"ni\",   \"contains as member, U+220B ISOtech\" },\n+{ 8719, \"prod\", \"n-ary product = product sign, U+220F ISOamsb\" },\n+{ 8721, \"sum\",  \"n-ary summation, U+2211 ISOamsb\" },\n+{ 8722, \"minus\",\"minus sign, U+2212 ISOtech\" },\n+{ 8727, \"lowast\",\"asterisk operator, U+2217 ISOtech\" },\n+{ 8730, \"radic\",\"square root = radical sign, U+221A ISOtech\" },\n+{ 8733, \"prop\", \"proportional to, U+221D ISOtech\" },\n+{ 8734, \"infin\",\"infinity, U+221E ISOtech\" },\n+{ 8736, \"ang\",  \"angle, U+2220 ISOamso\" },\n+{ 8743, \"and\",  \"logical and = wedge, U+2227 ISOtech\" },\n+{ 8744, \"or\",   \"logical or = vee, U+2228 ISOtech\" },\n+{ 8745, \"cap\",  \"intersection = cap, U+2229 ISOtech\" },\n+{ 8746, \"cup\",  \"union = cup, U+222A ISOtech\" },\n+{ 8747, \"int\",  \"integral, U+222B ISOtech\" },\n+{ 8756, \"there4\",\"therefore, U+2234 ISOtech\" },\n+{ 8764, \"sim\",  \"tilde operator = varies with = similar to, U+223C ISOtech\" },\n+{ 8773, \"cong\", \"approximately equal to, U+2245 ISOtech\" },\n+{ 8776, \"asymp\",\"almost equal to = asymptotic to, U+2248 ISOamsr\" },\n+{ 8800, \"ne\",   \"not equal to, U+2260 ISOtech\" },\n+{ 8801, \"equiv\",\"identical to, U+2261 ISOtech\" },\n+{ 8804, \"le\",   \"less-than or equal to, U+2264 ISOtech\" },\n+{ 8805, \"ge\",   \"greater-than or equal to, U+2265 ISOtech\" },\n+{ 8834, \"sub\",  \"subset of, U+2282 ISOtech\" },\n+{ 8835, \"sup\",  \"superset of, U+2283 ISOtech\" },\n+{ 8836, \"nsub\", \"not a subset of, U+2284 ISOamsn\" },\n+{ 8838, \"sube\", \"subset of or equal to, U+2286 ISOtech\" },\n+{ 8839, \"supe\", \"superset of or equal to, U+2287 ISOtech\" },\n+{ 8853, \"oplus\",\"circled plus = direct sum, U+2295 ISOamsb\" },\n+{ 8855, \"otimes\",\"circled times = vector product, U+2297 ISOamsb\" },\n+{ 8869, \"perp\", \"up tack = orthogonal to = perpendicular, U+22A5 ISOtech\" },\n+{ 8901, \"sdot\", \"dot operator, U+22C5 ISOamsb\" },\n+{ 8968, \"lceil\",\"left ceiling = apl upstile, U+2308 ISOamsc\" },\n+{ 8969, \"rceil\",\"right ceiling, U+2309 ISOamsc\" },\n+{ 8970, \"lfloor\",\"left floor = apl downstile, U+230A ISOamsc\" },\n+{ 8971, \"rfloor\",\"right floor, U+230B ISOamsc\" },\n+{ 9001, \"lang\", \"left-pointing angle bracket = bra, U+2329 ISOtech\" },\n+{ 9002, \"rang\", \"right-pointing angle bracket = ket, U+232A ISOtech\" },\n+{ 9674, \"loz\",  \"lozenge, U+25CA ISOpub\" },\n+\n+{ 9824, \"spades\",\"black spade suit, U+2660 ISOpub\" },\n+{ 9827, \"clubs\",\"black club suit = shamrock, U+2663 ISOpub\" },\n+{ 9829, \"hearts\",\"black heart suit = valentine, U+2665 ISOpub\" },\n+{ 9830, \"diams\",\"black diamond suit, U+2666 ISOpub\" },\n@@ -1971,3 +1901,3 @@\n- *                                    *\n- *        Commodity functions to handle entities            *\n- *                                    *\n+ *                                                                      *\n+ *              Commodity functions to handle entities                  *\n+ *                                                                      *\n@@ -1976,15 +1906,0 @@\n-\/*\n- * Macro used to grow the current buffer.\n- *\/\n-#define growBuffer(buffer) {                        \\\n-    xmlChar *tmp;                            \\\n-    buffer##_size *= 2;                            \\\n-    tmp = (xmlChar *) xmlRealloc(buffer, buffer##_size);         \\\n-    if (tmp == NULL) {                            \\\n-    htmlErrMemory(ctxt);            \\\n-    xmlFree(buffer);                        \\\n-    return(NULL);                            \\\n-    }                                    \\\n-    buffer = tmp;                            \\\n-}\n-\n@@ -2009,1 +1924,1 @@\n-    }\n+        }\n@@ -2045,1 +1960,1 @@\n- * UTF8ToHtml:\n+ * htmlUTF8ToHtml:\n@@ -2060,5 +1975,2 @@\n-UTF8ToHtml(unsigned char* out, int *outlen,\n-              const unsigned char* in, int *inlen) {\n-    const unsigned char* processed = in;\n-    const unsigned char* outend;\n-    const unsigned char* outstart = out;\n+htmlUTF8ToHtml(unsigned char* out, int *outlen,\n+               const unsigned char* in, int *inlen) {\n@@ -2067,2 +1979,6 @@\n-    unsigned int c, d;\n-    int trailing;\n+    unsigned char* outstart = out;\n+    unsigned char* outend;\n+    int ret = XML_ENC_ERR_SPACE;\n+\n+    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -2070,1 +1986,0 @@\n-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);\n@@ -2073,5 +1988,5 @@\n-     * initialization nothing to do\n-     *\/\n-    *outlen = 0;\n-    *inlen = 0;\n-    return(0);\n+         * initialization nothing to do\n+         *\/\n+        *outlen = 0;\n+        *inlen = 0;\n+        return(XML_ENC_ERR_SUCCESS);\n@@ -2079,2 +1994,3 @@\n-    inend = in + (*inlen);\n-    outend = out + (*outlen);\n+\n+    inend = in + *inlen;\n+    outend = out + *outlen;\n@@ -2082,16 +1998,5 @@\n-    d = *in++;\n-    if      (d < 0x80)  { c= d; trailing= 0; }\n-    else if (d < 0xC0) {\n-        \/* trailing byte in leading position *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n-        } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }\n-        else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }\n-        else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }\n-    else {\n-        \/* no chance for this in Ascii *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n-    }\n+        const htmlEntityDesc *ent;\n+        const char *cp;\n+        char nbuf[16];\n+        unsigned c, d;\n+        int seqlen, len, i;\n@@ -2099,3 +2004,1 @@\n-    if (inend - in < trailing) {\n-        break;\n-    }\n+        d = *in;\n@@ -2103,6 +2006,7 @@\n-    for ( ; trailing; trailing--) {\n-        if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))\n-        break;\n-        c <<= 6;\n-        c |= d & 0x3F;\n-    }\n+        if (d < 0x80) {\n+            if (out >= outend)\n+                goto done;\n+            *out++ = d;\n+            in += 1;\n+            continue;\n+        }\n@@ -2110,10 +2014,12 @@\n-    \/* assertion: c is a single UTF-4 value *\/\n-    if (c < 0x80) {\n-        if (out + 1 >= outend)\n-        break;\n-        *out++ = c;\n-    } else {\n-        int len;\n-        const htmlEntityDesc * ent;\n-        const char *cp;\n-        char nbuf[16];\n+        if (d < 0xE0)      { c = d & 0x1F; seqlen = 2; }\n+        else if (d < 0xF0) { c = d & 0x0F; seqlen = 3; }\n+        else               { c = d & 0x07; seqlen = 4; }\n+\n+        if (inend - in < seqlen)\n+            break;\n+\n+        for (i = 1; i < seqlen; i++) {\n+            d = in[i];\n+            c <<= 6;\n+            c |= d & 0x3F;\n+        }\n@@ -2124,1 +2030,0 @@\n-\n@@ -2126,0 +2031,1 @@\n+\n@@ -2129,2 +2035,1 @@\n-        }\n-        else\n+        } else {\n@@ -2132,0 +2037,2 @@\n+        }\n+\n@@ -2133,2 +2040,3 @@\n-        if (out + 2 + len >= outend)\n-        break;\n+        if (outend - out < len + 2)\n+            goto done;\n+\n@@ -2139,0 +2047,2 @@\n+\n+        in += seqlen;\n@@ -2140,2 +2050,4 @@\n-    processed = in;\n-    }\n+\n+    ret = out - outstart;\n+\n+done:\n@@ -2143,2 +2055,2 @@\n-    *inlen = processed - instart;\n-    return(0);\n+    *inlen = in - instart;\n+    return(ret);\n@@ -2165,1 +2077,1 @@\n-           const unsigned char* in, int *inlen, int quoteChar) {\n+                   const unsigned char* in, int *inlen, int quoteChar) {\n@@ -2179,7 +2091,7 @@\n-    d = *in++;\n-    if      (d < 0x80)  { c= d; trailing= 0; }\n-    else if (d < 0xC0) {\n-        \/* trailing byte in leading position *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n+        d = *in++;\n+        if      (d < 0x80)  { c= d; trailing= 0; }\n+        else if (d < 0xC0) {\n+            \/* trailing byte in leading position *\/\n+            *outlen = out - outstart;\n+            *inlen = processed - instart;\n+            return(-2);\n@@ -2189,6 +2101,6 @@\n-    else {\n-        \/* no chance for this in Ascii *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n-    }\n+        else {\n+            \/* no chance for this in Ascii *\/\n+            *outlen = out - outstart;\n+            *inlen = processed - instart;\n+            return(-2);\n+        }\n@@ -2196,2 +2108,2 @@\n-    if (inend - in < trailing)\n-        break;\n+        if (inend - in < trailing)\n+            break;\n@@ -2199,5 +2111,8 @@\n-    while (trailing--) {\n-        if (((d= *in++) & 0xC0) != 0x80) {\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(-2);\n+        while (trailing--) {\n+            if (((d= *in++) & 0xC0) != 0x80) {\n+                *outlen = out - outstart;\n+                *inlen = processed - instart;\n+                return(-2);\n+            }\n+            c <<= 6;\n+            c |= d & 0x3F;\n@@ -2205,3 +2120,0 @@\n-        c <<= 6;\n-        c |= d & 0x3F;\n-    }\n@@ -2209,11 +2121,11 @@\n-    \/* assertion: c is a single UTF-4 value *\/\n-    if ((c < 0x80) && (c != (unsigned int) quoteChar) &&\n-        (c != '&') && (c != '<') && (c != '>')) {\n-        if (out >= outend)\n-        break;\n-        *out++ = c;\n-    } else {\n-        const htmlEntityDesc * ent;\n-        const char *cp;\n-        char nbuf[16];\n-        int len;\n+        \/* assertion: c is a single UTF-4 value *\/\n+        if ((c < 0x80) && (c != (unsigned int) quoteChar) &&\n+            (c != '&') && (c != '<') && (c != '>')) {\n+            if (out >= outend)\n+                break;\n+            *out++ = c;\n+        } else {\n+            const htmlEntityDesc * ent;\n+            const char *cp;\n+            char nbuf[16];\n+            int len;\n@@ -2221,7 +2133,17 @@\n-        \/*\n-         * Try to lookup a predefined HTML entity for it\n-         *\/\n-        ent = htmlEntityValueLookup(c);\n-        if (ent == NULL) {\n-        snprintf(nbuf, sizeof(nbuf), \"#%u\", c);\n-        cp = nbuf;\n+            \/*\n+             * Try to lookup a predefined HTML entity for it\n+             *\/\n+            ent = htmlEntityValueLookup(c);\n+            if (ent == NULL) {\n+                snprintf(nbuf, sizeof(nbuf), \"#%u\", c);\n+                cp = nbuf;\n+            }\n+            else\n+                cp = ent->name;\n+            len = strlen(cp);\n+            if (outend - out < len + 2)\n+                break;\n+            *out++ = '&';\n+            memcpy(out, cp, len);\n+            out += len;\n+            *out++ = ';';\n@@ -2229,11 +2151,1 @@\n-        else\n-        cp = ent->name;\n-        len = strlen(cp);\n-        if (outend - out < len + 2)\n-        break;\n-        *out++ = '&';\n-        memcpy(out, cp, len);\n-        out += len;\n-        *out++ = ';';\n-    }\n-    processed = in;\n+        processed = in;\n@@ -2247,3 +2159,3 @@\n- *                                    *\n- *        Commodity functions, cleanup needed ?            *\n- *                                    *\n+ *                                                                      *\n+ *              Commodity functions, cleanup needed ?                   *\n+ *                                                                      *\n@@ -2274,1 +2186,1 @@\n- * Returns 1 if ignorable 0 otherwise.\n+ * Returns 1 if ignorable 0 if whitespace, -1 otherwise.\n@@ -2284,1 +2196,1 @@\n-        if (!(IS_BLANK_CH(str[j]))) return(0);\n+        if (!(IS_WS_HTML(str[j]))) return(-1);\n@@ -2289,1 +2201,1 @@\n-    return(1);\n+        return(1);\n@@ -2291,1 +2203,1 @@\n-    return(1);\n+        return(1);\n@@ -2293,1 +2205,1 @@\n-    return(1);\n+        return(1);\n@@ -2308,1 +2220,1 @@\n-    lastChild = lastChild->prev;\n+        lastChild = lastChild->prev;\n@@ -2312,5 +2224,6 @@\n-    \/* keep ws in constructs like ...<b> <\/b>...\n-       for all tags \"b\" allowing PCDATA *\/\n-    for ( i = 0; i < sizeof(allowPCData)\/sizeof(allowPCData[0]); i++ ) {\n-        if ( xmlStrEqual(ctxt->name, BAD_CAST allowPCData[i]) ) {\n-        return(0);\n+        \/* keep ws in constructs like ...<b> <\/b>...\n+           for all tags \"b\" allowing PCDATA *\/\n+        for ( i = 0; i < sizeof(allowPCData)\/sizeof(allowPCData[0]); i++ ) {\n+            if ( xmlStrEqual(ctxt->name, BAD_CAST allowPCData[i]) ) {\n+                return(0);\n+            }\n@@ -2318,1 +2231,0 @@\n-    }\n@@ -2322,5 +2234,6 @@\n-    \/* keep ws in constructs like <p><b>xy<\/b> <i>z<\/i><p>\n-       for all tags \"p\" allowing PCDATA *\/\n-    for ( i = 0; i < sizeof(allowPCData)\/sizeof(allowPCData[0]); i++ ) {\n-        if ( xmlStrEqual(lastChild->name, BAD_CAST allowPCData[i]) ) {\n-        return(0);\n+        \/* keep ws in constructs like <p><b>xy<\/b> <i>z<\/i><p>\n+           for all tags \"p\" allowing PCDATA *\/\n+        for ( i = 0; i < sizeof(allowPCData)\/sizeof(allowPCData[0]); i++ ) {\n+            if ( xmlStrEqual(lastChild->name, BAD_CAST allowPCData[i]) ) {\n+                return(0);\n+            }\n@@ -2329,1 +2242,0 @@\n-    }\n@@ -2352,1 +2264,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2372,1 +2284,1 @@\n-    (URI != NULL)) {\n+        (URI != NULL)) {\n@@ -2375,1 +2287,1 @@\n-    intSubset = xmlCreateIntSubset(cur, BAD_CAST \"html\", ExternalID, URI);\n+        intSubset = xmlCreateIntSubset(cur, BAD_CAST \"html\", ExternalID, URI);\n@@ -2381,2 +2293,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -2398,3 +2310,3 @@\n-    return(htmlNewDocNoDtD(\n-            BAD_CAST \"http:\/\/www.w3.org\/TR\/REC-html40\/loose.dtd\",\n-            BAD_CAST \"-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\"));\n+        return(htmlNewDocNoDtD(\n+                    BAD_CAST \"http:\/\/www.w3.org\/TR\/REC-html40\/loose.dtd\",\n+                    BAD_CAST \"-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\"));\n@@ -2407,4 +2319,4 @@\n- *                                    *\n- *            The parser itself                *\n- *    Relates to http:\/\/www.w3.org\/TR\/html40                *\n- *                                    *\n+ *                                                                      *\n+ *                      The parser itself                               *\n+ *      Relates to http:\/\/www.w3.org\/TR\/html40                          *\n+ *                                                                      *\n@@ -2414,3 +2326,3 @@\n- *                                    *\n- *            The parser itself                *\n- *                                    *\n+ *                                                                      *\n+ *                      The parser itself                               *\n+ *                                                                      *\n@@ -2419,19 +2331,0 @@\n-static const xmlChar * htmlParseNameComplex(xmlParserCtxtPtr ctxt);\n-\n-static void\n-htmlSkipBogusComment(htmlParserCtxtPtr ctxt) {\n-    int c;\n-\n-    htmlParseErr(ctxt, XML_HTML_INCORRECTLY_OPENED_COMMENT,\n-                 \"Incorrectly opened comment\\n\", NULL, NULL);\n-\n-    while (PARSER_STOPPED(ctxt) == 0) {\n-        c = CUR;\n-        if (c == 0)\n-            break;\n-        NEXT;\n-        if (c == '>')\n-            break;\n-    }\n-}\n-\n@@ -2448,5 +2341,9 @@\n-static const xmlChar *\n-htmlParseHTMLName(htmlParserCtxtPtr ctxt) {\n-    const xmlChar *ret;\n-    int i = 0;\n-    xmlChar loc[HTML_PARSER_BUFFER_SIZE];\n+static xmlHashedString\n+htmlParseHTMLName(htmlParserCtxtPtr ctxt, int attr) {\n+    xmlHashedString ret;\n+    xmlChar buf[HTML_PARSER_BUFFER_SIZE];\n+    const xmlChar *in;\n+    size_t avail;\n+    int eof = PARSER_PROGRESSIVE(ctxt);\n+    int nbchar = 0;\n+    int stop = attr ? '=' : ' ';\n@@ -2454,2 +2351,2 @@\n-    if (!IS_ASCII_LETTER(CUR) && (CUR != '_') &&\n-        (CUR != ':') && (CUR != '.')) return(NULL);\n+    in = ctxt->input->cur;\n+    avail = ctxt->input->end - in;\n@@ -2457,7 +2354,2 @@\n-    while ((i < HTML_PARSER_BUFFER_SIZE) &&\n-           ((IS_ASCII_LETTER(CUR)) || (IS_ASCII_DIGIT(CUR)) ||\n-       (CUR == ':') || (CUR == '-') || (CUR == '_') ||\n-           (CUR == '.'))) {\n-    if ((CUR >= 'A') && (CUR <= 'Z')) loc[i] = CUR + 0x20;\n-        else loc[i] = CUR;\n-    i++;\n+    while (1) {\n+        int c, size;\n@@ -2465,2 +2357,2 @@\n-    NEXT;\n-    }\n+        if ((!eof) && (avail < 32)) {\n+            size_t oldAvail = avail;\n@@ -2468,3 +2360,1 @@\n-    ret = xmlDictLookup(ctxt->dict, loc, i);\n-    if (ret == NULL)\n-        htmlErrMemory(ctxt);\n+            ctxt->input->cur = in;\n@@ -2472,2 +2362,2 @@\n-    return(ret);\n-}\n+            SHRINK;\n+            xmlParserGrow(ctxt);\n@@ -2475,0 +2365,2 @@\n+            in = ctxt->input->cur;\n+            avail = ctxt->input->end - in;\n@@ -2476,10 +2368,3 @@\n-\/**\n- * htmlParseHTMLName_nonInvasive:\n- * @ctxt:  an HTML parser context\n- *\n- * parse an HTML tag or attribute name, note that we convert it to lowercase\n- * since HTML names are not case-sensitive, this doesn't consume the data\n- * from the stream, it's a look-ahead\n- *\n- * Returns the Tag Name parsed or NULL\n- *\/\n+            if (oldAvail == avail)\n+                eof = 1;\n+        }\n@@ -2487,5 +2372,33 @@\n-static const xmlChar *\n-htmlParseHTMLName_nonInvasive(htmlParserCtxtPtr ctxt) {\n-    int i = 0;\n-    xmlChar loc[HTML_PARSER_BUFFER_SIZE];\n-    const xmlChar *ret;\n+        if (avail == 0)\n+            break;\n+\n+        c = *in;\n+        size = 1;\n+\n+        if ((nbchar != 0) &&\n+            ((c == '\/') || (c == '>') || (c == stop) ||\n+             (IS_WS_HTML(c))))\n+            break;\n+\n+        if (c == 0) {\n+            if (nbchar + 3 <= HTML_PARSER_BUFFER_SIZE) {\n+                buf[nbchar++] = 0xEF;\n+                buf[nbchar++] = 0xBF;\n+                buf[nbchar++] = 0xBD;\n+            }\n+        } else if (c < 0x80) {\n+            if (nbchar < HTML_PARSER_BUFFER_SIZE) {\n+                if (IS_UPPER(c))\n+                    c += 0x20;\n+                buf[nbchar++] = c;\n+            }\n+        } else {\n+            size = htmlValidateUtf8(ctxt, in, avail, \/* partial *\/ 0);\n+\n+            if (size > 0) {\n+                if (nbchar + size <= HTML_PARSER_BUFFER_SIZE) {\n+                    memcpy(buf + nbchar, in, size);\n+                    nbchar += size;\n+                }\n+            } else {\n+                size = 1;\n@@ -2493,2 +2406,7 @@\n-    if (!IS_ASCII_LETTER(NXT(1)) && (NXT(1) != '_') &&\n-        (NXT(1) != ':')) return(NULL);\n+                if (nbchar + 3 <= HTML_PARSER_BUFFER_SIZE) {\n+                    buf[nbchar++] = 0xEF;\n+                    buf[nbchar++] = 0xBF;\n+                    buf[nbchar++] = 0xBD;\n+                }\n+            }\n+        }\n@@ -2496,6 +2414,2 @@\n-    while ((i < HTML_PARSER_BUFFER_SIZE) &&\n-           ((IS_ASCII_LETTER(NXT(1+i))) || (IS_ASCII_DIGIT(NXT(1+i))) ||\n-       (NXT(1+i) == ':') || (NXT(1+i) == '-') || (NXT(1+i) == '_'))) {\n-    if ((NXT(1+i) >= 'A') && (NXT(1+i) <= 'Z')) loc[i] = NXT(1+i) + 0x20;\n-        else loc[i] = NXT(1+i);\n-    i++;\n+        in += size;\n+        avail -= size;\n@@ -2504,2 +2418,6 @@\n-    ret = xmlDictLookup(ctxt->dict, loc, i);\n-    if (ret == NULL)\n+    ctxt->input->cur = in;\n+\n+    SHRINK;\n+\n+    ret = xmlDictLookupHashed(ctxt->dict, buf, nbchar);\n+    if (ret.name == NULL)\n@@ -2511,9 +2429,6 @@\n-\n-\/**\n- * htmlParseName:\n- * @ctxt:  an HTML parser context\n- *\n- * parse an HTML name, this routine is case sensitive.\n- *\n- * Returns the Name parsed or NULL\n- *\/\n+static const short htmlC1Remap[32] = {\n+    0x20AC, 0x0081, 0x201A, 0x0192, 0x201E, 0x2026, 0x2020, 0x2021,\n+    0x02C6, 0x2030, 0x0160, 0x2039, 0x0152, 0x008D, 0x017D, 0x008F,\n+    0x0090, 0x2018, 0x2019, 0x201C, 0x201D, 0x2022, 0x2013, 0x2014,\n+    0x02DC, 0x2122, 0x0161, 0x203A, 0x0153, 0x009D, 0x017E, 0x0178\n+};\n@@ -2522,4 +2437,3 @@\n-htmlParseName(htmlParserCtxtPtr ctxt) {\n-    const xmlChar *in;\n-    const xmlChar *ret;\n-    int count = 0;\n+htmlCodePointToUtf8(int c, xmlChar *out, int *osize) {\n+    int i = 0;\n+    int bits, hi;\n@@ -2527,1 +2441,7 @@\n-    GROW;\n+    if ((c >= 0x80) && (c < 0xA0)) {\n+        c = htmlC1Remap[c - 0x80];\n+    } else if ((c <= 0) ||\n+               ((c >= 0xD800) && (c < 0xE000)) ||\n+               (c > 0x10FFFF)) {\n+        c = 0xFFFD;\n+    }\n@@ -2529,17 +2449,4 @@\n-    \/*\n-     * Accelerator for simple ASCII names\n-     *\/\n-    in = ctxt->input->cur;\n-    if (((*in >= 0x61) && (*in <= 0x7A)) ||\n-    ((*in >= 0x41) && (*in <= 0x5A)) ||\n-    (*in == '_') || (*in == ':')) {\n-    in++;\n-    while (((*in >= 0x61) && (*in <= 0x7A)) ||\n-           ((*in >= 0x41) && (*in <= 0x5A)) ||\n-           ((*in >= 0x30) && (*in <= 0x39)) ||\n-           (*in == '_') || (*in == '-') ||\n-           (*in == ':') || (*in == '.'))\n-        in++;\n-\n-    if (in == ctxt->input->end)\n-        return(NULL);\n+    if      (c <    0x80) { bits =  0; hi = 0x00; }\n+    else if (c <   0x800) { bits =  6; hi = 0xC0; }\n+    else if (c < 0x10000) { bits = 12; hi = 0xE0; }\n+    else                  { bits = 18; hi = 0xF0; }\n@@ -2547,9 +2454,5 @@\n-    if ((*in > 0) && (*in < 0x80)) {\n-        count = in - ctxt->input->cur;\n-        ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);\n-            if (ret == NULL)\n-                htmlErrMemory(ctxt);\n-        ctxt->input->cur = in;\n-        ctxt->input->col += count;\n-        return(ret);\n-    }\n+    out[i++] = (c >> bits) | hi;\n+\n+    while (bits > 0) {\n+        bits -= 6;\n+        out[i++] = ((c >> bits) & 0x3F) | 0x80;\n@@ -2557,1 +2460,3 @@\n-    return(htmlParseNameComplex(ctxt));\n+\n+    *osize = i;\n+    return(out);\n@@ -2560,0 +2465,6 @@\n+#include \"html5ent.inc\"\n+\n+#define ENT_F_SEMICOLON 0x80u\n+#define ENT_F_SUBTABLE  0x40u\n+#define ENT_F_ALL       0xC0u\n+\n@@ -2561,8 +2472,12 @@\n-htmlParseNameComplex(xmlParserCtxtPtr ctxt) {\n-    int len = 0, l;\n-    int c;\n-    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n-                    XML_MAX_TEXT_LENGTH :\n-                    XML_MAX_NAME_LENGTH;\n-    const xmlChar *base = ctxt->input->base;\n-    const xmlChar *ret;\n+htmlFindEntityPrefix(const xmlChar *string, size_t slen, int isAttr,\n+                     int *nlen, int *rlen) {\n+    const xmlChar *match = NULL;\n+    unsigned left, right;\n+    int first = string[0];\n+    size_t matchLen = 0;\n+    size_t soff = 1;\n+\n+    if (slen < 2)\n+        return(NULL);\n+    if (!IS_ASCII_LETTER(first))\n+        return(NULL);\n@@ -2571,1 +2486,1 @@\n-     * Handler for more complex cases\n+     * Look up range by first character\n@@ -2573,6 +2488,3 @@\n-    c = CUR_CHAR(l);\n-    if ((c == ' ') || (c == '>') || (c == '\/') || \/* accelerators *\/\n-    (!IS_LETTER(c) && (c != '_') &&\n-         (c != ':'))) {\n-    return(NULL);\n-    }\n+    first &= 63;\n+    left = htmlEntAlpha[first*3] | htmlEntAlpha[first*3+1] << 8;\n+    right = left + htmlEntAlpha[first*3+2];\n@@ -2580,10 +2492,28 @@\n-    while ((c != ' ') && (c != '>') && (c != '\/') && \/* test bigname.xml *\/\n-       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n-            (c == '.') || (c == '-') ||\n-        (c == '_') || (c == ':') ||\n-        (IS_COMBINING(c)) ||\n-        (IS_EXTENDER(c)))) {\n-    len += l;\n-        if (len > maxLength) {\n-            htmlParseErr(ctxt, XML_ERR_NAME_TOO_LONG, \"name too long\", NULL, NULL);\n-            return(NULL);\n+    \/*\n+     * Binary search\n+     *\/\n+    while (left < right) {\n+        const xmlChar *bytes;\n+        unsigned mid;\n+        size_t len;\n+        int cmp;\n+\n+        mid = left + (right - left) \/ 2;\n+        bytes = htmlEntStrings + htmlEntValues[mid];\n+        len = bytes[0] & ~ENT_F_ALL;\n+\n+        cmp = string[soff] - bytes[1];\n+\n+        if (cmp == 0) {\n+            if (slen < len) {\n+                cmp = strncmp((const char *) string + soff + 1,\n+                              (const char *) bytes + 2,\n+                              slen - 1);\n+                \/* Prefix can never match *\/\n+                if (cmp == 0)\n+                    break;\n+            } else {\n+                cmp = strncmp((const char *) string + soff + 1,\n+                              (const char *) bytes + 2,\n+                              len - 1);\n+            }\n@@ -2591,10 +2521,0 @@\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n-    if (ctxt->input->base != base) {\n-        \/*\n-         * We changed encoding from an unknown encoding\n-         * Input buffer changed location, so we better start again\n-         *\/\n-        return(htmlParseNameComplex(ctxt));\n-    }\n-    }\n@@ -2602,5 +2522,35 @@\n-    if (ctxt->input->cur - ctxt->input->base < len) {\n-        \/* Sanity check *\/\n-    htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                     \"unexpected change of input buffer\", NULL, NULL);\n-        return (NULL);\n+        if (cmp < 0) {\n+            right = mid;\n+        } else if (cmp > 0) {\n+            left = mid + 1;\n+        } else {\n+            int term = soff + len < slen ? string[soff + len] : 0;\n+            int isAlnum, isTerm;\n+\n+            isAlnum = IS_ALNUM(term);\n+            isTerm = ((term == ';') ||\n+                      ((bytes[0] & ENT_F_SEMICOLON) &&\n+                       ((!isAttr) ||\n+                        ((!isAlnum) && (term != '=')))));\n+\n+            if (isTerm) {\n+                match = bytes + len + 1;\n+                matchLen = soff + len;\n+                if (term == ';')\n+                    matchLen += 1;\n+            }\n+\n+            if (bytes[0] & ENT_F_SUBTABLE) {\n+                if (isTerm)\n+                    match += 2;\n+\n+                if ((isAlnum) && (soff + len < slen)) {\n+                    left = mid + bytes[len + 1];\n+                    right = left + bytes[len + 2];\n+                    soff += len;\n+                    continue;\n+                }\n+            }\n+\n+            break;\n+        }\n@@ -2609,3 +2559,2 @@\n-    ret = xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len);\n-    if (ret == NULL)\n-        htmlErrMemory(ctxt);\n+    if (match == NULL)\n+        return(NULL);\n@@ -2613,1 +2562,3 @@\n-    return(ret);\n+    *nlen = matchLen;\n+    *rlen = match[0];\n+    return(match + 1);\n@@ -2616,1 +2567,0 @@\n-\n@@ -2618,1 +2568,1 @@\n- * htmlParseHTMLAttribute:\n+ * htmlParseData:\n@@ -2620,1 +2570,4 @@\n- * @stop:  a char stop value\n+ * @mask:  mask of terminating characters\n+ * @comment:  true if parsing a comment\n+ * @refs:  true if references are allowed\n+ * @maxLength:  maximum output length\n@@ -2622,2 +2575,1 @@\n- * parse an HTML attribute value till the stop (quote), if\n- * stop is 0 then it stops at the first space\n+ * Parse data until terminator is reached.\n@@ -2625,1 +2577,1 @@\n- * Returns the attribute parsed or NULL\n+ * Returns the parsed string or NULL in case of errors.\n@@ -2629,16 +2581,15 @@\n-htmlParseHTMLAttribute(htmlParserCtxtPtr ctxt, const xmlChar stop) {\n-    xmlChar *buffer = NULL;\n-    int buffer_size = 0;\n-    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n-                    XML_MAX_HUGE_LENGTH :\n-                    XML_MAX_TEXT_LENGTH;\n-    xmlChar *out = NULL;\n-    const xmlChar *name = NULL;\n-    const xmlChar *cur = NULL;\n-    const htmlEntityDesc * ent;\n-\n-    \/*\n-     * allocate a translation buffer.\n-     *\/\n-    buffer_size = HTML_PARSER_BUFFER_SIZE;\n-    buffer = (xmlChar *) xmlMallocAtomic(buffer_size);\n+htmlParseData(htmlParserCtxtPtr ctxt, htmlAsciiMask mask,\n+              int comment, int refs, int maxLength) {\n+    xmlParserInputPtr input = ctxt->input;\n+    xmlChar *ret = NULL;\n+    xmlChar *buffer;\n+    xmlChar utf8Char[4];\n+    size_t buffer_size;\n+    size_t used;\n+    int eof = PARSER_PROGRESSIVE(ctxt);\n+    int line, col;\n+    int termSkip = -1;\n+\n+    used = 0;\n+    buffer_size = ctxt->spaceMax;\n+    buffer = (xmlChar *) ctxt->spaceTab;\n@@ -2646,2 +2597,6 @@\n-    htmlErrMemory(ctxt);\n-    return(NULL);\n+        buffer_size = 500;\n+        buffer = xmlMalloc(buffer_size + 1);\n+        if (buffer == NULL) {\n+            htmlErrMemory(ctxt);\n+            return(NULL);\n+        }\n@@ -2649,1 +2604,0 @@\n-    out = buffer;\n@@ -2651,21 +2605,2 @@\n-    \/*\n-     * Ok loop until we reach one of the ending chars\n-     *\/\n-    while ((PARSER_STOPPED(ctxt) == 0) &&\n-           (CUR != 0) && (CUR != stop)) {\n-    if ((stop == 0) && (CUR == '>')) break;\n-    if ((stop == 0) && (IS_BLANK_CH(CUR))) break;\n-        if (CUR == '&') {\n-        if (NXT(1) == '#') {\n-        unsigned int c;\n-        int bits;\n-\n-        c = htmlParseCharRef(ctxt);\n-        if      (c <    0x80)\n-                { *out++  = c;                bits= -6; }\n-        else if (c <   0x800)\n-                { *out++  =((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n-        else if (c < 0x10000)\n-                { *out++  =((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n-        else\n-                { *out++  =((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n+    line = input->line;\n+    col = input->col;\n@@ -2673,3 +2608,8 @@\n-        for ( ; bits >= 0; bits-= 6) {\n-            *out++  = ((c >> bits) & 0x3F) | 0x80;\n-        }\n+    while (!PARSER_STOPPED(ctxt)) {\n+        const xmlChar *chunk, *in, *repl;\n+        size_t avail, chunkSize, extraSize;\n+        int replSize;\n+        int skip = 0;\n+        int ncr = 0;\n+        int ncrSize = 0;\n+        int cp = 0;\n@@ -2677,2 +2617,3 @@\n-        if (out - buffer > buffer_size - 100) {\n-            int indx = out - buffer;\n+        chunk = input->cur;\n+        avail = input->end - chunk;\n+        in = chunk;\n@@ -2680,9 +2621,12 @@\n-            growBuffer(buffer);\n-            out = &buffer[indx];\n-        }\n-        } else {\n-        ent = htmlParseEntityRef(ctxt, &name);\n-        if (name == NULL) {\n-            *out++ = '&';\n-            if (out - buffer > buffer_size - 100) {\n-            int indx = out - buffer;\n+        repl = BAD_CAST \"\";\n+        replSize = 0;\n+\n+        while (!PARSER_STOPPED(ctxt)) {\n+            size_t j;\n+            int cur, size;\n+\n+            if ((!eof) && (avail <= 64)) {\n+                size_t oldAvail = avail;\n+                size_t off = in - chunk;\n+\n+                input->cur = in;\n@@ -2690,2 +2634,9 @@\n-            growBuffer(buffer);\n-            out = &buffer[indx];\n+                xmlParserGrow(ctxt);\n+\n+                in = input->cur;\n+                chunk = in - off;\n+                input->cur = chunk;\n+                avail = input->end - in;\n+\n+                if (oldAvail == avail)\n+                    eof = 1;\n@@ -2693,6 +2644,0 @@\n-        } else if (ent == NULL) {\n-            *out++ = '&';\n-            cur = name;\n-            while (*cur != 0) {\n-            if (out - buffer > buffer_size - 100) {\n-                int indx = out - buffer;\n@@ -2700,2 +2645,3 @@\n-                growBuffer(buffer);\n-                out = &buffer[indx];\n+            if (avail == 0) {\n+                termSkip = 0;\n+                break;\n@@ -2703,1 +2649,28 @@\n-            *out++ = *cur++;\n+\n+            cur = *in;\n+            size = 1;\n+            col += 1;\n+\n+            if (htmlMaskMatch(mask, cur)) {\n+                if (comment) {\n+                    if (avail < 2) {\n+                        termSkip = 1;\n+                    } else if (in[1] == '-') {\n+                        if  (avail < 3) {\n+                            termSkip = 2;\n+                        } else if (in[2] == '>') {\n+                            termSkip = 3;\n+                        } else if (in[2] == '!') {\n+                            if (avail < 4)\n+                                termSkip = 3;\n+                            else if (in[3] == '>')\n+                                termSkip = 4;\n+                        }\n+                    }\n+\n+                    if (termSkip >= 0)\n+                        break;\n+                } else {\n+                    termSkip = 0;\n+                    break;\n+                }\n@@ -2705,3 +2678,0 @@\n-        } else {\n-            unsigned int c;\n-            int bits;\n@@ -2709,2 +2679,20 @@\n-            if (out - buffer > buffer_size - 100) {\n-            int indx = out - buffer;\n+            if (ncr) {\n+                int lc = cur | 0x20;\n+                int digit;\n+\n+                if ((cur >= '0') && (cur <= '9')) {\n+                    digit = cur - '0';\n+                } else if ((ncr == 16) && (lc >= 'a') && (lc <= 'f')) {\n+                    digit = (lc - 'a') + 10;\n+                } else {\n+                    if (cur == ';') {\n+                        in += 1;\n+                        size += 1;\n+                        ncrSize += 1;\n+                    }\n+                    goto next_chunk;\n+                }\n+\n+                cp = cp * ncr + digit;\n+                if (cp >= 0x110000)\n+                    cp = 0x110000;\n@@ -2712,2 +2700,3 @@\n-            growBuffer(buffer);\n-            out = &buffer[indx];\n+                ncrSize += 1;\n+\n+                goto next_char;\n@@ -2715,9 +2704,0 @@\n-            c = ent->value;\n-            if      (c <    0x80)\n-            { *out++  = c;                bits= -6; }\n-            else if (c <   0x800)\n-            { *out++  =((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n-            else if (c < 0x10000)\n-            { *out++  =((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n-            else\n-            { *out++  =((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n@@ -2725,2 +2705,96 @@\n-            for ( ; bits >= 0; bits-= 6) {\n-            *out++  = ((c >> bits) & 0x3F) | 0x80;\n+            switch (cur) {\n+            case '&':\n+                if (!refs)\n+                    break;\n+\n+                j = 1;\n+\n+                if ((j < avail) && (in[j] == '#')) {\n+                    j += 1;\n+                    if (j < avail) {\n+                        if ((in[j] | 0x20) == 'x') {\n+                            j += 1;\n+                            if ((j < avail) && (IS_HEX_DIGIT(in[j]))) {\n+                                ncr = 16;\n+                                size = 3;\n+                                ncrSize = 3;\n+                                cp = 0;\n+                            }\n+                        } else if (IS_ASCII_DIGIT(in[j])) {\n+                            ncr = 10;\n+                            size = 2;\n+                            ncrSize = 2;\n+                            cp = 0;\n+                        }\n+                    }\n+                } else {\n+                    repl = htmlFindEntityPrefix(in + j,\n+                                                avail - j,\n+                                                \/* isAttr *\/ 1,\n+                                                &skip, &replSize);\n+                    if (repl != NULL) {\n+                        skip += 1;\n+                        goto next_chunk;\n+                    }\n+\n+                    skip = 0;\n+                }\n+\n+                break;\n+\n+            case '\\0':\n+                skip = 1;\n+                repl = BAD_CAST \"\\xEF\\xBF\\xBD\";\n+                replSize = 3;\n+                goto next_chunk;\n+\n+            case '\\n':\n+                line += 1;\n+                col = 1;\n+                break;\n+\n+            case '\\r':\n+                skip = 1;\n+                if (in[1] != 0x0A) {\n+                    repl = BAD_CAST \"\\x0A\";\n+                    replSize = 1;\n+                }\n+                goto next_chunk;\n+\n+            default:\n+                if (cur < 0x80)\n+                    break;\n+\n+                if ((input->flags & XML_INPUT_HAS_ENCODING) == 0) {\n+                    xmlChar * guess;\n+\n+                    if (in > chunk)\n+                        goto next_chunk;\n+\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+                    guess = NULL;\n+#else\n+                    guess = htmlFindEncoding(ctxt);\n+#endif\n+                    if (guess == NULL) {\n+                        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);\n+                    } else {\n+                        xmlSwitchEncodingName(ctxt, (const char *) guess);\n+                        xmlFree(guess);\n+                    }\n+                    input->flags |= XML_INPUT_HAS_ENCODING;\n+\n+                    eof = PARSER_PROGRESSIVE(ctxt);\n+                    goto restart;\n+                }\n+\n+                size = htmlValidateUtf8(ctxt, in, avail, \/* partial *\/ 0);\n+\n+                if (size <= 0) {\n+                    skip = 1;\n+                    repl = BAD_CAST \"\\xEF\\xBF\\xBD\";\n+                    replSize = 3;\n+                    goto next_chunk;\n+                }\n+\n+                break;\n@@ -2728,0 +2802,4 @@\n+\n+next_char:\n+            in += size;\n+            avail -= size;\n@@ -2729,0 +2807,7 @@\n+\n+next_chunk:\n+        if (ncrSize > 0) {\n+            skip = ncrSize;\n+            in -= ncrSize;\n+\n+            repl = htmlCodePointToUtf8(cp, utf8Char, &replSize);\n@@ -2730,3 +2815,0 @@\n-    } else {\n-        unsigned int c;\n-        int bits, l;\n@@ -2734,2 +2816,2 @@\n-        if (out - buffer > buffer_size - 100) {\n-        int indx = out - buffer;\n+        chunkSize = in - chunk;\n+        extraSize = chunkSize + replSize;\n@@ -2737,2 +2819,4 @@\n-        growBuffer(buffer);\n-        out = &buffer[indx];\n+        if (extraSize > maxLength - used) {\n+            htmlParseErr(ctxt, XML_ERR_RESOURCE_LIMIT,\n+                         \"value too long\\n\", NULL, NULL);\n+            goto error;\n@@ -2740,9 +2824,0 @@\n-        c = CUR_CHAR(l);\n-        if      (c <    0x80)\n-            { *out++  = c;                bits= -6; }\n-        else if (c <   0x800)\n-            { *out++  =((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n-        else if (c < 0x10000)\n-            { *out++  =((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n-        else\n-            { *out++  =((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n@@ -2750,2 +2825,10 @@\n-        for ( ; bits >= 0; bits-= 6) {\n-        *out++  = ((c >> bits) & 0x3F) | 0x80;\n+        if (extraSize > buffer_size - used) {\n+            size_t newSize = (used + extraSize) * 2;\n+            xmlChar *tmp = xmlRealloc(buffer, newSize + 1);\n+\n+            if (tmp == NULL) {\n+                htmlErrMemory(ctxt);\n+                goto error;\n+            }\n+            buffer = tmp;\n+            buffer_size = newSize;\n@@ -2753,7 +2836,11 @@\n-        NEXTL(l);\n-    }\n-        if (out - buffer > maxLength) {\n-            htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                         \"attribute value too long\\n\", NULL, NULL);\n-            xmlFree(buffer);\n-            return(NULL);\n+\n+        if (chunkSize > 0) {\n+            input->cur += chunkSize;\n+            memcpy(buffer + used, chunk, chunkSize);\n+            used += chunkSize;\n+        }\n+\n+        input->cur += skip;\n+        if (replSize > 0) {\n+            memcpy(buffer + used, repl, replSize);\n+            used += replSize;\n@@ -2761,0 +2848,24 @@\n+\n+        SHRINK;\n+\n+        if (termSkip >= 0)\n+            break;\n+\n+restart:\n+        ;\n+    }\n+\n+    if (termSkip > 0) {\n+        input->cur += termSkip;\n+        col += termSkip;\n+    }\n+\n+    input->line = line;\n+    input->col = col;\n+\n+    ret = xmlMalloc(used + 1);\n+    if (ret == NULL) {\n+        htmlErrMemory(ctxt);\n+    } else {\n+        memcpy(ret, buffer, used);\n+        ret[used] = 0;\n@@ -2762,2 +2873,6 @@\n-    *out = 0;\n-    return(buffer);\n+\n+error:\n+    ctxt->spaceTab = (void *) buffer;\n+    ctxt->spaceMax = buffer_size;\n+\n+    return(ret);\n@@ -2773,6 +2888,1 @@\n- * parse an HTML ENTITY references\n- *\n- * [68] EntityRef ::= '&' Name ';'\n- *\n- * Returns the associated htmlEntityDescPtr if found, or NULL otherwise,\n- *         if non-NULL *str will have to be freed by the caller.\n+ * Returns NULL.\n@@ -2781,35 +2891,3 @@\n-htmlParseEntityRef(htmlParserCtxtPtr ctxt, const xmlChar **str) {\n-    const xmlChar *name;\n-    const htmlEntityDesc * ent = NULL;\n-\n-    if (str != NULL) *str = NULL;\n-    if ((ctxt == NULL) || (ctxt->input == NULL)) return(NULL);\n-\n-    if (CUR == '&') {\n-        NEXT;\n-        name = htmlParseName(ctxt);\n-    if (name == NULL) {\n-        htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n-                     \"htmlParseEntityRef: no name\\n\", NULL, NULL);\n-    } else {\n-        GROW;\n-        if (CUR == ';') {\n-            if (str != NULL)\n-            *str = name;\n-\n-        \/*\n-         * Lookup the entity in the table.\n-         *\/\n-        ent = htmlEntityLookup(name);\n-        if (ent != NULL) \/* OK that's ugly !!! *\/\n-            NEXT;\n-        } else {\n-        htmlParseErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING,\n-                     \"htmlParseEntityRef: expecting ';'\\n\",\n-                 NULL, NULL);\n-            if (str != NULL)\n-            *str = name;\n-        }\n-    }\n-    }\n-    return(ent);\n+htmlParseEntityRef(htmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED,\n+                   const xmlChar **str ATTRIBUTE_UNUSED) {\n+    return(NULL);\n@@ -2833,0 +2911,3 @@\n+    int maxLength = (ctxt->options & HTML_PARSE_HUGE) ?\n+                    XML_MAX_HUGE_LENGTH :\n+                    XML_MAX_TEXT_LENGTH;\n@@ -2835,7 +2916,4 @@\n-        NEXT;\n-    ret = htmlParseHTMLAttribute(ctxt, '\"');\n-        if (CUR != '\"') {\n-        htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                     \"AttValue: \\\" expected\\n\", NULL, NULL);\n-    } else\n-        NEXT;\n+        SKIP(1);\n+        ret = htmlParseData(ctxt, MASK_DQ, 0, 1, maxLength);\n+        if (CUR == '\"')\n+            SKIP(1);\n@@ -2843,7 +2921,4 @@\n-        NEXT;\n-    ret = htmlParseHTMLAttribute(ctxt, '\\'');\n-        if (CUR != '\\'') {\n-        htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,\n-                     \"AttValue: ' expected\\n\", NULL, NULL);\n-    } else\n-        NEXT;\n+        SKIP(1);\n+        ret = htmlParseData(ctxt, MASK_SQ, 0, 1, maxLength);\n+        if (CUR == '\\'')\n+            SKIP(1);\n@@ -2851,8 +2926,1 @@\n-        \/*\n-     * That's an HTMLism, the attribute value may not be quoted\n-     *\/\n-    ret = htmlParseHTMLAttribute(ctxt, 0);\n-    if (ret == NULL) {\n-        htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,\n-                     \"AttValue: no value found\\n\", NULL, NULL);\n-    }\n+        ret = htmlParseData(ctxt, MASK_WS_GT, 0, 1, maxLength);\n@@ -2863,10 +2931,5 @@\n-\/**\n- * htmlParseSystemLiteral:\n- * @ctxt:  an HTML parser context\n- *\n- * parse an HTML Literal\n- *\n- * [11] SystemLiteral ::= ('\"' [^\"]* '\"') | (\"'\" [^']* \"'\")\n- *\n- * Returns the SystemLiteral parsed or NULL\n- *\/\n+static void\n+htmlCharDataSAXCallback(htmlParserCtxtPtr ctxt, const xmlChar *buf,\n+                        int size, int mode) {\n+    if ((ctxt->sax == NULL) || (ctxt->disableSAX))\n+        return;\n@@ -2874,6 +2937,6 @@\n-static xmlChar *\n-htmlParseSystemLiteral(htmlParserCtxtPtr ctxt) {\n-    size_t len = 0, startPosition = 0;\n-    int err = 0;\n-    int quote;\n-    xmlChar *ret = NULL;\n+    if ((mode == 0) || (mode == DATA_RCDATA) ||\n+        (ctxt->sax->cdataBlock == NULL)) {\n+        if ((ctxt->name == NULL) ||\n+            (xmlStrEqual(ctxt->name, BAD_CAST \"html\")) ||\n+            (xmlStrEqual(ctxt->name, BAD_CAST \"head\"))) {\n+            int i;\n@@ -2881,7 +2944,7 @@\n-    if ((CUR != '\"') && (CUR != '\\'')) {\n-    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,\n-                 \"SystemLiteral \\\" or ' expected\\n\", NULL, NULL);\n-        return(NULL);\n-    }\n-    quote = CUR;\n-    NEXT;\n+            \/*\n+             * Add leading whitespace to html or head elements before\n+             * calling htmlStartCharData.\n+             *\/\n+            for (i = 0; i < size; i++)\n+                if (!IS_WS_HTML(buf[i]))\n+                    break;\n@@ -2889,3 +2952,8 @@\n-    if (CUR_PTR < BASE_PTR)\n-        return(ret);\n-    startPosition = CUR_PTR - BASE_PTR;\n+            if (i > 0) {\n+                if (!ctxt->keepBlanks) {\n+                    if (ctxt->sax->ignorableWhitespace != NULL)\n+                        ctxt->sax->ignorableWhitespace(ctxt->userData, buf, i);\n+                } else {\n+                    if (ctxt->sax->characters != NULL)\n+                        ctxt->sax->characters(ctxt->userData, buf, i);\n+                }\n@@ -2893,20 +2961,2 @@\n-    while ((PARSER_STOPPED(ctxt) == 0) &&\n-           (CUR != 0) && (CUR != quote)) {\n-        \/* TODO: Handle UTF-8 *\/\n-        if (!IS_CHAR_CH(CUR)) {\n-            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-                            \"Invalid char in SystemLiteral 0x%X\\n\", CUR);\n-            err = 1;\n-        }\n-        NEXT;\n-        len++;\n-    }\n-    if (CUR != quote) {\n-        htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,\n-                     \"Unfinished SystemLiteral\\n\", NULL, NULL);\n-    } else {\n-        if (err == 0) {\n-            ret = xmlStrndup((BASE_PTR+startPosition), len);\n-            if (ret == NULL) {\n-                htmlErrMemory(ctxt);\n-                return(NULL);\n+                buf += i;\n+                size -= i;\n@@ -2914,0 +2964,8 @@\n+\n+            if (size <= 0)\n+                return;\n+\n+            htmlStartCharData(ctxt);\n+\n+            if (PARSER_STOPPED(ctxt))\n+                return;\n@@ -2915,2 +2973,0 @@\n-        NEXT;\n-    }\n@@ -2918,1 +2974,15 @@\n-    return(ret);\n+        if ((mode == 0) &&\n+            (!ctxt->keepBlanks) &&\n+            (areBlanks(ctxt, buf, size) > 0)) {\n+            if (ctxt->sax->ignorableWhitespace != NULL)\n+                ctxt->sax->ignorableWhitespace(ctxt->userData, buf, size);\n+        } else {\n+            if (ctxt->sax->characters != NULL)\n+                ctxt->sax->characters(ctxt->userData, buf, size);\n+        }\n+    } else {\n+        \/*\n+         * Insert as CDATA, which is the same as HTML_PRESERVE_NODE\n+         *\/\n+        ctxt->sax->cdataBlock(ctxt->userData, buf, size);\n+    }\n@@ -2922,1 +2992,1 @@\n- * htmlParsePubidLiteral:\n+ * htmlParseCharData:\n@@ -2924,0 +2994,1 @@\n+ * @partial: true if the input buffer is incomplete\n@@ -2925,3 +2996,1 @@\n- * parse an HTML public literal\n- *\n- * [12] PubidLiteral ::= '\"' PubidChar* '\"' | \"'\" (PubidChar - \"'\")* \"'\"\n+ * Parse character data and references.\n@@ -2929,1 +2998,1 @@\n- * Returns the PubidLiteral parsed or NULL.\n+ * Returns 1 if all data was parsed, 0 otherwise.\n@@ -2932,6 +3001,9 @@\n-static xmlChar *\n-htmlParsePubidLiteral(htmlParserCtxtPtr ctxt) {\n-    size_t len = 0, startPosition = 0;\n-    int err = 0;\n-    int quote;\n-    xmlChar *ret = NULL;\n+static int\n+htmlParseCharData(htmlParserCtxtPtr ctxt, int partial) {\n+    xmlParserInputPtr input = ctxt->input;\n+    xmlChar utf8Char[4];\n+    int complete = 0;\n+    int done = 0;\n+    int mode;\n+    int eof = PARSER_PROGRESSIVE(ctxt);\n+    int line, col;\n@@ -2939,7 +3011,1 @@\n-    if ((CUR != '\"') && (CUR != '\\'')) {\n-    htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_STARTED,\n-                 \"PubidLiteral \\\" or ' expected\\n\", NULL, NULL);\n-        return(NULL);\n-    }\n-    quote = CUR;\n-    NEXT;\n+    mode = ctxt->endCheckState;\n@@ -2947,6 +3013,2 @@\n-    \/*\n-     * Name ::= (Letter | '_') (NameChar)*\n-     *\/\n-    if (CUR_PTR < BASE_PTR)\n-        return(ret);\n-    startPosition = CUR_PTR - BASE_PTR;\n+    line = input->line;\n+    col = input->col;\n@@ -2954,10 +3016,8 @@\n-    while ((PARSER_STOPPED(ctxt) == 0) &&\n-           (CUR != 0) && (CUR != quote)) {\n-        if (!IS_PUBIDCHAR_CH(CUR)) {\n-            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-                            \"Invalid char in PubidLiteral 0x%X\\n\", CUR);\n-            err = 1;\n-        }\n-        len++;\n-        NEXT;\n-    }\n+    while (!PARSER_STOPPED(ctxt)) {\n+        const xmlChar *chunk, *in, *repl;\n+        size_t avail;\n+        int replSize;\n+        int skip = 0;\n+        int ncr = 0;\n+        int ncrSize = 0;\n+        int cp = 0;\n@@ -2965,13 +3025,3 @@\n-    if (CUR != quote) {\n-        htmlParseErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED,\n-                     \"Unfinished PubidLiteral\\n\", NULL, NULL);\n-    } else {\n-        if (err == 0) {\n-            ret = xmlStrndup((BASE_PTR + startPosition), len);\n-            if (ret == NULL) {\n-                htmlErrMemory(ctxt);\n-                return(NULL);\n-            }\n-        }\n-        NEXT;\n-    }\n+        chunk = input->cur;\n+        avail = input->end - chunk;\n+        in = chunk;\n@@ -2979,2 +3029,2 @@\n-    return(ret);\n-}\n+        repl = BAD_CAST \"\";\n+        replSize = 0;\n@@ -2982,26 +3032,3 @@\n-\/**\n- * htmlParseScript:\n- * @ctxt:  an HTML parser context\n- *\n- * parse the content of an HTML SCRIPT or STYLE element\n- * http:\/\/www.w3.org\/TR\/html4\/sgml\/dtd.html#Script\n- * http:\/\/www.w3.org\/TR\/html4\/sgml\/dtd.html#StyleSheet\n- * http:\/\/www.w3.org\/TR\/html4\/types.html#type-script\n- * http:\/\/www.w3.org\/TR\/html4\/types.html#h-6.15\n- * http:\/\/www.w3.org\/TR\/html4\/appendix\/notes.html#h-B.3.2.1\n- *\n- * Script data ( %Script; in the DTD) can be the content of the SCRIPT\n- * element and the value of intrinsic event attributes. User agents must\n- * not evaluate script data as HTML markup but instead must pass it on as\n- * data to a script engine.\n- * NOTES:\n- * - The content is passed like CDATA\n- * - the attributes for style and scripting \"onXXX\" are also described\n- *   as CDATA but SGML allows entities references in attributes so their\n- *   processing is identical as other attributes\n- *\/\n-static void\n-htmlParseScript(htmlParserCtxtPtr ctxt) {\n-    xmlChar buf[HTML_PARSER_BIG_BUFFER_SIZE + 5];\n-    int nbchar = 0;\n-    int cur,l;\n+        while (!PARSER_STOPPED(ctxt)) {\n+            size_t j;\n+            int cur, size;\n@@ -3009,29 +3036,26 @@\n-    cur = CUR_CHAR(l);\n-    while (cur != 0) {\n-    if ((cur == '<') && (NXT(1) == '\/')) {\n-            \/*\n-             * One should break here, the specification is clear:\n-             * Authors should therefore escape \"<\/\" within the content.\n-             * Escape mechanisms are specific to each scripting or\n-             * style sheet language.\n-             *\n-             * In recovery mode, only break if end tag match the\n-             * current tag, effectively ignoring all tags inside the\n-             * script\/style block and treating the entire block as\n-             * CDATA.\n-             *\/\n-            if (ctxt->recovery) {\n-                if (xmlStrncasecmp(ctxt->name, ctxt->input->cur+2,\n-                   xmlStrlen(ctxt->name)) == 0)\n-                {\n-                    break; \/* while *\/\n-                } else {\n-            htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,\n-                 \"Element %s embeds close tag\\n\",\n-                         ctxt->name, NULL);\n-        }\n-            } else {\n-                if (((NXT(2) >= 'A') && (NXT(2) <= 'Z')) ||\n-                    ((NXT(2) >= 'a') && (NXT(2) <= 'z')))\n-                {\n-                    break; \/* while *\/\n+            if (avail <= 64) {\n+                if (!eof) {\n+                    size_t oldAvail = avail;\n+                    size_t off = in - chunk;\n+\n+                    input->cur = in;\n+\n+                    xmlParserGrow(ctxt);\n+\n+                    in = input->cur;\n+                    chunk = in - off;\n+                    input->cur = chunk;\n+                    avail = input->end - in;\n+\n+                    if (oldAvail == avail)\n+                        eof = 1;\n+                }\n+\n+                if (avail == 0) {\n+                    if ((partial) && (ncr)) {\n+                        in -= ncrSize;\n+                        ncrSize = 0;\n+                    }\n+\n+                    done = 1;\n+                    break;\n@@ -3040,23 +3064,0 @@\n-    }\n-        if (IS_CHAR(cur)) {\n-        COPY_BUF(l,buf,nbchar,cur);\n-        } else {\n-            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-                            \"Invalid char in CDATA 0x%X\\n\", cur);\n-        }\n-    NEXTL(l);\n-    if (nbchar >= HTML_PARSER_BIG_BUFFER_SIZE) {\n-            buf[nbchar] = 0;\n-        if (ctxt->sax->cdataBlock!= NULL) {\n-        \/*\n-         * Insert as CDATA, which is the same as HTML_PRESERVE_NODE\n-         *\/\n-        ctxt->sax->cdataBlock(ctxt->userData, buf, nbchar);\n-        } else if (ctxt->sax->characters != NULL) {\n-        ctxt->sax->characters(ctxt->userData, buf, nbchar);\n-        }\n-        nbchar = 0;\n-            SHRINK;\n-    }\n-    cur = CUR_CHAR(l);\n-    }\n@@ -3064,12 +3065,16 @@\n-    if ((nbchar != 0) && (ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n-        buf[nbchar] = 0;\n-    if (ctxt->sax->cdataBlock!= NULL) {\n-        \/*\n-         * Insert as CDATA, which is the same as HTML_PRESERVE_NODE\n-         *\/\n-        ctxt->sax->cdataBlock(ctxt->userData, buf, nbchar);\n-    } else if (ctxt->sax->characters != NULL) {\n-        ctxt->sax->characters(ctxt->userData, buf, nbchar);\n-    }\n-    }\n-}\n+            \/* Accelerator *\/\n+            if (!ncr) {\n+                while (avail > 0) {\n+                    static const unsigned mask[8] = {\n+                        0x00002401, 0x10002040,\n+                        0x00000000, 0x00000000,\n+                        0xFFFFFFFF, 0xFFFFFFFF,\n+                        0xFFFFFFFF, 0xFFFFFFFF\n+                    };\n+                    cur = *in;\n+                    if ((1u << (cur & 0x1F)) & mask[cur >> 5])\n+                        break;\n+                    col += 1;\n+                    in += 1;\n+                    avail -= 1;\n+                }\n@@ -3077,0 +3082,5 @@\n+                if ((!eof) && (avail <= 64))\n+                    continue;\n+                if (avail == 0)\n+                    continue;\n+            }\n@@ -3078,10 +3088,3 @@\n-\/**\n- * htmlParseCharDataInternal:\n- * @ctxt:  an HTML parser context\n- * @readahead: optional read ahead character in ascii range\n- *\n- * parse a CharData section.\n- * if we are within a CDATA section ']]>' marks an end of section.\n- *\n- * [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)\n- *\/\n+            cur = *in;\n+            size = 1;\n+            col += 1;\n@@ -3089,23 +3092,3 @@\n-static void\n-htmlParseCharDataInternal(htmlParserCtxtPtr ctxt, int readahead) {\n-    xmlChar buf[HTML_PARSER_BIG_BUFFER_SIZE + 6];\n-    int nbchar = 0;\n-    int cur, l;\n-\n-    if (readahead)\n-        buf[nbchar++] = readahead;\n-\n-    cur = CUR_CHAR(l);\n-    while ((cur != '<') &&\n-           (cur != '&') &&\n-       (cur != 0) &&\n-           (!PARSER_STOPPED(ctxt))) {\n-    if (!(IS_CHAR(cur))) {\n-        htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-                    \"Invalid char in CDATA 0x%X\\n\", cur);\n-    } else {\n-        COPY_BUF(l,buf,nbchar,cur);\n-    }\n-    NEXTL(l);\n-    if (nbchar >= HTML_PARSER_BIG_BUFFER_SIZE) {\n-            buf[nbchar] = 0;\n+            if (ncr) {\n+                int lc = cur | 0x20;\n+                int digit;\n@@ -3113,12 +3096,20 @@\n-        \/*\n-         * Ok the segment is to be consumed as chars.\n-         *\/\n-        if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n-        if (areBlanks(ctxt, buf, nbchar)) {\n-            if (ctxt->keepBlanks) {\n-            if (ctxt->sax->characters != NULL)\n-                ctxt->sax->characters(ctxt->userData, buf, nbchar);\n-            } else {\n-            if (ctxt->sax->ignorableWhitespace != NULL)\n-                ctxt->sax->ignorableWhitespace(ctxt->userData,\n-                                               buf, nbchar);\n+                if ((cur >= '0') && (cur <= '9')) {\n+                    digit = cur - '0';\n+                } else if ((ncr == 16) && (lc >= 'a') && (lc <= 'f')) {\n+                    digit = (lc - 'a') + 10;\n+                } else {\n+                    if (cur == ';') {\n+                        in += 1;\n+                        size += 1;\n+                        ncrSize += 1;\n+                    }\n+                    goto next_chunk;\n+                }\n+\n+                cp = cp * ncr + digit;\n+                if (cp >= 0x110000)\n+                    cp = 0x110000;\n+\n+                ncrSize += 1;\n+\n+                goto next_char;\n@@ -3126,13 +3117,0 @@\n-        } else {\n-            htmlCheckParagraph(ctxt);\n-            if (ctxt->sax->characters != NULL)\n-            ctxt->sax->characters(ctxt->userData, buf, nbchar);\n-        }\n-        }\n-        nbchar = 0;\n-            SHRINK;\n-    }\n-    cur = CUR_CHAR(l);\n-    }\n-    if (nbchar != 0) {\n-        buf[nbchar] = 0;\n@@ -3140,21 +3118,9 @@\n-    \/*\n-     * Ok the segment is to be consumed as chars.\n-     *\/\n-    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n-        if (areBlanks(ctxt, buf, nbchar)) {\n-        if (ctxt->keepBlanks) {\n-            if (ctxt->sax->characters != NULL)\n-            ctxt->sax->characters(ctxt->userData, buf, nbchar);\n-        } else {\n-            if (ctxt->sax->ignorableWhitespace != NULL)\n-            ctxt->sax->ignorableWhitespace(ctxt->userData,\n-                                           buf, nbchar);\n-        }\n-        } else {\n-        htmlCheckParagraph(ctxt);\n-        if (ctxt->sax->characters != NULL)\n-            ctxt->sax->characters(ctxt->userData, buf, nbchar);\n-        }\n-    }\n-    }\n-}\n+            switch (cur) {\n+            case '<':\n+                if (mode == 0) {\n+                    done = 1;\n+                    complete = 1;\n+                    goto next_chunk;\n+                }\n+                if (mode == DATA_PLAINTEXT)\n+                    break;\n@@ -3162,9 +3128,4 @@\n-\/**\n- * htmlParseCharData:\n- * @ctxt:  an HTML parser context\n- *\n- * parse a CharData section.\n- * if we are within a CDATA section ']]>' marks an end of section.\n- *\n- * [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)\n- *\/\n+                j = 1;\n+                if (j < avail) {\n+                    if ((mode == DATA_SCRIPT) && (in[j] == '!')) {\n+                        \/* Check for comment start *\/\n@@ -3172,4 +3133,9 @@\n-static void\n-htmlParseCharData(htmlParserCtxtPtr ctxt) {\n-    htmlParseCharDataInternal(ctxt, 0);\n-}\n+                        j += 1;\n+                        if ((j < avail) && (in[j] == '-')) {\n+                            j += 1;\n+                            if ((j < avail) && (in[j] == '-'))\n+                                mode = DATA_SCRIPT_ESC1;\n+                        }\n+                    } else {\n+                        int i = 0;\n+                        int solidus = 0;\n@@ -3177,16 +3143,1 @@\n-\/**\n- * htmlParseExternalID:\n- * @ctxt:  an HTML parser context\n- * @publicID:  a xmlChar** receiving PubidLiteral\n- *\n- * Parse an External ID or a Public ID\n- *\n- * [75] ExternalID ::= 'SYSTEM' S SystemLiteral\n- *                   | 'PUBLIC' S PubidLiteral S SystemLiteral\n- *\n- * [83] PublicID ::= 'PUBLIC' S PubidLiteral\n- *\n- * Returns the function returns SystemLiteral and in the second\n- *                case publicID receives PubidLiteral, is strict is off\n- *                it is possible to return NULL and have publicID set.\n- *\/\n+                        \/* Check for tag *\/\n@@ -3194,3 +3145,4 @@\n-static xmlChar *\n-htmlParseExternalID(htmlParserCtxtPtr ctxt, xmlChar **publicID) {\n-    xmlChar *URI = NULL;\n+                        if (in[j] == '\/') {\n+                            j += 1;\n+                            solidus = 1;\n+                        }\n@@ -3198,36 +3150,28 @@\n-    if ((UPPER == 'S') && (UPP(1) == 'Y') &&\n-         (UPP(2) == 'S') && (UPP(3) == 'T') &&\n-     (UPP(4) == 'E') && (UPP(5) == 'M')) {\n-        SKIP(6);\n-    if (!IS_BLANK_CH(CUR)) {\n-        htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,\n-                     \"Space required after 'SYSTEM'\\n\", NULL, NULL);\n-    }\n-        SKIP_BLANKS;\n-    URI = htmlParseSystemLiteral(ctxt);\n-    if (URI == NULL) {\n-        htmlParseErr(ctxt, XML_ERR_URI_REQUIRED,\n-                     \"htmlParseExternalID: SYSTEM, no URI\\n\", NULL, NULL);\n-        }\n-    } else if ((UPPER == 'P') && (UPP(1) == 'U') &&\n-           (UPP(2) == 'B') && (UPP(3) == 'L') &&\n-           (UPP(4) == 'I') && (UPP(5) == 'C')) {\n-        SKIP(6);\n-    if (!IS_BLANK_CH(CUR)) {\n-        htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,\n-                     \"Space required after 'PUBLIC'\\n\", NULL, NULL);\n-    }\n-        SKIP_BLANKS;\n-    *publicID = htmlParsePubidLiteral(ctxt);\n-    if (*publicID == NULL) {\n-        htmlParseErr(ctxt, XML_ERR_PUBID_REQUIRED,\n-                     \"htmlParseExternalID: PUBLIC, no Public Identifier\\n\",\n-             NULL, NULL);\n-    }\n-        SKIP_BLANKS;\n-        if ((CUR == '\"') || (CUR == '\\'')) {\n-        URI = htmlParseSystemLiteral(ctxt);\n-    }\n-    }\n-    return(URI);\n-}\n+                        if ((solidus) || (mode == DATA_SCRIPT_ESC1)) {\n+                            while ((j < avail) &&\n+                                   (ctxt->name[i] != 0) &&\n+                                   (ctxt->name[i] == (in[j] | 0x20))) {\n+                                i += 1;\n+                                j += 1;\n+                            }\n+\n+                            if ((ctxt->name[i] == 0) && (j < avail)) {\n+                                int c = in[j];\n+\n+                                if ((c == '>') || (c == '\/') ||\n+                                    (IS_WS_HTML(c))) {\n+                                    if ((mode == DATA_SCRIPT_ESC1) &&\n+                                        (!solidus)) {\n+                                        mode = DATA_SCRIPT_ESC2;\n+                                    } else if (mode == DATA_SCRIPT_ESC2) {\n+                                        mode = DATA_SCRIPT_ESC1;\n+                                    } else {\n+                                        complete = 1;\n+                                        done = 1;\n+                                        goto next_chunk;\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n@@ -3235,18 +3179,4 @@\n-\/**\n- * htmlParsePI:\n- * @ctxt:  an HTML parser context\n- *\n- * Parse an XML Processing Instruction. HTML5 doesn't allow processing\n- * instructions, so this will be removed at some point.\n- *\/\n-static void\n-htmlParsePI(htmlParserCtxtPtr ctxt) {\n-    xmlChar *buf = NULL;\n-    int len = 0;\n-    int size = HTML_PARSER_BUFFER_SIZE;\n-    int cur, l;\n-    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n-                    XML_MAX_HUGE_LENGTH :\n-                    XML_MAX_TEXT_LENGTH;\n-    const xmlChar *target;\n-    xmlParserInputState state;\n+                if ((partial) && (j >= avail)) {\n+                    done = 1;\n+                    goto next_chunk;\n+                }\n@@ -3254,7 +3184,1 @@\n-    if ((RAW == '<') && (NXT(1) == '?')) {\n-    state = ctxt->instate;\n-        ctxt->instate = XML_PARSER_PI;\n-    \/*\n-     * this is a Processing Instruction.\n-     *\/\n-    SKIP(2);\n+                break;\n@@ -3262,8 +3186,3 @@\n-    \/*\n-     * Parse the target name and check for special support like\n-     * namespace.\n-     *\/\n-        target = htmlParseName(ctxt);\n-    if (target != NULL) {\n-        if (RAW == '>') {\n-        SKIP(1);\n+            case '-':\n+                if ((mode != DATA_SCRIPT_ESC1) && (mode != DATA_SCRIPT_ESC2))\n+                    break;\n@@ -3271,24 +3190,1 @@\n-        \/*\n-         * SAX: PI detected.\n-         *\/\n-        if ((ctxt->sax) && (!ctxt->disableSAX) &&\n-            (ctxt->sax->processingInstruction != NULL))\n-            ctxt->sax->processingInstruction(ctxt->userData,\n-                                             target, NULL);\n-                goto done;\n-        }\n-        buf = (xmlChar *) xmlMallocAtomic(size);\n-        if (buf == NULL) {\n-        htmlErrMemory(ctxt);\n-        return;\n-        }\n-        cur = CUR;\n-        if (!IS_BLANK(cur)) {\n-        htmlParseErr(ctxt, XML_ERR_SPACE_REQUIRED,\n-              \"ParsePI: PI %s space expected\\n\", target, NULL);\n-        }\n-            SKIP_BLANKS;\n-        cur = CUR_CHAR(l);\n-        while ((cur != 0) && (cur != '>')) {\n-        if (len + 5 >= size) {\n-            xmlChar *tmp;\n+                \/* Check for comment end *\/\n@@ -3296,11 +3192,38 @@\n-            size *= 2;\n-            tmp = (xmlChar *) xmlRealloc(buf, size);\n-            if (tmp == NULL) {\n-            htmlErrMemory(ctxt);\n-            xmlFree(buf);\n-            return;\n-            }\n-            buf = tmp;\n-        }\n-                if (IS_CHAR(cur)) {\n-            COPY_BUF(l,buf,len,cur);\n+                j = 1;\n+                if ((j < avail) && (in[j] == '-')) {\n+                    j += 1;\n+                    if ((j < avail) && (in[j] == '>'))\n+                        mode = DATA_SCRIPT;\n+                }\n+\n+                if ((partial) && (j >= avail)) {\n+                    done = 1;\n+                    goto next_chunk;\n+                }\n+\n+                break;\n+\n+            case '&':\n+                if ((mode != 0) && (mode != DATA_RCDATA))\n+                    break;\n+\n+                j = 1;\n+\n+                if ((j < avail) && (in[j] == '#')) {\n+                    j += 1;\n+                    if (j < avail) {\n+                        if ((in[j] | 0x20) == 'x') {\n+                            j += 1;\n+                            if ((j < avail) && (IS_HEX_DIGIT(in[j]))) {\n+                                ncr = 16;\n+                                size = 3;\n+                                ncrSize = 3;\n+                                cp = 0;\n+                            }\n+                        } else if (IS_ASCII_DIGIT(in[j])) {\n+                            ncr = 10;\n+                            size = 2;\n+                            ncrSize = 2;\n+                            cp = 0;\n+                        }\n+                    }\n@@ -3308,3 +3231,62 @@\n-                    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-                                    \"Invalid char in processing instruction \"\n-                                    \"0x%X\\n\", cur);\n+                    if (partial) {\n+                        int terminated = 0;\n+                        size_t i;\n+\n+                        \/*\n+                         * &CounterClockwiseContourIntegral; has 33 bytes.\n+                         *\/\n+                        for (i = 1; i < avail; i++) {\n+                            if ((i >= 32) ||\n+                                (!IS_ASCII_LETTER(in[i]) &&\n+                                 ((i < 2) || !IS_ASCII_DIGIT(in[i])))) {\n+                                terminated = 1;\n+                                break;\n+                            }\n+                        }\n+\n+                        if (!terminated) {\n+                            done = 1;\n+                            goto next_chunk;\n+                        }\n+                    }\n+\n+                    repl = htmlFindEntityPrefix(in + j,\n+                                                avail - j,\n+                                                \/* isAttr *\/ 0,\n+                                                &skip, &replSize);\n+                    if (repl != NULL) {\n+                        skip += 1;\n+                        goto next_chunk;\n+                    }\n+\n+                    skip = 0;\n+                }\n+\n+                if ((partial) && (j >= avail)) {\n+                    done = 1;\n+                    goto next_chunk;\n+                }\n+\n+                break;\n+\n+            case '\\0':\n+                skip = 1;\n+                repl = BAD_CAST \"\\xEF\\xBF\\xBD\";\n+                replSize = 3;\n+                goto next_chunk;\n+\n+            case '\\n':\n+                line += 1;\n+                col = 1;\n+                break;\n+\n+            case '\\r':\n+                if (partial && avail < 2) {\n+                    done = 1;\n+                    goto next_chunk;\n+                }\n+\n+                skip = 1;\n+                if (in[1] != 0x0A) {\n+                    repl = BAD_CAST \"\\x0A\";\n+                    replSize = 1;\n@@ -3312,5 +3294,34 @@\n-                if (len > maxLength) {\n-                    htmlParseErr(ctxt, XML_ERR_PI_NOT_FINISHED,\n-                                 \"PI %s too long\", target, NULL);\n-                    xmlFree(buf);\n-                    goto done;\n+                goto next_chunk;\n+\n+            default:\n+                if (cur < 0x80)\n+                    break;\n+\n+                if ((input->flags & XML_INPUT_HAS_ENCODING) == 0) {\n+                    xmlChar * guess;\n+\n+                    if (in > chunk)\n+                        goto next_chunk;\n+\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+                    guess = NULL;\n+#else\n+                    guess = htmlFindEncoding(ctxt);\n+#endif\n+                    if (guess == NULL) {\n+                        xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_8859_1);\n+                    } else {\n+                        xmlSwitchEncodingName(ctxt, (const char *) guess);\n+                        xmlFree(guess);\n+                    }\n+                    input->flags |= XML_INPUT_HAS_ENCODING;\n+\n+                    eof = PARSER_PROGRESSIVE(ctxt);\n+                    goto restart;\n+                }\n+\n+                size = htmlValidateUtf8(ctxt, in, avail, partial);\n+\n+                if ((partial) && (size == 0)) {\n+                    done = 1;\n+                    goto next_chunk;\n@@ -3318,2 +3329,14 @@\n-        NEXTL(l);\n-        cur = CUR_CHAR(l);\n+\n+                if (size <= 0) {\n+                    skip = 1;\n+                    repl = BAD_CAST \"\\xEF\\xBF\\xBD\";\n+                    replSize = 3;\n+                    goto next_chunk;\n+                }\n+\n+                break;\n+            }\n+\n+next_char:\n+            in += size;\n+            avail -= size;\n@@ -3321,6 +3344,0 @@\n-        buf[len] = 0;\n-        if (cur != '>') {\n-        htmlParseErr(ctxt, XML_ERR_PI_NOT_FINISHED,\n-              \"ParsePI: PI %s never end ...\\n\", target, NULL);\n-        } else {\n-        SKIP(1);\n@@ -3328,7 +3345,6 @@\n-        \/*\n-         * SAX: PI detected.\n-         *\/\n-        if ((ctxt->sax) && (!ctxt->disableSAX) &&\n-            (ctxt->sax->processingInstruction != NULL))\n-            ctxt->sax->processingInstruction(ctxt->userData,\n-                                             target, buf);\n+next_chunk:\n+        if (ncrSize > 0) {\n+            skip = ncrSize;\n+            in -= ncrSize;\n+\n+            repl = htmlCodePointToUtf8(cp, utf8Char, &replSize);\n@@ -3336,5 +3352,0 @@\n-        xmlFree(buf);\n-    } else {\n-        htmlParseErr(ctxt, XML_ERR_PI_NOT_STARTED,\n-                         \"PI is not started correctly\", NULL, NULL);\n-    }\n@@ -3342,2 +3353,16 @@\n-done:\n-    ctxt->instate = state;\n+        if (in > chunk) {\n+            input->cur += in - chunk;\n+            htmlCharDataSAXCallback(ctxt, chunk, in - chunk, mode);\n+        }\n+\n+        input->cur += skip;\n+        if (replSize > 0)\n+            htmlCharDataSAXCallback(ctxt, repl, replSize, mode);\n+\n+        SHRINK;\n+\n+        if (done)\n+            break;\n+\n+restart:\n+        ;\n@@ -3345,0 +3370,10 @@\n+\n+    input->line = line;\n+    input->col = col;\n+\n+    if (complete)\n+        ctxt->endCheckState = 0;\n+    else\n+        ctxt->endCheckState = mode;\n+\n+    return(complete);\n@@ -3350,0 +3385,1 @@\n+ * @bogus:  true if this is a bogus comment\n@@ -3354,1 +3390,2 @@\n-htmlParseComment(htmlParserCtxtPtr ctxt) {\n+htmlParseComment(htmlParserCtxtPtr ctxt, int bogus) {\n+    const xmlChar *comment = BAD_CAST \"\";\n@@ -3356,7 +3393,1 @@\n-    int len;\n-    int size = HTML_PARSER_BUFFER_SIZE;\n-    int q, ql;\n-    int r, rl;\n-    int cur, l;\n-    int next, nl;\n-    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n+    int maxLength = (ctxt->options & HTML_PARSE_HUGE) ?\n@@ -3365,1 +3396,0 @@\n-    xmlParserInputState state;\n@@ -3367,46 +3397,14 @@\n-    \/*\n-     * Check that there is a comment right here.\n-     *\/\n-    if ((RAW != '<') || (NXT(1) != '!') ||\n-        (NXT(2) != '-') || (NXT(3) != '-')) return;\n-\n-    state = ctxt->instate;\n-    ctxt->instate = XML_PARSER_COMMENT;\n-    SKIP(4);\n-    buf = (xmlChar *) xmlMallocAtomic(size);\n-    if (buf == NULL) {\n-        htmlErrMemory(ctxt);\n-    return;\n-    }\n-    len = 0;\n-    buf[len] = 0;\n-    q = CUR_CHAR(ql);\n-    if (q == 0)\n-        goto unfinished;\n-    if (q == '>') {\n-        htmlParseErr(ctxt, XML_ERR_COMMENT_ABRUPTLY_ENDED, \"Comment abruptly ended\", NULL, NULL);\n-        cur = '>';\n-        goto finished;\n-    }\n-    NEXTL(ql);\n-    r = CUR_CHAR(rl);\n-    if (r == 0)\n-        goto unfinished;\n-    if (q == '-' && r == '>') {\n-        htmlParseErr(ctxt, XML_ERR_COMMENT_ABRUPTLY_ENDED, \"Comment abruptly ended\", NULL, NULL);\n-        cur = '>';\n-        goto finished;\n-    }\n-    NEXTL(rl);\n-    cur = CUR_CHAR(l);\n-    while ((cur != 0) &&\n-           ((cur != '>') ||\n-        (r != '-') || (q != '-'))) {\n-    NEXTL(l);\n-    next = CUR_CHAR(nl);\n-\n-    if ((q == '-') && (r == '-') && (cur == '!') && (next == '>')) {\n-      htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n-               \"Comment incorrectly closed by '--!>'\", NULL, NULL);\n-      cur = '>';\n-      break;\n+    if (bogus) {\n+        buf = htmlParseData(ctxt, MASK_GT, 0, 0, maxLength);\n+        if (CUR == '>')\n+            SKIP(1);\n+        comment = buf;\n+    } else {\n+        if (CUR == '>') {\n+            SKIP(1);\n+        } else if ((CUR == '-') && (NXT(1) == '>')) {\n+            SKIP(2);\n+        } else {\n+            buf = htmlParseData(ctxt, MASK_DASH, 1, 0, maxLength);\n+            comment = buf;\n+        }\n@@ -3415,8 +3413,1 @@\n-    if (len + 5 >= size) {\n-        xmlChar *tmp;\n-\n-        size *= 2;\n-        tmp = (xmlChar *) xmlRealloc(buf, size);\n-        if (tmp == NULL) {\n-            xmlFree(buf);\n-            htmlErrMemory(ctxt);\n+    if (comment == NULL)\n@@ -3424,16 +3415,0 @@\n-        }\n-        buf = tmp;\n-    }\n-        if (IS_CHAR(q)) {\n-        COPY_BUF(ql,buf,len,q);\n-        } else {\n-            htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-                            \"Invalid char in comment 0x%X\\n\", q);\n-        }\n-        if (len > maxLength) {\n-            htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n-                         \"comment too long\", NULL, NULL);\n-            xmlFree(buf);\n-            ctxt->instate = state;\n-            return;\n-        }\n@@ -3441,11 +3416,0 @@\n-    q = r;\n-    ql = rl;\n-    r = cur;\n-    rl = l;\n-    cur = next;\n-    l = nl;\n-    }\n-finished:\n-    buf[len] = 0;\n-    if (cur == '>') {\n-        NEXT;\n@@ -3454,5 +3418,1 @@\n-        ctxt->sax->comment(ctxt->userData, buf);\n-    xmlFree(buf);\n-    ctxt->instate = state;\n-    return;\n-    }\n+        ctxt->sax->comment(ctxt->userData, comment);\n@@ -3460,3 +3420,0 @@\n-unfinished:\n-    htmlParseErr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n-         \"Comment not terminated \\n<!--%.50s\\n\", buf, NULL);\n@@ -3472,1 +3429,11 @@\n- * parse Reference declarations\n+ * Returns 0\n+ *\/\n+int\n+htmlParseCharRef(htmlParserCtxtPtr ctxt ATTRIBUTE_UNUSED) {\n+    return(0);\n+}\n+\n+\n+\/**\n+ * htmlParseDoctypeLiteral:\n+ * @ctxt:  an HTML parser context\n@@ -3474,2 +3441,1 @@\n- * [66] CharRef ::= '&#' [0-9]+ ';' |\n- *                  '&#x' [0-9a-fA-F]+ ';'\n+ * Parse a DOCTYPE SYTSTEM or PUBLIC literal.\n@@ -3477,1 +3443,1 @@\n- * Returns the value parsed (as an int)\n+ * Returns the literal or NULL in case of error.\n@@ -3479,3 +3445,0 @@\n-int\n-htmlParseCharRef(htmlParserCtxtPtr ctxt) {\n-    int val = 0;\n@@ -3483,53 +3446,17 @@\n-    if ((ctxt == NULL) || (ctxt->input == NULL))\n-        return(0);\n-    if ((CUR == '&') && (NXT(1) == '#') &&\n-        ((NXT(2) == 'x') || NXT(2) == 'X')) {\n-    SKIP(3);\n-    while (CUR != ';') {\n-        if ((CUR >= '0') && (CUR <= '9')) {\n-                if (val < 0x110000)\n-                val = val * 16 + (CUR - '0');\n-            } else if ((CUR >= 'a') && (CUR <= 'f')) {\n-                if (val < 0x110000)\n-                val = val * 16 + (CUR - 'a') + 10;\n-            } else if ((CUR >= 'A') && (CUR <= 'F')) {\n-                if (val < 0x110000)\n-                val = val * 16 + (CUR - 'A') + 10;\n-            } else {\n-            htmlParseErr(ctxt, XML_ERR_INVALID_HEX_CHARREF,\n-                     \"htmlParseCharRef: missing semicolon\\n\",\n-                 NULL, NULL);\n-        break;\n-        }\n-        NEXT;\n-    }\n-    if (CUR == ';')\n-        NEXT;\n-    } else if  ((CUR == '&') && (NXT(1) == '#')) {\n-    SKIP(2);\n-    while (CUR != ';') {\n-        if ((CUR >= '0') && (CUR <= '9')) {\n-                if (val < 0x110000)\n-                val = val * 10 + (CUR - '0');\n-            } else {\n-            htmlParseErr(ctxt, XML_ERR_INVALID_DEC_CHARREF,\n-                     \"htmlParseCharRef: missing semicolon\\n\",\n-                 NULL, NULL);\n-        break;\n-        }\n-        NEXT;\n-    }\n-    if (CUR == ';')\n-        NEXT;\n-    } else {\n-    htmlParseErr(ctxt, XML_ERR_INVALID_CHARREF,\n-                 \"htmlParseCharRef: invalid value\\n\", NULL, NULL);\n-    }\n-    \/*\n-     * Check the value IS_CHAR ...\n-     *\/\n-    if (IS_CHAR(val)) {\n-        return(val);\n-    } else if (val >= 0x110000) {\n-    htmlParseErr(ctxt, XML_ERR_INVALID_CHAR,\n-             \"htmlParseCharRef: value too large\\n\", NULL, NULL);\n+static xmlChar *\n+htmlParseDoctypeLiteral(htmlParserCtxtPtr ctxt) {\n+    xmlChar *ret;\n+    int maxLength = (ctxt->options & HTML_PARSE_HUGE) ?\n+                    XML_MAX_TEXT_LENGTH :\n+                    XML_MAX_NAME_LENGTH;\n+\n+    if (CUR == '\"') {\n+        SKIP(1);\n+        ret = htmlParseData(ctxt, MASK_DQ_GT, 0, 0, maxLength);\n+        if (CUR == '\"')\n+            SKIP(1);\n+    } else if (CUR == '\\'') {\n+        SKIP(1);\n+        ret = htmlParseData(ctxt, MASK_SQ_GT, 0, 0, maxLength);\n+        if (CUR == '\\'')\n+            SKIP(1);\n@@ -3537,3 +3464,1 @@\n-    htmlParseErrInt(ctxt, XML_ERR_INVALID_CHAR,\n-            \"htmlParseCharRef: invalid xmlChar value %d\\n\",\n-            val);\n+        return(NULL);\n@@ -3541,1 +3466,2 @@\n-    return(0);\n+\n+    return(ret);\n@@ -3544,0 +3470,54 @@\n+static void\n+htmlSkipBogusDoctype(htmlParserCtxtPtr ctxt) {\n+    const xmlChar *in;\n+    size_t avail;\n+    int eof = PARSER_PROGRESSIVE(ctxt);\n+    int line, col;\n+\n+    line = ctxt->input->line;\n+    col = ctxt->input->col;\n+\n+    in = ctxt->input->cur;\n+    avail = ctxt->input->end - in;\n+\n+    while (!PARSER_STOPPED(ctxt)) {\n+        int cur;\n+\n+        if ((!eof) && (avail <= 64)) {\n+            size_t oldAvail = avail;\n+\n+            ctxt->input->cur = in;\n+\n+            xmlParserGrow(ctxt);\n+\n+            in = ctxt->input->cur;\n+            avail = ctxt->input->end - in;\n+\n+            if (oldAvail == avail)\n+                eof = 1;\n+        }\n+\n+        if (avail == 0)\n+            break;\n+\n+        col += 1;\n+\n+        cur = *in;\n+        if (cur == '>') {\n+            in += 1;\n+            break;\n+        } else if (cur == 0x0A) {\n+            line += 1;\n+            col = 1;\n+        }\n+\n+        in += 1;\n+        avail -= 1;\n+\n+        SHRINK;\n+    }\n+\n+    ctxt->input->cur = in;\n+    ctxt->input->line = line;\n+    ctxt->input->col = col;\n+}\n@@ -3549,4 +3529,1 @@\n- * parse a DOCTYPE declaration\n- *\n- * [28] doctypedecl ::= '<!DOCTYPE' S Name (S ExternalID)? S?\n- *                      ('[' (markupdecl | PEReference | S)* ']' S?)? '>'\n+ * Parse a DOCTYPE declaration.\n@@ -3557,2 +3534,2 @@\n-    const xmlChar *name;\n-    xmlChar *ExternalID = NULL;\n+    xmlChar *name = NULL;\n+    xmlChar *publicId = NULL;\n@@ -3560,0 +3537,3 @@\n+    int maxLength = (ctxt->options & HTML_PARSE_HUGE) ?\n+                    XML_MAX_TEXT_LENGTH :\n+                    XML_MAX_NAME_LENGTH;\n@@ -3568,12 +3548,2 @@\n-    \/*\n-     * Parse the DOCTYPE name.\n-     *\/\n-    name = htmlParseName(ctxt);\n-    if (name == NULL) {\n-    htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n-                 \"htmlParseDocTypeDecl : no DOCTYPE name !\\n\",\n-             NULL, NULL);\n-    }\n-    \/*\n-     * Check that upper(name) == \"HTML\" !!!!!!!!!!!!!\n-     *\/\n+    if ((ctxt->input->cur < ctxt->input->end) && (CUR != '>')) {\n+        name = htmlParseData(ctxt, MASK_WS_GT, 0, 0, maxLength);\n@@ -3581,1 +3551,2 @@\n-    SKIP_BLANKS;\n+        if ((ctxt->options & HTML_PARSE_HTML5) && (name != NULL)) {\n+            xmlChar *cur;\n@@ -3583,5 +3554,8 @@\n-    \/*\n-     * Check for SystemID and ExternalID\n-     *\/\n-    URI = htmlParseExternalID(ctxt, &ExternalID);\n-    SKIP_BLANKS;\n+            for (cur = name; *cur; cur++) {\n+                if (IS_UPPER(*cur))\n+                    *cur += 0x20;\n+            }\n+        }\n+\n+        SKIP_BLANKS;\n+    }\n@@ -3590,1 +3564,1 @@\n-     * We should be at the end of the DOCTYPE declaration.\n+     * Check for SystemID and publicId\n@@ -3592,7 +3566,16 @@\n-    if (CUR != '>') {\n-    htmlParseErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED,\n-                 \"DOCTYPE improperly terminated\\n\", NULL, NULL);\n-        \/* Ignore bogus content *\/\n-        while ((CUR != 0) && (CUR != '>') &&\n-               (PARSER_STOPPED(ctxt) == 0))\n-            NEXT;\n+    if ((UPPER == 'P') && (UPP(1) == 'U') &&\n+        (UPP(2) == 'B') && (UPP(3) == 'L') &&\n+        (UPP(4) == 'I') && (UPP(5) == 'C')) {\n+        SKIP(6);\n+        SKIP_BLANKS;\n+        publicId = htmlParseDoctypeLiteral(ctxt);\n+        if (publicId == NULL)\n+            goto bogus;\n+        SKIP_BLANKS;\n+        URI = htmlParseDoctypeLiteral(ctxt);\n+    } else if ((UPPER == 'S') && (UPP(1) == 'Y') &&\n+               (UPP(2) == 'S') && (UPP(3) == 'T') &&\n+               (UPP(4) == 'E') && (UPP(5) == 'M')) {\n+        SKIP(6);\n+        SKIP_BLANKS;\n+        URI = htmlParseDoctypeLiteral(ctxt);\n@@ -3600,2 +3583,3 @@\n-    if (CUR == '>')\n-        NEXT;\n+\n+bogus:\n+    htmlSkipBogusDoctype(ctxt);\n@@ -3607,2 +3591,2 @@\n-    (!ctxt->disableSAX))\n-    ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);\n+        (!ctxt->disableSAX))\n+        ctxt->sax->internalSubset(ctxt->userData, name, publicId, URI);\n@@ -3610,5 +3594,3 @@\n-    \/*\n-     * Cleanup, since we don't use all those identifiers\n-     *\/\n-    if (URI != NULL) xmlFree(URI);\n-    if (ExternalID != NULL) xmlFree(ExternalID);\n+    xmlFree(name);\n+    xmlFree(URI);\n+    xmlFree(publicId);\n@@ -3638,1 +3620,1 @@\n-static const xmlChar *\n+static xmlHashedString\n@@ -3640,1 +3622,1 @@\n-    const xmlChar *name;\n+    xmlHashedString hname;\n@@ -3644,6 +3626,3 @@\n-    name = htmlParseHTMLName(ctxt);\n-    if (name == NULL) {\n-    htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n-                 \"error parsing attribute name\\n\", NULL, NULL);\n-        return(NULL);\n-    }\n+    hname = htmlParseHTMLName(ctxt, 1);\n+    if (hname.name == NULL)\n+        return(hname);\n@@ -3656,3 +3635,3 @@\n-        NEXT;\n-    SKIP_BLANKS;\n-    val = htmlParseAttValue(ctxt);\n+        SKIP(1);\n+        SKIP_BLANKS;\n+        val = htmlParseAttValue(ctxt);\n@@ -3662,1 +3641,1 @@\n-    return(name);\n+    return(hname);\n@@ -3681,1 +3660,1 @@\n-    return;\n+        return;\n@@ -3685,1 +3664,1 @@\n-    encoding += 7;\n+        encoding += 7;\n@@ -3689,363 +3668,9 @@\n-     *\/\n-    if (encoding && IS_BLANK_CH(*encoding))\n-    encoding = xmlStrcasestr(attvalue, BAD_CAST\"=\");\n-    if (encoding && *encoding == '=') {\n-    encoding ++;\n-        copy = xmlStrdup(encoding);\n-        if (copy == NULL)\n-            htmlErrMemory(ctxt);\n-    xmlSetDeclaredEncoding(ctxt, copy);\n-    }\n-}\n-\n-\/**\n- * htmlCheckMeta:\n- * @ctxt:  an HTML parser context\n- * @atts:  the attributes values\n- *\n- * Checks an attributes from a Meta tag\n- *\/\n-static void\n-htmlCheckMeta(htmlParserCtxtPtr ctxt, const xmlChar **atts) {\n-    int i;\n-    const xmlChar *att, *value;\n-    int http = 0;\n-    const xmlChar *content = NULL;\n-\n-    if ((ctxt == NULL) || (atts == NULL))\n-    return;\n-\n-    i = 0;\n-    att = atts[i++];\n-    while (att != NULL) {\n-    value = atts[i++];\n-        if (value != NULL) {\n-            if ((!xmlStrcasecmp(att, BAD_CAST \"http-equiv\")) &&\n-                (!xmlStrcasecmp(value, BAD_CAST \"Content-Type\"))) {\n-                http = 1;\n-            } else if (!xmlStrcasecmp(att, BAD_CAST \"charset\")) {\n-                xmlChar *copy;\n-\n-                copy = xmlStrdup(value);\n-                if (copy == NULL)\n-                    htmlErrMemory(ctxt);\n-                xmlSetDeclaredEncoding(ctxt, copy);\n-            } else if (!xmlStrcasecmp(att, BAD_CAST \"content\")) {\n-                content = value;\n-            }\n-        }\n-    att = atts[i++];\n-    }\n-    if ((http) && (content != NULL))\n-    htmlCheckEncoding(ctxt, content);\n-\n-}\n-\n-\/**\n- * htmlParseStartTag:\n- * @ctxt:  an HTML parser context\n- *\n- * parse a start of tag either for rule element or\n- * EmptyElement. In both case we don't parse the tag closing chars.\n- *\n- * [40] STag ::= '<' Name (S Attribute)* S? '>'\n- *\n- * [44] EmptyElemTag ::= '<' Name (S Attribute)* S? '\/>'\n- *\n- * With namespace:\n- *\n- * [NS 8] STag ::= '<' QName (S Attribute)* S? '>'\n- *\n- * [NS 10] EmptyElement ::= '<' QName (S Attribute)* S? '\/>'\n- *\n- * Returns 0 in case of success, -1 in case of error and 1 if discarded\n- *\/\n-\n-static int\n-htmlParseStartTag(htmlParserCtxtPtr ctxt) {\n-    const xmlChar *name;\n-    const xmlChar *attname;\n-    xmlChar *attvalue;\n-    const xmlChar **atts;\n-    int nbatts = 0;\n-    int maxatts;\n-    int meta = 0;\n-    int i;\n-    int discardtag = 0;\n-\n-    if ((ctxt == NULL) || (ctxt->input == NULL))\n-    return -1;\n-    if (CUR != '<') return -1;\n-    NEXT;\n-\n-    atts = ctxt->atts;\n-    maxatts = ctxt->maxatts;\n-\n-    GROW;\n-    name = htmlParseHTMLName(ctxt);\n-    if (name == NULL) {\n-    htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n-                 \"htmlParseStartTag: invalid element name\\n\",\n-             NULL, NULL);\n-    \/* Dump the bogus tag like browsers do *\/\n-    while ((CUR != 0) && (CUR != '>') &&\n-               (PARSER_STOPPED(ctxt) == 0))\n-        NEXT;\n-        return -1;\n-    }\n-    if (xmlStrEqual(name, BAD_CAST\"meta\"))\n-    meta = 1;\n-\n-    \/*\n-     * Check for auto-closure of HTML elements.\n-     *\/\n-    htmlAutoClose(ctxt, name);\n-\n-    \/*\n-     * Check for implied HTML elements.\n-     *\/\n-    htmlCheckImplied(ctxt, name);\n-\n-    \/*\n-     * Avoid html at any level > 0, head at any level != 1\n-     * or any attempt to recurse body\n-     *\/\n-    if ((ctxt->nameNr > 0) && (xmlStrEqual(name, BAD_CAST\"html\"))) {\n-    htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n-                 \"htmlParseStartTag: misplaced <html> tag\\n\",\n-             name, NULL);\n-    discardtag = 1;\n-    ctxt->depth++;\n-    }\n-    if ((ctxt->nameNr != 1) &&\n-    (xmlStrEqual(name, BAD_CAST\"head\"))) {\n-    htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n-                 \"htmlParseStartTag: misplaced <head> tag\\n\",\n-             name, NULL);\n-    discardtag = 1;\n-    ctxt->depth++;\n-    }\n-    if (xmlStrEqual(name, BAD_CAST\"body\")) {\n-    int indx;\n-    for (indx = 0;indx < ctxt->nameNr;indx++) {\n-        if (xmlStrEqual(ctxt->nameTab[indx], BAD_CAST\"body\")) {\n-        htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n-                     \"htmlParseStartTag: misplaced <body> tag\\n\",\n-                 name, NULL);\n-        discardtag = 1;\n-        ctxt->depth++;\n-        }\n-    }\n-    }\n-\n-    \/*\n-     * Now parse the attributes, it ends up with the ending\n-     *\n-     * (S Attribute)* S?\n-     *\/\n-    SKIP_BLANKS;\n-    while ((CUR != 0) &&\n-           (CUR != '>') &&\n-       ((CUR != '\/') || (NXT(1) != '>')) &&\n-           (PARSER_STOPPED(ctxt) == 0)) {\n-    GROW;\n-    attname = htmlParseAttribute(ctxt, &attvalue);\n-        if (attname != NULL) {\n-\n-        \/*\n-         * Well formedness requires at most one declaration of an attribute\n-         *\/\n-        for (i = 0; i < nbatts;i += 2) {\n-            if (xmlStrEqual(atts[i], attname)) {\n-            htmlParseErr(ctxt, XML_ERR_ATTRIBUTE_REDEFINED,\n-                         \"Attribute %s redefined\\n\", attname, NULL);\n-            if (attvalue != NULL)\n-            xmlFree(attvalue);\n-            goto failed;\n-        }\n-        }\n-\n-        \/*\n-         * Add the pair to atts\n-         *\/\n-        if (atts == NULL) {\n-            maxatts = 22; \/* allow for 10 attrs by default *\/\n-            atts = (const xmlChar **)\n-               xmlMalloc(maxatts * sizeof(xmlChar *));\n-        if (atts == NULL) {\n-            htmlErrMemory(ctxt);\n-            if (attvalue != NULL)\n-            xmlFree(attvalue);\n-            goto failed;\n-        }\n-        ctxt->atts = atts;\n-        ctxt->maxatts = maxatts;\n-        } else if (nbatts + 4 > maxatts) {\n-            const xmlChar **n;\n-\n-            maxatts *= 2;\n-            n = (const xmlChar **) xmlRealloc((void *) atts,\n-                         maxatts * sizeof(const xmlChar *));\n-        if (n == NULL) {\n-            htmlErrMemory(ctxt);\n-            if (attvalue != NULL)\n-            xmlFree(attvalue);\n-            goto failed;\n-        }\n-        atts = n;\n-        ctxt->atts = atts;\n-        ctxt->maxatts = maxatts;\n-        }\n-        atts[nbatts++] = attname;\n-        atts[nbatts++] = attvalue;\n-        atts[nbatts] = NULL;\n-        atts[nbatts + 1] = NULL;\n-    }\n-    else {\n-        if (attvalue != NULL)\n-            xmlFree(attvalue);\n-        \/* Dump the bogus attribute string up to the next blank or\n-         * the end of the tag. *\/\n-        while ((CUR != 0) &&\n-               !(IS_BLANK_CH(CUR)) && (CUR != '>') &&\n-           ((CUR != '\/') || (NXT(1) != '>')) &&\n-                   (PARSER_STOPPED(ctxt) == 0))\n-        NEXT;\n-    }\n-\n-failed:\n-    SKIP_BLANKS;\n-    }\n-\n-    \/*\n-     * Handle specific association to the META tag\n-     *\/\n-    if (meta && (nbatts != 0))\n-    htmlCheckMeta(ctxt, atts);\n-\n-    \/*\n-     * SAX: Start of Element !\n-     *\/\n-    if (!discardtag) {\n-    htmlnamePush(ctxt, name);\n-    if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL)) {\n-        if (nbatts != 0)\n-        ctxt->sax->startElement(ctxt->userData, name, atts);\n-        else\n-        ctxt->sax->startElement(ctxt->userData, name, NULL);\n-    }\n-    }\n-\n-    if (atts != NULL) {\n-        for (i = 1;i < nbatts;i += 2) {\n-        if (atts[i] != NULL)\n-        xmlFree((xmlChar *) atts[i]);\n-    }\n-    }\n-\n-    return(discardtag);\n-}\n-\n-\/**\n- * htmlParseEndTag:\n- * @ctxt:  an HTML parser context\n- *\n- * parse an end of tag\n- *\n- * [42] ETag ::= '<\/' Name S? '>'\n- *\n- * With namespace\n- *\n- * [NS 9] ETag ::= '<\/' QName S? '>'\n- *\n- * Returns 1 if the current level should be closed.\n- *\/\n-\n-static int\n-htmlParseEndTag(htmlParserCtxtPtr ctxt)\n-{\n-    const xmlChar *name;\n-    const xmlChar *oldname;\n-    int i, ret;\n-\n-    if ((CUR != '<') || (NXT(1) != '\/')) {\n-        htmlParseErr(ctxt, XML_ERR_LTSLASH_REQUIRED,\n-                 \"htmlParseEndTag: '<\/' not found\\n\", NULL, NULL);\n-        return (0);\n-    }\n-    SKIP(2);\n-\n-    name = htmlParseHTMLName(ctxt);\n-    if (name == NULL)\n-        return (0);\n-    \/*\n-     * We should definitely be at the ending \"S? '>'\" part\n-     *\/\n-    SKIP_BLANKS;\n-    if (CUR != '>') {\n-        htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,\n-                 \"End tag : expected '>'\\n\", NULL, NULL);\n-        \/* Skip to next '>' *\/\n-        while ((PARSER_STOPPED(ctxt) == 0) &&\n-               (CUR != 0) && (CUR != '>'))\n-            NEXT;\n-    }\n-    if (CUR == '>')\n-        NEXT;\n-\n-    \/*\n-     * if we ignored misplaced tags in htmlParseStartTag don't pop them\n-     * out now.\n-     *\/\n-    if ((ctxt->depth > 0) &&\n-        (xmlStrEqual(name, BAD_CAST \"html\") ||\n-         xmlStrEqual(name, BAD_CAST \"body\") ||\n-     xmlStrEqual(name, BAD_CAST \"head\"))) {\n-    ctxt->depth--;\n-    return (0);\n-    }\n-\n-    \/*\n-     * If the name read is not one of the element in the parsing stack\n-     * then return, it's just an error.\n-     *\/\n-    for (i = (ctxt->nameNr - 1); i >= 0; i--) {\n-        if (xmlStrEqual(name, ctxt->nameTab[i]))\n-            break;\n-    }\n-    if (i < 0) {\n-        htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,\n-                 \"Unexpected end tag : %s\\n\", name, NULL);\n-        return (0);\n-    }\n-\n-\n-    \/*\n-     * Check for auto-closure of HTML elements.\n-     *\/\n-\n-    htmlAutoCloseOnClose(ctxt, name);\n-\n-    \/*\n-     * Well formedness constraints, opening and closing must match.\n-     * With the exception that the autoclose may have popped stuff out\n-     * of the stack.\n-     *\/\n-    if ((ctxt->name != NULL) && (!xmlStrEqual(ctxt->name, name))) {\n-        htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,\n-                     \"Opening and ending tag mismatch: %s and %s\\n\",\n-                     name, ctxt->name);\n-    }\n-\n-    \/*\n-     * SAX: End of Tag\n-     *\/\n-    oldname = ctxt->name;\n-    if ((oldname != NULL) && (xmlStrEqual(oldname, name))) {\n-        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n-            ctxt->sax->endElement(ctxt->userData, name);\n-    htmlNodeInfoPop(ctxt);\n-        htmlnamePop(ctxt);\n-        ret = 1;\n-    } else {\n-        ret = 0;\n+     *\/\n+    if (encoding && IS_WS_HTML(*encoding))\n+        encoding = xmlStrcasestr(attvalue, BAD_CAST\"=\");\n+    if (encoding && *encoding == '=') {\n+        encoding ++;\n+        copy = xmlStrdup(encoding);\n+        if (copy == NULL)\n+            htmlErrMemory(ctxt);\n+        xmlSetDeclaredEncoding(ctxt, copy);\n@@ -4053,2 +3678,0 @@\n-\n-    return (ret);\n@@ -4057,1 +3680,0 @@\n-\n@@ -4059,1 +3681,1 @@\n- * htmlParseReference:\n+ * htmlCheckMeta:\n@@ -4061,0 +3683,1 @@\n+ * @atts:  the attributes values\n@@ -4062,3 +3685,1 @@\n- * parse and handle entity references in content,\n- * this will end-up in a call to character() since this is either a\n- * CharRef, or a predefined entity.\n+ * Checks an attributes from a Meta tag\n@@ -4067,9 +3688,5 @@\n-htmlParseReference(htmlParserCtxtPtr ctxt) {\n-    const htmlEntityDesc * ent;\n-    xmlChar out[6];\n-    const xmlChar *name;\n-    if (CUR != '&') return;\n-\n-    if (NXT(1) == '#') {\n-    unsigned int c;\n-    int bits, i = 0;\n+htmlCheckMeta(htmlParserCtxtPtr ctxt, const xmlChar **atts) {\n+    int i;\n+    const xmlChar *att, *value;\n+    int http = 0;\n+    const xmlChar *content = NULL;\n@@ -4077,2 +3694,1 @@\n-    c = htmlParseCharRef(ctxt);\n-    if (c == 0)\n+    if ((ctxt == NULL) || (atts == NULL))\n@@ -4081,4 +3697,10 @@\n-        if      (c <    0x80) { out[i++]= c;                bits= -6; }\n-        else if (c <   0x800) { out[i++]=((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n-        else if (c < 0x10000) { out[i++]=((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n-        else                  { out[i++]=((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n+    i = 0;\n+    att = atts[i++];\n+    while (att != NULL) {\n+        value = atts[i++];\n+        if (value != NULL) {\n+            if ((!xmlStrcasecmp(att, BAD_CAST \"http-equiv\")) &&\n+                (!xmlStrcasecmp(value, BAD_CAST \"Content-Type\"))) {\n+                http = 1;\n+            } else if (!xmlStrcasecmp(att, BAD_CAST \"charset\")) {\n+                xmlChar *copy;\n@@ -4086,2 +3708,7 @@\n-        for ( ; bits >= 0; bits-= 6) {\n-            out[i++]= ((c >> bits) & 0x3F) | 0x80;\n+                copy = xmlStrdup(value);\n+                if (copy == NULL)\n+                    htmlErrMemory(ctxt);\n+                xmlSetDeclaredEncoding(ctxt, copy);\n+            } else if (!xmlStrcasecmp(att, BAD_CAST \"content\")) {\n+                content = value;\n+            }\n@@ -4089,12 +3716,1 @@\n-    out[i] = 0;\n-\n-    htmlCheckParagraph(ctxt);\n-    if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL))\n-        ctxt->sax->characters(ctxt->userData, out, i);\n-    } else {\n-    ent = htmlParseEntityRef(ctxt, &name);\n-    if (name == NULL) {\n-        htmlCheckParagraph(ctxt);\n-        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL))\n-            ctxt->sax->characters(ctxt->userData, BAD_CAST \"&\", 1);\n-        return;\n+        att = atts[i++];\n@@ -4102,20 +3718,2 @@\n-    if ((ent == NULL) || !(ent->value > 0)) {\n-        htmlCheckParagraph(ctxt);\n-        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL)) {\n-        ctxt->sax->characters(ctxt->userData, BAD_CAST \"&\", 1);\n-        ctxt->sax->characters(ctxt->userData, name, xmlStrlen(name));\n-        \/* ctxt->sax->characters(ctxt->userData, BAD_CAST \";\", 1); *\/\n-        }\n-    } else {\n-        unsigned int c;\n-        int bits, i = 0;\n-\n-        c = ent->value;\n-        if      (c <    0x80)\n-                { out[i++]= c;                bits= -6; }\n-        else if (c <   0x800)\n-                { out[i++]=((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n-        else if (c < 0x10000)\n-                { out[i++]=((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n-        else\n-                { out[i++]=((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n+    if ((http) && (content != NULL))\n+        htmlCheckEncoding(ctxt, content);\n@@ -4123,4 +3721,1 @@\n-        for ( ; bits >= 0; bits-= 6) {\n-        out[i++]= ((c >> bits) & 0x3F) | 0x80;\n-        }\n-        out[i] = 0;\n+}\n@@ -4128,4 +3723,35 @@\n-        htmlCheckParagraph(ctxt);\n-        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL))\n-        ctxt->sax->characters(ctxt->userData, out, i);\n-    }\n+\/**\n+ * htmlAttrHashInsert:\n+ * @ctxt: parser context\n+ * @size: size of the hash table\n+ * @name: attribute name\n+ * @hashValue: hash value of name\n+ * @aindex: attribute index (this is a multiple of 5)\n+ *\n+ * Inserts a new attribute into the hash table.\n+ *\n+ * Returns INT_MAX if no existing attribute was found, the attribute\n+ * index if an attribute was found, -1 if a memory allocation failed.\n+ *\/\n+static int\n+htmlAttrHashInsert(xmlParserCtxtPtr ctxt, unsigned size, const xmlChar *name,\n+                   unsigned hashValue, int aindex) {\n+    xmlAttrHashBucket *table = ctxt->attrHash;\n+    xmlAttrHashBucket *bucket;\n+    unsigned hindex;\n+\n+    hindex = hashValue & (size - 1);\n+    bucket = &table[hindex];\n+\n+    while (bucket->index >= 0) {\n+        const xmlChar **atts = &ctxt->atts[bucket->index];\n+\n+        if (name == atts[0])\n+            return(bucket->index);\n+\n+        hindex++;\n+        bucket++;\n+        if (hindex >= size) {\n+            hindex = 0;\n+            bucket = table;\n+        }\n@@ -4133,0 +3759,4 @@\n+\n+    bucket->index = aindex;\n+\n+    return(INT_MAX);\n@@ -4136,1 +3766,1 @@\n- * htmlParseContent:\n+ * htmlParseStartTag:\n@@ -4139,2 +3769,14 @@\n- * Parse a content: comment, sub-element, reference or text.\n- * Kept for compatibility with old code\n+ * parse a start of tag either for rule element or\n+ * EmptyElement. In both case we don't parse the tag closing chars.\n+ *\n+ * [40] STag ::= '<' Name (S Attribute)* S? '>'\n+ *\n+ * [44] EmptyElemTag ::= '<' Name (S Attribute)* S? '\/>'\n+ *\n+ * With namespace:\n+ *\n+ * [NS 8] STag ::= '<' QName (S Attribute)* S? '>'\n+ *\n+ * [NS 10] EmptyElement ::= '<' QName (S Attribute)* S? '\/>'\n+ *\n+ * Returns 0 in case of success, -1 in case of error and 1 if discarded\n@@ -4144,3 +3786,1 @@\n-htmlParseContent(htmlParserCtxtPtr ctxt) {\n-    xmlChar *currentNode;\n-    int depth;\n+htmlParseStartTag(htmlParserCtxtPtr ctxt) {\n@@ -4148,0 +3788,8 @@\n+    const xmlChar *attname;\n+    xmlChar *attvalue;\n+    const xmlChar **atts;\n+    int nbatts = 0;\n+    int maxatts;\n+    int meta = 0;\n+    int i;\n+    int discardtag = 0;\n@@ -4149,4 +3797,1 @@\n-    currentNode = xmlStrdup(ctxt->name);\n-    depth = ctxt->nameNr;\n-    while (!PARSER_STOPPED(ctxt)) {\n-        GROW;\n+    ctxt->endCheckState = 0;\n@@ -4154,8 +3799,8 @@\n-    \/*\n-     * Our tag or one of it's parent or children is ending.\n-     *\/\n-        if ((CUR == '<') && (NXT(1) == '\/')) {\n-        if (htmlParseEndTag(ctxt) &&\n-        ((currentNode != NULL) || (ctxt->nameNr == 0))) {\n-        if (currentNode != NULL)\n-            xmlFree(currentNode);\n+    SKIP(1);\n+\n+    atts = ctxt->atts;\n+    maxatts = ctxt->maxatts;\n+\n+    GROW;\n+    name = htmlParseHTMLName(ctxt, 0).name;\n+    if (name == NULL)\n@@ -4163,3 +3808,2 @@\n-        }\n-        continue; \/* while *\/\n-        }\n+    if (xmlStrEqual(name, BAD_CAST\"meta\"))\n+        meta = 1;\n@@ -4167,16 +3811,5 @@\n-    else if ((CUR == '<') &&\n-             ((IS_ASCII_LETTER(NXT(1))) ||\n-          (NXT(1) == '_') || (NXT(1) == ':'))) {\n-        name = htmlParseHTMLName_nonInvasive(ctxt);\n-        if (name == NULL) {\n-            htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n-             \"htmlParseStartTag: invalid element name\\n\",\n-             NULL, NULL);\n-            \/* Dump the bogus tag like browsers do *\/\n-                while ((CUR != 0) && (CUR != '>'))\n-                NEXT;\n-\n-            if (currentNode != NULL)\n-                xmlFree(currentNode);\n-            return;\n-        }\n+    if ((ctxt->options & HTML_PARSE_HTML5) == 0) {\n+        \/*\n+         * Check for auto-closure of HTML elements.\n+         *\/\n+        htmlAutoClose(ctxt, name);\n@@ -4184,4 +3817,34 @@\n-        if (ctxt->name != NULL) {\n-            if (htmlCheckAutoClose(name, ctxt->name) == 1) {\n-                htmlAutoClose(ctxt, name);\n-                continue;\n+        \/*\n+         * Check for implied HTML elements.\n+         *\/\n+        htmlCheckImplied(ctxt, name);\n+\n+        \/*\n+         * Avoid html at any level > 0, head at any level != 1\n+         * or any attempt to recurse body\n+         *\/\n+        if ((ctxt->nameNr > 0) && (xmlStrEqual(name, BAD_CAST\"html\"))) {\n+            htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n+                         \"htmlParseStartTag: misplaced <html> tag\\n\",\n+                         name, NULL);\n+            discardtag = 1;\n+            ctxt->depth++;\n+        }\n+        if ((ctxt->nameNr != 1) &&\n+            (xmlStrEqual(name, BAD_CAST\"head\"))) {\n+            htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n+                         \"htmlParseStartTag: misplaced <head> tag\\n\",\n+                         name, NULL);\n+            discardtag = 1;\n+            ctxt->depth++;\n+        }\n+        if (xmlStrEqual(name, BAD_CAST\"body\")) {\n+            int indx;\n+            for (indx = 0;indx < ctxt->nameNr;indx++) {\n+                if (xmlStrEqual(ctxt->nameTab[indx], BAD_CAST\"body\")) {\n+                    htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n+                                 \"htmlParseStartTag: misplaced <body> tag\\n\",\n+                                 name, NULL);\n+                    discardtag = 1;\n+                    ctxt->depth++;\n+                }\n@@ -4193,2 +3856,3 @@\n-     * Has this node been popped out during parsing of\n-     * the next element\n+     * Now parse the attributes, it ends up with the ending\n+     *\n+     * (S Attribute)* S?\n@@ -4196,6 +3860,6 @@\n-        if ((ctxt->nameNr > 0) && (depth >= ctxt->nameNr) &&\n-        (!xmlStrEqual(currentNode, ctxt->name)))\n-         {\n-        if (currentNode != NULL) xmlFree(currentNode);\n-        return;\n-    }\n+    SKIP_BLANKS;\n+    while ((ctxt->input->cur < ctxt->input->end) &&\n+           (CUR != '>') &&\n+           ((CUR != '\/') || (NXT(1) != '>')) &&\n+           (PARSER_STOPPED(ctxt) == 0)) {\n+        xmlHashedString hattname;\n@@ -4203,7 +3867,9 @@\n-    if ((CUR != 0) && ((xmlStrEqual(currentNode, BAD_CAST\"script\")) ||\n-        (xmlStrEqual(currentNode, BAD_CAST\"style\")))) {\n-        \/*\n-         * Handle SCRIPT\/STYLE separately\n-         *\/\n-        htmlParseScript(ctxt);\n-    }\n+        \/*  unexpected-solidus-in-tag *\/\n+        if (CUR == '\/') {\n+            SKIP(1);\n+            SKIP_BLANKS;\n+            continue;\n+        }\n+        GROW;\n+        hattname = htmlParseAttribute(ctxt, &attvalue);\n+        attname = hattname.name;\n@@ -4211,13 +3877,1 @@\n-        else if ((CUR == '<') && (NXT(1) == '!')) {\n-            \/*\n-             * Sometimes DOCTYPE arrives in the middle of the document\n-             *\/\n-            if ((UPP(2) == 'D') && (UPP(3) == 'O') &&\n-                (UPP(4) == 'C') && (UPP(5) == 'T') &&\n-                (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n-                (UPP(8) == 'E')) {\n-                htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n-                             \"Misplaced DOCTYPE declaration\\n\",\n-                             BAD_CAST \"DOCTYPE\" , NULL);\n-                htmlParseDocTypeDecl(ctxt);\n-            }\n+        if (attname != NULL) {\n@@ -4225,1 +3879,1 @@\n-             * First case :  a comment\n+             * Add the pair to atts\n@@ -4227,5 +3881,33 @@\n-            else if ((NXT(2) == '-') && (NXT(3) == '-')) {\n-                htmlParseComment(ctxt);\n-            }\n-            else {\n-                htmlSkipBogusComment(ctxt);\n+            if (nbatts + 4 > maxatts) {\n+                const xmlChar **tmp;\n+                unsigned *utmp;\n+                int newSize;\n+\n+                newSize = xmlGrowCapacity(maxatts,\n+                                          sizeof(tmp[0]) * 2 + sizeof(utmp[0]),\n+                                          11, HTML_MAX_ATTRS);\n+                if (newSize < 0) {\n+                    htmlErrMemory(ctxt);\n+                    goto failed;\n+                }\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+                if (newSize < 2)\n+                    newSize = 2;\n+#endif\n+                tmp = xmlRealloc(atts, newSize * sizeof(tmp[0]) * 2);\n+                if (tmp == NULL) {\n+                    htmlErrMemory(ctxt);\n+                    goto failed;\n+                }\n+                atts = tmp;\n+                ctxt->atts = tmp;\n+\n+                utmp = xmlRealloc(ctxt->attallocs, newSize * sizeof(utmp[0]));\n+                if (utmp == NULL) {\n+                    htmlErrMemory(ctxt);\n+                    goto failed;\n+                }\n+                ctxt->attallocs = utmp;\n+\n+                maxatts = newSize * 2;\n+                ctxt->maxatts = maxatts;\n@@ -4233,1 +3915,0 @@\n-        }\n@@ -4235,6 +3916,3 @@\n-        \/*\n-         * Second case : a Processing Instruction.\n-         *\/\n-        else if ((CUR == '<') && (NXT(1) == '?')) {\n-            htmlParsePI(ctxt);\n-        }\n+            ctxt->attallocs[nbatts\/2] = hattname.hashValue;\n+            atts[nbatts++] = attname;\n+            atts[nbatts++] = attvalue;\n@@ -4242,5 +3920,1 @@\n-        \/*\n-         * Third case :  a sub-element.\n-         *\/\n-        else if ((CUR == '<') && IS_ASCII_LETTER(NXT(1))) {\n-            htmlParseElement(ctxt);\n+            attvalue = NULL;\n@@ -4248,5 +3922,35 @@\n-        else if (CUR == '<') {\n-            if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-                (ctxt->sax->characters != NULL))\n-                ctxt->sax->characters(ctxt->userData, BAD_CAST \"<\", 1);\n-            NEXT;\n+\n+failed:\n+        if (attvalue != NULL)\n+            xmlFree(attvalue);\n+\n+        SKIP_BLANKS;\n+    }\n+\n+    if (ctxt->input->cur >= ctxt->input->end) {\n+        discardtag = 1;\n+        goto done;\n+    }\n+\n+    \/*\n+     * Verify that attribute names are unique.\n+     *\/\n+    if (nbatts > 2) {\n+        unsigned attrHashSize;\n+        int j, k;\n+\n+        attrHashSize = 4;\n+        while (attrHashSize \/ 2 < (unsigned) nbatts \/ 2)\n+            attrHashSize *= 2;\n+\n+        if (attrHashSize > ctxt->attrHashMax) {\n+            xmlAttrHashBucket *tmp;\n+\n+            tmp = xmlRealloc(ctxt->attrHash, attrHashSize * sizeof(tmp[0]));\n+            if (tmp == NULL) {\n+                htmlErrMemory(ctxt);\n+                goto done;\n+            }\n+\n+            ctxt->attrHash = tmp;\n+            ctxt->attrHashMax = attrHashSize;\n@@ -4255,6 +3959,21 @@\n-        \/*\n-         * Fourth case : a reference. If if has not been resolved,\n-         *    parsing returns it's Name, create the node\n-         *\/\n-        else if (CUR == '&') {\n-            htmlParseReference(ctxt);\n+        memset(ctxt->attrHash, -1, attrHashSize * sizeof(ctxt->attrHash[0]));\n+\n+        for (i = 0, j = 0, k = 0; i < nbatts; i += 2, k++) {\n+            unsigned hashValue;\n+            int res;\n+\n+            attname = atts[i];\n+            hashValue = ctxt->attallocs[k] | 0x80000000;\n+\n+            res = htmlAttrHashInsert(ctxt, attrHashSize, attname,\n+                                    hashValue, j);\n+            if (res < 0)\n+                continue;\n+\n+            if (res == INT_MAX) {\n+                atts[j] = atts[i];\n+                atts[j+1] = atts[i+1];\n+                j += 2;\n+            } else {\n+                xmlFree((xmlChar *) atts[i+1]);\n+            }\n@@ -4263,0 +3982,20 @@\n+        nbatts = j;\n+    }\n+\n+    if (nbatts > 0) {\n+        atts[nbatts] = NULL;\n+        atts[nbatts + 1] = NULL;\n+\n+    \/*\n+     * Apple's new libiconv is so broken that you routinely run into\n+     * issues when fuzz testing (by accident with an uninstrumented\n+     * libiconv). Here's a harmless (?) example:\n+     *\n+     * printf '>'             | iconv -f shift_jis -t utf-8 | hexdump -C\n+     * printf '\\xfc\\x00\\x00'  | iconv -f shift_jis -t utf-8 | hexdump -C\n+     * printf '>\\xfc\\x00\\x00' | iconv -f shift_jis -t utf-8 | hexdump -C\n+     *\n+     * The last command fails to detect the illegal sequence.\n+     *\/\n+#if !defined(__APPLE__) || \\\n+    !defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)\n@@ -4264,1 +4003,1 @@\n-         * Fifth case : end of the resource\n+         * Handle specific association to the META tag\n@@ -4266,3 +4005,12 @@\n-        else if (CUR == 0) {\n-            htmlAutoCloseOnEnd(ctxt);\n-            break;\n+        if (meta)\n+            htmlCheckMeta(ctxt, atts);\n+#endif\n+    }\n+\n+    \/*\n+     * SAX: Start of Element !\n+     *\/\n+    if (!discardtag) {\n+        if (ctxt->options & HTML_PARSE_HTML5) {\n+            if (ctxt->nameNr > 0)\n+                htmlnamePop(ctxt);\n@@ -4271,5 +4019,6 @@\n-        \/*\n-         * Last case, text. Note that References are handled directly.\n-         *\/\n-        else {\n-            htmlParseCharData(ctxt);\n+        htmlnamePush(ctxt, name);\n+        if ((ctxt->sax != NULL) && (ctxt->sax->startElement != NULL)) {\n+            if (nbatts != 0)\n+                ctxt->sax->startElement(ctxt->userData, name, atts);\n+            else\n+                ctxt->sax->startElement(ctxt->userData, name, NULL);\n@@ -4277,0 +4026,1 @@\n+    }\n@@ -4278,2 +4028,6 @@\n-        SHRINK;\n-        GROW;\n+done:\n+    if (atts != NULL) {\n+        for (i = 1;i < nbatts;i += 2) {\n+            if (atts[i] != NULL)\n+                xmlFree((xmlChar *) atts[i]);\n+        }\n@@ -4281,1 +4035,0 @@\n-    if (currentNode != NULL) xmlFree(currentNode);\n@@ -4285,1 +4038,1 @@\n- * htmlParseElement:\n+ * htmlParseEndTag:\n@@ -4288,1 +4041,1 @@\n- * DEPRECATED: Internal function, don't use.\n+ * parse an end of tag\n@@ -4290,2 +4043,1 @@\n- * parse an HTML element, this is highly recursive\n- * this is kept for compatibility with previous code versions\n+ * [42] ETag ::= '<\/' Name S? '>'\n@@ -4293,1 +4045,1 @@\n- * [39] element ::= EmptyElemTag | STag content ETag\n+ * With namespace\n@@ -4295,1 +4047,3 @@\n- * [41] Attribute ::= Name Eq AttValue\n+ * [NS 9] ETag ::= '<\/' QName S? '>'\n+ *\n+ * Returns 1 if the current level should be closed.\n@@ -4298,2 +4052,3 @@\n-void\n-htmlParseElement(htmlParserCtxtPtr ctxt) {\n+static void\n+htmlParseEndTag(htmlParserCtxtPtr ctxt)\n+{\n@@ -4301,6 +4056,2 @@\n-    xmlChar *currentNode = NULL;\n-    const htmlElemDesc * info;\n-    htmlParserNodeInfo node_info;\n-    int failed;\n-    int depth;\n-    const xmlChar *oldptr;\n+    const xmlChar *oldname;\n+    int i;\n@@ -4308,2 +4059,1 @@\n-    if ((ctxt == NULL) || (ctxt->input == NULL))\n-    return;\n+    ctxt->endCheckState = 0;\n@@ -4311,5 +4061,9 @@\n-    \/* Capture start position *\/\n-    if (ctxt->record_info) {\n-        node_info.begin_pos = ctxt->input->consumed +\n-                          (CUR_PTR - ctxt->input->base);\n-    node_info.begin_line = ctxt->input->line;\n+    SKIP(2);\n+\n+    if (ctxt->input->cur >= ctxt->input->end) {\n+        htmlStartCharData(ctxt);\n+        if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+            (ctxt->sax->characters != NULL))\n+            ctxt->sax->characters(ctxt->userData,\n+                                  BAD_CAST \"<\/\", 2);\n+        return;\n@@ -4318,5 +4072,7 @@\n-    failed = htmlParseStartTag(ctxt);\n-    name = ctxt->name;\n-    if ((failed == -1) || (name == NULL)) {\n-    if (CUR == '>')\n-        NEXT;\n+    if (CUR == '>') {\n+        SKIP(1);\n+        return;\n+    }\n+\n+    if (!IS_ASCII_LETTER(CUR)) {\n+        htmlParseComment(ctxt, \/* bogus *\/ 1);\n@@ -4326,7 +4082,26 @@\n-    \/*\n-     * Lookup the info for that element.\n-     *\/\n-    info = htmlTagLookup(name);\n-    if (info == NULL) {\n-    htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,\n-                 \"Tag %s invalid\\n\", name, NULL);\n+    name = htmlParseHTMLName(ctxt, 0).name;\n+    if (name == NULL)\n+        return;\n+\n+    \/*\n+     * Parse and ignore attributes.\n+     *\/\n+    SKIP_BLANKS;\n+    while ((ctxt->input->cur < ctxt->input->end) &&\n+           (CUR != '>') &&\n+           ((CUR != '\/') || (NXT(1) != '>')) &&\n+           (ctxt->instate != XML_PARSER_EOF)) {\n+        xmlChar *attvalue = NULL;\n+\n+        \/*  unexpected-solidus-in-tag *\/\n+        if (CUR == '\/') {\n+            SKIP(1);\n+            SKIP_BLANKS;\n+            continue;\n+        }\n+        GROW;\n+        htmlParseAttribute(ctxt, &attvalue);\n+        if (attvalue != NULL)\n+            xmlFree(attvalue);\n+\n+        SKIP_BLANKS;\n@@ -4335,4 +4110,3 @@\n-    \/*\n-     * Check for an Empty Element labeled the XML\/SGML way\n-     *\/\n-    if ((CUR == '\/') && (NXT(1) == '>')) {\n+    if (CUR == '>') {\n+        SKIP(1);\n+    } else if ((CUR == '\/') && (NXT(1) == '>')) {\n@@ -4340,4 +4114,2 @@\n-    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n-        ctxt->sax->endElement(ctxt->userData, name);\n-    htmlnamePop(ctxt);\n-    return;\n+    } else {\n+        return;\n@@ -4346,5 +4118,5 @@\n-    if (CUR == '>') {\n-        NEXT;\n-    } else {\n-    htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,\n-                 \"Couldn't find end of Start Tag %s\\n\", name, NULL);\n+    if (ctxt->options & HTML_PARSE_HTML5) {\n+        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n+            ctxt->sax->endElement(ctxt->userData, name);\n+        return;\n+    }\n@@ -4353,1 +4125,2 @@\n-     * end of parsing of this node.\n+     * if we ignored misplaced tags in htmlParseStartTag don't pop them\n+     * out now.\n@@ -4355,3 +4128,6 @@\n-    if (xmlStrEqual(name, ctxt->name)) {\n-        nodePop(ctxt);\n-        htmlnamePop(ctxt);\n+    if ((ctxt->depth > 0) &&\n+        (xmlStrEqual(name, BAD_CAST \"html\") ||\n+         xmlStrEqual(name, BAD_CAST \"body\") ||\n+         xmlStrEqual(name, BAD_CAST \"head\"))) {\n+        ctxt->depth--;\n+        return;\n@@ -4361,1 +4137,2 @@\n-     * Capture end position and add node\n+     * If the name read is not one of the element in the parsing stack\n+     * then return, it's just an error.\n@@ -4363,6 +4140,3 @@\n-    if (ctxt->record_info) {\n-       node_info.end_pos = ctxt->input->consumed +\n-                  (CUR_PTR - ctxt->input->base);\n-       node_info.end_line = ctxt->input->line;\n-       node_info.node = ctxt->node;\n-       xmlParserAddNodeInfo(ctxt, &node_info);\n+    for (i = (ctxt->nameNr - 1); i >= 0; i--) {\n+        if (xmlStrEqual(name, ctxt->nameTab[i]))\n+            break;\n@@ -4370,1 +4144,4 @@\n-    return;\n+    if (i < 0) {\n+        htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,\n+                     \"Unexpected end tag : %s\\n\", name, NULL);\n+        return;\n@@ -4373,0 +4150,1 @@\n+\n@@ -4374,1 +4152,1 @@\n-     * Check for an Empty Element from DTD definition\n+     * Check for auto-closure of HTML elements.\n@@ -4376,6 +4154,2 @@\n-    if ((info != NULL) && (info->empty)) {\n-    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n-        ctxt->sax->endElement(ctxt->userData, name);\n-    htmlnamePop(ctxt);\n-    return;\n-    }\n+\n+    htmlAutoCloseOnClose(ctxt, name);\n@@ -4384,1 +4158,3 @@\n-     * Parse the content of the element:\n+     * Well formedness constraints, opening and closing must match.\n+     * With the exception that the autoclose may have popped stuff out\n+     * of the stack.\n@@ -4386,7 +4162,4 @@\n-    currentNode = xmlStrdup(ctxt->name);\n-    depth = ctxt->nameNr;\n-    while (CUR != 0) {\n-    oldptr = ctxt->input->cur;\n-    htmlParseContent(ctxt);\n-    if (oldptr==ctxt->input->cur) break;\n-    if (ctxt->nameNr < depth) break;\n+    if ((ctxt->name != NULL) && (!xmlStrEqual(ctxt->name, name))) {\n+        htmlParseErr(ctxt, XML_ERR_TAG_NAME_MISMATCH,\n+                     \"Opening and ending tag mismatch: %s and %s\\n\",\n+                     name, ctxt->name);\n@@ -4396,1 +4169,1 @@\n-     * Capture end position and add node\n+     * SAX: End of Tag\n@@ -4398,9 +4171,6 @@\n-    if ( currentNode != NULL && ctxt->record_info ) {\n-       node_info.end_pos = ctxt->input->consumed +\n-                          (CUR_PTR - ctxt->input->base);\n-       node_info.end_line = ctxt->input->line;\n-       node_info.node = ctxt->node;\n-       xmlParserAddNodeInfo(ctxt, &node_info);\n-    }\n-    if (CUR == 0) {\n-    htmlAutoCloseOnEnd(ctxt);\n+    oldname = ctxt->name;\n+    if ((oldname != NULL) && (xmlStrEqual(oldname, name))) {\n+        htmlParserFinishElementParsing(ctxt);\n+        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n+            ctxt->sax->endElement(ctxt->userData, name);\n+        htmlnamePop(ctxt);\n@@ -4408,3 +4178,0 @@\n-\n-    if (currentNode != NULL)\n-    xmlFree(currentNode);\n@@ -4413,0 +4180,8 @@\n+\/**\n+ * htmlParseContent:\n+ * @ctxt:  an HTML parser context\n+ *\n+ * Parse a content: comment, sub-element, reference or text.\n+ * New version for non recursive htmlParseElementInternal\n+ *\/\n+\n@@ -4414,14 +4189,46 @@\n-htmlParserFinishElementParsing(htmlParserCtxtPtr ctxt) {\n-    \/*\n-     * Capture end position and add node\n-     *\/\n-    if ( ctxt->node != NULL && ctxt->record_info ) {\n-       ctxt->nodeInfo->end_pos = ctxt->input->consumed +\n-                                (CUR_PTR - ctxt->input->base);\n-       ctxt->nodeInfo->end_line = ctxt->input->line;\n-       ctxt->nodeInfo->node = ctxt->node;\n-       xmlParserAddNodeInfo(ctxt, ctxt->nodeInfo);\n-       htmlNodeInfoPop(ctxt);\n-    }\n-    if (CUR == 0) {\n-       htmlAutoCloseOnEnd(ctxt);\n+htmlParseContent(htmlParserCtxtPtr ctxt) {\n+    GROW;\n+\n+    while ((PARSER_STOPPED(ctxt) == 0) &&\n+           (ctxt->input->cur < ctxt->input->end)) {\n+        int mode;\n+\n+        mode = ctxt->endCheckState;\n+\n+        if ((mode == 0) && (CUR == '<')) {\n+            if (NXT(1) == '\/') {\n+                htmlParseEndTag(ctxt);\n+            } else if (NXT(1) == '!') {\n+                \/*\n+                 * Sometimes DOCTYPE arrives in the middle of the document\n+                 *\/\n+                if ((UPP(2) == 'D') && (UPP(3) == 'O') &&\n+                    (UPP(4) == 'C') && (UPP(5) == 'T') &&\n+                    (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n+                    (UPP(8) == 'E')) {\n+                    htmlParseDocTypeDecl(ctxt);\n+                } else if ((NXT(2) == '-') && (NXT(3) == '-')) {\n+                    SKIP(4);\n+                    htmlParseComment(ctxt, \/* bogus *\/ 0);\n+                } else {\n+                    SKIP(2);\n+                    htmlParseComment(ctxt, \/* bogus *\/ 1);\n+                }\n+            } else if (NXT(1) == '?') {\n+                SKIP(1);\n+                htmlParseComment(ctxt, \/* bogus *\/ 1);\n+            } else if (IS_ASCII_LETTER(NXT(1))) {\n+                htmlParseElementInternal(ctxt);\n+            } else {\n+                htmlStartCharData(ctxt);\n+                if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                    (ctxt->sax->characters != NULL))\n+                    ctxt->sax->characters(ctxt->userData, BAD_CAST \"<\", 1);\n+                SKIP(1);\n+            }\n+        } else {\n+            htmlParseCharData(ctxt, \/* partial *\/ 0);\n+        }\n+\n+        SHRINK;\n+        GROW;\n@@ -4429,0 +4236,3 @@\n+\n+    if (ctxt->input->cur >= ctxt->input->end)\n+        htmlAutoCloseOnEnd(ctxt);\n@@ -4442,1 +4252,1 @@\n-static void\n+static int\n@@ -4447,1 +4257,0 @@\n-    int failed;\n@@ -4450,1 +4259,1 @@\n-    return;\n+        return(0);\n@@ -4456,1 +4265,1 @@\n-    node_info.begin_line = ctxt->input->line;\n+        node_info.begin_line = ctxt->input->line;\n@@ -4459,1 +4268,1 @@\n-    failed = htmlParseStartTag(ctxt);\n+    htmlParseStartTag(ctxt);\n@@ -4461,5 +4270,2 @@\n-    if ((failed == -1) || (name == NULL)) {\n-    if (CUR == '>')\n-        NEXT;\n-        return;\n-    }\n+    if (name == NULL)\n+        return(0);\n@@ -4467,8 +4273,2 @@\n-    \/*\n-     * Lookup the info for that element.\n-     *\/\n-    info = htmlTagLookup(name);\n-    if (info == NULL) {\n-    htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,\n-                 \"Tag %s invalid\\n\", name, NULL);\n-    }\n+    if (ctxt->record_info)\n+        htmlNodeInfoPush(ctxt, &node_info);\n@@ -4481,4 +4281,7 @@\n-    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n-        ctxt->sax->endElement(ctxt->userData, name);\n-    htmlnamePop(ctxt);\n-    return;\n+        htmlParserFinishElementParsing(ctxt);\n+        if ((ctxt->options & HTML_PARSE_HTML5) == 0) {\n+            if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n+                ctxt->sax->endElement(ctxt->userData, name);\n+        }\n+        htmlnamePop(ctxt);\n+        return(0);\n@@ -4487,5 +4290,3 @@\n-    if (CUR == '>') {\n-        NEXT;\n-    } else {\n-    htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,\n-                 \"Couldn't find end of Start Tag %s\\n\", name, NULL);\n+    if (CUR != '>')\n+        return(0);\n+    SKIP(1);\n@@ -4494,1 +4295,1 @@\n-     * end of parsing of this node.\n+     * Lookup the info for that element.\n@@ -4496,10 +4297,1 @@\n-    if (xmlStrEqual(name, ctxt->name)) {\n-        nodePop(ctxt);\n-        htmlnamePop(ctxt);\n-    }\n-\n-        if (ctxt->record_info)\n-            htmlNodeInfoPush(ctxt, &node_info);\n-        htmlParserFinishElementParsing(ctxt);\n-    return;\n-    }\n+    info = htmlTagLookup(name);\n@@ -4511,4 +4303,7 @@\n-    if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n-        ctxt->sax->endElement(ctxt->userData, name);\n-    htmlnamePop(ctxt);\n-    return;\n+        htmlParserFinishElementParsing(ctxt);\n+        if ((ctxt->options & HTML_PARSE_HTML5) == 0) {\n+            if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n+                ctxt->sax->endElement(ctxt->userData, name);\n+        }\n+        htmlnamePop(ctxt);\n+        return(0);\n@@ -4517,2 +4312,4 @@\n-    if (ctxt->record_info)\n-        htmlNodeInfoPush(ctxt, &node_info);\n+    if (info != NULL)\n+        ctxt->endCheckState = info->dataMode;\n+\n+    return(1);\n@@ -4522,1 +4319,1 @@\n- * htmlParseContentInternal:\n+ * htmlParseElement:\n@@ -4525,2 +4322,8 @@\n- * Parse a content: comment, sub-element, reference or text.\n- * New version for non recursive htmlParseElementInternal\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * parse an HTML element, this is highly recursive\n+ * this is kept for compatibility with previous code versions\n+ *\n+ * [39] element ::= EmptyElemTag | STag content ETag\n+ *\n+ * [41] Attribute ::= Name Eq AttValue\n@@ -4529,3 +4332,3 @@\n-static void\n-htmlParseContentInternal(htmlParserCtxtPtr ctxt) {\n-    xmlChar *currentNode;\n+void\n+htmlParseElement(htmlParserCtxtPtr ctxt) {\n+    const xmlChar *oldptr;\n@@ -4533,37 +4336,0 @@\n-    const xmlChar *name;\n-\n-    depth = ctxt->nameNr;\n-    if (depth <= 0) {\n-        currentNode = NULL;\n-    } else {\n-        currentNode = xmlStrdup(ctxt->name);\n-        if (currentNode == NULL) {\n-            htmlErrMemory(ctxt);\n-            return;\n-        }\n-    }\n-    while (PARSER_STOPPED(ctxt) == 0) {\n-        GROW;\n-\n-    \/*\n-     * Our tag or one of it's parent or children is ending.\n-     *\/\n-        if ((CUR == '<') && (NXT(1) == '\/')) {\n-        if (htmlParseEndTag(ctxt) &&\n-        ((currentNode != NULL) || (ctxt->nameNr == 0))) {\n-        if (currentNode != NULL)\n-            xmlFree(currentNode);\n-\n-            depth = ctxt->nameNr;\n-                if (depth <= 0) {\n-                    currentNode = NULL;\n-                } else {\n-                    currentNode = xmlStrdup(ctxt->name);\n-                    if (currentNode == NULL) {\n-                        htmlErrMemory(ctxt);\n-                        break;\n-                    }\n-                }\n-        }\n-        continue; \/* while *\/\n-        }\n@@ -4571,28 +4337,2 @@\n-    else if ((CUR == '<') &&\n-             ((IS_ASCII_LETTER(NXT(1))) ||\n-          (NXT(1) == '_') || (NXT(1) == ':'))) {\n-        name = htmlParseHTMLName_nonInvasive(ctxt);\n-        if (name == NULL) {\n-            htmlParseErr(ctxt, XML_ERR_NAME_REQUIRED,\n-             \"htmlParseStartTag: invalid element name\\n\",\n-             NULL, NULL);\n-            \/* Dump the bogus tag like browsers do *\/\n-            while ((CUR == 0) && (CUR != '>'))\n-                NEXT;\n-\n-            htmlParserFinishElementParsing(ctxt);\n-            if (currentNode != NULL)\n-                xmlFree(currentNode);\n-\n-                if (ctxt->name == NULL) {\n-                    currentNode = NULL;\n-                } else {\n-                    currentNode = xmlStrdup(ctxt->name);\n-                    if (currentNode == NULL) {\n-                        htmlErrMemory(ctxt);\n-                        break;\n-                    }\n-                }\n-            depth = ctxt->nameNr;\n-            continue;\n-        }\n+    if ((ctxt == NULL) || (ctxt->input == NULL))\n+        return;\n@@ -4600,7 +4340,2 @@\n-        if (ctxt->name != NULL) {\n-            if (htmlCheckAutoClose(name, ctxt->name) == 1) {\n-                htmlAutoClose(ctxt, name);\n-                continue;\n-            }\n-        }\n-    }\n+    if (htmlParseElementInternal(ctxt) == 0)\n+        return;\n@@ -4609,2 +4344,1 @@\n-     * Has this node been popped out during parsing of\n-     * the next element\n+     * Parse the content of the element:\n@@ -4612,17 +4346,6 @@\n-        if ((ctxt->nameNr > 0) && (depth >= ctxt->nameNr) &&\n-        (!xmlStrEqual(currentNode, ctxt->name)))\n-         {\n-        htmlParserFinishElementParsing(ctxt);\n-        if (currentNode != NULL) xmlFree(currentNode);\n-\n-            if (ctxt->name == NULL) {\n-                currentNode = NULL;\n-            } else {\n-                currentNode = xmlStrdup(ctxt->name);\n-                if (currentNode == NULL) {\n-                    htmlErrMemory(ctxt);\n-                    break;\n-                }\n-            }\n-        depth = ctxt->nameNr;\n-        continue;\n+    depth = ctxt->nameNr;\n+    while (CUR != 0) {\n+        oldptr = ctxt->input->cur;\n+        htmlParseContent(ctxt);\n+        if (oldptr==ctxt->input->cur) break;\n+        if (ctxt->nameNr < depth) break;\n@@ -4631,6 +4354,2 @@\n-    if ((CUR != 0) && ((xmlStrEqual(currentNode, BAD_CAST\"script\")) ||\n-        (xmlStrEqual(currentNode, BAD_CAST\"style\")))) {\n-        \/*\n-         * Handle SCRIPT\/STYLE separately\n-         *\/\n-        htmlParseScript(ctxt);\n+    if (CUR == 0) {\n+        htmlAutoCloseOnEnd(ctxt);\n@@ -4638,0 +4357,1 @@\n+}\n@@ -4639,23 +4359,18 @@\n-        else if ((CUR == '<') && (NXT(1) == '!')) {\n-            \/*\n-             * Sometimes DOCTYPE arrives in the middle of the document\n-             *\/\n-            if ((UPP(2) == 'D') && (UPP(3) == 'O') &&\n-                (UPP(4) == 'C') && (UPP(5) == 'T') &&\n-                (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n-                (UPP(8) == 'E')) {\n-                htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n-                             \"Misplaced DOCTYPE declaration\\n\",\n-                             BAD_CAST \"DOCTYPE\" , NULL);\n-                htmlParseDocTypeDecl(ctxt);\n-            }\n-            \/*\n-             * First case :  a comment\n-             *\/\n-            else if ((NXT(2) == '-') && (NXT(3) == '-')) {\n-                htmlParseComment(ctxt);\n-            }\n-            else {\n-                htmlSkipBogusComment(ctxt);\n-            }\n-        }\n+\/**\n+ * htmlCtxtParseContentInternal:\n+ * @ctxt:  parser context\n+ * @input:  parser input\n+ *\n+ * Returns a node list.\n+ *\/\n+xmlNodePtr\n+htmlCtxtParseContentInternal(htmlParserCtxtPtr ctxt, xmlParserInputPtr input) {\n+    xmlNodePtr root;\n+    xmlNodePtr list = NULL;\n+    xmlChar *rootName = BAD_CAST \"#root\";\n+\n+    root = xmlNewDocNode(ctxt->myDoc, NULL, rootName, NULL);\n+    if (root == NULL) {\n+        htmlErrMemory(ctxt);\n+        return(NULL);\n+    }\n@@ -4663,6 +4378,4 @@\n-        \/*\n-         * Second case : a Processing Instruction.\n-         *\/\n-        else if ((CUR == '<') && (NXT(1) == '?')) {\n-            htmlParsePI(ctxt);\n-        }\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n+        xmlFreeNode(root);\n+        return(NULL);\n+    }\n@@ -4670,6 +4383,2 @@\n-        \/*\n-         * Third case :  a sub-element.\n-         *\/\n-        else if ((CUR == '<') && IS_ASCII_LETTER(NXT(1))) {\n-            htmlParseElementInternal(ctxt);\n-            if (currentNode != NULL) xmlFree(currentNode);\n+    htmlnamePush(ctxt, rootName);\n+    nodePush(ctxt, root);\n@@ -4677,17 +4386,1 @@\n-            if (ctxt->name == NULL) {\n-                currentNode = NULL;\n-            } else {\n-                currentNode = xmlStrdup(ctxt->name);\n-                if (currentNode == NULL) {\n-                    htmlErrMemory(ctxt);\n-                    break;\n-                }\n-            }\n-            depth = ctxt->nameNr;\n-        }\n-        else if (CUR == '<') {\n-            if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-                (ctxt->sax->characters != NULL))\n-                ctxt->sax->characters(ctxt->userData, BAD_CAST \"<\", 1);\n-            NEXT;\n-        }\n+    htmlParseContent(ctxt);\n@@ -4695,7 +4388,4 @@\n-        \/*\n-         * Fourth case : a reference. If if has not been resolved,\n-         *    parsing returns it's Name, create the node\n-         *\/\n-        else if (CUR == '&') {\n-            htmlParseReference(ctxt);\n-        }\n+    \/*\n+     * Only check for truncated multi-byte sequences\n+     *\/\n+    xmlParserCheckEOF(ctxt, XML_ERR_INTERNAL_ERROR);\n@@ -4703,7 +4393,3 @@\n-        \/*\n-         * Fifth case : end of the resource\n-         *\/\n-        else if (CUR == 0) {\n-            htmlAutoCloseOnEnd(ctxt);\n-            break;\n-        }\n+    \/* TODO: Use xmlCtxtIsCatastrophicError *\/\n+    if (ctxt->errNo != XML_ERR_NO_MEMORY) {\n+        xmlNodePtr cur;\n@@ -4712,1 +4398,1 @@\n-         * Last case, text. Note that References are handled directly.\n+         * Unlink newly created node list.\n@@ -4714,6 +4400,5 @@\n-        else {\n-            htmlParseCharData(ctxt);\n-        }\n-\n-        SHRINK;\n-        GROW;\n+        list = root->children;\n+        root->children = NULL;\n+        root->last = NULL;\n+        for (cur = list; cur != NULL; cur = cur->next)\n+            cur->parent = NULL;\n@@ -4721,2 +4406,0 @@\n-    if (currentNode != NULL) xmlFree(currentNode);\n-}\n@@ -4724,7 +4407,2 @@\n-\/**\n- * htmlParseContent:\n- * @ctxt:  an HTML parser context\n- *\n- * Parse a content: comment, sub-element, reference or text.\n- * This is the entry point when called from parser.c\n- *\/\n+    nodePop(ctxt);\n+    htmlnamePop(ctxt);\n@@ -4732,4 +4410,4 @@\n-void\n-__htmlParseContent(void *ctxt) {\n-    if (ctxt != NULL)\n-    htmlParseContentInternal((htmlParserCtxtPtr) ctxt);\n+    xmlCtxtPopInput(ctxt);\n+\n+    xmlFreeNode(root);\n+    return(list);\n@@ -4754,1 +4432,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4764,2 +4442,8 @@\n-     * This is wrong but matches long-standing behavior. In most cases,\n-     * a document starting with an XML declaration will specify UTF-8.\n+     * TODO: Implement HTML5 prescan algorithm\n+     *\/\n+\n+    \/*\n+     * This is wrong but matches long-standing behavior. In most\n+     * cases, a document starting with an XML declaration will\n+     * specify UTF-8. The HTML5 prescan algorithm handles\n+     * XML declarations in a better way.\n@@ -4775,4 +4459,0 @@\n-    if (CUR == 0) {\n-    htmlParseErr(ctxt, XML_ERR_DOCUMENT_EMPTY,\n-                 \"Document is empty\\n\", NULL, NULL);\n-    }\n@@ -4781,1 +4461,1 @@\n-    ctxt->sax->startDocument(ctxt->userData);\n+        ctxt->sax->startDocument(ctxt->userData);\n@@ -4786,6 +4466,11 @@\n-    while (((CUR == '<') && (NXT(1) == '!') &&\n-            (NXT(2) == '-') && (NXT(3) == '-')) ||\n-       ((CUR == '<') && (NXT(1) == '?'))) {\n-        htmlParseComment(ctxt);\n-        htmlParsePI(ctxt);\n-    SKIP_BLANKS;\n+    while (CUR == '<') {\n+        if ((NXT(1) == '!') && (NXT(2) == '-') && (NXT(3) == '-')) {\n+            SKIP(4);\n+            htmlParseComment(ctxt, \/* bogus *\/ 0);\n+        } else if (NXT(1) == '?') {\n+            SKIP(1);\n+            htmlParseComment(ctxt, \/* bogus *\/ 1);\n+        } else {\n+            break;\n+        }\n+        SKIP_BLANKS;\n@@ -4794,1 +4479,0 @@\n-\n@@ -4800,5 +4484,6 @@\n-    (UPP(2) == 'D') && (UPP(3) == 'O') &&\n-    (UPP(4) == 'C') && (UPP(5) == 'T') &&\n-    (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n-    (UPP(8) == 'E')) {\n-    htmlParseDocTypeDecl(ctxt);\n+        (UPP(2) == 'D') && (UPP(3) == 'O') &&\n+        (UPP(4) == 'C') && (UPP(5) == 'T') &&\n+        (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n+        (UPP(8) == 'E')) {\n+        ctxt->instate = XML_PARSER_MISC;\n+        htmlParseDocTypeDecl(ctxt);\n@@ -4811,7 +4496,12 @@\n-    while ((PARSER_STOPPED(ctxt) == 0) &&\n-           (((CUR == '<') && (NXT(1) == '!') &&\n-             (NXT(2) == '-') && (NXT(3) == '-')) ||\n-        ((CUR == '<') && (NXT(1) == '?')))) {\n-        htmlParseComment(ctxt);\n-        htmlParsePI(ctxt);\n-    SKIP_BLANKS;\n+    ctxt->instate = XML_PARSER_PROLOG;\n+    while (CUR == '<') {\n+        if ((NXT(1) == '!') && (NXT(2) == '-') && (NXT(3) == '-')) {\n+            SKIP(4);\n+            htmlParseComment(ctxt, \/* bogus *\/ 0);\n+        } else if (NXT(1) == '?') {\n+            SKIP(1);\n+            htmlParseComment(ctxt, \/* bogus *\/ 1);\n+        } else {\n+            break;\n+        }\n+        SKIP_BLANKS;\n@@ -4823,1 +4513,2 @@\n-    htmlParseContentInternal(ctxt);\n+    ctxt->instate = XML_PARSER_CONTENT;\n+    htmlParseContent(ctxt);\n@@ -4826,1 +4517,1 @@\n-     * autoclose\n+     * Only check for truncated multi-byte sequences\n@@ -4828,3 +4519,1 @@\n-    if (CUR == 0)\n-    htmlAutoCloseOnEnd(ctxt);\n-\n+    xmlParserCheckEOF(ctxt, XML_ERR_INTERNAL_ERROR);\n@@ -4839,6 +4528,6 @@\n-    dtd = xmlGetIntSubset(ctxt->myDoc);\n-    if (dtd == NULL) {\n-        ctxt->myDoc->intSubset =\n-        xmlCreateIntSubset(ctxt->myDoc, BAD_CAST \"html\",\n-            BAD_CAST \"-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\",\n-            BAD_CAST \"http:\/\/www.w3.org\/TR\/REC-html40\/loose.dtd\");\n+        dtd = xmlGetIntSubset(ctxt->myDoc);\n+        if (dtd == NULL) {\n+            ctxt->myDoc->intSubset =\n+                xmlCreateIntSubset(ctxt->myDoc, BAD_CAST \"html\",\n+                    BAD_CAST \"-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\",\n+                    BAD_CAST \"http:\/\/www.w3.org\/TR\/REC-html40\/loose.dtd\");\n@@ -4855,3 +4544,3 @@\n- *                                    *\n- *            Parser contexts handling            *\n- *                                    *\n+ *                                                                      *\n+ *                      Parser contexts handling                        *\n+ *                                                                      *\n@@ -4875,0 +4564,6 @@\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+    size_t initialNodeTabSize = 1;\n+#else\n+    size_t initialNodeTabSize = 10;\n+#endif\n+\n@@ -4880,1 +4575,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4885,1 +4580,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4897,1 +4592,1 @@\n-                      xmlMalloc(5 * sizeof(htmlParserInputPtr));\n+                      xmlMalloc(sizeof(htmlParserInputPtr));\n@@ -4899,1 +4594,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4901,1 +4596,1 @@\n-    ctxt->inputMax = 5;\n+    ctxt->inputMax = 1;\n@@ -4909,1 +4604,1 @@\n-    ctxt->nodeTab = (htmlNodePtr *) xmlMalloc(10 * sizeof(htmlNodePtr));\n+    ctxt->nodeTab = xmlMalloc(initialNodeTabSize * sizeof(htmlNodePtr));\n@@ -4911,1 +4606,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4913,1 +4608,1 @@\n-    ctxt->nodeMax = 10;\n+    ctxt->nodeMax = initialNodeTabSize;\n@@ -4917,1 +4612,1 @@\n-    ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));\n+    ctxt->nameTab = xmlMalloc(initialNodeTabSize * sizeof(xmlChar *));\n@@ -4919,1 +4614,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4921,1 +4616,1 @@\n-    ctxt->nameMax = 10;\n+    ctxt->nameMax = initialNodeTabSize;\n@@ -4933,1 +4628,1 @@\n-    ctxt->html = 1;\n+    ctxt->html = INSERT_INITIAL;\n@@ -4972,3 +4667,0 @@\n- * See xmlNewInputURL, xmlNewInputMemory, xmlNewInputIO and similar\n- * functions for advanced input control.\n- *\n@@ -5012,1 +4704,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5016,1 +4708,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5029,1 +4721,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5033,1 +4725,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5035,1 +4727,1 @@\n-    input = xmlNewInputMemory(ctxt, url, buffer, size, encoding, 0);\n+    input = xmlCtxtNewInputFromMemory(ctxt, url, buffer, size, encoding, 0);\n@@ -5037,1 +4729,1 @@\n-    xmlFreeParserCtxt(ctxt);\n+        xmlFreeParserCtxt(ctxt);\n@@ -5041,1 +4733,5 @@\n-    inputPush(ctxt, input);\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n+        xmlFreeInputStream(input);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n+    }\n@@ -5061,1 +4757,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5082,1 +4778,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5086,1 +4782,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5088,1 +4784,2 @@\n-    input = xmlNewInputString(ctxt, url, (const char *) str, encoding, 0);\n+    input = xmlCtxtNewInputFromString(ctxt, url, (const char *) str,\n+                                      encoding, 0);\n@@ -5090,2 +4787,2 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -5094,1 +4791,5 @@\n-    inputPush(ctxt, input);\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n+        xmlFreeInputStream(input);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n+    }\n@@ -5101,3 +4802,3 @@\n- *                                    *\n- *    Progressive parsing interfaces                *\n- *                                    *\n+ *                                                                      *\n+ *      Progressive parsing interfaces                          *\n+ *                                                                      *\n@@ -5106,0 +4807,11 @@\n+typedef enum {\n+    LSTATE_TAG_NAME = 0,\n+    LSTATE_BEFORE_ATTR_NAME,\n+    LSTATE_ATTR_NAME,\n+    LSTATE_AFTER_ATTR_NAME,\n+    LSTATE_BEFORE_ATTR_VALUE,\n+    LSTATE_ATTR_VALUE_DQUOTED,\n+    LSTATE_ATTR_VALUE_SQUOTED,\n+    LSTATE_ATTR_VALUE_UNQUOTED\n+} xmlLookupStates;\n+\n@@ -5107,1 +4819,1 @@\n- * htmlParseLookupSequence:\n+ * htmlParseLookupGt:\n@@ -5109,11 +4821,0 @@\n- * @first:  the first char to lookup\n- * @next:  the next char to lookup or zero\n- * @third:  the next char to lookup or zero\n- * @ignoreattrval: skip over attribute values\n- *\n- * Try to find if a sequence (first, next, third) or  just (first next) or\n- * (first) is available in the input stream.\n- * This function has a side effect of (possibly) incrementing ctxt->checkIndex\n- * to avoid rescanning sequences of bytes, it DOES change the state of the\n- * parser, do not use liberally.\n- * This is basically similar to xmlParseLookupSequence()\n@@ -5121,2 +4822,2 @@\n- * Returns the index to the current parsing point if the full sequence\n- *      is available, -1 otherwise.\n+ * Check whether there's enough data in the input buffer to finish parsing\n+ * a tag. This has to take quotes into account.\n@@ -5125,37 +4826,20 @@\n-htmlParseLookupSequence(htmlParserCtxtPtr ctxt, xmlChar first,\n-                        xmlChar next, xmlChar third, int ignoreattrval)\n-{\n-    size_t base, len;\n-    htmlParserInputPtr in;\n-    const xmlChar *buf;\n-    int quote;\n-\n-    in = ctxt->input;\n-    if (in == NULL)\n-        return (-1);\n-\n-    base = ctxt->checkIndex;\n-    quote = ctxt->endCheckState;\n-\n-    buf = in->cur;\n-    len = in->end - in->cur;\n-\n-    \/* take into account the sequence length *\/\n-    if (third)\n-        len -= 2;\n-    else if (next)\n-        len--;\n-    for (; base < len; base++) {\n-        if (base >= INT_MAX \/ 2) {\n-            ctxt->checkIndex = 0;\n-            ctxt->endCheckState = 0;\n-            return (base - 2);\n-        }\n-        if (ignoreattrval) {\n-            if (quote) {\n-                if (buf[base] == quote)\n-                    quote = 0;\n-                continue;\n-            }\n-            if (buf[base] == '\"' || buf[base] == '\\'') {\n-                quote = buf[base];\n+htmlParseLookupGt(xmlParserCtxtPtr ctxt) {\n+    const xmlChar *cur;\n+    const xmlChar *end = ctxt->input->end;\n+    int state = ctxt->endCheckState;\n+    size_t index;\n+\n+    if (ctxt->checkIndex == 0)\n+        cur = ctxt->input->cur + 2; \/* Skip '<a' or '<\/' *\/\n+    else\n+        cur = ctxt->input->cur + ctxt->checkIndex;\n+\n+    while (cur < end) {\n+        int c = *cur++;\n+\n+        if (state != LSTATE_ATTR_VALUE_SQUOTED &&\n+            state != LSTATE_ATTR_VALUE_DQUOTED) {\n+            if (c == '\/' &&\n+                state != LSTATE_BEFORE_ATTR_VALUE &&\n+                state != LSTATE_ATTR_VALUE_UNQUOTED) {\n+                state = LSTATE_BEFORE_ATTR_NAME;\n@@ -5163,0 +4847,4 @@\n+            } else if (c == '>') {\n+                ctxt->checkIndex = 0;\n+                ctxt->endCheckState = 0;\n+                return(0);\n@@ -5165,11 +4853,49 @@\n-        if (buf[base] == first) {\n-            if (third != 0) {\n-                if ((buf[base + 1] != next) || (buf[base + 2] != third))\n-                    continue;\n-            } else if (next != 0) {\n-                if (buf[base + 1] != next)\n-                    continue;\n-            }\n-            ctxt->checkIndex = 0;\n-            ctxt->endCheckState = 0;\n-            return (base);\n+\n+        switch (state) {\n+            case LSTATE_TAG_NAME:\n+                if (IS_WS_HTML(c))\n+                    state = LSTATE_BEFORE_ATTR_NAME;\n+                break;\n+\n+            case LSTATE_BEFORE_ATTR_NAME:\n+                if (!IS_WS_HTML(c))\n+                    state = LSTATE_ATTR_NAME;\n+                break;\n+\n+            case LSTATE_ATTR_NAME:\n+                if (c == '=')\n+                    state = LSTATE_BEFORE_ATTR_VALUE;\n+                else if (IS_WS_HTML(c))\n+                    state = LSTATE_AFTER_ATTR_NAME;\n+                break;\n+\n+            case LSTATE_AFTER_ATTR_NAME:\n+                if (c == '=')\n+                    state = LSTATE_BEFORE_ATTR_VALUE;\n+                else if (!IS_WS_HTML(c))\n+                    state = LSTATE_ATTR_NAME;\n+                break;\n+\n+            case LSTATE_BEFORE_ATTR_VALUE:\n+                if (c == '\"')\n+                    state = LSTATE_ATTR_VALUE_DQUOTED;\n+                else if (c == '\\'')\n+                    state = LSTATE_ATTR_VALUE_SQUOTED;\n+                else if (!IS_WS_HTML(c))\n+                    state = LSTATE_ATTR_VALUE_UNQUOTED;\n+                break;\n+\n+            case LSTATE_ATTR_VALUE_DQUOTED:\n+                if (c == '\"')\n+                    state = LSTATE_BEFORE_ATTR_NAME;\n+                break;\n+\n+            case LSTATE_ATTR_VALUE_SQUOTED:\n+                if (c == '\\'')\n+                    state = LSTATE_BEFORE_ATTR_NAME;\n+                break;\n+\n+            case LSTATE_ATTR_VALUE_UNQUOTED:\n+                if (IS_WS_HTML(c))\n+                    state = LSTATE_BEFORE_ATTR_NAME;\n+                break;\n@@ -5178,3 +4904,64 @@\n-    ctxt->checkIndex = base;\n-    ctxt->endCheckState = quote;\n-    return (-1);\n+\n+    index = cur - ctxt->input->cur;\n+    if (index > LONG_MAX) {\n+        ctxt->checkIndex = 0;\n+        ctxt->endCheckState = 0;\n+        return(0);\n+    }\n+    ctxt->checkIndex = index;\n+    ctxt->endCheckState = state;\n+    return(-1);\n+}\n+\n+\/**\n+ * htmlParseLookupString:\n+ * @ctxt:  an XML parser context\n+ * @startDelta: delta to apply at the start\n+ * @str:  string\n+ * @strLen:  length of string\n+ *\n+ * Check whether the input buffer contains a string.\n+ *\/\n+static int\n+htmlParseLookupString(xmlParserCtxtPtr ctxt, size_t startDelta,\n+                      const char *str, size_t strLen, size_t extraLen) {\n+    const xmlChar *end = ctxt->input->end;\n+    const xmlChar *cur, *term;\n+    size_t index, rescan;\n+    int ret;\n+\n+    if (ctxt->checkIndex == 0) {\n+        cur = ctxt->input->cur + startDelta;\n+    } else {\n+        cur = ctxt->input->cur + ctxt->checkIndex;\n+    }\n+\n+    term = BAD_CAST strstr((const char *) cur, str);\n+    if ((term != NULL) &&\n+        ((size_t) (ctxt->input->end - term) >= extraLen + 1)) {\n+        ctxt->checkIndex = 0;\n+\n+        if (term - ctxt->input->cur > INT_MAX \/ 2)\n+            ret = INT_MAX \/ 2;\n+        else\n+            ret = term - ctxt->input->cur;\n+\n+        return(ret);\n+    }\n+\n+    \/* Rescan (strLen + extraLen - 1) characters. *\/\n+    rescan = strLen + extraLen - 1;\n+    if ((size_t) (end - cur) <= rescan)\n+        end = cur;\n+    else\n+        end -= rescan;\n+    index = end - ctxt->input->cur;\n+    if (index > INT_MAX \/ 2) {\n+        ctxt->checkIndex = 0;\n+        ret = INT_MAX \/ 2;\n+    } else {\n+        ctxt->checkIndex = index;\n+        ret = -1;\n+    }\n+\n+    return(ret);\n@@ -5193,1 +4980,0 @@\n- * This wraps to htmlParseLookupSequence()\n@@ -5204,2 +4990,2 @@\n-    mark = htmlParseLookupSequence(ctxt, '-', '-', 0, 0);\n-    if (mark < 0)\n+        mark = htmlParseLookupString(ctxt, 2, \"--\", 2, 0);\n+        if (mark < 0)\n@@ -5207,0 +4993,6 @@\n+        \/*\n+         * <!-->    is a complete comment, but\n+         * <!--!>   is not\n+         * <!---!>  is not\n+         * <!----!> is\n+         *\/\n@@ -5208,1 +5000,1 @@\n-        ((NXT(mark+2) == '!') && (NXT(mark+3) == '>'))) {\n+            ((mark >= 4) && (NXT(mark+2) == '!') && (NXT(mark+3) == '>'))) {\n@@ -5210,2 +5002,2 @@\n-        break;\n-    }\n+            break;\n+        }\n@@ -5214,1 +5006,1 @@\n-        ctxt->checkIndex = mark;\n+            ctxt->checkIndex = mark;\n@@ -5217,1 +5009,1 @@\n-    ctxt->checkIndex = mark + 1;\n+        ctxt->checkIndex = mark + 1;\n@@ -5232,1 +5024,1 @@\n-static int\n+static void\n@@ -5234,7 +5026,0 @@\n-    int ret = 0;\n-    htmlParserInputPtr in;\n-    ptrdiff_t avail = 0;\n-    xmlChar cur, next;\n-\n-    htmlParserNodeInfo node_info;\n-\n@@ -5242,0 +5027,2 @@\n+        htmlParserInputPtr in;\n+        size_t avail;\n@@ -5243,27 +5030,3 @@\n-    in = ctxt->input;\n-    if (in == NULL) break;\n-    avail = in->end - in->cur;\n-    if ((avail == 0) && (terminate)) {\n-        htmlAutoCloseOnEnd(ctxt);\n-        if ((ctxt->nameNr == 0) && (ctxt->instate != XML_PARSER_EOF)) {\n-        \/*\n-         * SAX: end of the document processing.\n-         *\/\n-        ctxt->instate = XML_PARSER_EOF;\n-        if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n-            ctxt->sax->endDocument(ctxt->userData);\n-        }\n-    }\n-        if (avail < 1)\n-        goto done;\n-        \/*\n-         * This is done to make progress and avoid an infinite loop\n-         * if a parsing attempt was aborted by hitting a NUL byte. After\n-         * changing htmlCurrentChar, this probably isn't necessary anymore.\n-         * We should consider removing this check.\n-         *\/\n-    cur = in->cur[0];\n-    if (cur == 0) {\n-        SKIP(1);\n-        continue;\n-    }\n+        in = ctxt->input;\n+        if (in == NULL) break;\n+        avail = in->end - in->cur;\n@@ -5273,4 +5036,5 @@\n-            \/*\n-         * Document parsing is done !\n-         *\/\n-            goto done;\n+                \/*\n+                 * Document parsing is done !\n+                 *\/\n+                return;\n+\n@@ -5278,0 +5042,12 @@\n+                \/*\n+                 * Very first chars read from the document flow.\n+                 *\/\n+                if ((!terminate) && (avail < 4))\n+                    return;\n+\n+                xmlDetectEncoding(ctxt);\n+\n+                \/*\n+                 * TODO: Implement HTML5 prescan algorithm\n+                 *\/\n+\n@@ -5281,1 +5057,2 @@\n-                 * specify UTF-8.\n+                 * specify UTF-8. The HTML5 prescan algorithm handles\n+                 * XML declarations in a better way.\n@@ -5285,233 +5062,2 @@\n-                    xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_UTF8);\n-                }\n-\n-            \/*\n-         * Very first chars read from the document flow.\n-         *\/\n-        cur = in->cur[0];\n-        if (IS_BLANK_CH(cur)) {\n-            SKIP_BLANKS;\n-                    avail = in->end - in->cur;\n-        }\n-                if ((ctxt->sax) && (ctxt->sax->setDocumentLocator)) {\n-                    ctxt->sax->setDocumentLocator(ctxt->userData,\n-                            (xmlSAXLocator *) &xmlDefaultSAXLocator);\n-                }\n-        if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n-                (!ctxt->disableSAX))\n-            ctxt->sax->startDocument(ctxt->userData);\n-\n-        cur = in->cur[0];\n-        next = in->cur[1];\n-        if ((cur == '<') && (next == '!') &&\n-            (UPP(2) == 'D') && (UPP(3) == 'O') &&\n-            (UPP(4) == 'C') && (UPP(5) == 'T') &&\n-            (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n-            (UPP(8) == 'E')) {\n-            if ((!terminate) &&\n-                (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))\n-            goto done;\n-            htmlParseDocTypeDecl(ctxt);\n-            ctxt->instate = XML_PARSER_PROLOG;\n-                } else {\n-            ctxt->instate = XML_PARSER_MISC;\n-        }\n-        break;\n-            case XML_PARSER_MISC:\n-        SKIP_BLANKS;\n-                avail = in->end - in->cur;\n-        \/*\n-         * no chars in buffer\n-         *\/\n-        if (avail < 1)\n-            goto done;\n-        \/*\n-         * not enough chars in buffer\n-         *\/\n-        if (avail < 2) {\n-            if (!terminate)\n-            goto done;\n-            else\n-            next = ' ';\n-        } else {\n-            next = in->cur[1];\n-        }\n-        cur = in->cur[0];\n-            if ((cur == '<') && (next == '!') &&\n-            (in->cur[2] == '-') && (in->cur[3] == '-')) {\n-            if ((!terminate) && (htmlParseLookupCommentEnd(ctxt) < 0))\n-            goto done;\n-            htmlParseComment(ctxt);\n-            ctxt->instate = XML_PARSER_MISC;\n-            } else if ((cur == '<') && (next == '?')) {\n-            if ((!terminate) &&\n-                (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n-            goto done;\n-            htmlParsePI(ctxt);\n-            ctxt->instate = XML_PARSER_MISC;\n-        } else if ((cur == '<') && (next == '!') &&\n-            (UPP(2) == 'D') && (UPP(3) == 'O') &&\n-            (UPP(4) == 'C') && (UPP(5) == 'T') &&\n-            (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n-            (UPP(8) == 'E')) {\n-            if ((!terminate) &&\n-                (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))\n-            goto done;\n-            htmlParseDocTypeDecl(ctxt);\n-            ctxt->instate = XML_PARSER_PROLOG;\n-        } else if ((cur == '<') && (next == '!') &&\n-                   (avail < 9)) {\n-            goto done;\n-        } else {\n-            ctxt->instate = XML_PARSER_CONTENT;\n-        }\n-        break;\n-            case XML_PARSER_PROLOG:\n-        SKIP_BLANKS;\n-                avail = in->end - in->cur;\n-        if (avail < 2)\n-            goto done;\n-        cur = in->cur[0];\n-        next = in->cur[1];\n-        if ((cur == '<') && (next == '!') &&\n-            (in->cur[2] == '-') && (in->cur[3] == '-')) {\n-            if ((!terminate) && (htmlParseLookupCommentEnd(ctxt) < 0))\n-            goto done;\n-            htmlParseComment(ctxt);\n-            ctxt->instate = XML_PARSER_PROLOG;\n-            } else if ((cur == '<') && (next == '?')) {\n-            if ((!terminate) &&\n-                (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n-            goto done;\n-            htmlParsePI(ctxt);\n-            ctxt->instate = XML_PARSER_PROLOG;\n-        } else if ((cur == '<') && (next == '!') &&\n-                   (avail < 4)) {\n-            goto done;\n-        } else {\n-            ctxt->instate = XML_PARSER_CONTENT;\n-        }\n-        break;\n-            case XML_PARSER_EPILOG:\n-                avail = in->end - in->cur;\n-        if (avail < 1)\n-            goto done;\n-        cur = in->cur[0];\n-        if (IS_BLANK_CH(cur)) {\n-            htmlParseCharData(ctxt);\n-            goto done;\n-        }\n-        if (avail < 2)\n-            goto done;\n-        next = in->cur[1];\n-            if ((cur == '<') && (next == '!') &&\n-            (in->cur[2] == '-') && (in->cur[3] == '-')) {\n-            if ((!terminate) && (htmlParseLookupCommentEnd(ctxt) < 0))\n-            goto done;\n-            htmlParseComment(ctxt);\n-            ctxt->instate = XML_PARSER_EPILOG;\n-            } else if ((cur == '<') && (next == '?')) {\n-            if ((!terminate) &&\n-                (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n-            goto done;\n-            htmlParsePI(ctxt);\n-            ctxt->instate = XML_PARSER_EPILOG;\n-        } else if ((cur == '<') && (next == '!') &&\n-                   (avail < 4)) {\n-            goto done;\n-        } else {\n-            ctxt->errNo = XML_ERR_DOCUMENT_END;\n-            ctxt->wellFormed = 0;\n-            ctxt->instate = XML_PARSER_EOF;\n-            if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n-            ctxt->sax->endDocument(ctxt->userData);\n-            goto done;\n-        }\n-        break;\n-            case XML_PARSER_START_TAG: {\n-            const xmlChar *name;\n-        int failed;\n-        const htmlElemDesc * info;\n-\n-        \/*\n-         * no chars in buffer\n-         *\/\n-        if (avail < 1)\n-            goto done;\n-        \/*\n-         * not enough chars in buffer\n-         *\/\n-        if (avail < 2) {\n-            if (!terminate)\n-            goto done;\n-            else\n-            next = ' ';\n-        } else {\n-            next = in->cur[1];\n-        }\n-        cur = in->cur[0];\n-            if (cur != '<') {\n-            ctxt->instate = XML_PARSER_CONTENT;\n-            break;\n-        }\n-        if (next == '\/') {\n-            ctxt->instate = XML_PARSER_END_TAG;\n-            ctxt->checkIndex = 0;\n-            break;\n-        }\n-        if ((!terminate) &&\n-            (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))\n-            goto done;\n-\n-                \/* Capture start position *\/\n-            if (ctxt->record_info) {\n-                 node_info.begin_pos = ctxt->input->consumed +\n-                                    (CUR_PTR - ctxt->input->base);\n-                 node_info.begin_line = ctxt->input->line;\n-            }\n-\n-\n-        failed = htmlParseStartTag(ctxt);\n-        name = ctxt->name;\n-        if ((failed == -1) ||\n-            (name == NULL)) {\n-            if (CUR == '>')\n-            NEXT;\n-            break;\n-        }\n-\n-        \/*\n-         * Lookup the info for that element.\n-         *\/\n-        info = htmlTagLookup(name);\n-        if (info == NULL) {\n-            htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,\n-                         \"Tag %s invalid\\n\", name, NULL);\n-        }\n-\n-        \/*\n-         * Check for an Empty Element labeled the XML\/SGML way\n-         *\/\n-        if ((CUR == '\/') && (NXT(1) == '>')) {\n-            SKIP(2);\n-            if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n-            ctxt->sax->endElement(ctxt->userData, name);\n-            htmlnamePop(ctxt);\n-            ctxt->instate = XML_PARSER_CONTENT;\n-            break;\n-        }\n-\n-        if (CUR == '>') {\n-            NEXT;\n-        } else {\n-            htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,\n-                         \"Couldn't find end of Start Tag %s\\n\",\n-                 name, NULL);\n-\n-            \/*\n-             * end of parsing of this node.\n-             *\/\n-            if (xmlStrEqual(name, ctxt->name)) {\n-            nodePop(ctxt);\n-            htmlnamePop(ctxt);\n-            }\n+                    xmlSwitchEncoding(ctxt, XML_CHAR_ENCODING_UTF8);\n+                }\n@@ -5519,2 +5065,1 @@\n-            if (ctxt->record_info)\n-                htmlNodeInfoPush(ctxt, &node_info);\n+                \/* fall through *\/\n@@ -5522,3 +5067,14 @@\n-            ctxt->instate = XML_PARSER_CONTENT;\n-            break;\n-        }\n+            case XML_PARSER_XML_DECL:\n+                if ((ctxt->sax) && (ctxt->sax->setDocumentLocator)) {\n+                    ctxt->sax->setDocumentLocator(ctxt->userData,\n+                            (xmlSAXLocator *) &xmlDefaultSAXLocator);\n+                }\n+                if ((ctxt->sax) && (ctxt->sax->startDocument) &&\n+                    (!ctxt->disableSAX))\n+                    ctxt->sax->startDocument(ctxt->userData);\n+\n+                \/* Allow callback to modify state for tests *\/\n+                if ((ctxt->instate == XML_PARSER_START) ||\n+                    (ctxt->instate == XML_PARSER_XML_DECL))\n+                    ctxt->instate = XML_PARSER_MISC;\n+                break;\n@@ -5526,8 +5082,4 @@\n-        \/*\n-         * Check for an Empty Element from DTD definition\n-         *\/\n-        if ((info != NULL) && (info->empty)) {\n-            if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))\n-            ctxt->sax->endElement(ctxt->userData, name);\n-            htmlnamePop(ctxt);\n-        }\n+            case XML_PARSER_START_TAG:\n+                if ((!terminate) &&\n+                    (htmlParseLookupGt(ctxt) < 0))\n+                    return;\n@@ -5535,2 +5087,1 @@\n-                if (ctxt->record_info)\n-                htmlNodeInfoPush(ctxt, &node_info);\n+                htmlParseElementInternal(ctxt);\n@@ -5538,1 +5089,1 @@\n-        ctxt->instate = XML_PARSER_CONTENT;\n+                ctxt->instate = XML_PARSER_CONTENT;\n@@ -5540,1 +5091,3 @@\n-        }\n+\n+            case XML_PARSER_MISC: \/* initial *\/\n+            case XML_PARSER_PROLOG: \/* before html *\/\n@@ -5542,1 +5095,1 @@\n-        xmlChar chr[2] = { 0, 0 };\n+                int mode;\n@@ -5544,23 +5097,4 @@\n-                \/*\n-         * Handle preparsed entities and charRef\n-         *\/\n-        if ((avail == 1) && (terminate)) {\n-            cur = in->cur[0];\n-            if ((cur != '<') && (cur != '&')) {\n-            if (ctxt->sax != NULL) {\n-                            chr[0] = cur;\n-                if (IS_BLANK_CH(cur)) {\n-                if (ctxt->keepBlanks) {\n-                    if (ctxt->sax->characters != NULL)\n-                    ctxt->sax->characters(\n-                        ctxt->userData, chr, 1);\n-                } else {\n-                    if (ctxt->sax->ignorableWhitespace != NULL)\n-                    ctxt->sax->ignorableWhitespace(\n-                        ctxt->userData, chr, 1);\n-                }\n-                } else {\n-                htmlCheckParagraph(ctxt);\n-                if (ctxt->sax->characters != NULL)\n-                    ctxt->sax->characters(\n-                        ctxt->userData, chr, 1);\n+                if ((ctxt->instate == XML_PARSER_MISC) ||\n+                    (ctxt->instate == XML_PARSER_PROLOG)) {\n+                    SKIP_BLANKS;\n+                    avail = in->end - in->cur;\n@@ -5568,18 +5102,0 @@\n-            }\n-            ctxt->checkIndex = 0;\n-            in->cur++;\n-            break;\n-            }\n-        }\n-        if (avail < 2)\n-            goto done;\n-        cur = in->cur[0];\n-        next = in->cur[1];\n-        if ((xmlStrEqual(ctxt->name, BAD_CAST\"script\")) ||\n-            (xmlStrEqual(ctxt->name, BAD_CAST\"style\"))) {\n-            \/*\n-             * Handle SCRIPT\/STYLE separately\n-             *\/\n-            if (!terminate) {\n-                int idx;\n-            xmlChar val;\n@@ -5587,11 +5103,33 @@\n-            idx = htmlParseLookupSequence(ctxt, '<', '\/', 0, 0);\n-            if (idx < 0)\n-                goto done;\n-                val = in->cur[idx + 2];\n-            if (val == 0) { \/* bad cut of input *\/\n-                            \/*\n-                             * FIXME: htmlParseScript checks for additional\n-                             * characters after '<\/'.\n-                             *\/\n-                            ctxt->checkIndex = idx;\n-                goto done;\n+                if (avail < 1)\n+                    return;\n+                \/*\n+                 * Note that endCheckState is also used by\n+                 * xmlParseLookupGt.\n+                 *\/\n+                mode = ctxt->endCheckState;\n+\n+                if (mode != 0) {\n+                    if (htmlParseCharData(ctxt, !terminate) == 0)\n+                        return;\n+                } else if (in->cur[0] == '<') {\n+                    int next;\n+\n+                    if (avail < 2) {\n+                        if (!terminate)\n+                            return;\n+                        next = ' ';\n+                    } else {\n+                        next = in->cur[1];\n+                    }\n+\n+                    if (next == '!') {\n+                        if ((!terminate) && (avail < 4))\n+                            return;\n+                        if ((in->cur[2] == '-') && (in->cur[3] == '-')) {\n+                            if ((!terminate) &&\n+                                (htmlParseLookupCommentEnd(ctxt) < 0))\n+                                return;\n+                            SKIP(4);\n+                            htmlParseComment(ctxt, \/* bogus *\/ 0);\n+                            \/* don't change state *\/\n+                            break;\n@@ -5599,25 +5137,25 @@\n-            }\n-            htmlParseScript(ctxt);\n-            if ((cur == '<') && (next == '\/')) {\n-            ctxt->instate = XML_PARSER_END_TAG;\n-            ctxt->checkIndex = 0;\n-            break;\n-            }\n-        } else if ((cur == '<') && (next == '!')) {\n-                    if (avail < 4)\n-                        goto done;\n-                    \/*\n-                     * Sometimes DOCTYPE arrives in the middle of the document\n-                     *\/\n-                    if ((UPP(2) == 'D') && (UPP(3) == 'O') &&\n-                        (UPP(4) == 'C') && (UPP(5) == 'T') &&\n-                        (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n-                        (UPP(8) == 'E')) {\n-                        if ((!terminate) &&\n-                            (htmlParseLookupSequence(ctxt, '>', 0, 0, 1) < 0))\n-                            goto done;\n-                        htmlParseErr(ctxt, XML_HTML_STRUCURE_ERROR,\n-                                     \"Misplaced DOCTYPE declaration\\n\",\n-                                     BAD_CAST \"DOCTYPE\" , NULL);\n-                        htmlParseDocTypeDecl(ctxt);\n-                    } else if ((in->cur[2] == '-') && (in->cur[3] == '-')) {\n+\n+                        if ((!terminate) && (avail < 9))\n+                            return;\n+                        if ((UPP(2) == 'D') && (UPP(3) == 'O') &&\n+                            (UPP(4) == 'C') && (UPP(5) == 'T') &&\n+                            (UPP(6) == 'Y') && (UPP(7) == 'P') &&\n+                            (UPP(8) == 'E')) {\n+                            if ((!terminate) &&\n+                                (htmlParseLookupString(ctxt, 9, \">\", 1,\n+                                                       0) < 0))\n+                                return;\n+                            htmlParseDocTypeDecl(ctxt);\n+                            if (ctxt->instate == XML_PARSER_MISC)\n+                                ctxt->instate = XML_PARSER_PROLOG;\n+                            else\n+                                ctxt->instate = XML_PARSER_CONTENT;\n+                        } else {\n+                            ctxt->instate = XML_PARSER_CONTENT;\n+                            if ((!terminate) &&\n+                                (htmlParseLookupString(ctxt, 2, \">\", 1, 0) < 0))\n+                                return;\n+                            SKIP(2);\n+                            htmlParseComment(ctxt, \/* bogus *\/ 1);\n+                        }\n+                    } else if (next == '?') {\n@@ -5625,4 +5163,11 @@\n-                            (htmlParseLookupCommentEnd(ctxt) < 0))\n-                            goto done;\n-                        htmlParseComment(ctxt);\n-                        ctxt->instate = XML_PARSER_CONTENT;\n+                            (htmlParseLookupString(ctxt, 2, \">\", 1, 0) < 0))\n+                            return;\n+                        SKIP(1);\n+                        htmlParseComment(ctxt, \/* bogus *\/ 1);\n+                        \/* don't change state *\/\n+                    } else if (next == '\/') {\n+                        ctxt->instate = XML_PARSER_END_TAG;\n+                        ctxt->checkIndex = 0;\n+                    } else if (IS_ASCII_LETTER(next)) {\n+                        ctxt->instate = XML_PARSER_START_TAG;\n+                        ctxt->checkIndex = 0;\n@@ -5630,4 +5175,7 @@\n-                        if ((!terminate) &&\n-                            (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n-                            goto done;\n-                        htmlSkipBogusComment(ctxt);\n+                        ctxt->instate = XML_PARSER_CONTENT;\n+                        htmlStartCharData(ctxt);\n+                        if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                            (ctxt->sax->characters != NULL))\n+                            ctxt->sax->characters(ctxt->userData,\n+                                                  BAD_CAST \"<\", 1);\n+                        SKIP(1);\n@@ -5635,22 +5183,0 @@\n-                } else if ((cur == '<') && (next == '?')) {\n-                    if ((!terminate) &&\n-                        (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n-                        goto done;\n-                    htmlParsePI(ctxt);\n-                    ctxt->instate = XML_PARSER_CONTENT;\n-                } else if ((cur == '<') && (next == '\/')) {\n-                    ctxt->instate = XML_PARSER_END_TAG;\n-                    ctxt->checkIndex = 0;\n-                    break;\n-                } else if ((cur == '<') && IS_ASCII_LETTER(next)) {\n-                    if ((!terminate) && (next == 0))\n-                        goto done;\n-                    ctxt->instate = XML_PARSER_START_TAG;\n-                    ctxt->checkIndex = 0;\n-                    break;\n-                } else if (cur == '<') {\n-                    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-                        (ctxt->sax->characters != NULL))\n-                        ctxt->sax->characters(ctxt->userData,\n-                                              BAD_CAST \"<\", 1);\n-                    NEXT;\n@@ -5658,0 +5184,1 @@\n+                    ctxt->instate = XML_PARSER_CONTENT;\n@@ -5659,4 +5186,1 @@\n-                     * check that the text sequence is complete\n-                     * before handing out the data to the parser\n-                     * to avoid problems with erroneous end of\n-                     * data detection.\n+                     * We follow the logic of the XML push parser\n@@ -5664,12 +5188,4 @@\n-                    if ((!terminate) &&\n-                        (htmlParseLookupSequence(ctxt, '<', 0, 0, 0) < 0))\n-                        goto done;\n-                    ctxt->checkIndex = 0;\n-                    while ((PARSER_STOPPED(ctxt) == 0) &&\n-                           (cur != '<') && (in->cur < in->end)) {\n-                        if (cur == '&') {\n-                            htmlParseReference(ctxt);\n-                        } else {\n-                            htmlParseCharData(ctxt);\n-                        }\n-                        cur = in->cur[0];\n+                    if (avail < HTML_PARSER_BIG_BUFFER_SIZE) {\n+                        if ((!terminate) &&\n+                            (htmlParseLookupString(ctxt, 0, \"<\", 1, 0) < 0))\n+                            return;\n@@ -5677,1 +5193,7 @@\n-        }\n+                    ctxt->checkIndex = 0;\n+                    if (htmlParseCharData(ctxt, !terminate) == 0)\n+                        return;\n+                }\n+\n+                break;\n+            }\n@@ -5679,2 +5201,0 @@\n-        break;\n-        }\n@@ -5682,44 +5202,13 @@\n-        if (avail < 2)\n-            goto done;\n-        if ((!terminate) &&\n-            (htmlParseLookupSequence(ctxt, '>', 0, 0, 0) < 0))\n-            goto done;\n-        htmlParseEndTag(ctxt);\n-        if (ctxt->nameNr == 0) {\n-            ctxt->instate = XML_PARSER_EPILOG;\n-        } else {\n-            ctxt->instate = XML_PARSER_CONTENT;\n-        }\n-        ctxt->checkIndex = 0;\n-            break;\n-        default:\n-        htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n-                 \"HPP: internal error\\n\", NULL, NULL);\n-        ctxt->instate = XML_PARSER_EOF;\n-        break;\n-    }\n-    }\n-done:\n-    if ((avail == 0) && (terminate)) {\n-    htmlAutoCloseOnEnd(ctxt);\n-    if ((ctxt->nameNr == 0) && (ctxt->instate != XML_PARSER_EOF)) {\n-        \/*\n-         * SAX: end of the document processing.\n-         *\/\n-        ctxt->instate = XML_PARSER_EOF;\n-        if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n-        ctxt->sax->endDocument(ctxt->userData);\n-    }\n-    }\n-    if ((!(ctxt->options & HTML_PARSE_NODEFDTD)) && (ctxt->myDoc != NULL) &&\n-    ((terminate) || (ctxt->instate == XML_PARSER_EOF) ||\n-     (ctxt->instate == XML_PARSER_EPILOG))) {\n-    xmlDtdPtr dtd;\n-    dtd = xmlGetIntSubset(ctxt->myDoc);\n-    if (dtd == NULL) {\n-        ctxt->myDoc->intSubset =\n-        xmlCreateIntSubset(ctxt->myDoc, BAD_CAST \"html\",\n-            BAD_CAST \"-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\",\n-            BAD_CAST \"http:\/\/www.w3.org\/TR\/REC-html40\/loose.dtd\");\n-            if (ctxt->myDoc->intSubset == NULL)\n-                htmlErrMemory(ctxt);\n+                if ((!terminate) &&\n+                    (htmlParseLookupGt(ctxt) < 0))\n+                    return;\n+                htmlParseEndTag(ctxt);\n+                ctxt->instate = XML_PARSER_CONTENT;\n+                ctxt->checkIndex = 0;\n+                break;\n+\n+            default:\n+                htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,\n+                             \"HPP: internal error\\n\", NULL, NULL);\n+                ctxt->instate = XML_PARSER_EOF;\n+                break;\n@@ -5728,1 +5217,0 @@\n-    return(ret);\n@@ -5755,2 +5243,5 @@\n-    if ((ctxt == NULL) || (ctxt->input == NULL))\n-    return(XML_ERR_ARGUMENT);\n+    if ((ctxt == NULL) ||\n+        (ctxt->input == NULL) || (ctxt->input->buf == NULL) ||\n+        (size < 0) ||\n+        ((size > 0) && (chunk == NULL)))\n+        return(XML_ERR_ARGUMENT);\n@@ -5759,4 +5250,0 @@\n-    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n-        (ctxt->input->buf != NULL))  {\n-    size_t pos = ctxt->input->cur - ctxt->input->base;\n-    int res;\n@@ -5764,1 +5251,5 @@\n-    res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n+    if (size > 0)  {\n+        size_t pos = ctxt->input->cur - ctxt->input->base;\n+        int res;\n+\n+        res = xmlParserInputBufferPush(ctxt->input->buf, size, chunk);\n@@ -5766,1 +5257,1 @@\n-    if (res < 0) {\n+        if (res < 0) {\n@@ -5770,2 +5261,2 @@\n-        return (ctxt->errNo);\n-    }\n+            return (ctxt->errNo);\n+        }\n@@ -5773,0 +5264,1 @@\n+\n@@ -5774,2 +5266,9 @@\n-    if (terminate) {\n-    if (ctxt->instate != XML_PARSER_EOF) {\n+\n+    if ((terminate) && (ctxt->instate != XML_PARSER_EOF)) {\n+        htmlAutoCloseOnEnd(ctxt);\n+\n+        \/*\n+         * Only check for truncated multi-byte sequences\n+         *\/\n+        xmlParserCheckEOF(ctxt, XML_ERR_INTERNAL_ERROR);\n+\n@@ -5777,3 +5276,17 @@\n-        ctxt->sax->endDocument(ctxt->userData);\n-    }\n-    ctxt->instate = XML_PARSER_EOF;\n+            ctxt->sax->endDocument(ctxt->userData);\n+\n+        if ((!(ctxt->options & HTML_PARSE_NODEFDTD)) &&\n+            (ctxt->myDoc != NULL)) {\n+            xmlDtdPtr dtd;\n+            dtd = xmlGetIntSubset(ctxt->myDoc);\n+            if (dtd == NULL) {\n+                ctxt->myDoc->intSubset =\n+                    xmlCreateIntSubset(ctxt->myDoc, BAD_CAST \"html\",\n+                        BAD_CAST \"-\/\/W3C\/\/DTD HTML 4.0 Transitional\/\/EN\",\n+                        BAD_CAST \"http:\/\/www.w3.org\/TR\/REC-html40\/loose.dtd\");\n+                if (ctxt->myDoc->intSubset == NULL)\n+                    htmlErrMemory(ctxt);\n+            }\n+        }\n+\n+        ctxt->instate = XML_PARSER_EOF;\n@@ -5781,0 +5294,1 @@\n+\n@@ -5785,3 +5299,3 @@\n- *                                    *\n- *            User entry points                *\n- *                                    *\n+ *                                                                      *\n+ *                      User entry points                               *\n+ *                                                                      *\n@@ -5807,1 +5321,1 @@\n-             xmlCharEncoding enc) {\n+                         xmlCharEncoding enc) {\n@@ -5814,1 +5328,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5817,1 +5331,1 @@\n-    input = xmlNewInputPush(ctxt, filename, chunk, size, encoding);\n+    input = xmlNewPushInput(filename, chunk, size);\n@@ -5819,2 +5333,2 @@\n-    htmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        htmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -5822,1 +5336,9 @@\n-    inputPush(ctxt, input);\n+\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n+        xmlFreeInputStream(input);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n+    }\n+\n+    if (encoding != NULL)\n+        xmlSwitchEncodingName(ctxt, encoding);\n@@ -5917,1 +5439,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5920,1 +5442,1 @@\n-    input = xmlNewInputURL(ctxt, filename, NULL, encoding, 0);\n+    input = xmlCtxtNewInputFromUrl(ctxt, filename, NULL, encoding, 0);\n@@ -5922,2 +5444,7 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n+    }\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n+        xmlFreeInputStream(input);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -5925,1 +5452,0 @@\n-    inputPush(ctxt, input);\n@@ -5958,1 +5484,1 @@\n-    oldsax = ctxt->sax;\n+        oldsax = ctxt->sax;\n@@ -5982,2 +5508,0 @@\n- * See xmlNewInputURL for details.\n- *\n@@ -6016,2 +5540,1 @@\n- * Checks whether an HTML element may be a direct child of a parent element.\n- * Note - doesn't check for deprecated elements\n+ * DEPRECATED: Don't use.\n@@ -6019,1 +5542,1 @@\n- * Returns 1 if allowed; 0 otherwise.\n+ * Returns 1\n@@ -6022,11 +5545,3 @@\n-htmlElementAllowedHere(const htmlElemDesc* parent, const xmlChar* elt) {\n-  const char** p ;\n-\n-  if ( ! elt || ! parent || ! parent->subelts )\n-    return 0 ;\n-\n-  for ( p = parent->subelts; *p; ++p )\n-    if ( !xmlStrcmp((const xmlChar *)*p, elt) )\n-      return 1 ;\n-\n-  return 0 ;\n+htmlElementAllowedHere(const htmlElemDesc* parent ATTRIBUTE_UNUSED,\n+                       const xmlChar* elt ATTRIBUTE_UNUSED) {\n+    return(1);\n@@ -6034,0 +5549,1 @@\n+\n@@ -6039,2 +5555,1 @@\n- * Checks whether an HTML element may be a direct child of a parent element.\n- * and if so whether it is valid or deprecated.\n+ * DEPRECATED: Don't use.\n@@ -6042,1 +5557,1 @@\n- * Returns one of HTML_VALID, HTML_DEPRECATED, HTML_INVALID\n+ * Returns HTML_VALID\n@@ -6045,7 +5560,3 @@\n-htmlElementStatusHere(const htmlElemDesc* parent, const htmlElemDesc* elt) {\n-  if ( ! parent || ! elt )\n-    return HTML_INVALID ;\n-  if ( ! htmlElementAllowedHere(parent, (const xmlChar*) elt->name ) )\n-    return HTML_INVALID ;\n-\n-  return ( elt->dtd == 0 ) ? HTML_VALID : HTML_DEPRECATED ;\n+htmlElementStatusHere(const htmlElemDesc* parent ATTRIBUTE_UNUSED,\n+                      const htmlElemDesc* elt ATTRIBUTE_UNUSED) {\n+    return(HTML_VALID);\n@@ -6053,0 +5564,1 @@\n+\n@@ -6059,2 +5571,1 @@\n- * Checks whether an attribute is valid for an element\n- * Has full knowledge of Required and Deprecated attributes\n+ * DEPRECATED: Don't use.\n@@ -6062,1 +5573,1 @@\n- * Returns one of HTML_REQUIRED, HTML_VALID, HTML_DEPRECATED, HTML_INVALID\n+ * Returns HTML_VALID\n@@ -6065,22 +5576,4 @@\n-htmlAttrAllowed(const htmlElemDesc* elt, const xmlChar* attr, int legacy) {\n-  const char** p ;\n-\n-  if ( !elt || ! attr )\n-    return HTML_INVALID ;\n-\n-  if ( elt->attrs_req )\n-    for ( p = elt->attrs_req; *p; ++p)\n-      if ( !xmlStrcmp((const xmlChar*)*p, attr) )\n-        return HTML_REQUIRED ;\n-\n-  if ( elt->attrs_opt )\n-    for ( p = elt->attrs_opt; *p; ++p)\n-      if ( !xmlStrcmp((const xmlChar*)*p, attr) )\n-        return HTML_VALID ;\n-\n-  if ( legacy && elt->attrs_depr )\n-    for ( p = elt->attrs_depr; *p; ++p)\n-      if ( !xmlStrcmp((const xmlChar*)*p, attr) )\n-        return HTML_DEPRECATED ;\n-\n-  return HTML_INVALID ;\n+htmlAttrAllowed(const htmlElemDesc* elt ATTRIBUTE_UNUSED,\n+                const xmlChar* attr ATTRIBUTE_UNUSED,\n+                int legacy ATTRIBUTE_UNUSED) {\n+    return(HTML_VALID);\n@@ -6088,0 +5581,1 @@\n+\n@@ -6092,1 +5586,1 @@\n- *    for Element nodes)\n+ *      for Element nodes)\n@@ -6094,2 +5588,1 @@\n- * Checks whether the tree node is valid.  Experimental (the author\n- *     only uses the HTML enhancements in a SAX parser)\n+ * DEPRECATED: Don't use.\n@@ -6097,4 +5590,1 @@\n- * Return: for Element nodes, a return from htmlElementAllowedHere (if\n- *    legacy allowed) or htmlElementStatusHere (otherwise).\n- *    for Attribute nodes, a return from htmlAttrAllowed\n- *    for other nodes, HTML_NA (no checks performed)\n+ * Returns HTML_VALID\n@@ -6103,19 +5593,3 @@\n-htmlNodeStatus(htmlNodePtr node, int legacy) {\n-  if ( ! node )\n-    return HTML_INVALID ;\n-\n-  switch ( node->type ) {\n-    case XML_ELEMENT_NODE:\n-      return legacy\n-    ? ( htmlElementAllowedHere (\n-        htmlTagLookup(node->parent->name) , node->name\n-        ) ? HTML_VALID : HTML_INVALID )\n-    : htmlElementStatusHere(\n-        htmlTagLookup(node->parent->name) ,\n-        htmlTagLookup(node->name) )\n-    ;\n-    case XML_ATTRIBUTE_NODE:\n-      return htmlAttrAllowed(\n-    htmlTagLookup(node->parent->name) , node->name, legacy) ;\n-    default: return HTML_NA ;\n-  }\n+htmlNodeStatus(htmlNodePtr node ATTRIBUTE_UNUSED,\n+               int legacy ATTRIBUTE_UNUSED) {\n+    return(HTML_VALID);\n@@ -6123,0 +5597,1 @@\n+\n@@ -6124,3 +5599,3 @@\n- *                                    *\n- *    New set (2.6.0) of simpler and more flexible APIs        *\n- *                                    *\n+ *                                                                      *\n+ *      New set (2.6.0) of simpler and more flexible APIs               *\n+ *                                                                      *\n@@ -6135,4 +5610,4 @@\n-#define DICT_FREE(str)                        \\\n-    if ((str) && ((!dict) ||                \\\n-        (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))    \\\n-        xmlFree((char *)(str));\n+#define DICT_FREE(str)                                          \\\n+        if ((str) && ((!dict) ||                                \\\n+            (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n+            xmlFree((char *)(str));\n@@ -6157,1 +5632,1 @@\n-    while ((input = inputPop(ctxt)) != NULL) { \/* Non consuming *\/\n+    while ((input = xmlCtxtPopInput(ctxt)) != NULL) { \/* Non consuming *\/\n@@ -6165,2 +5640,2 @@\n-    ctxt->spaceTab[0] = -1;\n-    ctxt->space = &ctxt->spaceTab[0];\n+        ctxt->spaceTab[0] = -1;\n+        ctxt->space = &ctxt->spaceTab[0];\n@@ -6168,1 +5643,1 @@\n-    ctxt->space = NULL;\n+        ctxt->space = NULL;\n@@ -6201,1 +5676,1 @@\n-    ctxt->html = 1;\n+    ctxt->html = INSERT_INITIAL;\n@@ -6236,0 +5711,162 @@\n+static int\n+htmlCtxtSetOptionsInternal(xmlParserCtxtPtr ctxt, int options, int keepMask)\n+{\n+    int allMask;\n+\n+    if (ctxt == NULL)\n+        return(-1);\n+\n+    allMask = HTML_PARSE_RECOVER |\n+              HTML_PARSE_HTML5 |\n+              HTML_PARSE_NODEFDTD |\n+              HTML_PARSE_NOERROR |\n+              HTML_PARSE_NOWARNING |\n+              HTML_PARSE_PEDANTIC |\n+              HTML_PARSE_NOBLANKS |\n+              HTML_PARSE_NONET |\n+              HTML_PARSE_NOIMPLIED |\n+              HTML_PARSE_COMPACT |\n+              HTML_PARSE_HUGE |\n+              HTML_PARSE_IGNORE_ENC |\n+              HTML_PARSE_BIG_LINES;\n+\n+    ctxt->options = (ctxt->options & keepMask) | (options & allMask);\n+\n+    \/*\n+     * For some options, struct members are historically the source\n+     * of truth. See xmlCtxtSetOptionsInternal.\n+     *\/\n+    ctxt->keepBlanks = (options & HTML_PARSE_NOBLANKS) ? 0 : 1;\n+\n+    \/*\n+     * Recover from character encoding errors\n+     *\/\n+    ctxt->recovery = 1;\n+\n+    \/*\n+     * Changing SAX callbacks is a bad idea. This should be fixed.\n+     *\/\n+    if (options & HTML_PARSE_NOBLANKS) {\n+        ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;\n+    }\n+    if (options & HTML_PARSE_HUGE) {\n+        if (ctxt->dict != NULL)\n+            xmlDictSetLimit(ctxt->dict, 0);\n+    }\n+\n+    \/*\n+     * It would be useful to allow this feature.\n+     *\/\n+    ctxt->dictNames = 0;\n+\n+    ctxt->linenumbers = 1;\n+\n+    \/*\n+     * Allow XML_PARSE_NOENT which many users set on the HTML parser.\n+     *\/\n+    return(options & ~allMask & ~XML_PARSE_NOENT);\n+}\n+\n+\/**\n+ * htmlCtxtSetOptions:\n+ * @ctxt: an HTML parser context\n+ * @options:  a bitmask of xmlParserOption values\n+ *\n+ * Applies the options to the parser context. Unset options are\n+ * cleared.\n+ *\n+ * Available since 2.14.0. With older versions, you can use\n+ * htmlCtxtUseOptions.\n+ *\n+ * HTML_PARSE_RECOVER\n+ *\n+ * No effect as of 2.14.0.\n+ *\n+ * HTML_PARSE_HTML5\n+ *\n+ * Make the tokenizer emit a SAX callback for each token. This results\n+ * in unbalanced invocations of startElement and endElement.\n+ *\n+ * For now, this is only usable with custom SAX callbacks.\n+ *\n+ * HTML_PARSE_NODEFDTD\n+ *\n+ * Do not default to a doctype if none was found.\n+ *\n+ * HTML_PARSE_NOERROR\n+ *\n+ * Disable error and warning reports to the error handlers.\n+ * Errors are still accessible with xmlCtxtGetLastError.\n+ *\n+ * HTML_PARSE_NOWARNING\n+ *\n+ * Disable warning reports.\n+ *\n+ * HTML_PARSE_PEDANTIC\n+ *\n+ * No effect.\n+ *\n+ * HTML_PARSE_NOBLANKS\n+ *\n+ * Remove some text nodes containing only whitespace from the\n+ * result document. Which nodes are removed depends on a conservative\n+ * heuristic. The reindenting feature of the serialization code relies\n+ * on this option to be set when parsing. Use of this option is\n+ * DISCOURAGED.\n+ *\n+ * HTML_PARSE_NONET\n+ *\n+ * No effect.\n+ *\n+ * HTML_PARSE_NOIMPLIED\n+ *\n+ * Do not add implied html, head or body elements.\n+ *\n+ * HTML_PARSE_COMPACT\n+ *\n+ * Store small strings directly in the node struct to save\n+ * memory.\n+ *\n+ * HTML_PARSE_HUGE\n+ *\n+ * Relax some internal limits.\n+ *\n+ * Available since 2.14.0. Use XML_PARSE_HUGE works with older\n+ * versions.\n+ *\n+ * Maximum size of text nodes, tags, comments, CDATA sections\n+ *\n+ * normal: 10M\n+ * huge:    1B\n+ *\n+ * Maximum size of names, system literals, pubid literals\n+ *\n+ * normal: 50K\n+ * huge:   10M\n+ *\n+ * Maximum nesting depth of elements\n+ *\n+ * normal:  256\n+ * huge:   2048\n+ *\n+ * HTML_PARSE_IGNORE_ENC\n+ *\n+ * Ignore the encoding in the HTML declaration. This option is\n+ * mostly unneeded these days. The only effect is to enforce\n+ * UTF-8 decoding of ASCII-like data.\n+ *\n+ * HTML_PARSE_BIG_LINES\n+ *\n+ * Enable reporting of line numbers larger than 65535.\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns 0 in case of success, the set of unknown or unimplemented options\n+ *         in case of error.\n+ *\/\n+int\n+htmlCtxtSetOptions(xmlParserCtxtPtr ctxt, int options)\n+{\n+    return(htmlCtxtSetOptionsInternal(ctxt, options, 0));\n+}\n+\n@@ -6241,1 +5878,13 @@\n- * Applies the options to the parser context\n+ * DEPRECATED: Use htmlCtxtSetOptions.\n+ *\n+ * Applies the options to the parser context. The following options\n+ * are never cleared and can only be enabled:\n+ *\n+ * HTML_PARSE_NODEFDTD\n+ * HTML_PARSE_NOERROR\n+ * HTML_PARSE_NOWARNING\n+ * HTML_PARSE_NOIMPLIED\n+ * HTML_PARSE_COMPACT\n+ * HTML_PARSE_HUGE\n+ * HTML_PARSE_IGNORE_ENC\n+ * HTML_PARSE_BIG_LINES\n@@ -6249,2 +5898,1 @@\n-    if (ctxt == NULL)\n-        return(-1);\n+    int keepMask;\n@@ -6252,54 +5900,13 @@\n-    if (options & HTML_PARSE_NOWARNING) {\n-        ctxt->sax->warning = NULL;\n-        ctxt->vctxt.warning = NULL;\n-        options -= XML_PARSE_NOWARNING;\n-    ctxt->options |= XML_PARSE_NOWARNING;\n-    }\n-    if (options & HTML_PARSE_NOERROR) {\n-        ctxt->sax->error = NULL;\n-        ctxt->vctxt.error = NULL;\n-        ctxt->sax->fatalError = NULL;\n-        options -= XML_PARSE_NOERROR;\n-    ctxt->options |= XML_PARSE_NOERROR;\n-    }\n-    if (options & HTML_PARSE_PEDANTIC) {\n-        ctxt->pedantic = 1;\n-        options -= XML_PARSE_PEDANTIC;\n-    ctxt->options |= XML_PARSE_PEDANTIC;\n-    } else\n-        ctxt->pedantic = 0;\n-    if (options & XML_PARSE_NOBLANKS) {\n-        ctxt->keepBlanks = 0;\n-        ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;\n-        options -= XML_PARSE_NOBLANKS;\n-    ctxt->options |= XML_PARSE_NOBLANKS;\n-    } else\n-        ctxt->keepBlanks = 1;\n-    if (options & HTML_PARSE_RECOVER) {\n-        ctxt->recovery = 1;\n-    options -= HTML_PARSE_RECOVER;\n-    } else\n-        ctxt->recovery = 0;\n-    if (options & HTML_PARSE_COMPACT) {\n-    ctxt->options |= HTML_PARSE_COMPACT;\n-        options -= HTML_PARSE_COMPACT;\n-    }\n-    if (options & XML_PARSE_HUGE) {\n-    ctxt->options |= XML_PARSE_HUGE;\n-        options -= XML_PARSE_HUGE;\n-    }\n-    if (options & HTML_PARSE_NODEFDTD) {\n-    ctxt->options |= HTML_PARSE_NODEFDTD;\n-        options -= HTML_PARSE_NODEFDTD;\n-    }\n-    if (options & HTML_PARSE_IGNORE_ENC) {\n-    ctxt->options |= HTML_PARSE_IGNORE_ENC;\n-        options -= HTML_PARSE_IGNORE_ENC;\n-    }\n-    if (options & HTML_PARSE_NOIMPLIED) {\n-        ctxt->options |= HTML_PARSE_NOIMPLIED;\n-        options -= HTML_PARSE_NOIMPLIED;\n-    }\n-    ctxt->dictNames = 0;\n-    ctxt->linenumbers = 1;\n-    return (options);\n+    \/*\n+     * For historic reasons, some options can only be enabled.\n+     *\/\n+    keepMask = HTML_PARSE_NODEFDTD |\n+               HTML_PARSE_NOERROR |\n+               HTML_PARSE_NOWARNING |\n+               HTML_PARSE_NOIMPLIED |\n+               HTML_PARSE_COMPACT |\n+               HTML_PARSE_HUGE |\n+               HTML_PARSE_IGNORE_ENC |\n+               HTML_PARSE_BIG_LINES;\n+\n+    return(htmlCtxtSetOptionsInternal(ctxt, options, keepMask));\n@@ -6324,1 +5931,3 @@\n-    if ((ctxt == NULL) || (input == NULL))\n+    if ((ctxt == NULL) || (input == NULL)) {\n+        xmlFatalErr(ctxt, XML_ERR_ARGUMENT, NULL);\n+        xmlFreeInputStream(input);\n@@ -6326,0 +5935,1 @@\n+    }\n@@ -6329,1 +5939,1 @@\n-        xmlFreeInputStream(inputPop(ctxt));\n+        xmlFreeInputStream(xmlCtxtPopInput(ctxt));\n@@ -6331,1 +5941,1 @@\n-    if (inputPush(ctxt, input) < 0) {\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n@@ -6336,1 +5946,1 @@\n-    ctxt->html = 1;\n+    ctxt->html = INSERT_INITIAL;\n@@ -6339,7 +5949,1 @@\n-    if (ctxt->errNo != XML_ERR_NO_MEMORY) {\n-        ret = ctxt->myDoc;\n-    } else {\n-        ret = NULL;\n-        xmlFreeDoc(ctxt->myDoc);\n-    }\n-    ctxt->myDoc = NULL;\n+    ret = xmlCtxtGetDocument(ctxt);\n@@ -6349,1 +5953,1 @@\n-        xmlFreeInputStream(inputPop(ctxt));\n+        xmlFreeInputStream(xmlCtxtPopInput(ctxt));\n@@ -6374,1 +5978,1 @@\n-    htmlDocPtr doc;\n+    htmlDocPtr doc = NULL;\n@@ -6382,2 +5986,2 @@\n-    input = xmlNewInputString(ctxt, url, (const char *) str, encoding,\n-                              XML_INPUT_BUF_STATIC);\n+    input = xmlCtxtNewInputFromString(ctxt, url, (const char *) str, encoding,\n+                                      XML_INPUT_BUF_STATIC);\n@@ -6385,1 +5989,2 @@\n-    doc = htmlCtxtParseDocument(ctxt, input);\n+    if (input != NULL)\n+        doc = htmlCtxtParseDocument(ctxt, input);\n@@ -6409,1 +6014,1 @@\n-    htmlDocPtr doc;\n+    htmlDocPtr doc = NULL;\n@@ -6417,1 +6022,1 @@\n-    input = xmlNewInputURL(ctxt, filename, NULL, encoding, 0);\n+    input = xmlCtxtNewInputFromUrl(ctxt, filename, NULL, encoding, 0);\n@@ -6419,1 +6024,2 @@\n-    doc = htmlCtxtParseDocument(ctxt, input);\n+    if (input != NULL)\n+        doc = htmlCtxtParseDocument(ctxt, input);\n@@ -6446,1 +6052,1 @@\n-    htmlDocPtr doc;\n+    htmlDocPtr doc = NULL;\n@@ -6449,1 +6055,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6457,2 +6063,2 @@\n-    input = xmlNewInputMemory(ctxt, url, buffer, size, encoding,\n-                              XML_INPUT_BUF_STATIC);\n+    input = xmlCtxtNewInputFromMemory(ctxt, url, buffer, size, encoding,\n+                                      XML_INPUT_BUF_STATIC);\n@@ -6460,1 +6066,2 @@\n-    doc = htmlCtxtParseDocument(ctxt, input);\n+    if (input != NULL)\n+        doc = htmlCtxtParseDocument(ctxt, input);\n@@ -6488,1 +6095,1 @@\n-    htmlDocPtr doc;\n+    htmlDocPtr doc = NULL;\n@@ -6496,1 +6103,1 @@\n-    input = xmlNewInputFd(ctxt, url, fd, encoding, 0);\n+    input = xmlCtxtNewInputFromFd(ctxt, url, fd, encoding, 0);\n@@ -6498,1 +6105,2 @@\n-    doc = htmlCtxtParseDocument(ctxt, input);\n+    if (input != NULL)\n+        doc = htmlCtxtParseDocument(ctxt, input);\n@@ -6526,1 +6134,1 @@\n-    htmlDocPtr doc;\n+    htmlDocPtr doc = NULL;\n@@ -6534,1 +6142,2 @@\n-    input = xmlNewInputIO(ctxt, url, ioread, ioclose, ioctx, encoding, 0);\n+    input = xmlCtxtNewInputFromIO(ctxt, url, ioread, ioclose, ioctx,\n+                                  encoding, 0);\n@@ -6536,1 +6145,2 @@\n-    doc = htmlCtxtParseDocument(ctxt, input);\n+    if (input != NULL)\n+        doc = htmlCtxtParseDocument(ctxt, input);\n@@ -6568,1 +6178,4 @@\n-    input = xmlNewInputString(ctxt, URL, (const char *) str, encoding, 0);\n+    input = xmlCtxtNewInputFromString(ctxt, URL, (const char *) str,\n+                                      encoding, 0);\n+    if (input == NULL)\n+        return(NULL);\n@@ -6583,1 +6196,1 @@\n- * See xmlNewInputURL and htmlCtxtUseOptions for details.\n+ * See htmlCtxtUseOptions for details.\n@@ -6599,1 +6212,3 @@\n-    input = xmlNewInputURL(ctxt, filename, NULL, encoding, 0);\n+    input = xmlCtxtNewInputFromUrl(ctxt, filename, NULL, encoding, 0);\n+    if (input == NULL)\n+        return(NULL);\n@@ -6632,2 +6247,4 @@\n-    input = xmlNewInputMemory(ctxt, URL, buffer, size, encoding,\n-                              XML_INPUT_BUF_STATIC);\n+    input = xmlCtxtNewInputFromMemory(ctxt, URL, buffer, size, encoding,\n+                                      XML_INPUT_BUF_STATIC);\n+    if (input == NULL)\n+        return(NULL);\n@@ -6667,1 +6284,3 @@\n-    input = xmlNewInputFd(ctxt, URL, fd, encoding, 0);\n+    input = xmlCtxtNewInputFromFd(ctxt, URL, fd, encoding, 0);\n+    if (input == NULL)\n+        return(NULL);\n@@ -6684,1 +6303,1 @@\n- * See xmlNewInputIO and htmlCtxtUseOptions for details.\n+ * See htmlCtxtUseOptions for details.\n@@ -6691,1 +6310,1 @@\n-          const char *URL,\n+              const char *URL,\n@@ -6702,1 +6321,4 @@\n-    input = xmlNewInputIO(ctxt, URL, ioread, ioclose, ioctx, encoding, 0);\n+    input = xmlCtxtNewInputFromIO(ctxt, URL, ioread, ioclose, ioctx,\n+                                  encoding, 0);\n+    if (input == NULL)\n+        return(NULL);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/HTMLparser.c","additions":3373,"deletions":3751,"binary":false,"changes":7124,"status":"modified"},{"patch":"@@ -32,3 +32,3 @@\n- *                                    *\n- *        Getting\/Setting encoding meta tags            *\n- *                                    *\n+ *                                                                      *\n+ *              Getting\/Setting encoding meta tags                      *\n+ *                                                                      *\n@@ -52,1 +52,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -59,9 +59,9 @@\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n-        if (xmlStrEqual(cur->name, BAD_CAST\"html\"))\n-        break;\n-        if (xmlStrEqual(cur->name, BAD_CAST\"head\"))\n-        goto found_head;\n-        if (xmlStrEqual(cur->name, BAD_CAST\"meta\"))\n-        goto found_meta;\n-    }\n-    cur = cur->next;\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n+            if (xmlStrEqual(cur->name, BAD_CAST\"html\"))\n+                break;\n+            if (xmlStrEqual(cur->name, BAD_CAST\"head\"))\n+                goto found_head;\n+            if (xmlStrEqual(cur->name, BAD_CAST\"meta\"))\n+                goto found_meta;\n+        }\n+        cur = cur->next;\n@@ -70,1 +70,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -77,7 +77,7 @@\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n-        if (xmlStrEqual(cur->name, BAD_CAST\"head\"))\n-        break;\n-        if (xmlStrEqual(cur->name, BAD_CAST\"meta\"))\n-        goto found_meta;\n-    }\n-    cur = cur->next;\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n+            if (xmlStrEqual(cur->name, BAD_CAST\"head\"))\n+                break;\n+            if (xmlStrEqual(cur->name, BAD_CAST\"meta\"))\n+                goto found_meta;\n+        }\n+        cur = cur->next;\n@@ -86,1 +86,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -95,21 +95,24 @@\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n-        if (xmlStrEqual(cur->name, BAD_CAST\"meta\")) {\n-        xmlAttrPtr attr = cur->properties;\n-        int http;\n-        const xmlChar *value;\n-\n-        content = NULL;\n-        http = 0;\n-        while (attr != NULL) {\n-            if ((attr->children != NULL) &&\n-                (attr->children->type == XML_TEXT_NODE) &&\n-                (attr->children->next == NULL)) {\n-            value = attr->children->content;\n-            if ((!xmlStrcasecmp(attr->name, BAD_CAST\"http-equiv\"))\n-             && (!xmlStrcasecmp(value, BAD_CAST\"Content-Type\")))\n-                http = 1;\n-            else if ((value != NULL)\n-             && (!xmlStrcasecmp(attr->name, BAD_CAST\"content\")))\n-                content = value;\n-            if ((http != 0) && (content != NULL))\n-                goto found_content;\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n+            if (xmlStrEqual(cur->name, BAD_CAST\"meta\")) {\n+                xmlAttrPtr attr = cur->properties;\n+                int http;\n+                const xmlChar *value;\n+\n+                content = NULL;\n+                http = 0;\n+                while (attr != NULL) {\n+                    if ((attr->children != NULL) &&\n+                        (attr->children->type == XML_TEXT_NODE) &&\n+                        (attr->children->next == NULL)) {\n+                        value = attr->children->content;\n+                        if ((!xmlStrcasecmp(attr->name, BAD_CAST\"http-equiv\"))\n+                         && (!xmlStrcasecmp(value, BAD_CAST\"Content-Type\")))\n+                            http = 1;\n+                        else if ((value != NULL)\n+                         && (!xmlStrcasecmp(attr->name, BAD_CAST\"content\")))\n+                            content = value;\n+                        if ((http != 0) && (content != NULL))\n+                            goto found_content;\n+                    }\n+                    attr = attr->next;\n+                }\n@@ -117,2 +120,0 @@\n-            attr = attr->next;\n-        }\n@@ -120,2 +121,1 @@\n-    }\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -128,1 +128,1 @@\n-    encoding = xmlStrstr(content, BAD_CAST\"Charset=\");\n+        encoding = xmlStrstr(content, BAD_CAST\"Charset=\");\n@@ -130,1 +130,1 @@\n-    encoding = xmlStrstr(content, BAD_CAST\"CHARSET=\");\n+        encoding = xmlStrstr(content, BAD_CAST\"CHARSET=\");\n@@ -132,1 +132,1 @@\n-    encoding += 8;\n+        encoding += 8;\n@@ -134,7 +134,7 @@\n-    encoding = xmlStrstr(content, BAD_CAST\"charset =\");\n-    if (encoding == NULL)\n-        encoding = xmlStrstr(content, BAD_CAST\"Charset =\");\n-    if (encoding == NULL)\n-        encoding = xmlStrstr(content, BAD_CAST\"CHARSET =\");\n-    if (encoding != NULL)\n-        encoding += 9;\n+        encoding = xmlStrstr(content, BAD_CAST\"charset =\");\n+        if (encoding == NULL)\n+            encoding = xmlStrstr(content, BAD_CAST\"Charset =\");\n+        if (encoding == NULL)\n+            encoding = xmlStrstr(content, BAD_CAST\"CHARSET =\");\n+        if (encoding != NULL)\n+            encoding += 9;\n@@ -143,1 +143,1 @@\n-    while ((*encoding == ' ') || (*encoding == '\\t')) encoding++;\n+        while ((*encoding == ' ') || (*encoding == '\\t')) encoding++;\n@@ -168,1 +168,1 @@\n-    return(-1);\n+        return(-1);\n@@ -175,1 +175,1 @@\n-    snprintf(newcontent, sizeof(newcontent), \"text\/html; charset=%s\",\n+        snprintf(newcontent, sizeof(newcontent), \"text\/html; charset=%s\",\n@@ -177,1 +177,1 @@\n-    newcontent[sizeof(newcontent) - 1] = 0;\n+        newcontent[sizeof(newcontent) - 1] = 0;\n@@ -186,9 +186,9 @@\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n-        if (xmlStrcasecmp(cur->name, BAD_CAST\"html\") == 0)\n-        break;\n-        if (xmlStrcasecmp(cur->name, BAD_CAST\"head\") == 0)\n-        goto found_head;\n-        if (xmlStrcasecmp(cur->name, BAD_CAST\"meta\") == 0)\n-        goto found_meta;\n-    }\n-    cur = cur->next;\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n+            if (xmlStrcasecmp(cur->name, BAD_CAST\"html\") == 0)\n+                break;\n+            if (xmlStrcasecmp(cur->name, BAD_CAST\"head\") == 0)\n+                goto found_head;\n+            if (xmlStrcasecmp(cur->name, BAD_CAST\"meta\") == 0)\n+                goto found_meta;\n+        }\n+        cur = cur->next;\n@@ -197,1 +197,1 @@\n-    return(-1);\n+        return(-1);\n@@ -204,4 +204,4 @@\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n-        if (xmlStrcasecmp(cur->name, BAD_CAST\"head\") == 0)\n-        break;\n-        if (xmlStrcasecmp(cur->name, BAD_CAST\"meta\") == 0) {\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n+            if (xmlStrcasecmp(cur->name, BAD_CAST\"head\") == 0)\n+                break;\n+            if (xmlStrcasecmp(cur->name, BAD_CAST\"meta\") == 0) {\n@@ -209,1 +209,1 @@\n-        goto found_meta;\n+                goto found_meta;\n@@ -211,2 +211,2 @@\n-    }\n-    cur = cur->next;\n+        }\n+        cur = cur->next;\n@@ -215,1 +215,1 @@\n-    return(-1);\n+        return(-1);\n@@ -228,17 +228,17 @@\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n-        if (xmlStrcasecmp(cur->name, BAD_CAST\"meta\") == 0) {\n-        xmlAttrPtr attr = cur->properties;\n-        int http;\n-        const xmlChar *value;\n-\n-        content = NULL;\n-        http = 0;\n-        while (attr != NULL) {\n-            if ((attr->children != NULL) &&\n-                (attr->children->type == XML_TEXT_NODE) &&\n-                (attr->children->next == NULL)) {\n-            value = attr->children->content;\n-            if ((!xmlStrcasecmp(attr->name, BAD_CAST\"http-equiv\"))\n-             && (!xmlStrcasecmp(value, BAD_CAST\"Content-Type\")))\n-                http = 1;\n-            else\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->name != NULL)) {\n+            if (xmlStrcasecmp(cur->name, BAD_CAST\"meta\") == 0) {\n+                xmlAttrPtr attr = cur->properties;\n+                int http;\n+                const xmlChar *value;\n+\n+                content = NULL;\n+                http = 0;\n+                while (attr != NULL) {\n+                    if ((attr->children != NULL) &&\n+                        (attr->children->type == XML_TEXT_NODE) &&\n+                        (attr->children->next == NULL)) {\n+                        value = attr->children->content;\n+                        if ((!xmlStrcasecmp(attr->name, BAD_CAST\"http-equiv\"))\n+                         && (!xmlStrcasecmp(value, BAD_CAST\"Content-Type\")))\n+                            http = 1;\n+                        else\n@@ -248,1 +248,1 @@\n-                   content = value;\n+                               content = value;\n@@ -250,9 +250,9 @@\n-                if ((http != 0) && (content != NULL))\n-                break;\n-            }\n-            attr = attr->next;\n-        }\n-        if ((http != 0) && (content != NULL)) {\n-            meta = cur;\n-            break;\n-        }\n+                        if ((http != 0) && (content != NULL))\n+                            break;\n+                    }\n+                    attr = attr->next;\n+                }\n+                if ((http != 0) && (content != NULL)) {\n+                    meta = cur;\n+                    break;\n+                }\n@@ -260,0 +260,1 @@\n+            }\n@@ -261,2 +262,1 @@\n-    }\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -314,0 +314,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -333,48 +335,3 @@\n- *                                    *\n- *            Output error handlers                *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * htmlSaveErr:\n- * @code:  the error number\n- * @node:  the location of the error.\n- * @extra:  extra information\n- *\n- * Handle an out of memory condition\n- *\/\n-static void\n-htmlSaveErr(int code, xmlNodePtr node, const char *extra)\n-{\n-    const char *msg = NULL;\n-    int res;\n-\n-    switch(code) {\n-        case XML_SAVE_NOT_UTF8:\n-        msg = \"string is not in UTF-8\\n\";\n-        break;\n-    case XML_SAVE_CHAR_INVALID:\n-        msg = \"invalid character value\\n\";\n-        break;\n-    case XML_SAVE_UNKNOWN_ENCODING:\n-        msg = \"unknown encoding %s\\n\";\n-        break;\n-    case XML_SAVE_NO_DOCTYPE:\n-        msg = \"HTML has no DOCTYPE\\n\";\n-        break;\n-    default:\n-        msg = \"unexpected error number\\n\";\n-    }\n-\n-    res = __xmlRaiseError(NULL, NULL, NULL, NULL, node,\n-                          XML_FROM_OUTPUT, code, XML_ERR_ERROR, NULL, 0,\n-                          extra, NULL, NULL, 0, 0,\n-                          msg, extra);\n-    if (res < 0)\n-        xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_OUTPUT, NULL);\n-}\n-\n-\/************************************************************************\n- *                                    *\n- *        Dumping HTML tree content to a simple buffer        *\n- *                                    *\n+ *                                                                      *\n+ *              Dumping HTML tree content to a simple buffer            *\n+ *                                                                      *\n@@ -383,17 +340,7 @@\n-static xmlCharEncodingHandler *\n-htmlFindOutputEncoder(const char *encoding) {\n-    xmlCharEncodingHandler *handler = NULL;\n-\n-    if (encoding != NULL) {\n-        int res;\n-\n-        res = xmlOpenCharEncodingHandler(encoding, \/* output *\/ 1,\n-                                         &handler);\n-        if (res != XML_ERR_OK)\n-            htmlSaveErr(XML_SAVE_UNKNOWN_ENCODING, NULL, encoding);\n-    } else {\n-        \/*\n-         * Fallback to HTML when the encoding is unspecified\n-         *\/\n-        xmlOpenCharEncodingHandler(\"HTML\", \/* output *\/ 1, &handler);\n-    }\n+static xmlParserErrors\n+htmlFindOutputEncoder(const char *encoding, xmlCharEncodingHandler **out) {\n+    \/*\n+     * Fallback to HTML if the encoding is unspecified\n+     *\/\n+    if (encoding == NULL)\n+        encoding = \"HTML\";\n@@ -401,1 +348,1 @@\n-    return(handler);\n+    return(xmlOpenCharEncodingHandler(encoding, \/* output *\/ 1, out));\n@@ -417,1 +364,1 @@\n-               int format) {\n+                   int format) {\n@@ -423,1 +370,1 @@\n-    return ((size_t) -1);\n+        return ((size_t) -1);\n@@ -426,1 +373,1 @@\n-    return ((size_t) -1);\n+        return ((size_t) -1);\n@@ -430,1 +377,1 @@\n-    return ((size_t) -1);\n+        return ((size_t) -1);\n@@ -463,1 +410,2 @@\n-    size_t ret;\n+    size_t ret1;\n+    int ret2;\n@@ -473,2 +421,1 @@\n-    xmlBufSetAllocationScheme(buffer, XML_BUFFER_ALLOC_DOUBLEIT);\n-    ret = htmlBufNodeDumpFormat(buffer, doc, cur, 1);\n+    ret1 = htmlBufNodeDumpFormat(buffer, doc, cur, 1);\n@@ -476,1 +423,1 @@\n-    xmlBufBackToBuffer(buffer);\n+    ret2 = xmlBufBackToBuffer(buffer, buf);\n@@ -478,1 +425,1 @@\n-    if (ret > INT_MAX)\n+    if ((ret1 == (size_t) -1) || (ret2 < 0))\n@@ -480,1 +427,1 @@\n-    return((int) ret);\n+    return(ret1 > INT_MAX ? INT_MAX : ret1);\n@@ -499,1 +446,1 @@\n-                   xmlNodePtr cur, const char *encoding, int format) {\n+                       xmlNodePtr cur, const char *encoding, int format) {\n@@ -509,1 +456,2 @@\n-    handler = htmlFindOutputEncoder(encoding);\n+    if (htmlFindOutputEncoder(encoding, &handler) != XML_ERR_OK)\n+        return(-1);\n@@ -513,1 +461,1 @@\n-        return(0);\n+        return(-1);\n@@ -559,1 +507,1 @@\n-    return;\n+        return;\n@@ -562,2 +510,3 @@\n-    handler = htmlFindOutputEncoder(encoding);\n-    buf = xmlAllocOutputBufferInternal(handler);\n+    if (htmlFindOutputEncoder(encoding, &handler) != XML_ERR_OK)\n+        return;\n+    buf = xmlAllocOutputBuffer(handler);\n@@ -566,1 +515,1 @@\n-    return;\n+        return;\n@@ -597,1 +546,1 @@\n-    htmlDocDumpMemoryFormat(cur, mem, size, 1);\n+        htmlDocDumpMemoryFormat(cur, mem, size, 1);\n@@ -602,3 +551,3 @@\n- *                                    *\n- *        Dumping HTML tree content to an I\/O output buffer    *\n- *                                    *\n+ *                                                                      *\n+ *              Dumping HTML tree content to an I\/O output buffer       *\n+ *                                                                      *\n@@ -619,1 +568,1 @@\n-              const char *encoding ATTRIBUTE_UNUSED) {\n+                  const char *encoding ATTRIBUTE_UNUSED) {\n@@ -622,4 +571,2 @@\n-    if (cur == NULL) {\n-    htmlSaveErr(XML_SAVE_NO_DOCTYPE, (xmlNodePtr) doc, NULL);\n-    return;\n-    }\n+    if (cur == NULL)\n+        return;\n@@ -629,6 +576,6 @@\n-    xmlOutputBufferWriteString(buf, \" PUBLIC \");\n-    xmlOutputBufferWriteQuotedString(buf, cur->ExternalID);\n-    if (cur->SystemID != NULL) {\n-        xmlOutputBufferWriteString(buf, \" \");\n-        xmlOutputBufferWriteQuotedString(buf, cur->SystemID);\n-    }\n+        xmlOutputBufferWriteString(buf, \" PUBLIC \");\n+        xmlOutputBufferWriteQuotedString(buf, cur->ExternalID);\n+        if (cur->SystemID != NULL) {\n+            xmlOutputBufferWriteString(buf, \" \");\n+            xmlOutputBufferWriteQuotedString(buf, cur->SystemID);\n+        }\n@@ -636,3 +583,3 @@\n-           xmlStrcmp(cur->SystemID, BAD_CAST \"about:legacy-compat\")) {\n-    xmlOutputBufferWriteString(buf, \" SYSTEM \");\n-    xmlOutputBufferWriteQuotedString(buf, cur->SystemID);\n+               xmlStrcmp(cur->SystemID, BAD_CAST \"about:legacy-compat\")) {\n+        xmlOutputBufferWriteString(buf, \" SYSTEM \");\n+        xmlOutputBufferWriteQuotedString(buf, cur->SystemID);\n@@ -663,1 +610,1 @@\n-    return;\n+        return;\n@@ -668,1 +615,1 @@\n-    xmlOutputBufferWriteString(buf, \":\");\n+        xmlOutputBufferWriteString(buf, \":\");\n@@ -672,16 +619,16 @@\n-    value = xmlNodeListGetString(doc, cur->children, 0);\n-    if (value) {\n-        xmlOutputBufferWriteString(buf, \"=\");\n-        if ((cur->ns == NULL) && (cur->parent != NULL) &&\n-        (cur->parent->ns == NULL) &&\n-        ((!xmlStrcasecmp(cur->name, BAD_CAST \"href\")) ||\n-             (!xmlStrcasecmp(cur->name, BAD_CAST \"action\")) ||\n-         (!xmlStrcasecmp(cur->name, BAD_CAST \"src\")) ||\n-         ((!xmlStrcasecmp(cur->name, BAD_CAST \"name\")) &&\n-          (!xmlStrcasecmp(cur->parent->name, BAD_CAST \"a\"))))) {\n-        xmlChar *escaped;\n-        xmlChar *tmp = value;\n-\n-        while (IS_BLANK_CH(*tmp)) tmp++;\n-\n-        \/*\n+        value = xmlNodeListGetString(doc, cur->children, 0);\n+        if (value) {\n+            xmlOutputBufferWriteString(buf, \"=\");\n+            if ((cur->ns == NULL) && (cur->parent != NULL) &&\n+                (cur->parent->ns == NULL) &&\n+                ((!xmlStrcasecmp(cur->name, BAD_CAST \"href\")) ||\n+                 (!xmlStrcasecmp(cur->name, BAD_CAST \"action\")) ||\n+                 (!xmlStrcasecmp(cur->name, BAD_CAST \"src\")) ||\n+                 ((!xmlStrcasecmp(cur->name, BAD_CAST \"name\")) &&\n+                  (!xmlStrcasecmp(cur->parent->name, BAD_CAST \"a\"))))) {\n+                xmlChar *escaped;\n+                xmlChar *tmp = value;\n+\n+                while (IS_BLANK_CH(*tmp)) tmp++;\n+\n+                \/*\n@@ -694,2 +641,2 @@\n-         *\/\n-        escaped = xmlURIEscapeStr(tmp,\n+                 *\/\n+                escaped = xmlURIEscapeStr(tmp,\n@@ -697,4 +644,4 @@\n-        if (escaped != NULL) {\n-            xmlOutputBufferWriteQuotedString(buf, escaped);\n-            xmlFree(escaped);\n-        } else {\n+                if (escaped != NULL) {\n+                    xmlOutputBufferWriteQuotedString(buf, escaped);\n+                    xmlFree(escaped);\n+                } else {\n@@ -702,6 +649,6 @@\n-        }\n-        } else {\n-        xmlOutputBufferWriteQuotedString(buf, value);\n-        }\n-        xmlFree(value);\n-    } else  {\n+                }\n+            } else {\n+                xmlOutputBufferWriteQuotedString(buf, value);\n+            }\n+            xmlFree(value);\n+        } else  {\n@@ -709,1 +656,1 @@\n-    }\n+        }\n@@ -725,1 +672,1 @@\n-                     xmlNodePtr cur, const char *encoding ATTRIBUTE_UNUSED,\n+                         xmlNodePtr cur, const char *encoding ATTRIBUTE_UNUSED,\n@@ -734,1 +681,1 @@\n-    return;\n+        return;\n@@ -960,1 +907,1 @@\n-               xmlNodePtr cur, const char *encoding ATTRIBUTE_UNUSED) {\n+                   xmlNodePtr cur, const char *encoding ATTRIBUTE_UNUSED) {\n@@ -975,1 +922,1 @@\n-                           const char *encoding ATTRIBUTE_UNUSED,\n+                               const char *encoding ATTRIBUTE_UNUSED,\n@@ -997,1 +944,1 @@\n-                     const char *encoding ATTRIBUTE_UNUSED) {\n+                         const char *encoding ATTRIBUTE_UNUSED) {\n@@ -1002,3 +949,3 @@\n- *                                    *\n- *        Saving functions front-ends                *\n- *                                    *\n+ *                                                                      *\n+ *              Saving functions front-ends                             *\n+ *                                                                      *\n@@ -1026,1 +973,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1030,1 +977,2 @@\n-    handler = htmlFindOutputEncoder(encoding);\n+    if (htmlFindOutputEncoder(encoding, &handler) != XML_ERR_OK)\n+        return(-1);\n@@ -1064,1 +1012,2 @@\n-    handler = htmlFindOutputEncoder(encoding);\n+    if (htmlFindOutputEncoder(encoding, &handler) != XML_ERR_OK)\n+        return(-1);\n@@ -1066,4 +1015,2 @@\n-    if (buf == NULL) {\n-        xmlCharEncCloseFunc(handler);\n-        return(0);\n-    }\n+    if (buf == NULL)\n+        return(-1);\n@@ -1090,1 +1037,1 @@\n-               const char *encoding, int format) {\n+                   const char *encoding, int format) {\n@@ -1100,1 +1047,2 @@\n-    handler = htmlFindOutputEncoder(encoding);\n+    if (htmlFindOutputEncoder(encoding, &handler) != XML_ERR_OK)\n+        return(-1);\n@@ -1104,1 +1052,1 @@\n-    htmlSetMetaEncoding(cur, (const xmlChar *) \"UTF-8\");\n+        htmlSetMetaEncoding(cur, (const xmlChar *) \"UTF-8\");\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/HTMLtree.c","additions":206,"deletions":258,"binary":false,"changes":464,"status":"modified"},{"patch":"@@ -3,1 +3,81 @@\n-v2.13.8: Apr 17 2025\n+v2.14.5: Jul 10 2025\n+\n+### Regressions\n+\n+- html: Don't abort on encoding errors\n+- parser: Fix handling of invalid char refs in recovery mode\n+- xmllint: Print document even in case of XInclude errors\n+- xmllint: Fix --xinclude --path\n+\n+### Security\n+\n+- schematron: Fix memory safety issues in xmlSchematronReportOutput\n+- Schematron: Fix null pointer dereference leading to DoS (Michael Mann)\n+- Fix potential buffer overflows of interactive shell (Michael Mann)\n+\n+### Improvements\n+\n+- parser: Fix xmlCtxtIsStopped\n+\n+### Build systems and portability\n+\n+- schemas: Fix compilation with pre-C99 MSVC\n+- cmake: Add missing endif() in libxml2-config.cmake.in\n+- Fix CMake iconv handling after change to private dependency (Markus Rickert)\n+\n+\n+v2.14.4: Jun 16 2025\n+\n+### Regressions\n+\n+- parser: Fix parsing of PublicIds and VersionNums\n+- parser: Fix custom SAX parsers without cdataBlock handler\n+- error: Fix initGenericErrorDefaultFunc compatibility macro again\n+- io: Make xmlOutputBufferCreate* not free encoder on error\n+- reader: Fix null deref on malloc failure\n+- Revert \"meson: Install libxml2.py\"\n+\n+### Security\n+\n+- tree: Fix integer overflow in xmlBuildQName\n+\n+### Improvements\n+\n+- parser: Use parser context as default in resource loader\n+- parser: Only validate EnumerationTypes when requested\n+- parser: Undeprecate some parser context members\n+\n+### Build systems\n+\n+- cmake: Avoid overlinking with non-CMake libxml2-config.cmake\n+- cmake: Make iconv a private dependency\n+\n+\n+v2.14.3: May 13 2025\n+\n+### Regressions\n+\n+- reader: Fix reading compressed data\n+- parser: Make undeclared entities in XML content fatal\n+- save: Fix XML escape table\n+- save: Fix xmlSave with NULL encoding\n+- Revert \"valid: Remove duplicate error messages when streaming\"\n+\n+### Bug fixes\n+\n+- save: Fix serialization of attribute defaults containing &lt;\n+- io: Fix linkage of __xml*BufferCreateFilename functions\n+\n+### Build systems\n+\n+- cmake: Fix installation directories in libxml2-config.cmake\n+- meson: Install libxml2.py\n+\n+### Improvements\n+\n+- parser: Make xmlCtxtGetValidCtxt depend on VALID_ENABLED\n+- html: Avoid HTML_PARSE_HTML5 clashing with XML_PARSE_NOENT\n+\n+\n+v2.14.2: Apr 17 2025\n+\n@@ -5,0 +85,1 @@\n+\n@@ -8,0 +89,175 @@\n+\n+### Build\n+\n+- error: Fix initGenericErrorDefaultFunc compatibility macro\n+- meson: don't link with pthreads on Windows (Benjamin Gilbert)\n+- cmake, meson: Align Darwin version info with Autotools\n+- globals: Fix --with-thread-alloc build\n+- meson: ensure relaxng option supports minimum option (Lovell Fuller)\n+\n+\n+v2.14.1: Apr 3 2025\n+\n+### Regressions\n+\n+- parser: Fix XML_PARSE_NOBLANKS dropping non-whitespace text\n+\n+### Build systems\n+\n+- win32-legacy: Fix build (ThomasK)\n+- meson: Fix build from tarball\n+- cmake, meson: Change library filename to libxml2.so.16.0.0\n+\n+\n+v2.14.0: Mar 27 2025\n+\n+### Major changes\n+\n+The HTML tokenizer now conforms fully to HTML5. Several non-standard\n+syntax warnings were removed. Note that HTML5 tree construction isn't\n+implemented yet.\n+\n+Binary compatibility is restricted to versions 2.14 or newer. On ELF\n+systems, the soname was bumped from libxml2.so.2 to libxml2.so.16.\n+\n+The serialization API will now take user-provided or default encodings\n+into account when serializing attribute values, matching the\n+serialization of text and avoiding unnecessary escaping.\n+\n+The XML parser won't try to merge consecutive CDATA sections as before\n+to align with web standards. Each CDATA section will create exactly one\n+node or SAX callback.\n+\n+Support for RELAX NG can now be disabled with a new configuration\n+option independently of XML Schemas support. It is still enabled by\n+default.\n+\n+The \"legacy\" configuration option won't enable support for HTTP and\n+LZMA anymore. These features will be removed in the next release.\n+\n+Parts of the xmllint executable were refactored, allowing the\n+combination of more options. OOM errors should be reported reliably now.\n+\n+Several improvements were made to the build systems. Meson is fully\n+supported now.\n+\n+Parts of the buffering code were reworked and simplified.\n+\n+Overflow checks before reallocations were hardenend.\n+\n+Some unprefixed symbols were renamed to avoid namespace pollution.\n+\n+### Other potentially incompatible changes\n+\n+Strings passed to the \"characters\" callback of the HTML SAX parser\n+aren't null-terminated anymore, matching the behavior of the XML\n+parser. Custom SAX parsers must use the \"len\" argument.\n+\n+xmlIOParseDTD doesn't allow null bytes at the end of the input anymore.\n+\n+Type and layout of conversion callbacks in struct xmlCharEncodingHandler\n+were changed. Applications using libxml2's encoding conversion API\n+should use functions xmlCharEncInFunc and xmlCharEncOutFunc instead of\n+accessing the callbacks directly.\n+\n+### New features\n+\n+Input callbacks can now be set on a parser context and an improved API\n+to create parser input is available. The following new functions,\n+taking a parser input object, were added:\n+\n+- xmlCtxtParseDocument\n+- xmlCtxtParseContent as replacement for xmlParseBalancedChunkMemory\n+  and xmlParseInNodeContext\n+- xmlCtxtParseDtd\n+\n+The xmlSave API now has additional options to replace global settings.\n+\n+Parser options XML_PARSE_UNZIP, XML_PARSE_NO_SYS_CATALOG and\n+XML_PARSE_CATALOG_PI were added.\n+\n+An API function to install a custom character encoding converter is\n+now available. This makes it possible to use ICU for encoding conversion\n+even if libxml2 was compiled without ICU support, see example\/icu.c.\n+\n+### Deprecations\n+\n+Access to many public struct members is now deprecated. Several accessor\n+functions were added to use instead.\n+\n+More internal functions were deprecated.\n+\n+### Removals\n+\n+Metadata about the HTML4 content model was removed from the htmlElemDesc\n+struct and related functions were deprecated.\n+\n+The FTP module and related functions were removed.\n+\n+Support for the range and point extensions of the xpointer() scheme\n+was removed. The rest of the XPointer implementation isn't affected.\n+The xpointer() scheme now behaves like the xpath1() scheme.\n+\n+Several legacy symbols and the functions in xmlunicode.h were removed.\n+\n+Some unprefixed, internal macros like ATTRIBUTE_UNUSED were removed\n+from public headers.\n+\n+ELF version information was removed.\n+\n+The shell was moved from libxml2 to xmllint. Several related functions\n+are no longer available.\n+\n+The libxml.m4 file containing autoconf macros was removed.\n+\n+The --with-tree configuration option was removed.\n+\n+The hack to detect single-threaded programs under glibc was removed.\n+\n+### Planned removals\n+\n+Support for HTTP and LZMA compression is planned to be removed in the\n+2.15 release.\n+\n+The following features are considered for removal:\n+\n+- Modules API (xmlmodule.h)\n+- Schematron support\n+- Support for zlib compressed file I\/O\n+- Legacy Windows build system in win32\n+\n+RELAX NG support is still in a bad state and a long-term removal\n+candidate.\n+\n+### Thanks\n+\n+Thanks to the following contributors:\n+\n+- Andrew Potter\n+- Benjamin Gilbert\n+- Chun-wei Fan\n+- correctmost\n+- Daniel Cheng\n+- Daniel E\n+- Florin Haja\n+- Grzegorz Szymaszek\n+- Heiko Becker\n+- Himanshibansal\n+- Jan Alexander Steffens (heftig)\n+- Kjell Ahlstedt\n+- makise-homura\n+- Markus Rickert\n+- Mike Dalessio\n+- Miklos Vajna\n+- Rosen Penev\n+- Ruslan Garipov\n+- Ryan Carsten Schmidt\n+- Saleem Abdulrasool\n+- Sam James\n+- Satadru Pramanik\n+- Taylor R Campbell\n+- triallax\n+- Yegor Yefremov\n+- Zak Ridouh\n+\n+\n@@ -9,0 +265,1 @@\n+\n@@ -10,0 +267,1 @@\n+\n@@ -13,0 +271,2 @@\n+\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/NEWS","additions":261,"deletions":1,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -13,1 +13,3 @@\n-<https:\/\/gitlab.gnome.org\/GNOME\/libxml2\/-\/issues>\n+<https:\/\/gitlab.gnome.org\/GNOME\/libxml2\/-\/issues>.\n+Please report *security issues* to our bug tracker as well. Make sure to\n+mark the issue as *confidential*.\n@@ -24,2 +26,1 @@\n-libxml2 can be built with GNU Autotools, CMake, meson or several other\n-build systems in platform-specific subdirectories.\n+libxml2 can be built with GNU Autotools, CMake or meson.\n@@ -48,3 +49,3 @@\n-    --with-debug            debugging module and shell (on)\n-    --with-history          history support for shell (off)\n-    --with-readline[=DIR]   use readline in DIR (for shell history)\n+    --with-debug            debugging module (on)\n+    --with-history          history support for xmllint shell (off)\n+    --with-readline[=DIR]   use readline in DIR for shell (off)\n@@ -64,0 +65,1 @@\n+    --with-relaxng          RELAX NG support (on)\n@@ -65,1 +67,1 @@\n-    --with-schemas          XML Schemas 1.0 and RELAX NG support (on)\n+    --with-schemas          XML Schemas 1.0 support (on)\n@@ -69,1 +71,0 @@\n-    --with-tree             DOM like tree manipulation APIs (on)\n@@ -102,1 +103,1 @@\n-Another option for compiling libxml is using CMake:\n+Example commands:\n@@ -104,4 +105,5 @@\n-    cmake -E tar xf libxml2-xxx.tar.gz\n-    cmake -S libxml2-xxx -B libxml2-xxx-build [possible options]\n-    cmake --build libxml2-xxx-build\n-    cmake --install libxml2-xxx-build\n+    cmake -E tar xf libxml2-xxx.tar.xz\n+    cmake -S libxml2-xxx -B builddir [options]\n+    cmake --build builddir\n+    ctest --test-dir builddir\n+    cmake --install builddir\n@@ -115,1 +117,0 @@\n-    -D LIBXML2_WITH_LZMA=OFF            # disable liblzma\n@@ -117,1 +118,1 @@\n-    -D LIBXML2_WITH_ZLIB=OFF            # disable libz\n+    -D LIBXML2_WITH_ZLIB=ON             # enable zlib\n@@ -124,1 +125,1 @@\n-Libxml can also be built with meson. Without option, simply call\n+Example commands:\n@@ -126,2 +127,4 @@\n-meson setup builddir\n-ninja -C builddir\n+    meson setup [options] builddir\n+    ninja -C builddir\n+    meson test -C builddir\n+    ninja -C builddir install\n@@ -129,1 +132,1 @@\n-To add options, see the meson_options.txt file. For example:\n+See the `meson_options.txt` file for options. For example:\n@@ -131,9 +134,5 @@\n-meson setup -Dprefix=$prefix -Dftp=true -Dhistory=true -Dicu=true -Dhttp=true builddir\n-\n-To install libxml:\n-\n-ninja -C builddir install\n-\n-To launch tests:\n-\n-meson test -C builddir\n+    -Dprefix=$prefix\n+    -Dhistory=enabled\n+    -Dhttp=enabled\n+    -Dschematron=disabled\n+    -Dzlib=enabled\n@@ -143,3 +142,1 @@\n-Libxml does not require any other libraries. A platform with somewhat\n-recent POSIX support should be sufficient (please report any violation\n-to this rule you may find).\n+libxml2 supports POSIX and Windows operating systems.\n@@ -150,2 +147,2 @@\n-[GNU libiconv](https:\/\/www.gnu.org\/software\/libiconv\/). Alternatively,\n-you can use [ICU](https:\/\/icu.unicode.org\/).\n+[GNU libiconv](https:\/\/www.gnu.org\/software\/libiconv\/). Using\n+[ICU](https:\/\/icu.unicode.org\/) is also supported but discouraged.\n@@ -157,0 +154,2 @@\n+The xmllint executable uses libreadline and libhistory if enabled.\n+\n@@ -159,2 +158,2 @@\n-The current version of the code can be found in GNOME's GitLab at \n-at <https:\/\/gitlab.gnome.org\/GNOME\/libxml2>. The best way to get involved\n+The current version of the code can be found in GNOME's GitLab at\n+<https:\/\/gitlab.gnome.org\/GNOME\/libxml2>. The best way to get involved\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/README.md","additions":34,"deletions":35,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-#include <libxml\/debugXML.h>\n@@ -34,2 +33,0 @@\n-#define XML_MAX_URI_LENGTH 2000\n-\n@@ -63,1 +60,1 @@\n-    ctxt->valid = 0;\n+        ctxt->valid = 0;\n@@ -242,1 +239,1 @@\n-           const xmlChar *ExternalID, const xmlChar *SystemID)\n+               const xmlChar *ExternalID, const xmlChar *SystemID)\n@@ -249,1 +246,3 @@\n-    return;\n+        return;\n+    if ((ctxt->html) && (ctxt->instate != XML_PARSER_MISC))\n+        return;\n@@ -252,5 +251,3 @@\n-    if (ctxt->html)\n-        return;\n-    xmlUnlinkNode((xmlNodePtr) dtd);\n-    xmlFreeDtd(dtd);\n-    ctxt->myDoc->intSubset = NULL;\n+        xmlUnlinkNode((xmlNodePtr) dtd);\n+        xmlFreeDtd(dtd);\n+        ctxt->myDoc->intSubset = NULL;\n@@ -259,1 +256,1 @@\n-    xmlCreateIntSubset(ctxt->myDoc, name, ExternalID, SystemID);\n+        xmlCreateIntSubset(ctxt->myDoc, name, ExternalID, SystemID);\n@@ -275,1 +272,1 @@\n-           const xmlChar *ExternalID, const xmlChar *SystemID)\n+               const xmlChar *ExternalID, const xmlChar *SystemID)\n@@ -282,10 +279,10 @@\n-     (ctxt->wellFormed && ctxt->myDoc))) {\n-    \/*\n-     * Try to fetch and parse the external subset.\n-     *\/\n-    xmlParserInputPtr oldinput;\n-    int oldinputNr;\n-    int oldinputMax;\n-    xmlParserInputPtr *oldinputTab;\n-    xmlParserInputPtr input = NULL;\n-    const xmlChar *oldencoding;\n+         (ctxt->wellFormed && ctxt->myDoc))) {\n+        \/*\n+         * Try to fetch and parse the external subset.\n+         *\/\n+        xmlParserInputPtr oldinput;\n+        int oldinputNr;\n+        int oldinputMax;\n+        xmlParserInputPtr *oldinputTab;\n+        xmlParserInputPtr input = NULL;\n+        const xmlChar *oldencoding;\n@@ -294,0 +291,5 @@\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+        int inputMax = 1;\n+#else\n+        int inputMax = 5;\n+#endif\n@@ -295,9 +297,9 @@\n-    \/*\n-     * Ask the Entity resolver to load the damn thing\n-     *\/\n-    if ((ctxt->sax != NULL) && (ctxt->sax->resolveEntity != NULL))\n-        input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,\n-                                            SystemID);\n-    if (input == NULL) {\n-        return;\n-    }\n+        \/*\n+         * Ask the Entity resolver to load the damn thing\n+         *\/\n+        if ((ctxt->sax != NULL) && (ctxt->sax->resolveEntity != NULL))\n+            input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,\n+                                                SystemID);\n+        if (input == NULL) {\n+            return;\n+        }\n@@ -305,1 +307,1 @@\n-    if (xmlNewDtd(ctxt->myDoc, name, ExternalID, SystemID) == NULL) {\n+        if (xmlNewDtd(ctxt->myDoc, name, ExternalID, SystemID) == NULL) {\n@@ -311,34 +313,28 @@\n-    \/*\n-     * make sure we won't destroy the main document context\n-     *\/\n-    oldinput = ctxt->input;\n-    oldinputNr = ctxt->inputNr;\n-    oldinputMax = ctxt->inputMax;\n-    oldinputTab = ctxt->inputTab;\n-    oldencoding = ctxt->encoding;\n-    ctxt->encoding = NULL;\n-\n-    ctxt->inputTab = (xmlParserInputPtr *)\n-                     xmlMalloc(5 * sizeof(xmlParserInputPtr));\n-    if (ctxt->inputTab == NULL) {\n-        xmlSAX2ErrMemory(ctxt);\n-            xmlFreeInputStream(input);\n-        ctxt->input = oldinput;\n-        ctxt->inputNr = oldinputNr;\n-        ctxt->inputMax = oldinputMax;\n-        ctxt->inputTab = oldinputTab;\n-        ctxt->encoding = oldencoding;\n-        return;\n-    }\n-    ctxt->inputNr = 0;\n-    ctxt->inputMax = 5;\n-    ctxt->input = NULL;\n-    xmlPushInput(ctxt, input);\n-\n-    if (input->filename == NULL)\n-        input->filename = (char *) xmlCanonicPath(SystemID);\n-    input->line = 1;\n-    input->col = 1;\n-    input->base = ctxt->input->cur;\n-    input->cur = ctxt->input->cur;\n-    input->free = NULL;\n+        \/*\n+         * make sure we won't destroy the main document context\n+         *\/\n+        oldinput = ctxt->input;\n+        oldinputNr = ctxt->inputNr;\n+        oldinputMax = ctxt->inputMax;\n+        oldinputTab = ctxt->inputTab;\n+        oldencoding = ctxt->encoding;\n+        ctxt->encoding = NULL;\n+\n+        ctxt->inputTab = xmlMalloc(inputMax * sizeof(xmlParserInputPtr));\n+        if (ctxt->inputTab == NULL) {\n+            xmlSAX2ErrMemory(ctxt);\n+            goto error;\n+        }\n+        ctxt->inputNr = 0;\n+        ctxt->inputMax = inputMax;\n+        ctxt->input = NULL;\n+        if (xmlCtxtPushInput(ctxt, input) < 0)\n+            goto error;\n+\n+        if (input->filename == NULL)\n+            input->filename = (char *) xmlCanonicPath(SystemID);\n+        input->line = 1;\n+        input->col = 1;\n+        input->base = ctxt->input->cur;\n+        input->cur = ctxt->input->cur;\n+        input->free = NULL;\n@@ -346,4 +342,4 @@\n-    \/*\n-     * let's parse that entity knowing it's an external subset.\n-     *\/\n-    xmlParseExternalSubset(ctxt, ExternalID, SystemID);\n+        \/*\n+         * let's parse that entity knowing it's an external subset.\n+         *\/\n+        xmlParseExternalSubset(ctxt, ExternalID, SystemID);\n@@ -352,2 +348,2 @@\n-     * Free up the external entities\n-     *\/\n+         * Free up the external entities\n+         *\/\n@@ -355,2 +351,2 @@\n-    while (ctxt->inputNr > 1)\n-        xmlPopInput(ctxt);\n+        while (ctxt->inputNr > 1)\n+            xmlFreeInputStream(xmlCtxtPopInput(ctxt));\n@@ -369,1 +365,2 @@\n-    xmlFreeInputStream(ctxt->input);\n+error:\n+        xmlFreeInputStream(input);\n@@ -372,13 +369,13 @@\n-    \/*\n-     * Restore the parsing context of the main entity\n-     *\/\n-    ctxt->input = oldinput;\n-    ctxt->inputNr = oldinputNr;\n-    ctxt->inputMax = oldinputMax;\n-    ctxt->inputTab = oldinputTab;\n-    if ((ctxt->encoding != NULL) &&\n-        ((ctxt->dict == NULL) ||\n-         (!xmlDictOwns(ctxt->dict, ctxt->encoding))))\n-        xmlFree((xmlChar *) ctxt->encoding);\n-    ctxt->encoding = oldencoding;\n-    \/* ctxt->wellFormed = oldwellFormed; *\/\n+        \/*\n+         * Restore the parsing context of the main entity\n+         *\/\n+        ctxt->input = oldinput;\n+        ctxt->inputNr = oldinputNr;\n+        ctxt->inputMax = oldinputMax;\n+        ctxt->inputTab = oldinputTab;\n+        if ((ctxt->encoding != NULL) &&\n+            ((ctxt->dict == NULL) ||\n+             (!xmlDictOwns(ctxt->dict, ctxt->encoding))))\n+            xmlFree((xmlChar *) ctxt->encoding);\n+        ctxt->encoding = oldencoding;\n+        \/* ctxt->wellFormed = oldwellFormed; *\/\n@@ -394,5 +391,2 @@\n- * The entity loader, to control the loading of external entities,\n- * the application can either:\n- *    - override this xmlSAX2ResolveEntity() callback in the SAX block\n- *    - or better use the xmlSetExternalEntityLoader() function to\n- *      set up it's own entity resolution routine\n+ * This is only used to load DTDs. The preferred way to install\n+ * custom resolvers is xmlCtxtSetResourceLoader.\n@@ -400,1 +394,1 @@\n- * Returns the xmlParserInputPtr if inlined or NULL for DOM behaviour.\n+ * Returns a parser input.\n@@ -403,1 +397,2 @@\n-xmlSAX2ResolveEntity(void *ctx, const xmlChar *publicId, const xmlChar *systemId)\n+xmlSAX2ResolveEntity(void *ctx, const xmlChar *publicId,\n+                     const xmlChar *systemId)\n@@ -446,2 +441,2 @@\n-    ret = xmlLoadExternalEntity((const char *) URI,\n-                                (const char *) publicId, ctxt);\n+    ret = xmlLoadResource(ctxt, (const char *) URI,\n+                          (const char *) publicId, XML_RESOURCE_DTD);\n@@ -471,3 +466,3 @@\n-    ret = xmlGetPredefinedEntity(name);\n-    if (ret != NULL)\n-        return(ret);\n+        ret = xmlGetPredefinedEntity(name);\n+        if (ret != NULL)\n+            return(ret);\n@@ -476,15 +471,16 @@\n-    if (ctxt->inSubset == 2) {\n-        ctxt->myDoc->standalone = 0;\n-        ret = xmlGetDocEntity(ctxt->myDoc, name);\n-        ctxt->myDoc->standalone = 1;\n-    } else {\n-        ret = xmlGetDocEntity(ctxt->myDoc, name);\n-        if (ret == NULL) {\n-        ctxt->myDoc->standalone = 0;\n-        ret = xmlGetDocEntity(ctxt->myDoc, name);\n-        if (ret != NULL) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_NOT_STANDALONE,\n-     \"Entity(%s) document marked standalone but requires external subset\\n\",\n-                   name, NULL);\n-        }\n-        ctxt->myDoc->standalone = 1;\n+        if (ctxt->inSubset == 2) {\n+            ctxt->myDoc->standalone = 0;\n+            ret = xmlGetDocEntity(ctxt->myDoc, name);\n+            ctxt->myDoc->standalone = 1;\n+        } else {\n+            ret = xmlGetDocEntity(ctxt->myDoc, name);\n+            if (ret == NULL) {\n+                ctxt->myDoc->standalone = 0;\n+                ret = xmlGetDocEntity(ctxt->myDoc, name);\n+                if (ret != NULL) {\n+                    xmlFatalErrMsg(ctxt, XML_ERR_NOT_STANDALONE,\n+         \"Entity(%s) document marked standalone but requires external subset\\n\",\n+                                   name, NULL);\n+                }\n+                ctxt->myDoc->standalone = 1;\n+            }\n@@ -492,1 +488,0 @@\n-    }\n@@ -494,1 +489,1 @@\n-    ret = xmlGetDocEntity(ctxt->myDoc, name);\n+        ret = xmlGetDocEntity(ctxt->myDoc, name);\n@@ -630,1 +625,1 @@\n-          xmlEnumerationPtr tree)\n+              xmlEnumerationPtr tree)\n@@ -634,1 +629,2 @@\n-    xmlChar *name = NULL, *prefix = NULL;\n+    const xmlChar *name = NULL;\n+    xmlChar *prefix = NULL;\n@@ -644,7 +640,7 @@\n-    \/*\n-     * Raise the error but keep the validity flag\n-     *\/\n-    int tmp = ctxt->valid;\n-    xmlErrValid(ctxt, XML_DTD_XMLID_TYPE,\n-          \"xml:id : attribute type should be ID\\n\", NULL, NULL);\n-    ctxt->valid = tmp;\n+        \/*\n+         * Raise the error but keep the validity flag\n+         *\/\n+        int tmp = ctxt->valid;\n+        xmlErrValid(ctxt, XML_DTD_XMLID_TYPE,\n+              \"xml:id : attribute type should be ID\\n\", NULL, NULL);\n+        ctxt->valid = tmp;\n@@ -652,2 +648,1 @@\n-    \/* TODO: optimize name\/prefix allocation *\/\n-    name = xmlSplitQName(ctxt, fullname, &prefix);\n+    name = xmlSplitQName4(fullname, &prefix);\n@@ -658,1 +653,5 @@\n-    attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->intSubset, elem,\n+        attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->intSubset, elem,\n+               name, prefix, (xmlAttributeType) type,\n+               (xmlAttributeDefault) def, defaultValue, tree);\n+    else if (ctxt->inSubset == 2)\n+        attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->extSubset, elem,\n@@ -661,4 +660,0 @@\n-    else if (ctxt->inSubset == 2)\n-    attr = xmlAddAttributeDecl(&ctxt->vctxt, ctxt->myDoc->extSubset, elem,\n-       name, prefix, (xmlAttributeType) type,\n-       (xmlAttributeDefault) def, defaultValue, tree);\n@@ -667,6 +662,5 @@\n-         \"SAX.xmlSAX2AttributeDecl(%s) called while not in subset\\n\",\n-                   name, NULL);\n-    xmlFree(name);\n-    xmlFree(prefix);\n-    xmlFreeEnumeration(tree);\n-    return;\n+             \"SAX.xmlSAX2AttributeDecl(%s) called while not in subset\\n\",\n+                       name, NULL);\n+        xmlFree(prefix);\n+        xmlFreeEnumeration(tree);\n+        return;\n@@ -676,1 +670,1 @@\n-    ctxt->valid = 0;\n+        ctxt->valid = 0;\n@@ -679,2 +673,2 @@\n-    ctxt->valid &= xmlValidateAttributeDecl(&ctxt->vctxt, ctxt->myDoc,\n-                                            attr);\n+        ctxt->valid &= xmlValidateAttributeDecl(&ctxt->vctxt, ctxt->myDoc,\n+                                                attr);\n@@ -683,3 +677,1 @@\n-    xmlFree(prefix);\n-    if (name != NULL)\n-    xmlFree(name);\n+        xmlFree(prefix);\n@@ -718,2 +710,2 @@\n-         \"SAX.xmlSAX2ElementDecl(%s) called while not in subset\\n\",\n-                   name, NULL);\n+             \"SAX.xmlSAX2ElementDecl(%s) called while not in subset\\n\",\n+                       name, NULL);\n@@ -743,1 +735,1 @@\n-         const xmlChar *publicId, const xmlChar *systemId)\n+             const xmlChar *publicId, const xmlChar *systemId)\n@@ -755,4 +747,4 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NOTATION_PROCESSING,\n-         \"SAX.xmlSAX2NotationDecl(%s) externalID or PublicID missing\\n\",\n-                   name, NULL);\n-    return;\n+        xmlFatalErrMsg(ctxt, XML_ERR_NOTATION_PROCESSING,\n+             \"SAX.xmlSAX2NotationDecl(%s) externalID or PublicID missing\\n\",\n+                       name, NULL);\n+        return;\n@@ -760,1 +752,1 @@\n-    nota = xmlAddNotationDecl(&ctxt->vctxt, ctxt->myDoc->intSubset, name,\n+        nota = xmlAddNotationDecl(&ctxt->vctxt, ctxt->myDoc->intSubset, name,\n@@ -763,1 +755,1 @@\n-    nota = xmlAddNotationDecl(&ctxt->vctxt, ctxt->myDoc->extSubset, name,\n+        nota = xmlAddNotationDecl(&ctxt->vctxt, ctxt->myDoc->extSubset, name,\n@@ -766,4 +758,4 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NOTATION_PROCESSING,\n-         \"SAX.xmlSAX2NotationDecl(%s) called while not in subset\\n\",\n-                   name, NULL);\n-    return;\n+        xmlFatalErrMsg(ctxt, XML_ERR_NOTATION_PROCESSING,\n+             \"SAX.xmlSAX2NotationDecl(%s) called while not in subset\\n\",\n+                       name, NULL);\n+        return;\n@@ -775,2 +767,2 @@\n-    ctxt->valid &= xmlValidateNotationDecl(&ctxt->vctxt, ctxt->myDoc,\n-                                           nota);\n+        ctxt->valid &= xmlValidateNotationDecl(&ctxt->vctxt, ctxt->myDoc,\n+                                               nota);\n@@ -792,2 +784,2 @@\n-           const xmlChar *publicId, const xmlChar *systemId,\n-           const xmlChar *notationName)\n+                   const xmlChar *publicId, const xmlChar *systemId,\n+                   const xmlChar *notationName)\n@@ -828,8 +820,8 @@\n-    if (ctxt->myDoc == NULL)\n-        ctxt->myDoc = htmlNewDocNoDtD(NULL, NULL);\n-    if (ctxt->myDoc == NULL) {\n-        xmlSAX2ErrMemory(ctxt);\n-        return;\n-    }\n-    ctxt->myDoc->properties = XML_DOC_HTML;\n-    ctxt->myDoc->parseFlags = ctxt->options;\n+        if (ctxt->myDoc == NULL)\n+            ctxt->myDoc = htmlNewDocNoDtD(NULL, NULL);\n+        if (ctxt->myDoc == NULL) {\n+            xmlSAX2ErrMemory(ctxt);\n+            return;\n+        }\n+        ctxt->myDoc->properties = XML_DOC_HTML;\n+        ctxt->myDoc->parseFlags = ctxt->options;\n@@ -839,15 +831,15 @@\n-    doc = ctxt->myDoc = xmlNewDoc(ctxt->version);\n-    if (doc != NULL) {\n-        doc->properties = 0;\n-        if (ctxt->options & XML_PARSE_OLD10)\n-            doc->properties |= XML_DOC_OLD10;\n-        doc->parseFlags = ctxt->options;\n-        doc->standalone = ctxt->standalone;\n-    } else {\n-        xmlSAX2ErrMemory(ctxt);\n-        return;\n-    }\n-    if ((ctxt->dictNames) && (doc != NULL)) {\n-        doc->dict = ctxt->dict;\n-        xmlDictReference(doc->dict);\n-    }\n+        doc = ctxt->myDoc = xmlNewDoc(ctxt->version);\n+        if (doc != NULL) {\n+            doc->properties = 0;\n+            if (ctxt->options & XML_PARSE_OLD10)\n+                doc->properties |= XML_DOC_OLD10;\n+            doc->parseFlags = ctxt->options;\n+            doc->standalone = ctxt->standalone;\n+        } else {\n+            xmlSAX2ErrMemory(ctxt);\n+            return;\n+        }\n+        if ((ctxt->dictNames) && (doc != NULL)) {\n+            doc->dict = ctxt->dict;\n+            xmlDictReference(doc->dict);\n+        }\n@@ -856,4 +848,4 @@\n-    (ctxt->input != NULL) && (ctxt->input->filename != NULL)) {\n-    ctxt->myDoc->URL = xmlPathToURI((const xmlChar *)ctxt->input->filename);\n-    if (ctxt->myDoc->URL == NULL)\n-        xmlSAX2ErrMemory(ctxt);\n+        (ctxt->input != NULL) && (ctxt->input->filename != NULL)) {\n+        ctxt->myDoc->URL = xmlPathToURI((const xmlChar *)ctxt->input->filename);\n+        if (ctxt->myDoc->URL == NULL)\n+            xmlSAX2ErrMemory(ctxt);\n@@ -879,1 +871,1 @@\n-    ctxt->valid &= xmlValidateDocumentFinal(&ctxt->vctxt, ctxt->myDoc);\n+        ctxt->valid &= xmlValidateDocumentFinal(&ctxt->vctxt, ctxt->myDoc);\n@@ -900,1 +892,1 @@\n-    parent = (xmlNodePtr) ctxt->myDoc->intSubset;\n+        parent = (xmlNodePtr) ctxt->myDoc->intSubset;\n@@ -902,1 +894,1 @@\n-    parent = (xmlNodePtr) ctxt->myDoc->extSubset;\n+        parent = (xmlNodePtr) ctxt->myDoc->extSubset;\n@@ -922,1 +914,1 @@\n-    (ctxt->input != NULL)) {\n+        (ctxt->input != NULL)) {\n@@ -930,1 +922,1 @@\n-#if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_LEGACY_ENABLED)\n+#if defined(LIBXML_SAX1_ENABLED)\n@@ -950,1 +942,1 @@\n- * xmlSAX2AttributeInternal:\n+ * xmlSAX1Attribute:\n@@ -954,1 +946,0 @@\n- * @prefix: the prefix on the element node\n@@ -957,3 +948,2 @@\n- * The default handling is to convert the attribute into an\n- * DOM subtree and past it in a new xmlAttr element added to\n- * the element.\n+ *\n+ * Deprecated SAX1 interface.\n@@ -962,2 +952,2 @@\n-xmlSAX2AttributeInternal(void *ctx, const xmlChar *fullname,\n-             const xmlChar *value, const xmlChar *prefix ATTRIBUTE_UNUSED)\n+xmlSAX1Attribute(xmlParserCtxtPtr ctxt, const xmlChar *fullname,\n+                 const xmlChar *value, const xmlChar *prefix)\n@@ -965,1 +955,0 @@\n-    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;\n@@ -967,1 +956,1 @@\n-    xmlChar *name;\n+    const xmlChar *name;\n@@ -969,1 +958,0 @@\n-    xmlChar *nval;\n@@ -972,5 +960,0 @@\n-    if (ctxt->html) {\n-    name = xmlStrdup(fullname);\n-    ns = NULL;\n-    namespace = NULL;\n-    } else {\n@@ -980,18 +963,1 @@\n-    name = xmlSplitQName(ctxt, fullname, &ns);\n-    if ((name != NULL) && (name[0] == 0)) {\n-        if (xmlStrEqual(ns, BAD_CAST \"xmlns\")) {\n-        xmlNsErrMsg(ctxt, XML_ERR_NS_DECL_ERROR,\n-                \"invalid namespace declaration '%s'\\n\",\n-                fullname, NULL);\n-        } else {\n-        xmlNsWarnMsg(ctxt, XML_WAR_NS_COLUMN,\n-                 \"Avoid attribute ending with ':' like '%s'\\n\",\n-                 fullname, NULL);\n-        }\n-        if (ns != NULL)\n-        xmlFree(ns);\n-        ns = NULL;\n-        xmlFree(name);\n-        name = xmlStrdup(fullname);\n-    }\n-    }\n+    name = xmlSplitQName4(fullname, &ns);\n@@ -1000,33 +966,1 @@\n-    if (ns != NULL)\n-        xmlFree(ns);\n-    return;\n-    }\n-\n-#ifdef LIBXML_HTML_ENABLED\n-    if ((ctxt->html) &&\n-        (value == NULL) && (htmlIsBooleanAttr(fullname))) {\n-            nval = xmlStrdup(fullname);\n-            if (nval == NULL)\n-                xmlSAX2ErrMemory(ctxt);\n-            value = (const xmlChar *) nval;\n-    } else\n-#endif\n-    {\n-#ifdef LIBXML_VALID_ENABLED\n-        \/*\n-         * Do the last stage of the attribute normalization\n-         * Needed for HTML too:\n-         *   http:\/\/www.w3.org\/TR\/html4\/types.html#h-6.2\n-         *\/\n-        ctxt->vctxt.valid = 1;\n-        nval = xmlValidCtxtNormalizeAttributeValue(&ctxt->vctxt,\n-                                               ctxt->myDoc, ctxt->node,\n-                                               fullname, value);\n-        if (ctxt->vctxt.valid != 1) {\n-            ctxt->valid = 0;\n-        }\n-        if (nval != NULL)\n-            value = nval;\n-#else\n-        nval = NULL;\n-#endif \/* LIBXML_VALID_ENABLED *\/\n+        return;\n@@ -1038,1 +972,1 @@\n-    if ((!ctxt->html) && (ns == NULL) &&\n+    if ((ns == NULL) &&\n@@ -1041,2 +975,2 @@\n-    xmlNsPtr nsret;\n-    xmlChar *val;\n+        xmlNsPtr nsret;\n+        xmlChar *val;\n@@ -1049,8 +983,7 @@\n-        val = xmlExpandEntitiesInAttValue(ctxt, value, \/* normalize *\/ 0);\n-        if (val == NULL) {\n-            xmlSAX2ErrMemory(ctxt);\n-        if (name != NULL)\n-            xmlFree(name);\n-                if (nval != NULL)\n-                    xmlFree(nval);\n-        return;\n+            val = xmlExpandEntitiesInAttValue(ctxt, value, \/* normalize *\/ 0);\n+            if (val == NULL) {\n+                xmlSAX2ErrMemory(ctxt);\n+                return;\n+            }\n+        } else {\n+            val = (xmlChar *) value;\n@@ -1058,3 +991,0 @@\n-    } else {\n-        val = (xmlChar *) value;\n-    }\n@@ -1062,2 +992,2 @@\n-    if (val[0] != 0) {\n-        xmlURIPtr uri;\n+        if (val[0] != 0) {\n+            xmlURIPtr uri;\n@@ -1065,1 +995,1 @@\n-        if (xmlParseURISafe((const char *)val, &uri) < 0)\n+            if (xmlParseURISafe((const char *)val, &uri) < 0)\n@@ -1067,1 +997,1 @@\n-        if (uri == NULL) {\n+            if (uri == NULL) {\n@@ -1070,2 +1000,2 @@\n-        } else {\n-        if (uri->scheme == NULL) {\n+            } else {\n+                if (uri->scheme == NULL) {\n@@ -1075,0 +1005,3 @@\n+                }\n+                xmlFreeURI(uri);\n+            }\n@@ -1076,3 +1009,0 @@\n-        xmlFreeURI(uri);\n-        }\n-    }\n@@ -1080,2 +1010,2 @@\n-    \/* a default namespace definition *\/\n-    nsret = xmlNewNs(ctxt->node, val, NULL);\n+        \/* a default namespace definition *\/\n+        nsret = xmlNewNs(ctxt->node, val, NULL);\n@@ -1086,4 +1016,4 @@\n-    \/*\n-     * Validate also for namespace decls, they are attributes from\n-     * an XML-1.0 perspective\n-     *\/\n+        \/*\n+         * Validate also for namespace decls, they are attributes from\n+         * an XML-1.0 perspective\n+         *\/\n@@ -1092,2 +1022,2 @@\n-        ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,\n-                       ctxt->node, prefix, nsret, val);\n+            ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,\n+                                           ctxt->node, prefix, nsret, val);\n@@ -1096,7 +1026,3 @@\n-    if (name != NULL)\n-        xmlFree(name);\n-    if (nval != NULL)\n-        xmlFree(nval);\n-    if (val != value)\n-        xmlFree(val);\n-    return;\n+        if (val != value)\n+            xmlFree(val);\n+        return;\n@@ -1104,2 +1030,1 @@\n-    if ((!ctxt->html) &&\n-    (ns != NULL) && (ns[0] == 'x') && (ns[1] == 'm') && (ns[2] == 'l') &&\n+    if ((ns != NULL) && (ns[0] == 'x') && (ns[1] == 'm') && (ns[2] == 'l') &&\n@@ -1107,2 +1032,2 @@\n-    xmlNsPtr nsret;\n-    xmlChar *val;\n+        xmlNsPtr nsret;\n+        xmlChar *val;\n@@ -1115,9 +1040,8 @@\n-        val = xmlExpandEntitiesInAttValue(ctxt, value, \/* normalize *\/ 0);\n-        if (val == NULL) {\n-            xmlSAX2ErrMemory(ctxt);\n-            xmlFree(ns);\n-        if (name != NULL)\n-            xmlFree(name);\n-                if (nval != NULL)\n-                    xmlFree(nval);\n-        return;\n+            val = xmlExpandEntitiesInAttValue(ctxt, value, \/* normalize *\/ 0);\n+            if (val == NULL) {\n+                xmlSAX2ErrMemory(ctxt);\n+                xmlFree(ns);\n+                return;\n+            }\n+        } else {\n+            val = (xmlChar *) value;\n@@ -1125,3 +1049,0 @@\n-    } else {\n-        val = (xmlChar *) value;\n-    }\n@@ -1129,6 +1050,6 @@\n-    if (val[0] == 0) {\n-        xmlNsErrMsg(ctxt, XML_NS_ERR_EMPTY,\n-                \"Empty namespace name for prefix %s\\n\", name, NULL);\n-    }\n-    if ((ctxt->pedantic != 0) && (val[0] != 0)) {\n-        xmlURIPtr uri;\n+        if (val[0] == 0) {\n+            xmlNsErrMsg(ctxt, XML_NS_ERR_EMPTY,\n+                        \"Empty namespace name for prefix %s\\n\", name, NULL);\n+        }\n+        if ((ctxt->pedantic != 0) && (val[0] != 0)) {\n+            xmlURIPtr uri;\n@@ -1136,1 +1057,1 @@\n-        if (xmlParseURISafe((const char *)val, &uri) < 0)\n+            if (xmlParseURISafe((const char *)val, &uri) < 0)\n@@ -1138,9 +1059,10 @@\n-        if (uri == NULL) {\n-            xmlNsWarnMsg(ctxt, XML_WAR_NS_URI,\n-             \"xmlns:%s: %s not a valid URI\\n\", name, value);\n-        } else {\n-        if (uri->scheme == NULL) {\n-            xmlNsWarnMsg(ctxt, XML_WAR_NS_URI_RELATIVE,\n-               \"xmlns:%s: URI %s is not absolute\\n\", name, value);\n-        }\n-        xmlFreeURI(uri);\n+            if (uri == NULL) {\n+                xmlNsWarnMsg(ctxt, XML_WAR_NS_URI,\n+                         \"xmlns:%s: %s not a valid URI\\n\", name, value);\n+            } else {\n+                if (uri->scheme == NULL) {\n+                    xmlNsWarnMsg(ctxt, XML_WAR_NS_URI_RELATIVE,\n+                           \"xmlns:%s: URI %s is not absolute\\n\", name, value);\n+                }\n+                xmlFreeURI(uri);\n+            }\n@@ -1148,1 +1070,0 @@\n-    }\n@@ -1150,3 +1071,3 @@\n-    \/* a standard namespace definition *\/\n-    nsret = xmlNewNs(ctxt->node, val, name);\n-    xmlFree(ns);\n+        \/* a standard namespace definition *\/\n+        nsret = xmlNewNs(ctxt->node, val, name);\n+        xmlFree(ns);\n@@ -1158,4 +1079,4 @@\n-    \/*\n-     * Validate also for namespace decls, they are attributes from\n-     * an XML-1.0 perspective\n-     *\/\n+        \/*\n+         * Validate also for namespace decls, they are attributes from\n+         * an XML-1.0 perspective\n+         *\/\n@@ -1163,3 +1084,3 @@\n-             ctxt->myDoc && ctxt->myDoc->intSubset) {\n-        ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,\n-                       ctxt->node, prefix, nsret, value);\n+                 ctxt->myDoc && ctxt->myDoc->intSubset) {\n+            ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,\n+                                           ctxt->node, prefix, nsret, value);\n@@ -1168,7 +1089,3 @@\n-    if (name != NULL)\n-        xmlFree(name);\n-    if (nval != NULL)\n-        xmlFree(nval);\n-    if (val != value)\n-        xmlFree(val);\n-    return;\n+        if (val != value)\n+            xmlFree(val);\n+        return;\n@@ -1180,1 +1097,1 @@\n-    res = xmlSearchNsSafe(ctxt->node, ns, &namespace);\n+        res = xmlSearchNsSafe(ctxt->node, ns, &namespace);\n@@ -1184,5 +1101,5 @@\n-    if (namespace == NULL) {\n-        xmlNsErrMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n-            \"Namespace prefix %s of attribute %s is not defined\\n\",\n-                     ns, name);\n-    } else {\n+        if (namespace == NULL) {\n+            xmlNsErrMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n+                    \"Namespace prefix %s of attribute %s is not defined\\n\",\n+                             ns, name);\n+        } else {\n@@ -1202,2 +1119,0 @@\n-                        if (name != NULL)\n-                            xmlFree(name);\n@@ -1211,1 +1126,1 @@\n-    namespace = NULL;\n+        namespace = NULL;\n@@ -1215,1 +1130,1 @@\n-    ret = xmlNewNsPropEatName(ctxt->node, namespace, name, NULL);\n+    ret = xmlNewNsProp(ctxt->node, namespace, name, NULL);\n@@ -1221,1 +1136,1 @@\n-    if ((ctxt->replaceEntities == 0) && (!ctxt->html)) {\n+    if (ctxt->replaceEntities == 0) {\n@@ -1235,1 +1150,1 @@\n-    if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&\n+    if (ctxt->validate && ctxt->wellFormed &&\n@@ -1238,4 +1153,4 @@\n-    \/*\n-     * If we don't substitute entities, the validation should be\n-     * done on a value with replaced entities anyway.\n-     *\/\n+        \/*\n+         * If we don't substitute entities, the validation should be\n+         * done on a value with replaced entities anyway.\n+         *\/\n@@ -1243,1 +1158,1 @@\n-        xmlChar *val;\n+            xmlChar *val;\n@@ -1246,13 +1161,13 @@\n-        val = xmlExpandEntitiesInAttValue(ctxt, value, \/* normalize *\/ 0);\n-\n-        if (val == NULL)\n-        ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n-                ctxt->myDoc, ctxt->node, ret, value);\n-        else {\n-        xmlChar *nvalnorm;\n-\n-        \/*\n-         * Do the last stage of the attribute normalization\n-         * It need to be done twice ... it's an extra burden related\n-         * to the ability to keep xmlSAX2References in attributes\n-         *\/\n+            val = xmlExpandEntitiesInAttValue(ctxt, value, \/* normalize *\/ 0);\n+\n+            if (val == NULL)\n+                ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n+                                ctxt->myDoc, ctxt->node, ret, value);\n+            else {\n+                xmlChar *nvalnorm;\n+\n+                \/*\n+                 * Do the last stage of the attribute normalization\n+                 * It need to be done twice ... it's an extra burden related\n+                 * to the ability to keep xmlSAX2References in attributes\n+                 *\/\n@@ -1262,4 +1177,4 @@\n-        if (nvalnorm != NULL) {\n-            xmlFree(val);\n-            val = nvalnorm;\n-        }\n+                if (nvalnorm != NULL) {\n+                    xmlFree(val);\n+                    val = nvalnorm;\n+                }\n@@ -1267,2 +1182,2 @@\n-        ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n-                    ctxt->myDoc, ctxt->node, ret, val);\n+                ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n+                                ctxt->myDoc, ctxt->node, ret, val);\n@@ -1270,0 +1185,4 @@\n+            }\n+        } else {\n+            ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt, ctxt->myDoc,\n+                                               ctxt->node, ret, value);\n@@ -1271,4 +1190,0 @@\n-    } else {\n-        ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt, ctxt->myDoc,\n-                           ctxt->node, ret, value);\n-    }\n@@ -1285,8 +1200,2 @@\n-     * when validating, the ID registration is done at the attribute\n-     * validation level. Otherwise we have to do specific handling here.\n-     *\/\n-    if (xmlStrEqual(fullname, BAD_CAST \"xml:id\")) {\n-        \/*\n-         * Add the xml:id value\n-         *\n-         * Open issue: normalization of the value.\n+         * when validating, the ID registration is done at the attribute\n+         * validation level. Otherwise we have to do specific handling here.\n@@ -1294,7 +1203,13 @@\n-        if (xmlValidateNCName(content, 1) != 0) {\n-            xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,\n-                    \"xml:id : attribute value %s is not an NCName\\n\",\n-                    content, NULL);\n-        }\n-        xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);\n-    } else {\n+        if (xmlStrEqual(fullname, BAD_CAST \"xml:id\")) {\n+            \/*\n+             * Add the xml:id value\n+             *\n+             * Open issue: normalization of the value.\n+             *\/\n+            if (xmlValidateNCName(content, 1) != 0) {\n+                xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,\n+                            \"xml:id : attribute value %s is not an NCName\\n\",\n+                            content, NULL);\n+            }\n+            xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);\n+        } else {\n@@ -1313,2 +1228,0 @@\n-    if (nval != NULL)\n-    xmlFree(nval);\n@@ -1316,1 +1229,1 @@\n-    xmlFree(ns);\n+        xmlFree(ns);\n@@ -1323,0 +1236,2 @@\n+ *\n+ * Deprecated SAX1 interface.\n@@ -1326,1 +1241,1 @@\n-    const xmlChar *prefix, const xmlChar **atts) {\n+        const xmlChar *prefix, const xmlChar **atts) {\n@@ -1334,2 +1249,2 @@\n-    elemDecl = xmlGetDtdQElementDesc(ctxt->myDoc->extSubset, name, prefix);\n-    internal = 0;\n+        elemDecl = xmlGetDtdQElementDesc(ctxt->myDoc->extSubset, name, prefix);\n+        internal = 0;\n@@ -1341,20 +1256,20 @@\n-    xmlAttributePtr attr = elemDecl->attributes;\n-    \/*\n-     * Check against defaulted attributes from the external subset\n-     * if the document is stamped as standalone\n-     *\/\n-    if ((ctxt->myDoc->standalone == 1) &&\n-        (ctxt->myDoc->extSubset != NULL) &&\n-        (ctxt->validate)) {\n-        while (attr != NULL) {\n-        if ((attr->defaultValue != NULL) &&\n-            (xmlGetDtdQAttrDesc(ctxt->myDoc->extSubset,\n-                    attr->elem, attr->name,\n-                    attr->prefix) == attr) &&\n-            (xmlGetDtdQAttrDesc(ctxt->myDoc->intSubset,\n-                    attr->elem, attr->name,\n-                    attr->prefix) == NULL)) {\n-            xmlChar *fulln;\n-\n-            if (attr->prefix != NULL) {\n-            fulln = xmlStrdup(attr->prefix);\n+        xmlAttributePtr attr = elemDecl->attributes;\n+        \/*\n+         * Check against defaulted attributes from the external subset\n+         * if the document is stamped as standalone\n+         *\/\n+        if ((ctxt->myDoc->standalone == 1) &&\n+            (ctxt->myDoc->extSubset != NULL) &&\n+            (ctxt->validate)) {\n+            while (attr != NULL) {\n+                if ((attr->defaultValue != NULL) &&\n+                    (xmlGetDtdQAttrDesc(ctxt->myDoc->extSubset,\n+                                        attr->elem, attr->name,\n+                                        attr->prefix) == attr) &&\n+                    (xmlGetDtdQAttrDesc(ctxt->myDoc->intSubset,\n+                                        attr->elem, attr->name,\n+                                        attr->prefix) == NULL)) {\n+                    xmlChar *fulln;\n+\n+                    if (attr->prefix != NULL) {\n+                        fulln = xmlStrdup(attr->prefix);\n@@ -1362,1 +1277,1 @@\n-                fulln = xmlStrcat(fulln, BAD_CAST \":\");\n+                            fulln = xmlStrcat(fulln, BAD_CAST \":\");\n@@ -1364,4 +1279,4 @@\n-                fulln = xmlStrcat(fulln, attr->name);\n-            } else {\n-            fulln = xmlStrdup(attr->name);\n-            }\n+                            fulln = xmlStrcat(fulln, attr->name);\n+                    } else {\n+                        fulln = xmlStrdup(attr->name);\n+                    }\n@@ -1373,17 +1288,17 @@\n-            \/*\n-             * Check that the attribute is not declared in the\n-             * serialization\n-             *\/\n-            att = NULL;\n-            if (atts != NULL) {\n-            i = 0;\n-            att = atts[i];\n-            while (att != NULL) {\n-                if (xmlStrEqual(att, fulln))\n-                break;\n-                i += 2;\n-                att = atts[i];\n-            }\n-            }\n-            if (att == NULL) {\n-                xmlErrValid(ctxt, XML_DTD_STANDALONE_DEFAULTED,\n+                    \/*\n+                     * Check that the attribute is not declared in the\n+                     * serialization\n+                     *\/\n+                    att = NULL;\n+                    if (atts != NULL) {\n+                        i = 0;\n+                        att = atts[i];\n+                        while (att != NULL) {\n+                            if (xmlStrEqual(att, fulln))\n+                                break;\n+                            i += 2;\n+                            att = atts[i];\n+                        }\n+                    }\n+                    if (att == NULL) {\n+                        xmlErrValid(ctxt, XML_DTD_STANDALONE_DEFAULTED,\n@@ -1391,3 +1306,3 @@\n-                    fulln,\n-                    attr->elem);\n-            }\n+                                    fulln,\n+                                    attr->elem);\n+                    }\n@@ -1395,0 +1310,3 @@\n+                }\n+                attr = attr->nexth;\n+            }\n@@ -1396,3 +1314,0 @@\n-        attr = attr->nexth;\n-        }\n-    }\n@@ -1400,5 +1315,0 @@\n-    \/*\n-     * Actually insert defaulted values when needed\n-     *\/\n-    attr = elemDecl->attributes;\n-    while (attr != NULL) {\n@@ -1406,3 +1316,1 @@\n-         * Make sure that attributes redefinition occurring in the\n-         * internal subset are not overridden by definitions in the\n-         * external subset.\n+         * Actually insert defaulted values when needed\n@@ -1410,29 +1318,2 @@\n-        if (attr->defaultValue != NULL) {\n-        \/*\n-         * the element should be instantiated in the tree if:\n-         *  - this is a namespace prefix\n-         *  - the user required for completion in the tree\n-         *    like XSLT\n-         *  - there isn't already an attribute definition\n-         *    in the internal subset overriding it.\n-         *\/\n-        if (((attr->prefix != NULL) &&\n-             (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\"))) ||\n-            ((attr->prefix == NULL) &&\n-             (xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) ||\n-            (ctxt->loadsubset & XML_COMPLETE_ATTRS)) {\n-            xmlAttributePtr tst;\n-\n-            tst = xmlGetDtdQAttrDesc(ctxt->myDoc->intSubset,\n-                         attr->elem, attr->name,\n-                         attr->prefix);\n-            if ((tst == attr) || (tst == NULL)) {\n-                xmlChar fn[50];\n-            xmlChar *fulln;\n-\n-                        fulln = xmlBuildQName(attr->name, attr->prefix, fn, 50);\n-            if (fulln == NULL) {\n-                xmlSAX2ErrMemory(ctxt);\n-                return;\n-            }\n-\n+        attr = elemDecl->attributes;\n+        while (attr != NULL) {\n@@ -1440,2 +1321,3 @@\n-             * Check that the attribute is not declared in the\n-             * serialization\n+             * Make sure that attributes redefinition occurring in the\n+             * internal subset are not overridden by definitions in the\n+             * external subset.\n@@ -1443,9 +1325,51 @@\n-            att = NULL;\n-            if (atts != NULL) {\n-                i = 0;\n-                att = atts[i];\n-                while (att != NULL) {\n-                if (xmlStrEqual(att, fulln))\n-                    break;\n-                i += 2;\n-                att = atts[i];\n+            if (attr->defaultValue != NULL) {\n+                \/*\n+                 * the element should be instantiated in the tree if:\n+                 *  - this is a namespace prefix\n+                 *  - the user required for completion in the tree\n+                 *    like XSLT\n+                 *  - there isn't already an attribute definition\n+                 *    in the internal subset overriding it.\n+                 *\/\n+                if (((attr->prefix != NULL) &&\n+                     (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\"))) ||\n+                    ((attr->prefix == NULL) &&\n+                     (xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) ||\n+                    (ctxt->loadsubset & XML_COMPLETE_ATTRS)) {\n+                    xmlAttributePtr tst;\n+\n+                    tst = xmlGetDtdQAttrDesc(ctxt->myDoc->intSubset,\n+                                             attr->elem, attr->name,\n+                                             attr->prefix);\n+                    if ((tst == attr) || (tst == NULL)) {\n+                        xmlChar fn[50];\n+                        xmlChar *fulln;\n+\n+                        fulln = xmlBuildQName(attr->name, attr->prefix, fn, 50);\n+                        if (fulln == NULL) {\n+                            xmlSAX2ErrMemory(ctxt);\n+                            return;\n+                        }\n+\n+                        \/*\n+                         * Check that the attribute is not declared in the\n+                         * serialization\n+                         *\/\n+                        att = NULL;\n+                        if (atts != NULL) {\n+                            i = 0;\n+                            att = atts[i];\n+                            while (att != NULL) {\n+                                if (xmlStrEqual(att, fulln))\n+                                    break;\n+                                i += 2;\n+                                att = atts[i];\n+                            }\n+                        }\n+                        if (att == NULL) {\n+                            xmlSAX1Attribute(ctxt, fulln,\n+                                             attr->defaultValue, prefix);\n+                        }\n+                        if ((fulln != fn) && (fulln != attr->name))\n+                            xmlFree(fulln);\n+                    }\n@@ -1454,7 +1378,1 @@\n-            if (att == NULL) {\n-                xmlSAX2AttributeInternal(ctxt, fulln,\n-                         attr->defaultValue, prefix);\n-            }\n-            if ((fulln != fn) && (fulln != attr->name))\n-                xmlFree(fulln);\n-            }\n+            attr = attr->nexth;\n@@ -1462,0 +1380,5 @@\n+        if (internal == 1) {\n+            elemDecl = xmlGetDtdQElementDesc(ctxt->myDoc->extSubset,\n+                                             name, prefix);\n+            internal = 0;\n+            goto process_external_subset;\n@@ -1463,8 +1386,0 @@\n-        attr = attr->nexth;\n-    }\n-    if (internal == 1) {\n-        elemDecl = xmlGetDtdQElementDesc(ctxt->myDoc->extSubset,\n-                                     name, prefix);\n-        internal = 0;\n-        goto process_external_subset;\n-    }\n@@ -1475,1 +1390,1 @@\n- * xmlSAX2StartElement:\n+ * xmlSAX1StartElement:\n@@ -1481,0 +1396,2 @@\n+ *\n+ * Deprecated SAX1 interface.\n@@ -1482,2 +1399,2 @@\n-void\n-xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)\n+static void\n+xmlSAX1StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts)\n@@ -1489,1 +1406,1 @@\n-    xmlChar *name;\n+    const xmlChar *name;\n@@ -1493,1 +1410,1 @@\n-    int i;\n+    int i, res;\n@@ -1502,7 +1419,7 @@\n-     ((ctxt->myDoc->intSubset->notations == NULL) &&\n-      (ctxt->myDoc->intSubset->elements == NULL) &&\n-      (ctxt->myDoc->intSubset->attributes == NULL) &&\n-      (ctxt->myDoc->intSubset->entities == NULL)))) {\n-    xmlErrValid(ctxt, XML_ERR_NO_DTD,\n-      \"Validation failed: no DTD found !\", NULL, NULL);\n-    ctxt->validate = 0;\n+         ((ctxt->myDoc->intSubset->notations == NULL) &&\n+          (ctxt->myDoc->intSubset->elements == NULL) &&\n+          (ctxt->myDoc->intSubset->attributes == NULL) &&\n+          (ctxt->myDoc->intSubset->entities == NULL)))) {\n+        xmlErrValid(ctxt, XML_ERR_NO_DTD,\n+          \"Validation failed: no DTD found !\", NULL, NULL);\n+        ctxt->validate = 0;\n@@ -1511,12 +1428,7 @@\n-    if (ctxt->html) {\n-        prefix = NULL;\n-        name = xmlStrdup(fullname);\n-    } else {\n-        \/*\n-         * Split the full name into a namespace prefix and the tag name\n-         *\/\n-        name = xmlSplitQName(ctxt, fullname, &prefix);\n-        if (name == NULL) {\n-            xmlSAX2ErrMemory(ctxt);\n-            return;\n-        }\n+    \/*\n+     * Split the full name into a namespace prefix and the tag name\n+     *\/\n+    name = xmlSplitQName4(fullname, &prefix);\n+    if (name == NULL) {\n+        xmlSAX2ErrMemory(ctxt);\n+        return;\n@@ -1530,1 +1442,1 @@\n-    ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL, name, NULL);\n+    ret = xmlNewDocNode(ctxt->myDoc, NULL, name, NULL);\n@@ -1532,2 +1444,2 @@\n-    xmlFree(prefix);\n-    xmlSAX2ErrMemory(ctxt);\n+        xmlFree(prefix);\n+        xmlSAX2ErrMemory(ctxt);\n@@ -1559,2 +1471,8 @@\n-    if (!ctxt->html) {\n-        int res;\n+    \/*\n+     * Insert all the defaulted attributes from the DTD especially\n+     * namespaces\n+     *\/\n+    if ((ctxt->myDoc->intSubset != NULL) ||\n+        (ctxt->myDoc->extSubset != NULL)) {\n+        xmlCheckDefaultedAttributes(ctxt, name, prefix, atts);\n+    }\n@@ -1562,8 +1480,11 @@\n-        \/*\n-         * Insert all the defaulted attributes from the DTD especially\n-         * namespaces\n-         *\/\n-        if ((ctxt->myDoc->intSubset != NULL) ||\n-            (ctxt->myDoc->extSubset != NULL)) {\n-            xmlCheckDefaultedAttributes(ctxt, name, prefix, atts);\n-        }\n+    \/*\n+     * process all the attributes whose name start with \"xmlns\"\n+     *\/\n+    if (atts != NULL) {\n+        i = 0;\n+        att = atts[i++];\n+        value = atts[i++];\n+        while ((att != NULL) && (value != NULL)) {\n+            if ((att[0] == 'x') && (att[1] == 'm') && (att[2] == 'l') &&\n+                (att[3] == 'n') && (att[4] == 's'))\n+                xmlSAX1Attribute(ctxt, att, value, prefix);\n@@ -1571,5 +1492,0 @@\n-        \/*\n-         * process all the attributes whose name start with \"xmlns\"\n-         *\/\n-        if (atts != NULL) {\n-            i = 0;\n@@ -1578,8 +1494,0 @@\n-        while ((att != NULL) && (value != NULL)) {\n-        if ((att[0] == 'x') && (att[1] == 'm') && (att[2] == 'l') &&\n-            (att[3] == 'n') && (att[4] == 's'))\n-            xmlSAX2AttributeInternal(ctxt, att, value, prefix);\n-\n-        att = atts[i++];\n-        value = atts[i++];\n-        }\n@@ -1587,0 +1495,1 @@\n+    }\n@@ -1588,5 +1497,9 @@\n-        \/*\n-         * Search the namespace, note that since the attributes have been\n-         * processed, the local namespaces are available.\n-         *\/\n-        res = xmlSearchNsSafe(ret, prefix, &ns);\n+    \/*\n+     * Search the namespace, note that since the attributes have been\n+     * processed, the local namespaces are available.\n+     *\/\n+    res = xmlSearchNsSafe(ret, prefix, &ns);\n+    if (res < 0)\n+        xmlSAX2ErrMemory(ctxt);\n+    if ((ns == NULL) && (parent != NULL)) {\n+        res = xmlSearchNsSafe(parent, prefix, &ns);\n@@ -1595,21 +1508,8 @@\n-        if ((ns == NULL) && (parent != NULL)) {\n-            res = xmlSearchNsSafe(parent, prefix, &ns);\n-            if (res < 0)\n-                xmlSAX2ErrMemory(ctxt);\n-        }\n-        if ((prefix != NULL) && (ns == NULL)) {\n-            xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n-                         \"Namespace prefix %s is not defined\\n\",\n-                         prefix, NULL);\n-            ns = xmlNewNs(ret, NULL, prefix);\n-            if (ns == NULL)\n-                xmlSAX2ErrMemory(ctxt);\n-        }\n-\n-        \/*\n-         * set the namespace node, making sure that if the default namespace\n-         * is unbound on a parent we simply keep it NULL\n-         *\/\n-        if ((ns != NULL) && (ns->href != NULL) &&\n-            ((ns->href[0] != 0) || (ns->prefix != NULL)))\n-            xmlSetNs(ret, ns);\n+    }\n+    if ((prefix != NULL) && (ns == NULL)) {\n+        xmlNsWarnMsg(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n+                     \"Namespace prefix %s is not defined\\n\",\n+                     prefix, NULL);\n+        ns = xmlNewNs(ret, NULL, prefix);\n+        if (ns == NULL)\n+            xmlSAX2ErrMemory(ctxt);\n@@ -1618,0 +1518,8 @@\n+    \/*\n+     * set the namespace node, making sure that if the default namespace\n+     * is unbound on a parent we simply keep it NULL\n+     *\/\n+    if ((ns != NULL) && (ns->href != NULL) &&\n+        ((ns->href[0] != 0) || (ns->prefix != NULL)))\n+        xmlSetNs(ret, ns);\n+\n@@ -1623,5 +1531,0 @@\n-    att = atts[i++];\n-    value = atts[i++];\n-    if (ctxt->html) {\n-        while (att != NULL) {\n-        xmlSAX2AttributeInternal(ctxt, att, value, NULL);\n@@ -1630,2 +1533,0 @@\n-        }\n-    } else {\n@@ -1633,3 +1534,3 @@\n-        if ((att[0] != 'x') || (att[1] != 'm') || (att[2] != 'l') ||\n-            (att[3] != 'n') || (att[4] != 's'))\n-            xmlSAX2AttributeInternal(ctxt, att, value, NULL);\n+            if ((att[0] != 'x') || (att[1] != 'm') || (att[2] != 'l') ||\n+                (att[3] != 'n') || (att[4] != 's'))\n+                xmlSAX1Attribute(ctxt, att, value, NULL);\n@@ -1637,5 +1538,5 @@\n-        \/*\n-         * Next ones\n-         *\/\n-        att = atts[i++];\n-        value = atts[i++];\n+            \/*\n+             * Next ones\n+             *\/\n+            att = atts[i++];\n+            value = atts[i++];\n@@ -1644,1 +1545,0 @@\n-    }\n@@ -1653,1 +1553,1 @@\n-    int chk;\n+        int chk;\n@@ -1655,7 +1555,7 @@\n-    chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);\n-    if (chk <= 0)\n-        ctxt->valid = 0;\n-    if (chk < 0)\n-        ctxt->wellFormed = 0;\n-    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n-    ctxt->vctxt.flags |= XML_VCTXT_DTD_VALIDATED;\n+        chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);\n+        if (chk <= 0)\n+            ctxt->valid = 0;\n+        if (chk < 0)\n+            ctxt->wellFormed = 0;\n+        ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n+        ctxt->vctxt.flags |= XML_VCTXT_DTD_VALIDATED;\n@@ -1666,1 +1566,1 @@\n-    xmlFree(prefix);\n+        xmlFree(prefix);\n@@ -1669,0 +1569,145 @@\n+#endif \/* LIBXML_SAX1_ENABLED *\/\n+\n+#ifdef LIBXML_HTML_ENABLED\n+static void\n+xmlSAX2HtmlAttribute(xmlParserCtxtPtr ctxt, const xmlChar *fullname,\n+                     const xmlChar *value) {\n+    xmlAttrPtr ret;\n+    xmlChar *nval = NULL;\n+\n+    ret = xmlNewNsProp(ctxt->node, NULL, fullname, NULL);\n+    if (ret == NULL) {\n+        xmlSAX2ErrMemory(ctxt);\n+        return;\n+    }\n+\n+    if ((value == NULL) && (htmlIsBooleanAttr(fullname))) {\n+        nval = xmlStrdup(fullname);\n+        if (nval == NULL) {\n+            xmlSAX2ErrMemory(ctxt);\n+            return;\n+        }\n+        value = nval;\n+    }\n+\n+    if (value != NULL) {\n+        ret->children = xmlNewDocText(ctxt->myDoc, value);\n+        if (ret->children == NULL) {\n+            xmlSAX2ErrMemory(ctxt);\n+        } else {\n+            ret->last = ret->children;\n+            ret->children->parent = (xmlNodePtr) ret;\n+        }\n+    }\n+\n+    if (((ctxt->loadsubset & XML_SKIP_IDS) == 0) &&\n+        \/*\n+         * Don't create IDs containing entity references (should\n+         * be always the case with HTML)\n+         *\/\n+        (ret->children != NULL) &&\n+        (ret->children->type == XML_TEXT_NODE) &&\n+        (ret->children->next == NULL)) {\n+        int res = xmlIsID(ctxt->myDoc, ctxt->node, ret);\n+\n+        if (res < 0)\n+            xmlCtxtErrMemory(ctxt);\n+        else if (res > 0)\n+            xmlAddID(&ctxt->vctxt, ctxt->myDoc, ret->children->content, ret);\n+    }\n+\n+    if (nval != NULL)\n+        xmlFree(nval);\n+}\n+\n+\/**\n+ * xmlSAX2StartHtmlElement:\n+ * @ctxt:  parser context\n+ * @fullname:  The element name, including namespace prefix\n+ * @atts:  An array of name\/value attributes pairs, NULL terminated\n+ *\n+ * Called when an opening tag has been processed.\n+ *\/\n+static void\n+xmlSAX2StartHtmlElement(xmlParserCtxtPtr ctxt, const xmlChar *fullname,\n+                        const xmlChar **atts) {\n+    xmlNodePtr ret;\n+    xmlNodePtr parent;\n+    const xmlChar *att;\n+    const xmlChar *value;\n+    int i;\n+\n+    ret = xmlNewDocNode(ctxt->myDoc, NULL, fullname, NULL);\n+    if (ret == NULL) {\n+        xmlSAX2ErrMemory(ctxt);\n+        return;\n+    }\n+    ctxt->nodemem = -1;\n+\n+    \/* Initialize parent before pushing node *\/\n+    parent = ctxt->node;\n+    if (parent == NULL)\n+        parent = (xmlNodePtr) ctxt->myDoc;\n+\n+    \/*\n+     * Link the child element\n+     *\/\n+    xmlSAX2AppendChild(ctxt, ret);\n+\n+    \/*\n+     * We are parsing a new node.\n+     *\/\n+    if (nodePush(ctxt, ret) < 0) {\n+        xmlUnlinkNode(ret);\n+        xmlFreeNode(ret);\n+        return;\n+    }\n+\n+    if (atts != NULL) {\n+        i = 0;\n+        att = atts[i++];\n+        value = atts[i++];\n+        while (att != NULL) {\n+            xmlSAX2HtmlAttribute(ctxt, att, value);\n+            att = atts[i++];\n+            value = atts[i++];\n+        }\n+    }\n+}\n+#endif \/* LIBXML_HTML_ENABLED *\/\n+\n+\/**\n+ * xmlSAX2StartElement:\n+ * @ctx: the user data (XML parser context)\n+ * @fullname:  The element name, including namespace prefix\n+ * @atts:  An array of name\/value attributes pairs, NULL terminated\n+ *\n+ * DEPRECATED: Don't call this function directly.\n+ *\n+ * Called when an opening tag has been processed.\n+ *\n+ * Used for HTML and SAX1.\n+ *\/\n+void\n+xmlSAX2StartElement(void *ctx, const xmlChar *fullname, const xmlChar **atts) {\n+    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;\n+\n+    (void) atts;\n+\n+    if ((ctxt == NULL) || (fullname == NULL) || (ctxt->myDoc == NULL))\n+        return;\n+\n+#ifdef LIBXML_SAX1_ENABLED\n+    if (!ctxt->html) {\n+        xmlSAX1StartElement(ctxt, fullname, atts);\n+        return;\n+    }\n+#endif\n+\n+#ifdef LIBXML_HTML_ENABLED\n+    if (ctxt->html) {\n+        xmlSAX2StartHtmlElement(ctxt, fullname, atts);\n+        return;\n+    }\n+#endif\n+}\n@@ -1675,0 +1720,2 @@\n+ * DEPRECATED: Don't call this function directly.\n+ *\n@@ -1676,0 +1723,2 @@\n+ *\n+ * Used for HTML and SAX1.\n@@ -1682,3 +1731,2 @@\n-    if (ctx == NULL) return;\n-\n-    ctxt->nodemem = -1;\n+    if (ctxt == NULL)\n+        return;\n@@ -1686,2 +1734,2 @@\n-#ifdef LIBXML_VALID_ENABLED\n-    if (ctxt->validate && ctxt->wellFormed &&\n+#if defined(LIBXML_SAX1_ENABLED) && defined(LIBXML_VALID_ENABLED)\n+    if (!ctxt->html && ctxt->validate && ctxt->wellFormed &&\n@@ -1690,1 +1738,1 @@\n-                         ctxt->node);\n+                                             ctxt->node);\n@@ -1693,0 +1741,2 @@\n+#if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED)\n+    ctxt->nodemem = -1;\n@@ -1698,0 +1748,1 @@\n+#endif\n@@ -1699,1 +1750,0 @@\n-#endif \/* LIBXML_SAX1_ENABLED || LIBXML_HTML_ENABLED || LIBXML_LEGACY_ENABLED *\/\n@@ -1720,3 +1770,3 @@\n-    ret = ctxt->freeElems;\n-    ctxt->freeElems = ret->next;\n-    ctxt->freeElemsNr--;\n+        ret = ctxt->freeElems;\n+        ctxt->freeElems = ret->next;\n+        ctxt->freeElemsNr--;\n@@ -1724,1 +1774,1 @@\n-    ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n+        ret = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n@@ -1728,1 +1778,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1735,1 +1785,1 @@\n-    if (ctxt->dictNames) {\n+    if ((!ctxt->html) && (ctxt->dictNames)) {\n@@ -1738,10 +1788,10 @@\n-    if ((len < (int) (2 * sizeof(void *))) &&\n-        (ctxt->options & XML_PARSE_COMPACT)) {\n-        \/* store the string in the node overriding properties and nsDef *\/\n-        xmlChar *tmp = (xmlChar *) &(ret->properties);\n-        memcpy(tmp, str, len);\n-        tmp[len] = 0;\n-        intern = tmp;\n-    } else if ((len <= 3) && ((cur == '\"') || (cur == '\\'') ||\n-        ((cur == '<') && (str[len + 1] != '!')))) {\n-        intern = xmlDictLookup(ctxt->dict, str, len);\n+        if ((len < (int) (2 * sizeof(void *))) &&\n+            (ctxt->options & XML_PARSE_COMPACT)) {\n+            \/* store the string in the node overriding properties and nsDef *\/\n+            xmlChar *tmp = (xmlChar *) &(ret->properties);\n+            memcpy(tmp, str, len);\n+            tmp[len] = 0;\n+            intern = tmp;\n+        } else if ((len <= 3) && ((cur == '\"') || (cur == '\\'') ||\n+            ((cur == '<') && (str[len + 1] != '!')))) {\n+            intern = xmlDictLookup(ctxt->dict, str, len);\n@@ -1753,3 +1803,3 @@\n-    } else if (IS_BLANK_CH(*str) && (len < 60) && (cur == '<') &&\n-               (str[len + 1] != '!')) {\n-        int i;\n+        } else if (IS_BLANK_CH(*str) && (len < 60) && (cur == '<') &&\n+                   (str[len + 1] != '!')) {\n+            int i;\n@@ -1757,4 +1807,4 @@\n-        for (i = 1;i < len;i++) {\n-        if (!IS_BLANK_CH(str[i])) goto skip;\n-        }\n-        intern = xmlDictLookup(ctxt->dict, str, len);\n+            for (i = 1;i < len;i++) {\n+                if (!IS_BLANK_CH(str[i])) goto skip;\n+            }\n+            intern = xmlDictLookup(ctxt->dict, str, len);\n@@ -1766,1 +1816,1 @@\n-    }\n+        }\n@@ -1773,6 +1823,6 @@\n-    ret->content = xmlStrndup(str, len);\n-    if (ret->content == NULL) {\n-        xmlSAX2ErrMemory(ctxt);\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n+        ret->content = xmlStrndup(str, len);\n+        if (ret->content == NULL) {\n+            xmlSAX2ErrMemory(ctxt);\n+            xmlFree(ret);\n+            return(NULL);\n+        }\n@@ -1780,1 +1830,1 @@\n-    ret->content = (xmlChar *) intern;\n+        ret->content = (xmlChar *) intern;\n@@ -1782,2 +1832,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue(ret);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue(ret);\n@@ -1806,1 +1856,1 @@\n-        goto decode;\n+            goto decode;\n@@ -1838,2 +1888,2 @@\n-           const xmlChar * value,\n-           const xmlChar * valueend)\n+                   const xmlChar * value,\n+                   const xmlChar * valueend)\n@@ -1849,2 +1899,2 @@\n-    namespace = xmlParserNsLookupSax(ctxt, prefix);\n-    if ((namespace == NULL) && (xmlStrEqual(prefix, BAD_CAST \"xml\"))) {\n+        namespace = xmlParserNsLookupSax(ctxt, prefix);\n+        if ((namespace == NULL) && (xmlStrEqual(prefix, BAD_CAST \"xml\"))) {\n@@ -1853,1 +1903,1 @@\n-        res = xmlSearchNsSafe(ctxt->node, prefix, &namespace);\n+            res = xmlSearchNsSafe(ctxt->node, prefix, &namespace);\n@@ -1856,1 +1906,1 @@\n-    }\n+        }\n@@ -1864,2 +1914,2 @@\n-    ctxt->freeAttrs = ret->next;\n-    ctxt->freeAttrsNr--;\n+        ctxt->freeAttrs = ret->next;\n+        ctxt->freeAttrsNr--;\n@@ -1898,1 +1948,1 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n@@ -1902,1 +1952,1 @@\n-    xmlNodePtr tmp;\n+        xmlNodePtr tmp;\n@@ -1904,14 +1954,14 @@\n-    \/*\n-     * We know that if there is an entity reference, then\n-     * the string has been dup'ed and terminates with 0\n-     * otherwise with ' or \"\n-     *\/\n-    if (*valueend != 0) {\n-        tmp = xmlSAX2TextNode(ctxt, value, valueend - value);\n-        ret->children = tmp;\n-        ret->last = tmp;\n-        if (tmp != NULL) {\n-        tmp->doc = ret->doc;\n-        tmp->parent = (xmlNodePtr) ret;\n-        }\n-    } else if (valueend > value) {\n+        \/*\n+         * We know that if there is an entity reference, then\n+         * the string has been dup'ed and terminates with 0\n+         * otherwise with ' or \"\n+         *\/\n+        if (*valueend != 0) {\n+            tmp = xmlSAX2TextNode(ctxt, value, valueend - value);\n+            ret->children = tmp;\n+            ret->last = tmp;\n+            if (tmp != NULL) {\n+                tmp->doc = ret->doc;\n+                tmp->parent = (xmlNodePtr) ret;\n+            }\n+        } else if (valueend > value) {\n@@ -1921,1 +1971,1 @@\n-    }\n+        }\n@@ -1923,1 +1973,1 @@\n-    xmlNodePtr tmp;\n+        xmlNodePtr tmp;\n@@ -1925,7 +1975,7 @@\n-    tmp = xmlSAX2TextNode(ctxt, value, valueend - value);\n-    ret->children = tmp;\n-    ret->last = tmp;\n-    if (tmp != NULL) {\n-        tmp->doc = ret->doc;\n-        tmp->parent = (xmlNodePtr) ret;\n-    }\n+        tmp = xmlSAX2TextNode(ctxt, value, valueend - value);\n+        ret->children = tmp;\n+        ret->last = tmp;\n+        if (tmp != NULL) {\n+            tmp->doc = ret->doc;\n+            tmp->parent = (xmlNodePtr) ret;\n+        }\n@@ -1937,4 +1987,4 @@\n-    \/*\n-     * If we don't substitute entities, the validation should be\n-     * done on a value with replaced entities anyway.\n-     *\/\n+        \/*\n+         * If we don't substitute entities, the validation should be\n+         * done on a value with replaced entities anyway.\n+         *\/\n@@ -1942,12 +1992,12 @@\n-        dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);\n-        if (dup == NULL) {\n-            if (*valueend == 0) {\n-            ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n-                    ctxt->myDoc, ctxt->node, ret, value);\n-        } else {\n-            \/*\n-             * That should already be normalized.\n-             * cheaper to finally allocate here than duplicate\n-             * entry points in the full validation code\n-             *\/\n-            dup = xmlStrndup(value, valueend - value);\n+            dup = xmlSAX2DecodeAttrEntities(ctxt, value, valueend);\n+            if (dup == NULL) {\n+                if (*valueend == 0) {\n+                    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n+                                    ctxt->myDoc, ctxt->node, ret, value);\n+                } else {\n+                    \/*\n+                     * That should already be normalized.\n+                     * cheaper to finally allocate here than duplicate\n+                     * entry points in the full validation code\n+                     *\/\n+                    dup = xmlStrndup(value, valueend - value);\n@@ -1957,17 +2007,17 @@\n-            ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n-                    ctxt->myDoc, ctxt->node, ret, dup);\n-        }\n-        } else {\n-            \/*\n-         * dup now contains a string of the flattened attribute\n-         * content with entities substituted. Check if we need to\n-         * apply an extra layer of normalization.\n-         * It need to be done twice ... it's an extra burden related\n-         * to the ability to keep references in attributes\n-         *\/\n-        if (ctxt->attsSpecial != NULL) {\n-            xmlChar *nvalnorm;\n-            xmlChar fn[50];\n-            xmlChar *fullname;\n-\n-            fullname = xmlBuildQName(localname, prefix, fn, 50);\n+                    ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n+                                    ctxt->myDoc, ctxt->node, ret, dup);\n+                }\n+            } else {\n+                \/*\n+                 * dup now contains a string of the flattened attribute\n+                 * content with entities substituted. Check if we need to\n+                 * apply an extra layer of normalization.\n+                 * It need to be done twice ... it's an extra burden related\n+                 * to the ability to keep references in attributes\n+                 *\/\n+                if (ctxt->attsSpecial != NULL) {\n+                    xmlChar *nvalnorm;\n+                    xmlChar fn[50];\n+                    xmlChar *fullname;\n+\n+                    fullname = xmlBuildQName(localname, prefix, fn, 50);\n@@ -1977,15 +2027,15 @@\n-            ctxt->vctxt.valid = 1;\n-                nvalnorm = xmlValidCtxtNormalizeAttributeValue(\n-                             &ctxt->vctxt, ctxt->myDoc,\n-                     ctxt->node, fullname, dup);\n-            if (ctxt->vctxt.valid != 1)\n-                ctxt->valid = 0;\n-\n-            if ((fullname != fn) && (fullname != localname))\n-                xmlFree(fullname);\n-            if (nvalnorm != NULL) {\n-                xmlFree(dup);\n-                dup = nvalnorm;\n-            }\n-            }\n-        }\n+                        ctxt->vctxt.valid = 1;\n+                        nvalnorm = xmlValidCtxtNormalizeAttributeValue(\n+                                         &ctxt->vctxt, ctxt->myDoc,\n+                                         ctxt->node, fullname, dup);\n+                        if (ctxt->vctxt.valid != 1)\n+                            ctxt->valid = 0;\n+\n+                        if ((fullname != fn) && (fullname != localname))\n+                            xmlFree(fullname);\n+                        if (nvalnorm != NULL) {\n+                            xmlFree(dup);\n+                            dup = nvalnorm;\n+                        }\n+                    }\n+                }\n@@ -1993,9 +2043,9 @@\n-        ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n-                    ctxt->myDoc, ctxt->node, ret, dup);\n-        }\n-    } else {\n-        \/*\n-         * if entities already have been substituted, then\n-         * the attribute as passed is already normalized\n-         *\/\n-        dup = xmlStrndup(value, valueend - value);\n+                ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n+                                ctxt->myDoc, ctxt->node, ret, dup);\n+            }\n+        } else {\n+            \/*\n+             * if entities already have been substituted, then\n+             * the attribute as passed is already normalized\n+             *\/\n+            dup = xmlStrndup(value, valueend - value);\n@@ -2005,3 +2055,3 @@\n-        ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n-                                 ctxt->myDoc, ctxt->node, ret, dup);\n-    }\n+            ctxt->valid &= xmlValidateOneAttribute(&ctxt->vctxt,\n+                                     ctxt->myDoc, ctxt->node, ret, dup);\n+        }\n@@ -2018,10 +2068,2 @@\n-     * when validating, the ID registration is done at the attribute\n-     * validation level. Otherwise we have to do specific handling here.\n-     *\/\n-        if ((prefix == ctxt->str_xml) &&\n-               (localname[0] == 'i') && (localname[1] == 'd') &&\n-           (localname[2] == 0)) {\n-        \/*\n-         * Add the xml:id value\n-         *\n-         * Open issue: normalization of the value.\n+         * when validating, the ID registration is done at the attribute\n+         * validation level. Otherwise we have to do specific handling here.\n@@ -2029,2 +2071,10 @@\n-        if (xmlValidateNCName(content, 1) != 0) {\n-            xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,\n+        if ((prefix == ctxt->str_xml) &&\n+                   (localname[0] == 'i') && (localname[1] == 'd') &&\n+                   (localname[2] == 0)) {\n+            \/*\n+             * Add the xml:id value\n+             *\n+             * Open issue: normalization of the value.\n+             *\/\n+            if (xmlValidateNCName(content, 1) != 0) {\n+                xmlErrValid(ctxt, XML_DTD_XMLID_VALUE,\n@@ -2033,3 +2083,3 @@\n-        }\n-        xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);\n-    } else {\n+            }\n+            xmlAddID(&ctxt->vctxt, ctxt->myDoc, content, ret);\n+        } else {\n@@ -2044,1 +2094,1 @@\n-    }\n+        }\n@@ -2047,1 +2097,1 @@\n-    xmlFree(dup);\n+        xmlFree(dup);\n@@ -2072,7 +2122,7 @@\n-              const xmlChar *prefix,\n-              const xmlChar *URI,\n-              int nb_namespaces,\n-              const xmlChar **namespaces,\n-              int nb_attributes,\n-              int nb_defaulted,\n-              const xmlChar **attributes)\n+                      const xmlChar *prefix,\n+                      const xmlChar *URI,\n+                      int nb_namespaces,\n+                      const xmlChar **namespaces,\n+                      int nb_attributes,\n+                      int nb_defaulted,\n+                      const xmlChar **attributes)\n@@ -2091,9 +2141,11 @@\n-    if (ctxt->validate && (ctxt->myDoc->extSubset == NULL) &&\n-        ((ctxt->myDoc->intSubset == NULL) ||\n-     ((ctxt->myDoc->intSubset->notations == NULL) &&\n-      (ctxt->myDoc->intSubset->elements == NULL) &&\n-      (ctxt->myDoc->intSubset->attributes == NULL) &&\n-      (ctxt->myDoc->intSubset->entities == NULL)))) {\n-    xmlErrValid(ctxt, XML_DTD_NO_DTD,\n-      \"Validation failed: no DTD found !\", NULL, NULL);\n-    ctxt->validate = 0;\n+    if (ctxt->validate &&\n+        ((ctxt->myDoc == NULL) ||\n+         ((ctxt->myDoc->extSubset == NULL) &&\n+          ((ctxt->myDoc->intSubset == NULL) ||\n+           ((ctxt->myDoc->intSubset->notations == NULL) &&\n+            (ctxt->myDoc->intSubset->elements == NULL) &&\n+            (ctxt->myDoc->intSubset->attributes == NULL) &&\n+            (ctxt->myDoc->intSubset->entities == NULL)))))) {\n+        xmlErrValid(ctxt, XML_DTD_NO_DTD,\n+          \"Validation failed: no DTD found !\", NULL, NULL);\n+        ctxt->validate = 0;\n@@ -2107,1 +2159,1 @@\n-        const xmlChar *fullname;\n+            const xmlChar *fullname;\n@@ -2109,2 +2161,2 @@\n-        fullname = xmlDictQLookup(ctxt->dict, prefix, localname);\n-        if (fullname == NULL) {\n+            fullname = xmlDictQLookup(ctxt->dict, prefix, localname);\n+            if (fullname == NULL) {\n@@ -2114,3 +2166,3 @@\n-        localname = fullname;\n-    } else {\n-        lname = xmlBuildQName(localname, prefix, NULL, 0);\n+            localname = fullname;\n+        } else {\n+            lname = xmlBuildQName(localname, prefix, NULL, 0);\n@@ -2121,1 +2173,1 @@\n-    }\n+        }\n@@ -2128,3 +2180,3 @@\n-    ctxt->freeElems = ret->next;\n-    ctxt->freeElemsNr--;\n-    memset(ret, 0, sizeof(xmlNode));\n+        ctxt->freeElems = ret->next;\n+        ctxt->freeElemsNr--;\n+        memset(ret, 0, sizeof(xmlNode));\n@@ -2132,1 +2184,1 @@\n-    ret->type = XML_ELEMENT_NODE;\n+        ret->type = XML_ELEMENT_NODE;\n@@ -2134,9 +2186,9 @@\n-    if (ctxt->dictNames)\n-        ret->name = localname;\n-    else {\n-        if (lname == NULL)\n-        ret->name = xmlStrdup(localname);\n-        else\n-            ret->name = lname;\n-        if (ret->name == NULL) {\n-            xmlSAX2ErrMemory(ctxt);\n+        if (ctxt->dictNames)\n+            ret->name = localname;\n+        else {\n+            if (lname == NULL)\n+                ret->name = xmlStrdup(localname);\n+            else\n+                ret->name = lname;\n+            if (ret->name == NULL) {\n+                xmlSAX2ErrMemory(ctxt);\n@@ -2144,1 +2196,2 @@\n-        return;\n+                return;\n+            }\n@@ -2146,3 +2199,2 @@\n-    }\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-        xmlRegisterNodeDefaultValue(ret);\n+        if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+            xmlRegisterNodeDefaultValue(ret);\n@@ -2150,12 +2202,11 @@\n-    if (ctxt->dictNames)\n-        ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,\n-                                   (xmlChar *) localname, NULL);\n-    else if (lname == NULL)\n-        ret = xmlNewDocNode(ctxt->myDoc, NULL, localname, NULL);\n-    else\n-        ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,\n-                                   (xmlChar *) lname, NULL);\n-    if (ret == NULL) {\n-        xmlSAX2ErrMemory(ctxt);\n-        return;\n-    }\n+        if (ctxt->dictNames)\n+            ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL,\n+                                       (xmlChar *) localname, NULL);\n+        else if (lname == NULL)\n+            ret = xmlNewDocNode(ctxt->myDoc, NULL, localname, NULL);\n+        else\n+            ret = xmlNewDocNodeEatName(ctxt->myDoc, NULL, lname, NULL);\n+        if (ret == NULL) {\n+            xmlSAX2ErrMemory(ctxt);\n+            return;\n+        }\n@@ -2169,5 +2220,11 @@\n-    uri = namespaces[i++];\n-    ns = xmlNewNs(NULL, uri, pref);\n-    if (ns != NULL) {\n-        if (last == NULL) {\n-            ret->nsDef = last = ns;\n+        uri = namespaces[i++];\n+        ns = xmlNewNs(NULL, uri, pref);\n+        if (ns != NULL) {\n+            if (last == NULL) {\n+                ret->nsDef = last = ns;\n+            } else {\n+                last->next = ns;\n+                last = ns;\n+            }\n+            if ((URI != NULL) && (prefix == pref))\n+                ret->ns = ns;\n@@ -2175,6 +2232,0 @@\n-            last->next = ns;\n-        last = ns;\n-        }\n-        if ((URI != NULL) && (prefix == pref))\n-        ret->ns = ns;\n-    } else {\n@@ -2182,2 +2233,2 @@\n-        continue;\n-    }\n+            continue;\n+        }\n@@ -2188,5 +2239,5 @@\n-    if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&\n-        ctxt->myDoc && ctxt->myDoc->intSubset) {\n-        ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,\n-                                               ret, prefix, ns, uri);\n-    }\n+        if ((!ctxt->html) && ctxt->validate && ctxt->wellFormed &&\n+            ctxt->myDoc && ctxt->myDoc->intSubset) {\n+            ctxt->valid &= xmlValidateOneNamespace(&ctxt->vctxt, ctxt->myDoc,\n+                                                   ret, prefix, ns, uri);\n+        }\n@@ -2216,1 +2267,1 @@\n-    nb_attributes -= nb_defaulted;\n+        nb_attributes -= nb_defaulted;\n@@ -2224,1 +2275,1 @@\n-    if ((ret->ns == NULL) && (xmlStrEqual(prefix, BAD_CAST \"xml\"))) {\n+        if ((ret->ns == NULL) && (xmlStrEqual(prefix, BAD_CAST \"xml\"))) {\n@@ -2227,1 +2278,1 @@\n-        res = xmlSearchNsSafe(ret, prefix, &ret->ns);\n+            res = xmlSearchNsSafe(ret, prefix, &ret->ns);\n@@ -2230,7 +2281,0 @@\n-    }\n-    if (ret->ns == NULL) {\n-        ns = xmlNewNs(ret, NULL, prefix);\n-        if (ns == NULL) {\n-\n-            xmlSAX2ErrMemory(ctxt);\n-        return;\n@@ -2238,0 +2282,7 @@\n+        if (ret->ns == NULL) {\n+            ns = xmlNewNs(ret, NULL, prefix);\n+            if (ns == NULL) {\n+\n+                xmlSAX2ErrMemory(ctxt);\n+                return;\n+            }\n@@ -2246,1 +2297,1 @@\n-    }\n+        }\n@@ -2258,6 +2309,6 @@\n-        \/*\n-         * Handle the rare case of an undefined attribute prefix\n-         *\/\n-        if ((attributes[j+1] != NULL) && (attributes[j+2] == NULL)) {\n-        if (ctxt->dictNames) {\n-            const xmlChar *fullname;\n+            \/*\n+             * Handle the rare case of an undefined attribute prefix\n+             *\/\n+            if ((attributes[j+1] != NULL) && (attributes[j+2] == NULL)) {\n+                if (ctxt->dictNames) {\n+                    const xmlChar *fullname;\n@@ -2265,3 +2316,3 @@\n-            fullname = xmlDictQLookup(ctxt->dict, attributes[j+1],\n-                                      attributes[j]);\n-            if (fullname == NULL) {\n+                    fullname = xmlDictQLookup(ctxt->dict, attributes[j+1],\n+                                              attributes[j]);\n+                    if (fullname == NULL) {\n@@ -2275,4 +2326,4 @@\n-        } else {\n-            lname = xmlBuildQName(attributes[j], attributes[j+1],\n-                                  NULL, 0);\n-            if (lname == NULL) {\n+                } else {\n+                    lname = xmlBuildQName(attributes[j], attributes[j+1],\n+                                          NULL, 0);\n+                    if (lname == NULL) {\n@@ -2287,2 +2338,2 @@\n-        }\n-        }\n+                }\n+            }\n@@ -2304,1 +2355,1 @@\n-    }\n+        }\n@@ -2314,1 +2365,1 @@\n-    int chk;\n+        int chk;\n@@ -2316,7 +2367,7 @@\n-    chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);\n-    if (chk <= 0)\n-        ctxt->valid = 0;\n-    if (chk < 0)\n-        ctxt->wellFormed = 0;\n-    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n-    ctxt->vctxt.flags |= XML_VCTXT_DTD_VALIDATED;\n+        chk = xmlValidateDtdFinal(&ctxt->vctxt, ctxt->myDoc);\n+        if (chk <= 0)\n+            ctxt->valid = 0;\n+        if (chk < 0)\n+            ctxt->wellFormed = 0;\n+        ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n+        ctxt->vctxt.flags |= XML_VCTXT_DTD_VALIDATED;\n@@ -2341,1 +2392,1 @@\n-            const xmlChar * URI ATTRIBUTE_UNUSED)\n+                    const xmlChar * URI ATTRIBUTE_UNUSED)\n@@ -2420,11 +2471,11 @@\n-    if (lastChild != NULL) {\n-        ctxt->node->children = lastChild;\n-        ctxt->node->last = lastChild;\n-        lastChild->parent = ctxt->node;\n-        lastChild->doc = ctxt->node->doc;\n-        ctxt->nodelen = len;\n-        ctxt->nodemem = len + 1;\n-    } else {\n-        xmlSAX2ErrMemory(ctxt);\n-        return;\n-    }\n+        if (lastChild != NULL) {\n+            ctxt->node->children = lastChild;\n+            ctxt->node->last = lastChild;\n+            lastChild->parent = ctxt->node;\n+            lastChild->doc = ctxt->node->doc;\n+            ctxt->nodelen = len;\n+            ctxt->nodemem = len + 1;\n+        } else {\n+            xmlSAX2ErrMemory(ctxt);\n+            return;\n+        }\n@@ -2432,3 +2483,3 @@\n-    int coalesceText = (lastChild != NULL) &&\n-        (lastChild->type == type) &&\n-        ((type != XML_TEXT_NODE) ||\n+        int coalesceText = (lastChild != NULL) &&\n+            (lastChild->type == type) &&\n+            (((ctxt->html) && (type != XML_TEXT_NODE)) ||\n@@ -2436,1 +2487,1 @@\n-    if ((coalesceText) && (ctxt->nodemem != 0)) {\n+        if ((coalesceText) && (ctxt->nodemem > 0)) {\n@@ -2441,18 +2492,18 @@\n-        \/*\n-         * The whole point of maintaining nodelen and nodemem,\n-         * xmlTextConcat is too costly, i.e. compute length,\n-         * reallocate a new buffer, move data, append ch. Here\n-         * We try to minimize realloc() uses and avoid copying\n-         * and recomputing length over and over.\n-         *\/\n-        if (lastChild->content == (xmlChar *)&(lastChild->properties)) {\n-        lastChild->content = xmlStrdup(lastChild->content);\n-        lastChild->properties = NULL;\n-        } else if ((ctxt->nodemem == ctxt->nodelen + 1) &&\n-                   (xmlDictOwns(ctxt->dict, lastChild->content))) {\n-        lastChild->content = xmlStrdup(lastChild->content);\n-        }\n-        if (lastChild->content == NULL) {\n-        xmlSAX2ErrMemory(ctxt);\n-        return;\n-         }\n+            \/*\n+             * The whole point of maintaining nodelen and nodemem,\n+             * xmlTextConcat is too costly, i.e. compute length,\n+             * reallocate a new buffer, move data, append ch. Here\n+             * We try to minimize realloc() uses and avoid copying\n+             * and recomputing length over and over.\n+             *\/\n+            if (lastChild->content == (xmlChar *)&(lastChild->properties)) {\n+                lastChild->content = xmlStrdup(lastChild->content);\n+                lastChild->properties = NULL;\n+            } else if ((ctxt->nodemem == ctxt->nodelen + 1) &&\n+                       (xmlDictOwns(ctxt->dict, lastChild->content))) {\n+                lastChild->content = xmlStrdup(lastChild->content);\n+            }\n+            if (lastChild->content == NULL) {\n+                xmlSAX2ErrMemory(ctxt);\n+                return;\n+            }\n@@ -2465,3 +2516,3 @@\n-        if (ctxt->nodelen + len >= ctxt->nodemem) {\n-        xmlChar *newbuf;\n-        int size;\n+            if (ctxt->nodelen + len >= ctxt->nodemem) {\n+                xmlChar *newbuf;\n+                int size;\n@@ -2469,1 +2520,1 @@\n-        size = ctxt->nodemem > INT_MAX - len ?\n+                size = ctxt->nodemem > INT_MAX - len ?\n@@ -2472,1 +2523,1 @@\n-        size = size > INT_MAX \/ 2 ? INT_MAX : size * 2;\n+                size = size > INT_MAX \/ 2 ? INT_MAX : size * 2;\n@@ -2474,20 +2525,20 @@\n-        if (newbuf == NULL) {\n-            xmlSAX2ErrMemory(ctxt);\n-            return;\n-        }\n-        ctxt->nodemem = size;\n-        lastChild->content = newbuf;\n-        }\n-        memcpy(&lastChild->content[ctxt->nodelen], ch, len);\n-        ctxt->nodelen += len;\n-        lastChild->content[ctxt->nodelen] = 0;\n-    } else if (coalesceText) {\n-        if (xmlTextConcat(lastChild, ch, len)) {\n-        xmlSAX2ErrMemory(ctxt);\n-        }\n-        if (ctxt->node->children != NULL) {\n-        ctxt->nodelen = xmlStrlen(lastChild->content);\n-        ctxt->nodemem = ctxt->nodelen + 1;\n-        }\n-    } else {\n-        \/* Mixed content, first time *\/\n+                if (newbuf == NULL) {\n+                    xmlSAX2ErrMemory(ctxt);\n+                    return;\n+                }\n+                ctxt->nodemem = size;\n+                lastChild->content = newbuf;\n+            }\n+            memcpy(&lastChild->content[ctxt->nodelen], ch, len);\n+            ctxt->nodelen += len;\n+            lastChild->content[ctxt->nodelen] = 0;\n+        } else if (coalesceText) {\n+            if (xmlTextConcat(lastChild, ch, len)) {\n+                xmlSAX2ErrMemory(ctxt);\n+            }\n+            if (ctxt->node->children != NULL) {\n+                ctxt->nodelen = xmlStrlen(lastChild->content);\n+                ctxt->nodemem = ctxt->nodelen + 1;\n+            }\n+        } else {\n+            \/* Mixed content, first time *\/\n@@ -2500,1 +2551,1 @@\n-        if (lastChild == NULL) {\n+            if (lastChild == NULL) {\n@@ -2503,5 +2554,6 @@\n-        xmlSAX2AppendChild(ctxt, lastChild);\n-        if (ctxt->node->children != NULL) {\n-            ctxt->nodelen = len;\n-            ctxt->nodemem = len + 1;\n-        }\n+                xmlSAX2AppendChild(ctxt, lastChild);\n+                if (ctxt->node->children != NULL) {\n+                    ctxt->nodelen = len;\n+                    ctxt->nodemem = len + 1;\n+                }\n+            }\n@@ -2510,1 +2562,0 @@\n-    }\n@@ -2521,1 +2572,1 @@\n-                lastChild->psvi = (void *) (ptrdiff_t) ctxt->input->line;\n+                lastChild->psvi = XML_INT_TO_PTR(ctxt->input->line);\n@@ -2618,2 +2669,0 @@\n-static int xmlSAX2DefaultVersionValue = 2;\n-\n@@ -2623,1 +2672,1 @@\n- * @version:  the version, 1 or 2\n+ * @version:  the version, must be 2\n@@ -2627,5 +2676,1 @@\n- * Set the default version of SAX used globally by the library.\n- * By default, during initialization the default is set to 2.\n- * Note that it is generally a better coding style to use\n- * xmlSAXVersion() to set up the version explicitly for a given\n- * parsing context.\n+ * Has no effect.\n@@ -2633,1 +2678,1 @@\n- * Returns the previous value in case of success and -1 in case of error.\n+ * Returns 2 in case of success and -1 in case of error.\n@@ -2638,3 +2683,1 @@\n-    int ret = xmlSAX2DefaultVersionValue;\n-\n-    if ((version != 1) && (version != 2))\n+    if (version != 2)\n@@ -2642,2 +2685,1 @@\n-    xmlSAX2DefaultVersionValue = version;\n-    return(ret);\n+    return(2);\n@@ -2661,4 +2703,4 @@\n-    hdlr->startElementNs = xmlSAX2StartElementNs;\n-    hdlr->endElementNs = xmlSAX2EndElementNs;\n-    hdlr->serror = NULL;\n-    hdlr->initialized = XML_SAX2_MAGIC;\n+        hdlr->startElementNs = xmlSAX2StartElementNs;\n+        hdlr->endElementNs = xmlSAX2EndElementNs;\n+        hdlr->serror = NULL;\n+        hdlr->initialized = XML_SAX2_MAGIC;\n@@ -2667,1 +2709,1 @@\n-    hdlr->initialized = 1;\n+        hdlr->initialized = 1;\n@@ -2718,1 +2760,1 @@\n-    return;\n+        return;\n@@ -2720,1 +2762,1 @@\n-    xmlSAXVersion(hdlr, xmlSAX2DefaultVersionValue);\n+    xmlSAXVersion(hdlr, 2);\n@@ -2722,3 +2764,1 @@\n-    hdlr->warning = NULL;\n-    else\n-    hdlr->warning = xmlParserWarning;\n+        hdlr->warning = NULL;\n@@ -2752,1 +2792,1 @@\n-    return;\n+        return;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/SAX2.c","additions":1010,"deletions":970,"binary":false,"changes":1980,"status":"modified"},{"patch":"@@ -18,1 +18,1 @@\n-#include <string.h> \/* for memset() only ! *\/\n+#include <string.h>\n@@ -20,2 +20,0 @@\n-#include <ctype.h>\n-#include <stdlib.h>\n@@ -23,0 +21,1 @@\n+#include <libxml\/parser.h>\n@@ -24,1 +23,0 @@\n-#include <libxml\/parserInternals.h> \/* for XML_MAX_TEXT_LENGTH *\/\n@@ -27,1 +25,0 @@\n-#include \"private\/error.h\"\n@@ -35,0 +32,7 @@\n+#define BUF_FLAG_OOM        (1u << 0)\n+#define BUF_FLAG_OVERFLOW   (1u << 1)\n+#define BUF_FLAG_STATIC     (1u << 2)\n+\n+#define BUF_ERROR(buf) ((buf)->flags & (BUF_FLAG_OOM | BUF_FLAG_OVERFLOW))\n+#define BUF_STATIC(buf) ((buf)->flags & BUF_FLAG_STATIC)\n+\n@@ -44,1 +48,2 @@\n-    xmlChar *content;        \/* The buffer content UTF8 *\/\n+    xmlChar *content;           \/* The buffer content UTF8 *\/\n+#ifdef WITH_BUFFER_COMPAT\n@@ -47,6 +52,6 @@\n-    xmlBufferAllocationScheme alloc; \/* The realloc method *\/\n-    xmlChar *contentIO;        \/* in IO mode we may have a different base *\/\n-    size_t use;                \/* The buffer size used *\/\n-    size_t size;        \/* The buffer size *\/\n-    xmlBufferPtr buffer;        \/* wrapper for an old buffer *\/\n-    int error;                  \/* an error code if a failure occurred *\/\n+#endif\n+    xmlChar *mem;               \/* Start of the allocation *\/\n+    size_t use;                 \/* The buffer size used *\/\n+    size_t size;                \/* The buffer size, excluding terminating 0 *\/\n+    size_t maxSize;             \/* The maximum buffer size *\/\n+    unsigned flags;             \/* flags *\/\n@@ -60,1 +65,1 @@\n-#define UPDATE_COMPAT(buf)                    \\\n+#define UPDATE_COMPAT(buf)                                  \\\n@@ -62,1 +67,1 @@\n-     else buf->compat_size = INT_MAX;                \\\n+     else buf->compat_size = INT_MAX;                       \\\n@@ -71,7 +76,7 @@\n-#define CHECK_COMPAT(buf)                    \\\n-     if (buf->size != (size_t) buf->compat_size)        \\\n-         if (buf->compat_size < INT_MAX)            \\\n-         buf->size = buf->compat_size;            \\\n-     if (buf->use != (size_t) buf->compat_use)            \\\n-         if (buf->compat_use < INT_MAX)                \\\n-         buf->use = buf->compat_use;\n+#define CHECK_COMPAT(buf)                                   \\\n+     if (buf->size != (size_t) buf->compat_size)            \\\n+         if (buf->compat_size < INT_MAX)                    \\\n+             buf->size = buf->compat_size;                  \\\n+     if (buf->use != (size_t) buf->compat_use)              \\\n+         if (buf->compat_use < INT_MAX)                     \\\n+             buf->use = buf->compat_use;\n@@ -94,2 +99,2 @@\n-    if (buf->error == 0)\n-        buf->error = XML_ERR_NO_MEMORY;\n+    if (!BUF_ERROR(buf))\n+        buf->flags |= BUF_FLAG_OOM;\n@@ -108,2 +113,2 @@\n-    if (buf->error == 0)\n-        buf->error = XML_BUF_OVERFLOW;\n+    if (!BUF_ERROR(buf))\n+        buf->flags |= BUF_FLAG_OVERFLOW;\n@@ -112,1 +117,0 @@\n-\n@@ -115,0 +119,1 @@\n+ * @size: initial size of buffer\n@@ -120,1 +125,1 @@\n-xmlBufCreate(void) {\n+xmlBufCreate(size_t size) {\n@@ -123,1 +128,4 @@\n-    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));\n+    if (size == SIZE_MAX)\n+        return(NULL);\n+\n+    ret = xmlMalloc(sizeof(*ret));\n@@ -126,0 +134,1 @@\n+\n@@ -127,8 +136,7 @@\n-    ret->error = 0;\n-    ret->buffer = NULL;\n-    ret->size = xmlDefaultBufferSize;\n-    UPDATE_COMPAT(ret);\n-    ret->alloc = xmlBufferAllocScheme;\n-    ret->content = (xmlChar *) xmlMallocAtomic(ret->size);\n-    if (ret->content == NULL) {\n-    xmlFree(ret);\n+    ret->flags = 0;\n+    ret->size = size;\n+    ret->maxSize = SIZE_MAX - 1;\n+\n+    ret->mem = xmlMalloc(ret->size + 1);\n+    if (ret->mem == NULL) {\n+        xmlFree(ret);\n@@ -137,0 +145,1 @@\n+    ret->content = ret->mem;\n@@ -138,1 +147,2 @@\n-    ret->contentIO = NULL;\n+\n+    UPDATE_COMPAT(ret);\n@@ -143,2 +153,4 @@\n- * xmlBufCreateSize:\n- * @size: initial size of buffer\n+ * xmlBufCreateMem:\n+ * @mem:  a memory area\n+ * @size:  size of the buffer excluding terminator\n+ * @isStatic:  whether the memory area is static\n@@ -146,2 +158,8 @@\n- * routine to create an XML buffer.\n- * returns the new structure.\n+ * Create a buffer initialized with memory.\n+ *\n+ * If @isStatic is set, uses the memory area directly as backing store.\n+ * The memory must be zero-terminated and not be modified for the\n+ * lifetime of the buffer. A static buffer can't be grown, modified or\n+ * detached, but it can be shrunk.\n+ *\n+ * Returns a new buffer.\n@@ -150,1 +168,1 @@\n-xmlBufCreateSize(size_t size) {\n+xmlBufCreateMem(const xmlChar *mem, size_t size, int isStatic) {\n@@ -153,1 +171,1 @@\n-    if (size == SIZE_MAX)\n+    if (mem == NULL)\n@@ -155,1 +173,2 @@\n-    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));\n+\n+    ret = xmlMalloc(sizeof(*ret));\n@@ -158,9 +177,4 @@\n-    ret->use = 0;\n-    ret->error = 0;\n-    ret->buffer = NULL;\n-    ret->alloc = xmlBufferAllocScheme;\n-    ret->size = (size ? size + 1 : 0);         \/* +1 for ending null *\/\n-    UPDATE_COMPAT(ret);\n-    if (ret->size){\n-        ret->content = (xmlChar *) xmlMallocAtomic(ret->size);\n-        if (ret->content == NULL) {\n+\n+    if (isStatic) {\n+        \/* Check that memory is zero-terminated *\/\n+        if (mem[size] != 0) {\n@@ -170,4 +184,19 @@\n-        ret->content[0] = 0;\n-    } else\n-    ret->content = NULL;\n-    ret->contentIO = NULL;\n+        ret->flags = BUF_FLAG_STATIC;\n+        ret->mem = (xmlChar *) mem;\n+    } else {\n+        ret->flags = 0;\n+        ret->mem = xmlMalloc(size + 1);\n+        if (ret->mem == NULL) {\n+            xmlFree(ret);\n+            return(NULL);\n+        }\n+        memcpy(ret->mem, mem, size);\n+        ret->mem[size] = 0;\n+    }\n+\n+    ret->use = size;\n+    ret->size = size;\n+    ret->maxSize = SIZE_MAX - 1;\n+    ret->content = ret->mem;\n+\n+    UPDATE_COMPAT(ret);\n@@ -191,5 +220,1 @@\n-    if (buf == NULL)\n-        return(NULL);\n-    if (buf->buffer != NULL)\n-        return(NULL);\n-    if (buf->error)\n+    if ((buf == NULL) || (BUF_ERROR(buf)) || (BUF_STATIC(buf)))\n@@ -198,2 +223,1 @@\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&\n-        (buf->content != buf->contentIO)) {\n+    if (buf->content != buf->mem) {\n@@ -201,1 +225,1 @@\n-        xmlFree(buf->contentIO);\n+        xmlFree(buf->mem);\n@@ -203,1 +227,1 @@\n-        ret = buf->content;\n+        ret = buf->mem;\n@@ -207,1 +231,1 @@\n-    buf->contentIO = NULL;\n+    buf->mem = NULL;\n@@ -210,1 +234,0 @@\n-    UPDATE_COMPAT(buf);\n@@ -212,0 +235,1 @@\n+    UPDATE_COMPAT(buf);\n@@ -215,53 +239,0 @@\n-\/**\n- * xmlBufGetAllocationScheme:\n- * @buf:  the buffer\n- *\n- * Get the buffer allocation scheme\n- *\n- * Returns the scheme or -1 in case of error\n- *\/\n-int\n-xmlBufGetAllocationScheme(xmlBufPtr buf) {\n-    if (buf == NULL) {\n-        return(-1);\n-    }\n-    return(buf->alloc);\n-}\n-\n-\/**\n- * xmlBufSetAllocationScheme:\n- * @buf:  the buffer to tune\n- * @scheme:  allocation scheme to use\n- *\n- * Sets the allocation scheme for this buffer\n- *\n- * returns 0 in case of success and -1 in case of failure\n- *\/\n-int\n-xmlBufSetAllocationScheme(xmlBufPtr buf,\n-                          xmlBufferAllocationScheme scheme) {\n-    if ((buf == NULL) || (buf->error != 0)) {\n-        return(-1);\n-    }\n-    if (buf->alloc == XML_BUFFER_ALLOC_IO)\n-        return(-1);\n-    if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||\n-        (scheme == XML_BUFFER_ALLOC_EXACT) ||\n-        (scheme == XML_BUFFER_ALLOC_HYBRID) ||\n-    (scheme == XML_BUFFER_ALLOC_BOUNDED)) {\n-    buf->alloc = scheme;\n-        if (buf->buffer)\n-            buf->buffer->alloc = scheme;\n-        return(0);\n-    }\n-    \/*\n-     * Switching a buffer ALLOC_IO has the side effect of initializing\n-     * the contentIO field with the current content\n-     *\/\n-    if (scheme == XML_BUFFER_ALLOC_IO) {\n-        buf->alloc = XML_BUFFER_ALLOC_IO;\n-        buf->contentIO = buf->content;\n-    }\n-    return(-1);\n-}\n-\n@@ -277,3 +248,2 @@\n-    if (buf == NULL) {\n-    return;\n-    }\n+    if (buf == NULL)\n+        return;\n@@ -281,6 +251,2 @@\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&\n-        (buf->contentIO != NULL)) {\n-        xmlFree(buf->contentIO);\n-    } else if (buf->content != NULL) {\n-        xmlFree(buf->content);\n-    }\n+    if (!BUF_STATIC(buf))\n+        xmlFree(buf->mem);\n@@ -298,2 +264,4 @@\n-    if ((buf == NULL) || (buf->error != 0)) return;\n-    if (buf->content == NULL) return;\n+    if ((buf == NULL) || (BUF_ERROR(buf)) || (BUF_STATIC(buf)))\n+        return;\n+    if (buf->mem == NULL)\n+        return;\n@@ -301,0 +269,1 @@\n+\n@@ -302,3 +271,3 @@\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&\n-               (buf->contentIO != NULL)) {\n-        size_t start_buf = buf->content - buf->contentIO;\n+    buf->size += buf->content - buf->mem;\n+    buf->content = buf->mem;\n+    buf->content[0] = 0;\n@@ -306,6 +275,0 @@\n-    buf->size += start_buf;\n-        buf->content = buf->contentIO;\n-        buf->content[0] = 0;\n-    } else {\n-        buf->content[0] = 0;\n-    }\n@@ -320,0 +283,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -329,1 +294,4 @@\n-    if ((buf == NULL) || (buf->error != 0)) return(0);\n+    if ((buf == NULL) || (BUF_ERROR(buf)))\n+        return(0);\n+    if (len == 0)\n+        return(0);\n@@ -331,2 +299,3 @@\n-    if (len == 0) return(0);\n-    if (len > buf->use) return(0);\n+\n+    if (len > buf->use)\n+        return(0);\n@@ -335,6 +304,1 @@\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n-    \/*\n-     * we just move the content pointer, but also make sure\n-     * the perceived buffer size has shrunk accordingly\n-     *\/\n-        buf->content += len;\n+    buf->content += len;\n@@ -343,17 +307,0 @@\n-        \/*\n-     * sometimes though it maybe be better to really shrink\n-     * on IO buffers\n-     *\/\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n-        size_t start_buf = buf->content - buf->contentIO;\n-        if (start_buf >= buf->size) {\n-        memmove(buf->contentIO, &buf->content[0], buf->use);\n-        buf->content = buf->contentIO;\n-        buf->content[buf->use] = 0;\n-        buf->size += start_buf;\n-        }\n-    }\n-    } else {\n-    memmove(buf->content, &buf->content[len], buf->use);\n-    buf->content[buf->use] = 0;\n-    }\n@@ -370,2 +317,0 @@\n- * Error checking should be done on buf->error since using the return\n- * value doesn't work that well\n@@ -373,1 +318,1 @@\n- * Returns 0 in case of error or the length made available otherwise\n+ * Returns 0 on success, -1 in case of error\n@@ -375,1 +320,1 @@\n-static size_t\n+static int\n@@ -378,0 +323,1 @@\n+    size_t start;\n@@ -380,7 +326,9 @@\n-    if ((buf == NULL) || (buf->error != 0)) return(0);\n-    CHECK_COMPAT(buf)\n-\n-    if (len < buf->size - buf->use)\n-        return(buf->size - buf->use - 1);\n-    if (len >= SIZE_MAX - buf->use) {\n-        xmlBufMemoryError(buf);\n+    \/*\n+     * If there's enough space at the start of the buffer,\n+     * move the contents.\n+     *\/\n+    start = buf->content - buf->mem;\n+    if (len <= start + buf->size - buf->use) {\n+        memmove(buf->mem, buf->content, buf->use + 1);\n+        buf->size += start;\n+        buf->content = buf->mem;\n@@ -390,0 +338,5 @@\n+    if (len > buf->maxSize - buf->use) {\n+        xmlBufOverflowError(buf);\n+        return(-1);\n+    }\n+\n@@ -391,1 +344,4 @@\n-        size = buf->size > SIZE_MAX \/ 2 ? SIZE_MAX : buf->size * 2;\n+        if (buf->size <= buf->maxSize \/ 2)\n+            size = buf->size * 2;\n+        else\n+            size = buf->maxSize;\n@@ -394,11 +350,2 @@\n-        size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;\n-    }\n-\n-    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {\n-        \/*\n-     * Used to provide parsing limits\n-     *\/\n-        if ((buf->use + len + 1 >= XML_MAX_TEXT_LENGTH) ||\n-        (buf->size >= XML_MAX_TEXT_LENGTH)) {\n-        xmlBufMemoryError(buf);\n-        return(0);\n+        if (size <= buf->maxSize - 100)\n+            size += 100;\n@@ -406,5 +353,0 @@\n-    if (size >= XML_MAX_TEXT_LENGTH)\n-        size = XML_MAX_TEXT_LENGTH;\n-    }\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n-        size_t start_buf = buf->content - buf->contentIO;\n@@ -412,7 +354,6 @@\n-    newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);\n-    if (newbuf == NULL) {\n-        xmlBufMemoryError(buf);\n-        return(0);\n-    }\n-    buf->contentIO = newbuf;\n-    buf->content = newbuf + start_buf;\n+    if (buf->content == buf->mem) {\n+        newbuf = xmlRealloc(buf->mem, size + 1);\n+        if (newbuf == NULL) {\n+            xmlBufMemoryError(buf);\n+            return(-1);\n+        }\n@@ -420,4 +361,8 @@\n-    newbuf = (xmlChar *) xmlRealloc(buf->content, size);\n-    if (newbuf == NULL) {\n-        xmlBufMemoryError(buf);\n-        return(0);\n+        newbuf = xmlMalloc(size + 1);\n+        if (newbuf == NULL) {\n+            xmlBufMemoryError(buf);\n+            return(-1);\n+        }\n+        if (buf->content != NULL)\n+            memcpy(newbuf, buf->content, buf->use + 1);\n+        xmlFree(buf->mem);\n@@ -425,0 +370,2 @@\n+\n+    buf->mem = newbuf;\n@@ -426,1 +373,0 @@\n-    }\n@@ -428,2 +374,2 @@\n-    UPDATE_COMPAT(buf)\n-    return(buf->size - buf->use - 1);\n+\n+    return(0);\n@@ -440,1 +386,1 @@\n- * Returns -1 in case of error or the length made available otherwise\n+ * Returns 0 on succes, -1 in case of error\n@@ -443,2 +389,4 @@\n-xmlBufGrow(xmlBufPtr buf, int len) {\n-    size_t ret;\n+xmlBufGrow(xmlBufPtr buf, size_t len) {\n+    if ((buf == NULL) || (BUF_ERROR(buf)) || (BUF_STATIC(buf)))\n+        return(-1);\n+    CHECK_COMPAT(buf)\n@@ -446,2 +394,1 @@\n-    if ((buf == NULL) || (len < 0)) return(-1);\n-    if (len == 0)\n+    if (len <= buf->size - buf->use)\n@@ -449,5 +396,0 @@\n-    ret = xmlBufGrowInternal(buf, len);\n-    if (buf->error != 0)\n-        return(-1);\n-    return(ret > INT_MAX ? INT_MAX : ret);\n-}\n@@ -455,11 +397,2 @@\n-\/**\n- * xmlBufDump:\n- * @file:  the file output\n- * @buf:  the buffer to dump\n- *\n- * Dumps an XML buffer to  a FILE *.\n- * Returns the number of #xmlChar written\n- *\/\n-size_t\n-xmlBufDump(FILE *file, xmlBufPtr buf) {\n-    size_t ret;\n+    if (xmlBufGrowInternal(buf, len) < 0)\n+        return(-1);\n@@ -467,4 +400,1 @@\n-    if ((buf == NULL) || (buf->error != 0)) {\n-    return(0);\n-    }\n-    if (buf->content == NULL) {\n+    UPDATE_COMPAT(buf)\n@@ -472,6 +402,0 @@\n-    }\n-    CHECK_COMPAT(buf)\n-    if (file == NULL)\n-    file = stdout;\n-    ret = fwrite(buf->content, 1, buf->use, file);\n-    return(ret);\n@@ -492,1 +416,1 @@\n-    if ((!buf) || (buf->error))\n+    if ((!buf) || (BUF_ERROR(buf)))\n@@ -510,1 +434,1 @@\n-    if ((!buf) || (buf->error))\n+    if ((!buf) || (BUF_ERROR(buf)))\n@@ -530,1 +454,1 @@\n-    if ((buf == NULL) || (buf->error))\n+    if ((buf == NULL) || (BUF_ERROR(buf)) || (BUF_STATIC(buf)))\n@@ -533,1 +457,1 @@\n-    if (len >= (buf->size - buf->use))\n+    if (len > buf->size - buf->use)\n@@ -541,19 +465,0 @@\n-\/**\n- * xmlBufLength:\n- * @buf:  the buffer\n- *\n- * Function to get the length of a buffer\n- *\n- * Returns the length of data in the internal content\n- *\/\n-\n-size_t\n-xmlBufLength(const xmlBufPtr buf)\n-{\n-    if ((!buf) || (buf->error))\n-        return 0;\n-    CHECK_COMPAT(buf)\n-\n-    return(buf->use);\n-}\n-\n@@ -572,1 +477,1 @@\n-    if ((!buf) || (buf->error))\n+    if ((!buf) || (BUF_ERROR(buf)))\n@@ -594,1 +499,1 @@\n-    if ((!buf) || (buf->error))\n+    if ((!buf) || (BUF_ERROR(buf)))\n@@ -598,1 +503,1 @@\n-    return((buf->size > buf->use) ? (buf->size - buf->use - 1) : 0);\n+    return(buf->size - buf->use);\n@@ -612,1 +517,1 @@\n-    if ((!buf) || (buf->error))\n+    if ((!buf) || (BUF_ERROR(buf)))\n@@ -619,126 +524,0 @@\n-\/**\n- * xmlBufResize:\n- * @buf:  the buffer to resize\n- * @size:  the desired size\n- *\n- * Resize a buffer to accommodate minimum size of @size.\n- *\n- * Returns  0 in case of problems, 1 otherwise\n- *\/\n-int\n-xmlBufResize(xmlBufPtr buf, size_t size)\n-{\n-    size_t newSize;\n-    xmlChar* rebuf = NULL;\n-    size_t start_buf;\n-\n-    if ((buf == NULL) || (buf->error))\n-        return(0);\n-    CHECK_COMPAT(buf)\n-\n-    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {\n-        \/*\n-     * Used to provide parsing limits\n-     *\/\n-        if (size >= XML_MAX_TEXT_LENGTH) {\n-        xmlBufMemoryError(buf);\n-        return(0);\n-    }\n-    }\n-\n-    \/* Don't resize if we don't have to *\/\n-    if (size < buf->size)\n-        return 1;\n-\n-    \/* figure out new size *\/\n-    switch (buf->alloc){\n-    case XML_BUFFER_ALLOC_IO:\n-    case XML_BUFFER_ALLOC_DOUBLEIT:\n-        \/*take care of empty case*\/\n-            if (buf->size == 0) {\n-                newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);\n-            } else {\n-                newSize = buf->size;\n-            }\n-        while (size > newSize) {\n-            if (newSize > SIZE_MAX \/ 2) {\n-                xmlBufMemoryError(buf);\n-                return 0;\n-            }\n-            newSize *= 2;\n-        }\n-        break;\n-    case XML_BUFFER_ALLOC_EXACT:\n-            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);\n-        break;\n-        case XML_BUFFER_ALLOC_HYBRID:\n-            if (buf->use < BASE_BUFFER_SIZE)\n-                newSize = size;\n-            else {\n-                newSize = buf->size;\n-                while (size > newSize) {\n-                    if (newSize > SIZE_MAX \/ 2) {\n-                        xmlBufMemoryError(buf);\n-                        return 0;\n-                    }\n-                    newSize *= 2;\n-                }\n-            }\n-            break;\n-\n-    default:\n-            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);\n-        break;\n-    }\n-\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n-        start_buf = buf->content - buf->contentIO;\n-\n-        if (start_buf > newSize) {\n-        \/* move data back to start *\/\n-        memmove(buf->contentIO, buf->content, buf->use);\n-        buf->content = buf->contentIO;\n-        buf->content[buf->use] = 0;\n-        buf->size += start_buf;\n-    } else {\n-        rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);\n-        if (rebuf == NULL) {\n-        xmlBufMemoryError(buf);\n-        return 0;\n-        }\n-        buf->contentIO = rebuf;\n-        buf->content = rebuf + start_buf;\n-    }\n-    } else {\n-    if (buf->content == NULL) {\n-        rebuf = (xmlChar *) xmlMallocAtomic(newSize);\n-        buf->use = 0;\n-            if (rebuf != NULL)\n-            rebuf[buf->use] = 0;\n-    } else if (buf->size - buf->use < 100) {\n-        rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);\n-        } else {\n-        \/*\n-         * if we are reallocating a buffer far from being full, it's\n-         * better to make a new allocation and copy only the used range\n-         * and free the old one.\n-         *\/\n-        rebuf = (xmlChar *) xmlMallocAtomic(newSize);\n-        if (rebuf != NULL) {\n-        memcpy(rebuf, buf->content, buf->use);\n-        xmlFree(buf->content);\n-        rebuf[buf->use] = 0;\n-        }\n-    }\n-    if (rebuf == NULL) {\n-        xmlBufMemoryError(buf);\n-        return 0;\n-    }\n-    buf->content = rebuf;\n-    }\n-    buf->size = newSize;\n-    UPDATE_COMPAT(buf)\n-\n-    return 1;\n-}\n-\n@@ -757,5 +536,7 @@\n-xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len) {\n-    size_t needSize;\n-\n-    if ((str == NULL) || (buf == NULL) || (buf->error))\n-    return -1;\n+xmlBufAdd(xmlBufPtr buf, const xmlChar *str, size_t len) {\n+    if ((buf == NULL) || (BUF_ERROR(buf)) || (BUF_STATIC(buf)))\n+        return(-1);\n+    if (len == 0)\n+        return(0);\n+    if (str == NULL)\n+        return(-1);\n@@ -764,28 +545,2 @@\n-    if (len < -1) {\n-    return -1;\n-    }\n-    if (len == 0) return 0;\n-\n-    if (len < 0)\n-        len = xmlStrlen(str);\n-\n-    if (len < 0) return -1;\n-    if (len == 0) return 0;\n-\n-    \/* Note that both buf->size and buf->use can be zero here. *\/\n-    if ((size_t) len >= buf->size - buf->use) {\n-        if ((size_t) len >= SIZE_MAX - buf->use) {\n-            xmlBufMemoryError(buf);\n-            return(-1);\n-        }\n-        needSize = buf->use + len + 1;\n-    if (buf->alloc == XML_BUFFER_ALLOC_BOUNDED) {\n-        \/*\n-         * Used to provide parsing limits\n-         *\/\n-        if (needSize >= XML_MAX_TEXT_LENGTH) {\n-        xmlBufMemoryError(buf);\n-        return(-1);\n-        }\n-    }\n-        if (!xmlBufResize(buf, needSize))\n+    if (len > buf->size - buf->use) {\n+        if (xmlBufGrowInternal(buf, len) < 0)\n@@ -798,0 +553,1 @@\n+\n@@ -799,1 +555,1 @@\n-    return 0;\n+    return(0);\n@@ -805,1 +561,1 @@\n- * @str:  the #xmlChar string\n+ * @str:  the #xmlChar string (optional)\n@@ -814,5 +570,3 @@\n-    if ((buf == NULL) || (buf->error))\n-        return(-1);\n-    CHECK_COMPAT(buf)\n-    if (str == NULL) return -1;\n-    return xmlBufAdd(buf, str, -1);\n+    if (str == NULL)\n+        return(0);\n+    return(xmlBufAdd(buf, str, strlen((const char *) str)));\n@@ -839,2 +593,2 @@\n-    ret = (xmlBufPtr) xmlMalloc(sizeof(xmlBuf));\n-    if (ret == NULL) {\n+    ret = xmlMalloc(sizeof(xmlBuf));\n+    if (ret == NULL)\n@@ -842,1 +596,1 @@\n-    }\n+\n@@ -844,7 +598,19 @@\n-    ret->size = buffer->size;\n-    UPDATE_COMPAT(ret);\n-    ret->error = 0;\n-    ret->buffer = buffer;\n-    ret->alloc = buffer->alloc;\n-    ret->content = buffer->content;\n-    ret->contentIO = buffer->contentIO;\n+    ret->flags = 0;\n+    ret->maxSize = SIZE_MAX - 1;\n+\n+    if (buffer->content == NULL) {\n+        ret->size = 50;\n+        ret->mem = xmlMalloc(ret->size + 1);\n+        ret->content = ret->mem;\n+        if (ret->mem == NULL)\n+            xmlBufMemoryError(ret);\n+        else\n+            ret->content[0] = 0;\n+    } else {\n+        ret->size = buffer->size - 1;\n+        ret->content = buffer->content;\n+        if (buffer->alloc == XML_BUFFER_ALLOC_IO)\n+            ret->mem = buffer->contentIO;\n+        else\n+            ret->mem = buffer->content;\n+    }\n@@ -852,0 +618,1 @@\n+    UPDATE_COMPAT(ret);\n@@ -858,0 +625,1 @@\n+ * @ret: old buffer\n@@ -865,1 +633,1 @@\n- * Returns the old xmlBufferPtr unless the call failed and NULL is returned\n+ * Returns 0 on success, -1 on error.\n@@ -867,8 +635,4 @@\n-xmlBufferPtr\n-xmlBufBackToBuffer(xmlBufPtr buf) {\n-    xmlBufferPtr ret;\n-\n-    if (buf == NULL)\n-        return(NULL);\n-    CHECK_COMPAT(buf)\n-    ret = buf->buffer;\n+int\n+xmlBufBackToBuffer(xmlBufPtr buf, xmlBufferPtr ret) {\n+    if ((buf == NULL) || (ret == NULL))\n+        return(-1);\n@@ -876,1 +640,2 @@\n-    if ((buf->error) || (ret == NULL)) {\n+    if ((BUF_ERROR(buf)) || (BUF_STATIC(buf)) ||\n+        (buf->use >= INT_MAX)) {\n@@ -878,7 +643,5 @@\n-        if (ret != NULL) {\n-            ret->content = NULL;\n-            ret->contentIO = NULL;\n-            ret->use = 0;\n-            ret->size = 0;\n-        }\n-        return(NULL);\n+        ret->content = NULL;\n+        ret->contentIO = NULL;\n+        ret->use = 0;\n+        ret->size = 0;\n+        return(-1);\n@@ -887,21 +650,3 @@\n-    \/*\n-     * What to do in case of error in the buffer ???\n-     *\/\n-    if (buf->use > INT_MAX) {\n-        \/*\n-         * Worse case, we really allocated and used more than the\n-         * maximum allowed memory for an xmlBuffer on this architecture.\n-         * Keep the buffer but provide a truncated size value.\n-         *\/\n-        xmlBufOverflowError(buf);\n-        ret->use = INT_MAX;\n-        ret->size = INT_MAX;\n-    } else if (buf->size > INT_MAX) {\n-        \/*\n-         * milder case, we allocated more than the maximum allowed memory\n-         * for an xmlBuffer on this architecture, but used less than the\n-         * limit.\n-         * Keep the buffer but provide a truncated size value.\n-         *\/\n-        xmlBufOverflowError(buf);\n-        ret->use = buf->use;\n+    ret->use = buf->use;\n+    if (buf->size >= INT_MAX) {\n+        \/* Keep the buffer but provide a truncated size value. *\/\n@@ -910,2 +655,1 @@\n-        ret->use = buf->use;\n-        ret->size = buf->size;\n+        ret->size = buf->size + 1;\n@@ -913,1 +657,1 @@\n-    ret->alloc = buf->alloc;\n+    ret->alloc = XML_BUFFER_ALLOC_IO;\n@@ -915,1 +659,1 @@\n-    ret->contentIO = buf->contentIO;\n+    ret->contentIO = buf->mem;\n@@ -917,1 +661,1 @@\n-    return(ret);\n+    return(0);\n@@ -956,0 +700,577 @@\n+\/************************************************************************\n+ *                                                                      *\n+ *                      Old buffer implementation                       *\n+ *                                                                      *\n+ ************************************************************************\/\n+\n+\/**\n+ * xmlSetBufferAllocationScheme:\n+ * @scheme:  allocation method to use\n+ *\n+ * DEPRECATED: Use xmlBufferSetAllocationScheme.\n+ *\n+ * Set the buffer allocation method.  Types are\n+ * XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down\n+ * XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed,\n+ *                             improves performance\n+ *\/\n+void\n+xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme ATTRIBUTE_UNUSED) {\n+}\n+\n+\/**\n+ * xmlGetBufferAllocationScheme:\n+ *\n+ * DEPRECATED: Use xmlBufferSetAllocationScheme.\n+ *\n+ * Types are\n+ * XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down\n+ * XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed,\n+ *                             improves performance\n+ * XML_BUFFER_ALLOC_HYBRID - use exact sizes on small strings to keep memory usage tight\n+ *                            in normal usage, and doubleit on large strings to avoid\n+ *                            pathological performance.\n+ *\n+ * Returns the current allocation scheme\n+ *\/\n+xmlBufferAllocationScheme\n+xmlGetBufferAllocationScheme(void) {\n+    return(XML_BUFFER_ALLOC_EXACT);\n+}\n+\n+\/**\n+ * xmlBufferCreate:\n+ *\n+ * routine to create an XML buffer.\n+ * returns the new structure.\n+ *\/\n+xmlBufferPtr\n+xmlBufferCreate(void) {\n+    xmlBufferPtr ret;\n+\n+    ret = xmlMalloc(sizeof(*ret));\n+    if (ret == NULL)\n+        return(NULL);\n+\n+    ret->use = 0;\n+    ret->size = 256;\n+    ret->alloc = XML_BUFFER_ALLOC_IO;\n+    ret->contentIO = xmlMalloc(ret->size);\n+    if (ret->contentIO == NULL) {\n+        xmlFree(ret);\n+        return(NULL);\n+    }\n+    ret->content = ret->contentIO;\n+    ret->content[0] = 0;\n+\n+    return(ret);\n+}\n+\n+\/**\n+ * xmlBufferCreateSize:\n+ * @size: initial size of buffer\n+ *\n+ * routine to create an XML buffer.\n+ * returns the new structure.\n+ *\/\n+xmlBufferPtr\n+xmlBufferCreateSize(size_t size) {\n+    xmlBufferPtr ret;\n+\n+    if (size >= INT_MAX)\n+        return(NULL);\n+\n+    ret = xmlMalloc(sizeof(*ret));\n+    if (ret == NULL)\n+        return(NULL);\n+\n+    ret->use = 0;\n+    ret->alloc = XML_BUFFER_ALLOC_IO;\n+    ret->size = (size ? size + 1 : 0);         \/* +1 for ending null *\/\n+\n+    if (ret->size) {\n+        ret->contentIO = xmlMalloc(ret->size);\n+        if (ret->contentIO == NULL) {\n+            xmlFree(ret);\n+            return(NULL);\n+        }\n+        ret->content = ret->contentIO;\n+        ret->content[0] = 0;\n+    } else {\n+        ret->contentIO = NULL;\n+        ret->content = NULL;\n+    }\n+\n+    return(ret);\n+}\n+\n+\/**\n+ * xmlBufferDetach:\n+ * @buf:  the buffer\n+ *\n+ * Remove the string contained in a buffer and gie it back to the\n+ * caller. The buffer is reset to an empty content.\n+ * This doesn't work with immutable buffers as they can't be reset.\n+ *\n+ * Returns the previous string contained by the buffer.\n+ *\/\n+xmlChar *\n+xmlBufferDetach(xmlBufferPtr buf) {\n+    xmlChar *ret;\n+\n+    if (buf == NULL)\n+        return(NULL);\n+\n+    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&\n+        (buf->content != buf->contentIO)) {\n+        ret = xmlStrndup(buf->content, buf->use);\n+        xmlFree(buf->contentIO);\n+    } else {\n+        ret = buf->content;\n+    }\n+\n+    buf->contentIO = NULL;\n+    buf->content = NULL;\n+    buf->size = 0;\n+    buf->use = 0;\n+\n+    return ret;\n+}\n+\n+\/**\n+ * xmlBufferCreateStatic:\n+ * @mem: the memory area\n+ * @size:  the size in byte\n+ *\n+ * Returns an XML buffer initialized with bytes.\n+ *\/\n+xmlBufferPtr\n+xmlBufferCreateStatic(void *mem, size_t size) {\n+    xmlBufferPtr buf = xmlBufferCreateSize(size);\n+\n+    xmlBufferAdd(buf, mem, size);\n+    return(buf);\n+}\n+\n+\/**\n+ * xmlBufferSetAllocationScheme:\n+ * @buf:  the buffer to tune\n+ * @scheme:  allocation scheme to use\n+ *\n+ * Sets the allocation scheme for this buffer.\n+ *\n+ * For libxml2 before 2.14, it is recommended to set this to\n+ * XML_BUFFER_ALLOC_DOUBLE_IT. Has no effect on 2.14 or later.\n+ *\/\n+void\n+xmlBufferSetAllocationScheme(xmlBufferPtr buf ATTRIBUTE_UNUSED,\n+                             xmlBufferAllocationScheme scheme ATTRIBUTE_UNUSED) {\n+}\n+\n+\/**\n+ * xmlBufferFree:\n+ * @buf:  the buffer to free\n+ *\n+ * Frees an XML buffer. It frees both the content and the structure which\n+ * encapsulate it.\n+ *\/\n+void\n+xmlBufferFree(xmlBufferPtr buf) {\n+    if (buf == NULL)\n+        return;\n+\n+    if (buf->alloc == XML_BUFFER_ALLOC_IO)\n+        xmlFree(buf->contentIO);\n+    else\n+        xmlFree(buf->content);\n+\n+    xmlFree(buf);\n+}\n+\n+\/**\n+ * xmlBufferEmpty:\n+ * @buf:  the buffer\n+ *\n+ * empty a buffer.\n+ *\/\n+void\n+xmlBufferEmpty(xmlBufferPtr buf) {\n+    if (buf == NULL)\n+        return;\n+    if (buf->content == NULL)\n+        return;\n+\n+    buf->use = 0;\n+\n+    if (buf->alloc == XML_BUFFER_ALLOC_IO) {\n+        buf->size += buf->content - buf->contentIO;\n+        buf->content = buf->contentIO;\n+        buf->content[0] = 0;\n+    } else {\n+        buf->content[0] = 0;\n+    }\n+}\n+\n+\/**\n+ * xmlBufferShrink:\n+ * @buf:  the buffer to dump\n+ * @len:  the number of xmlChar to remove\n+ *\n+ * DEPRECATED: Don't use.\n+ *\n+ * Remove the beginning of an XML buffer.\n+ *\n+ * Returns the number of #xmlChar removed, or -1 in case of failure.\n+ *\/\n+int\n+xmlBufferShrink(xmlBufferPtr buf, unsigned int len) {\n+    if (buf == NULL)\n+        return(-1);\n+    if (len == 0)\n+        return(0);\n+    if (len > buf->use)\n+        return(-1);\n+\n+    buf->use -= len;\n+\n+    if (buf->alloc == XML_BUFFER_ALLOC_IO) {\n+        buf->content += len;\n+        buf->size -= len;\n+    } else {\n+        memmove(buf->content, &buf->content[len], buf->use + 1);\n+    }\n+\n+    return(len);\n+}\n+\n+\/**\n+ * xmlBufferGrow:\n+ * @buf:  the buffer\n+ * @len:  the minimum free size to allocate\n+ *\n+ * DEPRECATED: Don't use.\n+ *\n+ * Grow the available space of an XML buffer.\n+ *\n+ * Returns the new available space or -1 in case of error\n+ *\/\n+int\n+xmlBufferGrow(xmlBufferPtr buf, unsigned int len) {\n+    unsigned int size;\n+    xmlChar *newbuf;\n+\n+    if (buf == NULL)\n+        return(-1);\n+\n+    if (len < buf->size - buf->use)\n+        return(0);\n+    if (len >= INT_MAX - buf->use)\n+        return(-1);\n+\n+    if (buf->size > (size_t) len) {\n+        if (buf->size <= INT_MAX \/ 2)\n+            size = buf->size * 2;\n+        else\n+            size = INT_MAX;\n+    } else {\n+        size = buf->use + len + 1;\n+        if (size <= INT_MAX - 100)\n+            size += 100;\n+    }\n+\n+    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&\n+        (buf->content != buf->contentIO)) {\n+        newbuf = xmlMalloc(size);\n+        if (newbuf == NULL)\n+            return(-1);\n+        if (buf->content != NULL)\n+            memcpy(newbuf, buf->content, buf->use + 1);\n+        xmlFree(buf->contentIO);\n+    } else {\n+        newbuf = xmlRealloc(buf->content, size);\n+        if (newbuf == NULL)\n+            return(-1);\n+    }\n+\n+    if (buf->alloc == XML_BUFFER_ALLOC_IO)\n+        buf->contentIO = newbuf;\n+    buf->content = newbuf;\n+    buf->size = size;\n+\n+    return(buf->size - buf->use - 1);\n+}\n+\n+\/**\n+ * xmlBufferDump:\n+ * @file:  the file output\n+ * @buf:  the buffer to dump\n+ *\n+ * Dumps an XML buffer to  a FILE *.\n+ * Returns the number of #xmlChar written\n+ *\/\n+int\n+xmlBufferDump(FILE *file, xmlBufferPtr buf) {\n+    size_t ret;\n+\n+    if (buf == NULL)\n+        return(0);\n+    if (buf->content == NULL)\n+        return(0);\n+    if (file == NULL)\n+        file = stdout;\n+    ret = fwrite(buf->content, 1, buf->use, file);\n+    return(ret > INT_MAX ? INT_MAX : ret);\n+}\n+\n+\/**\n+ * xmlBufferContent:\n+ * @buf:  the buffer\n+ *\n+ * Function to extract the content of a buffer\n+ *\n+ * Returns the internal content\n+ *\/\n+\n+const xmlChar *\n+xmlBufferContent(const xmlBuffer *buf)\n+{\n+    if(!buf)\n+        return NULL;\n+\n+    return buf->content;\n+}\n+\n+\/**\n+ * xmlBufferLength:\n+ * @buf:  the buffer\n+ *\n+ * Function to get the length of a buffer\n+ *\n+ * Returns the length of data in the internal content\n+ *\/\n+\n+int\n+xmlBufferLength(const xmlBuffer *buf)\n+{\n+    if(!buf)\n+        return 0;\n+\n+    return buf->use;\n+}\n+\n+\/**\n+ * xmlBufferResize:\n+ * @buf:  the buffer to resize\n+ * @size:  the desired size\n+ *\n+ * DEPRECATED: Don't use.\n+\n+ * Resize a buffer to accommodate minimum size of @size.\n+ *\n+ * Returns  0 in case of problems, 1 otherwise\n+ *\/\n+int\n+xmlBufferResize(xmlBufferPtr buf, unsigned int size)\n+{\n+    int res;\n+\n+    if (buf == NULL)\n+        return(0);\n+    if (size < buf->size)\n+        return(1);\n+    res = xmlBufferGrow(buf, size - buf->use);\n+\n+    return(res < 0 ? 0 : 1);\n+}\n+\n+\/**\n+ * xmlBufferAdd:\n+ * @buf:  the buffer to dump\n+ * @str:  the #xmlChar string\n+ * @len:  the number of #xmlChar to add\n+ *\n+ * Add a string range to an XML buffer. if len == -1, the length of\n+ * str is recomputed.\n+ *\n+ * Returns a xmlParserErrors code.\n+ *\/\n+int\n+xmlBufferAdd(xmlBufferPtr buf, const xmlChar *str, int len) {\n+    if ((buf == NULL) || (str == NULL))\n+        return(XML_ERR_ARGUMENT);\n+    if (len < 0)\n+        len = xmlStrlen(str);\n+    if (len == 0)\n+        return(XML_ERR_OK);\n+\n+    \/* Note that both buf->size and buf->use can be zero here. *\/\n+    if ((unsigned) len >= buf->size - buf->use) {\n+        if (xmlBufferGrow(buf, len) < 0)\n+            return(XML_ERR_NO_MEMORY);\n+    }\n+\n+    memmove(&buf->content[buf->use], str, len);\n+    buf->use += len;\n+    buf->content[buf->use] = 0;\n+    return(XML_ERR_OK);\n+}\n+\n+\/**\n+ * xmlBufferAddHead:\n+ * @buf:  the buffer\n+ * @str:  the #xmlChar string\n+ * @len:  the number of #xmlChar to add\n+ *\n+ * Add a string range to the beginning of an XML buffer.\n+ * if len == -1, the length of @str is recomputed.\n+ *\n+ * Returns a xmlParserErrors code.\n+ *\/\n+int\n+xmlBufferAddHead(xmlBufferPtr buf, const xmlChar *str, int len) {\n+    unsigned start = 0;\n+\n+    if ((buf == NULL) || (str == NULL))\n+        return(XML_ERR_ARGUMENT);\n+    if (len < 0)\n+        len = xmlStrlen(str);\n+    if (len == 0)\n+        return(XML_ERR_OK);\n+\n+    if (buf->alloc == XML_BUFFER_ALLOC_IO) {\n+        start = buf->content - buf->contentIO;\n+\n+        \/*\n+         * We can add it in the space previously shrunk\n+         *\/\n+        if ((unsigned) len <= start) {\n+            buf->content -= len;\n+            memmove(&buf->content[0], str, len);\n+            buf->use += len;\n+            buf->size += len;\n+            return(0);\n+        }\n+        if ((unsigned) len < buf->size + start - buf->use) {\n+            memmove(&buf->contentIO[len], buf->content, buf->use + 1);\n+            memmove(buf->contentIO, str, len);\n+            buf->content = buf->contentIO;\n+            buf->use += len;\n+            buf->size += start;\n+            return(0);\n+        }\n+    }\n+\n+    if ((unsigned) len >= buf->size - buf->use) {\n+        if (xmlBufferGrow(buf, len) < 0)\n+            return(-1);\n+    }\n+\n+    memmove(&buf->content[len], buf->content, buf->use + 1);\n+    memmove(buf->content, str, len);\n+    buf->use += len;\n+    return (0);\n+}\n+\n+\/**\n+ * xmlBufferCat:\n+ * @buf:  the buffer to add to\n+ * @str:  the #xmlChar string\n+ *\n+ * Append a zero terminated string to an XML buffer.\n+ *\n+ * Returns 0 successful, a positive error code number otherwise\n+ *         and -1 in case of internal or API error.\n+ *\/\n+int\n+xmlBufferCat(xmlBufferPtr buf, const xmlChar *str) {\n+    return(xmlBufferAdd(buf, str, -1));\n+}\n+\n+\/**\n+ * xmlBufferCCat:\n+ * @buf:  the buffer to dump\n+ * @str:  the C char string\n+ *\n+ * Append a zero terminated C string to an XML buffer.\n+ *\n+ * Returns 0 successful, a positive error code number otherwise\n+ *         and -1 in case of internal or API error.\n+ *\/\n+int\n+xmlBufferCCat(xmlBufferPtr buf, const char *str) {\n+    return(xmlBufferAdd(buf, (const xmlChar *) str, -1));\n+}\n+\n+\/**\n+ * xmlBufferWriteCHAR:\n+ * @buf:  the XML buffer\n+ * @string:  the string to add\n+ *\n+ * routine which manages and grows an output buffer. This one adds\n+ * xmlChars at the end of the buffer.\n+ *\/\n+void\n+xmlBufferWriteCHAR(xmlBufferPtr buf, const xmlChar *string) {\n+    xmlBufferAdd(buf, string, -1);\n+}\n+\n+\/**\n+ * xmlBufferWriteChar:\n+ * @buf:  the XML buffer output\n+ * @string:  the string to add\n+ *\n+ * routine which manage and grows an output buffer. This one add\n+ * C chars at the end of the array.\n+ *\/\n+void\n+xmlBufferWriteChar(xmlBufferPtr buf, const char *string) {\n+    xmlBufferAdd(buf, (const xmlChar *) string, -1);\n+}\n+\n+\n+\/**\n+ * xmlBufferWriteQuotedString:\n+ * @buf:  the XML buffer output\n+ * @string:  the string to add\n+ *\n+ * routine which manage and grows an output buffer. This one writes\n+ * a quoted or double quoted #xmlChar string, checking first if it holds\n+ * quote or double-quotes internally\n+ *\/\n+void\n+xmlBufferWriteQuotedString(xmlBufferPtr buf, const xmlChar *string) {\n+    const xmlChar *cur, *base;\n+    if (buf == NULL)\n+        return;\n+    if (xmlStrchr(string, '\\\"')) {\n+        if (xmlStrchr(string, '\\'')) {\n+            xmlBufferCCat(buf, \"\\\"\");\n+            base = cur = string;\n+            while(*cur != 0){\n+                if(*cur == '\"'){\n+                    if (base != cur)\n+                        xmlBufferAdd(buf, base, cur - base);\n+                    xmlBufferAdd(buf, BAD_CAST \"&quot;\", 6);\n+                    cur++;\n+                    base = cur;\n+                }\n+                else {\n+                    cur++;\n+                }\n+            }\n+            if (base != cur)\n+                xmlBufferAdd(buf, base, cur - base);\n+            xmlBufferCCat(buf, \"\\\"\");\n+        }\n+        else{\n+            xmlBufferCCat(buf, \"\\'\");\n+            xmlBufferCat(buf, string);\n+            xmlBufferCCat(buf, \"\\'\");\n+        }\n+    } else {\n+        xmlBufferCCat(buf, \"\\\"\");\n+        xmlBufferCat(buf, string);\n+        xmlBufferCCat(buf, \"\\\"\");\n+    }\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/buf.c","additions":807,"deletions":486,"binary":false,"changes":1293,"status":"modified"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Summary: Internal Interfaces for memory buffers in libxml2\n- * Description: this module describes most of the new xmlBuf buffer\n- *              entry points, those are private routines, with a\n- *              few exceptions exported in tree.h. This was added\n- *              in 2.9.0.\n- *\n- * Copy: See Copyright for the status of this software.\n- *\n- * Author: Daniel Veillard\n- *\/\n-\n-#ifndef __XML_BUF_H__\n-#define __XML_BUF_H__\n-\n-#include <libxml\/tree.h>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-xmlBufPtr xmlBufCreate(void);\n-xmlBufPtr xmlBufCreateSize(size_t size);\n-xmlBufPtr xmlBufCreateStatic(void *mem, size_t size);\n-\n-int xmlBufSetAllocationScheme(xmlBufPtr buf,\n-                              xmlBufferAllocationScheme scheme);\n-int xmlBufGetAllocationScheme(xmlBufPtr buf);\n-\n-void xmlBufFree(xmlBufPtr buf);\n-void xmlBufEmpty(xmlBufPtr buf);\n-\n-\/* size_t xmlBufShrink(xmlBufPtr buf, size_t len); *\/\n-int xmlBufGrow(xmlBufPtr buf, int len);\n-int xmlBufResize(xmlBufPtr buf, size_t len);\n-\n-int xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len);\n-int xmlBufCat(xmlBufPtr buf, const xmlChar *str);\n-int xmlBufCCat(xmlBufPtr buf, const char *str);\n-int xmlBufWriteQuotedString(xmlBufPtr buf, const xmlChar *string);\n-\n-size_t xmlBufAvail(const xmlBufPtr buf);\n-size_t xmlBufLength(const xmlBufPtr buf);\n-\/* size_t xmlBufUse(const xmlBufPtr buf); *\/\n-int xmlBufIsEmpty(const xmlBufPtr buf);\n-int xmlBufAddLen(xmlBufPtr buf, size_t len);\n-\n-\/* const xmlChar * xmlBufContent(const xmlBuf *buf); *\/\n-\/* const xmlChar * xmlBufEnd(xmlBufPtr buf); *\/\n-\n-xmlChar * xmlBufDetach(xmlBufPtr buf);\n-\n-size_t xmlBufDump(FILE *file, xmlBufPtr buf);\n-\n-xmlBufPtr xmlBufFromBuffer(xmlBufferPtr buffer);\n-xmlBufferPtr xmlBufBackToBuffer(xmlBufPtr buf);\n-int xmlBufMergeBuffer(xmlBufPtr buf, xmlBufferPtr buffer);\n-\n-int xmlBufResetInput(xmlBufPtr buf, xmlParserInputPtr input);\n-size_t xmlBufGetInputBase(xmlBufPtr buf, xmlParserInputPtr input);\n-int xmlBufSetInputBaseCur(xmlBufPtr buf, xmlParserInputPtr input,\n-                          size_t base, size_t cur);\n-#ifdef __cplusplus\n-}\n-#endif\n-#endif \/* __XML_BUF_H__ *\/\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/buf.h","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -2,2 +2,2 @@\n- * chvalid.c:    this module implements the character range\n- *        validation APIs\n+ * chvalid.c:   this module implements the character range\n+ *              validation APIs\n@@ -102,1 +102,1 @@\n-    {197, 0, xmlIsBaseChar_srng, (xmlChLRangePtr)0};\n+        {197, 0, xmlIsBaseChar_srng, (xmlChLRangePtr)0};\n@@ -108,1 +108,1 @@\n-    {2, 1, xmlIsChar_srng, xmlIsChar_lrng};\n+        {2, 1, xmlIsChar_srng, xmlIsChar_lrng};\n@@ -136,1 +136,1 @@\n-    {95, 0, xmlIsCombining_srng, (xmlChLRangePtr)0};\n+        {95, 0, xmlIsCombining_srng, (xmlChLRangePtr)0};\n@@ -144,1 +144,1 @@\n-    {14, 0, xmlIsDigit_srng, (xmlChLRangePtr)0};\n+        {14, 0, xmlIsDigit_srng, (xmlChLRangePtr)0};\n@@ -151,1 +151,1 @@\n-    {10, 0, xmlIsExtender_srng, (xmlChLRangePtr)0};\n+        {10, 0, xmlIsExtender_srng, (xmlChLRangePtr)0};\n@@ -156,1 +156,1 @@\n-    {3, 0, xmlIsIdeographic_srng, (xmlChLRangePtr)0};\n+        {3, 0, xmlIsIdeographic_srng, (xmlChLRangePtr)0};\n@@ -176,15 +176,17 @@\n-    if (val < 0x10000) {    \/* is val in 'short' or 'long'  array? *\/\n-    if (rptr->nbShortRange == 0)\n-        return 0;\n-    low = 0;\n-    high = rptr->nbShortRange - 1;\n-    sptr = rptr->shortRange;\n-    while (low <= high) {\n-        mid = (low + high) \/ 2;\n-        if ((unsigned short) val < sptr[mid].low) {\n-        high = mid - 1;\n-        } else {\n-            if ((unsigned short) val > sptr[mid].high) {\n-            low = mid + 1;\n-        } else {\n-            return 1;\n+    if (val < 0x10000) {        \/* is val in 'short' or 'long'  array? *\/\n+        if (rptr->nbShortRange == 0)\n+            return 0;\n+        low = 0;\n+        high = rptr->nbShortRange - 1;\n+        sptr = rptr->shortRange;\n+        while (low <= high) {\n+            mid = (low + high) \/ 2;\n+            if ((unsigned short) val < sptr[mid].low) {\n+                high = mid - 1;\n+            } else {\n+                if ((unsigned short) val > sptr[mid].high) {\n+                    low = mid + 1;\n+                } else {\n+                    return 1;\n+                }\n+            }\n@@ -192,2 +194,0 @@\n-        }\n-    }\n@@ -195,15 +195,2 @@\n-    if (rptr->nbLongRange == 0) {\n-        return 0;\n-    }\n-    low = 0;\n-    high = rptr->nbLongRange - 1;\n-    lptr = rptr->longRange;\n-    while (low <= high) {\n-        mid = (low + high) \/ 2;\n-        if (val < lptr[mid].low) {\n-        high = mid - 1;\n-        } else {\n-            if (val > lptr[mid].high) {\n-            low = mid + 1;\n-        } else {\n-            return 1;\n+        if (rptr->nbLongRange == 0) {\n+            return 0;\n@@ -211,0 +198,14 @@\n+        low = 0;\n+        high = rptr->nbLongRange - 1;\n+        lptr = rptr->longRange;\n+        while (low <= high) {\n+            mid = (low + high) \/ 2;\n+            if (val < lptr[mid].low) {\n+                high = mid - 1;\n+            } else {\n+                if (val > lptr[mid].high) {\n+                    low = mid + 1;\n+                } else {\n+                    return 1;\n+                }\n+            }\n@@ -213,1 +214,0 @@\n-    }\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/chvalid.c","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"private\/error.h\"\n@@ -146,3 +147,3 @@\n-    if ((size_t)(pool->end - pool->free) > namelen)\n-        goto found_pool;\n-    if (pool->size > size) size = pool->size;\n+        if ((size_t)(pool->end - pool->free) > namelen)\n+            goto found_pool;\n+        if (pool->size > size) size = pool->size;\n@@ -150,1 +151,1 @@\n-    pool = pool->next;\n+        pool = pool->next;\n@@ -174,9 +175,9 @@\n-    pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);\n-    if (pool == NULL)\n-        return(NULL);\n-    pool->size = size;\n-    pool->nbStrings = 0;\n-    pool->free = &pool->array[0];\n-    pool->end = &pool->array[size];\n-    pool->next = dict->strings;\n-    dict->strings = pool;\n+        pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);\n+        if (pool == NULL)\n+            return(NULL);\n+        pool->size = size;\n+        pool->nbStrings = 0;\n+        pool->free = &pool->array[0];\n+        pool->end = &pool->array[size];\n+        pool->next = dict->strings;\n+        dict->strings = pool;\n@@ -216,3 +217,3 @@\n-    if ((size_t)(pool->end - pool->free) > namelen + plen + 1)\n-        goto found_pool;\n-    if (pool->size > size) size = pool->size;\n+        if ((size_t)(pool->end - pool->free) > namelen + plen + 1)\n+            goto found_pool;\n+        if (pool->size > size) size = pool->size;\n@@ -220,1 +221,1 @@\n-    pool = pool->next;\n+        pool = pool->next;\n@@ -231,1 +232,1 @@\n-    else size *= 4; \/* exponential growth *\/\n+        else size *= 4; \/* exponential growth *\/\n@@ -233,10 +234,10 @@\n-        size = 4 * (namelen + plen + 1); \/* just in case ! *\/\n-    pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);\n-    if (pool == NULL)\n-        return(NULL);\n-    pool->size = size;\n-    pool->nbStrings = 0;\n-    pool->free = &pool->array[0];\n-    pool->end = &pool->array[size];\n-    pool->next = dict->strings;\n-    dict->strings = pool;\n+            size = 4 * (namelen + plen + 1); \/* just in case ! *\/\n+        pool = (xmlDictStringsPtr) xmlMalloc(sizeof(xmlDictStrings) + size);\n+        if (pool == NULL)\n+            return(NULL);\n+        pool->size = size;\n+        pool->nbStrings = 0;\n+        pool->free = &pool->array[0];\n+        pool->end = &pool->array[size];\n+        pool->next = dict->strings;\n+        dict->strings = pool;\n@@ -305,1 +306,1 @@\n-    xmlDictReference(dict->subdict);\n+        xmlDictReference(dict->subdict);\n@@ -339,1 +340,1 @@\n-    return;\n+        return;\n@@ -356,1 +357,1 @@\n-    xmlFree(dict->table);\n+        xmlFree(dict->table);\n@@ -361,2 +362,2 @@\n-    xmlFree(pool);\n-    pool = nextp;\n+        xmlFree(pool);\n+        pool = nextp;\n@@ -382,1 +383,1 @@\n-    return(-1);\n+        return(-1);\n@@ -386,2 +387,2 @@\n-        return(1);\n-    pool = pool->next;\n+            return(1);\n+        pool = pool->next;\n@@ -406,1 +407,1 @@\n-    return(-1);\n+        return(-1);\n@@ -427,1 +428,1 @@\n-    return(0);\n+        return(0);\n@@ -448,1 +449,1 @@\n-    return(0);\n+        return(0);\n@@ -452,1 +453,1 @@\n-    pool = pool->next;\n+        pool = pool->next;\n@@ -702,1 +703,1 @@\n-    unsigned hashValue;\n+    unsigned hashValue, newSize;\n@@ -707,1 +708,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -729,1 +730,3 @@\n-    if (dict->size > 0)\n+    if (dict->size == 0) {\n+        newSize = MIN_HASH_SIZE;\n+    } else {\n@@ -731,2 +734,11 @@\n-    if (found)\n-        return(entry);\n+        if (found)\n+            return(entry);\n+\n+        if (dict->nbElems + 1 > dict->size \/ MAX_FILL_DENOM * MAX_FILL_NUM) {\n+            if (dict->size >= MAX_HASH_SIZE)\n+                return(NULL);\n+            newSize = dict->size * 2;\n+        } else {\n+            newSize = 0;\n+        }\n+    }\n@@ -756,2 +768,2 @@\n-    if (dict->nbElems + 1 > dict->size \/ MAX_FILL_DENOM * MAX_FILL_NUM) {\n-        unsigned newSize, mask, displ, pos;\n+    if (newSize > 0) {\n+        unsigned mask, displ, pos;\n@@ -759,7 +771,0 @@\n-        if (dict->size == 0) {\n-            newSize = MIN_HASH_SIZE;\n-        } else {\n-            if (dict->size >= MAX_HASH_SIZE)\n-                return(NULL);\n-            newSize = dict->size * 2;\n-        }\n@@ -932,7 +937,5 @@\n-  #if defined(HAVE_GETENTROPY)\n-    #ifdef HAVE_UNISTD_H\n-      #include <unistd.h>\n-    #endif\n-    #ifdef HAVE_SYS_RANDOM_H\n-      #include <sys\/random.h>\n-    #endif\n+  #if HAVE_DECL_GETENTROPY\n+    \/* POSIX 2024 *\/\n+    #include <unistd.h>\n+    \/* Older platforms *\/\n+    #include <sys\/random.h>\n@@ -961,0 +964,7 @@\n+        \/*\n+         * You can find many (recent as of 2025) discussions how\n+         * to get a pseudo-random seed on Windows in projects like\n+         * Golang, Rust, Chromium and Firefox.\n+         *\n+         * TODO: Support ProcessPrng available since Windows 10.\n+         *\/\n@@ -964,5 +974,3 @@\n-        if (!BCRYPT_SUCCESS(status)) {\n-            fprintf(stderr, \"libxml2: BCryptGenRandom failed with \"\n-                    \"error code %lu\\n\", GetLastError());\n-            abort();\n-        }\n+        if (!BCRYPT_SUCCESS(status))\n+            xmlAbort(\"libxml2: BCryptGenRandom failed with error code %lu\\n\",\n+                     GetLastError());\n@@ -972,1 +980,1 @@\n-#if defined(HAVE_GETENTROPY)\n+#if HAVE_DECL_GETENTROPY\n@@ -986,5 +994,8 @@\n-            if (errno != EINTR) {\n-                fprintf(stderr, \"libxml2: getentropy failed with \"\n-                        \"error code %d\\n\", errno);\n-                abort();\n-            }\n+            \/*\n+             * We really don't want to fallback to the unsafe PRNG\n+             * for possibly accidental reasons, so we abort on any\n+             * unknown error.\n+             *\/\n+            if (errno != EINTR)\n+                xmlAbort(\"libxml2: getentropy failed with error code %d\\n\",\n+                         errno);\n@@ -994,0 +1005,3 @@\n+        \/*\n+         * TODO: Fallback to \/dev\/urandom for older POSIX systems.\n+         *\/\n@@ -1055,1 +1069,0 @@\n-#ifdef LIBXML_THREAD_ENABLED\n@@ -1057,3 +1070,0 @@\n-#else\n-    return(xmlGlobalRandom());\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/dict.c","additions":86,"deletions":76,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include <iconv.h>\n@@ -45,0 +46,1 @@\n+#include \"private\/entities.h\"\n@@ -46,0 +48,1 @@\n+#include \"private\/memory.h\"\n@@ -49,10 +52,0 @@\n-\/* Size of pivot buffer, same as icu\/source\/common\/ucnv.cpp CHUNK_SIZE *\/\n-#define ICU_PIVOT_BUF_SIZE 1024\n-typedef struct _uconv_t uconv_t;\n-struct _uconv_t {\n-  UConverter *uconv; \/* for conversion between an encoding and UTF-16 *\/\n-  UConverter *utf8; \/* for conversion between UTF-8 and UTF-16 *\/\n-  UChar      pivot_buf[ICU_PIVOT_BUF_SIZE];\n-  UChar      *pivot_source;\n-  UChar      *pivot_target;\n-};\n@@ -61,0 +54,3 @@\n+#define XML_HANDLER_STATIC (1 << 0)\n+#define XML_HANDLER_LEGACY (1 << 1)\n+\n@@ -74,35 +70,44 @@\n-\/************************************************************************\n- *                                    *\n- *        Conversions To\/From UTF8 encoding            *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * asciiToUTF8:\n- * @out:  a pointer to an array of bytes to store the result\n- * @outlen:  the length of @out\n- * @in:  a pointer to an array of ASCII chars\n- * @inlen:  the length of @in\n- *\n- * Take a block of ASCII chars in and try to convert it to an UTF-8\n- * block of chars out.\n- *\n- * Returns the number of bytes written or an XML_ENC_ERR code.\n- *\n- * The value of @inlen after return is the number of octets consumed\n- *     if the return value is positive, else unpredictable.\n- * The value of @outlen after return is the number of octets produced.\n- *\/\n-static int\n-asciiToUTF8(unsigned char* out, int *outlen,\n-              const unsigned char* in, int *inlen) {\n-    unsigned char* outstart = out;\n-    const unsigned char* base = in;\n-    const unsigned char* processed = in;\n-    unsigned char* outend = out + *outlen;\n-    const unsigned char* inend;\n-    unsigned int c;\n-\n-    inend = in + (*inlen);\n-    while ((in < inend) && (out - outstart + 5 < *outlen)) {\n-    c= *in++;\n+typedef struct {\n+    const char *name;\n+    xmlCharEncoding enc;\n+} xmlEncTableEntry;\n+\n+static const xmlEncTableEntry xmlEncTable[] = {\n+    { \"ASCII\", XML_CHAR_ENCODING_ASCII },\n+    { \"EUC-JP\", XML_CHAR_ENCODING_EUC_JP },\n+    { \"HTML\", XML_CHAR_ENCODING_HTML },\n+    { \"ISO LATIN 1\", XML_CHAR_ENCODING_8859_1 },\n+    { \"ISO LATIN 2\", XML_CHAR_ENCODING_8859_2 },\n+    { \"ISO-10646-UCS-2\", XML_CHAR_ENCODING_UCS2 },\n+    { \"ISO-10646-UCS-4\", XML_CHAR_ENCODING_UCS4LE },\n+    { \"ISO-2022-JP\", XML_CHAR_ENCODING_2022_JP },\n+    { \"ISO-8859-1\", XML_CHAR_ENCODING_8859_1 },\n+    { \"ISO-8859-10\", XML_CHAR_ENCODING_8859_10 },\n+    { \"ISO-8859-11\", XML_CHAR_ENCODING_8859_11 },\n+    { \"ISO-8859-13\", XML_CHAR_ENCODING_8859_13 },\n+    { \"ISO-8859-14\", XML_CHAR_ENCODING_8859_14 },\n+    { \"ISO-8859-15\", XML_CHAR_ENCODING_8859_15 },\n+    { \"ISO-8859-16\", XML_CHAR_ENCODING_8859_16 },\n+    { \"ISO-8859-2\", XML_CHAR_ENCODING_8859_2 },\n+    { \"ISO-8859-3\", XML_CHAR_ENCODING_8859_3 },\n+    { \"ISO-8859-4\", XML_CHAR_ENCODING_8859_4 },\n+    { \"ISO-8859-5\", XML_CHAR_ENCODING_8859_5 },\n+    { \"ISO-8859-6\", XML_CHAR_ENCODING_8859_6 },\n+    { \"ISO-8859-7\", XML_CHAR_ENCODING_8859_7 },\n+    { \"ISO-8859-8\", XML_CHAR_ENCODING_8859_8 },\n+    { \"ISO-8859-9\", XML_CHAR_ENCODING_8859_9 },\n+    { \"ISO-LATIN-1\", XML_CHAR_ENCODING_8859_1 },\n+    { \"ISO-LATIN-2\", XML_CHAR_ENCODING_8859_2 },\n+    { \"SHIFT_JIS\", XML_CHAR_ENCODING_SHIFT_JIS },\n+    { \"UCS-2\", XML_CHAR_ENCODING_UCS2 },\n+    { \"UCS-4\", XML_CHAR_ENCODING_UCS4LE },\n+    { \"UCS2\", XML_CHAR_ENCODING_UCS2 },\n+    { \"UCS4\", XML_CHAR_ENCODING_UCS4LE },\n+    { \"US-ASCII\", XML_CHAR_ENCODING_ASCII },\n+    { \"UTF-16\", XML_CHAR_ENCODING_UTF16 },\n+    { \"UTF-16BE\", XML_CHAR_ENCODING_UTF16BE },\n+    { \"UTF-16LE\", XML_CHAR_ENCODING_UTF16LE },\n+    { \"UTF-8\", XML_CHAR_ENCODING_UTF8 },\n+    { \"UTF16\", XML_CHAR_ENCODING_UTF16 },\n+    { \"UTF8\", XML_CHAR_ENCODING_UTF8 }\n+};\n@@ -110,16 +115,15 @@\n-        if (out >= outend)\n-        break;\n-        if (c < 0x80) {\n-        *out++ = c;\n-    } else {\n-        *outlen = out - outstart;\n-        *inlen = processed - base;\n-        return(XML_ENC_ERR_INPUT);\n-    }\n-\n-    processed = (const unsigned char*) in;\n-    }\n-    *outlen = out - outstart;\n-    *inlen = processed - base;\n-    return(*outlen);\n-}\n+static xmlCharEncError\n+asciiToAscii(void *vctxt, unsigned char* out, int *outlen,\n+             const unsigned char* in, int *inlen, int flush);\n+static xmlCharEncError\n+UTF8ToUTF8(void *vctxt, unsigned char* out, int *outlen,\n+           const unsigned char* inb, int *inlenb, int flush);\n+static xmlCharEncError\n+latin1ToUTF8(void *vctxt, unsigned char* out, int *outlen,\n+             const unsigned char* in, int *inlen, int flush);\n+static xmlCharEncError\n+UTF16LEToUTF8(void *vctxt, unsigned char* out, int *outlen,\n+              const unsigned char* inb, int *inlenb, int flush);\n+static xmlCharEncError\n+UTF16BEToUTF8(void *vctxt, unsigned char* out, int *outlen,\n+              const unsigned char* inb, int *inlenb, int flush);\n@@ -128,26 +132,0 @@\n-\/**\n- * UTF8Toascii:\n- * @out:  a pointer to an array of bytes to store the result\n- * @outlen:  the length of @out\n- * @in:  a pointer to an array of UTF-8 chars\n- * @inlen:  the length of @in\n- *\n- * Take a block of UTF-8 chars in and try to convert it to an ASCII\n- * block of chars out.\n- *\n- * Returns the number of bytes written or an XML_ENC_ERR code.\n- *\n- * The value of @inlen after return is the number of octets consumed\n- *     if the return value is positive, else unpredictable.\n- * The value of @outlen after return is the number of octets produced.\n- *\/\n-static int\n-UTF8Toascii(unsigned char* out, int *outlen,\n-              const unsigned char* in, int *inlen) {\n-    const unsigned char* processed = in;\n-    const unsigned char* outend;\n-    const unsigned char* outstart = out;\n-    const unsigned char* instart = in;\n-    const unsigned char* inend;\n-    unsigned int c, d;\n-    int trailing;\n@@ -155,29 +133,19 @@\n-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))\n-        return(XML_ENC_ERR_INTERNAL);\n-    if (in == NULL) {\n-        \/*\n-     * initialization nothing to do\n-     *\/\n-    *outlen = 0;\n-    *inlen = 0;\n-    return(0);\n-    }\n-    inend = in + (*inlen);\n-    outend = out + (*outlen);\n-    while (in < inend) {\n-    d = *in++;\n-    if      (d < 0x80)  { c= d; trailing= 0; }\n-    else if (d < 0xC0) {\n-        \/* trailing byte in leading position *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(XML_ENC_ERR_INPUT);\n-        } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }\n-        else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }\n-        else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }\n-    else {\n-        \/* no chance for this in Ascii *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(XML_ENC_ERR_INPUT);\n-    }\n+static xmlCharEncError\n+UTF8ToLatin1(void *vctxt, unsigned char* outb, int *outlen,\n+             const unsigned char* in, int *inlen, int flush);\n+static xmlCharEncError\n+UTF8ToUTF16(void *vctxt, unsigned char* outb, int *outlen,\n+            const unsigned char* in, int *inlen, int flush);\n+static xmlCharEncError\n+UTF8ToUTF16LE(void *vctxt, unsigned char* outb, int *outlen,\n+              const unsigned char* in, int *inlen, int flush);\n+static xmlCharEncError\n+UTF8ToUTF16BE(void *vctxt, unsigned char* outb, int *outlen,\n+              const unsigned char* in, int *inlen, int flush);\n+\n+#else \/* LIBXML_OUTPUT_ENABLED *\/\n+\n+#define UTF8ToLatin1 NULL\n+#define UTF8ToUTF16 NULL\n+#define UTF8ToUTF16LE NULL\n+#define UTF8ToUTF16BE NULL\n@@ -185,28 +153,0 @@\n-    if (inend - in < trailing) {\n-        break;\n-    }\n-\n-    for ( ; trailing; trailing--) {\n-        if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))\n-        break;\n-        c <<= 6;\n-        c |= d & 0x3F;\n-    }\n-\n-    \/* assertion: c is a single UTF-4 value *\/\n-    if (c < 0x80) {\n-        if (out >= outend)\n-        break;\n-        *out++ = c;\n-    } else {\n-        \/* no chance for this in Ascii *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(XML_ENC_ERR_INPUT);\n-    }\n-    processed = in;\n-    }\n-    *outlen = out - outstart;\n-    *inlen = processed - instart;\n-    return(*outlen);\n-}\n@@ -215,127 +155,7 @@\n-\/**\n- * isolat1ToUTF8:\n- * @out:  a pointer to an array of bytes to store the result\n- * @outlen:  the length of @out\n- * @in:  a pointer to an array of ISO Latin 1 chars\n- * @inlen:  the length of @in\n- *\n- * Take a block of ISO Latin 1 chars in and try to convert it to an UTF-8\n- * block of chars out.\n- *\n- * Returns the number of bytes written or an XML_ENC_ERR code.\n- *\n- * The value of @inlen after return is the number of octets consumed\n- *     if the return value is positive, else unpredictable.\n- * The value of @outlen after return is the number of octets produced.\n- *\/\n-int\n-isolat1ToUTF8(unsigned char* out, int *outlen,\n-              const unsigned char* in, int *inlen) {\n-    unsigned char* outstart = out;\n-    const unsigned char* base = in;\n-    unsigned char* outend;\n-    const unsigned char* inend;\n-    const unsigned char* instop;\n-\n-    if ((out == NULL) || (in == NULL) || (outlen == NULL) || (inlen == NULL))\n-    return(XML_ENC_ERR_INTERNAL);\n-\n-    outend = out + *outlen;\n-    inend = in + (*inlen);\n-    instop = inend;\n-\n-    while ((in < inend) && (out < outend - 1)) {\n-    if (*in >= 0x80) {\n-        *out++ = (((*in) >>  6) & 0x1F) | 0xC0;\n-            *out++ = ((*in) & 0x3F) | 0x80;\n-        ++in;\n-    }\n-    if ((instop - in) > (outend - out)) instop = in + (outend - out);\n-    while ((in < instop) && (*in < 0x80)) {\n-        *out++ = *in++;\n-    }\n-    }\n-    if ((in < inend) && (out < outend) && (*in < 0x80)) {\n-        *out++ = *in++;\n-    }\n-    *outlen = out - outstart;\n-    *inlen = in - base;\n-    return(*outlen);\n-}\n-\n-\/**\n- * UTF8ToUTF8:\n- * @out:  a pointer to an array of bytes to store the result\n- * @outlen:  the length of @out\n- * @inb:  a pointer to an array of UTF-8 chars\n- * @inlenb:  the length of @in in UTF-8 chars\n- *\n- * No op copy operation for UTF8 handling.\n- *\n- * Returns the number of bytes written or an XML_ENC_ERR code.\n- *\n- *     The value of *inlen after return is the number of octets consumed\n- *     if the return value is positive, else unpredictable.\n- *\/\n-static int\n-UTF8ToUTF8(unsigned char* out, int *outlen,\n-           const unsigned char* inb, int *inlenb)\n-{\n-    int len;\n-\n-    if ((out == NULL) || (outlen == NULL) || (inlenb == NULL))\n-    return(XML_ENC_ERR_INTERNAL);\n-    if (inb == NULL) {\n-        \/* inb == NULL means output is initialized. *\/\n-        *outlen = 0;\n-        *inlenb = 0;\n-        return(0);\n-    }\n-    if (*outlen > *inlenb) {\n-    len = *inlenb;\n-    } else {\n-    len = *outlen;\n-    }\n-    if (len < 0)\n-    return(XML_ENC_ERR_INTERNAL);\n-\n-    \/*\n-     * FIXME: Conversion functions must assure valid UTF-8, so we have\n-     * to check for UTF-8 validity. Preferably, this converter shouldn't\n-     * be used at all.\n-     *\/\n-    memcpy(out, inb, len);\n-\n-    *outlen = len;\n-    *inlenb = len;\n-    return(*outlen);\n-}\n-\n-\n-#ifdef LIBXML_OUTPUT_ENABLED\n-\/**\n- * UTF8Toisolat1:\n- * @out:  a pointer to an array of bytes to store the result\n- * @outlen:  the length of @out\n- * @in:  a pointer to an array of UTF-8 chars\n- * @inlen:  the length of @in\n- *\n- * Take a block of UTF-8 chars in and try to convert it to an ISO Latin 1\n- * block of chars out.\n- *\n- * Returns the number of bytes written or an XML_ENC_ERR code.\n- *\n- * The value of @inlen after return is the number of octets consumed\n- *     if the return value is positive, else unpredictable.\n- * The value of @outlen after return is the number of octets produced.\n- *\/\n-int\n-UTF8Toisolat1(unsigned char* out, int *outlen,\n-              const unsigned char* in, int *inlen) {\n-    const unsigned char* processed = in;\n-    const unsigned char* outend;\n-    const unsigned char* outstart = out;\n-    const unsigned char* instart = in;\n-    const unsigned char* inend;\n-    unsigned int c, d;\n-    int trailing;\n+#if defined(LIBXML_OUTPUT_ENABLED) && defined(LIBXML_HTML_ENABLED)\n+static xmlCharEncError\n+UTF8ToHtmlWrapper(void *vctxt, unsigned char *out, int *outlen,\n+                  const unsigned char *in, int *inlen, int flush);\n+#else\n+#define UTF8ToHtmlWrapper NULL\n+#endif\n@@ -343,29 +163,2 @@\n-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))\n-        return(XML_ENC_ERR_INTERNAL);\n-    if (in == NULL) {\n-        \/*\n-     * initialization nothing to do\n-     *\/\n-    *outlen = 0;\n-    *inlen = 0;\n-    return(0);\n-    }\n-    inend = in + (*inlen);\n-    outend = out + (*outlen);\n-    while (in < inend) {\n-    d = *in++;\n-    if      (d < 0x80)  { c= d; trailing= 0; }\n-    else if (d < 0xC0) {\n-        \/* trailing byte in leading position *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(XML_ENC_ERR_INPUT);\n-        } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }\n-        else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }\n-        else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }\n-    else {\n-        \/* no chance for this in IsoLat1 *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(XML_ENC_ERR_INPUT);\n-    }\n+#if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED) && \\\n+    defined(LIBXML_ISO8859X_ENABLED)\n@@ -373,3 +166,1 @@\n-    if (inend - in < trailing) {\n-        break;\n-    }\n+#include \"iso8859x.inc\"\n@@ -377,11 +168,6 @@\n-    for ( ; trailing; trailing--) {\n-        if (in >= inend)\n-        break;\n-        if (((d= *in++) & 0xC0) != 0x80) {\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(XML_ENC_ERR_INPUT);\n-        }\n-        c <<= 6;\n-        c |= d & 0x3F;\n-    }\n+static xmlCharEncError\n+ISO8859xToUTF8(void *vctxt, unsigned char* out, int *outlen,\n+               const unsigned char* in, int *inlen, int flush);\n+static xmlCharEncError\n+UTF8ToISO8859x(void *vctxt, unsigned char *out, int *outlen,\n+               const unsigned char *in, int *inlen, int flush);\n@@ -389,18 +175,5 @@\n-    \/* assertion: c is a single UTF-4 value *\/\n-    if (c <= 0xFF) {\n-        if (out >= outend)\n-        break;\n-        *out++ = c;\n-    } else {\n-        \/* no chance for this in IsoLat1 *\/\n-        *outlen = out - outstart;\n-        *inlen = processed - instart;\n-        return(XML_ENC_ERR_INPUT);\n-    }\n-    processed = in;\n-    }\n-    *outlen = out - outstart;\n-    *inlen = processed - instart;\n-    return(*outlen);\n-}\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n+#define MAKE_ISO_HANDLER(name, n) \\\n+    { (char *) name, { ISO8859xToUTF8 }, { UTF8ToISO8859x }, \\\n+      (void *) xmlunicodetable_ISO8859_##n, \\\n+      (void *) xmltranscodetable_ISO8859_##n, \\\n+      NULL, XML_HANDLER_STATIC }\n@@ -408,72 +181,1 @@\n-\/**\n- * UTF16LEToUTF8:\n- * @out:  a pointer to an array of bytes to store the result\n- * @outlen:  the length of @out\n- * @inb:  a pointer to an array of UTF-16LE passwd as a byte array\n- * @inlenb:  the length of @in in UTF-16LE chars\n- *\n- * Take a block of UTF-16LE ushorts in and try to convert it to an UTF-8\n- * block of chars out. This function assumes the endian property\n- * is the same between the native type of this machine and the\n- * inputed one.\n- *\n- * Returns the number of bytes written or an XML_ENC_ERR code.\n- *\n- * The value of *inlen after return is the number of octets consumed\n- * if the return value is positive, else unpredictable.\n- *\/\n-static int\n-UTF16LEToUTF8(unsigned char* out, int *outlen,\n-            const unsigned char* inb, int *inlenb)\n-{\n-    unsigned char* outstart = out;\n-    const unsigned char* processed = inb;\n-    unsigned char* outend;\n-    unsigned short* in = (unsigned short *) (void *) inb;\n-    unsigned short* inend;\n-    unsigned int c, d, inlen;\n-    unsigned char *tmp;\n-    int bits;\n-\n-    if (*outlen == 0) {\n-        *inlenb = 0;\n-        return(0);\n-    }\n-    outend = out + *outlen;\n-    if ((*inlenb % 2) == 1)\n-        (*inlenb)--;\n-    inlen = *inlenb \/ 2;\n-    inend = in + inlen;\n-    while ((in < inend) && (out - outstart + 5 < *outlen)) {\n-        if (xmlLittleEndian) {\n-        c= *in++;\n-    } else {\n-        tmp = (unsigned char *) in;\n-        c = *tmp++;\n-        c = c | (*tmp << 8);\n-        in++;\n-    }\n-        if ((c & 0xFC00) == 0xD800) {    \/* surrogates *\/\n-        if (in >= inend) {           \/* handle split mutli-byte characters *\/\n-        break;\n-        }\n-        if (xmlLittleEndian) {\n-        d = *in++;\n-        } else {\n-        tmp = (unsigned char *) in;\n-        d = *tmp++;\n-        d = d | (*tmp << 8);\n-        in++;\n-        }\n-            if ((d & 0xFC00) == 0xDC00) {\n-                c &= 0x03FF;\n-                c <<= 10;\n-                c |= d & 0x03FF;\n-                c += 0x10000;\n-            }\n-            else {\n-        *outlen = out - outstart;\n-        *inlenb = processed - inb;\n-            return(XML_ENC_ERR_INPUT);\n-        }\n-        }\n+#else \/* LIBXML_ISO8859X_ENABLED *\/\n@@ -481,7 +183,3 @@\n-    \/* assertion: c is a single UTF-4 value *\/\n-        if (out >= outend)\n-        break;\n-        if      (c <    0x80) {  *out++=  c;                bits= -6; }\n-        else if (c <   0x800) {  *out++= ((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n-        else if (c < 0x10000) {  *out++= ((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n-        else                  {  *out++= ((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n+#define MAKE_ISO_HANDLER(name, n) \\\n+    { (char *) name, { NULL }, { NULL }, NULL, NULL, NULL, \\\n+      XML_HANDLER_STATIC }\n@@ -489,121 +187,1 @@\n-        for ( ; bits >= 0; bits-= 6) {\n-            if (out >= outend)\n-            break;\n-            *out++= ((c >> bits) & 0x3F) | 0x80;\n-        }\n-    processed = (const unsigned char*) in;\n-    }\n-    *outlen = out - outstart;\n-    *inlenb = processed - inb;\n-    return(*outlen);\n-}\n-\n-#ifdef LIBXML_OUTPUT_ENABLED\n-\/**\n- * UTF8ToUTF16LE:\n- * @outb:  a pointer to an array of bytes to store the result\n- * @outlen:  the length of @outb\n- * @in:  a pointer to an array of UTF-8 chars\n- * @inlen:  the length of @in\n- *\n- * Take a block of UTF-8 chars in and try to convert it to an UTF-16LE\n- * block of chars out.\n- *\n- * Returns the number of bytes written or an XML_ENC_ERR code.\n- *\/\n-static int\n-UTF8ToUTF16LE(unsigned char* outb, int *outlen,\n-            const unsigned char* in, int *inlen)\n-{\n-    unsigned short* out = (unsigned short *) (void *) outb;\n-    const unsigned char* processed = in;\n-    const unsigned char *const instart = in;\n-    unsigned short* outstart= out;\n-    unsigned short* outend;\n-    const unsigned char* inend;\n-    unsigned int c, d;\n-    int trailing;\n-    unsigned char *tmp;\n-    unsigned short tmp1, tmp2;\n-\n-    \/* UTF16LE encoding has no BOM *\/\n-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))\n-        return(XML_ENC_ERR_INTERNAL);\n-    if (in == NULL) {\n-    *outlen = 0;\n-    *inlen = 0;\n-    return(0);\n-    }\n-    inend= in + *inlen;\n-    outend = out + (*outlen \/ 2);\n-    while (in < inend) {\n-      d= *in++;\n-      if      (d < 0x80)  { c= d; trailing= 0; }\n-      else if (d < 0xC0) {\n-          \/* trailing byte in leading position *\/\n-      *outlen = (out - outstart) * 2;\n-      *inlen = processed - instart;\n-      return(XML_ENC_ERR_INPUT);\n-      } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }\n-      else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }\n-      else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }\n-      else {\n-    \/* no chance for this in UTF-16 *\/\n-    *outlen = (out - outstart) * 2;\n-    *inlen = processed - instart;\n-    return(XML_ENC_ERR_INPUT);\n-      }\n-\n-      if (inend - in < trailing) {\n-          break;\n-      }\n-\n-      for ( ; trailing; trailing--) {\n-          if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))\n-          break;\n-          c <<= 6;\n-          c |= d & 0x3F;\n-      }\n-\n-      \/* assertion: c is a single UTF-4 value *\/\n-        if (c < 0x10000) {\n-            if (out >= outend)\n-            break;\n-        if (xmlLittleEndian) {\n-        *out++ = c;\n-        } else {\n-        tmp = (unsigned char *) out;\n-        *tmp = (unsigned char) c; \/* Explicit truncation *\/\n-        *(tmp + 1) = c >> 8 ;\n-        out++;\n-        }\n-        }\n-        else if (c < 0x110000) {\n-            if (out+1 >= outend)\n-            break;\n-            c -= 0x10000;\n-        if (xmlLittleEndian) {\n-        *out++ = 0xD800 | (c >> 10);\n-        *out++ = 0xDC00 | (c & 0x03FF);\n-        } else {\n-        tmp1 = 0xD800 | (c >> 10);\n-        tmp = (unsigned char *) out;\n-        *tmp = (unsigned char) tmp1; \/* Explicit truncation *\/\n-        *(tmp + 1) = tmp1 >> 8;\n-        out++;\n-\n-        tmp2 = 0xDC00 | (c & 0x03FF);\n-        tmp = (unsigned char *) out;\n-        *tmp  = (unsigned char) tmp2; \/* Explicit truncation *\/\n-        *(tmp + 1) = tmp2 >> 8;\n-        out++;\n-        }\n-        }\n-        else\n-        break;\n-    processed = in;\n-    }\n-    *outlen = (out - outstart) * 2;\n-    *inlen = processed - instart;\n-    return(*outlen);\n-}\n+#endif \/* LIBXML_ISO8859X_ENABLED *\/\n@@ -611,34 +189,2 @@\n-\/**\n- * UTF8ToUTF16:\n- * @outb:  a pointer to an array of bytes to store the result\n- * @outlen:  the length of @outb\n- * @in:  a pointer to an array of UTF-8 chars\n- * @inlen:  the length of @in\n- *\n- * Take a block of UTF-8 chars in and try to convert it to an UTF-16\n- * block of chars out.\n- *\n- * Returns the number of bytes written or an XML_ENC_ERR code.\n- *\/\n-static int\n-UTF8ToUTF16(unsigned char* outb, int *outlen,\n-            const unsigned char* in, int *inlen)\n-{\n-    if (in == NULL) {\n-    \/*\n-     * initialization, add the Byte Order Mark for UTF-16LE\n-     *\/\n-        if (*outlen >= 2) {\n-        outb[0] = 0xFF;\n-        outb[1] = 0xFE;\n-        *outlen = 2;\n-        *inlen = 0;\n-        return(2);\n-    }\n-    *outlen = 0;\n-    *inlen = 0;\n-    return(0);\n-    }\n-    return (UTF8ToUTF16LE(outb, outlen, in, inlen));\n-}\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n+#define MAKE_HANDLER(name, in, out) \\\n+    { (char *) name, { in }, { out }, NULL, NULL, NULL, XML_HANDLER_STATIC }\n@@ -646,13 +192,2 @@\n-\/**\n- * UTF16BEToUTF8:\n- * @out:  a pointer to an array of bytes to store the result\n- * @outlen:  the length of @out\n- * @inb:  a pointer to an array of UTF-16 passed as a byte array\n- * @inlenb:  the length of @in in UTF-16 chars\n- *\n- * Take a block of UTF-16 ushorts in and try to convert it to an UTF-8\n- * block of chars out. This function assumes the endian property\n- * is the same between the native type of this machine and the\n- * inputed one.\n- *\n- * Returns the number of bytes written or an XML_ENC_ERR code.\n+\/*\n+ * The layout must match enum xmlCharEncoding.\n@@ -660,2 +195,2 @@\n- * The value of *inlen after return is the number of octets consumed\n- * if the return value is positive, else unpredictable.\n+ * Names should match the IANA registry if possible:\n+ * https:\/\/www.iana.org\/assignments\/character-sets\/character-sets.xhtml\n@@ -663,55 +198,33 @@\n-static int\n-UTF16BEToUTF8(unsigned char* out, int *outlen,\n-            const unsigned char* inb, int *inlenb)\n-{\n-    unsigned char* outstart = out;\n-    const unsigned char* processed = inb;\n-    unsigned char* outend;\n-    unsigned short* in = (unsigned short *) (void *) inb;\n-    unsigned short* inend;\n-    unsigned int c, d, inlen;\n-    unsigned char *tmp;\n-    int bits;\n-\n-    if (*outlen == 0) {\n-        *inlenb = 0;\n-        return(0);\n-    }\n-    outend = out + *outlen;\n-    if ((*inlenb % 2) == 1)\n-        (*inlenb)--;\n-    inlen = *inlenb \/ 2;\n-    inend= in + inlen;\n-    while ((in < inend) && (out - outstart + 5 < *outlen)) {\n-    if (xmlLittleEndian) {\n-        tmp = (unsigned char *) in;\n-        c = *tmp++;\n-        c = (c << 8) | *tmp;\n-        in++;\n-    } else {\n-        c= *in++;\n-    }\n-        if ((c & 0xFC00) == 0xD800) {    \/* surrogates *\/\n-        if (in >= inend) {           \/* handle split mutli-byte characters *\/\n-                break;\n-        }\n-        if (xmlLittleEndian) {\n-        tmp = (unsigned char *) in;\n-        d = *tmp++;\n-        d = (d << 8) | *tmp;\n-        in++;\n-        } else {\n-        d= *in++;\n-        }\n-            if ((d & 0xFC00) == 0xDC00) {\n-                c &= 0x03FF;\n-                c <<= 10;\n-                c |= d & 0x03FF;\n-                c += 0x10000;\n-            }\n-            else {\n-        *outlen = out - outstart;\n-        *inlenb = processed - inb;\n-            return(XML_ENC_ERR_INPUT);\n-        }\n-        }\n+static const xmlCharEncodingHandler defaultHandlers[31] = {\n+    MAKE_HANDLER(NULL, NULL, NULL), \/* NONE *\/\n+    MAKE_HANDLER(\"UTF-8\", UTF8ToUTF8, UTF8ToUTF8),\n+    MAKE_HANDLER(\"UTF-16LE\", UTF16LEToUTF8, UTF8ToUTF16LE),\n+    MAKE_HANDLER(\"UTF-16BE\", UTF16BEToUTF8, UTF8ToUTF16BE),\n+    MAKE_HANDLER(\"UCS-4LE\", NULL, NULL),\n+    MAKE_HANDLER(\"UCS-4BE\", NULL, NULL),\n+    MAKE_HANDLER(\"IBM037\", NULL, NULL),\n+    MAKE_HANDLER(NULL, NULL, NULL), \/* UCS4_2143 *\/\n+    MAKE_HANDLER(NULL, NULL, NULL), \/* UCS4_3412 *\/\n+    MAKE_HANDLER(\"UCS-2\", NULL, NULL),\n+    MAKE_HANDLER(\"ISO-8859-1\", latin1ToUTF8, UTF8ToLatin1),\n+    MAKE_ISO_HANDLER(\"ISO-8859-2\", 2),\n+    MAKE_ISO_HANDLER(\"ISO-8859-3\", 3),\n+    MAKE_ISO_HANDLER(\"ISO-8859-4\", 4),\n+    MAKE_ISO_HANDLER(\"ISO-8859-5\", 5),\n+    MAKE_ISO_HANDLER(\"ISO-8859-6\", 6),\n+    MAKE_ISO_HANDLER(\"ISO-8859-7\", 7),\n+    MAKE_ISO_HANDLER(\"ISO-8859-8\", 8),\n+    MAKE_ISO_HANDLER(\"ISO-8859-9\", 9),\n+    MAKE_HANDLER(\"ISO-2022-JP\", NULL, NULL),\n+    MAKE_HANDLER(\"Shift_JIS\", NULL, NULL),\n+    MAKE_HANDLER(\"EUC-JP\", NULL, NULL),\n+    MAKE_HANDLER(\"US-ASCII\", asciiToAscii, asciiToAscii),\n+    MAKE_HANDLER(\"UTF-16\", UTF16LEToUTF8, UTF8ToUTF16),\n+    MAKE_HANDLER(\"HTML\", NULL, UTF8ToHtmlWrapper),\n+    MAKE_ISO_HANDLER(\"ISO-8859-10\", 10),\n+    MAKE_ISO_HANDLER(\"ISO-8859-11\", 11),\n+    MAKE_ISO_HANDLER(\"ISO-8859-13\", 13),\n+    MAKE_ISO_HANDLER(\"ISO-8859-14\", 14),\n+    MAKE_ISO_HANDLER(\"ISO-8859-15\", 15),\n+    MAKE_ISO_HANDLER(\"ISO-8859-16\", 16),\n+};\n@@ -719,7 +232,2 @@\n-    \/* assertion: c is a single UTF-4 value *\/\n-        if (out >= outend)\n-        break;\n-        if      (c <    0x80) {  *out++=  c;                bits= -6; }\n-        else if (c <   0x800) {  *out++= ((c >>  6) & 0x1F) | 0xC0;  bits=  0; }\n-        else if (c < 0x10000) {  *out++= ((c >> 12) & 0x0F) | 0xE0;  bits=  6; }\n-        else                  {  *out++= ((c >> 18) & 0x07) | 0xF0;  bits= 12; }\n+#define NUM_DEFAULT_HANDLERS \\\n+    (sizeof(defaultHandlers) \/ sizeof(defaultHandlers[0]))\n@@ -727,11 +235,4 @@\n-        for ( ; bits >= 0; bits-= 6) {\n-            if (out >= outend)\n-            break;\n-            *out++= ((c >> bits) & 0x3F) | 0x80;\n-        }\n-    processed = (const unsigned char*) in;\n-    }\n-    *outlen = out - outstart;\n-    *inlenb = processed - inb;\n-    return(*outlen);\n-}\n+\/* the size should be growable, but it's not a big deal ... *\/\n+#define MAX_ENCODING_HANDLERS 50\n+static xmlCharEncodingHandlerPtr *globalHandlers = NULL;\n+static int nbCharEncodingHandler = 0;\n@@ -739,27 +240,5 @@\n-#ifdef LIBXML_OUTPUT_ENABLED\n-\/**\n- * UTF8ToUTF16BE:\n- * @outb:  a pointer to an array of bytes to store the result\n- * @outlen:  the length of @outb\n- * @in:  a pointer to an array of UTF-8 chars\n- * @inlen:  the length of @in\n- *\n- * Take a block of UTF-8 chars in and try to convert it to an UTF-16BE\n- * block of chars out.\n- *\n- * Returns the number of bytes written or an XML_ENC_ERR code.\n- *\/\n-static int\n-UTF8ToUTF16BE(unsigned char* outb, int *outlen,\n-            const unsigned char* in, int *inlen)\n-{\n-    unsigned short* out = (unsigned short *) (void *) outb;\n-    const unsigned char* processed = in;\n-    const unsigned char *const instart = in;\n-    unsigned short* outstart= out;\n-    unsigned short* outend;\n-    const unsigned char* inend;\n-    unsigned int c, d;\n-    int trailing;\n-    unsigned char *tmp;\n-    unsigned short tmp1, tmp2;\n+#ifdef LIBXML_ICONV_ENABLED\n+static xmlParserErrors\n+xmlCharEncIconv(const char *name, xmlCharEncFlags flags,\n+                xmlCharEncodingHandler **out);\n+#endif\n@@ -767,79 +246,5 @@\n-    \/* UTF-16BE has no BOM *\/\n-    if ((outb == NULL) || (outlen == NULL) || (inlen == NULL))\n-        return(XML_ENC_ERR_INTERNAL);\n-    if (in == NULL) {\n-    *outlen = 0;\n-    *inlen = 0;\n-    return(0);\n-    }\n-    inend= in + *inlen;\n-    outend = out + (*outlen \/ 2);\n-    while (in < inend) {\n-      d= *in++;\n-      if      (d < 0x80)  { c= d; trailing= 0; }\n-      else if (d < 0xC0)  {\n-          \/* trailing byte in leading position *\/\n-      *outlen = out - outstart;\n-      *inlen = processed - instart;\n-      return(XML_ENC_ERR_INPUT);\n-      } else if (d < 0xE0)  { c= d & 0x1F; trailing= 1; }\n-      else if (d < 0xF0)  { c= d & 0x0F; trailing= 2; }\n-      else if (d < 0xF8)  { c= d & 0x07; trailing= 3; }\n-      else {\n-          \/* no chance for this in UTF-16 *\/\n-      *outlen = out - outstart;\n-      *inlen = processed - instart;\n-      return(XML_ENC_ERR_INPUT);\n-      }\n-\n-      if (inend - in < trailing) {\n-          break;\n-      }\n-\n-      for ( ; trailing; trailing--) {\n-          if ((in >= inend) || (((d= *in++) & 0xC0) != 0x80))  break;\n-          c <<= 6;\n-          c |= d & 0x3F;\n-      }\n-\n-      \/* assertion: c is a single UTF-4 value *\/\n-        if (c < 0x10000) {\n-            if (out >= outend)  break;\n-        if (xmlLittleEndian) {\n-        tmp = (unsigned char *) out;\n-        *tmp = c >> 8;\n-        *(tmp + 1) = (unsigned char) c; \/* Explicit truncation *\/\n-        out++;\n-        } else {\n-        *out++ = c;\n-        }\n-        }\n-        else if (c < 0x110000) {\n-            if (out+1 >= outend)  break;\n-            c -= 0x10000;\n-        if (xmlLittleEndian) {\n-        tmp1 = 0xD800 | (c >> 10);\n-        tmp = (unsigned char *) out;\n-        *tmp = tmp1 >> 8;\n-        *(tmp + 1) = (unsigned char) tmp1; \/* Explicit truncation *\/\n-        out++;\n-\n-        tmp2 = 0xDC00 | (c & 0x03FF);\n-        tmp = (unsigned char *) out;\n-        *tmp = tmp2 >> 8;\n-        *(tmp + 1) = (unsigned char) tmp2; \/* Explicit truncation *\/\n-        out++;\n-        } else {\n-        *out++ = 0xD800 | (c >> 10);\n-        *out++ = 0xDC00 | (c & 0x03FF);\n-        }\n-        }\n-        else\n-        break;\n-    processed = in;\n-    }\n-    *outlen = (out - outstart) * 2;\n-    *inlen = processed - instart;\n-    return(*outlen);\n-}\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n+#ifdef LIBXML_ICU_ENABLED\n+static xmlParserErrors\n+xmlCharEncUconv(const char *name, xmlCharEncFlags flags,\n+                xmlCharEncodingHandler **out);\n+#endif\n@@ -848,3 +253,3 @@\n- *                                    *\n- *        Generic encoding handling routines            *\n- *                                    *\n+ *                                                                      *\n+ *              Generic encoding handling routines                      *\n+ *                                                                      *\n@@ -870,29 +275,23 @@\n-    if ((in[0] == 0x00) && (in[1] == 0x00) &&\n-        (in[2] == 0x00) && (in[3] == 0x3C))\n-        return(XML_CHAR_ENCODING_UCS4BE);\n-    if ((in[0] == 0x3C) && (in[1] == 0x00) &&\n-        (in[2] == 0x00) && (in[3] == 0x00))\n-        return(XML_CHAR_ENCODING_UCS4LE);\n-    if ((in[0] == 0x00) && (in[1] == 0x00) &&\n-        (in[2] == 0x3C) && (in[3] == 0x00))\n-        return(XML_CHAR_ENCODING_UCS4_2143);\n-    if ((in[0] == 0x00) && (in[1] == 0x3C) &&\n-        (in[2] == 0x00) && (in[3] == 0x00))\n-        return(XML_CHAR_ENCODING_UCS4_3412);\n-    if ((in[0] == 0x4C) && (in[1] == 0x6F) &&\n-        (in[2] == 0xA7) && (in[3] == 0x94))\n-        return(XML_CHAR_ENCODING_EBCDIC);\n-    if ((in[0] == 0x3C) && (in[1] == 0x3F) &&\n-        (in[2] == 0x78) && (in[3] == 0x6D))\n-        return(XML_CHAR_ENCODING_UTF8);\n-    \/*\n-     * Although not part of the recommendation, we also\n-     * attempt an \"auto-recognition\" of UTF-16LE and\n-     * UTF-16BE encodings.\n-     *\/\n-    if ((in[0] == 0x3C) && (in[1] == 0x00) &&\n-        (in[2] == 0x3F) && (in[3] == 0x00))\n-        return(XML_CHAR_ENCODING_UTF16LE);\n-    if ((in[0] == 0x00) && (in[1] == 0x3C) &&\n-        (in[2] == 0x00) && (in[3] == 0x3F))\n-        return(XML_CHAR_ENCODING_UTF16BE);\n+        if ((in[0] == 0x00) && (in[1] == 0x00) &&\n+            (in[2] == 0x00) && (in[3] == 0x3C))\n+            return(XML_CHAR_ENCODING_UCS4BE);\n+        if ((in[0] == 0x3C) && (in[1] == 0x00) &&\n+            (in[2] == 0x00) && (in[3] == 0x00))\n+            return(XML_CHAR_ENCODING_UCS4LE);\n+        if ((in[0] == 0x4C) && (in[1] == 0x6F) &&\n+            (in[2] == 0xA7) && (in[3] == 0x94))\n+            return(XML_CHAR_ENCODING_EBCDIC);\n+        if ((in[0] == 0x3C) && (in[1] == 0x3F) &&\n+            (in[2] == 0x78) && (in[3] == 0x6D))\n+            return(XML_CHAR_ENCODING_UTF8);\n+        \/*\n+         * Although not part of the recommendation, we also\n+         * attempt an \"auto-recognition\" of UTF-16LE and\n+         * UTF-16BE encodings.\n+         *\/\n+        if ((in[0] == 0x3C) && (in[1] == 0x00) &&\n+            (in[2] == 0x3F) && (in[3] == 0x00))\n+            return(XML_CHAR_ENCODING_UTF16LE);\n+        if ((in[0] == 0x00) && (in[1] == 0x3C) &&\n+            (in[2] == 0x00) && (in[3] == 0x3F))\n+            return(XML_CHAR_ENCODING_UTF16BE);\n@@ -901,7 +300,7 @@\n-    \/*\n-     * Errata on XML-1.0 June 20 2001\n-     * We now allow an UTF8 encoded BOM\n-     *\/\n-    if ((in[0] == 0xEF) && (in[1] == 0xBB) &&\n-        (in[2] == 0xBF))\n-        return(XML_CHAR_ENCODING_UTF8);\n+        \/*\n+         * Errata on XML-1.0 June 20 2001\n+         * We now allow an UTF8 encoded BOM\n+         *\/\n+        if ((in[0] == 0xEF) && (in[1] == 0xBB) &&\n+            (in[2] == 0xBF))\n+            return(XML_CHAR_ENCODING_UTF8);\n@@ -911,4 +310,4 @@\n-    if ((in[0] == 0xFE) && (in[1] == 0xFF))\n-        return(XML_CHAR_ENCODING_UTF16BE);\n-    if ((in[0] == 0xFF) && (in[1] == 0xFE))\n-        return(XML_CHAR_ENCODING_UTF16LE);\n+        if ((in[0] == 0xFE) && (in[1] == 0xFF))\n+            return(XML_CHAR_ENCODING_UTF16BE);\n+        if ((in[0] == 0xFF) && (in[1] == 0xFE))\n+            return(XML_CHAR_ENCODING_UTF16LE);\n@@ -922,0 +321,3 @@\n+ * DEPRECATED: This function modifies global state and is not\n+ * thread-safe.\n+ *\n@@ -929,1 +331,1 @@\n-    return;\n+        return;\n@@ -932,4 +334,4 @@\n-    if (xmlCharEncodingAliases[i].name != NULL)\n-        xmlFree((char *) xmlCharEncodingAliases[i].name);\n-    if (xmlCharEncodingAliases[i].alias != NULL)\n-        xmlFree((char *) xmlCharEncodingAliases[i].alias);\n+        if (xmlCharEncodingAliases[i].name != NULL)\n+            xmlFree((char *) xmlCharEncodingAliases[i].name);\n+        if (xmlCharEncodingAliases[i].alias != NULL)\n+            xmlFree((char *) xmlCharEncodingAliases[i].alias);\n@@ -947,0 +349,2 @@\n+ * DEPRECATED: This function is not thread-safe.\n+ *\n@@ -957,1 +361,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -960,1 +364,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -964,1 +368,1 @@\n-    if (upper[i] == 0) break;\n+        if (upper[i] == 0) break;\n@@ -972,3 +376,3 @@\n-    if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {\n-        return(xmlCharEncodingAliases[i].name);\n-    }\n+        if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {\n+            return(xmlCharEncodingAliases[i].name);\n+        }\n@@ -984,0 +388,3 @@\n+ * DEPRECATED: This function modifies global state and is not\n+ * thread-safe.\n+ *\n@@ -996,1 +403,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1000,1 +407,1 @@\n-    if (upper[i] == 0) break;\n+        if (upper[i] == 0) break;\n@@ -1006,3 +413,1 @@\n-        size_t newSize = xmlCharEncodingAliasesMax ?\n-                         xmlCharEncodingAliasesMax * 2 :\n-                         20;\n+        int newSize;\n@@ -1010,3 +415,5 @@\n-        tmp = (xmlCharEncodingAliasPtr)\n-              xmlRealloc(xmlCharEncodingAliases,\n-                         newSize * sizeof(xmlCharEncodingAlias));\n+        newSize = xmlGrowCapacity(xmlCharEncodingAliasesMax, sizeof(tmp[0]),\n+                                  20, XML_MAX_ITEMS);\n+        if (newSize < 0)\n+            return(-1);\n+        tmp = xmlRealloc(xmlCharEncodingAliases, newSize * sizeof(tmp[0]));\n@@ -1023,5 +430,5 @@\n-    if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {\n-        \/*\n-         * Replace the definition.\n-         *\/\n-        nameCopy = xmlMemStrdup(name);\n+        if (!strcmp(xmlCharEncodingAliases[i].alias, upper)) {\n+            \/*\n+             * Replace the definition.\n+             *\/\n+            nameCopy = xmlMemStrdup(name);\n@@ -1030,4 +437,4 @@\n-        xmlFree((char *) xmlCharEncodingAliases[i].name);\n-        xmlCharEncodingAliases[i].name = nameCopy;\n-        return(0);\n-    }\n+            xmlFree((char *) xmlCharEncodingAliases[i].name);\n+            xmlCharEncodingAliases[i].name = nameCopy;\n+            return(0);\n+        }\n@@ -1056,0 +463,3 @@\n+ * DEPRECATED: This function modifies global state and is not\n+ * thread-safe.\n+ *\n@@ -1065,1 +475,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1068,1 +478,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1073,8 +483,8 @@\n-    if (!strcmp(xmlCharEncodingAliases[i].alias, alias)) {\n-        xmlFree((char *) xmlCharEncodingAliases[i].name);\n-        xmlFree((char *) xmlCharEncodingAliases[i].alias);\n-        xmlCharEncodingAliasesNb--;\n-        memmove(&xmlCharEncodingAliases[i], &xmlCharEncodingAliases[i + 1],\n-            sizeof(xmlCharEncodingAlias) * (xmlCharEncodingAliasesNb - i));\n-        return(0);\n-    }\n+        if (!strcmp(xmlCharEncodingAliases[i].alias, alias)) {\n+            xmlFree((char *) xmlCharEncodingAliases[i].name);\n+            xmlFree((char *) xmlCharEncodingAliases[i].alias);\n+            xmlCharEncodingAliasesNb--;\n+            memmove(&xmlCharEncodingAliases[i], &xmlCharEncodingAliases[i + 1],\n+                    sizeof(xmlCharEncodingAlias) * (xmlCharEncodingAliasesNb - i));\n+            return(0);\n+        }\n@@ -1085,0 +495,25 @@\n+static int\n+xmlCompareEncTableEntries(const void *vkey, const void *ventry) {\n+    const char *key = vkey;\n+    const xmlEncTableEntry *entry = ventry;\n+\n+    return(xmlStrcasecmp(BAD_CAST key, BAD_CAST entry->name));\n+}\n+\n+static xmlCharEncoding\n+xmlParseCharEncodingInternal(const char *name)\n+{\n+    const xmlEncTableEntry *entry;\n+\n+    if (name == NULL)\n+       return(XML_CHAR_ENCODING_NONE);\n+\n+    entry = bsearch(name, xmlEncTable,\n+                    sizeof(xmlEncTable) \/ sizeof(xmlEncTable[0]),\n+                    sizeof(xmlEncTable[0]), xmlCompareEncTableEntries);\n+    if (entry != NULL)\n+        return(entry->enc);\n+\n+    return(XML_CHAR_ENCODING_ERROR);\n+}\n+\n@@ -1094,64 +529,6 @@\n- * if not recognized.\n- *\/\n-xmlCharEncoding\n-xmlParseCharEncoding(const char* name)\n-{\n-    const char *alias;\n-    char upper[500];\n-    int i;\n-\n-    if (name == NULL)\n-    return(XML_CHAR_ENCODING_NONE);\n-\n-    \/*\n-     * Do the alias resolution\n-     *\/\n-    alias = xmlGetEncodingAlias(name);\n-    if (alias != NULL)\n-    name = alias;\n-\n-    for (i = 0;i < 499;i++) {\n-        upper[i] = (char) toupper((unsigned char) name[i]);\n-    if (upper[i] == 0) break;\n-    }\n-    upper[i] = 0;\n-\n-    if (!strcmp(upper, \"\")) return(XML_CHAR_ENCODING_NONE);\n-    if (!strcmp(upper, \"UTF-8\")) return(XML_CHAR_ENCODING_UTF8);\n-    if (!strcmp(upper, \"UTF8\")) return(XML_CHAR_ENCODING_UTF8);\n-\n-    \/*\n-     * NOTE: if we were able to parse this, the endianness of UTF16 is\n-     *       already found and in use\n-     *\/\n-    if (!strcmp(upper, \"UTF-16\")) return(XML_CHAR_ENCODING_UTF16LE);\n-    if (!strcmp(upper, \"UTF16\")) return(XML_CHAR_ENCODING_UTF16LE);\n-\n-    if (!strcmp(upper, \"ISO-10646-UCS-2\")) return(XML_CHAR_ENCODING_UCS2);\n-    if (!strcmp(upper, \"UCS-2\")) return(XML_CHAR_ENCODING_UCS2);\n-    if (!strcmp(upper, \"UCS2\")) return(XML_CHAR_ENCODING_UCS2);\n-\n-    \/*\n-     * NOTE: if we were able to parse this, the endianness of UCS4 is\n-     *       already found and in use\n-     *\/\n-    if (!strcmp(upper, \"ISO-10646-UCS-4\")) return(XML_CHAR_ENCODING_UCS4LE);\n-    if (!strcmp(upper, \"UCS-4\")) return(XML_CHAR_ENCODING_UCS4LE);\n-    if (!strcmp(upper, \"UCS4\")) return(XML_CHAR_ENCODING_UCS4LE);\n-\n-\n-    if (!strcmp(upper,  \"ISO-8859-1\")) return(XML_CHAR_ENCODING_8859_1);\n-    if (!strcmp(upper,  \"ISO-LATIN-1\")) return(XML_CHAR_ENCODING_8859_1);\n-    if (!strcmp(upper,  \"ISO LATIN 1\")) return(XML_CHAR_ENCODING_8859_1);\n-\n-    if (!strcmp(upper,  \"ISO-8859-2\")) return(XML_CHAR_ENCODING_8859_2);\n-    if (!strcmp(upper,  \"ISO-LATIN-2\")) return(XML_CHAR_ENCODING_8859_2);\n-    if (!strcmp(upper,  \"ISO LATIN 2\")) return(XML_CHAR_ENCODING_8859_2);\n-\n-    if (!strcmp(upper,  \"ISO-8859-3\")) return(XML_CHAR_ENCODING_8859_3);\n-    if (!strcmp(upper,  \"ISO-8859-4\")) return(XML_CHAR_ENCODING_8859_4);\n-    if (!strcmp(upper,  \"ISO-8859-5\")) return(XML_CHAR_ENCODING_8859_5);\n-    if (!strcmp(upper,  \"ISO-8859-6\")) return(XML_CHAR_ENCODING_8859_6);\n-    if (!strcmp(upper,  \"ISO-8859-7\")) return(XML_CHAR_ENCODING_8859_7);\n-    if (!strcmp(upper,  \"ISO-8859-8\")) return(XML_CHAR_ENCODING_8859_8);\n-    if (!strcmp(upper,  \"ISO-8859-9\")) return(XML_CHAR_ENCODING_8859_9);\n+ * if not recognized.\n+ *\/\n+xmlCharEncoding\n+xmlParseCharEncoding(const char *name)\n+{\n+    xmlCharEncoding enc = xmlParseCharEncodingInternal(name);\n@@ -1159,3 +536,3 @@\n-    if (!strcmp(upper, \"ISO-2022-JP\")) return(XML_CHAR_ENCODING_2022_JP);\n-    if (!strcmp(upper, \"SHIFT_JIS\")) return(XML_CHAR_ENCODING_SHIFT_JIS);\n-    if (!strcmp(upper, \"EUC-JP\")) return(XML_CHAR_ENCODING_EUC_JP);\n+    \/* Backward compatibility *\/\n+    if (enc == XML_CHAR_ENCODING_UTF16)\n+        enc = XML_CHAR_ENCODING_UTF16LE;\n@@ -1163,1 +540,1 @@\n-    return(XML_CHAR_ENCODING_ERROR);\n+    return(enc);\n@@ -1176,1 +553,0 @@\n-\n@@ -1180,6 +556,0 @@\n-        case XML_CHAR_ENCODING_ERROR:\n-        return(NULL);\n-        case XML_CHAR_ENCODING_NONE:\n-        return(NULL);\n-        case XML_CHAR_ENCODING_UTF8:\n-        return(\"UTF-8\");\n@@ -1187,1 +557,1 @@\n-        return(\"UTF-16\");\n+            return(\"UTF-16\");\n@@ -1189,3 +559,1 @@\n-        return(\"UTF-16\");\n-        case XML_CHAR_ENCODING_EBCDIC:\n-            return(\"EBCDIC\");\n+            return(\"UTF-16\");\n@@ -1193,1 +561,1 @@\n-            return(\"ISO-10646-UCS-4\");\n+            return(\"UCS-4\");\n@@ -1195,33 +563,3 @@\n-            return(\"ISO-10646-UCS-4\");\n-        case XML_CHAR_ENCODING_UCS4_2143:\n-            return(\"ISO-10646-UCS-4\");\n-        case XML_CHAR_ENCODING_UCS4_3412:\n-            return(\"ISO-10646-UCS-4\");\n-        case XML_CHAR_ENCODING_UCS2:\n-            return(\"ISO-10646-UCS-2\");\n-        case XML_CHAR_ENCODING_8859_1:\n-        return(\"ISO-8859-1\");\n-        case XML_CHAR_ENCODING_8859_2:\n-        return(\"ISO-8859-2\");\n-        case XML_CHAR_ENCODING_8859_3:\n-        return(\"ISO-8859-3\");\n-        case XML_CHAR_ENCODING_8859_4:\n-        return(\"ISO-8859-4\");\n-        case XML_CHAR_ENCODING_8859_5:\n-        return(\"ISO-8859-5\");\n-        case XML_CHAR_ENCODING_8859_6:\n-        return(\"ISO-8859-6\");\n-        case XML_CHAR_ENCODING_8859_7:\n-        return(\"ISO-8859-7\");\n-        case XML_CHAR_ENCODING_8859_8:\n-        return(\"ISO-8859-8\");\n-        case XML_CHAR_ENCODING_8859_9:\n-        return(\"ISO-8859-9\");\n-        case XML_CHAR_ENCODING_2022_JP:\n-            return(\"ISO-2022-JP\");\n-        case XML_CHAR_ENCODING_SHIFT_JIS:\n-            return(\"Shift-JIS\");\n-        case XML_CHAR_ENCODING_EUC_JP:\n-            return(\"EUC-JP\");\n-    case XML_CHAR_ENCODING_ASCII:\n-        return(NULL);\n+            return(\"UCS-4\");\n+        default:\n+            break;\n@@ -1229,1 +567,5 @@\n-    return(NULL);\n+\n+    if ((enc <= 0) || ((size_t) enc >= NUM_DEFAULT_HANDLERS))\n+        return(NULL);\n+\n+    return(defaultHandlers[enc].name);\n@@ -1233,3 +575,3 @@\n- *                                    *\n- *            Char encoding handlers                *\n- *                                    *\n+ *                                                                      *\n+ *                      Char encoding handlers                          *\n+ *                                                                      *\n@@ -1238,98 +580,0 @@\n-#if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED) && \\\n-    defined(LIBXML_ISO8859X_ENABLED)\n-\n-#define DECLARE_ISO_FUNCS(n) \\\n-    static int ISO8859_##n##ToUTF8(unsigned char* out, int *outlen, \\\n-                                   const unsigned char* in, int *inlen); \\\n-    static int UTF8ToISO8859_##n(unsigned char* out, int *outlen, \\\n-                                 const unsigned char* in, int *inlen);\n-\n-\/** DOC_DISABLE *\/\n-DECLARE_ISO_FUNCS(2)\n-DECLARE_ISO_FUNCS(3)\n-DECLARE_ISO_FUNCS(4)\n-DECLARE_ISO_FUNCS(5)\n-DECLARE_ISO_FUNCS(6)\n-DECLARE_ISO_FUNCS(7)\n-DECLARE_ISO_FUNCS(8)\n-DECLARE_ISO_FUNCS(9)\n-DECLARE_ISO_FUNCS(10)\n-DECLARE_ISO_FUNCS(11)\n-DECLARE_ISO_FUNCS(13)\n-DECLARE_ISO_FUNCS(14)\n-DECLARE_ISO_FUNCS(15)\n-DECLARE_ISO_FUNCS(16)\n-\/** DOC_ENABLE *\/\n-\n-#endif \/* LIBXML_ISO8859X_ENABLED *\/\n-\n-#ifdef LIBXML_ICONV_ENABLED\n-  #define EMPTY_ICONV , (iconv_t) -1, (iconv_t) -1\n-#else\n-  #define EMPTY_ICONV\n-#endif\n-\n-#ifdef LIBXML_ICU_ENABLED\n-  #define EMPTY_UCONV , NULL, NULL\n-#else\n-  #define EMPTY_UCONV\n-#endif\n-\n-#define MAKE_HANDLER(name, in, out) \\\n-    { (char *) name, in, out EMPTY_ICONV EMPTY_UCONV }\n-\n-static const xmlCharEncodingHandler defaultHandlers[] = {\n-#ifdef LIBXML_OUTPUT_ENABLED\n-    MAKE_HANDLER(\"UTF-16LE\", UTF16LEToUTF8, UTF8ToUTF16LE)\n-    ,MAKE_HANDLER(\"UTF-16BE\", UTF16BEToUTF8, UTF8ToUTF16BE)\n-    ,MAKE_HANDLER(\"UTF-16\", UTF16LEToUTF8, UTF8ToUTF16)\n-    ,MAKE_HANDLER(\"ISO-8859-1\", isolat1ToUTF8, UTF8Toisolat1)\n-    ,MAKE_HANDLER(\"ASCII\", asciiToUTF8, UTF8Toascii)\n-    ,MAKE_HANDLER(\"US-ASCII\", asciiToUTF8, UTF8Toascii)\n-#ifdef LIBXML_HTML_ENABLED\n-    ,MAKE_HANDLER(\"HTML\", NULL, UTF8ToHtml)\n-#endif\n-#else\n-    MAKE_HANDLER(\"UTF-16LE\", UTF16LEToUTF8, NULL)\n-    ,MAKE_HANDLER(\"UTF-16BE\", UTF16BEToUTF8, NULL)\n-    ,MAKE_HANDLER(\"UTF-16\", UTF16LEToUTF8, NULL)\n-    ,MAKE_HANDLER(\"ISO-8859-1\", isolat1ToUTF8, NULL)\n-    ,MAKE_HANDLER(\"ASCII\", asciiToUTF8, NULL)\n-    ,MAKE_HANDLER(\"US-ASCII\", asciiToUTF8, NULL)\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-\n-#if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED) && \\\n-    defined(LIBXML_ISO8859X_ENABLED)\n-    ,MAKE_HANDLER(\"ISO-8859-2\", ISO8859_2ToUTF8, UTF8ToISO8859_2)\n-    ,MAKE_HANDLER(\"ISO-8859-3\", ISO8859_3ToUTF8, UTF8ToISO8859_3)\n-    ,MAKE_HANDLER(\"ISO-8859-4\", ISO8859_4ToUTF8, UTF8ToISO8859_4)\n-    ,MAKE_HANDLER(\"ISO-8859-5\", ISO8859_5ToUTF8, UTF8ToISO8859_5)\n-    ,MAKE_HANDLER(\"ISO-8859-6\", ISO8859_6ToUTF8, UTF8ToISO8859_6)\n-    ,MAKE_HANDLER(\"ISO-8859-7\", ISO8859_7ToUTF8, UTF8ToISO8859_7)\n-    ,MAKE_HANDLER(\"ISO-8859-8\", ISO8859_8ToUTF8, UTF8ToISO8859_8)\n-    ,MAKE_HANDLER(\"ISO-8859-9\", ISO8859_9ToUTF8, UTF8ToISO8859_9)\n-    ,MAKE_HANDLER(\"ISO-8859-10\", ISO8859_10ToUTF8, UTF8ToISO8859_10)\n-    ,MAKE_HANDLER(\"ISO-8859-11\", ISO8859_11ToUTF8, UTF8ToISO8859_11)\n-    ,MAKE_HANDLER(\"ISO-8859-13\", ISO8859_13ToUTF8, UTF8ToISO8859_13)\n-    ,MAKE_HANDLER(\"ISO-8859-14\", ISO8859_14ToUTF8, UTF8ToISO8859_14)\n-    ,MAKE_HANDLER(\"ISO-8859-15\", ISO8859_15ToUTF8, UTF8ToISO8859_15)\n-    ,MAKE_HANDLER(\"ISO-8859-16\", ISO8859_16ToUTF8, UTF8ToISO8859_16)\n-#endif\n-};\n-\n-#define NUM_DEFAULT_HANDLERS \\\n-    (sizeof(defaultHandlers) \/ sizeof(defaultHandlers[0]))\n-\n-static const xmlCharEncodingHandler xmlUTF8Handler =\n-    MAKE_HANDLER(\"UTF-8\", UTF8ToUTF8, UTF8ToUTF8);\n-\n-static const xmlCharEncodingHandler *xmlUTF16LEHandler = &defaultHandlers[0];\n-static const xmlCharEncodingHandler *xmlUTF16BEHandler = &defaultHandlers[1];\n-static const xmlCharEncodingHandler *xmlLatin1Handler = &defaultHandlers[3];\n-static const xmlCharEncodingHandler *xmlAsciiHandler = &defaultHandlers[4];\n-\n-\/* the size should be growable, but it's not a big deal ... *\/\n-#define MAX_ENCODING_HANDLERS 50\n-static xmlCharEncodingHandlerPtr *handlers = NULL;\n-static int nbCharEncodingHandler = 0;\n-\n@@ -1342,0 +586,3 @@\n+ * DEPRECATED: This function modifies global state and is not\n+ * thread-safe.\n+ *\n@@ -1361,1 +608,1 @@\n-    name = alias;\n+        name = alias;\n@@ -1367,1 +614,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1370,1 +617,1 @@\n-    if (upper[i] == 0) break;\n+        if (upper[i] == 0) break;\n@@ -1375,1 +622,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1384,1 +631,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1387,2 +634,2 @@\n-    handler->input = input;\n-    handler->output = output;\n+    handler->input.legacyFunc = input;\n+    handler->output.legacyFunc = output;\n@@ -1390,9 +637,1 @@\n-\n-#ifdef LIBXML_ICONV_ENABLED\n-    handler->iconv_in = (iconv_t) -1;\n-    handler->iconv_out = (iconv_t) -1;\n-#endif\n-#ifdef LIBXML_ICU_ENABLED\n-    handler->uconv_in = NULL;\n-    handler->uconv_out = NULL;\n-#endif\n+    handler->flags = XML_HANDLER_STATIC | XML_HANDLER_LEGACY;\n@@ -1407,0 +646,58 @@\n+\/**\n+ * xmlCharEncNewCustomHandler:\n+ * @name:  the encoding name\n+ * @input:  input callback which converts to UTF-8\n+ * @output:  output callback which converts from UTF-8\n+ * @ctxtDtor:  context destructor\n+ * @inputCtxt:  context for input callback\n+ * @outputCtxt:  context for output callback\n+ * @out:  pointer to resulting handler\n+ *\n+ * Create a custom xmlCharEncodingHandler.\n+ *\n+ * Returns an xmlParserErrors code.\n+ *\/\n+xmlParserErrors\n+xmlCharEncNewCustomHandler(const char *name,\n+                           xmlCharEncConvFunc input, xmlCharEncConvFunc output,\n+                           xmlCharEncConvCtxtDtor ctxtDtor,\n+                           void *inputCtxt, void *outputCtxt,\n+                           xmlCharEncodingHandler **out) {\n+    xmlCharEncodingHandler *handler;\n+\n+    if (out == NULL)\n+        return(XML_ERR_ARGUMENT);\n+\n+    handler = xmlMalloc(sizeof(*handler));\n+    if (handler == NULL)\n+        goto error;\n+    memset(handler, 0, sizeof(*handler));\n+\n+    if (name != NULL) {\n+        handler->name = xmlMemStrdup(name);\n+        if (handler->name == NULL)\n+            goto error;\n+    }\n+\n+    handler->input.func = input;\n+    handler->output.func = output;\n+    handler->ctxtDtor = ctxtDtor;\n+    handler->inputCtxt = inputCtxt;\n+    handler->outputCtxt = outputCtxt;\n+\n+    *out = handler;\n+    return(XML_ERR_OK);\n+\n+error:\n+    xmlFree(handler);\n+\n+    if (ctxtDtor != NULL) {\n+        if (inputCtxt != NULL)\n+            ctxtDtor(inputCtxt);\n+        if (outputCtxt != NULL)\n+            ctxtDtor(outputCtxt);\n+    }\n+\n+    return(XML_ERR_NO_MEMORY);\n+}\n+\n@@ -1446,1 +743,1 @@\n-    if (handlers == NULL) return;\n+    if (globalHandlers == NULL) return;\n@@ -1449,0 +746,2 @@\n+        xmlCharEncodingHandler *handler;\n+\n@@ -1450,5 +749,6 @@\n-    if (handlers[nbCharEncodingHandler] != NULL) {\n-        if (handlers[nbCharEncodingHandler]->name != NULL)\n-        xmlFree(handlers[nbCharEncodingHandler]->name);\n-        xmlFree(handlers[nbCharEncodingHandler]);\n-    }\n+        handler = globalHandlers[nbCharEncodingHandler];\n+        if (handler != NULL) {\n+            if (handler->name != NULL)\n+                xmlFree(handler->name);\n+            xmlFree(handler);\n+        }\n@@ -1456,2 +756,2 @@\n-    xmlFree(handlers);\n-    handlers = NULL;\n+    xmlFree(globalHandlers);\n+    globalHandlers = NULL;\n@@ -1465,1 +765,4 @@\n- * Register the char encoding handler, surprising, isn't it ?\n+ * DEPRECATED: This function modifies global state and is not\n+ * thread-safe.\n+ *\n+ * Register the char encoding handler.\n@@ -1471,3 +774,4 @@\n-    if (handlers == NULL) {\n-        handlers = xmlMalloc(MAX_ENCODING_HANDLERS * sizeof(handlers[0]));\n-        if (handlers == NULL)\n+    if (globalHandlers == NULL) {\n+        globalHandlers = xmlMalloc(\n+                MAX_ENCODING_HANDLERS * sizeof(globalHandlers[0]));\n+        if (globalHandlers == NULL)\n@@ -1479,1 +783,1 @@\n-    handlers[nbCharEncodingHandler++] = handler;\n+    globalHandlers[nbCharEncodingHandler++] = handler;\n@@ -1491,174 +795,0 @@\n-#ifdef LIBXML_ICONV_ENABLED\n-static int\n-xmlCreateIconvHandler(const char *name, xmlCharEncodingHandler **out) {\n-    xmlCharEncodingHandlerPtr enc = NULL;\n-    iconv_t icv_in = (iconv_t) -1;\n-    iconv_t icv_out = (iconv_t) -1;\n-    int ret;\n-\n-    *out = NULL;\n-\n-    icv_in = iconv_open(\"UTF-8\", name);\n-    if (icv_in == (iconv_t) -1) {\n-        if (errno == EINVAL)\n-            ret = XML_ERR_UNSUPPORTED_ENCODING;\n-        else if (errno == ENOMEM)\n-            ret = XML_ERR_NO_MEMORY;\n-        else\n-            ret = XML_ERR_SYSTEM;\n-        goto error;\n-    }\n-\n-    icv_out = iconv_open(name, \"UTF-8\");\n-    if (icv_out == (iconv_t) -1) {\n-        if (errno == EINVAL)\n-            ret = XML_ERR_UNSUPPORTED_ENCODING;\n-        else if (errno == ENOMEM)\n-            ret = XML_ERR_NO_MEMORY;\n-        else\n-            ret = XML_ERR_SYSTEM;\n-        goto error;\n-    }\n-\n-    enc = xmlMalloc(sizeof(*enc));\n-    if (enc == NULL) {\n-        ret = XML_ERR_NO_MEMORY;\n-        goto error;\n-    }\n-    memset(enc, 0, sizeof(*enc));\n-\n-    enc->name = xmlMemStrdup(name);\n-    if (enc->name == NULL) {\n-        ret = XML_ERR_NO_MEMORY;\n-        goto error;\n-    }\n-    enc->iconv_in = icv_in;\n-    enc->iconv_out = icv_out;\n-\n-    *out = enc;\n-    return(0);\n-\n-error:\n-    if (enc != NULL)\n-        xmlFree(enc);\n-    if (icv_in != (iconv_t) -1)\n-        iconv_close(icv_in);\n-    if (icv_out != (iconv_t) -1)\n-        iconv_close(icv_out);\n-    return(ret);\n-}\n-#endif \/* LIBXML_ICONV_ENABLED *\/\n-\n-#ifdef LIBXML_ICU_ENABLED\n-static int\n-openIcuConverter(const char* name, int toUnicode, uconv_t **out)\n-{\n-    UErrorCode status;\n-    uconv_t *conv;\n-\n-    *out = NULL;\n-\n-    conv = (uconv_t *) xmlMalloc(sizeof(uconv_t));\n-    if (conv == NULL)\n-        return(XML_ERR_NO_MEMORY);\n-\n-    conv->pivot_source = conv->pivot_buf;\n-    conv->pivot_target = conv->pivot_buf;\n-\n-    status = U_ZERO_ERROR;\n-    conv->uconv = ucnv_open(name, &status);\n-    if (U_FAILURE(status))\n-        goto error;\n-\n-    status = U_ZERO_ERROR;\n-    if (toUnicode) {\n-        ucnv_setToUCallBack(conv->uconv, UCNV_TO_U_CALLBACK_STOP,\n-                                                NULL, NULL, NULL, &status);\n-    }\n-    else {\n-        ucnv_setFromUCallBack(conv->uconv, UCNV_FROM_U_CALLBACK_STOP,\n-                                                NULL, NULL, NULL, &status);\n-    }\n-    if (U_FAILURE(status))\n-        goto error;\n-\n-    status = U_ZERO_ERROR;\n-    conv->utf8 = ucnv_open(\"UTF-8\", &status);\n-    if (U_FAILURE(status))\n-        goto error;\n-\n-    *out = conv;\n-    return(0);\n-\n-error:\n-    if (conv->uconv)\n-        ucnv_close(conv->uconv);\n-    xmlFree(conv);\n-\n-    if (status == U_FILE_ACCESS_ERROR)\n-        return(XML_ERR_UNSUPPORTED_ENCODING);\n-    if (status == U_MEMORY_ALLOCATION_ERROR)\n-        return(XML_ERR_NO_MEMORY);\n-    return(XML_ERR_SYSTEM);\n-}\n-\n-static void\n-closeIcuConverter(uconv_t *conv)\n-{\n-    if (conv == NULL)\n-        return;\n-    ucnv_close(conv->uconv);\n-    ucnv_close(conv->utf8);\n-    xmlFree(conv);\n-}\n-\n-static int\n-xmlCreateUconvHandler(const char *name, xmlCharEncodingHandler **out) {\n-    xmlCharEncodingHandlerPtr enc = NULL;\n-    uconv_t *ucv_in = NULL;\n-    uconv_t *ucv_out = NULL;\n-    int ret;\n-\n-    ret = openIcuConverter(name, 1, &ucv_in);\n-    if (ret != 0)\n-        goto error;\n-    ret = openIcuConverter(name, 0, &ucv_out);\n-    if (ret != 0)\n-        goto error;\n-\n-    enc = (xmlCharEncodingHandlerPtr)\n-           xmlMalloc(sizeof(xmlCharEncodingHandler));\n-    if (enc == NULL) {\n-        ret = XML_ERR_NO_MEMORY;\n-        goto error;\n-    }\n-    memset(enc, 0, sizeof(xmlCharEncodingHandler));\n-\n-    enc->name = xmlMemStrdup(name);\n-    if (enc->name == NULL) {\n-        ret = XML_ERR_NO_MEMORY;\n-        goto error;\n-    }\n-    enc->input = NULL;\n-    enc->output = NULL;\n-#ifdef LIBXML_ICONV_ENABLED\n-    enc->iconv_in = (iconv_t) -1;\n-    enc->iconv_out = (iconv_t) -1;\n-#endif\n-    enc->uconv_in = ucv_in;\n-    enc->uconv_out = ucv_out;\n-\n-    *out = enc;\n-    return(0);\n-\n-error:\n-    if (enc != NULL)\n-        xmlFree(enc);\n-    if (ucv_in != NULL)\n-        closeIcuConverter(ucv_in);\n-    if (ucv_out != NULL)\n-        closeIcuConverter(ucv_out);\n-    return(ret);\n-}\n-#endif \/* LIBXML_ICU_ENABLED *\/\n-\n@@ -1667,2 +797,5 @@\n- * @name:  a string describing the char encoding.\n- * @output:  boolean, use handler for output\n+ * @norig:  name of the char encoding\n+ * @name:  potentially aliased name of the encoding\n+ * @flags:  bit mask of flags\n+ * @impl:  a conversion implementation (optional)\n+ * @implCtxt:  user data for conversion implementation (optional)\n@@ -1673,2 +806,1 @@\n- * Returns 0 on success, 1 if no handler was found, -1 if a memory\n- * allocation failed.\n+ * Returns an xmlParserErrors error code.\n@@ -1676,2 +808,3 @@\n-static int\n-xmlFindExtraHandler(const char *name, int output,\n+static xmlParserErrors\n+xmlFindExtraHandler(const char *norig, const char *name, xmlCharEncFlags flags,\n+                    xmlCharEncConvImpl impl, void *implCtxt,\n@@ -1679,2 +812,8 @@\n-    int ret;\n-    int i;\n+    \/*\n+     * Try custom implementation before deprecated global handlers.\n+     *\n+     * Note that we pass the original name without deprecated\n+     * alias resolution.\n+     *\/\n+    if (impl != NULL)\n+        return(impl(implCtxt, norig, flags, out));\n@@ -1682,1 +821,5 @@\n-    (void) ret;\n+    \/*\n+     * Deprecated\n+     *\/\n+    if (globalHandlers != NULL) {\n+        int i;\n@@ -1684,1 +827,0 @@\n-    if (handlers != NULL) {\n@@ -1686,1 +828,1 @@\n-            xmlCharEncodingHandler *handler = handlers[i];\n+            xmlCharEncodingHandler *h = globalHandlers[i];\n@@ -1689,11 +831,5 @@\n-                               (const xmlChar *) handler->name)) {\n-                if (output) {\n-                    if (handler->output != NULL) {\n-                        *out = handler;\n-                        return(0);\n-                    }\n-                } else {\n-                    if (handler->input != NULL) {\n-                        *out = handler;\n-                        return(0);\n-                    }\n+                               (const xmlChar *) h->name)) {\n+                if ((((flags & XML_ENC_INPUT) == 0) || (h->input.func)) &&\n+                    (((flags & XML_ENC_OUTPUT) == 0) || (h->output.func))) {\n+                    *out = h;\n+                    return(XML_ERR_OK);\n@@ -1706,5 +842,8 @@\n-    ret = xmlCreateIconvHandler(name, out);\n-    if (*out != NULL)\n-        return(0);\n-    if (ret != XML_ERR_UNSUPPORTED_ENCODING)\n-        return(ret);\n+    {\n+        int ret = xmlCharEncIconv(name, flags, out);\n+\n+        if (ret == XML_ERR_OK)\n+            return(XML_ERR_OK);\n+        if (ret != XML_ERR_UNSUPPORTED_ENCODING)\n+            return(ret);\n+    }\n@@ -1714,30 +853,2 @@\n-    ret = xmlCreateUconvHandler(name, out);\n-    if (*out != NULL)\n-        return(0);\n-    if (ret != XML_ERR_UNSUPPORTED_ENCODING)\n-        return(ret);\n-#endif \/* LIBXML_ICU_ENABLED *\/\n-\n-    return(XML_ERR_UNSUPPORTED_ENCODING);\n-}\n-\n-\/**\n- * xmlFindHandler:\n- * @name:  a string describing the char encoding.\n- * @output:  boolean, use handler for output\n- * @out:  pointer to resulting handler\n- *\n- * Search all handlers for an exact match.\n- *\n- * Returns 0 on success, 1 if no handler was found, -1 if a memory\n- * allocation failed.\n- *\/\n-static int\n-xmlFindHandler(const char *name, int output, xmlCharEncodingHandler **out) {\n-    int i;\n-\n-    \/*\n-     * Check for default handlers\n-     *\/\n-    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {\n-        xmlCharEncodingHandler *handler;\n+    {\n+        int ret = xmlCharEncUconv(name, flags, out);\n@@ -1745,16 +856,4 @@\n-        handler = (xmlCharEncodingHandler *) &defaultHandlers[i];\n-\n-        if (xmlStrcasecmp((const xmlChar *) name,\n-                          (const xmlChar *) handler->name) == 0) {\n-            if (output) {\n-                if (handler->output != NULL) {\n-                    *out = handler;\n-                    return(0);\n-                }\n-            } else {\n-                if (handler->input != NULL) {\n-                    *out = handler;\n-                    return(0);\n-                }\n-            }\n-        }\n+        if (ret == XML_ERR_OK)\n+            return(XML_ERR_OK);\n+        if (ret != XML_ERR_UNSUPPORTED_ENCODING)\n+            return(ret);\n@@ -1762,0 +861,1 @@\n+#endif \/* LIBXML_ICU_ENABLED *\/\n@@ -1763,4 +863,1 @@\n-    \/*\n-     * Check for other handlers\n-     *\/\n-    return(xmlFindExtraHandler(name, output, out));\n+    return(XML_ERR_UNSUPPORTED_ENCODING);\n@@ -1774,3 +871,7 @@\n- * Find or create a handler matching the encoding. If no default or\n- * registered handler could be found, try to create a handler using\n- * iconv or ICU if supported.\n+ * Find or create a handler matching the encoding. The following\n+ * converters are looked up in order:\n+ *\n+ * - Built-in handler (UTF-8, UTF-16, ISO-8859-1, ASCII)\n+ * - User-registered global handler (deprecated)\n+ * - iconv if enabled\n+ * - ICU if enabled\n@@ -1780,0 +881,3 @@\n+ * If the encoding is UTF-8, a NULL handler and no error code will\n+ * be returned.\n+ *\n@@ -1782,1 +886,2 @@\n- * Returns an xmlParserErrors error code.\n+ * Returns XML_ERR_OK, XML_ERR_UNSUPPORTED_ENCODING or another\n+ * xmlParserErrors error code.\n@@ -1784,1 +889,1 @@\n-int\n+xmlParserErrors\n@@ -1787,17 +892,1 @@\n-    const char *name = NULL;\n-    static const char *const ebcdicNames[] = {\n-        \"EBCDIC\", \"ebcdic\", \"EBCDIC-US\", \"IBM-037\"\n-    };\n-    static const char *const ucs4Names[] = {\n-        \"ISO-10646-UCS-4\", \"UCS-4\", \"UCS4\"\n-    };\n-    static const char *const ucs2Names[] = {\n-        \"ISO-10646-UCS-2\", \"UCS-2\", \"UCS2\"\n-    };\n-    static const char *const shiftJisNames[] = {\n-        \"SHIFT-JIS\", \"SHIFT_JIS\", \"Shift_JIS\",\n-    };\n-    const char *const *names = NULL;\n-    int numNames = 0;\n-    int ret;\n-    int i;\n+    const xmlCharEncodingHandler *handler;\n@@ -1809,2 +898,1 @@\n-    switch (enc) {\n-        case XML_CHAR_ENCODING_ERROR:\n+    if ((enc <= 0) || ((size_t) enc >= NUM_DEFAULT_HANDLERS))\n@@ -1812,84 +900,20 @@\n-        case XML_CHAR_ENCODING_NONE:\n-        return(0);\n-        case XML_CHAR_ENCODING_UTF8:\n-        return(0);\n-        case XML_CHAR_ENCODING_UTF16LE:\n-        *out = (xmlCharEncodingHandler *) xmlUTF16LEHandler;\n-            return(0);\n-        case XML_CHAR_ENCODING_UTF16BE:\n-        *out = (xmlCharEncodingHandler *) xmlUTF16BEHandler;\n-            return(0);\n-        case XML_CHAR_ENCODING_EBCDIC:\n-            names = ebcdicNames;\n-            numNames = sizeof(ebcdicNames) \/ sizeof(ebcdicNames[0]);\n-        break;\n-        case XML_CHAR_ENCODING_UCS4BE:\n-        case XML_CHAR_ENCODING_UCS4LE:\n-            names = ucs4Names;\n-            numNames = sizeof(ucs4Names) \/ sizeof(ucs4Names[0]);\n-        break;\n-        case XML_CHAR_ENCODING_UCS4_2143:\n-        break;\n-        case XML_CHAR_ENCODING_UCS4_3412:\n-        break;\n-        case XML_CHAR_ENCODING_UCS2:\n-            names = ucs2Names;\n-            numNames = sizeof(ucs2Names) \/ sizeof(ucs2Names[0]);\n-        break;\n-\n-        case XML_CHAR_ENCODING_ASCII:\n-        *out = (xmlCharEncodingHandler *) xmlAsciiHandler;\n-            return(0);\n-        case XML_CHAR_ENCODING_8859_1:\n-        *out = (xmlCharEncodingHandler *) xmlLatin1Handler;\n-            return(0);\n-        case XML_CHAR_ENCODING_8859_2:\n-        name = \"ISO-8859-2\";\n-        break;\n-        case XML_CHAR_ENCODING_8859_3:\n-        name = \"ISO-8859-3\";\n-        break;\n-        case XML_CHAR_ENCODING_8859_4:\n-        name = \"ISO-8859-4\";\n-        break;\n-        case XML_CHAR_ENCODING_8859_5:\n-        name = \"ISO-8859-5\";\n-        break;\n-        case XML_CHAR_ENCODING_8859_6:\n-        name = \"ISO-8859-6\";\n-        break;\n-        case XML_CHAR_ENCODING_8859_7:\n-        name = \"ISO-8859-7\";\n-        break;\n-        case XML_CHAR_ENCODING_8859_8:\n-        name = \"ISO-8859-8\";\n-        break;\n-        case XML_CHAR_ENCODING_8859_9:\n-        name = \"ISO-8859-9\";\n-        break;\n-\n-        case XML_CHAR_ENCODING_2022_JP:\n-            name = \"ISO-2022-JP\";\n-        break;\n-        case XML_CHAR_ENCODING_SHIFT_JIS:\n-            names = shiftJisNames;\n-            numNames = sizeof(shiftJisNames) \/ sizeof(shiftJisNames[0]);\n-        break;\n-        case XML_CHAR_ENCODING_EUC_JP:\n-            name = \"EUC-JP\";\n-        break;\n-    default:\n-        break;\n-    }\n-\n-    if (name != NULL)\n-        return(xmlFindExtraHandler(name, 0, out));\n-\n-    if (names != NULL) {\n-        for (i = 0; i < numNames; i++) {\n-            ret = xmlFindExtraHandler(names[i], 0, out);\n-            if (*out != NULL)\n-                return(0);\n-            if (ret != XML_ERR_UNSUPPORTED_ENCODING)\n-                return(ret);\n-        }\n+\n+    \/* Return NULL handler for UTF-8 *\/\n+    if ((enc == XML_CHAR_ENCODING_UTF8) ||\n+        (enc == XML_CHAR_ENCODING_NONE))\n+        return(XML_ERR_OK);\n+\n+    handler = &defaultHandlers[enc];\n+    if ((handler->input.func != NULL) || (handler->output.func != NULL)) {\n+        *out = (xmlCharEncodingHandler *) handler;\n+        return(XML_ERR_OK);\n+    }\n+\n+    if (handler->name != NULL) {\n+        xmlCharEncFlags flags = XML_ENC_INPUT;\n+\n+#ifdef LIBXML_OUTPUT_ENABLED\n+        flags |= XML_ENC_OUTPUT;\n+#endif\n+        return(xmlFindExtraHandler(handler->name, handler->name, flags,\n+                                   NULL, NULL, out));\n@@ -1920,1 +944,1 @@\n- * xmlOpenCharEncodingHandler:\n+ * xmlCreateCharEncodingHandler:\n@@ -1922,1 +946,3 @@\n- * @output:  boolean, use handler for output\n+ * @flags:  bit mask of flags\n+ * @impl:  a conversion implementation (optional)\n+ * @implCtxt:  user data for conversion implementation (optional)\n@@ -1925,3 +951,8 @@\n- * Find or create a handler matching the encoding. If no default or\n- * registered handler could be found, try to create a handler using\n- * iconv or ICU if supported.\n+ * Find or create a handler matching the encoding. The following\n+ * converters are looked up in order:\n+ *\n+ * - Built-in handler (UTF-8, UTF-16, ISO-8859-1, ASCII)\n+ * - Custom implementation if provided\n+ * - User-registered global handler (deprecated)\n+ * - iconv if enabled\n+ * - ICU if enabled\n@@ -1934,1 +965,1 @@\n- * Available since 2.13.0.\n+ * @flags can contain XML_ENC_INPUT, XML_ENC_OUTPUT or both.\n@@ -1936,1 +967,4 @@\n- * Returns an xmlParserErrors error code.\n+ * Available since 2.14.0.\n+ *\n+ * Returns XML_ERR_OK, XML_ERR_UNSUPPORTED_ENCODING or another\n+ * xmlParserErrors error code.\n@@ -1938,5 +972,6 @@\n-int\n-xmlOpenCharEncodingHandler(const char *name, int output,\n-                           xmlCharEncodingHandler **out) {\n-    const char *nalias;\n-    const char *norig;\n+xmlParserErrors\n+xmlCreateCharEncodingHandler(const char *name, xmlCharEncFlags flags,\n+                             xmlCharEncConvImpl impl, void *implCtxt,\n+                             xmlCharEncodingHandler **out) {\n+    const xmlCharEncodingHandler *handler;\n+    const char *norig, *nalias;\n@@ -1944,1 +979,0 @@\n-    int ret;\n@@ -1950,1 +984,1 @@\n-    if (name == NULL)\n+    if ((name == NULL) || (flags == 0))\n@@ -1953,7 +987,0 @@\n-    if ((xmlStrcasecmp(BAD_CAST name, BAD_CAST \"UTF-8\") == 0) ||\n-        (xmlStrcasecmp(BAD_CAST name, BAD_CAST \"UTF8\") == 0))\n-        return(XML_ERR_OK);\n-\n-    \/*\n-     * Do the alias resolution\n-     *\/\n@@ -1963,1 +990,1 @@\n-    name = nalias;\n+        name = nalias;\n@@ -1965,5 +992,1 @@\n-    ret = xmlFindHandler(name, output, out);\n-    if (*out != NULL)\n-        return(0);\n-    if (ret != XML_ERR_UNSUPPORTED_ENCODING)\n-        return(ret);\n+    enc = xmlParseCharEncodingInternal(name);\n@@ -1971,8 +994,46 @@\n-    \/*\n-     * Fallback using the canonical names\n-     *\n-     * TODO: We should make sure that the name of the returned\n-     * handler equals norig.\n-     *\/\n-    enc = xmlParseCharEncoding(norig);\n-    return(xmlLookupCharEncodingHandler(enc, out));\n+    \/* Return NULL handler for UTF-8 *\/\n+    if (enc == XML_CHAR_ENCODING_UTF8)\n+        return(XML_ERR_OK);\n+\n+    if ((enc > 0) && ((size_t) enc < NUM_DEFAULT_HANDLERS)) {\n+        handler = &defaultHandlers[enc];\n+        if ((((flags & XML_ENC_INPUT) == 0) || (handler->input.func)) &&\n+            (((flags & XML_ENC_OUTPUT) == 0) || (handler->output.func))) {\n+            *out = (xmlCharEncodingHandler *) handler;\n+            return(XML_ERR_OK);\n+        }\n+    }\n+\n+    return(xmlFindExtraHandler(norig, name, flags, impl, implCtxt, out));\n+}\n+\n+\/**\n+ * xmlOpenCharEncodingHandler:\n+ * @name:  a string describing the char encoding.\n+ * @output:  boolean, use handler for output\n+ * @out:  pointer to result\n+ *\n+ * Find or create a handler matching the encoding. The following\n+ * converters are looked up in order:\n+ *\n+ * - Built-in handler (UTF-8, UTF-16, ISO-8859-1, ASCII)\n+ * - User-registered global handler (deprecated)\n+ * - iconv if enabled\n+ * - ICU if enabled\n+ *\n+ * The handler must be closed with xmlCharEncCloseFunc.\n+ *\n+ * If the encoding is UTF-8, a NULL handler and no error code will\n+ * be returned.\n+ *\n+ * Available since 2.13.0.\n+ *\n+ * Returns XML_ERR_OK, XML_ERR_UNSUPPORTED_ENCODING or another\n+ * xmlParserErrors error code.\n+ *\/\n+xmlParserErrors\n+xmlOpenCharEncodingHandler(const char *name, int output,\n+                           xmlCharEncodingHandler **out) {\n+    xmlCharEncFlags flags = output ? XML_ENC_OUTPUT : XML_ENC_INPUT;\n+\n+    return(xmlCreateCharEncodingHandler(name, flags, NULL, NULL, out));\n@@ -1988,0 +1049,3 @@\n+ * If the encoding is UTF-8, this will return a no-op handler that\n+ * shouldn't be used.\n+ *\n@@ -1994,0 +1058,1 @@\n+    xmlCharEncFlags flags;\n@@ -2001,1 +1066,2 @@\n-        return((xmlCharEncodingHandlerPtr) &xmlUTF8Handler);\n+        return((xmlCharEncodingHandlerPtr)\n+                &defaultHandlers[XML_CHAR_ENCODING_UTF8]);\n@@ -2003,1 +1069,5 @@\n-    xmlOpenCharEncodingHandler(name, 0, &ret);\n+    flags = XML_ENC_INPUT;\n+#ifdef LIBXML_OUTPUT_ENABLED\n+    flags |= XML_ENC_OUTPUT;\n+#endif\n+    xmlCreateCharEncodingHandler(name, flags, NULL, NULL, &ret);\n@@ -2008,3 +1078,3 @@\n- *                                    *\n- *        ICONV based generic conversion functions        *\n- *                                    *\n+ *                                                                      *\n+ *              ICONV based generic conversion functions                *\n+ *                                                                      *\n@@ -2014,0 +1084,4 @@\n+typedef struct {\n+    iconv_t cd;\n+} xmlIconvCtxt;\n+\n@@ -2015,2 +1089,2 @@\n- * xmlIconvWrapper:\n- * @cd:        iconv converter data structure\n+ * xmlIconvConvert:\n+ * @vctxt:  conversion context\n@@ -2021,2 +1095,1 @@\n- *\n- * Returns an XML_ENC_ERR code.\n+ * @flush:  end of input\n@@ -2027,0 +1100,2 @@\n+ *\n+ * Returns an XML_ENC_ERR code.\n@@ -2028,3 +1103,5 @@\n-static int\n-xmlIconvWrapper(iconv_t cd, unsigned char *out, int *outlen,\n-                const unsigned char *in, int *inlen) {\n+static xmlCharEncError\n+xmlIconvConvert(void *vctxt, unsigned char *out, int *outlen,\n+                const unsigned char *in, int *inlen,\n+                int flush ATTRIBUTE_UNUSED) {\n+    xmlIconvCtxt *ctxt = vctxt;\n@@ -2045,1 +1122,1 @@\n-    ret = iconv(cd, (void *) &icv_in, &icv_inlen, &icv_out, &icv_outlen);\n+    ret = iconv(ctxt->cd, (void *) &icv_in, &icv_inlen, &icv_out, &icv_outlen);\n@@ -2053,0 +1130,4 @@\n+        \/*\n+         * EINVAL means a truncated multi-byte sequence at the end\n+         * of the input buffer. We treat this as success.\n+         *\/\n@@ -2054,1 +1135,9 @@\n-            return(XML_ENC_ERR_PARTIAL);\n+            return(XML_ENC_ERR_SUCCESS);\n+#ifdef __APPLE__\n+        \/*\n+         * Apple's new libiconv can return EOPNOTSUPP under\n+         * unknown circumstances (detected when fuzzing).\n+         *\/\n+        if (errno == EOPNOTSUPP)\n+            return(XML_ENC_ERR_INPUT);\n+#endif\n@@ -2059,0 +1148,152 @@\n+\n+static void\n+xmlIconvFree(void *vctxt) {\n+    xmlIconvCtxt *ctxt = vctxt;\n+\n+    if (ctxt == NULL)\n+        return;\n+\n+    if (ctxt->cd != (iconv_t) -1)\n+        iconv_close(ctxt->cd);\n+\n+    xmlFree(ctxt);\n+}\n+\n+#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && \\\n+    defined(__GLIBC__)\n+#include <libxml\/parserInternals.h>\n+\n+static int\n+xmlEncodingMatch(const char *name1, const char *name2) {\n+    \/*\n+     * Fuzzy match for encoding names\n+     *\/\n+    while (1) {\n+        while ((*name1 != 0) && (!IS_ASCII_LETTER(*name1)))\n+            name1 += 1;\n+        while ((*name2 != 0) && (!IS_ASCII_LETTER(*name2)))\n+            name2 += 1;\n+        if ((*name1 == 0) || (*name2 == 0))\n+            break;\n+        if ((*name1 | 0x20) != (*name2 | 0x20))\n+            return(0);\n+        name1 += 1;\n+        name2 += 1;\n+    }\n+\n+    return((*name1 == 0) && (*name2 == 0));\n+}\n+#endif \/* FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION *\/\n+\n+static xmlParserErrors\n+xmlCharEncIconv(const char *name, xmlCharEncFlags flags,\n+                xmlCharEncodingHandler **out) {\n+    xmlCharEncConvFunc inFunc = NULL, outFunc = NULL;\n+    xmlIconvCtxt *inputCtxt = NULL, *outputCtxt = NULL;\n+    iconv_t icv_in;\n+    iconv_t icv_out;\n+    xmlParserErrors ret;\n+\n+    \/*\n+     * POSIX allows \"indicator suffixes\" like \"\/\/IGNORE\" to be\n+     * passed to iconv_open. This can change the behavior in\n+     * unexpected ways.\n+     *\n+     * Many iconv implementations also support non-standard\n+     * codesets like \"wchar_t\", \"char\" or the empty string \"\".\n+     * It would make sense to disallow them, but codeset names\n+     * are matched fuzzily, so a string like \"w-C.hA_rt\" could\n+     * be interpreted as \"wchar_t\".\n+     *\n+     * When escaping characters that aren't supported in the\n+     * target encoding, we also rely on GNU libiconv behavior to\n+     * stop conversion without trying any kind of fallback.\n+     * This violates the POSIX spec which says:\n+     *\n+     * > If iconv() encounters a character in the input buffer\n+     * > that is valid, but for which an identical character does\n+     * > not exist in the output codeset [...] iconv() shall\n+     * > perform an implementation-defined conversion on the\n+     * > character.\n+     *\n+     * See: https:\/\/sourceware.org\/bugzilla\/show_bug.cgi?id=29913\n+     *\n+     * Unfortunately, strict POSIX compliance makes it impossible\n+     * to detect untranslatable characters.\n+     *\/\n+    if (strstr(name, \"\/\/\") != NULL) {\n+        ret = XML_ERR_UNSUPPORTED_ENCODING;\n+        goto error;\n+    }\n+\n+#if defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION) && \\\n+    defined(__GLIBC__)\n+    \/*\n+     * This glibc bug can lead to unpredictable results with the\n+     * push parser.\n+     *\n+     * https:\/\/sourceware.org\/bugzilla\/show_bug.cgi?id=32633\n+     *\/\n+    if ((xmlEncodingMatch(name, \"TSCII\")) ||\n+        (xmlEncodingMatch(name, \"BIG5-HKSCS\"))) {\n+        ret = XML_ERR_UNSUPPORTED_ENCODING;\n+        goto error;\n+    }\n+#endif\n+\n+    if (flags & XML_ENC_INPUT) {\n+        inputCtxt = xmlMalloc(sizeof(xmlIconvCtxt));\n+        if (inputCtxt == NULL) {\n+            ret = XML_ERR_NO_MEMORY;\n+            goto error;\n+        }\n+        inputCtxt->cd = (iconv_t) -1;\n+\n+        icv_in = iconv_open(\"UTF-8\", name);\n+        if (icv_in == (iconv_t) -1) {\n+            if (errno == EINVAL)\n+                ret = XML_ERR_UNSUPPORTED_ENCODING;\n+            else if (errno == ENOMEM)\n+                ret = XML_ERR_NO_MEMORY;\n+            else\n+                ret = XML_ERR_SYSTEM;\n+            goto error;\n+        }\n+        inputCtxt->cd = icv_in;\n+\n+        inFunc = xmlIconvConvert;\n+    }\n+\n+    if (flags & XML_ENC_OUTPUT) {\n+        outputCtxt = xmlMalloc(sizeof(xmlIconvCtxt));\n+        if (outputCtxt == NULL) {\n+            ret = XML_ERR_NO_MEMORY;\n+            goto error;\n+        }\n+        outputCtxt->cd = (iconv_t) -1;\n+\n+        icv_out = iconv_open(name, \"UTF-8\");\n+        if (icv_out == (iconv_t) -1) {\n+            if (errno == EINVAL)\n+                ret = XML_ERR_UNSUPPORTED_ENCODING;\n+            else if (errno == ENOMEM)\n+                ret = XML_ERR_NO_MEMORY;\n+            else\n+                ret = XML_ERR_SYSTEM;\n+            goto error;\n+        }\n+        outputCtxt->cd = icv_out;\n+\n+        outFunc = xmlIconvConvert;\n+    }\n+\n+    return(xmlCharEncNewCustomHandler(name, inFunc, outFunc, xmlIconvFree,\n+                                      inputCtxt, outputCtxt, out));\n+\n+error:\n+    if (inputCtxt != NULL)\n+        xmlIconvFree(inputCtxt);\n+    if (outputCtxt != NULL)\n+        xmlIconvFree(outputCtxt);\n+    return(ret);\n+}\n@@ -2062,3 +1303,3 @@\n- *                                    *\n- *        ICU based generic conversion functions        *\n- *                                    *\n+ *                                                                      *\n+ *              ICU based generic conversion functions          *\n+ *                                                                      *\n@@ -2068,0 +1309,13 @@\n+\/* Size of pivot buffer, same as icu\/source\/common\/ucnv.cpp CHUNK_SIZE *\/\n+#define ICU_PIVOT_BUF_SIZE 1024\n+\n+typedef struct _uconv_t xmlUconvCtxt;\n+struct _uconv_t {\n+  UConverter *uconv; \/* for conversion between an encoding and UTF-16 *\/\n+  UConverter *utf8; \/* for conversion between UTF-8 and UTF-16 *\/\n+  UChar      *pivot_source;\n+  UChar      *pivot_target;\n+  int        isInput;\n+  UChar      pivot_buf[ICU_PIVOT_BUF_SIZE];\n+};\n+\n@@ -2069,3 +1323,2 @@\n- * xmlUconvWrapper:\n- * @cd: ICU uconverter data structure\n- * @toUnicode : non-zero if toUnicode. 0 otherwise.\n+ * xmlUconvConvert:\n+ * @vctxt:  conversion context\n@@ -2076,0 +1329,1 @@\n+ * @flush:  end of input\n@@ -2083,3 +1337,4 @@\n-static int\n-xmlUconvWrapper(uconv_t *cd, int toUnicode, unsigned char *out, int *outlen,\n-                const unsigned char *in, int *inlen) {\n+static xmlCharEncError\n+xmlUconvConvert(void *vctxt, unsigned char *out, int *outlen,\n+                const unsigned char *in, int *inlen, int flush) {\n+    xmlUconvCtxt *cd = vctxt;\n@@ -2088,0 +1343,1 @@\n+    UConverter *target, *source;\n@@ -2089,0 +1345,1 @@\n+    int ret;\n@@ -2091,1 +1348,2 @@\n-        if (outlen != NULL) *outlen = 0;\n+        if (outlen != NULL)\n+            *outlen = 0;\n@@ -2096,12 +1354,4 @@\n-     * Note that the ICU API is stateful. It can always consume a certain\n-     * amount of input even if the output buffer would overflow. The\n-     * remaining input must be processed by calling ucnv_convertEx with a\n-     * possibly empty input buffer.\n-     *\n-     * ucnv_convertEx is always called with reset and flush set to 0,\n-     * so we don't mess up the state. This should never generate\n-     * U_TRUNCATED_CHAR_FOUND errors.\n-     *\n-     * This also means that ICU xmlCharEncodingHandlers should never be\n-     * reused. It would be a lot nicer if there was a way to emulate the\n-     * stateless iconv API.\n+     * The ICU API can consume input, including partial sequences,\n+     * even if the output buffer would overflow. The remaining input\n+     * must be processed by calling ucnv_convertEx with a possibly\n+     * empty input buffer.\n@@ -2109,6 +1359,3 @@\n-    if (toUnicode) {\n-        \/* encoding => UTF-16 => UTF-8 *\/\n-        ucnv_convertEx(cd->utf8, cd->uconv, &ucv_out, ucv_out + *outlen,\n-                       &ucv_in, ucv_in + *inlen, cd->pivot_buf,\n-                       &cd->pivot_source, &cd->pivot_target,\n-                       cd->pivot_buf + ICU_PIVOT_BUF_SIZE, 0, 0, &err);\n+    if (cd->isInput) {\n+        source = cd->uconv;\n+        target = cd->utf8;\n@@ -2116,5 +1363,2 @@\n-        \/* UTF-8 => UTF-16 => encoding *\/\n-        ucnv_convertEx(cd->uconv, cd->utf8, &ucv_out, ucv_out + *outlen,\n-                       &ucv_in, ucv_in + *inlen, cd->pivot_buf,\n-                       &cd->pivot_source, &cd->pivot_target,\n-                       cd->pivot_buf + ICU_PIVOT_BUF_SIZE, 0, 0, &err);\n+        source = cd->utf8;\n+        target = cd->uconv;\n@@ -2122,0 +1366,7 @@\n+\n+    ucnv_convertEx(target, source, &ucv_out, ucv_out + *outlen,\n+                   &ucv_in, ucv_in + *inlen, cd->pivot_buf,\n+                   &cd->pivot_source, &cd->pivot_target,\n+                   cd->pivot_buf + ICU_PIVOT_BUF_SIZE,\n+                   \/* reset *\/ 0, flush, &err);\n+\n@@ -2124,0 +1375,1 @@\n+\n@@ -2125,1 +1377,120 @@\n-        return(XML_ENC_ERR_SUCCESS);\n+        ret = XML_ENC_ERR_SUCCESS;\n+    } else {\n+        switch (err) {\n+            case U_TRUNCATED_CHAR_FOUND:\n+                \/* Should only happen with flush *\/\n+                ret = XML_ENC_ERR_INPUT;\n+                break;\n+\n+            case U_BUFFER_OVERFLOW_ERROR:\n+                ret = XML_ENC_ERR_SPACE;\n+                break;\n+\n+            case U_INVALID_CHAR_FOUND:\n+            case U_ILLEGAL_CHAR_FOUND:\n+            case U_ILLEGAL_ESCAPE_SEQUENCE:\n+            case U_UNSUPPORTED_ESCAPE_SEQUENCE:\n+                ret = XML_ENC_ERR_INPUT;\n+                break;\n+\n+            case U_MEMORY_ALLOCATION_ERROR:\n+                ret = XML_ENC_ERR_MEMORY;\n+                break;\n+\n+            default:\n+                ret = XML_ENC_ERR_INTERNAL;\n+                break;\n+        }\n+    }\n+\n+    return(ret);\n+}\n+\n+static xmlParserErrors\n+openIcuConverter(const char* name, int isInput, xmlUconvCtxt **out)\n+{\n+    UErrorCode status;\n+    xmlUconvCtxt *conv;\n+\n+    *out = NULL;\n+\n+    conv = (xmlUconvCtxt *) xmlMalloc(sizeof(xmlUconvCtxt));\n+    if (conv == NULL)\n+        return(XML_ERR_NO_MEMORY);\n+\n+    conv->isInput = isInput;\n+    conv->pivot_source = conv->pivot_buf;\n+    conv->pivot_target = conv->pivot_buf;\n+\n+    status = U_ZERO_ERROR;\n+    conv->uconv = ucnv_open(name, &status);\n+    if (U_FAILURE(status))\n+        goto error;\n+\n+    status = U_ZERO_ERROR;\n+    if (isInput) {\n+        ucnv_setToUCallBack(conv->uconv, UCNV_TO_U_CALLBACK_STOP,\n+                                                NULL, NULL, NULL, &status);\n+    }\n+    else {\n+        ucnv_setFromUCallBack(conv->uconv, UCNV_FROM_U_CALLBACK_STOP,\n+                                                NULL, NULL, NULL, &status);\n+    }\n+    if (U_FAILURE(status))\n+        goto error;\n+\n+    status = U_ZERO_ERROR;\n+    conv->utf8 = ucnv_open(\"UTF-8\", &status);\n+    if (U_FAILURE(status))\n+        goto error;\n+\n+    *out = conv;\n+    return(XML_ERR_OK);\n+\n+error:\n+    if (conv->uconv)\n+        ucnv_close(conv->uconv);\n+    xmlFree(conv);\n+\n+    if (status == U_FILE_ACCESS_ERROR)\n+        return(XML_ERR_UNSUPPORTED_ENCODING);\n+    if (status == U_MEMORY_ALLOCATION_ERROR)\n+        return(XML_ERR_NO_MEMORY);\n+    return(XML_ERR_SYSTEM);\n+}\n+\n+static void\n+closeIcuConverter(xmlUconvCtxt *conv)\n+{\n+    if (conv == NULL)\n+        return;\n+    ucnv_close(conv->uconv);\n+    ucnv_close(conv->utf8);\n+    xmlFree(conv);\n+}\n+\n+static void\n+xmlUconvFree(void *vctxt) {\n+    closeIcuConverter(vctxt);\n+}\n+\n+static xmlParserErrors\n+xmlCharEncUconv(const char *name, xmlCharEncFlags flags,\n+                xmlCharEncodingHandler **out) {\n+    xmlCharEncConvFunc inFunc = NULL, outFunc = NULL;\n+    xmlUconvCtxt *ucv_in = NULL;\n+    xmlUconvCtxt *ucv_out = NULL;\n+    int ret;\n+\n+    if (flags & XML_ENC_INPUT) {\n+        ret = openIcuConverter(name, 1, &ucv_in);\n+        if (ret != 0)\n+            goto error;\n+        inFunc = xmlUconvConvert;\n+    }\n+\n+    if (flags & XML_ENC_OUTPUT) {\n+        ret = openIcuConverter(name, 0, &ucv_out);\n+        if (ret != 0)\n+            goto error;\n+        outFunc = xmlUconvConvert;\n@@ -2127,5 +1498,10 @@\n-    if (err == U_BUFFER_OVERFLOW_ERROR)\n-        return(XML_ENC_ERR_SPACE);\n-    if (err == U_INVALID_CHAR_FOUND || err == U_ILLEGAL_CHAR_FOUND)\n-        return(XML_ENC_ERR_INPUT);\n-    return(XML_ENC_ERR_PARTIAL);\n+\n+    return(xmlCharEncNewCustomHandler(name, inFunc, outFunc, xmlUconvFree,\n+                                      ucv_in, ucv_out, out));\n+\n+error:\n+    if (ucv_in != NULL)\n+        closeIcuConverter(ucv_in);\n+    if (ucv_out != NULL)\n+        closeIcuConverter(ucv_out);\n+    return(ret);\n@@ -2136,3 +1512,3 @@\n- *                                    *\n- *        The real API used by libxml for on-the-fly conversion    *\n- *                                    *\n+ *                                                                      *\n+ *              The real API used by libxml for on-the-fly conversion   *\n+ *                                                                      *\n@@ -2147,3 +1523,3 @@\n-static int\n-xmlEncConvertError(int code) {\n-    int ret;\n+static xmlParserErrors\n+xmlEncConvertError(xmlCharEncError code) {\n+    xmlParserErrors ret;\n@@ -2176,0 +1552,1 @@\n+ * @flush:  end of input\n@@ -2183,1 +1560,1 @@\n-int\n+xmlCharEncError\n@@ -2185,2 +1562,3 @@\n-                 int *outlen, const unsigned char *in, int *inlen) {\n-    int ret;\n+                 int *outlen, const unsigned char *in, int *inlen,\n+                 int flush) {\n+    xmlCharEncError ret;\n@@ -2188,2 +1566,2 @@\n-    if (handler->input != NULL) {\n-        int oldinlen = *inlen;\n+    if (handler->flags & XML_HANDLER_LEGACY) {\n+        xmlCharEncodingInputFunc func = handler->input.legacyFunc;\n@@ -2191,13 +1569,4 @@\n-        ret = handler->input(out, outlen, in, inlen);\n-        if (ret >= 0) {\n-            \/*\n-             * The built-in converters don't signal XML_ENC_ERR_SPACE.\n-             *\/\n-            if (*inlen < oldinlen) {\n-                if (*outlen > 0)\n-                    ret = XML_ENC_ERR_SPACE;\n-                else\n-                    ret = XML_ENC_ERR_PARTIAL;\n-            } else {\n-                ret = XML_ENC_ERR_SUCCESS;\n-            }\n+        if (func == NULL) {\n+            *outlen = 0;\n+            *inlen = 0;\n+            return(XML_ENC_ERR_INTERNAL);\n@@ -2205,15 +1574,20 @@\n-    }\n-#ifdef LIBXML_ICONV_ENABLED\n-    else if (handler->iconv_in != (iconv_t) -1) {\n-        ret = xmlIconvWrapper(handler->iconv_in, out, outlen, in, inlen);\n-    }\n-#endif \/* LIBXML_ICONV_ENABLED *\/\n-#ifdef LIBXML_ICU_ENABLED\n-    else if (handler->uconv_in != NULL) {\n-        ret = xmlUconvWrapper(handler->uconv_in, 1, out, outlen, in, inlen);\n-    }\n-#endif \/* LIBXML_ICU_ENABLED *\/\n-    else {\n-        *outlen = 0;\n-        *inlen = 0;\n-        ret = XML_ENC_ERR_INTERNAL;\n+\n+        ret = func(out, outlen, in, inlen);\n+    } else {\n+        xmlCharEncConvFunc func = handler->input.func;\n+        int oldInlen;\n+\n+        if (func == NULL) {\n+            *outlen = 0;\n+            *inlen = 0;\n+            return(XML_ENC_ERR_INTERNAL);\n+        }\n+\n+        oldInlen = *inlen;\n+        ret = func(handler->inputCtxt, out, outlen, in, inlen, flush);\n+\n+        \/*\n+         * Check for truncated multi-byte sequence.\n+         *\/\n+        if ((flush) && (ret == XML_ENC_ERR_SUCCESS) && (*inlen != oldInlen))\n+            ret = XML_ENC_ERR_INPUT;\n@@ -2222,2 +1596,1 @@\n-    \/* Ignore partial errors when reading. *\/\n-    if (ret == XML_ENC_ERR_PARTIAL)\n+    if (ret > 0)\n@@ -2243,1 +1616,1 @@\n-static int\n+static xmlCharEncError\n@@ -2246,1 +1619,1 @@\n-    int ret;\n+    xmlCharEncError ret;\n@@ -2248,2 +1621,2 @@\n-    if (handler->output != NULL) {\n-        int oldinlen = *inlen;\n+    if (handler->flags & XML_HANDLER_LEGACY) {\n+        xmlCharEncodingOutputFunc func = handler->output.legacyFunc;\n@@ -2251,13 +1624,4 @@\n-        ret = handler->output(out, outlen, in, inlen);\n-        if (ret >= 0) {\n-            \/*\n-             * The built-in converters don't signal XML_ENC_ERR_SPACE.\n-             *\/\n-            if (*inlen < oldinlen) {\n-                if (*outlen > 0)\n-                    ret = XML_ENC_ERR_SPACE;\n-                else\n-                    ret = XML_ENC_ERR_PARTIAL;\n-            } else {\n-                ret = XML_ENC_ERR_SUCCESS;\n-            }\n+        if (func == NULL) {\n+            *outlen = 0;\n+            *inlen = 0;\n+            return(XML_ENC_ERR_INTERNAL);\n@@ -2265,15 +1629,12 @@\n-    }\n-#ifdef LIBXML_ICONV_ENABLED\n-    else if (handler->iconv_out != (iconv_t) -1) {\n-        ret = xmlIconvWrapper(handler->iconv_out, out, outlen, in, inlen);\n-    }\n-#endif \/* LIBXML_ICONV_ENABLED *\/\n-#ifdef LIBXML_ICU_ENABLED\n-    else if (handler->uconv_out != NULL) {\n-        ret = xmlUconvWrapper(handler->uconv_out, 0, out, outlen, in, inlen);\n-    }\n-#endif \/* LIBXML_ICU_ENABLED *\/\n-    else {\n-        *outlen = 0;\n-        *inlen = 0;\n-        ret = XML_ENC_ERR_INTERNAL;\n+\n+        ret = func(out, outlen, in, inlen);\n+    } else {\n+        xmlCharEncConvFunc func = handler->output.func;\n+\n+        if (func == NULL) {\n+            *outlen = 0;\n+            *inlen = 0;\n+            return(XML_ENC_ERR_INTERNAL);\n+        }\n+\n+        ret = func(handler->outputCtxt, out, outlen, in, inlen, \/* flush *\/ 0);\n@@ -2282,3 +1643,2 @@\n-    \/* We shouldn't generate partial sequences when writing. *\/\n-    if (ret == XML_ENC_ERR_PARTIAL)\n-        ret = XML_ENC_ERR_INTERNAL;\n+    if (ret > 0)\n+        ret = XML_ENC_ERR_SUCCESS;\n@@ -2308,0 +1668,5 @@\n+ * @sizeOut:  pointer to output size\n+ * @flush:  end of input\n+ *\n+ * @sizeOut should be set to the maximum output size (or SIZE_MAX).\n+ * After return, it is set to the number of bytes written.\n@@ -2311,1 +1676,1 @@\n- * Returns the number of bytes written or an XML_ENC_ERR code.\n+ * Returns an XML_ENC_ERR code.\n@@ -2313,2 +1678,2 @@\n-int\n-xmlCharEncInput(xmlParserInputBufferPtr input)\n+xmlCharEncError\n+xmlCharEncInput(xmlParserInputBufferPtr input, size_t *sizeOut, int flush)\n@@ -2316,9 +1681,6 @@\n-    int ret;\n-    size_t avail;\n-    size_t toconv;\n-    int c_in;\n-    int c_out;\n-    xmlBufPtr in;\n-    xmlBufPtr out;\n-    const xmlChar *inData;\n-    size_t inTotal = 0;\n+    xmlBufPtr out, in;\n+    const xmlChar *dataIn;\n+    size_t availIn;\n+    size_t maxOut;\n+    size_t totalIn, totalOut;\n+    xmlCharEncError ret;\n@@ -2326,3 +1688,0 @@\n-    if ((input == NULL) || (input->encoder == NULL) ||\n-        (input->buffer == NULL) || (input->raw == NULL))\n-        return(XML_ENC_ERR_INTERNAL);\n@@ -2332,5 +1691,2 @@\n-    toconv = xmlBufUse(in);\n-    if (toconv == 0)\n-        return (0);\n-    inData = xmlBufContent(in);\n-    inTotal = 0;\n+    maxOut = *sizeOut;\n+    totalOut = 0;\n@@ -2338,2 +1694,1 @@\n-    do {\n-        c_in = toconv > INT_MAX \/ 2 ? INT_MAX \/ 2 : toconv;\n+    *sizeOut = 0;\n@@ -2341,4 +1696,55 @@\n-        avail = xmlBufAvail(out);\n-        if (avail > INT_MAX)\n-            avail = INT_MAX;\n-        if (avail < 4096) {\n+    availIn = xmlBufUse(in);\n+    if ((availIn == 0) && (!flush))\n+        return(0);\n+    dataIn = xmlBufContent(in);\n+    totalIn = 0;\n+\n+    while (1) {\n+        size_t availOut;\n+        int completeOut, completeIn;\n+        int c_out, c_in;\n+\n+        availOut = xmlBufAvail(out);\n+        if (availOut > INT_MAX \/ 2)\n+            availOut = INT_MAX \/ 2;\n+\n+        if (availOut < maxOut) {\n+            c_out = availOut;\n+            completeOut = 0;\n+        } else {\n+            c_out = maxOut;\n+            completeOut = 1;\n+        }\n+\n+        if (availIn > INT_MAX \/ 2) {\n+            c_in = INT_MAX \/ 2;\n+            completeIn = 0;\n+        } else {\n+            c_in = availIn;\n+            completeIn = 1;\n+        }\n+\n+        ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,\n+                               dataIn, &c_in, flush && completeIn);\n+\n+        totalIn += c_in;\n+        dataIn += c_in;\n+        availIn -= c_in;\n+\n+        totalOut += c_out;\n+        maxOut -= c_out;\n+        xmlBufAddLen(out, c_out);\n+\n+        if ((ret != XML_ENC_ERR_SUCCESS) && (ret != XML_ENC_ERR_SPACE)) {\n+            input->error = xmlEncConvertError(ret);\n+            return(ret);\n+        }\n+\n+        if ((completeOut) && (completeIn))\n+            break;\n+        if ((completeOut) && (ret == XML_ENC_ERR_SPACE))\n+            break;\n+        if ((completeIn) && (ret == XML_ENC_ERR_SUCCESS))\n+            break;\n+\n+        if (ret == XML_ENC_ERR_SPACE) {\n@@ -2349,1 +1755,0 @@\n-            avail = xmlBufAvail(out);\n@@ -2351,0 +1756,1 @@\n+    }\n@@ -2352,11 +1758,1 @@\n-        c_in = toconv;\n-        c_out = avail;\n-        ret = xmlEncInputChunk(input->encoder, xmlBufEnd(out), &c_out,\n-                               inData, &c_in);\n-        inTotal += c_in;\n-        inData += c_in;\n-        toconv -= c_in;\n-        xmlBufAddLen(out, c_out);\n-    } while (ret == XML_ENC_ERR_SPACE);\n-\n-    xmlBufShrink(in, inTotal);\n+    xmlBufShrink(in, totalIn);\n@@ -2364,1 +1760,1 @@\n-    if (input->rawconsumed > ULONG_MAX - (unsigned long)c_in)\n+    if (input->rawconsumed > ULONG_MAX - (unsigned long) totalIn)\n@@ -2367,8 +1763,1 @@\n-        input->rawconsumed += c_in;\n-\n-    if (((ret != 0) && (c_out == 0)) ||\n-        (ret == XML_ENC_ERR_MEMORY)) {\n-        if (input->error == 0)\n-            input->error = xmlEncConvertError(ret);\n-        return(ret);\n-    }\n+        input->rawconsumed += totalIn;\n@@ -2376,1 +1765,2 @@\n-    return (c_out);\n+    *sizeOut = totalOut;\n+    return(XML_ENC_ERR_SUCCESS);\n@@ -2413,1 +1803,1 @@\n-                           in->content, &toconv);\n+                           in->content, &toconv, \/* flush *\/ 0);\n@@ -2516,2 +1906,1 @@\n-        charrefLen = snprintf((char *) &charref[0], sizeof(charref),\n-                         \"&#%d;\", cur);\n+        charrefLen = xmlSerializeDecCharRef((char *) charref, cur);\n@@ -2577,1 +1966,1 @@\n-    written--; \/* Gennady: count '\/0' *\/\n+        written--; \/* Gennady: count '\/0' *\/\n@@ -2598,1 +1987,1 @@\n-    written = out->size - out->use - 1;\n+        written = out->size - out->use - 1;\n@@ -2628,2 +2017,1 @@\n-        charrefLen = snprintf((char *) &charref[0], sizeof(charref),\n-                         \"&#%d;\", cur);\n+        charrefLen = xmlSerializeDecCharRef((char *) charref, cur);\n@@ -2651,1 +2039,2 @@\n- * Generic front-end for encoding handler close function\n+ * Releases an xmlCharEncodingHandler. Must be called after\n+ * a handler is no longer in use.\n@@ -2653,1 +2042,1 @@\n- * Returns 0 if success, or -1 in case of error\n+ * Returns 0.\n@@ -2657,5 +2046,2 @@\n-    int ret = 0;\n-    int tofree = 0;\n-    int i = 0;\n-\n-    if (handler == NULL) return(-1);\n+    if (handler == NULL)\n+        return(0);\n@@ -2663,4 +2049,2 @@\n-    for (i = 0; i < (int) NUM_DEFAULT_HANDLERS; i++) {\n-        if (handler == &defaultHandlers[i])\n-            return(0);\n-    }\n+    if (handler->flags & XML_HANDLER_STATIC)\n+        return(0);\n@@ -2668,44 +2052,4 @@\n-    if (handlers != NULL) {\n-        for (i = 0;i < nbCharEncodingHandler; i++) {\n-            if (handler == handlers[i])\n-                return(0);\n-    }\n-    }\n-#ifdef LIBXML_ICONV_ENABLED\n-    \/*\n-     * Iconv handlers can be used only once, free the whole block.\n-     * and the associated icon resources.\n-     *\/\n-    if ((handler->iconv_out != (iconv_t) -1) || (handler->iconv_in != (iconv_t) -1)) {\n-        tofree = 1;\n-    if (handler->iconv_out != (iconv_t) -1) {\n-        if (iconv_close(handler->iconv_out))\n-        ret = -1;\n-        handler->iconv_out = (iconv_t) -1;\n-    }\n-    if (handler->iconv_in != (iconv_t) -1) {\n-        if (iconv_close(handler->iconv_in))\n-        ret = -1;\n-        handler->iconv_in = (iconv_t) -1;\n-    }\n-    }\n-#endif \/* LIBXML_ICONV_ENABLED *\/\n-#ifdef LIBXML_ICU_ENABLED\n-    if ((handler->uconv_out != NULL) || (handler->uconv_in != NULL)) {\n-        tofree = 1;\n-    if (handler->uconv_out != NULL) {\n-        closeIcuConverter(handler->uconv_out);\n-        handler->uconv_out = NULL;\n-    }\n-    if (handler->uconv_in != NULL) {\n-        closeIcuConverter(handler->uconv_in);\n-        handler->uconv_in = NULL;\n-    }\n-    }\n-#endif\n-    if (tofree) {\n-        \/* free up only dynamic handlers iconv\/uconv *\/\n-        if (handler->name != NULL)\n-            xmlFree(handler->name);\n-        handler->name = NULL;\n-        xmlFree(handler);\n+    xmlFree(handler->name);\n+    if (handler->ctxtDtor != NULL) {\n+        handler->ctxtDtor(handler->inputCtxt);\n+        handler->ctxtDtor(handler->outputCtxt);\n@@ -2713,2 +2057,2 @@\n-\n-    return(ret);\n+    xmlFree(handler);\n+    return(0);\n@@ -2721,0 +2065,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -2735,1 +2081,2 @@\n-    if (ctxt == NULL) return(-1);\n+    if (ctxt == NULL)\n+        return(-1);\n@@ -2737,1 +2084,3 @@\n-    if (in == NULL)  return(-1);\n+    if (in == NULL)\n+        return(-1);\n+\n@@ -2739,2 +2088,3 @@\n-        unsigned int unused = 0;\n-    xmlCharEncodingHandler * handler = in->buf->encoder;\n+        int unused = 0;\n+        xmlCharEncodingHandler * handler = in->buf->encoder;\n+\n@@ -2742,4 +2092,4 @@\n-     * Encoding conversion, compute the number of unused original\n-     * bytes from the input not consumed and subtract that from\n-     * the raw consumed value, this is not a cheap operation\n-     *\/\n+         * Encoding conversion, compute the number of unused original\n+         * bytes from the input not consumed and subtract that from\n+         * the raw consumed value, this is not a cheap operation\n+         *\/\n@@ -2747,20 +2097,21 @@\n-        unsigned char convbuf[32000];\n-        const unsigned char *cur = (const unsigned char *)in->cur;\n-        int toconv = in->end - in->cur, written = 32000;\n-\n-        int ret;\n-\n-            do {\n-                toconv = in->end - cur;\n-                written = 32000;\n-                ret = xmlEncOutputChunk(handler, &convbuf[0], &written,\n-                                        cur, &toconv);\n-                if ((ret != XML_ENC_ERR_SUCCESS) && (ret != XML_ENC_ERR_SPACE))\n-                    return(-1);\n-                unused += written;\n-                cur += toconv;\n-            } while (ret == XML_ENC_ERR_SPACE);\n-    }\n-    if (in->buf->rawconsumed < unused)\n-        return(-1);\n-    return(in->buf->rawconsumed - unused);\n+            unsigned char *convbuf;\n+            const unsigned char *cur = (const unsigned char *)in->cur;\n+            int toconv, ret;\n+\n+            convbuf = xmlMalloc(32000);\n+            if (convbuf == NULL)\n+                return(-1);\n+\n+            toconv = in->end - cur;\n+            unused = 32000;\n+            ret = xmlEncOutputChunk(handler, convbuf, &unused, cur, &toconv);\n+\n+            xmlFree(convbuf);\n+\n+            if (ret != XML_ENC_ERR_SUCCESS)\n+                return(-1);\n+        }\n+\n+        if (in->buf->rawconsumed < (unsigned long) unused)\n+            return(-1);\n+        return(in->buf->rawconsumed - unused);\n@@ -2768,0 +2119,1 @@\n+\n@@ -2771,2 +2123,92 @@\n-#if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED)\n-#ifdef LIBXML_ISO8859X_ENABLED\n+\/************************************************************************\n+ *                                                                      *\n+ *              Conversions To\/From UTF8 encoding                       *\n+ *                                                                      *\n+ ************************************************************************\/\n+\n+static xmlCharEncError\n+asciiToAscii(void *vctxt ATTRIBUTE_UNUSED,\n+             unsigned char* out, int *poutlen,\n+             const unsigned char* in, int *pinlen,\n+             int flush ATTRIBUTE_UNUSED) {\n+    const unsigned char *inend;\n+    const unsigned char *instart = in;\n+    int inlen, outlen, ret;\n+\n+    if (in == NULL) {\n+        *pinlen = 0;\n+        *poutlen = 0;\n+        return(XML_ENC_ERR_SUCCESS);\n+    }\n+\n+    inlen = *pinlen;\n+    outlen = *poutlen;\n+\n+    if (outlen < inlen) {\n+        inlen = outlen;\n+        ret = XML_ENC_ERR_SPACE;\n+    } else {\n+        ret = inlen;\n+    }\n+\n+    inend = in + inlen;\n+    *poutlen = inlen;\n+    *pinlen = inlen;\n+\n+    while (in < inend) {\n+        unsigned c = *in;\n+\n+        if (c >= 0x80) {\n+            *poutlen = in - instart;\n+            *pinlen = in - instart;\n+            return(XML_ENC_ERR_INPUT);\n+        }\n+\n+        in++;\n+        *out++ = c;\n+    }\n+\n+    return(ret);\n+}\n+\n+static xmlCharEncError\n+latin1ToUTF8(void *vctxt ATTRIBUTE_UNUSED,\n+             unsigned char* out, int *outlen,\n+             const unsigned char* in, int *inlen,\n+             int flush ATTRIBUTE_UNUSED) {\n+    unsigned char* outstart = out;\n+    const unsigned char* instart = in;\n+    unsigned char* outend;\n+    const unsigned char* inend;\n+    int ret = XML_ENC_ERR_SPACE;\n+\n+    if ((out == NULL) || (in == NULL) || (outlen == NULL) || (inlen == NULL))\n+        return(XML_ENC_ERR_INTERNAL);\n+\n+    outend = out + *outlen;\n+    inend = in + *inlen;\n+\n+    while (in < inend) {\n+        unsigned c = *in;\n+\n+        if (c < 0x80) {\n+            if (out >= outend)\n+                goto done;\n+            *out++ = c;\n+        } else {\n+            if (outend - out < 2)\n+                goto done;\n+            *out++ = (c >> 6) | 0xC0;\n+            *out++ = (c & 0x3F) | 0x80;\n+        }\n+\n+        in++;\n+    }\n+\n+    ret = out - outstart;\n+\n+done:\n+    *outlen = out - outstart;\n+    *inlen = in - instart;\n+    return(ret);\n+}\n@@ -2775,1 +2217,1 @@\n- * UTF8ToISO8859x:\n+ * xmlIsolat1ToUTF8:\n@@ -2778,1 +2220,1 @@\n- * @in:  a pointer to an array of UTF-8 chars\n+ * @in:  a pointer to an array of ISO Latin 1 chars\n@@ -2780,1 +2222,0 @@\n- * @xlattable: the 2-level transcoding table\n@@ -2782,1 +2223,1 @@\n- * Take a block of UTF-8 chars in and try to convert it to an ISO 8859-*\n+ * Take a block of ISO Latin 1 chars in and try to convert it to an UTF-8\n@@ -2788,2 +2229,2 @@\n- * as the return value is positive, else unpredictable.\n- * The value of @outlen after return is the number of octets consumed.\n+ *     if the return value is positive, else unpredictable.\n+ * The value of @outlen after return is the number of octets produced.\n@@ -2791,4 +2232,44 @@\n-static int\n-UTF8ToISO8859x(unsigned char* out, int *outlen,\n-              const unsigned char* in, int *inlen,\n-              const unsigned char* const xlattable) {\n+int\n+xmlIsolat1ToUTF8(unsigned char* out, int *outlen,\n+                 const unsigned char* in, int *inlen) {\n+    return(latin1ToUTF8(\/* ctxt *\/ NULL, out, outlen, in, inlen,\n+                        \/* flush *\/ 0));\n+}\n+\n+static xmlCharEncError\n+UTF8ToUTF8(void *vctxt ATTRIBUTE_UNUSED,\n+           unsigned char* out, int *outlen,\n+           const unsigned char* in, int *inlen,\n+           int flush ATTRIBUTE_UNUSED) {\n+    int len;\n+    int ret;\n+\n+    if (in == NULL) {\n+        *inlen = 0;\n+        *outlen = 0;\n+        return(XML_ENC_ERR_SUCCESS);\n+    }\n+\n+    if (*outlen < *inlen) {\n+        len = *outlen;\n+        ret = XML_ENC_ERR_SPACE;\n+    } else {\n+        len = *inlen;\n+        ret = len;\n+    }\n+\n+    memcpy(out, in, len);\n+\n+    *outlen = len;\n+    *inlen = len;\n+    return(ret);\n+}\n+\n+\n+#ifdef LIBXML_OUTPUT_ENABLED\n+static xmlCharEncError\n+UTF8ToLatin1(void *vctxt ATTRIBUTE_UNUSED,\n+             unsigned char* out, int *outlen,\n+             const unsigned char* in, int *inlen,\n+             int flush ATTRIBUTE_UNUSED) {\n+    const unsigned char* outend;\n@@ -2796,1 +2277,0 @@\n-    const unsigned char* inend;\n@@ -2798,1 +2278,6 @@\n-    const unsigned char* processed = in;\n+    const unsigned char* inend;\n+    unsigned c;\n+    int ret = XML_ENC_ERR_SPACE;\n+\n+    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -2800,3 +2285,0 @@\n-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL) ||\n-        (xlattable == NULL))\n-    return(XML_ENC_ERR_INTERNAL);\n@@ -2804,4 +2286,0 @@\n-        \/*\n-        * initialization nothing to do\n-        *\/\n-        *outlen = 0;\n@@ -2809,1 +2287,2 @@\n-        return(0);\n+        *outlen = 0;\n+        return(XML_ENC_ERR_SUCCESS);\n@@ -2811,70 +2290,16 @@\n-    inend = in + (*inlen);\n-    while (in < inend) {\n-        unsigned char d = *in++;\n-        if  (d < 0x80)  {\n-            *out++ = d;\n-        } else if (d < 0xC0) {\n-            \/* trailing byte in leading position *\/\n-            *outlen = out - outstart;\n-            *inlen = processed - instart;\n-            return(XML_ENC_ERR_INPUT);\n-        } else if (d < 0xE0) {\n-            unsigned char c;\n-            if (!(in < inend)) {\n-                \/* trailing byte not in input buffer *\/\n-                *outlen = out - outstart;\n-                *inlen = processed - instart;\n-                return(XML_ENC_ERR_PARTIAL);\n-            }\n-            c = *in++;\n-            if ((c & 0xC0) != 0x80) {\n-                \/* not a trailing byte *\/\n-                *outlen = out - outstart;\n-                *inlen = processed - instart;\n-                return(XML_ENC_ERR_INPUT);\n-            }\n-            c = c & 0x3F;\n-            d = d & 0x1F;\n-            d = xlattable [48 + c + xlattable [d] * 64];\n-            if (d == 0) {\n-                \/* not in character set *\/\n-                *outlen = out - outstart;\n-                *inlen = processed - instart;\n-                return(XML_ENC_ERR_INPUT);\n-            }\n-            *out++ = d;\n-        } else if (d < 0xF0) {\n-            unsigned char c1;\n-            unsigned char c2;\n-            if (!(in < inend - 1)) {\n-                \/* trailing bytes not in input buffer *\/\n-                *outlen = out - outstart;\n-                *inlen = processed - instart;\n-                return(XML_ENC_ERR_PARTIAL);\n-            }\n-            c1 = *in++;\n-            if ((c1 & 0xC0) != 0x80) {\n-                \/* not a trailing byte (c1) *\/\n-                *outlen = out - outstart;\n-                *inlen = processed - instart;\n-                return(XML_ENC_ERR_INPUT);\n-            }\n-            c2 = *in++;\n-            if ((c2 & 0xC0) != 0x80) {\n-                \/* not a trailing byte (c2) *\/\n-                *outlen = out - outstart;\n-                *inlen = processed - instart;\n-                return(XML_ENC_ERR_INPUT);\n-            }\n-            c1 = c1 & 0x3F;\n-            c2 = c2 & 0x3F;\n-        d = d & 0x0F;\n-        d = xlattable [48 + c2 + xlattable [48 + c1 +\n-            xlattable [32 + d] * 64] * 64];\n-            if (d == 0) {\n-                \/* not in character set *\/\n-                *outlen = out - outstart;\n-                *inlen = processed - instart;\n-                return(XML_ENC_ERR_INPUT);\n-            }\n-            *out++ = d;\n+\n+    inend = in + *inlen;\n+    outend = out + *outlen;\n+    while (in < inend) {\n+        if (out >= outend)\n+            goto done;\n+\n+        c = *in;\n+\n+        if (c < 0x80) {\n+            *out++ = c;\n+        } else if ((c >= 0xC2) && (c <= 0xC3)) {\n+            if (inend - in < 2)\n+                break;\n+            in++;\n+            *out++ = (unsigned char) ((c << 6) | (*in & 0x3F));\n@@ -2882,4 +2307,2 @@\n-            \/* cannot transcode >= U+010000 *\/\n-            *outlen = out - outstart;\n-            *inlen = processed - instart;\n-            return(XML_ENC_ERR_INPUT);\n+            ret = XML_ENC_ERR_INPUT;\n+            goto done;\n@@ -2887,1 +2310,2 @@\n-        processed = in;\n+\n+        in++;\n@@ -2889,0 +2313,4 @@\n+\n+    ret = out - outstart;\n+\n+done:\n@@ -2890,2 +2318,2 @@\n-    *inlen = processed - instart;\n-    return(*outlen);\n+    *inlen = in - instart;\n+    return(ret);\n@@ -2895,1 +2323,1 @@\n- * ISO8859xToUTF8\n+ * xmlUTF8ToIsolat1:\n@@ -2898,1 +2326,1 @@\n- * @in:  a pointer to an array of ISO Latin 1 chars\n+ * @in:  a pointer to an array of UTF-8 chars\n@@ -2901,1 +2329,1 @@\n- * Take a block of ISO 8859-* chars in and try to convert it to an UTF-8\n+ * Take a block of UTF-8 chars in and try to convert it to an ISO Latin 1\n@@ -2907,0 +2335,1 @@\n+ *     if the return value is positive, else unpredictable.\n@@ -2909,10 +2338,5 @@\n-static int\n-ISO8859xToUTF8(unsigned char* out, int *outlen,\n-              const unsigned char* in, int *inlen,\n-              unsigned short const *unicodetable) {\n-    unsigned char* outstart = out;\n-    unsigned char* outend;\n-    const unsigned char* instart = in;\n-    const unsigned char* inend;\n-    const unsigned char* instop;\n-    unsigned int c;\n+int\n+xmlUTF8ToIsolat1(unsigned char* out, int *outlen,\n+              const unsigned char* in, int *inlen) {\n+    if ((out == NULL) || (outlen == NULL) || (in == NULL) || (inlen == NULL))\n+        return(XML_ENC_ERR_INTERNAL);\n@@ -2920,6 +2344,4 @@\n-    if ((out == NULL) || (outlen == NULL) || (inlen == NULL) ||\n-        (in == NULL) || (unicodetable == NULL))\n-    return(XML_ENC_ERR_INTERNAL);\n-    outend = out + *outlen;\n-    inend = in + *inlen;\n-    instop = inend;\n+    return(UTF8ToLatin1(\/* ctxt *\/ NULL, out, outlen, in, inlen,\n+                        \/* flush *\/ 0));\n+}\n+#endif \/* LIBXML_OUTPUT_ENABLED *\/\n@@ -2927,8 +2349,41 @@\n-    while ((in < inend) && (out < outend - 2)) {\n-        if (*in >= 0x80) {\n-            c = unicodetable [*in - 0x80];\n-            if (c == 0) {\n-                \/* undefined code point *\/\n-                *outlen = out - outstart;\n-                *inlen = in - instart;\n-                return(XML_ENC_ERR_INPUT);\n+static xmlCharEncError\n+UTF16LEToUTF8(void *vctxt ATTRIBUTE_UNUSED,\n+              unsigned char *out, int *outlen,\n+              const unsigned char *in, int *inlen,\n+              int flush ATTRIBUTE_UNUSED) {\n+    const unsigned char *instart = in;\n+    const unsigned char *inend = in + (*inlen & ~1);\n+    unsigned char *outstart = out;\n+    unsigned char *outend = out + *outlen;\n+    unsigned c, d;\n+    int ret = XML_ENC_ERR_SPACE;\n+\n+    while (in < inend) {\n+        c = in[0] | (in[1] << 8);\n+\n+        if (c < 0x80) {\n+            if (out >= outend)\n+                goto done;\n+            out[0] = c;\n+            in += 2;\n+            out += 1;\n+        } else if (c < 0x800) {\n+            if (outend - out < 2)\n+                goto done;\n+            out[0] = (c >> 6)   | 0xC0;\n+            out[1] = (c & 0x3F) | 0x80;\n+            in += 2;\n+            out += 2;\n+        } else if ((c & 0xF800) != 0xD800) {\n+            if (outend - out < 3)\n+                goto done;\n+            out[0] =  (c >> 12)         | 0xE0;\n+            out[1] = ((c >>  6) & 0x3F) | 0x80;\n+            out[2] =  (c        & 0x3F) | 0x80;\n+            in += 2;\n+            out += 3;\n+        } else {\n+            \/* Surrogate pair *\/\n+            if ((c & 0xFC00) != 0xD800) {\n+                ret = XML_ENC_ERR_INPUT;\n+                goto done;\n@@ -2936,7 +2391,6 @@\n-            if (c < 0x800) {\n-                *out++ = ((c >>  6) & 0x1F) | 0xC0;\n-                *out++ = (c & 0x3F) | 0x80;\n-            } else {\n-                *out++ = ((c >>  12) & 0x0F) | 0xE0;\n-                *out++ = ((c >>  6) & 0x3F) | 0x80;\n-                *out++ = (c & 0x3F) | 0x80;\n+            if (inend - in < 4)\n+                break;\n+            d = in[2] | (in[3] << 8);\n+            if ((d & 0xFC00) != 0xDC00) {\n+                ret = XML_ENC_ERR_INPUT;\n+                goto done;\n@@ -2944,1 +2398,9 @@\n-            ++in;\n+            if (outend - out < 4)\n+                goto done;\n+            c = (c << 10) + d - ((0xD800 << 10) + 0xDC00 - 0x10000);\n+            out[0] =  (c >> 18)         | 0xF0;\n+            out[1] = ((c >> 12) & 0x3F) | 0x80;\n+            out[2] = ((c >>  6) & 0x3F) | 0x80;\n+            out[3] =  (c        & 0x3F) | 0x80;\n+            in += 4;\n+            out += 4;\n@@ -2946,10 +2408,0 @@\n-        if (instop - in > outend - out) instop = in + (outend - out);\n-        while ((*in < 0x80) && (in < instop)) {\n-            *out++ = *in++;\n-        }\n-    }\n-    if ((in < inend) && (out < outend) && (*in < 0x80)) {\n-        *out++ =  *in++;\n-    }\n-    if ((in < inend) && (out < outend) && (*in < 0x80)) {\n-        *out++ =  *in++;\n@@ -2957,0 +2409,4 @@\n+\n+    ret = out - outstart;\n+\n+done:\n@@ -2959,1 +2415,1 @@\n-    return (*outlen);\n+    return(ret);\n@@ -2962,0 +2418,12 @@\n+#ifdef LIBXML_OUTPUT_ENABLED\n+static xmlCharEncError\n+UTF8ToUTF16LE(void *vctxt ATTRIBUTE_UNUSED,\n+              unsigned char *out, int *outlen,\n+              const unsigned char *in, int *inlen,\n+              int flush ATTRIBUTE_UNUSED) {\n+    const unsigned char *instart = in;\n+    const unsigned char *inend;\n+    unsigned char *outstart = out;\n+    unsigned char *outend;\n+    unsigned c, d;\n+    int ret = XML_ENC_ERR_SPACE;\n@@ -2963,3 +2431,12 @@\n-\/************************************************************************\n- * Lookup tables for ISO-8859-2..ISO-8859-16 transcoding                *\n- ************************************************************************\/\n+    \/* UTF16LE encoding has no BOM *\/\n+    if ((out == NULL) || (outlen == NULL) || (inlen == NULL))\n+        return(XML_ENC_ERR_INTERNAL);\n+    if (in == NULL) {\n+        *outlen = 0;\n+        *inlen = 0;\n+        return(0);\n+    }\n+    inend = in + *inlen;\n+    outend = out + (*outlen & ~1);\n+    while (in < inend) {\n+        c = in[0];\n@@ -2967,18 +2444,10 @@\n-static const unsigned short xmlunicodetable_ISO8859_2 [128] = {\n-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n-    0x00a0, 0x0104, 0x02d8, 0x0141, 0x00a4, 0x013d, 0x015a, 0x00a7,\n-    0x00a8, 0x0160, 0x015e, 0x0164, 0x0179, 0x00ad, 0x017d, 0x017b,\n-    0x00b0, 0x0105, 0x02db, 0x0142, 0x00b4, 0x013e, 0x015b, 0x02c7,\n-    0x00b8, 0x0161, 0x015f, 0x0165, 0x017a, 0x02dd, 0x017e, 0x017c,\n-    0x0154, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0139, 0x0106, 0x00c7,\n-    0x010c, 0x00c9, 0x0118, 0x00cb, 0x011a, 0x00cd, 0x00ce, 0x010e,\n-    0x0110, 0x0143, 0x0147, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x00d7,\n-    0x0158, 0x016e, 0x00da, 0x0170, 0x00dc, 0x00dd, 0x0162, 0x00df,\n-    0x0155, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x013a, 0x0107, 0x00e7,\n-    0x010d, 0x00e9, 0x0119, 0x00eb, 0x011b, 0x00ed, 0x00ee, 0x010f,\n-    0x0111, 0x0144, 0x0148, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x00f7,\n-    0x0159, 0x016f, 0x00fa, 0x0171, 0x00fc, 0x00fd, 0x0163, 0x02d9,\n-};\n+        if (c < 0x80) {\n+            if (out >= outend)\n+                goto done;\n+            out[0] = c;\n+            out[1] = 0;\n+            in += 1;\n+            out += 2;\n+        } else {\n+            int i, len;\n+            unsigned min;\n@@ -2986,29 +2455,17 @@\n-static const unsigned char xmltranscodetable_ISO8859_2 [48 + 6 * 64] = {\n-    \"\\x00\\x00\\x01\\x05\\x02\\x04\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n-    \"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n-    \"\\xa0\\x00\\x00\\x00\\xa4\\x00\\x00\\xa7\\xa8\\x00\\x00\\x00\\x00\\xad\\x00\\x00\"\n-    \"\\xb0\\x00\\x00\\x00\\xb4\\x00\\x00\\x00\\xb8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\xc3\\xe3\\xa1\\xb1\\xc6\\xe6\\x00\\x00\\x00\\x00\\xc8\\xe8\\xcf\\xef\"\n-    \"\\xd0\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\xca\\xea\\xcc\\xec\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc5\\xe5\\x00\\x00\\xa5\\xb5\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xb7\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa2\\xff\\x00\\xb2\\x00\\xbd\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\xa3\\xb3\\xd1\\xf1\\x00\\x00\\xd2\\xf2\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xd5\\xf5\\x00\\x00\\xc0\\xe0\\x00\\x00\\xd8\\xf8\\xa6\\xb6\\x00\\x00\\xaa\\xba\"\n-    \"\\xa9\\xb9\\xde\\xfe\\xab\\xbb\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd9\\xf9\"\n-    \"\\xdb\\xfb\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xac\\xbc\\xaf\\xbf\\xae\\xbe\\x00\"\n-    \"\\x00\\xc1\\xc2\\x00\\xc4\\x00\\x00\\xc7\\x00\\xc9\\x00\\xcb\\x00\\xcd\\xce\\x00\"\n-    \"\\x00\\x00\\x00\\xd3\\xd4\\x00\\xd6\\xd7\\x00\\x00\\xda\\x00\\xdc\\xdd\\x00\\xdf\"\n-    \"\\x00\\xe1\\xe2\\x00\\xe4\\x00\\x00\\xe7\\x00\\xe9\\x00\\xeb\\x00\\xed\\xee\\x00\"\n-    \"\\x00\\x00\\x00\\xf3\\xf4\\x00\\xf6\\xf7\\x00\\x00\\xfa\\x00\\xfc\\xfd\\x00\\x00\"\n-};\n+            if (c < 0xE0) {\n+                if (c < 0xC2) {\n+                    ret = XML_ENC_ERR_INPUT;\n+                    goto done;\n+                }\n+                c &= 0x1F;\n+                len = 2;\n+                min = 0x80;\n+            } else if (c < 0xF0) {\n+                c &= 0x0F;\n+                len = 3;\n+                min = 0x800;\n+            } else {\n+                c &= 0x0F;\n+                len = 4;\n+                min = 0x10000;\n+            }\n@@ -3016,18 +2473,2 @@\n-static const unsigned short xmlunicodetable_ISO8859_3 [128] = {\n-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n-    0x00a0, 0x0126, 0x02d8, 0x00a3, 0x00a4, 0x0000, 0x0124, 0x00a7,\n-    0x00a8, 0x0130, 0x015e, 0x011e, 0x0134, 0x00ad, 0x0000, 0x017b,\n-    0x00b0, 0x0127, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x0125, 0x00b7,\n-    0x00b8, 0x0131, 0x015f, 0x011f, 0x0135, 0x00bd, 0x0000, 0x017c,\n-    0x00c0, 0x00c1, 0x00c2, 0x0000, 0x00c4, 0x010a, 0x0108, 0x00c7,\n-    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,\n-    0x0000, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x0120, 0x00d6, 0x00d7,\n-    0x011c, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x016c, 0x015c, 0x00df,\n-    0x00e0, 0x00e1, 0x00e2, 0x0000, 0x00e4, 0x010b, 0x0109, 0x00e7,\n-    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,\n-    0x0000, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x0121, 0x00f6, 0x00f7,\n-    0x011d, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x016d, 0x015d, 0x02d9,\n-};\n+            if (inend - in < len)\n+                break;\n@@ -3035,33 +2476,7 @@\n-static const unsigned char xmltranscodetable_ISO8859_3 [48 + 7 * 64] = {\n-    \"\\x04\\x00\\x01\\x06\\x02\\x05\\x00\\x00\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n-    \"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n-    \"\\xa0\\x00\\x00\\xa3\\xa4\\x00\\x00\\xa7\\xa8\\x00\\x00\\x00\\x00\\xad\\x00\\x00\"\n-    \"\\xb0\\x00\\xb2\\xb3\\xb4\\xb5\\x00\\xb7\\xb8\\x00\\x00\\x00\\x00\\xbd\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc6\\xe6\\xc5\\xe5\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd8\\xf8\\xab\\xbb\"\n-    \"\\xd5\\xf5\\x00\\x00\\xa6\\xb6\\xa1\\xb1\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xa9\\xb9\\x00\\x00\\xac\\xbc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa2\\xff\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xde\\xfe\\xaa\\xba\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xdd\\xfd\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaf\\xbf\\x00\\x00\\x00\"\n-    \"\\xc0\\xc1\\xc2\\x00\\xc4\\x00\\x00\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"\n-    \"\\x00\\xd1\\xd2\\xd3\\xd4\\x00\\xd6\\xd7\\x00\\xd9\\xda\\xdb\\xdc\\x00\\x00\\xdf\"\n-    \"\\xe0\\xe1\\xe2\\x00\\xe4\\x00\\x00\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n-    \"\\x00\\xf1\\xf2\\xf3\\xf4\\x00\\xf6\\xf7\\x00\\xf9\\xfa\\xfb\\xfc\\x00\\x00\\x00\"\n-};\n+            for (i = 1; i < len; i++) {\n+                if ((in[i] & 0xC0) != 0x80) {\n+                    ret = XML_ENC_ERR_INPUT;\n+                    goto done;\n+                }\n+                c = (c << 6) | (in[i] & 0x3F);\n+            }\n@@ -3069,18 +2484,6 @@\n-static const unsigned short xmlunicodetable_ISO8859_4 [128] = {\n-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n-    0x00a0, 0x0104, 0x0138, 0x0156, 0x00a4, 0x0128, 0x013b, 0x00a7,\n-    0x00a8, 0x0160, 0x0112, 0x0122, 0x0166, 0x00ad, 0x017d, 0x00af,\n-    0x00b0, 0x0105, 0x02db, 0x0157, 0x00b4, 0x0129, 0x013c, 0x02c7,\n-    0x00b8, 0x0161, 0x0113, 0x0123, 0x0167, 0x014a, 0x017e, 0x014b,\n-    0x0100, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x012e,\n-    0x010c, 0x00c9, 0x0118, 0x00cb, 0x0116, 0x00cd, 0x00ce, 0x012a,\n-    0x0110, 0x0145, 0x014c, 0x0136, 0x00d4, 0x00d5, 0x00d6, 0x00d7,\n-    0x00d8, 0x0172, 0x00da, 0x00db, 0x00dc, 0x0168, 0x016a, 0x00df,\n-    0x0101, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x012f,\n-    0x010d, 0x00e9, 0x0119, 0x00eb, 0x0117, 0x00ed, 0x00ee, 0x012b,\n-    0x0111, 0x0146, 0x014d, 0x0137, 0x00f4, 0x00f5, 0x00f6, 0x00f7,\n-    0x00f8, 0x0173, 0x00fa, 0x00fb, 0x00fc, 0x0169, 0x016b, 0x02d9,\n-};\n+            if ((c < min) ||\n+                ((c >= 0xD800) && (c <= 0xDFFF)) ||\n+                (c > 0x10FFFF)) {\n+                ret = XML_ENC_ERR_INPUT;\n+                goto done;\n+            }\n@@ -3088,29 +2491,18 @@\n-static const unsigned char xmltranscodetable_ISO8859_4 [48 + 6 * 64] = {\n-    \"\\x00\\x00\\x01\\x05\\x02\\x03\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n-    \"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n-    \"\\xa0\\x00\\x00\\x00\\xa4\\x00\\x00\\xa7\\xa8\\x00\\x00\\x00\\x00\\xad\\x00\\xaf\"\n-    \"\\xb0\\x00\\x00\\x00\\xb4\\x00\\x00\\x00\\xb8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xc0\\xe0\\x00\\x00\\xa1\\xb1\\x00\\x00\\x00\\x00\\x00\\x00\\xc8\\xe8\\x00\\x00\"\n-    \"\\xd0\\xf0\\xaa\\xba\\x00\\x00\\xcc\\xec\\xca\\xea\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\xab\\xbb\\x00\\x00\\x00\\x00\\xa5\\xb5\\xcf\\xef\\x00\\x00\\xc7\\xe7\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\xd3\\xf3\\xa2\\x00\\x00\\xa6\\xb6\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\xd1\\xf1\\x00\\x00\\x00\\xbd\\xbf\\xd2\\xf2\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\xa3\\xb3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xa9\\xb9\\x00\\x00\\x00\\x00\\xac\\xbc\\xdd\\xfd\\xde\\xfe\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\xd9\\xf9\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xae\\xbe\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xb7\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\x00\\xb2\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\x00\\x00\\xc9\\x00\\xcb\\x00\\xcd\\xce\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\xd4\\xd5\\xd6\\xd7\\xd8\\x00\\xda\\xdb\\xdc\\x00\\x00\\xdf\"\n-    \"\\x00\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\x00\\x00\\xe9\\x00\\xeb\\x00\\xed\\xee\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\xf4\\xf5\\xf6\\xf7\\xf8\\x00\\xfa\\xfb\\xfc\\x00\\x00\\x00\"\n-};\n+            if (c < 0x10000) {\n+                if (out >= outend)\n+                    goto done;\n+                out[0] = c & 0xFF;\n+                out[1] = c >> 8;\n+                out += 2;\n+            } else {\n+                if (outend - out < 4)\n+                    goto done;\n+                c -= 0x10000;\n+                d = (c & 0x03FF) | 0xDC00;\n+                c = (c >> 10)    | 0xD800;\n+                out[0] = c & 0xFF;\n+                out[1] = c >> 8;\n+                out[2] = d & 0xFF;\n+                out[3] = d >> 8;\n+                out += 4;\n+            }\n@@ -3118,18 +2510,3 @@\n-static const unsigned short xmlunicodetable_ISO8859_5 [128] = {\n-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n-    0x00a0, 0x0401, 0x0402, 0x0403, 0x0404, 0x0405, 0x0406, 0x0407,\n-    0x0408, 0x0409, 0x040a, 0x040b, 0x040c, 0x00ad, 0x040e, 0x040f,\n-    0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417,\n-    0x0418, 0x0419, 0x041a, 0x041b, 0x041c, 0x041d, 0x041e, 0x041f,\n-    0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427,\n-    0x0428, 0x0429, 0x042a, 0x042b, 0x042c, 0x042d, 0x042e, 0x042f,\n-    0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,\n-    0x0438, 0x0439, 0x043a, 0x043b, 0x043c, 0x043d, 0x043e, 0x043f,\n-    0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447,\n-    0x0448, 0x0449, 0x044a, 0x044b, 0x044c, 0x044d, 0x044e, 0x044f,\n-    0x2116, 0x0451, 0x0452, 0x0453, 0x0454, 0x0455, 0x0456, 0x0457,\n-    0x0458, 0x0459, 0x045a, 0x045b, 0x045c, 0x00a7, 0x045e, 0x045f,\n-};\n+            in += len;\n+        }\n+    }\n@@ -3137,29 +2514,1 @@\n-static const unsigned char xmltranscodetable_ISO8859_5 [48 + 6 * 64] = {\n-    \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x02\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n-    \"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n-    \"\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\xfd\\x00\\x00\\x00\\x00\\x00\\xad\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\x00\\xae\\xaf\"\n-    \"\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\"\n-    \"\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"\n-    \"\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\"\n-    \"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n-    \"\\x00\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\x00\\xfe\\xff\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-};\n+    ret = out - outstart;\n@@ -3167,18 +2516,5 @@\n-static const unsigned short xmlunicodetable_ISO8859_6 [128] = {\n-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n-    0x00a0, 0x0000, 0x0000, 0x0000, 0x00a4, 0x0000, 0x0000, 0x0000,\n-    0x0000, 0x0000, 0x0000, 0x0000, 0x060c, 0x00ad, 0x0000, 0x0000,\n-    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n-    0x0000, 0x0000, 0x0000, 0x061b, 0x0000, 0x0000, 0x0000, 0x061f,\n-    0x0000, 0x0621, 0x0622, 0x0623, 0x0624, 0x0625, 0x0626, 0x0627,\n-    0x0628, 0x0629, 0x062a, 0x062b, 0x062c, 0x062d, 0x062e, 0x062f,\n-    0x0630, 0x0631, 0x0632, 0x0633, 0x0634, 0x0635, 0x0636, 0x0637,\n-    0x0638, 0x0639, 0x063a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n-    0x0640, 0x0641, 0x0642, 0x0643, 0x0644, 0x0645, 0x0646, 0x0647,\n-    0x0648, 0x0649, 0x064a, 0x064b, 0x064c, 0x064d, 0x064e, 0x064f,\n-    0x0650, 0x0651, 0x0652, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n-    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n-};\n+done:\n+    *outlen = out - outstart;\n+    *inlen = in - instart;\n+    return(ret);\n+}\n@@ -3186,25 +2522,23 @@\n-static const unsigned char xmltranscodetable_ISO8859_6 [48 + 5 * 64] = {\n-    \"\\x02\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x04\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n-    \"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n-    \"\\xa0\\x00\\x00\\x00\\xa4\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xad\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xac\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbb\\x00\\x00\\x00\\xbf\"\n-    \"\\x00\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"\n-    \"\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n-    \"\\xf0\\xf1\\xf2\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-};\n+static xmlCharEncError\n+UTF8ToUTF16(void *vctxt,\n+            unsigned char* outb, int *outlen,\n+            const unsigned char* in, int *inlen,\n+            int flush) {\n+    if (in == NULL) {\n+        \/*\n+         * initialization, add the Byte Order Mark for UTF-16LE\n+         *\/\n+        if (*outlen >= 2) {\n+            outb[0] = 0xFF;\n+            outb[1] = 0xFE;\n+            *outlen = 2;\n+            *inlen = 0;\n+            return(2);\n+        }\n+        *outlen = 0;\n+        *inlen = 0;\n+        return(0);\n+    }\n+    return (UTF8ToUTF16LE(vctxt, outb, outlen, in, inlen, flush));\n+}\n+#endif \/* LIBXML_OUTPUT_ENABLED *\/\n@@ -3212,18 +2546,11 @@\n-static const unsigned short xmlunicodetable_ISO8859_7 [128] = {\n-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n-    0x00a0, 0x2018, 0x2019, 0x00a3, 0x0000, 0x0000, 0x00a6, 0x00a7,\n-    0x00a8, 0x00a9, 0x0000, 0x00ab, 0x00ac, 0x00ad, 0x0000, 0x2015,\n-    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x0384, 0x0385, 0x0386, 0x00b7,\n-    0x0388, 0x0389, 0x038a, 0x00bb, 0x038c, 0x00bd, 0x038e, 0x038f,\n-    0x0390, 0x0391, 0x0392, 0x0393, 0x0394, 0x0395, 0x0396, 0x0397,\n-    0x0398, 0x0399, 0x039a, 0x039b, 0x039c, 0x039d, 0x039e, 0x039f,\n-    0x03a0, 0x03a1, 0x0000, 0x03a3, 0x03a4, 0x03a5, 0x03a6, 0x03a7,\n-    0x03a8, 0x03a9, 0x03aa, 0x03ab, 0x03ac, 0x03ad, 0x03ae, 0x03af,\n-    0x03b0, 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6, 0x03b7,\n-    0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03be, 0x03bf,\n-    0x03c0, 0x03c1, 0x03c2, 0x03c3, 0x03c4, 0x03c5, 0x03c6, 0x03c7,\n-    0x03c8, 0x03c9, 0x03ca, 0x03cb, 0x03cc, 0x03cd, 0x03ce, 0x0000,\n-};\n+static xmlCharEncError\n+UTF16BEToUTF8(void *vctxt ATTRIBUTE_UNUSED,\n+              unsigned char *out, int *outlen,\n+              const unsigned char *in, int *inlen,\n+              int flush ATTRIBUTE_UNUSED) {\n+    const unsigned char *instart = in;\n+    const unsigned char *inend = in + (*inlen & ~1);\n+    unsigned char *outstart = out;\n+    unsigned char *outend = out + *outlen;\n+    unsigned c, d;\n+    int ret = XML_ENC_ERR_SPACE;\n@@ -3231,33 +2558,2 @@\n-static const unsigned char xmltranscodetable_ISO8859_7 [48 + 7 * 64] = {\n-    \"\\x04\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x05\\x06\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n-    \"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n-    \"\\xa0\\x00\\x00\\xa3\\x00\\x00\\xa6\\xa7\\xa8\\xa9\\x00\\xab\\xac\\xad\\x00\\x00\"\n-    \"\\xb0\\xb1\\xb2\\xb3\\x00\\x00\\x00\\xb7\\x00\\x00\\x00\\xbb\\x00\\xbd\\x00\\x00\"\n-    \"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\xaf\\x00\\x00\\xa1\\xa2\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\xb4\\xb5\\xb6\\x00\\xb8\\xb9\\xba\\x00\\xbc\\x00\\xbe\\xbf\"\n-    \"\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"\n-    \"\\xd0\\xd1\\x00\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\"\n-    \"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n-    \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-};\n+    while (in < inend) {\n+        c = (in[0] << 8) | in[1];\n@@ -3265,18 +2561,45 @@\n-static const unsigned short xmlunicodetable_ISO8859_8 [128] = {\n-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n-    0x00a0, 0x0000, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,\n-    0x00a8, 0x00a9, 0x00d7, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,\n-    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,\n-    0x00b8, 0x00b9, 0x00f7, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x0000,\n-    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n-    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n-    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,\n-    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x2017,\n-    0x05d0, 0x05d1, 0x05d2, 0x05d3, 0x05d4, 0x05d5, 0x05d6, 0x05d7,\n-    0x05d8, 0x05d9, 0x05da, 0x05db, 0x05dc, 0x05dd, 0x05de, 0x05df,\n-    0x05e0, 0x05e1, 0x05e2, 0x05e3, 0x05e4, 0x05e5, 0x05e6, 0x05e7,\n-    0x05e8, 0x05e9, 0x05ea, 0x0000, 0x0000, 0x200e, 0x200f, 0x0000,\n-};\n+        if (c < 0x80) {\n+            if (out >= outend)\n+                goto done;\n+            out[0] = c;\n+            in += 2;\n+            out += 1;\n+        } else if (c < 0x800) {\n+            if (outend - out < 2)\n+                goto done;\n+            out[0] = (c >> 6)   | 0xC0;\n+            out[1] = (c & 0x3F) | 0x80;\n+            in += 2;\n+            out += 2;\n+        } else if ((c & 0xF800) != 0xD800) {\n+            if (outend - out < 3)\n+                goto done;\n+            out[0] =  (c >> 12)         | 0xE0;\n+            out[1] = ((c >>  6) & 0x3F) | 0x80;\n+            out[2] =  (c        & 0x3F) | 0x80;\n+            in += 2;\n+            out += 3;\n+        } else {\n+            \/* Surrogate pair *\/\n+            if ((c & 0xFC00) != 0xD800) {\n+                ret = XML_ENC_ERR_INPUT;\n+                goto done;\n+            }\n+            if (inend - in < 4)\n+                break;\n+            d = (in[2] << 8) | in[3];\n+            if ((d & 0xFC00) != 0xDC00) {\n+                ret = XML_ENC_ERR_INPUT;\n+                goto done;\n+            }\n+            if (outend - out < 4)\n+                goto done;\n+            c = (c << 10) + d - ((0xD800 << 10) + 0xDC00 - 0x10000);\n+            out[0] =  (c >> 18)         | 0xF0;\n+            out[1] = ((c >> 12) & 0x3F) | 0x80;\n+            out[2] = ((c >>  6) & 0x3F) | 0x80;\n+            out[3] =  (c        & 0x3F) | 0x80;\n+            in += 4;\n+            out += 4;\n+        }\n+    }\n@@ -3284,33 +2607,1 @@\n-static const unsigned char xmltranscodetable_ISO8859_8 [48 + 7 * 64] = {\n-    \"\\x02\\x00\\x01\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n-    \"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n-    \"\\xa0\\x00\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\x00\\xab\\xac\\xad\\xae\\xaf\"\n-    \"\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\x00\\xbb\\xbc\\xbd\\xbe\\x00\"\n-    \"\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xba\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xfd\\xfe\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xdf\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n-    \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-};\n+    ret = out - outstart;\n@@ -3318,18 +2609,5 @@\n-static const unsigned short xmlunicodetable_ISO8859_9 [128] = {\n-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n-    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x00a4, 0x00a5, 0x00a6, 0x00a7,\n-    0x00a8, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,\n-    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x00b4, 0x00b5, 0x00b6, 0x00b7,\n-    0x00b8, 0x00b9, 0x00ba, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00bf,\n-    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,\n-    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,\n-    0x011e, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,\n-    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x0130, 0x015e, 0x00df,\n-    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,\n-    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,\n-    0x011f, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,\n-    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x0131, 0x015f, 0x00ff,\n-};\n+done:\n+    *outlen = out - outstart;\n+    *inlen = in - instart;\n+    return(ret);\n+}\n@@ -3337,25 +2615,12 @@\n-static const unsigned char xmltranscodetable_ISO8859_9 [48 + 5 * 64] = {\n-    \"\\x00\\x00\\x01\\x02\\x03\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n-    \"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n-    \"\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\"\n-    \"\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\"\n-    \"\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"\n-    \"\\x00\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\x00\\x00\\xdf\"\n-    \"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n-    \"\\x00\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\x00\\x00\\xff\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd0\\xf0\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xdd\\xfd\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xde\\xfe\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-};\n+#ifdef LIBXML_OUTPUT_ENABLED\n+static xmlCharEncError\n+UTF8ToUTF16BE(void *vctxt ATTRIBUTE_UNUSED,\n+              unsigned char *out, int *outlen,\n+              const unsigned char *in, int *inlen,\n+              int flush ATTRIBUTE_UNUSED) {\n+    const unsigned char *instart = in;\n+    const unsigned char *inend;\n+    unsigned char *outstart = out;\n+    unsigned char *outend;\n+    unsigned c, d;\n+    int ret = XML_ENC_ERR_SPACE;\n@@ -3363,18 +2628,11 @@\n-static const unsigned short xmlunicodetable_ISO8859_10 [128] = {\n-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n-    0x00a0, 0x0104, 0x0112, 0x0122, 0x012a, 0x0128, 0x0136, 0x00a7,\n-    0x013b, 0x0110, 0x0160, 0x0166, 0x017d, 0x00ad, 0x016a, 0x014a,\n-    0x00b0, 0x0105, 0x0113, 0x0123, 0x012b, 0x0129, 0x0137, 0x00b7,\n-    0x013c, 0x0111, 0x0161, 0x0167, 0x017e, 0x2015, 0x016b, 0x014b,\n-    0x0100, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x012e,\n-    0x010c, 0x00c9, 0x0118, 0x00cb, 0x0116, 0x00cd, 0x00ce, 0x00cf,\n-    0x00d0, 0x0145, 0x014c, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x0168,\n-    0x00d8, 0x0172, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,\n-    0x0101, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x012f,\n-    0x010d, 0x00e9, 0x0119, 0x00eb, 0x0117, 0x00ed, 0x00ee, 0x00ef,\n-    0x00f0, 0x0146, 0x014d, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x0169,\n-    0x00f8, 0x0173, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x0138,\n-};\n+    \/* UTF-16BE has no BOM *\/\n+    if ((out == NULL) || (outlen == NULL) || (inlen == NULL)) return(-1);\n+    if (in == NULL) {\n+        *outlen = 0;\n+        *inlen = 0;\n+        return(0);\n+    }\n+    inend = in + *inlen;\n+    outend = out + (*outlen & ~1);\n+    while (in < inend) {\n+        c = in[0];\n@@ -3382,33 +2640,10 @@\n-static const unsigned char xmltranscodetable_ISO8859_10 [48 + 7 * 64] = {\n-    \"\\x00\\x00\\x01\\x06\\x02\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n-    \"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n-    \"\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\xa7\\x00\\x00\\x00\\x00\\x00\\xad\\x00\\x00\"\n-    \"\\xb0\\x00\\x00\\x00\\x00\\x00\\x00\\xb7\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xc0\\xe0\\x00\\x00\\xa1\\xb1\\x00\\x00\\x00\\x00\\x00\\x00\\xc8\\xe8\\x00\\x00\"\n-    \"\\xa9\\xb9\\xa2\\xb2\\x00\\x00\\xcc\\xec\\xca\\xea\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\xa3\\xb3\\x00\\x00\\x00\\x00\\xa5\\xb5\\xa4\\xb4\\x00\\x00\\xc7\\xe7\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\xa6\\xb6\\xff\\x00\\x00\\xa8\\xb8\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\xd1\\xf1\\x00\\x00\\x00\\xaf\\xbf\\xd2\\xf2\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xaa\\xba\\x00\\x00\\x00\\x00\\xab\\xbb\\xd7\\xf7\\xae\\xbe\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\xd9\\xf9\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xac\\xbc\\x00\"\n-    \"\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\xbd\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\x00\\x00\\xc9\\x00\\xcb\\x00\\xcd\\xce\\xcf\"\n-    \"\\xd0\\x00\\x00\\xd3\\xd4\\xd5\\xd6\\x00\\xd8\\x00\\xda\\xdb\\xdc\\xdd\\xde\\xdf\"\n-    \"\\x00\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\x00\\x00\\xe9\\x00\\xeb\\x00\\xed\\xee\\xef\"\n-    \"\\xf0\\x00\\x00\\xf3\\xf4\\xf5\\xf6\\x00\\xf8\\x00\\xfa\\xfb\\xfc\\xfd\\xfe\\x00\"\n-};\n+        if (c < 0x80) {\n+            if (out >= outend)\n+                goto done;\n+            out[0] = 0;\n+            out[1] = c;\n+            in += 1;\n+            out += 2;\n+        } else {\n+            int i, len;\n+            unsigned min;\n@@ -3416,18 +2651,17 @@\n-static const unsigned short xmlunicodetable_ISO8859_11 [128] = {\n-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n-    0x00a0, 0x0e01, 0x0e02, 0x0e03, 0x0e04, 0x0e05, 0x0e06, 0x0e07,\n-    0x0e08, 0x0e09, 0x0e0a, 0x0e0b, 0x0e0c, 0x0e0d, 0x0e0e, 0x0e0f,\n-    0x0e10, 0x0e11, 0x0e12, 0x0e13, 0x0e14, 0x0e15, 0x0e16, 0x0e17,\n-    0x0e18, 0x0e19, 0x0e1a, 0x0e1b, 0x0e1c, 0x0e1d, 0x0e1e, 0x0e1f,\n-    0x0e20, 0x0e21, 0x0e22, 0x0e23, 0x0e24, 0x0e25, 0x0e26, 0x0e27,\n-    0x0e28, 0x0e29, 0x0e2a, 0x0e2b, 0x0e2c, 0x0e2d, 0x0e2e, 0x0e2f,\n-    0x0e30, 0x0e31, 0x0e32, 0x0e33, 0x0e34, 0x0e35, 0x0e36, 0x0e37,\n-    0x0e38, 0x0e39, 0x0e3a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0e3f,\n-    0x0e40, 0x0e41, 0x0e42, 0x0e43, 0x0e44, 0x0e45, 0x0e46, 0x0e47,\n-    0x0e48, 0x0e49, 0x0e4a, 0x0e4b, 0x0e4c, 0x0e4d, 0x0e4e, 0x0e4f,\n-    0x0e50, 0x0e51, 0x0e52, 0x0e53, 0x0e54, 0x0e55, 0x0e56, 0x0e57,\n-    0x0e58, 0x0e59, 0x0e5a, 0x0e5b, 0x0000, 0x0000, 0x0000, 0x0000,\n-};\n+            if (c < 0xE0) {\n+                if (c < 0xC2) {\n+                    ret = XML_ENC_ERR_INPUT;\n+                    goto done;\n+                }\n+                c &= 0x1F;\n+                len = 2;\n+                min = 0x80;\n+            } else if (c < 0xF0) {\n+                c &= 0x0F;\n+                len = 3;\n+                min = 0x800;\n+            } else {\n+                c &= 0x0F;\n+                len = 4;\n+                min = 0x10000;\n+            }\n@@ -3435,29 +2669,2 @@\n-static const unsigned char xmltranscodetable_ISO8859_11 [48 + 6 * 64] = {\n-    \"\\x04\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n-    \"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n-    \"\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x05\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\"\n-    \"\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf\"\n-    \"\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"\n-    \"\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\x00\\x00\\x00\\x00\\xdf\"\n-    \"\\xff\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n-    \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-};\n+            if (inend - in < len)\n+                break;\n@@ -3465,18 +2672,7 @@\n-static const unsigned short xmlunicodetable_ISO8859_13 [128] = {\n-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n-    0x00a0, 0x201d, 0x00a2, 0x00a3, 0x00a4, 0x201e, 0x00a6, 0x00a7,\n-    0x00d8, 0x00a9, 0x0156, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00c6,\n-    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x201c, 0x00b5, 0x00b6, 0x00b7,\n-    0x00f8, 0x00b9, 0x0157, 0x00bb, 0x00bc, 0x00bd, 0x00be, 0x00e6,\n-    0x0104, 0x012e, 0x0100, 0x0106, 0x00c4, 0x00c5, 0x0118, 0x0112,\n-    0x010c, 0x00c9, 0x0179, 0x0116, 0x0122, 0x0136, 0x012a, 0x013b,\n-    0x0160, 0x0143, 0x0145, 0x00d3, 0x014c, 0x00d5, 0x00d6, 0x00d7,\n-    0x0172, 0x0141, 0x015a, 0x016a, 0x00dc, 0x017b, 0x017d, 0x00df,\n-    0x0105, 0x012f, 0x0101, 0x0107, 0x00e4, 0x00e5, 0x0119, 0x0113,\n-    0x010d, 0x00e9, 0x017a, 0x0117, 0x0123, 0x0137, 0x012b, 0x013c,\n-    0x0161, 0x0144, 0x0146, 0x00f3, 0x014d, 0x00f5, 0x00f6, 0x00f7,\n-    0x0173, 0x0142, 0x015b, 0x016b, 0x00fc, 0x017c, 0x017e, 0x2019,\n-};\n+            for (i = 1; i < len; i++) {\n+                if ((in[i] & 0xC0) != 0x80) {\n+                    ret = XML_ENC_ERR_INPUT;\n+                    goto done;\n+                }\n+                c = (c << 6) | (in[i] & 0x3F);\n+            }\n@@ -3484,33 +2680,6 @@\n-static const unsigned char xmltranscodetable_ISO8859_13 [48 + 7 * 64] = {\n-    \"\\x00\\x00\\x01\\x04\\x06\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n-    \"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n-    \"\\xa0\\x00\\xa2\\xa3\\xa4\\x00\\xa6\\xa7\\x00\\xa9\\x00\\xab\\xac\\xad\\xae\\x00\"\n-    \"\\xb0\\xb1\\xb2\\xb3\\x00\\xb5\\xb6\\xb7\\x00\\xb9\\x00\\xbb\\xbc\\xbd\\xbe\\x00\"\n-    \"\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\x00\\x00\\xb4\\xa1\\xa5\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\xc4\\xc5\\xaf\\x00\\x00\\xc9\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\xd3\\x00\\xd5\\xd6\\xd7\\xa8\\x00\\x00\\x00\\xdc\\x00\\x00\\xdf\"\n-    \"\\x00\\x00\\x00\\x00\\xe4\\xe5\\xbf\\x00\\x00\\xe9\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\xf3\\x00\\xf5\\xf6\\xf7\\xb8\\x00\\x00\\x00\\xfc\\x00\\x00\\x00\"\n-    \"\\x00\\xd9\\xf9\\xd1\\xf1\\xd2\\xf2\\x00\\x00\\x00\\x00\\x00\\xd4\\xf4\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xba\\x00\\x00\\xda\\xfa\\x00\\x00\\x00\\x00\"\n-    \"\\xd0\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xdb\\xfb\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\xd8\\xf8\\x00\\x00\\x00\\x00\\x00\\xca\\xea\\xdd\\xfd\\xde\\xfe\\x00\"\n-    \"\\xc2\\xe2\\x00\\x00\\xc0\\xe0\\xc3\\xe3\\x00\\x00\\x00\\x00\\xc8\\xe8\\x00\\x00\"\n-    \"\\x00\\x00\\xc7\\xe7\\x00\\x00\\xcb\\xeb\\xc6\\xe6\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\xcc\\xec\\x00\\x00\\x00\\x00\\x00\\x00\\xce\\xee\\x00\\x00\\xc1\\xe1\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\xcd\\xed\\x00\\x00\\x00\\xcf\\xef\\x00\\x00\\x00\"\n-};\n+            if ((c < min) ||\n+                ((c >= 0xD800) && (c <= 0xDFFF)) ||\n+                (c > 0x10FFFF)) {\n+                ret = XML_ENC_ERR_INPUT;\n+                goto done;\n+            }\n@@ -3518,18 +2687,18 @@\n-static const unsigned short xmlunicodetable_ISO8859_14 [128] = {\n-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n-    0x00a0, 0x1e02, 0x1e03, 0x00a3, 0x010a, 0x010b, 0x1e0a, 0x00a7,\n-    0x1e80, 0x00a9, 0x1e82, 0x1e0b, 0x1ef2, 0x00ad, 0x00ae, 0x0178,\n-    0x1e1e, 0x1e1f, 0x0120, 0x0121, 0x1e40, 0x1e41, 0x00b6, 0x1e56,\n-    0x1e81, 0x1e57, 0x1e83, 0x1e60, 0x1ef3, 0x1e84, 0x1e85, 0x1e61,\n-    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,\n-    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,\n-    0x0174, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x1e6a,\n-    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x0176, 0x00df,\n-    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,\n-    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,\n-    0x0175, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x1e6b,\n-    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x0177, 0x00ff,\n-};\n+            if (c < 0x10000) {\n+                if (out >= outend)\n+                    goto done;\n+                out[0] = c >> 8;\n+                out[1] = c & 0xFF;\n+                out += 2;\n+            } else {\n+                if (outend - out < 4)\n+                    goto done;\n+                c -= 0x10000;\n+                d = (c & 0x03FF) | 0xDC00;\n+                c = (c >> 10)    | 0xD800;\n+                out[0] = c >> 8;\n+                out[1] = c & 0xFF;\n+                out[2] = d >> 8;\n+                out[3] = d & 0xFF;\n+                out += 4;\n+            }\n@@ -3537,45 +2706,3 @@\n-static const unsigned char xmltranscodetable_ISO8859_14 [48 + 10 * 64] = {\n-    \"\\x00\\x00\\x01\\x09\\x04\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n-    \"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n-    \"\\xa0\\x00\\x00\\xa3\\x00\\x00\\x00\\xa7\\x00\\xa9\\x00\\x00\\x00\\xad\\xae\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\xb6\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x03\\x08\\x05\\x06\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\xa1\\xa2\\x00\\x00\\x00\\x00\\x00\\x00\\xa6\\xab\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xb0\\xb1\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa4\\xa5\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xb2\\xb3\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xa8\\xb8\\xaa\\xba\\xbd\\xbe\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\xac\\xbc\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\xd0\\xf0\\xde\\xfe\\xaf\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xb4\\xb5\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\xb7\\xb9\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xbb\\xbf\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xd7\\xf7\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"\n-    \"\\x00\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\x00\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\x00\\xdf\"\n-    \"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n-    \"\\x00\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\x00\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\x00\\xff\"\n-};\n+            in += len;\n+        }\n+    }\n@@ -3583,18 +2710,1 @@\n-static const unsigned short xmlunicodetable_ISO8859_15 [128] = {\n-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n-    0x00a0, 0x00a1, 0x00a2, 0x00a3, 0x20ac, 0x00a5, 0x0160, 0x00a7,\n-    0x0161, 0x00a9, 0x00aa, 0x00ab, 0x00ac, 0x00ad, 0x00ae, 0x00af,\n-    0x00b0, 0x00b1, 0x00b2, 0x00b3, 0x017d, 0x00b5, 0x00b6, 0x00b7,\n-    0x017e, 0x00b9, 0x00ba, 0x00bb, 0x0152, 0x0153, 0x0178, 0x00bf,\n-    0x00c0, 0x00c1, 0x00c2, 0x00c3, 0x00c4, 0x00c5, 0x00c6, 0x00c7,\n-    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,\n-    0x00d0, 0x00d1, 0x00d2, 0x00d3, 0x00d4, 0x00d5, 0x00d6, 0x00d7,\n-    0x00d8, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x00dd, 0x00de, 0x00df,\n-    0x00e0, 0x00e1, 0x00e2, 0x00e3, 0x00e4, 0x00e5, 0x00e6, 0x00e7,\n-    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,\n-    0x00f0, 0x00f1, 0x00f2, 0x00f3, 0x00f4, 0x00f5, 0x00f6, 0x00f7,\n-    0x00f8, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x00fd, 0x00fe, 0x00ff,\n-};\n+    ret = out - outstart;\n@@ -3602,29 +2712,6 @@\n-static const unsigned char xmltranscodetable_ISO8859_15 [48 + 6 * 64] = {\n-    \"\\x00\\x00\\x01\\x05\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n-    \"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n-    \"\\xa0\\xa1\\xa2\\xa3\\x00\\xa5\\x00\\xa7\\x00\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf\"\n-    \"\\xb0\\xb1\\xb2\\xb3\\x00\\xb5\\xb6\\xb7\\x00\\xb9\\xba\\xbb\\x00\\x00\\x00\\xbf\"\n-    \"\\x00\\x00\\x03\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa4\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\xbc\\xbd\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xa6\\xa8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xbe\\x00\\x00\\x00\\x00\\xb4\\xb8\\x00\"\n-    \"\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"\n-    \"\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf\"\n-    \"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n-    \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"\n-};\n+done:\n+    *outlen = out - outstart;\n+    *inlen = in - instart;\n+    return(ret);\n+}\n+#endif \/* LIBXML_OUTPUT_ENABLED *\/\n@@ -3632,18 +2719,9 @@\n-static const unsigned short xmlunicodetable_ISO8859_16 [128] = {\n-    0x0080, 0x0081, 0x0082, 0x0083, 0x0084, 0x0085, 0x0086, 0x0087,\n-    0x0088, 0x0089, 0x008a, 0x008b, 0x008c, 0x008d, 0x008e, 0x008f,\n-    0x0090, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,\n-    0x0098, 0x0099, 0x009a, 0x009b, 0x009c, 0x009d, 0x009e, 0x009f,\n-    0x00a0, 0x0104, 0x0105, 0x0141, 0x20ac, 0x201e, 0x0160, 0x00a7,\n-    0x0161, 0x00a9, 0x0218, 0x00ab, 0x0179, 0x00ad, 0x017a, 0x017b,\n-    0x00b0, 0x00b1, 0x010c, 0x0142, 0x017d, 0x201d, 0x00b6, 0x00b7,\n-    0x017e, 0x010d, 0x0219, 0x00bb, 0x0152, 0x0153, 0x0178, 0x017c,\n-    0x00c0, 0x00c1, 0x00c2, 0x0102, 0x00c4, 0x0106, 0x00c6, 0x00c7,\n-    0x00c8, 0x00c9, 0x00ca, 0x00cb, 0x00cc, 0x00cd, 0x00ce, 0x00cf,\n-    0x0110, 0x0143, 0x00d2, 0x00d3, 0x00d4, 0x0150, 0x00d6, 0x015a,\n-    0x0170, 0x00d9, 0x00da, 0x00db, 0x00dc, 0x0118, 0x021a, 0x00df,\n-    0x00e0, 0x00e1, 0x00e2, 0x0103, 0x00e4, 0x0107, 0x00e6, 0x00e7,\n-    0x00e8, 0x00e9, 0x00ea, 0x00eb, 0x00ec, 0x00ed, 0x00ee, 0x00ef,\n-    0x0111, 0x0144, 0x00f2, 0x00f3, 0x00f4, 0x0151, 0x00f6, 0x015b,\n-    0x0171, 0x00f9, 0x00fa, 0x00fb, 0x00fc, 0x0119, 0x021b, 0x00ff,\n-};\n+#if defined(LIBXML_OUTPUT_ENABLED) && defined(LIBXML_HTML_ENABLED)\n+static xmlCharEncError\n+UTF8ToHtmlWrapper(void *vctxt ATTRIBUTE_UNUSED,\n+                  unsigned char *out, int *outlen,\n+                  const unsigned char *in, int *inlen,\n+                  int flush ATTRIBUTE_UNUSED) {\n+    return(htmlUTF8ToHtml(out, outlen, in, inlen));\n+}\n+#endif\n@@ -3651,41 +2729,2 @@\n-static const unsigned char xmltranscodetable_ISO8859_16 [48 + 9 * 64] = {\n-    \"\\x00\\x00\\x01\\x08\\x02\\x03\\x00\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f\"\n-    \"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f\"\n-    \"\\xa0\\x00\\x00\\x00\\x00\\x00\\x00\\xa7\\x00\\xa9\\x00\\xab\\x00\\xad\\x00\\x00\"\n-    \"\\xb0\\xb1\\x00\\x00\\x00\\x00\\xb6\\xb7\\x00\\x00\\x00\\xbb\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\xc3\\xe3\\xa1\\xa2\\xc5\\xe5\\x00\\x00\\x00\\x00\\xb2\\xb9\\x00\\x00\"\n-    \"\\xd0\\xf0\\x00\\x00\\x00\\x00\\x00\\x00\\xdd\\xfd\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\xa3\\xb3\\xd1\\xf1\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xd5\\xf5\\xbc\\xbd\\x00\\x00\\x00\\x00\\x00\\x00\\xd7\\xf7\\x00\\x00\\x00\\x00\"\n-    \"\\xa6\\xa8\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xd8\\xf8\\x00\\x00\\x00\\x00\\x00\\x00\\xbe\\xac\\xae\\xaf\\xbf\\xb4\\xb8\\x00\"\n-    \"\\x06\\x00\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa4\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xb5\\xa5\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xba\\xde\\xfe\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n-    \"\\xc0\\xc1\\xc2\\x00\\xc4\\x00\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf\"\n-    \"\\x00\\x00\\xd2\\xd3\\xd4\\x00\\xd6\\x00\\x00\\xd9\\xda\\xdb\\xdc\\x00\\x00\\xdf\"\n-    \"\\xe0\\xe1\\xe2\\x00\\xe4\\x00\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef\"\n-    \"\\x00\\x00\\xf2\\xf3\\xf4\\x00\\xf6\\x00\\x00\\xf9\\xfa\\xfb\\xfc\\x00\\x00\\xff\"\n-};\n+#if !defined(LIBXML_ICONV_ENABLED) && !defined(LIBXML_ICU_ENABLED) && \\\n+    defined(LIBXML_ISO8859X_ENABLED)\n@@ -3693,0 +2732,11 @@\n+static xmlCharEncError\n+UTF8ToISO8859x(void *vctxt,\n+               unsigned char *out, int *outlen,\n+               const unsigned char *in, int *inlen,\n+               int flush ATTRIBUTE_UNUSED) {\n+    const unsigned char *xlattable = vctxt;\n+    const unsigned char *instart = in;\n+    const unsigned char *inend;\n+    unsigned char *outstart = out;\n+    unsigned char *outend;\n+    int ret = XML_ENC_ERR_SPACE;\n@@ -3694,3 +2744,8 @@\n-\/*\n- * auto-generated functions for ISO-8859-2 .. ISO-8859-16\n- *\/\n+    if (in == NULL) {\n+        \/*\n+        * initialization nothing to do\n+        *\/\n+        *outlen = 0;\n+        *inlen = 0;\n+        return(XML_ENC_ERR_SUCCESS);\n+    }\n@@ -3698,8 +2753,4 @@\n-static int ISO8859_2ToUTF8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_2);\n-}\n-static int UTF8ToISO8859_2 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_2);\n-}\n+    inend = in + *inlen;\n+    outend = out + *outlen;\n+    while (in < inend) {\n+        unsigned d = *in;\n@@ -3707,8 +2758,6 @@\n-static int ISO8859_3ToUTF8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_3);\n-}\n-static int UTF8ToISO8859_3 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_3);\n-}\n+        if  (d < 0x80)  {\n+            if (out >= outend)\n+                goto done;\n+            in += 1;\n+        } else if (d < 0xE0) {\n+            unsigned c;\n@@ -3716,8 +2765,16 @@\n-static int ISO8859_4ToUTF8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_4);\n-}\n-static int UTF8ToISO8859_4 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_4);\n-}\n+            if (inend - in < 2)\n+                break;\n+            c = in[1] & 0x3F;\n+            d = d & 0x1F;\n+            d = xlattable [48 + c + xlattable [d] * 64];\n+            if (d == 0) {\n+                \/* not in character set *\/\n+                ret = XML_ENC_ERR_INPUT;\n+                goto done;\n+            }\n+            if (out >= outend)\n+                goto done;\n+            in += 2;\n+        } else if (d < 0xF0) {\n+            unsigned c1;\n+            unsigned c2;\n@@ -3725,8 +2782,20 @@\n-static int ISO8859_5ToUTF8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_5);\n-}\n-static int UTF8ToISO8859_5 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_5);\n-}\n+            if (inend - in < 3)\n+                break;\n+            c1 = in[1] & 0x3F;\n+            c2 = in[2] & 0x3F;\n+            d = d & 0x0F;\n+            d = xlattable [48 + c2 + xlattable [48 + c1 +\n+                        xlattable [32 + d] * 64] * 64];\n+            if (d == 0) {\n+                \/* not in character set *\/\n+                ret = XML_ENC_ERR_INPUT;\n+                goto done;\n+            }\n+            if (out >= outend)\n+                goto done;\n+            in += 3;\n+        } else {\n+            \/* cannot transcode >= U+010000 *\/\n+                ret = XML_ENC_ERR_INPUT;\n+                goto done;\n+        }\n@@ -3734,8 +2803,2 @@\n-static int ISO8859_6ToUTF8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_6);\n-}\n-static int UTF8ToISO8859_6 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_6);\n-}\n+        *out++ = d;\n+    }\n@@ -3743,8 +2806,1 @@\n-static int ISO8859_7ToUTF8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_7);\n-}\n-static int UTF8ToISO8859_7 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_7);\n-}\n+    ret = out - outstart;\n@@ -3752,7 +2808,4 @@\n-static int ISO8859_8ToUTF8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_8);\n-}\n-static int UTF8ToISO8859_8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_8);\n+done:\n+    *outlen = out - outstart;\n+    *inlen = in - instart;\n+    return(ret);\n@@ -3761,8 +2814,11 @@\n-static int ISO8859_9ToUTF8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_9);\n-}\n-static int UTF8ToISO8859_9 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_9);\n-}\n+static xmlCharEncError\n+ISO8859xToUTF8(void *vctxt,\n+               unsigned char* out, int *outlen,\n+               const unsigned char* in, int *inlen,\n+               int flush ATTRIBUTE_UNUSED) {\n+    unsigned short const *unicodetable = vctxt;\n+    const unsigned char* instart = in;\n+    const unsigned char* inend;\n+    unsigned char* outstart = out;\n+    unsigned char* outend;\n+    int ret = XML_ENC_ERR_SPACE;\n@@ -3770,8 +2826,2 @@\n-static int ISO8859_10ToUTF8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_10);\n-}\n-static int UTF8ToISO8859_10 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_10);\n-}\n+    outend = out + *outlen;\n+    inend = in + *inlen;\n@@ -3779,8 +2829,2 @@\n-static int ISO8859_11ToUTF8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_11);\n-}\n-static int UTF8ToISO8859_11 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_11);\n-}\n+    while (in < inend) {\n+        unsigned c = *in;\n@@ -3788,8 +2832,24 @@\n-static int ISO8859_13ToUTF8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_13);\n-}\n-static int UTF8ToISO8859_13 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_13);\n-}\n+        if (c < 0x80) {\n+            if (out >= outend)\n+                goto done;\n+            *out++ = c;\n+        } else {\n+            c = unicodetable[c - 0x80];\n+            if (c == 0) {\n+                \/* undefined code point *\/\n+                ret = XML_ENC_ERR_INPUT;\n+                goto done;\n+            }\n+            if (c < 0x800) {\n+                if (outend - out < 2)\n+                    goto done;\n+                *out++ = ((c >>  6) & 0x1F) | 0xC0;\n+                *out++ = (c & 0x3F) | 0x80;\n+            } else {\n+                if (outend - out < 3)\n+                    goto done;\n+                *out++ = ((c >>  12) & 0x0F) | 0xE0;\n+                *out++ = ((c >>  6) & 0x3F) | 0x80;\n+                *out++ = (c & 0x3F) | 0x80;\n+            }\n+        }\n@@ -3797,8 +2857,2 @@\n-static int ISO8859_14ToUTF8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_14);\n-}\n-static int UTF8ToISO8859_14 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_14);\n-}\n+        in += 1;\n+    }\n@@ -3806,8 +2860,1 @@\n-static int ISO8859_15ToUTF8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_15);\n-}\n-static int UTF8ToISO8859_15 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_15);\n-}\n+    ret = out - outstart;\n@@ -3815,7 +2862,4 @@\n-static int ISO8859_16ToUTF8 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return ISO8859xToUTF8 (out, outlen, in, inlen, xmlunicodetable_ISO8859_16);\n-}\n-static int UTF8ToISO8859_16 (unsigned char* out, int *outlen,\n-    const unsigned char* in, int *inlen) {\n-    return UTF8ToISO8859x (out, outlen, in, inlen, xmltranscodetable_ISO8859_16);\n+done:\n+    *outlen = out - outstart;\n+    *inlen = in - instart;\n+    return(ret);\n@@ -3825,1 +2869,0 @@\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/encoding.c","additions":1751,"deletions":2708,"binary":false,"changes":4459,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+#ifndef SIZE_MAX\n+  #define SIZE_MAX ((size_t) -1)\n+#endif\n+\n@@ -116,2 +120,2 @@\n-            const xmlChar *ExternalID, const xmlChar *SystemID,\n-            const xmlChar *content) {\n+                const xmlChar *ExternalID, const xmlChar *SystemID,\n+                const xmlChar *content) {\n@@ -122,1 +126,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -132,1 +136,1 @@\n-    ret->name = xmlStrdup(name);\n+        ret->name = xmlStrdup(name);\n@@ -149,1 +153,1 @@\n-    ret->content = xmlStrndup(content, ret->length);\n+        ret->content = xmlStrndup(content, ret->length);\n@@ -157,1 +161,1 @@\n-            the defining entity *\/\n+                        the defining entity *\/\n@@ -186,2 +190,2 @@\n-      const xmlChar *ExternalID, const xmlChar *SystemID,\n-      const xmlChar *content, xmlEntityPtr *out) {\n+          const xmlChar *ExternalID, const xmlChar *SystemID,\n+          const xmlChar *content, xmlEntityPtr *out) {\n@@ -197,1 +201,1 @@\n-    return(XML_ERR_ARGUMENT);\n+        return(XML_ERR_ARGUMENT);\n@@ -245,2 +249,2 @@\n-        if (dtd->entities == NULL) {\n-        dtd->entities = xmlHashCreateDict(0, dict);\n+            if (dtd->entities == NULL) {\n+                dtd->entities = xmlHashCreateDict(0, dict);\n@@ -250,2 +254,2 @@\n-        table = dtd->entities;\n-        break;\n+            table = dtd->entities;\n+            break;\n@@ -254,2 +258,2 @@\n-        if (dtd->pentities == NULL) {\n-        dtd->pentities = xmlHashCreateDict(0, dict);\n+            if (dtd->pentities == NULL) {\n+                dtd->pentities = xmlHashCreateDict(0, dict);\n@@ -259,2 +263,2 @@\n-        table = dtd->pentities;\n-        break;\n+            table = dtd->pentities;\n+            break;\n@@ -262,1 +266,1 @@\n-        return(XML_ERR_ARGUMENT);\n+            return(XML_ERR_ARGUMENT);\n@@ -273,3 +277,3 @@\n-    \/*\n-     * entity was already defined at another level.\n-     *\/\n+        \/*\n+         * entity was already defined at another level.\n+         *\/\n@@ -277,1 +281,1 @@\n-    return(XML_WAR_ENTITY_REDEFINED);\n+        return(XML_WAR_ENTITY_REDEFINED);\n@@ -286,1 +290,1 @@\n-    dtd->children = dtd->last = (xmlNodePtr) ret;\n+        dtd->children = dtd->last = (xmlNodePtr) ret;\n@@ -288,3 +292,3 @@\n-    dtd->last->next = (xmlNodePtr) ret;\n-    ret->prev = dtd->last;\n-    dtd->last = (xmlNodePtr) ret;\n+        dtd->last->next = (xmlNodePtr) ret;\n+        ret->prev = dtd->last;\n+        dtd->last = (xmlNodePtr) ret;\n@@ -311,3 +315,3 @@\n-        if (xmlStrEqual(name, BAD_CAST \"lt\"))\n-            return(&xmlEntityLt);\n-        break;\n+            if (xmlStrEqual(name, BAD_CAST \"lt\"))\n+                return(&xmlEntityLt);\n+            break;\n@@ -315,3 +319,3 @@\n-        if (xmlStrEqual(name, BAD_CAST \"gt\"))\n-            return(&xmlEntityGt);\n-        break;\n+            if (xmlStrEqual(name, BAD_CAST \"gt\"))\n+                return(&xmlEntityGt);\n+            break;\n@@ -319,5 +323,5 @@\n-        if (xmlStrEqual(name, BAD_CAST \"amp\"))\n-            return(&xmlEntityAmp);\n-        if (xmlStrEqual(name, BAD_CAST \"apos\"))\n-            return(&xmlEntityApos);\n-        break;\n+            if (xmlStrEqual(name, BAD_CAST \"amp\"))\n+                return(&xmlEntityAmp);\n+            if (xmlStrEqual(name, BAD_CAST \"apos\"))\n+                return(&xmlEntityApos);\n+            break;\n@@ -325,5 +329,5 @@\n-        if (xmlStrEqual(name, BAD_CAST \"quot\"))\n-            return(&xmlEntityQuot);\n-        break;\n-    default:\n-        break;\n+            if (xmlStrEqual(name, BAD_CAST \"quot\"))\n+                return(&xmlEntityQuot);\n+            break;\n+        default:\n+            break;\n@@ -349,2 +353,2 @@\n-            const xmlChar *ExternalID, const xmlChar *SystemID,\n-        const xmlChar *content) {\n+                const xmlChar *ExternalID, const xmlChar *SystemID,\n+                const xmlChar *content) {\n@@ -372,2 +376,2 @@\n-            const xmlChar *ExternalID, const xmlChar *SystemID,\n-            const xmlChar *content) {\n+                const xmlChar *ExternalID, const xmlChar *SystemID,\n+                const xmlChar *content) {\n@@ -399,2 +403,2 @@\n-         const xmlChar *ExternalID, const xmlChar *SystemID,\n-         const xmlChar *content) {\n+             const xmlChar *ExternalID, const xmlChar *SystemID,\n+             const xmlChar *content) {\n@@ -402,1 +406,1 @@\n-    return(xmlAddDocEntity(doc, name, type, ExternalID, SystemID, content));\n+        return(xmlAddDocEntity(doc, name, type, ExternalID, SystemID, content));\n@@ -441,1 +445,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -443,4 +447,4 @@\n-    table = (xmlEntitiesTablePtr) doc->intSubset->pentities;\n-    ret = xmlGetEntityFromTable(table, name);\n-    if (ret != NULL)\n-        return(ret);\n+        table = (xmlEntitiesTablePtr) doc->intSubset->pentities;\n+        ret = xmlGetEntityFromTable(table, name);\n+        if (ret != NULL)\n+            return(ret);\n@@ -449,2 +453,2 @@\n-    table = (xmlEntitiesTablePtr) doc->extSubset->pentities;\n-    return(xmlGetEntityFromTable(table, name));\n+        table = (xmlEntitiesTablePtr) doc->extSubset->pentities;\n+        return(xmlGetEntityFromTable(table, name));\n@@ -471,1 +475,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -473,2 +477,2 @@\n-    table = (xmlEntitiesTablePtr) doc->extSubset->entities;\n-    return(xmlGetEntityFromTable(table, name));\n+        table = (xmlEntitiesTablePtr) doc->extSubset->entities;\n+        return(xmlGetEntityFromTable(table, name));\n@@ -496,13 +500,14 @@\n-    if ((doc->intSubset != NULL) && (doc->intSubset->entities != NULL)) {\n-        table = (xmlEntitiesTablePtr) doc->intSubset->entities;\n-        cur = xmlGetEntityFromTable(table, name);\n-        if (cur != NULL)\n-        return(cur);\n-    }\n-    if (doc->standalone != 1) {\n-        if ((doc->extSubset != NULL) &&\n-        (doc->extSubset->entities != NULL)) {\n-        table = (xmlEntitiesTablePtr) doc->extSubset->entities;\n-        cur = xmlGetEntityFromTable(table, name);\n-        if (cur != NULL)\n-            return(cur);\n+        if ((doc->intSubset != NULL) && (doc->intSubset->entities != NULL)) {\n+            table = (xmlEntitiesTablePtr) doc->intSubset->entities;\n+            cur = xmlGetEntityFromTable(table, name);\n+            if (cur != NULL)\n+                return(cur);\n+        }\n+        if (doc->standalone != 1) {\n+            if ((doc->extSubset != NULL) &&\n+                (doc->extSubset->entities != NULL)) {\n+                table = (xmlEntitiesTablePtr) doc->extSubset->entities;\n+                cur = xmlGetEntityFromTable(table, name);\n+                if (cur != NULL)\n+                    return(cur);\n+            }\n@@ -510,1 +515,0 @@\n-    }\n@@ -516,1 +520,9 @@\n- * Macro used to grow the current buffer.\n+ * xmlSerializeHexCharRef:\n+ * @buf:  a char buffer\n+ * @val:  a codepoint\n+ *\n+ * Serializes a hex char ref like &#xA0;\n+ *\n+ * Writes at most 9 bytes. Does not include a terminating zero byte.\n+ *\n+ * Returns the number of bytes written.\n@@ -518,8 +530,35 @@\n-#define growBufferReentrant() {                        \\\n-    xmlChar *tmp;                                                       \\\n-    size_t new_size = buffer_size * 2;                                  \\\n-    if (new_size < buffer_size) goto mem_error;                         \\\n-    tmp = (xmlChar *) xmlRealloc(buffer, new_size);                    \\\n-    if (tmp == NULL) goto mem_error;                                    \\\n-    buffer = tmp;                            \\\n-    buffer_size = new_size;                        \\\n+int\n+xmlSerializeHexCharRef(char *buf, int val) {\n+    char *out = buf;\n+    int shift = 0, bits;\n+\n+    *out++ = '&';\n+    *out++ = '#';\n+    *out++ = 'x';\n+\n+    bits = val;\n+    if (bits & 0xFF0000) {\n+        shift = 16;\n+        bits &= 0xFF0000;\n+    } else if (bits & 0x00FF00) {\n+        shift = 8;\n+        bits &= 0x00FF00;\n+    }\n+    if (bits & 0xF0F0F0) {\n+        shift += 4;\n+    }\n+\n+    do {\n+        int d = (val >> shift) & 0x0F;\n+\n+        if (d < 10)\n+            *out++ = '0' + d;\n+        else\n+            *out++ = 'A' + (d - 10);\n+\n+        shift -= 4;\n+    } while (shift >= 0);\n+\n+    *out++ = ';';\n+\n+    return(out - buf);\n@@ -528,5 +567,4 @@\n-\/**\n- * xmlEncodeEntitiesInternal:\n- * @doc:  the document containing the string\n- * @input:  A string to convert to XML.\n- * @attr: are we handling an attribute value\n+\/*\n+ * xmlSerializeDecCharRef:\n+ * @buf:  a char buffer\n+ * @val:  a codepoint\n@@ -534,4 +572,1 @@\n- * Do a global encoding of a string, replacing the predefined entities\n- * and non ASCII values with their entities and CharRef counterparts.\n- * Contrary to xmlEncodeEntities, this routine is reentrant, and result\n- * must be deallocated.\n+ * Serializes a decimal char ref like &#38;\n@@ -539,1 +574,3 @@\n- * Returns A newly allocated string with the substitution done.\n+ * Writes at most 10 bytes. Does not include a terminating zero byte.\n+ *\n+ * Returns the number of bytes written.\n@@ -541,11 +578,17 @@\n-static xmlChar *\n-xmlEncodeEntitiesInternal(xmlDocPtr doc, const xmlChar *input, int attr) {\n-    const xmlChar *cur = input;\n-    xmlChar *buffer = NULL;\n-    xmlChar *out = NULL;\n-    size_t buffer_size = 0;\n-    int html = 0;\n-\n-    if (input == NULL) return(NULL);\n-    if (doc != NULL)\n-        html = (doc->type == XML_HTML_DOCUMENT_NODE);\n+int\n+xmlSerializeDecCharRef(char *buf, int val) {\n+    char *out = buf;\n+    int len, i;\n+\n+    *out++ = '&';\n+    *out++ = '#';\n+\n+    if (val < 100) {\n+        len = (val < 10) ? 1 : 2;\n+    } else if (val < 10000) {\n+        len = (val < 1000) ? 3 : 4;\n+    } else if (val < 1000000) {\n+        len = (val < 100000) ? 5 : 6;\n+    } else {\n+        len = 7;\n+    }\n@@ -553,5 +596,45 @@\n-    \/*\n-     * allocate an translation buffer.\n-     *\/\n-    buffer_size = 1000;\n-    buffer = (xmlChar *) xmlMalloc(buffer_size);\n+    for (i = len - 1; i >= 0; i--) {\n+        out[i] = '0' + val % 10;\n+        val \/= 10;\n+    }\n+\n+    out[len] = ';';\n+\n+    return(len + 3);\n+}\n+\n+static const char xmlEscapeSafe[128] = {\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n+};\n+\n+\/*\n+ * xmlEscapeText:\n+ * @text:  input text\n+ * @flags:  XML_ESCAPE flags\n+ *\n+ * Escapes certain characters with char refs.\n+ *\n+ * XML_ESCAPE_ATTR: for attribute content.\n+ * XML_ESCAPE_NON_ASCII: escape non-ASCII chars.\n+ * XML_ESCAPE_HTML: for HTML content.\n+ * XML_ESCAPE_QUOT: escape double quotes.\n+ * XML_ESCAPE_ALLOW_INVALID: allow invalid characters.\n+ *\n+ * Returns an escaped string or NULL if a memory allocation failed.\n+ *\/\n+xmlChar *\n+xmlEscapeText(const xmlChar *text, int flags) {\n+    const xmlChar *cur;\n+    xmlChar *buffer;\n+    xmlChar *out;\n+    const xmlChar *unescaped;\n+    size_t size = 50;\n+\n+    buffer = xmlMalloc(size + 1);\n@@ -559,1 +642,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -562,7 +645,2 @@\n-    while (*cur != '\\0') {\n-        size_t indx = out - buffer;\n-        if (indx + 100 > buffer_size) {\n-\n-        growBufferReentrant();\n-        out = &buffer[indx];\n-    }\n+    cur = text;\n+    unescaped = cur;\n@@ -570,4 +648,2 @@\n-    \/*\n-     * By default one have to encode at least '<', '>', '\"' and '&' !\n-     *\/\n-    if (*cur == '<') {\n+    while (*cur != '\\0') {\n+        char buf[12];\n@@ -575,13 +651,18 @@\n-\n-        \/*\n-         * Special handling of server side include in HTML attributes\n-         *\/\n-        if (html && attr &&\n-            (cur[1] == '!') && (cur[2] == '-') && (cur[3] == '-') &&\n-            ((end = xmlStrstr(cur, BAD_CAST \"-->\")) != NULL)) {\n-            while (cur != end) {\n-            *out++ = *cur++;\n-            indx = out - buffer;\n-            if (indx + 100 > buffer_size) {\n-            growBufferReentrant();\n-            out = &buffer[indx];\n+        const xmlChar *repl;\n+        size_t used;\n+        size_t replSize;\n+        size_t unescapedSize;\n+        size_t totalSize;\n+        int chunkSize = 1;\n+        int c;\n+\n+        \/* accelerator *\/\n+        while (1) {\n+            c = *cur;\n+\n+            if (c < 0x80) {\n+                if (!xmlEscapeSafe[*cur])\n+                    break;\n+            } else {\n+               if (flags & XML_ESCAPE_NON_ASCII)\n+                   break;\n@@ -589,0 +670,1 @@\n+            cur += 1;\n@@ -590,27 +672,18 @@\n-        *out++ = *cur++;\n-        *out++ = *cur++;\n-        *out++ = *cur++;\n-        continue;\n-        }\n-        *out++ = '&';\n-        *out++ = 'l';\n-        *out++ = 't';\n-        *out++ = ';';\n-    } else if (*cur == '>') {\n-        *out++ = '&';\n-        *out++ = 'g';\n-        *out++ = 't';\n-        *out++ = ';';\n-    } else if (*cur == '&') {\n-        \/*\n-         * Special handling of &{...} construct from HTML 4, see\n-         * http:\/\/www.w3.org\/TR\/html401\/appendix\/notes.html#h-B.7.1\n-         *\/\n-        if (html && attr && (cur[1] == '{') &&\n-            (strchr((const char *) cur, '}'))) {\n-            while (*cur != '}') {\n-            *out++ = *cur++;\n-            indx = out - buffer;\n-            if (indx + 100 > buffer_size) {\n-            growBufferReentrant();\n-            out = &buffer[indx];\n+\n+        if (c == 0) {\n+            chunkSize = 0;\n+            repl = BAD_CAST \"\";\n+            replSize = 0;\n+        } else if (c == '<') {\n+            \/*\n+             * Special handling of server side include in HTML attributes\n+             *\/\n+            if ((flags & XML_ESCAPE_HTML) && (flags & XML_ESCAPE_ATTR) &&\n+                (cur[1] == '!') && (cur[2] == '-') && (cur[3] == '-') &&\n+                ((end = xmlStrstr(cur, BAD_CAST \"-->\")) != NULL)) {\n+                chunkSize = (end - cur) + 3;\n+                repl = cur;\n+                replSize = chunkSize;\n+            } else {\n+                repl = BAD_CAST \"&lt;\";\n+                replSize = 4;\n@@ -618,27 +691,49 @@\n-        }\n-        *out++ = *cur++;\n-        continue;\n-        }\n-        *out++ = '&';\n-        *out++ = 'a';\n-        *out++ = 'm';\n-        *out++ = 'p';\n-        *out++ = ';';\n-    } else if (((*cur >= 0x20) && (*cur < 0x80)) ||\n-        (*cur == '\\n') || (*cur == '\\t') || ((html) && (*cur == '\\r'))) {\n-        \/*\n-         * default case, just copy !\n-         *\/\n-        *out++ = *cur;\n-    } else if (*cur >= 0x80) {\n-        if (((doc != NULL) && (doc->encoding != NULL)) || (html)) {\n-        \/*\n-         * Bjrn Reese <br@sseusa.com> provided the patch\n-            xmlChar xc;\n-            xc = (*cur & 0x3F) << 6;\n-            if (cur[1] != 0) {\n-            xc += *(++cur) & 0x3F;\n-            *out++ = xc;\n-            } else\n-         *\/\n-        *out++ = *cur;\n+        } else if (c == '>') {\n+            repl = BAD_CAST \"&gt;\";\n+            replSize = 4;\n+        } else if (c == '&') {\n+            \/*\n+             * Special handling of &{...} construct from HTML 4, see\n+             * http:\/\/www.w3.org\/TR\/html401\/appendix\/notes.html#h-B.7.1\n+             *\/\n+            if ((flags & XML_ESCAPE_HTML) && (flags & XML_ESCAPE_ATTR) &&\n+                (cur[1] == '{') && (end = xmlStrchr(cur, '}'))) {\n+                chunkSize = (end - cur) + 1;\n+                repl = cur;\n+                replSize = chunkSize;\n+            } else {\n+                repl = BAD_CAST \"&amp;\";\n+                replSize = 5;\n+            }\n+        } else if ((flags & XML_ESCAPE_QUOT) && (c == '\"')) {\n+            repl = BAD_CAST \"&quot;\";\n+            replSize = 6;\n+        } else if (((flags & XML_ESCAPE_HTML) == 0) && (c == '\\r')) {\n+            repl = BAD_CAST \"&#13;\";\n+            replSize = 5;\n+        } else if ((flags & XML_ESCAPE_NON_ASCII) && (c >= 0x80)) {\n+            int val;\n+\n+            chunkSize = 4;\n+            val = xmlGetUTF8Char(cur, &chunkSize);\n+            if (val < 0) {\n+                val = 0xFFFD;\n+                chunkSize = 1;\n+            } else if (((flags & XML_ESCAPE_ALLOW_INVALID) == 0) &&\n+                       (!IS_CHAR(val))) {\n+                val = 0xFFFD;\n+            }\n+\n+            replSize = xmlSerializeHexCharRef(buf, val);\n+            repl = BAD_CAST buf;\n+        } else if ((flags & (XML_ESCAPE_ALLOW_INVALID | XML_ESCAPE_HTML)) ||\n+                   (c >= 0x20) ||\n+                   (c == '\\n') || (c == '\\t') || (c == '\\r')) {\n+            \/* default case, just copy *\/\n+            cur += 1;\n+            if (*cur != 0)\n+                continue;\n+\n+            chunkSize = 0;\n+            repl = BAD_CAST \"\";\n+            replSize = 0;\n@@ -646,25 +741,3 @@\n-        \/*\n-         * We assume we have UTF-8 input.\n-         * It must match either:\n-         *   110xxxxx 10xxxxxx\n-         *   1110xxxx 10xxxxxx 10xxxxxx\n-         *   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n-         * That is:\n-         *   cur[0] is 11xxxxxx\n-         *   cur[1] is 10xxxxxx\n-         *   cur[2] is 10xxxxxx if cur[0] is 111xxxxx\n-         *   cur[3] is 10xxxxxx if cur[0] is 1111xxxx\n-         *   cur[0] is not 11111xxx\n-         *\/\n-        char buf[13], *ptr;\n-        int val, l;\n-\n-                l = 4;\n-                val = xmlGetUTF8Char(cur, &l);\n-                if (val < 0) {\n-                    val = 0xFFFD;\n-                    cur++;\n-                } else {\n-                    if (!IS_CHAR(val))\n-                        val = 0xFFFD;\n-                    cur += l;\n+            \/* ignore *\/\n+            repl = BAD_CAST \"\";\n+            replSize = 0;\n@@ -672,8 +745,27 @@\n-        \/*\n-         * We could do multiple things here. Just save as a char ref\n-         *\/\n-        snprintf(buf, sizeof(buf), \"&#x%X;\", val);\n-        buf[sizeof(buf) - 1] = 0;\n-        ptr = buf;\n-        while (*ptr != 0) *out++ = *ptr++;\n-        continue;\n+\n+        used = out - buffer;\n+        unescapedSize = cur - unescaped;\n+        totalSize = unescapedSize + replSize;\n+\n+        cur += chunkSize;\n+\n+        if (totalSize > size - used) {\n+            xmlChar *tmp;\n+            int newSize;\n+\n+            if ((size > (SIZE_MAX - 1) \/ 2) ||\n+                (totalSize > (SIZE_MAX - 1) \/ 2 - size)) {\n+                xmlFree(buffer);\n+                return(NULL);\n+            }\n+            newSize = size + totalSize;\n+            if (*cur != 0)\n+                newSize *= 2;\n+            tmp = xmlRealloc(buffer, newSize + 1);\n+            if (tmp == NULL) {\n+                xmlFree(buffer);\n+                return(NULL);\n+            }\n+            buffer = tmp;\n+            size = newSize;\n+            out = buffer + used;\n@@ -681,2 +773,0 @@\n-    } else if (IS_BYTE_CHAR(*cur)) {\n-        char buf[11], *ptr;\n@@ -684,6 +774,6 @@\n-        snprintf(buf, sizeof(buf), \"&#%d;\", *cur);\n-        buf[sizeof(buf) - 1] = 0;\n-            ptr = buf;\n-        while (*ptr != 0) *out++ = *ptr++;\n-    }\n-    cur++;\n+        memcpy(out, unescaped, unescapedSize);\n+        out += unescapedSize;\n+        memcpy(out, repl, replSize);\n+        out += replSize;\n+\n+        unescaped = cur;\n@@ -691,0 +781,1 @@\n+\n@@ -693,4 +784,0 @@\n-\n-mem_error:\n-    xmlFree(buffer);\n-    return(NULL);\n@@ -700,1 +787,1 @@\n- * xmlEncodeAttributeEntities:\n+ * xmlEncodeEntitiesInternal:\n@@ -703,0 +790,1 @@\n+ * @flags:  XML_ESCAPE flags\n@@ -705,2 +793,3 @@\n- * and non ASCII values with their entities and CharRef counterparts for\n- * attribute values.\n+ * and non ASCII values with their entities and CharRef counterparts.\n+ * Contrary to xmlEncodeEntities, this routine is reentrant, and result\n+ * must be deallocated.\n@@ -711,2 +800,11 @@\n-xmlEncodeAttributeEntities(xmlDocPtr doc, const xmlChar *input) {\n-    return xmlEncodeEntitiesInternal(doc, input, 1);\n+xmlEncodeEntitiesInternal(xmlDocPtr doc, const xmlChar *input,\n+                          unsigned flags) {\n+    if (input == NULL)\n+        return(NULL);\n+\n+    if ((doc != NULL) && (doc->type == XML_HTML_DOCUMENT_NODE))\n+        flags |= XML_ESCAPE_HTML;\n+    else if ((doc == NULL) || (doc->encoding == NULL))\n+        flags |= XML_ESCAPE_NON_ASCII;\n+\n+    return(xmlEscapeText(input, flags));\n@@ -725,0 +823,4 @@\n+ * This escapes '<', '>', '&' and '\\r'. If the document has no encoding,\n+ * non-ASCII codepoints are escaped. There is some special handling for\n+ * HTML documents.\n+ *\n@@ -734,1 +836,1 @@\n- * @doc:  the document containing the string\n+ * @doc:  unused\n@@ -740,0 +842,2 @@\n+ * This escapes '<', '>', '&', '\"' and '\\r' chars.\n+ *\n@@ -743,67 +847,4 @@\n-xmlEncodeSpecialChars(const xmlDoc *doc ATTRIBUTE_UNUSED, const xmlChar *input) {\n-    const xmlChar *cur = input;\n-    xmlChar *buffer = NULL;\n-    xmlChar *out = NULL;\n-    size_t buffer_size = 0;\n-    if (input == NULL) return(NULL);\n-\n-    \/*\n-     * allocate an translation buffer.\n-     *\/\n-    buffer_size = 1000;\n-    buffer = (xmlChar *) xmlMalloc(buffer_size);\n-    if (buffer == NULL)\n-    return(NULL);\n-    out = buffer;\n-\n-    while (*cur != '\\0') {\n-        size_t indx = out - buffer;\n-        if (indx + 10 > buffer_size) {\n-\n-        growBufferReentrant();\n-        out = &buffer[indx];\n-    }\n-\n-    \/*\n-     * By default one have to encode at least '<', '>', '\"' and '&' !\n-     *\/\n-    if (*cur == '<') {\n-        *out++ = '&';\n-        *out++ = 'l';\n-        *out++ = 't';\n-        *out++ = ';';\n-    } else if (*cur == '>') {\n-        *out++ = '&';\n-        *out++ = 'g';\n-        *out++ = 't';\n-        *out++ = ';';\n-    } else if (*cur == '&') {\n-        *out++ = '&';\n-        *out++ = 'a';\n-        *out++ = 'm';\n-        *out++ = 'p';\n-        *out++ = ';';\n-    } else if (*cur == '\"') {\n-        *out++ = '&';\n-        *out++ = 'q';\n-        *out++ = 'u';\n-        *out++ = 'o';\n-        *out++ = 't';\n-        *out++ = ';';\n-    } else if (*cur == '\\r') {\n-        *out++ = '&';\n-        *out++ = '#';\n-        *out++ = '1';\n-        *out++ = '3';\n-        *out++ = ';';\n-    } else {\n-        \/*\n-         * Works because on UTF-8, all extended sequences cannot\n-         * result in bytes in the ASCII range.\n-         *\/\n-        *out++ = *cur;\n-    }\n-    cur++;\n-    }\n-    *out = 0;\n-    return(buffer);\n+xmlEncodeSpecialChars(const xmlDoc *doc ATTRIBUTE_UNUSED,\n+                      const xmlChar *input) {\n+    if (input == NULL)\n+        return(NULL);\n@@ -811,3 +852,1 @@\n-mem_error:\n-    xmlFree(buffer);\n-    return(NULL);\n+    return(xmlEscapeText(input, XML_ESCAPE_QUOT | XML_ESCAPE_ALLOW_INVALID));\n@@ -839,1 +878,1 @@\n-    xmlFreeEntity((xmlEntityPtr) entity);\n+        xmlFreeEntity((xmlEntityPtr) entity);\n@@ -853,1 +892,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -869,1 +907,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -875,1 +913,1 @@\n-    cur->name = xmlStrdup(ent->name);\n+        cur->name = xmlStrdup(ent->name);\n@@ -880,1 +918,1 @@\n-    cur->ExternalID = xmlStrdup(ent->ExternalID);\n+        cur->ExternalID = xmlStrdup(ent->ExternalID);\n@@ -885,1 +923,1 @@\n-    cur->SystemID = xmlStrdup(ent->SystemID);\n+        cur->SystemID = xmlStrdup(ent->SystemID);\n@@ -890,1 +928,1 @@\n-    cur->content = xmlStrdup(ent->content);\n+        cur->content = xmlStrdup(ent->content);\n@@ -895,1 +933,1 @@\n-    cur->orig = xmlStrdup(ent->orig);\n+        cur->orig = xmlStrdup(ent->orig);\n@@ -900,1 +938,1 @@\n-    cur->URI = xmlStrdup(ent->URI);\n+        cur->URI = xmlStrdup(ent->URI);\n@@ -923,1 +961,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/entities.c","additions":355,"deletions":318,"binary":false,"changes":673,"status":"modified"},{"patch":"@@ -20,0 +20,1 @@\n+#include \"private\/globals.h\"\n@@ -22,0 +23,31 @@\n+\/**\n+ * xmlIsCatastrophicError:\n+ * @level:  error level\n+ * @code:  error code\n+ *\n+ * Returns true if an error is catastrophic.\n+ *\/\n+int\n+xmlIsCatastrophicError(int level, int code) {\n+    int fatal = 0;\n+\n+    if (level != XML_ERR_FATAL)\n+        return(0);\n+\n+    switch (code) {\n+        case XML_ERR_NO_MEMORY:\n+        \/* case XML_ERR_RESOURCE_LIMIT: *\/\n+        case XML_ERR_SYSTEM:\n+        case XML_ERR_ARGUMENT:\n+        case XML_ERR_INTERNAL_ERROR:\n+            fatal = 1;\n+            break;\n+        default:\n+            if ((code >= 1500) && (code <= 1599))\n+                fatal = 1;\n+            break;\n+    }\n+\n+    return(fatal);\n+}\n+\n@@ -23,3 +55,3 @@\n- *                                    *\n- *            Error struct                    *\n- *                                    *\n+ *                                                                      *\n+ *                      Error struct                                    *\n+ *                                                                      *\n@@ -180,3 +212,3 @@\n- *                                    *\n- *            Handling of out of context errors        *\n- *                                    *\n+ *                                                                      *\n+ *                      Handling of out of context errors               *\n+ *                                                                      *\n@@ -198,1 +230,1 @@\n-    xmlGenericErrorContext = (void *) stderr;\n+        xmlGenericErrorContext = (void *) stderr;\n@@ -205,18 +237,0 @@\n-\/**\n- * initGenericErrorDefaultFunc:\n- * @handler:  the handler\n- *\n- * DEPRECATED: Use xmlSetGenericErrorFunc.\n- *\n- * Set or reset (if NULL) the default handler for generic errors\n- * to the builtin error function.\n- *\/\n-void\n-initGenericErrorDefaultFunc(xmlGenericErrorFunc * handler)\n-{\n-    if (handler == NULL)\n-        xmlGenericError = xmlGenericErrorDefaultFunc;\n-    else\n-        xmlGenericError = (*handler);\n-}\n-\n@@ -248,1 +262,1 @@\n-    xmlGenericError = handler;\n+        xmlGenericError = handler;\n@@ -250,1 +264,1 @@\n-    xmlGenericError = xmlGenericErrorDefaultFunc;\n+        xmlGenericError = xmlGenericErrorDefaultFunc;\n@@ -290,3 +304,3 @@\n- *                                    *\n- *            Handling of parsing errors            *\n- *                                    *\n+ *                                                                      *\n+ *                      Handling of parsing errors                      *\n+ *                                                                      *\n@@ -307,7 +321,7 @@\n-    if (input->filename)\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"%s:%d: \", input->filename,\n-            input->line);\n-    else\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"Entity: line %d: \", input->line);\n+        if (input->filename)\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"%s:%d: \", input->filename,\n+                    input->line);\n+        else\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"Entity: line %d: \", input->line);\n@@ -326,1 +340,1 @@\n-        xmlGenericErrorFunc channel, void *data ) {\n+                xmlGenericErrorFunc channel, void *data ) {\n@@ -328,1 +342,1 @@\n-    unsigned int n, col;    \/* GCC warns if signed, because compared with sizeof() *\/\n+    unsigned int n, col;        \/* GCC warns if signed, because compared with sizeof() *\/\n@@ -339,1 +353,1 @@\n-    cur--;\n+        cur--;\n@@ -344,1 +358,1 @@\n-       (*cur != '\\n') && (*cur != '\\r')) {\n+           (*cur != '\\n') && (*cur != '\\r')) {\n@@ -368,1 +382,1 @@\n-    n += len;\n+        n += len;\n@@ -379,3 +393,3 @@\n-    if (*(ctnt) != '\\t')\n-        *(ctnt) = ' ';\n-    ctnt++;\n+        if (*(ctnt) != '\\t')\n+            *(ctnt) = ' ';\n+        ctnt++;\n@@ -446,2 +460,2 @@\n-    (domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {\n-    ctxt = err->ctxt;\n+        (domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {\n+        ctxt = err->ctxt;\n@@ -472,3 +486,3 @@\n-             ((domain == XML_FROM_PARSER) || (domain == XML_FROM_SCHEMASV)||\n-          (domain == XML_FROM_SCHEMASP)||(domain == XML_FROM_DTD) ||\n-          (domain == XML_FROM_RELAXNGP)||(domain == XML_FROM_RELAXNGV)))\n+                 ((domain == XML_FROM_PARSER) || (domain == XML_FROM_SCHEMASV)||\n+                  (domain == XML_FROM_SCHEMASP)||(domain == XML_FROM_DTD) ||\n+                  (domain == XML_FROM_RELAXNGP)||(domain == XML_FROM_RELAXNGV)))\n@@ -570,5 +584,5 @@\n-    len = xmlStrlen((const xmlChar *) message);\n-    if ((len > 0) && (message[len - 1] != '\\n'))\n-        channel(data, \"%s\\n\", message);\n-    else\n-        channel(data, \"%s\", message);\n+        len = xmlStrlen((const xmlChar *) message);\n+        if ((len > 0) && (message[len - 1] != '\\n'))\n+            channel(data, \"%s\\n\", message);\n+        else\n+            channel(data, \"%s\", message);\n@@ -607,10 +621,10 @@\n-    (err->int1 < xmlStrlen((const xmlChar *)err->str1))) {\n-    xmlChar buf[150];\n-    int i;\n-\n-    channel(data, \"%s\\n\", err->str1);\n-    for (i=0;i < err->int1;i++)\n-         buf[i] = ' ';\n-    buf[i++] = '^';\n-    buf[i] = 0;\n-    channel(data, \"%s\\n\", buf);\n+        (err->int1 < xmlStrlen((const xmlChar *)err->str1))) {\n+        xmlChar buf[150];\n+        int i;\n+\n+        channel(data, \"%s\\n\", err->str1);\n+        for (i=0;i < err->int1;i++)\n+             buf[i] = ' ';\n+        buf[i++] = '^';\n+        buf[i] = 0;\n+        channel(data, \"%s\\n\", buf);\n@@ -638,1 +652,1 @@\n-    xmlError *lastError = &xmlLastError;\n+    xmlError *lastError = xmlGetLastErrorInternal();\n@@ -697,1 +711,1 @@\n-    xmlErrorPtr lastError = &xmlLastError;\n+    xmlErrorPtr lastError = xmlGetLastErrorInternal();\n@@ -703,4 +717,2 @@\n-    if (code == XML_ERR_INTERNAL_ERROR) {\n-        fprintf(stderr, \"Unexpected error: %d\\n\", code);\n-        abort();\n-    }\n+    if (code == XML_ERR_INTERNAL_ERROR)\n+        xmlAbort(\"Unexpected error: %d\\n\", code);\n@@ -713,2 +725,2 @@\n-    (domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {\n-    ctxt = (xmlParserCtxtPtr) ctx;\n+        (domain == XML_FROM_IO) || (domain == XML_FROM_VALID)) {\n+        ctxt = (xmlParserCtxtPtr) ctx;\n@@ -730,1 +742,1 @@\n-    schannel(data, to);\n+        schannel(data, to);\n@@ -742,1 +754,1 @@\n-        channel(data, \"%s\", to->message);\n+            channel(data, \"%s\", to->message);\n@@ -749,1 +761,1 @@\n- * __xmlRaiseError:\n+ * xmlRaiseError:\n@@ -754,1 +766,1 @@\n- * @nod: the node or NULL\n+ * @node: the node or NULL\n@@ -775,6 +787,6 @@\n-__xmlRaiseError(xmlStructuredErrorFunc schannel,\n-                xmlGenericErrorFunc channel, void *data, void *ctx,\n-                xmlNode *node, int domain, int code, xmlErrorLevel level,\n-                const char *file, int line, const char *str1,\n-                const char *str2, const char *str3, int int1, int col,\n-                const char *msg, ...)\n+xmlRaiseError(xmlStructuredErrorFunc schannel,\n+              xmlGenericErrorFunc channel, void *data, void *ctx,\n+              xmlNode *node, int domain, int code, xmlErrorLevel level,\n+              const char *file, int line, const char *str1,\n+              const char *str2, const char *str3, int int1, int col,\n+              const char *msg, ...)\n@@ -803,7 +815,7 @@\n-    input = ctxt->input;\n-    if ((input != NULL) && (input->filename == NULL) &&\n-        (ctxt->inputNr > 1)) {\n-        cur = input;\n-        input = ctxt->inputTab[ctxt->inputNr - 2];\n-    }\n-    xmlParserPrintFileInfo(input);\n+        input = ctxt->input;\n+        if ((input != NULL) && (input->filename == NULL) &&\n+            (ctxt->inputNr > 1)) {\n+            cur = input;\n+            input = ctxt->inputTab[ctxt->inputNr - 2];\n+        }\n+        xmlParserPrintFileInfo(input);\n@@ -817,1 +829,1 @@\n-    xmlFree(str);\n+        xmlFree(str);\n@@ -821,6 +833,6 @@\n-    xmlParserPrintFileContext(input);\n-    if (cur != NULL) {\n-        xmlParserPrintFileInfo(cur);\n-        xmlGenericError(xmlGenericErrorContext, \"\\n\");\n-        xmlParserPrintFileContext(cur);\n-    }\n+        xmlParserPrintFileContext(input);\n+        if (cur != NULL) {\n+            xmlParserPrintFileInfo(cur);\n+            xmlGenericError(xmlGenericErrorContext, \"\\n\");\n+            xmlParserPrintFileContext(cur);\n+        }\n@@ -908,3 +920,3 @@\n- *                                    *\n- *            Extended Error Handling                *\n- *                                    *\n+ *                                                                      *\n+ *                      Extended Error Handling                         *\n+ *                                                                      *\n@@ -924,3 +936,5 @@\n-    if (xmlLastError.code == XML_ERR_OK)\n-        return (NULL);\n-    return (&xmlLastError);\n+    const xmlError *error = xmlGetLastErrorInternal();\n+\n+    if (error->code == XML_ERR_OK)\n+        return(NULL);\n+    return(error);\n@@ -965,4 +979,1 @@\n-    if (xmlLastError.code == XML_ERR_OK)\n-        return;\n-    xmlResetError(&xmlLastError);\n-}\n+    xmlError *error = xmlGetLastErrorInternal();\n@@ -970,38 +981,2 @@\n-\/**\n- * xmlCtxtGetLastError:\n- * @ctx:  an XML parser context\n- *\n- * Get the last parsing error registered.\n- *\n- * Returns NULL if no error occurred or a pointer to the error\n- *\/\n-const xmlError *\n-xmlCtxtGetLastError(void *ctx)\n-{\n-    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;\n-\n-    if (ctxt == NULL)\n-        return (NULL);\n-    if (ctxt->lastError.code == XML_ERR_OK)\n-        return (NULL);\n-    return (&ctxt->lastError);\n-}\n-\n-\/**\n- * xmlCtxtResetLastError:\n- * @ctx:  an XML parser context\n- *\n- * Cleanup the last global error registered. For parsing error\n- * this does not change the well-formedness result.\n- *\/\n-void\n-xmlCtxtResetLastError(void *ctx)\n-{\n-    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;\n-\n-    if (ctxt == NULL)\n-        return;\n-    ctxt->errNo = XML_ERR_OK;\n-    if (ctxt->lastError.code == XML_ERR_OK)\n-        return;\n-    xmlResetError(&ctxt->lastError);\n+    if (error->code != XML_ERR_OK)\n+        xmlResetError(error);\n@@ -1369,0 +1344,46 @@\n+\n+\/**\n+ * xmlVPrintErrorMessage:\n+ * @fmt:  printf format string\n+ * @ap:  arguments\n+ *\n+ * Prints to stderr.\n+ *\/\n+void\n+xmlVPrintErrorMessage(const char *fmt, va_list ap) {\n+    vfprintf(stderr, fmt, ap);\n+}\n+\n+\/**\n+ * xmlPrintErrorMessage:\n+ * @fmt:  printf format string\n+ * @...:  arguments\n+ *\n+ * Prints to stderr.\n+ *\/\n+void\n+xmlPrintErrorMessage(const char *fmt, ...) {\n+    va_list ap;\n+\n+    va_start(ap, fmt);\n+    xmlVPrintErrorMessage(fmt, ap);\n+    va_end(ap);\n+}\n+\n+\/**\n+ * xmlAbort:\n+ * @fmt:  printf format string\n+ * @...:  arguments\n+ *\n+ * Print message to stderr and abort.\n+ *\/\n+void\n+xmlAbort(const char *fmt, ...) {\n+    va_list ap;\n+\n+    va_start(ap, fmt);\n+    xmlVPrintErrorMessage(fmt, ap);\n+    va_end(ap);\n+\n+    abort();\n+}\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/error.c","additions":166,"deletions":145,"binary":false,"changes":311,"status":"modified"},{"patch":"@@ -14,1 +14,0 @@\n-#include <stdio.h>\n@@ -19,1 +18,0 @@\n-#include <libxml\/globals.h>\n@@ -26,1 +24,1 @@\n-#include <libxml\/SAX.h>\n+#include <libxml\/xmlsave.h>\n@@ -35,0 +33,5 @@\n+\/*\n+ * Mutex to protect \"ForNewThreads\" variables\n+ *\/\n+static xmlMutex xmlThrDefMutex;\n+\n@@ -49,3 +52,3 @@\n- * First we support POSIX and Windows threads. Then we support both thread-local\n- * storage provided by the compiler and older methods like thread-specific data\n- * (pthreads) or TlsAlloc (Windows).\n+ * First we support POSIX and Windows threads. Then we support both\n+ * thread-local storage provided by the compiler and older methods like\n+ * thread-specific data (pthreads) or TlsAlloc (Windows).\n@@ -54,2 +57,17 @@\n- * On Windows, we either use DllMain when compiling a DLL or a registered wait\n- * function for static builds.\n+ * On Windows, we either use DllMain when compiling a DLL or a registered\n+ * wait function for static builds.\n+ *\n+ * Compiler TLS isn't really useful for now. It can make allocation more\n+ * robust on some platforms but it also increases the memory consumption\n+ * of each thread by ~250 bytes whether it uses libxml2 or not. The main\n+ * problem is that we have to deallocate strings in xmlLastError and C\n+ * offers no simple way to deallocate dynamic data in _Thread_local\n+ * variables. In C++, one could simply use a thread_local variable with a\n+ * destructor.\n+ *\n+ * At some point, many of the deprecated globals can be removed,\n+ * although things like global error handlers will take a while.\n+ * Ultimately, the only crucial things seem to be xmlLastError and\n+ * RNG state. xmlLastError already involves dynamic allocation, so it\n+ * could be allocated dynamically as well, only storing a global\n+ * pointer.\n@@ -58,3 +76,0 @@\n-\/*\n- * Helpful Macro\n- *\/\n@@ -62,16 +77,0 @@\n-#define IS_MAIN_THREAD (xmlIsMainThreadInternal())\n-#else\n-#define IS_MAIN_THREAD 1\n-#endif\n-\n-#define XML_DECLARE_MEMBER(name, type, attrs) \\\n-  type gs_##name;\n-\n-struct _xmlGlobalState {\n-    int initialized;\n-\n-#if defined(HAVE_WIN32_THREADS) && \\\n-    defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL)\n-    void *threadHandle;\n-    void *waitHandle;\n-#endif\n@@ -79,2 +78,6 @@\n-#ifdef LIBXML_THREAD_ENABLED\n-    unsigned localRngState[2];\n+#ifdef HAVE_WIN32_THREADS\n+  #if defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL)\n+    #define USE_WAIT_DTOR\n+  #else\n+    #define USE_DLL_MAIN\n+  #endif\n@@ -83,18 +86,0 @@\n-#define XML_OP XML_DECLARE_MEMBER\n-XML_GLOBALS_ALLOC\n-XML_GLOBALS_ERROR\n-XML_GLOBALS_IO\n-XML_GLOBALS_PARSER\n-XML_GLOBALS_TREE\n-#undef XML_OP\n-};\n-\n-static int parserInitialized;\n-\n-\/*\n- * Mutex to protect \"ForNewThreads\" variables\n- *\/\n-static xmlMutex xmlThrDefMutex;\n-\n-#ifdef LIBXML_THREAD_ENABLED\n-\n@@ -111,2 +96,1 @@\n-    (!defined(HAVE_WIN32_THREADS) || \\\n-     !defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))\n+    !defined(USE_WAIT_DTOR)\n@@ -116,4 +100,0 @@\n-#ifdef USE_TLS\n-static XML_THREAD_LOCAL xmlGlobalState globalState;\n-#endif\n-\n@@ -122,20 +102,0 @@\n-\/*\n- * Weak symbol hack, see threads.c\n- *\/\n-#if defined(__GNUC__) && \\\n-    defined(__GLIBC__) && \\\n-    __GLIBC__ * 100 + __GLIBC_MINOR__ < 234\n-\n-#pragma weak pthread_getspecific\n-#pragma weak pthread_setspecific\n-#pragma weak pthread_key_create\n-#pragma weak pthread_key_delete\n-#pragma weak pthread_equal\n-#pragma weak pthread_self\n-\n-#define XML_PTHREAD_WEAK\n-\n-static int libxml_is_threaded = -1;\n-\n-#endif\n-\n@@ -148,1 +108,0 @@\n-static pthread_t mainthread;\n@@ -155,1 +114,0 @@\n-static DWORD mainthread;\n@@ -164,5 +122,50 @@\n-\/************************************************************************\n- *                                    *\n- *    All the user accessible global variables of the library        *\n- *                                    *\n- ************************************************************************\/\n+struct _xmlGlobalState {\n+#ifdef USE_TLS\n+    int initialized;\n+#endif\n+\n+#ifdef USE_WAIT_DTOR\n+    void *threadHandle;\n+    void *waitHandle;\n+#endif\n+\n+    unsigned localRngState[2];\n+\n+    xmlError lastError;\n+\n+#ifdef LIBXML_THREAD_ALLOC_ENABLED\n+    xmlMallocFunc malloc;\n+    xmlMallocFunc mallocAtomic;\n+    xmlReallocFunc realloc;\n+    xmlFreeFunc free;\n+    xmlStrdupFunc memStrdup;\n+#endif\n+\n+    int doValidityCheckingDefaultValue;\n+    int getWarningsDefaultValue;\n+    int keepBlanksDefaultValue;\n+    int lineNumbersDefaultValue;\n+    int loadExtDtdDefaultValue;\n+    int pedanticParserDefaultValue;\n+    int substituteEntitiesDefaultValue;\n+\n+#ifdef LIBXML_OUTPUT_ENABLED\n+    int indentTreeOutput;\n+    const char *treeIndentString;\n+    int saveNoEmptyTags;\n+#endif\n+\n+    xmlGenericErrorFunc genericError;\n+    void *genericErrorContext;\n+    xmlStructuredErrorFunc structuredError;\n+    void *structuredErrorContext;\n+\n+    xmlRegisterNodeFunc registerNodeDefaultValue;\n+    xmlDeregisterNodeFunc deregisterNodeDefaultValue;\n+\n+    xmlParserInputBufferCreateFilenameFunc parserInputBufferCreateFilenameValue;\n+    xmlOutputBufferCreateFilenameFunc outputBufferCreateFilenameValue;\n+};\n+\n+typedef struct _xmlGlobalState xmlGlobalState;\n+typedef xmlGlobalState *xmlGlobalStatePtr;\n@@ -171,1 +174,3 @@\n-static unsigned xmlMainThreadRngState[2];\n+\n+#ifdef USE_TLS\n+static XML_THREAD_LOCAL xmlGlobalState globalState;\n@@ -174,0 +179,12 @@\n+#else \/* LIBXML_THREAD_ENABLED *\/\n+\n+static xmlGlobalState globalState;\n+\n+#endif \/* LIBXML_THREAD_ENABLED *\/\n+\n+\/************************************************************************\n+ *                                                                      *\n+ *      All the user accessible global variables of the library         *\n+ *                                                                      *\n+ ************************************************************************\/\n+\n@@ -237,20 +254,0 @@\n-\/**\n- * xmlBufferAllocScheme:\n- *\n- * DEPRECATED: Don't use.\n- *\n- * Global setting, default allocation policy for buffers, default is\n- * XML_BUFFER_ALLOC_EXACT\n- *\/\n-xmlBufferAllocationScheme xmlBufferAllocScheme = XML_BUFFER_ALLOC_EXACT;\n-static xmlBufferAllocationScheme xmlBufferAllocSchemeThrDef = XML_BUFFER_ALLOC_EXACT;\n-\/**\n- * xmlDefaultBufferSize:\n- *\n- * DEPRECATED: Don't use.\n- *\n- * Global setting, default buffer size. Default value is BASE_BUFFER_SIZE\n- *\/\n-int xmlDefaultBufferSize = BASE_BUFFER_SIZE;\n-static int xmlDefaultBufferSizeThrDef = BASE_BUFFER_SIZE;\n-\n@@ -261,25 +258,0 @@\n-\/**\n- * oldXMLWDcompatibility:\n- *\n- * Global setting, DEPRECATED.\n- *\/\n-const int oldXMLWDcompatibility = 0; \/* DEPRECATED *\/\n-\/**\n- * xmlParserDebugEntities:\n- *\n- * DEPRECATED: Don't use\n- *\n- * Global setting, asking the parser to print out debugging information.\n- * while handling entities.\n- * Disabled by default\n- *\/\n-const int xmlParserDebugEntities = 0;\n-\/**\n- * xmlDoValidityCheckingDefaultValue:\n- *\n- * DEPRECATED: Use the modern options API with XML_PARSE_DTDVALID.\n- *\n- * Global setting, indicate that the parser should work in validating mode.\n- * Disabled by default.\n- *\/\n-int xmlDoValidityCheckingDefaultValue = 0;\n@@ -287,9 +259,0 @@\n-\/**\n- * xmlGetWarningsDefaultValue:\n- *\n- * DEPRECATED: Use the modern options API with XML_PARSE_NOWARNING.\n- *\n- * Global setting, indicate that the DTD validation should provide warnings.\n- * Activated by default.\n- *\/\n-int xmlGetWarningsDefaultValue = 1;\n@@ -297,10 +260,0 @@\n-\/**\n- * xmlLoadExtDtdDefaultValue:\n- *\n- * DEPRECATED: Use the modern options API with XML_PARSE_DTDLOAD.\n- *\n- * Global setting, indicate that the parser should load DTD while not\n- * validating.\n- * Disabled by default.\n- *\/\n-int xmlLoadExtDtdDefaultValue = 0;\n@@ -308,9 +261,0 @@\n-\/**\n- * xmlPedanticParserDefaultValue:\n- *\n- * DEPRECATED: Use the modern options API with XML_PARSE_PEDANTIC.\n- *\n- * Global setting, indicate that the parser be pedantic\n- * Disabled by default.\n- *\/\n-int xmlPedanticParserDefaultValue = 0;\n@@ -318,11 +262,0 @@\n-\/**\n- * xmlLineNumbersDefaultValue:\n- *\n- * DEPRECATED: The modern options API always enables line numbers.\n- *\n- * Global setting, indicate that the parser should store the line number\n- * in the content field of elements in the DOM tree.\n- * Disabled by default since this may not be safe for old classes of\n- * application.\n- *\/\n-int xmlLineNumbersDefaultValue = 0;\n@@ -330,12 +263,0 @@\n-\/**\n- * xmlKeepBlanksDefaultValue:\n- *\n- * DEPRECATED: Use the modern options API with XML_PARSE_NOBLANKS.\n- *\n- * Global setting, indicate that the parser should keep all blanks\n- * nodes found in the content\n- * Activated by default, this is actually needed to have the parser\n- * conformant to the XML Recommendation, however the option is kept\n- * for some applications since this was libxml1 default behaviour.\n- *\/\n-int xmlKeepBlanksDefaultValue = 1;\n@@ -343,12 +264,0 @@\n-\/**\n- * xmlSubstituteEntitiesDefaultValue:\n- *\n- * DEPRECATED: Use the modern options API with XML_PARSE_NOENT.\n- *\n- * Global setting, indicate that the parser should not generate entity\n- * references but replace them with the actual content of the entity\n- * Disabled by default, this should be activated when using XPath since\n- * the XPath data model requires entities replacement and the XPath\n- * engine does not handle entities references transparently.\n- *\/\n-int xmlSubstituteEntitiesDefaultValue = 0;\n@@ -357,6 +266,0 @@\n-\/**\n- * xmlRegisterNodeDefaultValue:\n- *\n- * DEPRECATED: Don't use\n- *\/\n-xmlRegisterNodeFunc xmlRegisterNodeDefaultValue = NULL;\n@@ -364,7 +267,0 @@\n-\n-\/**\n- * xmlDeregisterNodeDefaultValue:\n- *\n- * DEPRECATED: Don't use\n- *\/\n-xmlDeregisterNodeFunc xmlDeregisterNodeDefaultValue = NULL;\n@@ -373,7 +269,4 @@\n-\/**\n- * xmlParserInputBufferCreateFilenameValue:\n- *\n- * DEPRECATED: Don't use\n- *\/\n-xmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValue = NULL;\n-static xmlParserInputBufferCreateFilenameFunc xmlParserInputBufferCreateFilenameValueThrDef = NULL;\n+static xmlParserInputBufferCreateFilenameFunc\n+xmlParserInputBufferCreateFilenameValueThrDef = NULL;\n+static xmlOutputBufferCreateFilenameFunc\n+xmlOutputBufferCreateFilenameValueThrDef = NULL;\n@@ -381,14 +274,0 @@\n-\/**\n- * xmlOutputBufferCreateFilenameValue:\n- *\n- * DEPRECATED: Don't use\n- *\/\n-xmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValue = NULL;\n-static xmlOutputBufferCreateFilenameFunc xmlOutputBufferCreateFilenameValueThrDef = NULL;\n-\n-\/**\n- * xmlGenericError:\n- *\n- * Global setting: function used for generic error callbacks\n- *\/\n-xmlGenericErrorFunc xmlGenericError = xmlGenericErrorDefaultFunc;\n@@ -396,6 +275,0 @@\n-\/**\n- * xmlStructuredError:\n- *\n- * Global setting: function used for structured error callbacks\n- *\/\n-xmlStructuredErrorFunc xmlStructuredError = NULL;\n@@ -403,6 +276,0 @@\n-\/**\n- * xmlGenericErrorContext:\n- *\n- * Global setting passed to generic error callbacks\n- *\/\n-void *xmlGenericErrorContext = NULL;\n@@ -410,6 +277,0 @@\n-\/**\n- * xmlStructuredErrorContext:\n- *\n- * Global setting passed to structured error callbacks\n- *\/\n-void *xmlStructuredErrorContext = NULL;\n@@ -417,1 +278,0 @@\n-xmlError xmlLastError;\n@@ -420,10 +280,0 @@\n-\/*\n- * output defaults\n- *\/\n-\/**\n- * xmlIndentTreeOutput:\n- *\n- * Global setting, asking the serializer to indent the output tree by default\n- * Enabled by default\n- *\/\n-int xmlIndentTreeOutput = 1;\n@@ -431,7 +281,0 @@\n-\n-\/**\n- * xmlTreeIndentString:\n- *\n- * The string used to do one-level indent. By default is equal to \"  \" (two spaces)\n- *\/\n-const char *xmlTreeIndentString = \"  \";\n@@ -439,10 +282,0 @@\n-\n-\/**\n- * xmlSaveNoEmptyTags:\n- *\n- * Global setting, asking the serializer to not output empty tags\n- * as <empty\/> but <empty><\/empty>. those two forms are indistinguishable\n- * once parsed.\n- * Disabled by default\n- *\/\n-int xmlSaveNoEmptyTags = 0;\n@@ -549,0 +382,3 @@\n+static void\n+xmlInitGlobalState(xmlGlobalStatePtr gs);\n+\n@@ -550,3 +386,3 @@\n- *                                    *\n- *            Per thread global state handling        *\n- *                                    *\n+ *                                                                      *\n+ *                      Per thread global state handling                *\n+ *                                                                      *\n@@ -573,16 +409,0 @@\n-#ifdef XML_PTHREAD_WEAK\n-    if (libxml_is_threaded == -1)\n-        libxml_is_threaded =\n-            (pthread_getspecific != NULL) &&\n-            (pthread_setspecific != NULL) &&\n-            (pthread_key_create != NULL) &&\n-            (pthread_key_delete != NULL) &&\n-            \/*\n-             * pthread_equal can be inline, resuting in -Waddress warnings.\n-             * Let's assume it's available if all the other functions are.\n-             *\/\n-            \/* (pthread_equal != NULL) && *\/\n-            (pthread_self != NULL);\n-    if (libxml_is_threaded == 0)\n-        return;\n-#endif \/* XML_PTHREAD_WEAK *\/\n@@ -590,1 +410,0 @@\n-    mainthread = pthread_self();\n@@ -593,3 +412,2 @@\n-    globalkey = TlsAlloc();\n-#endif\n-    mainthread = GetCurrentThreadId();\n+    if (globalkey == TLS_OUT_OF_INDEXES)\n+        globalkey = TlsAlloc();\n@@ -597,4 +415,2 @@\n-\n-#ifdef LIBXML_THREAD_ENABLED\n-    xmlMainThreadRngState[0] = xmlGlobalRandom();\n-    xmlMainThreadRngState[1] = xmlGlobalRandom();\n+#else \/* no thread support *\/\n+    xmlInitGlobalState(&globalState);\n@@ -621,3 +437,5 @@\n-    xmlResetError(&xmlLastError);\n-\n-    xmlCleanupMutex(&xmlThrDefMutex);\n+    \/*\n+     * We assume that all other threads using the library have\n+     * terminated and the last remaining thread calls\n+     * xmlCleanupParser.\n+     *\/\n@@ -626,4 +444,7 @@\n-#ifdef XML_PTHREAD_WEAK\n-    if (libxml_is_threaded == 0)\n-        return;\n-#endif \/* XML_PTHREAD_WEAK *\/\n+    \/*\n+     * Free thread-specific data of last thread before calling\n+     * pthread_key_delete.\n+     *\/\n+    xmlGlobalState *gs = pthread_getspecific(globalkey);\n+    if (gs != NULL)\n+        xmlFreeGlobalState(gs);\n@@ -632,1 +453,1 @@\n-#ifndef USE_TLS\n+#if defined(USE_WAIT_DTOR) && !defined(USE_TLS)\n@@ -638,0 +459,2 @@\n+#else \/* no thread support *\/\n+    xmlResetError(&globalState.lastError);\n@@ -640,59 +463,1 @@\n-    parserInitialized = 0;\n-}\n-\n-\/**\n- * xmlInitializeGlobalState:\n- * @gs: a pointer to a newly allocated global state\n- *\n- * DEPRECATED: No-op.\n- *\/\n-void\n-xmlInitializeGlobalState(xmlGlobalStatePtr gs ATTRIBUTE_UNUSED)\n-{\n-}\n-\n-\/**\n- * xmlGetGlobalState:\n- *\n- * DEPRECATED\n- *\n- * Returns NULL.\n- *\/\n-xmlGlobalStatePtr\n-xmlGetGlobalState(void)\n-{\n-    return(NULL);\n-}\n-\n-static int\n-xmlIsMainThreadInternal(void) {\n-    if (parserInitialized == 0) {\n-        xmlInitParser();\n-        parserInitialized = 1;\n-    }\n-\n-#ifdef HAVE_POSIX_THREADS\n-#ifdef XML_PTHREAD_WEAK\n-    if (libxml_is_threaded == 0)\n-        return (1);\n-#endif\n-    return (pthread_equal(mainthread, pthread_self()));\n-#elif defined HAVE_WIN32_THREADS\n-    return (mainthread == GetCurrentThreadId());\n-#else\n-    return (1);\n-#endif\n-}\n-\n-\/**\n- * xmlIsMainThread:\n- *\n- * DEPRECATED: Internal function, do not use.\n- *\n- * Check whether the current thread is the main thread.\n- *\n- * Returns 1 if the current thread is the main thread, 0 otherwise\n- *\/\n-int\n-xmlIsMainThread(void) {\n-    return(xmlIsMainThreadInternal());\n+    xmlCleanupMutex(&xmlThrDefMutex);\n@@ -709,1 +474,1 @@\n-     * Free any memory allocated in the thread's xmlLastError. If it\n+     * Free any memory allocated in the thread's error struct. If it\n@@ -712,5 +477,0 @@\n-     *\n-     * It would be nice if we could make xmlLastError a special error\n-     * type which uses statically allocated, fixed-size buffers.\n-     * But the xmlError struct is fully public and widely used,\n-     * so changes are dangerous.\n@@ -718,1 +478,1 @@\n-    xmlResetError(&(gs->gs_xmlLastError));\n+    xmlResetError(&gs->lastError);\n@@ -724,2 +484,1 @@\n-#if defined(HAVE_WIN32_THREADS) && \\\n-    defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL)\n+#if defined(USE_WAIT_DTOR)\n@@ -756,63 +515,1 @@\n-#endif \/* LIBXML_STATIC *\/\n-\n-static void\n-xmlInitGlobalState(xmlGlobalStatePtr gs) {\n-    xmlMutexLock(&xmlThrDefMutex);\n-\n-#ifdef LIBXML_THREAD_ENABLED\n-    gs->localRngState[0] = xmlGlobalRandom();\n-    gs->localRngState[1] = xmlGlobalRandom();\n-#endif\n-\n-    gs->gs_xmlBufferAllocScheme = xmlBufferAllocSchemeThrDef;\n-    gs->gs_xmlDefaultBufferSize = xmlDefaultBufferSizeThrDef;\n-    gs->gs_xmlDoValidityCheckingDefaultValue =\n-         xmlDoValidityCheckingDefaultValueThrDef;\n-#ifdef LIBXML_THREAD_ALLOC_ENABLED\n-    gs->gs_xmlFree = free;\n-    gs->gs_xmlMalloc = malloc;\n-    gs->gs_xmlMallocAtomic = malloc;\n-    gs->gs_xmlRealloc = realloc;\n-    gs->gs_xmlMemStrdup = xmlPosixStrdup;\n-#endif\n-    gs->gs_xmlGetWarningsDefaultValue = xmlGetWarningsDefaultValueThrDef;\n-#ifdef LIBXML_OUTPUT_ENABLED\n-    gs->gs_xmlIndentTreeOutput = xmlIndentTreeOutputThrDef;\n-    gs->gs_xmlTreeIndentString = xmlTreeIndentStringThrDef;\n-    gs->gs_xmlSaveNoEmptyTags = xmlSaveNoEmptyTagsThrDef;\n-#endif\n-    gs->gs_xmlKeepBlanksDefaultValue = xmlKeepBlanksDefaultValueThrDef;\n-    gs->gs_xmlLineNumbersDefaultValue = xmlLineNumbersDefaultValueThrDef;\n-    gs->gs_xmlLoadExtDtdDefaultValue = xmlLoadExtDtdDefaultValueThrDef;\n-    gs->gs_xmlPedanticParserDefaultValue = xmlPedanticParserDefaultValueThrDef;\n-    gs->gs_xmlSubstituteEntitiesDefaultValue =\n-        xmlSubstituteEntitiesDefaultValueThrDef;\n-\n-    gs->gs_xmlGenericError = xmlGenericErrorThrDef;\n-    gs->gs_xmlStructuredError = xmlStructuredErrorThrDef;\n-    gs->gs_xmlGenericErrorContext = xmlGenericErrorContextThrDef;\n-    gs->gs_xmlStructuredErrorContext = xmlStructuredErrorContextThrDef;\n-    gs->gs_xmlRegisterNodeDefaultValue = xmlRegisterNodeDefaultValueThrDef;\n-    gs->gs_xmlDeregisterNodeDefaultValue = xmlDeregisterNodeDefaultValueThrDef;\n-\n-    gs->gs_xmlParserInputBufferCreateFilenameValue =\n-        xmlParserInputBufferCreateFilenameValueThrDef;\n-    gs->gs_xmlOutputBufferCreateFilenameValue =\n-        xmlOutputBufferCreateFilenameValueThrDef;\n-    memset(&gs->gs_xmlLastError, 0, sizeof(xmlError));\n-\n-    xmlMutexUnlock(&xmlThrDefMutex);\n-\n-#ifdef HAVE_POSIX_THREADS\n-    pthread_setspecific(globalkey, gs);\n-#elif defined HAVE_WIN32_THREADS\n-#ifndef USE_TLS\n-    TlsSetValue(globalkey, gs);\n-#endif\n-#if defined(LIBXML_STATIC) && !defined(LIBXML_STATIC_FOR_DLL)\n-    xmlRegisterGlobalStateDtor(gs);\n-#endif\n-#endif\n-\n-    gs->initialized = 1;\n-}\n+#endif \/* USE_WAIT_DTOR *\/\n@@ -835,0 +532,4 @@\n+    \/*\n+     * We use malloc\/free to allow accessing globals before setting\n+     * custom memory allocators.\n+     *\/\n@@ -845,3 +546,2 @@\n-        fprintf(stderr, \"libxml2: Failed to allocate globals for thread\\n\"\n-                        \"libxml2: See xmlCheckThreadLocalStorage\\n\");\n-        abort();\n+        xmlAbort(\"libxml2: Failed to allocate globals for thread\\n\"\n+                 \"libxml2: See xmlCheckThreadLocalStorage\\n\");\n@@ -862,0 +562,2 @@\n+    xmlInitParser();\n+\n@@ -881,1 +583,1 @@\n-\/* Define thread-local storage accessors with macro magic *\/\n+#else \/* LIBXML_THREAD_ENABLED *\/\n@@ -883,7 +585,4 @@\n-#define XML_DEFINE_GLOBAL_WRAPPER(name, type, attrs) \\\n-    type *__##name(void) { \\\n-        if (IS_MAIN_THREAD) \\\n-            return (&name); \\\n-        else \\\n-            return (&xmlGetThreadLocalStorage(0)->gs_##name); \\\n-    }\n+static xmlGlobalStatePtr\n+xmlGetThreadLocalStorage(int allowFailure ATTRIBUTE_UNUSED) {\n+    return(&globalState);\n+}\n@@ -891,7 +590,1 @@\n-#define XML_OP XML_DEFINE_GLOBAL_WRAPPER\n-XML_GLOBALS_ALLOC\n-XML_GLOBALS_ERROR\n-XML_GLOBALS_IO\n-XML_GLOBALS_PARSER\n-XML_GLOBALS_TREE\n-#undef XML_OP\n+#endif \/* LIBXML_THREAD_ENABLED *\/\n@@ -899,12 +592,122 @@\n-#ifdef LIBXML_THREAD_ENABLED\n-\/**\n- * xmlGetLocalRngState:\n- *\n- * Returns the local RNG state.\n- *\/\n-unsigned *\n-xmlGetLocalRngState(void) {\n-    if (IS_MAIN_THREAD)\n-        return(xmlMainThreadRngState);\n-    else\n-        return(xmlGetThreadLocalStorage(0)->localRngState);\n+static void\n+xmlInitGlobalState(xmlGlobalStatePtr gs) {\n+    gs->localRngState[0] = xmlGlobalRandom();\n+    gs->localRngState[1] = xmlGlobalRandom();\n+\n+    memset(&gs->lastError, 0, sizeof(xmlError));\n+\n+#ifdef LIBXML_THREAD_ALLOC_ENABLED\n+    \/* XML_GLOBALS_ALLOC *\/\n+    gs->free = free;\n+    gs->malloc = malloc;\n+    gs->mallocAtomic = malloc;\n+    gs->realloc = realloc;\n+    gs->memStrdup = xmlPosixStrdup;\n+#endif\n+\n+    xmlMutexLock(&xmlThrDefMutex);\n+\n+    \/* XML_GLOBALS_PARSER *\/\n+    gs->doValidityCheckingDefaultValue =\n+         xmlDoValidityCheckingDefaultValueThrDef;\n+    gs->getWarningsDefaultValue = xmlGetWarningsDefaultValueThrDef;\n+    gs->keepBlanksDefaultValue = xmlKeepBlanksDefaultValueThrDef;\n+    gs->lineNumbersDefaultValue = xmlLineNumbersDefaultValueThrDef;\n+    gs->loadExtDtdDefaultValue = xmlLoadExtDtdDefaultValueThrDef;\n+    gs->pedanticParserDefaultValue = xmlPedanticParserDefaultValueThrDef;\n+    gs->substituteEntitiesDefaultValue =\n+        xmlSubstituteEntitiesDefaultValueThrDef;\n+#ifdef LIBXML_OUTPUT_ENABLED\n+    gs->indentTreeOutput = xmlIndentTreeOutputThrDef;\n+    gs->treeIndentString = xmlTreeIndentStringThrDef;\n+    gs->saveNoEmptyTags = xmlSaveNoEmptyTagsThrDef;\n+#endif\n+\n+    \/* XML_GLOBALS_ERROR *\/\n+    gs->genericError = xmlGenericErrorThrDef;\n+    gs->structuredError = xmlStructuredErrorThrDef;\n+    gs->genericErrorContext = xmlGenericErrorContextThrDef;\n+    gs->structuredErrorContext = xmlStructuredErrorContextThrDef;\n+\n+    \/* XML_GLOBALS_TREE *\/\n+    gs->registerNodeDefaultValue = xmlRegisterNodeDefaultValueThrDef;\n+    gs->deregisterNodeDefaultValue = xmlDeregisterNodeDefaultValueThrDef;\n+\n+    \/* XML_GLOBALS_IO *\/\n+    gs->parserInputBufferCreateFilenameValue =\n+        xmlParserInputBufferCreateFilenameValueThrDef;\n+    gs->outputBufferCreateFilenameValue =\n+        xmlOutputBufferCreateFilenameValueThrDef;\n+\n+    xmlMutexUnlock(&xmlThrDefMutex);\n+\n+#ifdef USE_TLS\n+    gs->initialized = 1;\n+#endif\n+\n+#ifdef HAVE_POSIX_THREADS\n+    pthread_setspecific(globalkey, gs);\n+#elif defined HAVE_WIN32_THREADS\n+#ifndef USE_TLS\n+    TlsSetValue(globalkey, gs);\n+#endif\n+#ifdef USE_WAIT_DTOR\n+    xmlRegisterGlobalStateDtor(gs);\n+#endif\n+#endif\n+}\n+\n+const xmlError *\n+__xmlLastError(void) {\n+    return(&xmlGetThreadLocalStorage(0)->lastError);\n+}\n+\n+int *\n+__xmlDoValidityCheckingDefaultValue(void) {\n+    return(&xmlGetThreadLocalStorage(0)->doValidityCheckingDefaultValue);\n+}\n+\n+int *\n+__xmlGetWarningsDefaultValue(void) {\n+    return(&xmlGetThreadLocalStorage(0)->getWarningsDefaultValue);\n+}\n+\n+int *\n+__xmlKeepBlanksDefaultValue(void) {\n+    return(&xmlGetThreadLocalStorage(0)->keepBlanksDefaultValue);\n+}\n+\n+int *\n+__xmlLineNumbersDefaultValue(void) {\n+    return(&xmlGetThreadLocalStorage(0)->lineNumbersDefaultValue);\n+}\n+\n+int *\n+__xmlLoadExtDtdDefaultValue(void) {\n+    return(&xmlGetThreadLocalStorage(0)->loadExtDtdDefaultValue);\n+}\n+\n+int *\n+__xmlPedanticParserDefaultValue(void) {\n+    return(&xmlGetThreadLocalStorage(0)->pedanticParserDefaultValue);\n+}\n+\n+int *\n+__xmlSubstituteEntitiesDefaultValue(void) {\n+    return(&xmlGetThreadLocalStorage(0)->substituteEntitiesDefaultValue);\n+}\n+\n+#ifdef LIBXML_OUTPUT_ENABLED\n+int *\n+__xmlIndentTreeOutput(void) {\n+    return(&xmlGetThreadLocalStorage(0)->indentTreeOutput);\n+}\n+\n+const char **\n+__xmlTreeIndentString(void) {\n+    return(&xmlGetThreadLocalStorage(0)->treeIndentString);\n+}\n+\n+int *\n+__xmlSaveNoEmptyTags(void) {\n+    return(&xmlGetThreadLocalStorage(0)->saveNoEmptyTags);\n@@ -914,1 +717,4 @@\n-\/* For backward compatibility *\/\n+xmlGenericErrorFunc *\n+__xmlGenericError(void) {\n+    return(&xmlGetThreadLocalStorage(0)->genericError);\n+}\n@@ -916,3 +722,3 @@\n-const char *const *\n-__xmlParserVersion(void) {\n-    return &xmlParserVersion;\n+void **\n+__xmlGenericErrorContext(void) {\n+    return(&xmlGetThreadLocalStorage(0)->genericErrorContext);\n@@ -921,3 +727,3 @@\n-const int *\n-__oldXMLWDcompatibility(void) {\n-    return &oldXMLWDcompatibility;\n+xmlStructuredErrorFunc *\n+__xmlStructuredError(void) {\n+    return(&xmlGetThreadLocalStorage(0)->structuredError);\n@@ -926,3 +732,3 @@\n-const int *\n-__xmlParserDebugEntities(void) {\n-    return &xmlParserDebugEntities;\n+void **\n+__xmlStructuredErrorContext(void) {\n+    return(&xmlGetThreadLocalStorage(0)->structuredErrorContext);\n@@ -931,3 +737,3 @@\n-const xmlSAXLocator *\n-__xmlDefaultSAXLocator(void) {\n-    return &xmlDefaultSAXLocator;\n+xmlRegisterNodeFunc *\n+__xmlRegisterNodeDefaultValue(void) {\n+    return(&xmlGetThreadLocalStorage(0)->registerNodeDefaultValue);\n@@ -936,4 +742,3 @@\n-#ifdef LIBXML_SAX1_ENABLED\n-const xmlSAXHandlerV1 *\n-__xmlDefaultSAXHandler(void) {\n-    return &xmlDefaultSAXHandler;\n+xmlDeregisterNodeFunc *\n+__xmlDeregisterNodeDefaultValue(void) {\n+    return(&xmlGetThreadLocalStorage(0)->deregisterNodeDefaultValue);\n@@ -942,4 +747,3 @@\n-#ifdef LIBXML_HTML_ENABLED\n-const xmlSAXHandlerV1 *\n-__htmlDefaultSAXHandler(void) {\n-    return &htmlDefaultSAXHandler;\n+xmlParserInputBufferCreateFilenameFunc *\n+__xmlParserInputBufferCreateFilenameValue(void) {\n+    return(&xmlGetThreadLocalStorage(0)->parserInputBufferCreateFilenameValue);\n@@ -947,2 +751,0 @@\n-#endif \/* LIBXML_HTML_ENABLED *\/\n-#endif \/* LIBXML_SAX1_ENABLED *\/\n@@ -950,1 +752,41 @@\n-#endif \/* LIBXML_THREAD_ENABLED *\/\n+xmlOutputBufferCreateFilenameFunc *\n+__xmlOutputBufferCreateFilenameValue(void) {\n+    return(&xmlGetThreadLocalStorage(0)->outputBufferCreateFilenameValue);\n+}\n+\n+#ifdef LIBXML_THREAD_ALLOC_ENABLED\n+xmlMallocFunc *\n+__xmlMalloc(void) {\n+    return(&xmlGetThreadLocalStorage(0)->malloc);\n+}\n+\n+xmlMallocFunc *\n+__xmlMallocAtomic(void) {\n+    return(&xmlGetThreadLocalStorage(0)->mallocAtomic);\n+}\n+\n+xmlReallocFunc *\n+__xmlRealloc(void) {\n+    return(&xmlGetThreadLocalStorage(0)->realloc);\n+}\n+\n+xmlFreeFunc *\n+__xmlFree(void) {\n+    return(&xmlGetThreadLocalStorage(0)->free);\n+}\n+\n+xmlStrdupFunc *\n+__xmlMemStrdup(void) {\n+    return(&xmlGetThreadLocalStorage(0)->memStrdup);\n+}\n+#endif \/* LIBXML_THREAD_ALLOC_ENABLED *\/\n+\n+\/**\n+ * xmlGetLocalRngState:\n+ *\n+ * Returns the local RNG state.\n+ *\/\n+unsigned *\n+xmlGetLocalRngState(void) {\n+    return(xmlGetThreadLocalStorage(0)->localRngState);\n+}\n@@ -966,7 +808,1 @@\n- * This function never fails if the library is compiled with support\n- * for thread-local storage.\n- *\n- * This function never fails for the \"main\" thread which is the first\n- * thread calling xmlInitParser.\n- *\n- * Available since v2.12.0.\n+ * Available since 2.12.0.\n@@ -977,1 +813,1 @@\n-    if ((!xmlIsMainThreadInternal()) && (xmlGetThreadLocalStorage(1) == NULL))\n+    if (xmlGetThreadLocalStorage(1) == NULL)\n@@ -983,0 +819,10 @@\n+\/**\n+ * xmlGetLastErrorInternal:\n+ *\n+ * Returns a pointer to the global error struct.\n+ *\/\n+xmlError *\n+xmlGetLastErrorInternal(void) {\n+    return(&xmlGetThreadLocalStorage(0)->lastError);\n+}\n+\n@@ -996,2 +842,1 @@\n-#if defined(HAVE_WIN32_THREADS) && \\\n-    (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))\n+#ifdef USE_DLL_MAIN\n@@ -1034,0 +879,11 @@\n+\n+#ifndef LIBXML_THREAD_ALLOC_ENABLED\n+        case DLL_PROCESS_DETACH:\n+            if (xmlFree == free)\n+                xmlCleanupParser();\n+            if (globalkey != TLS_OUT_OF_INDEXES) {\n+                TlsFree(globalkey);\n+                globalkey = TLS_OUT_OF_INDEXES;\n+            }\n+            break;\n+#endif\n@@ -1037,1 +893,1 @@\n-#endif\n+#endif \/* USE_DLL_MAIN *\/\n@@ -1044,1 +900,1 @@\n-    xmlGenericErrorThrDef = handler;\n+        xmlGenericErrorThrDef = handler;\n@@ -1046,1 +902,1 @@\n-    xmlGenericErrorThrDef = xmlGenericErrorDefaultFunc;\n+        xmlGenericErrorThrDef = xmlGenericErrorDefaultFunc;\n@@ -1058,18 +914,0 @@\n-xmlBufferAllocationScheme xmlThrDefBufferAllocScheme(xmlBufferAllocationScheme v) {\n-    xmlBufferAllocationScheme ret;\n-    xmlMutexLock(&xmlThrDefMutex);\n-    ret = xmlBufferAllocSchemeThrDef;\n-    xmlBufferAllocSchemeThrDef = v;\n-    xmlMutexUnlock(&xmlThrDefMutex);\n-    return ret;\n-}\n-\n-int xmlThrDefDefaultBufferSize(int v) {\n-    int ret;\n-    xmlMutexLock(&xmlThrDefMutex);\n-    ret = xmlDefaultBufferSizeThrDef;\n-    xmlDefaultBufferSizeThrDef = v;\n-    xmlMutexUnlock(&xmlThrDefMutex);\n-    return ret;\n-}\n-\n@@ -1150,4 +988,0 @@\n-int xmlThrDefParserDebugEntities(int v ATTRIBUTE_UNUSED) {\n-    return(xmlParserDebugEntities);\n-}\n-\n@@ -1180,1 +1014,1 @@\n-    __xmlRegisterCallbacks = 1;\n+    xmlRegisterCallbacks = 1;\n@@ -1195,1 +1029,1 @@\n-    __xmlRegisterCallbacks = 1;\n+    xmlRegisterCallbacks = 1;\n@@ -1210,2 +1044,2 @@\n-        old = __xmlParserInputBufferCreateFilename;\n-    }\n+                old = __xmlParserInputBufferCreateFilename;\n+        }\n@@ -1228,2 +1062,2 @@\n-        old = __xmlOutputBufferCreateFilename;\n-    }\n+                old = __xmlOutputBufferCreateFilename;\n+        }\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/globals.c","additions":364,"deletions":530,"binary":false,"changes":894,"status":"modified"},{"patch":"@@ -430,3 +430,2 @@\n-    size_t lengths[3];\n-    unsigned hashValue;\n-    int found = 0;\n+    size_t lengths[3] = {0, 0, 0};\n+    unsigned hashValue, newSize;\n@@ -437,0 +436,2 @@\n+    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, lengths);\n+\n@@ -440,2 +441,5 @@\n-    hashValue = xmlHashValue(hash->randomSeed, key, key2, key3, lengths);\n-    if (hash->size > 0)\n+    if (hash->size == 0) {\n+        newSize = MIN_HASH_SIZE;\n+    } else {\n+        int found = 0;\n+\n@@ -443,6 +447,0 @@\n-    if (found) {\n-        if (update) {\n-            if (dealloc)\n-                dealloc(entry->payload, entry->key);\n-            entry->payload = payload;\n-        }\n@@ -450,2 +448,6 @@\n-        return(0);\n-    }\n+        if (found) {\n+            if (update) {\n+                if (dealloc)\n+                    dealloc(entry->payload, entry->key);\n+                entry->payload = payload;\n+            }\n@@ -453,5 +455,2 @@\n-    \/*\n-     * Grow the hash table if needed\n-     *\/\n-    if (hash->nbElems + 1 > hash->size \/ MAX_FILL_DENOM * MAX_FILL_NUM) {\n-        unsigned newSize, mask, displ, pos;\n+            return(0);\n+        }\n@@ -459,3 +458,1 @@\n-        if (hash->size == 0) {\n-            newSize = MIN_HASH_SIZE;\n-        } else {\n+        if (hash->nbElems + 1 > hash->size \/ MAX_FILL_DENOM * MAX_FILL_NUM) {\n@@ -466,0 +463,2 @@\n+        } else {\n+            newSize = 0;\n@@ -467,0 +466,8 @@\n+    }\n+\n+    \/*\n+     * Grow the hash table if needed\n+     *\/\n+    if (newSize > 0) {\n+        unsigned mask, displ, pos;\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/hash.c","additions":28,"deletions":21,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -0,0 +1,1607 @@\n+static const unsigned char htmlEntAlpha[177] = {\n+      0,   0,   0,   0,   0,  19,  19,   0,  12,  31,   0,  31,  65,   0,  45,\n+    119,   0,  24, 144,   0,   8, 152,   0,  19, 173,   0,  12, 185,   0,  20,\n+    210,   0,   7, 217,   0,   8, 225,   0,  49,  28,   1,   9,  37,   1,  20,\n+    108,   1,  23, 131,   1,  11, 150,   1,   4, 154,   1,  31, 198,   1,  22,\n+    238,   1,  19,   4,   2,  30,  40,   2,  12,  57,   2,   5,  62,   2,   4,\n+     66,   2,  10,  76,   2,  10,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n+      0,   0,   0,   0,   0,   0,   0,   0,   0,  86,   2,  25, 146,   2,  79,\n+      5,   3,  52,  99,   3,  48, 163,   3,  46, 225,   3,  35,   5,   4,  25,\n+     64,   4,  25,  92,   4,  28, 142,   4,   8, 150,   4,   9, 160,   4,  82,\n+     56,   5,  24,  93,   5,  85,   2,   6,  41,  55,   6,  23, 121,   6,   9,\n+    131,   6,  74, 233,   6,  58, 129,   7,  41, 185,   7,  42, 232,   7,  36,\n+     18,   8,   9,  29,   8,  24,  53,   8,  11,  64,   8,  13\n+};\n+\n+static const unsigned short htmlEntValues[2125] = {\n+        0,     8,    13,    22,    31,    39,    45,    53,    62,    70,\n+       78,    85,    93,   102,   119,   127,   136,   146,   155,   162,\n+      175,   183,   193,   199,   210,   224,   231,   239,   248,   256,\n+      264,   274,   281,   288,   297,   328,   339,   348,   357,   365,\n+      376,   383,   393,   405,   412,   418,   431,   446,   460,   475,\n+      503,   528,   547,   564,   577,   587,   606,   614,   627,   662,\n+      671,   680,   306,   558,   689,   697,   716,   723,   730,   737,\n+      747,   755,   764,   773,   779,   794,   802,   821,   838,   863,\n+      881,   900,   911,   928,   937,   963,   988,  1000,  1019,  1038,\n+     1062,  1079,  1102,  1130,  1154,  1174,  1192,  1209,  1230,  1251,\n+     1286,  1298,  1321,  1342,  1370,  1392,  1421,  1444,  1457,  1466,\n+      705,   788,   945,   953,  1266,  1274,  1362,  1413,  1434,  1475,\n+     1481,  1487,  1496,  1505,  1513,  1519,  1526,  1534,  1543,  1554,\n+     1562,  1582,  1606,  1614,  1623,  1633,  1654,  1669,  1677,  1685,\n+     1691,  1698,  1708,  1644,  1724,  1730,  1738,  1759,  1784,  1793,\n+     1803,  1817,  1825,  1832,  1836,  1851,  1860,  1869,  1877,  1883,\n+     1890,  1898,  1904,  1913,  1940,  1960,  1978,  1993,  2014,  2030,\n+     2039,  1846,  1931,  2045,  2054,  2062,  2067,  2075,  2082,  2098,\n+     2106,  2124,  2132,  2141,  2157,  2170,  2177,  2185,  2192,  2201,\n+     2209,  2215,  2222,  2229,  2238,  2276,  2309,  2327,  2345,  2353,\n+     2362,  2369,  2377,  2386,  2394,  2246,  2253,  2266,  2285,  2295,\n+     2401,  2409,  2415,  2423,  2432,  2441,  2450,  2458,  2465,  2472,\n+     2480,  2489,  2495,  2503,  2512,  2521,  2528,  2532,  2541,  2550,\n+     2558,  2572,  2580,  2589,  2598,  2604,  2624,  2662,  2677,  2698,\n+     2719,  2747,  2760,  2778,  2797,  2831,  2867,  2887,  2906,  2932,\n+     2956,  2969,  2987,  3007,  3024,  3039,  3051,  3069,  3082,  3090,\n+     3111,  3120,  3137,  3159,  3177,  3194,  3216,  3234,  3243,  3261,\n+     3280,  3288,  3295,  3304,  2639,  2647,  2739,  2810,  2820,  2849,\n+     2857,  2924,  2948,  3098,  3310,  3317,  3323,  3338,  3351,  3359,\n+     3372,  3381,  3389,  3394,  3401,  3410,  3419,  3428,  3434,  3457,\n+     3479,  3500,  3525,  3549,  3567,  3576,  3584,  3595,  3614,  3622,\n+     4343,  4352,  4361,  3631,  3645,  3656,  3678,  3690,  3714,  3725,\n+     3815,  3834,  3850,  3889,  3960,  3987,  4008,  4050,  4069,  4109,\n+     4140,  4173,  4199,  4253,  4281,  4327,  3702,  3739,  3749,  3765,\n+     3779,  3788,  3805,  3869,  3879,  3900,  3910,  3922,  3933,  3950,\n+     4023,  4035,  4089,  4099,  4130,  4163,  4189,  4214,  4226,  4241,\n+     4271,  4293,  4303,  4317,  4366,  4374,  4383,  4391,  4397,  4406,\n+     4414,  4423,  4431,  4439,  4449,  4458,  4482,  4500,  4506,  4515,\n+     4524,  4533,  4543,  4550,  4561,  4574,  4589,  4608,  4620,  4626,\n+     4634,  4640,  4645,  4657,  4674,  4682,  4778,  4787,  4690,  4738,\n+     4746,  4756,  4703,  4713,  4728,  4771,  4793,  4799,  4807,  4815,\n+     4824,  4833,  4839,  4848,  4856,  4873,  4882,  4891,  4897,  4966,\n+     4973,  4979,  5000,  5038,  5054,  5076,  5098,  5127,  5141,  5176,\n+     5213,  5234,  5254,  5281,  5306,  5320,  5328,  5344,  5359,  5367,\n+     5374,  4866,  4905,  4922,  4943,  5016,  5024,  5119,  5155,  5165,\n+     5195,  5203,  5273,  5298,  5389,  5398,  5405,  5414,  5423,  5459,\n+     5467,  5485,  5503,  5522,  5538,  5546,  5561,  5570,  5578,  5665,\n+     5674,  5682,  5711,  5760,  5772,  5779,  5431,  5439,  5447,  5454,\n+     5590,  5607,  5630,  5655,  5620,  5645,  5691,  5701,  5725,  5735,\n+     5750,  5788,  5810,  5800,  5818,  5826,  5835,  5843,  5850,  5855,\n+     5861,  5870,  5879,  5885,  5893,  5906,  5914,  5931,  5944,  5989,\n+     5998,  6011,  6020,  5955,  5965,  5979,  6029,  6038,  6057,  6065,\n+     6074,  6082,  6088,  6097,  6105,  6114,  6122,  6132,  6146,  6162,\n+     6182,  6202,  6210,  6219,  6254,  6269,  6286,  6307,  6318,  6333,\n+     6351,  6370,  6386,  6394,  6403,  6412,  6048,  6193,  6232,  6240,\n+     6297,  6379,  6419,  6428,  6436,  6442,  6459,  6466,  6476,  6541,\n+     6558,  6566,  6575,  6584,  6453,  6486,  6498,  6509,  6527,  6594,\n+     6602,  6611,  6619,  6628,  6637,  6645,  6650,  6659,  6668,  6675,\n+     6682,  6689,  6698,  6706,  6712,  6720,  6729,  6738,  6745,  6752,\n+     6761,  6770,  6776,  6783,  6801,  6808,  6815,  6823,  6832,  6841,\n+     6850,  6891,  6899,  6914,  6923,  6934,  6943,  6951,  6959,  6968,\n+     6973,  7012,  7147,  7155,  7164,  7223,  7231,  7240,  7245,  7263,\n+     7272,  7279,  7291,  6858,  6866,  6872,  6879,  6886,  6907,  6982,\n+     6990,  6996,  7006,  7021,  7027,  7034,  7100,  7124,  7132,  7138,\n+     7044,  7051,  7058,  7065,  7072,  7079,  7086,  7093,  7109,  7118,\n+     7172,  7178,  7187,  7193,  7200,  7205,  7216,  7256,  7300,  7308,\n+     7320,  7334,  7347,  7367,  7377,  7396,  7415,  7424,  7430,  7439,\n+     7457,  7468,  7476,  7486,  7493,  7501,  7512,  7520,  7530,  7541,\n+     7551,  7562,  7574,  7587,  7599,  7610,  7629,  7646,  7658,  7668,\n+     7680,  7690,  7706,  7721,  7768,  7777,  7786,  7795,  7804,  7813,\n+     7835,  7843,  7852,  7869,  7879,  7888,  7897,  7906,  7915,  7949,\n+     7958,  7967,  7976,  7985,  8031,  8041,  8050,  8059,  8068,  8077,\n+     8111,  8123,  8134,  8146,  8155,  8164,  8173,  8182,  8228,  8238,\n+     8246,  8255,  8264,  8273,  8289,  8312,  8329,  7360,  7389,  7406,\n+     7451,  7740,  7749,  7758,  7823,  7861,  7925,  7931,  7937,  7943,\n+     7995,  8001,  8007,  8013,  8019,  8025,  8087,  8093,  8099,  8105,\n+     8192,  8198,  8204,  8210,  8216,  8222,  8283,  8297,  8303,  8322,\n+     8339,  8345,  8353,  8359,  8368,  8428,  8437,  8445,  8454,  8463,\n+     8472,  8480,  8498,  8505,  8513,  8524,  8542,  8550,  8557,  8577,\n+     8583,  8730,  8749,  8772,  8785,  8823,  8841,  8851,  8860,  8870,\n+     8886,  8895,  8904,  8913,  8929,  8945,  8954,  8965,  8976,  8985,\n+     8994,  9012,  9071,  9089,  9104,  9119,  9131,  9145,  9154,  9172,\n+     9191,  9200,  9209,  9221,  9230,  8377,  8385,  8395,  8403,  8411,\n+     8419,  8491,  8533,  8568,  8592,  8598,  8697,  8703,  8713,  8721,\n+     8605,  8612,  8628,  8645,  8653,  8662,  8673,  8685,  8741,  8758,\n+     8766,  8781,  8795,  8802,  8813,  8833,  8879,  8923,  8939,  9006,\n+     9021,  9031,  9039,  9047,  9055,  9062,  9083,  9240,  9248,  9256,\n+     9266,  9276,  9284,  9300,  9311,  9319,  9328,  9334,  9370,  9376,\n+     9384,  9395,  9405,  9413,  9422,  9431,  9466,  9472,  9482,  9491,\n+     9528,  9535,  9545,  9555,  9563,  9572,  9627,  9645,  9658,  9676,\n+     9695,  9715,  9727,  9737,  9747,  9756,  9763,  9771,  9780,  9789,\n+     9805,  9814,  9823,  9834,  9841,  9294,  9342,  9352,  9360,  9441,\n+     9460,  9451,  9499,  9520,  9508,  9580,  9597,  9607,  9616,  9589,\n+     9799,  9853,  9862,  9870,  9879,  9889,  9898,  9913,  9923,  9929,\n+     9936,  9942,  9951,  9959,  9991, 10032, 10040, 10065, 10089, 10095,\n+    10103, 10111, 10120, 10137, 10146, 10167, 10177, 10188, 10197, 10211,\n+    10226, 10234, 10244, 10262, 10274, 10283, 10292, 10300, 10309, 10317,\n+    10323, 10329, 10336, 10344, 10350, 10359, 10374,  9908,  9967,  9975,\n+     9983,  9999, 10010, 10016, 10024, 10051, 10059, 10075, 10082, 10130,\n+    10155, 10162, 10255, 10390, 10407, 10413, 10423, 10433, 10442, 10452,\n+    10460, 10469, 10477, 10485, 10494, 10503, 10510, 10519, 10529, 10545,\n+    10557, 10566, 10576, 10585, 10595, 10605, 10615, 10625, 10635, 10644,\n+    10654, 10664, 10674, 10684, 10694, 10704, 10713, 10722, 10539, 10731,\n+    10745, 10754, 10769, 10776, 10785, 10793, 10799, 10806, 10901, 10909,\n+    10923, 10932, 10939, 10965, 10972, 10991, 11014, 11023, 11032, 11039,\n+    11047, 11069, 11191, 11207, 10739, 10764, 10814, 10820, 10844, 10828,\n+    10834, 10852, 10859, 10883, 10869, 10877, 10894, 10917, 10947, 10953,\n+    10959, 10982, 11000, 11008, 11057, 11063, 11075, 11082, 11090, 11098,\n+    11107, 11117, 11129, 11138, 11147, 11159, 11172, 11182, 11218, 11226,\n+    11236, 11243, 11253, 11262, 11286, 11294, 11302, 11322, 11332, 11342,\n+    11350, 11362, 11374, 11383, 11393, 11410, 11428, 11437, 11447, 11456,\n+    11466, 11475, 11485, 11272, 11280, 11314, 11495, 11504, 11524, 11531,\n+    11539, 11546, 11554, 11563, 11605, 11613, 11621, 11630, 11642, 11654,\n+    11662, 11670, 11678, 11776, 11783, 11791, 11800, 11807, 11816, 11825,\n+    11834, 11878, 11894, 11902, 11512, 11519, 11571, 11580, 11588, 11597,\n+    11686, 11695, 11713, 11721, 11705, 11729, 11737, 11747, 11757, 11767,\n+    11844, 11850, 11858, 11872, 11866, 11886, 11909, 11917, 11923, 11931,\n+    11939, 11948, 11957, 11966, 11974, 11989, 11998, 12004, 12012, 12021,\n+    12028, 12035, 12044, 11984, 12053, 12062, 12070, 12080, 12089, 12103,\n+    12111, 12120, 12132, 12142, 12151, 12174, 12181, 12189, 12257, 12291,\n+    12300, 12309, 12317, 12325, 12334, 12345, 12356, 12365, 12374, 12383,\n+    12389, 12395, 12403, 12420, 12431, 12443, 12451, 12766, 12776, 12786,\n+    12794, 12808, 12817, 12834, 12843, 12850, 12894, 12903, 12924, 12931,\n+    12950, 12973, 12982, 12991, 13000, 13009, 13026, 13048, 13062, 13080,\n+    13097, 13115, 13124, 13133, 13143, 13154, 13164, 13172, 13196, 13211,\n+    13220, 13232, 13249, 13256, 13265, 13275, 13284, 13291, 13313, 13319,\n+    13336, 13345, 13441, 13453, 13464, 13480, 12097, 12161, 12167, 12199,\n+    12214, 12221, 12228, 12235, 12242, 12250, 12207, 12266, 12274, 12282,\n+    12414, 12459, 12482, 12500, 12516, 12533, 12558, 12578, 12600, 12617,\n+    12623, 12647, 12473, 12552, 12631, 12637, 12655, 12662, 12686, 12704,\n+    12716, 12725, 12736, 12748, 12757, 12672, 12680, 12697, 12802, 12828,\n+    12858, 12866, 12877, 12886, 12915, 12941, 12959, 12967, 13181, 13190,\n+    13204, 13243, 13301, 13307, 13330, 13351, 13358, 13366, 13374, 13383,\n+    13392, 13401, 13411, 13420, 13429, 13435, 13491, 13500, 13507, 13515,\n+    13533, 13577, 13587, 13597, 13603, 13612, 13629, 13637, 13644, 13652,\n+    13682, 13713, 13721, 13729, 13739, 13749, 13758, 13764, 13773, 13783,\n+    13525, 13542, 13552, 13561, 13570, 13661, 13667, 13675, 13693, 13699,\n+    13707, 13790, 13801, 13809, 13818, 13838, 13852, 13871, 13880, 13900,\n+    13915, 13925, 13935, 13944, 13953, 13964, 14005, 14031, 14038, 14059,\n+    14067, 14076, 14085, 14106, 14114, 14120, 14129, 14226, 14234, 14243,\n+    14288, 14297, 14312, 14321, 14330, 14339, 14367, 14374, 14383, 14392,\n+    14401, 14409, 14491, 14500, 14524, 14532, 14541, 14627, 14665, 14676,\n+    14720, 14729, 14756, 14771, 14788, 14820, 14833, 14851, 14875, 14884,\n+    14893, 14904, 14915, 14969, 14989, 15043, 15051, 15060, 15068, 15094,\n+    15121, 15149, 15159, 15169, 15180, 15190, 15201, 15210, 15221, 15231,\n+    15242, 15264, 15274, 15288, 15300, 15309, 15319, 15337, 13830, 13892,\n+    13973, 13981, 13990, 13996, 14016, 14025, 14051, 14096, 14137, 14145,\n+    14154, 14171, 14181, 14190, 14199, 14209, 14164, 14220, 14252, 14280,\n+    14260, 14268, 14306, 14347, 14361, 14355, 14418, 14430, 14447, 14475,\n+    14455, 14463, 14485, 14509, 14518, 14549, 14597, 14558, 14566, 14576,\n+    14583, 14590, 14606, 14613, 14620, 14637, 14647, 14657, 14685, 14693,\n+    14703, 14711, 14740, 14748, 14782, 14797, 14805, 14813, 14861, 14869,\n+    14925, 14933, 14939, 14952, 14961, 14980, 14999, 15007, 15013, 15026,\n+    15035, 15087, 15114, 15128, 15134, 15142, 15253, 15330, 15347, 15353,\n+    15362, 15370, 15385, 15391, 15400, 15409, 15417, 15425, 15435, 15443,\n+    15452, 15460, 15467, 15476, 15483, 15492, 15498, 15506, 15515, 15524,\n+    15535, 15544, 15551, 15559, 15567, 15577, 15585, 15595, 15604, 15612,\n+    15621, 15630, 15712, 15720, 15729, 15737, 15746, 15765, 15772, 15380,\n+    15638, 15646, 15680, 15689, 15696, 15706, 15654, 15670, 15675, 15663,\n+    15758, 15781, 15827, 15833, 15841, 15849, 15859, 15867, 15878, 15886,\n+    15899, 15909, 15918, 15942, 15960, 15970, 16043, 16048, 16060, 16069,\n+    16077, 16303, 16312, 16318, 15790, 15806, 15814, 15821, 15797, 15894,\n+    15925, 15937, 15954, 15978, 15987, 15993, 16001, 16008, 16015, 16021,\n+    16027, 16035, 16085, 16091, 16098, 16106, 16190, 16206, 16213, 16221,\n+    16230, 16237, 16248, 16259, 16270, 16286, 16294, 16114, 16122, 16133,\n+    16145, 16152, 16164, 16173, 16182, 16200, 16279, 16328, 16336, 16344,\n+    16353, 16363, 16372, 16387, 16398, 16414, 16407, 16420, 16429, 16437,\n+    16447, 16456, 16464, 16474, 16483, 16492, 16504, 16533, 16541, 16628,\n+    16638, 16658, 16667, 16676, 16684, 16692, 16701, 16712, 16723, 16732,\n+    16741, 16750, 16756, 16762, 16770, 16781, 16798, 16806, 16839, 16847,\n+    16853, 16863, 16873, 16881, 16890, 16907, 16920, 16945, 16965, 16983,\n+    17002, 17023, 17043, 17062, 17081, 17088, 17104, 17113, 17122, 17129,\n+    17150, 17159, 17168, 17177, 17186, 17195, 17204, 17214, 17225, 17240,\n+    17252, 17261, 17271, 17280, 17287, 17293, 17310, 17320, 17330, 17361,\n+    17372, 16514, 16520, 16526, 16551, 16558, 16573, 16579, 16586, 16593,\n+    16600, 16607, 16615, 16622, 16566, 16649, 16792, 16816, 16824, 16833,\n+    16901, 16915, 16936, 17141, 17233, 17304, 17340, 17346, 17352, 17378,\n+    17387, 17396, 17503, 17525, 17534, 17544, 17562, 17569, 17575, 17585,\n+    17597, 17606, 17614, 17632, 17641, 17650, 17657, 17669, 17686, 17692,\n+    17712, 17796, 17805, 17822, 17832, 17844, 17852, 17861, 17887, 17896,\n+    17918, 17927, 17947, 17955, 17975, 17995, 18029, 18063, 18094, 18103,\n+    18112, 18122, 18132, 18142, 18158, 18176, 18190, 18198, 18343, 18421,\n+    18428, 18436, 18623, 18632, 18642, 18660, 18670, 17404, 17410, 17417,\n+    17425, 17433, 17448, 17455, 17462, 17470, 17479, 17490, 17498, 17441,\n+    17513, 17519, 17555, 17624, 17702, 17707, 17721, 17729, 17743, 17757,\n+    17771, 17778, 17787, 17737, 17751, 17765, 17870, 17878, 17903, 17911,\n+    17939, 17966, 17986, 18006, 18012, 18022, 18040, 18046, 18056, 18072,\n+    18080, 18088, 18152, 18207, 18213, 18221, 18237, 18246, 18253, 18260,\n+    18269, 18278, 18319, 18327, 18335, 18229, 18288, 18303, 18297, 18313,\n+    18353, 18364, 18376, 18383, 18395, 18404, 18413, 18445, 18450, 18455,\n+    18460, 18466, 18474, 18483, 18499, 18508, 18517, 18526, 18535, 18542,\n+    18549, 18558, 18599, 18607, 18615, 18491, 18568, 18583, 18577, 18593,\n+    18653, 18678, 18688, 18694, 18702, 18711, 18720, 18726, 18734, 18744,\n+    18752, 18762, 18775, 18797, 18812, 18824, 18834, 18843, 18853, 18861,\n+    18869, 18900, 18908, 18916, 18958, 18966, 18976, 18985, 19051, 19061,\n+    19069, 19081, 19092, 19101, 19112, 19124, 19133, 19140, 19148, 19157,\n+    19166, 19186, 18785, 18792, 18879, 18894, 18887, 18925, 18933, 18941,\n+    18950, 18999, 19008, 19026, 19032, 19019, 19044, 19207, 19215, 19223,\n+    19232, 19240, 19248, 19257, 19265, 19271, 19280, 19289, 19298, 19308,\n+    19316, 19325, 19334, 19343, 19352, 19371, 19381, 19390, 19398, 19404,\n+    19412, 19421, 19432, 19447, 19464, 19482, 19491, 19512, 19526, 19545,\n+    19555, 19563, 19572, 19581, 19590, 19599, 19615, 19624, 19631, 19364,\n+    19500, 19505, 19538, 19609, 19642, 19650, 19666, 19675, 19685, 19698,\n+    19709, 19723, 19732, 19740, 19753, 19769, 19780, 19810, 19840, 19851,\n+    19870, 19890, 19896, 19905, 19929, 19939, 19947, 19953, 19961, 19970,\n+    19982, 19994, 20003, 20012, 20021, 20030, 20043, 20056, 20069, 20082,\n+    19660, 19763, 19801, 19831, 19914, 19922, 20093, 20101, 20111, 20128,\n+    20138, 20146, 20155, 20161, 20178, 20122, 20169, 20187, 20195, 20204,\n+    20212, 20221, 20229, 20238, 20247, 20252, 20261, 20270, 20278, 20286,\n+    20295, 20304, 20314, 20324, 20333, 20342, 20351, 20361, 20371, 20380,\n+    20388, 20398, 20407, 20414, 20422, 20428, 20434, 20442, 20449, 20458,\n+    20467, 20474, 20481, 20490, 20499, 20505, 20512, 20522, 20529, 20537,\n+    20544, 20555, 20564, 20573, 20580\n+};\n+\n+static const unsigned char htmlEntStrings[20588] = {\n+    132, 'E', 'l', 'i', 'g',   2, 195, 134, 130, 'M', 'P',   1, '&', 133, 'a',\n+    'c', 'u', 't', 'e',   2, 195, 129,   5, 'b', 'r', 'e', 'v', 'e',   2, 196,\n+    130, 132, 'c', 'i', 'r', 'c',   2, 195, 130,   2, 'c', 'y',   2, 208, 144,\n+      2, 'f', 'r',   4, 240, 157, 148, 132, 133, 'g', 'r', 'a', 'v', 'e',   2,\n+    195, 128,   4, 'l', 'p', 'h', 'a',   2, 206, 145,   4, 'm', 'a', 'c', 'r',\n+      2, 196, 128,   2, 'n', 'd',   3, 226, 169, 147,   4, 'o', 'g', 'o', 'n',\n+      2, 196, 132,   3, 'o', 'p', 'f',   4, 240, 157, 148, 184,  12, 'p', 'p',\n+    'l', 'y', 'F', 'u', 'n', 'c', 't', 'i', 'o', 'n',   3, 226, 129, 161, 132,\n+    'r', 'i', 'n', 'g',   2, 195, 133,   3, 's', 'c', 'r',   4, 240, 157, 146,\n+    156,   5, 's', 's', 'i', 'g', 'n',   3, 226, 137, 148, 133, 't', 'i', 'l',\n+    'd', 'e',   2, 195, 131, 131, 'u', 'm', 'l',   2, 195, 132,   8, 'a', 'c',\n+    'k', 's', 'l', 'a', 's', 'h',   3, 226, 136, 150,   3, 'a', 'r', 'v',   3,\n+    226, 171, 167,   5, 'a', 'r', 'w', 'e', 'd',   3, 226, 140, 134,   2, 'c',\n+    'y',   2, 208, 145,   6, 'e', 'c', 'a', 'u', 's', 'e',   3, 226, 136, 181,\n+      9, 'e', 'r', 'n', 'o', 'u', 'l', 'l', 'i', 's',   3, 226, 132, 172,   3,\n+    'e', 't', 'a',   2, 206, 146,   2, 'f', 'r',   4, 240, 157, 148, 133,   3,\n+    'o', 'p', 'f',   4, 240, 157, 148, 185,   4, 'r', 'e', 'v', 'e',   2, 203,\n+    152,   3, 's', 'c', 'r',   3, 226, 132, 172,   5, 'u', 'm', 'p', 'e', 'q',\n+      3, 226, 137, 142,   3, 'H', 'c', 'y',   2, 208, 167, 131, 'O', 'P', 'Y',\n+      2, 194, 169,   5, 'a', 'c', 'u', 't', 'e',   2, 196, 134,  66, 'a', 'p',\n+     28,   1,   3, 226, 139, 146,  17, 'i', 't', 'a', 'l', 'D', 'i', 'f', 'f',\n+    'e', 'r', 'e', 'n', 't', 'i', 'a', 'l', 'D',   3, 226, 133, 133,   6, 'a',\n+    'y', 'l', 'e', 'y', 's',   3, 226, 132, 173,   5, 'c', 'a', 'r', 'o', 'n',\n+      2, 196, 140, 133, 'c', 'e', 'd', 'i', 'l',   2, 195, 135,   4, 'c', 'i',\n+    'r', 'c',   2, 196, 136,   6, 'c', 'o', 'n', 'i', 'n', 't',   3, 226, 136,\n+    176,   3, 'd', 'o', 't',   2, 196, 138,   6, 'e', 'd', 'i', 'l', 'l', 'a',\n+      2, 194, 184,   8, 'e', 'n', 't', 'e', 'r', 'D', 'o', 't',   2, 194, 183,\n+      2, 'f', 'r',   3, 226, 132, 173,   2, 'h', 'i',   2, 206, 167,   8, 'i',\n+    'r', 'c', 'l', 'e', 'D', 'o', 't',   3, 226, 138, 153,  10, 'i', 'r', 'c',\n+    'l', 'e', 'M', 'i', 'n', 'u', 's',   3, 226, 138, 150,   9, 'i', 'r', 'c',\n+    'l', 'e', 'P', 'l', 'u', 's',   3, 226, 138, 149,  10, 'i', 'r', 'c', 'l',\n+    'e', 'T', 'i', 'm', 'e', 's',   3, 226, 138, 151,  23, 'l', 'o', 'c', 'k',\n+    'w', 'i', 's', 'e', 'C', 'o', 'n', 't', 'o', 'u', 'r', 'I', 'n', 't', 'e',\n+    'g', 'r', 'a', 'l',   3, 226, 136, 178,  20, 'l', 'o', 's', 'e', 'C', 'u',\n+    'r', 'l', 'y', 'D', 'o', 'u', 'b', 'l', 'e', 'Q', 'u', 'o', 't', 'e',   3,\n+    226, 128, 157,  14, 'l', 'o', 's', 'e', 'C', 'u', 'r', 'l', 'y', 'Q', 'u',\n+    'o', 't', 'e',   3, 226, 128, 153,  68, 'o', 'l', 'o', 'n',  11,   1,   3,\n+    226, 136, 183,   1, 'e',   3, 226, 169, 180,   8, 'o', 'n', 'g', 'r', 'u',\n+    'e', 'n', 't',   3, 226, 137, 161,   5, 'o', 'n', 'i', 'n', 't',   3, 226,\n+    136, 175,  14, 'o', 'n', 't', 'o', 'u', 'r', 'I', 'n', 't', 'e', 'g', 'r',\n+    'a', 'l',   3, 226, 136, 174,   3, 'o', 'p', 'f',   3, 226, 132, 130,   8,\n+    'o', 'p', 'r', 'o', 'd', 'u', 'c', 't',   3, 226, 136, 144,  30, 'o', 'u',\n+    'n', 't', 'e', 'r', 'C', 'l', 'o', 'c', 'k', 'w', 'i', 's', 'e', 'C', 'o',\n+    'n', 't', 'o', 'u', 'r', 'I', 'n', 't', 'e', 'g', 'r', 'a', 'l',   3, 226,\n+    136, 179,   4, 'r', 'o', 's', 's',   3, 226, 168, 175,   3, 's', 'c', 'r',\n+      4, 240, 157, 146, 158,  66, 'u', 'p',   3,   1,   3, 226, 139, 147,   3,\n+    'C', 'a', 'p',   3, 226, 137, 141,  65, 'D',  45,   1,   3, 226, 133, 133,\n+      6, 'o', 't', 'r', 'a', 'h', 'd',   3, 226, 164, 145,   3, 'J', 'c', 'y',\n+      2, 208, 130,   3, 'S', 'c', 'y',   2, 208, 133,   3, 'Z', 'c', 'y',   2,\n+    208, 143,   5, 'a', 'g', 'g', 'e', 'r',   3, 226, 128, 161,   3, 'a', 'r',\n+    'r',   3, 226, 134, 161,   4, 'a', 's', 'h', 'v',   3, 226, 171, 164,   5,\n+    'c', 'a', 'r', 'o', 'n',   2, 196, 142,   2, 'c', 'y',   2, 208, 148,  66,\n+    'e', 'l',  37,   1,   3, 226, 136, 135,   2, 't', 'a',   2, 206, 148,   2,\n+    'f', 'r',   4, 240, 157, 148, 135,  15, 'i', 'a', 'c', 'r', 'i', 't', 'i',\n+    'c', 'a', 'l', 'A', 'c', 'u', 't', 'e',   2, 194, 180,  13, 'i', 'a', 'c',\n+    'r', 'i', 't', 'i', 'c', 'a', 'l', 'D', 'o', 't',   2, 203, 153,  21, 'i',\n+    'a', 'c', 'r', 'i', 't', 'i', 'c', 'a', 'l', 'D', 'o', 'u', 'b', 'l', 'e',\n+    'A', 'c', 'u', 't', 'e',   2, 203, 157,  15, 'i', 'a', 'c', 'r', 'i', 't',\n+    'i', 'c', 'a', 'l', 'G', 'r', 'a', 'v', 'e',   1, '`',  15, 'i', 'a', 'c',\n+    'r', 'i', 't', 'i', 'c', 'a', 'l', 'T', 'i', 'l', 'd', 'e',   2, 203, 156,\n+      6, 'i', 'a', 'm', 'o', 'n', 'd',   3, 226, 139, 132,  12, 'i', 'f', 'f',\n+    'e', 'r', 'e', 'n', 't', 'i', 'a', 'l', 'D',   3, 226, 133, 134,   3, 'o',\n+    'p', 'f',   4, 240, 157, 148, 187,  66, 'o', 't',  28,   2,   2, 194, 168,\n+      3, 'D', 'o', 't',   3, 226, 131, 156,   5, 'E', 'q', 'u', 'a', 'l',   3,\n+    226, 137, 144,  20, 'o', 'u', 'b', 'l', 'e', 'C', 'o', 'n', 't', 'o', 'u',\n+    'r', 'I', 'n', 't', 'e', 'g', 'r', 'a', 'l',   3, 226, 136, 175,   8, 'o',\n+    'u', 'b', 'l', 'e', 'D', 'o', 't',   2, 194, 168,  14, 'o', 'u', 'b', 'l',\n+    'e', 'D', 'o', 'w', 'n', 'A', 'r', 'r', 'o', 'w',   3, 226, 135, 147,  14,\n+    'o', 'u', 'b', 'l', 'e', 'L', 'e', 'f', 't', 'A', 'r', 'r', 'o', 'w',   3,\n+    226, 135, 144,  19, 'o', 'u', 'b', 'l', 'e', 'L', 'e', 'f', 't', 'R', 'i',\n+    'g', 'h', 't', 'A', 'r', 'r', 'o', 'w',   3, 226, 135, 148,  12, 'o', 'u',\n+    'b', 'l', 'e', 'L', 'e', 'f', 't', 'T', 'e', 'e',   3, 226, 171, 164,  18,\n+    'o', 'u', 'b', 'l', 'e', 'L', 'o', 'n', 'g', 'L', 'e', 'f', 't', 'A', 'r',\n+    'r', 'o', 'w',   3, 226, 159, 184,  23, 'o', 'u', 'b', 'l', 'e', 'L', 'o',\n+    'n', 'g', 'L', 'e', 'f', 't', 'R', 'i', 'g', 'h', 't', 'A', 'r', 'r', 'o',\n+    'w',   3, 226, 159, 186,  19, 'o', 'u', 'b', 'l', 'e', 'L', 'o', 'n', 'g',\n+    'R', 'i', 'g', 'h', 't', 'A', 'r', 'r', 'o', 'w',   3, 226, 159, 185,  15,\n+    'o', 'u', 'b', 'l', 'e', 'R', 'i', 'g', 'h', 't', 'A', 'r', 'r', 'o', 'w',\n+      3, 226, 135, 146,  13, 'o', 'u', 'b', 'l', 'e', 'R', 'i', 'g', 'h', 't',\n+    'T', 'e', 'e',   3, 226, 138, 168,  12, 'o', 'u', 'b', 'l', 'e', 'U', 'p',\n+    'A', 'r', 'r', 'o', 'w',   3, 226, 135, 145,  16, 'o', 'u', 'b', 'l', 'e',\n+    'U', 'p', 'D', 'o', 'w', 'n', 'A', 'r', 'r', 'o', 'w',   3, 226, 135, 149,\n+     16, 'o', 'u', 'b', 'l', 'e', 'V', 'e', 'r', 't', 'i', 'c', 'a', 'l', 'B',\n+    'a', 'r',   3, 226, 136, 165,  72, 'o', 'w', 'n', 'A', 'r', 'r', 'o', 'w',\n+     15,   2,   3, 226, 134, 147,   3, 'B', 'a', 'r',   3, 226, 164, 147,   7,\n+    'U', 'p', 'A', 'r', 'r', 'o', 'w',   3, 226, 135, 181,   8, 'o', 'w', 'n',\n+    'B', 'r', 'e', 'v', 'e',   2, 204, 145,  18, 'o', 'w', 'n', 'L', 'e', 'f',\n+    't', 'R', 'i', 'g', 'h', 't', 'V', 'e', 'c', 't', 'o', 'r',   3, 226, 165,\n+    144,  16, 'o', 'w', 'n', 'L', 'e', 'f', 't', 'T', 'e', 'e', 'V', 'e', 'c',\n+    't', 'o', 'r',   3, 226, 165, 158,  77, 'o', 'w', 'n', 'L', 'e', 'f', 't',\n+    'V', 'e', 'c', 't', 'o', 'r',  13,   1,   3, 226, 134, 189,   3, 'B', 'a',\n+    'r',   3, 226, 165, 150,  17, 'o', 'w', 'n', 'R', 'i', 'g', 'h', 't', 'T',\n+    'e', 'e', 'V', 'e', 'c', 't', 'o', 'r',   3, 226, 165, 159,  78, 'o', 'w',\n+    'n', 'R', 'i', 'g', 'h', 't', 'V', 'e', 'c', 't', 'o', 'r',  12,   1,   3,\n+    226, 135, 129,   3, 'B', 'a', 'r',   3, 226, 165, 151,  70, 'o', 'w', 'n',\n+    'T', 'e', 'e',  12,   1,   3, 226, 138, 164,   5, 'A', 'r', 'r', 'o', 'w',\n+      3, 226, 134, 167,   8, 'o', 'w', 'n', 'a', 'r', 'r', 'o', 'w',   3, 226,\n+    135, 147,   3, 's', 'c', 'r',   4, 240, 157, 146, 159,   5, 's', 't', 'r',\n+    'o', 'k',   2, 196, 144,   2, 'N', 'G',   2, 197, 138, 130, 'T', 'H',   2,\n+    195, 144, 133, 'a', 'c', 'u', 't', 'e',   2, 195, 137,   5, 'c', 'a', 'r',\n+    'o', 'n',   2, 196, 154, 132, 'c', 'i', 'r', 'c',   2, 195, 138,   2, 'c',\n+    'y',   2, 208, 173,   3, 'd', 'o', 't',   2, 196, 150,   2, 'f', 'r',   4,\n+    240, 157, 148, 136, 133, 'g', 'r', 'a', 'v', 'e',   2, 195, 136,   6, 'l',\n+    'e', 'm', 'e', 'n', 't',   3, 226, 136, 136,   4, 'm', 'a', 'c', 'r',   2,\n+    196, 146,  15, 'm', 'p', 't', 'y', 'S', 'm', 'a', 'l', 'l', 'S', 'q', 'u',\n+    'a', 'r', 'e',   3, 226, 151, 187,  19, 'm', 'p', 't', 'y', 'V', 'e', 'r',\n+    'y', 'S', 'm', 'a', 'l', 'l', 'S', 'q', 'u', 'a', 'r', 'e',   3, 226, 150,\n+    171,   4, 'o', 'g', 'o', 'n',   2, 196, 152,   3, 'o', 'p', 'f',   4, 240,\n+    157, 148, 188,   6, 'p', 's', 'i', 'l', 'o', 'n',   2, 206, 149,  68, 'q',\n+    'u', 'a', 'l',   8,   1,   3, 226, 169, 181,   5, 'T', 'i', 'l', 'd', 'e',\n+      3, 226, 137, 130,  10, 'q', 'u', 'i', 'l', 'i', 'b', 'r', 'i', 'u', 'm',\n+      3, 226, 135, 140,   3, 's', 'c', 'r',   3, 226, 132, 176,   3, 's', 'i',\n+    'm',   3, 226, 169, 179,   2, 't', 'a',   2, 206, 151, 131, 'u', 'm', 'l',\n+      2, 195, 139,   5, 'x', 'i', 's', 't', 's',   3, 226, 136, 131,  11, 'x',\n+    'p', 'o', 'n', 'e', 'n', 't', 'i', 'a', 'l', 'E',   3, 226, 133, 135,   2,\n+    'c', 'y',   2, 208, 164,   2, 'f', 'r',   4, 240, 157, 148, 137,  16, 'i',\n+    'l', 'l', 'e', 'd', 'S', 'm', 'a', 'l', 'l', 'S', 'q', 'u', 'a', 'r', 'e',\n+      3, 226, 151, 188,  20, 'i', 'l', 'l', 'e', 'd', 'V', 'e', 'r', 'y', 'S',\n+    'm', 'a', 'l', 'l', 'S', 'q', 'u', 'a', 'r', 'e',   3, 226, 150, 170,   3,\n+    'o', 'p', 'f',   4, 240, 157, 148, 189,   5, 'o', 'r', 'A', 'l', 'l',   3,\n+    226, 136, 128,   9, 'o', 'u', 'r', 'i', 'e', 'r', 't', 'r', 'f',   3, 226,\n+    132, 177,   3, 's', 'c', 'r',   3, 226, 132, 177,   3, 'J', 'c', 'y',   2,\n+    208, 131, 129, 'T',   1, '>',  68, 'a', 'm', 'm', 'a',  17,   1,   2, 206,\n+    147,   1, 'd',   2, 207, 156,   5, 'b', 'r', 'e', 'v', 'e',   2, 196, 158,\n+      5, 'c', 'e', 'd', 'i', 'l',   2, 196, 162,   4, 'c', 'i', 'r', 'c',   2,\n+    196, 156,   2, 'c', 'y',   2, 208, 147,   3, 'd', 'o', 't',   2, 196, 160,\n+      2, 'f', 'r',   4, 240, 157, 148, 138,   1, 'g',   3, 226, 139, 153,   3,\n+    'o', 'p', 'f',   4, 240, 157, 148, 190,  75, 'r', 'e', 'a', 't', 'e', 'r',\n+    'E', 'q', 'u', 'a', 'l',   9,   1,   3, 226, 137, 165,   4, 'L', 'e', 's',\n+    's',   3, 226, 139, 155,  15, 'r', 'e', 'a', 't', 'e', 'r', 'F', 'u', 'l',\n+    'l', 'E', 'q', 'u', 'a', 'l',   3, 226, 137, 167,  13, 'r', 'e', 'a', 't',\n+    'e', 'r', 'G', 'r', 'e', 'a', 't', 'e', 'r',   3, 226, 170, 162,  10, 'r',\n+    'e', 'a', 't', 'e', 'r', 'L', 'e', 's', 's',   3, 226, 137, 183,  16, 'r',\n+    'e', 'a', 't', 'e', 'r', 'S', 'l', 'a', 'n', 't', 'E', 'q', 'u', 'a', 'l',\n+      3, 226, 169, 190,  11, 'r', 'e', 'a', 't', 'e', 'r', 'T', 'i', 'l', 'd',\n+    'e',   3, 226, 137, 179,   3, 's', 'c', 'r',   4, 240, 157, 146, 162,   1,\n+    't',   3, 226, 137, 171,   5, 'A', 'R', 'D', 'c', 'y',   2, 208, 170,   4,\n+    'a', 'c', 'e', 'k',   2, 203, 135,   2, 'a', 't',   1, '^',   4, 'c', 'i',\n+    'r', 'c',   2, 196, 164,   2, 'f', 'r',   3, 226, 132, 140,  11, 'i', 'l',\n+    'b', 'e', 'r', 't', 'S', 'p', 'a', 'c', 'e',   3, 226, 132, 139,   3, 'o',\n+    'p', 'f',   3, 226, 132, 141,  13, 'o', 'r', 'i', 'z', 'o', 'n', 't', 'a',\n+    'l', 'L', 'i', 'n', 'e',   3, 226, 148, 128,   3, 's', 'c', 'r',   3, 226,\n+    132, 139,   5, 's', 't', 'r', 'o', 'k',   2, 196, 166,  11, 'u', 'm', 'p',\n+    'D', 'o', 'w', 'n', 'H', 'u', 'm', 'p',   3, 226, 137, 142,   8, 'u', 'm',\n+    'p', 'E', 'q', 'u', 'a', 'l',   3, 226, 137, 143,   3, 'E', 'c', 'y',   2,\n+    208, 149,   4, 'J', 'l', 'i', 'g',   2, 196, 178,   3, 'O', 'c', 'y',   2,\n+    208, 129, 133, 'a', 'c', 'u', 't', 'e',   2, 195, 141, 132, 'c', 'i', 'r',\n+    'c',   2, 195, 142,   2, 'c', 'y',   2, 208, 152,   3, 'd', 'o', 't',   2,\n+    196, 176,   2, 'f', 'r',   3, 226, 132, 145, 133, 'g', 'r', 'a', 'v', 'e',\n+      2, 195, 140,  65, 'm',  11,   3,   3, 226, 132, 145,   3, 'a', 'c', 'r',\n+      2, 196, 170,   8, 'a', 'g', 'i', 'n', 'a', 'r', 'y', 'I',   3, 226, 133,\n+    136,   5, 'p', 'l', 'i', 'e', 's',   3, 226, 135, 146,  66, 'n', 't',  13,\n+      2,   3, 226, 136, 172,   5, 'e', 'g', 'r', 'a', 'l',   3, 226, 136, 171,\n+      9, 'e', 'r', 's', 'e', 'c', 't', 'i', 'o', 'n',   3, 226, 139, 130,  13,\n+    'n', 'v', 'i', 's', 'i', 'b', 'l', 'e', 'C', 'o', 'm', 'm', 'a',   3, 226,\n+    129, 163,  13, 'n', 'v', 'i', 's', 'i', 'b', 'l', 'e', 'T', 'i', 'm', 'e',\n+    's',   3, 226, 129, 162,   4, 'o', 'g', 'o', 'n',   2, 196, 174,   3, 'o',\n+    'p', 'f',   4, 240, 157, 149, 128,   3, 'o', 't', 'a',   2, 206, 153,   3,\n+    's', 'c', 'r',   3, 226, 132, 144,   5, 't', 'i', 'l', 'd', 'e',   2, 196,\n+    168,   4, 'u', 'k', 'c', 'y',   2, 208, 134, 131, 'u', 'm', 'l',   2, 195,\n+    143,   4, 'c', 'i', 'r', 'c',   2, 196, 180,   2, 'c', 'y',   2, 208, 153,\n+      2, 'f', 'r',   4, 240, 157, 148, 141,   3, 'o', 'p', 'f',   4, 240, 157,\n+    149, 129,   3, 's', 'c', 'r',   4, 240, 157, 146, 165,   5, 's', 'e', 'r',\n+    'c', 'y',   2, 208, 136,   4, 'u', 'k', 'c', 'y',   2, 208, 132,   3, 'H',\n+    'c', 'y',   2, 208, 165,   3, 'J', 'c', 'y',   2, 208, 140,   4, 'a', 'p',\n+    'p', 'a',   2, 206, 154,   5, 'c', 'e', 'd', 'i', 'l',   2, 196, 182,   2,\n+    'c', 'y',   2, 208, 154,   2, 'f', 'r',   4, 240, 157, 148, 142,   3, 'o',\n+    'p', 'f',   4, 240, 157, 149, 130,   3, 's', 'c', 'r',   4, 240, 157, 146,\n+    166,   3, 'J', 'c', 'y',   2, 208, 137, 129, 'T',   1, '<',   5, 'a', 'c',\n+    'u', 't', 'e',   2, 196, 185,   5, 'a', 'm', 'b', 'd', 'a',   2, 206, 155,\n+      3, 'a', 'n', 'g',   3, 226, 159, 170,   9, 'a', 'p', 'l', 'a', 'c', 'e',\n+    't', 'r', 'f',   3, 226, 132, 146,   3, 'a', 'r', 'r',   3, 226, 134, 158,\n+      5, 'c', 'a', 'r', 'o', 'n',   2, 196, 189,   5, 'c', 'e', 'd', 'i', 'l',\n+      2, 196, 187,   2, 'c', 'y',   2, 208, 155,  15, 'e', 'f', 't', 'A', 'n',\n+    'g', 'l', 'e', 'B', 'r', 'a', 'c', 'k', 'e', 't',   3, 226, 159, 168,  72,\n+    'e', 'f', 't', 'A', 'r', 'r', 'o', 'w',  38,   2,   3, 226, 134, 144,   3,\n+    'B', 'a', 'r',   3, 226, 135, 164,  10, 'R', 'i', 'g', 'h', 't', 'A', 'r',\n+    'r', 'o', 'w',   3, 226, 135, 134,  10, 'e', 'f', 't', 'C', 'e', 'i', 'l',\n+    'i', 'n', 'g',   3, 226, 140, 136,  16, 'e', 'f', 't', 'D', 'o', 'u', 'b',\n+    'l', 'e', 'B', 'r', 'a', 'c', 'k', 'e', 't',   3, 226, 159, 166,  16, 'e',\n+    'f', 't', 'D', 'o', 'w', 'n', 'T', 'e', 'e', 'V', 'e', 'c', 't', 'o', 'r',\n+      3, 226, 165, 161,  77, 'e', 'f', 't', 'D', 'o', 'w', 'n', 'V', 'e', 'c',\n+    't', 'o', 'r',  36,   1,   3, 226, 135, 131,   3, 'B', 'a', 'r',   3, 226,\n+    165, 153,   8, 'e', 'f', 't', 'F', 'l', 'o', 'o', 'r',   3, 226, 140, 138,\n+     13, 'e', 'f', 't', 'R', 'i', 'g', 'h', 't', 'A', 'r', 'r', 'o', 'w',   3,\n+    226, 134, 148,  14, 'e', 'f', 't', 'R', 'i', 'g', 'h', 't', 'V', 'e', 'c',\n+    't', 'o', 'r',   3, 226, 165, 142,  70, 'e', 'f', 't', 'T', 'e', 'e',  33,\n+      2,   3, 226, 138, 163,   5, 'A', 'r', 'r', 'o', 'w',   3, 226, 134, 164,\n+      6, 'V', 'e', 'c', 't', 'o', 'r',   3, 226, 165, 154,  75, 'e', 'f', 't',\n+    'T', 'r', 'i', 'a', 'n', 'g', 'l', 'e',  34,   2,   3, 226, 138, 178,   3,\n+    'B', 'a', 'r',   3, 226, 167, 143,   5, 'E', 'q', 'u', 'a', 'l',   3, 226,\n+    138, 180,  15, 'e', 'f', 't', 'U', 'p', 'D', 'o', 'w', 'n', 'V', 'e', 'c',\n+    't', 'o', 'r',   3, 226, 165, 145,  14, 'e', 'f', 't', 'U', 'p', 'T', 'e',\n+    'e', 'V', 'e', 'c', 't', 'o', 'r',   3, 226, 165, 160,  75, 'e', 'f', 't',\n+    'U', 'p', 'V', 'e', 'c', 't', 'o', 'r',  33,   1,   3, 226, 134, 191,   3,\n+    'B', 'a', 'r',   3, 226, 165, 152,  73, 'e', 'f', 't', 'V', 'e', 'c', 't',\n+    'o', 'r',  33,   1,   3, 226, 134, 188,   3, 'B', 'a', 'r',   3, 226, 165,\n+    146,   8, 'e', 'f', 't', 'a', 'r', 'r', 'o', 'w',   3, 226, 135, 144,  13,\n+    'e', 'f', 't', 'r', 'i', 'g', 'h', 't', 'a', 'r', 'r', 'o', 'w',   3, 226,\n+    135, 148,  15, 'e', 's', 's', 'E', 'q', 'u', 'a', 'l', 'G', 'r', 'e', 'a',\n+    't', 'e', 'r',   3, 226, 139, 154,  12, 'e', 's', 's', 'F', 'u', 'l', 'l',\n+    'E', 'q', 'u', 'a', 'l',   3, 226, 137, 166,  10, 'e', 's', 's', 'G', 'r',\n+    'e', 'a', 't', 'e', 'r',   3, 226, 137, 182,   7, 'e', 's', 's', 'L', 'e',\n+    's', 's',   3, 226, 170, 161,  13, 'e', 's', 's', 'S', 'l', 'a', 'n', 't',\n+    'E', 'q', 'u', 'a', 'l',   3, 226, 169, 189,   8, 'e', 's', 's', 'T', 'i',\n+    'l', 'd', 'e',   3, 226, 137, 178,   2, 'f', 'r',   4, 240, 157, 148, 143,\n+     65, 'l',  24,   1,   3, 226, 139, 152,   8, 'e', 'f', 't', 'a', 'r', 'r',\n+    'o', 'w',   3, 226, 135, 154,   5, 'm', 'i', 'd', 'o', 't',   2, 196, 191,\n+     12, 'o', 'n', 'g', 'L', 'e', 'f', 't', 'A', 'r', 'r', 'o', 'w',   3, 226,\n+    159, 181,  17, 'o', 'n', 'g', 'L', 'e', 'f', 't', 'R', 'i', 'g', 'h', 't',\n+    'A', 'r', 'r', 'o', 'w',   3, 226, 159, 183,  13, 'o', 'n', 'g', 'R', 'i',\n+    'g', 'h', 't', 'A', 'r', 'r', 'o', 'w',   3, 226, 159, 182,  12, 'o', 'n',\n+    'g', 'l', 'e', 'f', 't', 'a', 'r', 'r', 'o', 'w',   3, 226, 159, 184,  17,\n+    'o', 'n', 'g', 'l', 'e', 'f', 't', 'r', 'i', 'g', 'h', 't', 'a', 'r', 'r',\n+    'o', 'w',   3, 226, 159, 186,  13, 'o', 'n', 'g', 'r', 'i', 'g', 'h', 't',\n+    'a', 'r', 'r', 'o', 'w',   3, 226, 159, 185,   3, 'o', 'p', 'f',   4, 240,\n+    157, 149, 131,  13, 'o', 'w', 'e', 'r', 'L', 'e', 'f', 't', 'A', 'r', 'r',\n+    'o', 'w',   3, 226, 134, 153,  14, 'o', 'w', 'e', 'r', 'R', 'i', 'g', 'h',\n+    't', 'A', 'r', 'r', 'o', 'w',   3, 226, 134, 152,   3, 's', 'c', 'r',   3,\n+    226, 132, 146,   2, 's', 'h',   3, 226, 134, 176,   5, 's', 't', 'r', 'o',\n+    'k',   2, 197, 129,   1, 't',   3, 226, 137, 170,   2, 'a', 'p',   3, 226,\n+    164, 133,   2, 'c', 'y',   2, 208, 156,  10, 'e', 'd', 'i', 'u', 'm', 'S',\n+    'p', 'a', 'c', 'e',   3, 226, 129, 159,   8, 'e', 'l', 'l', 'i', 'n', 't',\n+    'r', 'f',   3, 226, 132, 179,   2, 'f', 'r',   4, 240, 157, 148, 144,   8,\n+    'i', 'n', 'u', 's', 'P', 'l', 'u', 's',   3, 226, 136, 147,   3, 'o', 'p',\n+    'f',   4, 240, 157, 149, 132,   3, 's', 'c', 'r',   3, 226, 132, 179,   1,\n+    'u',   2, 206, 156,   3, 'J', 'c', 'y',   2, 208, 138,   5, 'a', 'c', 'u',\n+    't', 'e',   2, 197, 131,   5, 'c', 'a', 'r', 'o', 'n',   2, 197, 135,   5,\n+    'c', 'e', 'd', 'i', 'l',   2, 197, 133,   2, 'c', 'y',   2, 208, 157,  18,\n+    'e', 'g', 'a', 't', 'i', 'v', 'e', 'M', 'e', 'd', 'i', 'u', 'm', 'S', 'p',\n+    'a', 'c', 'e',   3, 226, 128, 139,  17, 'e', 'g', 'a', 't', 'i', 'v', 'e',\n+    'T', 'h', 'i', 'c', 'k', 'S', 'p', 'a', 'c', 'e',   3, 226, 128, 139,  16,\n+    'e', 'g', 'a', 't', 'i', 'v', 'e', 'T', 'h', 'i', 'n', 'S', 'p', 'a', 'c',\n+    'e',   3, 226, 128, 139,  20, 'e', 'g', 'a', 't', 'i', 'v', 'e', 'V', 'e',\n+    'r', 'y', 'T', 'h', 'i', 'n', 'S', 'p', 'a', 'c', 'e',   3, 226, 128, 139,\n+     19, 'e', 's', 't', 'e', 'd', 'G', 'r', 'e', 'a', 't', 'e', 'r', 'G', 'r',\n+    'e', 'a', 't', 'e', 'r',   3, 226, 137, 171,  13, 'e', 's', 't', 'e', 'd',\n+    'L', 'e', 's', 's', 'L', 'e', 's', 's',   3, 226, 137, 170,   6, 'e', 'w',\n+    'L', 'i', 'n', 'e',   1,  10,   2, 'f', 'r',   4, 240, 157, 148, 145,   6,\n+    'o', 'B', 'r', 'e', 'a', 'k',   3, 226, 129, 160,  15, 'o', 'n', 'B', 'r',\n+    'e', 'a', 'k', 'i', 'n', 'g', 'S', 'p', 'a', 'c', 'e',   2, 194, 160,   3,\n+    'o', 'p', 'f',   3, 226, 132, 149,  66, 'o', 't',   4,  23,   3, 226, 171,\n+    172,   9, 'C', 'o', 'n', 'g', 'r', 'u', 'e', 'n', 't',   3, 226, 137, 162,\n+      6, 'C', 'u', 'p', 'C', 'a', 'p',   3, 226, 137, 173,  17, 'D', 'o', 'u',\n+    'b', 'l', 'e', 'V', 'e', 'r', 't', 'i', 'c', 'a', 'l', 'B', 'a', 'r',   3,\n+    226, 136, 166,   7, 'E', 'l', 'e', 'm', 'e', 'n', 't',   3, 226, 136, 137,\n+     69, 'E', 'q', 'u', 'a', 'l',  19,   1,   3, 226, 137, 160,   5, 'T', 'i',\n+    'l', 'd', 'e',   5, 226, 137, 130, 204, 184,   6, 'E', 'x', 'i', 's', 't',\n+    's',   3, 226, 136, 132,  71, 'G', 'r', 'e', 'a', 't', 'e', 'r',  18,   6,\n+      3, 226, 137, 175,   5, 'E', 'q', 'u', 'a', 'l',   3, 226, 137, 177,   9,\n+    'F', 'u', 'l', 'l', 'E', 'q', 'u', 'a', 'l',   5, 226, 137, 167, 204, 184,\n+      7, 'G', 'r', 'e', 'a', 't', 'e', 'r',   5, 226, 137, 171, 204, 184,   4,\n+    'L', 'e', 's', 's',   3, 226, 137, 185,  10, 'S', 'l', 'a', 'n', 't', 'E',\n+    'q', 'u', 'a', 'l',   5, 226, 169, 190, 204, 184,   5, 'T', 'i', 'l', 'd',\n+    'e',   3, 226, 137, 181,  12, 'H', 'u', 'm', 'p', 'D', 'o', 'w', 'n', 'H',\n+    'u', 'm', 'p',   5, 226, 137, 142, 204, 184,   9, 'H', 'u', 'm', 'p', 'E',\n+    'q', 'u', 'a', 'l',   5, 226, 137, 143, 204, 184,  76, 'L', 'e', 'f', 't',\n+    'T', 'r', 'i', 'a', 'n', 'g', 'l', 'e',  21,   2,   3, 226, 139, 170,   3,\n+    'B', 'a', 'r',   5, 226, 167, 143, 204, 184,   5, 'E', 'q', 'u', 'a', 'l',\n+      3, 226, 139, 172,  68, 'L', 'e', 's', 's',  22,   5,   3, 226, 137, 174,\n+      5, 'E', 'q', 'u', 'a', 'l',   3, 226, 137, 176,   7, 'G', 'r', 'e', 'a',\n+    't', 'e', 'r',   3, 226, 137, 184,   4, 'L', 'e', 's', 's',   5, 226, 137,\n+    170, 204, 184,  10, 'S', 'l', 'a', 'n', 't', 'E', 'q', 'u', 'a', 'l',   5,\n+    226, 169, 189, 204, 184,   5, 'T', 'i', 'l', 'd', 'e',   3, 226, 137, 180,\n+     20, 'N', 'e', 's', 't', 'e', 'd', 'G', 'r', 'e', 'a', 't', 'e', 'r', 'G',\n+    'r', 'e', 'a', 't', 'e', 'r',   5, 226, 170, 162, 204, 184,  14, 'N', 'e',\n+    's', 't', 'e', 'd', 'L', 'e', 's', 's', 'L', 'e', 's', 's',   5, 226, 170,\n+    161, 204, 184,  72, 'P', 'r', 'e', 'c', 'e', 'd', 'e', 's',  24,   2,   3,\n+    226, 138, 128,   5, 'E', 'q', 'u', 'a', 'l',   5, 226, 170, 175, 204, 184,\n+     10, 'S', 'l', 'a', 'n', 't', 'E', 'q', 'u', 'a', 'l',   3, 226, 139, 160,\n+     14, 'R', 'e', 'v', 'e', 'r', 's', 'e', 'E', 'l', 'e', 'm', 'e', 'n', 't',\n+      3, 226, 136, 140,  77, 'R', 'i', 'g', 'h', 't', 'T', 'r', 'i', 'a', 'n',\n+    'g', 'l', 'e',  24,   2,   3, 226, 139, 171,   3, 'B', 'a', 'r',   5, 226,\n+    167, 144, 204, 184,   5, 'E', 'q', 'u', 'a', 'l',   3, 226, 139, 173,  76,\n+    'S', 'q', 'u', 'a', 'r', 'e', 'S', 'u', 'b', 's', 'e', 't',  25,   1,   5,\n+    226, 138, 143, 204, 184,   5, 'E', 'q', 'u', 'a', 'l',   3, 226, 139, 162,\n+     78, 'S', 'q', 'u', 'a', 'r', 'e', 'S', 'u', 'p', 'e', 'r', 's', 'e', 't',\n+     25,   1,   5, 226, 138, 144, 204, 184,   5, 'E', 'q', 'u', 'a', 'l',   3,\n+    226, 139, 163,  70, 'S', 'u', 'b', 's', 'e', 't',  25,   1,   6, 226, 138,\n+    130, 226, 131, 146,   5, 'E', 'q', 'u', 'a', 'l',   3, 226, 138, 136,  72,\n+    'S', 'u', 'c', 'c', 'e', 'e', 'd', 's',  25,   3,   3, 226, 138, 129,   5,\n+    'E', 'q', 'u', 'a', 'l',   5, 226, 170, 176, 204, 184,  10, 'S', 'l', 'a',\n+    'n', 't', 'E', 'q', 'u', 'a', 'l',   3, 226, 139, 161,   5, 'T', 'i', 'l',\n+    'd', 'e',   5, 226, 137, 191, 204, 184,  72, 'S', 'u', 'p', 'e', 'r', 's',\n+    'e', 't',  27,   1,   6, 226, 138, 131, 226, 131, 146,   5, 'E', 'q', 'u',\n+    'a', 'l',   3, 226, 138, 137,  69, 'T', 'i', 'l', 'd', 'e',  27,   3,   3,\n+    226, 137, 129,   5, 'E', 'q', 'u', 'a', 'l',   3, 226, 137, 132,   9, 'F',\n+    'u', 'l', 'l', 'E', 'q', 'u', 'a', 'l',   3, 226, 137, 135,   5, 'T', 'i',\n+    'l', 'd', 'e',   3, 226, 137, 137,  11, 'V', 'e', 'r', 't', 'i', 'c', 'a',\n+    'l', 'B', 'a', 'r',   3, 226, 136, 164,   3, 's', 'c', 'r',   4, 240, 157,\n+    146, 169, 133, 't', 'i', 'l', 'd', 'e',   2, 195, 145,   1, 'u',   2, 206,\n+    157,   4, 'E', 'l', 'i', 'g',   2, 197, 146, 133, 'a', 'c', 'u', 't', 'e',\n+      2, 195, 147, 132, 'c', 'i', 'r', 'c',   2, 195, 148,   2, 'c', 'y',   2,\n+    208, 158,   5, 'd', 'b', 'l', 'a', 'c',   2, 197, 144,   2, 'f', 'r',   4,\n+    240, 157, 148, 146, 133, 'g', 'r', 'a', 'v', 'e',   2, 195, 146,   4, 'm',\n+    'a', 'c', 'r',   2, 197, 140,   4, 'm', 'e', 'g', 'a',   2, 206, 169,   6,\n+    'm', 'i', 'c', 'r', 'o', 'n',   2, 206, 159,   3, 'o', 'p', 'f',   4, 240,\n+    157, 149, 134,  19, 'p', 'e', 'n', 'C', 'u', 'r', 'l', 'y', 'D', 'o', 'u',\n+    'b', 'l', 'e', 'Q', 'u', 'o', 't', 'e',   3, 226, 128, 156,  13, 'p', 'e',\n+    'n', 'C', 'u', 'r', 'l', 'y', 'Q', 'u', 'o', 't', 'e',   3, 226, 128, 152,\n+      1, 'r',   3, 226, 169, 148,   3, 's', 'c', 'r',   4, 240, 157, 146, 170,\n+    133, 's', 'l', 'a', 's', 'h',   2, 195, 152, 133, 't', 'i', 'l', 'd', 'e',\n+      2, 195, 149,   5, 't', 'i', 'm', 'e', 's',   3, 226, 168, 183, 131, 'u',\n+    'm', 'l',   2, 195, 150,   6, 'v', 'e', 'r', 'B', 'a', 'r',   3, 226, 128,\n+    190,   8, 'v', 'e', 'r', 'B', 'r', 'a', 'c', 'e',   3, 226, 143, 158,  10,\n+    'v', 'e', 'r', 'B', 'r', 'a', 'c', 'k', 'e', 't',   3, 226, 142, 180,  14,\n+    'v', 'e', 'r', 'P', 'a', 'r', 'e', 'n', 't', 'h', 'e', 's', 'i', 's',   3,\n+    226, 143, 156,   7, 'a', 'r', 't', 'i', 'a', 'l', 'D',   3, 226, 136, 130,\n+      2, 'c', 'y',   2, 208, 159,   2, 'f', 'r',   4, 240, 157, 148, 147,   2,\n+    'h', 'i',   2, 206, 166,   1, 'i',   2, 206, 160,   8, 'l', 'u', 's', 'M',\n+    'i', 'n', 'u', 's',   2, 194, 177,  12, 'o', 'i', 'n', 'c', 'a', 'r', 'e',\n+    'p', 'l', 'a', 'n', 'e',   3, 226, 132, 140,   3, 'o', 'p', 'f',   3, 226,\n+    132, 153,  65, 'r',   3,   4,   3, 226, 170, 187,  70, 'e', 'c', 'e', 'd',\n+    'e', 's',   4,   3,   3, 226, 137, 186,   5, 'E', 'q', 'u', 'a', 'l',   3,\n+    226, 170, 175,  10, 'S', 'l', 'a', 'n', 't', 'E', 'q', 'u', 'a', 'l',   3,\n+    226, 137, 188,   5, 'T', 'i', 'l', 'd', 'e',   3, 226, 137, 190,   3, 'i',\n+    'm', 'e',   3, 226, 128, 179,   5, 'o', 'd', 'u', 'c', 't',   3, 226, 136,\n+    143,  72, 'o', 'p', 'o', 'r', 't', 'i', 'o', 'n',   4,   1,   3, 226, 136,\n+    183,   2, 'a', 'l',   3, 226, 136, 157,   3, 's', 'c', 'r',   4, 240, 157,\n+    146, 171,   2, 's', 'i',   2, 206, 168, 131, 'U', 'O', 'T',   1, '\"',   2,\n+    'f', 'r',   4, 240, 157, 148, 148,   3, 'o', 'p', 'f',   3, 226, 132, 154,\n+      3, 's', 'c', 'r',   4, 240, 157, 146, 172,   4, 'B', 'a', 'r', 'r',   3,\n+    226, 164, 144, 130, 'E', 'G',   2, 194, 174,   5, 'a', 'c', 'u', 't', 'e',\n+      2, 197, 148,   3, 'a', 'n', 'g',   3, 226, 159, 171,  67, 'a', 'r', 'r',\n+     27,   1,   3, 226, 134, 160,   2, 't', 'l',   3, 226, 164, 150,   5, 'c',\n+    'a', 'r', 'o', 'n',   2, 197, 152,   5, 'c', 'e', 'd', 'i', 'l',   2, 197,\n+    150,   2, 'c', 'y',   2, 208, 160,  65, 'e',  24,   3,   3, 226, 132, 156,\n+     12, 'v', 'e', 'r', 's', 'e', 'E', 'l', 'e', 'm', 'e', 'n', 't',   3, 226,\n+    136, 139,  16, 'v', 'e', 'r', 's', 'e', 'E', 'q', 'u', 'i', 'l', 'i', 'b',\n+    'r', 'i', 'u', 'm',   3, 226, 135, 139,  18, 'v', 'e', 'r', 's', 'e', 'U',\n+    'p', 'E', 'q', 'u', 'i', 'l', 'i', 'b', 'r', 'i', 'u', 'm',   3, 226, 165,\n+    175,   2, 'f', 'r',   3, 226, 132, 156,   2, 'h', 'o',   2, 206, 161,  16,\n+    'i', 'g', 'h', 't', 'A', 'n', 'g', 'l', 'e', 'B', 'r', 'a', 'c', 'k', 'e',\n+    't',   3, 226, 159, 169,  73, 'i', 'g', 'h', 't', 'A', 'r', 'r', 'o', 'w',\n+     23,   2,   3, 226, 134, 146,   3, 'B', 'a', 'r',   3, 226, 135, 165,   9,\n+    'L', 'e', 'f', 't', 'A', 'r', 'r', 'o', 'w',   3, 226, 135, 132,  11, 'i',\n+    'g', 'h', 't', 'C', 'e', 'i', 'l', 'i', 'n', 'g',   3, 226, 140, 137,  17,\n+    'i', 'g', 'h', 't', 'D', 'o', 'u', 'b', 'l', 'e', 'B', 'r', 'a', 'c', 'k',\n+    'e', 't',   3, 226, 159, 167,  17, 'i', 'g', 'h', 't', 'D', 'o', 'w', 'n',\n+    'T', 'e', 'e', 'V', 'e', 'c', 't', 'o', 'r',   3, 226, 165, 157,  78, 'i',\n+    'g', 'h', 't', 'D', 'o', 'w', 'n', 'V', 'e', 'c', 't', 'o', 'r',  21,   1,\n+      3, 226, 135, 130,   3, 'B', 'a', 'r',   3, 226, 165, 149,   9, 'i', 'g',\n+    'h', 't', 'F', 'l', 'o', 'o', 'r',   3, 226, 140, 139,  71, 'i', 'g', 'h',\n+    't', 'T', 'e', 'e',  20,   2,   3, 226, 138, 162,   5, 'A', 'r', 'r', 'o',\n+    'w',   3, 226, 134, 166,   6, 'V', 'e', 'c', 't', 'o', 'r',   3, 226, 165,\n+    155,  76, 'i', 'g', 'h', 't', 'T', 'r', 'i', 'a', 'n', 'g', 'l', 'e',  21,\n+      2,   3, 226, 138, 179,   3, 'B', 'a', 'r',   3, 226, 167, 144,   5, 'E',\n+    'q', 'u', 'a', 'l',   3, 226, 138, 181,  16, 'i', 'g', 'h', 't', 'U', 'p',\n+    'D', 'o', 'w', 'n', 'V', 'e', 'c', 't', 'o', 'r',   3, 226, 165, 143,  15,\n+    'i', 'g', 'h', 't', 'U', 'p', 'T', 'e', 'e', 'V', 'e', 'c', 't', 'o', 'r',\n+      3, 226, 165, 156,  76, 'i', 'g', 'h', 't', 'U', 'p', 'V', 'e', 'c', 't',\n+    'o', 'r',  20,   1,   3, 226, 134, 190,   3, 'B', 'a', 'r',   3, 226, 165,\n+    148,  74, 'i', 'g', 'h', 't', 'V', 'e', 'c', 't', 'o', 'r',  20,   1,   3,\n+    226, 135, 128,   3, 'B', 'a', 'r',   3, 226, 165, 147,   9, 'i', 'g', 'h',\n+    't', 'a', 'r', 'r', 'o', 'w',   3, 226, 135, 146,   3, 'o', 'p', 'f',   3,\n+    226, 132, 157,  11, 'o', 'u', 'n', 'd', 'I', 'm', 'p', 'l', 'i', 'e', 's',\n+      3, 226, 165, 176,  10, 'r', 'i', 'g', 'h', 't', 'a', 'r', 'r', 'o', 'w',\n+      3, 226, 135, 155,   3, 's', 'c', 'r',   3, 226, 132, 155,   2, 's', 'h',\n+      3, 226, 134, 177,  10, 'u', 'l', 'e', 'D', 'e', 'l', 'a', 'y', 'e', 'd',\n+      3, 226, 167, 180,   5, 'H', 'C', 'H', 'c', 'y',   2, 208, 169,   3, 'H',\n+    'c', 'y',   2, 208, 168,   5, 'O', 'F', 'T', 'c', 'y',   2, 208, 172,   5,\n+    'a', 'c', 'u', 't', 'e',   2, 197, 154,  65, 'c',  18,   4,   3, 226, 170,\n+    188,   4, 'a', 'r', 'o', 'n',   2, 197, 160,   4, 'e', 'd', 'i', 'l',   2,\n+    197, 158,   3, 'i', 'r', 'c',   2, 197, 156,   1, 'y',   2, 208, 161,   2,\n+    'f', 'r',   4, 240, 157, 148, 150,  13, 'h', 'o', 'r', 't', 'D', 'o', 'w',\n+    'n', 'A', 'r', 'r', 'o', 'w',   3, 226, 134, 147,  13, 'h', 'o', 'r', 't',\n+    'L', 'e', 'f', 't', 'A', 'r', 'r', 'o', 'w',   3, 226, 134, 144,  14, 'h',\n+    'o', 'r', 't', 'R', 'i', 'g', 'h', 't', 'A', 'r', 'r', 'o', 'w',   3, 226,\n+    134, 146,  11, 'h', 'o', 'r', 't', 'U', 'p', 'A', 'r', 'r', 'o', 'w',   3,\n+    226, 134, 145,   4, 'i', 'g', 'm', 'a',   2, 206, 163,  10, 'm', 'a', 'l',\n+    'l', 'C', 'i', 'r', 'c', 'l', 'e',   3, 226, 136, 152,   3, 'o', 'p', 'f',\n+      4, 240, 157, 149, 138,   3, 'q', 'r', 't',   3, 226, 136, 154,  69, 'q',\n+    'u', 'a', 'r', 'e',  12,   4,   3, 226, 150, 161,  12, 'I', 'n', 't', 'e',\n+    'r', 's', 'e', 'c', 't', 'i', 'o', 'n',   3, 226, 138, 147,  70, 'S', 'u',\n+    'b', 's', 'e', 't',   3,   1,   3, 226, 138, 143,   5, 'E', 'q', 'u', 'a',\n+    'l',   3, 226, 138, 145,  72, 'S', 'u', 'p', 'e', 'r', 's', 'e', 't',   3,\n+      1,   3, 226, 138, 144,   5, 'E', 'q', 'u', 'a', 'l',   3, 226, 138, 146,\n+      5, 'U', 'n', 'i', 'o', 'n',   3, 226, 138, 148,   3, 's', 'c', 'r',   4,\n+    240, 157, 146, 174,   3, 't', 'a', 'r',   3, 226, 139, 134,  66, 'u', 'b',\n+     15,   1,   3, 226, 139, 144,  67, 's', 'e', 't',   1,   1,   3, 226, 139,\n+    144,   5, 'E', 'q', 'u', 'a', 'l',   3, 226, 138, 134,  71, 'u', 'c', 'c',\n+    'e', 'e', 'd', 's',  16,   3,   3, 226, 137, 187,   5, 'E', 'q', 'u', 'a',\n+    'l',   3, 226, 170, 176,  10, 'S', 'l', 'a', 'n', 't', 'E', 'q', 'u', 'a',\n+    'l',   3, 226, 137, 189,   5, 'T', 'i', 'l', 'd', 'e',   3, 226, 137, 191,\n+      7, 'u', 'c', 'h', 'T', 'h', 'a', 't',   3, 226, 136, 139,   2, 'u', 'm',\n+      3, 226, 136, 145,  66, 'u', 'p',  16,   2,   3, 226, 139, 145,  69, 'e',\n+    'r', 's', 'e', 't',   2,   1,   3, 226, 138, 131,   5, 'E', 'q', 'u', 'a',\n+    'l',   3, 226, 138, 135,   3, 's', 'e', 't',   3, 226, 139, 145, 132, 'H',\n+    'O', 'R', 'N',   2, 195, 158,   4, 'R', 'A', 'D', 'E',   3, 226, 132, 162,\n+      4, 'S', 'H', 'c', 'y',   2, 208, 139,   3, 'S', 'c', 'y',   2, 208, 166,\n+      2, 'a', 'b',   1,   9,   2, 'a', 'u',   2, 206, 164,   5, 'c', 'a', 'r',\n+    'o', 'n',   2, 197, 164,   5, 'c', 'e', 'd', 'i', 'l',   2, 197, 162,   2,\n+    'c', 'y',   2, 208, 162,   2, 'f', 'r',   4, 240, 157, 148, 151,   8, 'h',\n+    'e', 'r', 'e', 'f', 'o', 'r', 'e',   3, 226, 136, 180,   4, 'h', 'e', 't',\n+    'a',   2, 206, 152,   9, 'h', 'i', 'c', 'k', 'S', 'p', 'a', 'c', 'e',   6,\n+    226, 129, 159, 226, 128, 138,   8, 'h', 'i', 'n', 'S', 'p', 'a', 'c', 'e',\n+      3, 226, 128, 137,  68, 'i', 'l', 'd', 'e',   5,   3,   3, 226, 136, 188,\n+      5, 'E', 'q', 'u', 'a', 'l',   3, 226, 137, 131,   9, 'F', 'u', 'l', 'l',\n+    'E', 'q', 'u', 'a', 'l',   3, 226, 137, 133,   5, 'T', 'i', 'l', 'd', 'e',\n+      3, 226, 137, 136,   3, 'o', 'p', 'f',   4, 240, 157, 149, 139,   8, 'r',\n+    'i', 'p', 'l', 'e', 'D', 'o', 't',   3, 226, 131, 155,   3, 's', 'c', 'r',\n+      4, 240, 157, 146, 175,   5, 's', 't', 'r', 'o', 'k',   2, 197, 166, 133,\n+    'a', 'c', 'u', 't', 'e',   2, 195, 154,  67, 'a', 'r', 'r',  29,   1,   3,\n+    226, 134, 159,   4, 'o', 'c', 'i', 'r',   3, 226, 165, 137,   4, 'b', 'r',\n+    'c', 'y',   2, 208, 142,   5, 'b', 'r', 'e', 'v', 'e',   2, 197, 172, 132,\n+    'c', 'i', 'r', 'c',   2, 195, 155,   2, 'c', 'y',   2, 208, 163,   5, 'd',\n+    'b', 'l', 'a', 'c',   2, 197, 176,   2, 'f', 'r',   4, 240, 157, 148, 152,\n+    133, 'g', 'r', 'a', 'v', 'e',   2, 195, 153,   4, 'm', 'a', 'c', 'r',   2,\n+    197, 170,   7, 'n', 'd', 'e', 'r', 'B', 'a', 'r',   1, '_',   9, 'n', 'd',\n+    'e', 'r', 'B', 'r', 'a', 'c', 'e',   3, 226, 143, 159,  11, 'n', 'd', 'e',\n+    'r', 'B', 'r', 'a', 'c', 'k', 'e', 't',   3, 226, 142, 181,  15, 'n', 'd',\n+    'e', 'r', 'P', 'a', 'r', 'e', 'n', 't', 'h', 'e', 's', 'i', 's',   3, 226,\n+    143, 157,  68, 'n', 'i', 'o', 'n',  17,   1,   3, 226, 139, 131,   4, 'P',\n+    'l', 'u', 's',   3, 226, 138, 142,   4, 'o', 'g', 'o', 'n',   2, 197, 178,\n+      3, 'o', 'p', 'f',   4, 240, 157, 149, 140,  70, 'p', 'A', 'r', 'r', 'o',\n+    'w',  15,   2,   3, 226, 134, 145,   3, 'B', 'a', 'r',   3, 226, 164, 146,\n+      9, 'D', 'o', 'w', 'n', 'A', 'r', 'r', 'o', 'w',   3, 226, 135, 133,  10,\n+    'p', 'D', 'o', 'w', 'n', 'A', 'r', 'r', 'o', 'w',   3, 226, 134, 149,  12,\n+    'p', 'E', 'q', 'u', 'i', 'l', 'i', 'b', 'r', 'i', 'u', 'm',   3, 226, 165,\n+    174,  68, 'p', 'T', 'e', 'e',  14,   1,   3, 226, 138, 165,   5, 'A', 'r',\n+    'r', 'o', 'w',   3, 226, 134, 165,   6, 'p', 'a', 'r', 'r', 'o', 'w',   3,\n+    226, 135, 145,  10, 'p', 'd', 'o', 'w', 'n', 'a', 'r', 'r', 'o', 'w',   3,\n+    226, 135, 149,  13, 'p', 'p', 'e', 'r', 'L', 'e', 'f', 't', 'A', 'r', 'r',\n+    'o', 'w',   3, 226, 134, 150,  14, 'p', 'p', 'e', 'r', 'R', 'i', 'g', 'h',\n+    't', 'A', 'r', 'r', 'o', 'w',   3, 226, 134, 151,  67, 'p', 's', 'i',  10,\n+      1,   2, 207, 146,   3, 'l', 'o', 'n',   2, 206, 165,   4, 'r', 'i', 'n',\n+    'g',   2, 197, 174,   3, 's', 'c', 'r',   4, 240, 157, 146, 176,   5, 't',\n+    'i', 'l', 'd', 'e',   2, 197, 168, 131, 'u', 'm', 'l',   2, 195, 156,   4,\n+    'D', 'a', 's', 'h',   3, 226, 138, 171,   3, 'b', 'a', 'r',   3, 226, 171,\n+    171,   2, 'c', 'y',   2, 208, 146,  68, 'd', 'a', 's', 'h',   9,   1,   3,\n+    226, 138, 169,   1, 'l',   3, 226, 171, 166,   2, 'e', 'e',   3, 226, 139,\n+    129,   5, 'e', 'r', 'b', 'a', 'r',   3, 226, 128, 150,  67, 'e', 'r', 't',\n+      7,   4,   3, 226, 128, 150,   7, 'i', 'c', 'a', 'l', 'B', 'a', 'r',   3,\n+    226, 136, 163,   8, 'i', 'c', 'a', 'l', 'L', 'i', 'n', 'e',   1, '|',  13,\n+    'i', 'c', 'a', 'l', 'S', 'e', 'p', 'a', 'r', 'a', 't', 'o', 'r',   3, 226,\n+    157, 152,   9, 'i', 'c', 'a', 'l', 'T', 'i', 'l', 'd', 'e',   3, 226, 137,\n+    128,  12, 'e', 'r', 'y', 'T', 'h', 'i', 'n', 'S', 'p', 'a', 'c', 'e',   3,\n+    226, 128, 138,   2, 'f', 'r',   4, 240, 157, 148, 153,   3, 'o', 'p', 'f',\n+      4, 240, 157, 149, 141,   3, 's', 'c', 'r',   4, 240, 157, 146, 177,   5,\n+    'v', 'd', 'a', 's', 'h',   3, 226, 138, 170,   4, 'c', 'i', 'r', 'c',   2,\n+    197, 180,   4, 'e', 'd', 'g', 'e',   3, 226, 139, 128,   2, 'f', 'r',   4,\n+    240, 157, 148, 154,   3, 'o', 'p', 'f',   4, 240, 157, 149, 142,   3, 's',\n+    'c', 'r',   4, 240, 157, 146, 178,   2, 'f', 'r',   4, 240, 157, 148, 155,\n+      1, 'i',   2, 206, 158,   3, 'o', 'p', 'f',   4, 240, 157, 149, 143,   3,\n+    's', 'c', 'r',   4, 240, 157, 146, 179,   3, 'A', 'c', 'y',   2, 208, 175,\n+      3, 'I', 'c', 'y',   2, 208, 135,   3, 'U', 'c', 'y',   2, 208, 174, 133,\n+    'a', 'c', 'u', 't', 'e',   2, 195, 157,   4, 'c', 'i', 'r', 'c',   2, 197,\n+    182,   2, 'c', 'y',   2, 208, 171,   2, 'f', 'r',   4, 240, 157, 148, 156,\n+      3, 'o', 'p', 'f',   4, 240, 157, 149, 144,   3, 's', 'c', 'r',   4, 240,\n+    157, 146, 180,   3, 'u', 'm', 'l',   2, 197, 184,   3, 'H', 'c', 'y',   2,\n+    208, 150,   5, 'a', 'c', 'u', 't', 'e',   2, 197, 185,   5, 'c', 'a', 'r',\n+    'o', 'n',   2, 197, 189,   2, 'c', 'y',   2, 208, 151,   3, 'd', 'o', 't',\n+      2, 197, 187,  13, 'e', 'r', 'o', 'W', 'i', 'd', 't', 'h', 'S', 'p', 'a',\n+    'c', 'e',   3, 226, 128, 139,   3, 'e', 't', 'a',   2, 206, 150,   2, 'f',\n+    'r',   3, 226, 132, 168,   3, 'o', 'p', 'f',   3, 226, 132, 164,   3, 's',\n+    'c', 'r',   4, 240, 157, 146, 181, 133, 'a', 'c', 'u', 't', 'e',   2, 195,\n+    161,   5, 'b', 'r', 'e', 'v', 'e',   2, 196, 131,  65, 'c',  23,   5,   3,\n+    226, 136, 190,   1, 'E',   5, 226, 136, 190, 204, 179,   1, 'd',   3, 226,\n+    136, 191, 131, 'i', 'r', 'c',   2, 195, 162, 131, 'u', 't', 'e',   2, 194,\n+    180,   1, 'y',   2, 208, 176, 132, 'e', 'l', 'i', 'g',   2, 195, 166,  65,\n+    'f',  26,   1,   3, 226, 129, 161,   1, 'r',   4, 240, 157, 148, 158, 133,\n+    'g', 'r', 'a', 'v', 'e',   2, 195, 160,   6, 'l', 'e', 'f', 's', 'y', 'm',\n+      3, 226, 132, 181,   4, 'l', 'e', 'p', 'h',   3, 226, 132, 181,   4, 'l',\n+    'p', 'h', 'a',   2, 206, 177,   4, 'm', 'a', 'c', 'r',   2, 196, 129,   4,\n+    'm', 'a', 'l', 'g',   3, 226, 168, 191, 130, 'm', 'p',   1, '&',  66, 'n',\n+    'd',  19,   4,   3, 226, 136, 167,   3, 'a', 'n', 'd',   3, 226, 169, 149,\n+      1, 'd',   3, 226, 169, 156,   5, 's', 'l', 'o', 'p', 'e',   3, 226, 169,\n+    152,   1, 'v',   3, 226, 169, 154,  66, 'n', 'g',  22,   7,   3, 226, 136,\n+    160,   1, 'e',   3, 226, 166, 164,   2, 'l', 'e',   3, 226, 136, 160,  67,\n+    'm', 's', 'd',   5,   8,   3, 226, 136, 161,   2, 'a', 'a',   3, 226, 166,\n+    168,   2, 'a', 'b',   3, 226, 166, 169,   2, 'a', 'c',   3, 226, 166, 170,\n+      2, 'a', 'd',   3, 226, 166, 171,   2, 'a', 'e',   3, 226, 166, 172,   2,\n+    'a', 'f',   3, 226, 166, 173,   2, 'a', 'g',   3, 226, 166, 174,   2, 'a',\n+    'h',   3, 226, 166, 175,  66, 'r', 't',  12,   1,   3, 226, 136, 159,  66,\n+    'v', 'b',   1,   1,   3, 226, 138, 190,   1, 'd',   3, 226, 166, 157,   3,\n+    's', 'p', 'h',   3, 226, 136, 162,   2, 's', 't',   2, 195, 133,   4, 'z',\n+    'a', 'r', 'r',   3, 226, 141, 188,   4, 'o', 'g', 'o', 'n',   2, 196, 133,\n+      3, 'o', 'p', 'f',   4, 240, 157, 149, 146,  65, 'p',  36,   6,   3, 226,\n+    137, 136,   1, 'E',   3, 226, 169, 176,   4, 'a', 'c', 'i', 'r',   3, 226,\n+    169, 175,   1, 'e',   3, 226, 137, 138,   2, 'i', 'd',   3, 226, 137, 139,\n+      2, 'o', 's',   1,  39,  68, 'p', 'r', 'o', 'x',   1,   1,   3, 226, 137,\n+    136,   2, 'e', 'q',   3, 226, 137, 138, 132, 'r', 'i', 'n', 'g',   2, 195,\n+    165,   3, 's', 'c', 'r',   4, 240, 157, 146, 182,   2, 's', 't',   1, '*',\n+     68, 's', 'y', 'm', 'p',  39,   1,   3, 226, 137, 136,   2, 'e', 'q',   3,\n+    226, 137, 141, 133, 't', 'i', 'l', 'd', 'e',   2, 195, 163, 131, 'u', 'm',\n+    'l',   2, 195, 164,   7, 'w', 'c', 'o', 'n', 'i', 'n', 't',   3, 226, 136,\n+    179,   4, 'w', 'i', 'n', 't',   3, 226, 168, 145,   3, 'N', 'o', 't',   3,\n+    226, 171, 173,   7, 'a', 'c', 'k', 'c', 'o', 'n', 'g',   3, 226, 137, 140,\n+     10, 'a', 'c', 'k', 'e', 'p', 's', 'i', 'l', 'o', 'n',   2, 207, 182,   8,\n+    'a', 'c', 'k', 'p', 'r', 'i', 'm', 'e',   3, 226, 128, 181,  70, 'a', 'c',\n+    'k', 's', 'i', 'm',  75,   1,   3, 226, 136, 189,   2, 'e', 'q',   3, 226,\n+    139, 141,   5, 'a', 'r', 'v', 'e', 'e',   3, 226, 138, 189,  69, 'a', 'r',\n+    'w', 'e', 'd',  74,   1,   3, 226, 140, 133,   2, 'g', 'e',   3, 226, 140,\n+    133,  67, 'b', 'r', 'k',  74,   1,   3, 226, 142, 181,   4, 't', 'b', 'r',\n+    'k',   3, 226, 142, 182,   4, 'c', 'o', 'n', 'g',   3, 226, 137, 140,   2,\n+    'c', 'y',   2, 208, 177,   4, 'd', 'q', 'u', 'o',   3, 226, 128, 158,  69,\n+    'e', 'c', 'a', 'u', 's',  71,   1,   3, 226, 136, 181,   1, 'e',   3, 226,\n+    136, 181,   6, 'e', 'm', 'p', 't', 'y', 'v',   3, 226, 166, 176,   4, 'e',\n+    'p', 's', 'i',   2, 207, 182,   5, 'e', 'r', 'n', 'o', 'u',   3, 226, 132,\n+    172,   3, 'e', 't', 'a',   2, 206, 178,   3, 'e', 't', 'h',   3, 226, 132,\n+    182,   6, 'e', 't', 'w', 'e', 'e', 'n',   3, 226, 137, 172,   2, 'f', 'r',\n+      4, 240, 157, 148, 159,   5, 'i', 'g', 'c', 'a', 'p',   3, 226, 139, 130,\n+      6, 'i', 'g', 'c', 'i', 'r', 'c',   3, 226, 151, 175,   5, 'i', 'g', 'c',\n+    'u', 'p',   3, 226, 139, 131,   6, 'i', 'g', 'o', 'd', 'o', 't',   3, 226,\n+    168, 128,   7, 'i', 'g', 'o', 'p', 'l', 'u', 's',   3, 226, 168, 129,   8,\n+    'i', 'g', 'o', 't', 'i', 'm', 'e', 's',   3, 226, 168, 130,   7, 'i', 'g',\n+    's', 'q', 'c', 'u', 'p',   3, 226, 168, 134,   6, 'i', 'g', 's', 't', 'a',\n+    'r',   3, 226, 152, 133,  14, 'i', 'g', 't', 'r', 'i', 'a', 'n', 'g', 'l',\n+    'e', 'd', 'o', 'w', 'n',   3, 226, 150, 189,  12, 'i', 'g', 't', 'r', 'i',\n+    'a', 'n', 'g', 'l', 'e', 'u', 'p',   3, 226, 150, 179,   7, 'i', 'g', 'u',\n+    'p', 'l', 'u', 's',   3, 226, 168, 132,   5, 'i', 'g', 'v', 'e', 'e',   3,\n+    226, 139, 129,   7, 'i', 'g', 'w', 'e', 'd', 'g', 'e',   3, 226, 139, 128,\n+      5, 'k', 'a', 'r', 'o', 'w',   3, 226, 164, 141,  11, 'l', 'a', 'c', 'k',\n+    'l', 'o', 'z', 'e', 'n', 'g', 'e',   3, 226, 167, 171,  10, 'l', 'a', 'c',\n+    'k', 's', 'q', 'u', 'a', 'r', 'e',   3, 226, 150, 170,  76, 'l', 'a', 'c',\n+    'k', 't', 'r', 'i', 'a', 'n', 'g', 'l', 'e',  48,   3,   3, 226, 150, 180,\n+      4, 'd', 'o', 'w', 'n',   3, 226, 150, 190,   4, 'l', 'e', 'f', 't',   3,\n+    226, 151, 130,   5, 'r', 'i', 'g', 'h', 't',   3, 226, 150, 184,   4, 'l',\n+    'a', 'n', 'k',   3, 226, 144, 163,   4, 'l', 'k', '1', '2',   3, 226, 150,\n+    146,   4, 'l', 'k', '1', '4',   3, 226, 150, 145,   4, 'l', 'k', '3', '4',\n+      3, 226, 150, 147,   4, 'l', 'o', 'c', 'k',   3, 226, 150, 136,  66, 'n',\n+    'e',  45,   1,   4, '=', 226, 131, 165,   4, 'q', 'u', 'i', 'v',   6, 226,\n+    137, 161, 226, 131, 165,   3, 'n', 'o', 't',   3, 226, 140, 144,   3, 'o',\n+    'p', 'f',   4, 240, 157, 149, 147,  66, 'o', 't',  43,   1,   3, 226, 138,\n+    165,   3, 't', 'o', 'm',   3, 226, 138, 165,   5, 'o', 'w', 't', 'i', 'e',\n+      3, 226, 139, 136,   4, 'o', 'x', 'D', 'L',   3, 226, 149, 151,   4, 'o',\n+    'x', 'D', 'R',   3, 226, 149, 148,   4, 'o', 'x', 'D', 'l',   3, 226, 149,\n+    150,   4, 'o', 'x', 'D', 'r',   3, 226, 149, 147,  67, 'o', 'x', 'H',  38,\n+      4,   3, 226, 149, 144,   1, 'D',   3, 226, 149, 166,   1, 'U',   3, 226,\n+    149, 169,   1, 'd',   3, 226, 149, 164,   1, 'u',   3, 226, 149, 167,   4,\n+    'o', 'x', 'U', 'L',   3, 226, 149, 157,   4, 'o', 'x', 'U', 'R',   3, 226,\n+    149, 154,   4, 'o', 'x', 'U', 'l',   3, 226, 149, 156,   4, 'o', 'x', 'U',\n+    'r',   3, 226, 149, 153,  67, 'o', 'x', 'V',  37,   6,   3, 226, 149, 145,\n+      1, 'H',   3, 226, 149, 172,   1, 'L',   3, 226, 149, 163,   1, 'R',   3,\n+    226, 149, 160,   1, 'h',   3, 226, 149, 171,   1, 'l',   3, 226, 149, 162,\n+      1, 'r',   3, 226, 149, 159,   5, 'o', 'x', 'b', 'o', 'x',   3, 226, 167,\n+    137,   4, 'o', 'x', 'd', 'L',   3, 226, 149, 149,   4, 'o', 'x', 'd', 'R',\n+      3, 226, 149, 146,   4, 'o', 'x', 'd', 'l',   3, 226, 148, 144,   4, 'o',\n+    'x', 'd', 'r',   3, 226, 148, 140,  67, 'o', 'x', 'h',  37,   4,   3, 226,\n+    148, 128,   1, 'D',   3, 226, 149, 165,   1, 'U',   3, 226, 149, 168,   1,\n+    'd',   3, 226, 148, 172,   1, 'u',   3, 226, 148, 180,   7, 'o', 'x', 'm',\n+    'i', 'n', 'u', 's',   3, 226, 138, 159,   6, 'o', 'x', 'p', 'l', 'u', 's',\n+      3, 226, 138, 158,   7, 'o', 'x', 't', 'i', 'm', 'e', 's',   3, 226, 138,\n+    160,   4, 'o', 'x', 'u', 'L',   3, 226, 149, 155,   4, 'o', 'x', 'u', 'R',\n+      3, 226, 149, 152,   4, 'o', 'x', 'u', 'l',   3, 226, 148, 152,   4, 'o',\n+    'x', 'u', 'r',   3, 226, 148, 148,  67, 'o', 'x', 'v',  33,   6,   3, 226,\n+    148, 130,   1, 'H',   3, 226, 149, 170,   1, 'L',   3, 226, 149, 161,   1,\n+    'R',   3, 226, 149, 158,   1, 'h',   3, 226, 148, 188,   1, 'l',   3, 226,\n+    148, 164,   1, 'r',   3, 226, 148, 156,   5, 'p', 'r', 'i', 'm', 'e',   3,\n+    226, 128, 181,   4, 'r', 'e', 'v', 'e',   2, 203, 152, 133, 'r', 'v', 'b',\n+    'a', 'r',   2, 194, 166,   3, 's', 'c', 'r',   4, 240, 157, 146, 183,   4,\n+    's', 'e', 'm', 'i',   3, 226, 129, 143,  67, 's', 'i', 'm',  33,   1,   3,\n+    226, 136, 189,   1, 'e',   3, 226, 139, 141,  67, 's', 'o', 'l',  33,   2,\n+      1,  92,   1, 'b',   3, 226, 167, 133,   4, 'h', 's', 'u', 'b',   3, 226,\n+    159, 136,  67, 'u', 'l', 'l',  34,   1,   3, 226, 128, 162,   2, 'e', 't',\n+      3, 226, 128, 162,  67, 'u', 'm', 'p',  34,   2,   3, 226, 137, 142,   1,\n+    'E',   3, 226, 170, 174,  65, 'e',   1,   1,   3, 226, 137, 143,   1, 'q',\n+      3, 226, 137, 143,   5, 'a', 'c', 'u', 't', 'e',   2, 196, 135,  66, 'a',\n+    'p',  51,   6,   3, 226, 136, 169,   3, 'a', 'n', 'd',   3, 226, 169, 132,\n+      5, 'b', 'r', 'c', 'u', 'p',   3, 226, 169, 137,   3, 'c', 'a', 'p',   3,\n+    226, 169, 139,   3, 'c', 'u', 'p',   3, 226, 169, 135,   3, 'd', 'o', 't',\n+      3, 226, 169, 128,   1, 's',   6, 226, 136, 169, 239, 184, 128,   4, 'a',\n+    'r', 'e', 't',   3, 226, 129, 129,   4, 'a', 'r', 'o', 'n',   2, 203, 135,\n+      4, 'c', 'a', 'p', 's',   3, 226, 169, 141,   5, 'c', 'a', 'r', 'o', 'n',\n+      2, 196, 141, 133, 'c', 'e', 'd', 'i', 'l',   2, 195, 167,   4, 'c', 'i',\n+    'r', 'c',   2, 196, 137,  68, 'c', 'u', 'p', 's',  50,   1,   3, 226, 169,\n+    140,   2, 's', 'm',   3, 226, 169, 144,   3, 'd', 'o', 't',   2, 196, 139,\n+    132, 'e', 'd', 'i', 'l',   2, 194, 184,   6, 'e', 'm', 'p', 't', 'y', 'v',\n+      3, 226, 166, 178, 195, 'e', 'n', 't',  47,   1,   2, 194, 162,   5, 'e',\n+    'r', 'd', 'o', 't',   2, 194, 183,   2, 'f', 'r',   4, 240, 157, 148, 160,\n+      3, 'h', 'c', 'y',   2, 209, 135,  68, 'h', 'e', 'c', 'k',  45,   1,   3,\n+    226, 156, 147,   4, 'm', 'a', 'r', 'k',   3, 226, 156, 147,   2, 'h', 'i',\n+      2, 207, 135,  66, 'i', 'r',  44,   6,   3, 226, 151, 139,   1, 'E',   3,\n+    226, 167, 131,  65, 'c',   5,   8,   2, 203, 134,   2, 'e', 'q',   3, 226,\n+    137, 151,  11, 'l', 'e', 'a', 'r', 'r', 'o', 'w', 'l', 'e', 'f', 't',   3,\n+    226, 134, 186,  12, 'l', 'e', 'a', 'r', 'r', 'o', 'w', 'r', 'i', 'g', 'h',\n+    't',   3, 226, 134, 187,   4, 'l', 'e', 'd', 'R',   2, 194, 174,   4, 'l',\n+    'e', 'd', 'S',   3, 226, 147, 136,   6, 'l', 'e', 'd', 'a', 's', 't',   3,\n+    226, 138, 155,   7, 'l', 'e', 'd', 'c', 'i', 'r', 'c',   3, 226, 138, 154,\n+      7, 'l', 'e', 'd', 'd', 'a', 's', 'h',   3, 226, 138, 157,   1, 'e',   3,\n+    226, 137, 151,   5, 'f', 'n', 'i', 'n', 't',   3, 226, 168, 144,   3, 'm',\n+    'i', 'd',   3, 226, 171, 175,   4, 's', 'c', 'i', 'r',   3, 226, 167, 130,\n+     68, 'l', 'u', 'b', 's',  57,   1,   3, 226, 153, 163,   3, 'u', 'i', 't',\n+      3, 226, 153, 163,  68, 'o', 'l', 'o', 'n',  57,   1,   1, ':',  65, 'e',\n+      1,   1,   3, 226, 137, 148,   1, 'q',   3, 226, 137, 148,  68, 'o', 'm',\n+    'm', 'a',  58,   1,   1, ',',   1, 't',   1, '@',  67, 'o', 'm', 'p',  58,\n+      3,   3, 226, 136, 129,   2, 'f', 'n',   3, 226, 136, 152,   6, 'l', 'e',\n+    'm', 'e', 'n', 't',   3, 226, 136, 129,   5, 'l', 'e', 'x', 'e', 's',   3,\n+    226, 132, 130,  67, 'o', 'n', 'g',  60,   1,   3, 226, 137, 133,   3, 'd',\n+    'o', 't',   3, 226, 169, 173,   5, 'o', 'n', 'i', 'n', 't',   3, 226, 136,\n+    174,   3, 'o', 'p', 'f',   4, 240, 157, 149, 148,   5, 'o', 'p', 'r', 'o',\n+    'd',   3, 226, 136, 144, 195, 'o', 'p', 'y',  57,   1,   2, 194, 169,   2,\n+    's', 'r',   3, 226, 132, 151,   4, 'r', 'a', 'r', 'r',   3, 226, 134, 181,\n+      4, 'r', 'o', 's', 's',   3, 226, 156, 151,   3, 's', 'c', 'r',   4, 240,\n+    157, 146, 184,  67, 's', 'u', 'b',  54,   1,   3, 226, 171, 143,   1, 'e',\n+      3, 226, 171, 145,  67, 's', 'u', 'p',  54,   1,   3, 226, 171, 144,   1,\n+    'e',   3, 226, 171, 146,   4, 't', 'd', 'o', 't',   3, 226, 139, 175,   6,\n+    'u', 'd', 'a', 'r', 'r', 'l',   3, 226, 164, 184,   6, 'u', 'd', 'a', 'r',\n+    'r', 'r',   3, 226, 164, 181,   4, 'u', 'e', 'p', 'r',   3, 226, 139, 158,\n+      4, 'u', 'e', 's', 'c',   3, 226, 139, 159,  69, 'u', 'l', 'a', 'r', 'r',\n+     49,   1,   3, 226, 134, 182,   1, 'p',   3, 226, 164, 189,  66, 'u', 'p',\n+     49,   6,   3, 226, 136, 170,   5, 'b', 'r', 'c', 'a', 'p',   3, 226, 169,\n+    136,   3, 'c', 'a', 'p',   3, 226, 169, 134,   3, 'c', 'u', 'p',   3, 226,\n+    169, 138,   3, 'd', 'o', 't',   3, 226, 138, 141,   2, 'o', 'r',   3, 226,\n+    169, 133,   1, 's',   6, 226, 136, 170, 239, 184, 128,  69, 'u', 'r', 'a',\n+    'r', 'r',  54,   1,   3, 226, 134, 183,   1, 'm',   3, 226, 164, 188,  10,\n+    'u', 'r', 'l', 'y', 'e', 'q', 'p', 'r', 'e', 'c',   3, 226, 139, 158,  10,\n+    'u', 'r', 'l', 'y', 'e', 'q', 's', 'u', 'c', 'c',   3, 226, 139, 159,   7,\n+    'u', 'r', 'l', 'y', 'v', 'e', 'e',   3, 226, 139, 142,   9, 'u', 'r', 'l',\n+    'y', 'w', 'e', 'd', 'g', 'e',   3, 226, 139, 143, 133, 'u', 'r', 'r', 'e',\n+    'n',   2, 194, 164,  13, 'u', 'r', 'v', 'e', 'a', 'r', 'r', 'o', 'w', 'l',\n+    'e', 'f', 't',   3, 226, 134, 182,  14, 'u', 'r', 'v', 'e', 'a', 'r', 'r',\n+    'o', 'w', 'r', 'i', 'g', 'h', 't',   3, 226, 134, 183,   4, 'u', 'v', 'e',\n+    'e',   3, 226, 139, 142,   4, 'u', 'w', 'e', 'd',   3, 226, 139, 143,   7,\n+    'w', 'c', 'o', 'n', 'i', 'n', 't',   3, 226, 136, 178,   4, 'w', 'i', 'n',\n+    't',   3, 226, 136, 177,   5, 'y', 'l', 'c', 't', 'y',   3, 226, 140, 173,\n+      3, 'A', 'r', 'r',   3, 226, 135, 147,   3, 'H', 'a', 'r',   3, 226, 165,\n+    165,   5, 'a', 'g', 'g', 'e', 'r',   3, 226, 128, 160,   5, 'a', 'l', 'e',\n+    't', 'h',   3, 226, 132, 184,   3, 'a', 'r', 'r',   3, 226, 134, 147,  67,\n+    'a', 's', 'h',  43,   1,   3, 226, 128, 144,   1, 'v',   3, 226, 138, 163,\n+      6, 'b', 'k', 'a', 'r', 'o', 'w',   3, 226, 164, 143,   4, 'b', 'l', 'a',\n+    'c',   2, 203, 157,   5, 'c', 'a', 'r', 'o', 'n',   2, 196, 143,   2, 'c',\n+    'y',   2, 208, 180,  65, 'd',  39,   3,   3, 226, 133, 134,   5, 'a', 'g',\n+    'g', 'e', 'r',   3, 226, 128, 161,   3, 'a', 'r', 'r',   3, 226, 135, 138,\n+      5, 'o', 't', 's', 'e', 'q',   3, 226, 169, 183, 130, 'e', 'g',   2, 194,\n+    176,   4, 'e', 'l', 't', 'a',   2, 206, 180,   6, 'e', 'm', 'p', 't', 'y',\n+    'v',   3, 226, 166, 177,   5, 'f', 'i', 's', 'h', 't',   3, 226, 165, 191,\n+      2, 'f', 'r',   4, 240, 157, 148, 161,   4, 'h', 'a', 'r', 'l',   3, 226,\n+    135, 131,   4, 'h', 'a', 'r', 'r',   3, 226, 135, 130,  67, 'i', 'a', 'm',\n+     34,   2,   3, 226, 139, 132,  67, 'o', 'n', 'd',   2,   1,   3, 226, 139,\n+    132,   4, 's', 'u', 'i', 't',   3, 226, 153, 166,   1, 's',   3, 226, 153,\n+    166,   2, 'i', 'e',   2, 194, 168,   6, 'i', 'g', 'a', 'm', 'm', 'a',   2,\n+    207, 157,   4, 'i', 's', 'i', 'n',   3, 226, 139, 178,  66, 'i', 'v',  33,\n+      2,   2, 195, 183, 195, 'i', 'd', 'e',   2,   1,   2, 195, 183,   7, 'o',\n+    'n', 't', 'i', 'm', 'e', 's',   3, 226, 139, 135,   3, 'o', 'n', 'x',   3,\n+    226, 139, 135,   3, 'j', 'c', 'y',   2, 209, 146,   5, 'l', 'c', 'o', 'r',\n+    'n',   3, 226, 140, 158,   5, 'l', 'c', 'r', 'o', 'p',   3, 226, 140, 141,\n+      5, 'o', 'l', 'l', 'a', 'r',   1, '$',   3, 'o', 'p', 'f',   4, 240, 157,\n+    149, 149,  66, 'o', 't',  30,   4,   2, 203, 153,  66, 'e', 'q',   4,   1,\n+      3, 226, 137, 144,   3, 'd', 'o', 't',   3, 226, 137, 145,   5, 'm', 'i',\n+    'n', 'u', 's',   3, 226, 136, 184,   4, 'p', 'l', 'u', 's',   3, 226, 136,\n+    148,   6, 's', 'q', 'u', 'a', 'r', 'e',   3, 226, 138, 161,  13, 'o', 'u',\n+    'b', 'l', 'e', 'b', 'a', 'r', 'w', 'e', 'd', 'g', 'e',   3, 226, 140, 134,\n+      8, 'o', 'w', 'n', 'a', 'r', 'r', 'o', 'w',   3, 226, 134, 147,  13, 'o',\n+    'w', 'n', 'd', 'o', 'w', 'n', 'a', 'r', 'r', 'o', 'w', 's',   3, 226, 135,\n+    138,  14, 'o', 'w', 'n', 'h', 'a', 'r', 'p', 'o', 'o', 'n', 'l', 'e', 'f',\n+    't',   3, 226, 135, 131,  15, 'o', 'w', 'n', 'h', 'a', 'r', 'p', 'o', 'o',\n+    'n', 'r', 'i', 'g', 'h', 't',   3, 226, 135, 130,   7, 'r', 'b', 'k', 'a',\n+    'r', 'o', 'w',   3, 226, 164, 144,   5, 'r', 'c', 'o', 'r', 'n',   3, 226,\n+    140, 159,   5, 'r', 'c', 'r', 'o', 'p',   3, 226, 140, 140,   3, 's', 'c',\n+    'r',   4, 240, 157, 146, 185,   3, 's', 'c', 'y',   2, 209, 149,   3, 's',\n+    'o', 'l',   3, 226, 167, 182,   5, 's', 't', 'r', 'o', 'k',   2, 196, 145,\n+      4, 't', 'd', 'o', 't',   3, 226, 139, 177,  67, 't', 'r', 'i',  21,   1,\n+      3, 226, 150, 191,   1, 'f',   3, 226, 150, 190,   4, 'u', 'a', 'r', 'r',\n+      3, 226, 135, 181,   4, 'u', 'h', 'a', 'r',   3, 226, 165, 175,   6, 'w',\n+    'a', 'n', 'g', 'l', 'e',   3, 226, 166, 166,   3, 'z', 'c', 'y',   2, 209,\n+    159,   7, 'z', 'i', 'g', 'r', 'a', 'r', 'r',   3, 226, 159, 191,   4, 'D',\n+    'D', 'o', 't',   3, 226, 169, 183,   3, 'D', 'o', 't',   3, 226, 137, 145,\n+    133, 'a', 'c', 'u', 't', 'e',   2, 195, 169,   5, 'a', 's', 't', 'e', 'r',\n+      3, 226, 169, 174,   5, 'c', 'a', 'r', 'o', 'n',   2, 196, 155,  67, 'c',\n+    'i', 'r',  41,   1,   3, 226, 137, 150, 129, 'c',   2, 195, 170,   5, 'c',\n+    'o', 'l', 'o', 'n',   3, 226, 137, 149,   2, 'c', 'y',   2, 209, 141,   3,\n+    'd', 'o', 't',   2, 196, 151,   1, 'e',   3, 226, 133, 135,   4, 'f', 'D',\n+    'o', 't',   3, 226, 137, 146,   2, 'f', 'r',   4, 240, 157, 148, 162,  65,\n+    'g',  35,   2,   3, 226, 170, 154, 132, 'r', 'a', 'v', 'e',   2, 195, 168,\n+     65, 's',   1,   1,   3, 226, 170, 150,   3, 'd', 'o', 't',   3, 226, 170,\n+    152,  65, 'l',  37,   3,   3, 226, 170, 153,   6, 'i', 'n', 't', 'e', 'r',\n+    's',   3, 226, 143, 167,   1, 'l',   3, 226, 132, 147,  65, 's',   1,   1,\n+      3, 226, 170, 149,   3, 'd', 'o', 't',   3, 226, 170, 151,   4, 'm', 'a',\n+    'c', 'r',   2, 196, 147,  68, 'm', 'p', 't', 'y',  39,   2,   3, 226, 136,\n+    133,   3, 's', 'e', 't',   3, 226, 136, 133,   1, 'v',   3, 226, 136, 133,\n+     67, 'm', 's', 'p',  40,   2,   3, 226, 128, 131,   2, '1', '3',   3, 226,\n+    128, 132,   2, '1', '4',   3, 226, 128, 133,   2, 'n', 'g',   2, 197, 139,\n+      3, 'n', 's', 'p',   3, 226, 128, 130,   4, 'o', 'g', 'o', 'n',   2, 196,\n+    153,   3, 'o', 'p', 'f',   4, 240, 157, 149, 150,  67, 'p', 'a', 'r',  37,\n+      1,   3, 226, 139, 149,   2, 's', 'l',   3, 226, 167, 163,   4, 'p', 'l',\n+    'u', 's',   3, 226, 169, 177,  67, 'p', 's', 'i',  36,   2,   2, 206, 181,\n+      3, 'l', 'o', 'n',   2, 206, 181,   1, 'v',   2, 207, 181,   5, 'q', 'c',\n+    'i', 'r', 'c',   3, 226, 137, 150,   6, 'q', 'c', 'o', 'l', 'o', 'n',   3,\n+    226, 137, 149,   4, 'q', 's', 'i', 'm',   3, 226, 137, 130,   9, 'q', 's',\n+    'l', 'a', 'n', 't', 'g', 't', 'r',   3, 226, 170, 150,  10, 'q', 's', 'l',\n+    'a', 'n', 't', 'l', 'e', 's', 's',   3, 226, 170, 149,   5, 'q', 'u', 'a',\n+    'l', 's',   1, '=',   5, 'q', 'u', 'e', 's', 't',   3, 226, 137, 159,  68,\n+    'q', 'u', 'i', 'v',  30,   1,   3, 226, 137, 161,   2, 'D', 'D',   3, 226,\n+    169, 184,   7, 'q', 'v', 'p', 'a', 'r', 's', 'l',   3, 226, 167, 165,   4,\n+    'r', 'D', 'o', 't',   3, 226, 137, 147,   4, 'r', 'a', 'r', 'r',   3, 226,\n+    165, 177,   3, 's', 'c', 'r',   3, 226, 132, 175,   4, 's', 'd', 'o', 't',\n+      3, 226, 137, 144,   3, 's', 'i', 'm',   3, 226, 137, 130,   2, 't', 'a',\n+      2, 206, 183, 130, 't', 'h',   2, 195, 176, 131, 'u', 'm', 'l',   2, 195,\n+    171,   3, 'u', 'r', 'o',   3, 226, 130, 172,   3, 'x', 'c', 'l',   1, '!',\n+      4, 'x', 'i', 's', 't',   3, 226, 136, 131,  10, 'x', 'p', 'e', 'c', 't',\n+    'a', 't', 'i', 'o', 'n',   3, 226, 132, 176,  11, 'x', 'p', 'o', 'n', 'e',\n+    'n', 't', 'i', 'a', 'l', 'e',   3, 226, 133, 135,  12, 'a', 'l', 'l', 'i',\n+    'n', 'g', 'd', 'o', 't', 's', 'e', 'q',   3, 226, 137, 146,   2, 'c', 'y',\n+      2, 209, 132,   5, 'e', 'm', 'a', 'l', 'e',   3, 226, 153, 128,   5, 'f',\n+    'i', 'l', 'i', 'g',   3, 239, 172, 131,   4, 'f', 'l', 'i', 'g',   3, 239,\n+    172, 128,   5, 'f', 'l', 'l', 'i', 'g',   3, 239, 172, 132,   2, 'f', 'r',\n+      4, 240, 157, 148, 163,   4, 'i', 'l', 'i', 'g',   3, 239, 172, 129,   4,\n+    'j', 'l', 'i', 'g',   2, 'f', 'j',   3, 'l', 'a', 't',   3, 226, 153, 173,\n+      4, 'l', 'l', 'i', 'g',   3, 239, 172, 130,   4, 'l', 't', 'n', 's',   3,\n+    226, 150, 177,   3, 'n', 'o', 'f',   2, 198, 146,   3, 'o', 'p', 'f',   4,\n+    240, 157, 149, 151,   5, 'o', 'r', 'a', 'l', 'l',   3, 226, 136, 128,  67,\n+    'o', 'r', 'k',  20,   1,   3, 226, 139, 148,   1, 'v',   3, 226, 171, 153,\n+      7, 'p', 'a', 'r', 't', 'i', 'n', 't',   3, 226, 168, 141, 133, 'r', 'a',\n+    'c', '1', '2',   2, 194, 189,   5, 'r', 'a', 'c', '1', '3',   3, 226, 133,\n+    147, 133, 'r', 'a', 'c', '1', '4',   2, 194, 188,   5, 'r', 'a', 'c', '1',\n+    '5',   3, 226, 133, 149,   5, 'r', 'a', 'c', '1', '6',   3, 226, 133, 153,\n+      5, 'r', 'a', 'c', '1', '8',   3, 226, 133, 155,   5, 'r', 'a', 'c', '2',\n+    '3',   3, 226, 133, 148,   5, 'r', 'a', 'c', '2', '5',   3, 226, 133, 150,\n+    133, 'r', 'a', 'c', '3', '4',   2, 194, 190,   5, 'r', 'a', 'c', '3', '5',\n+      3, 226, 133, 151,   5, 'r', 'a', 'c', '3', '8',   3, 226, 133, 156,   5,\n+    'r', 'a', 'c', '4', '5',   3, 226, 133, 152,   5, 'r', 'a', 'c', '5', '6',\n+      3, 226, 133, 154,   5, 'r', 'a', 'c', '5', '8',   3, 226, 133, 157,   5,\n+    'r', 'a', 'c', '7', '8',   3, 226, 133, 158,   4, 'r', 'a', 's', 'l',   3,\n+    226, 129, 132,   4, 'r', 'o', 'w', 'n',   3, 226, 140, 162,   3, 's', 'c',\n+    'r',   4, 240, 157, 146, 187,  65, 'E',  25,   1,   3, 226, 137, 167,   1,\n+    'l',   3, 226, 170, 140,   5, 'a', 'c', 'u', 't', 'e',   2, 199, 181,  68,\n+    'a', 'm', 'm', 'a',  24,   1,   2, 206, 179,   1, 'd',   2, 207, 157,   2,\n+    'a', 'p',   3, 226, 170, 134,   5, 'b', 'r', 'e', 'v', 'e',   2, 196, 159,\n+      4, 'c', 'i', 'r', 'c',   2, 196, 157,   2, 'c', 'y',   2, 208, 179,   3,\n+    'd', 'o', 't',   2, 196, 161,  65, 'e',  19,   3,   3, 226, 137, 165,   1,\n+    'l',   3, 226, 139, 155,  65, 'q',   2,   2,   3, 226, 137, 165,   1, 'q',\n+      3, 226, 137, 167,   5, 's', 'l', 'a', 'n', 't',   3, 226, 169, 190,  65,\n+    's',   3,   3,   3, 226, 169, 190,   2, 'c', 'c',   3, 226, 170, 169,  67,\n+    'd', 'o', 't',   2,   1,   3, 226, 170, 128,  65, 'o',   1,   1,   3, 226,\n+    170, 130,   1, 'l',   3, 226, 170, 132,  65, 'l',   3,   1,   6, 226, 139,\n+    155, 239, 184, 128,   2, 'e', 's',   3, 226, 170, 148,   2, 'f', 'r',   4,\n+    240, 157, 148, 164,  65, 'g',  28,   1,   3, 226, 137, 171,   1, 'g',   3,\n+    226, 139, 153,   4, 'i', 'm', 'e', 'l',   3, 226, 132, 183,   3, 'j', 'c',\n+    'y',   2, 209, 147,  65, 'l',  26,   3,   3, 226, 137, 183,   1, 'E',   3,\n+    226, 170, 146,   1, 'a',   3, 226, 170, 165,   1, 'j',   3, 226, 170, 164,\n+      2, 'n', 'E',   3, 226, 137, 169,  67, 'n', 'a', 'p',  27,   1,   3, 226,\n+    170, 138,   4, 'p', 'r', 'o', 'x',   3, 226, 170, 138,  66, 'n', 'e',  27,\n+      1,   3, 226, 170, 136,  65, 'q',   1,   1,   3, 226, 170, 136,   1, 'q',\n+      3, 226, 137, 169,   4, 'n', 's', 'i', 'm',   3, 226, 139, 167,   3, 'o',\n+    'p', 'f',   4, 240, 157, 149, 152,   4, 'r', 'a', 'v', 'e',   1, '`',   3,\n+    's', 'c', 'r',   3, 226, 132, 138,  67, 's', 'i', 'm',  24,   2,   3, 226,\n+    137, 179,   1, 'e',   3, 226, 170, 142,   1, 'l',   3, 226, 170, 144, 193,\n+    't',  25,  12,   1, '>',   2, 'c', 'c',   3, 226, 170, 167,   3, 'c', 'i',\n+    'r',   3, 226, 169, 186,   3, 'd', 'o', 't',   3, 226, 139, 151,   4, 'l',\n+    'P', 'a', 'r',   3, 226, 166, 149,   5, 'q', 'u', 'e', 's', 't',   3, 226,\n+    169, 188,   7, 'r', 'a', 'p', 'p', 'r', 'o', 'x',   3, 226, 170, 134,   4,\n+    'r', 'a', 'r', 'r',   3, 226, 165, 184,   4, 'r', 'd', 'o', 't',   3, 226,\n+    139, 151,   7, 'r', 'e', 'q', 'l', 'e', 's', 's',   3, 226, 139, 155,   8,\n+    'r', 'e', 'q', 'q', 'l', 'e', 's', 's',   3, 226, 170, 140,   5, 'r', 'l',\n+    'e', 's', 's',   3, 226, 137, 183,   4, 'r', 's', 'i', 'm',   3, 226, 137,\n+    179,   8, 'v', 'e', 'r', 't', 'n', 'e', 'q', 'q',   6, 226, 137, 169, 239,\n+    184, 128,   3, 'v', 'n', 'E',   6, 226, 137, 169, 239, 184, 128,   3, 'A',\n+    'r', 'r',   3, 226, 135, 148,   5, 'a', 'i', 'r', 's', 'p',   3, 226, 128,\n+    138,   3, 'a', 'l', 'f',   2, 194, 189,   5, 'a', 'm', 'i', 'l', 't',   3,\n+    226, 132, 139,   5, 'a', 'r', 'd', 'c', 'y',   2, 209, 138,  67, 'a', 'r',\n+    'r',  20,   2,   3, 226, 134, 148,   3, 'c', 'i', 'r',   3, 226, 165, 136,\n+      1, 'w',   3, 226, 134, 173,   3, 'b', 'a', 'r',   3, 226, 132, 143,   4,\n+    'c', 'i', 'r', 'c',   2, 196, 165,  69, 'e', 'a', 'r', 't', 's',  19,   1,\n+      3, 226, 153, 165,   3, 'u', 'i', 't',   3, 226, 153, 165,   5, 'e', 'l',\n+    'l', 'i', 'p',   3, 226, 128, 166,   5, 'e', 'r', 'c', 'o', 'n',   3, 226,\n+    138, 185,   2, 'f', 'r',   4, 240, 157, 148, 165,   7, 'k', 's', 'e', 'a',\n+    'r', 'o', 'w',   3, 226, 164, 165,   7, 'k', 's', 'w', 'a', 'r', 'o', 'w',\n+      3, 226, 164, 166,   4, 'o', 'a', 'r', 'r',   3, 226, 135, 191,   5, 'o',\n+    'm', 't', 'h', 't',   3, 226, 136, 187,  12, 'o', 'o', 'k', 'l', 'e', 'f',\n+    't', 'a', 'r', 'r', 'o', 'w',   3, 226, 134, 169,  13, 'o', 'o', 'k', 'r',\n+    'i', 'g', 'h', 't', 'a', 'r', 'r', 'o', 'w',   3, 226, 134, 170,   3, 'o',\n+    'p', 'f',   4, 240, 157, 149, 153,   5, 'o', 'r', 'b', 'a', 'r',   3, 226,\n+    128, 149,   3, 's', 'c', 'r',   4, 240, 157, 146, 189,   5, 's', 'l', 'a',\n+    's', 'h',   3, 226, 132, 143,   5, 's', 't', 'r', 'o', 'k',   2, 196, 167,\n+      5, 'y', 'b', 'u', 'l', 'l',   3, 226, 129, 131,   5, 'y', 'p', 'h', 'e',\n+    'n',   3, 226, 128, 144, 133, 'a', 'c', 'u', 't', 'e',   2, 195, 173,  65,\n+    'c',  27,   2,   3, 226, 129, 163, 131, 'i', 'r', 'c',   2, 195, 174,   1,\n+    'y',   2, 208, 184,   3, 'e', 'c', 'y',   2, 208, 181, 132, 'e', 'x', 'c',\n+    'l',   2, 194, 161,   2, 'f', 'f',   3, 226, 135, 148,   2, 'f', 'r',   4,\n+    240, 157, 148, 166, 133, 'g', 'r', 'a', 'v', 'e',   2, 195, 172,  65, 'i',\n+     23,   4,   3, 226, 133, 136,   4, 'i', 'i', 'n', 't',   3, 226, 168, 140,\n+      3, 'i', 'n', 't',   3, 226, 136, 173,   4, 'n', 'f', 'i', 'n',   3, 226,\n+    167, 156,   3, 'o', 't', 'a',   3, 226, 132, 169,   4, 'j', 'l', 'i', 'g',\n+      2, 196, 179,   4, 'm', 'a', 'c', 'r',   2, 196, 171,   4, 'm', 'a', 'g',\n+    'e',   3, 226, 132, 145,   7, 'm', 'a', 'g', 'l', 'i', 'n', 'e',   3, 226,\n+    132, 144,   7, 'm', 'a', 'g', 'p', 'a', 'r', 't',   3, 226, 132, 145,   4,\n+    'm', 'a', 't', 'h',   2, 196, 177,   3, 'm', 'o', 'f',   3, 226, 138, 183,\n+      4, 'm', 'p', 'e', 'd',   2, 198, 181,  65, 'n',  18,   4,   3, 226, 136,\n+    136,   4, 'c', 'a', 'r', 'e',   3, 226, 132, 133,  67, 'f', 'i', 'n',   3,\n+      1,   3, 226, 136, 158,   3, 't', 'i', 'e',   3, 226, 167, 157,   4, 'o',\n+    'd', 'o', 't',   2, 196, 177,  65, 't',   2,   5,   3, 226, 136, 171,   3,\n+    'c', 'a', 'l',   3, 226, 138, 186,   5, 'e', 'g', 'e', 'r', 's',   3, 226,\n+    132, 164,   5, 'e', 'r', 'c', 'a', 'l',   3, 226, 138, 186,   5, 'l', 'a',\n+    'r', 'h', 'k',   3, 226, 168, 151,   4, 'p', 'r', 'o', 'd',   3, 226, 168,\n+    188,   3, 'o', 'c', 'y',   2, 209, 145,   4, 'o', 'g', 'o', 'n',   2, 196,\n+    175,   3, 'o', 'p', 'f',   4, 240, 157, 149, 154,   3, 'o', 't', 'a',   2,\n+    206, 185,   4, 'p', 'r', 'o', 'd',   3, 226, 168, 188, 133, 'q', 'u', 'e',\n+    's', 't',   2, 194, 191,   3, 's', 'c', 'r',   4, 240, 157, 146, 190,  67,\n+    's', 'i', 'n',  20,   4,   3, 226, 136, 136,   1, 'E',   3, 226, 139, 185,\n+      3, 'd', 'o', 't',   3, 226, 139, 181,  65, 's',   2,   1,   3, 226, 139,\n+    180,   1, 'v',   3, 226, 139, 179,   1, 'v',   3, 226, 136, 136,  65, 't',\n+     24,   1,   3, 226, 129, 162,   4, 'i', 'l', 'd', 'e',   2, 196, 169,   4,\n+    'u', 'k', 'c', 'y',   2, 209, 150, 131, 'u', 'm', 'l',   2, 195, 175,   4,\n+    'c', 'i', 'r', 'c',   2, 196, 181,   2, 'c', 'y',   2, 208, 185,   2, 'f',\n+    'r',   4, 240, 157, 148, 167,   4, 'm', 'a', 't', 'h',   2, 200, 183,   3,\n+    'o', 'p', 'f',   4, 240, 157, 149, 155,   3, 's', 'c', 'r',   4, 240, 157,\n+    146, 191,   5, 's', 'e', 'r', 'c', 'y',   2, 209, 152,   4, 'u', 'k', 'c',\n+    'y',   2, 209, 148,  68, 'a', 'p', 'p', 'a',   9,   1,   2, 206, 186,   1,\n+    'v',   2, 207, 176,   5, 'c', 'e', 'd', 'i', 'l',   2, 196, 183,   2, 'c',\n+    'y',   2, 208, 186,   2, 'f', 'r',   4, 240, 157, 148, 168,   5, 'g', 'r',\n+    'e', 'e', 'n',   2, 196, 184,   3, 'h', 'c', 'y',   2, 209, 133,   3, 'j',\n+    'c', 'y',   2, 209, 156,   3, 'o', 'p', 'f',   4, 240, 157, 149, 156,   3,\n+    's', 'c', 'r',   4, 240, 157, 147, 128,   4, 'A', 'a', 'r', 'r',   3, 226,\n+    135, 154,   3, 'A', 'r', 'r',   3, 226, 135, 144,   5, 'A', 't', 'a', 'i',\n+    'l',   3, 226, 164, 155,   4, 'B', 'a', 'r', 'r',   3, 226, 164, 142,  65,\n+    'E',  78,   1,   3, 226, 137, 166,   1, 'g',   3, 226, 170, 139,   3, 'H',\n+    'a', 'r',   3, 226, 165, 162,   5, 'a', 'c', 'u', 't', 'e',   2, 196, 186,\n+      7, 'a', 'e', 'm', 'p', 't', 'y', 'v',   3, 226, 166, 180,   5, 'a', 'g',\n+    'r', 'a', 'n',   3, 226, 132, 146,   5, 'a', 'm', 'b', 'd', 'a',   2, 206,\n+    187,  67, 'a', 'n', 'g',  73,   2,   3, 226, 159, 168,   1, 'd',   3, 226,\n+    166, 145,   2, 'l', 'e',   3, 226, 159, 168,   2, 'a', 'p',   3, 226, 170,\n+    133, 132, 'a', 'q', 'u', 'o',   2, 194, 171,  67, 'a', 'r', 'r',  72,   7,\n+      3, 226, 134, 144,  65, 'b',   7,   1,   3, 226, 135, 164,   2, 'f', 's',\n+      3, 226, 164, 159,   2, 'f', 's',   3, 226, 164, 157,   2, 'h', 'k',   3,\n+    226, 134, 169,   2, 'l', 'p',   3, 226, 134, 171,   2, 'p', 'l',   3, 226,\n+    164, 185,   3, 's', 'i', 'm',   3, 226, 165, 179,   2, 't', 'l',   3, 226,\n+    134, 162,  66, 'a', 't',  79,   2,   3, 226, 170, 171,   3, 'a', 'i', 'l',\n+      3, 226, 164, 153,  65, 'e',   1,   1,   3, 226, 170, 173,   1, 's',   6,\n+    226, 170, 173, 239, 184, 128,   4, 'b', 'a', 'r', 'r',   3, 226, 164, 140,\n+      4, 'b', 'b', 'r', 'k',   3, 226, 157, 178,   5, 'b', 'r', 'a', 'c', 'e',\n+      1, '{',   5, 'b', 'r', 'a', 'c', 'k',   1, '[',   4, 'b', 'r', 'k', 'e',\n+      3, 226, 166, 139,   6, 'b', 'r', 'k', 's', 'l', 'd',   3, 226, 166, 143,\n+      6, 'b', 'r', 'k', 's', 'l', 'u',   3, 226, 166, 141,   5, 'c', 'a', 'r',\n+    'o', 'n',   2, 196, 190,   5, 'c', 'e', 'd', 'i', 'l',   2, 196, 188,   4,\n+    'c', 'e', 'i', 'l',   3, 226, 140, 136,   3, 'c', 'u', 'b',   1, '{',   2,\n+    'c', 'y',   2, 208, 187,   3, 'd', 'c', 'a',   3, 226, 164, 182,  68, 'd',\n+    'q', 'u', 'o',  68,   1,   3, 226, 128, 156,   1, 'r',   3, 226, 128, 158,\n+      6, 'd', 'r', 'd', 'h', 'a', 'r',   3, 226, 165, 167,   7, 'd', 'r', 'u',\n+    's', 'h', 'a', 'r',   3, 226, 165, 139,   3, 'd', 's', 'h',   3, 226, 134,\n+    178,  65, 'e',  65,  11,   3, 226, 137, 164,  71, 'f', 't', 'a', 'r', 'r',\n+    'o', 'w',  11,   1,   3, 226, 134, 144,   4, 't', 'a', 'i', 'l',   3, 226,\n+    134, 162,  13, 'f', 't', 'h', 'a', 'r', 'p', 'o', 'o', 'n', 'd', 'o', 'w',\n+    'n',   3, 226, 134, 189,  11, 'f', 't', 'h', 'a', 'r', 'p', 'o', 'o', 'n',\n+    'u', 'p',   3, 226, 134, 188,  12, 'f', 't', 'l', 'e', 'f', 't', 'a', 'r',\n+    'r', 'o', 'w', 's',   3, 226, 135, 135,  76, 'f', 't', 'r', 'i', 'g', 'h',\n+    't', 'a', 'r', 'r', 'o', 'w',   8,   1,   3, 226, 134, 148,   1, 's',   3,\n+    226, 135, 134,  15, 'f', 't', 'r', 'i', 'g', 'h', 't', 'h', 'a', 'r', 'p',\n+    'o', 'o', 'n', 's',   3, 226, 135, 139,  17, 'f', 't', 'r', 'i', 'g', 'h',\n+    't', 's', 'q', 'u', 'i', 'g', 'a', 'r', 'r', 'o', 'w',   3, 226, 134, 173,\n+     12, 'f', 't', 't', 'h', 'r', 'e', 'e', 't', 'i', 'm', 'e', 's',   3, 226,\n+    139, 139,   1, 'g',   3, 226, 139, 154,  65, 'q',   4,   2,   3, 226, 137,\n+    164,   1, 'q',   3, 226, 137, 166,   5, 's', 'l', 'a', 'n', 't',   3, 226,\n+    169, 189,  65, 's',   5,   9,   3, 226, 169, 189,   2, 'c', 'c',   3, 226,\n+    170, 168,  67, 'd', 'o', 't',   8,   1,   3, 226, 169, 191,  65, 'o',   1,\n+      1,   3, 226, 170, 129,   1, 'r',   3, 226, 170, 131,  65, 'g',   9,   1,\n+      6, 226, 139, 154, 239, 184, 128,   2, 'e', 's',   3, 226, 170, 147,   7,\n+    's', 'a', 'p', 'p', 'r', 'o', 'x',   3, 226, 170, 133,   4, 's', 'd', 'o',\n+    't',   3, 226, 139, 150,   6, 's', 'e', 'q', 'g', 't', 'r',   3, 226, 139,\n+    154,   7, 's', 'e', 'q', 'q', 'g', 't', 'r',   3, 226, 170, 139,   4, 's',\n+    'g', 't', 'r',   3, 226, 137, 182,   4, 's', 's', 'i', 'm',   3, 226, 137,\n+    178,   5, 'f', 'i', 's', 'h', 't',   3, 226, 165, 188,   5, 'f', 'l', 'o',\n+    'o', 'r',   3, 226, 140, 138,   2, 'f', 'r',   4, 240, 157, 148, 169,  65,\n+    'g',  88,   1,   3, 226, 137, 182,   1, 'E',   3, 226, 170, 145,   4, 'h',\n+    'a', 'r', 'd',   3, 226, 134, 189,  68, 'h', 'a', 'r', 'u',  87,   1,   3,\n+    226, 134, 188,   1, 'l',   3, 226, 165, 170,   4, 'h', 'b', 'l', 'k',   3,\n+    226, 150, 132,   3, 'j', 'c', 'y',   2, 209, 153,  65, 'l',  85,   4,   3,\n+    226, 137, 170,   3, 'a', 'r', 'r',   3, 226, 135, 135,   6, 'c', 'o', 'r',\n+    'n', 'e', 'r',   3, 226, 140, 158,   4, 'h', 'a', 'r', 'd',   3, 226, 165,\n+    171,   3, 't', 'r', 'i',   3, 226, 151, 186,   5, 'm', 'i', 'd', 'o', 't',\n+      2, 197, 128,  69, 'm', 'o', 'u', 's', 't',  87,   1,   3, 226, 142, 176,\n+      4, 'a', 'c', 'h', 'e',   3, 226, 142, 176,   2, 'n', 'E',   3, 226, 137,\n+    168,  67, 'n', 'a', 'p',  86,   1,   3, 226, 170, 137,   4, 'p', 'r', 'o',\n+    'x',   3, 226, 170, 137,  66, 'n', 'e',  86,   1,   3, 226, 170, 135,  65,\n+    'q',   1,   1,   3, 226, 170, 135,   1, 'q',   3, 226, 137, 168,   4, 'n',\n+    's', 'i', 'm',   3, 226, 139, 166,   4, 'o', 'a', 'n', 'g',   3, 226, 159,\n+    172,   4, 'o', 'a', 'r', 'r',   3, 226, 135, 189,   4, 'o', 'b', 'r', 'k',\n+      3, 226, 159, 166,  12, 'o', 'n', 'g', 'l', 'e', 'f', 't', 'a', 'r', 'r',\n+    'o', 'w',   3, 226, 159, 181,  17, 'o', 'n', 'g', 'l', 'e', 'f', 't', 'r',\n+    'i', 'g', 'h', 't', 'a', 'r', 'r', 'o', 'w',   3, 226, 159, 183,   9, 'o',\n+    'n', 'g', 'm', 'a', 'p', 's', 't', 'o',   3, 226, 159, 188,  13, 'o', 'n',\n+    'g', 'r', 'i', 'g', 'h', 't', 'a', 'r', 'r', 'o', 'w',   3, 226, 159, 182,\n+     12, 'o', 'o', 'p', 'a', 'r', 'r', 'o', 'w', 'l', 'e', 'f', 't',   3, 226,\n+    134, 171,  13, 'o', 'o', 'p', 'a', 'r', 'r', 'o', 'w', 'r', 'i', 'g', 'h',\n+    't',   3, 226, 134, 172,   4, 'o', 'p', 'a', 'r',   3, 226, 166, 133,   3,\n+    'o', 'p', 'f',   4, 240, 157, 149, 157,   5, 'o', 'p', 'l', 'u', 's',   3,\n+    226, 168, 173,   6, 'o', 't', 'i', 'm', 'e', 's',   3, 226, 168, 180,   5,\n+    'o', 'w', 'a', 's', 't',   3, 226, 136, 151,   5, 'o', 'w', 'b', 'a', 'r',\n+      1, '_',  66, 'o', 'z',  71,   2,   3, 226, 151, 138,   4, 'e', 'n', 'g',\n+    'e',   3, 226, 151, 138,   1, 'f',   3, 226, 167, 171,  67, 'p', 'a', 'r',\n+     72,   1,   1, '(',   2, 'l', 't',   3, 226, 166, 147,   4, 'r', 'a', 'r',\n+    'r',   3, 226, 135, 134,   7, 'r', 'c', 'o', 'r', 'n', 'e', 'r',   3, 226,\n+    140, 159,  68, 'r', 'h', 'a', 'r',  70,   1,   3, 226, 135, 139,   1, 'd',\n+      3, 226, 165, 173,   2, 'r', 'm',   3, 226, 128, 142,   4, 'r', 't', 'r',\n+    'i',   3, 226, 138, 191,   5, 's', 'a', 'q', 'u', 'o',   3, 226, 128, 185,\n+      3, 's', 'c', 'r',   4, 240, 157, 147, 129,   2, 's', 'h',   3, 226, 134,\n+    176,  67, 's', 'i', 'm',  65,   2,   3, 226, 137, 178,   1, 'e',   3, 226,\n+    170, 141,   1, 'g',   3, 226, 170, 143,   3, 's', 'q', 'b',   1, '[',  68,\n+    's', 'q', 'u', 'o',  65,   1,   3, 226, 128, 152,   1, 'r',   3, 226, 128,\n+    154,   5, 's', 't', 'r', 'o', 'k',   2, 197, 130, 193, 't',  64,   9,   1,\n+    '<',   2, 'c', 'c',   3, 226, 170, 166,   3, 'c', 'i', 'r',   3, 226, 169,\n+    185,   3, 'd', 'o', 't',   3, 226, 139, 150,   4, 'h', 'r', 'e', 'e',   3,\n+    226, 139, 139,   4, 'i', 'm', 'e', 's',   3, 226, 139, 137,   4, 'l', 'a',\n+    'r', 'r',   3, 226, 165, 182,   5, 'q', 'u', 'e', 's', 't',   3, 226, 169,\n+    187,   4, 'r', 'P', 'a', 'r',   3, 226, 166, 150,  66, 'r', 'i',   1,   2,\n+      3, 226, 151, 131,   1, 'e',   3, 226, 138, 180,   1, 'f',   3, 226, 151,\n+    130,   7, 'u', 'r', 'd', 's', 'h', 'a', 'r',   3, 226, 165, 138,   6, 'u',\n+    'r', 'u', 'h', 'a', 'r',   3, 226, 165, 166,   8, 'v', 'e', 'r', 't', 'n',\n+    'e', 'q', 'q',   6, 226, 137, 168, 239, 184, 128,   3, 'v', 'n', 'E',   6,\n+    226, 137, 168, 239, 184, 128,   4, 'D', 'D', 'o', 't',   3, 226, 136, 186,\n+    131, 'a', 'c', 'r',   2, 194, 175,   3, 'a', 'l', 'e',   3, 226, 153, 130,\n+     67, 'a', 'l', 't',  21,   1,   3, 226, 156, 160,   3, 'e', 's', 'e',   3,\n+    226, 156, 160,  66, 'a', 'p',  21,   1,   3, 226, 134, 166,  67, 's', 't',\n+    'o',   1,   3,   3, 226, 134, 166,   4, 'd', 'o', 'w', 'n',   3, 226, 134,\n+    167,   4, 'l', 'e', 'f', 't',   3, 226, 134, 164,   2, 'u', 'p',   3, 226,\n+    134, 165,   5, 'a', 'r', 'k', 'e', 'r',   3, 226, 150, 174,   5, 'c', 'o',\n+    'm', 'm', 'a',   3, 226, 168, 169,   2, 'c', 'y',   2, 208, 188,   4, 'd',\n+    'a', 's', 'h',   3, 226, 128, 148,  12, 'e', 'a', 's', 'u', 'r', 'e', 'd',\n+    'a', 'n', 'g', 'l', 'e',   3, 226, 136, 161,   2, 'f', 'r',   4, 240, 157,\n+    148, 170,   2, 'h', 'o',   3, 226, 132, 167, 132, 'i', 'c', 'r', 'o',   2,\n+    194, 181,  66, 'i', 'd',  16,   3,   3, 226, 136, 163,   3, 'a', 's', 't',\n+      1, '*',   3, 'c', 'i', 'r',   3, 226, 171, 176, 131, 'd', 'o', 't',   2,\n+    194, 183,  68, 'i', 'n', 'u', 's',  18,   2,   3, 226, 136, 146,   1, 'b',\n+      3, 226, 138, 159,  65, 'd',   1,   1,   3, 226, 136, 184,   1, 'u',   3,\n+    226, 168, 170,   3, 'l', 'c', 'p',   3, 226, 171, 155,   3, 'l', 'd', 'r',\n+      3, 226, 128, 166,   5, 'n', 'p', 'l', 'u', 's',   3, 226, 136, 147,   5,\n+    'o', 'd', 'e', 'l', 's',   3, 226, 138, 167,   3, 'o', 'p', 'f',   4, 240,\n+    157, 149, 158,   1, 'p',   3, 226, 136, 147,   3, 's', 'c', 'r',   4, 240,\n+    157, 147, 130,   5, 's', 't', 'p', 'o', 's',   3, 226, 136, 190,  65, 'u',\n+     12,   2,   2, 206, 188,   6, 'l', 't', 'i', 'm', 'a', 'p',   3, 226, 138,\n+    184,   3, 'm', 'a', 'p',   3, 226, 138, 184,   2, 'G', 'g',   5, 226, 139,\n+    153, 204, 184,  66, 'G', 't',  84,   1,   6, 226, 137, 171, 226, 131, 146,\n+      1, 'v',   5, 226, 137, 171, 204, 184,   9, 'L', 'e', 'f', 't', 'a', 'r',\n+    'r', 'o', 'w',   3, 226, 135, 141,  14, 'L', 'e', 'f', 't', 'r', 'i', 'g',\n+    'h', 't', 'a', 'r', 'r', 'o', 'w',   3, 226, 135, 142,   2, 'L', 'l',   5,\n+    226, 139, 152, 204, 184,  66, 'L', 't',  81,   1,   6, 226, 137, 170, 226,\n+    131, 146,   1, 'v',   5, 226, 137, 170, 204, 184,  10, 'R', 'i', 'g', 'h',\n+    't', 'a', 'r', 'r', 'o', 'w',   3, 226, 135, 143,   5, 'V', 'D', 'a', 's',\n+    'h',   3, 226, 138, 175,   5, 'V', 'd', 'a', 's', 'h',   3, 226, 138, 174,\n+      4, 'a', 'b', 'l', 'a',   3, 226, 136, 135,   5, 'a', 'c', 'u', 't', 'e',\n+      2, 197, 132,   3, 'a', 'n', 'g',   6, 226, 136, 160, 226, 131, 146,  66,\n+    'a', 'p',  75,   4,   3, 226, 137, 137,   1, 'E',   5, 226, 169, 176, 204,\n+    184,   2, 'i', 'd',   5, 226, 137, 139, 204, 184,   2, 'o', 's',   2, 197,\n+    137,   4, 'p', 'r', 'o', 'x',   3, 226, 137, 137,  68, 'a', 't', 'u', 'r',\n+     78,   1,   3, 226, 153, 174,  66, 'a', 'l',   1,   1,   3, 226, 153, 174,\n+      1, 's',   3, 226, 132, 149, 131, 'b', 's', 'p',   2, 194, 160,  68, 'b',\n+    'u', 'm', 'p',  78,   1,   5, 226, 137, 142, 204, 184,   1, 'e',   5, 226,\n+    137, 143, 204, 184,   3, 'c', 'a', 'p',   3, 226, 169, 131,   5, 'c', 'a',\n+    'r', 'o', 'n',   2, 197, 136,   5, 'c', 'e', 'd', 'i', 'l',   2, 197, 134,\n+     68, 'c', 'o', 'n', 'g',  75,   1,   3, 226, 137, 135,   3, 'd', 'o', 't',\n+      5, 226, 169, 173, 204, 184,   3, 'c', 'u', 'p',   3, 226, 169, 130,   2,\n+    'c', 'y',   2, 208, 189,   4, 'd', 'a', 's', 'h',   3, 226, 128, 147,  65,\n+    'e',  72,   8,   3, 226, 137, 160,   3, 'A', 'r', 'r',   3, 226, 135, 151,\n+      4, 'a', 'r', 'h', 'k',   3, 226, 164, 164,  67, 'a', 'r', 'r',   6,   1,\n+      3, 226, 134, 151,   2, 'o', 'w',   3, 226, 134, 151,   3, 'd', 'o', 't',\n+      5, 226, 137, 144, 204, 184,   4, 'q', 'u', 'i', 'v',   3, 226, 137, 162,\n+      4, 's', 'e', 'a', 'r',   3, 226, 164, 168,   3, 's', 'i', 'm',   5, 226,\n+    137, 130, 204, 184,  68, 'x', 'i', 's', 't',   2,   1,   3, 226, 136, 132,\n+      1, 's',   3, 226, 136, 132,   2, 'f', 'r',   4, 240, 157, 148, 171,   2,\n+    'g', 'E',   5, 226, 137, 167, 204, 184,  66, 'g', 'e',  79,   2,   3, 226,\n+    137, 177,  65, 'q',   2,   2,   3, 226, 137, 177,   1, 'q',   5, 226, 137,\n+    167, 204, 184,   5, 's', 'l', 'a', 'n', 't',   5, 226, 169, 190, 204, 184,\n+      1, 's',   5, 226, 169, 190, 204, 184,   4, 'g', 's', 'i', 'm',   3, 226,\n+    137, 181,  66, 'g', 't',  81,   1,   3, 226, 137, 175,   1, 'r',   3, 226,\n+    137, 175,   4, 'h', 'A', 'r', 'r',   3, 226, 135, 142,   4, 'h', 'a', 'r',\n+    'r',   3, 226, 134, 174,   4, 'h', 'p', 'a', 'r',   3, 226, 171, 178,  65,\n+    'i',  78,   2,   3, 226, 136, 139,  65, 's',   2,   1,   3, 226, 139, 188,\n+      1, 'd',   3, 226, 139, 186,   1, 'v',   3, 226, 136, 139,   3, 'j', 'c',\n+    'y',   2, 209, 154,   4, 'l', 'A', 'r', 'r',   3, 226, 135, 141,   2, 'l',\n+    'E',   5, 226, 137, 166, 204, 184,   4, 'l', 'a', 'r', 'r',   3, 226, 134,\n+    154,   3, 'l', 'd', 'r',   3, 226, 128, 165,  66, 'l', 'e',  75,   4,   3,\n+    226, 137, 176,   7, 'f', 't', 'a', 'r', 'r', 'o', 'w',   3, 226, 134, 154,\n+     12, 'f', 't', 'r', 'i', 'g', 'h', 't', 'a', 'r', 'r', 'o', 'w',   3, 226,\n+    134, 174,  65, 'q',   2,   2,   3, 226, 137, 176,   1, 'q',   5, 226, 137,\n+    166, 204, 184,   5, 's', 'l', 'a', 'n', 't',   5, 226, 169, 189, 204, 184,\n+     65, 's',   3,   1,   5, 226, 169, 189, 204, 184,   1, 's',   3, 226, 137,\n+    174,   4, 'l', 's', 'i', 'm',   3, 226, 137, 180,  66, 'l', 't',  80,   1,\n+      3, 226, 137, 174,  66, 'r', 'i',   1,   1,   3, 226, 139, 170,   1, 'e',\n+      3, 226, 139, 172,   3, 'm', 'i', 'd',   3, 226, 136, 164,   3, 'o', 'p',\n+    'f',   4, 240, 157, 149, 159, 194, 'o', 't',  79,   2,   2, 194, 172,  66,\n+    'i', 'n',   2,   5,   3, 226, 136, 137,   1, 'E',   5, 226, 139, 185, 204,\n+    184,   3, 'd', 'o', 't',   5, 226, 139, 181, 204, 184,   2, 'v', 'a',   3,\n+    226, 136, 137,   2, 'v', 'b',   3, 226, 139, 183,   2, 'v', 'c',   3, 226,\n+    139, 182,  66, 'n', 'i',   6,   3,   3, 226, 136, 140,   2, 'v', 'a',   3,\n+    226, 136, 140,   2, 'v', 'b',   3, 226, 139, 190,   2, 'v', 'c',   3, 226,\n+    139, 189,  67, 'p', 'a', 'r',  88,   3,   3, 226, 136, 166,   5, 'a', 'l',\n+    'l', 'e', 'l',   3, 226, 136, 166,   2, 's', 'l',   6, 226, 171, 189, 226,\n+    131, 165,   1, 't',   5, 226, 136, 130, 204, 184,   6, 'p', 'o', 'l', 'i',\n+    'n', 't',   3, 226, 168, 148,  66, 'p', 'r',  89,   2,   3, 226, 138, 128,\n+      3, 'c', 'u', 'e',   3, 226, 139, 160,  65, 'e',   1,   1,   5, 226, 170,\n+    175, 204, 184,  65, 'c',   1,   1,   3, 226, 138, 128,   2, 'e', 'q',   5,\n+    226, 170, 175, 204, 184,   4, 'r', 'A', 'r', 'r',   3, 226, 135, 143,  68,\n+    'r', 'a', 'r', 'r',  91,   2,   3, 226, 134, 155,   1, 'c',   5, 226, 164,\n+    179, 204, 184,   1, 'w',   5, 226, 134, 157, 204, 184,  10, 'r', 'i', 'g',\n+    'h', 't', 'a', 'r', 'r', 'o', 'w',   3, 226, 134, 155,  68, 'r', 't', 'r',\n+    'i',  91,   1,   3, 226, 139, 171,   1, 'e',   3, 226, 139, 173,  66, 's',\n+    'c',  91,   3,   3, 226, 138, 129,   3, 'c', 'u', 'e',   3, 226, 139, 161,\n+      1, 'e',   5, 226, 170, 176, 204, 184,   1, 'r',   4, 240, 157, 147, 131,\n+      8, 's', 'h', 'o', 'r', 't', 'm', 'i', 'd',   3, 226, 136, 164,  13, 's',\n+    'h', 'o', 'r', 't', 'p', 'a', 'r', 'a', 'l', 'l', 'e', 'l',   3, 226, 136,\n+    166,  67, 's', 'i', 'm',  91,   1,   3, 226, 137, 129,  65, 'e',   1,   1,\n+      3, 226, 137, 132,   1, 'q',   3, 226, 137, 132,   4, 's', 'm', 'i', 'd',\n+      3, 226, 136, 164,   4, 's', 'p', 'a', 'r',   3, 226, 136, 166,   6, 's',\n+    'q', 's', 'u', 'b', 'e',   3, 226, 139, 162,   6, 's', 'q', 's', 'u', 'p',\n+    'e',   3, 226, 139, 163,  67, 's', 'u', 'b',  88,   3,   3, 226, 138, 132,\n+      1, 'E',   5, 226, 171, 133, 204, 184,   1, 'e',   3, 226, 138, 136,  67,\n+    's', 'e', 't',   1,   1,   6, 226, 138, 130, 226, 131, 146,  66, 'e', 'q',\n+      1,   1,   3, 226, 138, 136,   1, 'q',   5, 226, 171, 133, 204, 184,  68,\n+    's', 'u', 'c', 'c',  92,   1,   3, 226, 138, 129,   2, 'e', 'q',   5, 226,\n+    170, 176, 204, 184,  67, 's', 'u', 'p',  92,   3,   3, 226, 138, 133,   1,\n+    'E',   5, 226, 171, 134, 204, 184,   1, 'e',   3, 226, 138, 137,  67, 's',\n+    'e', 't',   1,   1,   6, 226, 138, 131, 226, 131, 146,  66, 'e', 'q',   1,\n+      1,   3, 226, 138, 137,   1, 'q',   5, 226, 171, 134, 204, 184,   3, 't',\n+    'g', 'l',   3, 226, 137, 185, 133, 't', 'i', 'l', 'd', 'e',   2, 195, 177,\n+      3, 't', 'l', 'g',   3, 226, 137, 184,  76, 't', 'r', 'i', 'a', 'n', 'g',\n+    'l', 'e', 'l', 'e', 'f', 't',  93,   1,   3, 226, 139, 170,   2, 'e', 'q',\n+      3, 226, 139, 172,  77, 't', 'r', 'i', 'a', 'n', 'g', 'l', 'e', 'r', 'i',\n+    'g', 'h', 't',  93,   1,   3, 226, 139, 171,   2, 'e', 'q',   3, 226, 139,\n+    173,  65, 'u',  93,   1,   2, 206, 189,  65, 'm',   1,   2,   1, '#',   3,\n+    'e', 'r', 'o',   3, 226, 132, 150,   2, 's', 'p',   3, 226, 128, 135,   5,\n+    'v', 'D', 'a', 's', 'h',   3, 226, 138, 173,   5, 'v', 'H', 'a', 'r', 'r',\n+      3, 226, 164, 132,   3, 'v', 'a', 'p',   6, 226, 137, 141, 226, 131, 146,\n+      5, 'v', 'd', 'a', 's', 'h',   3, 226, 138, 172,   3, 'v', 'g', 'e',   6,\n+    226, 137, 165, 226, 131, 146,   3, 'v', 'g', 't',   4, '>', 226, 131, 146,\n+      6, 'v', 'i', 'n', 'f', 'i', 'n',   3, 226, 167, 158,   5, 'v', 'l', 'A',\n+    'r', 'r',   3, 226, 164, 130,   3, 'v', 'l', 'e',   6, 226, 137, 164, 226,\n+    131, 146,  67, 'v', 'l', 't',  86,   1,   4, '<', 226, 131, 146,   3, 'r',\n+    'i', 'e',   6, 226, 138, 180, 226, 131, 146,   5, 'v', 'r', 'A', 'r', 'r',\n+      3, 226, 164, 131,   6, 'v', 'r', 't', 'r', 'i', 'e',   6, 226, 138, 181,\n+    226, 131, 146,   4, 'v', 's', 'i', 'm',   6, 226, 136, 188, 226, 131, 146,\n+      4, 'w', 'A', 'r', 'r',   3, 226, 135, 150,   5, 'w', 'a', 'r', 'h', 'k',\n+      3, 226, 164, 163,  68, 'w', 'a', 'r', 'r',  81,   1,   3, 226, 134, 150,\n+      2, 'o', 'w',   3, 226, 134, 150,   5, 'w', 'n', 'e', 'a', 'r',   3, 226,\n+    164, 167,   1, 'S',   3, 226, 147, 136, 133, 'a', 'c', 'u', 't', 'e',   2,\n+    195, 179,   3, 'a', 's', 't',   3, 226, 138, 155,  67, 'c', 'i', 'r',  38,\n+      1,   3, 226, 138, 154, 129, 'c',   2, 195, 180,   2, 'c', 'y',   2, 208,\n+    190,   4, 'd', 'a', 's', 'h',   3, 226, 138, 157,   5, 'd', 'b', 'l', 'a',\n+    'c',   2, 197, 145,   3, 'd', 'i', 'v',   3, 226, 168, 184,   3, 'd', 'o',\n+    't',   3, 226, 138, 153,   5, 'd', 's', 'o', 'l', 'd',   3, 226, 166, 188,\n+      4, 'e', 'l', 'i', 'g',   2, 197, 147,   4, 'f', 'c', 'i', 'r',   3, 226,\n+    166, 191,   2, 'f', 'r',   4, 240, 157, 148, 172,   3, 'g', 'o', 'n',   2,\n+    203, 155, 133, 'g', 'r', 'a', 'v', 'e',   2, 195, 178,   2, 'g', 't',   3,\n+    226, 167, 129,   4, 'h', 'b', 'a', 'r',   3, 226, 166, 181,   2, 'h', 'm',\n+      2, 206, 169,   3, 'i', 'n', 't',   3, 226, 136, 174,   4, 'l', 'a', 'r',\n+    'r',   3, 226, 134, 186,   4, 'l', 'c', 'i', 'r',   3, 226, 166, 190,   6,\n+    'l', 'c', 'r', 'o', 's', 's',   3, 226, 166, 187,   4, 'l', 'i', 'n', 'e',\n+      3, 226, 128, 190,   2, 'l', 't',   3, 226, 167, 128,   4, 'm', 'a', 'c',\n+    'r',   2, 197, 141,   4, 'm', 'e', 'g', 'a',   2, 207, 137,   6, 'm', 'i',\n+    'c', 'r', 'o', 'n',   2, 206, 191,   3, 'm', 'i', 'd',   3, 226, 166, 182,\n+      5, 'm', 'i', 'n', 'u', 's',   3, 226, 138, 150,   3, 'o', 'p', 'f',   4,\n+    240, 157, 149, 160,   3, 'p', 'a', 'r',   3, 226, 166, 183,   4, 'p', 'e',\n+    'r', 'p',   3, 226, 166, 185,   4, 'p', 'l', 'u', 's',   3, 226, 138, 149,\n+     65, 'r',   9,   6,   3, 226, 136, 168,   3, 'a', 'r', 'r',   3, 226, 134,\n+    187,  65, 'd',   5,   3,   3, 226, 169, 157,  66, 'e', 'r',   3,   1,   3,\n+    226, 132, 180,   2, 'o', 'f',   3, 226, 132, 180, 129, 'f',   2, 194, 170,\n+    129, 'm',   2, 194, 186,   4, 'i', 'g', 'o', 'f',   3, 226, 138, 182,   2,\n+    'o', 'r',   3, 226, 169, 150,   5, 's', 'l', 'o', 'p', 'e',   3, 226, 169,\n+    151,   1, 'v',   3, 226, 169, 155,   3, 's', 'c', 'r',   3, 226, 132, 180,\n+    133, 's', 'l', 'a', 's', 'h',   2, 195, 184,   3, 's', 'o', 'l',   3, 226,\n+    138, 152, 133, 't', 'i', 'l', 'd', 'e',   2, 195, 181,  69, 't', 'i', 'm',\n+    'e', 's',  14,   1,   3, 226, 138, 151,   2, 'a', 's',   3, 226, 168, 182,\n+    131, 'u', 'm', 'l',   2, 195, 182,   4, 'v', 'b', 'a', 'r',   3, 226, 140,\n+    189,  66, 'a', 'r',  23,   4,   3, 226, 136, 165, 193, 'a',   4,   1,   2,\n+    194, 182,   4, 'l', 'l', 'e', 'l',   3, 226, 136, 165,   3, 's', 'i', 'm',\n+      3, 226, 171, 179,   2, 's', 'l',   3, 226, 171, 189,   1, 't',   3, 226,\n+    136, 130,   2, 'c', 'y',   2, 208, 191,   5, 'e', 'r', 'c', 'n', 't',   1,\n+    '%',   5, 'e', 'r', 'i', 'o', 'd',   1, '.',   5, 'e', 'r', 'm', 'i', 'l',\n+      3, 226, 128, 176,   3, 'e', 'r', 'p',   3, 226, 138, 165,   6, 'e', 'r',\n+    't', 'e', 'n', 'k',   3, 226, 128, 177,   2, 'f', 'r',   4, 240, 157, 148,\n+    173,  66, 'h', 'i',  20,   1,   2, 207, 134,   1, 'v',   2, 207, 149,   5,\n+    'h', 'm', 'm', 'a', 't',   3, 226, 132, 179,   4, 'h', 'o', 'n', 'e',   3,\n+    226, 152, 142,  65, 'i',  18,   2,   2, 207, 128,   7, 't', 'c', 'h', 'f',\n+    'o', 'r', 'k',   3, 226, 139, 148,   1, 'v',   2, 207, 150,  69, 'l', 'a',\n+    'n', 'c', 'k',  19,   1,   3, 226, 132, 143,   1, 'h',   3, 226, 132, 142,\n+      5, 'l', 'a', 'n', 'k', 'v',   3, 226, 132, 143,  67, 'l', 'u', 's',  18,\n+      9,   1, '+',   4, 'a', 'c', 'i', 'r',   3, 226, 168, 163,   1, 'b',   3,\n+    226, 138, 158,   3, 'c', 'i', 'r',   3, 226, 168, 162,   2, 'd', 'o',   3,\n+    226, 136, 148,   2, 'd', 'u',   3, 226, 168, 165,   1, 'e',   3, 226, 169,\n+    178, 130, 'm', 'n',   2, 194, 177,   3, 's', 'i', 'm',   3, 226, 168, 166,\n+      3, 't', 'w', 'o',   3, 226, 168, 167,   1, 'm',   2, 194, 177,   7, 'o',\n+    'i', 'n', 't', 'i', 'n', 't',   3, 226, 168, 149,   3, 'o', 'p', 'f',   4,\n+    240, 157, 149, 161, 132, 'o', 'u', 'n', 'd',   2, 194, 163,  65, 'r',  22,\n+     15,   3, 226, 137, 186,   1, 'E',   3, 226, 170, 179,   2, 'a', 'p',   3,\n+    226, 170, 183,   3, 'c', 'u', 'e',   3, 226, 137, 188,  65, 'e',  12,   1,\n+      3, 226, 170, 175,  65, 'c',   1,   7,   3, 226, 137, 186,   6, 'a', 'p',\n+    'p', 'r', 'o', 'x',   3, 226, 170, 183,   7, 'c', 'u', 'r', 'l', 'y', 'e',\n+    'q',   3, 226, 137, 188,   2, 'e', 'q',   3, 226, 170, 175,   7, 'n', 'a',\n+    'p', 'p', 'r', 'o', 'x',   3, 226, 170, 185,   4, 'n', 'e', 'q', 'q',   3,\n+    226, 170, 181,   4, 'n', 's', 'i', 'm',   3, 226, 139, 168,   3, 's', 'i',\n+    'm',   3, 226, 137, 190,  67, 'i', 'm', 'e',  19,   1,   3, 226, 128, 178,\n+      1, 's',   3, 226, 132, 153,   2, 'n', 'E',   3, 226, 170, 181,   3, 'n',\n+    'a', 'p',   3, 226, 170, 185,   4, 'n', 's', 'i', 'm',   3, 226, 139, 168,\n+      2, 'o', 'd',   3, 226, 136, 143,   6, 'o', 'f', 'a', 'l', 'a', 'r',   3,\n+    226, 140, 174,   6, 'o', 'f', 'l', 'i', 'n', 'e',   3, 226, 140, 146,   6,\n+    'o', 'f', 's', 'u', 'r', 'f',   3, 226, 140, 147,  66, 'o', 'p',  12,   1,\n+      3, 226, 136, 157,   2, 't', 'o',   3, 226, 136, 157,   3, 's', 'i', 'm',\n+      3, 226, 137, 190,   4, 'u', 'r', 'e', 'l',   3, 226, 138, 176,   3, 's',\n+    'c', 'r',   4, 240, 157, 147, 133,   2, 's', 'i',   2, 207, 136,   5, 'u',\n+    'n', 'c', 's', 'p',   3, 226, 128, 136,   2, 'f', 'r',   4, 240, 157, 148,\n+    174,   3, 'i', 'n', 't',   3, 226, 168, 140,   3, 'o', 'p', 'f',   4, 240,\n+    157, 149, 162,   5, 'p', 'r', 'i', 'm', 'e',   3, 226, 129, 151,   3, 's',\n+    'c', 'r',   4, 240, 157, 147, 134,  10, 'u', 'a', 't', 'e', 'r', 'n', 'i',\n+    'o', 'n', 's',   3, 226, 132, 141,   6, 'u', 'a', 't', 'i', 'n', 't',   3,\n+    226, 168, 150,  68, 'u', 'e', 's', 't',   2,   1,   1, '?',   2, 'e', 'q',\n+      3, 226, 137, 159, 131, 'u', 'o', 't',   1, '\"',   4, 'A', 'a', 'r', 'r',\n+      3, 226, 135, 155,   3, 'A', 'r', 'r',   3, 226, 135, 146,   5, 'A', 't',\n+    'a', 'i', 'l',   3, 226, 164, 156,   4, 'B', 'a', 'r', 'r',   3, 226, 164,\n+    143,   3, 'H', 'a', 'r',   3, 226, 165, 164,   3, 'a', 'c', 'e',   5, 226,\n+    136, 189, 204, 177,   5, 'a', 'c', 'u', 't', 'e',   2, 197, 149,   4, 'a',\n+    'd', 'i', 'c',   3, 226, 136, 154,   7, 'a', 'e', 'm', 'p', 't', 'y', 'v',\n+      3, 226, 166, 179,  67, 'a', 'n', 'g',  65,   3,   3, 226, 159, 169,   1,\n+    'd',   3, 226, 166, 146,   1, 'e',   3, 226, 166, 165,   2, 'l', 'e',   3,\n+    226, 159, 169, 132, 'a', 'q', 'u', 'o',   2, 194, 187,  67, 'a', 'r', 'r',\n+     66,  10,   3, 226, 134, 146,   2, 'a', 'p',   3, 226, 165, 181,  65, 'b',\n+      9,   1,   3, 226, 135, 165,   2, 'f', 's',   3, 226, 164, 160,   1, 'c',\n+      3, 226, 164, 179,   2, 'f', 's',   3, 226, 164, 158,   2, 'h', 'k',   3,\n+    226, 134, 170,   2, 'l', 'p',   3, 226, 134, 172,   2, 'p', 'l',   3, 226,\n+    165, 133,   3, 's', 'i', 'm',   3, 226, 165, 180,   2, 't', 'l',   3, 226,\n+    134, 163,   1, 'w',   3, 226, 134, 157,   5, 'a', 't', 'a', 'i', 'l',   3,\n+    226, 164, 154,  68, 'a', 't', 'i', 'o',  75,   1,   3, 226, 136, 182,   4,\n+    'n', 'a', 'l', 's',   3, 226, 132, 154,   4, 'b', 'a', 'r', 'r',   3, 226,\n+    164, 141,   4, 'b', 'b', 'r', 'k',   3, 226, 157, 179,   5, 'b', 'r', 'a',\n+    'c', 'e',   1, '}',   5, 'b', 'r', 'a', 'c', 'k',   1, ']',   4, 'b', 'r',\n+    'k', 'e',   3, 226, 166, 140,   6, 'b', 'r', 'k', 's', 'l', 'd',   3, 226,\n+    166, 142,   6, 'b', 'r', 'k', 's', 'l', 'u',   3, 226, 166, 144,   5, 'c',\n+    'a', 'r', 'o', 'n',   2, 197, 153,   5, 'c', 'e', 'd', 'i', 'l',   2, 197,\n+    151,   4, 'c', 'e', 'i', 'l',   3, 226, 140, 137,   3, 'c', 'u', 'b',   1,\n+    '}',   2, 'c', 'y',   2, 209, 128,   3, 'd', 'c', 'a',   3, 226, 164, 183,\n+      6, 'd', 'l', 'd', 'h', 'a', 'r',   3, 226, 165, 169,  68, 'd', 'q', 'u',\n+    'o',  61,   1,   3, 226, 128, 157,   1, 'r',   3, 226, 128, 157,   3, 'd',\n+    's', 'h',   3, 226, 134, 179,  67, 'e', 'a', 'l',  60,   3,   3, 226, 132,\n+    156,   3, 'i', 'n', 'e',   3, 226, 132, 155,   4, 'p', 'a', 'r', 't',   3,\n+    226, 132, 156,   1, 's',   3, 226, 132, 157,   3, 'e', 'c', 't',   3, 226,\n+    150, 173, 130, 'e', 'g',   2, 194, 174,   5, 'f', 'i', 's', 'h', 't',   3,\n+    226, 165, 189,   5, 'f', 'l', 'o', 'o', 'r',   3, 226, 140, 139,   2, 'f',\n+    'r',   4, 240, 157, 148, 175,   4, 'h', 'a', 'r', 'd',   3, 226, 135, 129,\n+     68, 'h', 'a', 'r', 'u',  56,   1,   3, 226, 135, 128,   1, 'l',   3, 226,\n+    165, 172,  66, 'h', 'o',  56,   1,   2, 207, 129,   1, 'v',   2, 207, 177,\n+     73, 'i', 'g', 'h', 't', 'a', 'r', 'r', 'o', 'w',  56,   1,   3, 226, 134,\n+    146,   4, 't', 'a', 'i', 'l',   3, 226, 134, 163,  15, 'i', 'g', 'h', 't',\n+    'h', 'a', 'r', 'p', 'o', 'o', 'n', 'd', 'o', 'w', 'n',   3, 226, 135, 129,\n+     13, 'i', 'g', 'h', 't', 'h', 'a', 'r', 'p', 'o', 'o', 'n', 'u', 'p',   3,\n+    226, 135, 128,  14, 'i', 'g', 'h', 't', 'l', 'e', 'f', 't', 'a', 'r', 'r',\n+    'o', 'w', 's',   3, 226, 135, 132,  16, 'i', 'g', 'h', 't', 'l', 'e', 'f',\n+    't', 'h', 'a', 'r', 'p', 'o', 'o', 'n', 's',   3, 226, 135, 140,  15, 'i',\n+    'g', 'h', 't', 'r', 'i', 'g', 'h', 't', 'a', 'r', 'r', 'o', 'w', 's',   3,\n+    226, 135, 137,  14, 'i', 'g', 'h', 't', 's', 'q', 'u', 'i', 'g', 'a', 'r',\n+    'r', 'o', 'w',   3, 226, 134, 157,  14, 'i', 'g', 'h', 't', 't', 'h', 'r',\n+    'e', 'e', 't', 'i', 'm', 'e', 's',   3, 226, 139, 140,   3, 'i', 'n', 'g',\n+      2, 203, 154,  11, 'i', 's', 'i', 'n', 'g', 'd', 'o', 't', 's', 'e', 'q',\n+      3, 226, 137, 147,   4, 'l', 'a', 'r', 'r',   3, 226, 135, 132,   4, 'l',\n+    'h', 'a', 'r',   3, 226, 135, 140,   2, 'l', 'm',   3, 226, 128, 143,  69,\n+    'm', 'o', 'u', 's', 't',  44,   1,   3, 226, 142, 177,   4, 'a', 'c', 'h',\n+    'e',   3, 226, 142, 177,   4, 'n', 'm', 'i', 'd',   3, 226, 171, 174,   4,\n+    'o', 'a', 'n', 'g',   3, 226, 159, 173,   4, 'o', 'a', 'r', 'r',   3, 226,\n+    135, 190,   4, 'o', 'b', 'r', 'k',   3, 226, 159, 167,   4, 'o', 'p', 'a',\n+    'r',   3, 226, 166, 134,   3, 'o', 'p', 'f',   4, 240, 157, 149, 163,   5,\n+    'o', 'p', 'l', 'u', 's',   3, 226, 168, 174,   6, 'o', 't', 'i', 'm', 'e',\n+    's',   3, 226, 168, 181,  67, 'p', 'a', 'r',  36,   1,   1, ')',   2, 'g',\n+    't',   3, 226, 166, 148,   7, 'p', 'p', 'o', 'l', 'i', 'n', 't',   3, 226,\n+    168, 146,   4, 'r', 'a', 'r', 'r',   3, 226, 135, 137,   5, 's', 'a', 'q',\n+    'u', 'o',   3, 226, 128, 186,   3, 's', 'c', 'r',   4, 240, 157, 147, 135,\n+      2, 's', 'h',   3, 226, 134, 177,   3, 's', 'q', 'b',   1, ']',  68, 's',\n+    'q', 'u', 'o',  30,   1,   3, 226, 128, 153,   1, 'r',   3, 226, 128, 153,\n+      5, 't', 'h', 'r', 'e', 'e',   3, 226, 139, 140,   5, 't', 'i', 'm', 'e',\n+    's',   3, 226, 139, 138,  67, 't', 'r', 'i',  28,   3,   3, 226, 150, 185,\n+      1, 'e',   3, 226, 138, 181,   1, 'f',   3, 226, 150, 184,   4, 'l', 't',\n+    'r', 'i',   3, 226, 167, 142,   6, 'u', 'l', 'u', 'h', 'a', 'r',   3, 226,\n+    165, 168,   1, 'x',   3, 226, 132, 158,   5, 'a', 'c', 'u', 't', 'e',   2,\n+    197, 155,   4, 'b', 'q', 'u', 'o',   3, 226, 128, 154,  65, 'c',  56,  12,\n+      3, 226, 137, 187,   1, 'E',   3, 226, 170, 180,   2, 'a', 'p',   3, 226,\n+    170, 184,   4, 'a', 'r', 'o', 'n',   2, 197, 161,   3, 'c', 'u', 'e',   3,\n+    226, 137, 189,  65, 'e',   8,   1,   3, 226, 170, 176,   3, 'd', 'i', 'l',\n+      2, 197, 159,   3, 'i', 'r', 'c',   2, 197, 157,   2, 'n', 'E',   3, 226,\n+    170, 182,   3, 'n', 'a', 'p',   3, 226, 170, 186,   4, 'n', 's', 'i', 'm',\n+      3, 226, 139, 169,   6, 'p', 'o', 'l', 'i', 'n', 't',   3, 226, 168, 147,\n+      3, 's', 'i', 'm',   3, 226, 137, 191,   1, 'y',   2, 209, 129,  67, 'd',\n+    'o', 't',  68,   2,   3, 226, 139, 133,   1, 'b',   3, 226, 138, 161,   1,\n+    'e',   3, 226, 169, 166,   4, 'e', 'A', 'r', 'r',   3, 226, 135, 152,   5,\n+    'e', 'a', 'r', 'h', 'k',   3, 226, 164, 165,  68, 'e', 'a', 'r', 'r',  67,\n+      1,   3, 226, 134, 152,   2, 'o', 'w',   3, 226, 134, 152, 131, 'e', 'c',\n+    't',   2, 194, 167,   3, 'e', 'm', 'i',   1, ';',   5, 'e', 's', 'w', 'a',\n+    'r',   3, 226, 164, 169,   7, 'e', 't', 'm', 'i', 'n', 'u', 's',   3, 226,\n+    136, 150,   4, 'e', 't', 'm', 'n',   3, 226, 136, 150,   3, 'e', 'x', 't',\n+      3, 226, 156, 182,  66, 'f', 'r',  61,   1,   4, 240, 157, 148, 176,   3,\n+    'o', 'w', 'n',   3, 226, 140, 162,   4, 'h', 'a', 'r', 'p',   3, 226, 153,\n+    175,   5, 'h', 'c', 'h', 'c', 'y',   2, 209, 137,   3, 'h', 'c', 'y',   2,\n+    209, 136,   7, 'h', 'o', 'r', 't', 'm', 'i', 'd',   3, 226, 136, 163,  12,\n+    'h', 'o', 'r', 't', 'p', 'a', 'r', 'a', 'l', 'l', 'e', 'l',   3, 226, 136,\n+    165, 130, 'h', 'y',   2, 194, 173,  68, 'i', 'g', 'm', 'a',  55,   2,   2,\n+    207, 131,   1, 'f',   2, 207, 130,   1, 'v',   2, 207, 130,  66, 'i', 'm',\n+     56,   7,   3, 226, 136, 188,   3, 'd', 'o', 't',   3, 226, 169, 170,  65,\n+    'e',   6,   1,   3, 226, 137, 131,   1, 'q',   3, 226, 137, 131,  65, 'g',\n+      6,   1,   3, 226, 170, 158,   1, 'E',   3, 226, 170, 160,  65, 'l',   6,\n+      1,   3, 226, 170, 157,   1, 'E',   3, 226, 170, 159,   2, 'n', 'e',   3,\n+    226, 137, 134,   4, 'p', 'l', 'u', 's',   3, 226, 168, 164,   4, 'r', 'a',\n+    'r', 'r',   3, 226, 165, 178,   4, 'l', 'a', 'r', 'r',   3, 226, 134, 144,\n+     12, 'm', 'a', 'l', 'l', 's', 'e', 't', 'm', 'i', 'n', 'u', 's',   3, 226,\n+    136, 150,   5, 'm', 'a', 's', 'h', 'p',   3, 226, 168, 179,   7, 'm', 'e',\n+    'p', 'a', 'r', 's', 'l',   3, 226, 167, 164,   3, 'm', 'i', 'd',   3, 226,\n+    136, 163,   4, 'm', 'i', 'l', 'e',   3, 226, 140, 163,  66, 'm', 't',  59,\n+      1,   3, 226, 170, 170,  65, 'e',   1,   1,   3, 226, 170, 172,   1, 's',\n+      6, 226, 170, 172, 239, 184, 128,   5, 'o', 'f', 't', 'c', 'y',   2, 209,\n+    140,  66, 'o', 'l',  59,   1,   1, '\/',  65, 'b',   1,   1,   3, 226, 167,\n+    132,   2, 'a', 'r',   3, 226, 140, 191,   3, 'o', 'p', 'f',   4, 240, 157,\n+    149, 164,  69, 'p', 'a', 'd', 'e', 's',  59,   1,   3, 226, 153, 160,   3,\n+    'u', 'i', 't',   3, 226, 153, 160,   3, 'p', 'a', 'r',   3, 226, 136, 165,\n+     68, 'q', 'c', 'a', 'p',  58,   1,   3, 226, 138, 147,   1, 's',   6, 226,\n+    138, 147, 239, 184, 128,  68, 'q', 'c', 'u', 'p',  58,   1,   3, 226, 138,\n+    148,   1, 's',   6, 226, 138, 148, 239, 184, 128,  68, 'q', 's', 'u', 'b',\n+     58,   2,   3, 226, 138, 143,   1, 'e',   3, 226, 138, 145,  67, 's', 'e',\n+    't',   1,   1,   3, 226, 138, 143,   2, 'e', 'q',   3, 226, 138, 145,  68,\n+    'q', 's', 'u', 'p',  60,   2,   3, 226, 138, 144,   1, 'e',   3, 226, 138,\n+    146,  67, 's', 'e', 't',   1,   1,   3, 226, 138, 144,   2, 'e', 'q',   3,\n+    226, 138, 146,  66, 'q', 'u',  62,   3,   3, 226, 150, 161,   3, 'a', 'r',\n+    'e',   3, 226, 150, 161,   3, 'a', 'r', 'f',   3, 226, 150, 170,   1, 'f',\n+      3, 226, 150, 170,   4, 'r', 'a', 'r', 'r',   3, 226, 134, 146,   3, 's',\n+    'c', 'r',   4, 240, 157, 147, 136,   5, 's', 'e', 't', 'm', 'n',   3, 226,\n+    136, 150,   5, 's', 'm', 'i', 'l', 'e',   3, 226, 140, 163,   5, 's', 't',\n+    'a', 'r', 'f',   3, 226, 139, 134,  67, 't', 'a', 'r',  59,   1,   3, 226,\n+    152, 134,   1, 'f',   3, 226, 152, 133,  14, 't', 'r', 'a', 'i', 'g', 'h',\n+    't', 'e', 'p', 's', 'i', 'l', 'o', 'n',   2, 207, 181,  10, 't', 'r', 'a',\n+    'i', 'g', 'h', 't', 'p', 'h', 'i',   2, 207, 149,   4, 't', 'r', 'n', 's',\n+      2, 194, 175,  66, 'u', 'b',  56,  12,   3, 226, 138, 130,   1, 'E',   3,\n+    226, 171, 133,   3, 'd', 'o', 't',   3, 226, 170, 189,  65, 'e',  10,   1,\n+      3, 226, 138, 134,   3, 'd', 'o', 't',   3, 226, 171, 131,   4, 'm', 'u',\n+    'l', 't',   3, 226, 171, 129,   2, 'n', 'E',   3, 226, 171, 139,   2, 'n',\n+    'e',   3, 226, 138, 138,   4, 'p', 'l', 'u', 's',   3, 226, 170, 191,   4,\n+    'r', 'a', 'r', 'r',   3, 226, 165, 185,  67, 's', 'e', 't',   5,   2,   3,\n+    226, 138, 130,  66, 'e', 'q',   2,   1,   3, 226, 138, 134,   1, 'q',   3,\n+    226, 171, 133,  67, 'n', 'e', 'q',   2,   1,   3, 226, 138, 138,   1, 'q',\n+      3, 226, 171, 139,   3, 's', 'i', 'm',   3, 226, 171, 135,   3, 's', 'u',\n+    'b',   3, 226, 171, 149,   3, 's', 'u', 'p',   3, 226, 171, 147,  67, 'u',\n+    'c', 'c',  72,   7,   3, 226, 137, 187,   6, 'a', 'p', 'p', 'r', 'o', 'x',\n+      3, 226, 170, 184,   7, 'c', 'u', 'r', 'l', 'y', 'e', 'q',   3, 226, 137,\n+    189,   2, 'e', 'q',   3, 226, 170, 176,   7, 'n', 'a', 'p', 'p', 'r', 'o',\n+    'x',   3, 226, 170, 186,   4, 'n', 'e', 'q', 'q',   3, 226, 170, 182,   4,\n+    'n', 's', 'i', 'm',   3, 226, 139, 169,   3, 's', 'i', 'm',   3, 226, 137,\n+    191,   2, 'u', 'm',   3, 226, 136, 145,   3, 'u', 'n', 'g',   3, 226, 153,\n+    170,  66, 'u', 'p',  76,  18,   3, 226, 138, 131, 129, '1',   2, 194, 185,\n+    129, '2',   2, 194, 178, 129, '3',   2, 194, 179,   1, 'E',   3, 226, 171,\n+    134,   3, 'd', 'o', 't',   3, 226, 170, 190,   4, 'd', 's', 'u', 'b',   3,\n+    226, 171, 152,  65, 'e',  12,   1,   3, 226, 138, 135,   3, 'd', 'o', 't',\n+      3, 226, 171, 132,   4, 'h', 's', 'o', 'l',   3, 226, 159, 137,   4, 'h',\n+    's', 'u', 'b',   3, 226, 171, 151,   4, 'l', 'a', 'r', 'r',   3, 226, 165,\n+    187,   4, 'm', 'u', 'l', 't',   3, 226, 171, 130,   2, 'n', 'E',   3, 226,\n+    171, 140,   2, 'n', 'e',   3, 226, 138, 139,   4, 'p', 'l', 'u', 's',   3,\n+    226, 171, 128,  67, 's', 'e', 't',   5,   2,   3, 226, 138, 131,  66, 'e',\n+    'q',   2,   1,   3, 226, 138, 135,   1, 'q',   3, 226, 171, 134,  67, 'n',\n+    'e', 'q',   2,   1,   3, 226, 138, 139,   1, 'q',   3, 226, 171, 140,   3,\n+    's', 'i', 'm',   3, 226, 171, 136,   3, 's', 'u', 'b',   3, 226, 171, 148,\n+      3, 's', 'u', 'p',   3, 226, 171, 150,   4, 'w', 'A', 'r', 'r',   3, 226,\n+    135, 153,   5, 'w', 'a', 'r', 'h', 'k',   3, 226, 164, 166,  68, 'w', 'a',\n+    'r', 'r',  96,   1,   3, 226, 134, 153,   2, 'o', 'w',   3, 226, 134, 153,\n+      5, 'w', 'n', 'w', 'a', 'r',   3, 226, 164, 170, 132, 'z', 'l', 'i', 'g',\n+      2, 195, 159,   5, 'a', 'r', 'g', 'e', 't',   3, 226, 140, 150,   2, 'a',\n+    'u',   2, 207, 132,   3, 'b', 'r', 'k',   3, 226, 142, 180,   5, 'c', 'a',\n+    'r', 'o', 'n',   2, 197, 165,   5, 'c', 'e', 'd', 'i', 'l',   2, 197, 163,\n+      2, 'c', 'y',   2, 209, 130,   3, 'd', 'o', 't',   3, 226, 131, 155,   5,\n+    'e', 'l', 'r', 'e', 'c',   3, 226, 140, 149,   2, 'f', 'r',   4, 240, 157,\n+    148, 177,   5, 'h', 'e', 'r', 'e', '4',   3, 226, 136, 180,   8, 'h', 'e',\n+    'r', 'e', 'f', 'o', 'r', 'e',   3, 226, 136, 180,  68, 'h', 'e', 't', 'a',\n+     30,   2,   2, 206, 184,   3, 's', 'y', 'm',   2, 207, 145,   1, 'v',   2,\n+    207, 145,  10, 'h', 'i', 'c', 'k', 'a', 'p', 'p', 'r', 'o', 'x',   3, 226,\n+    137, 136,   7, 'h', 'i', 'c', 'k', 's', 'i', 'm',   3, 226, 136, 188,   5,\n+    'h', 'i', 'n', 's', 'p',   3, 226, 128, 137,   4, 'h', 'k', 'a', 'p',   3,\n+    226, 137, 136,   5, 'h', 'k', 's', 'i', 'm',   3, 226, 136, 188, 132, 'h',\n+    'o', 'r', 'n',   2, 195, 190,   4, 'i', 'l', 'd', 'e',   2, 203, 156, 196,\n+    'i', 'm', 'e', 's',  24,   2,   2, 195, 151,  65, 'b',   2,   1,   3, 226,\n+    138, 160,   2, 'a', 'r',   3, 226, 168, 177,   1, 'd',   3, 226, 168, 176,\n+      3, 'i', 'n', 't',   3, 226, 136, 173,   3, 'o', 'e', 'a',   3, 226, 164,\n+    168,  66, 'o', 'p',  24,   3,   3, 226, 138, 164,   3, 'b', 'o', 't',   3,\n+    226, 140, 182,   3, 'c', 'i', 'r',   3, 226, 171, 177,  65, 'f',   1,   1,\n+      4, 240, 157, 149, 165,   3, 'o', 'r', 'k',   3, 226, 171, 154,   3, 'o',\n+    's', 'a',   3, 226, 164, 169,   5, 'p', 'r', 'i', 'm', 'e',   3, 226, 128,\n+    180,   4, 'r', 'a', 'd', 'e',   3, 226, 132, 162,  71, 'r', 'i', 'a', 'n',\n+    'g', 'l', 'e',  24,   4,   3, 226, 150, 181,   4, 'd', 'o', 'w', 'n',   3,\n+    226, 150, 191,  68, 'l', 'e', 'f', 't',   3,   1,   3, 226, 151, 131,   2,\n+    'e', 'q',   3, 226, 138, 180,   1, 'q',   3, 226, 137, 156,  69, 'r', 'i',\n+    'g', 'h', 't',   2,   1,   3, 226, 150, 185,   2, 'e', 'q',   3, 226, 138,\n+    181,   5, 'r', 'i', 'd', 'o', 't',   3, 226, 151, 172,   3, 'r', 'i', 'e',\n+      3, 226, 137, 156,   7, 'r', 'i', 'm', 'i', 'n', 'u', 's',   3, 226, 168,\n+    186,   6, 'r', 'i', 'p', 'l', 'u', 's',   3, 226, 168, 185,   4, 'r', 'i',\n+    's', 'b',   3, 226, 167, 141,   6, 'r', 'i', 't', 'i', 'm', 'e',   3, 226,\n+    168, 187,   7, 'r', 'p', 'e', 'z', 'i', 'u', 'm',   3, 226, 143, 162,   3,\n+    's', 'c', 'r',   4, 240, 157, 147, 137,   3, 's', 'c', 'y',   2, 209, 134,\n+      4, 's', 'h', 'c', 'y',   2, 209, 155,   5, 's', 't', 'r', 'o', 'k',   2,\n+    197, 167,   4, 'w', 'i', 'x', 't',   3, 226, 137, 172,  15, 'w', 'o', 'h',\n+    'e', 'a', 'd', 'l', 'e', 'f', 't', 'a', 'r', 'r', 'o', 'w',   3, 226, 134,\n+    158,  16, 'w', 'o', 'h', 'e', 'a', 'd', 'r', 'i', 'g', 'h', 't', 'a', 'r',\n+    'r', 'o', 'w',   3, 226, 134, 160,   3, 'A', 'r', 'r',   3, 226, 135, 145,\n+      3, 'H', 'a', 'r',   3, 226, 165, 163, 133, 'a', 'c', 'u', 't', 'e',   2,\n+    195, 186,   3, 'a', 'r', 'r',   3, 226, 134, 145,   4, 'b', 'r', 'c', 'y',\n+      2, 209, 158,   5, 'b', 'r', 'e', 'v', 'e',   2, 197, 173, 132, 'c', 'i',\n+    'r', 'c',   2, 195, 187,   2, 'c', 'y',   2, 209, 131,   4, 'd', 'a', 'r',\n+    'r',   3, 226, 135, 133,   5, 'd', 'b', 'l', 'a', 'c',   2, 197, 177,   4,\n+    'd', 'h', 'a', 'r',   3, 226, 165, 174,   5, 'f', 'i', 's', 'h', 't',   3,\n+    226, 165, 190,   2, 'f', 'r',   4, 240, 157, 148, 178, 133, 'g', 'r', 'a',\n+    'v', 'e',   2, 195, 185,   4, 'h', 'a', 'r', 'l',   3, 226, 134, 191,   4,\n+    'h', 'a', 'r', 'r',   3, 226, 134, 190,   4, 'h', 'b', 'l', 'k',   3, 226,\n+    150, 128,  69, 'l', 'c', 'o', 'r', 'n',  25,   1,   3, 226, 140, 156,   2,\n+    'e', 'r',   3, 226, 140, 156,   5, 'l', 'c', 'r', 'o', 'p',   3, 226, 140,\n+    143,   4, 'l', 't', 'r', 'i',   3, 226, 151, 184,   4, 'm', 'a', 'c', 'r',\n+      2, 197, 171, 130, 'm', 'l',   2, 194, 168,   4, 'o', 'g', 'o', 'n',   2,\n+    197, 179,   3, 'o', 'p', 'f',   4, 240, 157, 149, 166,   6, 'p', 'a', 'r',\n+    'r', 'o', 'w',   3, 226, 134, 145,  10, 'p', 'd', 'o', 'w', 'n', 'a', 'r',\n+    'r', 'o', 'w',   3, 226, 134, 149,  12, 'p', 'h', 'a', 'r', 'p', 'o', 'o',\n+    'n', 'l', 'e', 'f', 't',   3, 226, 134, 191,  13, 'p', 'h', 'a', 'r', 'p',\n+    'o', 'o', 'n', 'r', 'i', 'g', 'h', 't',   3, 226, 134, 190,   4, 'p', 'l',\n+    'u', 's',   3, 226, 138, 142,  67, 'p', 's', 'i',  14,   2,   2, 207, 133,\n+      1, 'h',   2, 207, 146,   3, 'l', 'o', 'n',   2, 207, 133,   9, 'p', 'u',\n+    'p', 'a', 'r', 'r', 'o', 'w', 's',   3, 226, 135, 136,  69, 'r', 'c', 'o',\n+    'r', 'n',  14,   1,   3, 226, 140, 157,   2, 'e', 'r',   3, 226, 140, 157,\n+      5, 'r', 'c', 'r', 'o', 'p',   3, 226, 140, 142,   4, 'r', 'i', 'n', 'g',\n+      2, 197, 175,   4, 'r', 't', 'r', 'i',   3, 226, 151, 185,   3, 's', 'c',\n+    'r',   4, 240, 157, 147, 138,   4, 't', 'd', 'o', 't',   3, 226, 139, 176,\n+      5, 't', 'i', 'l', 'd', 'e',   2, 197, 169,  67, 't', 'r', 'i',   8,   1,\n+      3, 226, 150, 181,   1, 'f',   3, 226, 150, 180,   4, 'u', 'a', 'r', 'r',\n+      3, 226, 135, 136, 131, 'u', 'm', 'l',   2, 195, 188,   6, 'w', 'a', 'n',\n+    'g', 'l', 'e',   3, 226, 166, 167,   3, 'A', 'r', 'r',   3, 226, 135, 149,\n+     67, 'B', 'a', 'r',  35,   1,   3, 226, 171, 168,   1, 'v',   3, 226, 171,\n+    169,   4, 'D', 'a', 's', 'h',   3, 226, 138, 168,   5, 'a', 'n', 'g', 'r',\n+    't',   3, 226, 166, 156,   9, 'a', 'r', 'e', 'p', 's', 'i', 'l', 'o', 'n',\n+      2, 207, 181,   7, 'a', 'r', 'k', 'a', 'p', 'p', 'a',   2, 207, 176,   9,\n+    'a', 'r', 'n', 'o', 't', 'h', 'i', 'n', 'g',   3, 226, 136, 133,   5, 'a',\n+    'r', 'p', 'h', 'i',   2, 207, 149,   4, 'a', 'r', 'p', 'i',   2, 207, 150,\n+      8, 'a', 'r', 'p', 'r', 'o', 'p', 't', 'o',   3, 226, 136, 157,  67, 'a',\n+    'r', 'r',  27,   1,   3, 226, 134, 149,   2, 'h', 'o',   2, 207, 177,   7,\n+    'a', 'r', 's', 'i', 'g', 'm', 'a',   2, 207, 130,  75, 'a', 'r', 's', 'u',\n+    'b', 's', 'e', 't', 'n', 'e', 'q',  26,   1,   6, 226, 138, 138, 239, 184,\n+    128,   1, 'q',   6, 226, 171, 139, 239, 184, 128,  75, 'a', 'r', 's', 'u',\n+    'p', 's', 'e', 't', 'n', 'e', 'q',  26,   1,   6, 226, 138, 139, 239, 184,\n+    128,   1, 'q',   6, 226, 171, 140, 239, 184, 128,   7, 'a', 'r', 't', 'h',\n+    'e', 't', 'a',   2, 207, 145,  14, 'a', 'r', 't', 'r', 'i', 'a', 'n', 'g',\n+    'l', 'e', 'l', 'e', 'f', 't',   3, 226, 138, 178,  15, 'a', 'r', 't', 'r',\n+    'i', 'a', 'n', 'g', 'l', 'e', 'r', 'i', 'g', 'h', 't',   3, 226, 138, 179,\n+      2, 'c', 'y',   2, 208, 178,   4, 'd', 'a', 's', 'h',   3, 226, 138, 162,\n+     66, 'e', 'e',  21,   2,   3, 226, 136, 168,   3, 'b', 'a', 'r',   3, 226,\n+    138, 187,   2, 'e', 'q',   3, 226, 137, 154,   5, 'e', 'l', 'l', 'i', 'p',\n+      3, 226, 139, 174,   5, 'e', 'r', 'b', 'a', 'r',   1, '|',   3, 'e', 'r',\n+    't',   1, '|',   2, 'f', 'r',   4, 240, 157, 148, 179,   4, 'l', 't', 'r',\n+    'i',   3, 226, 138, 178,   4, 'n', 's', 'u', 'b',   6, 226, 138, 130, 226,\n+    131, 146,   4, 'n', 's', 'u', 'p',   6, 226, 138, 131, 226, 131, 146,   3,\n+    'o', 'p', 'f',   4, 240, 157, 149, 167,   4, 'p', 'r', 'o', 'p',   3, 226,\n+    136, 157,   4, 'r', 't', 'r', 'i',   3, 226, 138, 179,   3, 's', 'c', 'r',\n+      4, 240, 157, 147, 139,   5, 's', 'u', 'b', 'n', 'E',   6, 226, 171, 139,\n+    239, 184, 128,   5, 's', 'u', 'b', 'n', 'e',   6, 226, 138, 138, 239, 184,\n+    128,   5, 's', 'u', 'p', 'n', 'E',   6, 226, 171, 140, 239, 184, 128,   5,\n+    's', 'u', 'p', 'n', 'e',   6, 226, 138, 139, 239, 184, 128,   6, 'z', 'i',\n+    'g', 'z', 'a', 'g',   3, 226, 166, 154,   4, 'c', 'i', 'r', 'c',   2, 197,\n+    181,   5, 'e', 'd', 'b', 'a', 'r',   3, 226, 169, 159,  68, 'e', 'd', 'g',\n+    'e',   7,   1,   3, 226, 136, 167,   1, 'q',   3, 226, 137, 153,   5, 'e',\n+    'i', 'e', 'r', 'p',   3, 226, 132, 152,   2, 'f', 'r',   4, 240, 157, 148,\n+    180,   3, 'o', 'p', 'f',   4, 240, 157, 149, 168,   1, 'p',   3, 226, 132,\n+    152,  65, 'r',   3,   1,   3, 226, 137, 128,   4, 'e', 'a', 't', 'h',   3,\n+    226, 137, 128,   3, 's', 'c', 'r',   4, 240, 157, 147, 140,   3, 'c', 'a',\n+    'p',   3, 226, 139, 130,   4, 'c', 'i', 'r', 'c',   3, 226, 151, 175,   3,\n+    'c', 'u', 'p',   3, 226, 139, 131,   4, 'd', 't', 'r', 'i',   3, 226, 150,\n+    189,   2, 'f', 'r',   4, 240, 157, 148, 181,   4, 'h', 'A', 'r', 'r',   3,\n+    226, 159, 186,   4, 'h', 'a', 'r', 'r',   3, 226, 159, 183,   1, 'i',   2,\n+    206, 190,   4, 'l', 'A', 'r', 'r',   3, 226, 159, 184,   4, 'l', 'a', 'r',\n+    'r',   3, 226, 159, 181,   3, 'm', 'a', 'p',   3, 226, 159, 188,   3, 'n',\n+    'i', 's',   3, 226, 139, 187,   4, 'o', 'd', 'o', 't',   3, 226, 168, 128,\n+      3, 'o', 'p', 'f',   4, 240, 157, 149, 169,   5, 'o', 'p', 'l', 'u', 's',\n+      3, 226, 168, 129,   5, 'o', 't', 'i', 'm', 'e',   3, 226, 168, 130,   4,\n+    'r', 'A', 'r', 'r',   3, 226, 159, 185,   4, 'r', 'a', 'r', 'r',   3, 226,\n+    159, 182,   3, 's', 'c', 'r',   4, 240, 157, 147, 141,   5, 's', 'q', 'c',\n+    'u', 'p',   3, 226, 168, 134,   5, 'u', 'p', 'l', 'u', 's',   3, 226, 168,\n+    132,   4, 'u', 't', 'r', 'i',   3, 226, 150, 179,   3, 'v', 'e', 'e',   3,\n+    226, 139, 129,   5, 'w', 'e', 'd', 'g', 'e',   3, 226, 139, 128, 133, 'a',\n+    'c', 'u', 't', 'e',   2, 195, 189,   3, 'a', 'c', 'y',   2, 209, 143,   4,\n+    'c', 'i', 'r', 'c',   2, 197, 183,   2, 'c', 'y',   2, 209, 139, 130, 'e',\n+    'n',   2, 194, 165,   2, 'f', 'r',   4, 240, 157, 148, 182,   3, 'i', 'c',\n+    'y',   2, 209, 151,   3, 'o', 'p', 'f',   4, 240, 157, 149, 170,   3, 's',\n+    'c', 'r',   4, 240, 157, 147, 142,   3, 'u', 'c', 'y',   2, 209, 142, 131,\n+    'u', 'm', 'l',   2, 195, 191,   5, 'a', 'c', 'u', 't', 'e',   2, 197, 186,\n+      5, 'c', 'a', 'r', 'o', 'n',   2, 197, 190,   2, 'c', 'y',   2, 208, 183,\n+      3, 'd', 'o', 't',   2, 197, 188,   5, 'e', 'e', 't', 'r', 'f',   3, 226,\n+    132, 168,   3, 'e', 't', 'a',   2, 206, 182,   2, 'f', 'r',   4, 240, 157,\n+    148, 183,   3, 'h', 'c', 'y',   2, 208, 182,   6, 'i', 'g', 'r', 'a', 'r',\n+    'r',   3, 226, 135, 157,   3, 'o', 'p', 'f',   4, 240, 157, 149, 171,   3,\n+    's', 'c', 'r',   4, 240, 157, 147, 143,   2, 'w', 'j',   3, 226, 128, 141,\n+      3, 'w', 'n', 'j',   3, 226, 128, 140\n+};\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/html5ent.inc","additions":1607,"deletions":0,"binary":false,"changes":1607,"status":"added"},{"patch":"@@ -24,0 +24,5 @@\n+\/*\n+ * Backward compatibility\n+ *\/\n+#define UTF8ToHtml htmlUTF8ToHtml\n+\n@@ -44,2 +49,2 @@\n-    const char *name;    \/* The tag name *\/\n-    char startTag;      \/* Whether the start tag can be implied *\/\n+    const char *name;   \/* The tag name *\/\n+    char startTag;      \/* unused *\/\n@@ -49,2 +54,2 @@\n-    char depr;          \/* Is this a deprecated element ? *\/\n-    char dtd;           \/* 1: only in Loose DTD, 2: only Frameset one *\/\n+    char depr;          \/* unused *\/\n+    char dtd;           \/* unused *\/\n@@ -54,16 +59,7 @@\n-\/* NRK Jan.2003\n- * New fields encapsulating HTML structure\n- *\n- * Bugs:\n- *    This is a very limited representation.  It fails to tell us when\n- *    an element *requires* subelements (we only have whether they're\n- *    allowed or not), and it doesn't tell us where CDATA and PCDATA\n- *    are allowed.  Some element relationships are not fully represented:\n- *    these are flagged with the word MODIFIER\n- *\/\n-    const char** subelts;        \/* allowed sub-elements of this element *\/\n-    const char* defaultsubelt;    \/* subelement for suggested auto-repair\n-                       if necessary or NULL *\/\n-    const char** attrs_opt;        \/* Optional Attributes *\/\n-    const char** attrs_depr;        \/* Additional deprecated attributes *\/\n-    const char** attrs_req;        \/* Required attributes *\/\n+    const char** subelts XML_DEPRECATED_MEMBER;\n+    const char* defaultsubelt XML_DEPRECATED_MEMBER;\n+    const char** attrs_opt XML_DEPRECATED_MEMBER;\n+    const char** attrs_depr XML_DEPRECATED_MEMBER;\n+    const char** attrs_req XML_DEPRECATED_MEMBER;\n+\n+    int dataMode;\n@@ -78,2 +74,2 @@\n-    unsigned int value;    \/* the UNICODE value for the character *\/\n-    const char *name;    \/* The entity name *\/\n+    unsigned int value; \/* the UNICODE value for the character *\/\n+    const char *name;   \/* The entity name *\/\n@@ -88,5 +84,0 @@\n-#ifdef LIBXML_THREAD_ENABLED\n-XML_DEPRECATED\n-XMLPUBFUN const xmlSAXHandlerV1 *__htmlDefaultSAXHandler(void);\n-#endif\n-\n@@ -100,1 +91,1 @@\n-            htmlInitAutoClose    (void);\n+                        htmlInitAutoClose       (void);\n@@ -102,1 +93,1 @@\n-            htmlTagLookup    (const xmlChar *tag);\n+                        htmlTagLookup   (const xmlChar *tag);\n@@ -104,1 +95,1 @@\n-            htmlEntityLookup(const xmlChar *name);\n+                        htmlEntityLookup(const xmlChar *name);\n@@ -106,1 +97,1 @@\n-            htmlEntityValueLookup(unsigned int value);\n+                        htmlEntityValueLookup(unsigned int value);\n@@ -108,0 +99,1 @@\n+XML_DEPRECATED\n@@ -109,2 +101,3 @@\n-            htmlIsAutoClosed(htmlDocPtr doc,\n-                     htmlNodePtr elem);\n+                        htmlIsAutoClosed(htmlDocPtr doc,\n+                                         htmlNodePtr elem);\n+XML_DEPRECATED\n@@ -112,3 +105,3 @@\n-            htmlAutoCloseTag(htmlDocPtr doc,\n-                     const xmlChar *name,\n-                     htmlNodePtr elem);\n+                        htmlAutoCloseTag(htmlDocPtr doc,\n+                                         const xmlChar *name,\n+                                         htmlNodePtr elem);\n@@ -117,2 +110,2 @@\n-            htmlParseEntityRef(htmlParserCtxtPtr ctxt,\n-                     const xmlChar **str);\n+                        htmlParseEntityRef(htmlParserCtxtPtr ctxt,\n+                                         const xmlChar **str);\n@@ -121,1 +114,1 @@\n-            htmlParseCharRef(htmlParserCtxtPtr ctxt);\n+                        htmlParseCharRef(htmlParserCtxtPtr ctxt);\n@@ -124,1 +117,1 @@\n-            htmlParseElement(htmlParserCtxtPtr ctxt);\n+                        htmlParseElement(htmlParserCtxtPtr ctxt);\n@@ -127,1 +120,1 @@\n-            htmlNewParserCtxt(void);\n+                        htmlNewParserCtxt(void);\n@@ -129,2 +122,2 @@\n-            htmlNewSAXParserCtxt(const htmlSAXHandler *sax,\n-                         void *userData);\n+                        htmlNewSAXParserCtxt(const htmlSAXHandler *sax,\n+                                             void *userData);\n@@ -133,2 +126,2 @@\n-            htmlCreateMemoryParserCtxt(const char *buffer,\n-                           int size);\n+                        htmlCreateMemoryParserCtxt(const char *buffer,\n+                                                   int size);\n@@ -137,1 +130,1 @@\n-            htmlParseDocument(htmlParserCtxtPtr ctxt);\n+                        htmlParseDocument(htmlParserCtxtPtr ctxt);\n@@ -140,4 +133,4 @@\n-            htmlSAXParseDoc    (const xmlChar *cur,\n-                     const char *encoding,\n-                     htmlSAXHandlerPtr sax,\n-                     void *userData);\n+                        htmlSAXParseDoc (const xmlChar *cur,\n+                                         const char *encoding,\n+                                         htmlSAXHandlerPtr sax,\n+                                         void *userData);\n@@ -145,2 +138,2 @@\n-            htmlParseDoc    (const xmlChar *cur,\n-                     const char *encoding);\n+                        htmlParseDoc    (const xmlChar *cur,\n+                                         const char *encoding);\n@@ -148,2 +141,2 @@\n-            htmlCreateFileParserCtxt(const char *filename,\n-                                             const char *encoding);\n+                        htmlCreateFileParserCtxt(const char *filename,\n+                                                 const char *encoding);\n@@ -152,4 +145,4 @@\n-            htmlSAXParseFile(const char *filename,\n-                     const char *encoding,\n-                     htmlSAXHandlerPtr sax,\n-                     void *userData);\n+                        htmlSAXParseFile(const char *filename,\n+                                         const char *encoding,\n+                                         htmlSAXHandlerPtr sax,\n+                                         void *userData);\n@@ -157,2 +150,2 @@\n-            htmlParseFile    (const char *filename,\n-                     const char *encoding);\n+                        htmlParseFile   (const char *filename,\n+                                         const char *encoding);\n@@ -160,4 +153,4 @@\n-            UTF8ToHtml    (unsigned char *out,\n-                     int *outlen,\n-                     const unsigned char *in,\n-                     int *inlen);\n+                        htmlUTF8ToHtml  (unsigned char *out,\n+                                         int *outlen,\n+                                         const unsigned char *in,\n+                                         int *inlen);\n@@ -165,4 +158,4 @@\n-            htmlEncodeEntities(unsigned char *out,\n-                     int *outlen,\n-                     const unsigned char *in,\n-                     int *inlen, int quoteChar);\n+                        htmlEncodeEntities(unsigned char *out,\n+                                         int *outlen,\n+                                         const unsigned char *in,\n+                                         int *inlen, int quoteChar);\n@@ -170,1 +163,1 @@\n-            htmlIsScriptAttribute(const xmlChar *name);\n+                        htmlIsScriptAttribute(const xmlChar *name);\n@@ -173,1 +166,1 @@\n-            htmlHandleOmittedElem(int val);\n+                        htmlHandleOmittedElem(int val);\n@@ -180,6 +173,6 @@\n-            htmlCreatePushParserCtxt(htmlSAXHandlerPtr sax,\n-                         void *user_data,\n-                         const char *chunk,\n-                         int size,\n-                         const char *filename,\n-                         xmlCharEncoding enc);\n+                        htmlCreatePushParserCtxt(htmlSAXHandlerPtr sax,\n+                                                 void *user_data,\n+                                                 const char *chunk,\n+                                                 int size,\n+                                                 const char *filename,\n+                                                 xmlCharEncoding enc);\n@@ -187,4 +180,4 @@\n-            htmlParseChunk        (htmlParserCtxtPtr ctxt,\n-                         const char *chunk,\n-                         int size,\n-                         int terminate);\n+                        htmlParseChunk          (htmlParserCtxtPtr ctxt,\n+                                                 const char *chunk,\n+                                                 int size,\n+                                                 int terminate);\n@@ -194,1 +187,1 @@\n-            htmlFreeParserCtxt    (htmlParserCtxtPtr ctxt);\n+                        htmlFreeParserCtxt      (htmlParserCtxtPtr ctxt);\n@@ -206,1 +199,1 @@\n-    HTML_PARSE_RECOVER  = 1<<0, \/* Relaxed parsing *\/\n+    HTML_PARSE_RECOVER  = 1<<0, \/* No effect *\/\n@@ -208,5 +201,5 @@\n-    HTML_PARSE_NOERROR    = 1<<5,    \/* suppress error reports *\/\n-    HTML_PARSE_NOWARNING= 1<<6,    \/* suppress warning reports *\/\n-    HTML_PARSE_PEDANTIC    = 1<<7,    \/* pedantic error reporting *\/\n-    HTML_PARSE_NOBLANKS    = 1<<8,    \/* remove blank nodes *\/\n-    HTML_PARSE_NONET    = 1<<11,\/* Forbid network access *\/\n+    HTML_PARSE_NOERROR  = 1<<5, \/* suppress error reports *\/\n+    HTML_PARSE_NOWARNING= 1<<6, \/* suppress warning reports *\/\n+    HTML_PARSE_PEDANTIC = 1<<7, \/* No effect *\/\n+    HTML_PARSE_NOBLANKS = 1<<8, \/* remove blank nodes *\/\n+    HTML_PARSE_NONET    = 1<<11,\/* No effect *\/\n@@ -215,1 +208,4 @@\n-    HTML_PARSE_IGNORE_ENC=1<<21 \/* ignore internal document encoding hint *\/\n+    HTML_PARSE_HUGE     = 1<<19,\/* relax any hardcoded limit from the parser *\/\n+    HTML_PARSE_IGNORE_ENC=1<<21,\/* ignore internal document encoding hint *\/\n+    HTML_PARSE_BIG_LINES= 1<<22,\/* Store big lines numbers in text PSVI field *\/\n+    HTML_PARSE_HTML5    = 1<<26 \/* HTML5 support *\/\n@@ -219,1 +215,4 @@\n-        htmlCtxtReset        (htmlParserCtxtPtr ctxt);\n+                htmlCtxtReset           (htmlParserCtxtPtr ctxt);\n+XMLPUBFUN int\n+                htmlCtxtSetOptions      (htmlParserCtxtPtr ctxt,\n+                                         int options);\n@@ -221,2 +220,2 @@\n-        htmlCtxtUseOptions    (htmlParserCtxtPtr ctxt,\n-                     int options);\n+                htmlCtxtUseOptions      (htmlParserCtxtPtr ctxt,\n+                                         int options);\n@@ -224,4 +223,4 @@\n-        htmlReadDoc        (const xmlChar *cur,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlReadDoc             (const xmlChar *cur,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -229,3 +228,3 @@\n-        htmlReadFile        (const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlReadFile            (const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -233,5 +232,5 @@\n-        htmlReadMemory        (const char *buffer,\n-                     int size,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlReadMemory          (const char *buffer,\n+                                         int size,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -239,4 +238,4 @@\n-        htmlReadFd        (int fd,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlReadFd              (int fd,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -244,6 +243,6 @@\n-        htmlReadIO        (xmlInputReadCallback ioread,\n-                     xmlInputCloseCallback ioclose,\n-                     void *ioctx,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlReadIO              (xmlInputReadCallback ioread,\n+                                         xmlInputCloseCallback ioclose,\n+                                         void *ioctx,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -251,2 +250,2 @@\n-        htmlCtxtParseDocument    (htmlParserCtxtPtr ctxt,\n-                     xmlParserInputPtr input);\n+                htmlCtxtParseDocument   (htmlParserCtxtPtr ctxt,\n+                                         xmlParserInputPtr input);\n@@ -254,5 +253,5 @@\n-        htmlCtxtReadDoc        (xmlParserCtxtPtr ctxt,\n-                     const xmlChar *cur,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlCtxtReadDoc         (xmlParserCtxtPtr ctxt,\n+                                         const xmlChar *cur,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -260,4 +259,4 @@\n-        htmlCtxtReadFile        (xmlParserCtxtPtr ctxt,\n-                     const char *filename,\n-                     const char *encoding,\n-                     int options);\n+                htmlCtxtReadFile                (xmlParserCtxtPtr ctxt,\n+                                         const char *filename,\n+                                         const char *encoding,\n+                                         int options);\n@@ -265,6 +264,6 @@\n-        htmlCtxtReadMemory        (xmlParserCtxtPtr ctxt,\n-                     const char *buffer,\n-                     int size,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlCtxtReadMemory              (xmlParserCtxtPtr ctxt,\n+                                         const char *buffer,\n+                                         int size,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -272,5 +271,5 @@\n-        htmlCtxtReadFd        (xmlParserCtxtPtr ctxt,\n-                     int fd,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlCtxtReadFd          (xmlParserCtxtPtr ctxt,\n+                                         int fd,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -278,7 +277,7 @@\n-        htmlCtxtReadIO        (xmlParserCtxtPtr ctxt,\n-                     xmlInputReadCallback ioread,\n-                     xmlInputCloseCallback ioclose,\n-                     void *ioctx,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                htmlCtxtReadIO          (xmlParserCtxtPtr ctxt,\n+                                         xmlInputReadCallback ioread,\n+                                         xmlInputCloseCallback ioclose,\n+                                         void *ioctx,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -286,1 +285,1 @@\n-\/* NRK\/Jan2003: further knowledge of HTML structure\n+\/* deprecated content model\n@@ -289,1 +288,1 @@\n-  HTML_NA = 0 ,        \/* something we don't check at all *\/\n+  HTML_NA = 0 ,         \/* something we don't check at all *\/\n@@ -299,0 +298,1 @@\n+XML_DEPRECATED\n@@ -300,0 +300,1 @@\n+XML_DEPRECATED\n@@ -301,0 +302,1 @@\n+XML_DEPRECATED\n@@ -302,0 +304,1 @@\n+XML_DEPRECATED\n@@ -321,1 +324,1 @@\n-    htmlElementAllowedHere((parent), (elt)->name)\n+        htmlElementAllowedHere((parent), (elt)->name)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/HTMLparser.h","additions":148,"deletions":145,"binary":false,"changes":293,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#define HTML_TEXT_NODE        XML_TEXT_NODE\n+#define HTML_TEXT_NODE          XML_TEXT_NODE\n@@ -46,1 +46,1 @@\n-#define HTML_COMMENT_NODE    XML_COMMENT_NODE\n+#define HTML_COMMENT_NODE       XML_COMMENT_NODE\n@@ -53,1 +53,1 @@\n-#define HTML_PRESERVE_NODE    XML_CDATA_SECTION_NODE\n+#define HTML_PRESERVE_NODE      XML_CDATA_SECTION_NODE\n@@ -60,1 +60,1 @@\n-#define HTML_PI_NODE        XML_PI_NODE\n+#define HTML_PI_NODE            XML_PI_NODE\n@@ -63,2 +63,2 @@\n-        htmlNewDoc        (const xmlChar *URI,\n-                     const xmlChar *ExternalID);\n+                htmlNewDoc              (const xmlChar *URI,\n+                                         const xmlChar *ExternalID);\n@@ -66,2 +66,2 @@\n-        htmlNewDocNoDtD        (const xmlChar *URI,\n-                     const xmlChar *ExternalID);\n+                htmlNewDocNoDtD         (const xmlChar *URI,\n+                                         const xmlChar *ExternalID);\n@@ -69,1 +69,1 @@\n-        htmlGetMetaEncoding    (htmlDocPtr doc);\n+                htmlGetMetaEncoding     (htmlDocPtr doc);\n@@ -71,2 +71,2 @@\n-        htmlSetMetaEncoding    (htmlDocPtr doc,\n-                     const xmlChar *encoding);\n+                htmlSetMetaEncoding     (htmlDocPtr doc,\n+                                         const xmlChar *encoding);\n@@ -75,3 +75,3 @@\n-        htmlDocDumpMemory    (xmlDocPtr cur,\n-                     xmlChar **mem,\n-                     int *size);\n+                htmlDocDumpMemory       (xmlDocPtr cur,\n+                                         xmlChar **mem,\n+                                         int *size);\n@@ -79,4 +79,4 @@\n-        htmlDocDumpMemoryFormat    (xmlDocPtr cur,\n-                     xmlChar **mem,\n-                     int *size,\n-                     int format);\n+                htmlDocDumpMemoryFormat (xmlDocPtr cur,\n+                                         xmlChar **mem,\n+                                         int *size,\n+                                         int format);\n@@ -84,2 +84,2 @@\n-        htmlDocDump        (FILE *f,\n-                     xmlDocPtr cur);\n+                htmlDocDump             (FILE *f,\n+                                         xmlDocPtr cur);\n@@ -87,2 +87,2 @@\n-        htmlSaveFile        (const char *filename,\n-                     xmlDocPtr cur);\n+                htmlSaveFile            (const char *filename,\n+                                         xmlDocPtr cur);\n@@ -90,3 +90,3 @@\n-        htmlNodeDump        (xmlBufferPtr buf,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur);\n+                htmlNodeDump            (xmlBufferPtr buf,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur);\n@@ -94,3 +94,3 @@\n-        htmlNodeDumpFile    (FILE *out,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur);\n+                htmlNodeDumpFile        (FILE *out,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur);\n@@ -98,5 +98,5 @@\n-        htmlNodeDumpFileFormat    (FILE *out,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur,\n-                     const char *encoding,\n-                     int format);\n+                htmlNodeDumpFileFormat  (FILE *out,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur,\n+                                         const char *encoding,\n+                                         int format);\n@@ -104,3 +104,3 @@\n-        htmlSaveFileEnc        (const char *filename,\n-                     xmlDocPtr cur,\n-                     const char *encoding);\n+                htmlSaveFileEnc         (const char *filename,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding);\n@@ -108,4 +108,4 @@\n-        htmlSaveFileFormat    (const char *filename,\n-                     xmlDocPtr cur,\n-                     const char *encoding,\n-                     int format);\n+                htmlSaveFileFormat      (const char *filename,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding,\n+                                         int format);\n@@ -114,5 +114,5 @@\n-        htmlNodeDumpFormatOutput(xmlOutputBufferPtr buf,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur,\n-                     const char *encoding,\n-                     int format);\n+                htmlNodeDumpFormatOutput(xmlOutputBufferPtr buf,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur,\n+                                         const char *encoding,\n+                                         int format);\n@@ -120,3 +120,3 @@\n-        htmlDocContentDumpOutput(xmlOutputBufferPtr buf,\n-                     xmlDocPtr cur,\n-                     const char *encoding);\n+                htmlDocContentDumpOutput(xmlOutputBufferPtr buf,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding);\n@@ -124,4 +124,4 @@\n-        htmlDocContentDumpFormatOutput(xmlOutputBufferPtr buf,\n-                     xmlDocPtr cur,\n-                     const char *encoding,\n-                     int format);\n+                htmlDocContentDumpFormatOutput(xmlOutputBufferPtr buf,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding,\n+                                         int format);\n@@ -129,4 +129,4 @@\n-        htmlNodeDumpOutput    (xmlOutputBufferPtr buf,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur,\n-                     const char *encoding);\n+                htmlNodeDumpOutput      (xmlOutputBufferPtr buf,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur,\n+                                         const char *encoding);\n@@ -136,0 +136,1 @@\n+XML_DEPRECATED\n@@ -137,1 +138,1 @@\n-        htmlIsBooleanAttr    (const xmlChar *name);\n+                htmlIsBooleanAttr       (const xmlChar *name);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/HTMLtree.h","additions":58,"deletions":57,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -11,1 +11,0 @@\n-\n@@ -15,7 +14,2 @@\n-#include <libxml\/xmlversion.h>\n-#include <libxml\/parser.h>\n-\n-#ifdef LIBXML_LEGACY_ENABLED\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n+#ifdef __GNUC__\n+  #warning \"libxml\/SAX.h is deprecated\"\n@@ -23,178 +17,0 @@\n-XML_DEPRECATED\n-XMLPUBFUN const xmlChar *\n-        getPublicId            (void *ctx);\n-XML_DEPRECATED\n-XMLPUBFUN const xmlChar *\n-        getSystemId            (void *ctx);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        setDocumentLocator        (void *ctx,\n-                         xmlSAXLocatorPtr loc);\n-\n-XML_DEPRECATED\n-XMLPUBFUN int\n-        getLineNumber            (void *ctx);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-        getColumnNumber            (void *ctx);\n-\n-XML_DEPRECATED\n-XMLPUBFUN int\n-        isStandalone            (void *ctx);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-        hasInternalSubset        (void *ctx);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-        hasExternalSubset        (void *ctx);\n-\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        internalSubset            (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        externalSubset            (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID);\n-XML_DEPRECATED\n-XMLPUBFUN xmlEntityPtr\n-        getEntity            (void *ctx,\n-                         const xmlChar *name);\n-XML_DEPRECATED\n-XMLPUBFUN xmlEntityPtr\n-        getParameterEntity        (void *ctx,\n-                         const xmlChar *name);\n-XML_DEPRECATED\n-XMLPUBFUN xmlParserInputPtr\n-        resolveEntity            (void *ctx,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId);\n-\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        entityDecl            (void *ctx,\n-                         const xmlChar *name,\n-                         int type,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId,\n-                         xmlChar *content);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        attributeDecl            (void *ctx,\n-                         const xmlChar *elem,\n-                         const xmlChar *fullname,\n-                         int type,\n-                         int def,\n-                         const xmlChar *defaultValue,\n-                         xmlEnumerationPtr tree);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        elementDecl            (void *ctx,\n-                         const xmlChar *name,\n-                         int type,\n-                         xmlElementContentPtr content);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        notationDecl            (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        unparsedEntityDecl        (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId,\n-                         const xmlChar *notationName);\n-\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        startDocument            (void *ctx);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        endDocument            (void *ctx);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        attribute            (void *ctx,\n-                         const xmlChar *fullname,\n-                         const xmlChar *value);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        startElement            (void *ctx,\n-                         const xmlChar *fullname,\n-                         const xmlChar **atts);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        endElement            (void *ctx,\n-                         const xmlChar *name);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        reference            (void *ctx,\n-                         const xmlChar *name);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        characters            (void *ctx,\n-                         const xmlChar *ch,\n-                         int len);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        ignorableWhitespace        (void *ctx,\n-                         const xmlChar *ch,\n-                         int len);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        processingInstruction        (void *ctx,\n-                         const xmlChar *target,\n-                         const xmlChar *data);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        globalNamespace            (void *ctx,\n-                         const xmlChar *href,\n-                         const xmlChar *prefix);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        setNamespace            (void *ctx,\n-                         const xmlChar *name);\n-XML_DEPRECATED\n-XMLPUBFUN xmlNsPtr\n-        getNamespace            (void *ctx);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-        checkNamespace            (void *ctx,\n-                         xmlChar *nameSpace);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        namespaceDecl            (void *ctx,\n-                         const xmlChar *href,\n-                         const xmlChar *prefix);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        comment                (void *ctx,\n-                         const xmlChar *value);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        cdataBlock            (void *ctx,\n-                         const xmlChar *value,\n-                         int len);\n-\n-#ifdef LIBXML_SAX1_ENABLED\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        initxmlDefaultSAXHandler    (xmlSAXHandlerV1 *hdlr,\n-                         int warning);\n-#ifdef LIBXML_HTML_ENABLED\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        inithtmlDefaultSAXHandler    (xmlSAXHandlerV1 *hdlr);\n-#endif\n-#endif \/* LIBXML_SAX1_ENABLED *\/\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n-#endif \/* LIBXML_LEGACY_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/SAX.h","additions":2,"deletions":186,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -22,1 +22,1 @@\n-        xmlSAX2GetPublicId        (void *ctx);\n+                xmlSAX2GetPublicId              (void *ctx);\n@@ -24,1 +24,1 @@\n-        xmlSAX2GetSystemId        (void *ctx);\n+                xmlSAX2GetSystemId              (void *ctx);\n@@ -26,2 +26,2 @@\n-        xmlSAX2SetDocumentLocator    (void *ctx,\n-                         xmlSAXLocatorPtr loc);\n+                xmlSAX2SetDocumentLocator       (void *ctx,\n+                                                 xmlSAXLocatorPtr loc);\n@@ -30,1 +30,1 @@\n-        xmlSAX2GetLineNumber        (void *ctx);\n+                xmlSAX2GetLineNumber            (void *ctx);\n@@ -32,1 +32,1 @@\n-        xmlSAX2GetColumnNumber        (void *ctx);\n+                xmlSAX2GetColumnNumber          (void *ctx);\n@@ -35,1 +35,1 @@\n-        xmlSAX2IsStandalone        (void *ctx);\n+                xmlSAX2IsStandalone             (void *ctx);\n@@ -37,1 +37,1 @@\n-        xmlSAX2HasInternalSubset    (void *ctx);\n+                xmlSAX2HasInternalSubset        (void *ctx);\n@@ -39,1 +39,1 @@\n-        xmlSAX2HasExternalSubset    (void *ctx);\n+                xmlSAX2HasExternalSubset        (void *ctx);\n@@ -42,4 +42,4 @@\n-        xmlSAX2InternalSubset        (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID);\n+                xmlSAX2InternalSubset           (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID);\n@@ -47,4 +47,4 @@\n-        xmlSAX2ExternalSubset        (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID);\n+                xmlSAX2ExternalSubset           (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID);\n@@ -52,2 +52,2 @@\n-        xmlSAX2GetEntity        (void *ctx,\n-                         const xmlChar *name);\n+                xmlSAX2GetEntity                (void *ctx,\n+                                                 const xmlChar *name);\n@@ -55,2 +55,2 @@\n-        xmlSAX2GetParameterEntity    (void *ctx,\n-                         const xmlChar *name);\n+                xmlSAX2GetParameterEntity       (void *ctx,\n+                                                 const xmlChar *name);\n@@ -58,3 +58,3 @@\n-        xmlSAX2ResolveEntity        (void *ctx,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId);\n+                xmlSAX2ResolveEntity            (void *ctx,\n+                                                 const xmlChar *publicId,\n+                                                 const xmlChar *systemId);\n@@ -63,30 +63,30 @@\n-        xmlSAX2EntityDecl        (void *ctx,\n-                         const xmlChar *name,\n-                         int type,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId,\n-                         xmlChar *content);\n-XMLPUBFUN void\n-        xmlSAX2AttributeDecl        (void *ctx,\n-                         const xmlChar *elem,\n-                         const xmlChar *fullname,\n-                         int type,\n-                         int def,\n-                         const xmlChar *defaultValue,\n-                         xmlEnumerationPtr tree);\n-XMLPUBFUN void\n-        xmlSAX2ElementDecl        (void *ctx,\n-                         const xmlChar *name,\n-                         int type,\n-                         xmlElementContentPtr content);\n-XMLPUBFUN void\n-        xmlSAX2NotationDecl        (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId);\n-XMLPUBFUN void\n-        xmlSAX2UnparsedEntityDecl    (void *ctx,\n-                         const xmlChar *name,\n-                         const xmlChar *publicId,\n-                         const xmlChar *systemId,\n-                         const xmlChar *notationName);\n+                xmlSAX2EntityDecl               (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 int type,\n+                                                 const xmlChar *publicId,\n+                                                 const xmlChar *systemId,\n+                                                 xmlChar *content);\n+XMLPUBFUN void\n+                xmlSAX2AttributeDecl            (void *ctx,\n+                                                 const xmlChar *elem,\n+                                                 const xmlChar *fullname,\n+                                                 int type,\n+                                                 int def,\n+                                                 const xmlChar *defaultValue,\n+                                                 xmlEnumerationPtr tree);\n+XMLPUBFUN void\n+                xmlSAX2ElementDecl              (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 int type,\n+                                                 xmlElementContentPtr content);\n+XMLPUBFUN void\n+                xmlSAX2NotationDecl             (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *publicId,\n+                                                 const xmlChar *systemId);\n+XMLPUBFUN void\n+                xmlSAX2UnparsedEntityDecl       (void *ctx,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *publicId,\n+                                                 const xmlChar *systemId,\n+                                                 const xmlChar *notationName);\n@@ -95,1 +95,1 @@\n-        xmlSAX2StartDocument        (void *ctx);\n+                xmlSAX2StartDocument            (void *ctx);\n@@ -97,41 +97,2 @@\n-        xmlSAX2EndDocument        (void *ctx);\n-#if defined(LIBXML_SAX1_ENABLED) || defined(LIBXML_HTML_ENABLED) || \\\n-    defined(LIBXML_WRITER_ENABLED) || defined(LIBXML_LEGACY_ENABLED)\n-XMLPUBFUN void\n-        xmlSAX2StartElement        (void *ctx,\n-                         const xmlChar *fullname,\n-                         const xmlChar **atts);\n-XMLPUBFUN void\n-        xmlSAX2EndElement        (void *ctx,\n-                         const xmlChar *name);\n-#endif \/* LIBXML_SAX1_ENABLED or LIBXML_HTML_ENABLED or LIBXML_LEGACY_ENABLED *\/\n-XMLPUBFUN void\n-        xmlSAX2StartElementNs        (void *ctx,\n-                         const xmlChar *localname,\n-                         const xmlChar *prefix,\n-                         const xmlChar *URI,\n-                         int nb_namespaces,\n-                         const xmlChar **namespaces,\n-                         int nb_attributes,\n-                         int nb_defaulted,\n-                         const xmlChar **attributes);\n-XMLPUBFUN void\n-        xmlSAX2EndElementNs        (void *ctx,\n-                         const xmlChar *localname,\n-                         const xmlChar *prefix,\n-                         const xmlChar *URI);\n-XMLPUBFUN void\n-        xmlSAX2Reference        (void *ctx,\n-                         const xmlChar *name);\n-XMLPUBFUN void\n-        xmlSAX2Characters        (void *ctx,\n-                         const xmlChar *ch,\n-                         int len);\n-XMLPUBFUN void\n-        xmlSAX2IgnorableWhitespace    (void *ctx,\n-                         const xmlChar *ch,\n-                         int len);\n-XMLPUBFUN void\n-        xmlSAX2ProcessingInstruction    (void *ctx,\n-                         const xmlChar *target,\n-                         const xmlChar *data);\n+                xmlSAX2EndDocument              (void *ctx);\n+XML_DEPRECATED\n@@ -139,2 +100,4 @@\n-        xmlSAX2Comment            (void *ctx,\n-                         const xmlChar *value);\n+                xmlSAX2StartElement             (void *ctx,\n+                                                 const xmlChar *fullname,\n+                                                 const xmlChar **atts);\n+XML_DEPRECATED\n@@ -142,3 +105,39 @@\n-        xmlSAX2CDataBlock        (void *ctx,\n-                         const xmlChar *value,\n-                         int len);\n+                xmlSAX2EndElement               (void *ctx,\n+                                                 const xmlChar *name);\n+XMLPUBFUN void\n+                xmlSAX2StartElementNs           (void *ctx,\n+                                                 const xmlChar *localname,\n+                                                 const xmlChar *prefix,\n+                                                 const xmlChar *URI,\n+                                                 int nb_namespaces,\n+                                                 const xmlChar **namespaces,\n+                                                 int nb_attributes,\n+                                                 int nb_defaulted,\n+                                                 const xmlChar **attributes);\n+XMLPUBFUN void\n+                xmlSAX2EndElementNs             (void *ctx,\n+                                                 const xmlChar *localname,\n+                                                 const xmlChar *prefix,\n+                                                 const xmlChar *URI);\n+XMLPUBFUN void\n+                xmlSAX2Reference                (void *ctx,\n+                                                 const xmlChar *name);\n+XMLPUBFUN void\n+                xmlSAX2Characters               (void *ctx,\n+                                                 const xmlChar *ch,\n+                                                 int len);\n+XMLPUBFUN void\n+                xmlSAX2IgnorableWhitespace      (void *ctx,\n+                                                 const xmlChar *ch,\n+                                                 int len);\n+XMLPUBFUN void\n+                xmlSAX2ProcessingInstruction    (void *ctx,\n+                                                 const xmlChar *target,\n+                                                 const xmlChar *data);\n+XMLPUBFUN void\n+                xmlSAX2Comment                  (void *ctx,\n+                                                 const xmlChar *value);\n+XMLPUBFUN void\n+                xmlSAX2CDataBlock               (void *ctx,\n+                                                 const xmlChar *value,\n+                                                 int len);\n@@ -149,1 +148,1 @@\n-        xmlSAXDefaultVersion        (int version);\n+                xmlSAXDefaultVersion            (int version);\n@@ -153,2 +152,2 @@\n-        xmlSAXVersion            (xmlSAXHandler *hdlr,\n-                         int version);\n+                xmlSAXVersion                   (xmlSAXHandler *hdlr,\n+                                                 int version);\n@@ -156,2 +155,2 @@\n-        xmlSAX2InitDefaultSAXHandler    (xmlSAXHandler *hdlr,\n-                         int warning);\n+                xmlSAX2InitDefaultSAXHandler    (xmlSAXHandler *hdlr,\n+                                                 int warning);\n@@ -160,1 +159,1 @@\n-        xmlSAX2InitHtmlDefaultSAXHandler(xmlSAXHandler *hdlr);\n+                xmlSAX2InitHtmlDefaultSAXHandler(xmlSAXHandler *hdlr);\n@@ -163,1 +162,1 @@\n-        htmlDefaultSAXHandlerInit    (void);\n+                htmlDefaultSAXHandlerInit       (void);\n@@ -167,1 +166,1 @@\n-        xmlDefaultSAXHandlerInit    (void);\n+                xmlDefaultSAXHandlerInit        (void);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/SAX2.h","additions":108,"deletions":109,"binary":false,"changes":217,"status":"modified"},{"patch":"@@ -58,6 +58,6 @@\n-        xmlC14NDocSaveTo    (xmlDocPtr doc,\n-                     xmlNodeSetPtr nodes,\n-                     int mode, \/* a xmlC14NMode *\/\n-                     xmlChar **inclusive_ns_prefixes,\n-                     int with_comments,\n-                     xmlOutputBufferPtr buf);\n+                xmlC14NDocSaveTo        (xmlDocPtr doc,\n+                                         xmlNodeSetPtr nodes,\n+                                         int mode, \/* a xmlC14NMode *\/\n+                                         xmlChar **inclusive_ns_prefixes,\n+                                         int with_comments,\n+                                         xmlOutputBufferPtr buf);\n@@ -66,6 +66,6 @@\n-        xmlC14NDocDumpMemory    (xmlDocPtr doc,\n-                     xmlNodeSetPtr nodes,\n-                     int mode, \/* a xmlC14NMode *\/\n-                     xmlChar **inclusive_ns_prefixes,\n-                     int with_comments,\n-                     xmlChar **doc_txt_ptr);\n+                xmlC14NDocDumpMemory    (xmlDocPtr doc,\n+                                         xmlNodeSetPtr nodes,\n+                                         int mode, \/* a xmlC14NMode *\/\n+                                         xmlChar **inclusive_ns_prefixes,\n+                                         int with_comments,\n+                                         xmlChar **doc_txt_ptr);\n@@ -74,7 +74,7 @@\n-        xmlC14NDocSave        (xmlDocPtr doc,\n-                     xmlNodeSetPtr nodes,\n-                     int mode, \/* a xmlC14NMode *\/\n-                     xmlChar **inclusive_ns_prefixes,\n-                     int with_comments,\n-                     const char* filename,\n-                     int compression);\n+                xmlC14NDocSave          (xmlDocPtr doc,\n+                                         xmlNodeSetPtr nodes,\n+                                         int mode, \/* a xmlC14NMode *\/\n+                                         xmlChar **inclusive_ns_prefixes,\n+                                         int with_comments,\n+                                         const char* filename,\n+                                         int compression);\n@@ -96,3 +96,3 @@\n-typedef int (*xmlC14NIsVisibleCallback)    (void* user_data,\n-                     xmlNodePtr node,\n-                     xmlNodePtr parent);\n+typedef int (*xmlC14NIsVisibleCallback) (void* user_data,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr parent);\n@@ -101,7 +101,7 @@\n-        xmlC14NExecute        (xmlDocPtr doc,\n-                     xmlC14NIsVisibleCallback is_visible_callback,\n-                     void* user_data,\n-                     int mode, \/* a xmlC14NMode *\/\n-                     xmlChar **inclusive_ns_prefixes,\n-                     int with_comments,\n-                     xmlOutputBufferPtr buf);\n+                xmlC14NExecute          (xmlDocPtr doc,\n+                                         xmlC14NIsVisibleCallback is_visible_callback,\n+                                         void* user_data,\n+                                         int mode, \/* a xmlC14NMode *\/\n+                                         xmlChar **inclusive_ns_prefixes,\n+                                         int with_comments,\n+                                         xmlOutputBufferPtr buf);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/c14n.h","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#define XML_CATALOGS_NAMESPACE                    \\\n+#define XML_CATALOGS_NAMESPACE                                  \\\n@@ -44,1 +44,1 @@\n-#define XML_CATALOG_PI                        \\\n+#define XML_CATALOG_PI                                          \\\n@@ -70,1 +70,1 @@\n-        xmlNewCatalog        (int sgml);\n+                xmlNewCatalog           (int sgml);\n@@ -72,1 +72,1 @@\n-        xmlLoadACatalog        (const char *filename);\n+                xmlLoadACatalog         (const char *filename);\n@@ -74,1 +74,1 @@\n-        xmlLoadSGMLSuperCatalog    (const char *filename);\n+                xmlLoadSGMLSuperCatalog (const char *filename);\n@@ -76,1 +76,1 @@\n-        xmlConvertSGMLCatalog    (xmlCatalogPtr catal);\n+                xmlConvertSGMLCatalog   (xmlCatalogPtr catal);\n@@ -78,4 +78,4 @@\n-        xmlACatalogAdd        (xmlCatalogPtr catal,\n-                     const xmlChar *type,\n-                     const xmlChar *orig,\n-                     const xmlChar *replace);\n+                xmlACatalogAdd          (xmlCatalogPtr catal,\n+                                         const xmlChar *type,\n+                                         const xmlChar *orig,\n+                                         const xmlChar *replace);\n@@ -83,2 +83,2 @@\n-        xmlACatalogRemove    (xmlCatalogPtr catal,\n-                     const xmlChar *value);\n+                xmlACatalogRemove       (xmlCatalogPtr catal,\n+                                         const xmlChar *value);\n@@ -86,3 +86,3 @@\n-        xmlACatalogResolve    (xmlCatalogPtr catal,\n-                     const xmlChar *pubID,\n-                                     const xmlChar *sysID);\n+                xmlACatalogResolve      (xmlCatalogPtr catal,\n+                                         const xmlChar *pubID,\n+                                         const xmlChar *sysID);\n@@ -90,2 +90,2 @@\n-        xmlACatalogResolveSystem(xmlCatalogPtr catal,\n-                     const xmlChar *sysID);\n+                xmlACatalogResolveSystem(xmlCatalogPtr catal,\n+                                         const xmlChar *sysID);\n@@ -93,2 +93,2 @@\n-        xmlACatalogResolvePublic(xmlCatalogPtr catal,\n-                     const xmlChar *pubID);\n+                xmlACatalogResolvePublic(xmlCatalogPtr catal,\n+                                         const xmlChar *pubID);\n@@ -96,2 +96,2 @@\n-        xmlACatalogResolveURI    (xmlCatalogPtr catal,\n-                     const xmlChar *URI);\n+                xmlACatalogResolveURI   (xmlCatalogPtr catal,\n+                                         const xmlChar *URI);\n@@ -100,2 +100,2 @@\n-        xmlACatalogDump        (xmlCatalogPtr catal,\n-                     FILE *out);\n+                xmlACatalogDump         (xmlCatalogPtr catal,\n+                                         FILE *out);\n@@ -104,1 +104,1 @@\n-        xmlFreeCatalog        (xmlCatalogPtr catal);\n+                xmlFreeCatalog          (xmlCatalogPtr catal);\n@@ -106,1 +106,1 @@\n-        xmlCatalogIsEmpty    (xmlCatalogPtr catal);\n+                xmlCatalogIsEmpty       (xmlCatalogPtr catal);\n@@ -112,1 +112,1 @@\n-        xmlInitializeCatalog    (void);\n+                xmlInitializeCatalog    (void);\n@@ -114,1 +114,1 @@\n-        xmlLoadCatalog        (const char *filename);\n+                xmlLoadCatalog          (const char *filename);\n@@ -116,1 +116,1 @@\n-        xmlLoadCatalogs        (const char *paths);\n+                xmlLoadCatalogs         (const char *paths);\n@@ -118,1 +118,1 @@\n-        xmlCatalogCleanup    (void);\n+                xmlCatalogCleanup       (void);\n@@ -121,1 +121,1 @@\n-        xmlCatalogDump        (FILE *out);\n+                xmlCatalogDump          (FILE *out);\n@@ -124,2 +124,2 @@\n-        xmlCatalogResolve    (const xmlChar *pubID,\n-                                     const xmlChar *sysID);\n+                xmlCatalogResolve       (const xmlChar *pubID,\n+                                         const xmlChar *sysID);\n@@ -127,1 +127,1 @@\n-        xmlCatalogResolveSystem    (const xmlChar *sysID);\n+                xmlCatalogResolveSystem (const xmlChar *sysID);\n@@ -129,1 +129,1 @@\n-        xmlCatalogResolvePublic    (const xmlChar *pubID);\n+                xmlCatalogResolvePublic (const xmlChar *pubID);\n@@ -131,1 +131,1 @@\n-        xmlCatalogResolveURI    (const xmlChar *URI);\n+                xmlCatalogResolveURI    (const xmlChar *URI);\n@@ -133,3 +133,3 @@\n-        xmlCatalogAdd        (const xmlChar *type,\n-                     const xmlChar *orig,\n-                     const xmlChar *replace);\n+                xmlCatalogAdd           (const xmlChar *type,\n+                                         const xmlChar *orig,\n+                                         const xmlChar *replace);\n@@ -137,1 +137,1 @@\n-        xmlCatalogRemove    (const xmlChar *value);\n+                xmlCatalogRemove        (const xmlChar *value);\n@@ -139,1 +139,1 @@\n-        xmlParseCatalogFile    (const char *filename);\n+                xmlParseCatalogFile     (const char *filename);\n@@ -141,1 +141,1 @@\n-        xmlCatalogConvert    (void);\n+                xmlCatalogConvert       (void);\n@@ -148,1 +148,1 @@\n-        xmlCatalogFreeLocal    (void *catalogs);\n+                xmlCatalogFreeLocal     (void *catalogs);\n@@ -150,2 +150,2 @@\n-        xmlCatalogAddLocal    (void *catalogs,\n-                     const xmlChar *URL);\n+                xmlCatalogAddLocal      (void *catalogs,\n+                                         const xmlChar *URL);\n@@ -153,3 +153,3 @@\n-        xmlCatalogLocalResolve    (void *catalogs,\n-                     const xmlChar *pubID,\n-                                     const xmlChar *sysID);\n+                xmlCatalogLocalResolve  (void *catalogs,\n+                                         const xmlChar *pubID,\n+                                         const xmlChar *sysID);\n@@ -157,2 +157,2 @@\n-        xmlCatalogLocalResolveURI(void *catalogs,\n-                     const xmlChar *URI);\n+                xmlCatalogLocalResolveURI(void *catalogs,\n+                                         const xmlChar *URI);\n@@ -163,1 +163,2 @@\n-        xmlCatalogSetDebug    (int level);\n+                xmlCatalogSetDebug      (int level);\n+XML_DEPRECATED\n@@ -165,1 +166,1 @@\n-        xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer);\n+                xmlCatalogSetDefaultPrefer(xmlCatalogPrefer prefer);\n@@ -167,1 +168,1 @@\n-        xmlCatalogSetDefaults    (xmlCatalogAllow allow);\n+                xmlCatalogSetDefaults   (xmlCatalogAllow allow);\n@@ -169,1 +170,1 @@\n-        xmlCatalogGetDefaults    (void);\n+                xmlCatalogGetDefaults   (void);\n@@ -174,1 +175,1 @@\n-        xmlCatalogGetSystem    (const xmlChar *sysID);\n+                xmlCatalogGetSystem     (const xmlChar *sysID);\n@@ -176,1 +177,1 @@\n-        xmlCatalogGetPublic    (const xmlChar *pubID);\n+                xmlCatalogGetPublic     (const xmlChar *pubID);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/catalog.h","additions":56,"deletions":55,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-    unsigned short    low;\n-    unsigned short    high;\n+    unsigned short      low;\n+    unsigned short      high;\n@@ -38,2 +38,2 @@\n-    unsigned int    low;\n-    unsigned int    high;\n+    unsigned int        low;\n+    unsigned int        high;\n@@ -45,4 +45,4 @@\n-    int            nbShortRange;\n-    int            nbLongRange;\n-    const xmlChSRange    *shortRange;    \/* points to an array of ranges *\/\n-    const xmlChLRange    *longRange;\n+    int                 nbShortRange;\n+    int                 nbLongRange;\n+    const xmlChSRange   *shortRange;    \/* points to an array of ranges *\/\n+    const xmlChLRange   *longRange;\n@@ -55,1 +55,1 @@\n-        xmlCharInRange(unsigned int val, const xmlChRangeGroup *group);\n+                xmlCharInRange(unsigned int val, const xmlChRangeGroup *group);\n@@ -64,5 +64,5 @@\n-#define xmlIsBaseChar_ch(c)    (((0x41 <= (c)) && ((c) <= 0x5a)) || \\\n-                 ((0x61 <= (c)) && ((c) <= 0x7a)) || \\\n-                 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \\\n-                 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \\\n-                  (0xf8 <= (c)))\n+#define xmlIsBaseChar_ch(c)     (((0x41 <= (c)) && ((c) <= 0x5a)) || \\\n+                                 ((0x61 <= (c)) && ((c) <= 0x7a)) || \\\n+                                 ((0xc0 <= (c)) && ((c) <= 0xd6)) || \\\n+                                 ((0xd8 <= (c)) && ((c) <= 0xf6)) || \\\n+                                  (0xf8 <= (c)))\n@@ -76,3 +76,3 @@\n-#define xmlIsBaseCharQ(c)    (((c) < 0x100) ? \\\n-                 xmlIsBaseChar_ch((c)) : \\\n-                 xmlCharInRange((c), &xmlIsBaseCharGroup))\n+#define xmlIsBaseCharQ(c)       (((c) < 0x100) ? \\\n+                                 xmlIsBaseChar_ch((c)) : \\\n+                                 xmlCharInRange((c), &xmlIsBaseCharGroup))\n@@ -88,3 +88,3 @@\n-#define xmlIsBlank_ch(c)    (((c) == 0x20) || \\\n-                 ((0x9 <= (c)) && ((c) <= 0xa)) || \\\n-                 ((c) == 0xd))\n+#define xmlIsBlank_ch(c)        (((c) == 0x20) || \\\n+                                 ((0x9 <= (c)) && ((c) <= 0xa)) || \\\n+                                 ((c) == 0xd))\n@@ -98,2 +98,2 @@\n-#define xmlIsBlankQ(c)        (((c) < 0x100) ? \\\n-                 xmlIsBlank_ch((c)) : 0)\n+#define xmlIsBlankQ(c)          (((c) < 0x100) ? \\\n+                                 xmlIsBlank_ch((c)) : 0)\n@@ -108,3 +108,3 @@\n-#define xmlIsChar_ch(c)        (((0x9 <= (c)) && ((c) <= 0xa)) || \\\n-                 ((c) == 0xd) || \\\n-                  (0x20 <= (c)))\n+#define xmlIsChar_ch(c)         (((0x9 <= (c)) && ((c) <= 0xa)) || \\\n+                                 ((c) == 0xd) || \\\n+                                  (0x20 <= (c)))\n@@ -118,5 +118,5 @@\n-#define xmlIsCharQ(c)        (((c) < 0x100) ? \\\n-                 xmlIsChar_ch((c)) :\\\n-                (((0x100 <= (c)) && ((c) <= 0xd7ff)) || \\\n-                 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \\\n-                 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))\n+#define xmlIsCharQ(c)           (((c) < 0x100) ? \\\n+                                 xmlIsChar_ch((c)) :\\\n+                                (((0x100 <= (c)) && ((c) <= 0xd7ff)) || \\\n+                                 ((0xe000 <= (c)) && ((c) <= 0xfffd)) || \\\n+                                 ((0x10000 <= (c)) && ((c) <= 0x10ffff))))\n@@ -132,3 +132,3 @@\n-#define xmlIsCombiningQ(c)    (((c) < 0x100) ? \\\n-                 0 : \\\n-                 xmlCharInRange((c), &xmlIsCombiningGroup))\n+#define xmlIsCombiningQ(c)      (((c) < 0x100) ? \\\n+                                 0 : \\\n+                                 xmlCharInRange((c), &xmlIsCombiningGroup))\n@@ -144,1 +144,1 @@\n-#define xmlIsDigit_ch(c)    (((0x30 <= (c)) && ((c) <= 0x39)))\n+#define xmlIsDigit_ch(c)        (((0x30 <= (c)) && ((c) <= 0x39)))\n@@ -152,3 +152,3 @@\n-#define xmlIsDigitQ(c)        (((c) < 0x100) ? \\\n-                 xmlIsDigit_ch((c)) : \\\n-                 xmlCharInRange((c), &xmlIsDigitGroup))\n+#define xmlIsDigitQ(c)          (((c) < 0x100) ? \\\n+                                 xmlIsDigit_ch((c)) : \\\n+                                 xmlCharInRange((c), &xmlIsDigitGroup))\n@@ -164,1 +164,1 @@\n-#define xmlIsExtender_ch(c)    (((c) == 0xb7))\n+#define xmlIsExtender_ch(c)     (((c) == 0xb7))\n@@ -172,3 +172,3 @@\n-#define xmlIsExtenderQ(c)    (((c) < 0x100) ? \\\n-                 xmlIsExtender_ch((c)) : \\\n-                 xmlCharInRange((c), &xmlIsExtenderGroup))\n+#define xmlIsExtenderQ(c)       (((c) < 0x100) ? \\\n+                                 xmlIsExtender_ch((c)) : \\\n+                                 xmlCharInRange((c), &xmlIsExtenderGroup))\n@@ -185,4 +185,4 @@\n-                 0 :\\\n-                (((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \\\n-                 ((c) == 0x3007) || \\\n-                 ((0x3021 <= (c)) && ((c) <= 0x3029))))\n+                                 0 :\\\n+                                (((0x4e00 <= (c)) && ((c) <= 0x9fa5)) || \\\n+                                 ((c) == 0x3007) || \\\n+                                 ((0x3021 <= (c)) && ((c) <= 0x3029))))\n@@ -207,2 +207,2 @@\n-#define xmlIsPubidCharQ(c)    (((c) < 0x100) ? \\\n-                 xmlIsPubidChar_ch((c)) : 0)\n+#define xmlIsPubidCharQ(c)      (((c) < 0x100) ? \\\n+                                 xmlIsPubidChar_ch((c)) : 0)\n@@ -211,1 +211,1 @@\n-        xmlIsBaseChar(unsigned int ch);\n+                xmlIsBaseChar(unsigned int ch);\n@@ -213,1 +213,1 @@\n-        xmlIsBlank(unsigned int ch);\n+                xmlIsBlank(unsigned int ch);\n@@ -215,1 +215,1 @@\n-        xmlIsChar(unsigned int ch);\n+                xmlIsChar(unsigned int ch);\n@@ -217,1 +217,1 @@\n-        xmlIsCombining(unsigned int ch);\n+                xmlIsCombining(unsigned int ch);\n@@ -219,1 +219,1 @@\n-        xmlIsDigit(unsigned int ch);\n+                xmlIsDigit(unsigned int ch);\n@@ -221,1 +221,1 @@\n-        xmlIsExtender(unsigned int ch);\n+                xmlIsExtender(unsigned int ch);\n@@ -223,1 +223,1 @@\n-        xmlIsIdeographic(unsigned int ch);\n+                xmlIsIdeographic(unsigned int ch);\n@@ -225,1 +225,1 @@\n-        xmlIsPubidChar(unsigned int ch);\n+                xmlIsPubidChar(unsigned int ch);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/chvalid.h","additions":55,"deletions":55,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-    xmlDebugDumpString    (FILE *output,\n-                 const xmlChar *str);\n+        xmlDebugDumpString      (FILE *output,\n+                                 const xmlChar *str);\n@@ -32,3 +32,3 @@\n-    xmlDebugDumpAttr    (FILE *output,\n-                 xmlAttrPtr attr,\n-                 int depth);\n+        xmlDebugDumpAttr        (FILE *output,\n+                                 xmlAttrPtr attr,\n+                                 int depth);\n@@ -36,3 +36,3 @@\n-    xmlDebugDumpAttrList    (FILE *output,\n-                 xmlAttrPtr attr,\n-                 int depth);\n+        xmlDebugDumpAttrList    (FILE *output,\n+                                 xmlAttrPtr attr,\n+                                 int depth);\n@@ -40,3 +40,3 @@\n-    xmlDebugDumpOneNode    (FILE *output,\n-                 xmlNodePtr node,\n-                 int depth);\n+        xmlDebugDumpOneNode     (FILE *output,\n+                                 xmlNodePtr node,\n+                                 int depth);\n@@ -44,3 +44,3 @@\n-    xmlDebugDumpNode    (FILE *output,\n-                 xmlNodePtr node,\n-                 int depth);\n+        xmlDebugDumpNode        (FILE *output,\n+                                 xmlNodePtr node,\n+                                 int depth);\n@@ -48,3 +48,3 @@\n-    xmlDebugDumpNodeList    (FILE *output,\n-                 xmlNodePtr node,\n-                 int depth);\n+        xmlDebugDumpNodeList    (FILE *output,\n+                                 xmlNodePtr node,\n+                                 int depth);\n@@ -52,2 +52,2 @@\n-    xmlDebugDumpDocumentHead(FILE *output,\n-                 xmlDocPtr doc);\n+        xmlDebugDumpDocumentHead(FILE *output,\n+                                 xmlDocPtr doc);\n@@ -55,2 +55,2 @@\n-    xmlDebugDumpDocument    (FILE *output,\n-                 xmlDocPtr doc);\n+        xmlDebugDumpDocument    (FILE *output,\n+                                 xmlDocPtr doc);\n@@ -58,2 +58,2 @@\n-    xmlDebugDumpDTD        (FILE *output,\n-                 xmlDtdPtr dtd);\n+        xmlDebugDumpDTD         (FILE *output,\n+                                 xmlDtdPtr dtd);\n@@ -61,2 +61,2 @@\n-    xmlDebugDumpEntities    (FILE *output,\n-                 xmlDocPtr doc);\n+        xmlDebugDumpEntities    (FILE *output,\n+                                 xmlDocPtr doc);\n@@ -65,3 +65,3 @@\n- *                                *\n- *            Checking routines            *\n- *                                *\n+ *                                                              *\n+ *                      Checking routines                       *\n+ *                                                              *\n@@ -71,140 +71,2 @@\n-    xmlDebugCheckDocument    (FILE * output,\n-                 xmlDocPtr doc);\n-\n-\/****************************************************************\n- *                                *\n- *            XML shell helpers            *\n- *                                *\n- ****************************************************************\/\n-\n-XMLPUBFUN void\n-    xmlLsOneNode        (FILE *output, xmlNodePtr node);\n-XMLPUBFUN int\n-    xmlLsCountNode        (xmlNodePtr node);\n-\n-XMLPUBFUN const char *\n-    xmlBoolToText        (int boolval);\n-\n-\/****************************************************************\n- *                                *\n- *     The XML shell related structures and functions        *\n- *                                *\n- ****************************************************************\/\n-\n-#ifdef LIBXML_XPATH_ENABLED\n-\/**\n- * xmlShellReadlineFunc:\n- * @prompt:  a string prompt\n- *\n- * This is a generic signature for the XML shell input function.\n- *\n- * Returns a string which will be freed by the Shell.\n- *\/\n-typedef char * (* xmlShellReadlineFunc)(char *prompt);\n-\n-\/**\n- * xmlShellCtxt:\n- *\n- * A debugging shell context.\n- * TODO: add the defined function tables.\n- *\/\n-typedef struct _xmlShellCtxt xmlShellCtxt;\n-typedef xmlShellCtxt *xmlShellCtxtPtr;\n-struct _xmlShellCtxt {\n-    char *filename;\n-    xmlDocPtr doc;\n-    xmlNodePtr node;\n-    xmlXPathContextPtr pctxt;\n-    int loaded;\n-    FILE *output;\n-    xmlShellReadlineFunc input;\n-};\n-\n-\/**\n- * xmlShellCmd:\n- * @ctxt:  a shell context\n- * @arg:  a string argument\n- * @node:  a first node\n- * @node2:  a second node\n- *\n- * This is a generic signature for the XML shell functions.\n- *\n- * Returns an int, negative returns indicating errors.\n- *\/\n-typedef int (* xmlShellCmd) (xmlShellCtxtPtr ctxt,\n-                             char *arg,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n-\n-XMLPUBFUN void\n-    xmlShellPrintXPathError    (int errorType,\n-                 const char *arg);\n-XMLPUBFUN void\n-    xmlShellPrintXPathResult(xmlXPathObjectPtr list);\n-XMLPUBFUN int\n-    xmlShellList        (xmlShellCtxtPtr ctxt,\n-                 char *arg,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n-XMLPUBFUN int\n-    xmlShellBase        (xmlShellCtxtPtr ctxt,\n-                 char *arg,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n-XMLPUBFUN int\n-    xmlShellDir        (xmlShellCtxtPtr ctxt,\n-                 char *arg,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n-XMLPUBFUN int\n-    xmlShellLoad        (xmlShellCtxtPtr ctxt,\n-                 char *filename,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n-#ifdef LIBXML_OUTPUT_ENABLED\n-XMLPUBFUN void\n-    xmlShellPrintNode    (xmlNodePtr node);\n-XMLPUBFUN int\n-    xmlShellCat        (xmlShellCtxtPtr ctxt,\n-                 char *arg,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n-XMLPUBFUN int\n-    xmlShellWrite        (xmlShellCtxtPtr ctxt,\n-                 char *filename,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n-XMLPUBFUN int\n-    xmlShellSave        (xmlShellCtxtPtr ctxt,\n-                 char *filename,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n-#ifdef LIBXML_VALID_ENABLED\n-XMLPUBFUN int\n-    xmlShellValidate    (xmlShellCtxtPtr ctxt,\n-                 char *dtd,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n-#endif \/* LIBXML_VALID_ENABLED *\/\n-XMLPUBFUN int\n-    xmlShellDu        (xmlShellCtxtPtr ctxt,\n-                 char *arg,\n-                 xmlNodePtr tree,\n-                 xmlNodePtr node2);\n-XMLPUBFUN int\n-    xmlShellPwd        (xmlShellCtxtPtr ctxt,\n-                 char *buffer,\n-                 xmlNodePtr node,\n-                 xmlNodePtr node2);\n-\n-\/*\n- * The Shell interface.\n- *\/\n-XMLPUBFUN void\n-    xmlShell        (xmlDocPtr doc,\n-                 const char *filename,\n-                 xmlShellReadlineFunc input,\n-                 FILE *output);\n-\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n+        xmlDebugCheckDocument   (FILE * output,\n+                                 xmlDocPtr doc);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/debugXML.h","additions":30,"deletions":168,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-            xmlDictCreate    (void);\n+                        xmlDictCreate   (void);\n@@ -40,1 +40,1 @@\n-            xmlDictSetLimit    (xmlDictPtr dict,\n+                        xmlDictSetLimit (xmlDictPtr dict,\n@@ -43,1 +43,1 @@\n-            xmlDictGetUsage (xmlDictPtr dict);\n+                        xmlDictGetUsage (xmlDictPtr dict);\n@@ -45,1 +45,1 @@\n-            xmlDictCreateSub(xmlDictPtr sub);\n+                        xmlDictCreateSub(xmlDictPtr sub);\n@@ -47,1 +47,1 @@\n-            xmlDictReference(xmlDictPtr dict);\n+                        xmlDictReference(xmlDictPtr dict);\n@@ -49,1 +49,1 @@\n-            xmlDictFree    (xmlDictPtr dict);\n+                        xmlDictFree     (xmlDictPtr dict);\n@@ -55,3 +55,3 @@\n-            xmlDictLookup    (xmlDictPtr dict,\n-                                 const xmlChar *name,\n-                                 int len);\n+                        xmlDictLookup   (xmlDictPtr dict,\n+                                         const xmlChar *name,\n+                                         int len);\n@@ -59,3 +59,3 @@\n-            xmlDictExists    (xmlDictPtr dict,\n-                                 const xmlChar *name,\n-                                 int len);\n+                        xmlDictExists   (xmlDictPtr dict,\n+                                         const xmlChar *name,\n+                                         int len);\n@@ -63,3 +63,3 @@\n-            xmlDictQLookup    (xmlDictPtr dict,\n-                                 const xmlChar *prefix,\n-                                 const xmlChar *name);\n+                        xmlDictQLookup  (xmlDictPtr dict,\n+                                         const xmlChar *prefix,\n+                                         const xmlChar *name);\n@@ -67,2 +67,2 @@\n-            xmlDictOwns    (xmlDictPtr dict,\n-                     const xmlChar *str);\n+                        xmlDictOwns     (xmlDictPtr dict,\n+                                         const xmlChar *str);\n@@ -70,1 +70,1 @@\n-            xmlDictSize    (xmlDictPtr dict);\n+                        xmlDictSize     (xmlDictPtr dict);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/dict.h","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -26,4 +26,1 @@\n-\n-#ifdef LIBXML_ICONV_ENABLED\n-#include <iconv.h>\n-#endif\n+#include <libxml\/xmlerror.h>\n@@ -35,0 +32,6 @@\n+\/*\n+ * Backward compatibility\n+ *\/\n+#define UTF8Toisolat1 xmlUTF8ToIsolat1\n+#define isolat1ToUTF8 xmlIsolat1ToUTF8\n+\n@@ -37,1 +40,1 @@\n-    XML_ENC_ERR_SPACE       = -1,\n+    XML_ENC_ERR_INTERNAL    = -1,\n@@ -39,3 +42,2 @@\n-    XML_ENC_ERR_PARTIAL     = -3,\n-    XML_ENC_ERR_INTERNAL    = -4,\n-    XML_ENC_ERR_MEMORY      = -5\n+    XML_ENC_ERR_SPACE       = -3,\n+    XML_ENC_ERR_MEMORY      = -4\n@@ -48,16 +50,0 @@\n- * Libxml does not do beforehand translation on UTF8 and ISOLatinX.\n- * It also supports ASCII, ISO-8859-1, and UTF16 (LE and BE) by default.\n- *\n- * Anything else would have to be translated to UTF8 before being\n- * given to the parser itself. The BOM for UTF16 and the encoding\n- * declaration are looked at and a converter is looked for at that\n- * point. If not found the parser stops here as asked by the XML REC. A\n- * converter can be registered by the user using xmlRegisterCharEncodingHandler\n- * but the current form doesn't allow stateful transcoding (a serious\n- * problem agreed !). If iconv has been found it will be used\n- * automatically and allow stateful transcoding, the simplest is then\n- * to be sure to enable iconv and to provide iconv libs for the encoding\n- * support needed.\n- *\n- * Note that the generic \"UTF-16\" is not a predefined value.  Instead, only\n- * the specific UTF-16LE and UTF-16BE are present.\n@@ -67,7 +53,7 @@\n-    XML_CHAR_ENCODING_NONE=    0, \/* No char encoding detected *\/\n-    XML_CHAR_ENCODING_UTF8=    1, \/* UTF-8 *\/\n-    XML_CHAR_ENCODING_UTF16LE=    2, \/* UTF-16 little endian *\/\n-    XML_CHAR_ENCODING_UTF16BE=    3, \/* UTF-16 big endian *\/\n-    XML_CHAR_ENCODING_UCS4LE=    4, \/* UCS-4 little endian *\/\n-    XML_CHAR_ENCODING_UCS4BE=    5, \/* UCS-4 big endian *\/\n-    XML_CHAR_ENCODING_EBCDIC=    6, \/* EBCDIC uh! *\/\n+    XML_CHAR_ENCODING_NONE=     0, \/* No char encoding detected *\/\n+    XML_CHAR_ENCODING_UTF8=     1, \/* UTF-8 *\/\n+    XML_CHAR_ENCODING_UTF16LE=  2, \/* UTF-16 little endian *\/\n+    XML_CHAR_ENCODING_UTF16BE=  3, \/* UTF-16 big endian *\/\n+    XML_CHAR_ENCODING_UCS4LE=   4, \/* UCS-4 little endian *\/\n+    XML_CHAR_ENCODING_UCS4BE=   5, \/* UCS-4 big endian *\/\n+    XML_CHAR_ENCODING_EBCDIC=   6, \/* EBCDIC uh! *\/\n@@ -76,10 +62,10 @@\n-    XML_CHAR_ENCODING_UCS2=    9, \/* UCS-2 *\/\n-    XML_CHAR_ENCODING_8859_1=    10,\/* ISO-8859-1 ISO Latin 1 *\/\n-    XML_CHAR_ENCODING_8859_2=    11,\/* ISO-8859-2 ISO Latin 2 *\/\n-    XML_CHAR_ENCODING_8859_3=    12,\/* ISO-8859-3 *\/\n-    XML_CHAR_ENCODING_8859_4=    13,\/* ISO-8859-4 *\/\n-    XML_CHAR_ENCODING_8859_5=    14,\/* ISO-8859-5 *\/\n-    XML_CHAR_ENCODING_8859_6=    15,\/* ISO-8859-6 *\/\n-    XML_CHAR_ENCODING_8859_7=    16,\/* ISO-8859-7 *\/\n-    XML_CHAR_ENCODING_8859_8=    17,\/* ISO-8859-8 *\/\n-    XML_CHAR_ENCODING_8859_9=    18,\/* ISO-8859-9 *\/\n+    XML_CHAR_ENCODING_UCS2=     9, \/* UCS-2 *\/\n+    XML_CHAR_ENCODING_8859_1=   10,\/* ISO-8859-1 ISO Latin 1 *\/\n+    XML_CHAR_ENCODING_8859_2=   11,\/* ISO-8859-2 ISO Latin 2 *\/\n+    XML_CHAR_ENCODING_8859_3=   12,\/* ISO-8859-3 *\/\n+    XML_CHAR_ENCODING_8859_4=   13,\/* ISO-8859-4 *\/\n+    XML_CHAR_ENCODING_8859_5=   14,\/* ISO-8859-5 *\/\n+    XML_CHAR_ENCODING_8859_6=   15,\/* ISO-8859-6 *\/\n+    XML_CHAR_ENCODING_8859_7=   16,\/* ISO-8859-7 *\/\n+    XML_CHAR_ENCODING_8859_8=   17,\/* ISO-8859-8 *\/\n+    XML_CHAR_ENCODING_8859_9=   18,\/* ISO-8859-9 *\/\n@@ -89,1 +75,10 @@\n-    XML_CHAR_ENCODING_ASCII=    22 \/* pure ASCII *\/\n+    XML_CHAR_ENCODING_ASCII=    22,\/* pure ASCII *\/\n+    \/* Available since 2.14.0 *\/\n+    XML_CHAR_ENCODING_UTF16=    23,\/* UTF-16 native *\/\n+    XML_CHAR_ENCODING_HTML=     24,\/* HTML (output only) *\/\n+    XML_CHAR_ENCODING_8859_10=  25,\/* ISO-8859-10 *\/\n+    XML_CHAR_ENCODING_8859_11=  26,\/* ISO-8859-11 *\/\n+    XML_CHAR_ENCODING_8859_13=  27,\/* ISO-8859-13 *\/\n+    XML_CHAR_ENCODING_8859_14=  28,\/* ISO-8859-14 *\/\n+    XML_CHAR_ENCODING_8859_15=  29,\/* ISO-8859-15 *\/\n+    XML_CHAR_ENCODING_8859_16=  30 \/* ISO-8859-16 *\/\n@@ -92,0 +87,5 @@\n+typedef enum {\n+    XML_ENC_INPUT = (1 << 0),\n+    XML_ENC_OUTPUT = (1 << 1)\n+} xmlCharEncFlags;\n+\n@@ -99,2 +99,1 @@\n- * Take a block of chars in the original encoding and try to convert\n- * it to an UTF-8 block of chars out.\n+ * Convert characters to UTF-8.\n@@ -102,5 +101,4 @@\n- * Returns the number of bytes written, -1 if lack of space, or -2\n- *     if the transcoding failed.\n- * The value of @inlen after return is the number of octets consumed\n- *     if the return value is positive, else unpredictiable.\n- * The value of @outlen after return is the number of octets consumed.\n+ * On success, the value of @inlen after return is the number of\n+ * bytes consumed and @outlen is the number of bytes produced.\n+ *\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n@@ -108,2 +106,2 @@\n-typedef int (* xmlCharEncodingInputFunc)(unsigned char *out, int *outlen,\n-                                         const unsigned char *in, int *inlen);\n+typedef int (*xmlCharEncodingInputFunc)(unsigned char *out, int *outlen,\n+                                        const unsigned char *in, int *inlen);\n@@ -119,4 +117,28 @@\n- * Take a block of UTF-8 chars in and try to convert it to another\n- * encoding.\n- * Note: a first call designed to produce heading info is called with\n- * in = NULL. If stateful this should also initialize the encoder state.\n+ * Convert characters from UTF-8.\n+ *\n+ * On success, the value of @inlen after return is the number of\n+ * bytes consumed and @outlen is the number of bytes produced.\n+ *\n+ * Returns the number of bytes written or an XML_ENC_ERR code.\n+ *\/\n+typedef int (*xmlCharEncodingOutputFunc)(unsigned char *out, int *outlen,\n+                                         const unsigned char *in, int *inlen);\n+\n+\n+\/**\n+ * xmlCharEncConvFunc:\n+ * @vctxt:  conversion context\n+ * @out:  a pointer to an array of bytes to store the result\n+ * @outlen:  the length of @out\n+ * @in:  a pointer to an array of input bytes\n+ * @inlen:  the length of @in\n+ * @flush:  end of input\n+ *\n+ * Convert between character encodings.\n+ *\n+ * The value of @inlen after return is the number of bytes consumed\n+ * and @outlen is the number of bytes produced.\n+ *\n+ * If the converter can consume partial multi-byte sequences, the\n+ * @flush flag can be used to detect truncated sequences at EOF.\n+ * Otherwise, the flag can be ignored.\n@@ -124,5 +146,1 @@\n- * Returns the number of bytes written, -1 if lack of space, or -2\n- *     if the transcoding failed.\n- * The value of @inlen after return is the number of octets consumed\n- *     if the return value is positive, else unpredictiable.\n- * The value of @outlen after return is the number of octets produced.\n+ * Returns an XML_ENC_ERR code.\n@@ -130,2 +148,3 @@\n-typedef int (* xmlCharEncodingOutputFunc)(unsigned char *out, int *outlen,\n-                                          const unsigned char *in, int *inlen);\n+typedef xmlCharEncError\n+(*xmlCharEncConvFunc)(void *vctxt, unsigned char *out, int *outlen,\n+                      const unsigned char *in, int *inlen, int flush);\n@@ -133,0 +152,8 @@\n+\/**\n+ * xmlCharEncConvCtxtDtor:\n+ * @vctxt:  conversion context\n+ *\n+ * Free a conversion context.\n+ *\/\n+typedef void\n+(*xmlCharEncConvCtxtDtor)(void *vctxt);\n@@ -136,1 +163,2 @@\n- * If iconv is supported, there are two extra fields.\n+ *\n+ * This structure will be made private.\n@@ -141,11 +169,13 @@\n-    char                       *name;\n-    xmlCharEncodingInputFunc   input;\n-    xmlCharEncodingOutputFunc  output;\n-#ifdef LIBXML_ICONV_ENABLED\n-    iconv_t                    iconv_in;\n-    iconv_t                    iconv_out;\n-#endif \/* LIBXML_ICONV_ENABLED *\/\n-#ifdef LIBXML_ICU_ENABLED\n-    struct _uconv_t            *uconv_in;\n-    struct _uconv_t            *uconv_out;\n-#endif \/* LIBXML_ICU_ENABLED *\/\n+    char *name XML_DEPRECATED_MEMBER;\n+    union {\n+        xmlCharEncConvFunc func;\n+        xmlCharEncodingInputFunc legacyFunc;\n+    } input XML_DEPRECATED_MEMBER;\n+    union {\n+        xmlCharEncConvFunc func;\n+        xmlCharEncodingOutputFunc legacyFunc;\n+    } output XML_DEPRECATED_MEMBER;\n+    void *inputCtxt XML_DEPRECATED_MEMBER;\n+    void *outputCtxt XML_DEPRECATED_MEMBER;\n+    xmlCharEncConvCtxtDtor ctxtDtor XML_DEPRECATED_MEMBER;\n+    int flags XML_DEPRECATED_MEMBER;\n@@ -154,0 +184,19 @@\n+\/**\n+ * xmlCharEncConvImpl:\n+ * @vctxt:  user data\n+ * @name:  encoding name\n+ * @flags:  bit mask of flags\n+ * @out:  pointer to resulting handler\n+ *\n+ * If this function returns XML_ERR_OK, it must fill the @out\n+ * pointer with an encoding handler. The handler can be obtained\n+ * from xmlCharEncNewCustomHandler.\n+ *\n+ * @flags can contain XML_ENC_INPUT, XML_ENC_OUTPUT or both.\n+ *\n+ * Returns an xmlParserErrors code.\n+ *\/\n+typedef xmlParserErrors\n+(*xmlCharEncConvImpl)(void *vctxt, const char *name, xmlCharEncFlags flags,\n+                      xmlCharEncodingHandler **out);\n+\n@@ -159,1 +208,1 @@\n-    xmlInitCharEncodingHandlers    (void);\n+        xmlInitCharEncodingHandlers     (void);\n@@ -162,1 +211,1 @@\n-    xmlCleanupCharEncodingHandlers    (void);\n+        xmlCleanupCharEncodingHandlers  (void);\n@@ -164,8 +213,14 @@\n-    xmlRegisterCharEncodingHandler    (xmlCharEncodingHandlerPtr handler);\n-XMLPUBFUN int\n-    xmlLookupCharEncodingHandler    (xmlCharEncoding enc,\n-                     xmlCharEncodingHandlerPtr *out);\n-XMLPUBFUN int\n-    xmlOpenCharEncodingHandler    (const char *name,\n-                     int output,\n-                     xmlCharEncodingHandlerPtr *out);\n+        xmlRegisterCharEncodingHandler  (xmlCharEncodingHandlerPtr handler);\n+XMLPUBFUN xmlParserErrors\n+        xmlLookupCharEncodingHandler    (xmlCharEncoding enc,\n+                                         xmlCharEncodingHandlerPtr *out);\n+XMLPUBFUN xmlParserErrors\n+        xmlOpenCharEncodingHandler      (const char *name,\n+                                         int output,\n+                                         xmlCharEncodingHandlerPtr *out);\n+XMLPUBFUN xmlParserErrors\n+        xmlCreateCharEncodingHandler    (const char *name,\n+                                         xmlCharEncFlags flags,\n+                                         xmlCharEncConvImpl impl,\n+                                         void *implCtxt,\n+                                         xmlCharEncodingHandlerPtr *out);\n@@ -173,1 +228,1 @@\n-    xmlGetCharEncodingHandler    (xmlCharEncoding enc);\n+        xmlGetCharEncodingHandler       (xmlCharEncoding enc);\n@@ -175,1 +230,1 @@\n-    xmlFindCharEncodingHandler    (const char *name);\n+        xmlFindCharEncodingHandler      (const char *name);\n@@ -177,3 +232,11 @@\n-    xmlNewCharEncodingHandler    (const char *name,\n-                     xmlCharEncodingInputFunc input,\n-                     xmlCharEncodingOutputFunc output);\n+        xmlNewCharEncodingHandler       (const char *name,\n+                                         xmlCharEncodingInputFunc input,\n+                                         xmlCharEncodingOutputFunc output);\n+XMLPUBFUN xmlParserErrors\n+        xmlCharEncNewCustomHandler      (const char *name,\n+                                         xmlCharEncConvFunc input,\n+                                         xmlCharEncConvFunc output,\n+                                         xmlCharEncConvCtxtDtor ctxtDtor,\n+                                         void *inputCtxt,\n+                                         void *outputCtxt,\n+                                         xmlCharEncodingHandler **out);\n@@ -185,2 +248,2 @@\n-    xmlAddEncodingAlias        (const char *name,\n-                     const char *alias);\n+        xmlAddEncodingAlias             (const char *name,\n+                                         const char *alias);\n@@ -188,1 +251,1 @@\n-    xmlDelEncodingAlias        (const char *alias);\n+        xmlDelEncodingAlias             (const char *alias);\n@@ -190,1 +253,1 @@\n-    xmlGetEncodingAlias        (const char *alias);\n+        xmlGetEncodingAlias             (const char *alias);\n@@ -192,1 +255,1 @@\n-    xmlCleanupEncodingAliases    (void);\n+        xmlCleanupEncodingAliases       (void);\n@@ -194,1 +257,1 @@\n-    xmlParseCharEncoding        (const char *name);\n+        xmlParseCharEncoding            (const char *name);\n@@ -196,1 +259,1 @@\n-    xmlGetCharEncodingName        (xmlCharEncoding enc);\n+        xmlGetCharEncodingName          (xmlCharEncoding enc);\n@@ -202,2 +265,2 @@\n-    xmlDetectCharEncoding        (const unsigned char *in,\n-                     int len);\n+        xmlDetectCharEncoding           (const unsigned char *in,\n+                                         int len);\n@@ -209,3 +272,3 @@\n-    xmlCharEncOutFunc        (xmlCharEncodingHandler *handler,\n-                     struct _xmlBuffer *out,\n-                     struct _xmlBuffer *in);\n+        xmlCharEncOutFunc               (xmlCharEncodingHandler *handler,\n+                                         struct _xmlBuffer *out,\n+                                         struct _xmlBuffer *in);\n@@ -214,3 +277,3 @@\n-    xmlCharEncInFunc        (xmlCharEncodingHandler *handler,\n-                     struct _xmlBuffer *out,\n-                     struct _xmlBuffer *in);\n+        xmlCharEncInFunc                (xmlCharEncodingHandler *handler,\n+                                         struct _xmlBuffer *out,\n+                                         struct _xmlBuffer *in);\n@@ -219,3 +282,3 @@\n-    xmlCharEncFirstLine        (xmlCharEncodingHandler *handler,\n-                     struct _xmlBuffer *out,\n-                     struct _xmlBuffer *in);\n+        xmlCharEncFirstLine             (xmlCharEncodingHandler *handler,\n+                                         struct _xmlBuffer *out,\n+                                         struct _xmlBuffer *in);\n@@ -223,1 +286,1 @@\n-    xmlCharEncCloseFunc        (xmlCharEncodingHandler *handler);\n+        xmlCharEncCloseFunc             (xmlCharEncodingHandler *handler);\n@@ -230,4 +293,4 @@\n-    UTF8Toisolat1            (unsigned char *out,\n-                     int *outlen,\n-                     const unsigned char *in,\n-                     int *inlen);\n+        xmlUTF8ToIsolat1                (unsigned char *out,\n+                                         int *outlen,\n+                                         const unsigned char *in,\n+                                         int *inlen);\n@@ -236,4 +299,4 @@\n-    isolat1ToUTF8            (unsigned char *out,\n-                     int *outlen,\n-                     const unsigned char *in,\n-                     int *inlen);\n+        xmlIsolat1ToUTF8                (unsigned char *out,\n+                                         int *outlen,\n+                                         const unsigned char *in,\n+                                         int *inlen);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/encoding.h","additions":179,"deletions":116,"binary":false,"changes":295,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    void           *_private;            \/* application data *\/\n+    void           *_private;           \/* application data *\/\n@@ -45,6 +45,6 @@\n-    const xmlChar          *name;    \/* Entity name *\/\n-    struct _xmlNode    *children;    \/* First child link *\/\n-    struct _xmlNode        *last;    \/* Last child link *\/\n-    struct _xmlDtd       *parent;    \/* -> DTD *\/\n-    struct _xmlNode        *next;    \/* next sibling link  *\/\n-    struct _xmlNode        *prev;    \/* previous sibling link  *\/\n+    const xmlChar          *name;       \/* Entity name *\/\n+    struct _xmlNode    *children;       \/* First child link *\/\n+    struct _xmlNode        *last;       \/* Last child link *\/\n+    struct _xmlDtd       *parent;       \/* -> DTD *\/\n+    struct _xmlNode        *next;       \/* next sibling link  *\/\n+    struct _xmlNode        *prev;       \/* previous sibling link  *\/\n@@ -53,6 +53,6 @@\n-    xmlChar                *orig;    \/* content without ref substitution *\/\n-    xmlChar             *content;    \/* content or ndata if unparsed *\/\n-    int                   length;    \/* the content length *\/\n-    xmlEntityType          etype;    \/* The entity type *\/\n-    const xmlChar    *ExternalID;    \/* External identifier for PUBLIC *\/\n-    const xmlChar      *SystemID;    \/* URI for a SYSTEM or PUBLIC Entity *\/\n+    xmlChar                *orig;       \/* content without ref substitution *\/\n+    xmlChar             *content;       \/* content or ndata if unparsed *\/\n+    int                   length;       \/* the content length *\/\n+    xmlEntityType          etype;       \/* The entity type *\/\n+    const xmlChar    *ExternalID;       \/* External identifier for PUBLIC *\/\n+    const xmlChar      *SystemID;       \/* URI for a SYSTEM or PUBLIC Entity *\/\n@@ -60,3 +60,3 @@\n-    struct _xmlEntity     *nexte;    \/* unused *\/\n-    const xmlChar           *URI;    \/* the full URI as computed *\/\n-    int                    owner;    \/* unused *\/\n+    struct _xmlEntity     *nexte;       \/* unused *\/\n+    const xmlChar           *URI;       \/* the full URI as computed *\/\n+    int                    owner;       \/* unused *\/\n@@ -79,6 +79,0 @@\n-#ifdef LIBXML_LEGACY_ENABLED\n-XML_DEPRECATED\n-XMLPUBFUN void\n-        xmlInitializePredefinedEntities    (void);\n-#endif \/* LIBXML_LEGACY_ENABLED *\/\n-\n@@ -86,6 +80,6 @@\n-            xmlNewEntity        (xmlDocPtr doc,\n-                         const xmlChar *name,\n-                         int type,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID,\n-                         const xmlChar *content);\n+                        xmlNewEntity            (xmlDocPtr doc,\n+                                                 const xmlChar *name,\n+                                                 int type,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID,\n+                                                 const xmlChar *content);\n@@ -93,1 +87,1 @@\n-            xmlFreeEntity        (xmlEntityPtr entity);\n+                        xmlFreeEntity           (xmlEntityPtr entity);\n@@ -95,8 +89,8 @@\n-            xmlAddEntity        (xmlDocPtr doc,\n-                         int extSubset,\n-                         const xmlChar *name,\n-                         int type,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID,\n-                         const xmlChar *content,\n-                         xmlEntityPtr *out);\n+                        xmlAddEntity            (xmlDocPtr doc,\n+                                                 int extSubset,\n+                                                 const xmlChar *name,\n+                                                 int type,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID,\n+                                                 const xmlChar *content,\n+                                                 xmlEntityPtr *out);\n@@ -104,6 +98,6 @@\n-            xmlAddDocEntity        (xmlDocPtr doc,\n-                         const xmlChar *name,\n-                         int type,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID,\n-                         const xmlChar *content);\n+                        xmlAddDocEntity         (xmlDocPtr doc,\n+                                                 const xmlChar *name,\n+                                                 int type,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID,\n+                                                 const xmlChar *content);\n@@ -111,6 +105,6 @@\n-            xmlAddDtdEntity        (xmlDocPtr doc,\n-                         const xmlChar *name,\n-                         int type,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID,\n-                         const xmlChar *content);\n+                        xmlAddDtdEntity         (xmlDocPtr doc,\n+                                                 const xmlChar *name,\n+                                                 int type,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID,\n+                                                 const xmlChar *content);\n@@ -118,1 +112,1 @@\n-            xmlGetPredefinedEntity    (const xmlChar *name);\n+                        xmlGetPredefinedEntity  (const xmlChar *name);\n@@ -120,2 +114,2 @@\n-            xmlGetDocEntity        (const xmlDoc *doc,\n-                         const xmlChar *name);\n+                        xmlGetDocEntity         (const xmlDoc *doc,\n+                                                 const xmlChar *name);\n@@ -123,2 +117,2 @@\n-            xmlGetDtdEntity        (xmlDocPtr doc,\n-                         const xmlChar *name);\n+                        xmlGetDtdEntity         (xmlDocPtr doc,\n+                                                 const xmlChar *name);\n@@ -126,8 +120,2 @@\n-            xmlGetParameterEntity    (xmlDocPtr doc,\n-                         const xmlChar *name);\n-#ifdef LIBXML_LEGACY_ENABLED\n-XML_DEPRECATED\n-XMLPUBFUN const xmlChar *\n-            xmlEncodeEntities    (xmlDocPtr doc,\n-                         const xmlChar *input);\n-#endif \/* LIBXML_LEGACY_ENABLED *\/\n+                        xmlGetParameterEntity   (xmlDocPtr doc,\n+                                                 const xmlChar *name);\n@@ -135,2 +123,2 @@\n-            xmlEncodeEntitiesReentrant(xmlDocPtr doc,\n-                         const xmlChar *input);\n+                        xmlEncodeEntitiesReentrant(xmlDocPtr doc,\n+                                                 const xmlChar *input);\n@@ -138,2 +126,2 @@\n-            xmlEncodeSpecialChars    (const xmlDoc *doc,\n-                         const xmlChar *input);\n+                        xmlEncodeSpecialChars   (const xmlDoc *doc,\n+                                                 const xmlChar *input);\n@@ -141,2 +129,1 @@\n-            xmlCreateEntitiesTable    (void);\n-#ifdef LIBXML_TREE_ENABLED\n+                        xmlCreateEntitiesTable  (void);\n@@ -144,2 +131,1 @@\n-            xmlCopyEntitiesTable    (xmlEntitiesTablePtr table);\n-#endif \/* LIBXML_TREE_ENABLED *\/\n+                        xmlCopyEntitiesTable    (xmlEntitiesTablePtr table);\n@@ -147,1 +133,1 @@\n-            xmlFreeEntitiesTable    (xmlEntitiesTablePtr table);\n+                        xmlFreeEntitiesTable    (xmlEntitiesTablePtr table);\n@@ -150,2 +136,2 @@\n-            xmlDumpEntitiesTable    (xmlBufferPtr buf,\n-                         xmlEntitiesTablePtr table);\n+                        xmlDumpEntitiesTable    (xmlBufferPtr buf,\n+                                                 xmlEntitiesTablePtr table);\n@@ -153,2 +139,2 @@\n-            xmlDumpEntityDecl    (xmlBufferPtr buf,\n-                         xmlEntityPtr ent);\n+                        xmlDumpEntityDecl       (xmlBufferPtr buf,\n+                                                 xmlEntityPtr ent);\n@@ -156,5 +142,0 @@\n-#ifdef LIBXML_LEGACY_ENABLED\n-XMLPUBFUN void\n-            xmlCleanupPredefinedEntities(void);\n-#endif \/* LIBXML_LEGACY_ENABLED *\/\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/entities.h","additions":61,"deletions":80,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -25,16 +25,0 @@\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-typedef struct _xmlGlobalState xmlGlobalState;\n-typedef xmlGlobalState *xmlGlobalStatePtr;\n-\n-XML_DEPRECATED XMLPUBFUN void\n-xmlInitializeGlobalState(xmlGlobalStatePtr gs);\n-XML_DEPRECATED XMLPUBFUN\n-xmlGlobalStatePtr xmlGetGlobalState(void);\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/globals.h","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- *        various places in the library.\n+ *              various places in the library.\n@@ -91,2 +91,2 @@\n-                   const xmlChar *name, const xmlChar *name2,\n-                   const xmlChar *name3);\n+                                   const xmlChar *name, const xmlChar *name2,\n+                                   const xmlChar *name3);\n@@ -98,1 +98,1 @@\n-        xmlHashCreate        (int size);\n+                xmlHashCreate           (int size);\n@@ -100,2 +100,2 @@\n-        xmlHashCreateDict    (int size,\n-                     xmlDictPtr dict);\n+                xmlHashCreateDict       (int size,\n+                                         xmlDictPtr dict);\n@@ -103,2 +103,2 @@\n-        xmlHashFree        (xmlHashTablePtr hash,\n-                     xmlHashDeallocator dealloc);\n+                xmlHashFree             (xmlHashTablePtr hash,\n+                                         xmlHashDeallocator dealloc);\n@@ -106,2 +106,2 @@\n-        xmlHashDefaultDeallocator(void *entry,\n-                     const xmlChar *name);\n+                xmlHashDefaultDeallocator(void *entry,\n+                                         const xmlChar *name);\n@@ -113,3 +113,3 @@\n-        xmlHashAdd        (xmlHashTablePtr hash,\n-                                 const xmlChar *name,\n-                                 void *userdata);\n+                xmlHashAdd              (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         void *userdata);\n@@ -117,3 +117,3 @@\n-        xmlHashAddEntry        (xmlHashTablePtr hash,\n-                                 const xmlChar *name,\n-                                 void *userdata);\n+                xmlHashAddEntry         (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         void *userdata);\n@@ -121,4 +121,4 @@\n-        xmlHashUpdateEntry    (xmlHashTablePtr hash,\n-                                 const xmlChar *name,\n-                                 void *userdata,\n-                     xmlHashDeallocator dealloc);\n+                xmlHashUpdateEntry      (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         void *userdata,\n+                                         xmlHashDeallocator dealloc);\n@@ -126,4 +126,4 @@\n-        xmlHashAdd2        (xmlHashTablePtr hash,\n-                                 const xmlChar *name,\n-                                 const xmlChar *name2,\n-                                 void *userdata);\n+                xmlHashAdd2             (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         void *userdata);\n@@ -131,4 +131,4 @@\n-        xmlHashAddEntry2    (xmlHashTablePtr hash,\n-                                 const xmlChar *name,\n-                                 const xmlChar *name2,\n-                                 void *userdata);\n+                xmlHashAddEntry2        (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         void *userdata);\n@@ -136,5 +136,5 @@\n-        xmlHashUpdateEntry2    (xmlHashTablePtr hash,\n-                                 const xmlChar *name,\n-                                 const xmlChar *name2,\n-                                 void *userdata,\n-                     xmlHashDeallocator dealloc);\n+                xmlHashUpdateEntry2     (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         void *userdata,\n+                                         xmlHashDeallocator dealloc);\n@@ -142,5 +142,5 @@\n-        xmlHashAdd3        (xmlHashTablePtr hash,\n-                                 const xmlChar *name,\n-                                 const xmlChar *name2,\n-                                 const xmlChar *name3,\n-                                 void *userdata);\n+                xmlHashAdd3             (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *name3,\n+                                         void *userdata);\n@@ -148,5 +148,5 @@\n-        xmlHashAddEntry3    (xmlHashTablePtr hash,\n-                                 const xmlChar *name,\n-                                 const xmlChar *name2,\n-                                 const xmlChar *name3,\n-                                 void *userdata);\n+                xmlHashAddEntry3        (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *name3,\n+                                         void *userdata);\n@@ -154,6 +154,6 @@\n-        xmlHashUpdateEntry3    (xmlHashTablePtr hash,\n-                                 const xmlChar *name,\n-                                 const xmlChar *name2,\n-                                 const xmlChar *name3,\n-                                 void *userdata,\n-                     xmlHashDeallocator dealloc);\n+                xmlHashUpdateEntry3     (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *name3,\n+                                         void *userdata,\n+                                         xmlHashDeallocator dealloc);\n@@ -165,3 +165,3 @@\n-        xmlHashRemoveEntry    (xmlHashTablePtr hash,\n-                     const xmlChar *name,\n-                     xmlHashDeallocator dealloc);\n+                xmlHashRemoveEntry      (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         xmlHashDeallocator dealloc);\n@@ -169,4 +169,4 @@\n-        xmlHashRemoveEntry2    (xmlHashTablePtr hash,\n-                     const xmlChar *name,\n-                     const xmlChar *name2,\n-                     xmlHashDeallocator dealloc);\n+                xmlHashRemoveEntry2     (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         xmlHashDeallocator dealloc);\n@@ -174,5 +174,5 @@\n-        xmlHashRemoveEntry3    (xmlHashTablePtr hash,\n-                     const xmlChar *name,\n-                     const xmlChar *name2,\n-                     const xmlChar *name3,\n-                     xmlHashDeallocator dealloc);\n+                xmlHashRemoveEntry3     (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *name3,\n+                                         xmlHashDeallocator dealloc);\n@@ -184,2 +184,2 @@\n-        xmlHashLookup        (xmlHashTablePtr hash,\n-                     const xmlChar *name);\n+                xmlHashLookup           (xmlHashTablePtr hash,\n+                                         const xmlChar *name);\n@@ -187,3 +187,3 @@\n-        xmlHashLookup2        (xmlHashTablePtr hash,\n-                     const xmlChar *name,\n-                     const xmlChar *name2);\n+                xmlHashLookup2          (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2);\n@@ -191,4 +191,4 @@\n-        xmlHashLookup3        (xmlHashTablePtr hash,\n-                     const xmlChar *name,\n-                     const xmlChar *name2,\n-                     const xmlChar *name3);\n+                xmlHashLookup3          (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *name3);\n@@ -196,3 +196,3 @@\n-        xmlHashQLookup        (xmlHashTablePtr hash,\n-                     const xmlChar *prefix,\n-                     const xmlChar *name);\n+                xmlHashQLookup          (xmlHashTablePtr hash,\n+                                         const xmlChar *prefix,\n+                                         const xmlChar *name);\n@@ -200,5 +200,5 @@\n-        xmlHashQLookup2        (xmlHashTablePtr hash,\n-                     const xmlChar *prefix,\n-                     const xmlChar *name,\n-                     const xmlChar *prefix2,\n-                     const xmlChar *name2);\n+                xmlHashQLookup2         (xmlHashTablePtr hash,\n+                                         const xmlChar *prefix,\n+                                         const xmlChar *name,\n+                                         const xmlChar *prefix2,\n+                                         const xmlChar *name2);\n@@ -206,7 +206,7 @@\n-        xmlHashQLookup3        (xmlHashTablePtr hash,\n-                     const xmlChar *prefix,\n-                     const xmlChar *name,\n-                     const xmlChar *prefix2,\n-                     const xmlChar *name2,\n-                     const xmlChar *prefix3,\n-                     const xmlChar *name3);\n+                xmlHashQLookup3         (xmlHashTablePtr hash,\n+                                         const xmlChar *prefix,\n+                                         const xmlChar *name,\n+                                         const xmlChar *prefix2,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *prefix3,\n+                                         const xmlChar *name3);\n@@ -218,3 +218,3 @@\n-        xmlHashCopySafe        (xmlHashTablePtr hash,\n-                     xmlHashCopier copy,\n-                     xmlHashDeallocator dealloc);\n+                xmlHashCopySafe         (xmlHashTablePtr hash,\n+                                         xmlHashCopier copy,\n+                                         xmlHashDeallocator dealloc);\n@@ -222,2 +222,2 @@\n-        xmlHashCopy        (xmlHashTablePtr hash,\n-                     xmlHashCopier copy);\n+                xmlHashCopy             (xmlHashTablePtr hash,\n+                                         xmlHashCopier copy);\n@@ -225,1 +225,1 @@\n-        xmlHashSize        (xmlHashTablePtr hash);\n+                xmlHashSize             (xmlHashTablePtr hash);\n@@ -227,3 +227,3 @@\n-        xmlHashScan        (xmlHashTablePtr hash,\n-                     xmlHashScanner scan,\n-                     void *data);\n+                xmlHashScan             (xmlHashTablePtr hash,\n+                                         xmlHashScanner scan,\n+                                         void *data);\n@@ -231,6 +231,6 @@\n-        xmlHashScan3        (xmlHashTablePtr hash,\n-                     const xmlChar *name,\n-                     const xmlChar *name2,\n-                     const xmlChar *name3,\n-                     xmlHashScanner scan,\n-                     void *data);\n+                xmlHashScan3            (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *name3,\n+                                         xmlHashScanner scan,\n+                                         void *data);\n@@ -238,3 +238,3 @@\n-        xmlHashScanFull        (xmlHashTablePtr hash,\n-                     xmlHashScannerFull scan,\n-                     void *data);\n+                xmlHashScanFull         (xmlHashTablePtr hash,\n+                                         xmlHashScannerFull scan,\n+                                         void *data);\n@@ -242,6 +242,6 @@\n-        xmlHashScanFull3    (xmlHashTablePtr hash,\n-                     const xmlChar *name,\n-                     const xmlChar *name2,\n-                     const xmlChar *name3,\n-                     xmlHashScannerFull scan,\n-                     void *data);\n+                xmlHashScanFull3        (xmlHashTablePtr hash,\n+                                         const xmlChar *name,\n+                                         const xmlChar *name2,\n+                                         const xmlChar *name3,\n+                                         xmlHashScannerFull scan,\n+                                         void *data);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/hash.h","additions":109,"deletions":109,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-        xmlListCreate        (xmlListDeallocator deallocator,\n-                                     xmlListDataCompare compare);\n+                xmlListCreate           (xmlListDeallocator deallocator,\n+                                         xmlListDataCompare compare);\n@@ -59,1 +59,1 @@\n-        xmlListDelete        (xmlListPtr l);\n+                xmlListDelete           (xmlListPtr l);\n@@ -63,2 +63,2 @@\n-        xmlListSearch        (xmlListPtr l,\n-                     void *data);\n+                xmlListSearch           (xmlListPtr l,\n+                                         void *data);\n@@ -66,2 +66,2 @@\n-        xmlListReverseSearch    (xmlListPtr l,\n-                     void *data);\n+                xmlListReverseSearch    (xmlListPtr l,\n+                                         void *data);\n@@ -69,2 +69,2 @@\n-        xmlListInsert        (xmlListPtr l,\n-                     void *data) ;\n+                xmlListInsert           (xmlListPtr l,\n+                                         void *data) ;\n@@ -72,2 +72,2 @@\n-        xmlListAppend        (xmlListPtr l,\n-                     void *data) ;\n+                xmlListAppend           (xmlListPtr l,\n+                                         void *data) ;\n@@ -75,2 +75,2 @@\n-        xmlListRemoveFirst    (xmlListPtr l,\n-                     void *data);\n+                xmlListRemoveFirst      (xmlListPtr l,\n+                                         void *data);\n@@ -78,2 +78,2 @@\n-        xmlListRemoveLast    (xmlListPtr l,\n-                     void *data);\n+                xmlListRemoveLast       (xmlListPtr l,\n+                                         void *data);\n@@ -81,2 +81,2 @@\n-        xmlListRemoveAll    (xmlListPtr l,\n-                     void *data);\n+                xmlListRemoveAll        (xmlListPtr l,\n+                                         void *data);\n@@ -84,1 +84,1 @@\n-        xmlListClear        (xmlListPtr l);\n+                xmlListClear            (xmlListPtr l);\n@@ -86,1 +86,1 @@\n-        xmlListEmpty        (xmlListPtr l);\n+                xmlListEmpty            (xmlListPtr l);\n@@ -88,1 +88,1 @@\n-        xmlListFront        (xmlListPtr l);\n+                xmlListFront            (xmlListPtr l);\n@@ -90,1 +90,1 @@\n-        xmlListEnd        (xmlListPtr l);\n+                xmlListEnd              (xmlListPtr l);\n@@ -92,1 +92,1 @@\n-        xmlListSize        (xmlListPtr l);\n+                xmlListSize             (xmlListPtr l);\n@@ -95,1 +95,1 @@\n-        xmlListPopFront        (xmlListPtr l);\n+                xmlListPopFront         (xmlListPtr l);\n@@ -97,1 +97,1 @@\n-        xmlListPopBack        (xmlListPtr l);\n+                xmlListPopBack          (xmlListPtr l);\n@@ -99,2 +99,2 @@\n-        xmlListPushFront    (xmlListPtr l,\n-                     void *data);\n+                xmlListPushFront        (xmlListPtr l,\n+                                         void *data);\n@@ -102,2 +102,2 @@\n-        xmlListPushBack        (xmlListPtr l,\n-                     void *data);\n+                xmlListPushBack         (xmlListPtr l,\n+                                         void *data);\n@@ -107,1 +107,1 @@\n-        xmlListReverse        (xmlListPtr l);\n+                xmlListReverse          (xmlListPtr l);\n@@ -109,1 +109,1 @@\n-        xmlListSort        (xmlListPtr l);\n+                xmlListSort             (xmlListPtr l);\n@@ -111,3 +111,3 @@\n-        xmlListWalk        (xmlListPtr l,\n-                     xmlListWalker walker,\n-                     void *user);\n+                xmlListWalk             (xmlListPtr l,\n+                                         xmlListWalker walker,\n+                                         void *user);\n@@ -115,3 +115,3 @@\n-        xmlListReverseWalk    (xmlListPtr l,\n-                     xmlListWalker walker,\n-                     void *user);\n+                xmlListReverseWalk      (xmlListPtr l,\n+                                         xmlListWalker walker,\n+                                         void *user);\n@@ -119,2 +119,2 @@\n-        xmlListMerge        (xmlListPtr l1,\n-                     xmlListPtr l2);\n+                xmlListMerge            (xmlListPtr l1,\n+                                         xmlListPtr l2);\n@@ -122,1 +122,1 @@\n-        xmlListDup        (xmlListPtr old);\n+                xmlListDup              (xmlListPtr old);\n@@ -124,2 +124,2 @@\n-        xmlListCopy        (xmlListPtr cur,\n-                     xmlListPtr old);\n+                xmlListCopy             (xmlListPtr cur,\n+                                         xmlListPtr old);\n@@ -128,1 +128,1 @@\n-        xmlLinkGetData          (xmlLinkPtr lk);\n+                xmlLinkGetData          (xmlLinkPtr lk);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/list.h","additions":42,"deletions":42,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,4 +2,1 @@\n- * Summary: minimal FTP implementation\n- * Description: minimal FTP implementation allowing to fetch resources\n- *              like external subset. This module is DEPRECATED, do not\n- *              use any of its functions.\n+ * Summary: Removed legacy symbols for an outdated FTP client\n@@ -15,26 +12,2 @@\n-#include <libxml\/xmlversion.h>\n-\n-#if defined(LIBXML_FTP_ENABLED)\n-\n-\/* Needed for portability to Windows 64 bits *\/\n-#if defined(_WIN32)\n-#include <winsock2.h>\n-#else\n-\/**\n- * SOCKET:\n- *\n- * macro used to provide portability of code to windows sockets\n- *\/\n-#define SOCKET int\n-\/**\n- * INVALID_SOCKET:\n- *\n- * macro used to provide portability of code to windows sockets\n- * the value to be used when the socket is not valid\n- *\/\n-#undef  INVALID_SOCKET\n-#define INVALID_SOCKET (-1)\n-#endif\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n+#ifdef __GNUC__\n+  #warning \"libxml\/nanoftp.h is deprecated\"\n@@ -43,143 +16,0 @@\n-\/**\n- * ftpListCallback:\n- * @userData:  user provided data for the callback\n- * @filename:  the file name (including \"->\" when links are shown)\n- * @attrib:  the attribute string\n- * @owner:  the owner string\n- * @group:  the group string\n- * @size:  the file size\n- * @links:  the link count\n- * @year:  the year\n- * @month:  the month\n- * @day:  the day\n- * @hour:  the hour\n- * @minute:  the minute\n- *\n- * A callback for the xmlNanoFTPList command.\n- * Note that only one of year and day:minute are specified.\n- *\/\n-typedef void (*ftpListCallback) (void *userData,\n-                             const char *filename, const char *attrib,\n-                             const char *owner, const char *group,\n-                 unsigned long size, int links, int year,\n-                 const char *month, int day, int hour,\n-                 int minute);\n-\/**\n- * ftpDataCallback:\n- * @userData: the user provided context\n- * @data: the data received\n- * @len: its size in bytes\n- *\n- * A callback for the xmlNanoFTPGet command.\n- *\/\n-typedef void (*ftpDataCallback) (void *userData,\n-                 const char *data,\n-                 int len);\n-\n-\/*\n- * Init\n- *\/\n-XML_DEPRECATED\n-XMLPUBFUN void\n-    xmlNanoFTPInit        (void);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-    xmlNanoFTPCleanup    (void);\n-\n-\/*\n- * Creating\/freeing contexts.\n- *\/\n-XML_DEPRECATED\n-XMLPUBFUN void *\n-    xmlNanoFTPNewCtxt    (const char *URL);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-    xmlNanoFTPFreeCtxt    (void * ctx);\n-XML_DEPRECATED\n-XMLPUBFUN void *\n-    xmlNanoFTPConnectTo    (const char *server,\n-                 int port);\n-\/*\n- * Opening\/closing session connections.\n- *\/\n-XML_DEPRECATED\n-XMLPUBFUN void *\n-    xmlNanoFTPOpen        (const char *URL);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlNanoFTPConnect    (void *ctx);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlNanoFTPClose        (void *ctx);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlNanoFTPQuit        (void *ctx);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-    xmlNanoFTPScanProxy    (const char *URL);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-    xmlNanoFTPProxy        (const char *host,\n-                 int port,\n-                 const char *user,\n-                 const char *passwd,\n-                 int type);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlNanoFTPUpdateURL    (void *ctx,\n-                 const char *URL);\n-\n-\/*\n- * Rather internal commands.\n- *\/\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlNanoFTPGetResponse    (void *ctx);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlNanoFTPCheckResponse    (void *ctx);\n-\n-\/*\n- * CD\/DIR\/GET handlers.\n- *\/\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlNanoFTPCwd        (void *ctx,\n-                 const char *directory);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlNanoFTPDele        (void *ctx,\n-                 const char *file);\n-\n-XML_DEPRECATED\n-XMLPUBFUN SOCKET\n-    xmlNanoFTPGetConnection    (void *ctx);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlNanoFTPCloseConnection(void *ctx);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlNanoFTPList        (void *ctx,\n-                 ftpListCallback callback,\n-                 void *userData,\n-                 const char *filename);\n-XML_DEPRECATED\n-XMLPUBFUN SOCKET\n-    xmlNanoFTPGetSocket    (void *ctx,\n-                 const char *filename);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlNanoFTPGet        (void *ctx,\n-                 ftpDataCallback callback,\n-                 void *userData,\n-                 const char *filename);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlNanoFTPRead        (void *ctx,\n-                 void *dest,\n-                 int len);\n-\n-#ifdef __cplusplus\n-}\n-#endif\n-#endif \/* defined(LIBXML_FTP_ENABLED) || defined(LIBXML_LEGACY_ENABLED) *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/nanoftp.h","additions":3,"deletions":173,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-    xmlNanoHTTPInit        (void);\n+        xmlNanoHTTPInit         (void);\n@@ -26,1 +26,1 @@\n-    xmlNanoHTTPCleanup    (void);\n+        xmlNanoHTTPCleanup      (void);\n@@ -29,1 +29,1 @@\n-    xmlNanoHTTPScanProxy    (const char *URL);\n+        xmlNanoHTTPScanProxy    (const char *URL);\n@@ -32,3 +32,3 @@\n-    xmlNanoHTTPFetch    (const char *URL,\n-                 const char *filename,\n-                 char **contentType);\n+        xmlNanoHTTPFetch        (const char *URL,\n+                                 const char *filename,\n+                                 char **contentType);\n@@ -37,6 +37,6 @@\n-    xmlNanoHTTPMethod    (const char *URL,\n-                 const char *method,\n-                 const char *input,\n-                 char **contentType,\n-                 const char *headers,\n-                 int   ilen);\n+        xmlNanoHTTPMethod       (const char *URL,\n+                                 const char *method,\n+                                 const char *input,\n+                                 char **contentType,\n+                                 const char *headers,\n+                                 int   ilen);\n@@ -45,7 +45,7 @@\n-    xmlNanoHTTPMethodRedir    (const char *URL,\n-                 const char *method,\n-                 const char *input,\n-                 char **contentType,\n-                 char **redir,\n-                 const char *headers,\n-                 int   ilen);\n+        xmlNanoHTTPMethodRedir  (const char *URL,\n+                                 const char *method,\n+                                 const char *input,\n+                                 char **contentType,\n+                                 char **redir,\n+                                 const char *headers,\n+                                 int   ilen);\n@@ -54,2 +54,2 @@\n-    xmlNanoHTTPOpen        (const char *URL,\n-                 char **contentType);\n+        xmlNanoHTTPOpen         (const char *URL,\n+                                 char **contentType);\n@@ -58,3 +58,3 @@\n-    xmlNanoHTTPOpenRedir    (const char *URL,\n-                 char **contentType,\n-                 char **redir);\n+        xmlNanoHTTPOpenRedir    (const char *URL,\n+                                 char **contentType,\n+                                 char **redir);\n@@ -63,1 +63,1 @@\n-    xmlNanoHTTPReturnCode    (void *ctx);\n+        xmlNanoHTTPReturnCode   (void *ctx);\n@@ -66,1 +66,1 @@\n-    xmlNanoHTTPAuthHeader    (void *ctx);\n+        xmlNanoHTTPAuthHeader   (void *ctx);\n@@ -69,1 +69,1 @@\n-    xmlNanoHTTPRedir    (void *ctx);\n+        xmlNanoHTTPRedir        (void *ctx);\n@@ -72,1 +72,1 @@\n-    xmlNanoHTTPContentLength( void * ctx );\n+        xmlNanoHTTPContentLength( void * ctx );\n@@ -75,1 +75,1 @@\n-    xmlNanoHTTPEncoding    (void *ctx);\n+        xmlNanoHTTPEncoding     (void *ctx);\n@@ -78,1 +78,1 @@\n-    xmlNanoHTTPMimeType    (void *ctx);\n+        xmlNanoHTTPMimeType     (void *ctx);\n@@ -81,3 +81,3 @@\n-    xmlNanoHTTPRead        (void *ctx,\n-                 void *dest,\n-                 int len);\n+        xmlNanoHTTPRead         (void *ctx,\n+                                 void *dest,\n+                                 int len);\n@@ -87,2 +87,2 @@\n-    xmlNanoHTTPSave        (void *ctxt,\n-                 const char *filename);\n+        xmlNanoHTTPSave         (void *ctxt,\n+                                 const char *filename);\n@@ -92,1 +92,1 @@\n-    xmlNanoHTTPClose    (void *ctx);\n+        xmlNanoHTTPClose        (void *ctx);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/nanohttp.h","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -41,1 +41,25 @@\n-#define XML_DEFAULT_VERSION    \"1.0\"\n+#define XML_DEFAULT_VERSION     \"1.0\"\n+\n+typedef enum {\n+    XML_STATUS_NOT_WELL_FORMED          = (1 << 0),\n+    XML_STATUS_NOT_NS_WELL_FORMED       = (1 << 1),\n+    XML_STATUS_DTD_VALIDATION_FAILED    = (1 << 2),\n+    XML_STATUS_CATASTROPHIC_ERROR       = (1 << 3)\n+} xmlParserStatus;\n+\n+typedef enum {\n+    XML_RESOURCE_UNKNOWN = 0,\n+    XML_RESOURCE_MAIN_DOCUMENT,\n+    XML_RESOURCE_DTD,\n+    XML_RESOURCE_GENERAL_ENTITY,\n+    XML_RESOURCE_PARAMETER_ENTITY,\n+    XML_RESOURCE_XINCLUDE,\n+    XML_RESOURCE_XINCLUDE_TEXT\n+} xmlResourceType;\n+\n+typedef enum {\n+    XML_INPUT_BUF_STATIC            = (1 << 1),\n+    XML_INPUT_BUF_ZERO_TERMINATED   = (1 << 2),\n+    XML_INPUT_UNZIP                 = (1 << 3),\n+    XML_INPUT_NETWORK               = (1 << 4)\n+} xmlParserInputFlags;\n@@ -64,18 +88,33 @@\n-    xmlParserInputBufferPtr buf;      \/* UTF-8 encoded buffer *\/\n-\n-    const char *filename;             \/* The file analyzed, if any *\/\n-    const char *directory;            \/* unused *\/\n-    const xmlChar *base;              \/* Base of the array to parse *\/\n-    const xmlChar *cur;               \/* Current char being parsed *\/\n-    const xmlChar *end;               \/* end of the array to parse *\/\n-    int length;                       \/* unused *\/\n-    int line;                         \/* Current line *\/\n-    int col;                          \/* Current column *\/\n-    unsigned long consumed;           \/* How many xmlChars already consumed *\/\n-    xmlParserInputDeallocate free;    \/* function to deallocate the base *\/\n-    const xmlChar *encoding;          \/* unused *\/\n-    const xmlChar *version;           \/* the version string for entity *\/\n-    int flags;                        \/* Flags *\/\n-    int id;                           \/* an unique identifier for the entity *\/\n-    unsigned long parentConsumed;     \/* unused *\/\n-    xmlEntityPtr entity;              \/* entity, if any *\/\n+    xmlParserInputBufferPtr buf;\n+    \/* The file analyzed, if any *\/\n+    const char *filename;\n+    \/* unused *\/\n+    const char *directory XML_DEPRECATED_MEMBER;\n+    \/* Base of the array to parse *\/\n+    const xmlChar *base;\n+    \/* Current char being parsed *\/\n+    const xmlChar *cur;\n+    \/* end of the array to parse *\/\n+    const xmlChar *end;\n+    \/* unused *\/\n+    int length XML_DEPRECATED_MEMBER;\n+    \/* Current line *\/\n+    int line;\n+    \/* Current column *\/\n+    int col;\n+    \/* How many xmlChars already consumed *\/\n+    unsigned long consumed;\n+    \/* function to deallocate the base *\/\n+    xmlParserInputDeallocate free XML_DEPRECATED_MEMBER;\n+    \/* unused *\/\n+    const xmlChar *encoding XML_DEPRECATED_MEMBER;\n+    \/* the version string for entity *\/\n+    const xmlChar *version XML_DEPRECATED_MEMBER;\n+    \/* Flags *\/\n+    int flags XML_DEPRECATED_MEMBER;\n+    \/* an unique identifier for the entity *\/\n+    int id XML_DEPRECATED_MEMBER;\n+    \/* unused *\/\n+    unsigned long parentConsumed XML_DEPRECATED_MEMBER;\n+    \/* entity, if any *\/\n+    xmlEntityPtr entity XML_DEPRECATED_MEMBER;\n@@ -118,12 +157,12 @@\n-    XML_PARSER_EOF = -1,    \/* nothing is to be parsed *\/\n-    XML_PARSER_START = 0,    \/* nothing has been parsed *\/\n-    XML_PARSER_MISC,        \/* Misc* before int subset *\/\n-    XML_PARSER_PI,        \/* Within a processing instruction *\/\n-    XML_PARSER_DTD,        \/* within some DTD content *\/\n-    XML_PARSER_PROLOG,        \/* Misc* after internal subset *\/\n-    XML_PARSER_COMMENT,        \/* within a comment *\/\n-    XML_PARSER_START_TAG,    \/* within a start tag *\/\n-    XML_PARSER_CONTENT,        \/* within the content *\/\n-    XML_PARSER_CDATA_SECTION,    \/* within a CDATA section *\/\n-    XML_PARSER_END_TAG,        \/* within a closing tag *\/\n-    XML_PARSER_ENTITY_DECL,    \/* within an entity declaration *\/\n+    XML_PARSER_EOF = -1,        \/* nothing is to be parsed *\/\n+    XML_PARSER_START = 0,       \/* nothing has been parsed *\/\n+    XML_PARSER_MISC,            \/* Misc* before int subset *\/\n+    XML_PARSER_PI,              \/* Within a processing instruction *\/\n+    XML_PARSER_DTD,             \/* within some DTD content *\/\n+    XML_PARSER_PROLOG,          \/* Misc* after internal subset *\/\n+    XML_PARSER_COMMENT,         \/* within a comment *\/\n+    XML_PARSER_START_TAG,       \/* within a start tag *\/\n+    XML_PARSER_CONTENT,         \/* within the content *\/\n+    XML_PARSER_CDATA_SECTION,   \/* within a CDATA section *\/\n+    XML_PARSER_END_TAG,         \/* within a closing tag *\/\n+    XML_PARSER_ENTITY_DECL,     \/* within an entity declaration *\/\n@@ -131,5 +170,5 @@\n-    XML_PARSER_ATTRIBUTE_VALUE,    \/* within an attribute value *\/\n-    XML_PARSER_SYSTEM_LITERAL,    \/* within a SYSTEM value *\/\n-    XML_PARSER_EPILOG,        \/* the Misc* after the last end tag *\/\n-    XML_PARSER_IGNORE,        \/* within an IGNORED section *\/\n-    XML_PARSER_PUBLIC_LITERAL,    \/* within a PUBLIC value *\/\n+    XML_PARSER_ATTRIBUTE_VALUE, \/* within an attribute value *\/\n+    XML_PARSER_SYSTEM_LITERAL,  \/* within a SYSTEM value *\/\n+    XML_PARSER_EPILOG,          \/* the Misc* after the last end tag *\/\n+    XML_PARSER_IGNORE,          \/* within an IGNORED section *\/\n+    XML_PARSER_PUBLIC_LITERAL,  \/* within a PUBLIC value *\/\n@@ -143,3 +182,3 @@\n-#define XML_DETECT_IDS        2\n-#define XML_COMPLETE_ATTRS    4\n-#define XML_SKIP_IDS        8\n+#define XML_DETECT_IDS          2\n+#define XML_COMPLETE_ATTRS      4\n+#define XML_SKIP_IDS            8\n@@ -166,0 +205,23 @@\n+\/**\n+ * xmlResourceLoader:\n+ * @ctxt:  parser context\n+ * @url:  URL to load\n+ * @publicId:  publid ID from DTD (optional)\n+ * @type:  resource type\n+ * @flags:  flags\n+ * @out:  result pointer\n+ *\n+ * Callback for custom resource loaders.\n+ *\n+ * @flags can contain XML_INPUT_UNZIP and XML_INPUT_NETWORK.\n+ *\n+ * On success, @out should be set to a new parser input object and\n+ * XML_ERR_OK should be returned.\n+ *\n+ * Returns an xmlParserErrors code.\n+ *\/\n+typedef xmlParserErrors\n+(*xmlResourceLoader)(void *ctxt, const char *url, const char *publicId,\n+                     xmlResourceType type, xmlParserInputFlags flags,\n+                     xmlParserInputPtr *out);\n+\n@@ -179,12 +241,22 @@\n-    struct _xmlSAXHandler *sax;       \/* The SAX handler *\/\n-    void            *userData;        \/* For SAX interface only, used by DOM build *\/\n-    xmlDocPtr           myDoc;        \/* the document being built *\/\n-    int            wellFormed;        \/* is the document well formed *\/\n-    int       replaceEntities;        \/* shall we replace entities ? *\/\n-    const xmlChar    *version;        \/* the XML version string *\/\n-    const xmlChar   *encoding;        \/* the declared encoding, if any *\/\n-    int            standalone;        \/* standalone document *\/\n-    int                  html;        \/* an HTML(1) document\n-                                       * 3 is HTML after <head>\n-                                       * 10 is HTML after <body>\n-                                       *\/\n+    \/* The SAX handler *\/\n+    struct _xmlSAXHandler *sax;\n+    \/* For SAX interface only, used by DOM build *\/\n+    void *userData;\n+    \/* the document being built *\/\n+    xmlDocPtr myDoc;\n+    \/* is the document well formed *\/\n+    int wellFormed;\n+    \/* shall we replace entities ? *\/\n+    int replaceEntities XML_DEPRECATED_MEMBER;\n+    \/* the XML version string *\/\n+    const xmlChar *version;\n+    \/* the declared encoding, if any *\/\n+    const xmlChar *encoding;\n+    \/* standalone document *\/\n+    int standalone;\n+\n+    \/* an HTML(1) document\n+     * 3 is HTML after <head>\n+     * 10 is HTML after <body>\n+     *\/\n+    int html;\n@@ -193,4 +265,0 @@\n-    xmlParserInputPtr  input;         \/* Current input stream *\/\n-    int                inputNr;       \/* Number of current input streams *\/\n-    int                inputMax;      \/* Max number of input streams *\/\n-    xmlParserInputPtr *inputTab;      \/* stack of inputs *\/\n@@ -198,8 +266,8 @@\n-    \/* Node analysis stack only used for DOM building *\/\n-    xmlNodePtr         node;          \/* Current parsed Node *\/\n-    int                nodeNr;        \/* Depth of the parsing stack *\/\n-    int                nodeMax;       \/* Max depth of the parsing stack *\/\n-    xmlNodePtr        *nodeTab;       \/* array of nodes *\/\n-\n-    int record_info;                  \/* Whether node info should be kept *\/\n-    xmlParserNodeInfoSeq node_seq;    \/* info about each node parsed *\/\n+    \/* Current input stream *\/\n+    xmlParserInputPtr input;\n+    \/* Number of current input streams *\/\n+    int inputNr;\n+    \/* Max number of input streams *\/\n+    int inputMax XML_DEPRECATED_MEMBER;\n+    \/* stack of inputs *\/\n+    xmlParserInputPtr *inputTab;\n@@ -207,1 +275,1 @@\n-    int errNo;                        \/* error code *\/\n+    \/* Node analysis stack only used for DOM building *\/\n@@ -209,3 +277,38 @@\n-    int     hasExternalSubset;        \/* reference and external subset *\/\n-    int             hasPErefs;        \/* the internal subset has PE refs *\/\n-    int              external;        \/* unused *\/\n+    \/* Current parsed Node *\/\n+    xmlNodePtr node;\n+    \/* Depth of the parsing stack *\/\n+    int nodeNr XML_DEPRECATED_MEMBER;\n+    \/* Max depth of the parsing stack *\/\n+    int nodeMax XML_DEPRECATED_MEMBER;\n+    \/* array of nodes *\/\n+    xmlNodePtr *nodeTab XML_DEPRECATED_MEMBER;\n+\n+    \/* Whether node info should be kept *\/\n+    int record_info;\n+    \/* info about each node parsed *\/\n+    xmlParserNodeInfoSeq node_seq XML_DEPRECATED_MEMBER;\n+\n+    \/* error code *\/\n+    int errNo;\n+\n+    \/* reference and external subset *\/\n+    int hasExternalSubset XML_DEPRECATED_MEMBER;\n+    \/* the internal subset has PE refs *\/\n+    int hasPErefs XML_DEPRECATED_MEMBER;\n+    \/* unused *\/\n+    int external XML_DEPRECATED_MEMBER;\n+\n+    \/* is the document valid *\/\n+    int valid;\n+    \/* shall we try to validate ? *\/\n+    int validate XML_DEPRECATED_MEMBER;\n+    \/* The validity context *\/\n+    xmlValidCtxt vctxt;\n+\n+    \/* push parser state *\/\n+    xmlParserInputState instate XML_DEPRECATED_MEMBER;\n+    \/* unused *\/\n+    int token XML_DEPRECATED_MEMBER;\n+\n+    \/* unused internally, still used downstream *\/\n+    char *directory;\n@@ -213,3 +316,1 @@\n-    int                 valid;        \/* is the document valid *\/\n-    int              validate;        \/* shall we try to validate ? *\/\n-    xmlValidCtxt        vctxt;        \/* The validity context *\/\n+    \/* Node name stack *\/\n@@ -217,2 +318,25 @@\n-    xmlParserInputState instate;      \/* push parser state *\/\n-    int                 token;        \/* unused *\/\n+    \/* Current parsed Node *\/\n+    const xmlChar *name XML_DEPRECATED_MEMBER;\n+    \/* Depth of the parsing stack *\/\n+    int nameNr XML_DEPRECATED_MEMBER;\n+    \/* Max depth of the parsing stack *\/\n+    int nameMax XML_DEPRECATED_MEMBER;\n+    \/* array of nodes *\/\n+    const xmlChar **nameTab XML_DEPRECATED_MEMBER;\n+\n+    \/* unused *\/\n+    long nbChars XML_DEPRECATED_MEMBER;\n+    \/* used by progressive parsing lookup *\/\n+    long checkIndex XML_DEPRECATED_MEMBER;\n+    \/* ugly but ... *\/\n+    int keepBlanks XML_DEPRECATED_MEMBER;\n+    \/* SAX callbacks are disabled *\/\n+    int disableSAX;\n+    \/* Parsing is in int 1\/ext 2 subset *\/\n+    int inSubset;\n+    \/* name of subset *\/\n+    const xmlChar *intSubName;\n+    \/* URI of external subset *\/\n+    xmlChar *extSubURI;\n+    \/* SYSTEM ID of external subset *\/\n+    xmlChar *extSubSystem;\n@@ -220,1 +344,1 @@\n-    char           *directory;        \/* unused *\/\n+    \/* xml:space values *\/\n@@ -222,14 +346,23 @@\n-    \/* Node name stack *\/\n-    const xmlChar     *name;          \/* Current parsed Node *\/\n-    int                nameNr;        \/* Depth of the parsing stack *\/\n-    int                nameMax;       \/* Max depth of the parsing stack *\/\n-    const xmlChar *   *nameTab;       \/* array of nodes *\/\n-\n-    long               nbChars;       \/* unused *\/\n-    long            checkIndex;       \/* used by progressive parsing lookup *\/\n-    int             keepBlanks;       \/* ugly but ... *\/\n-    int             disableSAX;       \/* SAX callbacks are disabled *\/\n-    int               inSubset;       \/* Parsing is in int 1\/ext 2 subset *\/\n-    const xmlChar *    intSubName;    \/* name of subset *\/\n-    xmlChar *          extSubURI;     \/* URI of external subset *\/\n-    xmlChar *          extSubSystem;  \/* SYSTEM ID of external subset *\/\n+    \/* Should the parser preserve spaces *\/\n+    int *space XML_DEPRECATED_MEMBER;\n+    \/* Depth of the parsing stack *\/\n+    int spaceNr XML_DEPRECATED_MEMBER;\n+    \/* Max depth of the parsing stack *\/\n+    int spaceMax XML_DEPRECATED_MEMBER;\n+    \/* array of space infos *\/\n+    int *spaceTab XML_DEPRECATED_MEMBER;\n+\n+    \/* to prevent entity substitution loops *\/\n+    int depth XML_DEPRECATED_MEMBER;\n+    \/* unused *\/\n+    xmlParserInputPtr entity XML_DEPRECATED_MEMBER;\n+    \/* unused *\/\n+    int charset XML_DEPRECATED_MEMBER;\n+    \/* Those two fields are there to *\/\n+    int nodelen XML_DEPRECATED_MEMBER;\n+    \/* Speed up large node parsing *\/\n+    int nodemem XML_DEPRECATED_MEMBER;\n+    \/* signal pedantic warnings *\/\n+    int pedantic XML_DEPRECATED_MEMBER;\n+    \/* For user data, libxml won't touch it *\/\n+    void *_private;\n@@ -237,23 +370,18 @@\n-    \/* xml:space values *\/\n-    int *              space;         \/* Should the parser preserve spaces *\/\n-    int                spaceNr;       \/* Depth of the parsing stack *\/\n-    int                spaceMax;      \/* Max depth of the parsing stack *\/\n-    int *              spaceTab;      \/* array of space infos *\/\n-\n-    int                depth;         \/* to prevent entity substitution loops *\/\n-    xmlParserInputPtr  entity;        \/* unused *\/\n-    int                charset;       \/* unused *\/\n-    int                nodelen;       \/* Those two fields are there to *\/\n-    int                nodemem;       \/* Speed up large node parsing *\/\n-    int                pedantic;      \/* signal pedantic warnings *\/\n-    void              *_private;      \/* For user data, libxml won't touch it *\/\n-\n-    int                loadsubset;    \/* should the external subset be loaded *\/\n-    int                linenumbers;   \/* set line number in element content *\/\n-    void              *catalogs;      \/* document's own catalog *\/\n-    int                recovery;      \/* run in recovery mode *\/\n-    int                progressive;   \/* unused *\/\n-    xmlDictPtr         dict;          \/* dictionary for the parser *\/\n-    const xmlChar *   *atts;          \/* array for the attributes callbacks *\/\n-    int                maxatts;       \/* the size of the array *\/\n-    int                docdict;       \/* unused *\/\n+    \/* should the external subset be loaded *\/\n+    int loadsubset;\n+    \/* set line number in element content *\/\n+    int linenumbers XML_DEPRECATED_MEMBER;\n+    \/* document's own catalog *\/\n+    void *catalogs XML_DEPRECATED_MEMBER;\n+    \/* run in recovery mode *\/\n+    int recovery XML_DEPRECATED_MEMBER;\n+    \/* unused *\/\n+    int progressive XML_DEPRECATED_MEMBER;\n+    \/* dictionary for the parser *\/\n+    xmlDictPtr dict;\n+    \/* array for the attributes callbacks *\/\n+    const xmlChar **atts XML_DEPRECATED_MEMBER;\n+    \/* the size of the array *\/\n+    int maxatts XML_DEPRECATED_MEMBER;\n+    \/* unused *\/\n+    int docdict XML_DEPRECATED_MEMBER;\n@@ -264,3 +392,3 @@\n-    const xmlChar *str_xml;\n-    const xmlChar *str_xmlns;\n-    const xmlChar *str_xml_ns;\n+    const xmlChar *str_xml XML_DEPRECATED_MEMBER;\n+    const xmlChar *str_xmlns XML_DEPRECATED_MEMBER;\n+    const xmlChar *str_xml_ns XML_DEPRECATED_MEMBER;\n@@ -271,10 +399,21 @@\n-    int                sax2;          \/* operating in the new SAX mode *\/\n-    int                nsNr;          \/* the number of inherited namespaces *\/\n-    int                nsMax;         \/* the size of the arrays *\/\n-    const xmlChar *   *nsTab;         \/* the array of prefix\/namespace name *\/\n-    unsigned          *attallocs;     \/* which attribute were allocated *\/\n-    xmlStartTag       *pushTab;       \/* array of data for push *\/\n-    xmlHashTablePtr    attsDefault;   \/* defaulted attributes if any *\/\n-    xmlHashTablePtr    attsSpecial;   \/* non-CDATA attributes if any *\/\n-    int                nsWellFormed;  \/* is the document XML Namespace okay *\/\n-    int                options;       \/* Extra options *\/\n+\n+    \/* operating in the new SAX mode *\/\n+    int sax2 XML_DEPRECATED_MEMBER;\n+    \/* the number of inherited namespaces *\/\n+    int nsNr XML_DEPRECATED_MEMBER;\n+    \/* the size of the arrays *\/\n+    int nsMax XML_DEPRECATED_MEMBER;\n+    \/* the array of prefix\/namespace name *\/\n+    const xmlChar **nsTab XML_DEPRECATED_MEMBER;\n+    \/* which attribute were allocated *\/\n+    unsigned *attallocs XML_DEPRECATED_MEMBER;\n+    \/* array of data for push *\/\n+    xmlStartTag *pushTab XML_DEPRECATED_MEMBER;\n+    \/* defaulted attributes if any *\/\n+    xmlHashTablePtr attsDefault XML_DEPRECATED_MEMBER;\n+    \/* non-CDATA attributes if any *\/\n+    xmlHashTablePtr attsSpecial XML_DEPRECATED_MEMBER;\n+    \/* is the document XML Namespace okay *\/\n+    int nsWellFormed;\n+    \/* Extra options *\/\n+    int options;\n@@ -285,5 +424,11 @@\n-    int               dictNames;    \/* Use dictionary names for the tree *\/\n-    int               freeElemsNr;  \/* number of freed element nodes *\/\n-    xmlNodePtr        freeElems;    \/* List of freed element nodes *\/\n-    int               freeAttrsNr;  \/* number of freed attributes nodes *\/\n-    xmlAttrPtr        freeAttrs;    \/* List of freed attributes nodes *\/\n+\n+    \/* Use dictionary names for the tree *\/\n+    int dictNames XML_DEPRECATED_MEMBER;\n+    \/* number of freed element nodes *\/\n+    int freeElemsNr XML_DEPRECATED_MEMBER;\n+    \/* List of freed element nodes *\/\n+    xmlNodePtr freeElems XML_DEPRECATED_MEMBER;\n+    \/* number of freed attributes nodes *\/\n+    int freeAttrsNr XML_DEPRECATED_MEMBER;\n+    \/* List of freed attributes nodes *\/\n+    xmlAttrPtr freeAttrs XML_DEPRECATED_MEMBER;\n@@ -294,4 +439,7 @@\n-    xmlError          lastError;\n-    xmlParserMode     parseMode;    \/* the parser mode *\/\n-    unsigned long    nbentities;    \/* unused *\/\n-    unsigned long  sizeentities;    \/* size of external entities *\/\n+    xmlError lastError XML_DEPRECATED_MEMBER;\n+    \/* the parser mode *\/\n+    xmlParserMode parseMode XML_DEPRECATED_MEMBER;\n+    \/* unused *\/\n+    unsigned long nbentities XML_DEPRECATED_MEMBER;\n+    \/* size of external entities *\/\n+    unsigned long sizeentities XML_DEPRECATED_MEMBER;\n@@ -300,19 +448,38 @@\n-    xmlParserNodeInfo *nodeInfo;      \/* Current NodeInfo *\/\n-    int                nodeInfoNr;    \/* Depth of the parsing stack *\/\n-    int                nodeInfoMax;   \/* Max depth of the parsing stack *\/\n-    xmlParserNodeInfo *nodeInfoTab;   \/* array of nodeInfos *\/\n-\n-    int                input_id;      \/* we need to label inputs *\/\n-    unsigned long      sizeentcopy;   \/* volume of entity copy *\/\n-\n-    int           endCheckState;    \/* quote state for push parser *\/\n-    unsigned short     nbErrors;    \/* number of errors *\/\n-    unsigned short   nbWarnings;    \/* number of warnings *\/\n-    unsigned            maxAmpl;    \/* maximum amplification factor *\/\n-\n-    xmlParserNsData       *nsdb;    \/* namespace database *\/\n-    unsigned        attrHashMax;    \/* allocated size *\/\n-    xmlAttrHashBucket *attrHash;    \/* atttribute hash table *\/\n-\n-    xmlStructuredErrorFunc errorHandler;\n-    void *errorCtxt;\n+    \/* Current NodeInfo *\/\n+    xmlParserNodeInfo *nodeInfo XML_DEPRECATED_MEMBER;\n+    \/* Depth of the parsing stack *\/\n+    int nodeInfoNr XML_DEPRECATED_MEMBER;\n+    \/* Max depth of the parsing stack *\/\n+    int nodeInfoMax XML_DEPRECATED_MEMBER;\n+    \/* array of nodeInfos *\/\n+    xmlParserNodeInfo *nodeInfoTab XML_DEPRECATED_MEMBER;\n+\n+    \/* we need to label inputs *\/\n+    int input_id XML_DEPRECATED_MEMBER;\n+    \/* volume of entity copy *\/\n+    unsigned long sizeentcopy XML_DEPRECATED_MEMBER;\n+\n+    \/* quote state for push parser *\/\n+    int endCheckState XML_DEPRECATED_MEMBER;\n+    \/* number of errors *\/\n+    unsigned short nbErrors XML_DEPRECATED_MEMBER;\n+    \/* number of warnings *\/\n+    unsigned short nbWarnings XML_DEPRECATED_MEMBER;\n+    \/* maximum amplification factor *\/\n+    unsigned maxAmpl XML_DEPRECATED_MEMBER;\n+\n+    \/* namespace database *\/\n+    xmlParserNsData *nsdb XML_DEPRECATED_MEMBER;\n+    \/* allocated size *\/\n+    unsigned attrHashMax XML_DEPRECATED_MEMBER;\n+    \/* atttribute hash table *\/\n+    xmlAttrHashBucket *attrHash XML_DEPRECATED_MEMBER;\n+\n+    xmlStructuredErrorFunc errorHandler XML_DEPRECATED_MEMBER;\n+    void *errorCtxt XML_DEPRECATED_MEMBER;\n+\n+    xmlResourceLoader resourceLoader XML_DEPRECATED_MEMBER;\n+    void *resourceCtxt XML_DEPRECATED_MEMBER;\n+\n+    xmlCharEncConvImpl convImpl XML_DEPRECATED_MEMBER;\n+    void *convCtxt XML_DEPRECATED_MEMBER;\n@@ -356,2 +523,2 @@\n-                const xmlChar *publicId,\n-                const xmlChar *systemId);\n+                                const xmlChar *publicId,\n+                                const xmlChar *systemId);\n@@ -368,3 +535,3 @@\n-                const xmlChar *name,\n-                const xmlChar *ExternalID,\n-                const xmlChar *SystemID);\n+                                const xmlChar *name,\n+                                const xmlChar *ExternalID,\n+                                const xmlChar *SystemID);\n@@ -381,3 +548,3 @@\n-                const xmlChar *name,\n-                const xmlChar *ExternalID,\n-                const xmlChar *SystemID);\n+                                const xmlChar *name,\n+                                const xmlChar *ExternalID,\n+                                const xmlChar *SystemID);\n@@ -394,1 +561,1 @@\n-                const xmlChar *name);\n+                                const xmlChar *name);\n@@ -405,1 +572,1 @@\n-                const xmlChar *name);\n+                                const xmlChar *name);\n@@ -418,5 +585,5 @@\n-                const xmlChar *name,\n-                int type,\n-                const xmlChar *publicId,\n-                const xmlChar *systemId,\n-                xmlChar *content);\n+                                const xmlChar *name,\n+                                int type,\n+                                const xmlChar *publicId,\n+                                const xmlChar *systemId,\n+                                xmlChar *content);\n@@ -433,3 +600,3 @@\n-                const xmlChar *name,\n-                const xmlChar *publicId,\n-                const xmlChar *systemId);\n+                                const xmlChar *name,\n+                                const xmlChar *publicId,\n+                                const xmlChar *systemId);\n@@ -449,6 +616,6 @@\n-                const xmlChar *elem,\n-                const xmlChar *fullname,\n-                int type,\n-                int def,\n-                const xmlChar *defaultValue,\n-                xmlEnumerationPtr tree);\n+                                const xmlChar *elem,\n+                                const xmlChar *fullname,\n+                                int type,\n+                                int def,\n+                                const xmlChar *defaultValue,\n+                                xmlEnumerationPtr tree);\n@@ -465,3 +632,3 @@\n-                const xmlChar *name,\n-                int type,\n-                xmlElementContentPtr content);\n+                                const xmlChar *name,\n+                                int type,\n+                                xmlElementContentPtr content);\n@@ -479,4 +646,4 @@\n-                const xmlChar *name,\n-                const xmlChar *publicId,\n-                const xmlChar *systemId,\n-                const xmlChar *notationName);\n+                                const xmlChar *name,\n+                                const xmlChar *publicId,\n+                                const xmlChar *systemId,\n+                                const xmlChar *notationName);\n@@ -492,1 +659,1 @@\n-                xmlSAXLocatorPtr loc);\n+                                xmlSAXLocatorPtr loc);\n@@ -516,2 +683,2 @@\n-                const xmlChar *name,\n-                const xmlChar **atts);\n+                                const xmlChar *name,\n+                                const xmlChar **atts);\n@@ -526,1 +693,1 @@\n-                const xmlChar *name);\n+                                const xmlChar *name);\n@@ -539,2 +706,2 @@\n-                const xmlChar *name,\n-                const xmlChar *value);\n+                                const xmlChar *name,\n+                                const xmlChar *value);\n@@ -549,1 +716,1 @@\n-                const xmlChar *name);\n+                                const xmlChar *name);\n@@ -559,2 +726,2 @@\n-                const xmlChar *ch,\n-                int len);\n+                                const xmlChar *ch,\n+                                int len);\n@@ -571,2 +738,2 @@\n-                const xmlChar *ch,\n-                int len);\n+                                const xmlChar *ch,\n+                                int len);\n@@ -582,2 +749,2 @@\n-                const xmlChar *target,\n-                const xmlChar *data);\n+                                const xmlChar *target,\n+                                const xmlChar *data);\n@@ -592,1 +759,1 @@\n-                const xmlChar *value);\n+                                const xmlChar *value);\n@@ -602,3 +769,3 @@\n-                            void *ctx,\n-                const xmlChar *value,\n-                int len);\n+                                void *ctx,\n+                                const xmlChar *value,\n+                                int len);\n@@ -614,1 +781,1 @@\n-                const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n+                                const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -624,1 +791,1 @@\n-                const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n+                                const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -636,1 +803,1 @@\n-                const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n+                                const char *msg, ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -667,3 +834,3 @@\n- *                                    *\n- *            The SAX version 2 API extensions        *\n- *                                    *\n+ *                                                                      *\n+ *                      The SAX version 2 API extensions                *\n+ *                                                                      *\n@@ -698,8 +865,8 @@\n-                    const xmlChar *localname,\n-                    const xmlChar *prefix,\n-                    const xmlChar *URI,\n-                    int nb_namespaces,\n-                    const xmlChar **namespaces,\n-                    int nb_attributes,\n-                    int nb_defaulted,\n-                    const xmlChar **attributes);\n+                                        const xmlChar *localname,\n+                                        const xmlChar *prefix,\n+                                        const xmlChar *URI,\n+                                        int nb_namespaces,\n+                                        const xmlChar **namespaces,\n+                                        int nb_attributes,\n+                                        int nb_defaulted,\n+                                        const xmlChar **attributes);\n@@ -719,3 +886,3 @@\n-                    const xmlChar *localname,\n-                    const xmlChar *prefix,\n-                    const xmlChar *URI);\n+                                        const xmlChar *localname,\n+                                        const xmlChar *prefix,\n+                                        const xmlChar *URI);\n@@ -725,12 +892,17 @@\n-    internalSubsetSAXFunc internalSubset;\n-    isStandaloneSAXFunc isStandalone;\n-    hasInternalSubsetSAXFunc hasInternalSubset;\n-    hasExternalSubsetSAXFunc hasExternalSubset;\n-    resolveEntitySAXFunc resolveEntity;\n-    getEntitySAXFunc getEntity;\n-    entityDeclSAXFunc entityDecl;\n-    notationDeclSAXFunc notationDecl;\n-    attributeDeclSAXFunc attributeDecl;\n-    elementDeclSAXFunc elementDecl;\n-    unparsedEntityDeclSAXFunc unparsedEntityDecl;\n-    setDocumentLocatorSAXFunc setDocumentLocator;\n+    \/*\n+     * For DTD-related handlers, it's recommended to either use the\n+     * original libxml2 handler or set them to NULL if DTDs can be\n+     * ignored.\n+     *\/\n+    internalSubsetSAXFunc internalSubset; \/* DTD *\/\n+    isStandaloneSAXFunc isStandalone; \/* unused *\/\n+    hasInternalSubsetSAXFunc hasInternalSubset; \/* DTD *\/\n+    hasExternalSubsetSAXFunc hasExternalSubset; \/* DTD *\/\n+    resolveEntitySAXFunc resolveEntity; \/* DTD *\/\n+    getEntitySAXFunc getEntity; \/* DTD *\/\n+    entityDeclSAXFunc entityDecl; \/* DTD *\/\n+    notationDeclSAXFunc notationDecl; \/* DTD *\/\n+    attributeDeclSAXFunc attributeDecl; \/* DTD *\/\n+    elementDeclSAXFunc elementDecl; \/* DTD *\/\n+    unparsedEntityDeclSAXFunc unparsedEntityDecl; \/* DTD *\/\n+    setDocumentLocatorSAXFunc setDocumentLocator; \/* deprecated *\/\n@@ -756,0 +928,5 @@\n+    \/*\n+     * `ignorableWhitespace` should always be set to the same value\n+     * as `characters`. Otherwise, the parser will try to detect\n+     * whitespace which is unreliable.\n+     *\/\n@@ -761,2 +938,2 @@\n-    fatalErrorSAXFunc fatalError; \/* unused error() get all the errors *\/\n-    getParameterEntitySAXFunc getParameterEntity;\n+    fatalErrorSAXFunc fatalError; \/* unused, `error` gets all the errors *\/\n+    getParameterEntitySAXFunc getParameterEntity; \/* DTD *\/\n@@ -764,1 +941,1 @@\n-    externalSubsetSAXFunc externalSubset;\n+    externalSubsetSAXFunc externalSubset; \/* DTD *\/\n@@ -776,0 +953,4 @@\n+    \/*\n+     * Takes precedence over `error` or `warning`, but modern code\n+     * should use xmlCtxtSetErrorHandler.\n+     *\/\n@@ -827,2 +1008,2 @@\n-                     const char *ID,\n-                     xmlParserCtxtPtr context);\n+                                         const char *ID,\n+                                         xmlParserCtxtPtr context);\n@@ -835,4 +1016,2 @@\n-XML_DEPRECATED\n-XMLPUBVAR const int oldXMLWDcompatibility;\n-XML_DEPRECATED\n-XMLPUBVAR const int xmlParserDebugEntities;\n+\n+\/** DOC_DISABLE *\/\n@@ -846,3 +1025,0 @@\n-#ifdef LIBXML_THREAD_ENABLED\n-\/* backward compatibility *\/\n-XMLPUBFUN const char *const *__xmlParserVersion(void);\n@@ -850,1 +1026,1 @@\n-XMLPUBFUN const int *__oldXMLWDcompatibility(void);\n+XMLPUBFUN int *__xmlDoValidityCheckingDefaultValue(void);\n@@ -852,1 +1028,1 @@\n-XMLPUBFUN const int *__xmlParserDebugEntities(void);\n+XMLPUBFUN int *__xmlGetWarningsDefaultValue(void);\n@@ -854,2 +1030,1 @@\n-XMLPUBFUN const xmlSAXLocator *__xmlDefaultSAXLocator(void);\n-#ifdef LIBXML_SAX1_ENABLED\n+XMLPUBFUN int *__xmlKeepBlanksDefaultValue(void);\n@@ -857,13 +1032,7 @@\n-XMLPUBFUN const xmlSAXHandlerV1 *__xmlDefaultSAXHandler(void);\n-#endif\n-#endif\n-\n-\/** DOC_DISABLE *\/\n-#define XML_GLOBALS_PARSER_CORE \\\n-  XML_OP(xmlDoValidityCheckingDefaultValue, int, XML_DEPRECATED) \\\n-  XML_OP(xmlGetWarningsDefaultValue, int, XML_DEPRECATED) \\\n-  XML_OP(xmlKeepBlanksDefaultValue, int, XML_DEPRECATED) \\\n-  XML_OP(xmlLineNumbersDefaultValue, int, XML_DEPRECATED) \\\n-  XML_OP(xmlLoadExtDtdDefaultValue, int, XML_DEPRECATED) \\\n-  XML_OP(xmlPedanticParserDefaultValue, int, XML_DEPRECATED) \\\n-  XML_OP(xmlSubstituteEntitiesDefaultValue, int, XML_DEPRECATED)\n+XMLPUBFUN int *__xmlLineNumbersDefaultValue(void);\n+XML_DEPRECATED\n+XMLPUBFUN int *__xmlLoadExtDtdDefaultValue(void);\n+XML_DEPRECATED\n+XMLPUBFUN int *__xmlPedanticParserDefaultValue(void);\n+XML_DEPRECATED\n+XMLPUBFUN int *__xmlSubstituteEntitiesDefaultValue(void);\n@@ -872,6 +1041,3 @@\n-  #define XML_GLOBALS_PARSER_OUTPUT \\\n-    XML_OP(xmlIndentTreeOutput, int, XML_NO_ATTR) \\\n-    XML_OP(xmlTreeIndentString, const char *, XML_NO_ATTR) \\\n-    XML_OP(xmlSaveNoEmptyTags, int, XML_NO_ATTR)\n-#else\n-  #define XML_GLOBALS_PARSER_OUTPUT\n+XMLPUBFUN int *__xmlIndentTreeOutput(void);\n+XMLPUBFUN const char **__xmlTreeIndentString(void);\n+XMLPUBFUN int *__xmlSaveNoEmptyTags(void);\n@@ -880,9 +1046,1 @@\n-#define XML_GLOBALS_PARSER \\\n-  XML_GLOBALS_PARSER_CORE \\\n-  XML_GLOBALS_PARSER_OUTPUT\n-\n-#define XML_OP XML_DECLARE_GLOBAL\n-XML_GLOBALS_PARSER\n-#undef XML_OP\n-\n-#if defined(LIBXML_THREAD_ENABLED) && !defined(XML_GLOBALS_NO_REDEFINITION)\n+#ifndef XML_GLOBALS_NO_REDEFINITION\n@@ -890,1 +1048,1 @@\n-    XML_GLOBAL_MACRO(xmlDoValidityCheckingDefaultValue)\n+    (*__xmlDoValidityCheckingDefaultValue())\n@@ -892,2 +1050,2 @@\n-    XML_GLOBAL_MACRO(xmlGetWarningsDefaultValue)\n-  #define xmlKeepBlanksDefaultValue XML_GLOBAL_MACRO(xmlKeepBlanksDefaultValue)\n+    (*__xmlGetWarningsDefaultValue())\n+  #define xmlKeepBlanksDefaultValue (*__xmlKeepBlanksDefaultValue())\n@@ -895,2 +1053,2 @@\n-    XML_GLOBAL_MACRO(xmlLineNumbersDefaultValue)\n-  #define xmlLoadExtDtdDefaultValue XML_GLOBAL_MACRO(xmlLoadExtDtdDefaultValue)\n+    (*__xmlLineNumbersDefaultValue())\n+  #define xmlLoadExtDtdDefaultValue (*__xmlLoadExtDtdDefaultValue())\n@@ -898,1 +1056,1 @@\n-    XML_GLOBAL_MACRO(xmlPedanticParserDefaultValue)\n+    (*__xmlPedanticParserDefaultValue())\n@@ -900,1 +1058,1 @@\n-    XML_GLOBAL_MACRO(xmlSubstituteEntitiesDefaultValue)\n+    (*__xmlSubstituteEntitiesDefaultValue())\n@@ -902,3 +1060,3 @@\n-    #define xmlIndentTreeOutput XML_GLOBAL_MACRO(xmlIndentTreeOutput)\n-    #define xmlTreeIndentString XML_GLOBAL_MACRO(xmlTreeIndentString)\n-    #define xmlSaveNoEmptyTags XML_GLOBAL_MACRO(xmlSaveNoEmptyTags)\n+    #define xmlIndentTreeOutput (*__xmlIndentTreeOutput())\n+    #define xmlTreeIndentString (*__xmlTreeIndentString())\n+    #define xmlSaveNoEmptyTags (*__xmlSaveNoEmptyTags())\n@@ -913,1 +1071,1 @@\n-        xmlInitParser        (void);\n+                xmlInitParser           (void);\n@@ -915,1 +1073,1 @@\n-        xmlCleanupParser    (void);\n+                xmlCleanupParser        (void);\n@@ -918,1 +1076,1 @@\n-        xmlInitGlobals        (void);\n+                xmlInitGlobals          (void);\n@@ -921,1 +1079,1 @@\n-        xmlCleanupGlobals    (void);\n+                xmlCleanupGlobals       (void);\n@@ -928,3 +1086,2 @@\n-        xmlParserInputRead    (xmlParserInputPtr in,\n-                     int len);\n-XML_DEPRECATED\n+                xmlParserInputRead      (xmlParserInputPtr in,\n+                                         int len);\n@@ -932,2 +1089,2 @@\n-        xmlParserInputGrow    (xmlParserInputPtr in,\n-                     int len);\n+                xmlParserInputGrow      (xmlParserInputPtr in,\n+                                         int len);\n@@ -940,1 +1097,1 @@\n-        xmlParseDoc        (const xmlChar *cur);\n+                xmlParseDoc             (const xmlChar *cur);\n@@ -942,1 +1099,1 @@\n-        xmlParseFile        (const char *filename);\n+                xmlParseFile            (const char *filename);\n@@ -944,2 +1101,2 @@\n-        xmlParseMemory        (const char *buffer,\n-                     int size);\n+                xmlParseMemory          (const char *buffer,\n+                                         int size);\n@@ -947,3 +1104,5 @@\n-XML_DEPRECATED XMLPUBFUN int\n-        xmlSubstituteEntitiesDefault(int val);\n-XML_DEPRECATED XMLPUBFUN int\n+XML_DEPRECATED\n+XMLPUBFUN int\n+                xmlSubstituteEntitiesDefault(int val);\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -952,3 +1111,4 @@\n-        xmlKeepBlanksDefault    (int val);\n-XML_DEPRECATED XMLPUBFUN int\n-        xmlThrDefKeepBlanksDefaultValue(int v);\n+                xmlKeepBlanksDefault    (int val);\n+XML_DEPRECATED\n+XMLPUBFUN int\n+                xmlThrDefKeepBlanksDefaultValue(int v);\n@@ -956,4 +1116,6 @@\n-        xmlStopParser        (xmlParserCtxtPtr ctxt);\n-XML_DEPRECATED XMLPUBFUN int\n-        xmlPedanticParserDefault(int val);\n-XML_DEPRECATED XMLPUBFUN int\n+                xmlStopParser           (xmlParserCtxtPtr ctxt);\n+XML_DEPRECATED\n+XMLPUBFUN int\n+                xmlPedanticParserDefault(int val);\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -961,3 +1123,5 @@\n-XML_DEPRECATED XMLPUBFUN int\n-        xmlLineNumbersDefault    (int val);\n-XML_DEPRECATED XMLPUBFUN int\n+XML_DEPRECATED\n+XMLPUBFUN int\n+                xmlLineNumbersDefault   (int val);\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -965,1 +1129,2 @@\n-XML_DEPRECATED XMLPUBFUN int\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -967,1 +1132,2 @@\n-XML_DEPRECATED XMLPUBFUN int\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -969,1 +1135,2 @@\n-XML_DEPRECATED XMLPUBFUN int\n+XML_DEPRECATED\n+XMLPUBFUN int\n@@ -971,2 +1138,0 @@\n-XML_DEPRECATED XMLPUBFUN int\n-                xmlThrDefParserDebugEntities(int v);\n@@ -980,1 +1145,1 @@\n-        xmlRecoverDoc        (const xmlChar *cur);\n+                xmlRecoverDoc           (const xmlChar *cur);\n@@ -983,2 +1148,2 @@\n-        xmlRecoverMemory    (const char *buffer,\n-                     int size);\n+                xmlRecoverMemory        (const char *buffer,\n+                                         int size);\n@@ -987,1 +1152,1 @@\n-        xmlRecoverFile        (const char *filename);\n+                xmlRecoverFile          (const char *filename);\n@@ -994,1 +1159,2 @@\n-        xmlParseDocument    (xmlParserCtxtPtr ctxt);\n+                xmlParseDocument        (xmlParserCtxtPtr ctxt);\n+XML_DEPRECATED\n@@ -996,1 +1162,1 @@\n-        xmlParseExtParsedEnt    (xmlParserCtxtPtr ctxt);\n+                xmlParseExtParsedEnt    (xmlParserCtxtPtr ctxt);\n@@ -1000,3 +1166,3 @@\n-        xmlSAXUserParseFile    (xmlSAXHandlerPtr sax,\n-                     void *user_data,\n-                     const char *filename);\n+                xmlSAXUserParseFile     (xmlSAXHandlerPtr sax,\n+                                         void *user_data,\n+                                         const char *filename);\n@@ -1005,4 +1171,4 @@\n-        xmlSAXUserParseMemory    (xmlSAXHandlerPtr sax,\n-                     void *user_data,\n-                     const char *buffer,\n-                     int size);\n+                xmlSAXUserParseMemory   (xmlSAXHandlerPtr sax,\n+                                         void *user_data,\n+                                         const char *buffer,\n+                                         int size);\n@@ -1011,3 +1177,3 @@\n-        xmlSAXParseDoc        (xmlSAXHandlerPtr sax,\n-                     const xmlChar *cur,\n-                     int recovery);\n+                xmlSAXParseDoc          (xmlSAXHandlerPtr sax,\n+                                         const xmlChar *cur,\n+                                         int recovery);\n@@ -1016,4 +1182,4 @@\n-        xmlSAXParseMemory    (xmlSAXHandlerPtr sax,\n-                     const char *buffer,\n-                     int size,\n-                     int recovery);\n+                xmlSAXParseMemory       (xmlSAXHandlerPtr sax,\n+                                         const char *buffer,\n+                                         int size,\n+                                         int recovery);\n@@ -1022,5 +1188,5 @@\n-        xmlSAXParseMemoryWithData (xmlSAXHandlerPtr sax,\n-                     const char *buffer,\n-                     int size,\n-                     int recovery,\n-                     void *data);\n+                xmlSAXParseMemoryWithData (xmlSAXHandlerPtr sax,\n+                                         const char *buffer,\n+                                         int size,\n+                                         int recovery,\n+                                         void *data);\n@@ -1029,3 +1195,3 @@\n-        xmlSAXParseFile        (xmlSAXHandlerPtr sax,\n-                     const char *filename,\n-                     int recovery);\n+                xmlSAXParseFile         (xmlSAXHandlerPtr sax,\n+                                         const char *filename,\n+                                         int recovery);\n@@ -1034,4 +1200,4 @@\n-        xmlSAXParseFileWithData    (xmlSAXHandlerPtr sax,\n-                     const char *filename,\n-                     int recovery,\n-                     void *data);\n+                xmlSAXParseFileWithData (xmlSAXHandlerPtr sax,\n+                                         const char *filename,\n+                                         int recovery,\n+                                         void *data);\n@@ -1040,2 +1206,2 @@\n-        xmlSAXParseEntity    (xmlSAXHandlerPtr sax,\n-                     const char *filename);\n+                xmlSAXParseEntity       (xmlSAXHandlerPtr sax,\n+                                         const char *filename);\n@@ -1044,1 +1210,1 @@\n-        xmlParseEntity        (const char *filename);\n+                xmlParseEntity          (const char *filename);\n@@ -1048,0 +1214,12 @@\n+XMLPUBFUN xmlDtdPtr\n+                xmlCtxtParseDtd         (xmlParserCtxtPtr ctxt,\n+                                         xmlParserInputPtr input,\n+                                         const xmlChar *ExternalID,\n+                                         const xmlChar *SystemID);\n+XMLPUBFUN int\n+                xmlCtxtValidateDocument (xmlParserCtxtPtr ctxt,\n+                                         xmlDocPtr doc);\n+XMLPUBFUN int\n+                xmlCtxtValidateDtd      (xmlParserCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlDtdPtr dtd);\n@@ -1050,3 +1228,3 @@\n-        xmlSAXParseDTD        (xmlSAXHandlerPtr sax,\n-                     const xmlChar *ExternalID,\n-                     const xmlChar *SystemID);\n+                xmlSAXParseDTD          (xmlSAXHandlerPtr sax,\n+                                         const xmlChar *ExternalID,\n+                                         const xmlChar *SystemID);\n@@ -1054,2 +1232,2 @@\n-        xmlParseDTD        (const xmlChar *ExternalID,\n-                     const xmlChar *SystemID);\n+                xmlParseDTD             (const xmlChar *ExternalID,\n+                                         const xmlChar *SystemID);\n@@ -1057,3 +1235,3 @@\n-        xmlIOParseDTD        (xmlSAXHandlerPtr sax,\n-                     xmlParserInputBufferPtr input,\n-                     xmlCharEncoding enc);\n+                xmlIOParseDTD           (xmlSAXHandlerPtr sax,\n+                                         xmlParserInputBufferPtr input,\n+                                         xmlCharEncoding enc);\n@@ -1063,6 +1241,6 @@\n-        xmlParseBalancedChunkMemory(xmlDocPtr doc,\n-                     xmlSAXHandlerPtr sax,\n-                     void *user_data,\n-                     int depth,\n-                     const xmlChar *string,\n-                     xmlNodePtr *lst);\n+                xmlParseBalancedChunkMemory(xmlDocPtr doc,\n+                                         xmlSAXHandlerPtr sax,\n+                                         void *user_data,\n+                                         int depth,\n+                                         const xmlChar *string,\n+                                         xmlNodePtr *lst);\n@@ -1071,5 +1249,5 @@\n-        xmlParseInNodeContext    (xmlNodePtr node,\n-                     const char *data,\n-                     int datalen,\n-                     int options,\n-                     xmlNodePtr *lst);\n+                xmlParseInNodeContext   (xmlNodePtr node,\n+                                         const char *data,\n+                                         int datalen,\n+                                         int options,\n+                                         xmlNodePtr *lst);\n@@ -1078,1 +1256,1 @@\n-        xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc,\n+                xmlParseBalancedChunkMemoryRecover(xmlDocPtr doc,\n@@ -1087,7 +1265,7 @@\n-        xmlParseExternalEntity    (xmlDocPtr doc,\n-                     xmlSAXHandlerPtr sax,\n-                     void *user_data,\n-                     int depth,\n-                     const xmlChar *URL,\n-                     const xmlChar *ID,\n-                     xmlNodePtr *lst);\n+                xmlParseExternalEntity  (xmlDocPtr doc,\n+                                         xmlSAXHandlerPtr sax,\n+                                         void *user_data,\n+                                         int depth,\n+                                         const xmlChar *URL,\n+                                         const xmlChar *ID,\n+                                         xmlNodePtr *lst);\n@@ -1096,4 +1274,4 @@\n-        xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx,\n-                     const xmlChar *URL,\n-                     const xmlChar *ID,\n-                     xmlNodePtr *lst);\n+                xmlParseCtxtExternalEntity(xmlParserCtxtPtr ctx,\n+                                         const xmlChar *URL,\n+                                         const xmlChar *ID,\n+                                         xmlNodePtr *lst);\n@@ -1105,1 +1283,1 @@\n-        xmlNewParserCtxt    (void);\n+                xmlNewParserCtxt        (void);\n@@ -1107,2 +1285,2 @@\n-        xmlNewSAXParserCtxt    (const xmlSAXHandler *sax,\n-                     void *userData);\n+                xmlNewSAXParserCtxt     (const xmlSAXHandler *sax,\n+                                         void *userData);\n@@ -1110,1 +1288,1 @@\n-        xmlInitParserCtxt    (xmlParserCtxtPtr ctxt);\n+                xmlInitParserCtxt       (xmlParserCtxtPtr ctxt);\n@@ -1112,1 +1290,1 @@\n-        xmlClearParserCtxt    (xmlParserCtxtPtr ctxt);\n+                xmlClearParserCtxt      (xmlParserCtxtPtr ctxt);\n@@ -1114,1 +1292,1 @@\n-        xmlFreeParserCtxt    (xmlParserCtxtPtr ctxt);\n+                xmlFreeParserCtxt       (xmlParserCtxtPtr ctxt);\n@@ -1118,3 +1296,3 @@\n-        xmlSetupParserForBuffer    (xmlParserCtxtPtr ctxt,\n-                     const xmlChar* buffer,\n-                     const char *filename);\n+                xmlSetupParserForBuffer (xmlParserCtxtPtr ctxt,\n+                                         const xmlChar* buffer,\n+                                         const char *filename);\n@@ -1123,21 +1301,1 @@\n-        xmlCreateDocParserCtxt    (const xmlChar *cur);\n-\n-#ifdef LIBXML_LEGACY_ENABLED\n-\/*\n- * Reading\/setting optional parsing features.\n- *\/\n-XML_DEPRECATED\n-XMLPUBFUN int\n-        xmlGetFeaturesList    (int *len,\n-                     const char **result);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-        xmlGetFeature        (xmlParserCtxtPtr ctxt,\n-                     const char *name,\n-                     void *result);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-        xmlSetFeature        (xmlParserCtxtPtr ctxt,\n-                     const char *name,\n-                     void *value);\n-#endif \/* LIBXML_LEGACY_ENABLED *\/\n+                xmlCreateDocParserCtxt  (const xmlChar *cur);\n@@ -1150,5 +1308,5 @@\n-        xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax,\n-                     void *user_data,\n-                     const char *chunk,\n-                     int size,\n-                     const char *filename);\n+                xmlCreatePushParserCtxt(xmlSAXHandlerPtr sax,\n+                                         void *user_data,\n+                                         const char *chunk,\n+                                         int size,\n+                                         const char *filename);\n@@ -1156,4 +1314,4 @@\n-        xmlParseChunk        (xmlParserCtxtPtr ctxt,\n-                     const char *chunk,\n-                     int size,\n-                     int terminate);\n+                xmlParseChunk           (xmlParserCtxtPtr ctxt,\n+                                         const char *chunk,\n+                                         int size,\n+                                         int terminate);\n@@ -1167,6 +1325,6 @@\n-        xmlCreateIOParserCtxt    (xmlSAXHandlerPtr sax,\n-                     void *user_data,\n-                     xmlInputReadCallback   ioread,\n-                     xmlInputCloseCallback  ioclose,\n-                     void *ioctx,\n-                     xmlCharEncoding enc);\n+                xmlCreateIOParserCtxt   (xmlSAXHandlerPtr sax,\n+                                         void *user_data,\n+                                         xmlInputReadCallback   ioread,\n+                                         xmlInputCloseCallback  ioclose,\n+                                         void *ioctx,\n+                                         xmlCharEncoding enc);\n@@ -1175,3 +1333,3 @@\n-        xmlNewIOInputStream    (xmlParserCtxtPtr ctxt,\n-                     xmlParserInputBufferPtr input,\n-                     xmlCharEncoding enc);\n+                xmlNewIOInputStream     (xmlParserCtxtPtr ctxt,\n+                                         xmlParserInputBufferPtr input,\n+                                         xmlCharEncoding enc);\n@@ -1182,0 +1340,1 @@\n+XML_DEPRECATED\n@@ -1183,2 +1342,3 @@\n-        xmlParserFindNodeInfo    (xmlParserCtxtPtr ctxt,\n-                         xmlNodePtr node);\n+                xmlParserFindNodeInfo   (xmlParserCtxtPtr ctxt,\n+                                         xmlNodePtr node);\n+XML_DEPRECATED\n@@ -1186,1 +1346,2 @@\n-        xmlInitNodeInfoSeq    (xmlParserNodeInfoSeqPtr seq);\n+                xmlInitNodeInfoSeq      (xmlParserNodeInfoSeqPtr seq);\n+XML_DEPRECATED\n@@ -1188,1 +1349,2 @@\n-        xmlClearNodeInfoSeq    (xmlParserNodeInfoSeqPtr seq);\n+                xmlClearNodeInfoSeq     (xmlParserNodeInfoSeqPtr seq);\n+XML_DEPRECATED\n@@ -1190,1 +1352,1 @@\n-        xmlParserFindNodeInfoIndex(xmlParserNodeInfoSeqPtr seq,\n+                xmlParserFindNodeInfoIndex(xmlParserNodeInfoSeqPtr seq,\n@@ -1192,0 +1354,1 @@\n+XML_DEPRECATED\n@@ -1193,2 +1356,2 @@\n-        xmlParserAddNodeInfo    (xmlParserCtxtPtr ctxt,\n-                     xmlParserNodeInfoPtr info);\n+                xmlParserAddNodeInfo    (xmlParserCtxtPtr ctxt,\n+                                         xmlParserNodeInfoPtr info);\n@@ -1201,1 +1364,1 @@\n-        xmlSetExternalEntityLoader(xmlExternalEntityLoader f);\n+                xmlSetExternalEntityLoader(xmlExternalEntityLoader f);\n@@ -1203,1 +1366,1 @@\n-        xmlGetExternalEntityLoader(void);\n+                xmlGetExternalEntityLoader(void);\n@@ -1205,3 +1368,3 @@\n-        xmlLoadExternalEntity    (const char *URL,\n-                     const char *ID,\n-                     xmlParserCtxtPtr ctxt);\n+                xmlLoadExternalEntity   (const char *URL,\n+                                         const char *ID,\n+                                         xmlParserCtxtPtr ctxt);\n@@ -1209,3 +1372,1 @@\n-\/*\n- * Index lookup, actually implemented in the encoding module\n- *\/\n+XML_DEPRECATED\n@@ -1213,1 +1374,1 @@\n-        xmlByteConsumed        (xmlParserCtxtPtr ctxt);\n+                xmlByteConsumed         (xmlParserCtxtPtr ctxt);\n@@ -1225,12 +1386,12 @@\n-    XML_PARSE_RECOVER    = 1<<0,    \/* recover on errors *\/\n-    XML_PARSE_NOENT    = 1<<1,    \/* substitute entities *\/\n-    XML_PARSE_DTDLOAD    = 1<<2,    \/* load the external subset *\/\n-    XML_PARSE_DTDATTR    = 1<<3,    \/* default DTD attributes *\/\n-    XML_PARSE_DTDVALID    = 1<<4,    \/* validate with the DTD *\/\n-    XML_PARSE_NOERROR    = 1<<5,    \/* suppress error reports *\/\n-    XML_PARSE_NOWARNING    = 1<<6,    \/* suppress warning reports *\/\n-    XML_PARSE_PEDANTIC    = 1<<7,    \/* pedantic error reporting *\/\n-    XML_PARSE_NOBLANKS    = 1<<8,    \/* remove blank nodes *\/\n-    XML_PARSE_SAX1    = 1<<9,    \/* use the SAX1 interface internally *\/\n-    XML_PARSE_XINCLUDE    = 1<<10,\/* Implement XInclude substitution  *\/\n-    XML_PARSE_NONET    = 1<<11,\/* Forbid network access *\/\n+    XML_PARSE_RECOVER   = 1<<0, \/* recover on errors *\/\n+    XML_PARSE_NOENT     = 1<<1, \/* substitute entities *\/\n+    XML_PARSE_DTDLOAD   = 1<<2, \/* load the external subset *\/\n+    XML_PARSE_DTDATTR   = 1<<3, \/* default DTD attributes *\/\n+    XML_PARSE_DTDVALID  = 1<<4, \/* validate with the DTD *\/\n+    XML_PARSE_NOERROR   = 1<<5, \/* suppress error reports *\/\n+    XML_PARSE_NOWARNING = 1<<6, \/* suppress warning reports *\/\n+    XML_PARSE_PEDANTIC  = 1<<7, \/* pedantic error reporting *\/\n+    XML_PARSE_NOBLANKS  = 1<<8, \/* remove blank nodes *\/\n+    XML_PARSE_SAX1      = 1<<9, \/* use the SAX1 interface internally *\/\n+    XML_PARSE_XINCLUDE  = 1<<10,\/* Implement XInclude substitution  *\/\n+    XML_PARSE_NONET     = 1<<11,\/* Forbid network access *\/\n@@ -1238,2 +1399,2 @@\n-    XML_PARSE_NSCLEAN    = 1<<13,\/* remove redundant namespaces declarations *\/\n-    XML_PARSE_NOCDATA    = 1<<14,\/* merge CDATA as text nodes *\/\n+    XML_PARSE_NSCLEAN   = 1<<13,\/* remove redundant namespaces declarations *\/\n+    XML_PARSE_NOCDATA   = 1<<14,\/* merge CDATA as text nodes *\/\n@@ -1243,2 +1404,2 @@\n-                   crash if you try to modify the tree) *\/\n-    XML_PARSE_OLD10    = 1<<17,\/* parse using XML-1.0 before update 5 *\/\n+                                   crash if you try to modify the tree) *\/\n+    XML_PARSE_OLD10     = 1<<17,\/* parse using XML-1.0 before update 5 *\/\n@@ -1250,1 +1411,6 @@\n-    XML_PARSE_NO_XXE    = 1<<23 \/* disable loading of external content *\/\n+    \/* since 2.13.0 *\/\n+    XML_PARSE_NO_XXE    = 1<<23,\/* disable loading of external content *\/\n+    \/* since 2.14.0 *\/\n+    XML_PARSE_UNZIP          = 1<<24,\/* allow compressed content *\/\n+    XML_PARSE_NO_SYS_CATALOG = 1<<25,\/* disable global system catalog *\/\n+    XML_PARSE_CATALOG_PI     = 1<<26 \/* allow catalog PIs *\/\n@@ -1254,1 +1420,1 @@\n-        xmlCtxtReset        (xmlParserCtxtPtr ctxt);\n+                xmlCtxtReset            (xmlParserCtxtPtr ctxt);\n@@ -1256,5 +1422,5 @@\n-        xmlCtxtResetPush    (xmlParserCtxtPtr ctxt,\n-                     const char *chunk,\n-                     int size,\n-                     const char *filename,\n-                     const char *encoding);\n+                xmlCtxtResetPush        (xmlParserCtxtPtr ctxt,\n+                                         const char *chunk,\n+                                         int size,\n+                                         const char *filename,\n+                                         const char *encoding);\n@@ -1262,2 +1428,1 @@\n-        xmlCtxtSetOptions    (xmlParserCtxtPtr ctxt,\n-                     int options);\n+                xmlCtxtGetOptions       (xmlParserCtxtPtr ctxt);\n@@ -1265,2 +1430,12 @@\n-        xmlCtxtUseOptions    (xmlParserCtxtPtr ctxt,\n-                     int options);\n+                xmlCtxtSetOptions       (xmlParserCtxtPtr ctxt,\n+                                         int options);\n+XMLPUBFUN int\n+                xmlCtxtUseOptions       (xmlParserCtxtPtr ctxt,\n+                                         int options);\n+XMLPUBFUN void *\n+                xmlCtxtGetPrivate       (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN void\n+                xmlCtxtSetPrivate       (xmlParserCtxtPtr ctxt,\n+                                         void *priv);\n+XMLPUBFUN void *\n+                xmlCtxtGetCatalogs      (xmlParserCtxtPtr ctxt);\n@@ -1268,3 +1443,4 @@\n-        xmlCtxtSetErrorHandler    (xmlParserCtxtPtr ctxt,\n-                     xmlStructuredErrorFunc handler,\n-                     void *data);\n+                xmlCtxtSetCatalogs      (xmlParserCtxtPtr ctxt,\n+                                         void *catalogs);\n+XMLPUBFUN xmlDictPtr\n+                xmlCtxtGetDict          (xmlParserCtxtPtr ctxt);\n@@ -1272,2 +1448,7 @@\n-        xmlCtxtSetMaxAmplification(xmlParserCtxtPtr ctxt,\n-                     unsigned maxAmpl);\n+                xmlCtxtSetDict          (xmlParserCtxtPtr ctxt,\n+                                         xmlDictPtr);\n+XMLPUBFUN xmlSAXHandler *\n+                xmlCtxtGetSaxHandler    (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN int\n+                xmlCtxtSetSaxHandler    (xmlParserCtxtPtr ctxt,\n+                                         const xmlSAXHandler *sax);\n@@ -1275,4 +1456,37 @@\n-        xmlReadDoc        (const xmlChar *cur,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlCtxtGetDocument      (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN int\n+                xmlCtxtIsHtml           (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN int\n+                xmlCtxtIsStopped        (xmlParserCtxtPtr ctxt);\n+#ifdef LIBXML_VALID_ENABLED\n+XMLPUBFUN xmlValidCtxtPtr\n+                xmlCtxtGetValidCtxt     (xmlParserCtxtPtr ctxt);\n+#endif\n+XMLPUBFUN const xmlChar *\n+                xmlCtxtGetVersion       (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN const xmlChar *\n+                xmlCtxtGetDeclaredEncoding(xmlParserCtxtPtr ctxt);\n+XMLPUBFUN int\n+                xmlCtxtGetStandalone    (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN xmlParserStatus\n+                xmlCtxtGetStatus        (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN void\n+                xmlCtxtSetErrorHandler  (xmlParserCtxtPtr ctxt,\n+                                         xmlStructuredErrorFunc handler,\n+                                         void *data);\n+XMLPUBFUN void\n+                xmlCtxtSetResourceLoader(xmlParserCtxtPtr ctxt,\n+                                         xmlResourceLoader loader,\n+                                         void *vctxt);\n+XMLPUBFUN void\n+                xmlCtxtSetCharEncConvImpl(xmlParserCtxtPtr ctxt,\n+                                         xmlCharEncConvImpl impl,\n+                                         void *vctxt);\n+XMLPUBFUN void\n+                xmlCtxtSetMaxAmplification(xmlParserCtxtPtr ctxt,\n+                                         unsigned maxAmpl);\n+XMLPUBFUN xmlDocPtr\n+                xmlReadDoc              (const xmlChar *cur,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1280,3 +1494,3 @@\n-        xmlReadFile        (const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReadFile             (const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1284,5 +1498,5 @@\n-        xmlReadMemory        (const char *buffer,\n-                     int size,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReadMemory           (const char *buffer,\n+                                         int size,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1290,4 +1504,4 @@\n-        xmlReadFd        (int fd,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReadFd               (int fd,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1295,6 +1509,6 @@\n-        xmlReadIO        (xmlInputReadCallback ioread,\n-                     xmlInputCloseCallback ioclose,\n-                     void *ioctx,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReadIO               (xmlInputReadCallback ioread,\n+                                         xmlInputCloseCallback ioclose,\n+                                         void *ioctx,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1302,2 +1516,7 @@\n-        xmlCtxtParseDocument    (xmlParserCtxtPtr ctxt,\n-                     xmlParserInputPtr input);\n+                xmlCtxtParseDocument    (xmlParserCtxtPtr ctxt,\n+                                         xmlParserInputPtr input);\n+XMLPUBFUN xmlNodePtr\n+                xmlCtxtParseContent     (xmlParserCtxtPtr ctxt,\n+                                         xmlParserInputPtr input,\n+                                         xmlNodePtr node,\n+                                         int hasTextDecl);\n@@ -1305,5 +1524,5 @@\n-        xmlCtxtReadDoc        (xmlParserCtxtPtr ctxt,\n-                     const xmlChar *cur,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlCtxtReadDoc          (xmlParserCtxtPtr ctxt,\n+                                         const xmlChar *cur,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1311,4 +1530,4 @@\n-        xmlCtxtReadFile        (xmlParserCtxtPtr ctxt,\n-                     const char *filename,\n-                     const char *encoding,\n-                     int options);\n+                xmlCtxtReadFile         (xmlParserCtxtPtr ctxt,\n+                                         const char *filename,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1316,6 +1535,6 @@\n-        xmlCtxtReadMemory        (xmlParserCtxtPtr ctxt,\n-                     const char *buffer,\n-                     int size,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlCtxtReadMemory               (xmlParserCtxtPtr ctxt,\n+                                         const char *buffer,\n+                                         int size,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1323,5 +1542,5 @@\n-        xmlCtxtReadFd        (xmlParserCtxtPtr ctxt,\n-                     int fd,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlCtxtReadFd           (xmlParserCtxtPtr ctxt,\n+                                         int fd,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -1329,7 +1548,30 @@\n-        xmlCtxtReadIO        (xmlParserCtxtPtr ctxt,\n-                     xmlInputReadCallback ioread,\n-                     xmlInputCloseCallback ioclose,\n-                     void *ioctx,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlCtxtReadIO           (xmlParserCtxtPtr ctxt,\n+                                         xmlInputReadCallback ioread,\n+                                         xmlInputCloseCallback ioclose,\n+                                         void *ioctx,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n+\n+\/**\n+ * New input API\n+ *\/\n+\n+XMLPUBFUN xmlParserErrors\n+xmlNewInputFromUrl(const char *url, xmlParserInputFlags flags,\n+                   xmlParserInputPtr *out);\n+XMLPUBFUN xmlParserInputPtr\n+xmlNewInputFromMemory(const char *url, const void *mem, size_t size,\n+                      xmlParserInputFlags flags);\n+XMLPUBFUN xmlParserInputPtr\n+xmlNewInputFromString(const char *url, const char *str,\n+                      xmlParserInputFlags flags);\n+XMLPUBFUN xmlParserInputPtr\n+xmlNewInputFromFd(const char *url, int fd, xmlParserInputFlags flags);\n+XMLPUBFUN xmlParserInputPtr\n+xmlNewInputFromIO(const char *url, xmlInputReadCallback ioRead,\n+                  xmlInputCloseCallback ioClose, void *ioCtxt,\n+                  xmlParserInputFlags flags);\n+XMLPUBFUN xmlParserErrors\n+xmlInputSetEncodingHandler(xmlParserInputPtr input,\n+                           xmlCharEncodingHandlerPtr handler);\n@@ -1381,0 +1623,1 @@\n+    XML_WITH_RELAXNG = 34, \/* since 2.14.0 *\/\n@@ -1385,1 +1628,1 @@\n-        xmlHasFeature        (xmlFeature feature);\n+                xmlHasFeature           (xmlFeature feature);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/parser.h","additions":770,"deletions":527,"binary":false,"changes":1297,"status":"modified"},{"patch":"@@ -25,8 +25,2 @@\n-\/**\n- * xmlParserMaxDepth:\n- *\n- * DEPRECATED: has no effect\n- *\n- * arbitrary depth limit for the XML documents that we allow to\n- * process. This is not a limitation of the parser but a safety\n- * boundary feature, use XML_PARSE_HUGE option to override it.\n+\/*\n+ * Backward compatibility\n@@ -34,2 +28,3 @@\n-XML_DEPRECATED\n-XMLPUBVAR const unsigned int xmlParserMaxDepth;\n+#define inputPush xmlCtxtPushInput\n+#define inputPop xmlCtxtPopInput\n+#define xmlParserMaxDepth 256\n@@ -74,1 +69,1 @@\n-#define XML_MAX_DICTIONARY_LIMIT 10000000\n+#define XML_MAX_DICTIONARY_LIMIT 100000000\n@@ -94,8 +89,0 @@\n-\/**\n- * INPUT_CHUNK:\n- *\n- * The parser tries to always have that amount of input ready.\n- * One of the point is providing context when reporting errors.\n- *\/\n-#define INPUT_CHUNK    250\n-\n@@ -103,3 +90,3 @@\n- *                                    *\n- * UNICODE version of the macros.                    *\n- *                                    *\n+ *                                                                      *\n+ * UNICODE version of the macros.                                       *\n+ *                                                                      *\n@@ -116,1 +103,1 @@\n-#define IS_BYTE_CHAR(c)     xmlIsChar_ch(c)\n+#define IS_BYTE_CHAR(c)  xmlIsChar_ch(c)\n@@ -261,2 +248,2 @@\n-#define IS_ASCII_LETTER(c)    (((0x41 <= (c)) && ((c) <= 0x5a)) || \\\n-                 ((0x61 <= (c)) && ((c) <= 0x7a)))\n+#define IS_ASCII_LETTER(c)      ((0x61 <= ((c) | 0x20)) && \\\n+                                 (((c) | 0x20) <= 0x7a))\n@@ -271,1 +258,1 @@\n-#define IS_ASCII_DIGIT(c)    ((0x30 <= (c)) && ((c) <= 0x39))\n+#define IS_ASCII_DIGIT(c)       ((0x30 <= (c)) && ((c) <= 0x39))\n@@ -282,1 +269,1 @@\n-#define IS_PUBIDCHAR(c)    xmlIsPubidCharQ(c)\n+#define IS_PUBIDCHAR(c) xmlIsPubidCharQ(c)\n@@ -297,0 +284,1 @@\n+XML_DEPRECATED\n@@ -299,3 +287,1 @@\n-\/*\n- * Function to finish the work of the macros where needed.\n- *\/\n+XML_DEPRECATED\n@@ -308,1 +294,1 @@\n-            xmlCreateFileParserCtxt    (const char *filename);\n+                        xmlCreateFileParserCtxt (const char *filename);\n@@ -310,2 +296,2 @@\n-            xmlCreateURLParserCtxt    (const char *filename,\n-                         int options);\n+                        xmlCreateURLParserCtxt  (const char *filename,\n+                                                 int options);\n@@ -313,2 +299,3 @@\n-            xmlCreateMemoryParserCtxt(const char *buffer,\n-                         int size);\n+                        xmlCreateMemoryParserCtxt(const char *buffer,\n+                                                 int size);\n+XML_DEPRECATED\n@@ -316,3 +303,3 @@\n-            xmlCreateEntityParserCtxt(const xmlChar *URL,\n-                         const xmlChar *ID,\n-                         const xmlChar *base);\n+                        xmlCreateEntityParserCtxt(const xmlChar *URL,\n+                                                 const xmlChar *ID,\n+                                                 const xmlChar *base);\n@@ -320,1 +307,1 @@\n-            xmlCtxtErrMemory    (xmlParserCtxtPtr ctxt);\n+                        xmlCtxtErrMemory        (xmlParserCtxtPtr ctxt);\n@@ -322,2 +309,2 @@\n-            xmlSwitchEncoding    (xmlParserCtxtPtr ctxt,\n-                         xmlCharEncoding enc);\n+                        xmlSwitchEncoding       (xmlParserCtxtPtr ctxt,\n+                                                 xmlCharEncoding enc);\n@@ -325,2 +312,2 @@\n-            xmlSwitchEncodingName    (xmlParserCtxtPtr ctxt,\n-                         const char *encoding);\n+                        xmlSwitchEncodingName   (xmlParserCtxtPtr ctxt,\n+                                                 const char *encoding);\n@@ -328,2 +315,2 @@\n-            xmlSwitchToEncoding    (xmlParserCtxtPtr ctxt,\n-                     xmlCharEncodingHandlerPtr handler);\n+                        xmlSwitchToEncoding     (xmlParserCtxtPtr ctxt,\n+                                         xmlCharEncodingHandlerPtr handler);\n@@ -332,3 +319,3 @@\n-            xmlSwitchInputEncoding    (xmlParserCtxtPtr ctxt,\n-                         xmlParserInputPtr input,\n-                     xmlCharEncodingHandlerPtr handler);\n+                        xmlSwitchInputEncoding  (xmlParserCtxtPtr ctxt,\n+                                                 xmlParserInputPtr input,\n+                                         xmlCharEncodingHandlerPtr handler);\n@@ -340,2 +327,2 @@\n-            xmlNewStringInputStream    (xmlParserCtxtPtr ctxt,\n-                         const xmlChar *buffer);\n+                        xmlNewStringInputStream (xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *buffer);\n@@ -344,2 +331,2 @@\n-            xmlNewEntityInputStream    (xmlParserCtxtPtr ctxt,\n-                         xmlEntityPtr entity);\n+                        xmlNewEntityInputStream (xmlParserCtxtPtr ctxt,\n+                                                 xmlEntityPtr entity);\n@@ -347,2 +334,9 @@\n-            xmlPushInput        (xmlParserCtxtPtr ctxt,\n-                         xmlParserInputPtr input);\n+                        xmlCtxtPushInput        (xmlParserCtxtPtr ctxt,\n+                                                 xmlParserInputPtr input);\n+XMLPUBFUN xmlParserInputPtr\n+                        xmlCtxtPopInput         (xmlParserCtxtPtr ctxt);\n+XML_DEPRECATED\n+XMLPUBFUN int\n+                        xmlPushInput            (xmlParserCtxtPtr ctxt,\n+                                                 xmlParserInputPtr input);\n+XML_DEPRECATED\n@@ -350,1 +344,1 @@\n-            xmlPopInput        (xmlParserCtxtPtr ctxt);\n+                        xmlPopInput             (xmlParserCtxtPtr ctxt);\n@@ -352,1 +346,1 @@\n-            xmlFreeInputStream    (xmlParserInputPtr input);\n+                        xmlFreeInputStream      (xmlParserInputPtr input);\n@@ -354,2 +348,2 @@\n-            xmlNewInputFromFile    (xmlParserCtxtPtr ctxt,\n-                         const char *filename);\n+                        xmlNewInputFromFile     (xmlParserCtxtPtr ctxt,\n+                                                 const char *filename);\n@@ -357,1 +351,1 @@\n-            xmlNewInputStream    (xmlParserCtxtPtr ctxt);\n+                        xmlNewInputStream       (xmlParserCtxtPtr ctxt);\n@@ -363,3 +357,3 @@\n-            xmlSplitQName        (xmlParserCtxtPtr ctxt,\n-                         const xmlChar *name,\n-                         xmlChar **prefix);\n+                        xmlSplitQName           (xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 xmlChar **prefix);\n@@ -372,1 +366,1 @@\n-            xmlParseName        (xmlParserCtxtPtr ctxt);\n+                        xmlParseName            (xmlParserCtxtPtr ctxt);\n@@ -375,1 +369,1 @@\n-            xmlParseNmtoken        (xmlParserCtxtPtr ctxt);\n+                        xmlParseNmtoken         (xmlParserCtxtPtr ctxt);\n@@ -378,2 +372,2 @@\n-            xmlParseEntityValue    (xmlParserCtxtPtr ctxt,\n-                         xmlChar **orig);\n+                        xmlParseEntityValue     (xmlParserCtxtPtr ctxt,\n+                                                 xmlChar **orig);\n@@ -382,1 +376,1 @@\n-            xmlParseAttValue    (xmlParserCtxtPtr ctxt);\n+                        xmlParseAttValue        (xmlParserCtxtPtr ctxt);\n@@ -385,1 +379,1 @@\n-            xmlParseSystemLiteral    (xmlParserCtxtPtr ctxt);\n+                        xmlParseSystemLiteral   (xmlParserCtxtPtr ctxt);\n@@ -388,1 +382,1 @@\n-            xmlParsePubidLiteral    (xmlParserCtxtPtr ctxt);\n+                        xmlParsePubidLiteral    (xmlParserCtxtPtr ctxt);\n@@ -391,2 +385,2 @@\n-            xmlParseCharData    (xmlParserCtxtPtr ctxt,\n-                         int cdata);\n+                        xmlParseCharData        (xmlParserCtxtPtr ctxt,\n+                                                 int cdata);\n@@ -395,3 +389,3 @@\n-            xmlParseExternalID    (xmlParserCtxtPtr ctxt,\n-                         xmlChar **publicID,\n-                         int strict);\n+                        xmlParseExternalID      (xmlParserCtxtPtr ctxt,\n+                                                 xmlChar **publicID,\n+                                                 int strict);\n@@ -400,1 +394,1 @@\n-            xmlParseComment        (xmlParserCtxtPtr ctxt);\n+                        xmlParseComment         (xmlParserCtxtPtr ctxt);\n@@ -403,1 +397,1 @@\n-            xmlParsePITarget    (xmlParserCtxtPtr ctxt);\n+                        xmlParsePITarget        (xmlParserCtxtPtr ctxt);\n@@ -406,1 +400,1 @@\n-            xmlParsePI        (xmlParserCtxtPtr ctxt);\n+                        xmlParsePI              (xmlParserCtxtPtr ctxt);\n@@ -409,1 +403,1 @@\n-            xmlParseNotationDecl    (xmlParserCtxtPtr ctxt);\n+                        xmlParseNotationDecl    (xmlParserCtxtPtr ctxt);\n@@ -412,1 +406,1 @@\n-            xmlParseEntityDecl    (xmlParserCtxtPtr ctxt);\n+                        xmlParseEntityDecl      (xmlParserCtxtPtr ctxt);\n@@ -415,2 +409,2 @@\n-            xmlParseDefaultDecl    (xmlParserCtxtPtr ctxt,\n-                         xmlChar **value);\n+                        xmlParseDefaultDecl     (xmlParserCtxtPtr ctxt,\n+                                                 xmlChar **value);\n@@ -419,1 +413,1 @@\n-            xmlParseNotationType    (xmlParserCtxtPtr ctxt);\n+                        xmlParseNotationType    (xmlParserCtxtPtr ctxt);\n@@ -422,1 +416,1 @@\n-            xmlParseEnumerationType    (xmlParserCtxtPtr ctxt);\n+                        xmlParseEnumerationType (xmlParserCtxtPtr ctxt);\n@@ -425,2 +419,2 @@\n-            xmlParseEnumeratedType    (xmlParserCtxtPtr ctxt,\n-                         xmlEnumerationPtr *tree);\n+                        xmlParseEnumeratedType  (xmlParserCtxtPtr ctxt,\n+                                                 xmlEnumerationPtr *tree);\n@@ -429,2 +423,2 @@\n-            xmlParseAttributeType    (xmlParserCtxtPtr ctxt,\n-                         xmlEnumerationPtr *tree);\n+                        xmlParseAttributeType   (xmlParserCtxtPtr ctxt,\n+                                                 xmlEnumerationPtr *tree);\n@@ -433,1 +427,1 @@\n-            xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt);\n+                        xmlParseAttributeListDecl(xmlParserCtxtPtr ctxt);\n@@ -436,3 +430,3 @@\n-            xmlParseElementMixedContentDecl\n-                        (xmlParserCtxtPtr ctxt,\n-                         int inputchk);\n+                        xmlParseElementMixedContentDecl\n+                                                (xmlParserCtxtPtr ctxt,\n+                                                 int inputchk);\n@@ -441,3 +435,3 @@\n-            xmlParseElementChildrenContentDecl\n-                        (xmlParserCtxtPtr ctxt,\n-                         int inputchk);\n+                        xmlParseElementChildrenContentDecl\n+                                                (xmlParserCtxtPtr ctxt,\n+                                                 int inputchk);\n@@ -446,3 +440,3 @@\n-            xmlParseElementContentDecl(xmlParserCtxtPtr ctxt,\n-                         const xmlChar *name,\n-                         xmlElementContentPtr *result);\n+                        xmlParseElementContentDecl(xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 xmlElementContentPtr *result);\n@@ -451,1 +445,1 @@\n-            xmlParseElementDecl    (xmlParserCtxtPtr ctxt);\n+                        xmlParseElementDecl     (xmlParserCtxtPtr ctxt);\n@@ -454,1 +448,1 @@\n-            xmlParseMarkupDecl    (xmlParserCtxtPtr ctxt);\n+                        xmlParseMarkupDecl      (xmlParserCtxtPtr ctxt);\n@@ -457,1 +451,1 @@\n-            xmlParseCharRef        (xmlParserCtxtPtr ctxt);\n+                        xmlParseCharRef         (xmlParserCtxtPtr ctxt);\n@@ -460,1 +454,1 @@\n-            xmlParseEntityRef    (xmlParserCtxtPtr ctxt);\n+                        xmlParseEntityRef       (xmlParserCtxtPtr ctxt);\n@@ -463,1 +457,1 @@\n-            xmlParseReference    (xmlParserCtxtPtr ctxt);\n+                        xmlParseReference       (xmlParserCtxtPtr ctxt);\n@@ -466,1 +460,1 @@\n-            xmlParsePEReference    (xmlParserCtxtPtr ctxt);\n+                        xmlParsePEReference     (xmlParserCtxtPtr ctxt);\n@@ -469,1 +463,1 @@\n-            xmlParseDocTypeDecl    (xmlParserCtxtPtr ctxt);\n+                        xmlParseDocTypeDecl     (xmlParserCtxtPtr ctxt);\n@@ -473,2 +467,2 @@\n-            xmlParseAttribute    (xmlParserCtxtPtr ctxt,\n-                         xmlChar **value);\n+                        xmlParseAttribute       (xmlParserCtxtPtr ctxt,\n+                                                 xmlChar **value);\n@@ -477,1 +471,1 @@\n-            xmlParseStartTag    (xmlParserCtxtPtr ctxt);\n+                        xmlParseStartTag        (xmlParserCtxtPtr ctxt);\n@@ -480,1 +474,1 @@\n-            xmlParseEndTag        (xmlParserCtxtPtr ctxt);\n+                        xmlParseEndTag          (xmlParserCtxtPtr ctxt);\n@@ -484,1 +478,1 @@\n-            xmlParseCDSect        (xmlParserCtxtPtr ctxt);\n+                        xmlParseCDSect          (xmlParserCtxtPtr ctxt);\n@@ -486,1 +480,1 @@\n-            xmlParseContent        (xmlParserCtxtPtr ctxt);\n+                        xmlParseContent         (xmlParserCtxtPtr ctxt);\n@@ -489,1 +483,1 @@\n-            xmlParseElement        (xmlParserCtxtPtr ctxt);\n+                        xmlParseElement         (xmlParserCtxtPtr ctxt);\n@@ -492,1 +486,1 @@\n-            xmlParseVersionNum    (xmlParserCtxtPtr ctxt);\n+                        xmlParseVersionNum      (xmlParserCtxtPtr ctxt);\n@@ -495,1 +489,1 @@\n-            xmlParseVersionInfo    (xmlParserCtxtPtr ctxt);\n+                        xmlParseVersionInfo     (xmlParserCtxtPtr ctxt);\n@@ -498,1 +492,1 @@\n-            xmlParseEncName        (xmlParserCtxtPtr ctxt);\n+                        xmlParseEncName         (xmlParserCtxtPtr ctxt);\n@@ -501,1 +495,1 @@\n-            xmlParseEncodingDecl    (xmlParserCtxtPtr ctxt);\n+                        xmlParseEncodingDecl    (xmlParserCtxtPtr ctxt);\n@@ -504,1 +498,1 @@\n-            xmlParseSDDecl        (xmlParserCtxtPtr ctxt);\n+                        xmlParseSDDecl          (xmlParserCtxtPtr ctxt);\n@@ -507,1 +501,1 @@\n-            xmlParseXMLDecl        (xmlParserCtxtPtr ctxt);\n+                        xmlParseXMLDecl         (xmlParserCtxtPtr ctxt);\n@@ -510,1 +504,1 @@\n-            xmlParseTextDecl    (xmlParserCtxtPtr ctxt);\n+                        xmlParseTextDecl        (xmlParserCtxtPtr ctxt);\n@@ -513,1 +507,2 @@\n-            xmlParseMisc        (xmlParserCtxtPtr ctxt);\n+                        xmlParseMisc            (xmlParserCtxtPtr ctxt);\n+XML_DEPRECATED\n@@ -515,3 +510,3 @@\n-            xmlParseExternalSubset    (xmlParserCtxtPtr ctxt,\n-                         const xmlChar *ExternalID,\n-                         const xmlChar *SystemID);\n+                        xmlParseExternalSubset  (xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *ExternalID,\n+                                                 const xmlChar *SystemID);\n@@ -523,1 +518,1 @@\n-#define XML_SUBSTITUTE_NONE    0\n+#define XML_SUBSTITUTE_NONE     0\n@@ -529,1 +524,1 @@\n-#define XML_SUBSTITUTE_REF    1\n+#define XML_SUBSTITUTE_REF      1\n@@ -541,1 +536,1 @@\n-#define XML_SUBSTITUTE_BOTH    3\n+#define XML_SUBSTITUTE_BOTH     3\n@@ -545,6 +540,6 @@\n-        xmlStringDecodeEntities        (xmlParserCtxtPtr ctxt,\n-                         const xmlChar *str,\n-                         int what,\n-                         xmlChar end,\n-                         xmlChar  end2,\n-                         xmlChar end3);\n+                xmlStringDecodeEntities         (xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *str,\n+                                                 int what,\n+                                                 xmlChar end,\n+                                                 xmlChar  end2,\n+                                                 xmlChar end3);\n@@ -553,24 +548,7 @@\n-        xmlStringLenDecodeEntities    (xmlParserCtxtPtr ctxt,\n-                         const xmlChar *str,\n-                         int len,\n-                         int what,\n-                         xmlChar end,\n-                         xmlChar  end2,\n-                         xmlChar end3);\n-\n-\/*\n- * Generated by MACROS on top of parser.c c.f. PUSH_AND_POP.\n- *\/\n-XML_DEPRECATED\n-XMLPUBFUN int            nodePush        (xmlParserCtxtPtr ctxt,\n-                         xmlNodePtr value);\n-XML_DEPRECATED\n-XMLPUBFUN xmlNodePtr        nodePop            (xmlParserCtxtPtr ctxt);\n-XMLPUBFUN int            inputPush        (xmlParserCtxtPtr ctxt,\n-                         xmlParserInputPtr value);\n-XMLPUBFUN xmlParserInputPtr    inputPop        (xmlParserCtxtPtr ctxt);\n-XML_DEPRECATED\n-XMLPUBFUN const xmlChar *    namePop            (xmlParserCtxtPtr ctxt);\n-XML_DEPRECATED\n-XMLPUBFUN int            namePush        (xmlParserCtxtPtr ctxt,\n-                         const xmlChar *value);\n+                xmlStringLenDecodeEntities      (xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *str,\n+                                                 int len,\n+                                                 int what,\n+                                                 xmlChar end,\n+                                                 xmlChar  end2,\n+                                                 xmlChar end3);\n@@ -582,1 +560,1 @@\n-XMLPUBFUN int            xmlSkipBlankChars    (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN int                   xmlSkipBlankChars       (xmlParserCtxtPtr ctxt);\n@@ -584,3 +562,3 @@\n-XMLPUBFUN int            xmlStringCurrentChar    (xmlParserCtxtPtr ctxt,\n-                         const xmlChar *cur,\n-                         int *len);\n+XMLPUBFUN int                   xmlStringCurrentChar    (xmlParserCtxtPtr ctxt,\n+                                                 const xmlChar *cur,\n+                                                 int *len);\n@@ -588,1 +566,1 @@\n-XMLPUBFUN void            xmlParserHandlePEReference(xmlParserCtxtPtr ctxt);\n+XMLPUBFUN void                  xmlParserHandlePEReference(xmlParserCtxtPtr ctxt);\n@@ -590,1 +568,1 @@\n-XMLPUBFUN int            xmlCheckLanguageID    (const xmlChar *lang);\n+XMLPUBFUN int                   xmlCheckLanguageID      (const xmlChar *lang);\n@@ -596,7 +574,2 @@\n-XMLPUBFUN int            xmlCurrentChar        (xmlParserCtxtPtr ctxt,\n-                         int *len);\n-XMLPUBFUN int        xmlCopyCharMultiByte    (xmlChar *out,\n-                         int val);\n-XMLPUBFUN int            xmlCopyChar        (int len,\n-                         xmlChar *out,\n-                         int val);\n+XMLPUBFUN int                   xmlCurrentChar          (xmlParserCtxtPtr ctxt,\n+                                                 int *len);\n@@ -604,1 +577,2 @@\n-XMLPUBFUN void            xmlNextChar        (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN int           xmlCopyCharMultiByte    (xmlChar *out,\n+                                                 int val);\n@@ -606,35 +580,3 @@\n-XMLPUBFUN void            xmlParserInputShrink    (xmlParserInputPtr in);\n-\n-\/*\n- * Specific function to keep track of entities references\n- * and used by the XSLT debugger.\n- *\/\n-#ifdef LIBXML_LEGACY_ENABLED\n-\/**\n- * xmlEntityReferenceFunc:\n- * @ent: the entity\n- * @firstNode:  the fist node in the chunk\n- * @lastNode:  the last nod in the chunk\n- *\n- * Callback function used when one needs to be able to track back the\n- * provenance of a chunk of nodes inherited from an entity replacement.\n- *\/\n-typedef    void    (*xmlEntityReferenceFunc)    (xmlEntityPtr ent,\n-                         xmlNodePtr firstNode,\n-                         xmlNodePtr lastNode);\n-\n-XML_DEPRECATED\n-XMLPUBFUN void        xmlSetEntityReferenceFunc    (xmlEntityReferenceFunc func);\n-\n-XML_DEPRECATED\n-XMLPUBFUN xmlChar *\n-            xmlParseQuotedString    (xmlParserCtxtPtr ctxt);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-                        xmlParseNamespace       (xmlParserCtxtPtr ctxt);\n-XML_DEPRECATED\n-XMLPUBFUN xmlChar *\n-            xmlNamespaceParseNSDef    (xmlParserCtxtPtr ctxt);\n-XML_DEPRECATED\n-XMLPUBFUN xmlChar *\n-            xmlScanName        (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN int                   xmlCopyChar             (int len,\n+                                                 xmlChar *out,\n+                                                 int val);\n@@ -642,2 +584,1 @@\n-XMLPUBFUN xmlChar *\n-            xmlNamespaceParseNCName    (xmlParserCtxtPtr ctxt);\n+XMLPUBFUN void                  xmlNextChar             (xmlParserCtxtPtr ctxt);\n@@ -645,22 +586,1 @@\n-XMLPUBFUN void    xmlParserHandleReference(xmlParserCtxtPtr ctxt);\n-XML_DEPRECATED\n-XMLPUBFUN xmlChar *\n-            xmlNamespaceParseQName    (xmlParserCtxtPtr ctxt,\n-                         xmlChar **prefix);\n-\/**\n- * Entities\n- *\/\n-XML_DEPRECATED\n-XMLPUBFUN xmlChar *\n-        xmlDecodeEntities        (xmlParserCtxtPtr ctxt,\n-                         int len,\n-                         int what,\n-                         xmlChar end,\n-                         xmlChar  end2,\n-                         xmlChar end3);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-            xmlHandleEntity        (xmlParserCtxtPtr ctxt,\n-                         xmlEntityPtr entity);\n-\n-#endif \/* LIBXML_LEGACY_ENABLED *\/\n+XMLPUBFUN void                  xmlParserInputShrink    (xmlParserInputPtr in);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/parserInternals.h","additions":148,"deletions":228,"binary":false,"changes":376,"status":"modified"},{"patch":"@@ -40,4 +40,4 @@\n-    XML_PATTERN_DEFAULT        = 0,    \/* simple pattern match *\/\n-    XML_PATTERN_XPATH        = 1<<0,    \/* standard XPath pattern *\/\n-    XML_PATTERN_XSSEL        = 1<<1,    \/* XPath subset for schema selector *\/\n-    XML_PATTERN_XSFIELD        = 1<<2    \/* XPath subset for schema field *\/\n+    XML_PATTERN_DEFAULT         = 0,    \/* simple pattern match *\/\n+    XML_PATTERN_XPATH           = 1<<0, \/* standard XPath pattern *\/\n+    XML_PATTERN_XSSEL           = 1<<1, \/* XPath subset for schema selector *\/\n+    XML_PATTERN_XSFIELD         = 1<<2  \/* XPath subset for schema field *\/\n@@ -47,1 +47,1 @@\n-            xmlFreePattern        (xmlPatternPtr comp);\n+                        xmlFreePattern          (xmlPatternPtr comp);\n@@ -50,1 +50,1 @@\n-            xmlFreePatternList    (xmlPatternPtr comp);\n+                        xmlFreePatternList      (xmlPatternPtr comp);\n@@ -53,4 +53,4 @@\n-            xmlPatterncompile    (const xmlChar *pattern,\n-                         xmlDict *dict,\n-                         int flags,\n-                         const xmlChar **namespaces);\n+                        xmlPatterncompile       (const xmlChar *pattern,\n+                                                 xmlDict *dict,\n+                                                 int flags,\n+                                                 const xmlChar **namespaces);\n@@ -58,5 +58,5 @@\n-            xmlPatternCompileSafe    (const xmlChar *pattern,\n-                         xmlDict *dict,\n-                         int flags,\n-                         const xmlChar **namespaces,\n-                         xmlPatternPtr *patternOut);\n+                        xmlPatternCompileSafe   (const xmlChar *pattern,\n+                                                 xmlDict *dict,\n+                                                 int flags,\n+                                                 const xmlChar **namespaces,\n+                                                 xmlPatternPtr *patternOut);\n@@ -64,2 +64,2 @@\n-            xmlPatternMatch        (xmlPatternPtr comp,\n-                         xmlNodePtr node);\n+                        xmlPatternMatch         (xmlPatternPtr comp,\n+                                                 xmlNodePtr node);\n@@ -72,1 +72,1 @@\n-            xmlPatternStreamable    (xmlPatternPtr comp);\n+                        xmlPatternStreamable    (xmlPatternPtr comp);\n@@ -74,1 +74,1 @@\n-            xmlPatternMaxDepth    (xmlPatternPtr comp);\n+                        xmlPatternMaxDepth      (xmlPatternPtr comp);\n@@ -76,1 +76,1 @@\n-            xmlPatternMinDepth    (xmlPatternPtr comp);\n+                        xmlPatternMinDepth      (xmlPatternPtr comp);\n@@ -78,1 +78,1 @@\n-            xmlPatternFromRoot    (xmlPatternPtr comp);\n+                        xmlPatternFromRoot      (xmlPatternPtr comp);\n@@ -80,1 +80,1 @@\n-            xmlPatternGetStreamCtxt    (xmlPatternPtr comp);\n+                        xmlPatternGetStreamCtxt (xmlPatternPtr comp);\n@@ -82,1 +82,1 @@\n-            xmlFreeStreamCtxt    (xmlStreamCtxtPtr stream);\n+                        xmlFreeStreamCtxt       (xmlStreamCtxtPtr stream);\n@@ -84,4 +84,4 @@\n-            xmlStreamPushNode    (xmlStreamCtxtPtr stream,\n-                         const xmlChar *name,\n-                         const xmlChar *ns,\n-                         int nodeType);\n+                        xmlStreamPushNode       (xmlStreamCtxtPtr stream,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns,\n+                                                 int nodeType);\n@@ -89,3 +89,3 @@\n-            xmlStreamPush        (xmlStreamCtxtPtr stream,\n-                         const xmlChar *name,\n-                         const xmlChar *ns);\n+                        xmlStreamPush           (xmlStreamCtxtPtr stream,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns);\n@@ -93,3 +93,3 @@\n-            xmlStreamPushAttr    (xmlStreamCtxtPtr stream,\n-                         const xmlChar *name,\n-                         const xmlChar *ns);\n+                        xmlStreamPushAttr       (xmlStreamCtxtPtr stream,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns);\n@@ -97,1 +97,1 @@\n-            xmlStreamPop        (xmlStreamCtxtPtr stream);\n+                        xmlStreamPop            (xmlStreamCtxtPtr stream);\n@@ -99,1 +99,1 @@\n-            xmlStreamWantsAnyNode    (xmlStreamCtxtPtr stream);\n+                        xmlStreamWantsAnyNode   (xmlStreamCtxtPtr stream);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/pattern.h","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -17,0 +17,1 @@\n+#include <libxml\/parser.h>\n@@ -18,1 +19,1 @@\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -37,2 +38,2 @@\n-                              const char *msg,\n-                              ...) LIBXML_ATTR_FORMAT(2,3);\n+                                                      const char *msg,\n+                                                      ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -49,2 +50,2 @@\n-                            const char *msg,\n-                            ...) LIBXML_ATTR_FORMAT(2,3);\n+                                                        const char *msg,\n+                                                        ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -121,1 +122,1 @@\n-            xmlRelaxNGInitTypes        (void);\n+                    xmlRelaxNGInitTypes         (void);\n@@ -124,1 +125,1 @@\n-            xmlRelaxNGCleanupTypes    (void);\n+                    xmlRelaxNGCleanupTypes      (void);\n@@ -130,1 +131,1 @@\n-            xmlRelaxNGNewParserCtxt    (const char *URL);\n+                    xmlRelaxNGNewParserCtxt     (const char *URL);\n@@ -132,2 +133,2 @@\n-            xmlRelaxNGNewMemParserCtxt    (const char *buffer,\n-                         int size);\n+                    xmlRelaxNGNewMemParserCtxt  (const char *buffer,\n+                                                 int size);\n@@ -135,1 +136,1 @@\n-            xmlRelaxNGNewDocParserCtxt    (xmlDocPtr doc);\n+                    xmlRelaxNGNewDocParserCtxt  (xmlDocPtr doc);\n@@ -138,2 +139,2 @@\n-            xmlRelaxParserSetFlag    (xmlRelaxNGParserCtxtPtr ctxt,\n-                         int flag);\n+                    xmlRelaxParserSetFlag       (xmlRelaxNGParserCtxtPtr ctxt,\n+                                                 int flag);\n@@ -142,1 +143,1 @@\n-            xmlRelaxNGFreeParserCtxt    (xmlRelaxNGParserCtxtPtr ctxt);\n+                    xmlRelaxNGFreeParserCtxt    (xmlRelaxNGParserCtxtPtr ctxt);\n@@ -144,4 +145,4 @@\n-            xmlRelaxNGSetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,\n-                     xmlRelaxNGValidityErrorFunc err,\n-                     xmlRelaxNGValidityWarningFunc warn,\n-                     void *ctx);\n+                    xmlRelaxNGSetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,\n+                                         xmlRelaxNGValidityErrorFunc err,\n+                                         xmlRelaxNGValidityWarningFunc warn,\n+                                         void *ctx);\n@@ -149,4 +150,4 @@\n-            xmlRelaxNGGetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,\n-                     xmlRelaxNGValidityErrorFunc *err,\n-                     xmlRelaxNGValidityWarningFunc *warn,\n-                     void **ctx);\n+                    xmlRelaxNGGetParserErrors(xmlRelaxNGParserCtxtPtr ctxt,\n+                                         xmlRelaxNGValidityErrorFunc *err,\n+                                         xmlRelaxNGValidityWarningFunc *warn,\n+                                         void **ctx);\n@@ -154,4 +155,8 @@\n-            xmlRelaxNGSetParserStructuredErrors(\n-                     xmlRelaxNGParserCtxtPtr ctxt,\n-                     xmlStructuredErrorFunc serror,\n-                     void *ctx);\n+                    xmlRelaxNGSetParserStructuredErrors(\n+                                         xmlRelaxNGParserCtxtPtr ctxt,\n+                                         xmlStructuredErrorFunc serror,\n+                                         void *ctx);\n+XMLPUBFUN void\n+                    xmlRelaxNGSetResourceLoader (xmlRelaxNGParserCtxtPtr ctxt,\n+                                                 xmlResourceLoader loader,\n+                                                 void *vctxt);\n@@ -159,1 +164,1 @@\n-            xmlRelaxNGParse        (xmlRelaxNGParserCtxtPtr ctxt);\n+                    xmlRelaxNGParse             (xmlRelaxNGParserCtxtPtr ctxt);\n@@ -161,1 +166,1 @@\n-            xmlRelaxNGFree        (xmlRelaxNGPtr schema);\n+                    xmlRelaxNGFree              (xmlRelaxNGPtr schema);\n@@ -164,2 +169,2 @@\n-            xmlRelaxNGDump        (FILE *output,\n-                     xmlRelaxNGPtr schema);\n+                    xmlRelaxNGDump              (FILE *output,\n+                                         xmlRelaxNGPtr schema);\n@@ -167,2 +172,2 @@\n-            xmlRelaxNGDumpTree    (FILE * output,\n-                     xmlRelaxNGPtr schema);\n+                    xmlRelaxNGDumpTree  (FILE * output,\n+                                         xmlRelaxNGPtr schema);\n@@ -174,4 +179,4 @@\n-            xmlRelaxNGSetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,\n-                     xmlRelaxNGValidityErrorFunc err,\n-                     xmlRelaxNGValidityWarningFunc warn,\n-                     void *ctx);\n+                    xmlRelaxNGSetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,\n+                                         xmlRelaxNGValidityErrorFunc err,\n+                                         xmlRelaxNGValidityWarningFunc warn,\n+                                         void *ctx);\n@@ -179,4 +184,4 @@\n-            xmlRelaxNGGetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,\n-                     xmlRelaxNGValidityErrorFunc *err,\n-                     xmlRelaxNGValidityWarningFunc *warn,\n-                     void **ctx);\n+                    xmlRelaxNGGetValidErrors(xmlRelaxNGValidCtxtPtr ctxt,\n+                                         xmlRelaxNGValidityErrorFunc *err,\n+                                         xmlRelaxNGValidityWarningFunc *warn,\n+                                         void **ctx);\n@@ -184,2 +189,2 @@\n-            xmlRelaxNGSetValidStructuredErrors(xmlRelaxNGValidCtxtPtr ctxt,\n-                      xmlStructuredErrorFunc serror, void *ctx);\n+                        xmlRelaxNGSetValidStructuredErrors(xmlRelaxNGValidCtxtPtr ctxt,\n+                                          xmlStructuredErrorFunc serror, void *ctx);\n@@ -187,1 +192,1 @@\n-            xmlRelaxNGNewValidCtxt    (xmlRelaxNGPtr schema);\n+                    xmlRelaxNGNewValidCtxt      (xmlRelaxNGPtr schema);\n@@ -189,1 +194,1 @@\n-            xmlRelaxNGFreeValidCtxt    (xmlRelaxNGValidCtxtPtr ctxt);\n+                    xmlRelaxNGFreeValidCtxt     (xmlRelaxNGValidCtxtPtr ctxt);\n@@ -191,2 +196,2 @@\n-            xmlRelaxNGValidateDoc    (xmlRelaxNGValidCtxtPtr ctxt,\n-                         xmlDocPtr doc);\n+                    xmlRelaxNGValidateDoc       (xmlRelaxNGValidCtxtPtr ctxt,\n+                                                 xmlDocPtr doc);\n@@ -197,3 +202,3 @@\n-            xmlRelaxNGValidatePushElement    (xmlRelaxNGValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem);\n+                    xmlRelaxNGValidatePushElement       (xmlRelaxNGValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem);\n@@ -201,3 +206,3 @@\n-            xmlRelaxNGValidatePushCData    (xmlRelaxNGValidCtxtPtr ctxt,\n-                     const xmlChar *data,\n-                     int len);\n+                    xmlRelaxNGValidatePushCData (xmlRelaxNGValidCtxtPtr ctxt,\n+                                         const xmlChar *data,\n+                                         int len);\n@@ -205,3 +210,3 @@\n-            xmlRelaxNGValidatePopElement    (xmlRelaxNGValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem);\n+                    xmlRelaxNGValidatePopElement        (xmlRelaxNGValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem);\n@@ -209,3 +214,3 @@\n-            xmlRelaxNGValidateFullElement    (xmlRelaxNGValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem);\n+                    xmlRelaxNGValidateFullElement       (xmlRelaxNGValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem);\n@@ -217,1 +222,1 @@\n-#endif \/* LIBXML_SCHEMAS_ENABLED *\/\n+#endif \/* LIBXML_RELAXNG_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/relaxng.h","additions":64,"deletions":59,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- *        The Schemas development is a Work In Progress.\n+ *              The Schemas development is a Work In Progress.\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/schemasInternals.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-    XML_SCHEMATRON_OUT_QUIET = 1 << 0,    \/* quiet no report *\/\n-    XML_SCHEMATRON_OUT_TEXT = 1 << 1,    \/* build a textual report *\/\n+    XML_SCHEMATRON_OUT_QUIET = 1 << 0,  \/* quiet no report *\/\n+    XML_SCHEMATRON_OUT_TEXT = 1 << 1,   \/* build a textual report *\/\n@@ -30,3 +30,3 @@\n-    XML_SCHEMATRON_OUT_FILE = 1 << 8,    \/* output to a file descriptor *\/\n-    XML_SCHEMATRON_OUT_BUFFER = 1 << 9,    \/* output to a buffer *\/\n-    XML_SCHEMATRON_OUT_IO = 1 << 10    \/* output to I\/O mechanism *\/\n+    XML_SCHEMATRON_OUT_FILE = 1 << 8,   \/* output to a file descriptor *\/\n+    XML_SCHEMATRON_OUT_BUFFER = 1 << 9, \/* output to a buffer *\/\n+    XML_SCHEMATRON_OUT_IO = 1 << 10     \/* output to I\/O mechanism *\/\n@@ -74,1 +74,1 @@\n-        xmlSchematronNewParserCtxt    (const char *URL);\n+            xmlSchematronNewParserCtxt  (const char *URL);\n@@ -76,2 +76,2 @@\n-        xmlSchematronNewMemParserCtxt(const char *buffer,\n-                     int size);\n+            xmlSchematronNewMemParserCtxt(const char *buffer,\n+                                         int size);\n@@ -79,1 +79,1 @@\n-        xmlSchematronNewDocParserCtxt(xmlDocPtr doc);\n+            xmlSchematronNewDocParserCtxt(xmlDocPtr doc);\n@@ -81,1 +81,1 @@\n-        xmlSchematronFreeParserCtxt    (xmlSchematronParserCtxtPtr ctxt);\n+            xmlSchematronFreeParserCtxt (xmlSchematronParserCtxtPtr ctxt);\n@@ -84,4 +84,4 @@\n-        xmlSchematronSetParserErrors(xmlSchematronParserCtxtPtr ctxt,\n-                     xmlSchematronValidityErrorFunc err,\n-                     xmlSchematronValidityWarningFunc warn,\n-                     void *ctx);\n+            xmlSchematronSetParserErrors(xmlSchematronParserCtxtPtr ctxt,\n+                                         xmlSchematronValidityErrorFunc err,\n+                                         xmlSchematronValidityWarningFunc warn,\n+                                         void *ctx);\n@@ -89,4 +89,4 @@\n-        xmlSchematronGetParserErrors(xmlSchematronParserCtxtPtr ctxt,\n-                    xmlSchematronValidityErrorFunc * err,\n-                    xmlSchematronValidityWarningFunc * warn,\n-                    void **ctx);\n+                xmlSchematronGetParserErrors(xmlSchematronParserCtxtPtr ctxt,\n+                                        xmlSchematronValidityErrorFunc * err,\n+                                        xmlSchematronValidityWarningFunc * warn,\n+                                        void **ctx);\n@@ -94,1 +94,1 @@\n-        xmlSchematronIsValid    (xmlSchematronValidCtxtPtr ctxt);\n+                xmlSchematronIsValid    (xmlSchematronValidCtxtPtr ctxt);\n@@ -97,1 +97,1 @@\n-        xmlSchematronParse        (xmlSchematronParserCtxtPtr ctxt);\n+            xmlSchematronParse          (xmlSchematronParserCtxtPtr ctxt);\n@@ -99,1 +99,1 @@\n-        xmlSchematronFree        (xmlSchematronPtr schema);\n+            xmlSchematronFree           (xmlSchematronPtr schema);\n@@ -104,4 +104,4 @@\n-        xmlSchematronSetValidStructuredErrors(\n-                                      xmlSchematronValidCtxtPtr ctxt,\n-                      xmlStructuredErrorFunc serror,\n-                      void *ctx);\n+            xmlSchematronSetValidStructuredErrors(\n+                                          xmlSchematronValidCtxtPtr ctxt,\n+                                          xmlStructuredErrorFunc serror,\n+                                          void *ctx);\n@@ -110,4 +110,4 @@\n-        xmlSchematronSetValidErrors    (xmlSchematronValidCtxtPtr ctxt,\n-                     xmlSchematronValidityErrorFunc err,\n-                     xmlSchematronValidityWarningFunc warn,\n-                     void *ctx);\n+            xmlSchematronSetValidErrors (xmlSchematronValidCtxtPtr ctxt,\n+                                         xmlSchematronValidityErrorFunc err,\n+                                         xmlSchematronValidityWarningFunc warn,\n+                                         void *ctx);\n@@ -115,4 +115,4 @@\n-        xmlSchematronGetValidErrors    (xmlSchematronValidCtxtPtr ctxt,\n-                     xmlSchematronValidityErrorFunc *err,\n-                     xmlSchematronValidityWarningFunc *warn,\n-                     void **ctx);\n+            xmlSchematronGetValidErrors (xmlSchematronValidCtxtPtr ctxt,\n+                                         xmlSchematronValidityErrorFunc *err,\n+                                         xmlSchematronValidityWarningFunc *warn,\n+                                         void **ctx);\n@@ -120,2 +120,2 @@\n-        xmlSchematronSetValidOptions(xmlSchematronValidCtxtPtr ctxt,\n-                     int options);\n+            xmlSchematronSetValidOptions(xmlSchematronValidCtxtPtr ctxt,\n+                                         int options);\n@@ -123,1 +123,1 @@\n-        xmlSchematronValidCtxtGetOptions(xmlSchematronValidCtxtPtr ctxt);\n+            xmlSchematronValidCtxtGetOptions(xmlSchematronValidCtxtPtr ctxt);\n@@ -126,1 +126,1 @@\n-                             xmlNodePtr elem);\n+                                         xmlNodePtr elem);\n@@ -130,2 +130,2 @@\n-        xmlSchematronNewValidCtxt    (xmlSchematronPtr schema,\n-                     int options);\n+            xmlSchematronNewValidCtxt   (xmlSchematronPtr schema,\n+                                         int options);\n@@ -133,1 +133,1 @@\n-        xmlSchematronFreeValidCtxt    (xmlSchematronValidCtxtPtr ctxt);\n+            xmlSchematronFreeValidCtxt  (xmlSchematronValidCtxtPtr ctxt);\n@@ -135,2 +135,2 @@\n-        xmlSchematronValidateDoc    (xmlSchematronValidCtxtPtr ctxt,\n-                     xmlDocPtr instance);\n+            xmlSchematronValidateDoc    (xmlSchematronValidCtxtPtr ctxt,\n+                                         xmlDocPtr instance);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/schematron.h","additions":42,"deletions":42,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-            xmlCheckThreadLocalStorage(void);\n+                        xmlCheckThreadLocalStorage(void);\n@@ -36,1 +36,1 @@\n-            xmlNewMutex    (void);\n+                        xmlNewMutex     (void);\n@@ -38,1 +38,1 @@\n-            xmlMutexLock    (xmlMutexPtr tok);\n+                        xmlMutexLock    (xmlMutexPtr tok);\n@@ -40,1 +40,1 @@\n-            xmlMutexUnlock    (xmlMutexPtr tok);\n+                        xmlMutexUnlock  (xmlMutexPtr tok);\n@@ -42,1 +42,1 @@\n-            xmlFreeMutex    (xmlMutexPtr tok);\n+                        xmlFreeMutex    (xmlMutexPtr tok);\n@@ -45,1 +45,1 @@\n-            xmlNewRMutex    (void);\n+                        xmlNewRMutex    (void);\n@@ -47,1 +47,1 @@\n-            xmlRMutexLock    (xmlRMutexPtr tok);\n+                        xmlRMutexLock   (xmlRMutexPtr tok);\n@@ -49,1 +49,1 @@\n-            xmlRMutexUnlock    (xmlRMutexPtr tok);\n+                        xmlRMutexUnlock (xmlRMutexPtr tok);\n@@ -51,1 +51,1 @@\n-            xmlFreeRMutex    (xmlRMutexPtr tok);\n+                        xmlFreeRMutex   (xmlRMutexPtr tok);\n@@ -58,1 +58,1 @@\n-            xmlInitThreads    (void);\n+                        xmlInitThreads  (void);\n@@ -60,1 +60,1 @@\n-            xmlLockLibrary    (void);\n+                        xmlLockLibrary  (void);\n@@ -62,7 +62,1 @@\n-            xmlUnlockLibrary(void);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-            xmlGetThreadId    (void);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-            xmlIsMainThread    (void);\n+                        xmlUnlockLibrary(void);\n@@ -71,1 +65,1 @@\n-            xmlCleanupThreads(void);\n+                        xmlCleanupThreads(void);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/threads.h","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -35,0 +35,6 @@\n+\/*\n+ * Backward compatibility\n+ *\/\n+#define xmlBufferAllocScheme XML_BUFFER_ALLOC_EXACT\n+#define xmlDefaultBufferSize 4096\n+\n@@ -62,7 +68,0 @@\n-\/**\n- * BASE_BUFFER_SIZE:\n- *\n- * default buffer size 4000.\n- *\/\n-#define BASE_BUFFER_SIZE 4096\n-\n@@ -86,2 +85,2 @@\n-    XML_BUFFER_ALLOC_DOUBLEIT,    \/* double each time one need to grow *\/\n-    XML_BUFFER_ALLOC_EXACT,    \/* grow only to the minimal size *\/\n+    XML_BUFFER_ALLOC_DOUBLEIT,  \/* double each time one need to grow *\/\n+    XML_BUFFER_ALLOC_EXACT,     \/* grow only to the minimal size *\/\n@@ -89,1 +88,1 @@\n-    XML_BUFFER_ALLOC_IO,    \/* special allocation scheme used for I\/O *\/\n+    XML_BUFFER_ALLOC_IO,        \/* special allocation scheme used for I\/O *\/\n@@ -103,5 +102,10 @@\n-    xmlChar *content;        \/* The buffer content UTF8 *\/\n-    unsigned int use;        \/* The buffer size used *\/\n-    unsigned int size;        \/* The buffer size *\/\n-    xmlBufferAllocationScheme alloc; \/* The realloc method *\/\n-    xmlChar *contentIO;        \/* in IO mode we may have a different base *\/\n+    \/* The buffer content UTF8 *\/\n+    xmlChar *content XML_DEPRECATED_MEMBER;\n+    \/* The buffer size used *\/\n+    unsigned int use XML_DEPRECATED_MEMBER;\n+    \/* The buffer size *\/\n+    unsigned int size XML_DEPRECATED_MEMBER;\n+    \/* The realloc method *\/\n+    xmlBufferAllocationScheme alloc XML_DEPRECATED_MEMBER;\n+    \/* in IO mode we may have a different base *\/\n+    xmlChar *contentIO XML_DEPRECATED_MEMBER;\n@@ -131,1 +135,1 @@\n-XMLPUBFUN xmlChar*       xmlBufContent    (const xmlBuf* buf);\n+XMLPUBFUN xmlChar*       xmlBufContent  (const xmlBuf* buf);\n@@ -134,1 +138,1 @@\n-XMLPUBFUN size_t         xmlBufShrink    (xmlBufPtr buf, size_t len);\n+XMLPUBFUN size_t         xmlBufShrink   (xmlBufPtr buf, size_t len);\n@@ -171,21 +175,21 @@\n-    XML_ELEMENT_NODE=        1,\n-    XML_ATTRIBUTE_NODE=        2,\n-    XML_TEXT_NODE=        3,\n-    XML_CDATA_SECTION_NODE=    4,\n-    XML_ENTITY_REF_NODE=    5,\n-    XML_ENTITY_NODE=        6,  \/* unused *\/\n-    XML_PI_NODE=        7,\n-    XML_COMMENT_NODE=        8,\n-    XML_DOCUMENT_NODE=        9,\n-    XML_DOCUMENT_TYPE_NODE=    10, \/* unused *\/\n-    XML_DOCUMENT_FRAG_NODE=    11,\n-    XML_NOTATION_NODE=        12, \/* unused *\/\n-    XML_HTML_DOCUMENT_NODE=    13,\n-    XML_DTD_NODE=        14,\n-    XML_ELEMENT_DECL=        15,\n-    XML_ATTRIBUTE_DECL=        16,\n-    XML_ENTITY_DECL=        17,\n-    XML_NAMESPACE_DECL=        18,\n-    XML_XINCLUDE_START=        19,\n-    XML_XINCLUDE_END=        20\n-    \/* XML_DOCB_DOCUMENT_NODE=    21 *\/ \/* removed *\/\n+    XML_ELEMENT_NODE=           1,\n+    XML_ATTRIBUTE_NODE=         2,\n+    XML_TEXT_NODE=              3,\n+    XML_CDATA_SECTION_NODE=     4,\n+    XML_ENTITY_REF_NODE=        5,\n+    XML_ENTITY_NODE=            6,  \/* unused *\/\n+    XML_PI_NODE=                7,\n+    XML_COMMENT_NODE=           8,\n+    XML_DOCUMENT_NODE=          9,\n+    XML_DOCUMENT_TYPE_NODE=     10, \/* unused *\/\n+    XML_DOCUMENT_FRAG_NODE=     11,\n+    XML_NOTATION_NODE=          12, \/* unused *\/\n+    XML_HTML_DOCUMENT_NODE=     13,\n+    XML_DTD_NODE=               14,\n+    XML_ELEMENT_DECL=           15,\n+    XML_ATTRIBUTE_DECL=         16,\n+    XML_ENTITY_DECL=            17,\n+    XML_NAMESPACE_DECL=         18,\n+    XML_XINCLUDE_START=         19,\n+    XML_XINCLUDE_END=           20\n+    \/* XML_DOCB_DOCUMENT_NODE=  21 *\/ \/* removed *\/\n@@ -208,3 +212,3 @@\n-    const xmlChar               *name;            \/* Notation name *\/\n-    const xmlChar               *PublicID;    \/* Public identifier, if any *\/\n-    const xmlChar               *SystemID;    \/* System identifier, if any *\/\n+    const xmlChar               *name;          \/* Notation name *\/\n+    const xmlChar               *PublicID;      \/* Public identifier, if any *\/\n+    const xmlChar               *SystemID;      \/* System identifier, if any *\/\n@@ -222,1 +226,1 @@\n-    XML_ATTRIBUTE_IDREF    ,\n+    XML_ATTRIBUTE_IDREF ,\n@@ -255,1 +259,1 @@\n-    const xmlChar            *name;    \/* Enumeration name *\/\n+    const xmlChar            *name;     \/* Enumeration name *\/\n@@ -267,1 +271,1 @@\n-    void           *_private;            \/* application data *\/\n+    void           *_private;           \/* application data *\/\n@@ -269,6 +273,6 @@\n-    const xmlChar          *name;    \/* Attribute name *\/\n-    struct _xmlNode    *children;    \/* NULL *\/\n-    struct _xmlNode        *last;    \/* NULL *\/\n-    struct _xmlDtd       *parent;    \/* -> DTD *\/\n-    struct _xmlNode        *next;    \/* next sibling link  *\/\n-    struct _xmlNode        *prev;    \/* previous sibling link  *\/\n+    const xmlChar          *name;       \/* Attribute name *\/\n+    struct _xmlNode    *children;       \/* NULL *\/\n+    struct _xmlNode        *last;       \/* NULL *\/\n+    struct _xmlDtd       *parent;       \/* -> DTD *\/\n+    struct _xmlNode        *next;       \/* next sibling link  *\/\n+    struct _xmlNode        *prev;       \/* previous sibling link  *\/\n@@ -277,4 +281,4 @@\n-    struct _xmlAttribute  *nexth;    \/* next in hash table *\/\n-    xmlAttributeType       atype;    \/* The attribute type *\/\n-    xmlAttributeDefault      def;    \/* the default *\/\n-    const xmlChar  *defaultValue;    \/* or the default value *\/\n+    struct _xmlAttribute  *nexth;       \/* next in hash table *\/\n+    xmlAttributeType       atype;       \/* The attribute type *\/\n+    xmlAttributeDefault      def;       \/* the default *\/\n+    const xmlChar  *defaultValue;       \/* or the default value *\/\n@@ -282,2 +286,2 @@\n-    const xmlChar        *prefix;    \/* the namespace prefix if any *\/\n-    const xmlChar          *elem;    \/* Element holding the attribute *\/\n+    const xmlChar        *prefix;       \/* the namespace prefix if any *\/\n+    const xmlChar          *elem;       \/* Element holding the attribute *\/\n@@ -320,2 +324,2 @@\n-    xmlElementContentType     type;    \/* PCDATA, ELEMENT, SEQ or OR *\/\n-    xmlElementContentOccur    ocur;    \/* ONCE, OPT, MULT or PLUS *\/\n+    xmlElementContentType     type;     \/* PCDATA, ELEMENT, SEQ or OR *\/\n+    xmlElementContentOccur    ocur;     \/* ONCE, OPT, MULT or PLUS *\/\n@@ -323,4 +327,4 @@\n-    struct _xmlElementContent *c1;    \/* first child *\/\n-    struct _xmlElementContent *c2;    \/* second child *\/\n-    struct _xmlElementContent *parent;    \/* parent *\/\n-    const xmlChar             *prefix;    \/* Namespace prefix *\/\n+    struct _xmlElementContent *c1;      \/* first child *\/\n+    struct _xmlElementContent *c2;      \/* second child *\/\n+    struct _xmlElementContent *parent;  \/* parent *\/\n+    const xmlChar             *prefix;  \/* Namespace prefix *\/\n@@ -352,1 +356,1 @@\n-    void           *_private;            \/* application data *\/\n+    void           *_private;           \/* application data *\/\n@@ -354,6 +358,6 @@\n-    const xmlChar          *name;    \/* Element name *\/\n-    struct _xmlNode    *children;    \/* NULL *\/\n-    struct _xmlNode        *last;    \/* NULL *\/\n-    struct _xmlDtd       *parent;    \/* -> DTD *\/\n-    struct _xmlNode        *next;    \/* next sibling link  *\/\n-    struct _xmlNode        *prev;    \/* previous sibling link  *\/\n+    const xmlChar          *name;       \/* Element name *\/\n+    struct _xmlNode    *children;       \/* NULL *\/\n+    struct _xmlNode        *last;       \/* NULL *\/\n+    struct _xmlDtd       *parent;       \/* -> DTD *\/\n+    struct _xmlNode        *next;       \/* next sibling link  *\/\n+    struct _xmlNode        *prev;       \/* previous sibling link  *\/\n@@ -362,4 +366,4 @@\n-    xmlElementTypeVal      etype;    \/* The type *\/\n-    xmlElementContentPtr content;    \/* the allowed element content *\/\n-    xmlAttributePtr   attributes;    \/* List of the declared attributes *\/\n-    const xmlChar        *prefix;    \/* the namespace prefix if any *\/\n+    xmlElementTypeVal      etype;       \/* The type *\/\n+    xmlElementContentPtr content;       \/* the allowed element content *\/\n+    xmlAttributePtr   attributes;       \/* List of the declared attributes *\/\n+    const xmlChar        *prefix;       \/* the namespace prefix if any *\/\n@@ -367,1 +371,1 @@\n-    xmlRegexpPtr       contModel;    \/* the validating regexp *\/\n+    xmlRegexpPtr       contModel;       \/* the validating regexp *\/\n@@ -369,1 +373,1 @@\n-    void          *contModel;\n+    void              *contModel;\n@@ -395,4 +399,4 @@\n-    struct _xmlNs  *next;    \/* next Ns link for this node  *\/\n-    xmlNsType      type;    \/* global or local *\/\n-    const xmlChar *href;    \/* URL for the namespace *\/\n-    const xmlChar *prefix;    \/* prefix for the namespace *\/\n+    struct _xmlNs  *next;       \/* next Ns link for this node  *\/\n+    xmlNsType      type;        \/* global or local *\/\n+    const xmlChar *href;        \/* URL for the namespace *\/\n+    const xmlChar *prefix;      \/* prefix for the namespace *\/\n@@ -400,1 +404,1 @@\n-    struct _xmlDoc *context;        \/* normally an xmlDoc *\/\n+    struct _xmlDoc *context;            \/* normally an xmlDoc *\/\n@@ -412,1 +416,1 @@\n-    void           *_private;    \/* application data *\/\n+    void           *_private;   \/* application data *\/\n@@ -414,3 +418,3 @@\n-    const xmlChar *name;    \/* Name of the DTD *\/\n-    struct _xmlNode *children;    \/* the value of the property link *\/\n-    struct _xmlNode *last;    \/* last child link *\/\n+    const xmlChar *name;        \/* Name of the DTD *\/\n+    struct _xmlNode *children;  \/* the value of the property link *\/\n+    struct _xmlNode *last;      \/* last child link *\/\n@@ -418,3 +422,3 @@\n-    struct _xmlNode *next;    \/* next sibling link  *\/\n-    struct _xmlNode *prev;    \/* previous sibling link  *\/\n-    struct _xmlDoc  *doc;    \/* the containing document *\/\n+    struct _xmlNode *next;      \/* next sibling link  *\/\n+    struct _xmlNode *prev;      \/* previous sibling link  *\/\n+    struct _xmlDoc  *doc;       \/* the containing document *\/\n@@ -427,1 +431,1 @@\n-    const xmlChar *ExternalID;    \/* External identifier for PUBLIC DTD *\/\n+    const xmlChar *ExternalID;  \/* External identifier for PUBLIC DTD *\/\n@@ -440,1 +444,1 @@\n-    void           *_private;    \/* application data *\/\n+    void           *_private;   \/* application data *\/\n@@ -443,2 +447,2 @@\n-    struct _xmlNode *children;    \/* the value of the property *\/\n-    struct _xmlNode *last;    \/* NULL *\/\n+    struct _xmlNode *children;  \/* the value of the property *\/\n+    struct _xmlNode *last;      \/* NULL *\/\n@@ -446,3 +450,3 @@\n-    struct _xmlAttr *next;    \/* next sibling link  *\/\n-    struct _xmlAttr *prev;    \/* previous sibling link  *\/\n-    struct _xmlDoc  *doc;    \/* the containing document *\/\n+    struct _xmlAttr *next;      \/* next sibling link  *\/\n+    struct _xmlAttr *prev;      \/* previous sibling link  *\/\n+    struct _xmlDoc  *doc;       \/* the containing document *\/\n@@ -451,1 +455,1 @@\n-    void            *psvi;    \/* for type\/PSVI information *\/\n+    void            *psvi;      \/* for type\/PSVI information *\/\n@@ -464,1 +468,1 @@\n-    struct _xmlID    *next;    \/* next ID *\/\n+    struct _xmlID    *next;     \/* next ID *\/\n@@ -466,4 +470,4 @@\n-    xmlAttrPtr        attr;    \/* The attribute holding it *\/\n-    const xmlChar    *name;    \/* The attribute if attr is not available *\/\n-    int               lineno;    \/* The line number if attr is not available *\/\n-    struct _xmlDoc   *doc;    \/* The document holding the ID *\/\n+    xmlAttrPtr        attr;     \/* The attribute holding it *\/\n+    const xmlChar    *name;     \/* The attribute if attr is not available *\/\n+    int               lineno;   \/* The line number if attr is not available *\/\n+    struct _xmlDoc   *doc;      \/* The document holding the ID *\/\n@@ -482,4 +486,4 @@\n-    const xmlChar     *value;    \/* The Ref name *\/\n-    xmlAttrPtr        attr;    \/* The attribute holding it *\/\n-    const xmlChar    *name;    \/* The attribute if attr is not available *\/\n-    int               lineno;    \/* The line number if attr is not available *\/\n+    const xmlChar     *value;   \/* The Ref name *\/\n+    xmlAttrPtr        attr;     \/* The attribute holding it *\/\n+    const xmlChar    *name;     \/* The attribute if attr is not available *\/\n+    int               lineno;   \/* The line number if attr is not available *\/\n@@ -496,2 +500,2 @@\n-    void           *_private;    \/* application data *\/\n-    xmlElementType   type;    \/* type number, must be second ! *\/\n+    void           *_private;   \/* application data *\/\n+    xmlElementType   type;      \/* type number, must be second ! *\/\n@@ -499,2 +503,2 @@\n-    struct _xmlNode *children;    \/* parent->childs link *\/\n-    struct _xmlNode *last;    \/* last child link *\/\n+    struct _xmlNode *children;  \/* parent->childs link *\/\n+    struct _xmlNode *last;      \/* last child link *\/\n@@ -502,3 +506,3 @@\n-    struct _xmlNode *next;    \/* next sibling link  *\/\n-    struct _xmlNode *prev;    \/* previous sibling link  *\/\n-    struct _xmlDoc  *doc;    \/* the containing document *\/\n+    struct _xmlNode *next;      \/* next sibling link  *\/\n+    struct _xmlNode *prev;      \/* previous sibling link  *\/\n+    struct _xmlDoc  *doc;       \/* the containing document *\/\n@@ -511,3 +515,3 @@\n-    void            *psvi;    \/* for type\/PSVI information *\/\n-    unsigned short   line;    \/* line number *\/\n-    unsigned short   extra;    \/* extra data for XPath\/XSLT *\/\n+    void            *psvi;      \/* for type\/PSVI information *\/\n+    unsigned short   line;      \/* line number *\/\n+    unsigned short   extra;     \/* extra data for XPath\/XSLT *\/\n@@ -521,1 +525,1 @@\n-#define XML_GET_CONTENT(n)                    \\\n+#define XML_GET_CONTENT(n)                                      \\\n@@ -529,1 +533,1 @@\n-#define XML_GET_LINE(n)                        \\\n+#define XML_GET_LINE(n)                                         \\\n@@ -539,6 +543,6 @@\n-    XML_DOC_WELLFORMED        = 1<<0, \/* document is XML well formed *\/\n-    XML_DOC_NSVALID        = 1<<1, \/* document is Namespace valid *\/\n-    XML_DOC_OLD10        = 1<<2, \/* parsed with old XML-1.0 parser *\/\n-    XML_DOC_DTDVALID        = 1<<3, \/* DTD validation was successful *\/\n-    XML_DOC_XINCLUDE        = 1<<4, \/* XInclude substitution was done *\/\n-    XML_DOC_USERBUILT        = 1<<5, \/* Document was built using the API\n+    XML_DOC_WELLFORMED          = 1<<0, \/* document is XML well formed *\/\n+    XML_DOC_NSVALID             = 1<<1, \/* document is Namespace valid *\/\n+    XML_DOC_OLD10               = 1<<2, \/* parsed with old XML-1.0 parser *\/\n+    XML_DOC_DTDVALID            = 1<<3, \/* DTD validation was successful *\/\n+    XML_DOC_XINCLUDE            = 1<<4, \/* XInclude substitution was done *\/\n+    XML_DOC_USERBUILT           = 1<<5, \/* Document was built using the API\n@@ -546,2 +550,2 @@\n-    XML_DOC_INTERNAL        = 1<<6, \/* built for internal processing *\/\n-    XML_DOC_HTML        = 1<<7  \/* parsed or built HTML document *\/\n+    XML_DOC_INTERNAL            = 1<<6, \/* built for internal processing *\/\n+    XML_DOC_HTML                = 1<<7  \/* parsed or built HTML document *\/\n@@ -558,1 +562,1 @@\n-    void           *_private;    \/* application data *\/\n+    void           *_private;   \/* application data *\/\n@@ -560,3 +564,3 @@\n-    char           *name;    \/* name\/filename\/URI of the document *\/\n-    struct _xmlNode *children;    \/* the document tree *\/\n-    struct _xmlNode *last;    \/* last child link *\/\n+    char           *name;       \/* name\/filename\/URI of the document *\/\n+    struct _xmlNode *children;  \/* the document tree *\/\n+    struct _xmlNode *last;      \/* last child link *\/\n@@ -564,3 +568,3 @@\n-    struct _xmlNode *next;    \/* next sibling link  *\/\n-    struct _xmlNode *prev;    \/* previous sibling link  *\/\n-    struct _xmlDoc  *doc;    \/* autoreference to itself *\/\n+    struct _xmlNode *next;      \/* next sibling link  *\/\n+    struct _xmlNode *prev;      \/* previous sibling link  *\/\n+    struct _xmlDoc  *doc;       \/* autoreference to itself *\/\n@@ -571,8 +575,8 @@\n-                     1 if standalone=\"yes\"\n-                     0 if standalone=\"no\"\n-                    -1 if there is no XML declaration\n-                    -2 if there is an XML declaration, but no\n-                    standalone attribute was specified *\/\n-    struct _xmlDtd  *intSubset;    \/* the document internal subset *\/\n-    struct _xmlDtd  *extSubset;    \/* the document external subset *\/\n-    struct _xmlNs   *oldNs;    \/* Global namespace, the old way *\/\n+                                     1 if standalone=\"yes\"\n+                                     0 if standalone=\"no\"\n+                                    -1 if there is no XML declaration\n+                                    -2 if there is an XML declaration, but no\n+                                        standalone attribute was specified *\/\n+    struct _xmlDtd  *intSubset; \/* the document internal subset *\/\n+    struct _xmlDtd  *extSubset; \/* the document external subset *\/\n+    struct _xmlNs   *oldNs;     \/* Global namespace, the old way *\/\n@@ -583,1 +587,1 @@\n-    const xmlChar  *URL;    \/* The URI for that document *\/\n+    const xmlChar  *URL;        \/* The URI for that document *\/\n@@ -586,5 +590,5 @@\n-    void           *psvi;    \/* for type\/PSVI information *\/\n-    int             parseFlags;    \/* set of xmlParserOption used to parse the\n-                   document *\/\n-    int             properties;    \/* set of xmlDocProperties for this document\n-                   set at the end of parsing *\/\n+    void           *psvi;       \/* for type\/PSVI information *\/\n+    int             parseFlags; \/* set of xmlParserOption used to parse the\n+                                   document *\/\n+    int             properties; \/* set of xmlDocProperties for this document\n+                                   set at the end of parsing *\/\n@@ -609,3 +613,3 @@\n-                         xmlNodePtr node,\n-                         const xmlChar *nsName,\n-                         const xmlChar *nsPrefix);\n+                                                 xmlNodePtr node,\n+                                                 const xmlChar *nsName,\n+                                                 const xmlChar *nsPrefix);\n@@ -677,14 +681,6 @@\n-#define XML_GLOBALS_TREE \\\n-  XML_OP(xmlBufferAllocScheme, xmlBufferAllocationScheme, XML_DEPRECATED) \\\n-  XML_OP(xmlDefaultBufferSize, int, XML_DEPRECATED) \\\n-  XML_OP(xmlRegisterNodeDefaultValue, xmlRegisterNodeFunc, XML_DEPRECATED) \\\n-  XML_OP(xmlDeregisterNodeDefaultValue, xmlDeregisterNodeFunc, \\\n-         XML_DEPRECATED)\n-\n-#define XML_OP XML_DECLARE_GLOBAL\n-XML_GLOBALS_TREE\n-#undef XML_OP\n-\n-#if defined(LIBXML_THREAD_ENABLED) && !defined(XML_GLOBALS_NO_REDEFINITION)\n-  #define xmlBufferAllocScheme XML_GLOBAL_MACRO(xmlBufferAllocScheme)\n-  #define xmlDefaultBufferSize XML_GLOBAL_MACRO(xmlDefaultBufferSize)\n+XML_DEPRECATED\n+XMLPUBFUN xmlRegisterNodeFunc *__xmlRegisterNodeDefaultValue(void);\n+XML_DEPRECATED\n+XMLPUBFUN xmlDeregisterNodeFunc *__xmlDeregisterNodeDefaultValue(void);\n+\n+#ifndef XML_GLOBALS_NO_REDEFINITION\n@@ -692,1 +688,1 @@\n-    XML_GLOBAL_MACRO(xmlRegisterNodeDefaultValue)\n+    (*__xmlRegisterNodeDefaultValue())\n@@ -694,1 +690,1 @@\n-    XML_GLOBAL_MACRO(xmlDeregisterNodeDefaultValue)\n+    (*__xmlDeregisterNodeDefaultValue())\n@@ -702,2 +698,2 @@\n-        xmlValidateNCName    (const xmlChar *value,\n-                     int space);\n+                xmlValidateNCName       (const xmlChar *value,\n+                                         int space);\n@@ -705,1 +701,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n@@ -707,2 +702,2 @@\n-        xmlValidateQName    (const xmlChar *value,\n-                     int space);\n+                xmlValidateQName        (const xmlChar *value,\n+                                         int space);\n@@ -710,2 +705,2 @@\n-        xmlValidateName        (const xmlChar *value,\n-                     int space);\n+                xmlValidateName         (const xmlChar *value,\n+                                         int space);\n@@ -713,3 +708,2 @@\n-        xmlValidateNMToken    (const xmlChar *value,\n-                     int space);\n-#endif\n+                xmlValidateNMToken      (const xmlChar *value,\n+                                         int space);\n@@ -718,4 +712,4 @@\n-        xmlBuildQName        (const xmlChar *ncname,\n-                     const xmlChar *prefix,\n-                     xmlChar *memory,\n-                     int len);\n+                xmlBuildQName           (const xmlChar *ncname,\n+                                         const xmlChar *prefix,\n+                                         xmlChar *memory,\n+                                         int len);\n@@ -723,2 +717,2 @@\n-        xmlSplitQName2        (const xmlChar *name,\n-                     xmlChar **prefix);\n+                xmlSplitQName2          (const xmlChar *name,\n+                                         xmlChar **prefix);\n@@ -726,2 +720,2 @@\n-        xmlSplitQName3        (const xmlChar *name,\n-                     int *len);\n+                xmlSplitQName3          (const xmlChar *name,\n+                                         int *len);\n@@ -733,0 +727,1 @@\n+XML_DEPRECATED\n@@ -734,1 +729,2 @@\n-        xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme);\n+                xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme);\n+XML_DEPRECATED\n@@ -736,1 +732,1 @@\n-        xmlGetBufferAllocationScheme(void);\n+                xmlGetBufferAllocationScheme(void);\n@@ -739,1 +735,1 @@\n-        xmlBufferCreate        (void);\n+                xmlBufferCreate         (void);\n@@ -741,1 +737,1 @@\n-        xmlBufferCreateSize    (size_t size);\n+                xmlBufferCreateSize     (size_t size);\n@@ -743,2 +739,3 @@\n-        xmlBufferCreateStatic    (void *mem,\n-                     size_t size);\n+                xmlBufferCreateStatic   (void *mem,\n+                                         size_t size);\n+XML_DEPRECATED\n@@ -746,2 +743,2 @@\n-        xmlBufferResize        (xmlBufferPtr buf,\n-                     unsigned int size);\n+                xmlBufferResize         (xmlBufferPtr buf,\n+                                         unsigned int size);\n@@ -749,1 +746,1 @@\n-        xmlBufferFree        (xmlBufferPtr buf);\n+                xmlBufferFree           (xmlBufferPtr buf);\n@@ -751,2 +748,2 @@\n-        xmlBufferDump        (FILE *file,\n-                     xmlBufferPtr buf);\n+                xmlBufferDump           (FILE *file,\n+                                         xmlBufferPtr buf);\n@@ -754,3 +751,3 @@\n-        xmlBufferAdd        (xmlBufferPtr buf,\n-                     const xmlChar *str,\n-                     int len);\n+                xmlBufferAdd            (xmlBufferPtr buf,\n+                                         const xmlChar *str,\n+                                         int len);\n@@ -758,3 +755,3 @@\n-        xmlBufferAddHead    (xmlBufferPtr buf,\n-                     const xmlChar *str,\n-                     int len);\n+                xmlBufferAddHead        (xmlBufferPtr buf,\n+                                         const xmlChar *str,\n+                                         int len);\n@@ -762,2 +759,2 @@\n-        xmlBufferCat        (xmlBufferPtr buf,\n-                     const xmlChar *str);\n+                xmlBufferCat            (xmlBufferPtr buf,\n+                                         const xmlChar *str);\n@@ -765,2 +762,3 @@\n-        xmlBufferCCat        (xmlBufferPtr buf,\n-                     const char *str);\n+                xmlBufferCCat           (xmlBufferPtr buf,\n+                                         const char *str);\n+XML_DEPRECATED\n@@ -768,2 +766,3 @@\n-        xmlBufferShrink        (xmlBufferPtr buf,\n-                     unsigned int len);\n+                xmlBufferShrink         (xmlBufferPtr buf,\n+                                         unsigned int len);\n+XML_DEPRECATED\n@@ -771,2 +770,2 @@\n-        xmlBufferGrow        (xmlBufferPtr buf,\n-                     unsigned int len);\n+                xmlBufferGrow           (xmlBufferPtr buf,\n+                                         unsigned int len);\n@@ -774,1 +773,1 @@\n-        xmlBufferEmpty        (xmlBufferPtr buf);\n+                xmlBufferEmpty          (xmlBufferPtr buf);\n@@ -776,1 +775,1 @@\n-        xmlBufferContent    (const xmlBuffer *buf);\n+                xmlBufferContent        (const xmlBuffer *buf);\n@@ -778,1 +777,1 @@\n-        xmlBufferDetach         (xmlBufferPtr buf);\n+                xmlBufferDetach         (xmlBufferPtr buf);\n@@ -780,2 +779,2 @@\n-        xmlBufferSetAllocationScheme(xmlBufferPtr buf,\n-                     xmlBufferAllocationScheme scheme);\n+                xmlBufferSetAllocationScheme(xmlBufferPtr buf,\n+                                         xmlBufferAllocationScheme scheme);\n@@ -783,1 +782,1 @@\n-        xmlBufferLength        (const xmlBuffer *buf);\n+                xmlBufferLength         (const xmlBuffer *buf);\n@@ -789,4 +788,4 @@\n-        xmlCreateIntSubset    (xmlDocPtr doc,\n-                     const xmlChar *name,\n-                     const xmlChar *ExternalID,\n-                     const xmlChar *SystemID);\n+                xmlCreateIntSubset      (xmlDocPtr doc,\n+                                         const xmlChar *name,\n+                                         const xmlChar *ExternalID,\n+                                         const xmlChar *SystemID);\n@@ -794,4 +793,4 @@\n-        xmlNewDtd        (xmlDocPtr doc,\n-                     const xmlChar *name,\n-                     const xmlChar *ExternalID,\n-                     const xmlChar *SystemID);\n+                xmlNewDtd               (xmlDocPtr doc,\n+                                         const xmlChar *name,\n+                                         const xmlChar *ExternalID,\n+                                         const xmlChar *SystemID);\n@@ -799,1 +798,1 @@\n-        xmlGetIntSubset        (const xmlDoc *doc);\n+                xmlGetIntSubset         (const xmlDoc *doc);\n@@ -801,8 +800,1 @@\n-        xmlFreeDtd        (xmlDtdPtr cur);\n-#ifdef LIBXML_LEGACY_ENABLED\n-XML_DEPRECATED\n-XMLPUBFUN xmlNsPtr\n-        xmlNewGlobalNs        (xmlDocPtr doc,\n-                     const xmlChar *href,\n-                     const xmlChar *prefix);\n-#endif \/* LIBXML_LEGACY_ENABLED *\/\n+                xmlFreeDtd              (xmlDtdPtr cur);\n@@ -810,3 +802,3 @@\n-        xmlNewNs        (xmlNodePtr node,\n-                     const xmlChar *href,\n-                     const xmlChar *prefix);\n+                xmlNewNs                (xmlNodePtr node,\n+                                         const xmlChar *href,\n+                                         const xmlChar *prefix);\n@@ -814,1 +806,1 @@\n-        xmlFreeNs        (xmlNsPtr cur);\n+                xmlFreeNs               (xmlNsPtr cur);\n@@ -816,1 +808,1 @@\n-        xmlFreeNsList        (xmlNsPtr cur);\n+                xmlFreeNsList           (xmlNsPtr cur);\n@@ -818,1 +810,1 @@\n-        xmlNewDoc        (const xmlChar *version);\n+                xmlNewDoc               (const xmlChar *version);\n@@ -820,1 +812,1 @@\n-        xmlFreeDoc        (xmlDocPtr cur);\n+                xmlFreeDoc              (xmlDocPtr cur);\n@@ -822,5 +814,3 @@\n-        xmlNewDocProp        (xmlDocPtr doc,\n-                     const xmlChar *name,\n-                     const xmlChar *value);\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \\\n-    defined(LIBXML_SCHEMAS_ENABLED)\n+                xmlNewDocProp           (xmlDocPtr doc,\n+                                         const xmlChar *name,\n+                                         const xmlChar *value);\n@@ -828,4 +818,3 @@\n-        xmlNewProp        (xmlNodePtr node,\n-                     const xmlChar *name,\n-                     const xmlChar *value);\n-#endif\n+                xmlNewProp              (xmlNodePtr node,\n+                                         const xmlChar *name,\n+                                         const xmlChar *value);\n@@ -833,4 +822,4 @@\n-        xmlNewNsProp        (xmlNodePtr node,\n-                     xmlNsPtr ns,\n-                     const xmlChar *name,\n-                     const xmlChar *value);\n+                xmlNewNsProp            (xmlNodePtr node,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *name,\n+                                         const xmlChar *value);\n@@ -838,4 +827,4 @@\n-        xmlNewNsPropEatName    (xmlNodePtr node,\n-                     xmlNsPtr ns,\n-                     xmlChar *name,\n-                     const xmlChar *value);\n+                xmlNewNsPropEatName     (xmlNodePtr node,\n+                                         xmlNsPtr ns,\n+                                         xmlChar *name,\n+                                         const xmlChar *value);\n@@ -843,1 +832,1 @@\n-        xmlFreePropList        (xmlAttrPtr cur);\n+                xmlFreePropList         (xmlAttrPtr cur);\n@@ -845,1 +834,1 @@\n-        xmlFreeProp        (xmlAttrPtr cur);\n+                xmlFreeProp             (xmlAttrPtr cur);\n@@ -847,2 +836,2 @@\n-        xmlCopyProp        (xmlNodePtr target,\n-                     xmlAttrPtr cur);\n+                xmlCopyProp             (xmlNodePtr target,\n+                                         xmlAttrPtr cur);\n@@ -850,3 +839,2 @@\n-        xmlCopyPropList        (xmlNodePtr target,\n-                     xmlAttrPtr cur);\n-#ifdef LIBXML_TREE_ENABLED\n+                xmlCopyPropList         (xmlNodePtr target,\n+                                         xmlAttrPtr cur);\n@@ -854,3 +842,1 @@\n-        xmlCopyDtd        (xmlDtdPtr dtd);\n-#endif \/* LIBXML_TREE_ENABLED *\/\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n+                xmlCopyDtd              (xmlDtdPtr dtd);\n@@ -858,3 +844,2 @@\n-        xmlCopyDoc        (xmlDocPtr doc,\n-                     int recursive);\n-#endif \/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) *\/\n+                xmlCopyDoc              (xmlDocPtr doc,\n+                                         int recursive);\n@@ -865,4 +850,4 @@\n-        xmlNewDocNode        (xmlDocPtr doc,\n-                     xmlNsPtr ns,\n-                     const xmlChar *name,\n-                     const xmlChar *content);\n+                xmlNewDocNode           (xmlDocPtr doc,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *name,\n+                                         const xmlChar *content);\n@@ -870,4 +855,4 @@\n-        xmlNewDocNodeEatName    (xmlDocPtr doc,\n-                     xmlNsPtr ns,\n-                     xmlChar *name,\n-                     const xmlChar *content);\n+                xmlNewDocNodeEatName    (xmlDocPtr doc,\n+                                         xmlNsPtr ns,\n+                                         xmlChar *name,\n+                                         const xmlChar *content);\n@@ -875,2 +860,2 @@\n-        xmlNewNode        (xmlNsPtr ns,\n-                     const xmlChar *name);\n+                xmlNewNode              (xmlNsPtr ns,\n+                                         const xmlChar *name);\n@@ -878,3 +863,2 @@\n-        xmlNewNodeEatName    (xmlNsPtr ns,\n-                     xmlChar *name);\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n+                xmlNewNodeEatName       (xmlNsPtr ns,\n+                                         xmlChar *name);\n@@ -882,5 +866,4 @@\n-        xmlNewChild        (xmlNodePtr parent,\n-                     xmlNsPtr ns,\n-                     const xmlChar *name,\n-                     const xmlChar *content);\n-#endif\n+                xmlNewChild             (xmlNodePtr parent,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *name,\n+                                         const xmlChar *content);\n@@ -888,2 +871,2 @@\n-        xmlNewDocText        (const xmlDoc *doc,\n-                     const xmlChar *content);\n+                xmlNewDocText           (const xmlDoc *doc,\n+                                         const xmlChar *content);\n@@ -891,1 +874,1 @@\n-        xmlNewText        (const xmlChar *content);\n+                xmlNewText              (const xmlChar *content);\n@@ -893,3 +876,3 @@\n-        xmlNewDocPI        (xmlDocPtr doc,\n-                     const xmlChar *name,\n-                     const xmlChar *content);\n+                xmlNewDocPI             (xmlDocPtr doc,\n+                                         const xmlChar *name,\n+                                         const xmlChar *content);\n@@ -897,2 +880,2 @@\n-        xmlNewPI        (const xmlChar *name,\n-                     const xmlChar *content);\n+                xmlNewPI                (const xmlChar *name,\n+                                         const xmlChar *content);\n@@ -900,3 +883,3 @@\n-        xmlNewDocTextLen    (xmlDocPtr doc,\n-                     const xmlChar *content,\n-                     int len);\n+                xmlNewDocTextLen        (xmlDocPtr doc,\n+                                         const xmlChar *content,\n+                                         int len);\n@@ -904,2 +887,2 @@\n-        xmlNewTextLen        (const xmlChar *content,\n-                     int len);\n+                xmlNewTextLen           (const xmlChar *content,\n+                                         int len);\n@@ -907,2 +890,2 @@\n-        xmlNewDocComment    (xmlDocPtr doc,\n-                     const xmlChar *content);\n+                xmlNewDocComment        (xmlDocPtr doc,\n+                                         const xmlChar *content);\n@@ -910,1 +893,1 @@\n-        xmlNewComment        (const xmlChar *content);\n+                xmlNewComment           (const xmlChar *content);\n@@ -912,3 +895,3 @@\n-        xmlNewCDataBlock    (xmlDocPtr doc,\n-                     const xmlChar *content,\n-                     int len);\n+                xmlNewCDataBlock        (xmlDocPtr doc,\n+                                         const xmlChar *content,\n+                                         int len);\n@@ -916,2 +899,2 @@\n-        xmlNewCharRef        (xmlDocPtr doc,\n-                     const xmlChar *name);\n+                xmlNewCharRef           (xmlDocPtr doc,\n+                                         const xmlChar *name);\n@@ -919,2 +902,2 @@\n-        xmlNewReference        (const xmlDoc *doc,\n-                     const xmlChar *name);\n+                xmlNewReference         (const xmlDoc *doc,\n+                                         const xmlChar *name);\n@@ -922,2 +905,2 @@\n-        xmlCopyNode        (xmlNodePtr node,\n-                     int recursive);\n+                xmlCopyNode             (xmlNodePtr node,\n+                                         int recursive);\n@@ -925,3 +908,3 @@\n-        xmlDocCopyNode        (xmlNodePtr node,\n-                     xmlDocPtr doc,\n-                     int recursive);\n+                xmlDocCopyNode          (xmlNodePtr node,\n+                                         xmlDocPtr doc,\n+                                         int recursive);\n@@ -929,2 +912,2 @@\n-        xmlDocCopyNodeList    (xmlDocPtr doc,\n-                     xmlNodePtr node);\n+                xmlDocCopyNodeList      (xmlDocPtr doc,\n+                                         xmlNodePtr node);\n@@ -932,2 +915,1 @@\n-        xmlCopyNodeList        (xmlNodePtr node);\n-#ifdef LIBXML_TREE_ENABLED\n+                xmlCopyNodeList         (xmlNodePtr node);\n@@ -935,4 +917,4 @@\n-        xmlNewTextChild        (xmlNodePtr parent,\n-                     xmlNsPtr ns,\n-                     const xmlChar *name,\n-                     const xmlChar *content);\n+                xmlNewTextChild         (xmlNodePtr parent,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *name,\n+                                         const xmlChar *content);\n@@ -940,4 +922,4 @@\n-        xmlNewDocRawNode    (xmlDocPtr doc,\n-                     xmlNsPtr ns,\n-                     const xmlChar *name,\n-                     const xmlChar *content);\n+                xmlNewDocRawNode        (xmlDocPtr doc,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *name,\n+                                         const xmlChar *content);\n@@ -945,2 +927,1 @@\n-        xmlNewDocFragment    (xmlDocPtr doc);\n-#endif \/* LIBXML_TREE_ENABLED *\/\n+                xmlNewDocFragment       (xmlDocPtr doc);\n@@ -952,2 +933,1 @@\n-        xmlGetLineNo        (const xmlNode *node);\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)\n+                xmlGetLineNo            (const xmlNode *node);\n@@ -955,2 +935,1 @@\n-        xmlGetNodePath        (const xmlNode *node);\n-#endif \/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED) *\/\n+                xmlGetNodePath          (const xmlNode *node);\n@@ -958,1 +937,1 @@\n-        xmlDocGetRootElement    (const xmlDoc *doc);\n+                xmlDocGetRootElement    (const xmlDoc *doc);\n@@ -960,1 +939,1 @@\n-        xmlGetLastChild        (const xmlNode *parent);\n+                xmlGetLastChild         (const xmlNode *parent);\n@@ -962,1 +941,1 @@\n-        xmlNodeIsText        (const xmlNode *node);\n+                xmlNodeIsText           (const xmlNode *node);\n@@ -964,1 +943,1 @@\n-        xmlIsBlankNode        (const xmlNode *node);\n+                xmlIsBlankNode          (const xmlNode *node);\n@@ -969,1 +948,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)\n@@ -971,4 +949,2 @@\n-        xmlDocSetRootElement    (xmlDocPtr doc,\n-                     xmlNodePtr root);\n-#endif \/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) *\/\n-#ifdef LIBXML_TREE_ENABLED\n+                xmlDocSetRootElement    (xmlDocPtr doc,\n+                                         xmlNodePtr root);\n@@ -976,3 +952,2 @@\n-        xmlNodeSetName        (xmlNodePtr cur,\n-                     const xmlChar *name);\n-#endif \/* LIBXML_TREE_ENABLED *\/\n+                xmlNodeSetName          (xmlNodePtr cur,\n+                                         const xmlChar *name);\n@@ -980,2 +955,2 @@\n-        xmlAddChild        (xmlNodePtr parent,\n-                     xmlNodePtr cur);\n+                xmlAddChild             (xmlNodePtr parent,\n+                                         xmlNodePtr cur);\n@@ -983,3 +958,2 @@\n-        xmlAddChildList        (xmlNodePtr parent,\n-                     xmlNodePtr cur);\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)\n+                xmlAddChildList         (xmlNodePtr parent,\n+                                         xmlNodePtr cur);\n@@ -987,5 +961,2 @@\n-        xmlReplaceNode        (xmlNodePtr old,\n-                     xmlNodePtr cur);\n-#endif \/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED) *\/\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \\\n-    defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)\n+                xmlReplaceNode          (xmlNodePtr old,\n+                                         xmlNodePtr cur);\n@@ -993,3 +964,2 @@\n-        xmlAddPrevSibling    (xmlNodePtr cur,\n-                     xmlNodePtr elem);\n-#endif \/* LIBXML_TREE_ENABLED || LIBXML_HTML_ENABLED || LIBXML_SCHEMAS_ENABLED *\/\n+                xmlAddPrevSibling       (xmlNodePtr cur,\n+                                         xmlNodePtr elem);\n@@ -997,2 +967,2 @@\n-        xmlAddSibling        (xmlNodePtr cur,\n-                     xmlNodePtr elem);\n+                xmlAddSibling           (xmlNodePtr cur,\n+                                         xmlNodePtr elem);\n@@ -1000,2 +970,2 @@\n-        xmlAddNextSibling    (xmlNodePtr cur,\n-                     xmlNodePtr elem);\n+                xmlAddNextSibling       (xmlNodePtr cur,\n+                                         xmlNodePtr elem);\n@@ -1003,1 +973,1 @@\n-        xmlUnlinkNode        (xmlNodePtr cur);\n+                xmlUnlinkNode           (xmlNodePtr cur);\n@@ -1005,2 +975,2 @@\n-        xmlTextMerge        (xmlNodePtr first,\n-                     xmlNodePtr second);\n+                xmlTextMerge            (xmlNodePtr first,\n+                                         xmlNodePtr second);\n@@ -1008,3 +978,3 @@\n-        xmlTextConcat        (xmlNodePtr node,\n-                     const xmlChar *content,\n-                     int len);\n+                xmlTextConcat           (xmlNodePtr node,\n+                                         const xmlChar *content,\n+                                         int len);\n@@ -1012,1 +982,1 @@\n-        xmlFreeNodeList        (xmlNodePtr cur);\n+                xmlFreeNodeList         (xmlNodePtr cur);\n@@ -1014,1 +984,1 @@\n-        xmlFreeNode        (xmlNodePtr cur);\n+                xmlFreeNode             (xmlNodePtr cur);\n@@ -1016,2 +986,2 @@\n-        xmlSetTreeDoc        (xmlNodePtr tree,\n-                     xmlDocPtr doc);\n+                xmlSetTreeDoc           (xmlNodePtr tree,\n+                                         xmlDocPtr doc);\n@@ -1019,2 +989,2 @@\n-        xmlSetListDoc        (xmlNodePtr list,\n-                     xmlDocPtr doc);\n+                xmlSetListDoc           (xmlNodePtr list,\n+                                         xmlDocPtr doc);\n@@ -1025,3 +995,3 @@\n-        xmlSearchNs        (xmlDocPtr doc,\n-                     xmlNodePtr node,\n-                     const xmlChar *nameSpace);\n+                xmlSearchNs             (xmlDocPtr doc,\n+                                         xmlNodePtr node,\n+                                         const xmlChar *nameSpace);\n@@ -1029,5 +999,3 @@\n-        xmlSearchNsByHref    (xmlDocPtr doc,\n-                     xmlNodePtr node,\n-                     const xmlChar *href);\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || \\\n-    defined(LIBXML_SCHEMAS_ENABLED)\n+                xmlSearchNsByHref       (xmlDocPtr doc,\n+                                         xmlNodePtr node,\n+                                         const xmlChar *href);\n@@ -1035,3 +1003,3 @@\n-        xmlGetNsListSafe    (const xmlDoc *doc,\n-                     const xmlNode *node,\n-                     xmlNsPtr **out);\n+                xmlGetNsListSafe        (const xmlDoc *doc,\n+                                         const xmlNode *node,\n+                                         xmlNsPtr **out);\n@@ -1039,3 +1007,2 @@\n-        xmlGetNsList        (const xmlDoc *doc,\n-                     const xmlNode *node);\n-#endif \/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) *\/\n+                xmlGetNsList            (const xmlDoc *doc,\n+                                         const xmlNode *node);\n@@ -1044,2 +1011,2 @@\n-        xmlSetNs        (xmlNodePtr node,\n-                     xmlNsPtr ns);\n+                xmlSetNs                (xmlNodePtr node,\n+                                         xmlNsPtr ns);\n@@ -1047,1 +1014,1 @@\n-        xmlCopyNamespace    (xmlNsPtr cur);\n+                xmlCopyNamespace        (xmlNsPtr cur);\n@@ -1049,1 +1016,1 @@\n-        xmlCopyNamespaceList    (xmlNsPtr cur);\n+                xmlCopyNamespaceList    (xmlNsPtr cur);\n@@ -1054,2 +1021,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || \\\n-    defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)\n@@ -1057,3 +1022,3 @@\n-        xmlSetProp        (xmlNodePtr node,\n-                     const xmlChar *name,\n-                     const xmlChar *value);\n+                xmlSetProp              (xmlNodePtr node,\n+                                         const xmlChar *name,\n+                                         const xmlChar *value);\n@@ -1061,6 +1026,4 @@\n-        xmlSetNsProp        (xmlNodePtr node,\n-                     xmlNsPtr ns,\n-                     const xmlChar *name,\n-                     const xmlChar *value);\n-#endif \/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || \\\n-      defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED) *\/\n+                xmlSetNsProp            (xmlNodePtr node,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *name,\n+                                         const xmlChar *value);\n@@ -1068,4 +1031,4 @@\n-        xmlNodeGetAttrValue    (const xmlNode *node,\n-                     const xmlChar *name,\n-                     const xmlChar *nsUri,\n-                     xmlChar **out);\n+                xmlNodeGetAttrValue     (const xmlNode *node,\n+                                         const xmlChar *name,\n+                                         const xmlChar *nsUri,\n+                                         xmlChar **out);\n@@ -1073,2 +1036,2 @@\n-        xmlGetNoNsProp        (const xmlNode *node,\n-                     const xmlChar *name);\n+                xmlGetNoNsProp          (const xmlNode *node,\n+                                         const xmlChar *name);\n@@ -1076,2 +1039,2 @@\n-        xmlGetProp        (const xmlNode *node,\n-                     const xmlChar *name);\n+                xmlGetProp              (const xmlNode *node,\n+                                         const xmlChar *name);\n@@ -1079,2 +1042,2 @@\n-        xmlHasProp        (const xmlNode *node,\n-                     const xmlChar *name);\n+                xmlHasProp              (const xmlNode *node,\n+                                         const xmlChar *name);\n@@ -1082,3 +1045,3 @@\n-        xmlHasNsProp        (const xmlNode *node,\n-                     const xmlChar *name,\n-                     const xmlChar *nameSpace);\n+                xmlHasNsProp            (const xmlNode *node,\n+                                         const xmlChar *name,\n+                                         const xmlChar *nameSpace);\n@@ -1086,3 +1049,3 @@\n-        xmlGetNsProp        (const xmlNode *node,\n-                     const xmlChar *name,\n-                     const xmlChar *nameSpace);\n+                xmlGetNsProp            (const xmlNode *node,\n+                                         const xmlChar *name,\n+                                         const xmlChar *nameSpace);\n@@ -1090,2 +1053,2 @@\n-        xmlStringGetNodeList    (const xmlDoc *doc,\n-                     const xmlChar *value);\n+                xmlStringGetNodeList    (const xmlDoc *doc,\n+                                         const xmlChar *value);\n@@ -1093,3 +1056,3 @@\n-        xmlStringLenGetNodeList    (const xmlDoc *doc,\n-                     const xmlChar *value,\n-                     int len);\n+                xmlStringLenGetNodeList (const xmlDoc *doc,\n+                                         const xmlChar *value,\n+                                         int len);\n@@ -1097,4 +1060,3 @@\n-        xmlNodeListGetString    (xmlDocPtr doc,\n-                     const xmlNode *list,\n-                     int inLine);\n-#ifdef LIBXML_TREE_ENABLED\n+                xmlNodeListGetString    (xmlDocPtr doc,\n+                                         const xmlNode *list,\n+                                         int inLine);\n@@ -1102,4 +1064,3 @@\n-        xmlNodeListGetRawString    (const xmlDoc *doc,\n-                     const xmlNode *list,\n-                     int inLine);\n-#endif \/* LIBXML_TREE_ENABLED *\/\n+                xmlNodeListGetRawString (const xmlDoc *doc,\n+                                         const xmlNode *list,\n+                                         int inLine);\n@@ -1107,3 +1068,2 @@\n-        xmlNodeSetContent    (xmlNodePtr cur,\n-                     const xmlChar *content);\n-#ifdef LIBXML_TREE_ENABLED\n+                xmlNodeSetContent       (xmlNodePtr cur,\n+                                         const xmlChar *content);\n@@ -1111,4 +1071,3 @@\n-        xmlNodeSetContentLen    (xmlNodePtr cur,\n-                     const xmlChar *content,\n-                     int len);\n-#endif \/* LIBXML_TREE_ENABLED *\/\n+                xmlNodeSetContentLen    (xmlNodePtr cur,\n+                                         const xmlChar *content,\n+                                         int len);\n@@ -1116,2 +1075,2 @@\n-        xmlNodeAddContent    (xmlNodePtr cur,\n-                     const xmlChar *content);\n+                xmlNodeAddContent       (xmlNodePtr cur,\n+                                         const xmlChar *content);\n@@ -1119,3 +1078,3 @@\n-        xmlNodeAddContentLen    (xmlNodePtr cur,\n-                     const xmlChar *content,\n-                     int len);\n+                xmlNodeAddContentLen    (xmlNodePtr cur,\n+                                         const xmlChar *content,\n+                                         int len);\n@@ -1123,1 +1082,1 @@\n-        xmlNodeGetContent    (const xmlNode *cur);\n+                xmlNodeGetContent       (const xmlNode *cur);\n@@ -1126,2 +1085,2 @@\n-        xmlNodeBufGetContent    (xmlBufferPtr buffer,\n-                     const xmlNode *cur);\n+                xmlNodeBufGetContent    (xmlBufferPtr buffer,\n+                                         const xmlNode *cur);\n@@ -1129,2 +1088,2 @@\n-        xmlBufGetNodeContent    (xmlBufPtr buf,\n-                     const xmlNode *cur);\n+                xmlBufGetNodeContent    (xmlBufPtr buf,\n+                                         const xmlNode *cur);\n@@ -1133,1 +1092,1 @@\n-        xmlNodeGetLang        (const xmlNode *cur);\n+                xmlNodeGetLang          (const xmlNode *cur);\n@@ -1135,2 +1094,1 @@\n-        xmlNodeGetSpacePreserve    (const xmlNode *cur);\n-#ifdef LIBXML_TREE_ENABLED\n+                xmlNodeGetSpacePreserve (const xmlNode *cur);\n@@ -1138,2 +1096,2 @@\n-        xmlNodeSetLang        (xmlNodePtr cur,\n-                     const xmlChar *lang);\n+                xmlNodeSetLang          (xmlNodePtr cur,\n+                                         const xmlChar *lang);\n@@ -1141,3 +1099,2 @@\n-        xmlNodeSetSpacePreserve (xmlNodePtr cur,\n-                     int val);\n-#endif \/* LIBXML_TREE_ENABLED *\/\n+                xmlNodeSetSpacePreserve (xmlNodePtr cur,\n+                                         int val);\n@@ -1145,3 +1102,3 @@\n-        xmlNodeGetBaseSafe    (const xmlDoc *doc,\n-                     const xmlNode *cur,\n-                     xmlChar **baseOut);\n+                xmlNodeGetBaseSafe      (const xmlDoc *doc,\n+                                         const xmlNode *cur,\n+                                         xmlChar **baseOut);\n@@ -1149,3 +1106,2 @@\n-        xmlNodeGetBase        (const xmlDoc *doc,\n-                     const xmlNode *cur);\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)\n+                xmlNodeGetBase          (const xmlDoc *doc,\n+                                         const xmlNode *cur);\n@@ -1153,3 +1109,2 @@\n-        xmlNodeSetBase        (xmlNodePtr cur,\n-                     const xmlChar *uri);\n-#endif\n+                xmlNodeSetBase          (xmlNodePtr cur,\n+                                         const xmlChar *uri);\n@@ -1161,2 +1116,1 @@\n-        xmlRemoveProp        (xmlAttrPtr cur);\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n+                xmlRemoveProp           (xmlAttrPtr cur);\n@@ -1164,3 +1118,3 @@\n-        xmlUnsetNsProp        (xmlNodePtr node,\n-                     xmlNsPtr ns,\n-                     const xmlChar *name);\n+                xmlUnsetNsProp          (xmlNodePtr node,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *name);\n@@ -1168,3 +1122,2 @@\n-        xmlUnsetProp        (xmlNodePtr node,\n-                     const xmlChar *name);\n-#endif \/* defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) *\/\n+                xmlUnsetProp            (xmlNodePtr node,\n+                                         const xmlChar *name);\n@@ -1176,2 +1129,2 @@\n-        xmlBufferWriteCHAR    (xmlBufferPtr buf,\n-                     const xmlChar *string);\n+                xmlBufferWriteCHAR      (xmlBufferPtr buf,\n+                                         const xmlChar *string);\n@@ -1179,2 +1132,2 @@\n-        xmlBufferWriteChar    (xmlBufferPtr buf,\n-                     const char *string);\n+                xmlBufferWriteChar      (xmlBufferPtr buf,\n+                                         const char *string);\n@@ -1182,2 +1135,2 @@\n-        xmlBufferWriteQuotedString(xmlBufferPtr buf,\n-                     const xmlChar *string);\n+                xmlBufferWriteQuotedString(xmlBufferPtr buf,\n+                                         const xmlChar *string);\n@@ -1187,3 +1140,3 @@\n-                     xmlDocPtr doc,\n-                     xmlAttrPtr attr,\n-                     const xmlChar *string);\n+                                         xmlDocPtr doc,\n+                                         xmlAttrPtr attr,\n+                                         const xmlChar *string);\n@@ -1192,1 +1145,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -1197,3 +1149,2 @@\n-        xmlReconciliateNs    (xmlDocPtr doc,\n-                     xmlNodePtr tree);\n-#endif\n+                xmlReconciliateNs       (xmlDocPtr doc,\n+                                         xmlNodePtr tree);\n@@ -1206,4 +1157,4 @@\n-        xmlDocDumpFormatMemory    (xmlDocPtr cur,\n-                     xmlChar **mem,\n-                     int *size,\n-                     int format);\n+                xmlDocDumpFormatMemory  (xmlDocPtr cur,\n+                                         xmlChar **mem,\n+                                         int *size,\n+                                         int format);\n@@ -1211,3 +1162,3 @@\n-        xmlDocDumpMemory    (xmlDocPtr cur,\n-                     xmlChar **mem,\n-                     int *size);\n+                xmlDocDumpMemory        (xmlDocPtr cur,\n+                                         xmlChar **mem,\n+                                         int *size);\n@@ -1215,4 +1166,4 @@\n-        xmlDocDumpMemoryEnc    (xmlDocPtr out_doc,\n-                     xmlChar **doc_txt_ptr,\n-                     int * doc_txt_len,\n-                     const char *txt_encoding);\n+                xmlDocDumpMemoryEnc     (xmlDocPtr out_doc,\n+                                         xmlChar **doc_txt_ptr,\n+                                         int * doc_txt_len,\n+                                         const char *txt_encoding);\n@@ -1220,5 +1171,5 @@\n-        xmlDocDumpFormatMemoryEnc(xmlDocPtr out_doc,\n-                     xmlChar **doc_txt_ptr,\n-                     int * doc_txt_len,\n-                     const char *txt_encoding,\n-                     int format);\n+                xmlDocDumpFormatMemoryEnc(xmlDocPtr out_doc,\n+                                         xmlChar **doc_txt_ptr,\n+                                         int * doc_txt_len,\n+                                         const char *txt_encoding,\n+                                         int format);\n@@ -1226,3 +1177,3 @@\n-        xmlDocFormatDump    (FILE *f,\n-                     xmlDocPtr cur,\n-                     int format);\n+                xmlDocFormatDump        (FILE *f,\n+                                         xmlDocPtr cur,\n+                                         int format);\n@@ -1230,2 +1181,2 @@\n-        xmlDocDump        (FILE *f,\n-                     xmlDocPtr cur);\n+                xmlDocDump              (FILE *f,\n+                                         xmlDocPtr cur);\n@@ -1233,3 +1184,3 @@\n-        xmlElemDump        (FILE *f,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur);\n+                xmlElemDump             (FILE *f,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur);\n@@ -1237,2 +1188,2 @@\n-        xmlSaveFile        (const char *filename,\n-                     xmlDocPtr cur);\n+                xmlSaveFile             (const char *filename,\n+                                         xmlDocPtr cur);\n@@ -1240,3 +1191,3 @@\n-        xmlSaveFormatFile    (const char *filename,\n-                     xmlDocPtr cur,\n-                     int format);\n+                xmlSaveFormatFile       (const char *filename,\n+                                         xmlDocPtr cur,\n+                                         int format);\n@@ -1244,5 +1195,5 @@\n-        xmlBufNodeDump        (xmlBufPtr buf,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur,\n-                     int level,\n-                     int format);\n+                xmlBufNodeDump          (xmlBufPtr buf,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur,\n+                                         int level,\n+                                         int format);\n@@ -1250,5 +1201,5 @@\n-        xmlNodeDump        (xmlBufferPtr buf,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur,\n-                     int level,\n-                     int format);\n+                xmlNodeDump             (xmlBufferPtr buf,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur,\n+                                         int level,\n+                                         int format);\n@@ -1257,3 +1208,3 @@\n-        xmlSaveFileTo        (xmlOutputBufferPtr buf,\n-                     xmlDocPtr cur,\n-                     const char *encoding);\n+                xmlSaveFileTo           (xmlOutputBufferPtr buf,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding);\n@@ -1261,4 +1212,4 @@\n-        xmlSaveFormatFileTo     (xmlOutputBufferPtr buf,\n-                     xmlDocPtr cur,\n-                         const char *encoding,\n-                         int format);\n+                xmlSaveFormatFileTo     (xmlOutputBufferPtr buf,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding,\n+                                         int format);\n@@ -1266,6 +1217,6 @@\n-        xmlNodeDumpOutput    (xmlOutputBufferPtr buf,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr cur,\n-                     int level,\n-                     int format,\n-                     const char *encoding);\n+                xmlNodeDumpOutput       (xmlOutputBufferPtr buf,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr cur,\n+                                         int level,\n+                                         int format,\n+                                         const char *encoding);\n@@ -1274,4 +1225,4 @@\n-        xmlSaveFormatFileEnc    (const char *filename,\n-                     xmlDocPtr cur,\n-                     const char *encoding,\n-                     int format);\n+                xmlSaveFormatFileEnc    (const char *filename,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding,\n+                                         int format);\n@@ -1280,3 +1231,3 @@\n-        xmlSaveFileEnc        (const char *filename,\n-                     xmlDocPtr cur,\n-                     const char *encoding);\n+                xmlSaveFileEnc          (const char *filename,\n+                                         xmlDocPtr cur,\n+                                         const char *encoding);\n@@ -1289,2 +1240,2 @@\n-        xmlIsXHTML        (const xmlChar *systemID,\n-                     const xmlChar *publicID);\n+                xmlIsXHTML              (const xmlChar *systemID,\n+                                         const xmlChar *publicID);\n@@ -1296,1 +1247,1 @@\n-        xmlGetDocCompressMode    (const xmlDoc *doc);\n+                xmlGetDocCompressMode   (const xmlDoc *doc);\n@@ -1298,2 +1249,2 @@\n-        xmlSetDocCompressMode    (xmlDocPtr doc,\n-                     int mode);\n+                xmlSetDocCompressMode   (xmlDocPtr doc,\n+                                         int mode);\n@@ -1302,1 +1253,1 @@\n-        xmlGetCompressMode    (void);\n+                xmlGetCompressMode      (void);\n@@ -1305,1 +1256,1 @@\n-        xmlSetCompressMode    (int mode);\n+                xmlSetCompressMode      (int mode);\n@@ -1311,1 +1262,1 @@\n-        xmlDOMWrapNewCtxt    (void);\n+                xmlDOMWrapNewCtxt       (void);\n@@ -1313,1 +1264,1 @@\n-        xmlDOMWrapFreeCtxt    (xmlDOMWrapCtxtPtr ctxt);\n+                xmlDOMWrapFreeCtxt      (xmlDOMWrapCtxtPtr ctxt);\n@@ -1315,3 +1266,3 @@\n-        xmlDOMWrapReconcileNamespaces(xmlDOMWrapCtxtPtr ctxt,\n-                     xmlNodePtr elem,\n-                     int options);\n+            xmlDOMWrapReconcileNamespaces(xmlDOMWrapCtxtPtr ctxt,\n+                                         xmlNodePtr elem,\n+                                         int options);\n@@ -1319,6 +1270,6 @@\n-        xmlDOMWrapAdoptNode        (xmlDOMWrapCtxtPtr ctxt,\n-                     xmlDocPtr sourceDoc,\n-                     xmlNodePtr node,\n-                     xmlDocPtr destDoc,\n-                     xmlNodePtr destParent,\n-                     int options);\n+            xmlDOMWrapAdoptNode         (xmlDOMWrapCtxtPtr ctxt,\n+                                         xmlDocPtr sourceDoc,\n+                                         xmlNodePtr node,\n+                                         xmlDocPtr destDoc,\n+                                         xmlNodePtr destParent,\n+                                         int options);\n@@ -1326,4 +1277,4 @@\n-        xmlDOMWrapRemoveNode    (xmlDOMWrapCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr node,\n-                     int options);\n+            xmlDOMWrapRemoveNode        (xmlDOMWrapCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr node,\n+                                         int options);\n@@ -1331,10 +1282,9 @@\n-        xmlDOMWrapCloneNode        (xmlDOMWrapCtxtPtr ctxt,\n-                     xmlDocPtr sourceDoc,\n-                     xmlNodePtr node,\n-                     xmlNodePtr *clonedNode,\n-                     xmlDocPtr destDoc,\n-                     xmlNodePtr destParent,\n-                     int deep,\n-                     int options);\n-\n-#ifdef LIBXML_TREE_ENABLED\n+            xmlDOMWrapCloneNode         (xmlDOMWrapCtxtPtr ctxt,\n+                                         xmlDocPtr sourceDoc,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr *clonedNode,\n+                                         xmlDocPtr destDoc,\n+                                         xmlNodePtr destParent,\n+                                         int deep,\n+                                         int options);\n+\n@@ -1355,1 +1305,0 @@\n-#endif\n@@ -1359,1 +1308,1 @@\n-        xmlRegisterNodeDefault    (xmlRegisterNodeFunc func);\n+            xmlRegisterNodeDefault      (xmlRegisterNodeFunc func);\n@@ -1362,1 +1311,1 @@\n-        xmlDeregisterNodeDefault    (xmlDeregisterNodeFunc func);\n+            xmlDeregisterNodeDefault    (xmlDeregisterNodeFunc func);\n@@ -1370,5 +1319,0 @@\n-XML_DEPRECATED XMLPUBFUN xmlBufferAllocationScheme\n-            xmlThrDefBufferAllocScheme  (xmlBufferAllocationScheme v);\n-XML_DEPRECATED XMLPUBFUN int\n-            xmlThrDefDefaultBufferSize  (int v);\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/tree.h","additions":528,"deletions":584,"binary":false,"changes":1112,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-    char *scheme;    \/* the URI scheme *\/\n-    char *opaque;    \/* opaque part *\/\n+    char *scheme;       \/* the URI scheme *\/\n+    char *opaque;       \/* opaque part *\/\n@@ -38,7 +38,7 @@\n-    char *server;    \/* the server part *\/\n-    char *user;        \/* the user part *\/\n-    int port;        \/* the port number *\/\n-    char *path;        \/* the path string *\/\n-    char *query;    \/* the query string (deprecated - use with caution) *\/\n-    char *fragment;    \/* the fragment identifier *\/\n-    int  cleanup;    \/* parsing potentially unclean URI *\/\n+    char *server;       \/* the server part *\/\n+    char *user;         \/* the user part *\/\n+    int port;           \/* the port number *\/\n+    char *path;         \/* the path string *\/\n+    char *query;        \/* the query string (deprecated - use with caution) *\/\n+    char *fragment;     \/* the fragment identifier *\/\n+    int  cleanup;       \/* parsing potentially unclean URI *\/\n@@ -50,1 +50,1 @@\n- * xmlChar *    xmlNodeGetBase    (xmlDocPtr doc,\n+ * xmlChar *    xmlNodeGetBase  (xmlDocPtr doc,\n@@ -54,1 +54,1 @@\n-        xmlCreateURI        (void);\n+                xmlCreateURI            (void);\n@@ -56,3 +56,3 @@\n-        xmlBuildURISafe        (const xmlChar *URI,\n-                     const xmlChar *base,\n-                     xmlChar **out);\n+                xmlBuildURISafe         (const xmlChar *URI,\n+                                         const xmlChar *base,\n+                                         xmlChar **out);\n@@ -60,2 +60,2 @@\n-        xmlBuildURI        (const xmlChar *URI,\n-                     const xmlChar *base);\n+                xmlBuildURI             (const xmlChar *URI,\n+                                         const xmlChar *base);\n@@ -63,3 +63,3 @@\n-        xmlBuildRelativeURISafe    (const xmlChar *URI,\n-                     const xmlChar *base,\n-                     xmlChar **out);\n+                xmlBuildRelativeURISafe (const xmlChar *URI,\n+                                         const xmlChar *base,\n+                                         xmlChar **out);\n@@ -67,2 +67,2 @@\n-        xmlBuildRelativeURI    (const xmlChar *URI,\n-                     const xmlChar *base);\n+                xmlBuildRelativeURI     (const xmlChar *URI,\n+                                         const xmlChar *base);\n@@ -70,1 +70,1 @@\n-        xmlParseURI        (const char *str);\n+                xmlParseURI             (const char *str);\n@@ -72,2 +72,2 @@\n-        xmlParseURISafe        (const char *str,\n-                     xmlURIPtr *uri);\n+                xmlParseURISafe         (const char *str,\n+                                         xmlURIPtr *uri);\n@@ -75,2 +75,2 @@\n-        xmlParseURIRaw        (const char *str,\n-                     int raw);\n+                xmlParseURIRaw          (const char *str,\n+                                         int raw);\n@@ -78,2 +78,2 @@\n-        xmlParseURIReference    (xmlURIPtr uri,\n-                     const char *str);\n+                xmlParseURIReference    (xmlURIPtr uri,\n+                                         const char *str);\n@@ -81,1 +81,1 @@\n-        xmlSaveUri        (xmlURIPtr uri);\n+                xmlSaveUri              (xmlURIPtr uri);\n@@ -83,2 +83,2 @@\n-        xmlPrintURI        (FILE *stream,\n-                     xmlURIPtr uri);\n+                xmlPrintURI             (FILE *stream,\n+                                         xmlURIPtr uri);\n@@ -86,2 +86,2 @@\n-        xmlURIEscapeStr         (const xmlChar *str,\n-                     const xmlChar *list);\n+                xmlURIEscapeStr         (const xmlChar *str,\n+                                         const xmlChar *list);\n@@ -89,3 +89,3 @@\n-        xmlURIUnescapeString    (const char *str,\n-                     int len,\n-                     char *target);\n+                xmlURIUnescapeString    (const char *str,\n+                                         int len,\n+                                         char *target);\n@@ -93,1 +93,1 @@\n-        xmlNormalizeURIPath    (char *path);\n+                xmlNormalizeURIPath     (char *path);\n@@ -95,1 +95,1 @@\n-        xmlURIEscape        (const xmlChar *str);\n+                xmlURIEscape            (const xmlChar *str);\n@@ -97,1 +97,1 @@\n-        xmlFreeURI        (xmlURIPtr uri);\n+                xmlFreeURI              (xmlURIPtr uri);\n@@ -99,1 +99,1 @@\n-        xmlCanonicPath        (const xmlChar *path);\n+                xmlCanonicPath          (const xmlChar *path);\n@@ -101,1 +101,1 @@\n-        xmlPathToURI        (const xmlChar *path);\n+                xmlPathToURI            (const xmlChar *path);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/uri.h","additions":41,"deletions":41,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -47,2 +47,2 @@\n-                 const char *msg,\n-                 ...) LIBXML_ATTR_FORMAT(2,3);\n+                             const char *msg,\n+                             ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -62,2 +62,2 @@\n-                   const char *msg,\n-                   ...) LIBXML_ATTR_FORMAT(2,3);\n+                               const char *msg,\n+                               ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -72,3 +72,3 @@\n-    void *userData;            \/* user specific data block *\/\n-    xmlValidityErrorFunc error;        \/* the callback in case of errors *\/\n-    xmlValidityWarningFunc warning;    \/* the callback in case of warning *\/\n+    void *userData;                     \/* user specific data block *\/\n+    xmlValidityErrorFunc error;         \/* the callback in case of errors *\/\n+    xmlValidityWarningFunc warning;     \/* the callback in case of warning *\/\n@@ -142,0 +142,1 @@\n+XML_DEPRECATED\n@@ -143,6 +144,6 @@\n-        xmlAddNotationDecl    (xmlValidCtxtPtr ctxt,\n-                     xmlDtdPtr dtd,\n-                     const xmlChar *name,\n-                     const xmlChar *PublicID,\n-                     const xmlChar *SystemID);\n-#ifdef LIBXML_TREE_ENABLED\n+                xmlAddNotationDecl      (xmlValidCtxtPtr ctxt,\n+                                         xmlDtdPtr dtd,\n+                                         const xmlChar *name,\n+                                         const xmlChar *PublicID,\n+                                         const xmlChar *SystemID);\n+XML_DEPRECATED\n@@ -150,2 +151,2 @@\n-        xmlCopyNotationTable    (xmlNotationTablePtr table);\n-#endif \/* LIBXML_TREE_ENABLED *\/\n+                xmlCopyNotationTable    (xmlNotationTablePtr table);\n+XML_DEPRECATED\n@@ -153,1 +154,1 @@\n-        xmlFreeNotationTable    (xmlNotationTablePtr table);\n+                xmlFreeNotationTable    (xmlNotationTablePtr table);\n@@ -157,2 +158,2 @@\n-        xmlDumpNotationDecl    (xmlBufferPtr buf,\n-                     xmlNotationPtr nota);\n+                xmlDumpNotationDecl     (xmlBufferPtr buf,\n+                                         xmlNotationPtr nota);\n@@ -161,2 +162,2 @@\n-        xmlDumpNotationTable    (xmlBufferPtr buf,\n-                     xmlNotationTablePtr table);\n+                xmlDumpNotationTable    (xmlBufferPtr buf,\n+                                         xmlNotationTablePtr table);\n@@ -167,0 +168,1 @@\n+XML_DEPRECATED\n@@ -168,2 +170,3 @@\n-        xmlNewElementContent    (const xmlChar *name,\n-                     xmlElementContentType type);\n+                xmlNewElementContent    (const xmlChar *name,\n+                                         xmlElementContentType type);\n+XML_DEPRECATED\n@@ -171,1 +174,2 @@\n-        xmlCopyElementContent    (xmlElementContentPtr content);\n+                xmlCopyElementContent   (xmlElementContentPtr content);\n+XML_DEPRECATED\n@@ -173,1 +177,1 @@\n-        xmlFreeElementContent    (xmlElementContentPtr cur);\n+                xmlFreeElementContent   (xmlElementContentPtr cur);\n@@ -175,0 +179,1 @@\n+XML_DEPRECATED\n@@ -176,3 +181,4 @@\n-        xmlNewDocElementContent    (xmlDocPtr doc,\n-                     const xmlChar *name,\n-                     xmlElementContentType type);\n+                xmlNewDocElementContent (xmlDocPtr doc,\n+                                         const xmlChar *name,\n+                                         xmlElementContentType type);\n+XML_DEPRECATED\n@@ -180,2 +186,3 @@\n-        xmlCopyDocElementContent(xmlDocPtr doc,\n-                     xmlElementContentPtr content);\n+                xmlCopyDocElementContent(xmlDocPtr doc,\n+                                         xmlElementContentPtr content);\n+XML_DEPRECATED\n@@ -183,2 +190,3 @@\n-        xmlFreeDocElementContent(xmlDocPtr doc,\n-                     xmlElementContentPtr cur);\n+                xmlFreeDocElementContent(xmlDocPtr doc,\n+                                         xmlElementContentPtr cur);\n+XML_DEPRECATED\n@@ -186,4 +194,4 @@\n-        xmlSnprintfElementContent(char *buf,\n-                     int size,\n-                                     xmlElementContentPtr content,\n-                     int englob);\n+                xmlSnprintfElementContent(char *buf,\n+                                         int size,\n+                                         xmlElementContentPtr content,\n+                                         int englob);\n@@ -193,3 +201,3 @@\n-        xmlSprintfElementContent(char *buf,\n-                                     xmlElementContentPtr content,\n-                     int englob);\n+                xmlSprintfElementContent(char *buf,\n+                                         xmlElementContentPtr content,\n+                                         int englob);\n@@ -199,0 +207,1 @@\n+XML_DEPRECATED\n@@ -200,6 +209,6 @@\n-        xmlAddElementDecl    (xmlValidCtxtPtr ctxt,\n-                     xmlDtdPtr dtd,\n-                     const xmlChar *name,\n-                     xmlElementTypeVal type,\n-                     xmlElementContentPtr content);\n-#ifdef LIBXML_TREE_ENABLED\n+                xmlAddElementDecl       (xmlValidCtxtPtr ctxt,\n+                                         xmlDtdPtr dtd,\n+                                         const xmlChar *name,\n+                                         xmlElementTypeVal type,\n+                                         xmlElementContentPtr content);\n+XML_DEPRECATED\n@@ -207,2 +216,2 @@\n-        xmlCopyElementTable    (xmlElementTablePtr table);\n-#endif \/* LIBXML_TREE_ENABLED *\/\n+                xmlCopyElementTable     (xmlElementTablePtr table);\n+XML_DEPRECATED\n@@ -210,1 +219,1 @@\n-        xmlFreeElementTable    (xmlElementTablePtr table);\n+                xmlFreeElementTable     (xmlElementTablePtr table);\n@@ -214,2 +223,2 @@\n-        xmlDumpElementTable    (xmlBufferPtr buf,\n-                     xmlElementTablePtr table);\n+                xmlDumpElementTable     (xmlBufferPtr buf,\n+                                         xmlElementTablePtr table);\n@@ -218,2 +227,2 @@\n-        xmlDumpElementDecl    (xmlBufferPtr buf,\n-                     xmlElementPtr elem);\n+                xmlDumpElementDecl      (xmlBufferPtr buf,\n+                                         xmlElementPtr elem);\n@@ -223,0 +232,1 @@\n+XML_DEPRECATED\n@@ -224,1 +234,2 @@\n-        xmlCreateEnumeration    (const xmlChar *name);\n+                xmlCreateEnumeration    (const xmlChar *name);\n+\/* XML_DEPRECATED, needed for custom attributeDecl SAX handler *\/\n@@ -226,2 +237,2 @@\n-        xmlFreeEnumeration    (xmlEnumerationPtr cur);\n-#ifdef LIBXML_TREE_ENABLED\n+                xmlFreeEnumeration      (xmlEnumerationPtr cur);\n+XML_DEPRECATED\n@@ -229,2 +240,1 @@\n-        xmlCopyEnumeration    (xmlEnumerationPtr cur);\n-#endif \/* LIBXML_TREE_ENABLED *\/\n+                xmlCopyEnumeration      (xmlEnumerationPtr cur);\n@@ -233,0 +243,1 @@\n+XML_DEPRECATED\n@@ -234,10 +245,10 @@\n-        xmlAddAttributeDecl    (xmlValidCtxtPtr ctxt,\n-                     xmlDtdPtr dtd,\n-                     const xmlChar *elem,\n-                     const xmlChar *name,\n-                     const xmlChar *ns,\n-                     xmlAttributeType type,\n-                     xmlAttributeDefault def,\n-                     const xmlChar *defaultValue,\n-                     xmlEnumerationPtr tree);\n-#ifdef LIBXML_TREE_ENABLED\n+                xmlAddAttributeDecl     (xmlValidCtxtPtr ctxt,\n+                                         xmlDtdPtr dtd,\n+                                         const xmlChar *elem,\n+                                         const xmlChar *name,\n+                                         const xmlChar *ns,\n+                                         xmlAttributeType type,\n+                                         xmlAttributeDefault def,\n+                                         const xmlChar *defaultValue,\n+                                         xmlEnumerationPtr tree);\n+XML_DEPRECATED\n@@ -245,2 +256,2 @@\n-        xmlCopyAttributeTable  (xmlAttributeTablePtr table);\n-#endif \/* LIBXML_TREE_ENABLED *\/\n+                xmlCopyAttributeTable  (xmlAttributeTablePtr table);\n+XML_DEPRECATED\n@@ -248,1 +259,1 @@\n-        xmlFreeAttributeTable  (xmlAttributeTablePtr table);\n+                xmlFreeAttributeTable  (xmlAttributeTablePtr table);\n@@ -252,2 +263,2 @@\n-        xmlDumpAttributeTable  (xmlBufferPtr buf,\n-                    xmlAttributeTablePtr table);\n+                xmlDumpAttributeTable  (xmlBufferPtr buf,\n+                                        xmlAttributeTablePtr table);\n@@ -256,2 +267,2 @@\n-        xmlDumpAttributeDecl   (xmlBufferPtr buf,\n-                    xmlAttributePtr attr);\n+                xmlDumpAttributeDecl   (xmlBufferPtr buf,\n+                                        xmlAttributePtr attr);\n@@ -262,2 +273,2 @@\n-        xmlAddIDSafe           (xmlAttrPtr attr,\n-                    const xmlChar *value);\n+                xmlAddIDSafe           (xmlAttrPtr attr,\n+                                        const xmlChar *value);\n@@ -265,4 +276,4 @@\n-        xmlAddID           (xmlValidCtxtPtr ctxt,\n-                    xmlDocPtr doc,\n-                    const xmlChar *value,\n-                    xmlAttrPtr attr);\n+                xmlAddID               (xmlValidCtxtPtr ctxt,\n+                                        xmlDocPtr doc,\n+                                        const xmlChar *value,\n+                                        xmlAttrPtr attr);\n@@ -270,1 +281,1 @@\n-        xmlFreeIDTable           (xmlIDTablePtr table);\n+                xmlFreeIDTable         (xmlIDTablePtr table);\n@@ -272,2 +283,2 @@\n-        xmlGetID           (xmlDocPtr doc,\n-                    const xmlChar *ID);\n+                xmlGetID               (xmlDocPtr doc,\n+                                        const xmlChar *ID);\n@@ -275,3 +286,3 @@\n-        xmlIsID               (xmlDocPtr doc,\n-                    xmlNodePtr elem,\n-                    xmlAttrPtr attr);\n+                xmlIsID                (xmlDocPtr doc,\n+                                        xmlNodePtr elem,\n+                                        xmlAttrPtr attr);\n@@ -279,2 +290,2 @@\n-        xmlRemoveID           (xmlDocPtr doc,\n-                    xmlAttrPtr attr);\n+                xmlRemoveID            (xmlDocPtr doc,\n+                                        xmlAttrPtr attr);\n@@ -285,4 +296,4 @@\n-        xmlAddRef           (xmlValidCtxtPtr ctxt,\n-                    xmlDocPtr doc,\n-                    const xmlChar *value,\n-                    xmlAttrPtr attr);\n+                xmlAddRef              (xmlValidCtxtPtr ctxt,\n+                                        xmlDocPtr doc,\n+                                        const xmlChar *value,\n+                                        xmlAttrPtr attr);\n@@ -291,1 +302,1 @@\n-        xmlFreeRefTable           (xmlRefTablePtr table);\n+                xmlFreeRefTable        (xmlRefTablePtr table);\n@@ -294,3 +305,3 @@\n-        xmlIsRef           (xmlDocPtr doc,\n-                    xmlNodePtr elem,\n-                    xmlAttrPtr attr);\n+                xmlIsRef               (xmlDocPtr doc,\n+                                        xmlNodePtr elem,\n+                                        xmlAttrPtr attr);\n@@ -299,2 +310,2 @@\n-        xmlRemoveRef           (xmlDocPtr doc,\n-                    xmlAttrPtr attr);\n+                xmlRemoveRef           (xmlDocPtr doc,\n+                                        xmlAttrPtr attr);\n@@ -303,2 +314,2 @@\n-        xmlGetRefs           (xmlDocPtr doc,\n-                    const xmlChar *ID);\n+                xmlGetRefs             (xmlDocPtr doc,\n+                                        const xmlChar *ID);\n@@ -312,1 +323,1 @@\n-        xmlNewValidCtxt(void);\n+                xmlNewValidCtxt(void);\n@@ -314,1 +325,1 @@\n-        xmlFreeValidCtxt(xmlValidCtxtPtr);\n+                xmlFreeValidCtxt(xmlValidCtxtPtr);\n@@ -318,2 +329,2 @@\n-        xmlValidateRoot        (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc);\n+                xmlValidateRoot         (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc);\n@@ -322,3 +333,3 @@\n-        xmlValidateElementDecl    (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                                 xmlElementPtr elem);\n+                xmlValidateElementDecl  (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlElementPtr elem);\n@@ -327,4 +338,4 @@\n-        xmlValidNormalizeAttributeValue(xmlDocPtr doc,\n-                     xmlNodePtr elem,\n-                     const xmlChar *name,\n-                     const xmlChar *value);\n+                xmlValidNormalizeAttributeValue(xmlDocPtr doc,\n+                                         xmlNodePtr elem,\n+                                         const xmlChar *name,\n+                                         const xmlChar *value);\n@@ -333,5 +344,5 @@\n-        xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem,\n-                     const xmlChar *name,\n-                     const xmlChar *value);\n+                xmlValidCtxtNormalizeAttributeValue(xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem,\n+                                         const xmlChar *name,\n+                                         const xmlChar *value);\n@@ -340,3 +351,3 @@\n-        xmlValidateAttributeDecl(xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                                 xmlAttributePtr attr);\n+                xmlValidateAttributeDecl(xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlAttributePtr attr);\n@@ -345,2 +356,2 @@\n-        xmlValidateAttributeValue(xmlAttributeType type,\n-                     const xmlChar *value);\n+                xmlValidateAttributeValue(xmlAttributeType type,\n+                                         const xmlChar *value);\n@@ -349,3 +360,3 @@\n-        xmlValidateNotationDecl    (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                                 xmlNotationPtr nota);\n+                xmlValidateNotationDecl (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNotationPtr nota);\n@@ -353,3 +364,3 @@\n-        xmlValidateDtd        (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlDtdPtr dtd);\n+                xmlValidateDtd          (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlDtdPtr dtd);\n@@ -358,2 +369,2 @@\n-        xmlValidateDtdFinal    (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc);\n+                xmlValidateDtdFinal     (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc);\n@@ -361,2 +372,2 @@\n-        xmlValidateDocument    (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc);\n+                xmlValidateDocument     (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc);\n@@ -364,3 +375,3 @@\n-        xmlValidateElement    (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem);\n+                xmlValidateElement      (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem);\n@@ -369,3 +380,3 @@\n-        xmlValidateOneElement    (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                                 xmlNodePtr elem);\n+                xmlValidateOneElement   (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem);\n@@ -374,5 +385,5 @@\n-        xmlValidateOneAttribute    (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr    elem,\n-                     xmlAttrPtr attr,\n-                     const xmlChar *value);\n+                xmlValidateOneAttribute (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr     elem,\n+                                         xmlAttrPtr attr,\n+                                         const xmlChar *value);\n@@ -381,6 +392,6 @@\n-        xmlValidateOneNamespace    (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem,\n-                     const xmlChar *prefix,\n-                     xmlNsPtr ns,\n-                     const xmlChar *value);\n+                xmlValidateOneNamespace (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem,\n+                                         const xmlChar *prefix,\n+                                         xmlNsPtr ns,\n+                                         const xmlChar *value);\n@@ -389,5 +400,2 @@\n-        xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc);\n-#endif \/* LIBXML_VALID_ENABLED *\/\n-\n-#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n+                xmlValidateDocumentFinal(xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc);\n@@ -396,4 +404,4 @@\n-        xmlValidateNotationUse    (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     const xmlChar *notationName);\n-#endif \/* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED *\/\n+                xmlValidateNotationUse  (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         const xmlChar *notationName);\n+#endif \/* LIBXML_VALID_ENABLED *\/\n@@ -402,2 +410,2 @@\n-        xmlIsMixedElement    (xmlDocPtr doc,\n-                     const xmlChar *name);\n+                xmlIsMixedElement       (xmlDocPtr doc,\n+                                         const xmlChar *name);\n@@ -405,3 +413,3 @@\n-        xmlGetDtdAttrDesc    (xmlDtdPtr dtd,\n-                     const xmlChar *elem,\n-                     const xmlChar *name);\n+                xmlGetDtdAttrDesc       (xmlDtdPtr dtd,\n+                                         const xmlChar *elem,\n+                                         const xmlChar *name);\n@@ -409,4 +417,4 @@\n-        xmlGetDtdQAttrDesc    (xmlDtdPtr dtd,\n-                     const xmlChar *elem,\n-                     const xmlChar *name,\n-                     const xmlChar *prefix);\n+                xmlGetDtdQAttrDesc      (xmlDtdPtr dtd,\n+                                         const xmlChar *elem,\n+                                         const xmlChar *name,\n+                                         const xmlChar *prefix);\n@@ -414,2 +422,2 @@\n-        xmlGetDtdNotationDesc    (xmlDtdPtr dtd,\n-                     const xmlChar *name);\n+                xmlGetDtdNotationDesc   (xmlDtdPtr dtd,\n+                                         const xmlChar *name);\n@@ -417,3 +425,3 @@\n-        xmlGetDtdQElementDesc    (xmlDtdPtr dtd,\n-                     const xmlChar *name,\n-                     const xmlChar *prefix);\n+                xmlGetDtdQElementDesc   (xmlDtdPtr dtd,\n+                                         const xmlChar *name,\n+                                         const xmlChar *prefix);\n@@ -421,2 +429,2 @@\n-        xmlGetDtdElementDesc    (xmlDtdPtr dtd,\n-                     const xmlChar *name);\n+                xmlGetDtdElementDesc    (xmlDtdPtr dtd,\n+                                         const xmlChar *name);\n@@ -427,4 +435,4 @@\n-        xmlValidGetPotentialChildren(xmlElementContent *ctree,\n-                     const xmlChar **names,\n-                     int *len,\n-                     int max);\n+                xmlValidGetPotentialChildren(xmlElementContent *ctree,\n+                                         const xmlChar **names,\n+                                         int *len,\n+                                         int max);\n@@ -433,4 +441,4 @@\n-        xmlValidGetValidElements(xmlNode *prev,\n-                     xmlNode *next,\n-                     const xmlChar **names,\n-                     int max);\n+                xmlValidGetValidElements(xmlNode *prev,\n+                                         xmlNode *next,\n+                                         const xmlChar **names,\n+                                         int max);\n@@ -438,1 +446,1 @@\n-        xmlValidateNameValue    (const xmlChar *value);\n+                xmlValidateNameValue    (const xmlChar *value);\n@@ -440,1 +448,1 @@\n-        xmlValidateNamesValue    (const xmlChar *value);\n+                xmlValidateNamesValue   (const xmlChar *value);\n@@ -442,1 +450,1 @@\n-        xmlValidateNmtokenValue    (const xmlChar *value);\n+                xmlValidateNmtokenValue (const xmlChar *value);\n@@ -444,1 +452,1 @@\n-        xmlValidateNmtokensValue(const xmlChar *value);\n+                xmlValidateNmtokensValue(const xmlChar *value);\n@@ -452,2 +460,2 @@\n-        xmlValidBuildContentModel(xmlValidCtxtPtr ctxt,\n-                     xmlElementPtr elem);\n+                xmlValidBuildContentModel(xmlValidCtxtPtr ctxt,\n+                                         xmlElementPtr elem);\n@@ -457,4 +465,4 @@\n-        xmlValidatePushElement    (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem,\n-                     const xmlChar *qname);\n+                xmlValidatePushElement  (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem,\n+                                         const xmlChar *qname);\n@@ -463,3 +471,3 @@\n-        xmlValidatePushCData    (xmlValidCtxtPtr ctxt,\n-                     const xmlChar *data,\n-                     int len);\n+                xmlValidatePushCData    (xmlValidCtxtPtr ctxt,\n+                                         const xmlChar *data,\n+                                         int len);\n@@ -468,4 +476,4 @@\n-        xmlValidatePopElement    (xmlValidCtxtPtr ctxt,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr elem,\n-                     const xmlChar *qname);\n+                xmlValidatePopElement   (xmlValidCtxtPtr ctxt,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr elem,\n+                                         const xmlChar *qname);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/valid.h","additions":205,"deletions":197,"binary":false,"changes":402,"status":"modified"},{"patch":"@@ -19,0 +19,1 @@\n+#include <libxml\/parser.h>\n@@ -94,1 +95,1 @@\n-        xmlXIncludeProcess    (xmlDocPtr doc);\n+                xmlXIncludeProcess      (xmlDocPtr doc);\n@@ -96,2 +97,2 @@\n-        xmlXIncludeProcessFlags    (xmlDocPtr doc,\n-                     int flags);\n+                xmlXIncludeProcessFlags (xmlDocPtr doc,\n+                                         int flags);\n@@ -99,3 +100,3 @@\n-        xmlXIncludeProcessFlagsData(xmlDocPtr doc,\n-                     int flags,\n-                     void *data);\n+                xmlXIncludeProcessFlagsData(xmlDocPtr doc,\n+                                         int flags,\n+                                         void *data);\n@@ -107,1 +108,1 @@\n-        xmlXIncludeProcessTree    (xmlNodePtr tree);\n+                xmlXIncludeProcessTree  (xmlNodePtr tree);\n@@ -109,2 +110,2 @@\n-        xmlXIncludeProcessTreeFlags(xmlNodePtr tree,\n-                     int flags);\n+                xmlXIncludeProcessTreeFlags(xmlNodePtr tree,\n+                                         int flags);\n@@ -115,1 +116,1 @@\n-        xmlXIncludeNewContext    (xmlDocPtr doc);\n+                xmlXIncludeNewContext   (xmlDocPtr doc);\n@@ -117,2 +118,2 @@\n-        xmlXIncludeSetFlags    (xmlXIncludeCtxtPtr ctxt,\n-                     int flags);\n+                xmlXIncludeSetFlags     (xmlXIncludeCtxtPtr ctxt,\n+                                         int flags);\n@@ -120,3 +121,7 @@\n-        xmlXIncludeSetErrorHandler(xmlXIncludeCtxtPtr ctxt,\n-                     xmlStructuredErrorFunc handler,\n-                     void *data);\n+                xmlXIncludeSetErrorHandler(xmlXIncludeCtxtPtr ctxt,\n+                                         xmlStructuredErrorFunc handler,\n+                                         void *data);\n+XMLPUBFUN void\n+                xmlXIncludeSetResourceLoader(xmlXIncludeCtxtPtr ctxt,\n+                                         xmlResourceLoader loader,\n+                                         void *data);\n@@ -124,1 +129,1 @@\n-        xmlXIncludeGetLastError    (xmlXIncludeCtxtPtr ctxt);\n+                xmlXIncludeGetLastError (xmlXIncludeCtxtPtr ctxt);\n@@ -126,1 +131,1 @@\n-        xmlXIncludeFreeContext    (xmlXIncludeCtxtPtr ctxt);\n+                xmlXIncludeFreeContext  (xmlXIncludeCtxtPtr ctxt);\n@@ -128,2 +133,2 @@\n-        xmlXIncludeProcessNode    (xmlXIncludeCtxtPtr ctxt,\n-                     xmlNodePtr tree);\n+                xmlXIncludeProcessNode  (xmlXIncludeCtxtPtr ctxt,\n+                                         xmlNodePtr tree);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xinclude.h","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -82,5 +82,5 @@\n-(*xlinkSimpleLinkFunk)    (void *ctx,\n-             xmlNodePtr node,\n-             const xlinkHRef href,\n-             const xlinkRole role,\n-             const xlinkTitle title);\n+(*xlinkSimpleLinkFunk)  (void *ctx,\n+                         xmlNodePtr node,\n+                         const xlinkHRef href,\n+                         const xlinkRole role,\n+                         const xlinkTitle title);\n@@ -108,12 +108,12 @@\n-             xmlNodePtr node,\n-             int nbLocators,\n-             const xlinkHRef *hrefs,\n-             const xlinkRole *roles,\n-             int nbArcs,\n-             const xlinkRole *from,\n-             const xlinkRole *to,\n-             xlinkShow *show,\n-             xlinkActuate *actuate,\n-             int nbTitles,\n-             const xlinkTitle *titles,\n-             const xmlChar **langs);\n+                         xmlNodePtr node,\n+                         int nbLocators,\n+                         const xlinkHRef *hrefs,\n+                         const xlinkRole *roles,\n+                         int nbArcs,\n+                         const xlinkRole *from,\n+                         const xlinkRole *to,\n+                         xlinkShow *show,\n+                         xlinkActuate *actuate,\n+                         int nbTitles,\n+                         const xlinkTitle *titles,\n+                         const xmlChar **langs);\n@@ -135,8 +135,8 @@\n-(*xlinkExtendedLinkSetFunk)    (void *ctx,\n-                 xmlNodePtr node,\n-                 int nbLocators,\n-                 const xlinkHRef *hrefs,\n-                 const xlinkRole *roles,\n-                 int nbTitles,\n-                 const xlinkTitle *titles,\n-                 const xmlChar **langs);\n+(*xlinkExtendedLinkSetFunk)     (void *ctx,\n+                                 xmlNodePtr node,\n+                                 int nbLocators,\n+                                 const xlinkHRef *hrefs,\n+                                 const xlinkRole *roles,\n+                                 int nbTitles,\n+                                 const xlinkTitle *titles,\n+                                 const xmlChar **langs);\n@@ -163,0 +163,1 @@\n+XML_DEPRECATED\n@@ -164,1 +165,2 @@\n-        xlinkGetDefaultDetect    (void);\n+                xlinkGetDefaultDetect   (void);\n+XML_DEPRECATED\n@@ -166,1 +168,1 @@\n-        xlinkSetDefaultDetect    (xlinkNodeDetectFunc func);\n+                xlinkSetDefaultDetect   (xlinkNodeDetectFunc func);\n@@ -171,0 +173,1 @@\n+XML_DEPRECATED\n@@ -172,1 +175,2 @@\n-        xlinkGetDefaultHandler    (void);\n+                xlinkGetDefaultHandler  (void);\n+XML_DEPRECATED\n@@ -174,1 +178,1 @@\n-        xlinkSetDefaultHandler    (xlinkHandlerPtr handler);\n+                xlinkSetDefaultHandler  (xlinkHandlerPtr handler);\n@@ -180,2 +184,2 @@\n-        xlinkIsLink        (xmlDocPtr doc,\n-                     xmlNodePtr node);\n+                xlinkIsLink             (xmlDocPtr doc,\n+                                         xmlNodePtr node);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xlink.h","additions":35,"deletions":31,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-    int    compressed;        \/* -1=unknown, 0=not compressed, 1=compressed *\/\n+    int compressed;         \/* -1=unknown, 0=not compressed, 1=compressed *\/\n@@ -179,9 +179,6 @@\n-#define XML_GLOBALS_IO \\\n-  XML_OP(xmlParserInputBufferCreateFilenameValue, \\\n-           xmlParserInputBufferCreateFilenameFunc, XML_DEPRECATED) \\\n-  XML_OP(xmlOutputBufferCreateFilenameValue, \\\n-           xmlOutputBufferCreateFilenameFunc, XML_DEPRECATED)\n-\n-#define XML_OP XML_DECLARE_GLOBAL\n-XML_GLOBALS_IO\n-#undef XML_OP\n+XML_DEPRECATED\n+XMLPUBFUN xmlParserInputBufferCreateFilenameFunc *\n+__xmlParserInputBufferCreateFilenameValue(void);\n+XML_DEPRECATED\n+XMLPUBFUN xmlOutputBufferCreateFilenameFunc *\n+__xmlOutputBufferCreateFilenameValue(void);\n@@ -189,1 +186,1 @@\n-#if defined(LIBXML_THREAD_ENABLED) && !defined(XML_GLOBALS_NO_REDEFINITION)\n+#ifndef XML_GLOBALS_NO_REDEFINITION\n@@ -191,1 +188,1 @@\n-    XML_GLOBAL_MACRO(xmlParserInputBufferCreateFilenameValue)\n+    (*__xmlParserInputBufferCreateFilenameValue())\n@@ -193,1 +190,1 @@\n-    XML_GLOBAL_MACRO(xmlOutputBufferCreateFilenameValue)\n+    (*__xmlOutputBufferCreateFilenameValue())\n@@ -201,1 +198,1 @@\n-    xmlCleanupInputCallbacks        (void);\n+        xmlCleanupInputCallbacks                (void);\n@@ -204,1 +201,1 @@\n-    xmlPopInputCallbacks            (void);\n+        xmlPopInputCallbacks                    (void);\n@@ -207,1 +204,1 @@\n-    xmlRegisterDefaultInputCallbacks    (void);\n+        xmlRegisterDefaultInputCallbacks        (void);\n@@ -209,1 +206,1 @@\n-    xmlAllocParserInputBuffer        (xmlCharEncoding enc);\n+        xmlAllocParserInputBuffer               (xmlCharEncoding enc);\n@@ -212,1 +209,1 @@\n-    xmlParserInputBufferCreateFilename    (const char *URI,\n+        xmlParserInputBufferCreateFilename      (const char *URI,\n@@ -214,0 +211,1 @@\n+XML_DEPRECATED\n@@ -215,1 +213,1 @@\n-    xmlParserInputBufferCreateFile        (FILE *file,\n+        xmlParserInputBufferCreateFile          (FILE *file,\n@@ -218,2 +216,2 @@\n-    xmlParserInputBufferCreateFd        (int fd,\n-                                             xmlCharEncoding enc);\n+        xmlParserInputBufferCreateFd            (int fd,\n+                                                 xmlCharEncoding enc);\n@@ -221,2 +219,2 @@\n-    xmlParserInputBufferCreateMem        (const char *mem, int size,\n-                                             xmlCharEncoding enc);\n+        xmlParserInputBufferCreateMem           (const char *mem, int size,\n+                                                 xmlCharEncoding enc);\n@@ -224,2 +222,2 @@\n-    xmlParserInputBufferCreateStatic    (const char *mem, int size,\n-                                             xmlCharEncoding enc);\n+        xmlParserInputBufferCreateStatic        (const char *mem, int size,\n+                                                 xmlCharEncoding enc);\n@@ -227,4 +225,5 @@\n-    xmlParserInputBufferCreateIO        (xmlInputReadCallback   ioread,\n-                         xmlInputCloseCallback  ioclose,\n-                         void *ioctx,\n-                                             xmlCharEncoding enc);\n+        xmlParserInputBufferCreateIO            (xmlInputReadCallback   ioread,\n+                                                 xmlInputCloseCallback  ioclose,\n+                                                 void *ioctx,\n+                                                 xmlCharEncoding enc);\n+XML_DEPRECATED\n@@ -232,2 +231,3 @@\n-    xmlParserInputBufferRead        (xmlParserInputBufferPtr in,\n-                         int len);\n+        xmlParserInputBufferRead                (xmlParserInputBufferPtr in,\n+                                                 int len);\n+XML_DEPRECATED\n@@ -235,2 +235,3 @@\n-    xmlParserInputBufferGrow        (xmlParserInputBufferPtr in,\n-                         int len);\n+        xmlParserInputBufferGrow                (xmlParserInputBufferPtr in,\n+                                                 int len);\n+XML_DEPRECATED\n@@ -238,3 +239,3 @@\n-    xmlParserInputBufferPush        (xmlParserInputBufferPtr in,\n-                         int len,\n-                         const char *buf);\n+        xmlParserInputBufferPush                (xmlParserInputBufferPtr in,\n+                                                 int len,\n+                                                 const char *buf);\n@@ -242,1 +243,1 @@\n-    xmlFreeParserInputBuffer        (xmlParserInputBufferPtr in);\n+        xmlFreeParserInputBuffer                (xmlParserInputBufferPtr in);\n@@ -244,1 +245,1 @@\n-    xmlParserGetDirectory            (const char *filename);\n+        xmlParserGetDirectory                   (const char *filename);\n@@ -247,4 +248,4 @@\n-    xmlRegisterInputCallbacks        (xmlInputMatchCallback matchFunc,\n-                         xmlInputOpenCallback openFunc,\n-                         xmlInputReadCallback readFunc,\n-                         xmlInputCloseCallback closeFunc);\n+        xmlRegisterInputCallbacks               (xmlInputMatchCallback matchFunc,\n+                                                 xmlInputOpenCallback openFunc,\n+                                                 xmlInputReadCallback readFunc,\n+                                                 xmlInputCloseCallback closeFunc);\n@@ -252,3 +253,3 @@\n-xmlParserInputBufferPtr\n-    __xmlParserInputBufferCreateFilename(const char *URI,\n-                        xmlCharEncoding enc);\n+XMLPUBFUN xmlParserInputBufferPtr\n+        __xmlParserInputBufferCreateFilename(const char *URI,\n+                                                xmlCharEncoding enc);\n@@ -261,1 +262,1 @@\n-    xmlCleanupOutputCallbacks        (void);\n+        xmlCleanupOutputCallbacks               (void);\n@@ -263,1 +264,1 @@\n-    xmlPopOutputCallbacks            (void);\n+        xmlPopOutputCallbacks                   (void);\n@@ -265,1 +266,1 @@\n-    xmlRegisterDefaultOutputCallbacks(void);\n+        xmlRegisterDefaultOutputCallbacks(void);\n@@ -267,1 +268,1 @@\n-    xmlAllocOutputBuffer        (xmlCharEncodingHandlerPtr encoder);\n+        xmlAllocOutputBuffer            (xmlCharEncodingHandlerPtr encoder);\n@@ -270,3 +271,3 @@\n-    xmlOutputBufferCreateFilename    (const char *URI,\n-                     xmlCharEncodingHandlerPtr encoder,\n-                     int compression);\n+        xmlOutputBufferCreateFilename   (const char *URI,\n+                                         xmlCharEncodingHandlerPtr encoder,\n+                                         int compression);\n@@ -275,2 +276,2 @@\n-    xmlOutputBufferCreateFile    (FILE *file,\n-                     xmlCharEncodingHandlerPtr encoder);\n+        xmlOutputBufferCreateFile       (FILE *file,\n+                                         xmlCharEncodingHandlerPtr encoder);\n@@ -279,2 +280,2 @@\n-    xmlOutputBufferCreateBuffer    (xmlBufferPtr buffer,\n-                     xmlCharEncodingHandlerPtr encoder);\n+        xmlOutputBufferCreateBuffer     (xmlBufferPtr buffer,\n+                                         xmlCharEncodingHandlerPtr encoder);\n@@ -283,2 +284,2 @@\n-    xmlOutputBufferCreateFd        (int fd,\n-                     xmlCharEncodingHandlerPtr encoder);\n+        xmlOutputBufferCreateFd         (int fd,\n+                                         xmlCharEncodingHandlerPtr encoder);\n@@ -287,4 +288,4 @@\n-    xmlOutputBufferCreateIO        (xmlOutputWriteCallback   iowrite,\n-                     xmlOutputCloseCallback  ioclose,\n-                     void *ioctx,\n-                     xmlCharEncodingHandlerPtr encoder);\n+        xmlOutputBufferCreateIO         (xmlOutputWriteCallback   iowrite,\n+                                         xmlOutputCloseCallback  ioclose,\n+                                         void *ioctx,\n+                                         xmlCharEncodingHandlerPtr encoder);\n@@ -299,3 +300,3 @@\n-    xmlOutputBufferWrite        (xmlOutputBufferPtr out,\n-                     int len,\n-                     const char *buf);\n+        xmlOutputBufferWrite            (xmlOutputBufferPtr out,\n+                                         int len,\n+                                         const char *buf);\n@@ -303,2 +304,2 @@\n-    xmlOutputBufferWriteString    (xmlOutputBufferPtr out,\n-                     const char *str);\n+        xmlOutputBufferWriteString      (xmlOutputBufferPtr out,\n+                                         const char *str);\n@@ -306,3 +307,3 @@\n-    xmlOutputBufferWriteEscape    (xmlOutputBufferPtr out,\n-                     const xmlChar *str,\n-                     xmlCharEncodingOutputFunc escaping);\n+        xmlOutputBufferWriteEscape      (xmlOutputBufferPtr out,\n+                                         const xmlChar *str,\n+                                         xmlCharEncodingOutputFunc escaping);\n@@ -311,1 +312,1 @@\n-    xmlOutputBufferFlush        (xmlOutputBufferPtr out);\n+        xmlOutputBufferFlush            (xmlOutputBufferPtr out);\n@@ -313,1 +314,1 @@\n-    xmlOutputBufferClose        (xmlOutputBufferPtr out);\n+        xmlOutputBufferClose            (xmlOutputBufferPtr out);\n@@ -316,4 +317,4 @@\n-    xmlRegisterOutputCallbacks    (xmlOutputMatchCallback matchFunc,\n-                     xmlOutputOpenCallback openFunc,\n-                     xmlOutputWriteCallback writeFunc,\n-                     xmlOutputCloseCallback closeFunc);\n+        xmlRegisterOutputCallbacks      (xmlOutputMatchCallback matchFunc,\n+                                         xmlOutputOpenCallback openFunc,\n+                                         xmlOutputWriteCallback writeFunc,\n+                                         xmlOutputCloseCallback closeFunc);\n@@ -321,2 +322,2 @@\n-xmlOutputBufferPtr\n-    __xmlOutputBufferCreateFilename(const char *URI,\n+XMLPUBFUN xmlOutputBufferPtr\n+        __xmlOutputBufferCreateFilename(const char *URI,\n@@ -330,1 +331,1 @@\n-    xmlRegisterHTTPPostCallbacks    (void );\n+        xmlRegisterHTTPPostCallbacks    (void );\n@@ -337,2 +338,2 @@\n-    xmlCheckHTTPInput        (xmlParserCtxtPtr ctxt,\n-                     xmlParserInputPtr ret);\n+        xmlCheckHTTPInput               (xmlParserCtxtPtr ctxt,\n+                                         xmlParserInputPtr ret);\n@@ -344,3 +345,3 @@\n-    xmlNoNetExternalEntityLoader    (const char *URL,\n-                     const char *ID,\n-                     xmlParserCtxtPtr ctxt);\n+        xmlNoNetExternalEntityLoader    (const char *URL,\n+                                         const char *ID,\n+                                         xmlParserCtxtPtr ctxt);\n@@ -350,1 +351,1 @@\n-    xmlNormalizeWindowsPath        (const xmlChar *path);\n+        xmlNormalizeWindowsPath         (const xmlChar *path);\n@@ -354,1 +355,1 @@\n-    xmlCheckFilename        (const char *path);\n+        xmlCheckFilename                (const char *path);\n@@ -360,1 +361,1 @@\n-    xmlFileMatch            (const char *filename);\n+        xmlFileMatch                    (const char *filename);\n@@ -363,1 +364,1 @@\n-    xmlFileOpen            (const char *filename);\n+        xmlFileOpen                     (const char *filename);\n@@ -366,3 +367,3 @@\n-    xmlFileRead            (void * context,\n-                     char * buffer,\n-                     int len);\n+        xmlFileRead                     (void * context,\n+                                         char * buffer,\n+                                         int len);\n@@ -371,1 +372,1 @@\n-    xmlFileClose            (void * context);\n+        xmlFileClose                    (void * context);\n@@ -379,1 +380,1 @@\n-    xmlIOHTTPMatch            (const char *filename);\n+        xmlIOHTTPMatch                  (const char *filename);\n@@ -382,1 +383,1 @@\n-    xmlIOHTTPOpen            (const char *filename);\n+        xmlIOHTTPOpen                   (const char *filename);\n@@ -386,2 +387,2 @@\n-    xmlIOHTTPOpenW            (const char * post_uri,\n-                     int   compression );\n+        xmlIOHTTPOpenW                  (const char * post_uri,\n+                                         int   compression );\n@@ -391,3 +392,3 @@\n-    xmlIOHTTPRead            (void * context,\n-                     char * buffer,\n-                     int len);\n+        xmlIOHTTPRead                   (void * context,\n+                                         char * buffer,\n+                                         int len);\n@@ -396,1 +397,1 @@\n-    xmlIOHTTPClose            (void * context);\n+        xmlIOHTTPClose                  (void * context);\n@@ -399,20 +400,0 @@\n-\/**\n- * Default 'ftp:\/\/' protocol callbacks\n- *\/\n-#if defined(LIBXML_FTP_ENABLED)\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlIOFTPMatch            (const char *filename);\n-XML_DEPRECATED\n-XMLPUBFUN void *\n-    xmlIOFTPOpen            (const char *filename);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlIOFTPRead            (void * context,\n-                     char * buffer,\n-                     int len);\n-XML_DEPRECATED\n-XMLPUBFUN int\n-    xmlIOFTPClose            (void * context);\n-#endif \/* defined(LIBXML_FTP_ENABLED) *\/\n-\n@@ -420,2 +401,2 @@\n-    xmlParserInputBufferCreateFilenameDefault(\n-        xmlParserInputBufferCreateFilenameFunc func);\n+        xmlParserInputBufferCreateFilenameDefault(\n+                xmlParserInputBufferCreateFilenameFunc func);\n@@ -423,2 +404,2 @@\n-    xmlOutputBufferCreateFilenameDefault(\n-        xmlOutputBufferCreateFilenameFunc func);\n+        xmlOutputBufferCreateFilenameDefault(\n+                xmlOutputBufferCreateFilenameFunc func);\n@@ -427,2 +408,2 @@\n-    xmlThrDefOutputBufferCreateFilenameDefault(\n-        xmlOutputBufferCreateFilenameFunc func);\n+        xmlThrDefOutputBufferCreateFilenameDefault(\n+                xmlOutputBufferCreateFilenameFunc func);\n@@ -431,2 +412,2 @@\n-    xmlThrDefParserInputBufferCreateFilenameDefault(\n-        xmlParserInputBufferCreateFilenameFunc func);\n+        xmlThrDefParserInputBufferCreateFilenameDefault(\n+                xmlParserInputBufferCreateFilenameFunc func);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlIO.h","additions":109,"deletions":128,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -16,1 +16,0 @@\n-#ifdef LIBXML_AUTOMATA_ENABLED\n@@ -43,0 +42,1 @@\n+XML_DEPRECATED\n@@ -44,1 +44,2 @@\n-            xmlNewAutomata        (void);\n+                    xmlNewAutomata              (void);\n+XML_DEPRECATED\n@@ -46,1 +47,1 @@\n-            xmlFreeAutomata        (xmlAutomataPtr am);\n+                    xmlFreeAutomata             (xmlAutomataPtr am);\n@@ -48,0 +49,1 @@\n+XML_DEPRECATED\n@@ -49,1 +51,2 @@\n-            xmlAutomataGetInitState    (xmlAutomataPtr am);\n+                    xmlAutomataGetInitState     (xmlAutomataPtr am);\n+XML_DEPRECATED\n@@ -51,2 +54,3 @@\n-            xmlAutomataSetFinalState    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr state);\n+                    xmlAutomataSetFinalState    (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr state);\n+XML_DEPRECATED\n@@ -54,1 +58,2 @@\n-            xmlAutomataNewState        (xmlAutomataPtr am);\n+                    xmlAutomataNewState         (xmlAutomataPtr am);\n+XML_DEPRECATED\n@@ -56,5 +61,6 @@\n-            xmlAutomataNewTransition    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         const xmlChar *token,\n-                         void *data);\n+                    xmlAutomataNewTransition    (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 const xmlChar *token,\n+                                                 void *data);\n+XML_DEPRECATED\n@@ -62,6 +68,7 @@\n-            xmlAutomataNewTransition2    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         const xmlChar *token,\n-                         const xmlChar *token2,\n-                         void *data);\n+                    xmlAutomataNewTransition2   (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 const xmlChar *token,\n+                                                 const xmlChar *token2,\n+                                                 void *data);\n+XML_DEPRECATED\n@@ -69,6 +76,6 @@\n-                    xmlAutomataNewNegTrans    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         const xmlChar *token,\n-                         const xmlChar *token2,\n-                         void *data);\n+                    xmlAutomataNewNegTrans      (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 const xmlChar *token,\n+                                                 const xmlChar *token2,\n+                                                 void *data);\n@@ -76,0 +83,1 @@\n+XML_DEPRECATED\n@@ -77,7 +85,8 @@\n-            xmlAutomataNewCountTrans    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         const xmlChar *token,\n-                         int min,\n-                         int max,\n-                         void *data);\n+                    xmlAutomataNewCountTrans    (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 const xmlChar *token,\n+                                                 int min,\n+                                                 int max,\n+                                                 void *data);\n+XML_DEPRECATED\n@@ -85,8 +94,9 @@\n-            xmlAutomataNewCountTrans2    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         const xmlChar *token,\n-                         const xmlChar *token2,\n-                         int min,\n-                         int max,\n-                         void *data);\n+                    xmlAutomataNewCountTrans2   (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 const xmlChar *token,\n+                                                 const xmlChar *token2,\n+                                                 int min,\n+                                                 int max,\n+                                                 void *data);\n+XML_DEPRECATED\n@@ -94,7 +104,8 @@\n-            xmlAutomataNewOnceTrans    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         const xmlChar *token,\n-                         int min,\n-                         int max,\n-                         void *data);\n+                    xmlAutomataNewOnceTrans     (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 const xmlChar *token,\n+                                                 int min,\n+                                                 int max,\n+                                                 void *data);\n+XML_DEPRECATED\n@@ -102,8 +113,9 @@\n-            xmlAutomataNewOnceTrans2    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         const xmlChar *token,\n-                         const xmlChar *token2,\n-                         int min,\n-                         int max,\n-                         void *data);\n+                    xmlAutomataNewOnceTrans2    (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 const xmlChar *token,\n+                                                 const xmlChar *token2,\n+                                                 int min,\n+                                                 int max,\n+                                                 void *data);\n+XML_DEPRECATED\n@@ -111,4 +123,5 @@\n-            xmlAutomataNewAllTrans    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         int lax);\n+                    xmlAutomataNewAllTrans      (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 int lax);\n+XML_DEPRECATED\n@@ -116,3 +129,4 @@\n-            xmlAutomataNewEpsilon    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to);\n+                    xmlAutomataNewEpsilon       (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to);\n+XML_DEPRECATED\n@@ -120,4 +134,5 @@\n-            xmlAutomataNewCountedTrans    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         int counter);\n+                    xmlAutomataNewCountedTrans  (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 int counter);\n+XML_DEPRECATED\n@@ -125,4 +140,5 @@\n-            xmlAutomataNewCounterTrans    (xmlAutomataPtr am,\n-                         xmlAutomataStatePtr from,\n-                         xmlAutomataStatePtr to,\n-                         int counter);\n+                    xmlAutomataNewCounterTrans  (xmlAutomataPtr am,\n+                                                 xmlAutomataStatePtr from,\n+                                                 xmlAutomataStatePtr to,\n+                                                 int counter);\n+XML_DEPRECATED\n@@ -130,3 +146,3 @@\n-            xmlAutomataNewCounter    (xmlAutomataPtr am,\n-                         int min,\n-                         int max);\n+                    xmlAutomataNewCounter       (xmlAutomataPtr am,\n+                                                 int min,\n+                                                 int max);\n@@ -134,0 +150,1 @@\n+XML_DEPRECATED\n@@ -135,1 +152,2 @@\n-            xmlAutomataCompile        (xmlAutomataPtr am);\n+                    xmlAutomataCompile          (xmlAutomataPtr am);\n+XML_DEPRECATED\n@@ -137,1 +155,1 @@\n-            xmlAutomataIsDeterminist    (xmlAutomataPtr am);\n+                    xmlAutomataIsDeterminist    (xmlAutomataPtr am);\n@@ -143,1 +161,0 @@\n-#endif \/* LIBXML_AUTOMATA_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlautomata.h","additions":92,"deletions":75,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -19,0 +19,6 @@\n+\/*\n+ * Backward compatibility\n+ *\/\n+#define initGenericErrorDefaultFunc(h) \\\n+    xmlSetGenericErrorFunc(NULL, (h) ? *(h) : NULL)\n+\n@@ -26,3 +32,3 @@\n-    XML_ERR_WARNING = 1,    \/* A simple warning *\/\n-    XML_ERR_ERROR = 2,        \/* A recoverable error *\/\n-    XML_ERR_FATAL = 3        \/* A fatal error *\/\n+    XML_ERR_WARNING = 1,        \/* A simple warning *\/\n+    XML_ERR_ERROR = 2,          \/* A recoverable error *\/\n+    XML_ERR_FATAL = 3           \/* A fatal error *\/\n@@ -39,4 +45,4 @@\n-    XML_FROM_TREE,    \/* The tree module *\/\n-    XML_FROM_NAMESPACE,    \/* The XML Namespace module *\/\n-    XML_FROM_DTD,    \/* The XML DTD validation with parser context*\/\n-    XML_FROM_HTML,    \/* The HTML parser *\/\n+    XML_FROM_TREE,      \/* The tree module *\/\n+    XML_FROM_NAMESPACE, \/* The XML Namespace module *\/\n+    XML_FROM_DTD,       \/* The XML DTD validation with parser context*\/\n+    XML_FROM_HTML,      \/* The HTML parser *\/\n@@ -45,6 +51,6 @@\n-    XML_FROM_IO,    \/* The Input\/Output stack *\/\n-    XML_FROM_FTP,    \/* The FTP module *\/\n-    XML_FROM_HTTP,    \/* The HTTP module *\/\n-    XML_FROM_XINCLUDE,    \/* The XInclude processing *\/\n-    XML_FROM_XPATH,    \/* The XPath module *\/\n-    XML_FROM_XPOINTER,    \/* The XPointer module *\/\n+    XML_FROM_IO,        \/* The Input\/Output stack *\/\n+    XML_FROM_FTP,       \/* The FTP module *\/\n+    XML_FROM_HTTP,      \/* The HTTP module *\/\n+    XML_FROM_XINCLUDE,  \/* The XInclude processing *\/\n+    XML_FROM_XPATH,     \/* The XPath module *\/\n+    XML_FROM_XPOINTER,  \/* The XPointer module *\/\n@@ -52,10 +58,10 @@\n-    XML_FROM_DATATYPE,    \/* The W3C XML Schemas Datatype module *\/\n-    XML_FROM_SCHEMASP,    \/* The W3C XML Schemas parser module *\/\n-    XML_FROM_SCHEMASV,    \/* The W3C XML Schemas validation module *\/\n-    XML_FROM_RELAXNGP,    \/* The Relax-NG parser module *\/\n-    XML_FROM_RELAXNGV,    \/* The Relax-NG validator module *\/\n-    XML_FROM_CATALOG,    \/* The Catalog module *\/\n-    XML_FROM_C14N,    \/* The Canonicalization module *\/\n-    XML_FROM_XSLT,    \/* The XSLT engine from libxslt *\/\n-    XML_FROM_VALID,    \/* The XML DTD validation with valid context *\/\n-    XML_FROM_CHECK,    \/* The error checking module *\/\n+    XML_FROM_DATATYPE,  \/* The W3C XML Schemas Datatype module *\/\n+    XML_FROM_SCHEMASP,  \/* The W3C XML Schemas parser module *\/\n+    XML_FROM_SCHEMASV,  \/* The W3C XML Schemas validation module *\/\n+    XML_FROM_RELAXNGP,  \/* The Relax-NG parser module *\/\n+    XML_FROM_RELAXNGV,  \/* The Relax-NG validator module *\/\n+    XML_FROM_CATALOG,   \/* The Catalog module *\/\n+    XML_FROM_C14N,      \/* The Canonicalization module *\/\n+    XML_FROM_XSLT,      \/* The XSLT engine from libxslt *\/\n+    XML_FROM_VALID,     \/* The XML DTD validation with valid context *\/\n+    XML_FROM_CHECK,     \/* The error checking module *\/\n@@ -64,1 +70,1 @@\n-    XML_FROM_I18N,    \/* The module handling character conversion *\/\n+    XML_FROM_I18N,      \/* The module handling character conversion *\/\n@@ -79,2 +85,2 @@\n-    int        domain;    \/* What part of the library raised this error *\/\n-    int        code;    \/* The error code, e.g. an xmlParserError *\/\n+    int         domain; \/* What part of the library raised this error *\/\n+    int         code;   \/* The error code, e.g. an xmlParserError *\/\n@@ -83,7 +89,7 @@\n-    char       *file;    \/* the filename *\/\n-    int        line;    \/* the line number if available *\/\n-    char       *str1;    \/* extra string information *\/\n-    char       *str2;    \/* extra string information *\/\n-    char       *str3;    \/* extra string information *\/\n-    int        int1;    \/* extra number information *\/\n-    int        int2;    \/* error column # or 0 if N\/A (todo: rename field when we would brk ABI) *\/\n+    char       *file;   \/* the filename *\/\n+    int         line;   \/* the line number if available *\/\n+    char       *str1;   \/* extra string information *\/\n+    char       *str2;   \/* extra string information *\/\n+    char       *str3;   \/* extra string information *\/\n+    int         int1;   \/* extra number information *\/\n+    int         int2;   \/* error column # or 0 if N\/A (todo: rename field when we would brk ABI) *\/\n@@ -855,2 +861,2 @@\n-                 const char *msg,\n-                 ...) LIBXML_ATTR_FORMAT(2,3);\n+                                 const char *msg,\n+                                 ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -868,6 +874,2 @@\n-#define XML_GLOBALS_ERROR \\\n-  XML_OP(xmlLastError, xmlError, XML_DEPRECATED) \\\n-  XML_OP(xmlGenericError, xmlGenericErrorFunc, XML_NO_ATTR) \\\n-  XML_OP(xmlGenericErrorContext, void *, XML_NO_ATTR) \\\n-  XML_OP(xmlStructuredError, xmlStructuredErrorFunc, XML_NO_ATTR) \\\n-  XML_OP(xmlStructuredErrorContext, void *, XML_NO_ATTR)\n+XML_DEPRECATED\n+XMLPUBFUN const xmlError *__xmlLastError(void);\n@@ -875,3 +877,4 @@\n-#define XML_OP XML_DECLARE_GLOBAL\n-XML_GLOBALS_ERROR\n-#undef XML_OP\n+XMLPUBFUN xmlGenericErrorFunc *__xmlGenericError(void);\n+XMLPUBFUN void **__xmlGenericErrorContext(void);\n+XMLPUBFUN xmlStructuredErrorFunc *__xmlStructuredError(void);\n+XMLPUBFUN void **__xmlStructuredErrorContext(void);\n@@ -879,6 +882,6 @@\n-#if defined(LIBXML_THREAD_ENABLED) && !defined(XML_GLOBALS_NO_REDEFINITION)\n-  #define xmlLastError XML_GLOBAL_MACRO(xmlLastError)\n-  #define xmlGenericError XML_GLOBAL_MACRO(xmlGenericError)\n-  #define xmlGenericErrorContext XML_GLOBAL_MACRO(xmlGenericErrorContext)\n-  #define xmlStructuredError XML_GLOBAL_MACRO(xmlStructuredError)\n-  #define xmlStructuredErrorContext XML_GLOBAL_MACRO(xmlStructuredErrorContext)\n+#ifndef XML_GLOBALS_NO_REDEFINITION\n+  #define xmlLastError (*__xmlLastError())\n+  #define xmlGenericError (*__xmlGenericError())\n+  #define xmlGenericErrorContext (*__xmlGenericErrorContext())\n+  #define xmlStructuredError (*__xmlStructuredError())\n+  #define xmlStructuredErrorContext (*__xmlStructuredErrorContext())\n@@ -893,2 +896,2 @@\n-    xmlSetGenericErrorFunc    (void *ctx,\n-                 xmlGenericErrorFunc handler);\n+    xmlSetGenericErrorFunc      (void *ctx,\n+                                 xmlGenericErrorFunc handler);\n@@ -899,3 +902,0 @@\n-XML_DEPRECATED\n-XMLPUBFUN void\n-    initGenericErrorDefaultFunc    (xmlGenericErrorFunc *handler);\n@@ -904,2 +904,2 @@\n-    xmlSetStructuredErrorFunc    (void *ctx,\n-                 xmlStructuredErrorFunc handler);\n+    xmlSetStructuredErrorFunc   (void *ctx,\n+                                 xmlStructuredErrorFunc handler);\n@@ -915,3 +915,3 @@\n-    xmlParserError        (void *ctx,\n-                 const char *msg,\n-                 ...) LIBXML_ATTR_FORMAT(2,3);\n+    xmlParserError              (void *ctx,\n+                                 const char *msg,\n+                                 ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -919,3 +919,3 @@\n-    xmlParserWarning        (void *ctx,\n-                 const char *msg,\n-                 ...) LIBXML_ATTR_FORMAT(2,3);\n+    xmlParserWarning            (void *ctx,\n+                                 const char *msg,\n+                                 ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -923,3 +923,3 @@\n-    xmlParserValidityError    (void *ctx,\n-                 const char *msg,\n-                 ...) LIBXML_ATTR_FORMAT(2,3);\n+    xmlParserValidityError      (void *ctx,\n+                                 const char *msg,\n+                                 ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -928,2 +928,2 @@\n-                 const char *msg,\n-                 ...) LIBXML_ATTR_FORMAT(2,3);\n+                                 const char *msg,\n+                                 ...) LIBXML_ATTR_FORMAT(2,3);\n@@ -934,1 +934,1 @@\n-    xmlParserPrintFileInfo    (struct _xmlParserInput *input);\n+    xmlParserPrintFileInfo      (struct _xmlParserInput *input);\n@@ -936,1 +936,1 @@\n-    xmlParserPrintFileContext    (struct _xmlParserInput *input);\n+    xmlParserPrintFileContext   (struct _xmlParserInput *input);\n@@ -938,3 +938,3 @@\n-xmlFormatError            (const xmlError *err,\n-                 xmlGenericErrorFunc channel,\n-                 void *data);\n+xmlFormatError                  (const xmlError *err,\n+                                 xmlGenericErrorFunc channel,\n+                                 void *data);\n@@ -946,1 +946,1 @@\n-    xmlGetLastError        (void);\n+    xmlGetLastError             (void);\n@@ -948,1 +948,1 @@\n-    xmlResetLastError        (void);\n+    xmlResetLastError           (void);\n@@ -950,1 +950,1 @@\n-    xmlCtxtGetLastError        (void *ctx);\n+    xmlCtxtGetLastError         (void *ctx);\n@@ -952,1 +952,1 @@\n-    xmlCtxtResetLastError    (void *ctx);\n+    xmlCtxtResetLastError       (void *ctx);\n@@ -954,1 +954,1 @@\n-    xmlResetError        (xmlErrorPtr err);\n+    xmlResetError               (xmlErrorPtr err);\n@@ -956,2 +956,2 @@\n-    xmlCopyError        (const xmlError *from,\n-                 xmlErrorPtr to);\n+    xmlCopyError                (const xmlError *from,\n+                                 xmlErrorPtr to);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlerror.h","additions":80,"deletions":80,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -44,8 +44,0 @@\n-#ifndef ATTRIBUTE_UNUSED\n-  #if __GNUC__ * 100 + __GNUC_MINOR__ >= 207 || defined(__clang__)\n-    #define ATTRIBUTE_UNUSED __attribute__((unused))\n-  #else\n-    #define ATTRIBUTE_UNUSED\n-  #endif\n-#endif\n-\n@@ -78,17 +70,5 @@\n-\/*\n- * Warnings pragmas, should be moved from public headers\n- *\/\n-\n-#if defined(__LCC__)\n-\n-  #define XML_IGNORE_FPTR_CAST_WARNINGS\n-  #define XML_POP_WARNINGS \\\n-    _Pragma(\"diag_default 1215\")\n-\n-#elif defined(__clang__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 406)\n-\n-  #if defined(__clang__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 800)\n-    #define XML_IGNORE_FPTR_CAST_WARNINGS \\\n-      _Pragma(\"GCC diagnostic push\") \\\n-      _Pragma(\"GCC diagnostic ignored \\\"-Wpedantic\\\"\") \\\n-      _Pragma(\"GCC diagnostic ignored \\\"-Wcast-function-type\\\"\")\n+#ifndef XML_DEPRECATED_MEMBER\n+  #if defined(IN_LIBXML)\n+    #define XML_DEPRECATED_MEMBER\n+  #elif __GNUC__ * 100 + __GNUC_MINOR__ >= 301\n+    #define XML_DEPRECATED_MEMBER __attribute__((deprecated))\n@@ -96,3 +76,1 @@\n-    #define XML_IGNORE_FPTR_CAST_WARNINGS \\\n-      _Pragma(\"GCC diagnostic push\") \\\n-      _Pragma(\"GCC diagnostic ignored \\\"-Wpedantic\\\"\")\n+    #define XML_DEPRECATED_MEMBER\n@@ -100,28 +78,0 @@\n-  #define XML_POP_WARNINGS \\\n-    _Pragma(\"GCC diagnostic pop\")\n-\n-#elif defined(_MSC_VER) && _MSC_VER >= 1400\n-\n-  #define XML_IGNORE_FPTR_CAST_WARNINGS __pragma(warning(push))\n-  #define XML_POP_WARNINGS __pragma(warning(pop))\n-\n-#else\n-\n-  #define XML_IGNORE_FPTR_CAST_WARNINGS\n-  #define XML_POP_WARNINGS\n-\n-#endif\n-\n-\/*\n- * Accessors for globals\n- *\/\n-\n-#define XML_NO_ATTR\n-\n-#ifdef LIBXML_THREAD_ENABLED\n-  #define XML_DECLARE_GLOBAL(name, type, attrs) \\\n-    attrs XMLPUBFUN type *__##name(void);\n-  #define XML_GLOBAL_MACRO(name) (*__##name())\n-#else\n-  #define XML_DECLARE_GLOBAL(name, type, attrs) \\\n-    attrs XMLPUBVAR type name;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlexports.h","additions":6,"deletions":56,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-\/** DOC_DISABLE *\/\n@@ -74,18 +73,15 @@\n-  #define XML_GLOBALS_ALLOC \\\n-    XML_OP(xmlMalloc, xmlMallocFunc, XML_NO_ATTR) \\\n-    XML_OP(xmlMallocAtomic, xmlMallocFunc, XML_NO_ATTR) \\\n-    XML_OP(xmlRealloc, xmlReallocFunc, XML_NO_ATTR) \\\n-    XML_OP(xmlFree, xmlFreeFunc, XML_NO_ATTR) \\\n-    XML_OP(xmlMemStrdup, xmlStrdupFunc, XML_NO_ATTR)\n-  #define XML_OP XML_DECLARE_GLOBAL\n-    XML_GLOBALS_ALLOC\n-  #undef XML_OP\n-  #if defined(LIBXML_THREAD_ENABLED) && !defined(XML_GLOBALS_NO_REDEFINITION)\n-    #define xmlMalloc XML_GLOBAL_MACRO(xmlMalloc)\n-    #define xmlMallocAtomic XML_GLOBAL_MACRO(xmlMallocAtomic)\n-    #define xmlRealloc XML_GLOBAL_MACRO(xmlRealloc)\n-    #define xmlFree XML_GLOBAL_MACRO(xmlFree)\n-    #define xmlMemStrdup XML_GLOBAL_MACRO(xmlMemStrdup)\n-  #endif\n-#else\n-  #define XML_GLOBALS_ALLOC\n+\n+\/** DOC_DISABLE *\/\n+XMLPUBFUN xmlMallocFunc *__xmlMalloc(void);\n+XMLPUBFUN xmlMallocFunc *__xmlMallocAtomic(void);\n+XMLPUBFUN xmlReallocFunc *__xmlRealloc(void);\n+XMLPUBFUN xmlFreeFunc *__xmlFree(void);\n+XMLPUBFUN xmlStrdupFunc *__xmlMemStrdup(void);\n+\n+#ifndef XML_GLOBALS_NO_REDEFINITION\n+  #define xmlMalloc (*__xmlMalloc())\n+  #define xmlMallocAtomic (*__xmlMallocAtomic())\n+  #define xmlRealloc (*__xmlRealloc())\n+  #define xmlFree (*__xmlFree())\n+  #define xmlMemStrdup (*__xmlMemStrdup())\n+#endif\n@@ -93,0 +89,2 @@\n+\n+#else\n@@ -106,4 +104,4 @@\n-    xmlMemSetup    (xmlFreeFunc freeFunc,\n-             xmlMallocFunc mallocFunc,\n-             xmlReallocFunc reallocFunc,\n-             xmlStrdupFunc strdupFunc);\n+        xmlMemSetup     (xmlFreeFunc freeFunc,\n+                         xmlMallocFunc mallocFunc,\n+                         xmlReallocFunc reallocFunc,\n+                         xmlStrdupFunc strdupFunc);\n@@ -111,4 +109,5 @@\n-    xmlMemGet    (xmlFreeFunc *freeFunc,\n-             xmlMallocFunc *mallocFunc,\n-             xmlReallocFunc *reallocFunc,\n-             xmlStrdupFunc *strdupFunc);\n+        xmlMemGet       (xmlFreeFunc *freeFunc,\n+                         xmlMallocFunc *mallocFunc,\n+                         xmlReallocFunc *reallocFunc,\n+                         xmlStrdupFunc *strdupFunc);\n+XML_DEPRECATED\n@@ -116,5 +115,6 @@\n-    xmlGcMemSetup    (xmlFreeFunc freeFunc,\n-             xmlMallocFunc mallocFunc,\n-             xmlMallocFunc mallocAtomicFunc,\n-             xmlReallocFunc reallocFunc,\n-             xmlStrdupFunc strdupFunc);\n+        xmlGcMemSetup   (xmlFreeFunc freeFunc,\n+                         xmlMallocFunc mallocFunc,\n+                         xmlMallocFunc mallocAtomicFunc,\n+                         xmlReallocFunc reallocFunc,\n+                         xmlStrdupFunc strdupFunc);\n+XML_DEPRECATED\n@@ -122,5 +122,5 @@\n-    xmlGcMemGet    (xmlFreeFunc *freeFunc,\n-             xmlMallocFunc *mallocFunc,\n-             xmlMallocFunc *mallocAtomicFunc,\n-             xmlReallocFunc *reallocFunc,\n-             xmlStrdupFunc *strdupFunc);\n+        xmlGcMemGet     (xmlFreeFunc *freeFunc,\n+                         xmlMallocFunc *mallocFunc,\n+                         xmlMallocFunc *mallocAtomicFunc,\n+                         xmlReallocFunc *reallocFunc,\n+                         xmlStrdupFunc *strdupFunc);\n@@ -133,1 +133,1 @@\n-    xmlInitMemory    (void);\n+        xmlInitMemory   (void);\n@@ -145,1 +145,1 @@\n-    xmlMemSize    (void *ptr);\n+        xmlMemSize      (void *ptr);\n@@ -147,1 +147,1 @@\n-    xmlMemUsed    (void);\n+        xmlMemUsed      (void);\n@@ -149,1 +149,1 @@\n-    xmlMemBlocks    (void);\n+        xmlMemBlocks    (void);\n@@ -152,1 +152,1 @@\n-    xmlMemDisplay    (FILE *fp);\n+        xmlMemDisplay   (FILE *fp);\n@@ -155,1 +155,1 @@\n-    xmlMemDisplayLast(FILE *fp, long nbBytes);\n+        xmlMemDisplayLast(FILE *fp, long nbBytes);\n@@ -158,1 +158,1 @@\n-    xmlMemShow    (FILE *fp, int nr);\n+        xmlMemShow      (FILE *fp, int nr);\n@@ -161,1 +161,1 @@\n-    xmlMemoryDump    (void);\n+        xmlMemoryDump   (void);\n@@ -163,1 +163,1 @@\n-    xmlMemMalloc    (size_t size) LIBXML_ATTR_ALLOC_SIZE(1);\n+        xmlMemMalloc    (size_t size) LIBXML_ATTR_ALLOC_SIZE(1);\n@@ -165,1 +165,1 @@\n-    xmlMemRealloc    (void *ptr,size_t size);\n+        xmlMemRealloc   (void *ptr,size_t size);\n@@ -167,1 +167,1 @@\n-    xmlMemFree    (void *ptr);\n+        xmlMemFree      (void *ptr);\n@@ -169,1 +169,1 @@\n-    xmlMemoryStrdup    (const char *str);\n+        xmlMemoryStrdup (const char *str);\n@@ -172,1 +172,1 @@\n-    xmlMallocLoc    (size_t size, const char *file, int line) LIBXML_ATTR_ALLOC_SIZE(1);\n+        xmlMallocLoc    (size_t size, const char *file, int line) LIBXML_ATTR_ALLOC_SIZE(1);\n@@ -175,1 +175,1 @@\n-    xmlReallocLoc    (void *ptr, size_t size, const char *file, int line);\n+        xmlReallocLoc   (void *ptr, size_t size, const char *file, int line);\n@@ -178,1 +178,1 @@\n-    xmlMallocAtomicLoc (size_t size, const char *file, int line) LIBXML_ATTR_ALLOC_SIZE(1);\n+        xmlMallocAtomicLoc (size_t size, const char *file, int line) LIBXML_ATTR_ALLOC_SIZE(1);\n@@ -181,1 +181,1 @@\n-    xmlMemStrdupLoc    (const char *str, const char *file, int line);\n+        xmlMemStrdupLoc (const char *str, const char *file, int line);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlmemory.h","additions":53,"deletions":53,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-    XML_MODULE_LAZY = 1,    \/* lazy binding *\/\n-    XML_MODULE_LOCAL= 2        \/* local binding *\/\n+    XML_MODULE_LAZY = 1,        \/* lazy binding *\/\n+    XML_MODULE_LOCAL= 2         \/* local binding *\/\n@@ -40,0 +40,1 @@\n+XML_DEPRECATED\n@@ -41,1 +42,1 @@\n-                         int options);\n+                                                 int options);\n@@ -43,3 +44,4 @@\n-XMLPUBFUN int xmlModuleSymbol        (xmlModulePtr module,\n-                         const char* name,\n-                         void **result);\n+XML_DEPRECATED\n+XMLPUBFUN int xmlModuleSymbol           (xmlModulePtr module,\n+                                                 const char* name,\n+                                                 void **result);\n@@ -47,1 +49,2 @@\n-XMLPUBFUN int xmlModuleClose        (xmlModulePtr module);\n+XML_DEPRECATED\n+XMLPUBFUN int xmlModuleClose            (xmlModulePtr module);\n@@ -49,1 +52,2 @@\n-XMLPUBFUN int xmlModuleFree        (xmlModulePtr module);\n+XML_DEPRECATED\n+XMLPUBFUN int xmlModuleFree             (xmlModulePtr module);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlmodule.h","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -19,0 +19,2 @@\n+#endif\n+#ifdef LIBXML_SCHEMAS_ENABLED\n@@ -21,1 +23,0 @@\n-\/* for compatibility *\/\n@@ -115,2 +116,2 @@\n-            xmlNewTextReader    (xmlParserInputBufferPtr input,\n-                                             const char *URI);\n+                        xmlNewTextReader        (xmlParserInputBufferPtr input,\n+                                                 const char *URI);\n@@ -118,1 +119,1 @@\n-            xmlNewTextReaderFilename(const char *URI);\n+                        xmlNewTextReaderFilename(const char *URI);\n@@ -121,1 +122,1 @@\n-            xmlFreeTextReader    (xmlTextReaderPtr reader);\n+                        xmlFreeTextReader       (xmlTextReaderPtr reader);\n@@ -137,1 +138,1 @@\n-            xmlTextReaderRead    (xmlTextReaderPtr reader);\n+                        xmlTextReaderRead       (xmlTextReaderPtr reader);\n@@ -141,1 +142,1 @@\n-            xmlTextReaderReadInnerXml(xmlTextReaderPtr reader);\n+                        xmlTextReaderReadInnerXml(xmlTextReaderPtr reader);\n@@ -144,1 +145,1 @@\n-            xmlTextReaderReadOuterXml(xmlTextReaderPtr reader);\n+                        xmlTextReaderReadOuterXml(xmlTextReaderPtr reader);\n@@ -148,1 +149,1 @@\n-            xmlTextReaderReadString    (xmlTextReaderPtr reader);\n+                        xmlTextReaderReadString (xmlTextReaderPtr reader);\n@@ -150,1 +151,1 @@\n-            xmlTextReaderReadAttributeValue(xmlTextReaderPtr reader);\n+                        xmlTextReaderReadAttributeValue(xmlTextReaderPtr reader);\n@@ -156,1 +157,1 @@\n-            xmlTextReaderAttributeCount(xmlTextReaderPtr reader);\n+                        xmlTextReaderAttributeCount(xmlTextReaderPtr reader);\n@@ -158,1 +159,1 @@\n-            xmlTextReaderDepth    (xmlTextReaderPtr reader);\n+                        xmlTextReaderDepth      (xmlTextReaderPtr reader);\n@@ -160,1 +161,1 @@\n-            xmlTextReaderHasAttributes(xmlTextReaderPtr reader);\n+                        xmlTextReaderHasAttributes(xmlTextReaderPtr reader);\n@@ -162,1 +163,1 @@\n-            xmlTextReaderHasValue(xmlTextReaderPtr reader);\n+                        xmlTextReaderHasValue(xmlTextReaderPtr reader);\n@@ -164,1 +165,1 @@\n-            xmlTextReaderIsDefault    (xmlTextReaderPtr reader);\n+                        xmlTextReaderIsDefault  (xmlTextReaderPtr reader);\n@@ -166,1 +167,1 @@\n-            xmlTextReaderIsEmptyElement(xmlTextReaderPtr reader);\n+                        xmlTextReaderIsEmptyElement(xmlTextReaderPtr reader);\n@@ -168,1 +169,1 @@\n-            xmlTextReaderNodeType    (xmlTextReaderPtr reader);\n+                        xmlTextReaderNodeType   (xmlTextReaderPtr reader);\n@@ -170,1 +171,1 @@\n-            xmlTextReaderQuoteChar    (xmlTextReaderPtr reader);\n+                        xmlTextReaderQuoteChar  (xmlTextReaderPtr reader);\n@@ -172,1 +173,1 @@\n-            xmlTextReaderReadState    (xmlTextReaderPtr reader);\n+                        xmlTextReaderReadState  (xmlTextReaderPtr reader);\n@@ -177,1 +178,1 @@\n-            xmlTextReaderConstBaseUri    (xmlTextReaderPtr reader);\n+                    xmlTextReaderConstBaseUri   (xmlTextReaderPtr reader);\n@@ -179,1 +180,1 @@\n-            xmlTextReaderConstLocalName    (xmlTextReaderPtr reader);\n+                    xmlTextReaderConstLocalName (xmlTextReaderPtr reader);\n@@ -181,1 +182,1 @@\n-            xmlTextReaderConstName    (xmlTextReaderPtr reader);\n+                    xmlTextReaderConstName      (xmlTextReaderPtr reader);\n@@ -183,1 +184,1 @@\n-            xmlTextReaderConstNamespaceUri(xmlTextReaderPtr reader);\n+                    xmlTextReaderConstNamespaceUri(xmlTextReaderPtr reader);\n@@ -185,1 +186,1 @@\n-            xmlTextReaderConstPrefix    (xmlTextReaderPtr reader);\n+                    xmlTextReaderConstPrefix    (xmlTextReaderPtr reader);\n@@ -187,1 +188,1 @@\n-            xmlTextReaderConstXmlLang    (xmlTextReaderPtr reader);\n+                    xmlTextReaderConstXmlLang   (xmlTextReaderPtr reader);\n@@ -189,2 +190,2 @@\n-            xmlTextReaderConstString    (xmlTextReaderPtr reader,\n-                         const xmlChar *str);\n+                    xmlTextReaderConstString    (xmlTextReaderPtr reader,\n+                                                 const xmlChar *str);\n@@ -192,1 +193,1 @@\n-            xmlTextReaderConstValue    (xmlTextReaderPtr reader);\n+                    xmlTextReaderConstValue     (xmlTextReaderPtr reader);\n@@ -199,1 +200,1 @@\n-            xmlTextReaderBaseUri    (xmlTextReaderPtr reader);\n+                        xmlTextReaderBaseUri    (xmlTextReaderPtr reader);\n@@ -201,1 +202,1 @@\n-            xmlTextReaderLocalName    (xmlTextReaderPtr reader);\n+                        xmlTextReaderLocalName  (xmlTextReaderPtr reader);\n@@ -203,1 +204,1 @@\n-            xmlTextReaderName    (xmlTextReaderPtr reader);\n+                        xmlTextReaderName       (xmlTextReaderPtr reader);\n@@ -205,1 +206,1 @@\n-            xmlTextReaderNamespaceUri(xmlTextReaderPtr reader);\n+                        xmlTextReaderNamespaceUri(xmlTextReaderPtr reader);\n@@ -207,1 +208,1 @@\n-            xmlTextReaderPrefix    (xmlTextReaderPtr reader);\n+                        xmlTextReaderPrefix     (xmlTextReaderPtr reader);\n@@ -209,1 +210,1 @@\n-            xmlTextReaderXmlLang    (xmlTextReaderPtr reader);\n+                        xmlTextReaderXmlLang    (xmlTextReaderPtr reader);\n@@ -211,1 +212,1 @@\n-            xmlTextReaderValue    (xmlTextReaderPtr reader);\n+                        xmlTextReaderValue      (xmlTextReaderPtr reader);\n@@ -217,1 +218,1 @@\n-            xmlTextReaderClose        (xmlTextReaderPtr reader);\n+                    xmlTextReaderClose          (xmlTextReaderPtr reader);\n@@ -219,2 +220,2 @@\n-            xmlTextReaderGetAttributeNo    (xmlTextReaderPtr reader,\n-                         int no);\n+                    xmlTextReaderGetAttributeNo (xmlTextReaderPtr reader,\n+                                                 int no);\n@@ -222,2 +223,2 @@\n-            xmlTextReaderGetAttribute    (xmlTextReaderPtr reader,\n-                         const xmlChar *name);\n+                    xmlTextReaderGetAttribute   (xmlTextReaderPtr reader,\n+                                                 const xmlChar *name);\n@@ -225,3 +226,3 @@\n-            xmlTextReaderGetAttributeNs    (xmlTextReaderPtr reader,\n-                         const xmlChar *localName,\n-                         const xmlChar *namespaceURI);\n+                    xmlTextReaderGetAttributeNs (xmlTextReaderPtr reader,\n+                                                 const xmlChar *localName,\n+                                                 const xmlChar *namespaceURI);\n@@ -229,1 +230,1 @@\n-            xmlTextReaderGetRemainder    (xmlTextReaderPtr reader);\n+                    xmlTextReaderGetRemainder   (xmlTextReaderPtr reader);\n@@ -231,2 +232,2 @@\n-            xmlTextReaderLookupNamespace(xmlTextReaderPtr reader,\n-                         const xmlChar *prefix);\n+                    xmlTextReaderLookupNamespace(xmlTextReaderPtr reader,\n+                                                 const xmlChar *prefix);\n@@ -234,2 +235,2 @@\n-            xmlTextReaderMoveToAttributeNo(xmlTextReaderPtr reader,\n-                         int no);\n+                    xmlTextReaderMoveToAttributeNo(xmlTextReaderPtr reader,\n+                                                 int no);\n@@ -237,2 +238,2 @@\n-            xmlTextReaderMoveToAttribute(xmlTextReaderPtr reader,\n-                         const xmlChar *name);\n+                    xmlTextReaderMoveToAttribute(xmlTextReaderPtr reader,\n+                                                 const xmlChar *name);\n@@ -240,3 +241,3 @@\n-            xmlTextReaderMoveToAttributeNs(xmlTextReaderPtr reader,\n-                         const xmlChar *localName,\n-                         const xmlChar *namespaceURI);\n+                    xmlTextReaderMoveToAttributeNs(xmlTextReaderPtr reader,\n+                                                 const xmlChar *localName,\n+                                                 const xmlChar *namespaceURI);\n@@ -244,1 +245,1 @@\n-            xmlTextReaderMoveToFirstAttribute(xmlTextReaderPtr reader);\n+                    xmlTextReaderMoveToFirstAttribute(xmlTextReaderPtr reader);\n@@ -246,1 +247,1 @@\n-            xmlTextReaderMoveToNextAttribute(xmlTextReaderPtr reader);\n+                    xmlTextReaderMoveToNextAttribute(xmlTextReaderPtr reader);\n@@ -248,1 +249,1 @@\n-            xmlTextReaderMoveToElement    (xmlTextReaderPtr reader);\n+                    xmlTextReaderMoveToElement  (xmlTextReaderPtr reader);\n@@ -250,1 +251,1 @@\n-            xmlTextReaderNormalization    (xmlTextReaderPtr reader);\n+                    xmlTextReaderNormalization  (xmlTextReaderPtr reader);\n@@ -252,1 +253,1 @@\n-            xmlTextReaderConstEncoding  (xmlTextReaderPtr reader);\n+                    xmlTextReaderConstEncoding  (xmlTextReaderPtr reader);\n@@ -258,3 +259,3 @@\n-            xmlTextReaderSetParserProp    (xmlTextReaderPtr reader,\n-                         int prop,\n-                         int value);\n+                    xmlTextReaderSetParserProp  (xmlTextReaderPtr reader,\n+                                                 int prop,\n+                                                 int value);\n@@ -262,2 +263,2 @@\n-            xmlTextReaderGetParserProp    (xmlTextReaderPtr reader,\n-                         int prop);\n+                    xmlTextReaderGetParserProp  (xmlTextReaderPtr reader,\n+                                                 int prop);\n@@ -265,1 +266,1 @@\n-            xmlTextReaderCurrentNode    (xmlTextReaderPtr reader);\n+                    xmlTextReaderCurrentNode    (xmlTextReaderPtr reader);\n@@ -274,1 +275,1 @@\n-            xmlTextReaderPreserve    (xmlTextReaderPtr reader);\n+                    xmlTextReaderPreserve       (xmlTextReaderPtr reader);\n@@ -277,3 +278,3 @@\n-            xmlTextReaderPreservePattern(xmlTextReaderPtr reader,\n-                         const xmlChar *pattern,\n-                         const xmlChar **namespaces);\n+                    xmlTextReaderPreservePattern(xmlTextReaderPtr reader,\n+                                                 const xmlChar *pattern,\n+                                                 const xmlChar **namespaces);\n@@ -282,1 +283,1 @@\n-            xmlTextReaderCurrentDoc    (xmlTextReaderPtr reader);\n+                    xmlTextReaderCurrentDoc     (xmlTextReaderPtr reader);\n@@ -284,1 +285,1 @@\n-            xmlTextReaderExpand        (xmlTextReaderPtr reader);\n+                    xmlTextReaderExpand         (xmlTextReaderPtr reader);\n@@ -286,1 +287,1 @@\n-            xmlTextReaderNext        (xmlTextReaderPtr reader);\n+                    xmlTextReaderNext           (xmlTextReaderPtr reader);\n@@ -288,1 +289,1 @@\n-            xmlTextReaderNextSibling    (xmlTextReaderPtr reader);\n+                    xmlTextReaderNextSibling    (xmlTextReaderPtr reader);\n@@ -290,2 +291,2 @@\n-            xmlTextReaderIsValid    (xmlTextReaderPtr reader);\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+                    xmlTextReaderIsValid        (xmlTextReaderPtr reader);\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -293,2 +294,2 @@\n-            xmlTextReaderRelaxNGValidate(xmlTextReaderPtr reader,\n-                         const char *rng);\n+                    xmlTextReaderRelaxNGValidate(xmlTextReaderPtr reader,\n+                                                 const char *rng);\n@@ -296,3 +297,3 @@\n-            xmlTextReaderRelaxNGValidateCtxt(xmlTextReaderPtr reader,\n-                         xmlRelaxNGValidCtxtPtr ctxt,\n-                         int options);\n+                    xmlTextReaderRelaxNGValidateCtxt(xmlTextReaderPtr reader,\n+                                                 xmlRelaxNGValidCtxtPtr ctxt,\n+                                                 int options);\n@@ -301,2 +302,4 @@\n-            xmlTextReaderRelaxNGSetSchema(xmlTextReaderPtr reader,\n-                         xmlRelaxNGPtr schema);\n+                    xmlTextReaderRelaxNGSetSchema(xmlTextReaderPtr reader,\n+                                                 xmlRelaxNGPtr schema);\n+#endif\n+#ifdef LIBXML_SCHEMAS_ENABLED\n@@ -304,2 +307,2 @@\n-            xmlTextReaderSchemaValidate    (xmlTextReaderPtr reader,\n-                         const char *xsd);\n+                    xmlTextReaderSchemaValidate (xmlTextReaderPtr reader,\n+                                                 const char *xsd);\n@@ -307,3 +310,3 @@\n-            xmlTextReaderSchemaValidateCtxt(xmlTextReaderPtr reader,\n-                         xmlSchemaValidCtxtPtr ctxt,\n-                         int options);\n+                    xmlTextReaderSchemaValidateCtxt(xmlTextReaderPtr reader,\n+                                                 xmlSchemaValidCtxtPtr ctxt,\n+                                                 int options);\n@@ -311,2 +314,2 @@\n-            xmlTextReaderSetSchema    (xmlTextReaderPtr reader,\n-                         xmlSchemaPtr schema);\n+                    xmlTextReaderSetSchema      (xmlTextReaderPtr reader,\n+                                                 xmlSchemaPtr schema);\n@@ -315,1 +318,1 @@\n-            xmlTextReaderConstXmlVersion(xmlTextReaderPtr reader);\n+                    xmlTextReaderConstXmlVersion(xmlTextReaderPtr reader);\n@@ -317,1 +320,1 @@\n-            xmlTextReaderStandalone     (xmlTextReaderPtr reader);\n+                    xmlTextReaderStandalone     (xmlTextReaderPtr reader);\n@@ -324,1 +327,1 @@\n-        xmlTextReaderByteConsumed    (xmlTextReaderPtr reader);\n+                xmlTextReaderByteConsumed       (xmlTextReaderPtr reader);\n@@ -330,1 +333,1 @@\n-        xmlReaderWalker        (xmlDocPtr doc);\n+                xmlReaderWalker         (xmlDocPtr doc);\n@@ -332,4 +335,4 @@\n-        xmlReaderForDoc        (const xmlChar * cur,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReaderForDoc         (const xmlChar * cur,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -337,3 +340,3 @@\n-        xmlReaderForFile    (const char *filename,\n-                     const char *encoding,\n-                     int options);\n+                xmlReaderForFile        (const char *filename,\n+                                         const char *encoding,\n+                                         int options);\n@@ -341,5 +344,5 @@\n-        xmlReaderForMemory    (const char *buffer,\n-                     int size,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReaderForMemory      (const char *buffer,\n+                                         int size,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -347,4 +350,4 @@\n-        xmlReaderForFd        (int fd,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReaderForFd          (int fd,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -352,42 +355,42 @@\n-        xmlReaderForIO        (xmlInputReadCallback ioread,\n-                     xmlInputCloseCallback ioclose,\n-                     void *ioctx,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n-\n-XMLPUBFUN int\n-        xmlReaderNewWalker    (xmlTextReaderPtr reader,\n-                     xmlDocPtr doc);\n-XMLPUBFUN int\n-        xmlReaderNewDoc        (xmlTextReaderPtr reader,\n-                     const xmlChar * cur,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n-XMLPUBFUN int\n-        xmlReaderNewFile    (xmlTextReaderPtr reader,\n-                     const char *filename,\n-                     const char *encoding,\n-                     int options);\n-XMLPUBFUN int\n-        xmlReaderNewMemory    (xmlTextReaderPtr reader,\n-                     const char *buffer,\n-                     int size,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n-XMLPUBFUN int\n-        xmlReaderNewFd        (xmlTextReaderPtr reader,\n-                     int fd,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n-XMLPUBFUN int\n-        xmlReaderNewIO        (xmlTextReaderPtr reader,\n-                     xmlInputReadCallback ioread,\n-                     xmlInputCloseCallback ioclose,\n-                     void *ioctx,\n-                     const char *URL,\n-                     const char *encoding,\n-                     int options);\n+                xmlReaderForIO          (xmlInputReadCallback ioread,\n+                                         xmlInputCloseCallback ioclose,\n+                                         void *ioctx,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n+\n+XMLPUBFUN int\n+                xmlReaderNewWalker      (xmlTextReaderPtr reader,\n+                                         xmlDocPtr doc);\n+XMLPUBFUN int\n+                xmlReaderNewDoc         (xmlTextReaderPtr reader,\n+                                         const xmlChar * cur,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n+XMLPUBFUN int\n+                xmlReaderNewFile        (xmlTextReaderPtr reader,\n+                                         const char *filename,\n+                                         const char *encoding,\n+                                         int options);\n+XMLPUBFUN int\n+                xmlReaderNewMemory      (xmlTextReaderPtr reader,\n+                                         const char *buffer,\n+                                         int size,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n+XMLPUBFUN int\n+                xmlReaderNewFd          (xmlTextReaderPtr reader,\n+                                         int fd,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n+XMLPUBFUN int\n+                xmlReaderNewIO          (xmlTextReaderPtr reader,\n+                                         xmlInputReadCallback ioread,\n+                                         xmlInputCloseCallback ioclose,\n+                                         void *ioctx,\n+                                         const char *URL,\n+                                         const char *encoding,\n+                                         int options);\n@@ -409,3 +412,3 @@\n-                           const char *msg,\n-                           xmlParserSeverities severity,\n-                           xmlTextReaderLocatorPtr locator);\n+                                               const char *msg,\n+                                               xmlParserSeverities severity,\n+                                               xmlTextReaderLocatorPtr locator);\n@@ -413,1 +416,1 @@\n-        xmlTextReaderLocatorLineNumber(xmlTextReaderLocatorPtr locator);\n+            xmlTextReaderLocatorLineNumber(xmlTextReaderLocatorPtr locator);\n@@ -415,1 +418,1 @@\n-        xmlTextReaderLocatorBaseURI (xmlTextReaderLocatorPtr locator);\n+            xmlTextReaderLocatorBaseURI (xmlTextReaderLocatorPtr locator);\n@@ -417,3 +420,3 @@\n-        xmlTextReaderSetErrorHandler(xmlTextReaderPtr reader,\n-                     xmlTextReaderErrorFunc f,\n-                     void *arg);\n+            xmlTextReaderSetErrorHandler(xmlTextReaderPtr reader,\n+                                         xmlTextReaderErrorFunc f,\n+                                         void *arg);\n@@ -421,3 +424,8 @@\n-        xmlTextReaderSetStructuredErrorHandler(xmlTextReaderPtr reader,\n-                           xmlStructuredErrorFunc f,\n-                           void *arg);\n+            xmlTextReaderSetStructuredErrorHandler(xmlTextReaderPtr reader,\n+                                                   xmlStructuredErrorFunc f,\n+                                                   void *arg);\n+XMLPUBFUN void\n+            xmlTextReaderGetErrorHandler(xmlTextReaderPtr reader,\n+                                         xmlTextReaderErrorFunc *f,\n+                                         void **arg);\n+\n@@ -425,3 +433,3 @@\n-        xmlTextReaderGetErrorHandler(xmlTextReaderPtr reader,\n-                     xmlTextReaderErrorFunc *f,\n-                     void **arg);\n+            xmlTextReaderSetResourceLoader(xmlTextReaderPtr reader,\n+                                           xmlResourceLoader loader,\n+                                           void *data);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlreader.h","additions":173,"deletions":165,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-            xmlRegexpCompile    (const xmlChar *regexp);\n-XMLPUBFUN void             xmlRegFreeRegexp(xmlRegexpPtr regexp);\n+                    xmlRegexpCompile    (const xmlChar *regexp);\n+XMLPUBFUN void                   xmlRegFreeRegexp(xmlRegexpPtr regexp);\n@@ -48,2 +48,3 @@\n-            xmlRegexpExec    (xmlRegexpPtr comp,\n-                     const xmlChar *value);\n+                    xmlRegexpExec       (xmlRegexpPtr comp,\n+                                         const xmlChar *value);\n+XML_DEPRECATED\n@@ -51,2 +52,2 @@\n-            xmlRegexpPrint    (FILE *output,\n-                     xmlRegexpPtr regexp);\n+                    xmlRegexpPrint      (FILE *output,\n+                                         xmlRegexpPtr regexp);\n@@ -54,1 +55,1 @@\n-            xmlRegexpIsDeterminist(xmlRegexpPtr comp);\n+                    xmlRegexpIsDeterminist(xmlRegexpPtr comp);\n@@ -66,3 +67,3 @@\n-                                 const xmlChar *token,\n-                     void *transdata,\n-                     void *inputdata);\n+                                     const xmlChar *token,\n+                                     void *transdata,\n+                                     void *inputdata);\n@@ -73,0 +74,1 @@\n+XML_DEPRECATED\n@@ -74,3 +76,4 @@\n-            xmlRegNewExecCtxt    (xmlRegexpPtr comp,\n-                     xmlRegExecCallbacks callback,\n-                     void *data);\n+                    xmlRegNewExecCtxt   (xmlRegexpPtr comp,\n+                                         xmlRegExecCallbacks callback,\n+                                         void *data);\n+XML_DEPRECATED\n@@ -78,1 +81,2 @@\n-            xmlRegFreeExecCtxt    (xmlRegExecCtxtPtr exec);\n+                    xmlRegFreeExecCtxt  (xmlRegExecCtxtPtr exec);\n+XML_DEPRECATED\n@@ -80,3 +84,4 @@\n-            xmlRegExecPushString(xmlRegExecCtxtPtr exec,\n-                     const xmlChar *value,\n-                     void *data);\n+                    xmlRegExecPushString(xmlRegExecCtxtPtr exec,\n+                                         const xmlChar *value,\n+                                         void *data);\n+XML_DEPRECATED\n@@ -84,4 +89,4 @@\n-            xmlRegExecPushString2(xmlRegExecCtxtPtr exec,\n-                     const xmlChar *value,\n-                     const xmlChar *value2,\n-                     void *data);\n+                    xmlRegExecPushString2(xmlRegExecCtxtPtr exec,\n+                                         const xmlChar *value,\n+                                         const xmlChar *value2,\n+                                         void *data);\n@@ -89,0 +94,1 @@\n+XML_DEPRECATED\n@@ -90,5 +96,6 @@\n-            xmlRegExecNextValues(xmlRegExecCtxtPtr exec,\n-                     int *nbval,\n-                     int *nbneg,\n-                     xmlChar **values,\n-                     int *terminal);\n+                    xmlRegExecNextValues(xmlRegExecCtxtPtr exec,\n+                                         int *nbval,\n+                                         int *nbneg,\n+                                         xmlChar **values,\n+                                         int *terminal);\n+XML_DEPRECATED\n@@ -96,55 +103,6 @@\n-            xmlRegExecErrInfo    (xmlRegExecCtxtPtr exec,\n-                     const xmlChar **string,\n-                     int *nbval,\n-                     int *nbneg,\n-                     xmlChar **values,\n-                     int *terminal);\n-#ifdef LIBXML_EXPR_ENABLED\n-\/*\n- * Formal regular expression handling\n- * Its goal is to do some formal work on content models\n- *\/\n-\n-\/* expressions are used within a context *\/\n-typedef struct _xmlExpCtxt xmlExpCtxt;\n-typedef xmlExpCtxt *xmlExpCtxtPtr;\n-\n-XMLPUBFUN void\n-            xmlExpFreeCtxt    (xmlExpCtxtPtr ctxt);\n-XMLPUBFUN xmlExpCtxtPtr\n-            xmlExpNewCtxt    (int maxNodes,\n-                     xmlDictPtr dict);\n-\n-XMLPUBFUN int\n-            xmlExpCtxtNbNodes(xmlExpCtxtPtr ctxt);\n-XMLPUBFUN int\n-            xmlExpCtxtNbCons(xmlExpCtxtPtr ctxt);\n-\n-\/* Expressions are trees but the tree is opaque *\/\n-typedef struct _xmlExpNode xmlExpNode;\n-typedef xmlExpNode *xmlExpNodePtr;\n-\n-typedef enum {\n-    XML_EXP_EMPTY = 0,\n-    XML_EXP_FORBID = 1,\n-    XML_EXP_ATOM = 2,\n-    XML_EXP_SEQ = 3,\n-    XML_EXP_OR = 4,\n-    XML_EXP_COUNT = 5\n-} xmlExpNodeType;\n-\n-\/*\n- * 2 core expressions shared by all for the empty language set\n- * and for the set with just the empty token\n- *\/\n-XMLPUBVAR xmlExpNodePtr forbiddenExp;\n-XMLPUBVAR xmlExpNodePtr emptyExp;\n-\n-\/*\n- * Expressions are reference counted internally\n- *\/\n-XMLPUBFUN void\n-            xmlExpFree    (xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr expr);\n-XMLPUBFUN void\n-            xmlExpRef    (xmlExpNodePtr expr);\n+                    xmlRegExecErrInfo   (xmlRegExecCtxtPtr exec,\n+                                         const xmlChar **string,\n+                                         int *nbval,\n+                                         int *nbneg,\n+                                         xmlChar **values,\n+                                         int *terminal);\n@@ -152,57 +110,0 @@\n-\/*\n- * constructors can be either manual or from a string\n- *\/\n-XMLPUBFUN xmlExpNodePtr\n-            xmlExpParse    (xmlExpCtxtPtr ctxt,\n-                     const char *expr);\n-XMLPUBFUN xmlExpNodePtr\n-            xmlExpNewAtom    (xmlExpCtxtPtr ctxt,\n-                     const xmlChar *name,\n-                     int len);\n-XMLPUBFUN xmlExpNodePtr\n-            xmlExpNewOr    (xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr left,\n-                     xmlExpNodePtr right);\n-XMLPUBFUN xmlExpNodePtr\n-            xmlExpNewSeq    (xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr left,\n-                     xmlExpNodePtr right);\n-XMLPUBFUN xmlExpNodePtr\n-            xmlExpNewRange    (xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr subset,\n-                     int min,\n-                     int max);\n-\/*\n- * The really interesting APIs\n- *\/\n-XMLPUBFUN int\n-            xmlExpIsNillable(xmlExpNodePtr expr);\n-XMLPUBFUN int\n-            xmlExpMaxToken    (xmlExpNodePtr expr);\n-XMLPUBFUN int\n-            xmlExpGetLanguage(xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr expr,\n-                     const xmlChar**langList,\n-                     int len);\n-XMLPUBFUN int\n-            xmlExpGetStart    (xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr expr,\n-                     const xmlChar**tokList,\n-                     int len);\n-XMLPUBFUN xmlExpNodePtr\n-            xmlExpStringDerive(xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr expr,\n-                     const xmlChar *str,\n-                     int len);\n-XMLPUBFUN xmlExpNodePtr\n-            xmlExpExpDerive    (xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr expr,\n-                     xmlExpNodePtr sub);\n-XMLPUBFUN int\n-            xmlExpSubsume    (xmlExpCtxtPtr ctxt,\n-                     xmlExpNodePtr expr,\n-                     xmlExpNodePtr sub);\n-XMLPUBFUN void\n-            xmlExpDump    (xmlBufferPtr buf,\n-                     xmlExpNodePtr expr);\n-#endif \/* LIBXML_EXPR_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlregexp.h","additions":39,"deletions":138,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -30,5 +30,5 @@\n-    XML_SAVE_FORMAT     = 1<<0,    \/* format save output *\/\n-    XML_SAVE_NO_DECL    = 1<<1,    \/* drop the xml declaration *\/\n-    XML_SAVE_NO_EMPTY    = 1<<2, \/* no empty tags *\/\n-    XML_SAVE_NO_XHTML    = 1<<3, \/* disable XHTML1 specific rules *\/\n-    XML_SAVE_XHTML    = 1<<4, \/* force XHTML1 specific rules *\/\n+    XML_SAVE_FORMAT     = 1<<0, \/* format save output *\/\n+    XML_SAVE_NO_DECL    = 1<<1, \/* drop the xml declaration *\/\n+    XML_SAVE_NO_EMPTY   = 1<<2, \/* no empty tags *\/\n+    XML_SAVE_NO_XHTML   = 1<<3, \/* disable XHTML1 specific rules *\/\n+    XML_SAVE_XHTML      = 1<<4, \/* force XHTML1 specific rules *\/\n@@ -37,1 +37,5 @@\n-    XML_SAVE_WSNONSIG   = 1<<7  \/* format with non-significant whitespace *\/\n+    XML_SAVE_WSNONSIG   = 1<<7, \/* format with non-significant whitespace *\/\n+    \/* Available since 2.14.0 *\/\n+    XML_SAVE_EMPTY      = 1<<8, \/* force empty tags, overriding global *\/\n+    XML_SAVE_NO_INDENT  = 1<<9, \/* disable indenting *\/\n+    XML_SAVE_INDENT     = 1<<10 \/* force indenting, overriding global *\/\n@@ -45,3 +49,3 @@\n-        xmlSaveToFd        (int fd,\n-                     const char *encoding,\n-                     int options);\n+                xmlSaveToFd             (int fd,\n+                                         const char *encoding,\n+                                         int options);\n@@ -49,3 +53,3 @@\n-        xmlSaveToFilename    (const char *filename,\n-                     const char *encoding,\n-                     int options);\n+                xmlSaveToFilename       (const char *filename,\n+                                         const char *encoding,\n+                                         int options);\n@@ -54,3 +58,3 @@\n-        xmlSaveToBuffer        (xmlBufferPtr buffer,\n-                     const char *encoding,\n-                     int options);\n+                xmlSaveToBuffer         (xmlBufferPtr buffer,\n+                                         const char *encoding,\n+                                         int options);\n@@ -59,5 +63,5 @@\n-        xmlSaveToIO        (xmlOutputWriteCallback iowrite,\n-                     xmlOutputCloseCallback ioclose,\n-                     void *ioctx,\n-                     const char *encoding,\n-                     int options);\n+                xmlSaveToIO             (xmlOutputWriteCallback iowrite,\n+                                         xmlOutputCloseCallback ioclose,\n+                                         void *ioctx,\n+                                         const char *encoding,\n+                                         int options);\n@@ -66,2 +70,2 @@\n-        xmlSaveDoc        (xmlSaveCtxtPtr ctxt,\n-                     xmlDocPtr doc);\n+                xmlSaveDoc              (xmlSaveCtxtPtr ctxt,\n+                                         xmlDocPtr doc);\n@@ -69,2 +73,2 @@\n-        xmlSaveTree        (xmlSaveCtxtPtr ctxt,\n-                     xmlNodePtr node);\n+                xmlSaveTree             (xmlSaveCtxtPtr ctxt,\n+                                         xmlNodePtr node);\n@@ -73,1 +77,1 @@\n-        xmlSaveFlush        (xmlSaveCtxtPtr ctxt);\n+                xmlSaveFlush            (xmlSaveCtxtPtr ctxt);\n@@ -75,1 +79,3 @@\n-        xmlSaveClose        (xmlSaveCtxtPtr ctxt);\n+                xmlSaveClose            (xmlSaveCtxtPtr ctxt);\n+XMLPUBFUN xmlParserErrors\n+                xmlSaveFinish           (xmlSaveCtxtPtr ctxt);\n@@ -77,1 +83,3 @@\n-        xmlSaveFinish        (xmlSaveCtxtPtr ctxt);\n+                xmlSaveSetIndentString  (xmlSaveCtxtPtr ctxt,\n+                                         const char *indent);\n+XML_DEPRECATED\n@@ -79,2 +87,3 @@\n-        xmlSaveSetEscape    (xmlSaveCtxtPtr ctxt,\n-                     xmlCharEncodingOutputFunc escape);\n+                xmlSaveSetEscape        (xmlSaveCtxtPtr ctxt,\n+                                         xmlCharEncodingOutputFunc escape);\n+XML_DEPRECATED\n@@ -82,2 +91,2 @@\n-        xmlSaveSetAttrEscape    (xmlSaveCtxtPtr ctxt,\n-                     xmlCharEncodingOutputFunc escape);\n+                xmlSaveSetAttrEscape    (xmlSaveCtxtPtr ctxt,\n+                                         xmlCharEncodingOutputFunc escape);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlsave.h","additions":40,"deletions":31,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -21,0 +21,1 @@\n+#include <libxml\/parser.h>\n@@ -32,2 +33,2 @@\n-    XML_SCHEMAS_ERR_OK        = 0,\n-    XML_SCHEMAS_ERR_NOROOT    = 1,\n+    XML_SCHEMAS_ERR_OK          = 0,\n+    XML_SCHEMAS_ERR_NOROOT      = 1,\n@@ -71,4 +72,4 @@\n-    XML_SCHEMA_VAL_VC_I_CREATE            = 1<<0\n-    \/* Default\/fixed: create an attribute node\n-    * or an element's text node on the instance.\n-    *\/\n+    XML_SCHEMA_VAL_VC_I_CREATE                  = 1<<0\n+        \/* Default\/fixed: create an attribute node\n+        * or an element's text node on the instance.\n+        *\/\n@@ -78,4 +79,4 @@\n-    XML_SCHEMA_VAL_XSI_ASSEMBLE            = 1<<1,\n-    * assemble schemata using\n-    * xsi:schemaLocation and\n-    * xsi:noNamespaceSchemaLocation\n+    XML_SCHEMA_VAL_XSI_ASSEMBLE                 = 1<<1,\n+        * assemble schemata using\n+        * xsi:schemaLocation and\n+        * xsi:noNamespaceSchemaLocation\n@@ -141,1 +142,1 @@\n-        xmlSchemaNewParserCtxt    (const char *URL);\n+            xmlSchemaNewParserCtxt      (const char *URL);\n@@ -143,2 +144,2 @@\n-        xmlSchemaNewMemParserCtxt    (const char *buffer,\n-                     int size);\n+            xmlSchemaNewMemParserCtxt   (const char *buffer,\n+                                         int size);\n@@ -146,1 +147,1 @@\n-        xmlSchemaNewDocParserCtxt    (xmlDocPtr doc);\n+            xmlSchemaNewDocParserCtxt   (xmlDocPtr doc);\n@@ -148,1 +149,1 @@\n-        xmlSchemaFreeParserCtxt    (xmlSchemaParserCtxtPtr ctxt);\n+            xmlSchemaFreeParserCtxt     (xmlSchemaParserCtxtPtr ctxt);\n@@ -150,4 +151,4 @@\n-        xmlSchemaSetParserErrors    (xmlSchemaParserCtxtPtr ctxt,\n-                     xmlSchemaValidityErrorFunc err,\n-                     xmlSchemaValidityWarningFunc warn,\n-                     void *ctx);\n+            xmlSchemaSetParserErrors    (xmlSchemaParserCtxtPtr ctxt,\n+                                         xmlSchemaValidityErrorFunc err,\n+                                         xmlSchemaValidityWarningFunc warn,\n+                                         void *ctx);\n@@ -155,3 +156,3 @@\n-        xmlSchemaSetParserStructuredErrors(xmlSchemaParserCtxtPtr ctxt,\n-                     xmlStructuredErrorFunc serror,\n-                     void *ctx);\n+            xmlSchemaSetParserStructuredErrors(xmlSchemaParserCtxtPtr ctxt,\n+                                         xmlStructuredErrorFunc serror,\n+                                         void *ctx);\n@@ -159,4 +160,8 @@\n-        xmlSchemaGetParserErrors(xmlSchemaParserCtxtPtr ctxt,\n-                    xmlSchemaValidityErrorFunc * err,\n-                    xmlSchemaValidityWarningFunc * warn,\n-                    void **ctx);\n+            xmlSchemaGetParserErrors    (xmlSchemaParserCtxtPtr ctxt,\n+                                        xmlSchemaValidityErrorFunc * err,\n+                                        xmlSchemaValidityWarningFunc * warn,\n+                                        void **ctx);\n+XMLPUBFUN void\n+            xmlSchemaSetResourceLoader  (xmlSchemaParserCtxtPtr ctxt,\n+                                         xmlResourceLoader loader,\n+                                         void *data);\n@@ -164,1 +169,1 @@\n-        xmlSchemaIsValid    (xmlSchemaValidCtxtPtr ctxt);\n+            xmlSchemaIsValid            (xmlSchemaValidCtxtPtr ctxt);\n@@ -167,1 +172,1 @@\n-        xmlSchemaParse        (xmlSchemaParserCtxtPtr ctxt);\n+            xmlSchemaParse              (xmlSchemaParserCtxtPtr ctxt);\n@@ -169,2 +174,2 @@\n-        xmlSchemaFree        (xmlSchemaPtr schema);\n-#ifdef LIBXML_OUTPUT_ENABLED\n+            xmlSchemaFree               (xmlSchemaPtr schema);\n+#ifdef LIBXML_DEBUG_ENABLED\n@@ -172,3 +177,3 @@\n-        xmlSchemaDump        (FILE *output,\n-                     xmlSchemaPtr schema);\n-#endif \/* LIBXML_OUTPUT_ENABLED *\/\n+            xmlSchemaDump               (FILE *output,\n+                                         xmlSchemaPtr schema);\n+#endif \/* LIBXML_DEBUG_ENABLED *\/\n@@ -179,4 +184,4 @@\n-        xmlSchemaSetValidErrors    (xmlSchemaValidCtxtPtr ctxt,\n-                     xmlSchemaValidityErrorFunc err,\n-                     xmlSchemaValidityWarningFunc warn,\n-                     void *ctx);\n+            xmlSchemaSetValidErrors     (xmlSchemaValidCtxtPtr ctxt,\n+                                         xmlSchemaValidityErrorFunc err,\n+                                         xmlSchemaValidityWarningFunc warn,\n+                                         void *ctx);\n@@ -184,3 +189,3 @@\n-        xmlSchemaSetValidStructuredErrors(xmlSchemaValidCtxtPtr ctxt,\n-                     xmlStructuredErrorFunc serror,\n-                     void *ctx);\n+            xmlSchemaSetValidStructuredErrors(xmlSchemaValidCtxtPtr ctxt,\n+                                         xmlStructuredErrorFunc serror,\n+                                         void *ctx);\n@@ -188,4 +193,4 @@\n-        xmlSchemaGetValidErrors    (xmlSchemaValidCtxtPtr ctxt,\n-                     xmlSchemaValidityErrorFunc *err,\n-                     xmlSchemaValidityWarningFunc *warn,\n-                     void **ctx);\n+            xmlSchemaGetValidErrors     (xmlSchemaValidCtxtPtr ctxt,\n+                                         xmlSchemaValidityErrorFunc *err,\n+                                         xmlSchemaValidityWarningFunc *warn,\n+                                         void **ctx);\n@@ -193,2 +198,2 @@\n-        xmlSchemaSetValidOptions    (xmlSchemaValidCtxtPtr ctxt,\n-                     int options);\n+            xmlSchemaSetValidOptions    (xmlSchemaValidCtxtPtr ctxt,\n+                                         int options);\n@@ -197,1 +202,1 @@\n-                                     const char *filename);\n+                                         const char *filename);\n@@ -199,1 +204,1 @@\n-        xmlSchemaValidCtxtGetOptions(xmlSchemaValidCtxtPtr ctxt);\n+            xmlSchemaValidCtxtGetOptions(xmlSchemaValidCtxtPtr ctxt);\n@@ -202,1 +207,1 @@\n-        xmlSchemaNewValidCtxt    (xmlSchemaPtr schema);\n+            xmlSchemaNewValidCtxt       (xmlSchemaPtr schema);\n@@ -204,1 +209,1 @@\n-        xmlSchemaFreeValidCtxt    (xmlSchemaValidCtxtPtr ctxt);\n+            xmlSchemaFreeValidCtxt      (xmlSchemaValidCtxtPtr ctxt);\n@@ -206,2 +211,2 @@\n-        xmlSchemaValidateDoc    (xmlSchemaValidCtxtPtr ctxt,\n-                     xmlDocPtr instance);\n+            xmlSchemaValidateDoc        (xmlSchemaValidCtxtPtr ctxt,\n+                                         xmlDocPtr instance);\n@@ -210,1 +215,1 @@\n-                             xmlNodePtr elem);\n+                                         xmlNodePtr elem);\n@@ -212,5 +217,5 @@\n-        xmlSchemaValidateStream    (xmlSchemaValidCtxtPtr ctxt,\n-                     xmlParserInputBufferPtr input,\n-                     xmlCharEncoding enc,\n-                     xmlSAXHandlerPtr sax,\n-                     void *user_data);\n+            xmlSchemaValidateStream     (xmlSchemaValidCtxtPtr ctxt,\n+                                         xmlParserInputBufferPtr input,\n+                                         xmlCharEncoding enc,\n+                                         const xmlSAXHandler *sax,\n+                                         void *user_data);\n@@ -218,3 +223,3 @@\n-        xmlSchemaValidateFile    (xmlSchemaValidCtxtPtr ctxt,\n-                     const char * filename,\n-                     int options);\n+            xmlSchemaValidateFile       (xmlSchemaValidCtxtPtr ctxt,\n+                                         const char * filename,\n+                                         int options);\n@@ -223,1 +228,1 @@\n-        xmlSchemaValidCtxtGetParserCtxt(xmlSchemaValidCtxtPtr ctxt);\n+            xmlSchemaValidCtxtGetParserCtxt(xmlSchemaValidCtxtPtr ctxt);\n@@ -232,3 +237,3 @@\n-            xmlSchemaSAXPlug        (xmlSchemaValidCtxtPtr ctxt,\n-                     xmlSAXHandlerPtr *sax,\n-                     void **user_data);\n+            xmlSchemaSAXPlug            (xmlSchemaValidCtxtPtr ctxt,\n+                                         xmlSAXHandlerPtr *sax,\n+                                         void **user_data);\n@@ -236,1 +241,1 @@\n-            xmlSchemaSAXUnplug        (xmlSchemaSAXPlugPtr plug);\n+            xmlSchemaSAXUnplug          (xmlSchemaSAXPlugPtr plug);\n@@ -240,3 +245,3 @@\n-            xmlSchemaValidateSetLocator    (xmlSchemaValidCtxtPtr vctxt,\n-                     xmlSchemaValidityLocatorFunc f,\n-                     void *ctxt);\n+            xmlSchemaValidateSetLocator (xmlSchemaValidCtxtPtr vctxt,\n+                                         xmlSchemaValidityLocatorFunc f,\n+                                         void *ctxt);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlschemas.h","additions":74,"deletions":69,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-        xmlSchemaInitTypes        (void);\n+                xmlSchemaInitTypes              (void);\n@@ -37,1 +37,1 @@\n-        xmlSchemaCleanupTypes        (void);\n+                xmlSchemaCleanupTypes           (void);\n@@ -39,23 +39,23 @@\n-        xmlSchemaGetPredefinedType    (const xmlChar *name,\n-                         const xmlChar *ns);\n-XMLPUBFUN int\n-        xmlSchemaValidatePredefinedType    (xmlSchemaTypePtr type,\n-                         const xmlChar *value,\n-                         xmlSchemaValPtr *val);\n-XMLPUBFUN int\n-        xmlSchemaValPredefTypeNode    (xmlSchemaTypePtr type,\n-                         const xmlChar *value,\n-                         xmlSchemaValPtr *val,\n-                         xmlNodePtr node);\n-XMLPUBFUN int\n-        xmlSchemaValidateFacet        (xmlSchemaTypePtr base,\n-                         xmlSchemaFacetPtr facet,\n-                         const xmlChar *value,\n-                         xmlSchemaValPtr val);\n-XMLPUBFUN int\n-        xmlSchemaValidateFacetWhtsp    (xmlSchemaFacetPtr facet,\n-                         xmlSchemaWhitespaceValueType fws,\n-                         xmlSchemaValType valType,\n-                         const xmlChar *value,\n-                         xmlSchemaValPtr val,\n-                         xmlSchemaWhitespaceValueType ws);\n+                xmlSchemaGetPredefinedType      (const xmlChar *name,\n+                                                 const xmlChar *ns);\n+XMLPUBFUN int\n+                xmlSchemaValidatePredefinedType (xmlSchemaTypePtr type,\n+                                                 const xmlChar *value,\n+                                                 xmlSchemaValPtr *val);\n+XMLPUBFUN int\n+                xmlSchemaValPredefTypeNode      (xmlSchemaTypePtr type,\n+                                                 const xmlChar *value,\n+                                                 xmlSchemaValPtr *val,\n+                                                 xmlNodePtr node);\n+XMLPUBFUN int\n+                xmlSchemaValidateFacet          (xmlSchemaTypePtr base,\n+                                                 xmlSchemaFacetPtr facet,\n+                                                 const xmlChar *value,\n+                                                 xmlSchemaValPtr val);\n+XMLPUBFUN int\n+                xmlSchemaValidateFacetWhtsp     (xmlSchemaFacetPtr facet,\n+                                                 xmlSchemaWhitespaceValueType fws,\n+                                                 xmlSchemaValType valType,\n+                                                 const xmlChar *value,\n+                                                 xmlSchemaValPtr val,\n+                                                 xmlSchemaWhitespaceValueType ws);\n@@ -63,1 +63,1 @@\n-        xmlSchemaFreeValue        (xmlSchemaValPtr val);\n+                xmlSchemaFreeValue              (xmlSchemaValPtr val);\n@@ -65,1 +65,1 @@\n-        xmlSchemaNewFacet        (void);\n+                xmlSchemaNewFacet               (void);\n@@ -67,4 +67,4 @@\n-        xmlSchemaCheckFacet        (xmlSchemaFacetPtr facet,\n-                         xmlSchemaTypePtr typeDecl,\n-                         xmlSchemaParserCtxtPtr ctxt,\n-                         const xmlChar *name);\n+                xmlSchemaCheckFacet             (xmlSchemaFacetPtr facet,\n+                                                 xmlSchemaTypePtr typeDecl,\n+                                                 xmlSchemaParserCtxtPtr ctxt,\n+                                                 const xmlChar *name);\n@@ -72,1 +72,1 @@\n-        xmlSchemaFreeFacet        (xmlSchemaFacetPtr facet);\n+                xmlSchemaFreeFacet              (xmlSchemaFacetPtr facet);\n@@ -74,2 +74,2 @@\n-        xmlSchemaCompareValues        (xmlSchemaValPtr x,\n-                         xmlSchemaValPtr y);\n+                xmlSchemaCompareValues          (xmlSchemaValPtr x,\n+                                                 xmlSchemaValPtr y);\n@@ -77,1 +77,1 @@\n-    xmlSchemaGetBuiltInListSimpleTypeItemType    (xmlSchemaTypePtr type);\n+    xmlSchemaGetBuiltInListSimpleTypeItemType   (xmlSchemaTypePtr type);\n@@ -79,4 +79,4 @@\n-    xmlSchemaValidateListSimpleTypeFacet    (xmlSchemaFacetPtr facet,\n-                         const xmlChar *value,\n-                         unsigned long actualLen,\n-                         unsigned long *expectedLen);\n+    xmlSchemaValidateListSimpleTypeFacet        (xmlSchemaFacetPtr facet,\n+                                                 const xmlChar *value,\n+                                                 unsigned long actualLen,\n+                                                 unsigned long *expectedLen);\n@@ -84,1 +84,1 @@\n-        xmlSchemaGetBuiltInType        (xmlSchemaValType type);\n+                xmlSchemaGetBuiltInType         (xmlSchemaValType type);\n@@ -86,2 +86,2 @@\n-        xmlSchemaIsBuiltInTypeFacet    (xmlSchemaTypePtr type,\n-                         int facetType);\n+                xmlSchemaIsBuiltInTypeFacet     (xmlSchemaTypePtr type,\n+                                                 int facetType);\n@@ -89,1 +89,1 @@\n-        xmlSchemaCollapseString        (const xmlChar *value);\n+                xmlSchemaCollapseString         (const xmlChar *value);\n@@ -91,1 +91,1 @@\n-        xmlSchemaWhiteSpaceReplace    (const xmlChar *value);\n+                xmlSchemaWhiteSpaceReplace      (const xmlChar *value);\n@@ -93,29 +93,29 @@\n-        xmlSchemaGetFacetValueAsULong    (xmlSchemaFacetPtr facet);\n-XMLPUBFUN int\n-        xmlSchemaValidateLengthFacet    (xmlSchemaTypePtr type,\n-                         xmlSchemaFacetPtr facet,\n-                         const xmlChar *value,\n-                         xmlSchemaValPtr val,\n-                         unsigned long *length);\n-XMLPUBFUN int\n-        xmlSchemaValidateLengthFacetWhtsp(xmlSchemaFacetPtr facet,\n-                          xmlSchemaValType valType,\n-                          const xmlChar *value,\n-                          xmlSchemaValPtr val,\n-                          unsigned long *length,\n-                          xmlSchemaWhitespaceValueType ws);\n-XMLPUBFUN int\n-        xmlSchemaValPredefTypeNodeNoNorm(xmlSchemaTypePtr type,\n-                         const xmlChar *value,\n-                         xmlSchemaValPtr *val,\n-                         xmlNodePtr node);\n-XMLPUBFUN int\n-        xmlSchemaGetCanonValue        (xmlSchemaValPtr val,\n-                         const xmlChar **retValue);\n-XMLPUBFUN int\n-        xmlSchemaGetCanonValueWhtsp    (xmlSchemaValPtr val,\n-                         const xmlChar **retValue,\n-                         xmlSchemaWhitespaceValueType ws);\n-XMLPUBFUN int\n-        xmlSchemaValueAppend        (xmlSchemaValPtr prev,\n-                         xmlSchemaValPtr cur);\n+                xmlSchemaGetFacetValueAsULong   (xmlSchemaFacetPtr facet);\n+XMLPUBFUN int\n+                xmlSchemaValidateLengthFacet    (xmlSchemaTypePtr type,\n+                                                 xmlSchemaFacetPtr facet,\n+                                                 const xmlChar *value,\n+                                                 xmlSchemaValPtr val,\n+                                                 unsigned long *length);\n+XMLPUBFUN int\n+                xmlSchemaValidateLengthFacetWhtsp(xmlSchemaFacetPtr facet,\n+                                                  xmlSchemaValType valType,\n+                                                  const xmlChar *value,\n+                                                  xmlSchemaValPtr val,\n+                                                  unsigned long *length,\n+                                                  xmlSchemaWhitespaceValueType ws);\n+XMLPUBFUN int\n+                xmlSchemaValPredefTypeNodeNoNorm(xmlSchemaTypePtr type,\n+                                                 const xmlChar *value,\n+                                                 xmlSchemaValPtr *val,\n+                                                 xmlNodePtr node);\n+XMLPUBFUN int\n+                xmlSchemaGetCanonValue          (xmlSchemaValPtr val,\n+                                                 const xmlChar **retValue);\n+XMLPUBFUN int\n+                xmlSchemaGetCanonValueWhtsp     (xmlSchemaValPtr val,\n+                                                 const xmlChar **retValue,\n+                                                 xmlSchemaWhitespaceValueType ws);\n+XMLPUBFUN int\n+                xmlSchemaValueAppend            (xmlSchemaValPtr prev,\n+                                                 xmlSchemaValPtr cur);\n@@ -123,1 +123,1 @@\n-        xmlSchemaValueGetNext        (xmlSchemaValPtr cur);\n+                xmlSchemaValueGetNext           (xmlSchemaValPtr cur);\n@@ -125,1 +125,1 @@\n-        xmlSchemaValueGetAsString    (xmlSchemaValPtr val);\n+                xmlSchemaValueGetAsString       (xmlSchemaValPtr val);\n@@ -127,1 +127,1 @@\n-        xmlSchemaValueGetAsBoolean    (xmlSchemaValPtr val);\n+                xmlSchemaValueGetAsBoolean      (xmlSchemaValPtr val);\n@@ -129,2 +129,2 @@\n-        xmlSchemaNewStringValue        (xmlSchemaValType type,\n-                         const xmlChar *value);\n+                xmlSchemaNewStringValue         (xmlSchemaValType type,\n+                                                 const xmlChar *value);\n@@ -132,2 +132,2 @@\n-        xmlSchemaNewNOTATIONValue    (const xmlChar *name,\n-                         const xmlChar *ns);\n+                xmlSchemaNewNOTATIONValue       (const xmlChar *name,\n+                                                 const xmlChar *ns);\n@@ -135,2 +135,2 @@\n-        xmlSchemaNewQNameValue        (const xmlChar *namespaceName,\n-                         const xmlChar *localName);\n+                xmlSchemaNewQNameValue          (const xmlChar *namespaceName,\n+                                                 const xmlChar *localName);\n@@ -138,4 +138,4 @@\n-        xmlSchemaCompareValuesWhtsp    (xmlSchemaValPtr x,\n-                         xmlSchemaWhitespaceValueType xws,\n-                         xmlSchemaValPtr y,\n-                         xmlSchemaWhitespaceValueType yws);\n+                xmlSchemaCompareValuesWhtsp     (xmlSchemaValPtr x,\n+                                                 xmlSchemaWhitespaceValueType xws,\n+                                                 xmlSchemaValPtr y,\n+                                                 xmlSchemaWhitespaceValueType yws);\n@@ -143,1 +143,1 @@\n-        xmlSchemaCopyValue        (xmlSchemaValPtr val);\n+                xmlSchemaCopyValue              (xmlSchemaValPtr val);\n@@ -145,1 +145,1 @@\n-        xmlSchemaGetValType        (xmlSchemaValPtr val);\n+                xmlSchemaGetValType             (xmlSchemaValPtr val);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlschemastypes.h","additions":88,"deletions":88,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -5,8 +5,1 @@\n- * This file is automatically generated from the\n- * UCS description files of the Unicode Character Database\n- * http:\/\/www.unicode.org\/Public\/4.0-Update1\/UCD-4.0.1.html\n- * using the genUnicode.py Python script.\n- *\n- * Generation date: Tue Apr 30 17:30:38 2024\n- * Sources: Blocks-4.0.1.txt UnicodeData-4.0.1.txt\n- * Author: Daniel Veillard\n+ * Deprecated, don't use.\n@@ -18,344 +11,2 @@\n-#include <libxml\/xmlversion.h>\n-\n-#ifdef LIBXML_UNICODE_ENABLED\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsAegeanNumbers    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsAlphabeticPresentationForms    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsArabic    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsArabicPresentationFormsA    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsArabicPresentationFormsB    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsArmenian    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsArrows    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsBasicLatin    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsBengali    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsBlockElements    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsBopomofo    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsBopomofoExtended    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsBoxDrawing    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsBraillePatterns    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsBuhid    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsByzantineMusicalSymbols    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCJKCompatibility    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCJKCompatibilityForms    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCJKCompatibilityIdeographs    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCJKCompatibilityIdeographsSupplement    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCJKRadicalsSupplement    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCJKSymbolsandPunctuation    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCJKUnifiedIdeographs    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCJKUnifiedIdeographsExtensionA    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCJKUnifiedIdeographsExtensionB    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCherokee    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCombiningDiacriticalMarks    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCombiningDiacriticalMarksforSymbols    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCombiningHalfMarks    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCombiningMarksforSymbols    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsControlPictures    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCurrencySymbols    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCypriotSyllabary    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCyrillic    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCyrillicSupplement    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsDeseret    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsDevanagari    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsDingbats    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsEnclosedAlphanumerics    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsEnclosedCJKLettersandMonths    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsEthiopic    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsGeneralPunctuation    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsGeometricShapes    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsGeorgian    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsGothic    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsGreek    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsGreekExtended    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsGreekandCoptic    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsGujarati    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsGurmukhi    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsHalfwidthandFullwidthForms    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsHangulCompatibilityJamo    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsHangulJamo    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsHangulSyllables    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsHanunoo    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsHebrew    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsHighPrivateUseSurrogates    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsHighSurrogates    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsHiragana    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsIPAExtensions    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsIdeographicDescriptionCharacters    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsKanbun    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsKangxiRadicals    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsKannada    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsKatakana    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsKatakanaPhoneticExtensions    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsKhmer    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsKhmerSymbols    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsLao    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsLatin1Supplement    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsLatinExtendedA    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsLatinExtendedB    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsLatinExtendedAdditional    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsLetterlikeSymbols    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsLimbu    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsLinearBIdeograms    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsLinearBSyllabary    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsLowSurrogates    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsMalayalam    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsMathematicalAlphanumericSymbols    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsMathematicalOperators    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsMiscellaneousMathematicalSymbolsA    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsMiscellaneousMathematicalSymbolsB    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsMiscellaneousSymbols    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsMiscellaneousSymbolsandArrows    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsMiscellaneousTechnical    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsMongolian    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsMusicalSymbols    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsMyanmar    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsNumberForms    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsOgham    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsOldItalic    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsOpticalCharacterRecognition    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsOriya    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsOsmanya    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsPhoneticExtensions    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsPrivateUse    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsPrivateUseArea    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsRunic    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsShavian    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsSinhala    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsSmallFormVariants    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsSpacingModifierLetters    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsSpecials    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsSuperscriptsandSubscripts    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsSupplementalArrowsA    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsSupplementalArrowsB    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsSupplementalMathematicalOperators    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsSupplementaryPrivateUseAreaA    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsSupplementaryPrivateUseAreaB    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsSyriac    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsTagalog    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsTagbanwa    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsTags    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsTaiLe    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsTaiXuanJingSymbols    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsTamil    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsTelugu    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsThaana    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsThai    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsTibetan    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsUgaritic    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsUnifiedCanadianAboriginalSyllabics    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsVariationSelectors    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsVariationSelectorsSupplement    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsYiRadicals    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsYiSyllables    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsYijingHexagramSymbols    (int code);\n-\n-XMLPUBFUN int xmlUCSIsBlock    (int code, const char *block);\n-\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatC    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatCc    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatCf    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatCo    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatCs    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatL    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatLl    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatLm    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatLo    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatLt    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatLu    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatM    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatMc    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatMe    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatMn    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatN    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatNd    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatNl    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatNo    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatP    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatPc    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatPd    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatPe    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatPf    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatPi    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatPo    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatPs    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatS    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatSc    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatSk    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatSm    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatSo    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatZ    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatZl    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatZp    (int code);\n-XML_DEPRECATED\n-XMLPUBFUN int xmlUCSIsCatZs    (int code);\n-\n-XMLPUBFUN int xmlUCSIsCat    (int code, const char *cat);\n-\n-#ifdef __cplusplus\n-}\n+#ifdef __GNUC__\n+  #warning \"libxml\/xmlunicode.h is deprecated\"\n@@ -364,2 +15,0 @@\n-#endif \/* LIBXML_UNICODE_ENABLED *\/\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlunicode.h","additions":3,"deletions":354,"binary":false,"changes":357,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-                    LIBXML_ATTR_FORMAT(2,3);\n+                                        LIBXML_ATTR_FORMAT(2,3);\n@@ -77,1 +77,1 @@\n-                     LIBXML_ATTR_FORMAT(2,0);\n+                                         LIBXML_ATTR_FORMAT(2,0);\n@@ -107,1 +107,1 @@\n-                    LIBXML_ATTR_FORMAT(3,4);\n+                                        LIBXML_ATTR_FORMAT(3,4);\n@@ -113,1 +113,1 @@\n-                     LIBXML_ATTR_FORMAT(3,0);\n+                                         LIBXML_ATTR_FORMAT(3,0);\n@@ -125,1 +125,1 @@\n-                      LIBXML_ATTR_FORMAT(5,6);\n+                                          LIBXML_ATTR_FORMAT(5,6);\n@@ -133,1 +133,1 @@\n-                       LIBXML_ATTR_FORMAT(5,0);\n+                                           LIBXML_ATTR_FORMAT(5,0);\n@@ -150,1 +150,1 @@\n-                    LIBXML_ATTR_FORMAT(2,3);\n+                                    LIBXML_ATTR_FORMAT(2,3);\n@@ -154,1 +154,1 @@\n-                     LIBXML_ATTR_FORMAT(2,0);\n+                                     LIBXML_ATTR_FORMAT(2,0);\n@@ -165,1 +165,1 @@\n-                             LIBXML_ATTR_FORMAT(2,3);\n+                                                         LIBXML_ATTR_FORMAT(2,3);\n@@ -171,1 +171,1 @@\n-                              LIBXML_ATTR_FORMAT(2,0);\n+                                                          LIBXML_ATTR_FORMAT(2,0);\n@@ -206,1 +206,1 @@\n-                      LIBXML_ATTR_FORMAT(3,4);\n+                                          LIBXML_ATTR_FORMAT(3,4);\n@@ -212,1 +212,1 @@\n-                       LIBXML_ATTR_FORMAT(3,0);\n+                                           LIBXML_ATTR_FORMAT(3,0);\n@@ -224,1 +224,1 @@\n-                        LIBXML_ATTR_FORMAT(5,6);\n+                                            LIBXML_ATTR_FORMAT(5,6);\n@@ -232,1 +232,1 @@\n-                         LIBXML_ATTR_FORMAT(5,0);\n+                                             LIBXML_ATTR_FORMAT(5,0);\n@@ -259,1 +259,1 @@\n-                   LIBXML_ATTR_FORMAT(3,4);\n+                                   LIBXML_ATTR_FORMAT(3,4);\n@@ -264,1 +264,1 @@\n-                    LIBXML_ATTR_FORMAT(3,0);\n+                                    LIBXML_ATTR_FORMAT(3,0);\n@@ -289,1 +289,1 @@\n-                      LIBXML_ATTR_FORMAT(2,3);\n+                                      LIBXML_ATTR_FORMAT(2,3);\n@@ -293,1 +293,1 @@\n-                       LIBXML_ATTR_FORMAT(2,0);\n+                                       LIBXML_ATTR_FORMAT(2,0);\n@@ -317,1 +317,1 @@\n-                    LIBXML_ATTR_FORMAT(5,6);\n+                                    LIBXML_ATTR_FORMAT(5,6);\n@@ -324,1 +324,1 @@\n-                     LIBXML_ATTR_FORMAT(5,0);\n+                                     LIBXML_ATTR_FORMAT(5,0);\n@@ -355,1 +355,1 @@\n-                       LIBXML_ATTR_FORMAT(3,4);\n+                                           LIBXML_ATTR_FORMAT(3,4);\n@@ -361,1 +361,1 @@\n-                        LIBXML_ATTR_FORMAT(3,0);\n+                                            LIBXML_ATTR_FORMAT(3,0);\n@@ -385,1 +385,1 @@\n-                       LIBXML_ATTR_FORMAT(3,4);\n+                                           LIBXML_ATTR_FORMAT(3,4);\n@@ -391,1 +391,1 @@\n-                        LIBXML_ATTR_FORMAT(3,0);\n+                                            LIBXML_ATTR_FORMAT(3,0);\n@@ -416,1 +416,1 @@\n-                          LIBXML_ATTR_FORMAT(4,5);\n+                                                  LIBXML_ATTR_FORMAT(4,5);\n@@ -423,1 +423,1 @@\n-                           LIBXML_ATTR_FORMAT(4,0);\n+                                                   LIBXML_ATTR_FORMAT(4,0);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xmlwriter.h","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n@@ -31,1 +30,0 @@\n-#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n@@ -35,3 +33,0 @@\n-#endif \/* LIBXML_XPATH_ENABLED or LIBXML_SCHEMAS_ENABLED *\/\n-\n-#ifdef LIBXML_XPATH_ENABLED\n@@ -84,3 +79,3 @@\n-    int nodeNr;            \/* number of nodes in the set *\/\n-    int nodeMax;        \/* size of the array as allocated *\/\n-    xmlNodePtr *nodeTab;    \/* array of nodes in no particular order *\/\n+    int nodeNr;                 \/* number of nodes in the set *\/\n+    int nodeMax;                \/* size of the array as allocated *\/\n+    xmlNodePtr *nodeTab;        \/* array of nodes in no particular order *\/\n@@ -107,5 +102,0 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    XPATH_POINT = 5,\n-    XPATH_RANGE = 6,\n-    XPATH_LOCATIONSET = 7,\n-#endif\n@@ -116,1 +106,0 @@\n-#ifndef LIBXML_XPTR_LOCS_ENABLED\n@@ -122,1 +111,0 @@\n-#endif\n@@ -157,2 +145,2 @@\n-    const xmlChar         *name;        \/* the type name *\/\n-    xmlXPathConvertFunc func;        \/* the conversion function *\/\n+    const xmlChar         *name;                \/* the type name *\/\n+    xmlXPathConvertFunc func;           \/* the conversion function *\/\n@@ -168,2 +156,2 @@\n-    const xmlChar       *name;        \/* the variable name *\/\n-    xmlXPathObjectPtr value;        \/* the value *\/\n+    const xmlChar       *name;          \/* the variable name *\/\n+    xmlXPathObjectPtr value;            \/* the value *\/\n@@ -181,1 +169,1 @@\n-                             int nargs);\n+                                 int nargs);\n@@ -190,2 +178,2 @@\n-    const xmlChar      *name;        \/* the function name *\/\n-    xmlXPathEvalFunc func;        \/* the evaluation function *\/\n+    const xmlChar      *name;           \/* the function name *\/\n+    xmlXPathEvalFunc func;              \/* the evaluation function *\/\n@@ -207,1 +195,1 @@\n-                 xmlXPathObjectPtr cur);\n+                                 xmlXPathObjectPtr cur);\n@@ -216,2 +204,2 @@\n-    const xmlChar      *name;        \/* the axis name *\/\n-    xmlXPathAxisFunc func;        \/* the search function *\/\n+    const xmlChar      *name;           \/* the axis name *\/\n+    xmlXPathAxisFunc func;              \/* the search function *\/\n@@ -263,2 +251,2 @@\n-                     const xmlChar *name,\n-                     const xmlChar *ns_uri);\n+                                         const xmlChar *name,\n+                                         const xmlChar *ns_uri);\n@@ -281,1 +269,1 @@\n-#define XML_XPATH_NOVAR      (1<<1)\n+#define XML_XPATH_NOVAR   (1<<1)\n@@ -301,2 +289,2 @@\n-    xmlDocPtr doc;            \/* The current document *\/\n-    xmlNodePtr node;            \/* The current node *\/\n+    xmlDocPtr doc;                      \/* The current document *\/\n+    xmlNodePtr node;                    \/* The current node *\/\n@@ -304,3 +292,3 @@\n-    int nb_variables_unused;        \/* unused (hash table) *\/\n-    int max_variables_unused;        \/* unused (hash table) *\/\n-    xmlHashTablePtr varHash;        \/* Hash table of defined variables *\/\n+    int nb_variables_unused;            \/* unused (hash table) *\/\n+    int max_variables_unused;           \/* unused (hash table) *\/\n+    xmlHashTablePtr varHash;            \/* Hash table of defined variables *\/\n@@ -308,3 +296,3 @@\n-    int nb_types;            \/* number of defined types *\/\n-    int max_types;            \/* max number of types *\/\n-    xmlXPathTypePtr types;        \/* Array of defined types *\/\n+    int nb_types;                       \/* number of defined types *\/\n+    int max_types;                      \/* max number of types *\/\n+    xmlXPathTypePtr types;              \/* Array of defined types *\/\n@@ -312,3 +300,3 @@\n-    int nb_funcs_unused;        \/* unused (hash table) *\/\n-    int max_funcs_unused;        \/* unused (hash table) *\/\n-    xmlHashTablePtr funcHash;        \/* Hash table of defined funcs *\/\n+    int nb_funcs_unused;                \/* unused (hash table) *\/\n+    int max_funcs_unused;               \/* unused (hash table) *\/\n+    xmlHashTablePtr funcHash;           \/* Hash table of defined funcs *\/\n@@ -316,3 +304,3 @@\n-    int nb_axis;            \/* number of defined axis *\/\n-    int max_axis;            \/* max number of axis *\/\n-    xmlXPathAxisPtr axis;        \/* Array of defined axis *\/\n+    int nb_axis;                        \/* number of defined axis *\/\n+    int max_axis;                       \/* max number of axis *\/\n+    xmlXPathAxisPtr axis;               \/* Array of defined axis *\/\n@@ -321,3 +309,3 @@\n-    xmlNsPtr *namespaces;        \/* Array of namespaces *\/\n-    int nsNr;                \/* number of namespace in scope *\/\n-    void *user;                \/* function to free *\/\n+    xmlNsPtr *namespaces;               \/* Array of namespaces *\/\n+    int nsNr;                           \/* number of namespace in scope *\/\n+    void *user;                         \/* function to free *\/\n@@ -326,2 +314,2 @@\n-    int contextSize;            \/* the context size *\/\n-    int proximityPosition;        \/* the proximity position *\/\n+    int contextSize;                    \/* the context size *\/\n+    int proximityPosition;              \/* the proximity position *\/\n@@ -330,3 +318,3 @@\n-    int xptr;                \/* is this an XPointer context? *\/\n-    xmlNodePtr here;            \/* for here() *\/\n-    xmlNodePtr origin;            \/* for origin() *\/\n+    int xptr;                           \/* is this an XPointer context? *\/\n+    xmlNodePtr here;                    \/* for here() *\/\n+    xmlNodePtr origin;                  \/* for origin() *\/\n@@ -335,1 +323,1 @@\n-    xmlHashTablePtr nsHash;        \/* The namespaces hash table *\/\n+    xmlHashTablePtr nsHash;             \/* The namespaces hash table *\/\n@@ -337,1 +325,1 @@\n-    void *varLookupData;        \/* variable lookup data *\/\n+    void *varLookupData;                \/* variable lookup data *\/\n@@ -348,1 +336,1 @@\n-    void *funcLookupData;        \/* function lookup data *\/\n+    void *funcLookupData;               \/* function lookup data *\/\n@@ -351,2 +339,2 @@\n-    xmlNsPtr *tmpNsList;        \/* Array of namespaces *\/\n-    int tmpNsNr;            \/* number of namespaces in scope *\/\n+    xmlNsPtr *tmpNsList;                \/* Array of namespaces *\/\n+    int tmpNsNr;                        \/* number of namespaces in scope *\/\n@@ -357,2 +345,2 @@\n-    xmlError lastError;            \/* the last error *\/\n-    xmlNodePtr debugNode;        \/* the source node XSLT *\/\n+    xmlError lastError;                 \/* the last error *\/\n+    xmlNodePtr debugNode;               \/* the source node XSLT *\/\n@@ -361,1 +349,1 @@\n-    xmlDictPtr dict;            \/* dictionary if any *\/\n+    xmlDictPtr dict;                    \/* dictionary if any *\/\n@@ -363,1 +351,1 @@\n-    int flags;                \/* flags to control compilation *\/\n+    int flags;                          \/* flags to control compilation *\/\n@@ -388,2 +376,2 @@\n-    const xmlChar *cur;            \/* the current char being parsed *\/\n-    const xmlChar *base;            \/* the full expression *\/\n+    const xmlChar *cur;                 \/* the current char being parsed *\/\n+    const xmlChar *base;                        \/* the full expression *\/\n@@ -391,1 +379,1 @@\n-    int error;                \/* error code *\/\n+    int error;                          \/* error code *\/\n@@ -393,5 +381,5 @@\n-    xmlXPathContextPtr  context;    \/* the evaluation context *\/\n-    xmlXPathObjectPtr     value;    \/* the current value *\/\n-    int                 valueNr;    \/* number of values stacked *\/\n-    int                valueMax;    \/* max number of values stacked *\/\n-    xmlXPathObjectPtr *valueTab;    \/* stack of values *\/\n+    xmlXPathContextPtr  context;        \/* the evaluation context *\/\n+    xmlXPathObjectPtr     value;        \/* the current value *\/\n+    int                 valueNr;        \/* number of values stacked *\/\n+    int                valueMax;        \/* max number of values stacked *\/\n+    xmlXPathObjectPtr *valueTab;        \/* stack of values *\/\n@@ -399,3 +387,3 @@\n-    xmlXPathCompExprPtr comp;        \/* the precompiled expression *\/\n-    int xptr;                \/* it this an XPointer expression *\/\n-    xmlNodePtr         ancestor;    \/* used for walking preceding axis *\/\n+    xmlXPathCompExprPtr comp;           \/* the precompiled expression *\/\n+    int xptr;                           \/* it this an XPointer expression *\/\n+    xmlNodePtr         ancestor;        \/* used for walking preceding axis *\/\n@@ -407,3 +395,3 @@\n- *                                    *\n- *            Public API                    *\n- *                                    *\n+ *                                                                      *\n+ *                      Public API                                      *\n+ *                                                                      *\n@@ -416,0 +404,1 @@\n+XML_DEPRECATED\n@@ -417,0 +406,1 @@\n+XML_DEPRECATED\n@@ -418,0 +408,1 @@\n+XML_DEPRECATED\n@@ -440,5 +431,5 @@\n-#define xmlXPathNodeSetItem(ns, index)                \\\n-        ((((ns) != NULL) &&                \\\n-          ((index) >= 0) && ((index) < (ns)->nodeNr)) ?    \\\n-         (ns)->nodeTab[(index)]                \\\n-         : NULL)\n+#define xmlXPathNodeSetItem(ns, index)                          \\\n+                ((((ns) != NULL) &&                             \\\n+                  ((index) >= 0) && ((index) < (ns)->nodeNr)) ? \\\n+                 (ns)->nodeTab[(index)]                         \\\n+                 : NULL)\n@@ -458,1 +449,1 @@\n-            xmlXPathFreeObject        (xmlXPathObjectPtr obj);\n+                    xmlXPathFreeObject          (xmlXPathObjectPtr obj);\n@@ -460,1 +451,1 @@\n-            xmlXPathNodeSetCreate    (xmlNodePtr val);\n+                    xmlXPathNodeSetCreate       (xmlNodePtr val);\n@@ -462,1 +453,1 @@\n-            xmlXPathFreeNodeSetList    (xmlXPathObjectPtr obj);\n+                    xmlXPathFreeNodeSetList     (xmlXPathObjectPtr obj);\n@@ -464,1 +455,1 @@\n-            xmlXPathFreeNodeSet        (xmlNodeSetPtr obj);\n+                    xmlXPathFreeNodeSet         (xmlNodeSetPtr obj);\n@@ -466,1 +457,1 @@\n-            xmlXPathObjectCopy        (xmlXPathObjectPtr val);\n+                    xmlXPathObjectCopy          (xmlXPathObjectPtr val);\n@@ -468,2 +459,2 @@\n-            xmlXPathCmpNodes        (xmlNodePtr node1,\n-                         xmlNodePtr node2);\n+                    xmlXPathCmpNodes            (xmlNodePtr node1,\n+                                                 xmlNodePtr node2);\n@@ -474,1 +465,1 @@\n-            xmlXPathCastNumberToBoolean    (double val);\n+                    xmlXPathCastNumberToBoolean (double val);\n@@ -476,1 +467,1 @@\n-            xmlXPathCastStringToBoolean    (const xmlChar * val);\n+                    xmlXPathCastStringToBoolean (const xmlChar * val);\n@@ -478,1 +469,1 @@\n-            xmlXPathCastNodeSetToBoolean(xmlNodeSetPtr ns);\n+                    xmlXPathCastNodeSetToBoolean(xmlNodeSetPtr ns);\n@@ -480,1 +471,1 @@\n-            xmlXPathCastToBoolean    (xmlXPathObjectPtr val);\n+                    xmlXPathCastToBoolean       (xmlXPathObjectPtr val);\n@@ -483,1 +474,1 @@\n-            xmlXPathCastBooleanToNumber    (int val);\n+                    xmlXPathCastBooleanToNumber (int val);\n@@ -485,1 +476,1 @@\n-            xmlXPathCastStringToNumber    (const xmlChar * val);\n+                    xmlXPathCastStringToNumber  (const xmlChar * val);\n@@ -487,1 +478,1 @@\n-            xmlXPathCastNodeToNumber    (xmlNodePtr node);\n+                    xmlXPathCastNodeToNumber    (xmlNodePtr node);\n@@ -489,1 +480,1 @@\n-            xmlXPathCastNodeSetToNumber    (xmlNodeSetPtr ns);\n+                    xmlXPathCastNodeSetToNumber (xmlNodeSetPtr ns);\n@@ -491,1 +482,1 @@\n-            xmlXPathCastToNumber    (xmlXPathObjectPtr val);\n+                    xmlXPathCastToNumber        (xmlXPathObjectPtr val);\n@@ -494,1 +485,1 @@\n-            xmlXPathCastBooleanToString    (int val);\n+                    xmlXPathCastBooleanToString (int val);\n@@ -496,1 +487,1 @@\n-            xmlXPathCastNumberToString    (double val);\n+                    xmlXPathCastNumberToString  (double val);\n@@ -498,1 +489,1 @@\n-            xmlXPathCastNodeToString    (xmlNodePtr node);\n+                    xmlXPathCastNodeToString    (xmlNodePtr node);\n@@ -500,1 +491,1 @@\n-            xmlXPathCastNodeSetToString    (xmlNodeSetPtr ns);\n+                    xmlXPathCastNodeSetToString (xmlNodeSetPtr ns);\n@@ -502,1 +493,1 @@\n-            xmlXPathCastToString    (xmlXPathObjectPtr val);\n+                    xmlXPathCastToString        (xmlXPathObjectPtr val);\n@@ -505,1 +496,1 @@\n-            xmlXPathConvertBoolean    (xmlXPathObjectPtr val);\n+                    xmlXPathConvertBoolean      (xmlXPathObjectPtr val);\n@@ -507,1 +498,1 @@\n-            xmlXPathConvertNumber    (xmlXPathObjectPtr val);\n+                    xmlXPathConvertNumber       (xmlXPathObjectPtr val);\n@@ -509,1 +500,1 @@\n-            xmlXPathConvertString    (xmlXPathObjectPtr val);\n+                    xmlXPathConvertString       (xmlXPathObjectPtr val);\n@@ -515,1 +506,1 @@\n-            xmlXPathNewContext        (xmlDocPtr doc);\n+                    xmlXPathNewContext          (xmlDocPtr doc);\n@@ -517,1 +508,1 @@\n-            xmlXPathFreeContext        (xmlXPathContextPtr ctxt);\n+                    xmlXPathFreeContext         (xmlXPathContextPtr ctxt);\n@@ -519,3 +510,3 @@\n-            xmlXPathSetErrorHandler(xmlXPathContextPtr ctxt,\n-                        xmlStructuredErrorFunc handler,\n-                        void *context);\n+                    xmlXPathSetErrorHandler(xmlXPathContextPtr ctxt,\n+                                            xmlStructuredErrorFunc handler,\n+                                            void *context);\n@@ -523,4 +514,4 @@\n-            xmlXPathContextSetCache(xmlXPathContextPtr ctxt,\n-                            int active,\n-                        int value,\n-                        int options);\n+                    xmlXPathContextSetCache(xmlXPathContextPtr ctxt,\n+                                            int active,\n+                                            int value,\n+                                            int options);\n@@ -531,1 +522,1 @@\n-            xmlXPathOrderDocElems    (xmlDocPtr doc);\n+                    xmlXPathOrderDocElems       (xmlDocPtr doc);\n@@ -533,2 +524,2 @@\n-            xmlXPathSetContextNode    (xmlNodePtr node,\n-                         xmlXPathContextPtr ctx);\n+                    xmlXPathSetContextNode      (xmlNodePtr node,\n+                                                 xmlXPathContextPtr ctx);\n@@ -536,3 +527,3 @@\n-            xmlXPathNodeEval        (xmlNodePtr node,\n-                         const xmlChar *str,\n-                         xmlXPathContextPtr ctx);\n+                    xmlXPathNodeEval            (xmlNodePtr node,\n+                                                 const xmlChar *str,\n+                                                 xmlXPathContextPtr ctx);\n@@ -540,2 +531,2 @@\n-            xmlXPathEval        (const xmlChar *str,\n-                         xmlXPathContextPtr ctx);\n+                    xmlXPathEval                (const xmlChar *str,\n+                                                 xmlXPathContextPtr ctx);\n@@ -543,2 +534,2 @@\n-            xmlXPathEvalExpression    (const xmlChar *str,\n-                         xmlXPathContextPtr ctxt);\n+                    xmlXPathEvalExpression      (const xmlChar *str,\n+                                                 xmlXPathContextPtr ctxt);\n@@ -546,2 +537,2 @@\n-            xmlXPathEvalPredicate    (xmlXPathContextPtr ctxt,\n-                         xmlXPathObjectPtr res);\n+                    xmlXPathEvalPredicate       (xmlXPathContextPtr ctxt,\n+                                                 xmlXPathObjectPtr res);\n@@ -552,1 +543,1 @@\n-            xmlXPathCompile        (const xmlChar *str);\n+                    xmlXPathCompile             (const xmlChar *str);\n@@ -554,2 +545,2 @@\n-            xmlXPathCtxtCompile        (xmlXPathContextPtr ctxt,\n-                         const xmlChar *str);\n+                    xmlXPathCtxtCompile         (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *str);\n@@ -557,2 +548,2 @@\n-            xmlXPathCompiledEval    (xmlXPathCompExprPtr comp,\n-                         xmlXPathContextPtr ctx);\n+                    xmlXPathCompiledEval        (xmlXPathCompExprPtr comp,\n+                                                 xmlXPathContextPtr ctx);\n@@ -560,2 +551,2 @@\n-            xmlXPathCompiledEvalToBoolean(xmlXPathCompExprPtr comp,\n-                         xmlXPathContextPtr ctxt);\n+                    xmlXPathCompiledEvalToBoolean(xmlXPathCompExprPtr comp,\n+                                                 xmlXPathContextPtr ctxt);\n@@ -563,3 +554,2 @@\n-            xmlXPathFreeCompExpr    (xmlXPathCompExprPtr comp);\n-#endif \/* LIBXML_XPATH_ENABLED *\/\n-#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n+                    xmlXPathFreeCompExpr        (xmlXPathCompExprPtr comp);\n+\n@@ -568,1 +558,1 @@\n-            xmlXPathInit        (void);\n+                    xmlXPathInit                (void);\n@@ -570,1 +560,1 @@\n-        xmlXPathIsNaN    (double val);\n+                xmlXPathIsNaN   (double val);\n@@ -572,1 +562,1 @@\n-        xmlXPathIsInf    (double val);\n+                xmlXPathIsInf   (double val);\n@@ -578,1 +568,1 @@\n-#endif \/* LIBXML_XPATH_ENABLED or LIBXML_SCHEMAS_ENABLED*\/\n+#endif \/* LIBXML_XPATH_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xpath.h","additions":127,"deletions":137,"binary":false,"changes":264,"status":"modified"},{"patch":"@@ -25,0 +25,6 @@\n+\/*\n+ * Backward compatibility\n+ *\/\n+#define valuePush xmlXPathValuePush\n+#define valuePop xmlXPathValuePop\n+\n@@ -26,3 +32,3 @@\n- *                                    *\n- *            Helpers                        *\n- *                                    *\n+ *                                                                      *\n+ *                      Helpers                                         *\n+ *                                                                      *\n@@ -42,2 +48,2 @@\n-#define xmlXPathSetError(ctxt, err)                    \\\n-    { xmlXPatherror((ctxt), __FILE__, __LINE__, (err));            \\\n+#define xmlXPathSetError(ctxt, err)                                     \\\n+    { xmlXPatherror((ctxt), __FILE__, __LINE__, (err));                 \\\n@@ -52,1 +58,1 @@\n-#define xmlXPathSetArityError(ctxt)                    \\\n+#define xmlXPathSetArityError(ctxt)                                     \\\n@@ -61,1 +67,1 @@\n-#define xmlXPathSetTypeError(ctxt)                    \\\n+#define xmlXPathSetTypeError(ctxt)                                      \\\n@@ -72,1 +78,1 @@\n-#define xmlXPathGetError(ctxt)      ((ctxt)->error)\n+#define xmlXPathGetError(ctxt)    ((ctxt)->error)\n@@ -92,1 +98,1 @@\n-#define xmlXPathGetDocument(ctxt)    ((ctxt)->context->doc)\n+#define xmlXPathGetDocument(ctxt)       ((ctxt)->context->doc)\n@@ -105,1 +111,1 @@\n-        xmlXPathPopBoolean    (xmlXPathParserContextPtr ctxt);\n+                xmlXPathPopBoolean      (xmlXPathParserContextPtr ctxt);\n@@ -107,1 +113,1 @@\n-        xmlXPathPopNumber    (xmlXPathParserContextPtr ctxt);\n+                xmlXPathPopNumber       (xmlXPathParserContextPtr ctxt);\n@@ -109,1 +115,1 @@\n-        xmlXPathPopString    (xmlXPathParserContextPtr ctxt);\n+                xmlXPathPopString       (xmlXPathParserContextPtr ctxt);\n@@ -111,1 +117,1 @@\n-        xmlXPathPopNodeSet    (xmlXPathParserContextPtr ctxt);\n+                xmlXPathPopNodeSet      (xmlXPathParserContextPtr ctxt);\n@@ -113,1 +119,1 @@\n-        xmlXPathPopExternal    (xmlXPathParserContextPtr ctxt);\n+                xmlXPathPopExternal     (xmlXPathParserContextPtr ctxt);\n@@ -122,1 +128,1 @@\n-#define xmlXPathReturnBoolean(ctxt, val)                \\\n+#define xmlXPathReturnBoolean(ctxt, val)                                \\\n@@ -148,1 +154,1 @@\n-#define xmlXPathReturnNumber(ctxt, val)                    \\\n+#define xmlXPathReturnNumber(ctxt, val)                                 \\\n@@ -158,1 +164,1 @@\n-#define xmlXPathReturnString(ctxt, str)                    \\\n+#define xmlXPathReturnString(ctxt, str)                                 \\\n@@ -167,1 +173,1 @@\n-#define xmlXPathReturnEmptyString(ctxt)                    \\\n+#define xmlXPathReturnEmptyString(ctxt)                                 \\\n@@ -177,1 +183,1 @@\n-#define xmlXPathReturnNodeSet(ctxt, ns)                    \\\n+#define xmlXPathReturnNodeSet(ctxt, ns)                                 \\\n@@ -186,1 +192,1 @@\n-#define xmlXPathReturnEmptyNodeSet(ctxt)                \\\n+#define xmlXPathReturnEmptyNodeSet(ctxt)                                \\\n@@ -196,1 +202,1 @@\n-#define xmlXPathReturnExternal(ctxt, val)                \\\n+#define xmlXPathReturnExternal(ctxt, val)                               \\\n@@ -208,3 +214,3 @@\n-#define xmlXPathStackIsNodeSet(ctxt)                    \\\n-    (((ctxt)->value != NULL)                        \\\n-     && (((ctxt)->value->type == XPATH_NODESET)                \\\n+#define xmlXPathStackIsNodeSet(ctxt)                                    \\\n+    (((ctxt)->value != NULL)                                            \\\n+     && (((ctxt)->value->type == XPATH_NODESET)                         \\\n@@ -223,2 +229,2 @@\n-#define xmlXPathStackIsExternal(ctxt)                    \\\n-    ((ctxt->value != NULL) && (ctxt->value->type == XPATH_USERS))\n+#define xmlXPathStackIsExternal(ctxt)                                   \\\n+        ((ctxt->value != NULL) && (ctxt->value->type == XPATH_USERS))\n@@ -232,1 +238,1 @@\n-#define xmlXPathEmptyNodeSet(ns)                    \\\n+#define xmlXPathEmptyNodeSet(ns)                                        \\\n@@ -240,1 +246,1 @@\n-#define CHECK_ERROR                            \\\n+#define CHECK_ERROR                                                     \\\n@@ -248,1 +254,1 @@\n-#define CHECK_ERROR0                            \\\n+#define CHECK_ERROR0                                                    \\\n@@ -257,1 +263,1 @@\n-#define XP_ERROR(X)                            \\\n+#define XP_ERROR(X)                                                     \\\n@@ -266,1 +272,1 @@\n-#define XP_ERROR0(X)                            \\\n+#define XP_ERROR0(X)                                                    \\\n@@ -276,2 +282,2 @@\n-#define CHECK_TYPE(typeval)                        \\\n-    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))    \\\n+#define CHECK_TYPE(typeval)                                             \\\n+    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))        \\\n@@ -287,2 +293,2 @@\n-#define CHECK_TYPE0(typeval)                        \\\n-    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))    \\\n+#define CHECK_TYPE0(typeval)                                            \\\n+    if ((ctxt->value == NULL) || (ctxt->value->type != typeval))        \\\n@@ -297,5 +303,5 @@\n-#define CHECK_ARITY(x)                            \\\n-    if (ctxt == NULL) return;                        \\\n-    if (nargs != (x))                            \\\n-        XP_ERROR(XPATH_INVALID_ARITY);                    \\\n-    if (ctxt->valueNr < (x))                        \\\n+#define CHECK_ARITY(x)                                                  \\\n+    if (ctxt == NULL) return;                                           \\\n+    if (nargs != (x))                                                   \\\n+        XP_ERROR(XPATH_INVALID_ARITY);                                  \\\n+    if (ctxt->valueNr < (x))                                            \\\n@@ -309,2 +315,2 @@\n-#define CAST_TO_STRING                            \\\n-    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_STRING))    \\\n+#define CAST_TO_STRING                                                  \\\n+    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_STRING))   \\\n@@ -318,2 +324,2 @@\n-#define CAST_TO_NUMBER                            \\\n-    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))    \\\n+#define CAST_TO_NUMBER                                                  \\\n+    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_NUMBER))   \\\n@@ -327,2 +333,2 @@\n-#define CAST_TO_BOOLEAN                            \\\n-    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_BOOLEAN))    \\\n+#define CAST_TO_BOOLEAN                                                 \\\n+    if ((ctxt->value != NULL) && (ctxt->value->type != XPATH_BOOLEAN))  \\\n@@ -336,3 +342,3 @@\n-    xmlXPathRegisterVariableLookup    (xmlXPathContextPtr ctxt,\n-                     xmlXPathVariableLookupFunc f,\n-                     void *data);\n+        xmlXPathRegisterVariableLookup  (xmlXPathContextPtr ctxt,\n+                                         xmlXPathVariableLookupFunc f,\n+                                         void *data);\n@@ -345,3 +351,3 @@\n-        xmlXPathRegisterFuncLookup    (xmlXPathContextPtr ctxt,\n-                     xmlXPathFuncLookupFunc f,\n-                     void *funcCtxt);\n+            xmlXPathRegisterFuncLookup  (xmlXPathContextPtr ctxt,\n+                                         xmlXPathFuncLookupFunc f,\n+                                         void *funcCtxt);\n@@ -353,4 +359,4 @@\n-        xmlXPatherror    (xmlXPathParserContextPtr ctxt,\n-                 const char *file,\n-                 int line,\n-                 int no);\n+                xmlXPatherror   (xmlXPathParserContextPtr ctxt,\n+                                 const char *file,\n+                                 int line,\n+                                 int no);\n@@ -359,2 +365,2 @@\n-        xmlXPathErr    (xmlXPathParserContextPtr ctxt,\n-                 int error);\n+                xmlXPathErr     (xmlXPathParserContextPtr ctxt,\n+                                 int error);\n@@ -364,3 +370,3 @@\n-        xmlXPathDebugDumpObject    (FILE *output,\n-                     xmlXPathObjectPtr cur,\n-                     int depth);\n+                xmlXPathDebugDumpObject (FILE *output,\n+                                         xmlXPathObjectPtr cur,\n+                                         int depth);\n@@ -368,3 +374,3 @@\n-        xmlXPathDebugDumpCompExpr(FILE *output,\n-                     xmlXPathCompExprPtr comp,\n-                     int depth);\n+            xmlXPathDebugDumpCompExpr(FILE *output,\n+                                         xmlXPathCompExprPtr comp,\n+                                         int depth);\n@@ -376,2 +382,2 @@\n-        xmlXPathNodeSetContains        (xmlNodeSetPtr cur,\n-                         xmlNodePtr val);\n+                xmlXPathNodeSetContains         (xmlNodeSetPtr cur,\n+                                                 xmlNodePtr val);\n@@ -379,2 +385,2 @@\n-        xmlXPathDifference        (xmlNodeSetPtr nodes1,\n-                         xmlNodeSetPtr nodes2);\n+                xmlXPathDifference              (xmlNodeSetPtr nodes1,\n+                                                 xmlNodeSetPtr nodes2);\n@@ -382,2 +388,2 @@\n-        xmlXPathIntersection        (xmlNodeSetPtr nodes1,\n-                         xmlNodeSetPtr nodes2);\n+                xmlXPathIntersection            (xmlNodeSetPtr nodes1,\n+                                                 xmlNodeSetPtr nodes2);\n@@ -386,1 +392,1 @@\n-        xmlXPathDistinctSorted        (xmlNodeSetPtr nodes);\n+                xmlXPathDistinctSorted          (xmlNodeSetPtr nodes);\n@@ -388,1 +394,1 @@\n-        xmlXPathDistinct        (xmlNodeSetPtr nodes);\n+                xmlXPathDistinct                (xmlNodeSetPtr nodes);\n@@ -391,2 +397,2 @@\n-        xmlXPathHasSameNodes        (xmlNodeSetPtr nodes1,\n-                         xmlNodeSetPtr nodes2);\n+                xmlXPathHasSameNodes            (xmlNodeSetPtr nodes1,\n+                                                 xmlNodeSetPtr nodes2);\n@@ -395,2 +401,2 @@\n-        xmlXPathNodeLeadingSorted    (xmlNodeSetPtr nodes,\n-                         xmlNodePtr node);\n+                xmlXPathNodeLeadingSorted       (xmlNodeSetPtr nodes,\n+                                                 xmlNodePtr node);\n@@ -398,2 +404,2 @@\n-        xmlXPathLeadingSorted        (xmlNodeSetPtr nodes1,\n-                         xmlNodeSetPtr nodes2);\n+                xmlXPathLeadingSorted           (xmlNodeSetPtr nodes1,\n+                                                 xmlNodeSetPtr nodes2);\n@@ -401,2 +407,2 @@\n-        xmlXPathNodeLeading        (xmlNodeSetPtr nodes,\n-                         xmlNodePtr node);\n+                xmlXPathNodeLeading             (xmlNodeSetPtr nodes,\n+                                                 xmlNodePtr node);\n@@ -404,2 +410,2 @@\n-        xmlXPathLeading            (xmlNodeSetPtr nodes1,\n-                         xmlNodeSetPtr nodes2);\n+                xmlXPathLeading                 (xmlNodeSetPtr nodes1,\n+                                                 xmlNodeSetPtr nodes2);\n@@ -408,2 +414,2 @@\n-        xmlXPathNodeTrailingSorted    (xmlNodeSetPtr nodes,\n-                         xmlNodePtr node);\n+                xmlXPathNodeTrailingSorted      (xmlNodeSetPtr nodes,\n+                                                 xmlNodePtr node);\n@@ -411,2 +417,2 @@\n-        xmlXPathTrailingSorted        (xmlNodeSetPtr nodes1,\n-                         xmlNodeSetPtr nodes2);\n+                xmlXPathTrailingSorted          (xmlNodeSetPtr nodes1,\n+                                                 xmlNodeSetPtr nodes2);\n@@ -414,2 +420,2 @@\n-        xmlXPathNodeTrailing        (xmlNodeSetPtr nodes,\n-                         xmlNodePtr node);\n+                xmlXPathNodeTrailing            (xmlNodeSetPtr nodes,\n+                                                 xmlNodePtr node);\n@@ -417,2 +423,2 @@\n-        xmlXPathTrailing        (xmlNodeSetPtr nodes1,\n-                         xmlNodeSetPtr nodes2);\n+                xmlXPathTrailing                (xmlNodeSetPtr nodes1,\n+                                                 xmlNodeSetPtr nodes2);\n@@ -426,3 +432,3 @@\n-        xmlXPathRegisterNs        (xmlXPathContextPtr ctxt,\n-                         const xmlChar *prefix,\n-                         const xmlChar *ns_uri);\n+                xmlXPathRegisterNs              (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *prefix,\n+                                                 const xmlChar *ns_uri);\n@@ -430,2 +436,2 @@\n-        xmlXPathNsLookup        (xmlXPathContextPtr ctxt,\n-                         const xmlChar *prefix);\n+                xmlXPathNsLookup                (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *prefix);\n@@ -433,1 +439,1 @@\n-        xmlXPathRegisteredNsCleanup    (xmlXPathContextPtr ctxt);\n+                xmlXPathRegisteredNsCleanup     (xmlXPathContextPtr ctxt);\n@@ -436,3 +442,3 @@\n-        xmlXPathRegisterFunc        (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name,\n-                         xmlXPathFunction f);\n+                xmlXPathRegisterFunc            (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 xmlXPathFunction f);\n@@ -440,4 +446,4 @@\n-        xmlXPathRegisterFuncNS        (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name,\n-                         const xmlChar *ns_uri,\n-                         xmlXPathFunction f);\n+                xmlXPathRegisterFuncNS          (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns_uri,\n+                                                 xmlXPathFunction f);\n@@ -445,3 +451,3 @@\n-        xmlXPathRegisterVariable    (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name,\n-                         xmlXPathObjectPtr value);\n+                xmlXPathRegisterVariable        (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 xmlXPathObjectPtr value);\n@@ -449,4 +455,4 @@\n-        xmlXPathRegisterVariableNS    (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name,\n-                         const xmlChar *ns_uri,\n-                         xmlXPathObjectPtr value);\n+                xmlXPathRegisterVariableNS      (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns_uri,\n+                                                 xmlXPathObjectPtr value);\n@@ -454,2 +460,2 @@\n-        xmlXPathFunctionLookup        (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name);\n+                xmlXPathFunctionLookup          (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name);\n@@ -457,3 +463,3 @@\n-        xmlXPathFunctionLookupNS    (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name,\n-                         const xmlChar *ns_uri);\n+                xmlXPathFunctionLookupNS        (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns_uri);\n@@ -461,1 +467,1 @@\n-        xmlXPathRegisteredFuncsCleanup    (xmlXPathContextPtr ctxt);\n+                xmlXPathRegisteredFuncsCleanup  (xmlXPathContextPtr ctxt);\n@@ -463,2 +469,2 @@\n-        xmlXPathVariableLookup        (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name);\n+                xmlXPathVariableLookup          (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name);\n@@ -466,3 +472,3 @@\n-        xmlXPathVariableLookupNS    (xmlXPathContextPtr ctxt,\n-                         const xmlChar *name,\n-                         const xmlChar *ns_uri);\n+                xmlXPathVariableLookupNS        (xmlXPathContextPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns_uri);\n@@ -470,1 +476,1 @@\n-        xmlXPathRegisteredVariablesCleanup(xmlXPathContextPtr ctxt);\n+                xmlXPathRegisteredVariablesCleanup(xmlXPathContextPtr ctxt);\n@@ -476,2 +482,2 @@\n-          xmlXPathNewParserContext    (const xmlChar *str,\n-                         xmlXPathContextPtr ctxt);\n+                  xmlXPathNewParserContext      (const xmlChar *str,\n+                                                 xmlXPathContextPtr ctxt);\n@@ -479,1 +485,1 @@\n-        xmlXPathFreeParserContext    (xmlXPathParserContextPtr ctxt);\n+                xmlXPathFreeParserContext       (xmlXPathParserContextPtr ctxt);\n@@ -481,1 +487,0 @@\n-\/* TODO: remap to xmlXPathValuePop and Push. *\/\n@@ -483,1 +488,1 @@\n-        valuePop            (xmlXPathParserContextPtr ctxt);\n+                xmlXPathValuePop                (xmlXPathParserContextPtr ctxt);\n@@ -485,2 +490,2 @@\n-        valuePush            (xmlXPathParserContextPtr ctxt,\n-                         xmlXPathObjectPtr value);\n+                xmlXPathValuePush               (xmlXPathParserContextPtr ctxt,\n+                                                 xmlXPathObjectPtr value);\n@@ -489,1 +494,1 @@\n-        xmlXPathNewString        (const xmlChar *val);\n+                xmlXPathNewString               (const xmlChar *val);\n@@ -491,1 +496,1 @@\n-        xmlXPathNewCString        (const char *val);\n+                xmlXPathNewCString              (const char *val);\n@@ -493,1 +498,1 @@\n-        xmlXPathWrapString        (xmlChar *val);\n+                xmlXPathWrapString              (xmlChar *val);\n@@ -495,1 +500,1 @@\n-        xmlXPathWrapCString        (char * val);\n+                xmlXPathWrapCString             (char * val);\n@@ -497,1 +502,1 @@\n-        xmlXPathNewFloat        (double val);\n+                xmlXPathNewFloat                (double val);\n@@ -499,1 +504,1 @@\n-        xmlXPathNewBoolean        (int val);\n+                xmlXPathNewBoolean              (int val);\n@@ -501,1 +506,1 @@\n-        xmlXPathNewNodeSet        (xmlNodePtr val);\n+                xmlXPathNewNodeSet              (xmlNodePtr val);\n@@ -503,1 +508,1 @@\n-        xmlXPathNewValueTree        (xmlNodePtr val);\n+                xmlXPathNewValueTree            (xmlNodePtr val);\n@@ -505,2 +510,2 @@\n-        xmlXPathNodeSetAdd        (xmlNodeSetPtr cur,\n-                         xmlNodePtr val);\n+                xmlXPathNodeSetAdd              (xmlNodeSetPtr cur,\n+                                                 xmlNodePtr val);\n@@ -508,2 +513,2 @@\n-        xmlXPathNodeSetAddUnique    (xmlNodeSetPtr cur,\n-                         xmlNodePtr val);\n+                xmlXPathNodeSetAddUnique        (xmlNodeSetPtr cur,\n+                                                 xmlNodePtr val);\n@@ -511,3 +516,3 @@\n-        xmlXPathNodeSetAddNs        (xmlNodeSetPtr cur,\n-                         xmlNodePtr node,\n-                         xmlNsPtr ns);\n+                xmlXPathNodeSetAddNs            (xmlNodeSetPtr cur,\n+                                                 xmlNodePtr node,\n+                                                 xmlNsPtr ns);\n@@ -515,1 +520,1 @@\n-        xmlXPathNodeSetSort        (xmlNodeSetPtr set);\n+                xmlXPathNodeSetSort             (xmlNodeSetPtr set);\n@@ -518,1 +523,2 @@\n-        xmlXPathRoot            (xmlXPathParserContextPtr ctxt);\n+                xmlXPathRoot                    (xmlXPathParserContextPtr ctxt);\n+XML_DEPRECATED\n@@ -520,1 +526,1 @@\n-        xmlXPathEvalExpr        (xmlXPathParserContextPtr ctxt);\n+                xmlXPathEvalExpr                (xmlXPathParserContextPtr ctxt);\n@@ -522,1 +528,1 @@\n-        xmlXPathParseName        (xmlXPathParserContextPtr ctxt);\n+                xmlXPathParseName               (xmlXPathParserContextPtr ctxt);\n@@ -524,1 +530,1 @@\n-        xmlXPathParseNCName        (xmlXPathParserContextPtr ctxt);\n+                xmlXPathParseNCName             (xmlXPathParserContextPtr ctxt);\n@@ -530,1 +536,1 @@\n-        xmlXPathStringEvalNumber    (const xmlChar *str);\n+                xmlXPathStringEvalNumber        (const xmlChar *str);\n@@ -532,2 +538,2 @@\n-        xmlXPathEvaluatePredicateResult (xmlXPathParserContextPtr ctxt,\n-                         xmlXPathObjectPtr res);\n+                xmlXPathEvaluatePredicateResult (xmlXPathParserContextPtr ctxt,\n+                                                 xmlXPathObjectPtr res);\n@@ -535,1 +541,1 @@\n-        xmlXPathRegisterAllFunctions    (xmlXPathContextPtr ctxt);\n+                xmlXPathRegisterAllFunctions    (xmlXPathContextPtr ctxt);\n@@ -537,2 +543,2 @@\n-        xmlXPathNodeSetMerge        (xmlNodeSetPtr val1,\n-                         xmlNodeSetPtr val2);\n+                xmlXPathNodeSetMerge            (xmlNodeSetPtr val1,\n+                                                 xmlNodeSetPtr val2);\n@@ -540,2 +546,2 @@\n-        xmlXPathNodeSetDel        (xmlNodeSetPtr cur,\n-                         xmlNodePtr val);\n+                xmlXPathNodeSetDel              (xmlNodeSetPtr cur,\n+                                                 xmlNodePtr val);\n@@ -543,2 +549,2 @@\n-        xmlXPathNodeSetRemove        (xmlNodeSetPtr cur,\n-                         int val);\n+                xmlXPathNodeSetRemove           (xmlNodeSetPtr cur,\n+                                                 int val);\n@@ -546,1 +552,1 @@\n-        xmlXPathNewNodeSetList        (xmlNodeSetPtr val);\n+                xmlXPathNewNodeSetList          (xmlNodeSetPtr val);\n@@ -548,1 +554,1 @@\n-        xmlXPathWrapNodeSet        (xmlNodeSetPtr val);\n+                xmlXPathWrapNodeSet             (xmlNodeSetPtr val);\n@@ -550,1 +556,1 @@\n-        xmlXPathWrapExternal        (void *val);\n+                xmlXPathWrapExternal            (void *val);\n@@ -568,1 +574,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -570,1 +576,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -572,1 +578,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -574,1 +580,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -576,1 +582,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -578,1 +584,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -580,1 +586,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -582,1 +588,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -584,1 +590,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -586,1 +592,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -588,1 +594,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -590,1 +596,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n@@ -592,1 +598,1 @@\n-            xmlNodePtr cur);\n+                        xmlNodePtr cur);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xpathInternals.h","additions":181,"deletions":175,"binary":false,"changes":356,"status":"modified"},{"patch":"@@ -31,79 +31,0 @@\n-#if defined(LIBXML_XPTR_LOCS_ENABLED)\n-\/*\n- * A Location Set\n- *\/\n-typedef struct _xmlLocationSet xmlLocationSet;\n-typedef xmlLocationSet *xmlLocationSetPtr;\n-struct _xmlLocationSet {\n-    int locNr;              \/* number of locations in the set *\/\n-    int locMax;              \/* size of the array as allocated *\/\n-    xmlXPathObjectPtr *locTab;\/* array of locations *\/\n-};\n-\n-\/*\n- * Handling of location sets.\n- *\/\n-\n-XML_DEPRECATED\n-XMLPUBFUN xmlLocationSetPtr\n-            xmlXPtrLocationSetCreate    (xmlXPathObjectPtr val);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-            xmlXPtrFreeLocationSet    (xmlLocationSetPtr obj);\n-XML_DEPRECATED\n-XMLPUBFUN xmlLocationSetPtr\n-            xmlXPtrLocationSetMerge    (xmlLocationSetPtr val1,\n-                         xmlLocationSetPtr val2);\n-XML_DEPRECATED\n-XMLPUBFUN xmlXPathObjectPtr\n-            xmlXPtrNewRange        (xmlNodePtr start,\n-                         int startindex,\n-                         xmlNodePtr end,\n-                         int endindex);\n-XML_DEPRECATED\n-XMLPUBFUN xmlXPathObjectPtr\n-            xmlXPtrNewRangePoints    (xmlXPathObjectPtr start,\n-                         xmlXPathObjectPtr end);\n-XML_DEPRECATED\n-XMLPUBFUN xmlXPathObjectPtr\n-            xmlXPtrNewRangeNodePoint    (xmlNodePtr start,\n-                         xmlXPathObjectPtr end);\n-XML_DEPRECATED\n-XMLPUBFUN xmlXPathObjectPtr\n-            xmlXPtrNewRangePointNode    (xmlXPathObjectPtr start,\n-                         xmlNodePtr end);\n-XML_DEPRECATED\n-XMLPUBFUN xmlXPathObjectPtr\n-            xmlXPtrNewRangeNodes    (xmlNodePtr start,\n-                         xmlNodePtr end);\n-XML_DEPRECATED\n-XMLPUBFUN xmlXPathObjectPtr\n-            xmlXPtrNewLocationSetNodes    (xmlNodePtr start,\n-                         xmlNodePtr end);\n-XML_DEPRECATED\n-XMLPUBFUN xmlXPathObjectPtr\n-            xmlXPtrNewLocationSetNodeSet(xmlNodeSetPtr set);\n-XML_DEPRECATED\n-XMLPUBFUN xmlXPathObjectPtr\n-            xmlXPtrNewRangeNodeObject    (xmlNodePtr start,\n-                         xmlXPathObjectPtr end);\n-XML_DEPRECATED\n-XMLPUBFUN xmlXPathObjectPtr\n-            xmlXPtrNewCollapsedRange    (xmlNodePtr start);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-            xmlXPtrLocationSetAdd    (xmlLocationSetPtr cur,\n-                         xmlXPathObjectPtr val);\n-XML_DEPRECATED\n-XMLPUBFUN xmlXPathObjectPtr\n-            xmlXPtrWrapLocationSet    (xmlLocationSetPtr val);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-            xmlXPtrLocationSetDel    (xmlLocationSetPtr cur,\n-                         xmlXPathObjectPtr val);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-            xmlXPtrLocationSetRemove    (xmlLocationSetPtr cur,\n-                         int val);\n-#endif \/* defined(LIBXML_XPTR_LOCS_ENABLED) *\/\n-\n@@ -113,0 +34,1 @@\n+XML_DEPRECATED\n@@ -114,3 +36,3 @@\n-            xmlXPtrNewContext        (xmlDocPtr doc,\n-                         xmlNodePtr here,\n-                         xmlNodePtr origin);\n+                    xmlXPtrNewContext           (xmlDocPtr doc,\n+                                                 xmlNodePtr here,\n+                                                 xmlNodePtr origin);\n@@ -118,2 +40,2 @@\n-            xmlXPtrEval            (const xmlChar *str,\n-                         xmlXPathContextPtr ctx);\n+                    xmlXPtrEval                 (const xmlChar *str,\n+                                                 xmlXPathContextPtr ctx);\n@@ -121,12 +43,0 @@\n-#if defined(LIBXML_XPTR_LOCS_ENABLED)\n-XML_DEPRECATED\n-XMLPUBFUN void\n-            xmlXPtrRangeToFunction    (xmlXPathParserContextPtr ctxt,\n-                         int nargs);\n-XML_DEPRECATED\n-XMLPUBFUN xmlNodePtr\n-            xmlXPtrBuildNodeList    (xmlXPathObjectPtr obj);\n-XML_DEPRECATED\n-XMLPUBFUN void\n-            xmlXPtrEvalRangePredicate    (xmlXPathParserContextPtr ctxt);\n-#endif \/* defined(LIBXML_XPTR_LOCS_ENABLED) *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/libxml\/xpointer.h","additions":6,"deletions":96,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+#include <libxml\/parser.h>\n@@ -7,1 +8,1 @@\n-xmlBufCreate(void);\n+xmlBufCreate(size_t size);\n@@ -9,7 +10,1 @@\n-xmlBufCreateSize(size_t size);\n-\n-XML_HIDDEN int\n-xmlBufSetAllocationScheme(xmlBufPtr buf, xmlBufferAllocationScheme scheme);\n-XML_HIDDEN int\n-xmlBufGetAllocationScheme(xmlBufPtr buf);\n-\n+xmlBufCreateMem(const xmlChar *mem, size_t size, int isStatic);\n@@ -18,0 +13,1 @@\n+\n@@ -21,3 +17,0 @@\n-\/* size_t xmlBufShrink(xmlBufPtr buf, size_t len); *\/\n-XML_HIDDEN int\n-xmlBufGrow(xmlBufPtr buf, int len);\n@@ -25,1 +18,1 @@\n-xmlBufResize(xmlBufPtr buf, size_t len);\n+xmlBufGrow(xmlBufPtr buf, size_t len);\n@@ -28,1 +21,1 @@\n-xmlBufAdd(xmlBufPtr buf, const xmlChar *str, int len);\n+xmlBufAdd(xmlBufPtr buf, const xmlChar *str, size_t len);\n@@ -34,3 +27,0 @@\n-XML_HIDDEN size_t\n-xmlBufLength(const xmlBufPtr buf);\n-\/* size_t xmlBufUse(const xmlBufPtr buf); *\/\n@@ -42,3 +32,0 @@\n-\/* const xmlChar * xmlBufContent(const xmlBuf *buf); *\/\n-\/* const xmlChar * xmlBufEnd(xmlBufPtr buf); *\/\n-\n@@ -48,3 +35,0 @@\n-XML_HIDDEN size_t\n-xmlBufDump(FILE *file, xmlBufPtr buf);\n-\n@@ -53,2 +37,2 @@\n-XML_HIDDEN xmlBufferPtr\n-xmlBufBackToBuffer(xmlBufPtr buf);\n+XML_HIDDEN int\n+xmlBufBackToBuffer(xmlBufPtr buf, xmlBufferPtr ret);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/buf.h","additions":8,"deletions":24,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,13 @@\n+#ifndef XML_CATA_H_PRIVATE__\n+#define XML_CATA_H_PRIVATE__\n+\n+#ifdef LIBXML_CATALOG_ENABLED\n+\n+XML_HIDDEN void\n+xmlInitCatalogInternal(void);\n+XML_HIDDEN void\n+xmlCleanupCatalogInternal(void);\n+\n+#endif \/* LIBXML_CATALOG_ENABLED *\/\n+\n+#endif \/* XML_CATA_H_PRIVATE__ *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/cata.h","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -10,1 +10,1 @@\n-XML_HIDDEN int\n+XML_HIDDEN xmlCharEncError\n@@ -12,3 +12,4 @@\n-                 int *outlen, const unsigned char *in, int *inlen);\n-XML_HIDDEN int\n-xmlCharEncInput(xmlParserInputBufferPtr input);\n+                 int *outlen, const unsigned char *in, int *inlen,\n+                 int flush);\n+XML_HIDDEN xmlCharEncError\n+xmlCharEncInput(xmlParserInputBufferPtr input, size_t *sizeOut, int flush);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/enc.h","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -24,0 +24,14 @@\n+#define XML_ESCAPE_ATTR             (1u << 0)\n+#define XML_ESCAPE_NON_ASCII        (1u << 1)\n+#define XML_ESCAPE_HTML             (1u << 2)\n+#define XML_ESCAPE_QUOT             (1u << 3)\n+#define XML_ESCAPE_ALLOW_INVALID    (1u << 4)\n+\n+XML_HIDDEN int\n+xmlSerializeHexCharRef(char *buf, int val);\n+XML_HIDDEN int\n+xmlSerializeDecCharRef(char *buf, int val);\n+\n+XML_HIDDEN xmlChar *\n+xmlEscapeText(const xmlChar *text, int flags);\n+\n@@ -25,1 +39,2 @@\n-xmlEncodeAttributeEntities(xmlDocPtr doc, const xmlChar *input);\n+xmlEncodeEntitiesInternal(xmlDocPtr doc, const xmlChar *input,\n+                          unsigned flags);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/entities.h","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -4,0 +4,2 @@\n+#include <stdarg.h>\n+\n@@ -11,0 +13,3 @@\n+XML_HIDDEN int\n+xmlIsCatastrophicError(int level, int code);\n+\n@@ -22,6 +27,6 @@\n-__xmlRaiseError(xmlStructuredErrorFunc schannel, xmlGenericErrorFunc channel,\n-                void *data, void *ctx, struct _xmlNode *node,\n-                int domain, int code, xmlErrorLevel level,\n-                const char *file, int line, const char *str1,\n-                const char *str2, const char *str3, int int1, int col,\n-            const char *msg, ...) LIBXML_ATTR_FORMAT(16,17);\n+xmlRaiseError(xmlStructuredErrorFunc schannel, xmlGenericErrorFunc channel,\n+              void *data, void *ctx, struct _xmlNode *node,\n+              int domain, int code, xmlErrorLevel level,\n+              const char *file, int line, const char *str1,\n+              const char *str2, const char *str3, int int1, int col,\n+              const char *msg, ...) LIBXML_ATTR_FORMAT(16,17);\n@@ -34,0 +39,7 @@\n+XML_HIDDEN void\n+xmlVPrintErrorMessage(const char *fmt, va_list ap);\n+XML_HIDDEN void\n+xmlPrintErrorMessage(const char *fmt, ...);\n+XML_HIDDEN void\n+xmlAbort(const char *fmt, ...);\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/error.h","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -9,1 +9,3 @@\n-#ifdef LIBXML_THREAD_ENABLED\n+XML_HIDDEN xmlError *\n+xmlGetLastErrorInternal(void);\n+\n@@ -12,1 +14,0 @@\n-#endif\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/globals.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -8,2 +8,2 @@\n-XML_HIDDEN void\n-__htmlParseContent(void *ctx);\n+XML_HIDDEN xmlNodePtr\n+htmlCtxtParseContentInternal(xmlParserCtxtPtr ctxt, xmlParserInputPtr input);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/html.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8,0 +8,10 @@\n+\/*\n+ * Initial buffer size should include\n+ *\n+ * - MINLEN = 4000 (I\/O chunk size)\n+ * - INPUT_CHUNK = 250 (parser prefetch)\n+ * - LINE_LEN = 80 (shrink limit for error messages)\n+ * - some amount for unshrunken content.\n+ *\/\n+#define XML_IO_BUFFER_SIZE 6000\n+\n@@ -11,3 +21,0 @@\n-XML_HIDDEN int\n-__xmlIOErr(int domain, int code, const char *extra);\n-\n@@ -17,3 +24,4 @@\n-XML_HIDDEN int\n-xmlParserInputBufferCreateFilenameSafe(const char *URI, xmlCharEncoding enc,\n-                                       xmlParserInputBufferPtr *out);\n+XML_HIDDEN xmlParserErrors\n+xmlParserInputBufferCreateUrl(const char *URI, xmlCharEncoding enc,\n+                              xmlParserInputFlags flags,\n+                              xmlParserInputBufferPtr *out);\n@@ -22,1 +30,1 @@\n-xmlNewInputBufferString(const char *str, int flags);\n+xmlNewInputBufferString(const char *str, xmlParserInputFlags flags);\n@@ -24,2 +32,2 @@\n-xmlNewInputBufferMemory(const void *mem, size_t size, int flags,\n-                        xmlCharEncoding enc);\n+xmlNewInputBufferMemory(const void *mem, size_t size,\n+                        xmlParserInputFlags flags, xmlCharEncoding enc);\n@@ -27,2 +35,2 @@\n-XML_HIDDEN int\n-xmlInputFromFd(xmlParserInputBufferPtr buf, int fd, int unzip);\n+XML_HIDDEN xmlParserErrors\n+xmlInputFromFd(xmlParserInputBufferPtr buf, int fd, xmlParserInputFlags flags);\n@@ -31,2 +39,0 @@\n-XML_HIDDEN xmlOutputBufferPtr\n-xmlAllocOutputBufferInternal(xmlCharEncodingHandlerPtr encoder);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/io.h","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -4,0 +4,11 @@\n+#include \"..\/..\/libxml.h\"\n+\n+#include <limits.h>\n+#include <stddef.h>\n+\n+#ifndef SIZE_MAX\n+  #define SIZE_MAX ((size_t) -1)\n+#endif\n+\n+#define XML_MAX_ITEMS 1000000000 \/* 1 billion *\/\n+\n@@ -9,0 +20,38 @@\n+\/**\n+ * xmlGrowCapacity:\n+ * @array:  pointer to array\n+ * @capacity:  pointer to capacity (in\/out)\n+ * @elemSize:  size of an element in bytes\n+ * @min:  elements in initial allocation\n+ * @max:  maximum elements in the array\n+ *\n+ * Grow an array by at least one element, checking for overflow.\n+ *\n+ * Returns the new array size on success, -1 on failure.\n+ *\/\n+static XML_INLINE int\n+xmlGrowCapacity(int capacity, size_t elemSize, int min, int max) {\n+    int extra;\n+\n+    if (capacity <= 0) {\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+        (void) min;\n+        return(1);\n+#else\n+        return(min);\n+#endif\n+    }\n+\n+    if ((capacity >= max) ||\n+        ((size_t) capacity > SIZE_MAX \/ 2 \/ elemSize))\n+        return(-1);\n+\n+    \/* Grow by 50% *\/\n+    extra = (capacity + 1) \/ 2;\n+\n+    if (capacity > max - extra)\n+        return(max);\n+\n+    return(capacity + extra);\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/memory.h","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -7,0 +7,4 @@\n+#define XML_INVALID_CHAR 0x200000\n+\n+#define XML_MAX_URI_LENGTH 2000\n+\n@@ -20,0 +24,3 @@\n+\/*\n+ * TODO: Rename to avoid confusion with xmlParserInputFlags\n+ *\/\n@@ -45,0 +52,12 @@\n+\/**\n+ * INPUT_CHUNK:\n+ *\n+ * The parser tries to always have that amount of input ready.\n+ * One of the point is providing context when reporting errors.\n+ *\/\n+#define INPUT_CHUNK     250\n+\n+struct _xmlAttrHashBucket {\n+    int index;\n+};\n+\n@@ -62,0 +81,2 @@\n+XML_HIDDEN int\n+xmlCtxtIsCatastrophicError(xmlParserCtxtPtr ctxt);\n@@ -77,0 +98,5 @@\n+XML_HIDDEN int\n+nodePush(xmlParserCtxtPtr ctxt, xmlNodePtr value);\n+XML_HIDDEN xmlNodePtr\n+nodePop(xmlParserCtxtPtr ctxt);\n+\n@@ -91,7 +117,0 @@\n-#define XML_INPUT_BUF_STATIC        (1u << 1)\n-#define XML_INPUT_BUF_ZERO_TERMINATED    (1u << 2)\n-#define XML_INPUT_UNZIP            (1u << 3)\n-\n-\/* Internal parser option *\/\n-#define XML_PARSE_UNZIP     (1 << 24)\n-\n@@ -99,2 +118,6 @@\n-xmlNewInputURL(xmlParserCtxtPtr ctxt, const char *url, const char *publicId,\n-               const char *encoding, int flags);\n+xmlLoadResource(xmlParserCtxtPtr ctxt, const char *url, const char *publicId,\n+                xmlResourceType type);\n+XML_HIDDEN xmlParserInputPtr\n+xmlCtxtNewInputFromUrl(xmlParserCtxtPtr ctxt, const char *url,\n+                       const char *publicId, const char *encoding,\n+                       xmlParserInputFlags flags);\n@@ -102,3 +125,4 @@\n-xmlNewInputMemory(xmlParserCtxtPtr ctxt, const char *url,\n-                  const void *mem, size_t size,\n-                  const char *encoding, int flags);\n+xmlCtxtNewInputFromMemory(xmlParserCtxtPtr ctxt, const char *url,\n+                          const void *mem, size_t size,\n+                          const char *encoding,\n+                          xmlParserInputFlags flags);\n@@ -106,2 +130,3 @@\n-xmlNewInputString(xmlParserCtxtPtr ctxt, const char *url, const char *str,\n-                  const char *encoding, int flags);\n+xmlCtxtNewInputFromString(xmlParserCtxtPtr ctxt, const char *url,\n+                          const char *str, const char *encoding,\n+                          xmlParserInputFlags flags);\n@@ -109,2 +134,2 @@\n-xmlNewInputFd(xmlParserCtxtPtr ctxt, const char *filename, int fd,\n-              const char *encoding, int flags);\n+xmlCtxtNewInputFromFd(xmlParserCtxtPtr ctxt, const char *filename, int fd,\n+                      const char *encoding, xmlParserInputFlags flags);\n@@ -112,5 +137,5 @@\n-xmlNewInputIO(xmlParserCtxtPtr ctxt, const char *url,\n-              xmlInputReadCallback ioRead,\n-              xmlInputCloseCallback ioClose,\n-              void *ioCtxt,\n-              const char *encoding, int flags);\n+xmlCtxtNewInputFromIO(xmlParserCtxtPtr ctxt, const char *url,\n+                      xmlInputReadCallback ioRead,\n+                      xmlInputCloseCallback ioClose,\n+                      void *ioCtxt,\n+                      const char *encoding, xmlParserInputFlags flags);\n@@ -118,2 +143,1 @@\n-xmlNewInputPush(xmlParserCtxtPtr ctxt, const char *url,\n-                const char *chunk, int size, const char *encoding);\n+xmlNewPushInput(const char *url, const char *chunk, int size);\n@@ -125,0 +149,3 @@\n+XML_HIDDEN void\n+xmlParserCheckEOF(xmlParserCtxtPtr ctxt, xmlParserErrors code);\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/parser.h","additions":50,"deletions":23,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -7,4 +7,1 @@\n-  #ifdef HAVE_PTHREAD_H\n-    #include <pthread.h>\n-    #define HAVE_POSIX_THREADS\n-  #elif defined(_WIN32)\n+  #ifdef _WIN32\n@@ -12,0 +9,4 @@\n+    #ifdef _WIN32_WINNT\n+      #undef _WIN32_WINNT\n+    #endif\n+    #define _WIN32_WINNT 0x0600\n@@ -14,0 +15,3 @@\n+  #else\n+    #include <pthread.h>\n+    #define HAVE_POSIX_THREADS\n@@ -30,0 +34,17 @@\n+\/*\n+ * xmlRMutex are reentrant mutual exception locks\n+ *\/\n+struct _xmlRMutex {\n+#ifdef HAVE_POSIX_THREADS\n+    pthread_mutex_t lock;\n+    unsigned int held;\n+    unsigned int waiters;\n+    pthread_t tid;\n+    pthread_cond_t cv;\n+#elif defined HAVE_WIN32_THREADS\n+    CRITICAL_SECTION cs;\n+#else\n+    int empty;\n+#endif\n+};\n+\n@@ -35,0 +56,5 @@\n+XML_HIDDEN void\n+xmlInitRMutex(xmlRMutexPtr mutex);\n+XML_HIDDEN void\n+xmlCleanupRMutex(xmlRMutexPtr mutex);\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/threads.h","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -4,5 +4,0 @@\n-\/*\n- * Internal variable indicating if a callback has been registered for\n- * node creation\/destruction. It avoids spending a lot of time in locking\n- * function while checking if the callback exists.\n- *\/\n@@ -10,1 +5,1 @@\n-__xmlRegisterCallbacks;\n+xmlRegisterCallbacks;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/private\/tree.h","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,4 +33,0 @@\n-#ifndef XML_SOCKLEN_T\n-#define XML_SOCKLEN_T int\n-#endif\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/include\/wsockcompat.h","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,7 +32,24 @@\n-\/*\n- * Due to some Autotools limitations, this variable must be passed as\n- * compiler flag. Define a default value if the macro wasn't set by the\n- * build system.\n- *\/\n-#ifndef SYSCONFDIR\n-  #define SYSCONFDIR \"\/etc\"\n+#if defined(__has_attribute)\n+#define XML_HAS_ATTRIBUTE(x) __has_attribute(x)\n+#else\n+#define XML_HAS_ATTRIBUTE(x) 0\n+#endif\n+\n+#if __STDC_VERSION__ >= 199901L\n+  #define XML_INLINE inline\n+#elif defined(_MSC_VER)\n+  #if _MSC_VER >= 1900\n+    #define XML_INLINE inline\n+  #else\n+    #define XML_INLINE _inline\n+  #endif\n+#else\n+  #define XML_INLINE\n+#endif\n+\n+#if __STDC_VERSION__ >= 199901L || (defined(_MSC_VER) && _MSC_VER >= 1900)\n+  #include <stdint.h>\n+  #define XML_INTPTR_T intptr_t\n+#else\n+  #include <stddef.h>\n+  #define XML_INTPTR_T ptrdiff_t\n@@ -41,0 +58,3 @@\n+#define XML_PTR_TO_INT(p) ((XML_INTPTR_T) (p))\n+#define XML_INT_TO_PTR(i) ((void *) (XML_INTPTR_T) (i))\n+\n@@ -50,0 +70,16 @@\n+#if __GNUC__ * 100 + __GNUC_MINOR__ >= 207 || defined(__clang__)\n+  #define ATTRIBUTE_UNUSED __attribute__((unused))\n+#else\n+  #define ATTRIBUTE_UNUSED\n+#endif\n+\n+#ifdef HAVE_FUNC_ATTRIBUTE_DESTRUCTOR\n+  #define ATTRIBUTE_DESTRUCTOR __attribute__((destructor))\n+#endif\n+\n+#if XML_HAS_ATTRIBUTE(__counted_by__)\n+  #define ATTRIBUTE_COUNTED_BY(c) __attribute__((__counted_by__(c)))\n+#else\n+  #define ATTRIBUTE_COUNTED_BY(c)\n+#endif\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml.h","additions":43,"deletions":7,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    return (0);\n+        return (0);\n@@ -191,1 +191,2 @@\n-    if (NULL == (l = (xmlListPtr )xmlMalloc( sizeof(xmlList))))\n+    l = (xmlListPtr)xmlMalloc(sizeof(xmlList));\n+    if (l == NULL)\n@@ -197,2 +198,3 @@\n-    if (NULL ==(l->sentinel = (xmlLinkPtr )xmlMalloc(sizeof(xmlLink)))) {\n-    xmlFree(l);\n+    l->sentinel = (xmlLinkPtr)xmlMalloc(sizeof(xmlLink));\n+    if (l->sentinel == NULL) {\n+        xmlFree(l);\n@@ -376,1 +378,1 @@\n-    xmlLinkDeallocator(l, lk);\n+        xmlLinkDeallocator(l, lk);\n@@ -568,1 +570,2 @@\n-    if (NULL ==(lkNew = (xmlLinkPtr )xmlMalloc(sizeof(xmlLink))))\n+    lkNew = (xmlLinkPtr)xmlMalloc(sizeof(xmlLink));\n+    if (lkNew == NULL)\n@@ -641,1 +644,2 @@\n-    if (NULL ==(lTemp = xmlListDup(l)))\n+    lTemp = xmlListDup(l);\n+    if (lTemp == NULL)\n@@ -646,1 +650,0 @@\n-    return;\n@@ -727,1 +730,2 @@\n-    if (NULL ==(cur = xmlListCreate(NULL, old->linkCompare)))\n+    cur = xmlListCreate(NULL, old->linkCompare);\n+    if (cur == NULL)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/list.c","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1,1982 +0,0 @@\n-\/*\n- * nanoftp.c: basic FTP client support\n- *\n- *  Reference: RFC 959\n- *\/\n-\n-#ifdef TESTING\n-#define STANDALONE\n-#define HAVE_UNISTD_H\n-#define HAVE_SYS_SOCKET_H\n-#define HAVE_NETINET_IN_H\n-#define HAVE_NETDB_H\n-#define HAVE_SYS_TIME_H\n-#endif \/* TESTING *\/\n-\n-#define IN_LIBXML\n-#include \"libxml.h\"\n-\n-#ifdef LIBXML_FTP_ENABLED\n-#include <string.h>\n-#include <stdlib.h>\n-#include <errno.h>\n-\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#elif defined (_WIN32)\n-#include <io.h>\n-#endif\n-#ifdef HAVE_SYS_SOCKET_H\n-#include <sys\/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#include <netinet\/in.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#include <arpa\/inet.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n-#include <netdb.h>\n-#endif\n-#ifdef HAVE_FCNTL_H\n-#include <fcntl.h>\n-#endif\n-#ifdef HAVE_SYS_TIME_H\n-#include <sys\/time.h>\n-#endif\n-#ifdef HAVE_SYS_SELECT_H\n-#include <sys\/select.h>\n-#endif\n-#ifdef HAVE_SYS_SOCKET_H\n-#include <sys\/socket.h>\n-#endif\n-\n-#include <libxml\/xmlmemory.h>\n-#include <libxml\/parser.h>\n-#include <libxml\/xmlerror.h>\n-#include <libxml\/uri.h>\n-#include <libxml\/nanoftp.h>\n-\n-#include \"private\/error.h\"\n-#include \"private\/io.h\"\n-\n-#if defined(_WIN32)\n-#include <wsockcompat.h>\n-#endif\n-\n-\/**\n- * A couple portability macros\n- *\/\n-#ifndef _WINSOCKAPI_\n-#define closesocket(s) close(s)\n-#endif\n-\n-#ifndef XML_SOCKLEN_T\n-#define XML_SOCKLEN_T unsigned int\n-#endif\n-\n-#define GETHOSTBYNAME_ARG_CAST (char *)\n-#define SEND_ARG2_CAST (char *)\n-\n-#define FTP_COMMAND_OK        200\n-#define FTP_SYNTAX_ERROR    500\n-#define FTP_GET_PASSWD        331\n-#define FTP_BUF_SIZE        1024\n-\n-#define XML_NANO_MAX_URLBUF    4096\n-\n-typedef struct xmlNanoFTPCtxt {\n-    char *protocol;    \/* the protocol name *\/\n-    char *hostname;    \/* the host name *\/\n-    int port;        \/* the port *\/\n-    char *path;        \/* the path within the URL *\/\n-    char *user;        \/* user string *\/\n-    char *passwd;    \/* passwd string *\/\n-#ifdef SUPPORT_IP6\n-    struct sockaddr_storage ftpAddr; \/* this is large enough to hold IPv6 address*\/\n-#else\n-    struct sockaddr_in ftpAddr; \/* the socket address struct *\/\n-#endif\n-    int passive;    \/* currently we support only passive !!! *\/\n-    SOCKET controlFd;    \/* the file descriptor for the control socket *\/\n-    SOCKET dataFd;    \/* the file descriptor for the data socket *\/\n-    int state;        \/* WRITE \/ READ \/ CLOSED *\/\n-    int returnValue;    \/* the protocol return value *\/\n-    \/* buffer for data received from the control connection *\/\n-    char controlBuf[FTP_BUF_SIZE + 1];\n-    int controlBufIndex;\n-    int controlBufUsed;\n-    int controlBufAnswer;\n-} xmlNanoFTPCtxt, *xmlNanoFTPCtxtPtr;\n-\n-static int initialized = 0;\n-static char *proxy = NULL;    \/* the proxy name if any *\/\n-static int proxyPort = 0;    \/* the proxy port if any *\/\n-static char *proxyUser = NULL;    \/* user for proxy authentication *\/\n-static char *proxyPasswd = NULL;\/* passwd for proxy authentication *\/\n-static int proxyType = 0;    \/* uses TYPE or a@b ? *\/\n-\n-#ifdef SUPPORT_IP6\n-static\n-int have_ipv6(void) {\n-    int s;\n-\n-    s = socket (AF_INET6, SOCK_STREAM, 0);\n-    if (s != -1) {\n-    close (s);\n-    return (1);\n-    }\n-    return (0);\n-}\n-#endif\n-\n-\/**\n- * xmlFTPErrMemory:\n- * @extra:  extra information\n- *\n- * Handle an out of memory condition\n- *\/\n-static void\n-xmlFTPErrMemory(const char *extra ATTRIBUTE_UNUSED)\n-{\n-    xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_FTP, NULL);\n-}\n-\n-\/**\n- * xmlNanoFTPInit:\n- *\n- * Initialize the FTP protocol layer.\n- * Currently it just checks for proxy information,\n- * and get the hostname\n- *\/\n-\n-void\n-xmlNanoFTPInit(void) {\n-    const char *env;\n-#ifdef _WINSOCKAPI_\n-    WSADATA wsaData;\n-#endif\n-\n-    if (initialized)\n-    return;\n-\n-#ifdef _WINSOCKAPI_\n-    if (WSAStartup(MAKEWORD(1, 1), &wsaData) != 0)\n-    return;\n-#endif\n-\n-    proxyPort = 21;\n-    env = getenv(\"no_proxy\");\n-    if (env && ((env[0] == '*' ) && (env[1] == 0)))\n-    return;\n-    env = getenv(\"ftp_proxy\");\n-    if (env != NULL) {\n-    xmlNanoFTPScanProxy(env);\n-    } else {\n-    env = getenv(\"FTP_PROXY\");\n-    if (env != NULL) {\n-        xmlNanoFTPScanProxy(env);\n-    }\n-    }\n-    env = getenv(\"ftp_proxy_user\");\n-    if (env != NULL) {\n-    proxyUser = xmlMemStrdup(env);\n-    }\n-    env = getenv(\"ftp_proxy_password\");\n-    if (env != NULL) {\n-    proxyPasswd = xmlMemStrdup(env);\n-    }\n-    initialized = 1;\n-}\n-\n-\/**\n- * xmlNanoFTPCleanup:\n- *\n- * Cleanup the FTP protocol layer. This cleanup proxy information.\n- *\/\n-\n-void\n-xmlNanoFTPCleanup(void) {\n-    if (proxy != NULL) {\n-    xmlFree(proxy);\n-    proxy = NULL;\n-    }\n-    if (proxyUser != NULL) {\n-    xmlFree(proxyUser);\n-    proxyUser = NULL;\n-    }\n-    if (proxyPasswd != NULL) {\n-    xmlFree(proxyPasswd);\n-    proxyPasswd = NULL;\n-    }\n-#ifdef _WINSOCKAPI_\n-    if (initialized)\n-    WSACleanup();\n-#endif\n-    initialized = 0;\n-}\n-\n-\/**\n- * xmlNanoFTPProxy:\n- * @host:  the proxy host name\n- * @port:  the proxy port\n- * @user:  the proxy user name\n- * @passwd:  the proxy password\n- * @type:  the type of proxy 1 for using SITE, 2 for USER a@b\n- *\n- * Setup the FTP proxy information.\n- * This can also be done by using ftp_proxy ftp_proxy_user and\n- * ftp_proxy_password environment variables.\n- *\/\n-\n-void\n-xmlNanoFTPProxy(const char *host, int port, const char *user,\n-            const char *passwd, int type) {\n-    if (proxy != NULL) {\n-    xmlFree(proxy);\n-    proxy = NULL;\n-    }\n-    if (proxyUser != NULL) {\n-    xmlFree(proxyUser);\n-    proxyUser = NULL;\n-    }\n-    if (proxyPasswd != NULL) {\n-    xmlFree(proxyPasswd);\n-    proxyPasswd = NULL;\n-    }\n-    if (host)\n-    proxy = xmlMemStrdup(host);\n-    if (user)\n-    proxyUser = xmlMemStrdup(user);\n-    if (passwd)\n-    proxyPasswd = xmlMemStrdup(passwd);\n-    proxyPort = port;\n-    proxyType = type;\n-}\n-\n-\/**\n- * xmlNanoFTPScanURL:\n- * @ctx:  an FTP context\n- * @URL:  The URL used to initialize the context\n- *\n- * (Re)Initialize an FTP context by parsing the URL and finding\n- * the protocol host port and path it indicates.\n- *\/\n-\n-static void\n-xmlNanoFTPScanURL(void *ctx, const char *URL) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    xmlURIPtr uri;\n-\n-    \/*\n-     * Clear any existing data from the context\n-     *\/\n-    if (ctxt->protocol != NULL) {\n-        xmlFree(ctxt->protocol);\n-    ctxt->protocol = NULL;\n-    }\n-    if (ctxt->hostname != NULL) {\n-        xmlFree(ctxt->hostname);\n-    ctxt->hostname = NULL;\n-    }\n-    if (ctxt->path != NULL) {\n-        xmlFree(ctxt->path);\n-    ctxt->path = NULL;\n-    }\n-    if (URL == NULL) return;\n-\n-    uri = xmlParseURIRaw(URL, 1);\n-    if (uri == NULL)\n-    return;\n-\n-    if ((uri->scheme == NULL) || (uri->server == NULL)) {\n-    xmlFreeURI(uri);\n-    return;\n-    }\n-\n-    ctxt->protocol = xmlMemStrdup(uri->scheme);\n-    ctxt->hostname = xmlMemStrdup(uri->server);\n-    if (uri->path != NULL)\n-    ctxt->path = xmlMemStrdup(uri->path);\n-    else\n-    ctxt->path = xmlMemStrdup(\"\/\");\n-    if (uri->port != 0)\n-    ctxt->port = uri->port;\n-\n-    if (uri->user != NULL) {\n-    char *cptr;\n-    if ((cptr=strchr(uri->user, ':')) == NULL)\n-        ctxt->user = xmlMemStrdup(uri->user);\n-    else {\n-        ctxt->user = (char *)xmlStrndup((xmlChar *)uri->user,\n-                (cptr - uri->user));\n-        ctxt->passwd = xmlMemStrdup(cptr+1);\n-    }\n-    }\n-\n-    xmlFreeURI(uri);\n-\n-}\n-\n-\/**\n- * xmlNanoFTPUpdateURL:\n- * @ctx:  an FTP context\n- * @URL:  The URL used to update the context\n- *\n- * Update an FTP context by parsing the URL and finding\n- * new path it indicates. If there is an error in the\n- * protocol, hostname, port or other information, the\n- * error is raised. It indicates a new connection has to\n- * be established.\n- *\n- * Returns 0 if Ok, -1 in case of error (other host).\n- *\/\n-\n-int\n-xmlNanoFTPUpdateURL(void *ctx, const char *URL) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    xmlURIPtr uri;\n-\n-    if (URL == NULL)\n-    return(-1);\n-    if (ctxt == NULL)\n-    return(-1);\n-    if (ctxt->protocol == NULL)\n-    return(-1);\n-    if (ctxt->hostname == NULL)\n-    return(-1);\n-\n-    uri = xmlParseURIRaw(URL, 1);\n-    if (uri == NULL)\n-    return(-1);\n-\n-    if ((uri->scheme == NULL) || (uri->server == NULL)) {\n-    xmlFreeURI(uri);\n-    return(-1);\n-    }\n-    if ((strcmp(ctxt->protocol, uri->scheme)) ||\n-    (strcmp(ctxt->hostname, uri->server)) ||\n-    ((uri->port != 0) && (ctxt->port != uri->port))) {\n-    xmlFreeURI(uri);\n-    return(-1);\n-    }\n-\n-    if (uri->port != 0)\n-    ctxt->port = uri->port;\n-\n-    if (ctxt->path != NULL) {\n-    xmlFree(ctxt->path);\n-    ctxt->path = NULL;\n-    }\n-\n-    if (uri->path == NULL)\n-        ctxt->path = xmlMemStrdup(\"\/\");\n-    else\n-    ctxt->path = xmlMemStrdup(uri->path);\n-\n-    xmlFreeURI(uri);\n-\n-    return(0);\n-}\n-\n-\/**\n- * xmlNanoFTPScanProxy:\n- * @URL:  The proxy URL used to initialize the proxy context\n- *\n- * (Re)Initialize the FTP Proxy context by parsing the URL and finding\n- * the protocol host port it indicates.\n- * Should be like ftp:\/\/myproxy\/ or ftp:\/\/myproxy:3128\/\n- * A NULL URL cleans up proxy information.\n- *\/\n-\n-void\n-xmlNanoFTPScanProxy(const char *URL) {\n-    xmlURIPtr uri;\n-\n-    if (proxy != NULL) {\n-        xmlFree(proxy);\n-    proxy = NULL;\n-    }\n-    proxyPort = 0;\n-\n-    if (URL == NULL) return;\n-\n-    uri = xmlParseURIRaw(URL, 1);\n-    if ((uri == NULL) || (uri->scheme == NULL) ||\n-    (strcmp(uri->scheme, \"ftp\")) || (uri->server == NULL)) {\n-    __xmlIOErr(XML_FROM_FTP, XML_FTP_URL_SYNTAX, \"Syntax Error\\n\");\n-    if (uri != NULL)\n-        xmlFreeURI(uri);\n-    return;\n-    }\n-\n-    proxy = xmlMemStrdup(uri->server);\n-    if (uri->port != 0)\n-    proxyPort = uri->port;\n-\n-    xmlFreeURI(uri);\n-}\n-\n-\/**\n- * xmlNanoFTPNewCtxt:\n- * @URL:  The URL used to initialize the context\n- *\n- * Allocate and initialize a new FTP context.\n- *\n- * Returns an FTP context or NULL in case of error.\n- *\/\n-\n-void*\n-xmlNanoFTPNewCtxt(const char *URL) {\n-    xmlNanoFTPCtxtPtr ret;\n-    char *unescaped;\n-\n-    ret = (xmlNanoFTPCtxtPtr) xmlMalloc(sizeof(xmlNanoFTPCtxt));\n-    if (ret == NULL) {\n-        xmlFTPErrMemory(\"allocating FTP context\");\n-        return(NULL);\n-    }\n-\n-    memset(ret, 0, sizeof(xmlNanoFTPCtxt));\n-    ret->port = 21;\n-    ret->passive = 1;\n-    ret->returnValue = 0;\n-    ret->controlBufIndex = 0;\n-    ret->controlBufUsed = 0;\n-    ret->controlFd = INVALID_SOCKET;\n-\n-    unescaped = xmlURIUnescapeString(URL, 0, NULL);\n-    if (unescaped != NULL) {\n-    xmlNanoFTPScanURL(ret, unescaped);\n-    xmlFree(unescaped);\n-    } else if (URL != NULL)\n-    xmlNanoFTPScanURL(ret, URL);\n-\n-    return(ret);\n-}\n-\n-\/**\n- * xmlNanoFTPFreeCtxt:\n- * @ctx:  an FTP context\n- *\n- * Frees the context after closing the connection.\n- *\/\n-\n-void\n-xmlNanoFTPFreeCtxt(void * ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    if (ctxt == NULL) return;\n-    if (ctxt->hostname != NULL) xmlFree(ctxt->hostname);\n-    if (ctxt->protocol != NULL) xmlFree(ctxt->protocol);\n-    if (ctxt->path != NULL) xmlFree(ctxt->path);\n-    if (ctxt->user != NULL) xmlFree(ctxt->user);\n-    if (ctxt->passwd != NULL) xmlFree(ctxt->passwd);\n-    ctxt->passive = 1;\n-    if (ctxt->controlFd != INVALID_SOCKET) closesocket(ctxt->controlFd);\n-    ctxt->controlFd = INVALID_SOCKET;\n-    ctxt->controlBufIndex = -1;\n-    ctxt->controlBufUsed = -1;\n-    xmlFree(ctxt);\n-}\n-\n-\/**\n- * xmlNanoFTPParseResponse:\n- * @buf:  the buffer containing the response\n- * @len:  the buffer length\n- *\n- * Parsing of the server answer, we just extract the code.\n- *\n- * returns 0 for errors\n- *     +XXX for last line of response\n- *     -XXX for response to be continued\n- *\/\n-static int\n-xmlNanoFTPParseResponse(char *buf, int len) {\n-    int val = 0;\n-\n-    if (len < 3) return(-1);\n-    if ((*buf >= '0') && (*buf <= '9'))\n-        val = val * 10 + (*buf - '0');\n-    else\n-        return(0);\n-    buf++;\n-    if ((*buf >= '0') && (*buf <= '9'))\n-        val = val * 10 + (*buf - '0');\n-    else\n-        return(0);\n-    buf++;\n-    if ((*buf >= '0') && (*buf <= '9'))\n-        val = val * 10 + (*buf - '0');\n-    else\n-        return(0);\n-    buf++;\n-    if (*buf == '-')\n-        return(-val);\n-    return(val);\n-}\n-\n-\/**\n- * xmlNanoFTPGetMore:\n- * @ctx:  an FTP context\n- *\n- * Read more information from the FTP control connection\n- * Returns the number of bytes read, < 0 indicates an error\n- *\/\n-static int\n-xmlNanoFTPGetMore(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    int len;\n-    int size;\n-\n-    if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);\n-\n-    if ((ctxt->controlBufIndex < 0) || (ctxt->controlBufIndex > FTP_BUF_SIZE)) {\n-    return(-1);\n-    }\n-\n-    if ((ctxt->controlBufUsed < 0) || (ctxt->controlBufUsed > FTP_BUF_SIZE)) {\n-    return(-1);\n-    }\n-    if (ctxt->controlBufIndex > ctxt->controlBufUsed) {\n-    return(-1);\n-    }\n-\n-    \/*\n-     * First pack the control buffer\n-     *\/\n-    if (ctxt->controlBufIndex > 0) {\n-    memmove(&ctxt->controlBuf[0], &ctxt->controlBuf[ctxt->controlBufIndex],\n-        ctxt->controlBufUsed - ctxt->controlBufIndex);\n-    ctxt->controlBufUsed -= ctxt->controlBufIndex;\n-    ctxt->controlBufIndex = 0;\n-    }\n-    size = FTP_BUF_SIZE - ctxt->controlBufUsed;\n-    if (size == 0) {\n-    return(0);\n-    }\n-\n-    \/*\n-     * Read the amount left on the control connection\n-     *\/\n-    if ((len = recv(ctxt->controlFd, &ctxt->controlBuf[ctxt->controlBufIndex],\n-            size, 0)) < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"recv failed\");\n-    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    ctxt->controlBufUsed += len;\n-    ctxt->controlBuf[ctxt->controlBufUsed] = 0;\n-\n-    return(len);\n-}\n-\n-\/**\n- * xmlNanoFTPReadResponse:\n- * @ctx:  an FTP context\n- *\n- * Read the response from the FTP server after a command.\n- * Returns the code number\n- *\/\n-static int\n-xmlNanoFTPReadResponse(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char *ptr, *end;\n-    int len;\n-    int res = -1, cur = -1;\n-\n-    if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);\n-\n-get_more:\n-    \/*\n-     * Assumes everything up to controlBuf[controlBufIndex] has been read\n-     * and analyzed.\n-     *\/\n-    len = xmlNanoFTPGetMore(ctx);\n-    if (len < 0) {\n-        return(-1);\n-    }\n-    if ((ctxt->controlBufUsed == 0) && (len == 0)) {\n-        return(-1);\n-    }\n-    ptr = &ctxt->controlBuf[ctxt->controlBufIndex];\n-    end = &ctxt->controlBuf[ctxt->controlBufUsed];\n-\n-    while (ptr < end) {\n-        cur = xmlNanoFTPParseResponse(ptr, end - ptr);\n-    if (cur > 0) {\n-        \/*\n-         * Successfully scanned the control code, scratch\n-         * till the end of the line, but keep the index to be\n-         * able to analyze the result if needed.\n-         *\/\n-        res = cur;\n-        ptr += 3;\n-        ctxt->controlBufAnswer = ptr - ctxt->controlBuf;\n-        while ((ptr < end) && (*ptr != '\\n')) ptr++;\n-        if (*ptr == '\\n') ptr++;\n-        if (*ptr == '\\r') ptr++;\n-        break;\n-    }\n-    while ((ptr < end) && (*ptr != '\\n')) ptr++;\n-    if (ptr >= end) {\n-        ctxt->controlBufIndex = ctxt->controlBufUsed;\n-        goto get_more;\n-    }\n-    if (*ptr != '\\r') ptr++;\n-    }\n-\n-    if (res < 0) goto get_more;\n-    ctxt->controlBufIndex = ptr - ctxt->controlBuf;\n-\n-    return(res \/ 100);\n-}\n-\n-\/**\n- * xmlNanoFTPGetResponse:\n- * @ctx:  an FTP context\n- *\n- * Get the response from the FTP server after a command.\n- * Returns the code number\n- *\/\n-\n-int\n-xmlNanoFTPGetResponse(void *ctx) {\n-    int res;\n-\n-    res = xmlNanoFTPReadResponse(ctx);\n-\n-    return(res);\n-}\n-\n-\/**\n- * xmlNanoFTPCheckResponse:\n- * @ctx:  an FTP context\n- *\n- * Check if there is a response from the FTP server after a command.\n- * Returns the code number, or 0\n- *\/\n-\n-int\n-xmlNanoFTPCheckResponse(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    fd_set rfd;\n-    struct timeval tv;\n-\n-    if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);\n-    tv.tv_sec = 0;\n-    tv.tv_usec = 0;\n-    FD_ZERO(&rfd);\n-    FD_SET(ctxt->controlFd, &rfd);\n-    switch(select(ctxt->controlFd + 1, &rfd, NULL, NULL, &tv)) {\n-    case 0:\n-        return(0);\n-    case -1:\n-        __xmlIOErr(XML_FROM_FTP, 0, \"select\");\n-        return(-1);\n-\n-    }\n-\n-    return(xmlNanoFTPReadResponse(ctx));\n-}\n-\n-\/**\n- * Send the user authentication\n- *\/\n-\n-static int\n-xmlNanoFTPSendUser(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[200];\n-    int len;\n-    int res;\n-\n-    if (ctxt->user == NULL)\n-    snprintf(buf, sizeof(buf), \"USER anonymous\\r\\n\");\n-    else\n-    snprintf(buf, sizeof(buf), \"USER %s\\r\\n\", ctxt->user);\n-    buf[sizeof(buf) - 1] = 0;\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * Send the password authentication\n- *\/\n-\n-static int\n-xmlNanoFTPSendPasswd(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[200];\n-    int len;\n-    int res;\n-\n-    if (ctxt->passwd == NULL)\n-    snprintf(buf, sizeof(buf), \"PASS anonymous@\\r\\n\");\n-    else\n-    snprintf(buf, sizeof(buf), \"PASS %s\\r\\n\", ctxt->passwd);\n-    buf[sizeof(buf) - 1] = 0;\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlNanoFTPQuit:\n- * @ctx:  an FTP context\n- *\n- * Send a QUIT command to the server\n- *\n- * Returns -1 in case of error, 0 otherwise\n- *\/\n-\n-\n-int\n-xmlNanoFTPQuit(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[200];\n-    int len, res;\n-\n-    if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);\n-\n-    snprintf(buf, sizeof(buf), \"QUIT\\r\\n\");\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlNanoFTPConnect:\n- * @ctx:  an FTP context\n- *\n- * Tries to open a control connection\n- *\n- * Returns -1 in case of error, 0 otherwise\n- *\/\n-\n-int\n-xmlNanoFTPConnect(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    struct hostent *hp;\n-    int port;\n-    int res;\n-    int addrlen = sizeof (struct sockaddr_in);\n-\n-    if (ctxt == NULL)\n-    return(-1);\n-    if (ctxt->hostname == NULL)\n-    return(-1);\n-\n-    \/*\n-     * do the blocking DNS query.\n-     *\/\n-    if (proxy) {\n-        port = proxyPort;\n-    } else {\n-    port = ctxt->port;\n-    }\n-    if (port == 0)\n-    port = 21;\n-\n-    memset (&ctxt->ftpAddr, 0, sizeof(ctxt->ftpAddr));\n-\n-#ifdef SUPPORT_IP6\n-    if (have_ipv6 ()) {\n-    struct addrinfo hints, *tmp, *result;\n-\n-    result = NULL;\n-    memset (&hints, 0, sizeof(hints));\n-    hints.ai_socktype = SOCK_STREAM;\n-\n-    if (proxy) {\n-        if (getaddrinfo (proxy, NULL, &hints, &result) != 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"getaddrinfo failed\");\n-        return (-1);\n-        }\n-    }\n-    else\n-        if (getaddrinfo (ctxt->hostname, NULL, &hints, &result) != 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"getaddrinfo failed\");\n-        return (-1);\n-        }\n-\n-    for (tmp = result; tmp; tmp = tmp->ai_next)\n-        if (tmp->ai_family == AF_INET || tmp->ai_family == AF_INET6)\n-        break;\n-\n-    if (!tmp) {\n-        if (result)\n-        freeaddrinfo (result);\n-        __xmlIOErr(XML_FROM_FTP, 0, \"getaddrinfo failed\");\n-        return (-1);\n-    }\n-    if ((size_t)tmp->ai_addrlen > sizeof(ctxt->ftpAddr)) {\n-        if (result)\n-        freeaddrinfo (result);\n-        __xmlIOErr(XML_FROM_FTP, 0, \"gethostbyname address mismatch\");\n-        return (-1);\n-    }\n-    if (tmp->ai_family == AF_INET6) {\n-        memcpy (&ctxt->ftpAddr, tmp->ai_addr, tmp->ai_addrlen);\n-        ((struct sockaddr_in6 *) &ctxt->ftpAddr)->sin6_port = htons (port);\n-        ctxt->controlFd = socket (AF_INET6, SOCK_STREAM, 0);\n-    }\n-    else {\n-        memcpy (&ctxt->ftpAddr, tmp->ai_addr, tmp->ai_addrlen);\n-        ((struct sockaddr_in *) &ctxt->ftpAddr)->sin_port = htons (port);\n-        ctxt->controlFd = socket (AF_INET, SOCK_STREAM, 0);\n-    }\n-    addrlen = tmp->ai_addrlen;\n-    freeaddrinfo (result);\n-    }\n-    else\n-#endif\n-    {\n-    if (proxy)\n-        hp = gethostbyname (GETHOSTBYNAME_ARG_CAST proxy);\n-    else\n-        hp = gethostbyname (GETHOSTBYNAME_ARG_CAST ctxt->hostname);\n-    if (hp == NULL) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"gethostbyname failed\");\n-        return (-1);\n-    }\n-    if ((unsigned int) hp->h_length >\n-        sizeof(((struct sockaddr_in *)&ctxt->ftpAddr)->sin_addr)) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"gethostbyname address mismatch\");\n-        return (-1);\n-    }\n-\n-    \/*\n-     * Prepare the socket\n-     *\/\n-    ((struct sockaddr_in *)&ctxt->ftpAddr)->sin_family = AF_INET;\n-    memcpy (&((struct sockaddr_in *)&ctxt->ftpAddr)->sin_addr,\n-        hp->h_addr_list[0], hp->h_length);\n-    ((struct sockaddr_in *)&ctxt->ftpAddr)->sin_port =\n-             (unsigned short)htons ((unsigned short)port);\n-    ctxt->controlFd = socket (AF_INET, SOCK_STREAM, 0);\n-    addrlen = sizeof (struct sockaddr_in);\n-    }\n-\n-    if (ctxt->controlFd == INVALID_SOCKET) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"socket failed\");\n-        return(-1);\n-    }\n-\n-    \/*\n-     * Do the connect.\n-     *\/\n-    if (connect(ctxt->controlFd, (struct sockaddr *) &ctxt->ftpAddr,\n-        addrlen) < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"Failed to create a connection\");\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-    return(-1);\n-    }\n-\n-    \/*\n-     * Wait for the HELLO from the server.\n-     *\/\n-    res = xmlNanoFTPGetResponse(ctxt);\n-    if (res != 2) {\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-    return(-1);\n-    }\n-\n-    \/*\n-     * State diagram for the login operation on the FTP server\n-     *\n-     * Reference: RFC 959\n-     *\n-     *                       1\n-     * +---+   USER    +---+------------->+---+\n-     * | B |---------->| W | 2       ---->| E |\n-     * +---+           +---+------  |  -->+---+\n-     *                  | |       | | |\n-     *                3 | | 4,5   | | |\n-     *    --------------   -----  | | |\n-     *   |                      | | | |\n-     *   |                      | | | |\n-     *   |                 ---------  |\n-     *   |               1|     | |   |\n-     *   V                |     | |   |\n-     * +---+   PASS    +---+ 2  |  ------>+---+\n-     * |   |---------->| W |------------->| S |\n-     * +---+           +---+   ---------->+---+\n-     *                  | |   | |     |\n-     *                3 | |4,5| |     |\n-     *    --------------   --------   |\n-     *   |                    | |  |  |\n-     *   |                    | |  |  |\n-     *   |                 -----------\n-     *   |             1,3|   | |  |\n-     *   V                |  2| |  |\n-     * +---+   ACCT    +---+--  |   ----->+---+\n-     * |   |---------->| W | 4,5 -------->| F |\n-     * +---+           +---+------------->+---+\n-     *\n-     * Of course in case of using a proxy this get really nasty and is not\n-     * standardized at all :-(\n-     *\/\n-    if (proxy) {\n-        int len;\n-    char buf[400];\n-\n-        if (proxyUser != NULL) {\n-        \/*\n-         * We need proxy auth\n-         *\/\n-        snprintf(buf, sizeof(buf), \"USER %s\\r\\n\", proxyUser);\n-            buf[sizeof(buf) - 1] = 0;\n-            len = strlen(buf);\n-        res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-        if (res < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-        closesocket(ctxt->controlFd);\n-        ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n-        }\n-        res = xmlNanoFTPGetResponse(ctxt);\n-        switch (res) {\n-        case 2:\n-            if (proxyPasswd == NULL)\n-            break;\n-                    \/* Falls through. *\/\n-        case 3:\n-            if (proxyPasswd != NULL)\n-            snprintf(buf, sizeof(buf), \"PASS %s\\r\\n\", proxyPasswd);\n-            else\n-            snprintf(buf, sizeof(buf), \"PASS anonymous@\\r\\n\");\n-                    buf[sizeof(buf) - 1] = 0;\n-                    len = strlen(buf);\n-            res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-            if (res < 0) {\n-            __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-            closesocket(ctxt->controlFd);\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n-            }\n-            res = xmlNanoFTPGetResponse(ctxt);\n-            if (res > 3) {\n-            closesocket(ctxt->controlFd);\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(-1);\n-            }\n-            break;\n-        case 1:\n-            break;\n-        case 4:\n-        case 5:\n-        case -1:\n-        default:\n-            closesocket(ctxt->controlFd);\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(-1);\n-        }\n-    }\n-\n-    \/*\n-     * We assume we don't need more authentication to the proxy\n-     * and that it succeeded :-\\\n-     *\/\n-    switch (proxyType) {\n-        case 0:\n-        \/* we will try in sequence *\/\n-        case 1:\n-        \/* Using SITE command *\/\n-        snprintf(buf, sizeof(buf), \"SITE %s\\r\\n\", ctxt->hostname);\n-                buf[sizeof(buf) - 1] = 0;\n-                len = strlen(buf);\n-        res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-        if (res < 0) {\n-            __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n-        }\n-        res = xmlNanoFTPGetResponse(ctxt);\n-        if (res == 2) {\n-            \/* we assume it worked :-\\ 1 is error for SITE command *\/\n-            proxyType = 1;\n-            break;\n-        }\n-        if (proxyType == 1) {\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(-1);\n-        }\n-                \/* Falls through. *\/\n-        case 2:\n-        \/* USER user@host command *\/\n-        if (ctxt->user == NULL)\n-            snprintf(buf, sizeof(buf), \"USER anonymous@%s\\r\\n\",\n-                       ctxt->hostname);\n-        else\n-            snprintf(buf, sizeof(buf), \"USER %s@%s\\r\\n\",\n-                       ctxt->user, ctxt->hostname);\n-                buf[sizeof(buf) - 1] = 0;\n-                len = strlen(buf);\n-        res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-        if (res < 0) {\n-            __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n-        }\n-        res = xmlNanoFTPGetResponse(ctxt);\n-        if ((res == 1) || (res == 2)) {\n-            \/* we assume it worked :-\\ *\/\n-            proxyType = 2;\n-            return(0);\n-        }\n-        if (ctxt->passwd == NULL)\n-            snprintf(buf, sizeof(buf), \"PASS anonymous@\\r\\n\");\n-        else\n-            snprintf(buf, sizeof(buf), \"PASS %s\\r\\n\", ctxt->passwd);\n-                buf[sizeof(buf) - 1] = 0;\n-                len = strlen(buf);\n-        res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-        if (res < 0) {\n-            __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(res);\n-        }\n-        res = xmlNanoFTPGetResponse(ctxt);\n-        if ((res == 1) || (res == 2)) {\n-            \/* we assume it worked :-\\ *\/\n-            proxyType = 2;\n-            return(0);\n-        }\n-        if (proxyType == 2) {\n-            closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-            ctxt->controlFd = INVALID_SOCKET;\n-            return(-1);\n-        }\n-                \/* Falls through. *\/\n-        case 3:\n-        \/*\n-         * If you need support for other Proxy authentication scheme\n-         * send the code or at least the sequence in use.\n-         *\/\n-        default:\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    }\n-    \/*\n-     * Non-proxy handling.\n-     *\/\n-    res = xmlNanoFTPSendUser(ctxt);\n-    if (res < 0) {\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-    return(-1);\n-    }\n-    res = xmlNanoFTPGetResponse(ctxt);\n-    switch (res) {\n-    case 2:\n-        return(0);\n-    case 3:\n-        break;\n-    case 1:\n-    case 4:\n-    case 5:\n-        case -1:\n-    default:\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    res = xmlNanoFTPSendPasswd(ctxt);\n-    if (res < 0) {\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-    return(-1);\n-    }\n-    res = xmlNanoFTPGetResponse(ctxt);\n-    switch (res) {\n-    case 2:\n-        break;\n-    case 3:\n-        __xmlIOErr(XML_FROM_FTP, XML_FTP_ACCNT,\n-               \"FTP server asking for ACCNT on anonymous\\n\");\n-           \/* Falls through. *\/\n-    case 1:\n-    case 4:\n-    case 5:\n-        case -1:\n-    default:\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        ctxt->controlFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-\n-    return(0);\n-}\n-\n-\/**\n- * xmlNanoFTPConnectTo:\n- * @server:  an FTP server name\n- * @port:  the port (use 21 if 0)\n- *\n- * Tries to open a control connection to the given server\/port\n- *\n- * Returns an fTP context or NULL if it failed\n- *\/\n-\n-void*\n-xmlNanoFTPConnectTo(const char *server, int port) {\n-    xmlNanoFTPCtxtPtr ctxt;\n-    int res;\n-\n-    xmlNanoFTPInit();\n-    if (server == NULL)\n-    return(NULL);\n-    if (port <= 0)\n-    return(NULL);\n-    ctxt = (xmlNanoFTPCtxtPtr) xmlNanoFTPNewCtxt(NULL);\n-    if (ctxt == NULL)\n-        return(NULL);\n-    ctxt->hostname = xmlMemStrdup(server);\n-    if (ctxt->hostname == NULL) {\n-    xmlNanoFTPFreeCtxt(ctxt);\n-    return(NULL);\n-    }\n-    ctxt->port = port;\n-    res = xmlNanoFTPConnect(ctxt);\n-    if (res < 0) {\n-    xmlNanoFTPFreeCtxt(ctxt);\n-    return(NULL);\n-    }\n-    return(ctxt);\n-}\n-\n-\/**\n- * xmlNanoFTPCwd:\n- * @ctx:  an FTP context\n- * @directory:  a directory on the server\n- *\n- * Tries to change the remote directory\n- *\n- * Returns -1 in case of error, 1 if CWD worked, 0 if it failed\n- *\/\n-\n-int\n-xmlNanoFTPCwd(void *ctx, const char *directory) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[400];\n-    int len;\n-    int res;\n-\n-    if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);\n-    if (directory == NULL) return 0;\n-\n-    \/*\n-     * Expected response code for CWD:\n-     *\n-     * CWD\n-     *     250\n-     *     500, 501, 502, 421, 530, 550\n-     *\/\n-    snprintf(buf, sizeof(buf), \"CWD %s\\r\\n\", directory);\n-    buf[sizeof(buf) - 1] = 0;\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n-    }\n-    res = xmlNanoFTPGetResponse(ctxt);\n-    if (res == 4) {\n-    return(-1);\n-    }\n-    if (res == 2) return(1);\n-    if (res == 5) {\n-    return(0);\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlNanoFTPDele:\n- * @ctx:  an FTP context\n- * @file:  a file or directory on the server\n- *\n- * Tries to delete an item (file or directory) from server\n- *\n- * Returns -1 in case of error, 1 if DELE worked, 0 if it failed\n- *\/\n-\n-int\n-xmlNanoFTPDele(void *ctx, const char *file) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[400];\n-    int len;\n-    int res;\n-\n-    if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET) ||\n-        (file == NULL)) return(-1);\n-\n-    \/*\n-     * Expected response code for DELE:\n-     *\n-     * DELE\n-     *       250\n-     *       450, 550\n-     *       500, 501, 502, 421, 530\n-     *\/\n-\n-    snprintf(buf, sizeof(buf), \"DELE %s\\r\\n\", file);\n-    buf[sizeof(buf) - 1] = 0;\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    return(res);\n-    }\n-    res = xmlNanoFTPGetResponse(ctxt);\n-    if (res == 4) {\n-    return(-1);\n-    }\n-    if (res == 2) return(1);\n-    if (res == 5) {\n-    return(0);\n-    }\n-    return(0);\n-}\n-\/**\n- * xmlNanoFTPGetConnection:\n- * @ctx:  an FTP context\n- *\n- * Try to open a data connection to the server. Currently only\n- * passive mode is supported.\n- *\n- * Returns -1 in case of error, 0 otherwise\n- *\/\n-\n-SOCKET\n-xmlNanoFTPGetConnection(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[200], *cur;\n-    int len, i;\n-    int res;\n-    unsigned char ad[6], *adp, *portp;\n-    unsigned int temp[6];\n-#ifdef SUPPORT_IP6\n-    struct sockaddr_storage dataAddr;\n-#else\n-    struct sockaddr_in dataAddr;\n-#endif\n-    XML_SOCKLEN_T dataAddrLen;\n-\n-    if (ctxt == NULL) return INVALID_SOCKET;\n-\n-    memset (&dataAddr, 0, sizeof(dataAddr));\n-#ifdef SUPPORT_IP6\n-    if ((ctxt->ftpAddr).ss_family == AF_INET6) {\n-    ctxt->dataFd = socket (AF_INET6, SOCK_STREAM, IPPROTO_TCP);\n-    ((struct sockaddr_in6 *)&dataAddr)->sin6_family = AF_INET6;\n-    dataAddrLen = sizeof(struct sockaddr_in6);\n-    } else\n-#endif\n-    {\n-    ctxt->dataFd = socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n-    ((struct sockaddr_in *)&dataAddr)->sin_family = AF_INET;\n-    dataAddrLen = sizeof (struct sockaddr_in);\n-    }\n-\n-    if (ctxt->dataFd == INVALID_SOCKET) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"socket failed\");\n-    return INVALID_SOCKET;\n-    }\n-\n-    if (ctxt->passive) {\n-#ifdef SUPPORT_IP6\n-    if ((ctxt->ftpAddr).ss_family == AF_INET6)\n-        snprintf (buf, sizeof(buf), \"EPSV\\r\\n\");\n-    else\n-#endif\n-        snprintf (buf, sizeof(buf), \"PASV\\r\\n\");\n-        len = strlen (buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n-        res = xmlNanoFTPReadResponse(ctx);\n-    if (res != 2) {\n-        if (res == 5) {\n-            closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-        } else {\n-        \/*\n-         * retry with an active connection\n-         *\/\n-            closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-            ctxt->passive = 0;\n-        }\n-    }\n-    cur = &ctxt->controlBuf[ctxt->controlBufAnswer];\n-    while (((*cur < '0') || (*cur > '9')) && *cur != '\\0') cur++;\n-#ifdef SUPPORT_IP6\n-    if ((ctxt->ftpAddr).ss_family == AF_INET6) {\n-        if (sscanf (cur, \"%u\", &temp[0]) != 1) {\n-        __xmlIOErr(XML_FROM_FTP, XML_FTP_EPSV_ANSWER,\n-            \"Invalid answer to EPSV\\n\");\n-        if (ctxt->dataFd != INVALID_SOCKET) {\n-            closesocket (ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        }\n-        return INVALID_SOCKET;\n-        }\n-        memcpy (&((struct sockaddr_in6 *)&dataAddr)->sin6_addr, &((struct sockaddr_in6 *)&ctxt->ftpAddr)->sin6_addr, sizeof(struct in6_addr));\n-        ((struct sockaddr_in6 *)&dataAddr)->sin6_port = htons (temp[0]);\n-    }\n-    else\n-#endif\n-    {\n-        if (sscanf (cur, \"%u,%u,%u,%u,%u,%u\", &temp[0], &temp[1], &temp[2],\n-        &temp[3], &temp[4], &temp[5]) != 6) {\n-        __xmlIOErr(XML_FROM_FTP, XML_FTP_PASV_ANSWER,\n-            \"Invalid answer to PASV\\n\");\n-        if (ctxt->dataFd != INVALID_SOCKET) {\n-            closesocket (ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        }\n-        return INVALID_SOCKET;\n-        }\n-        for (i=0; i<6; i++) ad[i] = (unsigned char) (temp[i] & 0xff);\n-        memcpy (&((struct sockaddr_in *)&dataAddr)->sin_addr, &ad[0], 4);\n-        memcpy (&((struct sockaddr_in *)&dataAddr)->sin_port, &ad[4], 2);\n-    }\n-\n-    if (connect(ctxt->dataFd, (struct sockaddr *) &dataAddr, dataAddrLen) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"Failed to create a data connection\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n-    } else {\n-        getsockname(ctxt->dataFd, (struct sockaddr *) &dataAddr, &dataAddrLen);\n-#ifdef SUPPORT_IP6\n-    if ((ctxt->ftpAddr).ss_family == AF_INET6)\n-        ((struct sockaddr_in6 *)&dataAddr)->sin6_port = 0;\n-    else\n-#endif\n-        ((struct sockaddr_in *)&dataAddr)->sin_port = 0;\n-\n-    if (bind(ctxt->dataFd, (struct sockaddr *) &dataAddr, dataAddrLen) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"bind failed\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n-        getsockname(ctxt->dataFd, (struct sockaddr *) &dataAddr, &dataAddrLen);\n-\n-    if (listen(ctxt->dataFd, 1) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"listen failed\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n-#ifdef SUPPORT_IP6\n-    if ((ctxt->ftpAddr).ss_family == AF_INET6) {\n-        char buf6[INET6_ADDRSTRLEN];\n-        inet_ntop (AF_INET6, &((struct sockaddr_in6 *)&dataAddr)->sin6_addr,\n-            buf6, INET6_ADDRSTRLEN);\n-        adp = (unsigned char *) buf6;\n-        portp = (unsigned char *) &((struct sockaddr_in6 *)&dataAddr)->sin6_port;\n-        snprintf (buf, sizeof(buf), \"EPRT |2|%s|%s|\\r\\n\", adp, portp);\n-        } else\n-#endif\n-    {\n-        adp = (unsigned char *) &((struct sockaddr_in *)&dataAddr)->sin_addr;\n-        portp = (unsigned char *) &((struct sockaddr_in *)&dataAddr)->sin_port;\n-        snprintf (buf, sizeof(buf), \"PORT %d,%d,%d,%d,%d,%d\\r\\n\",\n-        adp[0] & 0xff, adp[1] & 0xff, adp[2] & 0xff, adp[3] & 0xff,\n-        portp[0] & 0xff, portp[1] & 0xff);\n-    }\n-\n-        buf[sizeof(buf) - 1] = 0;\n-        len = strlen(buf);\n-\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-    }\n-        res = xmlNanoFTPGetResponse(ctxt);\n-    if (res != 2) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return INVALID_SOCKET;\n-        }\n-    }\n-    return(ctxt->dataFd);\n-\n-}\n-\n-\/**\n- * xmlNanoFTPCloseConnection:\n- * @ctx:  an FTP context\n- *\n- * Close the data connection from the server\n- *\n- * Returns -1 in case of error, 0 otherwise\n- *\/\n-\n-int\n-xmlNanoFTPCloseConnection(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    int res;\n-    fd_set rfd, efd;\n-    struct timeval tv;\n-\n-    if ((ctxt == NULL) || (ctxt->controlFd == INVALID_SOCKET)) return(-1);\n-\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    tv.tv_sec = 15;\n-    tv.tv_usec = 0;\n-    FD_ZERO(&rfd);\n-    FD_SET(ctxt->controlFd, &rfd);\n-    FD_ZERO(&efd);\n-    FD_SET(ctxt->controlFd, &efd);\n-    res = select(ctxt->controlFd + 1, &rfd, NULL, &efd, &tv);\n-    if (res < 0) {\n-    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-    return(-1);\n-    }\n-    if (res == 0) {\n-    closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-    } else {\n-    res = xmlNanoFTPGetResponse(ctxt);\n-    if (res != 2) {\n-        closesocket(ctxt->controlFd); ctxt->controlFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    }\n-    return(0);\n-}\n-\n-\/**\n- * xmlNanoFTPParseList:\n- * @list:  some data listing received from the server\n- * @callback:  the user callback\n- * @userData:  the user callback data\n- *\n- * Parse at most one entry from the listing.\n- *\n- * Returns -1 in case of error, the length of data parsed otherwise\n- *\/\n-\n-static int\n-xmlNanoFTPParseList(const char *list, ftpListCallback callback, void *userData) {\n-    const char *cur = list;\n-    char filename[151];\n-    char attrib[11];\n-    char owner[11];\n-    char group[11];\n-    char month[4];\n-    int year = 0;\n-    int minute = 0;\n-    int hour = 0;\n-    int day = 0;\n-    unsigned long size = 0;\n-    int links = 0;\n-    int i;\n-\n-    if (!strncmp(cur, \"total\", 5)) {\n-        cur += 5;\n-    while (*cur == ' ') cur++;\n-    while ((*cur >= '0') && (*cur <= '9'))\n-        links = (links * 10) + (*cur++ - '0');\n-    while ((*cur == ' ') || (*cur == '\\n')  || (*cur == '\\r'))\n-        cur++;\n-    return(cur - list);\n-    } else if (*list == '+') {\n-    return(0);\n-    } else {\n-    while ((*cur == ' ') || (*cur == '\\n')  || (*cur == '\\r'))\n-        cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while (*cur != ' ') {\n-        if (i < 10)\n-        attrib[i++] = *cur;\n-        cur++;\n-        if (*cur == 0) return(0);\n-    }\n-    attrib[10] = 0;\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    while ((*cur >= '0') && (*cur <= '9'))\n-        links = (links * 10) + (*cur++ - '0');\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while (*cur != ' ') {\n-        if (i < 10)\n-        owner[i++] = *cur;\n-        cur++;\n-        if (*cur == 0) return(0);\n-    }\n-    owner[i] = 0;\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while (*cur != ' ') {\n-        if (i < 10)\n-        group[i++] = *cur;\n-        cur++;\n-        if (*cur == 0) return(0);\n-    }\n-    group[i] = 0;\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    while ((*cur >= '0') && (*cur <= '9'))\n-        size = (size * 10) + (*cur++ - '0');\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while (*cur != ' ') {\n-        if (i < 3)\n-        month[i++] = *cur;\n-        cur++;\n-        if (*cur == 0) return(0);\n-    }\n-    month[i] = 0;\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-        while ((*cur >= '0') && (*cur <= '9'))\n-        day = (day * 10) + (*cur++ - '0');\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    if ((cur[1] == 0) || (cur[2] == 0)) return(0);\n-    if ((cur[1] == ':') || (cur[2] == ':')) {\n-        while ((*cur >= '0') && (*cur <= '9'))\n-        hour = (hour * 10) + (*cur++ - '0');\n-        if (*cur == ':') cur++;\n-        while ((*cur >= '0') && (*cur <= '9'))\n-        minute = (minute * 10) + (*cur++ - '0');\n-    } else {\n-        while ((*cur >= '0') && (*cur <= '9'))\n-        year = (year * 10) + (*cur++ - '0');\n-    }\n-    while (*cur == ' ') cur++;\n-    if (*cur == 0) return(0);\n-    i = 0;\n-    while ((*cur != '\\n')  && (*cur != '\\r')) {\n-        if (i < 150)\n-        filename[i++] = *cur;\n-        cur++;\n-        if (*cur == 0) return(0);\n-    }\n-    filename[i] = 0;\n-    if ((*cur != '\\n') && (*cur != '\\r'))\n-        return(0);\n-    while ((*cur == '\\n')  || (*cur == '\\r'))\n-        cur++;\n-    }\n-    if (callback != NULL) {\n-        callback(userData, filename, attrib, owner, group, size, links,\n-         year, month, day, hour, minute);\n-    }\n-    return(cur - list);\n-}\n-\n-\/**\n- * xmlNanoFTPList:\n- * @ctx:  an FTP context\n- * @callback:  the user callback\n- * @userData:  the user callback data\n- * @filename:  optional files to list\n- *\n- * Do a listing on the server. All files info are passed back\n- * in the callbacks.\n- *\n- * Returns -1 in case of error, 0 otherwise\n- *\/\n-\n-int\n-xmlNanoFTPList(void *ctx, ftpListCallback callback, void *userData,\n-           const char *filename) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[4096 + 1];\n-    int len, res;\n-    int indx = 0, base;\n-    fd_set rfd, efd;\n-    struct timeval tv;\n-\n-    if (ctxt == NULL) return (-1);\n-    if (filename == NULL) {\n-        if (xmlNanoFTPCwd(ctxt, ctxt->path) < 1)\n-        return(-1);\n-    ctxt->dataFd = xmlNanoFTPGetConnection(ctxt);\n-    if (ctxt->dataFd == INVALID_SOCKET)\n-        return(-1);\n-    snprintf(buf, sizeof(buf), \"LIST -L\\r\\n\");\n-    } else {\n-    if (filename[0] != '\/') {\n-        if (xmlNanoFTPCwd(ctxt, ctxt->path) < 1)\n-        return(-1);\n-    }\n-    ctxt->dataFd = xmlNanoFTPGetConnection(ctxt);\n-    if (ctxt->dataFd == INVALID_SOCKET)\n-        return(-1);\n-    snprintf(buf, sizeof(buf), \"LIST -L %s\\r\\n\", filename);\n-    }\n-    buf[sizeof(buf) - 1] = 0;\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return(res);\n-    }\n-    res = xmlNanoFTPReadResponse(ctxt);\n-    if (res != 1) {\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return(-res);\n-    }\n-\n-    do {\n-    tv.tv_sec = 1;\n-    tv.tv_usec = 0;\n-    FD_ZERO(&rfd);\n-    FD_SET(ctxt->dataFd, &rfd);\n-    FD_ZERO(&efd);\n-    FD_SET(ctxt->dataFd, &efd);\n-    res = select(ctxt->dataFd + 1, &rfd, NULL, &efd, &tv);\n-    if (res < 0) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    if (res == 0) {\n-        res = xmlNanoFTPCheckResponse(ctxt);\n-        if (res < 0) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-        }\n-        if (res == 2) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(0);\n-        }\n-\n-        continue;\n-    }\n-\n-    if ((len = recv(ctxt->dataFd, &buf[indx], sizeof(buf) - (indx + 1), 0)) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"recv\");\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    indx += len;\n-    buf[indx] = 0;\n-    base = 0;\n-    do {\n-        res = xmlNanoFTPParseList(&buf[base], callback, userData);\n-        base += res;\n-    } while (res > 0);\n-\n-    memmove(&buf[0], &buf[base], indx - base);\n-    indx -= base;\n-    } while (len != 0);\n-    xmlNanoFTPCloseConnection(ctxt);\n-    return(0);\n-}\n-\n-\/**\n- * xmlNanoFTPGetSocket:\n- * @ctx:  an FTP context\n- * @filename:  the file to retrieve (or NULL if path is in context).\n- *\n- * Initiate fetch of the given file from the server.\n- *\n- * Returns the socket for the data connection, or <0 in case of error\n- *\/\n-\n-\n-SOCKET\n-xmlNanoFTPGetSocket(void *ctx, const char *filename) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[300];\n-    int res, len;\n-    if (ctx == NULL)\n-    return INVALID_SOCKET;\n-    if ((filename == NULL) && (ctxt->path == NULL))\n-    return INVALID_SOCKET;\n-    ctxt->dataFd = xmlNanoFTPGetConnection(ctxt);\n-    if (ctxt->dataFd == INVALID_SOCKET)\n-    return INVALID_SOCKET;\n-\n-    snprintf(buf, sizeof(buf), \"TYPE I\\r\\n\");\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return INVALID_SOCKET;\n-    }\n-    res = xmlNanoFTPReadResponse(ctxt);\n-    if (res != 2) {\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return INVALID_SOCKET;\n-    }\n-    if (filename == NULL)\n-    snprintf(buf, sizeof(buf), \"RETR %s\\r\\n\", ctxt->path);\n-    else\n-    snprintf(buf, sizeof(buf), \"RETR %s\\r\\n\", filename);\n-    buf[sizeof(buf) - 1] = 0;\n-    len = strlen(buf);\n-    res = send(ctxt->controlFd, SEND_ARG2_CAST buf, len, 0);\n-    if (res < 0) {\n-    __xmlIOErr(XML_FROM_FTP, 0, \"send failed\");\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return INVALID_SOCKET;\n-    }\n-    res = xmlNanoFTPReadResponse(ctxt);\n-    if (res != 1) {\n-    closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-    return INVALID_SOCKET;\n-    }\n-    return(ctxt->dataFd);\n-}\n-\n-\/**\n- * xmlNanoFTPGet:\n- * @ctx:  an FTP context\n- * @callback:  the user callback\n- * @userData:  the user callback data\n- * @filename:  the file to retrieve\n- *\n- * Fetch the given file from the server. All data are passed back\n- * in the callbacks. The last callback has a size of 0 block.\n- *\n- * Returns -1 in case of error, 0 otherwise\n- *\/\n-\n-int\n-xmlNanoFTPGet(void *ctx, ftpDataCallback callback, void *userData,\n-          const char *filename) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-    char buf[4096];\n-    int len = 0, res;\n-    fd_set rfd;\n-    struct timeval tv;\n-\n-    if (ctxt == NULL) return(-1);\n-    if ((filename == NULL) && (ctxt->path == NULL))\n-    return(-1);\n-    if (callback == NULL)\n-    return(-1);\n-    if (xmlNanoFTPGetSocket(ctxt, filename) == INVALID_SOCKET)\n-    return(-1);\n-\n-    do {\n-    tv.tv_sec = 1;\n-    tv.tv_usec = 0;\n-    FD_ZERO(&rfd);\n-    FD_SET(ctxt->dataFd, &rfd);\n-    res = select(ctxt->dataFd + 1, &rfd, NULL, NULL, &tv);\n-    if (res < 0) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    if (res == 0) {\n-        res = xmlNanoFTPCheckResponse(ctxt);\n-        if (res < 0) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-        }\n-        if (res == 2) {\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(0);\n-        }\n-\n-        continue;\n-    }\n-    if ((len = recv(ctxt->dataFd, buf, sizeof(buf), 0)) < 0) {\n-        __xmlIOErr(XML_FROM_FTP, 0, \"recv failed\");\n-        callback(userData, buf, len);\n-        closesocket(ctxt->dataFd); ctxt->dataFd = INVALID_SOCKET;\n-        return(-1);\n-    }\n-    callback(userData, buf, len);\n-    } while (len != 0);\n-\n-    return(xmlNanoFTPCloseConnection(ctxt));\n-}\n-\n-\/**\n- * xmlNanoFTPRead:\n- * @ctx:  the FTP context\n- * @dest:  a buffer\n- * @len:  the buffer length\n- *\n- * This function tries to read @len bytes from the existing FTP connection\n- * and saves them in @dest. This is a blocking call.\n- *\n- * Returns the number of byte read. 0 is an indication of an end of connection.\n- *         -1 indicates a parameter error.\n- *\/\n-int\n-xmlNanoFTPRead(void *ctx, void *dest, int len) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-\n-    if (ctx == NULL) return(-1);\n-    if (ctxt->dataFd == INVALID_SOCKET) return(0);\n-    if (dest == NULL) return(-1);\n-    if (len <= 0) return(0);\n-\n-    len = recv(ctxt->dataFd, dest, len, 0);\n-    if (len <= 0) {\n-    if (len < 0)\n-        __xmlIOErr(XML_FROM_FTP, 0, \"recv failed\");\n-    xmlNanoFTPCloseConnection(ctxt);\n-    }\n-    return(len);\n-}\n-\n-\/**\n- * xmlNanoFTPOpen:\n- * @URL: the URL to the resource\n- *\n- * Start to fetch the given ftp:\/\/ resource\n- *\n- * Returns an FTP context, or NULL\n- *\/\n-\n-void*\n-xmlNanoFTPOpen(const char *URL) {\n-    xmlNanoFTPCtxtPtr ctxt;\n-    SOCKET sock;\n-\n-    xmlNanoFTPInit();\n-    if (URL == NULL) return(NULL);\n-    if (strncmp(\"ftp:\/\/\", URL, 6)) return(NULL);\n-\n-    ctxt = (xmlNanoFTPCtxtPtr) xmlNanoFTPNewCtxt(URL);\n-    if (ctxt == NULL) return(NULL);\n-    if (xmlNanoFTPConnect(ctxt) < 0) {\n-    xmlNanoFTPFreeCtxt(ctxt);\n-    return(NULL);\n-    }\n-    sock = xmlNanoFTPGetSocket(ctxt, ctxt->path);\n-    if (sock == INVALID_SOCKET) {\n-    xmlNanoFTPFreeCtxt(ctxt);\n-    return(NULL);\n-    }\n-    return(ctxt);\n-}\n-\n-\/**\n- * xmlNanoFTPClose:\n- * @ctx: an FTP context\n- *\n- * Close the connection and both control and transport\n- *\n- * Returns -1 in case of error, 0 otherwise\n- *\/\n-\n-int\n-xmlNanoFTPClose(void *ctx) {\n-    xmlNanoFTPCtxtPtr ctxt = (xmlNanoFTPCtxtPtr) ctx;\n-\n-    if (ctxt == NULL)\n-    return(-1);\n-\n-    if (ctxt->dataFd != INVALID_SOCKET) {\n-    closesocket(ctxt->dataFd);\n-    ctxt->dataFd = INVALID_SOCKET;\n-    }\n-    if (ctxt->controlFd != INVALID_SOCKET) {\n-    xmlNanoFTPQuit(ctxt);\n-    closesocket(ctxt->controlFd);\n-    ctxt->controlFd = INVALID_SOCKET;\n-    }\n-    xmlNanoFTPFreeCtxt(ctxt);\n-    return(0);\n-}\n-\n-#ifdef STANDALONE\n-\/************************************************************************\n- *                                    *\n- *            Basic test in Standalone mode            *\n- *                                    *\n- ************************************************************************\/\n-static\n-void ftpList(void *userData, const char *filename, const char* attrib,\n-         const char *owner, const char *group, unsigned long size, int links,\n-         int year, const char *month, int day, int hour, int minute) {\n-    fprintf(stderr,\n-        \"%s %s %s %ld %s\\n\", attrib, owner, group, size, filename);\n-}\n-static\n-void ftpData(void *userData, const char *data, int len) {\n-    if (userData == NULL) return;\n-    if (len <= 0) {\n-    fclose((FILE*)userData);\n-    return;\n-    }\n-    fwrite(data, len, 1, (FILE*)userData);\n-}\n-\n-int main(int argc, char **argv) {\n-    void *ctxt;\n-    FILE *output;\n-    char *tstfile = NULL;\n-\n-    xmlNanoFTPInit();\n-    if (argc > 1) {\n-    ctxt = xmlNanoFTPNewCtxt(argv[1]);\n-    if (xmlNanoFTPConnect(ctxt) < 0) {\n-        fprintf(stderr,\n-            \"Couldn't connect to %s\\n\", argv[1]);\n-        exit(1);\n-    }\n-    if (argc > 2)\n-        tstfile = argv[2];\n-    } else\n-    ctxt = xmlNanoFTPConnectTo(\"localhost\", 0);\n-    if (ctxt == NULL) {\n-        fprintf(stderr,\n-        \"Couldn't connect to localhost\\n\");\n-        exit(1);\n-    }\n-    xmlNanoFTPList(ctxt, ftpList, NULL, tstfile);\n-    output = fopen(\"\/tmp\/tstdata\", \"w\");\n-    if (output != NULL) {\n-    if (xmlNanoFTPGet(ctxt, ftpData, (void *) output, tstfile) < 0)\n-        fprintf(stderr,\n-            \"Failed to get file\\n\");\n-\n-    }\n-    xmlNanoFTPClose(ctxt);\n-    exit(0);\n-}\n-#endif \/* STANDALONE *\/\n-#else \/* !LIBXML_FTP_ENABLED *\/\n-#ifdef STANDALONE\n-#include <stdio.h>\n-int main(int argc, char **argv) {\n-    fprintf(stderr,\n-        \"%s : FTP support not compiled in\\n\", argv[0]);\n-    return(0);\n-}\n-#endif \/* STANDALONE *\/\n-#endif \/* LIBXML_FTP_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/nanoftp.c","additions":0,"deletions":1982,"binary":false,"changes":1982,"status":"deleted"},{"patch":"@@ -23,3 +23,4 @@\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#elif defined (_WIN32)\n+#include <fcntl.h>\n+\n+#ifdef _WIN32\n+\n@@ -27,11 +28,5 @@\n-#endif\n-#ifdef HAVE_SYS_SOCKET_H\n-#include <sys\/socket.h>\n-#endif\n-#ifdef HAVE_NETINET_IN_H\n-#include <netinet\/in.h>\n-#endif\n-#ifdef HAVE_ARPA_INET_H\n-#include <arpa\/inet.h>\n-#endif\n-#ifdef HAVE_NETDB_H\n+#include <wsockcompat.h>\n+#define XML_SOCKLEN_T int\n+\n+#else \/* _WIN32 *\/\n+\n@@ -39,5 +34,2 @@\n-#endif\n-#ifdef HAVE_FCNTL_H\n-#include <fcntl.h>\n-#endif\n-#ifdef HAVE_SYS_TIME_H\n+#include <netinet\/in.h>\n+#include <sys\/socket.h>\n@@ -45,5 +37,4 @@\n-#endif\n-#ifndef HAVE_POLL_H\n-#ifdef HAVE_SYS_SELECT_H\n-#include <sys\/select.h>\n-#endif\n+#include <unistd.h>\n+\n+#ifdef HAVE_POLL_H\n+  #include <poll.h>\n@@ -51,4 +42,1 @@\n-#include <poll.h>\n-#endif\n-#ifdef LIBXML_ZLIB_ENABLED\n-#include <zlib.h>\n+  #include <sys\/select.h>\n@@ -57,0 +45,3 @@\n+\/* This can be disabled if you don't have getaddrinfo *\/\n+#define SUPPORT_IP6\n+#define XML_SOCKLEN_T socklen_t\n@@ -58,4 +49,1 @@\n-#ifdef VMS\n-#include <stropts>\n-#define XML_SOCKLEN_T unsigned int\n-#endif\n+#endif \/* _WIN32 *\/\n@@ -63,2 +51,2 @@\n-#if defined(_WIN32)\n-#include <wsockcompat.h>\n+#ifdef LIBXML_ZLIB_ENABLED\n+#include <zlib.h>\n@@ -85,4 +73,0 @@\n-#ifndef XML_SOCKLEN_T\n-#define XML_SOCKLEN_T unsigned int\n-#endif\n-\n@@ -92,6 +76,1 @@\n-#ifdef STANDALONE\n-#define xmlStrncasecmp(a, b, n) strncasecmp((char *)a, (char *)b, n)\n-#define xmlStrcasecmpi(a, b) strcasecmp((char *)a, (char *)b)\n-#endif\n-\n-#define XML_NANO_HTTP_MAX_REDIR    10\n+#define XML_NANO_HTTP_MAX_REDIR 10\n@@ -99,1 +78,1 @@\n-#define XML_NANO_HTTP_CHUNK    4096\n+#define XML_NANO_HTTP_CHUNK     4096\n@@ -102,3 +81,5 @@\n-#define XML_NANO_HTTP_WRITE    1\n-#define XML_NANO_HTTP_READ    2\n-#define XML_NANO_HTTP_NONE    4\n+#define XML_NANO_HTTP_WRITE     1\n+#define XML_NANO_HTTP_READ      2\n+#define XML_NANO_HTTP_NONE      4\n+\n+#define __xmlIOErr(domain, code, extra) ((void) 0)\n@@ -107,15 +88,15 @@\n-    char *protocol;    \/* the protocol name *\/\n-    char *hostname;    \/* the host name *\/\n-    int port;        \/* the port *\/\n-    char *path;        \/* the path within the URL *\/\n-    char *query;    \/* the query string *\/\n-    SOCKET fd;        \/* the file descriptor for the socket *\/\n-    int state;        \/* WRITE \/ READ \/ CLOSED *\/\n-    char *out;        \/* buffer sent (zero terminated) *\/\n-    char *outptr;    \/* index within the buffer sent *\/\n-    char *in;        \/* the receiving buffer *\/\n-    char *content;    \/* the start of the content *\/\n-    char *inptr;    \/* the next byte to read from network *\/\n-    char *inrptr;    \/* the next byte to give back to the client *\/\n-    int inlen;        \/* len of the input buffer *\/\n-    int last;        \/* return code for last operation *\/\n+    char *protocol;     \/* the protocol name *\/\n+    char *hostname;     \/* the host name *\/\n+    int port;           \/* the port *\/\n+    char *path;         \/* the path within the URL *\/\n+    char *query;        \/* the query string *\/\n+    SOCKET fd;          \/* the file descriptor for the socket *\/\n+    int state;          \/* WRITE \/ READ \/ CLOSED *\/\n+    char *out;          \/* buffer sent (zero terminated) *\/\n+    char *outptr;       \/* index within the buffer sent *\/\n+    char *in;           \/* the receiving buffer *\/\n+    char *content;      \/* the start of the content *\/\n+    char *inptr;        \/* the next byte to read from network *\/\n+    char *inrptr;       \/* the next byte to give back to the client *\/\n+    int inlen;          \/* len of the input buffer *\/\n+    int last;           \/* return code for last operation *\/\n@@ -125,5 +106,5 @@\n-    char *contentType;    \/* the MIME type for the input *\/\n-    char *location;    \/* the new URL in case of redirect *\/\n-    char *authHeader;    \/* contents of {WWW,Proxy}-Authenticate header *\/\n-    char *encoding;    \/* encoding extracted from the contentType *\/\n-    char *mimeType;    \/* Mime-Type extracted from the contentType *\/\n+    char *contentType;  \/* the MIME type for the input *\/\n+    char *location;     \/* the new URL in case of redirect *\/\n+    char *authHeader;   \/* contents of {WWW,Proxy}-Authenticate header *\/\n+    char *encoding;     \/* encoding extracted from the contentType *\/\n+    char *mimeType;     \/* Mime-Type extracted from the contentType *\/\n@@ -131,2 +112,2 @@\n-    z_stream *strm;    \/* Zlib stream object *\/\n-    int usesGzip;    \/* \"Content-Encoding: gzip\" was detected *\/\n+    z_stream *strm;     \/* Zlib stream object *\/\n+    int usesGzip;       \/* \"Content-Encoding: gzip\" was detected *\/\n@@ -137,2 +118,2 @@\n-static char *proxy = NULL;     \/* the proxy name if any *\/\n-static int proxyPort;    \/* the proxy port if any *\/\n+static char *proxy = NULL;       \/* the proxy name if any *\/\n+static int proxyPort;   \/* the proxy port if any *\/\n@@ -195,1 +176,1 @@\n-    return;\n+        return;\n@@ -199,1 +180,1 @@\n-    return;\n+        return;\n@@ -203,14 +184,14 @@\n-    proxyPort = 80;\n-    env = getenv(\"no_proxy\");\n-    if (env && ((env[0] == '*') && (env[1] == 0)))\n-        goto done;\n-    env = getenv(\"http_proxy\");\n-    if (env != NULL) {\n-        xmlNanoHTTPScanProxy(env);\n-        goto done;\n-    }\n-    env = getenv(\"HTTP_PROXY\");\n-    if (env != NULL) {\n-        xmlNanoHTTPScanProxy(env);\n-        goto done;\n-    }\n+        proxyPort = 80;\n+        env = getenv(\"no_proxy\");\n+        if (env && ((env[0] == '*') && (env[1] == 0)))\n+            goto done;\n+        env = getenv(\"http_proxy\");\n+        if (env != NULL) {\n+            xmlNanoHTTPScanProxy(env);\n+            goto done;\n+        }\n+        env = getenv(\"HTTP_PROXY\");\n+        if (env != NULL) {\n+            xmlNanoHTTPScanProxy(env);\n+            goto done;\n+        }\n@@ -231,2 +212,2 @@\n-    xmlFree(proxy);\n-    proxy = NULL;\n+        xmlFree(proxy);\n+        proxy = NULL;\n@@ -236,1 +217,1 @@\n-    WSACleanup();\n+        WSACleanup();\n@@ -261,1 +242,1 @@\n-    ctxt->protocol = NULL;\n+        ctxt->protocol = NULL;\n@@ -265,1 +246,1 @@\n-    ctxt->hostname = NULL;\n+        ctxt->hostname = NULL;\n@@ -269,1 +250,1 @@\n-    ctxt->path = NULL;\n+        ctxt->path = NULL;\n@@ -273,1 +254,1 @@\n-    ctxt->query = NULL;\n+        ctxt->query = NULL;\n@@ -279,1 +260,1 @@\n-    return;\n+        return;\n@@ -282,2 +263,2 @@\n-    xmlFreeURI(uri);\n-    return;\n+        xmlFreeURI(uri);\n+        return;\n@@ -290,2 +271,4 @@\n-    if ((len > 2) && (uri->server[len - 1] == ']')) {\n-        ctxt->hostname = (char *) xmlCharStrndup(uri->server + 1, len -2);\n+        if ((len > 2) && (uri->server[len - 1] == ']')) {\n+            ctxt->hostname = (char *) xmlCharStrndup(uri->server + 1, len -2);\n+        } else\n+            ctxt->hostname = xmlMemStrdup(uri->server);\n@@ -294,2 +277,0 @@\n-    } else\n-    ctxt->hostname = xmlMemStrdup(uri->server);\n@@ -297,1 +278,1 @@\n-    ctxt->path = xmlMemStrdup(uri->path);\n+        ctxt->path = xmlMemStrdup(uri->path);\n@@ -299,1 +280,1 @@\n-    ctxt->path = xmlMemStrdup(\"\/\");\n+        ctxt->path = xmlMemStrdup(\"\/\");\n@@ -301,1 +282,1 @@\n-    ctxt->query = xmlMemStrdup(uri->query);\n+        ctxt->query = xmlMemStrdup(uri->query);\n@@ -303,1 +284,1 @@\n-    ctxt->port = uri->port;\n+        ctxt->port = uri->port;\n@@ -324,1 +305,1 @@\n-    proxy = NULL;\n+        proxy = NULL;\n@@ -332,5 +313,5 @@\n-    (strcmp(uri->scheme, \"http\")) || (uri->server == NULL)) {\n-    __xmlIOErr(XML_FROM_HTTP, XML_HTTP_URL_SYNTAX, \"Syntax Error\\n\");\n-    if (uri != NULL)\n-        xmlFreeURI(uri);\n-    return;\n+        (strcmp(uri->scheme, \"http\")) || (uri->server == NULL)) {\n+        __xmlIOErr(XML_FROM_HTTP, XML_HTTP_URL_SYNTAX, \"Syntax Error\\n\");\n+        if (uri != NULL)\n+            xmlFreeURI(uri);\n+        return;\n@@ -341,1 +322,1 @@\n-    proxyPort = uri->port;\n+        proxyPort = uri->port;\n@@ -399,2 +380,2 @@\n-    inflateEnd(ctxt->strm);\n-    xmlFree(ctxt->strm);\n+        inflateEnd(ctxt->strm);\n+        xmlFree(ctxt->strm);\n@@ -505,1 +486,1 @@\n-            ctxt->in = (char *) xmlMallocAtomic(65000);\n+            ctxt->in = xmlMalloc(65000);\n@@ -623,1 +604,1 @@\n-    int    rc;\n+    int rc;\n@@ -626,7 +607,11 @@\n-    if (ctxt->inrptr == ctxt->inptr) {\n-        if ( (rc = xmlNanoHTTPRecv(ctxt)) == 0) {\n-        if (bp == buf)\n-            return(NULL);\n-        else\n-            *bp = 0;\n-        return(xmlMemStrdup(buf));\n+        if (ctxt->inrptr == ctxt->inptr) {\n+            if ( (rc = xmlNanoHTTPRecv(ctxt)) == 0) {\n+                if (bp == buf)\n+                    return(NULL);\n+                else\n+                    *bp = 0;\n+                return(xmlMemStrdup(buf));\n+            }\n+            else if ( rc == -1 ) {\n+                return ( NULL );\n+            }\n@@ -634,2 +619,4 @@\n-        else if ( rc == -1 ) {\n-            return ( NULL );\n+        *bp = *ctxt->inrptr++;\n+        if (*bp == '\\n') {\n+            *bp = 0;\n+            return(xmlMemStrdup(buf));\n@@ -637,8 +624,2 @@\n-    }\n-    *bp = *ctxt->inrptr++;\n-    if (*bp == '\\n') {\n-        *bp = 0;\n-        return(xmlMemStrdup(buf));\n-    }\n-    if (*bp != '\\r')\n-        bp++;\n+        if (*bp != '\\r')\n+            bp++;\n@@ -673,1 +654,1 @@\n-    int ret = 0;\n+        int ret = 0;\n@@ -675,12 +656,5 @@\n-    cur += 5;\n-    while ((*cur >= '0') && (*cur <= '9')) {\n-        version *= 10;\n-        version += *cur - '0';\n-        cur++;\n-    }\n-    if (*cur == '.') {\n-        cur++;\n-        if ((*cur >= '0') && (*cur <= '9')) {\n-        version *= 10;\n-        version += *cur - '0';\n-        cur++;\n+        cur += 5;\n+        while ((*cur >= '0') && (*cur <= '9')) {\n+            version *= 10;\n+            version += *cur - '0';\n+            cur++;\n@@ -688,14 +662,21 @@\n-        while ((*cur >= '0') && (*cur <= '9'))\n-        cur++;\n-    } else\n-        version *= 10;\n-    if ((*cur != ' ') && (*cur != '\\t')) return;\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    if ((*cur < '0') || (*cur > '9')) return;\n-    while ((*cur >= '0') && (*cur <= '9')) {\n-        ret *= 10;\n-        ret += *cur - '0';\n-        cur++;\n-    }\n-    if ((*cur != 0) && (*cur != ' ') && (*cur != '\\t')) return;\n-    ctxt->returnValue = ret;\n+        if (*cur == '.') {\n+            cur++;\n+            if ((*cur >= '0') && (*cur <= '9')) {\n+                version *= 10;\n+                version += *cur - '0';\n+                cur++;\n+            }\n+            while ((*cur >= '0') && (*cur <= '9'))\n+                cur++;\n+        } else\n+            version *= 10;\n+        if ((*cur != ' ') && (*cur != '\\t')) return;\n+        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n+        if ((*cur < '0') || (*cur > '9')) return;\n+        while ((*cur >= '0') && (*cur <= '9')) {\n+            ret *= 10;\n+            ret += *cur - '0';\n+            cur++;\n+        }\n+        if ((*cur != 0) && (*cur != ' ') && (*cur != '\\t')) return;\n+        ctxt->returnValue = ret;\n@@ -706,16 +687,6 @@\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    if (ctxt->contentType != NULL)\n-        xmlFree(ctxt->contentType);\n-    ctxt->contentType = xmlMemStrdup(cur);\n-    mime = (const xmlChar *) cur;\n-    last = mime;\n-    while ((*last != 0) && (*last != ' ') && (*last != '\\t') &&\n-           (*last != ';') && (*last != ','))\n-        last++;\n-    if (ctxt->mimeType != NULL)\n-        xmlFree(ctxt->mimeType);\n-    ctxt->mimeType = (char *) xmlStrndup(mime, last - mime);\n-    charset = xmlStrstr(BAD_CAST ctxt->contentType, BAD_CAST \"charset=\");\n-    if (charset != NULL) {\n-        charset += 8;\n-        last = charset;\n+        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n+        if (ctxt->contentType != NULL)\n+            xmlFree(ctxt->contentType);\n+        ctxt->contentType = xmlMemStrdup(cur);\n+        mime = (const xmlChar *) cur;\n+        last = mime;\n@@ -724,5 +695,15 @@\n-        last++;\n-        if (ctxt->encoding != NULL)\n-            xmlFree(ctxt->encoding);\n-        ctxt->encoding = (char *) xmlStrndup(charset, last - charset);\n-    }\n+            last++;\n+        if (ctxt->mimeType != NULL)\n+            xmlFree(ctxt->mimeType);\n+        ctxt->mimeType = (char *) xmlStrndup(mime, last - mime);\n+        charset = xmlStrstr(BAD_CAST ctxt->contentType, BAD_CAST \"charset=\");\n+        if (charset != NULL) {\n+            charset += 8;\n+            last = charset;\n+            while ((*last != 0) && (*last != ' ') && (*last != '\\t') &&\n+                   (*last != ';') && (*last != ','))\n+                last++;\n+            if (ctxt->encoding != NULL)\n+                xmlFree(ctxt->encoding);\n+            ctxt->encoding = (char *) xmlStrndup(charset, last - charset);\n+        }\n@@ -732,15 +713,5 @@\n-    if (ctxt->contentType != NULL) return;\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    ctxt->contentType = xmlMemStrdup(cur);\n-    mime = (const xmlChar *) cur;\n-    last = mime;\n-    while ((*last != 0) && (*last != ' ') && (*last != '\\t') &&\n-           (*last != ';') && (*last != ','))\n-        last++;\n-    if (ctxt->mimeType != NULL)\n-        xmlFree(ctxt->mimeType);\n-    ctxt->mimeType = (char *) xmlStrndup(mime, last - mime);\n-    charset = xmlStrstr(BAD_CAST ctxt->contentType, BAD_CAST \"charset=\");\n-    if (charset != NULL) {\n-        charset += 8;\n-        last = charset;\n+        if (ctxt->contentType != NULL) return;\n+        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n+        ctxt->contentType = xmlMemStrdup(cur);\n+        mime = (const xmlChar *) cur;\n+        last = mime;\n@@ -749,5 +720,15 @@\n-        last++;\n-        if (ctxt->encoding != NULL)\n-            xmlFree(ctxt->encoding);\n-        ctxt->encoding = (char *) xmlStrndup(charset, last - charset);\n-    }\n+            last++;\n+        if (ctxt->mimeType != NULL)\n+            xmlFree(ctxt->mimeType);\n+        ctxt->mimeType = (char *) xmlStrndup(mime, last - mime);\n+        charset = xmlStrstr(BAD_CAST ctxt->contentType, BAD_CAST \"charset=\");\n+        if (charset != NULL) {\n+            charset += 8;\n+            last = charset;\n+            while ((*last != 0) && (*last != ' ') && (*last != '\\t') &&\n+                   (*last != ';') && (*last != ','))\n+                last++;\n+            if (ctxt->encoding != NULL)\n+                xmlFree(ctxt->encoding);\n+            ctxt->encoding = (char *) xmlStrndup(charset, last - charset);\n+        }\n@@ -756,12 +737,12 @@\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    if (ctxt->location != NULL)\n-        xmlFree(ctxt->location);\n-    if (*cur == '\/') {\n-        xmlChar *tmp_http = xmlStrdup(BAD_CAST \"http:\/\/\");\n-        xmlChar *tmp_loc =\n-            xmlStrcat(tmp_http, (const xmlChar *) ctxt->hostname);\n-        ctxt->location =\n-            (char *) xmlStrcat (tmp_loc, (const xmlChar *) cur);\n-    } else {\n-        ctxt->location = xmlMemStrdup(cur);\n-    }\n+        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n+        if (ctxt->location != NULL)\n+            xmlFree(ctxt->location);\n+        if (*cur == '\/') {\n+            xmlChar *tmp_http = xmlStrdup(BAD_CAST \"http:\/\/\");\n+            xmlChar *tmp_loc =\n+                xmlStrcat(tmp_http, (const xmlChar *) ctxt->hostname);\n+            ctxt->location =\n+                (char *) xmlStrcat (tmp_loc, (const xmlChar *) cur);\n+        } else {\n+            ctxt->location = xmlMemStrdup(cur);\n+        }\n@@ -770,4 +751,4 @@\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    if (ctxt->authHeader != NULL)\n-        xmlFree(ctxt->authHeader);\n-    ctxt->authHeader = xmlMemStrdup(cur);\n+        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n+        if (ctxt->authHeader != NULL)\n+            xmlFree(ctxt->authHeader);\n+        ctxt->authHeader = xmlMemStrdup(cur);\n@@ -776,4 +757,4 @@\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    if (ctxt->authHeader != NULL)\n-        xmlFree(ctxt->authHeader);\n-    ctxt->authHeader = xmlMemStrdup(cur);\n+        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n+        if (ctxt->authHeader != NULL)\n+            xmlFree(ctxt->authHeader);\n+        ctxt->authHeader = xmlMemStrdup(cur);\n@@ -782,4 +763,4 @@\n-    cur += 17;\n-    while ((*cur == ' ') || (*cur == '\\t')) cur++;\n-    if ( !xmlStrncasecmp( BAD_CAST cur, BAD_CAST\"gzip\", 4) ) {\n-        ctxt->usesGzip = 1;\n+        cur += 17;\n+        while ((*cur == ' ') || (*cur == '\\t')) cur++;\n+        if ( !xmlStrncasecmp( BAD_CAST cur, BAD_CAST\"gzip\", 4) ) {\n+            ctxt->usesGzip = 1;\n@@ -787,1 +768,1 @@\n-        ctxt->strm = xmlMalloc(sizeof(z_stream));\n+            ctxt->strm = xmlMalloc(sizeof(z_stream));\n@@ -789,6 +770,6 @@\n-        if (ctxt->strm != NULL) {\n-        ctxt->strm->zalloc = Z_NULL;\n-        ctxt->strm->zfree = Z_NULL;\n-        ctxt->strm->opaque = Z_NULL;\n-        ctxt->strm->avail_in = 0;\n-        ctxt->strm->next_in = Z_NULL;\n+            if (ctxt->strm != NULL) {\n+                ctxt->strm->zalloc = Z_NULL;\n+                ctxt->strm->zfree = Z_NULL;\n+                ctxt->strm->opaque = Z_NULL;\n+                ctxt->strm->avail_in = 0;\n+                ctxt->strm->next_in = Z_NULL;\n@@ -796,1 +777,2 @@\n-        inflateInit2( ctxt->strm, 31 );\n+                inflateInit2( ctxt->strm, 31 );\n+            }\n@@ -798,1 +780,0 @@\n-    }\n@@ -801,2 +782,2 @@\n-    cur += 15;\n-    ctxt->ContentLength = strtol( cur, NULL, 10 );\n+        cur += 15;\n+        ctxt->ContentLength = strtol( cur, NULL, 10 );\n@@ -1004,2 +985,2 @@\n-    int status;\n-    struct addrinfo hints, *res, *result;\n+        int status;\n+        struct addrinfo hints, *res, *result;\n@@ -1009,9 +990,3 @@\n-    result = NULL;\n-    memset (&hints, 0,sizeof(hints));\n-    hints.ai_socktype = SOCK_STREAM;\n-\n-    status = getaddrinfo (host, NULL, &hints, &result);\n-    if (status) {\n-        __xmlIOErr(XML_FROM_HTTP, 0, \"getaddrinfo failed\\n\");\n-        return INVALID_SOCKET;\n-    }\n+        result = NULL;\n+        memset (&hints, 0,sizeof(hints));\n+        hints.ai_socktype = SOCK_STREAM;\n@@ -1019,14 +994,3 @@\n-    for (res = result; res; res = res->ai_next) {\n-        if (res->ai_family == AF_INET) {\n-        if ((size_t)res->ai_addrlen > sizeof(sockin)) {\n-            __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n-            freeaddrinfo (result);\n-            return INVALID_SOCKET;\n-        }\n-        memcpy (&sockin, res->ai_addr, res->ai_addrlen);\n-        sockin.sin_port = htons (port);\n-        addr = (struct sockaddr *)&sockin;\n-        } else if (res->ai_family == AF_INET6) {\n-        if ((size_t)res->ai_addrlen > sizeof(sockin6)) {\n-            __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n-            freeaddrinfo (result);\n+        status = getaddrinfo (host, NULL, &hints, &result);\n+        if (status) {\n+            __xmlIOErr(XML_FROM_HTTP, 0, \"getaddrinfo failed\\n\");\n@@ -1035,5 +999,0 @@\n-        memcpy (&sockin6, res->ai_addr, res->ai_addrlen);\n-        sockin6.sin6_port = htons (port);\n-        addr = (struct sockaddr *)&sockin6;\n-        } else\n-        continue;              \/* for *\/\n@@ -1041,4 +1000,27 @@\n-        s = xmlNanoHTTPConnectAttempt (addr);\n-        if (s != INVALID_SOCKET) {\n-        freeaddrinfo (result);\n-        return (s);\n+        for (res = result; res; res = res->ai_next) {\n+            if (res->ai_family == AF_INET) {\n+                if ((size_t)res->ai_addrlen > sizeof(sockin)) {\n+                    __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n+                    freeaddrinfo (result);\n+                    return INVALID_SOCKET;\n+                }\n+                memcpy (&sockin, res->ai_addr, res->ai_addrlen);\n+                sockin.sin_port = htons (port);\n+                addr = (struct sockaddr *)&sockin;\n+            } else if (res->ai_family == AF_INET6) {\n+                if ((size_t)res->ai_addrlen > sizeof(sockin6)) {\n+                    __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n+                    freeaddrinfo (result);\n+                    return INVALID_SOCKET;\n+                }\n+                memcpy (&sockin6, res->ai_addr, res->ai_addrlen);\n+                sockin6.sin6_port = htons (port);\n+                addr = (struct sockaddr *)&sockin6;\n+            } else\n+                continue;              \/* for *\/\n+\n+            s = xmlNanoHTTPConnectAttempt (addr);\n+            if (s != INVALID_SOCKET) {\n+                freeaddrinfo (result);\n+                return (s);\n+            }\n@@ -1046,1 +1028,0 @@\n-    }\n@@ -1048,2 +1029,2 @@\n-    if (result)\n-        freeaddrinfo (result);\n+        if (result)\n+            freeaddrinfo (result);\n@@ -1057,2 +1038,2 @@\n-    h = gethostbyname (GETHOSTBYNAME_ARG_CAST host);\n-    if (h == NULL) {\n+        h = gethostbyname (GETHOSTBYNAME_ARG_CAST host);\n+        if (h == NULL) {\n@@ -1065,2 +1046,2 @@\n-#if defined(HAVE_NETDB_H) && defined(HOST_NOT_FOUND) && defined(__linux__)\n-        const char *h_err_txt = \"\";\n+#if defined(HOST_NOT_FOUND) && defined(__linux__)\n+            const char *h_err_txt = \"\";\n@@ -1068,4 +1049,4 @@\n-        switch (h_errno) {\n-        case HOST_NOT_FOUND:\n-            h_err_txt = \"Authoritative host not found\";\n-            break;\n+            switch (h_errno) {\n+                case HOST_NOT_FOUND:\n+                    h_err_txt = \"Authoritative host not found\";\n+                    break;\n@@ -1073,4 +1054,4 @@\n-        case TRY_AGAIN:\n-            h_err_txt =\n-            \"Non-authoritative host not found or server failure.\";\n-            break;\n+                case TRY_AGAIN:\n+                    h_err_txt =\n+                        \"Non-authoritative host not found or server failure.\";\n+                    break;\n@@ -1078,4 +1059,4 @@\n-        case NO_RECOVERY:\n-            h_err_txt =\n-            \"Non-recoverable errors:  FORMERR, REFUSED, or NOTIMP.\";\n-            break;\n+                case NO_RECOVERY:\n+                    h_err_txt =\n+                        \"Non-recoverable errors:  FORMERR, REFUSED, or NOTIMP.\";\n+                    break;\n@@ -1084,4 +1065,4 @@\n-        case NO_ADDRESS:\n-            h_err_txt =\n-            \"Valid name, no data record of requested type.\";\n-            break;\n+                case NO_ADDRESS:\n+                    h_err_txt =\n+                        \"Valid name, no data record of requested type.\";\n+                    break;\n@@ -1090,5 +1071,5 @@\n-        default:\n-            h_err_txt = \"No error text defined.\";\n-            break;\n-        }\n-        __xmlIOErr(XML_FROM_HTTP, 0, h_err_txt);\n+                default:\n+                    h_err_txt = \"No error text defined.\";\n+                    break;\n+            }\n+            __xmlIOErr(XML_FROM_HTTP, 0, h_err_txt);\n@@ -1096,1 +1077,1 @@\n-        __xmlIOErr(XML_FROM_HTTP, 0, \"Failed to resolve host\");\n+            __xmlIOErr(XML_FROM_HTTP, 0, \"Failed to resolve host\");\n@@ -1098,8 +1079,0 @@\n-        return INVALID_SOCKET;\n-    }\n-\n-    for (i = 0; h->h_addr_list[i]; i++) {\n-        if (h->h_addrtype == AF_INET) {\n-        \/* A records (IPv4) *\/\n-        if ((unsigned int) h->h_length > sizeof(ia)) {\n-            __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n@@ -1108,7 +1081,0 @@\n-        memcpy (&ia, h->h_addr_list[i], h->h_length);\n-        sockin.sin_family = h->h_addrtype;\n-        sockin.sin_addr = ia;\n-        sockin.sin_port = (unsigned short)htons ((unsigned short)port);\n-        addr = (struct sockaddr *) &sockin;\n-        } else\n-        break;              \/* for *\/\n@@ -1116,4 +1082,19 @@\n-        s = xmlNanoHTTPConnectAttempt (addr);\n-        if (s != INVALID_SOCKET)\n-        return (s);\n-    }\n+        for (i = 0; h->h_addr_list[i]; i++) {\n+            if (h->h_addrtype == AF_INET) {\n+                \/* A records (IPv4) *\/\n+                if ((unsigned int) h->h_length > sizeof(ia)) {\n+                    __xmlIOErr(XML_FROM_HTTP, 0, \"address size mismatch\\n\");\n+                    return INVALID_SOCKET;\n+                }\n+                memcpy (&ia, h->h_addr_list[i], h->h_length);\n+                sockin.sin_family = h->h_addrtype;\n+                sockin.sin_addr = ia;\n+                sockin.sin_port = (unsigned short)htons ((unsigned short)port);\n+                addr = (struct sockaddr *) &sockin;\n+            } else\n+                break;              \/* for *\/\n+\n+            s = xmlNanoHTTPConnectAttempt (addr);\n+            if (s != INVALID_SOCKET)\n+                return (s);\n+        }\n@@ -1198,1 +1179,1 @@\n-    ctxt->strm->avail_in = ctxt->inptr - ctxt->inrptr;\n+        ctxt->strm->avail_in = ctxt->inptr - ctxt->inrptr;\n@@ -1201,1 +1182,1 @@\n-           (ctxt->strm->avail_in > 0 || xmlNanoHTTPRecv(ctxt) > 0)) {\n+               (ctxt->strm->avail_in > 0 || xmlNanoHTTPRecv(ctxt) > 0)) {\n@@ -1203,1 +1184,1 @@\n-                ctxt->inptr - ctxt->inrptr - bytes_read;\n+                            ctxt->inptr - ctxt->inrptr - bytes_read;\n@@ -1210,1 +1191,1 @@\n-    }\n+        }\n@@ -1264,1 +1245,1 @@\n-    return 0;\n+        return 0;\n@@ -1279,2 +1260,3 @@\n-    if (tolower(pattern_start[idx_pattern]) != tolower(hostname[idx_hostname]))\n-        break;\n+        if (tolower((unsigned char)pattern_start[idx_pattern]) !=\n+            tolower((unsigned char)hostname[idx_hostname]))\n+            break;\n@@ -1302,1 +1284,1 @@\n-    return 0;\n+        return 0;\n@@ -1311,1 +1293,1 @@\n-    while (isspace(*env))\n+    while (isspace((unsigned char)*env))\n@@ -1315,1 +1297,1 @@\n-    return 0;\n+        return 0;\n@@ -1322,3 +1304,3 @@\n-        ++env;\n-        continue;\n-    }\n+            ++env;\n+            continue;\n+        }\n@@ -1326,5 +1308,5 @@\n-    *(env++) = '\\0';\n-    if (xmlNanoHTTPHostnameMatch(p, hostname)) {\n-        xmlFree(cpy);\n-        return 1;\n-    }\n+        *(env++) = '\\0';\n+        if (xmlNanoHTTPHostnameMatch(p, hostname)) {\n+            xmlFree(cpy);\n+            return 1;\n+        }\n@@ -1332,3 +1314,3 @@\n-    while (isspace(*env))\n-        ++env;\n-    p = env;\n+        while (isspace((unsigned char)*env))\n+            ++env;\n+        p = env;\n@@ -1367,1 +1349,1 @@\n-          const char *headers, int ilen ) {\n+                  const char *headers, int ilen ) {\n@@ -1382,3 +1364,3 @@\n-    ctxt = xmlNanoHTTPNewCtxt(URL);\n-    if (ctxt == NULL)\n-        return(NULL);\n+        ctxt = xmlNanoHTTPNewCtxt(URL);\n+        if (ctxt == NULL)\n+            return(NULL);\n@@ -1386,4 +1368,4 @@\n-    ctxt = xmlNanoHTTPNewCtxt(redirURL);\n-    if (ctxt == NULL)\n-        return(NULL);\n-    ctxt->location = xmlMemStrdup(redirURL);\n+        ctxt = xmlNanoHTTPNewCtxt(redirURL);\n+        if (ctxt == NULL)\n+            return(NULL);\n+        ctxt->location = xmlMemStrdup(redirURL);\n@@ -1393,1 +1375,1 @@\n-    __xmlIOErr(XML_FROM_IO, XML_IO_UNSUPPORTED_PROTOCOL, ctxt->protocol);\n+        __xmlIOErr(XML_FROM_IO, XML_IO_UNSUPPORTED_PROTOCOL, ctxt->protocol);\n@@ -1395,1 +1377,1 @@\n-    if (redirURL != NULL) xmlFree(redirURL);\n+        if (redirURL != NULL) xmlFree(redirURL);\n@@ -1399,2 +1381,2 @@\n-    __xmlIOErr(XML_FROM_HTTP, XML_HTTP_UNKNOWN_HOST,\n-               \"Failed to identify host in URI\");\n+        __xmlIOErr(XML_FROM_HTTP, XML_HTTP_UNKNOWN_HOST,\n+                   \"Failed to identify host in URI\");\n@@ -1402,1 +1384,1 @@\n-    if (redirURL != NULL) xmlFree(redirURL);\n+        if (redirURL != NULL) xmlFree(redirURL);\n@@ -1407,2 +1389,2 @@\n-    blen = strlen(ctxt->hostname) * 2 + 16;\n-    ret = xmlNanoHTTPConnectHost(proxy, proxyPort);\n+        blen = strlen(ctxt->hostname) * 2 + 16;\n+        ret = xmlNanoHTTPConnectHost(proxy, proxyPort);\n@@ -1411,2 +1393,2 @@\n-    blen = strlen(ctxt->hostname);\n-    ret = xmlNanoHTTPConnectHost(ctxt->hostname, ctxt->port);\n+        blen = strlen(ctxt->hostname);\n+        ret = xmlNanoHTTPConnectHost(ctxt->hostname, ctxt->port);\n@@ -1416,1 +1398,1 @@\n-    if (redirURL != NULL) xmlFree(redirURL);\n+        if (redirURL != NULL) xmlFree(redirURL);\n@@ -1422,1 +1404,1 @@\n-    ilen = 0;\n+        ilen = 0;\n@@ -1424,1 +1406,1 @@\n-    blen += 36;\n+        blen += 36;\n@@ -1427,1 +1409,1 @@\n-    blen += strlen(headers) + 2;\n+        blen += strlen(headers) + 2;\n@@ -1429,2 +1411,2 @@\n-    \/* reserve for string plus 'Content-Type: \\r\\n\" *\/\n-    blen += strlen(*contentType) + 16;\n+        \/* reserve for string plus 'Content-Type: \\r\\n\" *\/\n+        blen += strlen(*contentType) + 16;\n@@ -1432,2 +1414,2 @@\n-    \/* 1 for '?' *\/\n-    blen += strlen(ctxt->query) + 1;\n+        \/* 1 for '?' *\/\n+        blen += strlen(ctxt->query) + 1;\n@@ -1440,5 +1422,5 @@\n-    \/* reserve space for ':xxxxx', incl. potential proxy *\/\n-    if (use_proxy)\n-        blen += 17;\n-    else\n-        blen += 11;\n+        \/* reserve space for ':xxxxx', incl. potential proxy *\/\n+        if (use_proxy)\n+            blen += 17;\n+        else\n+            blen += 11;\n@@ -1446,1 +1428,1 @@\n-    bp = (char*)xmlMallocAtomic(blen);\n+    bp = xmlMalloc(blen);\n@@ -1449,2 +1431,2 @@\n-    xmlHTTPErrMemory();\n-    return ( NULL );\n+        xmlHTTPErrMemory();\n+        return ( NULL );\n@@ -1456,8 +1438,8 @@\n-    if (ctxt->port != 80) {\n-        p += snprintf( p, blen - (p - bp), \"%s http:\/\/%s:%d%s\",\n-            method, ctxt->hostname,\n-            ctxt->port, ctxt->path );\n-    }\n-    else\n-        p += snprintf( p, blen - (p - bp), \"%s http:\/\/%s%s\", method,\n-            ctxt->hostname, ctxt->path);\n+        if (ctxt->port != 80) {\n+            p += snprintf( p, blen - (p - bp), \"%s http:\/\/%s:%d%s\",\n+                        method, ctxt->hostname,\n+                        ctxt->port, ctxt->path );\n+        }\n+        else\n+            p += snprintf( p, blen - (p - bp), \"%s http:\/\/%s%s\", method,\n+                        ctxt->hostname, ctxt->path);\n@@ -1466,1 +1448,1 @@\n-    p += snprintf( p, blen - (p - bp), \"%s %s\", method, ctxt->path);\n+        p += snprintf( p, blen - (p - bp), \"%s %s\", method, ctxt->path);\n@@ -1469,1 +1451,1 @@\n-    p += snprintf( p, blen - (p - bp), \"?%s\", ctxt->query);\n+        p += snprintf( p, blen - (p - bp), \"?%s\", ctxt->query);\n@@ -1473,1 +1455,1 @@\n-            ctxt->hostname);\n+                    ctxt->hostname);\n@@ -1476,1 +1458,1 @@\n-            ctxt->hostname, ctxt->port);\n+                    ctxt->hostname, ctxt->port);\n@@ -1484,1 +1466,1 @@\n-    p += snprintf(p, blen - (p - bp), \"Content-Type: %s\\r\\n\", *contentType);\n+        p += snprintf(p, blen - (p - bp), \"Content-Type: %s\\r\\n\", *contentType);\n@@ -1487,1 +1469,1 @@\n-    p += snprintf( p, blen - (p - bp), \"%s\", headers );\n+        p += snprintf( p, blen - (p - bp), \"%s\", headers );\n@@ -1490,1 +1472,1 @@\n-    snprintf(p, blen - (p - bp), \"Content-Length: %d\\r\\n\\r\\n\", ilen );\n+        snprintf(p, blen - (p - bp), \"Content-Length: %d\\r\\n\\r\\n\", ilen );\n@@ -1492,1 +1474,1 @@\n-    snprintf(p, blen - (p - bp), \"\\r\\n\");\n+        snprintf(p, blen - (p - bp), \"\\r\\n\");\n@@ -1500,1 +1482,1 @@\n-    xmlNanoHTTPSend( ctxt, input, ilen );\n+        xmlNanoHTTPSend( ctxt, input, ilen );\n@@ -1507,5 +1489,5 @@\n-        ctxt->content = ctxt->inrptr;\n-        xmlFree(p);\n-        break;\n-    }\n-    xmlNanoHTTPScanAnswer(ctxt, p);\n+            ctxt->content = ctxt->inrptr;\n+            xmlFree(p);\n+            break;\n+        }\n+        xmlNanoHTTPScanAnswer(ctxt, p);\n@@ -1518,1 +1500,1 @@\n-    while ( xmlNanoHTTPRecv(ctxt) > 0 )\n+        while ( xmlNanoHTTPRecv(ctxt) > 0 )\n@@ -1521,4 +1503,7 @@\n-        nbRedirects++;\n-        if (redirURL != NULL)\n-        xmlFree(redirURL);\n-        redirURL = xmlMemStrdup(ctxt->location);\n+            nbRedirects++;\n+            if (redirURL != NULL)\n+                xmlFree(redirURL);\n+            redirURL = xmlMemStrdup(ctxt->location);\n+            xmlNanoHTTPFreeCtxt(ctxt);\n+            goto retry;\n+        }\n@@ -1526,5 +1511,2 @@\n-        goto retry;\n-    }\n-    xmlNanoHTTPFreeCtxt(ctxt);\n-    if (redirURL != NULL) xmlFree(redirURL);\n-    return(NULL);\n+        if (redirURL != NULL) xmlFree(redirURL);\n+        return(NULL);\n@@ -1534,4 +1516,4 @@\n-    if (ctxt->contentType != NULL)\n-        *contentType = xmlMemStrdup(ctxt->contentType);\n-    else\n-        *contentType = NULL;\n+        if (ctxt->contentType != NULL)\n+            *contentType = xmlMemStrdup(ctxt->contentType);\n+        else\n+            *contentType = NULL;\n@@ -1541,1 +1523,1 @@\n-    *redir = redirURL;\n+        *redir = redirURL;\n@@ -1543,4 +1525,4 @@\n-    if (redirURL != NULL)\n-        xmlFree(redirURL);\n-    if (redir != NULL)\n-        *redir = NULL;\n+        if (redirURL != NULL)\n+            xmlFree(redirURL);\n+        if (redir != NULL)\n+            *redir = NULL;\n@@ -1573,1 +1555,1 @@\n-                          NULL, headers, ilen));\n+                                  NULL, headers, ilen));\n@@ -1602,1 +1584,1 @@\n-        fd = 0;\n+        fd = 1; \/* STDOUT_FILENO *\/\n@@ -1605,5 +1587,7 @@\n-    if (fd < 0) {\n-        xmlNanoHTTPClose(ctxt);\n-        if ((contentType != NULL) && (*contentType != NULL)) {\n-            xmlFree(*contentType);\n-        *contentType = NULL;\n+        if (fd < 0) {\n+            xmlNanoHTTPClose(ctxt);\n+            if ((contentType != NULL) && (*contentType != NULL)) {\n+                xmlFree(*contentType);\n+                *contentType = NULL;\n+            }\n+            return(-1);\n@@ -1611,2 +1595,0 @@\n-        return(-1);\n-    }\n@@ -1617,3 +1599,3 @@\n-    if (write(fd, buf, len) == -1) {\n-        ret = -1;\n-    }\n+        if (write(fd, buf, len) == -1) {\n+            ret = -1;\n+        }\n@@ -1648,1 +1630,1 @@\n-        fd = 0;\n+        fd = 1; \/* STDOUT_FILENO *\/\n@@ -1651,4 +1633,4 @@\n-    if (fd < 0) {\n-        xmlNanoHTTPClose(ctxt);\n-        return(-1);\n-    }\n+        if (fd < 0) {\n+            xmlNanoHTTPClose(ctxt);\n+            return(-1);\n+        }\n@@ -1659,3 +1641,3 @@\n-    if (write(fd, buf, len) == -1) {\n-        ret = -1;\n-    }\n+        if (write(fd, buf, len) == -1) {\n+            ret = -1;\n+        }\n@@ -1717,1 +1699,1 @@\n-    xmlNanoHTTPCtxtPtr    ctxt = (xmlNanoHTTPCtxtPtr)ctx;\n+    xmlNanoHTTPCtxtPtr  ctxt = (xmlNanoHTTPCtxtPtr)ctx;\n@@ -1732,1 +1714,1 @@\n-    xmlNanoHTTPCtxtPtr    ctxt = (xmlNanoHTTPCtxtPtr)ctx;\n+    xmlNanoHTTPCtxtPtr  ctxt = (xmlNanoHTTPCtxtPtr)ctx;\n@@ -1747,1 +1729,1 @@\n-    xmlNanoHTTPCtxtPtr    ctxt = (xmlNanoHTTPCtxtPtr)ctx;\n+    xmlNanoHTTPCtxtPtr  ctxt = (xmlNanoHTTPCtxtPtr)ctx;\n@@ -1762,1 +1744,1 @@\n-    xmlNanoHTTPCtxtPtr    ctxt = (xmlNanoHTTPCtxtPtr)ctx;\n+    xmlNanoHTTPCtxtPtr  ctxt = (xmlNanoHTTPCtxtPtr)ctx;\n@@ -1781,1 +1763,1 @@\n-    xmlNanoHTTPCtxtPtr    ctxt = (xmlNanoHTTPCtxtPtr)ctx;\n+    xmlNanoHTTPCtxtPtr  ctxt = (xmlNanoHTTPCtxtPtr)ctx;\n@@ -1783,5 +1765,5 @@\n-    int            rc = 0;\n-    int            cur_lgth;\n-    int            rcvd_lgth;\n-    int            dummy_int;\n-    char *        dummy_ptr = NULL;\n+    int                 rc = 0;\n+    int                 cur_lgth;\n+    int                 rcvd_lgth;\n+    int                 dummy_int;\n+    char *              dummy_ptr = NULL;\n@@ -1801,2 +1783,2 @@\n-    *ptr = NULL;\n-    return ( -1 );\n+        *ptr = NULL;\n+        return ( -1 );\n@@ -1809,3 +1791,3 @@\n-    rcvd_lgth += cur_lgth;\n-    if ( (ctxt->ContentLength > 0) && (rcvd_lgth >= ctxt->ContentLength) )\n-        break;\n+        rcvd_lgth += cur_lgth;\n+        if ( (ctxt->ContentLength > 0) && (rcvd_lgth >= ctxt->ContentLength) )\n+            break;\n@@ -1820,1 +1802,1 @@\n-    rc = -1;\n+        rc = -1;\n@@ -1825,29 +1807,0 @@\n-#ifdef STANDALONE\n-int main(int argc, char **argv) {\n-    char *contentType = NULL;\n-\n-    if (argv[1] != NULL) {\n-    if (argv[2] != NULL)\n-        xmlNanoHTTPFetch(argv[1], argv[2], &contentType);\n-        else\n-        xmlNanoHTTPFetch(argv[1], \"-\", &contentType);\n-    if (contentType != NULL) xmlFree(contentType);\n-    } else {\n-        fprintf(stderr,\n-        \"%s: minimal HTTP GET implementation\\n\", argv[0]);\n-        fprintf(stderr,\n-        \"\\tusage %s [ URL [ filename ] ]\\n\", argv[0]);\n-    }\n-    xmlNanoHTTPCleanup();\n-    return(0);\n-}\n-#endif \/* STANDALONE *\/\n-#else \/* !LIBXML_HTTP_ENABLED *\/\n-#ifdef STANDALONE\n-#include <stdio.h>\n-int main(int argc, char **argv) {\n-    fprintf(stderr,\n-        \"%s : HTTP support not compiled in\\n\", argv[0]);\n-    return(0);\n-}\n-#endif \/* STANDALONE *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/nanohttp.c","additions":432,"deletions":479,"binary":false,"changes":911,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n- * the module SAX.c.\n+ * the module SAX2.c.\n@@ -65,0 +65,1 @@\n+#include <libxml\/HTMLparser.h>\n@@ -75,0 +76,1 @@\n+#include \"private\/memory.h\"\n@@ -86,0 +88,6 @@\n+#ifndef SIZE_MAX\n+  #define SIZE_MAX ((size_t) -1)\n+#endif\n+\n+#define XML_MAX_ATTRS 100000000 \/* 100 million *\/\n+\n@@ -118,4 +126,0 @@\n-struct _xmlAttrHashBucket {\n-    int index;\n-};\n-\n@@ -135,3 +139,3 @@\n- *                                    *\n- *    Arbitrary limits set in the parser. See XML_PARSE_HUGE        *\n- *                                    *\n+ *                                                                      *\n+ *      Arbitrary limits set in the parser. See XML_PARSE_HUGE          *\n+ *                                                                      *\n@@ -160,12 +164,0 @@\n-\/**\n- * xmlParserMaxDepth:\n- *\n- * arbitrary depth limit for the XML documents that we allow to\n- * process. This is not a limitation of the parser but a safety\n- * boundary feature. It can be disabled with the XML_PARSE_HUGE\n- * parser option.\n- *\/\n-const unsigned int xmlParserMaxDepth = 256;\n-\n-\n-\n@@ -217,3 +209,3 @@\n- *                                    *\n- *        Some factorized error routines                *\n- *                                    *\n+ *                                                                      *\n+ *              Some factorized error routines                          *\n+ *                                                                      *\n@@ -333,1 +325,1 @@\n-          const xmlChar *str2)\n+                  const xmlChar *str2)\n@@ -504,3 +496,3 @@\n- *                                    *\n- *        Library wide options                    *\n- *                                    *\n+ *                                                                      *\n+ *              Library wide options                                    *\n+ *                                                                      *\n@@ -523,1 +515,1 @@\n-    case XML_WITH_THREAD:\n+        case XML_WITH_THREAD:\n@@ -525,6 +517,0 @@\n-        return(1);\n-#else\n-        return(0);\n-#endif\n-        case XML_WITH_TREE:\n-#ifdef LIBXML_TREE_ENABLED\n@@ -535,0 +521,2 @@\n+        case XML_WITH_TREE:\n+            return(1);\n@@ -570,6 +558,0 @@\n-#endif\n-        case XML_WITH_FTP:\n-#ifdef LIBXML_FTP_ENABLED\n-            return(1);\n-#else\n-            return(0);\n@@ -596,3 +578,0 @@\n-#ifdef LIBXML_LEGACY_ENABLED\n-            return(1);\n-#else\n@@ -600,1 +579,0 @@\n-#endif\n@@ -644,3 +622,0 @@\n-#ifdef LIBXML_UNICODE_ENABLED\n-            return(1);\n-#else\n@@ -648,1 +623,0 @@\n-#endif\n@@ -656,1 +630,1 @@\n-#ifdef LIBXML_AUTOMATA_ENABLED\n+#ifdef LIBXML_REGEXP_ENABLED\n@@ -666,0 +640,6 @@\n+#endif\n+        case XML_WITH_RELAXNG:\n+#ifdef LIBXML_RELAXNG_ENABLED\n+            return(1);\n+#else\n+            return(0);\n@@ -712,1 +692,1 @@\n-        break;\n+            break;\n@@ -718,3 +698,3 @@\n- *                                    *\n- *            Simple string buffer                *\n- *                                    *\n+ *                                                                      *\n+ *                      Simple string buffer                            *\n+ *                                                                      *\n@@ -932,3 +912,3 @@\n- *                                    *\n- *        SAX2 defaulted attributes handling            *\n- *                                    *\n+ *                                                                      *\n+ *              SAX2 defaulted attributes handling                      *\n+ *                                                                      *\n@@ -983,1 +963,1 @@\n-        (ctxt->str_xml_ns == NULL)) {\n+                (ctxt->str_xml_ns == NULL)) {\n@@ -986,0 +966,5 @@\n+\n+    xmlDictSetLimit(ctxt->dict,\n+                    (ctxt->options & XML_PARSE_HUGE) ?\n+                        0 :\n+                        XML_MAX_DICTIONARY_LIMIT);\n@@ -1000,1 +985,1 @@\n-    int nbAttrs;    \/* number of defaulted attributes on that element *\/\n+    int nbAttrs;        \/* number of defaulted attributes on that element *\/\n@@ -1004,1 +989,1 @@\n-    xmlDefAttr attrs[]; \/* array of localname\/prefix\/values\/external *\/\n+    xmlDefAttr attrs[] ATTRIBUTE_COUNTED_BY(maxAttrs);\n@@ -1035,7 +1020,7 @@\n-    if (*src == 0x20) {\n-        while (*src == 0x20) src++;\n-        if (*src != 0)\n-        *dst++ = 0x20;\n-    } else {\n-        *dst++ = *src++;\n-    }\n+        if (*src == 0x20) {\n+            while (*src == 0x20) src++;\n+            if (*src != 0)\n+                *dst++ = 0x20;\n+        } else {\n+            *dst++ = *src++;\n+        }\n@@ -1076,1 +1061,1 @@\n-        return;\n+            return;\n@@ -1081,2 +1066,2 @@\n-    if (ctxt->attsDefault == NULL)\n-        goto mem_error;\n+        if (ctxt->attsDefault == NULL)\n+            goto mem_error;\n@@ -1092,1 +1077,1 @@\n-    prefix.name = NULL;\n+        prefix.name = NULL;\n@@ -1095,1 +1080,1 @@\n-    prefix = xmlDictLookupHashed(ctxt->dict, fullname, len);\n+        prefix = xmlDictLookupHashed(ctxt->dict, fullname, len);\n@@ -1111,1 +1096,13 @@\n-        newSize = (defaults != NULL) ? 2 * defaults->maxAttrs : 4;\n+        if (defaults == NULL) {\n+            newSize = 4;\n+        } else {\n+            if ((defaults->maxAttrs >= XML_MAX_ATTRS) ||\n+                ((size_t) defaults->maxAttrs >\n+                     SIZE_MAX \/ 2 \/ sizeof(temp[0]) - sizeof(*defaults)))\n+                goto mem_error;\n+\n+            if (defaults->maxAttrs > XML_MAX_ATTRS \/ 2)\n+                newSize = XML_MAX_ATTRS;\n+            else\n+                newSize = defaults->maxAttrs * 2;\n+        }\n@@ -1114,2 +1111,2 @@\n-    if (temp == NULL)\n-        goto mem_error;\n+        if (temp == NULL)\n+            goto mem_error;\n@@ -1118,1 +1115,1 @@\n-    temp->maxAttrs = newSize;\n+        temp->maxAttrs = newSize;\n@@ -1120,5 +1117,5 @@\n-    if (xmlHashUpdateEntry2(ctxt->attsDefault, name.name, prefix.name,\n-                            defaults, NULL) < 0) {\n-        xmlFree(defaults);\n-        goto mem_error;\n-    }\n+        if (xmlHashUpdateEntry2(ctxt->attsDefault, name.name, prefix.name,\n+                                defaults, NULL) < 0) {\n+            xmlFree(defaults);\n+            goto mem_error;\n+        }\n@@ -1134,1 +1131,1 @@\n-    prefix.name = NULL;\n+        prefix.name = NULL;\n@@ -1137,1 +1134,1 @@\n-    prefix = xmlDictLookupHashed(ctxt->dict, fullattr, len);\n+        prefix = xmlDictLookupHashed(ctxt->dict, fullattr, len);\n@@ -1167,1 +1164,0 @@\n-    return;\n@@ -1181,3 +1177,3 @@\n-          const xmlChar *fullname,\n-          const xmlChar *fullattr,\n-          int type)\n+                  const xmlChar *fullname,\n+                  const xmlChar *fullattr,\n+                  int type)\n@@ -1187,2 +1183,2 @@\n-    if (ctxt->attsSpecial == NULL)\n-        goto mem_error;\n+        if (ctxt->attsSpecial == NULL)\n+            goto mem_error;\n@@ -1192,1 +1188,1 @@\n-                    (void *) (ptrdiff_t) type) < 0)\n+                    XML_INT_TO_PTR(type)) < 0)\n@@ -1198,1 +1194,0 @@\n-    return;\n@@ -1212,1 +1207,1 @@\n-    if (((ptrdiff_t) payload) == XML_ATTRIBUTE_CDATA) {\n+    if (XML_PTR_TO_INT(payload) == XML_ATTRIBUTE_CDATA) {\n@@ -1237,1 +1232,0 @@\n-    return;\n@@ -1437,3 +1431,3 @@\n- *                                    *\n- *        Parser stacks related functions and macros        *\n- *                                    *\n+ *                                                                      *\n+ *              Parser stacks related functions and macros              *\n+ *                                                                      *\n@@ -1680,1 +1674,4 @@\n-    if (ctxt->nsMax > INT_MAX \/ 2)\n+    newSize = xmlGrowCapacity(ctxt->nsMax,\n+                              sizeof(table[0]) + sizeof(extra[0]),\n+                              16, XML_MAX_ITEMS);\n+    if (newSize < 0)\n@@ -1682,1 +1679,0 @@\n-    newSize = ctxt->nsMax ? ctxt->nsMax * 2 : 16;\n@@ -1902,1 +1898,1 @@\n-xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt, int nr) {\n+xmlCtxtGrowAttrs(xmlParserCtxtPtr ctxt) {\n@@ -1905,1 +1901,1 @@\n-    int maxatts;\n+    int newSize;\n@@ -1907,14 +1903,12 @@\n-    if (nr + 5 > ctxt->maxatts) {\n-    maxatts = ctxt->maxatts == 0 ? 55 : (nr + 5) * 2;\n-    atts = (const xmlChar **) xmlMalloc(\n-                     maxatts * sizeof(const xmlChar *));\n-    if (atts == NULL) goto mem_error;\n-    attallocs = xmlRealloc(ctxt->attallocs,\n-                               (maxatts \/ 5) * sizeof(attallocs[0]));\n-    if (attallocs == NULL) {\n-            xmlFree(atts);\n-            goto mem_error;\n-        }\n-        if (ctxt->maxatts > 0)\n-            memcpy(atts, ctxt->atts, ctxt->maxatts * sizeof(const xmlChar *));\n-        xmlFree(ctxt->atts);\n+    newSize = xmlGrowCapacity(ctxt->maxatts \/ 5,\n+                              sizeof(atts[0]) * 5 + sizeof(attallocs[0]),\n+                              10, XML_MAX_ATTRS);\n+    if (newSize < 0) {\n+        xmlFatalErr(ctxt, XML_ERR_RESOURCE_LIMIT,\n+                    \"Maximum number of attributes exceeded\");\n+        return(-1);\n+    }\n+\n+    atts = xmlRealloc(ctxt->atts, newSize * sizeof(atts[0]) * 5);\n+    if (atts == NULL)\n+        goto mem_error;\n@@ -1922,0 +1916,5 @@\n+\n+    attallocs = xmlRealloc(ctxt->attallocs,\n+                           newSize * sizeof(attallocs[0]));\n+    if (attallocs == NULL)\n+        goto mem_error;\n@@ -1923,3 +1922,5 @@\n-    ctxt->maxatts = maxatts;\n-    }\n-    return(ctxt->maxatts);\n+\n+    ctxt->maxatts = newSize * 5;\n+\n+    return(0);\n+\n@@ -1932,1 +1933,1 @@\n- * inputPush:\n+ * xmlCtxtPushInput:\n@@ -1941,1 +1942,1 @@\n-inputPush(xmlParserCtxtPtr ctxt, xmlParserInputPtr value)\n+xmlCtxtPushInput(xmlParserCtxtPtr ctxt, xmlParserInputPtr value)\n@@ -1944,0 +1945,1 @@\n+    int maxDepth;\n@@ -1948,0 +1950,2 @@\n+    maxDepth = (ctxt->options & XML_PARSE_HUGE) ? 40 : 20;\n+\n@@ -1949,1 +1953,0 @@\n-        size_t newSize = ctxt->inputMax * 2;\n@@ -1951,0 +1954,1 @@\n+        int newSize;\n@@ -1952,2 +1956,9 @@\n-        tmp = (xmlParserInputPtr *) xmlRealloc(ctxt->inputTab,\n-                                               newSize * sizeof(*tmp));\n+        newSize = xmlGrowCapacity(ctxt->inputMax, sizeof(tmp[0]),\n+                                  5, maxDepth);\n+        if (newSize < 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_RESOURCE_LIMIT,\n+                           \"Maximum entity nesting depth exceeded\");\n+            xmlHaltParser(ctxt);\n+            return(-1);\n+        }\n+        tmp = xmlRealloc(ctxt->inputTab, newSize * sizeof(tmp[0]));\n@@ -1956,1 +1967,1 @@\n-            return (-1);\n+            return(-1);\n@@ -1970,0 +1981,5 @@\n+    if (ctxt->input_id >= INT_MAX) {\n+        xmlFatalErrMsg(ctxt, XML_ERR_RESOURCE_LIMIT, \"Input ID overflow\\n\");\n+        return(-1);\n+    }\n+\n@@ -1978,0 +1994,7 @@\n+    \/*\n+     * Internally, the input ID is only used to detect parameter entity\n+     * boundaries. But there are entity loaders in downstream code that\n+     * detect the main document by checking for \"input_id == 1\".\n+     *\/\n+    value->id = ctxt->input_id++;\n+\n@@ -1980,0 +2003,1 @@\n+\n@@ -1981,1 +2005,1 @@\n- * inputPop:\n+ * xmlCtxtPopInput:\n@@ -1989,1 +2013,1 @@\n-inputPop(xmlParserCtxtPtr ctxt)\n+xmlCtxtPopInput(xmlParserCtxtPtr ctxt)\n@@ -2006,0 +2030,1 @@\n+\n@@ -2020,2 +2045,0 @@\n-    int maxDepth;\n-\n@@ -2025,8 +2048,0 @@\n-    maxDepth = (ctxt->options & XML_PARSE_HUGE) ? 2048 : 256;\n-    if (ctxt->nodeNr > maxDepth) {\n-        xmlFatalErrMsgInt(ctxt, XML_ERR_RESOURCE_LIMIT,\n-                \"Excessive depth in document: %d use XML_PARSE_HUGE option\\n\",\n-                ctxt->nodeNr);\n-        xmlHaltParser(ctxt);\n-        return(-1);\n-    }\n@@ -2034,0 +2049,1 @@\n+        int maxDepth = (ctxt->options & XML_PARSE_HUGE) ? 2048 : 256;\n@@ -2035,0 +2051,12 @@\n+        int newSize;\n+\n+        newSize = xmlGrowCapacity(ctxt->nodeMax, sizeof(tmp[0]),\n+                                  10, maxDepth);\n+        if (newSize < 0) {\n+            xmlFatalErrMsgInt(ctxt, XML_ERR_RESOURCE_LIMIT,\n+                    \"Excessive depth in document: %d,\"\n+                    \" use XML_PARSE_HUGE option\\n\",\n+                    ctxt->nodeNr);\n+            xmlHaltParser(ctxt);\n+            return(-1);\n+        }\n@@ -2036,3 +2064,1 @@\n-    tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,\n-                                      ctxt->nodeMax * 2 *\n-                                      sizeof(ctxt->nodeTab[0]));\n+        tmp = xmlRealloc(ctxt->nodeTab, newSize * sizeof(tmp[0]));\n@@ -2044,1 +2070,1 @@\n-    ctxt->nodeMax *= 2;\n+        ctxt->nodeMax = newSize;\n@@ -2046,0 +2072,1 @@\n+\n@@ -2099,1 +2126,1 @@\n-        const xmlChar * *tmp;\n+        const xmlChar **tmp;\n@@ -2101,17 +2128,19 @@\n-        ctxt->nameMax *= 2;\n-        tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt->nameTab,\n-                                    ctxt->nameMax *\n-                                    sizeof(ctxt->nameTab[0]));\n-        if (tmp == NULL) {\n-        ctxt->nameMax \/= 2;\n-        goto mem_error;\n-        }\n-    ctxt->nameTab = tmp;\n-        tmp2 = (xmlStartTag *) xmlRealloc((void * *)ctxt->pushTab,\n-                                    ctxt->nameMax *\n-                                    sizeof(ctxt->pushTab[0]));\n-        if (tmp2 == NULL) {\n-        ctxt->nameMax \/= 2;\n-        goto mem_error;\n-        }\n-    ctxt->pushTab = tmp2;\n+        int newSize;\n+\n+        newSize = xmlGrowCapacity(ctxt->nameMax,\n+                                  sizeof(tmp[0]) + sizeof(tmp2[0]),\n+                                  10, XML_MAX_ITEMS);\n+        if (newSize < 0)\n+            goto mem_error;\n+\n+        tmp = xmlRealloc(ctxt->nameTab, newSize * sizeof(tmp[0]));\n+        if (tmp == NULL)\n+            goto mem_error;\n+        ctxt->nameTab = tmp;\n+\n+        tmp2 = xmlRealloc(ctxt->pushTab, newSize * sizeof(tmp2[0]));\n+        if (tmp2 == NULL)\n+            goto mem_error;\n+        ctxt->pushTab = tmp2;\n+\n+        ctxt->nameMax = newSize;\n@@ -2119,2 +2148,1 @@\n-        ctxt->pushTab = (xmlStartTag *) xmlMalloc(ctxt->nameMax *\n-                                            sizeof(ctxt->pushTab[0]));\n+        ctxt->pushTab = xmlMalloc(ctxt->nameMax * sizeof(ctxt->pushTab[0]));\n@@ -2163,35 +2191,0 @@\n-\/**\n- * namePush:\n- * @ctxt:  an XML parser context\n- * @value:  the element name\n- *\n- * DEPRECATED: Internal function, do not use.\n- *\n- * Pushes a new element name on top of the name stack\n- *\n- * Returns -1 in case of error, the index in the stack otherwise\n- *\/\n-int\n-namePush(xmlParserCtxtPtr ctxt, const xmlChar * value)\n-{\n-    if (ctxt == NULL) return (-1);\n-\n-    if (ctxt->nameNr >= ctxt->nameMax) {\n-        const xmlChar * *tmp;\n-        tmp = (const xmlChar * *) xmlRealloc((xmlChar * *)ctxt->nameTab,\n-                                    ctxt->nameMax * 2 *\n-                                    sizeof(ctxt->nameTab[0]));\n-        if (tmp == NULL) {\n-        goto mem_error;\n-        }\n-    ctxt->nameTab = tmp;\n-        ctxt->nameMax *= 2;\n-    }\n-    ctxt->nameTab[ctxt->nameNr] = value;\n-    ctxt->name = value;\n-    return (ctxt->nameNr++);\n-mem_error:\n-    xmlErrMemory(ctxt);\n-    return (-1);\n-}\n-\n@@ -2208,1 +2201,1 @@\n-const xmlChar *\n+static const xmlChar *\n@@ -2228,0 +2221,8 @@\n+        int newSize;\n+\n+        newSize = xmlGrowCapacity(ctxt->spaceMax, sizeof(tmp[0]),\n+                                  10, XML_MAX_ITEMS);\n+        if (newSize < 0) {\n+            xmlErrMemory(ctxt);\n+            return(-1);\n+        }\n@@ -2229,3 +2230,1 @@\n-    ctxt->spaceMax *= 2;\n-        tmp = (int *) xmlRealloc(ctxt->spaceTab,\n-                             ctxt->spaceMax * sizeof(ctxt->spaceTab[0]));\n+        tmp = xmlRealloc(ctxt->spaceTab, newSize * sizeof(tmp[0]));\n@@ -2233,5 +2232,6 @@\n-        xmlErrMemory(ctxt);\n-        ctxt->spaceMax \/=2;\n-        return(-1);\n-    }\n-    ctxt->spaceTab = tmp;\n+            xmlErrMemory(ctxt);\n+            return(-1);\n+        }\n+        ctxt->spaceTab = tmp;\n+\n+        ctxt->spaceMax = newSize;\n@@ -2249,1 +2249,1 @@\n-    ctxt->space = &ctxt->spaceTab[ctxt->spaceNr - 1];\n+        ctxt->space = &ctxt->spaceTab[ctxt->spaceNr - 1];\n@@ -2284,2 +2284,0 @@\n- *   CUR_CHAR(l) returns the current unicode character (int), set l\n- *           to the number of xmlChars used for the encoding [0-5].\n@@ -2316,4 +2314,4 @@\n-#define SKIP(val) do {                            \\\n-    ctxt->input->cur += (val),ctxt->input->col+=(val);            \\\n-    if (*ctxt->input->cur == 0)                        \\\n-        xmlParserGrow(ctxt);                        \\\n+#define SKIP(val) do {                                                  \\\n+    ctxt->input->cur += (val),ctxt->input->col+=(val);                  \\\n+    if (*ctxt->input->cur == 0)                                         \\\n+        xmlParserGrow(ctxt);                                            \\\n@@ -2322,10 +2320,10 @@\n-#define SKIPL(val) do {                            \\\n-    int skipl;                                \\\n-    for(skipl=0; skipl<val; skipl++) {                    \\\n-    if (*(ctxt->input->cur) == '\\n') {                \\\n-    ctxt->input->line++; ctxt->input->col = 1;            \\\n-    } else ctxt->input->col++;                    \\\n-    ctxt->input->cur++;                        \\\n-    }                                    \\\n-    if (*ctxt->input->cur == 0)                        \\\n-        xmlParserGrow(ctxt);                        \\\n+#define SKIPL(val) do {                                                 \\\n+    int skipl;                                                          \\\n+    for(skipl=0; skipl<val; skipl++) {                                  \\\n+        if (*(ctxt->input->cur) == '\\n') {                              \\\n+        ctxt->input->line++; ctxt->input->col = 1;                      \\\n+        } else ctxt->input->col++;                                      \\\n+        ctxt->input->cur++;                                             \\\n+    }                                                                   \\\n+    if (*ctxt->input->cur == 0)                                         \\\n+        xmlParserGrow(ctxt);                                            \\\n@@ -2335,4 +2333,2 @@\n-    if ((!PARSER_PROGRESSIVE(ctxt)) && \\\n-        (ctxt->input->cur - ctxt->input->base > 2 * INPUT_CHUNK) && \\\n-    (ctxt->input->end - ctxt->input->cur < 2 * INPUT_CHUNK)) \\\n-    xmlParserShrink(ctxt);\n+    if (!PARSER_PROGRESSIVE(ctxt)) \\\n+        xmlParserShrink(ctxt);\n@@ -2343,1 +2339,1 @@\n-    xmlParserGrow(ctxt);\n+        xmlParserGrow(ctxt);\n@@ -2351,5 +2347,5 @@\n-#define NEXT1 {                                \\\n-    ctxt->input->col++;                        \\\n-    ctxt->input->cur++;                        \\\n-    if (*ctxt->input->cur == 0)                    \\\n-        xmlParserGrow(ctxt);                        \\\n+#define NEXT1 {                                                         \\\n+        ctxt->input->col++;                                             \\\n+        ctxt->input->cur++;                                             \\\n+        if (*ctxt->input->cur == 0)                                     \\\n+            xmlParserGrow(ctxt);                                                \\\n@@ -2358,5 +2354,5 @@\n-#define NEXTL(l) do {                            \\\n-    if (*(ctxt->input->cur) == '\\n') {                    \\\n-    ctxt->input->line++; ctxt->input->col = 1;            \\\n-    } else ctxt->input->col++;                        \\\n-    ctxt->input->cur += l;                \\\n+#define NEXTL(l) do {                                                   \\\n+    if (*(ctxt->input->cur) == '\\n') {                                  \\\n+        ctxt->input->line++; ctxt->input->col = 1;                      \\\n+    } else ctxt->input->col++;                                          \\\n+    ctxt->input->cur += l;                              \\\n@@ -2365,1 +2361,0 @@\n-#define CUR_CHAR(l) xmlCurrentChar(ctxt, &l)\n@@ -2368,2 +2363,2 @@\n-#define COPY_BUF(b, i, v)                        \\\n-    if (v < 0x80) b[i++] = v;                        \\\n+#define COPY_BUF(b, i, v)                                               \\\n+    if (v < 0x80) b[i++] = v;                                           \\\n@@ -2372,0 +2367,10 @@\n+static int\n+xmlCurrentCharRecover(xmlParserCtxtPtr ctxt, int *len) {\n+    int c = xmlCurrentChar(ctxt, len);\n+\n+    if (c == XML_INVALID_CHAR)\n+        c = 0xFFFD; \/* replacement character *\/\n+\n+    return(c);\n+}\n+\n@@ -2387,4 +2392,0 @@\n-    \/*\n-     * It's Okay to use CUR\/NEXT here since all the blanks are on\n-     * the ASCII range.\n-     *\/\n@@ -2409,0 +2410,3 @@\n+    if (res > 4)\n+        GROW;\n+\n@@ -2451,1 +2455,1 @@\n-    xmlPopInput(ctxt);\n+    xmlFreeInputStream(xmlCtxtPopInput(ctxt));\n@@ -2454,0 +2458,2 @@\n+\n+    GROW;\n@@ -2477,0 +2483,4 @@\n+    \/*\n+     * It's Okay to use CUR\/NEXT here since all the blanks are on\n+     * the ASCII range.\n+     *\/\n@@ -2522,3 +2532,3 @@\n- *                                    *\n- *        Commodity functions to handle entities            *\n- *                                    *\n+ *                                                                      *\n+ *              Commodity functions to handle entities                  *\n+ *                                                                      *\n@@ -2531,2 +2541,1 @@\n- * xmlPopInput: the current input pointed by ctxt->input came to an end\n- *          pop it and return the next char.\n+ * DEPRECATED: Internal function, don't use.\n@@ -2541,1 +2550,1 @@\n-    input = inputPop(ctxt);\n+    input = xmlCtxtPopInput(ctxt);\n@@ -2553,0 +2562,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -2559,1 +2570,0 @@\n-    int maxDepth;\n@@ -2565,9 +2575,3 @@\n-    maxDepth = (ctxt->options & XML_PARSE_HUGE) ? 40 : 20;\n-    if (ctxt->inputNr > maxDepth) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_RESOURCE_LIMIT,\n-                       \"Maximum entity nesting depth exceeded\");\n-        xmlHaltParser(ctxt);\n-    return(-1);\n-    }\n-    ret = inputPush(ctxt, input);\n-    GROW;\n+    ret = xmlCtxtPushInput(ctxt, input);\n+    if (ret >= 0)\n+        GROW;\n@@ -2604,5 +2608,1 @@\n-    SKIP(3);\n-    GROW;\n-    while ((RAW != ';') && (PARSER_STOPPED(ctxt) == 0)) {\n-        if (count++ > 20) {\n-        count = 0;\n+        SKIP(3);\n@@ -2610,0 +2610,21 @@\n+        while ((RAW != ';') && (PARSER_STOPPED(ctxt) == 0)) {\n+            if (count++ > 20) {\n+                count = 0;\n+                GROW;\n+            }\n+            if ((RAW >= '0') && (RAW <= '9'))\n+                val = val * 16 + (CUR - '0');\n+            else if ((RAW >= 'a') && (RAW <= 'f') && (count < 20))\n+                val = val * 16 + (CUR - 'a') + 10;\n+            else if ((RAW >= 'A') && (RAW <= 'F') && (count < 20))\n+                val = val * 16 + (CUR - 'A') + 10;\n+            else {\n+                xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);\n+                val = 0;\n+                break;\n+            }\n+            if (val > 0x110000)\n+                val = 0x110000;\n+\n+            NEXT;\n+            count++;\n@@ -2611,10 +2632,4 @@\n-        if ((RAW >= '0') && (RAW <= '9'))\n-            val = val * 16 + (CUR - '0');\n-        else if ((RAW >= 'a') && (RAW <= 'f') && (count < 20))\n-            val = val * 16 + (CUR - 'a') + 10;\n-        else if ((RAW >= 'A') && (RAW <= 'F') && (count < 20))\n-            val = val * 16 + (CUR - 'A') + 10;\n-        else {\n-        xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);\n-        val = 0;\n-        break;\n+        if (RAW == ';') {\n+            \/* on purpose to avoid reentrancy problems with NEXT and SKIP *\/\n+            ctxt->input->col++;\n+            ctxt->input->cur++;\n@@ -2622,11 +2637,0 @@\n-        if (val > 0x110000)\n-            val = 0x110000;\n-\n-        NEXT;\n-        count++;\n-    }\n-    if (RAW == ';') {\n-        \/* on purpose to avoid reentrancy problems with NEXT and SKIP *\/\n-        ctxt->input->col++;\n-        ctxt->input->cur++;\n-    }\n@@ -2634,5 +2638,1 @@\n-    SKIP(2);\n-    GROW;\n-    while (RAW != ';') { \/* loop blocked by count *\/\n-        if (count++ > 20) {\n-        count = 0;\n+        SKIP(2);\n@@ -2640,0 +2640,17 @@\n+        while (RAW != ';') { \/* loop blocked by count *\/\n+            if (count++ > 20) {\n+                count = 0;\n+                GROW;\n+            }\n+            if ((RAW >= '0') && (RAW <= '9'))\n+                val = val * 10 + (CUR - '0');\n+            else {\n+                xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);\n+                val = 0;\n+                break;\n+            }\n+            if (val > 0x110000)\n+                val = 0x110000;\n+\n+            NEXT;\n+            count++;\n@@ -2641,6 +2658,4 @@\n-        if ((RAW >= '0') && (RAW <= '9'))\n-            val = val * 10 + (CUR - '0');\n-        else {\n-        xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);\n-        val = 0;\n-        break;\n+        if (RAW == ';') {\n+            \/* on purpose to avoid reentrancy problems with NEXT and SKIP *\/\n+            ctxt->input->col++;\n+            ctxt->input->cur++;\n@@ -2648,11 +2663,0 @@\n-        if (val > 0x110000)\n-            val = 0x110000;\n-\n-        NEXT;\n-        count++;\n-    }\n-    if (RAW == ';') {\n-        \/* on purpose to avoid reentrancy problems with NEXT and SKIP *\/\n-        ctxt->input->col++;\n-        ctxt->input->cur++;\n-    }\n@@ -2673,4 +2677,3 @@\n-            val);\n-    } else if (IS_CHAR(val)) {\n-        return(val);\n-    } else {\n+                val);\n+        val = 0xFFFD;\n+    } else if (!IS_CHAR(val)) {\n@@ -2679,1 +2682,1 @@\n-                      val);\n+                          val);\n@@ -2681,1 +2684,1 @@\n-    return(0);\n+    return(val);\n@@ -2712,18 +2715,1 @@\n-    ptr += 3;\n-    cur = *ptr;\n-    while (cur != ';') { \/* Non input consuming loop *\/\n-        if ((cur >= '0') && (cur <= '9'))\n-            val = val * 16 + (cur - '0');\n-        else if ((cur >= 'a') && (cur <= 'f'))\n-            val = val * 16 + (cur - 'a') + 10;\n-        else if ((cur >= 'A') && (cur <= 'F'))\n-            val = val * 16 + (cur - 'A') + 10;\n-        else {\n-        xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);\n-        val = 0;\n-        break;\n-        }\n-        if (val > 0x110000)\n-            val = 0x110000;\n-\n-        ptr++;\n+        ptr += 3;\n@@ -2731,16 +2717,14 @@\n-    }\n-    if (cur == ';')\n-        ptr++;\n-    } else if  ((cur == '&') && (ptr[1] == '#')){\n-    ptr += 2;\n-    cur = *ptr;\n-    while (cur != ';') { \/* Non input consuming loops *\/\n-        if ((cur >= '0') && (cur <= '9'))\n-            val = val * 10 + (cur - '0');\n-        else {\n-        xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);\n-        val = 0;\n-        break;\n-        }\n-        if (val > 0x110000)\n-            val = 0x110000;\n+        while (cur != ';') { \/* Non input consuming loop *\/\n+            if ((cur >= '0') && (cur <= '9'))\n+                val = val * 16 + (cur - '0');\n+            else if ((cur >= 'a') && (cur <= 'f'))\n+                val = val * 16 + (cur - 'a') + 10;\n+            else if ((cur >= 'A') && (cur <= 'F'))\n+                val = val * 16 + (cur - 'A') + 10;\n+            else {\n+                xmlFatalErr(ctxt, XML_ERR_INVALID_HEX_CHARREF, NULL);\n+                val = 0;\n+                break;\n+            }\n+            if (val > 0x110000)\n+                val = 0x110000;\n@@ -2748,1 +2732,7 @@\n-        ptr++;\n+            ptr++;\n+            cur = *ptr;\n+        }\n+        if (cur == ';')\n+            ptr++;\n+    } else if  ((cur == '&') && (ptr[1] == '#')){\n+        ptr += 2;\n@@ -2750,3 +2740,16 @@\n-    }\n-    if (cur == ';')\n-        ptr++;\n+        while (cur != ';') { \/* Non input consuming loops *\/\n+            if ((cur >= '0') && (cur <= '9'))\n+                val = val * 10 + (cur - '0');\n+            else {\n+                xmlFatalErr(ctxt, XML_ERR_INVALID_DEC_CHARREF, NULL);\n+                val = 0;\n+                break;\n+            }\n+            if (val > 0x110000)\n+                val = 0x110000;\n+\n+            ptr++;\n+            cur = *ptr;\n+        }\n+        if (cur == ';')\n+            ptr++;\n@@ -2754,2 +2757,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);\n-    return(0);\n+        xmlFatalErr(ctxt, XML_ERR_INVALID_CHARREF, NULL);\n+        return(0);\n@@ -2772,2 +2775,2 @@\n-              \"xmlParseStringCharRef: invalid xmlChar value %d\\n\",\n-              val);\n+                          \"xmlParseStringCharRef: invalid xmlChar value %d\\n\",\n+                          val);\n@@ -2863,1 +2866,1 @@\n-                xmlChar end, xmlChar  end2, xmlChar end3) {\n+                        xmlChar end, xmlChar  end2, xmlChar end3) {\n@@ -2874,3 +2877,3 @@\n- *                                    *\n- *        Commodity functions, cleanup needed ?            *\n- *                                    *\n+ *                                                                      *\n+ *              Commodity functions, cleanup needed ?                   *\n+ *                                                                      *\n@@ -2896,7 +2899,0 @@\n-    \/*\n-     * Don't spend time trying to differentiate them, the same callback is\n-     * used !\n-     *\/\n-    if (ctxt->sax->ignorableWhitespace == ctxt->sax->characters)\n-    return(0);\n-\n@@ -2908,1 +2904,1 @@\n-    return(0);\n+        return(0);\n@@ -2914,2 +2910,2 @@\n-    for (i = 0;i < len;i++)\n-        if (!(IS_BLANK_CH(str[i]))) return(0);\n+        for (i = 0;i < len;i++)\n+            if (!(IS_BLANK_CH(str[i]))) return(0);\n@@ -2946,0 +2942,4 @@\n+     *\n+     * When push parsing, we could be at the end of a chunk.\n+     * This makes the look-ahead and consequently the NOBLANKS\n+     * option unreliable.\n@@ -2949,1 +2949,1 @@\n-    (RAW == '<') && (NXT(1) == '\/')) return(0);\n+        (RAW == '<') && (NXT(1) == '\/')) return(0);\n@@ -2964,4 +2964,4 @@\n- *                                    *\n- *        Extra stuff for namespace support            *\n- *    Relates to http:\/\/www.w3.org\/TR\/WD-xml-names            *\n- *                                    *\n+ *                                                                      *\n+ *              Extra stuff for namespace support                       *\n+ *      Relates to http:\/\/www.w3.org\/TR\/WD-xml-names                    *\n+ *                                                                      *\n@@ -2976,0 +2976,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -3006,1 +3008,1 @@\n-    return(xmlStrdup(name));\n+        return(xmlStrdup(name));\n@@ -3010,2 +3012,2 @@\n-    buf[len++] = c;\n-    c = *cur++;\n+        buf[len++] = c;\n+        c = *cur++;\n@@ -3014,15 +3016,5 @@\n-    \/*\n-     * Okay someone managed to make a huge name, so he's ready to pay\n-     * for the processing speed.\n-     *\/\n-    max = len * 2;\n-\n-    buffer = (xmlChar *) xmlMallocAtomic(max);\n-    if (buffer == NULL) {\n-        xmlErrMemory(ctxt);\n-        return(NULL);\n-    }\n-    memcpy(buffer, buf, len);\n-    while ((c != 0) && (c != ':')) { \/* tested bigname.xml *\/\n-        if (len + 10 > max) {\n-            xmlChar *tmp;\n+        \/*\n+         * Okay someone managed to make a huge name, so he's ready to pay\n+         * for the processing speed.\n+         *\/\n+        max = len * 2;\n@@ -3030,4 +3022,2 @@\n-        max *= 2;\n-        tmp = (xmlChar *) xmlRealloc(buffer, max);\n-        if (tmp == NULL) {\n-            xmlFree(buffer);\n+        buffer = xmlMalloc(max);\n+        if (buffer == NULL) {\n@@ -3037,1 +3027,23 @@\n-        buffer = tmp;\n+        memcpy(buffer, buf, len);\n+        while ((c != 0) && (c != ':')) { \/* tested bigname.xml *\/\n+            if (len + 10 > max) {\n+                xmlChar *tmp;\n+                int newSize;\n+\n+                newSize = xmlGrowCapacity(max, 1, 1, XML_MAX_ITEMS);\n+                if (newSize < 0) {\n+                    xmlErrMemory(ctxt);\n+                    xmlFree(buffer);\n+                    return(NULL);\n+                }\n+                tmp = xmlRealloc(buffer, newSize);\n+                if (tmp == NULL) {\n+                    xmlErrMemory(ctxt);\n+                    xmlFree(buffer);\n+                    return(NULL);\n+                }\n+                buffer = tmp;\n+                max = newSize;\n+            }\n+            buffer[len++] = c;\n+            c = *cur++;\n@@ -3039,4 +3051,1 @@\n-        buffer[len++] = c;\n-        c = *cur++;\n-    }\n-    buffer[len] = 0;\n+        buffer[len] = 0;\n@@ -3047,2 +3056,2 @@\n-        xmlFree(buffer);\n-    return(xmlStrdup(name));\n+            xmlFree(buffer);\n+        return(xmlStrdup(name));\n@@ -3052,1 +3061,1 @@\n-    ret = xmlStrndup(buf, len);\n+        ret = xmlStrndup(buf, len);\n@@ -3054,2 +3063,2 @@\n-        xmlErrMemory(ctxt);\n-        return(NULL);\n+            xmlErrMemory(ctxt);\n+            return(NULL);\n@@ -3058,3 +3067,3 @@\n-    ret = buffer;\n-    buffer = NULL;\n-    max = XML_MAX_NAMELEN;\n+        ret = buffer;\n+        buffer = NULL;\n+        max = XML_MAX_NAMELEN;\n@@ -3065,1 +3074,1 @@\n-    c = *cur;\n+        c = *cur;\n@@ -3067,2 +3076,2 @@\n-    if (c == 0) {\n-        ret = xmlStrndup(BAD_CAST \"\", 0);\n+        if (c == 0) {\n+            ret = xmlStrndup(BAD_CAST \"\", 0);\n@@ -3075,17 +3084,0 @@\n-    }\n-    len = 0;\n-\n-    \/*\n-     * Check that the first character is proper to start\n-     * a new name\n-     *\/\n-    if (!(((c >= 0x61) && (c <= 0x7A)) ||\n-          ((c >= 0x41) && (c <= 0x5A)) ||\n-          (c == '_') || (c == ':'))) {\n-        int l;\n-        int first = CUR_SCHAR(cur, l);\n-\n-        if (!IS_LETTER(first) && (first != '_')) {\n-        xmlFatalErrMsgStr(ctxt, XML_NS_ERR_QNAME,\n-                \"Name %s is not XML Namespace compliant\\n\",\n-                  name);\n@@ -3093,2 +3085,1 @@\n-    }\n-    cur++;\n+        len = 0;\n@@ -3096,5 +3087,0 @@\n-    while ((c != 0) && (len < max)) { \/* tested bigname2.xml *\/\n-        buf[len++] = c;\n-        c = *cur++;\n-    }\n-    if (len >= max) {\n@@ -3102,2 +3088,2 @@\n-         * Okay someone managed to make a huge name, so he's ready to pay\n-         * for the processing speed.\n+         * Check that the first character is proper to start\n+         * a new name\n@@ -3105,1 +3091,13 @@\n-        max = len * 2;\n+        if (!(((c >= 0x61) && (c <= 0x7A)) ||\n+              ((c >= 0x41) && (c <= 0x5A)) ||\n+              (c == '_') || (c == ':'))) {\n+            int l;\n+            int first = CUR_SCHAR(cur, l);\n+\n+            if (!IS_LETTER(first) && (first != '_')) {\n+                xmlFatalErrMsgStr(ctxt, XML_NS_ERR_QNAME,\n+                            \"Name %s is not XML Namespace compliant\\n\",\n+                                  name);\n+            }\n+        }\n+        cur++;\n@@ -3107,5 +3105,3 @@\n-        buffer = (xmlChar *) xmlMallocAtomic(max);\n-        if (buffer == NULL) {\n-            xmlErrMemory(ctxt);\n-                xmlFree(prefix);\n-        return(NULL);\n+        while ((c != 0) && (len < max)) { \/* tested bigname2.xml *\/\n+            buf[len++] = c;\n+            c = *cur++;\n@@ -3113,4 +3109,6 @@\n-        memcpy(buffer, buf, len);\n-        while (c != 0) { \/* tested bigname2.xml *\/\n-        if (len + 10 > max) {\n-            xmlChar *tmp;\n+        if (len >= max) {\n+            \/*\n+             * Okay someone managed to make a huge name, so he's ready to pay\n+             * for the processing speed.\n+             *\/\n+            max = len * 2;\n@@ -3118,4 +3116,21 @@\n-            max *= 2;\n-            tmp = (xmlChar *) xmlRealloc(buffer, max);\n-            if (tmp == NULL) {\n-            xmlErrMemory(ctxt);\n+            buffer = xmlMalloc(max);\n+            if (buffer == NULL) {\n+                xmlErrMemory(ctxt);\n+                xmlFree(prefix);\n+                return(NULL);\n+            }\n+            memcpy(buffer, buf, len);\n+            while (c != 0) { \/* tested bigname2.xml *\/\n+                if (len + 10 > max) {\n+                    xmlChar *tmp;\n+                    int newSize;\n+\n+                    newSize = xmlGrowCapacity(max, 1, 1, XML_MAX_ITEMS);\n+                    if (newSize < 0) {\n+                        xmlErrMemory(ctxt);\n+                        xmlFree(buffer);\n+                        return(NULL);\n+                    }\n+                    tmp = xmlRealloc(buffer, newSize);\n+                    if (tmp == NULL) {\n+                        xmlErrMemory(ctxt);\n@@ -3123,2 +3138,8 @@\n-            xmlFree(buffer);\n-            return(NULL);\n+                        xmlFree(buffer);\n+                        return(NULL);\n+                    }\n+                    buffer = tmp;\n+                    max = newSize;\n+                }\n+                buffer[len++] = c;\n+                c = *cur++;\n@@ -3126,4 +3147,1 @@\n-            buffer = tmp;\n-        }\n-        buffer[len++] = c;\n-        c = *cur++;\n+            buffer[len] = 0;\n@@ -3131,2 +3149,0 @@\n-        buffer[len] = 0;\n-    }\n@@ -3134,2 +3150,2 @@\n-    if (buffer == NULL) {\n-        ret = xmlStrndup(buf, len);\n+        if (buffer == NULL) {\n+            ret = xmlStrndup(buf, len);\n@@ -3140,3 +3156,3 @@\n-    } else {\n-        ret = buffer;\n-    }\n+        } else {\n+            ret = buffer;\n+        }\n@@ -3151,4 +3167,4 @@\n- *                                    *\n- *            The parser itself                *\n- *    Relates to http:\/\/www.w3.org\/TR\/REC-xml                *\n- *                                    *\n+ *                                                                      *\n+ *                      The parser itself                               *\n+ *      Relates to http:\/\/www.w3.org\/TR\/REC-xml                         *\n+ *                                                                      *\n@@ -3158,3 +3174,3 @@\n- *                                    *\n- *    Routines to parse Name, NCName and NmToken            *\n- *                                    *\n+ *                                                                      *\n+ *      Routines to parse Name, NCName and NmToken                      *\n+ *                                                                      *\n@@ -3177,20 +3193,20 @@\n-     * Use the new checks of production [4] [4a] amd [5] of the\n-     * Update 5 of XML-1.0\n-     *\/\n-    if ((c != ' ') && (c != '>') && (c != '\/') && \/* accelerators *\/\n-        (((c >= 'a') && (c <= 'z')) ||\n-         ((c >= 'A') && (c <= 'Z')) ||\n-         (c == '_') || (c == ':') ||\n-         ((c >= 0xC0) && (c <= 0xD6)) ||\n-         ((c >= 0xD8) && (c <= 0xF6)) ||\n-         ((c >= 0xF8) && (c <= 0x2FF)) ||\n-         ((c >= 0x370) && (c <= 0x37D)) ||\n-         ((c >= 0x37F) && (c <= 0x1FFF)) ||\n-         ((c >= 0x200C) && (c <= 0x200D)) ||\n-         ((c >= 0x2070) && (c <= 0x218F)) ||\n-         ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n-         ((c >= 0x3001) && (c <= 0xD7FF)) ||\n-         ((c >= 0xF900) && (c <= 0xFDCF)) ||\n-         ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n-         ((c >= 0x10000) && (c <= 0xEFFFF))))\n-        return(1);\n+         * Use the new checks of production [4] [4a] amd [5] of the\n+         * Update 5 of XML-1.0\n+         *\/\n+        if ((c != ' ') && (c != '>') && (c != '\/') && \/* accelerators *\/\n+            (((c >= 'a') && (c <= 'z')) ||\n+             ((c >= 'A') && (c <= 'Z')) ||\n+             (c == '_') || (c == ':') ||\n+             ((c >= 0xC0) && (c <= 0xD6)) ||\n+             ((c >= 0xD8) && (c <= 0xF6)) ||\n+             ((c >= 0xF8) && (c <= 0x2FF)) ||\n+             ((c >= 0x370) && (c <= 0x37D)) ||\n+             ((c >= 0x37F) && (c <= 0x1FFF)) ||\n+             ((c >= 0x200C) && (c <= 0x200D)) ||\n+             ((c >= 0x2070) && (c <= 0x218F)) ||\n+             ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n+             ((c >= 0x3001) && (c <= 0xD7FF)) ||\n+             ((c >= 0xF900) && (c <= 0xFDCF)) ||\n+             ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n+             ((c >= 0x10000) && (c <= 0xEFFFF))))\n+            return(1);\n@@ -3199,1 +3215,1 @@\n-        return(1);\n+            return(1);\n@@ -3208,24 +3224,24 @@\n-     * Use the new checks of production [4] [4a] amd [5] of the\n-     * Update 5 of XML-1.0\n-     *\/\n-    if ((c != ' ') && (c != '>') && (c != '\/') && \/* accelerators *\/\n-        (((c >= 'a') && (c <= 'z')) ||\n-         ((c >= 'A') && (c <= 'Z')) ||\n-         ((c >= '0') && (c <= '9')) || \/* !start *\/\n-         (c == '_') || (c == ':') ||\n-         (c == '-') || (c == '.') || (c == 0xB7) || \/* !start *\/\n-         ((c >= 0xC0) && (c <= 0xD6)) ||\n-         ((c >= 0xD8) && (c <= 0xF6)) ||\n-         ((c >= 0xF8) && (c <= 0x2FF)) ||\n-         ((c >= 0x300) && (c <= 0x36F)) || \/* !start *\/\n-         ((c >= 0x370) && (c <= 0x37D)) ||\n-         ((c >= 0x37F) && (c <= 0x1FFF)) ||\n-         ((c >= 0x200C) && (c <= 0x200D)) ||\n-         ((c >= 0x203F) && (c <= 0x2040)) || \/* !start *\/\n-         ((c >= 0x2070) && (c <= 0x218F)) ||\n-         ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n-         ((c >= 0x3001) && (c <= 0xD7FF)) ||\n-         ((c >= 0xF900) && (c <= 0xFDCF)) ||\n-         ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n-         ((c >= 0x10000) && (c <= 0xEFFFF))))\n-         return(1);\n+         * Use the new checks of production [4] [4a] amd [5] of the\n+         * Update 5 of XML-1.0\n+         *\/\n+        if ((c != ' ') && (c != '>') && (c != '\/') && \/* accelerators *\/\n+            (((c >= 'a') && (c <= 'z')) ||\n+             ((c >= 'A') && (c <= 'Z')) ||\n+             ((c >= '0') && (c <= '9')) || \/* !start *\/\n+             (c == '_') || (c == ':') ||\n+             (c == '-') || (c == '.') || (c == 0xB7) || \/* !start *\/\n+             ((c >= 0xC0) && (c <= 0xD6)) ||\n+             ((c >= 0xD8) && (c <= 0xF6)) ||\n+             ((c >= 0xF8) && (c <= 0x2FF)) ||\n+             ((c >= 0x300) && (c <= 0x36F)) || \/* !start *\/\n+             ((c >= 0x370) && (c <= 0x37D)) ||\n+             ((c >= 0x37F) && (c <= 0x1FFF)) ||\n+             ((c >= 0x200C) && (c <= 0x200D)) ||\n+             ((c >= 0x203F) && (c <= 0x2040)) || \/* !start *\/\n+             ((c >= 0x2070) && (c <= 0x218F)) ||\n+             ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n+             ((c >= 0x3001) && (c <= 0xD7FF)) ||\n+             ((c >= 0xF900) && (c <= 0xFDCF)) ||\n+             ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n+             ((c >= 0x10000) && (c <= 0xEFFFF))))\n+             return(1);\n@@ -3235,4 +3251,4 @@\n-        (c == '_') || (c == ':') ||\n-        (IS_COMBINING(c)) ||\n-        (IS_EXTENDER(c)))\n-        return(1);\n+            (c == '_') || (c == ':') ||\n+            (IS_COMBINING(c)) ||\n+            (IS_EXTENDER(c)))\n+            return(1);\n@@ -3255,1 +3271,1 @@\n-    c = CUR_CHAR(l);\n+    c = xmlCurrentChar(ctxt, &l);\n@@ -3258,47 +3274,22 @@\n-     * Use the new checks of production [4] [4a] amd [5] of the\n-     * Update 5 of XML-1.0\n-     *\/\n-    if ((c == ' ') || (c == '>') || (c == '\/') || \/* accelerators *\/\n-        (!(((c >= 'a') && (c <= 'z')) ||\n-           ((c >= 'A') && (c <= 'Z')) ||\n-           (c == '_') || (c == ':') ||\n-           ((c >= 0xC0) && (c <= 0xD6)) ||\n-           ((c >= 0xD8) && (c <= 0xF6)) ||\n-           ((c >= 0xF8) && (c <= 0x2FF)) ||\n-           ((c >= 0x370) && (c <= 0x37D)) ||\n-           ((c >= 0x37F) && (c <= 0x1FFF)) ||\n-           ((c >= 0x200C) && (c <= 0x200D)) ||\n-           ((c >= 0x2070) && (c <= 0x218F)) ||\n-           ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n-           ((c >= 0x3001) && (c <= 0xD7FF)) ||\n-           ((c >= 0xF900) && (c <= 0xFDCF)) ||\n-           ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n-           ((c >= 0x10000) && (c <= 0xEFFFF))))) {\n-        return(NULL);\n-    }\n-    len += l;\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n-    while ((c != ' ') && (c != '>') && (c != '\/') && \/* accelerators *\/\n-           (((c >= 'a') && (c <= 'z')) ||\n-            ((c >= 'A') && (c <= 'Z')) ||\n-            ((c >= '0') && (c <= '9')) || \/* !start *\/\n-            (c == '_') || (c == ':') ||\n-            (c == '-') || (c == '.') || (c == 0xB7) || \/* !start *\/\n-            ((c >= 0xC0) && (c <= 0xD6)) ||\n-            ((c >= 0xD8) && (c <= 0xF6)) ||\n-            ((c >= 0xF8) && (c <= 0x2FF)) ||\n-            ((c >= 0x300) && (c <= 0x36F)) || \/* !start *\/\n-            ((c >= 0x370) && (c <= 0x37D)) ||\n-            ((c >= 0x37F) && (c <= 0x1FFF)) ||\n-            ((c >= 0x200C) && (c <= 0x200D)) ||\n-            ((c >= 0x203F) && (c <= 0x2040)) || \/* !start *\/\n-            ((c >= 0x2070) && (c <= 0x218F)) ||\n-            ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n-            ((c >= 0x3001) && (c <= 0xD7FF)) ||\n-            ((c >= 0xF900) && (c <= 0xFDCF)) ||\n-            ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n-            ((c >= 0x10000) && (c <= 0xEFFFF))\n-        )) {\n-            if (len <= INT_MAX - l)\n-            len += l;\n+         * Use the new checks of production [4] [4a] amd [5] of the\n+         * Update 5 of XML-1.0\n+         *\/\n+        if ((c == ' ') || (c == '>') || (c == '\/') || \/* accelerators *\/\n+            (!(((c >= 'a') && (c <= 'z')) ||\n+               ((c >= 'A') && (c <= 'Z')) ||\n+               (c == '_') || (c == ':') ||\n+               ((c >= 0xC0) && (c <= 0xD6)) ||\n+               ((c >= 0xD8) && (c <= 0xF6)) ||\n+               ((c >= 0xF8) && (c <= 0x2FF)) ||\n+               ((c >= 0x370) && (c <= 0x37D)) ||\n+               ((c >= 0x37F) && (c <= 0x1FFF)) ||\n+               ((c >= 0x200C) && (c <= 0x200D)) ||\n+               ((c >= 0x2070) && (c <= 0x218F)) ||\n+               ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n+               ((c >= 0x3001) && (c <= 0xD7FF)) ||\n+               ((c >= 0xF900) && (c <= 0xFDCF)) ||\n+               ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n+               ((c >= 0x10000) && (c <= 0xEFFFF))))) {\n+            return(NULL);\n+        }\n+        len += l;\n@@ -3306,18 +3297,22 @@\n-        c = CUR_CHAR(l);\n-    }\n-    } else {\n-    if ((c == ' ') || (c == '>') || (c == '\/') || \/* accelerators *\/\n-        (!IS_LETTER(c) && (c != '_') &&\n-         (c != ':'))) {\n-        return(NULL);\n-    }\n-    len += l;\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n-\n-    while ((c != ' ') && (c != '>') && (c != '\/') && \/* test bigname.xml *\/\n-           ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n-        (c == '.') || (c == '-') ||\n-        (c == '_') || (c == ':') ||\n-        (IS_COMBINING(c)) ||\n-        (IS_EXTENDER(c)))) {\n+        c = xmlCurrentChar(ctxt, &l);\n+        while ((c != ' ') && (c != '>') && (c != '\/') && \/* accelerators *\/\n+               (((c >= 'a') && (c <= 'z')) ||\n+                ((c >= 'A') && (c <= 'Z')) ||\n+                ((c >= '0') && (c <= '9')) || \/* !start *\/\n+                (c == '_') || (c == ':') ||\n+                (c == '-') || (c == '.') || (c == 0xB7) || \/* !start *\/\n+                ((c >= 0xC0) && (c <= 0xD6)) ||\n+                ((c >= 0xD8) && (c <= 0xF6)) ||\n+                ((c >= 0xF8) && (c <= 0x2FF)) ||\n+                ((c >= 0x300) && (c <= 0x36F)) || \/* !start *\/\n+                ((c >= 0x370) && (c <= 0x37D)) ||\n+                ((c >= 0x37F) && (c <= 0x1FFF)) ||\n+                ((c >= 0x200C) && (c <= 0x200D)) ||\n+                ((c >= 0x203F) && (c <= 0x2040)) || \/* !start *\/\n+                ((c >= 0x2070) && (c <= 0x218F)) ||\n+                ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n+                ((c >= 0x3001) && (c <= 0xD7FF)) ||\n+                ((c >= 0xF900) && (c <= 0xFDCF)) ||\n+                ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n+                ((c >= 0x10000) && (c <= 0xEFFFF))\n+                )) {\n@@ -3325,1 +3320,11 @@\n-            len += l;\n+                len += l;\n+            NEXTL(l);\n+            c = xmlCurrentChar(ctxt, &l);\n+        }\n+    } else {\n+        if ((c == ' ') || (c == '>') || (c == '\/') || \/* accelerators *\/\n+            (!IS_LETTER(c) && (c != '_') &&\n+             (c != ':'))) {\n+            return(NULL);\n+        }\n+        len += l;\n@@ -3327,2 +3332,13 @@\n-        c = CUR_CHAR(l);\n-    }\n+        c = xmlCurrentChar(ctxt, &l);\n+\n+        while ((c != ' ') && (c != '>') && (c != '\/') && \/* test bigname.xml *\/\n+               ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n+                (c == '.') || (c == '-') ||\n+                (c == '_') || (c == ':') ||\n+                (IS_COMBINING(c)) ||\n+                (IS_EXTENDER(c)))) {\n+            if (len <= INT_MAX - l)\n+                len += l;\n+            NEXTL(l);\n+            c = xmlCurrentChar(ctxt, &l);\n+        }\n@@ -3387,8 +3403,2 @@\n-    ((*in >= 0x41) && (*in <= 0x5A)) ||\n-    (*in == '_') || (*in == ':')) {\n-    in++;\n-    while (((*in >= 0x61) && (*in <= 0x7A)) ||\n-           ((*in >= 0x41) && (*in <= 0x5A)) ||\n-           ((*in >= 0x30) && (*in <= 0x39)) ||\n-           (*in == '_') || (*in == '-') ||\n-           (*in == ':') || (*in == '.'))\n+        ((*in >= 0x41) && (*in <= 0x5A)) ||\n+        (*in == '_') || (*in == ':')) {\n@@ -3396,2 +3406,8 @@\n-    if ((*in > 0) && (*in < 0x80)) {\n-        count = in - ctxt->input->cur;\n+        while (((*in >= 0x61) && (*in <= 0x7A)) ||\n+               ((*in >= 0x41) && (*in <= 0x5A)) ||\n+               ((*in >= 0x30) && (*in <= 0x39)) ||\n+               (*in == '_') || (*in == '-') ||\n+               (*in == ':') || (*in == '.'))\n+            in++;\n+        if ((*in > 0) && (*in < 0x80)) {\n+            count = in - ctxt->input->cur;\n@@ -3402,7 +3418,7 @@\n-        ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);\n-        ctxt->input->cur = in;\n-        ctxt->input->col += count;\n-        if (ret == NULL)\n-            xmlErrMemory(ctxt);\n-        return(ret);\n-    }\n+            ret = xmlDictLookup(ctxt->dict, ctxt->input->cur, count);\n+            ctxt->input->cur = in;\n+            ctxt->input->col += count;\n+            if (ret == NULL)\n+                xmlErrMemory(ctxt);\n+            return(ret);\n+        }\n@@ -3431,1 +3447,1 @@\n-    c = CUR_CHAR(l);\n+    c = xmlCurrentChar(ctxt, &l);\n@@ -3433,2 +3449,2 @@\n-    (!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {\n-    return(ret);\n+        (!xmlIsNameStartChar(ctxt, c) || (c == ':'))) {\n+        return(ret);\n@@ -3438,1 +3454,1 @@\n-       (xmlIsNameChar(ctxt, c) && (c != ':'))) {\n+           (xmlIsNameChar(ctxt, c) && (c != ':'))) {\n@@ -3440,3 +3456,3 @@\n-        len += l;\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n+            len += l;\n+        NEXTL(l);\n+        c = xmlCurrentChar(ctxt, &l);\n@@ -3486,8 +3502,2 @@\n-     ((*in >= 0x41) && (*in <= 0x5A)) ||\n-     (*in == '_')) && (in < e)) {\n-    in++;\n-    while ((((*in >= 0x61) && (*in <= 0x7A)) ||\n-            ((*in >= 0x41) && (*in <= 0x5A)) ||\n-            ((*in >= 0x30) && (*in <= 0x39)) ||\n-            (*in == '_') || (*in == '-') ||\n-            (*in == '.')) && (in < e))\n+         ((*in >= 0x41) && (*in <= 0x5A)) ||\n+         (*in == '_')) && (in < e)) {\n@@ -3495,4 +3505,10 @@\n-    if (in >= e)\n-        goto complex;\n-    if ((*in > 0) && (*in < 0x80)) {\n-        count = in - ctxt->input->cur;\n+        while ((((*in >= 0x61) && (*in <= 0x7A)) ||\n+                ((*in >= 0x41) && (*in <= 0x5A)) ||\n+                ((*in >= 0x30) && (*in <= 0x39)) ||\n+                (*in == '_') || (*in == '-') ||\n+                (*in == '.')) && (in < e))\n+            in++;\n+        if (in >= e)\n+            goto complex;\n+        if ((*in > 0) && (*in < 0x80)) {\n+            count = in - ctxt->input->cur;\n@@ -3503,5 +3519,7 @@\n-        ret = xmlDictLookupHashed(ctxt->dict, ctxt->input->cur, count);\n-        ctxt->input->cur = in;\n-        ctxt->input->col += count;\n-        if (ret.name == NULL) {\n-            xmlErrMemory(ctxt);\n+            ret = xmlDictLookupHashed(ctxt->dict, ctxt->input->cur, count);\n+            ctxt->input->cur = in;\n+            ctxt->input->col += count;\n+            if (ret.name == NULL) {\n+                xmlErrMemory(ctxt);\n+            }\n+            return(ret);\n@@ -3509,2 +3527,0 @@\n-        return(ret);\n-    }\n@@ -3537,2 +3553,2 @@\n-    ++in;\n-    ++cmp;\n+        ++in;\n+        ++cmp;\n@@ -3541,4 +3557,4 @@\n-    \/* success *\/\n-    ctxt->input->col += in - ctxt->input->cur;\n-    ctxt->input->cur = in;\n-    return (const xmlChar*) 1;\n+        \/* success *\/\n+        ctxt->input->col += in - ctxt->input->cur;\n+        ctxt->input->cur = in;\n+        return (const xmlChar*) 1;\n@@ -3550,1 +3566,1 @@\n-    return (const xmlChar*) 1;\n+        return (const xmlChar*) 1;\n@@ -3586,1 +3602,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3593,31 +3609,1 @@\n-    COPY_BUF(buf, len, c);\n-    cur += l;\n-    c = CUR_SCHAR(cur, l);\n-    if (len >= XML_MAX_NAMELEN) { \/* test bigentname.xml *\/\n-        \/*\n-         * Okay someone managed to make a huge name, so he's ready to pay\n-         * for the processing speed.\n-         *\/\n-        xmlChar *buffer;\n-        int max = len * 2;\n-\n-        buffer = (xmlChar *) xmlMallocAtomic(max);\n-        if (buffer == NULL) {\n-            xmlErrMemory(ctxt);\n-        return(NULL);\n-        }\n-        memcpy(buffer, buf, len);\n-        while (xmlIsNameChar(ctxt, c)) {\n-        if (len + 10 > max) {\n-            xmlChar *tmp;\n-\n-            max *= 2;\n-            tmp = (xmlChar *) xmlRealloc(buffer, max);\n-            if (tmp == NULL) {\n-            xmlErrMemory(ctxt);\n-            xmlFree(buffer);\n-            return(NULL);\n-            }\n-            buffer = tmp;\n-        }\n-        COPY_BUF(buffer, len, c);\n+        COPY_BUF(buf, len, c);\n@@ -3626,4 +3612,33 @@\n-                if (len > maxLength) {\n-                    xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"NCName\");\n-                    xmlFree(buffer);\n-                    return(NULL);\n+        if (len >= XML_MAX_NAMELEN) { \/* test bigentname.xml *\/\n+            \/*\n+             * Okay someone managed to make a huge name, so he's ready to pay\n+             * for the processing speed.\n+             *\/\n+            xmlChar *buffer;\n+            int max = len * 2;\n+\n+            buffer = xmlMalloc(max);\n+            if (buffer == NULL) {\n+                xmlErrMemory(ctxt);\n+                return(NULL);\n+            }\n+            memcpy(buffer, buf, len);\n+            while (xmlIsNameChar(ctxt, c)) {\n+                if (len + 10 > max) {\n+                    xmlChar *tmp;\n+                    int newSize;\n+\n+                    newSize = xmlGrowCapacity(max, 1, 1, maxLength);\n+                    if (newSize < 0) {\n+                        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"NCName\");\n+                        xmlFree(buffer);\n+                        return(NULL);\n+                    }\n+                    tmp = xmlRealloc(buffer, newSize);\n+                    if (tmp == NULL) {\n+                        xmlErrMemory(ctxt);\n+                        xmlFree(buffer);\n+                        return(NULL);\n+                    }\n+                    buffer = tmp;\n+                    max = newSize;\n@@ -3631,0 +3646,7 @@\n+                COPY_BUF(buffer, len, c);\n+                cur += l;\n+                c = CUR_SCHAR(cur, l);\n+            }\n+            buffer[len] = 0;\n+            *str = cur;\n+            return(buffer);\n@@ -3632,4 +3654,0 @@\n-        buffer[len] = 0;\n-        *str = cur;\n-        return(buffer);\n-    }\n@@ -3673,1 +3691,1 @@\n-    c = CUR_CHAR(l);\n+    c = xmlCurrentChar(ctxt, &l);\n@@ -3676,20 +3694,10 @@\n-    COPY_BUF(buf, len, c);\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n-    if (len >= XML_MAX_NAMELEN) {\n-        \/*\n-         * Okay someone managed to make a huge token, so he's ready to pay\n-         * for the processing speed.\n-         *\/\n-        xmlChar *buffer;\n-        int max = len * 2;\n-\n-        buffer = (xmlChar *) xmlMallocAtomic(max);\n-        if (buffer == NULL) {\n-            xmlErrMemory(ctxt);\n-        return(NULL);\n-        }\n-        memcpy(buffer, buf, len);\n-        while (xmlIsNameChar(ctxt, c)) {\n-        if (len + 10 > max) {\n-            xmlChar *tmp;\n+        COPY_BUF(buf, len, c);\n+        NEXTL(l);\n+        c = xmlCurrentChar(ctxt, &l);\n+        if (len >= XML_MAX_NAMELEN) {\n+            \/*\n+             * Okay someone managed to make a huge token, so he's ready to pay\n+             * for the processing speed.\n+             *\/\n+            xmlChar *buffer;\n+            int max = len * 2;\n@@ -3697,6 +3705,4 @@\n-            max *= 2;\n-            tmp = (xmlChar *) xmlRealloc(buffer, max);\n-            if (tmp == NULL) {\n-            xmlErrMemory(ctxt);\n-            xmlFree(buffer);\n-            return(NULL);\n+            buffer = xmlMalloc(max);\n+            if (buffer == NULL) {\n+                xmlErrMemory(ctxt);\n+                return(NULL);\n@@ -3704,7 +3710,20 @@\n-            buffer = tmp;\n-        }\n-        COPY_BUF(buffer, len, c);\n-                if (len > maxLength) {\n-                    xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"NmToken\");\n-                    xmlFree(buffer);\n-                    return(NULL);\n+            memcpy(buffer, buf, len);\n+            while (xmlIsNameChar(ctxt, c)) {\n+                if (len + 10 > max) {\n+                    xmlChar *tmp;\n+                    int newSize;\n+\n+                    newSize = xmlGrowCapacity(max, 1, 1, maxLength);\n+                    if (newSize < 0) {\n+                        xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"NmToken\");\n+                        xmlFree(buffer);\n+                        return(NULL);\n+                    }\n+                    tmp = xmlRealloc(buffer, newSize);\n+                    if (tmp == NULL) {\n+                        xmlErrMemory(ctxt);\n+                        xmlFree(buffer);\n+                        return(NULL);\n+                    }\n+                    buffer = tmp;\n+                    max = newSize;\n@@ -3712,2 +3731,6 @@\n-        NEXTL(l);\n-        c = CUR_CHAR(l);\n+                COPY_BUF(buffer, len, c);\n+                NEXTL(l);\n+                c = xmlCurrentChar(ctxt, &l);\n+            }\n+            buffer[len] = 0;\n+            return(buffer);\n@@ -3715,3 +3738,0 @@\n-        buffer[len] = 0;\n-        return(buffer);\n-    }\n@@ -3753,1 +3773,1 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_RESOURCE_LIMIT,\n+        xmlFatalErrMsg(ctxt, XML_ERR_RESOURCE_LIMIT,\n@@ -3755,1 +3775,1 @@\n-    return;\n+        return;\n@@ -3878,2 +3898,0 @@\n-\n-    return;\n@@ -3892,1 +3910,1 @@\n- *                   \"'\" ([^%&'] | PEReference | Reference)* \"'\"\n+ *                     \"'\" ([^%&'] | PEReference | Reference)* \"'\"\n@@ -3911,2 +3929,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n@@ -3988,1 +4006,1 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_RESOURCE_LIMIT,\n+        xmlFatalErrMsg(ctxt, XML_ERR_RESOURCE_LIMIT,\n@@ -3990,1 +4008,1 @@\n-    return;\n+        return;\n@@ -4022,1 +4040,1 @@\n-    if (c != '&') {\n+        if (c != '&') {\n@@ -4035,2 +4053,2 @@\n-        val = xmlParseStringCharRef(ctxt, &str);\n-        if (val == 0) {\n+            val = xmlParseStringCharRef(ctxt, &str);\n+            if (val == 0) {\n@@ -4040,1 +4058,1 @@\n-    } else {\n+        } else {\n@@ -4044,2 +4062,2 @@\n-        name = xmlParseStringEntityRef(ctxt, &str);\n-        if (name == NULL) {\n+            name = xmlParseStringEntityRef(ctxt, &str);\n+            if (name == NULL) {\n@@ -4100,1 +4118,1 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_RESOURCE_LIMIT,\n+        xmlFatalErrMsg(ctxt, XML_ERR_RESOURCE_LIMIT,\n@@ -4102,1 +4120,1 @@\n-    return;\n+        return;\n@@ -4127,1 +4145,1 @@\n-    if (c != '&') {\n+        if (c != '&') {\n@@ -4176,2 +4194,2 @@\n-        val = xmlParseStringCharRef(ctxt, &str);\n-        if (val == 0) {\n+            val = xmlParseStringCharRef(ctxt, &str);\n+            if (val == 0) {\n@@ -4191,1 +4209,1 @@\n-    } else {\n+        } else {\n@@ -4200,1 +4218,1 @@\n-        name = xmlParseStringEntityRef(ctxt, &str);\n+            name = xmlParseStringEntityRef(ctxt, &str);\n@@ -4210,5 +4228,5 @@\n-        if ((ent != NULL) &&\n-        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n-        if (ent->content == NULL) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n-                \"predefined entity has no content\\n\");\n+            if ((ent != NULL) &&\n+                (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                if (ent->content == NULL) {\n+                    xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,\n+                            \"predefined entity has no content\\n\");\n@@ -4221,1 +4239,1 @@\n-        } else if ((ent != NULL) && (ent->content != NULL)) {\n+            } else if ((ent != NULL) && (ent->content != NULL)) {\n@@ -4224,1 +4242,1 @@\n-        xmlExpandEntityInAttValue(ctxt, buf, ent->content, ent,\n+                xmlExpandEntityInAttValue(ctxt, buf, ent->content, ent,\n@@ -4228,1 +4246,1 @@\n-        }\n+            }\n@@ -4234,2 +4252,0 @@\n-\n-    return;\n@@ -4323,2 +4339,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);\n+        return(NULL);\n@@ -4430,2 +4446,2 @@\n-                 * The reparsing will be done in xmlStringGetNodeList()\n-                 * called by the attribute() function in SAX.c\n+                 * The reparsing will be done in xmlNodeParseContent()\n+                 * called from SAX2.c\n@@ -4493,1 +4509,1 @@\n-    }\n+        }\n@@ -4601,1 +4617,1 @@\n-    stop = '\"';\n+        stop = '\"';\n@@ -4604,1 +4620,1 @@\n-    stop = '\\'';\n+        stop = '\\'';\n@@ -4606,2 +4622,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);\n+        return(NULL);\n@@ -4610,1 +4626,1 @@\n-    buf = (xmlChar *) xmlMallocAtomic(size);\n+    buf = xmlMalloc(size);\n@@ -4613,1 +4629,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4615,1 +4631,1 @@\n-    cur = CUR_CHAR(l);\n+    cur = xmlCurrentCharRecover(ctxt, &l);\n@@ -4617,2 +4633,3 @@\n-    if (len + 5 >= size) {\n-        xmlChar *tmp;\n+        if (len + 5 >= size) {\n+            xmlChar *tmp;\n+            int newSize;\n@@ -4620,14 +4637,14 @@\n-        size *= 2;\n-        tmp = (xmlChar *) xmlRealloc(buf, size);\n-        if (tmp == NULL) {\n-            xmlFree(buf);\n-        xmlErrMemory(ctxt);\n-        return(NULL);\n-        }\n-        buf = tmp;\n-    }\n-    COPY_BUF(buf, len, cur);\n-        if (len > maxLength) {\n-            xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"SystemLiteral\");\n-            xmlFree(buf);\n-            return(NULL);\n+            newSize = xmlGrowCapacity(size, 1, 1, maxLength);\n+            if (newSize < 0) {\n+                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"SystemLiteral\");\n+                xmlFree(buf);\n+                return(NULL);\n+            }\n+            tmp = xmlRealloc(buf, newSize);\n+            if (tmp == NULL) {\n+                xmlFree(buf);\n+                xmlErrMemory(ctxt);\n+                return(NULL);\n+            }\n+            buf = tmp;\n+            size = newSize;\n@@ -4635,2 +4652,3 @@\n-    NEXTL(l);\n-    cur = CUR_CHAR(l);\n+        COPY_BUF(buf, len, cur);\n+        NEXTL(l);\n+        cur = xmlCurrentCharRecover(ctxt, &l);\n@@ -4640,1 +4658,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);\n@@ -4642,1 +4660,1 @@\n-    NEXT;\n+        NEXT;\n@@ -4673,1 +4691,1 @@\n-    stop = '\"';\n+        stop = '\"';\n@@ -4676,1 +4694,1 @@\n-    stop = '\\'';\n+        stop = '\\'';\n@@ -4678,2 +4696,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_STARTED, NULL);\n+        return(NULL);\n@@ -4681,1 +4699,1 @@\n-    buf = (xmlChar *) xmlMallocAtomic(size);\n+    buf = xmlMalloc(size);\n@@ -4683,2 +4701,2 @@\n-    xmlErrMemory(ctxt);\n-    return(NULL);\n+        xmlErrMemory(ctxt);\n+        return(NULL);\n@@ -4689,2 +4707,3 @@\n-    if (len + 1 >= size) {\n-        xmlChar *tmp;\n+        if (len + 1 >= size) {\n+            xmlChar *tmp;\n+            int newSize;\n@@ -4692,14 +4711,14 @@\n-        size *= 2;\n-        tmp = (xmlChar *) xmlRealloc(buf, size);\n-        if (tmp == NULL) {\n-        xmlErrMemory(ctxt);\n-        xmlFree(buf);\n-        return(NULL);\n-        }\n-        buf = tmp;\n-    }\n-    buf[len++] = cur;\n-        if (len > maxLength) {\n-            xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"Public ID\");\n-            xmlFree(buf);\n-            return(NULL);\n+            newSize = xmlGrowCapacity(size, 1, 1, maxLength);\n+            if (newSize < 0) {\n+                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"Public ID\");\n+                xmlFree(buf);\n+                return(NULL);\n+            }\n+            tmp = xmlRealloc(buf, newSize);\n+            if (tmp == NULL) {\n+                xmlErrMemory(ctxt);\n+                xmlFree(buf);\n+                return(NULL);\n+            }\n+            buf = tmp;\n+            size = newSize;\n@@ -4707,2 +4726,3 @@\n-    NEXT;\n-    cur = CUR;\n+        buf[len++] = cur;\n+        NEXT;\n+        cur = CUR;\n@@ -4712,1 +4732,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_LITERAL_NOT_FINISHED, NULL);\n@@ -4714,1 +4734,1 @@\n-    NEXTL(1);\n+        NEXTL(1);\n@@ -4759,0 +4779,34 @@\n+static void\n+xmlCharacters(xmlParserCtxtPtr ctxt, const xmlChar *buf, int size,\n+              int isBlank) {\n+    int checkBlanks;\n+\n+    if ((ctxt->sax == NULL) || (ctxt->disableSAX))\n+        return;\n+\n+    checkBlanks = (!ctxt->keepBlanks) ||\n+                  (ctxt->sax->ignorableWhitespace != ctxt->sax->characters);\n+\n+    \/*\n+     * Calling areBlanks with only parts of a text node\n+     * is fundamentally broken, making the NOBLANKS option\n+     * essentially unusable.\n+     *\/\n+    if ((checkBlanks) &&\n+        (areBlanks(ctxt, buf, size, isBlank))) {\n+        if ((ctxt->sax->ignorableWhitespace != NULL) &&\n+            (ctxt->keepBlanks))\n+            ctxt->sax->ignorableWhitespace(ctxt->userData, buf, size);\n+    } else {\n+        if (ctxt->sax->characters != NULL)\n+            ctxt->sax->characters(ctxt->userData, buf, size);\n+\n+        \/*\n+         * The old code used to update this value for \"complex\" data\n+         * even if checkBlanks was false. This was probably a bug.\n+         *\/\n+        if ((checkBlanks) && (*ctxt->space == -1))\n+            *ctxt->space = -2;\n+    }\n+}\n+\n@@ -4804,21 +4858,1 @@\n-                if ((ctxt->sax != NULL) &&\n-                    (ctxt->disableSAX == 0) &&\n-                    (ctxt->sax->ignorableWhitespace !=\n-                     ctxt->sax->characters)) {\n-                    if (areBlanks(ctxt, tmp, nbchar, 1)) {\n-                        if (ctxt->sax->ignorableWhitespace != NULL)\n-                            ctxt->sax->ignorableWhitespace(ctxt->userData,\n-                                                   tmp, nbchar);\n-                    } else {\n-                        if (ctxt->sax->characters != NULL)\n-                            ctxt->sax->characters(ctxt->userData,\n-                                                  tmp, nbchar);\n-                        if (*ctxt->space == -1)\n-                            *ctxt->space = -2;\n-                    }\n-                } else if ((ctxt->sax != NULL) &&\n-                           (ctxt->disableSAX == 0) &&\n-                           (ctxt->sax->characters != NULL)) {\n-                    ctxt->sax->characters(ctxt->userData,\n-                                          tmp, nbchar);\n-                }\n+                xmlCharacters(ctxt, tmp, nbchar, 1);\n@@ -4849,3 +4883,5 @@\n-            in++;\n-            ctxt->input->col++;\n-            goto get_more;\n+            if ((!partial) || (ctxt->input->end - in >= 2)) {\n+                in++;\n+                ctxt->input->col++;\n+                goto get_more;\n+            }\n@@ -4855,7 +4891,2 @@\n-            if ((ctxt->sax != NULL) &&\n-                (ctxt->disableSAX == 0) &&\n-                (ctxt->sax->ignorableWhitespace !=\n-                 ctxt->sax->characters) &&\n-                (IS_BLANK_CH(*ctxt->input->cur))) {\n-                const xmlChar *tmp = ctxt->input->cur;\n-                ctxt->input->cur = in;\n+            const xmlChar *tmp = ctxt->input->cur;\n+            ctxt->input->cur = in;\n@@ -4863,21 +4894,4 @@\n-                if (areBlanks(ctxt, tmp, nbchar, 0)) {\n-                    if (ctxt->sax->ignorableWhitespace != NULL)\n-                        ctxt->sax->ignorableWhitespace(ctxt->userData,\n-                                                       tmp, nbchar);\n-                } else {\n-                    if (ctxt->sax->characters != NULL)\n-                        ctxt->sax->characters(ctxt->userData,\n-                                              tmp, nbchar);\n-                    if (*ctxt->space == -1)\n-                        *ctxt->space = -2;\n-                }\n-                line = ctxt->input->line;\n-                col = ctxt->input->col;\n-            } else if ((ctxt->sax != NULL) &&\n-                       (ctxt->disableSAX == 0)) {\n-                if (ctxt->sax->characters != NULL)\n-                    ctxt->sax->characters(ctxt->userData,\n-                                          ctxt->input->cur, nbchar);\n-                line = ctxt->input->line;\n-                col = ctxt->input->col;\n-            }\n+            xmlCharacters(ctxt, tmp, nbchar, 0);\n+\n+            line = ctxt->input->line;\n+            col = ctxt->input->col;\n@@ -4902,0 +4916,3 @@\n+        if ((partial) && (*in == ']') && (ctxt->input->end - in < 2)) {\n+            return;\n+        }\n@@ -4929,1 +4946,1 @@\n-    cur = CUR_CHAR(l);\n+    cur = xmlCurrentCharRecover(ctxt, &l);\n@@ -4932,9 +4949,11 @@\n-       (IS_CHAR(cur))) {\n-    if ((cur == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {\n-        xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);\n-    }\n-    COPY_BUF(buf, nbchar, cur);\n-    \/* move current position before possible calling of ctxt->sax->characters *\/\n-    NEXTL(l);\n-    if (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) {\n-        buf[nbchar] = 0;\n+           ((!partial) || (cur != ']') ||\n+            (ctxt->input->end - ctxt->input->cur >= 2)) &&\n+           (IS_CHAR(cur))) {\n+        if ((cur == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {\n+            xmlFatalErr(ctxt, XML_ERR_MISPLACED_CDATA_END, NULL);\n+        }\n+        COPY_BUF(buf, nbchar, cur);\n+        \/* move current position before possible calling of ctxt->sax->characters *\/\n+        NEXTL(l);\n+        if (nbchar >= XML_PARSER_BIG_BUFFER_SIZE) {\n+            buf[nbchar] = 0;\n@@ -4942,18 +4961,2 @@\n-        \/*\n-         * OK the segment is to be consumed as chars.\n-         *\/\n-        if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n-        if (areBlanks(ctxt, buf, nbchar, 0)) {\n-            if (ctxt->sax->ignorableWhitespace != NULL)\n-            ctxt->sax->ignorableWhitespace(ctxt->userData,\n-                                           buf, nbchar);\n-        } else {\n-            if (ctxt->sax->characters != NULL)\n-            ctxt->sax->characters(ctxt->userData, buf, nbchar);\n-            if ((ctxt->sax->characters !=\n-                 ctxt->sax->ignorableWhitespace) &&\n-            (*ctxt->space == -1))\n-            *ctxt->space = -2;\n-        }\n-        }\n-        nbchar = 0;\n+            xmlCharacters(ctxt, buf, nbchar, 0);\n+            nbchar = 0;\n@@ -4961,2 +4964,2 @@\n-    }\n-    cur = CUR_CHAR(l);\n+        }\n+        cur = xmlCurrentCharRecover(ctxt, &l);\n@@ -4966,15 +4969,2 @@\n-    \/*\n-     * OK the segment is to be consumed as chars.\n-     *\/\n-    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n-        if (areBlanks(ctxt, buf, nbchar, 0)) {\n-        if (ctxt->sax->ignorableWhitespace != NULL)\n-            ctxt->sax->ignorableWhitespace(ctxt->userData, buf, nbchar);\n-        } else {\n-        if (ctxt->sax->characters != NULL)\n-            ctxt->sax->characters(ctxt->userData, buf, nbchar);\n-        if ((ctxt->sax->characters != ctxt->sax->ignorableWhitespace) &&\n-            (*ctxt->space == -1))\n-            *ctxt->space = -2;\n-        }\n-    }\n+\n+        xmlCharacters(ctxt, buf, nbchar, 0);\n@@ -4996,1 +4986,1 @@\n-        } else if ((cur != '<') && (cur != '&')) {\n+        } else if ((cur != '<') && (cur != '&') && (cur != ']')) {\n@@ -5048,7 +5038,7 @@\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                       \"Space required after 'SYSTEM'\\n\");\n-    }\n-    URI = xmlParseSystemLiteral(ctxt);\n-    if (URI == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after 'SYSTEM'\\n\");\n+        }\n+        URI = xmlParseSystemLiteral(ctxt);\n+        if (URI == NULL) {\n+            xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);\n@@ -5058,12 +5048,0 @@\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-            \"Space required after 'PUBLIC'\\n\");\n-    }\n-    *publicID = xmlParsePubidLiteral(ctxt);\n-    if (*publicID == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED, NULL);\n-    }\n-    if (strict) {\n-        \/*\n-         * We don't handle [83] so \"S SystemLiteral\" is required.\n-         *\/\n@@ -5071,2 +5049,2 @@\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-            \"Space required after the Public Identifier\\n\");\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                    \"Space required after 'PUBLIC'\\n\");\n@@ -5074,4 +5052,16 @@\n-    } else {\n-        \/*\n-         * We handle [83] so we return immediately, if\n-         * \"S SystemLiteral\" is not detected. We skip blanks if no\n+        *publicID = xmlParsePubidLiteral(ctxt);\n+        if (*publicID == NULL) {\n+            xmlFatalErr(ctxt, XML_ERR_PUBID_REQUIRED, NULL);\n+        }\n+        if (strict) {\n+            \/*\n+             * We don't handle [83] so \"S SystemLiteral\" is required.\n+             *\/\n+            if (SKIP_BLANKS == 0) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                        \"Space required after the Public Identifier\\n\");\n+            }\n+        } else {\n+            \/*\n+             * We handle [83] so we return immediately, if\n+             * \"S SystemLiteral\" is not detected. We skip blanks if no\n@@ -5080,7 +5070,7 @@\n-         *\/\n-        if (SKIP_BLANKS == 0) return(NULL);\n-        if ((CUR != '\\'') && (CUR != '\"')) return(NULL);\n-    }\n-    URI = xmlParseSystemLiteral(ctxt);\n-    if (URI == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);\n+             *\/\n+            if (SKIP_BLANKS == 0) return(NULL);\n+            if ((CUR != '\\'') && (CUR != '\"')) return(NULL);\n+        }\n+        URI = xmlParseSystemLiteral(ctxt);\n+        if (URI == NULL) {\n+            xmlFatalErr(ctxt, XML_ERR_URI_REQUIRED, NULL);\n@@ -5112,3 +5102,3 @@\n-    size_t maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n-                       XML_MAX_HUGE_LENGTH :\n-                       XML_MAX_TEXT_LENGTH;\n+    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n+                    XML_MAX_HUGE_LENGTH :\n+                    XML_MAX_TEXT_LENGTH;\n@@ -5118,6 +5108,6 @@\n-    size = XML_PARSER_BUFFER_SIZE;\n-    buf = (xmlChar *) xmlMallocAtomic(size);\n-    if (buf == NULL) {\n-        xmlErrMemory(ctxt);\n-        return;\n-    }\n+        size = XML_PARSER_BUFFER_SIZE;\n+        buf = xmlMalloc(size);\n+        if (buf == NULL) {\n+            xmlErrMemory(ctxt);\n+            return;\n+        }\n@@ -5125,1 +5115,1 @@\n-    q = CUR_CHAR(ql);\n+    q = xmlCurrentCharRecover(ctxt, &ql);\n@@ -5131,3 +5121,3 @@\n-                      q);\n-    xmlFree (buf);\n-    return;\n+                          q);\n+        xmlFree (buf);\n+        return;\n@@ -5136,1 +5126,1 @@\n-    r = CUR_CHAR(rl);\n+    r = xmlCurrentCharRecover(ctxt, &rl);\n@@ -5142,3 +5132,3 @@\n-                      r);\n-    xmlFree (buf);\n-    return;\n+                          r);\n+        xmlFree (buf);\n+        return;\n@@ -5147,1 +5137,1 @@\n-    cur = CUR_CHAR(l);\n+    cur = xmlCurrentCharRecover(ctxt, &l);\n@@ -5152,14 +5142,3 @@\n-        (r != '-') || (q != '-'))) {\n-    if ((r == '-') && (q == '-')) {\n-        xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);\n-    }\n-    if (len + 5 >= size) {\n-        xmlChar *new_buf;\n-            size_t new_size;\n-\n-        new_size = size * 2;\n-        new_buf = (xmlChar *) xmlRealloc(buf, new_size);\n-        if (new_buf == NULL) {\n-        xmlFree (buf);\n-        xmlErrMemory(ctxt);\n-        return;\n+            (r != '-') || (q != '-'))) {\n+        if ((r == '-') && (q == '-')) {\n+            xmlFatalErr(ctxt, XML_ERR_HYPHEN_IN_COMMENT, NULL);\n@@ -5167,9 +5146,19 @@\n-        buf = new_buf;\n-            size = new_size;\n-    }\n-    COPY_BUF(buf, len, q);\n-        if (len > maxLength) {\n-            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n-                         \"Comment too big found\", NULL);\n-            xmlFree (buf);\n-            return;\n+        if (len + 5 >= size) {\n+            xmlChar *tmp;\n+            int newSize;\n+\n+            newSize = xmlGrowCapacity(size, 1, 1, maxLength);\n+            if (newSize < 0) {\n+                xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n+                             \"Comment too big found\", NULL);\n+                xmlFree (buf);\n+                return;\n+            }\n+            tmp = xmlRealloc(buf, newSize);\n+            if (tmp == NULL) {\n+                xmlErrMemory(ctxt);\n+                xmlFree(buf);\n+                return;\n+            }\n+            buf = tmp;\n+            size = newSize;\n@@ -5177,0 +5166,1 @@\n+        COPY_BUF(buf, len, q);\n@@ -5178,4 +5168,4 @@\n-    q = r;\n-    ql = rl;\n-    r = cur;\n-    rl = l;\n+        q = r;\n+        ql = rl;\n+        r = cur;\n+        rl = l;\n@@ -5183,2 +5173,2 @@\n-    NEXTL(l);\n-    cur = CUR_CHAR(l);\n+        NEXTL(l);\n+        cur = xmlCurrentCharRecover(ctxt, &l);\n@@ -5189,2 +5179,2 @@\n-    xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n-                         \"Comment not terminated \\n<!--%.50s\\n\", buf);\n+        xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n+                             \"Comment not terminated \\n<!--%.50s\\n\", buf);\n@@ -5194,1 +5184,1 @@\n-                      cur);\n+                          cur);\n@@ -5197,3 +5187,3 @@\n-    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n-        (!ctxt->disableSAX))\n-        ctxt->sax->comment(ctxt->userData, buf);\n+        if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n+            (!ctxt->disableSAX))\n+            ctxt->sax->comment(ctxt->userData, buf);\n@@ -5205,1 +5195,1 @@\n-             \"Comment not terminated\\n\", NULL);\n+                         \"Comment not terminated\\n\", NULL);\n@@ -5207,1 +5197,0 @@\n-    return;\n@@ -5252,6 +5241,6 @@\n-    if (*in == 0xA) {\n-        do {\n-        ctxt->input->line++; ctxt->input->col = 1;\n-        in++;\n-        } while (*in == 0xA);\n-    }\n+        if (*in == 0xA) {\n+            do {\n+                ctxt->input->line++; ctxt->input->col = 1;\n+                in++;\n+            } while (*in == 0xA);\n+        }\n@@ -5260,19 +5249,25 @@\n-    while (((*in > '-') && (*in <= 0x7F)) ||\n-           ((*in >= 0x20) && (*in < '-')) ||\n-           (*in == 0x09)) {\n-            in++;\n-            ccol++;\n-    }\n-    ctxt->input->col = ccol;\n-    if (*in == 0xA) {\n-        do {\n-        ctxt->input->line++; ctxt->input->col = 1;\n-        in++;\n-        } while (*in == 0xA);\n-        goto get_more;\n-    }\n-    nbchar = in - ctxt->input->cur;\n-    \/*\n-     * save current set of data\n-     *\/\n-    if (nbchar > 0) {\n+        while (((*in > '-') && (*in <= 0x7F)) ||\n+               ((*in >= 0x20) && (*in < '-')) ||\n+               (*in == 0x09)) {\n+                    in++;\n+                    ccol++;\n+        }\n+        ctxt->input->col = ccol;\n+        if (*in == 0xA) {\n+            do {\n+                ctxt->input->line++; ctxt->input->col = 1;\n+                in++;\n+            } while (*in == 0xA);\n+            goto get_more;\n+        }\n+        nbchar = in - ctxt->input->cur;\n+        \/*\n+         * save current set of data\n+         *\/\n+        if (nbchar > 0) {\n+            if (nbchar > maxLength - len) {\n+                xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n+                                  \"Comment too big found\", NULL);\n+                xmlFree(buf);\n+                return;\n+            }\n@@ -5284,1 +5279,1 @@\n-                buf = (xmlChar *) xmlMallocAtomic(size);\n+                buf = xmlMalloc(size);\n@@ -5292,2 +5287,2 @@\n-                size  += len + nbchar + XML_PARSER_BUFFER_SIZE;\n-                new_buf = (xmlChar *) xmlRealloc(buf, size);\n+                size += len + nbchar + XML_PARSER_BUFFER_SIZE;\n+                new_buf = xmlRealloc(buf, size);\n@@ -5295,1 +5290,0 @@\n-                    xmlFree (buf);\n@@ -5297,0 +5291,1 @@\n+                    xmlFree(buf);\n@@ -5304,6 +5299,0 @@\n-    }\n-        if (len > maxLength) {\n-            xmlFatalErrMsgStr(ctxt, XML_ERR_COMMENT_NOT_FINISHED,\n-                         \"Comment too big found\", NULL);\n-            xmlFree (buf);\n-            return;\n@@ -5311,8 +5300,0 @@\n-    ctxt->input->cur = in;\n-    if (*in == 0xA) {\n-        in++;\n-        ctxt->input->line++; ctxt->input->col = 1;\n-    }\n-    if (*in == 0xD) {\n-        in++;\n-        if (*in == 0xA) {\n@@ -5320,3 +5301,3 @@\n-        in++;\n-        ctxt->input->line++; ctxt->input->col = 1;\n-        goto get_more;\n+        if (*in == 0xA) {\n+            in++;\n+            ctxt->input->line++; ctxt->input->col = 1;\n@@ -5324,15 +5305,7 @@\n-        in--;\n-    }\n-    SHRINK;\n-    GROW;\n-    in = ctxt->input->cur;\n-    if (*in == '-') {\n-        if (in[1] == '-') {\n-            if (in[2] == '>') {\n-            SKIP(3);\n-            if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n-                (!ctxt->disableSAX)) {\n-            if (buf != NULL)\n-                ctxt->sax->comment(ctxt->userData, buf);\n-            else\n-                ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n+        if (*in == 0xD) {\n+            in++;\n+            if (*in == 0xA) {\n+                ctxt->input->cur = in;\n+                in++;\n+                ctxt->input->line++; ctxt->input->col = 1;\n+                goto get_more;\n@@ -5340,3 +5313,1 @@\n-            if (buf != NULL)\n-                xmlFree(buf);\n-            return;\n+            in--;\n@@ -5344,3 +5315,21 @@\n-        if (buf != NULL) {\n-            xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n-                              \"Double hyphen within comment: \"\n+        SHRINK;\n+        GROW;\n+        in = ctxt->input->cur;\n+        if (*in == '-') {\n+            if (in[1] == '-') {\n+                if (in[2] == '>') {\n+                    SKIP(3);\n+                    if ((ctxt->sax != NULL) && (ctxt->sax->comment != NULL) &&\n+                        (!ctxt->disableSAX)) {\n+                        if (buf != NULL)\n+                            ctxt->sax->comment(ctxt->userData, buf);\n+                        else\n+                            ctxt->sax->comment(ctxt->userData, BAD_CAST \"\");\n+                    }\n+                    if (buf != NULL)\n+                        xmlFree(buf);\n+                    return;\n+                }\n+                if (buf != NULL) {\n+                    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n+                                      \"Double hyphen within comment: \"\n@@ -5348,6 +5337,10 @@\n-                      buf);\n-        } else\n-            xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n-                              \"Double hyphen within comment\\n\", NULL);\n-        in++;\n-        ctxt->input->col++;\n+                                      buf);\n+                } else\n+                    xmlFatalErrMsgStr(ctxt, XML_ERR_HYPHEN_IN_COMMENT,\n+                                      \"Double hyphen within comment\\n\", NULL);\n+                in++;\n+                ctxt->input->col++;\n+            }\n+            in++;\n+            ctxt->input->col++;\n+            goto get_more;\n@@ -5355,4 +5348,0 @@\n-        in++;\n-        ctxt->input->col++;\n-        goto get_more;\n-    }\n@@ -5361,1 +5350,0 @@\n-    return;\n@@ -5387,13 +5375,5 @@\n-    int i;\n-    if ((name[0] == 'x') && (name[1] == 'm') &&\n-        (name[2] == 'l') && (name[3] == 0)) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_RESERVED_XML_NAME,\n-         \"XML declaration allowed only at the start of the document\\n\");\n-        return(name);\n-    } else if (name[3] == 0) {\n-        xmlFatalErr(ctxt, XML_ERR_RESERVED_XML_NAME, NULL);\n-        return(name);\n-    }\n-    for (i = 0;;i++) {\n-        if (xmlW3CPIs[i] == NULL) break;\n-        if (xmlStrEqual(name, (const xmlChar *)xmlW3CPIs[i]))\n+        int i;\n+        if ((name[0] == 'x') && (name[1] == 'm') &&\n+            (name[2] == 'l') && (name[3] == 0)) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_RESERVED_XML_NAME,\n+                 \"XML declaration allowed only at the start of the document\\n\");\n@@ -5401,4 +5381,12 @@\n-    }\n-    xmlWarningMsg(ctxt, XML_ERR_RESERVED_XML_NAME,\n-              \"xmlParsePITarget: invalid name prefix 'xml'\\n\",\n-              NULL, NULL);\n+        } else if (name[3] == 0) {\n+            xmlFatalErr(ctxt, XML_ERR_RESERVED_XML_NAME, NULL);\n+            return(name);\n+        }\n+        for (i = 0;;i++) {\n+            if (xmlW3CPIs[i] == NULL) break;\n+            if (xmlStrEqual(name, (const xmlChar *)xmlW3CPIs[i]))\n+                return(name);\n+        }\n+        xmlWarningMsg(ctxt, XML_ERR_RESERVED_XML_NAME,\n+                      \"xmlParsePITarget: invalid name prefix 'xml'\\n\",\n+                      NULL, NULL);\n@@ -5407,2 +5395,2 @@\n-    xmlNsErr(ctxt, XML_NS_ERR_COLON,\n-         \"colons are forbidden from PI names '%s'\\n\", name, NULL, NULL);\n+        xmlNsErr(ctxt, XML_NS_ERR_COLON,\n+                 \"colons are forbidden from PI names '%s'\\n\", name, NULL, NULL);\n@@ -5438,1 +5426,1 @@\n-    goto error;\n+        goto error;\n@@ -5442,1 +5430,1 @@\n-    return;\n+        return;\n@@ -5448,1 +5436,1 @@\n-    goto error;\n+        goto error;\n@@ -5453,1 +5441,1 @@\n-    goto error;\n+        goto error;\n@@ -5458,1 +5446,1 @@\n-    goto error;\n+        goto error;\n@@ -5467,2 +5455,2 @@\n-    ctxt->catalogs = xmlCatalogAddLocal(ctxt->catalogs, URL);\n-    xmlFree(URL);\n+        ctxt->catalogs = xmlCatalogAddLocal(ctxt->catalogs, URL);\n+        xmlFree(URL);\n@@ -5474,2 +5462,2 @@\n-              \"Catalog PI syntax error: %s\\n\",\n-          catalog, NULL);\n+                  \"Catalog PI syntax error: %s\\n\",\n+                  catalog, NULL);\n@@ -5477,1 +5465,1 @@\n-    xmlFree(URL);\n+        xmlFree(URL);\n@@ -5506,12 +5494,3 @@\n-    \/*\n-     * this is a Processing Instruction.\n-     *\/\n-    SKIP(2);\n-\n-    \/*\n-     * Parse the target name and check for special support like\n-     * namespace.\n-     *\/\n-        target = xmlParsePITarget(ctxt);\n-    if (target != NULL) {\n-        if ((RAW == '?') && (NXT(1) == '>')) {\n+        \/*\n+         * this is a Processing Instruction.\n+         *\/\n@@ -5521,1 +5500,2 @@\n-         * SAX: PI detected.\n+         * Parse the target name and check for special support like\n+         * namespace.\n@@ -5523,26 +5503,13 @@\n-        if ((ctxt->sax) && (!ctxt->disableSAX) &&\n-            (ctxt->sax->processingInstruction != NULL))\n-            ctxt->sax->processingInstruction(ctxt->userData,\n-                                             target, NULL);\n-        return;\n-        }\n-        buf = (xmlChar *) xmlMallocAtomic(size);\n-        if (buf == NULL) {\n-        xmlErrMemory(ctxt);\n-        return;\n-        }\n-        if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,\n-              \"ParsePI: PI %s space expected\\n\", target);\n-        }\n-        cur = CUR_CHAR(l);\n-        while (IS_CHAR(cur) && \/* checked *\/\n-           ((cur != '?') || (NXT(1) != '>'))) {\n-        if (len + 5 >= size) {\n-            xmlChar *tmp;\n-                    size_t new_size = size * 2;\n-            tmp = (xmlChar *) xmlRealloc(buf, new_size);\n-            if (tmp == NULL) {\n-            xmlErrMemory(ctxt);\n-            xmlFree(buf);\n-            return;\n+        target = xmlParsePITarget(ctxt);\n+        if (target != NULL) {\n+            if ((RAW == '?') && (NXT(1) == '>')) {\n+                SKIP(2);\n+\n+                \/*\n+                 * SAX: PI detected.\n+                 *\/\n+                if ((ctxt->sax) && (!ctxt->disableSAX) &&\n+                    (ctxt->sax->processingInstruction != NULL))\n+                    ctxt->sax->processingInstruction(ctxt->userData,\n+                                                     target, NULL);\n+                return;\n@@ -5550,9 +5517,31 @@\n-            buf = tmp;\n-                    size = new_size;\n-        }\n-        COPY_BUF(buf, len, cur);\n-                if (len > maxLength) {\n-                    xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,\n-                                      \"PI %s too big found\", target);\n-                    xmlFree(buf);\n-                    return;\n+            buf = xmlMalloc(size);\n+            if (buf == NULL) {\n+                xmlErrMemory(ctxt);\n+                return;\n+            }\n+            if (SKIP_BLANKS == 0) {\n+                xmlFatalErrMsgStr(ctxt, XML_ERR_SPACE_REQUIRED,\n+                          \"ParsePI: PI %s space expected\\n\", target);\n+            }\n+            cur = xmlCurrentCharRecover(ctxt, &l);\n+            while (IS_CHAR(cur) && \/* checked *\/\n+                   ((cur != '?') || (NXT(1) != '>'))) {\n+                if (len + 5 >= size) {\n+                    xmlChar *tmp;\n+                    int newSize;\n+\n+                    newSize = xmlGrowCapacity(size, 1, 1, maxLength);\n+                    if (newSize < 0) {\n+                        xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,\n+                                          \"PI %s too big found\", target);\n+                        xmlFree(buf);\n+                        return;\n+                    }\n+                    tmp = xmlRealloc(buf, newSize);\n+                    if (tmp == NULL) {\n+                        xmlErrMemory(ctxt);\n+                        xmlFree(buf);\n+                        return;\n+                    }\n+                    buf = tmp;\n+                    size = newSize;\n@@ -5560,9 +5549,10 @@\n-        NEXTL(l);\n-        cur = CUR_CHAR(l);\n-        }\n-        buf[len] = 0;\n-        if (cur != '?') {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,\n-              \"ParsePI: PI %s never end ...\\n\", target);\n-        } else {\n-        SKIP(2);\n+                COPY_BUF(buf, len, cur);\n+                NEXTL(l);\n+                cur = xmlCurrentCharRecover(ctxt, &l);\n+            }\n+            buf[len] = 0;\n+            if (cur != '?') {\n+                xmlFatalErrMsgStr(ctxt, XML_ERR_PI_NOT_FINISHED,\n+                      \"ParsePI: PI %s never end ...\\n\", target);\n+            } else {\n+                SKIP(2);\n@@ -5571,7 +5561,9 @@\n-        if ((ctxt->inSubset == 0) &&\n-            (xmlStrEqual(target, XML_CATALOG_PI))) {\n-            xmlCatalogAllow allow = xmlCatalogGetDefaults();\n-            if ((allow == XML_CATA_ALLOW_DOCUMENT) ||\n-            (allow == XML_CATA_ALLOW_ALL))\n-            xmlParseCatalogPI(ctxt, buf);\n-        }\n+                if ((ctxt->inSubset == 0) &&\n+                    (xmlStrEqual(target, XML_CATALOG_PI))) {\n+                    xmlCatalogAllow allow = xmlCatalogGetDefaults();\n+\n+                    if ((ctxt->options & XML_PARSE_CATALOG_PI) &&\n+                        ((allow == XML_CATA_ALLOW_DOCUMENT) ||\n+                         (allow == XML_CATA_ALLOW_ALL)))\n+                        xmlParseCatalogPI(ctxt, buf);\n+                }\n@@ -5580,8 +5572,11 @@\n-\n-        \/*\n-         * SAX: PI detected.\n-         *\/\n-        if ((ctxt->sax) && (!ctxt->disableSAX) &&\n-            (ctxt->sax->processingInstruction != NULL))\n-            ctxt->sax->processingInstruction(ctxt->userData,\n-                                             target, buf);\n+                \/*\n+                 * SAX: PI detected.\n+                 *\/\n+                if ((ctxt->sax) && (!ctxt->disableSAX) &&\n+                    (ctxt->sax->processingInstruction != NULL))\n+                    ctxt->sax->processingInstruction(ctxt->userData,\n+                                                     target, buf);\n+            }\n+            xmlFree(buf);\n+        } else {\n+            xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);\n@@ -5589,4 +5584,0 @@\n-        xmlFree(buf);\n-    } else {\n-        xmlFatalErr(ctxt, XML_ERR_PI_NOT_STARTED, NULL);\n-    }\n@@ -5625,7 +5616,7 @@\n-    int inputid = ctxt->input->id;\n-    SKIP(8);\n-    if (SKIP_BLANKS_PE == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"Space required after '<!NOTATION'\\n\");\n-        return;\n-    }\n+        int inputid = ctxt->input->id;\n+        SKIP(8);\n+        if (SKIP_BLANKS_PE == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after '<!NOTATION'\\n\");\n+            return;\n+        }\n@@ -5634,14 +5625,14 @@\n-    if (name == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);\n-        return;\n-    }\n-    if (xmlStrchr(name, ':') != NULL) {\n-        xmlNsErr(ctxt, XML_NS_ERR_COLON,\n-             \"colons are forbidden from notation names '%s'\\n\",\n-             name, NULL, NULL);\n-    }\n-    if (SKIP_BLANKS_PE == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-             \"Space required after the NOTATION name'\\n\");\n-        return;\n-    }\n+        if (name == NULL) {\n+            xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);\n+            return;\n+        }\n+        if (xmlStrchr(name, ':') != NULL) {\n+            xmlNsErr(ctxt, XML_NS_ERR_COLON,\n+                     \"colons are forbidden from notation names '%s'\\n\",\n+                     name, NULL, NULL);\n+        }\n+        if (SKIP_BLANKS_PE == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                     \"Space required after the NOTATION name'\\n\");\n+            return;\n+        }\n@@ -5649,5 +5640,5 @@\n-    \/*\n-     * Parse the IDs.\n-     *\/\n-    Systemid = xmlParseExternalID(ctxt, &Pubid, 0);\n-    SKIP_BLANKS_PE;\n+        \/*\n+         * Parse the IDs.\n+         *\/\n+        Systemid = xmlParseExternalID(ctxt, &Pubid, 0);\n+        SKIP_BLANKS_PE;\n@@ -5655,4 +5646,4 @@\n-    if (RAW == '>') {\n-        if (inputid != ctxt->input->id) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n-                           \"Notation declaration doesn't start and stop\"\n+        if (RAW == '>') {\n+            if (inputid != ctxt->input->id) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+                               \"Notation declaration doesn't start and stop\"\n@@ -5660,0 +5651,7 @@\n+            }\n+            NEXT;\n+            if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                (ctxt->sax->notationDecl != NULL))\n+                ctxt->sax->notationDecl(ctxt->userData, name, Pubid, Systemid);\n+        } else {\n+            xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);\n@@ -5661,9 +5659,2 @@\n-        NEXT;\n-        if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-        (ctxt->sax->notationDecl != NULL))\n-        ctxt->sax->notationDecl(ctxt->userData, name, Pubid, Systemid);\n-    } else {\n-        xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);\n-    }\n-    if (Systemid != NULL) xmlFree(Systemid);\n-    if (Pubid != NULL) xmlFree(Pubid);\n+        if (Systemid != NULL) xmlFree(Systemid);\n+        if (Pubid != NULL) xmlFree(Pubid);\n@@ -5712,9 +5703,2 @@\n-    int inputid = ctxt->input->id;\n-    SKIP(6);\n-    if (SKIP_BLANKS_PE == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"Space required after '<!ENTITY'\\n\");\n-    }\n-\n-    if (RAW == '%') {\n-        NEXT;\n+        int inputid = ctxt->input->id;\n+        SKIP(6);\n@@ -5722,2 +5706,11 @@\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                   \"Space required after '%%'\\n\");\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after '<!ENTITY'\\n\");\n+        }\n+\n+        if (RAW == '%') {\n+            NEXT;\n+            if (SKIP_BLANKS_PE == 0) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                               \"Space required after '%%'\\n\");\n+            }\n+            isParameter = 1;\n@@ -5725,2 +5718,0 @@\n-        isParameter = 1;\n-    }\n@@ -5729,3 +5720,3 @@\n-    if (name == NULL) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-                       \"xmlParseEntityDecl: no name\\n\");\n+        if (name == NULL) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                           \"xmlParseEntityDecl: no name\\n\");\n@@ -5733,23 +5724,0 @@\n-    }\n-    if (xmlStrchr(name, ':') != NULL) {\n-        xmlNsErr(ctxt, XML_NS_ERR_COLON,\n-             \"colons are forbidden from entities names '%s'\\n\",\n-             name, NULL, NULL);\n-    }\n-    if (SKIP_BLANKS_PE == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"Space required after the entity name\\n\");\n-    }\n-\n-    \/*\n-     * handle the various case of definitions...\n-     *\/\n-    if (isParameter) {\n-        if ((RAW == '\"') || (RAW == '\\'')) {\n-            value = xmlParseEntityValue(ctxt, &orig);\n-        if (value) {\n-            if ((ctxt->sax != NULL) &&\n-            (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))\n-            ctxt->sax->entityDecl(ctxt->userData, name,\n-                            XML_INTERNAL_PARAMETER_ENTITY,\n-                    NULL, NULL, value);\n@@ -5757,4 +5725,4 @@\n-        } else {\n-            URI = xmlParseExternalID(ctxt, &literal, 1);\n-        if ((URI == NULL) && (literal == NULL)) {\n-            xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);\n+        if (xmlStrchr(name, ':') != NULL) {\n+            xmlNsErr(ctxt, XML_NS_ERR_COLON,\n+                     \"colons are forbidden from entities names '%s'\\n\",\n+                     name, NULL, NULL);\n@@ -5762,1 +5730,24 @@\n-        if (URI) {\n+        if (SKIP_BLANKS_PE == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after the entity name\\n\");\n+        }\n+\n+        \/*\n+         * handle the various case of definitions...\n+         *\/\n+        if (isParameter) {\n+            if ((RAW == '\"') || (RAW == '\\'')) {\n+                value = xmlParseEntityValue(ctxt, &orig);\n+                if (value) {\n+                    if ((ctxt->sax != NULL) &&\n+                        (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))\n+                        ctxt->sax->entityDecl(ctxt->userData, name,\n+                                    XML_INTERNAL_PARAMETER_ENTITY,\n+                                    NULL, NULL, value);\n+                }\n+            } else {\n+                URI = xmlParseExternalID(ctxt, &literal, 1);\n+                if ((URI == NULL) && (literal == NULL)) {\n+                    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);\n+                }\n+                if (URI) {\n@@ -5773,22 +5764,1 @@\n-        }\n-        }\n-    } else {\n-        if ((RAW == '\"') || (RAW == '\\'')) {\n-            value = xmlParseEntityValue(ctxt, &orig);\n-        if ((ctxt->sax != NULL) &&\n-            (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))\n-            ctxt->sax->entityDecl(ctxt->userData, name,\n-                XML_INTERNAL_GENERAL_ENTITY,\n-                NULL, NULL, value);\n-        \/*\n-         * For expat compatibility in SAX mode.\n-         *\/\n-        if ((ctxt->myDoc == NULL) ||\n-            (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {\n-            if (ctxt->myDoc == NULL) {\n-            ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);\n-            if (ctxt->myDoc == NULL) {\n-                xmlErrMemory(ctxt);\n-                goto done;\n-            }\n-            ctxt->myDoc->properties = XML_DOC_INTERNAL;\n+                }\n@@ -5796,3 +5766,24 @@\n-            if (ctxt->myDoc->intSubset == NULL) {\n-            ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,\n-                        BAD_CAST \"fake\", NULL, NULL);\n+        } else {\n+            if ((RAW == '\"') || (RAW == '\\'')) {\n+                value = xmlParseEntityValue(ctxt, &orig);\n+                if ((ctxt->sax != NULL) &&\n+                    (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))\n+                    ctxt->sax->entityDecl(ctxt->userData, name,\n+                                XML_INTERNAL_GENERAL_ENTITY,\n+                                NULL, NULL, value);\n+                \/*\n+                 * For expat compatibility in SAX mode.\n+                 *\/\n+                if ((ctxt->myDoc == NULL) ||\n+                    (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE))) {\n+                    if (ctxt->myDoc == NULL) {\n+                        ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);\n+                        if (ctxt->myDoc == NULL) {\n+                            xmlErrMemory(ctxt);\n+                            goto done;\n+                        }\n+                        ctxt->myDoc->properties = XML_DOC_INTERNAL;\n+                    }\n+                    if (ctxt->myDoc->intSubset == NULL) {\n+                        ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,\n+                                            BAD_CAST \"fake\", NULL, NULL);\n@@ -5805,9 +5796,9 @@\n-            xmlSAX2EntityDecl(ctxt, name, XML_INTERNAL_GENERAL_ENTITY,\n-                          NULL, NULL, value);\n-        }\n-        } else {\n-            URI = xmlParseExternalID(ctxt, &literal, 1);\n-        if ((URI == NULL) && (literal == NULL)) {\n-            xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);\n-        }\n-        if (URI) {\n+                    xmlSAX2EntityDecl(ctxt, name, XML_INTERNAL_GENERAL_ENTITY,\n+                                      NULL, NULL, value);\n+                }\n+            } else {\n+                URI = xmlParseExternalID(ctxt, &literal, 1);\n+                if ((URI == NULL) && (literal == NULL)) {\n+                    xmlFatalErr(ctxt, XML_ERR_VALUE_REQUIRED, NULL);\n+                }\n+                if (URI) {\n@@ -5817,34 +5808,0 @@\n-        }\n-        if ((RAW != '>') && (SKIP_BLANKS_PE == 0)) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                   \"Space required before 'NDATA'\\n\");\n-        }\n-        if (CMP5(CUR_PTR, 'N', 'D', 'A', 'T', 'A')) {\n-            SKIP(5);\n-            if (SKIP_BLANKS_PE == 0) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                       \"Space required after 'NDATA'\\n\");\n-            }\n-            ndata = xmlParseName(ctxt);\n-            if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-                (ctxt->sax->unparsedEntityDecl != NULL))\n-            ctxt->sax->unparsedEntityDecl(ctxt->userData, name,\n-                    literal, URI, ndata);\n-        } else {\n-            if ((ctxt->sax != NULL) &&\n-                (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))\n-            ctxt->sax->entityDecl(ctxt->userData, name,\n-                    XML_EXTERNAL_GENERAL_PARSED_ENTITY,\n-                    literal, URI, NULL);\n-            \/*\n-             * For expat compatibility in SAX mode.\n-             * assuming the entity replacement was asked for\n-             *\/\n-            if ((ctxt->replaceEntities != 0) &&\n-            ((ctxt->myDoc == NULL) ||\n-            (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE)))) {\n-            if (ctxt->myDoc == NULL) {\n-                ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);\n-                if (ctxt->myDoc == NULL) {\n-                    xmlErrMemory(ctxt);\n-                goto done;\n@@ -5852,2 +5809,36 @@\n-                ctxt->myDoc->properties = XML_DOC_INTERNAL;\n-            }\n+                if ((RAW != '>') && (SKIP_BLANKS_PE == 0)) {\n+                    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                                   \"Space required before 'NDATA'\\n\");\n+                }\n+                if (CMP5(CUR_PTR, 'N', 'D', 'A', 'T', 'A')) {\n+                    SKIP(5);\n+                    if (SKIP_BLANKS_PE == 0) {\n+                        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                                       \"Space required after 'NDATA'\\n\");\n+                    }\n+                    ndata = xmlParseName(ctxt);\n+                    if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                        (ctxt->sax->unparsedEntityDecl != NULL))\n+                        ctxt->sax->unparsedEntityDecl(ctxt->userData, name,\n+                                    literal, URI, ndata);\n+                } else {\n+                    if ((ctxt->sax != NULL) &&\n+                        (!ctxt->disableSAX) && (ctxt->sax->entityDecl != NULL))\n+                        ctxt->sax->entityDecl(ctxt->userData, name,\n+                                    XML_EXTERNAL_GENERAL_PARSED_ENTITY,\n+                                    literal, URI, NULL);\n+                    \/*\n+                     * For expat compatibility in SAX mode.\n+                     * assuming the entity replacement was asked for\n+                     *\/\n+                    if ((ctxt->replaceEntities != 0) &&\n+                        ((ctxt->myDoc == NULL) ||\n+                        (xmlStrEqual(ctxt->myDoc->version, SAX_COMPAT_MODE)))) {\n+                        if (ctxt->myDoc == NULL) {\n+                            ctxt->myDoc = xmlNewDoc(SAX_COMPAT_MODE);\n+                            if (ctxt->myDoc == NULL) {\n+                                xmlErrMemory(ctxt);\n+                                goto done;\n+                            }\n+                            ctxt->myDoc->properties = XML_DOC_INTERNAL;\n+                        }\n@@ -5855,3 +5846,3 @@\n-            if (ctxt->myDoc->intSubset == NULL) {\n-                ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,\n-                        BAD_CAST \"fake\", NULL, NULL);\n+                        if (ctxt->myDoc->intSubset == NULL) {\n+                            ctxt->myDoc->intSubset = xmlNewDtd(ctxt->myDoc,\n+                                                BAD_CAST \"fake\", NULL, NULL);\n@@ -5863,3 +5854,5 @@\n-            xmlSAX2EntityDecl(ctxt, name,\n-                          XML_EXTERNAL_GENERAL_PARSED_ENTITY,\n-                          literal, URI, NULL);\n+                        xmlSAX2EntityDecl(ctxt, name,\n+                                          XML_EXTERNAL_GENERAL_PARSED_ENTITY,\n+                                          literal, URI, NULL);\n+                    }\n+                }\n@@ -5868,11 +5861,9 @@\n-        }\n-    }\n-    SKIP_BLANKS_PE;\n-    if (RAW != '>') {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,\n-                \"xmlParseEntityDecl: entity %s not terminated\\n\", name);\n-        xmlHaltParser(ctxt);\n-    } else {\n-        if (inputid != ctxt->input->id) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n-                           \"Entity declaration doesn't start and stop in\"\n+        SKIP_BLANKS_PE;\n+        if (RAW != '>') {\n+            xmlFatalErrMsgStr(ctxt, XML_ERR_ENTITY_NOT_FINISHED,\n+                    \"xmlParseEntityDecl: entity %s not terminated\\n\", name);\n+            xmlHaltParser(ctxt);\n+        } else {\n+            if (inputid != ctxt->input->id) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+                               \"Entity declaration doesn't start and stop in\"\n@@ -5880,0 +5871,2 @@\n+            }\n+            NEXT;\n@@ -5881,7 +5874,5 @@\n-        NEXT;\n-    }\n-    if (orig != NULL) {\n-        \/*\n-         * Ugly mechanism to save the raw entity value.\n-         *\/\n-        xmlEntityPtr cur = NULL;\n+        if (orig != NULL) {\n+            \/*\n+             * Ugly mechanism to save the raw entity value.\n+             *\/\n+            xmlEntityPtr cur = NULL;\n@@ -5889,12 +5880,12 @@\n-        if (isParameter) {\n-            if ((ctxt->sax != NULL) &&\n-            (ctxt->sax->getParameterEntity != NULL))\n-            cur = ctxt->sax->getParameterEntity(ctxt->userData, name);\n-        } else {\n-            if ((ctxt->sax != NULL) &&\n-            (ctxt->sax->getEntity != NULL))\n-            cur = ctxt->sax->getEntity(ctxt->userData, name);\n-        if ((cur == NULL) && (ctxt->userData==ctxt)) {\n-            cur = xmlSAX2GetEntity(ctxt, name);\n-        }\n-        }\n+            if (isParameter) {\n+                if ((ctxt->sax != NULL) &&\n+                    (ctxt->sax->getParameterEntity != NULL))\n+                    cur = ctxt->sax->getParameterEntity(ctxt->userData, name);\n+            } else {\n+                if ((ctxt->sax != NULL) &&\n+                    (ctxt->sax->getEntity != NULL))\n+                    cur = ctxt->sax->getEntity(ctxt->userData, name);\n+                if ((cur == NULL) && (ctxt->userData==ctxt)) {\n+                    cur = xmlSAX2GetEntity(ctxt, name);\n+                }\n+            }\n@@ -5902,1 +5893,1 @@\n-        cur->orig = orig;\n+                cur->orig = orig;\n@@ -5904,0 +5895,1 @@\n+            }\n@@ -5905,1 +5897,0 @@\n-    }\n@@ -5908,3 +5899,3 @@\n-    if (value != NULL) xmlFree(value);\n-    if (URI != NULL) xmlFree(URI);\n-    if (literal != NULL) xmlFree(literal);\n+        if (value != NULL) xmlFree(value);\n+        if (URI != NULL) xmlFree(URI);\n+        if (literal != NULL) xmlFree(literal);\n@@ -5953,2 +5944,2 @@\n-    SKIP(9);\n-    return(XML_ATTRIBUTE_REQUIRED);\n+        SKIP(9);\n+        return(XML_ATTRIBUTE_REQUIRED);\n@@ -5957,2 +5948,2 @@\n-    SKIP(8);\n-    return(XML_ATTRIBUTE_IMPLIED);\n+        SKIP(8);\n+        return(XML_ATTRIBUTE_IMPLIED);\n@@ -5962,6 +5953,6 @@\n-    SKIP(6);\n-    val = XML_ATTRIBUTE_FIXED;\n-    if (SKIP_BLANKS_PE == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"Space required after '#FIXED'\\n\");\n-    }\n+        SKIP(6);\n+        val = XML_ATTRIBUTE_FIXED;\n+        if (SKIP_BLANKS_PE == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after '#FIXED'\\n\");\n+        }\n@@ -5971,2 +5962,2 @@\n-    xmlFatalErrMsg(ctxt, (xmlParserErrors)ctxt->errNo,\n-               \"Attribute default value declaration error\\n\");\n+        xmlFatalErrMsg(ctxt, (xmlParserErrors)ctxt->errNo,\n+                       \"Attribute default value declaration error\\n\");\n@@ -6003,2 +5994,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_STARTED, NULL);\n+        return(NULL);\n@@ -6008,1 +5999,1 @@\n-    SKIP_BLANKS_PE;\n+        SKIP_BLANKS_PE;\n@@ -6010,3 +6001,3 @@\n-    if (name == NULL) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"Name expected in NOTATION declaration\\n\");\n+        if (name == NULL) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                           \"Name expected in NOTATION declaration\\n\");\n@@ -6014,11 +6005,1 @@\n-        return(NULL);\n-    }\n-    tmp = ret;\n-    while (tmp != NULL) {\n-        if (xmlStrEqual(name, tmp->name)) {\n-        xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,\n-      \"standalone: attribute notation value token %s duplicated\\n\",\n-                 name, NULL);\n-        if (!xmlDictOwns(ctxt->dict, name))\n-            xmlFree((xmlChar *) name);\n-        break;\n+            return(NULL);\n@@ -6026,5 +6007,20 @@\n-        tmp = tmp->next;\n-    }\n-    if (tmp == NULL) {\n-        cur = xmlCreateEnumeration(name);\n-        if (cur == NULL) {\n+        tmp = NULL;\n+#ifdef LIBXML_VALID_ENABLED\n+        if (ctxt->validate) {\n+            tmp = ret;\n+            while (tmp != NULL) {\n+                if (xmlStrEqual(name, tmp->name)) {\n+                    xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,\n+              \"standalone: attribute notation value token %s duplicated\\n\",\n+                                     name, NULL);\n+                    if (!xmlDictOwns(ctxt->dict, name))\n+                        xmlFree((xmlChar *) name);\n+                    break;\n+                }\n+                tmp = tmp->next;\n+            }\n+        }\n+#endif \/* LIBXML_VALID_ENABLED *\/\n+        if (tmp == NULL) {\n+            cur = xmlCreateEnumeration(name);\n+            if (cur == NULL) {\n@@ -6035,4 +6031,5 @@\n-        if (last == NULL) ret = last = cur;\n-        else {\n-        last->next = cur;\n-        last = cur;\n+            if (last == NULL) ret = last = cur;\n+            else {\n+                last->next = cur;\n+                last = cur;\n+            }\n@@ -6040,2 +6037,1 @@\n-    }\n-    SKIP_BLANKS_PE;\n+        SKIP_BLANKS_PE;\n@@ -6044,1 +6040,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_NOTATION_NOT_FINISHED, NULL);\n@@ -6046,1 +6042,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6075,2 +6071,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_STARTED, NULL);\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_STARTED, NULL);\n+        return(NULL);\n@@ -6080,1 +6076,1 @@\n-    SKIP_BLANKS_PE;\n+        SKIP_BLANKS_PE;\n@@ -6082,13 +6078,3 @@\n-    if (name == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_NMTOKEN_REQUIRED, NULL);\n-        return(ret);\n-    }\n-    tmp = ret;\n-    while (tmp != NULL) {\n-        if (xmlStrEqual(name, tmp->name)) {\n-        xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,\n-      \"standalone: attribute enumeration value token %s duplicated\\n\",\n-                 name, NULL);\n-        if (!xmlDictOwns(ctxt->dict, name))\n-            xmlFree(name);\n-        break;\n+        if (name == NULL) {\n+            xmlFatalErr(ctxt, XML_ERR_NMTOKEN_REQUIRED, NULL);\n+            return(ret);\n@@ -6096,7 +6082,22 @@\n-        tmp = tmp->next;\n-    }\n-    if (tmp == NULL) {\n-        cur = xmlCreateEnumeration(name);\n-        if (!xmlDictOwns(ctxt->dict, name))\n-        xmlFree(name);\n-        if (cur == NULL) {\n+        tmp = NULL;\n+#ifdef LIBXML_VALID_ENABLED\n+        if (ctxt->validate) {\n+            tmp = ret;\n+            while (tmp != NULL) {\n+                if (xmlStrEqual(name, tmp->name)) {\n+                    xmlValidityError(ctxt, XML_DTD_DUP_TOKEN,\n+              \"standalone: attribute enumeration value token %s duplicated\\n\",\n+                                     name, NULL);\n+                    if (!xmlDictOwns(ctxt->dict, name))\n+                        xmlFree(name);\n+                    break;\n+                }\n+                tmp = tmp->next;\n+            }\n+        }\n+#endif \/* LIBXML_VALID_ENABLED *\/\n+        if (tmp == NULL) {\n+            cur = xmlCreateEnumeration(name);\n+            if (!xmlDictOwns(ctxt->dict, name))\n+                xmlFree(name);\n+            if (cur == NULL) {\n@@ -6107,4 +6108,5 @@\n-        if (last == NULL) ret = last = cur;\n-        else {\n-        last->next = cur;\n-        last = cur;\n+            if (last == NULL) ret = last = cur;\n+            else {\n+                last->next = cur;\n+                last = cur;\n+            }\n@@ -6112,2 +6114,1 @@\n-    }\n-    SKIP_BLANKS_PE;\n+        SKIP_BLANKS_PE;\n@@ -6116,2 +6117,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_FINISHED, NULL);\n-    return(ret);\n+        xmlFatalErr(ctxt, XML_ERR_ATTLIST_NOT_FINISHED, NULL);\n+        return(ret);\n@@ -6143,9 +6144,9 @@\n-    SKIP(8);\n-    if (SKIP_BLANKS_PE == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"Space required after 'NOTATION'\\n\");\n-        return(0);\n-    }\n-    *tree = xmlParseNotationType(ctxt);\n-    if (*tree == NULL) return(0);\n-    return(XML_ATTRIBUTE_NOTATION);\n+        SKIP(8);\n+        if (SKIP_BLANKS_PE == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after 'NOTATION'\\n\");\n+            return(0);\n+        }\n+        *tree = xmlParseNotationType(ctxt);\n+        if (*tree == NULL) return(0);\n+        return(XML_ATTRIBUTE_NOTATION);\n@@ -6208,2 +6209,2 @@\n-    SKIP(5);\n-    return(XML_ATTRIBUTE_CDATA);\n+        SKIP(5);\n+        return(XML_ATTRIBUTE_CDATA);\n@@ -6211,2 +6212,2 @@\n-    SKIP(6);\n-    return(XML_ATTRIBUTE_IDREFS);\n+        SKIP(6);\n+        return(XML_ATTRIBUTE_IDREFS);\n@@ -6214,2 +6215,2 @@\n-    SKIP(5);\n-    return(XML_ATTRIBUTE_IDREF);\n+        SKIP(5);\n+        return(XML_ATTRIBUTE_IDREF);\n@@ -6218,1 +6219,1 @@\n-    return(XML_ATTRIBUTE_ID);\n+        return(XML_ATTRIBUTE_ID);\n@@ -6220,2 +6221,2 @@\n-    SKIP(6);\n-    return(XML_ATTRIBUTE_ENTITY);\n+        SKIP(6);\n+        return(XML_ATTRIBUTE_ENTITY);\n@@ -6223,2 +6224,2 @@\n-    SKIP(8);\n-    return(XML_ATTRIBUTE_ENTITIES);\n+        SKIP(8);\n+        return(XML_ATTRIBUTE_ENTITIES);\n@@ -6226,2 +6227,2 @@\n-    SKIP(8);\n-    return(XML_ATTRIBUTE_NMTOKENS);\n+        SKIP(8);\n+        return(XML_ATTRIBUTE_NMTOKENS);\n@@ -6229,2 +6230,2 @@\n-    SKIP(7);\n-    return(XML_ATTRIBUTE_NMTOKEN);\n+        SKIP(7);\n+        return(XML_ATTRIBUTE_NMTOKEN);\n@@ -6259,1 +6260,1 @@\n-    int inputid = ctxt->input->id;\n+        int inputid = ctxt->input->id;\n@@ -6261,5 +6262,5 @@\n-    SKIP(7);\n-    if (SKIP_BLANKS_PE == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                         \"Space required after '<!ATTLIST'\\n\");\n-    }\n+        SKIP(7);\n+        if (SKIP_BLANKS_PE == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                                 \"Space required after '<!ATTLIST'\\n\");\n+        }\n@@ -6267,19 +6268,4 @@\n-    if (elemName == NULL) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"ATTLIST: no name for Element\\n\");\n-        return;\n-    }\n-    SKIP_BLANKS_PE;\n-    GROW;\n-    while ((RAW != '>') && (PARSER_STOPPED(ctxt) == 0)) {\n-        int type;\n-        int def;\n-        xmlChar *defaultValue = NULL;\n-\n-        GROW;\n-            tree = NULL;\n-        attrName = xmlParseName(ctxt);\n-        if (attrName == NULL) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-                   \"ATTLIST: no name for Attribute\\n\");\n-        break;\n+        if (elemName == NULL) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                           \"ATTLIST: no name for Element\\n\");\n+            return;\n@@ -6287,0 +6273,1 @@\n+        SKIP_BLANKS_PE;\n@@ -6288,5 +6275,4 @@\n-        if (SKIP_BLANKS_PE == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                \"Space required after the attribute name\\n\");\n-        break;\n-        }\n+        while ((RAW != '>') && (PARSER_STOPPED(ctxt) == 0)) {\n+            int type;\n+            int def;\n+            xmlChar *defaultValue = NULL;\n@@ -6294,4 +6280,14 @@\n-        type = xmlParseAttributeType(ctxt, &tree);\n-        if (type <= 0) {\n-            break;\n-        }\n+            GROW;\n+            tree = NULL;\n+            attrName = xmlParseName(ctxt);\n+            if (attrName == NULL) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                               \"ATTLIST: no name for Attribute\\n\");\n+                break;\n+            }\n+            GROW;\n+            if (SKIP_BLANKS_PE == 0) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                        \"Space required after the attribute name\\n\");\n+                break;\n+            }\n@@ -6299,8 +6295,4 @@\n-        GROW;\n-        if (SKIP_BLANKS_PE == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                   \"Space required after the attribute type\\n\");\n-            if (tree != NULL)\n-            xmlFreeEnumeration(tree);\n-        break;\n-        }\n+            type = xmlParseAttributeType(ctxt, &tree);\n+            if (type <= 0) {\n+                break;\n+            }\n@@ -6308,2 +6300,11 @@\n-        def = xmlParseDefaultDecl(ctxt, &defaultValue);\n-        if (def <= 0) {\n+            GROW;\n+            if (SKIP_BLANKS_PE == 0) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                               \"Space required after the attribute type\\n\");\n+                if (tree != NULL)\n+                    xmlFreeEnumeration(tree);\n+                break;\n+            }\n+\n+            def = xmlParseDefaultDecl(ctxt, &defaultValue);\n+            if (def <= 0) {\n@@ -6311,7 +6312,7 @@\n-            xmlFree(defaultValue);\n-            if (tree != NULL)\n-            xmlFreeEnumeration(tree);\n-            break;\n-        }\n-        if ((type != XML_ATTRIBUTE_CDATA) && (defaultValue != NULL))\n-            xmlAttrNormalizeSpace(defaultValue, defaultValue);\n+                    xmlFree(defaultValue);\n+                if (tree != NULL)\n+                    xmlFreeEnumeration(tree);\n+                break;\n+            }\n+            if ((type != XML_ATTRIBUTE_CDATA) && (defaultValue != NULL))\n+                xmlAttrNormalizeSpace(defaultValue, defaultValue);\n@@ -6319,1 +6320,1 @@\n-        GROW;\n+            GROW;\n@@ -6321,3 +6322,25 @@\n-        if (SKIP_BLANKS_PE == 0) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-            \"Space required after the attribute default value\\n\");\n+                if (SKIP_BLANKS_PE == 0) {\n+                    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                        \"Space required after the attribute default value\\n\");\n+                    if (defaultValue != NULL)\n+                        xmlFree(defaultValue);\n+                    if (tree != NULL)\n+                        xmlFreeEnumeration(tree);\n+                    break;\n+                }\n+            }\n+            if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                (ctxt->sax->attributeDecl != NULL))\n+                ctxt->sax->attributeDecl(ctxt->userData, elemName, attrName,\n+                                type, def, defaultValue, tree);\n+            else if (tree != NULL)\n+                xmlFreeEnumeration(tree);\n+\n+            if ((ctxt->sax2) && (defaultValue != NULL) &&\n+                (def != XML_ATTRIBUTE_IMPLIED) &&\n+                (def != XML_ATTRIBUTE_REQUIRED)) {\n+                xmlAddDefAttrs(ctxt, elemName, attrName, defaultValue);\n+            }\n+            if (ctxt->sax2) {\n+                xmlAddSpecialAttr(ctxt, elemName, attrName, type);\n+            }\n@@ -6325,20 +6348,2 @@\n-            xmlFree(defaultValue);\n-            if (tree != NULL)\n-            xmlFreeEnumeration(tree);\n-            break;\n-        }\n-        }\n-        if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-        (ctxt->sax->attributeDecl != NULL))\n-        ctxt->sax->attributeDecl(ctxt->userData, elemName, attrName,\n-                            type, def, defaultValue, tree);\n-        else if (tree != NULL)\n-        xmlFreeEnumeration(tree);\n-\n-        if ((ctxt->sax2) && (defaultValue != NULL) &&\n-            (def != XML_ATTRIBUTE_IMPLIED) &&\n-        (def != XML_ATTRIBUTE_REQUIRED)) {\n-        xmlAddDefAttrs(ctxt, elemName, attrName, defaultValue);\n-        }\n-        if (ctxt->sax2) {\n-        xmlAddSpecialAttr(ctxt, elemName, attrName, type);\n+                xmlFree(defaultValue);\n+            GROW;\n@@ -6346,7 +6351,3 @@\n-        if (defaultValue != NULL)\n-            xmlFree(defaultValue);\n-        GROW;\n-    }\n-    if (RAW == '>') {\n-        if (inputid != ctxt->input->id) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+        if (RAW == '>') {\n+            if (inputid != ctxt->input->id) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n@@ -6355,0 +6356,2 @@\n+            }\n+            NEXT;\n@@ -6356,2 +6359,0 @@\n-        NEXT;\n-    }\n@@ -6389,5 +6390,5 @@\n-    SKIP(7);\n-    SKIP_BLANKS_PE;\n-    if (RAW == ')') {\n-        if (ctxt->input->id != inputchk) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+        SKIP(7);\n+        SKIP_BLANKS_PE;\n+        if (RAW == ')') {\n+            if (ctxt->input->id != inputchk) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n@@ -6396,4 +6397,4 @@\n-        }\n-        NEXT;\n-        ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);\n-        if (ret == NULL)\n+            }\n+            NEXT;\n+            ret = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);\n+            if (ret == NULL)\n@@ -6401,3 +6402,5 @@\n-        if (RAW == '*') {\n-        ret->ocur = XML_ELEMENT_CONTENT_MULT;\n-        NEXT;\n+            if (RAW == '*') {\n+                ret->ocur = XML_ELEMENT_CONTENT_MULT;\n+                NEXT;\n+            }\n+            return(ret);\n@@ -6405,5 +6408,3 @@\n-        return(ret);\n-    }\n-    if ((RAW == '(') || (RAW == '|')) {\n-        ret = cur = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);\n-        if (ret == NULL)\n+        if ((RAW == '(') || (RAW == '|')) {\n+            ret = cur = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_PCDATA);\n+            if (ret == NULL)\n@@ -6411,3 +6412,3 @@\n-    }\n-    while ((RAW == '|') && (PARSER_STOPPED(ctxt) == 0)) {\n-        NEXT;\n+        }\n+        while ((RAW == '|') && (PARSER_STOPPED(ctxt) == 0)) {\n+            NEXT;\n@@ -6417,9 +6418,9 @@\n-        if (elem == NULL) {\n-        n->c1 = cur;\n-        if (cur != NULL)\n-            cur->parent = n;\n-        ret = cur = n;\n-        } else {\n-            cur->c2 = n;\n-        n->parent = cur;\n-        n->c1 = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);\n+            if (elem == NULL) {\n+                n->c1 = cur;\n+                if (cur != NULL)\n+                    cur->parent = n;\n+                ret = cur = n;\n+            } else {\n+                cur->c2 = n;\n+                n->parent = cur;\n+                n->c1 = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);\n@@ -6428,10 +6429,13 @@\n-        n->c1->parent = n;\n-        cur = n;\n-        }\n-        SKIP_BLANKS_PE;\n-        elem = xmlParseName(ctxt);\n-        if (elem == NULL) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-            \"xmlParseElementMixedContentDecl : Name expected\\n\");\n-        xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n+                n->c1->parent = n;\n+                cur = n;\n+            }\n+            SKIP_BLANKS_PE;\n+            elem = xmlParseName(ctxt);\n+            if (elem == NULL) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                        \"xmlParseElementMixedContentDecl : Name expected\\n\");\n+                xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n+            }\n+            SKIP_BLANKS_PE;\n+            GROW;\n@@ -6439,8 +6443,5 @@\n-        SKIP_BLANKS_PE;\n-        GROW;\n-    }\n-    if ((RAW == ')') && (NXT(1) == '*')) {\n-        if (elem != NULL) {\n-        cur->c2 = xmlNewDocElementContent(ctxt->myDoc, elem,\n-                                       XML_ELEMENT_CONTENT_ELEMENT);\n-        if (cur->c2 == NULL)\n+        if ((RAW == ')') && (NXT(1) == '*')) {\n+            if (elem != NULL) {\n+                cur->c2 = xmlNewDocElementContent(ctxt->myDoc, elem,\n+                                               XML_ELEMENT_CONTENT_ELEMENT);\n+                if (cur->c2 == NULL)\n@@ -6448,1 +6449,1 @@\n-        cur->c2->parent = cur;\n+                cur->c2->parent = cur;\n@@ -6452,2 +6453,2 @@\n-        if (ctxt->input->id != inputchk) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+            if (ctxt->input->id != inputchk) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n@@ -6456,0 +6457,6 @@\n+            }\n+            SKIP(2);\n+        } else {\n+            xmlFreeDocElementContent(ctxt->myDoc, ret);\n+            xmlFatalErr(ctxt, XML_ERR_MIXED_NOT_STARTED, NULL);\n+            return(NULL);\n@@ -6457,6 +6464,0 @@\n-        SKIP(2);\n-    } else {\n-        xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        xmlFatalErr(ctxt, XML_ERR_MIXED_NOT_STARTED, NULL);\n-        return(NULL);\n-    }\n@@ -6465,1 +6466,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_PCDATA_REQUIRED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_PCDATA_REQUIRED, NULL);\n@@ -6495,8 +6496,8 @@\n- *    with parenthesized groups. That is to say, if either of the\n- *    opening or closing parentheses in a choice, seq, or Mixed\n- *    construct is contained in the replacement text for a parameter\n- *    entity, both must be contained in the same replacement text. For\n- *    interoperability, if a parameter-entity reference appears in a\n- *    choice, seq, or Mixed construct, its replacement text should not\n- *    be empty, and neither the first nor last non-blank character of\n- *    the replacement text should be a connector (| or ,).\n+ *      with parenthesized groups. That is to say, if either of the\n+ *      opening or closing parentheses in a choice, seq, or Mixed\n+ *      construct is contained in the replacement text for a parameter\n+ *      entity, both must be contained in the same replacement text. For\n+ *      interoperability, if a parameter-entity reference appears in a\n+ *      choice, seq, or Mixed construct, its replacement text should not\n+ *      be empty, and neither the first nor last non-blank character of\n+ *      the replacement text should be a connector (| or ,).\n@@ -6519,1 +6520,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6524,1 +6525,1 @@\n-    int inputid = ctxt->input->id;\n+        int inputid = ctxt->input->id;\n@@ -6526,3 +6527,3 @@\n-        \/* Recurse on first child *\/\n-    NEXT;\n-    SKIP_BLANKS_PE;\n+        \/* Recurse on first child *\/\n+        NEXT;\n+        SKIP_BLANKS_PE;\n@@ -6533,2 +6534,2 @@\n-    SKIP_BLANKS_PE;\n-    GROW;\n+        SKIP_BLANKS_PE;\n+        GROW;\n@@ -6536,5 +6537,5 @@\n-    elem = xmlParseName(ctxt);\n-    if (elem == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);\n-        return(NULL);\n-    }\n+        elem = xmlParseName(ctxt);\n+        if (elem == NULL) {\n+            xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);\n+            return(NULL);\n+        }\n@@ -6542,18 +6543,18 @@\n-    if (cur == NULL) {\n-        xmlErrMemory(ctxt);\n-        return(NULL);\n-    }\n-    GROW;\n-    if (RAW == '?') {\n-        cur->ocur = XML_ELEMENT_CONTENT_OPT;\n-        NEXT;\n-    } else if (RAW == '*') {\n-        cur->ocur = XML_ELEMENT_CONTENT_MULT;\n-        NEXT;\n-    } else if (RAW == '+') {\n-        cur->ocur = XML_ELEMENT_CONTENT_PLUS;\n-        NEXT;\n-    } else {\n-        cur->ocur = XML_ELEMENT_CONTENT_ONCE;\n-    }\n-    GROW;\n+        if (cur == NULL) {\n+            xmlErrMemory(ctxt);\n+            return(NULL);\n+        }\n+        GROW;\n+        if (RAW == '?') {\n+            cur->ocur = XML_ELEMENT_CONTENT_OPT;\n+            NEXT;\n+        } else if (RAW == '*') {\n+            cur->ocur = XML_ELEMENT_CONTENT_MULT;\n+            NEXT;\n+        } else if (RAW == '+') {\n+            cur->ocur = XML_ELEMENT_CONTENT_PLUS;\n+            NEXT;\n+        } else {\n+            cur->ocur = XML_ELEMENT_CONTENT_ONCE;\n+        }\n+        GROW;\n@@ -6564,2 +6565,2 @@\n-     * Each loop we parse one separator and one element.\n-     *\/\n+         * Each loop we parse one separator and one element.\n+         *\/\n@@ -6567,1 +6568,1 @@\n-        if (type == 0) type = CUR;\n+            if (type == 0) type = CUR;\n@@ -6569,14 +6570,14 @@\n-        \/*\n-         * Detect \"Name | Name , Name\" error\n-         *\/\n-        else if (type != CUR) {\n-        xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,\n-            \"xmlParseElementChildrenContentDecl : '%c' expected\\n\",\n-                          type);\n-        if ((last != NULL) && (last != ret))\n-            xmlFreeDocElementContent(ctxt->myDoc, last);\n-        if (ret != NULL)\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n-        }\n-        NEXT;\n+            \/*\n+             * Detect \"Name | Name , Name\" error\n+             *\/\n+            else if (type != CUR) {\n+                xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,\n+                    \"xmlParseElementChildrenContentDecl : '%c' expected\\n\",\n+                                  type);\n+                if ((last != NULL) && (last != ret))\n+                    xmlFreeDocElementContent(ctxt->myDoc, last);\n+                if (ret != NULL)\n+                    xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n+            }\n+            NEXT;\n@@ -6584,2 +6585,2 @@\n-        op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);\n-        if (op == NULL) {\n+            op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_SEQ);\n+            if (op == NULL) {\n@@ -6587,22 +6588,22 @@\n-        if ((last != NULL) && (last != ret))\n-            xmlFreeDocElementContent(ctxt->myDoc, last);\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n-        }\n-        if (last == NULL) {\n-        op->c1 = ret;\n-        if (ret != NULL)\n-            ret->parent = op;\n-        ret = cur = op;\n-        } else {\n-            cur->c2 = op;\n-        if (op != NULL)\n-            op->parent = cur;\n-        op->c1 = last;\n-        if (last != NULL)\n-            last->parent = op;\n-        cur =op;\n-        last = NULL;\n-        }\n-    } else if (RAW == '|') {\n-        if (type == 0) type = CUR;\n+                if ((last != NULL) && (last != ret))\n+                    xmlFreeDocElementContent(ctxt->myDoc, last);\n+                xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n+            }\n+            if (last == NULL) {\n+                op->c1 = ret;\n+                if (ret != NULL)\n+                    ret->parent = op;\n+                ret = cur = op;\n+            } else {\n+                cur->c2 = op;\n+                if (op != NULL)\n+                    op->parent = cur;\n+                op->c1 = last;\n+                if (last != NULL)\n+                    last->parent = op;\n+                cur =op;\n+                last = NULL;\n+            }\n+        } else if (RAW == '|') {\n+            if (type == 0) type = CUR;\n@@ -6610,14 +6611,14 @@\n-        \/*\n-         * Detect \"Name , Name | Name\" error\n-         *\/\n-        else if (type != CUR) {\n-        xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,\n-            \"xmlParseElementChildrenContentDecl : '%c' expected\\n\",\n-                  type);\n-        if ((last != NULL) && (last != ret))\n-            xmlFreeDocElementContent(ctxt->myDoc, last);\n-        if (ret != NULL)\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n-        }\n-        NEXT;\n+            \/*\n+             * Detect \"Name , Name | Name\" error\n+             *\/\n+            else if (type != CUR) {\n+                xmlFatalErrMsgInt(ctxt, XML_ERR_SEPARATOR_REQUIRED,\n+                    \"xmlParseElementChildrenContentDecl : '%c' expected\\n\",\n+                                  type);\n+                if ((last != NULL) && (last != ret))\n+                    xmlFreeDocElementContent(ctxt->myDoc, last);\n+                if (ret != NULL)\n+                    xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n+            }\n+            NEXT;\n@@ -6625,2 +6626,2 @@\n-        op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);\n-        if (op == NULL) {\n+            op = xmlNewDocElementContent(ctxt->myDoc, NULL, XML_ELEMENT_CONTENT_OR);\n+            if (op == NULL) {\n@@ -6628,11 +6629,21 @@\n-        if ((last != NULL) && (last != ret))\n-            xmlFreeDocElementContent(ctxt->myDoc, last);\n-        if (ret != NULL)\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n-        }\n-        if (last == NULL) {\n-        op->c1 = ret;\n-        if (ret != NULL)\n-            ret->parent = op;\n-        ret = cur = op;\n+                if ((last != NULL) && (last != ret))\n+                    xmlFreeDocElementContent(ctxt->myDoc, last);\n+                if (ret != NULL)\n+                    xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n+            }\n+            if (last == NULL) {\n+                op->c1 = ret;\n+                if (ret != NULL)\n+                    ret->parent = op;\n+                ret = cur = op;\n+            } else {\n+                cur->c2 = op;\n+                if (op != NULL)\n+                    op->parent = cur;\n+                op->c1 = last;\n+                if (last != NULL)\n+                    last->parent = op;\n+                cur =op;\n+                last = NULL;\n+            }\n@@ -6640,8 +6651,6 @@\n-            cur->c2 = op;\n-        if (op != NULL)\n-            op->parent = cur;\n-        op->c1 = last;\n-        if (last != NULL)\n-            last->parent = op;\n-        cur =op;\n-        last = NULL;\n+            xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);\n+            if ((last != NULL) && (last != ret))\n+                xmlFreeDocElementContent(ctxt->myDoc, last);\n+            if (ret != NULL)\n+                xmlFreeDocElementContent(ctxt->myDoc, ret);\n+            return(NULL);\n@@ -6649,15 +6658,1 @@\n-    } else {\n-        xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_FINISHED, NULL);\n-        if ((last != NULL) && (last != ret))\n-            xmlFreeDocElementContent(ctxt->myDoc, last);\n-        if (ret != NULL)\n-        xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n-    }\n-    GROW;\n-    SKIP_BLANKS_PE;\n-    GROW;\n-    if (RAW == '(') {\n-        int inputid = ctxt->input->id;\n-        \/* Recurse on second child *\/\n-        NEXT;\n+        GROW;\n@@ -6665,1 +6660,7 @@\n-        last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,\n+        GROW;\n+        if (RAW == '(') {\n+            int inputid = ctxt->input->id;\n+            \/* Recurse on second child *\/\n+            NEXT;\n+            SKIP_BLANKS_PE;\n+            last = xmlParseElementChildrenContentDeclPriv(ctxt, inputid,\n@@ -6668,3 +6669,3 @@\n-        if (ret != NULL)\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n+                if (ret != NULL)\n+                    xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n@@ -6672,25 +6673,1 @@\n-        SKIP_BLANKS_PE;\n-    } else {\n-        elem = xmlParseName(ctxt);\n-        if (elem == NULL) {\n-        xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);\n-        if (ret != NULL)\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n-        }\n-        last = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);\n-        if (last == NULL) {\n-                xmlErrMemory(ctxt);\n-        if (ret != NULL)\n-            xmlFreeDocElementContent(ctxt->myDoc, ret);\n-        return(NULL);\n-        }\n-        if (RAW == '?') {\n-        last->ocur = XML_ELEMENT_CONTENT_OPT;\n-        NEXT;\n-        } else if (RAW == '*') {\n-        last->ocur = XML_ELEMENT_CONTENT_MULT;\n-        NEXT;\n-        } else if (RAW == '+') {\n-        last->ocur = XML_ELEMENT_CONTENT_PLUS;\n-        NEXT;\n+            SKIP_BLANKS_PE;\n@@ -6698,1 +6675,26 @@\n-        last->ocur = XML_ELEMENT_CONTENT_ONCE;\n+            elem = xmlParseName(ctxt);\n+            if (elem == NULL) {\n+                xmlFatalErr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED, NULL);\n+                if (ret != NULL)\n+                    xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n+            }\n+            last = xmlNewDocElementContent(ctxt->myDoc, elem, XML_ELEMENT_CONTENT_ELEMENT);\n+            if (last == NULL) {\n+                xmlErrMemory(ctxt);\n+                if (ret != NULL)\n+                    xmlFreeDocElementContent(ctxt->myDoc, ret);\n+                return(NULL);\n+            }\n+            if (RAW == '?') {\n+                last->ocur = XML_ELEMENT_CONTENT_OPT;\n+                NEXT;\n+            } else if (RAW == '*') {\n+                last->ocur = XML_ELEMENT_CONTENT_MULT;\n+                NEXT;\n+            } else if (RAW == '+') {\n+                last->ocur = XML_ELEMENT_CONTENT_PLUS;\n+                NEXT;\n+            } else {\n+                last->ocur = XML_ELEMENT_CONTENT_ONCE;\n+            }\n@@ -6700,3 +6702,2 @@\n-    }\n-    SKIP_BLANKS_PE;\n-    GROW;\n+        SKIP_BLANKS_PE;\n+        GROW;\n@@ -6706,2 +6707,2 @@\n-    if (last != NULL)\n-        last->parent = cur;\n+        if (last != NULL)\n+            last->parent = cur;\n@@ -6710,1 +6711,1 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n@@ -6716,8 +6717,8 @@\n-    if (ret != NULL) {\n-        if ((ret->ocur == XML_ELEMENT_CONTENT_PLUS) ||\n-            (ret->ocur == XML_ELEMENT_CONTENT_MULT))\n-            ret->ocur = XML_ELEMENT_CONTENT_MULT;\n-        else\n-            ret->ocur = XML_ELEMENT_CONTENT_OPT;\n-    }\n-    NEXT;\n+        if (ret != NULL) {\n+            if ((ret->ocur == XML_ELEMENT_CONTENT_PLUS) ||\n+                (ret->ocur == XML_ELEMENT_CONTENT_MULT))\n+                ret->ocur = XML_ELEMENT_CONTENT_MULT;\n+            else\n+                ret->ocur = XML_ELEMENT_CONTENT_OPT;\n+        }\n+        NEXT;\n@@ -6725,17 +6726,18 @@\n-    if (ret != NULL) {\n-        ret->ocur = XML_ELEMENT_CONTENT_MULT;\n-        cur = ret;\n-        \/*\n-         * Some normalization:\n-         * (a | b* | c?)* == (a | b | c)*\n-         *\/\n-        while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {\n-        if ((cur->c1 != NULL) &&\n-                ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n-             (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT)))\n-            cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;\n-        if ((cur->c2 != NULL) &&\n-                ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||\n-             (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT)))\n-            cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;\n-        cur = cur->c2;\n+        if (ret != NULL) {\n+            ret->ocur = XML_ELEMENT_CONTENT_MULT;\n+            cur = ret;\n+            \/*\n+             * Some normalization:\n+             * (a | b* | c?)* == (a | b | c)*\n+             *\/\n+            while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {\n+                if ((cur->c1 != NULL) &&\n+                    ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n+                     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT)))\n+                    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;\n+                if ((cur->c2 != NULL) &&\n+                    ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||\n+                     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT)))\n+                    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;\n+                cur = cur->c2;\n+            }\n@@ -6743,2 +6745,1 @@\n-    }\n-    NEXT;\n+        NEXT;\n@@ -6746,2 +6747,2 @@\n-    if (ret != NULL) {\n-        int found = 0;\n+        if (ret != NULL) {\n+            int found = 0;\n@@ -6749,24 +6750,27 @@\n-        if ((ret->ocur == XML_ELEMENT_CONTENT_OPT) ||\n-            (ret->ocur == XML_ELEMENT_CONTENT_MULT))\n-            ret->ocur = XML_ELEMENT_CONTENT_MULT;\n-        else\n-            ret->ocur = XML_ELEMENT_CONTENT_PLUS;\n-        \/*\n-         * Some normalization:\n-         * (a | b*)+ == (a | b)*\n-         * (a | b?)+ == (a | b)*\n-         *\/\n-        while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {\n-        if ((cur->c1 != NULL) &&\n-                ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n-             (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {\n-            cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;\n-            found = 1;\n-        }\n-        if ((cur->c2 != NULL) &&\n-                ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||\n-             (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT))) {\n-            cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;\n-            found = 1;\n-        }\n-        cur = cur->c2;\n+            if ((ret->ocur == XML_ELEMENT_CONTENT_OPT) ||\n+                (ret->ocur == XML_ELEMENT_CONTENT_MULT))\n+                ret->ocur = XML_ELEMENT_CONTENT_MULT;\n+            else\n+                ret->ocur = XML_ELEMENT_CONTENT_PLUS;\n+            \/*\n+             * Some normalization:\n+             * (a | b*)+ == (a | b)*\n+             * (a | b?)+ == (a | b)*\n+             *\/\n+            while ((cur != NULL) && (cur->type == XML_ELEMENT_CONTENT_OR)) {\n+                if ((cur->c1 != NULL) &&\n+                    ((cur->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n+                     (cur->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {\n+                    cur->c1->ocur = XML_ELEMENT_CONTENT_ONCE;\n+                    found = 1;\n+                }\n+                if ((cur->c2 != NULL) &&\n+                    ((cur->c2->ocur == XML_ELEMENT_CONTENT_OPT) ||\n+                     (cur->c2->ocur == XML_ELEMENT_CONTENT_MULT))) {\n+                    cur->c2->ocur = XML_ELEMENT_CONTENT_ONCE;\n+                    found = 1;\n+                }\n+                cur = cur->c2;\n+            }\n+            if (found)\n+                ret->ocur = XML_ELEMENT_CONTENT_MULT;\n@@ -6774,4 +6778,1 @@\n-        if (found)\n-        ret->ocur = XML_ELEMENT_CONTENT_MULT;\n-    }\n-    NEXT;\n+        NEXT;\n@@ -6802,8 +6803,8 @@\n- *    with parenthesized groups. That is to say, if either of the\n- *    opening or closing parentheses in a choice, seq, or Mixed\n- *    construct is contained in the replacement text for a parameter\n- *    entity, both must be contained in the same replacement text. For\n- *    interoperability, if a parameter-entity reference appears in a\n- *    choice, seq, or Mixed construct, its replacement text should not\n- *    be empty, and neither the first nor last non-blank character of\n- *    the replacement text should be a connector (| or ,).\n+ *      with parenthesized groups. That is to say, if either of the\n+ *      opening or closing parentheses in a choice, seq, or Mixed\n+ *      construct is contained in the replacement text for a parameter\n+ *      entity, both must be contained in the same replacement text. For\n+ *      interoperability, if a parameter-entity reference appears in a\n+ *      choice, seq, or Mixed construct, its replacement text should not\n+ *      be empty, and neither the first nor last non-blank character of\n+ *      the replacement text should be a connector (| or ,).\n@@ -6847,3 +6848,3 @@\n-    xmlFatalErrMsgStr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,\n-        \"xmlParseElementContentDecl : %s '(' expected\\n\", name);\n-    return(-1);\n+        xmlFatalErrMsgStr(ctxt, XML_ERR_ELEMCONTENT_NOT_STARTED,\n+                \"xmlParseElementContentDecl : %s '(' expected\\n\", name);\n+        return(-1);\n@@ -6856,1 +6857,1 @@\n-    res = XML_ELEMENT_TYPE_MIXED;\n+        res = XML_ELEMENT_TYPE_MIXED;\n@@ -6859,1 +6860,1 @@\n-    res = XML_ELEMENT_TYPE_ELEMENT;\n+        res = XML_ELEMENT_TYPE_ELEMENT;\n@@ -6893,1 +6894,1 @@\n-    int inputid = ctxt->input->id;\n+        int inputid = ctxt->input->id;\n@@ -6895,6 +6896,6 @@\n-    SKIP(7);\n-    if (SKIP_BLANKS_PE == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                   \"Space required after 'ELEMENT'\\n\");\n-        return(-1);\n-    }\n+        SKIP(7);\n+        if (SKIP_BLANKS_PE == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after 'ELEMENT'\\n\");\n+            return(-1);\n+        }\n@@ -6902,28 +6903,28 @@\n-    if (name == NULL) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"xmlParseElementDecl: no name for Element\\n\");\n-        return(-1);\n-    }\n-    if (SKIP_BLANKS_PE == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"Space required after the element name\\n\");\n-    }\n-    if (CMP5(CUR_PTR, 'E', 'M', 'P', 'T', 'Y')) {\n-        SKIP(5);\n-        \/*\n-         * Element must always be empty.\n-         *\/\n-        ret = XML_ELEMENT_TYPE_EMPTY;\n-    } else if ((RAW == 'A') && (NXT(1) == 'N') &&\n-               (NXT(2) == 'Y')) {\n-        SKIP(3);\n-        \/*\n-         * Element is a generic container.\n-         *\/\n-        ret = XML_ELEMENT_TYPE_ANY;\n-    } else if (RAW == '(') {\n-        ret = xmlParseElementContentDecl(ctxt, name, &content);\n-    } else {\n-        \/*\n-         * [ WFC: PEs in Internal Subset ] error handling.\n-         *\/\n+        if (name == NULL) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                           \"xmlParseElementDecl: no name for Element\\n\");\n+            return(-1);\n+        }\n+        if (SKIP_BLANKS_PE == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space required after the element name\\n\");\n+        }\n+        if (CMP5(CUR_PTR, 'E', 'M', 'P', 'T', 'Y')) {\n+            SKIP(5);\n+            \/*\n+             * Element must always be empty.\n+             *\/\n+            ret = XML_ELEMENT_TYPE_EMPTY;\n+        } else if ((RAW == 'A') && (NXT(1) == 'N') &&\n+                   (NXT(2) == 'Y')) {\n+            SKIP(3);\n+            \/*\n+             * Element is a generic container.\n+             *\/\n+            ret = XML_ELEMENT_TYPE_ANY;\n+        } else if (RAW == '(') {\n+            ret = xmlParseElementContentDecl(ctxt, name, &content);\n+        } else {\n+            \/*\n+             * [ WFC: PEs in Internal Subset ] error handling.\n+             *\/\n@@ -6932,2 +6933,2 @@\n-        return(-1);\n-    }\n+            return(-1);\n+        }\n@@ -6935,1 +6936,1 @@\n-    SKIP_BLANKS_PE;\n+        SKIP_BLANKS_PE;\n@@ -6937,8 +6938,8 @@\n-    if (RAW != '>') {\n-        xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n-        if (content != NULL) {\n-        xmlFreeDocElementContent(ctxt->myDoc, content);\n-        }\n-    } else {\n-        if (inputid != ctxt->input->id) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n+        if (RAW != '>') {\n+            xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n+            if (content != NULL) {\n+                xmlFreeDocElementContent(ctxt->myDoc, content);\n+            }\n+        } else {\n+            if (inputid != ctxt->input->id) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_ENTITY_BOUNDARY,\n@@ -6947,1 +6948,1 @@\n-        }\n+            }\n@@ -6949,18 +6950,19 @@\n-        NEXT;\n-        if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-        (ctxt->sax->elementDecl != NULL)) {\n-        if (content != NULL)\n-            content->parent = NULL;\n-            ctxt->sax->elementDecl(ctxt->userData, name, ret,\n-                               content);\n-        if ((content != NULL) && (content->parent == NULL)) {\n-            \/*\n-             * this is a trick: if xmlAddElementDecl is called,\n-             * instead of copying the full tree it is plugged directly\n-             * if called from the parser. Avoid duplicating the\n-             * interfaces or change the API\/ABI\n-             *\/\n-            xmlFreeDocElementContent(ctxt->myDoc, content);\n-        }\n-        } else if (content != NULL) {\n-        xmlFreeDocElementContent(ctxt->myDoc, content);\n+            NEXT;\n+            if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                (ctxt->sax->elementDecl != NULL)) {\n+                if (content != NULL)\n+                    content->parent = NULL;\n+                ctxt->sax->elementDecl(ctxt->userData, name, ret,\n+                                       content);\n+                if ((content != NULL) && (content->parent == NULL)) {\n+                    \/*\n+                     * this is a trick: if xmlAddElementDecl is called,\n+                     * instead of copying the full tree it is plugged directly\n+                     * if called from the parser. Avoid duplicating the\n+                     * interfaces or change the API\/ABI\n+                     *\/\n+                    xmlFreeDocElementContent(ctxt->myDoc, content);\n+                }\n+            } else if (content != NULL) {\n+                xmlFreeDocElementContent(ctxt->myDoc, content);\n+            }\n@@ -6969,1 +6971,0 @@\n-    }\n@@ -7016,4 +7017,11 @@\n-\n-                    inputIdsSize = (inputIdsSize == 0 ? 4 : inputIdsSize * 2);\n-                    tmp = (int *) xmlRealloc(inputIds,\n-                            inputIdsSize * sizeof(int));\n+                    int newSize;\n+\n+                    newSize = xmlGrowCapacity(inputIdsSize, sizeof(tmp[0]),\n+                                              4, 1000);\n+                    if (newSize < 0) {\n+                        xmlFatalErrMsg(ctxt, XML_ERR_RESOURCE_LIMIT,\n+                                       \"Maximum conditional section nesting\"\n+                                       \" depth exceeded\\n\");\n+                        goto error;\n+                    }\n+                    tmp = xmlRealloc(inputIds, newSize * sizeof(tmp[0]));\n@@ -7025,0 +7033,1 @@\n+                    inputIdsSize = newSize;\n@@ -7137,6 +7146,6 @@\n-        switch (NXT(2)) {\n-            case 'E':\n-            if (NXT(3) == 'L')\n-            xmlParseElementDecl(ctxt);\n-            else if (NXT(3) == 'N')\n-            xmlParseEntityDecl(ctxt);\n+            switch (NXT(2)) {\n+                case 'E':\n+                    if (NXT(3) == 'L')\n+                        xmlParseElementDecl(ctxt);\n+                    else if (NXT(3) == 'N')\n+                        xmlParseEntityDecl(ctxt);\n@@ -7145,11 +7154,11 @@\n-            break;\n-            case 'A':\n-            xmlParseAttributeListDecl(ctxt);\n-            break;\n-            case 'N':\n-            xmlParseNotationDecl(ctxt);\n-            break;\n-            case '-':\n-            xmlParseComment(ctxt);\n-            break;\n-        default:\n+                    break;\n+                case 'A':\n+                    xmlParseAttributeListDecl(ctxt);\n+                    break;\n+                case 'N':\n+                    xmlParseNotationDecl(ctxt);\n+                    break;\n+                case '-':\n+                    xmlParseComment(ctxt);\n+                    break;\n+                default:\n@@ -7162,1 +7171,4 @@\n-            break;\n+                    break;\n+            }\n+        } else if (NXT(1) == '?') {\n+            xmlParsePI(ctxt);\n@@ -7164,3 +7176,0 @@\n-    } else if (NXT(1) == '?') {\n-        xmlParsePI(ctxt);\n-    }\n@@ -7189,1 +7198,1 @@\n-    SKIP(5);\n+        SKIP(5);\n@@ -7191,2 +7200,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_STARTED, NULL);\n-    return;\n+        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_STARTED, NULL);\n+        return;\n@@ -7196,2 +7205,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"Space needed after '<?xml'\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                       \"Space needed after '<?xml'\\n\");\n@@ -7205,1 +7214,1 @@\n-    version = xmlCharStrdup(XML_DEFAULT_VERSION);\n+        version = xmlCharStrdup(XML_DEFAULT_VERSION);\n@@ -7211,4 +7220,4 @@\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                   \"Space needed here\\n\");\n-    }\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"Space needed here\\n\");\n+        }\n@@ -7228,2 +7237,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n-    NEXT;\n+        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n+        NEXT;\n@@ -7233,1 +7242,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n@@ -7248,0 +7257,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -7264,1 +7275,1 @@\n-    xmlParseTextDecl(ctxt);\n+        xmlParseTextDecl(ctxt);\n@@ -7268,5 +7279,5 @@\n-    if (ctxt->myDoc == NULL) {\n-        xmlErrMemory(ctxt);\n-        return;\n-    }\n-    ctxt->myDoc->properties = XML_DOC_INTERNAL;\n+        if (ctxt->myDoc == NULL) {\n+            xmlErrMemory(ctxt);\n+            return;\n+        }\n+        ctxt->myDoc->properties = XML_DOC_INTERNAL;\n@@ -7285,1 +7296,1 @@\n-    GROW;\n+        GROW;\n@@ -7302,3 +7313,1 @@\n-    if (RAW != 0) {\n-    xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);\n-    }\n+    xmlParserCheckEOF(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED);\n@@ -7335,3 +7344,3 @@\n-    int i = 0;\n-    xmlChar out[16];\n-    int value = xmlParseCharRef(ctxt);\n+        int i = 0;\n+        xmlChar out[16];\n+        int value = xmlParseCharRef(ctxt);\n@@ -7339,2 +7348,2 @@\n-    if (value == 0)\n-        return;\n+        if (value == 0)\n+            return;\n@@ -7350,1 +7359,1 @@\n-    return;\n+        return;\n@@ -7373,1 +7382,1 @@\n-    return;\n+        return;\n@@ -7378,9 +7387,9 @@\n-    val = ent->content;\n-    if (val == NULL) return;\n-    \/*\n-     * inline the entity.\n-     *\/\n-    if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n-        (!ctxt->disableSAX))\n-        ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));\n-    return;\n+        val = ent->content;\n+        if (val == NULL) return;\n+        \/*\n+         * inline the entity.\n+         *\/\n+        if ((ctxt->sax != NULL) && (ctxt->sax->characters != NULL) &&\n+            (!ctxt->disableSAX))\n+            ctxt->sax->characters(ctxt->userData, val, xmlStrlen(val));\n+        return;\n@@ -7468,3 +7477,3 @@\n-    \/*\n-     * Create a reference\n-     *\/\n+        \/*\n+         * Create a reference\n+         *\/\n@@ -7472,1 +7481,1 @@\n-        ctxt->sax->reference(ctxt->userData, ent->name);\n+            ctxt->sax->reference(ctxt->userData, ent->name);\n@@ -7478,1 +7487,1 @@\n-     *\/\n+         *\/\n@@ -7489,1 +7498,1 @@\n-                (ctxt->sax->cdataBlock == NULL)) {\n+                (ctxt->options & XML_PARSE_NOCDATA)) {\n@@ -7512,1 +7521,1 @@\n-                    (ctxt->sax->cdataBlock == NULL)) {\n+                    (ctxt->options & XML_PARSE_NOCDATA)) {\n@@ -7596,1 +7605,1 @@\n-    } else if ((ctxt->loadsubset) ||\n+    } else if ((ctxt->loadsubset & ~XML_SKIP_IDS) ||\n@@ -7619,1 +7628,1 @@\n-    xmlEntityPtr ent;\n+    xmlEntityPtr ent = NULL;\n@@ -7635,9 +7644,9 @@\n-    if (ctxt->sax->getEntity != NULL)\n-        ent = ctxt->sax->getEntity(ctxt->userData, name);\n-    if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&\n-        (ctxt->options & XML_PARSE_OLDSAX))\n-        ent = xmlGetPredefinedEntity(name);\n-    if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&\n-        (ctxt->userData==ctxt)) {\n-        ent = xmlSAX2GetEntity(ctxt, name);\n-    }\n+        if (ctxt->sax->getEntity != NULL)\n+            ent = ctxt->sax->getEntity(ctxt->userData, name);\n+        if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&\n+            (ctxt->options & XML_PARSE_OLDSAX))\n+            ent = xmlGetPredefinedEntity(name);\n+        if ((ctxt->wellFormed == 1 ) && (ent == NULL) &&\n+            (ctxt->userData==ctxt)) {\n+            ent = xmlSAX2GetEntity(ctxt, name);\n+        }\n@@ -7656,2 +7665,2 @@\n-    xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,\n-         \"Entity reference to unparsed entity %s\\n\", name);\n+        xmlFatalErrMsgStr(ctxt, XML_ERR_UNPARSED_ENTITY,\n+                 \"Entity reference to unparsed entity %s\\n\", name);\n@@ -7699,2 +7708,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"xmlParseEntityRef: no name\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                       \"xmlParseEntityRef: no name\\n\");\n@@ -7704,2 +7713,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n+        return(NULL);\n@@ -7776,1 +7785,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -7781,4 +7790,4 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"xmlParseStringEntityRef: no name\\n\");\n-    *str = ptr;\n-    return(NULL);\n+        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                       \"xmlParseStringEntityRef: no name\\n\");\n+        *str = ptr;\n+        return(NULL);\n@@ -7787,1 +7796,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n@@ -7789,2 +7798,2 @@\n-    *str = ptr;\n-    return(NULL);\n+        *str = ptr;\n+        return(NULL);\n@@ -7842,2 +7851,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, \"PEReference: no name\\n\");\n-    return;\n+        xmlFatalErrMsg(ctxt, XML_ERR_PEREF_NO_NAME, \"PEReference: no name\\n\");\n+        return;\n@@ -7846,1 +7855,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_PEREF_SEMICOL_MISSING, NULL);\n@@ -7859,2 +7868,2 @@\n-    (ctxt->sax->getParameterEntity != NULL))\n-    entity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n+        (ctxt->sax->getParameterEntity != NULL))\n+        entity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n@@ -7865,10 +7874,10 @@\n-    \/*\n-     * Internal checking in case the entity quest barfed\n-     *\/\n-    if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n-        (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n-        xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n-          \"Internal: %%%s; is not a parameter entity\\n\",\n-              name, NULL);\n-    } else {\n-        if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n+        \/*\n+         * Internal checking in case the entity quest barfed\n+         *\/\n+        if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n+            (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n+            xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n+                  \"Internal: %%%s; is not a parameter entity\\n\",\n+                          name, NULL);\n+        } else {\n+            if ((entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) &&\n@@ -7876,4 +7885,4 @@\n-         ((ctxt->loadsubset == 0) &&\n-          (ctxt->replaceEntities == 0) &&\n-          (ctxt->validate == 0))))\n-        return;\n+                 ((ctxt->loadsubset == 0) &&\n+                  (ctxt->replaceEntities == 0) &&\n+                  (ctxt->validate == 0))))\n+                return;\n@@ -7887,2 +7896,2 @@\n-        input = xmlNewEntityInputStream(ctxt, entity);\n-        if (xmlPushInput(ctxt, input) < 0) {\n+            input = xmlNewEntityInputStream(ctxt, entity);\n+            if (xmlCtxtPushInput(ctxt, input) < 0) {\n@@ -7890,1 +7899,1 @@\n-        return;\n+                return;\n@@ -7895,1 +7904,3 @@\n-        if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {\n+            GROW;\n+\n+            if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY) {\n@@ -7903,1 +7914,1 @@\n-    }\n+        }\n@@ -7912,3 +7923,1 @@\n- * Load the original content of the given system entity from the\n- * ExternalID\/SystemID given. This is to be used for Included in Literal\n- * http:\/\/www.w3.org\/TR\/REC-xml\/#inliteral processing of entities references\n+ * Load the content of an entity.\n@@ -7924,0 +7933,1 @@\n+    xmlResourceType rtype;\n@@ -7931,4 +7941,4 @@\n-     (entity->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)) ||\n-    (entity->content != NULL)) {\n-    xmlFatalErr(ctxt, XML_ERR_ARGUMENT,\n-                \"xmlLoadEntityContent parameter error\");\n+         (entity->etype != XML_EXTERNAL_GENERAL_PARSED_ENTITY)) ||\n+        (entity->content != NULL)) {\n+        xmlFatalErr(ctxt, XML_ERR_ARGUMENT,\n+                    \"xmlLoadEntityContent parameter error\");\n@@ -7938,2 +7948,7 @@\n-    input = xmlLoadExternalEntity((char *) entity->URI,\n-           (char *) entity->ExternalID, ctxt);\n+    if (entity->etype == XML_EXTERNAL_PARAMETER_ENTITY)\n+        rtype = XML_RESOURCE_PARAMETER_ENTITY;\n+    else\n+        rtype = XML_RESOURCE_GENERAL_ENTITY;\n+\n+    input = xmlLoadResource(ctxt, (char *) entity->URI,\n+                            (char *) entity->ExternalID, rtype);\n@@ -7962,1 +7977,4 @@\n-    inputPush(ctxt, input);\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n+        xmlFreeInputStream(input);\n+        goto error;\n+    }\n@@ -7970,1 +7988,1 @@\n-    xmlParseTextDecl(ctxt);\n+        xmlParseTextDecl(ctxt);\n@@ -7996,2 +8014,0 @@\n-    content = xmlBufDetach(input->buf->buffer);\n-\n@@ -8003,0 +8019,6 @@\n+    content = xmlStrndup(xmlBufContent(input->buf->buffer), length);\n+    if (content == NULL) {\n+        xmlErrMemory(ctxt);\n+        goto error;\n+    }\n+\n@@ -8024,1 +8046,1 @@\n-        xmlFreeInputStream(inputPop(ctxt));\n+        xmlFreeInputStream(xmlCtxtPopInput(ctxt));\n@@ -8085,4 +8107,4 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"xmlParseStringPEReference: no name\\n\");\n-    *str = ptr;\n-    return(NULL);\n+        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                       \"xmlParseStringPEReference: no name\\n\");\n+        *str = ptr;\n+        return(NULL);\n@@ -8092,4 +8114,4 @@\n-    xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n-    xmlFree(name);\n-    *str = ptr;\n-    return(NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ENTITYREF_SEMICOL_MISSING, NULL);\n+        xmlFree(name);\n+        *str = ptr;\n+        return(NULL);\n@@ -8106,2 +8128,2 @@\n-    (ctxt->sax->getParameterEntity != NULL))\n-    entity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n+        (ctxt->sax->getParameterEntity != NULL))\n+        entity = ctxt->sax->getParameterEntity(ctxt->userData, name);\n@@ -8112,9 +8134,9 @@\n-    \/*\n-     * Internal checking in case the entity quest barfed\n-     *\/\n-    if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n-        (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n-        xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n-              \"%%%s; is not a parameter entity\\n\",\n-              name, NULL);\n-    }\n+        \/*\n+         * Internal checking in case the entity quest barfed\n+         *\/\n+        if ((entity->etype != XML_INTERNAL_PARAMETER_ENTITY) &&\n+            (entity->etype != XML_EXTERNAL_PARAMETER_ENTITY)) {\n+            xmlWarningMsg(ctxt, XML_WAR_UNDECLARED_ENTITY,\n+                          \"%%%s; is not a parameter entity\\n\",\n+                          name, NULL);\n+        }\n@@ -8155,1 +8177,4 @@\n-    SKIP_BLANKS;\n+    if (SKIP_BLANKS == 0) {\n+        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                       \"Space required after 'DOCTYPE'\\n\");\n+    }\n@@ -8162,2 +8187,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"xmlParseDocTypeDecl : no DOCTYPE name !\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                       \"xmlParseDocTypeDecl : no DOCTYPE name !\\n\");\n@@ -8186,9 +8211,2 @@\n-    (!ctxt->disableSAX))\n-    ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);\n-\n-    \/*\n-     * Is there any internal subset declarations ?\n-     * they are handled separately in xmlParseInternalSubset()\n-     *\/\n-    if (RAW == '[')\n-    return;\n+        (!ctxt->disableSAX))\n+        ctxt->sax->internalSubset(ctxt->userData, name, ExternalID, URI);\n@@ -8196,5 +8214,2 @@\n-    \/*\n-     * We should be at the end of the DOCTYPE declaration.\n-     *\/\n-    if (RAW != '>') {\n-    xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);\n+    if ((RAW != '[') && (RAW != '>')) {\n+        xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);\n@@ -8202,1 +8217,0 @@\n-    NEXT;\n@@ -8223,7 +8237,7 @@\n-    \/*\n-     * Parse the succession of Markup declarations and\n-     * PEReferences.\n-     * Subsequence (markupdecl | PEReference | S)*\n-     *\/\n-    SKIP_BLANKS;\n-    while (((RAW != ']') || (ctxt->inputNr > oldInputNr)) &&\n+        \/*\n+         * Parse the succession of Markup declarations and\n+         * PEReferences.\n+         * Subsequence (markupdecl | PEReference | S)*\n+         *\/\n+        SKIP_BLANKS;\n+        while (((RAW != ']') || (ctxt->inputNr > oldInputNr)) &&\n@@ -8240,1 +8254,1 @@\n-            xmlParseMarkupDecl(ctxt);\n+                xmlParseMarkupDecl(ctxt);\n@@ -8242,1 +8256,1 @@\n-            xmlParsePEReference(ctxt);\n+                xmlParsePEReference(ctxt);\n@@ -8244,1 +8258,1 @@\n-        xmlFatalErr(ctxt, XML_ERR_INT_SUBSET_NOT_FINISHED, NULL);\n+                xmlFatalErr(ctxt, XML_ERR_INT_SUBSET_NOT_FINISHED, NULL);\n@@ -8247,1 +8261,1 @@\n-        SKIP_BLANKS_PE;\n+            SKIP_BLANKS_PE;\n@@ -8250,1 +8264,1 @@\n-    }\n+        }\n@@ -8255,4 +8269,4 @@\n-    if (RAW == ']') {\n-        NEXT;\n-        SKIP_BLANKS;\n-    }\n+        if (RAW == ']') {\n+            NEXT;\n+            SKIP_BLANKS;\n+        }\n@@ -8265,2 +8279,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);\n-    return;\n+        xmlFatalErr(ctxt, XML_ERR_DOCTYPE_NOT_FINISHED, NULL);\n+        return;\n@@ -8316,2 +8330,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-                   \"error parsing attribute name\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                       \"error parsing attribute name\\n\");\n@@ -8327,2 +8341,2 @@\n-    SKIP_BLANKS;\n-    val = xmlParseAttValue(ctxt);\n+        SKIP_BLANKS;\n+        val = xmlParseAttValue(ctxt);\n@@ -8330,3 +8344,3 @@\n-    xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,\n-           \"Specification mandates value for attribute %s\\n\", name);\n-    return(name);\n+        xmlFatalErrMsgStr(ctxt, XML_ERR_ATTRIBUTE_WITHOUT_VALUE,\n+               \"Specification mandates value for attribute %s\\n\", name);\n+        return(name);\n@@ -8341,5 +8355,5 @@\n-    if (!xmlCheckLanguageID(val)) {\n-        xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,\n-                  \"Malformed value for xml:lang : %s\\n\",\n-              val, NULL);\n-    }\n+        if (!xmlCheckLanguageID(val)) {\n+            xmlWarningMsg(ctxt, XML_WAR_LANG_VALUE,\n+                          \"Malformed value for xml:lang : %s\\n\",\n+                          val, NULL);\n+        }\n@@ -8352,6 +8366,6 @@\n-    if (xmlStrEqual(val, BAD_CAST \"default\"))\n-        *(ctxt->space) = 0;\n-    else if (xmlStrEqual(val, BAD_CAST \"preserve\"))\n-        *(ctxt->space) = 1;\n-    else {\n-        xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,\n+        if (xmlStrEqual(val, BAD_CAST \"default\"))\n+            *(ctxt->space) = 0;\n+        else if (xmlStrEqual(val, BAD_CAST \"preserve\"))\n+            *(ctxt->space) = 1;\n+        else {\n+                xmlWarningMsg(ctxt, XML_WAR_SPACE_VALUE,\n@@ -8360,1 +8374,1 @@\n-    }\n+        }\n@@ -8411,2 +8425,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-         \"xmlParseStartTag: invalid element name\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+             \"xmlParseStartTag: invalid element name\\n\");\n@@ -8425,3 +8439,3 @@\n-       ((RAW != '\/') || (NXT(1) != '>')) &&\n-       (IS_BYTE_CHAR(RAW))) && (PARSER_STOPPED(ctxt) == 0)) {\n-    attname = xmlParseAttribute(ctxt, &attvalue);\n+           ((RAW != '\/') || (NXT(1) != '>')) &&\n+           (IS_BYTE_CHAR(RAW))) && (PARSER_STOPPED(ctxt) == 0)) {\n+        attname = xmlParseAttribute(ctxt, &attvalue);\n@@ -8429,1 +8443,1 @@\n-        break;\n+            break;\n@@ -8431,29 +8445,17 @@\n-        \/*\n-         * [ WFC: Unique Att Spec ]\n-         * No attribute name may appear more than once in the same\n-         * start-tag or empty-element tag.\n-         *\/\n-        for (i = 0; i < nbatts;i += 2) {\n-            if (xmlStrEqual(atts[i], attname)) {\n-            xmlErrAttributeDup(ctxt, NULL, attname);\n-            xmlFree(attvalue);\n-            goto failed;\n-        }\n-        }\n-        \/*\n-         * Add the pair to atts\n-         *\/\n-        if (atts == NULL) {\n-            maxatts = 22; \/* allow for 10 attrs by default *\/\n-            atts = (const xmlChar **)\n-               xmlMalloc(maxatts * sizeof(xmlChar *));\n-        if (atts == NULL) {\n-            xmlErrMemory(ctxt);\n-            if (attvalue != NULL)\n-            xmlFree(attvalue);\n-            goto failed;\n-        }\n-        ctxt->atts = atts;\n-        ctxt->maxatts = maxatts;\n-        } else if (nbatts + 4 > maxatts) {\n-            const xmlChar **n;\n+            \/*\n+             * [ WFC: Unique Att Spec ]\n+             * No attribute name may appear more than once in the same\n+             * start-tag or empty-element tag.\n+             *\/\n+            for (i = 0; i < nbatts;i += 2) {\n+                if (xmlStrEqual(atts[i], attname)) {\n+                    xmlErrAttributeDup(ctxt, NULL, attname);\n+                    goto failed;\n+                }\n+            }\n+            \/*\n+             * Add the pair to atts\n+             *\/\n+            if (nbatts + 4 > maxatts) {\n+                const xmlChar **n;\n+                int newSize;\n@@ -8461,12 +8463,27 @@\n-            maxatts *= 2;\n-            n = (const xmlChar **) xmlRealloc((void *) atts,\n-                         maxatts * sizeof(const xmlChar *));\n-        if (n == NULL) {\n-            xmlErrMemory(ctxt);\n-            if (attvalue != NULL)\n-            xmlFree(attvalue);\n-            goto failed;\n-        }\n-        atts = n;\n-        ctxt->atts = atts;\n-        ctxt->maxatts = maxatts;\n+                newSize = xmlGrowCapacity(maxatts, sizeof(n[0]) * 2,\n+                                          11, XML_MAX_ATTRS);\n+                if (newSize < 0) {\n+                    xmlErrMemory(ctxt);\n+                    goto failed;\n+                }\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+                if (newSize < 2)\n+                    newSize = 2;\n+#endif\n+                n = xmlRealloc(atts, newSize * sizeof(n[0]) * 2);\n+                if (n == NULL) {\n+                    xmlErrMemory(ctxt);\n+                    goto failed;\n+                }\n+                atts = n;\n+                maxatts = newSize * 2;\n+                ctxt->atts = atts;\n+                ctxt->maxatts = maxatts;\n+            }\n+\n+            atts[nbatts++] = attname;\n+            atts[nbatts++] = attvalue;\n+            atts[nbatts] = NULL;\n+            atts[nbatts + 1] = NULL;\n+\n+            attvalue = NULL;\n@@ -8474,8 +8491,0 @@\n-        atts[nbatts++] = attname;\n-        atts[nbatts++] = attvalue;\n-        atts[nbatts] = NULL;\n-        atts[nbatts + 1] = NULL;\n-    } else {\n-        if (attvalue != NULL)\n-        xmlFree(attvalue);\n-    }\n@@ -8485,8 +8494,11 @@\n-    GROW\n-    if ((RAW == '>') || (((RAW == '\/') && (NXT(1) == '>'))))\n-        break;\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"attributes construct error\\n\");\n-    }\n-    SHRINK;\n+        if (attvalue != NULL)\n+            xmlFree(attvalue);\n+\n+        GROW\n+        if ((RAW == '>') || (((RAW == '\/') && (NXT(1) == '>'))))\n+            break;\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"attributes construct error\\n\");\n+        }\n+        SHRINK;\n@@ -8500,5 +8512,5 @@\n-    (!ctxt->disableSAX)) {\n-    if (nbatts > 0)\n-        ctxt->sax->startElement(ctxt->userData, name, atts);\n-    else\n-        ctxt->sax->startElement(ctxt->userData, name, NULL);\n+        (!ctxt->disableSAX)) {\n+        if (nbatts > 0)\n+            ctxt->sax->startElement(ctxt->userData, name, atts);\n+        else\n+            ctxt->sax->startElement(ctxt->userData, name, NULL);\n@@ -8510,2 +8522,2 @@\n-        if (atts[i] != NULL)\n-           xmlFree((xmlChar *) atts[i]);\n+            if (atts[i] != NULL)\n+               xmlFree((xmlChar *) atts[i]);\n@@ -8537,3 +8549,3 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_LTSLASH_REQUIRED,\n-               \"xmlParseEndTag: '<\/' not found\\n\");\n-    return;\n+        xmlFatalErrMsg(ctxt, XML_ERR_LTSLASH_REQUIRED,\n+                       \"xmlParseEndTag: '<\/' not found\\n\");\n+        return;\n@@ -8551,1 +8563,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n@@ -8553,1 +8565,1 @@\n-    NEXT1;\n+        NEXT1;\n@@ -8564,2 +8576,2 @@\n-             \"Opening and ending tag mismatch: %s line %d and %s\\n\",\n-                        ctxt->name, line, name);\n+                     \"Opening and ending tag mismatch: %s line %d and %s\\n\",\n+                                ctxt->name, line, name);\n@@ -8572,1 +8584,1 @@\n-    (!ctxt->disableSAX))\n+        (!ctxt->disableSAX))\n@@ -8577,1 +8589,0 @@\n-    return;\n@@ -8602,3 +8613,3 @@\n- *                                    *\n- *              SAX 2 specific operations                *\n- *                                    *\n+ *                                                                      *\n+ *                    SAX 2 specific operations                         *\n+ *                                                                      *\n@@ -8717,7 +8728,0 @@\n-    while (*in != 0 && *in == *cmp) {\n-    ++in;\n-    ++cmp;\n-    }\n-    if ((*cmp == 0) && (*in == ':')) {\n-        in++;\n-    cmp = name;\n@@ -8728,2 +8732,9 @@\n-    if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {\n-        \/* success *\/\n+    if ((*cmp == 0) && (*in == ':')) {\n+        in++;\n+        cmp = name;\n+        while (*in != 0 && *in == *cmp) {\n+            ++in;\n+            ++cmp;\n+        }\n+        if (*cmp == 0 && (*in == '>' || IS_BLANK_CH (*in))) {\n+            \/* success *\/\n@@ -8731,3 +8742,3 @@\n-        ctxt->input->cur = in;\n-        return((const xmlChar*) 1);\n-    }\n+            ctxt->input->cur = in;\n+            return((const xmlChar*) 1);\n+        }\n@@ -8742,1 +8753,1 @@\n-    return((const xmlChar*) 1);\n+        return((const xmlChar*) 1);\n@@ -8782,4 +8793,1 @@\n-    if (hprefix->name != NULL)\n-        prefix = hprefix->name;\n-    else\n-        prefix = NULL;\n+    prefix = hprefix->name;\n@@ -8793,3 +8801,2 @@\n-        type = (int) (ptrdiff_t) xmlHashQLookup2(ctxt->attsSpecial,\n-                                                 pref, elem,\n-                                                 prefix, name);\n+        type = XML_PTR_TO_INT(xmlHashQLookup2(ctxt->attsSpecial, pref, elem,\n+                                              prefix, name));\n@@ -8898,1 +8905,1 @@\n-            int nsIndex = (int) (ptrdiff_t) atts[2];\n+            int nsIndex = XML_PTR_TO_INT(atts[2]);\n@@ -9016,2 +9023,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n-               \"StartTag: invalid element name\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_NAME_REQUIRED,\n+                       \"StartTag: invalid element name\\n\");\n@@ -9056,3 +9063,3 @@\n-       ((RAW != '\/') || (NXT(1) != '>')) &&\n-       (IS_BYTE_CHAR(RAW))) && (PARSER_STOPPED(ctxt) == 0)) {\n-    int len = -1;\n+           ((RAW != '\/') || (NXT(1) != '>')) &&\n+           (IS_BYTE_CHAR(RAW))) && (PARSER_STOPPED(ctxt) == 0)) {\n+        int len = -1;\n@@ -9060,1 +9067,1 @@\n-    hattname = xmlParseAttribute2(ctxt, prefix, localname,\n+        hattname = xmlParseAttribute2(ctxt, prefix, localname,\n@@ -9064,1 +9071,1 @@\n-        break;\n+            break;\n@@ -9069,1 +9076,1 @@\n-    if (len < 0) len = xmlStrlen(attvalue);\n+        if (len < 0) len = xmlStrlen(attvalue);\n@@ -9194,3 +9201,2 @@\n-                if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {\n-                    goto next_attr;\n-                }\n+                int res = xmlCtxtGrowAttrs(ctxt);\n+\n@@ -9199,0 +9205,3 @@\n+\n+                if (res < 0)\n+                    goto next_attr;\n@@ -9232,8 +9241,8 @@\n-    GROW\n-    if ((RAW == '>') || (((RAW == '\/') && (NXT(1) == '>'))))\n-        break;\n-    if (SKIP_BLANKS == 0) {\n-        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-               \"attributes construct error\\n\");\n-        break;\n-    }\n+        GROW\n+        if ((RAW == '>') || (((RAW == '\/') && (NXT(1) == '>'))))\n+            break;\n+        if (SKIP_BLANKS == 0) {\n+            xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                           \"attributes construct error\\n\");\n+            break;\n+        }\n@@ -9249,3 +9258,3 @@\n-    defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);\n-    if (defaults != NULL) {\n-        for (i = 0; i < defaults->nbAttrs; i++) {\n+        defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);\n+        if (defaults != NULL) {\n+            for (i = 0; i < defaults->nbAttrs; i++) {\n@@ -9254,2 +9263,2 @@\n-            attname = attr->name.name;\n-        aprefix = attr->prefix.name;\n+                attname = attr->name.name;\n+                aprefix = attr->prefix.name;\n@@ -9257,1 +9266,1 @@\n-        if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {\n+                if ((attname == ctxt->str_xmlns) && (aprefix == NULL)) {\n@@ -9262,1 +9271,1 @@\n-        } else if (aprefix == ctxt->str_xmlns) {\n+                } else if (aprefix == ctxt->str_xmlns) {\n@@ -9268,1 +9277,6 @@\n-        } else {\n+                } else {\n+                    if (nratts + nbTotalDef >= XML_MAX_ATTRS) {\n+                        xmlFatalErr(ctxt, XML_ERR_RESOURCE_LIMIT,\n+                                    \"Maximum number of attributes exceeded\");\n+                        break;\n+                    }\n@@ -9271,0 +9285,1 @@\n+            }\n@@ -9273,1 +9288,0 @@\n-    }\n@@ -9283,3 +9297,3 @@\n-    * The default namespace does not apply to attribute names.\n-    *\/\n-    if (aprefix == NULL) {\n+        * The default namespace does not apply to attribute names.\n+        *\/\n+        if (aprefix == NULL) {\n@@ -9294,1 +9308,1 @@\n-        if ((nsIndex == INT_MAX) || (nsIndex < ctxt->nsdb->minNsIndex)) {\n+            if ((nsIndex == INT_MAX) || (nsIndex < ctxt->nsdb->minNsIndex)) {\n@@ -9296,2 +9310,2 @@\n-            \"Namespace prefix %s for %s on %s is not defined\\n\",\n-            aprefix, attname, localname);\n+                    \"Namespace prefix %s for %s on %s is not defined\\n\",\n+                    aprefix, attname, localname);\n@@ -9302,1 +9316,1 @@\n-        atts[i+2] = (const xmlChar *) (ptrdiff_t) nsIndex;\n+        atts[i+2] = XML_INT_TO_PTR(nsIndex);\n@@ -9340,1 +9354,1 @@\n-            nsIndex = (ptrdiff_t) atts[i+2];\n+            nsIndex = XML_PTR_TO_INT(atts[i+2]);\n@@ -9393,3 +9407,3 @@\n-    defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);\n-    if (defaults != NULL) {\n-        for (i = 0; i < defaults->nbAttrs; i++) {\n+        defaults = xmlHashLookup2(ctxt->attsDefault, localname, prefix);\n+        if (defaults != NULL) {\n+            for (i = 0; i < defaults->nbAttrs; i++) {\n@@ -9397,2 +9411,2 @@\n-                const xmlChar *nsuri;\n-                unsigned hashValue, uriHashValue;\n+                const xmlChar *nsuri = NULL;\n+                unsigned hashValue, uriHashValue = 0;\n@@ -9401,2 +9415,2 @@\n-            attname = attr->name.name;\n-        aprefix = attr->prefix.name;\n+                attname = attr->name.name;\n+                aprefix = attr->prefix.name;\n@@ -9404,1 +9418,1 @@\n-        if ((attname == ctxt->str_xmlns) && (aprefix == NULL))\n+                if ((attname == ctxt->str_xmlns) && (aprefix == NULL))\n@@ -9406,1 +9420,1 @@\n-        if (aprefix == ctxt->str_xmlns)\n+                if (aprefix == ctxt->str_xmlns)\n@@ -9413,1 +9427,1 @@\n-                } if (aprefix == ctxt->str_xml) {\n+                } else if (aprefix == ctxt->str_xml) {\n@@ -9417,1 +9431,1 @@\n-                } else if (aprefix != NULL) {\n+                } else {\n@@ -9455,2 +9469,7 @@\n-                if ((atts == NULL) || (nbatts + 5 > maxatts)) {\n-                    if (xmlCtxtGrowAttrs(ctxt, nbatts + 5) < 0) {\n+                if ((atts == NULL) || (nbatts + 5 > maxatts)) {\n+                    res = xmlCtxtGrowAttrs(ctxt);\n+\n+                    maxatts = ctxt->maxatts;\n+                    atts = ctxt->atts;\n+\n+                    if (res < 0) {\n@@ -9460,2 +9479,0 @@\n-                    maxatts = ctxt->maxatts;\n-                    atts = ctxt->atts;\n@@ -9466,1 +9483,1 @@\n-                atts[nbatts++] = (const xmlChar *) (ptrdiff_t) nsIndex;\n+                atts[nbatts++] = XML_INT_TO_PTR(nsIndex);\n@@ -9476,0 +9493,1 @@\n+            }\n@@ -9478,1 +9496,0 @@\n-    }\n@@ -9522,1 +9539,1 @@\n-        nsIndex = (ptrdiff_t) atts[i+2];\n+        nsIndex = XML_PTR_TO_INT(atts[i+2]);\n@@ -9531,2 +9548,2 @@\n-            atts[i+3] = BASE_PTR + (ptrdiff_t) atts[i+3];  \/* value *\/\n-            atts[i+4] = BASE_PTR + (ptrdiff_t) atts[i+4];  \/* valuend *\/\n+            atts[i+3] = BASE_PTR + XML_PTR_TO_INT(atts[i+3]);  \/* value *\/\n+            atts[i+4] = BASE_PTR + XML_PTR_TO_INT(atts[i+4]);  \/* valuend *\/\n@@ -9538,3 +9555,3 @@\n-    xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n-             \"Namespace prefix %s on %s is not defined\\n\",\n-         prefix, localname, NULL);\n+        xmlNsErr(ctxt, XML_NS_ERR_UNDEFINED_NAMESPACE,\n+                 \"Namespace prefix %s on %s is not defined\\n\",\n+                 prefix, localname, NULL);\n@@ -9549,3 +9566,3 @@\n-    (!ctxt->disableSAX)) {\n-    if (nbNs > 0)\n-        ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,\n+        (!ctxt->disableSAX)) {\n+        if (nbNs > 0)\n+            ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,\n@@ -9553,3 +9570,3 @@\n-              nbatts \/ 5, nbdef, atts);\n-    else\n-        ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,\n+                          nbatts \/ 5, nbdef, atts);\n+        else\n+            ctxt->sax->startElementNs(ctxt->userData, localname, prefix, uri,\n@@ -9564,3 +9581,3 @@\n-    for (i = 0, j = 0; j < nratts; i += 5, j++)\n-        if (ctxt->attallocs[j] & 0x80000000)\n-            xmlFree((xmlChar *) atts[i+3]);\n+        for (i = 0, j = 0; j < nratts; i += 5, j++)\n+            if (ctxt->attallocs[j] & 0x80000000)\n+                xmlFree((xmlChar *) atts[i+3]);\n@@ -9594,2 +9611,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);\n-    return;\n+        xmlFatalErr(ctxt, XML_ERR_LTSLASH_REQUIRED, NULL);\n+        return;\n@@ -9610,1 +9627,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_GT_REQUIRED, NULL);\n@@ -9612,1 +9629,1 @@\n-    NEXT1;\n+        NEXT1;\n@@ -9623,2 +9640,2 @@\n-             \"Opening and ending tag mismatch: %s line %d and %s\\n\",\n-                        ctxt->name, tag->line, name);\n+                     \"Opening and ending tag mismatch: %s line %d and %s\\n\",\n+                                ctxt->name, tag->line, name);\n@@ -9631,2 +9648,2 @@\n-    (!ctxt->disableSAX))\n-    ctxt->sax->endElementNs(ctxt->userData, ctxt->name, tag->prefix,\n+        (!ctxt->disableSAX))\n+        ctxt->sax->endElementNs(ctxt->userData, ctxt->name, tag->prefix,\n@@ -9637,1 +9654,1 @@\n-    xmlParserNsPop(ctxt, tag->nsNr);\n+        xmlParserNsPop(ctxt, tag->nsNr);\n@@ -9662,1 +9679,1 @@\n-    int    s, sl;\n+    int s, sl;\n@@ -9676,1 +9693,1 @@\n-    r = CUR_CHAR(rl);\n+    r = xmlCurrentCharRecover(ctxt, &rl);\n@@ -9678,1 +9695,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);\n@@ -9682,1 +9699,1 @@\n-    s = CUR_CHAR(sl);\n+    s = xmlCurrentCharRecover(ctxt, &sl);\n@@ -9684,1 +9701,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_CDATA_NOT_FINISHED, NULL);\n@@ -9688,2 +9705,2 @@\n-    cur = CUR_CHAR(l);\n-    buf = (xmlChar *) xmlMallocAtomic(size);\n+    cur = xmlCurrentCharRecover(ctxt, &l);\n+    buf = xmlMalloc(size);\n@@ -9691,1 +9708,1 @@\n-    xmlErrMemory(ctxt);\n+        xmlErrMemory(ctxt);\n@@ -9696,2 +9713,3 @@\n-    if (len + 5 >= size) {\n-        xmlChar *tmp;\n+        if (len + 5 >= size) {\n+            xmlChar *tmp;\n+            int newSize;\n@@ -9699,3 +9717,4 @@\n-        tmp = (xmlChar *) xmlRealloc(buf, size * 2);\n-        if (tmp == NULL) {\n-        xmlErrMemory(ctxt);\n+            newSize = xmlGrowCapacity(size, 1, 1, maxLength);\n+            if (newSize < 0) {\n+                xmlFatalErrMsg(ctxt, XML_ERR_CDATA_NOT_FINISHED,\n+                               \"CData section too big found\\n\");\n@@ -9703,0 +9722,8 @@\n+            }\n+            tmp = xmlRealloc(buf, newSize);\n+            if (tmp == NULL) {\n+                xmlErrMemory(ctxt);\n+                goto out;\n+            }\n+            buf = tmp;\n+            size = newSize;\n@@ -9704,15 +9731,7 @@\n-        buf = tmp;\n-        size *= 2;\n-    }\n-    COPY_BUF(buf, len, r);\n-        if (len > maxLength) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_CDATA_NOT_FINISHED,\n-                           \"CData section too big found\\n\");\n-            goto out;\n-        }\n-    r = s;\n-    rl = sl;\n-    s = cur;\n-    sl = l;\n-    NEXTL(l);\n-    cur = CUR_CHAR(l);\n+        COPY_BUF(buf, len, r);\n+        r = s;\n+        rl = sl;\n+        s = cur;\n+        sl = l;\n+        NEXTL(l);\n+        cur = xmlCurrentCharRecover(ctxt, &l);\n@@ -9722,2 +9741,2 @@\n-    xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,\n-                         \"CData section not finished\\n%.50s\\n\", buf);\n+        xmlFatalErrMsgStr(ctxt, XML_ERR_CDATA_NOT_FINISHED,\n+                             \"CData section not finished\\n%.50s\\n\", buf);\n@@ -9732,4 +9751,6 @@\n-    if (ctxt->sax->cdataBlock != NULL)\n-        ctxt->sax->cdataBlock(ctxt->userData, buf, len);\n-    else if (ctxt->sax->characters != NULL)\n-        ctxt->sax->characters(ctxt->userData, buf, len);\n+        if ((ctxt->sax->cdataBlock != NULL) &&\n+            ((ctxt->options & XML_PARSE_NOCDATA) == 0)) {\n+            ctxt->sax->cdataBlock(ctxt->userData, buf, len);\n+        } else if (ctxt->sax->characters != NULL) {\n+            ctxt->sax->characters(ctxt->userData, buf, len);\n+        }\n@@ -9758,2 +9779,2 @@\n-       (PARSER_STOPPED(ctxt) == 0)) {\n-    const xmlChar *cur = ctxt->input->cur;\n+           (PARSER_STOPPED(ctxt) == 0)) {\n+        const xmlChar *cur = ctxt->input->cur;\n@@ -9761,6 +9782,6 @@\n-    \/*\n-     * First case : a Processing Instruction.\n-     *\/\n-    if ((*cur == '<') && (cur[1] == '?')) {\n-        xmlParsePI(ctxt);\n-    }\n+        \/*\n+         * First case : a Processing Instruction.\n+         *\/\n+        if ((*cur == '<') && (cur[1] == '?')) {\n+            xmlParsePI(ctxt);\n+        }\n@@ -9768,7 +9789,7 @@\n-    \/*\n-     * Second case : a CDSection\n-     *\/\n-    \/* 2.6.0 test was *cur not RAW *\/\n-    else if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {\n-        xmlParseCDSect(ctxt);\n-    }\n+        \/*\n+         * Second case : a CDSection\n+         *\/\n+        \/* 2.6.0 test was *cur not RAW *\/\n+        else if (CMP9(CUR_PTR, '<', '!', '[', 'C', 'D', 'A', 'T', 'A', '[')) {\n+            xmlParseCDSect(ctxt);\n+        }\n@@ -9776,7 +9797,7 @@\n-    \/*\n-     * Third case :  a comment\n-     *\/\n-    else if ((*cur == '<') && (NXT(1) == '!') &&\n-         (NXT(2) == '-') && (NXT(3) == '-')) {\n-        xmlParseComment(ctxt);\n-    }\n+        \/*\n+         * Third case :  a comment\n+         *\/\n+        else if ((*cur == '<') && (NXT(1) == '!') &&\n+                 (NXT(2) == '-') && (NXT(3) == '-')) {\n+            xmlParseComment(ctxt);\n+        }\n@@ -9784,4 +9805,4 @@\n-    \/*\n-     * Fourth case :  a sub-element.\n-     *\/\n-    else if (*cur == '<') {\n+        \/*\n+         * Fourth case :  a sub-element.\n+         *\/\n+        else if (*cur == '<') {\n@@ -9791,1 +9812,1 @@\n-            xmlParseElementEnd(ctxt);\n+                xmlParseElementEnd(ctxt);\n@@ -9793,1 +9814,1 @@\n-            xmlParseElementStart(ctxt);\n+                xmlParseElementStart(ctxt);\n@@ -9795,1 +9816,1 @@\n-    }\n+        }\n@@ -9797,4 +9818,4 @@\n-    \/*\n-     * Fifth case : a reference. If if has not been resolved,\n-     *    parsing returns it's Name, create the node\n-     *\/\n+        \/*\n+         * Fifth case : a reference. If if has not been resolved,\n+         *    parsing returns it's Name, create the node\n+         *\/\n@@ -9802,3 +9823,3 @@\n-    else if (*cur == '&') {\n-        xmlParseReference(ctxt);\n-    }\n+        else if (*cur == '&') {\n+            xmlParseReference(ctxt);\n+        }\n@@ -9806,6 +9827,6 @@\n-    \/*\n-     * Last case, text. Note that References are handled directly.\n-     *\/\n-    else {\n-        xmlParseCharDataInternal(ctxt, 0);\n-    }\n+        \/*\n+         * Last case, text. Note that References are handled directly.\n+         *\/\n+        else {\n+            xmlParseCharDataInternal(ctxt, 0);\n+        }\n@@ -9813,2 +9834,2 @@\n-    SHRINK;\n-    GROW;\n+        SHRINK;\n+        GROW;\n@@ -9853,1 +9874,1 @@\n- * xmlParseInNodeContext.\n+ * xmlCtxtParseContent.\n@@ -9864,2 +9885,1 @@\n-    if (ctxt->input->cur < ctxt->input->end)\n-    xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n+    xmlParserCheckEOF(ctxt, XML_ERR_NOT_WELL_BALANCED);\n@@ -9929,2 +9949,2 @@\n-    xmlHaltParser(ctxt);\n-    return(-1);\n+        xmlHaltParser(ctxt);\n+        return(-1);\n@@ -9937,1 +9957,1 @@\n-    node_info.begin_line = ctxt->input->line;\n+        node_info.begin_line = ctxt->input->line;\n@@ -9941,1 +9961,1 @@\n-    spacePush(ctxt, -1);\n+        spacePush(ctxt, -1);\n@@ -9943,1 +9963,1 @@\n-    spacePush(ctxt, -1);\n+        spacePush(ctxt, -1);\n@@ -9945,1 +9965,1 @@\n-    spacePush(ctxt, *ctxt->space);\n+        spacePush(ctxt, *ctxt->space);\n@@ -9954,1 +9974,1 @@\n-    name = xmlParseStartTag(ctxt);\n+        name = xmlParseStartTag(ctxt);\n@@ -9957,1 +9977,1 @@\n-    spacePop(ctxt);\n+        spacePop(ctxt);\n@@ -9979,4 +9999,4 @@\n-    if (ctxt->sax2) {\n-        if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&\n-        (!ctxt->disableSAX))\n-        ctxt->sax->endElementNs(ctxt->userData, name, prefix, URI);\n+        if (ctxt->sax2) {\n+            if ((ctxt->sax != NULL) && (ctxt->sax->endElementNs != NULL) &&\n+                (!ctxt->disableSAX))\n+                ctxt->sax->endElementNs(ctxt->userData, name, prefix, URI);\n@@ -9984,4 +10004,4 @@\n-    } else {\n-        if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&\n-        (!ctxt->disableSAX))\n-        ctxt->sax->endElement(ctxt->userData, name);\n+        } else {\n+            if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL) &&\n+                (!ctxt->disableSAX))\n+                ctxt->sax->endElement(ctxt->userData, name);\n@@ -9989,6 +10009,6 @@\n-    }\n-    namePop(ctxt);\n-    spacePop(ctxt);\n-    if (nbNs > 0)\n-        xmlParserNsPop(ctxt, nbNs);\n-    if (cur != NULL && ctxt->record_info) {\n+        }\n+        namePop(ctxt);\n+        spacePop(ctxt);\n+        if (nbNs > 0)\n+            xmlParserNsPop(ctxt, nbNs);\n+        if (cur != NULL && ctxt->record_info) {\n@@ -10000,2 +10020,2 @@\n-    }\n-    return(1);\n+        }\n+        return(1);\n@@ -10013,2 +10033,2 @@\n-             \"Couldn't find end of Start Tag %s line %d\\n\",\n-                        name, line, NULL);\n+                     \"Couldn't find end of Start Tag %s line %d\\n\",\n+                                name, line, NULL);\n@@ -10016,9 +10036,9 @@\n-    \/*\n-     * end of parsing of this node.\n-     *\/\n-    nodePop(ctxt);\n-    namePop(ctxt);\n-    spacePop(ctxt);\n-    if (nbNs > 0)\n-        xmlParserNsPop(ctxt, nbNs);\n-    return(-1);\n+        \/*\n+         * end of parsing of this node.\n+         *\/\n+        nodePop(ctxt);\n+        namePop(ctxt);\n+        spacePop(ctxt);\n+        if (nbNs > 0)\n+            xmlParserNsPop(ctxt, nbNs);\n+        return(-1);\n@@ -10050,2 +10070,2 @@\n-    xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);\n-    namePop(ctxt);\n+        xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);\n+        namePop(ctxt);\n@@ -10055,1 +10075,1 @@\n-    xmlParseEndTag1(ctxt, 0);\n+        xmlParseEndTag1(ctxt, 0);\n@@ -10092,0 +10112,3 @@\n+    int maxLength = (ctxt->options & XML_PARSE_HUGE) ?\n+                    XML_MAX_TEXT_LENGTH :\n+                    XML_MAX_NAME_LENGTH;\n@@ -10094,1 +10117,1 @@\n-    buf = (xmlChar *) xmlMallocAtomic(size);\n+    buf = xmlMalloc(size);\n@@ -10096,2 +10119,2 @@\n-    xmlErrMemory(ctxt);\n-    return(NULL);\n+        xmlErrMemory(ctxt);\n+        return(NULL);\n@@ -10101,2 +10124,2 @@\n-    xmlFree(buf);\n-    return(NULL);\n+        xmlFree(buf);\n+        return(NULL);\n@@ -10108,2 +10131,2 @@\n-    xmlFree(buf);\n-    return(NULL);\n+        xmlFree(buf);\n+        return(NULL);\n@@ -10115,2 +10138,3 @@\n-    if (len + 1 >= size) {\n-        xmlChar *tmp;\n+        if (len + 1 >= size) {\n+            xmlChar *tmp;\n+            int newSize;\n@@ -10118,6 +10142,14 @@\n-        size *= 2;\n-        tmp = (xmlChar *) xmlRealloc(buf, size);\n-        if (tmp == NULL) {\n-            xmlFree(buf);\n-        xmlErrMemory(ctxt);\n-        return(NULL);\n+            newSize = xmlGrowCapacity(size, 1, 1, maxLength);\n+            if (newSize < 0) {\n+                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"VersionNum\");\n+                xmlFree(buf);\n+                return(NULL);\n+            }\n+            tmp = xmlRealloc(buf, newSize);\n+            if (tmp == NULL) {\n+                xmlErrMemory(ctxt);\n+                xmlFree(buf);\n+                return(NULL);\n+            }\n+            buf = tmp;\n+            size = newSize;\n@@ -10125,5 +10157,3 @@\n-        buf = tmp;\n-    }\n-    buf[len++] = cur;\n-    NEXT;\n-    cur=CUR;\n+        buf[len++] = cur;\n+        NEXT;\n+        cur=CUR;\n@@ -10155,5 +10185,5 @@\n-    SKIP(7);\n-    SKIP_BLANKS;\n-    if (RAW != '=') {\n-        xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);\n-        return(NULL);\n+        SKIP(7);\n+        SKIP_BLANKS;\n+        if (RAW != '=') {\n+            xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);\n+            return(NULL);\n@@ -10161,3 +10191,0 @@\n-    NEXT;\n-    SKIP_BLANKS;\n-    if (RAW == '\"') {\n@@ -10165,4 +10192,2 @@\n-        version = xmlParseVersionNum(ctxt);\n-        if (RAW != '\"') {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n-        } else\n+        SKIP_BLANKS;\n+        if (RAW == '\"') {\n@@ -10170,6 +10195,6 @@\n-    } else if (RAW == '\\''){\n-        NEXT;\n-        version = xmlParseVersionNum(ctxt);\n-        if (RAW != '\\'') {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n-        } else\n+            version = xmlParseVersionNum(ctxt);\n+            if (RAW != '\"') {\n+                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n+            } else\n+                NEXT;\n+        } else if (RAW == '\\''){\n@@ -10177,3 +10202,8 @@\n-    } else {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);\n-    }\n+            version = xmlParseVersionNum(ctxt);\n+            if (RAW != '\\'') {\n+                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n+            } else\n+                NEXT;\n+        } else {\n+            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);\n+        }\n@@ -10209,20 +10239,2 @@\n-    buf = (xmlChar *) xmlMallocAtomic(size);\n-    if (buf == NULL) {\n-        xmlErrMemory(ctxt);\n-        return(NULL);\n-    }\n-\n-    buf[len++] = cur;\n-    NEXT;\n-    cur = CUR;\n-    while (((cur >= 'a') && (cur <= 'z')) ||\n-           ((cur >= 'A') && (cur <= 'Z')) ||\n-           ((cur >= '0') && (cur <= '9')) ||\n-           (cur == '.') || (cur == '_') ||\n-           (cur == '-')) {\n-        if (len + 1 >= size) {\n-            xmlChar *tmp;\n-\n-        size *= 2;\n-        tmp = (xmlChar *) xmlRealloc(buf, size);\n-        if (tmp == NULL) {\n+        buf = xmlMalloc(size);\n+        if (buf == NULL) {\n@@ -10230,1 +10242,0 @@\n-            xmlFree(buf);\n@@ -10233,2 +10244,1 @@\n-        buf = tmp;\n-        }\n+\n@@ -10236,5 +10246,0 @@\n-            if (len > maxLength) {\n-                xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"EncName\");\n-                xmlFree(buf);\n-                return(NULL);\n-            }\n@@ -10243,0 +10248,27 @@\n+        while (((cur >= 'a') && (cur <= 'z')) ||\n+               ((cur >= 'A') && (cur <= 'Z')) ||\n+               ((cur >= '0') && (cur <= '9')) ||\n+               (cur == '.') || (cur == '_') ||\n+               (cur == '-')) {\n+            if (len + 1 >= size) {\n+                xmlChar *tmp;\n+                int newSize;\n+\n+                newSize = xmlGrowCapacity(size, 1, 1, maxLength);\n+                if (newSize < 0) {\n+                    xmlFatalErr(ctxt, XML_ERR_NAME_TOO_LONG, \"EncName\");\n+                    xmlFree(buf);\n+                    return(NULL);\n+                }\n+                tmp = xmlRealloc(buf, newSize);\n+                if (tmp == NULL) {\n+                    xmlErrMemory(ctxt);\n+                    xmlFree(buf);\n+                    return(NULL);\n+                }\n+                buf = tmp;\n+                size = newSize;\n+            }\n+            buf[len++] = cur;\n+            NEXT;\n+            cur = CUR;\n@@ -10244,1 +10276,1 @@\n-    buf[len] = 0;\n+        buf[len] = 0;\n@@ -10246,1 +10278,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_ENCODING_NAME, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_ENCODING_NAME, NULL);\n@@ -10341,2 +10373,2 @@\n- *      (A standalone value of -2 means that the XML declaration was found,\n- *       but no value was specified for the standalone attribute).\n+ *        (A standalone value of -2 means that the XML declaration was found,\n+ *         but no value was specified for the standalone attribute).\n@@ -10351,1 +10383,1 @@\n-    SKIP(10);\n+        SKIP(10);\n@@ -10353,3 +10385,3 @@\n-    if (RAW != '=') {\n-        xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);\n-        return(standalone);\n+        if (RAW != '=') {\n+            xmlFatalErr(ctxt, XML_ERR_EQUAL_REQUIRED, NULL);\n+            return(standalone);\n@@ -10357,3 +10389,0 @@\n-    NEXT;\n-    SKIP_BLANKS;\n-        if (RAW == '\\''){\n@@ -10361,2 +10390,5 @@\n-        if ((RAW == 'n') && (NXT(1) == 'o')) {\n-            standalone = 0;\n+        SKIP_BLANKS;\n+        if (RAW == '\\''){\n+            NEXT;\n+            if ((RAW == 'n') && (NXT(1) == 'o')) {\n+                standalone = 0;\n@@ -10364,4 +10396,4 @@\n-        } else if ((RAW == 'y') && (NXT(1) == 'e') &&\n-                   (NXT(2) == 's')) {\n-            standalone = 1;\n-        SKIP(3);\n+            } else if ((RAW == 'y') && (NXT(1) == 'e') &&\n+                       (NXT(2) == 's')) {\n+                standalone = 1;\n+                SKIP(3);\n@@ -10369,5 +10401,7 @@\n-        xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);\n-        }\n-        if (RAW != '\\'') {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n-        } else\n+                xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);\n+            }\n+            if (RAW != '\\'') {\n+                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n+            } else\n+                NEXT;\n+        } else if (RAW == '\"'){\n@@ -10375,8 +10409,6 @@\n-    } else if (RAW == '\"'){\n-        NEXT;\n-        if ((RAW == 'n') && (NXT(1) == 'o')) {\n-            standalone = 0;\n-        SKIP(2);\n-        } else if ((RAW == 'y') && (NXT(1) == 'e') &&\n-                   (NXT(2) == 's')) {\n-            standalone = 1;\n+            if ((RAW == 'n') && (NXT(1) == 'o')) {\n+                standalone = 0;\n+                SKIP(2);\n+            } else if ((RAW == 'y') && (NXT(1) == 'e') &&\n+                       (NXT(2) == 's')) {\n+                standalone = 1;\n@@ -10385,8 +10417,8 @@\n-        xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);\n-        }\n-        if (RAW != '\"') {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n-        } else\n-            NEXT;\n-    } else {\n-        xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);\n+                xmlFatalErr(ctxt, XML_ERR_STANDALONE_VALUE, NULL);\n+            }\n+            if (RAW != '\"') {\n+                xmlFatalErr(ctxt, XML_ERR_STRING_NOT_CLOSED, NULL);\n+            } else\n+                NEXT;\n+        } else {\n+            xmlFatalErr(ctxt, XML_ERR_STRING_NOT_STARTED, NULL);\n@@ -10427,2 +10459,2 @@\n-    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n-                   \"Blank needed after '<?xml'\\n\");\n+        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED,\n+                       \"Blank needed after '<?xml'\\n\");\n@@ -10437,1 +10469,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_VERSION_MISSING, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_VERSION_MISSING, NULL);\n@@ -10439,18 +10471,19 @@\n-    if (!xmlStrEqual(version, (const xmlChar *) XML_DEFAULT_VERSION)) {\n-        \/*\n-         * Changed here for XML-1.0 5th edition\n-         *\/\n-        if (ctxt->options & XML_PARSE_OLD10) {\n-        xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,\n-                      \"Unsupported version '%s'\\n\",\n-                      version);\n-        } else {\n-            if ((version[0] == '1') && ((version[1] == '.'))) {\n-            xmlWarningMsg(ctxt, XML_WAR_UNKNOWN_VERSION,\n-                          \"Unsupported version '%s'\\n\",\n-                  version, NULL);\n-        } else {\n-            xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,\n-                      \"Unsupported version '%s'\\n\",\n-                      version);\n-        }\n+        if (!xmlStrEqual(version, (const xmlChar *) XML_DEFAULT_VERSION)) {\n+            \/*\n+             * Changed here for XML-1.0 5th edition\n+             *\/\n+            if (ctxt->options & XML_PARSE_OLD10) {\n+                xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,\n+                                  \"Unsupported version '%s'\\n\",\n+                                  version);\n+            } else {\n+                if ((version[0] == '1') && ((version[1] == '.'))) {\n+                    xmlWarningMsg(ctxt, XML_WAR_UNKNOWN_VERSION,\n+                                  \"Unsupported version '%s'\\n\",\n+                                  version, NULL);\n+                } else {\n+                    xmlFatalErrMsgStr(ctxt, XML_ERR_UNKNOWN_VERSION,\n+                                      \"Unsupported version '%s'\\n\",\n+                                      version);\n+                }\n+            }\n@@ -10458,4 +10491,3 @@\n-    }\n-    if (ctxt->version != NULL)\n-        xmlFree((void *) ctxt->version);\n-    ctxt->version = version;\n+        if (ctxt->version != NULL)\n+            xmlFree((void *) ctxt->version);\n+        ctxt->version = version;\n@@ -10469,4 +10501,4 @@\n-        SKIP(2);\n-        return;\n-    }\n-    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, \"Blank needed here\\n\");\n+            SKIP(2);\n+            return;\n+        }\n+        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, \"Blank needed here\\n\");\n@@ -10481,4 +10513,4 @@\n-        SKIP(2);\n-        return;\n-    }\n-    xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, \"Blank needed here\\n\");\n+            SKIP(2);\n+            return;\n+        }\n+        xmlFatalErrMsg(ctxt, XML_ERR_SPACE_REQUIRED, \"Blank needed here\\n\");\n@@ -10500,2 +10532,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n-    NEXT;\n+        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n+        NEXT;\n@@ -10505,1 +10537,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_XMLDECL_NOT_FINISHED, NULL);\n@@ -10515,0 +10547,32 @@\n+\/**\n+ * xmlCtxtGetVersion:\n+ * @ctxt:  parser context\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns the version from the XML declaration.\n+ *\/\n+const xmlChar *\n+xmlCtxtGetVersion(xmlParserCtxtPtr ctxt) {\n+    if (ctxt == NULL)\n+        return(NULL);\n+\n+    return(ctxt->version);\n+}\n+\n+\/**\n+ * xmlCtxtGetStandalone:\n+ * @ctxt:  parser context\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns the value from the standalone document declaration.\n+ *\/\n+int\n+xmlCtxtGetStandalone(xmlParserCtxtPtr ctxt) {\n+    if (ctxt == NULL)\n+        return(0);\n+\n+    return(ctxt->standalone);\n+}\n+\n@@ -10532,1 +10596,1 @@\n-        xmlParsePI(ctxt);\n+            xmlParsePI(ctxt);\n@@ -10534,1 +10598,1 @@\n-        xmlParseComment(ctxt);\n+            xmlParseComment(ctxt);\n@@ -10567,1 +10631,1 @@\n-    if (xmlStrEqual(doc->version, SAX_COMPAT_MODE)) {\n+        if (xmlStrEqual(doc->version, SAX_COMPAT_MODE)) {\n@@ -10605,2 +10669,2 @@\n-    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n-    return(-1);\n+        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n+        return(-1);\n@@ -10612,5 +10676,5 @@\n-    \/*\n-     * Note that we will switch encoding on the fly.\n-     *\/\n-    xmlParseXMLDecl(ctxt);\n-    SKIP_BLANKS;\n+        \/*\n+         * Note that we will switch encoding on the fly.\n+         *\/\n+        xmlParseXMLDecl(ctxt);\n+        SKIP_BLANKS;\n@@ -10618,1 +10682,1 @@\n-    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n+        ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n@@ -10628,1 +10692,1 @@\n-    ctxt->myDoc->compression = ctxt->input->buf->compressed;\n+        ctxt->myDoc->compression = ctxt->input->buf->compressed;\n@@ -10643,5 +10707,7 @@\n-    ctxt->inSubset = 1;\n-    xmlParseDocTypeDecl(ctxt);\n-    if (RAW == '[') {\n-        xmlParseInternalSubset(ctxt);\n-    }\n+        ctxt->inSubset = 1;\n+        xmlParseDocTypeDecl(ctxt);\n+        if (RAW == '[') {\n+            xmlParseInternalSubset(ctxt);\n+        } else if (RAW == '>') {\n+            NEXT;\n+        }\n@@ -10649,9 +10715,9 @@\n-    \/*\n-     * Create and update the external subset.\n-     *\/\n-    ctxt->inSubset = 2;\n-    if ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&\n-        (!ctxt->disableSAX))\n-        ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n-                                  ctxt->extSubSystem, ctxt->extSubURI);\n-    ctxt->inSubset = 0;\n+        \/*\n+         * Create and update the external subset.\n+         *\/\n+        ctxt->inSubset = 2;\n+        if ((ctxt->sax != NULL) && (ctxt->sax->externalSubset != NULL) &&\n+            (!ctxt->disableSAX))\n+            ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n+                                      ctxt->extSubSystem, ctxt->extSubURI);\n+        ctxt->inSubset = 0;\n@@ -10661,1 +10727,1 @@\n-    xmlParseMisc(ctxt);\n+        xmlParseMisc(ctxt);\n@@ -10673,1 +10739,1 @@\n-    xmlParseElement(ctxt);\n+        xmlParseElement(ctxt);\n@@ -10675,4 +10741,4 @@\n-    \/*\n-     * The Misc part at the end\n-     *\/\n-    xmlParseMisc(ctxt);\n+        \/*\n+         * The Misc part at the end\n+         *\/\n+        xmlParseMisc(ctxt);\n@@ -10680,10 +10746,1 @@\n-        if (ctxt->input->cur < ctxt->input->end) {\n-            if (ctxt->wellFormed)\n-            xmlFatalErr(ctxt, XML_ERR_DOCUMENT_END, NULL);\n-        } else if ((ctxt->input->buf != NULL) &&\n-                   (ctxt->input->buf->encoder != NULL) &&\n-                   (ctxt->input->buf->error == 0) &&\n-                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-                           \"Truncated multi-byte sequence at EOF\\n\");\n-        }\n+        xmlParserCheckEOF(ctxt, XML_ERR_DOCUMENT_END);\n@@ -10696,2 +10753,2 @@\n-    ctxt->valid = 0;\n-    return(-1);\n+        ctxt->valid = 0;\n+        return(-1);\n@@ -10707,0 +10764,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -10732,1 +10791,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n@@ -10741,5 +10800,5 @@\n-    \/*\n-     * Note that we will switch encoding on the fly.\n-     *\/\n-    xmlParseXMLDecl(ctxt);\n-    SKIP_BLANKS;\n+        \/*\n+         * Note that we will switch encoding on the fly.\n+         *\/\n+        xmlParseXMLDecl(ctxt);\n+        SKIP_BLANKS;\n@@ -10747,1 +10806,1 @@\n-    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n+        ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n@@ -10762,1 +10821,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n@@ -10776,3 +10835,3 @@\n- *                                    *\n- *        Progressive parsing interfaces                *\n- *                                    *\n+ *                                                                      *\n+ *              Progressive parsing interfaces                          *\n+ *                                                                      *\n@@ -11039,68 +11098,0 @@\n-\/**\n- * xmlCheckCdataPush:\n- * @cur: pointer to the block of characters\n- * @len: length of the block in bytes\n- * @complete: 1 if complete CDATA block is passed in, 0 if partial block\n- *\n- * Check that the block of characters is okay as SCdata content [20]\n- *\n- * Returns the number of bytes to pass if okay, a negative index where an\n- *         UTF-8 error occurred otherwise\n- *\/\n-static int\n-xmlCheckCdataPush(const xmlChar *utf, int len, int complete) {\n-    int ix;\n-    unsigned char c;\n-    int codepoint;\n-\n-    if ((utf == NULL) || (len <= 0))\n-        return(0);\n-\n-    for (ix = 0; ix < len;) {      \/* string is 0-terminated *\/\n-        c = utf[ix];\n-        if ((c & 0x80) == 0x00) {    \/* 1-byte code, starts with 10 *\/\n-        if (c >= 0x20)\n-        ix++;\n-        else if ((c == 0xA) || (c == 0xD) || (c == 0x9))\n-            ix++;\n-        else\n-            return(-ix);\n-    } else if ((c & 0xe0) == 0xc0) {\/* 2-byte code, starts with 110 *\/\n-        if (ix + 2 > len) return(complete ? -ix : ix);\n-        if ((utf[ix+1] & 0xc0 ) != 0x80)\n-            return(-ix);\n-        codepoint = (utf[ix] & 0x1f) << 6;\n-        codepoint |= utf[ix+1] & 0x3f;\n-        if (!xmlIsCharQ(codepoint))\n-            return(-ix);\n-        ix += 2;\n-    } else if ((c & 0xf0) == 0xe0) {\/* 3-byte code, starts with 1110 *\/\n-        if (ix + 3 > len) return(complete ? -ix : ix);\n-        if (((utf[ix+1] & 0xc0) != 0x80) ||\n-            ((utf[ix+2] & 0xc0) != 0x80))\n-            return(-ix);\n-        codepoint = (utf[ix] & 0xf) << 12;\n-        codepoint |= (utf[ix+1] & 0x3f) << 6;\n-        codepoint |= utf[ix+2] & 0x3f;\n-        if (!xmlIsCharQ(codepoint))\n-            return(-ix);\n-        ix += 3;\n-    } else if ((c & 0xf8) == 0xf0) {\/* 4-byte code, starts with 11110 *\/\n-        if (ix + 4 > len) return(complete ? -ix : ix);\n-        if (((utf[ix+1] & 0xc0) != 0x80) ||\n-            ((utf[ix+2] & 0xc0) != 0x80) ||\n-        ((utf[ix+3] & 0xc0) != 0x80))\n-            return(-ix);\n-        codepoint = (utf[ix] & 0x7) << 18;\n-        codepoint |= (utf[ix+1] & 0x3f) << 12;\n-        codepoint |= (utf[ix+2] & 0x3f) << 6;\n-        codepoint |= utf[ix+3] & 0x3f;\n-        if (!xmlIsCharQ(codepoint))\n-            return(-ix);\n-        ix += 4;\n-    } else                \/* unknown encoding *\/\n-        return(-ix);\n-      }\n-      return(ix);\n-}\n-\n@@ -11133,1 +11124,1 @@\n-        goto done;\n+            goto done;\n@@ -11136,4 +11127,4 @@\n-            \/*\n-         * Document parsing is done !\n-         *\/\n-            goto done;\n+                \/*\n+                 * Document parsing is done !\n+                 *\/\n+                goto done;\n@@ -11157,1 +11148,1 @@\n-        break;\n+                break;\n@@ -11160,7 +11151,7 @@\n-        if ((!terminate) && (avail < 2))\n-            goto done;\n-        cur = ctxt->input->cur[0];\n-        next = ctxt->input->cur[1];\n-            if ((cur == '<') && (next == '?')) {\n-            \/* PI or XML decl *\/\n-            if ((!terminate) &&\n+                if ((!terminate) && (avail < 2))\n+                    goto done;\n+                cur = ctxt->input->cur[0];\n+                next = ctxt->input->cur[1];\n+                if ((cur == '<') && (next == '?')) {\n+                    \/* PI or XML decl *\/\n+                    if ((!terminate) &&\n@@ -11168,9 +11159,9 @@\n-            goto done;\n-            if ((ctxt->input->cur[2] == 'x') &&\n-            (ctxt->input->cur[3] == 'm') &&\n-            (ctxt->input->cur[4] == 'l') &&\n-            (IS_BLANK_CH(ctxt->input->cur[5]))) {\n-            ret += 5;\n-            xmlParseXMLDecl(ctxt);\n-            } else {\n-            ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n+                        goto done;\n+                    if ((ctxt->input->cur[2] == 'x') &&\n+                        (ctxt->input->cur[3] == 'm') &&\n+                        (ctxt->input->cur[4] == 'l') &&\n+                        (IS_BLANK_CH(ctxt->input->cur[5]))) {\n+                        ret += 5;\n+                        xmlParseXMLDecl(ctxt);\n+                    } else {\n+                        ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n@@ -11181,8 +11172,8 @@\n-            }\n-        } else {\n-            ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n-            if (ctxt->version == NULL) {\n-                xmlErrMemory(ctxt);\n-            break;\n-            }\n-        }\n+                    }\n+                } else {\n+                    ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n+                    if (ctxt->version == NULL) {\n+                        xmlErrMemory(ctxt);\n+                        break;\n+                    }\n+                }\n@@ -11197,1 +11188,1 @@\n-        break;\n+                break;\n@@ -11199,3 +11190,3 @@\n-            const xmlChar *name;\n-        const xmlChar *prefix = NULL;\n-        const xmlChar *URI = NULL;\n+                const xmlChar *name;\n+                const xmlChar *prefix = NULL;\n+                const xmlChar *URI = NULL;\n@@ -11203,1 +11194,1 @@\n-        int nbNs = 0;\n+                int nbNs = 0;\n@@ -11205,5 +11196,5 @@\n-        if ((!terminate) && (avail < 2))\n-            goto done;\n-        cur = ctxt->input->cur[0];\n-            if (cur != '<') {\n-            xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n+                if ((!terminate) && (avail < 2))\n+                    goto done;\n+                cur = ctxt->input->cur[0];\n+                if (cur != '<') {\n+                    xmlFatalErrMsg(ctxt, XML_ERR_DOCUMENT_EMPTY,\n@@ -11213,3 +11204,0 @@\n-            goto done;\n-        }\n-        if ((!terminate) && (!xmlParseLookupGt(ctxt)))\n@@ -11217,6 +11205,9 @@\n-        if (ctxt->spaceNr == 0)\n-            spacePush(ctxt, -1);\n-        else if (*ctxt->space == -2)\n-            spacePush(ctxt, -1);\n-        else\n-            spacePush(ctxt, *ctxt->space);\n+                }\n+                if ((!terminate) && (!xmlParseLookupGt(ctxt)))\n+                    goto done;\n+                if (ctxt->spaceNr == 0)\n+                    spacePush(ctxt, -1);\n+                else if (*ctxt->space == -2)\n+                    spacePush(ctxt, -1);\n+                else\n+                    spacePush(ctxt, *ctxt->space);\n@@ -11224,1 +11215,1 @@\n-        if (ctxt->sax2)\n+                if (ctxt->sax2)\n@@ -11226,1 +11217,1 @@\n-            name = xmlParseStartTag2(ctxt, &prefix, &URI, &nbNs);\n+                    name = xmlParseStartTag2(ctxt, &prefix, &URI, &nbNs);\n@@ -11228,2 +11219,2 @@\n-        else\n-            name = xmlParseStartTag(ctxt);\n+                else\n+                    name = xmlParseStartTag(ctxt);\n@@ -11231,2 +11222,2 @@\n-        if (name == NULL) {\n-            spacePop(ctxt);\n+                if (name == NULL) {\n+                    spacePop(ctxt);\n@@ -11235,2 +11226,2 @@\n-            goto done;\n-        }\n+                    goto done;\n+                }\n@@ -11238,8 +11229,8 @@\n-        \/*\n-         * [ VC: Root Element Type ]\n-         * The Name in the document type declaration must match\n-         * the element type of the root element.\n-         *\/\n-        if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&\n-            ctxt->node && (ctxt->node == ctxt->myDoc->children))\n-            ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n+                \/*\n+                 * [ VC: Root Element Type ]\n+                 * The Name in the document type declaration must match\n+                 * the element type of the root element.\n+                 *\/\n+                if (ctxt->validate && ctxt->wellFormed && ctxt->myDoc &&\n+                    ctxt->node && (ctxt->node == ctxt->myDoc->children))\n+                    ctxt->valid &= xmlValidateRoot(&ctxt->vctxt, ctxt->myDoc);\n@@ -11248,5 +11239,5 @@\n-        \/*\n-         * Check for an Empty Element.\n-         *\/\n-        if ((RAW == '\/') && (NXT(1) == '>')) {\n-            SKIP(2);\n+                \/*\n+                 * Check for an Empty Element.\n+                 *\/\n+                if ((RAW == '\/') && (NXT(1) == '>')) {\n+                    SKIP(2);\n@@ -11254,8 +11245,8 @@\n-            if (ctxt->sax2) {\n-            if ((ctxt->sax != NULL) &&\n-                (ctxt->sax->endElementNs != NULL) &&\n-                (!ctxt->disableSAX))\n-                ctxt->sax->endElementNs(ctxt->userData, name,\n-                                        prefix, URI);\n-            if (nbNs > 0)\n-                xmlParserNsPop(ctxt, nbNs);\n+                    if (ctxt->sax2) {\n+                        if ((ctxt->sax != NULL) &&\n+                            (ctxt->sax->endElementNs != NULL) &&\n+                            (!ctxt->disableSAX))\n+                            ctxt->sax->endElementNs(ctxt->userData, name,\n+                                                    prefix, URI);\n+                        if (nbNs > 0)\n+                            xmlParserNsPop(ctxt, nbNs);\n@@ -11263,5 +11254,5 @@\n-            } else {\n-            if ((ctxt->sax != NULL) &&\n-                (ctxt->sax->endElement != NULL) &&\n-                (!ctxt->disableSAX))\n-                ctxt->sax->endElement(ctxt->userData, name);\n+                    } else {\n+                        if ((ctxt->sax != NULL) &&\n+                            (ctxt->sax->endElement != NULL) &&\n+                            (!ctxt->disableSAX))\n+                            ctxt->sax->endElement(ctxt->userData, name);\n@@ -11269,4 +11260,4 @@\n-            }\n-            spacePop(ctxt);\n-        } else if (RAW == '>') {\n-            NEXT;\n+                    }\n+                    spacePop(ctxt);\n+                } else if (RAW == '>') {\n+                    NEXT;\n@@ -11274,6 +11265,6 @@\n-        } else {\n-            xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,\n-                     \"Couldn't find end of Start Tag %s\\n\",\n-                     name);\n-            nodePop(ctxt);\n-            spacePop(ctxt);\n+                } else {\n+                    xmlFatalErrMsgStr(ctxt, XML_ERR_GT_REQUIRED,\n+                                         \"Couldn't find end of Start Tag %s\\n\",\n+                                         name);\n+                    nodePop(ctxt);\n+                    spacePop(ctxt);\n@@ -11282,1 +11273,1 @@\n-        }\n+                }\n@@ -11289,1 +11280,1 @@\n-        }\n+            }\n@@ -11291,1 +11282,1 @@\n-        cur = ctxt->input->cur[0];\n+                cur = ctxt->input->cur[0];\n@@ -11293,1 +11284,1 @@\n-        if (cur == '<') {\n+                if (cur == '<') {\n@@ -11296,1 +11287,1 @@\n-            next = ctxt->input->cur[1];\n+                    next = ctxt->input->cur[1];\n@@ -11334,1 +11325,3 @@\n-                                SKIP(9);\n+                                if ((!terminate) &&\n+                                    (!xmlParseLookupString(ctxt, 9, \"]]>\", 3)))\n+                                    goto done;\n@@ -11336,0 +11329,2 @@\n+                                xmlParseCDSect(ctxt);\n+                                ctxt->instate = XML_PARSER_CONTENT;\n@@ -11340,4 +11335,4 @@\n-        } else if (cur == '&') {\n-            if ((!terminate) && (!xmlParseLookupChar(ctxt, ';')))\n-            goto done;\n-            xmlParseReference(ctxt);\n+                } else if (cur == '&') {\n+                    if ((!terminate) && (!xmlParseLookupChar(ctxt, ';')))\n+                        goto done;\n+                    xmlParseReference(ctxt);\n@@ -11345,16 +11340,16 @@\n-        } else {\n-            \/* TODO Avoid the extra copy, handle directly !!! *\/\n-            \/*\n-             * Goal of the following test is:\n-             *  - minimize calls to the SAX 'character' callback\n-             *    when they are mergeable\n-             *  - handle an problem for isBlank when we only parse\n-             *    a sequence of blank chars and the next one is\n-             *    not available to check against '<' presence.\n-             *  - tries to homogenize the differences in SAX\n-             *    callbacks between the push and pull versions\n-             *    of the parser.\n-             *\/\n-            if (avail < XML_PARSER_BIG_BUFFER_SIZE) {\n-            if ((!terminate) && (!xmlParseLookupCharData(ctxt)))\n-                goto done;\n+                } else {\n+                    \/* TODO Avoid the extra copy, handle directly !!! *\/\n+                    \/*\n+                     * Goal of the following test is:\n+                     *  - minimize calls to the SAX 'character' callback\n+                     *    when they are mergeable\n+                     *  - handle an problem for isBlank when we only parse\n+                     *    a sequence of blank chars and the next one is\n+                     *    not available to check against '<' presence.\n+                     *  - tries to homogenize the differences in SAX\n+                     *    callbacks between the push and pull versions\n+                     *    of the parser.\n+                     *\/\n+                    if (avail < XML_PARSER_BIG_BUFFER_SIZE) {\n+                        if ((!terminate) && (!xmlParseLookupCharData(ctxt)))\n+                            goto done;\n@@ -11363,1 +11358,1 @@\n-            xmlParseCharDataInternal(ctxt, !terminate);\n+                    xmlParseCharDataInternal(ctxt, !terminate);\n@@ -11365,1 +11360,1 @@\n-        }\n+                }\n@@ -11368,2 +11363,2 @@\n-        break;\n-        }\n+                break;\n+            }\n@@ -11371,6 +11366,6 @@\n-        if ((!terminate) && (!xmlParseLookupChar(ctxt, '>')))\n-            goto done;\n-        if (ctxt->sax2) {\n-                xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);\n-            nameNsPop(ctxt);\n-        }\n+                if ((!terminate) && (!xmlParseLookupChar(ctxt, '>')))\n+                    goto done;\n+                if (ctxt->sax2) {\n+                    xmlParseEndTag2(ctxt, &ctxt->pushTab[ctxt->nameNr - 1]);\n+                    nameNsPop(ctxt);\n+                }\n@@ -11378,2 +11373,2 @@\n-          else\n-            xmlParseEndTag1(ctxt, 0);\n+                  else\n+                    xmlParseEndTag1(ctxt, 0);\n@@ -11381,20 +11376,2 @@\n-        if (ctxt->nameNr == 0) {\n-            ctxt->instate = XML_PARSER_EPILOG;\n-        } else {\n-            ctxt->instate = XML_PARSER_CONTENT;\n-        }\n-        break;\n-            case XML_PARSER_CDATA_SECTION: {\n-            \/*\n-         * The Push mode need to have the SAX callback for\n-         * cdataBlock merge back contiguous callbacks.\n-         *\/\n-        const xmlChar *term;\n-\n-                if (terminate) {\n-                    \/*\n-                     * Don't call xmlParseLookupString. If 'terminate'\n-                     * is set, checkIndex is invalid.\n-                     *\/\n-                    term = BAD_CAST strstr((const char *) ctxt->input->cur,\n-                                           \"]]>\");\n+                if (ctxt->nameNr == 0) {\n+                    ctxt->instate = XML_PARSER_EPILOG;\n@@ -11402,1 +11379,1 @@\n-            term = xmlParseLookupString(ctxt, 0, \"]]>\", 3);\n+                    ctxt->instate = XML_PARSER_CONTENT;\n@@ -11404,66 +11381,1 @@\n-\n-        if (term == NULL) {\n-            int tmp, size;\n-\n-                    if (terminate) {\n-                        \/* Unfinished CDATA section *\/\n-                        size = ctxt->input->end - ctxt->input->cur;\n-                    } else {\n-                        if (avail < XML_PARSER_BIG_BUFFER_SIZE + 2)\n-                            goto done;\n-                        ctxt->checkIndex = 0;\n-                        \/* XXX: Why don't we pass the full buffer? *\/\n-                        size = XML_PARSER_BIG_BUFFER_SIZE;\n-                    }\n-                    tmp = xmlCheckCdataPush(ctxt->input->cur, size, 0);\n-                    if (tmp <= 0) {\n-                        tmp = -tmp;\n-                        ctxt->input->cur += tmp;\n-                        goto encoding_error;\n-                    }\n-                    if ((ctxt->sax != NULL) && (!ctxt->disableSAX)) {\n-                        if (ctxt->sax->cdataBlock != NULL)\n-                            ctxt->sax->cdataBlock(ctxt->userData,\n-                                                  ctxt->input->cur, tmp);\n-                        else if (ctxt->sax->characters != NULL)\n-                            ctxt->sax->characters(ctxt->userData,\n-                                                  ctxt->input->cur, tmp);\n-                    }\n-                    SKIPL(tmp);\n-        } else {\n-                    int base = term - CUR_PTR;\n-            int tmp;\n-\n-            tmp = xmlCheckCdataPush(ctxt->input->cur, base, 1);\n-            if ((tmp < 0) || (tmp != base)) {\n-            tmp = -tmp;\n-            ctxt->input->cur += tmp;\n-            goto encoding_error;\n-            }\n-            if ((ctxt->sax != NULL) && (base == 0) &&\n-                (ctxt->sax->cdataBlock != NULL) &&\n-                (!ctxt->disableSAX)) {\n-            \/*\n-             * Special case to provide identical behaviour\n-             * between pull and push parsers on enpty CDATA\n-             * sections\n-             *\/\n-             if ((ctxt->input->cur - ctxt->input->base >= 9) &&\n-                 (!strncmp((const char *)&ctxt->input->cur[-9],\n-                           \"<![CDATA[\", 9)))\n-                 ctxt->sax->cdataBlock(ctxt->userData,\n-                                       BAD_CAST \"\", 0);\n-            } else if ((ctxt->sax != NULL) && (base > 0) &&\n-            (!ctxt->disableSAX)) {\n-            if (ctxt->sax->cdataBlock != NULL)\n-                ctxt->sax->cdataBlock(ctxt->userData,\n-                          ctxt->input->cur, base);\n-            else if (ctxt->sax->characters != NULL)\n-                ctxt->sax->characters(ctxt->userData,\n-                          ctxt->input->cur, base);\n-            }\n-            SKIPL(base + 3);\n-            ctxt->instate = XML_PARSER_CONTENT;\n-        }\n-        break;\n-        }\n+                break;\n@@ -11473,1 +11385,1 @@\n-        SKIP_BLANKS;\n+                SKIP_BLANKS;\n@@ -11475,3 +11387,3 @@\n-        if (avail < 1)\n-            goto done;\n-        if (ctxt->input->cur[0] == '<') {\n+                if (avail < 1)\n+                    goto done;\n+                if (ctxt->input->cur[0] == '<') {\n@@ -11518,0 +11430,2 @@\n+                                    if (RAW == '>')\n+                                        NEXT;\n@@ -11543,1 +11457,1 @@\n-            ctxt->instate = XML_PARSER_EOF;\n+                    ctxt->instate = XML_PARSER_EOF;\n@@ -11546,3 +11460,3 @@\n-            ctxt->instate = XML_PARSER_START_TAG;\n-        }\n-        break;\n+                    ctxt->instate = XML_PARSER_START_TAG;\n+                }\n+                break;\n@@ -11552,9 +11466,9 @@\n-        xmlParseInternalSubset(ctxt);\n-        ctxt->inSubset = 2;\n-        if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n-            (ctxt->sax->externalSubset != NULL))\n-            ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n-                ctxt->extSubSystem, ctxt->extSubURI);\n-        ctxt->inSubset = 0;\n-        xmlCleanSpecialAttr(ctxt);\n-        ctxt->instate = XML_PARSER_PROLOG;\n+                xmlParseInternalSubset(ctxt);\n+                ctxt->inSubset = 2;\n+                if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                    (ctxt->sax->externalSubset != NULL))\n+                    ctxt->sax->externalSubset(ctxt->userData, ctxt->intSubName,\n+                            ctxt->extSubSystem, ctxt->extSubURI);\n+                ctxt->inSubset = 0;\n+                xmlCleanSpecialAttr(ctxt);\n+                ctxt->instate = XML_PARSER_PROLOG;\n@@ -11562,1 +11476,1 @@\n-        }\n+            }\n@@ -11565,4 +11479,4 @@\n-            \"PP: internal error\\n\");\n-        ctxt->instate = XML_PARSER_EOF;\n-        break;\n-    }\n+                        \"PP: internal error\\n\");\n+                ctxt->instate = XML_PARSER_EOF;\n+                break;\n+        }\n@@ -11572,7 +11486,0 @@\n-encoding_error:\n-    \/* Only report the first error *\/\n-    if ((ctxt->input->flags & XML_INPUT_ENCODING_ERROR) == 0) {\n-        xmlCtxtErrIO(ctxt, XML_ERR_INVALID_ENCODING, NULL);\n-        ctxt->input->flags |= XML_INPUT_ENCODING_ERROR;\n-    }\n-    return(0);\n@@ -11596,1 +11503,3 @@\n- * be freed by the library.\n+ * be freed when calling xmlFreeParserCtxt and must be freed by the\n+ * caller. If the document isn't well-formed, it will still be returned\n+ * in ctxt->myDoc.\n@@ -11598,2 +11507,3 @@\n- * If the document isn't well-formed, ctxt->myDoc is set to NULL.\n- * The push parser doesn't support recovery mode.\n+ * As an exception, xmlCtxtResetPush will free the document in\n+ * ctxt->myDoc. So ctxt->myDoc should be set to NULL after extracting\n+ * the document.\n@@ -11608,0 +11518,1 @@\n+    size_t pos;\n@@ -11609,0 +11520,1 @@\n+    int res;\n@@ -11612,0 +11524,4 @@\n+    if ((chunk == NULL) && (size > 0))\n+        return(XML_ERR_ARGUMENT);\n+    if ((ctxt->input == NULL) || (ctxt->input->buf == NULL))\n+        return(XML_ERR_ARGUMENT);\n@@ -11614,2 +11530,0 @@\n-    if (ctxt->input == NULL)\n-        return(XML_ERR_INTERNAL_ERROR);\n@@ -11622,2 +11536,2 @@\n-    end_in_lf = 1;\n-    size--;\n+        end_in_lf = 1;\n+        size--;\n@@ -11626,5 +11540,5 @@\n-    if ((size > 0) && (chunk != NULL) && (ctxt->input != NULL) &&\n-        (ctxt->input->buf != NULL))  {\n-    size_t pos = ctxt->input->cur - ctxt->input->base;\n-    int res;\n-\n+    \/*\n+     * Also push an empty chunk to make sure that the raw buffer\n+     * will be flushed if there is an encoder.\n+     *\/\n+    pos = ctxt->input->cur - ctxt->input->base;\n@@ -11632,1 +11546,1 @@\n-        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n+    xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n@@ -11634,1 +11548,1 @@\n-            xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n+        xmlCtxtErrIO(ctxt, ctxt->input->buf->error, NULL);\n@@ -11638,1 +11552,0 @@\n-    }\n@@ -11655,7 +11568,4 @@\n-    if ((end_in_lf == 1) && (ctxt->input != NULL) &&\n-        (ctxt->input->buf != NULL)) {\n-    size_t pos = ctxt->input->cur - ctxt->input->base;\n-        int res;\n-\n-    res = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n-    xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n+    if (end_in_lf == 1) {\n+        pos = ctxt->input->cur - ctxt->input->base;\n+        res = xmlParserInputBufferPush(ctxt->input->buf, 1, \"\\r\");\n+        xmlBufUpdateInput(ctxt->input->buf->buffer, ctxt->input, pos);\n@@ -11669,3 +11579,3 @@\n-    \/*\n-     * Check for termination\n-     *\/\n+        \/*\n+         * Check for termination\n+         *\/\n@@ -11686,6 +11596,2 @@\n-        } else if ((ctxt->input->buf != NULL) &&\n-                   (ctxt->input->buf->encoder != NULL) &&\n-                   (ctxt->input->buf->error == 0) &&\n-                   (!xmlBufIsEmpty(ctxt->input->buf->raw))) {\n-            xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,\n-                           \"Truncated multi-byte sequence at EOF\\n\");\n+        } else {\n+            xmlParserCheckEOF(ctxt, XML_ERR_DOCUMENT_END);\n@@ -11693,1 +11599,1 @@\n-    if (ctxt->instate != XML_PARSER_EOF) {\n+        if (ctxt->instate != XML_PARSER_EOF) {\n@@ -11696,1 +11602,1 @@\n-    }\n+        }\n@@ -11699,1 +11605,1 @@\n-    return((xmlParserErrors) ctxt->errNo);\n+        return((xmlParserErrors) ctxt->errNo);\n@@ -11705,3 +11611,3 @@\n- *                                    *\n- *        I\/O front end functions to the parser            *\n- *                                    *\n+ *                                                                      *\n+ *              I\/O front end functions to the parser                   *\n+ *                                                                      *\n@@ -11723,0 +11629,3 @@\n+ * The push parser doesn't support recovery mode or the\n+ * XML_PARSE_NOBLANKS option.\n+ *\n@@ -11726,1 +11635,2 @@\n- * Returns the new parser context or NULL in case of error.\n+ * Returns the new parser context or NULL if a memory allocation\n+ * failed.\n@@ -11737,1 +11647,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -11742,1 +11652,1 @@\n-    input = xmlNewInputPush(ctxt, filename, chunk, size, NULL);\n+    input = xmlNewPushInput(filename, chunk, size);\n@@ -11744,2 +11654,7 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n+    }\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n+        xmlFreeInputStream(input);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -11747,1 +11662,0 @@\n-    inputPush(ctxt, input);\n@@ -11793,1 +11707,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -11796,1 +11710,2 @@\n-    input = xmlNewInputIO(ctxt, NULL, ioread, ioclose, ioctx, encoding, 0);\n+    input = xmlCtxtNewInputFromIO(ctxt, NULL, ioread, ioclose, ioctx,\n+                                  encoding, 0);\n@@ -11798,1 +11713,1 @@\n-    xmlFreeParserCtxt(ctxt);\n+        xmlFreeParserCtxt(ctxt);\n@@ -11801,1 +11716,5 @@\n-    inputPush(ctxt, input);\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n+        xmlFreeInputStream(input);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n+    }\n@@ -11808,3 +11727,3 @@\n- *                                    *\n- *        Front ends when parsing a DTD                *\n- *                                    *\n+ *                                                                      *\n+ *              Front ends when parsing a DTD                           *\n+ *                                                                      *\n@@ -11813,0 +11732,79 @@\n+\/**\n+ * xmlCtxtParseDtd:\n+ * @ctxt:  a parser context\n+ * @input:  a parser input\n+ * @publicId:  public ID of the DTD (optional)\n+ * @systemId:  system ID of the DTD (optional)\n+ *\n+ * Parse a DTD.\n+ *\n+ * Option XML_PARSE_DTDLOAD should be enabled in the parser context\n+ * to make external entities work.\n+ *\n+ * Availabe since 2.14.0.\n+ *\n+ * Returns the resulting xmlDtdPtr or NULL in case of error.\n+ * @input will be freed by the function in any case.\n+ *\/\n+xmlDtdPtr\n+xmlCtxtParseDtd(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n+                const xmlChar *publicId, const xmlChar *systemId) {\n+    xmlDtdPtr ret = NULL;\n+\n+    if ((ctxt == NULL) || (input == NULL)) {\n+        xmlFatalErr(ctxt, XML_ERR_ARGUMENT, NULL);\n+        xmlFreeInputStream(input);\n+        return(NULL);\n+    }\n+\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n+        xmlFreeInputStream(input);\n+        return(NULL);\n+    }\n+\n+    if (publicId == NULL)\n+        publicId = BAD_CAST \"none\";\n+    if (systemId == NULL)\n+        systemId = BAD_CAST \"none\";\n+\n+    ctxt->myDoc = xmlNewDoc(BAD_CAST \"1.0\");\n+    if (ctxt->myDoc == NULL) {\n+        xmlErrMemory(ctxt);\n+        goto error;\n+    }\n+    ctxt->myDoc->properties = XML_DOC_INTERNAL;\n+    ctxt->myDoc->extSubset = xmlNewDtd(ctxt->myDoc, BAD_CAST \"none\",\n+                                       publicId, systemId);\n+    if (ctxt->myDoc->extSubset == NULL) {\n+        xmlErrMemory(ctxt);\n+        xmlFreeDoc(ctxt->myDoc);\n+        goto error;\n+    }\n+\n+    xmlParseExternalSubset(ctxt, publicId, systemId);\n+\n+    if (ctxt->wellFormed) {\n+        ret = ctxt->myDoc->extSubset;\n+        ctxt->myDoc->extSubset = NULL;\n+        if (ret != NULL) {\n+            xmlNodePtr tmp;\n+\n+            ret->doc = NULL;\n+            tmp = ret->children;\n+            while (tmp != NULL) {\n+                tmp->doc = NULL;\n+                tmp = tmp->next;\n+            }\n+        }\n+    } else {\n+        ret = NULL;\n+    }\n+    xmlFreeDoc(ctxt->myDoc);\n+    ctxt->myDoc = NULL;\n+\n+error:\n+    xmlFreeInputStream(xmlCtxtPopInput(ctxt));\n+\n+    return(ret);\n+}\n+\n@@ -11819,0 +11817,2 @@\n+ * DEPRECATED: Use xmlCtxtParseDtd.\n+ *\n@@ -11827,1 +11827,1 @@\n-          xmlCharEncoding enc) {\n+              xmlCharEncoding enc) {\n@@ -11833,1 +11833,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -11838,1 +11838,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -11849,2 +11849,2 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -11853,7 +11853,0 @@\n-    \/*\n-     * plug some encoding conversion routines here.\n-     *\/\n-    if (xmlPushInput(ctxt, pinput) < 0) {\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n-    }\n@@ -11864,20 +11857,1 @@\n-    \/*\n-     * let's parse that entity knowing it's an external subset.\n-     *\/\n-    ctxt->myDoc = xmlNewDoc(BAD_CAST \"1.0\");\n-    if (ctxt->myDoc == NULL) {\n-    xmlErrMemory(ctxt);\n-    return(NULL);\n-    }\n-    ctxt->myDoc->properties = XML_DOC_INTERNAL;\n-    ctxt->myDoc->extSubset = xmlNewDtd(ctxt->myDoc, BAD_CAST \"none\",\n-                                   BAD_CAST \"none\", BAD_CAST \"none\");\n-\n-    xmlParseExternalSubset(ctxt, BAD_CAST \"none\", BAD_CAST \"none\");\n-\n-    if (ctxt->myDoc != NULL) {\n-    if (ctxt->wellFormed) {\n-        ret = ctxt->myDoc->extSubset;\n-        ctxt->myDoc->extSubset = NULL;\n-        if (ret != NULL) {\n-        xmlNodePtr tmp;\n+    ret = xmlCtxtParseDtd(ctxt, pinput, NULL, NULL);\n@@ -11885,13 +11859,0 @@\n-        ret->doc = NULL;\n-        tmp = ret->children;\n-        while (tmp != NULL) {\n-            tmp->doc = NULL;\n-            tmp = tmp->next;\n-        }\n-        }\n-    } else {\n-        ret = NULL;\n-    }\n-        xmlFreeDoc(ctxt->myDoc);\n-        ctxt->myDoc = NULL;\n-    }\n@@ -11899,1 +11860,0 @@\n-\n@@ -11909,1 +11869,1 @@\n- * DEPRECATED: Don't use.\n+ * DEPRECATED: Use xmlCtxtParseDtd.\n@@ -11928,1 +11888,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -11937,2 +11897,2 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -11946,2 +11906,2 @@\n-    input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,\n-                                     systemIdCanonic);\n+        input = ctxt->sax->resolveEntity(ctxt->userData, ExternalID,\n+                                         systemIdCanonic);\n@@ -11949,14 +11909,4 @@\n-    xmlFreeParserCtxt(ctxt);\n-    if (systemIdCanonic != NULL)\n-        xmlFree(systemIdCanonic);\n-    return(NULL);\n-    }\n-\n-    \/*\n-     * plug some encoding conversion routines here.\n-     *\/\n-    if (xmlPushInput(ctxt, input) < 0) {\n-    xmlFreeParserCtxt(ctxt);\n-    if (systemIdCanonic != NULL)\n-        xmlFree(systemIdCanonic);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        if (systemIdCanonic != NULL)\n+            xmlFree(systemIdCanonic);\n+        return(NULL);\n@@ -11965,2 +11915,0 @@\n-    xmlDetectEncoding(ctxt);\n-\n@@ -11968,1 +11916,1 @@\n-    input->filename = (char *) systemIdCanonic;\n+        input->filename = (char *) systemIdCanonic;\n@@ -11970,20 +11918,1 @@\n-    xmlFree(systemIdCanonic);\n-\n-    \/*\n-     * let's parse that entity knowing it's an external subset.\n-     *\/\n-    ctxt->myDoc = xmlNewDoc(BAD_CAST \"1.0\");\n-    if (ctxt->myDoc == NULL) {\n-    xmlErrMemory(ctxt);\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n-    }\n-    ctxt->myDoc->properties = XML_DOC_INTERNAL;\n-    ctxt->myDoc->extSubset = xmlNewDtd(ctxt->myDoc, BAD_CAST \"none\",\n-                                   ExternalID, SystemID);\n-    if (ctxt->myDoc->extSubset == NULL) {\n-        xmlFreeDoc(ctxt->myDoc);\n-        xmlFreeParserCtxt(ctxt);\n-        return(NULL);\n-    }\n-    xmlParseExternalSubset(ctxt, ExternalID, SystemID);\n+        xmlFree(systemIdCanonic);\n@@ -11991,6 +11920,1 @@\n-    if (ctxt->myDoc != NULL) {\n-    if (ctxt->wellFormed) {\n-        ret = ctxt->myDoc->extSubset;\n-        ctxt->myDoc->extSubset = NULL;\n-        if (ret != NULL) {\n-        xmlNodePtr tmp;\n+    ret = xmlCtxtParseDtd(ctxt, input, ExternalID, SystemID);\n@@ -11998,13 +11922,0 @@\n-        ret->doc = NULL;\n-        tmp = ret->children;\n-        while (tmp != NULL) {\n-            tmp->doc = NULL;\n-            tmp = tmp->next;\n-        }\n-        }\n-    } else {\n-        ret = NULL;\n-    }\n-        xmlFreeDoc(ctxt->myDoc);\n-        ctxt->myDoc = NULL;\n-    }\n@@ -12012,1 +11923,0 @@\n-\n@@ -12034,3 +11944,3 @@\n- *                                    *\n- *        Front ends when parsing an Entity            *\n- *                                    *\n+ *                                                                      *\n+ *              Front ends when parsing an Entity                       *\n+ *                                                                      *\n@@ -12040,2 +11950,2 @@\n-xmlCtxtParseContent(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n-                    int hasTextDecl, int buildTree) {\n+xmlCtxtParseContentInternal(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n+                            int hasTextDecl, int buildTree) {\n@@ -12055,1 +11965,1 @@\n-    if (xmlPushInput(ctxt, input) < 0)\n+    if (xmlCtxtPushInput(ctxt, input) < 0)\n@@ -12088,1 +11998,1 @@\n-    xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n+        xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n@@ -12091,1 +12001,1 @@\n-        ((ctxt->recovery) && (ctxt->errNo != XML_ERR_NO_MEMORY))) {\n+        ((ctxt->recovery) && (!xmlCtxtIsCatastrophicError(ctxt)))) {\n@@ -12096,2 +12006,1 @@\n-             * Return the newly created nodeset after unlinking it from\n-             * its pseudo parent.\n+             * Unlink newly created node list.\n@@ -12099,6 +12008,1 @@\n-            cur = root->children;\n-            list = cur;\n-            while (cur != NULL) {\n-                cur->parent = NULL;\n-                cur = cur->next;\n-            }\n+            list = root->children;\n@@ -12107,0 +12011,2 @@\n+            for (cur = list; cur != NULL; cur = cur->next)\n+                cur->parent = NULL;\n@@ -12126,2 +12032,1 @@\n-    \/* xmlPopInput would free the stream *\/\n-    inputPop(ctxt);\n+    xmlCtxtPopInput(ctxt);\n@@ -12183,1 +12088,1 @@\n-     * - xmlCtxtParseContent\n+     * - xmlCtxtParseContentInternal\n@@ -12189,1 +12094,1 @@\n-     * see xmlPushInput.\n+     * see xmlCtxtPushInput.\n@@ -12197,1 +12102,1 @@\n-    list = xmlCtxtParseContent(ctxt, input, isExternal, buildTree);\n+    list = xmlCtxtParseContentInternal(ctxt, input, isExternal, buildTree);\n@@ -12274,1 +12179,2 @@\n-    input = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);\n+    input = xmlLoadResource(ctxt, (char *) URL, (char *) ID,\n+                            XML_RESOURCE_GENERAL_ENTITY);\n@@ -12280,1 +12186,1 @@\n-    list = xmlCtxtParseContent(ctxt, input, \/* hasTextDecl *\/ 1, 1);\n+    list = xmlCtxtParseContentInternal(ctxt, input, \/* hasTextDecl *\/ 1, 1);\n@@ -12315,1 +12221,1 @@\n-      int depth, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *list) {\n+          int depth, const xmlChar *URL, const xmlChar *ID, xmlNodePtr *list) {\n@@ -12357,5 +12263,150 @@\n-int\n-xmlParseBalancedChunkMemory(xmlDocPtr doc, xmlSAXHandlerPtr sax,\n-     void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst) {\n-    return xmlParseBalancedChunkMemoryRecover( doc, sax, user_data,\n-                                                depth, string, lst, 0 );\n+int\n+xmlParseBalancedChunkMemory(xmlDocPtr doc, xmlSAXHandlerPtr sax,\n+     void *user_data, int depth, const xmlChar *string, xmlNodePtr *lst) {\n+    return xmlParseBalancedChunkMemoryRecover( doc, sax, user_data,\n+                                                depth, string, lst, 0 );\n+}\n+#endif \/* LIBXML_SAX1_ENABLED *\/\n+\n+\/**\n+ * xmlCtxtParseContent:\n+ * @ctxt:  parser context\n+ * @input:  parser input\n+ * @node:  target node or document\n+ * @hasTextDecl:  whether to parse text declaration\n+ *\n+ * Parse a well-balanced chunk of XML matching the 'content' production.\n+ *\n+ * Namespaces in scope of @node and entities of @node's document are\n+ * recognized. When validating, the DTD of @node's document is used.\n+ *\n+ * Always consumes @input even in error case.\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns a node list or NULL in case of error.\n+ *\/\n+xmlNodePtr\n+xmlCtxtParseContent(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n+                    xmlNodePtr node, int hasTextDecl) {\n+    xmlDocPtr doc;\n+    xmlNodePtr cur, list = NULL;\n+    int nsnr = 0;\n+    xmlDictPtr oldDict;\n+    int oldOptions, oldDictNames, oldLoadSubset;\n+\n+    if ((ctxt == NULL) || (input == NULL) || (node == NULL)) {\n+        xmlFatalErr(ctxt, XML_ERR_ARGUMENT, NULL);\n+        goto exit;\n+    }\n+\n+    doc = node->doc;\n+    if (doc == NULL) {\n+        xmlFatalErr(ctxt, XML_ERR_ARGUMENT, NULL);\n+        goto exit;\n+    }\n+\n+    switch (node->type) {\n+        case XML_ELEMENT_NODE:\n+        case XML_DOCUMENT_NODE:\n+        case XML_HTML_DOCUMENT_NODE:\n+            break;\n+\n+        case XML_ATTRIBUTE_NODE:\n+        case XML_TEXT_NODE:\n+        case XML_CDATA_SECTION_NODE:\n+        case XML_ENTITY_REF_NODE:\n+        case XML_PI_NODE:\n+        case XML_COMMENT_NODE:\n+            for (cur = node->parent; cur != NULL; cur = node->parent) {\n+                if ((cur->type == XML_ELEMENT_NODE) ||\n+                    (cur->type == XML_DOCUMENT_NODE) ||\n+                    (cur->type == XML_HTML_DOCUMENT_NODE)) {\n+                    node = cur;\n+                    break;\n+                }\n+            }\n+            break;\n+\n+        default:\n+            xmlFatalErr(ctxt, XML_ERR_ARGUMENT, NULL);\n+            goto exit;\n+    }\n+\n+#ifdef LIBXML_HTML_ENABLED\n+    if (ctxt->html)\n+        htmlCtxtReset(ctxt);\n+    else\n+#endif\n+        xmlCtxtReset(ctxt);\n+\n+    oldDict = ctxt->dict;\n+    oldOptions = ctxt->options;\n+    oldDictNames = ctxt->dictNames;\n+    oldLoadSubset = ctxt->loadsubset;\n+\n+    \/*\n+     * Use input doc's dict if present, else assure XML_PARSE_NODICT is set.\n+     *\/\n+    if (doc->dict != NULL) {\n+        ctxt->dict = doc->dict;\n+    } else {\n+        ctxt->options |= XML_PARSE_NODICT;\n+        ctxt->dictNames = 0;\n+    }\n+\n+    \/*\n+     * Disable IDs\n+     *\/\n+    ctxt->loadsubset |= XML_SKIP_IDS;\n+\n+    ctxt->myDoc = doc;\n+\n+#ifdef LIBXML_HTML_ENABLED\n+    if (ctxt->html) {\n+        \/*\n+         * When parsing in context, it makes no sense to add implied\n+         * elements like html\/body\/etc...\n+         *\/\n+        ctxt->options |= HTML_PARSE_NOIMPLIED;\n+\n+        list = htmlCtxtParseContentInternal(ctxt, input);\n+    } else\n+#endif\n+    {\n+        xmlCtxtInitializeLate(ctxt);\n+\n+        \/*\n+         * initialize the SAX2 namespaces stack\n+         *\/\n+        cur = node;\n+        while ((cur != NULL) && (cur->type == XML_ELEMENT_NODE)) {\n+            xmlNsPtr ns = cur->nsDef;\n+            xmlHashedString hprefix, huri;\n+\n+            while (ns != NULL) {\n+                hprefix = xmlDictLookupHashed(ctxt->dict, ns->prefix, -1);\n+                huri = xmlDictLookupHashed(ctxt->dict, ns->href, -1);\n+                if (xmlParserNsPush(ctxt, &hprefix, &huri, ns, 1) > 0)\n+                    nsnr++;\n+                ns = ns->next;\n+            }\n+            cur = cur->parent;\n+        }\n+\n+        list = xmlCtxtParseContentInternal(ctxt, input, hasTextDecl, 1);\n+\n+        if (nsnr > 0)\n+            xmlParserNsPop(ctxt, nsnr);\n+    }\n+\n+    ctxt->dict = oldDict;\n+    ctxt->options = oldOptions;\n+    ctxt->dictNames = oldDictNames;\n+    ctxt->loadsubset = oldLoadSubset;\n+    ctxt->myDoc = NULL;\n+    ctxt->node = NULL;\n+\n+exit:\n+    xmlFreeInputStream(input);\n+    return(list);\n@@ -12363,1 +12414,0 @@\n-#endif \/* LIBXML_SAX1_ENABLED *\/\n@@ -12371,1 +12421,1 @@\n- * @lst:  the return value for the set of parsed nodes\n+ * @listOut:  the return value for the set of parsed nodes\n@@ -12381,0 +12431,4 @@\n+ * This function assumes the encoding of @node's document which is\n+ * typically not what you want. A better alternative is\n+ * xmlCtxtParseContent.\n+ *\n@@ -12386,1 +12440,1 @@\n-                      int options, xmlNodePtr *lst) {\n+                      int options, xmlNodePtr *listOut) {\n@@ -12388,3 +12442,4 @@\n-    xmlDocPtr doc = NULL;\n-    xmlNodePtr fake, cur;\n-    int nsnr = 0;\n+    xmlParserInputPtr input;\n+    xmlDocPtr doc;\n+    xmlNodePtr list;\n+    xmlParserErrors ret;\n@@ -12392,1 +12447,3 @@\n-    xmlParserErrors ret = XML_ERR_OK;\n+    if (listOut == NULL)\n+        return(XML_ERR_INTERNAL_ERROR);\n+    *listOut = NULL;\n@@ -12394,17 +12451,1 @@\n-    \/*\n-     * check all input parameters, grab the document\n-     *\/\n-    if ((lst == NULL) || (node == NULL) || (data == NULL) || (datalen < 0))\n-        return(XML_ERR_ARGUMENT);\n-    switch (node->type) {\n-        case XML_ELEMENT_NODE:\n-        case XML_ATTRIBUTE_NODE:\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        case XML_ENTITY_REF_NODE:\n-        case XML_PI_NODE:\n-        case XML_COMMENT_NODE:\n-        case XML_DOCUMENT_NODE:\n-        case XML_HTML_DOCUMENT_NODE:\n-        break;\n-    default:\n+    if ((node == NULL) || (data == NULL) || (datalen < 0))\n@@ -12413,8 +12454,0 @@\n-    }\n-    while ((node != NULL) && (node->type != XML_ELEMENT_NODE) &&\n-           (node->type != XML_DOCUMENT_NODE) &&\n-       (node->type != XML_HTML_DOCUMENT_NODE))\n-    node = node->parent;\n-    if (node == NULL)\n-    return(XML_ERR_INTERNAL_ERROR);\n-    if (node->type == XML_ELEMENT_NODE)\n@@ -12422,2 +12455,0 @@\n-    else\n-        doc = (xmlDocPtr) node;\n@@ -12425,1 +12456,1 @@\n-    return(XML_ERR_INTERNAL_ERROR);\n+        return(XML_ERR_INTERNAL_ERROR);\n@@ -12427,6 +12458,0 @@\n-    \/*\n-     * allocate a context and set-up everything not related to the\n-     * node position in the tree\n-     *\/\n-    if (doc->type == XML_DOCUMENT_NODE)\n-    ctxt = xmlCreateMemoryParserCtxt((char *) data, datalen);\n@@ -12434,7 +12459,2 @@\n-    else if (doc->type == XML_HTML_DOCUMENT_NODE) {\n-    ctxt = htmlCreateMemoryParserCtxt((char *) data, datalen);\n-        \/*\n-         * When parsing in context, it makes no sense to add implied\n-         * elements like html\/body\/etc...\n-         *\/\n-        options |= HTML_PARSE_NOIMPLIED;\n+    if (doc->type == XML_HTML_DOCUMENT_NODE) {\n+        ctxt = htmlNewParserCtxt();\n@@ -12442,1 +12462,0 @@\n-#endif\n@@ -12444,1 +12463,2 @@\n-        return(XML_ERR_INTERNAL_ERROR);\n+#endif\n+        ctxt = xmlNewParserCtxt();\n@@ -12449,29 +12469,4 @@\n-    \/*\n-     * Use input doc's dict if present, else assure XML_PARSE_NODICT is set.\n-     * We need a dictionary for xmlCtxtInitializeLate, so if there's no doc dict\n-     * we must wait until the last moment to free the original one.\n-     *\/\n-    if (doc->dict != NULL) {\n-        if (ctxt->dict != NULL)\n-        xmlDictFree(ctxt->dict);\n-    ctxt->dict = doc->dict;\n-    } else {\n-        options |= XML_PARSE_NODICT;\n-        ctxt->dictNames = 0;\n-    }\n-\n-    if (doc->encoding != NULL)\n-        xmlSwitchEncodingName(ctxt, (const char *) doc->encoding);\n-\n-    xmlCtxtUseOptions(ctxt, options);\n-    xmlCtxtInitializeLate(ctxt);\n-    ctxt->myDoc = doc;\n-    \/* parsing in context, i.e. as within existing content *\/\n-    ctxt->input_id = 2;\n-\n-    \/*\n-     * TODO: Use xmlCtxtParseContent\n-     *\/\n-\n-    fake = xmlNewDocComment(node->doc, NULL);\n-    if (fake == NULL) {\n+    input = xmlCtxtNewInputFromMemory(ctxt, NULL, data, datalen,\n+                                      (const char *) doc->encoding,\n+                                      XML_INPUT_BUF_STATIC);\n+    if (input == NULL) {\n@@ -12479,32 +12474,1 @@\n-    return(XML_ERR_NO_MEMORY);\n-    }\n-    xmlAddChild(node, fake);\n-\n-    if (node->type == XML_ELEMENT_NODE)\n-    nodePush(ctxt, node);\n-\n-    if ((ctxt->html == 0) && (node->type == XML_ELEMENT_NODE)) {\n-    \/*\n-     * initialize the SAX2 namespaces stack\n-     *\/\n-    cur = node;\n-    while ((cur != NULL) && (cur->type == XML_ELEMENT_NODE)) {\n-        xmlNsPtr ns = cur->nsDef;\n-            xmlHashedString hprefix, huri;\n-\n-        while (ns != NULL) {\n-                hprefix = xmlDictLookupHashed(ctxt->dict, ns->prefix, -1);\n-                huri = xmlDictLookupHashed(ctxt->dict, ns->href, -1);\n-                if (xmlParserNsPush(ctxt, &hprefix, &huri, ns, 1) > 0)\n-                    nsnr++;\n-        ns = ns->next;\n-        }\n-        cur = cur->parent;\n-    }\n-    }\n-\n-    if ((ctxt->validate) || (ctxt->replaceEntities != 0)) {\n-    \/*\n-     * ID\/IDREF registration will be done in xmlValidateElement below\n-     *\/\n-    ctxt->loadsubset |= XML_SKIP_IDS;\n+        return(XML_ERR_NO_MEMORY);\n@@ -12513,9 +12477,1 @@\n-#ifdef LIBXML_HTML_ENABLED\n-    if (doc->type == XML_HTML_DOCUMENT_NODE)\n-        __htmlParseContent(ctxt);\n-    else\n-#endif\n-    xmlParseContentInternal(ctxt);\n-\n-    if (ctxt->input->cur < ctxt->input->end)\n-    xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n+    xmlCtxtUseOptions(ctxt, options);\n@@ -12523,1 +12479,1 @@\n-    xmlParserNsPop(ctxt, nsnr);\n+    list = xmlCtxtParseContent(ctxt, input, node, \/* hasTextDecl *\/ 0);\n@@ -12525,3 +12481,4 @@\n-    if ((ctxt->wellFormed) ||\n-        ((ctxt->recovery) && (ctxt->errNo != XML_ERR_NO_MEMORY))) {\n-        ret = XML_ERR_OK;\n+    if (list == NULL) {\n+        ret = ctxt->errNo;\n+        if (ret == XML_ERR_ARGUMENT)\n+            ret = XML_ERR_INTERNAL_ERROR;\n@@ -12529,30 +12486,2 @@\n-    ret = (xmlParserErrors) ctxt->errNo;\n-    }\n-\n-    \/*\n-     * Return the newly created nodeset after unlinking it from\n-     * the pseudo sibling.\n-     *\/\n-\n-    cur = fake->next;\n-    fake->next = NULL;\n-    node->last = fake;\n-\n-    if (cur != NULL) {\n-    cur->prev = NULL;\n-    }\n-\n-    *lst = cur;\n-\n-    while (cur != NULL) {\n-    cur->parent = NULL;\n-    cur = cur->next;\n-    }\n-\n-    xmlUnlinkNode(fake);\n-    xmlFreeNode(fake);\n-\n-\n-    if (ret != XML_ERR_OK) {\n-        xmlFreeNodeList(*lst);\n-    *lst = NULL;\n+        ret = XML_ERR_OK;\n+        *listOut = list;\n@@ -12561,2 +12490,0 @@\n-    if (doc->dict != NULL)\n-        ctxt->dict = NULL;\n@@ -12622,2 +12549,4 @@\n-    if (input == NULL)\n-        return(ctxt->errNo);\n+    if (input == NULL) {\n+        ret = ctxt->errNo;\n+        goto error;\n+    }\n@@ -12625,1 +12554,1 @@\n-    list = xmlCtxtParseContent(ctxt, input, \/* hasTextDecl *\/ 0, 1);\n+    list = xmlCtxtParseContentInternal(ctxt, input, \/* hasTextDecl *\/ 0, 1);\n@@ -12636,0 +12565,1 @@\n+error:\n@@ -12666,1 +12596,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -12681,1 +12611,1 @@\n-    ret = ctxt->myDoc;\n+        ret = ctxt->myDoc;\n@@ -12727,1 +12657,1 @@\n-                      const xmlChar *base) {\n+                          const xmlChar *base) {\n@@ -12734,1 +12664,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -12743,1 +12673,2 @@\n-    input = xmlLoadExternalEntity((char *)URL, (char *)ID, ctxt);\n+    input = xmlLoadResource(ctxt, (char *) URL, (char *) ID,\n+                            XML_RESOURCE_UNKNOWN);\n@@ -12747,1 +12678,2 @@\n-    if (inputPush(ctxt, input) < 0)\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n+        xmlFreeInputStream(input);\n@@ -12749,0 +12681,1 @@\n+    }\n@@ -12760,3 +12693,3 @@\n- *                                    *\n- *        Front ends when parsing from a file            *\n- *                                    *\n+ *                                                                      *\n+ *              Front ends when parsing from a file                     *\n+ *                                                                      *\n@@ -12786,1 +12719,3 @@\n-    return(NULL);\n+        return(NULL);\n+\n+    options |= XML_PARSE_UNZIP;\n@@ -12791,1 +12726,1 @@\n-    input = xmlLoadExternalEntity(filename, NULL, ctxt);\n+    input = xmlLoadResource(ctxt, filename, NULL, XML_RESOURCE_MAIN_DOCUMENT);\n@@ -12793,2 +12728,7 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n+    }\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n+        xmlFreeInputStream(input);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -12796,1 +12736,0 @@\n-    inputPush(ctxt, input);\n@@ -12844,1 +12783,1 @@\n-    xmlDocPtr ret;\n+    xmlDocPtr ret = NULL;\n@@ -12850,1 +12789,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -12853,1 +12792,1 @@\n-    ctxt->_private = data;\n+        ctxt->_private = data;\n@@ -12861,1 +12800,1 @@\n-        input = xmlNewInputFd(ctxt, filename, STDIN_FILENO, NULL, 0);\n+        input = xmlCtxtNewInputFromFd(ctxt, filename, STDIN_FILENO, NULL, 0);\n@@ -12863,1 +12802,1 @@\n-        input = xmlNewInputURL(ctxt, filename, NULL, NULL, 0);\n+        input = xmlCtxtNewInputFromUrl(ctxt, filename, NULL, NULL, 0);\n@@ -12865,1 +12804,2 @@\n-    ret = xmlCtxtParseDocument(ctxt, input);\n+    if (input != NULL)\n+        ret = xmlCtxtParseDocument(ctxt, input);\n@@ -12973,1 +12913,2 @@\n-    input = xmlNewInputString(ctxt, filename, (const char *) buffer, NULL, 0);\n+    input = xmlCtxtNewInputFromString(ctxt, filename, (const char *) buffer,\n+                                      NULL, 0);\n@@ -12976,1 +12917,2 @@\n-    inputPush(ctxt, input);\n+    if (xmlCtxtPushInput(ctxt, input) < 0)\n+        xmlFreeInputStream(input);\n@@ -13007,1 +12949,1 @@\n-    ctxt->userData = user_data;\n+        ctxt->userData = user_data;\n@@ -13013,1 +12955,1 @@\n-    ret = 0;\n+        ret = 0;\n@@ -13016,3 +12958,3 @@\n-        ret = ctxt->errNo;\n-    else\n-        ret = -1;\n+            ret = ctxt->errNo;\n+        else\n+            ret = -1;\n@@ -13022,1 +12964,1 @@\n-    ctxt->myDoc = NULL;\n+        ctxt->myDoc = NULL;\n@@ -13031,3 +12973,3 @@\n- *                                    *\n- *        Front ends when parsing from memory            *\n- *                                    *\n+ *                                                                      *\n+ *              Front ends when parsing from memory                     *\n+ *                                                                      *\n@@ -13052,1 +12994,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -13056,1 +12998,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -13058,1 +13000,1 @@\n-    input = xmlNewInputMemory(ctxt, NULL, buffer, size, NULL, 0);\n+    input = xmlCtxtNewInputFromMemory(ctxt, NULL, buffer, size, NULL, 0);\n@@ -13060,2 +13002,7 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n+    }\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n+        xmlFreeInputStream(input);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -13063,1 +13010,0 @@\n-    inputPush(ctxt, input);\n@@ -13093,1 +13039,1 @@\n-    xmlDocPtr ret;\n+    xmlDocPtr ret = NULL;\n@@ -13105,1 +13051,1 @@\n-    ctxt->_private=data;\n+        ctxt->_private=data;\n@@ -13112,2 +13058,2 @@\n-    input = xmlNewInputMemory(ctxt, NULL, buffer, size, NULL,\n-                              XML_INPUT_BUF_STATIC);\n+    input = xmlCtxtNewInputFromMemory(ctxt, NULL, buffer, size, NULL,\n+                                      XML_INPUT_BUF_STATIC);\n@@ -13115,1 +13061,2 @@\n-    ret = xmlCtxtParseDocument(ctxt, input);\n+    if (input != NULL)\n+        ret = xmlCtxtParseDocument(ctxt, input);\n@@ -13139,1 +13086,1 @@\n-              int size, int recovery) {\n+                  int size, int recovery) {\n@@ -13191,1 +13138,1 @@\n-              const char *buffer, int size) {\n+                          const char *buffer, int size) {\n@@ -13204,1 +13151,1 @@\n-    ctxt->userData = user_data;\n+        ctxt->userData = user_data;\n@@ -13210,1 +13157,1 @@\n-    ret = 0;\n+        ret = 0;\n@@ -13213,3 +13160,3 @@\n-        ret = ctxt->errNo;\n-    else\n-        ret = -1;\n+            ret = ctxt->errNo;\n+        else\n+            ret = -1;\n@@ -13219,1 +13166,1 @@\n-    ctxt->myDoc = NULL;\n+        ctxt->myDoc = NULL;\n@@ -13242,1 +13189,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -13244,1 +13191,1 @@\n-    input = xmlNewInputString(ctxt, NULL, (const char *) str, NULL, 0);\n+    input = xmlCtxtNewInputFromString(ctxt, NULL, (const char *) str, NULL, 0);\n@@ -13246,2 +13193,7 @@\n-    xmlFreeParserCtxt(ctxt);\n-    return(NULL);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n+    }\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n+        xmlFreeInputStream(input);\n+        xmlFreeParserCtxt(ctxt);\n+        return(NULL);\n@@ -13249,1 +13201,0 @@\n-    inputPush(ctxt, input);\n@@ -13296,1 +13247,1 @@\n-    ctxt->sax = oldsax;\n+        ctxt->sax = oldsax;\n@@ -13320,3 +13271,3 @@\n- *                                    *\n- *    New set (2.6.0) of simpler and more flexible APIs        *\n- *                                    *\n+ *                                                                      *\n+ *      New set (2.6.0) of simpler and more flexible APIs               *\n+ *                                                                      *\n@@ -13332,4 +13283,4 @@\n-#define DICT_FREE(str)                        \\\n-    if ((str) && ((!dict) ||                \\\n-        (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))    \\\n-        xmlFree((char *)(str));\n+#define DICT_FREE(str)                                          \\\n+        if ((str) && ((!dict) ||                                \\\n+            (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n+            xmlFree((char *)(str));\n@@ -13354,1 +13305,1 @@\n-    while ((input = inputPop(ctxt)) != NULL) { \/* Non consuming *\/\n+    while ((input = xmlCtxtPopInput(ctxt)) != NULL) { \/* Non consuming *\/\n@@ -13362,2 +13313,2 @@\n-    ctxt->spaceTab[0] = -1;\n-    ctxt->space = &ctxt->spaceTab[0];\n+        ctxt->spaceTab[0] = -1;\n+        ctxt->space = &ctxt->spaceTab[0];\n@@ -13406,5 +13357,0 @@\n-#if 0\n-    ctxt->vctxt.userData = ctxt;\n-    ctxt->vctxt.error = xmlParserValidityError;\n-    ctxt->vctxt.warning = xmlParserValidityWarning;\n-#endif\n@@ -13433,1 +13379,1 @@\n-    xmlCatalogFreeLocal(ctxt->catalogs);\n+        xmlCatalogFreeLocal(ctxt->catalogs);\n@@ -13464,1 +13410,1 @@\n-    input = xmlNewInputPush(ctxt, filename, chunk, size, encoding);\n+    input = xmlNewPushInput(filename, chunk, size);\n@@ -13467,1 +13413,8 @@\n-    inputPush(ctxt, input);\n+\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n+        xmlFreeInputStream(input);\n+        return(1);\n+    }\n+\n+    if (encoding != NULL)\n+        xmlSwitchEncodingName(ctxt, encoding);\n@@ -13509,1 +13462,4 @@\n-              XML_PARSE_NO_XXE;\n+              XML_PARSE_NO_XXE |\n+              XML_PARSE_UNZIP |\n+              XML_PARSE_NO_SYS_CATALOG |\n+              XML_PARSE_CATALOG_PI;\n@@ -13536,9 +13492,0 @@\n-    \/*\n-     * Changing SAX callbacks is a bad idea. This should be fixed.\n-     *\/\n-    if (options & XML_PARSE_NOBLANKS) {\n-        ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;\n-    }\n-    if (options & XML_PARSE_NOCDATA) {\n-        ctxt->sax->cdataBlock = NULL;\n-    }\n@@ -13572,0 +13519,2 @@\n+ * Not supported by the push parser.\n+ *\n@@ -13607,0 +13556,2 @@\n+ * Available since 2.13.0.\n+ *\n@@ -13622,5 +13573,3 @@\n- * Remove some text nodes containing only whitespace from the\n- * result document. Which nodes are removed depends on DTD\n- * element declarations or a conservative heuristic. The\n- * reindenting feature of the serialization code relies on this\n- * option to be set when parsing. Use of this option is\n+ * Remove some whitespace from the result document. Where to\n+ * remove whitespace depends on DTD element declarations or a\n+ * broken heuristic with unfixable bugs. Use of this option is\n@@ -13629,0 +13578,2 @@\n+ * Not supported by the push parser.\n+ *\n@@ -13636,1 +13587,1 @@\n- * Disable network access with the builtin HTTP and FTP clients.\n+ * Disable network access with the builtin HTTP client.\n@@ -13702,0 +13653,19 @@\n+ * XML_PARSE_UNZIP\n+ *\n+ * Enable input decompression. Setting this option is discouraged\n+ * to avoid zip bombs.\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * XML_PARSE_NO_SYS_CATALOG\n+ *\n+ * Disables the global system XML catalog.\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * XML_PARSE_CATALOG_PI\n+ *\n+ * Enable XML catalog processing instructions.\n+ *\n+ * Available since 2.14.0.\n+ *\n@@ -13708,0 +13678,5 @@\n+#ifdef LIBXML_HTML_ENABLED\n+    if ((ctxt != NULL) && (ctxt->html))\n+        return(htmlCtxtSetOptions(ctxt, options));\n+#endif\n+\n@@ -13711,0 +13686,19 @@\n+\/**\n+ * xmlCtxtGetOptions:\n+ * @ctxt: an XML parser context\n+ *\n+ * Get the current options of the parser context.\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns the current options set in the parser context, or -1 if ctxt is NULL.\n+ *\/\n+int\n+xmlCtxtGetOptions(xmlParserCtxtPtr ctxt)\n+{\n+    if (ctxt == NULL)\n+        return(-1);\n+\n+    return(ctxt->options);\n+}\n+\n@@ -13741,0 +13735,5 @@\n+#ifdef LIBXML_HTML_ENABLED\n+    if ((ctxt != NULL) && (ctxt->html))\n+        return(htmlCtxtUseOptions(ctxt, options));\n+#endif\n+\n@@ -13795,1 +13794,3 @@\n-    if ((ctxt == NULL) || (input == NULL))\n+    if ((ctxt == NULL) || (input == NULL)) {\n+        xmlFatalErr(ctxt, XML_ERR_ARGUMENT, NULL);\n+        xmlFreeInputStream(input);\n@@ -13797,0 +13798,1 @@\n+    }\n@@ -13800,1 +13802,1 @@\n-        xmlFreeInputStream(inputPop(ctxt));\n+        xmlFreeInputStream(xmlCtxtPopInput(ctxt));\n@@ -13802,1 +13804,1 @@\n-    if (inputPush(ctxt, input) < 0) {\n+    if (xmlCtxtPushInput(ctxt, input) < 0) {\n@@ -13809,11 +13811,1 @@\n-    if ((ctxt->wellFormed) ||\n-        ((ctxt->recovery) && (ctxt->errNo != XML_ERR_NO_MEMORY))) {\n-        ret = ctxt->myDoc;\n-    } else {\n-        if (ctxt->errNo == XML_ERR_OK)\n-            xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR, \"unknown error\\n\");\n-\n-        ret = NULL;\n-    xmlFreeDoc(ctxt->myDoc);\n-    }\n-    ctxt->myDoc = NULL;\n+    ret = xmlCtxtGetDocument(ctxt);\n@@ -13823,1 +13815,1 @@\n-        xmlFreeInputStream(inputPop(ctxt));\n+        xmlFreeInputStream(xmlCtxtPopInput(ctxt));\n@@ -13848,1 +13840,1 @@\n-    xmlDocPtr doc;\n+    xmlDocPtr doc = NULL;\n@@ -13856,2 +13848,2 @@\n-    input = xmlNewInputString(ctxt, URL, (const char *) cur, encoding,\n-                              XML_INPUT_BUF_STATIC);\n+    input = xmlCtxtNewInputFromString(ctxt, URL, (const char *) cur, encoding,\n+                                      XML_INPUT_BUF_STATIC);\n@@ -13859,1 +13851,2 @@\n-    doc = xmlCtxtParseDocument(ctxt, input);\n+    if (input != NULL)\n+        doc = xmlCtxtParseDocument(ctxt, input);\n@@ -13874,0 +13867,5 @@\n+ * This function always enables the XML_PARSE_UNZIP option for\n+ * backward compatibility. If a \"-\" filename is passed, it will\n+ * read from stdin. Both of these features are potentially\n+ * insecure and might be removed from later versions.\n+ *\n@@ -13883,1 +13881,1 @@\n-    xmlDocPtr doc;\n+    xmlDocPtr doc = NULL;\n@@ -13889,0 +13887,2 @@\n+    options |= XML_PARSE_UNZIP;\n+\n@@ -13897,2 +13897,2 @@\n-        input = xmlNewInputFd(ctxt, filename, STDIN_FILENO, encoding,\n-                              XML_INPUT_UNZIP);\n+        input = xmlCtxtNewInputFromFd(ctxt, filename, STDIN_FILENO,\n+                                      encoding, 0);\n@@ -13900,1 +13900,1 @@\n-        input = xmlNewInputURL(ctxt, filename, NULL, encoding, 0);\n+        input = xmlCtxtNewInputFromUrl(ctxt, filename, NULL, encoding, 0);\n@@ -13902,1 +13902,2 @@\n-    doc = xmlCtxtParseDocument(ctxt, input);\n+    if (input != NULL)\n+        doc = xmlCtxtParseDocument(ctxt, input);\n@@ -13929,1 +13930,1 @@\n-    xmlDocPtr doc;\n+    xmlDocPtr doc = NULL;\n@@ -13932,1 +13933,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -13940,2 +13941,2 @@\n-    input = xmlNewInputMemory(ctxt, url, buffer, size, encoding,\n-                              XML_INPUT_BUF_STATIC);\n+    input = xmlCtxtNewInputFromMemory(ctxt, url, buffer, size, encoding,\n+                                      XML_INPUT_BUF_STATIC);\n@@ -13943,1 +13944,2 @@\n-    doc = xmlCtxtParseDocument(ctxt, input);\n+    if (input != NULL)\n+        doc = xmlCtxtParseDocument(ctxt, input);\n@@ -13970,1 +13972,1 @@\n-    xmlDocPtr doc;\n+    xmlDocPtr doc = NULL;\n@@ -13978,1 +13980,1 @@\n-    input = xmlNewInputFd(ctxt, URL, fd, encoding, 0);\n+    input = xmlCtxtNewInputFromFd(ctxt, URL, fd, encoding, 0);\n@@ -13980,1 +13982,2 @@\n-    doc = xmlCtxtParseDocument(ctxt, input);\n+    if (input != NULL)\n+        doc = xmlCtxtParseDocument(ctxt, input);\n@@ -14007,1 +14010,1 @@\n-    xmlDocPtr doc;\n+    xmlDocPtr doc = NULL;\n@@ -14015,1 +14018,2 @@\n-    input = xmlNewInputIO(ctxt, URL, ioread, ioclose, ioctx, encoding, 0);\n+    input = xmlCtxtNewInputFromIO(ctxt, URL, ioread, ioclose, ioctx,\n+                                  encoding, 0);\n@@ -14017,1 +14021,2 @@\n-    doc = xmlCtxtParseDocument(ctxt, input);\n+    if (input != NULL)\n+        doc = xmlCtxtParseDocument(ctxt, input);\n@@ -14052,2 +14057,4 @@\n-    input = xmlNewInputString(ctxt, URL, (const char *) str, encoding,\n-                              XML_INPUT_BUF_STATIC);\n+    input = xmlCtxtNewInputFromString(ctxt, URL, (const char *) str, encoding,\n+                                      XML_INPUT_BUF_STATIC);\n+    if (input == NULL)\n+        return(NULL);\n@@ -14068,0 +14075,4 @@\n+ * This function always enables the XML_PARSE_UNZIP option for\n+ * backward compatibility. This feature is potentially insecure\n+ * and might be removed from later versions.\n+ *\n@@ -14079,0 +14090,2 @@\n+    options |= XML_PARSE_UNZIP;\n+\n@@ -14082,1 +14095,3 @@\n-    input = xmlNewInputURL(ctxt, filename, NULL, encoding, 0);\n+    input = xmlCtxtNewInputFromUrl(ctxt, filename, NULL, encoding, 0);\n+    if (input == NULL)\n+        return(NULL);\n@@ -14118,2 +14133,4 @@\n-    input = xmlNewInputMemory(ctxt, URL, buffer, size, encoding,\n-                              XML_INPUT_BUF_STATIC);\n+    input = xmlCtxtNewInputFromMemory(ctxt, URL, buffer, size, encoding,\n+                                      XML_INPUT_BUF_STATIC);\n+    if (input == NULL)\n+        return(NULL);\n@@ -14149,1 +14166,0 @@\n-    int inputFlags;\n@@ -14157,4 +14173,3 @@\n-    inputFlags = 0;\n-    if (options & XML_PARSE_UNZIP)\n-        inputFlags |= XML_INPUT_UNZIP;\n-    input = xmlNewInputFd(ctxt, URL, fd, encoding, inputFlags);\n+    input = xmlCtxtNewInputFromFd(ctxt, URL, fd, encoding, 0);\n+    if (input == NULL)\n+        return(NULL);\n@@ -14188,1 +14203,1 @@\n-          const char *URL,\n+              const char *URL,\n@@ -14199,1 +14214,4 @@\n-    input = xmlNewInputIO(ctxt, URL, ioread, ioclose, ioctx, encoding, 0);\n+    input = xmlCtxtNewInputFromIO(ctxt, URL, ioread, ioclose, ioctx,\n+                                  encoding, 0);\n+    if (input == NULL)\n+        return(NULL);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/parser.c","additions":3432,"deletions":3414,"binary":false,"changes":6846,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"private\/memory.h\"\n@@ -49,0 +50,4 @@\n+#ifndef SIZE_MAX\n+  #define SIZE_MAX ((size_t) -1)\n+#endif\n+\n@@ -74,3 +79,3 @@\n-    fprintf(stderr,\n-        \"Fatal: program compiled against libxml %d using libxml %d\\n\",\n-        (version \/ 10000), (myversion \/ 10000));\n+        xmlPrintErrorMessage(\n+                \"Fatal: program compiled against libxml %d using libxml %d\\n\",\n+                (version \/ 10000), (myversion \/ 10000));\n@@ -78,3 +83,3 @@\n-    fprintf(stderr,\n-        \"Warning: program compiled against libxml %d using older %d\\n\",\n-        (version \/ 100), (myversion \/ 100));\n+        xmlPrintErrorMessage(\n+                \"Warning: program compiled against libxml %d using older %d\\n\",\n+                (version \/ 100), (myversion \/ 100));\n@@ -86,3 +91,3 @@\n- *                                    *\n- *        Some factorized error routines                *\n- *                                    *\n+ *                                                                      *\n+ *              Some factorized error routines                          *\n+ *                                                                      *\n@@ -124,0 +129,40 @@\n+\/**\n+ * xmlCtxtGetLastError:\n+ * @ctx:  an XML parser context\n+ *\n+ * Get the last parsing error registered.\n+ *\n+ * Returns NULL if no error occurred or a pointer to the error\n+ *\/\n+const xmlError *\n+xmlCtxtGetLastError(void *ctx)\n+{\n+    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;\n+\n+    if (ctxt == NULL)\n+        return (NULL);\n+    if (ctxt->lastError.code == XML_ERR_OK)\n+        return (NULL);\n+    return (&ctxt->lastError);\n+}\n+\n+\/**\n+ * xmlCtxtResetLastError:\n+ * @ctx:  an XML parser context\n+ *\n+ * Cleanup the last global error registered. For parsing error\n+ * this does not change the well-formedness result.\n+ *\/\n+void\n+xmlCtxtResetLastError(void *ctx)\n+{\n+    xmlParserCtxtPtr ctxt = (xmlParserCtxtPtr) ctx;\n+\n+    if (ctxt == NULL)\n+        return;\n+    ctxt->errNo = XML_ERR_OK;\n+    if (ctxt->lastError.code == XML_ERR_OK)\n+        return;\n+    xmlResetError(&ctxt->lastError);\n+}\n+\n@@ -139,1 +184,2 @@\n-    if (ctxt == NULL)\n+    if (ctxt == NULL) {\n+        xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_PARSER, NULL);\n@@ -141,0 +187,1 @@\n+    }\n@@ -182,6 +229,0 @@\n-    \/*\n-     * Only report a warning if a file could not be found. This should\n-     * only be done for external entities, but the external entity loader\n-     * of xsltproc can try multiple paths and assumes that ENOENT doesn't\n-     * raise an error and aborts parsing.\n-     *\/\n@@ -189,1 +230,0 @@\n-         (code == XML_IO_NETWORK_ATTEMPT) ||\n@@ -191,0 +231,6 @@\n+        \/*\n+         * Only report a warning if a file could not be found. This should\n+         * only be done for external entities, but the external entity loader\n+         * of xsltproc can try multiple paths and assumes that ENOENT doesn't\n+         * raise an error and aborts parsing.\n+         *\/\n@@ -195,0 +241,2 @@\n+    } else if (code == XML_IO_NETWORK_ATTEMPT) {\n+        level = XML_ERR_ERROR;\n@@ -216,0 +264,15 @@\n+\/**\n+ * xmlCtxtIsCatastrophicError:\n+ * @ctxt:  parser context\n+ *\n+ * Returns true if the last error is catastrophic.\n+ *\/\n+int\n+xmlCtxtIsCatastrophicError(xmlParserCtxtPtr ctxt) {\n+    if (ctxt == NULL)\n+        return(1);\n+\n+    return(xmlIsCatastrophicError(ctxt->lastError.level,\n+                                  ctxt->lastError.code));\n+}\n+\n@@ -251,0 +314,11 @@\n+    if (ctxt == NULL) {\n+        res = xmlVRaiseError(NULL, NULL, NULL, NULL, node, domain, code,\n+                             level, NULL, 0, (const char *) str1,\n+                             (const char *) str2, (const char *) str3,\n+                             int1, 0, msg, ap);\n+        if (res < 0)\n+            xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_PARSER, NULL);\n+\n+        return;\n+    }\n+\n@@ -252,1 +326,5 @@\n-    return;\n+        return;\n+\n+    \/* Don't overwrite catastrophic errors *\/\n+    if (xmlCtxtIsCatastrophicError(ctxt))\n+        return;\n@@ -256,1 +334,1 @@\n-            goto done;\n+            return;\n@@ -261,2 +339,3 @@\n-            ((level < XML_ERR_FATAL) || (ctxt->wellFormed == 0)))\n-            goto done;\n+            ((level < XML_ERR_FATAL) || (ctxt->wellFormed == 0)) &&\n+            (!xmlIsCatastrophicError(level, code)))\n+            return;\n@@ -313,1 +392,0 @@\n-done:\n@@ -318,1 +396,4 @@\n-        if (ctxt->recovery == 0)\n+\n+        if (xmlCtxtIsCatastrophicError(ctxt))\n+            ctxt->disableSAX = 2; \/* stop parser *\/\n+        else if (ctxt->recovery == 0)\n@@ -321,2 +402,0 @@\n-\n-    return;\n@@ -355,0 +434,36 @@\n+\/**\n+ * xmlCtxtGetStatus:\n+ * @ctxt:  an XML parser context\n+ *\n+ * Get well-formedness and validation status after parsing. Also\n+ * reports catastrophic errors which are not related to parsing\n+ * like out-of-memory, I\/O or other errors.\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns a bitmask of XML_STATUS_* flags ORed together.\n+ *\/\n+xmlParserStatus\n+xmlCtxtGetStatus(xmlParserCtxt *ctxt) {\n+    xmlParserStatus bits = 0;\n+\n+    if (xmlCtxtIsCatastrophicError(ctxt)) {\n+        bits |= XML_STATUS_CATASTROPHIC_ERROR |\n+                XML_STATUS_NOT_WELL_FORMED |\n+                XML_STATUS_NOT_NS_WELL_FORMED;\n+        if ((ctxt != NULL) && (ctxt->validate))\n+            bits |= XML_STATUS_DTD_VALIDATION_FAILED;\n+\n+        return(bits);\n+    }\n+\n+    if (!ctxt->wellFormed)\n+        bits |= XML_STATUS_NOT_WELL_FORMED;\n+    if (!ctxt->nsWellFormed)\n+        bits |= XML_STATUS_NOT_NS_WELL_FORMED;\n+    if ((ctxt->validate) && (!ctxt->valid))\n+        bits |= XML_STATUS_DTD_VALIDATION_FAILED;\n+\n+    return(bits);\n+}\n+\n@@ -384,0 +499,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -395,3 +512,3 @@\n- *                                    *\n- *        Input handling functions for progressive parsing    *\n- *                                    *\n+ *                                                                      *\n+ *              Input handling functions for progressive parsing        *\n+ *                                                                      *\n@@ -466,1 +583,1 @@\n-    return(-1);\n+        return(-1);\n@@ -482,0 +599,43 @@\n+\/**\n+ * xmlParserCheckEOF:\n+ * @ctxt:  parser ctxt\n+ * @code:  error code\n+ *\n+ * Raises an error with @code if the input wasn't consumed\n+ * completely.\n+ *\/\n+void\n+xmlParserCheckEOF(xmlParserCtxtPtr ctxt, xmlParserErrors code) {\n+    xmlParserInputPtr in = ctxt->input;\n+    xmlParserInputBufferPtr buf;\n+\n+    if (ctxt->errNo != XML_ERR_OK)\n+        return;\n+\n+    if (in->cur < in->end) {\n+        xmlFatalErr(ctxt, code, NULL);\n+        return;\n+    }\n+\n+    buf = in->buf;\n+    if ((buf != NULL) && (buf->encoder != NULL)) {\n+        size_t curBase = in->cur - in->base;\n+        size_t sizeOut = 64;\n+        xmlCharEncError ret;\n+\n+        \/*\n+         * Check for truncated multi-byte sequence\n+         *\/\n+        ret = xmlCharEncInput(buf, &sizeOut, \/* flush *\/ 1);\n+        xmlBufUpdateInput(buf->buffer, in, curBase);\n+        if (ret != XML_ENC_ERR_SUCCESS) {\n+            xmlCtxtErrIO(ctxt, buf->error, NULL);\n+            return;\n+        }\n+\n+        \/* Shouldn't happen *\/\n+        if (in->cur < in->end)\n+            xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"expected EOF\");\n+    }\n+}\n+\n@@ -539,1 +699,1 @@\n-    size_t used;\n+    size_t used, res;\n@@ -543,5 +703,0 @@\n-    \/* Don't shrink pull parser memory buffers. *\/\n-    if ((!PARSER_PROGRESSIVE(ctxt)) &&\n-        (buf->encoder == NULL) &&\n-        (buf->readcallback == NULL))\n-        return;\n@@ -550,6 +705,0 @@\n-    \/*\n-     * Do not shrink on large buffers whose only a tiny fraction\n-     * was consumed\n-     *\/\n-    if (used > INPUT_CHUNK) {\n-    size_t res = xmlBufShrink(buf->buffer, used - LINE_LEN);\n@@ -557,1 +706,4 @@\n-    if (res > 0) {\n+    if (used > LINE_LEN) {\n+        res = xmlBufShrink(buf->buffer, used - LINE_LEN);\n+\n+        if (res > 0) {\n@@ -564,2 +716,1 @@\n-    }\n-    }\n+        }\n@@ -567,1 +718,2 @@\n-    xmlBufUpdateInput(buf->buffer, in, used);\n+        xmlBufUpdateInput(buf->buffer, in, used);\n+    }\n@@ -590,7 +742,4 @@\n-    \/*\n-     * Do not shrink on large buffers whose only a tiny fraction\n-     * was consumed\n-     *\/\n-    if (used > INPUT_CHUNK) {\n-    ret = xmlBufShrink(in->buf->buffer, used - LINE_LEN);\n-    if (ret > 0) {\n+\n+    if (used > LINE_LEN) {\n+        ret = xmlBufShrink(in->buf->buffer, used - LINE_LEN);\n+        if (ret > 0) {\n@@ -603,6 +752,1 @@\n-    }\n-    }\n-\n-    if (xmlBufUse(in->buf->buffer) <= INPUT_CHUNK) {\n-        xmlParserInputBufferRead(in->buf, 2 * INPUT_CHUNK);\n-    }\n+        }\n@@ -610,7 +754,1 @@\n-    in->base = xmlBufContent(in->buf->buffer);\n-    if (in->base == NULL) {\n-        \/* TODO: raise error *\/\n-        in->base = BAD_CAST \"\";\n-        in->cur = in->base;\n-        in->end = in->base;\n-        return;\n+        xmlBufUpdateInput(in->buf->buffer, in, used);\n@@ -618,2 +756,0 @@\n-    in->cur = in->base + used;\n-    in->end = xmlBufEnd(in->buf->buffer);\n@@ -623,3 +759,3 @@\n- *                                    *\n- *        UTF8 character input and related functions        *\n- *                                    *\n+ *                                                                      *\n+ *              UTF8 character input and related functions              *\n+ *                                                                      *\n@@ -722,1 +858,0 @@\n-    return;\n@@ -764,1 +899,1 @@\n-    \/* 1-byte code *\/\n+        \/* 1-byte code *\/\n@@ -858,1 +993,1 @@\n-    return(0xFFFD); \/* U+FFFD Replacement Character *\/\n+    return(XML_INVALID_CHAR);\n@@ -905,0 +1040,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -922,6 +1059,6 @@\n-    xmlChar *savedout = out;\n-    int bits;\n-    if (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }\n-    else if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}\n-    else if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }\n-    else {\n+        xmlChar *savedout = out;\n+        int bits;\n+        if (val <   0x800) { *out++= (val >>  6) | 0xC0;  bits=  0; }\n+        else if (val < 0x10000) { *out++= (val >> 12) | 0xE0;  bits=  6;}\n+        else if (val < 0x110000)  { *out++= (val >> 18) | 0xF0;  bits=  12; }\n+        else {\n@@ -929,2 +1066,1 @@\n-            fprintf(stderr, \"xmlCopyCharMultiByte: codepoint out of range\\n\");\n-            abort();\n+            xmlAbort(\"xmlCopyCharMultiByte: codepoint out of range\\n\");\n@@ -932,5 +1068,5 @@\n-        return(0);\n-    }\n-    for ( ; bits >= 0; bits-= 6)\n-        *out++= ((val >> bits) & 0x3F) | 0x80 ;\n-    return (out - savedout);\n+            return(0);\n+        }\n+        for ( ; bits >= 0; bits-= 6)\n+            *out++= ((val >> bits) & 0x3F) | 0x80 ;\n+        return (out - savedout);\n@@ -948,0 +1084,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -958,1 +1096,1 @@\n-    return(xmlCopyCharMultiByte (out, val));\n+        return(xmlCopyCharMultiByte (out, val));\n@@ -965,3 +1103,3 @@\n- *                                    *\n- *        Commodity functions to switch encodings            *\n- *                                    *\n+ *                                                                      *\n+ *              Commodity functions to switch encodings                 *\n+ *                                                                      *\n@@ -970,2 +1108,26 @@\n-static int\n-xmlDetectEBCDIC(xmlParserInputPtr input, xmlCharEncodingHandlerPtr *hout) {\n+\/**\n+ * xmlCtxtSetCharEncConvImpl:\n+ * @ctxt:  parser context\n+ * @impl:  callback\n+ * @vctxt:  user data\n+ *\n+ * Installs a custom implementation to convert between character\n+ * encodings.\n+ *\n+ * This bypasses legacy feature like global encoding handlers or\n+ * encoding aliases.\n+ *\n+ * Available since 2.14.0.\n+ *\/\n+void\n+xmlCtxtSetCharEncConvImpl(xmlParserCtxtPtr ctxt, xmlCharEncConvImpl impl,\n+                          void *vctxt) {\n+    if (ctxt == NULL)\n+        return;\n+\n+    ctxt->convImpl = impl;\n+    ctxt->convCtxt = vctxt;\n+}\n+\n+static xmlParserErrors\n+xmlDetectEBCDIC(xmlParserCtxtPtr ctxt, xmlCharEncodingHandlerPtr *hout) {\n@@ -973,0 +1135,1 @@\n+    xmlParserInputPtr input = ctxt->input;\n@@ -974,1 +1137,3 @@\n-    int inlen, outlen, res, i;\n+    int inlen, outlen, i;\n+    xmlParserErrors code;\n+    xmlCharEncError res;\n@@ -980,1 +1145,1 @@\n-     * to EBCDIC-US and try to find the encoding declaration.\n+     * to IBM037 (EBCDIC-US) and try to find the encoding declaration.\n@@ -982,3 +1147,4 @@\n-    res = xmlLookupCharEncodingHandler(XML_CHAR_ENCODING_EBCDIC, &handler);\n-    if (res != 0)\n-        return(res);\n+    code = xmlCreateCharEncodingHandler(\"IBM037\", XML_ENC_INPUT,\n+            ctxt->convImpl, ctxt->convCtxt, &handler);\n+    if (code != XML_ERR_OK)\n+        return(code);\n@@ -987,1 +1153,2 @@\n-    res = xmlEncInputChunk(handler, out, &outlen, input->cur, &inlen);\n+    res = xmlEncInputChunk(handler, out, &outlen, input->cur, &inlen,\n+                           \/* flush *\/ 0);\n@@ -1025,4 +1192,5 @@\n-            res = xmlOpenCharEncodingHandler((char *) out + start,\n-                                             \/* output *\/ 0, &handler);\n-            if (res != 0)\n-                return(res);\n+            code = xmlCreateCharEncodingHandler((char *) out + start,\n+                    XML_ENC_INPUT, ctxt->convImpl, ctxt->convCtxt,\n+                    &handler);\n+            if (code != XML_ERR_OK)\n+                return(code);\n@@ -1030,1 +1198,1 @@\n-            return(0);\n+            return(XML_ERR_OK);\n@@ -1039,3 +1207,4 @@\n-    res = xmlLookupCharEncodingHandler(XML_CHAR_ENCODING_EBCDIC, &handler);\n-    if (res != 0)\n-        return(res);\n+    code = xmlCreateCharEncodingHandler(\"IBM037\", XML_ENC_INPUT,\n+            ctxt->convImpl, ctxt->convCtxt, &handler);\n+    if (code != XML_ERR_OK)\n+        return(code);\n@@ -1043,1 +1212,1 @@\n-    return(0);\n+    return(XML_ERR_OK);\n@@ -1064,1 +1233,1 @@\n-    int res;\n+    xmlParserErrors code;\n@@ -1069,18 +1238,3 @@\n-    switch (enc) {\n-    case XML_CHAR_ENCODING_NONE:\n-    case XML_CHAR_ENCODING_UTF8:\n-        case XML_CHAR_ENCODING_ASCII:\n-            res = 0;\n-            break;\n-        case XML_CHAR_ENCODING_EBCDIC:\n-            res = xmlDetectEBCDIC(ctxt->input, &handler);\n-            break;\n-        default:\n-            res = xmlLookupCharEncodingHandler(enc, &handler);\n-            break;\n-    }\n-\n-    if (res != 0) {\n-        const char *name = xmlGetCharEncodingName(enc);\n-\n-        xmlFatalErr(ctxt, res, (name ? name : \"<null>\"));\n+    code = xmlLookupCharEncodingHandler(enc, &handler);\n+    if (code != 0) {\n+        xmlFatalErr(ctxt, code, NULL);\n@@ -1090,1 +1244,1 @@\n-    ret = xmlSwitchInputEncoding(ctxt, ctxt->input, handler);\n+    ret = xmlSwitchToEncoding(ctxt, handler);\n@@ -1100,2 +1254,2 @@\n- * xmlSwitchEncodingName:\n- * @ctxt:  the parser context, only for error reporting\n+ * xmlSwitchInputEncodingName:\n+ * @ctxt:  the parser context\n@@ -1105,2 +1259,0 @@\n- * Available since 2.13.0.\n- *\n@@ -1113,1 +1265,1 @@\n-    int res;\n+    xmlParserErrors res;\n@@ -1118,1 +1270,2 @@\n-    res = xmlOpenCharEncodingHandler(encoding, \/* output *\/ 0, &handler);\n+    res = xmlCreateCharEncodingHandler(encoding, XML_ENC_INPUT,\n+            ctxt->convImpl, ctxt->convCtxt, &handler);\n@@ -1128,1 +1281,7 @@\n-    return(xmlSwitchInputEncoding(ctxt, input, handler));\n+    res  = xmlInputSetEncodingHandler(input, handler);\n+    if (res != XML_ERR_OK) {\n+        xmlCtxtErrIO(ctxt, res, NULL);\n+        return(-1);\n+    }\n+\n+    return(0);\n@@ -1155,2 +1314,1 @@\n- * xmlSwitchInputEncoding:\n- * @ctxt:  the parser context, only for error reporting\n+ * xmlInputSetEncodingHandler:\n@@ -1160,2 +1318,0 @@\n- * DEPRECATED: Internal function, don't use.\n- *\n@@ -1164,1 +1320,3 @@\n- * Returns 0 in case of success, -1 otherwise\n+ * Closes the handler on error.\n+ *\n+ * Returns an xmlParserErrors code.\n@@ -1166,5 +1324,3 @@\n-int\n-xmlSwitchInputEncoding(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n-                       xmlCharEncodingHandlerPtr handler)\n-{\n-    int nbchars;\n+xmlParserErrors\n+xmlInputSetEncodingHandler(xmlParserInputPtr input,\n+                           xmlCharEncodingHandlerPtr handler) {\n@@ -1172,0 +1328,2 @@\n+    xmlBufPtr buf;\n+    xmlParserErrors code = XML_ERR_OK;\n@@ -1175,1 +1333,1 @@\n-    return (-1);\n+        return(XML_ERR_ARGUMENT);\n@@ -1191,1 +1349,1 @@\n-        return (0);\n+        return(XML_ERR_OK);\n@@ -1205,1 +1363,7 @@\n-        return (0);\n+        return(XML_ERR_OK);\n+    }\n+\n+    buf = xmlBufCreate(XML_IO_BUFFER_SIZE);\n+    if (buf == NULL) {\n+        xmlCharEncCloseFunc(handler);\n+        return(XML_ERR_NO_MEMORY);\n@@ -1209,0 +1373,2 @@\n+    in->raw = in->buffer;\n+    in->buffer = buf;\n@@ -1213,2 +1379,1 @@\n-    if (xmlBufIsEmpty(in->buffer) == 0) {\n-        xmlBufPtr buf;\n+    if (input->end > input->base) {\n@@ -1216,6 +1381,2 @@\n-\n-        buf = xmlBufCreate();\n-        if (buf == NULL) {\n-            xmlCtxtErrMemory(ctxt);\n-            return(-1);\n-        }\n+        size_t nbchars;\n+        xmlCharEncError res;\n@@ -1228,1 +1389,1 @@\n-        xmlBufShrink(in->buffer, processed);\n+        xmlBufShrink(in->raw, processed);\n@@ -1230,2 +1391,0 @@\n-        in->raw = in->buffer;\n-        in->buffer = buf;\n@@ -1234,9 +1393,40 @@\n-        nbchars = xmlCharEncInput(in);\n-        xmlBufResetInput(in->buffer, input);\n-        if (nbchars == XML_ENC_ERR_MEMORY) {\n-            xmlCtxtErrMemory(ctxt);\n-        } else if (nbchars < 0) {\n-            xmlCtxtErrIO(ctxt, in->error, NULL);\n-            xmlHaltParser(ctxt);\n-            return (-1);\n-        }\n+        \/*\n+         * If we're push-parsing, we must convert the whole buffer.\n+         *\n+         * If we're pull-parsing, we could be parsing from a huge\n+         * memory buffer which we don't want to convert completely.\n+         *\/\n+        if (input->flags & XML_INPUT_PROGRESSIVE)\n+            nbchars = SIZE_MAX;\n+        else\n+            nbchars = 4000 \/* MINLEN *\/;\n+        res = xmlCharEncInput(in, &nbchars, \/* flush *\/ 0);\n+        if (res != XML_ENC_ERR_SUCCESS)\n+            code = in->error;\n+    }\n+\n+    xmlBufResetInput(in->buffer, input);\n+\n+    return(code);\n+}\n+\n+\/**\n+ * xmlSwitchInputEncoding:\n+ * @ctxt:  the parser context, only for error reporting\n+ * @input:  the input stream\n+ * @handler:  the encoding handler\n+ *\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Use encoding handler to decode input data.\n+ *\n+ * Returns 0 in case of success, -1 otherwise\n+ *\/\n+int\n+xmlSwitchInputEncoding(xmlParserCtxtPtr ctxt, xmlParserInputPtr input,\n+                       xmlCharEncodingHandlerPtr handler) {\n+    xmlParserErrors code = xmlInputSetEncodingHandler(input, handler);\n+\n+    if (code != XML_ERR_OK) {\n+        xmlCtxtErrIO(ctxt, code, NULL);\n+        return(-1);\n@@ -1244,1 +1434,2 @@\n-    return (0);\n+\n+    return(0);\n@@ -1262,0 +1453,2 @@\n+    xmlParserErrors code;\n+\n@@ -1264,1 +1457,8 @@\n-    return(xmlSwitchInputEncoding(ctxt, ctxt->input, handler));\n+\n+    code = xmlInputSetEncodingHandler(ctxt->input, handler);\n+    if (code != XML_ERR_OK) {\n+        xmlCtxtErrIO(ctxt, code, NULL);\n+        return(-1);\n+    }\n+\n+    return(0);\n@@ -1303,0 +1503,6 @@\n+    \/*\n+     * BOM sniffing and detection of initial bytes of an XML\n+     * declaration.\n+     *\n+     * The HTML5 spec doesn't cover UTF-32 (UCS-4) or EBCDIC.\n+     *\/\n@@ -1305,1 +1511,2 @@\n-            if ((in[1] == 0x00) && (in[2] == 0x00) && (in[3] == 0x3C)) {\n+            if ((!ctxt->html) &&\n+                (in[1] == 0x00) && (in[2] == 0x00) && (in[3] == 0x3C)) {\n@@ -1309,0 +1516,4 @@\n+                \/*\n+                 * TODO: The HTML5 spec requires to check that the\n+                 * next codepoint is an 'x'.\n+                 *\/\n@@ -1316,1 +1527,2 @@\n-                if ((in[2] == 0x00) && (in[3] == 0x00)) {\n+                if ((!ctxt->html) &&\n+                    (in[2] == 0x00) && (in[3] == 0x00)) {\n@@ -1320,0 +1532,4 @@\n+                    \/*\n+                     * TODO: The HTML5 spec requires to check that the\n+                     * next codepoint is an 'x'.\n+                     *\/\n@@ -1327,2 +1543,3 @@\n-        if ((in[1] == 0x6F) && (in[2] == 0xA7) && (in[3] == 0x94)) {\n-            enc = XML_CHAR_ENCODING_EBCDIC;\n+            if ((!ctxt->html) &&\n+                (in[1] == 0x6F) && (in[2] == 0xA7) && (in[3] == 0x94)) {\n+                enc = XML_CHAR_ENCODING_EBCDIC;\n@@ -1364,1 +1581,14 @@\n-        xmlSwitchEncoding(ctxt, enc);\n+\n+        if (enc == XML_CHAR_ENCODING_EBCDIC) {\n+            xmlCharEncodingHandlerPtr handler;\n+            xmlParserErrors res;\n+\n+            res = xmlDetectEBCDIC(ctxt, &handler);\n+            if (res != XML_ERR_OK) {\n+                xmlFatalErr(ctxt, res, \"detecting EBCDIC\\n\");\n+            } else {\n+                xmlSwitchToEncoding(ctxt, handler);\n+            }\n+        } else {\n+            xmlSwitchEncoding(ctxt, enc);\n+        }\n@@ -1385,1 +1615,1 @@\n-        int res;\n+        xmlParserErrors res;\n@@ -1388,1 +1618,1 @@\n-         * xmlSwitchInputEncodingName treats unsupported encodings as\n+         * xmlSwitchEncodingName treats unsupported encodings as\n@@ -1392,2 +1622,2 @@\n-        res = xmlOpenCharEncodingHandler((const char *) encoding,\n-                \/* output *\/ 0, &handler);\n+        res = xmlCreateCharEncodingHandler((const char *) encoding,\n+                XML_ENC_INPUT, ctxt->convImpl, ctxt->convCtxt, &handler);\n@@ -1400,1 +1630,1 @@\n-        res  = xmlSwitchInputEncoding(ctxt, ctxt->input, handler);\n+        res  = xmlInputSetEncodingHandler(ctxt->input, handler);\n@@ -1402,0 +1632,1 @@\n+            xmlCtxtErrIO(ctxt, res, NULL);\n@@ -1464,0 +1695,17 @@\n+\/**\n+ * xmlCtxtGetDeclaredEncoding:\n+ * @ctxt:  parser context\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns the encoding from the encoding declaration. This can differ\n+ * from the actual encoding.\n+ *\/\n+const xmlChar *\n+xmlCtxtGetDeclaredEncoding(xmlParserCtxtPtr ctxt) {\n+    if (ctxt == NULL)\n+        return(NULL);\n+\n+    return(ctxt->encoding);\n+}\n+\n@@ -1489,3 +1737,3 @@\n- *                                    *\n- *    Commodity functions to handle entities processing        *\n- *                                    *\n+ *                                                                      *\n+ *      Commodity functions to handle entities processing               *\n+ *                                                                      *\n@@ -1517,0 +1765,2 @@\n+ * DEPRECATED: Use xmlNewInputFromUrl or similar functions.\n+ *\n@@ -1528,1 +1778,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1534,13 +1784,0 @@\n-    \/*\n-     * If the context is NULL the id cannot be initialized, but that\n-     * should not happen while parsing which is the situation where\n-     * the id is actually needed.\n-     *\/\n-    if (ctxt != NULL) {\n-        if (input->id >= INT_MAX) {\n-            xmlCtxtErrMemory(ctxt);\n-            return(NULL);\n-        }\n-        input->id = ctxt->input_id++;\n-    }\n-\n@@ -1551,1 +1788,1 @@\n- * xmlNewInputURL:\n+ * xmlCtxtNewInputFromUrl:\n@@ -1564,2 +1801,3 @@\n-xmlNewInputURL(xmlParserCtxtPtr ctxt, const char *url, const char *publicId,\n-               const char *encoding, int flags ATTRIBUTE_UNUSED) {\n+xmlCtxtNewInputFromUrl(xmlParserCtxtPtr ctxt, const char *url,\n+                       const char *publicId, const char *encoding,\n+                       xmlParserInputFlags flags ATTRIBUTE_UNUSED) {\n@@ -1569,1 +1807,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1571,1 +1809,1 @@\n-    input = xmlLoadExternalEntity(url, publicId, ctxt);\n+    input = xmlLoadResource(ctxt, url, publicId, XML_RESOURCE_MAIN_DOCUMENT);\n@@ -1583,1 +1821,0 @@\n- * @ctxt:  parser context\n@@ -1586,1 +1823,0 @@\n- * @encoding:  character encoding (optional)\n@@ -1593,2 +1829,1 @@\n-xmlNewInputInternal(xmlParserCtxtPtr ctxt, xmlParserInputBufferPtr buf,\n-                    const char *filename, const char *encoding) {\n+xmlNewInputInternal(xmlParserInputBufferPtr buf, const char *filename) {\n@@ -1597,1 +1832,1 @@\n-    input = xmlNewInputStream(ctxt);\n+    input = (xmlParserInputPtr) xmlMalloc(sizeof(xmlParserInput));\n@@ -1599,2 +1834,2 @@\n-    xmlFreeParserInputBuffer(buf);\n-    return(NULL);\n+        xmlFreeParserInputBuffer(buf);\n+        return(NULL);\n@@ -1602,0 +1837,3 @@\n+    memset(input, 0, sizeof(xmlParserInput));\n+    input->line = 1;\n+    input->col = 1;\n@@ -1609,1 +1847,0 @@\n-            xmlCtxtErrMemory(ctxt);\n@@ -1615,3 +1852,0 @@\n-    if (encoding != NULL)\n-        xmlSwitchInputEncodingName(ctxt, input, encoding);\n-\n@@ -1622,2 +1856,1 @@\n- * xmlNewInputMemory:\n- * @ctxt:  parser context\n+ * xmlNewInputFromMemory:\n@@ -1627,1 +1860,0 @@\n- * @encoding:  character encoding (optional)\n@@ -1643,1 +1875,3 @@\n- * Returns a new parser input.\n+ * Available since 2.14.0.\n+ *\n+ * Returns a new parser input or NULL if a memory allocation failed.\n@@ -1646,3 +1880,2 @@\n-xmlNewInputMemory(xmlParserCtxtPtr ctxt, const char *url,\n-                  const void *mem, size_t size,\n-                  const char *encoding, int flags) {\n+xmlNewInputFromMemory(const char *url, const void *mem, size_t size,\n+                      xmlParserInputFlags flags) {\n@@ -1651,2 +1884,2 @@\n-    if ((ctxt == NULL) || (mem == NULL))\n-    return(NULL);\n+    if (mem == NULL)\n+        return(NULL);\n@@ -1655,2 +1888,1 @@\n-    if (buf == NULL) {\n-    xmlCtxtErrMemory(ctxt);\n+    if (buf == NULL)\n@@ -1658,1 +1890,0 @@\n-    }\n@@ -1660,1 +1891,1 @@\n-    return(xmlNewInputInternal(ctxt, buf, url, encoding));\n+    return(xmlNewInputInternal(buf, url));\n@@ -1664,1 +1895,1 @@\n- * xmlNewInputString:\n+ * xmlCtxtNewInputFromMemory:\n@@ -1667,1 +1898,2 @@\n- * @str:  zero-terminated string\n+ * @mem:  pointer to char array\n+ * @size:  size of array\n@@ -1671,0 +1903,29 @@\n+ * Returns a new parser input or NULL in case of error.\n+ *\/\n+xmlParserInputPtr\n+xmlCtxtNewInputFromMemory(xmlParserCtxtPtr ctxt, const char *url,\n+                          const void *mem, size_t size,\n+                          const char *encoding, xmlParserInputFlags flags) {\n+    xmlParserInputPtr input;\n+\n+    if ((ctxt == NULL) || (mem == NULL))\n+        return(NULL);\n+\n+    input = xmlNewInputFromMemory(url, mem, size, flags);\n+    if (input == NULL) {\n+        xmlCtxtErrMemory(ctxt);\n+        return(NULL);\n+    }\n+\n+    if (encoding != NULL)\n+        xmlSwitchInputEncodingName(ctxt, input, encoding);\n+\n+    return(input);\n+}\n+\n+\/**\n+ * xmlNewInputFromString:\n+ * @url:  base URL (optional)\n+ * @str:  zero-terminated string\n+ * @flags:  optimization hints\n+ *\n@@ -1680,1 +1941,3 @@\n- * Returns a new parser input.\n+ * Available since 2.14.0.\n+ *\n+ * Returns a new parser input or NULL if a memory allocation failed.\n@@ -1683,2 +1946,2 @@\n-xmlNewInputString(xmlParserCtxtPtr ctxt, const char *url,\n-                  const char *str, const char *encoding, int flags) {\n+xmlNewInputFromString(const char *url, const char *str,\n+                      xmlParserInputFlags flags) {\n@@ -1687,2 +1950,2 @@\n-    if ((ctxt == NULL) || (str == NULL))\n-    return(NULL);\n+    if (str == NULL)\n+        return(NULL);\n@@ -1691,2 +1954,1 @@\n-    if (buf == NULL) {\n-    xmlCtxtErrMemory(ctxt);\n+    if (buf == NULL)\n@@ -1694,1 +1956,0 @@\n-    }\n@@ -1696,1 +1957,1 @@\n-    return(xmlNewInputInternal(ctxt, buf, url, encoding));\n+    return(xmlNewInputInternal(buf, url));\n@@ -1700,1 +1961,1 @@\n- * xmlNewInputFd:\n+ * xmlCtxtNewInputFromString:\n@@ -1703,1 +1964,1 @@\n- * @fd:  file descriptor\n+ * @str:  zero-terminated string\n@@ -1705,1 +1966,30 @@\n- * @flags:  unused, pass 0\n+ * @flags:  optimization hints\n+ *\n+ * Returns a new parser input.\n+ *\/\n+xmlParserInputPtr\n+xmlCtxtNewInputFromString(xmlParserCtxtPtr ctxt, const char *url,\n+                          const char *str, const char *encoding,\n+                          xmlParserInputFlags flags) {\n+    xmlParserInputPtr input;\n+\n+    if ((ctxt == NULL) || (str == NULL))\n+        return(NULL);\n+\n+    input = xmlNewInputFromString(url, str, flags);\n+    if (input == NULL) {\n+        xmlCtxtErrMemory(ctxt);\n+        return(NULL);\n+    }\n+\n+    if (encoding != NULL)\n+        xmlSwitchInputEncodingName(ctxt, input, encoding);\n+\n+    return(input);\n+}\n+\n+\/**\n+ * xmlNewInputFromFd:\n+ * @url:  base URL (optional)\n+ * @fd:  file descriptor\n+ * @flags:  input flags\n@@ -1714,1 +2004,7 @@\n- * Returns a new parser input.\n+ * Supported @flags are XML_INPUT_UNZIP to decompress data\n+ * automatically. This feature is deprecated and will be removed\n+ * in a future release.\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns a new parser input or NULL if a memory allocation failed.\n@@ -1717,2 +2013,1 @@\n-xmlNewInputFd(xmlParserCtxtPtr ctxt, const char *url,\n-              int fd, const char *encoding, int flags) {\n+xmlNewInputFromFd(const char *url, int fd, xmlParserInputFlags flags) {\n@@ -1721,2 +2016,2 @@\n-    if ((ctxt == NULL) || (fd < 0))\n-    return(NULL);\n+    if (fd < 0)\n+        return(NULL);\n@@ -1725,2 +2020,1 @@\n-    if (buf == NULL) {\n-    xmlCtxtErrMemory(ctxt);\n+    if (buf == NULL)\n@@ -1728,1 +2022,0 @@\n-    }\n@@ -1730,1 +2023,1 @@\n-    if (xmlInputFromFd(buf, fd, (flags & XML_INPUT_UNZIP) != 0) < 0) {\n+    if (xmlInputFromFd(buf, fd, flags) != XML_ERR_OK) {\n@@ -1735,1 +2028,1 @@\n-    return(xmlNewInputInternal(ctxt, buf, url, encoding));\n+    return(xmlNewInputInternal(buf, url));\n@@ -1739,1 +2032,1 @@\n- * xmlNewInputIO:\n+ * xmlCtxtNewInputFromFd:\n@@ -1742,0 +2035,33 @@\n+ * @fd:  file descriptor\n+ * @encoding:  character encoding (optional)\n+ * @flags:  unused, pass 0\n+ *\n+ * Returns a new parser input.\n+ *\/\n+xmlParserInputPtr\n+xmlCtxtNewInputFromFd(xmlParserCtxtPtr ctxt, const char *url,\n+                      int fd, const char *encoding,\n+                      xmlParserInputFlags flags) {\n+    xmlParserInputPtr input;\n+\n+    if ((ctxt == NULL) || (fd < 0))\n+        return(NULL);\n+\n+    if (ctxt->options & XML_PARSE_UNZIP)\n+        flags |= XML_INPUT_UNZIP;\n+\n+    input = xmlNewInputFromFd(url, fd, flags);\n+    if (input == NULL) {\n+        xmlCtxtErrMemory(ctxt);\n+        return(NULL);\n+    }\n+\n+    if (encoding != NULL)\n+        xmlSwitchInputEncodingName(ctxt, input, encoding);\n+\n+    return(input);\n+}\n+\n+\/**\n+ * xmlNewInputFromIO:\n+ * @url:  base URL (optional)\n@@ -1745,1 +2071,0 @@\n- * @encoding:  character encoding (optional)\n@@ -1762,1 +2087,3 @@\n- * Returns a new parser input.\n+ * Available since 2.14.0.\n+ *\n+ * Returns a new parser input or NULL if a memory allocation failed.\n@@ -1765,4 +2092,3 @@\n-xmlNewInputIO(xmlParserCtxtPtr ctxt, const char *url,\n-              xmlInputReadCallback ioRead, xmlInputCloseCallback ioClose,\n-              void *ioCtxt,\n-              const char *encoding, int flags ATTRIBUTE_UNUSED) {\n+xmlNewInputFromIO(const char *url, xmlInputReadCallback ioRead,\n+                  xmlInputCloseCallback ioClose, void *ioCtxt,\n+                  xmlParserInputFlags flags ATTRIBUTE_UNUSED) {\n@@ -1771,2 +2097,2 @@\n-    if ((ctxt == NULL) || (ioRead == NULL))\n-    return(NULL);\n+    if (ioRead == NULL)\n+        return(NULL);\n@@ -1776,1 +2102,0 @@\n-        xmlCtxtErrMemory(ctxt);\n@@ -1786,1 +2111,1 @@\n-    return(xmlNewInputInternal(ctxt, buf, url, encoding));\n+    return(xmlNewInputInternal(buf, url));\n@@ -1790,1 +2115,1 @@\n- * xmlNewInputPush:\n+ * xmlCtxtNewInputFromIO:\n@@ -1793,0 +2118,34 @@\n+ * @ioRead:  read callback\n+ * @ioClose:  close callback (optional)\n+ * @ioCtxt:  IO context\n+ * @encoding:  character encoding (optional)\n+ * @flags:  unused, pass 0\n+ *\n+ * Returns a new parser input.\n+ *\/\n+xmlParserInputPtr\n+xmlCtxtNewInputFromIO(xmlParserCtxtPtr ctxt, const char *url,\n+                      xmlInputReadCallback ioRead,\n+                      xmlInputCloseCallback ioClose,\n+                      void *ioCtxt, const char *encoding,\n+                      xmlParserInputFlags flags) {\n+    xmlParserInputPtr input;\n+\n+    if ((ctxt == NULL) || (ioRead == NULL))\n+        return(NULL);\n+\n+    input = xmlNewInputFromIO(url, ioRead, ioClose, ioCtxt, flags);\n+    if (input == NULL) {\n+        xmlCtxtErrMemory(ctxt);\n+        return(NULL);\n+    }\n+\n+    if (encoding != NULL)\n+        xmlSwitchInputEncodingName(ctxt, input, encoding);\n+\n+    return(input);\n+}\n+\n+\/**\n+ * xmlNewPushInput:\n+ * @url:  base URL (optional)\n@@ -1795,1 +2154,0 @@\n- * @encoding:  character encoding (optional)\n@@ -1799,1 +2157,1 @@\n- * Returns a new parser input.\n+ * Returns a new parser input or NULL if a memory allocation failed.\n@@ -1802,2 +2160,1 @@\n-xmlNewInputPush(xmlParserCtxtPtr ctxt, const char *url,\n-                const char *chunk, int size, const char *encoding) {\n+xmlNewPushInput(const char *url, const char *chunk, int size) {\n@@ -1808,2 +2165,1 @@\n-    if (buf == NULL) {\n-        xmlCtxtErrMemory(ctxt);\n+    if (buf == NULL)\n@@ -1811,1 +2167,0 @@\n-    }\n@@ -1813,1 +2168,1 @@\n-    input = xmlNewInputInternal(ctxt, buf, url, encoding);\n+    input = xmlNewInputInternal(buf, url);\n@@ -1815,1 +2170,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1822,1 +2177,1 @@\n-    res = xmlParserInputBufferPush(input->buf, size, chunk);\n+        res = xmlParserInputBufferPush(input->buf, size, chunk);\n@@ -1825,1 +2180,0 @@\n-            xmlCtxtErrIO(ctxt, input->buf->error, NULL);\n@@ -1847,1 +2201,2 @@\n-                xmlCharEncoding enc) {\n+                    xmlCharEncoding enc) {\n+    xmlParserInputPtr input;\n@@ -1850,1 +2205,6 @@\n-    if (buf == NULL)\n+    if ((ctxt == NULL) || (buf == NULL))\n+        return(NULL);\n+\n+    input = xmlNewInputInternal(buf, NULL);\n+    if (input == NULL) {\n+        xmlCtxtErrMemory(ctxt);\n@@ -1852,0 +2212,1 @@\n+    }\n@@ -1854,1 +2215,4 @@\n-    return(xmlNewInputInternal(ctxt, buf, NULL, encoding));\n+    if (encoding != NULL)\n+        xmlSwitchInputEncodingName(ctxt, input, encoding);\n+\n+    return(input);\n@@ -1873,1 +2237,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1876,2 +2240,2 @@\n-        input = xmlNewInputString(ctxt, NULL, (const char *) ent->content,\n-                                  NULL, XML_INPUT_BUF_STATIC);\n+        input = xmlCtxtNewInputFromString(ctxt, NULL,\n+                (const char *) ent->content, NULL, XML_INPUT_BUF_STATIC);\n@@ -1879,2 +2243,9 @@\n-        input = xmlLoadExternalEntity((char *) ent->URI,\n-                                      (char *) ent->ExternalID, ctxt);\n+        xmlResourceType rtype;\n+\n+        if (ent->etype == XML_EXTERNAL_PARAMETER_ENTITY)\n+            rtype = XML_RESOURCE_PARAMETER_ENTITY;\n+        else\n+            rtype = XML_RESOURCE_GENERAL_ENTITY;\n+\n+        input = xmlLoadResource(ctxt, (char *) ent->URI,\n+                                (char *) ent->ExternalID, rtype);\n@@ -1898,0 +2269,2 @@\n+ * DEPRECATED: Use xmlNewInputFromString.\n+ *\n@@ -1904,1 +2277,2 @@\n-    return(xmlNewInputString(ctxt, NULL, (const char *) buffer, NULL, 0));\n+    return(xmlCtxtNewInputFromString(ctxt, NULL, (const char *) buffer,\n+                                     NULL, 0));\n@@ -1909,3 +2283,3 @@\n- *                                *\n- *        External entities loading            *\n- *                                *\n+ *                                                              *\n+ *              External entities loading                       *\n+ *                                                              *\n@@ -1933,0 +2307,2 @@\n+    int allowLocal = 0;\n+    int allowGlobal = 0;\n@@ -1940,4 +2316,0 @@\n-    if ((pref != XML_CATA_ALLOW_NONE) && (!xmlNoNetExists(URL))) {\n-    \/*\n-     * Do a local lookup\n-     *\/\n@@ -1946,22 +2318,2 @@\n-         (pref == XML_CATA_ALLOW_DOCUMENT))) {\n-        resource = xmlCatalogLocalResolve(ctxt->catalogs,\n-                          (const xmlChar *)ID,\n-                          (const xmlChar *)URL);\n-        }\n-    \/*\n-     * Try a global lookup\n-     *\/\n-    if ((resource == NULL) &&\n-        ((pref == XML_CATA_ALLOW_ALL) ||\n-         (pref == XML_CATA_ALLOW_GLOBAL))) {\n-        resource = xmlCatalogResolve((const xmlChar *)ID,\n-                     (const xmlChar *)URL);\n-    }\n-    if ((resource == NULL) && (URL != NULL))\n-        resource = xmlStrdup((const xmlChar *) URL);\n-\n-    \/*\n-     * TODO: do an URI lookup on the reference\n-     *\/\n-    if ((resource != NULL) && (!xmlNoNetExists((const char *)resource))) {\n-        xmlChar *tmp = NULL;\n+         (pref == XML_CATA_ALLOW_DOCUMENT)))\n+        allowLocal = 1;\n@@ -1969,1 +2321,2 @@\n-        if ((ctxt != NULL) && (ctxt->catalogs != NULL) &&\n+    if (((ctxt == NULL) ||\n+         ((ctxt->options & XML_PARSE_NO_SYS_CATALOG) == 0)) &&\n@@ -1971,2 +2324,11 @@\n-         (pref == XML_CATA_ALLOW_DOCUMENT))) {\n-        tmp = xmlCatalogLocalResolveURI(ctxt->catalogs, resource);\n+         (pref == XML_CATA_ALLOW_GLOBAL)))\n+        allowGlobal = 1;\n+\n+    if ((pref != XML_CATA_ALLOW_NONE) && (!xmlNoNetExists(URL))) {\n+        \/*\n+         * Do a local lookup\n+         *\/\n+        if (allowLocal) {\n+            resource = xmlCatalogLocalResolve(ctxt->catalogs,\n+                                              (const xmlChar *)ID,\n+                                              (const xmlChar *)URL);\n@@ -1974,4 +2336,6 @@\n-        if ((tmp == NULL) &&\n-        ((pref == XML_CATA_ALLOW_ALL) ||\n-             (pref == XML_CATA_ALLOW_GLOBAL))) {\n-        tmp = xmlCatalogResolveURI(resource);\n+        \/*\n+         * Try a global lookup\n+         *\/\n+        if ((resource == NULL) && (allowGlobal)) {\n+            resource = xmlCatalogResolve((const xmlChar *)ID,\n+                                         (const xmlChar *)URL);\n@@ -1979,0 +2343,2 @@\n+        if ((resource == NULL) && (URL != NULL))\n+            resource = xmlStrdup((const xmlChar *) URL);\n@@ -1980,3 +2346,17 @@\n-        if (tmp != NULL) {\n-        xmlFree(resource);\n-        resource = tmp;\n+        \/*\n+         * TODO: do an URI lookup on the reference\n+         *\/\n+        if ((resource != NULL) && (!xmlNoNetExists((const char *)resource))) {\n+            xmlChar *tmp = NULL;\n+\n+            if (allowLocal) {\n+                tmp = xmlCatalogLocalResolveURI(ctxt->catalogs, resource);\n+            }\n+            if ((tmp == NULL) && (allowGlobal)) {\n+                tmp = xmlCatalogResolveURI(resource);\n+            }\n+\n+            if (tmp != NULL) {\n+                xmlFree(resource);\n+                resource = tmp;\n+            }\n@@ -1985,1 +2365,0 @@\n-    }\n@@ -1992,0 +2371,47 @@\n+#ifdef LIBXML_HTTP_ENABLED\n+static xmlParserErrors\n+xmlCheckHTTPInputInternal(xmlParserInputPtr input) {\n+    const char *encoding;\n+    const char *redir;\n+    const char *mime;\n+    int code;\n+\n+    if ((input == NULL) || (input->buf == NULL) ||\n+        (input->buf->readcallback != xmlIOHTTPRead) ||\n+        (input->buf->context == NULL))\n+        return(XML_ERR_OK);\n+\n+    code = xmlNanoHTTPReturnCode(input->buf->context);\n+    if (code >= 400) {\n+        \/* fatal error *\/\n+        return(XML_IO_LOAD_ERROR);\n+    }\n+\n+    mime = xmlNanoHTTPMimeType(input->buf->context);\n+    if ((xmlStrstr(BAD_CAST mime, BAD_CAST \"\/xml\")) ||\n+        (xmlStrstr(BAD_CAST mime, BAD_CAST \"+xml\"))) {\n+        encoding = xmlNanoHTTPEncoding(input->buf->context);\n+        if (encoding != NULL) {\n+            xmlCharEncodingHandlerPtr handler;\n+            xmlParserErrors res;\n+\n+            res = xmlOpenCharEncodingHandler(encoding, \/* output *\/ 0,\n+                                             &handler);\n+            if (res == 0)\n+                xmlInputSetEncodingHandler(input, handler);\n+        }\n+    }\n+\n+    redir = xmlNanoHTTPRedir(input->buf->context);\n+    if (redir != NULL) {\n+        if (input->filename != NULL)\n+            xmlFree((xmlChar *) input->filename);\n+        input->filename = xmlMemStrdup(redir);\n+        if (input->filename == NULL)\n+            return(XML_ERR_NO_MEMORY);\n+    }\n+\n+    return(XML_ERR_OK);\n+}\n+#endif \/* LIBXML_HTTP_ENABLED *\/\n+\n@@ -2012,7 +2438,2 @@\n-    if ((ret != NULL) && (ret->buf != NULL) &&\n-        (ret->buf->readcallback == xmlIOHTTPRead) &&\n-        (ret->buf->context != NULL)) {\n-        const char *encoding;\n-        const char *redir;\n-        const char *mime;\n-        int code;\n+    {\n+        int code = xmlCheckHTTPInputInternal(ret);\n@@ -2020,4 +2441,2 @@\n-        code = xmlNanoHTTPReturnCode(ret->buf->context);\n-        if (code >= 400) {\n-            \/* fatal error *\/\n-        if (ret->filename != NULL)\n+        if (code != XML_ERR_OK) {\n+            if (ret->filename != NULL)\n@@ -2025,1 +2444,1 @@\n-        else\n+            else\n@@ -2028,20 +2447,1 @@\n-            ret = NULL;\n-        } else {\n-\n-            mime = xmlNanoHTTPMimeType(ret->buf->context);\n-            if ((xmlStrstr(BAD_CAST mime, BAD_CAST \"\/xml\")) ||\n-                (xmlStrstr(BAD_CAST mime, BAD_CAST \"+xml\"))) {\n-                encoding = xmlNanoHTTPEncoding(ret->buf->context);\n-                if (encoding != NULL)\n-                    xmlSwitchEncodingName(ctxt, encoding);\n-#if 0\n-            } else if (xmlStrstr(BAD_CAST mime, BAD_CAST \"html\")) {\n-#endif\n-            }\n-            redir = xmlNanoHTTPRedir(ret->buf->context);\n-            if (redir != NULL) {\n-                if (ret->filename != NULL)\n-                    xmlFree((xmlChar *) ret->filename);\n-                ret->filename =\n-                    (char *) xmlStrdup((const xmlChar *) redir);\n-            }\n+            return(NULL);\n@@ -2051,0 +2451,1 @@\n+\n@@ -2054,0 +2455,69 @@\n+\/**\n+ * xmlNewInputFromUrl:\n+ * @filename:  the filename to use as entity\n+ * @flags:  XML_INPUT flags\n+ * @out:  pointer to new parser input\n+ *\n+ * Create a new input stream based on a file or a URL.\n+ *\n+ * The flag XML_INPUT_UNZIP allows decompression.\n+ *\n+ * The flag XML_INPUT_NETWORK allows network access.\n+ *\n+ * The following resource loaders will be called if they were\n+ * registered (in order of precedence):\n+ *\n+ * - the per-thread xmlParserInputBufferCreateFilenameFunc set with\n+ *   xmlParserInputBufferCreateFilenameDefault (deprecated)\n+ * - the default loader which will return\n+ *   - the result from a matching global input callback set with\n+ *     xmlRegisterInputCallbacks (deprecated)\n+ *   - a HTTP resource if support is compiled in.\n+ *   - a file opened from the filesystem, with automatic detection\n+ *     of compressed files if support is compiled in.\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns an xmlParserErrors code.\n+ *\/\n+xmlParserErrors\n+xmlNewInputFromUrl(const char *filename, xmlParserInputFlags flags,\n+                   xmlParserInputPtr *out) {\n+    xmlParserInputBufferPtr buf;\n+    xmlParserInputPtr input;\n+    xmlParserErrors code = XML_ERR_OK;\n+\n+    if (out == NULL)\n+        return(XML_ERR_ARGUMENT);\n+    *out = NULL;\n+    if (filename == NULL)\n+        return(XML_ERR_ARGUMENT);\n+\n+    if (xmlParserInputBufferCreateFilenameValue != NULL) {\n+        buf = xmlParserInputBufferCreateFilenameValue(filename,\n+                XML_CHAR_ENCODING_NONE);\n+        if (buf == NULL)\n+            code = XML_IO_ENOENT;\n+    } else {\n+        code = xmlParserInputBufferCreateUrl(filename, XML_CHAR_ENCODING_NONE,\n+                                             flags, &buf);\n+    }\n+    if (code != XML_ERR_OK)\n+        return(code);\n+\n+    input = xmlNewInputInternal(buf, filename);\n+    if (input == NULL)\n+        return(XML_ERR_NO_MEMORY);\n+\n+#ifdef LIBXML_HTTP_ENABLED\n+    code = xmlCheckHTTPInputInternal(input);\n+    if (code != XML_ERR_OK) {\n+        xmlFreeInputStream(input);\n+        return(code);\n+    }\n+#endif\n+\n+    *out = input;\n+    return(XML_ERR_OK);\n+}\n+\n@@ -2059,0 +2529,2 @@\n+ * DEPRECATED: Use xmlNewInputFromUrl.\n+ *\n@@ -2065,5 +2537,3 @@\n-    xmlParserInputBufferPtr buf;\n-    xmlParserInputPtr inputStream;\n-    const xmlChar *URI;\n-    xmlChar *canonic;\n-    int code;\n+    xmlParserInputPtr input;\n+    xmlParserInputFlags flags = 0;\n+    xmlParserErrors code;\n@@ -2074,6 +2544,4 @@\n-    code = xmlParserInputBufferCreateFilenameSafe(filename,\n-                                                  XML_CHAR_ENCODING_NONE, &buf);\n-    if (buf == NULL) {\n-        xmlCtxtErrIO(ctxt, code, filename);\n-    return(NULL);\n-    }\n+    if (ctxt->options & XML_PARSE_UNZIP)\n+        flags |= XML_INPUT_UNZIP;\n+    if ((ctxt->options & XML_PARSE_NONET) == 0)\n+        flags |= XML_INPUT_NETWORK;\n@@ -2081,19 +2549,3 @@\n-    inputStream = xmlNewInputStream(ctxt);\n-    if (inputStream == NULL) {\n-    xmlFreeParserInputBuffer(buf);\n-    return(NULL);\n-    }\n-\n-    inputStream->buf = buf;\n-    inputStream = xmlCheckHTTPInput(ctxt, inputStream);\n-    if (inputStream == NULL)\n-        return(NULL);\n-\n-    if (inputStream->filename == NULL)\n-    URI = (xmlChar *) filename;\n-    else\n-    URI = (xmlChar *) inputStream->filename;\n-    canonic = xmlCanonicPath(URI);\n-    if (canonic == NULL) {\n-        xmlCtxtErrMemory(ctxt);\n-        xmlFreeInputStream(inputStream);\n+    code = xmlNewInputFromUrl(filename, flags, &input);\n+    if (code != XML_ERR_OK) {\n+        xmlCtxtErrIO(ctxt, code, filename);\n@@ -2102,5 +2554,0 @@\n-    if (inputStream->filename != NULL)\n-        xmlFree((char *) inputStream->filename);\n-    inputStream->filename = (char *) canonic;\n-\n-    xmlBufResetInput(inputStream->buf->buffer, inputStream);\n@@ -2108,1 +2555,1 @@\n-    return(inputStream);\n+    return(input);\n@@ -2122,1 +2569,1 @@\n-xmlDefaultExternalEntityLoader(const char *URL, const char *ID,\n+xmlDefaultExternalEntityLoader(const char *url, const char *ID,\n@@ -2125,2 +2572,2 @@\n-    xmlParserInputPtr ret = NULL;\n-    xmlChar *resource = NULL;\n+    xmlParserInputPtr input = NULL;\n+    char *resource = NULL;\n@@ -2128,2 +2575,1 @@\n-    if (URL == NULL)\n-        return(NULL);\n+    (void) ID;\n@@ -2131,2 +2577,2 @@\n-    if ((ctxt != NULL) && (ctxt->options & XML_PARSE_NONET)) {\n-        int options = ctxt->options;\n+    if (url == NULL)\n+        return(NULL);\n@@ -2134,5 +2580,0 @@\n-    ctxt->options -= XML_PARSE_NONET;\n-        ret = xmlNoNetExternalEntityLoader(URL, ID, ctxt);\n-    ctxt->options = options;\n-    return(ret);\n-    }\n@@ -2140,1 +2581,3 @@\n-    resource = xmlResolveResourceFromCatalog(URL, ID, ctxt);\n+    resource = (char *) xmlResolveResourceFromCatalog(url, ID, ctxt);\n+    if (resource != NULL)\n+        url = resource;\n@@ -2143,2 +2586,7 @@\n-    if (resource == NULL)\n-        resource = (xmlChar *) URL;\n+    if ((ctxt != NULL) &&\n+        (ctxt->options & XML_PARSE_NONET) &&\n+        (xmlStrncasecmp(BAD_CAST url, BAD_CAST \"http:\/\/\", 7) == 0)) {\n+        xmlCtxtErrIO(ctxt, XML_IO_NETWORK_ATTEMPT, url);\n+    } else {\n+        input = xmlNewInputFromFile(ctxt, url);\n+    }\n@@ -2146,2 +2594,1 @@\n-    ret = xmlNewInputFromFile(ctxt, (const char *) resource);\n-    if ((resource != NULL) && (resource != (xmlChar *) URL))\n+    if (resource != NULL)\n@@ -2149,1 +2596,1 @@\n-    return (ret);\n+    return(input);\n@@ -2158,0 +2605,2 @@\n+ * DEPRECATED: Use XML_PARSE_NONET.\n+ *\n@@ -2166,2 +2615,2 @@\n-    xmlParserInputPtr input = NULL;\n-    xmlChar *resource = NULL;\n+    int oldOptions = 0;\n+    xmlParserInputPtr input;\n@@ -2169,3 +2618,4 @@\n-#ifdef LIBXML_CATALOG_ENABLED\n-    resource = xmlResolveResourceFromCatalog(URL, ID, ctxt);\n-#endif\n+    if (ctxt != NULL) {\n+        oldOptions = ctxt->options;\n+        ctxt->options |= XML_PARSE_NONET;\n+    }\n@@ -2173,2 +2623,4 @@\n-    if (resource == NULL)\n-    resource = (xmlChar *) URL;\n+    input = xmlDefaultExternalEntityLoader(URL, ID, ctxt);\n+\n+    if (ctxt != NULL)\n+        ctxt->options = oldOptions;\n@@ -2176,19 +2628,0 @@\n-    if (resource != NULL) {\n-        if ((!xmlStrncasecmp(BAD_CAST resource, BAD_CAST \"ftp:\/\/\", 6)) ||\n-            (!xmlStrncasecmp(BAD_CAST resource, BAD_CAST \"http:\/\/\", 7))) {\n-            xmlCtxtErrIO(ctxt, XML_IO_NETWORK_ATTEMPT,\n-                         (const char *) resource);\n-            \/*\n-             * Also forward the error directly to the global error\n-             * handler, which the XML::LibXML test suite expects.\n-             *\/\n-            __xmlIOErr(XML_FROM_IO, XML_IO_NETWORK_ATTEMPT,\n-                       (const char *) resource);\n-        if (resource != (xmlChar *) URL)\n-        xmlFree(resource);\n-        return(NULL);\n-    }\n-    }\n-    input = xmlDefaultExternalEntityLoader((const char *) resource, ID, ctxt);\n-    if (resource != (xmlChar *) URL)\n-    xmlFree(resource);\n@@ -2208,1 +2641,5 @@\n- * Changes the defaultexternal entity resolver function for the application\n+ * DEPRECATED: This is a global setting and not thread-safe. Use\n+ * xmlCtxtSetResourceLoader or similar functions.\n+ *\n+ * Changes the default external entity resolver function for the\n+ * application.\n@@ -2218,0 +2655,2 @@\n+ * DEPRECATED: See xmlSetExternalEntityLoader.\n+ *\n@@ -2227,0 +2666,84 @@\n+\/**\n+ * xmlCtxtSetResourceLoader:\n+ * @ctxt:  parser context\n+ * @loader:  callback\n+ * @vctxt:  user data\n+ *\n+ * Installs a custom callback to load documents, DTDs or external\n+ * entities.\n+ *\n+ * If @vctxt is NULL, the parser context will be passed.\n+ *\n+ * Available since 2.14.0.\n+ *\/\n+void\n+xmlCtxtSetResourceLoader(xmlParserCtxtPtr ctxt, xmlResourceLoader loader,\n+                         void *vctxt) {\n+    if (ctxt == NULL)\n+        return;\n+\n+    ctxt->resourceLoader = loader;\n+    ctxt->resourceCtxt = vctxt;\n+}\n+\n+\/**\n+ * xmlLoadResource:\n+ * @ctxt:  parser context\n+ * @url:  the URL for the entity to load\n+ * @publicId:  the Public ID for the entity to load\n+ * @type:  resource type\n+ *\n+ * Returns the xmlParserInputPtr or NULL in case of error.\n+ *\/\n+xmlParserInputPtr\n+xmlLoadResource(xmlParserCtxtPtr ctxt, const char *url, const char *publicId,\n+                xmlResourceType type) {\n+    char *canonicFilename;\n+    xmlParserInputPtr ret;\n+\n+    if (url == NULL)\n+        return(NULL);\n+\n+    if ((ctxt != NULL) && (ctxt->resourceLoader != NULL)) {\n+        char *resource = NULL;\n+        void *userData;\n+        xmlParserInputFlags flags = 0;\n+        int code;\n+\n+#ifdef LIBXML_CATALOG_ENABLED\n+        resource = (char *) xmlResolveResourceFromCatalog(url, publicId, ctxt);\n+        if (resource != NULL)\n+            url = resource;\n+#endif\n+\n+        if (ctxt->options & XML_PARSE_UNZIP)\n+            flags |= XML_INPUT_UNZIP;\n+        if ((ctxt->options & XML_PARSE_NONET) == 0)\n+            flags |= XML_INPUT_NETWORK;\n+\n+        userData = ctxt->resourceCtxt;\n+        if (userData == NULL)\n+            userData = ctxt;\n+\n+        code = ctxt->resourceLoader(userData, url, publicId, type,\n+                                    flags, &ret);\n+        if (code != XML_ERR_OK) {\n+            xmlCtxtErrIO(ctxt, code, url);\n+            ret = NULL;\n+        }\n+        if (resource != NULL)\n+            xmlFree(resource);\n+        return(ret);\n+    }\n+\n+    canonicFilename = (char *) xmlCanonicPath((const xmlChar *) url);\n+    if (canonicFilename == NULL) {\n+        xmlCtxtErrMemory(ctxt);\n+        return(NULL);\n+    }\n+\n+    ret = xmlCurrentExternalEntityLoader(canonicFilename, publicId, ctxt);\n+    xmlFree(canonicFilename);\n+    return(ret);\n+}\n+\n@@ -2240,2 +2763,4 @@\n- * The following resource loaders will be called if they were\n- * registered (in order of precedence):\n+ * If catalog lookup is enabled (default is yes) and URL or ID are\n+ * found in system or local XML catalogs, URL is replaced with the\n+ * result. Then the following resource loaders will be called if\n+ * they were registered (in order of precedence):\n@@ -2243,0 +2768,1 @@\n+ * - the resource loader set with xmlCtxtSetResourceLoader\n@@ -2244,1 +2770,2 @@\n- *   xmlSetExternalEntityLoader\n+ *   xmlSetExternalEntityLoader (without catalog resolution,\n+ *   deprecated)\n@@ -2246,1 +2773,1 @@\n- *   xmlParserInputBufferCreateFilenameDefault\n+ *   xmlParserInputBufferCreateFilenameDefault (deprecated)\n@@ -2249,1 +2776,1 @@\n- *     xmlRegisterInputCallbacks\n+ *     xmlRegisterInputCallbacks (deprecated)\n@@ -2259,15 +2786,1 @@\n-    char *canonicFilename;\n-    xmlParserInputPtr ret;\n-\n-    if (URL == NULL)\n-        return(NULL);\n-\n-    canonicFilename = (char *) xmlCanonicPath((const xmlChar *) URL);\n-    if (canonicFilename == NULL) {\n-        xmlCtxtErrMemory(ctxt);\n-        return(NULL);\n-    }\n-\n-    ret = xmlCurrentExternalEntityLoader(canonicFilename, ID, ctxt);\n-    xmlFree(canonicFilename);\n-    return(ret);\n+    return(xmlLoadResource(ctxt, URL, ID, XML_RESOURCE_UNKNOWN));\n@@ -2277,3 +2790,3 @@\n- *                                    *\n- *        Commodity functions to handle parser contexts        *\n- *                                    *\n+ *                                                                      *\n+ *              Commodity functions to handle parser contexts           *\n+ *                                                                      *\n@@ -2298,0 +2811,5 @@\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+    size_t initialNodeTabSize = 1;\n+#else\n+    size_t initialNodeTabSize = 10;\n+#endif\n@@ -2303,1 +2821,1 @@\n-    ctxt->dict = xmlDictCreate();\n+        ctxt->dict = xmlDictCreate();\n@@ -2305,2 +2823,1 @@\n-    return(-1);\n-    xmlDictSetLimit(ctxt->dict, XML_MAX_DICTIONARY_LIMIT);\n+        return(-1);\n@@ -2309,1 +2826,1 @@\n-    ctxt->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));\n+        ctxt->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));\n@@ -2311,1 +2828,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2313,1 +2830,1 @@\n-    memset(ctxt->sax, 0, sizeof(xmlSAXHandler));\n+        memset(ctxt->sax, 0, sizeof(xmlSAXHandler));\n@@ -2317,2 +2834,2 @@\n-    if (sax->initialized == XML_SAX2_MAGIC) {\n-        memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));\n+        if (sax->initialized == XML_SAX2_MAGIC) {\n+            memcpy(ctxt->sax, sax, sizeof(xmlSAXHandler));\n@@ -2320,2 +2837,2 @@\n-        memset(ctxt->sax, 0, sizeof(xmlSAXHandler));\n-        memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));\n+            memset(ctxt->sax, 0, sizeof(xmlSAXHandler));\n+            memcpy(ctxt->sax, sax, sizeof(xmlSAXHandlerV1));\n@@ -2330,3 +2847,8 @@\n-    ctxt->inputTab = (xmlParserInputPtr *)\n-            xmlMalloc(5 * sizeof(xmlParserInputPtr));\n-    ctxt->inputMax = 5;\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+        size_t initialSize = 1;\n+#else\n+        size_t initialSize = 5;\n+#endif\n+\n+        ctxt->inputTab = xmlMalloc(initialSize * sizeof(xmlParserInputPtr));\n+        ctxt->inputMax = initialSize;\n@@ -2335,2 +2857,2 @@\n-    return(-1);\n-    while ((input = inputPop(ctxt)) != NULL) { \/* Non consuming *\/\n+        return(-1);\n+    while ((input = xmlCtxtPopInput(ctxt)) != NULL) { \/* Non consuming *\/\n@@ -2352,2 +2874,2 @@\n-    ctxt->nodeTab = (xmlNodePtr *) xmlMalloc(10 * sizeof(xmlNodePtr));\n-    ctxt->nodeMax = 10;\n+        ctxt->nodeTab = xmlMalloc(initialNodeTabSize * sizeof(xmlNodePtr));\n+        ctxt->nodeMax = initialNodeTabSize;\n@@ -2356,1 +2878,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2362,2 +2884,2 @@\n-    ctxt->nameTab = (const xmlChar **) xmlMalloc(10 * sizeof(xmlChar *));\n-    ctxt->nameMax = 10;\n+        ctxt->nameTab = xmlMalloc(initialNodeTabSize * sizeof(xmlChar *));\n+        ctxt->nameMax = initialNodeTabSize;\n@@ -2366,1 +2888,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2372,2 +2894,2 @@\n-    ctxt->spaceTab = (int *) xmlMalloc(10 * sizeof(int));\n-    ctxt->spaceMax = 10;\n+        ctxt->spaceTab = xmlMalloc(initialNodeTabSize * sizeof(int));\n+        ctxt->spaceMax = initialNodeTabSize;\n@@ -2376,1 +2898,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2378,1 +2900,0 @@\n-    ctxt->spaceMax = 10;\n@@ -2409,2 +2930,2 @@\n-    ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;\n-    ctxt->options |= XML_PARSE_NOBLANKS;\n+        ctxt->sax->ignorableWhitespace = xmlSAX2IgnorableWhitespace;\n+        ctxt->options |= XML_PARSE_NOBLANKS;\n@@ -2438,2 +2959,1 @@\n-        if (ctxt->nsdb == NULL) {\n-            xmlCtxtErrMemory(ctxt);\n+        if (ctxt->nsdb == NULL)\n@@ -2441,1 +2961,0 @@\n-        }\n@@ -2480,1 +2999,1 @@\n-    while ((input = inputPop(ctxt)) != NULL) { \/* Non consuming *\/\n+    while ((input = xmlCtxtPopInput(ctxt)) != NULL) { \/* Non consuming *\/\n@@ -2515,6 +3034,6 @@\n-    cur = ctxt->freeElems;\n-    while (cur != NULL) {\n-        next = cur->next;\n-        xmlFree(cur);\n-        cur = next;\n-    }\n+        cur = ctxt->freeElems;\n+        while (cur != NULL) {\n+            next = cur->next;\n+            xmlFree(cur);\n+            cur = next;\n+        }\n@@ -2525,6 +3044,6 @@\n-    cur = ctxt->freeAttrs;\n-    while (cur != NULL) {\n-        next = cur->next;\n-        xmlFree(cur);\n-        cur = next;\n-    }\n+        cur = ctxt->freeAttrs;\n+        while (cur != NULL) {\n+            next = cur->next;\n+            xmlFree(cur);\n+            cur = next;\n+        }\n@@ -2548,1 +3067,1 @@\n-    xmlCatalogFreeLocal(ctxt->catalogs);\n+        xmlCatalogFreeLocal(ctxt->catalogs);\n@@ -2591,1 +3110,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2595,1 +3114,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2600,0 +3119,232 @@\n+\/**\n+ * xmlCtxtGetPrivate:\n+ * @ctxt:  parser context\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns the private application data.\n+ *\/\n+void *\n+xmlCtxtGetPrivate(xmlParserCtxtPtr ctxt) {\n+    if (ctxt == NULL)\n+        return(NULL);\n+\n+    return(ctxt->_private);\n+}\n+\n+\/**\n+ * xmlCtxtSetPrivate:\n+ * @ctxt:  parser context\n+ * @priv:  private application data\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Set the private application data.\n+ *\/\n+void\n+xmlCtxtSetPrivate(xmlParserCtxtPtr ctxt, void *priv) {\n+    if (ctxt == NULL)\n+        return;\n+\n+    ctxt->_private = priv;\n+}\n+\n+\/**\n+ * xmlCtxtGetCatalogs:\n+ * @ctxt:  parser context\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns the local catalogs.\n+ *\/\n+void *\n+xmlCtxtGetCatalogs(xmlParserCtxtPtr ctxt) {\n+    if (ctxt == NULL)\n+        return(NULL);\n+\n+    return(ctxt->catalogs);\n+}\n+\n+\/**\n+ * xmlCtxtSetCatalogs:\n+ * @ctxt:  parser context\n+ * @catalogs:  catalogs pointer\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Set the local catalogs.\n+ *\/\n+void\n+xmlCtxtSetCatalogs(xmlParserCtxtPtr ctxt, void *catalogs) {\n+    if (ctxt == NULL)\n+        return;\n+\n+    ctxt->catalogs = catalogs;\n+}\n+\n+\/**\n+ * xmlCtxtGetDict:\n+ * @ctxt:  parser context\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns the dictionary.\n+ *\/\n+xmlDictPtr\n+xmlCtxtGetDict(xmlParserCtxtPtr ctxt) {\n+    if (ctxt == NULL)\n+        return(NULL);\n+\n+    return(ctxt->dict);\n+}\n+\n+\/**\n+ * xmlCtxtSetDict:\n+ * @ctxt:  parser context\n+ * @dict:  dictionary\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Set the dictionary. This should only be done immediately after\n+ * creating a parser context.\n+ *\/\n+void\n+xmlCtxtSetDict(xmlParserCtxtPtr ctxt, xmlDictPtr dict) {\n+    if (ctxt == NULL)\n+        return;\n+\n+    if (ctxt->dict != NULL)\n+        xmlDictFree(ctxt->dict);\n+\n+    xmlDictReference(dict);\n+    ctxt->dict = dict;\n+}\n+\n+\/**\n+ * xmlCtxtGetSaxHandler:\n+ * @ctxt:  parser context\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns the SAX handler struct. This is not a copy and must not\n+ * be freed. Handlers can be updated.\n+ *\/\n+xmlSAXHandler *\n+xmlCtxtGetSaxHandler(xmlParserCtxtPtr ctxt) {\n+    if (ctxt == NULL)\n+        return(NULL);\n+\n+    return(ctxt->sax);\n+}\n+\n+\/**\n+ * xmlCtxtSetSaxHandler:\n+ * @ctxt:  parser context\n+ * @sax:  SAX handler\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Set the SAX handler struct to a copy of @sax.\n+ *\n+ * Returns 0 on success or -1 if arguments are invalid or a memory\n+ * allocation failed.\n+ *\/\n+int\n+xmlCtxtSetSaxHandler(xmlParserCtxtPtr ctxt, const xmlSAXHandler *sax) {\n+    xmlSAXHandler *copy;\n+\n+    if ((ctxt == NULL) || (sax == NULL))\n+        return(-1);\n+\n+    copy = xmlMalloc(sizeof(*copy));\n+    if (copy == NULL)\n+        return(-1);\n+\n+    memcpy(copy, sax, sizeof(*copy));\n+    ctxt->sax = copy;\n+\n+    return(0);\n+}\n+\n+\/**\n+ * xmlCtxtGetDocument:\n+ * @ctxt:  parser context\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns the parsed document or NULL if a fatal error occurred when\n+ * parsing. The document must be freed by the caller. Resets the\n+ * context's document to NULL.\n+ *\/\n+xmlDocPtr\n+xmlCtxtGetDocument(xmlParserCtxtPtr ctxt) {\n+    xmlDocPtr doc;\n+\n+    if (ctxt == NULL)\n+        return(NULL);\n+\n+    if ((ctxt->wellFormed) ||\n+        (((ctxt->recovery) || (ctxt->html)) &&\n+         (!xmlCtxtIsCatastrophicError(ctxt)))) {\n+        doc = ctxt->myDoc;\n+    } else {\n+        if (ctxt->errNo == XML_ERR_OK)\n+            xmlFatalErr(ctxt, XML_ERR_INTERNAL_ERROR, \"unknown error\");\n+        doc = NULL;\n+        xmlFreeDoc(ctxt->myDoc);\n+    }\n+    ctxt->myDoc = NULL;\n+\n+    return(doc);\n+}\n+\n+\/**\n+ * xmlCtxtIsHtml:\n+ * @ctxt:  parser context\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns 1 if this is a HTML parser context, 0 otherwise.\n+ *\/\n+int\n+xmlCtxtIsHtml(xmlParserCtxtPtr ctxt) {\n+    if (ctxt == NULL)\n+        return(0);\n+\n+    return(ctxt->html ? 1 : 0);\n+}\n+\n+\/**\n+ * xmlCtxtIsStopped:\n+ * @ctxt:  parser context\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns 1 if the parser is stopped, 0 otherwise.\n+ *\/\n+int\n+xmlCtxtIsStopped(xmlParserCtxtPtr ctxt) {\n+    if (ctxt == NULL)\n+        return(0);\n+\n+    return(ctxt->disableSAX != 0);\n+}\n+\n+#ifdef LIBXML_VALID_ENABLED\n+\/**\n+ * xmlCtxtGetValidCtxt:\n+ * @ctxt:  parser context\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns the validation context.\n+ *\/\n+xmlValidCtxtPtr\n+xmlCtxtGetValidCtxt(xmlParserCtxtPtr ctxt) {\n+    if (ctxt == NULL)\n+        return(NULL);\n+\n+    return(&ctxt->vctxt);\n+}\n+#endif\n+\n@@ -2601,3 +3352,3 @@\n- *                                    *\n- *        Handling of node information                *\n- *                                    *\n+ *                                                                      *\n+ *              Handling of node information                            *\n+ *                                                                      *\n@@ -2761,19 +3512,13 @@\n-        if ((ctxt->node_seq.length + 1 > ctxt->node_seq.maximum) ||\n-        (ctxt->node_seq.buffer == NULL)) {\n-            xmlParserNodeInfo *tmp_buffer;\n-            unsigned int byte_size;\n-\n-            if (ctxt->node_seq.maximum == 0)\n-                ctxt->node_seq.maximum = 2;\n-            byte_size = (sizeof(*ctxt->node_seq.buffer) *\n-            (2 * ctxt->node_seq.maximum));\n-\n-            if (ctxt->node_seq.buffer == NULL)\n-                tmp_buffer = (xmlParserNodeInfo *) xmlMalloc(byte_size);\n-            else\n-                tmp_buffer =\n-                    (xmlParserNodeInfo *) xmlRealloc(ctxt->node_seq.buffer,\n-                                                     byte_size);\n-\n-            if (tmp_buffer == NULL) {\n-        xmlCtxtErrMemory(ctxt);\n+        if (ctxt->node_seq.length + 1 > ctxt->node_seq.maximum) {\n+            xmlParserNodeInfo *tmp;\n+            int newSize;\n+\n+            newSize = xmlGrowCapacity(ctxt->node_seq.maximum, sizeof(tmp[0]),\n+                                      4, XML_MAX_ITEMS);\n+            if (newSize < 0) {\n+                xmlCtxtErrMemory(ctxt);\n+                return;\n+            }\n+            tmp = xmlRealloc(ctxt->node_seq.buffer, newSize * sizeof(tmp[0]));\n+            if (tmp == NULL) {\n+                xmlCtxtErrMemory(ctxt);\n@@ -2782,2 +3527,2 @@\n-            ctxt->node_seq.buffer = tmp_buffer;\n-            ctxt->node_seq.maximum *= 2;\n+            ctxt->node_seq.buffer = tmp;\n+            ctxt->node_seq.maximum = newSize;\n@@ -2801,3 +3546,3 @@\n- *                                    *\n- *        Defaults settings                    *\n- *                                    *\n+ *                                                                      *\n+ *              Defaults settings                                       *\n+ *                                                                      *\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/parserInternals.c","additions":1275,"deletions":530,"binary":false,"changes":1805,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+#include \"private\/memory.h\"\n+\n@@ -46,1 +48,1 @@\n-#define XML_STREAM_STEP_FINAL    2\n+#define XML_STREAM_STEP_FINAL   2\n@@ -50,1 +52,1 @@\n-#define XML_STREAM_STEP_IN_SET    32\n+#define XML_STREAM_STEP_IN_SET  32\n@@ -69,2 +71,2 @@\n-                 XML_PATTERN_XSSEL | \\\n-                 XML_PATTERN_XSFIELD)\n+                                 XML_PATTERN_XSSEL | \\\n+                                 XML_PATTERN_XSFIELD)\n@@ -81,1 +83,1 @@\n-    r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \\\n+        r = (xmlChar *) xmlDictLookup((c)->comp->dict, BAD_CAST nsname, -1); \\\n@@ -89,4 +91,4 @@\n-    int flags;            \/* properties of that step *\/\n-    const xmlChar *name;    \/* first string value if NULL accept all *\/\n-    const xmlChar *ns;        \/* second string value *\/\n-    int nodeType;        \/* type of node *\/\n+    int flags;                  \/* properties of that step *\/\n+    const xmlChar *name;        \/* first string value if NULL accept all *\/\n+    const xmlChar *ns;          \/* second string value *\/\n+    int nodeType;               \/* type of node *\/\n@@ -98,4 +100,4 @@\n-    xmlDict *dict;        \/* the dictionary if any *\/\n-    int nbStep;            \/* number of steps in the automata *\/\n-    int maxStep;        \/* allocated number of steps *\/\n-    xmlStreamStepPtr steps;    \/* the array of steps *\/\n+    xmlDict *dict;              \/* the dictionary if any *\/\n+    int nbStep;                 \/* number of steps in the automata *\/\n+    int maxStep;                \/* allocated number of steps *\/\n+    xmlStreamStepPtr steps;     \/* the array of steps *\/\n@@ -107,6 +109,6 @@\n-    xmlStreamCompPtr comp;    \/* the compiled stream *\/\n-    int nbState;        \/* number of states in the automata *\/\n-    int maxState;        \/* allocated number of states *\/\n-    int level;            \/* how deep are we ? *\/\n-    int *states;        \/* the array of step indexes *\/\n-    int flags;            \/* validation options *\/\n+    xmlStreamCompPtr comp;      \/* the compiled stream *\/\n+    int nbState;                \/* number of states in the automata *\/\n+    int maxState;               \/* allocated number of states *\/\n+    int level;                  \/* how deep are we ? *\/\n+    int *states;                \/* the array of step indexes *\/\n+    int flags;                  \/* validation options *\/\n@@ -158,1 +160,1 @@\n-#define PAT_FROM_ROOT    (1<<8)\n+#define PAT_FROM_ROOT   (1<<8)\n@@ -162,5 +164,5 @@\n-    void *data;        \/* the associated template *\/\n-    xmlDictPtr dict;        \/* the optional dictionary *\/\n-    struct _xmlPattern *next;    \/* next pattern if | is used *\/\n-    const xmlChar *pattern;    \/* the pattern *\/\n-    int flags;            \/* flags *\/\n+    void *data;         \/* the associated template *\/\n+    xmlDictPtr dict;            \/* the optional dictionary *\/\n+    struct _xmlPattern *next;   \/* next pattern if | is used *\/\n+    const xmlChar *pattern;     \/* the pattern *\/\n+    int flags;                  \/* flags *\/\n@@ -176,8 +178,8 @@\n-    const xmlChar *cur;            \/* the current char being parsed *\/\n-    const xmlChar *base;        \/* the full expression *\/\n-    int               error;        \/* error code *\/\n-    xmlDictPtr     dict;        \/* the dictionary if any *\/\n-    xmlPatternPtr  comp;        \/* the result *\/\n-    xmlNodePtr     elem;        \/* the current node if any *\/\n-    const xmlChar **namespaces;        \/* the namespaces definitions *\/\n-    int   nb_namespaces;        \/* the number of namespaces *\/\n+    const xmlChar *cur;                 \/* the current char being parsed *\/\n+    const xmlChar *base;                \/* the full expression *\/\n+    int            error;               \/* error code *\/\n+    xmlDictPtr     dict;                \/* the dictionary if any *\/\n+    xmlPatternPtr  comp;                \/* the result *\/\n+    xmlNodePtr     elem;                \/* the current node if any *\/\n+    const xmlChar **namespaces;         \/* the namespaces definitions *\/\n+    int   nb_namespaces;                \/* the number of namespaces *\/\n@@ -187,3 +189,3 @@\n- *                                    *\n- *            Type functions                    *\n- *                                    *\n+ *                                                                      *\n+ *                      Type functions                                  *\n+ *                                                                      *\n@@ -205,3 +207,3 @@\n-    ERROR(NULL, NULL, NULL,\n-        \"xmlNewPattern : malloc failed\\n\");\n-    return(NULL);\n+        ERROR(NULL, NULL, NULL,\n+                \"xmlNewPattern : malloc failed\\n\");\n+        return(NULL);\n@@ -210,8 +212,2 @@\n-    cur->maxStep = 10;\n-    cur->steps = (xmlStepOpPtr) xmlMalloc(cur->maxStep * sizeof(xmlStepOp));\n-    if (cur->steps == NULL) {\n-        xmlFree(cur);\n-    ERROR(NULL, NULL, NULL,\n-        \"xmlNewPattern : malloc failed\\n\");\n-    return(NULL);\n-    }\n+    cur->steps = NULL;\n+    cur->maxStep = 0;\n@@ -238,1 +234,1 @@\n-    return;\n+        return;\n@@ -242,1 +238,1 @@\n-    xmlFree((xmlChar *)comp->pattern);\n+        xmlFree((xmlChar *)comp->pattern);\n@@ -245,6 +241,7 @@\n-        for (i = 0;i < comp->nbStep;i++) {\n-        op = &comp->steps[i];\n-        if (op->value != NULL)\n-            xmlFree((xmlChar *) op->value);\n-        if (op->value2 != NULL)\n-            xmlFree((xmlChar *) op->value2);\n+            for (i = 0;i < comp->nbStep;i++) {\n+                op = &comp->steps[i];\n+                if (op->value != NULL)\n+                    xmlFree((xmlChar *) op->value);\n+                if (op->value2 != NULL)\n+                    xmlFree((xmlChar *) op->value2);\n+            }\n@@ -252,2 +249,1 @@\n-    }\n-    xmlFree(comp->steps);\n+        xmlFree(comp->steps);\n@@ -273,4 +269,4 @@\n-    cur = comp;\n-    comp = comp->next;\n-    cur->next = NULL;\n-    xmlFreePatternInternal(cur);\n+        cur = comp;\n+        comp = comp->next;\n+        cur->next = NULL;\n+        xmlFreePatternInternal(cur);\n@@ -301,3 +297,3 @@\n-    ERROR(NULL, NULL, NULL,\n-        \"xmlNewPatParserContext : malloc failed\\n\");\n-    return(NULL);\n+        ERROR(NULL, NULL, NULL,\n+                \"xmlNewPatParserContext : malloc failed\\n\");\n+        return(NULL);\n@@ -330,1 +326,1 @@\n-    return;\n+        return;\n@@ -335,0 +331,18 @@\n+static int\n+xmlPatternGrow(xmlPatternPtr comp) {\n+    xmlStepOpPtr temp;\n+    int newSize;\n+\n+    newSize = xmlGrowCapacity(comp->maxStep, sizeof(temp[0]),\n+                              10, XML_MAX_ITEMS);\n+    if (newSize < 0)\n+        return(-1);\n+    temp = xmlRealloc(comp->steps, newSize * sizeof(temp[0]));\n+    if (temp == NULL)\n+        return(-1);\n+    comp->steps = temp;\n+    comp->maxStep = newSize;\n+\n+    return(0);\n+}\n+\n@@ -351,6 +365,1 @@\n-        xmlStepOpPtr temp;\n-    temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *\n-                                     sizeof(xmlStepOp));\n-        if (temp == NULL) {\n-        ERROR(ctxt, NULL, NULL,\n-                 \"xmlPatternAdd: realloc failed\\n\");\n+        if (xmlPatternGrow(comp) < 0) {\n@@ -358,4 +367,2 @@\n-        return (-1);\n-    }\n-    comp->steps = temp;\n-    comp->maxStep *= 2;\n+            return(-1);\n+        }\n@@ -367,29 +374,1 @@\n-    return (0);\n-}\n-\n-#if 0\n-\/**\n- * xsltSwapTopPattern:\n- * @comp:  the compiled match expression\n- *\n- * reverse the two top steps.\n- *\/\n-static void\n-xsltSwapTopPattern(xmlPatternPtr comp) {\n-    int i;\n-    int j = comp->nbStep - 1;\n-\n-    if (j > 0) {\n-    register const xmlChar *tmp;\n-    register xmlPatOp op;\n-    i = j - 1;\n-    tmp = comp->steps[i].value;\n-    comp->steps[i].value = comp->steps[j].value;\n-    comp->steps[j].value = tmp;\n-    tmp = comp->steps[i].value2;\n-    comp->steps[i].value2 = comp->steps[j].value2;\n-    comp->steps[j].value2 = tmp;\n-    op = comp->steps[i].op;\n-    comp->steps[i].op = comp->steps[j].op;\n-    comp->steps[j].op = op;\n-    }\n+    return(0);\n@@ -397,1 +376,0 @@\n-#endif\n@@ -416,5 +394,5 @@\n-        comp->steps[i].value = comp->steps[j].value;\n-        comp->steps[i].value2 = comp->steps[j].value2;\n-        comp->steps[i].op = comp->steps[j].op;\n-    }\n-    comp->nbStep--;\n+            comp->steps[i].value = comp->steps[j].value;\n+            comp->steps[i].value2 = comp->steps[j].value2;\n+            comp->steps[i].op = comp->steps[j].op;\n+        }\n+        comp->nbStep--;\n@@ -422,0 +400,4 @@\n+\n+    \/*\n+     * Grow to add OP_END later\n+     *\/\n@@ -423,10 +405,2 @@\n-        xmlStepOpPtr temp;\n-    temp = (xmlStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *\n-                                     sizeof(xmlStepOp));\n-        if (temp == NULL) {\n-        ERROR(ctxt, NULL, NULL,\n-                 \"xmlReversePattern: realloc failed\\n\");\n-        return (-1);\n-    }\n-    comp->steps = temp;\n-    comp->maxStep *= 2;\n+        if (xmlPatternGrow(comp) < 0)\n+            return(-1);\n@@ -434,0 +408,1 @@\n+\n@@ -437,13 +412,13 @@\n-    register const xmlChar *tmp;\n-    register xmlPatOp op;\n-    tmp = comp->steps[i].value;\n-    comp->steps[i].value = comp->steps[j].value;\n-    comp->steps[j].value = tmp;\n-    tmp = comp->steps[i].value2;\n-    comp->steps[i].value2 = comp->steps[j].value2;\n-    comp->steps[j].value2 = tmp;\n-    op = comp->steps[i].op;\n-    comp->steps[i].op = comp->steps[j].op;\n-    comp->steps[j].op = op;\n-    j--;\n-    i++;\n+        register const xmlChar *tmp;\n+        register xmlPatOp op;\n+        tmp = comp->steps[i].value;\n+        comp->steps[i].value = comp->steps[j].value;\n+        comp->steps[j].value = tmp;\n+        tmp = comp->steps[i].value2;\n+        comp->steps[i].value2 = comp->steps[j].value2;\n+        comp->steps[j].value2 = tmp;\n+        op = comp->steps[i].op;\n+        comp->steps[i].op = comp->steps[j].op;\n+        comp->steps[j].op = op;\n+        j--;\n+        i++;\n@@ -451,0 +426,1 @@\n+\n@@ -458,3 +434,3 @@\n- *                                    *\n- *        The interpreter for the precompiled patterns        *\n- *                                    *\n+ *                                                                      *\n+ *              The interpreter for the precompiled patterns            *\n+ *                                                                      *\n@@ -465,6 +441,1 @@\n-    if ((states->states == NULL) || (states->maxstates <= 0)) {\n-        states->maxstates = 4;\n-    states->nbstates = 0;\n-    states->states = xmlMalloc(4 * sizeof(xmlStepState));\n-    }\n-    else if (states->maxstates <= states->nbstates) {\n+    if (states->maxstates <= states->nbstates) {\n@@ -472,0 +443,1 @@\n+        int newSize;\n@@ -473,6 +445,9 @@\n-    tmp = (xmlStepStatePtr) xmlRealloc(states->states,\n-                   2 * states->maxstates * sizeof(xmlStepState));\n-    if (tmp == NULL)\n-        return(-1);\n-    states->states = tmp;\n-    states->maxstates *= 2;\n+        newSize = xmlGrowCapacity(states->maxstates, sizeof(tmp[0]),\n+                                  4, XML_MAX_ITEMS);\n+        if (newSize < 0)\n+            return(-1);\n+        tmp = xmlRealloc(states->states, newSize * sizeof(tmp[0]));\n+        if (tmp == NULL)\n+            return(-1);\n+        states->states = tmp;\n+        states->maxstates = newSize;\n@@ -482,3 +457,0 @@\n-#if 0\n-    fprintf(stderr, \"Push: %d, %s\\n\", step, node->name);\n-#endif\n@@ -507,2 +479,2 @@\n-    step = &comp->steps[i];\n-    switch (step->op) {\n+        step = &comp->steps[i];\n+        switch (step->op) {\n@@ -510,1 +482,1 @@\n-        goto found;\n+                goto found;\n@@ -512,7 +484,7 @@\n-        if (node->type == XML_NAMESPACE_DECL)\n-            goto rollback;\n-        node = node->parent;\n-        if ((node->type == XML_DOCUMENT_NODE) ||\n-            (node->type == XML_HTML_DOCUMENT_NODE))\n-            continue;\n-        goto rollback;\n+                if (node->type == XML_NAMESPACE_DECL)\n+                    goto rollback;\n+                node = node->parent;\n+                if ((node->type == XML_DOCUMENT_NODE) ||\n+                    (node->type == XML_HTML_DOCUMENT_NODE))\n+                    continue;\n+                goto rollback;\n@@ -520,20 +492,20 @@\n-        if (node->type != XML_ELEMENT_NODE)\n-            goto rollback;\n-        if (step->value == NULL)\n-            continue;\n-        if (step->value[0] != node->name[0])\n-            goto rollback;\n-        if (!xmlStrEqual(step->value, node->name))\n-            goto rollback;\n-\n-        \/* Namespace test *\/\n-        if (node->ns == NULL) {\n-            if (step->value2 != NULL)\n-            goto rollback;\n-        } else if (node->ns->href != NULL) {\n-            if (step->value2 == NULL)\n-            goto rollback;\n-            if (!xmlStrEqual(step->value2, node->ns->href))\n-            goto rollback;\n-        }\n-        continue;\n+                if (node->type != XML_ELEMENT_NODE)\n+                    goto rollback;\n+                if (step->value == NULL)\n+                    continue;\n+                if (step->value[0] != node->name[0])\n+                    goto rollback;\n+                if (!xmlStrEqual(step->value, node->name))\n+                    goto rollback;\n+\n+                \/* Namespace test *\/\n+                if (node->ns == NULL) {\n+                    if (step->value2 != NULL)\n+                        goto rollback;\n+                } else if (node->ns->href != NULL) {\n+                    if (step->value2 == NULL)\n+                        goto rollback;\n+                    if (!xmlStrEqual(step->value2, node->ns->href))\n+                        goto rollback;\n+                }\n+                continue;\n@@ -541,16 +513,21 @@\n-        xmlNodePtr lst;\n-\n-        if ((node->type != XML_ELEMENT_NODE) &&\n-            (node->type != XML_DOCUMENT_NODE) &&\n-            (node->type != XML_HTML_DOCUMENT_NODE))\n-            goto rollback;\n-\n-        lst = node->children;\n-\n-        if (step->value != NULL) {\n-            while (lst != NULL) {\n-            if ((lst->type == XML_ELEMENT_NODE) &&\n-                (step->value[0] == lst->name[0]) &&\n-                (xmlStrEqual(step->value, lst->name)))\n-                break;\n-            lst = lst->next;\n+                xmlNodePtr lst;\n+\n+                if ((node->type != XML_ELEMENT_NODE) &&\n+                    (node->type != XML_DOCUMENT_NODE) &&\n+                    (node->type != XML_HTML_DOCUMENT_NODE))\n+                    goto rollback;\n+\n+                lst = node->children;\n+\n+                if (step->value != NULL) {\n+                    while (lst != NULL) {\n+                        if ((lst->type == XML_ELEMENT_NODE) &&\n+                            (step->value[0] == lst->name[0]) &&\n+                            (xmlStrEqual(step->value, lst->name)))\n+                            break;\n+                        lst = lst->next;\n+                    }\n+                    if (lst != NULL)\n+                        continue;\n+                }\n+                goto rollback;\n@@ -558,5 +535,0 @@\n-            if (lst != NULL)\n-            continue;\n-        }\n-        goto rollback;\n-        }\n@@ -564,17 +536,17 @@\n-        if (node->type != XML_ATTRIBUTE_NODE)\n-            goto rollback;\n-        if (step->value != NULL) {\n-            if (step->value[0] != node->name[0])\n-            goto rollback;\n-            if (!xmlStrEqual(step->value, node->name))\n-            goto rollback;\n-        }\n-        \/* Namespace test *\/\n-        if (node->ns == NULL) {\n-            if (step->value2 != NULL)\n-            goto rollback;\n-        } else if (step->value2 != NULL) {\n-            if (!xmlStrEqual(step->value2, node->ns->href))\n-            goto rollback;\n-        }\n-        continue;\n+                if (node->type != XML_ATTRIBUTE_NODE)\n+                    goto rollback;\n+                if (step->value != NULL) {\n+                    if (step->value[0] != node->name[0])\n+                        goto rollback;\n+                    if (!xmlStrEqual(step->value, node->name))\n+                        goto rollback;\n+                }\n+                \/* Namespace test *\/\n+                if (node->ns == NULL) {\n+                    if (step->value2 != NULL)\n+                        goto rollback;\n+                } else if (step->value2 != NULL) {\n+                    if (!xmlStrEqual(step->value2, node->ns->href))\n+                        goto rollback;\n+                }\n+                continue;\n@@ -582,24 +554,24 @@\n-        if ((node->type == XML_DOCUMENT_NODE) ||\n-            (node->type == XML_HTML_DOCUMENT_NODE) ||\n-            (node->type == XML_NAMESPACE_DECL))\n-            goto rollback;\n-        node = node->parent;\n-        if (node == NULL)\n-            goto rollback;\n-        if (step->value == NULL)\n-            continue;\n-        if (step->value[0] != node->name[0])\n-            goto rollback;\n-        if (!xmlStrEqual(step->value, node->name))\n-            goto rollback;\n-        \/* Namespace test *\/\n-        if (node->ns == NULL) {\n-            if (step->value2 != NULL)\n-            goto rollback;\n-        } else if (node->ns->href != NULL) {\n-            if (step->value2 == NULL)\n-            goto rollback;\n-            if (!xmlStrEqual(step->value2, node->ns->href))\n-            goto rollback;\n-        }\n-        continue;\n+                if ((node->type == XML_DOCUMENT_NODE) ||\n+                    (node->type == XML_HTML_DOCUMENT_NODE) ||\n+                    (node->type == XML_NAMESPACE_DECL))\n+                    goto rollback;\n+                node = node->parent;\n+                if (node == NULL)\n+                    goto rollback;\n+                if (step->value == NULL)\n+                    continue;\n+                if (step->value[0] != node->name[0])\n+                    goto rollback;\n+                if (!xmlStrEqual(step->value, node->name))\n+                    goto rollback;\n+                \/* Namespace test *\/\n+                if (node->ns == NULL) {\n+                    if (step->value2 != NULL)\n+                        goto rollback;\n+                } else if (node->ns->href != NULL) {\n+                    if (step->value2 == NULL)\n+                        goto rollback;\n+                    if (!xmlStrEqual(step->value2, node->ns->href))\n+                        goto rollback;\n+                }\n+                continue;\n@@ -607,25 +579,57 @@\n-        \/* TODO: implement coalescing of ANCESTOR\/NODE ops *\/\n-        if (step->value == NULL) {\n-            i++;\n-            step = &comp->steps[i];\n-            if (step->op == XML_OP_ROOT)\n-            goto found;\n-            if (step->op != XML_OP_ELEM)\n-            goto rollback;\n-            if (step->value == NULL)\n-            return(-1);\n-        }\n-        if (node == NULL)\n-            goto rollback;\n-        if ((node->type == XML_DOCUMENT_NODE) ||\n-            (node->type == XML_HTML_DOCUMENT_NODE) ||\n-            (node->type == XML_NAMESPACE_DECL))\n-            goto rollback;\n-        node = node->parent;\n-        while (node != NULL) {\n-            if ((node->type == XML_ELEMENT_NODE) &&\n-            (step->value[0] == node->name[0]) &&\n-            (xmlStrEqual(step->value, node->name))) {\n-            \/* Namespace test *\/\n-            if (node->ns == NULL) {\n-                if (step->value2 == NULL)\n+                \/* TODO: implement coalescing of ANCESTOR\/NODE ops *\/\n+                if (step->value == NULL) {\n+                    i++;\n+                    step = &comp->steps[i];\n+                    if (step->op == XML_OP_ROOT)\n+                        goto found;\n+                    if (step->op != XML_OP_ELEM)\n+                        goto rollback;\n+                    if (step->value == NULL)\n+                        return(-1);\n+                }\n+                if (node == NULL)\n+                    goto rollback;\n+                if ((node->type == XML_DOCUMENT_NODE) ||\n+                    (node->type == XML_HTML_DOCUMENT_NODE) ||\n+                    (node->type == XML_NAMESPACE_DECL))\n+                    goto rollback;\n+                node = node->parent;\n+                while (node != NULL) {\n+                    if ((node->type == XML_ELEMENT_NODE) &&\n+                        (step->value[0] == node->name[0]) &&\n+                        (xmlStrEqual(step->value, node->name))) {\n+                        \/* Namespace test *\/\n+                        if (node->ns == NULL) {\n+                            if (step->value2 == NULL)\n+                                break;\n+                        } else if (node->ns->href != NULL) {\n+                            if ((step->value2 != NULL) &&\n+                                (xmlStrEqual(step->value2, node->ns->href)))\n+                                break;\n+                        }\n+                    }\n+                    node = node->parent;\n+                }\n+                if (node == NULL)\n+                    goto rollback;\n+                \/*\n+                 * prepare a potential rollback from here\n+                 * for ancestors of that node.\n+                 *\/\n+                if (step->op == XML_OP_ANCESTOR)\n+                    xmlPatPushState(&states, i, node);\n+                else\n+                    xmlPatPushState(&states, i - 1, node);\n+                continue;\n+            case XML_OP_NS:\n+                if (node->type != XML_ELEMENT_NODE)\n+                    goto rollback;\n+                if (node->ns == NULL) {\n+                    if (step->value != NULL)\n+                        goto rollback;\n+                } else if (node->ns->href != NULL) {\n+                    if (step->value == NULL)\n+                        goto rollback;\n+                    if (!xmlStrEqual(step->value, node->ns->href))\n+                        goto rollback;\n+                }\n@@ -633,3 +637,3 @@\n-            } else if (node->ns->href != NULL) {\n-                if ((step->value2 != NULL) &&\n-                    (xmlStrEqual(step->value2, node->ns->href)))\n+            case XML_OP_ALL:\n+                if (node->type != XML_ELEMENT_NODE)\n+                    goto rollback;\n@@ -637,26 +641,0 @@\n-            }\n-            }\n-            node = node->parent;\n-        }\n-        if (node == NULL)\n-            goto rollback;\n-        \/*\n-         * prepare a potential rollback from here\n-         * for ancestors of that node.\n-         *\/\n-        if (step->op == XML_OP_ANCESTOR)\n-            xmlPatPushState(&states, i, node);\n-        else\n-            xmlPatPushState(&states, i - 1, node);\n-        continue;\n-            case XML_OP_NS:\n-        if (node->type != XML_ELEMENT_NODE)\n-            goto rollback;\n-        if (node->ns == NULL) {\n-            if (step->value != NULL)\n-            goto rollback;\n-        } else if (node->ns->href != NULL) {\n-            if (step->value == NULL)\n-            goto rollback;\n-            if (!xmlStrEqual(step->value, node->ns->href))\n-            goto rollback;\n@@ -664,6 +642,0 @@\n-        break;\n-            case XML_OP_ALL:\n-        if (node->type != XML_ELEMENT_NODE)\n-            goto rollback;\n-        break;\n-    }\n@@ -674,1 +646,1 @@\n-    xmlFree(states.states);\n+        xmlFree(states.states);\n@@ -680,1 +652,1 @@\n-    return(0);\n+        return(0);\n@@ -682,2 +654,2 @@\n-    xmlFree(states.states);\n-    return(0);\n+        xmlFree(states.states);\n+        return(0);\n@@ -688,3 +660,0 @@\n-#if 0\n-    fprintf(stderr, \"Pop: %d, %s\\n\", i, node->name);\n-#endif\n@@ -695,3 +664,3 @@\n- *                                    *\n- *            Dedicated parser for templates            *\n- *                                    *\n+ *                                                                      *\n+ *                      Dedicated parser for templates                  *\n+ *                                                                      *\n@@ -706,1 +675,1 @@\n-#define SKIP_BLANKS                            \\\n+#define SKIP_BLANKS                                                     \\\n@@ -713,1 +682,1 @@\n-#define PUSH(op, val, val2)                        \\\n+#define PUSH(op, val, val2)                                             \\\n@@ -716,67 +685,0 @@\n-#if 0\n-\/**\n- * xmlPatScanLiteral:\n- * @ctxt:  the XPath Parser context\n- *\n- * Parse an XPath Literal:\n- *\n- * [29] Literal ::= '\"' [^\"]* '\"'\n- *                | \"'\" [^']* \"'\"\n- *\n- * Returns the Literal parsed or NULL\n- *\/\n-\n-static xmlChar *\n-xmlPatScanLiteral(xmlPatParserContextPtr ctxt) {\n-    const xmlChar *q, *cur;\n-    xmlChar *ret = NULL;\n-    int val, len;\n-\n-    SKIP_BLANKS;\n-    if (CUR == '\"') {\n-        NEXT;\n-    cur = q = CUR_PTR;\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    while ((IS_CHAR(val)) && (val != '\"')) {\n-        cur += len;\n-        val = xmlStringCurrentChar(NULL, cur, &len);\n-    }\n-    if (!IS_CHAR(val)) {\n-        ctxt->error = 1;\n-        return(NULL);\n-    } else {\n-        if (ctxt->dict)\n-        ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\n-        else\n-        ret = xmlStrndup(q, cur - q);\n-        }\n-    cur += len;\n-    CUR_PTR = cur;\n-    } else if (CUR == '\\'') {\n-        NEXT;\n-    cur = q = CUR_PTR;\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    while ((IS_CHAR(val)) && (val != '\\'')) {\n-        cur += len;\n-        val = xmlStringCurrentChar(NULL, cur, &len);\n-    }\n-    if (!IS_CHAR(val)) {\n-        ctxt->error = 1;\n-        return(NULL);\n-    } else {\n-        if (ctxt->dict)\n-        ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\n-        else\n-        ret = xmlStrndup(q, cur - q);\n-        }\n-    cur += len;\n-    CUR_PTR = cur;\n-    } else {\n-    \/* XP_ERROR(XPATH_START_LITERAL_ERROR); *\/\n-    ctxt->error = 1;\n-    return(NULL);\n-    }\n-    return(ret);\n-}\n-#endif\n-\n@@ -808,1 +710,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -812,5 +714,5 @@\n-       (val == '_') ||\n-       (IS_COMBINING(val)) ||\n-       (IS_EXTENDER(val))) {\n-    cur += len;\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n+           (val == '_') ||\n+           (IS_COMBINING(val)) ||\n+           (IS_EXTENDER(val))) {\n+        cur += len;\n+        val = xmlStringCurrentChar(NULL, cur, &len);\n@@ -819,1 +721,1 @@\n-    ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\n+        ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\n@@ -821,1 +723,1 @@\n-    ret = xmlStrndup(q, cur - q);\n+        ret = xmlStrndup(q, cur - q);\n@@ -846,1 +748,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -850,5 +752,5 @@\n-       (val == '_') ||\n-       (IS_COMBINING(val)) ||\n-       (IS_EXTENDER(val))) {\n-    cur += len;\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n+           (val == '_') ||\n+           (IS_COMBINING(val)) ||\n+           (IS_EXTENDER(val))) {\n+        cur += len;\n+        val = xmlStringCurrentChar(NULL, cur, &len);\n@@ -857,1 +759,1 @@\n-    ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\n+        ret = (xmlChar *) xmlDictLookup(ctxt->dict, q, cur - q);\n@@ -859,1 +761,1 @@\n-    ret = xmlStrndup(q, cur - q);\n+        ret = xmlStrndup(q, cur - q);\n@@ -866,26 +768,0 @@\n-#if 0\n-\/**\n- * xmlPatScanQName:\n- * @ctxt:  the XPath Parser context\n- * @prefix:  the place to store the prefix\n- *\n- * Parse a qualified name\n- *\n- * Returns the Name parsed or NULL\n- *\/\n-\n-static xmlChar *\n-xmlPatScanQName(xmlPatParserContextPtr ctxt, xmlChar **prefix) {\n-    xmlChar *ret = NULL;\n-\n-    *prefix = NULL;\n-    ret = xmlPatScanNCName(ctxt);\n-    if (CUR == ':') {\n-        *prefix = ret;\n-    NEXT;\n-    ret = xmlPatScanNCName(ctxt);\n-    }\n-    return(ret);\n-}\n-#endif\n-\n@@ -909,9 +785,9 @@\n-    if (CUR == '*') {\n-        PUSH(XML_OP_ATTR, NULL, NULL);\n-        NEXT;\n-    } else {\n-        ERROR(NULL, NULL, NULL,\n-        \"xmlCompileAttributeTest : Name expected\\n\");\n-        ctxt->error = 1;\n-    }\n-    return;\n+        if (CUR == '*') {\n+            PUSH(XML_OP_ATTR, NULL, NULL);\n+            NEXT;\n+        } else {\n+            ERROR(NULL, NULL, NULL,\n+                \"xmlCompileAttributeTest : Name expected\\n\");\n+            ctxt->error = 1;\n+        }\n+        return;\n@@ -920,2 +796,2 @@\n-    int i;\n-    xmlChar *prefix = name;\n+        int i;\n+        xmlChar *prefix = name;\n@@ -923,1 +799,1 @@\n-    NEXT;\n+        NEXT;\n@@ -925,21 +801,4 @@\n-    if (IS_BLANK_CH(CUR)) {\n-        ERROR5(NULL, NULL, NULL, \"Invalid QName.\\n\", NULL);\n-        ctxt->error = 1;\n-        goto error;\n-    }\n-    \/*\n-    * This is a namespace match\n-    *\/\n-    token = xmlPatScanName(ctxt);\n-    if ((prefix[0] == 'x') &&\n-        (prefix[1] == 'm') &&\n-        (prefix[2] == 'l') &&\n-        (prefix[3] == 0))\n-    {\n-        XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE);\n-    } else {\n-        for (i = 0;i < ctxt->nb_namespaces;i++) {\n-        if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\n-            XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\n-            break;\n-        }\n+        if (IS_BLANK_CH(CUR)) {\n+            ERROR5(NULL, NULL, NULL, \"Invalid QName.\\n\", NULL);\n+            ctxt->error = 1;\n+            goto error;\n@@ -947,6 +806,24 @@\n-        if (i >= ctxt->nb_namespaces) {\n-        ERROR5(NULL, NULL, NULL,\n-            \"xmlCompileAttributeTest : no namespace bound to prefix %s\\n\",\n-            prefix);\n-        ctxt->error = 1;\n-        goto error;\n+        \/*\n+        * This is a namespace match\n+        *\/\n+        token = xmlPatScanName(ctxt);\n+        if ((prefix[0] == 'x') &&\n+            (prefix[1] == 'm') &&\n+            (prefix[2] == 'l') &&\n+            (prefix[3] == 0))\n+        {\n+            XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE);\n+        } else {\n+            for (i = 0;i < ctxt->nb_namespaces;i++) {\n+                if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\n+                    XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\n+                    break;\n+                }\n+            }\n+            if (i >= ctxt->nb_namespaces) {\n+                ERROR5(NULL, NULL, NULL,\n+                    \"xmlCompileAttributeTest : no namespace bound to prefix %s\\n\",\n+                    prefix);\n+                ctxt->error = 1;\n+                goto error;\n+            }\n@@ -954,1 +831,0 @@\n-    }\n@@ -957,4 +833,10 @@\n-    if (token == NULL) {\n-        if (CUR == '*') {\n-        NEXT;\n-        PUSH(XML_OP_ATTR, NULL, URL);\n+        if (token == NULL) {\n+            if (CUR == '*') {\n+                NEXT;\n+                PUSH(XML_OP_ATTR, NULL, URL);\n+            } else {\n+                ERROR(NULL, NULL, NULL,\n+                    \"xmlCompileAttributeTest : Name expected\\n\");\n+                ctxt->error = 1;\n+                goto error;\n+            }\n@@ -962,4 +844,1 @@\n-        ERROR(NULL, NULL, NULL,\n-            \"xmlCompileAttributeTest : Name expected\\n\");\n-        ctxt->error = 1;\n-        goto error;\n+            PUSH(XML_OP_ATTR, token, URL);\n@@ -968,4 +847,1 @@\n-        PUSH(XML_OP_ATTR, token, URL);\n-    }\n-    } else {\n-    PUSH(XML_OP_ATTR, name, NULL);\n+        PUSH(XML_OP_ATTR, name, NULL);\n@@ -976,1 +852,1 @@\n-    XML_PAT_FREE_STRING(ctxt, name);\n+        XML_PAT_FREE_STRING(ctxt, name);\n@@ -978,1 +854,1 @@\n-    XML_PAT_FREE_STRING(ctxt, URL)\n+        XML_PAT_FREE_STRING(ctxt, URL)\n@@ -980,1 +856,1 @@\n-    XML_PAT_FREE_STRING(ctxt, token);\n+        XML_PAT_FREE_STRING(ctxt, token);\n@@ -1003,6 +879,6 @@\n-    \/*\n-    * Context node.\n-    *\/\n-    NEXT;\n-    PUSH(XML_OP_ELEM, NULL, NULL);\n-    return;\n+        \/*\n+        * Context node.\n+        *\/\n+        NEXT;\n+        PUSH(XML_OP_ELEM, NULL, NULL);\n+        return;\n@@ -1011,7 +887,13 @@\n-    \/*\n-    * Attribute test.\n-    *\/\n-    if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {\n-        ERROR5(NULL, NULL, NULL,\n-        \"Unexpected attribute axis in '%s'.\\n\", ctxt->base);\n-        ctxt->error = 1;\n+        \/*\n+        * Attribute test.\n+        *\/\n+        if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {\n+            ERROR5(NULL, NULL, NULL,\n+                \"Unexpected attribute axis in '%s'.\\n\", ctxt->base);\n+            ctxt->error = 1;\n+            return;\n+        }\n+        NEXT;\n+        xmlCompileAttributeTest(ctxt);\n+        if (ctxt->error != 0)\n+            goto error;\n@@ -1020,6 +902,0 @@\n-    NEXT;\n-    xmlCompileAttributeTest(ctxt);\n-    if (ctxt->error != 0)\n-        goto error;\n-    return;\n-    }\n@@ -1030,54 +906,0 @@\n-    if (CUR == '*') {\n-        NEXT;\n-        PUSH(XML_OP_ALL, NULL, NULL);\n-        return;\n-    } else {\n-        ERROR(NULL, NULL, NULL,\n-            \"xmlCompileStepPattern : Name expected\\n\");\n-        ctxt->error = 1;\n-        return;\n-    }\n-    }\n-    if (IS_BLANK_CH(CUR)) {\n-    hasBlanks = 1;\n-    SKIP_BLANKS;\n-    }\n-    if (CUR == ':') {\n-    NEXT;\n-    if (CUR != ':') {\n-        xmlChar *prefix = name;\n-        int i;\n-\n-        if (hasBlanks || IS_BLANK_CH(CUR)) {\n-        ERROR5(NULL, NULL, NULL, \"Invalid QName.\\n\", NULL);\n-        ctxt->error = 1;\n-        goto error;\n-        }\n-        \/*\n-         * This is a namespace match\n-         *\/\n-        token = xmlPatScanName(ctxt);\n-        if ((prefix[0] == 'x') &&\n-        (prefix[1] == 'm') &&\n-        (prefix[2] == 'l') &&\n-        (prefix[3] == 0))\n-        {\n-        XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)\n-        } else {\n-        for (i = 0;i < ctxt->nb_namespaces;i++) {\n-            if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\n-            XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\n-            break;\n-            }\n-        }\n-        if (i >= ctxt->nb_namespaces) {\n-            ERROR5(NULL, NULL, NULL,\n-            \"xmlCompileStepPattern : no namespace bound to prefix %s\\n\",\n-            prefix);\n-            ctxt->error = 1;\n-            goto error;\n-        }\n-        }\n-        XML_PAT_FREE_STRING(ctxt, prefix);\n-        name = NULL;\n-        if (token == NULL) {\n@@ -1085,18 +907,0 @@\n-            NEXT;\n-            PUSH(XML_OP_NS, URL, NULL);\n-        } else {\n-            ERROR(NULL, NULL, NULL,\n-                \"xmlCompileStepPattern : Name expected\\n\");\n-            ctxt->error = 1;\n-            goto error;\n-        }\n-        } else {\n-        PUSH(XML_OP_ELEM, token, URL);\n-        }\n-    } else {\n-        NEXT;\n-        if (xmlStrEqual(name, (const xmlChar *) \"child\")) {\n-        XML_PAT_FREE_STRING(ctxt, name);\n-        name = xmlPatScanName(ctxt);\n-        if (name == NULL) {\n-            if (CUR == '*') {\n@@ -1106,1 +910,1 @@\n-            } else {\n+        } else {\n@@ -1108,1 +912,1 @@\n-                \"xmlCompileStepPattern : QName expected\\n\");\n+                    \"xmlCompileStepPattern : Name expected\\n\");\n@@ -1110,2 +914,1 @@\n-            goto error;\n-            }\n+            return;\n@@ -1113,1 +916,8 @@\n-        if (CUR == ':') {\n+    }\n+    if (IS_BLANK_CH(CUR)) {\n+        hasBlanks = 1;\n+        SKIP_BLANKS;\n+    }\n+    if (CUR == ':') {\n+        NEXT;\n+        if (CUR != ':') {\n@@ -1117,5 +927,4 @@\n-            NEXT;\n-            if (IS_BLANK_CH(CUR)) {\n-            ERROR5(NULL, NULL, NULL, \"Invalid QName.\\n\", NULL);\n-            ctxt->error = 1;\n-            goto error;\n+            if (hasBlanks || IS_BLANK_CH(CUR)) {\n+                ERROR5(NULL, NULL, NULL, \"Invalid QName.\\n\", NULL);\n+                ctxt->error = 1;\n+                goto error;\n@@ -1124,2 +933,2 @@\n-            * This is a namespace match\n-            *\/\n+             * This is a namespace match\n+             *\/\n@@ -1128,3 +937,3 @@\n-            (prefix[1] == 'm') &&\n-            (prefix[2] == 'l') &&\n-            (prefix[3] == 0))\n+                (prefix[1] == 'm') &&\n+                (prefix[2] == 'l') &&\n+                (prefix[3] == 0))\n@@ -1132,1 +941,1 @@\n-            XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)\n+                XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)\n@@ -1134,4 +943,12 @@\n-            for (i = 0;i < ctxt->nb_namespaces;i++) {\n-                if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\n-                XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\n-                break;\n+                for (i = 0;i < ctxt->nb_namespaces;i++) {\n+                    if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\n+                        XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\n+                        break;\n+                    }\n+                }\n+                if (i >= ctxt->nb_namespaces) {\n+                    ERROR5(NULL, NULL, NULL,\n+                        \"xmlCompileStepPattern : no namespace bound to prefix %s\\n\",\n+                        prefix);\n+                    ctxt->error = 1;\n+                    goto error;\n@@ -1139,8 +956,0 @@\n-            }\n-            if (i >= ctxt->nb_namespaces) {\n-                ERROR5(NULL, NULL, NULL,\n-                \"xmlCompileStepPattern : no namespace bound \"\n-                \"to prefix %s\\n\", prefix);\n-                ctxt->error = 1;\n-                goto error;\n-            }\n@@ -1151,3 +960,9 @@\n-            if (CUR == '*') {\n-                NEXT;\n-                PUSH(XML_OP_NS, URL, NULL);\n+                if (CUR == '*') {\n+                    NEXT;\n+                    PUSH(XML_OP_NS, URL, NULL);\n+                } else {\n+                    ERROR(NULL, NULL, NULL,\n+                            \"xmlCompileStepPattern : Name expected\\n\");\n+                    ctxt->error = 1;\n+                    goto error;\n+                }\n@@ -1155,4 +970,1 @@\n-                ERROR(NULL, NULL, NULL,\n-                \"xmlCompileStepPattern : Name expected\\n\");\n-                ctxt->error = 1;\n-                goto error;\n+                PUSH(XML_OP_ELEM, token, URL);\n@@ -1160,0 +972,83 @@\n+        } else {\n+            NEXT;\n+            if (xmlStrEqual(name, (const xmlChar *) \"child\")) {\n+                XML_PAT_FREE_STRING(ctxt, name);\n+                name = xmlPatScanName(ctxt);\n+                if (name == NULL) {\n+                    if (CUR == '*') {\n+                        NEXT;\n+                        PUSH(XML_OP_ALL, NULL, NULL);\n+                        return;\n+                    } else {\n+                        ERROR(NULL, NULL, NULL,\n+                            \"xmlCompileStepPattern : QName expected\\n\");\n+                        ctxt->error = 1;\n+                        goto error;\n+                    }\n+                }\n+                if (CUR == ':') {\n+                    xmlChar *prefix = name;\n+                    int i;\n+\n+                    NEXT;\n+                    if (IS_BLANK_CH(CUR)) {\n+                        ERROR5(NULL, NULL, NULL, \"Invalid QName.\\n\", NULL);\n+                        ctxt->error = 1;\n+                        goto error;\n+                    }\n+                    \/*\n+                    * This is a namespace match\n+                    *\/\n+                    token = xmlPatScanName(ctxt);\n+                    if ((prefix[0] == 'x') &&\n+                        (prefix[1] == 'm') &&\n+                        (prefix[2] == 'l') &&\n+                        (prefix[3] == 0))\n+                    {\n+                        XML_PAT_COPY_NSNAME(ctxt, URL, XML_XML_NAMESPACE)\n+                    } else {\n+                        for (i = 0;i < ctxt->nb_namespaces;i++) {\n+                            if (xmlStrEqual(ctxt->namespaces[2 * i + 1], prefix)) {\n+                                XML_PAT_COPY_NSNAME(ctxt, URL, ctxt->namespaces[2 * i])\n+                                break;\n+                            }\n+                        }\n+                        if (i >= ctxt->nb_namespaces) {\n+                            ERROR5(NULL, NULL, NULL,\n+                                \"xmlCompileStepPattern : no namespace bound \"\n+                                \"to prefix %s\\n\", prefix);\n+                            ctxt->error = 1;\n+                            goto error;\n+                        }\n+                    }\n+                    XML_PAT_FREE_STRING(ctxt, prefix);\n+                    name = NULL;\n+                    if (token == NULL) {\n+                        if (CUR == '*') {\n+                            NEXT;\n+                            PUSH(XML_OP_NS, URL, NULL);\n+                        } else {\n+                            ERROR(NULL, NULL, NULL,\n+                                \"xmlCompileStepPattern : Name expected\\n\");\n+                            ctxt->error = 1;\n+                            goto error;\n+                        }\n+                    } else {\n+                        PUSH(XML_OP_ELEM, token, URL);\n+                    }\n+                } else\n+                    PUSH(XML_OP_ELEM, name, NULL);\n+                return;\n+            } else if (xmlStrEqual(name, (const xmlChar *) \"attribute\")) {\n+                XML_PAT_FREE_STRING(ctxt, name)\n+                name = NULL;\n+                if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {\n+                    ERROR5(NULL, NULL, NULL,\n+                        \"Unexpected attribute axis in '%s'.\\n\", ctxt->base);\n+                    ctxt->error = 1;\n+                    goto error;\n+                }\n+                xmlCompileAttributeTest(ctxt);\n+                if (ctxt->error != 0)\n+                    goto error;\n+                return;\n@@ -1161,1 +1056,4 @@\n-            PUSH(XML_OP_ELEM, token, URL);\n+                ERROR5(NULL, NULL, NULL,\n+                    \"The 'element' or 'attribute' axis is expected.\\n\", NULL);\n+                ctxt->error = 1;\n+                goto error;\n@@ -1163,11 +1061,0 @@\n-        } else\n-            PUSH(XML_OP_ELEM, name, NULL);\n-        return;\n-        } else if (xmlStrEqual(name, (const xmlChar *) \"attribute\")) {\n-        XML_PAT_FREE_STRING(ctxt, name)\n-        name = NULL;\n-        if (XML_STREAM_XS_IDC_SEL(ctxt->comp)) {\n-            ERROR5(NULL, NULL, NULL,\n-            \"Unexpected attribute axis in '%s'.\\n\", ctxt->base);\n-            ctxt->error = 1;\n-            goto error;\n@@ -1175,11 +1062,0 @@\n-        xmlCompileAttributeTest(ctxt);\n-        if (ctxt->error != 0)\n-            goto error;\n-        return;\n-        } else {\n-        ERROR5(NULL, NULL, NULL,\n-            \"The 'element' or 'attribute' axis is expected.\\n\", NULL);\n-        ctxt->error = 1;\n-        goto error;\n-        }\n-    }\n@@ -1188,5 +1064,5 @@\n-        ctxt->error = 1;\n-        goto error;\n-    }\n-    NEXT;\n-    PUSH(XML_OP_ALL, token, NULL);\n+            ctxt->error = 1;\n+            goto error;\n+        }\n+        NEXT;\n+        PUSH(XML_OP_ALL, token, NULL);\n@@ -1194,1 +1070,1 @@\n-    PUSH(XML_OP_ELEM, name, NULL);\n+        PUSH(XML_OP_ELEM, name, NULL);\n@@ -1199,1 +1075,1 @@\n-    XML_PAT_FREE_STRING(ctxt, URL)\n+        XML_PAT_FREE_STRING(ctxt, URL)\n@@ -1201,1 +1077,1 @@\n-    XML_PAT_FREE_STRING(ctxt, token)\n+        XML_PAT_FREE_STRING(ctxt, token)\n@@ -1203,1 +1079,1 @@\n-    XML_PAT_FREE_STRING(ctxt, name)\n+        XML_PAT_FREE_STRING(ctxt, name)\n@@ -1225,3 +1101,3 @@\n-    PUSH(XML_OP_ANCESTOR, NULL, NULL);\n-    NEXT;\n-    NEXT;\n+        PUSH(XML_OP_ANCESTOR, NULL, NULL);\n+        NEXT;\n+        NEXT;\n@@ -1229,28 +1105,3 @@\n-    PUSH(XML_OP_ANCESTOR, NULL, NULL);\n-    NEXT;\n-    NEXT;\n-    NEXT;\n-    \/* Check for incompleteness. *\/\n-    SKIP_BLANKS;\n-    if (CUR == 0) {\n-        ERROR5(NULL, NULL, NULL,\n-           \"Incomplete expression '%s'.\\n\", ctxt->base);\n-        ctxt->error = 1;\n-        goto error;\n-    }\n-    }\n-    if (CUR == '@') {\n-    NEXT;\n-    xmlCompileAttributeTest(ctxt);\n-        if (ctxt->error != 0)\n-            goto error;\n-    SKIP_BLANKS;\n-    \/* TODO: check for incompleteness *\/\n-    if (CUR != 0) {\n-        xmlCompileStepPattern(ctxt);\n-        if (ctxt->error != 0)\n-        goto error;\n-    }\n-    } else {\n-        if (CUR == '\/') {\n-        PUSH(XML_OP_ROOT, NULL, NULL);\n+        PUSH(XML_OP_ANCESTOR, NULL, NULL);\n+        NEXT;\n+        NEXT;\n@@ -1261,4 +1112,4 @@\n-        ERROR5(NULL, NULL, NULL,\n-            \"Incomplete expression '%s'.\\n\", ctxt->base);\n-        ctxt->error = 1;\n-        goto error;\n+            ERROR5(NULL, NULL, NULL,\n+               \"Incomplete expression '%s'.\\n\", ctxt->base);\n+            ctxt->error = 1;\n+            goto error;\n@@ -1267,8 +1118,1 @@\n-    xmlCompileStepPattern(ctxt);\n-    if (ctxt->error != 0)\n-        goto error;\n-    SKIP_BLANKS;\n-    while (CUR == '\/') {\n-        if (NXT(1) == '\/') {\n-            PUSH(XML_OP_ANCESTOR, NULL, NULL);\n-        NEXT;\n+    if (CUR == '@') {\n@@ -1276,2 +1120,1 @@\n-        SKIP_BLANKS;\n-        xmlCompileStepPattern(ctxt);\n+        xmlCompileAttributeTest(ctxt);\n@@ -1280,3 +1123,0 @@\n-        } else {\n-            PUSH(XML_OP_PARENT, NULL, NULL);\n-        NEXT;\n@@ -1284,5 +1124,18 @@\n-        if (CUR == 0) {\n-            ERROR5(NULL, NULL, NULL,\n-            \"Incomplete expression '%s'.\\n\", ctxt->base);\n-            ctxt->error = 1;\n-            goto error;\n+        \/* TODO: check for incompleteness *\/\n+        if (CUR != 0) {\n+            xmlCompileStepPattern(ctxt);\n+            if (ctxt->error != 0)\n+                goto error;\n+        }\n+    } else {\n+        if (CUR == '\/') {\n+            PUSH(XML_OP_ROOT, NULL, NULL);\n+            NEXT;\n+            \/* Check for incompleteness. *\/\n+            SKIP_BLANKS;\n+            if (CUR == 0) {\n+                ERROR5(NULL, NULL, NULL,\n+                    \"Incomplete expression '%s'.\\n\", ctxt->base);\n+                ctxt->error = 1;\n+                goto error;\n+            }\n@@ -1293,0 +1146,24 @@\n+        SKIP_BLANKS;\n+        while (CUR == '\/') {\n+            if (NXT(1) == '\/') {\n+                PUSH(XML_OP_ANCESTOR, NULL, NULL);\n+                NEXT;\n+                NEXT;\n+                SKIP_BLANKS;\n+                xmlCompileStepPattern(ctxt);\n+                if (ctxt->error != 0)\n+                    goto error;\n+            } else {\n+                PUSH(XML_OP_PARENT, NULL, NULL);\n+                NEXT;\n+                SKIP_BLANKS;\n+                if (CUR == 0) {\n+                    ERROR5(NULL, NULL, NULL,\n+                    \"Incomplete expression '%s'.\\n\", ctxt->base);\n+                    ctxt->error = 1;\n+                    goto error;\n+                }\n+                xmlCompileStepPattern(ctxt);\n+                if (ctxt->error != 0)\n+                    goto error;\n+            }\n@@ -1295,1 +1172,0 @@\n-    }\n@@ -1297,3 +1173,3 @@\n-    ERROR5(NULL, NULL, NULL,\n-           \"Failed to compile pattern %s\\n\", ctxt->base);\n-    ctxt->error = 1;\n+        ERROR5(NULL, NULL, NULL,\n+               \"Failed to compile pattern %s\\n\", ctxt->base);\n+        ctxt->error = 1;\n@@ -1318,4 +1194,4 @@\n-    ERROR5(NULL, NULL, NULL,\n-        \"Unexpected selection of the document root in '%s'.\\n\",\n-        ctxt->base);\n-    goto error;\n+        ERROR5(NULL, NULL, NULL,\n+            \"Unexpected selection of the document root in '%s'.\\n\",\n+            ctxt->base);\n+        goto error;\n@@ -1326,27 +1202,9 @@\n-    \/* \".\" - \"self::node()\" *\/\n-    NEXT;\n-    SKIP_BLANKS;\n-    if (CUR == 0) {\n-        \/*\n-        * Selection of the context node.\n-        *\/\n-        PUSH(XML_OP_ELEM, NULL, NULL);\n-        return;\n-    }\n-    if (CUR != '\/') {\n-        \/* TODO: A more meaningful error message. *\/\n-        ERROR5(NULL, NULL, NULL,\n-        \"Unexpected token after '.' in '%s'.\\n\", ctxt->base);\n-        goto error;\n-    }\n-    \/* \".\/\" - \"self::node()\/\" *\/\n-    NEXT;\n-    SKIP_BLANKS;\n-    if (CUR == '\/') {\n-        if (IS_BLANK_CH(PEEKPREV(1))) {\n-        \/*\n-        * Disallow \".\/ \/\"\n-        *\/\n-        ERROR5(NULL, NULL, NULL,\n-            \"Unexpected '\/' token in '%s'.\\n\", ctxt->base);\n-        goto error;\n+        \/* \".\" - \"self::node()\" *\/\n+        NEXT;\n+        SKIP_BLANKS;\n+        if (CUR == 0) {\n+            \/*\n+            * Selection of the context node.\n+            *\/\n+            PUSH(XML_OP_ELEM, NULL, NULL);\n+            return;\n@@ -1354,2 +1212,7 @@\n-        \/* \".\/\/\" - \"self:node()\/descendant-or-self::node()\/\" *\/\n-        PUSH(XML_OP_ANCESTOR, NULL, NULL);\n+        if (CUR != '\/') {\n+            \/* TODO: A more meaningful error message. *\/\n+            ERROR5(NULL, NULL, NULL,\n+            \"Unexpected token after '.' in '%s'.\\n\", ctxt->base);\n+            goto error;\n+        }\n+        \/* \".\/\" - \"self::node()\/\" *\/\n@@ -1358,3 +1221,16 @@\n-    }\n-    if (CUR == 0)\n-        goto error_unfinished;\n+        if (CUR == '\/') {\n+            if (IS_BLANK_CH(PEEKPREV(1))) {\n+                \/*\n+                * Disallow \".\/ \/\"\n+                *\/\n+                ERROR5(NULL, NULL, NULL,\n+                    \"Unexpected '\/' token in '%s'.\\n\", ctxt->base);\n+                goto error;\n+            }\n+            \/* \".\/\/\" - \"self:node()\/descendant-or-self::node()\/\" *\/\n+            PUSH(XML_OP_ANCESTOR, NULL, NULL);\n+            NEXT;\n+            SKIP_BLANKS;\n+        }\n+        if (CUR == 0)\n+            goto error_unfinished;\n@@ -1366,20 +1242,20 @@\n-    xmlCompileStepPattern(ctxt);\n-    if (ctxt->error != 0)\n-        goto error;\n-    SKIP_BLANKS;\n-    if (CUR != '\/')\n-        break;\n-    PUSH(XML_OP_PARENT, NULL, NULL);\n-    NEXT;\n-    SKIP_BLANKS;\n-    if (CUR == '\/') {\n-        \/*\n-        * Disallow subsequent '\/\/'.\n-        *\/\n-        ERROR5(NULL, NULL, NULL,\n-        \"Unexpected subsequent '\/\/' in '%s'.\\n\",\n-        ctxt->base);\n-        goto error;\n-    }\n-    if (CUR == 0)\n-        goto error_unfinished;\n+        xmlCompileStepPattern(ctxt);\n+        if (ctxt->error != 0)\n+            goto error;\n+        SKIP_BLANKS;\n+        if (CUR != '\/')\n+            break;\n+        PUSH(XML_OP_PARENT, NULL, NULL);\n+        NEXT;\n+        SKIP_BLANKS;\n+        if (CUR == '\/') {\n+            \/*\n+            * Disallow subsequent '\/\/'.\n+            *\/\n+            ERROR5(NULL, NULL, NULL,\n+                \"Unexpected subsequent '\/\/' in '%s'.\\n\",\n+                ctxt->base);\n+            goto error;\n+        }\n+        if (CUR == 0)\n+            goto error_unfinished;\n@@ -1390,3 +1266,3 @@\n-    ERROR5(NULL, NULL, NULL,\n-        \"Failed to compile expression '%s'.\\n\", ctxt->base);\n-    ctxt->error = 1;\n+        ERROR5(NULL, NULL, NULL,\n+            \"Failed to compile expression '%s'.\\n\", ctxt->base);\n+        ctxt->error = 1;\n@@ -1402,2 +1278,1 @@\n-    \"Unfinished expression '%s'.\\n\", ctxt->base);\n-    return;\n+        \"Unfinished expression '%s'.\\n\", ctxt->base);\n@@ -1407,3 +1282,3 @@\n- *                                    *\n- *            The streaming code                *\n- *                                    *\n+ *                                                                      *\n+ *                      The streaming code                              *\n+ *                                                                      *\n@@ -1429,3 +1304,3 @@\n-    ERROR(NULL, NULL, NULL,\n-        \"xmlNewStreamComp: malloc failed\\n\");\n-    return(NULL);\n+        ERROR(NULL, NULL, NULL,\n+                \"xmlNewStreamComp: malloc failed\\n\");\n+        return(NULL);\n@@ -1436,4 +1311,4 @@\n-    xmlFree(cur);\n-    ERROR(NULL, NULL, NULL,\n-          \"xmlNewStreamComp: malloc failed\\n\");\n-    return(NULL);\n+        xmlFree(cur);\n+        ERROR(NULL, NULL, NULL,\n+              \"xmlNewStreamComp: malloc failed\\n\");\n+        return(NULL);\n@@ -1456,3 +1331,3 @@\n-        xmlFree(comp->steps);\n-    if (comp->dict != NULL)\n-        xmlDictFree(comp->dict);\n+            xmlFree(comp->steps);\n+        if (comp->dict != NULL)\n+            xmlDictFree(comp->dict);\n@@ -1480,9 +1355,18 @@\n-    cur = (xmlStreamStepPtr) xmlRealloc(comp->steps,\n-                 comp->maxStep * 2 * sizeof(xmlStreamStep));\n-    if (cur == NULL) {\n-        ERROR(NULL, NULL, NULL,\n-          \"xmlNewStreamComp: malloc failed\\n\");\n-        return(-1);\n-    }\n-    comp->steps = cur;\n-        comp->maxStep *= 2;\n+        xmlStreamStepPtr tmp;\n+        int newSize;\n+\n+        newSize = xmlGrowCapacity(comp->maxStep, sizeof(tmp[0]),\n+                                  4, XML_MAX_ITEMS);\n+        if (newSize < 0) {\n+            ERROR(NULL, NULL, NULL,\n+                  \"xmlNewStreamComp: growCapacity failed\\n\");\n+            return(-1);\n+        }\n+        cur = xmlRealloc(comp->steps, newSize * sizeof(tmp[0]));\n+        if (cur == NULL) {\n+            ERROR(NULL, NULL, NULL,\n+                  \"xmlNewStreamComp: malloc failed\\n\");\n+            return(-1);\n+        }\n+        comp->steps = cur;\n+        comp->maxStep = newSize;\n@@ -1519,9 +1403,9 @@\n-    (comp->steps[0].value == NULL) &&\n-    (comp->steps[0].value2 == NULL)) {\n-    stream = xmlNewStreamComp(0);\n-    if (stream == NULL)\n-        return(-1);\n-    \/* Note that the stream will have no steps in this case. *\/\n-    stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;\n-    comp->stream = stream;\n-    return(0);\n+        (comp->steps[0].value == NULL) &&\n+        (comp->steps[0].value2 == NULL)) {\n+        stream = xmlNewStreamComp(0);\n+        if (stream == NULL)\n+            return(-1);\n+        \/* Note that the stream will have no steps in this case. *\/\n+        stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;\n+        comp->stream = stream;\n+        return(0);\n@@ -1535,1 +1419,1 @@\n-    xmlDictReference(stream->dict);\n+        xmlDictReference(stream->dict);\n@@ -1540,1 +1424,1 @@\n-    stream->flags |= XML_STREAM_FROM_ROOT;\n+        stream->flags |= XML_STREAM_FROM_ROOT;\n@@ -1543,1 +1427,1 @@\n-    step = comp->steps[i];\n+        step = comp->steps[i];\n@@ -1545,65 +1429,104 @@\n-        case XML_OP_END:\n-            break;\n-        case XML_OP_ROOT:\n-            if (i != 0)\n-            goto error;\n-        root = 1;\n-        break;\n-        case XML_OP_NS:\n-        s = xmlStreamCompAddStep(stream, NULL, step.value,\n-            XML_ELEMENT_NODE, flags);\n-        if (s < 0)\n-            goto error;\n-        prevs = s;\n-        flags = 0;\n-        break;\n-        case XML_OP_ATTR:\n-        flags |= XML_STREAM_STEP_ATTR;\n-        prevs = -1;\n-        s = xmlStreamCompAddStep(stream,\n-            step.value, step.value2, XML_ATTRIBUTE_NODE, flags);\n-        flags = 0;\n-        if (s < 0)\n-            goto error;\n-        break;\n-        case XML_OP_ELEM:\n-            if ((step.value == NULL) && (step.value2 == NULL)) {\n-            \/*\n-            * We have a \".\" or \"self::node()\" here.\n-            * Eliminate redundant self::node() tests like in \"\/.\/.\"\n-            * or \"\/\/.\/\"\n-            * The only case we won't eliminate is \"\/\/.\", i.e. if\n-            * self::node() is the last node test and we had\n-            * continuation somewhere beforehand.\n-            *\/\n-            if ((comp->nbStep == i + 1) &&\n-            (flags & XML_STREAM_STEP_DESC)) {\n-            \/*\n-            * Mark the special case where the expression resolves\n-            * to any type of node.\n-            *\/\n-            if (comp->nbStep == i + 1) {\n-                stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;\n-            }\n-            flags |= XML_STREAM_STEP_NODE;\n-            s = xmlStreamCompAddStep(stream, NULL, NULL,\n-                XML_STREAM_ANY_NODE, flags);\n-            if (s < 0)\n-                goto error;\n-            flags = 0;\n-            \/*\n-            * If there was a previous step, mark it to be added to\n-            * the result node-set; this is needed since only\n-            * the last step will be marked as \"final\" and only\n-            * \"final\" nodes are added to the resulting set.\n-            *\/\n-            if (prevs != -1) {\n-                stream->steps[prevs].flags |= XML_STREAM_STEP_IN_SET;\n-                prevs = -1;\n-            }\n-            break;\n-\n-            } else {\n-            \/* Just skip this one. *\/\n-            continue;\n-            }\n+            case XML_OP_END:\n+                break;\n+            case XML_OP_ROOT:\n+                if (i != 0)\n+                    goto error;\n+                root = 1;\n+                break;\n+            case XML_OP_NS:\n+                s = xmlStreamCompAddStep(stream, NULL, step.value,\n+                    XML_ELEMENT_NODE, flags);\n+                if (s < 0)\n+                    goto error;\n+                prevs = s;\n+                flags = 0;\n+                break;\n+            case XML_OP_ATTR:\n+                flags |= XML_STREAM_STEP_ATTR;\n+                prevs = -1;\n+                s = xmlStreamCompAddStep(stream,\n+                    step.value, step.value2, XML_ATTRIBUTE_NODE, flags);\n+                flags = 0;\n+                if (s < 0)\n+                    goto error;\n+                break;\n+            case XML_OP_ELEM:\n+                if ((step.value == NULL) && (step.value2 == NULL)) {\n+                    \/*\n+                    * We have a \".\" or \"self::node()\" here.\n+                    * Eliminate redundant self::node() tests like in \"\/.\/.\"\n+                    * or \"\/\/.\/\"\n+                    * The only case we won't eliminate is \"\/\/.\", i.e. if\n+                    * self::node() is the last node test and we had\n+                    * continuation somewhere beforehand.\n+                    *\/\n+                    if ((comp->nbStep == i + 1) &&\n+                        (flags & XML_STREAM_STEP_DESC)) {\n+                        \/*\n+                        * Mark the special case where the expression resolves\n+                        * to any type of node.\n+                        *\/\n+                        if (comp->nbStep == i + 1) {\n+                            stream->flags |= XML_STREAM_FINAL_IS_ANY_NODE;\n+                        }\n+                        flags |= XML_STREAM_STEP_NODE;\n+                        s = xmlStreamCompAddStep(stream, NULL, NULL,\n+                            XML_STREAM_ANY_NODE, flags);\n+                        if (s < 0)\n+                            goto error;\n+                        flags = 0;\n+                        \/*\n+                        * If there was a previous step, mark it to be added to\n+                        * the result node-set; this is needed since only\n+                        * the last step will be marked as \"final\" and only\n+                        * \"final\" nodes are added to the resulting set.\n+                        *\/\n+                        if (prevs != -1) {\n+                            stream->steps[prevs].flags |= XML_STREAM_STEP_IN_SET;\n+                            prevs = -1;\n+                        }\n+                        break;\n+\n+                    } else {\n+                        \/* Just skip this one. *\/\n+                        continue;\n+                    }\n+                }\n+                \/* An element node. *\/\n+                s = xmlStreamCompAddStep(stream, step.value, step.value2,\n+                    XML_ELEMENT_NODE, flags);\n+                if (s < 0)\n+                    goto error;\n+                prevs = s;\n+                flags = 0;\n+                break;\n+            case XML_OP_CHILD:\n+                \/* An element node child. *\/\n+                s = xmlStreamCompAddStep(stream, step.value, step.value2,\n+                    XML_ELEMENT_NODE, flags);\n+                if (s < 0)\n+                    goto error;\n+                prevs = s;\n+                flags = 0;\n+                break;\n+            case XML_OP_ALL:\n+                s = xmlStreamCompAddStep(stream, NULL, NULL,\n+                    XML_ELEMENT_NODE, flags);\n+                if (s < 0)\n+                    goto error;\n+                prevs = s;\n+                flags = 0;\n+                break;\n+            case XML_OP_PARENT:\n+                break;\n+            case XML_OP_ANCESTOR:\n+                \/* Skip redundant continuations. *\/\n+                if (flags & XML_STREAM_STEP_DESC)\n+                    break;\n+                flags |= XML_STREAM_STEP_DESC;\n+                \/*\n+                * Mark the expression as having \"\/\/\".\n+                *\/\n+                if ((stream->flags & XML_STREAM_DESC) == 0)\n+                    stream->flags |= XML_STREAM_DESC;\n+                break;\n@@ -1611,32 +1534,2 @@\n-        \/* An element node. *\/\n-            s = xmlStreamCompAddStep(stream, step.value, step.value2,\n-            XML_ELEMENT_NODE, flags);\n-        if (s < 0)\n-            goto error;\n-        prevs = s;\n-        flags = 0;\n-        break;\n-        case XML_OP_CHILD:\n-        \/* An element node child. *\/\n-            s = xmlStreamCompAddStep(stream, step.value, step.value2,\n-            XML_ELEMENT_NODE, flags);\n-        if (s < 0)\n-            goto error;\n-        prevs = s;\n-        flags = 0;\n-        break;\n-        case XML_OP_ALL:\n-            s = xmlStreamCompAddStep(stream, NULL, NULL,\n-            XML_ELEMENT_NODE, flags);\n-        if (s < 0)\n-            goto error;\n-        prevs = s;\n-        flags = 0;\n-        break;\n-        case XML_OP_PARENT:\n-            break;\n-        case XML_OP_ANCESTOR:\n-        \/* Skip redundant continuations. *\/\n-        if (flags & XML_STREAM_STEP_DESC)\n-            break;\n-            flags |= XML_STREAM_STEP_DESC;\n+    }\n+    if ((! root) && (comp->flags & XML_PATTERN_NOTPATTERN) == 0) {\n@@ -1644,1 +1537,3 @@\n-        * Mark the expression as having \"\/\/\".\n+        * If this should behave like a real pattern, we will mark\n+        * the first step as having \"\/\/\", to be reentrant on every\n+        * tree level.\n@@ -1648,11 +1543,0 @@\n-        break;\n-    }\n-    }\n-    if ((! root) && (comp->flags & XML_PATTERN_NOTPATTERN) == 0) {\n-    \/*\n-    * If this should behave like a real pattern, we will mark\n-    * the first step as having \"\/\/\", to be reentrant on every\n-    * tree level.\n-    *\/\n-    if ((stream->flags & XML_STREAM_DESC) == 0)\n-        stream->flags |= XML_STREAM_DESC;\n@@ -1660,4 +1544,4 @@\n-    if (stream->nbStep > 0) {\n-        if ((stream->steps[0].flags & XML_STREAM_STEP_DESC) == 0)\n-        stream->steps[0].flags |= XML_STREAM_STEP_DESC;\n-    }\n+        if (stream->nbStep > 0) {\n+            if ((stream->steps[0].flags & XML_STREAM_STEP_DESC) == 0)\n+                stream->steps[0].flags |= XML_STREAM_STEP_DESC;\n+        }\n@@ -1666,1 +1550,1 @@\n-    goto error;\n+        goto error;\n@@ -1669,1 +1553,1 @@\n-    stream->steps[0].flags |= XML_STREAM_STEP_ROOT;\n+        stream->steps[0].flags |= XML_STREAM_STEP_ROOT;\n@@ -1691,3 +1575,3 @@\n-    ERROR(NULL, NULL, NULL,\n-        \"xmlNewStreamCtxt: malloc failed\\n\");\n-    return(NULL);\n+        ERROR(NULL, NULL, NULL,\n+                \"xmlNewStreamCtxt: malloc failed\\n\");\n+        return(NULL);\n@@ -1696,7 +1580,1 @@\n-    cur->states = (int *) xmlMalloc(4 * 2 * sizeof(int));\n-    if (cur->states == NULL) {\n-    xmlFree(cur);\n-    ERROR(NULL, NULL, NULL,\n-          \"xmlNewStreamCtxt: malloc failed\\n\");\n-    return(NULL);\n-    }\n+    cur->states = NULL;\n@@ -1704,1 +1582,1 @@\n-    cur->maxState = 4;\n+    cur->maxState = 0;\n@@ -1724,1 +1602,1 @@\n-        xmlFree(stream->states);\n+            xmlFree(stream->states);\n@@ -1726,1 +1604,1 @@\n-    stream = next;\n+        stream = next;\n@@ -1744,4 +1622,4 @@\n-        comp->states[2 * i] = idx;\n-        comp->states[2 * i + 1] = level;\n-        return(i);\n-    }\n+            comp->states[2 * i] = idx;\n+            comp->states[2 * i + 1] = level;\n+            return(i);\n+        }\n@@ -1750,1 +1628,2 @@\n-        int *cur;\n+        int *tmp;\n+        int newSize;\n@@ -1752,9 +1631,15 @@\n-    cur = (int *) xmlRealloc(comp->states,\n-                 comp->maxState * 4 * sizeof(int));\n-    if (cur == NULL) {\n-        ERROR(NULL, NULL, NULL,\n-          \"xmlNewStreamCtxt: malloc failed\\n\");\n-        return(-1);\n-    }\n-    comp->states = cur;\n-        comp->maxState *= 2;\n+        newSize = xmlGrowCapacity(comp->maxState, sizeof(tmp[0]) * 2,\n+                                  4, XML_MAX_ITEMS);\n+        if (newSize < 0) {\n+            ERROR(NULL, NULL, NULL,\n+                  \"xmlNewStreamCtxt: growCapacity failed\\n\");\n+            return(-1);\n+        }\n+        tmp = xmlRealloc(comp->states, newSize * sizeof(tmp[0]) * 2);\n+        if (tmp == NULL) {\n+            ERROR(NULL, NULL, NULL,\n+                  \"xmlNewStreamCtxt: malloc failed\\n\");\n+            return(-1);\n+        }\n+        comp->states = tmp;\n+        comp->maxState = newSize;\n@@ -1785,2 +1670,2 @@\n-              const xmlChar *name, const xmlChar *ns,\n-              int nodeType) {\n+                      const xmlChar *name, const xmlChar *ns,\n+                      int nodeType) {\n@@ -1795,24 +1680,24 @@\n-    comp = stream->comp;\n-\n-    if ((nodeType == XML_ELEMENT_NODE) &&\n-        (name == NULL) && (ns == NULL)) {\n-        \/* We have a document node here (or a reset). *\/\n-        stream->nbState = 0;\n-        stream->level = 0;\n-        stream->blockLevel = -1;\n-        if (comp->flags & XML_STREAM_FROM_ROOT) {\n-        if (comp->nbStep == 0) {\n-            \/* TODO: We have a \"\/.\" here? *\/\n-            ret = 1;\n-        } else {\n-            if ((comp->nbStep == 1) &&\n-            (comp->steps[0].nodeType == XML_STREAM_ANY_NODE) &&\n-            (comp->steps[0].flags & XML_STREAM_STEP_DESC))\n-            {\n-            \/*\n-            * In the case of \"\/\/.\" the document node will match\n-            * as well.\n-            *\/\n-            ret = 1;\n-            } else if (comp->steps[0].flags & XML_STREAM_STEP_ROOT) {\n-            if (xmlStreamCtxtAddState(stream, 0, 0) < 0)\n+        comp = stream->comp;\n+\n+        if ((nodeType == XML_ELEMENT_NODE) &&\n+            (name == NULL) && (ns == NULL)) {\n+            \/* We have a document node here (or a reset). *\/\n+            stream->nbState = 0;\n+            stream->level = 0;\n+            stream->blockLevel = -1;\n+            if (comp->flags & XML_STREAM_FROM_ROOT) {\n+                if (comp->nbStep == 0) {\n+                    \/* TODO: We have a \"\/.\" here? *\/\n+                    ret = 1;\n+                } else {\n+                    if ((comp->nbStep == 1) &&\n+                        (comp->steps[0].nodeType == XML_STREAM_ANY_NODE) &&\n+                        (comp->steps[0].flags & XML_STREAM_STEP_DESC))\n+                    {\n+                        \/*\n+                        * In the case of \"\/\/.\" the document node will match\n+                        * as well.\n+                        *\/\n+                        ret = 1;\n+                    } else if (comp->steps[0].flags & XML_STREAM_STEP_ROOT) {\n+                        if (xmlStreamCtxtAddState(stream, 0, 0) < 0)\n@@ -1820,0 +1705,2 @@\n+                    }\n+                }\n@@ -1821,0 +1708,2 @@\n+            stream = stream->next;\n+            continue; \/* while *\/\n@@ -1822,4 +1711,0 @@\n-        }\n-        stream = stream->next;\n-        continue; \/* while *\/\n-    }\n@@ -1827,12 +1712,0 @@\n-    \/*\n-    * Fast check for \".\".\n-    *\/\n-    if (comp->nbStep == 0) {\n-        \/*\n-         * \/ and . are handled at the XPath node set creation\n-         * level by checking min depth\n-         *\/\n-        if (stream->flags & XML_PATTERN_XPATH) {\n-        stream = stream->next;\n-        continue; \/* while *\/\n-        }\n@@ -1840,3 +1713,1 @@\n-        * For non-pattern like evaluation like XML Schema IDCs\n-        * or traditional XPath expressions, this will match if\n-        * we are at the first level only, otherwise on every level.\n+        * Fast check for \".\".\n@@ -1844,4 +1715,21 @@\n-        if ((nodeType != XML_ATTRIBUTE_NODE) &&\n-        (((stream->flags & XML_PATTERN_NOTPATTERN) == 0) ||\n-        (stream->level == 0))) {\n-            ret = 1;\n+        if (comp->nbStep == 0) {\n+            \/*\n+             * \/ and . are handled at the XPath node set creation\n+             * level by checking min depth\n+             *\/\n+            if (stream->flags & XML_PATTERN_XPATH) {\n+                stream = stream->next;\n+                continue; \/* while *\/\n+            }\n+            \/*\n+            * For non-pattern like evaluation like XML Schema IDCs\n+            * or traditional XPath expressions, this will match if\n+            * we are at the first level only, otherwise on every level.\n+            *\/\n+            if ((nodeType != XML_ATTRIBUTE_NODE) &&\n+                (((stream->flags & XML_PATTERN_NOTPATTERN) == 0) ||\n+                (stream->level == 0))) {\n+                    ret = 1;\n+            }\n+            stream->level++;\n+            goto stream_next;\n@@ -1849,41 +1737,6 @@\n-        stream->level++;\n-        goto stream_next;\n-    }\n-    if (stream->blockLevel != -1) {\n-        \/*\n-        * Skip blocked expressions.\n-        *\/\n-        stream->level++;\n-        goto stream_next;\n-    }\n-\n-    if ((nodeType != XML_ELEMENT_NODE) &&\n-        (nodeType != XML_ATTRIBUTE_NODE) &&\n-        ((comp->flags & XML_STREAM_FINAL_IS_ANY_NODE) == 0)) {\n-        \/*\n-        * No need to process nodes of other types if we don't\n-        * resolve to those types.\n-        * TODO: Do we need to block the context here?\n-        *\/\n-        stream->level++;\n-        goto stream_next;\n-    }\n-\n-    \/*\n-     * Check evolution of existing states\n-     *\/\n-    i = 0;\n-    m = stream->nbState;\n-    while (i < m) {\n-        if ((comp->flags & XML_STREAM_DESC) == 0) {\n-        \/*\n-        * If there is no \"\/\/\", then only the last\n-        * added state is of interest.\n-        *\/\n-        stepNr = stream->states[2 * (stream->nbState -1)];\n-        \/*\n-        * TODO: Security check, should not happen, remove it.\n-        *\/\n-        if (stream->states[(2 * (stream->nbState -1)) + 1] <\n-            stream->level) {\n-            return (-1);\n+        if (stream->blockLevel != -1) {\n+            \/*\n+            * Skip blocked expressions.\n+            *\/\n+            stream->level++;\n+            goto stream_next;\n@@ -1891,14 +1744,0 @@\n-        desc = 0;\n-        \/* loop-stopper *\/\n-        i = m;\n-        } else {\n-        \/*\n-        * If there are \"\/\/\", then we need to process every \"\/\/\"\n-        * occurring in the states, plus any other state for this\n-        * level.\n-        *\/\n-        stepNr = stream->states[2 * i];\n-\n-        \/* TODO: should not happen anymore: dead states *\/\n-        if (stepNr < 0)\n-            goto next_state;\n@@ -1906,17 +1745,3 @@\n-        tmp = stream->states[(2 * i) + 1];\n-\n-        \/* skip new states just added *\/\n-        if (tmp > stream->level)\n-            goto next_state;\n-\n-        \/* skip states at ancestor levels, except if \"\/\/\" *\/\n-        desc = comp->steps[stepNr].flags & XML_STREAM_STEP_DESC;\n-        if ((tmp < stream->level) && (!desc))\n-            goto next_state;\n-        }\n-        \/*\n-        * Check for correct node-type.\n-        *\/\n-        step = comp->steps[stepNr];\n-        if (step.nodeType != nodeType) {\n-        if (step.nodeType == XML_ATTRIBUTE_NODE) {\n+        if ((nodeType != XML_ELEMENT_NODE) &&\n+            (nodeType != XML_ATTRIBUTE_NODE) &&\n+            ((comp->flags & XML_STREAM_FINAL_IS_ANY_NODE) == 0)) {\n@@ -1924,1 +1749,3 @@\n-            * Block this expression for deeper evaluation.\n+            * No need to process nodes of other types if we don't\n+            * resolve to those types.\n+            * TODO: Do we need to block the context here?\n@@ -1926,5 +1753,2 @@\n-            if ((comp->flags & XML_STREAM_DESC) == 0)\n-            stream->blockLevel = stream->level +1;\n-            goto next_state;\n-        } else if (step.nodeType != XML_STREAM_ANY_NODE)\n-            goto next_state;\n+            stream->level++;\n+            goto stream_next;\n@@ -1932,0 +1756,1 @@\n+\n@@ -1933,7 +1758,44 @@\n-        * Compare local\/namespace-name.\n-        *\/\n-        match = 0;\n-        if (step.nodeType == XML_STREAM_ANY_NODE) {\n-        match = 1;\n-        } else if (step.name == NULL) {\n-        if (step.ns == NULL) {\n+         * Check evolution of existing states\n+         *\/\n+        i = 0;\n+        m = stream->nbState;\n+        while (i < m) {\n+            if ((comp->flags & XML_STREAM_DESC) == 0) {\n+                \/*\n+                * If there is no \"\/\/\", then only the last\n+                * added state is of interest.\n+                *\/\n+                stepNr = stream->states[2 * (stream->nbState -1)];\n+                \/*\n+                * TODO: Security check, should not happen, remove it.\n+                *\/\n+                if (stream->states[(2 * (stream->nbState -1)) + 1] <\n+                    stream->level) {\n+                    return (-1);\n+                }\n+                desc = 0;\n+                \/* loop-stopper *\/\n+                i = m;\n+            } else {\n+                \/*\n+                * If there are \"\/\/\", then we need to process every \"\/\/\"\n+                * occurring in the states, plus any other state for this\n+                * level.\n+                *\/\n+                stepNr = stream->states[2 * i];\n+\n+                \/* TODO: should not happen anymore: dead states *\/\n+                if (stepNr < 0)\n+                    goto next_state;\n+\n+                tmp = stream->states[(2 * i) + 1];\n+\n+                \/* skip new states just added *\/\n+                if (tmp > stream->level)\n+                    goto next_state;\n+\n+                \/* skip states at ancestor levels, except if \"\/\/\" *\/\n+                desc = comp->steps[stepNr].flags & XML_STREAM_STEP_DESC;\n+                if ((tmp < stream->level) && (!desc))\n+                    goto next_state;\n+            }\n@@ -1941,1 +1803,1 @@\n-            * This lets through all elements\/attributes.\n+            * Check for correct node-type.\n@@ -1943,29 +1805,36 @@\n-            match = 1;\n-        } else if (ns != NULL)\n-            match = xmlStrEqual(step.ns, ns);\n-        } else if (((step.ns != NULL) == (ns != NULL)) &&\n-        (name != NULL) &&\n-        (step.name[0] == name[0]) &&\n-        xmlStrEqual(step.name, name) &&\n-        ((step.ns == ns) || xmlStrEqual(step.ns, ns)))\n-        {\n-        match = 1;\n-        }\n-#if 0\n-\/*\n-* TODO: Pointer comparison won't work, since not guaranteed that the given\n-*  values are in the same dict; especially if it's the namespace name,\n-*  normally coming from ns->href. We need a namespace dict mechanism !\n-*\/\n-        } else if (comp->dict) {\n-        if (step.name == NULL) {\n-            if (step.ns == NULL)\n-            match = 1;\n-            else\n-            match = (step.ns == ns);\n-        } else {\n-            match = ((step.name == name) && (step.ns == ns));\n-        }\n-#endif \/* if 0 ------------------------------------------------------- *\/\n-        if (match) {\n-        final = step.flags & XML_STREAM_STEP_FINAL;\n+            step = comp->steps[stepNr];\n+            if (step.nodeType != nodeType) {\n+                if (step.nodeType == XML_ATTRIBUTE_NODE) {\n+                    \/*\n+                    * Block this expression for deeper evaluation.\n+                    *\/\n+                    if ((comp->flags & XML_STREAM_DESC) == 0)\n+                        stream->blockLevel = stream->level +1;\n+                    goto next_state;\n+                } else if (step.nodeType != XML_STREAM_ANY_NODE)\n+                    goto next_state;\n+            }\n+            \/*\n+            * Compare local\/namespace-name.\n+            *\/\n+            match = 0;\n+            if (step.nodeType == XML_STREAM_ANY_NODE) {\n+                match = 1;\n+            } else if (step.name == NULL) {\n+                if (step.ns == NULL) {\n+                    \/*\n+                    * This lets through all elements\/attributes.\n+                    *\/\n+                    match = 1;\n+                } else if (ns != NULL)\n+                    match = xmlStrEqual(step.ns, ns);\n+            } else if (((step.ns != NULL) == (ns != NULL)) &&\n+                (name != NULL) &&\n+                (step.name[0] == name[0]) &&\n+                xmlStrEqual(step.name, name) &&\n+                ((step.ns == ns) || xmlStrEqual(step.ns, ns)))\n+            {\n+                match = 1;\n+            }\n+            if (match) {\n+                final = step.flags & XML_STREAM_STEP_FINAL;\n@@ -1978,17 +1847,17 @@\n-        if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {\n-            \/*\n-            * Check if we have a special case like \"foo\/bar\/\/.\", where\n-            * \"foo\" is selected as well.\n-            *\/\n-            ret = 1;\n-        }\n-        }\n-        if (((comp->flags & XML_STREAM_DESC) == 0) &&\n-        ((! match) || final))  {\n-        \/*\n-        * Mark this expression as blocked for any evaluation at\n-        * deeper levels. Note that this includes \"\/foo\"\n-        * expressions if the *pattern* behaviour is used.\n-        *\/\n-        stream->blockLevel = stream->level +1;\n-        }\n+                if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {\n+                    \/*\n+                    * Check if we have a special case like \"foo\/bar\/\/.\", where\n+                    * \"foo\" is selected as well.\n+                    *\/\n+                    ret = 1;\n+                }\n+            }\n+            if (((comp->flags & XML_STREAM_DESC) == 0) &&\n+                ((! match) || final))  {\n+                \/*\n+                * Mark this expression as blocked for any evaluation at\n+                * deeper levels. Note that this includes \"\/foo\"\n+                * expressions if the *pattern* behaviour is used.\n+                *\/\n+                stream->blockLevel = stream->level +1;\n+            }\n@@ -1996,4 +1865,2 @@\n-        i++;\n-    }\n-\n-    stream->level++;\n+            i++;\n+        }\n@@ -2001,8 +1868,1 @@\n-    \/*\n-    * Re\/enter the expression.\n-    * Don't reenter if it's an absolute expression like \"\/foo\",\n-    *   except \"\/\/foo\".\n-    *\/\n-    step = comp->steps[0];\n-    if (step.flags & XML_STREAM_STEP_ROOT)\n-        goto stream_next;\n+        stream->level++;\n@@ -2010,2 +1870,0 @@\n-    desc = step.flags & XML_STREAM_STEP_DESC;\n-    if (stream->flags & XML_PATTERN_NOTPATTERN) {\n@@ -2013,2 +1871,3 @@\n-        * Re\/enter the expression if it is a \"descendant\" one,\n-        * or if we are at the 1st level of evaluation.\n+        * Re\/enter the expression.\n+        * Don't reenter if it's an absolute expression like \"\/foo\",\n+        *   except \"\/\/foo\".\n@@ -2016,0 +1875,26 @@\n+        step = comp->steps[0];\n+        if (step.flags & XML_STREAM_STEP_ROOT)\n+            goto stream_next;\n+\n+        desc = step.flags & XML_STREAM_STEP_DESC;\n+        if (stream->flags & XML_PATTERN_NOTPATTERN) {\n+            \/*\n+            * Re\/enter the expression if it is a \"descendant\" one,\n+            * or if we are at the 1st level of evaluation.\n+            *\/\n+\n+            if (stream->level == 1) {\n+                if (XML_STREAM_XS_IDC(stream)) {\n+                    \/*\n+                    * XS-IDC: The missing \"self::node()\" will always\n+                    * match the first given node.\n+                    *\/\n+                    goto stream_next;\n+                } else\n+                    goto compare;\n+            }\n+            \/*\n+            * A \"\/\/\" is always reentrant.\n+            *\/\n+            if (desc)\n+                goto compare;\n@@ -2017,2 +1902,0 @@\n-        if (stream->level == 1) {\n-        if (XML_STREAM_XS_IDC(stream)) {\n@@ -2020,2 +1903,3 @@\n-            * XS-IDC: The missing \"self::node()\" will always\n-            * match the first given node.\n+            * XS-IDC: Process the 2nd level, since the missing\n+            * \"self::node()\" is responsible for the 2nd level being\n+            * the real start level.\n@@ -2023,0 +1907,3 @@\n+            if ((stream->level == 2) && XML_STREAM_XS_IDC(stream))\n+                goto compare;\n+\n@@ -2024,2 +1911,0 @@\n-        } else\n-            goto compare;\n@@ -2027,5 +1912,0 @@\n-        \/*\n-        * A \"\/\/\" is always reentrant.\n-        *\/\n-        if (desc)\n-        goto compare;\n@@ -2033,0 +1913,1 @@\n+compare:\n@@ -2034,3 +1915,1 @@\n-        * XS-IDC: Process the 2nd level, since the missing\n-        * \"self::node()\" is responsible for the 2nd level being\n-        * the real start level.\n+        * Check expected node-type.\n@@ -2038,24 +1917,6 @@\n-        if ((stream->level == 2) && XML_STREAM_XS_IDC(stream))\n-        goto compare;\n-\n-        goto stream_next;\n-    }\n-\n-compare:\n-    \/*\n-    * Check expected node-type.\n-    *\/\n-    if (step.nodeType != nodeType) {\n-        if (nodeType == XML_ATTRIBUTE_NODE)\n-        goto stream_next;\n-        else if (step.nodeType != XML_STREAM_ANY_NODE)\n-        goto stream_next;\n-    }\n-    \/*\n-    * Compare local\/namespace-name.\n-    *\/\n-    match = 0;\n-    if (step.nodeType == XML_STREAM_ANY_NODE) {\n-        match = 1;\n-    } else if (step.name == NULL) {\n-        if (step.ns == NULL) {\n+        if (step.nodeType != nodeType) {\n+            if (nodeType == XML_ATTRIBUTE_NODE)\n+                goto stream_next;\n+            else if (step.nodeType != XML_STREAM_ANY_NODE)\n+                goto stream_next;\n+        }\n@@ -2063,1 +1924,1 @@\n-        * This lets through all elements\/attributes.\n+        * Compare local\/namespace-name.\n@@ -2065,15 +1926,23 @@\n-        match = 1;\n-        } else if (ns != NULL)\n-        match = xmlStrEqual(step.ns, ns);\n-    } else if (((step.ns != NULL) == (ns != NULL)) &&\n-        (name != NULL) &&\n-        (step.name[0] == name[0]) &&\n-        xmlStrEqual(step.name, name) &&\n-        ((step.ns == ns) || xmlStrEqual(step.ns, ns)))\n-    {\n-        match = 1;\n-    }\n-    final = step.flags & XML_STREAM_STEP_FINAL;\n-    if (match) {\n-        if (final) {\n-        ret = 1;\n+        match = 0;\n+        if (step.nodeType == XML_STREAM_ANY_NODE) {\n+            match = 1;\n+        } else if (step.name == NULL) {\n+            if (step.ns == NULL) {\n+                \/*\n+                * This lets through all elements\/attributes.\n+                *\/\n+                match = 1;\n+            } else if (ns != NULL)\n+                match = xmlStrEqual(step.ns, ns);\n+        } else if (((step.ns != NULL) == (ns != NULL)) &&\n+            (name != NULL) &&\n+            (step.name[0] == name[0]) &&\n+            xmlStrEqual(step.name, name) &&\n+            ((step.ns == ns) || xmlStrEqual(step.ns, ns)))\n+        {\n+            match = 1;\n+        }\n+        final = step.flags & XML_STREAM_STEP_FINAL;\n+        if (match) {\n+            if (final) {\n+                ret = 1;\n@@ -2083,6 +1952,15 @@\n-        if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {\n-        \/*\n-        * Check if we have a special case like \"foo\/\/.\", where\n-        * \"foo\" is selected as well.\n-        *\/\n-        ret = 1;\n+            if ((ret != 1) && (step.flags & XML_STREAM_STEP_IN_SET)) {\n+                \/*\n+                * Check if we have a special case like \"foo\/\/.\", where\n+                * \"foo\" is selected as well.\n+                *\/\n+                ret = 1;\n+            }\n+        }\n+        if (((comp->flags & XML_STREAM_DESC) == 0) &&\n+            ((! match) || final))  {\n+            \/*\n+            * Mark this expression as blocked for any evaluation at\n+            * deeper levels.\n+            *\/\n+            stream->blockLevel = stream->level;\n@@ -2090,9 +1968,0 @@\n-    }\n-    if (((comp->flags & XML_STREAM_DESC) == 0) &&\n-        ((! match) || final))  {\n-        \/*\n-        * Mark this expression as blocked for any evaluation at\n-        * deeper levels.\n-        *\/\n-        stream->blockLevel = stream->level;\n-    }\n@@ -2150,2 +2019,2 @@\n-          const xmlChar *name, const xmlChar *ns,\n-          int nodeType)\n+                  const xmlChar *name, const xmlChar *ns,\n+                  int nodeType)\n@@ -2154,1 +2023,1 @@\n-    nodeType));\n+        nodeType));\n@@ -2175,1 +2044,1 @@\n-          const xmlChar *name, const xmlChar *ns) {\n+                  const xmlChar *name, const xmlChar *ns) {\n@@ -2194,5 +2063,5 @@\n-    \/*\n-    * Reset block-level.\n-    *\/\n-    if (stream->blockLevel == stream->level)\n-        stream->blockLevel = -1;\n+        \/*\n+        * Reset block-level.\n+        *\/\n+        if (stream->blockLevel == stream->level)\n+            stream->blockLevel = -1;\n@@ -2200,19 +2069,19 @@\n-    \/*\n-     *  stream->level can be zero when XML_FINAL_IS_ANY_NODE is set\n-     *  (see the thread at\n-     *  http:\/\/mail.gnome.org\/archives\/xslt\/2008-July\/msg00027.html)\n-     *\/\n-    if (stream->level)\n-        stream->level--;\n-    \/*\n-     * Check evolution of existing states\n-     *\/\n-    for (i = stream->nbState -1; i >= 0; i--) {\n-        \/* discard obsoleted states *\/\n-        lev = stream->states[(2 * i) + 1];\n-        if (lev > stream->level)\n-        stream->nbState--;\n-        if (lev <= stream->level)\n-        break;\n-    }\n-    stream = stream->next;\n+        \/*\n+         *  stream->level can be zero when XML_FINAL_IS_ANY_NODE is set\n+         *  (see the thread at\n+         *  http:\/\/mail.gnome.org\/archives\/xslt\/2008-July\/msg00027.html)\n+         *\/\n+        if (stream->level)\n+            stream->level--;\n+        \/*\n+         * Check evolution of existing states\n+         *\/\n+        for (i = stream->nbState -1; i >= 0; i--) {\n+            \/* discard obsoleted states *\/\n+            lev = stream->states[(2 * i) + 1];\n+            if (lev > stream->level)\n+                stream->nbState--;\n+            if (lev <= stream->level)\n+                break;\n+        }\n+        stream = stream->next;\n@@ -2239,1 +2108,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2241,3 +2110,3 @@\n-    if (streamCtxt->comp->flags & XML_STREAM_FINAL_IS_ANY_NODE)\n-        return(1);\n-    streamCtxt = streamCtxt->next;\n+        if (streamCtxt->comp->flags & XML_STREAM_FINAL_IS_ANY_NODE)\n+            return(1);\n+        streamCtxt = streamCtxt->next;\n@@ -2249,3 +2118,3 @@\n- *                                    *\n- *            The public interfaces                *\n- *                                    *\n+ *                                                                      *\n+ *                      The public interfaces                           *\n+ *                                                                      *\n@@ -2290,2 +2159,2 @@\n-    tmp = NULL;\n-    while ((*or != 0) && (*or != '|')) or++;\n+        tmp = NULL;\n+        while ((*or != 0) && (*or != '|')) or++;\n@@ -2293,5 +2162,7 @@\n-        ctxt = xmlNewPatParserContext(start, dict, namespaces);\n-    else {\n-        tmp = xmlStrndup(start, or - start);\n-        if (tmp != NULL) {\n-        ctxt = xmlNewPatParserContext(tmp, dict, namespaces);\n+            ctxt = xmlNewPatParserContext(start, dict, namespaces);\n+        else {\n+            tmp = xmlStrndup(start, or - start);\n+            if (tmp != NULL) {\n+                ctxt = xmlNewPatParserContext(tmp, dict, namespaces);\n+            }\n+            or++;\n@@ -2299,3 +2170,1 @@\n-        or++;\n-    }\n-    if (ctxt == NULL) {\n+        if (ctxt == NULL) {\n@@ -2305,2 +2174,2 @@\n-    cur = xmlNewPattern();\n-    if (cur == NULL) {\n+        cur = xmlNewPattern();\n+        if (cur == NULL) {\n@@ -2310,15 +2179,15 @@\n-    \/*\n-    * Assign string dict.\n-    *\/\n-    if (dict) {\n-        cur->dict = dict;\n-        xmlDictReference(dict);\n-    }\n-    if (ret == NULL)\n-        ret = cur;\n-    else {\n-        cur->next = ret->next;\n-        ret->next = cur;\n-    }\n-    cur->flags = flags;\n-    ctxt->comp = cur;\n+        \/*\n+        * Assign string dict.\n+        *\/\n+        if (dict) {\n+            cur->dict = dict;\n+            xmlDictReference(dict);\n+        }\n+        if (ret == NULL)\n+            ret = cur;\n+        else {\n+            cur->next = ret->next;\n+            ret->next = cur;\n+        }\n+        cur->flags = flags;\n+        ctxt->comp = cur;\n@@ -2326,5 +2195,5 @@\n-    if (XML_STREAM_XS_IDC(cur))\n-        xmlCompileIDCXPathPath(ctxt);\n-    else\n-        xmlCompilePathPattern(ctxt);\n-    if (ctxt->error != 0) {\n+        if (XML_STREAM_XS_IDC(cur))\n+            xmlCompileIDCXPathPath(ctxt);\n+        else\n+            xmlCompilePathPattern(ctxt);\n+        if (ctxt->error != 0) {\n@@ -2332,1 +2201,1 @@\n-        goto error;\n+            goto error;\n@@ -2334,2 +2203,2 @@\n-    xmlFreePatParserContext(ctxt);\n-    ctxt = NULL;\n+        xmlFreePatParserContext(ctxt);\n+        ctxt = NULL;\n@@ -2339,8 +2208,9 @@\n-        if (type == 0) {\n-            type = cur->flags & (PAT_FROM_ROOT | PAT_FROM_CUR);\n-        } else if (type == PAT_FROM_ROOT) {\n-            if (cur->flags & PAT_FROM_CUR)\n-            streamable = 0;\n-        } else if (type == PAT_FROM_CUR) {\n-            if (cur->flags & PAT_FROM_ROOT)\n-            streamable = 0;\n+            if (type == 0) {\n+                type = cur->flags & (PAT_FROM_ROOT | PAT_FROM_CUR);\n+            } else if (type == PAT_FROM_ROOT) {\n+                if (cur->flags & PAT_FROM_CUR)\n+                    streamable = 0;\n+            } else if (type == PAT_FROM_CUR) {\n+                if (cur->flags & PAT_FROM_ROOT)\n+                    streamable = 0;\n+            }\n@@ -2348,3 +2218,2 @@\n-    }\n-    if (streamable) {\n-        error = xmlStreamCompile(cur);\n+        if (streamable) {\n+            error = xmlStreamCompile(cur);\n@@ -2354,1 +2223,1 @@\n-    error = xmlReversePattern(cur);\n+        error = xmlReversePattern(cur);\n@@ -2356,6 +2225,6 @@\n-        goto error;\n-    if (tmp != NULL) {\n-        xmlFree(tmp);\n-        tmp = NULL;\n-    }\n-    start = or;\n+            goto error;\n+        if (tmp != NULL) {\n+            xmlFree(tmp);\n+            tmp = NULL;\n+        }\n+        start = or;\n@@ -2365,4 +2234,6 @@\n-    while (cur != NULL) {\n-        if (cur->stream != NULL) {\n-        xmlFreeStreamComp(cur->stream);\n-        cur->stream = NULL;\n+        while (cur != NULL) {\n+            if (cur->stream != NULL) {\n+                xmlFreeStreamComp(cur->stream);\n+                cur->stream = NULL;\n+            }\n+            cur = cur->next;\n@@ -2370,2 +2241,0 @@\n-        cur = cur->next;\n-    }\n@@ -2422,3 +2291,3 @@\n-    if (ret != 0)\n-        return(ret);\n-    comp = comp->next;\n+        if (ret != 0)\n+            return(ret);\n+        comp = comp->next;\n@@ -2448,12 +2317,12 @@\n-        goto failed;\n-    cur = xmlNewStreamCtxt(comp->stream);\n-    if (cur == NULL)\n-        goto failed;\n-    if (ret == NULL)\n-        ret = cur;\n-    else {\n-        cur->next = ret->next;\n-        ret->next = cur;\n-    }\n-    cur->flags = comp->flags;\n-    comp = comp->next;\n+            goto failed;\n+        cur = xmlNewStreamCtxt(comp->stream);\n+        if (cur == NULL)\n+            goto failed;\n+        if (ret == NULL)\n+            ret = cur;\n+        else {\n+            cur->next = ret->next;\n+            ret->next = cur;\n+        }\n+        cur->flags = comp->flags;\n+        comp = comp->next;\n@@ -2482,2 +2351,2 @@\n-        return(0);\n-    comp = comp->next;\n+            return(0);\n+        comp = comp->next;\n@@ -2504,7 +2373,7 @@\n-        return(-1);\n-    for (i = 0;i < comp->stream->nbStep;i++)\n-        if (comp->stream->steps[i].flags & XML_STREAM_STEP_DESC)\n-            return(-2);\n-    if (comp->stream->nbStep > ret)\n-        ret = comp->stream->nbStep;\n-    comp = comp->next;\n+            return(-1);\n+        for (i = 0;i < comp->stream->nbStep;i++)\n+            if (comp->stream->steps[i].flags & XML_STREAM_STEP_DESC)\n+                return(-2);\n+        if (comp->stream->nbStep > ret)\n+            ret = comp->stream->nbStep;\n+        comp = comp->next;\n@@ -2532,6 +2401,6 @@\n-        return(-1);\n-    if (comp->stream->nbStep < ret)\n-        ret = comp->stream->nbStep;\n-    if (ret == 0)\n-        return(0);\n-    comp = comp->next;\n+            return(-1);\n+        if (comp->stream->nbStep < ret)\n+            ret = comp->stream->nbStep;\n+        if (ret == 0)\n+            return(0);\n+        comp = comp->next;\n@@ -2556,4 +2425,4 @@\n-        return(-1);\n-    if (comp->flags & PAT_FROM_ROOT)\n-        return(1);\n-    comp = comp->next;\n+            return(-1);\n+        if (comp->flags & PAT_FROM_ROOT)\n+            return(1);\n+        comp = comp->next;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/pattern.c","additions":1194,"deletions":1325,"binary":false,"changes":2519,"status":"modified"},{"patch":"@@ -14,0 +14,1 @@\n+#include <stdarg.h>\n@@ -21,0 +22,3 @@\n+#ifdef LIBXML_RELAXNG_ENABLED\n+#include <libxml\/relaxng.h>\n+#endif\n@@ -23,1 +27,0 @@\n-#include <libxml\/relaxng.h>\n@@ -30,0 +33,1 @@\n+#include \"private\/cata.h\"\n@@ -32,0 +36,1 @@\n+#include \"private\/error.h\"\n@@ -38,59 +43,0 @@\n-#if defined(HAVE_POSIX_THREADS) && \\\n-    defined(__GLIBC__) && \\\n-    __GLIBC__ * 100 + __GLIBC_MINOR__ >= 234\n-\n-\/*\n- * The modern way available since glibc 2.32.\n- *\n- * The check above is for glibc 2.34 which merged the pthread symbols into\n- * libc. Since we still allow linking without pthread symbols (see below),\n- * this only works if pthread symbols are guaranteed to be available.\n- *\/\n-\n-#include <sys\/single_threaded.h>\n-\n-#define XML_IS_THREADED() (!__libc_single_threaded)\n-#define XML_IS_NEVER_THREADED() 0\n-\n-#elif defined(HAVE_POSIX_THREADS) && \\\n-      defined(__GLIBC__) && \\\n-      defined(__GNUC__)\n-\n-\/*\n- * The traditional way to check for single-threaded applications with\n- * glibc was to check whether the separate libpthread library is\n- * linked in. This works by not linking libxml2 with libpthread (see\n- * BASE_THREAD_LIBS in configure.ac and Makefile.am) and declaring\n- * pthread functions as weak symbols.\n- *\n- * In glibc 2.34, the pthread symbols were moved from libpthread to libc,\n- * so this doesn't work anymore.\n- *\n- * At some point, this legacy code and the BASE_THREAD_LIBS hack in\n- * configure.ac can probably be removed.\n- *\/\n-\n-#pragma weak pthread_mutex_init\n-#pragma weak pthread_mutex_destroy\n-#pragma weak pthread_mutex_lock\n-#pragma weak pthread_mutex_unlock\n-#pragma weak pthread_cond_init\n-#pragma weak pthread_cond_destroy\n-#pragma weak pthread_cond_wait\n-#pragma weak pthread_equal\n-#pragma weak pthread_self\n-#pragma weak pthread_cond_signal\n-\n-#define XML_PTHREAD_WEAK\n-#define XML_IS_THREADED() libxml_is_threaded\n-#define XML_IS_NEVER_THREADED() (!libxml_is_threaded)\n-\n-static int libxml_is_threaded = -1;\n-\n-#else \/* other POSIX platforms *\/\n-\n-#define XML_IS_THREADED() 1\n-#define XML_IS_NEVER_THREADED() 0\n-\n-#endif\n-\n@@ -103,18 +49,1 @@\n-\/*\n- * xmlRMutex are reentrant mutual exception locks\n- *\/\n-struct _xmlRMutex {\n-#ifdef HAVE_POSIX_THREADS\n-    pthread_mutex_t lock;\n-    unsigned int held;\n-    unsigned int waiters;\n-    pthread_t tid;\n-    pthread_cond_t cv;\n-#elif defined HAVE_WIN32_THREADS\n-    CRITICAL_SECTION cs;\n-#else\n-    int empty;\n-#endif\n-};\n-\n-static xmlRMutexPtr xmlLibraryLock = NULL;\n+static xmlRMutex xmlLibraryLock;\n@@ -132,2 +61,1 @@\n-    if (XML_IS_NEVER_THREADED() == 0)\n-        pthread_mutex_init(&mutex->lock, NULL);\n+    pthread_mutex_init(&mutex->lock, NULL);\n@@ -154,1 +82,2 @@\n-    if ((tok = malloc(sizeof(xmlMutex))) == NULL)\n+    tok = malloc(sizeof(xmlMutex));\n+    if (tok == NULL)\n@@ -170,2 +99,1 @@\n-    if (XML_IS_NEVER_THREADED() == 0)\n-        pthread_mutex_destroy(&mutex->lock);\n+    pthread_mutex_destroy(&mutex->lock);\n@@ -211,2 +139,1 @@\n-    if (XML_IS_THREADED() != 0)\n-        pthread_mutex_lock(&tok->lock);\n+    pthread_mutex_lock(&tok->lock);\n@@ -231,2 +158,1 @@\n-    if (XML_IS_THREADED() != 0)\n-        pthread_mutex_unlock(&tok->lock);\n+    pthread_mutex_unlock(&tok->lock);\n@@ -238,0 +164,20 @@\n+\/**\n+ * xmlInitRMutex:\n+ * @tok:  mutex\n+ *\n+ * Initialize the mutex.\n+ *\/\n+void\n+xmlInitRMutex(xmlRMutexPtr tok) {\n+    (void) tok;\n+\n+#ifdef HAVE_POSIX_THREADS\n+    pthread_mutex_init(&tok->lock, NULL);\n+    tok->held = 0;\n+    tok->waiters = 0;\n+    pthread_cond_init(&tok->cv, NULL);\n+#elif defined HAVE_WIN32_THREADS\n+    InitializeCriticalSection(&tok->cs);\n+#endif\n+}\n+\n@@ -253,1 +199,2 @@\n-    if ((tok = malloc(sizeof(xmlRMutex))) == NULL)\n+    tok = malloc(sizeof(xmlRMutex));\n+    if (tok == NULL)\n@@ -255,0 +202,14 @@\n+    xmlInitRMutex(tok);\n+    return (tok);\n+}\n+\n+\/**\n+ * xmlCleanupRMutex:\n+ * @tok:  mutex\n+ *\n+ * Cleanup the mutex.\n+ *\/\n+void\n+xmlCleanupRMutex(xmlRMutexPtr tok) {\n+    (void) tok;\n+\n@@ -256,6 +217,2 @@\n-    if (XML_IS_NEVER_THREADED() == 0) {\n-        pthread_mutex_init(&tok->lock, NULL);\n-        tok->held = 0;\n-        tok->waiters = 0;\n-        pthread_cond_init(&tok->cv, NULL);\n-    }\n+    pthread_mutex_destroy(&tok->lock);\n+    pthread_cond_destroy(&tok->cv);\n@@ -263,1 +220,1 @@\n-    InitializeCriticalSection(&tok->cs);\n+    DeleteCriticalSection(&tok->cs);\n@@ -265,1 +222,0 @@\n-    return (tok);\n@@ -276,1 +232,1 @@\n-xmlFreeRMutex(xmlRMutexPtr tok ATTRIBUTE_UNUSED)\n+xmlFreeRMutex(xmlRMutexPtr tok)\n@@ -280,8 +236,1 @@\n-#ifdef HAVE_POSIX_THREADS\n-    if (XML_IS_NEVER_THREADED() == 0) {\n-        pthread_mutex_destroy(&tok->lock);\n-        pthread_cond_destroy(&tok->cv);\n-    }\n-#elif defined HAVE_WIN32_THREADS\n-    DeleteCriticalSection(&tok->cs);\n-#endif\n+    xmlCleanupRMutex(tok);\n@@ -303,3 +252,0 @@\n-    if (XML_IS_THREADED() == 0)\n-        return;\n-\n@@ -339,3 +285,0 @@\n-    if (XML_IS_THREADED() == 0)\n-        return;\n-\n@@ -356,3 +299,3 @@\n- *                                    *\n- *            Library wide thread interfaces            *\n- *                                    *\n+ *                                                                      *\n+ *                      Library wide thread interfaces                  *\n+ *                                                                      *\n@@ -361,31 +304,0 @@\n-\/**\n- * xmlGetThreadId:\n- *\n- * DEPRECATED: Internal function, do not use.\n- *\n- * xmlGetThreadId() find the current thread ID number\n- * Note that this is likely to be broken on some platforms using pthreads\n- * as the specification doesn't mandate pthread_t to be an integer type\n- *\n- * Returns the current thread ID number\n- *\/\n-int\n-xmlGetThreadId(void)\n-{\n-#ifdef HAVE_POSIX_THREADS\n-    pthread_t id;\n-    int ret;\n-\n-    if (XML_IS_THREADED() == 0)\n-        return (0);\n-    id = pthread_self();\n-    \/* horrible but preserves compat, see warning above *\/\n-    memcpy(&ret, &id, sizeof(ret));\n-    return (ret);\n-#elif defined HAVE_WIN32_THREADS\n-    return GetCurrentThreadId();\n-#else\n-    return ((int) 0);\n-#endif\n-}\n-\n@@ -401,1 +313,1 @@\n-    xmlRMutexLock(xmlLibraryLock);\n+    xmlRMutexLock(&xmlLibraryLock);\n@@ -413,1 +325,1 @@\n-    xmlRMutexUnlock(xmlLibraryLock);\n+    xmlRMutexUnlock(&xmlLibraryLock);\n@@ -440,0 +352,10 @@\n+static void\n+xmlInitThreadsInternal(void) {\n+    xmlInitRMutex(&xmlLibraryLock);\n+}\n+\n+static void\n+xmlCleanupThreadsInternal(void) {\n+    xmlCleanupRMutex(&xmlLibraryLock);\n+}\n+\n@@ -441,3 +363,3 @@\n- *                                    *\n- *            Library wide initialization            *\n- *                                    *\n+ *                                                                      *\n+ *                      Library wide initialization                     *\n+ *                                                                      *\n@@ -447,2 +369,0 @@\n-static int xmlParserInnerInitialized = 0;\n-\n@@ -451,1 +371,1 @@\n-static pthread_mutex_t global_init_lock = PTHREAD_MUTEX_INITIALIZER;\n+static pthread_once_t onceControl = PTHREAD_ONCE_INIT;\n@@ -453,1 +373,3 @@\n-static volatile LPCRITICAL_SECTION global_init_lock = NULL;\n+static INIT_ONCE onceControl = INIT_ONCE_STATIC_INIT;\n+#else\n+static int onceControl = 0;\n@@ -456,6 +378,0 @@\n-\/**\n- * xmlGlobalInitMutexLock\n- *\n- * Makes sure that the global initialization mutex is initialized and\n- * locks it.\n- *\/\n@@ -463,4 +379,1 @@\n-xmlGlobalInitMutexLock(void) {\n-#ifdef HAVE_POSIX_THREADS\n-\n-#ifdef XML_PTHREAD_WEAK\n+xmlInitParserInternal(void) {\n@@ -468,3 +381,1 @@\n-     * This is somewhat unreliable since libpthread could be loaded\n-     * later with dlopen() and threads could be created. But it's\n-     * long-standing behavior and hard to work around.\n+     * Note that the initialization code must not make memory allocations.\n@@ -472,16 +383,8 @@\n-    if (libxml_is_threaded == -1)\n-        libxml_is_threaded =\n-            (pthread_mutex_init != NULL) &&\n-            (pthread_mutex_destroy != NULL) &&\n-            (pthread_mutex_lock != NULL) &&\n-            (pthread_mutex_unlock != NULL) &&\n-            (pthread_cond_init != NULL) &&\n-            (pthread_cond_destroy != NULL) &&\n-            (pthread_cond_wait != NULL) &&\n-            \/*\n-             * pthread_equal can be inline, resuting in -Waddress warnings.\n-             * Let's assume it's available if all the other functions are.\n-             *\/\n-            \/* (pthread_equal != NULL) && *\/\n-            (pthread_self != NULL) &&\n-            (pthread_cond_signal != NULL);\n+    xmlInitRandom(); \/* Required by xmlInitGlobalsInternal *\/\n+    xmlInitMemoryInternal();\n+    xmlInitThreadsInternal();\n+    xmlInitGlobalsInternal();\n+    xmlInitDictInternal();\n+    xmlInitEncodingInternal();\n+#if defined(LIBXML_XPATH_ENABLED)\n+    xmlInitXPathInternal();\n@@ -489,39 +392,3 @@\n-\n-    \/* The mutex is statically initialized, so we just lock it. *\/\n-    if (XML_IS_THREADED() != 0)\n-        pthread_mutex_lock(&global_init_lock);\n-\n-#elif defined HAVE_WIN32_THREADS\n-\n-    LPCRITICAL_SECTION cs;\n-\n-    \/* Create a new critical section *\/\n-    if (global_init_lock == NULL) {\n-        cs = malloc(sizeof(CRITICAL_SECTION));\n-        if (cs == NULL) {\n-            fprintf(stderr, \"libxml2: xmlInitParser: out of memory\\n\");\n-            abort();\n-        }\n-        InitializeCriticalSection(cs);\n-\n-        \/* Swap it into the global_init_lock *\/\n-#ifdef InterlockedCompareExchangePointer\n-        InterlockedCompareExchangePointer((void **) &global_init_lock,\n-                                          cs, NULL);\n-#else \/* Use older void* version *\/\n-        InterlockedCompareExchange((void **) &global_init_lock,\n-                                   (void *) cs, NULL);\n-#endif \/* InterlockedCompareExchangePointer *\/\n-\n-        \/* If another thread successfully recorded its critical\n-         * section in the global_init_lock then discard the one\n-         * allocated by this thread. *\/\n-        if (global_init_lock != cs) {\n-            DeleteCriticalSection(cs);\n-            free(cs);\n-        }\n-    }\n-\n-    \/* Lock the chosen critical section *\/\n-    EnterCriticalSection(global_init_lock);\n-\n+    xmlInitIOCallbacks();\n+#ifdef LIBXML_CATALOG_ENABLED\n+    xmlInitCatalogInternal();\n@@ -529,1 +396,0 @@\n-}\n@@ -531,9 +397,1 @@\n-static void\n-xmlGlobalInitMutexUnlock(void) {\n-#ifdef HAVE_POSIX_THREADS\n-    if (XML_IS_THREADED() != 0)\n-        pthread_mutex_unlock(&global_init_lock);\n-#elif defined HAVE_WIN32_THREADS\n-    if (global_init_lock != NULL)\n-    LeaveCriticalSection(global_init_lock);\n-#endif\n+    xmlParserInitialized = 1;\n@@ -542,16 +400,7 @@\n-\/**\n- * xmlGlobalInitMutexDestroy\n- *\n- * Makes sure that the global initialization mutex is destroyed before\n- * application termination.\n- *\/\n-static void\n-xmlGlobalInitMutexDestroy(void) {\n-#ifdef HAVE_POSIX_THREADS\n-#elif defined HAVE_WIN32_THREADS\n-    if (global_init_lock != NULL) {\n-        DeleteCriticalSection(global_init_lock);\n-        free(global_init_lock);\n-        global_init_lock = NULL;\n-    }\n-#endif\n+#if defined(HAVE_WIN32_THREADS)\n+static BOOL WINAPI\n+xmlInitParserWinWrapper(INIT_ONCE *initOnce ATTRIBUTE_UNUSED,\n+                        void *parameter ATTRIBUTE_UNUSED,\n+                        void **context ATTRIBUTE_UNUSED) {\n+    xmlInitParserInternal();\n+    return(TRUE);\n@@ -559,0 +408,1 @@\n+#endif\n@@ -565,2 +415,6 @@\n- * Call once from the main thread before using the library in\n- * multithreaded programs.\n+ * For older versions, it's recommended to call this function once\n+ * from the main thread before using the library in multithreaded\n+ * programs.\n+ *\n+ * Since 2.14.0, there's no distinction between threads. It should\n+ * be unnecessary to call this function.\n@@ -570,27 +424,8 @@\n-    \/*\n-     * Note that the initialization code must not make memory allocations.\n-     *\/\n-    if (xmlParserInitialized != 0)\n-        return;\n-\n-    xmlGlobalInitMutexLock();\n-\n-    if (xmlParserInnerInitialized == 0) {\n-#if defined(_WIN32) && \\\n-    !defined(LIBXML_THREAD_ALLOC_ENABLED) && \\\n-    (!defined(LIBXML_STATIC) || defined(LIBXML_STATIC_FOR_DLL))\n-        if (xmlFree == free)\n-            atexit(xmlCleanupParser);\n-#endif\n-\n-        xmlInitRandom(); \/* Required by xmlInitGlobalsInternal *\/\n-        xmlInitMemoryInternal();\n-        xmlInitGlobalsInternal();\n-        xmlInitDictInternal();\n-        xmlInitEncodingInternal();\n-#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n-        xmlInitXPathInternal();\n-#endif\n-        xmlInitIOCallbacks();\n-\n-        xmlParserInnerInitialized = 1;\n+#ifdef HAVE_POSIX_THREADS\n+    pthread_once(&onceControl, xmlInitParserInternal);\n+#elif defined(HAVE_WIN32_THREADS)\n+    InitOnceExecuteOnce(&onceControl, xmlInitParserWinWrapper, NULL, NULL);\n+#else\n+    if (onceControl == 0) {\n+        xmlInitParserInternal();\n+        onceControl = 1;\n@@ -598,4 +433,1 @@\n-\n-    xmlGlobalInitMutexUnlock();\n-\n-    xmlParserInitialized = 1;\n+#endif\n@@ -607,9 +439,7 @@\n- * This function name is somewhat misleading. It does not clean up\n- * parser state, it cleans up memory allocated by the library itself.\n- * It is a cleanup function for the XML library. It tries to reclaim all\n- * related global memory allocated for the library processing.\n- * It doesn't deallocate any document related memory. One should\n- * call xmlCleanupParser() only when the process has finished using\n- * the library and all XML\/HTML documents built with it.\n- * See also xmlInitParser() which has the opposite function of preparing\n- * the library for operations.\n+ * This function is named somewhat misleadingly. It does not clean up\n+ * parser state but global memory allocated by the library itself.\n+ *\n+ * Since 2.9.11, cleanup is performed automatically if a shared or\n+ * dynamic libxml2 library is unloaded. This function should only\n+ * be used to avoid false positives from memory leak checkers in\n+ * static builds.\n@@ -617,7 +447,4 @@\n- * WARNING: if your application is multithreaded or has plugin support\n- *          calling this may crash the application if another thread or\n- *          a plugin is still using libxml2. It's sometimes very hard to\n- *          guess if libxml2 is in use in the application, some libraries\n- *          or plugins may use it without notice. In case of doubt abstain\n- *          from calling this function or do it just before calling exit()\n- *          to avoid leak reports from valgrind !\n+ * WARNING: xmlCleanupParser assumes that all other threads that called\n+ * libxml2 functions have terminated. No library calls must be made\n+ * after calling this function. In general, THIS FUNCTION SHOULD ONLY\n+ * BE CALLED RIGHT BEFORE THE WHOLE PROCESS EXITS.\n@@ -627,0 +454,6 @@\n+    \/*\n+     * Unfortunately, some users call this function to fix memory\n+     * leaks on unload with versions before 2.9.11. This can result\n+     * in the library being reinitialized, so this use case must\n+     * be supported.\n+     *\/\n@@ -630,2 +463,0 @@\n-    \/* These functions can call xmlFree. *\/\n-\n@@ -635,0 +466,1 @@\n+    xmlCleanupCatalogInternal();\n@@ -638,0 +470,2 @@\n+#endif\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -641,2 +475,0 @@\n-    \/* These functions should never call xmlFree. *\/\n-\n@@ -646,0 +478,2 @@\n+    xmlCleanupThreadsInternal();\n+\n@@ -647,2 +481,2 @@\n-     * Must come last. On Windows, xmlCleanupGlobalsInternal can call\n-     * xmlFree which uses xmlMemMutex in debug mode.\n+     * Must come after all cleanup functions that call xmlFree which\n+     * uses xmlMemMutex in debug mode.\n@@ -652,2 +486,0 @@\n-    xmlGlobalInitMutexDestroy();\n-\n@@ -655,1 +487,17 @@\n-    xmlParserInnerInitialized = 0;\n+\n+    \/*\n+     * This is a bit sketchy but should make reinitialization work.\n+     *\/\n+#ifdef HAVE_POSIX_THREADS\n+    {\n+        pthread_once_t tmp = PTHREAD_ONCE_INIT;\n+        memcpy(&onceControl, &tmp, sizeof(tmp));\n+    }\n+#elif defined(HAVE_WIN32_THREADS)\n+    {\n+        INIT_ONCE tmp = INIT_ONCE_STATIC_INIT;\n+        memcpy(&onceControl, &tmp, sizeof(tmp));\n+    }\n+#else\n+    onceControl = 0;\n+#endif\n@@ -658,1 +506,1 @@\n-#if defined(HAVE_ATTRIBUTE_DESTRUCTOR) && \\\n+#if defined(HAVE_FUNC_ATTRIBUTE_DESTRUCTOR) && \\\n@@ -673,1 +521,0 @@\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/threads.c","additions":155,"deletions":308,"binary":false,"changes":463,"status":"modified"},{"patch":"@@ -172,0 +172,1 @@\n+XML_HIDDEN\n@@ -173,0 +174,1 @@\n+XML_HIDDEN\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/timsort.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,3 +41,0 @@\n-#ifdef LIBXML_DEBUG_ENABLED\n-#include <libxml\/debugXML.h>\n-#endif\n@@ -48,0 +45,1 @@\n+#include \"private\/memory.h\"\n@@ -50,1 +48,10 @@\n-int __xmlRegisterCallbacks = 0;\n+#ifndef SIZE_MAX\n+  #define SIZE_MAX ((size_t) -1)\n+#endif\n+\n+\/*\n+ * Internal variable indicating whether a callback has been registered\n+ * for node creation\/destruction. This avoids looking up thread-local\n+ * data if no callback was ever registered.\n+ *\/\n+int xmlRegisterCallbacks = 0;\n@@ -53,3 +60,3 @@\n- *                                    *\n- *        Forward declarations                    *\n- *                                    *\n+ *                                                                      *\n+ *              Forward declarations                                    *\n+ *                                                                      *\n@@ -66,1 +73,1 @@\n-               const xmlChar *nsName, int useDTD);\n+                       const xmlChar *nsName, int useDTD);\n@@ -77,3 +84,3 @@\n- *                                    *\n- *        A few static variables and macros            *\n- *                                    *\n+ *                                                                      *\n+ *              A few static variables and macros                       *\n+ *                                                                      *\n@@ -95,4 +102,4 @@\n- *                                    *\n- *        Functions to move to entities.c once the        *\n- *        API freeze is smoothen and they can be made public.    *\n- *                                    *\n+ *                                                                      *\n+ *              Functions to move to entities.c once the                *\n+ *              API freeze is smoothen and they can be made public.     *\n+ *                                                                      *\n@@ -102,1 +109,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -118,3 +124,3 @@\n-    table = (xmlEntitiesTablePtr) dtd->entities;\n-    return((xmlEntityPtr) xmlHashLookup(table, name));\n-    \/* return(xmlGetEntityFromTable(table, name)); *\/\n+        table = (xmlEntitiesTablePtr) dtd->entities;\n+        return((xmlEntityPtr) xmlHashLookup(table, name));\n+        \/* return(xmlGetEntityFromTable(table, name)); *\/\n@@ -139,3 +145,3 @@\n-    table = (xmlEntitiesTablePtr) dtd->pentities;\n-    return((xmlEntityPtr) xmlHashLookup(table, name));\n-    \/* return(xmlGetEntityFromTable(table, name)); *\/\n+        table = (xmlEntitiesTablePtr) dtd->pentities;\n+        return((xmlEntityPtr) xmlHashLookup(table, name));\n+        \/* return(xmlGetEntityFromTable(table, name)); *\/\n@@ -145,1 +151,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -148,3 +153,3 @@\n- *                                    *\n- *            QName handling helper                *\n- *                                    *\n+ *                                                                      *\n+ *                      QName handling helper                           *\n+ *                                                                      *\n@@ -169,2 +174,2 @@\n-          xmlChar *memory, int len) {\n-    int lenn, lenp;\n+              xmlChar *memory, int len) {\n+    size_t lenn, lenp;\n@@ -173,1 +178,1 @@\n-    if (ncname == NULL) return(NULL);\n+    if ((ncname == NULL) || (len < 0)) return(NULL);\n@@ -184,4 +189,1 @@\n-\n-    if ((memory == NULL) || (len < lenn + lenp + 2)) {\n-    ret = (xmlChar *) xmlMallocAtomic(lenn + lenp + 2);\n-    if (ret == NULL)\n+    if (lenn >= SIZE_MAX - lenp - 1)\n@@ -189,0 +191,5 @@\n+\n+    if ((memory == NULL) || ((size_t) len < lenn + lenp + 2)) {\n+        ret = xmlMalloc(lenn + lenp + 2);\n+        if (ret == NULL)\n+            return(NULL);\n@@ -190,1 +197,1 @@\n-    ret = memory;\n+        ret = memory;\n@@ -229,1 +236,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -236,1 +243,1 @@\n-    len++;\n+        len++;\n@@ -239,1 +246,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -243,1 +250,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -246,5 +253,5 @@\n-    if (*prefix != NULL) {\n-        xmlFree(*prefix);\n-        *prefix = NULL;\n-    }\n-    return(NULL);\n+        if (*prefix != NULL) {\n+            xmlFree(*prefix);\n+            *prefix = NULL;\n+        }\n+        return(NULL);\n@@ -277,1 +284,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -284,1 +291,1 @@\n-    l++;\n+        l++;\n@@ -287,1 +294,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -318,1 +325,1 @@\n-    return(name);\n+        return(name);\n@@ -325,1 +332,1 @@\n-    l++;\n+        l++;\n@@ -331,1 +338,1 @@\n-    return(name);\n+        return(name);\n@@ -342,3 +349,3 @@\n- *                                    *\n- *        Check Name, NCName and QName strings            *\n- *                                    *\n+ *                                                                      *\n+ *              Check Name, NCName and QName strings                    *\n+ *                                                                      *\n@@ -371,1 +378,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -373,2 +380,2 @@\n-    (*cur == '_'))\n-    cur++;\n+        (*cur == '_'))\n+        cur++;\n@@ -376,1 +383,1 @@\n-    goto try_complex;\n+        goto try_complex;\n@@ -378,4 +385,4 @@\n-       ((*cur >= 'A') && (*cur <= 'Z')) ||\n-       ((*cur >= '0') && (*cur <= '9')) ||\n-       (*cur == '_') || (*cur == '-') || (*cur == '.'))\n-    cur++;\n+           ((*cur >= 'A') && (*cur <= 'Z')) ||\n+           ((*cur >= '0') && (*cur <= '9')) ||\n+           (*cur == '_') || (*cur == '-') || (*cur == '.'))\n+        cur++;\n@@ -383,1 +390,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -385,1 +392,1 @@\n-    return(0);\n+        return(0);\n@@ -394,4 +401,4 @@\n-    while (IS_BLANK(c)) {\n-        cur += l;\n-        c = CUR_SCHAR(cur, l);\n-    }\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -400,1 +407,1 @@\n-    return(1);\n+        return(1);\n@@ -404,7 +411,2 @@\n-       (c == '-') || (c == '_') || IS_COMBINING(c) ||\n-       IS_EXTENDER(c)) {\n-    cur += l;\n-    c = CUR_SCHAR(cur, l);\n-    }\n-    if (space) {\n-    while (IS_BLANK(c)) {\n+           (c == '-') || (c == '_') || IS_COMBINING(c) ||\n+           IS_EXTENDER(c)) {\n@@ -414,0 +416,5 @@\n+    if (space) {\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -416,1 +423,1 @@\n-    return(1);\n+        return(1);\n@@ -421,1 +428,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n@@ -443,1 +449,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -445,13 +451,0 @@\n-    (*cur == '_'))\n-    cur++;\n-    else\n-    goto try_complex;\n-    while (((*cur >= 'a') && (*cur <= 'z')) ||\n-       ((*cur >= 'A') && (*cur <= 'Z')) ||\n-       ((*cur >= '0') && (*cur <= '9')) ||\n-       (*cur == '_') || (*cur == '-') || (*cur == '.'))\n-    cur++;\n-    if (*cur == ':') {\n-    cur++;\n-    if (((*cur >= 'a') && (*cur <= 'z')) ||\n-        ((*cur >= 'A') && (*cur <= 'Z')) ||\n@@ -467,0 +460,13 @@\n+    if (*cur == ':') {\n+        cur++;\n+        if (((*cur >= 'a') && (*cur <= 'z')) ||\n+            ((*cur >= 'A') && (*cur <= 'Z')) ||\n+            (*cur == '_'))\n+            cur++;\n+        else\n+            goto try_complex;\n+        while (((*cur >= 'a') && (*cur <= 'z')) ||\n+               ((*cur >= 'A') && (*cur <= 'Z')) ||\n+               ((*cur >= '0') && (*cur <= '9')) ||\n+               (*cur == '_') || (*cur == '-') || (*cur == '.'))\n+            cur++;\n@@ -469,1 +475,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -471,1 +477,1 @@\n-    return(0);\n+        return(0);\n@@ -480,14 +486,4 @@\n-    while (IS_BLANK(c)) {\n-        cur += l;\n-        c = CUR_SCHAR(cur, l);\n-    }\n-    }\n-    if ((!IS_LETTER(c)) && (c != '_'))\n-    return(1);\n-    cur += l;\n-    c = CUR_SCHAR(cur, l);\n-    while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||\n-       (c == '-') || (c == '_') || IS_COMBINING(c) ||\n-       IS_EXTENDER(c)) {\n-    cur += l;\n-    c = CUR_SCHAR(cur, l);\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -495,3 +491,0 @@\n-    if (c == ':') {\n-    cur += l;\n-    c = CUR_SCHAR(cur, l);\n@@ -508,3 +501,5 @@\n-    }\n-    if (space) {\n-    while (IS_BLANK(c)) {\n+    if (c == ':') {\n+        cur += l;\n+        c = CUR_SCHAR(cur, l);\n+        if ((!IS_LETTER(c)) && (c != '_'))\n+            return(1);\n@@ -513,0 +508,6 @@\n+        while (IS_LETTER(c) || IS_DIGIT(c) || (c == '.') ||\n+               (c == '-') || (c == '_') || IS_COMBINING(c) ||\n+               IS_EXTENDER(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -514,0 +515,5 @@\n+    if (space) {\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -516,1 +522,1 @@\n-    return(1);\n+        return(1);\n@@ -541,1 +547,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -543,2 +549,2 @@\n-    (*cur == '_') || (*cur == ':'))\n-    cur++;\n+        (*cur == '_') || (*cur == ':'))\n+        cur++;\n@@ -546,1 +552,1 @@\n-    goto try_complex;\n+        goto try_complex;\n@@ -548,4 +554,4 @@\n-       ((*cur >= 'A') && (*cur <= 'Z')) ||\n-       ((*cur >= '0') && (*cur <= '9')) ||\n-       (*cur == '_') || (*cur == '-') || (*cur == '.') || (*cur == ':'))\n-    cur++;\n+           ((*cur >= 'A') && (*cur <= 'Z')) ||\n+           ((*cur >= '0') && (*cur <= '9')) ||\n+           (*cur == '_') || (*cur == '-') || (*cur == '.') || (*cur == ':'))\n+        cur++;\n@@ -553,1 +559,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -555,1 +561,1 @@\n-    return(0);\n+        return(0);\n@@ -564,4 +570,4 @@\n-    while (IS_BLANK(c)) {\n-        cur += l;\n-        c = CUR_SCHAR(cur, l);\n-    }\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -570,1 +576,1 @@\n-    return(1);\n+        return(1);\n@@ -574,6 +580,1 @@\n-       (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)) {\n-    cur += l;\n-    c = CUR_SCHAR(cur, l);\n-    }\n-    if (space) {\n-    while (IS_BLANK(c)) {\n+           (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)) {\n@@ -583,0 +584,5 @@\n+    if (space) {\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -585,1 +591,1 @@\n-    return(1);\n+        return(1);\n@@ -610,1 +616,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -615,1 +621,1 @@\n-    cur++;\n+        cur++;\n@@ -617,1 +623,1 @@\n-    goto try_complex;\n+        goto try_complex;\n@@ -619,4 +625,4 @@\n-       ((*cur >= 'A') && (*cur <= 'Z')) ||\n-       ((*cur >= '0') && (*cur <= '9')) ||\n-       (*cur == '_') || (*cur == '-') || (*cur == '.') || (*cur == ':'))\n-    cur++;\n+           ((*cur >= 'A') && (*cur <= 'Z')) ||\n+           ((*cur >= '0') && (*cur <= '9')) ||\n+           (*cur == '_') || (*cur == '-') || (*cur == '.') || (*cur == ':'))\n+        cur++;\n@@ -624,1 +630,1 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n+        while (IS_BLANK_CH(*cur)) cur++;\n@@ -626,1 +632,1 @@\n-    return(0);\n+        return(0);\n@@ -635,4 +641,4 @@\n-    while (IS_BLANK(c)) {\n-        cur += l;\n-        c = CUR_SCHAR(cur, l);\n-    }\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -642,1 +648,1 @@\n-    return(1);\n+        return(1);\n@@ -646,6 +652,1 @@\n-       (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)) {\n-    cur += l;\n-    c = CUR_SCHAR(cur, l);\n-    }\n-    if (space) {\n-    while (IS_BLANK(c)) {\n+           (c == '-') || (c == '_') || IS_COMBINING(c) || IS_EXTENDER(c)) {\n@@ -655,0 +656,5 @@\n+    if (space) {\n+        while (IS_BLANK(c)) {\n+            cur += l;\n+            c = CUR_SCHAR(cur, l);\n+        }\n@@ -657,1 +663,1 @@\n-    return(1);\n+        return(1);\n@@ -660,1 +666,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -663,3 +668,3 @@\n- *                                    *\n- *        Allocation and deallocation of basic structures        *\n- *                                    *\n+ *                                                                      *\n+ *              Allocation and deallocation of basic structures         *\n+ *                                                                      *\n@@ -668,35 +673,0 @@\n-\/**\n- * xmlSetBufferAllocationScheme:\n- * @scheme:  allocation method to use\n- *\n- * Set the buffer allocation method.  Types are\n- * XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down\n- * XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed,\n- *                             improves performance\n- *\/\n-void\n-xmlSetBufferAllocationScheme(xmlBufferAllocationScheme scheme) {\n-    if ((scheme == XML_BUFFER_ALLOC_EXACT) ||\n-        (scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||\n-        (scheme == XML_BUFFER_ALLOC_HYBRID))\n-    xmlBufferAllocScheme = scheme;\n-}\n-\n-\/**\n- * xmlGetBufferAllocationScheme:\n- *\n- * Types are\n- * XML_BUFFER_ALLOC_EXACT - use exact sizes, keeps memory usage down\n- * XML_BUFFER_ALLOC_DOUBLEIT - double buffer when extra needed,\n- *                             improves performance\n- * XML_BUFFER_ALLOC_HYBRID - use exact sizes on small strings to keep memory usage tight\n- *                            in normal usage, and doubleit on large strings to avoid\n- *                            pathological performance.\n- *\n- * Returns the current allocation scheme\n- *\/\n-xmlBufferAllocationScheme\n-xmlGetBufferAllocationScheme(void) {\n-    return(xmlBufferAllocScheme);\n-}\n-\n@@ -726,1 +696,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -733,1 +703,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -738,1 +708,1 @@\n-    cur->href = xmlStrdup(href);\n+        cur->href = xmlStrdup(href);\n@@ -743,1 +713,1 @@\n-    cur->prefix = xmlStrdup(prefix);\n+        cur->prefix = xmlStrdup(prefix);\n@@ -753,4 +723,4 @@\n-    if (node->nsDef == NULL) {\n-        node->nsDef = cur;\n-    } else {\n-        xmlNsPtr prev = node->nsDef;\n+        if (node->nsDef == NULL) {\n+            node->nsDef = cur;\n+        } else {\n+            xmlNsPtr prev = node->nsDef;\n@@ -758,1 +728,1 @@\n-        if ((xmlStrEqual(prev->prefix, cur->prefix)) &&\n+            if ((xmlStrEqual(prev->prefix, cur->prefix)) &&\n@@ -761,3 +731,3 @@\n-        while (prev->next != NULL) {\n-            prev = prev->next;\n-        if ((xmlStrEqual(prev->prefix, cur->prefix)) &&\n+            while (prev->next != NULL) {\n+                prev = prev->next;\n+                if ((xmlStrEqual(prev->prefix, cur->prefix)) &&\n@@ -766,0 +736,2 @@\n+            }\n+            prev->next = cur;\n@@ -767,2 +739,0 @@\n-        prev->next = cur;\n-    }\n@@ -788,1 +758,1 @@\n-    return;\n+        return;\n@@ -792,1 +762,1 @@\n-    node->ns = ns;\n+        node->ns = ns;\n@@ -804,1 +774,1 @@\n-    return;\n+        return;\n@@ -821,1 +791,1 @@\n-    return;\n+        return;\n@@ -826,1 +796,1 @@\n-    cur = next;\n+        cur = next;\n@@ -854,1 +824,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -862,1 +832,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -867,1 +837,1 @@\n-    cur->name = xmlStrdup(name);\n+        cur->name = xmlStrdup(name);\n@@ -872,1 +842,1 @@\n-    cur->ExternalID = xmlStrdup(ExternalID);\n+        cur->ExternalID = xmlStrdup(ExternalID);\n@@ -877,1 +847,1 @@\n-    cur->SystemID = xmlStrdup(SystemID);\n+        cur->SystemID = xmlStrdup(SystemID);\n@@ -882,1 +852,1 @@\n-    doc->extSubset = cur;\n+        doc->extSubset = cur;\n@@ -885,2 +855,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -907,1 +877,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -910,3 +880,3 @@\n-    if (cur->type == XML_DTD_NODE)\n-        return((xmlDtdPtr) cur);\n-    cur = cur->next;\n+        if (cur->type == XML_DTD_NODE)\n+            return((xmlDtdPtr) cur);\n+        cur = cur->next;\n@@ -950,1 +920,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -955,2 +925,2 @@\n-    cur->name = xmlStrdup(name);\n-    if (cur->name == NULL)\n+        cur->name = xmlStrdup(name);\n+        if (cur->name == NULL)\n@@ -960,2 +930,2 @@\n-    cur->ExternalID = xmlStrdup(ExternalID);\n-    if (cur->ExternalID  == NULL)\n+        cur->ExternalID = xmlStrdup(ExternalID);\n+        if (cur->ExternalID  == NULL)\n@@ -965,2 +935,2 @@\n-    cur->SystemID = xmlStrdup(SystemID);\n-    if (cur->SystemID == NULL)\n+        cur->SystemID = xmlStrdup(SystemID);\n+        if (cur->SystemID == NULL)\n@@ -970,24 +940,5 @@\n-    doc->intSubset = cur;\n-    cur->parent = doc;\n-    cur->doc = doc;\n-    if (doc->children == NULL) {\n-        doc->children = (xmlNodePtr) cur;\n-        doc->last = (xmlNodePtr) cur;\n-    } else {\n-        if (doc->type == XML_HTML_DOCUMENT_NODE) {\n-        xmlNodePtr prev;\n-\n-        prev = doc->children;\n-        prev->prev = (xmlNodePtr) cur;\n-        cur->next = prev;\n-        doc->children = (xmlNodePtr) cur;\n-        } else {\n-        xmlNodePtr next;\n-\n-        next = doc->children;\n-        while ((next != NULL) && (next->type != XML_ELEMENT_NODE))\n-            next = next->next;\n-        if (next == NULL) {\n-            cur->prev = doc->last;\n-            cur->prev->next = (xmlNodePtr) cur;\n-            cur->next = NULL;\n+        doc->intSubset = cur;\n+        cur->parent = doc;\n+        cur->doc = doc;\n+        if (doc->children == NULL) {\n+            doc->children = (xmlNodePtr) cur;\n@@ -996,8 +947,28 @@\n-            cur->next = next;\n-            cur->prev = next->prev;\n-            if (cur->prev == NULL)\n-            doc->children = (xmlNodePtr) cur;\n-            else\n-            cur->prev->next = (xmlNodePtr) cur;\n-            next->prev = (xmlNodePtr) cur;\n-        }\n+            if (doc->type == XML_HTML_DOCUMENT_NODE) {\n+                xmlNodePtr prev;\n+\n+                prev = doc->children;\n+                prev->prev = (xmlNodePtr) cur;\n+                cur->next = prev;\n+                doc->children = (xmlNodePtr) cur;\n+            } else {\n+                xmlNodePtr next;\n+\n+                next = doc->children;\n+                while ((next != NULL) && (next->type != XML_ELEMENT_NODE))\n+                    next = next->next;\n+                if (next == NULL) {\n+                    cur->prev = doc->last;\n+                    cur->prev->next = (xmlNodePtr) cur;\n+                    cur->next = NULL;\n+                    doc->last = (xmlNodePtr) cur;\n+                } else {\n+                    cur->next = next;\n+                    cur->prev = next->prev;\n+                    if (cur->prev == NULL)\n+                        doc->children = (xmlNodePtr) cur;\n+                    else\n+                        cur->prev->next = (xmlNodePtr) cur;\n+                    next->prev = (xmlNodePtr) cur;\n+                }\n+            }\n@@ -1006,1 +977,0 @@\n-    }\n@@ -1008,2 +978,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -1024,4 +994,4 @@\n-#define DICT_FREE(str)                        \\\n-    if ((str) && ((!dict) ||                \\\n-        (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))    \\\n-        xmlFree((char *)(str));\n+#define DICT_FREE(str)                                          \\\n+        if ((str) && ((!dict) ||                                \\\n+            (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n+            xmlFree((char *)(str));\n@@ -1040,1 +1010,1 @@\n-    return;\n+        return;\n@@ -1044,2 +1014,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n-    xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n+    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n+        xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -1048,1 +1018,1 @@\n-    xmlNodePtr next, c = cur->children;\n+        xmlNodePtr next, c = cur->children;\n@@ -1050,4 +1020,4 @@\n-    \/*\n-     * Cleanup all nodes which are not part of the specific lists\n-     * of notations, elements, attributes and entities.\n-     *\/\n+        \/*\n+         * Cleanup all nodes which are not part of the specific lists\n+         * of notations, elements, attributes and entities.\n+         *\/\n@@ -1055,6 +1025,8 @@\n-        next = c->next;\n-        if ((c->type != XML_ELEMENT_DECL) &&\n-        (c->type != XML_ATTRIBUTE_DECL) &&\n-        (c->type != XML_ENTITY_DECL)) {\n-        xmlUnlinkNodeInternal(c);\n-        xmlFreeNode(c);\n+            next = c->next;\n+            if ((c->type != XML_ELEMENT_DECL) &&\n+                (c->type != XML_ATTRIBUTE_DECL) &&\n+                (c->type != XML_ENTITY_DECL)) {\n+                xmlUnlinkNodeInternal(c);\n+                xmlFreeNode(c);\n+            }\n+            c = next;\n@@ -1062,2 +1034,0 @@\n-        c = next;\n-    }\n@@ -1097,1 +1067,1 @@\n-    version = (const xmlChar *) \"1.0\";\n+        version = (const xmlChar *) \"1.0\";\n@@ -1104,1 +1074,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1110,2 +1080,2 @@\n-    xmlFree(cur);\n-    return(NULL);\n+        xmlFree(cur);\n+        return(NULL);\n@@ -1125,2 +1095,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -1142,1 +1112,1 @@\n-    return;\n+        return;\n@@ -1147,2 +1117,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n-    xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n+    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n+        xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -1160,1 +1130,1 @@\n-    extSubset = NULL;\n+        extSubset = NULL;\n@@ -1162,3 +1132,3 @@\n-    xmlUnlinkNodeInternal((xmlNodePtr) cur->extSubset);\n-    cur->extSubset = NULL;\n-    xmlFreeDtd(extSubset);\n+        xmlUnlinkNodeInternal((xmlNodePtr) cur->extSubset);\n+        cur->extSubset = NULL;\n+        xmlFreeDtd(extSubset);\n@@ -1167,3 +1137,3 @@\n-    xmlUnlinkNodeInternal((xmlNodePtr) cur->intSubset);\n-    cur->intSubset = NULL;\n-    xmlFreeDtd(intSubset);\n+        xmlUnlinkNodeInternal((xmlNodePtr) cur->intSubset);\n+        cur->intSubset = NULL;\n+        xmlFreeDtd(intSubset);\n@@ -1221,1 +1191,1 @@\n-    buf = xmlBufCreateSize(64);\n+    buf = xmlBufCreate(50);\n@@ -1224,1 +1194,0 @@\n-    xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);\n@@ -1228,2 +1197,2 @@\n-    if (cur[0] == '&') {\n-        int charval = 0;\n+        if (cur[0] == '&') {\n+            int charval = 0;\n@@ -1231,3 +1200,3 @@\n-        \/*\n-         * Save the current text.\n-         *\/\n+            \/*\n+             * Save the current text.\n+             *\/\n@@ -1235,4 +1204,4 @@\n-        if (xmlBufAdd(buf, q, cur - q))\n-            goto out;\n-            q = cur;\n-        }\n+                if (xmlBufAdd(buf, q, cur - q))\n+                    goto out;\n+                q = cur;\n+            }\n@@ -1240,2 +1209,2 @@\n-        if ((remaining > 2) && (cur[1] == '#') && (cur[2] == 'x')) {\n-            int tmp = 0;\n+            if ((remaining > 2) && (cur[1] == '#') && (cur[2] == 'x')) {\n+                int tmp = 0;\n@@ -1243,1 +1212,1 @@\n-        cur += 3;\n+                cur += 3;\n@@ -1245,11 +1214,11 @@\n-        while ((remaining > 0) && ((tmp = *cur) != ';')) {\n-            if ((tmp >= '0') && (tmp <= '9'))\n-            charval = charval * 16 + (tmp - '0');\n-            else if ((tmp >= 'a') && (tmp <= 'f'))\n-            charval = charval * 16 + (tmp - 'a') + 10;\n-            else if ((tmp >= 'A') && (tmp <= 'F'))\n-            charval = charval * 16 + (tmp - 'A') + 10;\n-            else {\n-            charval = 0;\n-            break;\n-            }\n+                while ((remaining > 0) && ((tmp = *cur) != ';')) {\n+                    if ((tmp >= '0') && (tmp <= '9'))\n+                        charval = charval * 16 + (tmp - '0');\n+                    else if ((tmp >= 'a') && (tmp <= 'f'))\n+                        charval = charval * 16 + (tmp - 'a') + 10;\n+                    else if ((tmp >= 'A') && (tmp <= 'F'))\n+                        charval = charval * 16 + (tmp - 'A') + 10;\n+                    else {\n+                        charval = 0;\n+                        break;\n+                    }\n@@ -1258,1 +1227,1 @@\n-            cur++;\n+                    cur++;\n@@ -1260,3 +1229,3 @@\n-        }\n-        if (tmp == ';') {\n-            cur++;\n+                }\n+                if (tmp == ';') {\n+                    cur++;\n@@ -1265,3 +1234,3 @@\n-        q = cur;\n-        } else if ((remaining > 1) && (cur[1] == '#')) {\n-            int tmp = 0;\n+                q = cur;\n+            } else if ((remaining > 1) && (cur[1] == '#')) {\n+                int tmp = 0;\n@@ -1269,1 +1238,1 @@\n-        cur += 2;\n+                cur += 2;\n@@ -1271,7 +1240,7 @@\n-        while ((remaining > 0) && ((tmp = *cur) != ';')) {\n-            if ((tmp >= '0') && (tmp <= '9'))\n-            charval = charval * 10 + (tmp - '0');\n-            else {\n-            charval = 0;\n-            break;\n-            }\n+                while ((remaining > 0) && ((tmp = *cur) != ';')) {\n+                    if ((tmp >= '0') && (tmp <= '9'))\n+                        charval = charval * 10 + (tmp - '0');\n+                    else {\n+                        charval = 0;\n+                        break;\n+                    }\n@@ -1280,1 +1249,1 @@\n-            cur++;\n+                    cur++;\n@@ -1282,3 +1251,3 @@\n-        }\n-        if (tmp == ';') {\n-            cur++;\n+                }\n+                if (tmp == ';') {\n+                    cur++;\n@@ -1287,6 +1256,6 @@\n-        q = cur;\n-        } else {\n-        \/*\n-         * Read the entity string\n-         *\/\n-        cur++;\n+                q = cur;\n+            } else {\n+                \/*\n+                 * Read the entity string\n+                 *\/\n+                cur++;\n@@ -1294,2 +1263,2 @@\n-        q = cur;\n-        while ((remaining > 0) && (*cur != 0) && (*cur != ';')) {\n+                q = cur;\n+                while ((remaining > 0) && (*cur != 0) && (*cur != ';')) {\n@@ -1299,4 +1268,4 @@\n-        if ((remaining <= 0) || (*cur == 0))\n-            break;\n-        if (cur != q) {\n-            val = xmlStrndup(q, cur - q);\n+                if ((remaining <= 0) || (*cur == 0))\n+                    break;\n+                if (cur != q) {\n+                    val = xmlStrndup(q, cur - q);\n@@ -1305,3 +1274,3 @@\n-            ent = xmlGetDocEntity(doc, val);\n-            if ((ent != NULL) &&\n-            (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n+                    ent = xmlGetDocEntity(doc, val);\n+                    if ((ent != NULL) &&\n+                        (ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {\n@@ -1311,11 +1280,11 @@\n-            if (xmlBufCat(buf, ent->content))\n-                goto out;\n-            } else {\n-            \/*\n-             * Flush buffer so far\n-             *\/\n-            if (!xmlBufIsEmpty(buf)) {\n-                node = xmlNewDocText(doc, NULL);\n-                if (node == NULL)\n-                goto out;\n-                node->content = xmlBufDetach(buf);\n+                        if (xmlBufCat(buf, ent->content))\n+                            goto out;\n+                    } else {\n+                        \/*\n+                         * Flush buffer so far\n+                         *\/\n+                        if (!xmlBufIsEmpty(buf)) {\n+                            node = xmlNewDocText(doc, NULL);\n+                            if (node == NULL)\n+                                goto out;\n+                            node->content = xmlBufDetach(buf);\n@@ -1324,3 +1293,3 @@\n-                if (last == NULL) {\n-                head = node;\n-                } else {\n+                            if (last == NULL) {\n+                                head = node;\n+                            } else {\n@@ -1329,1 +1298,1 @@\n-                }\n+                            }\n@@ -1331,1 +1300,1 @@\n-            }\n+                        }\n@@ -1333,1 +1302,1 @@\n-            if ((ent != NULL) &&\n+                        if ((ent != NULL) &&\n@@ -1346,1 +1315,1 @@\n-            }\n+                        }\n@@ -1348,4 +1317,4 @@\n-            \/*\n-             * Create a new REFERENCE_REF node\n-             *\/\n-            node = xmlNewEntityRef((xmlDocPtr) doc, val);\n+                        \/*\n+                         * Create a new REFERENCE_REF node\n+                         *\/\n+                        node = xmlNewEntityRef((xmlDocPtr) doc, val);\n@@ -1353,2 +1322,2 @@\n-            if (node == NULL)\n-                goto out;\n+                        if (node == NULL)\n+                            goto out;\n@@ -1362,3 +1331,3 @@\n-            if (last == NULL) {\n-                head = node;\n-            } else {\n+                        if (last == NULL) {\n+                            head = node;\n+                        } else {\n@@ -1367,1 +1336,1 @@\n-            }\n+                        }\n@@ -1369,2 +1338,2 @@\n-            }\n-            xmlFree(val);\n+                    }\n+                    xmlFree(val);\n@@ -1372,2 +1341,2 @@\n-        }\n-        cur++;\n+                }\n+                cur++;\n@@ -1375,5 +1344,5 @@\n-        q = cur;\n-        }\n-        if (charval != 0) {\n-        xmlChar buffer[10];\n-        int l;\n+                q = cur;\n+            }\n+            if (charval != 0) {\n+                xmlChar buffer[10];\n+                int l;\n@@ -1384,2 +1353,2 @@\n-        l = xmlCopyCharMultiByte(buffer, charval);\n-        buffer[l] = 0;\n+                l = xmlCopyCharMultiByte(buffer, charval);\n+                buffer[l] = 0;\n@@ -1387,5 +1356,5 @@\n-        if (xmlBufCat(buf, buffer))\n-            goto out;\n-        }\n-    } else {\n-        cur++;\n+                if (xmlBufCat(buf, buffer))\n+                    goto out;\n+            }\n+        } else {\n+            cur++;\n@@ -1398,4 +1367,4 @@\n-     * Handle the last piece of text.\n-     *\/\n-    if (xmlBufAdd(buf, q, cur - q))\n-        goto out;\n+         * Handle the last piece of text.\n+         *\/\n+        if (xmlBufAdd(buf, q, cur - q))\n+            goto out;\n@@ -1405,2 +1374,2 @@\n-    node = xmlNewDocText(doc, NULL);\n-    if (node == NULL)\n+        node = xmlNewDocText(doc, NULL);\n+        if (node == NULL)\n@@ -1409,1 +1378,1 @@\n-    node->content = xmlBufDetach(buf);\n+        node->content = xmlBufDetach(buf);\n@@ -1411,3 +1380,3 @@\n-    if (last == NULL) {\n-        head = node;\n-    } else {\n+        if (last == NULL) {\n+            head = node;\n+        } else {\n@@ -1416,1 +1385,1 @@\n-    }\n+        }\n@@ -1482,2 +1451,2 @@\n- * Returns a pointer to the first child or NULL if a memory\n- * allocation failed.\n+ * Returns a pointer to the first child or NULL if the value if empty\n+ * or a memory allocation failed.\n@@ -1509,2 +1478,2 @@\n- * Returns a pointer to the first child or NULL if a memory\n- * allocation failed.\n+ * Returns a pointer to the first child or NULL if the value if empty\n+ * or a memory allocation failed.\n@@ -1545,1 +1514,1 @@\n-    buf = xmlBufCreateSize(64);\n+    buf = xmlBufCreate(50);\n@@ -1559,2 +1528,2 @@\n-                        encoded = xmlEncodeEntitiesReentrant(doc,\n-                                                             node->content);\n+                        encoded = xmlEncodeEntitiesInternal(doc, node->content,\n+                                                            0);\n@@ -1562,2 +1531,2 @@\n-                        encoded = xmlEncodeAttributeEntities(doc,\n-                                                             node->content);\n+                        encoded = xmlEncodeEntitiesInternal(doc, node->content,\n+                                                            XML_ESCAPE_ATTR);\n@@ -1632,1 +1601,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -1659,1 +1627,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -1671,2 +1638,2 @@\n-        ((node->doc == NULL) || (node->doc->dict == NULL) ||\n-         (!(xmlDictOwns(node->doc->dict, name)))))\n+            ((node->doc == NULL) || (node->doc->dict == NULL) ||\n+             (!(xmlDictOwns(node->doc->dict, name)))))\n@@ -1683,1 +1650,1 @@\n-        ((node == NULL) || (node->doc == NULL) ||\n+            ((node == NULL) || (node->doc == NULL) ||\n@@ -1685,1 +1652,1 @@\n-         (!(xmlDictOwns(node->doc->dict, name)))))\n+             (!(xmlDictOwns(node->doc->dict, name)))))\n@@ -1750,1 +1717,1 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n@@ -1759,2 +1726,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \\\n-    defined(LIBXML_SCHEMAS_ENABLED)\n@@ -1782,1 +1747,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1785,1 +1750,1 @@\n-    return xmlNewPropInternal(node, NULL, name, value, 0);\n+        return xmlNewPropInternal(node, NULL, name, value, 0);\n@@ -1787,1 +1752,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -1812,1 +1776,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1837,1 +1801,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1864,1 +1828,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1872,1 +1836,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1877,1 +1841,1 @@\n-    cur->name = xmlDictLookup(doc->dict, name, -1);\n+        cur->name = xmlDictLookup(doc->dict, name, -1);\n@@ -1879,1 +1843,1 @@\n-    cur->name = xmlStrdup(name);\n+        cur->name = xmlStrdup(name);\n@@ -1884,1 +1848,1 @@\n-    if (xmlNodeParseContent((xmlNodePtr) cur, value, -1) < 0)\n+        if (xmlNodeParseContent((xmlNodePtr) cur, value, -1) < 0)\n@@ -1888,2 +1852,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -1910,1 +1874,1 @@\n-    cur = next;\n+        cur = next;\n@@ -1927,2 +1891,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n-    xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n+    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n+        xmlDeregisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -1932,1 +1896,1 @@\n-        xmlRemoveID(cur->doc, cur);\n+            xmlRemoveID(cur->doc, cur);\n@@ -1956,1 +1920,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1959,1 +1923,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1964,10 +1928,2 @@\n-        if (cur->next != NULL)\n-            cur->next->prev = NULL;\n-    xmlFreeProp(cur);\n-    return(0);\n-    }\n-    while (tmp != NULL) {\n-    if (tmp->next == cur) {\n-        tmp->next = cur->next;\n-        if (tmp->next != NULL)\n-        tmp->next->prev = tmp;\n+                if (cur->next != NULL)\n+                        cur->next->prev = NULL;\n@@ -1977,0 +1933,8 @@\n+    while (tmp != NULL) {\n+        if (tmp->next == cur) {\n+            tmp->next = cur->next;\n+            if (tmp->next != NULL)\n+                tmp->next->prev = tmp;\n+            xmlFreeProp(cur);\n+            return(0);\n+        }\n@@ -1998,1 +1962,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2006,1 +1970,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2014,1 +1978,1 @@\n-    cur->name = xmlStrdup(name);\n+        cur->name = xmlStrdup(name);\n@@ -2018,1 +1982,1 @@\n-    cur->content = xmlStrdup(content);\n+        cur->content = xmlStrdup(content);\n@@ -2023,2 +1987,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -2094,1 +2058,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2110,2 +2074,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)cur);\n@@ -2209,1 +2173,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -2232,1 +2195,1 @@\n-    if (content != NULL) {\n+        if (content != NULL) {\n@@ -2235,1 +2198,1 @@\n-        text = xmlNewDocText(doc, content);\n+            text = xmlNewDocText(doc, content);\n@@ -2244,1 +2207,1 @@\n-    }\n+        }\n@@ -2267,1 +2230,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2273,2 +2236,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue(cur);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2277,1 +2240,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -2299,1 +2261,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2305,1 +2267,1 @@\n-    cur->content = xmlStrdup(content);\n+        cur->content = xmlStrdup(content);\n@@ -2310,2 +2272,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue(cur);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2319,1 +2281,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -2344,1 +2305,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2371,1 +2332,1 @@\n-    parent->last = cur;\n+        parent->last = cur;\n@@ -2374,3 +2335,3 @@\n-    prev->next = cur;\n-    cur->prev = prev;\n-    parent->last = cur;\n+        prev->next = cur;\n+        cur->prev = prev;\n+        parent->last = cur;\n@@ -2381,1 +2342,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -2406,1 +2366,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2413,2 +2373,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue(cur);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2445,5 +2405,5 @@\n-    len = xmlStrlen(name);\n-    if (name[len - 1] == ';')\n-        copy = xmlStrndup(name, len - 1);\n-    else\n-        copy = xmlStrndup(name, len);\n+        len = xmlStrlen(name);\n+        if (name[len - 1] == ';')\n+            copy = xmlStrndup(name, len - 1);\n+        else\n+            copy = xmlStrndup(name, len);\n@@ -2451,1 +2411,1 @@\n-    copy = xmlStrdup(name);\n+        copy = xmlStrdup(name);\n@@ -2484,1 +2444,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2492,5 +2452,5 @@\n-    len = xmlStrlen(name);\n-    if (name[len - 1] == ';')\n-        cur->name = xmlStrndup(name, len - 1);\n-    else\n-        cur->name = xmlStrndup(name, len);\n+        len = xmlStrlen(name);\n+        if (name[len - 1] == ';')\n+            cur->name = xmlStrndup(name, len - 1);\n+        else\n+            cur->name = xmlStrndup(name, len);\n@@ -2498,1 +2458,1 @@\n-    cur->name = xmlStrdup(name);\n+        cur->name = xmlStrdup(name);\n@@ -2504,8 +2464,8 @@\n-    cur->content = ent->content;\n-    \/*\n-     * The parent pointer in entity is a DTD pointer and thus is NOT\n-     * updated.  Not sure if this is 100% correct.\n-     *  -George\n-     *\/\n-    cur->children = (xmlNodePtr) ent;\n-    cur->last = (xmlNodePtr) ent;\n+        cur->content = ent->content;\n+        \/*\n+         * The parent pointer in entity is a DTD pointer and thus is NOT\n+         * updated.  Not sure if this is 100% correct.\n+         *  -George\n+         *\/\n+        cur->children = (xmlNodePtr) ent;\n+        cur->last = (xmlNodePtr) ent;\n@@ -2514,2 +2474,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue(cur);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2561,1 +2521,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2567,1 +2527,1 @@\n-    cur->content = xmlStrndup(content, len);\n+        cur->content = xmlStrndup(content, len);\n@@ -2574,2 +2534,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue(cur);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2619,1 +2579,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2625,1 +2585,1 @@\n-    cur->content = xmlStrdup(content);\n+        cur->content = xmlStrdup(content);\n@@ -2630,2 +2590,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue(cur);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2659,1 +2619,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2665,1 +2625,1 @@\n-    cur->content = xmlStrndup(content, len);\n+        cur->content = xmlStrndup(content, len);\n@@ -2672,2 +2632,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue(cur);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue(cur);\n@@ -2866,1 +2826,1 @@\n-    return(0);\n+        return(0);\n@@ -2917,1 +2877,1 @@\n-    return(0);\n+        return(0);\n@@ -2921,2 +2881,2 @@\n-    if (cur->doc != doc) {\n-        if (xmlSetTreeDoc(cur, doc) < 0)\n+        if (cur->doc != doc) {\n+            if (xmlSetTreeDoc(cur, doc) < 0)\n@@ -2925,1 +2885,1 @@\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -2931,1 +2891,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n@@ -2958,1 +2917,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2985,1 +2944,1 @@\n-    parent->last = cur;\n+        parent->last = cur;\n@@ -2988,3 +2947,3 @@\n-    prev->next = cur;\n-    cur->prev = prev;\n-    parent->last = cur;\n+        prev->next = cur;\n+        cur->prev = prev;\n+        parent->last = cur;\n@@ -2995,1 +2954,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -3076,1 +3034,1 @@\n-    return xmlInsertProp(doc, cur, parent, prev, next);\n+        return xmlInsertProp(doc, cur, parent, prev, next);\n@@ -3082,1 +3040,1 @@\n-    if ((prev != NULL) && (prev->type == XML_TEXT_NODE) &&\n+        if ((prev != NULL) && (prev->type == XML_TEXT_NODE) &&\n@@ -3087,3 +3045,3 @@\n-        xmlFreeNode(cur);\n-        return(prev);\n-    }\n+            xmlFreeNode(cur);\n+            return(prev);\n+        }\n@@ -3091,1 +3049,1 @@\n-    if ((next != NULL) && (next->type == XML_TEXT_NODE) &&\n+        if ((next != NULL) && (next->type == XML_TEXT_NODE) &&\n@@ -3094,1 +3052,1 @@\n-            xmlChar *merged;\n+                xmlChar *merged;\n@@ -3103,3 +3061,3 @@\n-        xmlFreeNode(cur);\n-        return(next);\n-    }\n+            xmlFreeNode(cur);\n+            return(next);\n+        }\n@@ -3122,1 +3080,1 @@\n-    if (xmlSetTreeDoc(cur, doc) < 0) {\n+        if (xmlSetTreeDoc(cur, doc) < 0) {\n@@ -3180,1 +3138,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3188,2 +3146,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_HTML_ENABLED) || \\\n-    defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)\n@@ -3213,1 +3169,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3220,1 +3176,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -3247,1 +3202,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3255,1 +3210,1 @@\n-        node = node->parent->last;\n+            node = node->parent->last;\n@@ -3257,1 +3212,1 @@\n-    while (node->next != NULL)\n+        while (node->next != NULL)\n@@ -3285,1 +3240,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3289,1 +3244,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3294,2 +3249,2 @@\n-    if (iter->doc != parent->doc) {\n-        if (xmlSetTreeDoc(iter, parent->doc) < 0)\n+        if (iter->doc != parent->doc) {\n+            if (xmlSetTreeDoc(iter, parent->doc) < 0)\n@@ -3297,1 +3252,1 @@\n-    }\n+        }\n@@ -3311,6 +3266,6 @@\n-    \/*\n-     * If cur and parent->last both are TEXT nodes, then merge them.\n-     *\/\n-    if ((cur->type == XML_TEXT_NODE) &&\n-        (prev->type == XML_TEXT_NODE) &&\n-        (cur->name == prev->name)) {\n+        \/*\n+         * If cur and parent->last both are TEXT nodes, then merge them.\n+         *\/\n+        if ((cur->type == XML_TEXT_NODE) &&\n+            (prev->type == XML_TEXT_NODE) &&\n+            (cur->name == prev->name)) {\n@@ -3322,8 +3277,8 @@\n-        xmlFreeNode(cur);\n-        \/*\n-         * if it's the only child, nothing more to be done.\n-         *\/\n-        if (next == NULL)\n-        return(prev);\n-        cur = next;\n-    }\n+            xmlFreeNode(cur);\n+            \/*\n+             * if it's the only child, nothing more to be done.\n+             *\/\n+            if (next == NULL)\n+                return(prev);\n+            cur = next;\n+        }\n@@ -3331,2 +3286,2 @@\n-    prev->next = cur;\n-    cur->prev = prev;\n+        prev->next = cur;\n+        cur->prev = prev;\n@@ -3335,1 +3290,1 @@\n-    cur->parent = parent;\n+        cur->parent = parent;\n@@ -3357,1 +3312,1 @@\n- * matching @elem, the old attribute is destroyed.\n+ * matching @cur, the old attribute is destroyed.\n@@ -3384,1 +3339,1 @@\n- * Returns @elem or a sibling if @elem was merged. Returns NULL\n+ * Returns @cur or a sibling if @cur was merged. Returns NULL\n@@ -3434,1 +3389,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3439,1 +3394,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -3624,2 +3578,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n-\n@@ -3641,2 +3593,2 @@\n-    xmlFreeNsList((xmlNsPtr) cur);\n-    return;\n+        xmlFreeNsList((xmlNsPtr) cur);\n+        return;\n@@ -3657,1 +3609,1 @@\n-    if ((cur->type == XML_DOCUMENT_NODE) ||\n+        if ((cur->type == XML_DOCUMENT_NODE) ||\n@@ -3668,2 +3620,20 @@\n-        if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n-        xmlDeregisterNodeDefaultValue(cur);\n+            if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n+                xmlDeregisterNodeDefaultValue(cur);\n+\n+            if (((cur->type == XML_ELEMENT_NODE) ||\n+                 (cur->type == XML_XINCLUDE_START) ||\n+                 (cur->type == XML_XINCLUDE_END)) &&\n+                (cur->properties != NULL))\n+                xmlFreePropList(cur->properties);\n+            if ((cur->type != XML_ELEMENT_NODE) &&\n+                (cur->type != XML_XINCLUDE_START) &&\n+                (cur->type != XML_XINCLUDE_END) &&\n+                (cur->type != XML_ENTITY_REF_NODE) &&\n+                (cur->content != (xmlChar *) &(cur->properties))) {\n+                DICT_FREE(cur->content)\n+            }\n+            if (((cur->type == XML_ELEMENT_NODE) ||\n+                 (cur->type == XML_XINCLUDE_START) ||\n+                 (cur->type == XML_XINCLUDE_END)) &&\n+                (cur->nsDef != NULL))\n+                xmlFreeNsList(cur->nsDef);\n@@ -3671,11 +3641,11 @@\n-        if (((cur->type == XML_ELEMENT_NODE) ||\n-         (cur->type == XML_XINCLUDE_START) ||\n-         (cur->type == XML_XINCLUDE_END)) &&\n-        (cur->properties != NULL))\n-        xmlFreePropList(cur->properties);\n-        if ((cur->type != XML_ELEMENT_NODE) &&\n-        (cur->type != XML_XINCLUDE_START) &&\n-        (cur->type != XML_XINCLUDE_END) &&\n-        (cur->type != XML_ENTITY_REF_NODE) &&\n-        (cur->content != (xmlChar *) &(cur->properties))) {\n-        DICT_FREE(cur->content)\n+            \/*\n+             * When a node is a text node or a comment, it uses a global static\n+             * variable for the name of the node.\n+             * Otherwise the node name might come from the document's\n+             * dictionary\n+             *\/\n+            if ((cur->name != NULL) &&\n+                (cur->type != XML_TEXT_NODE) &&\n+                (cur->type != XML_COMMENT_NODE))\n+                DICT_FREE(cur->name)\n+            xmlFree(cur);\n@@ -3683,18 +3653,0 @@\n-        if (((cur->type == XML_ELEMENT_NODE) ||\n-             (cur->type == XML_XINCLUDE_START) ||\n-         (cur->type == XML_XINCLUDE_END)) &&\n-        (cur->nsDef != NULL))\n-        xmlFreeNsList(cur->nsDef);\n-\n-        \/*\n-         * When a node is a text node or a comment, it uses a global static\n-         * variable for the name of the node.\n-         * Otherwise the node name might come from the document's\n-         * dictionary\n-         *\/\n-        if ((cur->name != NULL) &&\n-        (cur->type != XML_TEXT_NODE) &&\n-        (cur->type != XML_COMMENT_NODE))\n-        DICT_FREE(cur->name)\n-        xmlFree(cur);\n-    }\n@@ -3703,1 +3655,1 @@\n-        cur = next;\n+            cur = next;\n@@ -3731,2 +3683,2 @@\n-    xmlFreeDtd((xmlDtdPtr) cur);\n-    return;\n+        xmlFreeDtd((xmlDtdPtr) cur);\n+        return;\n@@ -3735,1 +3687,1 @@\n-    xmlFreeNs((xmlNsPtr) cur);\n+        xmlFreeNs((xmlNsPtr) cur);\n@@ -3739,2 +3691,2 @@\n-    xmlFreeProp((xmlAttrPtr) cur);\n-    return;\n+        xmlFreeProp((xmlAttrPtr) cur);\n+        return;\n@@ -3747,2 +3699,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n-    xmlDeregisterNodeDefaultValue(cur);\n+    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n+        xmlDeregisterNodeDefaultValue(cur);\n@@ -3753,2 +3705,2 @@\n-    (cur->type != XML_ENTITY_REF_NODE))\n-    xmlFreeNodeList(cur->children);\n+        (cur->type != XML_ENTITY_REF_NODE))\n+        xmlFreeNodeList(cur->children);\n@@ -3777,1 +3729,1 @@\n-    DICT_FREE(cur->name)\n+        DICT_FREE(cur->name)\n@@ -3794,12 +3746,12 @@\n-    xmlNodePtr parent;\n-    parent = cur->parent;\n-    if (cur->type == XML_ATTRIBUTE_NODE) {\n-        if (parent->properties == (xmlAttrPtr) cur)\n-        parent->properties = ((xmlAttrPtr) cur)->next;\n-    } else {\n-        if (parent->children == cur)\n-        parent->children = cur->next;\n-        if (parent->last == cur)\n-        parent->last = cur->prev;\n-    }\n-    cur->parent = NULL;\n+        xmlNodePtr parent;\n+        parent = cur->parent;\n+        if (cur->type == XML_ATTRIBUTE_NODE) {\n+            if (parent->properties == (xmlAttrPtr) cur)\n+                parent->properties = ((xmlAttrPtr) cur)->next;\n+        } else {\n+            if (parent->children == cur)\n+                parent->children = cur->next;\n+            if (parent->last == cur)\n+                parent->last = cur->prev;\n+        }\n+        cur->parent = NULL;\n@@ -3828,1 +3780,1 @@\n-    return;\n+        return;\n@@ -3834,1 +3786,1 @@\n-    xmlDocPtr doc = cur->doc;\n+        xmlDocPtr doc = cur->doc;\n@@ -3836,6 +3788,6 @@\n-    if (doc != NULL) {\n-        if (doc->intSubset == (xmlDtdPtr) cur)\n-        doc->intSubset = NULL;\n-        if (doc->extSubset == (xmlDtdPtr) cur)\n-        doc->extSubset = NULL;\n-    }\n+        if (doc != NULL) {\n+            if (doc->intSubset == (xmlDtdPtr) cur)\n+                doc->intSubset = NULL;\n+            if (doc->extSubset == (xmlDtdPtr) cur)\n+                doc->extSubset = NULL;\n+        }\n@@ -3850,1 +3802,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)\n@@ -3874,1 +3825,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3878,2 +3829,2 @@\n-    xmlUnlinkNode(old);\n-    return(old);\n+        xmlUnlinkNode(old);\n+        return(old);\n@@ -3882,1 +3833,1 @@\n-    return(old);\n+        return(old);\n@@ -3885,1 +3836,1 @@\n-    return(old);\n+        return(old);\n@@ -3893,1 +3844,1 @@\n-    cur->next->prev = cur;\n+        cur->next->prev = cur;\n@@ -3896,1 +3847,1 @@\n-    cur->prev->next = cur;\n+        cur->prev->next = cur;\n@@ -3898,9 +3849,9 @@\n-    if (cur->type == XML_ATTRIBUTE_NODE) {\n-        if (cur->parent->properties == (xmlAttrPtr)old)\n-        cur->parent->properties = ((xmlAttrPtr) cur);\n-    } else {\n-        if (cur->parent->children == old)\n-        cur->parent->children = cur;\n-        if (cur->parent->last == old)\n-        cur->parent->last = cur;\n-    }\n+        if (cur->type == XML_ATTRIBUTE_NODE) {\n+            if (cur->parent->properties == (xmlAttrPtr)old)\n+                cur->parent->properties = ((xmlAttrPtr) cur);\n+        } else {\n+            if (cur->parent->children == old)\n+                cur->parent->children = cur;\n+            if (cur->parent->last == old)\n+                cur->parent->last = cur;\n+        }\n@@ -3912,1 +3863,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -3915,3 +3865,3 @@\n- *                                    *\n- *        Copy operations                        *\n- *                                    *\n+ *                                                                      *\n+ *              Copy operations                                         *\n+ *                                                                      *\n@@ -3935,5 +3885,5 @@\n-    case XML_LOCAL_NAMESPACE:\n-        ret = xmlNewNs(NULL, cur->href, cur->prefix);\n-        break;\n-    default:\n-        return(NULL);\n+        case XML_LOCAL_NAMESPACE:\n+            ret = xmlNewNs(NULL, cur->href, cur->prefix);\n+            break;\n+        default:\n+            return(NULL);\n@@ -3964,7 +3914,7 @@\n-    if (p == NULL) {\n-        ret = p = q;\n-    } else {\n-        p->next = q;\n-        p = q;\n-    }\n-    cur = cur->next;\n+        if (p == NULL) {\n+            ret = p = q;\n+        } else {\n+            p->next = q;\n+            p = q;\n+        }\n+        cur = cur->next;\n@@ -3983,1 +3933,1 @@\n-    ret = xmlNewDocProp(target->doc, cur->name, NULL);\n+        ret = xmlNewDocProp(target->doc, cur->name, NULL);\n@@ -3985,1 +3935,1 @@\n-    ret = xmlNewDocProp(doc, cur->name, NULL);\n+        ret = xmlNewDocProp(doc, cur->name, NULL);\n@@ -3987,1 +3937,1 @@\n-    ret = xmlNewDocProp(cur->parent->doc, cur->name, NULL);\n+        ret = xmlNewDocProp(cur->parent->doc, cur->name, NULL);\n@@ -3989,1 +3939,1 @@\n-    ret = xmlNewDocProp(cur->children->doc, cur->name, NULL);\n+        ret = xmlNewDocProp(cur->children->doc, cur->name, NULL);\n@@ -3991,1 +3941,1 @@\n-    ret = xmlNewDocProp(NULL, cur->name, NULL);\n+        ret = xmlNewDocProp(NULL, cur->name, NULL);\n@@ -4051,1 +4001,1 @@\n-    xmlNodePtr tmp;\n+        xmlNodePtr tmp;\n@@ -4053,1 +4003,1 @@\n-    ret->children = xmlStaticCopyNodeList(cur->children, ret->doc, (xmlNodePtr) ret);\n+        ret->children = xmlStaticCopyNodeList(cur->children, ret->doc, (xmlNodePtr) ret);\n@@ -4056,8 +4006,8 @@\n-    ret->last = NULL;\n-    tmp = ret->children;\n-    while (tmp != NULL) {\n-        \/* tmp->parent = (xmlNodePtr)ret; *\/\n-        if (tmp->next == NULL)\n-            ret->last = tmp;\n-        tmp = tmp->next;\n-    }\n+        ret->last = NULL;\n+        tmp = ret->children;\n+        while (tmp != NULL) {\n+            \/* tmp->parent = (xmlNodePtr)ret; *\/\n+            if (tmp->next == NULL)\n+                ret->last = tmp;\n+            tmp = tmp->next;\n+        }\n@@ -4069,1 +4019,1 @@\n-    (target->doc != NULL) && (cur->doc != NULL) &&\n+        (target->doc != NULL) && (cur->doc != NULL) &&\n@@ -4076,2 +4026,2 @@\n-    if (res != 0) {\n-        xmlChar *id;\n+        if (res != 0) {\n+            xmlChar *id;\n@@ -4079,2 +4029,2 @@\n-        id = xmlNodeGetContent((xmlNodePtr) cur);\n-        if (id == NULL)\n+            id = xmlNodeGetContent((xmlNodePtr) cur);\n+            if (id == NULL)\n@@ -4083,1 +4033,1 @@\n-        xmlFree(id);\n+            xmlFree(id);\n@@ -4086,1 +4036,1 @@\n-    }\n+        }\n@@ -4111,1 +4061,1 @@\n-    return xmlCopyPropInternal(NULL, target, cur);\n+        return xmlCopyPropInternal(NULL, target, cur);\n@@ -4135,1 +4085,1 @@\n-    if (q == NULL) {\n+        if (q == NULL) {\n@@ -4137,1 +4087,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -4139,8 +4089,8 @@\n-    if (p == NULL) {\n-        ret = p = q;\n-    } else {\n-        p->next = q;\n-        q->prev = p;\n-        p = q;\n-    }\n-    cur = cur->next;\n+        if (p == NULL) {\n+            ret = p = q;\n+        } else {\n+            p->next = q;\n+            q->prev = p;\n+            p = q;\n+        }\n+        cur = cur->next;\n@@ -4197,1 +4147,1 @@\n-        break;\n+            break;\n@@ -4199,1 +4149,1 @@\n-        return((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));\n+                return((xmlNodePtr) xmlCopyPropInternal(doc, parent, (xmlAttrPtr) node));\n@@ -4201,1 +4151,1 @@\n-        return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));\n+            return((xmlNodePtr) xmlCopyNamespaceList((xmlNsPtr) node));\n@@ -4205,3 +4155,1 @@\n-#ifdef LIBXML_TREE_ENABLED\n-        return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));\n-#endif \/* LIBXML_TREE_ENABLED *\/\n+            return((xmlNodePtr) xmlCopyDoc((xmlDocPtr) node, extended));\n@@ -4217,1 +4165,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4224,1 +4172,1 @@\n-    ret->name = xmlStringText;\n+        ret->name = xmlStringText;\n@@ -4226,1 +4174,1 @@\n-    ret->name = xmlStringTextNoenc;\n+        ret->name = xmlStringTextNoenc;\n@@ -4228,1 +4176,1 @@\n-    ret->name = xmlStringComment;\n+        ret->name = xmlStringComment;\n@@ -4231,3 +4179,3 @@\n-        ret->name = xmlDictLookup(doc->dict, node->name, -1);\n-    else\n-        ret->name = xmlStrdup(node->name);\n+            ret->name = xmlDictLookup(doc->dict, node->name, -1);\n+        else\n+            ret->name = xmlStrdup(node->name);\n@@ -4238,5 +4186,5 @@\n-    (node->content != NULL) &&\n-    (node->type != XML_ENTITY_REF_NODE) &&\n-    (node->type != XML_XINCLUDE_END) &&\n-    (node->type != XML_XINCLUDE_START)) {\n-    ret->content = xmlStrdup(node->content);\n+        (node->content != NULL) &&\n+        (node->type != XML_ENTITY_REF_NODE) &&\n+        (node->type != XML_XINCLUDE_END) &&\n+        (node->type != XML_XINCLUDE_START)) {\n+        ret->content = xmlStrdup(node->content);\n@@ -4251,1 +4199,1 @@\n-    goto out;\n+        goto out;\n@@ -4263,1 +4211,1 @@\n-    res = xmlSearchNsSafe(ret, node->ns->prefix, &ns);\n+        res = xmlSearchNsSafe(ret, node->ns->prefix, &ns);\n@@ -4266,5 +4214,5 @@\n-    if (ns == NULL) {\n-        \/*\n-         * Humm, we are copying an element whose namespace is defined\n-         * out of the new tree scope. Search it in the original tree\n-         * and add it at the top of the new tree.\n+        if (ns == NULL) {\n+            \/*\n+             * Humm, we are copying an element whose namespace is defined\n+             * out of the new tree scope. Search it in the original tree\n+             * and add it at the top of the new tree.\n@@ -4274,2 +4222,2 @@\n-         *\/\n-        res = xmlSearchNsSafe(node, node->ns->prefix, &ns);\n+             *\/\n+            res = xmlSearchNsSafe(node, node->ns->prefix, &ns);\n@@ -4278,2 +4226,2 @@\n-        if (ns != NULL) {\n-            xmlNodePtr root = ret;\n+            if (ns != NULL) {\n+                xmlNodePtr root = ret;\n@@ -4281,2 +4229,2 @@\n-        while (root->parent != NULL) root = root->parent;\n-        ret->ns = xmlNewNs(root, ns->href, ns->prefix);\n+                while (root->parent != NULL) root = root->parent;\n+                ret->ns = xmlNewNs(root, ns->href, ns->prefix);\n@@ -4285,1 +4233,1 @@\n-        }\n+            }\n@@ -4288,6 +4236,6 @@\n-    } else {\n-        \/*\n-         * reference the existing namespace definition in our own tree.\n-         *\/\n-        ret->ns = ns;\n-    }\n+        } else {\n+            \/*\n+             * reference the existing namespace definition in our own tree.\n+             *\/\n+            ret->ns = ns;\n+        }\n@@ -4301,12 +4249,12 @@\n-    if ((doc == NULL) || (node->doc != doc)) {\n-        \/*\n-         * The copied node will go into a separate document, so\n-         * to avoid dangling references to the ENTITY_DECL node\n-         * we cannot keep the reference. Try to find it in the\n-         * target document.\n-         *\/\n-        ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);\n-    } else {\n-            ret->children = node->children;\n-    }\n-    ret->last = ret->children;\n+        if ((doc == NULL) || (node->doc != doc)) {\n+            \/*\n+             * The copied node will go into a separate document, so\n+             * to avoid dangling references to the ENTITY_DECL node\n+             * we cannot keep the reference. Try to find it in the\n+             * target document.\n+             *\/\n+            ret->children = (xmlNodePtr) xmlGetDocEntity(doc, ret->name);\n+        } else {\n+            ret->children = node->children;\n+        }\n+        ret->last = ret->children;\n@@ -4358,2 +4306,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n-    xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n+    if ((xmlRegisterCallbacks) && (xmlRegisterNodeDefaultValue))\n+        xmlRegisterNodeDefaultValue((xmlNodePtr)ret);\n@@ -4389,9 +4337,8 @@\n-#ifdef LIBXML_TREE_ENABLED\n-    if (node->type == XML_DTD_NODE ) {\n-        if (doc == NULL) {\n-        node = next;\n-        continue;\n-        }\n-        if ((doc->intSubset == NULL) && (newSubset == NULL)) {\n-        q = (xmlNodePtr) xmlCopyDtd( (xmlDtdPtr) node );\n-        if (q == NULL) goto error;\n+        if (node->type == XML_DTD_NODE ) {\n+            if (doc == NULL) {\n+                node = next;\n+                continue;\n+            }\n+            if ((doc->intSubset == NULL) && (newSubset == NULL)) {\n+                q = (xmlNodePtr) xmlCopyDtd( (xmlDtdPtr) node );\n+                if (q == NULL) goto error;\n@@ -4399,4 +4346,4 @@\n-        xmlSetTreeDoc(q, doc);\n-        q->parent = parent;\n-        newSubset = (xmlDtdPtr) q;\n-        } else {\n+                xmlSetTreeDoc(q, doc);\n+                q->parent = parent;\n+                newSubset = (xmlDtdPtr) q;\n+            } else {\n@@ -4408,1 +4355,1 @@\n-        q = (xmlNodePtr) doc->intSubset;\n+                q = (xmlNodePtr) doc->intSubset;\n@@ -4425,0 +4372,12 @@\n+            }\n+        } else\n+            q = xmlStaticCopyNode(node, doc, parent, 1);\n+        if (q == NULL) goto error;\n+        if (ret == NULL) {\n+            q->prev = NULL;\n+            ret = p = q;\n+        } else if (p != q) {\n+        \/* the test is required if xmlStaticCopyNode coalesced 2 text nodes *\/\n+            p->next = q;\n+            q->prev = p;\n+            p = q;\n@@ -4426,14 +4385,1 @@\n-    } else\n-#endif \/* LIBXML_TREE_ENABLED *\/\n-        q = xmlStaticCopyNode(node, doc, parent, 1);\n-    if (q == NULL) goto error;\n-    if (ret == NULL) {\n-        q->prev = NULL;\n-        ret = p = q;\n-    } else if (p != q) {\n-    \/* the test is required if xmlStaticCopyNode coalesced 2 text nodes *\/\n-        p->next = q;\n-        q->prev = p;\n-        p = q;\n-    }\n-    node = next;\n+        node = next;\n@@ -4459,2 +4405,2 @@\n- *            when applicable)\n- *        if 2 copy properties and namespaces (when applicable)\n+ *                      when applicable)\n+ *              if 2 copy properties and namespaces (when applicable)\n@@ -4481,2 +4427,2 @@\n- *            when applicable)\n- *        if 2 copy properties and namespaces (when applicable)\n+ *                      when applicable)\n+ *              if 2 copy properties and namespaces (when applicable)\n@@ -4527,1 +4473,0 @@\n-#if defined(LIBXML_TREE_ENABLED)\n@@ -4546,1 +4491,1 @@\n-                        (xmlEntitiesTablePtr) dtd->entities);\n+                            (xmlEntitiesTablePtr) dtd->entities);\n@@ -4552,1 +4497,1 @@\n-                        (xmlNotationTablePtr) dtd->notations);\n+                            (xmlNotationTablePtr) dtd->notations);\n@@ -4558,1 +4503,1 @@\n-                        (xmlElementTablePtr) dtd->elements);\n+                            (xmlElementTablePtr) dtd->elements);\n@@ -4564,1 +4509,1 @@\n-                        (xmlAttributeTablePtr) dtd->attributes);\n+                            (xmlAttributeTablePtr) dtd->attributes);\n@@ -4569,2 +4514,2 @@\n-    ret->pentities = (void *) xmlCopyEntitiesTable(\n-                (xmlEntitiesTablePtr) dtd->pentities);\n+        ret->pentities = (void *) xmlCopyEntitiesTable(\n+                            (xmlEntitiesTablePtr) dtd->pentities);\n@@ -4577,12 +4522,20 @@\n-    q = NULL;\n-\n-    if (cur->type == XML_ENTITY_DECL) {\n-        xmlEntityPtr tmp = (xmlEntityPtr) cur;\n-        switch (tmp->etype) {\n-        case XML_INTERNAL_GENERAL_ENTITY:\n-        case XML_EXTERNAL_GENERAL_PARSED_ENTITY:\n-        case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:\n-            q = (xmlNodePtr) xmlGetEntityFromDtd(ret, tmp->name);\n-            break;\n-        case XML_INTERNAL_PARAMETER_ENTITY:\n-        case XML_EXTERNAL_PARAMETER_ENTITY:\n+        q = NULL;\n+\n+        if (cur->type == XML_ENTITY_DECL) {\n+            xmlEntityPtr tmp = (xmlEntityPtr) cur;\n+            switch (tmp->etype) {\n+                case XML_INTERNAL_GENERAL_ENTITY:\n+                case XML_EXTERNAL_GENERAL_PARSED_ENTITY:\n+                case XML_EXTERNAL_GENERAL_UNPARSED_ENTITY:\n+                    q = (xmlNodePtr) xmlGetEntityFromDtd(ret, tmp->name);\n+                    break;\n+                case XML_INTERNAL_PARAMETER_ENTITY:\n+                case XML_EXTERNAL_PARAMETER_ENTITY:\n+                    q = (xmlNodePtr)\n+                        xmlGetParameterEntityFromDtd(ret, tmp->name);\n+                    break;\n+                case XML_INTERNAL_PREDEFINED_ENTITY:\n+                    break;\n+            }\n+        } else if (cur->type == XML_ELEMENT_DECL) {\n+            xmlElementPtr tmp = (xmlElementPtr) cur;\n@@ -4590,15 +4543,7 @@\n-            xmlGetParameterEntityFromDtd(ret, tmp->name);\n-            break;\n-        case XML_INTERNAL_PREDEFINED_ENTITY:\n-            break;\n-        }\n-    } else if (cur->type == XML_ELEMENT_DECL) {\n-        xmlElementPtr tmp = (xmlElementPtr) cur;\n-        q = (xmlNodePtr)\n-        xmlGetDtdQElementDesc(ret, tmp->name, tmp->prefix);\n-    } else if (cur->type == XML_ATTRIBUTE_DECL) {\n-        xmlAttributePtr tmp = (xmlAttributePtr) cur;\n-        q = (xmlNodePtr)\n-        xmlGetDtdQAttrDesc(ret, tmp->elem, tmp->name, tmp->prefix);\n-    } else if (cur->type == XML_COMMENT_NODE) {\n-        q = xmlCopyNode(cur, 0);\n+                xmlGetDtdQElementDesc(ret, tmp->name, tmp->prefix);\n+        } else if (cur->type == XML_ATTRIBUTE_DECL) {\n+            xmlAttributePtr tmp = (xmlAttributePtr) cur;\n+            q = (xmlNodePtr)\n+                xmlGetDtdQAttrDesc(ret, tmp->elem, tmp->name, tmp->prefix);\n+        } else if (cur->type == XML_COMMENT_NODE) {\n+            q = xmlCopyNode(cur, 0);\n@@ -4607,1 +4552,1 @@\n-    }\n+        }\n@@ -4609,4 +4554,4 @@\n-    if (q == NULL) {\n-        cur = cur->next;\n-        continue;\n-    }\n+        if (q == NULL) {\n+            cur = cur->next;\n+            continue;\n+        }\n@@ -4614,4 +4559,4 @@\n-    if (p == NULL)\n-        ret->children = q;\n-    else\n-        p->next = q;\n+        if (p == NULL)\n+            ret->children = q;\n+        else\n+            p->next = q;\n@@ -4619,6 +4564,6 @@\n-    q->prev = p;\n-    q->parent = (xmlNodePtr) ret;\n-    q->next = NULL;\n-    ret->last = q;\n-    p = q;\n-    cur = cur->next;\n+        q->prev = p;\n+        q->parent = (xmlNodePtr) ret;\n+        q->next = NULL;\n+        ret->last = q;\n+        p = q;\n+        cur = cur->next;\n@@ -4633,1 +4578,0 @@\n-#endif\n@@ -4635,1 +4579,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n@@ -4677,1 +4620,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -4680,1 +4622,1 @@\n-    if (ret->intSubset == NULL)\n+        if (ret->intSubset == NULL)\n@@ -4683,1 +4625,1 @@\n-    xmlSetTreeDoc((xmlNodePtr)ret->intSubset, ret);\n+        xmlSetTreeDoc((xmlNodePtr)ret->intSubset, ret);\n@@ -4685,1 +4627,0 @@\n-#endif\n@@ -4692,1 +4633,1 @@\n-    xmlNodePtr tmp;\n+        xmlNodePtr tmp;\n@@ -4694,2 +4635,2 @@\n-    ret->children = xmlStaticCopyNodeList(doc->children, ret,\n-                                       (xmlNodePtr)ret);\n+        ret->children = xmlStaticCopyNodeList(doc->children, ret,\n+                                               (xmlNodePtr)ret);\n@@ -4698,7 +4639,7 @@\n-    ret->last = NULL;\n-    tmp = ret->children;\n-    while (tmp != NULL) {\n-        if (tmp->next == NULL)\n-            ret->last = tmp;\n-        tmp = tmp->next;\n-    }\n+        ret->last = NULL;\n+        tmp = ret->children;\n+        while (tmp != NULL) {\n+            if (tmp->next == NULL)\n+                ret->last = tmp;\n+            tmp = tmp->next;\n+        }\n@@ -4712,1 +4653,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -4715,3 +4655,3 @@\n- *                                    *\n- *        Content access functions                *\n- *                                    *\n+ *                                                                      *\n+ *              Content access functions                                *\n+ *                                                                      *\n@@ -4742,15 +4682,15 @@\n-    (node->type == XML_COMMENT_NODE) ||\n-    (node->type == XML_PI_NODE)) {\n-    if (node->line == 65535) {\n-        if ((node->type == XML_TEXT_NODE) && (node->psvi != NULL))\n-            result = (long) (ptrdiff_t) node->psvi;\n-        else if ((node->type == XML_ELEMENT_NODE) &&\n-                 (node->children != NULL))\n-            result = xmlGetLineNoInternal(node->children, depth + 1);\n-        else if (node->next != NULL)\n-            result = xmlGetLineNoInternal(node->next, depth + 1);\n-        else if (node->prev != NULL)\n-            result = xmlGetLineNoInternal(node->prev, depth + 1);\n-    }\n-    if ((result == -1) || (result == 65535))\n-        result = (long) node->line;\n+        (node->type == XML_COMMENT_NODE) ||\n+        (node->type == XML_PI_NODE)) {\n+        if (node->line == 65535) {\n+            if ((node->type == XML_TEXT_NODE) && (node->psvi != NULL))\n+                result = XML_PTR_TO_INT(node->psvi);\n+            else if ((node->type == XML_ELEMENT_NODE) &&\n+                     (node->children != NULL))\n+                result = xmlGetLineNoInternal(node->children, depth + 1);\n+            else if (node->next != NULL)\n+                result = xmlGetLineNoInternal(node->next, depth + 1);\n+            else if (node->prev != NULL)\n+                result = xmlGetLineNoInternal(node->prev, depth + 1);\n+        }\n+        if ((result == -1) || (result == 65535))\n+            result = node->line;\n@@ -4759,3 +4699,3 @@\n-          (node->prev->type == XML_TEXT_NODE) ||\n-          (node->prev->type == XML_COMMENT_NODE) ||\n-          (node->prev->type == XML_PI_NODE)))\n+              (node->prev->type == XML_TEXT_NODE) ||\n+              (node->prev->type == XML_COMMENT_NODE) ||\n+              (node->prev->type == XML_PI_NODE)))\n@@ -4786,1 +4726,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_DEBUG_ENABLED)\n@@ -4800,2 +4739,2 @@\n-    xmlChar *buffer = NULL, *temp;\n-    size_t buf_len;\n+    xmlChar *buffer = NULL;\n+    size_t buf_len, len;\n@@ -4812,1 +4751,1 @@\n-    buffer = (xmlChar *) xmlMallocAtomic(buf_len);\n+    buffer = xmlMalloc(buf_len);\n@@ -4815,1 +4754,1 @@\n-    buf = (xmlChar *) xmlMallocAtomic(buf_len);\n+    buf = xmlMalloc(buf_len);\n@@ -4834,1 +4773,1 @@\n-        generic = 0;\n+            generic = 0;\n@@ -4838,1 +4777,1 @@\n-        if (cur->ns->prefix != NULL) {\n+                if (cur->ns->prefix != NULL) {\n@@ -4840,11 +4779,11 @@\n-            (char *)cur->ns->prefix, (char *)cur->name);\n-            nametemp[sizeof(nametemp) - 1] = 0;\n-            name = nametemp;\n-        } else {\n-            \/*\n-            * We cannot express named elements in the default\n-            * namespace, so use \"*\".\n-            *\/\n-            generic = 1;\n-            name = \"*\";\n-        }\n+                        (char *)cur->ns->prefix, (char *)cur->name);\n+                    nametemp[sizeof(nametemp) - 1] = 0;\n+                    name = nametemp;\n+                } else {\n+                    \/*\n+                    * We cannot express named elements in the default\n+                    * namespace, so use \"*\".\n+                    *\/\n+                    generic = 1;\n+                    name = \"*\";\n+                }\n@@ -4856,1 +4795,1 @@\n-         * TODO: the occurrence test seems bogus for namespaced names\n+             * TODO: the occurrence test seems bogus for namespaced names\n@@ -4861,5 +4800,5 @@\n-            (generic ||\n-             (xmlStrEqual(cur->name, tmp->name) &&\n-             ((tmp->ns == cur->ns) ||\n-              ((tmp->ns != NULL) && (cur->ns != NULL) &&\n-               (xmlStrEqual(cur->ns->prefix, tmp->ns->prefix)))))))\n+                    (generic ||\n+                     (xmlStrEqual(cur->name, tmp->name) &&\n+                     ((tmp->ns == cur->ns) ||\n+                      ((tmp->ns != NULL) && (cur->ns != NULL) &&\n+                       (xmlStrEqual(cur->ns->prefix, tmp->ns->prefix)))))))\n@@ -4873,5 +4812,5 @@\n-            (generic ||\n-             (xmlStrEqual(cur->name, tmp->name) &&\n-             ((tmp->ns == cur->ns) ||\n-              ((tmp->ns != NULL) && (cur->ns != NULL) &&\n-               (xmlStrEqual(cur->ns->prefix, tmp->ns->prefix)))))))\n+                        (generic ||\n+                         (xmlStrEqual(cur->name, tmp->name) &&\n+                         ((tmp->ns == cur->ns) ||\n+                          ((tmp->ns != NULL) && (cur->ns != NULL) &&\n+                           (xmlStrEqual(cur->ns->prefix, tmp->ns->prefix)))))))\n@@ -4887,1 +4826,1 @@\n-        name = \"comment()\";\n+            name = \"comment()\";\n@@ -4896,1 +4835,1 @@\n-            occur++;\n+                    occur++;\n@@ -4902,2 +4841,2 @@\n-            if (tmp->type == XML_COMMENT_NODE)\n-                occur++;\n+                    if (tmp->type == XML_COMMENT_NODE)\n+                        occur++;\n@@ -4913,1 +4852,1 @@\n-        name = \"text()\";\n+            name = \"text()\";\n@@ -4922,2 +4861,2 @@\n-            (tmp->type == XML_CDATA_SECTION_NODE))\n-            occur++;\n+                    (tmp->type == XML_CDATA_SECTION_NODE))\n+                    occur++;\n@@ -4926,4 +4865,4 @@\n-        \/*\n-        * Evaluate if this is the only text- or CDATA-section-node;\n-        * if yes, then we'll get \"text()\", otherwise \"text()[1]\".\n-        *\/\n+            \/*\n+            * Evaluate if this is the only text- or CDATA-section-node;\n+            * if yes, then we'll get \"text()\", otherwise \"text()[1]\".\n+            *\/\n@@ -4933,8 +4872,8 @@\n-            if ((tmp->type == XML_TEXT_NODE) ||\n-            (tmp->type == XML_CDATA_SECTION_NODE))\n-            {\n-            occur = 1;\n-            break;\n-            }\n-            tmp = tmp->next;\n-        }\n+                    if ((tmp->type == XML_TEXT_NODE) ||\n+                        (tmp->type == XML_CDATA_SECTION_NODE))\n+                    {\n+                        occur = 1;\n+                        break;\n+                    }\n+                    tmp = tmp->next;\n+                }\n@@ -4945,2 +4884,2 @@\n-        snprintf(nametemp, sizeof(nametemp) - 1,\n-             \"processing-instruction('%s')\", (char *)cur->name);\n+            snprintf(nametemp, sizeof(nametemp) - 1,\n+                     \"processing-instruction('%s')\", (char *)cur->name);\n@@ -4950,1 +4889,1 @@\n-        next = cur->parent;\n+            next = cur->parent;\n@@ -4958,1 +4897,1 @@\n-            (xmlStrEqual(cur->name, tmp->name)))\n+                    (xmlStrEqual(cur->name, tmp->name)))\n@@ -4966,1 +4905,1 @@\n-            (xmlStrEqual(cur->name, tmp->name)))\n+                        (xmlStrEqual(cur->name, tmp->name)))\n@@ -4979,1 +4918,1 @@\n-            if (cur->ns->prefix != NULL)\n+                if (cur->ns->prefix != NULL)\n@@ -4981,4 +4920,4 @@\n-            (char *)cur->ns->prefix, (char *)cur->name);\n-        else\n-            snprintf(nametemp, sizeof(nametemp) - 1, \"%s\",\n-            (char *)cur->name);\n+                        (char *)cur->ns->prefix, (char *)cur->name);\n+                else\n+                    snprintf(nametemp, sizeof(nametemp) - 1, \"%s\",\n+                        (char *)cur->name);\n@@ -4998,4 +4937,14 @@\n-        if (xmlStrlen(buffer) + sizeof(nametemp) + 20 > buf_len) {\n-            buf_len =\n-                2 * buf_len + xmlStrlen(buffer) + sizeof(nametemp) + 20;\n-            temp = (xmlChar *) xmlRealloc(buffer, buf_len);\n+        len = strlen((const char *) buffer);\n+        if (buf_len - len < sizeof(nametemp) + 20) {\n+            xmlChar *temp;\n+            int newSize;\n+\n+            if ((buf_len > SIZE_MAX \/ 2) ||\n+                (2 * buf_len > SIZE_MAX - len - sizeof(nametemp) - 20)) {\n+                xmlFree(buf);\n+                xmlFree(buffer);\n+                return (NULL);\n+            }\n+            newSize = 2 * buf_len + len + sizeof(nametemp) + 20;\n+\n+            temp = xmlRealloc(buffer, newSize);\n@@ -5008,1 +4957,2 @@\n-            temp = (xmlChar *) xmlRealloc(buf, buf_len);\n+\n+            temp = xmlRealloc(buf, newSize);\n@@ -5015,0 +4965,2 @@\n+\n+            buf_len = newSize;\n@@ -5028,1 +4980,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -5046,2 +4997,2 @@\n-    if (ret->type == XML_ELEMENT_NODE)\n-        return(ret);\n+        if (ret->type == XML_ELEMENT_NODE)\n+            return(ret);\n@@ -5053,1 +5004,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_WRITER_ENABLED)\n@@ -5074,1 +5024,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5077,2 +5027,2 @@\n-    if (old->type == XML_ELEMENT_NODE)\n-        break;\n+        if (old->type == XML_ELEMENT_NODE)\n+            break;\n@@ -5088,6 +5038,6 @@\n-    if (doc->children == NULL) {\n-        doc->children = root;\n-        doc->last = root;\n-    } else {\n-        xmlAddSibling(doc->children, root);\n-    }\n+        if (doc->children == NULL) {\n+            doc->children = root;\n+            doc->last = root;\n+        } else {\n+            xmlAddSibling(doc->children, root);\n+        }\n@@ -5095,1 +5045,1 @@\n-    xmlReplaceNode(old, root);\n+        xmlReplaceNode(old, root);\n@@ -5099,1 +5049,0 @@\n-#endif\n@@ -5101,1 +5050,0 @@\n-#if defined(LIBXML_TREE_ENABLED)\n@@ -5131,1 +5079,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -5156,2 +5103,2 @@\n-    if (lang != NULL)\n-        return(lang);\n+        if (lang != NULL)\n+            return(lang);\n@@ -5159,1 +5106,1 @@\n-    cur = cur->parent;\n+        cur = cur->parent;\n@@ -5166,1 +5113,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -5190,1 +5136,1 @@\n-    return(res);\n+        return(res);\n@@ -5203,1 +5149,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -5224,1 +5169,1 @@\n-    res = xmlNodeGetAttrValue(cur, BAD_CAST \"space\", XML_XML_NAMESPACE,\n+        res = xmlNodeGetAttrValue(cur, BAD_CAST \"space\", XML_XML_NAMESPACE,\n@@ -5228,8 +5173,10 @@\n-    if (space != NULL) {\n-        if (xmlStrEqual(space, BAD_CAST \"preserve\")) {\n-        xmlFree(space);\n-        return(1);\n-        }\n-        if (xmlStrEqual(space, BAD_CAST \"default\")) {\n-        xmlFree(space);\n-        return(0);\n+        if (space != NULL) {\n+            if (xmlStrEqual(space, BAD_CAST \"preserve\")) {\n+                xmlFree(space);\n+                return(1);\n+            }\n+            if (xmlStrEqual(space, BAD_CAST \"default\")) {\n+                xmlFree(space);\n+                return(0);\n+            }\n+            xmlFree(space);\n@@ -5237,2 +5184,0 @@\n-        xmlFree(space);\n-    }\n@@ -5240,1 +5185,1 @@\n-    cur = cur->parent;\n+        cur = cur->parent;\n@@ -5246,1 +5191,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -5268,1 +5212,1 @@\n-        break;\n+            break;\n@@ -5275,1 +5219,1 @@\n-    dict = doc->dict;\n+        dict = doc->dict;\n@@ -5292,1 +5236,0 @@\n-#endif\n@@ -5294,1 +5237,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED)\n@@ -5315,1 +5257,1 @@\n-        break;\n+            break;\n@@ -5318,1 +5260,1 @@\n-        xmlDocPtr doc = (xmlDocPtr) cur;\n+            xmlDocPtr doc = (xmlDocPtr) cur;\n@@ -5320,4 +5262,4 @@\n-        if (doc->URL != NULL)\n-        xmlFree((xmlChar *) doc->URL);\n-        if (uri == NULL) {\n-        doc->URL = NULL;\n+            if (doc->URL != NULL)\n+                xmlFree((xmlChar *) doc->URL);\n+            if (uri == NULL) {\n+                doc->URL = NULL;\n@@ -5325,1 +5267,1 @@\n-        doc->URL = xmlPathToURI(uri);\n+                doc->URL = xmlPathToURI(uri);\n@@ -5329,2 +5271,2 @@\n-        return(0);\n-    }\n+            return(0);\n+        }\n@@ -5332,1 +5274,1 @@\n-        return(-1);\n+            return(-1);\n@@ -5337,1 +5279,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5349,1 +5291,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -5389,14 +5330,14 @@\n-    while ((cur != NULL) && (cur->name != NULL)) {\n-        if (cur->type != XML_ELEMENT_NODE) {\n-            cur = cur->next;\n-        continue;\n-        }\n-        if (!xmlStrcasecmp(cur->name, BAD_CAST \"html\")) {\n-            cur = cur->children;\n-        continue;\n-        }\n-        if (!xmlStrcasecmp(cur->name, BAD_CAST \"head\")) {\n-            cur = cur->children;\n-        continue;\n-        }\n-        if (!xmlStrcasecmp(cur->name, BAD_CAST \"base\")) {\n+        while ((cur != NULL) && (cur->name != NULL)) {\n+            if (cur->type != XML_ELEMENT_NODE) {\n+                cur = cur->next;\n+                continue;\n+            }\n+            if (!xmlStrcasecmp(cur->name, BAD_CAST \"html\")) {\n+                cur = cur->children;\n+                continue;\n+            }\n+            if (!xmlStrcasecmp(cur->name, BAD_CAST \"head\")) {\n+                cur = cur->children;\n+                continue;\n+            }\n+            if (!xmlStrcasecmp(cur->name, BAD_CAST \"base\")) {\n@@ -5408,0 +5349,2 @@\n+            }\n+            cur = cur->next;\n@@ -5409,3 +5352,1 @@\n-        cur = cur->next;\n-    }\n-    return(0);\n+        return(0);\n@@ -5415,2 +5356,2 @@\n-    if (cur->type == XML_ENTITY_DECL) {\n-        xmlEntityPtr ent = (xmlEntityPtr) cur;\n+        if (cur->type == XML_ENTITY_DECL) {\n+            xmlEntityPtr ent = (xmlEntityPtr) cur;\n@@ -5421,1 +5362,1 @@\n-        ret = xmlStrdup(ent->URI);\n+            ret = xmlStrdup(ent->URI);\n@@ -5425,3 +5366,3 @@\n-    }\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        if (xmlNodeGetAttrValue(cur, BAD_CAST \"base\", XML_XML_NAMESPACE,\n+        }\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            if (xmlNodeGetAttrValue(cur, BAD_CAST \"base\", XML_XML_NAMESPACE,\n@@ -5432,3 +5373,3 @@\n-        if (base != NULL) {\n-        if (ret != NULL) {\n-            res = xmlBuildURISafe(ret, base, &newbase);\n+            if (base != NULL) {\n+                if (ret != NULL) {\n+                    res = xmlBuildURISafe(ret, base, &newbase);\n@@ -5439,7 +5380,7 @@\n-            ret = newbase;\n-        } else {\n-            ret = base;\n-        }\n-        if ((!xmlStrncmp(ret, BAD_CAST \"http:\/\/\", 7)) ||\n-            (!xmlStrncmp(ret, BAD_CAST \"ftp:\/\/\", 6)) ||\n-            (!xmlStrncmp(ret, BAD_CAST \"urn:\", 4)))\n+                    ret = newbase;\n+                } else {\n+                    ret = base;\n+                }\n+                if ((!xmlStrncmp(ret, BAD_CAST \"http:\/\/\", 7)) ||\n+                    (!xmlStrncmp(ret, BAD_CAST \"ftp:\/\/\", 6)) ||\n+                    (!xmlStrncmp(ret, BAD_CAST \"urn:\", 4)))\n@@ -5447,0 +5388,1 @@\n+            }\n@@ -5448,2 +5390,1 @@\n-    }\n-    cur = cur->parent;\n+        cur = cur->parent;\n@@ -5453,2 +5394,2 @@\n-    if (ret == NULL) {\n-        ret = xmlStrdup(doc->URL);\n+        if (ret == NULL) {\n+            ret = xmlStrdup(doc->URL);\n@@ -5507,1 +5448,1 @@\n-    int ret;\n+    int ret1, ret2;\n@@ -5511,3 +5452,3 @@\n-    ret = xmlBufGetNodeContent(buf, cur);\n-    buffer = xmlBufBackToBuffer(buf);\n-    if ((ret < 0) || (buffer == NULL))\n+    ret1 = xmlBufGetNodeContent(buf, cur);\n+    ret2 = xmlBufBackToBuffer(buf, buffer);\n+    if ((ret1 < 0) || (ret2 < 0))\n@@ -5614,1 +5555,1 @@\n-        xmlBufCat(buf, cur->content);\n+            xmlBufCat(buf, cur->content);\n@@ -5622,2 +5563,2 @@\n-        xmlBufCat(buf, ((xmlNsPtr) cur)->href);\n-        break;\n+            xmlBufCat(buf, ((xmlNsPtr) cur)->href);\n+            break;\n@@ -5689,1 +5630,1 @@\n-        return(xmlStrdup(((xmlNsPtr) cur)->href));\n+            return(xmlStrdup(((xmlNsPtr) cur)->href));\n@@ -5695,1 +5636,1 @@\n-    buf = xmlBufCreateSize(64);\n+    buf = xmlBufCreate(50);\n@@ -5698,1 +5639,0 @@\n-    xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);\n@@ -5709,1 +5649,1 @@\n-    return(1);\n+        return(1);\n@@ -5717,1 +5657,1 @@\n-        break;\n+            break;\n@@ -5725,1 +5665,1 @@\n-        if (content != NULL) {\n+            if (content != NULL) {\n@@ -5729,1 +5669,1 @@\n-            copy = xmlStrndup(content, len);\n+                    copy = xmlStrndup(content, len);\n@@ -5732,1 +5672,1 @@\n-        }\n+            }\n@@ -5735,1 +5675,1 @@\n-        break;\n+            break;\n@@ -5773,1 +5713,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -5788,1 +5727,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -5806,1 +5744,1 @@\n-    return(1);\n+        return(1);\n@@ -5813,1 +5751,1 @@\n-        xmlNodePtr newNode, tmp;\n+            xmlNodePtr newNode, tmp;\n@@ -5815,2 +5753,2 @@\n-        newNode = xmlNewDocTextLen(cur->doc, content, len);\n-        if (newNode == NULL)\n+            newNode = xmlNewDocTextLen(cur->doc, content, len);\n+            if (newNode == NULL)\n@@ -5823,2 +5761,2 @@\n-        break;\n-    }\n+            break;\n+        }\n@@ -5826,1 +5764,1 @@\n-        break;\n+            break;\n@@ -5873,0 +5811,1 @@\n+\n@@ -5877,1 +5816,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5887,1 +5826,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n@@ -5931,0 +5869,1 @@\n+                        int newSize;\n@@ -5932,4 +5871,12 @@\n-                        maxns = maxns ? maxns * 2 : 10;\n-                        tmp = (xmlNsPtr *) xmlRealloc(namespaces,\n-                                                      (maxns + 1) *\n-                                                      sizeof(xmlNsPtr));\n+                        newSize = xmlGrowCapacity(maxns, sizeof(tmp[0]),\n+                                                  10, XML_MAX_ITEMS);\n+                        if (newSize < 0) {\n+                            xmlFree(namespaces);\n+                            return(-1);\n+                        }\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+                        if (newSize < 2)\n+                            newSize = 2;\n+#endif\n+                        tmp = xmlRealloc(namespaces,\n+                                         (newSize + 1) * sizeof(tmp[0]));\n@@ -5941,0 +5888,1 @@\n+                        maxns = newSize;\n@@ -5977,1 +5925,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -6017,1 +5964,1 @@\n-    return (ns);\n+        return (ns);\n@@ -6088,1 +6035,1 @@\n-    node = node->parent;\n+        node = node->parent;\n@@ -6312,1 +6259,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6315,1 +6262,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6331,1 +6278,1 @@\n-    snprintf((char *) prefix, sizeof(prefix), \"default\");\n+        snprintf((char *) prefix, sizeof(prefix), \"default\");\n@@ -6333,1 +6280,1 @@\n-    snprintf((char *) prefix, sizeof(prefix), \"%.20s\", (char *)ns->prefix);\n+        snprintf((char *) prefix, sizeof(prefix), \"%.20s\", (char *)ns->prefix);\n@@ -6340,6 +6287,6 @@\n-    if (ns->prefix == NULL)\n-        snprintf((char *) prefix, sizeof(prefix), \"default%d\", counter++);\n-    else\n-        snprintf((char *) prefix, sizeof(prefix), \"%.20s%d\",\n-        (char *)ns->prefix, counter++);\n-    res = xmlSearchNsSafe(tree, prefix, &def);\n+        if (ns->prefix == NULL)\n+            snprintf((char *) prefix, sizeof(prefix), \"default%d\", counter++);\n+        else\n+            snprintf((char *) prefix, sizeof(prefix), \"%.20s%d\",\n+                (char *)ns->prefix, counter++);\n+        res = xmlSearchNsSafe(tree, prefix, &def);\n@@ -6357,2 +6304,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n-\n@@ -6364,0 +6309,18 @@\n+static int\n+xmlGrowNsCache(xmlNsCache **cache, int *capacity) {\n+    xmlNsCache *tmp;\n+    int newSize;\n+\n+    newSize = xmlGrowCapacity(*capacity, sizeof(tmp[0]),\n+                              10, XML_MAX_ITEMS);\n+    if (newSize < 0)\n+        return(-1);\n+    tmp = xmlRealloc(*cache, newSize * sizeof(tmp[0]));\n+    if (tmp == NULL)\n+        return(-1);\n+    *cache = tmp;\n+    *capacity = newSize;\n+\n+    return(0);\n+}\n+\n@@ -6394,12 +6357,1 @@\n-     * Reconciliate the node namespace\n-     *\/\n-    if (node->ns != NULL) {\n-        for (i = 0; i < nbCache; i++) {\n-            if (cache[i].oldNs == node->ns) {\n-            node->ns = cache[i].newNs;\n-            break;\n-        }\n-        }\n-        if (i == nbCache) {\n-            \/*\n-         * OK we need to recreate a new namespace definition\n+         * Reconciliate the node namespace\n@@ -6407,2 +6359,13 @@\n-        n = xmlNewReconciledNs(tree, node->ns);\n-        if (n == NULL) {\n+        if (node->ns != NULL) {\n+            for (i = 0; i < nbCache; i++) {\n+                if (cache[i].oldNs == node->ns) {\n+                    node->ns = cache[i].newNs;\n+                    break;\n+                }\n+            }\n+            if (i == nbCache) {\n+                \/*\n+                 * OK we need to recreate a new namespace definition\n+                 *\/\n+                n = xmlNewReconciledNs(tree, node->ns);\n+                if (n == NULL) {\n@@ -6411,16 +6374,7 @@\n-            \/*\n-             * check if we need to grow the cache buffers.\n-             *\/\n-            if (sizeCache <= nbCache) {\n-                        xmlNsCache *tmp;\n-                        size_t newSize = sizeCache ? sizeCache * 2 : 10;\n-\n-            tmp = xmlRealloc(cache, newSize * sizeof(tmp[0]));\n-                if (tmp == NULL) {\n-                            ret = -1;\n-            } else {\n-                            cache = tmp;\n-                            sizeCache = newSize;\n-                        }\n-            }\n-            if (nbCache < sizeCache) {\n+                    \/*\n+                     * check if we need to grow the cache buffers.\n+                     *\/\n+                    if ((sizeCache <= nbCache) &&\n+                        (xmlGrowNsCache(&cache, &sizeCache) < 0)) {\n+                        ret = -1;\n+                    } else {\n@@ -6431,15 +6385,1 @@\n-        node->ns = n;\n-        }\n-    }\n-    \/*\n-     * now check for namespace held by attributes on the node.\n-     *\/\n-    if (node->type == XML_ELEMENT_NODE) {\n-        attr = node->properties;\n-        while (attr != NULL) {\n-        if (attr->ns != NULL) {\n-            for (i = 0; i < nbCache; i++) {\n-            if (cache[i].oldNs == attr->ns) {\n-                attr->ns = cache[i].newNs;\n-                break;\n-            }\n+                node->ns = n;\n@@ -6447,6 +6387,20 @@\n-            if (i == nbCache) {\n-            \/*\n-             * OK we need to recreate a new namespace definition\n-             *\/\n-            n = xmlNewReconciledNs(tree, attr->ns);\n-            if (n == NULL) {\n+        }\n+        \/*\n+         * now check for namespace held by attributes on the node.\n+         *\/\n+        if (node->type == XML_ELEMENT_NODE) {\n+            attr = node->properties;\n+            while (attr != NULL) {\n+                if (attr->ns != NULL) {\n+                    for (i = 0; i < nbCache; i++) {\n+                        if (cache[i].oldNs == attr->ns) {\n+                            attr->ns = cache[i].newNs;\n+                            break;\n+                        }\n+                    }\n+                    if (i == nbCache) {\n+                        \/*\n+                         * OK we need to recreate a new namespace definition\n+                         *\/\n+                        n = xmlNewReconciledNs(tree, attr->ns);\n+                        if (n == NULL) {\n@@ -6455,18 +6409,7 @@\n-                \/*\n-                 * check if we need to grow the cache buffers.\n-                 *\/\n-                if (sizeCache <= nbCache) {\n-                                xmlNsCache *tmp;\n-                                size_t newSize = sizeCache ?\n-                                        sizeCache * 2 : 10;\n-\n-                                tmp = xmlRealloc(cache,\n-                                        newSize * sizeof(tmp[0]));\n-                                if (tmp == NULL) {\n-                                    ret = -1;\n-                                } else {\n-                                    cache = tmp;\n-                                    sizeCache = newSize;\n-                                }\n-                }\n-                if (nbCache < sizeCache) {\n+                            \/*\n+                             * check if we need to grow the cache buffers.\n+                             *\/\n+                            if ((sizeCache <= nbCache) &&\n+                                (xmlGrowNsCache(&cache, &sizeCache) < 0)) {\n+                                ret = -1;\n+                            } else {\n@@ -6475,0 +6418,4 @@\n+                            }\n+                        }\n+                        attr->ns = n;\n+                    }\n@@ -6476,2 +6423,1 @@\n-            }\n-            attr->ns = n;\n+                attr = attr->next;\n@@ -6480,3 +6426,0 @@\n-        attr = attr->next;\n-        }\n-    }\n@@ -6484,3 +6427,3 @@\n-    \/*\n-     * Browse the full subtree, deep first\n-     *\/\n+        \/*\n+         * Browse the full subtree, deep first\n+         *\/\n@@ -6488,11 +6431,4 @@\n-        \/* deep first *\/\n-        node = node->children;\n-    } else if ((node != tree) && (node->next != NULL)) {\n-        \/* then siblings *\/\n-        node = node->next;\n-    } else if (node != tree) {\n-        \/* go up to parents->next if needed *\/\n-        while (node != tree) {\n-            if (node->parent != NULL)\n-            node = node->parent;\n-        if ((node != tree) && (node->next != NULL)) {\n+            \/* deep first *\/\n+            node = node->children;\n+        } else if ((node != tree) && (node->next != NULL)) {\n+            \/* then siblings *\/\n@@ -6500,0 +6436,18 @@\n+        } else if (node != tree) {\n+            \/* go up to parents->next if needed *\/\n+            while (node != tree) {\n+                if (node->parent != NULL)\n+                    node = node->parent;\n+                if ((node != tree) && (node->next != NULL)) {\n+                    node = node->next;\n+                    break;\n+                }\n+                if (node->parent == NULL) {\n+                    node = NULL;\n+                    break;\n+                }\n+            }\n+            \/* exit condition *\/\n+            if (node == tree)\n+                node = NULL;\n+        } else\n@@ -6501,11 +6455,0 @@\n-        }\n-        if (node->parent == NULL) {\n-            node = NULL;\n-            break;\n-        }\n-        }\n-        \/* exit condition *\/\n-        if (node == tree)\n-            node = NULL;\n-    } else\n-        break;\n@@ -6514,1 +6457,1 @@\n-    xmlFree(cache);\n+        xmlFree(cache);\n@@ -6517,1 +6460,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -6521,1 +6463,1 @@\n-               const xmlChar *nsName, int useDTD)\n+                       const xmlChar *nsName, int useDTD)\n@@ -6529,1 +6471,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6532,21 +6474,24 @@\n-    prop = node->properties;\n-    if (nsName == NULL) {\n-        \/*\n-        * We want the attr to be in no namespace.\n-        *\/\n-        do {\n-        if ((prop->ns == NULL) && xmlStrEqual(prop->name, name)) {\n-            return(prop);\n-        }\n-        prop = prop->next;\n-        } while (prop != NULL);\n-    } else {\n-        \/*\n-        * We want the attr to be in the specified namespace.\n-        *\/\n-        do {\n-        if ((prop->ns != NULL) && xmlStrEqual(prop->name, name) &&\n-            ((prop->ns->href == nsName) ||\n-             xmlStrEqual(prop->ns->href, nsName)))\n-        {\n-            return(prop);\n+        prop = node->properties;\n+        if (nsName == NULL) {\n+            \/*\n+            * We want the attr to be in no namespace.\n+            *\/\n+            do {\n+                if ((prop->ns == NULL) && xmlStrEqual(prop->name, name)) {\n+                    return(prop);\n+                }\n+                prop = prop->next;\n+            } while (prop != NULL);\n+        } else {\n+            \/*\n+            * We want the attr to be in the specified namespace.\n+            *\/\n+            do {\n+                if ((prop->ns != NULL) && xmlStrEqual(prop->name, name) &&\n+                    ((prop->ns->href == nsName) ||\n+                     xmlStrEqual(prop->ns->href, nsName)))\n+                {\n+                    return(prop);\n+                }\n+                prop = prop->next;\n+            } while (prop != NULL);\n@@ -6554,3 +6499,0 @@\n-        prop = prop->next;\n-        } while (prop != NULL);\n-    }\n@@ -6559,1 +6501,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -6561,1 +6502,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6567,3 +6508,3 @@\n-    xmlDocPtr doc = node->doc;\n-    xmlAttributePtr attrDecl = NULL;\n-    xmlChar *elemQName, *tmpstr = NULL;\n+        xmlDocPtr doc = node->doc;\n+        xmlAttributePtr attrDecl = NULL;\n+        xmlChar *elemQName, *tmpstr = NULL;\n@@ -6571,17 +6512,0 @@\n-    \/*\n-    * We need the QName of the element for the DTD-lookup.\n-    *\/\n-    if ((node->ns != NULL) && (node->ns->prefix != NULL)) {\n-        tmpstr = xmlStrdup(node->ns->prefix);\n-        if (tmpstr == NULL)\n-        return(NULL);\n-        tmpstr = xmlStrcat(tmpstr, BAD_CAST \":\");\n-        if (tmpstr == NULL)\n-        return(NULL);\n-        tmpstr = xmlStrcat(tmpstr, node->name);\n-        if (tmpstr == NULL)\n-        return(NULL);\n-        elemQName = tmpstr;\n-    } else\n-        elemQName = (xmlChar *) node->name;\n-    if (nsName == NULL) {\n@@ -6589,1 +6513,1 @@\n-        * The common and nice case: Attr in no namespace.\n+        * We need the QName of the element for the DTD-lookup.\n@@ -6591,6 +6515,23 @@\n-        attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,\n-        elemQName, name, NULL);\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n-        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,\n-            elemQName, name, NULL);\n-        }\n+        if ((node->ns != NULL) && (node->ns->prefix != NULL)) {\n+            tmpstr = xmlStrdup(node->ns->prefix);\n+            if (tmpstr == NULL)\n+                return(NULL);\n+            tmpstr = xmlStrcat(tmpstr, BAD_CAST \":\");\n+            if (tmpstr == NULL)\n+                return(NULL);\n+            tmpstr = xmlStrcat(tmpstr, node->name);\n+            if (tmpstr == NULL)\n+                return(NULL);\n+            elemQName = tmpstr;\n+        } else\n+            elemQName = (xmlChar *) node->name;\n+        if (nsName == NULL) {\n+            \/*\n+            * The common and nice case: Attr in no namespace.\n+            *\/\n+            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,\n+                elemQName, name, NULL);\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n+                attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,\n+                    elemQName, name, NULL);\n+            }\n@@ -6598,11 +6539,11 @@\n-        \/*\n-        * The XML namespace must be bound to prefix 'xml'.\n-        *\/\n-        attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,\n-        elemQName, name, BAD_CAST \"xml\");\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n-        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,\n-            elemQName, name, BAD_CAST \"xml\");\n-        }\n-    } else {\n-        xmlNsPtr *nsList, *cur;\n+            \/*\n+            * The XML namespace must be bound to prefix 'xml'.\n+            *\/\n+            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset,\n+                elemQName, name, BAD_CAST \"xml\");\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n+                attrDecl = xmlGetDtdQAttrDesc(doc->extSubset,\n+                    elemQName, name, BAD_CAST \"xml\");\n+            }\n+        } else {\n+            xmlNsPtr *nsList, *cur;\n@@ -6610,22 +6551,9 @@\n-        \/*\n-        * The ugly case: Search using the prefixes of in-scope\n-        * ns-decls corresponding to @nsName.\n-        *\/\n-        nsList = xmlGetNsList(node->doc, node);\n-        if (nsList == NULL) {\n-        if (tmpstr != NULL)\n-            xmlFree(tmpstr);\n-        return(NULL);\n-        }\n-        cur = nsList;\n-        while (*cur != NULL) {\n-        if (xmlStrEqual((*cur)->href, nsName)) {\n-            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elemQName,\n-            name, (*cur)->prefix);\n-            if (attrDecl)\n-            break;\n-            if (doc->extSubset != NULL) {\n-            attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elemQName,\n-                name, (*cur)->prefix);\n-            if (attrDecl)\n-                break;\n+            \/*\n+            * The ugly case: Search using the prefixes of in-scope\n+            * ns-decls corresponding to @nsName.\n+            *\/\n+            nsList = xmlGetNsList(node->doc, node);\n+            if (nsList == NULL) {\n+                if (tmpstr != NULL)\n+                    xmlFree(tmpstr);\n+                return(NULL);\n@@ -6633,0 +6561,17 @@\n+            cur = nsList;\n+            while (*cur != NULL) {\n+                if (xmlStrEqual((*cur)->href, nsName)) {\n+                    attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elemQName,\n+                        name, (*cur)->prefix);\n+                    if (attrDecl)\n+                        break;\n+                    if (doc->extSubset != NULL) {\n+                        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elemQName,\n+                            name, (*cur)->prefix);\n+                        if (attrDecl)\n+                            break;\n+                    }\n+                }\n+                cur++;\n+            }\n+            xmlFree(nsList);\n@@ -6634,11 +6579,7 @@\n-        cur++;\n-        }\n-        xmlFree(nsList);\n-    }\n-    if (tmpstr != NULL)\n-        xmlFree(tmpstr);\n-    \/*\n-    * Only default\/fixed attrs are relevant.\n-    *\/\n-    if ((attrDecl != NULL) && (attrDecl->defaultValue != NULL))\n-        return((xmlAttrPtr) attrDecl);\n+        if (tmpstr != NULL)\n+            xmlFree(tmpstr);\n+        \/*\n+        * Only default\/fixed attrs are relevant.\n+        *\/\n+        if ((attrDecl != NULL) && (attrDecl->defaultValue != NULL))\n+            return((xmlAttrPtr) attrDecl);\n@@ -6646,1 +6587,1 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n+\n@@ -6654,1 +6595,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6656,1 +6597,1 @@\n-    return(xmlNodeGetContent((xmlNodePtr) prop));\n+        return(xmlNodeGetContent((xmlNodePtr) prop));\n@@ -6658,1 +6599,1 @@\n-    return(xmlStrdup(((xmlAttributePtr)prop)->defaultValue));\n+        return(xmlStrdup(((xmlAttributePtr)prop)->defaultValue));\n@@ -6689,1 +6630,1 @@\n-        return(prop);\n+            return(prop);\n@@ -6691,1 +6632,1 @@\n-    prop = prop->next;\n+        prop = prop->next;\n@@ -6702,3 +6643,3 @@\n-        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, node->name, name);\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdAttrDesc(doc->extSubset, node->name, name);\n+            attrDecl = xmlGetDtdAttrDesc(doc->intSubset, node->name, name);\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdAttrDesc(doc->extSubset, node->name, name);\n@@ -6708,2 +6649,2 @@\n-        return((xmlAttrPtr) attrDecl);\n-    }\n+                return((xmlAttrPtr) attrDecl);\n+        }\n@@ -6765,1 +6706,1 @@\n-    return(1);\n+        return(1);\n@@ -6799,1 +6740,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6827,1 +6768,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6855,1 +6796,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6859,1 +6800,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n@@ -6875,1 +6815,1 @@\n-    return(-1);\n+        return(-1);\n@@ -6897,1 +6837,1 @@\n-    return(-1);\n+        return(-1);\n@@ -6902,1 +6842,0 @@\n-#endif\n@@ -6904,1 +6843,0 @@\n-#if defined(LIBXML_TREE_ENABLED) || defined(LIBXML_XINCLUDE_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED) || defined(LIBXML_HTML_ENABLED)\n@@ -6927,1 +6865,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6937,2 +6875,2 @@\n-    res = xmlSearchNsSafe(node, prefix, &ns);\n-    xmlFree(prefix);\n+        res = xmlSearchNsSafe(node, prefix, &ns);\n+        xmlFree(prefix);\n@@ -6962,1 +6900,1 @@\n-         const xmlChar *value)\n+             const xmlChar *value)\n@@ -6967,1 +6905,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6975,3 +6913,3 @@\n-    \/*\n-    * Modify the attribute's value.\n-    *\/\n+        \/*\n+        * Modify the attribute's value.\n+        *\/\n@@ -6979,1 +6917,1 @@\n-        children = xmlNewDocText(node->doc, value);\n+            children = xmlNewDocText(node->doc, value);\n@@ -6984,13 +6922,7 @@\n-    if (prop->atype == XML_ATTRIBUTE_ID) {\n-        xmlRemoveID(node->doc, prop);\n-        prop->atype = XML_ATTRIBUTE_ID;\n-    }\n-    if (prop->children != NULL)\n-        xmlFreeNodeList(prop->children);\n-    prop->children = NULL;\n-    prop->last = NULL;\n-    prop->ns = ns;\n-    if (value != NULL) {\n-        xmlNodePtr tmp;\n-\n-        prop->children = children;\n+        if (prop->atype == XML_ATTRIBUTE_ID) {\n+            xmlRemoveID(node->doc, prop);\n+            prop->atype = XML_ATTRIBUTE_ID;\n+        }\n+        if (prop->children != NULL)\n+            xmlFreeNodeList(prop->children);\n+        prop->children = NULL;\n@@ -6998,6 +6930,13 @@\n-        tmp = prop->children;\n-        while (tmp != NULL) {\n-        tmp->parent = (xmlNodePtr) prop;\n-        if (tmp->next == NULL)\n-            prop->last = tmp;\n-        tmp = tmp->next;\n+        prop->ns = ns;\n+        if (value != NULL) {\n+            xmlNodePtr tmp;\n+\n+            prop->children = children;\n+            prop->last = NULL;\n+            tmp = prop->children;\n+            while (tmp != NULL) {\n+                tmp->parent = (xmlNodePtr) prop;\n+                if (tmp->next == NULL)\n+                    prop->last = tmp;\n+                tmp = tmp->next;\n+            }\n@@ -7005,3 +6944,2 @@\n-    }\n-    if ((prop->atype == XML_ATTRIBUTE_ID) &&\n-        (xmlAddIDSafe(prop, value) < 0)) {\n+        if ((prop->atype == XML_ATTRIBUTE_ID) &&\n+            (xmlAddIDSafe(prop, value) < 0)) {\n@@ -7010,1 +6948,1 @@\n-    return(prop);\n+        return(prop);\n@@ -7018,2 +6956,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n-\n@@ -7051,1 +6987,1 @@\n-    return(0);\n+        return(0);\n@@ -7055,2 +6991,2 @@\n-    if (!IS_BLANK_CH(*cur)) return(0);\n-    cur++;\n+        if (!IS_BLANK_CH(*cur)) return(0);\n+        cur++;\n@@ -7082,2 +7018,2 @@\n-    (node->type != XML_COMMENT_NODE) &&\n-    (node->type != XML_PI_NODE))\n+        (node->type != XML_COMMENT_NODE) &&\n+        (node->type != XML_PI_NODE))\n@@ -7089,32 +7025,0 @@\n-\/************************************************************************\n- *                                    *\n- *            Output : to a FILE or in memory            *\n- *                                    *\n- ************************************************************************\/\n-\n-\/**\n- * xmlBufferCreate:\n- *\n- * routine to create an XML buffer.\n- * returns the new structure.\n- *\/\n-xmlBufferPtr\n-xmlBufferCreate(void) {\n-    xmlBufferPtr ret;\n-\n-    ret = (xmlBufferPtr) xmlMalloc(sizeof(xmlBuffer));\n-    if (ret == NULL)\n-        return(NULL);\n-    ret->use = 0;\n-    ret->size = xmlDefaultBufferSize;\n-    ret->alloc = xmlBufferAllocScheme;\n-    ret->content = (xmlChar *) xmlMallocAtomic(ret->size);\n-    if (ret->content == NULL) {\n-    xmlFree(ret);\n-        return(NULL);\n-    }\n-    ret->content[0] = 0;\n-    ret->contentIO = NULL;\n-    return(ret);\n-}\n-\n@@ -7122,2 +7026,2 @@\n- * xmlBufferCreateSize:\n- * @size: initial size of buffer\n+ * xmlGetDocCompressMode:\n+ * @doc:  the document\n@@ -7125,2 +7029,2 @@\n- * routine to create an XML buffer.\n- * returns the new structure.\n+ * get the compression ratio for a document, ZLIB based\n+ * Returns 0 (uncompressed) to 9 (max compression)\n@@ -7128,23 +7032,4 @@\n-xmlBufferPtr\n-xmlBufferCreateSize(size_t size) {\n-    xmlBufferPtr ret;\n-\n-    if (size >= UINT_MAX)\n-        return(NULL);\n-    ret = (xmlBufferPtr) xmlMalloc(sizeof(xmlBuffer));\n-    if (ret == NULL)\n-        return(NULL);\n-    ret->use = 0;\n-    ret->alloc = xmlBufferAllocScheme;\n-    ret->size = (size ? size + 1 : 0);         \/* +1 for ending null *\/\n-    if (ret->size){\n-        ret->content = (xmlChar *) xmlMallocAtomic(ret->size);\n-        if (ret->content == NULL) {\n-            xmlFree(ret);\n-            return(NULL);\n-        }\n-        ret->content[0] = 0;\n-    } else\n-    ret->content = NULL;\n-    ret->contentIO = NULL;\n-    return(ret);\n+int\n+xmlGetDocCompressMode (const xmlDoc *doc) {\n+    if (doc == NULL) return(-1);\n+    return(doc->compression);\n@@ -7154,6 +7039,3 @@\n- * xmlBufferDetach:\n- * @buf:  the buffer\n- *\n- * Remove the string contained in a buffer and gie it back to the\n- * caller. The buffer is reset to an empty content.\n- * This doesn't work with immutable buffers as they can't be reset.\n+ * xmlSetDocCompressMode:\n+ * @doc:  the document\n+ * @mode:  the compression ratio\n@@ -7161,1 +7043,2 @@\n- * Returns the previous string contained by the buffer.\n+ * set the compression ratio for a document, ZLIB based\n+ * Correct values: 0 (uncompressed) to 9 (max compression)\n@@ -7163,13 +7046,6 @@\n-xmlChar *\n-xmlBufferDetach(xmlBufferPtr buf) {\n-    xmlChar *ret;\n-\n-    if (buf == NULL)\n-        return(NULL);\n-\n-    ret = buf->content;\n-    buf->content = NULL;\n-    buf->size = 0;\n-    buf->use = 0;\n-\n-    return ret;\n+void\n+xmlSetDocCompressMode (xmlDocPtr doc, int mode) {\n+    if (doc == NULL) return;\n+    if (mode < 0) doc->compression = 0;\n+    else if (mode > 9) doc->compression = 9;\n+    else doc->compression = mode;\n@@ -7178,1 +7054,0 @@\n-\n@@ -7180,3 +7055,1 @@\n- * xmlBufferCreateStatic:\n- * @mem: the memory area\n- * @size:  the size in byte\n+ * xmlGetCompressMode:\n@@ -7184,14 +7057,1 @@\n- * Returns an XML buffer initialized with bytes.\n- *\/\n-xmlBufferPtr\n-xmlBufferCreateStatic(void *mem, size_t size) {\n-    xmlBufferPtr buf = xmlBufferCreateSize(size);\n-\n-    xmlBufferAdd(buf, mem, size);\n-    return(buf);\n-}\n-\n-\/**\n- * xmlBufferSetAllocationScheme:\n- * @buf:  the buffer to tune\n- * @scheme:  allocation scheme to use\n+ * DEPRECATED: Use xmlGetDocCompressMode\n@@ -7199,1 +7059,2 @@\n- * Sets the allocation scheme for this buffer\n+ * get the default compression mode used, ZLIB based.\n+ * Returns 0 (uncompressed) to 9 (max compression)\n@@ -7201,11 +7062,4 @@\n-void\n-xmlBufferSetAllocationScheme(xmlBufferPtr buf,\n-                             xmlBufferAllocationScheme scheme) {\n-    if (buf == NULL) {\n-        return;\n-    }\n-    if (buf->alloc == XML_BUFFER_ALLOC_IO) return;\n-    if ((scheme == XML_BUFFER_ALLOC_DOUBLEIT) ||\n-        (scheme == XML_BUFFER_ALLOC_EXACT) ||\n-        (scheme == XML_BUFFER_ALLOC_HYBRID))\n-    buf->alloc = scheme;\n+int\n+xmlGetCompressMode(void)\n+{\n+    return (xmlCompressMode);\n@@ -7215,2 +7069,2 @@\n- * xmlBufferFree:\n- * @buf:  the buffer to free\n+ * xmlSetCompressMode:\n+ * @mode:  the compression ratio\n@@ -7218,21 +7072,1 @@\n- * Frees an XML buffer. It frees both the content and the structure which\n- * encapsulate it.\n- *\/\n-void\n-xmlBufferFree(xmlBufferPtr buf) {\n-    if (buf == NULL) {\n-    return;\n-    }\n-\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) &&\n-        (buf->contentIO != NULL)) {\n-        xmlFree(buf->contentIO);\n-    } else if (buf->content != NULL) {\n-        xmlFree(buf->content);\n-    }\n-    xmlFree(buf);\n-}\n-\n-\/**\n- * xmlBufferEmpty:\n- * @buf:  the buffer\n+ * DEPRECATED: Use xmlSetDocCompressMode\n@@ -7240,1 +7074,2 @@\n- * empty a buffer.\n+ * set the default compression mode used, ZLIB based\n+ * Correct values: 0 (uncompressed) to 9 (max compression)\n@@ -7243,13 +7078,4 @@\n-xmlBufferEmpty(xmlBufferPtr buf) {\n-    if (buf == NULL) return;\n-    if (buf->content == NULL) return;\n-    buf->use = 0;\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n-        size_t start_buf = buf->content - buf->contentIO;\n-\n-    buf->size += start_buf;\n-        buf->content = buf->contentIO;\n-        buf->content[0] = 0;\n-    } else {\n-        buf->content[0] = 0;\n-    }\n+xmlSetCompressMode(int mode) {\n+    if (mode < 0) xmlCompressMode = 0;\n+    else if (mode > 9) xmlCompressMode = 9;\n+    else xmlCompressMode = mode;\n@@ -7258,14 +7084,4 @@\n-\/**\n- * xmlBufferShrink:\n- * @buf:  the buffer to dump\n- * @len:  the number of xmlChar to remove\n- *\n- * Remove the beginning of an XML buffer.\n- *\n- * Returns the number of #xmlChar removed, or -1 in case of failure.\n- *\/\n-int\n-xmlBufferShrink(xmlBufferPtr buf, unsigned int len) {\n-    if (buf == NULL) return(-1);\n-    if (len == 0) return(0);\n-    if (len > buf->use) return(-1);\n+#define XML_TREE_NSMAP_PARENT -1\n+#define XML_TREE_NSMAP_XML -2\n+#define XML_TREE_NSMAP_DOC -3\n+#define XML_TREE_NSMAP_CUSTOM -4\n@@ -7273,2 +7089,7 @@\n-    buf->use -= len;\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n+typedef struct xmlNsMapItem *xmlNsMapItemPtr;\n+struct xmlNsMapItem {\n+    xmlNsMapItemPtr next;\n+    xmlNsMapItemPtr prev;\n+    xmlNsPtr oldNs; \/* old ns decl reference *\/\n+    xmlNsPtr newNs; \/* new ns decl reference *\/\n+    int shadowDepth; \/* Shadowed at this depth *\/\n@@ -7276,538 +7097,9 @@\n-     * we just move the content pointer, but also make sure\n-     * the perceived buffer size has shrunk accordingly\n-     *\/\n-        buf->content += len;\n-    buf->size -= len;\n-\n-        \/*\n-     * sometimes though it maybe be better to really shrink\n-     * on IO buffers\n-     *\/\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n-        size_t start_buf = buf->content - buf->contentIO;\n-        if (start_buf >= buf->size) {\n-        memmove(buf->contentIO, &buf->content[0], buf->use);\n-        buf->content = buf->contentIO;\n-        buf->content[buf->use] = 0;\n-        buf->size += start_buf;\n-        }\n-    }\n-    } else {\n-    memmove(buf->content, &buf->content[len], buf->use);\n-    buf->content[buf->use] = 0;\n-    }\n-    return(len);\n-}\n-\n-\/**\n- * xmlBufferGrow:\n- * @buf:  the buffer\n- * @len:  the minimum free size to allocate\n- *\n- * Grow the available space of an XML buffer.\n- *\n- * Returns the new available space or -1 in case of error\n- *\/\n-int\n-xmlBufferGrow(xmlBufferPtr buf, unsigned int len) {\n-    unsigned int size;\n-    xmlChar *newbuf;\n-\n-    if (buf == NULL) return(-1);\n-\n-    if (len < buf->size - buf->use)\n-        return(0);\n-    if (len >= UINT_MAX - buf->use)\n-        return(-1);\n-\n-    if (buf->size > (size_t) len) {\n-        size = buf->size > UINT_MAX \/ 2 ? UINT_MAX : buf->size * 2;\n-    } else {\n-        size = buf->use + len;\n-        size = size > UINT_MAX - 100 ? UINT_MAX : size + 100;\n-    }\n-\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n-        size_t start_buf = buf->content - buf->contentIO;\n-\n-    newbuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + size);\n-    if (newbuf == NULL)\n-        return(-1);\n-    buf->contentIO = newbuf;\n-    buf->content = newbuf + start_buf;\n-    } else {\n-    newbuf = (xmlChar *) xmlRealloc(buf->content, size);\n-    if (newbuf == NULL)\n-        return(-1);\n-    buf->content = newbuf;\n-    }\n-    buf->size = size;\n-    return(buf->size - buf->use - 1);\n-}\n-\n-\/**\n- * xmlBufferDump:\n- * @file:  the file output\n- * @buf:  the buffer to dump\n- *\n- * Dumps an XML buffer to  a FILE *.\n- * Returns the number of #xmlChar written\n- *\/\n-int\n-xmlBufferDump(FILE *file, xmlBufferPtr buf) {\n-    size_t ret;\n-\n-    if (buf == NULL) {\n-    return(0);\n-    }\n-    if (buf->content == NULL) {\n-    return(0);\n-    }\n-    if (file == NULL)\n-    file = stdout;\n-    ret = fwrite(buf->content, 1, buf->use, file);\n-    return(ret > INT_MAX ? INT_MAX : ret);\n-}\n-\n-\/**\n- * xmlBufferContent:\n- * @buf:  the buffer\n- *\n- * Function to extract the content of a buffer\n- *\n- * Returns the internal content\n- *\/\n-\n-const xmlChar *\n-xmlBufferContent(const xmlBuffer *buf)\n-{\n-    if(!buf)\n-        return NULL;\n-\n-    return buf->content;\n-}\n-\n-\/**\n- * xmlBufferLength:\n- * @buf:  the buffer\n- *\n- * Function to get the length of a buffer\n- *\n- * Returns the length of data in the internal content\n- *\/\n-\n-int\n-xmlBufferLength(const xmlBuffer *buf)\n-{\n-    if(!buf)\n-        return 0;\n-\n-    return buf->use;\n-}\n-\n-\/**\n- * xmlBufferResize:\n- * @buf:  the buffer to resize\n- * @size:  the desired size\n- *\n- * Resize a buffer to accommodate minimum size of @size.\n- *\n- * Returns  0 in case of problems, 1 otherwise\n- *\/\n-int\n-xmlBufferResize(xmlBufferPtr buf, unsigned int size)\n-{\n-    unsigned int newSize;\n-    xmlChar* rebuf = NULL;\n-    size_t start_buf;\n-\n-    if (buf == NULL)\n-        return(0);\n-\n-    \/* Don't resize if we don't have to *\/\n-    if (size < buf->size)\n-        return 1;\n-\n-    if (size > UINT_MAX - 10)\n-        return 0;\n-\n-    \/* figure out new size *\/\n-    switch (buf->alloc){\n-    case XML_BUFFER_ALLOC_IO:\n-    case XML_BUFFER_ALLOC_DOUBLEIT:\n-        \/*take care of empty case*\/\n-            if (buf->size == 0)\n-                newSize = size + 10;\n-            else\n-                newSize = buf->size;\n-        while (size > newSize) {\n-            if (newSize > UINT_MAX \/ 2)\n-                return 0;\n-            newSize *= 2;\n-        }\n-        break;\n-    case XML_BUFFER_ALLOC_EXACT:\n-        newSize = size + 10;\n-        break;\n-        case XML_BUFFER_ALLOC_HYBRID:\n-            if (buf->use < BASE_BUFFER_SIZE)\n-                newSize = size;\n-            else {\n-                newSize = buf->size;\n-                while (size > newSize) {\n-                    if (newSize > UINT_MAX \/ 2)\n-                        return 0;\n-                    newSize *= 2;\n-                }\n-            }\n-            break;\n-\n-    default:\n-        newSize = size + 10;\n-        break;\n-    }\n-\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n-        start_buf = buf->content - buf->contentIO;\n-\n-        if (start_buf > newSize) {\n-        \/* move data back to start *\/\n-        memmove(buf->contentIO, buf->content, buf->use);\n-        buf->content = buf->contentIO;\n-        buf->content[buf->use] = 0;\n-        buf->size += start_buf;\n-    } else {\n-        rebuf = (xmlChar *) xmlRealloc(buf->contentIO, start_buf + newSize);\n-        if (rebuf == NULL)\n-        return 0;\n-        buf->contentIO = rebuf;\n-        buf->content = rebuf + start_buf;\n-    }\n-    } else {\n-    if (buf->content == NULL) {\n-        rebuf = (xmlChar *) xmlMallocAtomic(newSize);\n-        buf->use = 0;\n-        rebuf[buf->use] = 0;\n-    } else if (buf->size - buf->use < 100) {\n-        rebuf = (xmlChar *) xmlRealloc(buf->content, newSize);\n-        } else {\n-        \/*\n-         * if we are reallocating a buffer far from being full, it's\n-         * better to make a new allocation and copy only the used range\n-         * and free the old one.\n-         *\/\n-        rebuf = (xmlChar *) xmlMallocAtomic(newSize);\n-        if (rebuf != NULL) {\n-        memcpy(rebuf, buf->content, buf->use);\n-        xmlFree(buf->content);\n-        rebuf[buf->use] = 0;\n-        }\n-    }\n-    if (rebuf == NULL)\n-        return 0;\n-    buf->content = rebuf;\n-    }\n-    buf->size = newSize;\n-\n-    return 1;\n-}\n-\n-\/**\n- * xmlBufferAdd:\n- * @buf:  the buffer to dump\n- * @str:  the #xmlChar string\n- * @len:  the number of #xmlChar to add\n- *\n- * Add a string range to an XML buffer. if len == -1, the length of\n- * str is recomputed.\n- *\n- * Returns 0 successful, a positive error code number otherwise\n- *         and -1 in case of internal or API error.\n- *\/\n-int\n-xmlBufferAdd(xmlBufferPtr buf, const xmlChar *str, int len) {\n-    unsigned int needSize;\n-\n-    if ((str == NULL) || (buf == NULL)) {\n-    return -1;\n-    }\n-    if (len < -1) {\n-    return -1;\n-    }\n-    if (len == 0) return 0;\n-\n-    if (len < 0)\n-        len = xmlStrlen(str);\n-\n-    if (len < 0) return -1;\n-    if (len == 0) return 0;\n-\n-    \/* Note that both buf->size and buf->use can be zero here. *\/\n-    if ((unsigned) len >= buf->size - buf->use) {\n-        if ((unsigned) len >= UINT_MAX - buf->use)\n-            return XML_ERR_NO_MEMORY;\n-        needSize = buf->use + len + 1;\n-        if (!xmlBufferResize(buf, needSize))\n-            return XML_ERR_NO_MEMORY;\n-    }\n-\n-    memmove(&buf->content[buf->use], str, len);\n-    buf->use += len;\n-    buf->content[buf->use] = 0;\n-    return 0;\n-}\n-\n-\/**\n- * xmlBufferAddHead:\n- * @buf:  the buffer\n- * @str:  the #xmlChar string\n- * @len:  the number of #xmlChar to add\n- *\n- * Add a string range to the beginning of an XML buffer.\n- * if len == -1, the length of @str is recomputed.\n- *\n- * Returns 0 successful, a positive error code number otherwise\n- *         and -1 in case of internal or API error.\n- *\/\n-int\n-xmlBufferAddHead(xmlBufferPtr buf, const xmlChar *str, int len) {\n-    unsigned int needSize;\n-\n-    if (buf == NULL)\n-        return(-1);\n-    if (str == NULL) {\n-    return -1;\n-    }\n-    if (len < -1) {\n-    return -1;\n-    }\n-    if (len == 0) return 0;\n-\n-    if (len < 0)\n-        len = xmlStrlen(str);\n-\n-    if (len <= 0) return -1;\n-\n-    if ((buf->alloc == XML_BUFFER_ALLOC_IO) && (buf->contentIO != NULL)) {\n-        size_t start_buf = buf->content - buf->contentIO;\n-\n-    if (start_buf > (unsigned int) len) {\n-        \/*\n-         * We can add it in the space previously shrunk\n-         *\/\n-        buf->content -= len;\n-            memmove(&buf->content[0], str, len);\n-        buf->use += len;\n-        buf->size += len;\n-            buf->content[buf->use] = 0;\n-        return(0);\n-    }\n-    }\n-    \/* Note that both buf->size and buf->use can be zero here. *\/\n-    if ((unsigned) len >= buf->size - buf->use) {\n-        if ((unsigned) len >= UINT_MAX - buf->use)\n-            return(-1);\n-        needSize = buf->use + len + 1;\n-        if (!xmlBufferResize(buf, needSize))\n-            return(-1);\n-    }\n-\n-    memmove(&buf->content[len], &buf->content[0], buf->use);\n-    memmove(&buf->content[0], str, len);\n-    buf->use += len;\n-    buf->content[buf->use] = 0;\n-    return 0;\n-}\n-\n-\/**\n- * xmlBufferCat:\n- * @buf:  the buffer to add to\n- * @str:  the #xmlChar string\n- *\n- * Append a zero terminated string to an XML buffer.\n- *\n- * Returns 0 successful, a positive error code number otherwise\n- *         and -1 in case of internal or API error.\n- *\/\n-int\n-xmlBufferCat(xmlBufferPtr buf, const xmlChar *str) {\n-    if (buf == NULL)\n-        return(-1);\n-    if (str == NULL) return -1;\n-    return xmlBufferAdd(buf, str, -1);\n-}\n-\n-\/**\n- * xmlBufferCCat:\n- * @buf:  the buffer to dump\n- * @str:  the C char string\n- *\n- * Append a zero terminated C string to an XML buffer.\n- *\n- * Returns 0 successful, a positive error code number otherwise\n- *         and -1 in case of internal or API error.\n- *\/\n-int\n-xmlBufferCCat(xmlBufferPtr buf, const char *str) {\n-    return xmlBufferCat(buf, (const xmlChar *) str);\n-}\n-\n-\/**\n- * xmlBufferWriteCHAR:\n- * @buf:  the XML buffer\n- * @string:  the string to add\n- *\n- * routine which manages and grows an output buffer. This one adds\n- * xmlChars at the end of the buffer.\n- *\/\n-void\n-xmlBufferWriteCHAR(xmlBufferPtr buf, const xmlChar *string) {\n-    if (buf == NULL)\n-        return;\n-    xmlBufferCat(buf, string);\n-}\n-\n-\/**\n- * xmlBufferWriteChar:\n- * @buf:  the XML buffer output\n- * @string:  the string to add\n- *\n- * routine which manage and grows an output buffer. This one add\n- * C chars at the end of the array.\n- *\/\n-void\n-xmlBufferWriteChar(xmlBufferPtr buf, const char *string) {\n-    if (buf == NULL)\n-        return;\n-    xmlBufferCCat(buf, string);\n-}\n-\n-\n-\/**\n- * xmlBufferWriteQuotedString:\n- * @buf:  the XML buffer output\n- * @string:  the string to add\n- *\n- * routine which manage and grows an output buffer. This one writes\n- * a quoted or double quoted #xmlChar string, checking first if it holds\n- * quote or double-quotes internally\n- *\/\n-void\n-xmlBufferWriteQuotedString(xmlBufferPtr buf, const xmlChar *string) {\n-    const xmlChar *cur, *base;\n-    if (buf == NULL)\n-        return;\n-    if (xmlStrchr(string, '\\\"')) {\n-        if (xmlStrchr(string, '\\'')) {\n-        xmlBufferCCat(buf, \"\\\"\");\n-            base = cur = string;\n-            while(*cur != 0){\n-                if(*cur == '\"'){\n-                    if (base != cur)\n-                        xmlBufferAdd(buf, base, cur - base);\n-                    xmlBufferAdd(buf, BAD_CAST \"&quot;\", 6);\n-                    cur++;\n-                    base = cur;\n-                }\n-                else {\n-                    cur++;\n-                }\n-            }\n-            if (base != cur)\n-                xmlBufferAdd(buf, base, cur - base);\n-        xmlBufferCCat(buf, \"\\\"\");\n-    }\n-        else{\n-        xmlBufferCCat(buf, \"\\'\");\n-            xmlBufferCat(buf, string);\n-        xmlBufferCCat(buf, \"\\'\");\n-        }\n-    } else {\n-        xmlBufferCCat(buf, \"\\\"\");\n-        xmlBufferCat(buf, string);\n-        xmlBufferCCat(buf, \"\\\"\");\n-    }\n-}\n-\n-\n-\/**\n- * xmlGetDocCompressMode:\n- * @doc:  the document\n- *\n- * get the compression ratio for a document, ZLIB based\n- * Returns 0 (uncompressed) to 9 (max compression)\n- *\/\n-int\n-xmlGetDocCompressMode (const xmlDoc *doc) {\n-    if (doc == NULL) return(-1);\n-    return(doc->compression);\n-}\n-\n-\/**\n- * xmlSetDocCompressMode:\n- * @doc:  the document\n- * @mode:  the compression ratio\n- *\n- * set the compression ratio for a document, ZLIB based\n- * Correct values: 0 (uncompressed) to 9 (max compression)\n- *\/\n-void\n-xmlSetDocCompressMode (xmlDocPtr doc, int mode) {\n-    if (doc == NULL) return;\n-    if (mode < 0) doc->compression = 0;\n-    else if (mode > 9) doc->compression = 9;\n-    else doc->compression = mode;\n-}\n-\n-\/**\n- * xmlGetCompressMode:\n- *\n- * DEPRECATED: Use xmlGetDocCompressMode\n- *\n- * get the default compression mode used, ZLIB based.\n- * Returns 0 (uncompressed) to 9 (max compression)\n- *\/\n-int\n-xmlGetCompressMode(void)\n-{\n-    return (xmlCompressMode);\n-}\n-\n-\/**\n- * xmlSetCompressMode:\n- * @mode:  the compression ratio\n- *\n- * DEPRECATED: Use xmlSetDocCompressMode\n- *\n- * set the default compression mode used, ZLIB based\n- * Correct values: 0 (uncompressed) to 9 (max compression)\n- *\/\n-void\n-xmlSetCompressMode(int mode) {\n-    if (mode < 0) xmlCompressMode = 0;\n-    else if (mode > 9) xmlCompressMode = 9;\n-    else xmlCompressMode = mode;\n-}\n-\n-#define XML_TREE_NSMAP_PARENT -1\n-#define XML_TREE_NSMAP_XML -2\n-#define XML_TREE_NSMAP_DOC -3\n-#define XML_TREE_NSMAP_CUSTOM -4\n-\n-typedef struct xmlNsMapItem *xmlNsMapItemPtr;\n-struct xmlNsMapItem {\n-    xmlNsMapItemPtr next;\n-    xmlNsMapItemPtr prev;\n-    xmlNsPtr oldNs; \/* old ns decl reference *\/\n-    xmlNsPtr newNs; \/* new ns decl reference *\/\n-    int shadowDepth; \/* Shadowed at this depth *\/\n-    \/*\n-    * depth:\n-    * >= 0 == @node's ns-decls\n-    * -1   == @parent's ns-decls\n-    * -2   == the doc->oldNs XML ns-decl\n-    * -3   == the doc->oldNs storage ns-decls\n-    * -4   == ns-decls provided via custom ns-handling\n-    *\/\n-    int depth;\n-};\n+    * depth:\n+    * >= 0 == @node's ns-decls\n+    * -1   == @parent's ns-decls\n+    * -2   == the doc->oldNs XML ns-decl\n+    * -3   == the doc->oldNs storage ns-decls\n+    * -4   == ns-decls provided via custom ns-handling\n+    *\/\n+    int depth;\n+};\n@@ -7828,1 +7120,1 @@\n-    (m)->first = NULL; \\\n+        (m)->first = NULL; \\\n@@ -7830,1 +7122,1 @@\n-    (m)->last->next = NULL; \\\n+        (m)->last->next = NULL; \\\n@@ -7846,1 +7138,1 @@\n-    return;\n+        return;\n@@ -7849,3 +7141,3 @@\n-    tmp = cur;\n-    cur = cur->next;\n-    xmlFree(tmp);\n+        tmp = cur;\n+        cur = cur->next;\n+        xmlFree(tmp);\n@@ -7855,3 +7147,3 @@\n-    tmp = cur;\n-    cur = cur->next;\n-    xmlFree(tmp);\n+        tmp = cur;\n+        cur = cur->next;\n+        xmlFree(tmp);\n@@ -7873,1 +7165,1 @@\n-               xmlNsPtr oldNs, xmlNsPtr newNs, int depth)\n+                       xmlNsPtr oldNs, xmlNsPtr newNs, int depth)\n@@ -7879,1 +7171,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -7881,1 +7173,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -7885,8 +7177,8 @@\n-    \/*\n-    * Create the ns-map.\n-    *\/\n-    map = (xmlNsMapPtr) xmlMalloc(sizeof(struct xmlNsMap));\n-    if (map == NULL)\n-        return(NULL);\n-    memset(map, 0, sizeof(struct xmlNsMap));\n-    *nsmap = map;\n+        \/*\n+        * Create the ns-map.\n+        *\/\n+        map = (xmlNsMapPtr) xmlMalloc(sizeof(struct xmlNsMap));\n+        if (map == NULL)\n+            return(NULL);\n+        memset(map, 0, sizeof(struct xmlNsMap));\n+        *nsmap = map;\n@@ -7896,6 +7188,6 @@\n-    \/*\n-    * Reuse an item from the pool.\n-    *\/\n-    ret = map->pool;\n-    map->pool = ret->next;\n-    memset(ret, 0, sizeof(struct xmlNsMapItem));\n+        \/*\n+        * Reuse an item from the pool.\n+        *\/\n+        ret = map->pool;\n+        map->pool = ret->next;\n+        memset(ret, 0, sizeof(struct xmlNsMapItem));\n@@ -7903,7 +7195,7 @@\n-    \/*\n-    * Create a new item.\n-    *\/\n-    ret = (xmlNsMapItemPtr) xmlMalloc(sizeof(struct xmlNsMapItem));\n-    if (ret == NULL)\n-        return(NULL);\n-    memset(ret, 0, sizeof(struct xmlNsMapItem));\n+        \/*\n+        * Create a new item.\n+        *\/\n+        ret = (xmlNsMapItemPtr) xmlMalloc(sizeof(struct xmlNsMapItem));\n+        if (ret == NULL)\n+            return(NULL);\n+        memset(ret, 0, sizeof(struct xmlNsMapItem));\n@@ -7913,5 +7205,5 @@\n-    \/*\n-    * First ever.\n-    *\/\n-    map->first = ret;\n-    map->last = ret;\n+        \/*\n+        * First ever.\n+        *\/\n+        map->first = ret;\n+        map->last = ret;\n@@ -7919,6 +7211,6 @@\n-    \/*\n-    * Append.\n-    *\/\n-    ret->prev = map->last;\n-    map->last->next = ret;\n-    map->last = ret;\n+        \/*\n+        * Append.\n+        *\/\n+        ret->prev = map->last;\n+        map->last->next = ret;\n+        map->last = ret;\n@@ -7926,6 +7218,6 @@\n-    \/*\n-    * Set on first position.\n-    *\/\n-    map->first->prev = ret;\n-    ret->next = map->first;\n-    map->first = ret;\n+        \/*\n+        * Set on first position.\n+        *\/\n+        map->first->prev = ret;\n+        ret->next = map->first;\n+        map->first = ret;\n@@ -7955,2 +7247,2 @@\n-           const xmlChar *nsName,\n-           const xmlChar *prefix)\n+                   const xmlChar *nsName,\n+                   const xmlChar *prefix)\n@@ -7961,1 +7253,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -7964,1 +7256,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -7966,10 +7258,1 @@\n-    \/* Reuse. *\/\n-    ns = ns->next;\n-    while (ns != NULL) {\n-        if (((ns->prefix == prefix) ||\n-        xmlStrEqual(ns->prefix, prefix)) &&\n-        xmlStrEqual(ns->href, nsName)) {\n-        return (ns);\n-        }\n-        if (ns->next == NULL)\n-        break;\n+        \/* Reuse. *\/\n@@ -7977,1 +7260,10 @@\n-    }\n+        while (ns != NULL) {\n+            if (((ns->prefix == prefix) ||\n+                xmlStrEqual(ns->prefix, prefix)) &&\n+                xmlStrEqual(ns->href, nsName)) {\n+                return (ns);\n+            }\n+            if (ns->next == NULL)\n+                break;\n+            ns = ns->next;\n+        }\n@@ -8001,1 +7293,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -8016,1 +7308,1 @@\n-    return;\n+        return;\n@@ -8018,1 +7310,1 @@\n-    xmlDOMWrapNsMapFree((xmlNsMapPtr) ctxt->namespaceMap);\n+        xmlDOMWrapNsMapFree((xmlNsMapPtr) ctxt->namespaceMap);\n@@ -8039,1 +7331,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -8041,9 +7333,9 @@\n-    xmlNsPtr ns;\n-    ns = nsList;\n-    do {\n-        if ((prefix == ns->prefix) ||\n-        xmlStrEqual(prefix, ns->prefix)) {\n-        return (ns);\n-        }\n-        ns = ns->next;\n-    } while (ns != NULL);\n+        xmlNsPtr ns;\n+        ns = nsList;\n+        do {\n+            if ((prefix == ns->prefix) ||\n+                xmlStrEqual(prefix, ns->prefix)) {\n+                return (ns);\n+            }\n+            ns = ns->next;\n+        } while (ns != NULL);\n@@ -8066,1 +7358,1 @@\n-                xmlNodePtr node)\n+                                xmlNodePtr node)\n@@ -8074,1 +7366,1 @@\n-    return (-1);\n+        return (-1);\n@@ -8082,16 +7374,28 @@\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        if (cur->nsDef != NULL) {\n-        ns = cur->nsDef;\n-        do {\n-            shadowed = 0;\n-            if (XML_NSMAP_NOTEMPTY(*map)) {\n-            \/*\n-            * Skip shadowed prefixes.\n-            *\/\n-            XML_NSMAP_FOREACH(*map, mi) {\n-                if ((ns->prefix == mi->newNs->prefix) ||\n-                xmlStrEqual(ns->prefix, mi->newNs->prefix)) {\n-                shadowed = 1;\n-                break;\n-                }\n-            }\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            if (cur->nsDef != NULL) {\n+                ns = cur->nsDef;\n+                do {\n+                    shadowed = 0;\n+                    if (XML_NSMAP_NOTEMPTY(*map)) {\n+                        \/*\n+                        * Skip shadowed prefixes.\n+                        *\/\n+                        XML_NSMAP_FOREACH(*map, mi) {\n+                            if ((ns->prefix == mi->newNs->prefix) ||\n+                                xmlStrEqual(ns->prefix, mi->newNs->prefix)) {\n+                                shadowed = 1;\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    \/*\n+                    * Insert mapping.\n+                    *\/\n+                    mi = xmlDOMWrapNsMapAddItem(map, 0, NULL,\n+                        ns, XML_TREE_NSMAP_PARENT);\n+                    if (mi == NULL)\n+                        return (-1);\n+                    if (shadowed)\n+                        mi->shadowDepth = 0;\n+                    ns = ns->next;\n+                } while (ns != NULL);\n@@ -8099,11 +7403,0 @@\n-            \/*\n-            * Insert mapping.\n-            *\/\n-            mi = xmlDOMWrapNsMapAddItem(map, 0, NULL,\n-            ns, XML_TREE_NSMAP_PARENT);\n-            if (mi == NULL)\n-            return (-1);\n-            if (shadowed)\n-            mi->shadowDepth = 0;\n-            ns = ns->next;\n-        } while (ns != NULL);\n@@ -8111,2 +7404,1 @@\n-    }\n-    cur = cur->parent;\n+        cur = cur->parent;\n@@ -8126,1 +7418,1 @@\n-            xmlNsPtr oldNs, xmlNsPtr newNs)\n+                        xmlNsPtr oldNs, xmlNsPtr newNs)\n@@ -8130,1 +7422,1 @@\n-        size_t newSize;\n+        int newSize;\n@@ -8132,1 +7424,3 @@\n-        newSize = *size ? *size * 2 : 3;\n+        newSize = xmlGrowCapacity(*size, 2 * sizeof(tmp[0]), 3, XML_MAX_ITEMS);\n+        if (newSize < 0)\n+            return(-1);\n@@ -8165,1 +7459,1 @@\n-             xmlNodePtr node, int options ATTRIBUTE_UNUSED)\n+                     xmlNodePtr node, int options ATTRIBUTE_UNUSED)\n@@ -8172,1 +7466,1 @@\n-    return (-1);\n+        return (-1);\n@@ -8176,1 +7470,1 @@\n-    return (0);\n+        return (0);\n@@ -8179,12 +7473,12 @@\n-    case XML_TEXT_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_ENTITY_REF_NODE:\n-    case XML_PI_NODE:\n-    case XML_COMMENT_NODE:\n-        xmlUnlinkNodeInternal(node);\n-        return (0);\n-    case XML_ELEMENT_NODE:\n-    case XML_ATTRIBUTE_NODE:\n-        break;\n-    default:\n-        return (1);\n+        case XML_TEXT_NODE:\n+        case XML_CDATA_SECTION_NODE:\n+        case XML_ENTITY_REF_NODE:\n+        case XML_PI_NODE:\n+        case XML_COMMENT_NODE:\n+            xmlUnlinkNodeInternal(node);\n+            return (0);\n+        case XML_ELEMENT_NODE:\n+        case XML_ATTRIBUTE_NODE:\n+            break;\n+        default:\n+            return (1);\n@@ -8197,11 +7491,11 @@\n-    switch (node->type) {\n-        case XML_ELEMENT_NODE:\n-        if ((ctxt == NULL) && (node->nsDef != NULL)) {\n-            ns = node->nsDef;\n-            do {\n-            if (xmlDOMWrapNSNormAddNsMapItem2(&list, &sizeList,\n-                &nbList, ns, ns) == -1)\n-                ret = -1;\n-            ns = ns->next;\n-            } while (ns != NULL);\n-        }\n+        switch (node->type) {\n+            case XML_ELEMENT_NODE:\n+                if ((ctxt == NULL) && (node->nsDef != NULL)) {\n+                    ns = node->nsDef;\n+                    do {\n+                        if (xmlDOMWrapNSNormAddNsMapItem2(&list, &sizeList,\n+                            &nbList, ns, ns) == -1)\n+                            ret = -1;\n+                        ns = ns->next;\n+                    } while (ns != NULL);\n+                }\n@@ -8209,10 +7503,36 @@\n-        case XML_ATTRIBUTE_NODE:\n-        if (node->ns != NULL) {\n-            \/*\n-            * Find a mapping.\n-            *\/\n-            if (list != NULL) {\n-            for (i = 0, j = 0; i < nbList; i++, j += 2) {\n-                if (node->ns == list[j]) {\n-                node->ns = list[++j];\n-                goto next_node;\n+            case XML_ATTRIBUTE_NODE:\n+                if (node->ns != NULL) {\n+                    \/*\n+                    * Find a mapping.\n+                    *\/\n+                    if (list != NULL) {\n+                        for (i = 0, j = 0; i < nbList; i++, j += 2) {\n+                            if (node->ns == list[j]) {\n+                                node->ns = list[++j];\n+                                goto next_node;\n+                            }\n+                        }\n+                    }\n+                    ns = NULL;\n+                    if (ctxt != NULL) {\n+                        \/*\n+                        * User defined.\n+                        *\/\n+                    } else {\n+                        \/*\n+                        * Add to doc's oldNs.\n+                        *\/\n+                        ns = xmlDOMWrapStoreNs(doc, node->ns->href,\n+                            node->ns->prefix);\n+                        if (ns == NULL)\n+                            ret = -1;\n+                    }\n+                    if (ns != NULL) {\n+                        \/*\n+                        * Add mapping.\n+                        *\/\n+                        if (xmlDOMWrapNSNormAddNsMapItem2(&list, &sizeList,\n+                            &nbList, node->ns, ns) == -1)\n+                            ret = -1;\n+                    }\n+                    node->ns = ns;\n@@ -8220,25 +7540,8 @@\n-            }\n-            }\n-            ns = NULL;\n-            if (ctxt != NULL) {\n-            \/*\n-            * User defined.\n-            *\/\n-            } else {\n-            \/*\n-            * Add to doc's oldNs.\n-            *\/\n-            ns = xmlDOMWrapStoreNs(doc, node->ns->href,\n-                node->ns->prefix);\n-            if (ns == NULL)\n-                ret = -1;\n-            }\n-            if (ns != NULL) {\n-            \/*\n-            * Add mapping.\n-            *\/\n-            if (xmlDOMWrapNSNormAddNsMapItem2(&list, &sizeList,\n-                &nbList, node->ns, ns) == -1)\n-                ret = -1;\n-            }\n-            node->ns = ns;\n+                if ((node->type == XML_ELEMENT_NODE) &&\n+                    (node->properties != NULL)) {\n+                    node = (xmlNodePtr) node->properties;\n+                    continue;\n+                }\n+                break;\n+            default:\n+                goto next_sibling;\n@@ -8246,0 +7549,1 @@\n+next_node:\n@@ -8247,2 +7551,2 @@\n-            (node->properties != NULL)) {\n-            node = (xmlNodePtr) node->properties;\n+            (node->children != NULL)) {\n+            node = node->children;\n@@ -8251,10 +7555,0 @@\n-        break;\n-        default:\n-        goto next_sibling;\n-    }\n-next_node:\n-    if ((node->type == XML_ELEMENT_NODE) &&\n-        (node->children != NULL)) {\n-        node = node->children;\n-        continue;\n-    }\n@@ -8262,5 +7556,5 @@\n-    if (node == NULL)\n-        break;\n-    if (node->next != NULL)\n-        node = node->next;\n-    else {\n+        if (node == NULL)\n+            break;\n+        if (node->next != NULL)\n+            node = node->next;\n+        else {\n@@ -8269,1 +7563,1 @@\n-        node = node->parent;\n+            node = node->parent;\n@@ -8275,1 +7569,1 @@\n-            goto next_sibling;\n+                goto next_sibling;\n@@ -8277,1 +7571,1 @@\n-    }\n+        }\n@@ -8281,1 +7575,1 @@\n-    xmlFree(list);\n+        xmlFree(list);\n@@ -8301,2 +7595,2 @@\n-                 const xmlChar* nsName,\n-                 xmlNsPtr *retNs, int prefixed)\n+                             const xmlChar* nsName,\n+                             xmlNsPtr *retNs, int prefixed)\n@@ -8308,1 +7602,1 @@\n-    return (-1);\n+        return (-1);\n@@ -8314,4 +7608,4 @@\n-    *retNs = xmlTreeEnsureXMLDecl(doc);\n-    if (*retNs == NULL)\n-        return (-1);\n-    return (1);\n+        *retNs = xmlTreeEnsureXMLDecl(doc);\n+        if (*retNs == NULL)\n+            return (-1);\n+        return (1);\n@@ -8321,20 +7615,55 @@\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        if (cur->nsDef != NULL) {\n-        for (ns = cur->nsDef; ns != NULL; ns = ns->next) {\n-            if (prefixed && (ns->prefix == NULL))\n-            continue;\n-            if (prev != NULL) {\n-            \/*\n-            * Check the last level of ns-decls for a\n-            * shadowing prefix.\n-            *\/\n-            prevns = prev->nsDef;\n-            do {\n-                if ((prevns->prefix == ns->prefix) ||\n-                ((prevns->prefix != NULL) &&\n-                (ns->prefix != NULL) &&\n-                xmlStrEqual(prevns->prefix, ns->prefix))) {\n-                \/*\n-                * Shadowed.\n-                *\/\n-                break;\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            if (cur->nsDef != NULL) {\n+                for (ns = cur->nsDef; ns != NULL; ns = ns->next) {\n+                    if (prefixed && (ns->prefix == NULL))\n+                        continue;\n+                    if (prev != NULL) {\n+                        \/*\n+                        * Check the last level of ns-decls for a\n+                        * shadowing prefix.\n+                        *\/\n+                        prevns = prev->nsDef;\n+                        do {\n+                            if ((prevns->prefix == ns->prefix) ||\n+                                ((prevns->prefix != NULL) &&\n+                                (ns->prefix != NULL) &&\n+                                xmlStrEqual(prevns->prefix, ns->prefix))) {\n+                                \/*\n+                                * Shadowed.\n+                                *\/\n+                                break;\n+                            }\n+                            prevns = prevns->next;\n+                        } while (prevns != NULL);\n+                        if (prevns != NULL)\n+                            continue;\n+                    }\n+                    \/*\n+                    * Ns-name comparison.\n+                    *\/\n+                    if ((nsName == ns->href) ||\n+                        xmlStrEqual(nsName, ns->href)) {\n+                        \/*\n+                        * At this point the prefix can only be shadowed,\n+                        * if we are the the (at least) 3rd level of\n+                        * ns-decls.\n+                        *\/\n+                        if (out) {\n+                            int ret;\n+\n+                            ret = xmlNsInScope(doc, node, prev, ns->prefix);\n+                            if (ret < 0)\n+                                return (-1);\n+                            \/*\n+                            * TODO: Should we try to find a matching ns-name\n+                            * only once? This here keeps on searching.\n+                            * I think we should try further since, there might\n+                            * be an other matching ns-decl with an unshadowed\n+                            * prefix.\n+                            *\/\n+                            if (! ret)\n+                                continue;\n+                        }\n+                        *retNs = ns;\n+                        return (1);\n+                    }\n@@ -8342,4 +7671,2 @@\n-                prevns = prevns->next;\n-            } while (prevns != NULL);\n-            if (prevns != NULL)\n-                continue;\n+                out = prev;\n+                prev = cur;\n@@ -8347,36 +7674,3 @@\n-            \/*\n-            * Ns-name comparison.\n-            *\/\n-            if ((nsName == ns->href) ||\n-            xmlStrEqual(nsName, ns->href)) {\n-            \/*\n-            * At this point the prefix can only be shadowed,\n-            * if we are the the (at least) 3rd level of\n-            * ns-decls.\n-            *\/\n-            if (out) {\n-                int ret;\n-\n-                ret = xmlNsInScope(doc, node, prev, ns->prefix);\n-                if (ret < 0)\n-                return (-1);\n-                \/*\n-                * TODO: Should we try to find a matching ns-name\n-                * only once? This here keeps on searching.\n-                * I think we should try further since, there might\n-                * be an other matching ns-decl with an unshadowed\n-                * prefix.\n-                *\/\n-                if (! ret)\n-                continue;\n-            }\n-            *retNs = ns;\n-            return (1);\n-            }\n-        }\n-        out = prev;\n-        prev = cur;\n-        }\n-    } else if (cur->type == XML_ENTITY_DECL)\n-        return (0);\n-    cur = cur->parent;\n+        } else if (cur->type == XML_ENTITY_DECL)\n+            return (0);\n+        cur = cur->parent;\n@@ -8402,2 +7696,2 @@\n-              const xmlChar* prefix,\n-              xmlNsPtr *retNs)\n+                          const xmlChar* prefix,\n+                          xmlNsPtr *retNs)\n@@ -8412,1 +7706,1 @@\n-    *retNs = NULL;\n+        *retNs = NULL;\n@@ -8414,6 +7708,6 @@\n-    if (retNs) {\n-        *retNs = xmlTreeEnsureXMLDecl(doc);\n-        if (*retNs == NULL)\n-        return (-1);\n-    }\n-    return (1);\n+        if (retNs) {\n+            *retNs = xmlTreeEnsureXMLDecl(doc);\n+            if (*retNs == NULL)\n+                return (-1);\n+        }\n+        return (1);\n@@ -8423,15 +7717,18 @@\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        if (cur->nsDef != NULL) {\n-        ns = cur->nsDef;\n-        do {\n-            if ((prefix == ns->prefix) ||\n-            xmlStrEqual(prefix, ns->prefix))\n-            {\n-            \/*\n-            * Disabled namespaces, e.g. xmlns:abc=\"\".\n-            *\/\n-            if (ns->href == NULL)\n-                return(0);\n-            if (retNs)\n-                *retNs = ns;\n-            return (1);\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            if (cur->nsDef != NULL) {\n+                ns = cur->nsDef;\n+                do {\n+                    if ((prefix == ns->prefix) ||\n+                        xmlStrEqual(prefix, ns->prefix))\n+                    {\n+                        \/*\n+                        * Disabled namespaces, e.g. xmlns:abc=\"\".\n+                        *\/\n+                        if (ns->href == NULL)\n+                            return(0);\n+                        if (retNs)\n+                            *retNs = ns;\n+                        return (1);\n+                    }\n+                    ns = ns->next;\n+                } while (ns != NULL);\n@@ -8439,6 +7736,3 @@\n-            ns = ns->next;\n-        } while (ns != NULL);\n-        }\n-    } else if (cur->type == XML_ENTITY_DECL)\n-        return (0);\n-    cur = cur->parent;\n+        } else if (cur->type == XML_ENTITY_DECL)\n+            return (0);\n+        cur = cur->parent;\n@@ -8466,4 +7760,4 @@\n-                xmlNodePtr elem,\n-                const xmlChar *nsName,\n-                const xmlChar *prefix,\n-                int checkShadow)\n+                                xmlNodePtr elem,\n+                                const xmlChar *nsName,\n+                                const xmlChar *prefix,\n+                                int checkShadow)\n@@ -8484,8 +7778,0 @@\n-    \/*\n-    * Lookup whether the prefix is unused in elem's ns-decls.\n-    *\/\n-    if ((elem->nsDef != NULL) &&\n-        (xmlTreeNSListLookupByPrefix(elem->nsDef, pref) != NULL))\n-        goto ns_next_prefix;\n-    if (checkShadow && elem->parent &&\n-        ((xmlNodePtr) elem->parent->doc != elem->parent)) {\n@@ -8493,1 +7779,1 @@\n-        * Does it shadow ancestor ns-decls?\n+        * Lookup whether the prefix is unused in elem's ns-decls.\n@@ -8495,15 +7781,23 @@\n-        if (xmlSearchNsByPrefixStrict(doc, elem->parent, pref, NULL) == 1)\n-        goto ns_next_prefix;\n-    }\n-    ret = xmlNewNs(NULL, nsName, pref);\n-    if (ret == NULL)\n-        return (NULL);\n-    if (elem->nsDef == NULL)\n-        elem->nsDef = ret;\n-    else {\n-        xmlNsPtr ns2 = elem->nsDef;\n-        while (ns2->next != NULL)\n-        ns2 = ns2->next;\n-        ns2->next = ret;\n-    }\n-    return (ret);\n+        if ((elem->nsDef != NULL) &&\n+            (xmlTreeNSListLookupByPrefix(elem->nsDef, pref) != NULL))\n+            goto ns_next_prefix;\n+        if (checkShadow && elem->parent &&\n+            ((xmlNodePtr) elem->parent->doc != elem->parent)) {\n+            \/*\n+            * Does it shadow ancestor ns-decls?\n+            *\/\n+            if (xmlSearchNsByPrefixStrict(doc, elem->parent, pref, NULL) == 1)\n+                goto ns_next_prefix;\n+        }\n+        ret = xmlNewNs(NULL, nsName, pref);\n+        if (ret == NULL)\n+            return (NULL);\n+        if (elem->nsDef == NULL)\n+            elem->nsDef = ret;\n+        else {\n+            xmlNsPtr ns2 = elem->nsDef;\n+            while (ns2->next != NULL)\n+                ns2 = ns2->next;\n+            ns2->next = ret;\n+        }\n+        return (ret);\n@@ -8511,10 +7805,10 @@\n-    counter++;\n-    if (counter > 1000)\n-        return (NULL);\n-    if (prefix == NULL) {\n-        snprintf((char *) buf, sizeof(buf),\n-        \"ns_%d\", counter);\n-    } else\n-        snprintf((char *) buf, sizeof(buf),\n-        \"%.30s_%d\", (char *)prefix, counter);\n-    pref = BAD_CAST buf;\n+        counter++;\n+        if (counter > 1000)\n+            return (NULL);\n+        if (prefix == NULL) {\n+            snprintf((char *) buf, sizeof(buf),\n+                \"ns_%d\", counter);\n+        } else\n+            snprintf((char *) buf, sizeof(buf),\n+            \"%.30s_%d\", (char *)prefix, counter);\n+        pref = BAD_CAST buf;\n@@ -8545,8 +7839,8 @@\n-                   xmlNodePtr elem,\n-                   xmlNsPtr ns,\n-                   xmlNsPtr *retNs,\n-                   xmlNsMapPtr *nsMap,\n-\n-                   int depth,\n-                   int ancestorsOnly,\n-                   int prefixed)\n+                                   xmlNodePtr elem,\n+                                   xmlNsPtr ns,\n+                                   xmlNsPtr *retNs,\n+                                   xmlNsMapPtr *nsMap,\n+\n+                                   int depth,\n+                                   int ancestorsOnly,\n+                                   int prefixed)\n@@ -8557,2 +7851,2 @@\n-    (nsMap == NULL))\n-    return (-1);\n+        (nsMap == NULL))\n+        return (-1);\n@@ -8565,7 +7859,7 @@\n-    \/*\n-    * Insert XML namespace mapping.\n-    *\/\n-    *retNs = xmlTreeEnsureXMLDecl(doc);\n-    if (*retNs == NULL)\n-        return (-1);\n-    return (0);\n+        \/*\n+        * Insert XML namespace mapping.\n+        *\/\n+        *retNs = xmlTreeEnsureXMLDecl(doc);\n+        if (*retNs == NULL)\n+            return (-1);\n+        return (0);\n@@ -8578,1 +7872,1 @@\n-    (! (ancestorsOnly && (elem == NULL))))\n+        (! (ancestorsOnly && (elem == NULL))))\n@@ -8580,5 +7874,0 @@\n-    \/*\n-    * Try to find an equal ns-name in in-scope ns-decls.\n-    *\/\n-    XML_NSMAP_FOREACH(*nsMap, mi) {\n-        if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n@@ -8586,4 +7875,1 @@\n-        * ancestorsOnly: This should be turned on to gain speed,\n-        * if one knows that the branch itself was already\n-        * ns-wellformed and no stale references existed.\n-        * I.e. it searches in the ancestor axis only.\n+        * Try to find an equal ns-name in in-scope ns-decls.\n@@ -8591,15 +7877,24 @@\n-        ((! ancestorsOnly) || (mi->depth == XML_TREE_NSMAP_PARENT)) &&\n-        \/* Skip shadowed prefixes. *\/\n-        (mi->shadowDepth == -1) &&\n-        \/* Skip xmlns=\"\" or xmlns:foo=\"\". *\/\n-        ((mi->newNs->href != NULL) &&\n-        (mi->newNs->href[0] != 0)) &&\n-        \/* Ensure a prefix if wanted. *\/\n-        ((! prefixed) || (mi->newNs->prefix != NULL)) &&\n-        \/* Equal ns name *\/\n-        ((mi->newNs->href == ns->href) ||\n-        xmlStrEqual(mi->newNs->href, ns->href))) {\n-        \/* Set the mapping. *\/\n-        mi->oldNs = ns;\n-        *retNs = mi->newNs;\n-        return (0);\n+        XML_NSMAP_FOREACH(*nsMap, mi) {\n+            if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n+                \/*\n+                * ancestorsOnly: This should be turned on to gain speed,\n+                * if one knows that the branch itself was already\n+                * ns-wellformed and no stale references existed.\n+                * I.e. it searches in the ancestor axis only.\n+                *\/\n+                ((! ancestorsOnly) || (mi->depth == XML_TREE_NSMAP_PARENT)) &&\n+                \/* Skip shadowed prefixes. *\/\n+                (mi->shadowDepth == -1) &&\n+                \/* Skip xmlns=\"\" or xmlns:foo=\"\". *\/\n+                ((mi->newNs->href != NULL) &&\n+                (mi->newNs->href[0] != 0)) &&\n+                \/* Ensure a prefix if wanted. *\/\n+                ((! prefixed) || (mi->newNs->prefix != NULL)) &&\n+                \/* Equal ns name *\/\n+                ((mi->newNs->href == ns->href) ||\n+                xmlStrEqual(mi->newNs->href, ns->href))) {\n+                \/* Set the mapping. *\/\n+                mi->oldNs = ns;\n+                *retNs = mi->newNs;\n+                return (0);\n+            }\n@@ -8608,1 +7903,0 @@\n-    }\n@@ -8613,1 +7907,1 @@\n-    xmlNsPtr tmpns;\n+        xmlNsPtr tmpns;\n@@ -8615,14 +7909,14 @@\n-    \/*\n-    * Store ns-decls in \"oldNs\" of the document-node.\n-    *\/\n-    tmpns = xmlDOMWrapStoreNs(doc, ns->href, ns->prefix);\n-    if (tmpns == NULL)\n-        return (-1);\n-    \/*\n-    * Insert mapping.\n-    *\/\n-    if (xmlDOMWrapNsMapAddItem(nsMap, -1, ns,\n-        tmpns, XML_TREE_NSMAP_DOC) == NULL) {\n-        return (-1);\n-    }\n-    *retNs = tmpns;\n+        \/*\n+        * Store ns-decls in \"oldNs\" of the document-node.\n+        *\/\n+        tmpns = xmlDOMWrapStoreNs(doc, ns->href, ns->prefix);\n+        if (tmpns == NULL)\n+            return (-1);\n+        \/*\n+        * Insert mapping.\n+        *\/\n+        if (xmlDOMWrapNsMapAddItem(nsMap, -1, ns,\n+                tmpns, XML_TREE_NSMAP_DOC) == NULL) {\n+            return (-1);\n+        }\n+        *retNs = tmpns;\n@@ -8630,1 +7924,1 @@\n-    xmlNsPtr tmpns;\n+        xmlNsPtr tmpns;\n@@ -8632,4 +7926,4 @@\n-    tmpns = xmlDOMWrapNSNormDeclareNsForced(doc, elem, ns->href,\n-        ns->prefix, 0);\n-    if (tmpns == NULL)\n-        return (-1);\n+        tmpns = xmlDOMWrapNSNormDeclareNsForced(doc, elem, ns->href,\n+            ns->prefix, 0);\n+        if (tmpns == NULL)\n+            return (-1);\n@@ -8637,9 +7931,1 @@\n-    if (*nsMap != NULL) {\n-        \/*\n-        * Does it shadow ancestor ns-decls?\n-        *\/\n-        XML_NSMAP_FOREACH(*nsMap, mi) {\n-        if ((mi->depth < depth) &&\n-            (mi->shadowDepth == -1) &&\n-            ((ns->prefix == mi->newNs->prefix) ||\n-            xmlStrEqual(ns->prefix, mi->newNs->prefix))) {\n+        if (*nsMap != NULL) {\n@@ -8647,1 +7933,1 @@\n-            * Shadows.\n+            * Does it shadow ancestor ns-decls?\n@@ -8649,2 +7935,12 @@\n-            mi->shadowDepth = depth;\n-            break;\n+            XML_NSMAP_FOREACH(*nsMap, mi) {\n+                if ((mi->depth < depth) &&\n+                    (mi->shadowDepth == -1) &&\n+                    ((ns->prefix == mi->newNs->prefix) ||\n+                    xmlStrEqual(ns->prefix, mi->newNs->prefix))) {\n+                    \/*\n+                    * Shadows.\n+                    *\/\n+                    mi->shadowDepth = depth;\n+                    break;\n+                }\n+            }\n@@ -8652,0 +7948,2 @@\n+        if (xmlDOMWrapNsMapAddItem(nsMap, -1, ns, tmpns, depth) == NULL) {\n+            return (-1);\n@@ -8653,5 +7951,1 @@\n-    }\n-    if (xmlDOMWrapNsMapAddItem(nsMap, -1, ns, tmpns, depth) == NULL) {\n-        return (-1);\n-    }\n-    *retNs = tmpns;\n+        *retNs = tmpns;\n@@ -8685,2 +7979,2 @@\n-                  xmlNodePtr elem,\n-                  int options)\n+                              xmlNodePtr elem,\n+                              int options)\n@@ -8697,1 +7991,1 @@\n-    ((xmlDOMReconcileNSOptions) options & XML_DOM_RECONNS_REMOVEREDUND) ? 1 : 0;\n+        ((xmlDOMReconcileNSOptions) options & XML_DOM_RECONNS_REMOVEREDUND) ? 1 : 0;\n@@ -8702,2 +7996,2 @@\n-    (elem->type != XML_ELEMENT_NODE))\n-    return (-1);\n+        (elem->type != XML_ELEMENT_NODE))\n+        return (-1);\n@@ -8708,15 +8002,5 @@\n-    switch (cur->type) {\n-        case XML_ELEMENT_NODE:\n-        adoptns = 1;\n-        curElem = cur;\n-        depth++;\n-        \/*\n-        * Namespace declarations.\n-        *\/\n-        if (cur->nsDef != NULL) {\n-            prevns = NULL;\n-            ns = cur->nsDef;\n-            while (ns != NULL) {\n-            if (! parnsdone) {\n-                if ((elem->parent) &&\n-                ((xmlNodePtr) elem->parent->doc != elem->parent)) {\n+        switch (cur->type) {\n+            case XML_ELEMENT_NODE:\n+                adoptns = 1;\n+                curElem = cur;\n+                depth++;\n@@ -8724,1 +8008,1 @@\n-                * Gather ancestor in-scope ns-decls.\n+                * Namespace declarations.\n@@ -8726,6 +8010,16 @@\n-                if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n-                    elem->parent) == -1)\n-                    ret = -1;\n-                }\n-                parnsdone = 1;\n-            }\n+                if (cur->nsDef != NULL) {\n+                    prevns = NULL;\n+                    ns = cur->nsDef;\n+                    while (ns != NULL) {\n+                        if (! parnsdone) {\n+                            if ((elem->parent) &&\n+                                ((xmlNodePtr) elem->parent->doc != elem->parent)) {\n+                                \/*\n+                                * Gather ancestor in-scope ns-decls.\n+                                *\/\n+                                if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n+                                    elem->parent) == -1)\n+                                    ret = -1;\n+                            }\n+                            parnsdone = 1;\n+                        }\n@@ -8733,19 +8027,19 @@\n-            \/*\n-            * Lookup the ns ancestor-axis for equal ns-decls in scope.\n-            *\/\n-            if (optRemoveRedundantNS && XML_NSMAP_NOTEMPTY(nsMap)) {\n-                XML_NSMAP_FOREACH(nsMap, mi) {\n-                if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n-                    (mi->shadowDepth == -1) &&\n-                    ((ns->prefix == mi->newNs->prefix) ||\n-                      xmlStrEqual(ns->prefix, mi->newNs->prefix)) &&\n-                    ((ns->href == mi->newNs->href) ||\n-                      xmlStrEqual(ns->href, mi->newNs->href)))\n-                {\n-                    \/*\n-                    * A redundant ns-decl was found.\n-                    * Add it to the list of redundant ns-decls.\n-                    *\/\n-                    if (xmlDOMWrapNSNormAddNsMapItem2(&listRedund,\n-                    &sizeRedund, &nbRedund, ns, mi->newNs) == -1) {\n-                    ret = -1;\n+                        \/*\n+                        * Lookup the ns ancestor-axis for equal ns-decls in scope.\n+                        *\/\n+                        if (optRemoveRedundantNS && XML_NSMAP_NOTEMPTY(nsMap)) {\n+                            XML_NSMAP_FOREACH(nsMap, mi) {\n+                                if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n+                                    (mi->shadowDepth == -1) &&\n+                                    ((ns->prefix == mi->newNs->prefix) ||\n+                                      xmlStrEqual(ns->prefix, mi->newNs->prefix)) &&\n+                                    ((ns->href == mi->newNs->href) ||\n+                                      xmlStrEqual(ns->href, mi->newNs->href)))\n+                                {\n+                                    \/*\n+                                    * A redundant ns-decl was found.\n+                                    * Add it to the list of redundant ns-decls.\n+                                    *\/\n+                                    if (xmlDOMWrapNSNormAddNsMapItem2(&listRedund,\n+                                        &sizeRedund, &nbRedund, ns, mi->newNs) == -1) {\n+                                        ret = -1;\n@@ -8762,19 +8056,3 @@\n-                }\n-                }\n-            }\n-\n-            \/*\n-            * Skip ns-references handling if the referenced\n-            * ns-decl is declared on the same element.\n-            *\/\n-            if ((cur->ns != NULL) && adoptns && (cur->ns == ns))\n-                adoptns = 0;\n-            \/*\n-            * Does it shadow any ns-decl?\n-            *\/\n-            if (XML_NSMAP_NOTEMPTY(nsMap)) {\n-                XML_NSMAP_FOREACH(nsMap, mi) {\n-                if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n-                    (mi->shadowDepth == -1) &&\n-                    ((ns->prefix == mi->newNs->prefix) ||\n-                    xmlStrEqual(ns->prefix, mi->newNs->prefix))) {\n+                                }\n+                            }\n+                        }\n@@ -8782,10 +8060,26 @@\n-                    mi->shadowDepth = depth;\n-                }\n-                }\n-            }\n-            \/*\n-            * Push mapping.\n-            *\/\n-            if (xmlDOMWrapNsMapAddItem(&nsMap, -1, ns, ns,\n-                depth) == NULL)\n-                ret = -1;\n+                        \/*\n+                        * Skip ns-references handling if the referenced\n+                        * ns-decl is declared on the same element.\n+                        *\/\n+                        if ((cur->ns != NULL) && adoptns && (cur->ns == ns))\n+                            adoptns = 0;\n+                        \/*\n+                        * Does it shadow any ns-decl?\n+                        *\/\n+                        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                            XML_NSMAP_FOREACH(nsMap, mi) {\n+                                if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n+                                    (mi->shadowDepth == -1) &&\n+                                    ((ns->prefix == mi->newNs->prefix) ||\n+                                    xmlStrEqual(ns->prefix, mi->newNs->prefix))) {\n+\n+                                    mi->shadowDepth = depth;\n+                                }\n+                            }\n+                        }\n+                        \/*\n+                        * Push mapping.\n+                        *\/\n+                        if (xmlDOMWrapNsMapAddItem(&nsMap, -1, ns, ns,\n+                            depth) == NULL)\n+                            ret = -1;\n@@ -8793,1 +8087,1 @@\n-            prevns = ns;\n+                        prevns = ns;\n@@ -8795,5 +8089,5 @@\n-            ns = ns->next;\n-            }\n-        }\n-        if (! adoptns)\n-            goto ns_end;\n+                        ns = ns->next;\n+                    }\n+                }\n+                if (! adoptns)\n+                    goto ns_end;\n@@ -8801,35 +8095,35 @@\n-        case XML_ATTRIBUTE_NODE:\n-        \/* No ns, no fun. *\/\n-        if (cur->ns == NULL)\n-            goto ns_end;\n-\n-        if (! parnsdone) {\n-            if ((elem->parent) &&\n-            ((xmlNodePtr) elem->parent->doc != elem->parent)) {\n-            if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n-                elem->parent) == -1)\n-                ret = -1;\n-            }\n-            parnsdone = 1;\n-        }\n-        \/*\n-        * Adjust the reference if this was a redundant ns-decl.\n-        *\/\n-        if (listRedund) {\n-           for (i = 0, j = 0; i < nbRedund; i++, j += 2) {\n-               if (cur->ns == listRedund[j]) {\n-               cur->ns = listRedund[++j];\n-               break;\n-               }\n-           }\n-        }\n-        \/*\n-        * Adopt ns-references.\n-        *\/\n-        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n-            \/*\n-            * Search for a mapping.\n-            *\/\n-            XML_NSMAP_FOREACH(nsMap, mi) {\n-            if ((mi->shadowDepth == -1) &&\n-                (cur->ns == mi->oldNs)) {\n+            case XML_ATTRIBUTE_NODE:\n+                \/* No ns, no fun. *\/\n+                if (cur->ns == NULL)\n+                    goto ns_end;\n+\n+                if (! parnsdone) {\n+                    if ((elem->parent) &&\n+                        ((xmlNodePtr) elem->parent->doc != elem->parent)) {\n+                        if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n+                                elem->parent) == -1)\n+                            ret = -1;\n+                    }\n+                    parnsdone = 1;\n+                }\n+                \/*\n+                * Adjust the reference if this was a redundant ns-decl.\n+                *\/\n+                if (listRedund) {\n+                   for (i = 0, j = 0; i < nbRedund; i++, j += 2) {\n+                       if (cur->ns == listRedund[j]) {\n+                           cur->ns = listRedund[++j];\n+                           break;\n+                       }\n+                   }\n+                }\n+                \/*\n+                * Adopt ns-references.\n+                *\/\n+                if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                    \/*\n+                    * Search for a mapping.\n+                    *\/\n+                    XML_NSMAP_FOREACH(nsMap, mi) {\n+                        if ((mi->shadowDepth == -1) &&\n+                            (cur->ns == mi->oldNs)) {\n@@ -8837,15 +8131,15 @@\n-                cur->ns = mi->newNs;\n-                goto ns_end;\n-            }\n-            }\n-        }\n-        \/*\n-        * Acquire a normalized ns-decl and add it to the map.\n-        *\/\n-        if (xmlDOMWrapNSNormAcquireNormalizedNs(doc, curElem,\n-            cur->ns, &ns,\n-            &nsMap, depth,\n-            ancestorsOnly,\n-            (cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)\n-            ret = -1;\n-        cur->ns = ns;\n+                            cur->ns = mi->newNs;\n+                            goto ns_end;\n+                        }\n+                    }\n+                }\n+                \/*\n+                * Acquire a normalized ns-decl and add it to the map.\n+                *\/\n+                if (xmlDOMWrapNSNormAcquireNormalizedNs(doc, curElem,\n+                        cur->ns, &ns,\n+                        &nsMap, depth,\n+                        ancestorsOnly,\n+                        (cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)\n+                    ret = -1;\n+                cur->ns = ns;\n@@ -8854,0 +8148,13 @@\n+                if ((cur->type == XML_ELEMENT_NODE) &&\n+                    (cur->properties != NULL)) {\n+                    \/*\n+                    * Process attributes.\n+                    *\/\n+                    cur = (xmlNodePtr) cur->properties;\n+                    continue;\n+                }\n+                break;\n+            default:\n+                goto next_sibling;\n+        }\n+into_content:\n@@ -8855,1 +8162,1 @@\n-            (cur->properties != NULL)) {\n+            (cur->children != NULL)) {\n@@ -8857,1 +8164,1 @@\n-            * Process attributes.\n+            * Process content of element-nodes only.\n@@ -8859,1 +8166,1 @@\n-            cur = (xmlNodePtr) cur->properties;\n+            cur = cur->children;\n@@ -8862,13 +8169,0 @@\n-        break;\n-        default:\n-        goto next_sibling;\n-    }\n-into_content:\n-    if ((cur->type == XML_ELEMENT_NODE) &&\n-        (cur->children != NULL)) {\n-        \/*\n-        * Process content of element-nodes only.\n-        *\/\n-        cur = cur->children;\n-        continue;\n-    }\n@@ -8876,19 +8170,21 @@\n-    if (cur == elem)\n-        break;\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n-        \/*\n-        * Pop mappings.\n-        *\/\n-        while ((nsMap->last != NULL) &&\n-            (nsMap->last->depth >= depth))\n-        {\n-            XML_NSMAP_POP(nsMap, mi)\n-        }\n-        \/*\n-        * Unshadow.\n-        *\/\n-        XML_NSMAP_FOREACH(nsMap, mi) {\n-            if (mi->shadowDepth >= depth)\n-            mi->shadowDepth = -1;\n-        }\n+        if (cur == elem)\n+            break;\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                \/*\n+                * Pop mappings.\n+                *\/\n+                while ((nsMap->last != NULL) &&\n+                    (nsMap->last->depth >= depth))\n+                {\n+                    XML_NSMAP_POP(nsMap, mi)\n+                }\n+                \/*\n+                * Unshadow.\n+                *\/\n+                XML_NSMAP_FOREACH(nsMap, mi) {\n+                    if (mi->shadowDepth >= depth)\n+                        mi->shadowDepth = -1;\n+                }\n+            }\n+            depth--;\n@@ -8896,8 +8192,9 @@\n-        depth--;\n-    }\n-    if (cur->next != NULL)\n-        cur = cur->next;\n-    else {\n-        if (cur->type == XML_ATTRIBUTE_NODE) {\n-        cur = cur->parent;\n-        goto into_content;\n+        if (cur->next != NULL)\n+            cur = cur->next;\n+        else {\n+            if (cur->type == XML_ATTRIBUTE_NODE) {\n+                cur = cur->parent;\n+                goto into_content;\n+            }\n+            cur = cur->parent;\n+            goto next_sibling;\n@@ -8905,3 +8202,0 @@\n-        cur = cur->parent;\n-        goto next_sibling;\n-    }\n@@ -8911,4 +8205,4 @@\n-    for (i = 0, j = 0; i < nbRedund; i++, j += 2) {\n-        xmlFreeNs(listRedund[j]);\n-    }\n-    xmlFree(listRedund);\n+        for (i = 0, j = 0; i < nbRedund; i++, j += 2) {\n+            xmlFreeNs(listRedund[j]);\n+        }\n+        xmlFree(listRedund);\n@@ -8917,1 +8211,1 @@\n-    xmlDOMWrapNsMapFree(nsMap);\n+        xmlDOMWrapNsMapFree(nsMap);\n@@ -8945,5 +8239,5 @@\n-              xmlDocPtr sourceDoc ATTRIBUTE_UNUSED,\n-              xmlNodePtr node,\n-              xmlDocPtr destDoc,\n-              xmlNodePtr destParent,\n-              int options ATTRIBUTE_UNUSED)\n+                      xmlDocPtr sourceDoc ATTRIBUTE_UNUSED,\n+                      xmlNodePtr node,\n+                      xmlDocPtr destDoc,\n+                      xmlNodePtr destParent,\n+                      int options ATTRIBUTE_UNUSED)\n@@ -8966,1 +8260,1 @@\n-    nsMap = (xmlNsMapPtr) ctxt->namespaceMap;\n+        nsMap = (xmlNsMapPtr) ctxt->namespaceMap;\n@@ -8974,1 +8268,1 @@\n-    (ctxt && ctxt->getNsForNodeFunc))\n+        (ctxt && ctxt->getNsForNodeFunc))\n@@ -8976,67 +8270,9 @@\n-    parnsdone = 1;\n-    } else\n-    parnsdone = 0;\n-\n-    cur = node;\n-\n-    while (cur != NULL) {\n-        if (cur->doc != destDoc) {\n-            if (xmlNodeSetDoc(cur, destDoc) < 0)\n-                ret = -1;\n-        }\n-\n-    switch (cur->type) {\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        \/*\n-        * TODO\n-        *\/\n-        ret = -1;\n-                goto leave_node;\n-        case XML_ELEMENT_NODE:\n-        curElem = cur;\n-        depth++;\n-        \/*\n-        * Namespace declarations.\n-        * - ns->href and ns->prefix are never in the dict, so\n-        *   we need not move the values over to the destination dict.\n-        * - Note that for custom handling of ns-references,\n-        *   the ns-decls need not be stored in the ns-map,\n-        *   since they won't be referenced by node->ns.\n-        *\/\n-        if ((cur->nsDef) &&\n-            ((ctxt == NULL) || (ctxt->getNsForNodeFunc == NULL)))\n-        {\n-            if (! parnsdone) {\n-            \/*\n-            * Gather @parent's in-scope ns-decls.\n-            *\/\n-            if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n-                destParent) == -1)\n-                ret = -1;\n-            parnsdone = 1;\n-            }\n-            for (ns = cur->nsDef; ns != NULL; ns = ns->next) {\n-            \/*\n-            * NOTE: ns->prefix and ns->href are never in the dict.\n-            *\/\n-            \/*\n-            * Does it shadow any ns-decl?\n-            *\/\n-            if (XML_NSMAP_NOTEMPTY(nsMap)) {\n-                XML_NSMAP_FOREACH(nsMap, mi) {\n-                if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n-                    (mi->shadowDepth == -1) &&\n-                    ((ns->prefix == mi->newNs->prefix) ||\n-                    xmlStrEqual(ns->prefix,\n-                    mi->newNs->prefix))) {\n-\n-                    mi->shadowDepth = depth;\n-                }\n-                }\n-            }\n-            \/*\n-            * Push mapping.\n-            *\/\n-            if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n-                ns, ns, depth) == NULL)\n+        parnsdone = 1;\n+    } else\n+        parnsdone = 0;\n+\n+    cur = node;\n+\n+    while (cur != NULL) {\n+        if (cur->doc != destDoc) {\n+            if (xmlNodeSetDoc(cur, destDoc) < 0)\n@@ -9044,1 +8280,0 @@\n-            }\n@@ -9046,0 +8281,59 @@\n+\n+        switch (cur->type) {\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+                \/*\n+                * TODO\n+                *\/\n+                ret = -1;\n+                goto leave_node;\n+            case XML_ELEMENT_NODE:\n+                curElem = cur;\n+                depth++;\n+                \/*\n+                * Namespace declarations.\n+                * - ns->href and ns->prefix are never in the dict, so\n+                *   we need not move the values over to the destination dict.\n+                * - Note that for custom handling of ns-references,\n+                *   the ns-decls need not be stored in the ns-map,\n+                *   since they won't be referenced by node->ns.\n+                *\/\n+                if ((cur->nsDef) &&\n+                    ((ctxt == NULL) || (ctxt->getNsForNodeFunc == NULL)))\n+                {\n+                    if (! parnsdone) {\n+                        \/*\n+                        * Gather @parent's in-scope ns-decls.\n+                        *\/\n+                        if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n+                            destParent) == -1)\n+                            ret = -1;\n+                        parnsdone = 1;\n+                    }\n+                    for (ns = cur->nsDef; ns != NULL; ns = ns->next) {\n+                        \/*\n+                        * NOTE: ns->prefix and ns->href are never in the dict.\n+                        *\/\n+                        \/*\n+                        * Does it shadow any ns-decl?\n+                        *\/\n+                        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                            XML_NSMAP_FOREACH(nsMap, mi) {\n+                                if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n+                                    (mi->shadowDepth == -1) &&\n+                                    ((ns->prefix == mi->newNs->prefix) ||\n+                                    xmlStrEqual(ns->prefix,\n+                                    mi->newNs->prefix))) {\n+\n+                                    mi->shadowDepth = depth;\n+                                }\n+                            }\n+                        }\n+                        \/*\n+                        * Push mapping.\n+                        *\/\n+                        if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n+                            ns, ns, depth) == NULL)\n+                            ret = -1;\n+                    }\n+                }\n@@ -9047,4 +8341,21 @@\n-        case XML_ATTRIBUTE_NODE:\n-        \/* No namespace, no fun. *\/\n-        if (cur->ns == NULL)\n-            goto ns_end;\n+            case XML_ATTRIBUTE_NODE:\n+                \/* No namespace, no fun. *\/\n+                if (cur->ns == NULL)\n+                    goto ns_end;\n+\n+                if (! parnsdone) {\n+                    if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n+                        destParent) == -1)\n+                        ret = -1;\n+                    parnsdone = 1;\n+                }\n+                \/*\n+                * Adopt ns-references.\n+                *\/\n+                if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                    \/*\n+                    * Search for a mapping.\n+                    *\/\n+                    XML_NSMAP_FOREACH(nsMap, mi) {\n+                        if ((mi->shadowDepth == -1) &&\n+                            (cur->ns == mi->oldNs)) {\n@@ -9052,16 +8363,37 @@\n-        if (! parnsdone) {\n-            if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n-            destParent) == -1)\n-            ret = -1;\n-            parnsdone = 1;\n-        }\n-        \/*\n-        * Adopt ns-references.\n-        *\/\n-        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n-            \/*\n-            * Search for a mapping.\n-            *\/\n-            XML_NSMAP_FOREACH(nsMap, mi) {\n-            if ((mi->shadowDepth == -1) &&\n-                (cur->ns == mi->oldNs)) {\n+                            cur->ns = mi->newNs;\n+                            goto ns_end;\n+                        }\n+                    }\n+                }\n+                \/*\n+                * No matching namespace in scope. We need a new one.\n+                *\/\n+                if ((ctxt) && (ctxt->getNsForNodeFunc)) {\n+                    \/*\n+                    * User-defined behaviour.\n+                    *\/\n+                    ns = ctxt->getNsForNodeFunc(ctxt, cur,\n+                        cur->ns->href, cur->ns->prefix);\n+                    \/*\n+                    * Insert mapping if ns is available; it's the users fault\n+                    * if not.\n+                    *\/\n+                    if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n+                            cur->ns, ns, XML_TREE_NSMAP_CUSTOM) == NULL)\n+                        ret = -1;\n+                    cur->ns = ns;\n+                } else {\n+                    \/*\n+                    * Acquire a normalized ns-decl and add it to the map.\n+                    *\/\n+                    if (xmlDOMWrapNSNormAcquireNormalizedNs(destDoc,\n+                        \/* ns-decls on curElem or on destDoc->oldNs *\/\n+                        destParent ? curElem : NULL,\n+                        cur->ns, &ns,\n+                        &nsMap, depth,\n+                        ancestorsOnly,\n+                        \/* ns-decls must be prefixed for attributes. *\/\n+                        (cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)\n+                        ret = -1;\n+                    cur->ns = ns;\n+                }\n@@ -9069,4 +8401,25 @@\n-                cur->ns = mi->newNs;\n-                goto ns_end;\n-            }\n-            }\n+ns_end:\n+                if (cur->type == XML_ELEMENT_NODE) {\n+                    cur->psvi = NULL;\n+                    cur->line = 0;\n+                    cur->extra = 0;\n+                    \/*\n+                    * Walk attributes.\n+                    *\/\n+                    if (cur->properties != NULL) {\n+                        \/*\n+                        * Process first attribute node.\n+                        *\/\n+                        cur = (xmlNodePtr) cur->properties;\n+                        continue;\n+                    }\n+                }\n+                break;\n+            case XML_TEXT_NODE:\n+            case XML_CDATA_SECTION_NODE:\n+            case XML_PI_NODE:\n+            case XML_COMMENT_NODE:\n+            case XML_ENTITY_REF_NODE:\n+                goto leave_node;\n+            default:\n+                ret = -1;\n@@ -9075,1 +8428,1 @@\n-        * No matching namespace in scope. We need a new one.\n+        * Walk the tree.\n@@ -9077,28 +8430,3 @@\n-        if ((ctxt) && (ctxt->getNsForNodeFunc)) {\n-            \/*\n-            * User-defined behaviour.\n-            *\/\n-            ns = ctxt->getNsForNodeFunc(ctxt, cur,\n-            cur->ns->href, cur->ns->prefix);\n-            \/*\n-            * Insert mapping if ns is available; it's the users fault\n-            * if not.\n-            *\/\n-            if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n-                cur->ns, ns, XML_TREE_NSMAP_CUSTOM) == NULL)\n-            ret = -1;\n-            cur->ns = ns;\n-        } else {\n-            \/*\n-            * Acquire a normalized ns-decl and add it to the map.\n-            *\/\n-            if (xmlDOMWrapNSNormAcquireNormalizedNs(destDoc,\n-            \/* ns-decls on curElem or on destDoc->oldNs *\/\n-            destParent ? curElem : NULL,\n-            cur->ns, &ns,\n-            &nsMap, depth,\n-            ancestorsOnly,\n-            \/* ns-decls must be prefixed for attributes. *\/\n-            (cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)\n-            ret = -1;\n-            cur->ns = ns;\n+        if (cur->children != NULL) {\n+            cur = cur->children;\n+            continue;\n@@ -9107,9 +8435,7 @@\n-ns_end:\n-        if (cur->type == XML_ELEMENT_NODE) {\n-            cur->psvi = NULL;\n-            cur->line = 0;\n-            cur->extra = 0;\n-            \/*\n-            * Walk attributes.\n-            *\/\n-            if (cur->properties != NULL) {\n+leave_node:\n+        if (cur == node)\n+            break;\n+        if ((cur->type == XML_ELEMENT_NODE) ||\n+            (cur->type == XML_XINCLUDE_START) ||\n+            (cur->type == XML_XINCLUDE_END))\n+        {\n@@ -9117,1 +8443,1 @@\n-            * Process first attribute node.\n+            * TODO: Do we expect nsDefs on XML_XINCLUDE_START?\n@@ -9119,2 +8445,16 @@\n-            cur = (xmlNodePtr) cur->properties;\n-            continue;\n+            if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                \/*\n+                * Pop mappings.\n+                *\/\n+                while ((nsMap->last != NULL) &&\n+                    (nsMap->last->depth >= depth))\n+                {\n+                    XML_NSMAP_POP(nsMap, mi)\n+                }\n+                \/*\n+                * Unshadow.\n+                *\/\n+                XML_NSMAP_FOREACH(nsMap, mi) {\n+                    if (mi->shadowDepth >= depth)\n+                        mi->shadowDepth = -1;\n+                }\n@@ -9122,0 +8462,1 @@\n+            depth--;\n@@ -9123,34 +8464,4 @@\n-        break;\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        case XML_PI_NODE:\n-        case XML_COMMENT_NODE:\n-        case XML_ENTITY_REF_NODE:\n-        goto leave_node;\n-        default:\n-        ret = -1;\n-    }\n-    \/*\n-    * Walk the tree.\n-    *\/\n-    if (cur->children != NULL) {\n-        cur = cur->children;\n-        continue;\n-    }\n-\n-leave_node:\n-    if (cur == node)\n-        break;\n-    if ((cur->type == XML_ELEMENT_NODE) ||\n-        (cur->type == XML_XINCLUDE_START) ||\n-        (cur->type == XML_XINCLUDE_END))\n-    {\n-        \/*\n-        * TODO: Do we expect nsDefs on XML_XINCLUDE_START?\n-        *\/\n-        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n-        \/*\n-        * Pop mappings.\n-        *\/\n-        while ((nsMap->last != NULL) &&\n-            (nsMap->last->depth >= depth))\n+        if (cur->next != NULL)\n+            cur = cur->next;\n+        else if ((cur->type == XML_ATTRIBUTE_NODE) &&\n+            (cur->parent->children != NULL))\n@@ -9158,9 +8469,4 @@\n-            XML_NSMAP_POP(nsMap, mi)\n-        }\n-        \/*\n-        * Unshadow.\n-        *\/\n-        XML_NSMAP_FOREACH(nsMap, mi) {\n-            if (mi->shadowDepth >= depth)\n-            mi->shadowDepth = -1;\n-        }\n+            cur = cur->parent->children;\n+        } else {\n+            cur = cur->parent;\n+            goto leave_node;\n@@ -9168,12 +8474,0 @@\n-        depth--;\n-    }\n-    if (cur->next != NULL)\n-        cur = cur->next;\n-    else if ((cur->type == XML_ATTRIBUTE_NODE) &&\n-        (cur->parent->children != NULL))\n-    {\n-        cur = cur->parent->children;\n-    } else {\n-        cur = cur->parent;\n-        goto leave_node;\n-    }\n@@ -9186,12 +8480,12 @@\n-    if ((ctxt) && (ctxt->namespaceMap == nsMap)) {\n-        \/*\n-        * Just cleanup the map but don't free.\n-        *\/\n-        if (nsMap->first) {\n-        if (nsMap->pool)\n-            nsMap->last->next = nsMap->pool;\n-        nsMap->pool = nsMap->first;\n-        nsMap->first = NULL;\n-        }\n-    } else\n-        xmlDOMWrapNsMapFree(nsMap);\n+        if ((ctxt) && (ctxt->namespaceMap == nsMap)) {\n+            \/*\n+            * Just cleanup the map but don't free.\n+            *\/\n+            if (nsMap->first) {\n+                if (nsMap->pool)\n+                    nsMap->last->next = nsMap->pool;\n+                nsMap->pool = nsMap->first;\n+                nsMap->first = NULL;\n+            }\n+        } else\n+            xmlDOMWrapNsMapFree(nsMap);\n@@ -9234,7 +8528,7 @@\n-              xmlDocPtr sourceDoc,\n-              xmlNodePtr node,\n-              xmlNodePtr *resNode,\n-              xmlDocPtr destDoc,\n-              xmlNodePtr destParent,\n-              int deep,\n-              int options ATTRIBUTE_UNUSED)\n+                      xmlDocPtr sourceDoc,\n+                      xmlNodePtr node,\n+                      xmlNodePtr *resNode,\n+                      xmlDocPtr destDoc,\n+                      xmlNodePtr destParent,\n+                      int deep,\n+                      int options ATTRIBUTE_UNUSED)\n@@ -9262,2 +8556,2 @@\n-    ((destParent != NULL) && (destParent->doc != destDoc)))\n-    return(-1);\n+        ((destParent != NULL) && (destParent->doc != destDoc)))\n+        return(-1);\n@@ -9268,1 +8562,1 @@\n-    return(1);\n+        return(1);\n@@ -9273,5 +8567,5 @@\n-    (node->doc != sourceDoc)) {\n-    \/*\n-    * Might be an XIncluded node.\n-    *\/\n-    return (-1);\n+        (node->doc != sourceDoc)) {\n+        \/*\n+        * Might be an XIncluded node.\n+        *\/\n+        return (-1);\n@@ -9280,1 +8574,1 @@\n-    sourceDoc = node->doc;\n+        sourceDoc = node->doc;\n@@ -9289,1 +8583,1 @@\n-    nsMap = (xmlNsMapPtr) ctxt->namespaceMap;\n+        nsMap = (xmlNsMapPtr) ctxt->namespaceMap;\n@@ -9295,55 +8589,6 @@\n-    if (cur->doc != sourceDoc) {\n-        \/*\n-        * We'll assume XIncluded nodes if the doc differs.\n-        * TODO: Do we need to reconciliate XIncluded nodes?\n-        * TODO: This here returns -1 in this case.\n-        *\/\n-        goto internal_error;\n-    }\n-    \/*\n-    * Create a new node.\n-    *\/\n-    switch (cur->type) {\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        \/*\n-        * TODO: What to do with XInclude?\n-        *\/\n-        goto internal_error;\n-        break;\n-        case XML_ELEMENT_NODE:\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        case XML_COMMENT_NODE:\n-        case XML_PI_NODE:\n-        case XML_DOCUMENT_FRAG_NODE:\n-        case XML_ENTITY_REF_NODE:\n-        \/*\n-        * Nodes of xmlNode structure.\n-        *\/\n-        clone = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n-        if (clone == NULL)\n-            goto internal_error;\n-        memset(clone, 0, sizeof(xmlNode));\n-        \/*\n-        * Set hierarchical links.\n-        *\/\n-        if (resultClone != NULL) {\n-            clone->parent = parentClone;\n-            if (prevClone) {\n-            prevClone->next = clone;\n-            clone->prev = prevClone;\n-            } else\n-            parentClone->children = clone;\n-                    parentClone->last = clone;\n-        } else\n-            resultClone = clone;\n-\n-        break;\n-        case XML_ATTRIBUTE_NODE:\n-        \/*\n-        * Attributes (xmlAttr).\n-        *\/\n-                \/* Use xmlRealloc to avoid -Warray-bounds warning *\/\n-        clone = (xmlNodePtr) xmlRealloc(NULL, sizeof(xmlAttr));\n-        if (clone == NULL)\n+        if (cur->doc != sourceDoc) {\n+            \/*\n+            * We'll assume XIncluded nodes if the doc differs.\n+            * TODO: Do we need to reconciliate XIncluded nodes?\n+            * TODO: This here returns -1 in this case.\n+            *\/\n@@ -9351,31 +8596,1 @@\n-        memset(clone, 0, sizeof(xmlAttr));\n-        \/*\n-        * Set hierarchical links.\n-        * TODO: Change this to add to the end of attributes.\n-        *\/\n-        if (resultClone != NULL) {\n-            clone->parent = parentClone;\n-            if (prevClone) {\n-            prevClone->next = clone;\n-            clone->prev = prevClone;\n-            } else\n-            parentClone->properties = (xmlAttrPtr) clone;\n-        } else\n-            resultClone = clone;\n-        break;\n-        default:\n-        \/*\n-        * TODO QUESTION: Any other nodes expected?\n-        *\/\n-        goto internal_error;\n-    }\n-\n-    clone->type = cur->type;\n-    clone->doc = destDoc;\n-\n-    \/*\n-    * Clone the name of the node if any.\n-    *\/\n-    if (cur->name == xmlStringText)\n-        clone->name = xmlStringText;\n-    else if (cur->name == xmlStringTextNoenc)\n+        }\n@@ -9383,3 +8598,1 @@\n-        * NOTE: Although xmlStringTextNoenc is never assigned to a node\n-        *   in tree.c, it might be set in Libxslt via\n-        *   \"xsl:disable-output-escaping\".\n+        * Create a new node.\n@@ -9387,9 +8600,6 @@\n-        clone->name = xmlStringTextNoenc;\n-    else if (cur->name == xmlStringComment)\n-        clone->name = xmlStringComment;\n-    else if (cur->name != NULL) {\n-            if (dict != NULL)\n-                clone->name = xmlDictLookup(dict, cur->name, -1);\n-            else\n-                clone->name = xmlStrdup(cur->name);\n-            if (clone->name == NULL)\n+        switch (cur->type) {\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+                \/*\n+                * TODO: What to do with XInclude?\n+                *\/\n@@ -9397,1 +8607,28 @@\n-    }\n+                break;\n+            case XML_ELEMENT_NODE:\n+            case XML_TEXT_NODE:\n+            case XML_CDATA_SECTION_NODE:\n+            case XML_COMMENT_NODE:\n+            case XML_PI_NODE:\n+            case XML_DOCUMENT_FRAG_NODE:\n+            case XML_ENTITY_REF_NODE:\n+                \/*\n+                * Nodes of xmlNode structure.\n+                *\/\n+                clone = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n+                if (clone == NULL)\n+                    goto internal_error;\n+                memset(clone, 0, sizeof(xmlNode));\n+                \/*\n+                * Set hierarchical links.\n+                *\/\n+                if (resultClone != NULL) {\n+                    clone->parent = parentClone;\n+                    if (prevClone) {\n+                        prevClone->next = clone;\n+                        clone->prev = prevClone;\n+                    } else\n+                        parentClone->children = clone;\n+                    parentClone->last = clone;\n+                } else\n+                    resultClone = clone;\n@@ -9399,16 +8636,2 @@\n-    switch (cur->type) {\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        \/*\n-        * TODO\n-        *\/\n-        return (-1);\n-        case XML_ELEMENT_NODE:\n-        cloneElem = clone;\n-        depth++;\n-        \/*\n-        * Namespace declarations.\n-        *\/\n-        if (cur->nsDef != NULL) {\n-            if (! parnsdone) {\n-            if (destParent && (ctxt == NULL)) {\n+                break;\n+            case XML_ATTRIBUTE_NODE:\n@@ -9416,1 +8639,1 @@\n-                * Gather @parent's in-scope ns-decls.\n+                * Attributes (xmlAttr).\n@@ -9418,11 +8641,34 @@\n-                if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n-                destParent) == -1)\n-                goto internal_error;\n-            }\n-            parnsdone = 1;\n-            }\n-            \/*\n-            * Clone namespace declarations.\n-            *\/\n-            cloneNsDefSlot = &(clone->nsDef);\n-            for (ns = cur->nsDef; ns != NULL; ns = ns->next) {\n+                clone = xmlMalloc(sizeof(xmlAttr));\n+                if (clone == NULL)\n+                    goto internal_error;\n+                memset(clone, 0, sizeof(xmlAttr));\n+                \/*\n+                * Set hierarchical links.\n+                * TODO: Change this to add to the end of attributes.\n+                *\/\n+                if (resultClone != NULL) {\n+                    clone->parent = parentClone;\n+                    if (prevClone) {\n+                        prevClone->next = clone;\n+                        clone->prev = prevClone;\n+                    } else\n+                        parentClone->properties = (xmlAttrPtr) clone;\n+                } else\n+                    resultClone = clone;\n+                break;\n+            default:\n+                \/*\n+                * TODO QUESTION: Any other nodes expected?\n+                *\/\n+                goto internal_error;\n+        }\n+\n+        clone->type = cur->type;\n+        clone->doc = destDoc;\n+\n+        \/*\n+        * Clone the name of the node if any.\n+        *\/\n+        if (cur->name == xmlStringText)\n+            clone->name = xmlStringText;\n+        else if (cur->name == xmlStringTextNoenc)\n@@ -9430,1 +8676,3 @@\n-            * Create a new xmlNs.\n+            * NOTE: Although xmlStringTextNoenc is never assigned to a node\n+            *   in tree.c, it might be set in Libxslt via\n+            *   \"xsl:disable-output-escaping\".\n@@ -9432,2 +8680,9 @@\n-            cloneNs = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));\n-            if (cloneNs == NULL)\n+            clone->name = xmlStringTextNoenc;\n+        else if (cur->name == xmlStringComment)\n+            clone->name = xmlStringComment;\n+        else if (cur->name != NULL) {\n+            if (dict != NULL)\n+                clone->name = xmlDictLookup(dict, cur->name, -1);\n+            else\n+                clone->name = xmlStrdup(cur->name);\n+            if (clone->name == NULL)\n@@ -9435,2 +8690,1 @@\n-            memset(cloneNs, 0, sizeof(xmlNs));\n-            cloneNs->type = XML_LOCAL_NAMESPACE;\n+        }\n@@ -9438,2 +8692,41 @@\n-            if (ns->href != NULL) {\n-                cloneNs->href = xmlStrdup(ns->href);\n+        switch (cur->type) {\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+                \/*\n+                * TODO\n+                *\/\n+                return (-1);\n+            case XML_ELEMENT_NODE:\n+                cloneElem = clone;\n+                depth++;\n+                \/*\n+                * Namespace declarations.\n+                *\/\n+                if (cur->nsDef != NULL) {\n+                    if (! parnsdone) {\n+                        if (destParent && (ctxt == NULL)) {\n+                            \/*\n+                            * Gather @parent's in-scope ns-decls.\n+                            *\/\n+                            if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap,\n+                                destParent) == -1)\n+                                goto internal_error;\n+                        }\n+                        parnsdone = 1;\n+                    }\n+                    \/*\n+                    * Clone namespace declarations.\n+                    *\/\n+                    cloneNsDefSlot = &(clone->nsDef);\n+                    for (ns = cur->nsDef; ns != NULL; ns = ns->next) {\n+                        \/*\n+                        * Create a new xmlNs.\n+                        *\/\n+                        cloneNs = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));\n+                        if (cloneNs == NULL)\n+                            goto internal_error;\n+                        memset(cloneNs, 0, sizeof(xmlNs));\n+                        cloneNs->type = XML_LOCAL_NAMESPACE;\n+\n+                        if (ns->href != NULL) {\n+                            cloneNs->href = xmlStrdup(ns->href);\n@@ -9445,2 +8738,2 @@\n-            if (ns->prefix != NULL) {\n-                cloneNs->prefix = xmlStrdup(ns->prefix);\n+                        if (ns->prefix != NULL) {\n+                            cloneNs->prefix = xmlStrdup(ns->prefix);\n@@ -9453,2 +8746,2 @@\n-            *cloneNsDefSlot = cloneNs;\n-            cloneNsDefSlot = &(cloneNs->next);\n+                        *cloneNsDefSlot = cloneNs;\n+                        cloneNsDefSlot = &(cloneNs->next);\n@@ -9456,23 +8749,33 @@\n-            \/*\n-            * Note that for custom handling of ns-references,\n-            * the ns-decls need not be stored in the ns-map,\n-            * since they won't be referenced by node->ns.\n-            *\/\n-            if ((ctxt == NULL) ||\n-                (ctxt->getNsForNodeFunc == NULL))\n-            {\n-                \/*\n-                * Does it shadow any ns-decl?\n-                *\/\n-                if (XML_NSMAP_NOTEMPTY(nsMap)) {\n-                XML_NSMAP_FOREACH(nsMap, mi) {\n-                    if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n-                    (mi->shadowDepth == -1) &&\n-                    ((ns->prefix == mi->newNs->prefix) ||\n-                    xmlStrEqual(ns->prefix,\n-                    mi->newNs->prefix))) {\n-                    \/*\n-                    * Mark as shadowed at the current\n-                    * depth.\n-                    *\/\n-                    mi->shadowDepth = depth;\n+                        \/*\n+                        * Note that for custom handling of ns-references,\n+                        * the ns-decls need not be stored in the ns-map,\n+                        * since they won't be referenced by node->ns.\n+                        *\/\n+                        if ((ctxt == NULL) ||\n+                            (ctxt->getNsForNodeFunc == NULL))\n+                        {\n+                            \/*\n+                            * Does it shadow any ns-decl?\n+                            *\/\n+                            if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                                XML_NSMAP_FOREACH(nsMap, mi) {\n+                                    if ((mi->depth >= XML_TREE_NSMAP_PARENT) &&\n+                                        (mi->shadowDepth == -1) &&\n+                                        ((ns->prefix == mi->newNs->prefix) ||\n+                                        xmlStrEqual(ns->prefix,\n+                                        mi->newNs->prefix))) {\n+                                        \/*\n+                                        * Mark as shadowed at the current\n+                                        * depth.\n+                                        *\/\n+                                        mi->shadowDepth = depth;\n+                                    }\n+                                }\n+                            }\n+                            \/*\n+                            * Push mapping.\n+                            *\/\n+                            if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n+                                ns, cloneNs, depth) == NULL)\n+                                goto internal_error;\n+                        }\n@@ -9481,1 +8784,10 @@\n-                }\n+                \/* cur->ns will be processed further down. *\/\n+                break;\n+            case XML_ATTRIBUTE_NODE:\n+                \/* IDs will be processed further down. *\/\n+                \/* cur->ns will be processed further down. *\/\n+                break;\n+            case XML_PI_NODE:\n+            case XML_COMMENT_NODE:\n+            case XML_TEXT_NODE:\n+            case XML_CDATA_SECTION_NODE:\n@@ -9483,1 +8795,1 @@\n-                * Push mapping.\n+                * Note that this will also cover the values of attributes.\n@@ -9485,19 +8797,0 @@\n-                if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n-                ns, cloneNs, depth) == NULL)\n-                goto internal_error;\n-            }\n-            }\n-        }\n-        \/* cur->ns will be processed further down. *\/\n-        break;\n-        case XML_ATTRIBUTE_NODE:\n-        \/* IDs will be processed further down. *\/\n-        \/* cur->ns will be processed further down. *\/\n-        break;\n-        case XML_PI_NODE:\n-        case XML_COMMENT_NODE:\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        \/*\n-        * Note that this will also cover the values of attributes.\n-        *\/\n@@ -9509,23 +8802,27 @@\n-        goto leave_node;\n-        case XML_ENTITY_REF_NODE:\n-        if (sourceDoc != destDoc) {\n-            if ((destDoc->intSubset) || (destDoc->extSubset)) {\n-            xmlEntityPtr ent;\n-            \/*\n-            * Different doc: Assign new entity-node if available.\n-            *\/\n-            ent = xmlGetDocEntity(destDoc, cur->name);\n-            if (ent != NULL) {\n-                clone->content = ent->content;\n-                clone->children = (xmlNodePtr) ent;\n-                clone->last = (xmlNodePtr) ent;\n-            }\n-            }\n-        } else {\n-            \/*\n-            * Same doc: Use the current node's entity declaration\n-            * and value.\n-            *\/\n-            clone->content = cur->content;\n-            clone->children = cur->children;\n-            clone->last = cur->last;\n+                goto leave_node;\n+            case XML_ENTITY_REF_NODE:\n+                if (sourceDoc != destDoc) {\n+                    if ((destDoc->intSubset) || (destDoc->extSubset)) {\n+                        xmlEntityPtr ent;\n+                        \/*\n+                        * Different doc: Assign new entity-node if available.\n+                        *\/\n+                        ent = xmlGetDocEntity(destDoc, cur->name);\n+                        if (ent != NULL) {\n+                            clone->content = ent->content;\n+                            clone->children = (xmlNodePtr) ent;\n+                            clone->last = (xmlNodePtr) ent;\n+                        }\n+                    }\n+                } else {\n+                    \/*\n+                    * Same doc: Use the current node's entity declaration\n+                    * and value.\n+                    *\/\n+                    clone->content = cur->content;\n+                    clone->children = cur->children;\n+                    clone->last = cur->last;\n+                }\n+                goto leave_node;\n+            default:\n+                goto internal_error;\n@@ -9533,4 +8830,0 @@\n-        goto leave_node;\n-        default:\n-        goto internal_error;\n-    }\n@@ -9538,2 +8831,2 @@\n-    if (cur->ns == NULL)\n-        goto end_ns_reference;\n+        if (cur->ns == NULL)\n+            goto end_ns_reference;\n@@ -9542,9 +8835,11 @@\n-    \/*\n-    ** The following will take care of references to ns-decls ********\n-    ** and is intended only for element- and attribute-nodes.\n-    **\n-    *\/\n-    if (! parnsdone) {\n-        if (destParent && (ctxt == NULL)) {\n-        if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap, destParent) == -1)\n-            goto internal_error;\n+        \/*\n+        ** The following will take care of references to ns-decls ********\n+        ** and is intended only for element- and attribute-nodes.\n+        **\n+        *\/\n+        if (! parnsdone) {\n+            if (destParent && (ctxt == NULL)) {\n+                if (xmlDOMWrapNSNormGatherInScopeNs(&nsMap, destParent) == -1)\n+                    goto internal_error;\n+            }\n+            parnsdone = 1;\n@@ -9552,6 +8847,0 @@\n-        parnsdone = 1;\n-    }\n-    \/*\n-    * Adopt ns-references.\n-    *\/\n-    if (XML_NSMAP_NOTEMPTY(nsMap)) {\n@@ -9559,1 +8848,1 @@\n-        * Search for a mapping.\n+        * Adopt ns-references.\n@@ -9561,3 +8850,1 @@\n-        XML_NSMAP_FOREACH(nsMap, mi) {\n-        if ((mi->shadowDepth == -1) &&\n-            (cur->ns == mi->oldNs)) {\n+        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n@@ -9565,1 +8852,1 @@\n-            * This is the nice case: a mapping was found.\n+            * Search for a mapping.\n@@ -9567,3 +8854,10 @@\n-            clone->ns = mi->newNs;\n-            goto end_ns_reference;\n-        }\n+            XML_NSMAP_FOREACH(nsMap, mi) {\n+                if ((mi->shadowDepth == -1) &&\n+                    (cur->ns == mi->oldNs)) {\n+                    \/*\n+                    * This is the nice case: a mapping was found.\n+                    *\/\n+                    clone->ns = mi->newNs;\n+                    goto end_ns_reference;\n+                }\n+            }\n@@ -9571,5 +8865,0 @@\n-    }\n-    \/*\n-    * No matching namespace in scope. We need a new one.\n-    *\/\n-    if ((ctxt != NULL) && (ctxt->getNsForNodeFunc != NULL)) {\n@@ -9577,14 +8866,1 @@\n-        * User-defined behaviour.\n-        *\/\n-        ns = ctxt->getNsForNodeFunc(ctxt, cur,\n-        cur->ns->href, cur->ns->prefix);\n-        \/*\n-        * Add user's mapping.\n-        *\/\n-        if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n-        cur->ns, ns, XML_TREE_NSMAP_CUSTOM) == NULL)\n-        goto internal_error;\n-        clone->ns = ns;\n-    } else {\n-        \/*\n-        * Acquire a normalized ns-decl and add it to the map.\n+        * No matching namespace in scope. We need a new one.\n@@ -9592,12 +8868,29 @@\n-        if (xmlDOMWrapNSNormAcquireNormalizedNs(destDoc,\n-        \/* ns-decls on cloneElem or on destDoc->oldNs *\/\n-        destParent ? cloneElem : NULL,\n-        cur->ns, &ns,\n-        &nsMap, depth,\n-        \/* if we need to search only in the ancestor-axis *\/\n-        ancestorsOnly,\n-        \/* ns-decls must be prefixed for attributes. *\/\n-        (cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)\n-        goto internal_error;\n-        clone->ns = ns;\n-    }\n+        if ((ctxt != NULL) && (ctxt->getNsForNodeFunc != NULL)) {\n+            \/*\n+            * User-defined behaviour.\n+            *\/\n+            ns = ctxt->getNsForNodeFunc(ctxt, cur,\n+                cur->ns->href, cur->ns->prefix);\n+            \/*\n+            * Add user's mapping.\n+            *\/\n+            if (xmlDOMWrapNsMapAddItem(&nsMap, -1,\n+                cur->ns, ns, XML_TREE_NSMAP_CUSTOM) == NULL)\n+                goto internal_error;\n+            clone->ns = ns;\n+        } else {\n+            \/*\n+            * Acquire a normalized ns-decl and add it to the map.\n+            *\/\n+            if (xmlDOMWrapNSNormAcquireNormalizedNs(destDoc,\n+                \/* ns-decls on cloneElem or on destDoc->oldNs *\/\n+                destParent ? cloneElem : NULL,\n+                cur->ns, &ns,\n+                &nsMap, depth,\n+                \/* if we need to search only in the ancestor-axis *\/\n+                ancestorsOnly,\n+                \/* ns-decls must be prefixed for attributes. *\/\n+                (cur->type == XML_ATTRIBUTE_NODE) ? 1 : 0) == -1)\n+                goto internal_error;\n+            clone->ns = ns;\n+        }\n@@ -9607,8 +8900,8 @@\n-    \/*\n-    * Some post-processing.\n-    *\n-    * Handle ID attributes.\n-    *\/\n-    if ((clone->type == XML_ATTRIBUTE_NODE) &&\n-        (clone->parent != NULL))\n-    {\n+        \/*\n+        * Some post-processing.\n+        *\n+        * Handle ID attributes.\n+        *\/\n+        if ((clone->type == XML_ATTRIBUTE_NODE) &&\n+            (clone->parent != NULL))\n+        {\n@@ -9617,1 +8910,1 @@\n-        res = xmlIsID(destDoc, clone->parent, (xmlAttrPtr) clone);\n+            res = xmlIsID(destDoc, clone->parent, (xmlAttrPtr) clone);\n@@ -9621,1 +8914,1 @@\n-        xmlChar *idVal;\n+                xmlChar *idVal;\n@@ -9623,1 +8916,1 @@\n-        idVal = xmlNodeGetContent(cur);\n+                idVal = xmlNodeGetContent(cur);\n@@ -9631,0 +8924,1 @@\n+            }\n@@ -9632,37 +8926,0 @@\n-    }\n-    \/*\n-    **\n-    ** The following will traverse the tree **************************\n-    **\n-    *\n-    * Walk the element's attributes before descending into child-nodes.\n-    *\/\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->properties != NULL)) {\n-        prevClone = NULL;\n-        parentClone = clone;\n-        cur = (xmlNodePtr) cur->properties;\n-        continue;\n-    }\n-into_content:\n-    \/*\n-    * Descend into child-nodes.\n-    *\/\n-    if (cur->children != NULL) {\n-        if (deep || (cur->type == XML_ATTRIBUTE_NODE)) {\n-        prevClone = NULL;\n-        parentClone = clone;\n-        cur = cur->children;\n-        continue;\n-        }\n-    }\n-\n-leave_node:\n-    \/*\n-    * At this point we are done with the node, its content\n-    * and an element-nodes's attribute-nodes.\n-    *\/\n-    if (cur == node)\n-        break;\n-    if ((cur->type == XML_ELEMENT_NODE) ||\n-        (cur->type == XML_XINCLUDE_START) ||\n-        (cur->type == XML_XINCLUDE_END)) {\n@@ -9670,1 +8927,5 @@\n-        * TODO: Do we expect nsDefs on XML_XINCLUDE_START?\n+        **\n+        ** The following will traverse the tree **************************\n+        **\n+        *\n+        * Walk the element's attributes before descending into child-nodes.\n@@ -9672,1 +8933,7 @@\n-        if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->properties != NULL)) {\n+            prevClone = NULL;\n+            parentClone = clone;\n+            cur = (xmlNodePtr) cur->properties;\n+            continue;\n+        }\n+into_content:\n@@ -9674,1 +8941,1 @@\n-        * Pop mappings.\n+        * Descend into child-nodes.\n@@ -9676,4 +8943,7 @@\n-        while ((nsMap->last != NULL) &&\n-            (nsMap->last->depth >= depth))\n-        {\n-            XML_NSMAP_POP(nsMap, mi)\n+        if (cur->children != NULL) {\n+            if (deep || (cur->type == XML_ATTRIBUTE_NODE)) {\n+                prevClone = NULL;\n+                parentClone = clone;\n+                cur = cur->children;\n+                continue;\n+            }\n@@ -9681,0 +8951,2 @@\n+\n+leave_node:\n@@ -9682,1 +8954,2 @@\n-        * Unshadow.\n+        * At this point we are done with the node, its content\n+        * and an element-nodes's attribute-nodes.\n@@ -9684,3 +8957,26 @@\n-        XML_NSMAP_FOREACH(nsMap, mi) {\n-            if (mi->shadowDepth >= depth)\n-            mi->shadowDepth = -1;\n+        if (cur == node)\n+            break;\n+        if ((cur->type == XML_ELEMENT_NODE) ||\n+            (cur->type == XML_XINCLUDE_START) ||\n+            (cur->type == XML_XINCLUDE_END)) {\n+            \/*\n+            * TODO: Do we expect nsDefs on XML_XINCLUDE_START?\n+            *\/\n+            if (XML_NSMAP_NOTEMPTY(nsMap)) {\n+                \/*\n+                * Pop mappings.\n+                *\/\n+                while ((nsMap->last != NULL) &&\n+                    (nsMap->last->depth >= depth))\n+                {\n+                    XML_NSMAP_POP(nsMap, mi)\n+                }\n+                \/*\n+                * Unshadow.\n+                *\/\n+                XML_NSMAP_FOREACH(nsMap, mi) {\n+                    if (mi->shadowDepth >= depth)\n+                        mi->shadowDepth = -1;\n+                }\n+            }\n+            depth--;\n@@ -9688,0 +8984,21 @@\n+        if (cur->next != NULL) {\n+            prevClone = clone;\n+            cur = cur->next;\n+        } else if (cur->type != XML_ATTRIBUTE_NODE) {\n+            clone = clone->parent;\n+            if (clone != NULL)\n+                parentClone = clone->parent;\n+            \/*\n+            * Process parent --> next;\n+            *\/\n+            cur = cur->parent;\n+            goto leave_node;\n+        } else {\n+            \/* This is for attributes only. *\/\n+            clone = clone->parent;\n+            parentClone = clone->parent;\n+            \/*\n+            * Process parent-element --> children.\n+            *\/\n+            cur = cur->parent;\n+            goto into_content;\n@@ -9689,24 +9006,0 @@\n-        depth--;\n-    }\n-    if (cur->next != NULL) {\n-        prevClone = clone;\n-        cur = cur->next;\n-    } else if (cur->type != XML_ATTRIBUTE_NODE) {\n-        clone = clone->parent;\n-        if (clone != NULL)\n-        parentClone = clone->parent;\n-        \/*\n-        * Process parent --> next;\n-        *\/\n-        cur = cur->parent;\n-        goto leave_node;\n-    } else {\n-        \/* This is for attributes only. *\/\n-        clone = clone->parent;\n-        parentClone = clone->parent;\n-        \/*\n-        * Process parent-element --> children.\n-        *\/\n-        cur = cur->parent;\n-        goto into_content;\n-    }\n@@ -9724,12 +9017,12 @@\n-    if ((ctxt) && (ctxt->namespaceMap == nsMap)) {\n-        \/*\n-        * Just cleanup the map but don't free.\n-        *\/\n-        if (nsMap->first) {\n-        if (nsMap->pool)\n-            nsMap->last->next = nsMap->pool;\n-        nsMap->pool = nsMap->first;\n-        nsMap->first = NULL;\n-        }\n-    } else\n-        xmlDOMWrapNsMapFree(nsMap);\n+        if ((ctxt) && (ctxt->namespaceMap == nsMap)) {\n+            \/*\n+            * Just cleanup the map but don't free.\n+            *\/\n+            if (nsMap->first) {\n+                if (nsMap->pool)\n+                    nsMap->last->next = nsMap->pool;\n+                nsMap->pool = nsMap->first;\n+                nsMap->first = NULL;\n+            }\n+        } else\n+            xmlDOMWrapNsMapFree(nsMap);\n@@ -9763,5 +9056,5 @@\n-            xmlDocPtr sourceDoc ATTRIBUTE_UNUSED,\n-            xmlAttrPtr attr,\n-            xmlDocPtr destDoc,\n-            xmlNodePtr destParent,\n-            int options ATTRIBUTE_UNUSED)\n+                    xmlDocPtr sourceDoc ATTRIBUTE_UNUSED,\n+                    xmlAttrPtr attr,\n+                    xmlDocPtr destDoc,\n+                    xmlNodePtr destParent,\n+                    int options ATTRIBUTE_UNUSED)\n@@ -9772,1 +9065,1 @@\n-    return (-1);\n+        return (-1);\n@@ -9780,1 +9073,1 @@\n-    xmlNsPtr ns = NULL;\n+        xmlNsPtr ns = NULL;\n@@ -9782,21 +9075,2 @@\n-    if (ctxt != NULL) {\n-        \/* TODO: User defined. *\/\n-    }\n-    \/* XML Namespace. *\/\n-    if (IS_STR_XML(attr->ns->prefix)) {\n-        ns = xmlTreeEnsureXMLDecl(destDoc);\n-    } else if (destParent == NULL) {\n-        \/*\n-        * Store in @destDoc->oldNs.\n-        *\/\n-        ns = xmlDOMWrapStoreNs(destDoc, attr->ns->href, attr->ns->prefix);\n-    } else {\n-        \/*\n-        * Declare on @destParent.\n-        *\/\n-        if (xmlSearchNsByNamespaceStrict(destDoc, destParent, attr->ns->href,\n-        &ns, 1) == -1)\n-        ret = -1;\n-        if (ns == NULL) {\n-        ns = xmlDOMWrapNSNormDeclareNsForced(destDoc, destParent,\n-            attr->ns->href, attr->ns->prefix, 1);\n+        if (ctxt != NULL) {\n+            \/* TODO: User defined. *\/\n@@ -9804,4 +9078,23 @@\n-    }\n-    if (ns == NULL)\n-        ret = -1;\n-    attr->ns = ns;\n+        \/* XML Namespace. *\/\n+        if (IS_STR_XML(attr->ns->prefix)) {\n+            ns = xmlTreeEnsureXMLDecl(destDoc);\n+        } else if (destParent == NULL) {\n+            \/*\n+            * Store in @destDoc->oldNs.\n+            *\/\n+            ns = xmlDOMWrapStoreNs(destDoc, attr->ns->href, attr->ns->prefix);\n+        } else {\n+            \/*\n+            * Declare on @destParent.\n+            *\/\n+            if (xmlSearchNsByNamespaceStrict(destDoc, destParent, attr->ns->href,\n+                &ns, 1) == -1)\n+                ret = -1;\n+            if (ns == NULL) {\n+                ns = xmlDOMWrapNSNormDeclareNsForced(destDoc, destParent,\n+                    attr->ns->href, attr->ns->prefix, 1);\n+            }\n+        }\n+        if (ns == NULL)\n+            ret = -1;\n+        attr->ns = ns;\n@@ -9842,5 +9135,5 @@\n-            xmlDocPtr sourceDoc,\n-            xmlNodePtr node,\n-            xmlDocPtr destDoc,\n-            xmlNodePtr destParent,\n-            int options)\n+                    xmlDocPtr sourceDoc,\n+                    xmlNodePtr node,\n+                    xmlDocPtr destDoc,\n+                    xmlNodePtr destParent,\n+                    int options)\n@@ -9852,2 +9145,2 @@\n-    ((destParent != NULL) && (destParent->doc != destDoc)))\n-    return(-1);\n+        ((destParent != NULL) && (destParent->doc != destDoc)))\n+        return(-1);\n@@ -9860,1 +9153,1 @@\n-    return (-1);\n+        return (-1);\n@@ -9867,1 +9160,1 @@\n-    return (-1);\n+        return (-1);\n@@ -9870,13 +9163,13 @@\n-    case XML_ELEMENT_NODE:\n-    case XML_ATTRIBUTE_NODE:\n-    case XML_TEXT_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_ENTITY_REF_NODE:\n-    case XML_PI_NODE:\n-    case XML_COMMENT_NODE:\n-        break;\n-    case XML_DOCUMENT_FRAG_NODE:\n-        \/* TODO: Support document-fragment-nodes. *\/\n-        return (2);\n-    default:\n-        return (1);\n+        case XML_ELEMENT_NODE:\n+        case XML_ATTRIBUTE_NODE:\n+        case XML_TEXT_NODE:\n+        case XML_CDATA_SECTION_NODE:\n+        case XML_ENTITY_REF_NODE:\n+        case XML_PI_NODE:\n+        case XML_COMMENT_NODE:\n+            break;\n+        case XML_DOCUMENT_FRAG_NODE:\n+            \/* TODO: Support document-fragment-nodes. *\/\n+            return (2);\n+        default:\n+            return (1);\n@@ -9888,1 +9181,1 @@\n-    xmlUnlinkNodeInternal(node);\n+        xmlUnlinkNodeInternal(node);\n@@ -9891,2 +9184,2 @@\n-        return (xmlDOMWrapAdoptBranch(ctxt, sourceDoc, node,\n-            destDoc, destParent, options));\n+            return (xmlDOMWrapAdoptBranch(ctxt, sourceDoc, node,\n+                    destDoc, destParent, options));\n@@ -9894,2 +9187,2 @@\n-        return (xmlDOMWrapAdoptAttr(ctxt, sourceDoc,\n-        (xmlAttrPtr) node, destDoc, destParent, options));\n+            return (xmlDOMWrapAdoptAttr(ctxt, sourceDoc,\n+                (xmlAttrPtr) node, destDoc, destParent, options));\n@@ -9906,3 +9199,3 @@\n- *                                    *\n- *            XHTML detection                    *\n- *                                    *\n+ *                                                                      *\n+ *                      XHTML detection                                 *\n+ *                                                                      *\n@@ -9936,1 +9229,1 @@\n-    return(-1);\n+        return(-1);\n@@ -9938,3 +9231,3 @@\n-    if (xmlStrEqual(publicID, XHTML_STRICT_PUBLIC_ID)) return(1);\n-    if (xmlStrEqual(publicID, XHTML_FRAME_PUBLIC_ID)) return(1);\n-    if (xmlStrEqual(publicID, XHTML_TRANS_PUBLIC_ID)) return(1);\n+        if (xmlStrEqual(publicID, XHTML_STRICT_PUBLIC_ID)) return(1);\n+        if (xmlStrEqual(publicID, XHTML_FRAME_PUBLIC_ID)) return(1);\n+        if (xmlStrEqual(publicID, XHTML_TRANS_PUBLIC_ID)) return(1);\n@@ -9943,3 +9236,3 @@\n-    if (xmlStrEqual(systemID, XHTML_STRICT_SYSTEM_ID)) return(1);\n-    if (xmlStrEqual(systemID, XHTML_FRAME_SYSTEM_ID)) return(1);\n-    if (xmlStrEqual(systemID, XHTML_TRANS_SYSTEM_ID)) return(1);\n+        if (xmlStrEqual(systemID, XHTML_STRICT_SYSTEM_ID)) return(1);\n+        if (xmlStrEqual(systemID, XHTML_FRAME_SYSTEM_ID)) return(1);\n+        if (xmlStrEqual(systemID, XHTML_TRANS_SYSTEM_ID)) return(1);\n@@ -9951,3 +9244,3 @@\n- *                                    *\n- *            Node callbacks                    *\n- *                                    *\n+ *                                                                      *\n+ *                      Node callbacks                                  *\n+ *                                                                      *\n@@ -9971,1 +9264,1 @@\n-    __xmlRegisterCallbacks = 1;\n+    xmlRegisterCallbacks = 1;\n@@ -9991,1 +9284,1 @@\n-    __xmlRegisterCallbacks = 1;\n+    xmlRegisterCallbacks = 1;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/tree.c","additions":2590,"deletions":3297,"binary":false,"changes":5887,"status":"modified"},{"patch":"@@ -22,0 +22,1 @@\n+#include \"private\/memory.h\"\n@@ -123,3 +124,3 @@\n- *                                    *\n- *                         RFC 3986 parser                *\n- *                                    *\n+ *                                                                      *\n+ *                         RFC 3986 parser                              *\n+ *                                                                      *\n@@ -129,1 +130,1 @@\n-#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||        \\\n+#define ISA_ALPHA(p) (((*(p) >= 'a') && (*(p) <= 'z')) ||               \\\n@@ -131,2 +132,2 @@\n-#define ISA_HEXDIG(p)                            \\\n-       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||        \\\n+#define ISA_HEXDIG(p)                                                   \\\n+       (ISA_DIGIT(p) || ((*(p) >= 'a') && (*(p) <= 'f')) ||             \\\n@@ -139,4 +140,4 @@\n-#define ISA_SUB_DELIM(p)                        \\\n-      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||        \\\n-       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||        \\\n-       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||        \\\n+#define ISA_SUB_DELIM(p)                                                \\\n+      (((*(p) == '!')) || ((*(p) == '$')) || ((*(p) == '&')) ||         \\\n+       ((*(p) == '(')) || ((*(p) == ')')) || ((*(p) == '*')) ||         \\\n+       ((*(p) == '+')) || ((*(p) == ',')) || ((*(p) == ';')) ||         \\\n@@ -148,1 +149,1 @@\n-#define ISA_GEN_DELIM(p)                        \\\n+#define ISA_GEN_DELIM(p)                                                \\\n@@ -161,2 +162,2 @@\n-#define ISA_STRICTLY_UNRESERVED(p)                    \\\n-      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||        \\\n+#define ISA_STRICTLY_UNRESERVED(p)                                      \\\n+      ((ISA_ALPHA(p)) || (ISA_DIGIT(p)) || ((*(p) == '-')) ||           \\\n@@ -168,1 +169,1 @@\n-#define ISA_PCT_ENCODED(p)                        \\\n+#define ISA_PCT_ENCODED(p)                                              \\\n@@ -174,2 +175,2 @@\n-#define ISA_PCHAR(u, p)                            \\\n-     (ISA_UNRESERVED(u, p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) ||    \\\n+#define ISA_PCHAR(u, p)                                                 \\\n+     (ISA_UNRESERVED(u, p) || ISA_PCT_ENCODED(p) || ISA_SUB_DELIM(p) || \\\n@@ -232,1 +233,1 @@\n-    return(1);\n+        return(1);\n@@ -246,2 +247,2 @@\n-    if (uri->scheme != NULL) xmlFree(uri->scheme);\n-    uri->scheme = STRNDUP(*str, cur - *str);\n+        if (uri->scheme != NULL) xmlFree(uri->scheme);\n+        uri->scheme = STRNDUP(*str, cur - *str);\n@@ -283,4 +284,4 @@\n-    if (uri->cleanup & XML_URI_NO_UNESCAPE)\n-        uri->fragment = STRNDUP(*str, cur - *str);\n-    else\n-        uri->fragment = xmlURIUnescapeString(*str, cur - *str, NULL);\n+        if (uri->cleanup & XML_URI_NO_UNESCAPE)\n+            uri->fragment = STRNDUP(*str, cur - *str);\n+        else\n+            uri->fragment = xmlURIUnescapeString(*str, cur - *str, NULL);\n@@ -317,4 +318,4 @@\n-    if (uri->cleanup & XML_URI_NO_UNESCAPE)\n-        uri->query = STRNDUP(*str, cur - *str);\n-    else\n-        uri->query = xmlURIUnescapeString(*str, cur - *str, NULL);\n+        if (uri->cleanup & XML_URI_NO_UNESCAPE)\n+            uri->query = STRNDUP(*str, cur - *str);\n+        else\n+            uri->query = xmlURIUnescapeString(*str, cur - *str, NULL);\n@@ -324,6 +325,6 @@\n-    \/* Save the raw bytes of the query as well.\n-     * See: http:\/\/mail.gnome.org\/archives\/xml\/2007-April\/thread.html#00114\n-     *\/\n-    if (uri->query_raw != NULL)\n-        xmlFree (uri->query_raw);\n-    uri->query_raw = STRNDUP (*str, cur - *str);\n+        \/* Save the raw bytes of the query as well.\n+         * See: http:\/\/mail.gnome.org\/archives\/xml\/2007-April\/thread.html#00114\n+         *\/\n+        if (uri->query_raw != NULL)\n+            xmlFree (uri->query_raw);\n+        uri->query_raw = STRNDUP (*str, cur - *str);\n@@ -356,1 +357,1 @@\n-    while (ISA_DIGIT(cur)) {\n+        while (ISA_DIGIT(cur)) {\n@@ -364,1 +365,1 @@\n-        port += digit;\n+            port += digit;\n@@ -366,6 +367,6 @@\n-        cur++;\n-    }\n-    if (uri != NULL)\n-        uri->port = port;\n-    *str = cur;\n-    return(0);\n+            cur++;\n+        }\n+        if (uri != NULL)\n+            uri->port = port;\n+        *str = cur;\n+        return(0);\n@@ -396,1 +397,1 @@\n-    NEXT(cur);\n+        NEXT(cur);\n@@ -398,6 +399,6 @@\n-    if (uri != NULL) {\n-        if (uri->user != NULL) xmlFree(uri->user);\n-        if (uri->cleanup & XML_URI_NO_UNESCAPE)\n-        uri->user = STRNDUP(*str, cur - *str);\n-        else\n-        uri->user = xmlURIUnescapeString(*str, cur - *str, NULL);\n+        if (uri != NULL) {\n+            if (uri->user != NULL) xmlFree(uri->user);\n+            if (uri->cleanup & XML_URI_NO_UNESCAPE)\n+                uri->user = STRNDUP(*str, cur - *str);\n+            else\n+                uri->user = xmlURIUnescapeString(*str, cur - *str, NULL);\n@@ -406,3 +407,3 @@\n-    }\n-    *str = cur;\n-    return(0);\n+        }\n+        *str = cur;\n+        return(0);\n@@ -434,1 +435,1 @@\n-    cur++;\n+        cur++;\n@@ -436,1 +437,1 @@\n-    cur += 2;\n+        cur += 2;\n@@ -438,1 +439,1 @@\n-    cur += 3;\n+        cur += 3;\n@@ -440,2 +441,2 @@\n-         (*(cur + 1) <= '4') && (ISA_DIGIT(cur + 2)))\n-    cur += 3;\n+             (*(cur + 1) <= '4') && (ISA_DIGIT(cur + 2)))\n+        cur += 3;\n@@ -443,2 +444,2 @@\n-         (*(cur + 2) >= '0') && (*(cur + 1) <= '5'))\n-    cur += 3;\n+             (*(cur + 2) >= '0') && (*(cur + 1) <= '5'))\n+        cur += 3;\n@@ -477,1 +478,4 @@\n-    while ((*cur != ']') && (*cur != 0))\n+        while ((*cur != ']') && (*cur != 0))\n+            cur++;\n+        if (*cur != ']')\n+            return(1);\n@@ -479,4 +483,1 @@\n-    if (*cur != ']')\n-        return(1);\n-    cur++;\n-    goto found;\n+        goto found;\n@@ -489,4 +490,4 @@\n-        goto not_ipv4;\n-    if (*cur != '.')\n-        goto not_ipv4;\n-    cur++;\n+            goto not_ipv4;\n+        if (*cur != '.')\n+            goto not_ipv4;\n+        cur++;\n@@ -494,3 +495,3 @@\n-        goto not_ipv4;\n-    if (*cur != '.')\n-        goto not_ipv4;\n+            goto not_ipv4;\n+        if (*cur != '.')\n+            goto not_ipv4;\n@@ -498,3 +499,3 @@\n-        goto not_ipv4;\n-    if (*cur != '.')\n-        goto not_ipv4;\n+            goto not_ipv4;\n+        if (*cur != '.')\n+            goto not_ipv4;\n@@ -502,2 +503,2 @@\n-        goto not_ipv4;\n-    goto found;\n+            goto not_ipv4;\n+        goto found;\n@@ -515,8 +516,8 @@\n-    if (uri->authority != NULL) xmlFree(uri->authority);\n-    uri->authority = NULL;\n-    if (uri->server != NULL) xmlFree(uri->server);\n-    if (cur != host) {\n-        if (uri->cleanup & XML_URI_NO_UNESCAPE)\n-        uri->server = STRNDUP(host, cur - host);\n-        else\n-        uri->server = xmlURIUnescapeString(host, cur - host, NULL);\n+        if (uri->authority != NULL) xmlFree(uri->authority);\n+        uri->authority = NULL;\n+        if (uri->server != NULL) xmlFree(uri->server);\n+        if (cur != host) {\n+            if (uri->cleanup & XML_URI_NO_UNESCAPE)\n+                uri->server = STRNDUP(host, cur - host);\n+            else\n+                uri->server = xmlURIUnescapeString(host, cur - host, NULL);\n@@ -525,2 +526,2 @@\n-    } else\n-        uri->server = NULL;\n+        } else\n+            uri->server = NULL;\n@@ -566,1 +567,1 @@\n-    if (ret != 0) return(ret);\n+        if (ret != 0) return(ret);\n@@ -596,2 +597,2 @@\n-        return(0);\n-    return(1);\n+            return(0);\n+        return(1);\n@@ -637,2 +638,2 @@\n-    ret = xmlParse3986Segment(uri, &cur, 0, 1);\n-    if (ret != 0) return(ret);\n+        ret = xmlParse3986Segment(uri, &cur, 0, 1);\n+        if (ret != 0) return(ret);\n@@ -641,1 +642,1 @@\n-    if (uri->path != NULL) xmlFree(uri->path);\n+        if (uri->path != NULL) xmlFree(uri->path);\n@@ -682,5 +683,5 @@\n-    while (*cur == '\/') {\n-        cur++;\n-        ret = xmlParse3986Segment(uri, &cur, 0, 1);\n-        if (ret != 0) return(ret);\n-    }\n+        while (*cur == '\/') {\n+            cur++;\n+            ret = xmlParse3986Segment(uri, &cur, 0, 1);\n+            if (ret != 0) return(ret);\n+        }\n@@ -689,1 +690,1 @@\n-    if (uri->path != NULL) xmlFree(uri->path);\n+        if (uri->path != NULL) xmlFree(uri->path);\n@@ -729,2 +730,2 @@\n-    ret = xmlParse3986Segment(uri, &cur, 0, 1);\n-    if (ret != 0) return(ret);\n+        ret = xmlParse3986Segment(uri, &cur, 0, 1);\n+        if (ret != 0) return(ret);\n@@ -733,1 +734,1 @@\n-    if (uri->path != NULL) xmlFree(uri->path);\n+        if (uri->path != NULL) xmlFree(uri->path);\n@@ -773,2 +774,2 @@\n-    ret = xmlParse3986Segment(uri, &cur, 0, 1);\n-    if (ret != 0) return(ret);\n+        ret = xmlParse3986Segment(uri, &cur, 0, 1);\n+        if (ret != 0) return(ret);\n@@ -777,1 +778,1 @@\n-    if (uri->path != NULL) xmlFree(uri->path);\n+        if (uri->path != NULL) xmlFree(uri->path);\n@@ -818,2 +819,2 @@\n-    ret = xmlParse3986Authority(uri, &cur);\n-    if (ret != 0) return(ret);\n+        ret = xmlParse3986Authority(uri, &cur);\n+        if (ret != 0) return(ret);\n@@ -823,6 +824,6 @@\n-    if ((uri->server == NULL) && (uri->port == PORT_EMPTY))\n-        uri->port = PORT_EMPTY_SERVER;\n-    ret = xmlParse3986PathAbEmpty(uri, &cur);\n-    if (ret != 0) return(ret);\n-    *str = cur;\n-    return(0);\n+        if ((uri->server == NULL) && (uri->port == PORT_EMPTY))\n+            uri->port = PORT_EMPTY_SERVER;\n+        ret = xmlParse3986PathAbEmpty(uri, &cur);\n+        if (ret != 0) return(ret);\n+        *str = cur;\n+        return(0);\n@@ -831,1 +832,1 @@\n-    if (ret != 0) return(ret);\n+        if (ret != 0) return(ret);\n@@ -834,1 +835,1 @@\n-    if (ret != 0) return(ret);\n+        if (ret != 0) return(ret);\n@@ -836,5 +837,5 @@\n-    \/* path-empty is effectively empty *\/\n-    if (uri != NULL) {\n-        if (uri->path != NULL) xmlFree(uri->path);\n-        uri->path = NULL;\n-    }\n+        \/* path-empty is effectively empty *\/\n+        if (uri != NULL) {\n+            if (uri->path != NULL) xmlFree(uri->path);\n+            uri->path = NULL;\n+        }\n@@ -868,4 +869,4 @@\n-    ret = xmlParse3986Authority(uri, &str);\n-    if (ret != 0) return(ret);\n-    ret = xmlParse3986PathAbEmpty(uri, &str);\n-    if (ret != 0) return(ret);\n+        ret = xmlParse3986Authority(uri, &str);\n+        if (ret != 0) return(ret);\n+        ret = xmlParse3986PathAbEmpty(uri, &str);\n+        if (ret != 0) return(ret);\n@@ -873,2 +874,2 @@\n-    ret = xmlParse3986PathAbsolute(uri, &str);\n-    if (ret != 0) return(ret);\n+        ret = xmlParse3986PathAbsolute(uri, &str);\n+        if (ret != 0) return(ret);\n@@ -877,1 +878,1 @@\n-    if (ret != 0) return(ret);\n+        if (ret != 0) return(ret);\n@@ -879,5 +880,5 @@\n-    \/* path-empty is effectively empty *\/\n-    if (uri != NULL) {\n-        if (uri->path != NULL) xmlFree(uri->path);\n-        uri->path = NULL;\n-    }\n+        \/* path-empty is effectively empty *\/\n+        if (uri != NULL) {\n+            if (uri->path != NULL) xmlFree(uri->path);\n+            uri->path = NULL;\n+        }\n@@ -887,3 +888,3 @@\n-    str++;\n-    ret = xmlParse3986Query(uri, &str);\n-    if (ret != 0) return(ret);\n+        str++;\n+        ret = xmlParse3986Query(uri, &str);\n+        if (ret != 0) return(ret);\n@@ -892,3 +893,3 @@\n-    str++;\n-    ret = xmlParse3986Fragment(uri, &str);\n-    if (ret != 0) return(ret);\n+        str++;\n+        ret = xmlParse3986Fragment(uri, &str);\n+        if (ret != 0) return(ret);\n@@ -897,2 +898,2 @@\n-    xmlCleanURI(uri);\n-    return(1);\n+        xmlCleanURI(uri);\n+        return(1);\n@@ -923,1 +924,1 @@\n-    return(1);\n+        return(1);\n@@ -929,3 +930,3 @@\n-    str++;\n-    ret = xmlParse3986Query(uri, &str);\n-    if (ret != 0) return(ret);\n+        str++;\n+        ret = xmlParse3986Query(uri, &str);\n+        if (ret != 0) return(ret);\n@@ -934,3 +935,3 @@\n-    str++;\n-    ret = xmlParse3986Fragment(uri, &str);\n-    if (ret != 0) return(ret);\n+        str++;\n+        ret = xmlParse3986Fragment(uri, &str);\n+        if (ret != 0) return(ret);\n@@ -939,2 +940,2 @@\n-    xmlCleanURI(uri);\n-    return(1);\n+        xmlCleanURI(uri);\n+        return(1);\n@@ -962,1 +963,1 @@\n-    return(-1);\n+        return(-1);\n@@ -972,3 +973,0 @@\n-    if (ret != 0) {\n-    xmlCleanURI(uri);\n-        ret = xmlParse3986RelativeRef(uri, str);\n@@ -977,2 +975,5 @@\n-        return(ret);\n-    }\n+        ret = xmlParse3986RelativeRef(uri, str);\n+        if (ret != 0) {\n+            xmlCleanURI(uri);\n+            return(ret);\n+        }\n@@ -1006,1 +1007,1 @@\n-    return(1);\n+        return(1);\n@@ -1073,1 +1074,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1077,3 +1078,3 @@\n-        uri->cleanup |= XML_URI_NO_UNESCAPE;\n-    }\n-    ret = xmlParseURIReference(uri, str);\n+            uri->cleanup |= XML_URI_NO_UNESCAPE;\n+        }\n+        ret = xmlParseURIReference(uri, str);\n@@ -1081,3 +1082,3 @@\n-        xmlFreeURI(uri);\n-        return(NULL);\n-    }\n+            xmlFreeURI(uri);\n+            return(NULL);\n+        }\n@@ -1089,3 +1090,3 @@\n- *                                    *\n- *            Generic URI structure functions            *\n- *                                    *\n+ *                                                                      *\n+ *                      Generic URI structure functions                 *\n+ *                                                                      *\n@@ -1107,1 +1108,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1122,1 +1123,1 @@\n-    int tmp;\n+    int newSize;\n@@ -1124,1 +1125,2 @@\n-    if (*max > MAX_URI_LENGTH)\n+    newSize = xmlGrowCapacity(*max, 1, 80, MAX_URI_LENGTH);\n+    if (newSize < 0)\n@@ -1126,2 +1128,1 @@\n-    tmp = *max * 2;\n-    temp = (xmlChar *) xmlRealloc(ret, (tmp + 1));\n+    temp = xmlRealloc(ret, newSize + 1);\n@@ -1130,1 +1131,1 @@\n-    *max = tmp;\n+    *max = newSize;\n@@ -1154,1 +1155,1 @@\n-    ret = (xmlChar *) xmlMallocAtomic(max + 1);\n+    ret = xmlMalloc(max + 1);\n@@ -1156,1 +1157,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1160,3 +1161,3 @@\n-    p = uri->scheme;\n-    while (*p != 0) {\n-        if (len >= max) {\n+        p = uri->scheme;\n+        while (*p != 0) {\n+            if (len >= max) {\n@@ -1165,1 +1166,3 @@\n-        ret = temp;\n+                ret = temp;\n+            }\n+            ret[len++] = *p++;\n@@ -1167,3 +1170,1 @@\n-        ret[len++] = *p++;\n-    }\n-    if (len >= max) {\n+        if (len >= max) {\n@@ -1173,2 +1174,2 @@\n-    }\n-    ret[len++] = ':';\n+        }\n+        ret[len++] = ':';\n@@ -1177,3 +1178,3 @@\n-    p = uri->opaque;\n-    while (*p != 0) {\n-        if (len + 3 >= max) {\n+        p = uri->opaque;\n+        while (*p != 0) {\n+            if (len + 3 >= max) {\n@@ -1183,0 +1184,10 @@\n+            }\n+            if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))\n+                ret[len++] = *p++;\n+            else {\n+                int val = *(unsigned char *)p++;\n+                int hi = val \/ 0x10, lo = val % 0x10;\n+                ret[len++] = '%';\n+                ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n+                ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n+            }\n@@ -1184,10 +1195,0 @@\n-        if (IS_RESERVED(*(p)) || IS_UNRESERVED(*(p)))\n-        ret[len++] = *p++;\n-        else {\n-        int val = *(unsigned char *)p++;\n-        int hi = val \/ 0x10, lo = val % 0x10;\n-        ret[len++] = '%';\n-        ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n-        ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n-        }\n-    }\n@@ -1195,2 +1196,2 @@\n-    if ((uri->server != NULL) || (uri->port != PORT_EMPTY)) {\n-        if (len + 3 >= max) {\n+        if ((uri->server != NULL) || (uri->port != PORT_EMPTY)) {\n+            if (len + 3 >= max) {\n@@ -1200,7 +1201,7 @@\n-        }\n-        ret[len++] = '\/';\n-        ret[len++] = '\/';\n-        if (uri->user != NULL) {\n-        p = uri->user;\n-        while (*p != 0) {\n-            if (len + 3 >= max) {\n+            }\n+            ret[len++] = '\/';\n+            ret[len++] = '\/';\n+            if (uri->user != NULL) {\n+                p = uri->user;\n+                while (*p != 0) {\n+                    if (len + 3 >= max) {\n@@ -1210,16 +1211,16 @@\n-            }\n-            if ((IS_UNRESERVED(*(p))) ||\n-            ((*(p) == ';')) || ((*(p) == ':')) ||\n-            ((*(p) == '&')) || ((*(p) == '=')) ||\n-            ((*(p) == '+')) || ((*(p) == '$')) ||\n-            ((*(p) == ',')))\n-            ret[len++] = *p++;\n-            else {\n-            int val = *(unsigned char *)p++;\n-            int hi = val \/ 0x10, lo = val % 0x10;\n-            ret[len++] = '%';\n-            ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n-            ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n-            }\n-        }\n-        if (len + 3 >= max) {\n+                    }\n+                    if ((IS_UNRESERVED(*(p))) ||\n+                        ((*(p) == ';')) || ((*(p) == ':')) ||\n+                        ((*(p) == '&')) || ((*(p) == '=')) ||\n+                        ((*(p) == '+')) || ((*(p) == '$')) ||\n+                        ((*(p) == ',')))\n+                        ret[len++] = *p++;\n+                    else {\n+                        int val = *(unsigned char *)p++;\n+                        int hi = val \/ 0x10, lo = val % 0x10;\n+                        ret[len++] = '%';\n+                        ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n+                        ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n+                    }\n+                }\n+                if (len + 3 >= max) {\n@@ -1229,10 +1230,2 @@\n-        }\n-        ret[len++] = '@';\n-        }\n-        if (uri->server != NULL) {\n-        p = uri->server;\n-        while (*p != 0) {\n-            if (len >= max) {\n-            temp = xmlSaveUriRealloc(ret, &max);\n-            if (temp == NULL) goto mem_error;\n-            ret = temp;\n+                }\n+                ret[len++] = '@';\n@@ -1240,0 +1233,8 @@\n+            if (uri->server != NULL) {\n+                p = uri->server;\n+                while (*p != 0) {\n+                    if (len >= max) {\n+                        temp = xmlSaveUriRealloc(ret, &max);\n+                        if (temp == NULL) goto mem_error;\n+                        ret = temp;\n+                    }\n@@ -1241,3 +1242,3 @@\n-            ret[len++] = (xmlChar) *p++;\n-        }\n-        }\n+                    ret[len++] = (xmlChar) *p++;\n+                }\n+            }\n@@ -1252,2 +1253,2 @@\n-    } else if (uri->authority != NULL) {\n-        if (len + 3 >= max) {\n+        } else if (uri->authority != NULL) {\n+            if (len + 3 >= max) {\n@@ -1257,6 +1258,6 @@\n-        }\n-        ret[len++] = '\/';\n-        ret[len++] = '\/';\n-        p = uri->authority;\n-        while (*p != 0) {\n-        if (len + 3 >= max) {\n+            }\n+            ret[len++] = '\/';\n+            ret[len++] = '\/';\n+            p = uri->authority;\n+            while (*p != 0) {\n+                if (len + 3 >= max) {\n@@ -1266,2 +1267,2 @@\n-        }\n-        if ((IS_UNRESERVED(*(p))) ||\n+                }\n+                if ((IS_UNRESERVED(*(p))) ||\n@@ -1271,11 +1272,11 @@\n-            ret[len++] = *p++;\n-        else {\n-            int val = *(unsigned char *)p++;\n-            int hi = val \/ 0x10, lo = val % 0x10;\n-            ret[len++] = '%';\n-            ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n-            ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n-        }\n-        }\n-    } else if (uri->scheme != NULL) {\n-        if (len + 3 >= max) {\n+                    ret[len++] = *p++;\n+                else {\n+                    int val = *(unsigned char *)p++;\n+                    int hi = val \/ 0x10, lo = val % 0x10;\n+                    ret[len++] = '%';\n+                    ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n+                    ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n+                }\n+            }\n+        } else if (uri->scheme != NULL) {\n+            if (len + 3 >= max) {\n@@ -1285,0 +1286,1 @@\n+            }\n@@ -1286,14 +1288,13 @@\n-    }\n-    if (uri->path != NULL) {\n-        p = uri->path;\n-        \/*\n-         * the colon in file:\/\/\/d: should not be escaped or\n-         * Windows accesses fail later.\n-         *\/\n-        if ((uri->scheme != NULL) &&\n-        (p[0] == '\/') &&\n-        (((p[1] >= 'a') && (p[1] <= 'z')) ||\n-         ((p[1] >= 'A') && (p[1] <= 'Z'))) &&\n-        (p[2] == ':') &&\n-            (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST \"file\"))) {\n-        if (len + 3 >= max) {\n+        if (uri->path != NULL) {\n+            p = uri->path;\n+            \/*\n+             * the colon in file:\/\/\/d: should not be escaped or\n+             * Windows accesses fail later.\n+             *\/\n+            if ((uri->scheme != NULL) &&\n+                (p[0] == '\/') &&\n+                (((p[1] >= 'a') && (p[1] <= 'z')) ||\n+                 ((p[1] >= 'A') && (p[1] <= 'Z'))) &&\n+                (p[2] == ':') &&\n+                (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST \"file\"))) {\n+                if (len + 3 >= max) {\n@@ -1303,7 +1304,7 @@\n-        }\n-        ret[len++] = *p++;\n-        ret[len++] = *p++;\n-        ret[len++] = *p++;\n-        }\n-        while (*p != 0) {\n-        if (len + 3 >= max) {\n+                }\n+                ret[len++] = *p++;\n+                ret[len++] = *p++;\n+                ret[len++] = *p++;\n+            }\n+            while (*p != 0) {\n+                if (len + 3 >= max) {\n@@ -1313,2 +1314,2 @@\n-        }\n-        if ((IS_UNRESERVED(*(p))) || ((*(p) == '\/')) ||\n+                }\n+                if ((IS_UNRESERVED(*(p))) || ((*(p) == '\/')) ||\n@@ -1316,10 +1317,11 @@\n-                ((*(p) == '=')) || ((*(p) == '+')) || ((*(p) == '$')) ||\n-                ((*(p) == ',')))\n-            ret[len++] = *p++;\n-        else {\n-            int val = *(unsigned char *)p++;\n-            int hi = val \/ 0x10, lo = val % 0x10;\n-            ret[len++] = '%';\n-            ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n-            ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n-        }\n+                    ((*(p) == '=')) || ((*(p) == '+')) || ((*(p) == '$')) ||\n+                    ((*(p) == ',')))\n+                    ret[len++] = *p++;\n+                else {\n+                    int val = *(unsigned char *)p++;\n+                    int hi = val \/ 0x10, lo = val % 0x10;\n+                    ret[len++] = '%';\n+                    ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n+                    ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n+                }\n+            }\n@@ -1327,3 +1329,2 @@\n-    }\n-    if (uri->query_raw != NULL) {\n-        if (len + 1 >= max) {\n+        if (uri->query_raw != NULL) {\n+            if (len + 1 >= max) {\n@@ -1333,5 +1334,5 @@\n-        }\n-        ret[len++] = '?';\n-        p = uri->query_raw;\n-        while (*p != 0) {\n-        if (len + 1 >= max) {\n+            }\n+            ret[len++] = '?';\n+            p = uri->query_raw;\n+            while (*p != 0) {\n+                if (len + 1 >= max) {\n@@ -1341,5 +1342,5 @@\n-        }\n-        ret[len++] = *p++;\n-        }\n-    } else if (uri->query != NULL) {\n-        if (len + 3 >= max) {\n+                }\n+                ret[len++] = *p++;\n+            }\n+        } else if (uri->query != NULL) {\n+            if (len + 3 >= max) {\n@@ -1349,5 +1350,5 @@\n-        }\n-        ret[len++] = '?';\n-        p = uri->query;\n-        while (*p != 0) {\n-        if (len + 3 >= max) {\n+            }\n+            ret[len++] = '?';\n+            p = uri->query;\n+            while (*p != 0) {\n+                if (len + 3 >= max) {\n@@ -1357,0 +1358,11 @@\n+                }\n+                if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))\n+                    ret[len++] = *p++;\n+                else {\n+                    int val = *(unsigned char *)p++;\n+                    int hi = val \/ 0x10, lo = val % 0x10;\n+                    ret[len++] = '%';\n+                    ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n+                    ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n+                }\n+            }\n@@ -1358,11 +1370,0 @@\n-        if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))\n-            ret[len++] = *p++;\n-        else {\n-            int val = *(unsigned char *)p++;\n-            int hi = val \/ 0x10, lo = val % 0x10;\n-            ret[len++] = '%';\n-            ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n-            ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n-        }\n-        }\n-    }\n@@ -1371,1 +1372,1 @@\n-    if (len + 3 >= max) {\n+        if (len + 3 >= max) {\n@@ -1375,5 +1376,5 @@\n-    }\n-    ret[len++] = '#';\n-    p = uri->fragment;\n-    while (*p != 0) {\n-        if (len + 3 >= max) {\n+        }\n+        ret[len++] = '#';\n+        p = uri->fragment;\n+        while (*p != 0) {\n+            if (len + 3 >= max) {\n@@ -1383,9 +1384,10 @@\n-        }\n-        if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))\n-        ret[len++] = *p++;\n-        else {\n-        int val = *(unsigned char *)p++;\n-        int hi = val \/ 0x10, lo = val % 0x10;\n-        ret[len++] = '%';\n-        ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n-        ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n+            }\n+            if ((IS_UNRESERVED(*(p))) || (IS_RESERVED(*(p))))\n+                ret[len++] = *p++;\n+            else {\n+                int val = *(unsigned char *)p++;\n+                int hi = val \/ 0x10, lo = val % 0x10;\n+                ret[len++] = '%';\n+                ret[len++] = hi + (hi > 9? 'A'-10 : '0');\n+                ret[len++] = lo + (lo > 9? 'A'-10 : '0');\n+            }\n@@ -1394,1 +1396,0 @@\n-    }\n@@ -1421,2 +1422,2 @@\n-    fprintf(stream, \"%s\", (char *) out);\n-    xmlFree(out);\n+        fprintf(stream, \"%s\", (char *) out);\n+        xmlFree(out);\n@@ -1479,3 +1480,3 @@\n- *                                    *\n- *            Helper functions                *\n- *                                    *\n+ *                                                                      *\n+ *                      Helper functions                                *\n+ *                                                                      *\n@@ -1514,1 +1515,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1618,1 +1619,1 @@\n-    return(1);\n+        return(1);\n@@ -1642,1 +1643,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1647,3 +1648,3 @@\n-    ret = (char *) xmlMallocAtomic(len + 1);\n-    if (ret == NULL)\n-        return(NULL);\n+        ret = xmlMalloc(len + 1);\n+        if (ret == NULL)\n+            return(NULL);\n@@ -1651,1 +1652,1 @@\n-    ret = target;\n+        ret = target;\n@@ -1655,1 +1656,1 @@\n-    if ((len > 2) && (*in == '%') && (is_hex(in[1])) && (is_hex(in[2]))) {\n+        if ((len > 2) && (*in == '%') && (is_hex(in[1])) && (is_hex(in[2]))) {\n@@ -1657,16 +1658,16 @@\n-        in++;\n-        if ((*in >= '0') && (*in <= '9'))\n-            c = (*in - '0');\n-        else if ((*in >= 'a') && (*in <= 'f'))\n-            c = (*in - 'a') + 10;\n-        else if ((*in >= 'A') && (*in <= 'F'))\n-            c = (*in - 'A') + 10;\n-        in++;\n-        if ((*in >= '0') && (*in <= '9'))\n-            c = c * 16 + (*in - '0');\n-        else if ((*in >= 'a') && (*in <= 'f'))\n-            c = c * 16 + (*in - 'a') + 10;\n-        else if ((*in >= 'A') && (*in <= 'F'))\n-            c = c * 16 + (*in - 'A') + 10;\n-        in++;\n-        len -= 3;\n+            in++;\n+            if ((*in >= '0') && (*in <= '9'))\n+                c = (*in - '0');\n+            else if ((*in >= 'a') && (*in <= 'f'))\n+                c = (*in - 'a') + 10;\n+            else if ((*in >= 'A') && (*in <= 'F'))\n+                c = (*in - 'A') + 10;\n+            in++;\n+            if ((*in >= '0') && (*in <= '9'))\n+                c = c * 16 + (*in - '0');\n+            else if ((*in >= 'a') && (*in <= 'f'))\n+                c = c * 16 + (*in - 'a') + 10;\n+            else if ((*in >= 'A') && (*in <= 'F'))\n+                c = c * 16 + (*in - 'A') + 10;\n+            in++;\n+            len -= 3;\n@@ -1674,5 +1675,5 @@\n-        *out++ = (char) c;\n-    } else {\n-        *out++ = *in++;\n-        len--;\n-    }\n+            *out++ = (char) c;\n+        } else {\n+            *out++ = *in++;\n+            len--;\n+        }\n@@ -1698,1 +1699,0 @@\n-    xmlChar *temp;\n@@ -1703,1 +1703,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1705,1 +1705,1 @@\n-    return(xmlStrdup(str));\n+        return(xmlStrdup(str));\n@@ -1709,1 +1709,1 @@\n-    ret = (xmlChar *) xmlMallocAtomic(len);\n+    ret = xmlMalloc(len);\n@@ -1711,1 +1711,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1715,2 +1715,7 @@\n-    if (len - out <= 3) {\n-            if (len > INT_MAX \/ 2)\n+        if (len - out <= 3) {\n+            xmlChar *temp;\n+            int newSize;\n+\n+            newSize = xmlGrowCapacity(len, 1, 1, XML_MAX_ITEMS);\n+            if (newSize < 0) {\n+                xmlFree(ret);\n@@ -1718,4 +1723,8 @@\n-            temp = xmlRealloc(ret, len * 2);\n-        if (temp == NULL) {\n-        xmlFree(ret);\n-        return(NULL);\n+            }\n+            temp = xmlRealloc(ret, newSize);\n+            if (temp == NULL) {\n+                xmlFree(ret);\n+                return(NULL);\n+            }\n+            ret = temp;\n+            len = newSize;\n@@ -1723,3 +1732,0 @@\n-        ret = temp;\n-            len *= 2;\n-    }\n@@ -1727,1 +1733,1 @@\n-    ch = *in;\n+        ch = *in;\n@@ -1729,17 +1735,17 @@\n-    if ((ch != '@') && (!IS_UNRESERVED(ch)) && (!xmlStrchr(list, ch))) {\n-        unsigned char val;\n-        ret[out++] = '%';\n-        val = ch >> 4;\n-        if (val <= 9)\n-        ret[out++] = '0' + val;\n-        else\n-        ret[out++] = 'A' + val - 0xA;\n-        val = ch & 0xF;\n-        if (val <= 9)\n-        ret[out++] = '0' + val;\n-        else\n-        ret[out++] = 'A' + val - 0xA;\n-        in++;\n-    } else {\n-        ret[out++] = *in++;\n-    }\n+        if ((ch != '@') && (!IS_UNRESERVED(ch)) && (!xmlStrchr(list, ch))) {\n+            unsigned char val;\n+            ret[out++] = '%';\n+            val = ch >> 4;\n+            if (val <= 9)\n+                ret[out++] = '0' + val;\n+            else\n+                ret[out++] = 'A' + val - 0xA;\n+            val = ch & 0xF;\n+            if (val <= 9)\n+                ret[out++] = '0' + val;\n+            else\n+                ret[out++] = 'A' + val - 0xA;\n+            in++;\n+        } else {\n+            ret[out++] = *in++;\n+        }\n@@ -1779,3 +1785,3 @@\n-    \/*\n-     * Allow escaping errors in the unescaped form\n-     *\/\n+        \/*\n+         * Allow escaping errors in the unescaped form\n+         *\/\n@@ -1886,3 +1892,3 @@\n- *                                    *\n- *            Public functions                *\n- *                                    *\n+ *                                                                      *\n+ *                      Public functions                                *\n+ *                                                                      *\n@@ -2066,1 +2072,1 @@\n-    goto done;\n+        goto done;\n@@ -2068,4 +2074,4 @@\n-    \/*\n-     * The URI is absolute don't modify.\n-     *\/\n-    val = xmlStrdup(URI);\n+        \/*\n+         * The URI is absolute don't modify.\n+         *\/\n+        val = xmlStrdup(URI);\n@@ -2074,1 +2080,1 @@\n-    goto done;\n+        goto done;\n@@ -2107,1 +2113,1 @@\n-    if (ref) {\n+        if (ref) {\n@@ -2109,1 +2115,1 @@\n-        val = xmlSaveUri(ref);\n+            val = xmlSaveUri(ref);\n@@ -2113,1 +2119,1 @@\n-    goto done;\n+        goto done;\n@@ -2116,8 +2122,8 @@\n-    \/*\n-     * the base fragment must be ignored\n-     *\/\n-    if (bas->fragment != NULL) {\n-        xmlFree(bas->fragment);\n-        bas->fragment = NULL;\n-    }\n-    val = xmlSaveUri(bas);\n+        \/*\n+         * the base fragment must be ignored\n+         *\/\n+        if (bas->fragment != NULL) {\n+            xmlFree(bas->fragment);\n+            bas->fragment = NULL;\n+        }\n+        val = xmlSaveUri(bas);\n@@ -2126,1 +2132,1 @@\n-    goto done;\n+        goto done;\n@@ -2144,1 +2150,1 @@\n-    goto done;\n+        goto done;\n@@ -2146,1 +2152,1 @@\n-    ((ref->authority == NULL) && (ref->server == NULL) &&\n+        ((ref->authority == NULL) && (ref->server == NULL) &&\n@@ -2148,2 +2154,2 @@\n-    if (bas->scheme != NULL) {\n-        res->scheme = xmlMemStrdup(bas->scheme);\n+        if (bas->scheme != NULL) {\n+            res->scheme = xmlMemStrdup(bas->scheme);\n@@ -2153,2 +2159,2 @@\n-    if (bas->authority != NULL) {\n-        res->authority = xmlMemStrdup(bas->authority);\n+        if (bas->authority != NULL) {\n+            res->authority = xmlMemStrdup(bas->authority);\n@@ -2158,2 +2164,2 @@\n-        if (bas->server != NULL) {\n-        res->server = xmlMemStrdup(bas->server);\n+            if (bas->server != NULL) {\n+                res->server = xmlMemStrdup(bas->server);\n@@ -2163,2 +2169,2 @@\n-        if (bas->user != NULL) {\n-        res->user = xmlMemStrdup(bas->user);\n+            if (bas->user != NULL) {\n+                res->user = xmlMemStrdup(bas->user);\n@@ -2168,4 +2174,4 @@\n-        res->port = bas->port;\n-    }\n-    if (bas->path != NULL) {\n-        res->path = xmlMemStrdup(bas->path);\n+            res->port = bas->port;\n+        }\n+        if (bas->path != NULL) {\n+            res->path = xmlMemStrdup(bas->path);\n@@ -2175,2 +2181,2 @@\n-    if (ref->query_raw != NULL) {\n-        res->query_raw = xmlMemStrdup (ref->query_raw);\n+        if (ref->query_raw != NULL) {\n+            res->query_raw = xmlMemStrdup (ref->query_raw);\n@@ -2180,1 +2186,1 @@\n-        res->query = xmlMemStrdup(ref->query);\n+            res->query = xmlMemStrdup(ref->query);\n@@ -2184,1 +2190,1 @@\n-        res->query_raw = xmlMemStrdup(bas->query_raw);\n+            res->query_raw = xmlMemStrdup(bas->query_raw);\n@@ -2188,1 +2194,1 @@\n-        res->query = xmlMemStrdup(bas->query);\n+            res->query = xmlMemStrdup(bas->query);\n@@ -2192,2 +2198,2 @@\n-    if (ref->fragment != NULL) {\n-        res->fragment = xmlMemStrdup(ref->fragment);\n+        if (ref->fragment != NULL) {\n+            res->fragment = xmlMemStrdup(ref->fragment);\n@@ -2197,1 +2203,1 @@\n-    goto step_7;\n+        goto step_7;\n@@ -2207,1 +2213,1 @@\n-    val = xmlSaveUri(ref);\n+        val = xmlSaveUri(ref);\n@@ -2210,1 +2216,1 @@\n-    goto done;\n+        goto done;\n@@ -2213,1 +2219,1 @@\n-    res->scheme = xmlMemStrdup(bas->scheme);\n+        res->scheme = xmlMemStrdup(bas->scheme);\n@@ -2219,1 +2225,1 @@\n-    res->query_raw = xmlMemStrdup(ref->query_raw);\n+        res->query_raw = xmlMemStrdup(ref->query_raw);\n@@ -2223,1 +2229,1 @@\n-    res->query = xmlMemStrdup(ref->query);\n+        res->query = xmlMemStrdup(ref->query);\n@@ -2228,1 +2234,1 @@\n-    res->fragment = xmlMemStrdup(ref->fragment);\n+        res->fragment = xmlMemStrdup(ref->fragment);\n@@ -2242,2 +2248,2 @@\n-    if (ref->authority != NULL) {\n-        res->authority = xmlMemStrdup(ref->authority);\n+        if (ref->authority != NULL) {\n+            res->authority = xmlMemStrdup(ref->authority);\n@@ -2252,2 +2258,2 @@\n-        if (ref->user != NULL) {\n-        res->user = xmlMemStrdup(ref->user);\n+            if (ref->user != NULL) {\n+                res->user = xmlMemStrdup(ref->user);\n@@ -2258,3 +2264,3 @@\n-    }\n-    if (ref->path != NULL) {\n-        res->path = xmlMemStrdup(ref->path);\n+        }\n+        if (ref->path != NULL) {\n+            res->path = xmlMemStrdup(ref->path);\n@@ -2264,1 +2270,1 @@\n-    goto step_7;\n+        goto step_7;\n@@ -2267,1 +2273,1 @@\n-    res->authority = xmlMemStrdup(bas->authority);\n+        res->authority = xmlMemStrdup(bas->authority);\n@@ -2271,2 +2277,2 @@\n-    if (bas->server != NULL) {\n-        res->server = xmlMemStrdup(bas->server);\n+        if (bas->server != NULL) {\n+            res->server = xmlMemStrdup(bas->server);\n@@ -2276,2 +2282,2 @@\n-    if (bas->user != NULL) {\n-        res->user = xmlMemStrdup(bas->user);\n+        if (bas->user != NULL) {\n+            res->user = xmlMemStrdup(bas->user);\n@@ -2281,1 +2287,1 @@\n-    res->port = bas->port;\n+        res->port = bas->port;\n@@ -2289,1 +2295,1 @@\n-    res->path = xmlMemStrdup(ref->path);\n+        res->path = xmlMemStrdup(ref->path);\n@@ -2292,1 +2298,1 @@\n-    goto step_7;\n+        goto step_7;\n@@ -2306,1 +2312,1 @@\n-    len += strlen(ref->path);\n+        len += strlen(ref->path);\n@@ -2308,2 +2314,2 @@\n-    len += strlen(bas->path);\n-    res->path = (char *) xmlMallocAtomic(len);\n+        len += strlen(bas->path);\n+    res->path = xmlMalloc(len);\n@@ -2311,1 +2317,1 @@\n-    goto done;\n+        goto done;\n@@ -2322,5 +2328,5 @@\n-    while (bas->path[cur] != 0) {\n-        while ((bas->path[cur] != 0) && (bas->path[cur] != '\/'))\n-        cur++;\n-        if (bas->path[cur] == 0)\n-        break;\n+        while (bas->path[cur] != 0) {\n+            while ((bas->path[cur] != 0) && (bas->path[cur] != '\/'))\n+                cur++;\n+            if (bas->path[cur] == 0)\n+                break;\n@@ -2328,4 +2334,5 @@\n-        cur++;\n-        while (out < cur) {\n-        res->path[out] = bas->path[out];\n-        out++;\n+            cur++;\n+            while (out < cur) {\n+                res->path[out] = bas->path[out];\n+                out++;\n+            }\n@@ -2334,1 +2341,0 @@\n-    }\n@@ -2342,9 +2348,9 @@\n-    indx = 0;\n-    \/*\n-     * Ensure the path includes a '\/'\n-     *\/\n-    if ((out == 0) && ((bas->server != NULL) || bas->port != PORT_EMPTY))\n-        res->path[out++] = '\/';\n-    while (ref->path[indx] != 0) {\n-        res->path[out++] = ref->path[indx++];\n-    }\n+        indx = 0;\n+        \/*\n+         * Ensure the path includes a '\/'\n+         *\/\n+        if ((out == 0) && ((bas->server != NULL) || bas->port != PORT_EMPTY))\n+            res->path[out++] = '\/';\n+        while (ref->path[indx] != 0) {\n+            res->path[out++] = ref->path[indx++];\n+        }\n@@ -2372,1 +2378,1 @@\n-    xmlFreeURI(ref);\n+        xmlFreeURI(ref);\n@@ -2374,1 +2380,1 @@\n-    xmlFreeURI(bas);\n+        xmlFreeURI(bas);\n@@ -2376,1 +2382,1 @@\n-    xmlFreeURI(res);\n+        xmlFreeURI(res);\n@@ -2416,1 +2422,1 @@\n-    goto done;\n+        goto done;\n@@ -2501,3 +2507,3 @@\n-    ret = xmlParseURIReference(uri, str);\n-    if (ret != 0)\n-        goto done;\n+        ret = xmlParseURIReference(uri, str);\n+        if (ret != 0)\n+            goto done;\n@@ -2534,1 +2540,2 @@\n- * base.  Some examples of this operation include:\n+ * base. Some examples of this operation include:\n+ *\n@@ -2537,3 +2544,0 @@\n- *     docs\/pic1.gif                    pic1.gif\n- *     docs\/img\/pic1.gif                img\/pic1.gif\n- *     img\/pic1.gif                     ..\/img\/pic1.gif\n@@ -2550,7 +2554,0 @@\n- *\n- * Note: if the URI reference is really weird or complicated, it may be\n- *       worthwhile to first convert it into a \"nice\" one by calling\n- *       xmlBuildURI (using 'base') before calling this routine,\n- *       since this routine (for reasonable efficiency) assumes URI has\n- *       already been through some validation.\n- *\n@@ -2582,1 +2579,1 @@\n-    return(1);\n+        return(1);\n@@ -2614,1 +2611,1 @@\n-    (xmlStrcmp ((xmlChar *)bas->server, (xmlChar *)ref->server)) ||\n+        (xmlStrcmp ((xmlChar *)bas->server, (xmlChar *)ref->server)) ||\n@@ -2617,1 +2614,1 @@\n-    goto done;\n+        goto done;\n@@ -2620,1 +2617,1 @@\n-    val = xmlStrdup(BAD_CAST \"\");\n+        val = xmlStrdup(BAD_CAST \"\");\n@@ -2623,1 +2620,1 @@\n-    goto done;\n+        goto done;\n@@ -2626,1 +2623,1 @@\n-    val = xmlStrdup((xmlChar *)ref->path);\n+        val = xmlStrdup((xmlChar *)ref->path);\n@@ -2631,1 +2628,1 @@\n-    goto escape;\n+        goto escape;\n@@ -2635,1 +2632,1 @@\n-    remove_path = 1;\n+        remove_path = 1;\n@@ -2656,2 +2653,2 @@\n-    while ((bptr[pos] == rptr[pos]) && (bptr[pos] != 0))\n-        pos++;\n+        while ((bptr[pos] == rptr[pos]) && (bptr[pos] != 0))\n+            pos++;\n@@ -2659,2 +2656,2 @@\n-    if (bptr[pos] == rptr[pos]) {\n-        val = xmlStrdup(BAD_CAST \"\");\n+        if (bptr[pos] == rptr[pos]) {\n+            val = xmlStrdup(BAD_CAST \"\");\n@@ -2663,2 +2660,2 @@\n-        goto done;        \/* (I can't imagine why anyone would do this) *\/\n-    }\n+            goto done;          \/* (I can't imagine why anyone would do this) *\/\n+        }\n@@ -2666,10 +2663,10 @@\n-    \/*\n-     * In URI, \"back up\" to the last '\/' encountered.  This will be the\n-     * beginning of the \"unique\" suffix of URI\n-     *\/\n-    ix = pos;\n-    for (; ix > 0; ix--) {\n-        if (rptr[ix - 1] == '\/')\n-        break;\n-    }\n-    uptr = (xmlChar *)&rptr[ix];\n+        \/*\n+         * In URI, \"back up\" to the last '\/' encountered.  This will be the\n+         * beginning of the \"unique\" suffix of URI\n+         *\/\n+        ix = pos;\n+        for (; ix > 0; ix--) {\n+            if (rptr[ix - 1] == '\/')\n+                break;\n+        }\n+        uptr = (xmlChar *)&rptr[ix];\n@@ -2677,7 +2674,7 @@\n-    \/*\n-     * In base, count the number of '\/' from the differing point\n-     *\/\n-    for (; bptr[ix] != 0; ix++) {\n-        if (bptr[ix] == '\/')\n-        nbslash++;\n-    }\n+        \/*\n+         * In base, count the number of '\/' from the differing point\n+         *\/\n+        for (; bptr[ix] != 0; ix++) {\n+            if (bptr[ix] == '\/')\n+                nbslash++;\n+        }\n@@ -2685,5 +2682,5 @@\n-    \/*\n-     * e.g: URI=\"foo\/\" base=\"foo\/bar\" -> \".\/\"\n-     *\/\n-    if (nbslash == 0 && !uptr[0]) {\n-        val = xmlStrdup(BAD_CAST \".\/\");\n+        \/*\n+         * e.g: URI=\"foo\/\" base=\"foo\/bar\" -> \".\/\"\n+         *\/\n+        if (nbslash == 0 && !uptr[0]) {\n+            val = xmlStrdup(BAD_CAST \".\/\");\n@@ -2692,2 +2689,2 @@\n-        goto done;\n-    }\n+            goto done;\n+        }\n@@ -2695,1 +2692,1 @@\n-    len = xmlStrlen (uptr) + 1;\n+        len = xmlStrlen (uptr) + 1;\n@@ -2699,3 +2696,3 @@\n-    if (uptr != NULL) {\n-        \/* exception characters from xmlSaveUri *\/\n-        val = xmlURIEscapeStr(uptr, BAD_CAST \"\/;&=+$,\");\n+        if (uptr != NULL) {\n+            \/* exception characters from xmlSaveUri *\/\n+            val = xmlURIEscapeStr(uptr, BAD_CAST \"\/;&=+$,\");\n@@ -2705,1 +2702,1 @@\n-    goto done;\n+        goto done;\n@@ -2716,1 +2713,1 @@\n-    goto done;\n+        goto done;\n@@ -2723,3 +2720,3 @@\n-    *vptr++ = '.';\n-    *vptr++ = '.';\n-    *vptr++ = '\/';\n+        *vptr++ = '.';\n+        *vptr++ = '.';\n+        *vptr++ = '\/';\n@@ -2732,3 +2729,7 @@\n-        (uptr[0] == '\/') && (vptr[-1] == '\/')) {\n-        memcpy (vptr, uptr + 1, len - 1);\n-        vptr[len - 2] = 0;\n+            (uptr[0] == '\/') && (vptr[-1] == '\/')) {\n+            memcpy (vptr, uptr + 1, len - 1);\n+            vptr[len - 2] = 0;\n+        } else {\n+            memcpy (vptr, uptr, len);\n+            vptr[len - 1] = 0;\n+        }\n@@ -2736,1 +2737,0 @@\n-        memcpy (vptr, uptr, len);\n@@ -2739,3 +2739,0 @@\n-    } else {\n-    vptr[len - 1] = 0;\n-    }\n@@ -2767,1 +2764,1 @@\n-    xmlFreeURI (ref);\n+        xmlFreeURI (ref);\n@@ -2769,1 +2766,1 @@\n-    xmlFreeURI (bas);\n+        xmlFreeURI (bas);\n@@ -2823,1 +2820,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2827,1 +2824,1 @@\n-    \/*\n+        \/*\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/uri.c","additions":561,"deletions":564,"binary":false,"changes":1125,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"private\/memory.h\"\n@@ -41,3 +42,3 @@\n- *                                    *\n- *            Error handling routines                *\n- *                                    *\n+ *                                                                      *\n+ *                      Error handling routines                         *\n+ *                                                                      *\n@@ -122,1 +123,1 @@\n-#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n+#ifdef LIBXML_VALID_ENABLED\n@@ -143,1 +144,0 @@\n-#endif \/* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED *\/\n@@ -145,1 +145,0 @@\n-#ifdef LIBXML_VALID_ENABLED\n@@ -201,3 +200,3 @@\n-    xmlElementPtr     elemDecl;    \/* pointer to the content model *\/\n-    xmlNodePtr           node;        \/* pointer to the current node *\/\n-    xmlRegExecCtxtPtr    exec;        \/* regexp runtime *\/\n+    xmlElementPtr        elemDecl;      \/* pointer to the content model *\/\n+    xmlNodePtr           node;          \/* pointer to the current node *\/\n+    xmlRegExecCtxtPtr    exec;          \/* regexp runtime *\/\n@@ -209,10 +208,0 @@\n-    if ((ctxt->vstateMax == 0) || (ctxt->vstateTab == NULL)) {\n-    ctxt->vstateMax = 10;\n-    ctxt->vstateTab = (xmlValidState *) xmlMalloc(ctxt->vstateMax *\n-                      sizeof(ctxt->vstateTab[0]));\n-        if (ctxt->vstateTab == NULL) {\n-        xmlVErrMemory(ctxt);\n-        return(-1);\n-    }\n-    }\n-\n@@ -221,0 +210,1 @@\n+        int newSize;\n@@ -222,2 +212,7 @@\n-    tmp = (xmlValidState *) xmlRealloc(ctxt->vstateTab,\n-                 2 * ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n+        newSize = xmlGrowCapacity(ctxt->vstateMax, sizeof(tmp[0]),\n+                                  10, XML_MAX_ITEMS);\n+        if (newSize < 0) {\n+            xmlVErrMemory(ctxt);\n+            return(-1);\n+        }\n+        tmp = xmlRealloc(ctxt->vstateTab, newSize * sizeof(tmp[0]));\n@@ -225,5 +220,5 @@\n-        xmlVErrMemory(ctxt);\n-        return(-1);\n-    }\n-    ctxt->vstateMax *= 2;\n-    ctxt->vstateTab = tmp;\n+            xmlVErrMemory(ctxt);\n+            return(-1);\n+        }\n+        ctxt->vstateTab = tmp;\n+        ctxt->vstateMax = newSize;\n@@ -235,5 +230,5 @@\n-    if (elemDecl->contModel == NULL)\n-        xmlValidBuildContentModel(ctxt, elemDecl);\n-    if (elemDecl->contModel != NULL) {\n-        ctxt->vstateTab[ctxt->vstateNr].exec =\n-        xmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);\n+        if (elemDecl->contModel == NULL)\n+            xmlValidBuildContentModel(ctxt, elemDecl);\n+        if (elemDecl->contModel != NULL) {\n+            ctxt->vstateTab[ctxt->vstateNr].exec =\n+                xmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);\n@@ -244,7 +239,7 @@\n-    } else {\n-        ctxt->vstateTab[ctxt->vstateNr].exec = NULL;\n-        xmlErrValidNode(ctxt, (xmlNodePtr) elemDecl,\n-                        XML_ERR_INTERNAL_ERROR,\n-                \"Failed to build content model regexp for %s\\n\",\n-                node->name, NULL, NULL);\n-    }\n+        } else {\n+            ctxt->vstateTab[ctxt->vstateNr].exec = NULL;\n+            xmlErrValidNode(ctxt, (xmlNodePtr) elemDecl,\n+                            XML_ERR_INTERNAL_ERROR,\n+                            \"Failed to build content model regexp for %s\\n\",\n+                            node->name, NULL, NULL);\n+        }\n@@ -265,1 +260,1 @@\n-    xmlRegFreeExecCtxt(ctxt->vstateTab[ctxt->vstateNr].exec);\n+        xmlRegFreeExecCtxt(ctxt->vstateTab[ctxt->vstateNr].exec);\n@@ -269,1 +264,1 @@\n-    ctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr - 1];\n+        ctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr - 1];\n@@ -271,1 +266,1 @@\n-    ctxt->vstate = NULL;\n+        ctxt->vstate = NULL;\n@@ -286,2 +281,2 @@\n-#define ROLLBACK_OR    0\n-#define ROLLBACK_PARENT    1\n+#define ROLLBACK_OR     0\n+#define ROLLBACK_PARENT 1\n@@ -290,2 +285,2 @@\n-    xmlElementContentPtr cont;    \/* pointer to the content model subtree *\/\n-    xmlNodePtr           node;    \/* pointer to the current node in the list *\/\n+    xmlElementContentPtr cont;  \/* pointer to the content model subtree *\/\n+    xmlNodePtr           node;  \/* pointer to the current node in the list *\/\n@@ -313,2 +308,2 @@\n-        xmlNodePtr node, unsigned char depth, long occurs,\n-        unsigned char state) {\n+            xmlNodePtr node, unsigned char depth, long occurs,\n+            unsigned char state) {\n@@ -317,12 +312,0 @@\n-    if (ctxt->vstateNr > MAX_RECURSE) {\n-    return(-1);\n-    }\n-    if (ctxt->vstateTab == NULL) {\n-    ctxt->vstateMax = 8;\n-    ctxt->vstateTab = (xmlValidState *) xmlMalloc(\n-             ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n-    if (ctxt->vstateTab == NULL) {\n-        xmlVErrMemory(ctxt);\n-        return(-1);\n-    }\n-    }\n@@ -331,0 +314,1 @@\n+        int newSize;\n@@ -332,2 +316,7 @@\n-        tmp = (xmlValidState *) xmlRealloc(ctxt->vstateTab,\n-                 2 * ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n+        newSize = xmlGrowCapacity(ctxt->vstateMax, sizeof(tmp[0]),\n+                                  8, MAX_RECURSE);\n+        if (newSize < 0) {\n+            xmlVErrMemory(ctxt);\n+            return(-1);\n+        }\n+        tmp = xmlRealloc(ctxt->vstateTab, newSize * sizeof(tmp[0]));\n@@ -335,6 +324,6 @@\n-        xmlVErrMemory(ctxt);\n-        return(-1);\n-    }\n-    ctxt->vstateMax *= 2;\n-    ctxt->vstateTab = tmp;\n-    ctxt->vstate = &ctxt->vstateTab[0];\n+            xmlVErrMemory(ctxt);\n+            return(-1);\n+        }\n+        ctxt->vstateTab = tmp;\n+        ctxt->vstateMax = newSize;\n+        ctxt->vstate = &ctxt->vstateTab[0];\n@@ -346,5 +335,5 @@\n-    (ctxt->vstateTab[i].node == node) &&\n-    (ctxt->vstateTab[i].depth == depth) &&\n-    (ctxt->vstateTab[i].occurs == occurs) &&\n-    (ctxt->vstateTab[i].state == state))\n-    return(ctxt->vstateNr);\n+        (ctxt->vstateTab[i].node == node) &&\n+        (ctxt->vstateTab[i].depth == depth) &&\n+        (ctxt->vstateTab[i].occurs == occurs) &&\n+        (ctxt->vstateTab[i].state == state))\n+        return(ctxt->vstateNr);\n@@ -377,11 +366,0 @@\n-    if (ctxt->nodeMax <= 0) {\n-        ctxt->nodeMax = 4;\n-        ctxt->nodeTab =\n-            (xmlNodePtr *) xmlMalloc(ctxt->nodeMax *\n-                                     sizeof(ctxt->nodeTab[0]));\n-        if (ctxt->nodeTab == NULL) {\n-        xmlVErrMemory(ctxt);\n-            ctxt->nodeMax = 0;\n-            return (0);\n-        }\n-    }\n@@ -390,2 +368,9 @@\n-        tmp = (xmlNodePtr *) xmlRealloc(ctxt->nodeTab,\n-                  ctxt->nodeMax * 2 * sizeof(ctxt->nodeTab[0]));\n+        int newSize;\n+\n+        newSize = xmlGrowCapacity(ctxt->nodeMax, sizeof(tmp[0]),\n+                                  4, XML_MAX_ITEMS);\n+        if (newSize < 0) {\n+            xmlVErrMemory(ctxt);\n+            return (-1);\n+        }\n+        tmp = xmlRealloc(ctxt->nodeTab, newSize * sizeof(tmp[0]));\n@@ -393,2 +378,2 @@\n-        xmlVErrMemory(ctxt);\n-            return (0);\n+            xmlVErrMemory(ctxt);\n+            return (-1);\n@@ -396,2 +381,2 @@\n-        ctxt->nodeMax *= 2;\n-    ctxt->nodeTab = tmp;\n+        ctxt->nodeTab = tmp;\n+        ctxt->nodeMax = newSize;\n@@ -423,4 +408,4 @@\n-#define CHECK_DTD                        \\\n-   if (doc == NULL) return(0);                    \\\n-   else if ((doc->intSubset == NULL) &&                \\\n-        (doc->extSubset == NULL)) return(0)\n+#define CHECK_DTD                                               \\\n+   if (doc == NULL) return(0);                                  \\\n+   else if ((doc->intSubset == NULL) &&                         \\\n+            (doc->extSubset == NULL)) return(0)\n@@ -431,3 +416,3 @@\n- *                                    *\n- *        Content model validation based on the regexps        *\n- *                                    *\n+ *                                                                      *\n+ *              Content model validation based on the regexps           *\n+ *                                                                      *\n@@ -448,2 +433,2 @@\n-                   xmlValidCtxtPtr ctxt,\n-                   const xmlChar *name) {\n+                           xmlValidCtxtPtr ctxt,\n+                           const xmlChar *name) {\n@@ -451,7 +436,0 @@\n-    xmlErrValidNode(ctxt, NULL, XML_ERR_INTERNAL_ERROR,\n-            \"Found NULL content in content model of %s\\n\",\n-            name, NULL, NULL);\n-    return(0);\n-    }\n-    switch (content->type) {\n-    case XML_ELEMENT_CONTENT_PCDATA:\n@@ -459,2 +437,2 @@\n-                \"Found PCDATA in content model of %s\\n\",\n-                    name, NULL, NULL);\n+                        \"Found NULL content in content model of %s\\n\",\n+                        name, NULL, NULL);\n@@ -462,5 +440,12 @@\n-        break;\n-    case XML_ELEMENT_CONTENT_ELEMENT: {\n-        xmlAutomataStatePtr oldstate = ctxt->state;\n-        xmlChar fn[50];\n-        xmlChar *fullname;\n+    }\n+    switch (content->type) {\n+        case XML_ELEMENT_CONTENT_PCDATA:\n+            xmlErrValidNode(ctxt, NULL, XML_ERR_INTERNAL_ERROR,\n+                            \"Found PCDATA in content model of %s\\n\",\n+                            name, NULL, NULL);\n+            return(0);\n+            break;\n+        case XML_ELEMENT_CONTENT_ELEMENT: {\n+            xmlAutomataStatePtr oldstate = ctxt->state;\n+            xmlChar fn[50];\n+            xmlChar *fullname;\n@@ -468,5 +453,5 @@\n-        fullname = xmlBuildQName(content->name, content->prefix, fn, 50);\n-        if (fullname == NULL) {\n-            xmlVErrMemory(ctxt);\n-        return(0);\n-        }\n+            fullname = xmlBuildQName(content->name, content->prefix, fn, 50);\n+            if (fullname == NULL) {\n+                xmlVErrMemory(ctxt);\n+                return(0);\n+            }\n@@ -474,21 +459,25 @@\n-        switch (content->ocur) {\n-        case XML_ELEMENT_CONTENT_ONCE:\n-            ctxt->state = xmlAutomataNewTransition(ctxt->am,\n-                ctxt->state, NULL, fullname, NULL);\n-            break;\n-        case XML_ELEMENT_CONTENT_OPT:\n-            ctxt->state = xmlAutomataNewTransition(ctxt->am,\n-                ctxt->state, NULL, fullname, NULL);\n-            xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n-            break;\n-        case XML_ELEMENT_CONTENT_PLUS:\n-            ctxt->state = xmlAutomataNewTransition(ctxt->am,\n-                ctxt->state, NULL, fullname, NULL);\n-            xmlAutomataNewTransition(ctxt->am, ctxt->state,\n-                                 ctxt->state, fullname, NULL);\n-            break;\n-        case XML_ELEMENT_CONTENT_MULT:\n-            ctxt->state = xmlAutomataNewEpsilon(ctxt->am,\n-                        ctxt->state, NULL);\n-            xmlAutomataNewTransition(ctxt->am,\n-                ctxt->state, ctxt->state, fullname, NULL);\n+            switch (content->ocur) {\n+                case XML_ELEMENT_CONTENT_ONCE:\n+                    ctxt->state = xmlAutomataNewTransition(ctxt->am,\n+                            ctxt->state, NULL, fullname, NULL);\n+                    break;\n+                case XML_ELEMENT_CONTENT_OPT:\n+                    ctxt->state = xmlAutomataNewTransition(ctxt->am,\n+                            ctxt->state, NULL, fullname, NULL);\n+                    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n+                    break;\n+                case XML_ELEMENT_CONTENT_PLUS:\n+                    ctxt->state = xmlAutomataNewTransition(ctxt->am,\n+                            ctxt->state, NULL, fullname, NULL);\n+                    xmlAutomataNewTransition(ctxt->am, ctxt->state,\n+                                             ctxt->state, fullname, NULL);\n+                    break;\n+                case XML_ELEMENT_CONTENT_MULT:\n+                    ctxt->state = xmlAutomataNewEpsilon(ctxt->am,\n+                                            ctxt->state, NULL);\n+                    xmlAutomataNewTransition(ctxt->am,\n+                            ctxt->state, ctxt->state, fullname, NULL);\n+                    break;\n+            }\n+            if ((fullname != fn) && (fullname != content->name))\n+                xmlFree(fullname);\n@@ -497,7 +486,3 @@\n-        if ((fullname != fn) && (fullname != content->name))\n-        xmlFree(fullname);\n-        break;\n-    }\n-    case XML_ELEMENT_CONTENT_SEQ: {\n-        xmlAutomataStatePtr oldstate, oldend;\n-        xmlElementContentOccur ocur;\n+        case XML_ELEMENT_CONTENT_SEQ: {\n+            xmlAutomataStatePtr oldstate, oldend;\n+            xmlElementContentOccur ocur;\n@@ -505,11 +490,11 @@\n-        \/*\n-         * Simply iterate over the content\n-         *\/\n-        oldstate = ctxt->state;\n-        ocur = content->ocur;\n-        if (ocur != XML_ELEMENT_CONTENT_ONCE) {\n-        ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);\n-        oldstate = ctxt->state;\n-        }\n-        do {\n-        if (xmlValidBuildAContentModel(content->c1, ctxt, name) == 0)\n+            \/*\n+             * Simply iterate over the content\n+             *\/\n+            oldstate = ctxt->state;\n+            ocur = content->ocur;\n+            if (ocur != XML_ELEMENT_CONTENT_ONCE) {\n+                ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);\n+                oldstate = ctxt->state;\n+            }\n+            do {\n+                if (xmlValidBuildAContentModel(content->c1, ctxt, name) == 0)\n@@ -517,4 +502,4 @@\n-        content = content->c2;\n-        } while ((content->type == XML_ELEMENT_CONTENT_SEQ) &&\n-             (content->ocur == XML_ELEMENT_CONTENT_ONCE));\n-        if (xmlValidBuildAContentModel(content, ctxt, name) == 0)\n+                content = content->c2;\n+            } while ((content->type == XML_ELEMENT_CONTENT_SEQ) &&\n+                     (content->ocur == XML_ELEMENT_CONTENT_ONCE));\n+            if (xmlValidBuildAContentModel(content, ctxt, name) == 0)\n@@ -522,14 +507,16 @@\n-        oldend = ctxt->state;\n-        ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);\n-        switch (ocur) {\n-        case XML_ELEMENT_CONTENT_ONCE:\n-            break;\n-        case XML_ELEMENT_CONTENT_OPT:\n-            xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n-            break;\n-        case XML_ELEMENT_CONTENT_MULT:\n-            xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n-            xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n-            break;\n-        case XML_ELEMENT_CONTENT_PLUS:\n-            xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n+            oldend = ctxt->state;\n+            ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);\n+            switch (ocur) {\n+                case XML_ELEMENT_CONTENT_ONCE:\n+                    break;\n+                case XML_ELEMENT_CONTENT_OPT:\n+                    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n+                    break;\n+                case XML_ELEMENT_CONTENT_MULT:\n+                    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n+                    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n+                    break;\n+                case XML_ELEMENT_CONTENT_PLUS:\n+                    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n+                    break;\n+            }\n@@ -538,14 +525,12 @@\n-        break;\n-    }\n-    case XML_ELEMENT_CONTENT_OR: {\n-        xmlAutomataStatePtr oldstate, oldend;\n-        xmlElementContentOccur ocur;\n-\n-        ocur = content->ocur;\n-        if ((ocur == XML_ELEMENT_CONTENT_PLUS) ||\n-        (ocur == XML_ELEMENT_CONTENT_MULT)) {\n-        ctxt->state = xmlAutomataNewEpsilon(ctxt->am,\n-            ctxt->state, NULL);\n-        }\n-        oldstate = ctxt->state;\n-        oldend = xmlAutomataNewState(ctxt->am);\n+        case XML_ELEMENT_CONTENT_OR: {\n+            xmlAutomataStatePtr oldstate, oldend;\n+            xmlElementContentOccur ocur;\n+\n+            ocur = content->ocur;\n+            if ((ocur == XML_ELEMENT_CONTENT_PLUS) ||\n+                (ocur == XML_ELEMENT_CONTENT_MULT)) {\n+                ctxt->state = xmlAutomataNewEpsilon(ctxt->am,\n+                        ctxt->state, NULL);\n+            }\n+            oldstate = ctxt->state;\n+            oldend = xmlAutomataNewState(ctxt->am);\n@@ -553,7 +538,7 @@\n-        \/*\n-         * iterate over the subtypes and remerge the end with an\n-         * epsilon transition\n-         *\/\n-        do {\n-        ctxt->state = oldstate;\n-        if (xmlValidBuildAContentModel(content->c1, ctxt, name) == 0)\n+            \/*\n+             * iterate over the subtypes and remerge the end with an\n+             * epsilon transition\n+             *\/\n+            do {\n+                ctxt->state = oldstate;\n+                if (xmlValidBuildAContentModel(content->c1, ctxt, name) == 0)\n@@ -561,6 +546,6 @@\n-        xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);\n-        content = content->c2;\n-        } while ((content->type == XML_ELEMENT_CONTENT_OR) &&\n-             (content->ocur == XML_ELEMENT_CONTENT_ONCE));\n-        ctxt->state = oldstate;\n-        if (xmlValidBuildAContentModel(content, ctxt, name) == 0)\n+                xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);\n+                content = content->c2;\n+            } while ((content->type == XML_ELEMENT_CONTENT_OR) &&\n+                     (content->ocur == XML_ELEMENT_CONTENT_ONCE));\n+            ctxt->state = oldstate;\n+            if (xmlValidBuildAContentModel(content, ctxt, name) == 0)\n@@ -568,14 +553,16 @@\n-        xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);\n-        ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);\n-        switch (ocur) {\n-        case XML_ELEMENT_CONTENT_ONCE:\n-            break;\n-        case XML_ELEMENT_CONTENT_OPT:\n-            xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n-            break;\n-        case XML_ELEMENT_CONTENT_MULT:\n-            xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n-            xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n-            break;\n-        case XML_ELEMENT_CONTENT_PLUS:\n-            xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n+            xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);\n+            ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);\n+            switch (ocur) {\n+                case XML_ELEMENT_CONTENT_ONCE:\n+                    break;\n+                case XML_ELEMENT_CONTENT_OPT:\n+                    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n+                    break;\n+                case XML_ELEMENT_CONTENT_MULT:\n+                    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n+                    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n+                    break;\n+                case XML_ELEMENT_CONTENT_PLUS:\n+                    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n+                    break;\n+            }\n@@ -584,7 +571,5 @@\n-        break;\n-    }\n-    default:\n-        xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n-                    \"ContentModel broken for element %s\\n\",\n-            (const char *) name);\n-        return(0);\n+        default:\n+            xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"ContentModel broken for element %s\\n\",\n+                        (const char *) name);\n+            return(0);\n@@ -611,1 +596,1 @@\n-    return(0);\n+        return(0);\n@@ -613,1 +598,1 @@\n-    return(0);\n+        return(0);\n@@ -615,1 +600,1 @@\n-    return(1);\n+        return(1);\n@@ -618,5 +603,5 @@\n-    if (!xmlRegexpIsDeterminist(elem->contModel)) {\n-        ctxt->valid = 0;\n-        return(0);\n-    }\n-    return(1);\n+        if (!xmlRegexpIsDeterminist(elem->contModel)) {\n+            ctxt->valid = 0;\n+            return(0);\n+        }\n+        return(1);\n@@ -628,1 +613,1 @@\n-    return(0);\n+        return(0);\n@@ -640,7 +625,7 @@\n-    char expr[5000];\n-    expr[0] = 0;\n-    xmlSnprintfElementContent(expr, 5000, elem->content, 1);\n-    xmlErrValidNode(ctxt, (xmlNodePtr) elem,\n-                    XML_DTD_CONTENT_NOT_DETERMINIST,\n-           \"Content model of %s is not deterministic: %s\\n\",\n-           elem->name, BAD_CAST expr, NULL);\n+        char expr[5000];\n+        expr[0] = 0;\n+        xmlSnprintfElementContent(expr, 5000, elem->content, 1);\n+        xmlErrValidNode(ctxt, (xmlNodePtr) elem,\n+                        XML_DTD_CONTENT_NOT_DETERMINIST,\n+               \"Content model of %s is not deterministic: %s\\n\",\n+               elem->name, BAD_CAST expr, NULL);\n@@ -648,1 +633,1 @@\n-    goto done;\n+        goto done;\n@@ -663,3 +648,3 @@\n- *                                *\n- *    Util functions for data allocation\/deallocation        *\n- *                                *\n+ *                                                              *\n+ *      Util functions for data allocation\/deallocation         *\n+ *                                                              *\n@@ -678,2 +663,3 @@\n-    if ((ret = xmlMalloc(sizeof (xmlValidCtxt))) == NULL)\n-    return (NULL);\n+    ret = xmlMalloc(sizeof (xmlValidCtxt));\n+    if (ret == NULL)\n+        return (NULL);\n@@ -711,0 +697,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -725,7 +713,7 @@\n-    case XML_ELEMENT_CONTENT_ELEMENT:\n-        if (name == NULL) {\n-            xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n-            \"xmlNewElementContent : name == NULL !\\n\",\n-            NULL);\n-        }\n-        break;\n+        case XML_ELEMENT_CONTENT_ELEMENT:\n+            if (name == NULL) {\n+                xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n+                        \"xmlNewElementContent : name == NULL !\\n\",\n+                        NULL);\n+            }\n+            break;\n@@ -733,3 +721,9 @@\n-    case XML_ELEMENT_CONTENT_SEQ:\n-    case XML_ELEMENT_CONTENT_OR:\n-        if (name != NULL) {\n+        case XML_ELEMENT_CONTENT_SEQ:\n+        case XML_ELEMENT_CONTENT_OR:\n+            if (name != NULL) {\n+                xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n+                        \"xmlNewElementContent : name != NULL !\\n\",\n+                        NULL);\n+            }\n+            break;\n+        default:\n@@ -737,9 +731,3 @@\n-            \"xmlNewElementContent : name != NULL !\\n\",\n-            NULL);\n-        }\n-        break;\n-    default:\n-        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n-            \"Internal: ELEMENT content corrupted invalid type\\n\",\n-            NULL);\n-        return(NULL);\n+                    \"Internal: ELEMENT content corrupted invalid type\\n\",\n+                    NULL);\n+            return(NULL);\n@@ -749,1 +737,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -755,1 +743,1 @@\n-    const xmlChar *tmp;\n+        const xmlChar *tmp;\n@@ -757,10 +745,6 @@\n-    tmp = xmlSplitQName3(name, &l);\n-    if (tmp == NULL) {\n-        if (dict == NULL)\n-        ret->name = xmlStrdup(name);\n-        else\n-            ret->name = xmlDictLookup(dict, name, -1);\n-    } else {\n-        if (dict == NULL) {\n-        ret->prefix = xmlStrndup(name, l);\n-        ret->name = xmlStrdup(tmp);\n+        tmp = xmlSplitQName3(name, &l);\n+        if (tmp == NULL) {\n+            if (dict == NULL)\n+                ret->name = xmlStrdup(name);\n+            else\n+                ret->name = xmlDictLookup(dict, name, -1);\n@@ -768,3 +752,7 @@\n-            ret->prefix = xmlDictLookup(dict, name, l);\n-        ret->name = xmlDictLookup(dict, tmp, -1);\n-        }\n+            if (dict == NULL) {\n+                ret->prefix = xmlStrndup(name, l);\n+                ret->name = xmlStrdup(tmp);\n+            } else {\n+                ret->prefix = xmlDictLookup(dict, name, l);\n+                ret->name = xmlDictLookup(dict, tmp, -1);\n+            }\n@@ -773,1 +761,1 @@\n-    }\n+        }\n@@ -789,0 +777,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -804,0 +794,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -820,1 +812,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -825,4 +817,4 @@\n-    if (dict)\n-        ret->name = xmlDictLookup(dict, cur->name, -1);\n-    else\n-        ret->name = xmlStrdup(cur->name);\n+        if (dict)\n+            ret->name = xmlDictLookup(dict, cur->name, -1);\n+        else\n+            ret->name = xmlStrdup(cur->name);\n@@ -834,4 +826,4 @@\n-    if (dict)\n-        ret->prefix = xmlDictLookup(dict, cur->prefix, -1);\n-    else\n-        ret->prefix = xmlStrdup(cur->prefix);\n+        if (dict)\n+            ret->prefix = xmlDictLookup(dict, cur->prefix, -1);\n+        else\n+            ret->prefix = xmlStrdup(cur->prefix);\n@@ -845,1 +837,1 @@\n-    ret->c1->parent = ret;\n+        ret->c1->parent = ret;\n@@ -849,4 +841,4 @@\n-    cur = cur->c2;\n-    while (cur != NULL) {\n-        tmp = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));\n-        if (tmp == NULL)\n+        cur = cur->c2;\n+        while (cur != NULL) {\n+            tmp = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));\n+            if (tmp == NULL)\n@@ -854,10 +846,10 @@\n-        memset(tmp, 0, sizeof(xmlElementContent));\n-        tmp->type = cur->type;\n-        tmp->ocur = cur->ocur;\n-        prev->c2 = tmp;\n-        tmp->parent = prev;\n-        if (cur->name != NULL) {\n-        if (dict)\n-            tmp->name = xmlDictLookup(dict, cur->name, -1);\n-        else\n-            tmp->name = xmlStrdup(cur->name);\n+            memset(tmp, 0, sizeof(xmlElementContent));\n+            tmp->type = cur->type;\n+            tmp->ocur = cur->ocur;\n+            prev->c2 = tmp;\n+            tmp->parent = prev;\n+            if (cur->name != NULL) {\n+                if (dict)\n+                    tmp->name = xmlDictLookup(dict, cur->name, -1);\n+                else\n+                    tmp->name = xmlStrdup(cur->name);\n@@ -866,1 +858,1 @@\n-        }\n+            }\n@@ -868,5 +860,5 @@\n-        if (cur->prefix != NULL) {\n-        if (dict)\n-            tmp->prefix = xmlDictLookup(dict, cur->prefix, -1);\n-        else\n-            tmp->prefix = xmlStrdup(cur->prefix);\n+            if (cur->prefix != NULL) {\n+                if (dict)\n+                    tmp->prefix = xmlDictLookup(dict, cur->prefix, -1);\n+                else\n+                    tmp->prefix = xmlStrdup(cur->prefix);\n@@ -875,4 +867,4 @@\n-        }\n-        if (cur->c1 != NULL) {\n-            tmp->c1 = xmlCopyDocElementContent(doc,cur->c1);\n-            if (tmp->c1 == NULL)\n+            }\n+            if (cur->c1 != NULL) {\n+                tmp->c1 = xmlCopyDocElementContent(doc,cur->c1);\n+                if (tmp->c1 == NULL)\n@@ -880,1 +872,1 @@\n-        tmp->c1->parent = tmp;\n+                tmp->c1->parent = tmp;\n@@ -882,3 +874,3 @@\n-        prev = tmp;\n-        cur = cur->c2;\n-    }\n+            prev = tmp;\n+            cur = cur->c2;\n+        }\n@@ -897,0 +889,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -912,0 +906,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -932,21 +928,21 @@\n-    switch (cur->type) {\n-        case XML_ELEMENT_CONTENT_PCDATA:\n-        case XML_ELEMENT_CONTENT_ELEMENT:\n-        case XML_ELEMENT_CONTENT_SEQ:\n-        case XML_ELEMENT_CONTENT_OR:\n-        break;\n-        default:\n-        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n-            \"Internal: ELEMENT content corrupted invalid type\\n\",\n-            NULL);\n-        return;\n-    }\n-    if (dict) {\n-        if ((cur->name != NULL) && (!xmlDictOwns(dict, cur->name)))\n-            xmlFree((xmlChar *) cur->name);\n-        if ((cur->prefix != NULL) && (!xmlDictOwns(dict, cur->prefix)))\n-            xmlFree((xmlChar *) cur->prefix);\n-    } else {\n-        if (cur->name != NULL) xmlFree((xmlChar *) cur->name);\n-        if (cur->prefix != NULL) xmlFree((xmlChar *) cur->prefix);\n-    }\n+        switch (cur->type) {\n+            case XML_ELEMENT_CONTENT_PCDATA:\n+            case XML_ELEMENT_CONTENT_ELEMENT:\n+            case XML_ELEMENT_CONTENT_SEQ:\n+            case XML_ELEMENT_CONTENT_OR:\n+                break;\n+            default:\n+                xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n+                        \"Internal: ELEMENT content corrupted invalid type\\n\",\n+                        NULL);\n+                return;\n+        }\n+        if (dict) {\n+            if ((cur->name != NULL) && (!xmlDictOwns(dict, cur->name)))\n+                xmlFree((xmlChar *) cur->name);\n+            if ((cur->prefix != NULL) && (!xmlDictOwns(dict, cur->prefix)))\n+                xmlFree((xmlChar *) cur->prefix);\n+        } else {\n+            if (cur->name != NULL) xmlFree((xmlChar *) cur->name);\n+            if (cur->prefix != NULL) xmlFree((xmlChar *) cur->prefix);\n+        }\n@@ -962,1 +958,1 @@\n-    xmlFree(cur);\n+        xmlFree(cur);\n@@ -965,1 +961,1 @@\n-        cur = parent->c2;\n+            cur = parent->c2;\n@@ -977,0 +973,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -992,0 +990,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -996,2 +996,2 @@\n-                     xmlElementContentPtr content ATTRIBUTE_UNUSED,\n-             int englob ATTRIBUTE_UNUSED) {\n+                         xmlElementContentPtr content ATTRIBUTE_UNUSED,\n+                         int englob ATTRIBUTE_UNUSED) {\n@@ -1008,0 +1008,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -1018,3 +1020,3 @@\n-    if ((size - len > 4) && (buf[len - 1] != '.'))\n-        strcat(buf, \" ...\");\n-    return;\n+        if ((size - len > 4) && (buf[len - 1] != '.'))\n+            strcat(buf, \" ...\");\n+        return;\n@@ -1026,2 +1028,2 @@\n-        break;\n-    case XML_ELEMENT_CONTENT_ELEMENT: {\n+            break;\n+        case XML_ELEMENT_CONTENT_ELEMENT: {\n@@ -1030,1 +1032,1 @@\n-        if (content->prefix != NULL)\n+            if (content->prefix != NULL)\n@@ -1032,23 +1034,11 @@\n-        if (size - len < qnameLen + 10) {\n-        strcat(buf, \" ...\");\n-        return;\n-        }\n-        if (content->prefix != NULL) {\n-        strcat(buf, (char *) content->prefix);\n-        strcat(buf, \":\");\n-        }\n-        if (content->name != NULL)\n-        strcat(buf, (char *) content->name);\n-        break;\n-        }\n-    case XML_ELEMENT_CONTENT_SEQ:\n-        if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n-            (content->c1->type == XML_ELEMENT_CONTENT_SEQ))\n-        xmlSnprintfElementContent(buf, size, content->c1, 1);\n-        else\n-        xmlSnprintfElementContent(buf, size, content->c1, 0);\n-        len = strlen(buf);\n-        if (size - len < 50) {\n-        if ((size - len > 4) && (buf[len - 1] != '.'))\n-            strcat(buf, \" ...\");\n-        return;\n+            if (size - len < qnameLen + 10) {\n+                strcat(buf, \" ...\");\n+                return;\n+            }\n+            if (content->prefix != NULL) {\n+                strcat(buf, (char *) content->prefix);\n+                strcat(buf, \":\");\n+            }\n+            if (content->name != NULL)\n+                strcat(buf, (char *) content->name);\n+            break;\n@@ -1056,0 +1046,12 @@\n+        case XML_ELEMENT_CONTENT_SEQ:\n+            if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n+                (content->c1->type == XML_ELEMENT_CONTENT_SEQ))\n+                xmlSnprintfElementContent(buf, size, content->c1, 1);\n+            else\n+                xmlSnprintfElementContent(buf, size, content->c1, 0);\n+            len = strlen(buf);\n+            if (size - len < 50) {\n+                if ((size - len > 4) && (buf[len - 1] != '.'))\n+                    strcat(buf, \" ...\");\n+                return;\n+            }\n@@ -1057,19 +1059,19 @@\n-        if (((content->c2->type == XML_ELEMENT_CONTENT_OR) ||\n-         (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&\n-        (content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))\n-        xmlSnprintfElementContent(buf, size, content->c2, 1);\n-        else\n-        xmlSnprintfElementContent(buf, size, content->c2, 0);\n-        break;\n-    case XML_ELEMENT_CONTENT_OR:\n-        if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n-            (content->c1->type == XML_ELEMENT_CONTENT_SEQ))\n-        xmlSnprintfElementContent(buf, size, content->c1, 1);\n-        else\n-        xmlSnprintfElementContent(buf, size, content->c1, 0);\n-        len = strlen(buf);\n-        if (size - len < 50) {\n-        if ((size - len > 4) && (buf[len - 1] != '.'))\n-            strcat(buf, \" ...\");\n-        return;\n-        }\n+            if (((content->c2->type == XML_ELEMENT_CONTENT_OR) ||\n+                 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&\n+                (content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))\n+                xmlSnprintfElementContent(buf, size, content->c2, 1);\n+            else\n+                xmlSnprintfElementContent(buf, size, content->c2, 0);\n+            break;\n+        case XML_ELEMENT_CONTENT_OR:\n+            if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n+                (content->c1->type == XML_ELEMENT_CONTENT_SEQ))\n+                xmlSnprintfElementContent(buf, size, content->c1, 1);\n+            else\n+                xmlSnprintfElementContent(buf, size, content->c1, 0);\n+            len = strlen(buf);\n+            if (size - len < 50) {\n+                if ((size - len > 4) && (buf[len - 1] != '.'))\n+                    strcat(buf, \" ...\");\n+                return;\n+            }\n@@ -1077,7 +1079,7 @@\n-        if (((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||\n-         (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&\n-        (content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))\n-        xmlSnprintfElementContent(buf, size, content->c2, 1);\n-        else\n-        xmlSnprintfElementContent(buf, size, content->c2, 0);\n-        break;\n+            if (((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||\n+                 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&\n+                (content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))\n+                xmlSnprintfElementContent(buf, size, content->c2, 1);\n+            else\n+                xmlSnprintfElementContent(buf, size, content->c2, 0);\n+            break;\n@@ -1090,1 +1092,1 @@\n-        break;\n+            break;\n@@ -1092,2 +1094,2 @@\n-        strcat(buf, \"?\");\n-        break;\n+            strcat(buf, \"?\");\n+            break;\n@@ -1095,2 +1097,2 @@\n-        strcat(buf, \"*\");\n-        break;\n+            strcat(buf, \"*\");\n+            break;\n@@ -1098,2 +1100,2 @@\n-        strcat(buf, \"+\");\n-        break;\n+            strcat(buf, \"+\");\n+            break;\n@@ -1104,3 +1106,3 @@\n- *                                *\n- *    Registration of DTD declarations            *\n- *                                *\n+ *                                                              *\n+ *      Registration of DTD declarations                        *\n+ *                                                              *\n@@ -1121,1 +1123,1 @@\n-    xmlFree((xmlChar *) elem->name);\n+        xmlFree((xmlChar *) elem->name);\n@@ -1123,1 +1125,1 @@\n-    xmlFree((xmlChar *) elem->prefix);\n+        xmlFree((xmlChar *) elem->prefix);\n@@ -1126,1 +1128,1 @@\n-    xmlRegFreeRegexp(elem->contModel);\n+        xmlRegFreeRegexp(elem->contModel);\n@@ -1140,0 +1142,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -1148,1 +1152,1 @@\n-          xmlElementContentPtr content) {\n+                  xmlElementContentPtr content) {\n@@ -1156,1 +1160,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1159,1 +1163,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1164,35 +1168,35 @@\n-        if (content != NULL) {\n-        xmlErrValid(ctxt, XML_DTD_CONTENT_ERROR,\n-                \"xmlAddElementDecl: content != NULL for EMPTY\\n\",\n-            NULL);\n-        return(NULL);\n-        }\n-        break;\n-    case XML_ELEMENT_TYPE_ANY:\n-        if (content != NULL) {\n-        xmlErrValid(ctxt, XML_DTD_CONTENT_ERROR,\n-                \"xmlAddElementDecl: content != NULL for ANY\\n\",\n-            NULL);\n-        return(NULL);\n-        }\n-        break;\n-    case XML_ELEMENT_TYPE_MIXED:\n-        if (content == NULL) {\n-        xmlErrValid(ctxt, XML_DTD_CONTENT_ERROR,\n-                \"xmlAddElementDecl: content == NULL for MIXED\\n\",\n-            NULL);\n-        return(NULL);\n-        }\n-        break;\n-    case XML_ELEMENT_TYPE_ELEMENT:\n-        if (content == NULL) {\n-        xmlErrValid(ctxt, XML_DTD_CONTENT_ERROR,\n-                \"xmlAddElementDecl: content == NULL for ELEMENT\\n\",\n-            NULL);\n-        return(NULL);\n-        }\n-        break;\n-    default:\n-        xmlErrValid(ctxt, XML_ERR_ARGUMENT,\n-            \"xmlAddElementDecl: invalid type\\n\", NULL);\n-        return(NULL);\n+            if (content != NULL) {\n+                xmlErrValid(ctxt, XML_DTD_CONTENT_ERROR,\n+                        \"xmlAddElementDecl: content != NULL for EMPTY\\n\",\n+                        NULL);\n+                return(NULL);\n+            }\n+            break;\n+        case XML_ELEMENT_TYPE_ANY:\n+            if (content != NULL) {\n+                xmlErrValid(ctxt, XML_DTD_CONTENT_ERROR,\n+                        \"xmlAddElementDecl: content != NULL for ANY\\n\",\n+                        NULL);\n+                return(NULL);\n+            }\n+            break;\n+        case XML_ELEMENT_TYPE_MIXED:\n+            if (content == NULL) {\n+                xmlErrValid(ctxt, XML_DTD_CONTENT_ERROR,\n+                        \"xmlAddElementDecl: content == NULL for MIXED\\n\",\n+                        NULL);\n+                return(NULL);\n+            }\n+            break;\n+        case XML_ELEMENT_TYPE_ELEMENT:\n+            if (content == NULL) {\n+                xmlErrValid(ctxt, XML_DTD_CONTENT_ERROR,\n+                        \"xmlAddElementDecl: content == NULL for ELEMENT\\n\",\n+                        NULL);\n+                return(NULL);\n+            }\n+            break;\n+        default:\n+            xmlErrValid(ctxt, XML_ERR_ARGUMENT,\n+                    \"xmlAddElementDecl: invalid type\\n\", NULL);\n+            return(NULL);\n@@ -1213,1 +1217,1 @@\n-    xmlDictPtr dict = NULL;\n+        xmlDictPtr dict = NULL;\n@@ -1215,2 +1219,2 @@\n-    if (dtd->doc != NULL)\n-        dict = dtd->doc->dict;\n+        if (dtd->doc != NULL)\n+            dict = dtd->doc->dict;\n@@ -1220,1 +1224,1 @@\n-    dtd->elements = (void *) table;\n+        dtd->elements = (void *) table;\n@@ -1228,5 +1232,5 @@\n-    ret = xmlHashLookup2(dtd->doc->intSubset->elements, localName, prefix);\n-    if ((ret != NULL) && (ret->etype == XML_ELEMENT_TYPE_UNDEFINED)) {\n-        oldAttributes = ret->attributes;\n-        ret->attributes = NULL;\n-        xmlHashRemoveEntry2(dtd->doc->intSubset->elements, localName, prefix,\n+        ret = xmlHashLookup2(dtd->doc->intSubset->elements, localName, prefix);\n+        if ((ret != NULL) && (ret->etype == XML_ELEMENT_TYPE_UNDEFINED)) {\n+            oldAttributes = ret->attributes;\n+            ret->attributes = NULL;\n+            xmlHashRemoveEntry2(dtd->doc->intSubset->elements, localName, prefix,\n@@ -1234,2 +1238,2 @@\n-        xmlFreeElement(ret);\n-    }\n+            xmlFreeElement(ret);\n+        }\n@@ -1244,1 +1248,1 @@\n-    if (ret->etype != XML_ELEMENT_TYPE_UNDEFINED) {\n+        if (ret->etype != XML_ELEMENT_TYPE_UNDEFINED) {\n@@ -1246,6 +1250,6 @@\n-        \/*\n-         * The element is already defined in this DTD.\n-         *\/\n-        xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,\n-                        \"Redefinition of element %s\\n\",\n-                name, NULL, NULL);\n+            \/*\n+             * The element is already defined in this DTD.\n+             *\/\n+            xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,\n+                            \"Redefinition of element %s\\n\",\n+                            name, NULL, NULL);\n@@ -1254,0 +1258,4 @@\n+                xmlFree(prefix);\n+            return(NULL);\n+        }\n+        if (prefix != NULL) {\n@@ -1255,6 +1263,2 @@\n-        return(NULL);\n-    }\n-    if (prefix != NULL) {\n-        xmlFree(prefix);\n-        prefix = NULL;\n-    }\n+            prefix = NULL;\n+        }\n@@ -1264,2 +1268,2 @@\n-    ret = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\n-    if (ret == NULL)\n+        ret = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\n+        if (ret == NULL)\n@@ -1267,2 +1271,2 @@\n-    memset(ret, 0, sizeof(xmlElement));\n-    ret->type = XML_ELEMENT_DECL;\n+        memset(ret, 0, sizeof(xmlElement));\n+        ret->type = XML_ELEMENT_DECL;\n@@ -1270,9 +1274,9 @@\n-    \/*\n-     * fill the structure.\n-     *\/\n-    ret->name = xmlStrdup(localName);\n-    if (ret->name == NULL) {\n-        xmlFree(ret);\n-        goto mem_error;\n-    }\n-    ret->prefix = prefix;\n+        \/*\n+         * fill the structure.\n+         *\/\n+        ret->name = xmlStrdup(localName);\n+        if (ret->name == NULL) {\n+            xmlFree(ret);\n+            goto mem_error;\n+        }\n+        ret->prefix = prefix;\n@@ -1281,4 +1285,4 @@\n-    \/*\n-     * Validity Check:\n-     * Insertion must not fail\n-     *\/\n+        \/*\n+         * Validity Check:\n+         * Insertion must not fail\n+         *\/\n@@ -1287,1 +1291,1 @@\n-        xmlFreeElement(ret);\n+            xmlFreeElement(ret);\n@@ -1289,6 +1293,6 @@\n-    }\n-    \/*\n-     * For new element, may have attributes from earlier\n-     * definition in internal subset\n-     *\/\n-    ret->attributes = oldAttributes;\n+        }\n+        \/*\n+         * For new element, may have attributes from earlier\n+         * definition in internal subset\n+         *\/\n+        ret->attributes = oldAttributes;\n@@ -1323,1 +1327,1 @@\n-    dtd->children = dtd->last = (xmlNodePtr) ret;\n+        dtd->children = dtd->last = (xmlNodePtr) ret;\n@@ -1326,2 +1330,2 @@\n-    ret->prev = dtd->last;\n-    dtd->last = (xmlNodePtr) ret;\n+        ret->prev = dtd->last;\n+        dtd->last = (xmlNodePtr) ret;\n@@ -1330,1 +1334,1 @@\n-    xmlFree(prefix);\n+        xmlFree(prefix);\n@@ -1349,0 +1353,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -1356,1 +1362,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -1372,1 +1377,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1377,1 +1382,1 @@\n-    cur->name = xmlStrdup(elem->name);\n+        cur->name = xmlStrdup(elem->name);\n@@ -1382,1 +1387,1 @@\n-    cur->prefix = xmlStrdup(elem->prefix);\n+        cur->prefix = xmlStrdup(elem->prefix);\n@@ -1404,0 +1409,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -1412,1 +1419,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -1479,0 +1485,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -1522,1 +1530,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -1527,0 +1534,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -1557,1 +1566,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -1580,7 +1588,7 @@\n-        ret ++;\n-        if ((ret > 1) && (err))\n-        xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_MULTIPLE_ID,\n-           \"Element %s has too many ID attributes defined : %s\\n\",\n-               elem->name, cur->name, NULL);\n-    }\n-    cur = cur->nexth;\n+            ret ++;\n+            if ((ret > 1) && (err))\n+                xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_MULTIPLE_ID,\n+               \"Element %s has too many ID attributes defined : %s\\n\",\n+                       elem->name, cur->name, NULL);\n+        }\n+        cur = cur->nexth;\n@@ -1604,1 +1612,1 @@\n-    dict = attr->doc->dict;\n+        dict = attr->doc->dict;\n@@ -1606,1 +1614,1 @@\n-    dict = NULL;\n+        dict = NULL;\n@@ -1612,1 +1620,1 @@\n-        xmlFree((xmlChar *) attr->elem);\n+            xmlFree((xmlChar *) attr->elem);\n@@ -1614,1 +1622,1 @@\n-        xmlFree((xmlChar *) attr->name);\n+            xmlFree((xmlChar *) attr->name);\n@@ -1616,1 +1624,1 @@\n-        xmlFree((xmlChar *) attr->prefix);\n+            xmlFree((xmlChar *) attr->prefix);\n@@ -1618,2 +1626,2 @@\n-        (!xmlDictOwns(dict, attr->defaultValue)))\n-        xmlFree((xmlChar *) attr->defaultValue);\n+            (!xmlDictOwns(dict, attr->defaultValue)))\n+            xmlFree((xmlChar *) attr->defaultValue);\n@@ -1621,8 +1629,8 @@\n-    if (attr->elem != NULL)\n-        xmlFree((xmlChar *) attr->elem);\n-    if (attr->name != NULL)\n-        xmlFree((xmlChar *) attr->name);\n-    if (attr->defaultValue != NULL)\n-        xmlFree((xmlChar *) attr->defaultValue);\n-    if (attr->prefix != NULL)\n-        xmlFree((xmlChar *) attr->prefix);\n+        if (attr->elem != NULL)\n+            xmlFree((xmlChar *) attr->elem);\n+        if (attr->name != NULL)\n+            xmlFree((xmlChar *) attr->name);\n+        if (attr->defaultValue != NULL)\n+            xmlFree((xmlChar *) attr->defaultValue);\n+        if (attr->prefix != NULL)\n+            xmlFree((xmlChar *) attr->prefix);\n@@ -1646,0 +1654,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -1655,2 +1665,2 @@\n-            xmlAttributeType type, xmlAttributeDefault def,\n-            const xmlChar *defaultValue, xmlEnumerationPtr tree) {\n+                    xmlAttributeType type, xmlAttributeDefault def,\n+                    const xmlChar *defaultValue, xmlEnumerationPtr tree) {\n@@ -1664,2 +1674,2 @@\n-    xmlFreeEnumeration(tree);\n-    return(NULL);\n+        xmlFreeEnumeration(tree);\n+        return(NULL);\n@@ -1668,2 +1678,2 @@\n-    xmlFreeEnumeration(tree);\n-    return(NULL);\n+        xmlFreeEnumeration(tree);\n+        return(NULL);\n@@ -1672,2 +1682,2 @@\n-    xmlFreeEnumeration(tree);\n-    return(NULL);\n+        xmlFreeEnumeration(tree);\n+        return(NULL);\n@@ -1676,1 +1686,1 @@\n-    dict = dtd->doc->dict;\n+        dict = dtd->doc->dict;\n@@ -1684,1 +1694,1 @@\n-        break;\n+            break;\n@@ -1686,1 +1696,1 @@\n-        break;\n+            break;\n@@ -1688,1 +1698,1 @@\n-        break;\n+            break;\n@@ -1690,1 +1700,1 @@\n-        break;\n+            break;\n@@ -1692,1 +1702,1 @@\n-        break;\n+            break;\n@@ -1694,1 +1704,1 @@\n-        break;\n+            break;\n@@ -1696,1 +1706,1 @@\n-        break;\n+            break;\n@@ -1698,1 +1708,1 @@\n-        break;\n+            break;\n@@ -1700,1 +1710,1 @@\n-        break;\n+            break;\n@@ -1702,6 +1712,6 @@\n-        break;\n-    default:\n-        xmlErrValid(ctxt, XML_ERR_ARGUMENT,\n-            \"xmlAddAttributeDecl: invalid type\\n\", NULL);\n-        xmlFreeEnumeration(tree);\n-        return(NULL);\n+            break;\n+        default:\n+            xmlErrValid(ctxt, XML_ERR_ARGUMENT,\n+                    \"xmlAddAttributeDecl: invalid type\\n\", NULL);\n+            xmlFreeEnumeration(tree);\n+            return(NULL);\n@@ -1711,6 +1721,6 @@\n-    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_DEFAULT,\n-                    \"Attribute %s of %s: invalid default value\\n\",\n-                    elem, name, defaultValue);\n-    defaultValue = NULL;\n-    if (ctxt != NULL)\n-        ctxt->valid = 0;\n+        xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_DEFAULT,\n+                        \"Attribute %s of %s: invalid default value\\n\",\n+                        elem, name, defaultValue);\n+        defaultValue = NULL;\n+        if (ctxt != NULL)\n+            ctxt->valid = 0;\n@@ -1725,2 +1735,2 @@\n-    (dtd->doc->intSubset != NULL) &&\n-    (dtd->doc->intSubset->attributes != NULL)) {\n+        (dtd->doc->intSubset != NULL) &&\n+        (dtd->doc->intSubset->attributes != NULL)) {\n@@ -1728,4 +1738,4 @@\n-    if (ret != NULL) {\n-        xmlFreeEnumeration(tree);\n-        return(NULL);\n-    }\n+        if (ret != NULL) {\n+            xmlFreeEnumeration(tree);\n+            return(NULL);\n+        }\n@@ -1740,1 +1750,1 @@\n-    dtd->attributes = (void *) table;\n+        dtd->attributes = (void *) table;\n@@ -1762,2 +1772,2 @@\n-    ret->name = xmlDictLookup(dict, name, -1);\n-    ret->elem = xmlDictLookup(dict, elem, -1);\n+        ret->name = xmlDictLookup(dict, name, -1);\n+        ret->elem = xmlDictLookup(dict, elem, -1);\n@@ -1765,2 +1775,2 @@\n-    ret->name = xmlStrdup(name);\n-    ret->elem = xmlStrdup(elem);\n+        ret->name = xmlStrdup(name);\n+        ret->elem = xmlStrdup(elem);\n@@ -1783,3 +1793,3 @@\n-        ret->defaultValue = xmlDictLookup(dict, defaultValue, -1);\n-    else\n-        ret->defaultValue = xmlStrdup(defaultValue);\n+            ret->defaultValue = xmlDictLookup(dict, defaultValue, -1);\n+        else\n+            ret->defaultValue = xmlStrdup(defaultValue);\n@@ -1811,2 +1821,2 @@\n-    xmlFreeAttribute(ret);\n-    return(NULL);\n+        xmlFreeAttribute(ret);\n+        return(NULL);\n@@ -1864,1 +1874,1 @@\n-    dtd->children = dtd->last = (xmlNodePtr) ret;\n+        dtd->children = dtd->last = (xmlNodePtr) ret;\n@@ -1867,2 +1877,2 @@\n-    ret->prev = dtd->last;\n-    dtd->last = (xmlNodePtr) ret;\n+        ret->prev = dtd->last;\n+        dtd->last = (xmlNodePtr) ret;\n@@ -1888,0 +1898,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -1895,1 +1907,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -1911,1 +1922,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1922,1 +1933,1 @@\n-    cur->elem = xmlStrdup(attr->elem);\n+        cur->elem = xmlStrdup(attr->elem);\n@@ -1927,1 +1938,1 @@\n-    cur->name = xmlStrdup(attr->name);\n+        cur->name = xmlStrdup(attr->name);\n@@ -1932,1 +1943,1 @@\n-    cur->prefix = xmlStrdup(attr->prefix);\n+        cur->prefix = xmlStrdup(attr->prefix);\n@@ -1937,1 +1948,1 @@\n-    cur->defaultValue = xmlStrdup(attr->defaultValue);\n+        cur->defaultValue = xmlStrdup(attr->defaultValue);\n@@ -1952,0 +1963,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -1961,1 +1974,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -2024,3 +2036,3 @@\n- *                                    *\n- *                NOTATIONs                *\n- *                                    *\n+ *                                                                      *\n+ *                              NOTATIONs                               *\n+ *                                                                      *\n@@ -2038,1 +2050,1 @@\n-    xmlFree((xmlChar *) nota->name);\n+        xmlFree((xmlChar *) nota->name);\n@@ -2040,1 +2052,1 @@\n-    xmlFree((xmlChar *) nota->PublicID);\n+        xmlFree((xmlChar *) nota->PublicID);\n@@ -2042,1 +2054,1 @@\n-    xmlFree((xmlChar *) nota->SystemID);\n+        xmlFree((xmlChar *) nota->SystemID);\n@@ -2055,0 +2067,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -2061,1 +2075,1 @@\n-               const xmlChar *name,\n+                   const xmlChar *name,\n@@ -2068,1 +2082,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2071,1 +2085,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2074,1 +2088,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2082,3 +2096,3 @@\n-    xmlDictPtr dict = NULL;\n-    if (dtd->doc != NULL)\n-        dict = dtd->doc->dict;\n+        xmlDictPtr dict = NULL;\n+        if (dtd->doc != NULL)\n+            dict = dtd->doc->dict;\n@@ -2126,2 +2140,2 @@\n-    xmlFreeNotation(ret);\n-    return(NULL);\n+        xmlFreeNotation(ret);\n+        return(NULL);\n@@ -2146,0 +2160,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -2153,1 +2169,0 @@\n-#ifdef LIBXML_TREE_ENABLED\n@@ -2169,1 +2184,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2172,1 +2187,1 @@\n-    cur->name = xmlStrdup(nota->name);\n+        cur->name = xmlStrdup(nota->name);\n@@ -2177,1 +2192,1 @@\n-    cur->PublicID = xmlStrdup(nota->PublicID);\n+        cur->PublicID = xmlStrdup(nota->PublicID);\n@@ -2182,1 +2197,1 @@\n-    cur->SystemID = xmlStrdup(nota->SystemID);\n+        cur->SystemID = xmlStrdup(nota->SystemID);\n@@ -2197,0 +2212,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -2205,1 +2222,0 @@\n-#endif \/* LIBXML_TREE_ENABLED *\/\n@@ -2254,3 +2270,3 @@\n- *                                    *\n- *                IDs                    *\n- *                                    *\n+ *                                                                      *\n+ *                              IDs                                     *\n+ *                                                                      *\n@@ -2265,4 +2281,4 @@\n-#define DICT_FREE(str)                        \\\n-    if ((str) && ((!dict) ||                \\\n-        (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))    \\\n-        xmlFree((char *)(str));\n+#define DICT_FREE(str)                                          \\\n+        if ((str) && ((!dict) ||                                \\\n+            (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n+            xmlFree((char *)(str));\n@@ -2298,1 +2314,1 @@\n-    DICT_FREE(id->value)\n+        DICT_FREE(id->value)\n@@ -2300,1 +2316,1 @@\n-    DICT_FREE(id->name)\n+        DICT_FREE(id->name)\n@@ -2331,1 +2347,1 @@\n-    return(0);\n+        return(0);\n@@ -2333,1 +2349,1 @@\n-    return(0);\n+        return(0);\n@@ -2355,1 +2371,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2372,2 +2388,2 @@\n-    xmlFreeID(id);\n-    return(-1);\n+        xmlFreeID(id);\n+        return(-1);\n@@ -2487,2 +2503,2 @@\n-        (xmlStrEqual(elem->name, BAD_CAST \"a\")))\n-        return(1);\n+            (xmlStrEqual(elem->name, BAD_CAST \"a\")))\n+            return(1);\n@@ -2490,3 +2506,3 @@\n-    xmlAttributePtr attrDecl = NULL;\n-    xmlChar felem[50];\n-    xmlChar *fullelemname;\n+        xmlAttributePtr attrDecl = NULL;\n+        xmlChar felem[50];\n+        xmlChar *fullelemname;\n@@ -2509,3 +2525,3 @@\n-    fullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?\n-        xmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :\n-        (xmlChar *)elem->name;\n+        fullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?\n+            xmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :\n+            (xmlChar *)elem->name;\n@@ -2517,7 +2533,7 @@\n-    if (fullelemname != NULL) {\n-        attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullelemname,\n-                                  attr->name, aprefix);\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullelemname,\n-                          attr->name, aprefix);\n-    }\n+        if (fullelemname != NULL) {\n+            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullelemname,\n+                                          attr->name, aprefix);\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullelemname,\n+                                              attr->name, aprefix);\n+        }\n@@ -2525,2 +2541,2 @@\n-    if ((fullelemname != felem) && (fullelemname != elem->name))\n-        xmlFree(fullelemname);\n+        if ((fullelemname != felem) && (fullelemname != elem->name))\n+            xmlFree(fullelemname);\n@@ -2529,1 +2545,1 @@\n-        return(1);\n+            return(1);\n@@ -2576,1 +2592,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2580,1 +2596,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2589,1 +2605,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2591,5 +2607,5 @@\n-    \/*\n-     * We are operating on a stream, return a well known reference\n-     * since the attribute node doesn't exist anymore\n-     *\/\n-    return((xmlAttrPtr) doc);\n+        \/*\n+         * We are operating on a stream, return a well known reference\n+         * since the attribute node doesn't exist anymore\n+         *\/\n+        return((xmlAttrPtr) doc);\n@@ -2601,3 +2617,3 @@\n- *                                    *\n- *                Refs                    *\n- *                                    *\n+ *                                                                      *\n+ *                              Refs                                    *\n+ *                                                                      *\n@@ -2607,2 +2623,2 @@\n-    xmlListPtr l;\n-    xmlAttrPtr ap;\n+        xmlListPtr l;\n+        xmlAttrPtr ap;\n@@ -2738,4 +2754,4 @@\n-    \/*\n-     * Operating in streaming mode, attr is gonna disappear\n-     *\/\n-    ret->name = xmlStrdup(attr->name);\n+        \/*\n+         * Operating in streaming mode, attr is gonna disappear\n+         *\/\n+        ret->name = xmlStrdup(attr->name);\n@@ -2744,1 +2760,1 @@\n-    ret->attr = NULL;\n+        ret->attr = NULL;\n@@ -2746,2 +2762,2 @@\n-    ret->name = NULL;\n-    ret->attr = attr;\n+        ret->name = NULL;\n+        ret->attr = attr;\n@@ -2758,1 +2774,2 @@\n-    if (NULL == (ref_list = xmlHashLookup(table, value))) {\n+    ref_list = xmlHashLookup(table, value);\n+    if (ref_list == NULL) {\n@@ -2761,2 +2778,3 @@\n-        if (NULL == (ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare)))\n-        goto failed;\n+        ref_list = xmlListCreate(xmlFreeRef, xmlDummyCompare);\n+        if (ref_list == NULL)\n+            goto failed;\n@@ -2766,1 +2784,1 @@\n-        goto failed;\n+            goto failed;\n@@ -2777,1 +2795,1 @@\n-        xmlFree((char *)ret->value);\n+            xmlFree((char *)ret->value);\n@@ -2779,1 +2797,1 @@\n-        xmlFree((char *)ret->name);\n+            xmlFree((char *)ret->name);\n@@ -2818,1 +2836,1 @@\n-    if (doc == NULL) return(0);\n+        if (doc == NULL) return(0);\n@@ -2838,4 +2856,4 @@\n-    if ((attrDecl != NULL) &&\n-        (attrDecl->atype == XML_ATTRIBUTE_IDREF ||\n-         attrDecl->atype == XML_ATTRIBUTE_IDREFS))\n-    return(1);\n+        if ((attrDecl != NULL) &&\n+            (attrDecl->atype == XML_ATTRIBUTE_IDREF ||\n+             attrDecl->atype == XML_ATTRIBUTE_IDREFS))\n+        return(1);\n@@ -2935,3 +2953,3 @@\n- *                                    *\n- *        Routines for validity checking                *\n- *                                    *\n+ *                                                                      *\n+ *              Routines for validity checking                          *\n+ *                                                                      *\n@@ -2965,1 +2983,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3000,1 +3018,1 @@\n-    xmlDictPtr dict = NULL;\n+        xmlDictPtr dict = NULL;\n@@ -3002,2 +3020,2 @@\n-    if (dtd->doc != NULL)\n-        dict = dtd->doc->dict;\n+        if (dtd->doc != NULL)\n+            dict = dtd->doc->dict;\n@@ -3005,2 +3023,2 @@\n-    dtd->elements = xmlHashCreateDict(0, dict);\n-    if (dtd->elements == NULL)\n+        dtd->elements = xmlHashCreateDict(0, dict);\n+        if (dtd->elements == NULL)\n@@ -3016,2 +3034,2 @@\n-    cur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\n-    if (cur == NULL)\n+        cur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\n+        if (cur == NULL)\n@@ -3019,2 +3037,2 @@\n-    memset(cur, 0, sizeof(xmlElement));\n-    cur->type = XML_ELEMENT_DECL;\n+        memset(cur, 0, sizeof(xmlElement));\n+        cur->type = XML_ELEMENT_DECL;\n@@ -3023,4 +3041,4 @@\n-    \/*\n-     * fill the structure.\n-     *\/\n-    cur->name = xmlStrdup(localName);\n+        \/*\n+         * fill the structure.\n+         *\/\n+        cur->name = xmlStrdup(localName);\n@@ -3029,1 +3047,1 @@\n-    cur->prefix = prefix;\n+        cur->prefix = prefix;\n@@ -3031,1 +3049,1 @@\n-    cur->etype = XML_ELEMENT_TYPE_UNDEFINED;\n+        cur->etype = XML_ELEMENT_TYPE_UNDEFINED;\n@@ -3033,1 +3051,1 @@\n-    if (xmlHashAdd2(table, localName, cur->prefix, cur) <= 0)\n+        if (xmlHashAdd2(table, localName, cur->prefix, cur) <= 0)\n@@ -3061,1 +3079,1 @@\n-                  const xmlChar *prefix) {\n+                      const xmlChar *prefix) {\n@@ -3096,1 +3114,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3122,1 +3140,1 @@\n-              const xmlChar *prefix) {\n+                  const xmlChar *prefix) {\n@@ -3153,1 +3171,1 @@\n-#if defined(LIBXML_VALID_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n+#ifdef LIBXML_VALID_ENABLED\n@@ -3177,1 +3195,1 @@\n-    notaDecl = xmlGetDtdNotationDesc(doc->extSubset, notationName);\n+        notaDecl = xmlGetDtdNotationDesc(doc->extSubset, notationName);\n@@ -3179,5 +3197,5 @@\n-    if ((notaDecl == NULL) && (ctxt != NULL)) {\n-    xmlErrValidNode(ctxt, (xmlNodePtr) doc, XML_DTD_UNKNOWN_NOTATION,\n-                    \"NOTATION %s is not declared\\n\",\n-                notationName, NULL, NULL);\n-    return(0);\n+    if (notaDecl == NULL) {\n+        xmlErrValidNode(ctxt, (xmlNodePtr) doc, XML_DTD_UNKNOWN_NOTATION,\n+                        \"NOTATION %s is not declared\\n\",\n+                        notationName, NULL, NULL);\n+        return(0);\n@@ -3187,1 +3205,1 @@\n-#endif \/* LIBXML_VALID_ENABLED or LIBXML_SCHEMAS_ENABLED *\/\n+#endif \/* LIBXML_VALID_ENABLED *\/\n@@ -3208,1 +3226,1 @@\n-    elemDecl = xmlGetDtdElementDesc(doc->extSubset, name);\n+        elemDecl = xmlGetDtdElementDesc(doc->extSubset, name);\n@@ -3211,4 +3229,4 @@\n-    case XML_ELEMENT_TYPE_UNDEFINED:\n-        return(-1);\n-    case XML_ELEMENT_TYPE_ELEMENT:\n-        return(0);\n+        case XML_ELEMENT_TYPE_UNDEFINED:\n+            return(-1);\n+        case XML_ELEMENT_TYPE_ELEMENT:\n+            return(0);\n@@ -3216,7 +3234,7 @@\n-        \/*\n-         * return 1 for EMPTY since we want VC error to pop up\n-         * on <empty>     <\/empty> for example\n-         *\/\n-    case XML_ELEMENT_TYPE_ANY:\n-    case XML_ELEMENT_TYPE_MIXED:\n-        return(1);\n+            \/*\n+             * return 1 for EMPTY since we want VC error to pop up\n+             * on <empty>     <\/empty> for example\n+             *\/\n+        case XML_ELEMENT_TYPE_ANY:\n+        case XML_ELEMENT_TYPE_MIXED:\n+            return(1);\n@@ -3247,7 +3265,7 @@\n-    if (*src == 0x20) {\n-        while (*src == 0x20) src++;\n-        if (*src != 0)\n-        *dst++ = 0x20;\n-    } else {\n-        *dst++ = *src++;\n-    }\n+        if (*src == 0x20) {\n+            while (*src == 0x20) src++;\n+            if (*src != 0)\n+                *dst++ = 0x20;\n+        } else {\n+            *dst++ = *src++;\n+        }\n@@ -3262,19 +3280,19 @@\n-     * Use the new checks of production [4] [4a] amd [5] of the\n-     * Update 5 of XML-1.0\n-     *\/\n-    if (((c >= 'a') && (c <= 'z')) ||\n-        ((c >= 'A') && (c <= 'Z')) ||\n-        (c == '_') || (c == ':') ||\n-        ((c >= 0xC0) && (c <= 0xD6)) ||\n-        ((c >= 0xD8) && (c <= 0xF6)) ||\n-        ((c >= 0xF8) && (c <= 0x2FF)) ||\n-        ((c >= 0x370) && (c <= 0x37D)) ||\n-        ((c >= 0x37F) && (c <= 0x1FFF)) ||\n-        ((c >= 0x200C) && (c <= 0x200D)) ||\n-        ((c >= 0x2070) && (c <= 0x218F)) ||\n-        ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n-        ((c >= 0x3001) && (c <= 0xD7FF)) ||\n-        ((c >= 0xF900) && (c <= 0xFDCF)) ||\n-        ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n-        ((c >= 0x10000) && (c <= 0xEFFFF)))\n-        return(1);\n+         * Use the new checks of production [4] [4a] amd [5] of the\n+         * Update 5 of XML-1.0\n+         *\/\n+        if (((c >= 'a') && (c <= 'z')) ||\n+            ((c >= 'A') && (c <= 'Z')) ||\n+            (c == '_') || (c == ':') ||\n+            ((c >= 0xC0) && (c <= 0xD6)) ||\n+            ((c >= 0xD8) && (c <= 0xF6)) ||\n+            ((c >= 0xF8) && (c <= 0x2FF)) ||\n+            ((c >= 0x370) && (c <= 0x37D)) ||\n+            ((c >= 0x37F) && (c <= 0x1FFF)) ||\n+            ((c >= 0x200C) && (c <= 0x200D)) ||\n+            ((c >= 0x2070) && (c <= 0x218F)) ||\n+            ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n+            ((c >= 0x3001) && (c <= 0xD7FF)) ||\n+            ((c >= 0xF900) && (c <= 0xFDCF)) ||\n+            ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n+            ((c >= 0x10000) && (c <= 0xEFFFF)))\n+            return(1);\n@@ -3283,1 +3301,1 @@\n-        return(1);\n+            return(1);\n@@ -3292,23 +3310,23 @@\n-     * Use the new checks of production [4] [4a] amd [5] of the\n-     * Update 5 of XML-1.0\n-     *\/\n-    if (((c >= 'a') && (c <= 'z')) ||\n-        ((c >= 'A') && (c <= 'Z')) ||\n-        ((c >= '0') && (c <= '9')) || \/* !start *\/\n-        (c == '_') || (c == ':') ||\n-        (c == '-') || (c == '.') || (c == 0xB7) || \/* !start *\/\n-        ((c >= 0xC0) && (c <= 0xD6)) ||\n-        ((c >= 0xD8) && (c <= 0xF6)) ||\n-        ((c >= 0xF8) && (c <= 0x2FF)) ||\n-        ((c >= 0x300) && (c <= 0x36F)) || \/* !start *\/\n-        ((c >= 0x370) && (c <= 0x37D)) ||\n-        ((c >= 0x37F) && (c <= 0x1FFF)) ||\n-        ((c >= 0x200C) && (c <= 0x200D)) ||\n-        ((c >= 0x203F) && (c <= 0x2040)) || \/* !start *\/\n-        ((c >= 0x2070) && (c <= 0x218F)) ||\n-        ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n-        ((c >= 0x3001) && (c <= 0xD7FF)) ||\n-        ((c >= 0xF900) && (c <= 0xFDCF)) ||\n-        ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n-        ((c >= 0x10000) && (c <= 0xEFFFF)))\n-         return(1);\n+         * Use the new checks of production [4] [4a] amd [5] of the\n+         * Update 5 of XML-1.0\n+         *\/\n+        if (((c >= 'a') && (c <= 'z')) ||\n+            ((c >= 'A') && (c <= 'Z')) ||\n+            ((c >= '0') && (c <= '9')) || \/* !start *\/\n+            (c == '_') || (c == ':') ||\n+            (c == '-') || (c == '.') || (c == 0xB7) || \/* !start *\/\n+            ((c >= 0xC0) && (c <= 0xD6)) ||\n+            ((c >= 0xD8) && (c <= 0xF6)) ||\n+            ((c >= 0xF8) && (c <= 0x2FF)) ||\n+            ((c >= 0x300) && (c <= 0x36F)) || \/* !start *\/\n+            ((c >= 0x370) && (c <= 0x37D)) ||\n+            ((c >= 0x37F) && (c <= 0x1FFF)) ||\n+            ((c >= 0x200C) && (c <= 0x200D)) ||\n+            ((c >= 0x203F) && (c <= 0x2040)) || \/* !start *\/\n+            ((c >= 0x2070) && (c <= 0x218F)) ||\n+            ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n+            ((c >= 0x3001) && (c <= 0xD7FF)) ||\n+            ((c >= 0xF900) && (c <= 0xFDCF)) ||\n+            ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n+            ((c >= 0x10000) && (c <= 0xEFFFF)))\n+             return(1);\n@@ -3318,4 +3336,4 @@\n-        (c == '_') || (c == ':') ||\n-        (IS_COMBINING(c)) ||\n-        (IS_EXTENDER(c)))\n-        return(1);\n+            (c == '_') || (c == ':') ||\n+            (IS_COMBINING(c)) ||\n+            (IS_EXTENDER(c)))\n+            return(1);\n@@ -3346,1 +3364,1 @@\n-    return(0);\n+        return(0);\n@@ -3351,2 +3369,2 @@\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    cur += len;\n+        val = xmlStringCurrentChar(NULL, cur, &len);\n+        cur += len;\n@@ -3395,1 +3413,1 @@\n-    return(0);\n+        return(0);\n@@ -3400,7 +3418,0 @@\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    cur += len;\n-    }\n-\n-    \/* Should not test IS_BLANK(val) here -- see erratum E20*\/\n-    while (val == 0x20) {\n-    while (val == 0x20) {\n@@ -3411,2 +3422,6 @@\n-    if (!xmlIsDocNameStartChar(doc, val))\n-        return(0);\n+    \/* Should not test IS_BLANK(val) here -- see erratum E20*\/\n+    while (val == 0x20) {\n+        while (val == 0x20) {\n+            val = xmlStringCurrentChar(NULL, cur, &len);\n+            cur += len;\n+        }\n@@ -3414,2 +3429,2 @@\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    cur += len;\n+        if (!xmlIsDocNameStartChar(doc, val))\n+            return(0);\n@@ -3417,1 +3432,0 @@\n-    while (xmlIsDocNameChar(doc, val)) {\n@@ -3420,1 +3434,5 @@\n-    }\n+\n+        while (xmlIsDocNameChar(doc, val)) {\n+            val = xmlStringCurrentChar(NULL, cur, &len);\n+            cur += len;\n+        }\n@@ -3465,1 +3483,1 @@\n-    return(0);\n+        return(0);\n@@ -3470,2 +3488,2 @@\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    cur += len;\n+        val = xmlStringCurrentChar(NULL, cur, &len);\n+        cur += len;\n@@ -3518,2 +3536,2 @@\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    cur += len;\n+        val = xmlStringCurrentChar(NULL, cur, &len);\n+        cur += len;\n@@ -3523,1 +3541,1 @@\n-    return(0);\n+        return(0);\n@@ -3526,7 +3544,0 @@\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    cur += len;\n-    }\n-\n-    \/* Should not test IS_BLANK(val) here -- see erratum E20*\/\n-    while (val == 0x20) {\n-    while (val == 0x20) {\n@@ -3536,1 +3547,0 @@\n-    if (val == 0) return(1);\n@@ -3538,2 +3548,7 @@\n-    if (!xmlIsDocNameChar(doc, val))\n-        return(0);\n+    \/* Should not test IS_BLANK(val) here -- see erratum E20*\/\n+    while (val == 0x20) {\n+        while (val == 0x20) {\n+            val = xmlStringCurrentChar(NULL, cur, &len);\n+            cur += len;\n+        }\n+        if (val == 0) return(1);\n@@ -3541,2 +3556,2 @@\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    cur += len;\n+        if (!xmlIsDocNameChar(doc, val))\n+            return(0);\n@@ -3544,1 +3559,0 @@\n-    while (xmlIsDocNameChar(doc, val)) {\n@@ -3547,1 +3561,5 @@\n-    }\n+\n+        while (xmlIsDocNameChar(doc, val)) {\n+            val = xmlStringCurrentChar(NULL, cur, &len);\n+            cur += len;\n+        }\n@@ -3611,13 +3629,13 @@\n-    case XML_ATTRIBUTE_ENTITIES:\n-    case XML_ATTRIBUTE_IDREFS:\n-        return(xmlValidateNamesValueInternal(doc, value));\n-    case XML_ATTRIBUTE_ENTITY:\n-    case XML_ATTRIBUTE_IDREF:\n-    case XML_ATTRIBUTE_ID:\n-    case XML_ATTRIBUTE_NOTATION:\n-        return(xmlValidateNameValueInternal(doc, value));\n-    case XML_ATTRIBUTE_NMTOKENS:\n-    case XML_ATTRIBUTE_ENUMERATION:\n-        return(xmlValidateNmtokensValueInternal(doc, value));\n-    case XML_ATTRIBUTE_NMTOKEN:\n-        return(xmlValidateNmtokenValueInternal(doc, value));\n+        case XML_ATTRIBUTE_ENTITIES:\n+        case XML_ATTRIBUTE_IDREFS:\n+            return(xmlValidateNamesValueInternal(doc, value));\n+        case XML_ATTRIBUTE_ENTITY:\n+        case XML_ATTRIBUTE_IDREF:\n+        case XML_ATTRIBUTE_ID:\n+        case XML_ATTRIBUTE_NOTATION:\n+            return(xmlValidateNameValueInternal(doc, value));\n+        case XML_ATTRIBUTE_NMTOKENS:\n+        case XML_ATTRIBUTE_ENUMERATION:\n+            return(xmlValidateNmtokensValueInternal(doc, value));\n+        case XML_ATTRIBUTE_NMTOKEN:\n+            return(xmlValidateNmtokenValueInternal(doc, value));\n@@ -3625,1 +3643,1 @@\n-        break;\n+            break;\n@@ -3695,6 +3713,6 @@\n-    case XML_ATTRIBUTE_IDREFS:\n-    case XML_ATTRIBUTE_IDREF:\n-    case XML_ATTRIBUTE_ID:\n-    case XML_ATTRIBUTE_NMTOKENS:\n-    case XML_ATTRIBUTE_ENUMERATION:\n-    case XML_ATTRIBUTE_NMTOKEN:\n+        case XML_ATTRIBUTE_IDREFS:\n+        case XML_ATTRIBUTE_IDREF:\n+        case XML_ATTRIBUTE_ID:\n+        case XML_ATTRIBUTE_NMTOKENS:\n+        case XML_ATTRIBUTE_ENUMERATION:\n+        case XML_ATTRIBUTE_NMTOKEN:\n@@ -3702,13 +3720,13 @@\n-        break;\n-    case XML_ATTRIBUTE_ENTITY: {\n-        xmlEntityPtr ent;\n-\n-        ent = xmlGetDocEntity(doc, value);\n-        \/* yeah it's a bit messy... *\/\n-        if ((ent == NULL) && (doc->standalone == 1)) {\n-        doc->standalone = 0;\n-        ent = xmlGetDocEntity(doc, value);\n-        }\n-        if (ent == NULL) {\n-        xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n-                XML_DTD_UNKNOWN_ENTITY,\n+            break;\n+        case XML_ATTRIBUTE_ENTITY: {\n+            xmlEntityPtr ent;\n+\n+            ent = xmlGetDocEntity(doc, value);\n+            \/* yeah it's a bit messy... *\/\n+            if ((ent == NULL) && (doc->standalone == 1)) {\n+                doc->standalone = 0;\n+                ent = xmlGetDocEntity(doc, value);\n+            }\n+            if (ent == NULL) {\n+                xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n+                                XML_DTD_UNKNOWN_ENTITY,\n@@ -3716,5 +3734,5 @@\n-               name, value, NULL);\n-        ret = 0;\n-        } else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n-        xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n-                XML_DTD_ENTITY_TYPE,\n+                       name, value, NULL);\n+                ret = 0;\n+            } else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n+                xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n+                                XML_DTD_ENTITY_TYPE,\n@@ -3722,4 +3740,4 @@\n-               name, value, NULL);\n-        ret = 0;\n-        }\n-        break;\n+                       name, value, NULL);\n+                ret = 0;\n+            }\n+            break;\n@@ -3727,3 +3745,3 @@\n-    case XML_ATTRIBUTE_ENTITIES: {\n-        xmlChar *dup, *nam = NULL, *cur, save;\n-        xmlEntityPtr ent;\n+        case XML_ATTRIBUTE_ENTITIES: {\n+            xmlChar *dup, *nam = NULL, *cur, save;\n+            xmlEntityPtr ent;\n@@ -3731,2 +3749,2 @@\n-        dup = xmlStrdup(value);\n-        if (dup == NULL) {\n+            dup = xmlStrdup(value);\n+            if (dup == NULL) {\n@@ -3734,1 +3752,1 @@\n-        return(0);\n+                return(0);\n@@ -3736,10 +3754,10 @@\n-        cur = dup;\n-        while (*cur != 0) {\n-        nam = cur;\n-        while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n-        save = *cur;\n-        *cur = 0;\n-        ent = xmlGetDocEntity(doc, nam);\n-        if (ent == NULL) {\n-            xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n-                    XML_DTD_UNKNOWN_ENTITY,\n+            cur = dup;\n+            while (*cur != 0) {\n+                nam = cur;\n+                while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n+                save = *cur;\n+                *cur = 0;\n+                ent = xmlGetDocEntity(doc, nam);\n+                if (ent == NULL) {\n+                    xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n+                                    XML_DTD_UNKNOWN_ENTITY,\n@@ -3747,5 +3765,5 @@\n-               name, nam, NULL);\n-            ret = 0;\n-        } else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n-            xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n-                    XML_DTD_ENTITY_TYPE,\n+                           name, nam, NULL);\n+                    ret = 0;\n+                } else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n+                    xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n+                                    XML_DTD_ENTITY_TYPE,\n@@ -3753,4 +3771,9 @@\n-               name, nam, NULL);\n-            ret = 0;\n-        }\n-        if (save == 0)\n+                           name, nam, NULL);\n+                    ret = 0;\n+                }\n+                if (save == 0)\n+                    break;\n+                *cur = save;\n+                while (IS_BLANK_CH(*cur)) cur++;\n+            }\n+            xmlFree(dup);\n@@ -3758,2 +3781,0 @@\n-        *cur = save;\n-        while (IS_BLANK_CH(*cur)) cur++;\n@@ -3761,5 +3782,2 @@\n-        xmlFree(dup);\n-        break;\n-    }\n-    case XML_ATTRIBUTE_NOTATION: {\n-        xmlNotationPtr nota;\n+        case XML_ATTRIBUTE_NOTATION: {\n+            xmlNotationPtr nota;\n@@ -3767,3 +3785,3 @@\n-        nota = xmlGetDtdNotationDesc(doc->intSubset, value);\n-        if ((nota == NULL) && (doc->extSubset != NULL))\n-        nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n+            nota = xmlGetDtdNotationDesc(doc->intSubset, value);\n+            if ((nota == NULL) && (doc->extSubset != NULL))\n+                nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n@@ -3771,3 +3789,3 @@\n-        if (nota == NULL) {\n-        xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n-                        XML_DTD_UNKNOWN_NOTATION,\n+            if (nota == NULL) {\n+                xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n+                                XML_DTD_UNKNOWN_NOTATION,\n@@ -3775,4 +3793,4 @@\n-               name, value, NULL);\n-        ret = 0;\n-        }\n-        break;\n+                       name, value, NULL);\n+                ret = 0;\n+            }\n+            break;\n@@ -3812,1 +3830,1 @@\n-         xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n+             xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n@@ -3829,2 +3847,2 @@\n-    xmlChar buf[50];\n-    xmlChar *elemname;\n+        xmlChar buf[50];\n+        xmlChar *elemname;\n@@ -3832,3 +3850,3 @@\n-    elemname = xmlBuildQName(elem->name, elem->ns->prefix, buf, 50);\n-    if (elemname == NULL)\n-        goto mem_error;\n+        elemname = xmlBuildQName(elem->name, elem->ns->prefix, buf, 50);\n+        if (elemname == NULL)\n+            goto mem_error;\n@@ -3838,2 +3856,2 @@\n-    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n-        attrDecl = xmlHashLookup3(doc->extSubset->attributes, localName,\n+        if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n+            attrDecl = xmlHashLookup3(doc->extSubset->attributes, localName,\n@@ -3841,5 +3859,5 @@\n-        if (attrDecl != NULL)\n-        extsubset = 1;\n-    }\n-    if ((elemname != buf) && (elemname != elem->name))\n-        xmlFree(elemname);\n+            if (attrDecl != NULL)\n+                extsubset = 1;\n+        }\n+        if ((elemname != buf) && (elemname != elem->name))\n+            xmlFree(elemname);\n@@ -3848,1 +3866,1 @@\n-    attrDecl = xmlHashLookup3(doc->intSubset->attributes, localName,\n+        attrDecl = xmlHashLookup3(doc->intSubset->attributes, localName,\n@@ -3851,1 +3869,1 @@\n-    attrDecl = xmlHashLookup3(doc->extSubset->attributes, localName,\n+        attrDecl = xmlHashLookup3(doc->extSubset->attributes, localName,\n@@ -3853,2 +3871,2 @@\n-    if (attrDecl != NULL)\n-        extsubset = 1;\n+        if (attrDecl != NULL)\n+            extsubset = 1;\n@@ -3858,1 +3876,1 @@\n-    goto done;\n+        goto done;\n@@ -3860,1 +3878,1 @@\n-    goto done;\n+        goto done;\n@@ -3864,1 +3882,1 @@\n-    goto mem_error;\n+        goto mem_error;\n@@ -3867,1 +3885,1 @@\n-    xmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n+        xmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n@@ -3869,2 +3887,2 @@\n-           name, elem->name, NULL);\n-    ctxt->valid = 0;\n+               name, elem->name, NULL);\n+        ctxt->valid = 0;\n@@ -3907,1 +3925,1 @@\n-                    const xmlChar *name, const xmlChar *value) {\n+                                const xmlChar *name, const xmlChar *value) {\n@@ -3917,2 +3935,2 @@\n-    xmlChar fn[50];\n-    xmlChar *fullname;\n+        xmlChar fn[50];\n+        xmlChar *fullname;\n@@ -3920,5 +3938,5 @@\n-    fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n-    if (fullname == NULL)\n-        return(NULL);\n-    if ((fullname != fn) && (fullname != elem->name))\n-        xmlFree(fullname);\n+        fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n+        if (fullname == NULL)\n+            return(NULL);\n+        if ((fullname != fn) && (fullname != elem->name))\n+            xmlFree(fullname);\n@@ -3928,1 +3946,1 @@\n-    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n+        attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n@@ -3931,1 +3949,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3933,1 +3951,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3937,1 +3955,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3944,1 +3962,1 @@\n-                           const xmlChar *name ATTRIBUTE_UNUSED) {\n+                               const xmlChar *name ATTRIBUTE_UNUSED) {\n@@ -3981,7 +3999,7 @@\n-    val = xmlValidateAttributeValueInternal(doc, attr->atype,\n-                                            attr->defaultValue);\n-    if (val == 0) {\n-        xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_DEFAULT,\n-           \"Syntax of default value for attribute %s of %s is not valid\\n\",\n-               attr->name, attr->elem, NULL);\n-    }\n+        val = xmlValidateAttributeValueInternal(doc, attr->atype,\n+                                                attr->defaultValue);\n+        if (val == 0) {\n+            xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_DEFAULT,\n+               \"Syntax of default value for attribute %s of %s is not valid\\n\",\n+                   attr->name, attr->elem, NULL);\n+        }\n@@ -3994,2 +4012,2 @@\n-    (attr->def != XML_ATTRIBUTE_REQUIRED)) {\n-    xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_FIXED,\n+        (attr->def != XML_ATTRIBUTE_REQUIRED)) {\n+        xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_FIXED,\n@@ -3997,2 +4015,2 @@\n-           attr->name, attr->elem, NULL);\n-    ret = 0;\n+               attr->name, attr->elem, NULL);\n+        ret = 0;\n@@ -4014,1 +4032,1 @@\n-    \/* the trick is that we parse DtD as their own internal subset *\/\n+        \/* the trick is that we parse DtD as their own internal subset *\/\n@@ -4018,4 +4036,4 @@\n-    if (elem != NULL) {\n-        nbId = xmlScanIDAttributeDecl(ctxt, elem, 0);\n-    } else {\n-        xmlAttributeTablePtr table;\n+        if (elem != NULL) {\n+            nbId = xmlScanIDAttributeDecl(ctxt, elem, 0);\n+        } else {\n+            xmlAttributeTablePtr table;\n@@ -4023,9 +4041,10 @@\n-        \/*\n-         * The attribute may be declared in the internal subset and the\n-         * element in the external subset.\n-         *\/\n-        nbId = 0;\n-        if (doc->intSubset != NULL) {\n-        table = (xmlAttributeTablePtr) doc->intSubset->attributes;\n-        xmlHashScan3(table, NULL, NULL, attr->elem,\n-                 xmlValidateAttributeIdCallback, &nbId);\n+            \/*\n+             * The attribute may be declared in the internal subset and the\n+             * element in the external subset.\n+             *\/\n+            nbId = 0;\n+            if (doc->intSubset != NULL) {\n+                table = (xmlAttributeTablePtr) doc->intSubset->attributes;\n+                xmlHashScan3(table, NULL, NULL, attr->elem,\n+                             xmlValidateAttributeIdCallback, &nbId);\n+            }\n@@ -4033,2 +4052,1 @@\n-    }\n-    if (nbId > 1) {\n+        if (nbId > 1) {\n@@ -4036,1 +4054,1 @@\n-        xmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n+            xmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n@@ -4038,1 +4056,1 @@\n-           attr->elem, nbId, attr->name);\n+                   attr->elem, nbId, attr->name);\n@@ -4040,3 +4058,3 @@\n-    } else if (doc->extSubset != NULL) {\n-        int extId = 0;\n-        elem = xmlHashLookup2(doc->extSubset->elements,\n+        } else if (doc->extSubset != NULL) {\n+            int extId = 0;\n+            elem = xmlHashLookup2(doc->extSubset->elements,\n@@ -4044,5 +4062,5 @@\n-        if (elem != NULL) {\n-        extId = xmlScanIDAttributeDecl(ctxt, elem, 0);\n-        }\n-        if (extId > 1) {\n-        xmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n+            if (elem != NULL) {\n+                extId = xmlScanIDAttributeDecl(ctxt, elem, 0);\n+            }\n+            if (extId > 1) {\n+                xmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n@@ -4050,1 +4068,1 @@\n-               attr->elem, extId, attr->name);\n+                       attr->elem, extId, attr->name);\n@@ -4052,2 +4070,2 @@\n-        } else if (extId + nbId > 1) {\n-        xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n+            } else if (extId + nbId > 1) {\n+                xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n@@ -4055,1 +4073,1 @@\n-               attr->elem, attr->name, NULL);\n+                       attr->elem, attr->name, NULL);\n@@ -4057,0 +4075,1 @@\n+            }\n@@ -4058,1 +4077,0 @@\n-    }\n@@ -4066,6 +4084,6 @@\n-    while (tree != NULL) {\n-        if (xmlStrEqual(tree->name, attr->defaultValue)) break;\n-        tree = tree->next;\n-    }\n-    if (tree == NULL) {\n-        xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_VALUE,\n+        while (tree != NULL) {\n+            if (xmlStrEqual(tree->name, attr->defaultValue)) break;\n+            tree = tree->next;\n+        }\n+        if (tree == NULL) {\n+            xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_VALUE,\n@@ -4073,3 +4091,3 @@\n-           attr->defaultValue, attr->name, attr->elem);\n-        ret = 0;\n-    }\n+                   attr->defaultValue, attr->name, attr->elem);\n+            ret = 0;\n+        }\n@@ -4111,7 +4129,0 @@\n-#if 0\n-#ifdef LIBXML_REGEXP_ENABLED\n-    \/* Build the regexp associated to the content model *\/\n-    ret = xmlValidBuildContentModel(ctxt, elem);\n-#endif\n-#endif\n-\n@@ -4120,1 +4131,1 @@\n-    xmlElementContentPtr cur, next;\n+        xmlElementContentPtr cur, next;\n@@ -4123,19 +4134,40 @@\n-    cur = elem->content;\n-    while (cur != NULL) {\n-        if (cur->type != XML_ELEMENT_CONTENT_OR) break;\n-        if (cur->c1 == NULL) break;\n-        if (cur->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {\n-        name = cur->c1->name;\n-        next = cur->c2;\n-        while (next != NULL) {\n-            if (next->type == XML_ELEMENT_CONTENT_ELEMENT) {\n-                if ((xmlStrEqual(next->name, name)) &&\n-                (xmlStrEqual(next->prefix, cur->c1->prefix))) {\n-                if (cur->c1->prefix == NULL) {\n-                xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n-           \"Definition of %s has duplicate references of %s\\n\",\n-                       elem->name, name, NULL);\n-                } else {\n-                xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n-           \"Definition of %s has duplicate references of %s:%s\\n\",\n-                       elem->name, cur->c1->prefix, name);\n+        cur = elem->content;\n+        while (cur != NULL) {\n+            if (cur->type != XML_ELEMENT_CONTENT_OR) break;\n+            if (cur->c1 == NULL) break;\n+            if (cur->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {\n+                name = cur->c1->name;\n+                next = cur->c2;\n+                while (next != NULL) {\n+                    if (next->type == XML_ELEMENT_CONTENT_ELEMENT) {\n+                        if ((xmlStrEqual(next->name, name)) &&\n+                            (xmlStrEqual(next->prefix, cur->c1->prefix))) {\n+                            if (cur->c1->prefix == NULL) {\n+                                xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n+                   \"Definition of %s has duplicate references of %s\\n\",\n+                                       elem->name, name, NULL);\n+                            } else {\n+                                xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n+                   \"Definition of %s has duplicate references of %s:%s\\n\",\n+                                       elem->name, cur->c1->prefix, name);\n+                            }\n+                            ret = 0;\n+                        }\n+                        break;\n+                    }\n+                    if (next->c1 == NULL) break;\n+                    if (next->c1->type != XML_ELEMENT_CONTENT_ELEMENT) break;\n+                    if ((xmlStrEqual(next->c1->name, name)) &&\n+                        (xmlStrEqual(next->c1->prefix, cur->c1->prefix))) {\n+                        if (cur->c1->prefix == NULL) {\n+                            xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n+               \"Definition of %s has duplicate references to %s\\n\",\n+                                   elem->name, name, NULL);\n+                        } else {\n+                            xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n+               \"Definition of %s has duplicate references to %s:%s\\n\",\n+                                   elem->name, cur->c1->prefix, name);\n+                        }\n+                        ret = 0;\n+                    }\n+                    next = next->c2;\n@@ -4143,18 +4175,0 @@\n-                ret = 0;\n-            }\n-            break;\n-            }\n-            if (next->c1 == NULL) break;\n-            if (next->c1->type != XML_ELEMENT_CONTENT_ELEMENT) break;\n-            if ((xmlStrEqual(next->c1->name, name)) &&\n-                (xmlStrEqual(next->c1->prefix, cur->c1->prefix))) {\n-            if (cur->c1->prefix == NULL) {\n-                xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n-           \"Definition of %s has duplicate references to %s\\n\",\n-                   elem->name, name, NULL);\n-            } else {\n-                xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n-           \"Definition of %s has duplicate references to %s:%s\\n\",\n-                   elem->name, cur->c1->prefix, name);\n-            }\n-            ret = 0;\n@@ -4162,2 +4176,1 @@\n-            next = next->c2;\n-        }\n+            cur = cur->c2;\n@@ -4165,2 +4178,0 @@\n-        cur = cur->c2;\n-    }\n@@ -4206,1 +4217,1 @@\n-    ret = 0;\n+        ret = 0;\n@@ -4256,2 +4267,2 @@\n-    xmlChar fn[50];\n-    xmlChar *fullname;\n+        xmlChar fn[50];\n+        xmlChar *fullname;\n@@ -4259,2 +4270,2 @@\n-    fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n-    if (fullname == NULL) {\n+        fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n+        if (fullname == NULL) {\n@@ -4262,1 +4273,1 @@\n-        return(0);\n+            return(0);\n@@ -4269,2 +4280,2 @@\n-    if ((fullname != fn) && (fullname != elem->name))\n-        xmlFree(fullname);\n+        if ((fullname != fn) && (fullname != elem->name))\n+            xmlFree(fullname);\n@@ -4283,4 +4294,4 @@\n-    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n-           \"No declaration for attribute %s of element %s\\n\",\n-           attr->name, elem->name, NULL);\n-    return(0);\n+        xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n+               \"No declaration for attribute %s of element %s\\n\",\n+               attr->name, elem->name, NULL);\n+        return(0);\n@@ -4294,3 +4305,3 @@\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n-       \"Syntax of value for attribute %s of %s is not valid\\n\",\n-           attr->name, elem->name, NULL);\n+            xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n+           \"Syntax of value for attribute %s of %s is not valid\\n\",\n+               attr->name, elem->name, NULL);\n@@ -4302,6 +4313,6 @@\n-    if (!xmlStrEqual(value, attrDecl->defaultValue)) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n-       \"Value for attribute %s of %s is different from default \\\"%s\\\"\\n\",\n-           attr->name, elem->name, attrDecl->defaultValue);\n-        ret = 0;\n-    }\n+        if (!xmlStrEqual(value, attrDecl->defaultValue)) {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n+           \"Value for attribute %s of %s is different from default \\\"%s\\\"\\n\",\n+                   attr->name, elem->name, attrDecl->defaultValue);\n+            ret = 0;\n+        }\n@@ -4313,1 +4324,1 @@\n-        ret = 0;\n+            ret = 0;\n@@ -4317,1 +4328,1 @@\n-    (attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {\n+        (attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {\n@@ -4319,1 +4330,1 @@\n-        ret = 0;\n+            ret = 0;\n@@ -4328,3 +4339,3 @@\n-    nota = xmlGetDtdNotationDesc(doc->intSubset, value);\n-    if (nota == NULL)\n-        nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n+        nota = xmlGetDtdNotationDesc(doc->intSubset, value);\n+        if (nota == NULL)\n+            nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n@@ -4332,2 +4343,2 @@\n-    if (nota == NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n+        if (nota == NULL) {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n@@ -4335,2 +4346,2 @@\n-           value, attr->name, elem->name);\n-        ret = 0;\n+                   value, attr->name, elem->name);\n+            ret = 0;\n@@ -4339,7 +4350,7 @@\n-    \/* Second, verify that it's among the list *\/\n-    while (tree != NULL) {\n-        if (xmlStrEqual(tree->name, value)) break;\n-        tree = tree->next;\n-    }\n-    if (tree == NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n+        \/* Second, verify that it's among the list *\/\n+        while (tree != NULL) {\n+            if (xmlStrEqual(tree->name, value)) break;\n+            tree = tree->next;\n+        }\n+        if (tree == NULL) {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n@@ -4347,3 +4358,3 @@\n-           value, attr->name, elem->name);\n-        ret = 0;\n-    }\n+                   value, attr->name, elem->name);\n+            ret = 0;\n+        }\n@@ -4355,6 +4366,6 @@\n-    while (tree != NULL) {\n-        if (xmlStrEqual(tree->name, value)) break;\n-        tree = tree->next;\n-    }\n-    if (tree == NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n+        while (tree != NULL) {\n+            if (xmlStrEqual(tree->name, value)) break;\n+            tree = tree->next;\n+        }\n+        if (tree == NULL) {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n@@ -4362,3 +4373,3 @@\n-           value, attr->name, elem->name);\n-        ret = 0;\n-    }\n+                   value, attr->name, elem->name);\n+            ret = 0;\n+        }\n@@ -4370,3 +4381,3 @@\n-    xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n-       \"Value for attribute %s of %s must be \\\"%s\\\"\\n\",\n-           attr->name, elem->name, attrDecl->defaultValue);\n+        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n+           \"Value for attribute %s of %s must be \\\"%s\\\"\\n\",\n+               attr->name, elem->name, attrDecl->defaultValue);\n@@ -4378,1 +4389,1 @@\n-                      attrDecl->atype, value);\n+                                      attrDecl->atype, value);\n@@ -4424,2 +4435,2 @@\n-    xmlChar fn[50];\n-    xmlChar *fullname;\n+        xmlChar fn[50];\n+        xmlChar *fullname;\n@@ -4427,13 +4438,13 @@\n-    fullname = xmlBuildQName(elem->name, prefix, fn, 50);\n-    if (fullname == NULL) {\n-        xmlVErrMemory(ctxt);\n-        return(0);\n-    }\n-    if (ns->prefix != NULL) {\n-        attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,\n-                                  ns->prefix, BAD_CAST \"xmlns\");\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,\n-                      ns->prefix, BAD_CAST \"xmlns\");\n-    } else {\n-        attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,\n+        fullname = xmlBuildQName(elem->name, prefix, fn, 50);\n+        if (fullname == NULL) {\n+            xmlVErrMemory(ctxt);\n+            return(0);\n+        }\n+        if (ns->prefix != NULL) {\n+            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,\n+                                          ns->prefix, BAD_CAST \"xmlns\");\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,\n+                                          ns->prefix, BAD_CAST \"xmlns\");\n+        } else {\n+            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,\n@@ -4441,2 +4452,2 @@\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,\n@@ -4444,3 +4455,3 @@\n-    }\n-    if ((fullname != fn) && (fullname != elem->name))\n-        xmlFree(fullname);\n+        }\n+        if ((fullname != fn) && (fullname != elem->name))\n+            xmlFree(fullname);\n@@ -4449,8 +4460,8 @@\n-    if (ns->prefix != NULL) {\n-        attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,\n-                                  ns->prefix, BAD_CAST \"xmlns\");\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,\n-                          ns->prefix, BAD_CAST \"xmlns\");\n-    } else {\n-        attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,\n+        if (ns->prefix != NULL) {\n+            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,\n+                                          ns->prefix, BAD_CAST \"xmlns\");\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,\n+                                              ns->prefix, BAD_CAST \"xmlns\");\n+        } else {\n+            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,\n@@ -4458,2 +4469,2 @@\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,\n@@ -4461,1 +4472,1 @@\n-    }\n+        }\n@@ -4467,10 +4478,10 @@\n-    if (ns->prefix != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n-           \"No declaration for attribute xmlns:%s of element %s\\n\",\n-           ns->prefix, elem->name, NULL);\n-    } else {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n-           \"No declaration for attribute xmlns of element %s\\n\",\n-           elem->name, NULL, NULL);\n-    }\n-    return(0);\n+        if (ns->prefix != NULL) {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n+                   \"No declaration for attribute xmlns:%s of element %s\\n\",\n+                   ns->prefix, elem->name, NULL);\n+        } else {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n+                   \"No declaration for attribute xmlns of element %s\\n\",\n+                   elem->name, NULL, NULL);\n+        }\n+        return(0);\n@@ -4481,9 +4492,9 @@\n-    if (ns->prefix != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,\n-           \"Syntax of value for attribute xmlns:%s of %s is not valid\\n\",\n-           ns->prefix, elem->name, NULL);\n-    } else {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,\n-           \"Syntax of value for attribute xmlns of %s is not valid\\n\",\n-           elem->name, NULL, NULL);\n-    }\n+        if (ns->prefix != NULL) {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,\n+               \"Syntax of value for attribute xmlns:%s of %s is not valid\\n\",\n+                   ns->prefix, elem->name, NULL);\n+        } else {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,\n+               \"Syntax of value for attribute xmlns of %s is not valid\\n\",\n+                   elem->name, NULL, NULL);\n+        }\n@@ -4495,3 +4506,3 @@\n-    if (!xmlStrEqual(value, attrDecl->defaultValue)) {\n-        if (ns->prefix != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n+        if (!xmlStrEqual(value, attrDecl->defaultValue)) {\n+            if (ns->prefix != NULL) {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n@@ -4499,3 +4510,3 @@\n-               ns->prefix, elem->name, attrDecl->defaultValue);\n-        } else {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n+                       ns->prefix, elem->name, attrDecl->defaultValue);\n+            } else {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n@@ -4503,1 +4514,3 @@\n-               elem->name, attrDecl->defaultValue, NULL);\n+                       elem->name, attrDecl->defaultValue, NULL);\n+            }\n+            ret = 0;\n@@ -4505,14 +4518,0 @@\n-        ret = 0;\n-    }\n-    }\n-\n-    \/*\n-     * Casting ns to xmlAttrPtr is wrong. We'd need separate functions\n-     * xmlAddID and xmlAddRef for namespace declarations, but it makes\n-     * no practical sense to use ID types anyway.\n-     *\/\n-#if 0\n-    \/* Validity Constraint: ID uniqueness *\/\n-    if (attrDecl->atype == XML_ATTRIBUTE_ID) {\n-        if (xmlAddID(ctxt, doc, value, (xmlAttrPtr) ns) == NULL)\n-        ret = 0;\n@@ -4521,7 +4520,0 @@\n-    if ((attrDecl->atype == XML_ATTRIBUTE_IDREF) ||\n-    (attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {\n-        if (xmlAddRef(ctxt, doc, value, (xmlAttrPtr) ns) == NULL)\n-        ret = 0;\n-    }\n-#endif\n-\n@@ -4534,3 +4526,3 @@\n-    nota = xmlGetDtdNotationDesc(doc->intSubset, value);\n-    if (nota == NULL)\n-        nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n+        nota = xmlGetDtdNotationDesc(doc->intSubset, value);\n+        if (nota == NULL)\n+            nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n@@ -4538,3 +4530,3 @@\n-    if (nota == NULL) {\n-        if (ns->prefix != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n+        if (nota == NULL) {\n+            if (ns->prefix != NULL) {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n@@ -4542,3 +4534,3 @@\n-               value, ns->prefix, elem->name);\n-        } else {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n+                       value, ns->prefix, elem->name);\n+            } else {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n@@ -4546,3 +4538,3 @@\n-               value, elem->name, NULL);\n-        }\n-        ret = 0;\n+                       value, elem->name, NULL);\n+            }\n+            ret = 0;\n@@ -4551,8 +4543,8 @@\n-    \/* Second, verify that it's among the list *\/\n-    while (tree != NULL) {\n-        if (xmlStrEqual(tree->name, value)) break;\n-        tree = tree->next;\n-    }\n-    if (tree == NULL) {\n-        if (ns->prefix != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n+        \/* Second, verify that it's among the list *\/\n+        while (tree != NULL) {\n+            if (xmlStrEqual(tree->name, value)) break;\n+            tree = tree->next;\n+        }\n+        if (tree == NULL) {\n+            if (ns->prefix != NULL) {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n@@ -4560,3 +4552,3 @@\n-               value, ns->prefix, elem->name);\n-        } else {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n+                       value, ns->prefix, elem->name);\n+            } else {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n@@ -4564,1 +4556,3 @@\n-               value, elem->name, NULL);\n+                       value, elem->name, NULL);\n+            }\n+            ret = 0;\n@@ -4566,2 +4560,0 @@\n-        ret = 0;\n-    }\n@@ -4573,7 +4565,7 @@\n-    while (tree != NULL) {\n-        if (xmlStrEqual(tree->name, value)) break;\n-        tree = tree->next;\n-    }\n-    if (tree == NULL) {\n-        if (ns->prefix != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n+        while (tree != NULL) {\n+            if (xmlStrEqual(tree->name, value)) break;\n+            tree = tree->next;\n+        }\n+        if (tree == NULL) {\n+            if (ns->prefix != NULL) {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n@@ -4581,3 +4573,3 @@\n-               value, ns->prefix, elem->name);\n-        } else {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n+                       value, ns->prefix, elem->name);\n+            } else {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n@@ -4585,1 +4577,3 @@\n-               value, elem->name, NULL);\n+                       value, elem->name, NULL);\n+            }\n+            ret = 0;\n@@ -4587,2 +4581,0 @@\n-        ret = 0;\n-    }\n@@ -4594,9 +4586,9 @@\n-    if (ns->prefix != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n-           \"Value for attribute xmlns:%s of %s must be \\\"%s\\\"\\n\",\n-           ns->prefix, elem->name, attrDecl->defaultValue);\n-    } else {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n-           \"Value for attribute xmlns of %s must be \\\"%s\\\"\\n\",\n-           elem->name, attrDecl->defaultValue, NULL);\n-    }\n+        if (ns->prefix != NULL) {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n+                   \"Value for attribute xmlns:%s of %s must be \\\"%s\\\"\\n\",\n+                   ns->prefix, elem->name, attrDecl->defaultValue);\n+        } else {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n+                   \"Value for attribute xmlns of %s must be \\\"%s\\\"\\n\",\n+                   elem->name, attrDecl->defaultValue, NULL);\n+        }\n@@ -4608,2 +4600,2 @@\n-    ret &= xmlValidateAttributeValue2(ctxt, doc, ns->prefix,\n-                      attrDecl->atype, value);\n+        ret &= xmlValidateAttributeValue2(ctxt, doc, ns->prefix,\n+                                          attrDecl->atype, value);\n@@ -4611,2 +4603,2 @@\n-    ret &= xmlValidateAttributeValue2(ctxt, doc, BAD_CAST \"xmlns\",\n-                      attrDecl->atype, value);\n+        ret &= xmlValidateAttributeValue2(ctxt, doc, BAD_CAST \"xmlns\",\n+                                          attrDecl->atype, value);\n@@ -4632,18 +4624,18 @@\n-    switch (child->type) {\n-        \/* These things are ignored (skipped) during validation.  *\/\n-        case XML_PI_NODE:\n-        case XML_COMMENT_NODE:\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        child = child->next;\n-        break;\n-        case XML_TEXT_NODE:\n-        if (xmlIsBlankNode(child))\n-            child = child->next;\n-        else\n-            return(child);\n-        break;\n-        \/* keep current node *\/\n-        default:\n-        return(child);\n-    }\n+        switch (child->type) {\n+            \/* These things are ignored (skipped) during validation.  *\/\n+            case XML_PI_NODE:\n+            case XML_COMMENT_NODE:\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+                child = child->next;\n+                break;\n+            case XML_TEXT_NODE:\n+                if (xmlIsBlankNode(child))\n+                    child = child->next;\n+                else\n+                    return(child);\n+                break;\n+            \/* keep current node *\/\n+            default:\n+                return(child);\n+        }\n@@ -4672,1 +4664,1 @@\n-    return(1);\n+        return(1);\n@@ -4674,3 +4666,3 @@\n-    ((CONT->ocur == XML_ELEMENT_CONTENT_MULT) ||\n-     (CONT->ocur == XML_ELEMENT_CONTENT_OPT))) {\n-    return(1);\n+        ((CONT->ocur == XML_ELEMENT_CONTENT_MULT) ||\n+         (CONT->ocur == XML_ELEMENT_CONTENT_OPT))) {\n+        return(1);\n@@ -4680,1 +4672,1 @@\n-    return(-2);\n+        return(-2);\n@@ -4692,2 +4684,2 @@\n-    ret = 1;\n-    goto analyze;\n+        ret = 1;\n+        goto analyze;\n@@ -4701,8 +4693,8 @@\n-    ((CONT->parent == NULL) ||\n-     (CONT->parent == (xmlElementContentPtr) 1) ||\n-     (CONT->parent->type != XML_ELEMENT_CONTENT_OR)) &&\n-    ((CONT->ocur == XML_ELEMENT_CONTENT_MULT) ||\n-     (CONT->ocur == XML_ELEMENT_CONTENT_OPT) ||\n-     ((CONT->ocur == XML_ELEMENT_CONTENT_PLUS) && (OCCURRENCE)))) {\n-    if (vstateVPush(ctxt, CONT, NODE, DEPTH, OCCURS, ROLLBACK_PARENT) < 0)\n-        return(0);\n+        ((CONT->parent == NULL) ||\n+         (CONT->parent == (xmlElementContentPtr) 1) ||\n+         (CONT->parent->type != XML_ELEMENT_CONTENT_OR)) &&\n+        ((CONT->ocur == XML_ELEMENT_CONTENT_MULT) ||\n+         (CONT->ocur == XML_ELEMENT_CONTENT_OPT) ||\n+         ((CONT->ocur == XML_ELEMENT_CONTENT_PLUS) && (OCCURRENCE)))) {\n+        if (vstateVPush(ctxt, CONT, NODE, DEPTH, OCCURS, ROLLBACK_PARENT) < 0)\n+            return(0);\n@@ -4716,20 +4708,20 @@\n-    case XML_ELEMENT_CONTENT_PCDATA:\n-        if (NODE == NULL) {\n-        ret = 0;\n-        break;\n-        }\n-        if (NODE->type == XML_TEXT_NODE) {\n-        \/*\n-         * go to next element in the content model\n-         * skipping ignorable elems\n-         *\/\n-        do {\n-            NODE = NODE->next;\n-            NODE = xmlValidateSkipIgnorable(NODE);\n-            if ((NODE != NULL) &&\n-            (NODE->type == XML_ENTITY_REF_NODE))\n-            return(-2);\n-        } while ((NODE != NULL) &&\n-             ((NODE->type != XML_ELEMENT_NODE) &&\n-              (NODE->type != XML_TEXT_NODE) &&\n-              (NODE->type != XML_CDATA_SECTION_NODE)));\n+        case XML_ELEMENT_CONTENT_PCDATA:\n+            if (NODE == NULL) {\n+                ret = 0;\n+                break;\n+            }\n+            if (NODE->type == XML_TEXT_NODE) {\n+                \/*\n+                 * go to next element in the content model\n+                 * skipping ignorable elems\n+                 *\/\n+                do {\n+                    NODE = NODE->next;\n+                    NODE = xmlValidateSkipIgnorable(NODE);\n+                    if ((NODE != NULL) &&\n+                        (NODE->type == XML_ENTITY_REF_NODE))\n+                        return(-2);\n+                } while ((NODE != NULL) &&\n+                         ((NODE->type != XML_ELEMENT_NODE) &&\n+                          (NODE->type != XML_TEXT_NODE) &&\n+                          (NODE->type != XML_CDATA_SECTION_NODE)));\n@@ -4737,66 +4729,66 @@\n-        break;\n-        } else {\n-        ret = 0;\n-        break;\n-        }\n-        break;\n-    case XML_ELEMENT_CONTENT_ELEMENT:\n-        if (NODE == NULL) {\n-        ret = 0;\n-        break;\n-        }\n-        ret = ((NODE->type == XML_ELEMENT_NODE) &&\n-           (xmlStrEqual(NODE->name, CONT->name)));\n-        if (ret == 1) {\n-        if ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n-            ret = (CONT->prefix == NULL);\n-        } else if (CONT->prefix == NULL) {\n-            ret = 0;\n-        } else {\n-            ret = xmlStrEqual(NODE->ns->prefix, CONT->prefix);\n-        }\n-        }\n-        if (ret == 1) {\n-        \/*\n-         * go to next element in the content model\n-         * skipping ignorable elems\n-         *\/\n-        do {\n-            NODE = NODE->next;\n-            NODE = xmlValidateSkipIgnorable(NODE);\n-            if ((NODE != NULL) &&\n-            (NODE->type == XML_ENTITY_REF_NODE))\n-            return(-2);\n-        } while ((NODE != NULL) &&\n-             ((NODE->type != XML_ELEMENT_NODE) &&\n-              (NODE->type != XML_TEXT_NODE) &&\n-              (NODE->type != XML_CDATA_SECTION_NODE)));\n-        } else {\n-        ret = 0;\n-        break;\n-        }\n-        break;\n-    case XML_ELEMENT_CONTENT_OR:\n-        \/*\n-         * Small optimization.\n-         *\/\n-        if (CONT->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {\n-        if ((NODE == NULL) ||\n-            (!xmlStrEqual(NODE->name, CONT->c1->name))) {\n-            DEPTH++;\n-            CONT = CONT->c2;\n-            goto cont;\n-        }\n-        if ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n-            ret = (CONT->c1->prefix == NULL);\n-        } else if (CONT->c1->prefix == NULL) {\n-            ret = 0;\n-        } else {\n-            ret = xmlStrEqual(NODE->ns->prefix, CONT->c1->prefix);\n-        }\n-        if (ret == 0) {\n-            DEPTH++;\n-            CONT = CONT->c2;\n-            goto cont;\n-        }\n-        }\n+                break;\n+            } else {\n+                ret = 0;\n+                break;\n+            }\n+            break;\n+        case XML_ELEMENT_CONTENT_ELEMENT:\n+            if (NODE == NULL) {\n+                ret = 0;\n+                break;\n+            }\n+            ret = ((NODE->type == XML_ELEMENT_NODE) &&\n+                   (xmlStrEqual(NODE->name, CONT->name)));\n+            if (ret == 1) {\n+                if ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n+                    ret = (CONT->prefix == NULL);\n+                } else if (CONT->prefix == NULL) {\n+                    ret = 0;\n+                } else {\n+                    ret = xmlStrEqual(NODE->ns->prefix, CONT->prefix);\n+                }\n+            }\n+            if (ret == 1) {\n+                \/*\n+                 * go to next element in the content model\n+                 * skipping ignorable elems\n+                 *\/\n+                do {\n+                    NODE = NODE->next;\n+                    NODE = xmlValidateSkipIgnorable(NODE);\n+                    if ((NODE != NULL) &&\n+                        (NODE->type == XML_ENTITY_REF_NODE))\n+                        return(-2);\n+                } while ((NODE != NULL) &&\n+                         ((NODE->type != XML_ELEMENT_NODE) &&\n+                          (NODE->type != XML_TEXT_NODE) &&\n+                          (NODE->type != XML_CDATA_SECTION_NODE)));\n+            } else {\n+                ret = 0;\n+                break;\n+            }\n+            break;\n+        case XML_ELEMENT_CONTENT_OR:\n+            \/*\n+             * Small optimization.\n+             *\/\n+            if (CONT->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {\n+                if ((NODE == NULL) ||\n+                    (!xmlStrEqual(NODE->name, CONT->c1->name))) {\n+                    DEPTH++;\n+                    CONT = CONT->c2;\n+                    goto cont;\n+                }\n+                if ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n+                    ret = (CONT->c1->prefix == NULL);\n+                } else if (CONT->c1->prefix == NULL) {\n+                    ret = 0;\n+                } else {\n+                    ret = xmlStrEqual(NODE->ns->prefix, CONT->c1->prefix);\n+                }\n+                if (ret == 0) {\n+                    DEPTH++;\n+                    CONT = CONT->c2;\n+                    goto cont;\n+                }\n+            }\n@@ -4804,18 +4796,6 @@\n-        \/*\n-         * save the second branch 'or' branch\n-         *\/\n-        if (vstateVPush(ctxt, CONT->c2, NODE, DEPTH + 1,\n-                OCCURS, ROLLBACK_OR) < 0)\n-        return(-1);\n-        DEPTH++;\n-        CONT = CONT->c1;\n-        goto cont;\n-    case XML_ELEMENT_CONTENT_SEQ:\n-        \/*\n-         * Small optimization.\n-         *\/\n-        if ((CONT->c1->type == XML_ELEMENT_CONTENT_ELEMENT) &&\n-        ((CONT->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n-         (CONT->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {\n-        if ((NODE == NULL) ||\n-            (!xmlStrEqual(NODE->name, CONT->c1->name))) {\n+            \/*\n+             * save the second branch 'or' branch\n+             *\/\n+            if (vstateVPush(ctxt, CONT->c2, NODE, DEPTH + 1,\n+                            OCCURS, ROLLBACK_OR) < 0)\n+                return(-1);\n@@ -4823,1 +4803,1 @@\n-            CONT = CONT->c2;\n+            CONT = CONT->c1;\n@@ -4825,9 +4805,26 @@\n-        }\n-        if ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n-            ret = (CONT->c1->prefix == NULL);\n-        } else if (CONT->c1->prefix == NULL) {\n-            ret = 0;\n-        } else {\n-            ret = xmlStrEqual(NODE->ns->prefix, CONT->c1->prefix);\n-        }\n-        if (ret == 0) {\n+        case XML_ELEMENT_CONTENT_SEQ:\n+            \/*\n+             * Small optimization.\n+             *\/\n+            if ((CONT->c1->type == XML_ELEMENT_CONTENT_ELEMENT) &&\n+                ((CONT->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n+                 (CONT->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {\n+                if ((NODE == NULL) ||\n+                    (!xmlStrEqual(NODE->name, CONT->c1->name))) {\n+                    DEPTH++;\n+                    CONT = CONT->c2;\n+                    goto cont;\n+                }\n+                if ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n+                    ret = (CONT->c1->prefix == NULL);\n+                } else if (CONT->c1->prefix == NULL) {\n+                    ret = 0;\n+                } else {\n+                    ret = xmlStrEqual(NODE->ns->prefix, CONT->c1->prefix);\n+                }\n+                if (ret == 0) {\n+                    DEPTH++;\n+                    CONT = CONT->c2;\n+                    goto cont;\n+                }\n+            }\n@@ -4835,1 +4832,1 @@\n-            CONT = CONT->c2;\n+            CONT = CONT->c1;\n@@ -4837,5 +4834,0 @@\n-        }\n-        }\n-        DEPTH++;\n-        CONT = CONT->c1;\n-        goto cont;\n@@ -4848,1 +4840,1 @@\n-    return(ret);\n+        return(ret);\n@@ -4852,7 +4844,7 @@\n-    \/*\n-     * First do the analysis depending on the occurrence model at\n-     * this level.\n-     *\/\n-    if (ret == 0) {\n-        switch (CONT->ocur) {\n-        xmlNodePtr cur;\n+        \/*\n+         * First do the analysis depending on the occurrence model at\n+         * this level.\n+         *\/\n+        if (ret == 0) {\n+            switch (CONT->ocur) {\n+                xmlNodePtr cur;\n@@ -4860,50 +4852,26 @@\n-        case XML_ELEMENT_CONTENT_ONCE:\n-            cur = ctxt->vstate->node;\n-            if (vstateVPop(ctxt) < 0 ) {\n-            return(0);\n-            }\n-            if (cur != ctxt->vstate->node)\n-            determinist = -3;\n-            goto cont;\n-        case XML_ELEMENT_CONTENT_PLUS:\n-            if (OCCURRENCE == 0) {\n-            cur = ctxt->vstate->node;\n-            if (vstateVPop(ctxt) < 0 ) {\n-                return(0);\n-            }\n-            if (cur != ctxt->vstate->node)\n-                determinist = -3;\n-            goto cont;\n-            }\n-            ret = 1;\n-            break;\n-        case XML_ELEMENT_CONTENT_MULT:\n-            ret = 1;\n-            break;\n-        case XML_ELEMENT_CONTENT_OPT:\n-            ret = 1;\n-            break;\n-        }\n-    } else {\n-        switch (CONT->ocur) {\n-        case XML_ELEMENT_CONTENT_OPT:\n-            ret = 1;\n-            break;\n-        case XML_ELEMENT_CONTENT_ONCE:\n-            ret = 1;\n-            break;\n-        case XML_ELEMENT_CONTENT_PLUS:\n-            if (STATE == ROLLBACK_PARENT) {\n-            ret = 1;\n-            break;\n-            }\n-            if (NODE == NULL) {\n-            ret = 1;\n-            break;\n-            }\n-            SET_OCCURRENCE;\n-            goto cont;\n-        case XML_ELEMENT_CONTENT_MULT:\n-            if (STATE == ROLLBACK_PARENT) {\n-            ret = 1;\n-            break;\n+                case XML_ELEMENT_CONTENT_ONCE:\n+                    cur = ctxt->vstate->node;\n+                    if (vstateVPop(ctxt) < 0 ) {\n+                        return(0);\n+                    }\n+                    if (cur != ctxt->vstate->node)\n+                        determinist = -3;\n+                    goto cont;\n+                case XML_ELEMENT_CONTENT_PLUS:\n+                    if (OCCURRENCE == 0) {\n+                        cur = ctxt->vstate->node;\n+                        if (vstateVPop(ctxt) < 0 ) {\n+                            return(0);\n+                        }\n+                        if (cur != ctxt->vstate->node)\n+                            determinist = -3;\n+                        goto cont;\n+                    }\n+                    ret = 1;\n+                    break;\n+                case XML_ELEMENT_CONTENT_MULT:\n+                    ret = 1;\n+                    break;\n+                case XML_ELEMENT_CONTENT_OPT:\n+                    ret = 1;\n+                    break;\n@@ -4911,3 +4879,30 @@\n-            if (NODE == NULL) {\n-            ret = 1;\n-            break;\n+        } else {\n+            switch (CONT->ocur) {\n+                case XML_ELEMENT_CONTENT_OPT:\n+                    ret = 1;\n+                    break;\n+                case XML_ELEMENT_CONTENT_ONCE:\n+                    ret = 1;\n+                    break;\n+                case XML_ELEMENT_CONTENT_PLUS:\n+                    if (STATE == ROLLBACK_PARENT) {\n+                        ret = 1;\n+                        break;\n+                    }\n+                    if (NODE == NULL) {\n+                        ret = 1;\n+                        break;\n+                    }\n+                    SET_OCCURRENCE;\n+                    goto cont;\n+                case XML_ELEMENT_CONTENT_MULT:\n+                    if (STATE == ROLLBACK_PARENT) {\n+                        ret = 1;\n+                        break;\n+                    }\n+                    if (NODE == NULL) {\n+                        ret = 1;\n+                        break;\n+                    }\n+                    \/* SET_OCCURRENCE; *\/\n+                    goto cont;\n@@ -4915,2 +4910,0 @@\n-            \/* SET_OCCURRENCE; *\/\n-            goto cont;\n@@ -4918,2 +4911,1 @@\n-    }\n-    STATE = 0;\n+        STATE = 0;\n@@ -4921,5 +4913,5 @@\n-    \/*\n-     * Then act accordingly at the parent level\n-     *\/\n-    RESET_OCCURRENCE;\n-    if ((CONT->parent == NULL) ||\n+        \/*\n+         * Then act accordingly at the parent level\n+         *\/\n+        RESET_OCCURRENCE;\n+        if ((CONT->parent == NULL) ||\n@@ -4927,1 +4919,1 @@\n-        break;\n+            break;\n@@ -4929,24 +4921,25 @@\n-    switch (CONT->parent->type) {\n-        case XML_ELEMENT_CONTENT_PCDATA:\n-        return(-1);\n-        case XML_ELEMENT_CONTENT_ELEMENT:\n-        return(-1);\n-        case XML_ELEMENT_CONTENT_OR:\n-        if (ret == 1) {\n-            CONT = CONT->parent;\n-            DEPTH--;\n-        } else {\n-            CONT = CONT->parent;\n-            DEPTH--;\n-        }\n-        break;\n-        case XML_ELEMENT_CONTENT_SEQ:\n-        if (ret == 0) {\n-            CONT = CONT->parent;\n-            DEPTH--;\n-        } else if (CONT == CONT->parent->c1) {\n-            CONT = CONT->parent->c2;\n-            goto cont;\n-        } else {\n-            CONT = CONT->parent;\n-            DEPTH--;\n+        switch (CONT->parent->type) {\n+            case XML_ELEMENT_CONTENT_PCDATA:\n+                return(-1);\n+            case XML_ELEMENT_CONTENT_ELEMENT:\n+                return(-1);\n+            case XML_ELEMENT_CONTENT_OR:\n+                if (ret == 1) {\n+                    CONT = CONT->parent;\n+                    DEPTH--;\n+                } else {\n+                    CONT = CONT->parent;\n+                    DEPTH--;\n+                }\n+                break;\n+            case XML_ELEMENT_CONTENT_SEQ:\n+                if (ret == 0) {\n+                    CONT = CONT->parent;\n+                    DEPTH--;\n+                } else if (CONT == CONT->parent->c1) {\n+                    CONT = CONT->parent->c2;\n+                    goto cont;\n+                } else {\n+                    CONT = CONT->parent;\n+                    DEPTH--;\n+                }\n@@ -4955,1 +4948,0 @@\n-    }\n@@ -4957,1 +4949,1 @@\n-    xmlNodePtr cur;\n+        xmlNodePtr cur;\n@@ -4959,7 +4951,7 @@\n-    cur = ctxt->vstate->node;\n-    if (vstateVPop(ctxt) < 0 ) {\n-        return(0);\n-    }\n-    if (cur != ctxt->vstate->node)\n-        determinist = -3;\n-    goto cont;\n+        cur = ctxt->vstate->node;\n+        if (vstateVPop(ctxt) < 0 ) {\n+            return(0);\n+        }\n+        if (cur != ctxt->vstate->node)\n+            determinist = -3;\n+        goto cont;\n@@ -4968,1 +4960,1 @@\n-    xmlNodePtr cur;\n+        xmlNodePtr cur;\n@@ -4970,7 +4962,7 @@\n-    cur = ctxt->vstate->node;\n-    if (vstateVPop(ctxt) < 0 ) {\n-        return(0);\n-    }\n-    if (cur != ctxt->vstate->node)\n-        determinist = -3;\n-    goto cont;\n+        cur = ctxt->vstate->node;\n+        if (vstateVPop(ctxt) < 0 ) {\n+            return(0);\n+        }\n+        if (cur != ctxt->vstate->node)\n+            determinist = -3;\n+        goto cont;\n@@ -5001,6 +4993,6 @@\n-    len = strlen(buf);\n-    if (size - len < 50) {\n-        if ((size - len > 4) && (buf[len - 1] != '.'))\n-        strcat(buf, \" ...\");\n-        return;\n-    }\n+        len = strlen(buf);\n+        if (size - len < 50) {\n+            if ((size - len > 4) && (buf[len - 1] != '.'))\n+                strcat(buf, \" ...\");\n+            return;\n+        }\n@@ -5018,4 +5010,4 @@\n-        if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n-            strcat(buf, (char *) cur->ns->prefix);\n-            strcat(buf, \":\");\n-        }\n+                if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n+                    strcat(buf, (char *) cur->ns->prefix);\n+                    strcat(buf, \":\");\n+                }\n@@ -5023,4 +5015,4 @@\n-                strcat(buf, (char *) cur->name);\n-        if (cur->next != NULL)\n-            strcat(buf, \" \");\n-        break;\n+                    strcat(buf, (char *) cur->name);\n+                if (cur->next != NULL)\n+                    strcat(buf, \" \");\n+                break;\n@@ -5029,2 +5021,2 @@\n-        if (xmlIsBlankNode(cur))\n-            break;\n+                if (xmlIsBlankNode(cur))\n+                    break;\n@@ -5034,4 +5026,4 @@\n-            strcat(buf, \"CDATA\");\n-        if (cur->next != NULL)\n-            strcat(buf, \" \");\n-        break;\n+                strcat(buf, \"CDATA\");\n+                if (cur->next != NULL)\n+                    strcat(buf, \" \");\n+                break;\n@@ -5040,1 +5032,1 @@\n-        case XML_HTML_DOCUMENT_NODE:\n+            case XML_HTML_DOCUMENT_NODE:\n@@ -5044,5 +5036,5 @@\n-        case XML_NAMESPACE_DECL:\n-            strcat(buf, \"???\");\n-        if (cur->next != NULL)\n-            strcat(buf, \" \");\n-        break;\n+            case XML_NAMESPACE_DECL:\n+                strcat(buf, \"???\");\n+                if (cur->next != NULL)\n+                    strcat(buf, \" \");\n+                break;\n@@ -5053,8 +5045,8 @@\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_ENTITY_DECL:\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        break;\n-    }\n-    cur = cur->next;\n+            case XML_ELEMENT_DECL:\n+            case XML_ATTRIBUTE_DECL:\n+            case XML_ENTITY_DECL:\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+                break;\n+        }\n+        cur = cur->next;\n@@ -5090,1 +5082,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5097,1 +5089,1 @@\n-    ret = xmlValidBuildContentModel(ctxt, elemDecl);\n+        ret = xmlValidBuildContentModel(ctxt, elemDecl);\n@@ -5099,1 +5091,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5101,1 +5093,1 @@\n-    xmlRegExecCtxtPtr exec;\n+        xmlRegExecCtxtPtr exec;\n@@ -5103,8 +5095,8 @@\n-    if (!xmlRegexpIsDeterminist(elemDecl->contModel)) {\n-        return(-1);\n-    }\n-    ctxt->nodeMax = 0;\n-    ctxt->nodeNr = 0;\n-    ctxt->nodeTab = NULL;\n-    exec = xmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);\n-    if (exec == NULL) {\n+        if (!xmlRegexpIsDeterminist(elemDecl->contModel)) {\n+            return(-1);\n+        }\n+        ctxt->nodeMax = 0;\n+        ctxt->nodeNr = 0;\n+        ctxt->nodeTab = NULL;\n+        exec = xmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);\n+        if (exec == NULL) {\n@@ -5124,1 +5116,4 @@\n-                        nodeVPush(ctxt, cur);\n+                        if (nodeVPush(ctxt, cur) < 0) {\n+                            ret = -1;\n+                            goto fail;\n+                        }\n@@ -5183,0 +5178,1 @@\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n@@ -5184,2 +5180,4 @@\n-    ctxt->vstateTab = (xmlValidState *) xmlMalloc(\n-         ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n+#else\n+    ctxt->vstateMax = 1;\n+#endif\n+    ctxt->vstateTab = xmlMalloc(ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n@@ -5187,2 +5185,2 @@\n-    xmlVErrMemory(ctxt);\n-    return(-1);\n+        xmlVErrMemory(ctxt);\n+        return(-1);\n@@ -5205,4 +5203,4 @@\n-    char expr[5000];\n-    expr[0] = 0;\n-    xmlSnprintfElementContent(expr, 5000, elemDecl->content, 1);\n-    xmlErrValidNode(ctxt, (xmlNodePtr) elemDecl,\n+        char expr[5000];\n+        expr[0] = 0;\n+        xmlSnprintfElementContent(expr, 5000, elemDecl->content, 1);\n+        xmlErrValidNode(ctxt, (xmlNodePtr) elemDecl,\n@@ -5210,2 +5208,2 @@\n-            \"Content model of %s is not deterministic: %s\\n\",\n-            name, BAD_CAST expr, NULL);\n+                \"Content model of %s is not deterministic: %s\\n\",\n+                name, BAD_CAST expr, NULL);\n@@ -5213,48 +5211,62 @@\n-    \/*\n-     * An entities reference appeared at this level.\n-     * Build a minimal representation of this node content\n-     * sufficient to run the validation process on it\n-     *\/\n-    cur = child;\n-    while (cur != NULL) {\n-        switch (cur->type) {\n-        case XML_ENTITY_REF_NODE:\n-            \/*\n-             * Push the current node to be able to roll back\n-             * and process within the entity\n-             *\/\n-            if ((cur->children != NULL) &&\n-            (cur->children->children != NULL)) {\n-            nodeVPush(ctxt, cur);\n-            cur = cur->children->children;\n-            continue;\n-            }\n-            break;\n-        case XML_TEXT_NODE:\n-            if (xmlIsBlankNode(cur))\n-            break;\n-            \/* no break on purpose *\/\n-        case XML_CDATA_SECTION_NODE:\n-            \/* no break on purpose *\/\n-        case XML_ELEMENT_NODE:\n-            \/*\n-             * Allocate a new node and minimally fills in\n-             * what's required\n-             *\/\n-            tmp = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n-            if (tmp == NULL) {\n-            xmlVErrMemory(ctxt);\n-            xmlFreeNodeList(repl);\n-            ret = -1;\n-            goto done;\n-            }\n-            tmp->type = cur->type;\n-            tmp->name = cur->name;\n-            tmp->ns = cur->ns;\n-            tmp->next = NULL;\n-            tmp->content = NULL;\n-            if (repl == NULL)\n-            repl = last = tmp;\n-            else {\n-            last->next = tmp;\n-            last = tmp;\n+        \/*\n+         * An entities reference appeared at this level.\n+         * Build a minimal representation of this node content\n+         * sufficient to run the validation process on it\n+         *\/\n+        cur = child;\n+        while (cur != NULL) {\n+            switch (cur->type) {\n+                case XML_ENTITY_REF_NODE:\n+                    \/*\n+                     * Push the current node to be able to roll back\n+                     * and process within the entity\n+                     *\/\n+                    if ((cur->children != NULL) &&\n+                        (cur->children->children != NULL)) {\n+                        if (nodeVPush(ctxt, cur) < 0) {\n+                            xmlFreeNodeList(repl);\n+                            ret = -1;\n+                            goto done;\n+                        }\n+                        cur = cur->children->children;\n+                        continue;\n+                    }\n+                    break;\n+                case XML_TEXT_NODE:\n+                    if (xmlIsBlankNode(cur))\n+                        break;\n+                    \/* falls through *\/\n+                case XML_CDATA_SECTION_NODE:\n+                case XML_ELEMENT_NODE:\n+                    \/*\n+                     * Allocate a new node and minimally fills in\n+                     * what's required\n+                     *\/\n+                    tmp = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n+                    if (tmp == NULL) {\n+                        xmlVErrMemory(ctxt);\n+                        xmlFreeNodeList(repl);\n+                        ret = -1;\n+                        goto done;\n+                    }\n+                    tmp->type = cur->type;\n+                    tmp->name = cur->name;\n+                    tmp->ns = cur->ns;\n+                    tmp->next = NULL;\n+                    tmp->content = NULL;\n+                    if (repl == NULL)\n+                        repl = last = tmp;\n+                    else {\n+                        last->next = tmp;\n+                        last = tmp;\n+                    }\n+                    if (cur->type == XML_CDATA_SECTION_NODE) {\n+                        \/*\n+                         * E59 spaces in CDATA does not match the\n+                         * nonterminal S\n+                         *\/\n+                        tmp->content = xmlStrdup(BAD_CAST \"CDATA\");\n+                    }\n+                    break;\n+                default:\n+                    break;\n@@ -5262,1 +5274,0 @@\n-            if (cur->type == XML_CDATA_SECTION_NODE) {\n@@ -5264,2 +5275,1 @@\n-             * E59 spaces in CDATA does not match the\n-             * nonterminal S\n+             * Switch to next element\n@@ -5267,29 +5277,20 @@\n-            tmp->content = xmlStrdup(BAD_CAST \"CDATA\");\n-            }\n-            break;\n-        default:\n-            break;\n-        }\n-        \/*\n-         * Switch to next element\n-         *\/\n-        cur = cur->next;\n-        while (cur == NULL) {\n-        cur = nodeVPop(ctxt);\n-        if (cur == NULL)\n-            break;\n-        cur = cur->next;\n-        }\n-    }\n-\n-    \/*\n-     * Relaunch the validation\n-     *\/\n-    ctxt->vstate = &ctxt->vstateTab[0];\n-    ctxt->vstateNr = 1;\n-    CONT = cont;\n-    NODE = repl;\n-    DEPTH = 0;\n-    OCCURS = 0;\n-    STATE = 0;\n-    ret = xmlValidateElementType(ctxt);\n+            cur = cur->next;\n+            while (cur == NULL) {\n+                cur = nodeVPop(ctxt);\n+                if (cur == NULL)\n+                    break;\n+                cur = cur->next;\n+            }\n+        }\n+\n+        \/*\n+         * Relaunch the validation\n+         *\/\n+        ctxt->vstate = &ctxt->vstateTab[0];\n+        ctxt->vstateNr = 1;\n+        CONT = cont;\n+        NODE = repl;\n+        DEPTH = 0;\n+        OCCURS = 0;\n+        STATE = 0;\n+        ret = xmlValidateElementType(ctxt);\n@@ -5299,3 +5300,3 @@\n-    if (ctxt != NULL) {\n-        char expr[5000];\n-        char list[5000];\n+        if (ctxt != NULL) {\n+            char expr[5000];\n+            char list[5000];\n@@ -5303,3 +5304,3 @@\n-        expr[0] = 0;\n-        xmlSnprintfElementContent(&expr[0], 5000, cont, 1);\n-        list[0] = 0;\n+            expr[0] = 0;\n+            xmlSnprintfElementContent(&expr[0], 5000, cont, 1);\n+            list[0] = 0;\n@@ -5307,3 +5308,3 @@\n-        if (repl != NULL)\n-        xmlSnprintfElements(&list[0], 5000, repl, 1);\n-        else\n+            if (repl != NULL)\n+                xmlSnprintfElements(&list[0], 5000, repl, 1);\n+            else\n@@ -5311,1 +5312,1 @@\n-        xmlSnprintfElements(&list[0], 5000, child, 1);\n+                xmlSnprintfElements(&list[0], 5000, child, 1);\n@@ -5313,14 +5314,9 @@\n-        if (name != NULL) {\n-        xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n-       \"Element %s content does not follow the DTD, expecting %s, got %s\\n\",\n-               name, BAD_CAST expr, BAD_CAST list);\n-        } else {\n-        xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n-       \"Element content does not follow the DTD, expecting %s, got %s\\n\",\n-               BAD_CAST expr, BAD_CAST list, NULL);\n-        }\n-    } else {\n-        if (name != NULL) {\n-        xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n-               \"Element %s content does not follow the DTD\\n\",\n-               name, NULL, NULL);\n+            if (name != NULL) {\n+                xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n+           \"Element %s content does not follow the DTD, expecting %s, got %s\\n\",\n+                       name, BAD_CAST expr, BAD_CAST list);\n+            } else {\n+                xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n+           \"Element content does not follow the DTD, expecting %s, got %s\\n\",\n+                       BAD_CAST expr, BAD_CAST list, NULL);\n+            }\n@@ -5328,3 +5324,9 @@\n-        xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n-               \"Element content does not follow the DTD\\n\",\n-                        NULL, NULL, NULL);\n+            if (name != NULL) {\n+                xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n+                       \"Element %s content does not follow the DTD\\n\",\n+                       name, NULL, NULL);\n+            } else {\n+                xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n+                       \"Element content does not follow the DTD\\n\",\n+                                NULL, NULL, NULL);\n+            }\n@@ -5332,2 +5334,1 @@\n-    }\n-    ret = 0;\n+        ret = 0;\n@@ -5336,1 +5337,1 @@\n-    ret = 1;\n+        ret = 1;\n@@ -5344,3 +5345,3 @@\n-    tmp = repl->next;\n-    xmlFree(repl);\n-    repl = tmp;\n+        tmp = repl->next;\n+        xmlFree(repl);\n+        repl = tmp;\n@@ -5350,2 +5351,2 @@\n-    xmlFree(ctxt->vstateTab);\n-    ctxt->vstateTab = NULL;\n+        xmlFree(ctxt->vstateTab);\n+        ctxt->vstateTab = NULL;\n@@ -5357,2 +5358,2 @@\n-    xmlFree(ctxt->nodeTab);\n-    ctxt->nodeTab = NULL;\n+        xmlFree(ctxt->nodeTab);\n+        ctxt->nodeTab = NULL;\n@@ -5382,1 +5383,1 @@\n-    return(0);\n+        return(0);\n@@ -5388,2 +5389,25 @@\n-    switch (cur->type) {\n-        case XML_ENTITY_REF_NODE:\n+        switch (cur->type) {\n+            case XML_ENTITY_REF_NODE:\n+                \/*\n+                 * Push the current node to be able to roll back\n+                 * and process within the entity\n+                 *\/\n+                if ((cur->children != NULL) &&\n+                    (cur->children->children != NULL)) {\n+                    if (nodeVPush(ctxt, cur) < 0) {\n+                        ret = 0;\n+                        goto done;\n+                    }\n+                    cur = cur->children->children;\n+                    continue;\n+                }\n+                break;\n+            case XML_COMMENT_NODE:\n+            case XML_PI_NODE:\n+            case XML_TEXT_NODE:\n+            case XML_CDATA_SECTION_NODE:\n+                break;\n+            default:\n+                ret = 0;\n+                goto done;\n+        }\n@@ -5391,2 +5415,1 @@\n-         * Push the current node to be able to roll back\n-         * and process within the entity\n+         * Switch to next element\n@@ -5394,24 +5417,0 @@\n-        if ((cur->children != NULL) &&\n-            (cur->children->children != NULL)) {\n-            nodeVPush(ctxt, cur);\n-            cur = cur->children->children;\n-            continue;\n-        }\n-        break;\n-        case XML_COMMENT_NODE:\n-        case XML_PI_NODE:\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        break;\n-        default:\n-        ret = 0;\n-        goto done;\n-    }\n-    \/*\n-     * Switch to next element\n-     *\/\n-    cur = cur->next;\n-    while (cur == NULL) {\n-        cur = nodeVPop(ctxt);\n-        if (cur == NULL)\n-        break;\n@@ -5419,1 +5418,6 @@\n-    }\n+        while (cur == NULL) {\n+            cur = nodeVPop(ctxt);\n+            if (cur == NULL)\n+                break;\n+            cur = cur->next;\n+        }\n@@ -5425,2 +5429,2 @@\n-    xmlFree(ctxt->nodeTab);\n-    ctxt->nodeTab = NULL;\n+        xmlFree(ctxt->nodeTab);\n+        ctxt->nodeTab = NULL;\n@@ -5444,1 +5448,1 @@\n-                  xmlElementContentPtr cont, const xmlChar *qname) {\n+                      xmlElementContentPtr cont, const xmlChar *qname) {\n@@ -5450,17 +5454,19 @@\n-    while (cont != NULL) {\n-        if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n-        if ((cont->prefix == NULL) && (xmlStrEqual(cont->name, qname)))\n-            return(1);\n-        } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n-           (cont->c1 != NULL) &&\n-           (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n-        if ((cont->c1->prefix == NULL) &&\n-            (xmlStrEqual(cont->c1->name, qname)))\n-            return(1);\n-        } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n-        (cont->c1 == NULL) ||\n-        (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n-        xmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,\n-            \"Internal: MIXED struct corrupted\\n\",\n-            NULL);\n-        break;\n+        while (cont != NULL) {\n+            if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n+                if ((cont->prefix == NULL) && (xmlStrEqual(cont->name, qname)))\n+                    return(1);\n+            } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n+               (cont->c1 != NULL) &&\n+               (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n+                if ((cont->c1->prefix == NULL) &&\n+                    (xmlStrEqual(cont->c1->name, qname)))\n+                    return(1);\n+            } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n+                (cont->c1 == NULL) ||\n+                (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n+                xmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,\n+                        \"Internal: MIXED struct corrupted\\n\",\n+                        NULL);\n+                break;\n+            }\n+            cont = cont->c2;\n@@ -5468,2 +5474,0 @@\n-        cont = cont->c2;\n-    }\n@@ -5471,20 +5475,22 @@\n-    while (cont != NULL) {\n-        if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n-        if ((cont->prefix != NULL) &&\n-            (xmlStrncmp(cont->prefix, qname, plen) == 0) &&\n-            (xmlStrEqual(cont->name, name)))\n-            return(1);\n-        } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n-           (cont->c1 != NULL) &&\n-           (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n-        if ((cont->c1->prefix != NULL) &&\n-            (xmlStrncmp(cont->c1->prefix, qname, plen) == 0) &&\n-            (xmlStrEqual(cont->c1->name, name)))\n-            return(1);\n-        } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n-        (cont->c1 == NULL) ||\n-        (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n-        xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,\n-            \"Internal: MIXED struct corrupted\\n\",\n-            NULL);\n-        break;\n+        while (cont != NULL) {\n+            if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n+                if ((cont->prefix != NULL) &&\n+                    (xmlStrncmp(cont->prefix, qname, plen) == 0) &&\n+                    (xmlStrEqual(cont->name, name)))\n+                    return(1);\n+            } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n+               (cont->c1 != NULL) &&\n+               (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n+                if ((cont->c1->prefix != NULL) &&\n+                    (xmlStrncmp(cont->c1->prefix, qname, plen) == 0) &&\n+                    (xmlStrEqual(cont->c1->name, name)))\n+                    return(1);\n+            } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n+                (cont->c1 == NULL) ||\n+                (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n+                xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,\n+                        \"Internal: MIXED struct corrupted\\n\",\n+                        NULL);\n+                break;\n+            }\n+            cont = cont->c2;\n@@ -5492,2 +5498,0 @@\n-        cont = cont->c2;\n-    }\n@@ -5513,1 +5517,1 @@\n-                xmlNodePtr elem, int *extsubset) {\n+                    xmlNodePtr elem, int *extsubset) {\n@@ -5521,1 +5525,1 @@\n-    *extsubset = 0;\n+        *extsubset = 0;\n@@ -5527,1 +5531,1 @@\n-    prefix = elem->ns->prefix;\n+        prefix = elem->ns->prefix;\n@@ -5530,8 +5534,8 @@\n-    elemDecl = xmlGetDtdQElementDesc(doc->intSubset,\n-                                 elem->name, prefix);\n-    if ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n-        elemDecl = xmlGetDtdQElementDesc(doc->extSubset,\n-                                     elem->name, prefix);\n-        if ((elemDecl != NULL) && (extsubset != NULL))\n-        *extsubset = 1;\n-    }\n+        elemDecl = xmlGetDtdQElementDesc(doc->intSubset,\n+                                         elem->name, prefix);\n+        if ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n+            elemDecl = xmlGetDtdQElementDesc(doc->extSubset,\n+                                             elem->name, prefix);\n+            if ((elemDecl != NULL) && (extsubset != NULL))\n+                *extsubset = 1;\n+        }\n@@ -5546,6 +5550,6 @@\n-    elemDecl = xmlGetDtdQElementDesc(doc->intSubset, elem->name, NULL);\n-    if ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n-        elemDecl = xmlGetDtdQElementDesc(doc->extSubset, elem->name, NULL);\n-        if ((elemDecl != NULL) && (extsubset != NULL))\n-        *extsubset = 1;\n-    }\n+        elemDecl = xmlGetDtdQElementDesc(doc->intSubset, elem->name, NULL);\n+        if ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n+            elemDecl = xmlGetDtdQElementDesc(doc->extSubset, elem->name, NULL);\n+            if ((elemDecl != NULL) && (extsubset != NULL))\n+                *extsubset = 1;\n+        }\n@@ -5554,4 +5558,4 @@\n-    xmlErrValidNode(ctxt, elem,\n-            XML_DTD_UNKNOWN_ELEM,\n-           \"No declaration for element %s\\n\",\n-           elem->name, NULL, NULL);\n+        xmlErrValidNode(ctxt, elem,\n+                        XML_DTD_UNKNOWN_ELEM,\n+               \"No declaration for element %s\\n\",\n+               elem->name, NULL, NULL);\n@@ -5585,1 +5589,1 @@\n-\/* printf(\"PushElem %s\\n\", qname); *\/\n+\n@@ -5587,2 +5591,2 @@\n-    xmlValidStatePtr state = ctxt->vstate;\n-    xmlElementPtr elemDecl;\n+        xmlValidStatePtr state = ctxt->vstate;\n+        xmlElementPtr elemDecl;\n@@ -5590,5 +5594,5 @@\n-    \/*\n-     * Check the new element against the content model of the new elem.\n-     *\/\n-    if (state->elemDecl != NULL) {\n-        elemDecl = state->elemDecl;\n+        \/*\n+         * Check the new element against the content model of the new elem.\n+         *\/\n+        if (state->elemDecl != NULL) {\n+            elemDecl = state->elemDecl;\n@@ -5596,44 +5600,44 @@\n-        switch(elemDecl->etype) {\n-        case XML_ELEMENT_TYPE_UNDEFINED:\n-            ret = 0;\n-            break;\n-        case XML_ELEMENT_TYPE_EMPTY:\n-            xmlErrValidNode(ctxt, state->node,\n-                    XML_DTD_NOT_EMPTY,\n-           \"Element %s was declared EMPTY this one has content\\n\",\n-               state->node->name, NULL, NULL);\n-            ret = 0;\n-            break;\n-        case XML_ELEMENT_TYPE_ANY:\n-            \/* I don't think anything is required then *\/\n-            break;\n-        case XML_ELEMENT_TYPE_MIXED:\n-            \/* simple case of declared as #PCDATA *\/\n-            if ((elemDecl->content != NULL) &&\n-            (elemDecl->content->type ==\n-             XML_ELEMENT_CONTENT_PCDATA)) {\n-            xmlErrValidNode(ctxt, state->node,\n-                    XML_DTD_NOT_PCDATA,\n-           \"Element %s was declared #PCDATA but contains non text nodes\\n\",\n-                state->node->name, NULL, NULL);\n-            ret = 0;\n-            } else {\n-            ret = xmlValidateCheckMixed(ctxt, elemDecl->content,\n-                                    qname);\n-            if (ret != 1) {\n-                xmlErrValidNode(ctxt, state->node,\n-                        XML_DTD_INVALID_CHILD,\n-           \"Element %s is not declared in %s list of possible children\\n\",\n-                    qname, state->node->name, NULL);\n-            }\n-            }\n-            break;\n-        case XML_ELEMENT_TYPE_ELEMENT:\n-            \/*\n-             * TODO:\n-             * VC: Standalone Document Declaration\n-             *     - element types with element content, if white space\n-             *       occurs directly within any instance of those types.\n-             *\/\n-            if (state->exec != NULL) {\n-            ret = xmlRegExecPushString(state->exec, qname, NULL);\n+            switch(elemDecl->etype) {\n+                case XML_ELEMENT_TYPE_UNDEFINED:\n+                    ret = 0;\n+                    break;\n+                case XML_ELEMENT_TYPE_EMPTY:\n+                    xmlErrValidNode(ctxt, state->node,\n+                                    XML_DTD_NOT_EMPTY,\n+               \"Element %s was declared EMPTY this one has content\\n\",\n+                           state->node->name, NULL, NULL);\n+                    ret = 0;\n+                    break;\n+                case XML_ELEMENT_TYPE_ANY:\n+                    \/* I don't think anything is required then *\/\n+                    break;\n+                case XML_ELEMENT_TYPE_MIXED:\n+                    \/* simple case of declared as #PCDATA *\/\n+                    if ((elemDecl->content != NULL) &&\n+                        (elemDecl->content->type ==\n+                         XML_ELEMENT_CONTENT_PCDATA)) {\n+                        xmlErrValidNode(ctxt, state->node,\n+                                        XML_DTD_NOT_PCDATA,\n+               \"Element %s was declared #PCDATA but contains non text nodes\\n\",\n+                                state->node->name, NULL, NULL);\n+                        ret = 0;\n+                    } else {\n+                        ret = xmlValidateCheckMixed(ctxt, elemDecl->content,\n+                                                    qname);\n+                        if (ret != 1) {\n+                            xmlErrValidNode(ctxt, state->node,\n+                                            XML_DTD_INVALID_CHILD,\n+               \"Element %s is not declared in %s list of possible children\\n\",\n+                                    qname, state->node->name, NULL);\n+                        }\n+                    }\n+                    break;\n+                case XML_ELEMENT_TYPE_ELEMENT:\n+                    \/*\n+                     * TODO:\n+                     * VC: Standalone Document Declaration\n+                     *     - element types with element content, if white space\n+                     *       occurs directly within any instance of those types.\n+                     *\/\n+                    if (state->exec != NULL) {\n+                        ret = xmlRegExecPushString(state->exec, qname, NULL);\n@@ -5644,9 +5648,11 @@\n-            if (ret < 0) {\n-                xmlErrValidNode(ctxt, state->node,\n-                        XML_DTD_CONTENT_MODEL,\n-           \"Element %s content does not follow the DTD, Misplaced %s\\n\",\n-                   state->node->name, qname, NULL);\n-                ret = 0;\n-            } else {\n-                ret = 1;\n-            }\n+                        if (ret < 0) {\n+                            xmlErrValidNode(ctxt, state->node,\n+                                            XML_DTD_CONTENT_MODEL,\n+               \"Element %s content does not follow the DTD, Misplaced %s\\n\",\n+                                   state->node->name, qname, NULL);\n+                            ret = 0;\n+                        } else {\n+                            ret = 1;\n+                        }\n+                    }\n+                    break;\n@@ -5654,1 +5660,0 @@\n-            break;\n@@ -5657,1 +5662,0 @@\n-    }\n@@ -5679,1 +5683,0 @@\n-\/* printf(\"CDATA %s %d\\n\", data, len); *\/\n@@ -5683,1 +5686,1 @@\n-    return(ret);\n+        return(ret);\n@@ -5685,2 +5688,2 @@\n-    xmlValidStatePtr state = ctxt->vstate;\n-    xmlElementPtr elemDecl;\n+        xmlValidStatePtr state = ctxt->vstate;\n+        xmlElementPtr elemDecl;\n@@ -5688,5 +5691,5 @@\n-    \/*\n-     * Check the new element against the content model of the new elem.\n-     *\/\n-    if (state->elemDecl != NULL) {\n-        elemDecl = state->elemDecl;\n+        \/*\n+         * Check the new element against the content model of the new elem.\n+         *\/\n+        if (state->elemDecl != NULL) {\n+            elemDecl = state->elemDecl;\n@@ -5694,16 +5697,16 @@\n-        switch(elemDecl->etype) {\n-        case XML_ELEMENT_TYPE_UNDEFINED:\n-            ret = 0;\n-            break;\n-        case XML_ELEMENT_TYPE_EMPTY:\n-            xmlErrValidNode(ctxt, state->node,\n-                    XML_DTD_NOT_EMPTY,\n-           \"Element %s was declared EMPTY this one has content\\n\",\n-               state->node->name, NULL, NULL);\n-            ret = 0;\n-            break;\n-        case XML_ELEMENT_TYPE_ANY:\n-            break;\n-        case XML_ELEMENT_TYPE_MIXED:\n-            break;\n-        case XML_ELEMENT_TYPE_ELEMENT: {\n+            switch(elemDecl->etype) {\n+                case XML_ELEMENT_TYPE_UNDEFINED:\n+                    ret = 0;\n+                    break;\n+                case XML_ELEMENT_TYPE_EMPTY:\n+                    xmlErrValidNode(ctxt, state->node,\n+                                    XML_DTD_NOT_EMPTY,\n+               \"Element %s was declared EMPTY this one has content\\n\",\n+                           state->node->name, NULL, NULL);\n+                    ret = 0;\n+                    break;\n+                case XML_ELEMENT_TYPE_ANY:\n+                    break;\n+                case XML_ELEMENT_TYPE_MIXED:\n+                    break;\n+                case XML_ELEMENT_TYPE_ELEMENT: {\n@@ -5730,0 +5733,1 @@\n+            }\n@@ -5732,1 +5736,0 @@\n-    }\n@@ -5753,1 +5756,1 @@\n-              const xmlChar *qname ATTRIBUTE_UNUSED) {\n+                      const xmlChar *qname ATTRIBUTE_UNUSED) {\n@@ -5758,1 +5761,1 @@\n-\/* printf(\"PopElem %s\\n\", qname); *\/\n+\n@@ -5760,2 +5763,2 @@\n-    xmlValidStatePtr state = ctxt->vstate;\n-    xmlElementPtr elemDecl;\n+        xmlValidStatePtr state = ctxt->vstate;\n+        xmlElementPtr elemDecl;\n@@ -5763,5 +5766,5 @@\n-    \/*\n-     * Check the new element against the content model of the new elem.\n-     *\/\n-    if (state->elemDecl != NULL) {\n-        elemDecl = state->elemDecl;\n+        \/*\n+         * Check the new element against the content model of the new elem.\n+         *\/\n+        if (state->elemDecl != NULL) {\n+            elemDecl = state->elemDecl;\n@@ -5769,4 +5772,4 @@\n-        if (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT) {\n-        if (state->exec != NULL) {\n-            ret = xmlRegExecPushString(state->exec, NULL, NULL);\n-            if (ret <= 0) {\n+            if (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT) {\n+                if (state->exec != NULL) {\n+                    ret = xmlRegExecPushString(state->exec, NULL, NULL);\n+                    if (ret <= 0) {\n@@ -5776,11 +5779,13 @@\n-                xmlErrValidNode(ctxt, state->node,\n-                                XML_DTD_CONTENT_MODEL,\n-       \"Element %s content does not follow the DTD, Expecting more children\\n\",\n-                   state->node->name, NULL,NULL);\n-            ret = 0;\n-            } else {\n-            \/*\n-             * previous validation errors should not generate\n-             * a new one here\n-             *\/\n-            ret = 1;\n+                            xmlErrValidNode(ctxt, state->node,\n+                                            XML_DTD_CONTENT_MODEL,\n+           \"Element %s content does not follow the DTD, Expecting more children\\n\",\n+                               state->node->name, NULL,NULL);\n+                        ret = 0;\n+                    } else {\n+                        \/*\n+                         * previous validation errors should not generate\n+                         * a new one here\n+                         *\/\n+                        ret = 1;\n+                    }\n+                }\n@@ -5789,3 +5794,1 @@\n-        }\n-    }\n-    vstateVPop(ctxt);\n+        vstateVPop(ctxt);\n@@ -5839,1 +5842,1 @@\n-        return(1);\n+            return(1);\n@@ -5841,5 +5844,5 @@\n-        break;\n-    default:\n-        xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n-           \"unexpected element type\\n\", NULL, NULL ,NULL);\n-        return(0);\n+            break;\n+        default:\n+            xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n+                   \"unexpected element type\\n\", NULL, NULL ,NULL);\n+            return(0);\n@@ -5853,1 +5856,1 @@\n-    return(0);\n+        return(0);\n@@ -5863,8 +5866,2 @@\n-        xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ELEM,\n-                        \"No declaration for element %s\\n\",\n-           elem->name, NULL, NULL);\n-        return(0);\n-        case XML_ELEMENT_TYPE_EMPTY:\n-        if (elem->children != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_NOT_EMPTY,\n-           \"Element %s was declared EMPTY this one has content\\n\",\n+            xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ELEM,\n+                            \"No declaration for element %s\\n\",\n@@ -5872,3 +5869,9 @@\n-        ret = 0;\n-        }\n-        break;\n+            return(0);\n+        case XML_ELEMENT_TYPE_EMPTY:\n+            if (elem->children != NULL) {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_NOT_EMPTY,\n+               \"Element %s was declared EMPTY this one has content\\n\",\n+                       elem->name, NULL, NULL);\n+                ret = 0;\n+            }\n+            break;\n@@ -5876,2 +5879,2 @@\n-        \/* I don't think anything is required then *\/\n-        break;\n+            \/* I don't think anything is required then *\/\n+            break;\n@@ -5880,19 +5883,19 @@\n-        \/* simple case of declared as #PCDATA *\/\n-        if ((elemDecl->content != NULL) &&\n-        (elemDecl->content->type == XML_ELEMENT_CONTENT_PCDATA)) {\n-        ret = xmlValidateOneCdataElement(ctxt, doc, elem);\n-        if (!ret) {\n-            xmlErrValidNode(ctxt, elem, XML_DTD_NOT_PCDATA,\n-           \"Element %s was declared #PCDATA but contains non text nodes\\n\",\n-               elem->name, NULL, NULL);\n-        }\n-        break;\n-        }\n-        child = elem->children;\n-        \/* Hum, this start to get messy *\/\n-        while (child != NULL) {\n-            if (child->type == XML_ELEMENT_NODE) {\n-            name = child->name;\n-            if ((child->ns != NULL) && (child->ns->prefix != NULL)) {\n-            xmlChar fn[50];\n-            xmlChar *fullname;\n+            \/* simple case of declared as #PCDATA *\/\n+            if ((elemDecl->content != NULL) &&\n+                (elemDecl->content->type == XML_ELEMENT_CONTENT_PCDATA)) {\n+                ret = xmlValidateOneCdataElement(ctxt, doc, elem);\n+                if (!ret) {\n+                    xmlErrValidNode(ctxt, elem, XML_DTD_NOT_PCDATA,\n+               \"Element %s was declared #PCDATA but contains non text nodes\\n\",\n+                           elem->name, NULL, NULL);\n+                }\n+                break;\n+            }\n+            child = elem->children;\n+            \/* Hum, this start to get messy *\/\n+            while (child != NULL) {\n+                if (child->type == XML_ELEMENT_NODE) {\n+                    name = child->name;\n+                    if ((child->ns != NULL) && (child->ns->prefix != NULL)) {\n+                        xmlChar fn[50];\n+                        xmlChar *fullname;\n@@ -5900,3 +5903,3 @@\n-            fullname = xmlBuildQName(child->name, child->ns->prefix,\n-                                 fn, 50);\n-            if (fullname == NULL) {\n+                        fullname = xmlBuildQName(child->name, child->ns->prefix,\n+                                                 fn, 50);\n+                        if (fullname == NULL) {\n@@ -5904,1 +5907,1 @@\n-                return(0);\n+                            return(0);\n@@ -5906,17 +5909,49 @@\n-            cont = elemDecl->content;\n-            while (cont != NULL) {\n-                if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n-                if (xmlStrEqual(cont->name, fullname))\n-                    break;\n-                } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n-                   (cont->c1 != NULL) &&\n-                   (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n-                if (xmlStrEqual(cont->c1->name, fullname))\n-                    break;\n-                } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n-                (cont->c1 == NULL) ||\n-                (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n-                xmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,\n-                    \"Internal: MIXED struct corrupted\\n\",\n-                    NULL);\n-                break;\n+                        cont = elemDecl->content;\n+                        while (cont != NULL) {\n+                            if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n+                                if (xmlStrEqual(cont->name, fullname))\n+                                    break;\n+                            } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n+                               (cont->c1 != NULL) &&\n+                               (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n+                                if (xmlStrEqual(cont->c1->name, fullname))\n+                                    break;\n+                            } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n+                                (cont->c1 == NULL) ||\n+                                (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n+                                xmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,\n+                                        \"Internal: MIXED struct corrupted\\n\",\n+                                        NULL);\n+                                break;\n+                            }\n+                            cont = cont->c2;\n+                        }\n+                        if ((fullname != fn) && (fullname != child->name))\n+                            xmlFree(fullname);\n+                        if (cont != NULL)\n+                            goto child_ok;\n+                    }\n+                    cont = elemDecl->content;\n+                    while (cont != NULL) {\n+                        if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n+                            if (xmlStrEqual(cont->name, name)) break;\n+                        } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n+                           (cont->c1 != NULL) &&\n+                           (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)) {\n+                            if (xmlStrEqual(cont->c1->name, name)) break;\n+                        } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n+                            (cont->c1 == NULL) ||\n+                            (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)) {\n+                            xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,\n+                                    \"Internal: MIXED struct corrupted\\n\",\n+                                    NULL);\n+                            break;\n+                        }\n+                        cont = cont->c2;\n+                    }\n+                    if (cont == NULL) {\n+                        xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_CHILD,\n+               \"Element %s is not declared in %s list of possible children\\n\",\n+                               name, elem->name, NULL);\n+                        ret = 0;\n+                    }\n@@ -5924,32 +5959,0 @@\n-                cont = cont->c2;\n-            }\n-            if ((fullname != fn) && (fullname != child->name))\n-                xmlFree(fullname);\n-            if (cont != NULL)\n-                goto child_ok;\n-            }\n-            cont = elemDecl->content;\n-            while (cont != NULL) {\n-                if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n-                if (xmlStrEqual(cont->name, name)) break;\n-            } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n-               (cont->c1 != NULL) &&\n-               (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)) {\n-                if (xmlStrEqual(cont->c1->name, name)) break;\n-            } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n-                (cont->c1 == NULL) ||\n-                (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)) {\n-                xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,\n-                    \"Internal: MIXED struct corrupted\\n\",\n-                    NULL);\n-                break;\n-            }\n-            cont = cont->c2;\n-            }\n-            if (cont == NULL) {\n-            xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_CHILD,\n-           \"Element %s is not declared in %s list of possible children\\n\",\n-                   name, elem->name, NULL);\n-            ret = 0;\n-            }\n-        }\n@@ -5957,3 +5960,3 @@\n-            child = child->next;\n-        }\n-        break;\n+                child = child->next;\n+            }\n+            break;\n@@ -5961,9 +5964,9 @@\n-        if ((doc->standalone == 1) && (extsubset == 1)) {\n-        \/*\n-         * VC: Standalone Document Declaration\n-         *     - element types with element content, if white space\n-         *       occurs directly within any instance of those types.\n-         *\/\n-        child = elem->children;\n-        while (child != NULL) {\n-            if ((child->type == XML_TEXT_NODE) &&\n+            if ((doc->standalone == 1) && (extsubset == 1)) {\n+                \/*\n+                 * VC: Standalone Document Declaration\n+                 *     - element types with element content, if white space\n+                 *       occurs directly within any instance of those types.\n+                 *\/\n+                child = elem->children;\n+                while (child != NULL) {\n+                    if ((child->type == XML_TEXT_NODE) &&\n@@ -5971,1 +5974,1 @@\n-            const xmlChar *content = child->content;\n+                        const xmlChar *content = child->content;\n@@ -5973,5 +5976,5 @@\n-            while (IS_BLANK_CH(*content))\n-                content++;\n-            if (*content == 0) {\n-                xmlErrValidNode(ctxt, elem,\n-                                XML_DTD_STANDALONE_WHITE_SPACE,\n+                        while (IS_BLANK_CH(*content))\n+                            content++;\n+                        if (*content == 0) {\n+                            xmlErrValidNode(ctxt, elem,\n+                                            XML_DTD_STANDALONE_WHITE_SPACE,\n@@ -5979,4 +5982,7 @@\n-                   elem->name, NULL, NULL);\n-                ret = 0;\n-                break;\n-            }\n+                                   elem->name, NULL, NULL);\n+                            ret = 0;\n+                            break;\n+                        }\n+                    }\n+                    child =child->next;\n+                }\n@@ -5984,9 +5990,6 @@\n-            child =child->next;\n-        }\n-        }\n-        child = elem->children;\n-        cont = elemDecl->content;\n-        tmp = xmlValidateElementContent(ctxt, child, elemDecl, 1, elem);\n-        if (tmp <= 0)\n-        ret = 0;\n-        break;\n+            child = elem->children;\n+            cont = elemDecl->content;\n+            tmp = xmlValidateElementContent(ctxt, child, elemDecl, 1, elem);\n+            if (tmp <= 0)\n+                ret = 0;\n+            break;\n@@ -5999,47 +6002,22 @@\n-    if (attr->def == XML_ATTRIBUTE_REQUIRED) {\n-        int qualified = -1;\n-\n-        if ((attr->prefix == NULL) &&\n-        (xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) {\n-        xmlNsPtr ns;\n-\n-        ns = elem->nsDef;\n-        while (ns != NULL) {\n-            if (ns->prefix == NULL)\n-            goto found;\n-            ns = ns->next;\n-        }\n-        } else if (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\")) {\n-        xmlNsPtr ns;\n-\n-        ns = elem->nsDef;\n-        while (ns != NULL) {\n-            if (xmlStrEqual(attr->name, ns->prefix))\n-            goto found;\n-            ns = ns->next;\n-        }\n-        } else {\n-        xmlAttrPtr attrib;\n-\n-        attrib = elem->properties;\n-        while (attrib != NULL) {\n-            if (xmlStrEqual(attrib->name, attr->name)) {\n-            if (attr->prefix != NULL) {\n-                xmlNsPtr nameSpace = attrib->ns;\n-\n-                if (nameSpace == NULL)\n-                nameSpace = elem->ns;\n-                \/*\n-                 * qualified names handling is problematic, having a\n-                 * different prefix should be possible but DTDs don't\n-                 * allow to define the URI instead of the prefix :-(\n-                 *\/\n-                if (nameSpace == NULL) {\n-                if (qualified < 0)\n-                    qualified = 0;\n-                } else if (!xmlStrEqual(nameSpace->prefix,\n-                            attr->prefix)) {\n-                if (qualified < 1)\n-                    qualified = 1;\n-                } else\n-                goto found;\n+        if (attr->def == XML_ATTRIBUTE_REQUIRED) {\n+            int qualified = -1;\n+\n+            if ((attr->prefix == NULL) &&\n+                (xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) {\n+                xmlNsPtr ns;\n+\n+                ns = elem->nsDef;\n+                while (ns != NULL) {\n+                    if (ns->prefix == NULL)\n+                        goto found;\n+                    ns = ns->next;\n+                }\n+            } else if (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\")) {\n+                xmlNsPtr ns;\n+\n+                ns = elem->nsDef;\n+                while (ns != NULL) {\n+                    if (xmlStrEqual(attr->name, ns->prefix))\n+                        goto found;\n+                    ns = ns->next;\n+                }\n@@ -6047,7 +6025,36 @@\n-                \/*\n-                 * We should allow applications to define namespaces\n-                 * for their application even if the DTD doesn't\n-                 * carry one, otherwise, basically we would always\n-                 * break.\n-                 *\/\n-                goto found;\n+                xmlAttrPtr attrib;\n+\n+                attrib = elem->properties;\n+                while (attrib != NULL) {\n+                    if (xmlStrEqual(attrib->name, attr->name)) {\n+                        if (attr->prefix != NULL) {\n+                            xmlNsPtr nameSpace = attrib->ns;\n+\n+                            if (nameSpace == NULL)\n+                                nameSpace = elem->ns;\n+                            \/*\n+                             * qualified names handling is problematic, having a\n+                             * different prefix should be possible but DTDs don't\n+                             * allow to define the URI instead of the prefix :-(\n+                             *\/\n+                            if (nameSpace == NULL) {\n+                                if (qualified < 0)\n+                                    qualified = 0;\n+                            } else if (!xmlStrEqual(nameSpace->prefix,\n+                                                    attr->prefix)) {\n+                                if (qualified < 1)\n+                                    qualified = 1;\n+                            } else\n+                                goto found;\n+                        } else {\n+                            \/*\n+                             * We should allow applications to define namespaces\n+                             * for their application even if the DTD doesn't\n+                             * carry one, otherwise, basically we would always\n+                             * break.\n+                             *\/\n+                            goto found;\n+                        }\n+                    }\n+                    attrib = attrib->next;\n+                }\n@@ -6055,0 +6062,20 @@\n+            if (qualified == -1) {\n+                if (attr->prefix == NULL) {\n+                    xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,\n+                       \"Element %s does not carry attribute %s\\n\",\n+                           elem->name, attr->name, NULL);\n+                    ret = 0;\n+                } else {\n+                    xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,\n+                       \"Element %s does not carry attribute %s:%s\\n\",\n+                           elem->name, attr->prefix,attr->name);\n+                    ret = 0;\n+                }\n+            } else if (qualified == 0) {\n+                xmlErrValidWarning(ctxt, elem, XML_DTD_NO_PREFIX,\n+                   \"Element %s required attribute %s:%s has no prefix\\n\",\n+                       elem->name, attr->prefix, attr->name);\n+            } else if (qualified == 1) {\n+                xmlErrValidWarning(ctxt, elem, XML_DTD_DIFFERENT_PREFIX,\n+                   \"Element %s required attribute %s:%s has different prefix\\n\",\n+                       elem->name, attr->prefix, attr->name);\n@@ -6056,40 +6083,16 @@\n-            attrib = attrib->next;\n-        }\n-        }\n-        if (qualified == -1) {\n-        if (attr->prefix == NULL) {\n-            xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,\n-               \"Element %s does not carry attribute %s\\n\",\n-               elem->name, attr->name, NULL);\n-            ret = 0;\n-            } else {\n-            xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,\n-               \"Element %s does not carry attribute %s:%s\\n\",\n-               elem->name, attr->prefix,attr->name);\n-            ret = 0;\n-        }\n-        } else if (qualified == 0) {\n-        xmlErrValidWarning(ctxt, elem, XML_DTD_NO_PREFIX,\n-           \"Element %s required attribute %s:%s has no prefix\\n\",\n-               elem->name, attr->prefix, attr->name);\n-        } else if (qualified == 1) {\n-        xmlErrValidWarning(ctxt, elem, XML_DTD_DIFFERENT_PREFIX,\n-           \"Element %s required attribute %s:%s has different prefix\\n\",\n-               elem->name, attr->prefix, attr->name);\n-        }\n-    } else if (attr->def == XML_ATTRIBUTE_FIXED) {\n-        \/*\n-         * Special tests checking #FIXED namespace declarations\n-         * have the right value since this is not done as an\n-         * attribute checking\n-         *\/\n-        if ((attr->prefix == NULL) &&\n-        (xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) {\n-        xmlNsPtr ns;\n-\n-        ns = elem->nsDef;\n-        while (ns != NULL) {\n-            if (ns->prefix == NULL) {\n-            if (!xmlStrEqual(attr->defaultValue, ns->href)) {\n-                xmlErrValidNode(ctxt, elem,\n-                       XML_DTD_ELEM_DEFAULT_NAMESPACE,\n+        } else if (attr->def == XML_ATTRIBUTE_FIXED) {\n+            \/*\n+             * Special tests checking #FIXED namespace declarations\n+             * have the right value since this is not done as an\n+             * attribute checking\n+             *\/\n+            if ((attr->prefix == NULL) &&\n+                (xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) {\n+                xmlNsPtr ns;\n+\n+                ns = elem->nsDef;\n+                while (ns != NULL) {\n+                    if (ns->prefix == NULL) {\n+                        if (!xmlStrEqual(attr->defaultValue, ns->href)) {\n+                            xmlErrValidNode(ctxt, elem,\n+                                   XML_DTD_ELEM_DEFAULT_NAMESPACE,\n@@ -6097,20 +6100,23 @@\n-                   elem->name, NULL, NULL);\n-                ret = 0;\n-            }\n-            goto found;\n-            }\n-            ns = ns->next;\n-        }\n-        } else if (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\")) {\n-        xmlNsPtr ns;\n-\n-        ns = elem->nsDef;\n-        while (ns != NULL) {\n-            if (xmlStrEqual(attr->name, ns->prefix)) {\n-            if (!xmlStrEqual(attr->defaultValue, ns->href)) {\n-                xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n-           \"Element %s namespace name for %s does not match the DTD\\n\",\n-                   elem->name, ns->prefix, NULL);\n-                ret = 0;\n-            }\n-            goto found;\n+                                   elem->name, NULL, NULL);\n+                            ret = 0;\n+                        }\n+                        goto found;\n+                    }\n+                    ns = ns->next;\n+                }\n+            } else if (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\")) {\n+                xmlNsPtr ns;\n+\n+                ns = elem->nsDef;\n+                while (ns != NULL) {\n+                    if (xmlStrEqual(attr->name, ns->prefix)) {\n+                        if (!xmlStrEqual(attr->defaultValue, ns->href)) {\n+                            xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n+                   \"Element %s namespace name for %s does not match the DTD\\n\",\n+                                   elem->name, ns->prefix, NULL);\n+                            ret = 0;\n+                        }\n+                        goto found;\n+                    }\n+                    ns = ns->next;\n+                }\n@@ -6118,1 +6124,0 @@\n-            ns = ns->next;\n@@ -6120,2 +6125,0 @@\n-        }\n-    }\n@@ -6153,2 +6156,2 @@\n-    xmlErrValid(ctxt, XML_DTD_NO_ROOT,\n-                \"no root element\\n\", NULL);\n+        xmlErrValid(ctxt, XML_DTD_NO_ROOT,\n+                    \"no root element\\n\", NULL);\n@@ -6163,8 +6166,8 @@\n-    (doc->intSubset->name != NULL)) {\n-    \/*\n-     * Check first the document root against the NQName\n-     *\/\n-    if (!xmlStrEqual(doc->intSubset->name, root->name)) {\n-        if ((root->ns != NULL) && (root->ns->prefix != NULL)) {\n-        xmlChar fn[50];\n-        xmlChar *fullname;\n+        (doc->intSubset->name != NULL)) {\n+        \/*\n+         * Check first the document root against the NQName\n+         *\/\n+        if (!xmlStrEqual(doc->intSubset->name, root->name)) {\n+            if ((root->ns != NULL) && (root->ns->prefix != NULL)) {\n+                xmlChar fn[50];\n+                xmlChar *fullname;\n@@ -6172,3 +6175,17 @@\n-        fullname = xmlBuildQName(root->name, root->ns->prefix, fn, 50);\n-        if (fullname == NULL) {\n-            xmlVErrMemory(ctxt);\n+                fullname = xmlBuildQName(root->name, root->ns->prefix, fn, 50);\n+                if (fullname == NULL) {\n+                    xmlVErrMemory(ctxt);\n+                    return(0);\n+                }\n+                ret = xmlStrEqual(doc->intSubset->name, fullname);\n+                if ((fullname != fn) && (fullname != root->name))\n+                    xmlFree(fullname);\n+                if (ret == 1)\n+                    goto name_ok;\n+            }\n+            if ((xmlStrEqual(doc->intSubset->name, BAD_CAST \"HTML\")) &&\n+                (xmlStrEqual(root->name, BAD_CAST \"html\")))\n+                goto name_ok;\n+            xmlErrValidNode(ctxt, root, XML_DTD_ROOT_NAME,\n+                   \"root and DTD name do not match '%s' and '%s'\\n\",\n+                   root->name, doc->intSubset->name, NULL);\n@@ -6177,14 +6194,0 @@\n-        ret = xmlStrEqual(doc->intSubset->name, fullname);\n-        if ((fullname != fn) && (fullname != root->name))\n-            xmlFree(fullname);\n-        if (ret == 1)\n-            goto name_ok;\n-        }\n-        if ((xmlStrEqual(doc->intSubset->name, BAD_CAST \"HTML\")) &&\n-        (xmlStrEqual(root->name, BAD_CAST \"html\")))\n-        goto name_ok;\n-        xmlErrValidNode(ctxt, root, XML_DTD_ROOT_NAME,\n-           \"root and DTD name do not match '%s' and '%s'\\n\",\n-           root->name, doc->intSubset->name, NULL);\n-        return(0);\n-    }\n@@ -6282,1 +6285,1 @@\n-                       const xmlChar *name) {\n+                           const xmlChar *name) {\n@@ -6287,1 +6290,1 @@\n-    return;\n+        return;\n@@ -6289,1 +6292,1 @@\n-    return;\n+        return;\n@@ -6292,1 +6295,1 @@\n-    xmlChar *dup, *str = NULL, *cur, save;\n+        xmlChar *dup, *str = NULL, *cur, save;\n@@ -6294,2 +6297,2 @@\n-    dup = xmlStrdup(name);\n-    if (dup == NULL) {\n+        dup = xmlStrdup(name);\n+        if (dup == NULL) {\n@@ -6297,14 +6300,1 @@\n-        return;\n-    }\n-    cur = dup;\n-    while (*cur != 0) {\n-        str = cur;\n-        while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n-        save = *cur;\n-        *cur = 0;\n-        id = xmlGetID(ctxt->doc, str);\n-        if (id == NULL) {\n-        xmlErrValidNodeNr(ctxt, NULL, XML_DTD_UNKNOWN_ID,\n-       \"attribute %s line %d references an unknown ID \\\"%s\\\"\\n\",\n-               ref->name, ref->lineno, str);\n-        ctxt->valid = 0;\n+            return;\n@@ -6312,6 +6302,19 @@\n-        if (save == 0)\n-        break;\n-        *cur = save;\n-        while (IS_BLANK_CH(*cur)) cur++;\n-    }\n-    xmlFree(dup);\n+        cur = dup;\n+        while (*cur != 0) {\n+            str = cur;\n+            while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n+            save = *cur;\n+            *cur = 0;\n+            id = xmlGetID(ctxt->doc, str);\n+            if (id == NULL) {\n+                xmlErrValidNodeNr(ctxt, NULL, XML_DTD_UNKNOWN_ID,\n+           \"attribute %s line %d references an unknown ID \\\"%s\\\"\\n\",\n+                       ref->name, ref->lineno, str);\n+                ctxt->valid = 0;\n+            }\n+            if (save == 0)\n+                break;\n+            *cur = save;\n+            while (IS_BLANK_CH(*cur)) cur++;\n+        }\n+        xmlFree(dup);\n@@ -6319,7 +6322,7 @@\n-    id = xmlGetID(ctxt->doc, name);\n-    if (id == NULL) {\n-        xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n-       \"IDREF attribute %s references an unknown ID \\\"%s\\\"\\n\",\n-           attr->name, name, NULL);\n-        ctxt->valid = 0;\n-    }\n+        id = xmlGetID(ctxt->doc, name);\n+        if (id == NULL) {\n+            xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n+           \"IDREF attribute %s references an unknown ID \\\"%s\\\"\\n\",\n+                   attr->name, name, NULL);\n+            ctxt->valid = 0;\n+        }\n@@ -6327,1 +6330,1 @@\n-    xmlChar *dup, *str = NULL, *cur, save;\n+        xmlChar *dup, *str = NULL, *cur, save;\n@@ -6329,18 +6332,5 @@\n-    dup = xmlStrdup(name);\n-    if (dup == NULL) {\n-        xmlVErrMemory(ctxt);\n-        ctxt->valid = 0;\n-        return;\n-    }\n-    cur = dup;\n-    while (*cur != 0) {\n-        str = cur;\n-        while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n-        save = *cur;\n-        *cur = 0;\n-        id = xmlGetID(ctxt->doc, str);\n-        if (id == NULL) {\n-        xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n-       \"IDREFS attribute %s references an unknown ID \\\"%s\\\"\\n\",\n-                 attr->name, str, NULL);\n-        ctxt->valid = 0;\n+        dup = xmlStrdup(name);\n+        if (dup == NULL) {\n+            xmlVErrMemory(ctxt);\n+            ctxt->valid = 0;\n+            return;\n@@ -6348,6 +6338,19 @@\n-        if (save == 0)\n-        break;\n-        *cur = save;\n-        while (IS_BLANK_CH(*cur)) cur++;\n-    }\n-    xmlFree(dup);\n+        cur = dup;\n+        while (*cur != 0) {\n+            str = cur;\n+            while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n+            save = *cur;\n+            *cur = 0;\n+            id = xmlGetID(ctxt->doc, str);\n+            if (id == NULL) {\n+                xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n+           \"IDREFS attribute %s references an unknown ID \\\"%s\\\"\\n\",\n+                             attr->name, str, NULL);\n+                ctxt->valid = 0;\n+            }\n+            if (save == 0)\n+                break;\n+            *cur = save;\n+            while (IS_BLANK_CH(*cur)) cur++;\n+        }\n+        xmlFree(dup);\n@@ -6367,3 +6370,3 @@\n-    xmlValidateMemoPtr memo = (xmlValidateMemoPtr)user;\n-    xmlValidateRef((xmlRefPtr)data, memo->ctxt, memo->name);\n-    return 1;\n+        xmlValidateMemoPtr memo = (xmlValidateMemoPtr)user;\n+        xmlValidateRef((xmlRefPtr)data, memo->ctxt, memo->name);\n+        return 1;\n@@ -6386,1 +6389,1 @@\n-    return;\n+        return;\n@@ -6421,2 +6424,2 @@\n-        \"xmlValidateDocumentFinal: doc == NULL\\n\", NULL);\n-    return(0);\n+                \"xmlValidateDocumentFinal: doc == NULL\\n\", NULL);\n+        return(0);\n@@ -6516,0 +6519,24 @@\n+\/**\n+ * xmlCtxtValidateDtd:\n+ * @ctxt:  a parser context\n+ * @doc:  a document instance\n+ * @dtd:  a dtd instance\n+ *\n+ * Validate a document against a DTD.\n+ *\n+ * Like xmlValidateDtd but uses the parser context's error handler.\n+ *\n+ * Availabe since 2.14.0.\n+ *\n+ * Returns 1 if valid or 0 otherwise.\n+ *\/\n+int\n+xmlCtxtValidateDtd(xmlParserCtxtPtr ctxt, xmlDocPtr doc, xmlDtdPtr dtd) {\n+    if ((ctxt == NULL) || (ctxt->html))\n+        return(0);\n+\n+    xmlCtxtReset(ctxt);\n+\n+    return(xmlValidateDtd(&ctxt->vctxt, doc, dtd));\n+}\n+\n@@ -6518,1 +6545,1 @@\n-                        const xmlChar *name ATTRIBUTE_UNUSED) {\n+                            const xmlChar *name ATTRIBUTE_UNUSED) {\n@@ -6522,1 +6549,1 @@\n-    return;\n+        return;\n@@ -6524,1 +6551,1 @@\n-    xmlChar *notation = cur->content;\n+        xmlChar *notation = cur->content;\n@@ -6526,2 +6553,2 @@\n-    if (notation != NULL) {\n-        int ret;\n+        if (notation != NULL) {\n+            int ret;\n@@ -6529,3 +6556,4 @@\n-        ret = xmlValidateNotationUse(ctxt, cur->doc, notation);\n-        if (ret != 1) {\n-        ctxt->valid = 0;\n+            ret = xmlValidateNotationUse(ctxt, cur->doc, notation);\n+            if (ret != 1) {\n+                ctxt->valid = 0;\n+            }\n@@ -6534,1 +6562,0 @@\n-    }\n@@ -6539,1 +6566,1 @@\n-                         const xmlChar *name ATTRIBUTE_UNUSED) {\n+                             const xmlChar *name ATTRIBUTE_UNUSED) {\n@@ -6547,1 +6574,1 @@\n-    return;\n+        return;\n@@ -6549,28 +6576,28 @@\n-    case XML_ATTRIBUTE_CDATA:\n-    case XML_ATTRIBUTE_ID:\n-    case XML_ATTRIBUTE_IDREF    :\n-    case XML_ATTRIBUTE_IDREFS:\n-    case XML_ATTRIBUTE_NMTOKEN:\n-    case XML_ATTRIBUTE_NMTOKENS:\n-    case XML_ATTRIBUTE_ENUMERATION:\n-        break;\n-    case XML_ATTRIBUTE_ENTITY:\n-    case XML_ATTRIBUTE_ENTITIES:\n-    case XML_ATTRIBUTE_NOTATION:\n-        if (cur->defaultValue != NULL) {\n-\n-        ret = xmlValidateAttributeValue2(ctxt, ctxt->doc, cur->name,\n-                                     cur->atype, cur->defaultValue);\n-        if ((ret == 0) && (ctxt->valid == 1))\n-            ctxt->valid = 0;\n-        }\n-        if (cur->tree != NULL) {\n-        xmlEnumerationPtr tree = cur->tree;\n-        while (tree != NULL) {\n-            ret = xmlValidateAttributeValue2(ctxt, ctxt->doc,\n-                    cur->name, cur->atype, tree->name);\n-            if ((ret == 0) && (ctxt->valid == 1))\n-            ctxt->valid = 0;\n-            tree = tree->next;\n-        }\n-        }\n+        case XML_ATTRIBUTE_CDATA:\n+        case XML_ATTRIBUTE_ID:\n+        case XML_ATTRIBUTE_IDREF        :\n+        case XML_ATTRIBUTE_IDREFS:\n+        case XML_ATTRIBUTE_NMTOKEN:\n+        case XML_ATTRIBUTE_NMTOKENS:\n+        case XML_ATTRIBUTE_ENUMERATION:\n+            break;\n+        case XML_ATTRIBUTE_ENTITY:\n+        case XML_ATTRIBUTE_ENTITIES:\n+        case XML_ATTRIBUTE_NOTATION:\n+            if (cur->defaultValue != NULL) {\n+\n+                ret = xmlValidateAttributeValue2(ctxt, ctxt->doc, cur->name,\n+                                                 cur->atype, cur->defaultValue);\n+                if ((ret == 0) && (ctxt->valid == 1))\n+                    ctxt->valid = 0;\n+            }\n+            if (cur->tree != NULL) {\n+                xmlEnumerationPtr tree = cur->tree;\n+                while (tree != NULL) {\n+                    ret = xmlValidateAttributeValue2(ctxt, ctxt->doc,\n+                                    cur->name, cur->atype, tree->name);\n+                    if ((ret == 0) && (ctxt->valid == 1))\n+                        ctxt->valid = 0;\n+                    tree = tree->next;\n+                }\n+            }\n@@ -6582,7 +6609,7 @@\n-    doc = cur->doc;\n-    if (cur->elem == NULL) {\n-        xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n-           \"xmlValidateAttributeCallback(%s): internal error\\n\",\n-           (const char *) cur->name);\n-        return;\n-    }\n+        doc = cur->doc;\n+        if (cur->elem == NULL) {\n+            xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n+                   \"xmlValidateAttributeCallback(%s): internal error\\n\",\n+                   (const char *) cur->name);\n+            return;\n+        }\n@@ -6596,2 +6623,2 @@\n-    if ((doc != NULL) && (doc->intSubset != NULL))\n-        elem = xmlHashLookup2(doc->intSubset->elements,\n+        if ((doc != NULL) && (doc->intSubset != NULL))\n+            elem = xmlHashLookup2(doc->intSubset->elements,\n@@ -6599,2 +6626,2 @@\n-    if ((elem == NULL) && (doc != NULL) && (doc->extSubset != NULL))\n-        elem = xmlHashLookup2(doc->extSubset->elements,\n+        if ((elem == NULL) && (doc != NULL) && (doc->extSubset != NULL))\n+            elem = xmlHashLookup2(doc->extSubset->elements,\n@@ -6602,3 +6629,3 @@\n-    if ((elem == NULL) && (cur->parent != NULL) &&\n-        (cur->parent->type == XML_DTD_NODE))\n-        elem = xmlHashLookup2(((xmlDtdPtr) cur->parent)->elements,\n+        if ((elem == NULL) && (cur->parent != NULL) &&\n+            (cur->parent->type == XML_DTD_NODE))\n+            elem = xmlHashLookup2(((xmlDtdPtr) cur->parent)->elements,\n@@ -6609,12 +6636,12 @@\n-    if (elem == NULL) {\n-        xmlErrValidNode(ctxt, NULL, XML_DTD_UNKNOWN_ELEM,\n-           \"attribute %s: could not find decl for element %s\\n\",\n-           cur->name, cur->elem, NULL);\n-        return;\n-    }\n-    if (elem->etype == XML_ELEMENT_TYPE_EMPTY) {\n-        xmlErrValidNode(ctxt, NULL, XML_DTD_EMPTY_NOTATION,\n-           \"NOTATION attribute %s declared for EMPTY element %s\\n\",\n-           cur->name, cur->elem, NULL);\n-        ctxt->valid = 0;\n-    }\n+        if (elem == NULL) {\n+            xmlErrValidNode(ctxt, NULL, XML_DTD_UNKNOWN_ELEM,\n+                   \"attribute %s: could not find decl for element %s\\n\",\n+                   cur->name, cur->elem, NULL);\n+            return;\n+        }\n+        if (elem->etype == XML_ELEMENT_TYPE_EMPTY) {\n+            xmlErrValidNode(ctxt, NULL, XML_DTD_EMPTY_NOTATION,\n+                   \"NOTATION attribute %s declared for EMPTY element %s\\n\",\n+                   cur->name, cur->elem, NULL);\n+            ctxt->valid = 0;\n+        }\n@@ -6651,1 +6678,1 @@\n-    return(0);\n+        return(0);\n@@ -6656,2 +6683,2 @@\n-    table = (xmlAttributeTablePtr) dtd->attributes;\n-    xmlHashScan(table, xmlValidateAttributeCallback, ctxt);\n+        table = (xmlAttributeTablePtr) dtd->attributes;\n+        xmlHashScan(table, xmlValidateAttributeCallback, ctxt);\n@@ -6660,2 +6687,2 @@\n-    entities = (xmlEntitiesTablePtr) dtd->entities;\n-    xmlHashScan(entities, xmlValidateNotationCallback, ctxt);\n+        entities = (xmlEntitiesTablePtr) dtd->entities;\n+        xmlHashScan(entities, xmlValidateNotationCallback, ctxt);\n@@ -6665,2 +6692,2 @@\n-    table = (xmlAttributeTablePtr) dtd->attributes;\n-    xmlHashScan(table, xmlValidateAttributeCallback, ctxt);\n+        table = (xmlAttributeTablePtr) dtd->attributes;\n+        xmlHashScan(table, xmlValidateAttributeCallback, ctxt);\n@@ -6669,2 +6696,2 @@\n-    entities = (xmlEntitiesTablePtr) dtd->entities;\n-    xmlHashScan(entities, xmlValidateNotationCallback, ctxt);\n+        entities = (xmlEntitiesTablePtr) dtd->entities;\n+        xmlHashScan(entities, xmlValidateNotationCallback, ctxt);\n@@ -6676,3 +6703,4 @@\n- * xmlValidateDocument:\n- * @ctxt:  the validation context\n- * @doc:  a document instance\n+ * xmlValidateDocumentInternal:\n+ * @ctxt:  parser context (optional)\n+ * @vctxt:  validation context (optional)\n+ * @doc:  document\n@@ -6680,5 +6708,1 @@\n- * Try to validate the document instance\n- *\n- * basically it does the all the checks described by the XML Rec\n- * i.e. validates the internal and external subset (if present)\n- * and validate the document tree.\n+ * Validate a document.\n@@ -6686,1 +6710,1 @@\n- * returns 1 if valid or 0 otherwise\n+ * Returns 1 if valid or 0 otherwise\n@@ -6688,3 +6712,3 @@\n-\n-int\n-xmlValidateDocument(xmlValidCtxtPtr ctxt, xmlDocPtr doc) {\n+static int\n+xmlValidateDocumentInternal(xmlParserCtxtPtr ctxt, xmlValidCtxtPtr vctxt,\n+                            xmlDocPtr doc) {\n@@ -6697,3 +6721,3 @@\n-        xmlErrValid(ctxt, XML_DTD_NO_DTD,\n-                \"no DTD found!\\n\", NULL);\n-    return(0);\n+        xmlErrValid(vctxt, XML_DTD_NO_DTD,\n+                    \"no DTD found!\\n\", NULL);\n+        return(0);\n@@ -6701,0 +6725,1 @@\n+\n@@ -6702,18 +6727,3 @@\n-    (doc->intSubset->ExternalID != NULL)) && (doc->extSubset == NULL)) {\n-    xmlChar *sysID;\n-    if (doc->intSubset->SystemID != NULL) {\n-        sysID = xmlBuildURI(doc->intSubset->SystemID,\n-            doc->URL);\n-        if (sysID == NULL) {\n-            xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n-            \"Could not build URI for external subset \\\"%s\\\"\\n\",\n-            (const char *) doc->intSubset->SystemID);\n-        return 0;\n-        }\n-    } else\n-        sysID = NULL;\n-        doc->extSubset = xmlParseDTD(doc->intSubset->ExternalID,\n-            (const xmlChar *)sysID);\n-    if (sysID != NULL)\n-        xmlFree(sysID);\n-        if (doc->extSubset == NULL) {\n+        (doc->intSubset->ExternalID != NULL)) && (doc->extSubset == NULL)) {\n+        xmlChar *sysID = NULL;\n+\n@@ -6721,3 +6731,28 @@\n-        xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n-               \"Could not load the external subset \\\"%s\\\"\\n\",\n-               (const char *) doc->intSubset->SystemID);\n+            int res;\n+\n+            res = xmlBuildURISafe(doc->intSubset->SystemID, doc->URL, &sysID);\n+            if (res < 0) {\n+                xmlVErrMemory(vctxt);\n+                return 0;\n+            } else if (res != 0) {\n+                xmlErrValid(vctxt, XML_DTD_LOAD_ERROR,\n+                        \"Could not build URI for external subset \\\"%s\\\"\\n\",\n+                        (const char *) doc->intSubset->SystemID);\n+                return 0;\n+            }\n+        }\n+\n+        if (ctxt != NULL) {\n+            xmlParserInputPtr input;\n+\n+            input = xmlLoadResource(ctxt, (const char *) sysID,\n+                    (const char *) doc->intSubset->ExternalID,\n+                    XML_RESOURCE_DTD);\n+            if (input == NULL) {\n+                xmlFree(sysID);\n+                return 0;\n+            }\n+\n+            doc->extSubset = xmlCtxtParseDtd(ctxt, input,\n+                                             doc->intSubset->ExternalID,\n+                                             sysID);\n@@ -6725,3 +6760,16 @@\n-        xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n-               \"Could not load the external subset \\\"%s\\\"\\n\",\n-               (const char *) doc->intSubset->ExternalID);\n+            doc->extSubset = xmlParseDTD(doc->intSubset->ExternalID, sysID);\n+        }\n+\n+        if (sysID != NULL)\n+            xmlFree(sysID);\n+        if (doc->extSubset == NULL) {\n+            if (doc->intSubset->SystemID != NULL) {\n+                xmlErrValid(vctxt, XML_DTD_LOAD_ERROR,\n+                       \"Could not load the external subset \\\"%s\\\"\\n\",\n+                       (const char *) doc->intSubset->SystemID);\n+            } else {\n+                xmlErrValid(vctxt, XML_DTD_LOAD_ERROR,\n+                       \"Could not load the external subset \\\"%s\\\"\\n\",\n+                       (const char *) doc->intSubset->ExternalID);\n+            }\n+            return(0);\n@@ -6729,2 +6777,0 @@\n-        return(0);\n-    }\n@@ -6741,2 +6787,2 @@\n-    ret = xmlValidateDtdFinal(ctxt, doc);\n-    if (!xmlValidateRoot(ctxt, doc)) return(0);\n+    ret = xmlValidateDtdFinal(vctxt, doc);\n+    if (!xmlValidateRoot(vctxt, doc)) return(0);\n@@ -6745,2 +6791,2 @@\n-    ret &= xmlValidateElement(ctxt, doc, root);\n-    ret &= xmlValidateDocumentFinal(ctxt, doc);\n+    ret &= xmlValidateElement(vctxt, doc, root);\n+    ret &= xmlValidateDocumentFinal(vctxt, doc);\n@@ -6750,0 +6796,47 @@\n+\/**\n+ * xmlValidateDocument:\n+ * @vctxt:  the validation context\n+ * @doc:  a document instance\n+ *\n+ * DEPRECATED: This function can't report malloc or other failures.\n+ * Use xmlCtxtValidateDocument.\n+ *\n+ * Try to validate the document instance\n+ *\n+ * basically it does the all the checks described by the XML Rec\n+ * i.e. validates the internal and external subset (if present)\n+ * and validate the document tree.\n+ *\n+ * returns 1 if valid or 0 otherwise\n+ *\/\n+int\n+xmlValidateDocument(xmlValidCtxtPtr vctxt, xmlDocPtr doc) {\n+    return(xmlValidateDocumentInternal(NULL, vctxt, doc));\n+}\n+\n+\/**\n+ * xmlCtxtValidateDocument:\n+ * @ctxt:  a parser context\n+ * @doc:  a document instance\n+ *\n+ * Validate a document.\n+ *\n+ * Like xmlValidateDocument but uses the parser context's error handler.\n+ *\n+ * Option XML_PARSE_DTDLOAD should be enabled in the parser context\n+ * to make external entities work.\n+ *\n+ * Availabe since 2.14.0.\n+ *\n+ * Returns 1 if valid or 0 otherwise.\n+ *\/\n+int\n+xmlCtxtValidateDocument(xmlParserCtxtPtr ctxt, xmlDocPtr doc) {\n+    if ((ctxt == NULL) || (ctxt->html))\n+        return(0);\n+\n+    xmlCtxtReset(ctxt);\n+\n+    return(xmlValidateDocumentInternal(ctxt, &ctxt->vctxt, doc));\n+}\n+\n@@ -6751,3 +6844,3 @@\n- *                                    *\n- *        Routines for dynamic validation editing            *\n- *                                    *\n+ *                                                                      *\n+ *              Routines for dynamic validation editing                 *\n+ *                                                                      *\n@@ -6779,18 +6872,18 @@\n-    case XML_ELEMENT_CONTENT_PCDATA:\n-        for (i = 0; i < *len;i++)\n-        if (xmlStrEqual(BAD_CAST \"#PCDATA\", names[i])) return(*len);\n-        names[(*len)++] = BAD_CAST \"#PCDATA\";\n-        break;\n-    case XML_ELEMENT_CONTENT_ELEMENT:\n-        for (i = 0; i < *len;i++)\n-        if (xmlStrEqual(ctree->name, names[i])) return(*len);\n-        names[(*len)++] = ctree->name;\n-        break;\n-    case XML_ELEMENT_CONTENT_SEQ:\n-        xmlValidGetPotentialChildren(ctree->c1, names, len, max);\n-        xmlValidGetPotentialChildren(ctree->c2, names, len, max);\n-        break;\n-    case XML_ELEMENT_CONTENT_OR:\n-        xmlValidGetPotentialChildren(ctree->c1, names, len, max);\n-        xmlValidGetPotentialChildren(ctree->c2, names, len, max);\n-        break;\n+        case XML_ELEMENT_CONTENT_PCDATA:\n+            for (i = 0; i < *len;i++)\n+                if (xmlStrEqual(BAD_CAST \"#PCDATA\", names[i])) return(*len);\n+            names[(*len)++] = BAD_CAST \"#PCDATA\";\n+            break;\n+        case XML_ELEMENT_CONTENT_ELEMENT:\n+            for (i = 0; i < *len;i++)\n+                if (xmlStrEqual(ctree->name, names[i])) return(*len);\n+            names[(*len)++] = ctree->name;\n+            break;\n+        case XML_ELEMENT_CONTENT_SEQ:\n+            xmlValidGetPotentialChildren(ctree->c1, names, len, max);\n+            xmlValidGetPotentialChildren(ctree->c2, names, len, max);\n+            break;\n+        case XML_ELEMENT_CONTENT_OR:\n+            xmlValidGetPotentialChildren(ctree->c1, names, len, max);\n+            xmlValidGetPotentialChildren(ctree->c2, names, len, max);\n+            break;\n@@ -6807,1 +6900,0 @@\n-    return;\n@@ -6862,1 +6954,1 @@\n-    vctxt.error = xmlNoValidityErr;    \/* this suppresses err\/warn output *\/\n+    vctxt.error = xmlNoValidityErr;     \/* this suppresses err\/warn output *\/\n@@ -6909,1 +7001,1 @@\n-               elements, &nb_elements, 256);\n+                       elements, &nb_elements, 256);\n@@ -6912,9 +7004,9 @@\n-    test_node->name = elements[i];\n-    if (xmlValidateOneElement(&vctxt, parent->doc, parent)) {\n-        int j;\n-\n-        for (j = 0; j < nb_valid_elements;j++)\n-        if (xmlStrEqual(elements[i], names[j])) break;\n-        names[nb_valid_elements++] = elements[i];\n-        if (nb_valid_elements >= max) break;\n-    }\n+        test_node->name = elements[i];\n+        if (xmlValidateOneElement(&vctxt, parent->doc, parent)) {\n+            int j;\n+\n+            for (j = 0; j < nb_valid_elements;j++)\n+                if (xmlStrEqual(elements[i], names[j])) break;\n+            names[nb_valid_elements++] = elements[i];\n+            if (nb_valid_elements >= max) break;\n+        }\n@@ -6940,1 +7032,0 @@\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/valid.c","additions":2432,"deletions":2341,"binary":false,"changes":4773,"status":"modified"},{"patch":"@@ -62,2 +62,0 @@\n-!else if \"$(WITH_THREADS)\" == \"posix\"\n-CFLAGS = $(CFLAGS) -DHAVE_PTHREAD_H\n@@ -80,1 +78,1 @@\n-!if \"$(WITH_FTP)\" == \"1\" || \"$(WITH_HTTP)\" == \"1\"\n+!if \"$(WITH_HTTP)\" == \"1\"\n@@ -126,1 +124,0 @@\n-\t$(XML_INTDIR)\\legacy.obj\\\n@@ -128,1 +125,0 @@\n-\t$(XML_INTDIR)\\nanoftp.obj\\\n@@ -134,1 +130,0 @@\n-\t$(XML_INTDIR)\\SAX.obj\\\n@@ -171,1 +166,0 @@\n-\t$(XML_INTDIR_A)\\legacy.obj\\\n@@ -173,1 +167,0 @@\n-\t$(XML_INTDIR_A)\\nanoftp.obj\\\n@@ -179,1 +172,0 @@\n-\t$(XML_INTDIR_A)\\SAX.obj\\\n@@ -211,6 +203,0 @@\n-\n-!if \"$(WITH_THREADS)\" != \"no\"\n-UTILS = $(UTILS) $(BINDIR)\\testThreads.exe\n-!endif\n-\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/win32\/Makefile.bcb","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -45,3 +45,0 @@\n-ifeq ($(WITH_THREADS),posix)\n-CFLAGS += -DHAVE_PTHREAD_H\n-endif\n@@ -55,3 +52,0 @@\n-ifeq ($(WITH_FTP),1)\n-LIBS += -lwsock32 -lws2_32\n-endif \n@@ -111,1 +105,0 @@\n-\t$(XML_INTDIR)\/nanoftp.o\\\n@@ -158,1 +151,0 @@\n-\t$(XML_INTDIR_A)\/nanoftp.o\\\n@@ -198,4 +190,0 @@\n-ifneq ($(WITH_THREADS),no)\n-UTILS += $(BINDIR)\/testThreads.exe\n-endif\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/win32\/Makefile.mingw","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-!else if \"$(WITH_THREADS)\" == \"posix\"\n-CFLAGS = $(CFLAGS) \/D \"HAVE_PTHREAD_H\"\n@@ -57,1 +55,1 @@\n-!if \"$(WITH_FTP)\" == \"1\" || \"$(WITH_HTTP)\" == \"1\"\n+!if \"$(WITH_HTTP)\" == \"1\"\n@@ -120,1 +118,0 @@\n-\t$(XML_INTDIR)\\legacy.obj\\\n@@ -122,1 +119,0 @@\n-\t$(XML_INTDIR)\\nanoftp.obj\\\n@@ -129,1 +125,0 @@\n-\t$(XML_INTDIR)\\SAX.obj\\\n@@ -165,1 +160,0 @@\n-\t$(XML_INTDIR_A)\\legacy.obj\\\n@@ -167,1 +161,0 @@\n-\t$(XML_INTDIR_A)\\nanoftp.obj\\\n@@ -174,1 +167,0 @@\n-\t$(XML_INTDIR_A)\\SAX.obj\\\n@@ -210,1 +202,0 @@\n-\t$(XML_INTDIR_A_DLL)\\legacy.obj\\\n@@ -212,1 +203,0 @@\n-\t$(XML_INTDIR_A_DLL)\\nanoftp.obj\\\n@@ -219,1 +209,0 @@\n-\t$(XML_INTDIR_A_DLL)\\SAX.obj\\\n@@ -260,4 +249,0 @@\n-!if \"$(WITH_THREADS)\" != \"no\"\n-UTILS = $(UTILS) $(BINDIR)\\testThreads.exe\n-!endif\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/win32\/Makefile.msvc","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -17,1 +17,1 @@\n-var configFile = srcDirXml + \"\\\\configure.ac\";\n+var libxmlVersionFile = srcDirXml + \"\\\\VERSION\";\n@@ -32,1 +32,0 @@\n-var withFtp = true;\n@@ -39,1 +38,0 @@\n-var withXptrLocs = false;\n@@ -50,0 +48,1 @@\n+var withRelaxNg = true;\n@@ -115,1 +114,0 @@\n-\ttxt += \"  ftp:        Enable FTP client (\" + (withFtp? \"yes\" : \"no\")  + \")\\n\";\n@@ -122,1 +120,0 @@\n-\ttxt += \"  xptr_locs:  Enable XPointer locs support (\" + (withXptrLocs? \"yes\" : \"no\")  + \")\\n\";\n@@ -131,0 +128,1 @@\n+\ttxt += \"  relaxng:    Enable RELAX NG support (\" + (withRelaxNg ? \"yes\" : \"no\") + \")\\n\";\n@@ -177,1 +175,1 @@\n-\tcf = fso.OpenTextFile(configFile, 1);\n+\tcf = fso.OpenTextFile(libxmlVersionFile, 1);\n@@ -191,13 +189,7 @@\n-\t\tif (m = s.match(\/^m4_define\\(\\[MAJOR_VERSION\\], (\\w+)\\)\/)) {\n-\t\t\tvf.WriteLine(\"LIBXML_MAJOR_VERSION=\" + m[1]);\n-\t\t\tverMajor = m[1];\n-\t\t} else if(m = s.match(\/^m4_define\\(\\[MINOR_VERSION\\], (\\w+)\\)\/)) {\n-\t\t\tvf.WriteLine(\"LIBXML_MINOR_VERSION=\" + m[1]);\n-\t\t\tverMinor = m[1];\n-\t\t} else if(m = s.match(\/^m4_define\\(\\[MICRO_VERSION\\], (\\w+)\\)\/)) {\n-\t\t\tvf.WriteLine(\"LIBXML_MICRO_VERSION=\" + m[1]);\n-\t\t\tverMicro = m[1];\n-\t\t} else if(s.search(\/^LIBXML_MICRO_VERSION_SUFFIX=\/) != -1) {\n-\t\t\tvf.WriteLine(s);\n-\t\t\tverMicroSuffix = s.substring(s.indexOf(\"=\") + 1, s.length);\n-\t\t}\n+\t\tversionSplit = s.split(\".\");\n+\t\tverMajor = versionSplit[0];\n+\t\tvf.WriteLine(\"LIBXML_MAJOR_VERSION=\" + verMajor);\n+\t\tverMinor = versionSplit[1];\n+\t\tvf.WriteLine(\"LIBXML_MINOR_VERSION=\" + verMinor);\n+\t\tverMicro = versionSplit[2];\n+\t\tvf.WriteLine(\"LIBXML_MICRO_VERSION=\" + verMicro);\n@@ -209,1 +201,0 @@\n-\tvf.WriteLine(\"WITH_FTP=\" + (withFtp? \"1\" : \"0\"));\n@@ -216,1 +207,0 @@\n-\tvf.WriteLine(\"WITH_XPTR_LOCS=\" + (withXptrLocs? \"1\" : \"0\"));\n@@ -227,0 +217,1 @@\n+\tvf.WriteLine(\"WITH_RELAXNG=\" + (withRelaxNg ? \"1\" : \"0\"));\n@@ -297,2 +288,0 @@\n-\t\t} else if (s.search(\/\\@WITH_FTP\\@\/) != -1) {\n-\t\t\tof.WriteLine(s.replace(\/\\@WITH_FTP\\@\/, withFtp? \"1\" : \"0\"));\n@@ -311,2 +300,0 @@\n-\t\t} else if (s.search(\/\\@WITH_XPTR_LOCS\\@\/) != -1) {\n-\t\t\tof.WriteLine(s.replace(\/\\@WITH_XPTR_LOCS\\@\/, withXptrLocs? \"1\" : \"0\"));\n@@ -333,0 +320,2 @@\n+\t\t} else if (s.search(\/\\@WITH_RELAXNG\\@\/) != -1) {\n+\t\t\tof.WriteLine(s.replace(\/\\@WITH_RELAXNG\\@\/, withRelaxNg? \"1\" : \"0\"));\n@@ -446,2 +435,0 @@\n-\t\telse if (opt == \"ftp\")\n-\t\t\twithFtp = strToBool(arg.substring(opt.length + 1, arg.length));\n@@ -460,2 +447,0 @@\n-\t\telse if (opt == \"xptr_locs\")\n-\t\t\twithXptrLocs = strToBool(arg.substring(opt.length + 1, arg.length));\n@@ -482,0 +467,2 @@\n+\t\telse if (opt == \"relaxng\")\n+\t\t\twithRelaxNg = strToBool(arg.substring(opt.length + 1, arg.length));\n@@ -622,1 +609,1 @@\n-var confighsrc = \"..\\\\include\\\\win32config.h\";\n+var confighsrc = \"win32config.h\";\n@@ -637,1 +624,0 @@\n-txtOut += \"        FTP client: \" + boolToStr(withFtp) + \"\\n\";\n@@ -644,1 +630,0 @@\n-txtOut += \"     XPointer locs: \" + boolToStr(withXptrLocs) + \"\\n\";\n@@ -653,0 +638,1 @@\n+txtOut += \"  Relax NG support: \" + boolToStr(withRelaxNg) + \"\\n\";\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/win32\/configure.js","additions":18,"deletions":32,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -16,4 +16,0 @@\n-#ifdef HAVE_SYS_STAT_H\n-#include <sys\/stat.h>\n-#endif\n-#ifdef HAVE_FCNTL_H\n@@ -21,0 +17,9 @@\n+#include <sys\/stat.h>\n+\n+#if defined(_WIN32)\n+  #define WIN32_LEAN_AND_MEAN\n+  #include <windows.h>\n+  #include <io.h>\n+  #include <direct.h>\n+#else\n+  #include <unistd.h>\n@@ -22,3 +27,1 @@\n-#ifdef HAVE_UNISTD_H\n-#include <unistd.h>\n-#endif\n+\n@@ -32,7 +35,0 @@\n-#if defined(_WIN32)\n-#define WIN32_LEAN_AND_MEAN\n-#include <windows.h>\n-#include <io.h>\n-#include <direct.h>\n-#endif\n-\n@@ -43,1 +39,1 @@\n-#include <libxml\/nanoftp.h>\n+#include <libxml\/parserInternals.h>\n@@ -51,0 +47,1 @@\n+#include \"private\/entities.h\"\n@@ -53,1 +50,4 @@\n-#include \"private\/parser.h\"\n+\n+#ifndef SIZE_MAX\n+  #define SIZE_MAX ((size_t) -1)\n+#endif\n@@ -112,3 +112,3 @@\n- *                                    *\n- *            Error handling                    *\n- *                                    *\n+ *                                                                      *\n+ *                      Error handling                                  *\n+ *                                                                      *\n@@ -118,13 +118,1 @@\n- * xmlIOErrMemory:\n- * @extra:  extra information\n- *\n- * Handle an out of memory condition\n- *\/\n-static void\n-xmlIOErrMemory(void)\n-{\n-    xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_IO, NULL);\n-}\n-\n-\/**\n- * __xmlIOErr:\n+ * xmlIOErr:\n@@ -132,2 +120,0 @@\n- * @\n- * @extra:  extra information\n@@ -135,1 +121,3 @@\n- * Handle an I\/O error\n+ * Convert errno to xmlParserErrors.\n+ *\n+ * Returns an xmlParserErrors code.\n@@ -137,2 +125,2 @@\n-int\n-__xmlIOErr(int domain, int code, const char *extra)\n+static xmlParserErrors\n+xmlIOErr(int err)\n@@ -140,5 +128,1 @@\n-    xmlStructuredErrorFunc schannel = NULL;\n-    xmlGenericErrorFunc channel = NULL;\n-    void *data = NULL;\n-    const char *fmt, *arg1, *arg2;\n-    int res;\n+    xmlParserErrors code;\n@@ -146,2 +130,1 @@\n-    if (code == 0) {\n-    if (errno == 0) code = XML_IO_UNKNOWN;\n+    if (err == 0) code = XML_IO_UNKNOWN;\n@@ -149,1 +132,1 @@\n-        else if (errno == EACCES) code = XML_IO_EACCES;\n+    else if (err == EACCES) code = XML_IO_EACCES;\n@@ -152,1 +135,1 @@\n-        else if (errno == EAGAIN) code = XML_IO_EAGAIN;\n+    else if (err == EAGAIN) code = XML_IO_EAGAIN;\n@@ -155,1 +138,1 @@\n-        else if (errno == EBADF) code = XML_IO_EBADF;\n+    else if (err == EBADF) code = XML_IO_EBADF;\n@@ -158,1 +141,1 @@\n-        else if (errno == EBADMSG) code = XML_IO_EBADMSG;\n+    else if (err == EBADMSG) code = XML_IO_EBADMSG;\n@@ -161,1 +144,1 @@\n-        else if (errno == EBUSY) code = XML_IO_EBUSY;\n+    else if (err == EBUSY) code = XML_IO_EBUSY;\n@@ -164,1 +147,1 @@\n-        else if (errno == ECANCELED) code = XML_IO_ECANCELED;\n+    else if (err == ECANCELED) code = XML_IO_ECANCELED;\n@@ -167,1 +150,1 @@\n-        else if (errno == ECHILD) code = XML_IO_ECHILD;\n+    else if (err == ECHILD) code = XML_IO_ECHILD;\n@@ -170,1 +153,1 @@\n-        else if (errno == EDEADLK) code = XML_IO_EDEADLK;\n+    else if (err == EDEADLK) code = XML_IO_EDEADLK;\n@@ -173,1 +156,1 @@\n-        else if (errno == EDOM) code = XML_IO_EDOM;\n+    else if (err == EDOM) code = XML_IO_EDOM;\n@@ -176,1 +159,1 @@\n-        else if (errno == EEXIST) code = XML_IO_EEXIST;\n+    else if (err == EEXIST) code = XML_IO_EEXIST;\n@@ -179,1 +162,1 @@\n-        else if (errno == EFAULT) code = XML_IO_EFAULT;\n+    else if (err == EFAULT) code = XML_IO_EFAULT;\n@@ -182,1 +165,1 @@\n-        else if (errno == EFBIG) code = XML_IO_EFBIG;\n+    else if (err == EFBIG) code = XML_IO_EFBIG;\n@@ -185,1 +168,1 @@\n-        else if (errno == EINPROGRESS) code = XML_IO_EINPROGRESS;\n+    else if (err == EINPROGRESS) code = XML_IO_EINPROGRESS;\n@@ -188,1 +171,1 @@\n-        else if (errno == EINTR) code = XML_IO_EINTR;\n+    else if (err == EINTR) code = XML_IO_EINTR;\n@@ -191,1 +174,1 @@\n-        else if (errno == EINVAL) code = XML_IO_EINVAL;\n+    else if (err == EINVAL) code = XML_IO_EINVAL;\n@@ -194,1 +177,1 @@\n-        else if (errno == EIO) code = XML_IO_EIO;\n+    else if (err == EIO) code = XML_IO_EIO;\n@@ -197,1 +180,1 @@\n-        else if (errno == EISDIR) code = XML_IO_EISDIR;\n+    else if (err == EISDIR) code = XML_IO_EISDIR;\n@@ -200,1 +183,1 @@\n-        else if (errno == EMFILE) code = XML_IO_EMFILE;\n+    else if (err == EMFILE) code = XML_IO_EMFILE;\n@@ -203,1 +186,1 @@\n-        else if (errno == EMLINK) code = XML_IO_EMLINK;\n+    else if (err == EMLINK) code = XML_IO_EMLINK;\n@@ -206,1 +189,1 @@\n-        else if (errno == EMSGSIZE) code = XML_IO_EMSGSIZE;\n+    else if (err == EMSGSIZE) code = XML_IO_EMSGSIZE;\n@@ -209,1 +192,1 @@\n-        else if (errno == ENAMETOOLONG) code = XML_IO_ENAMETOOLONG;\n+    else if (err == ENAMETOOLONG) code = XML_IO_ENAMETOOLONG;\n@@ -212,1 +195,1 @@\n-        else if (errno == ENFILE) code = XML_IO_ENFILE;\n+    else if (err == ENFILE) code = XML_IO_ENFILE;\n@@ -215,1 +198,1 @@\n-        else if (errno == ENODEV) code = XML_IO_ENODEV;\n+    else if (err == ENODEV) code = XML_IO_ENODEV;\n@@ -218,1 +201,1 @@\n-        else if (errno == ENOENT) code = XML_IO_ENOENT;\n+    else if (err == ENOENT) code = XML_IO_ENOENT;\n@@ -221,1 +204,1 @@\n-        else if (errno == ENOEXEC) code = XML_IO_ENOEXEC;\n+    else if (err == ENOEXEC) code = XML_IO_ENOEXEC;\n@@ -224,1 +207,1 @@\n-        else if (errno == ENOLCK) code = XML_IO_ENOLCK;\n+    else if (err == ENOLCK) code = XML_IO_ENOLCK;\n@@ -227,1 +210,1 @@\n-        else if (errno == ENOMEM) code = XML_IO_ENOMEM;\n+    else if (err == ENOMEM) code = XML_IO_ENOMEM;\n@@ -230,1 +213,1 @@\n-        else if (errno == ENOSPC) code = XML_IO_ENOSPC;\n+    else if (err == ENOSPC) code = XML_IO_ENOSPC;\n@@ -233,1 +216,1 @@\n-        else if (errno == ENOSYS) code = XML_IO_ENOSYS;\n+    else if (err == ENOSYS) code = XML_IO_ENOSYS;\n@@ -236,1 +219,1 @@\n-        else if (errno == ENOTDIR) code = XML_IO_ENOTDIR;\n+    else if (err == ENOTDIR) code = XML_IO_ENOTDIR;\n@@ -239,1 +222,1 @@\n-        else if (errno == ENOTEMPTY) code = XML_IO_ENOTEMPTY;\n+    else if (err == ENOTEMPTY) code = XML_IO_ENOTEMPTY;\n@@ -242,1 +225,1 @@\n-        else if (errno == ENOTSUP) code = XML_IO_ENOTSUP;\n+    else if (err == ENOTSUP) code = XML_IO_ENOTSUP;\n@@ -245,1 +228,1 @@\n-        else if (errno == ENOTTY) code = XML_IO_ENOTTY;\n+    else if (err == ENOTTY) code = XML_IO_ENOTTY;\n@@ -248,1 +231,1 @@\n-        else if (errno == ENXIO) code = XML_IO_ENXIO;\n+    else if (err == ENXIO) code = XML_IO_ENXIO;\n@@ -251,1 +234,1 @@\n-        else if (errno == EPERM) code = XML_IO_EPERM;\n+    else if (err == EPERM) code = XML_IO_EPERM;\n@@ -254,1 +237,1 @@\n-        else if (errno == EPIPE) code = XML_IO_EPIPE;\n+    else if (err == EPIPE) code = XML_IO_EPIPE;\n@@ -257,1 +240,1 @@\n-        else if (errno == ERANGE) code = XML_IO_ERANGE;\n+    else if (err == ERANGE) code = XML_IO_ERANGE;\n@@ -260,1 +243,1 @@\n-        else if (errno == EROFS) code = XML_IO_EROFS;\n+    else if (err == EROFS) code = XML_IO_EROFS;\n@@ -263,1 +246,1 @@\n-        else if (errno == ESPIPE) code = XML_IO_ESPIPE;\n+    else if (err == ESPIPE) code = XML_IO_ESPIPE;\n@@ -266,1 +249,1 @@\n-        else if (errno == ESRCH) code = XML_IO_ESRCH;\n+    else if (err == ESRCH) code = XML_IO_ESRCH;\n@@ -269,1 +252,1 @@\n-        else if (errno == ETIMEDOUT) code = XML_IO_ETIMEDOUT;\n+    else if (err == ETIMEDOUT) code = XML_IO_ETIMEDOUT;\n@@ -272,1 +255,1 @@\n-        else if (errno == EXDEV) code = XML_IO_EXDEV;\n+    else if (err == EXDEV) code = XML_IO_EXDEV;\n@@ -275,1 +258,1 @@\n-        else if (errno == ENOTSOCK) code = XML_IO_ENOTSOCK;\n+    else if (err == ENOTSOCK) code = XML_IO_ENOTSOCK;\n@@ -278,1 +261,1 @@\n-        else if (errno == EISCONN) code = XML_IO_EISCONN;\n+    else if (err == EISCONN) code = XML_IO_EISCONN;\n@@ -281,1 +264,1 @@\n-        else if (errno == ECONNREFUSED) code = XML_IO_ECONNREFUSED;\n+    else if (err == ECONNREFUSED) code = XML_IO_ECONNREFUSED;\n@@ -284,1 +267,1 @@\n-        else if (errno == ETIMEDOUT) code = XML_IO_ETIMEDOUT;\n+    else if (err == ETIMEDOUT) code = XML_IO_ETIMEDOUT;\n@@ -287,1 +270,1 @@\n-        else if (errno == ENETUNREACH) code = XML_IO_ENETUNREACH;\n+    else if (err == ENETUNREACH) code = XML_IO_ENETUNREACH;\n@@ -290,1 +273,1 @@\n-        else if (errno == EADDRINUSE) code = XML_IO_EADDRINUSE;\n+    else if (err == EADDRINUSE) code = XML_IO_EADDRINUSE;\n@@ -293,1 +276,1 @@\n-        else if (errno == EINPROGRESS) code = XML_IO_EINPROGRESS;\n+    else if (err == EINPROGRESS) code = XML_IO_EINPROGRESS;\n@@ -296,1 +279,1 @@\n-        else if (errno == EALREADY) code = XML_IO_EALREADY;\n+    else if (err == EALREADY) code = XML_IO_EALREADY;\n@@ -299,1 +282,1 @@\n-        else if (errno == EAFNOSUPPORT) code = XML_IO_EAFNOSUPPORT;\n+    else if (err == EAFNOSUPPORT) code = XML_IO_EAFNOSUPPORT;\n@@ -301,28 +284,1 @@\n-        else code = XML_IO_UNKNOWN;\n-    }\n-\n-    if (xmlStructuredError) {\n-        schannel = xmlStructuredError;\n-        data = xmlStructuredErrorContext;\n-    } else {\n-        channel = xmlGenericError;\n-        data = xmlGenericErrorContext;\n-    }\n-\n-    if (extra != NULL) {\n-        fmt = \"%s: %s\";\n-    } else {\n-        fmt = \"%s\";\n-    }\n-\n-    arg1 = xmlErrString(code);\n-    arg2 = extra;\n-\n-    res = __xmlRaiseError(schannel, channel, data, NULL, NULL,\n-                          domain, code, XML_ERR_ERROR, NULL, 0,\n-                          extra, NULL, NULL, 0, 0,\n-                          fmt, arg1, arg2);\n-    if (res < 0) {\n-        xmlIOErrMemory();\n-        return(XML_ERR_NO_MEMORY);\n-    }\n+    else code = XML_IO_UNKNOWN;\n@@ -333,13 +289,0 @@\n-\/**\n- * xmlIOErr:\n- * @code:  the error number\n- * @extra:  extra information\n- *\n- * Handle an I\/O error\n- *\/\n-static int\n-xmlIOErr(int code, const char *extra)\n-{\n-    return(__xmlIOErr(XML_FROM_IO, code, extra));\n-}\n-\n@@ -347,3 +290,3 @@\n- *                                    *\n- *        Standard I\/O for file accesses                *\n- *                                    *\n+ *                                                                      *\n+ *              Standard I\/O for file accesses                          *\n+ *                                                                      *\n@@ -424,1 +367,0 @@\n-#ifdef HAVE_STAT\n@@ -431,1 +373,0 @@\n-#endif\n@@ -434,1 +375,1 @@\n-    return(0);\n+        return(0);\n@@ -436,1 +377,0 @@\n-#ifdef HAVE_STAT\n@@ -466,1 +406,0 @@\n-#endif \/* HAVE_STAT *\/\n@@ -479,1 +418,1 @@\n-    escaped = &uri[16];\n+        escaped = &uri[16];\n@@ -481,1 +420,1 @@\n-    escaped = &uri[7];\n+        escaped = &uri[7];\n@@ -484,1 +423,1 @@\n-    escaped = &uri[5];\n+        escaped = &uri[5];\n@@ -502,0 +441,4 @@\n+typedef struct {\n+    int fd;\n+} xmlFdIOCtxt;\n+\n@@ -509,1 +452,1 @@\n-static int\n+static xmlParserErrors\n@@ -514,1 +457,1 @@\n-    int ret;\n+    xmlParserErrors ret;\n@@ -539,1 +482,1 @@\n-    fd = _wopen(wpath, flags | _O_BINARY, 0666);\n+        fd = _wopen(wpath, flags | _O_BINARY, 0666);\n@@ -558,5 +501,1 @@\n-            \/*\n-             * This error won't be forwarded to the parser context\n-             * which will report it a second time.\n-             *\/\n-            ret = xmlIOErr(0, filename);\n+            ret = xmlIOErr(errno);\n@@ -585,1 +524,2 @@\n-    int fd = (int) (ptrdiff_t) context;\n+    xmlFdIOCtxt *fdctxt = context;\n+    int fd = fdctxt->fd;\n@@ -598,1 +538,1 @@\n-            return(-xmlIOErr(0, \"read()\"));\n+            return(-xmlIOErr(errno));\n@@ -623,1 +563,2 @@\n-    int fd = (int) (ptrdiff_t) context;\n+    xmlFdIOCtxt *fdctxt = context;\n+    int fd = fdctxt->fd;\n@@ -628,3 +569,3 @@\n-    bytes = write(fd, buffer, len);\n-    if (bytes < 0)\n-            return(-xmlIOErr(0, \"write()\"));\n+        bytes = write(fd, buffer, len);\n+        if (bytes < 0)\n+            return(-xmlIOErr(errno));\n@@ -640,0 +581,6 @@\n+static int\n+xmlFdFree(void *context) {\n+    xmlFree(context);\n+    return(XML_ERR_OK);\n+}\n+\n@@ -650,0 +597,2 @@\n+    xmlFdIOCtxt *fdctxt = context;\n+    int fd = fdctxt->fd;\n@@ -652,1 +601,4 @@\n-    ret = close((int) (ptrdiff_t) context);\n+    ret = close(fd);\n+\n+    xmlFree(fdctxt);\n+\n@@ -654,1 +606,1 @@\n-        return(xmlIOErr(0, \"close()\"));\n+        return(xmlIOErr(errno));\n@@ -679,1 +631,1 @@\n- * Returns an I\/O context or NULL in case of error\n+ * Returns an xmlParserErrors code\n@@ -681,1 +633,1 @@\n-static int\n+static xmlParserErrors\n@@ -685,1 +637,1 @@\n-    int ret = XML_ERR_OK;\n+    xmlParserErrors ret = XML_ERR_OK;\n@@ -706,1 +658,1 @@\n-    fd = _wfopen(wpath, write ? L\"wb\" : L\"rb\");\n+        fd = _wfopen(wpath, write ? L\"wb\" : L\"rb\");\n@@ -725,1 +677,1 @@\n-            ret = xmlIOErr(0, filename);\n+            ret = xmlIOErr(errno);\n@@ -777,1 +729,1 @@\n-        return(-xmlIOErr(0, \"fread()\"));\n+        return(-xmlIOErr(errno));\n@@ -804,1 +756,1 @@\n-        return(-xmlIOErr(0, \"fwrite()\"));\n+        return(-xmlIOErr(errno));\n@@ -824,1 +776,1 @@\n-        return(xmlIOErr(0, \"fflush()\"));\n+        return(xmlIOErr(errno));\n@@ -850,1 +802,1 @@\n-        return(xmlIOErr(0, \"fclose()\"));\n+        return(xmlIOErr(errno));\n@@ -880,3 +832,3 @@\n- *                                    *\n- *        I\/O for compressed file accesses            *\n- *                                    *\n+ *                                                                      *\n+ *              I\/O for compressed file accesses                        *\n+ *                                                                      *\n@@ -900,1 +852,2 @@\n-    if (ret < 0) xmlIOErr(0, \"gzread()\");\n+    if (ret < 0)\n+        return(-XML_IO_UNKNOWN);\n@@ -920,1 +873,2 @@\n-    if (ret < 0) xmlIOErr(0, \"gzwrite()\");\n+    if (ret < 0)\n+        return(-XML_IO_UNKNOWN);\n@@ -933,5 +887,3 @@\n-    int ret;\n-\n-    ret =  (gzclose((gzFile) context) == Z_OK ) ? 0 : -1;\n-    if (ret < 0) xmlIOErr(0, \"gzclose()\");\n-    return(ret);\n+    if (gzclose((gzFile) context) != Z_OK)\n+        return(XML_IO_UNKNOWN);\n+    return(0);\n@@ -942,3 +894,3 @@\n- *                                    *\n- *        I\/O for compressed file accesses            *\n- *                                    *\n+ *                                                                      *\n+ *              I\/O for compressed file accesses                        *\n+ *                                                                      *\n@@ -966,1 +918,2 @@\n-    if (ret < 0) xmlIOErr(0, \"xzread()\");\n+    if (ret < 0)\n+        return(-XML_IO_UNKNOWN);\n@@ -978,5 +931,3 @@\n-    int ret;\n-\n-    ret =  (__libxml2_xzclose((xzFile) context) == LZMA_OK ) ? 0 : -1;\n-    if (ret < 0) xmlIOErr(0, \"xzclose()\");\n-    return(ret);\n+    if (__libxml2_xzclose((xzFile) context) != LZMA_OK)\n+        return(XML_IO_UNKNOWN);\n+    return(0);\n@@ -987,3 +938,3 @@\n- *                                    *\n- *            I\/O for HTTP file accesses            *\n- *                                    *\n+ *                                                                      *\n+ *                      I\/O for HTTP file accesses                      *\n+ *                                                                      *\n@@ -1006,1 +957,1 @@\n-    return(1);\n+        return(1);\n@@ -1078,1 +1029,0 @@\n-#ifdef LIBXML_FTP_ENABLED\n@@ -1080,3 +1030,3 @@\n- *                                    *\n- *            I\/O for FTP file accesses            *\n- *                                    *\n+ *                                                                      *\n+ *                      Input\/output buffers                            *\n+ *                                                                      *\n@@ -1084,31 +1034,0 @@\n-\/**\n- * xmlIOFTPMatch:\n- * @filename:  the URI for matching\n- *\n- * DEPRECATED: Internal function, don't use.\n- *\n- * check if the URI matches an FTP one\n- *\n- * Returns 1 if matches, 0 otherwise\n- *\/\n-int\n-xmlIOFTPMatch (const char *filename) {\n-    if (!xmlStrncasecmp(BAD_CAST filename, BAD_CAST \"ftp:\/\/\", 6))\n-    return(1);\n-    return(0);\n-}\n-\n-\/**\n- * xmlIOFTPOpen:\n- * @filename:  the URI for matching\n- *\n- * DEPRECATED: Internal function, don't use.\n- *\n- * open an FTP I\/O channel\n- *\n- * Returns an I\/O context or NULL in case of error\n- *\/\n-void *\n-xmlIOFTPOpen (const char *filename) {\n-    return(xmlNanoFTPOpen(filename));\n-}\n@@ -1116,16 +1035,3 @@\n-\/**\n- * xmlIOFTPRead:\n- * @context:  the I\/O context\n- * @buffer:  where to drop data\n- * @len:  number of bytes to write\n- *\n- * DEPRECATED: Internal function, don't use.\n- *\n- * Read @len bytes to @buffer from the I\/O channel.\n- *\n- * Returns the number of bytes written\n- *\/\n-int\n-xmlIOFTPRead(void * context, char * buffer, int len) {\n-    if ((buffer == NULL) || (len < 0)) return(-1);\n-    return(xmlNanoFTPRead(context, &buffer[0], len));\n+static int\n+xmlIODefaultMatch(const char *filename ATTRIBUTE_UNUSED) {\n+    return(1);\n@@ -1135,4 +1041,4 @@\n- * xmlIOFTPClose:\n- * @context:  the I\/O context\n- *\n- * DEPRECATED: Internal function, don't use.\n+ * xmlInputFromFd:\n+ * @buf:  parser input buffer\n+ * @fd:  file descriptor\n+ * @flags:  flags\n@@ -1140,1 +1046,2 @@\n- * Close an FTP I\/O channel\n+ * Update the buffer to read from @fd. Supports the XML_INPUT_UNZIP\n+ * flag.\n@@ -1142,1 +1049,1 @@\n- * Returns 0\n+ * Returns an xmlParserErrors code.\n@@ -1144,19 +1051,4 @@\n-int\n-xmlIOFTPClose (void * context) {\n-    return ( xmlNanoFTPClose(context) );\n-}\n-#endif \/* LIBXML_FTP_ENABLED *\/\n-\n-\/************************************************************************\n- *                                    *\n- *            Input\/output buffers                *\n- *                                    *\n- ************************************************************************\/\n-\n-static int\n-xmlIODefaultMatch(const char *filename ATTRIBUTE_UNUSED) {\n-    return(1);\n-}\n-\n-int\n-xmlInputFromFd(xmlParserInputBufferPtr buf, int fd, int unzip) {\n+xmlParserErrors\n+xmlInputFromFd(xmlParserInputBufferPtr buf, int fd,\n+               xmlParserInputFlags flags) {\n+    xmlFdIOCtxt *fdctxt;\n@@ -1165,1 +1057,1 @@\n-    (void) unzip;\n+    (void) flags;\n@@ -1168,1 +1060,1 @@\n-    if (unzip) {\n+    if (flags & XML_INPUT_UNZIP) {\n@@ -1176,1 +1068,1 @@\n-            return(xmlIOErr(0, \"dup()\"));\n+            return(xmlIOErr(errno));\n@@ -1184,0 +1076,1 @@\n+\n@@ -1206,1 +1099,1 @@\n-    if (unzip) {\n+    if (flags & XML_INPUT_UNZIP) {\n@@ -1214,1 +1107,1 @@\n-            return(xmlIOErr(0, \"dup()\"));\n+            return(xmlIOErr(errno));\n@@ -1222,0 +1115,1 @@\n+\n@@ -1245,1 +1139,8 @@\n-        return(xmlIOErr(0, \"dup()\"));\n+        return(xmlIOErr(errno));\n+\n+    fdctxt = xmlMalloc(sizeof(*fdctxt));\n+    if (fdctxt == NULL) {\n+        close(copy);\n+        return(XML_ERR_NO_MEMORY);\n+    }\n+    fdctxt->fd = copy;\n@@ -1247,1 +1148,1 @@\n-    buf->context = (void *) (ptrdiff_t) copy;\n+    buf->context = fdctxt;\n@@ -1258,0 +1159,1 @@\n+ * @flags:  XML_INPUT flags\n@@ -1261,3 +1163,4 @@\n-static int\n-xmlInputDefaultOpen(xmlParserInputBufferPtr buf, const char *filename) {\n-    int ret;\n+static xmlParserErrors\n+xmlInputDefaultOpen(xmlParserInputBufferPtr buf, const char *filename,\n+                    xmlParserInputFlags flags) {\n+    xmlParserErrors ret;\n@@ -1266,12 +1169,0 @@\n-#ifdef LIBXML_FTP_ENABLED\n-    if (xmlIOFTPMatch(filename)) {\n-        buf->context = xmlIOFTPOpen(filename);\n-\n-        if (buf->context != NULL) {\n-            buf->readcallback = xmlIOFTPRead;\n-            buf->closecallback = xmlIOFTPClose;\n-            return(XML_ERR_OK);\n-        }\n-    }\n-#endif \/* LIBXML_FTP_ENABLED *\/\n-\n@@ -1280,0 +1171,3 @@\n+        if ((flags & XML_INPUT_NETWORK) == 0)\n+            return(XML_IO_NETWORK_ATTEMPT);\n+\n@@ -1297,1 +1191,1 @@\n-    ret = xmlInputFromFd(buf, fd, \/* unzip *\/ 1);\n+    ret = xmlInputFromFd(buf, fd, flags);\n@@ -1314,1 +1208,1 @@\n-static int\n+static xmlParserErrors\n@@ -1317,0 +1211,1 @@\n+    xmlFdIOCtxt *fdctxt;\n@@ -1325,1 +1220,1 @@\n-            return(xmlIOErr(0, \"dup()\"));\n+            return(xmlIOErr(errno));\n@@ -1344,1 +1239,1 @@\n-            return(xmlIOErr(XML_IO_UNKNOWN, \"gzdopen()\"));\n+            return(XML_IO_UNKNOWN);\n@@ -1355,1 +1250,8 @@\n-    buf->context = (void *) (ptrdiff_t) fd;\n+    fdctxt = xmlMalloc(sizeof(*fdctxt));\n+    if (fdctxt == NULL) {\n+        close(fd);\n+        return(XML_ERR_NO_MEMORY);\n+    }\n+    fdctxt->fd = fd;\n+\n+    buf->context = fdctxt;\n@@ -1366,0 +1268,2 @@\n+ * DEPRECATED: Use xmlNewInputFrom*.\n+ *\n@@ -1380,1 +1284,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1383,1 +1287,1 @@\n-    ret->buffer = xmlBufCreateSize(2 * xmlDefaultBufferSize);\n+    ret->buffer = xmlBufCreate(XML_IO_BUFFER_SIZE);\n@@ -1386,1 +1290,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1388,1 +1292,0 @@\n-    xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_DOUBLEIT);\n@@ -1390,1 +1293,1 @@\n-        if (xmlLookupCharEncodingHandler(enc, &ret->encoder) != 0) {\n+        if (xmlLookupCharEncodingHandler(enc, &ret->encoder) != XML_ERR_OK) {\n@@ -1397,1 +1300,1 @@\n-        ret->raw = xmlBufCreateSize(2 * xmlDefaultBufferSize);\n+        ret->raw = xmlBufCreate(XML_IO_BUFFER_SIZE);\n@@ -1416,0 +1319,2 @@\n+ * Consumes @encoder but not in error case.\n+ *\n@@ -1424,16 +1329,0 @@\n-    return(NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlOutputBuffer));\n-    ret->buffer = xmlBufCreate();\n-    if (ret->buffer == NULL) {\n-        xmlFree(ret);\n-    return(NULL);\n-    }\n-    xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_IO);\n-\n-    ret->encoder = encoder;\n-    if (encoder != NULL) {\n-        ret->conv = xmlBufCreateSize(4000);\n-    if (ret->conv == NULL) {\n-            xmlBufFree(ret->buffer);\n-        xmlFree(ret);\n@@ -1442,31 +1331,0 @@\n-\n-    \/*\n-     * This call is designed to initiate the encoder state\n-     *\/\n-    xmlCharEncOutput(ret, 1);\n-    } else\n-        ret->conv = NULL;\n-    ret->writecallback = NULL;\n-    ret->closecallback = NULL;\n-    ret->context = NULL;\n-    ret->written = 0;\n-\n-    return(ret);\n-}\n-\n-\/**\n- * xmlAllocOutputBufferInternal:\n- * @encoder:  the encoding converter or NULL\n- *\n- * Create a buffered parser output\n- *\n- * Returns the new parser output or NULL\n- *\/\n-xmlOutputBufferPtr\n-xmlAllocOutputBufferInternal(xmlCharEncodingHandlerPtr encoder) {\n-    xmlOutputBufferPtr ret;\n-\n-    ret = (xmlOutputBufferPtr) xmlMalloc(sizeof(xmlOutputBuffer));\n-    if (ret == NULL) {\n-    return(NULL);\n-    }\n@@ -1474,1 +1332,1 @@\n-    ret->buffer = xmlBufCreate();\n+    ret->buffer = xmlBufCreate(MINLEN);\n@@ -1477,1 +1335,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1480,6 +1338,0 @@\n-\n-    \/*\n-     * For conversion buffers we use the special IO handling\n-     *\/\n-    xmlBufSetAllocationScheme(ret->buffer, XML_BUFFER_ALLOC_IO);\n-\n@@ -1488,2 +1340,2 @@\n-        ret->conv = xmlBufCreateSize(4000);\n-    if (ret->conv == NULL) {\n+        ret->conv = xmlBufCreate(MINLEN);\n+        if (ret->conv == NULL) {\n@@ -1491,3 +1343,3 @@\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n+            xmlFree(ret);\n+            return(NULL);\n+        }\n@@ -1495,3 +1347,3 @@\n-    \/*\n-     * This call is designed to initiate the encoder state\n-     *\/\n+        \/*\n+         * This call is designed to initiate the encoder state\n+         *\/\n@@ -1508,1 +1360,0 @@\n-\n@@ -1523,1 +1374,1 @@\n-    in->raw = NULL;\n+        in->raw = NULL;\n@@ -1529,1 +1380,1 @@\n-    in->closecallback(in->context);\n+        in->closecallback(in->context);\n@@ -1533,1 +1384,1 @@\n-    in->buffer = NULL;\n+        in->buffer = NULL;\n@@ -1564,1 +1415,2 @@\n-        if ((code != XML_ERR_OK) && (out->error == XML_ERR_OK)) {\n+        if ((code != XML_ERR_OK) &&\n+            (!xmlIsCatastrophicError(XML_ERR_FATAL, out->error))) {\n@@ -1596,1 +1448,1 @@\n- * xmlParserInputBufferCreateFilenameInt:\n+ * xmlParserInputBufferCreateUrl:\n@@ -1599,0 +1451,1 @@\n+ * @flags:  XML_INPUT flags\n@@ -1603,3 +1456,4 @@\n-static int\n-xmlParserInputBufferCreateFilenameInt(const char *URI, xmlCharEncoding enc,\n-                                      xmlParserInputBufferPtr *out) {\n+xmlParserErrors\n+xmlParserInputBufferCreateUrl(const char *URI, xmlCharEncoding enc,\n+                              xmlParserInputFlags flags,\n+                              xmlParserInputBufferPtr *out) {\n@@ -1607,1 +1461,1 @@\n-    int ret;\n+    xmlParserErrors ret;\n@@ -1632,1 +1486,1 @@\n-            ret = xmlInputDefaultOpen(buf, URI);\n+            ret = xmlInputDefaultOpen(buf, URI, flags);\n@@ -1650,1 +1504,1 @@\n-    return(ret);\n+        return(ret);\n@@ -1661,1 +1515,1 @@\n-    xmlParserInputBufferCreateFilenameInt(URI, enc, &ret);\n+    xmlParserInputBufferCreateUrl(URI, enc, 0, &ret);\n@@ -1670,0 +1524,2 @@\n+ * DEPRECATED: Use xmlNewInputFromUrl.\n+ *\n@@ -1679,0 +1535,3 @@\n+    xmlParserInputBufferPtr ret;\n+    xmlParserErrors code;\n+\n@@ -1682,18 +1541,1 @@\n-    return(__xmlParserInputBufferCreateFilename(URI, enc));\n-}\n-\n-\/**\n- * xmlParserInputBufferCreateFilenameSafe:\n- * @URI:  the filename or URI\n- * @enc:  encoding enum (deprecated)\n- * @out:  pointer to resulting input buffer\n- *\n- * Create an input buffer for a filename or URI.\n- *\n- * Returns an xmlParserErrors code.\n- *\/\n-int\n-xmlParserInputBufferCreateFilenameSafe(const char *URI, xmlCharEncoding enc,\n-                                       xmlParserInputBufferPtr *out) {\n-    if (xmlParserInputBufferCreateFilenameValue != NULL) {\n-        *out = xmlParserInputBufferCreateFilenameValue(URI, enc);\n+    code = xmlParserInputBufferCreateUrl(URI, enc, 0, &ret);\n@@ -1701,3 +1543,10 @@\n-        if (*out == NULL)\n-            return(XML_IO_ENOENT);\n-        return(XML_ERR_OK);\n+    \/*\n+     * xmlParserInputBufferCreateFilename has no way to return\n+     * the kind of error although it really is crucial.\n+     * All we can do is to set the global error.\n+     *\/\n+    if ((code != XML_ERR_OK) && (code != XML_IO_ENOENT)) {\n+        if (xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_IO, code,\n+                          XML_ERR_ERROR, URI, 0, NULL, NULL, NULL, 0, 0,\n+                          \"Failed to open file\\n\") < 0)\n+            xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_IO, NULL);\n@@ -1706,1 +1555,1 @@\n-    return(xmlParserInputBufferCreateFilenameInt(URI, enc, out));\n+    return(ret);\n@@ -1714,1 +1563,1 @@\n-    xmlOutputBufferPtr ret;\n+    xmlOutputBufferPtr ret = NULL;\n@@ -1722,1 +1571,1 @@\n-        return(NULL);\n+        goto error;\n@@ -1731,5 +1580,5 @@\n-             if (unescaped == NULL) {\n-                 xmlFreeURI(puri);\n-                 return(NULL);\n-             }\n-             URI = unescaped;\n+            if (unescaped == NULL) {\n+                xmlFreeURI(puri);\n+                goto error;\n+            }\n+            URI = unescaped;\n@@ -1743,5 +1592,3 @@\n-    ret = xmlAllocOutputBufferInternal(encoder);\n-    if (ret == NULL) {\n-        xmlFree(unescaped);\n-        return(NULL);\n-    }\n+    ret = xmlAllocOutputBuffer(encoder);\n+    if (ret == NULL)\n+        goto error;\n@@ -1755,1 +1602,1 @@\n-        int code;\n+        xmlParserErrors code;\n@@ -1774,0 +1621,2 @@\n+        \/* Don't free encoder *\/\n+        ret->encoder = NULL;\n@@ -1775,1 +1624,1 @@\n-    ret = NULL;\n+        ret = NULL;\n@@ -1778,0 +1627,1 @@\n+error:\n@@ -1795,0 +1645,2 @@\n+ * Consumes @encoder but not in error case.\n+ *\n@@ -1802,3 +1654,3 @@\n-        return xmlOutputBufferCreateFilenameValue(URI, encoder, compression);\n-    }\n-    return __xmlOutputBufferCreateFilename(URI, encoder, compression);\n+                return xmlOutputBufferCreateFilenameValue(URI, encoder, compression);\n+        }\n+        return __xmlOutputBufferCreateFilename(URI, encoder, compression);\n@@ -1813,0 +1665,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -1831,2 +1685,2 @@\n-    ret->readcallback = xmlFileRead;\n-    ret->closecallback = NULL;\n+        ret->readcallback = xmlFileRead;\n+        ret->closecallback = NULL;\n@@ -1847,0 +1701,2 @@\n+ * Consumes @encoder but not in error case.\n+ *\n@@ -1853,1 +1709,3 @@\n-    if (file == NULL) return(NULL);\n+    if (file == NULL) {\n+        return(NULL);\n+    }\n@@ -1855,1 +1713,1 @@\n-    ret = xmlAllocOutputBufferInternal(encoder);\n+    ret = xmlAllocOutputBuffer(encoder);\n@@ -1858,2 +1716,2 @@\n-    ret->writecallback = xmlFileWrite;\n-    ret->closecallback = xmlFileFlush;\n+        ret->writecallback = xmlFileWrite;\n+        ret->closecallback = xmlFileFlush;\n@@ -1872,0 +1730,2 @@\n+ * Consumes @encoder but not in error case.\n+ *\n@@ -1879,1 +1739,3 @@\n-    if (buffer == NULL) return(NULL);\n+    if (buffer == NULL) {\n+        return(NULL);\n+    }\n@@ -1927,0 +1789,2 @@\n+ * DEPRECATED: Use xmlNewInputFromFd.\n+ *\n@@ -1944,2 +1808,11 @@\n-        ret->context = (void *) (ptrdiff_t) fd;\n-    ret->readcallback = xmlFdRead;\n+        xmlFdIOCtxt *fdctxt;\n+\n+        fdctxt = xmlMalloc(sizeof(*fdctxt));\n+        if (fdctxt == NULL) {\n+            return(NULL);\n+        }\n+        fdctxt->fd = fd;\n+\n+        ret->context = fdctxt;\n+        ret->readcallback = xmlFdRead;\n+        ret->closecallback = xmlFdFree;\n@@ -1952,1 +1825,0 @@\n-    char *mem;\n@@ -1975,2 +1847,0 @@\n-    if (ctxt->mem != NULL)\n-        xmlFree(ctxt->mem);\n@@ -1993,2 +1863,2 @@\n-xmlNewInputBufferMemory(const void *mem, size_t size, int flags,\n-                        xmlCharEncoding enc) {\n+xmlNewInputBufferMemory(const void *mem, size_t size,\n+                        xmlParserInputFlags flags, xmlCharEncoding enc) {\n@@ -1996,2 +1866,0 @@\n-    xmlMemIOCtxt *ctxt;\n-    char *copy = NULL;\n@@ -1999,2 +1867,10 @@\n-    if ((flags & XML_INPUT_BUF_STATIC) == 0) {\n-        if (size + 1 == 0)\n+    if ((flags & XML_INPUT_BUF_STATIC) &&\n+        ((flags & XML_INPUT_BUF_ZERO_TERMINATED) == 0)) {\n+        xmlMemIOCtxt *ctxt;\n+\n+        \/*\n+         * Static buffer without zero terminator.\n+         * Stream memory to avoid a copy.\n+         *\/\n+        ret = xmlAllocParserInputBuffer(enc);\n+        if (ret == NULL)\n@@ -2002,2 +1878,4 @@\n-        copy = xmlMalloc(size + 1);\n-        if (copy == NULL)\n+\n+        ctxt = xmlMalloc(sizeof(*ctxt));\n+        if (ctxt == NULL) {\n+            xmlFreeParserInputBuffer(ret);\n@@ -2005,2 +1883,1 @@\n-        memcpy(copy, mem, size);\n-        copy[size] = 0;\n+        }\n@@ -2008,2 +1885,2 @@\n-        mem = copy;\n-    }\n+        ctxt->cur = mem;\n+        ctxt->size = size;\n@@ -2011,5 +1888,9 @@\n-    ret = xmlAllocParserInputBuffer(enc);\n-    if (ret == NULL) {\n-        xmlFree(copy);\n-        return(NULL);\n-    }\n+        ret->context = ctxt;\n+        ret->readcallback = xmlMemRead;\n+        ret->closecallback = xmlMemClose;\n+    } else {\n+        ret = xmlMalloc(sizeof(*ret));\n+        if (ret == NULL)\n+            return(NULL);\n+        memset(ret, 0, sizeof(xmlParserInputBuffer));\n+        ret->compressed = -1;\n@@ -2017,5 +1898,6 @@\n-    ctxt = xmlMalloc(sizeof(*ctxt));\n-    if (ctxt == NULL) {\n-        xmlFreeParserInputBuffer(ret);\n-        xmlFree(copy);\n-        return(NULL);\n+        ret->buffer = xmlBufCreateMem((const xmlChar *) mem, size,\n+                                      (flags & XML_INPUT_BUF_STATIC ? 1 : 0));\n+        if (ret->buffer == NULL) {\n+            xmlFree(ret);\n+            return(NULL);\n+        }\n@@ -2024,8 +1906,0 @@\n-    ctxt->mem = copy;\n-    ctxt->cur = mem;\n-    ctxt->size = size;\n-\n-    ret->context = ctxt;\n-    ret->readcallback = xmlMemRead;\n-    ret->closecallback = xmlMemClose;\n-\n@@ -2041,0 +1915,2 @@\n+ * DEPRECATED: Use xmlNewInputFromMemory.\n+ *\n@@ -2068,0 +1944,2 @@\n+ * DEPRECATED: Use xmlNewInputFromMemory.\n+ *\n@@ -2089,25 +1967,0 @@\n-typedef struct {\n-    const char *str;\n-} xmlStringIOCtxt;\n-\n-static int\n-xmlStringRead(void *vctxt, char *buf, int size) {\n-    xmlStringIOCtxt *ctxt = vctxt;\n-    const char *zero;\n-    size_t len;\n-\n-    zero = memchr(ctxt->str, 0, size);\n-    len = zero ? zero - ctxt->str : size;\n-\n-    memcpy(buf, ctxt->str, len);\n-    ctxt->str += len;\n-\n-    return(len);\n-}\n-\n-static int\n-xmlStringClose(void *vctxt) {\n-    xmlFree(vctxt);\n-    return(0);\n-}\n-\n@@ -2119,1 +1972,3 @@\n- * Create an input buffer for a null-teriminated C string.\n+ * DEPRECATED: Use xmlNewInputFromString.\n+ *\n+ * Create an input buffer for a null-terminated C string.\n@@ -2124,1 +1979,1 @@\n-xmlNewInputBufferString(const char *str, int flags) {\n+xmlNewInputBufferString(const char *str, xmlParserInputFlags flags) {\n@@ -2126,5 +1981,0 @@\n-    xmlStringIOCtxt *ctxt;\n-\n-    if ((flags & XML_INPUT_BUF_STATIC) == 0)\n-        return(xmlNewInputBufferMemory(str, strlen(str), flags,\n-                                       XML_CHAR_ENCODING_NONE));\n@@ -2132,1 +1982,1 @@\n-    ret = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);\n+    ret = xmlMalloc(sizeof(*ret));\n@@ -2135,0 +1985,2 @@\n+    memset(ret, 0, sizeof(xmlParserInputBuffer));\n+    ret->compressed = -1;\n@@ -2136,3 +1988,4 @@\n-    ctxt = xmlMalloc(sizeof(*ctxt));\n-    if (ctxt == NULL) {\n-        xmlFreeParserInputBuffer(ret);\n+    ret->buffer = xmlBufCreateMem((const xmlChar *) str, strlen(str),\n+                                  (flags & XML_INPUT_BUF_STATIC ? 1 : 0));\n+    if (ret->buffer == NULL) {\n+        xmlFree(ret);\n@@ -2142,6 +1995,0 @@\n-    ctxt->str = str;\n-\n-    ret->context = ctxt;\n-    ret->readcallback = xmlStringRead;\n-    ret->closecallback = xmlStringClose;\n-\n@@ -2160,0 +2007,2 @@\n+ * Consumes @encoder but not in error case.\n+ *\n@@ -2166,1 +2015,3 @@\n-    if (fd < 0) return(NULL);\n+    if (fd < 0) {\n+        return(NULL);\n+    }\n@@ -2168,1 +2019,1 @@\n-    ret = xmlAllocOutputBufferInternal(encoder);\n+    ret = xmlAllocOutputBuffer(encoder);\n@@ -2170,3 +2021,11 @@\n-        ret->context = (void *) (ptrdiff_t) fd;\n-    ret->writecallback = xmlFdWrite;\n-    ret->closecallback = NULL;\n+        xmlFdIOCtxt *fdctxt;\n+\n+        fdctxt = xmlMalloc(sizeof(*fdctxt));\n+        if (fdctxt == NULL) {\n+            return(NULL);\n+        }\n+        fdctxt->fd = fd;\n+\n+        ret->context = fdctxt;\n+        ret->writecallback = xmlFdWrite;\n+        ret->closecallback = xmlFdFree;\n@@ -2186,0 +2045,2 @@\n+ * DEPRECATED: Use xmlNewInputFromIO.\n+ *\n@@ -2197,1 +2058,1 @@\n-     xmlInputCloseCallback  ioclose, void *ioctx, xmlCharEncoding enc) {\n+         xmlInputCloseCallback  ioclose, void *ioctx, xmlCharEncoding enc) {\n@@ -2205,2 +2066,2 @@\n-    ret->readcallback = ioread;\n-    ret->closecallback = ioclose;\n+        ret->readcallback = ioread;\n+        ret->closecallback = ioclose;\n@@ -2223,0 +2084,2 @@\n+ * Consumes @encoder but not in error case.\n+ *\n@@ -2227,2 +2090,2 @@\n-     xmlOutputCloseCallback  ioclose, void *ioctx,\n-     xmlCharEncodingHandlerPtr encoder) {\n+         xmlOutputCloseCallback  ioclose, void *ioctx,\n+         xmlCharEncodingHandlerPtr encoder) {\n@@ -2231,1 +2094,3 @@\n-    if (iowrite == NULL) return(NULL);\n+    if (iowrite == NULL) {\n+        return(NULL);\n+    }\n@@ -2233,1 +2098,1 @@\n-    ret = xmlAllocOutputBufferInternal(encoder);\n+    ret = xmlAllocOutputBuffer(encoder);\n@@ -2236,2 +2101,2 @@\n-    ret->writecallback = iowrite;\n-    ret->closecallback = ioclose;\n+        ret->writecallback = iowrite;\n+        ret->closecallback = ioclose;\n@@ -2248,0 +2113,2 @@\n+ * DEPRECATED: Use xmlCtxtSetResourceLoader or similar functions.\n+ *\n@@ -2282,2 +2149,2 @@\n-        old = __xmlOutputBufferCreateFilename;\n-    }\n+                old = __xmlOutputBufferCreateFilename;\n+        }\n@@ -2295,0 +2162,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -2304,2 +2173,2 @@\n-                     int len, const char *buf) {\n-    int nbchars = 0;\n+                         int len, const char *buf) {\n+    size_t nbchars = 0;\n@@ -2312,2 +2181,2 @@\n-     * Store the data in the incoming raw buffer\n-     *\/\n+         * Store the data in the incoming raw buffer\n+         *\/\n@@ -2315,1 +2184,1 @@\n-        in->raw = xmlBufCreate();\n+            in->raw = xmlBufCreate(50);\n@@ -2320,3 +2189,3 @@\n-    }\n-    ret = xmlBufAdd(in->raw, (const xmlChar *) buf, len);\n-    if (ret != 0) {\n+        }\n+        ret = xmlBufAdd(in->raw, (const xmlChar *) buf, len);\n+        if (ret != 0) {\n@@ -2324,1 +2193,1 @@\n-        return(-1);\n+            return(-1);\n@@ -2327,6 +2196,9 @@\n-    \/*\n-     * convert as much as possible to the parser reading buffer.\n-     *\/\n-    nbchars = xmlCharEncInput(in);\n-    if (nbchars < 0)\n-        return(-1);\n+        \/*\n+         * convert as much as possible to the parser reading buffer.\n+         *\/\n+        nbchars = SIZE_MAX;\n+        if (xmlCharEncInput(in, &nbchars, \/* flush *\/ 0) !=\n+            XML_ENC_ERR_SUCCESS)\n+            return(-1);\n+        if (nbchars > INT_MAX)\n+            nbchars = INT_MAX;\n@@ -2334,1 +2206,1 @@\n-    nbchars = len;\n+        nbchars = len;\n@@ -2336,1 +2208,1 @@\n-    if (ret != 0) {\n+        if (ret != 0) {\n@@ -2338,1 +2210,1 @@\n-        return(-1);\n+            return(-1);\n@@ -2352,2 +2224,2 @@\n-        char * buffer ATTRIBUTE_UNUSED,\n-        int len ATTRIBUTE_UNUSED) {\n+            char * buffer ATTRIBUTE_UNUSED,\n+            int len ATTRIBUTE_UNUSED) {\n@@ -2362,0 +2234,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -2366,3 +2240,0 @@\n- * TODO: one should be able to remove one extra copy by copying directly\n- *       onto in->buffer or in->raw\n- *\n@@ -2374,1 +2245,0 @@\n-    xmlBufPtr buf;\n@@ -2377,3 +2247,2 @@\n-    if ((in == NULL) || (in->error)) return(-1);\n-    if ((len <= MINLEN) && (len != 4))\n-        len = MINLEN;\n+    if ((in == NULL) || (in->error))\n+        return(-1);\n@@ -2381,10 +2250,2 @@\n-    if (in->encoder == NULL) {\n-        if (in->readcallback == NULL)\n-            return(0);\n-        buf = in->buffer;\n-    } else {\n-        if (in->raw == NULL) {\n-        in->raw = xmlBufCreate();\n-    }\n-        buf = in->raw;\n-    }\n+    if (len < MINLEN)\n+        len = MINLEN;\n@@ -2396,1 +2257,20 @@\n-        if (xmlBufGrow(buf, len + 1) < 0) {\n+        xmlBufPtr buf;\n+\n+        if (in->encoder == NULL) {\n+            buf = in->buffer;\n+        } else {\n+            \/*\n+             * Some users only set 'encoder' and expect us to create\n+             * the raw buffer lazily.\n+             *\/\n+            if (in->raw == NULL) {\n+                in->raw = xmlBufCreate(XML_IO_BUFFER_SIZE);\n+                if (in->raw == NULL) {\n+                    in->error = XML_ERR_NO_MEMORY;\n+                    return(-1);\n+                }\n+            }\n+            buf = in->raw;\n+        }\n+\n+        if (xmlBufGrow(buf, len) < 0) {\n@@ -2401,3 +2281,3 @@\n-    res = in->readcallback(in->context, (char *)xmlBufEnd(buf), len);\n-    if (res <= 0)\n-        in->readcallback = endOfInput;\n+        res = in->readcallback(in->context, (char *)xmlBufEnd(buf), len);\n+        if (res <= 0)\n+            in->readcallback = endOfInput;\n@@ -2419,1 +2299,1 @@\n-     * try to establish compressed status of input if not done already\n+     * Handle encoding.\n@@ -2421,7 +2301,0 @@\n-    if (in->compressed == -1) {\n-#ifdef LIBXML_LZMA_ENABLED\n-    if (in->readcallback == xmlXzfileRead)\n-            in->compressed = __libxml2_xzcompressed(in->context);\n-#endif\n-    }\n-\n@@ -2429,3 +2302,14 @@\n-    res = xmlCharEncInput(in);\n-    if (res < 0)\n-        return(-1);\n+        size_t sizeOut;\n+\n+        \/*\n+         * Don't convert whole buffer when reading from memory.\n+         *\/\n+        if (in->readcallback == NULL)\n+            sizeOut = len;\n+        else\n+            sizeOut = SIZE_MAX;\n+\n+        if (xmlCharEncInput(in, &sizeOut, \/* flush *\/ 0) !=\n+            XML_ENC_ERR_SUCCESS)\n+            return(-1);\n+        res = sizeOut;\n@@ -2441,3 +2325,3 @@\n- * Refresh the content of the input buffer, the old data are considered\n- * consumed\n- * This routine handle the I18N transcoding to internal UTF-8\n+ * DEPRECATED: Internal function, don't use.\n+ *\n+ * Same as xmlParserInputBufferGrow.\n@@ -2458,1 +2342,1 @@\n- * @buf:  an char array\n+ * @data:  an char array\n@@ -2469,5 +2353,4 @@\n-xmlOutputBufferWrite(xmlOutputBufferPtr out, int len, const char *buf) {\n-    int nbchars = 0; \/* number of chars to output to I\/O *\/\n-    int ret;         \/* return from function call *\/\n-    int written = 0; \/* number of char written to I\/O so far *\/\n-    int chunk;       \/* number of byte current processed from buf *\/\n+xmlOutputBufferWrite(xmlOutputBufferPtr out, int len, const char *data) {\n+    xmlBufPtr buf = NULL;\n+    size_t written = 0;\n+    int ret;\n@@ -2475,3 +2358,4 @@\n-    if ((out == NULL) || (out->error)) return(-1);\n-    if (len < 0) return(0);\n-    if (out->error) return(-1);\n+    if ((out == NULL) || (out->error))\n+        return(-1);\n+    if (len < 0)\n+        return(0);\n@@ -2479,4 +2363,5 @@\n-    do {\n-    chunk = len;\n-    if (chunk > 4 * MINLEN)\n-        chunk = 4 * MINLEN;\n+    ret = xmlBufAdd(out->buffer, (const xmlChar *) data, len);\n+    if (ret != 0) {\n+        out->error = XML_ERR_NO_MEMORY;\n+        return(-1);\n+    }\n@@ -2492,8 +2377,2 @@\n-        out->conv = xmlBufCreate();\n-                if (out->conv == NULL) {\n-                    out->error = XML_ERR_NO_MEMORY;\n-                    return(-1);\n-                }\n-        }\n-        ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);\n-        if (ret != 0) {\n+            out->conv = xmlBufCreate(MINLEN);\n+            if (out->conv == NULL) {\n@@ -2501,1 +2380,1 @@\n-            return(-1);\n+                return(-1);\n@@ -2503,3 +2382,1 @@\n-\n-        if ((xmlBufUse(out->buffer) < MINLEN) && (chunk == len))\n-        goto done;\n+        }\n@@ -2510,7 +2387,12 @@\n-        ret = xmlCharEncOutput(out, 0);\n-        if (ret < 0)\n-        return(-1);\n-            if (out->writecallback)\n-            nbchars = xmlBufUse(out->conv);\n-            else\n-                nbchars = ret >= 0 ? ret : 0;\n+        if (xmlBufUse(out->buffer) < 256) {\n+            ret = 0;\n+        } else {\n+            ret = xmlCharEncOutput(out, 0);\n+            if (ret < 0)\n+                return(-1);\n+        }\n+\n+        if (out->writecallback)\n+            buf = out->conv;\n+        else\n+            written = ret;\n@@ -2518,9 +2400,4 @@\n-        ret = xmlBufAdd(out->buffer, (const xmlChar *) buf, chunk);\n-        if (ret != 0) {\n-                out->error = XML_ERR_NO_MEMORY;\n-            return(-1);\n-            }\n-            if (out->writecallback)\n-            nbchars = xmlBufUse(out->buffer);\n-            else\n-                nbchars = chunk;\n+        if (out->writecallback)\n+            buf = out->buffer;\n+        else\n+            written = len;\n@@ -2528,6 +2405,0 @@\n-    buf += chunk;\n-    len -= chunk;\n-\n-    if (out->writecallback) {\n-            if ((nbchars < MINLEN) && (len <= 0))\n-                goto done;\n@@ -2535,0 +2406,1 @@\n+    if ((buf != NULL) && (out->writecallback)) {\n@@ -2538,13 +2410,2 @@\n-        if (out->encoder != NULL) {\n-        ret = out->writecallback(out->context,\n-                           (const char *)xmlBufContent(out->conv), nbchars);\n-        if (ret >= 0)\n-            xmlBufShrink(out->conv, ret);\n-        } else {\n-        ret = out->writecallback(out->context,\n-                           (const char *)xmlBufContent(out->buffer), nbchars);\n-        if (ret >= 0)\n-            xmlBufShrink(out->buffer, ret);\n-        }\n-        if (ret < 0) {\n-                int errNo = (ret == -1) ? XML_IO_WRITE : -ret;\n+        while (1) {\n+            size_t nbchars = xmlBufUse(buf);\n@@ -2552,4 +2413,16 @@\n-        xmlIOErr(errNo, NULL);\n-        out->error = errNo;\n-        return(ret);\n-        }\n+            if (nbchars < MINLEN)\n+                break;\n+\n+            ret = out->writecallback(out->context,\n+                       (const char *)xmlBufContent(buf), nbchars);\n+            if (ret < 0) {\n+                out->error = (ret == -1) ? XML_IO_WRITE : -ret;\n+                return(-1);\n+            }\n+            if ((ret == 0) || ((size_t) ret > nbchars)) {\n+                out->error = XML_ERR_INTERNAL_ERROR;\n+                return(-1);\n+            }\n+\n+            xmlBufShrink(buf, ret);\n+            written += ret;\n@@ -2560,0 +2433,1 @@\n+        }\n@@ -2561,2 +2435,0 @@\n-    written += nbchars;\n-    } while (len > 0);\n@@ -2564,62 +2436,1 @@\n-done:\n-    return(written);\n-}\n-\n-\/**\n- * xmlEscapeContent:\n- * @out:  a pointer to an array of bytes to store the result\n- * @outlen:  the length of @out\n- * @in:  a pointer to an array of unescaped UTF-8 bytes\n- * @inlen:  the length of @in\n- *\n- * Take a block of UTF-8 chars in and escape them.\n- * Returns 0 if success, or -1 otherwise\n- * The value of @inlen after return is the number of octets consumed\n- *     if the return value is positive, else unpredictable.\n- * The value of @outlen after return is the number of octets consumed.\n- *\/\n-static int\n-xmlEscapeContent(unsigned char* out, int *outlen,\n-                 const xmlChar* in, int *inlen) {\n-    unsigned char* outstart = out;\n-    const unsigned char* base = in;\n-    unsigned char* outend = out + *outlen;\n-    const unsigned char* inend;\n-\n-    inend = in + (*inlen);\n-\n-    while ((in < inend) && (out < outend)) {\n-    if (*in == '<') {\n-        if (outend - out < 4) break;\n-        *out++ = '&';\n-        *out++ = 'l';\n-        *out++ = 't';\n-        *out++ = ';';\n-    } else if (*in == '>') {\n-        if (outend - out < 4) break;\n-        *out++ = '&';\n-        *out++ = 'g';\n-        *out++ = 't';\n-        *out++ = ';';\n-    } else if (*in == '&') {\n-        if (outend - out < 5) break;\n-        *out++ = '&';\n-        *out++ = 'a';\n-        *out++ = 'm';\n-        *out++ = 'p';\n-        *out++ = ';';\n-    } else if (*in == '\\r') {\n-        if (outend - out < 5) break;\n-        *out++ = '&';\n-        *out++ = '#';\n-        *out++ = '1';\n-        *out++ = '3';\n-        *out++ = ';';\n-    } else {\n-        *out++ = *in;\n-    }\n-    ++in;\n-    }\n-    *outlen = out - outstart;\n-    *inlen = in - base;\n-    return(0);\n+    return(written <= INT_MAX ? written : INT_MAX);\n@@ -2646,10 +2457,5 @@\n-    int nbchars = 0; \/* number of chars to output to I\/O *\/\n-    int ret;         \/* return from function call *\/\n-    int written = 0; \/* number of char written to I\/O so far *\/\n-    int oldwritten=0;\/* loop guard *\/\n-    int chunk;       \/* number of byte currently processed from str *\/\n-    int len;         \/* number of bytes in str *\/\n-    int cons;        \/* byte from str consumed *\/\n-\n-    if ((out == NULL) || (out->error) || (str == NULL) ||\n-        (out->buffer == NULL))\n+    int ret;\n+    int written = 0;\n+    size_t len;\n+\n+    if ((out == NULL) || (out->error) || (str == NULL))\n@@ -2657,4 +2463,0 @@\n-    len = strlen((const char *)str);\n-    if (len < 0) return(0);\n-    if (out->error) return(-1);\n-    if (escaping == NULL) escaping = xmlEscapeContent;\n@@ -2662,2 +2464,5 @@\n-    do {\n-        oldwritten = written;\n+    len = strlen((const char *) str);\n+    if (len >= INT_MAX) {\n+        out->error = XML_ERR_RESOURCE_LIMIT;\n+        return(-1);\n+    }\n@@ -2665,5 +2470,2 @@\n-        \/*\n-     * how many bytes to consume and how many bytes to store.\n-     *\/\n-    cons = len;\n-    chunk = xmlBufAvail(out->buffer);\n+    if (escaping == NULL) {\n+        char *escaped = (char *) xmlEscapeText(str, XML_ESCAPE_ALLOW_INVALID);\n@@ -2671,7 +2473,2 @@\n-        \/*\n-     * make sure we have enough room to save first, if this is\n-     * not the case force a flush, but make sure we stay in the loop\n-     *\/\n-    if (chunk < 40) {\n-        if (xmlBufGrow(out->buffer, 100) < 0) {\n-                out->error = XML_ERR_NO_MEMORY;\n+        if (escaped == NULL) {\n+            out->error = XML_ERR_NO_MEMORY;\n@@ -2679,4 +2476,1 @@\n-            }\n-            oldwritten = -1;\n-        continue;\n-    }\n+        }\n@@ -2684,13 +2478,4 @@\n-    \/*\n-     * first handle encoding stuff.\n-     *\/\n-    if (out->encoder != NULL) {\n-        \/*\n-         * Store the data in the incoming raw buffer\n-         *\/\n-        if (out->conv == NULL) {\n-        out->conv = xmlBufCreate();\n-                if (out->conv == NULL) {\n-                    out->error = XML_ERR_NO_MEMORY;\n-                    return(-1);\n-                }\n+        len = strlen(escaped);\n+        if (len >= INT_MAX) {\n+            out->error = XML_ERR_RESOURCE_LIMIT;\n+            return(-1);\n@@ -2698,7 +2483,0 @@\n-        ret = escaping(xmlBufEnd(out->buffer) ,\n-                       &chunk, str, &cons);\n-            if (ret < 0) {\n-                out->error = XML_ERR_NO_MEMORY;\n-                return(-1);\n-            }\n-            xmlBufAddLen(out->buffer, chunk);\n@@ -2706,2 +2484,1 @@\n-        if ((xmlBufUse(out->buffer) < MINLEN) && (cons == len))\n-        goto done;\n+        ret = xmlOutputBufferWrite(out, len, escaped);\n@@ -2709,21 +2486,2 @@\n-        \/*\n-         * convert as much as possible to the output buffer.\n-         *\/\n-        ret = xmlCharEncOutput(out, 0);\n-        if (ret < 0)\n-        return(-1);\n-            if (out->writecallback)\n-            nbchars = xmlBufUse(out->conv);\n-            else\n-                nbchars = ret >= 0 ? ret : 0;\n-    } else {\n-        ret = escaping(xmlBufEnd(out->buffer), &chunk, str, &cons);\n-            if (ret < 0) {\n-                out->error = XML_ERR_NO_MEMORY;\n-                return(-1);\n-            }\n-            xmlBufAddLen(out->buffer, chunk);\n-            if (out->writecallback)\n-            nbchars = xmlBufUse(out->buffer);\n-            else\n-                nbchars = chunk;\n+        xmlFree(escaped);\n+        return(ret);\n@@ -2731,2 +2489,0 @@\n-    str += cons;\n-    len -= cons;\n@@ -2734,3 +2490,4 @@\n-    if (out->writecallback) {\n-            if ((nbchars < MINLEN) && (len <= 0))\n-                goto done;\n+    while (len > 0) {\n+        xmlChar buf[1024];\n+        int c_out;\n+        int c_in;\n@@ -2738,14 +2495,4 @@\n-        \/*\n-         * second write the stuff to the I\/O channel\n-         *\/\n-        if (out->encoder != NULL) {\n-        ret = out->writecallback(out->context,\n-                           (const char *)xmlBufContent(out->conv), nbchars);\n-        if (ret >= 0)\n-            xmlBufShrink(out->conv, ret);\n-        } else {\n-        ret = out->writecallback(out->context,\n-                           (const char *)xmlBufContent(out->buffer), nbchars);\n-        if (ret >= 0)\n-            xmlBufShrink(out->buffer, ret);\n-        }\n+        c_out = 1024;\n+        c_in = len;\n+\n+        ret = escaping(buf, &c_out, str, &c_in);\n@@ -2753,4 +2500,2 @@\n-                int errNo = (ret == -1) ? XML_IO_WRITE : -ret;\n-        xmlIOErr(errNo, NULL);\n-        out->error = errNo;\n-        return(-1);\n+            out->error = XML_ERR_NO_MEMORY;\n+            return(-1);\n@@ -2758,9 +2503,7 @@\n-            if (out->written > INT_MAX - ret)\n-                out->written = INT_MAX;\n-            else\n-                out->written += ret;\n-    } else if (xmlBufAvail(out->buffer) < MINLEN) {\n-            if (xmlBufGrow(out->buffer, MINLEN) < 0) {\n-                out->error = XML_ERR_NO_MEMORY;\n-                return(-1);\n-            }\n+        str += c_in;\n+        len -= c_in;\n+\n+        ret = xmlOutputBufferWrite(out, c_out, (char *) buf);\n+        if (ret < 0)\n+            return(ret);\n+        written += ret;\n@@ -2768,2 +2511,0 @@\n-    written += nbchars;\n-    } while ((len > 0) && (oldwritten != written));\n@@ -2771,1 +2512,0 @@\n-done:\n@@ -2798,1 +2538,1 @@\n-    return(xmlOutputBufferWrite(out, len, str));\n+        return(xmlOutputBufferWrite(out, len, str));\n@@ -2821,1 +2561,1 @@\n-        xmlOutputBufferWrite(buf, 1, \"\\\"\");\n+            xmlOutputBufferWrite(buf, 1, \"\\\"\");\n@@ -2838,2 +2578,2 @@\n-        xmlOutputBufferWrite(buf, 1, \"\\\"\");\n-    }\n+            xmlOutputBufferWrite(buf, 1, \"\\\"\");\n+        }\n@@ -2841,1 +2581,1 @@\n-        xmlOutputBufferWrite(buf, 1, \"'\");\n+            xmlOutputBufferWrite(buf, 1, \"'\");\n@@ -2843,1 +2583,1 @@\n-        xmlOutputBufferWrite(buf, 1, \"'\");\n+            xmlOutputBufferWrite(buf, 1, \"'\");\n@@ -2869,8 +2609,8 @@\n-    \/*\n-     * convert as much as possible to the parser output buffer.\n-     *\/\n-    do {\n-        nbchars = xmlCharEncOutput(out, 0);\n-        if (nbchars < 0)\n-        return(-1);\n-    } while (nbchars);\n+        \/*\n+         * convert as much as possible to the parser output buffer.\n+         *\/\n+        do {\n+            nbchars = xmlCharEncOutput(out, 0);\n+            if (nbchars < 0)\n+                return(-1);\n+        } while (nbchars);\n@@ -2883,2 +2623,2 @@\n-    (out->writecallback != NULL)) {\n-    ret = out->writecallback(out->context,\n+        (out->writecallback != NULL)) {\n+        ret = out->writecallback(out->context,\n@@ -2887,2 +2627,2 @@\n-    if (ret >= 0)\n-        xmlBufShrink(out->conv, ret);\n+        if (ret >= 0)\n+            xmlBufShrink(out->conv, ret);\n@@ -2890,1 +2630,1 @@\n-    ret = out->writecallback(out->context,\n+        ret = out->writecallback(out->context,\n@@ -2893,2 +2633,2 @@\n-    if (ret >= 0)\n-        xmlBufShrink(out->buffer, ret);\n+        if (ret >= 0)\n+            xmlBufShrink(out->buffer, ret);\n@@ -2897,5 +2637,2 @@\n-        int errNo = (ret == -1) ? XML_IO_WRITE : -ret;\n-\n-        xmlIOErr(errNo, NULL);\n-        out->error = errNo;\n-    return(ret);\n+        out->error = (ret == -1) ? XML_IO_WRITE : -ret;\n+        return(ret);\n@@ -2939,1 +2676,1 @@\n-     cur --;\n+         cur --;\n@@ -2943,2 +2680,2 @@\n-    else *cur = 0;\n-    ret = xmlMemStrdup(dir);\n+        else *cur = 0;\n+        ret = xmlMemStrdup(dir);\n@@ -2968,1 +2705,1 @@\n-    return(0);\n+        return(0);\n@@ -2983,3 +2720,3 @@\n- *                                    *\n- *            Input\/output callbacks                *\n- *                                    *\n+ *                                                                      *\n+ *                      Input\/output callbacks                          *\n+ *                                                                      *\n@@ -3012,0 +2749,2 @@\n+ * DEPRECATED: Use xmlCtxtSetResourceLoader or similar functions.\n+ *\n@@ -3018,2 +2757,2 @@\n-    xmlInputOpenCallback openFunc, xmlInputReadCallback readFunc,\n-    xmlInputCloseCallback closeFunc) {\n+        xmlInputOpenCallback openFunc, xmlInputReadCallback readFunc,\n+        xmlInputCloseCallback closeFunc) {\n@@ -3023,1 +2762,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3091,2 +2830,2 @@\n-    xmlOutputOpenCallback openFunc, xmlOutputWriteCallback writeFunc,\n-    xmlOutputCloseCallback closeFunc) {\n+        xmlOutputOpenCallback openFunc, xmlOutputWriteCallback writeFunc,\n+        xmlOutputCloseCallback closeFunc) {\n@@ -3096,1 +2835,1 @@\n-    return(-1);\n+        return(-1);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlIO.c","additions":590,"deletions":851,"binary":false,"changes":1441,"status":"modified"},{"patch":"@@ -20,0 +20,1 @@\n+#include \"private\/error.h\"\n@@ -28,3 +29,3 @@\n- *                                    *\n- *        Macros, variables and associated types            *\n- *                                    *\n+ *                                                                      *\n+ *              Macros, variables and associated types                  *\n+ *                                                                      *\n@@ -50,1 +51,1 @@\n-              \/ ALIGN_SIZE ) * ALIGN_SIZE)\n+                      \/ ALIGN_SIZE ) * ALIGN_SIZE)\n@@ -106,2 +107,1 @@\n-    if (size > (MAX_SIZE_T - RESERVE_SIZE)) {\n-        fprintf(stderr, \"xmlMemMalloc: Unsigned overflow\\n\");\n+    if (size > (MAX_SIZE_T - RESERVE_SIZE))\n@@ -109,1 +109,0 @@\n-    }\n@@ -112,2 +111,1 @@\n-    if (!p) {\n-        fprintf(stderr, \"xmlMemMalloc: Out of memory\\n\");\n+    if (!p)\n@@ -115,1 +113,0 @@\n-    }\n@@ -164,2 +161,1 @@\n-    if (size > (MAX_SIZE_T - RESERVE_SIZE)) {\n-        fprintf(stderr, \"xmlMemRealloc: Unsigned overflow\\n\");\n+    if (size > (MAX_SIZE_T - RESERVE_SIZE))\n@@ -167,1 +163,0 @@\n-    }\n@@ -171,1 +166,1 @@\n-        fprintf(stderr, \"xmlMemRealloc: Tag error\\n\");\n+        xmlPrintErrorMessage(\"xmlMemRealloc: Tag error\\n\");\n@@ -180,1 +175,0 @@\n-        fprintf(stderr, \"xmlMemRealloc: Out of memory\\n\");\n@@ -210,1 +204,1 @@\n-        fprintf(stderr, \"xmlMemFree: Pointer from freed area\\n\");\n+        xmlPrintErrorMessage(\"xmlMemFree: Pointer from freed area\\n\");\n@@ -216,1 +210,1 @@\n-        fprintf(stderr, \"xmlMemFree: Tag error\\n\");\n+        xmlPrintErrorMessage(\"xmlMemFree: Tag error\\n\");\n@@ -228,2 +222,0 @@\n-\n-    return;\n@@ -265,2 +257,1 @@\n-    if (size > (MAX_SIZE_T - RESERVE_SIZE)) {\n-        fprintf(stderr, \"xmlMemoryStrdup: Unsigned overflow\\n\");\n+    if (size > (MAX_SIZE_T - RESERVE_SIZE))\n@@ -268,1 +259,0 @@\n-    }\n@@ -271,2 +261,1 @@\n-    if (!p) {\n-        fprintf(stderr, \"xmlMemoryStrdup: Out of memory\\n\");\n+    if (!p)\n@@ -274,1 +263,0 @@\n-    }\n@@ -302,1 +290,1 @@\n-    return(0);\n+        return(0);\n@@ -389,3 +377,3 @@\n- *                                *\n- *        Initialization Routines                *\n- *                                *\n+ *                                                              *\n+ *              Initialization Routines                         *\n+ *                                                              *\n@@ -468,1 +456,1 @@\n-    return(-1);\n+        return(-1);\n@@ -470,1 +458,1 @@\n-    return(-1);\n+        return(-1);\n@@ -472,1 +460,1 @@\n-    return(-1);\n+        return(-1);\n@@ -474,1 +462,1 @@\n-    return(-1);\n+        return(-1);\n@@ -496,1 +484,1 @@\n-      xmlReallocFunc *reallocFunc, xmlStrdupFunc *strdupFunc) {\n+          xmlReallocFunc *reallocFunc, xmlStrdupFunc *strdupFunc) {\n@@ -512,0 +500,2 @@\n+ * DEPRECATED: Use xmlMemSetup.\n+ *\n@@ -525,1 +515,1 @@\n-          xmlStrdupFunc strdupFunc) {\n+              xmlStrdupFunc strdupFunc) {\n@@ -527,1 +517,1 @@\n-    return(-1);\n+        return(-1);\n@@ -529,1 +519,1 @@\n-    return(-1);\n+        return(-1);\n@@ -531,1 +521,1 @@\n-    return(-1);\n+        return(-1);\n@@ -533,1 +523,1 @@\n-    return(-1);\n+        return(-1);\n@@ -535,1 +525,1 @@\n-    return(-1);\n+        return(-1);\n@@ -552,0 +542,2 @@\n+ * DEPRECATED: xmlMemGet.\n+ *\n@@ -561,1 +553,1 @@\n-        xmlStrdupFunc *strdupFunc) {\n+            xmlStrdupFunc *strdupFunc) {\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlmemory.c","additions":33,"deletions":41,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -32,0 +32,2 @@\n+#endif\n+#ifdef LIBXML_SCHEMAS_ENABLED\n@@ -44,1 +46,2 @@\n-#include \"private\/tree.h\"\n+#include \"private\/io.h\"\n+#include \"private\/memory.h\"\n@@ -46,0 +49,1 @@\n+#include \"private\/tree.h\"\n@@ -67,4 +71,4 @@\n- *                                    *\n- *    The parser: maps the Text Reader API on top of the existing    *\n- *        parsing routines building a tree            *\n- *                                    *\n+ *                                                                      *\n+ *      The parser: maps the Text Reader API on top of the existing     *\n+ *              parsing routines building a tree                        *\n+ *                                                                      *\n@@ -74,1 +78,1 @@\n-#define XML_TEXTREADER_CTXT    2\n+#define XML_TEXTREADER_CTXT     2\n@@ -95,2 +99,2 @@\n-    int                mode;    \/* the parsing mode *\/\n-    xmlDocPtr            doc;    \/* when walking an existing doc *\/\n+    int                         mode;   \/* the parsing mode *\/\n+    xmlDocPtr                   doc;    \/* when walking an existing doc *\/\n@@ -98,20 +102,20 @@\n-    int                allocs;    \/* what structure were deallocated *\/\n-    xmlTextReaderState        state;\n-    xmlParserCtxtPtr        ctxt;    \/* the parser context *\/\n-    xmlSAXHandlerPtr        sax;    \/* the parser SAX callbacks *\/\n-    xmlParserInputBufferPtr    input;    \/* the input *\/\n-    startElementSAXFunc        startElement;\/* initial SAX callbacks *\/\n-    endElementSAXFunc        endElement;  \/* idem *\/\n-    startElementNsSAX2Func    startElementNs;\/* idem *\/\n-    endElementNsSAX2Func    endElementNs;  \/* idem *\/\n-    charactersSAXFunc        characters;\n-    cdataBlockSAXFunc        cdataBlock;\n-    unsigned int        base;    \/* base of the segment in the input *\/\n-    unsigned int        cur;    \/* current position in the input *\/\n-    xmlNodePtr            node;    \/* current node *\/\n-    xmlNodePtr            curnode;\/* current attribute node *\/\n-    int                depth;  \/* depth of the current node *\/\n-    xmlNodePtr            faketext;\/* fake xmlNs chld *\/\n-    int                preserve;\/* preserve the resulting document *\/\n-    xmlBufPtr                buffer; \/* used to return const xmlChar * *\/\n-    xmlDictPtr            dict;    \/* the context dictionary *\/\n+    int                         allocs; \/* what structure were deallocated *\/\n+    xmlTextReaderState          state;\n+    xmlParserCtxtPtr            ctxt;   \/* the parser context *\/\n+    xmlSAXHandlerPtr            sax;    \/* the parser SAX callbacks *\/\n+    xmlParserInputBufferPtr     input;  \/* the input *\/\n+    startElementSAXFunc         startElement;\/* initial SAX callbacks *\/\n+    endElementSAXFunc           endElement;  \/* idem *\/\n+    startElementNsSAX2Func      startElementNs;\/* idem *\/\n+    endElementNsSAX2Func        endElementNs;  \/* idem *\/\n+    charactersSAXFunc           characters;\n+    cdataBlockSAXFunc           cdataBlock;\n+    unsigned int                base;   \/* base of the segment in the input *\/\n+    unsigned int                cur;    \/* current position in the input *\/\n+    xmlNodePtr                  node;   \/* current node *\/\n+    xmlNodePtr                  curnode;\/* current attribute node *\/\n+    int                         depth;  \/* depth of the current node *\/\n+    xmlNodePtr                  faketext;\/* fake xmlNs chld *\/\n+    int                         preserve;\/* preserve the resulting document *\/\n+    xmlBufPtr                   buffer; \/* used to return const xmlChar * *\/\n+    xmlDictPtr                  dict;   \/* the context dictionary *\/\n@@ -129,1 +133,1 @@\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -131,1 +135,1 @@\n-    xmlRelaxNGPtr          rngSchemas;    \/* The Relax NG schemas *\/\n+    xmlRelaxNGPtr          rngSchemas;  \/* The Relax NG schemas *\/\n@@ -135,1 +139,3 @@\n-    xmlNodePtr             rngFullNode;    \/* the node if RNG not progressive *\/\n+    xmlNodePtr             rngFullNode; \/* the node if RNG not progressive *\/\n+#endif\n+#ifdef LIBXML_SCHEMAS_ENABLED\n@@ -137,1 +143,1 @@\n-    xmlSchemaPtr          xsdSchemas;    \/* The Schemas schemas *\/\n+    xmlSchemaPtr          xsdSchemas;   \/* The Schemas schemas *\/\n@@ -141,1 +147,1 @@\n-    xmlSchemaSAXPlugPtr   xsdPlug;    \/* the schemas plug in SAX pipeline *\/\n+    xmlSchemaSAXPlugPtr   xsdPlug;      \/* the schemas plug in SAX pipeline *\/\n@@ -145,4 +151,4 @@\n-    int                xinclude;    \/* is xinclude asked for *\/\n-    const xmlChar *    xinclude_name;    \/* the xinclude name from dict *\/\n-    xmlXIncludeCtxtPtr xincctxt;    \/* the xinclude context *\/\n-    int                in_xinclude;    \/* counts for xinclude *\/\n+    int                xinclude;        \/* is xinclude asked for *\/\n+    const xmlChar *    xinclude_name;   \/* the xinclude name from dict *\/\n+    xmlXIncludeCtxtPtr xincctxt;        \/* the xinclude context *\/\n+    int                in_xinclude;     \/* counts for xinclude *\/\n@@ -155,2 +161,2 @@\n-    int                preserves;    \/* level of preserves *\/\n-    int                parserFlags;    \/* the set of options set *\/\n+    int                preserves;       \/* level of preserves *\/\n+    int                parserFlags;     \/* the set of options set *\/\n@@ -159,0 +165,3 @@\n+\n+    xmlResourceLoader resourceLoader;\n+    void *resourceCtxt;\n@@ -161,3 +170,3 @@\n-#define NODE_IS_EMPTY        0x1\n-#define NODE_IS_PRESERVED    0x2\n-#define NODE_IS_SPRESERVED    0x4\n+#define NODE_IS_EMPTY           0x1\n+#define NODE_IS_PRESERVED       0x2\n+#define NODE_IS_SPRESERVED      0x4\n@@ -175,4 +184,4 @@\n-#define DICT_FREE(str)                        \\\n-    if ((str) && ((!dict) ||                \\\n-        (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))    \\\n-        xmlFree((char *)(str));\n+#define DICT_FREE(str)                                          \\\n+        if ((str) && ((!dict) ||                                \\\n+            (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n+            xmlFree((char *)(str));\n@@ -183,0 +192,15 @@\n+static void\n+xmlTextReaderErr(xmlParserErrors code, const char *msg, ...) {\n+    va_list ap;\n+    int res;\n+\n+    va_start(ap, msg);\n+    res = xmlVRaiseError(NULL, NULL, NULL, NULL, NULL,\n+                         XML_FROM_PARSER, code, XML_ERR_FATAL,\n+                         NULL, 0, NULL, NULL, NULL, 0, 0,\n+                         msg, ap);\n+    va_end(ap);\n+    if (res < 0)\n+        xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_PARSER, NULL);\n+}\n+\n@@ -185,0 +209,5 @@\n+    if (reader == NULL) {\n+        xmlRaiseMemoryError(NULL, NULL, NULL, XML_FROM_PARSER, NULL);\n+        return;\n+    }\n+\n@@ -189,0 +218,1 @@\n+\n@@ -237,3 +267,3 @@\n- *                                    *\n- *    Our own version of the freeing routines as we recycle nodes    *\n- *                                    *\n+ *                                                                      *\n+ *      Our own version of the freeing routines as we recycle nodes     *\n+ *                                                                      *\n@@ -254,1 +284,1 @@\n-    dict = reader->ctxt->dict;\n+        dict = reader->ctxt->dict;\n@@ -259,2 +289,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n-    xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);\n+    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n+        xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);\n@@ -281,2 +311,2 @@\n-    reader->ctxt->freeAttrs = cur;\n-    reader->ctxt->freeAttrsNr++;\n+        reader->ctxt->freeAttrs = cur;\n+        reader->ctxt->freeAttrsNr++;\n@@ -284,1 +314,1 @@\n-    xmlFree(cur);\n+        xmlFree(cur);\n@@ -302,1 +332,1 @@\n-    cur = next;\n+        cur = next;\n@@ -322,1 +352,1 @@\n-    dict = reader->ctxt->dict;\n+        dict = reader->ctxt->dict;\n@@ -327,2 +357,2 @@\n-    xmlFreeNsList((xmlNsPtr) cur);\n-    return;\n+        xmlFreeNsList((xmlNsPtr) cur);\n+        return;\n@@ -331,3 +361,3 @@\n-    (cur->type == XML_HTML_DOCUMENT_NODE)) {\n-    xmlFreeDoc((xmlDocPtr) cur);\n-    return;\n+        (cur->type == XML_HTML_DOCUMENT_NODE)) {\n+        xmlFreeDoc((xmlDocPtr) cur);\n+        return;\n@@ -347,23 +377,23 @@\n-    \/* unroll to speed up freeing the document *\/\n-    if (cur->type != XML_DTD_NODE) {\n-\n-        if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n-        xmlDeregisterNodeDefaultValue(cur);\n-\n-        if (((cur->type == XML_ELEMENT_NODE) ||\n-         (cur->type == XML_XINCLUDE_START) ||\n-         (cur->type == XML_XINCLUDE_END)) &&\n-        (cur->properties != NULL))\n-        xmlTextReaderFreePropList(reader, cur->properties);\n-        if ((cur->content != (xmlChar *) &(cur->properties)) &&\n-            (cur->type != XML_ELEMENT_NODE) &&\n-        (cur->type != XML_XINCLUDE_START) &&\n-        (cur->type != XML_XINCLUDE_END) &&\n-        (cur->type != XML_ENTITY_REF_NODE)) {\n-        DICT_FREE(cur->content);\n-        }\n-        if (((cur->type == XML_ELEMENT_NODE) ||\n-             (cur->type == XML_XINCLUDE_START) ||\n-         (cur->type == XML_XINCLUDE_END)) &&\n-        (cur->nsDef != NULL))\n-        xmlFreeNsList(cur->nsDef);\n+        \/* unroll to speed up freeing the document *\/\n+        if (cur->type != XML_DTD_NODE) {\n+\n+            if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n+                xmlDeregisterNodeDefaultValue(cur);\n+\n+            if (((cur->type == XML_ELEMENT_NODE) ||\n+                 (cur->type == XML_XINCLUDE_START) ||\n+                 (cur->type == XML_XINCLUDE_END)) &&\n+                (cur->properties != NULL))\n+                xmlTextReaderFreePropList(reader, cur->properties);\n+            if ((cur->content != (xmlChar *) &(cur->properties)) &&\n+                (cur->type != XML_ELEMENT_NODE) &&\n+                (cur->type != XML_XINCLUDE_START) &&\n+                (cur->type != XML_XINCLUDE_END) &&\n+                (cur->type != XML_ENTITY_REF_NODE)) {\n+                DICT_FREE(cur->content);\n+            }\n+            if (((cur->type == XML_ELEMENT_NODE) ||\n+                 (cur->type == XML_XINCLUDE_START) ||\n+                 (cur->type == XML_XINCLUDE_END)) &&\n+                (cur->nsDef != NULL))\n+                xmlFreeNsList(cur->nsDef);\n@@ -371,15 +401,16 @@\n-        \/*\n-         * we don't free element names here they are interned now\n-         *\/\n-        if ((cur->type != XML_TEXT_NODE) &&\n-        (cur->type != XML_COMMENT_NODE))\n-        DICT_FREE(cur->name);\n-        if (((cur->type == XML_ELEMENT_NODE) ||\n-         (cur->type == XML_TEXT_NODE)) &&\n-            (reader != NULL) && (reader->ctxt != NULL) &&\n-        (reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {\n-            cur->next = reader->ctxt->freeElems;\n-        reader->ctxt->freeElems = cur;\n-        reader->ctxt->freeElemsNr++;\n-        } else {\n-        xmlFree(cur);\n+            \/*\n+             * we don't free element names here they are interned now\n+             *\/\n+            if ((cur->type != XML_TEXT_NODE) &&\n+                (cur->type != XML_COMMENT_NODE))\n+                DICT_FREE(cur->name);\n+            if (((cur->type == XML_ELEMENT_NODE) ||\n+                 (cur->type == XML_TEXT_NODE)) &&\n+                (reader != NULL) && (reader->ctxt != NULL) &&\n+                (reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {\n+                cur->next = reader->ctxt->freeElems;\n+                reader->ctxt->freeElems = cur;\n+                reader->ctxt->freeElemsNr++;\n+            } else {\n+                xmlFree(cur);\n+            }\n@@ -387,1 +418,0 @@\n-    }\n@@ -390,1 +420,1 @@\n-        cur = next;\n+            cur = next;\n@@ -414,1 +444,1 @@\n-    dict = reader->ctxt->dict;\n+        dict = reader->ctxt->dict;\n@@ -418,2 +448,2 @@\n-    xmlFreeDtd((xmlDtdPtr) cur);\n-    return;\n+        xmlFreeDtd((xmlDtdPtr) cur);\n+        return;\n@@ -422,1 +452,1 @@\n-    xmlFreeNs((xmlNsPtr) cur);\n+        xmlFreeNs((xmlNsPtr) cur);\n@@ -426,2 +456,2 @@\n-    xmlTextReaderFreeProp(reader, (xmlAttrPtr) cur);\n-    return;\n+        xmlTextReaderFreeProp(reader, (xmlAttrPtr) cur);\n+        return;\n@@ -431,4 +461,4 @@\n-    (cur->type != XML_ENTITY_REF_NODE)) {\n-    if (cur->children->parent == cur)\n-        xmlTextReaderFreeNodeList(reader, cur->children);\n-    cur->children = NULL;\n+        (cur->type != XML_ENTITY_REF_NODE)) {\n+        if (cur->children->parent == cur)\n+            xmlTextReaderFreeNodeList(reader, cur->children);\n+        cur->children = NULL;\n@@ -437,2 +467,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n-    xmlDeregisterNodeDefaultValue(cur);\n+    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n+        xmlDeregisterNodeDefaultValue(cur);\n@@ -441,4 +471,4 @@\n-     (cur->type == XML_XINCLUDE_START) ||\n-     (cur->type == XML_XINCLUDE_END)) &&\n-    (cur->properties != NULL))\n-    xmlTextReaderFreePropList(reader, cur->properties);\n+         (cur->type == XML_XINCLUDE_START) ||\n+         (cur->type == XML_XINCLUDE_END)) &&\n+        (cur->properties != NULL))\n+        xmlTextReaderFreePropList(reader, cur->properties);\n@@ -447,4 +477,4 @@\n-    (cur->type != XML_XINCLUDE_START) &&\n-    (cur->type != XML_XINCLUDE_END) &&\n-    (cur->type != XML_ENTITY_REF_NODE)) {\n-    DICT_FREE(cur->content);\n+        (cur->type != XML_XINCLUDE_START) &&\n+        (cur->type != XML_XINCLUDE_END) &&\n+        (cur->type != XML_ENTITY_REF_NODE)) {\n+        DICT_FREE(cur->content);\n@@ -453,4 +483,4 @@\n-     (cur->type == XML_XINCLUDE_START) ||\n-     (cur->type == XML_XINCLUDE_END)) &&\n-    (cur->nsDef != NULL))\n-    xmlFreeNsList(cur->nsDef);\n+         (cur->type == XML_XINCLUDE_START) ||\n+         (cur->type == XML_XINCLUDE_END)) &&\n+        (cur->nsDef != NULL))\n+        xmlFreeNsList(cur->nsDef);\n@@ -463,1 +493,1 @@\n-    DICT_FREE(cur->name);\n+        DICT_FREE(cur->name);\n@@ -466,6 +496,6 @@\n-     (cur->type == XML_TEXT_NODE)) &&\n-    (reader != NULL) && (reader->ctxt != NULL) &&\n-    (reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {\n-    cur->next = reader->ctxt->freeElems;\n-    reader->ctxt->freeElems = cur;\n-    reader->ctxt->freeElemsNr++;\n+         (cur->type == XML_TEXT_NODE)) &&\n+        (reader != NULL) && (reader->ctxt != NULL) &&\n+        (reader->ctxt->freeElemsNr < MAX_FREE_NODES)) {\n+        cur->next = reader->ctxt->freeElems;\n+        reader->ctxt->freeElems = cur;\n+        reader->ctxt->freeElemsNr++;\n@@ -473,1 +503,1 @@\n-    xmlFree(cur);\n+        xmlFree(cur);\n@@ -490,2 +520,2 @@\n-    if ((__xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n-    xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);\n+    if ((xmlRegisterCallbacks) && (xmlDeregisterNodeDefaultValue))\n+        xmlDeregisterNodeDefaultValue((xmlNodePtr) cur);\n@@ -503,1 +533,1 @@\n-    extSubset = NULL;\n+        extSubset = NULL;\n@@ -505,3 +535,3 @@\n-    xmlUnlinkNode((xmlNodePtr) cur->extSubset);\n-    cur->extSubset = NULL;\n-    xmlFreeDtd(extSubset);\n+        xmlUnlinkNode((xmlNodePtr) cur->extSubset);\n+        cur->extSubset = NULL;\n+        xmlFreeDtd(extSubset);\n@@ -510,3 +540,3 @@\n-    xmlUnlinkNode((xmlNodePtr) cur->intSubset);\n-    cur->intSubset = NULL;\n-    xmlFreeDtd(intSubset);\n+        xmlUnlinkNode((xmlNodePtr) cur->intSubset);\n+        cur->intSubset = NULL;\n+        xmlFreeDtd(intSubset);\n@@ -528,3 +558,3 @@\n- *                                    *\n- *            The reader core parser                *\n- *                                    *\n+ *                                                                      *\n+ *                      The reader core parser                          *\n+ *                                                                      *\n@@ -574,1 +604,0 @@\n-        size_t newSize = reader->entMax == 0 ? 10 : reader->entMax * 2;\n@@ -576,0 +605,1 @@\n+        int newSize;\n@@ -577,2 +607,7 @@\n-        tmp = (xmlNodePtr *) xmlRealloc(reader->entTab,\n-                                        newSize * sizeof(*tmp));\n+        newSize = xmlGrowCapacity(reader->entMax, sizeof(tmp[0]),\n+                                  10, XML_MAX_ITEMS);\n+        if (newSize < 0) {\n+            xmlTextReaderErrMemory(reader);\n+            return (-1);\n+        }\n+        tmp = xmlRealloc(reader->entTab, newSize * sizeof(tmp[0]));\n@@ -626,1 +661,1 @@\n-                      const xmlChar **atts) {\n+                          const xmlChar **atts) {\n@@ -631,5 +666,5 @@\n-    reader->startElement(ctx, fullname, atts);\n-    if ((ctxt->node != NULL) && (ctxt->input != NULL) &&\n-        (ctxt->input->cur != NULL) && (ctxt->input->cur[0] == '\/') &&\n-        (ctxt->input->cur[1] == '>'))\n-        ctxt->node->extra = NODE_IS_EMPTY;\n+        reader->startElement(ctx, fullname, atts);\n+        if ((ctxt->node != NULL) && (ctxt->input != NULL) &&\n+            (ctxt->input->cur != NULL) && (ctxt->input->cur[0] == '\/') &&\n+            (ctxt->input->cur[1] == '>'))\n+            ctxt->node->extra = NODE_IS_EMPTY;\n@@ -638,1 +673,1 @@\n-    reader->state = XML_TEXTREADER_ELEMENT;\n+        reader->state = XML_TEXTREADER_ELEMENT;\n@@ -654,1 +689,1 @@\n-    reader->endElement(ctx, fullname);\n+        reader->endElement(ctx, fullname);\n@@ -676,7 +711,7 @@\n-              const xmlChar *prefix,\n-              const xmlChar *URI,\n-              int nb_namespaces,\n-              const xmlChar **namespaces,\n-              int nb_attributes,\n-              int nb_defaulted,\n-              const xmlChar **attributes)\n+                      const xmlChar *prefix,\n+                      const xmlChar *URI,\n+                      int nb_namespaces,\n+                      const xmlChar **namespaces,\n+                      int nb_attributes,\n+                      int nb_defaulted,\n+                      const xmlChar **attributes)\n@@ -688,7 +723,7 @@\n-    reader->startElementNs(ctx, localname, prefix, URI, nb_namespaces,\n-                           namespaces, nb_attributes, nb_defaulted,\n-                   attributes);\n-    if ((ctxt->node != NULL) && (ctxt->input != NULL) &&\n-        (ctxt->input->cur != NULL) && (ctxt->input->cur[0] == '\/') &&\n-        (ctxt->input->cur[1] == '>'))\n-        ctxt->node->extra = NODE_IS_EMPTY;\n+        reader->startElementNs(ctx, localname, prefix, URI, nb_namespaces,\n+                               namespaces, nb_attributes, nb_defaulted,\n+                               attributes);\n+        if ((ctxt->node != NULL) && (ctxt->input != NULL) &&\n+            (ctxt->input->cur != NULL) && (ctxt->input->cur[0] == '\/') &&\n+            (ctxt->input->cur[1] == '>'))\n+            ctxt->node->extra = NODE_IS_EMPTY;\n@@ -697,1 +732,1 @@\n-    reader->state = XML_TEXTREADER_ELEMENT;\n+        reader->state = XML_TEXTREADER_ELEMENT;\n@@ -713,1 +748,1 @@\n-                  const xmlChar * URI)\n+                          const xmlChar * URI)\n@@ -719,1 +754,1 @@\n-    reader->endElementNs(ctx, localname, prefix, URI);\n+        reader->endElementNs(ctx, localname, prefix, URI);\n@@ -739,1 +774,1 @@\n-    reader->characters(ctx, ch, len);\n+        reader->characters(ctx, ch, len);\n@@ -758,1 +793,1 @@\n-    reader->cdataBlock(ctx, ch, len);\n+        reader->cdataBlock(ctx, ch, len);\n@@ -778,1 +813,1 @@\n-    return(-1);\n+        return(-1);\n@@ -785,9 +820,9 @@\n-    if (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n-        \/*\n-         * Refill the buffer unless we are at the end of the stream\n-         *\/\n-        if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n-        val = xmlParserInputBufferRead(reader->input, 4096);\n-        if (val == 0) {\n-            if (xmlBufUse(inbuf) == reader->cur) {\n-            reader->mode = XML_TEXTREADER_MODE_EOF;\n+        if (xmlBufUse(inbuf) < reader->cur + CHUNK_SIZE) {\n+            \/*\n+             * Refill the buffer unless we are at the end of the stream\n+             *\/\n+            if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n+                val = xmlParserInputBufferRead(reader->input, 4096);\n+                if (val == 0) {\n+                    if (xmlBufUse(inbuf) == reader->cur) {\n+                        reader->mode = XML_TEXTREADER_MODE_EOF;\n@@ -795,2 +830,2 @@\n-            }\n-        } else if (val < 0) {\n+                    }\n+                } else if (val < 0) {\n@@ -801,1 +836,1 @@\n-        }\n+                }\n@@ -803,9 +838,9 @@\n-        } else\n-        break;\n-    }\n-    \/*\n-     * parse by block of CHUNK_SIZE bytes, various tests show that\n-     * it's the best tradeoff at least on a 1.2GH Duron\n-     *\/\n-    if (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n-        val = xmlParseChunk(reader->ctxt,\n+            } else\n+                break;\n+        }\n+        \/*\n+         * parse by block of CHUNK_SIZE bytes, various tests show that\n+         * it's the best tradeoff at least on a 1.2GH Duron\n+         *\/\n+        if (xmlBufUse(inbuf) >= reader->cur + CHUNK_SIZE) {\n+            val = xmlParseChunk(reader->ctxt,\n@@ -814,15 +849,15 @@\n-        reader->cur += CHUNK_SIZE;\n-        if (val != 0)\n-        reader->ctxt->wellFormed = 0;\n-        if (reader->ctxt->wellFormed == 0)\n-        break;\n-    } else {\n-        s = xmlBufUse(inbuf) - reader->cur;\n-        val = xmlParseChunk(reader->ctxt,\n-         (const char *) xmlBufContent(inbuf) + reader->cur,\n-                    s, 0);\n-        reader->cur += s;\n-        if (val != 0)\n-        reader->ctxt->wellFormed = 0;\n-        break;\n-    }\n+            reader->cur += CHUNK_SIZE;\n+            if (val != 0)\n+                reader->ctxt->wellFormed = 0;\n+            if (reader->ctxt->wellFormed == 0)\n+                break;\n+        } else {\n+            s = xmlBufUse(inbuf) - reader->cur;\n+            val = xmlParseChunk(reader->ctxt,\n+                 (const char *) xmlBufContent(inbuf) + reader->cur,\n+                                s, 0);\n+            reader->cur += s;\n+            if (val != 0)\n+                reader->ctxt->wellFormed = 0;\n+            break;\n+        }\n@@ -836,7 +871,5 @@\n-        if (reader->input->readcallback != NULL) {\n-        if ((reader->cur >= 4096) &&\n-        (xmlBufUse(inbuf) - reader->cur <= CHUNK_SIZE)) {\n-        val = xmlBufShrink(inbuf, reader->cur);\n-        if (val >= 0) {\n-            reader->cur -= val;\n-        }\n+        if (reader->cur > 80 \/* LINE_LEN *\/) {\n+            val = xmlBufShrink(inbuf, reader->cur - 80);\n+            if (val >= 0) {\n+                reader->cur -= val;\n+            }\n@@ -845,1 +878,0 @@\n-    }\n@@ -852,12 +884,13 @@\n-    if (reader->state != XML_TEXTREADER_DONE) {\n-        s = xmlBufUse(inbuf) - reader->cur;\n-        val = xmlParseChunk(reader->ctxt,\n-         (const char *) xmlBufContent(inbuf) + reader->cur,\n-                    s, 1);\n-        reader->cur = xmlBufUse(inbuf);\n-        reader->state  = XML_TEXTREADER_DONE;\n-        if (val != 0) {\n-            if (reader->ctxt->wellFormed)\n-            reader->ctxt->wellFormed = 0;\n-        else\n-            return(-1);\n+        if (reader->state != XML_TEXTREADER_DONE) {\n+            s = xmlBufUse(inbuf) - reader->cur;\n+            val = xmlParseChunk(reader->ctxt,\n+                 (const char *) xmlBufContent(inbuf) + reader->cur,\n+                                s, 1);\n+            reader->cur = xmlBufUse(inbuf);\n+            reader->state  = XML_TEXTREADER_DONE;\n+            if (val != 0) {\n+                if (reader->ctxt->wellFormed)\n+                    reader->ctxt->wellFormed = 0;\n+                else\n+                    return(-1);\n+            }\n@@ -866,1 +899,0 @@\n-    }\n@@ -868,1 +900,1 @@\n-    reader->mode = XML_TEXTREADER_MODE_EOF;\n+        reader->mode = XML_TEXTREADER_MODE_EOF;\n@@ -889,4 +921,4 @@\n-    if ((node->ns == NULL) || (node->ns->prefix == NULL)) {\n-        reader->ctxt->valid &= xmlValidatePushElement(&reader->ctxt->vctxt,\n-                    reader->ctxt->myDoc, node, node->name);\n-    } else {\n+        if ((node->ns == NULL) || (node->ns->prefix == NULL)) {\n+            reader->ctxt->valid &= xmlValidatePushElement(&reader->ctxt->vctxt,\n+                                    reader->ctxt->myDoc, node, node->name);\n+        } else {\n@@ -894,1 +926,1 @@\n-        xmlChar *qname;\n+            xmlChar *qname;\n@@ -896,1 +928,1 @@\n-        qname = xmlBuildQName(node->name, node->ns->prefix, buf, 50);\n+            qname = xmlBuildQName(node->name, node->ns->prefix, buf, 50);\n@@ -901,2 +933,2 @@\n-        reader->ctxt->valid &= xmlValidatePushElement(&reader->ctxt->vctxt,\n-                    reader->ctxt->myDoc, node, qname);\n+            reader->ctxt->valid &= xmlValidatePushElement(&reader->ctxt->vctxt,\n+                                    reader->ctxt->myDoc, node, qname);\n@@ -904,2 +936,2 @@\n-            xmlFree(qname);\n-    }\n+                xmlFree(qname);\n+        }\n@@ -913,1 +945,1 @@\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -916,1 +948,1 @@\n-    int ret;\n+        int ret;\n@@ -918,16 +950,17 @@\n-    if (reader->rngFullNode != NULL) return(0);\n-    ret = xmlRelaxNGValidatePushElement(reader->rngValidCtxt,\n-                                        reader->ctxt->myDoc,\n-                        node);\n-    if (ret == 0) {\n-        \/*\n-         * this element requires a full tree\n-         *\/\n-        node = xmlTextReaderExpand(reader);\n-        if (node == NULL) {\n-            ret = -1;\n-        } else {\n-        ret = xmlRelaxNGValidateFullElement(reader->rngValidCtxt,\n-                            reader->ctxt->myDoc,\n-                            node);\n-        reader->rngFullNode = node;\n+        if (reader->rngFullNode != NULL) return(0);\n+        ret = xmlRelaxNGValidatePushElement(reader->rngValidCtxt,\n+                                            reader->ctxt->myDoc,\n+                                            node);\n+        if (ret == 0) {\n+            \/*\n+             * this element requires a full tree\n+             *\/\n+            node = xmlTextReaderExpand(reader);\n+            if (node == NULL) {\n+                ret = -1;\n+            } else {\n+                ret = xmlRelaxNGValidateFullElement(reader->rngValidCtxt,\n+                                                    reader->ctxt->myDoc,\n+                                                    node);\n+                reader->rngFullNode = node;\n+            }\n@@ -935,3 +968,2 @@\n-    }\n-    if (ret != 1)\n-        reader->rngValidErrors++;\n+        if (ret != 1)\n+            reader->rngValidErrors++;\n@@ -958,2 +990,2 @@\n-    reader->ctxt->valid &= xmlValidatePushCData(&reader->ctxt->vctxt,\n-                                                data, len);\n+        reader->ctxt->valid &= xmlValidatePushCData(&reader->ctxt->vctxt,\n+                                                    data, len);\n@@ -962,1 +994,1 @@\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -965,1 +997,1 @@\n-    int ret;\n+        int ret;\n@@ -967,4 +999,4 @@\n-    if (reader->rngFullNode != NULL) return;\n-    ret = xmlRelaxNGValidatePushCData(reader->rngValidCtxt, data, len);\n-    if (ret != 1)\n-        reader->rngValidErrors++;\n+        if (reader->rngFullNode != NULL) return;\n+        ret = xmlRelaxNGValidatePushCData(reader->rngValidCtxt, data, len);\n+        if (ret != 1)\n+            reader->rngValidErrors++;\n@@ -988,4 +1020,4 @@\n-    if ((node->ns == NULL) || (node->ns->prefix == NULL)) {\n-        reader->ctxt->valid &= xmlValidatePopElement(&reader->ctxt->vctxt,\n-                    reader->ctxt->myDoc, node, node->name);\n-    } else {\n+        if ((node->ns == NULL) || (node->ns->prefix == NULL)) {\n+            reader->ctxt->valid &= xmlValidatePopElement(&reader->ctxt->vctxt,\n+                                    reader->ctxt->myDoc, node, node->name);\n+        } else {\n@@ -993,1 +1025,1 @@\n-        xmlChar *qname;\n+            xmlChar *qname;\n@@ -995,1 +1027,1 @@\n-        qname = xmlBuildQName(node->name, node->ns->prefix, buf, 50);\n+            qname = xmlBuildQName(node->name, node->ns->prefix, buf, 50);\n@@ -1000,2 +1032,2 @@\n-        reader->ctxt->valid &= xmlValidatePopElement(&reader->ctxt->vctxt,\n-                    reader->ctxt->myDoc, node, qname);\n+            reader->ctxt->valid &= xmlValidatePopElement(&reader->ctxt->vctxt,\n+                                    reader->ctxt->myDoc, node, qname);\n@@ -1003,2 +1035,2 @@\n-            xmlFree(qname);\n-    }\n+                xmlFree(qname);\n+        }\n@@ -1012,1 +1044,1 @@\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -1015,1 +1047,1 @@\n-    int ret;\n+        int ret;\n@@ -1017,10 +1049,10 @@\n-    if (reader->rngFullNode != NULL) {\n-        if (node == reader->rngFullNode)\n-            reader->rngFullNode = NULL;\n-        return(0);\n-    }\n-    ret = xmlRelaxNGValidatePopElement(reader->rngValidCtxt,\n-                                       reader->ctxt->myDoc,\n-                       node);\n-    if (ret != 1)\n-        reader->rngValidErrors++;\n+        if (reader->rngFullNode != NULL) {\n+            if (node == reader->rngFullNode)\n+                reader->rngFullNode = NULL;\n+            return(0);\n+        }\n+        ret = xmlRelaxNGValidatePopElement(reader->rngValidCtxt,\n+                                           reader->ctxt->myDoc,\n+                                           node);\n+        if (ret != 1)\n+            reader->rngValidErrors++;\n@@ -1047,5 +1079,5 @@\n-    if (node->type == XML_ENTITY_REF_NODE) {\n-        if ((node->children != NULL) &&\n-        (node->children->type == XML_ENTITY_DECL) &&\n-        (node->children->children != NULL)) {\n-        if (xmlTextReaderEntPush(reader, node) < 0) {\n+        if (node->type == XML_ENTITY_REF_NODE) {\n+            if ((node->children != NULL) &&\n+                (node->children->type == XML_ENTITY_DECL) &&\n+                (node->children->children != NULL)) {\n+                if (xmlTextReaderEntPush(reader, node) < 0) {\n@@ -1056,8 +1088,8 @@\n-        node = node->children->children;\n-        continue;\n-        } else {\n-        \/*\n-         * The error has probably been raised already.\n-         *\/\n-        if (node == oldnode)\n-            break;\n+                node = node->children->children;\n+                continue;\n+            } else {\n+                \/*\n+                 * The error has probably been raised already.\n+                 *\/\n+                if (node == oldnode)\n+                    break;\n@@ -1065,1 +1097,1 @@\n-        }\n+            }\n@@ -1067,3 +1099,3 @@\n-    } else if (node->type == XML_ELEMENT_NODE) {\n-        reader->node = node;\n-        if (xmlTextReaderValidatePush(reader) < 0)\n+        } else if (node->type == XML_ELEMENT_NODE) {\n+            reader->node = node;\n+            if (xmlTextReaderValidatePush(reader) < 0)\n@@ -1071,2 +1103,2 @@\n-    } else if ((node->type == XML_TEXT_NODE) ||\n-           (node->type == XML_CDATA_SECTION_NODE)) {\n+        } else if ((node->type == XML_TEXT_NODE) ||\n+                   (node->type == XML_CDATA_SECTION_NODE)) {\n@@ -1074,1 +1106,1 @@\n-                                   xmlStrlen(node->content));\n+                                       xmlStrlen(node->content));\n@@ -1076,1 +1108,1 @@\n-    }\n+        }\n@@ -1078,8 +1110,8 @@\n-    \/*\n-     * go to next node\n-     *\/\n-    if (node->children != NULL) {\n-        node = node->children;\n-        continue;\n-    } else if (node->type == XML_ELEMENT_NODE) {\n-        if (xmlTextReaderValidatePop(reader) < 0)\n+        \/*\n+         * go to next node\n+         *\/\n+        if (node->children != NULL) {\n+            node = node->children;\n+            continue;\n+        } else if (node->type == XML_ELEMENT_NODE) {\n+            if (xmlTextReaderValidatePop(reader) < 0)\n@@ -1087,26 +1119,0 @@\n-    }\n-skip_children:\n-    if (node->next != NULL) {\n-        node = node->next;\n-        continue;\n-    }\n-    do {\n-        node = node->parent;\n-        if (node->type == XML_ELEMENT_NODE) {\n-            xmlNodePtr tmp;\n-        if (reader->entNr == 0) {\n-            while ((tmp = node->last) != NULL) {\n-            if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n-                xmlUnlinkNode(tmp);\n-                xmlTextReaderFreeNode(reader, tmp);\n-            } else\n-                break;\n-            }\n-        }\n-        reader->node = node;\n-        if (xmlTextReaderValidatePop(reader) < 0)\n-                    return(-1);\n-        }\n-        if ((node->type == XML_ENTITY_DECL) &&\n-        (reader->ent != NULL) && (reader->ent->children == node)) {\n-        node = xmlTextReaderEntPop(reader);\n@@ -1114,2 +1120,1 @@\n-        if (node == oldnode)\n-        break;\n+skip_children:\n@@ -1117,2 +1122,2 @@\n-        node = node->next;\n-        break;\n+            node = node->next;\n+            continue;\n@@ -1120,1 +1125,28 @@\n-    } while ((node != NULL) && (node != oldnode));\n+        do {\n+            node = node->parent;\n+            if (node->type == XML_ELEMENT_NODE) {\n+                xmlNodePtr tmp;\n+                if (reader->entNr == 0) {\n+                    while ((tmp = node->last) != NULL) {\n+                        if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n+                            xmlUnlinkNode(tmp);\n+                            xmlTextReaderFreeNode(reader, tmp);\n+                        } else\n+                            break;\n+                    }\n+                }\n+                reader->node = node;\n+                if (xmlTextReaderValidatePop(reader) < 0)\n+                    return(-1);\n+            }\n+            if ((node->type == XML_ENTITY_DECL) &&\n+                (reader->ent != NULL) && (reader->ent->children == node)) {\n+                node = xmlTextReaderEntPop(reader);\n+            }\n+            if (node == oldnode)\n+                break;\n+            if (node->next != NULL) {\n+                node = node->next;\n+                break;\n+            }\n+        } while ((node != NULL) && (node != oldnode));\n@@ -1167,1 +1199,1 @@\n-    if (PARSER_STOPPED(reader->ctxt))\n+        if (PARSER_STOPPED(reader->ctxt))\n@@ -1171,8 +1203,8 @@\n-        return(1);\n-    if (reader->ctxt->nodeNr < reader->depth)\n-        return(1);\n-    if (reader->mode == XML_TEXTREADER_MODE_EOF)\n-        return(1);\n-    val = xmlTextReaderPushData(reader);\n-    if (val < 0){\n-        reader->mode = XML_TEXTREADER_MODE_ERROR;\n+            return(1);\n+        if (reader->ctxt->nodeNr < reader->depth)\n+            return(1);\n+        if (reader->mode == XML_TEXTREADER_MODE_EOF)\n+            return(1);\n+        val = xmlTextReaderPushData(reader);\n+        if (val < 0){\n+            reader->mode = XML_TEXTREADER_MODE_ERROR;\n@@ -1180,2 +1212,2 @@\n-        return(-1);\n-    }\n+            return(-1);\n+        }\n@@ -1203,1 +1235,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1211,1 +1243,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1214,6 +1246,6 @@\n-    reader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n-    \/*\n-     * Initial state\n-     *\/\n-    do {\n-        val = xmlTextReaderPushData(reader);\n+        reader->mode = XML_TEXTREADER_MODE_INTERACTIVE;\n+        \/*\n+         * Initial state\n+         *\/\n+        do {\n+            val = xmlTextReaderPushData(reader);\n@@ -1225,8 +1257,8 @@\n-    } while ((reader->ctxt->node == NULL) &&\n-         ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n-          (reader->state != XML_TEXTREADER_DONE)));\n-    if (reader->ctxt->node == NULL) {\n-        if (reader->ctxt->myDoc != NULL) {\n-        reader->node = reader->ctxt->myDoc->children;\n-        }\n-        if (reader->node == NULL) {\n+        } while ((reader->ctxt->node == NULL) &&\n+                 ((reader->mode != XML_TEXTREADER_MODE_EOF) &&\n+                  (reader->state != XML_TEXTREADER_DONE)));\n+        if (reader->ctxt->node == NULL) {\n+            if (reader->ctxt->myDoc != NULL) {\n+                reader->node = reader->ctxt->myDoc->children;\n+            }\n+            if (reader->node == NULL) {\n@@ -1235,6 +1267,10 @@\n-        return(-1);\n-        }\n-        reader->state = XML_TEXTREADER_ELEMENT;\n-    } else {\n-        if (reader->ctxt->myDoc != NULL) {\n-        reader->node = reader->ctxt->myDoc->children;\n+                return(-1);\n+            }\n+            reader->state = XML_TEXTREADER_ELEMENT;\n+        } else {\n+            if (reader->ctxt->myDoc != NULL) {\n+                reader->node = reader->ctxt->myDoc->children;\n+            }\n+            if (reader->node == NULL)\n+                reader->node = reader->ctxt->nodeTab[0];\n+            reader->state = XML_TEXTREADER_ELEMENT;\n@@ -1242,7 +1278,3 @@\n-        if (reader->node == NULL)\n-        reader->node = reader->ctxt->nodeTab[0];\n-        reader->state = XML_TEXTREADER_ELEMENT;\n-    }\n-    reader->depth = 0;\n-    reader->ctxt->parseMode = XML_PARSE_READER;\n-    goto node_found;\n+        reader->depth = 0;\n+        reader->ctxt->parseMode = XML_PARSE_READER;\n+        goto node_found;\n@@ -1256,2 +1288,2 @@\n-    if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n-        return(0);\n+        if (reader->mode == XML_TEXTREADER_MODE_EOF) {\n+            return(0);\n@@ -1261,1 +1293,1 @@\n-        return(-1);\n+            return(-1);\n@@ -1271,1 +1303,1 @@\n-       (reader->ctxt->nodeNr == olddepth) &&\n+           (reader->ctxt->nodeNr == olddepth) &&\n@@ -1274,14 +1306,14 @@\n-        (reader->node->type == XML_ENTITY_REF_NODE) ||\n-        ((reader->node->children != NULL) &&\n-         (reader->node->children->type == XML_TEXT_NODE) &&\n-         (reader->node->children->next == NULL)) ||\n-        (reader->node->type == XML_DTD_NODE) ||\n-        (reader->node->type == XML_DOCUMENT_NODE) ||\n-        (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n-       ((reader->ctxt->node == NULL) ||\n-        (reader->ctxt->node == reader->node) ||\n-        (reader->ctxt->node == reader->node->parent)) &&\n-       (reader->ctxt->instate != XML_PARSER_EOF) &&\n-       (PARSER_STOPPED(reader->ctxt) == 0)) {\n-    val = xmlTextReaderPushData(reader);\n-    if (val < 0) {\n+            (reader->node->type == XML_ENTITY_REF_NODE) ||\n+            ((reader->node->children != NULL) &&\n+             (reader->node->children->type == XML_TEXT_NODE) &&\n+             (reader->node->children->next == NULL)) ||\n+            (reader->node->type == XML_DTD_NODE) ||\n+            (reader->node->type == XML_DOCUMENT_NODE) ||\n+            (reader->node->type == XML_HTML_DOCUMENT_NODE)) &&\n+           ((reader->ctxt->node == NULL) ||\n+            (reader->ctxt->node == reader->node) ||\n+            (reader->ctxt->node == reader->node->parent)) &&\n+           (reader->ctxt->instate != XML_PARSER_EOF) &&\n+           (PARSER_STOPPED(reader->ctxt) == 0)) {\n+        val = xmlTextReaderPushData(reader);\n+        if (val < 0) {\n@@ -1290,1 +1322,1 @@\n-        return(-1);\n+            return(-1);\n@@ -1292,2 +1324,2 @@\n-    if (reader->node == NULL)\n-        goto node_end;\n+        if (reader->node == NULL)\n+            goto node_end;\n@@ -1296,9 +1328,9 @@\n-    if ((reader->node->children != NULL) &&\n-        (reader->node->type != XML_ENTITY_REF_NODE) &&\n-        (reader->node->type != XML_XINCLUDE_START) &&\n-        (reader->node->type != XML_DTD_NODE)) {\n-        reader->node = reader->node->children;\n-        reader->depth++;\n-        reader->state = XML_TEXTREADER_ELEMENT;\n-        goto node_found;\n-    }\n+        if ((reader->node->children != NULL) &&\n+            (reader->node->type != XML_ENTITY_REF_NODE) &&\n+            (reader->node->type != XML_XINCLUDE_START) &&\n+            (reader->node->type != XML_DTD_NODE)) {\n+            reader->node = reader->node->children;\n+            reader->depth++;\n+            reader->state = XML_TEXTREADER_ELEMENT;\n+            goto node_found;\n+        }\n@@ -1307,1 +1339,1 @@\n-    if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n+        if ((oldstate == XML_TEXTREADER_ELEMENT) &&\n@@ -1309,2 +1341,2 @@\n-        (reader->node->children == NULL) &&\n-        ((reader->node->extra & NODE_IS_EMPTY) == 0)\n+            (reader->node->children == NULL) &&\n+            ((reader->node->extra & NODE_IS_EMPTY) == 0)\n@@ -1312,1 +1344,1 @@\n-        && (reader->in_xinclude <= 0)\n+            && (reader->in_xinclude <= 0)\n@@ -1314,4 +1346,4 @@\n-        ) {\n-        reader->state = XML_TEXTREADER_END;\n-        goto node_found;\n-    }\n+            ) {\n+            reader->state = XML_TEXTREADER_END;\n+            goto node_found;\n+        }\n@@ -1319,3 +1351,3 @@\n-    if ((reader->validate) &&\n-        (reader->node->type == XML_ELEMENT_NODE))\n-        if (xmlTextReaderValidatePop(reader) < 0)\n+        if ((reader->validate) &&\n+            (reader->node->type == XML_ELEMENT_NODE))\n+            if (xmlTextReaderValidatePop(reader) < 0)\n@@ -1325,9 +1357,9 @@\n-        (reader->node->extra & NODE_IS_SPRESERVED))\n-        reader->preserves--;\n-    reader->node = reader->node->next;\n-    reader->state = XML_TEXTREADER_ELEMENT;\n-\n-    \/*\n-     * Cleanup of the old node\n-     *\/\n-    if ((reader->preserves == 0) &&\n+            (reader->node->extra & NODE_IS_SPRESERVED))\n+            reader->preserves--;\n+        reader->node = reader->node->next;\n+        reader->state = XML_TEXTREADER_ELEMENT;\n+\n+        \/*\n+         * Cleanup of the old node\n+         *\/\n+        if ((reader->preserves == 0) &&\n@@ -1335,1 +1367,1 @@\n-        (reader->in_xinclude == 0) &&\n+            (reader->in_xinclude == 0) &&\n@@ -1337,2 +1369,2 @@\n-        (reader->entNr == 0) &&\n-        (reader->node->prev != NULL) &&\n+            (reader->entNr == 0) &&\n+            (reader->node->prev != NULL) &&\n@@ -1340,2 +1372,2 @@\n-        xmlNodePtr tmp = reader->node->prev;\n-        if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n+            xmlNodePtr tmp = reader->node->prev;\n+            if ((tmp->extra & NODE_IS_PRESERVED) == 0) {\n@@ -1344,2 +1376,3 @@\n-        xmlUnlinkNode(tmp);\n-        xmlTextReaderFreeNode(reader, tmp);\n+                xmlUnlinkNode(tmp);\n+                xmlTextReaderFreeNode(reader, tmp);\n+            }\n@@ -1347,1 +1380,0 @@\n-    }\n@@ -1349,1 +1381,1 @@\n-    goto node_found;\n+        goto node_found;\n@@ -1352,5 +1384,5 @@\n-    (reader->node->type == XML_ELEMENT_NODE) &&\n-    (reader->node->children == NULL) &&\n-    ((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n-    reader->state = XML_TEXTREADER_END;\n-    goto node_found;\n+        (reader->node->type == XML_ELEMENT_NODE) &&\n+        (reader->node->children == NULL) &&\n+        ((reader->node->extra & NODE_IS_EMPTY) == 0)) {;\n+        reader->state = XML_TEXTREADER_END;\n+        goto node_found;\n@@ -1366,2 +1398,2 @@\n-    (reader->node->extra & NODE_IS_SPRESERVED))\n-    reader->preserves--;\n+        (reader->node->extra & NODE_IS_SPRESERVED))\n+        reader->preserves--;\n@@ -1370,6 +1402,6 @@\n-    (reader->node->type == XML_DOCUMENT_NODE) ||\n-    (reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n-    if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n-        val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n-        reader->state = XML_TEXTREADER_DONE;\n-        if (val != 0) {\n+        (reader->node->type == XML_DOCUMENT_NODE) ||\n+        (reader->node->type == XML_HTML_DOCUMENT_NODE)) {\n+        if (reader->mode != XML_TEXTREADER_MODE_EOF) {\n+            val = xmlParseChunk(reader->ctxt, \"\", 0, 1);\n+            reader->state = XML_TEXTREADER_DONE;\n+            if (val != 0) {\n@@ -1378,1 +1410,1 @@\n-            return(-1);\n+                return(-1);\n@@ -1380,3 +1412,3 @@\n-    }\n-    reader->node = NULL;\n-    reader->depth = -1;\n+        }\n+        reader->node = NULL;\n+        reader->depth = -1;\n@@ -1384,4 +1416,4 @@\n-    \/*\n-     * Cleanup of the old node\n-     *\/\n-    if ((oldnode != NULL) && (reader->preserves == 0) &&\n+        \/*\n+         * Cleanup of the old node\n+         *\/\n+        if ((oldnode != NULL) && (reader->preserves == 0) &&\n@@ -1389,1 +1421,1 @@\n-        (reader->in_xinclude == 0) &&\n+            (reader->in_xinclude == 0) &&\n@@ -1391,6 +1423,6 @@\n-        (reader->entNr == 0) &&\n-        (oldnode->type != XML_DTD_NODE) &&\n-        ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n-        xmlUnlinkNode(oldnode);\n-        xmlTextReaderFreeNode(reader, oldnode);\n-    }\n+            (reader->entNr == 0) &&\n+            (oldnode->type != XML_DTD_NODE) &&\n+            ((oldnode->extra & NODE_IS_PRESERVED) == 0)) {\n+            xmlUnlinkNode(oldnode);\n+            xmlTextReaderFreeNode(reader, oldnode);\n+        }\n@@ -1398,1 +1430,1 @@\n-    goto node_end;\n+        goto node_end;\n@@ -1404,1 +1436,1 @@\n-    (reader->entNr == 0) &&\n+        (reader->entNr == 0) &&\n@@ -1407,3 +1439,3 @@\n-    xmlNodePtr tmp = reader->node->last;\n-    xmlUnlinkNode(tmp);\n-    xmlTextReaderFreeNode(reader, tmp);\n+        xmlNodePtr tmp = reader->node->last;\n+        xmlUnlinkNode(tmp);\n+        xmlTextReaderFreeNode(reader, tmp);\n@@ -1421,1 +1453,1 @@\n-     (reader->node->type == XML_CDATA_SECTION_NODE))) {\n+         (reader->node->type == XML_CDATA_SECTION_NODE))) {\n@@ -1423,1 +1455,1 @@\n-            return -1;\n+                return -1;\n@@ -1433,6 +1465,6 @@\n-    (reader->node->type == XML_ELEMENT_NODE) &&\n-    (reader->node->ns != NULL) &&\n-    ((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n-     (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n-    if (reader->xincctxt == NULL) {\n-        reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n+        (reader->node->type == XML_ELEMENT_NODE) &&\n+        (reader->node->ns != NULL) &&\n+        ((xmlStrEqual(reader->node->ns->href, XINCLUDE_NS)) ||\n+         (xmlStrEqual(reader->node->ns->href, XINCLUDE_OLD_NS)))) {\n+        if (reader->xincctxt == NULL) {\n+            reader->xincctxt = xmlXIncludeNewContext(reader->ctxt->myDoc);\n@@ -1443,2 +1475,2 @@\n-        xmlXIncludeSetFlags(reader->xincctxt,\n-                            reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n+            xmlXIncludeSetFlags(reader->xincctxt,\n+                                reader->parserFlags & (~XML_PARSE_NOXINCNODE));\n@@ -1449,6 +1481,9 @@\n-    }\n-    \/*\n-     * expand that node and process it\n-     *\/\n-    if (xmlTextReaderExpand(reader) == NULL)\n-        return(-1);\n+            if (reader->resourceLoader != NULL)\n+                xmlXIncludeSetResourceLoader(reader->xincctxt,\n+                        reader->resourceLoader, reader->resourceCtxt);\n+        }\n+        \/*\n+         * expand that node and process it\n+         *\/\n+        if (xmlTextReaderExpand(reader) == NULL)\n+            return(-1);\n@@ -1458,2 +1493,5 @@\n-            if (err == XML_ERR_NO_MEMORY)\n-                xmlTextReaderErrMemory(reader);\n+            if (xmlIsCatastrophicError(XML_ERR_FATAL, err)) {\n+                xmlFatalErr(reader->ctxt, err, NULL);\n+                reader->mode = XML_TEXTREADER_MODE_ERROR;\n+                reader->state = XML_TEXTREADER_ERROR;\n+            }\n@@ -1465,1 +1503,1 @@\n-    goto get_next_node;\n+        goto get_next_node;\n@@ -1469,1 +1507,1 @@\n-    goto get_next_node;\n+        goto get_next_node;\n@@ -1476,6 +1514,6 @@\n-    (reader->node->type == XML_ENTITY_REF_NODE) &&\n-    (reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n-    if ((reader->node->children != NULL) &&\n-        (reader->node->children->type == XML_ENTITY_DECL) &&\n-        (reader->node->children->children != NULL)) {\n-        if (xmlTextReaderEntPush(reader, reader->node) < 0)\n+        (reader->node->type == XML_ENTITY_REF_NODE) &&\n+        (reader->ctxt != NULL) && (reader->ctxt->replaceEntities == 1)) {\n+        if ((reader->node->children != NULL) &&\n+            (reader->node->children->type == XML_ENTITY_DECL) &&\n+            (reader->node->children->children != NULL)) {\n+            if (xmlTextReaderEntPush(reader, reader->node) < 0)\n@@ -1483,2 +1521,2 @@\n-        reader->node = reader->node->children->children;\n-    }\n+            reader->node = reader->node->children->children;\n+        }\n@@ -1487,3 +1525,3 @@\n-           (reader->node->type == XML_ENTITY_REF_NODE) &&\n-           (reader->ctxt != NULL) && (reader->validate)) {\n-    if (xmlTextReaderValidateEntity(reader) < 0)\n+               (reader->node->type == XML_ENTITY_REF_NODE) &&\n+               (reader->ctxt != NULL) && (reader->validate)) {\n+        if (xmlTextReaderValidateEntity(reader) < 0)\n@@ -1494,4 +1532,4 @@\n-    (reader->node->type == XML_ENTITY_DECL) &&\n-    (reader->ent != NULL) && (reader->ent->children == reader->node)) {\n-    reader->node = xmlTextReaderEntPop(reader);\n-    reader->depth++;\n+        (reader->node->type == XML_ENTITY_DECL) &&\n+        (reader->ent != NULL) && (reader->ent->children == reader->node)) {\n+        reader->node = xmlTextReaderEntPop(reader);\n+        reader->depth++;\n@@ -1502,1 +1540,1 @@\n-    xmlNodePtr node = reader->node;\n+        xmlNodePtr node = reader->node;\n@@ -1504,1 +1542,1 @@\n-    if ((node->type == XML_ELEMENT_NODE) &&\n+        if ((node->type == XML_ELEMENT_NODE) &&\n@@ -1506,2 +1544,2 @@\n-         (reader->state != XML_TEXTREADER_BACKTRACK))) {\n-        if (xmlTextReaderValidatePush(reader) < 0)\n+             (reader->state != XML_TEXTREADER_BACKTRACK))) {\n+            if (xmlTextReaderValidatePush(reader) < 0)\n@@ -1509,2 +1547,2 @@\n-    } else if ((node->type == XML_TEXT_NODE) ||\n-           (node->type == XML_CDATA_SECTION_NODE)) {\n+        } else if ((node->type == XML_TEXT_NODE) ||\n+                   (node->type == XML_CDATA_SECTION_NODE)) {\n@@ -1512,2 +1550,2 @@\n-                                   xmlStrlen(node->content));\n-    }\n+                                       xmlStrlen(node->content));\n+        }\n@@ -1520,4 +1558,4 @@\n-    for (i = 0;i < reader->patternNr;i++) {\n-         if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n-             xmlTextReaderPreserve(reader);\n-         break;\n+        for (i = 0;i < reader->patternNr;i++) {\n+             if (xmlPatternMatch(reader->patternTab[i], reader->node) == 1) {\n+                 xmlTextReaderPreserve(reader);\n+                 break;\n@@ -1525,1 +1563,1 @@\n-    }\n+        }\n@@ -1531,2 +1569,2 @@\n-    (reader->xsdValidCtxt != NULL)) {\n-    reader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n+        (reader->xsdValidCtxt != NULL)) {\n+        reader->xsdValidErrors = !xmlSchemaIsValid(reader->xsdValidCtxt);\n@@ -1552,1 +1590,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1595,1 +1633,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1607,2 +1645,2 @@\n-    if (ret != 1)\n-        return(ret);\n+        if (ret != 1)\n+            return(ret);\n@@ -1762,1 +1800,1 @@\n-    buf = xmlBufCreateSize(30);\n+    buf = xmlBufCreate(50);\n@@ -1767,1 +1805,0 @@\n-    xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);\n@@ -1808,60 +1845,0 @@\n-#if 0\n-\/**\n- * xmlTextReaderReadBase64:\n- * @reader:  the xmlTextReaderPtr used\n- * @array:  a byte array to store the content.\n- * @offset:  the zero-based index into array where the method should\n- *           begin to write.\n- * @len:  the number of bytes to write.\n- *\n- * Reads and decodes the Base64 encoded contents of an element and\n- * stores the result in a byte buffer.\n- *\n- * Returns the number of bytes written to array, or zero if the current\n- *         instance is not positioned on an element or -1 in case of error.\n- *\/\n-int\n-xmlTextReaderReadBase64(xmlTextReaderPtr reader,\n-                        unsigned char *array ATTRIBUTE_UNUSED,\n-                    int offset ATTRIBUTE_UNUSED,\n-            int len ATTRIBUTE_UNUSED) {\n-    if ((reader == NULL) || (reader->ctxt == NULL))\n-    return(-1);\n-    if (reader->ctxt->wellFormed != 1)\n-    return(-1);\n-\n-    if ((reader->node == NULL) || (reader->node->type == XML_ELEMENT_NODE))\n-    return(0);\n-    return(0);\n-}\n-\n-\/**\n- * xmlTextReaderReadBinHex:\n- * @reader:  the xmlTextReaderPtr used\n- * @array:  a byte array to store the content.\n- * @offset:  the zero-based index into array where the method should\n- *           begin to write.\n- * @len:  the number of bytes to write.\n- *\n- * Reads and decodes the BinHex encoded contents of an element and\n- * stores the result in a byte buffer.\n- *\n- * Returns the number of bytes written to array, or zero if the current\n- *         instance is not positioned on an element or -1 in case of error.\n- *\/\n-int\n-xmlTextReaderReadBinHex(xmlTextReaderPtr reader,\n-                        unsigned char *array ATTRIBUTE_UNUSED,\n-                    int offset ATTRIBUTE_UNUSED,\n-            int len ATTRIBUTE_UNUSED) {\n-    if ((reader == NULL) || (reader->ctxt == NULL))\n-    return(-1);\n-    if (reader->ctxt->wellFormed != 1)\n-    return(-1);\n-\n-    if ((reader->node == NULL) || (reader->node->type == XML_ELEMENT_NODE))\n-    return(0);\n-    return(0);\n-}\n-#endif\n-\n@@ -1869,3 +1846,3 @@\n- *                                    *\n- *            Operating on a preparsed tree            *\n- *                                    *\n+ *                                                                      *\n+ *                      Operating on a preparsed tree                   *\n+ *                                                                      *\n@@ -1894,2 +1871,2 @@\n-    \/* Here removed traversal to child, because we want to skip the subtree,\n-    replace with traversal to sibling to skip subtree *\/\n+        \/* Here removed traversal to child, because we want to skip the subtree,\n+        replace with traversal to sibling to skip subtree *\/\n@@ -1897,1 +1874,1 @@\n-        \/* Move to sibling if present,skipping sub-tree *\/\n+            \/* Move to sibling if present,skipping sub-tree *\/\n@@ -1903,5 +1880,5 @@\n-    \/* if reader->node->next is NULL mean no subtree for current node,\n-    so need to move to sibling of parent node if present *\/\n-    reader->state = XML_TEXTREADER_BACKTRACK;\n-    \/* This will move to parent if present *\/\n-    xmlTextReaderRead(reader);\n+        \/* if reader->node->next is NULL mean no subtree for current node,\n+        so need to move to sibling of parent node if present *\/\n+        reader->state = XML_TEXTREADER_BACKTRACK;\n+        \/* This will move to parent if present *\/\n+        xmlTextReaderRead(reader);\n@@ -1925,1 +1902,1 @@\n-    \/* Repeat process to move to sibling of parent node if present *\/\n+        \/* Repeat process to move to sibling of parent node if present *\/\n@@ -1964,1 +1941,1 @@\n-    (reader->node->type != XML_ENTITY_REF_NODE)) {\n+        (reader->node->type != XML_ENTITY_REF_NODE)) {\n@@ -1986,1 +1963,1 @@\n-        (reader->node->parent->type == XML_HTML_DOCUMENT_NODE)) {\n+            (reader->node->parent->type == XML_HTML_DOCUMENT_NODE)) {\n@@ -2002,1 +1979,1 @@\n-    goto next_node;\n+        goto next_node;\n@@ -2024,1 +2001,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2043,3 +2020,3 @@\n- *                                    *\n- *            Constructor and destructors            *\n- *                                    *\n+ *                                                                      *\n+ *                      Constructor and destructors                     *\n+ *                                                                      *\n@@ -2061,1 +2038,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2064,1 +2041,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2071,1 +2048,1 @@\n-    ret->buffer = xmlBufCreateSize(100);\n+    ret->buffer = xmlBufCreate(50);\n@@ -2074,1 +2051,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2076,3 +2053,0 @@\n-    \/* no operation on a reader should require a huge buffer *\/\n-    xmlBufSetAllocationScheme(ret->buffer,\n-                  XML_BUFFER_ALLOC_DOUBLEIT);\n@@ -2081,3 +2055,3 @@\n-    xmlBufFree(ret->buffer);\n-    xmlFree(ret);\n-    return(NULL);\n+        xmlBufFree(ret->buffer);\n+        xmlFree(ret);\n+        return(NULL);\n@@ -2093,4 +2067,4 @@\n-    ret->startElementNs = ret->sax->startElementNs;\n-    ret->sax->startElementNs = xmlTextReaderStartElementNs;\n-    ret->endElementNs = ret->sax->endElementNs;\n-    ret->sax->endElementNs = xmlTextReaderEndElementNs;\n+        ret->startElementNs = ret->sax->startElementNs;\n+        ret->sax->startElementNs = xmlTextReaderStartElementNs;\n+        ret->endElementNs = ret->sax->endElementNs;\n+        ret->sax->endElementNs = xmlTextReaderEndElementNs;\n@@ -2099,2 +2073,2 @@\n-    ret->startElementNs = NULL;\n-    ret->endElementNs = NULL;\n+        ret->startElementNs = NULL;\n+        ret->endElementNs = NULL;\n@@ -2113,1 +2087,1 @@\n-    xmlParserInputBufferRead(input, 4);\n+        xmlParserInputBufferRead(input, 4);\n@@ -2116,2 +2090,2 @@\n-    ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL,\n-                 (const char *) xmlBufContent(ret->input->buffer),\n+        ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL,\n+                             (const char *) xmlBufContent(ret->input->buffer),\n@@ -2119,2 +2093,2 @@\n-    ret->base = 0;\n-    ret->cur = 4;\n+        ret->base = 0;\n+        ret->cur = 4;\n@@ -2122,3 +2096,3 @@\n-    ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL, NULL, 0, URI);\n-    ret->base = 0;\n-    ret->cur = 0;\n+        ret->ctxt = xmlCreatePushParserCtxt(ret->sax, NULL, NULL, 0, URI);\n+        ret->base = 0;\n+        ret->cur = 0;\n@@ -2128,4 +2102,4 @@\n-    xmlBufFree(ret->buffer);\n-    xmlFree(ret->sax);\n-    xmlFree(ret);\n-    return(NULL);\n+        xmlBufFree(ret->buffer);\n+        xmlFree(ret->sax);\n+        xmlFree(ret);\n+        return(NULL);\n@@ -2165,3 +2139,21 @@\n-    input = xmlParserInputBufferCreateFilename(URI, XML_CHAR_ENCODING_NONE);\n-    if (input == NULL)\n-    return(NULL);\n+    if (xmlParserInputBufferCreateFilenameValue != NULL) {\n+        input = xmlParserInputBufferCreateFilenameValue(URI,\n+                XML_CHAR_ENCODING_NONE);\n+        if (input == NULL) {\n+            xmlTextReaderErr(XML_IO_ENOENT, \"filaed to open %s\", URI);\n+            return(NULL);\n+        }\n+    } else {\n+        xmlParserErrors code;\n+\n+        \/*\n+         * TODO: Remove XML_INPUT_UNZIP\n+         *\/\n+        code = xmlParserInputBufferCreateUrl(URI, XML_CHAR_ENCODING_NONE,\n+                                             XML_INPUT_UNZIP, &input);\n+        if (code != XML_ERR_OK) {\n+            xmlTextReaderErr(code, \"failed to open %s\", URI);\n+            return(NULL);\n+        }\n+    }\n+\n@@ -2170,2 +2162,3 @@\n-    xmlFreeParserInputBuffer(input);\n-    return(NULL);\n+        xmlTextReaderErrMemory(NULL);\n+        xmlFreeParserInputBuffer(input);\n+        return(NULL);\n@@ -2186,2 +2179,2 @@\n-    return;\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+        return;\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -2189,2 +2182,2 @@\n-    xmlRelaxNGFree(reader->rngSchemas);\n-    reader->rngSchemas = NULL;\n+        xmlRelaxNGFree(reader->rngSchemas);\n+        reader->rngSchemas = NULL;\n@@ -2193,3 +2186,3 @@\n-    if (! reader->rngPreserveCtxt)\n-        xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n-    reader->rngValidCtxt = NULL;\n+        if (! reader->rngPreserveCtxt)\n+            xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n+        reader->rngValidCtxt = NULL;\n@@ -2197,0 +2190,2 @@\n+#endif\n+#ifdef LIBXML_SCHEMAS_ENABLED\n@@ -2198,2 +2193,2 @@\n-    xmlSchemaSAXUnplug(reader->xsdPlug);\n-    reader->xsdPlug = NULL;\n+        xmlSchemaSAXUnplug(reader->xsdPlug);\n+        reader->xsdPlug = NULL;\n@@ -2202,3 +2197,3 @@\n-    if (! reader->xsdPreserveCtxt)\n-        xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n-    reader->xsdValidCtxt = NULL;\n+        if (! reader->xsdPreserveCtxt)\n+            xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n+        reader->xsdValidCtxt = NULL;\n@@ -2207,2 +2202,2 @@\n-    xmlSchemaFree(reader->xsdSchemas);\n-    reader->xsdSchemas = NULL;\n+        xmlSchemaFree(reader->xsdSchemas);\n+        reader->xsdSchemas = NULL;\n@@ -2213,1 +2208,1 @@\n-    xmlXIncludeFreeContext(reader->xincctxt);\n+        xmlXIncludeFreeContext(reader->xincctxt);\n@@ -2218,5 +2213,5 @@\n-    for (i = 0;i < reader->patternNr;i++) {\n-        if (reader->patternTab[i] != NULL)\n-            xmlFreePattern(reader->patternTab[i]);\n-    }\n-    xmlFree(reader->patternTab);\n+        for (i = 0;i < reader->patternNr;i++) {\n+            if (reader->patternTab[i] != NULL)\n+                xmlFreePattern(reader->patternTab[i]);\n+        }\n+        xmlFree(reader->patternTab);\n@@ -2229,3 +2224,3 @@\n-        reader->dict = NULL;\n-    if (reader->allocs & XML_TEXTREADER_CTXT)\n-        xmlFreeParserCtxt(reader->ctxt);\n+            reader->dict = NULL;\n+        if (reader->allocs & XML_TEXTREADER_CTXT)\n+            xmlFreeParserCtxt(reader->ctxt);\n@@ -2234,1 +2229,1 @@\n-    xmlFree(reader->sax);\n+        xmlFree(reader->sax);\n@@ -2238,1 +2233,1 @@\n-    xmlFree(reader->entTab);\n+        xmlFree(reader->entTab);\n@@ -2245,3 +2240,3 @@\n- *                                    *\n- *            Methods for XmlTextReader            *\n- *                                    *\n+ *                                                                      *\n+ *                      Methods for XmlTextReader                       *\n+ *                                                                      *\n@@ -2262,1 +2257,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2272,2 +2267,2 @@\n-    if ((reader->ctxt->vctxt.vstateTab != NULL) &&\n-        (reader->ctxt->vctxt.vstateMax > 0)){\n+        if ((reader->ctxt->vctxt.vstateTab != NULL) &&\n+            (reader->ctxt->vctxt.vstateMax > 0)){\n@@ -2278,4 +2273,4 @@\n-        xmlFree(reader->ctxt->vctxt.vstateTab);\n-        reader->ctxt->vctxt.vstateTab = NULL;\n-        reader->ctxt->vctxt.vstateMax = 0;\n-    }\n+            xmlFree(reader->ctxt->vctxt.vstateTab);\n+            reader->ctxt->vctxt.vstateTab = NULL;\n+            reader->ctxt->vctxt.vstateMax = 0;\n+        }\n@@ -2283,6 +2278,6 @@\n-    xmlStopParser(reader->ctxt);\n-    if (reader->ctxt->myDoc != NULL) {\n-        if (reader->preserve == 0)\n-        xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);\n-        reader->ctxt->myDoc = NULL;\n-    }\n+        xmlStopParser(reader->ctxt);\n+        if (reader->ctxt->myDoc != NULL) {\n+            if (reader->preserve == 0)\n+                xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);\n+            reader->ctxt->myDoc = NULL;\n+        }\n@@ -2291,2 +2286,2 @@\n-    xmlFreeParserInputBuffer(reader->input);\n-    reader->allocs -= XML_TEXTREADER_INPUT;\n+        xmlFreeParserInputBuffer(reader->input);\n+        reader->allocs -= XML_TEXTREADER_INPUT;\n@@ -2316,1 +2311,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2318,1 +2313,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2320,1 +2315,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2323,1 +2318,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2327,1 +2322,1 @@\n-    ns = ns->next;\n+        ns = ns->next;\n@@ -2330,1 +2325,1 @@\n-    return(readerStrdup(reader, ns->href));\n+        return(readerStrdup(reader, ns->href));\n@@ -2333,4 +2328,0 @@\n-    if (cur == NULL)\n-    return(NULL);\n-    for (;i < no;i++) {\n-    cur = cur->next;\n@@ -2339,0 +2330,4 @@\n+    for (;i < no;i++) {\n+        cur = cur->next;\n+        if (cur == NULL)\n+            return(NULL);\n@@ -2369,1 +2364,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2371,1 +2366,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2373,1 +2368,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2377,1 +2372,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2448,1 +2443,1 @@\n-                const xmlChar *namespaceURI) {\n+                            const xmlChar *namespaceURI) {\n@@ -2455,1 +2450,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2457,1 +2452,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2459,1 +2454,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2463,1 +2458,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2507,1 +2502,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2509,1 +2504,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2515,6 +2510,6 @@\n-    xmlStopParser(reader->ctxt);\n-    if (reader->ctxt->myDoc != NULL) {\n-        if (reader->preserve == 0)\n-        xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);\n-        reader->ctxt->myDoc = NULL;\n-    }\n+        xmlStopParser(reader->ctxt);\n+        if (reader->ctxt->myDoc != NULL) {\n+            if (reader->preserve == 0)\n+                xmlTextReaderFreeDoc(reader, reader->ctxt->myDoc);\n+            reader->ctxt->myDoc = NULL;\n+        }\n@@ -2523,3 +2518,3 @@\n-    ret = reader->input;\n-    reader->input = NULL;\n-    reader->allocs -= XML_TEXTREADER_INPUT;\n+        ret = reader->input;\n+        reader->input = NULL;\n+        reader->allocs -= XML_TEXTREADER_INPUT;\n@@ -2527,7 +2522,7 @@\n-    \/*\n-     * Hum, one may need to duplicate the data structure because\n-     * without reference counting the input may be freed twice:\n-     *   - by the layer which allocated it.\n-     *   - by the layer to which would have been returned to.\n-     *\/\n-    return(NULL);\n+        \/*\n+         * Hum, one may need to duplicate the data structure because\n+         * without reference counting the input may be freed twice:\n+         *   - by the layer which allocated it.\n+         *   - by the layer to which would have been returned to.\n+         *\/\n+        return(NULL);\n@@ -2555,1 +2550,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2557,1 +2552,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2565,1 +2560,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2587,1 +2582,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2589,1 +2584,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2592,1 +2587,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2598,1 +2593,1 @@\n-    ns = ns->next;\n+        ns = ns->next;\n@@ -2601,2 +2596,2 @@\n-    reader->curnode = (xmlNodePtr) ns;\n-    return(1);\n+        reader->curnode = (xmlNodePtr) ns;\n+        return(1);\n@@ -2606,4 +2601,0 @@\n-    if (cur == NULL)\n-    return(0);\n-    for (;i < no;i++) {\n-    cur = cur->next;\n@@ -2612,0 +2603,4 @@\n+    for (;i < no;i++) {\n+        cur = cur->next;\n+        if (cur == NULL)\n+            return(0);\n@@ -2637,1 +2632,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2639,1 +2634,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2643,1 +2638,1 @@\n-    return(0);\n+        return(0);\n@@ -2651,0 +2646,32 @@\n+        \/*\n+         * Namespace default decl\n+         *\/\n+        if (xmlStrEqual(name, BAD_CAST \"xmlns\")) {\n+            ns = reader->node->nsDef;\n+            while (ns != NULL) {\n+                if (ns->prefix == NULL) {\n+                    reader->curnode = (xmlNodePtr) ns;\n+                    return(1);\n+                }\n+                ns = ns->next;\n+            }\n+            return(0);\n+        }\n+\n+        prop = reader->node->properties;\n+        while (prop != NULL) {\n+            \/*\n+             * One need to have\n+             *   - same attribute names\n+             *   - and the attribute carrying that namespace\n+             *\/\n+            if ((xmlStrEqual(prop->name, name)) &&\n+                ((prop->ns == NULL) || (prop->ns->prefix == NULL))) {\n+                reader->curnode = (xmlNodePtr) prop;\n+                return(1);\n+            }\n+            prop = prop->next;\n+        }\n+        return(0);\n+    }\n+\n@@ -2654,1 +2681,1 @@\n-    if (xmlStrEqual(name, BAD_CAST \"xmlns\")) {\n+    if (xmlStrEqual(prefix, BAD_CAST \"xmlns\")) {\n@@ -2657,5 +2684,5 @@\n-        if (ns->prefix == NULL) {\n-            reader->curnode = (xmlNodePtr) ns;\n-            return(1);\n-        }\n-        ns = ns->next;\n+            if ((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localname))) {\n+                reader->curnode = (xmlNodePtr) ns;\n+                goto found;\n+            }\n+            ns = ns->next;\n@@ -2663,1 +2690,1 @@\n-        return(0);\n+        goto not_found;\n@@ -2665,1 +2692,0 @@\n-\n@@ -2673,4 +2699,4 @@\n-        if ((xmlStrEqual(prop->name, name)) &&\n-        ((prop->ns == NULL) || (prop->ns->prefix == NULL))) {\n-        reader->curnode = (xmlNodePtr) prop;\n-        return(1);\n+        if ((xmlStrEqual(prop->name, localname)) &&\n+            (prop->ns != NULL) && (xmlStrEqual(prop->ns->prefix, prefix))) {\n+            reader->curnode = (xmlNodePtr) prop;\n+            goto found;\n@@ -2680,31 +2706,0 @@\n-    return(0);\n-    }\n-\n-    \/*\n-     * Namespace default decl\n-     *\/\n-    if (xmlStrEqual(prefix, BAD_CAST \"xmlns\")) {\n-    ns = reader->node->nsDef;\n-    while (ns != NULL) {\n-        if ((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localname))) {\n-        reader->curnode = (xmlNodePtr) ns;\n-        goto found;\n-        }\n-        ns = ns->next;\n-    }\n-    goto not_found;\n-    }\n-    prop = reader->node->properties;\n-    while (prop != NULL) {\n-    \/*\n-     * One need to have\n-     *   - same attribute names\n-     *   - and the attribute carrying that namespace\n-     *\/\n-    if ((xmlStrEqual(prop->name, localname)) &&\n-        (prop->ns != NULL) && (xmlStrEqual(prop->ns->prefix, prefix))) {\n-        reader->curnode = (xmlNodePtr) prop;\n-        goto found;\n-    }\n-    prop = prop->next;\n-    }\n@@ -2735,1 +2730,1 @@\n-    const xmlChar *localName, const xmlChar *namespaceURI) {\n+        const xmlChar *localName, const xmlChar *namespaceURI) {\n@@ -2742,1 +2737,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2744,1 +2739,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2746,1 +2741,1 @@\n-    return(0);\n+        return(0);\n@@ -2750,13 +2745,13 @@\n-        if (! xmlStrEqual(localName, BAD_CAST \"xmlns\")) {\n-            prefix = BAD_CAST localName;\n-        }\n-        ns = reader->node->nsDef;\n-        while (ns != NULL) {\n-            if ((prefix == NULL && ns->prefix == NULL) ||\n-                ((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localName)))) {\n-                reader->curnode = (xmlNodePtr) ns;\n-                return(1);\n-            }\n-            ns = ns->next;\n-        }\n-        return(0);\n+                if (! xmlStrEqual(localName, BAD_CAST \"xmlns\")) {\n+                        prefix = BAD_CAST localName;\n+                }\n+                ns = reader->node->nsDef;\n+                while (ns != NULL) {\n+                        if ((prefix == NULL && ns->prefix == NULL) ||\n+                                ((ns->prefix != NULL) && (xmlStrEqual(ns->prefix, localName)))) {\n+                                reader->curnode = (xmlNodePtr) ns;\n+                                return(1);\n+                        }\n+                        ns = ns->next;\n+                }\n+                return(0);\n@@ -2767,5 +2762,5 @@\n-    \/*\n-     * One need to have\n-     *   - same attribute names\n-     *   - and the attribute carrying that namespace\n-     *\/\n+        \/*\n+         * One need to have\n+         *   - same attribute names\n+         *   - and the attribute carrying that namespace\n+         *\/\n@@ -2773,4 +2768,4 @@\n-        ((prop->ns != NULL) &&\n-         (xmlStrEqual(prop->ns->href, namespaceURI)))) {\n-        reader->curnode = (xmlNodePtr) prop;\n-        return(1);\n+            ((prop->ns != NULL) &&\n+             (xmlStrEqual(prop->ns->href, namespaceURI)))) {\n+            reader->curnode = (xmlNodePtr) prop;\n+            return(1);\n@@ -2778,1 +2773,1 @@\n-    prop = prop->next;\n+        prop = prop->next;\n@@ -2795,1 +2790,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2797,1 +2792,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2799,1 +2794,1 @@\n-    return(0);\n+        return(0);\n@@ -2802,2 +2797,2 @@\n-    reader->curnode = (xmlNodePtr) reader->node->nsDef;\n-    return(1);\n+        reader->curnode = (xmlNodePtr) reader->node->nsDef;\n+        return(1);\n@@ -2806,2 +2801,2 @@\n-    reader->curnode = (xmlNodePtr) reader->node->properties;\n-    return(1);\n+        reader->curnode = (xmlNodePtr) reader->node->properties;\n+        return(1);\n@@ -2824,1 +2819,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2826,1 +2821,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2828,1 +2823,1 @@\n-    return(0);\n+        return(0);\n@@ -2830,1 +2825,1 @@\n-    return(xmlTextReaderMoveToFirstAttribute(reader));\n+        return(xmlTextReaderMoveToFirstAttribute(reader));\n@@ -2833,10 +2828,10 @@\n-    xmlNsPtr ns = (xmlNsPtr) reader->curnode;\n-    if (ns->next != NULL) {\n-        reader->curnode = (xmlNodePtr) ns->next;\n-        return(1);\n-    }\n-    if (reader->node->properties != NULL) {\n-        reader->curnode = (xmlNodePtr) reader->node->properties;\n-        return(1);\n-    }\n-    return(0);\n+        xmlNsPtr ns = (xmlNsPtr) reader->curnode;\n+        if (ns->next != NULL) {\n+            reader->curnode = (xmlNodePtr) ns->next;\n+            return(1);\n+        }\n+        if (reader->node->properties != NULL) {\n+            reader->curnode = (xmlNodePtr) reader->node->properties;\n+            return(1);\n+        }\n+        return(0);\n@@ -2844,3 +2839,3 @@\n-           (reader->curnode->next != NULL)) {\n-    reader->curnode = reader->curnode->next;\n-    return(1);\n+               (reader->curnode->next != NULL)) {\n+        reader->curnode = reader->curnode->next;\n+        return(1);\n@@ -2863,1 +2858,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2865,1 +2860,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2867,1 +2862,1 @@\n-    return(0);\n+        return(0);\n@@ -2869,2 +2864,2 @@\n-    reader->curnode = NULL;\n-    return(1);\n+        reader->curnode = NULL;\n+        return(1);\n@@ -2888,1 +2883,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2890,1 +2885,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2892,3 +2887,0 @@\n-    return(0);\n-    if (reader->curnode->type == XML_ATTRIBUTE_NODE) {\n-    if (reader->curnode->children == NULL)\n@@ -2896,1 +2888,4 @@\n-    reader->curnode = reader->curnode->children;\n+    if (reader->curnode->type == XML_ATTRIBUTE_NODE) {\n+        if (reader->curnode->children == NULL)\n+            return(0);\n+        reader->curnode = reader->curnode->children;\n@@ -2898,1 +2893,1 @@\n-    xmlNsPtr ns = (xmlNsPtr) reader->curnode;\n+        xmlNsPtr ns = (xmlNsPtr) reader->curnode;\n@@ -2900,3 +2895,3 @@\n-    if (reader->faketext == NULL) {\n-        reader->faketext = xmlNewDocText(reader->node->doc,\n-                                     ns->href);\n+        if (reader->faketext == NULL) {\n+            reader->faketext = xmlNewDocText(reader->node->doc,\n+                                             ns->href);\n@@ -2907,1 +2902,1 @@\n-    } else {\n+        } else {\n@@ -2909,3 +2904,3 @@\n-            (reader->faketext->content !=\n-         (xmlChar *) &(reader->faketext->properties)))\n-        xmlFree(reader->faketext->content);\n+                (reader->faketext->content !=\n+                 (xmlChar *) &(reader->faketext->properties)))\n+                xmlFree(reader->faketext->content);\n@@ -2921,2 +2916,2 @@\n-    }\n-    reader->curnode = reader->faketext;\n+        }\n+        reader->curnode = reader->faketext;\n@@ -2924,3 +2919,3 @@\n-    if (reader->curnode->next == NULL)\n-        return(0);\n-    reader->curnode = reader->curnode->next;\n+        if (reader->curnode->next == NULL)\n+            return(0);\n+        reader->curnode = reader->curnode->next;\n@@ -2957,3 +2952,3 @@\n- *                                    *\n- *            Access API to the current node            *\n- *                                    *\n+ *                                                                      *\n+ *                      Access API to the current node                  *\n+ *                                                                      *\n@@ -2977,1 +2972,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2979,1 +2974,1 @@\n-    return(0);\n+        return(0);\n@@ -2982,1 +2977,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -2984,1 +2979,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -2987,1 +2982,1 @@\n-    return(0);\n+        return(0);\n@@ -2989,2 +2984,2 @@\n-    (reader->state == XML_TEXTREADER_BACKTRACK))\n-    return(0);\n+        (reader->state == XML_TEXTREADER_BACKTRACK))\n+        return(0);\n@@ -2994,2 +2989,2 @@\n-    ret++;\n-    attr = attr->next;\n+        ret++;\n+        attr = attr->next;\n@@ -2999,2 +2994,2 @@\n-    ret++;\n-    ns = ns->next;\n+        ret++;\n+        ns = ns->next;\n@@ -3020,1 +3015,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3022,1 +3017,1 @@\n-    return(XML_READER_TYPE_NONE);\n+        return(XML_READER_TYPE_NONE);\n@@ -3024,1 +3019,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3026,1 +3021,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3029,4 +3024,4 @@\n-        if ((reader->state == XML_TEXTREADER_END) ||\n-        (reader->state == XML_TEXTREADER_BACKTRACK))\n-        return(XML_READER_TYPE_END_ELEMENT);\n-        return(XML_READER_TYPE_ELEMENT);\n+            if ((reader->state == XML_TEXTREADER_END) ||\n+                (reader->state == XML_TEXTREADER_BACKTRACK))\n+                return(XML_READER_TYPE_END_ELEMENT);\n+            return(XML_READER_TYPE_ELEMENT);\n@@ -3035,1 +3030,1 @@\n-        return(XML_READER_TYPE_ATTRIBUTE);\n+            return(XML_READER_TYPE_ATTRIBUTE);\n@@ -3037,8 +3032,8 @@\n-        if (xmlIsBlankNode(reader->node)) {\n-        if (xmlNodeGetSpacePreserve(reader->node))\n-            return(XML_READER_TYPE_SIGNIFICANT_WHITESPACE);\n-        else\n-            return(XML_READER_TYPE_WHITESPACE);\n-        } else {\n-        return(XML_READER_TYPE_TEXT);\n-        }\n+            if (xmlIsBlankNode(reader->node)) {\n+                if (xmlNodeGetSpacePreserve(reader->node))\n+                    return(XML_READER_TYPE_SIGNIFICANT_WHITESPACE);\n+                else\n+                    return(XML_READER_TYPE_WHITESPACE);\n+            } else {\n+                return(XML_READER_TYPE_TEXT);\n+            }\n@@ -3046,1 +3041,1 @@\n-        return(XML_READER_TYPE_CDATA);\n+            return(XML_READER_TYPE_CDATA);\n@@ -3048,1 +3043,1 @@\n-        return(XML_READER_TYPE_ENTITY_REFERENCE);\n+            return(XML_READER_TYPE_ENTITY_REFERENCE);\n@@ -3050,1 +3045,1 @@\n-        return(XML_READER_TYPE_ENTITY);\n+            return(XML_READER_TYPE_ENTITY);\n@@ -3052,1 +3047,1 @@\n-        return(XML_READER_TYPE_PROCESSING_INSTRUCTION);\n+            return(XML_READER_TYPE_PROCESSING_INSTRUCTION);\n@@ -3054,1 +3049,1 @@\n-        return(XML_READER_TYPE_COMMENT);\n+            return(XML_READER_TYPE_COMMENT);\n@@ -3057,1 +3052,1 @@\n-        return(XML_READER_TYPE_DOCUMENT);\n+            return(XML_READER_TYPE_DOCUMENT);\n@@ -3059,1 +3054,1 @@\n-        return(XML_READER_TYPE_DOCUMENT_FRAGMENT);\n+            return(XML_READER_TYPE_DOCUMENT_FRAGMENT);\n@@ -3061,1 +3056,1 @@\n-        return(XML_READER_TYPE_NOTATION);\n+            return(XML_READER_TYPE_NOTATION);\n@@ -3064,1 +3059,1 @@\n-        return(XML_READER_TYPE_DOCUMENT_TYPE);\n+            return(XML_READER_TYPE_DOCUMENT_TYPE);\n@@ -3071,1 +3066,1 @@\n-        return(XML_READER_TYPE_NONE);\n+            return(XML_READER_TYPE_NONE);\n@@ -3087,1 +3082,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3089,1 +3084,1 @@\n-    return(0);\n+        return(0);\n@@ -3091,1 +3086,1 @@\n-    return(0);\n+        return(0);\n@@ -3093,1 +3088,1 @@\n-    return(0);\n+        return(0);\n@@ -3095,1 +3090,1 @@\n-    return(0);\n+        return(0);\n@@ -3118,1 +3113,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3120,1 +3115,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3122,1 +3117,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3124,5 +3119,5 @@\n-    xmlNsPtr ns = (xmlNsPtr) node;\n-    if (ns->prefix == NULL)\n-        return(readerStrdup(reader, BAD_CAST \"xmlns\"));\n-    else\n-        return(readerStrdup(reader, ns->prefix));\n+        xmlNsPtr ns = (xmlNsPtr) node;\n+        if (ns->prefix == NULL)\n+            return(readerStrdup(reader, BAD_CAST \"xmlns\"));\n+        else\n+            return(readerStrdup(reader, ns->prefix));\n@@ -3131,2 +3126,2 @@\n-    (node->type != XML_ATTRIBUTE_NODE))\n-    return(xmlTextReaderName(reader));\n+        (node->type != XML_ATTRIBUTE_NODE))\n+        return(xmlTextReaderName(reader));\n@@ -3149,1 +3144,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3151,1 +3146,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3153,1 +3148,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3155,5 +3150,5 @@\n-    xmlNsPtr ns = (xmlNsPtr) node;\n-    if (ns->prefix == NULL)\n-        return(constString(reader, BAD_CAST \"xmlns\"));\n-    else\n-        return(ns->prefix);\n+        xmlNsPtr ns = (xmlNsPtr) node;\n+        if (ns->prefix == NULL)\n+            return(constString(reader, BAD_CAST \"xmlns\"));\n+        else\n+            return(ns->prefix);\n@@ -3162,2 +3157,2 @@\n-    (node->type != XML_ATTRIBUTE_NODE))\n-    return(xmlTextReaderConstName(reader));\n+        (node->type != XML_ATTRIBUTE_NODE))\n+        return(xmlTextReaderConstName(reader));\n@@ -3182,1 +3177,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3184,1 +3179,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3186,1 +3181,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3190,3 +3185,3 @@\n-        if ((node->ns == NULL) ||\n-        (node->ns->prefix == NULL))\n-        return(readerStrdup(reader, node->name));\n+            if ((node->ns == NULL) ||\n+                (node->ns->prefix == NULL))\n+                return(readerStrdup(reader, node->name));\n@@ -3197,1 +3192,1 @@\n-        return(ret);\n+            return(ret);\n@@ -3199,1 +3194,1 @@\n-        return(readerStrdup(reader, BAD_CAST \"#text\"));\n+            return(readerStrdup(reader, BAD_CAST \"#text\"));\n@@ -3201,1 +3196,1 @@\n-        return(readerStrdup(reader, BAD_CAST \"#cdata-section\"));\n+            return(readerStrdup(reader, BAD_CAST \"#cdata-section\"));\n@@ -3204,1 +3199,1 @@\n-        return(readerStrdup(reader, node->name));\n+            return(readerStrdup(reader, node->name));\n@@ -3206,1 +3201,1 @@\n-        return(readerStrdup(reader, node->name));\n+            return(readerStrdup(reader, node->name));\n@@ -3208,1 +3203,1 @@\n-        return(readerStrdup(reader, BAD_CAST \"#comment\"));\n+            return(readerStrdup(reader, BAD_CAST \"#comment\"));\n@@ -3211,1 +3206,1 @@\n-        return(readerStrdup(reader, BAD_CAST \"#document\"));\n+            return(readerStrdup(reader, BAD_CAST \"#document\"));\n@@ -3213,1 +3208,1 @@\n-        return(readerStrdup(reader, BAD_CAST \"#document-fragment\"));\n+            return(readerStrdup(reader, BAD_CAST \"#document-fragment\"));\n@@ -3215,1 +3210,1 @@\n-        return(readerStrdup(reader, node->name));\n+            return(readerStrdup(reader, node->name));\n@@ -3218,1 +3213,1 @@\n-        return(readerStrdup(reader, node->name));\n+            return(readerStrdup(reader, node->name));\n@@ -3220,1 +3215,1 @@\n-        xmlNsPtr ns = (xmlNsPtr) node;\n+            xmlNsPtr ns = (xmlNsPtr) node;\n@@ -3222,2 +3217,2 @@\n-        if (ns->prefix == NULL)\n-        return(readerStrdup(reader, BAD_CAST \"xmlns\"));\n+            if (ns->prefix == NULL)\n+                return(readerStrdup(reader, BAD_CAST \"xmlns\"));\n@@ -3227,2 +3222,2 @@\n-        return(ret);\n-    }\n+            return(ret);\n+        }\n@@ -3235,1 +3230,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -3254,1 +3249,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3256,1 +3251,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3258,1 +3253,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3262,4 +3257,4 @@\n-        if ((node->ns == NULL) ||\n-        (node->ns->prefix == NULL))\n-        return(node->name);\n-        return(constQString(reader, node->ns->prefix, node->name));\n+            if ((node->ns == NULL) ||\n+                (node->ns->prefix == NULL))\n+                return(node->name);\n+            return(constQString(reader, node->ns->prefix, node->name));\n@@ -3267,1 +3262,1 @@\n-        return(constString(reader, BAD_CAST \"#text\"));\n+            return(constString(reader, BAD_CAST \"#text\"));\n@@ -3269,1 +3264,1 @@\n-        return(constString(reader, BAD_CAST \"#cdata-section\"));\n+            return(constString(reader, BAD_CAST \"#cdata-section\"));\n@@ -3272,1 +3267,1 @@\n-        return(constString(reader, node->name));\n+            return(constString(reader, node->name));\n@@ -3274,1 +3269,1 @@\n-        return(constString(reader, node->name));\n+            return(constString(reader, node->name));\n@@ -3276,1 +3271,1 @@\n-        return(constString(reader, BAD_CAST \"#comment\"));\n+            return(constString(reader, BAD_CAST \"#comment\"));\n@@ -3279,1 +3274,1 @@\n-        return(constString(reader, BAD_CAST \"#document\"));\n+            return(constString(reader, BAD_CAST \"#document\"));\n@@ -3281,1 +3276,1 @@\n-        return(constString(reader, BAD_CAST \"#document-fragment\"));\n+            return(constString(reader, BAD_CAST \"#document-fragment\"));\n@@ -3283,1 +3278,1 @@\n-        return(constString(reader, node->name));\n+            return(constString(reader, node->name));\n@@ -3286,1 +3281,1 @@\n-        return(constString(reader, node->name));\n+            return(constString(reader, node->name));\n@@ -3288,1 +3283,1 @@\n-        xmlNsPtr ns = (xmlNsPtr) node;\n+            xmlNsPtr ns = (xmlNsPtr) node;\n@@ -3290,4 +3285,4 @@\n-        if (ns->prefix == NULL)\n-        return(constString(reader, BAD_CAST \"xmlns\"));\n-        return(constQString(reader, BAD_CAST \"xmlns\", ns->prefix));\n-    }\n+            if (ns->prefix == NULL)\n+                return(constString(reader, BAD_CAST \"xmlns\"));\n+            return(constQString(reader, BAD_CAST \"xmlns\", ns->prefix));\n+        }\n@@ -3300,1 +3295,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -3318,1 +3313,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3320,1 +3315,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3322,1 +3317,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3324,4 +3319,4 @@\n-    xmlNsPtr ns = (xmlNsPtr) node;\n-    if (ns->prefix == NULL)\n-        return(NULL);\n-    return(readerStrdup(reader, BAD_CAST \"xmlns\"));\n+        xmlNsPtr ns = (xmlNsPtr) node;\n+        if (ns->prefix == NULL)\n+            return(NULL);\n+        return(readerStrdup(reader, BAD_CAST \"xmlns\"));\n@@ -3330,2 +3325,2 @@\n-    (node->type != XML_ATTRIBUTE_NODE))\n-    return(NULL);\n+        (node->type != XML_ATTRIBUTE_NODE))\n+        return(NULL);\n@@ -3333,1 +3328,1 @@\n-    return(readerStrdup(reader, node->ns->prefix));\n+        return(readerStrdup(reader, node->ns->prefix));\n@@ -3350,1 +3345,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3352,1 +3347,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3354,1 +3349,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3356,4 +3351,4 @@\n-    xmlNsPtr ns = (xmlNsPtr) node;\n-    if (ns->prefix == NULL)\n-        return(NULL);\n-    return(constString(reader, BAD_CAST \"xmlns\"));\n+        xmlNsPtr ns = (xmlNsPtr) node;\n+        if (ns->prefix == NULL)\n+            return(NULL);\n+        return(constString(reader, BAD_CAST \"xmlns\"));\n@@ -3362,2 +3357,2 @@\n-    (node->type != XML_ATTRIBUTE_NODE))\n-    return(NULL);\n+        (node->type != XML_ATTRIBUTE_NODE))\n+        return(NULL);\n@@ -3365,1 +3360,1 @@\n-    return(constString(reader, node->ns->prefix));\n+        return(constString(reader, node->ns->prefix));\n@@ -3382,1 +3377,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3384,1 +3379,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3386,1 +3381,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3388,1 +3383,1 @@\n-    return(readerStrdup(reader, BAD_CAST \"http:\/\/www.w3.org\/2000\/xmlns\/\"));\n+        return(readerStrdup(reader, BAD_CAST \"http:\/\/www.w3.org\/2000\/xmlns\/\"));\n@@ -3390,2 +3385,2 @@\n-    (node->type != XML_ATTRIBUTE_NODE))\n-    return(NULL);\n+        (node->type != XML_ATTRIBUTE_NODE))\n+        return(NULL);\n@@ -3393,1 +3388,1 @@\n-    return(readerStrdup(reader, node->ns->href));\n+        return(readerStrdup(reader, node->ns->href));\n@@ -3410,1 +3405,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3412,1 +3407,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3414,1 +3409,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3416,1 +3411,1 @@\n-    return(constString(reader, BAD_CAST \"http:\/\/www.w3.org\/2000\/xmlns\/\"));\n+        return(constString(reader, BAD_CAST \"http:\/\/www.w3.org\/2000\/xmlns\/\"));\n@@ -3418,2 +3413,2 @@\n-    (node->type != XML_ATTRIBUTE_NODE))\n-    return(NULL);\n+        (node->type != XML_ATTRIBUTE_NODE))\n+        return(NULL);\n@@ -3421,1 +3416,1 @@\n-    return(constString(reader, node->ns->href));\n+        return(constString(reader, node->ns->href));\n@@ -3440,1 +3435,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3464,1 +3459,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3486,1 +3481,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3488,1 +3483,1 @@\n-    return(0);\n+        return(0);\n@@ -3491,4 +3486,4 @@\n-    if ((reader->curnode->type == XML_ATTRIBUTE_NODE) ||\n-        (reader->curnode->type == XML_NAMESPACE_DECL))\n-        return(reader->depth + 1);\n-    return(reader->depth + 2);\n+        if ((reader->curnode->type == XML_ATTRIBUTE_NODE) ||\n+            (reader->curnode->type == XML_NAMESPACE_DECL))\n+            return(reader->depth + 1);\n+        return(reader->depth + 2);\n@@ -3511,1 +3506,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3513,1 +3508,1 @@\n-    return(0);\n+        return(0);\n@@ -3515,1 +3510,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3517,1 +3512,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3520,2 +3515,2 @@\n-    ((node->properties != NULL) || (node->nsDef != NULL)))\n-    return(1);\n+        ((node->properties != NULL) || (node->nsDef != NULL)))\n+        return(1);\n@@ -3538,1 +3533,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3540,1 +3535,1 @@\n-    return(0);\n+        return(0);\n@@ -3542,1 +3537,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3544,1 +3539,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3553,3 +3548,3 @@\n-        return(1);\n-    default:\n-        break;\n+            return(1);\n+        default:\n+            break;\n@@ -3573,1 +3568,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3575,1 +3570,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3577,1 +3572,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3579,1 +3574,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3583,1 +3578,1 @@\n-        return(readerStrdup(reader, ((xmlNsPtr) node)->href));\n+            return(readerStrdup(reader, ((xmlNsPtr) node)->href));\n@@ -3585,1 +3580,1 @@\n-        xmlAttrPtr attr = (xmlAttrPtr) node;\n+            xmlAttrPtr attr = (xmlAttrPtr) node;\n@@ -3591,1 +3586,1 @@\n-        if (attr->parent != NULL)\n+            if (attr->parent != NULL)\n@@ -3593,1 +3588,1 @@\n-        ret = xmlNodeListGetString(doc, attr->children, 1);\n+            ret = xmlNodeListGetString(doc, attr->children, 1);\n@@ -3596,2 +3591,2 @@\n-        return(ret);\n-    }\n+            return(ret);\n+        }\n@@ -3603,2 +3598,2 @@\n-    default:\n-        break;\n+        default:\n+            break;\n@@ -3622,1 +3617,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3624,1 +3619,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3626,1 +3621,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -3628,1 +3623,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -3632,1 +3627,1 @@\n-        return(((xmlNsPtr) node)->href);\n+            return(((xmlNsPtr) node)->href);\n@@ -3634,10 +3629,10 @@\n-        xmlAttrPtr attr = (xmlAttrPtr) node;\n-        const xmlChar *ret;\n-\n-        if ((attr->children != NULL) &&\n-            (attr->children->type == XML_TEXT_NODE) &&\n-        (attr->children->next == NULL))\n-        return(attr->children->content);\n-        else {\n-        if (reader->buffer == NULL) {\n-            reader->buffer = xmlBufCreateSize(100);\n+            xmlAttrPtr attr = (xmlAttrPtr) node;\n+            const xmlChar *ret;\n+\n+            if ((attr->children != NULL) &&\n+                (attr->children->type == XML_TEXT_NODE) &&\n+                (attr->children->next == NULL))\n+                return(attr->children->content);\n+            else {\n+                if (reader->buffer == NULL) {\n+                    reader->buffer = xmlBufCreate(50);\n@@ -3646,2 +3641,0 @@\n-            xmlBufSetAllocationScheme(reader->buffer,\n-                                      XML_BUFFER_ALLOC_DOUBLEIT);\n@@ -3650,3 +3643,3 @@\n-            xmlBufGetNodeContent(reader->buffer, node);\n-        ret = xmlBufContent(reader->buffer);\n-        if (ret == NULL) {\n+                xmlBufGetNodeContent(reader->buffer, node);\n+                ret = xmlBufContent(reader->buffer);\n+                if (ret == NULL) {\n@@ -3654,7 +3647,7 @@\n-            \/* error on the buffer best to reallocate *\/\n-            xmlBufFree(reader->buffer);\n-            reader->buffer = xmlBufCreateSize(100);\n-            xmlBufSetAllocationScheme(reader->buffer,\n-                                      XML_BUFFER_ALLOC_DOUBLEIT);\n-        }\n-        return(ret);\n+                    \/* error on the buffer best to reallocate *\/\n+                    xmlBufFree(reader->buffer);\n+                    reader->buffer = xmlBufCreate(50);\n+                }\n+                return(ret);\n+            }\n+            break;\n@@ -3662,2 +3655,0 @@\n-        break;\n-    }\n@@ -3668,3 +3659,3 @@\n-        return(node->content);\n-    default:\n-        break;\n+            return(node->content);\n+        default:\n+            break;\n@@ -3687,1 +3678,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3702,1 +3693,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3719,1 +3710,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3721,1 +3712,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3739,1 +3730,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3741,1 +3732,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3764,1 +3755,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3783,1 +3774,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3788,3 +3779,3 @@\n- *                                    *\n- *            Extensions to the base APIs            *\n- *                                    *\n+ *                                                                      *\n+ *                      Extensions to the base APIs                     *\n+ *                                                                      *\n@@ -3811,1 +3802,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3816,4 +3807,4 @@\n-        if (value != 0) {\n-        if (ctxt->loadsubset == 0) {\n-            if (reader->mode != XML_TEXTREADER_MODE_INITIAL)\n-            return(-1);\n+            if (value != 0) {\n+                if (ctxt->loadsubset == 0) {\n+                    if (reader->mode != XML_TEXTREADER_MODE_INITIAL)\n+                        return(-1);\n@@ -3821,3 +3812,3 @@\n-            ctxt->loadsubset |= XML_DETECT_IDS;\n-        }\n-        } else {\n+                    ctxt->loadsubset |= XML_DETECT_IDS;\n+                }\n+            } else {\n@@ -3825,3 +3816,3 @@\n-        ctxt->loadsubset &= ~XML_DETECT_IDS;\n-        }\n-        return(0);\n+                ctxt->loadsubset &= ~XML_DETECT_IDS;\n+            }\n+            return(0);\n@@ -3829,1 +3820,1 @@\n-        if (value != 0) {\n+            if (value != 0) {\n@@ -3831,2 +3822,2 @@\n-        ctxt->loadsubset |= XML_COMPLETE_ATTRS;\n-        } else {\n+                ctxt->loadsubset |= XML_COMPLETE_ATTRS;\n+            } else {\n@@ -3834,3 +3825,3 @@\n-        ctxt->loadsubset &= ~XML_COMPLETE_ATTRS;\n-        }\n-        return(0);\n+                ctxt->loadsubset &= ~XML_COMPLETE_ATTRS;\n+            }\n+            return(0);\n@@ -3838,1 +3829,1 @@\n-        if (value != 0) {\n+            if (value != 0) {\n@@ -3840,3 +3831,3 @@\n-        ctxt->validate = 1;\n-        reader->validate = XML_TEXTREADER_VALIDATE_DTD;\n-        } else {\n+                ctxt->validate = 1;\n+                reader->validate = XML_TEXTREADER_VALIDATE_DTD;\n+            } else {\n@@ -3844,3 +3835,3 @@\n-        ctxt->validate = 0;\n-        }\n-        return(0);\n+                ctxt->validate = 0;\n+            }\n+            return(0);\n@@ -3848,1 +3839,1 @@\n-        if (value != 0) {\n+            if (value != 0) {\n@@ -3850,2 +3841,2 @@\n-        ctxt->replaceEntities = 1;\n-        } else {\n+                ctxt->replaceEntities = 1;\n+            } else {\n@@ -3853,3 +3844,3 @@\n-        ctxt->replaceEntities = 0;\n-        }\n-        return(0);\n+                ctxt->replaceEntities = 0;\n+            }\n+            return(0);\n@@ -3875,1 +3866,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3880,3 +3871,3 @@\n-        if ((ctxt->loadsubset != 0) || (ctxt->validate != 0))\n-        return(1);\n-        return(0);\n+            if ((ctxt->loadsubset != 0) || (ctxt->validate != 0))\n+                return(1);\n+            return(0);\n@@ -3884,3 +3875,3 @@\n-        if (ctxt->loadsubset & XML_COMPLETE_ATTRS)\n-        return(1);\n-        return(0);\n+            if (ctxt->loadsubset & XML_COMPLETE_ATTRS)\n+                return(1);\n+            return(0);\n@@ -3888,3 +3879,3 @@\n-        return(reader->validate);\n-    case XML_PARSER_SUBST_ENTITIES:\n-        return(ctxt->replaceEntities);\n+            return(reader->validate);\n+        case XML_PARSER_SUBST_ENTITIES:\n+            return(ctxt->replaceEntities);\n@@ -3945,1 +3936,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3948,1 +3939,1 @@\n-    return(reader->curnode);\n+        return(reader->curnode);\n@@ -3967,1 +3958,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3974,2 +3965,2 @@\n-    cur->extra |= NODE_IS_PRESERVED;\n-    cur->extra |= NODE_IS_SPRESERVED;\n+        cur->extra |= NODE_IS_PRESERVED;\n+        cur->extra |= NODE_IS_SPRESERVED;\n@@ -3982,2 +3973,2 @@\n-        parent->extra |= NODE_IS_PRESERVED;\n-    parent = parent->parent;\n+            parent->extra |= NODE_IS_PRESERVED;\n+        parent = parent->parent;\n@@ -4008,1 +3999,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4014,9 +4005,0 @@\n-    if (reader->patternMax <= 0) {\n-    reader->patternMax = 4;\n-    reader->patternTab = (xmlPatternPtr *) xmlMalloc(reader->patternMax *\n-                          sizeof(reader->patternTab[0]));\n-        if (reader->patternTab == NULL) {\n-            xmlTextReaderErrMemory(reader);\n-            return (-1);\n-        }\n-    }\n@@ -4025,4 +4007,9 @@\n-        reader->patternMax *= 2;\n-    tmp = (xmlPatternPtr *) xmlRealloc(reader->patternTab,\n-                                      reader->patternMax *\n-                                      sizeof(reader->patternTab[0]));\n+        int newSize;\n+\n+        newSize = xmlGrowCapacity(reader->patternMax, sizeof(tmp[0]),\n+                                  4, XML_MAX_ITEMS);\n+        if (newSize < 0) {\n+            xmlTextReaderErrMemory(reader);\n+            return(-1);\n+        }\n+        tmp = xmlRealloc(reader->patternTab, newSize * sizeof(tmp[0]));\n@@ -4031,2 +4018,1 @@\n-        reader->patternMax \/= 2;\n-            return (-1);\n+            return(-1);\n@@ -4034,1 +4020,2 @@\n-    reader->patternTab = tmp;\n+        reader->patternTab = tmp;\n+        reader->patternMax = newSize;\n@@ -4056,1 +4043,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4060,1 +4047,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4066,1 +4053,1 @@\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -4087,3 +4074,3 @@\n-        xmlRelaxNGFree(reader->rngSchemas);\n-        reader->rngSchemas = NULL;\n-    }\n+            xmlRelaxNGFree(reader->rngSchemas);\n+            reader->rngSchemas = NULL;\n+        }\n@@ -4091,3 +4078,3 @@\n-        if (! reader->rngPreserveCtxt)\n-        xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n-        reader->rngValidCtxt = NULL;\n+            if (! reader->rngPreserveCtxt)\n+                xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n+            reader->rngValidCtxt = NULL;\n@@ -4095,2 +4082,2 @@\n-    reader->rngPreserveCtxt = 0;\n-    return(0);\n+        reader->rngPreserveCtxt = 0;\n+        return(0);\n@@ -4099,1 +4086,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4101,2 +4088,2 @@\n-    xmlRelaxNGFree(reader->rngSchemas);\n-    reader->rngSchemas = NULL;\n+        xmlRelaxNGFree(reader->rngSchemas);\n+        reader->rngSchemas = NULL;\n@@ -4105,3 +4092,3 @@\n-    if (! reader->rngPreserveCtxt)\n-        xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n-    reader->rngValidCtxt = NULL;\n+        if (! reader->rngPreserveCtxt)\n+            xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n+        reader->rngValidCtxt = NULL;\n@@ -4114,2 +4101,2 @@\n-    xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt,\n-            xmlTextReaderStructuredRelay, reader);\n+        xmlRelaxNGSetValidStructuredErrors(reader->rngValidCtxt,\n+                        xmlTextReaderStructuredRelay, reader);\n@@ -4121,0 +4108,1 @@\n+#endif \/* LIBXML_RELAXNG_ENABLED *\/\n@@ -4122,0 +4110,1 @@\n+#ifdef LIBXML_SCHEMAS_ENABLED\n@@ -4147,5 +4136,5 @@\n-    if (file != NULL)\n-        *file = reader->ctxt->input->filename;\n-    if (line != NULL)\n-        *line = reader->ctxt->input->line;\n-    return(0);\n+        if (file != NULL)\n+            *file = reader->ctxt->input->filename;\n+        if (line != NULL)\n+            *line = reader->ctxt->input->line;\n+        return(0);\n@@ -4155,1 +4144,1 @@\n-    int ret = 0;\n+        int ret = 0;\n@@ -4157,5 +4146,5 @@\n-    if (line != NULL) {\n-        res = xmlGetLineNo(reader->node);\n-        if (res > 0)\n-            *line = (unsigned long) res;\n-        else\n+        if (line != NULL) {\n+            res = xmlGetLineNo(reader->node);\n+            if (res > 0)\n+                *line = (unsigned long) res;\n+            else\n@@ -4163,1 +4152,1 @@\n-    }\n+        }\n@@ -4165,4 +4154,4 @@\n-        xmlDocPtr doc = reader->node->doc;\n-        if ((doc != NULL) && (doc->URL != NULL))\n-            *file = (const char *) doc->URL;\n-        else\n+            xmlDocPtr doc = reader->node->doc;\n+            if ((doc != NULL) && (doc->URL != NULL))\n+                *file = (const char *) doc->URL;\n+            else\n@@ -4170,2 +4159,2 @@\n-    }\n-    return(ret);\n+        }\n+        return(ret);\n@@ -4195,4 +4184,4 @@\n-    if (reader->xsdPlug != NULL) {\n-        xmlSchemaSAXUnplug(reader->xsdPlug);\n-        reader->xsdPlug = NULL;\n-    }\n+        if (reader->xsdPlug != NULL) {\n+            xmlSchemaSAXUnplug(reader->xsdPlug);\n+            reader->xsdPlug = NULL;\n+        }\n@@ -4200,3 +4189,3 @@\n-        if (! reader->xsdPreserveCtxt)\n-        xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n-        reader->xsdValidCtxt = NULL;\n+            if (! reader->xsdPreserveCtxt)\n+                xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n+            reader->xsdValidCtxt = NULL;\n@@ -4204,1 +4193,1 @@\n-    reader->xsdPreserveCtxt = 0;\n+        reader->xsdPreserveCtxt = 0;\n@@ -4206,4 +4195,4 @@\n-        xmlSchemaFree(reader->xsdSchemas);\n-        reader->xsdSchemas = NULL;\n-    }\n-    return(0);\n+            xmlSchemaFree(reader->xsdSchemas);\n+            reader->xsdSchemas = NULL;\n+        }\n+        return(0);\n@@ -4212,1 +4201,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4214,2 +4203,2 @@\n-    xmlSchemaSAXUnplug(reader->xsdPlug);\n-    reader->xsdPlug = NULL;\n+        xmlSchemaSAXUnplug(reader->xsdPlug);\n+        reader->xsdPlug = NULL;\n@@ -4218,3 +4207,3 @@\n-    if (! reader->xsdPreserveCtxt)\n-        xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n-    reader->xsdValidCtxt = NULL;\n+        if (! reader->xsdPreserveCtxt)\n+            xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n+        reader->xsdValidCtxt = NULL;\n@@ -4224,2 +4213,2 @@\n-    xmlSchemaFree(reader->xsdSchemas);\n-    reader->xsdSchemas = NULL;\n+        xmlSchemaFree(reader->xsdSchemas);\n+        reader->xsdSchemas = NULL;\n@@ -4229,2 +4218,2 @@\n-    xmlSchemaFree(reader->xsdSchemas);\n-    reader->xsdSchemas = NULL;\n+        xmlSchemaFree(reader->xsdSchemas);\n+        reader->xsdSchemas = NULL;\n@@ -4235,1 +4224,1 @@\n-                       &(reader->ctxt->userData));\n+                                       &(reader->ctxt->userData));\n@@ -4237,5 +4226,5 @@\n-    xmlSchemaFree(reader->xsdSchemas);\n-    reader->xsdSchemas = NULL;\n-    xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n-    reader->xsdValidCtxt = NULL;\n-    return(-1);\n+        xmlSchemaFree(reader->xsdSchemas);\n+        reader->xsdSchemas = NULL;\n+        xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n+        reader->xsdValidCtxt = NULL;\n+        return(-1);\n@@ -4245,1 +4234,1 @@\n-                (void *) reader);\n+                                (void *) reader);\n@@ -4248,2 +4237,2 @@\n-    xmlSchemaSetValidStructuredErrors(reader->xsdValidCtxt,\n-            xmlTextReaderStructuredRelay, reader);\n+        xmlSchemaSetValidStructuredErrors(reader->xsdValidCtxt,\n+                        xmlTextReaderStructuredRelay, reader);\n@@ -4254,0 +4243,1 @@\n+#endif \/* LIBXML_SCHEMAS_ENABLED *\/\n@@ -4255,0 +4245,1 @@\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -4267,1 +4258,1 @@\n- *       -1 in case of error.\n+ *         -1 in case of error.\n@@ -4271,3 +4262,3 @@\n-                     const char *rng,\n-                     xmlRelaxNGValidCtxtPtr ctxt,\n-                     int options ATTRIBUTE_UNUSED)\n+                                     const char *rng,\n+                                     xmlRelaxNGValidCtxtPtr ctxt,\n+                                     int options ATTRIBUTE_UNUSED)\n@@ -4276,1 +4267,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4279,1 +4270,1 @@\n-    return (-1);\n+        return (-1);\n@@ -4282,3 +4273,3 @@\n-    ((reader->mode != XML_TEXTREADER_MODE_INITIAL) ||\n-     (reader->ctxt == NULL)))\n-    return(-1);\n+        ((reader->mode != XML_TEXTREADER_MODE_INITIAL) ||\n+         (reader->ctxt == NULL)))\n+        return(-1);\n@@ -4288,3 +4279,3 @@\n-    if ( !reader->rngPreserveCtxt)\n-        xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n-    reader->rngValidCtxt = NULL;\n+        if ( !reader->rngPreserveCtxt)\n+            xmlRelaxNGFreeValidCtxt(reader->rngValidCtxt);\n+        reader->rngValidCtxt = NULL;\n@@ -4294,2 +4285,2 @@\n-    xmlRelaxNGFree(reader->rngSchemas);\n-    reader->rngSchemas = NULL;\n+        xmlRelaxNGFree(reader->rngSchemas);\n+        reader->rngSchemas = NULL;\n@@ -4299,2 +4290,2 @@\n-    \/* We just want to deactivate the validation, so get out. *\/\n-    return(0);\n+        \/* We just want to deactivate the validation, so get out. *\/\n+        return(0);\n@@ -4305,2 +4296,2 @@\n-    xmlRelaxNGParserCtxtPtr pctxt;\n-    \/* Parse the schema and create validation environment. *\/\n+        xmlRelaxNGParserCtxtPtr pctxt;\n+        \/* Parse the schema and create validation environment. *\/\n@@ -4308,3 +4299,3 @@\n-    pctxt = xmlRelaxNGNewParserCtxt(rng);\n-    if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n-        xmlRelaxNGSetParserStructuredErrors(pctxt,\n+        pctxt = xmlRelaxNGNewParserCtxt(rng);\n+        if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n+            xmlRelaxNGSetParserStructuredErrors(pctxt,\n@@ -4312,4 +4303,4 @@\n-    reader->rngSchemas = xmlRelaxNGParse(pctxt);\n-    xmlRelaxNGFreeParserCtxt(pctxt);\n-    if (reader->rngSchemas == NULL)\n-        return(-1);\n+        reader->rngSchemas = xmlRelaxNGParse(pctxt);\n+        xmlRelaxNGFreeParserCtxt(pctxt);\n+        if (reader->rngSchemas == NULL)\n+            return(-1);\n@@ -4317,6 +4308,6 @@\n-    reader->rngValidCtxt = xmlRelaxNGNewValidCtxt(reader->rngSchemas);\n-    if (reader->rngValidCtxt == NULL) {\n-        xmlRelaxNGFree(reader->rngSchemas);\n-        reader->rngSchemas = NULL;\n-        return(-1);\n-    }\n+        reader->rngValidCtxt = xmlRelaxNGNewValidCtxt(reader->rngSchemas);\n+        if (reader->rngValidCtxt == NULL) {\n+            xmlRelaxNGFree(reader->rngSchemas);\n+            reader->rngSchemas = NULL;\n+            return(-1);\n+        }\n@@ -4324,3 +4315,3 @@\n-    \/* Use the given validation context. *\/\n-    reader->rngValidCtxt = ctxt;\n-    reader->rngPreserveCtxt = 1;\n+        \/* Use the given validation context. *\/\n+        reader->rngValidCtxt = ctxt;\n+        reader->rngPreserveCtxt = 1;\n@@ -4332,1 +4323,1 @@\n-    *    could make this redirection optional.\n+    *   could make this redirection optional.\n@@ -4342,0 +4333,1 @@\n+#endif \/* LIBXML_RELAXNG_ENABLED *\/\n@@ -4343,0 +4335,1 @@\n+#ifdef LIBXML_SCHEMAS_ENABLED\n@@ -4359,3 +4352,3 @@\n-                    const char *xsd,\n-                    xmlSchemaValidCtxtPtr ctxt,\n-                    int options ATTRIBUTE_UNUSED)\n+                                    const char *xsd,\n+                                    xmlSchemaValidCtxtPtr ctxt,\n+                                    int options ATTRIBUTE_UNUSED)\n@@ -4367,1 +4360,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4370,1 +4363,1 @@\n-    ((reader->mode != XML_TEXTREADER_MODE_INITIAL) ||\n+        ((reader->mode != XML_TEXTREADER_MODE_INITIAL) ||\n@@ -4372,1 +4365,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4376,2 +4369,2 @@\n-    xmlSchemaSAXUnplug(reader->xsdPlug);\n-    reader->xsdPlug = NULL;\n+        xmlSchemaSAXUnplug(reader->xsdPlug);\n+        reader->xsdPlug = NULL;\n@@ -4380,3 +4373,3 @@\n-    if (! reader->xsdPreserveCtxt)\n-        xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n-    reader->xsdValidCtxt = NULL;\n+        if (! reader->xsdPreserveCtxt)\n+            xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n+        reader->xsdValidCtxt = NULL;\n@@ -4386,2 +4379,2 @@\n-    xmlSchemaFree(reader->xsdSchemas);\n-    reader->xsdSchemas = NULL;\n+        xmlSchemaFree(reader->xsdSchemas);\n+        reader->xsdSchemas = NULL;\n@@ -4391,2 +4384,2 @@\n-    \/* We just want to deactivate the validation, so get out. *\/\n-    return(0);\n+        \/* We just want to deactivate the validation, so get out. *\/\n+        return(0);\n@@ -4396,5 +4389,5 @@\n-    xmlSchemaParserCtxtPtr pctxt;\n-    \/* Parse the schema and create validation environment. *\/\n-    pctxt = xmlSchemaNewParserCtxt(xsd);\n-    if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n-        xmlSchemaSetParserStructuredErrors(pctxt,\n+        xmlSchemaParserCtxtPtr pctxt;\n+        \/* Parse the schema and create validation environment. *\/\n+        pctxt = xmlSchemaNewParserCtxt(xsd);\n+        if ((reader->errorFunc != NULL) || (reader->sErrorFunc != NULL))\n+            xmlSchemaSetParserStructuredErrors(pctxt,\n@@ -4402,20 +4395,20 @@\n-    reader->xsdSchemas = xmlSchemaParse(pctxt);\n-    xmlSchemaFreeParserCtxt(pctxt);\n-    if (reader->xsdSchemas == NULL)\n-        return(-1);\n-    reader->xsdValidCtxt = xmlSchemaNewValidCtxt(reader->xsdSchemas);\n-    if (reader->xsdValidCtxt == NULL) {\n-        xmlSchemaFree(reader->xsdSchemas);\n-        reader->xsdSchemas = NULL;\n-        return(-1);\n-    }\n-    reader->xsdPlug = xmlSchemaSAXPlug(reader->xsdValidCtxt,\n-        &(reader->ctxt->sax),\n-        &(reader->ctxt->userData));\n-    if (reader->xsdPlug == NULL) {\n-        xmlSchemaFree(reader->xsdSchemas);\n-        reader->xsdSchemas = NULL;\n-        xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n-        reader->xsdValidCtxt = NULL;\n-        return(-1);\n-    }\n+        reader->xsdSchemas = xmlSchemaParse(pctxt);\n+        xmlSchemaFreeParserCtxt(pctxt);\n+        if (reader->xsdSchemas == NULL)\n+            return(-1);\n+        reader->xsdValidCtxt = xmlSchemaNewValidCtxt(reader->xsdSchemas);\n+        if (reader->xsdValidCtxt == NULL) {\n+            xmlSchemaFree(reader->xsdSchemas);\n+            reader->xsdSchemas = NULL;\n+            return(-1);\n+        }\n+        reader->xsdPlug = xmlSchemaSAXPlug(reader->xsdValidCtxt,\n+            &(reader->ctxt->sax),\n+            &(reader->ctxt->userData));\n+        if (reader->xsdPlug == NULL) {\n+            xmlSchemaFree(reader->xsdSchemas);\n+            reader->xsdSchemas = NULL;\n+            xmlSchemaFreeValidCtxt(reader->xsdValidCtxt);\n+            reader->xsdValidCtxt = NULL;\n+            return(-1);\n+        }\n@@ -4423,11 +4416,11 @@\n-    \/* Use the given validation context. *\/\n-    reader->xsdValidCtxt = ctxt;\n-    reader->xsdPreserveCtxt = 1;\n-    reader->xsdPlug = xmlSchemaSAXPlug(reader->xsdValidCtxt,\n-        &(reader->ctxt->sax),\n-        &(reader->ctxt->userData));\n-    if (reader->xsdPlug == NULL) {\n-        reader->xsdValidCtxt = NULL;\n-        reader->xsdPreserveCtxt = 0;\n-        return(-1);\n-    }\n+        \/* Use the given validation context. *\/\n+        reader->xsdValidCtxt = ctxt;\n+        reader->xsdPreserveCtxt = 1;\n+        reader->xsdPlug = xmlSchemaSAXPlug(reader->xsdValidCtxt,\n+            &(reader->ctxt->sax),\n+            &(reader->ctxt->userData));\n+        if (reader->xsdPlug == NULL) {\n+            reader->xsdValidCtxt = NULL;\n+            reader->xsdPreserveCtxt = 0;\n+            return(-1);\n+        }\n@@ -4437,1 +4430,1 @@\n-                (void *) reader);\n+                                (void *) reader);\n@@ -4445,2 +4438,2 @@\n-    xmlSchemaSetValidStructuredErrors(reader->xsdValidCtxt,\n-            xmlTextReaderStructuredRelay, reader);\n+        xmlSchemaSetValidStructuredErrors(reader->xsdValidCtxt,\n+                        xmlTextReaderStructuredRelay, reader);\n@@ -4467,2 +4460,2 @@\n-                    xmlSchemaValidCtxtPtr ctxt,\n-                    int options)\n+                                    xmlSchemaValidCtxtPtr ctxt,\n+                                    int options)\n@@ -4490,0 +4483,1 @@\n+#endif \/* LIBXML_SCHEMAS_ENABLED *\/\n@@ -4491,0 +4485,1 @@\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -4506,2 +4501,2 @@\n-                 xmlRelaxNGValidCtxtPtr ctxt,\n-                 int options)\n+                                 xmlRelaxNGValidCtxtPtr ctxt,\n+                                 int options)\n@@ -4529,2 +4524,1 @@\n-\n-#endif\n+#endif \/* LIBXML_RELAXNG_ENABLED *\/\n@@ -4547,1 +4541,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4549,1 +4543,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4551,1 +4545,1 @@\n-    node = reader->curnode;\n+        node = reader->curnode;\n@@ -4553,1 +4547,1 @@\n-    node = reader->node;\n+        node = reader->node;\n@@ -4556,1 +4550,1 @@\n-    return(1);\n+        return(1);\n@@ -4558,1 +4552,1 @@\n-    return(0);\n+        return(0);\n@@ -4574,1 +4568,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4578,1 +4572,1 @@\n-    doc = reader->ctxt->myDoc;\n+        doc = reader->ctxt->myDoc;\n@@ -4580,1 +4574,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4583,1 +4577,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4602,1 +4596,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4606,1 +4600,1 @@\n-    doc = reader->ctxt->myDoc;\n+        doc = reader->ctxt->myDoc;\n@@ -4608,1 +4602,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4614,3 +4608,3 @@\n- *                                    *\n- *            Error Handling Extensions                       *\n- *                                    *\n+ *                                                                      *\n+ *                      Error Handling Extensions                       *\n+ *                                                                      *\n@@ -4636,10 +4630,1 @@\n-    ret = xmlGetLineNo(ctx->node);\n-    }\n-    else {\n-    \/* inspired from error.c *\/\n-    xmlParserInputPtr input;\n-    input = ctx->input;\n-    if ((input->filename == NULL) && (ctx->inputNr > 1))\n-        input = ctx->inputTab[ctx->inputNr - 2];\n-    if (input != NULL) {\n-        ret = input->line;\n+        ret = xmlGetLineNo(ctx->node);\n@@ -4648,2 +4633,11 @@\n-        ret = -1;\n-    }\n+        \/* inspired from error.c *\/\n+        xmlParserInputPtr input;\n+        input = ctx->input;\n+        if ((input->filename == NULL) && (ctx->inputNr > 1))\n+            input = ctx->inputTab[ctx->inputNr - 2];\n+        if (input != NULL) {\n+            ret = input->line;\n+        }\n+        else {\n+            ret = -1;\n+        }\n@@ -4673,10 +4667,1 @@\n-    ret = xmlNodeGetBase(NULL,ctx->node);\n-    }\n-    else {\n-    \/* inspired from error.c *\/\n-    xmlParserInputPtr input;\n-    input = ctx->input;\n-    if ((input->filename == NULL) && (ctx->inputNr > 1))\n-        input = ctx->inputTab[ctx->inputNr - 2];\n-    if (input != NULL) {\n-        ret = xmlStrdup(BAD_CAST input->filename);\n+        ret = xmlNodeGetBase(NULL,ctx->node);\n@@ -4685,2 +4670,11 @@\n-        ret = NULL;\n-    }\n+        \/* inspired from error.c *\/\n+        xmlParserInputPtr input;\n+        input = ctx->input;\n+        if ((input->filename == NULL) && (ctx->inputNr > 1))\n+            input = ctx->inputTab[ctx->inputNr - 2];\n+        if (input != NULL) {\n+            ret = xmlStrdup(BAD_CAST input->filename);\n+        }\n+        else {\n+            ret = NULL;\n+        }\n@@ -4695,1 +4689,1 @@\n- * @f:    the callback function to call on error and warnings\n+ * @f:  the callback function to call on error and warnings\n@@ -4714,1 +4708,1 @@\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -4719,0 +4713,2 @@\n+#endif\n+#ifdef LIBXML_SCHEMAS_ENABLED\n@@ -4730,1 +4726,1 @@\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -4735,0 +4731,2 @@\n+#endif\n+#ifdef LIBXML_SCHEMAS_ENABLED\n@@ -4746,1 +4744,1 @@\n- * @f:    the callback function to call on error and warnings\n+ * @f:  the callback function to call on error and warnings\n@@ -4763,1 +4761,1 @@\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -4768,0 +4766,2 @@\n+#endif\n+#ifdef LIBXML_SCHEMAS_ENABLED\n@@ -4779,1 +4779,1 @@\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -4784,0 +4784,2 @@\n+#endif\n+#ifdef LIBXML_SCHEMAS_ENABLED\n@@ -4792,0 +4794,41 @@\n+\/**\n+ * xmlTextReaderGetErrorHandler:\n+ * @reader:  the xmlTextReaderPtr used\n+ * @f:  the callback function or NULL is no callback has been registered\n+ * @arg:    a user argument\n+ *\n+ * Retrieve the error callback function and user argument.\n+ *\/\n+void\n+xmlTextReaderGetErrorHandler(xmlTextReaderPtr reader,\n+                             xmlTextReaderErrorFunc * f, void **arg)\n+{\n+    if (f != NULL)\n+        *f = reader->errorFunc;\n+    if (arg != NULL)\n+        *arg = reader->errorFuncArg;\n+}\n+\n+\/**\n+ * xmlTextReaderSetResourceLoader:\n+ * @reader:  thr reader\n+ * @loader:  resource loader\n+ * @data:  user data which will be passed to the loader\n+ *\n+ * Register a callback function that will be called to load external\n+ * resources like entities.\n+ *\n+ * Available since 2.14.0.\n+ *\/\n+void\n+xmlTextReaderSetResourceLoader(xmlTextReaderPtr reader,\n+                               xmlResourceLoader loader, void *data) {\n+    if ((reader == NULL) || (reader->ctxt == NULL))\n+        return;\n+\n+    reader->resourceLoader = loader;\n+    reader->resourceCtxt = data;\n+\n+    xmlCtxtSetResourceLoader(reader->ctxt, loader, data);\n+}\n+\n@@ -4805,1 +4848,1 @@\n-#ifdef LIBXML_SCHEMAS_ENABLED\n+#ifdef LIBXML_RELAXNG_ENABLED\n@@ -4808,0 +4851,2 @@\n+#endif\n+#ifdef LIBXML_SCHEMAS_ENABLED\n@@ -4816,17 +4861,0 @@\n-\/**\n- * xmlTextReaderGetErrorHandler:\n- * @reader:  the xmlTextReaderPtr used\n- * @f:    the callback function or NULL is no callback has been registered\n- * @arg:    a user argument\n- *\n- * Retrieve the error callback function and user argument.\n- *\/\n-void\n-xmlTextReaderGetErrorHandler(xmlTextReaderPtr reader,\n-                             xmlTextReaderErrorFunc * f, void **arg)\n-{\n-    if (f != NULL)\n-        *f = reader->errorFunc;\n-    if (arg != NULL)\n-        *arg = reader->errorFuncArg;\n-}\n@@ -4834,3 +4862,3 @@\n- *                                    *\n- *    New set (2.6.0) of simpler and more flexible APIs        *\n- *                                    *\n+ *                                                                      *\n+ *      New set (2.6.0) of simpler and more flexible APIs               *\n+ *                                                                      *\n@@ -4859,1 +4887,1 @@\n-        xmlFreeParserInputBuffer(input);\n+            xmlFreeParserInputBuffer(input);\n@@ -4875,3 +4903,3 @@\n-    xmlFreeParserInputBuffer(reader->input);\n-    reader->input = NULL;\n-    reader->allocs -= XML_TEXTREADER_INPUT;\n+        xmlFreeParserInputBuffer(reader->input);\n+        reader->input = NULL;\n+        reader->allocs -= XML_TEXTREADER_INPUT;\n@@ -4880,2 +4908,2 @@\n-    reader->input = input;\n-    reader->allocs |= XML_TEXTREADER_INPUT;\n+        reader->input = input;\n+        reader->allocs |= XML_TEXTREADER_INPUT;\n@@ -4884,1 +4912,1 @@\n-        reader->buffer = xmlBufCreateSize(100);\n+        reader->buffer = xmlBufCreate(50);\n@@ -4888,3 +4916,0 @@\n-    \/* no operation on a reader should require a huge buffer *\/\n-    xmlBufSetAllocationScheme(reader->buffer,\n-                  XML_BUFFER_ALLOC_DOUBLEIT);\n@@ -4892,1 +4917,1 @@\n-    reader->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));\n+        reader->sax = (xmlSAXHandler *) xmlMalloc(sizeof(xmlSAXHandler));\n@@ -4930,1 +4955,1 @@\n-               (const char *) xmlBufContent(reader->input->buffer),\n+                       (const char *) xmlBufContent(reader->input->buffer),\n@@ -4944,11 +4969,11 @@\n-        xmlParserInputPtr inputStream;\n-        xmlParserInputBufferPtr buf;\n-\n-        xmlCtxtReset(reader->ctxt);\n-        buf = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);\n-        if (buf == NULL) return(-1);\n-        inputStream = xmlNewInputStream(reader->ctxt);\n-        if (inputStream == NULL) {\n-        xmlFreeParserInputBuffer(buf);\n-        return(-1);\n-        }\n+            xmlParserInputPtr inputStream;\n+            xmlParserInputBufferPtr buf;\n+\n+            xmlCtxtReset(reader->ctxt);\n+            buf = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);\n+            if (buf == NULL) return(-1);\n+            inputStream = xmlNewInputStream(reader->ctxt);\n+            if (inputStream == NULL) {\n+                xmlFreeParserInputBuffer(buf);\n+                return(-1);\n+            }\n@@ -4956,6 +4981,6 @@\n-        if (URL == NULL)\n-        inputStream->filename = NULL;\n-        else\n-        inputStream->filename = (char *)\n-            xmlCanonicPath((const xmlChar *) URL);\n-        inputStream->buf = buf;\n+            if (URL == NULL)\n+                inputStream->filename = NULL;\n+            else\n+                inputStream->filename = (char *)\n+                    xmlCanonicPath((const xmlChar *) URL);\n+            inputStream->buf = buf;\n@@ -4964,3 +4989,6 @@\n-        inputPush(reader->ctxt, inputStream);\n-        reader->cur = 0;\n-    }\n+            if (xmlCtxtPushInput(reader->ctxt, inputStream) < 0) {\n+                xmlFreeInputStream(inputStream);\n+                return(-1);\n+            }\n+            reader->cur = 0;\n+        }\n@@ -4970,3 +4998,6 @@\n-        if (reader->dict != reader->ctxt->dict) {\n-        xmlDictFree(reader->dict);\n-        reader->dict = reader->ctxt->dict;\n+            if (reader->dict != reader->ctxt->dict) {\n+                xmlDictFree(reader->dict);\n+                reader->dict = reader->ctxt->dict;\n+            }\n+        } else {\n+            reader->ctxt->dict = reader->dict;\n@@ -4975,5 +5006,2 @@\n-        reader->ctxt->dict = reader->dict;\n-    }\n-    } else {\n-    if (reader->ctxt->dict == NULL)\n-        reader->ctxt->dict = xmlDictCreate();\n+        if (reader->ctxt->dict == NULL)\n+            reader->ctxt->dict = xmlDictCreate();\n@@ -4992,2 +5020,2 @@\n-    xmlXIncludeFreeContext(reader->xincctxt);\n-    reader->xincctxt = NULL;\n+        xmlXIncludeFreeContext(reader->xincctxt);\n+        reader->xincctxt = NULL;\n@@ -4997,1 +5025,1 @@\n-    reader->xinclude_name = xmlDictLookup(reader->dict, XINCLUDE_NODE, -1);\n+        reader->xinclude_name = xmlDictLookup(reader->dict, XINCLUDE_NODE, -1);\n@@ -5000,1 +5028,1 @@\n-    options -= XML_PARSE_XINCLUDE;\n+        options -= XML_PARSE_XINCLUDE;\n@@ -5008,1 +5036,1 @@\n-    reader->patternMax = 0;\n+        reader->patternMax = 0;\n@@ -5012,2 +5040,2 @@\n-    if (reader->patternTab[reader->patternNr] != NULL) {\n-        xmlFreePattern(reader->patternTab[reader->patternNr]);\n+        if (reader->patternTab[reader->patternNr] != NULL) {\n+            xmlFreePattern(reader->patternTab[reader->patternNr]);\n@@ -5015,1 +5043,1 @@\n-    }\n+        }\n@@ -5048,0 +5076,2 @@\n+    if (reader == NULL)\n+        return;\n@@ -5062,1 +5092,1 @@\n-    if (reader == NULL)\n+    if ((reader == NULL) || (reader->ctxt == NULL))\n@@ -5071,0 +5101,4 @@\n+ * DEPRECATED: The returned value is mostly random and useless.\n+ * It reflects the parser reading ahead and is in no way related to\n+ * the current node.\n+ *\n@@ -5082,0 +5116,2 @@\n+    xmlParserInputPtr in;\n+\n@@ -5084,1 +5120,4 @@\n-    return(xmlByteConsumed(reader->ctxt));\n+    in = reader->ctxt->input;\n+    if (in == NULL)\n+        return(-1);\n+    return(in->consumed + (in->cur - in->base));\n@@ -5106,1 +5145,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5231,0 +5270,1 @@\n+    xmlParserErrors code;\n@@ -5232,2 +5272,4 @@\n-    if (fd < 0)\n-        return (NULL);\n+    if (fd < 0) {\n+        xmlTextReaderErr(XML_ERR_ARGUMENT, \"invalid argument\");\n+        return(NULL);\n+    }\n@@ -5235,3 +5277,13 @@\n-    input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);\n-    if (input == NULL)\n-        return (NULL);\n+    input = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);\n+    if (input == NULL) {\n+        xmlTextReaderErrMemory(NULL);\n+        return(NULL);\n+    }\n+    \/*\n+     * TODO: Remove XML_INPUT_UNZIP\n+     *\/\n+    code = xmlInputFromFd(input, fd, XML_INPUT_UNZIP);\n+    if (code != XML_ERR_OK) {\n+        xmlTextReaderErr(code, \"failed to open fd\");\n+        return(NULL);\n+    }\n@@ -5239,0 +5291,1 @@\n+\n@@ -5241,0 +5294,1 @@\n+        xmlTextReaderErrMemory(NULL);\n@@ -5242,1 +5296,1 @@\n-        return (NULL);\n+        return(NULL);\n@@ -5246,0 +5300,1 @@\n+        xmlTextReaderErrMemory(NULL);\n@@ -5247,1 +5302,1 @@\n-        return (NULL);\n+        return(NULL);\n@@ -5319,1 +5374,1 @@\n-    xmlCtxtReset(reader->ctxt);\n+        xmlCtxtReset(reader->ctxt);\n@@ -5334,3 +5389,3 @@\n-        reader->dict = reader->ctxt->dict;\n-    else\n-        reader->dict = xmlDictCreate();\n+            reader->dict = reader->ctxt->dict;\n+        else\n+            reader->dict = xmlDictCreate();\n@@ -5391,4 +5446,4 @@\n-    if (filename == NULL)\n-        return (-1);\n-    if (reader == NULL)\n-        return (-1);\n+    if ((filename == NULL) || (reader == NULL)) {\n+        xmlTextReaderErr(XML_ERR_ARGUMENT, \"invalid argument\");\n+        return(-1);\n+    }\n@@ -5396,6 +5451,31 @@\n-    input =\n-        xmlParserInputBufferCreateFilename(filename,\n-                                           XML_CHAR_ENCODING_NONE);\n-    if (input == NULL)\n-        return (-1);\n-    return (xmlTextReaderSetup(reader, input, filename, encoding, options));\n+    if (xmlParserInputBufferCreateFilenameValue != NULL) {\n+        input = xmlParserInputBufferCreateFilenameValue(filename,\n+                XML_CHAR_ENCODING_NONE);\n+        if (input == NULL) {\n+            xmlTextReaderErr(XML_IO_ENOENT, \"failed to open %s\", filename);\n+            return(-1);\n+        }\n+    } else {\n+        \/*\n+         * TODO: Remove XML_INPUT_UNZIP\n+         *\/\n+        xmlParserInputFlags flags = XML_INPUT_UNZIP;\n+        xmlParserErrors code;\n+\n+        if ((options & XML_PARSE_NONET) == 0)\n+            flags |= XML_INPUT_NETWORK;\n+\n+        code = xmlParserInputBufferCreateUrl(filename, XML_CHAR_ENCODING_NONE,\n+                                             flags, &input);\n+        if (code != XML_ERR_OK) {\n+            xmlTextReaderErr(code, \"failed to open %s\", filename);\n+            return(-1);\n+        }\n+    }\n+\n+    if (xmlTextReaderSetup(reader, input, filename, encoding, options) < 0) {\n+        xmlTextReaderErrMemory(NULL);\n+        return(-1);\n+    }\n+\n+    return(0);\n@@ -5459,0 +5539,1 @@\n+    xmlParserErrors code;\n@@ -5460,4 +5541,4 @@\n-    if (fd < 0)\n-        return (-1);\n-    if (reader == NULL)\n-        return (-1);\n+    if ((fd < 0) || (reader == NULL)) {\n+        xmlTextReaderErr(XML_ERR_ARGUMENT, \"invalid argument\");\n+        return(-1);\n+    }\n@@ -5465,3 +5546,13 @@\n-    input = xmlParserInputBufferCreateFd(fd, XML_CHAR_ENCODING_NONE);\n-    if (input == NULL)\n-        return (-1);\n+    input = xmlAllocParserInputBuffer(XML_CHAR_ENCODING_NONE);\n+    if (input == NULL) {\n+        xmlTextReaderErrMemory(NULL);\n+        return(-1);\n+    }\n+    \/*\n+     * TODO: Remove XML_INPUT_UNZIP\n+     *\/\n+    code = xmlInputFromFd(input, fd, XML_INPUT_UNZIP);\n+    if (code != XML_ERR_OK) {\n+        xmlTextReaderErr(code, \"failed to open fd\");\n+        return(-1);\n+    }\n@@ -5469,1 +5560,7 @@\n-    return (xmlTextReaderSetup(reader, input, URL, encoding, options));\n+\n+    if (xmlTextReaderSetup(reader, input, URL, encoding, options) < 0) {\n+        xmlTextReaderErrMemory(NULL);\n+        return(-1);\n+    }\n+\n+    return(0);\n@@ -5511,209 +5608,0 @@\n-\/************************************************************************\n- *                                    *\n- *            Utilities                    *\n- *                                    *\n- ************************************************************************\/\n-#ifdef NOT_USED_YET\n-\n-\/**\n- * xmlBase64Decode:\n- * @in:  the input buffer\n- * @inlen:  the size of the input (in), the size read from it (out)\n- * @to:  the output buffer\n- * @tolen:  the size of the output (in), the size written to (out)\n- *\n- * Base64 decoder, reads from @in and save in @to\n- * TODO: tell jody when this is actually exported\n- *\n- * Returns 0 if all the input was consumer, 1 if the Base64 end was reached,\n- *         2 if there wasn't enough space on the output or -1 in case of error.\n- *\/\n-static int\n-xmlBase64Decode(const unsigned char *in, unsigned long *inlen,\n-                unsigned char *to, unsigned long *tolen)\n-{\n-    unsigned long incur;        \/* current index in in[] *\/\n-\n-    unsigned long inblk;        \/* last block index in in[] *\/\n-\n-    unsigned long outcur;       \/* current index in out[] *\/\n-\n-    unsigned long inmax;        \/* size of in[] *\/\n-\n-    unsigned long outmax;       \/* size of out[] *\/\n-\n-    unsigned char cur;          \/* the current value read from in[] *\/\n-\n-    unsigned char intmp[4], outtmp[4];  \/* temporary buffers for the convert *\/\n-\n-    int nbintmp;                \/* number of byte in intmp[] *\/\n-\n-    int is_ignore;              \/* cur should be ignored *\/\n-\n-    int is_end = 0;             \/* the end of the base64 was found *\/\n-\n-    int retval = 1;\n-\n-    int i;\n-\n-    if ((in == NULL) || (inlen == NULL) || (to == NULL) || (tolen == NULL))\n-        return (-1);\n-\n-    incur = 0;\n-    inblk = 0;\n-    outcur = 0;\n-    inmax = *inlen;\n-    outmax = *tolen;\n-    nbintmp = 0;\n-\n-    while (1) {\n-        if (incur >= inmax)\n-            break;\n-        cur = in[incur++];\n-        is_ignore = 0;\n-        if ((cur >= 'A') && (cur <= 'Z'))\n-            cur = cur - 'A';\n-        else if ((cur >= 'a') && (cur <= 'z'))\n-            cur = cur - 'a' + 26;\n-        else if ((cur >= '0') && (cur <= '9'))\n-            cur = cur - '0' + 52;\n-        else if (cur == '+')\n-            cur = 62;\n-        else if (cur == '\/')\n-            cur = 63;\n-        else if (cur == '.')\n-            cur = 0;\n-        else if (cur == '=')    \/*no op , end of the base64 stream *\/\n-            is_end = 1;\n-        else {\n-            is_ignore = 1;\n-            if (nbintmp == 0)\n-                inblk = incur;\n-        }\n-\n-        if (!is_ignore) {\n-            int nbouttmp = 3;\n-\n-            int is_break = 0;\n-\n-            if (is_end) {\n-                if (nbintmp == 0)\n-                    break;\n-                if ((nbintmp == 1) || (nbintmp == 2))\n-                    nbouttmp = 1;\n-                else\n-                    nbouttmp = 2;\n-                nbintmp = 3;\n-                is_break = 1;\n-            }\n-            intmp[nbintmp++] = cur;\n-            \/*\n-             * if intmp is full, push the 4byte sequence as a 3 byte\n-             * sequence out\n-             *\/\n-            if (nbintmp == 4) {\n-                nbintmp = 0;\n-                outtmp[0] = (intmp[0] << 2) | ((intmp[1] & 0x30) >> 4);\n-                outtmp[1] =\n-                    ((intmp[1] & 0x0F) << 4) | ((intmp[2] & 0x3C) >> 2);\n-                outtmp[2] = ((intmp[2] & 0x03) << 6) | (intmp[3] & 0x3F);\n-                if (outcur + 3 >= outmax) {\n-                    retval = 2;\n-                    break;\n-                }\n-\n-                for (i = 0; i < nbouttmp; i++)\n-                    to[outcur++] = outtmp[i];\n-                inblk = incur;\n-            }\n-\n-            if (is_break) {\n-                retval = 0;\n-                break;\n-            }\n-        }\n-    }\n-\n-    *tolen = outcur;\n-    *inlen = inblk;\n-    return (retval);\n-}\n-\n-\/*\n- * Test routine for the xmlBase64Decode function\n- *\/\n-#if 0\n-int\n-main(int argc, char **argv)\n-{\n-    char *input = \"  VW4 gcGV0        \\n      aXQgdGVzdCAuCg== \";\n-\n-    char output[100];\n-\n-    char output2[100];\n-\n-    char output3[100];\n-\n-    unsigned long inlen = strlen(input);\n-\n-    unsigned long outlen = 100;\n-\n-    int ret;\n-\n-    unsigned long cons, tmp, tmp2, prod;\n-\n-    \/*\n-     * Direct\n-     *\/\n-    ret = xmlBase64Decode(input, &inlen, output, &outlen);\n-\n-    output[outlen] = 0;\n-    printf(\"ret: %d, inlen: %ld , outlen: %ld, output: '%s'\\n\", ret, inlen,\n-           outlen, output)indent: Standard input:179: Error:Unmatched #endif\n-;\n-\n-    \/*\n-     * output chunking\n-     *\/\n-    cons = 0;\n-    prod = 0;\n-    while (cons < inlen) {\n-        tmp = 5;\n-        tmp2 = inlen - cons;\n-\n-        printf(\"%ld %ld\\n\", cons, prod);\n-        ret = xmlBase64Decode(&input[cons], &tmp2, &output2[prod], &tmp);\n-        cons += tmp2;\n-        prod += tmp;\n-        printf(\"%ld %ld\\n\", cons, prod);\n-    }\n-    output2[outlen] = 0;\n-    printf(\"ret: %d, cons: %ld , prod: %ld, output: '%s'\\n\", ret, cons,\n-           prod, output2);\n-\n-    \/*\n-     * input chunking\n-     *\/\n-    cons = 0;\n-    prod = 0;\n-    while (cons < inlen) {\n-        tmp = 100 - prod;\n-        tmp2 = inlen - cons;\n-        if (tmp2 > 5)\n-            tmp2 = 5;\n-\n-        printf(\"%ld %ld\\n\", cons, prod);\n-        ret = xmlBase64Decode(&input[cons], &tmp2, &output3[prod], &tmp);\n-        cons += tmp2;\n-        prod += tmp;\n-        printf(\"%ld %ld\\n\", cons, prod);\n-    }\n-    output3[outlen] = 0;\n-    printf(\"ret: %d, cons: %ld , prod: %ld, output: '%s'\\n\", ret, cons,\n-           prod, output3);\n-    return (0);\n-\n-}\n-#endif\n-#endif \/* NOT_USED_YET *\/\n-\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlreader.c","additions":1562,"deletions":1674,"binary":false,"changes":3236,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"private\/entities.h\"\n@@ -45,1 +46,1 @@\n-    char indent[MAX_INDENT + 1];    \/* array for indenting output *\/\n+    char indent[MAX_INDENT + 1];        \/* array for indenting output *\/\n@@ -48,2 +49,1 @@\n-    xmlCharEncodingOutputFunc escape;    \/* used for element content *\/\n-    xmlCharEncodingOutputFunc escapeAttr;\/* used for attribute content *\/\n+    xmlCharEncodingOutputFunc escape;   \/* used for element content *\/\n@@ -53,3 +53,3 @@\n- *                                    *\n- *            Output error handlers                *\n- *                                    *\n+ *                                                                      *\n+ *                      Output error handlers                           *\n+ *                                                                      *\n@@ -86,2 +86,4 @@\n-    \/* Don't overwrite memory errors *\/\n-    if ((out != NULL) && (out->error == XML_ERR_NO_MEMORY))\n+    \/* Don't overwrite catastrophic errors *\/\n+    if ((out != NULL) &&\n+        (out->error != XML_ERR_OK) &&\n+        (xmlIsCatastrophicError(XML_ERR_FATAL, out->error)))\n@@ -98,15 +100,5 @@\n-    switch(code) {\n-        case XML_SAVE_NOT_UTF8:\n-        msg = \"string is not in UTF-8\\n\";\n-        break;\n-    case XML_SAVE_CHAR_INVALID:\n-        msg = \"invalid character value\\n\";\n-        break;\n-    case XML_SAVE_UNKNOWN_ENCODING:\n-        msg = \"unknown encoding %s\\n\";\n-        break;\n-    case XML_SAVE_NO_DOCTYPE:\n-        msg = \"document has no DOCTYPE\\n\";\n-        break;\n-    default:\n-        msg = \"unexpected error number\\n\";\n+    if (code == XML_ERR_UNSUPPORTED_ENCODING) {\n+        msg = \"Unsupported encoding: %s\";\n+    } else {\n+        msg = xmlErrString(code);\n+        extra = NULL;\n@@ -115,4 +107,4 @@\n-    res = __xmlRaiseError(NULL, NULL, NULL, NULL, node,\n-                          XML_FROM_OUTPUT, code, XML_ERR_ERROR, NULL, 0,\n-                          extra, NULL, NULL, 0, 0,\n-                          msg, extra);\n+    res = xmlRaiseError(NULL, NULL, NULL, NULL, node,\n+                        XML_FROM_OUTPUT, code, XML_ERR_ERROR, NULL, 0,\n+                        extra, NULL, NULL, 0, 0,\n+                        msg, extra);\n@@ -124,3 +116,3 @@\n- *                                    *\n- *            Special escaping routines            *\n- *                                    *\n+ *                                                                      *\n+ *                      Special escaping routines                       *\n+ *                                                                      *\n@@ -128,40 +120,0 @@\n-static unsigned char *\n-xmlSerializeHexCharRef(unsigned char *out, int val) {\n-    unsigned char *ptr;\n-\n-    *out++ = '&';\n-    *out++ = '#';\n-    *out++ = 'x';\n-    if (val < 0x10) ptr = out;\n-    else if (val < 0x100) ptr = out + 1;\n-    else if (val < 0x1000) ptr = out + 2;\n-    else if (val < 0x10000) ptr = out + 3;\n-    else if (val < 0x100000) ptr = out + 4;\n-    else ptr = out + 5;\n-    out = ptr + 1;\n-    while (val > 0) {\n-    switch (val & 0xF) {\n-        case 0: *ptr-- = '0'; break;\n-        case 1: *ptr-- = '1'; break;\n-        case 2: *ptr-- = '2'; break;\n-        case 3: *ptr-- = '3'; break;\n-        case 4: *ptr-- = '4'; break;\n-        case 5: *ptr-- = '5'; break;\n-        case 6: *ptr-- = '6'; break;\n-        case 7: *ptr-- = '7'; break;\n-        case 8: *ptr-- = '8'; break;\n-        case 9: *ptr-- = '9'; break;\n-        case 0xA: *ptr-- = 'A'; break;\n-        case 0xB: *ptr-- = 'B'; break;\n-        case 0xC: *ptr-- = 'C'; break;\n-        case 0xD: *ptr-- = 'D'; break;\n-        case 0xE: *ptr-- = 'E'; break;\n-        case 0xF: *ptr-- = 'F'; break;\n-        default: *ptr-- = '0'; break;\n-    }\n-    val >>= 4;\n-    }\n-    *out++ = ';';\n-    *out = 0;\n-    return(out);\n-}\n@@ -169,14 +121,2 @@\n-\/**\n- * xmlEscapeEntities:\n- * @out:  a pointer to an array of bytes to store the result\n- * @outlen:  the length of @out\n- * @in:  a pointer to an array of unescaped UTF-8 bytes\n- * @inlen:  the length of @in\n- *\n- * Take a block of UTF-8 chars in and escape them. Used when there is no\n- * encoding specified.\n- *\n- * Returns 0 if success, or -1 otherwise\n- * The value of @inlen after return is the number of octets consumed\n- *     if the return value is positive, else unpredictable.\n- * The value of @outlen after return is the number of octets consumed.\n+\/*\n+ * Tables generated with tools\/genEscape.py\n@@ -184,59 +124,0 @@\n-static int\n-xmlEscapeEntities(unsigned char* out, int *outlen,\n-                 const xmlChar* in, int *inlen) {\n-    unsigned char* outstart = out;\n-    const unsigned char* base = in;\n-    unsigned char* outend = out + *outlen;\n-    const unsigned char* inend;\n-    int val;\n-\n-    inend = in + (*inlen);\n-\n-    while ((in < inend) && (out < outend)) {\n-    if (*in == '<') {\n-        if (outend - out < 4) break;\n-        *out++ = '&';\n-        *out++ = 'l';\n-        *out++ = 't';\n-        *out++ = ';';\n-        in++;\n-        continue;\n-    } else if (*in == '>') {\n-        if (outend - out < 4) break;\n-        *out++ = '&';\n-        *out++ = 'g';\n-        *out++ = 't';\n-        *out++ = ';';\n-        in++;\n-        continue;\n-    } else if (*in == '&') {\n-        if (outend - out < 5) break;\n-        *out++ = '&';\n-        *out++ = 'a';\n-        *out++ = 'm';\n-        *out++ = 'p';\n-        *out++ = ';';\n-        in++;\n-        continue;\n-    } else if (*in == 0xD) {\n-        if (outend - out < 5) break;\n-        *out++ = '&';\n-        *out++ = '#';\n-        *out++ = 'x';\n-        *out++ = 'D';\n-        *out++ = ';';\n-        in++;\n-    } else if (((*in >= 0x20) && (*in < 0x80)) ||\n-               (*in == 0xA) || (*in == 0x9)) {\n-        \/*\n-         * default case, just copy !\n-         *\/\n-        *out++ = *in++;\n-        continue;\n-    } else if (*in < 0x80) {\n-            \/* invalid control char *\/\n-        if (outend - out < 8) break;\n-        out = xmlSerializeHexCharRef(out, 0xFFFD);\n-        in++;\n-    } else {\n-            int len;\n@@ -244,1 +125,7 @@\n-        if (outend - out < 11) break;\n+static const char xmlEscapeContent[] = {\n+      8, '&', '#', 'x', 'F', 'F', 'F', 'D', ';',   4, '&', '#',\n+    '9', ';',   5, '&', '#', '1', '0', ';',   5, '&', '#', '1',\n+    '3', ';',   6, '&', 'q', 'u', 'o', 't', ';',   5, '&', 'a',\n+    'm', 'p', ';',   4, '&', 'l', 't', ';',   4, '&', 'g', 't',\n+    ';',\n+};\n@@ -246,2 +133,10 @@\n-            len = inend - in;\n-            val = xmlGetUTF8Char(in, &len);\n+static const signed char xmlEscapeTab[128] = {\n+     0,  0,  0,  0,  0,  0,  0,  0,  0, -1, -1,  0,  0, 20,  0,  0,\n+     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    -1, -1, -1, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 39, -1, 44, -1,\n+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+};\n@@ -249,0 +144,65 @@\n+static const signed char xmlEscapeTabAttr[128] = {\n+     0,  0,  0,  0,  0,  0,  0,  0,  0,  9, 14,  0,  0, 20,  0,  0,\n+     0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n+    -1, -1, 26, -1, -1, -1, 33, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 39, -1, 44, -1,\n+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+};\n+\n+static void\n+xmlSerializeText(xmlOutputBufferPtr buf, const xmlChar *string,\n+                 unsigned flags) {\n+    const char *cur;\n+    const signed char *tab;\n+\n+    if (string == NULL)\n+        return;\n+\n+    if (flags & XML_ESCAPE_ATTR)\n+        tab = xmlEscapeTabAttr;\n+    else\n+        tab = xmlEscapeTab;\n+\n+    cur = (const char *) string;\n+\n+    while (*cur != 0) {\n+        const char *base;\n+        int c;\n+        int offset;\n+\n+        base = cur;\n+        offset = -1;\n+\n+        while (1) {\n+            c = (unsigned char) *cur;\n+\n+            if (c < 0x80) {\n+                offset = tab[c];\n+                if (offset >= 0)\n+                    break;\n+            } else if (flags & XML_ESCAPE_NON_ASCII) {\n+                break;\n+            }\n+\n+            cur += 1;\n+        }\n+\n+        if (cur > base)\n+            xmlOutputBufferWrite(buf, cur - base, base);\n+\n+        if (offset >= 0) {\n+            if (c == 0)\n+                break;\n+\n+            xmlOutputBufferWrite(buf, xmlEscapeContent[offset],\n+                                 &xmlEscapeContent[offset+1]);\n+            cur += 1;\n+        } else {\n+            char tempBuf[12];\n+            int tempSize;\n+            int val = 0, len = 4;\n+\n+            val = xmlGetUTF8Char((const xmlChar *) cur, &len);\n@@ -251,1 +211,1 @@\n-                in++;\n+                cur += 1;\n@@ -255,1 +215,1 @@\n-                in += len;\n+                cur += len;\n@@ -258,5 +218,3 @@\n-        \/*\n-         * We could do multiple things here. Just save as a char ref\n-         *\/\n-        out = xmlSerializeHexCharRef(out, val);\n-    }\n+            tempSize = xmlSerializeHexCharRef(tempBuf, val);\n+            xmlOutputBufferWrite(buf, tempSize, tempBuf);\n+        }\n@@ -264,3 +222,0 @@\n-    *outlen = out - outstart;\n-    *inlen = in - base;\n-    return(0);\n@@ -270,3 +225,3 @@\n- *                                    *\n- *            Allocation and deallocation            *\n- *                                    *\n+ *                                                                      *\n+ *                      Allocation and deallocation                     *\n+ *                                                                      *\n@@ -274,0 +229,32 @@\n+\n+\/**\n+ * xmlSaveSetIndentString:\n+ * @ctxt:  save context\n+ * @indent:  indent string\n+ *\n+ * Sets the indent string.\n+ *\n+ * Available since 2.14.0.\n+ *\n+ * Returns 0 on success, -1 if the string is NULL, empty or too long.\n+ *\/\n+int\n+xmlSaveSetIndentString(xmlSaveCtxtPtr ctxt, const char *indent) {\n+    size_t len;\n+    int i;\n+\n+    if ((ctxt == NULL) || (indent == NULL))\n+        return(-1);\n+\n+    len = strlen(indent);\n+    if ((len <= 0) || (len > MAX_INDENT))\n+        return(-1);\n+\n+    ctxt->indent_size = len;\n+    ctxt->indent_nr = MAX_INDENT \/ ctxt->indent_size;\n+    for (i = 0; i < ctxt->indent_nr; i++)\n+        memcpy(&ctxt->indent[i * ctxt->indent_size], indent, len);\n+\n+    return(0);\n+}\n+\n@@ -281,1 +268,1 @@\n-xmlSaveCtxtInit(xmlSaveCtxtPtr ctxt)\n+xmlSaveCtxtInit(xmlSaveCtxtPtr ctxt, int options)\n@@ -283,3 +270,0 @@\n-    int i;\n-    int len;\n-\n@@ -287,13 +271,0 @@\n-    if ((ctxt->encoding == NULL) && (ctxt->escape == NULL))\n-        ctxt->escape = xmlEscapeEntities;\n-    len = xmlStrlen((xmlChar *)xmlTreeIndentString);\n-    if ((xmlTreeIndentString == NULL) || (len == 0)) {\n-        memset(&ctxt->indent[0], 0, MAX_INDENT + 1);\n-    } else {\n-    ctxt->indent_size = len;\n-    ctxt->indent_nr = MAX_INDENT \/ ctxt->indent_size;\n-    for (i = 0;i < ctxt->indent_nr;i++)\n-        memcpy(&ctxt->indent[i * ctxt->indent_size], xmlTreeIndentString,\n-           ctxt->indent_size);\n-        ctxt->indent[ctxt->indent_nr * ctxt->indent_size] = 0;\n-    }\n@@ -301,3 +272,12 @@\n-    if (xmlSaveNoEmptyTags) {\n-    ctxt->options |= XML_SAVE_NO_EMPTY;\n-    }\n+    xmlSaveSetIndentString(ctxt, xmlTreeIndentString);\n+\n+    if (options & XML_SAVE_FORMAT)\n+        ctxt->format = 1;\n+    else if (options & XML_SAVE_WSNONSIG)\n+        ctxt->format = 2;\n+\n+    if (((options & XML_SAVE_EMPTY) == 0) &&\n+        (xmlSaveNoEmptyTags))\n+        options |= XML_SAVE_NO_EMPTY;\n+\n+    ctxt->options = options;\n@@ -336,2 +316,2 @@\n-    xmlSaveErrMemory(NULL);\n-    return ( NULL );\n+        xmlSaveErrMemory(NULL);\n+        return ( NULL );\n@@ -342,1 +322,1 @@\n-        int res;\n+        xmlParserErrors res;\n@@ -346,2 +326,2 @@\n-    if (res != XML_ERR_OK) {\n-        xmlSaveErr(NULL, res, NULL, encoding);\n+        if (res != XML_ERR_OK) {\n+            xmlSaveErr(NULL, res, NULL, encoding);\n@@ -349,2 +329,2 @@\n-        return(NULL);\n-    }\n+            return(NULL);\n+        }\n@@ -352,1 +332,0 @@\n-    ret->escape = NULL;\n@@ -354,1 +333,0 @@\n-    xmlSaveCtxtInit(ret);\n@@ -356,14 +334,1 @@\n-    \/*\n-     * Use the options\n-     *\/\n-\n-    \/* Re-check this option as it may already have been set *\/\n-    if ((ret->options & XML_SAVE_NO_EMPTY) && ! (options & XML_SAVE_NO_EMPTY)) {\n-    options |= XML_SAVE_NO_EMPTY;\n-    }\n-\n-    ret->options = options;\n-    if (options & XML_SAVE_FORMAT)\n-        ret->format = 1;\n-    else if (options & XML_SAVE_WSNONSIG)\n-        ret->format = 2;\n+    xmlSaveCtxtInit(ret, options);\n@@ -375,3 +340,3 @@\n- *                                    *\n- *        Dumping XML tree content to a simple buffer        *\n- *                                    *\n+ *                                                                      *\n+ *              Dumping XML tree content to a simple buffer             *\n+ *                                                                      *\n@@ -379,0 +344,9 @@\n+\n+static void\n+xmlSaveWriteText(xmlSaveCtxt *ctxt, const xmlChar *text, unsigned flags) {\n+    if (ctxt->encoding == NULL)\n+        flags |= XML_ESCAPE_NON_ASCII;\n+\n+    xmlSerializeText(ctxt->buf, text, flags);\n+}\n+\n@@ -380,3 +354,2 @@\n- * xmlAttrSerializeContent:\n- * @buf:  the XML buffer output\n- * @doc:  the document\n+ * xmlSaveWriteAttrContent:\n+ * @ctxt:  save context\n@@ -388,1 +361,1 @@\n-xmlAttrSerializeContent(xmlOutputBufferPtr buf, xmlAttrPtr attr)\n+xmlSaveWriteAttrContent(xmlSaveCtxt *ctxt, xmlAttrPtr attr)\n@@ -391,0 +364,1 @@\n+    xmlOutputBufferPtr buf = ctxt->buf;\n@@ -396,3 +370,2 @@\n-            xmlBufAttrSerializeTxtContent(buf, attr->doc,\n-                                      children->content);\n-        break;\n+                xmlSaveWriteText(ctxt, children->content, XML_ESCAPE_ATTR);\n+                break;\n@@ -425,6 +398,6 @@\n-    xmlOutputBufferWrite(buf, 8, \" PUBLIC \");\n-    xmlOutputBufferWriteQuotedString(buf, nota->PublicID);\n-    if (nota->SystemID != NULL) {\n-        xmlOutputBufferWrite(buf, 1, \" \");\n-        xmlOutputBufferWriteQuotedString(buf, nota->SystemID);\n-    }\n+        xmlOutputBufferWrite(buf, 8, \" PUBLIC \");\n+        xmlOutputBufferWriteQuotedString(buf, nota->PublicID);\n+        if (nota->SystemID != NULL) {\n+            xmlOutputBufferWrite(buf, 1, \" \");\n+            xmlOutputBufferWriteQuotedString(buf, nota->SystemID);\n+        }\n@@ -432,2 +405,2 @@\n-    xmlOutputBufferWrite(buf, 8, \" SYSTEM \");\n-    xmlOutputBufferWriteQuotedString(buf, nota->SystemID);\n+        xmlOutputBufferWrite(buf, 8, \" SYSTEM \");\n+        xmlOutputBufferWriteQuotedString(buf, nota->SystemID);\n@@ -580,10 +553,10 @@\n-    case XML_ELEMENT_TYPE_EMPTY:\n-        xmlOutputBufferWrite(buf, 5, \"EMPTY\");\n-        break;\n-    case XML_ELEMENT_TYPE_ANY:\n-        xmlOutputBufferWrite(buf, 3, \"ANY\");\n-        break;\n-    case XML_ELEMENT_TYPE_MIXED:\n-    case XML_ELEMENT_TYPE_ELEMENT:\n-        xmlBufDumpElementContent(buf, elem->content);\n-        break;\n+        case XML_ELEMENT_TYPE_EMPTY:\n+            xmlOutputBufferWrite(buf, 5, \"EMPTY\");\n+            break;\n+        case XML_ELEMENT_TYPE_ANY:\n+            xmlOutputBufferWrite(buf, 3, \"ANY\");\n+            break;\n+        case XML_ELEMENT_TYPE_MIXED:\n+        case XML_ELEMENT_TYPE_ELEMENT:\n+            xmlBufDumpElementContent(buf, elem->content);\n+            break;\n@@ -626,1 +599,3 @@\n-xmlBufDumpAttributeDecl(xmlOutputBufferPtr buf, xmlAttributePtr attr) {\n+xmlSaveWriteAttributeDecl(xmlSaveCtxtPtr ctxt, xmlAttributePtr attr) {\n+    xmlOutputBufferPtr buf = ctxt->buf;\n+\n@@ -631,2 +606,2 @@\n-    xmlOutputBufferWriteString(buf, (const char *) attr->prefix);\n-    xmlOutputBufferWrite(buf, 1, \":\");\n+        xmlOutputBufferWriteString(buf, (const char *) attr->prefix);\n+        xmlOutputBufferWrite(buf, 1, \":\");\n@@ -637,33 +612,33 @@\n-    case XML_ATTRIBUTE_CDATA:\n-        xmlOutputBufferWrite(buf, 6, \" CDATA\");\n-        break;\n-    case XML_ATTRIBUTE_ID:\n-        xmlOutputBufferWrite(buf, 3, \" ID\");\n-        break;\n-    case XML_ATTRIBUTE_IDREF:\n-        xmlOutputBufferWrite(buf, 6, \" IDREF\");\n-        break;\n-    case XML_ATTRIBUTE_IDREFS:\n-        xmlOutputBufferWrite(buf, 7, \" IDREFS\");\n-        break;\n-    case XML_ATTRIBUTE_ENTITY:\n-        xmlOutputBufferWrite(buf, 7, \" ENTITY\");\n-        break;\n-    case XML_ATTRIBUTE_ENTITIES:\n-        xmlOutputBufferWrite(buf, 9, \" ENTITIES\");\n-        break;\n-    case XML_ATTRIBUTE_NMTOKEN:\n-        xmlOutputBufferWrite(buf, 8, \" NMTOKEN\");\n-        break;\n-    case XML_ATTRIBUTE_NMTOKENS:\n-        xmlOutputBufferWrite(buf, 9, \" NMTOKENS\");\n-        break;\n-    case XML_ATTRIBUTE_ENUMERATION:\n-        xmlOutputBufferWrite(buf, 2, \" (\");\n-        xmlBufDumpEnumeration(buf, attr->tree);\n-        break;\n-    case XML_ATTRIBUTE_NOTATION:\n-        xmlOutputBufferWrite(buf, 11, \" NOTATION (\");\n-        xmlBufDumpEnumeration(buf, attr->tree);\n-        break;\n-    default:\n+        case XML_ATTRIBUTE_CDATA:\n+            xmlOutputBufferWrite(buf, 6, \" CDATA\");\n+            break;\n+        case XML_ATTRIBUTE_ID:\n+            xmlOutputBufferWrite(buf, 3, \" ID\");\n+            break;\n+        case XML_ATTRIBUTE_IDREF:\n+            xmlOutputBufferWrite(buf, 6, \" IDREF\");\n+            break;\n+        case XML_ATTRIBUTE_IDREFS:\n+            xmlOutputBufferWrite(buf, 7, \" IDREFS\");\n+            break;\n+        case XML_ATTRIBUTE_ENTITY:\n+            xmlOutputBufferWrite(buf, 7, \" ENTITY\");\n+            break;\n+        case XML_ATTRIBUTE_ENTITIES:\n+            xmlOutputBufferWrite(buf, 9, \" ENTITIES\");\n+            break;\n+        case XML_ATTRIBUTE_NMTOKEN:\n+            xmlOutputBufferWrite(buf, 8, \" NMTOKEN\");\n+            break;\n+        case XML_ATTRIBUTE_NMTOKENS:\n+            xmlOutputBufferWrite(buf, 9, \" NMTOKENS\");\n+            break;\n+        case XML_ATTRIBUTE_ENUMERATION:\n+            xmlOutputBufferWrite(buf, 2, \" (\");\n+            xmlBufDumpEnumeration(buf, attr->tree);\n+            break;\n+        case XML_ATTRIBUTE_NOTATION:\n+            xmlOutputBufferWrite(buf, 11, \" NOTATION (\");\n+            xmlBufDumpEnumeration(buf, attr->tree);\n+            break;\n+        default:\n@@ -675,12 +650,12 @@\n-    case XML_ATTRIBUTE_NONE:\n-        break;\n-    case XML_ATTRIBUTE_REQUIRED:\n-        xmlOutputBufferWrite(buf, 10, \" #REQUIRED\");\n-        break;\n-    case XML_ATTRIBUTE_IMPLIED:\n-        xmlOutputBufferWrite(buf, 9, \" #IMPLIED\");\n-        break;\n-    case XML_ATTRIBUTE_FIXED:\n-        xmlOutputBufferWrite(buf, 7, \" #FIXED\");\n-        break;\n-    default:\n+        case XML_ATTRIBUTE_NONE:\n+            break;\n+        case XML_ATTRIBUTE_REQUIRED:\n+            xmlOutputBufferWrite(buf, 10, \" #REQUIRED\");\n+            break;\n+        case XML_ATTRIBUTE_IMPLIED:\n+            xmlOutputBufferWrite(buf, 9, \" #IMPLIED\");\n+            break;\n+        case XML_ATTRIBUTE_FIXED:\n+            xmlOutputBufferWrite(buf, 7, \" #FIXED\");\n+            break;\n+        default:\n@@ -692,2 +667,3 @@\n-    xmlOutputBufferWrite(buf, 1, \" \");\n-    xmlOutputBufferWriteQuotedString(buf, attr->defaultValue);\n+        xmlOutputBufferWrite(buf, 2, \" \\\"\");\n+        xmlSaveWriteText(ctxt, attr->defaultValue, XML_ESCAPE_ATTR);\n+        xmlOutputBufferWrite(buf, 1, \"\\\"\");\n@@ -712,10 +688,19 @@\n-    xmlOutputBufferWrite(buf, 1, \"\\\"\");\n-    base = cur = (const char *) content;\n-    while (*cur != 0) {\n-        if (*cur == '\"') {\n-        if (base != cur)\n-            xmlOutputBufferWrite(buf, cur - base, base);\n-        xmlOutputBufferWrite(buf, 6, \"&quot;\");\n-        cur++;\n-        base = cur;\n-        } else if (*cur == '%') {\n+        xmlOutputBufferWrite(buf, 1, \"\\\"\");\n+        base = cur = (const char *) content;\n+        while (*cur != 0) {\n+            if (*cur == '\"') {\n+                if (base != cur)\n+                    xmlOutputBufferWrite(buf, cur - base, base);\n+                xmlOutputBufferWrite(buf, 6, \"&quot;\");\n+                cur++;\n+                base = cur;\n+            } else if (*cur == '%') {\n+                if (base != cur)\n+                    xmlOutputBufferWrite(buf, cur - base, base);\n+                xmlOutputBufferWrite(buf, 6, \"&#x25;\");\n+                cur++;\n+                base = cur;\n+            } else {\n+                cur++;\n+            }\n+        }\n@@ -724,10 +709,1 @@\n-        xmlOutputBufferWrite(buf, 6, \"&#x25;\");\n-        cur++;\n-        base = cur;\n-        } else {\n-        cur++;\n-        }\n-    }\n-    if (base != cur)\n-        xmlOutputBufferWrite(buf, cur - base, base);\n-    xmlOutputBufferWrite(buf, 1, \"\\\"\");\n+        xmlOutputBufferWrite(buf, 1, \"\\\"\");\n@@ -791,3 +767,3 @@\n- *                                    *\n- *        Dumping XML tree content to an I\/O output buffer    *\n- *                                    *\n+ *                                                                      *\n+ *              Dumping XML tree content to an I\/O output buffer        *\n+ *                                                                      *\n@@ -801,1 +777,1 @@\n-        int res;\n+        xmlParserErrors res;\n@@ -803,1 +779,1 @@\n-    res = xmlOpenCharEncodingHandler(encoding, \/* output *\/ 1, &handler);\n+        res = xmlOpenCharEncodingHandler(encoding, \/* output *\/ 1, &handler);\n@@ -808,10 +784,16 @@\n-    buf->conv = xmlBufCreate();\n-    if (buf->conv == NULL) {\n-        xmlCharEncCloseFunc(handler);\n-            xmlSaveErrMemory(buf);\n-        return(-1);\n-    }\n-        buf->encoder = handler;\n-    \/*\n-     * initialize the state, e.g. if outputting a BOM\n-     *\/\n+\n+        if (handler != NULL) {\n+            buf->conv = xmlBufCreate(4000 \/* MINLEN *\/);\n+            if (buf->conv == NULL) {\n+                xmlCharEncCloseFunc(handler);\n+                xmlSaveErrMemory(buf);\n+                return(-1);\n+            }\n+            buf->encoder = handler;\n+        }\n+\n+        ctxt->encoding = (const xmlChar *) encoding;\n+\n+        \/*\n+         * initialize the state, e.g. if outputting a BOM\n+         *\/\n@@ -825,0 +807,1 @@\n+\n@@ -830,0 +813,3 @@\n+\n+    ctxt->encoding = NULL;\n+\n@@ -840,0 +826,16 @@\n+static void\n+xmlSaveWriteIndent(xmlSaveCtxtPtr ctxt, int extra)\n+{\n+    int level;\n+\n+    if ((ctxt->options & XML_SAVE_NO_INDENT) ||\n+        (((ctxt->options & XML_SAVE_INDENT) == 0) &&\n+         (xmlIndentTreeOutput == 0)))\n+        return;\n+\n+    level = ctxt->level + extra;\n+    if (level > ctxt->indent_nr)\n+        level = ctxt->indent_nr;\n+    xmlOutputBufferWrite(ctxt->buf, ctxt->indent_size * level, ctxt->indent);\n+}\n+\n@@ -873,2 +875,3 @@\n-xmlNsDumpOutput(xmlOutputBufferPtr buf, xmlDocPtr doc, xmlNsPtr cur,\n-                xmlSaveCtxtPtr ctxt) {\n+xmlNsDumpOutput(xmlOutputBufferPtr buf, xmlNsPtr cur, xmlSaveCtxtPtr ctxt) {\n+    unsigned escapeFlags = XML_ESCAPE_ATTR;\n+\n@@ -876,0 +879,4 @@\n+\n+    if ((ctxt == NULL) || (ctxt->encoding == NULL))\n+        escapeFlags |= XML_ESCAPE_NON_ASCII;\n+\n@@ -877,2 +884,2 @@\n-    if (xmlStrEqual(cur->prefix, BAD_CAST \"xml\"))\n-        return;\n+        if (xmlStrEqual(cur->prefix, BAD_CAST \"xml\"))\n+            return;\n@@ -880,4 +887,4 @@\n-    if (ctxt != NULL && ctxt->format == 2)\n-        xmlOutputBufferWriteWSNonSig(ctxt, 2);\n-    else\n-        xmlOutputBufferWrite(buf, 1, \" \");\n+        if (ctxt != NULL && ctxt->format == 2)\n+            xmlOutputBufferWriteWSNonSig(ctxt, 2);\n+        else\n+            xmlOutputBufferWrite(buf, 1, \" \");\n@@ -886,5 +893,5 @@\n-    if (cur->prefix != NULL) {\n-        xmlOutputBufferWrite(buf, 6, \"xmlns:\");\n-        xmlOutputBufferWriteString(buf, (const char *)cur->prefix);\n-    } else\n-        xmlOutputBufferWrite(buf, 5, \"xmlns\");\n+        if (cur->prefix != NULL) {\n+            xmlOutputBufferWrite(buf, 6, \"xmlns:\");\n+            xmlOutputBufferWriteString(buf, (const char *)cur->prefix);\n+        } else\n+            xmlOutputBufferWrite(buf, 5, \"xmlns\");\n@@ -892,1 +899,1 @@\n-        xmlBufAttrSerializeTxtContent(buf, doc, cur->href);\n+        xmlSerializeText(buf, cur->href, escapeFlags);\n@@ -906,1 +913,1 @@\n-xmlNsListDumpOutputCtxt(xmlSaveCtxtPtr ctxt, xmlDocPtr doc, xmlNsPtr cur) {\n+xmlNsListDumpOutputCtxt(xmlSaveCtxtPtr ctxt, xmlNsPtr cur) {\n@@ -908,2 +915,2 @@\n-        xmlNsDumpOutput(ctxt->buf, doc, cur, ctxt);\n-    cur = cur->next;\n+        xmlNsDumpOutput(ctxt->buf, cur, ctxt);\n+        cur = cur->next;\n@@ -924,2 +931,2 @@\n-        xmlNsDumpOutput(buf, NULL, cur, NULL);\n-    cur = cur->next;\n+        xmlNsDumpOutput(buf, cur, NULL);\n+        cur = cur->next;\n@@ -949,4 +956,4 @@\n-    xmlOutputBufferWrite(buf, 8, \" PUBLIC \");\n-    xmlOutputBufferWriteQuotedString(buf, dtd->ExternalID);\n-    xmlOutputBufferWrite(buf, 1, \" \");\n-    xmlOutputBufferWriteQuotedString(buf, dtd->SystemID);\n+        xmlOutputBufferWrite(buf, 8, \" PUBLIC \");\n+        xmlOutputBufferWriteQuotedString(buf, dtd->ExternalID);\n+        xmlOutputBufferWrite(buf, 1, \" \");\n+        xmlOutputBufferWriteQuotedString(buf, dtd->SystemID);\n@@ -954,2 +961,2 @@\n-    xmlOutputBufferWrite(buf, 8, \" SYSTEM \");\n-    xmlOutputBufferWriteQuotedString(buf, dtd->SystemID);\n+        xmlOutputBufferWrite(buf, 8, \" SYSTEM \");\n+        xmlOutputBufferWriteQuotedString(buf, dtd->SystemID);\n@@ -959,3 +966,3 @@\n-    (dtd->pentities == NULL)) {\n-    xmlOutputBufferWrite(buf, 1, \">\");\n-    return;\n+        (dtd->pentities == NULL)) {\n+        xmlOutputBufferWrite(buf, 1, \">\");\n+        return;\n@@ -1004,1 +1011,1 @@\n-    xmlOutputBufferWrite(buf, 1, \":\");\n+        xmlOutputBufferWrite(buf, 1, \":\");\n@@ -1019,1 +1026,1 @@\n-        xmlAttrSerializeContent(buf, cur);\n+        xmlSaveWriteAttrContent(ctxt, cur);\n@@ -1033,1 +1040,0 @@\n-    const xmlChar *oldenc = NULL;\n@@ -1043,5 +1049,1 @@\n-    if (doc != NULL) {\n-        oldenc = doc->encoding;\n-    if (ctxt->encoding != NULL) {\n-        doc->encoding = BAD_CAST ctxt->encoding;\n-    } else if (doc->encoding != NULL) {\n+    if ((encoding == NULL) && (doc != NULL))\n@@ -1049,2 +1051,0 @@\n-    }\n-    }\n@@ -1053,1 +1053,1 @@\n-    htmlSetMetaEncoding(doc, (const xmlChar *) encoding);\n+        htmlSetMetaEncoding(doc, (const xmlChar *) encoding);\n@@ -1055,1 +1055,1 @@\n-    encoding = htmlGetMetaEncoding(doc);\n+        encoding = htmlGetMetaEncoding(doc);\n@@ -1057,1 +1057,1 @@\n-    encoding = BAD_CAST \"HTML\";\n+        encoding = BAD_CAST \"HTML\";\n@@ -1059,6 +1059,4 @@\n-    (buf->encoder == NULL) && (buf->conv == NULL)) {\n-    if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {\n-        doc->encoding = oldenc;\n-        return(-1);\n-    }\n-    switched_encoding = 1;\n+        (buf->encoder == NULL) && (buf->conv == NULL)) {\n+        if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0)\n+            return(-1);\n+        switched_encoding = 1;\n@@ -1067,2 +1065,2 @@\n-    htmlNodeDumpFormatOutput(buf, doc, cur,\n-                       (const char *)encoding, 1);\n+        htmlNodeDumpFormatOutput(buf, doc, cur,\n+                                       (const char *)encoding, 1);\n@@ -1070,2 +1068,2 @@\n-    htmlNodeDumpFormatOutput(buf, doc, cur,\n-                       (const char *)encoding, 0);\n+        htmlNodeDumpFormatOutput(buf, doc, cur,\n+                                       (const char *)encoding, 0);\n@@ -1076,1 +1074,1 @@\n-    xmlSaveClearEncoding(ctxt);\n+        xmlSaveClearEncoding(ctxt);\n@@ -1078,2 +1076,0 @@\n-    if (doc != NULL)\n-    doc->encoding = oldenc;\n@@ -1107,2 +1103,2 @@\n-        xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);\n-        break;\n+            xmlDocContentDumpOutput(ctxt, (xmlDocPtr) cur);\n+            break;\n@@ -1121,1 +1117,1 @@\n-        break;\n+            break;\n@@ -1128,1 +1124,1 @@\n-            xmlBufDumpAttributeDecl(buf, (xmlAttributePtr) cur);\n+            xmlSaveWriteAttributeDecl(ctxt, (xmlAttributePtr) cur);\n@@ -1136,6 +1132,2 @@\n-        if ((cur != root) && (ctxt->format == 1) &&\n-                (xmlIndentTreeOutput))\n-        xmlOutputBufferWrite(buf, ctxt->indent_size *\n-                     (ctxt->level > ctxt->indent_nr ?\n-                      ctxt->indent_nr : ctxt->level),\n-                     ctxt->indent);\n+            if ((cur != root) && (ctxt->format == 1))\n+                xmlSaveWriteIndent(ctxt, 0);\n@@ -1160,1 +1152,1 @@\n-                xmlNsListDumpOutputCtxt(ctxt, cur->doc, cur->nsDef);\n+                xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);\n@@ -1210,1 +1202,1 @@\n-        if (cur->content == NULL)\n+            if (cur->content == NULL)\n@@ -1212,9 +1204,17 @@\n-        if (cur->name != xmlStringTextNoenc) {\n-                xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);\n-        } else {\n-        \/*\n-         * Disable escaping, needed for XSLT\n-         *\/\n-        xmlOutputBufferWriteString(buf, (const char *) cur->content);\n-        }\n-        break;\n+            if (cur->name != xmlStringTextNoenc) {\n+                if (ctxt->escape)\n+                    xmlOutputBufferWriteEscape(buf, cur->content,\n+                                               ctxt->escape);\n+#ifdef TEST_OUTPUT_BUFFER_WRITE_ESCAPE\n+                else if (ctxt->encoding)\n+                    xmlOutputBufferWriteEscape(buf, cur->content, NULL);\n+#endif\n+                else\n+                    xmlSaveWriteText(ctxt, cur->content, \/* flags *\/ 0);\n+            } else {\n+                \/*\n+                 * Disable escaping, needed for XSLT\n+                 *\/\n+                xmlOutputBufferWriteString(buf, (const char *) cur->content);\n+            }\n+            break;\n@@ -1223,5 +1223,2 @@\n-        if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n-        xmlOutputBufferWrite(buf, ctxt->indent_size *\n-                     (ctxt->level > ctxt->indent_nr ?\n-                      ctxt->indent_nr : ctxt->level),\n-                     ctxt->indent);\n+            if ((cur != root) && (ctxt->format == 1))\n+                xmlSaveWriteIndent(ctxt, 0);\n@@ -1251,5 +1248,2 @@\n-        if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n-        xmlOutputBufferWrite(buf, ctxt->indent_size *\n-                     (ctxt->level > ctxt->indent_nr ?\n-                      ctxt->indent_nr : ctxt->level),\n-                     ctxt->indent);\n+            if ((cur != root) && (ctxt->format == 1))\n+                xmlSaveWriteIndent(ctxt, 0);\n@@ -1300,1 +1294,1 @@\n-            xmlNsDumpOutput(buf, NULL, (xmlNsPtr) cur, ctxt);\n+            xmlNsDumpOutput(buf, (xmlNsPtr) cur, ctxt);\n@@ -1325,5 +1319,2 @@\n-                if ((xmlIndentTreeOutput) && (ctxt->format == 1))\n-                    xmlOutputBufferWrite(buf, ctxt->indent_size *\n-                                         (ctxt->level > ctxt->indent_nr ?\n-                                          ctxt->indent_nr : ctxt->level),\n-                                         ctxt->indent);\n+                if (ctxt->format == 1)\n+                    xmlSaveWriteIndent(ctxt, 0);\n@@ -1364,1 +1355,0 @@\n-    const xmlChar *oldenc = cur->encoding;\n@@ -1367,2 +1357,0 @@\n-    xmlCharEncodingOutputFunc oldescape = ctxt->escape;\n-    xmlCharEncodingOutputFunc oldescapeAttr = ctxt->escapeAttr;\n@@ -1370,1 +1358,0 @@\n-    xmlCharEncoding enc;\n@@ -1377,1 +1364,1 @@\n-     return(-1);\n+         return(-1);\n@@ -1379,5 +1366,2 @@\n-    if (ctxt->encoding != NULL) {\n-        cur->encoding = BAD_CAST ctxt->encoding;\n-    } else if (cur->encoding != NULL) {\n-    encoding = cur->encoding;\n-    }\n+    if (ctxt->encoding == NULL)\n+        encoding = cur->encoding;\n@@ -1391,1 +1375,1 @@\n-        htmlSetMetaEncoding(cur, (const xmlChar *) encoding);\n+            htmlSetMetaEncoding(cur, (const xmlChar *) encoding);\n@@ -1393,1 +1377,1 @@\n-        encoding = htmlGetMetaEncoding(cur);\n+            encoding = htmlGetMetaEncoding(cur);\n@@ -1395,6 +1379,7 @@\n-        encoding = BAD_CAST \"HTML\";\n-    if ((encoding != NULL) && (oldctxtenc == NULL) &&\n-        (buf->encoder == NULL) && (buf->conv == NULL)) {\n-        if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {\n-        cur->encoding = oldenc;\n-        return(-1);\n+            encoding = BAD_CAST \"HTML\";\n+        if ((encoding != NULL) && (oldctxtenc == NULL) &&\n+            (buf->encoder == NULL) && (buf->conv == NULL)) {\n+            if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {\n+                return(-1);\n+            }\n+            switched_encoding = 1;\n@@ -1402,1 +1387,0 @@\n-    }\n@@ -1404,8 +1388,5 @@\n-        htmlDocContentDumpFormatOutput(buf, cur,\n-                                       (const char *)encoding, 1);\n-    else\n-        htmlDocContentDumpFormatOutput(buf, cur,\n-                                       (const char *)encoding, 0);\n-    if (ctxt->encoding != NULL)\n-        cur->encoding = oldenc;\n-    return(0);\n+            htmlDocContentDumpFormatOutput(buf, cur,\n+                                           (const char *)encoding, 1);\n+        else\n+            htmlDocContentDumpFormatOutput(buf, cur,\n+                                           (const char *)encoding, 0);\n@@ -1418,17 +1399,11 @@\n-    enc = xmlParseCharEncoding((const char*) encoding);\n-    if ((encoding != NULL) && (oldctxtenc == NULL) &&\n-        (buf->encoder == NULL) && (buf->conv == NULL) &&\n-        ((ctxt->options & XML_SAVE_NO_DECL) == 0)) {\n-        if ((enc != XML_CHAR_ENCODING_UTF8) &&\n-        (enc != XML_CHAR_ENCODING_NONE) &&\n-        (enc != XML_CHAR_ENCODING_ASCII)) {\n-        \/*\n-         * we need to switch to this encoding but just for this\n-         * document since we output the XMLDecl the conversion\n-         * must be done to not generate not well formed documents.\n-         *\/\n-        if (xmlSaveSwitchEncoding(ctxt, (const char*) encoding) < 0) {\n-            cur->encoding = oldenc;\n-            return(-1);\n-        }\n-        switched_encoding = 1;\n+        if ((encoding != NULL) && (oldctxtenc == NULL) &&\n+            (buf->encoder == NULL) && (buf->conv == NULL) &&\n+            ((ctxt->options & XML_SAVE_NO_DECL) == 0)) {\n+            \/*\n+             * we need to switch to this encoding but just for this\n+             * document since we output the XMLDecl the conversion\n+             * must be done to not generate not well formed documents.\n+             *\/\n+            if (xmlSaveSwitchEncoding(ctxt, (const char *) encoding) < 0)\n+                return(-1);\n+            switched_encoding = 1;\n@@ -1436,5 +1411,0 @@\n-        if (ctxt->escape == xmlEscapeEntities)\n-        ctxt->escape = NULL;\n-        if (ctxt->escapeAttr == xmlEscapeEntities)\n-        ctxt->escapeAttr = NULL;\n-    }\n@@ -1443,20 +1413,22 @@\n-    \/*\n-     * Save the XML declaration\n-     *\/\n-    if ((ctxt->options & XML_SAVE_NO_DECL) == 0) {\n-        xmlOutputBufferWrite(buf, 14, \"<?xml version=\");\n-        if (cur->version != NULL)\n-        xmlOutputBufferWriteQuotedString(buf, cur->version);\n-        else\n-        xmlOutputBufferWrite(buf, 5, \"\\\"1.0\\\"\");\n-        if (encoding != NULL) {\n-        xmlOutputBufferWrite(buf, 10, \" encoding=\");\n-        xmlOutputBufferWriteQuotedString(buf, (xmlChar *) encoding);\n-        }\n-        switch (cur->standalone) {\n-        case 0:\n-            xmlOutputBufferWrite(buf, 16, \" standalone=\\\"no\\\"\");\n-            break;\n-        case 1:\n-            xmlOutputBufferWrite(buf, 17, \" standalone=\\\"yes\\\"\");\n-            break;\n+        \/*\n+         * Save the XML declaration\n+         *\/\n+        if ((ctxt->options & XML_SAVE_NO_DECL) == 0) {\n+            xmlOutputBufferWrite(buf, 14, \"<?xml version=\");\n+            if (cur->version != NULL)\n+                xmlOutputBufferWriteQuotedString(buf, cur->version);\n+            else\n+                xmlOutputBufferWrite(buf, 5, \"\\\"1.0\\\"\");\n+            if (encoding != NULL) {\n+                xmlOutputBufferWrite(buf, 10, \" encoding=\");\n+                xmlOutputBufferWriteQuotedString(buf, (xmlChar *) encoding);\n+            }\n+            switch (cur->standalone) {\n+                case 0:\n+                    xmlOutputBufferWrite(buf, 16, \" standalone=\\\"no\\\"\");\n+                    break;\n+                case 1:\n+                    xmlOutputBufferWrite(buf, 17, \" standalone=\\\"yes\\\"\");\n+                    break;\n+            }\n+            xmlOutputBufferWrite(buf, 3, \"?>\\n\");\n@@ -1464,2 +1436,0 @@\n-        xmlOutputBufferWrite(buf, 3, \"?>\\n\");\n-    }\n@@ -1470,5 +1440,6 @@\n-    if ((ctxt->options & XML_SAVE_NO_XHTML) == 0) {\n-        dtd = xmlGetIntSubset(cur);\n-        if (dtd != NULL) {\n-        is_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);\n-        if (is_xhtml < 0) is_xhtml = 0;\n+        if ((ctxt->options & XML_SAVE_NO_XHTML) == 0) {\n+            dtd = xmlGetIntSubset(cur);\n+            if (dtd != NULL) {\n+                is_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);\n+                if (is_xhtml < 0) is_xhtml = 0;\n+            }\n@@ -1476,1 +1447,0 @@\n-    }\n@@ -1478,2 +1448,2 @@\n-    if (cur->children != NULL) {\n-        xmlNodePtr child = cur->children;\n+        if (cur->children != NULL) {\n+            xmlNodePtr child = cur->children;\n@@ -1481,2 +1451,2 @@\n-        while (child != NULL) {\n-        ctxt->level = 0;\n+            while (child != NULL) {\n+                ctxt->level = 0;\n@@ -1484,3 +1454,3 @@\n-        if (is_xhtml)\n-            xhtmlNodeDumpOutput(ctxt, child);\n-        else\n+                if (is_xhtml)\n+                    xhtmlNodeDumpOutput(ctxt, child);\n+                else\n@@ -1488,1 +1458,1 @@\n-            xmlNodeDumpOutputInternal(ctxt, child);\n+                    xmlNodeDumpOutputInternal(ctxt, child);\n@@ -1492,1 +1462,2 @@\n-        child = child->next;\n+                child = child->next;\n+            }\n@@ -1495,1 +1466,0 @@\n-    }\n@@ -1501,3 +1471,1 @@\n-    xmlSaveClearEncoding(ctxt);\n-    ctxt->escape = oldescape;\n-    ctxt->escapeAttr = oldescapeAttr;\n+        xmlSaveClearEncoding(ctxt);\n@@ -1505,1 +1473,0 @@\n-    cur->encoding = oldenc;\n@@ -1511,3 +1478,3 @@\n- *                                    *\n- *        Functions specific to XHTML serialization        *\n- *                                    *\n+ *                                                                      *\n+ *              Functions specific to XHTML serialization               *\n+ *                                                                      *\n@@ -1527,1 +1494,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1529,21 +1496,0 @@\n-    return(0);\n-    if ((node->ns != NULL) && (!xmlStrEqual(node->ns->href, XHTML_NS_NAME)))\n-    return(0);\n-    if (node->children != NULL)\n-    return(0);\n-    switch (node->name ? node->name[0] : 0) {\n-    case 'a':\n-        if (xmlStrEqual(node->name, BAD_CAST \"area\"))\n-        return(1);\n-        return(0);\n-    case 'b':\n-        if (xmlStrEqual(node->name, BAD_CAST \"br\"))\n-        return(1);\n-        if (xmlStrEqual(node->name, BAD_CAST \"base\"))\n-        return(1);\n-        if (xmlStrEqual(node->name, BAD_CAST \"basefont\"))\n-        return(1);\n-        return(0);\n-    case 'c':\n-        if (xmlStrEqual(node->name, BAD_CAST \"col\"))\n-        return(1);\n@@ -1551,23 +1497,1 @@\n-    case 'f':\n-        if (xmlStrEqual(node->name, BAD_CAST \"frame\"))\n-        return(1);\n-        return(0);\n-    case 'h':\n-        if (xmlStrEqual(node->name, BAD_CAST \"hr\"))\n-        return(1);\n-        return(0);\n-    case 'i':\n-        if (xmlStrEqual(node->name, BAD_CAST \"img\"))\n-        return(1);\n-        if (xmlStrEqual(node->name, BAD_CAST \"input\"))\n-        return(1);\n-        if (xmlStrEqual(node->name, BAD_CAST \"isindex\"))\n-        return(1);\n-        return(0);\n-    case 'l':\n-        if (xmlStrEqual(node->name, BAD_CAST \"link\"))\n-        return(1);\n-        return(0);\n-    case 'm':\n-        if (xmlStrEqual(node->name, BAD_CAST \"meta\"))\n-        return(1);\n+    if ((node->ns != NULL) && (!xmlStrEqual(node->ns->href, XHTML_NS_NAME)))\n@@ -1575,3 +1499,1 @@\n-    case 'p':\n-        if (xmlStrEqual(node->name, BAD_CAST \"param\"))\n-        return(1);\n+    if (node->children != NULL)\n@@ -1579,0 +1501,45 @@\n+    switch (node->name ? node->name[0] : 0) {\n+        case 'a':\n+            if (xmlStrEqual(node->name, BAD_CAST \"area\"))\n+                return(1);\n+            return(0);\n+        case 'b':\n+            if (xmlStrEqual(node->name, BAD_CAST \"br\"))\n+                return(1);\n+            if (xmlStrEqual(node->name, BAD_CAST \"base\"))\n+                return(1);\n+            if (xmlStrEqual(node->name, BAD_CAST \"basefont\"))\n+                return(1);\n+            return(0);\n+        case 'c':\n+            if (xmlStrEqual(node->name, BAD_CAST \"col\"))\n+                return(1);\n+            return(0);\n+        case 'f':\n+            if (xmlStrEqual(node->name, BAD_CAST \"frame\"))\n+                return(1);\n+            return(0);\n+        case 'h':\n+            if (xmlStrEqual(node->name, BAD_CAST \"hr\"))\n+                return(1);\n+            return(0);\n+        case 'i':\n+            if (xmlStrEqual(node->name, BAD_CAST \"img\"))\n+                return(1);\n+            if (xmlStrEqual(node->name, BAD_CAST \"input\"))\n+                return(1);\n+            if (xmlStrEqual(node->name, BAD_CAST \"isindex\"))\n+                return(1);\n+            return(0);\n+        case 'l':\n+            if (xmlStrEqual(node->name, BAD_CAST \"link\"))\n+                return(1);\n+            return(0);\n+        case 'm':\n+            if (xmlStrEqual(node->name, BAD_CAST \"meta\"))\n+                return(1);\n+            return(0);\n+        case 'p':\n+            if (xmlStrEqual(node->name, BAD_CAST \"param\"))\n+                return(1);\n+            return(0);\n@@ -1602,12 +1569,12 @@\n-    if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST \"id\")))\n-        id = cur;\n-    else\n-    if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST \"name\")))\n-        name = cur;\n-    else\n-    if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST \"lang\")))\n-        lang = cur;\n-    else\n-    if ((cur->ns != NULL) && (xmlStrEqual(cur->name, BAD_CAST \"lang\")) &&\n-        (xmlStrEqual(cur->ns->prefix, BAD_CAST \"xml\")))\n-        xml_lang = cur;\n+        if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST \"id\")))\n+            id = cur;\n+        else\n+        if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST \"name\")))\n+            name = cur;\n+        else\n+        if ((cur->ns == NULL) && (xmlStrEqual(cur->name, BAD_CAST \"lang\")))\n+            lang = cur;\n+        else\n+        if ((cur->ns != NULL) && (xmlStrEqual(cur->name, BAD_CAST \"lang\")) &&\n+            (xmlStrEqual(cur->ns->prefix, BAD_CAST \"xml\")))\n+            xml_lang = cur;\n@@ -1615,1 +1582,1 @@\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -1621,14 +1588,14 @@\n-    if ((parent != NULL) && (parent->name != NULL) &&\n-        ((xmlStrEqual(parent->name, BAD_CAST \"a\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"p\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"div\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"img\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"map\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"applet\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"form\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"frame\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"iframe\")))) {\n-        xmlOutputBufferWrite(buf, 5, \" id=\\\"\");\n-        xmlAttrSerializeContent(buf, name);\n-        xmlOutputBufferWrite(buf, 1, \"\\\"\");\n-    }\n+        if ((parent != NULL) && (parent->name != NULL) &&\n+            ((xmlStrEqual(parent->name, BAD_CAST \"a\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"p\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"div\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"img\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"map\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"applet\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"form\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"frame\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"iframe\")))) {\n+            xmlOutputBufferWrite(buf, 5, \" id=\\\"\");\n+            xmlSaveWriteAttrContent(ctxt, name);\n+            xmlOutputBufferWrite(buf, 1, \"\\\"\");\n+        }\n@@ -1640,3 +1607,3 @@\n-    xmlOutputBufferWrite(buf, 11, \" xml:lang=\\\"\");\n-    xmlAttrSerializeContent(buf, lang);\n-    xmlOutputBufferWrite(buf, 1, \"\\\"\");\n+        xmlOutputBufferWrite(buf, 11, \" xml:lang=\\\"\");\n+        xmlSaveWriteAttrContent(ctxt, lang);\n+        xmlOutputBufferWrite(buf, 1, \"\\\"\");\n@@ -1645,3 +1612,3 @@\n-    xmlOutputBufferWrite(buf, 7, \" lang=\\\"\");\n-    xmlAttrSerializeContent(buf, xml_lang);\n-    xmlOutputBufferWrite(buf, 1, \"\\\"\");\n+        xmlOutputBufferWrite(buf, 7, \" lang=\\\"\");\n+        xmlSaveWriteAttrContent(ctxt, xml_lang);\n+        xmlOutputBufferWrite(buf, 1, \"\\\"\");\n@@ -1681,1 +1648,1 @@\n-        break;\n+            break;\n@@ -1684,2 +1651,2 @@\n-        xmlNsDumpOutput(buf, NULL, (xmlNsPtr) cur, ctxt);\n-        break;\n+            xmlNsDumpOutput(buf, (xmlNsPtr) cur, ctxt);\n+            break;\n@@ -1689,1 +1656,1 @@\n-        break;\n+            break;\n@@ -1702,1 +1669,1 @@\n-        break;\n+            break;\n@@ -1705,2 +1672,2 @@\n-            xmlBufDumpAttributeDecl(buf, (xmlAttributePtr) cur);\n-        break;\n+            xmlSaveWriteAttributeDecl(ctxt, (xmlAttributePtr) cur);\n+            break;\n@@ -1710,1 +1677,1 @@\n-        break;\n+            break;\n@@ -1715,5 +1682,2 @@\n-        if ((cur != root) && (ctxt->format == 1) && (xmlIndentTreeOutput))\n-        xmlOutputBufferWrite(buf, ctxt->indent_size *\n-                     (ctxt->level > ctxt->indent_nr ?\n-                      ctxt->indent_nr : ctxt->level),\n-                     ctxt->indent);\n+            if ((cur != root) && (ctxt->format == 1))\n+                xmlSaveWriteIndent(ctxt, 0);\n@@ -1739,1 +1703,1 @@\n-                xmlNsListDumpOutputCtxt(ctxt, cur->doc, cur->nsDef);\n+                xmlNsListDumpOutputCtxt(ctxt, cur->nsDef);\n@@ -1759,0 +1723,1 @@\n+                        int res;\n@@ -1761,2 +1726,5 @@\n-                        httpequiv = xmlGetProp(tmp, BAD_CAST\"http-equiv\");\n-                        if (httpequiv != NULL) {\n+                        res = xmlNodeGetAttrValue(tmp, BAD_CAST \"http-equiv\",\n+                                                  NULL, &httpequiv);\n+                        if (res < 0) {\n+                            xmlSaveErrMemory(buf);\n+                        } else if (res == 0) {\n@@ -1789,5 +1757,1 @@\n-                            if (xmlIndentTreeOutput)\n-                                xmlOutputBufferWrite(buf, ctxt->indent_size *\n-                                    (ctxt->level + 1 > ctxt->indent_nr ?\n-                                    ctxt->indent_nr : ctxt->level + 1),\n-                                    ctxt->indent);\n+                            xmlSaveWriteIndent(ctxt, 1);\n@@ -1827,5 +1791,1 @@\n-                        if (xmlIndentTreeOutput)\n-                            xmlOutputBufferWrite(buf, ctxt->indent_size *\n-                                (ctxt->level + 1 > ctxt->indent_nr ?\n-                                ctxt->indent_nr : ctxt->level + 1),\n-                                ctxt->indent);\n+                        xmlSaveWriteIndent(ctxt, 1);\n@@ -1868,1 +1828,1 @@\n-        if (cur->content == NULL)\n+            if (cur->content == NULL)\n@@ -1870,10 +1830,14 @@\n-        if ((cur->name == xmlStringText) ||\n-        (cur->name != xmlStringTextNoenc)) {\n-                xmlOutputBufferWriteEscape(buf, cur->content, ctxt->escape);\n-        } else {\n-        \/*\n-         * Disable escaping, needed for XSLT\n-         *\/\n-        xmlOutputBufferWriteString(buf, (const char *) cur->content);\n-        }\n-        break;\n+            if ((cur->name == xmlStringText) ||\n+                (cur->name != xmlStringTextNoenc)) {\n+                if (ctxt->escape)\n+                    xmlOutputBufferWriteEscape(buf, cur->content,\n+                                               ctxt->escape);\n+                else\n+                    xmlSaveWriteText(ctxt, cur->content, \/* flags *\/ 0);\n+            } else {\n+                \/*\n+                 * Disable escaping, needed for XSLT\n+                 *\/\n+                xmlOutputBufferWriteString(buf, (const char *) cur->content);\n+            }\n+            break;\n@@ -1939,1 +1903,1 @@\n-        break;\n+            break;\n@@ -1961,5 +1925,2 @@\n-                if ((xmlIndentTreeOutput) && (ctxt->format == 1))\n-                    xmlOutputBufferWrite(buf, ctxt->indent_size *\n-                                         (ctxt->level > ctxt->indent_nr ?\n-                                          ctxt->indent_nr : ctxt->level),\n-                                         ctxt->indent);\n+                if (ctxt->format == 1)\n+                    xmlSaveWriteIndent(ctxt, 0);\n@@ -1990,3 +1951,3 @@\n- *                                    *\n- *            Public entry points                *\n- *                                    *\n+ *                                                                      *\n+ *                      Public entry points                             *\n+ *                                                                      *\n@@ -2016,2 +1977,2 @@\n-    xmlFreeSaveCtxt(ret);\n-    return(NULL);\n+        xmlFreeSaveCtxt(ret);\n+        return(NULL);\n@@ -2046,2 +2007,2 @@\n-    xmlFreeSaveCtxt(ret);\n-    return(NULL);\n+        xmlFreeSaveCtxt(ret);\n+        return(NULL);\n@@ -2074,2 +2035,2 @@\n-    xmlFreeSaveCtxt(ret);\n-    return(NULL);\n+        xmlFreeSaveCtxt(ret);\n+        return(NULL);\n@@ -2105,2 +2066,2 @@\n-    xmlFreeSaveCtxt(ret);\n-    return(NULL);\n+        xmlFreeSaveCtxt(ret);\n+        return(NULL);\n@@ -2159,2 +2120,2 @@\n-    htmlNodeDumpOutputInternal(ctxt, cur);\n-    return(ret);\n+        htmlNodeDumpOutputInternal(ctxt, cur);\n+        return(ret);\n@@ -2249,1 +2210,1 @@\n-int\n+xmlParserErrors\n@@ -2256,2 +2217,8 @@\n-    xmlSaveFlush(ctxt);\n-    ret = ctxt->buf->error;\n+\n+    ret = xmlOutputBufferClose(ctxt->buf);\n+    ctxt->buf = NULL;\n+    if (ret < 0)\n+        ret = -ret;\n+    else\n+        ret = XML_ERR_OK;\n+\n@@ -2267,0 +2234,2 @@\n+ * DEPRECATED: Don't use.\n+ *\n@@ -2284,1 +2253,3 @@\n- * Set a custom escaping function to be used for text in attribute content\n+ * DEPRECATED: Don't use.\n+ *\n+ * Has no effect.\n@@ -2289,1 +2260,2 @@\n-xmlSaveSetAttrEscape(xmlSaveCtxtPtr ctxt, xmlCharEncodingOutputFunc escape)\n+xmlSaveSetAttrEscape(xmlSaveCtxtPtr ctxt,\n+                     xmlCharEncodingOutputFunc escape ATTRIBUTE_UNUSED)\n@@ -2292,1 +2264,0 @@\n-    ctxt->escapeAttr = escape;\n@@ -2297,3 +2268,3 @@\n- *                                    *\n- *        Public entry points based on buffers            *\n- *                                    *\n+ *                                                                      *\n+ *              Public entry points based on buffers                    *\n+ *                                                                      *\n@@ -2314,58 +2285,1 @@\n-    const xmlChar *base, *cur;\n-\n-    if (string == NULL)\n-        return;\n-    base = cur = string;\n-    while (*cur != 0) {\n-        if (*cur == '\\n') {\n-            if (base != cur)\n-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);\n-            xmlOutputBufferWrite(buf, 5, \"&#10;\");\n-            cur++;\n-            base = cur;\n-        } else if (*cur == '\\r') {\n-            if (base != cur)\n-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);\n-            xmlOutputBufferWrite(buf, 5, \"&#13;\");\n-            cur++;\n-            base = cur;\n-        } else if (*cur == '\\t') {\n-            if (base != cur)\n-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);\n-            xmlOutputBufferWrite(buf, 4, \"&#9;\");\n-            cur++;\n-            base = cur;\n-        } else if (*cur == '\"') {\n-            if (base != cur)\n-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);\n-            xmlOutputBufferWrite(buf, 6, \"&quot;\");\n-            cur++;\n-            base = cur;\n-        } else if (*cur == '<') {\n-            if (base != cur)\n-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);\n-            xmlOutputBufferWrite(buf, 4, \"&lt;\");\n-            cur++;\n-            base = cur;\n-        } else if (*cur == '>') {\n-            if (base != cur)\n-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);\n-            xmlOutputBufferWrite(buf, 4, \"&gt;\");\n-            cur++;\n-            base = cur;\n-        } else if (*cur == '&') {\n-            if (base != cur)\n-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);\n-            xmlOutputBufferWrite(buf, 5, \"&amp;\");\n-            cur++;\n-            base = cur;\n-        } else if ((*cur >= 0x80) && (cur[1] != 0) &&\n-               ((doc == NULL) || (doc->encoding == NULL))) {\n-            \/*\n-             * We assume we have UTF-8 content.\n-             *\/\n-            unsigned char tmp[12];\n-            int val = 0, l = 4;\n-\n-            if (base != cur)\n-                xmlOutputBufferWrite(buf, cur - base, (const char *) base);\n+    int flags = XML_ESCAPE_ATTR;\n@@ -2373,23 +2287,3 @@\n-            val = xmlGetUTF8Char(cur, &l);\n-            if (val < 0) {\n-                val = 0xFFFD;\n-                cur++;\n-            } else {\n-                if (!IS_CHAR(val))\n-                    val = 0xFFFD;\n-                cur += l;\n-            }\n-\n-            \/*\n-             * We could do multiple things here. Just save\n-             * as a char ref\n-             *\/\n-        xmlSerializeHexCharRef(tmp, val);\n-            xmlOutputBufferWriteString(buf, (const char *) tmp);\n-            base = cur;\n-        } else {\n-            cur++;\n-        }\n-    }\n-    if (base != cur)\n-        xmlOutputBufferWrite(buf, cur - base, (const char *) base);\n+    if ((doc == NULL) || (doc->encoding == NULL))\n+        flags |= XML_ESCAPE_NON_ASCII;\n+    xmlSerializeText(buf, string, flags);\n@@ -2445,1 +2339,2 @@\n-    size_t ret;\n+    size_t ret1;\n+    int ret2;\n@@ -2456,3 +2351,3 @@\n-    ret = xmlBufNodeDump(buffer, doc, cur, level, format);\n-    xmlBufBackToBuffer(buffer);\n-    if (ret > INT_MAX)\n+    ret1 = xmlBufNodeDump(buffer, doc, cur, level, format);\n+    ret2 = xmlBufBackToBuffer(buffer, buf);\n+    if ((ret1 == (size_t) -1) || (ret2 < 0))\n@@ -2460,1 +2355,1 @@\n-    return(ret);\n+    return(ret1 > INT_MAX ? INT_MAX : ret1);\n@@ -2486,1 +2381,0 @@\n-    int oldalloc;\n@@ -2510,2 +2404,0 @@\n-    oldalloc = xmlBufGetAllocationScheme(buf);\n-    xmlBufSetAllocationScheme(buf, XML_BUFFER_ALLOC_DOUBLEIT);\n@@ -2513,1 +2405,0 @@\n-    xmlBufSetAllocationScheme(buf, oldalloc);\n@@ -2554,3 +2445,3 @@\n- *                                    *\n- *        Saving functions front-ends                *\n- *                                    *\n+ *                                                                      *\n+ *              Saving functions front-ends                             *\n+ *                                                                      *\n@@ -2577,0 +2468,1 @@\n+    int options;\n@@ -2599,1 +2491,0 @@\n-    ctxt.format = format ? 1 : 0;\n@@ -2601,2 +2492,5 @@\n-    xmlSaveCtxtInit(&ctxt);\n-    ctxt.options |= XML_SAVE_AS_XML;\n+\n+    options = XML_SAVE_AS_XML;\n+    if (format)\n+        options |= XML_SAVE_FORMAT;\n+    xmlSaveCtxtInit(&ctxt, options);\n@@ -2607,3 +2501,3 @@\n-    is_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);\n-    if (is_xhtml < 0)\n-        is_xhtml = 0;\n+        is_xhtml = xmlIsXHTML(dtd->SystemID, dtd->ExternalID);\n+        if (is_xhtml < 0)\n+            is_xhtml = 0;\n@@ -2636,2 +2530,2 @@\n-        int * doc_txt_len, const char * txt_encoding,\n-        int format) {\n+                int * doc_txt_len, const char * txt_encoding,\n+                int format) {\n@@ -2639,0 +2533,1 @@\n+    int options;\n@@ -2666,1 +2561,1 @@\n-    txt_encoding = (const char *) out_doc->encoding;\n+        txt_encoding = (const char *) out_doc->encoding;\n@@ -2668,1 +2563,1 @@\n-        int res;\n+        xmlParserErrors res;\n@@ -2670,1 +2565,1 @@\n-    res = xmlOpenCharEncodingHandler(txt_encoding, \/* output *\/ 1,\n+        res = xmlOpenCharEncodingHandler(txt_encoding, \/* output *\/ 1,\n@@ -2672,1 +2567,1 @@\n-    if (res != XML_ERR_OK) {\n+        if (res != XML_ERR_OK) {\n@@ -2674,2 +2569,2 @@\n-        return;\n-    }\n+            return;\n+        }\n@@ -2678,1 +2573,2 @@\n-    if ((out_buff = xmlAllocOutputBuffer(conv_hdlr)) == NULL ) {\n+    out_buff = xmlAllocOutputBuffer(conv_hdlr);\n+    if (out_buff == NULL ) {\n@@ -2680,1 +2576,0 @@\n-        xmlCharEncCloseFunc(conv_hdlr);\n@@ -2687,1 +2582,0 @@\n-    ctxt.format = format ? 1 : 0;\n@@ -2689,2 +2583,6 @@\n-    xmlSaveCtxtInit(&ctxt);\n-    ctxt.options |= XML_SAVE_AS_XML;\n+\n+    options = XML_SAVE_AS_XML;\n+    if (format)\n+        options |= XML_SAVE_FORMAT;\n+    xmlSaveCtxtInit(&ctxt, options);\n+\n@@ -2755,1 +2653,1 @@\n-                int * doc_txt_len, const char * txt_encoding) {\n+                    int * doc_txt_len, const char * txt_encoding) {\n@@ -2757,1 +2655,1 @@\n-                          txt_encoding, 0);\n+                              txt_encoding, 0);\n@@ -2779,0 +2677,1 @@\n+    int options;\n@@ -2781,1 +2680,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2786,1 +2685,1 @@\n-        int res;\n+        xmlParserErrors res;\n@@ -2788,6 +2687,5 @@\n-    res = xmlOpenCharEncodingHandler(encoding, \/* output *\/ 1, &handler);\n-    if (res != XML_ERR_OK) {\n-        xmlFree((char *) cur->encoding);\n-        cur->encoding = NULL;\n-        encoding = NULL;\n-    }\n+        res = xmlOpenCharEncodingHandler(encoding, \/* output *\/ 1, &handler);\n+        if (res != XML_ERR_OK) {\n+            xmlFree((char *) cur->encoding);\n+            encoding = NULL;\n+        }\n@@ -2800,1 +2698,0 @@\n-    ctxt.format = format ? 1 : 0;\n@@ -2802,2 +2699,6 @@\n-    xmlSaveCtxtInit(&ctxt);\n-    ctxt.options |= XML_SAVE_AS_XML;\n+\n+    options = XML_SAVE_AS_XML;\n+    if (format)\n+        options |= XML_SAVE_FORMAT;\n+    xmlSaveCtxtInit(&ctxt, options);\n+\n@@ -2844,1 +2745,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2849,1 +2750,0 @@\n-    ctxt.format = 0;\n@@ -2851,2 +2751,3 @@\n-    xmlSaveCtxtInit(&ctxt);\n-    ctxt.options |= XML_SAVE_AS_XML;\n+\n+    xmlSaveCtxtInit(&ctxt, XML_SAVE_AS_XML);\n+\n@@ -2877,0 +2778,1 @@\n+    int options;\n@@ -2881,1 +2783,1 @@\n-     (cur->type != XML_HTML_DOCUMENT_NODE))) {\n+         (cur->type != XML_HTML_DOCUMENT_NODE))) {\n@@ -2883,1 +2785,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2888,1 +2790,0 @@\n-    ctxt.format = format ? 1 : 0;\n@@ -2890,2 +2791,6 @@\n-    xmlSaveCtxtInit(&ctxt);\n-    ctxt.options |= XML_SAVE_AS_XML;\n+\n+    options = XML_SAVE_AS_XML;\n+    if (format)\n+        options |= XML_SAVE_FORMAT;\n+    xmlSaveCtxtInit(&ctxt, options);\n+\n@@ -2912,1 +2817,1 @@\n-            const char * encoding, int format ) {\n+                        const char * encoding, int format ) {\n@@ -2917,0 +2822,1 @@\n+    int options;\n@@ -2919,1 +2825,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2922,1 +2828,1 @@\n-    encoding = (const char *) cur->encoding;\n+        encoding = (const char *) cur->encoding;\n@@ -2925,1 +2831,1 @@\n-        int res;\n+        xmlParserErrors res;\n@@ -2943,1 +2849,0 @@\n-    ctxt.format = format ? 1 : 0;\n@@ -2945,2 +2850,5 @@\n-    xmlSaveCtxtInit(&ctxt);\n-    ctxt.options |= XML_SAVE_AS_XML;\n+\n+    options = XML_SAVE_AS_XML;\n+    if (format)\n+        options |= XML_SAVE_FORMAT;\n+    xmlSaveCtxtInit(&ctxt, options);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlsave.c","additions":695,"deletions":787,"binary":false,"changes":1482,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);\n+    ret = xmlMalloc((size_t) len + 1);\n@@ -101,1 +101,1 @@\n-    ret = (xmlChar *) xmlMallocAtomic((size_t) len + 1);\n+    ret = xmlMalloc((size_t) len + 1);\n@@ -463,1 +463,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -911,1 +911,1 @@\n-    *len = 0;\n+        *len = 0;\n@@ -946,1 +946,1 @@\n-        if ((c & 0x80) == 0x00) {    \/* 1-byte code, starts with 10 *\/\n+        if ((c & 0x80) == 0x00) {       \/* 1-byte code, starts with 10 *\/\n@@ -948,7 +948,16 @@\n-    } else if ((c & 0xe0) == 0xc0) {\/* 2-byte code, starts with 110 *\/\n-        if ((utf[1] & 0xc0 ) != 0x80)\n-            return 0;\n-        ix = 2;\n-    } else if ((c & 0xf0) == 0xe0) {\/* 3-byte code, starts with 1110 *\/\n-        if (((utf[1] & 0xc0) != 0x80) ||\n-            ((utf[2] & 0xc0) != 0x80))\n+        } else if ((c & 0xe0) == 0xc0) {\/* 2-byte code, starts with 110 *\/\n+            if ((utf[1] & 0xc0 ) != 0x80)\n+                return 0;\n+            ix = 2;\n+        } else if ((c & 0xf0) == 0xe0) {\/* 3-byte code, starts with 1110 *\/\n+            if (((utf[1] & 0xc0) != 0x80) ||\n+                ((utf[2] & 0xc0) != 0x80))\n+                    return 0;\n+            ix = 3;\n+        } else if ((c & 0xf8) == 0xf0) {\/* 4-byte code, starts with 11110 *\/\n+            if (((utf[1] & 0xc0) != 0x80) ||\n+                ((utf[2] & 0xc0) != 0x80) ||\n+                ((utf[3] & 0xc0) != 0x80))\n+                    return 0;\n+            ix = 4;\n+        } else                          \/* unknown encoding *\/\n@@ -956,9 +965,0 @@\n-        ix = 3;\n-    } else if ((c & 0xf8) == 0xf0) {\/* 4-byte code, starts with 11110 *\/\n-        if (((utf[1] & 0xc0) != 0x80) ||\n-            ((utf[2] & 0xc0) != 0x80) ||\n-        ((utf[3] & 0xc0) != 0x80))\n-            return 0;\n-        ix = 4;\n-    } else                \/* unknown encoding *\/\n-        return 0;\n@@ -997,1 +997,2 @@\n-        if ( (ch = *ptr++) & 0x80)\n+        ch = *ptr++;\n+        if ((ch & 0x80))\n@@ -999,1 +1000,1 @@\n-        if (*ptr == 0) break;\n+                if (*ptr == 0) break;\n@@ -1001,1 +1002,1 @@\n-        }\n+            }\n@@ -1024,1 +1025,1 @@\n-    ret = (xmlChar *) xmlMallocAtomic((size_t) i + 1);\n+    ret = xmlMalloc((size_t) i + 1);\n@@ -1051,1 +1052,3 @@\n-        if ((ch=*utf++) == 0) return(NULL);\n+        ch = *utf++;\n+        if (ch == 0)\n+            return(NULL);\n@@ -1178,1 +1181,1 @@\n-    result = (xmlChar *) xmlMallocAtomic(resultLen);\n+    result = xmlMalloc(resultLen);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlstring.c","additions":30,"deletions":27,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -9,1 +9,1 @@\n- * Generation date: Mon Mar 27 11:09:52 2006\n+ * Generation date: Tue Mar  4 16:29:31 2025\n@@ -17,1 +17,1 @@\n-#ifdef LIBXML_UNICODE_ENABLED\n+#ifdef LIBXML_REGEXP_ENABLED\n@@ -21,1 +21,0 @@\n-#include <libxml\/xmlunicode.h>\n@@ -24,1 +23,3 @@\n-typedef int (xmlIntFunc)(int);    \/* just to keep one's mind untwisted *\/\n+#include \"private\/unicode.h\"\n+\n+typedef int (xmlIntFunc)(int);  \/* just to keep one's mind untwisted *\/\n@@ -33,1 +34,1 @@\n-    int            numentries;\n+    int             numentries;\n@@ -39,168 +40,0 @@\n-static const xmlUnicodeRange xmlUnicodeBlocks[] = {\n-  {\"AegeanNumbers\", xmlUCSIsAegeanNumbers},\n-  {\"AlphabeticPresentationForms\", xmlUCSIsAlphabeticPresentationForms},\n-  {\"Arabic\", xmlUCSIsArabic},\n-  {\"ArabicPresentationForms-A\", xmlUCSIsArabicPresentationFormsA},\n-  {\"ArabicPresentationForms-B\", xmlUCSIsArabicPresentationFormsB},\n-  {\"Armenian\", xmlUCSIsArmenian},\n-  {\"Arrows\", xmlUCSIsArrows},\n-  {\"BasicLatin\", xmlUCSIsBasicLatin},\n-  {\"Bengali\", xmlUCSIsBengali},\n-  {\"BlockElements\", xmlUCSIsBlockElements},\n-  {\"Bopomofo\", xmlUCSIsBopomofo},\n-  {\"BopomofoExtended\", xmlUCSIsBopomofoExtended},\n-  {\"BoxDrawing\", xmlUCSIsBoxDrawing},\n-  {\"BraillePatterns\", xmlUCSIsBraillePatterns},\n-  {\"Buhid\", xmlUCSIsBuhid},\n-  {\"ByzantineMusicalSymbols\", xmlUCSIsByzantineMusicalSymbols},\n-  {\"CJKCompatibility\", xmlUCSIsCJKCompatibility},\n-  {\"CJKCompatibilityForms\", xmlUCSIsCJKCompatibilityForms},\n-  {\"CJKCompatibilityIdeographs\", xmlUCSIsCJKCompatibilityIdeographs},\n-  {\"CJKCompatibilityIdeographsSupplement\", xmlUCSIsCJKCompatibilityIdeographsSupplement},\n-  {\"CJKRadicalsSupplement\", xmlUCSIsCJKRadicalsSupplement},\n-  {\"CJKSymbolsandPunctuation\", xmlUCSIsCJKSymbolsandPunctuation},\n-  {\"CJKUnifiedIdeographs\", xmlUCSIsCJKUnifiedIdeographs},\n-  {\"CJKUnifiedIdeographsExtensionA\", xmlUCSIsCJKUnifiedIdeographsExtensionA},\n-  {\"CJKUnifiedIdeographsExtensionB\", xmlUCSIsCJKUnifiedIdeographsExtensionB},\n-  {\"Cherokee\", xmlUCSIsCherokee},\n-  {\"CombiningDiacriticalMarks\", xmlUCSIsCombiningDiacriticalMarks},\n-  {\"CombiningDiacriticalMarksforSymbols\", xmlUCSIsCombiningDiacriticalMarksforSymbols},\n-  {\"CombiningHalfMarks\", xmlUCSIsCombiningHalfMarks},\n-  {\"CombiningMarksforSymbols\", xmlUCSIsCombiningMarksforSymbols},\n-  {\"ControlPictures\", xmlUCSIsControlPictures},\n-  {\"CurrencySymbols\", xmlUCSIsCurrencySymbols},\n-  {\"CypriotSyllabary\", xmlUCSIsCypriotSyllabary},\n-  {\"Cyrillic\", xmlUCSIsCyrillic},\n-  {\"CyrillicSupplement\", xmlUCSIsCyrillicSupplement},\n-  {\"Deseret\", xmlUCSIsDeseret},\n-  {\"Devanagari\", xmlUCSIsDevanagari},\n-  {\"Dingbats\", xmlUCSIsDingbats},\n-  {\"EnclosedAlphanumerics\", xmlUCSIsEnclosedAlphanumerics},\n-  {\"EnclosedCJKLettersandMonths\", xmlUCSIsEnclosedCJKLettersandMonths},\n-  {\"Ethiopic\", xmlUCSIsEthiopic},\n-  {\"GeneralPunctuation\", xmlUCSIsGeneralPunctuation},\n-  {\"GeometricShapes\", xmlUCSIsGeometricShapes},\n-  {\"Georgian\", xmlUCSIsGeorgian},\n-  {\"Gothic\", xmlUCSIsGothic},\n-  {\"Greek\", xmlUCSIsGreek},\n-  {\"GreekExtended\", xmlUCSIsGreekExtended},\n-  {\"GreekandCoptic\", xmlUCSIsGreekandCoptic},\n-  {\"Gujarati\", xmlUCSIsGujarati},\n-  {\"Gurmukhi\", xmlUCSIsGurmukhi},\n-  {\"HalfwidthandFullwidthForms\", xmlUCSIsHalfwidthandFullwidthForms},\n-  {\"HangulCompatibilityJamo\", xmlUCSIsHangulCompatibilityJamo},\n-  {\"HangulJamo\", xmlUCSIsHangulJamo},\n-  {\"HangulSyllables\", xmlUCSIsHangulSyllables},\n-  {\"Hanunoo\", xmlUCSIsHanunoo},\n-  {\"Hebrew\", xmlUCSIsHebrew},\n-  {\"HighPrivateUseSurrogates\", xmlUCSIsHighPrivateUseSurrogates},\n-  {\"HighSurrogates\", xmlUCSIsHighSurrogates},\n-  {\"Hiragana\", xmlUCSIsHiragana},\n-  {\"IPAExtensions\", xmlUCSIsIPAExtensions},\n-  {\"IdeographicDescriptionCharacters\", xmlUCSIsIdeographicDescriptionCharacters},\n-  {\"Kanbun\", xmlUCSIsKanbun},\n-  {\"KangxiRadicals\", xmlUCSIsKangxiRadicals},\n-  {\"Kannada\", xmlUCSIsKannada},\n-  {\"Katakana\", xmlUCSIsKatakana},\n-  {\"KatakanaPhoneticExtensions\", xmlUCSIsKatakanaPhoneticExtensions},\n-  {\"Khmer\", xmlUCSIsKhmer},\n-  {\"KhmerSymbols\", xmlUCSIsKhmerSymbols},\n-  {\"Lao\", xmlUCSIsLao},\n-  {\"Latin-1Supplement\", xmlUCSIsLatin1Supplement},\n-  {\"LatinExtended-A\", xmlUCSIsLatinExtendedA},\n-  {\"LatinExtended-B\", xmlUCSIsLatinExtendedB},\n-  {\"LatinExtendedAdditional\", xmlUCSIsLatinExtendedAdditional},\n-  {\"LetterlikeSymbols\", xmlUCSIsLetterlikeSymbols},\n-  {\"Limbu\", xmlUCSIsLimbu},\n-  {\"LinearBIdeograms\", xmlUCSIsLinearBIdeograms},\n-  {\"LinearBSyllabary\", xmlUCSIsLinearBSyllabary},\n-  {\"LowSurrogates\", xmlUCSIsLowSurrogates},\n-  {\"Malayalam\", xmlUCSIsMalayalam},\n-  {\"MathematicalAlphanumericSymbols\", xmlUCSIsMathematicalAlphanumericSymbols},\n-  {\"MathematicalOperators\", xmlUCSIsMathematicalOperators},\n-  {\"MiscellaneousMathematicalSymbols-A\", xmlUCSIsMiscellaneousMathematicalSymbolsA},\n-  {\"MiscellaneousMathematicalSymbols-B\", xmlUCSIsMiscellaneousMathematicalSymbolsB},\n-  {\"MiscellaneousSymbols\", xmlUCSIsMiscellaneousSymbols},\n-  {\"MiscellaneousSymbolsandArrows\", xmlUCSIsMiscellaneousSymbolsandArrows},\n-  {\"MiscellaneousTechnical\", xmlUCSIsMiscellaneousTechnical},\n-  {\"Mongolian\", xmlUCSIsMongolian},\n-  {\"MusicalSymbols\", xmlUCSIsMusicalSymbols},\n-  {\"Myanmar\", xmlUCSIsMyanmar},\n-  {\"NumberForms\", xmlUCSIsNumberForms},\n-  {\"Ogham\", xmlUCSIsOgham},\n-  {\"OldItalic\", xmlUCSIsOldItalic},\n-  {\"OpticalCharacterRecognition\", xmlUCSIsOpticalCharacterRecognition},\n-  {\"Oriya\", xmlUCSIsOriya},\n-  {\"Osmanya\", xmlUCSIsOsmanya},\n-  {\"PhoneticExtensions\", xmlUCSIsPhoneticExtensions},\n-  {\"PrivateUse\", xmlUCSIsPrivateUse},\n-  {\"PrivateUseArea\", xmlUCSIsPrivateUseArea},\n-  {\"Runic\", xmlUCSIsRunic},\n-  {\"Shavian\", xmlUCSIsShavian},\n-  {\"Sinhala\", xmlUCSIsSinhala},\n-  {\"SmallFormVariants\", xmlUCSIsSmallFormVariants},\n-  {\"SpacingModifierLetters\", xmlUCSIsSpacingModifierLetters},\n-  {\"Specials\", xmlUCSIsSpecials},\n-  {\"SuperscriptsandSubscripts\", xmlUCSIsSuperscriptsandSubscripts},\n-  {\"SupplementalArrows-A\", xmlUCSIsSupplementalArrowsA},\n-  {\"SupplementalArrows-B\", xmlUCSIsSupplementalArrowsB},\n-  {\"SupplementalMathematicalOperators\", xmlUCSIsSupplementalMathematicalOperators},\n-  {\"SupplementaryPrivateUseArea-A\", xmlUCSIsSupplementaryPrivateUseAreaA},\n-  {\"SupplementaryPrivateUseArea-B\", xmlUCSIsSupplementaryPrivateUseAreaB},\n-  {\"Syriac\", xmlUCSIsSyriac},\n-  {\"Tagalog\", xmlUCSIsTagalog},\n-  {\"Tagbanwa\", xmlUCSIsTagbanwa},\n-  {\"Tags\", xmlUCSIsTags},\n-  {\"TaiLe\", xmlUCSIsTaiLe},\n-  {\"TaiXuanJingSymbols\", xmlUCSIsTaiXuanJingSymbols},\n-  {\"Tamil\", xmlUCSIsTamil},\n-  {\"Telugu\", xmlUCSIsTelugu},\n-  {\"Thaana\", xmlUCSIsThaana},\n-  {\"Thai\", xmlUCSIsThai},\n-  {\"Tibetan\", xmlUCSIsTibetan},\n-  {\"Ugaritic\", xmlUCSIsUgaritic},\n-  {\"UnifiedCanadianAboriginalSyllabics\", xmlUCSIsUnifiedCanadianAboriginalSyllabics},\n-  {\"VariationSelectors\", xmlUCSIsVariationSelectors},\n-  {\"VariationSelectorsSupplement\", xmlUCSIsVariationSelectorsSupplement},\n-  {\"YiRadicals\", xmlUCSIsYiRadicals},\n-  {\"YiSyllables\", xmlUCSIsYiSyllables},\n-  {\"YijingHexagramSymbols\", xmlUCSIsYijingHexagramSymbols}};\n-\n-static const xmlUnicodeRange xmlUnicodeCats[] = {\n-  {\"C\", xmlUCSIsCatC},\n-  {\"Cc\", xmlUCSIsCatCc},\n-  {\"Cf\", xmlUCSIsCatCf},\n-  {\"Co\", xmlUCSIsCatCo},\n-  {\"Cs\", xmlUCSIsCatCs},\n-  {\"L\", xmlUCSIsCatL},\n-  {\"Ll\", xmlUCSIsCatLl},\n-  {\"Lm\", xmlUCSIsCatLm},\n-  {\"Lo\", xmlUCSIsCatLo},\n-  {\"Lt\", xmlUCSIsCatLt},\n-  {\"Lu\", xmlUCSIsCatLu},\n-  {\"M\", xmlUCSIsCatM},\n-  {\"Mc\", xmlUCSIsCatMc},\n-  {\"Me\", xmlUCSIsCatMe},\n-  {\"Mn\", xmlUCSIsCatMn},\n-  {\"N\", xmlUCSIsCatN},\n-  {\"Nd\", xmlUCSIsCatNd},\n-  {\"Nl\", xmlUCSIsCatNl},\n-  {\"No\", xmlUCSIsCatNo},\n-  {\"P\", xmlUCSIsCatP},\n-  {\"Pc\", xmlUCSIsCatPc},\n-  {\"Pd\", xmlUCSIsCatPd},\n-  {\"Pe\", xmlUCSIsCatPe},\n-  {\"Pf\", xmlUCSIsCatPf},\n-  {\"Pi\", xmlUCSIsCatPi},\n-  {\"Po\", xmlUCSIsCatPo},\n-  {\"Ps\", xmlUCSIsCatPs},\n-  {\"S\", xmlUCSIsCatS},\n-  {\"Sc\", xmlUCSIsCatSc},\n-  {\"Sk\", xmlUCSIsCatSk},\n-  {\"Sm\", xmlUCSIsCatSm},\n-  {\"So\", xmlUCSIsCatSo},\n-  {\"Z\", xmlUCSIsCatZ},\n-  {\"Zl\", xmlUCSIsCatZl},\n-  {\"Zp\", xmlUCSIsCatZp},\n-  {\"Zs\", xmlUCSIsCatZs}};\n-\n@@ -933,3 +766,0 @@\n-static const xmlUnicodeNameTable xmlUnicodeBlockTbl = {xmlUnicodeBlocks, 128};\n-static const xmlUnicodeNameTable xmlUnicodeCatTbl = {xmlUnicodeCats, 36};\n-\n@@ -956,7 +786,8 @@\n-    mid = (low + high) \/ 2;\n-    if ((cmp=strcmp(tname, sptr[mid].rangename)) == 0)\n-        return (sptr[mid].func);\n-    if (cmp < 0)\n-        high = mid - 1;\n-    else\n-        low = mid + 1;\n+        mid = (low + high) \/ 2;\n+        cmp = strcmp(tname, sptr[mid].rangename);\n+        if (cmp == 0)\n+            return (sptr[mid].func);\n+        if (cmp < 0)\n+            high = mid - 1;\n+        else\n+            low = mid + 1;\n@@ -975,1 +806,1 @@\n-int\n+static int\n@@ -988,1 +819,1 @@\n-int\n+static int\n@@ -1001,1 +832,1 @@\n-int\n+static int\n@@ -1014,1 +845,1 @@\n-int\n+static int\n@@ -1027,1 +858,1 @@\n-int\n+static int\n@@ -1040,1 +871,1 @@\n-int\n+static int\n@@ -1053,1 +884,1 @@\n-int\n+static int\n@@ -1066,1 +897,1 @@\n-int\n+static int\n@@ -1079,1 +910,1 @@\n-int\n+static int\n@@ -1092,1 +923,1 @@\n-int\n+static int\n@@ -1105,1 +936,1 @@\n-int\n+static int\n@@ -1118,1 +949,1 @@\n-int\n+static int\n@@ -1131,1 +962,1 @@\n-int\n+static int\n@@ -1144,1 +975,1 @@\n-int\n+static int\n@@ -1157,1 +988,1 @@\n-int\n+static int\n@@ -1170,1 +1001,1 @@\n-int\n+static int\n@@ -1183,1 +1014,1 @@\n-int\n+static int\n@@ -1196,1 +1027,1 @@\n-int\n+static int\n@@ -1209,1 +1040,1 @@\n-int\n+static int\n@@ -1222,1 +1053,1 @@\n-int\n+static int\n@@ -1235,1 +1066,1 @@\n-int\n+static int\n@@ -1248,1 +1079,1 @@\n-int\n+static int\n@@ -1261,1 +1092,1 @@\n-int\n+static int\n@@ -1274,1 +1105,1 @@\n-int\n+static int\n@@ -1287,1 +1118,1 @@\n-int\n+static int\n@@ -1300,1 +1131,1 @@\n-int\n+static int\n@@ -1313,1 +1144,1 @@\n-int\n+static int\n@@ -1326,1 +1157,1 @@\n-int\n+static int\n@@ -1339,1 +1170,1 @@\n-int\n+static int\n@@ -1352,1 +1183,1 @@\n-int\n+static int\n@@ -1365,1 +1196,1 @@\n-int\n+static int\n@@ -1378,1 +1209,1 @@\n-int\n+static int\n@@ -1391,1 +1222,1 @@\n-int\n+static int\n@@ -1404,1 +1235,1 @@\n-int\n+static int\n@@ -1417,1 +1248,1 @@\n-int\n+static int\n@@ -1430,1 +1261,1 @@\n-int\n+static int\n@@ -1443,1 +1274,1 @@\n-int\n+static int\n@@ -1456,1 +1287,1 @@\n-int\n+static int\n@@ -1469,1 +1300,1 @@\n-int\n+static int\n@@ -1482,1 +1313,1 @@\n-int\n+static int\n@@ -1495,1 +1326,1 @@\n-int\n+static int\n@@ -1508,1 +1339,1 @@\n-int\n+static int\n@@ -1521,1 +1352,1 @@\n-int\n+static int\n@@ -1534,1 +1365,1 @@\n-int\n+static int\n@@ -1547,1 +1378,1 @@\n-int\n+static int\n@@ -1560,1 +1391,1 @@\n-int\n+static int\n@@ -1573,1 +1404,1 @@\n-int\n+static int\n@@ -1586,1 +1417,1 @@\n-int\n+static int\n@@ -1599,1 +1430,1 @@\n-int\n+static int\n@@ -1612,1 +1443,1 @@\n-int\n+static int\n@@ -1625,1 +1456,1 @@\n-int\n+static int\n@@ -1638,1 +1469,1 @@\n-int\n+static int\n@@ -1651,1 +1482,1 @@\n-int\n+static int\n@@ -1664,1 +1495,1 @@\n-int\n+static int\n@@ -1677,1 +1508,1 @@\n-int\n+static int\n@@ -1690,1 +1521,1 @@\n-int\n+static int\n@@ -1703,1 +1534,1 @@\n-int\n+static int\n@@ -1716,1 +1547,1 @@\n-int\n+static int\n@@ -1729,1 +1560,1 @@\n-int\n+static int\n@@ -1742,1 +1573,1 @@\n-int\n+static int\n@@ -1755,1 +1586,1 @@\n-int\n+static int\n@@ -1768,1 +1599,1 @@\n-int\n+static int\n@@ -1781,1 +1612,1 @@\n-int\n+static int\n@@ -1794,1 +1625,1 @@\n-int\n+static int\n@@ -1807,1 +1638,1 @@\n-int\n+static int\n@@ -1820,1 +1651,1 @@\n-int\n+static int\n@@ -1833,1 +1664,1 @@\n-int\n+static int\n@@ -1846,1 +1677,1 @@\n-int\n+static int\n@@ -1859,1 +1690,1 @@\n-int\n+static int\n@@ -1872,1 +1703,1 @@\n-int\n+static int\n@@ -1885,1 +1716,1 @@\n-int\n+static int\n@@ -1898,1 +1729,1 @@\n-int\n+static int\n@@ -1911,1 +1742,1 @@\n-int\n+static int\n@@ -1924,1 +1755,1 @@\n-int\n+static int\n@@ -1937,1 +1768,1 @@\n-int\n+static int\n@@ -1950,1 +1781,1 @@\n-int\n+static int\n@@ -1963,1 +1794,1 @@\n-int\n+static int\n@@ -1976,1 +1807,1 @@\n-int\n+static int\n@@ -1989,1 +1820,1 @@\n-int\n+static int\n@@ -2002,1 +1833,1 @@\n-int\n+static int\n@@ -2015,1 +1846,1 @@\n-int\n+static int\n@@ -2028,1 +1859,1 @@\n-int\n+static int\n@@ -2041,1 +1872,1 @@\n-int\n+static int\n@@ -2054,1 +1885,1 @@\n-int\n+static int\n@@ -2067,1 +1898,1 @@\n-int\n+static int\n@@ -2080,1 +1911,1 @@\n-int\n+static int\n@@ -2093,1 +1924,1 @@\n-int\n+static int\n@@ -2106,1 +1937,1 @@\n-int\n+static int\n@@ -2119,1 +1950,1 @@\n-int\n+static int\n@@ -2132,1 +1963,1 @@\n-int\n+static int\n@@ -2145,1 +1976,1 @@\n-int\n+static int\n@@ -2158,1 +1989,1 @@\n-int\n+static int\n@@ -2171,1 +2002,1 @@\n-int\n+static int\n@@ -2184,1 +2015,1 @@\n-int\n+static int\n@@ -2197,1 +2028,1 @@\n-int\n+static int\n@@ -2210,1 +2041,1 @@\n-int\n+static int\n@@ -2223,1 +2054,1 @@\n-int\n+static int\n@@ -2238,1 +2069,1 @@\n-int\n+static int\n@@ -2251,1 +2082,1 @@\n-int\n+static int\n@@ -2264,1 +2095,1 @@\n-int\n+static int\n@@ -2277,1 +2108,1 @@\n-int\n+static int\n@@ -2290,1 +2121,1 @@\n-int\n+static int\n@@ -2303,1 +2134,1 @@\n-int\n+static int\n@@ -2316,1 +2147,1 @@\n-int\n+static int\n@@ -2329,1 +2160,1 @@\n-int\n+static int\n@@ -2342,1 +2173,1 @@\n-int\n+static int\n@@ -2355,1 +2186,1 @@\n-int\n+static int\n@@ -2368,1 +2199,1 @@\n-int\n+static int\n@@ -2381,1 +2212,1 @@\n-int\n+static int\n@@ -2394,1 +2225,1 @@\n-int\n+static int\n@@ -2407,1 +2238,1 @@\n-int\n+static int\n@@ -2420,1 +2251,1 @@\n-int\n+static int\n@@ -2433,1 +2264,1 @@\n-int\n+static int\n@@ -2446,1 +2277,1 @@\n-int\n+static int\n@@ -2459,1 +2290,1 @@\n-int\n+static int\n@@ -2472,1 +2303,1 @@\n-int\n+static int\n@@ -2485,1 +2316,1 @@\n-int\n+static int\n@@ -2498,1 +2329,1 @@\n-int\n+static int\n@@ -2511,1 +2342,1 @@\n-int\n+static int\n@@ -2524,1 +2355,1 @@\n-int\n+static int\n@@ -2537,1 +2368,1 @@\n-int\n+static int\n@@ -2550,1 +2381,1 @@\n-int\n+static int\n@@ -2563,1 +2394,1 @@\n-int\n+static int\n@@ -2576,1 +2407,1 @@\n-int\n+static int\n@@ -2589,1 +2420,1 @@\n-int\n+static int\n@@ -2602,1 +2433,1 @@\n-int\n+static int\n@@ -2615,1 +2446,1 @@\n-int\n+static int\n@@ -2628,1 +2459,1 @@\n-int\n+static int\n@@ -2633,19 +2464,0 @@\n-\/**\n- * xmlUCSIsBlock:\n- * @code: UCS code point\n- * @block: UCS block name\n- *\n- * Check whether the character is part of the UCS Block\n- *\n- * Returns 1 if true, 0 if false and -1 on unknown block\n- *\/\n-int\n-xmlUCSIsBlock(int code, const char *block) {\n-    xmlIntFunc *func;\n-\n-    func = xmlUnicodeLookup(&xmlUnicodeBlockTbl, block);\n-    if (func == NULL)\n-    return (-1);\n-    return (func(code));\n-}\n-\n@@ -3158,0 +2970,189 @@\n+static const xmlUnicodeRange xmlUnicodeBlocks[] = {  {\"AegeanNumbers\", xmlUCSIsAegeanNumbers},\n+  {\"AlphabeticPresentationForms\", xmlUCSIsAlphabeticPresentationForms},\n+  {\"Arabic\", xmlUCSIsArabic},\n+  {\"ArabicPresentationForms-A\", xmlUCSIsArabicPresentationFormsA},\n+  {\"ArabicPresentationForms-B\", xmlUCSIsArabicPresentationFormsB},\n+  {\"Armenian\", xmlUCSIsArmenian},\n+  {\"Arrows\", xmlUCSIsArrows},\n+  {\"BasicLatin\", xmlUCSIsBasicLatin},\n+  {\"Bengali\", xmlUCSIsBengali},\n+  {\"BlockElements\", xmlUCSIsBlockElements},\n+  {\"Bopomofo\", xmlUCSIsBopomofo},\n+  {\"BopomofoExtended\", xmlUCSIsBopomofoExtended},\n+  {\"BoxDrawing\", xmlUCSIsBoxDrawing},\n+  {\"BraillePatterns\", xmlUCSIsBraillePatterns},\n+  {\"Buhid\", xmlUCSIsBuhid},\n+  {\"ByzantineMusicalSymbols\", xmlUCSIsByzantineMusicalSymbols},\n+  {\"CJKCompatibility\", xmlUCSIsCJKCompatibility},\n+  {\"CJKCompatibilityForms\", xmlUCSIsCJKCompatibilityForms},\n+  {\"CJKCompatibilityIdeographs\", xmlUCSIsCJKCompatibilityIdeographs},\n+  {\"CJKCompatibilityIdeographsSupplement\", xmlUCSIsCJKCompatibilityIdeographsSupplement},\n+  {\"CJKRadicalsSupplement\", xmlUCSIsCJKRadicalsSupplement},\n+  {\"CJKSymbolsandPunctuation\", xmlUCSIsCJKSymbolsandPunctuation},\n+  {\"CJKUnifiedIdeographs\", xmlUCSIsCJKUnifiedIdeographs},\n+  {\"CJKUnifiedIdeographsExtensionA\", xmlUCSIsCJKUnifiedIdeographsExtensionA},\n+  {\"CJKUnifiedIdeographsExtensionB\", xmlUCSIsCJKUnifiedIdeographsExtensionB},\n+  {\"Cherokee\", xmlUCSIsCherokee},\n+  {\"CombiningDiacriticalMarks\", xmlUCSIsCombiningDiacriticalMarks},\n+  {\"CombiningDiacriticalMarksforSymbols\", xmlUCSIsCombiningDiacriticalMarksforSymbols},\n+  {\"CombiningHalfMarks\", xmlUCSIsCombiningHalfMarks},\n+  {\"CombiningMarksforSymbols\", xmlUCSIsCombiningMarksforSymbols},\n+  {\"ControlPictures\", xmlUCSIsControlPictures},\n+  {\"CurrencySymbols\", xmlUCSIsCurrencySymbols},\n+  {\"CypriotSyllabary\", xmlUCSIsCypriotSyllabary},\n+  {\"Cyrillic\", xmlUCSIsCyrillic},\n+  {\"CyrillicSupplement\", xmlUCSIsCyrillicSupplement},\n+  {\"Deseret\", xmlUCSIsDeseret},\n+  {\"Devanagari\", xmlUCSIsDevanagari},\n+  {\"Dingbats\", xmlUCSIsDingbats},\n+  {\"EnclosedAlphanumerics\", xmlUCSIsEnclosedAlphanumerics},\n+  {\"EnclosedCJKLettersandMonths\", xmlUCSIsEnclosedCJKLettersandMonths},\n+  {\"Ethiopic\", xmlUCSIsEthiopic},\n+  {\"GeneralPunctuation\", xmlUCSIsGeneralPunctuation},\n+  {\"GeometricShapes\", xmlUCSIsGeometricShapes},\n+  {\"Georgian\", xmlUCSIsGeorgian},\n+  {\"Gothic\", xmlUCSIsGothic},\n+  {\"Greek\", xmlUCSIsGreek},\n+  {\"GreekExtended\", xmlUCSIsGreekExtended},\n+  {\"GreekandCoptic\", xmlUCSIsGreekandCoptic},\n+  {\"Gujarati\", xmlUCSIsGujarati},\n+  {\"Gurmukhi\", xmlUCSIsGurmukhi},\n+  {\"HalfwidthandFullwidthForms\", xmlUCSIsHalfwidthandFullwidthForms},\n+  {\"HangulCompatibilityJamo\", xmlUCSIsHangulCompatibilityJamo},\n+  {\"HangulJamo\", xmlUCSIsHangulJamo},\n+  {\"HangulSyllables\", xmlUCSIsHangulSyllables},\n+  {\"Hanunoo\", xmlUCSIsHanunoo},\n+  {\"Hebrew\", xmlUCSIsHebrew},\n+  {\"HighPrivateUseSurrogates\", xmlUCSIsHighPrivateUseSurrogates},\n+  {\"HighSurrogates\", xmlUCSIsHighSurrogates},\n+  {\"Hiragana\", xmlUCSIsHiragana},\n+  {\"IPAExtensions\", xmlUCSIsIPAExtensions},\n+  {\"IdeographicDescriptionCharacters\", xmlUCSIsIdeographicDescriptionCharacters},\n+  {\"Kanbun\", xmlUCSIsKanbun},\n+  {\"KangxiRadicals\", xmlUCSIsKangxiRadicals},\n+  {\"Kannada\", xmlUCSIsKannada},\n+  {\"Katakana\", xmlUCSIsKatakana},\n+  {\"KatakanaPhoneticExtensions\", xmlUCSIsKatakanaPhoneticExtensions},\n+  {\"Khmer\", xmlUCSIsKhmer},\n+  {\"KhmerSymbols\", xmlUCSIsKhmerSymbols},\n+  {\"Lao\", xmlUCSIsLao},\n+  {\"Latin-1Supplement\", xmlUCSIsLatin1Supplement},\n+  {\"LatinExtended-A\", xmlUCSIsLatinExtendedA},\n+  {\"LatinExtended-B\", xmlUCSIsLatinExtendedB},\n+  {\"LatinExtendedAdditional\", xmlUCSIsLatinExtendedAdditional},\n+  {\"LetterlikeSymbols\", xmlUCSIsLetterlikeSymbols},\n+  {\"Limbu\", xmlUCSIsLimbu},\n+  {\"LinearBIdeograms\", xmlUCSIsLinearBIdeograms},\n+  {\"LinearBSyllabary\", xmlUCSIsLinearBSyllabary},\n+  {\"LowSurrogates\", xmlUCSIsLowSurrogates},\n+  {\"Malayalam\", xmlUCSIsMalayalam},\n+  {\"MathematicalAlphanumericSymbols\", xmlUCSIsMathematicalAlphanumericSymbols},\n+  {\"MathematicalOperators\", xmlUCSIsMathematicalOperators},\n+  {\"MiscellaneousMathematicalSymbols-A\", xmlUCSIsMiscellaneousMathematicalSymbolsA},\n+  {\"MiscellaneousMathematicalSymbols-B\", xmlUCSIsMiscellaneousMathematicalSymbolsB},\n+  {\"MiscellaneousSymbols\", xmlUCSIsMiscellaneousSymbols},\n+  {\"MiscellaneousSymbolsandArrows\", xmlUCSIsMiscellaneousSymbolsandArrows},\n+  {\"MiscellaneousTechnical\", xmlUCSIsMiscellaneousTechnical},\n+  {\"Mongolian\", xmlUCSIsMongolian},\n+  {\"MusicalSymbols\", xmlUCSIsMusicalSymbols},\n+  {\"Myanmar\", xmlUCSIsMyanmar},\n+  {\"NumberForms\", xmlUCSIsNumberForms},\n+  {\"Ogham\", xmlUCSIsOgham},\n+  {\"OldItalic\", xmlUCSIsOldItalic},\n+  {\"OpticalCharacterRecognition\", xmlUCSIsOpticalCharacterRecognition},\n+  {\"Oriya\", xmlUCSIsOriya},\n+  {\"Osmanya\", xmlUCSIsOsmanya},\n+  {\"PhoneticExtensions\", xmlUCSIsPhoneticExtensions},\n+  {\"PrivateUse\", xmlUCSIsPrivateUse},\n+  {\"PrivateUseArea\", xmlUCSIsPrivateUseArea},\n+  {\"Runic\", xmlUCSIsRunic},\n+  {\"Shavian\", xmlUCSIsShavian},\n+  {\"Sinhala\", xmlUCSIsSinhala},\n+  {\"SmallFormVariants\", xmlUCSIsSmallFormVariants},\n+  {\"SpacingModifierLetters\", xmlUCSIsSpacingModifierLetters},\n+  {\"Specials\", xmlUCSIsSpecials},\n+  {\"SuperscriptsandSubscripts\", xmlUCSIsSuperscriptsandSubscripts},\n+  {\"SupplementalArrows-A\", xmlUCSIsSupplementalArrowsA},\n+  {\"SupplementalArrows-B\", xmlUCSIsSupplementalArrowsB},\n+  {\"SupplementalMathematicalOperators\", xmlUCSIsSupplementalMathematicalOperators},\n+  {\"SupplementaryPrivateUseArea-A\", xmlUCSIsSupplementaryPrivateUseAreaA},\n+  {\"SupplementaryPrivateUseArea-B\", xmlUCSIsSupplementaryPrivateUseAreaB},\n+  {\"Syriac\", xmlUCSIsSyriac},\n+  {\"Tagalog\", xmlUCSIsTagalog},\n+  {\"Tagbanwa\", xmlUCSIsTagbanwa},\n+  {\"Tags\", xmlUCSIsTags},\n+  {\"TaiLe\", xmlUCSIsTaiLe},\n+  {\"TaiXuanJingSymbols\", xmlUCSIsTaiXuanJingSymbols},\n+  {\"Tamil\", xmlUCSIsTamil},\n+  {\"Telugu\", xmlUCSIsTelugu},\n+  {\"Thaana\", xmlUCSIsThaana},\n+  {\"Thai\", xmlUCSIsThai},\n+  {\"Tibetan\", xmlUCSIsTibetan},\n+  {\"Ugaritic\", xmlUCSIsUgaritic},\n+  {\"UnifiedCanadianAboriginalSyllabics\", xmlUCSIsUnifiedCanadianAboriginalSyllabics},\n+  {\"VariationSelectors\", xmlUCSIsVariationSelectors},\n+  {\"VariationSelectorsSupplement\", xmlUCSIsVariationSelectorsSupplement},\n+  {\"YiRadicals\", xmlUCSIsYiRadicals},\n+  {\"YiSyllables\", xmlUCSIsYiSyllables},\n+  {\"YijingHexagramSymbols\", xmlUCSIsYijingHexagramSymbols}};\n+\n+static const xmlUnicodeRange xmlUnicodeCats[] = {\n+  {\"C\", xmlUCSIsCatC},\n+  {\"Cc\", xmlUCSIsCatCc},\n+  {\"Cf\", xmlUCSIsCatCf},\n+  {\"Co\", xmlUCSIsCatCo},\n+  {\"Cs\", xmlUCSIsCatCs},\n+  {\"L\", xmlUCSIsCatL},\n+  {\"Ll\", xmlUCSIsCatLl},\n+  {\"Lm\", xmlUCSIsCatLm},\n+  {\"Lo\", xmlUCSIsCatLo},\n+  {\"Lt\", xmlUCSIsCatLt},\n+  {\"Lu\", xmlUCSIsCatLu},\n+  {\"M\", xmlUCSIsCatM},\n+  {\"Mc\", xmlUCSIsCatMc},\n+  {\"Me\", xmlUCSIsCatMe},\n+  {\"Mn\", xmlUCSIsCatMn},\n+  {\"N\", xmlUCSIsCatN},\n+  {\"Nd\", xmlUCSIsCatNd},\n+  {\"Nl\", xmlUCSIsCatNl},\n+  {\"No\", xmlUCSIsCatNo},\n+  {\"P\", xmlUCSIsCatP},\n+  {\"Pc\", xmlUCSIsCatPc},\n+  {\"Pd\", xmlUCSIsCatPd},\n+  {\"Pe\", xmlUCSIsCatPe},\n+  {\"Pf\", xmlUCSIsCatPf},\n+  {\"Pi\", xmlUCSIsCatPi},\n+  {\"Po\", xmlUCSIsCatPo},\n+  {\"Ps\", xmlUCSIsCatPs},\n+  {\"S\", xmlUCSIsCatS},\n+  {\"Sc\", xmlUCSIsCatSc},\n+  {\"Sk\", xmlUCSIsCatSk},\n+  {\"Sm\", xmlUCSIsCatSm},\n+  {\"So\", xmlUCSIsCatSo},\n+  {\"Z\", xmlUCSIsCatZ},\n+  {\"Zl\", xmlUCSIsCatZl},\n+  {\"Zp\", xmlUCSIsCatZp},\n+  {\"Zs\", xmlUCSIsCatZs}};\n+\n+static const xmlUnicodeNameTable xmlUnicodeBlockTbl = {xmlUnicodeBlocks, 128};\n+static const xmlUnicodeNameTable xmlUnicodeCatTbl = {xmlUnicodeCats, 36};\n+\n+\/**\n+ * xmlUCSIsBlock:\n+ * @code: UCS code point\n+ * @block: UCS block name\n+ *\n+ * Check whether the character is part of the UCS Block\n+ *\n+ * Returns 1 if true, 0 if false and -1 on unknown block\n+ *\/\n+int\n+xmlUCSIsBlock(int code, const char *block) {\n+    xmlIntFunc *func;\n+\n+    func = xmlUnicodeLookup(&xmlUnicodeBlockTbl, block);\n+    if (func == NULL)\n+        return (-1);\n+    return (func(code));\n+}\n+\n@@ -3173,1 +3174,1 @@\n-    return (-1);\n+        return (-1);\n@@ -3177,1 +3178,1 @@\n-#endif \/* LIBXML_UNICODE_ENABLED *\/\n+#endif \/* LIBXML_REGEXP_ENABLED *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlunicode.c","additions":333,"deletions":332,"binary":false,"changes":665,"status":"modified"},{"patch":"@@ -126,8 +126,8 @@\n-    if (ctxt != NULL) {\n-    __xmlRaiseError(NULL, NULL, NULL, ctxt->ctxt,\n-                NULL, XML_FROM_WRITER, error, XML_ERR_FATAL,\n-            NULL, 0, NULL, NULL, NULL, 0, 0, \"%s\", msg);\n-    } else {\n-    __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_WRITER, error,\n-                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, \"%s\", msg);\n-    }\n+    xmlParserCtxtPtr pctxt = NULL;\n+\n+    if (ctxt != NULL)\n+        pctxt = ctxt->ctxt;\n+\n+    xmlRaiseError(NULL, NULL, NULL, pctxt,\n+                  NULL, XML_FROM_WRITER, error, XML_ERR_FATAL,\n+                  NULL, 0, NULL, NULL, NULL, 0, 0, \"%s\", msg);\n@@ -149,8 +149,8 @@\n-    if (ctxt != NULL) {\n-    __xmlRaiseError(NULL, NULL, NULL, ctxt->ctxt,\n-                NULL, XML_FROM_WRITER, error, XML_ERR_FATAL,\n-            NULL, 0, NULL, NULL, NULL, val, 0, msg, val);\n-    } else {\n-    __xmlRaiseError(NULL, NULL, NULL, NULL, NULL, XML_FROM_WRITER, error,\n-                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, val, 0, msg, val);\n-    }\n+    xmlParserCtxtPtr pctxt = NULL;\n+\n+    if (ctxt != NULL)\n+        pctxt = ctxt->ctxt;\n+\n+    xmlRaiseError(NULL, NULL, NULL, pctxt,\n+                  NULL, XML_FROM_WRITER, error, XML_ERR_FATAL,\n+                  NULL, 0, NULL, NULL, NULL, val, 0, msg, val);\n@@ -358,2 +358,0 @@\n-    saxHandler.startElement = xmlSAX2StartElement;\n-    saxHandler.endElement = xmlSAX2EndElement;\n@@ -394,1 +392,1 @@\n-    ret->no_doc_free = 1;\n+        ret->no_doc_free = 1;\n@@ -427,2 +425,0 @@\n-    saxHandler.startElement = xmlSAX2StartElement;\n-    saxHandler.endElement = xmlSAX2EndElement;\n@@ -482,3 +478,3 @@\n-        xmlFreeDoc(writer->ctxt->myDoc);\n-        writer->ctxt->myDoc = NULL;\n-    }\n+            xmlFreeDoc(writer->ctxt->myDoc);\n+            writer->ctxt->myDoc = NULL;\n+        }\n@@ -541,3 +537,3 @@\n-    if (writer->out->conv == NULL) {\n-        writer->out->conv = xmlBufCreateSize(4000);\n-    }\n+        if (writer->out->conv == NULL) {\n+            writer->out->conv = xmlBufCreate(4000);\n+        }\n@@ -970,6 +966,6 @@\n-                case XML_TEXTWRITER_ATTRIBUTE:\n-                    count = xmlTextWriterEndAttribute(writer);\n-                    if (count < 0)\n-                        return -1;\n-                    sum += count;\n-                    \/* fallthrough *\/\n+                                case XML_TEXTWRITER_ATTRIBUTE:\n+                                        count = xmlTextWriterEndAttribute(writer);\n+                                        if (count < 0)\n+                                                return -1;\n+                                        sum += count;\n+                                        \/* fallthrough *\/\n@@ -1491,4 +1487,3 @@\n-#if 0\n-                    buf = NULL;\n-            xmlOutputBufferWriteEscape(writer->out, content, NULL);\n-#endif\n+                    \/*\n+                     * TODO: Use xmlSerializeText\n+                     *\/\n@@ -1502,2 +1497,2 @@\n-        default:\n-            break;\n+                default:\n+                    break;\n@@ -1539,4 +1534,4 @@\n-         'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',\n-         'a','b','c','d','e','f','g','h','i','j','k','l','m',\n-         'n','o','p','q','r','s','t','u','v','w','x','y','z',\n-         '0','1','2','3','4','5','6','7','8','9','+','\/'};\n+             'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',\n+             'a','b','c','d','e','f','g','h','i','j','k','l','m',\n+             'n','o','p','q','r','s','t','u','v','w','x','y','z',\n+             '0','1','2','3','4','5','6','7','8','9','+','\/'};\n@@ -1671,1 +1666,1 @@\n-    {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n+        {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};\n@@ -1866,1 +1861,1 @@\n-                                        \"xmlTextWriterStartAttributeNS : out of memory!\\n\");\n+                                                                        \"xmlTextWriterStartAttributeNS : out of memory!\\n\");\n@@ -2233,4 +2228,4 @@\n-    count = xmlTextWriterWriteString(writer, content);\n-    if (count == -1)\n-        return -1;\n-    sum += count;\n+        count = xmlTextWriterWriteString(writer, content);\n+        if (count == -1)\n+            return -1;\n+        sum += count;\n@@ -2496,2 +2491,2 @@\n-    if (count < 0)\n-    return -1;\n+        if (count < 0)\n+        return -1;\n@@ -2625,1 +2620,1 @@\n-        case XML_TEXTWRITER_TEXT:\n+                case XML_TEXTWRITER_TEXT:\n@@ -2921,1 +2916,1 @@\n-            if (writer->indent)\n+                        if (writer->indent)\n@@ -4446,1 +4441,2 @@\n-    if ((rc = xmlParseChunk(ctxt, str, len, 0)) != 0) {\n+    rc = xmlParseChunk(ctxt, str, len, 0);\n+    if (rc != 0) {\n@@ -4470,1 +4466,2 @@\n-    if ((rc = xmlParseChunk(ctxt, NULL, 0, 1)) != 0) {\n+    rc = xmlParseChunk(ctxt, NULL, 0, 1);\n+    if (rc != 0) {\n@@ -4508,1 +4505,1 @@\n-    va_end(locarg);\n+        va_end(locarg);\n@@ -4517,1 +4514,1 @@\n-    va_copy(locarg, argptr);\n+        va_copy(locarg, argptr);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xmlwriter.c","additions":54,"deletions":57,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -38,3 +38,0 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-#include <libxml\/xpointer.h>\n-#endif\n@@ -52,0 +49,1 @@\n+#include \"private\/memory.h\"\n@@ -137,1 +135,1 @@\n-#if defined(LIBXML_XPATH_ENABLED) || defined(LIBXML_SCHEMAS_ENABLED)\n+#if defined(LIBXML_XPATH_ENABLED)\n@@ -139,5 +137,42 @@\n-\/************************************************************************\n- *                                    *\n- *            Floating point stuff                *\n- *                                    *\n- ************************************************************************\/\n+static void\n+xmlXPathNameFunction(xmlXPathParserContextPtr ctxt, int nargs);\n+\n+static const struct {\n+    const char *name;\n+    xmlXPathFunction func;\n+} xmlXPathStandardFunctions[] = {\n+    { \"boolean\", xmlXPathBooleanFunction },\n+    { \"ceiling\", xmlXPathCeilingFunction },\n+    { \"count\", xmlXPathCountFunction },\n+    { \"concat\", xmlXPathConcatFunction },\n+    { \"contains\", xmlXPathContainsFunction },\n+    { \"id\", xmlXPathIdFunction },\n+    { \"false\", xmlXPathFalseFunction },\n+    { \"floor\", xmlXPathFloorFunction },\n+    { \"last\", xmlXPathLastFunction },\n+    { \"lang\", xmlXPathLangFunction },\n+    { \"local-name\", xmlXPathLocalNameFunction },\n+    { \"not\", xmlXPathNotFunction },\n+    { \"name\", xmlXPathNameFunction },\n+    { \"namespace-uri\", xmlXPathNamespaceURIFunction },\n+    { \"normalize-space\", xmlXPathNormalizeFunction },\n+    { \"number\", xmlXPathNumberFunction },\n+    { \"position\", xmlXPathPositionFunction },\n+    { \"round\", xmlXPathRoundFunction },\n+    { \"string\", xmlXPathStringFunction },\n+    { \"string-length\", xmlXPathStringLengthFunction },\n+    { \"starts-with\", xmlXPathStartsWithFunction },\n+    { \"substring\", xmlXPathSubstringFunction },\n+    { \"substring-before\", xmlXPathSubstringBeforeFunction },\n+    { \"substring-after\", xmlXPathSubstringAfterFunction },\n+    { \"sum\", xmlXPathSumFunction },\n+    { \"true\", xmlXPathTrueFunction },\n+    { \"translate\", xmlXPathTranslateFunction }\n+};\n+\n+#define NUM_STANDARD_FUNCTIONS \\\n+    (sizeof(xmlXPathStandardFunctions) \/ sizeof(xmlXPathStandardFunctions[0]))\n+\n+#define SF_HASH_SIZE 64\n+\n+static unsigned char xmlXPathSFHash[SF_HASH_SIZE];\n@@ -159,0 +194,12 @@\n+ATTRIBUTE_NO_SANITIZE_INTEGER\n+static unsigned\n+xmlXPathSFComputeHash(const xmlChar *name) {\n+    unsigned hashValue = 5381;\n+    const xmlChar *ptr;\n+\n+    for (ptr = name; *ptr; ptr++)\n+        hashValue = hashValue * 33 + *ptr;\n+\n+    return(hashValue);\n+}\n+\n@@ -167,0 +214,2 @@\n+    size_t i;\n+\n@@ -178,0 +227,20 @@\n+\n+    \/*\n+     * Initialize hash table for standard functions\n+     *\/\n+\n+    for (i = 0; i < SF_HASH_SIZE; i++)\n+        xmlXPathSFHash[i] = UCHAR_MAX;\n+\n+    for (i = 0; i < NUM_STANDARD_FUNCTIONS; i++) {\n+        const char *name = xmlXPathStandardFunctions[i].name;\n+        int bucketIndex = xmlXPathSFComputeHash(BAD_CAST name) % SF_HASH_SIZE;\n+\n+        while (xmlXPathSFHash[bucketIndex] != UCHAR_MAX) {\n+            bucketIndex += 1;\n+            if (bucketIndex >= SF_HASH_SIZE)\n+                bucketIndex = 0;\n+        }\n+\n+        xmlXPathSFHash[bucketIndex] = i;\n+    }\n@@ -180,0 +249,6 @@\n+\/************************************************************************\n+ *                                                                      *\n+ *                      Floating point stuff                            *\n+ *                                                                      *\n+ ************************************************************************\/\n+\n@@ -218,4 +293,0 @@\n-#endif \/* SCHEMAS or XPATH *\/\n-\n-#ifdef LIBXML_XPATH_ENABLED\n-\n@@ -236,7 +307,0 @@\n-#ifndef LIBXML_THREAD_ENABLED\n-\/*\n- * Optimizer is disabled only when threaded apps are detected while\n- * the library ain't compiled for thread safety.\n- *\/\n-static int xmlXPathDisableOptimizer = 0;\n-#endif\n@@ -247,0 +311,2 @@\n+#define XML_NODE_SORT_VALUE(n) XML_PTR_TO_INT((n)->content)\n+\n@@ -248,0 +314,1 @@\n+\n@@ -265,1 +332,1 @@\n-    ptrdiff_t l1, l2;\n+    XML_INTPTR_T l1, l2;\n@@ -268,1 +335,1 @@\n-    return(-2);\n+        return(-2);\n@@ -271,1 +338,1 @@\n-    return(0);\n+        return(0);\n@@ -277,36 +344,14 @@\n-    case XML_ELEMENT_NODE:\n-        if (node2->type == XML_ELEMENT_NODE) {\n-        if ((0 > (ptrdiff_t) node1->content) &&\n-            (0 > (ptrdiff_t) node2->content) &&\n-            (node1->doc == node2->doc))\n-        {\n-            l1 = -((ptrdiff_t) node1->content);\n-            l2 = -((ptrdiff_t) node2->content);\n-            if (l1 < l2)\n-            return(1);\n-            if (l1 > l2)\n-            return(-1);\n-        } else\n-            goto turtle_comparison;\n-        }\n-        break;\n-    case XML_ATTRIBUTE_NODE:\n-        precedence1 = 1; \/* element is owner *\/\n-        miscNode1 = node1;\n-        node1 = node1->parent;\n-        misc = 1;\n-        break;\n-    case XML_TEXT_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_COMMENT_NODE:\n-    case XML_PI_NODE: {\n-        miscNode1 = node1;\n-        \/*\n-        * Find nearest element node.\n-        *\/\n-        if (node1->prev != NULL) {\n-        do {\n-            node1 = node1->prev;\n-            if (node1->type == XML_ELEMENT_NODE) {\n-            precedence1 = 3; \/* element in prev-sibl axis *\/\n-            break;\n+        case XML_ELEMENT_NODE:\n+            if (node2->type == XML_ELEMENT_NODE) {\n+                if ((0 > XML_NODE_SORT_VALUE(node1)) &&\n+                    (0 > XML_NODE_SORT_VALUE(node2)) &&\n+                    (node1->doc == node2->doc))\n+                {\n+                    l1 = -XML_NODE_SORT_VALUE(node1);\n+                    l2 = -XML_NODE_SORT_VALUE(node2);\n+                    if (l1 < l2)\n+                        return(1);\n+                    if (l1 > l2)\n+                        return(-1);\n+                } else\n+                    goto turtle_comparison;\n@@ -314,6 +359,4 @@\n-            if (node1->prev == NULL) {\n-            precedence1 = 2; \/* element is parent *\/\n-            \/*\n-            * URGENT TODO: Are there any cases, where the\n-            * parent of such a node is not an element node?\n-            *\/\n+            break;\n+        case XML_ATTRIBUTE_NODE:\n+            precedence1 = 1; \/* element is owner *\/\n+            miscNode1 = node1;\n@@ -321,0 +364,1 @@\n+            misc = 1;\n@@ -322,0 +366,28 @@\n+        case XML_TEXT_NODE:\n+        case XML_CDATA_SECTION_NODE:\n+        case XML_COMMENT_NODE:\n+        case XML_PI_NODE: {\n+            miscNode1 = node1;\n+            \/*\n+            * Find nearest element node.\n+            *\/\n+            if (node1->prev != NULL) {\n+                do {\n+                    node1 = node1->prev;\n+                    if (node1->type == XML_ELEMENT_NODE) {\n+                        precedence1 = 3; \/* element in prev-sibl axis *\/\n+                        break;\n+                    }\n+                    if (node1->prev == NULL) {\n+                        precedence1 = 2; \/* element is parent *\/\n+                        \/*\n+                        * URGENT TODO: Are there any cases, where the\n+                        * parent of such a node is not an element node?\n+                        *\/\n+                        node1 = node1->parent;\n+                        break;\n+                    }\n+                } while (1);\n+            } else {\n+                precedence1 = 2; \/* element is parent *\/\n+                node1 = node1->parent;\n@@ -323,4 +395,9 @@\n-        } while (1);\n-        } else {\n-        precedence1 = 2; \/* element is parent *\/\n-        node1 = node1->parent;\n+            if ((node1 == NULL) || (node1->type != XML_ELEMENT_NODE) ||\n+                (0 <= XML_NODE_SORT_VALUE(node1))) {\n+                \/*\n+                * Fallback for whatever case.\n+                *\/\n+                node1 = miscNode1;\n+                precedence1 = 0;\n+            } else\n+                misc = 1;\n@@ -328,18 +405,8 @@\n-        if ((node1 == NULL) || (node1->type != XML_ELEMENT_NODE) ||\n-        (0 <= (ptrdiff_t) node1->content)) {\n-        \/*\n-        * Fallback for whatever case.\n-        *\/\n-        node1 = miscNode1;\n-        precedence1 = 0;\n-        } else\n-        misc = 1;\n-    }\n-        break;\n-    case XML_NAMESPACE_DECL:\n-        \/*\n-        * TODO: why do we return 1 for namespace nodes?\n-        *\/\n-        return(1);\n-    default:\n-        break;\n+            break;\n+        case XML_NAMESPACE_DECL:\n+            \/*\n+            * TODO: why do we return 1 for namespace nodes?\n+            *\/\n+            return(1);\n+        default:\n+            break;\n@@ -348,18 +415,1 @@\n-    case XML_ELEMENT_NODE:\n-        break;\n-    case XML_ATTRIBUTE_NODE:\n-        precedence2 = 1; \/* element is owner *\/\n-        miscNode2 = node2;\n-        node2 = node2->parent;\n-        misc = 1;\n-        break;\n-    case XML_TEXT_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_COMMENT_NODE:\n-    case XML_PI_NODE: {\n-        miscNode2 = node2;\n-        if (node2->prev != NULL) {\n-        do {\n-            node2 = node2->prev;\n-            if (node2->type == XML_ELEMENT_NODE) {\n-            precedence2 = 3; \/* element in prev-sibl axis *\/\n+        case XML_ELEMENT_NODE:\n@@ -367,3 +417,3 @@\n-            }\n-            if (node2->prev == NULL) {\n-            precedence2 = 2; \/* element is parent *\/\n+        case XML_ATTRIBUTE_NODE:\n+            precedence2 = 1; \/* element is owner *\/\n+            miscNode2 = node2;\n@@ -371,0 +421,1 @@\n+            misc = 1;\n@@ -372,0 +423,21 @@\n+        case XML_TEXT_NODE:\n+        case XML_CDATA_SECTION_NODE:\n+        case XML_COMMENT_NODE:\n+        case XML_PI_NODE: {\n+            miscNode2 = node2;\n+            if (node2->prev != NULL) {\n+                do {\n+                    node2 = node2->prev;\n+                    if (node2->type == XML_ELEMENT_NODE) {\n+                        precedence2 = 3; \/* element in prev-sibl axis *\/\n+                        break;\n+                    }\n+                    if (node2->prev == NULL) {\n+                        precedence2 = 2; \/* element is parent *\/\n+                        node2 = node2->parent;\n+                        break;\n+                    }\n+                } while (1);\n+            } else {\n+                precedence2 = 2; \/* element is parent *\/\n+                node2 = node2->parent;\n@@ -373,4 +445,7 @@\n-        } while (1);\n-        } else {\n-        precedence2 = 2; \/* element is parent *\/\n-        node2 = node2->parent;\n+            if ((node2 == NULL) || (node2->type != XML_ELEMENT_NODE) ||\n+                (0 <= XML_NODE_SORT_VALUE(node2)))\n+            {\n+                node2 = miscNode2;\n+                precedence2 = 0;\n+            } else\n+                misc = 1;\n@@ -378,13 +453,5 @@\n-        if ((node2 == NULL) || (node2->type != XML_ELEMENT_NODE) ||\n-        (0 <= (ptrdiff_t) node2->content))\n-        {\n-        node2 = miscNode2;\n-        precedence2 = 0;\n-        } else\n-        misc = 1;\n-    }\n-        break;\n-    case XML_NAMESPACE_DECL:\n-        return(1);\n-    default:\n-        break;\n+            break;\n+        case XML_NAMESPACE_DECL:\n+            return(1);\n+        default:\n+            break;\n@@ -393,13 +460,26 @@\n-    if (node1 == node2) {\n-        if (precedence1 == precedence2) {\n-        \/*\n-        * The ugly case; but normally there aren't many\n-        * adjacent non-element nodes around.\n-        *\/\n-        cur = miscNode2->prev;\n-        while (cur != NULL) {\n-            if (cur == miscNode1)\n-            return(1);\n-            if (cur->type == XML_ELEMENT_NODE)\n-            return(-1);\n-            cur = cur->prev;\n+        if (node1 == node2) {\n+            if (precedence1 == precedence2) {\n+                \/*\n+                * The ugly case; but normally there aren't many\n+                * adjacent non-element nodes around.\n+                *\/\n+                cur = miscNode2->prev;\n+                while (cur != NULL) {\n+                    if (cur == miscNode1)\n+                        return(1);\n+                    if (cur->type == XML_ELEMENT_NODE)\n+                        return(-1);\n+                    cur = cur->prev;\n+                }\n+                return (-1);\n+            } else {\n+                \/*\n+                * Evaluate based on higher precedence wrt to the element.\n+                * TODO: This assumes attributes are sorted before content.\n+                *   Is this 100% correct?\n+                *\/\n+                if (precedence1 < precedence2)\n+                    return(1);\n+                else\n+                    return(-1);\n+            }\n@@ -407,2 +487,0 @@\n-        return (-1);\n-        } else {\n@@ -410,3 +488,7 @@\n-        * Evaluate based on higher precedence wrt to the element.\n-        * TODO: This assumes attributes are sorted before content.\n-        *   Is this 100% correct?\n+        * Special case: One of the helper-elements is contained by the other.\n+        * <foo>\n+        *   <node2>\n+        *     <node1>Text-1(precedence1 == 2)<\/node1>\n+        *   <\/node2>\n+        *   Text-6(precedence2 == 3)\n+        * <\/foo>\n@@ -414,21 +496,7 @@\n-        if (precedence1 < precedence2)\n-            return(1);\n-        else\n-            return(-1);\n-        }\n-    }\n-    \/*\n-    * Special case: One of the helper-elements is contained by the other.\n-    * <foo>\n-    *   <node2>\n-    *     <node1>Text-1(precedence1 == 2)<\/node1>\n-    *   <\/node2>\n-    *   Text-6(precedence2 == 3)\n-    * <\/foo>\n-    *\/\n-    if ((precedence2 == 3) && (precedence1 > 1)) {\n-        cur = node1->parent;\n-        while (cur) {\n-        if (cur == node2)\n-            return(1);\n-        cur = cur->parent;\n+        if ((precedence2 == 3) && (precedence1 > 1)) {\n+            cur = node1->parent;\n+            while (cur) {\n+                if (cur == node2)\n+                    return(1);\n+                cur = cur->parent;\n+            }\n@@ -436,7 +504,7 @@\n-    }\n-    if ((precedence1 == 3) && (precedence2 > 1)) {\n-        cur = node2->parent;\n-        while (cur) {\n-        if (cur == node1)\n-            return(-1);\n-        cur = cur->parent;\n+        if ((precedence1 == 3) && (precedence2 > 1)) {\n+            cur = node2->parent;\n+            while (cur) {\n+                if (cur == node1)\n+                    return(-1);\n+                cur = cur->parent;\n+            }\n@@ -445,1 +513,0 @@\n-    }\n@@ -451,11 +518,11 @@\n-    (node2->type == XML_ELEMENT_NODE) &&\n-    (0 > (ptrdiff_t) node1->content) &&\n-    (0 > (ptrdiff_t) node2->content) &&\n-    (node1->doc == node2->doc)) {\n-\n-    l1 = -((ptrdiff_t) node1->content);\n-    l2 = -((ptrdiff_t) node2->content);\n-    if (l1 < l2)\n-        return(1);\n-    if (l1 > l2)\n-        return(-1);\n+        (node2->type == XML_ELEMENT_NODE) &&\n+        (0 > XML_NODE_SORT_VALUE(node1)) &&\n+        (0 > XML_NODE_SORT_VALUE(node2)) &&\n+        (node1->doc == node2->doc)) {\n+\n+        l1 = -XML_NODE_SORT_VALUE(node1);\n+        l2 = -XML_NODE_SORT_VALUE(node2);\n+        if (l1 < l2)\n+            return(1);\n+        if (l1 > l2)\n+            return(-1);\n@@ -467,1 +534,1 @@\n-    return(1);\n+        return(1);\n@@ -469,1 +536,1 @@\n-    return(-1);\n+        return(-1);\n@@ -474,3 +541,3 @@\n-    if (cur->parent == node1)\n-        return(1);\n-    depth2++;\n+        if (cur->parent == node1)\n+            return(1);\n+        depth2++;\n@@ -480,3 +547,3 @@\n-    if (cur->parent == node2)\n-        return(-1);\n-    depth1++;\n+        if (cur->parent == node2)\n+            return(-1);\n+        depth1++;\n@@ -488,1 +555,1 @@\n-    return(-2);\n+        return(-2);\n@@ -494,2 +561,2 @@\n-    depth1--;\n-    node1 = node1->parent;\n+        depth1--;\n+        node1 = node1->parent;\n@@ -498,2 +565,2 @@\n-    depth2--;\n-    node2 = node2->parent;\n+        depth2--;\n+        node2 = node2->parent;\n@@ -502,5 +569,5 @@\n-    node1 = node1->parent;\n-    node2 = node2->parent;\n-    \/* should not happen but just in case ... *\/\n-    if ((node1 == NULL) || (node2 == NULL))\n-        return(-2);\n+        node1 = node1->parent;\n+        node2 = node2->parent;\n+        \/* should not happen but just in case ... *\/\n+        if ((node1 == NULL) || (node2 == NULL))\n+            return(-2);\n@@ -512,1 +579,1 @@\n-    return(1);\n+        return(1);\n@@ -514,1 +581,1 @@\n-    return(-1);\n+        return(-1);\n@@ -519,11 +586,11 @@\n-    (node2->type == XML_ELEMENT_NODE) &&\n-    (0 > (ptrdiff_t) node1->content) &&\n-    (0 > (ptrdiff_t) node2->content) &&\n-    (node1->doc == node2->doc)) {\n-\n-    l1 = -((ptrdiff_t) node1->content);\n-    l2 = -((ptrdiff_t) node2->content);\n-    if (l1 < l2)\n-        return(1);\n-    if (l1 > l2)\n-        return(-1);\n+        (node2->type == XML_ELEMENT_NODE) &&\n+        (0 > XML_NODE_SORT_VALUE(node1)) &&\n+        (0 > XML_NODE_SORT_VALUE(node2)) &&\n+        (node1->doc == node2->doc)) {\n+\n+        l1 = -XML_NODE_SORT_VALUE(node1);\n+        l2 = -XML_NODE_SORT_VALUE(node2);\n+        if (l1 < l2)\n+            return(1);\n+        if (l1 > l2)\n+            return(-1);\n@@ -533,2 +600,2 @@\n-    if (cur == node2)\n-        return(1);\n+        if (cur == node2)\n+            return(1);\n@@ -575,3 +642,3 @@\n- *                                    *\n- *            Error handling routines                *\n- *                                    *\n+ *                                                                      *\n+ *                      Error handling routines                         *\n+ *                                                                      *\n@@ -586,1 +653,1 @@\n-#define XP_ERRORNULL(X)                            \\\n+#define XP_ERRORNULL(X)                                                 \\\n@@ -620,1 +687,1 @@\n-    \"?? Unknown error ??\\n\"    \/* Must be last in the list! *\/\n+    \"?? Unknown error ??\\n\"     \/* Must be last in the list! *\/\n@@ -622,2 +689,2 @@\n-#define MAXERRNO ((int)(sizeof(xmlXPathErrorMessages) \/    \\\n-           sizeof(xmlXPathErrorMessages[0])) - 1)\n+#define MAXERRNO ((int)(sizeof(xmlXPathErrorMessages) \/ \\\n+                   sizeof(xmlXPathErrorMessages[0])) - 1)\n@@ -673,1 +740,1 @@\n-    code = MAXERRNO;\n+        code = MAXERRNO;\n@@ -713,6 +780,6 @@\n-    res = __xmlRaiseError(schannel, channel, data, NULL, node, XML_FROM_XPATH,\n-                          code + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,\n-                          XML_ERR_ERROR, NULL, 0,\n-                          (const char *) ctxt->base, NULL, NULL,\n-                          ctxt->cur - ctxt->base, 0,\n-                          \"%s\", xmlXPathErrorMessages[code]);\n+    res = xmlRaiseError(schannel, channel, data, NULL, node, XML_FROM_XPATH,\n+                        code + XML_XPATH_EXPRESSION_OK - XPATH_EXPRESSION_OK,\n+                        XML_ERR_ERROR, NULL, 0,\n+                        (const char *) ctxt->base, NULL, NULL,\n+                        ctxt->cur - ctxt->base, 0,\n+                        \"%s\", xmlXPathErrorMessages[code]);\n@@ -765,3 +832,3 @@\n- *                                    *\n- *            Parser Types                    *\n- *                                    *\n+ *                                                                      *\n+ *                      Parser Types                                    *\n+ *                                                                      *\n@@ -793,3 +860,0 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    ,XPATH_OP_RANGETO\n-#endif\n@@ -833,3 +897,3 @@\n-    xmlXPathOp op;        \/* The identifier of the operation *\/\n-    int ch1;            \/* First child *\/\n-    int ch2;            \/* Second child *\/\n+    xmlXPathOp op;              \/* The identifier of the operation *\/\n+    int ch1;                    \/* First child *\/\n+    int ch2;                    \/* Second child *\/\n@@ -846,6 +910,6 @@\n-    int nbStep;            \/* Number of steps in this expression *\/\n-    int maxStep;        \/* Maximum number of steps allocated *\/\n-    xmlXPathStepOp *steps;    \/* ops for computation of this expression *\/\n-    int last;            \/* index of last step in expression *\/\n-    xmlChar *expr;        \/* the expression being computed *\/\n-    xmlDictPtr dict;        \/* the dictionary to use if any *\/\n+    int nbStep;                 \/* Number of steps in this expression *\/\n+    int maxStep;                \/* Maximum number of steps allocated *\/\n+    xmlXPathStepOp *steps;      \/* ops for computation of this expression *\/\n+    int last;                   \/* index of last step in expression *\/\n+    xmlChar *expr;              \/* the expression being computed *\/\n+    xmlDictPtr dict;            \/* the dictionary to use if any *\/\n@@ -858,3 +922,3 @@\n- *                                    *\n- *            Forward declarations                *\n- *                                    *\n+ *                                                                      *\n+ *                      Forward declarations                            *\n+ *                                                                      *\n@@ -870,2 +934,2 @@\n-                xmlXPathStepOpPtr op,\n-                int isPredicate);\n+                            xmlXPathStepOpPtr op,\n+                            int isPredicate);\n@@ -876,3 +940,3 @@\n- *                                    *\n- *            Parser Type functions                *\n- *                                    *\n+ *                                                                      *\n+ *                      Parser Type functions                           *\n+ *                                                                      *\n@@ -894,1 +958,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -896,0 +960,3 @@\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+    cur->maxStep = 1;\n+#else\n@@ -897,0 +964,1 @@\n+#endif\n@@ -899,1 +967,1 @@\n-                                       sizeof(xmlXPathStepOp));\n+                                           sizeof(xmlXPathStepOp));\n@@ -901,2 +969,2 @@\n-    xmlFree(cur);\n-    return(NULL);\n+        xmlFree(cur);\n+        return(NULL);\n@@ -924,7 +992,10 @@\n-    for (i = 0; i < comp->nbStep; i++) {\n-        op = &comp->steps[i];\n-        if (op->value4 != NULL) {\n-        if (op->op == XPATH_OP_VALUE)\n-            xmlXPathFreeObject(op->value4);\n-        else\n-            xmlFree(op->value4);\n+        for (i = 0; i < comp->nbStep; i++) {\n+            op = &comp->steps[i];\n+            if (op->value4 != NULL) {\n+                if (op->op == XPATH_OP_VALUE)\n+                    xmlXPathFreeObject(op->value4);\n+                else\n+                    xmlFree(op->value4);\n+            }\n+            if (op->value5 != NULL)\n+                xmlFree(op->value5);\n@@ -932,3 +1003,0 @@\n-        if (op->value5 != NULL)\n-        xmlFree(op->value5);\n-    }\n@@ -936,5 +1004,6 @@\n-    for (i = 0; i < comp->nbStep; i++) {\n-        op = &comp->steps[i];\n-        if (op->value4 != NULL) {\n-        if (op->op == XPATH_OP_VALUE)\n-            xmlXPathFreeObject(op->value4);\n+        for (i = 0; i < comp->nbStep; i++) {\n+            op = &comp->steps[i];\n+            if (op->value4 != NULL) {\n+                if (op->op == XPATH_OP_VALUE)\n+                    xmlXPathFreeObject(op->value4);\n+            }\n@@ -942,1 +1011,0 @@\n-    }\n@@ -982,1 +1050,2 @@\n-    xmlXPathStepOp *real;\n+        xmlXPathStepOp *real;\n+        int newSize;\n@@ -984,3 +1053,5 @@\n-        if (comp->maxStep >= XPATH_MAX_STEPS) {\n-        xmlXPathPErrMemory(ctxt);\n-        return(-1);\n+        newSize = xmlGrowCapacity(comp->maxStep, sizeof(real[0]),\n+                                  10, XPATH_MAX_STEPS);\n+        if (newSize < 0) {\n+            xmlXPathPErrMemory(ctxt);\n+            return(-1);\n@@ -988,9 +1059,7 @@\n-    comp->maxStep *= 2;\n-    real = (xmlXPathStepOp *) xmlRealloc(comp->steps,\n-                              comp->maxStep * sizeof(xmlXPathStepOp));\n-    if (real == NULL) {\n-        comp->maxStep \/= 2;\n-        xmlXPathPErrMemory(ctxt);\n-        return(-1);\n-    }\n-    comp->steps = real;\n+        real = xmlRealloc(comp->steps, newSize * sizeof(real[0]));\n+        if (real == NULL) {\n+            xmlXPathPErrMemory(ctxt);\n+            return(-1);\n+        }\n+        comp->steps = real;\n+        comp->maxStep = newSize;\n@@ -1007,1 +1076,1 @@\n-     (op == XPATH_OP_COLLECT))) {\n+         (op == XPATH_OP_COLLECT))) {\n@@ -1009,5 +1078,5 @@\n-        comp->steps[comp->nbStep].value4 = (xmlChar *)\n-            (void *)xmlDictLookup(comp->dict, value4, -1);\n-        xmlFree(value4);\n-    } else\n-        comp->steps[comp->nbStep].value4 = NULL;\n+            comp->steps[comp->nbStep].value4 = (xmlChar *)\n+                (void *)xmlDictLookup(comp->dict, value4, -1);\n+            xmlFree(value4);\n+        } else\n+            comp->steps[comp->nbStep].value4 = NULL;\n@@ -1015,5 +1084,5 @@\n-        comp->steps[comp->nbStep].value5 = (xmlChar *)\n-            (void *)xmlDictLookup(comp->dict, value5, -1);\n-        xmlFree(value5);\n-    } else\n-        comp->steps[comp->nbStep].value5 = NULL;\n+            comp->steps[comp->nbStep].value5 = (xmlChar *)\n+                (void *)xmlDictLookup(comp->dict, value5, -1);\n+            xmlFree(value5);\n+        } else\n+            comp->steps[comp->nbStep].value5 = NULL;\n@@ -1021,2 +1090,2 @@\n-    comp->steps[comp->nbStep].value4 = value4;\n-    comp->steps[comp->nbStep].value5 = value5;\n+        comp->steps[comp->nbStep].value4 = value4;\n+        comp->steps[comp->nbStep].value5 = value5;\n@@ -1028,32 +1097,6 @@\n-\/**\n- * xmlXPathCompSwap:\n- * @comp:  the compiled expression\n- * @op: operation index\n- *\n- * Swaps 2 operations in the compiled expression\n- *\/\n-static void\n-xmlXPathCompSwap(xmlXPathStepOpPtr op) {\n-    int tmp;\n-\n-#ifndef LIBXML_THREAD_ENABLED\n-    \/*\n-     * Since this manipulates possibly shared variables, this is\n-     * disabled if one detects that the library is used in a multithreaded\n-     * application\n-     *\/\n-    if (xmlXPathDisableOptimizer)\n-    return;\n-#endif\n-\n-    tmp = op->ch1;\n-    op->ch1 = op->ch2;\n-    op->ch2 = tmp;\n-}\n-\n-#define PUSH_FULL_EXPR(op, op1, op2, val, val2, val3, val4, val5)    \\\n-    xmlXPathCompExprAdd(ctxt, (op1), (op2),            \\\n-                    (op), (val), (val2), (val3), (val4), (val5))\n-#define PUSH_LONG_EXPR(op, val, val2, val3, val4, val5)            \\\n-    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,        \\\n-                    (op), (val), (val2), (val3), (val4), (val5))\n+#define PUSH_FULL_EXPR(op, op1, op2, val, val2, val3, val4, val5)       \\\n+    xmlXPathCompExprAdd(ctxt, (op1), (op2),                     \\\n+                        (op), (val), (val2), (val3), (val4), (val5))\n+#define PUSH_LONG_EXPR(op, val, val2, val3, val4, val5)                 \\\n+    xmlXPathCompExprAdd(ctxt, ctxt->comp->last, -1,             \\\n+                        (op), (val), (val2), (val3), (val4), (val5))\n@@ -1061,1 +1104,1 @@\n-#define PUSH_LEAVE_EXPR(op, val, val2)                    \\\n+#define PUSH_LEAVE_EXPR(op, val, val2)                                  \\\n@@ -1064,1 +1107,1 @@\n-#define PUSH_UNARY_EXPR(op, ch, val, val2)                \\\n+#define PUSH_UNARY_EXPR(op, ch, val, val2)                              \\\n@@ -1067,3 +1110,3 @@\n-#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)            \\\n-xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),            \\\n-            (val), (val2), 0 ,NULL ,NULL)\n+#define PUSH_BINARY_EXPR(op, ch1, ch2, val, val2)                       \\\n+xmlXPathCompExprAdd(ctxt, (ch1), (ch2), (op),                   \\\n+                        (val), (val2), 0 ,NULL ,NULL)\n@@ -1072,3 +1115,3 @@\n- *                                    *\n- *        XPath object cache structures                *\n- *                                    *\n+ *                                                                      *\n+ *              XPath object cache structures                           *\n+ *                                                                      *\n@@ -1091,3 +1134,3 @@\n- *                                    *\n- *        Debugging related functions                *\n- *                                    *\n+ *                                                                      *\n+ *              Debugging related functions                             *\n+ *                                                                      *\n@@ -1106,3 +1149,3 @@\n-    fprintf(output, \"%s\", shift);\n-    fprintf(output, \"Node is NULL !\\n\");\n-    return;\n+        fprintf(output, \"%s\", shift);\n+        fprintf(output, \"Node is NULL !\\n\");\n+        return;\n@@ -1113,3 +1156,3 @@\n-         (cur->type == XML_HTML_DOCUMENT_NODE)) {\n-    fprintf(output, \"%s\", shift);\n-    fprintf(output, \" \/\\n\");\n+             (cur->type == XML_HTML_DOCUMENT_NODE)) {\n+        fprintf(output, \"%s\", shift);\n+        fprintf(output, \" \/\\n\");\n@@ -1117,1 +1160,1 @@\n-    xmlDebugDumpAttr(output, (xmlAttrPtr)cur, depth);\n+        xmlDebugDumpAttr(output, (xmlAttrPtr)cur, depth);\n@@ -1119,1 +1162,1 @@\n-    xmlDebugDumpOneNode(output, cur, depth);\n+        xmlDebugDumpOneNode(output, cur, depth);\n@@ -1131,3 +1174,3 @@\n-    fprintf(output, \"%s\", shift);\n-    fprintf(output, \"Node is NULL !\\n\");\n-    return;\n+        fprintf(output, \"%s\", shift);\n+        fprintf(output, \"Node is NULL !\\n\");\n+        return;\n@@ -1138,3 +1181,3 @@\n-    tmp = cur;\n-    cur = cur->next;\n-    xmlDebugDumpOneNode(output, tmp, depth);\n+        tmp = cur;\n+        cur = cur->next;\n+        xmlDebugDumpOneNode(output, tmp, depth);\n@@ -1154,3 +1197,3 @@\n-    fprintf(output, \"%s\", shift);\n-    fprintf(output, \"NodeSet is NULL !\\n\");\n-    return;\n+        fprintf(output, \"%s\", shift);\n+        fprintf(output, \"NodeSet is NULL !\\n\");\n+        return;\n@@ -1161,6 +1204,6 @@\n-    fprintf(output, \"Set contains %d nodes:\\n\", cur->nodeNr);\n-    for (i = 0;i < cur->nodeNr;i++) {\n-        fprintf(output, \"%s\", shift);\n-        fprintf(output, \"%d\", i + 1);\n-        xmlXPathDebugDumpNode(output, cur->nodeTab[i], depth + 1);\n-    }\n+        fprintf(output, \"Set contains %d nodes:\\n\", cur->nodeNr);\n+        for (i = 0;i < cur->nodeNr;i++) {\n+            fprintf(output, \"%s\", shift);\n+            fprintf(output, \"%d\", i + 1);\n+            xmlXPathDebugDumpNode(output, cur->nodeTab[i], depth + 1);\n+        }\n@@ -1180,3 +1223,3 @@\n-    fprintf(output, \"%s\", shift);\n-    fprintf(output, \"Value Tree is NULL !\\n\");\n-    return;\n+        fprintf(output, \"%s\", shift);\n+        fprintf(output, \"Value Tree is NULL !\\n\");\n+        return;\n@@ -1190,24 +1233,0 @@\n-#if defined(LIBXML_XPTR_LOCS_ENABLED)\n-static void\n-xmlXPathDebugDumpLocationSet(FILE *output, xmlLocationSetPtr cur, int depth) {\n-    int i;\n-    char shift[100];\n-\n-    for (i = 0;((i < depth) && (i < 25));i++)\n-        shift[2 * i] = shift[2 * i + 1] = ' ';\n-    shift[2 * i] = shift[2 * i + 1] = 0;\n-\n-    if (cur == NULL) {\n-    fprintf(output, \"%s\", shift);\n-    fprintf(output, \"LocationSet is NULL !\\n\");\n-    return;\n-\n-    }\n-\n-    for (i = 0;i < cur->locNr;i++) {\n-    fprintf(output, \"%s\", shift);\n-        fprintf(output, \"%d : \", i + 1);\n-    xmlXPathDebugDumpObject(output, cur->locTab[i], depth + 1);\n-    }\n-}\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n@@ -1239,1 +1258,1 @@\n-    return;\n+        return;\n@@ -1243,2 +1262,2 @@\n-        fprintf(output, \"Object is uninitialized\\n\");\n-        break;\n+            fprintf(output, \"Object is uninitialized\\n\");\n+            break;\n@@ -1246,12 +1265,12 @@\n-        fprintf(output, \"Object is a Node Set :\\n\");\n-        xmlXPathDebugDumpNodeSet(output, cur->nodesetval, depth);\n-        break;\n-    case XPATH_XSLT_TREE:\n-        fprintf(output, \"Object is an XSLT value tree :\\n\");\n-        xmlXPathDebugDumpValueTree(output, cur->nodesetval, depth);\n-        break;\n-        case XPATH_BOOLEAN:\n-        fprintf(output, \"Object is a Boolean : \");\n-        if (cur->boolval) fprintf(output, \"true\\n\");\n-        else fprintf(output, \"false\\n\");\n-        break;\n+            fprintf(output, \"Object is a Node Set :\\n\");\n+            xmlXPathDebugDumpNodeSet(output, cur->nodesetval, depth);\n+            break;\n+        case XPATH_XSLT_TREE:\n+            fprintf(output, \"Object is an XSLT value tree :\\n\");\n+            xmlXPathDebugDumpValueTree(output, cur->nodesetval, depth);\n+            break;\n+        case XPATH_BOOLEAN:\n+            fprintf(output, \"Object is a Boolean : \");\n+            if (cur->boolval) fprintf(output, \"true\\n\");\n+            else fprintf(output, \"false\\n\");\n+            break;\n@@ -1259,11 +1278,11 @@\n-        switch (xmlXPathIsInf(cur->floatval)) {\n-        case 1:\n-        fprintf(output, \"Object is a number : Infinity\\n\");\n-        break;\n-        case -1:\n-        fprintf(output, \"Object is a number : -Infinity\\n\");\n-        break;\n-        default:\n-        if (xmlXPathIsNaN(cur->floatval)) {\n-            fprintf(output, \"Object is a number : NaN\\n\");\n-        } else if (cur->floatval == 0) {\n+            switch (xmlXPathIsInf(cur->floatval)) {\n+            case 1:\n+                fprintf(output, \"Object is a number : Infinity\\n\");\n+                break;\n+            case -1:\n+                fprintf(output, \"Object is a number : -Infinity\\n\");\n+                break;\n+            default:\n+                if (xmlXPathIsNaN(cur->floatval)) {\n+                    fprintf(output, \"Object is a number : NaN\\n\");\n+                } else if (cur->floatval == 0) {\n@@ -1271,6 +1290,6 @@\n-            fprintf(output, \"Object is a number : 0\\n\");\n-        } else {\n-            fprintf(output, \"Object is a number : %0g\\n\", cur->floatval);\n-        }\n-        }\n-        break;\n+                    fprintf(output, \"Object is a number : 0\\n\");\n+                } else {\n+                    fprintf(output, \"Object is a number : %0g\\n\", cur->floatval);\n+                }\n+            }\n+            break;\n@@ -1278,48 +1297,7 @@\n-        fprintf(output, \"Object is a string : \");\n-        xmlDebugDumpString(output, cur->stringval);\n-        fprintf(output, \"\\n\");\n-        break;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    case XPATH_POINT:\n-        fprintf(output, \"Object is a point : index %d in node\", cur->index);\n-        xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user, depth + 1);\n-        fprintf(output, \"\\n\");\n-        break;\n-    case XPATH_RANGE:\n-        if ((cur->user2 == NULL) ||\n-        ((cur->user2 == cur->user) && (cur->index == cur->index2))) {\n-        fprintf(output, \"Object is a collapsed range :\\n\");\n-        fprintf(output, \"%s\", shift);\n-        if (cur->index >= 0)\n-            fprintf(output, \"index %d in \", cur->index);\n-        fprintf(output, \"node\\n\");\n-        xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user,\n-                          depth + 1);\n-        } else  {\n-        fprintf(output, \"Object is a range :\\n\");\n-        fprintf(output, \"%s\", shift);\n-        fprintf(output, \"From \");\n-        if (cur->index >= 0)\n-            fprintf(output, \"index %d in \", cur->index);\n-        fprintf(output, \"node\\n\");\n-        xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user,\n-                          depth + 1);\n-        fprintf(output, \"%s\", shift);\n-        fprintf(output, \"To \");\n-        if (cur->index2 >= 0)\n-            fprintf(output, \"index %d in \", cur->index2);\n-        fprintf(output, \"node\\n\");\n-        xmlXPathDebugDumpNode(output, (xmlNodePtr) cur->user2,\n-                          depth + 1);\n-        fprintf(output, \"\\n\");\n-        }\n-        break;\n-    case XPATH_LOCATIONSET:\n-        fprintf(output, \"Object is a Location Set:\\n\");\n-        xmlXPathDebugDumpLocationSet(output,\n-            (xmlLocationSetPtr) cur->user, depth);\n-        break;\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-    case XPATH_USERS:\n-        fprintf(output, \"Object is user defined\\n\");\n-        break;\n+            fprintf(output, \"Object is a string : \");\n+            xmlDebugDumpString(output, cur->stringval);\n+            fprintf(output, \"\\n\");\n+            break;\n+        case XPATH_USERS:\n+            fprintf(output, \"Object is user defined\\n\");\n+            break;\n@@ -1331,1 +1309,1 @@\n-                         xmlXPathStepOpPtr op, int depth) {\n+                             xmlXPathStepOpPtr op, int depth) {\n@@ -1341,2 +1319,2 @@\n-    fprintf(output, \"Step is NULL\\n\");\n-    return;\n+        fprintf(output, \"Step is NULL\\n\");\n+        return;\n@@ -1346,1 +1324,1 @@\n-        fprintf(output, \"END\"); break;\n+            fprintf(output, \"END\"); break;\n@@ -1348,1 +1326,1 @@\n-        fprintf(output, \"AND\"); break;\n+            fprintf(output, \"AND\"); break;\n@@ -1350,1 +1328,1 @@\n-        fprintf(output, \"OR\"); break;\n+            fprintf(output, \"OR\"); break;\n@@ -1352,5 +1330,5 @@\n-         if (op->value)\n-         fprintf(output, \"EQUAL =\");\n-         else\n-         fprintf(output, \"EQUAL !=\");\n-         break;\n+             if (op->value)\n+                 fprintf(output, \"EQUAL =\");\n+             else\n+                 fprintf(output, \"EQUAL !=\");\n+             break;\n@@ -1358,7 +1336,7 @@\n-         if (op->value)\n-         fprintf(output, \"CMP <\");\n-         else\n-         fprintf(output, \"CMP >\");\n-         if (!op->value2)\n-         fprintf(output, \"=\");\n-         break;\n+             if (op->value)\n+                 fprintf(output, \"CMP <\");\n+             else\n+                 fprintf(output, \"CMP >\");\n+             if (!op->value2)\n+                 fprintf(output, \"=\");\n+             break;\n@@ -1366,9 +1344,9 @@\n-         if (op->value == 0)\n-         fprintf(output, \"PLUS -\");\n-         else if (op->value == 1)\n-         fprintf(output, \"PLUS +\");\n-         else if (op->value == 2)\n-         fprintf(output, \"PLUS unary -\");\n-         else if (op->value == 3)\n-         fprintf(output, \"PLUS unary - -\");\n-         break;\n+             if (op->value == 0)\n+                 fprintf(output, \"PLUS -\");\n+             else if (op->value == 1)\n+                 fprintf(output, \"PLUS +\");\n+             else if (op->value == 2)\n+                 fprintf(output, \"PLUS unary -\");\n+             else if (op->value == 3)\n+                 fprintf(output, \"PLUS unary - -\");\n+             break;\n@@ -1376,7 +1354,7 @@\n-         if (op->value == 0)\n-         fprintf(output, \"MULT *\");\n-         else if (op->value == 1)\n-         fprintf(output, \"MULT div\");\n-         else\n-         fprintf(output, \"MULT mod\");\n-         break;\n+             if (op->value == 0)\n+                 fprintf(output, \"MULT *\");\n+             else if (op->value == 1)\n+                 fprintf(output, \"MULT div\");\n+             else\n+                 fprintf(output, \"MULT mod\");\n+             break;\n@@ -1384,1 +1362,1 @@\n-         fprintf(output, \"UNION\"); break;\n+             fprintf(output, \"UNION\"); break;\n@@ -1386,1 +1364,1 @@\n-         fprintf(output, \"ROOT\"); break;\n+             fprintf(output, \"ROOT\"); break;\n@@ -1388,1 +1366,1 @@\n-         fprintf(output, \"NODE\"); break;\n+             fprintf(output, \"NODE\"); break;\n@@ -1390,1 +1368,1 @@\n-         fprintf(output, \"SORT\"); break;\n+             fprintf(output, \"SORT\"); break;\n@@ -1392,36 +1370,36 @@\n-        xmlXPathAxisVal axis = (xmlXPathAxisVal)op->value;\n-        xmlXPathTestVal test = (xmlXPathTestVal)op->value2;\n-        xmlXPathTypeVal type = (xmlXPathTypeVal)op->value3;\n-        const xmlChar *prefix = op->value4;\n-        const xmlChar *name = op->value5;\n-\n-        fprintf(output, \"COLLECT \");\n-        switch (axis) {\n-        case AXIS_ANCESTOR:\n-            fprintf(output, \" 'ancestors' \"); break;\n-        case AXIS_ANCESTOR_OR_SELF:\n-            fprintf(output, \" 'ancestors-or-self' \"); break;\n-        case AXIS_ATTRIBUTE:\n-            fprintf(output, \" 'attributes' \"); break;\n-        case AXIS_CHILD:\n-            fprintf(output, \" 'child' \"); break;\n-        case AXIS_DESCENDANT:\n-            fprintf(output, \" 'descendant' \"); break;\n-        case AXIS_DESCENDANT_OR_SELF:\n-            fprintf(output, \" 'descendant-or-self' \"); break;\n-        case AXIS_FOLLOWING:\n-            fprintf(output, \" 'following' \"); break;\n-        case AXIS_FOLLOWING_SIBLING:\n-            fprintf(output, \" 'following-siblings' \"); break;\n-        case AXIS_NAMESPACE:\n-            fprintf(output, \" 'namespace' \"); break;\n-        case AXIS_PARENT:\n-            fprintf(output, \" 'parent' \"); break;\n-        case AXIS_PRECEDING:\n-            fprintf(output, \" 'preceding' \"); break;\n-        case AXIS_PRECEDING_SIBLING:\n-            fprintf(output, \" 'preceding-sibling' \"); break;\n-        case AXIS_SELF:\n-            fprintf(output, \" 'self' \"); break;\n-        }\n-        switch (test) {\n+            xmlXPathAxisVal axis = (xmlXPathAxisVal)op->value;\n+            xmlXPathTestVal test = (xmlXPathTestVal)op->value2;\n+            xmlXPathTypeVal type = (xmlXPathTypeVal)op->value3;\n+            const xmlChar *prefix = op->value4;\n+            const xmlChar *name = op->value5;\n+\n+            fprintf(output, \"COLLECT \");\n+            switch (axis) {\n+                case AXIS_ANCESTOR:\n+                    fprintf(output, \" 'ancestors' \"); break;\n+                case AXIS_ANCESTOR_OR_SELF:\n+                    fprintf(output, \" 'ancestors-or-self' \"); break;\n+                case AXIS_ATTRIBUTE:\n+                    fprintf(output, \" 'attributes' \"); break;\n+                case AXIS_CHILD:\n+                    fprintf(output, \" 'child' \"); break;\n+                case AXIS_DESCENDANT:\n+                    fprintf(output, \" 'descendant' \"); break;\n+                case AXIS_DESCENDANT_OR_SELF:\n+                    fprintf(output, \" 'descendant-or-self' \"); break;\n+                case AXIS_FOLLOWING:\n+                    fprintf(output, \" 'following' \"); break;\n+                case AXIS_FOLLOWING_SIBLING:\n+                    fprintf(output, \" 'following-siblings' \"); break;\n+                case AXIS_NAMESPACE:\n+                    fprintf(output, \" 'namespace' \"); break;\n+                case AXIS_PARENT:\n+                    fprintf(output, \" 'parent' \"); break;\n+                case AXIS_PRECEDING:\n+                    fprintf(output, \" 'preceding' \"); break;\n+                case AXIS_PRECEDING_SIBLING:\n+                    fprintf(output, \" 'preceding-sibling' \"); break;\n+                case AXIS_SELF:\n+                    fprintf(output, \" 'self' \"); break;\n+            }\n+            switch (test) {\n@@ -1429,1 +1407,1 @@\n-            fprintf(output, \"'none' \"); break;\n+                    fprintf(output, \"'none' \"); break;\n@@ -1431,1 +1409,1 @@\n-            fprintf(output, \"'type' \"); break;\n+                    fprintf(output, \"'type' \"); break;\n@@ -1433,1 +1411,1 @@\n-            fprintf(output, \"'PI' \"); break;\n+                    fprintf(output, \"'PI' \"); break;\n@@ -1435,1 +1413,1 @@\n-            fprintf(output, \"'all' \"); break;\n+                    fprintf(output, \"'all' \"); break;\n@@ -1437,1 +1415,1 @@\n-            fprintf(output, \"'namespace' \"); break;\n+                    fprintf(output, \"'namespace' \"); break;\n@@ -1439,3 +1417,3 @@\n-            fprintf(output, \"'name' \"); break;\n-        }\n-        switch (type) {\n+                    fprintf(output, \"'name' \"); break;\n+            }\n+            switch (type) {\n@@ -1443,1 +1421,1 @@\n-            fprintf(output, \"'node' \"); break;\n+                    fprintf(output, \"'node' \"); break;\n@@ -1445,1 +1423,1 @@\n-            fprintf(output, \"'comment' \"); break;\n+                    fprintf(output, \"'comment' \"); break;\n@@ -1447,1 +1425,1 @@\n-            fprintf(output, \"'text' \"); break;\n+                    fprintf(output, \"'text' \"); break;\n@@ -1449,7 +1427,7 @@\n-            fprintf(output, \"'PI' \"); break;\n-        }\n-        if (prefix != NULL)\n-        fprintf(output, \"%s:\", prefix);\n-        if (name != NULL)\n-        fprintf(output, \"%s\", (const char *) name);\n-        break;\n+                    fprintf(output, \"'PI' \"); break;\n+            }\n+            if (prefix != NULL)\n+                fprintf(output, \"%s:\", prefix);\n+            if (name != NULL)\n+                fprintf(output, \"%s\", (const char *) name);\n+            break;\n@@ -1458,2 +1436,2 @@\n-    case XPATH_OP_VALUE: {\n-        xmlXPathObjectPtr object = (xmlXPathObjectPtr) op->value4;\n+        case XPATH_OP_VALUE: {\n+            xmlXPathObjectPtr object = (xmlXPathObjectPtr) op->value4;\n@@ -1461,7 +1439,7 @@\n-        fprintf(output, \"ELEM \");\n-        xmlXPathDebugDumpObject(output, object, 0);\n-        goto finish;\n-    }\n-    case XPATH_OP_VARIABLE: {\n-        const xmlChar *prefix = op->value5;\n-        const xmlChar *name = op->value4;\n+            fprintf(output, \"ELEM \");\n+            xmlXPathDebugDumpObject(output, object, 0);\n+            goto finish;\n+        }\n+        case XPATH_OP_VARIABLE: {\n+            const xmlChar *prefix = op->value5;\n+            const xmlChar *name = op->value4;\n@@ -1469,10 +1447,10 @@\n-        if (prefix != NULL)\n-        fprintf(output, \"VARIABLE %s:%s\", prefix, name);\n-        else\n-        fprintf(output, \"VARIABLE %s\", name);\n-        break;\n-    }\n-    case XPATH_OP_FUNCTION: {\n-        int nbargs = op->value;\n-        const xmlChar *prefix = op->value5;\n-        const xmlChar *name = op->value4;\n+            if (prefix != NULL)\n+                fprintf(output, \"VARIABLE %s:%s\", prefix, name);\n+            else\n+                fprintf(output, \"VARIABLE %s\", name);\n+            break;\n+        }\n+        case XPATH_OP_FUNCTION: {\n+            int nbargs = op->value;\n+            const xmlChar *prefix = op->value5;\n+            const xmlChar *name = op->value4;\n@@ -1480,7 +1458,7 @@\n-        if (prefix != NULL)\n-        fprintf(output, \"FUNCTION %s:%s(%d args)\",\n-            prefix, name, nbargs);\n-        else\n-        fprintf(output, \"FUNCTION %s(%d args)\", name, nbargs);\n-        break;\n-    }\n+            if (prefix != NULL)\n+                fprintf(output, \"FUNCTION %s:%s(%d args)\",\n+                        prefix, name, nbargs);\n+            else\n+                fprintf(output, \"FUNCTION %s(%d args)\", name, nbargs);\n+            break;\n+        }\n@@ -1490,4 +1468,1 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        case XPATH_OP_RANGETO: fprintf(output, \"RANGETO\"); break;\n-#endif\n-    default:\n+        default:\n@@ -1498,0 +1473,4 @@\n+    \/* OP_VALUE has invalid ch1. *\/\n+    if (op->op == XPATH_OP_VALUE)\n+        return;\n+\n@@ -1499,1 +1478,1 @@\n-    xmlXPathDebugDumpStepOp(output, comp, &comp->steps[op->ch1], depth + 1);\n+        xmlXPathDebugDumpStepOp(output, comp, &comp->steps[op->ch1], depth + 1);\n@@ -1501,1 +1480,1 @@\n-    xmlXPathDebugDumpStepOp(output, comp, &comp->steps[op->ch2], depth + 1);\n+        xmlXPathDebugDumpStepOp(output, comp, &comp->steps[op->ch2], depth + 1);\n@@ -1514,1 +1493,1 @@\n-                      int depth) {\n+                          int depth) {\n@@ -1542,3 +1521,3 @@\n- *                                    *\n- *            XPath object caching                *\n- *                                    *\n+ *                                                                      *\n+ *                      XPath object caching                            *\n+ *                                                                      *\n@@ -1561,1 +1540,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1576,6 +1555,6 @@\n-    if (list->nodesetval != NULL) {\n-        if (list->nodesetval->nodeTab != NULL)\n-        xmlFree(list->nodesetval->nodeTab);\n-        xmlFree(list->nodesetval);\n-    }\n-    xmlFree(list);\n+        if (list->nodesetval != NULL) {\n+            if (list->nodesetval->nodeTab != NULL)\n+                xmlFree(list->nodesetval->nodeTab);\n+            xmlFree(list->nodesetval);\n+        }\n+        xmlFree(list);\n@@ -1591,1 +1570,1 @@\n-    return;\n+        return;\n@@ -1593,1 +1572,1 @@\n-    xmlXPathCacheFreeObjectList(cache->nodesetObjs);\n+        xmlXPathCacheFreeObjectList(cache->nodesetObjs);\n@@ -1595,1 +1574,1 @@\n-    xmlXPathCacheFreeObjectList(cache->miscObjs);\n+        xmlXPathCacheFreeObjectList(cache->miscObjs);\n@@ -1623,3 +1602,3 @@\n-            int active,\n-            int value,\n-            int options)\n+                        int active,\n+                        int value,\n+                        int options)\n@@ -1628,1 +1607,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1630,1 +1609,1 @@\n-    xmlXPathContextCachePtr cache;\n+        xmlXPathContextCachePtr cache;\n@@ -1632,2 +1611,0 @@\n-    if (ctxt->cache == NULL) {\n-        ctxt->cache = xmlXPathNewCache();\n@@ -1635,0 +1612,2 @@\n+            ctxt->cache = xmlXPathNewCache();\n+            if (ctxt->cache == NULL) {\n@@ -1636,1 +1615,1 @@\n-        return(-1);\n+                return(-1);\n@@ -1638,8 +1617,8 @@\n-    }\n-    cache = (xmlXPathContextCachePtr) ctxt->cache;\n-    if (options == 0) {\n-        if (value < 0)\n-        value = 100;\n-        cache->maxNodeset = value;\n-        cache->maxMisc = value;\n-    }\n+        }\n+        cache = (xmlXPathContextCachePtr) ctxt->cache;\n+        if (options == 0) {\n+            if (value < 0)\n+                value = 100;\n+            cache->maxNodeset = value;\n+            cache->maxMisc = value;\n+        }\n@@ -1647,2 +1626,2 @@\n-    xmlXPathFreeCache((xmlXPathContextCachePtr) ctxt->cache);\n-    ctxt->cache = NULL;\n+        xmlXPathFreeCache((xmlXPathContextCachePtr) ctxt->cache);\n+        ctxt->cache = NULL;\n@@ -1672,2 +1651,2 @@\n-    xmlXPathContextCachePtr cache =\n-        (xmlXPathContextCachePtr) ctxt->cache;\n+        xmlXPathContextCachePtr cache =\n+            (xmlXPathContextCachePtr) ctxt->cache;\n@@ -1675,2 +1654,2 @@\n-    if (cache->miscObjs != NULL) {\n-        ret = cache->miscObjs;\n+        if (cache->miscObjs != NULL) {\n+            ret = cache->miscObjs;\n@@ -1680,4 +1659,4 @@\n-        ret->type = XPATH_NODESET;\n-        ret->nodesetval = val;\n-        return(ret);\n-    }\n+            ret->type = XPATH_NODESET;\n+            ret->nodesetval = val;\n+            return(ret);\n+        }\n@@ -1709,1 +1688,1 @@\n-    xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n+        xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n@@ -1711,2 +1690,2 @@\n-    if (cache->miscObjs != NULL) {\n-        ret = cache->miscObjs;\n+        if (cache->miscObjs != NULL) {\n+            ret = cache->miscObjs;\n@@ -1715,4 +1694,4 @@\n-        ret->type = XPATH_STRING;\n-        ret->stringval = val;\n-        return(ret);\n-    }\n+            ret->type = XPATH_STRING;\n+            ret->stringval = val;\n+            return(ret);\n+        }\n@@ -1745,1 +1724,1 @@\n-    xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n+        xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n@@ -1747,5 +1726,5 @@\n-    if (cache->nodesetObjs != NULL) {\n-        \/*\n-        * Use the nodeset-cache.\n-        *\/\n-        ret = cache->nodesetObjs;\n+        if (cache->nodesetObjs != NULL) {\n+            \/*\n+            * Use the nodeset-cache.\n+            *\/\n+            ret = cache->nodesetObjs;\n@@ -1755,7 +1734,7 @@\n-        ret->type = XPATH_NODESET;\n-        ret->boolval = 0;\n-        if (val) {\n-        if ((ret->nodesetval->nodeMax == 0) ||\n-            (val->type == XML_NAMESPACE_DECL))\n-        {\n-            if (xmlXPathNodeSetAddUnique(ret->nodesetval, val) < 0)\n+            ret->type = XPATH_NODESET;\n+            ret->boolval = 0;\n+            if (val) {\n+                if ((ret->nodesetval->nodeMax == 0) ||\n+                    (val->type == XML_NAMESPACE_DECL))\n+                {\n+                    if (xmlXPathNodeSetAddUnique(ret->nodesetval, val) < 0)\n@@ -1763,7 +1742,7 @@\n-        } else {\n-            ret->nodesetval->nodeTab[0] = val;\n-            ret->nodesetval->nodeNr = 1;\n-        }\n-        }\n-        return(ret);\n-    } else if (cache->miscObjs != NULL) {\n+                } else {\n+                    ret->nodesetval->nodeTab[0] = val;\n+                    ret->nodesetval->nodeNr = 1;\n+                }\n+            }\n+            return(ret);\n+        } else if (cache->miscObjs != NULL) {\n@@ -1771,3 +1750,3 @@\n-        \/*\n-        * Fallback to misc-cache.\n-        *\/\n+            \/*\n+            * Fallback to misc-cache.\n+            *\/\n@@ -1775,2 +1754,2 @@\n-        set = xmlXPathNodeSetCreate(val);\n-        if (set == NULL) {\n+            set = xmlXPathNodeSetCreate(val);\n+            if (set == NULL) {\n@@ -1778,2 +1757,2 @@\n-        return(NULL);\n-        }\n+                return(NULL);\n+            }\n@@ -1781,1 +1760,1 @@\n-        ret = cache->miscObjs;\n+            ret = cache->miscObjs;\n@@ -1785,5 +1764,5 @@\n-        ret->type = XPATH_NODESET;\n-        ret->boolval = 0;\n-        ret->nodesetval = set;\n-        return(ret);\n-    }\n+            ret->type = XPATH_NODESET;\n+            ret->boolval = 0;\n+            ret->nodesetval = set;\n+            return(ret);\n+        }\n@@ -1814,1 +1793,1 @@\n-    xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n+        xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n@@ -1816,1 +1795,1 @@\n-    if (cache->miscObjs != NULL) {\n+        if (cache->miscObjs != NULL) {\n@@ -1827,1 +1806,1 @@\n-        ret = cache->miscObjs;\n+            ret = cache->miscObjs;\n@@ -1830,1 +1809,1 @@\n-        ret->type = XPATH_STRING;\n+            ret->type = XPATH_STRING;\n@@ -1832,2 +1811,2 @@\n-        return(ret);\n-    }\n+            return(ret);\n+        }\n@@ -1875,1 +1854,1 @@\n-    xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n+        xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n@@ -1877,2 +1856,2 @@\n-    if (cache->miscObjs != NULL) {\n-        ret = cache->miscObjs;\n+        if (cache->miscObjs != NULL) {\n+            ret = cache->miscObjs;\n@@ -1882,4 +1861,4 @@\n-        ret->type = XPATH_BOOLEAN;\n-        ret->boolval = (val != 0);\n-        return(ret);\n-    }\n+            ret->type = XPATH_BOOLEAN;\n+            ret->boolval = (val != 0);\n+            return(ret);\n+        }\n@@ -1911,1 +1890,1 @@\n-    xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n+        xmlXPathContextCachePtr cache = (xmlXPathContextCachePtr) ctxt->cache;\n@@ -1913,2 +1892,2 @@\n-    if (cache->miscObjs != NULL) {\n-        ret = cache->miscObjs;\n+        if (cache->miscObjs != NULL) {\n+            ret = cache->miscObjs;\n@@ -1918,4 +1897,4 @@\n-        ret->type = XPATH_NUMBER;\n-        ret->floatval = val;\n-        return(ret);\n-    }\n+            ret->type = XPATH_NUMBER;\n+            ret->floatval = val;\n+            return(ret);\n+        }\n@@ -1947,1 +1926,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1950,1 +1929,1 @@\n-    switch (val->type) {\n+        switch (val->type) {\n@@ -1961,9 +1940,9 @@\n-        case XPATH_STRING:\n-        return(xmlXPathCacheNewString(pctxt, val->stringval));\n-        case XPATH_BOOLEAN:\n-        return(xmlXPathCacheNewBoolean(pctxt, val->boolval));\n-        case XPATH_NUMBER:\n-        return(xmlXPathCacheNewFloat(pctxt, val->floatval));\n-        default:\n-        break;\n-    }\n+            case XPATH_STRING:\n+                return(xmlXPathCacheNewString(pctxt, val->stringval));\n+            case XPATH_BOOLEAN:\n+                return(xmlXPathCacheNewBoolean(pctxt, val->boolval));\n+            case XPATH_NUMBER:\n+                return(xmlXPathCacheNewFloat(pctxt, val->floatval));\n+            default:\n+                break;\n+        }\n@@ -1978,3 +1957,3 @@\n- *                                    *\n- *        Parser stacks related functions and macros        *\n- *                                    *\n+ *                                                                      *\n+ *              Parser stacks related functions and macros              *\n+ *                                                                      *\n@@ -1998,1 +1977,1 @@\n-    return(xmlXPathNAN);\n+        return(xmlXPathNAN);\n@@ -2001,2 +1980,2 @@\n-    ret = xmlXPathNAN;\n-    break;\n+        ret = xmlXPathNAN;\n+        break;\n@@ -2007,1 +1986,1 @@\n-    str = xmlXPathCastNodeSetToString(val->nodesetval);\n+        str = xmlXPathCastNodeSetToString(val->nodesetval);\n@@ -2012,1 +1991,1 @@\n-        ret = xmlXPathCastStringToNumber(str);\n+            ret = xmlXPathCastStringToNumber(str);\n@@ -2015,1 +1994,1 @@\n-    break;\n+        break;\n@@ -2018,2 +1997,2 @@\n-    ret = xmlXPathCastStringToNumber(val->stringval);\n-    break;\n+        ret = xmlXPathCastStringToNumber(val->stringval);\n+        break;\n@@ -2021,2 +2000,2 @@\n-    ret = val->floatval;\n-    break;\n+        ret = val->floatval;\n+        break;\n@@ -2024,2 +2003,2 @@\n-    ret = xmlXPathCastBooleanToNumber(val->boolval);\n-    break;\n+        ret = xmlXPathCastBooleanToNumber(val->boolval);\n+        break;\n@@ -2027,8 +2006,3 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    case XPATH_POINT:\n-    case XPATH_RANGE:\n-    case XPATH_LOCATIONSET:\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-    \/* TODO *\/\n-    ret = xmlXPathNAN;\n-    break;\n+        \/* TODO *\/\n+        ret = xmlXPathNAN;\n+        break;\n@@ -2040,1 +2014,1 @@\n- * valuePop:\n+ * xmlXPathValuePop:\n@@ -2048,1 +2022,1 @@\n-valuePop(xmlXPathParserContextPtr ctxt)\n+xmlXPathValuePop(xmlXPathParserContextPtr ctxt)\n@@ -2064,0 +2038,1 @@\n+\n@@ -2065,1 +2040,1 @@\n- * valuePush:\n+ * xmlXPathValuePush:\n@@ -2077,1 +2052,1 @@\n-valuePush(xmlXPathParserContextPtr ctxt, xmlXPathObjectPtr value)\n+xmlXPathValuePush(xmlXPathParserContextPtr ctxt, xmlXPathObjectPtr value)\n@@ -2089,0 +2064,1 @@\n+        int newSize;\n@@ -2090,1 +2066,3 @@\n-        if (ctxt->valueMax >= XPATH_MAX_STACK_DEPTH) {\n+        newSize = xmlGrowCapacity(ctxt->valueMax, sizeof(tmp[0]),\n+                                  10, XPATH_MAX_STACK_DEPTH);\n+        if (newSize < 0) {\n@@ -2095,3 +2073,1 @@\n-        tmp = (xmlXPathObjectPtr *) xmlRealloc(ctxt->valueTab,\n-                                             2 * ctxt->valueMax *\n-                                             sizeof(ctxt->valueTab[0]));\n+        tmp = xmlRealloc(ctxt->valueTab, newSize * sizeof(tmp[0]));\n@@ -2103,2 +2079,2 @@\n-        ctxt->valueMax *= 2;\n-    ctxt->valueTab = tmp;\n+        ctxt->valueTab = tmp;\n+        ctxt->valueMax = newSize;\n@@ -2125,1 +2101,1 @@\n-    obj = valuePop(ctxt);\n+    obj = xmlXPathValuePop(ctxt);\n@@ -2127,2 +2103,2 @@\n-    xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n-    return(0);\n+        xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n+        return(0);\n@@ -2131,1 +2107,1 @@\n-    ret = xmlXPathCastToBoolean(obj);\n+        ret = xmlXPathCastToBoolean(obj);\n@@ -2152,1 +2128,1 @@\n-    obj = valuePop(ctxt);\n+    obj = xmlXPathValuePop(ctxt);\n@@ -2154,2 +2130,2 @@\n-    xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n-    return(0);\n+        xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n+        return(0);\n@@ -2158,1 +2134,1 @@\n-    ret = xmlXPathCastToNumberInternal(ctxt, obj);\n+        ret = xmlXPathCastToNumberInternal(ctxt, obj);\n@@ -2179,1 +2155,1 @@\n-    obj = valuePop(ctxt);\n+    obj = xmlXPathValuePop(ctxt);\n@@ -2181,2 +2157,2 @@\n-    xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n-    return(NULL);\n+        xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n+        return(NULL);\n@@ -2207,2 +2183,2 @@\n-    xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n-    return(NULL);\n+        xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n+        return(NULL);\n@@ -2211,2 +2187,2 @@\n-    xmlXPathSetTypeError(ctxt);\n-    return(NULL);\n+        xmlXPathSetTypeError(ctxt);\n+        return(NULL);\n@@ -2214,1 +2190,1 @@\n-    obj = valuePop(ctxt);\n+    obj = xmlXPathValuePop(ctxt);\n@@ -2216,5 +2192,0 @@\n-#if 0\n-    \/* to fix memory leak of not clearing obj->user *\/\n-    if (obj->boolval && obj->user != NULL)\n-        xmlFreeNodeList((xmlNodePtr) obj->user);\n-#endif\n@@ -2241,2 +2212,2 @@\n-    xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n-    return(NULL);\n+        xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n+        return(NULL);\n@@ -2245,2 +2216,2 @@\n-    xmlXPathSetTypeError(ctxt);\n-    return(NULL);\n+        xmlXPathSetTypeError(ctxt);\n+        return(NULL);\n@@ -2248,1 +2219,1 @@\n-    obj = valuePop(ctxt);\n+    obj = xmlXPathValuePop(ctxt);\n@@ -2284,3 +2255,3 @@\n-#define COPY_BUF(l,b,i,v)                                              \\\n-    if (l == 1) b[i++] = v;                                            \\\n-    else i += xmlCopyChar(l,&b[i],v)\n+#define COPY_BUF(b, i, v)                                               \\\n+    if (v < 0x80) b[i++] = v;                                           \\\n+    else i += xmlCopyCharMultiByte(&b[i],v)\n@@ -2290,1 +2261,1 @@\n-#define SKIP_BLANKS                            \\\n+#define SKIP_BLANKS                                                     \\\n@@ -2306,1 +2277,1 @@\n-#define    LOWER_DOUBLE_EXP 5\n+#define LOWER_DOUBLE_EXP 5\n@@ -2325,3 +2296,3 @@\n-    if (buffersize > (int)sizeof(\"Infinity\"))\n-        snprintf(buffer, buffersize, \"Infinity\");\n-    break;\n+        if (buffersize > (int)sizeof(\"Infinity\"))\n+            snprintf(buffer, buffersize, \"Infinity\");\n+        break;\n@@ -2329,3 +2300,3 @@\n-    if (buffersize > (int)sizeof(\"-Infinity\"))\n-        snprintf(buffer, buffersize, \"-Infinity\");\n-    break;\n+        if (buffersize > (int)sizeof(\"-Infinity\"))\n+            snprintf(buffer, buffersize, \"-Infinity\");\n+        break;\n@@ -2333,4 +2304,4 @@\n-    if (xmlXPathIsNaN(number)) {\n-        if (buffersize > (int)sizeof(\"NaN\"))\n-        snprintf(buffer, buffersize, \"NaN\");\n-    } else if (number == 0) {\n+        if (xmlXPathIsNaN(number)) {\n+            if (buffersize > (int)sizeof(\"NaN\"))\n+                snprintf(buffer, buffersize, \"NaN\");\n+        } else if (number == 0) {\n@@ -2338,2 +2309,2 @@\n-        snprintf(buffer, buffersize, \"0\");\n-    } else if ((number > INT_MIN) && (number < INT_MAX) &&\n+            snprintf(buffer, buffersize, \"0\");\n+        } else if ((number > INT_MIN) && (number < INT_MAX) &&\n@@ -2341,3 +2312,3 @@\n-        char work[30];\n-        char *ptr, *cur;\n-        int value = (int) number;\n+            char work[30];\n+            char *ptr, *cur;\n+            int value = (int) number;\n@@ -2346,2 +2317,15 @@\n-        if (value == 0) {\n-        *ptr++ = '0';\n+            if (value == 0) {\n+                *ptr++ = '0';\n+            } else {\n+                snprintf(work, 29, \"%d\", value);\n+                cur = &work[0];\n+                while ((*cur) && (ptr - buffer < buffersize)) {\n+                    *ptr++ = *cur++;\n+                }\n+            }\n+            if (ptr - buffer < buffersize) {\n+                *ptr = 0;\n+            } else if (buffersize > 0) {\n+                ptr--;\n+                *ptr = 0;\n+            }\n@@ -2349,30 +2333,15 @@\n-        snprintf(work, 29, \"%d\", value);\n-        cur = &work[0];\n-        while ((*cur) && (ptr - buffer < buffersize)) {\n-            *ptr++ = *cur++;\n-        }\n-        }\n-        if (ptr - buffer < buffersize) {\n-        *ptr = 0;\n-        } else if (buffersize > 0) {\n-        ptr--;\n-        *ptr = 0;\n-        }\n-    } else {\n-        \/*\n-          For the dimension of work,\n-              DBL_DIG is number of significant digits\n-          EXPONENT is only needed for \"scientific notation\"\n-              3 is sign, decimal point, and terminating zero\n-          LOWER_DOUBLE_EXP is max number of leading zeroes in fraction\n-          Note that this dimension is slightly (a few characters)\n-          larger than actually necessary.\n-        *\/\n-        char work[DBL_DIG + EXPONENT_DIGITS + 3 + LOWER_DOUBLE_EXP];\n-        int integer_place, fraction_place;\n-        char *ptr;\n-        char *after_fraction;\n-        double absolute_value;\n-        int size;\n-\n-        absolute_value = fabs(number);\n+            \/*\n+              For the dimension of work,\n+                  DBL_DIG is number of significant digits\n+                  EXPONENT is only needed for \"scientific notation\"\n+                  3 is sign, decimal point, and terminating zero\n+                  LOWER_DOUBLE_EXP is max number of leading zeroes in fraction\n+              Note that this dimension is slightly (a few characters)\n+              larger than actually necessary.\n+            *\/\n+            char work[DBL_DIG + EXPONENT_DIGITS + 3 + LOWER_DOUBLE_EXP];\n+            int integer_place, fraction_place;\n+            char *ptr;\n+            char *after_fraction;\n+            double absolute_value;\n+            int size;\n@@ -2380,14 +2349,1 @@\n-        \/*\n-         * First choose format - scientific or regular floating point.\n-         * In either case, result is in work, and after_fraction points\n-         * just past the fractional part.\n-        *\/\n-        if ( ((absolute_value > UPPER_DOUBLE) ||\n-          (absolute_value < LOWER_DOUBLE)) &&\n-         (absolute_value != 0.0) ) {\n-        \/* Use scientific notation *\/\n-        integer_place = DBL_DIG + EXPONENT_DIGITS + 1;\n-        fraction_place = DBL_DIG - 1;\n-        size = snprintf(work, sizeof(work),\"%*.*e\",\n-             integer_place, fraction_place, number);\n-        while ((size > 0) && (work[size] != 'e')) size--;\n+            absolute_value = fabs(number);\n@@ -2395,15 +2351,14 @@\n-        }\n-        else {\n-        \/* Use regular notation *\/\n-        if (absolute_value > 0.0) {\n-            integer_place = (int)log10(absolute_value);\n-            if (integer_place > 0)\n-                fraction_place = DBL_DIG - integer_place - 1;\n-            else\n-                fraction_place = DBL_DIG - integer_place;\n-        } else {\n-            fraction_place = 1;\n-        }\n-        size = snprintf(work, sizeof(work), \"%0.*f\",\n-                fraction_place, number);\n-        }\n+            \/*\n+             * First choose format - scientific or regular floating point.\n+             * In either case, result is in work, and after_fraction points\n+             * just past the fractional part.\n+            *\/\n+            if ( ((absolute_value > UPPER_DOUBLE) ||\n+                  (absolute_value < LOWER_DOUBLE)) &&\n+                 (absolute_value != 0.0) ) {\n+                \/* Use scientific notation *\/\n+                integer_place = DBL_DIG + EXPONENT_DIGITS + 1;\n+                fraction_place = DBL_DIG - 1;\n+                size = snprintf(work, sizeof(work),\"%*.*e\",\n+                         integer_place, fraction_place, number);\n+                while ((size > 0) && (work[size] != 'e')) size--;\n@@ -2411,5 +2366,15 @@\n-        \/* Remove leading spaces sometimes inserted by snprintf *\/\n-        while (work[0] == ' ') {\n-            for (ptr = &work[0];(ptr[0] = ptr[1]);ptr++);\n-        size--;\n-        }\n+            }\n+            else {\n+                \/* Use regular notation *\/\n+                if (absolute_value > 0.0) {\n+                    integer_place = (int)log10(absolute_value);\n+                    if (integer_place > 0)\n+                        fraction_place = DBL_DIG - integer_place - 1;\n+                    else\n+                        fraction_place = DBL_DIG - integer_place;\n+                } else {\n+                    fraction_place = 1;\n+                }\n+                size = snprintf(work, sizeof(work), \"%0.*f\",\n+                                fraction_place, number);\n+            }\n@@ -2417,8 +2382,5 @@\n-        \/* Remove fractional trailing zeroes *\/\n-        after_fraction = work + size;\n-        ptr = after_fraction;\n-        while (*(--ptr) == '0')\n-        ;\n-        if (*ptr != '.')\n-            ptr++;\n-        while ((*ptr++ = *after_fraction++) != 0);\n+            \/* Remove leading spaces sometimes inserted by snprintf *\/\n+            while (work[0] == ' ') {\n+                for (ptr = &work[0];(ptr[0] = ptr[1]);ptr++);\n+                size--;\n+            }\n@@ -2426,5 +2388,16 @@\n-        \/* Finally copy result back to caller *\/\n-        size = strlen(work) + 1;\n-        if (size > buffersize) {\n-        work[buffersize - 1] = 0;\n-        size = buffersize;\n+            \/* Remove fractional trailing zeroes *\/\n+            after_fraction = work + size;\n+            ptr = after_fraction;\n+            while (*(--ptr) == '0')\n+                ;\n+            if (*ptr != '.')\n+                ptr++;\n+            while ((*ptr++ = *after_fraction++) != 0);\n+\n+            \/* Finally copy result back to caller *\/\n+            size = strlen(work) + 1;\n+            if (size > buffersize) {\n+                work[buffersize - 1] = 0;\n+                size = buffersize;\n+            }\n+            memmove(buffer, work, size);\n@@ -2432,3 +2405,1 @@\n-        memmove(buffer, work, size);\n-    }\n-    break;\n+        break;\n@@ -2440,3 +2411,3 @@\n- *                                    *\n- *            Routines to handle NodeSets            *\n- *                                    *\n+ *                                                                      *\n+ *                      Routines to handle NodeSets                     *\n+ *                                                                      *\n@@ -2460,1 +2431,1 @@\n-    ptrdiff_t count = 0;\n+    XML_INTPTR_T count = 0;\n@@ -2464,1 +2435,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2467,18 +2438,7 @@\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        cur->content = (void *) (-(++count));\n-        if (cur->children != NULL) {\n-        cur = cur->children;\n-        continue;\n-        }\n-    }\n-    if (cur->next != NULL) {\n-        cur = cur->next;\n-        continue;\n-    }\n-    do {\n-        cur = cur->parent;\n-        if (cur == NULL)\n-        break;\n-        if (cur == (xmlNodePtr) doc) {\n-        cur = NULL;\n-        break;\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            count += 1;\n+            cur->content = XML_INT_TO_PTR(-count);\n+            if (cur->children != NULL) {\n+                cur = cur->children;\n+                continue;\n+            }\n@@ -2487,2 +2447,2 @@\n-        cur = cur->next;\n-        break;\n+            cur = cur->next;\n+            continue;\n@@ -2490,1 +2450,13 @@\n-    } while (cur != NULL);\n+        do {\n+            cur = cur->parent;\n+            if (cur == NULL)\n+                break;\n+            if (cur == (xmlNodePtr) doc) {\n+                cur = NULL;\n+                break;\n+            }\n+            if (cur->next != NULL) {\n+                cur = cur->next;\n+                break;\n+            }\n+        } while (cur != NULL);\n@@ -2513,1 +2485,1 @@\n-    return(-2);\n+        return(-2);\n@@ -2517,2 +2489,2 @@\n-    if (node1 == node2)        \/* trivial case *\/\n-    return(0);\n+    if (node1 == node2)         \/* trivial case *\/\n+        return(0);\n@@ -2520,3 +2492,3 @@\n-    attr1 = 1;\n-    attrNode1 = node1;\n-    node1 = node1->parent;\n+        attr1 = 1;\n+        attrNode1 = node1;\n+        node1 = node1->parent;\n@@ -2525,3 +2497,3 @@\n-    attr2 = 1;\n-    attrNode2 = node2;\n-    node2 = node2->parent;\n+        attr2 = 1;\n+        attrNode2 = node2;\n+        node2 = node2->parent;\n@@ -2530,10 +2502,12 @@\n-    if (attr1 == attr2) {\n-        \/* not required, but we keep attributes in order *\/\n-        if (attr1 != 0) {\n-            cur = attrNode2->prev;\n-        while (cur != NULL) {\n-            if (cur == attrNode1)\n-                return (1);\n-            cur = cur->prev;\n-        }\n-        return (-1);\n+        if (attr1 == attr2) {\n+            \/* not required, but we keep attributes in order *\/\n+            if (attr1 != 0) {\n+                cur = attrNode2->prev;\n+                while (cur != NULL) {\n+                    if (cur == attrNode1)\n+                        return (1);\n+                    cur = cur->prev;\n+                }\n+                return (-1);\n+            }\n+            return(0);\n@@ -2541,5 +2515,3 @@\n-        return(0);\n-    }\n-    if (attr2 == 1)\n-        return(1);\n-    return(-1);\n+        if (attr2 == 1)\n+            return(1);\n+        return(-1);\n@@ -2549,1 +2521,1 @@\n-    return(1);\n+        return(1);\n@@ -2551,1 +2523,1 @@\n-    return(1);\n+        return(1);\n@@ -2553,1 +2525,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2559,12 +2531,12 @@\n-    (node2->type == XML_ELEMENT_NODE) &&\n-    (0 > (ptrdiff_t) node1->content) &&\n-    (0 > (ptrdiff_t) node2->content) &&\n-    (node1->doc == node2->doc)) {\n-    ptrdiff_t l1, l2;\n-\n-    l1 = -((ptrdiff_t) node1->content);\n-    l2 = -((ptrdiff_t) node2->content);\n-    if (l1 < l2)\n-        return(1);\n-    if (l1 > l2)\n-        return(-1);\n+        (node2->type == XML_ELEMENT_NODE) &&\n+        (0 > XML_NODE_SORT_VALUE(node1)) &&\n+        (0 > XML_NODE_SORT_VALUE(node2)) &&\n+        (node1->doc == node2->doc)) {\n+        XML_INTPTR_T l1, l2;\n+\n+        l1 = -XML_NODE_SORT_VALUE(node1);\n+        l2 = -XML_NODE_SORT_VALUE(node2);\n+        if (l1 < l2)\n+            return(1);\n+        if (l1 > l2)\n+            return(-1);\n@@ -2577,3 +2549,3 @@\n-    if (cur->parent == node1)\n-        return(1);\n-    depth2++;\n+        if (cur->parent == node1)\n+            return(1);\n+        depth2++;\n@@ -2583,3 +2555,3 @@\n-    if (cur->parent == node2)\n-        return(-1);\n-    depth1++;\n+        if (cur->parent == node2)\n+            return(-1);\n+        depth1++;\n@@ -2591,1 +2563,1 @@\n-    return(-2);\n+        return(-2);\n@@ -2597,2 +2569,2 @@\n-    depth1--;\n-    node1 = node1->parent;\n+        depth1--;\n+        node1 = node1->parent;\n@@ -2601,2 +2573,2 @@\n-    depth2--;\n-    node2 = node2->parent;\n+        depth2--;\n+        node2 = node2->parent;\n@@ -2605,5 +2577,5 @@\n-    node1 = node1->parent;\n-    node2 = node2->parent;\n-    \/* should not happen but just in case ... *\/\n-    if ((node1 == NULL) || (node2 == NULL))\n-        return(-2);\n+        node1 = node1->parent;\n+        node2 = node2->parent;\n+        \/* should not happen but just in case ... *\/\n+        if ((node1 == NULL) || (node2 == NULL))\n+            return(-2);\n@@ -2615,1 +2587,1 @@\n-    return(1);\n+        return(1);\n@@ -2617,1 +2589,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2622,12 +2594,12 @@\n-    (node2->type == XML_ELEMENT_NODE) &&\n-    (0 > (ptrdiff_t) node1->content) &&\n-    (0 > (ptrdiff_t) node2->content) &&\n-    (node1->doc == node2->doc)) {\n-    ptrdiff_t l1, l2;\n-\n-    l1 = -((ptrdiff_t) node1->content);\n-    l2 = -((ptrdiff_t) node2->content);\n-    if (l1 < l2)\n-        return(1);\n-    if (l1 > l2)\n-        return(-1);\n+        (node2->type == XML_ELEMENT_NODE) &&\n+        (0 > XML_NODE_SORT_VALUE(node1)) &&\n+        (0 > XML_NODE_SORT_VALUE(node2)) &&\n+        (node1->doc == node2->doc)) {\n+        XML_INTPTR_T l1, l2;\n+\n+        l1 = -XML_NODE_SORT_VALUE(node1);\n+        l2 = -XML_NODE_SORT_VALUE(node2);\n+        if (l1 < l2)\n+            return(1);\n+        if (l1 > l2)\n+            return(-1);\n@@ -2637,2 +2609,2 @@\n-    if (cur == node2)\n-        return(1);\n+        if (cur == node2)\n+            return(1);\n@@ -2656,1 +2628,1 @@\n-    return;\n+        return;\n@@ -2665,3 +2637,3 @@\n-    for (i = incr; i < len; i++) {\n-        j = i - incr;\n-        while (j >= 0) {\n+        for (i = incr; i < len; i++) {\n+            j = i - incr;\n+            while (j >= 0) {\n@@ -2669,2 +2641,2 @@\n-        if (xmlXPathCmpNodesExt(set->nodeTab[j],\n-            set->nodeTab[j + incr]) == -1)\n+                if (xmlXPathCmpNodesExt(set->nodeTab[j],\n+                        set->nodeTab[j + incr]) == -1)\n@@ -2672,2 +2644,2 @@\n-        if (xmlXPathCmpNodes(set->nodeTab[j],\n-            set->nodeTab[j + incr]) == -1)\n+                if (xmlXPathCmpNodes(set->nodeTab[j],\n+                        set->nodeTab[j + incr]) == -1)\n@@ -2675,7 +2647,8 @@\n-        {\n-            tmp = set->nodeTab[j];\n-            set->nodeTab[j] = set->nodeTab[j + incr];\n-            set->nodeTab[j + incr] = tmp;\n-            j -= incr;\n-        } else\n-            break;\n+                {\n+                    tmp = set->nodeTab[j];\n+                    set->nodeTab[j] = set->nodeTab[j + incr];\n+                    set->nodeTab[j + incr] = tmp;\n+                    j -= incr;\n+                } else\n+                    break;\n+            }\n@@ -2684,1 +2657,0 @@\n-    }\n@@ -2690,1 +2662,1 @@\n-#define XML_NODESET_DEFAULT    10\n+#define XML_NODESET_DEFAULT     10\n@@ -2707,1 +2679,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2709,1 +2681,1 @@\n-    return((xmlNodePtr) ns);\n+        return((xmlNodePtr) ns);\n@@ -2716,1 +2688,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2720,1 +2692,1 @@\n-    cur->href = xmlStrdup(ns->href);\n+        cur->href = xmlStrdup(ns->href);\n@@ -2727,1 +2699,1 @@\n-    cur->prefix = xmlStrdup(ns->prefix);\n+        cur->prefix = xmlStrdup(ns->prefix);\n@@ -2749,1 +2721,1 @@\n-    return;\n+        return;\n@@ -2752,5 +2724,5 @@\n-    if (ns->href != NULL)\n-        xmlFree((xmlChar *)ns->href);\n-    if (ns->prefix != NULL)\n-        xmlFree((xmlChar *)ns->prefix);\n-    xmlFree(ns);\n+        if (ns->href != NULL)\n+            xmlFree((xmlChar *)ns->href);\n+        if (ns->prefix != NULL)\n+            xmlFree((xmlChar *)ns->prefix);\n+        xmlFree(ns);\n@@ -2774,1 +2746,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2778,7 +2750,7 @@\n-                         sizeof(xmlNodePtr));\n-    if (ret->nodeTab == NULL) {\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n-    memset(ret->nodeTab, 0 ,\n-           XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n+                                             sizeof(xmlNodePtr));\n+        if (ret->nodeTab == NULL) {\n+            xmlFree(ret);\n+            return(NULL);\n+        }\n+        memset(ret->nodeTab, 0 ,\n+               XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n@@ -2786,2 +2758,2 @@\n-    if (val->type == XML_NAMESPACE_DECL) {\n-        xmlNsPtr ns = (xmlNsPtr) val;\n+        if (val->type == XML_NAMESPACE_DECL) {\n+            xmlNsPtr ns = (xmlNsPtr) val;\n@@ -2794,3 +2766,3 @@\n-        ret->nodeTab[ret->nodeNr++] = nsNode;\n-    } else\n-        ret->nodeTab[ret->nodeNr++] = val;\n+            ret->nodeTab[ret->nodeNr++] = nsNode;\n+        } else\n+            ret->nodeTab[ret->nodeNr++] = val;\n@@ -2816,11 +2788,12 @@\n-    for (i = 0; i < cur->nodeNr; i++) {\n-        if (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) {\n-        xmlNsPtr ns1, ns2;\n-\n-        ns1 = (xmlNsPtr) val;\n-        ns2 = (xmlNsPtr) cur->nodeTab[i];\n-        if (ns1 == ns2)\n-            return(1);\n-        if ((ns1->next != NULL) && (ns2->next == ns1->next) &&\n-                (xmlStrEqual(ns1->prefix, ns2->prefix)))\n-            return(1);\n+        for (i = 0; i < cur->nodeNr; i++) {\n+            if (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) {\n+                xmlNsPtr ns1, ns2;\n+\n+                ns1 = (xmlNsPtr) val;\n+                ns2 = (xmlNsPtr) cur->nodeTab[i];\n+                if (ns1 == ns2)\n+                    return(1);\n+                if ((ns1->next != NULL) && (ns2->next == ns1->next) &&\n+                    (xmlStrEqual(ns1->prefix, ns2->prefix)))\n+                    return(1);\n+            }\n@@ -2828,1 +2801,0 @@\n-    }\n@@ -2830,4 +2802,4 @@\n-    for (i = 0; i < cur->nodeNr; i++) {\n-        if (cur->nodeTab[i] == val)\n-        return(1);\n-    }\n+        for (i = 0; i < cur->nodeNr; i++) {\n+            if (cur->nodeTab[i] == val)\n+                return(1);\n+        }\n@@ -2838,0 +2810,18 @@\n+static int\n+xmlXPathNodeSetGrow(xmlNodeSetPtr cur) {\n+    xmlNodePtr *temp;\n+    int newSize;\n+\n+    newSize = xmlGrowCapacity(cur->nodeMax, sizeof(temp[0]),\n+                              XML_NODESET_DEFAULT, XPATH_MAX_NODESET_LENGTH);\n+    if (newSize < 0)\n+        return(-1);\n+    temp = xmlRealloc(cur->nodeTab, newSize * sizeof(temp[0]));\n+    if (temp == NULL)\n+        return(-1);\n+    cur->nodeMax = newSize;\n+    cur->nodeTab = temp;\n+\n+    return(0);\n+}\n+\n@@ -2855,2 +2845,2 @@\n-    (node->type != XML_ELEMENT_NODE))\n-    return(-1);\n+        (node->type != XML_ELEMENT_NODE))\n+        return(-1);\n@@ -2864,4 +2854,4 @@\n-        (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) &&\n-        (((xmlNsPtr)cur->nodeTab[i])->next == (xmlNsPtr) node) &&\n-        (xmlStrEqual(ns->prefix, ((xmlNsPtr)cur->nodeTab[i])->prefix)))\n-        return(0);\n+            (cur->nodeTab[i]->type == XML_NAMESPACE_DECL) &&\n+            (((xmlNsPtr)cur->nodeTab[i])->next == (xmlNsPtr) node) &&\n+            (xmlStrEqual(ns->prefix, ((xmlNsPtr)cur->nodeTab[i])->prefix)))\n+            return(0);\n@@ -2873,12 +2863,2 @@\n-    if (cur->nodeMax == 0) {\n-        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n-                         sizeof(xmlNodePtr));\n-    if (cur->nodeTab == NULL)\n-        return(-1);\n-    memset(cur->nodeTab, 0 ,\n-           XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n-        cur->nodeMax = XML_NODESET_DEFAULT;\n-    } else if (cur->nodeNr == cur->nodeMax) {\n-        xmlNodePtr *temp;\n-\n-        if (cur->nodeMax >= XPATH_MAX_NODESET_LENGTH)\n+    if (cur->nodeNr >= cur->nodeMax) {\n+        if (xmlXPathNodeSetGrow(cur) < 0)\n@@ -2886,6 +2866,0 @@\n-    temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n-                      sizeof(xmlNodePtr));\n-    if (temp == NULL)\n-        return(-1);\n-        cur->nodeMax *= 2;\n-    cur->nodeTab = temp;\n@@ -2925,12 +2899,2 @@\n-    if (cur->nodeMax == 0) {\n-        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n-                         sizeof(xmlNodePtr));\n-    if (cur->nodeTab == NULL)\n-        return(-1);\n-    memset(cur->nodeTab, 0 ,\n-           XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n-        cur->nodeMax = XML_NODESET_DEFAULT;\n-    } else if (cur->nodeNr == cur->nodeMax) {\n-        xmlNodePtr *temp;\n-\n-        if (cur->nodeMax >= XPATH_MAX_NODESET_LENGTH)\n+    if (cur->nodeNr >= cur->nodeMax) {\n+        if (xmlXPathNodeSetGrow(cur) < 0)\n@@ -2938,6 +2902,0 @@\n-    temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n-                      sizeof(xmlNodePtr));\n-    if (temp == NULL)\n-        return(-1);\n-        cur->nodeMax *= 2;\n-    cur->nodeTab = temp;\n@@ -2945,0 +2903,1 @@\n+\n@@ -2946,1 +2905,1 @@\n-    xmlNsPtr ns = (xmlNsPtr) val;\n+        xmlNsPtr ns = (xmlNsPtr) val;\n@@ -2951,1 +2910,1 @@\n-    cur->nodeTab[cur->nodeNr++] = nsNode;\n+        cur->nodeTab[cur->nodeNr++] = nsNode;\n@@ -2953,1 +2912,1 @@\n-    cur->nodeTab[cur->nodeNr++] = val;\n+        cur->nodeTab[cur->nodeNr++] = val;\n@@ -2975,12 +2934,2 @@\n-    if (cur->nodeMax == 0) {\n-        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n-                         sizeof(xmlNodePtr));\n-    if (cur->nodeTab == NULL)\n-        return(-1);\n-    memset(cur->nodeTab, 0 ,\n-           XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n-        cur->nodeMax = XML_NODESET_DEFAULT;\n-    } else if (cur->nodeNr == cur->nodeMax) {\n-        xmlNodePtr *temp;\n-\n-        if (cur->nodeMax >= XPATH_MAX_NODESET_LENGTH)\n+    if (cur->nodeNr >= cur->nodeMax) {\n+        if (xmlXPathNodeSetGrow(cur) < 0)\n@@ -2988,6 +2937,0 @@\n-    temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax * 2 *\n-                      sizeof(xmlNodePtr));\n-    if (temp == NULL)\n-        return(-1);\n-    cur->nodeTab = temp;\n-        cur->nodeMax *= 2;\n@@ -2995,0 +2938,1 @@\n+\n@@ -2996,1 +2940,1 @@\n-    xmlNsPtr ns = (xmlNsPtr) val;\n+        xmlNsPtr ns = (xmlNsPtr) val;\n@@ -3001,1 +2945,1 @@\n-    cur->nodeTab[cur->nodeNr++] = nsNode;\n+        cur->nodeTab[cur->nodeNr++] = nsNode;\n@@ -3003,1 +2947,1 @@\n-    cur->nodeTab[cur->nodeNr++] = val;\n+        cur->nodeTab[cur->nodeNr++] = val;\n@@ -3025,1 +2969,1 @@\n-    val1 = xmlXPathNodeSetCreate(NULL);\n+        val1 = xmlXPathNodeSetCreate(NULL);\n@@ -3036,19 +2980,20 @@\n-    n2 = val2->nodeTab[i];\n-    \/*\n-     * check against duplicates\n-     *\/\n-    skip = 0;\n-    for (j = 0; j < initNr; j++) {\n-        n1 = val1->nodeTab[j];\n-        if (n1 == n2) {\n-        skip = 1;\n-        break;\n-        } else if ((n1->type == XML_NAMESPACE_DECL) &&\n-               (n2->type == XML_NAMESPACE_DECL)) {\n-        if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n-            (xmlStrEqual(((xmlNsPtr) n1)->prefix,\n-            ((xmlNsPtr) n2)->prefix)))\n-        {\n-            skip = 1;\n-            break;\n-        }\n+        n2 = val2->nodeTab[i];\n+        \/*\n+         * check against duplicates\n+         *\/\n+        skip = 0;\n+        for (j = 0; j < initNr; j++) {\n+            n1 = val1->nodeTab[j];\n+            if (n1 == n2) {\n+                skip = 1;\n+                break;\n+            } else if ((n1->type == XML_NAMESPACE_DECL) &&\n+                       (n2->type == XML_NAMESPACE_DECL)) {\n+                if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n+                    (xmlStrEqual(((xmlNsPtr) n1)->prefix,\n+                        ((xmlNsPtr) n2)->prefix)))\n+                {\n+                    skip = 1;\n+                    break;\n+                }\n+            }\n@@ -3056,17 +3001,2 @@\n-    }\n-    if (skip)\n-        continue;\n-\n-    \/*\n-     * grow the nodeTab if needed\n-     *\/\n-    if (val1->nodeMax == 0) {\n-        val1->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n-                            sizeof(xmlNodePtr));\n-        if (val1->nodeTab == NULL)\n-        goto error;\n-        memset(val1->nodeTab, 0 ,\n-           XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n-        val1->nodeMax = XML_NODESET_DEFAULT;\n-    } else if (val1->nodeNr == val1->nodeMax) {\n-        xmlNodePtr *temp;\n+        if (skip)\n+            continue;\n@@ -3074,1 +3004,5 @@\n-            if (val1->nodeMax >= XPATH_MAX_NODESET_LENGTH)\n+        \/*\n+         * grow the nodeTab if needed\n+         *\/\n+        if (val1->nodeNr >= val1->nodeMax) {\n+            if (xmlXPathNodeSetGrow(val1) < 0)\n@@ -3076,9 +3010,3 @@\n-        temp = (xmlNodePtr *) xmlRealloc(val1->nodeTab, val1->nodeMax * 2 *\n-                         sizeof(xmlNodePtr));\n-        if (temp == NULL)\n-        goto error;\n-        val1->nodeTab = temp;\n-        val1->nodeMax *= 2;\n-    }\n-    if (n2->type == XML_NAMESPACE_DECL) {\n-        xmlNsPtr ns = (xmlNsPtr) n2;\n+        }\n+        if (n2->type == XML_NAMESPACE_DECL) {\n+            xmlNsPtr ns = (xmlNsPtr) n2;\n@@ -3089,3 +3017,3 @@\n-        val1->nodeTab[val1->nodeNr++] = nsNode;\n-    } else\n-        val1->nodeTab[val1->nodeNr++] = n2;\n+            val1->nodeTab[val1->nodeNr++] = nsNode;\n+        } else\n+            val1->nodeTab[val1->nodeNr++] = n2;\n@@ -3118,2 +3046,2 @@\n-    int i, j, initNbSet1;\n-    xmlNodePtr n1, n2;\n+        int i, j, initNbSet1;\n+        xmlNodePtr n1, n2;\n@@ -3121,17 +3049,3 @@\n-    initNbSet1 = set1->nodeNr;\n-    for (i = 0;i < set2->nodeNr;i++) {\n-        n2 = set2->nodeTab[i];\n-        \/*\n-        * Skip duplicates.\n-        *\/\n-        for (j = 0; j < initNbSet1; j++) {\n-        n1 = set1->nodeTab[j];\n-        if (n1 == n2) {\n-            goto skip_node;\n-        } else if ((n1->type == XML_NAMESPACE_DECL) &&\n-            (n2->type == XML_NAMESPACE_DECL))\n-        {\n-            if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n-            (xmlStrEqual(((xmlNsPtr) n1)->prefix,\n-            ((xmlNsPtr) n2)->prefix)))\n-            {\n+        initNbSet1 = set1->nodeNr;\n+        for (i = 0;i < set2->nodeNr;i++) {\n+            n2 = set2->nodeTab[i];\n@@ -3139,1 +3053,1 @@\n-            * Free the namespace node.\n+            * Skip duplicates.\n@@ -3141,2 +3055,18 @@\n-            xmlXPathNodeSetFreeNs((xmlNsPtr) n2);\n-            goto skip_node;\n+            for (j = 0; j < initNbSet1; j++) {\n+                n1 = set1->nodeTab[j];\n+                if (n1 == n2) {\n+                    goto skip_node;\n+                } else if ((n1->type == XML_NAMESPACE_DECL) &&\n+                    (n2->type == XML_NAMESPACE_DECL))\n+                {\n+                    if ((((xmlNsPtr) n1)->next == ((xmlNsPtr) n2)->next) &&\n+                        (xmlStrEqual(((xmlNsPtr) n1)->prefix,\n+                        ((xmlNsPtr) n2)->prefix)))\n+                    {\n+                        \/*\n+                        * Free the namespace node.\n+                        *\/\n+                        xmlXPathNodeSetFreeNs((xmlNsPtr) n2);\n+                        goto skip_node;\n+                    }\n+                }\n@@ -3144,17 +3074,5 @@\n-        }\n-        }\n-        \/*\n-        * grow the nodeTab if needed\n-        *\/\n-        if (set1->nodeMax == 0) {\n-        set1->nodeTab = (xmlNodePtr *) xmlMalloc(\n-            XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n-        if (set1->nodeTab == NULL)\n-            goto error;\n-        memset(set1->nodeTab, 0,\n-            XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n-        set1->nodeMax = XML_NODESET_DEFAULT;\n-        } else if (set1->nodeNr >= set1->nodeMax) {\n-        xmlNodePtr *temp;\n-\n-                if (set1->nodeMax >= XPATH_MAX_NODESET_LENGTH)\n+            \/*\n+            * grow the nodeTab if needed\n+            *\/\n+            if (set1->nodeNr >= set1->nodeMax) {\n+                if (xmlXPathNodeSetGrow(set1) < 0)\n@@ -3162,8 +3080,2 @@\n-        temp = (xmlNodePtr *) xmlRealloc(\n-            set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));\n-        if (temp == NULL)\n-            goto error;\n-        set1->nodeTab = temp;\n-        set1->nodeMax *= 2;\n-        }\n-        set1->nodeTab[set1->nodeNr++] = n2;\n+            }\n+            set1->nodeTab[set1->nodeNr++] = n2;\n@@ -3172,1 +3084,1 @@\n-    }\n+        }\n@@ -3199,15 +3111,2 @@\n-    int i;\n-    xmlNodePtr n2;\n-\n-    for (i = 0;i < set2->nodeNr;i++) {\n-        n2 = set2->nodeTab[i];\n-        if (set1->nodeMax == 0) {\n-        set1->nodeTab = (xmlNodePtr *) xmlMalloc(\n-            XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n-        if (set1->nodeTab == NULL)\n-            goto error;\n-        memset(set1->nodeTab, 0,\n-            XML_NODESET_DEFAULT * sizeof(xmlNodePtr));\n-        set1->nodeMax = XML_NODESET_DEFAULT;\n-        } else if (set1->nodeNr >= set1->nodeMax) {\n-        xmlNodePtr *temp;\n+        int i;\n+        xmlNodePtr n2;\n@@ -3215,1 +3114,4 @@\n-                if (set1->nodeMax >= XPATH_MAX_NODESET_LENGTH)\n+        for (i = 0;i < set2->nodeNr;i++) {\n+            n2 = set2->nodeTab[i];\n+            if (set1->nodeNr >= set1->nodeMax) {\n+                if (xmlXPathNodeSetGrow(set1) < 0)\n@@ -3217,8 +3119,2 @@\n-        temp = (xmlNodePtr *) xmlRealloc(\n-            set1->nodeTab, set1->nodeMax * 2 * sizeof(xmlNodePtr));\n-        if (temp == NULL)\n-            goto error;\n-        set1->nodeTab = temp;\n-        set1->nodeMax *= 2;\n-        }\n-        set1->nodeTab[set1->nodeNr++] = n2;\n+            }\n+            set1->nodeTab[set1->nodeNr++] = n2;\n@@ -3226,1 +3122,1 @@\n-    }\n+        }\n@@ -3257,1 +3153,1 @@\n-    if (i >= cur->nodeNr) {    \/* not found *\/\n+    if (i >= cur->nodeNr) {     \/* not found *\/\n@@ -3261,2 +3157,2 @@\n-    (cur->nodeTab[i]->type == XML_NAMESPACE_DECL))\n-    xmlXPathNodeSetFreeNs((xmlNsPtr) cur->nodeTab[i]);\n+        (cur->nodeTab[i]->type == XML_NAMESPACE_DECL))\n+        xmlXPathNodeSetFreeNs((xmlNsPtr) cur->nodeTab[i]);\n@@ -3281,2 +3177,2 @@\n-    (cur->nodeTab[val]->type == XML_NAMESPACE_DECL))\n-    xmlXPathNodeSetFreeNs((xmlNsPtr) cur->nodeTab[val]);\n+        (cur->nodeTab[val]->type == XML_NAMESPACE_DECL))\n+        xmlXPathNodeSetFreeNs((xmlNsPtr) cur->nodeTab[val]);\n@@ -3299,1 +3195,1 @@\n-    int i;\n+        int i;\n@@ -3301,6 +3197,6 @@\n-    \/* @@ with_ns to check whether namespace nodes should be looked at @@ *\/\n-    for (i = 0;i < obj->nodeNr;i++)\n-        if ((obj->nodeTab[i] != NULL) &&\n-        (obj->nodeTab[i]->type == XML_NAMESPACE_DECL))\n-        xmlXPathNodeSetFreeNs((xmlNsPtr) obj->nodeTab[i]);\n-    xmlFree(obj->nodeTab);\n+        \/* @@ with_ns to check whether namespace nodes should be looked at @@ *\/\n+        for (i = 0;i < obj->nodeNr;i++)\n+            if ((obj->nodeTab[i] != NULL) &&\n+                (obj->nodeTab[i]->type == XML_NAMESPACE_DECL))\n+                xmlXPathNodeSetFreeNs((xmlNsPtr) obj->nodeTab[i]);\n+        xmlFree(obj->nodeTab);\n@@ -3324,1 +3220,1 @@\n-    return;\n+        return;\n@@ -3326,2 +3222,2 @@\n-    int i;\n-    xmlNodePtr node;\n+        int i;\n+        xmlNodePtr node;\n@@ -3329,6 +3225,6 @@\n-    for (i = pos; i < set->nodeNr; i++) {\n-        node = set->nodeTab[i];\n-        if ((node != NULL) &&\n-        (node->type == XML_NAMESPACE_DECL))\n-        xmlXPathNodeSetFreeNs((xmlNsPtr) node);\n-    }\n+        for (i = pos; i < set->nodeNr; i++) {\n+            node = set->nodeTab[i];\n+            if ((node != NULL) &&\n+                (node->type == XML_NAMESPACE_DECL))\n+                xmlXPathNodeSetFreeNs((xmlNsPtr) node);\n+        }\n@@ -3368,1 +3264,1 @@\n-    return;\n+        return;\n@@ -3394,1 +3290,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3422,1 +3318,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3477,1 +3373,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3516,1 +3412,1 @@\n-    return(nodes1);\n+        return(nodes1);\n@@ -3522,1 +3418,1 @@\n-    return(ret);\n+        return(ret);\n@@ -3527,3 +3423,3 @@\n-    cur = xmlXPathNodeSetItem(nodes1, i);\n-    if (!xmlXPathNodeSetContains(nodes2, cur)) {\n-        if (xmlXPathNodeSetAddUnique(ret, cur) < 0) {\n+        cur = xmlXPathNodeSetItem(nodes1, i);\n+        if (!xmlXPathNodeSetContains(nodes2, cur)) {\n+            if (xmlXPathNodeSetAddUnique(ret, cur) < 0) {\n@@ -3531,1 +3427,1 @@\n-            return(NULL);\n+                return(NULL);\n@@ -3533,1 +3429,1 @@\n-    }\n+        }\n@@ -3558,1 +3454,1 @@\n-    return(ret);\n+        return(ret);\n@@ -3560,1 +3456,1 @@\n-    return(ret);\n+        return(ret);\n@@ -3565,3 +3461,3 @@\n-    cur = xmlXPathNodeSetItem(nodes1, i);\n-    if (xmlXPathNodeSetContains(nodes2, cur)) {\n-        if (xmlXPathNodeSetAddUnique(ret, cur) < 0) {\n+        cur = xmlXPathNodeSetItem(nodes1, i);\n+        if (xmlXPathNodeSetContains(nodes2, cur)) {\n+            if (xmlXPathNodeSetAddUnique(ret, cur) < 0) {\n@@ -3569,1 +3465,1 @@\n-            return(NULL);\n+                return(NULL);\n@@ -3571,1 +3467,1 @@\n-    }\n+        }\n@@ -3595,1 +3491,1 @@\n-    return(nodes);\n+        return(nodes);\n@@ -3603,4 +3499,4 @@\n-    cur = xmlXPathNodeSetItem(nodes, i);\n-    strval = xmlXPathCastNodeToString(cur);\n-    if (xmlHashLookup(hash, strval) == NULL) {\n-        if (xmlHashAddEntry(hash, strval, strval) < 0) {\n+        cur = xmlXPathNodeSetItem(nodes, i);\n+        strval = xmlXPathCastNodeToString(cur);\n+        if (xmlHashLookup(hash, strval) == NULL) {\n+            if (xmlHashAddEntry(hash, strval, strval) < 0) {\n@@ -3610,5 +3506,5 @@\n-        if (xmlXPathNodeSetAddUnique(ret, cur) < 0)\n-            goto error;\n-    } else {\n-        xmlFree(strval);\n-    }\n+            if (xmlXPathNodeSetAddUnique(ret, cur) < 0)\n+                goto error;\n+        } else {\n+            xmlFree(strval);\n+        }\n@@ -3640,1 +3536,1 @@\n-    return(nodes);\n+        return(nodes);\n@@ -3663,2 +3559,2 @@\n-    xmlXPathNodeSetIsEmpty(nodes2))\n-    return(0);\n+        xmlXPathNodeSetIsEmpty(nodes2))\n+        return(0);\n@@ -3668,3 +3564,3 @@\n-    cur = xmlXPathNodeSetItem(nodes1, i);\n-    if (xmlXPathNodeSetContains(nodes2, cur))\n-        return(1);\n+        cur = xmlXPathNodeSetItem(nodes1, i);\n+        if (xmlXPathNodeSetContains(nodes2, cur))\n+            return(1);\n@@ -3694,1 +3590,1 @@\n-    return(nodes);\n+        return(nodes);\n@@ -3700,2 +3596,2 @@\n-    (!xmlXPathNodeSetContains(nodes, node)))\n-    return(ret);\n+        (!xmlXPathNodeSetContains(nodes, node)))\n+        return(ret);\n@@ -3705,4 +3601,4 @@\n-    cur = xmlXPathNodeSetItem(nodes, i);\n-    if (cur == node)\n-        break;\n-    if (xmlXPathNodeSetAddUnique(ret, cur) < 0) {\n+        cur = xmlXPathNodeSetItem(nodes, i);\n+        if (cur == node)\n+            break;\n+        if (xmlXPathNodeSetAddUnique(ret, cur) < 0) {\n@@ -3710,1 +3606,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -3751,1 +3647,1 @@\n-    return(nodes1);\n+        return(nodes1);\n@@ -3753,1 +3649,1 @@\n-                     xmlXPathNodeSetItem(nodes2, 1)));\n+                                     xmlXPathNodeSetItem(nodes2, 1)));\n@@ -3773,1 +3669,1 @@\n-    return(nodes1);\n+        return(nodes1);\n@@ -3775,1 +3671,1 @@\n-    return(xmlXPathNodeSetCreate(NULL));\n+        return(xmlXPathNodeSetCreate(NULL));\n@@ -3779,1 +3675,1 @@\n-                     xmlXPathNodeSetItem(nodes2, 1)));\n+                                     xmlXPathNodeSetItem(nodes2, 1)));\n@@ -3801,1 +3697,1 @@\n-    return(nodes);\n+        return(nodes);\n@@ -3807,2 +3703,2 @@\n-    (!xmlXPathNodeSetContains(nodes, node)))\n-    return(ret);\n+        (!xmlXPathNodeSetContains(nodes, node)))\n+        return(ret);\n@@ -3812,4 +3708,4 @@\n-    cur = xmlXPathNodeSetItem(nodes, i);\n-    if (cur == node)\n-        break;\n-    if (xmlXPathNodeSetAddUnique(ret, cur) < 0) {\n+        cur = xmlXPathNodeSetItem(nodes, i);\n+        if (cur == node)\n+            break;\n+        if (xmlXPathNodeSetAddUnique(ret, cur) < 0) {\n@@ -3817,1 +3713,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -3820,1 +3716,1 @@\n-    xmlXPathNodeSetSort(ret);    \/* bug 413451 *\/\n+    xmlXPathNodeSetSort(ret);   \/* bug 413451 *\/\n@@ -3859,1 +3755,1 @@\n-    return(nodes1);\n+        return(nodes1);\n@@ -3861,1 +3757,1 @@\n-                      xmlXPathNodeSetItem(nodes2, 0)));\n+                                      xmlXPathNodeSetItem(nodes2, 0)));\n@@ -3881,1 +3777,1 @@\n-    return(nodes1);\n+        return(nodes1);\n@@ -3883,1 +3779,1 @@\n-    return(xmlXPathNodeSetCreate(NULL));\n+        return(xmlXPathNodeSetCreate(NULL));\n@@ -3887,1 +3783,1 @@\n-                      xmlXPathNodeSetItem(nodes2, 0)));\n+                                      xmlXPathNodeSetItem(nodes2, 0)));\n@@ -3891,3 +3787,3 @@\n- *                                    *\n- *        Routines to handle extra functions            *\n- *                                    *\n+ *                                                                      *\n+ *              Routines to handle extra functions                      *\n+ *                                                                      *\n@@ -3908,1 +3804,1 @@\n-             xmlXPathFunction f) {\n+                     xmlXPathFunction f) {\n@@ -3925,1 +3821,1 @@\n-               const xmlChar *ns_uri, xmlXPathFunction f) {\n+                       const xmlChar *ns_uri, xmlXPathFunction f) {\n@@ -3927,0 +3823,1 @@\n+    void *payload;\n@@ -3929,1 +3826,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3931,1 +3828,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3934,1 +3831,1 @@\n-    ctxt->funcHash = xmlHashCreate(0);\n+        ctxt->funcHash = xmlHashCreate(0);\n@@ -3937,1 +3834,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3941,3 +3838,2 @@\n-XML_IGNORE_FPTR_CAST_WARNINGS\n-    ret = xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, (void *) f);\n-XML_POP_WARNINGS\n+    memcpy(&payload, &f, sizeof(f));\n+    ret = xmlHashAddEntry2(ctxt->funcHash, name, ns_uri, payload);\n@@ -3962,2 +3858,2 @@\n-                xmlXPathFuncLookupFunc f,\n-                void *funcCtxt) {\n+                            xmlXPathFuncLookupFunc f,\n+                            void *funcCtxt) {\n@@ -3965,1 +3861,1 @@\n-    return;\n+        return;\n@@ -3982,12 +3878,0 @@\n-    if (ctxt == NULL)\n-    return (NULL);\n-\n-    if (ctxt->funcLookupFunc != NULL) {\n-    xmlXPathFunction ret;\n-    xmlXPathFuncLookupFunc f;\n-\n-    f = ctxt->funcLookupFunc;\n-    ret = f(ctxt->funcLookupData, name, NULL);\n-    if (ret != NULL)\n-        return(ret);\n-    }\n@@ -4010,1 +3894,1 @@\n-             const xmlChar *ns_uri) {\n+                         const xmlChar *ns_uri) {\n@@ -4012,0 +3896,1 @@\n+    void *payload;\n@@ -4014,1 +3899,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4016,1 +3901,17 @@\n-    return(NULL);\n+        return(NULL);\n+\n+    if (ns_uri == NULL) {\n+        int bucketIndex = xmlXPathSFComputeHash(name) % SF_HASH_SIZE;\n+\n+        while (xmlXPathSFHash[bucketIndex] != UCHAR_MAX) {\n+            int funcIndex = xmlXPathSFHash[bucketIndex];\n+\n+            if (strcmp(xmlXPathStandardFunctions[funcIndex].name,\n+                       (char *) name) == 0)\n+                return(xmlXPathStandardFunctions[funcIndex].func);\n+\n+            bucketIndex += 1;\n+            if (bucketIndex >= SF_HASH_SIZE)\n+                bucketIndex = 0;\n+        }\n+    }\n@@ -4019,1 +3920,1 @@\n-    xmlXPathFuncLookupFunc f;\n+        xmlXPathFuncLookupFunc f;\n@@ -4021,4 +3922,4 @@\n-    f = ctxt->funcLookupFunc;\n-    ret = f(ctxt->funcLookupData, name, ns_uri);\n-    if (ret != NULL)\n-        return(ret);\n+        f = ctxt->funcLookupFunc;\n+        ret = f(ctxt->funcLookupData, name, ns_uri);\n+        if (ret != NULL)\n+            return(ret);\n@@ -4028,1 +3929,4 @@\n-    return(NULL);\n+        return(NULL);\n+\n+    payload = xmlHashLookup2(ctxt->funcHash, name, ns_uri);\n+    memcpy(&ret, &payload, sizeof(payload));\n@@ -4030,3 +3934,0 @@\n-XML_IGNORE_FPTR_CAST_WARNINGS\n-    ret = (xmlXPathFunction) xmlHashLookup2(ctxt->funcHash, name, ns_uri);\n-XML_POP_WARNINGS\n@@ -4045,1 +3946,1 @@\n-    return;\n+        return;\n@@ -4052,3 +3953,3 @@\n- *                                    *\n- *            Routines to handle Variables            *\n- *                                    *\n+ *                                                                      *\n+ *                      Routines to handle Variables                    *\n+ *                                                                      *\n@@ -4070,1 +3971,1 @@\n-             xmlXPathObjectPtr value) {\n+                         xmlXPathObjectPtr value) {\n@@ -4088,2 +3989,2 @@\n-               const xmlChar *ns_uri,\n-               xmlXPathObjectPtr value) {\n+                           const xmlChar *ns_uri,\n+                           xmlXPathObjectPtr value) {\n@@ -4091,1 +3992,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4093,1 +3994,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4096,1 +3997,1 @@\n-    ctxt->varHash = xmlHashCreate(0);\n+        ctxt->varHash = xmlHashCreate(0);\n@@ -4098,1 +3999,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4101,1 +4002,1 @@\n-                               xmlXPathFreeObjectEntry));\n+                                   xmlXPathFreeObjectEntry));\n@@ -4103,1 +4004,1 @@\n-                   (void *) value, xmlXPathFreeObjectEntry));\n+                               (void *) value, xmlXPathFreeObjectEntry));\n@@ -4116,1 +4017,1 @@\n-     xmlXPathVariableLookupFunc f, void *data) {\n+         xmlXPathVariableLookupFunc f, void *data) {\n@@ -4118,1 +4019,1 @@\n-    return;\n+        return;\n@@ -4136,1 +4037,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4139,1 +4040,1 @@\n-    xmlXPathObjectPtr ret;\n+        xmlXPathObjectPtr ret;\n@@ -4141,3 +4042,3 @@\n-    ret = ((xmlXPathVariableLookupFunc)ctxt->varLookupFunc)\n-            (ctxt->varLookupData, name, NULL);\n-    return(ret);\n+        ret = ((xmlXPathVariableLookupFunc)ctxt->varLookupFunc)\n+                (ctxt->varLookupData, name, NULL);\n+        return(ret);\n@@ -4161,1 +4062,1 @@\n-             const xmlChar *ns_uri) {\n+                         const xmlChar *ns_uri) {\n@@ -4163,1 +4064,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4166,1 +4067,1 @@\n-    xmlXPathObjectPtr ret;\n+        xmlXPathObjectPtr ret;\n@@ -4168,3 +4069,3 @@\n-    ret = ((xmlXPathVariableLookupFunc)ctxt->varLookupFunc)\n-            (ctxt->varLookupData, name, ns_uri);\n-    if (ret != NULL) return(ret);\n+        ret = ((xmlXPathVariableLookupFunc)ctxt->varLookupFunc)\n+                (ctxt->varLookupData, name, ns_uri);\n+        if (ret != NULL) return(ret);\n@@ -4174,1 +4075,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4176,1 +4077,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4190,1 +4091,1 @@\n-    return;\n+        return;\n@@ -4209,1 +4110,1 @@\n-               const xmlChar *ns_uri) {\n+                           const xmlChar *ns_uri) {\n@@ -4213,1 +4114,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4215,1 +4116,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4217,1 +4118,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4220,1 +4121,1 @@\n-    ctxt->nsHash = xmlHashCreate(10);\n+        ctxt->nsHash = xmlHashCreate(10);\n@@ -4223,1 +4124,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4227,1 +4128,1 @@\n-                              xmlHashDefaultDeallocator));\n+                                  xmlHashDefaultDeallocator));\n@@ -4257,1 +4158,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4259,1 +4160,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4262,1 +4163,1 @@\n-    return(XML_XML_NAMESPACE);\n+        return(XML_XML_NAMESPACE);\n@@ -4265,1 +4166,1 @@\n-    int i;\n+        int i;\n@@ -4267,5 +4168,5 @@\n-    for (i = 0;i < ctxt->nsNr;i++) {\n-        if ((ctxt->namespaces[i] != NULL) &&\n-        (xmlStrEqual(ctxt->namespaces[i]->prefix, prefix)))\n-        return(ctxt->namespaces[i]->href);\n-    }\n+        for (i = 0;i < ctxt->nsNr;i++) {\n+            if ((ctxt->namespaces[i] != NULL) &&\n+                (xmlStrEqual(ctxt->namespaces[i]->prefix, prefix)))\n+                return(ctxt->namespaces[i]->href);\n+        }\n@@ -4286,1 +4187,1 @@\n-    return;\n+        return;\n@@ -4293,3 +4194,3 @@\n- *                                    *\n- *            Routines to handle Values            *\n- *                                    *\n+ *                                                                      *\n+ *                      Routines to handle Values                       *\n+ *                                                                      *\n@@ -4314,1 +4215,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4335,1 +4236,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4356,1 +4257,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4386,1 +4287,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4434,1 +4335,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4454,1 +4355,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4458,1 +4359,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4461,9 +4362,5 @@\n-    case XPATH_BOOLEAN:\n-    case XPATH_NUMBER:\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    case XPATH_POINT:\n-    case XPATH_RANGE:\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-        break;\n-    case XPATH_STRING:\n-        ret->stringval = xmlStrdup(val->stringval);\n+        case XPATH_BOOLEAN:\n+        case XPATH_NUMBER:\n+            break;\n+        case XPATH_STRING:\n+            ret->stringval = xmlStrdup(val->stringval);\n@@ -4474,36 +4371,4 @@\n-        break;\n-    case XPATH_XSLT_TREE:\n-#if 0\n-\/*\n-  Removed 11 July 2004 - the current handling of xslt tmpRVT nodes means that\n-  this previous handling is no longer correct, and can cause some serious\n-  problems (ref. bug 145547)\n-*\/\n-        if ((val->nodesetval != NULL) &&\n-        (val->nodesetval->nodeTab != NULL)) {\n-        xmlNodePtr cur, tmp;\n-        xmlDocPtr top;\n-\n-        ret->boolval = 1;\n-        top =  xmlNewDoc(NULL);\n-        top->name = (char *)\n-            xmlStrdup(val->nodesetval->nodeTab[0]->name);\n-        ret->user = top;\n-        if (top != NULL) {\n-            top->doc = top;\n-            cur = val->nodesetval->nodeTab[0]->children;\n-            while (cur != NULL) {\n-            tmp = xmlDocCopyNode(cur, top, 1);\n-            xmlAddChild((xmlNodePtr) top, tmp);\n-            cur = cur->next;\n-            }\n-        }\n-\n-        ret->nodesetval = xmlXPathNodeSetCreate((xmlNodePtr) top);\n-        } else\n-        ret->nodesetval = xmlXPathNodeSetCreate(NULL);\n-        \/* Deallocate the copied tree value *\/\n-        break;\n-#endif\n-    case XPATH_NODESET:\n-        ret->nodesetval = xmlXPathNodeSetMerge(NULL, val->nodesetval);\n+            break;\n+        case XPATH_XSLT_TREE:\n+        case XPATH_NODESET:\n+            ret->nodesetval = xmlXPathNodeSetMerge(NULL, val->nodesetval);\n@@ -4514,11 +4379,3 @@\n-        \/* Do not deallocate the copied tree value *\/\n-        ret->boolval = 0;\n-        break;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    case XPATH_LOCATIONSET:\n-    {\n-        xmlLocationSetPtr loc = val->user;\n-        ret->user = (void *) xmlXPtrLocationSetMerge(NULL, loc);\n-        break;\n-    }\n-#endif\n+            \/* Do not deallocate the copied tree value *\/\n+            ret->boolval = 0;\n+            break;\n@@ -4526,2 +4383,2 @@\n-        ret->user = val->user;\n-        break;\n+            ret->user = val->user;\n+            break;\n@@ -4531,1 +4388,1 @@\n-        break;\n+            break;\n@@ -4548,5 +4405,0 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    } else if (obj->type == XPATH_LOCATIONSET) {\n-    if (obj->user != NULL)\n-        xmlXPtrFreeLocationSet(obj->user);\n-#endif\n@@ -4554,2 +4406,2 @@\n-    if (obj->stringval != NULL)\n-        xmlFree(obj->stringval);\n+        if (obj->stringval != NULL)\n+            xmlFree(obj->stringval);\n@@ -4576,1 +4428,1 @@\n-    return;\n+        return;\n@@ -4578,1 +4430,1 @@\n-     xmlXPathFreeObject(obj);\n+         xmlXPathFreeObject(obj);\n@@ -4580,9 +4432,9 @@\n-    xmlXPathContextCachePtr cache =\n-        (xmlXPathContextCachePtr) ctxt->cache;\n-\n-    switch (obj->type) {\n-        case XPATH_NODESET:\n-        case XPATH_XSLT_TREE:\n-        if (obj->nodesetval != NULL) {\n-            if ((obj->nodesetval->nodeMax <= 40) &&\n-            (cache->numNodeset < cache->maxNodeset)) {\n+        xmlXPathContextCachePtr cache =\n+            (xmlXPathContextCachePtr) ctxt->cache;\n+\n+        switch (obj->type) {\n+            case XPATH_NODESET:\n+            case XPATH_XSLT_TREE:\n+                if (obj->nodesetval != NULL) {\n+                    if ((obj->nodesetval->nodeMax <= 40) &&\n+                        (cache->numNodeset < cache->maxNodeset)) {\n@@ -4592,10 +4444,10 @@\n-            goto obj_cached;\n-            } else {\n-            xmlXPathFreeNodeSet(obj->nodesetval);\n-            obj->nodesetval = NULL;\n-            }\n-        }\n-        break;\n-        case XPATH_STRING:\n-        if (obj->stringval != NULL)\n-            xmlFree(obj->stringval);\n+                        goto obj_cached;\n+                    } else {\n+                        xmlXPathFreeNodeSet(obj->nodesetval);\n+                        obj->nodesetval = NULL;\n+                    }\n+                }\n+                break;\n+            case XPATH_STRING:\n+                if (obj->stringval != NULL)\n+                    xmlFree(obj->stringval);\n@@ -4603,8 +4455,6 @@\n-        break;\n-        case XPATH_BOOLEAN:\n-        case XPATH_NUMBER:\n-        break;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        case XPATH_LOCATIONSET:\n-        if (obj->user != NULL) {\n-            xmlXPtrFreeLocationSet(obj->user);\n+                break;\n+            case XPATH_BOOLEAN:\n+            case XPATH_NUMBER:\n+                break;\n+            default:\n+                goto free_obj;\n@@ -4612,5 +4462,0 @@\n-        goto free_obj;\n-#endif\n-        default:\n-        goto free_obj;\n-    }\n@@ -4618,3 +4463,3 @@\n-    \/*\n-    * Fallback to adding to the misc-objects slot.\n-    *\/\n+        \/*\n+        * Fallback to adding to the misc-objects slot.\n+        *\/\n@@ -4622,1 +4467,1 @@\n-        goto free_obj;\n+            goto free_obj;\n@@ -4629,10 +4474,2 @@\n-    if (obj->nodesetval != NULL) {\n-        xmlNodeSetPtr tmpset = obj->nodesetval;\n-\n-        \/*\n-        * Due to those nasty ns-nodes, we need to traverse\n-        * the list and free the ns-nodes.\n-        *\/\n-        if (tmpset->nodeNr > 0) {\n-        int i;\n-        xmlNodePtr node;\n+        if (obj->nodesetval != NULL) {\n+            xmlNodeSetPtr tmpset = obj->nodesetval;\n@@ -4640,6 +4477,16 @@\n-        for (i = 0; i < tmpset->nodeNr; i++) {\n-            node = tmpset->nodeTab[i];\n-            if ((node != NULL) &&\n-            (node->type == XML_NAMESPACE_DECL))\n-            {\n-            xmlXPathNodeSetFreeNs((xmlNsPtr) node);\n+            \/*\n+            * Due to those nasty ns-nodes, we need to traverse\n+            * the list and free the ns-nodes.\n+            *\/\n+            if (tmpset->nodeNr > 0) {\n+                int i;\n+                xmlNodePtr node;\n+\n+                for (i = 0; i < tmpset->nodeNr; i++) {\n+                    node = tmpset->nodeTab[i];\n+                    if ((node != NULL) &&\n+                        (node->type == XML_NAMESPACE_DECL))\n+                    {\n+                        xmlXPathNodeSetFreeNs((xmlNsPtr) node);\n+                    }\n+                }\n@@ -4647,3 +4494,1 @@\n-        }\n-        }\n-        tmpset->nodeNr = 0;\n+            tmpset->nodeNr = 0;\n@@ -4652,1 +4497,1 @@\n-    return;\n+        return;\n@@ -4655,6 +4500,6 @@\n-    \/*\n-    * Cache is full; free the object.\n-    *\/\n-    if (obj->nodesetval != NULL)\n-        xmlXPathFreeNodeSet(obj->nodesetval);\n-    xmlFree(obj);\n+        \/*\n+        * Cache is full; free the object.\n+        *\/\n+        if (obj->nodesetval != NULL)\n+            xmlXPathFreeNodeSet(obj->nodesetval);\n+        xmlFree(obj);\n@@ -4662,1 +4507,0 @@\n-    return;\n@@ -4667,3 +4511,3 @@\n- *                                    *\n- *            Type Casting Routines                *\n- *                                    *\n+ *                                                                      *\n+ *                      Type Casting Routines                           *\n+ *                                                                      *\n@@ -4684,1 +4528,1 @@\n-    ret = xmlStrdup((const xmlChar *) \"true\");\n+        ret = xmlStrdup((const xmlChar *) \"true\");\n@@ -4686,1 +4530,1 @@\n-    ret = xmlStrdup((const xmlChar *) \"false\");\n+        ret = xmlStrdup((const xmlChar *) \"false\");\n@@ -4703,2 +4547,2 @@\n-    ret = xmlStrdup((const xmlChar *) \"Infinity\");\n-    break;\n+        ret = xmlStrdup((const xmlChar *) \"Infinity\");\n+        break;\n@@ -4706,2 +4550,2 @@\n-    ret = xmlStrdup((const xmlChar *) \"-Infinity\");\n-    break;\n+        ret = xmlStrdup((const xmlChar *) \"-Infinity\");\n+        break;\n@@ -4709,3 +4553,3 @@\n-    if (xmlXPathIsNaN(val)) {\n-        ret = xmlStrdup((const xmlChar *) \"NaN\");\n-    } else if (val == 0) {\n+        if (xmlXPathIsNaN(val)) {\n+            ret = xmlStrdup((const xmlChar *) \"NaN\");\n+        } else if (val == 0) {\n@@ -4713,8 +4557,8 @@\n-        ret = xmlStrdup((const xmlChar *) \"0\");\n-    } else {\n-        \/* could be improved *\/\n-        char buf[100];\n-        xmlXPathFormatNumber(val, buf, 99);\n-        buf[99] = 0;\n-        ret = xmlStrdup((const xmlChar *) buf);\n-    }\n+            ret = xmlStrdup((const xmlChar *) \"0\");\n+        } else {\n+            \/* could be improved *\/\n+            char buf[100];\n+            xmlXPathFormatNumber(val, buf, 99);\n+            buf[99] = 0;\n+            ret = xmlStrdup((const xmlChar *) buf);\n+        }\n@@ -4749,1 +4593,1 @@\n-    return(xmlStrdup((const xmlChar *) \"\"));\n+        return(xmlStrdup((const xmlChar *) \"\"));\n@@ -4752,1 +4596,1 @@\n-    xmlXPathNodeSetSort(ns);\n+        xmlXPathNodeSetSort(ns);\n@@ -4770,1 +4614,1 @@\n-    return(xmlStrdup((const xmlChar *) \"\"));\n+        return(xmlStrdup((const xmlChar *) \"\"));\n@@ -4772,3 +4616,3 @@\n-    case XPATH_UNDEFINED:\n-        ret = xmlStrdup((const xmlChar *) \"\");\n-        break;\n+        case XPATH_UNDEFINED:\n+            ret = xmlStrdup((const xmlChar *) \"\");\n+            break;\n@@ -4777,4 +4621,4 @@\n-        ret = xmlXPathCastNodeSetToString(val->nodesetval);\n-        break;\n-    case XPATH_STRING:\n-        return(xmlStrdup(val->stringval));\n+            ret = xmlXPathCastNodeSetToString(val->nodesetval);\n+            break;\n+        case XPATH_STRING:\n+            return(xmlStrdup(val->stringval));\n@@ -4782,15 +4626,10 @@\n-        ret = xmlXPathCastBooleanToString(val->boolval);\n-        break;\n-    case XPATH_NUMBER: {\n-        ret = xmlXPathCastNumberToString(val->floatval);\n-        break;\n-    }\n-    case XPATH_USERS:\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    case XPATH_POINT:\n-    case XPATH_RANGE:\n-    case XPATH_LOCATIONSET:\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-        \/* TODO *\/\n-        ret = xmlStrdup((const xmlChar *) \"\");\n-        break;\n+            ret = xmlXPathCastBooleanToString(val->boolval);\n+            break;\n+        case XPATH_NUMBER: {\n+            ret = xmlXPathCastNumberToString(val->floatval);\n+            break;\n+        }\n+        case XPATH_USERS:\n+            \/* TODO *\/\n+            ret = xmlStrdup((const xmlChar *) \"\");\n+            break;\n@@ -4815,1 +4654,1 @@\n-    return(xmlXPathNewCString(\"\"));\n+        return(xmlXPathNewCString(\"\"));\n@@ -4819,1 +4658,1 @@\n-    break;\n+        break;\n@@ -4822,2 +4661,2 @@\n-    res = xmlXPathCastNodeSetToString(val->nodesetval);\n-    break;\n+        res = xmlXPathCastNodeSetToString(val->nodesetval);\n+        break;\n@@ -4825,1 +4664,1 @@\n-    return(val);\n+        return(val);\n@@ -4827,2 +4666,2 @@\n-    res = xmlXPathCastBooleanToString(val->boolval);\n-    break;\n+        res = xmlXPathCastBooleanToString(val->boolval);\n+        break;\n@@ -4830,2 +4669,2 @@\n-    res = xmlXPathCastNumberToString(val->floatval);\n-    break;\n+        res = xmlXPathCastNumberToString(val->floatval);\n+        break;\n@@ -4833,7 +4672,2 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    case XPATH_POINT:\n-    case XPATH_RANGE:\n-    case XPATH_LOCATIONSET:\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-    \/* TODO *\/\n-    break;\n+        \/* TODO *\/\n+        break;\n@@ -4843,1 +4677,1 @@\n-    return(xmlXPathNewCString(\"\"));\n+        return(xmlXPathNewCString(\"\"));\n@@ -4858,1 +4692,1 @@\n-    return(1.0);\n+        return(1.0);\n@@ -4889,1 +4723,1 @@\n-    return(xmlXPathNAN);\n+        return(xmlXPathNAN);\n@@ -4893,1 +4727,1 @@\n-    return(xmlXPathNAN);\n+        return(xmlXPathNAN);\n@@ -4928,1 +4762,1 @@\n-    return(xmlXPathNAN);\n+        return(xmlXPathNAN);\n@@ -4962,1 +4796,1 @@\n-    return(xmlXPathNewFloat(0.0));\n+        return(xmlXPathNewFloat(0.0));\n@@ -4964,1 +4798,1 @@\n-    return(val);\n+        return(val);\n@@ -4981,1 +4815,1 @@\n-     return(0);\n+         return(0);\n@@ -4996,1 +4830,1 @@\n-    return(0);\n+        return(0);\n@@ -5011,1 +4845,1 @@\n-    return(0);\n+        return(0);\n@@ -5028,1 +4862,1 @@\n-    return(0);\n+        return(0);\n@@ -5031,2 +4865,2 @@\n-    ret = 0;\n-    break;\n+        ret = 0;\n+        break;\n@@ -5035,2 +4869,2 @@\n-    ret = xmlXPathCastNodeSetToBoolean(val->nodesetval);\n-    break;\n+        ret = xmlXPathCastNodeSetToBoolean(val->nodesetval);\n+        break;\n@@ -5038,2 +4872,2 @@\n-    ret = xmlXPathCastStringToBoolean(val->stringval);\n-    break;\n+        ret = xmlXPathCastStringToBoolean(val->stringval);\n+        break;\n@@ -5041,2 +4875,2 @@\n-    ret = xmlXPathCastNumberToBoolean(val->floatval);\n-    break;\n+        ret = xmlXPathCastNumberToBoolean(val->floatval);\n+        break;\n@@ -5044,2 +4878,2 @@\n-    ret = val->boolval;\n-    break;\n+        ret = val->boolval;\n+        break;\n@@ -5047,8 +4881,3 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    case XPATH_POINT:\n-    case XPATH_RANGE:\n-    case XPATH_LOCATIONSET:\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-    \/* TODO *\/\n-    ret = 0;\n-    break;\n+        \/* TODO *\/\n+        ret = 0;\n+        break;\n@@ -5074,1 +4903,1 @@\n-    return(xmlXPathNewBoolean(0));\n+        return(xmlXPathNewBoolean(0));\n@@ -5076,1 +4905,1 @@\n-    return(val);\n+        return(val);\n@@ -5083,3 +4912,3 @@\n- *                                    *\n- *        Routines to handle XPath contexts            *\n- *                                    *\n+ *                                                                      *\n+ *              Routines to handle XPath contexts                       *\n+ *                                                                      *\n@@ -5102,1 +4931,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5125,2 +4954,2 @@\n-    xmlXPathFreeContext(ret);\n-    return(NULL);\n+        xmlXPathFreeContext(ret);\n+        return(NULL);\n@@ -5130,7 +4959,0 @@\n-    xmlXPathRegisterAllFunctions(ret);\n-\n-    if (ret->lastError.code != XML_ERR_OK) {\n-    xmlXPathFreeContext(ret);\n-    return(NULL);\n-    }\n-\n@@ -5151,1 +4973,1 @@\n-    xmlXPathFreeCache((xmlXPathContextCachePtr) ctxt->cache);\n+        xmlXPathFreeCache((xmlXPathContextCachePtr) ctxt->cache);\n@@ -5181,3 +5003,3 @@\n- *                                    *\n- *        Routines to handle XPath parser contexts        *\n- *                                    *\n+ *                                                                      *\n+ *              Routines to handle XPath parser contexts                *\n+ *                                                                      *\n@@ -5202,1 +5024,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5211,3 +5033,3 @@\n-    xmlFree(ret->valueTab);\n-    xmlFree(ret);\n-    return(NULL);\n+        xmlFree(ret->valueTab);\n+        xmlFree(ret);\n+        return(NULL);\n@@ -5217,1 +5039,1 @@\n-    xmlDictReference(ret->comp->dict);\n+        xmlDictReference(ret->comp->dict);\n@@ -5239,1 +5061,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5244,2 +5066,6 @@\n-    ret->valueTab = (xmlXPathObjectPtr *)\n-                     xmlMalloc(10 * sizeof(xmlXPathObjectPtr));\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+    ret->valueMax = 1;\n+#else\n+    ret->valueMax = 10;\n+#endif\n+    ret->valueTab = xmlMalloc(ret->valueMax * sizeof(xmlXPathObjectPtr));\n@@ -5247,3 +5073,3 @@\n-    xmlFree(ret);\n-    xmlXPathErrMemory(ctxt);\n-    return(NULL);\n+        xmlFree(ret);\n+        xmlXPathErrMemory(ctxt);\n+        return(NULL);\n@@ -5252,1 +5078,0 @@\n-    ret->valueMax = 10;\n@@ -5282,4 +5107,4 @@\n-    if (ctxt->comp->stream != NULL) {\n-        xmlFreePatternList(ctxt->comp->stream);\n-        ctxt->comp->stream = NULL;\n-    }\n+        if (ctxt->comp->stream != NULL) {\n+            xmlFreePatternList(ctxt->comp->stream);\n+            ctxt->comp->stream = NULL;\n+        }\n@@ -5287,1 +5112,1 @@\n-    xmlXPathFreeCompExpr(ctxt->comp);\n+        xmlXPathFreeCompExpr(ctxt->comp);\n@@ -5293,3 +5118,3 @@\n- *                                    *\n- *        The implicit core function library            *\n- *                                    *\n+ *                                                                      *\n+ *              The implicit core function library                      *\n+ *                                                                      *\n@@ -5315,1 +5140,1 @@\n-    return(0);\n+        return(0);\n@@ -5318,5 +5143,5 @@\n-    tmp = xmlDocGetRootElement((xmlDocPtr) node);\n-    if (tmp == NULL)\n-        node = node->children;\n-    else\n-        node = tmp;\n+        tmp = xmlDocGetRootElement((xmlDocPtr) node);\n+        if (tmp == NULL)\n+            node = node->children;\n+        else\n+            node = tmp;\n@@ -5324,2 +5149,2 @@\n-    if (node == NULL)\n-        return(0);\n+        if (node == NULL)\n+            return(0);\n@@ -5329,28 +5154,2 @@\n-    case XML_COMMENT_NODE:\n-    case XML_PI_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_TEXT_NODE:\n-        string = node->content;\n-        if (string == NULL)\n-        return(0);\n-        if (string[0] == 0)\n-        return(0);\n-        return(string[0] + (string[1] << 8));\n-    case XML_NAMESPACE_DECL:\n-        string = ((xmlNsPtr)node)->href;\n-        if (string == NULL)\n-        return(0);\n-        if (string[0] == 0)\n-        return(0);\n-        return(string[0] + (string[1] << 8));\n-    case XML_ATTRIBUTE_NODE:\n-        tmp = ((xmlAttrPtr) node)->children;\n-        break;\n-    case XML_ELEMENT_NODE:\n-        tmp = node->children;\n-        break;\n-    default:\n-        return(0);\n-    }\n-    while (tmp != NULL) {\n-    switch (tmp->type) {\n+        case XML_COMMENT_NODE:\n+        case XML_PI_NODE:\n@@ -5359,2 +5158,19 @@\n-        string = tmp->content;\n-        break;\n+            string = node->content;\n+            if (string == NULL)\n+                return(0);\n+            if (string[0] == 0)\n+                return(0);\n+            return(string[0] + (string[1] << 8));\n+        case XML_NAMESPACE_DECL:\n+            string = ((xmlNsPtr)node)->href;\n+            if (string == NULL)\n+                return(0);\n+            if (string[0] == 0)\n+                return(0);\n+            return(string[0] + (string[1] << 8));\n+        case XML_ATTRIBUTE_NODE:\n+            tmp = ((xmlAttrPtr) node)->children;\n+            break;\n+        case XML_ELEMENT_NODE:\n+            tmp = node->children;\n+            break;\n@@ -5362,2 +5178,1 @@\n-                string = NULL;\n-        break;\n+            return(0);\n@@ -5365,3 +5180,9 @@\n-    if ((string != NULL) && (string[0] != 0)) {\n-        if (len == 1) {\n-        return(ret + (string[0] << 8));\n+    while (tmp != NULL) {\n+        switch (tmp->type) {\n+            case XML_CDATA_SECTION_NODE:\n+            case XML_TEXT_NODE:\n+                string = tmp->content;\n+                break;\n+            default:\n+                string = NULL;\n+                break;\n@@ -5369,5 +5190,10 @@\n-        if (string[1] == 0) {\n-        len = 1;\n-        ret = string[0];\n-        } else {\n-        return(string[0] + (string[1] << 8));\n+        if ((string != NULL) && (string[0] != 0)) {\n+            if (len == 1) {\n+                return(ret + (string[0] << 8));\n+            }\n+            if (string[1] == 0) {\n+                len = 1;\n+                ret = string[0];\n+            } else {\n+                return(string[0] + (string[1] << 8));\n+            }\n@@ -5375,4 +5201,3 @@\n-    }\n-    \/*\n-     * Skip to next node\n-     *\/\n+        \/*\n+         * Skip to next node\n+         *\/\n@@ -5385,16 +5210,0 @@\n-    }\n-    if (tmp == node)\n-        break;\n-\n-    if (tmp->next != NULL) {\n-        tmp = tmp->next;\n-        continue;\n-    }\n-\n-    do {\n-        tmp = tmp->parent;\n-        if (tmp == NULL)\n-        break;\n-        if (tmp == node) {\n-        tmp = NULL;\n-        break;\n@@ -5402,0 +5211,3 @@\n+        if (tmp == node)\n+            break;\n+\n@@ -5403,2 +5215,2 @@\n-        tmp = tmp->next;\n-        break;\n+            tmp = tmp->next;\n+            continue;\n@@ -5406,1 +5218,14 @@\n-    } while (tmp != NULL);\n+\n+        do {\n+            tmp = tmp->parent;\n+            if (tmp == NULL)\n+                break;\n+            if (tmp == node) {\n+                tmp = NULL;\n+                break;\n+            }\n+            if (tmp->next != NULL) {\n+                tmp = tmp->next;\n+                break;\n+            }\n+        } while (tmp != NULL);\n@@ -5423,1 +5248,1 @@\n-    return(0);\n+        return(0);\n@@ -5425,1 +5250,1 @@\n-    return(0);\n+        return(0);\n@@ -5453,1 +5278,1 @@\n-                        xmlXPathObjectPtr arg, xmlXPathObjectPtr f) {\n+                            xmlXPathObjectPtr arg, xmlXPathObjectPtr f) {\n@@ -5459,3 +5284,3 @@\n-    ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE))) {\n-    xmlXPathReleaseObject(ctxt->context, arg);\n-    xmlXPathReleaseObject(ctxt->context, f);\n+        ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE))) {\n+        xmlXPathReleaseObject(ctxt->context, arg);\n+        xmlXPathReleaseObject(ctxt->context, f);\n@@ -5466,11 +5291,11 @@\n-    for (i = 0;i < ns->nodeNr;i++) {\n-         str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);\n-         if (str2 != NULL) {\n-         valuePush(ctxt, xmlXPathCacheNewString(ctxt, str2));\n-         xmlFree(str2);\n-         xmlXPathNumberFunction(ctxt, 1);\n-         valuePush(ctxt, xmlXPathCacheObjectCopy(ctxt, f));\n-         ret = xmlXPathCompareValues(ctxt, inf, strict);\n-         if (ret)\n-             break;\n-         } else {\n+        for (i = 0;i < ns->nodeNr;i++) {\n+             str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);\n+             if (str2 != NULL) {\n+                 xmlXPathValuePush(ctxt, xmlXPathCacheNewString(ctxt, str2));\n+                 xmlFree(str2);\n+                 xmlXPathNumberFunction(ctxt, 1);\n+                 xmlXPathValuePush(ctxt, xmlXPathCacheObjectCopy(ctxt, f));\n+                 ret = xmlXPathCompareValues(ctxt, inf, strict);\n+                 if (ret)\n+                     break;\n+             } else {\n@@ -5479,1 +5304,1 @@\n-    }\n+        }\n@@ -5509,1 +5334,1 @@\n-                        xmlXPathObjectPtr arg, xmlXPathObjectPtr s) {\n+                            xmlXPathObjectPtr arg, xmlXPathObjectPtr s) {\n@@ -5515,3 +5340,3 @@\n-    ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE))) {\n-    xmlXPathReleaseObject(ctxt->context, arg);\n-    xmlXPathReleaseObject(ctxt->context, s);\n+        ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE))) {\n+        xmlXPathReleaseObject(ctxt->context, arg);\n+        xmlXPathReleaseObject(ctxt->context, s);\n@@ -5522,11 +5347,11 @@\n-    for (i = 0;i < ns->nodeNr;i++) {\n-         str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);\n-         if (str2 != NULL) {\n-         valuePush(ctxt,\n-               xmlXPathCacheNewString(ctxt, str2));\n-         xmlFree(str2);\n-         valuePush(ctxt, xmlXPathCacheObjectCopy(ctxt, s));\n-         ret = xmlXPathCompareValues(ctxt, inf, strict);\n-         if (ret)\n-             break;\n-         } else {\n+        for (i = 0;i < ns->nodeNr;i++) {\n+             str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);\n+             if (str2 != NULL) {\n+                 xmlXPathValuePush(ctxt,\n+                           xmlXPathCacheNewString(ctxt, str2));\n+                 xmlFree(str2);\n+                 xmlXPathValuePush(ctxt, xmlXPathCacheObjectCopy(ctxt, s));\n+                 ret = xmlXPathCompareValues(ctxt, inf, strict);\n+                 if (ret)\n+                     break;\n+             } else {\n@@ -5535,1 +5360,1 @@\n-    }\n+        }\n@@ -5572,1 +5397,1 @@\n-                    xmlXPathObjectPtr arg1, xmlXPathObjectPtr arg2) {\n+                        xmlXPathObjectPtr arg1, xmlXPathObjectPtr arg2) {\n@@ -5581,2 +5406,2 @@\n-    ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE))) {\n-    xmlXPathFreeObject(arg2);\n+        ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE))) {\n+        xmlXPathFreeObject(arg2);\n@@ -5586,3 +5411,3 @@\n-    ((arg2->type != XPATH_NODESET) && (arg2->type != XPATH_XSLT_TREE))) {\n-    xmlXPathFreeObject(arg1);\n-    xmlXPathFreeObject(arg2);\n+        ((arg2->type != XPATH_NODESET) && (arg2->type != XPATH_XSLT_TREE))) {\n+        xmlXPathFreeObject(arg1);\n+        xmlXPathFreeObject(arg2);\n@@ -5596,3 +5421,3 @@\n-    xmlXPathFreeObject(arg1);\n-    xmlXPathFreeObject(arg2);\n-    return(0);\n+        xmlXPathFreeObject(arg1);\n+        xmlXPathFreeObject(arg2);\n+        return(0);\n@@ -5601,3 +5426,3 @@\n-    xmlXPathFreeObject(arg1);\n-    xmlXPathFreeObject(arg2);\n-    return(0);\n+        xmlXPathFreeObject(arg1);\n+        xmlXPathFreeObject(arg2);\n+        return(0);\n@@ -5609,3 +5434,3 @@\n-    xmlXPathFreeObject(arg1);\n-    xmlXPathFreeObject(arg2);\n-    return(0);\n+        xmlXPathFreeObject(arg1);\n+        xmlXPathFreeObject(arg2);\n+        return(0);\n@@ -5614,6 +5439,6 @@\n-    val1 = xmlXPathNodeToNumberInternal(ctxt, ns1->nodeTab[i]);\n-    if (xmlXPathIsNaN(val1))\n-        continue;\n-    for (j = 0;j < ns2->nodeNr;j++) {\n-        if (init == 0) {\n-        values2[j] = xmlXPathNodeToNumberInternal(ctxt,\n+        val1 = xmlXPathNodeToNumberInternal(ctxt, ns1->nodeTab[i]);\n+        if (xmlXPathIsNaN(val1))\n+            continue;\n+        for (j = 0;j < ns2->nodeNr;j++) {\n+            if (init == 0) {\n+                values2[j] = xmlXPathNodeToNumberInternal(ctxt,\n@@ -5621,0 +5446,13 @@\n+            }\n+            if (xmlXPathIsNaN(values2[j]))\n+                continue;\n+            if (inf && strict)\n+                ret = (val1 < values2[j]);\n+            else if (inf && !strict)\n+                ret = (val1 <= values2[j]);\n+            else if (!inf && strict)\n+                ret = (val1 > values2[j]);\n+            else if (!inf && !strict)\n+                ret = (val1 >= values2[j]);\n+            if (ret)\n+                break;\n@@ -5622,10 +5460,0 @@\n-        if (xmlXPathIsNaN(values2[j]))\n-        continue;\n-        if (inf && strict)\n-        ret = (val1 < values2[j]);\n-        else if (inf && !strict)\n-        ret = (val1 <= values2[j]);\n-        else if (!inf && strict)\n-        ret = (val1 > values2[j]);\n-        else if (!inf && !strict)\n-        ret = (val1 >= values2[j]);\n@@ -5633,5 +5461,2 @@\n-        break;\n-    }\n-    if (ret)\n-        break;\n-    init = 1;\n+            break;\n+        init = 1;\n@@ -5668,1 +5493,1 @@\n-                        xmlXPathObjectPtr arg, xmlXPathObjectPtr val) {\n+                            xmlXPathObjectPtr arg, xmlXPathObjectPtr val) {\n@@ -5670,1 +5495,1 @@\n-    ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE)))\n+        ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE)))\n@@ -5675,1 +5500,1 @@\n-        return(xmlXPathCompareNodeSetFloat(ctxt, inf, strict, arg, val));\n+            return(xmlXPathCompareNodeSetFloat(ctxt, inf, strict, arg, val));\n@@ -5678,1 +5503,1 @@\n-        return(xmlXPathCompareNodeSets(ctxt, inf, strict, arg, val));\n+            return(xmlXPathCompareNodeSets(ctxt, inf, strict, arg, val));\n@@ -5680,1 +5505,1 @@\n-        return(xmlXPathCompareNodeSetString(ctxt, inf, strict, arg, val));\n+            return(xmlXPathCompareNodeSetString(ctxt, inf, strict, arg, val));\n@@ -5682,5 +5507,5 @@\n-        valuePush(ctxt, arg);\n-        xmlXPathBooleanFunction(ctxt, 1);\n-        valuePush(ctxt, val);\n-        return(xmlXPathCompareValues(ctxt, inf, strict));\n-    default:\n+            xmlXPathValuePush(ctxt, arg);\n+            xmlXPathBooleanFunction(ctxt, 1);\n+            xmlXPathValuePush(ctxt, val);\n+            return(xmlXPathCompareValues(ctxt, inf, strict));\n+        default:\n@@ -5737,2 +5562,2 @@\n-        if (neq)\n-            continue;\n+                if (neq)\n+                    continue;\n@@ -5741,3 +5566,3 @@\n-        xmlFree(str2);\n-        return (1);\n-        }\n+                xmlFree(str2);\n+                return (1);\n+            }\n@@ -5746,1 +5571,1 @@\n-        return (1);\n+            return (1);\n@@ -5776,1 +5601,1 @@\n-    ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE)))\n+        ((arg->type != XPATH_NODESET) && (arg->type != XPATH_XSLT_TREE)))\n@@ -5781,6 +5606,6 @@\n-    for (i=0;i<ns->nodeNr;i++) {\n-        str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);\n-        if (str2 != NULL) {\n-        valuePush(ctxt, xmlXPathCacheNewString(ctxt, str2));\n-        xmlFree(str2);\n-        xmlXPathNumberFunction(ctxt, 1);\n+        for (i=0;i<ns->nodeNr;i++) {\n+            str2 = xmlXPathCastNodeToString(ns->nodeTab[i]);\n+            if (str2 != NULL) {\n+                xmlXPathValuePush(ctxt, xmlXPathCacheNewString(ctxt, str2));\n+                xmlFree(str2);\n+                xmlXPathNumberFunction(ctxt, 1);\n@@ -5788,16 +5613,16 @@\n-        val = valuePop(ctxt);\n-        v = val->floatval;\n-        xmlXPathReleaseObject(ctxt->context, val);\n-        if (!xmlXPathIsNaN(v)) {\n-            if ((!neq) && (v==f)) {\n-            ret = 1;\n-            break;\n-            } else if ((neq) && (v!=f)) {\n-            ret = 1;\n-            break;\n-            }\n-        } else {    \/* NaN is unequal to any value *\/\n-            if (neq)\n-            ret = 1;\n-        }\n-        } else {\n+                val = xmlXPathValuePop(ctxt);\n+                v = val->floatval;\n+                xmlXPathReleaseObject(ctxt->context, val);\n+                if (!xmlXPathIsNaN(v)) {\n+                    if ((!neq) && (v==f)) {\n+                        ret = 1;\n+                        break;\n+                    } else if ((neq) && (v!=f)) {\n+                        ret = 1;\n+                        break;\n+                    }\n+                } else {        \/* NaN is unequal to any value *\/\n+                    if (neq)\n+                        ret = 1;\n+                }\n+            } else {\n@@ -5806,1 +5631,1 @@\n-    }\n+        }\n@@ -5843,1 +5668,1 @@\n-    ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)))\n+        ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)))\n@@ -5846,1 +5671,1 @@\n-    ((arg2->type != XPATH_NODESET) && (arg2->type != XPATH_XSLT_TREE)))\n+        ((arg2->type != XPATH_NODESET) && (arg2->type != XPATH_XSLT_TREE)))\n@@ -5853,1 +5678,1 @@\n-    return(0);\n+        return(0);\n@@ -5855,1 +5680,1 @@\n-    return(0);\n+        return(0);\n@@ -5861,4 +5686,4 @@\n-    for (i = 0;i < ns1->nodeNr;i++)\n-        for (j = 0;j < ns2->nodeNr;j++)\n-        if (ns1->nodeTab[i] == ns2->nodeTab[j])\n-            return(1);\n+        for (i = 0;i < ns1->nodeNr;i++)\n+            for (j = 0;j < ns2->nodeNr;j++)\n+                if (ns1->nodeTab[i] == ns2->nodeTab[j])\n+                    return(1);\n@@ -5869,1 +5694,1 @@\n-    return(0);\n+        return(0);\n@@ -5874,2 +5699,2 @@\n-    xmlFree(values1);\n-    return(0);\n+        xmlFree(values1);\n+        return(0);\n@@ -5881,3 +5706,3 @@\n-    xmlFree(hashs1);\n-    xmlFree(values1);\n-    return(0);\n+        xmlFree(hashs1);\n+        xmlFree(values1);\n+        return(0);\n@@ -5888,4 +5713,4 @@\n-    xmlFree(hashs1);\n-    xmlFree(values1);\n-    xmlFree(values2);\n-    return(0);\n+        xmlFree(hashs1);\n+        xmlFree(values1);\n+        xmlFree(values2);\n+        return(0);\n@@ -5895,13 +5720,13 @@\n-    hashs1[i] = xmlXPathNodeValHash(ns1->nodeTab[i]);\n-    for (j = 0;j < ns2->nodeNr;j++) {\n-        if (i == 0)\n-        hashs2[j] = xmlXPathNodeValHash(ns2->nodeTab[j]);\n-        if (hashs1[i] != hashs2[j]) {\n-        if (neq) {\n-            ret = 1;\n-            break;\n-        }\n-        }\n-        else {\n-        if (values1[i] == NULL) {\n-            values1[i] = xmlNodeGetContent(ns1->nodeTab[i]);\n+        hashs1[i] = xmlXPathNodeValHash(ns1->nodeTab[i]);\n+        for (j = 0;j < ns2->nodeNr;j++) {\n+            if (i == 0)\n+                hashs2[j] = xmlXPathNodeValHash(ns2->nodeTab[j]);\n+            if (hashs1[i] != hashs2[j]) {\n+                if (neq) {\n+                    ret = 1;\n+                    break;\n+                }\n+            }\n+            else {\n+                if (values1[i] == NULL) {\n+                    values1[i] = xmlNodeGetContent(ns1->nodeTab[i]);\n@@ -5911,2 +5736,2 @@\n-        if (values2[j] == NULL) {\n-            values2[j] = xmlNodeGetContent(ns2->nodeTab[j]);\n+                if (values2[j] == NULL) {\n+                    values2[j] = xmlNodeGetContent(ns2->nodeTab[j]);\n@@ -5916,1 +5741,5 @@\n-        ret = xmlStrEqual(values1[i], values2[j]) ^ neq;\n+                ret = xmlStrEqual(values1[i], values2[j]) ^ neq;\n+                if (ret)\n+                    break;\n+            }\n+        }\n@@ -5919,4 +5748,0 @@\n-        }\n-    }\n-    if (ret)\n-        break;\n@@ -5925,2 +5750,2 @@\n-    if (values1[i] != NULL)\n-        xmlFree(values1[i]);\n+        if (values1[i] != NULL)\n+            xmlFree(values1[i]);\n@@ -5928,2 +5753,2 @@\n-    if (values2[j] != NULL)\n-        xmlFree(values2[j]);\n+        if (values2[j] != NULL)\n+            xmlFree(values2[j]);\n@@ -5947,4 +5772,0 @@\n-        break;\n-        case XPATH_BOOLEAN:\n-        switch (arg2->type) {\n-            case XPATH_UNDEFINED:\n@@ -5953,23 +5774,24 @@\n-            ret = (arg1->boolval == arg2->boolval);\n-            break;\n-        case XPATH_NUMBER:\n-            ret = (arg1->boolval ==\n-               xmlXPathCastNumberToBoolean(arg2->floatval));\n-            break;\n-        case XPATH_STRING:\n-            if ((arg2->stringval == NULL) ||\n-            (arg2->stringval[0] == 0)) ret = 0;\n-            else\n-            ret = 1;\n-            ret = (arg1->boolval == ret);\n-            break;\n-        case XPATH_USERS:\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        case XPATH_POINT:\n-        case XPATH_RANGE:\n-        case XPATH_LOCATIONSET:\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-            \/* TODO *\/\n-            break;\n-        case XPATH_NODESET:\n-        case XPATH_XSLT_TREE:\n+            switch (arg2->type) {\n+                case XPATH_UNDEFINED:\n+                    break;\n+                case XPATH_BOOLEAN:\n+                    ret = (arg1->boolval == arg2->boolval);\n+                    break;\n+                case XPATH_NUMBER:\n+                    ret = (arg1->boolval ==\n+                           xmlXPathCastNumberToBoolean(arg2->floatval));\n+                    break;\n+                case XPATH_STRING:\n+                    if ((arg2->stringval == NULL) ||\n+                        (arg2->stringval[0] == 0)) ret = 0;\n+                    else\n+                        ret = 1;\n+                    ret = (arg1->boolval == ret);\n+                    break;\n+                case XPATH_USERS:\n+                    \/* TODO *\/\n+                    break;\n+                case XPATH_NODESET:\n+                case XPATH_XSLT_TREE:\n+                    break;\n+            }\n@@ -5977,2 +5799,0 @@\n-        }\n-        break;\n@@ -5980,11 +5800,11 @@\n-        switch (arg2->type) {\n-            case XPATH_UNDEFINED:\n-            break;\n-        case XPATH_BOOLEAN:\n-            ret = (arg2->boolval==\n-               xmlXPathCastNumberToBoolean(arg1->floatval));\n-            break;\n-        case XPATH_STRING:\n-            valuePush(ctxt, arg2);\n-            xmlXPathNumberFunction(ctxt, 1);\n-            arg2 = valuePop(ctxt);\n+            switch (arg2->type) {\n+                case XPATH_UNDEFINED:\n+                    break;\n+                case XPATH_BOOLEAN:\n+                    ret = (arg2->boolval==\n+                           xmlXPathCastNumberToBoolean(arg1->floatval));\n+                    break;\n+                case XPATH_STRING:\n+                    xmlXPathValuePush(ctxt, arg2);\n+                    xmlXPathNumberFunction(ctxt, 1);\n+                    arg2 = xmlXPathValuePop(ctxt);\n@@ -5994,27 +5814,35 @@\n-        case XPATH_NUMBER:\n-            \/* Hand check NaN and Infinity equalities *\/\n-            if (xmlXPathIsNaN(arg1->floatval) ||\n-                xmlXPathIsNaN(arg2->floatval)) {\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg1->floatval) == 1) {\n-                if (xmlXPathIsInf(arg2->floatval) == 1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg1->floatval) == -1) {\n-            if (xmlXPathIsInf(arg2->floatval) == -1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg2->floatval) == 1) {\n-            if (xmlXPathIsInf(arg1->floatval) == 1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg2->floatval) == -1) {\n-            if (xmlXPathIsInf(arg1->floatval) == -1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else {\n-                ret = (arg1->floatval == arg2->floatval);\n+                case XPATH_NUMBER:\n+                    \/* Hand check NaN and Infinity equalities *\/\n+                    if (xmlXPathIsNaN(arg1->floatval) ||\n+                            xmlXPathIsNaN(arg2->floatval)) {\n+                        ret = 0;\n+                    } else if (xmlXPathIsInf(arg1->floatval) == 1) {\n+                        if (xmlXPathIsInf(arg2->floatval) == 1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else if (xmlXPathIsInf(arg1->floatval) == -1) {\n+                        if (xmlXPathIsInf(arg2->floatval) == -1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else if (xmlXPathIsInf(arg2->floatval) == 1) {\n+                        if (xmlXPathIsInf(arg1->floatval) == 1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else if (xmlXPathIsInf(arg2->floatval) == -1) {\n+                        if (xmlXPathIsInf(arg1->floatval) == -1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else {\n+                        ret = (arg1->floatval == arg2->floatval);\n+                    }\n+                    break;\n+                case XPATH_USERS:\n+                    \/* TODO *\/\n+                    break;\n+                case XPATH_NODESET:\n+                case XPATH_XSLT_TREE:\n+                    break;\n@@ -6023,24 +5851,0 @@\n-        case XPATH_USERS:\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        case XPATH_POINT:\n-        case XPATH_RANGE:\n-        case XPATH_LOCATIONSET:\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-            \/* TODO *\/\n-            break;\n-        case XPATH_NODESET:\n-        case XPATH_XSLT_TREE:\n-            break;\n-        }\n-        break;\n-        case XPATH_STRING:\n-        switch (arg2->type) {\n-            case XPATH_UNDEFINED:\n-            break;\n-        case XPATH_BOOLEAN:\n-            if ((arg1->stringval == NULL) ||\n-            (arg1->stringval[0] == 0)) ret = 0;\n-            else\n-            ret = 1;\n-            ret = (arg2->boolval == ret);\n-            break;\n@@ -6048,6 +5852,17 @@\n-            ret = xmlStrEqual(arg1->stringval, arg2->stringval);\n-            break;\n-        case XPATH_NUMBER:\n-            valuePush(ctxt, arg1);\n-            xmlXPathNumberFunction(ctxt, 1);\n-            arg1 = valuePop(ctxt);\n+            switch (arg2->type) {\n+                case XPATH_UNDEFINED:\n+                    break;\n+                case XPATH_BOOLEAN:\n+                    if ((arg1->stringval == NULL) ||\n+                        (arg1->stringval[0] == 0)) ret = 0;\n+                    else\n+                        ret = 1;\n+                    ret = (arg2->boolval == ret);\n+                    break;\n+                case XPATH_STRING:\n+                    ret = xmlStrEqual(arg1->stringval, arg2->stringval);\n+                    break;\n+                case XPATH_NUMBER:\n+                    xmlXPathValuePush(ctxt, arg1);\n+                    xmlXPathNumberFunction(ctxt, 1);\n+                    arg1 = xmlXPathValuePop(ctxt);\n@@ -6056,26 +5871,34 @@\n-            \/* Hand check NaN and Infinity equalities *\/\n-            if (xmlXPathIsNaN(arg1->floatval) ||\n-                xmlXPathIsNaN(arg2->floatval)) {\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg1->floatval) == 1) {\n-            if (xmlXPathIsInf(arg2->floatval) == 1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg1->floatval) == -1) {\n-            if (xmlXPathIsInf(arg2->floatval) == -1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg2->floatval) == 1) {\n-            if (xmlXPathIsInf(arg1->floatval) == 1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else if (xmlXPathIsInf(arg2->floatval) == -1) {\n-            if (xmlXPathIsInf(arg1->floatval) == -1)\n-                ret = 1;\n-            else\n-                ret = 0;\n-            } else {\n-                ret = (arg1->floatval == arg2->floatval);\n+                    \/* Hand check NaN and Infinity equalities *\/\n+                    if (xmlXPathIsNaN(arg1->floatval) ||\n+                            xmlXPathIsNaN(arg2->floatval)) {\n+                        ret = 0;\n+                    } else if (xmlXPathIsInf(arg1->floatval) == 1) {\n+                        if (xmlXPathIsInf(arg2->floatval) == 1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else if (xmlXPathIsInf(arg1->floatval) == -1) {\n+                        if (xmlXPathIsInf(arg2->floatval) == -1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else if (xmlXPathIsInf(arg2->floatval) == 1) {\n+                        if (xmlXPathIsInf(arg1->floatval) == 1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else if (xmlXPathIsInf(arg2->floatval) == -1) {\n+                        if (xmlXPathIsInf(arg1->floatval) == -1)\n+                            ret = 1;\n+                        else\n+                            ret = 0;\n+                    } else {\n+                        ret = (arg1->floatval == arg2->floatval);\n+                    }\n+                    break;\n+                case XPATH_USERS:\n+                    \/* TODO *\/\n+                    break;\n+                case XPATH_NODESET:\n+                case XPATH_XSLT_TREE:\n+                    break;\n@@ -6085,5 +5908,0 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        case XPATH_POINT:\n-        case XPATH_RANGE:\n-        case XPATH_LOCATIONSET:\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n@@ -6095,13 +5913,0 @@\n-        }\n-        break;\n-        case XPATH_USERS:\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    case XPATH_POINT:\n-    case XPATH_RANGE:\n-    case XPATH_LOCATIONSET:\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-        \/* TODO *\/\n-        break;\n-    case XPATH_NODESET:\n-    case XPATH_XSLT_TREE:\n-        break;\n@@ -6128,2 +5933,2 @@\n-    arg2 = valuePop(ctxt);\n-    arg1 = valuePop(ctxt);\n+    arg2 = xmlXPathValuePop(ctxt);\n+    arg1 = xmlXPathValuePop(ctxt);\n@@ -6131,5 +5936,5 @@\n-    if (arg1 != NULL)\n-        xmlXPathReleaseObject(ctxt->context, arg1);\n-    else\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n-    XP_ERROR0(XPATH_INVALID_OPERAND);\n+        if (arg1 != NULL)\n+            xmlXPathReleaseObject(ctxt->context, arg1);\n+        else\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n+        XP_ERROR0(XPATH_INVALID_OPERAND);\n@@ -6139,1 +5944,1 @@\n-    xmlXPathFreeObject(arg1);\n+        xmlXPathFreeObject(arg1);\n@@ -6148,27 +5953,27 @@\n-    \/*\n-     *Hack it to assure arg1 is the nodeset\n-     *\/\n-    if ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)) {\n-        argtmp = arg2;\n-        arg2 = arg1;\n-        arg1 = argtmp;\n-    }\n-    switch (arg2->type) {\n-        case XPATH_UNDEFINED:\n-        break;\n-        case XPATH_NODESET:\n-        case XPATH_XSLT_TREE:\n-        ret = xmlXPathEqualNodeSets(ctxt, arg1, arg2, 0);\n-        break;\n-        case XPATH_BOOLEAN:\n-        if ((arg1->nodesetval == NULL) ||\n-          (arg1->nodesetval->nodeNr == 0)) ret = 0;\n-        else\n-            ret = 1;\n-        ret = (ret == arg2->boolval);\n-        break;\n-        case XPATH_NUMBER:\n-        ret = xmlXPathEqualNodeSetFloat(ctxt, arg1, arg2->floatval, 0);\n-        break;\n-        case XPATH_STRING:\n-        ret = xmlXPathEqualNodeSetString(ctxt, arg1,\n+        \/*\n+         *Hack it to assure arg1 is the nodeset\n+         *\/\n+        if ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)) {\n+                argtmp = arg2;\n+                arg2 = arg1;\n+                arg1 = argtmp;\n+        }\n+        switch (arg2->type) {\n+            case XPATH_UNDEFINED:\n+                break;\n+            case XPATH_NODESET:\n+            case XPATH_XSLT_TREE:\n+                ret = xmlXPathEqualNodeSets(ctxt, arg1, arg2, 0);\n+                break;\n+            case XPATH_BOOLEAN:\n+                if ((arg1->nodesetval == NULL) ||\n+                  (arg1->nodesetval->nodeNr == 0)) ret = 0;\n+                else\n+                    ret = 1;\n+                ret = (ret == arg2->boolval);\n+                break;\n+            case XPATH_NUMBER:\n+                ret = xmlXPathEqualNodeSetFloat(ctxt, arg1, arg2->floatval, 0);\n+                break;\n+            case XPATH_STRING:\n+                ret = xmlXPathEqualNodeSetString(ctxt, arg1,\n@@ -6176,13 +5981,8 @@\n-        break;\n-        case XPATH_USERS:\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        case XPATH_POINT:\n-        case XPATH_RANGE:\n-        case XPATH_LOCATIONSET:\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-        \/* TODO *\/\n-        break;\n-    }\n-    xmlXPathReleaseObject(ctxt->context, arg1);\n-    xmlXPathReleaseObject(ctxt->context, arg2);\n-    return(ret);\n+                break;\n+            case XPATH_USERS:\n+                \/* TODO *\/\n+                break;\n+        }\n+        xmlXPathReleaseObject(ctxt->context, arg1);\n+        xmlXPathReleaseObject(ctxt->context, arg2);\n+        return(ret);\n@@ -6208,2 +6008,2 @@\n-    arg2 = valuePop(ctxt);\n-    arg1 = valuePop(ctxt);\n+    arg2 = xmlXPathValuePop(ctxt);\n+    arg1 = xmlXPathValuePop(ctxt);\n@@ -6211,5 +6011,5 @@\n-    if (arg1 != NULL)\n-        xmlXPathReleaseObject(ctxt->context, arg1);\n-    else\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n-    XP_ERROR0(XPATH_INVALID_OPERAND);\n+        if (arg1 != NULL)\n+            xmlXPathReleaseObject(ctxt->context, arg1);\n+        else\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n+        XP_ERROR0(XPATH_INVALID_OPERAND);\n@@ -6219,1 +6019,1 @@\n-    xmlXPathReleaseObject(ctxt->context, arg1);\n+        xmlXPathReleaseObject(ctxt->context, arg1);\n@@ -6228,27 +6028,27 @@\n-    \/*\n-     *Hack it to assure arg1 is the nodeset\n-     *\/\n-    if ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)) {\n-        argtmp = arg2;\n-        arg2 = arg1;\n-        arg1 = argtmp;\n-    }\n-    switch (arg2->type) {\n-        case XPATH_UNDEFINED:\n-        break;\n-        case XPATH_NODESET:\n-        case XPATH_XSLT_TREE:\n-        ret = xmlXPathEqualNodeSets(ctxt, arg1, arg2, 1);\n-        break;\n-        case XPATH_BOOLEAN:\n-        if ((arg1->nodesetval == NULL) ||\n-          (arg1->nodesetval->nodeNr == 0)) ret = 0;\n-        else\n-            ret = 1;\n-        ret = (ret != arg2->boolval);\n-        break;\n-        case XPATH_NUMBER:\n-        ret = xmlXPathEqualNodeSetFloat(ctxt, arg1, arg2->floatval, 1);\n-        break;\n-        case XPATH_STRING:\n-        ret = xmlXPathEqualNodeSetString(ctxt, arg1,\n+        \/*\n+         *Hack it to assure arg1 is the nodeset\n+         *\/\n+        if ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)) {\n+                argtmp = arg2;\n+                arg2 = arg1;\n+                arg1 = argtmp;\n+        }\n+        switch (arg2->type) {\n+            case XPATH_UNDEFINED:\n+                break;\n+            case XPATH_NODESET:\n+            case XPATH_XSLT_TREE:\n+                ret = xmlXPathEqualNodeSets(ctxt, arg1, arg2, 1);\n+                break;\n+            case XPATH_BOOLEAN:\n+                if ((arg1->nodesetval == NULL) ||\n+                  (arg1->nodesetval->nodeNr == 0)) ret = 0;\n+                else\n+                    ret = 1;\n+                ret = (ret != arg2->boolval);\n+                break;\n+            case XPATH_NUMBER:\n+                ret = xmlXPathEqualNodeSetFloat(ctxt, arg1, arg2->floatval, 1);\n+                break;\n+            case XPATH_STRING:\n+                ret = xmlXPathEqualNodeSetString(ctxt, arg1,\n@@ -6256,13 +6056,8 @@\n-        break;\n-        case XPATH_USERS:\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        case XPATH_POINT:\n-        case XPATH_RANGE:\n-        case XPATH_LOCATIONSET:\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-        \/* TODO *\/\n-        break;\n-    }\n-    xmlXPathReleaseObject(ctxt->context, arg1);\n-    xmlXPathReleaseObject(ctxt->context, arg2);\n-    return(ret);\n+                break;\n+            case XPATH_USERS:\n+                \/* TODO *\/\n+                break;\n+        }\n+        xmlXPathReleaseObject(ctxt->context, arg1);\n+        xmlXPathReleaseObject(ctxt->context, arg2);\n+        return(ret);\n@@ -6304,2 +6099,2 @@\n-    arg2 = valuePop(ctxt);\n-    arg1 = valuePop(ctxt);\n+    arg2 = xmlXPathValuePop(ctxt);\n+    arg1 = xmlXPathValuePop(ctxt);\n@@ -6307,5 +6102,5 @@\n-    if (arg1 != NULL)\n-        xmlXPathReleaseObject(ctxt->context, arg1);\n-    else\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n-    XP_ERROR0(XPATH_INVALID_OPERAND);\n+        if (arg1 != NULL)\n+            xmlXPathReleaseObject(ctxt->context, arg1);\n+        else\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n+        XP_ERROR0(XPATH_INVALID_OPERAND);\n@@ -6316,12 +6111,8 @@\n-    \/*\n-     * If either argument is a XPATH_NODESET or XPATH_XSLT_TREE the two arguments\n-     * are not freed from within this routine; they will be freed from the\n-     * called routine, e.g. xmlXPathCompareNodeSets or xmlXPathCompareNodeSetValue\n-     *\/\n-    if (((arg2->type == XPATH_NODESET) || (arg2->type == XPATH_XSLT_TREE)) &&\n-      ((arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE))){\n-        ret = xmlXPathCompareNodeSets(ctxt, inf, strict, arg1, arg2);\n-    } else {\n-        if ((arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE)) {\n-        ret = xmlXPathCompareNodeSetValue(ctxt, inf, strict,\n-                                      arg1, arg2);\n+        \/*\n+         * If either argument is a XPATH_NODESET or XPATH_XSLT_TREE the two arguments\n+         * are not freed from within this routine; they will be freed from the\n+         * called routine, e.g. xmlXPathCompareNodeSets or xmlXPathCompareNodeSetValue\n+         *\/\n+        if (((arg2->type == XPATH_NODESET) || (arg2->type == XPATH_XSLT_TREE)) &&\n+          ((arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE))){\n+            ret = xmlXPathCompareNodeSets(ctxt, inf, strict, arg1, arg2);\n@@ -6329,2 +6120,7 @@\n-        ret = xmlXPathCompareNodeSetValue(ctxt, !inf, strict,\n-                                      arg2, arg1);\n+            if ((arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE)) {\n+                ret = xmlXPathCompareNodeSetValue(ctxt, inf, strict,\n+                                                  arg1, arg2);\n+            } else {\n+                ret = xmlXPathCompareNodeSetValue(ctxt, !inf, strict,\n+                                                  arg2, arg1);\n+            }\n@@ -6332,2 +6128,1 @@\n-    }\n-    return(ret);\n+        return(ret);\n@@ -6337,3 +6132,3 @@\n-    valuePush(ctxt, arg1);\n-    xmlXPathNumberFunction(ctxt, 1);\n-    arg1 = valuePop(ctxt);\n+        xmlXPathValuePush(ctxt, arg1);\n+        xmlXPathNumberFunction(ctxt, 1);\n+        arg1 = xmlXPathValuePop(ctxt);\n@@ -6342,3 +6137,3 @@\n-    valuePush(ctxt, arg2);\n-    xmlXPathNumberFunction(ctxt, 1);\n-    arg2 = valuePop(ctxt);\n+        xmlXPathValuePush(ctxt, arg2);\n+        xmlXPathNumberFunction(ctxt, 1);\n+        arg2 = xmlXPathValuePop(ctxt);\n@@ -6354,1 +6149,1 @@\n-    ret=0;\n+        ret=0;\n@@ -6356,10 +6151,11 @@\n-    arg1i=xmlXPathIsInf(arg1->floatval);\n-    arg2i=xmlXPathIsInf(arg2->floatval);\n-    if (inf && strict) {\n-        if ((arg1i == -1 && arg2i != -1) ||\n-        (arg2i == 1 && arg1i != 1)) {\n-        ret = 1;\n-        } else if (arg1i == 0 && arg2i == 0) {\n-        ret = (arg1->floatval < arg2->floatval);\n-        } else {\n-        ret = 0;\n+        arg1i=xmlXPathIsInf(arg1->floatval);\n+        arg2i=xmlXPathIsInf(arg2->floatval);\n+        if (inf && strict) {\n+            if ((arg1i == -1 && arg2i != -1) ||\n+                (arg2i == 1 && arg1i != 1)) {\n+                ret = 1;\n+            } else if (arg1i == 0 && arg2i == 0) {\n+                ret = (arg1->floatval < arg2->floatval);\n+            } else {\n+                ret = 0;\n+            }\n@@ -6367,8 +6163,8 @@\n-    }\n-    else if (inf && !strict) {\n-        if (arg1i == -1 || arg2i == 1) {\n-        ret = 1;\n-        } else if (arg1i == 0 && arg2i == 0) {\n-        ret = (arg1->floatval <= arg2->floatval);\n-        } else {\n-        ret = 0;\n+        else if (inf && !strict) {\n+            if (arg1i == -1 || arg2i == 1) {\n+                ret = 1;\n+            } else if (arg1i == 0 && arg2i == 0) {\n+                ret = (arg1->floatval <= arg2->floatval);\n+            } else {\n+                ret = 0;\n+            }\n@@ -6376,9 +6172,9 @@\n-    }\n-    else if (!inf && strict) {\n-        if ((arg1i == 1 && arg2i != 1) ||\n-        (arg2i == -1 && arg1i != -1)) {\n-        ret = 1;\n-        } else if (arg1i == 0 && arg2i == 0) {\n-        ret = (arg1->floatval > arg2->floatval);\n-        } else {\n-        ret = 0;\n+        else if (!inf && strict) {\n+            if ((arg1i == 1 && arg2i != 1) ||\n+                (arg2i == -1 && arg1i != -1)) {\n+                ret = 1;\n+            } else if (arg1i == 0 && arg2i == 0) {\n+                ret = (arg1->floatval > arg2->floatval);\n+            } else {\n+                ret = 0;\n+            }\n@@ -6386,8 +6182,8 @@\n-    }\n-    else if (!inf && !strict) {\n-        if (arg1i == 1 || arg2i == -1) {\n-        ret = 1;\n-        } else if (arg1i == 0 && arg2i == 0) {\n-        ret = (arg1->floatval >= arg2->floatval);\n-        } else {\n-        ret = 0;\n+        else if (!inf && !strict) {\n+            if (arg1i == 1 || arg2i == -1) {\n+                ret = 1;\n+            } else if (arg1i == 0 && arg2i == 0) {\n+                ret = (arg1->floatval >= arg2->floatval);\n+            } else {\n+                ret = 0;\n+            }\n@@ -6396,1 +6192,0 @@\n-    }\n@@ -6432,1 +6227,1 @@\n-    arg = valuePop(ctxt);\n+    arg = xmlXPathValuePop(ctxt);\n@@ -6434,1 +6229,1 @@\n-    XP_ERROR(XPATH_INVALID_OPERAND);\n+        XP_ERROR(XPATH_INVALID_OPERAND);\n@@ -6455,1 +6250,1 @@\n-    arg = valuePop(ctxt);\n+    arg = xmlXPathValuePop(ctxt);\n@@ -6457,1 +6252,1 @@\n-    XP_ERROR(XPATH_INVALID_OPERAND);\n+        XP_ERROR(XPATH_INVALID_OPERAND);\n@@ -6478,1 +6273,1 @@\n-    arg = valuePop(ctxt);\n+    arg = xmlXPathValuePop(ctxt);\n@@ -6480,1 +6275,1 @@\n-    XP_ERROR(XPATH_INVALID_OPERAND);\n+        XP_ERROR(XPATH_INVALID_OPERAND);\n@@ -6502,1 +6297,1 @@\n-    arg = valuePop(ctxt);\n+    arg = xmlXPathValuePop(ctxt);\n@@ -6504,1 +6299,1 @@\n-    XP_ERROR(XPATH_INVALID_OPERAND);\n+        XP_ERROR(XPATH_INVALID_OPERAND);\n@@ -6525,1 +6320,1 @@\n-    arg = valuePop(ctxt);\n+    arg = xmlXPathValuePop(ctxt);\n@@ -6527,1 +6322,1 @@\n-    XP_ERROR(XPATH_INVALID_OPERAND);\n+        XP_ERROR(XPATH_INVALID_OPERAND);\n@@ -6534,1 +6329,1 @@\n-    ctxt->value->floatval = xmlXPathNAN;\n+        ctxt->value->floatval = xmlXPathNAN;\n@@ -6536,1 +6331,1 @@\n-    ctxt->value->floatval = fmod(arg1, arg2);\n+        ctxt->value->floatval = fmod(arg1, arg2);\n@@ -6541,3 +6336,3 @@\n- *                                    *\n- *        The traversal functions                    *\n- *                                    *\n+ *                                                                      *\n+ *              The traversal functions                                 *\n+ *                                                                      *\n@@ -6569,1 +6364,1 @@\n-            (xmlNodeSetPtr, xmlNodeSetPtr);\n+                    (xmlNodeSetPtr, xmlNodeSetPtr);\n@@ -6604,2 +6399,2 @@\n-    if (ctxt->context->node == NULL) return(NULL);\n-    switch (ctxt->context->node->type) {\n+        if (ctxt->context->node == NULL) return(NULL);\n+        switch (ctxt->context->node->type) {\n@@ -6615,1 +6410,1 @@\n-        return(ctxt->context->node->children);\n+                return(ctxt->context->node->children);\n@@ -6620,4 +6415,4 @@\n-        return(((xmlDocPtr) ctxt->context->node)->children);\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_ENTITY_DECL:\n+                return(((xmlDocPtr) ctxt->context->node)->children);\n+            case XML_ELEMENT_DECL:\n+            case XML_ATTRIBUTE_DECL:\n+            case XML_ENTITY_DECL:\n@@ -6625,3 +6420,5 @@\n-        case XML_NAMESPACE_DECL:\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n+            case XML_NAMESPACE_DECL:\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+                return(NULL);\n+        }\n@@ -6630,2 +6427,0 @@\n-    return(NULL);\n-    }\n@@ -6634,1 +6429,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6652,6 +6447,6 @@\n-    cur = ctxt->context->node;\n-    if (cur == NULL) return(NULL);\n-    \/*\n-    * Get the first element child.\n-    *\/\n-    switch (cur->type) {\n+        cur = ctxt->context->node;\n+        if (cur == NULL) return(NULL);\n+        \/*\n+        * Get the first element child.\n+        *\/\n+        switch (cur->type) {\n@@ -6659,2 +6454,2 @@\n-        case XML_DOCUMENT_FRAG_NODE:\n-        case XML_ENTITY_REF_NODE: \/* URGENT TODO: entify-refs as well? *\/\n+            case XML_DOCUMENT_FRAG_NODE:\n+            case XML_ENTITY_REF_NODE: \/* URGENT TODO: entify-refs as well? *\/\n@@ -6662,11 +6457,11 @@\n-        cur = cur->children;\n-        if (cur != NULL) {\n-            if (cur->type == XML_ELEMENT_NODE)\n-            return(cur);\n-            do {\n-            cur = cur->next;\n-            } while ((cur != NULL) &&\n-            (cur->type != XML_ELEMENT_NODE));\n-            return(cur);\n-        }\n-        return(NULL);\n+                cur = cur->children;\n+                if (cur != NULL) {\n+                    if (cur->type == XML_ELEMENT_NODE)\n+                        return(cur);\n+                    do {\n+                        cur = cur->next;\n+                    } while ((cur != NULL) &&\n+                        (cur->type != XML_ELEMENT_NODE));\n+                    return(cur);\n+                }\n+                return(NULL);\n@@ -6675,2 +6470,4 @@\n-        return(xmlDocGetRootElement((xmlDocPtr) cur));\n-        default:\n+                return(xmlDocGetRootElement((xmlDocPtr) cur));\n+            default:\n+                return(NULL);\n+        }\n@@ -6679,2 +6476,0 @@\n-    return(NULL);\n-    }\n@@ -6685,61 +6480,0 @@\n-    case XML_ELEMENT_NODE:\n-    case XML_TEXT_NODE:\n-    case XML_ENTITY_REF_NODE:\n-    case XML_ENTITY_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_PI_NODE:\n-    case XML_COMMENT_NODE:\n-    case XML_XINCLUDE_END:\n-        break;\n-    \/* case XML_DTD_NODE: *\/ \/* URGENT TODO: DTD-node as well? *\/\n-    default:\n-        return(NULL);\n-    }\n-    if (cur->next != NULL) {\n-    if (cur->next->type == XML_ELEMENT_NODE)\n-        return(cur->next);\n-    cur = cur->next;\n-    do {\n-        cur = cur->next;\n-    } while ((cur != NULL) && (cur->type != XML_ELEMENT_NODE));\n-    return(cur);\n-    }\n-    return(NULL);\n-}\n-\n-#if 0\n-\/**\n- * xmlXPathNextDescendantOrSelfElemParent:\n- * @ctxt:  the XPath Parser context\n- * @cur:  the current node in the traversal\n- *\n- * Traversal function for the \"descendant-or-self\" axis.\n- * Additionally it returns only nodes which can be parents of\n- * element nodes.\n- *\n- *\n- * Returns the next element following that axis\n- *\/\n-static xmlNodePtr\n-xmlXPathNextDescendantOrSelfElemParent(xmlNodePtr cur,\n-                       xmlNodePtr contextNode)\n-{\n-    if (cur == NULL) {\n-    if (contextNode == NULL)\n-        return(NULL);\n-    switch (contextNode->type) {\n-        case XML_ELEMENT_NODE:\n-        case XML_XINCLUDE_START:\n-        case XML_DOCUMENT_FRAG_NODE:\n-        case XML_DOCUMENT_NODE:\n-        case XML_HTML_DOCUMENT_NODE:\n-        return(contextNode);\n-        default:\n-        return(NULL);\n-    }\n-    return(NULL);\n-    } else {\n-    xmlNodePtr start = cur;\n-\n-    while (cur != NULL) {\n-        switch (cur->type) {\n@@ -6747,9 +6481,7 @@\n-        \/* TODO: OK to have XInclude here? *\/\n-        case XML_XINCLUDE_START:\n-        case XML_DOCUMENT_FRAG_NODE:\n-            if (cur != start)\n-            return(cur);\n-            if (cur->children != NULL) {\n-            cur = cur->children;\n-            continue;\n-            }\n+        case XML_TEXT_NODE:\n+        case XML_ENTITY_REF_NODE:\n+        case XML_ENTITY_NODE:\n+        case XML_CDATA_SECTION_NODE:\n+        case XML_PI_NODE:\n+        case XML_COMMENT_NODE:\n+        case XML_XINCLUDE_END:\n@@ -6757,6 +6489,1 @@\n-        \/* Not sure if we need those here. *\/\n-        case XML_DOCUMENT_NODE:\n-        case XML_HTML_DOCUMENT_NODE:\n-            if (cur != start)\n-            return(cur);\n-            return(xmlDocGetRootElement((xmlDocPtr) cur));\n+        \/* case XML_DTD_NODE: *\/ \/* URGENT TODO: DTD-node as well? *\/\n@@ -6764,12 +6491,1 @@\n-            break;\n-        }\n-\n-next_sibling:\n-        if ((cur == NULL) || (cur == contextNode))\n-        return(NULL);\n-        if (cur->next != NULL) {\n-        cur = cur->next;\n-        } else {\n-        cur = cur->parent;\n-        goto next_sibling;\n-        }\n+            return(NULL);\n@@ -6777,0 +6493,8 @@\n+    if (cur->next != NULL) {\n+        if (cur->next->type == XML_ELEMENT_NODE)\n+            return(cur->next);\n+        cur = cur->next;\n+        do {\n+            cur = cur->next;\n+        } while ((cur != NULL) && (cur->type != XML_ELEMENT_NODE));\n+        return(cur);\n@@ -6780,1 +6504,0 @@\n-#endif\n@@ -6797,5 +6520,5 @@\n-    if (ctxt->context->node == NULL)\n-        return(NULL);\n-    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n-        (ctxt->context->node->type == XML_NAMESPACE_DECL))\n-        return(NULL);\n+        if (ctxt->context->node == NULL)\n+            return(NULL);\n+        if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||\n+            (ctxt->context->node->type == XML_NAMESPACE_DECL))\n+            return(NULL);\n@@ -6804,1 +6527,1 @@\n-        return(ctxt->context->doc->children);\n+            return(ctxt->context->doc->children);\n@@ -6811,5 +6534,0 @@\n-    \/*\n-     * Do not descend on entities declarations\n-     *\/\n-    if (cur->children->type != XML_ENTITY_DECL) {\n-        cur = cur->children;\n@@ -6817,1 +6535,1 @@\n-         * Skip DTDs\n+         * Do not descend on entities declarations\n@@ -6819,3 +6537,8 @@\n-        if (cur->type != XML_DTD_NODE)\n-        return(cur);\n-    }\n+        if (cur->children->type != XML_ENTITY_DECL) {\n+            cur = cur->children;\n+            \/*\n+             * Skip DTDs\n+             *\/\n+            if (cur->type != XML_DTD_NODE)\n+                return(cur);\n+        }\n@@ -6827,4 +6550,4 @@\n-    cur = cur->next;\n-    if ((cur->type != XML_ENTITY_DECL) &&\n-        (cur->type != XML_DTD_NODE))\n-        return(cur);\n+        cur = cur->next;\n+        if ((cur->type != XML_ENTITY_DECL) &&\n+            (cur->type != XML_DTD_NODE))\n+            return(cur);\n@@ -6835,6 +6558,6 @@\n-    if (cur == NULL) break;\n-    if (cur == ctxt->context->node) return(NULL);\n-    if (cur->next != NULL) {\n-        cur = cur->next;\n-        return(cur);\n-    }\n+        if (cur == NULL) break;\n+        if (cur == ctxt->context->node) return(NULL);\n+        if (cur->next != NULL) {\n+            cur = cur->next;\n+            return(cur);\n+        }\n@@ -6892,2 +6615,2 @@\n-    if (ctxt->context->node == NULL) return(NULL);\n-    switch (ctxt->context->node->type) {\n+        if (ctxt->context->node == NULL) return(NULL);\n+        switch (ctxt->context->node->type) {\n@@ -6903,13 +6626,13 @@\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        case XML_ENTITY_DECL:\n-        if (ctxt->context->node->parent == NULL)\n-            return((xmlNodePtr) ctxt->context->doc);\n-        if ((ctxt->context->node->parent->type == XML_ELEMENT_NODE) &&\n-            ((ctxt->context->node->parent->name[0] == ' ') ||\n-             (xmlStrEqual(ctxt->context->node->parent->name,\n-                 BAD_CAST \"fake node libxslt\"))))\n-            return(NULL);\n-        return(ctxt->context->node->parent);\n+            case XML_ELEMENT_DECL:\n+            case XML_ATTRIBUTE_DECL:\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+            case XML_ENTITY_DECL:\n+                if (ctxt->context->node->parent == NULL)\n+                    return((xmlNodePtr) ctxt->context->doc);\n+                if ((ctxt->context->node->parent->type == XML_ELEMENT_NODE) &&\n+                    ((ctxt->context->node->parent->name[0] == ' ') ||\n+                     (xmlStrEqual(ctxt->context->node->parent->name,\n+                                 BAD_CAST \"fake node libxslt\"))))\n+                    return(NULL);\n+                return(ctxt->context->node->parent);\n@@ -6917,1 +6640,1 @@\n-        xmlAttrPtr att = (xmlAttrPtr) ctxt->context->node;\n+                xmlAttrPtr att = (xmlAttrPtr) ctxt->context->node;\n@@ -6919,2 +6642,2 @@\n-        return(att->parent);\n-        }\n+                return(att->parent);\n+            }\n@@ -6926,2 +6649,2 @@\n-        case XML_NAMESPACE_DECL: {\n-        xmlNsPtr ns = (xmlNsPtr) ctxt->context->node;\n+            case XML_NAMESPACE_DECL: {\n+                xmlNsPtr ns = (xmlNsPtr) ctxt->context->node;\n@@ -6929,3 +6652,3 @@\n-        if ((ns->next != NULL) &&\n-            (ns->next->type != XML_NAMESPACE_DECL))\n-            return((xmlNodePtr) ns->next);\n+                if ((ns->next != NULL) &&\n+                    (ns->next->type != XML_NAMESPACE_DECL))\n+                    return((xmlNodePtr) ns->next);\n@@ -6933,0 +6656,1 @@\n+            }\n@@ -6935,1 +6659,0 @@\n-    }\n@@ -6962,2 +6685,2 @@\n-    if (ctxt->context->node == NULL) return(NULL);\n-    switch (ctxt->context->node->type) {\n+        if (ctxt->context->node == NULL) return(NULL);\n+        switch (ctxt->context->node->type) {\n@@ -6971,4 +6694,4 @@\n-        case XML_DTD_NODE:\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_ENTITY_DECL:\n+            case XML_DTD_NODE:\n+            case XML_ELEMENT_DECL:\n+            case XML_ATTRIBUTE_DECL:\n+            case XML_ENTITY_DECL:\n@@ -6976,10 +6699,10 @@\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        if (ctxt->context->node->parent == NULL)\n-            return((xmlNodePtr) ctxt->context->doc);\n-        if ((ctxt->context->node->parent->type == XML_ELEMENT_NODE) &&\n-            ((ctxt->context->node->parent->name[0] == ' ') ||\n-             (xmlStrEqual(ctxt->context->node->parent->name,\n-                 BAD_CAST \"fake node libxslt\"))))\n-            return(NULL);\n-        return(ctxt->context->node->parent);\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+                if (ctxt->context->node->parent == NULL)\n+                    return((xmlNodePtr) ctxt->context->doc);\n+                if ((ctxt->context->node->parent->type == XML_ELEMENT_NODE) &&\n+                    ((ctxt->context->node->parent->name[0] == ' ') ||\n+                     (xmlStrEqual(ctxt->context->node->parent->name,\n+                                 BAD_CAST \"fake node libxslt\"))))\n+                    return(NULL);\n+                return(ctxt->context->node->parent);\n@@ -6987,1 +6710,1 @@\n-        xmlAttrPtr tmp = (xmlAttrPtr) ctxt->context->node;\n+                xmlAttrPtr tmp = (xmlAttrPtr) ctxt->context->node;\n@@ -6989,2 +6712,2 @@\n-        return(tmp->parent);\n-        }\n+                return(tmp->parent);\n+            }\n@@ -6996,2 +6719,2 @@\n-        case XML_NAMESPACE_DECL: {\n-        xmlNsPtr ns = (xmlNsPtr) ctxt->context->node;\n+            case XML_NAMESPACE_DECL: {\n+                xmlNsPtr ns = (xmlNsPtr) ctxt->context->node;\n@@ -6999,4 +6722,4 @@\n-        if ((ns->next != NULL) &&\n-            (ns->next->type != XML_NAMESPACE_DECL))\n-            return((xmlNodePtr) ns->next);\n-        \/* Bad, how did that namespace end up here ? *\/\n+                if ((ns->next != NULL) &&\n+                    (ns->next->type != XML_NAMESPACE_DECL))\n+                    return((xmlNodePtr) ns->next);\n+                \/* Bad, how did that namespace end up here ? *\/\n@@ -7004,0 +6727,1 @@\n+            }\n@@ -7005,2 +6729,1 @@\n-    }\n-    return(NULL);\n+        return(NULL);\n@@ -7009,1 +6732,1 @@\n-    return((xmlNodePtr) ctxt->context->doc);\n+        return((xmlNodePtr) ctxt->context->doc);\n@@ -7011,1 +6734,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -7013,9 +6736,9 @@\n-    case XML_ELEMENT_NODE:\n-    case XML_TEXT_NODE:\n-    case XML_CDATA_SECTION_NODE:\n-    case XML_ENTITY_REF_NODE:\n-    case XML_ENTITY_NODE:\n-    case XML_PI_NODE:\n-    case XML_COMMENT_NODE:\n-    case XML_NOTATION_NODE:\n-    case XML_DTD_NODE:\n+        case XML_ELEMENT_NODE:\n+        case XML_TEXT_NODE:\n+        case XML_CDATA_SECTION_NODE:\n+        case XML_ENTITY_REF_NODE:\n+        case XML_ENTITY_NODE:\n+        case XML_PI_NODE:\n+        case XML_COMMENT_NODE:\n+        case XML_NOTATION_NODE:\n+        case XML_DTD_NODE:\n@@ -7025,12 +6748,12 @@\n-    case XML_XINCLUDE_START:\n-    case XML_XINCLUDE_END:\n-        if (cur->parent == NULL)\n-        return(NULL);\n-        if ((cur->parent->type == XML_ELEMENT_NODE) &&\n-        ((cur->parent->name[0] == ' ') ||\n-         (xmlStrEqual(cur->parent->name,\n-                  BAD_CAST \"fake node libxslt\"))))\n-        return(NULL);\n-        return(cur->parent);\n-    case XML_ATTRIBUTE_NODE: {\n-        xmlAttrPtr att = (xmlAttrPtr) cur;\n+        case XML_XINCLUDE_START:\n+        case XML_XINCLUDE_END:\n+            if (cur->parent == NULL)\n+                return(NULL);\n+            if ((cur->parent->type == XML_ELEMENT_NODE) &&\n+                ((cur->parent->name[0] == ' ') ||\n+                 (xmlStrEqual(cur->parent->name,\n+                              BAD_CAST \"fake node libxslt\"))))\n+                return(NULL);\n+            return(cur->parent);\n+        case XML_ATTRIBUTE_NODE: {\n+            xmlAttrPtr att = (xmlAttrPtr) cur;\n@@ -7038,4 +6761,4 @@\n-        return(att->parent);\n-    }\n-    case XML_NAMESPACE_DECL: {\n-        xmlNsPtr ns = (xmlNsPtr) cur;\n+            return(att->parent);\n+        }\n+        case XML_NAMESPACE_DECL: {\n+            xmlNsPtr ns = (xmlNsPtr) cur;\n@@ -7043,4 +6766,10 @@\n-        if ((ns->next != NULL) &&\n-            (ns->next->type != XML_NAMESPACE_DECL))\n-            return((xmlNodePtr) ns->next);\n-        \/* Bad, how did that namespace end up here ? *\/\n+            if ((ns->next != NULL) &&\n+                (ns->next->type != XML_NAMESPACE_DECL))\n+                return((xmlNodePtr) ns->next);\n+            \/* Bad, how did that namespace end up here ? *\/\n+            return(NULL);\n+        }\n+        case XML_DOCUMENT_NODE:\n+        case XML_DOCUMENT_TYPE_NODE:\n+        case XML_DOCUMENT_FRAG_NODE:\n+        case XML_HTML_DOCUMENT_NODE:\n@@ -7048,6 +6777,0 @@\n-    }\n-    case XML_DOCUMENT_NODE:\n-    case XML_DOCUMENT_TYPE_NODE:\n-    case XML_DOCUMENT_FRAG_NODE:\n-    case XML_HTML_DOCUMENT_NODE:\n-        return(NULL);\n@@ -7094,2 +6817,2 @@\n-    (ctxt->context->node->type == XML_NAMESPACE_DECL))\n-    return(NULL);\n+        (ctxt->context->node->type == XML_NAMESPACE_DECL))\n+        return(NULL);\n@@ -7119,2 +6842,2 @@\n-    (ctxt->context->node->type == XML_NAMESPACE_DECL))\n-    return(NULL);\n+        (ctxt->context->node->type == XML_NAMESPACE_DECL))\n+        return(NULL);\n@@ -7126,3 +6849,3 @@\n-    cur = cur->prev;\n-    if (cur == NULL)\n-        return(ctxt->context->node->prev);\n+        cur = cur->prev;\n+        if (cur == NULL)\n+            return(ctxt->context->node->prev);\n@@ -7201,1 +6924,1 @@\n-    node = node->parent;\n+        node = node->parent;\n@@ -7237,1 +6960,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -7239,1 +6962,1 @@\n-    cur = cur->prev;\n+        cur = cur->prev;\n@@ -7294,1 +7017,1 @@\n-    cur = cur->prev;\n+        cur = cur->prev;\n@@ -7331,2 +7054,2 @@\n-        xmlFree(ctxt->context->tmpNsList);\n-    ctxt->context->tmpNsNr = 0;\n+            xmlFree(ctxt->context->tmpNsList);\n+        ctxt->context->tmpNsNr = 0;\n@@ -7343,1 +7066,1 @@\n-    return((xmlNodePtr) xmlXPathXMLNamespace);\n+        return((xmlNodePtr) xmlXPathXMLNamespace);\n@@ -7346,1 +7069,1 @@\n-    return (xmlNodePtr)ctxt->context->tmpNsList[--ctxt->context->tmpNsNr];\n+        return (xmlNodePtr)ctxt->context->tmpNsList[--ctxt->context->tmpNsNr];\n@@ -7348,4 +7071,4 @@\n-    if (ctxt->context->tmpNsList != NULL)\n-        xmlFree(ctxt->context->tmpNsList);\n-    ctxt->context->tmpNsList = NULL;\n-    return(NULL);\n+        if (ctxt->context->tmpNsList != NULL)\n+            xmlFree(ctxt->context->tmpNsList);\n+        ctxt->context->tmpNsList = NULL;\n+        return(NULL);\n@@ -7369,1 +7092,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -7371,1 +7094,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -7374,1 +7097,1 @@\n-        return(NULL);\n+            return(NULL);\n@@ -7381,3 +7104,3 @@\n- *                                    *\n- *        NodeTest Functions                    *\n- *                                    *\n+ *                                                                      *\n+ *              NodeTest Functions                                      *\n+ *                                                                      *\n@@ -7386,1 +7109,1 @@\n-#define IS_FUNCTION            200\n+#define IS_FUNCTION                     200\n@@ -7390,3 +7113,3 @@\n- *                                    *\n- *        Implicit tree core function library            *\n- *                                    *\n+ *                                                                      *\n+ *              Implicit tree core function library                     *\n+ *                                                                      *\n@@ -7404,2 +7127,2 @@\n-    return;\n-    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt,\n+        return;\n+    xmlXPathValuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt,\n@@ -7410,4 +7133,4 @@\n- *                                    *\n- *        The explicit core function library            *\n- *http:\/\/www.w3.org\/Style\/XSL\/Group\/1999\/07\/xpath-19990705.html#corelib    *\n- *                                    *\n+ *                                                                      *\n+ *              The explicit core function library                      *\n+ *http:\/\/www.w3.org\/Style\/XSL\/Group\/1999\/07\/xpath-19990705.html#corelib *\n+ *                                                                      *\n@@ -7430,2 +7153,2 @@\n-    valuePush(ctxt,\n-        xmlXPathCacheNewFloat(ctxt, (double) ctxt->context->contextSize));\n+        xmlXPathValuePush(ctxt,\n+            xmlXPathCacheNewFloat(ctxt, (double) ctxt->context->contextSize));\n@@ -7433,1 +7156,1 @@\n-    XP_ERROR(XPATH_INVALID_CTXT_SIZE);\n+        XP_ERROR(XPATH_INVALID_CTXT_SIZE);\n@@ -7452,1 +7175,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt,\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewFloat(ctxt,\n@@ -7455,1 +7178,1 @@\n-    XP_ERROR(XPATH_INVALID_CTXT_POSITION);\n+        XP_ERROR(XPATH_INVALID_CTXT_POSITION);\n@@ -7473,4 +7196,4 @@\n-    ((ctxt->value->type != XPATH_NODESET) &&\n-     (ctxt->value->type != XPATH_XSLT_TREE)))\n-    XP_ERROR(XPATH_INVALID_TYPE);\n-    cur = valuePop(ctxt);\n+        ((ctxt->value->type != XPATH_NODESET) &&\n+         (ctxt->value->type != XPATH_XSLT_TREE)))\n+        XP_ERROR(XPATH_INVALID_TYPE);\n+    cur = xmlXPathValuePop(ctxt);\n@@ -7479,1 +7202,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt, 0.0));\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewFloat(ctxt, 0.0));\n@@ -7481,2 +7204,2 @@\n-    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt,\n-        (double) cur->nodesetval->nodeNr));\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewFloat(ctxt,\n+            (double) cur->nodesetval->nodeNr));\n@@ -7511,2 +7234,2 @@\n-    while ((!IS_BLANK_CH(*cur)) && (*cur != 0))\n-        cur++;\n+        while ((!IS_BLANK_CH(*cur)) && (*cur != 0))\n+            cur++;\n@@ -7515,1 +7238,1 @@\n-    if (ID == NULL) {\n+        if (ID == NULL) {\n@@ -7543,2 +7266,2 @@\n-    while (IS_BLANK_CH(*cur)) cur++;\n-    ids = cur;\n+        while (IS_BLANK_CH(*cur)) cur++;\n+        ids = cur;\n@@ -7574,1 +7297,1 @@\n-    obj = valuePop(ctxt);\n+    obj = xmlXPathValuePop(ctxt);\n@@ -7577,2 +7300,2 @@\n-    xmlNodeSetPtr ns;\n-    int i;\n+        xmlNodeSetPtr ns;\n+        int i;\n@@ -7580,1 +7303,1 @@\n-    ret = xmlXPathNodeSetCreate(NULL);\n+        ret = xmlXPathNodeSetCreate(NULL);\n@@ -7584,4 +7307,4 @@\n-    if (obj->nodesetval != NULL) {\n-        for (i = 0; i < obj->nodesetval->nodeNr; i++) {\n-        tokens =\n-            xmlXPathCastNodeToString(obj->nodesetval->nodeTab[i]);\n+        if (obj->nodesetval != NULL) {\n+            for (i = 0; i < obj->nodesetval->nodeNr; i++) {\n+                tokens =\n+                    xmlXPathCastNodeToString(obj->nodesetval->nodeTab[i]);\n@@ -7590,1 +7313,1 @@\n-        ns = xmlXPathGetElementsByIds(ctxt->context->doc, tokens);\n+                ns = xmlXPathGetElementsByIds(ctxt->context->doc, tokens);\n@@ -7593,1 +7316,1 @@\n-        ret = xmlXPathNodeSetMerge(ret, ns);\n+                ret = xmlXPathNodeSetMerge(ret, ns);\n@@ -7596,3 +7319,4 @@\n-        xmlXPathFreeNodeSet(ns);\n-        if (tokens != NULL)\n-            xmlFree(tokens);\n+                xmlXPathFreeNodeSet(ns);\n+                if (tokens != NULL)\n+                    xmlFree(tokens);\n+            }\n@@ -7600,4 +7324,3 @@\n-    }\n-    xmlXPathReleaseObject(ctxt->context, obj);\n-    valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt, ret));\n-    return;\n+        xmlXPathReleaseObject(ctxt->context, obj);\n+        xmlXPathValuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt, ret));\n+        return;\n@@ -7613,2 +7336,1 @@\n-    valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt, ret));\n-    return;\n+    xmlXPathValuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt, ret));\n@@ -7637,2 +7359,2 @@\n-    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt, ctxt->context->node));\n-    nargs = 1;\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt, ctxt->context->node));\n+        nargs = 1;\n@@ -7643,4 +7365,4 @@\n-    ((ctxt->value->type != XPATH_NODESET) &&\n-     (ctxt->value->type != XPATH_XSLT_TREE)))\n-    XP_ERROR(XPATH_INVALID_TYPE);\n-    cur = valuePop(ctxt);\n+        ((ctxt->value->type != XPATH_NODESET) &&\n+         (ctxt->value->type != XPATH_XSLT_TREE)))\n+        XP_ERROR(XPATH_INVALID_TYPE);\n+    cur = xmlXPathValuePop(ctxt);\n@@ -7649,1 +7371,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n@@ -7651,18 +7373,18 @@\n-    int i = 0; \/* Should be first in document order !!!!! *\/\n-    switch (cur->nodesetval->nodeTab[i]->type) {\n-    case XML_ELEMENT_NODE:\n-    case XML_ATTRIBUTE_NODE:\n-    case XML_PI_NODE:\n-        if (cur->nodesetval->nodeTab[i]->name[0] == ' ')\n-        valuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n-        else\n-        valuePush(ctxt, xmlXPathCacheNewString(ctxt,\n-            cur->nodesetval->nodeTab[i]->name));\n-        break;\n-    case XML_NAMESPACE_DECL:\n-        valuePush(ctxt, xmlXPathCacheNewString(ctxt,\n-            ((xmlNsPtr)cur->nodesetval->nodeTab[i])->prefix));\n-        break;\n-    default:\n-        valuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n-    }\n+        int i = 0; \/* Should be first in document order !!!!! *\/\n+        switch (cur->nodesetval->nodeTab[i]->type) {\n+        case XML_ELEMENT_NODE:\n+        case XML_ATTRIBUTE_NODE:\n+        case XML_PI_NODE:\n+            if (cur->nodesetval->nodeTab[i]->name[0] == ' ')\n+                xmlXPathValuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n+            else\n+                xmlXPathValuePush(ctxt, xmlXPathCacheNewString(ctxt,\n+                        cur->nodesetval->nodeTab[i]->name));\n+            break;\n+        case XML_NAMESPACE_DECL:\n+            xmlXPathValuePush(ctxt, xmlXPathCacheNewString(ctxt,\n+                        ((xmlNsPtr)cur->nodesetval->nodeTab[i])->prefix));\n+            break;\n+        default:\n+            xmlXPathValuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n+        }\n@@ -7694,2 +7416,2 @@\n-    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt, ctxt->context->node));\n-    nargs = 1;\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt, ctxt->context->node));\n+        nargs = 1;\n@@ -7699,4 +7421,4 @@\n-    ((ctxt->value->type != XPATH_NODESET) &&\n-     (ctxt->value->type != XPATH_XSLT_TREE)))\n-    XP_ERROR(XPATH_INVALID_TYPE);\n-    cur = valuePop(ctxt);\n+        ((ctxt->value->type != XPATH_NODESET) &&\n+         (ctxt->value->type != XPATH_XSLT_TREE)))\n+        XP_ERROR(XPATH_INVALID_TYPE);\n+    cur = xmlXPathValuePop(ctxt);\n@@ -7705,1 +7427,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n@@ -7707,13 +7429,13 @@\n-    int i = 0; \/* Should be first in document order !!!!! *\/\n-    switch (cur->nodesetval->nodeTab[i]->type) {\n-    case XML_ELEMENT_NODE:\n-    case XML_ATTRIBUTE_NODE:\n-        if (cur->nodesetval->nodeTab[i]->ns == NULL)\n-        valuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n-        else\n-        valuePush(ctxt, xmlXPathCacheNewString(ctxt,\n-              cur->nodesetval->nodeTab[i]->ns->href));\n-        break;\n-    default:\n-        valuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n-    }\n+        int i = 0; \/* Should be first in document order !!!!! *\/\n+        switch (cur->nodesetval->nodeTab[i]->type) {\n+        case XML_ELEMENT_NODE:\n+        case XML_ATTRIBUTE_NODE:\n+            if (cur->nodesetval->nodeTab[i]->ns == NULL)\n+                xmlXPathValuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n+            else\n+                xmlXPathValuePush(ctxt, xmlXPathCacheNewString(ctxt,\n+                          cur->nodesetval->nodeTab[i]->ns->href));\n+            break;\n+        default:\n+            xmlXPathValuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n+        }\n@@ -7752,1 +7474,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt, ctxt->context->node));\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt, ctxt->context->node));\n@@ -7761,1 +7483,1 @@\n-    cur = valuePop(ctxt);\n+    cur = xmlXPathValuePop(ctxt);\n@@ -7764,1 +7486,1 @@\n-        valuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n@@ -7771,4 +7493,4 @@\n-        if (cur->nodesetval->nodeTab[i]->name[0] == ' ')\n-            valuePush(ctxt,\n-            xmlXPathCacheNewCString(ctxt, \"\"));\n-        else if ((cur->nodesetval->nodeTab[i]->ns == NULL) ||\n+                if (cur->nodesetval->nodeTab[i]->name[0] == ' ')\n+                    xmlXPathValuePush(ctxt,\n+                        xmlXPathCacheNewCString(ctxt, \"\"));\n+                else if ((cur->nodesetval->nodeTab[i]->ns == NULL) ||\n@@ -7776,11 +7498,11 @@\n-            valuePush(ctxt, xmlXPathCacheNewString(ctxt,\n-                cur->nodesetval->nodeTab[i]->name));\n-        } else {\n-            xmlChar *fullname;\n-\n-            fullname = xmlBuildQName(cur->nodesetval->nodeTab[i]->name,\n-                     cur->nodesetval->nodeTab[i]->ns->prefix,\n-                     NULL, 0);\n-            if (fullname == cur->nodesetval->nodeTab[i]->name)\n-            fullname = xmlStrdup(cur->nodesetval->nodeTab[i]->name);\n-            if (fullname == NULL)\n+                    xmlXPathValuePush(ctxt, xmlXPathCacheNewString(ctxt,\n+                            cur->nodesetval->nodeTab[i]->name));\n+                } else {\n+                    xmlChar *fullname;\n+\n+                    fullname = xmlBuildQName(cur->nodesetval->nodeTab[i]->name,\n+                                     cur->nodesetval->nodeTab[i]->ns->prefix,\n+                                     NULL, 0);\n+                    if (fullname == cur->nodesetval->nodeTab[i]->name)\n+                        fullname = xmlStrdup(cur->nodesetval->nodeTab[i]->name);\n+                    if (fullname == NULL)\n@@ -7788,1 +7510,1 @@\n-            valuePush(ctxt, xmlXPathCacheWrapString(ctxt, fullname));\n+                    xmlXPathValuePush(ctxt, xmlXPathCacheWrapString(ctxt, fullname));\n@@ -7792,2 +7514,2 @@\n-        valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt,\n-            cur->nodesetval->nodeTab[i]));\n+                xmlXPathValuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt,\n+                    cur->nodesetval->nodeTab[i]));\n@@ -7847,2 +7569,2 @@\n-        valuePush(ctxt, xmlXPathCacheWrapString(ctxt, stringval));\n-    return;\n+        xmlXPathValuePush(ctxt, xmlXPathCacheWrapString(ctxt, stringval));\n+        return;\n@@ -7852,1 +7574,1 @@\n-    cur = valuePop(ctxt);\n+    cur = xmlXPathValuePop(ctxt);\n@@ -7861,1 +7583,1 @@\n-    valuePush(ctxt, cur);\n+    xmlXPathValuePush(ctxt, cur);\n@@ -7882,5 +7604,5 @@\n-        return;\n-    if (ctxt->context->node == NULL) {\n-        valuePush(ctxt, xmlXPathCacheNewFloat(ctxt, 0));\n-    } else {\n-        xmlChar *content;\n+            return;\n+        if (ctxt->context->node == NULL) {\n+            xmlXPathValuePush(ctxt, xmlXPathCacheNewFloat(ctxt, 0));\n+        } else {\n+            xmlChar *content;\n@@ -7888,1 +7610,1 @@\n-        content = xmlXPathCastNodeToString(ctxt->context->node);\n+            content = xmlXPathCastNodeToString(ctxt->context->node);\n@@ -7891,5 +7613,5 @@\n-        valuePush(ctxt, xmlXPathCacheNewFloat(ctxt,\n-        xmlUTF8Strlen(content)));\n-        xmlFree(content);\n-    }\n-    return;\n+            xmlXPathValuePush(ctxt, xmlXPathCacheNewFloat(ctxt,\n+                xmlUTF8Strlen(content)));\n+            xmlFree(content);\n+        }\n+        return;\n@@ -7900,3 +7622,3 @@\n-    cur = valuePop(ctxt);\n-    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt,\n-    xmlUTF8Strlen(cur->stringval)));\n+    cur = xmlXPathValuePop(ctxt);\n+    xmlXPathValuePush(ctxt, xmlXPathCacheNewFloat(ctxt,\n+        xmlUTF8Strlen(cur->stringval)));\n@@ -7922,1 +7644,1 @@\n-    CHECK_ARITY(2);\n+        CHECK_ARITY(2);\n@@ -7926,1 +7648,1 @@\n-    cur = valuePop(ctxt);\n+    cur = xmlXPathValuePop(ctxt);\n@@ -7928,2 +7650,2 @@\n-    xmlXPathReleaseObject(ctxt->context, cur);\n-    return;\n+        xmlXPathReleaseObject(ctxt->context, cur);\n+        return;\n@@ -7934,8 +7656,8 @@\n-    CAST_TO_STRING;\n-    newobj = valuePop(ctxt);\n-    if ((newobj == NULL) || (newobj->type != XPATH_STRING)) {\n-        xmlXPathReleaseObject(ctxt->context, newobj);\n-        xmlXPathReleaseObject(ctxt->context, cur);\n-        XP_ERROR(XPATH_INVALID_TYPE);\n-    }\n-    tmp = xmlStrcat(newobj->stringval, cur->stringval);\n+        CAST_TO_STRING;\n+        newobj = xmlXPathValuePop(ctxt);\n+        if ((newobj == NULL) || (newobj->type != XPATH_STRING)) {\n+            xmlXPathReleaseObject(ctxt->context, newobj);\n+            xmlXPathReleaseObject(ctxt->context, cur);\n+            XP_ERROR(XPATH_INVALID_TYPE);\n+        }\n+        tmp = xmlStrcat(newobj->stringval, cur->stringval);\n@@ -7944,4 +7666,4 @@\n-    newobj->stringval = cur->stringval;\n-    cur->stringval = tmp;\n-    xmlXPathReleaseObject(ctxt->context, newobj);\n-    nargs--;\n+        newobj->stringval = cur->stringval;\n+        cur->stringval = tmp;\n+        xmlXPathReleaseObject(ctxt->context, newobj);\n+        nargs--;\n@@ -7949,1 +7671,1 @@\n-    valuePush(ctxt, cur);\n+    xmlXPathValuePush(ctxt, cur);\n@@ -7969,1 +7691,1 @@\n-    needle = valuePop(ctxt);\n+    needle = xmlXPathValuePop(ctxt);\n@@ -7971,1 +7693,1 @@\n-    hay = valuePop(ctxt);\n+    hay = xmlXPathValuePop(ctxt);\n@@ -7974,3 +7696,3 @@\n-    xmlXPathReleaseObject(ctxt->context, hay);\n-    xmlXPathReleaseObject(ctxt->context, needle);\n-    XP_ERROR(XPATH_INVALID_TYPE);\n+        xmlXPathReleaseObject(ctxt->context, hay);\n+        xmlXPathReleaseObject(ctxt->context, needle);\n+        XP_ERROR(XPATH_INVALID_TYPE);\n@@ -7979,1 +7701,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, 1));\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, 1));\n@@ -7981,1 +7703,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, 0));\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, 0));\n@@ -8004,1 +7726,1 @@\n-    needle = valuePop(ctxt);\n+    needle = xmlXPathValuePop(ctxt);\n@@ -8006,1 +7728,1 @@\n-    hay = valuePop(ctxt);\n+    hay = xmlXPathValuePop(ctxt);\n@@ -8009,3 +7731,3 @@\n-    xmlXPathReleaseObject(ctxt->context, hay);\n-    xmlXPathReleaseObject(ctxt->context, needle);\n-    XP_ERROR(XPATH_INVALID_TYPE);\n+        xmlXPathReleaseObject(ctxt->context, hay);\n+        xmlXPathReleaseObject(ctxt->context, needle);\n+        XP_ERROR(XPATH_INVALID_TYPE);\n@@ -8015,1 +7737,1 @@\n-        valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, 0));\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, 0));\n@@ -8017,1 +7739,1 @@\n-        valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, 1));\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, 1));\n@@ -8057,1 +7779,1 @@\n-    CHECK_ARITY(2);\n+        CHECK_ARITY(2);\n@@ -8060,1 +7782,1 @@\n-    CHECK_ARITY(3);\n+        CHECK_ARITY(3);\n@@ -8066,5 +7788,5 @@\n-    CAST_TO_NUMBER;\n-    CHECK_TYPE(XPATH_NUMBER);\n-    len = valuePop(ctxt);\n-    le = len->floatval;\n-    xmlXPathReleaseObject(ctxt->context, len);\n+        CAST_TO_NUMBER;\n+        CHECK_TYPE(XPATH_NUMBER);\n+        len = xmlXPathValuePop(ctxt);\n+        le = len->floatval;\n+        xmlXPathReleaseObject(ctxt->context, len);\n@@ -8075,1 +7797,1 @@\n-    start = valuePop(ctxt);\n+    start = xmlXPathValuePop(ctxt);\n@@ -8080,1 +7802,1 @@\n-    str = valuePop(ctxt);\n+    str = xmlXPathValuePop(ctxt);\n@@ -8116,2 +7838,2 @@\n-    valuePush(ctxt, xmlXPathCacheNewString(ctxt, ret));\n-    xmlFree(ret);\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewString(ctxt, ret));\n+        xmlFree(ret);\n@@ -8119,1 +7841,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n+        xmlXPathValuePush(ctxt, xmlXPathCacheNewCString(ctxt, \"\"));\n@@ -8147,1 +7869,1 @@\n-    find = valuePop(ctxt);\n+    find = xmlXPathValuePop(ctxt);\n@@ -8149,1 +7871,1 @@\n-    str = valuePop(ctxt);\n+    str = xmlXPathValuePop(ctxt);\n@@ -8163,1 +7885,1 @@\n-    valuePush(ctxt, xmlXPathCacheWrapString(ctxt, result));\n+    xmlXPathValuePush(ctxt, xmlXPathCacheWrapString(ctxt, result));\n@@ -8193,1 +7915,1 @@\n-    find = valuePop(ctxt);\n+    find = xmlXPathValuePop(ctxt);\n@@ -8195,1 +7917,1 @@\n-    str = valuePop(ctxt);\n+    str = xmlXPathValuePop(ctxt);\n@@ -8209,1 +7931,1 @@\n-    valuePush(ctxt, xmlXPathCacheWrapString(ctxt, result));\n+    xmlXPathValuePush(ctxt, xmlXPathCacheWrapString(ctxt, result));\n@@ -8241,1 +7963,1 @@\n-        valuePush(ctxt, xmlXPathCacheWrapString(ctxt, source));\n+        xmlXPathValuePush(ctxt, xmlXPathCacheWrapString(ctxt, source));\n@@ -8261,1 +7983,1 @@\n-        blank = 1;\n+            blank = 1;\n@@ -8309,1 +8031,1 @@\n-    to = valuePop(ctxt);\n+    to = xmlXPathValuePop(ctxt);\n@@ -8311,1 +8033,1 @@\n-    from = valuePop(ctxt);\n+    from = xmlXPathValuePop(ctxt);\n@@ -8313,1 +8035,1 @@\n-    str = valuePop(ctxt);\n+    str = xmlXPathValuePop(ctxt);\n@@ -8335,1 +8057,1 @@\n-    target = xmlBufCreateSize(64);\n+    target = xmlBufCreate(50);\n@@ -8376,1 +8098,1 @@\n-        valuePush(ctxt, xmlXPathCacheWrapString(ctxt, content));\n+        xmlXPathValuePush(ctxt, xmlXPathCacheWrapString(ctxt, content));\n@@ -8402,1 +8124,1 @@\n-    cur = valuePop(ctxt);\n+    cur = xmlXPathValuePop(ctxt);\n@@ -8410,1 +8132,1 @@\n-    valuePush(ctxt, cur);\n+    xmlXPathValuePush(ctxt, cur);\n@@ -8442,1 +8164,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, 1));\n+    xmlXPathValuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, 1));\n@@ -8456,1 +8178,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, 0));\n+    xmlXPathValuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, 0));\n@@ -8492,1 +8214,1 @@\n-    val = valuePop(ctxt);\n+    val = xmlXPathValuePop(ctxt);\n@@ -8512,1 +8234,1 @@\n-    xmlFree((void *)theLang);\n+        xmlFree((void *)theLang);\n@@ -8515,1 +8237,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, ret));\n+    xmlXPathValuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, ret));\n@@ -8533,4 +8255,4 @@\n-    if (ctxt->context->node == NULL) {\n-        valuePush(ctxt, xmlXPathCacheNewFloat(ctxt, 0.0));\n-    } else {\n-        xmlChar* content = xmlNodeGetContent(ctxt->context->node);\n+        if (ctxt->context->node == NULL) {\n+            xmlXPathValuePush(ctxt, xmlXPathCacheNewFloat(ctxt, 0.0));\n+        } else {\n+            xmlChar* content = xmlNodeGetContent(ctxt->context->node);\n@@ -8540,5 +8262,5 @@\n-        res = xmlXPathStringEvalNumber(content);\n-        valuePush(ctxt, xmlXPathCacheNewFloat(ctxt, res));\n-        xmlFree(content);\n-    }\n-    return;\n+            res = xmlXPathStringEvalNumber(content);\n+            xmlXPathValuePush(ctxt, xmlXPathCacheNewFloat(ctxt, res));\n+            xmlFree(content);\n+        }\n+        return;\n@@ -8548,1 +8270,1 @@\n-    cur = valuePop(ctxt);\n+    cur = xmlXPathValuePop(ctxt);\n@@ -8556,1 +8278,1 @@\n-    valuePush(ctxt, cur);\n+    xmlXPathValuePush(ctxt, cur);\n@@ -8577,4 +8299,4 @@\n-    ((ctxt->value->type != XPATH_NODESET) &&\n-     (ctxt->value->type != XPATH_XSLT_TREE)))\n-    XP_ERROR(XPATH_INVALID_TYPE);\n-    cur = valuePop(ctxt);\n+        ((ctxt->value->type != XPATH_NODESET) &&\n+         (ctxt->value->type != XPATH_XSLT_TREE)))\n+        XP_ERROR(XPATH_INVALID_TYPE);\n+    cur = xmlXPathValuePop(ctxt);\n@@ -8583,2 +8305,2 @@\n-    for (i = 0; i < cur->nodesetval->nodeNr; i++) {\n-        res += xmlXPathNodeToNumberInternal(ctxt,\n+        for (i = 0; i < cur->nodesetval->nodeNr; i++) {\n+            res += xmlXPathNodeToNumberInternal(ctxt,\n@@ -8586,0 +8308,1 @@\n+        }\n@@ -8587,2 +8310,1 @@\n-    }\n-    valuePush(ctxt, xmlXPathCacheNewFloat(ctxt, res));\n+    xmlXPathValuePush(ctxt, xmlXPathCacheNewFloat(ctxt, res));\n@@ -8669,3 +8391,3 @@\n- *                                    *\n- *            The Parser                    *\n- *                                    *\n+ *                                                                      *\n+ *                      The Parser                                      *\n+ *                                                                      *\n@@ -8683,1 +8405,1 @@\n-                                      int qualified);\n+                                          int qualified);\n@@ -8704,1 +8426,1 @@\n-    return(0);\n+        return(0);\n@@ -8720,9 +8442,1 @@\n-    if ((cur[1] & 0xc0) != 0x80)\n-        goto encoding_error;\n-    if ((c & 0xe0) == 0xe0) {\n-\n-        if ((cur[2] & 0xc0) != 0x80)\n-        goto encoding_error;\n-        if ((c & 0xf0) == 0xf0) {\n-        if (((c & 0xf8) != 0xf0) ||\n-            ((cur[3] & 0xc0) != 0x80))\n+        if ((cur[1] & 0xc0) != 0x80)\n@@ -8730,6 +8444,21 @@\n-        \/* 4-byte code *\/\n-        *len = 4;\n-        val = (cur[0] & 0x7) << 18;\n-        val |= (cur[1] & 0x3f) << 12;\n-        val |= (cur[2] & 0x3f) << 6;\n-        val |= cur[3] & 0x3f;\n+        if ((c & 0xe0) == 0xe0) {\n+\n+            if ((cur[2] & 0xc0) != 0x80)\n+                goto encoding_error;\n+            if ((c & 0xf0) == 0xf0) {\n+                if (((c & 0xf8) != 0xf0) ||\n+                    ((cur[3] & 0xc0) != 0x80))\n+                    goto encoding_error;\n+                \/* 4-byte code *\/\n+                *len = 4;\n+                val = (cur[0] & 0x7) << 18;\n+                val |= (cur[1] & 0x3f) << 12;\n+                val |= (cur[2] & 0x3f) << 6;\n+                val |= cur[3] & 0x3f;\n+            } else {\n+              \/* 3-byte code *\/\n+                *len = 3;\n+                val = (cur[0] & 0xf) << 12;\n+                val |= (cur[1] & 0x3f) << 6;\n+                val |= cur[2] & 0x3f;\n+            }\n@@ -8737,5 +8466,4 @@\n-          \/* 3-byte code *\/\n-        *len = 3;\n-        val = (cur[0] & 0xf) << 12;\n-        val |= (cur[1] & 0x3f) << 6;\n-        val |= cur[2] & 0x3f;\n+          \/* 2-byte code *\/\n+            *len = 2;\n+            val = (cur[0] & 0x1f) << 6;\n+            val |= cur[1] & 0x3f;\n@@ -8743,0 +8471,4 @@\n+        if (!IS_CHAR(val)) {\n+            XP_ERROR0(XPATH_INVALID_CHAR_ERROR);\n+        }\n+        return(val);\n@@ -8744,13 +8476,3 @@\n-      \/* 2-byte code *\/\n-        *len = 2;\n-        val = (cur[0] & 0x1f) << 6;\n-        val |= cur[1] & 0x3f;\n-    }\n-    if (!IS_CHAR(val)) {\n-        XP_ERROR0(XPATH_INVALID_CHAR_ERROR);\n-    }\n-    return(val);\n-    } else {\n-    \/* 1-byte code *\/\n-    *len = 1;\n-    return(*cur);\n+        \/* 1-byte code *\/\n+        *len = 1;\n+        return(*cur);\n@@ -8796,8 +8518,2 @@\n-    ((*in >= 0x41) && (*in <= 0x5A)) ||\n-    (*in == '_')) {\n-    in++;\n-    while (((*in >= 0x61) && (*in <= 0x7A)) ||\n-           ((*in >= 0x41) && (*in <= 0x5A)) ||\n-           ((*in >= 0x30) && (*in <= 0x39)) ||\n-           (*in == '_') || (*in == '.') ||\n-           (*in == '-'))\n+        ((*in >= 0x41) && (*in <= 0x5A)) ||\n+        (*in == '_')) {\n@@ -8805,1 +8521,7 @@\n-    if ((*in == ' ') || (*in == '>') || (*in == '\/') ||\n+        while (((*in >= 0x61) && (*in <= 0x7A)) ||\n+               ((*in >= 0x41) && (*in <= 0x5A)) ||\n+               ((*in >= 0x30) && (*in <= 0x39)) ||\n+               (*in == '_') || (*in == '.') ||\n+               (*in == '-'))\n+            in++;\n+        if ((*in == ' ') || (*in == '>') || (*in == '\/') ||\n@@ -8808,4 +8530,4 @@\n-        count = in - ctxt->cur;\n-        if (count == 0)\n-        return(NULL);\n-        ret = xmlStrndup(ctxt->cur, count);\n+            count = in - ctxt->cur;\n+            if (count == 0)\n+                return(NULL);\n+            ret = xmlStrndup(ctxt->cur, count);\n@@ -8814,3 +8536,3 @@\n-        ctxt->cur = in;\n-        return(ret);\n-    }\n+            ctxt->cur = in;\n+            return(ret);\n+        }\n@@ -8847,2 +8569,2 @@\n-    NEXT;\n-    ret = xmlXPathParseNCName(ctxt);\n+        NEXT;\n+        ret = xmlXPathParseNCName(ctxt);\n@@ -8879,8 +8601,2 @@\n-    ((*in >= 0x41) && (*in <= 0x5A)) ||\n-    (*in == '_') || (*in == ':')) {\n-    in++;\n-    while (((*in >= 0x61) && (*in <= 0x7A)) ||\n-           ((*in >= 0x41) && (*in <= 0x5A)) ||\n-           ((*in >= 0x30) && (*in <= 0x39)) ||\n-           (*in == '_') || (*in == '-') ||\n-           (*in == ':') || (*in == '.'))\n+        ((*in >= 0x41) && (*in <= 0x5A)) ||\n+        (*in == '_') || (*in == ':')) {\n@@ -8888,2 +8604,8 @@\n-    if ((*in > 0) && (*in < 0x80)) {\n-        count = in - ctxt->cur;\n+        while (((*in >= 0x61) && (*in <= 0x7A)) ||\n+               ((*in >= 0x41) && (*in <= 0x5A)) ||\n+               ((*in >= 0x30) && (*in <= 0x39)) ||\n+               (*in == '_') || (*in == '-') ||\n+               (*in == ':') || (*in == '.'))\n+            in++;\n+        if ((*in > 0) && (*in < 0x80)) {\n+            count = in - ctxt->cur;\n@@ -8894,1 +8616,1 @@\n-        ret = xmlStrndup(ctxt->cur, count);\n+            ret = xmlStrndup(ctxt->cur, count);\n@@ -8897,3 +8619,3 @@\n-        ctxt->cur = in;\n-        return(ret);\n-    }\n+            ctxt->cur = in;\n+            return(ret);\n+        }\n@@ -8918,1 +8640,1 @@\n-    (!IS_LETTER(c) && (c != '_') &&\n+        (!IS_LETTER(c) && (c != '_') &&\n@@ -8920,1 +8642,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -8924,1 +8646,1 @@\n-       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n+           ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n@@ -8926,13 +8648,13 @@\n-        (c == '_') || ((qualified) && (c == ':')) ||\n-        (IS_COMBINING(c)) ||\n-        (IS_EXTENDER(c)))) {\n-    COPY_BUF(l,buf,len,c);\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n-    if (len >= XML_MAX_NAMELEN) {\n-        \/*\n-         * Okay someone managed to make a huge name, so he's ready to pay\n-         * for the processing speed.\n-         *\/\n-        xmlChar *buffer;\n-        int max = len * 2;\n+            (c == '_') || ((qualified) && (c == ':')) ||\n+            (IS_COMBINING(c)) ||\n+            (IS_EXTENDER(c)))) {\n+        COPY_BUF(buf,len,c);\n+        NEXTL(l);\n+        c = CUR_CHAR(l);\n+        if (len >= XML_MAX_NAMELEN) {\n+            \/*\n+             * Okay someone managed to make a huge name, so he's ready to pay\n+             * for the processing speed.\n+             *\/\n+            xmlChar *buffer;\n+            int max = len * 2;\n@@ -8943,2 +8665,2 @@\n-        buffer = (xmlChar *) xmlMallocAtomic(max);\n-        if (buffer == NULL) {\n+            buffer = xmlMalloc(max);\n+            if (buffer == NULL) {\n@@ -8947,8 +8669,8 @@\n-        }\n-        memcpy(buffer, buf, len);\n-        while ((IS_LETTER(c)) || (IS_DIGIT(c)) || \/* test bigname.xml *\/\n-           (c == '.') || (c == '-') ||\n-           (c == '_') || ((qualified) && (c == ':')) ||\n-           (IS_COMBINING(c)) ||\n-           (IS_EXTENDER(c))) {\n-        if (len + 10 > max) {\n+            }\n+            memcpy(buffer, buf, len);\n+            while ((IS_LETTER(c)) || (IS_DIGIT(c)) || \/* test bigname.xml *\/\n+                   (c == '.') || (c == '-') ||\n+                   (c == '_') || ((qualified) && (c == ':')) ||\n+                   (IS_COMBINING(c)) ||\n+                   (IS_EXTENDER(c))) {\n+                if (len + 10 > max) {\n@@ -8956,1 +8678,4 @@\n-                    if (max > XML_MAX_NAME_LENGTH) {\n+                    int newSize;\n+\n+                    newSize = xmlGrowCapacity(max, 1, 1, XML_MAX_NAME_LENGTH);\n+                    if (newSize < 0) {\n@@ -8958,1 +8683,2 @@\n-                        XP_ERRORNULL(XPATH_EXPR_ERROR);\n+                        xmlXPathErr(ctxt, XPATH_EXPR_ERROR);\n+                        return(NULL);\n@@ -8960,3 +8686,2 @@\n-            max *= 2;\n-            tmp = (xmlChar *) xmlRealloc(buffer, max);\n-            if (tmp == NULL) {\n+                    tmp = xmlRealloc(buffer, newSize);\n+                    if (tmp == NULL) {\n@@ -8966,1 +8691,1 @@\n-            }\n+                    }\n@@ -8968,0 +8693,8 @@\n+                    max = newSize;\n+                }\n+                COPY_BUF(buffer,len,c);\n+                NEXTL(l);\n+                c = CUR_CHAR(l);\n+            }\n+            buffer[len] = 0;\n+            return(buffer);\n@@ -8969,7 +8702,0 @@\n-        COPY_BUF(l,buffer,len,c);\n-        NEXTL(l);\n-        c = CUR_CHAR(l);\n-        }\n-        buffer[len] = 0;\n-        return(buffer);\n-    }\n@@ -8978,1 +8704,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -9018,2 +8744,2 @@\n-    isneg = 1;\n-    cur++;\n+        isneg = 1;\n+        cur++;\n@@ -9032,6 +8758,6 @@\n-    ret = ret * 10;\n-    tmp = (*cur - '0');\n-    ok = 1;\n-    cur++;\n-    temp = (double) tmp;\n-    ret = ret + temp;\n+        ret = ret * 10;\n+        tmp = (*cur - '0');\n+        ok = 1;\n+        cur++;\n+        temp = (double) tmp;\n+        ret = ret + temp;\n@@ -9042,3 +8768,3 @@\n-    ret = ret * 10 + (*cur - '0');\n-    ok = 1;\n-    cur++;\n+        ret = ret * 10 + (*cur - '0');\n+        ok = 1;\n+        cur++;\n@@ -9049,2 +8775,2 @@\n-    int v, frac = 0, max;\n-    double fraction = 0;\n+        int v, frac = 0, max;\n+        double fraction = 0;\n@@ -9053,3 +8779,3 @@\n-    if (((*cur < '0') || (*cur > '9')) && (!ok)) {\n-        return(xmlXPathNAN);\n-    }\n+        if (((*cur < '0') || (*cur > '9')) && (!ok)) {\n+            return(xmlXPathNAN);\n+        }\n@@ -9057,2 +8783,2 @@\n-        frac = frac + 1;\n-        cur++;\n+            frac = frac + 1;\n+            cur++;\n@@ -9061,10 +8787,10 @@\n-    while (((*cur >= '0') && (*cur <= '9')) && (frac < max)) {\n-        v = (*cur - '0');\n-        fraction = fraction * 10 + v;\n-        frac = frac + 1;\n-        cur++;\n-    }\n-    fraction \/= pow(10.0, frac);\n-    ret = ret + fraction;\n-    while ((*cur >= '0') && (*cur <= '9'))\n-        cur++;\n+        while (((*cur >= '0') && (*cur <= '9')) && (frac < max)) {\n+            v = (*cur - '0');\n+            fraction = fraction * 10 + v;\n+            frac = frac + 1;\n+            cur++;\n+        }\n+        fraction \/= pow(10.0, frac);\n+        ret = ret + fraction;\n+        while ((*cur >= '0') && (*cur <= '9'))\n+            cur++;\n@@ -9075,2 +8801,2 @@\n-    is_exponent_negative = 1;\n-    cur++;\n+        is_exponent_negative = 1;\n+        cur++;\n@@ -9082,2 +8808,2 @@\n-      exponent = exponent * 10 + (*cur - '0');\n-    cur++;\n+          exponent = exponent * 10 + (*cur - '0');\n+        cur++;\n@@ -9129,2 +8855,2 @@\n-    ret = ret * 10;\n-    tmp = (CUR - '0');\n+        ret = ret * 10;\n+        tmp = (CUR - '0');\n@@ -9133,2 +8859,2 @@\n-    temp = (double) tmp;\n-    ret = ret + temp;\n+        temp = (double) tmp;\n+        ret = ret + temp;\n@@ -9139,3 +8865,3 @@\n-    ret = ret * 10 + (CUR - '0');\n-    ok = 1;\n-    NEXT;\n+        ret = ret * 10 + (CUR - '0');\n+        ok = 1;\n+        NEXT;\n@@ -9145,2 +8871,2 @@\n-    int v, frac = 0, max;\n-    double fraction = 0;\n+        int v, frac = 0, max;\n+        double fraction = 0;\n@@ -9158,3 +8884,3 @@\n-        v = (CUR - '0');\n-        fraction = fraction * 10 + v;\n-        frac = frac + 1;\n+            v = (CUR - '0');\n+            fraction = fraction * 10 + v;\n+            frac = frac + 1;\n@@ -9174,2 +8900,2 @@\n-        NEXT;\n-    }\n+            NEXT;\n+        }\n@@ -9187,1 +8913,1 @@\n-    ctxt->error = XPATH_MEMORY_ERROR;\n+        ctxt->error = XPATH_MEMORY_ERROR;\n@@ -9216,1 +8942,1 @@\n-    XP_ERRORNULL(XPATH_START_LITERAL_ERROR);\n+        XP_ERRORNULL(XPATH_START_LITERAL_ERROR);\n@@ -9292,1 +9018,1 @@\n-    XP_ERROR(XPATH_VARIABLE_REF_ERROR);\n+        XP_ERROR(XPATH_VARIABLE_REF_ERROR);\n@@ -9298,1 +9024,1 @@\n-    XP_ERROR(XPATH_VARIABLE_REF_ERROR);\n+        XP_ERROR(XPATH_VARIABLE_REF_ERROR);\n@@ -9307,1 +9033,1 @@\n-    XP_ERROR(XPATH_FORBID_VARIABLE_ERROR);\n+        XP_ERROR(XPATH_FORBID_VARIABLE_ERROR);\n@@ -9327,1 +9053,1 @@\n-    return(0);\n+        return(0);\n@@ -9330,1 +9056,1 @@\n-    return(1);\n+        return(1);\n@@ -9332,1 +9058,1 @@\n-    return(1);\n+        return(1);\n@@ -9334,1 +9060,1 @@\n-    return(1);\n+        return(1);\n@@ -9336,1 +9062,1 @@\n-    return(1);\n+        return(1);\n@@ -9359,2 +9085,2 @@\n-    xmlFree(prefix);\n-    XP_ERROR(XPATH_EXPR_ERROR);\n+        xmlFree(prefix);\n+        XP_ERROR(XPATH_EXPR_ERROR);\n@@ -9365,3 +9091,3 @@\n-    xmlFree(name);\n-    xmlFree(prefix);\n-    XP_ERROR(XPATH_EXPR_ERROR);\n+        xmlFree(name);\n+        xmlFree(prefix);\n+        XP_ERROR(XPATH_EXPR_ERROR);\n@@ -9376,1 +9102,1 @@\n-    xmlStrEqual(name, BAD_CAST \"count\"))\n+        xmlStrEqual(name, BAD_CAST \"count\"))\n@@ -9378,1 +9104,1 @@\n-    sort = 0;\n+        sort = 0;\n@@ -9382,16 +9108,19 @@\n-    while (CUR != 0) {\n-        int op1 = ctxt->comp->last;\n-        ctxt->comp->last = -1;\n-        xmlXPathCompileExpr(ctxt, sort);\n-        if (ctxt->error != XPATH_EXPRESSION_OK) {\n-        xmlFree(name);\n-        xmlFree(prefix);\n-        return;\n-        }\n-        PUSH_BINARY_EXPR(XPATH_OP_ARG, op1, ctxt->comp->last, 0, 0);\n-        nbargs++;\n-        if (CUR == ')') break;\n-        if (CUR != ',') {\n-        xmlFree(name);\n-        xmlFree(prefix);\n-        XP_ERROR(XPATH_EXPR_ERROR);\n+        while (CUR != 0) {\n+            int op1 = ctxt->comp->last;\n+            ctxt->comp->last = -1;\n+            xmlXPathCompileExpr(ctxt, sort);\n+            if (ctxt->error != XPATH_EXPRESSION_OK) {\n+                xmlFree(name);\n+                xmlFree(prefix);\n+                return;\n+            }\n+            PUSH_BINARY_EXPR(XPATH_OP_ARG, op1, ctxt->comp->last, 0, 0);\n+            nbargs++;\n+            if (CUR == ')') break;\n+            if (CUR != ',') {\n+                xmlFree(name);\n+                xmlFree(prefix);\n+                XP_ERROR(XPATH_EXPR_ERROR);\n+            }\n+            NEXT;\n+            SKIP_BLANKS;\n@@ -9399,3 +9128,0 @@\n-        NEXT;\n-        SKIP_BLANKS;\n-    }\n@@ -9428,9 +9154,9 @@\n-    NEXT;\n-    SKIP_BLANKS;\n-    xmlXPathCompileExpr(ctxt, 1);\n-    CHECK_ERROR;\n-    if (CUR != ')') {\n-        XP_ERROR(XPATH_EXPR_ERROR);\n-    }\n-    NEXT;\n-    SKIP_BLANKS;\n+        NEXT;\n+        SKIP_BLANKS;\n+        xmlXPathCompileExpr(ctxt, 1);\n+        CHECK_ERROR;\n+        if (CUR != ')') {\n+            XP_ERROR(XPATH_EXPR_ERROR);\n+        }\n+        NEXT;\n+        SKIP_BLANKS;\n@@ -9438,1 +9164,1 @@\n-    xmlXPathCompNumber(ctxt);\n+        xmlXPathCompNumber(ctxt);\n@@ -9440,1 +9166,1 @@\n-    xmlXPathCompLiteral(ctxt);\n+        xmlXPathCompLiteral(ctxt);\n@@ -9442,1 +9168,1 @@\n-    xmlXPathCompFunctionCall(ctxt);\n+        xmlXPathCompFunctionCall(ctxt);\n@@ -9469,2 +9195,2 @@\n-    xmlXPathCompPredicate(ctxt, 1);\n-    SKIP_BLANKS;\n+        xmlXPathCompPredicate(ctxt, 1);\n+        SKIP_BLANKS;\n@@ -9504,1 +9230,1 @@\n-    (!IS_LETTER(c) && (c != '_') &&\n+        (!IS_LETTER(c) && (c != '_') &&\n@@ -9506,1 +9232,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -9510,1 +9236,1 @@\n-       ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n+           ((IS_LETTER(c)) || (IS_DIGIT(c)) ||\n@@ -9512,5 +9238,5 @@\n-        (c == '_') || (c == ':') ||\n-        (IS_COMBINING(c)) ||\n-        (IS_EXTENDER(c)))) {\n-    NEXTL(l);\n-    c = CUR_CHAR(l);\n+            (c == '_') || (c == ':') ||\n+            (IS_COMBINING(c)) ||\n+            (IS_EXTENDER(c)))) {\n+        NEXTL(l);\n+        c = CUR_CHAR(l);\n@@ -9550,1 +9276,1 @@\n-    (IS_ASCII_DIGIT(CUR)) ||\n+        (IS_ASCII_DIGIT(CUR)) ||\n@@ -9552,2 +9278,2 @@\n-    (CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {\n-    lc = 0;\n+        (CUR == '.' && IS_ASCII_DIGIT(NXT(1)))) {\n+        lc = 0;\n@@ -9555,2 +9281,2 @@\n-    \/* relative or absolute location path *\/\n-    lc = 1;\n+        \/* relative or absolute location path *\/\n+        lc = 1;\n@@ -9558,2 +9284,2 @@\n-    \/* relative or absolute location path *\/\n-    lc = 1;\n+        \/* relative or absolute location path *\/\n+        lc = 1;\n@@ -9561,2 +9287,2 @@\n-    \/* relative abbreviated attribute location path *\/\n-    lc = 1;\n+        \/* relative abbreviated attribute location path *\/\n+        lc = 1;\n@@ -9564,17 +9290,1 @@\n-    \/* relative abbreviated attribute location path *\/\n-    lc = 1;\n-    } else {\n-    \/*\n-     * Problem is finding if we have a name here whether it's:\n-     *   - a nodetype\n-     *   - a function call in which case it's followed by '('\n-     *   - an axis in which case it's followed by ':'\n-     *   - a element name\n-     * We do an a priori analysis here rather than having to\n-     * maintain parsed token content through the recursive function\n-     * calls. This looks uglier but makes the code easier to\n-     * read\/write\/debug.\n-     *\/\n-    SKIP_BLANKS;\n-    name = xmlXPathScanName(ctxt);\n-    if ((name != NULL) && (xmlStrstr(name, (xmlChar *) \"::\") != NULL)) {\n+        \/* relative abbreviated attribute location path *\/\n@@ -9582,3 +9292,19 @@\n-        xmlFree(name);\n-    } else if (name != NULL) {\n-        int len =xmlStrlen(name);\n+    } else {\n+        \/*\n+         * Problem is finding if we have a name here whether it's:\n+         *   - a nodetype\n+         *   - a function call in which case it's followed by '('\n+         *   - an axis in which case it's followed by ':'\n+         *   - a element name\n+         * We do an a priori analysis here rather than having to\n+         * maintain parsed token content through the recursive function\n+         * calls. This looks uglier but makes the code easier to\n+         * read\/write\/debug.\n+         *\/\n+        SKIP_BLANKS;\n+        name = xmlXPathScanName(ctxt);\n+        if ((name != NULL) && (xmlStrstr(name, (xmlChar *) \"::\") != NULL)) {\n+            lc = 1;\n+            xmlFree(name);\n+        } else if (name != NULL) {\n+            int len =xmlStrlen(name);\n@@ -9587,18 +9313,14 @@\n-        while (NXT(len) != 0) {\n-        if (NXT(len) == '\/') {\n-            \/* element name *\/\n-            lc = 1;\n-            break;\n-        } else if (IS_BLANK_CH(NXT(len))) {\n-            \/* ignore blanks *\/\n-            ;\n-        } else if (NXT(len) == ':') {\n-            lc = 1;\n-            break;\n-        } else if ((NXT(len) == '(')) {\n-            \/* Node Type or Function *\/\n-            if (xmlXPathIsNodeType(name)) {\n-            lc = 1;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-                    } else if (ctxt->xptr &&\n-                               xmlStrEqual(name, BAD_CAST \"range-to\")) {\n+            while (NXT(len) != 0) {\n+                if (NXT(len) == '\/') {\n+                    \/* element name *\/\n+                    lc = 1;\n+                    break;\n+                } else if (IS_BLANK_CH(NXT(len))) {\n+                    \/* ignore blanks *\/\n+                    ;\n+                } else if (NXT(len) == ':') {\n+                    lc = 1;\n+                    break;\n+                } else if ((NXT(len) == '(')) {\n+                    \/* Node Type or Function *\/\n+                    if (xmlXPathIsNodeType(name)) {\n@@ -9606,4 +9328,3 @@\n-#endif\n-            } else {\n-            lc = 0;\n-            }\n+                    } else {\n+                        lc = 0;\n+                    }\n@@ -9611,8 +9332,19 @@\n-        } else if ((NXT(len) == '[')) {\n-            \/* element name *\/\n-            lc = 1;\n-            break;\n-        } else if ((NXT(len) == '<') || (NXT(len) == '>') ||\n-               (NXT(len) == '=')) {\n-            lc = 1;\n-            break;\n+                } else if ((NXT(len) == '[')) {\n+                    \/* element name *\/\n+                    lc = 1;\n+                    break;\n+                } else if ((NXT(len) == '<') || (NXT(len) == '>') ||\n+                           (NXT(len) == '=')) {\n+                    lc = 1;\n+                    break;\n+                } else {\n+                    lc = 1;\n+                    break;\n+                }\n+                len++;\n+            }\n+            if (NXT(len) == 0) {\n+                \/* element name *\/\n+                lc = 1;\n+            }\n+            xmlFree(name);\n@@ -9620,8 +9352,2 @@\n-            lc = 1;\n-            break;\n-        }\n-        len++;\n-        }\n-        if (NXT(len) == 0) {\n-        \/* element name *\/\n-        lc = 1;\n+            \/* make sure all cases are covered explicitly *\/\n+            XP_ERROR(XPATH_EXPR_ERROR);\n@@ -9629,5 +9355,0 @@\n-        xmlFree(name);\n-    } else {\n-        \/* make sure all cases are covered explicitly *\/\n-        XP_ERROR(XPATH_EXPR_ERROR);\n-    }\n@@ -9637,6 +9358,6 @@\n-    if (CUR == '\/') {\n-        PUSH_LEAVE_EXPR(XPATH_OP_ROOT, 0, 0);\n-    } else {\n-        PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);\n-    }\n-    xmlXPathCompLocationPath(ctxt);\n+        if (CUR == '\/') {\n+            PUSH_LEAVE_EXPR(XPATH_OP_ROOT, 0, 0);\n+        } else {\n+            PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);\n+        }\n+        xmlXPathCompLocationPath(ctxt);\n@@ -9644,5 +9365,5 @@\n-    xmlXPathCompFilterExpr(ctxt);\n-    CHECK_ERROR;\n-    if ((CUR == '\/') && (NXT(1) == '\/')) {\n-        SKIP(2);\n-        SKIP_BLANKS;\n+        xmlXPathCompFilterExpr(ctxt);\n+        CHECK_ERROR;\n+        if ((CUR == '\/') && (NXT(1) == '\/')) {\n+            SKIP(2);\n+            SKIP_BLANKS;\n@@ -9650,2 +9371,2 @@\n-        PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,\n-            NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n+            PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,\n+                    NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n@@ -9653,4 +9374,4 @@\n-        xmlXPathCompRelativeLocationPath(ctxt);\n-    } else if (CUR == '\/') {\n-        xmlXPathCompRelativeLocationPath(ctxt);\n-    }\n+            xmlXPathCompRelativeLocationPath(ctxt);\n+        } else if (CUR == '\/') {\n+            xmlXPathCompRelativeLocationPath(ctxt);\n+        }\n@@ -9677,2 +9398,2 @@\n-    int op1 = ctxt->comp->last;\n-    PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);\n+        int op1 = ctxt->comp->last;\n+        PUSH_LEAVE_EXPR(XPATH_OP_NODE, 0, 0);\n@@ -9680,3 +9401,3 @@\n-    NEXT;\n-    SKIP_BLANKS;\n-    xmlXPathCompPathExpr(ctxt);\n+        NEXT;\n+        SKIP_BLANKS;\n+        xmlXPathCompPathExpr(ctxt);\n@@ -9684,1 +9405,1 @@\n-    PUSH_BINARY_EXPR(XPATH_OP_UNION, op1, ctxt->comp->last, 0, 0);\n+        PUSH_BINARY_EXPR(XPATH_OP_UNION, op1, ctxt->comp->last, 0, 0);\n@@ -9686,1 +9407,1 @@\n-    SKIP_BLANKS;\n+        SKIP_BLANKS;\n@@ -9708,3 +9429,3 @@\n-    found = 1;\n-    NEXT;\n-    SKIP_BLANKS;\n+        found = 1;\n+        NEXT;\n+        SKIP_BLANKS;\n@@ -9716,4 +9437,4 @@\n-    if (minus)\n-        PUSH_UNARY_EXPR(XPATH_OP_PLUS, ctxt->comp->last, 2, 0);\n-    else\n-        PUSH_UNARY_EXPR(XPATH_OP_PLUS, ctxt->comp->last, 3, 0);\n+        if (minus)\n+            PUSH_UNARY_EXPR(XPATH_OP_PLUS, ctxt->comp->last, 2, 0);\n+        else\n+            PUSH_UNARY_EXPR(XPATH_OP_PLUS, ctxt->comp->last, 3, 0);\n@@ -9744,2 +9465,2 @@\n-    int op = -1;\n-    int op1 = ctxt->comp->last;\n+        int op = -1;\n+        int op1 = ctxt->comp->last;\n@@ -9748,10 +9469,10 @@\n-        op = 0;\n-        NEXT;\n-    } else if (CUR == 'd') {\n-        op = 1;\n-        SKIP(3);\n-    } else if (CUR == 'm') {\n-        op = 2;\n-        SKIP(3);\n-    }\n-    SKIP_BLANKS;\n+            op = 0;\n+            NEXT;\n+        } else if (CUR == 'd') {\n+            op = 1;\n+            SKIP(3);\n+        } else if (CUR == 'm') {\n+            op = 2;\n+            SKIP(3);\n+        }\n+        SKIP_BLANKS;\n@@ -9759,3 +9480,3 @@\n-    CHECK_ERROR;\n-    PUSH_BINARY_EXPR(XPATH_OP_MULT, op1, ctxt->comp->last, op, 0);\n-    SKIP_BLANKS;\n+        CHECK_ERROR;\n+        PUSH_BINARY_EXPR(XPATH_OP_MULT, op1, ctxt->comp->last, op, 0);\n+        SKIP_BLANKS;\n@@ -9783,2 +9504,2 @@\n-    int plus;\n-    int op1 = ctxt->comp->last;\n+        int plus;\n+        int op1 = ctxt->comp->last;\n@@ -9787,3 +9508,3 @@\n-    else plus = 0;\n-    NEXT;\n-    SKIP_BLANKS;\n+        else plus = 0;\n+        NEXT;\n+        SKIP_BLANKS;\n@@ -9791,3 +9512,3 @@\n-    CHECK_ERROR;\n-    PUSH_BINARY_EXPR(XPATH_OP_PLUS, op1, ctxt->comp->last, plus, 0);\n-    SKIP_BLANKS;\n+        CHECK_ERROR;\n+        PUSH_BINARY_EXPR(XPATH_OP_PLUS, op1, ctxt->comp->last, plus, 0);\n+        SKIP_BLANKS;\n@@ -9821,2 +9542,2 @@\n-    int inf, strict;\n-    int op1 = ctxt->comp->last;\n+        int inf, strict;\n+        int op1 = ctxt->comp->last;\n@@ -9825,6 +9546,6 @@\n-    else inf = 0;\n-    if (NXT(1) == '=') strict = 0;\n-    else strict = 1;\n-    NEXT;\n-    if (!strict) NEXT;\n-    SKIP_BLANKS;\n+        else inf = 0;\n+        if (NXT(1) == '=') strict = 0;\n+        else strict = 1;\n+        NEXT;\n+        if (!strict) NEXT;\n+        SKIP_BLANKS;\n@@ -9832,3 +9553,3 @@\n-    CHECK_ERROR;\n-    PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);\n-    SKIP_BLANKS;\n+        CHECK_ERROR;\n+        PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);\n+        SKIP_BLANKS;\n@@ -9860,2 +9581,2 @@\n-    int eq;\n-    int op1 = ctxt->comp->last;\n+        int eq;\n+        int op1 = ctxt->comp->last;\n@@ -9864,4 +9585,4 @@\n-    else eq = 0;\n-    NEXT;\n-    if (!eq) NEXT;\n-    SKIP_BLANKS;\n+        else eq = 0;\n+        NEXT;\n+        if (!eq) NEXT;\n+        SKIP_BLANKS;\n@@ -9869,3 +9590,3 @@\n-    CHECK_ERROR;\n-    PUSH_BINARY_EXPR(XPATH_OP_EQUAL, op1, ctxt->comp->last, eq, 0);\n-    SKIP_BLANKS;\n+        CHECK_ERROR;\n+        PUSH_BINARY_EXPR(XPATH_OP_EQUAL, op1, ctxt->comp->last, eq, 0);\n+        SKIP_BLANKS;\n@@ -9891,1 +9612,1 @@\n-    int op1 = ctxt->comp->last;\n+        int op1 = ctxt->comp->last;\n@@ -9893,1 +9614,1 @@\n-    SKIP_BLANKS;\n+        SKIP_BLANKS;\n@@ -9895,3 +9616,3 @@\n-    CHECK_ERROR;\n-    PUSH_BINARY_EXPR(XPATH_OP_AND, op1, ctxt->comp->last, 0, 0);\n-    SKIP_BLANKS;\n+        CHECK_ERROR;\n+        PUSH_BINARY_EXPR(XPATH_OP_AND, op1, ctxt->comp->last, 0, 0);\n+        SKIP_BLANKS;\n@@ -9929,1 +9650,1 @@\n-    int op1 = ctxt->comp->last;\n+        int op1 = ctxt->comp->last;\n@@ -9931,1 +9652,1 @@\n-    SKIP_BLANKS;\n+        SKIP_BLANKS;\n@@ -9933,3 +9654,3 @@\n-    CHECK_ERROR;\n-    PUSH_BINARY_EXPR(XPATH_OP_OR, op1, ctxt->comp->last, 0, 0);\n-    SKIP_BLANKS;\n+        CHECK_ERROR;\n+        PUSH_BINARY_EXPR(XPATH_OP_OR, op1, ctxt->comp->last, 0, 0);\n+        SKIP_BLANKS;\n@@ -9938,7 +9659,7 @@\n-    \/* more ops could be optimized too *\/\n-    \/*\n-    * This is the main place to eliminate sorting for\n-    * operations which don't require a sorted node-set.\n-    * E.g. count().\n-    *\/\n-    PUSH_UNARY_EXPR(XPATH_OP_SORT, ctxt->comp->last , 0, 0);\n+        \/* more ops could be optimized too *\/\n+        \/*\n+        * This is the main place to eliminate sorting for\n+        * operations which don't require a sorted node-set.\n+        * E.g. count().\n+        *\/\n+        PUSH_UNARY_EXPR(XPATH_OP_SORT, ctxt->comp->last , 0, 0);\n@@ -9967,1 +9688,1 @@\n-    XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);\n+        XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);\n@@ -9983,1 +9704,1 @@\n-    xmlXPathCompileExpr(ctxt, 0);\n+        xmlXPathCompileExpr(ctxt, 0);\n@@ -9985,1 +9706,1 @@\n-    xmlXPathCompileExpr(ctxt, 1);\n+        xmlXPathCompileExpr(ctxt, 1);\n@@ -9989,1 +9710,1 @@\n-    XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);\n+        XP_ERROR(XPATH_INVALID_PREDICATE_ERROR);\n@@ -9993,1 +9714,1 @@\n-    PUSH_BINARY_EXPR(XPATH_OP_FILTER, op1, ctxt->comp->last, 0, 0);\n+        PUSH_BINARY_EXPR(XPATH_OP_FILTER, op1, ctxt->comp->last, 0, 0);\n@@ -9995,1 +9716,1 @@\n-    PUSH_BINARY_EXPR(XPATH_OP_PREDICATE, op1, ctxt->comp->last, 0, 0);\n+        PUSH_BINARY_EXPR(XPATH_OP_PREDICATE, op1, ctxt->comp->last, 0, 0);\n@@ -10009,2 +9730,2 @@\n- *            | NodeType '(' ')'\n- *            | 'processing-instruction' '(' Literal ')'\n+ *                  | NodeType '(' ')'\n+ *                  | 'processing-instruction' '(' Literal ')'\n@@ -10013,2 +9734,2 @@\n- *            | NCName ':' '*'\n- *            | QName\n+ *                  | NCName ':' '*'\n+ *                  | QName\n@@ -10016,3 +9737,3 @@\n- *           | 'text'\n- *           | 'processing-instruction'\n- *           | 'node'\n+ *                 | 'text'\n+ *                 | 'processing-instruction'\n+ *                 | 'node'\n@@ -10024,2 +9745,2 @@\n-                 xmlXPathTypeVal *type, xmlChar **prefix,\n-             xmlChar *name) {\n+                     xmlXPathTypeVal *type, xmlChar **prefix,\n+                     xmlChar *name) {\n@@ -10029,1 +9750,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -10037,6 +9758,6 @@\n-    \/*\n-     * All elements\n-     *\/\n-    NEXT;\n-    *test = NODE_TEST_ALL;\n-    return(NULL);\n+        \/*\n+         * All elements\n+         *\/\n+        NEXT;\n+        *test = NODE_TEST_ALL;\n+        return(NULL);\n@@ -10046,1 +9767,1 @@\n-    name = xmlXPathParseNCName(ctxt);\n+        name = xmlXPathParseNCName(ctxt);\n@@ -10048,1 +9769,1 @@\n-    XP_ERRORNULL(XPATH_EXPR_ERROR);\n+        XP_ERRORNULL(XPATH_EXPR_ERROR);\n@@ -10054,22 +9775,1 @@\n-    NEXT;\n-    \/*\n-     * NodeType or PI search\n-     *\/\n-    if (xmlStrEqual(name, BAD_CAST \"comment\"))\n-        *type = NODE_TYPE_COMMENT;\n-    else if (xmlStrEqual(name, BAD_CAST \"node\"))\n-        *type = NODE_TYPE_NODE;\n-    else if (xmlStrEqual(name, BAD_CAST \"processing-instruction\"))\n-        *type = NODE_TYPE_PI;\n-    else if (xmlStrEqual(name, BAD_CAST \"text\"))\n-        *type = NODE_TYPE_TEXT;\n-    else {\n-        if (name != NULL)\n-        xmlFree(name);\n-        XP_ERRORNULL(XPATH_EXPR_ERROR);\n-    }\n-\n-    *test = NODE_TEST_TYPE;\n-\n-    SKIP_BLANKS;\n-    if (*type == NODE_TYPE_PI) {\n+        NEXT;\n@@ -10077,1 +9777,1 @@\n-         * Specific case: search a PI by name.\n+         * NodeType or PI search\n@@ -10079,6 +9779,16 @@\n-        if (name != NULL)\n-        xmlFree(name);\n-        name = NULL;\n-        if (CUR != ')') {\n-        name = xmlXPathParseLiteral(ctxt);\n-        *test = NODE_TEST_PI;\n+        if (xmlStrEqual(name, BAD_CAST \"comment\"))\n+            *type = NODE_TYPE_COMMENT;\n+        else if (xmlStrEqual(name, BAD_CAST \"node\"))\n+            *type = NODE_TYPE_NODE;\n+        else if (xmlStrEqual(name, BAD_CAST \"processing-instruction\"))\n+            *type = NODE_TYPE_PI;\n+        else if (xmlStrEqual(name, BAD_CAST \"text\"))\n+            *type = NODE_TYPE_TEXT;\n+        else {\n+            if (name != NULL)\n+                xmlFree(name);\n+            XP_ERRORNULL(XPATH_EXPR_ERROR);\n+        }\n+\n+        *test = NODE_TEST_TYPE;\n+\n@@ -10086,0 +9796,12 @@\n+        if (*type == NODE_TYPE_PI) {\n+            \/*\n+             * Specific case: search a PI by name.\n+             *\/\n+            if (name != NULL)\n+                xmlFree(name);\n+            name = NULL;\n+            if (CUR != ')') {\n+                name = xmlXPathParseLiteral(ctxt);\n+                *test = NODE_TEST_PI;\n+                SKIP_BLANKS;\n+            }\n@@ -10087,8 +9809,7 @@\n-    }\n-    if (CUR != ')') {\n-        if (name != NULL)\n-        xmlFree(name);\n-        XP_ERRORNULL(XPATH_UNCLOSED_ERROR);\n-    }\n-    NEXT;\n-    return(name);\n+        if (CUR != ')') {\n+            if (name != NULL)\n+                xmlFree(name);\n+            XP_ERRORNULL(XPATH_UNCLOSED_ERROR);\n+        }\n+        NEXT;\n+        return(name);\n@@ -10098,19 +9819,1 @@\n-    NEXT;\n-\n-    \/*\n-     * Since currently the parser context don't have a\n-     * namespace list associated:\n-     * The namespace name for this prefix can be computed\n-     * only at evaluation time. The compilation is done\n-     * outside of any context.\n-     *\/\n-#if 0\n-    *prefix = xmlXPathNsLookup(ctxt->context, name);\n-    if (name != NULL)\n-        xmlFree(name);\n-    if (*prefix == NULL) {\n-        XP_ERROR0(XPATH_UNDEF_PREFIX_ERROR);\n-    }\n-#else\n-    *prefix = name;\n-#endif\n+        NEXT;\n@@ -10118,1 +9821,0 @@\n-    if (CUR == '*') {\n@@ -10120,1 +9822,5 @@\n-         * All elements\n+         * Since currently the parser context don't have a\n+         * namespace list associated:\n+         * The namespace name for this prefix can be computed\n+         * only at evaluation time. The compilation is done\n+         * outside of any context.\n@@ -10122,4 +9828,1 @@\n-        NEXT;\n-        *test = NODE_TEST_ALL;\n-        return(NULL);\n-    }\n+        *prefix = name;\n@@ -10127,4 +9830,13 @@\n-    name = xmlXPathParseNCName(ctxt);\n-    if (name == NULL) {\n-        XP_ERRORNULL(XPATH_EXPR_ERROR);\n-    }\n+        if (CUR == '*') {\n+            \/*\n+             * All elements\n+             *\/\n+            NEXT;\n+            *test = NODE_TEST_ALL;\n+            return(NULL);\n+        }\n+\n+        name = xmlXPathParseNCName(ctxt);\n+        if (name == NULL) {\n+            XP_ERRORNULL(XPATH_EXPR_ERROR);\n+        }\n@@ -10159,40 +9871,40 @@\n-    case 'a':\n-        if (xmlStrEqual(name, BAD_CAST \"ancestor\"))\n-        ret = AXIS_ANCESTOR;\n-        if (xmlStrEqual(name, BAD_CAST \"ancestor-or-self\"))\n-        ret = AXIS_ANCESTOR_OR_SELF;\n-        if (xmlStrEqual(name, BAD_CAST \"attribute\"))\n-        ret = AXIS_ATTRIBUTE;\n-        break;\n-    case 'c':\n-        if (xmlStrEqual(name, BAD_CAST \"child\"))\n-        ret = AXIS_CHILD;\n-        break;\n-    case 'd':\n-        if (xmlStrEqual(name, BAD_CAST \"descendant\"))\n-        ret = AXIS_DESCENDANT;\n-        if (xmlStrEqual(name, BAD_CAST \"descendant-or-self\"))\n-        ret = AXIS_DESCENDANT_OR_SELF;\n-        break;\n-    case 'f':\n-        if (xmlStrEqual(name, BAD_CAST \"following\"))\n-        ret = AXIS_FOLLOWING;\n-        if (xmlStrEqual(name, BAD_CAST \"following-sibling\"))\n-        ret = AXIS_FOLLOWING_SIBLING;\n-        break;\n-    case 'n':\n-        if (xmlStrEqual(name, BAD_CAST \"namespace\"))\n-        ret = AXIS_NAMESPACE;\n-        break;\n-    case 'p':\n-        if (xmlStrEqual(name, BAD_CAST \"parent\"))\n-        ret = AXIS_PARENT;\n-        if (xmlStrEqual(name, BAD_CAST \"preceding\"))\n-        ret = AXIS_PRECEDING;\n-        if (xmlStrEqual(name, BAD_CAST \"preceding-sibling\"))\n-        ret = AXIS_PRECEDING_SIBLING;\n-        break;\n-    case 's':\n-        if (xmlStrEqual(name, BAD_CAST \"self\"))\n-        ret = AXIS_SELF;\n-        break;\n+        case 'a':\n+            if (xmlStrEqual(name, BAD_CAST \"ancestor\"))\n+                ret = AXIS_ANCESTOR;\n+            if (xmlStrEqual(name, BAD_CAST \"ancestor-or-self\"))\n+                ret = AXIS_ANCESTOR_OR_SELF;\n+            if (xmlStrEqual(name, BAD_CAST \"attribute\"))\n+                ret = AXIS_ATTRIBUTE;\n+            break;\n+        case 'c':\n+            if (xmlStrEqual(name, BAD_CAST \"child\"))\n+                ret = AXIS_CHILD;\n+            break;\n+        case 'd':\n+            if (xmlStrEqual(name, BAD_CAST \"descendant\"))\n+                ret = AXIS_DESCENDANT;\n+            if (xmlStrEqual(name, BAD_CAST \"descendant-or-self\"))\n+                ret = AXIS_DESCENDANT_OR_SELF;\n+            break;\n+        case 'f':\n+            if (xmlStrEqual(name, BAD_CAST \"following\"))\n+                ret = AXIS_FOLLOWING;\n+            if (xmlStrEqual(name, BAD_CAST \"following-sibling\"))\n+                ret = AXIS_FOLLOWING_SIBLING;\n+            break;\n+        case 'n':\n+            if (xmlStrEqual(name, BAD_CAST \"namespace\"))\n+                ret = AXIS_NAMESPACE;\n+            break;\n+        case 'p':\n+            if (xmlStrEqual(name, BAD_CAST \"parent\"))\n+                ret = AXIS_PARENT;\n+            if (xmlStrEqual(name, BAD_CAST \"preceding\"))\n+                ret = AXIS_PRECEDING;\n+            if (xmlStrEqual(name, BAD_CAST \"preceding-sibling\"))\n+                ret = AXIS_PRECEDING_SIBLING;\n+            break;\n+        case 's':\n+            if (xmlStrEqual(name, BAD_CAST \"self\"))\n+                ret = AXIS_SELF;\n+            break;\n@@ -10237,5 +9949,0 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    int rangeto = 0;\n-    int op2 = -1;\n-#endif\n-\n@@ -10244,24 +9951,1 @@\n-    SKIP(2);\n-    SKIP_BLANKS;\n-    PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_PARENT,\n-            NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n-    } else if (CUR == '.') {\n-    NEXT;\n-    SKIP_BLANKS;\n-    } else {\n-    xmlChar *name = NULL;\n-    xmlChar *prefix = NULL;\n-    xmlXPathTestVal test = (xmlXPathTestVal) 0;\n-    xmlXPathAxisVal axis = (xmlXPathAxisVal) 0;\n-    xmlXPathTypeVal type = (xmlXPathTypeVal) 0;\n-    int op1;\n-\n-    \/*\n-     * The modification needed for XPointer change to the production\n-     *\/\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    if (ctxt->xptr) {\n-        name = xmlXPathParseNCName(ctxt);\n-        if ((name != NULL) && (xmlStrEqual(name, BAD_CAST \"range-to\"))) {\n-                op2 = ctxt->comp->last;\n-        xmlFree(name);\n+        SKIP(2);\n@@ -10269,3 +9953,3 @@\n-        if (CUR != '(') {\n-            XP_ERROR(XPATH_EXPR_ERROR);\n-        }\n+        PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_PARENT,\n+                    NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n+    } else if (CUR == '.') {\n@@ -10274,17 +9958,0 @@\n-\n-        xmlXPathCompileExpr(ctxt, 1);\n-        \/* PUSH_BINARY_EXPR(XPATH_OP_RANGETO, op2, ctxt->comp->last, 0, 0); *\/\n-        CHECK_ERROR;\n-\n-        SKIP_BLANKS;\n-        if (CUR != ')') {\n-            XP_ERROR(XPATH_EXPR_ERROR);\n-        }\n-        NEXT;\n-        rangeto = 1;\n-        goto eval_predicates;\n-        }\n-    }\n-#endif\n-    if (CUR == '*') {\n-        axis = AXIS_CHILD;\n@@ -10292,15 +9959,8 @@\n-        if (name == NULL)\n-        name = xmlXPathParseNCName(ctxt);\n-        if (name != NULL) {\n-        axis = xmlXPathIsAxisName(name);\n-        if (axis != 0) {\n-            SKIP_BLANKS;\n-            if ((CUR == ':') && (NXT(1) == ':')) {\n-            SKIP(2);\n-            xmlFree(name);\n-            name = NULL;\n-            } else {\n-            \/* an element name can conflict with an axis one :-\\ *\/\n-            axis = AXIS_CHILD;\n-            }\n-        } else {\n+        xmlChar *name = NULL;\n+        xmlChar *prefix = NULL;\n+        xmlXPathTestVal test = (xmlXPathTestVal) 0;\n+        xmlXPathAxisVal axis = (xmlXPathAxisVal) 0;\n+        xmlXPathTypeVal type = (xmlXPathTypeVal) 0;\n+        int op1;\n+\n+        if (CUR == '*') {\n@@ -10308,4 +9968,0 @@\n-        }\n-        } else if (CUR == '@') {\n-        NEXT;\n-        axis = AXIS_ATTRIBUTE;\n@@ -10313,1 +9969,23 @@\n-        axis = AXIS_CHILD;\n+            if (name == NULL)\n+                name = xmlXPathParseNCName(ctxt);\n+            if (name != NULL) {\n+                axis = xmlXPathIsAxisName(name);\n+                if (axis != 0) {\n+                    SKIP_BLANKS;\n+                    if ((CUR == ':') && (NXT(1) == ':')) {\n+                        SKIP(2);\n+                        xmlFree(name);\n+                        name = NULL;\n+                    } else {\n+                        \/* an element name can conflict with an axis one :-\\ *\/\n+                        axis = AXIS_CHILD;\n+                    }\n+                } else {\n+                    axis = AXIS_CHILD;\n+                }\n+            } else if (CUR == '@') {\n+                NEXT;\n+                axis = AXIS_ATTRIBUTE;\n+            } else {\n+                axis = AXIS_CHILD;\n+            }\n@@ -10315,1 +9993,0 @@\n-    }\n@@ -10322,3 +9999,3 @@\n-    name = xmlXPathCompNodeTest(ctxt, &test, &type, &prefix, name);\n-    if (test == 0)\n-        return;\n+        name = xmlXPathCompNodeTest(ctxt, &test, &type, &prefix, name);\n+        if (test == 0)\n+            return;\n@@ -10327,3 +10004,4 @@\n-        (ctxt->context->flags & XML_XPATH_CHECKNS)) {\n-        if (xmlXPathNsLookup(ctxt->context, prefix) == NULL) {\n-        xmlXPathErr(ctxt, XPATH_UNDEF_PREFIX_ERROR);\n+            (ctxt->context->flags & XML_XPATH_CHECKNS)) {\n+            if (xmlXPathNsLookup(ctxt->context, prefix) == NULL) {\n+                xmlXPathErr(ctxt, XPATH_UNDEF_PREFIX_ERROR);\n+            }\n@@ -10331,1 +10009,0 @@\n-    }\n@@ -10333,5 +10010,2 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-eval_predicates:\n-#endif\n-    op1 = ctxt->comp->last;\n-    ctxt->comp->last = -1;\n+        op1 = ctxt->comp->last;\n+        ctxt->comp->last = -1;\n@@ -10339,4 +10013,4 @@\n-    SKIP_BLANKS;\n-    while (CUR == '[') {\n-        xmlXPathCompPredicate(ctxt, 0);\n-    }\n+        SKIP_BLANKS;\n+        while (CUR == '[') {\n+            xmlXPathCompPredicate(ctxt, 0);\n+        }\n@@ -10344,5 +10018,0 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    if (rangeto) {\n-        PUSH_BINARY_EXPR(XPATH_OP_RANGETO, op2, op1, 0, 0);\n-    } else\n-#endif\n@@ -10372,13 +10041,0 @@\n-    if ((CUR == '\/') && (NXT(1) == '\/')) {\n-    SKIP(2);\n-    SKIP_BLANKS;\n-    PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,\n-                 NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n-    } else if (CUR == '\/') {\n-        NEXT;\n-    SKIP_BLANKS;\n-    }\n-    xmlXPathCompStep(ctxt);\n-    CHECK_ERROR;\n-    SKIP_BLANKS;\n-    while (CUR == '\/') {\n@@ -10389,2 +10045,1 @@\n-                 NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n-        xmlXPathCompStep(ctxt);\n+                         NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n@@ -10392,1 +10047,1 @@\n-        NEXT;\n+            NEXT;\n@@ -10394,1 +10049,0 @@\n-        xmlXPathCompStep(ctxt);\n@@ -10396,0 +10050,2 @@\n+    xmlXPathCompStep(ctxt);\n+    CHECK_ERROR;\n@@ -10397,0 +10053,13 @@\n+    while (CUR == '\/') {\n+        if ((CUR == '\/') && (NXT(1) == '\/')) {\n+            SKIP(2);\n+            SKIP_BLANKS;\n+            PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,\n+                             NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n+            xmlXPathCompStep(ctxt);\n+        } else if (CUR == '\/') {\n+            NEXT;\n+            SKIP_BLANKS;\n+            xmlXPathCompStep(ctxt);\n+        }\n+        SKIP_BLANKS;\n@@ -10427,12 +10096,12 @@\n-    while (CUR == '\/') {\n-        if ((CUR == '\/') && (NXT(1) == '\/')) {\n-        SKIP(2);\n-        SKIP_BLANKS;\n-        PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,\n-                 NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n-        xmlXPathCompRelativeLocationPath(ctxt);\n-        } else if (CUR == '\/') {\n-        NEXT;\n-        SKIP_BLANKS;\n-        if ((CUR != 0) &&\n-            ((IS_ASCII_LETTER(CUR)) || (CUR >= 0x80) ||\n+        while (CUR == '\/') {\n+            if ((CUR == '\/') && (NXT(1) == '\/')) {\n+                SKIP(2);\n+                SKIP_BLANKS;\n+                PUSH_LONG_EXPR(XPATH_OP_COLLECT, AXIS_DESCENDANT_OR_SELF,\n+                             NODE_TEST_TYPE, NODE_TYPE_NODE, NULL, NULL);\n+                xmlXPathCompRelativeLocationPath(ctxt);\n+            } else if (CUR == '\/') {\n+                NEXT;\n+                SKIP_BLANKS;\n+                if ((CUR != 0) &&\n+                    ((IS_ASCII_LETTER(CUR)) || (CUR >= 0x80) ||\n@@ -10440,2 +10109,4 @@\n-             (CUR == '@') || (CUR == '*')))\n-            xmlXPathCompRelativeLocationPath(ctxt);\n+                     (CUR == '@') || (CUR == '*')))\n+                    xmlXPathCompRelativeLocationPath(ctxt);\n+            }\n+            CHECK_ERROR;\n@@ -10443,2 +10114,0 @@\n-        CHECK_ERROR;\n-    }\n@@ -10449,3 +10118,3 @@\n- *                                    *\n- *        XPath precompiled expression evaluation            *\n- *                                    *\n+ *                                                                      *\n+ *              XPath precompiled expression evaluation                 *\n+ *                                                                      *\n@@ -10472,2 +10141,2 @@\n-              xmlNodeSetPtr set,\n-              int filterOpIndex,\n+                      xmlNodeSetPtr set,\n+                      int filterOpIndex,\n@@ -10475,1 +10144,1 @@\n-              int hasNsNodes)\n+                      int hasNsNodes)\n@@ -10591,119 +10260,0 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-\/**\n- * xmlXPathLocationSetFilter:\n- * @ctxt:  the XPath Parser context\n- * @locset: the location set to filter\n- * @filterOpIndex: the index of the predicate\/filter op\n- * @minPos: minimum position in the filtered set (1-based)\n- * @maxPos: maximum position in the filtered set (1-based)\n- *\n- * Filter a location set, keeping only nodes for which the predicate\n- * expression matches. Afterwards, keep only nodes between minPos and maxPos\n- * in the filtered result.\n- *\/\n-static void\n-xmlXPathLocationSetFilter(xmlXPathParserContextPtr ctxt,\n-                  xmlLocationSetPtr locset,\n-                  int filterOpIndex,\n-                          int minPos, int maxPos)\n-{\n-    xmlXPathContextPtr xpctxt;\n-    xmlNodePtr oldnode;\n-    xmlDocPtr olddoc;\n-    xmlXPathStepOpPtr filterOp;\n-    int oldcs, oldpp;\n-    int i, j, pos;\n-\n-    if ((locset == NULL) || (locset->locNr == 0) || (filterOpIndex == -1))\n-        return;\n-\n-    xpctxt = ctxt->context;\n-    oldnode = xpctxt->node;\n-    olddoc = xpctxt->doc;\n-    oldcs = xpctxt->contextSize;\n-    oldpp = xpctxt->proximityPosition;\n-    filterOp = &ctxt->comp->steps[filterOpIndex];\n-\n-    xpctxt->contextSize = locset->locNr;\n-\n-    for (i = 0, j = 0, pos = 1; i < locset->locNr; i++) {\n-        xmlNodePtr contextNode = locset->locTab[i]->user;\n-        int res;\n-\n-        xpctxt->node = contextNode;\n-        xpctxt->proximityPosition = i + 1;\n-\n-        \/*\n-        * Also set the xpath document in case things like\n-        * key() are evaluated in the predicate.\n-        *\n-        * TODO: Get real doc for namespace nodes.\n-        *\/\n-        if ((contextNode->type != XML_NAMESPACE_DECL) &&\n-            (contextNode->doc != NULL))\n-            xpctxt->doc = contextNode->doc;\n-\n-        res = xmlXPathCompOpEvalToBoolean(ctxt, filterOp, 1);\n-\n-        if (ctxt->error != XPATH_EXPRESSION_OK)\n-            break;\n-        if (res < 0) {\n-            \/* Shouldn't happen *\/\n-            xmlXPathErr(ctxt, XPATH_EXPR_ERROR);\n-            break;\n-        }\n-\n-        if ((res != 0) && ((pos >= minPos) && (pos <= maxPos))) {\n-            if (i != j) {\n-                locset->locTab[j] = locset->locTab[i];\n-                locset->locTab[i] = NULL;\n-            }\n-\n-            j += 1;\n-        } else {\n-            \/* Remove the entry from the initial location set. *\/\n-            xmlXPathFreeObject(locset->locTab[i]);\n-            locset->locTab[i] = NULL;\n-        }\n-\n-        if (res != 0) {\n-            if (pos == maxPos) {\n-                i += 1;\n-                break;\n-            }\n-\n-            pos += 1;\n-        }\n-    }\n-\n-    \/* Free remaining nodes. *\/\n-    for (; i < locset->locNr; i++)\n-        xmlXPathFreeObject(locset->locTab[i]);\n-\n-    locset->locNr = j;\n-\n-    \/* If too many elements were removed, shrink table to preserve memory. *\/\n-    if ((locset->locMax > XML_NODESET_DEFAULT) &&\n-        (locset->locNr < locset->locMax \/ 2)) {\n-        xmlXPathObjectPtr *tmp;\n-        int locMax = locset->locNr;\n-\n-        if (locMax < XML_NODESET_DEFAULT)\n-            locMax = XML_NODESET_DEFAULT;\n-        tmp = (xmlXPathObjectPtr *) xmlRealloc(locset->locTab,\n-                locMax * sizeof(xmlXPathObjectPtr));\n-        if (tmp == NULL) {\n-            xmlXPathPErrMemory(ctxt);\n-        } else {\n-            locset->locTab = tmp;\n-            locset->locMax = locMax;\n-        }\n-    }\n-\n-    xpctxt->node = oldnode;\n-    xpctxt->doc = olddoc;\n-    xpctxt->contextSize = oldcs;\n-    xpctxt->proximityPosition = oldpp;\n-}\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-\n@@ -10725,2 +10275,2 @@\n-                xmlXPathStepOpPtr op,\n-                xmlNodeSetPtr set,\n+                            xmlXPathStepOpPtr op,\n+                            xmlNodeSetPtr set,\n@@ -10728,1 +10278,1 @@\n-                int hasNsNodes)\n+                            int hasNsNodes)\n@@ -10731,5 +10281,5 @@\n-    xmlXPathCompExprPtr comp = ctxt->comp;\n-    \/*\n-    * Process inner predicates first.\n-    *\/\n-    if (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) {\n+        xmlXPathCompExprPtr comp = ctxt->comp;\n+        \/*\n+        * Process inner predicates first.\n+        *\/\n+        if (comp->steps[op->ch1].op != XPATH_OP_PREDICATE) {\n@@ -10737,1 +10287,1 @@\n-    }\n+        }\n@@ -10741,1 +10291,1 @@\n-    xmlXPathCompOpEvalPredicate(ctxt, &comp->steps[op->ch1], set,\n+        xmlXPathCompOpEvalPredicate(ctxt, &comp->steps[op->ch1], set,\n@@ -10744,1 +10294,1 @@\n-    CHECK_ERROR;\n+        CHECK_ERROR;\n@@ -10753,2 +10303,2 @@\n-                xmlXPathStepOpPtr op,\n-                int *maxPos)\n+                            xmlXPathStepOpPtr op,\n+                            int *maxPos)\n@@ -10773,1 +10323,1 @@\n-    return(0);\n+        return(0);\n@@ -10776,1 +10326,1 @@\n-    exprOp = &ctxt->comp->steps[op->ch2];\n+        exprOp = &ctxt->comp->steps[op->ch2];\n@@ -10778,1 +10328,1 @@\n-    return(0);\n+        return(0);\n@@ -10781,3 +10331,3 @@\n-    (exprOp->op == XPATH_OP_VALUE) &&\n-    (exprOp->value4 != NULL) &&\n-    (((xmlXPathObjectPtr) exprOp->value4)->type == XPATH_NUMBER))\n+        (exprOp->op == XPATH_OP_VALUE) &&\n+        (exprOp->value4 != NULL) &&\n+        (((xmlXPathObjectPtr) exprOp->value4)->type == XPATH_NUMBER))\n@@ -10787,10 +10337,10 @@\n-    \/*\n-    * We have a \"[n]\" predicate here.\n-    * TODO: Unfortunately this simplistic test here is not\n-    * able to detect a position() predicate in compound\n-    * expressions like \"[@attr = 'a\" and position() = 1],\n-    * and even not the usage of position() in\n-    * \"[position() = 1]\"; thus - obviously - a position-range,\n-    * like it \"[position() < 5]\", is also not detected.\n-    * Maybe we could rewrite the AST to ease the optimization.\n-    *\/\n+        \/*\n+        * We have a \"[n]\" predicate here.\n+        * TODO: Unfortunately this simplistic test here is not\n+        * able to detect a position() predicate in compound\n+        * expressions like \"[@attr = 'a\" and position() = 1],\n+        * and even not the usage of position() in\n+        * \"[position() = 1]\"; thus - obviously - a position-range,\n+        * like it \"[position() < 5]\", is also not detected.\n+        * Maybe we could rewrite the AST to ease the optimization.\n+        *\/\n@@ -10799,1 +10349,1 @@\n-        *maxPos = (int) floatval;\n+            *maxPos = (int) floatval;\n@@ -10810,2 +10360,2 @@\n-               xmlNodePtr * first, xmlNodePtr * last,\n-               int toBool)\n+                           xmlNodePtr * first, xmlNodePtr * last,\n+                           int toBool)\n@@ -10816,1 +10366,5 @@\n-    if (++pos == maxPos) { \\\n+        if (++pos == maxPos) { \\\n+            if (addNode(seq, cur) < 0) \\\n+                xmlXPathPErrMemory(ctxt); \\\n+            goto axis_range_end; } \\\n+    } else { \\\n@@ -10819,5 +10373,1 @@\n-        goto axis_range_end; } \\\n-    } else { \\\n-    if (addNode(seq, cur) < 0) \\\n-        xmlXPathPErrMemory(ctxt); \\\n-    if (breakOnFirstHit) goto first_hit; }\n+        if (breakOnFirstHit) goto first_hit; }\n@@ -10827,1 +10377,6 @@\n-    if (++pos == maxPos) { \\\n+        if (++pos == maxPos) { \\\n+            hasNsNodes = 1; \\\n+            if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \\\n+                xmlXPathPErrMemory(ctxt); \\\n+        goto axis_range_end; } \\\n+    } else { \\\n@@ -10831,6 +10386,1 @@\n-    goto axis_range_end; } \\\n-    } else { \\\n-    hasNsNodes = 1; \\\n-    if (xmlXPathNodeSetAddNs(seq, xpctxt->node, (xmlNsPtr) cur) < 0) \\\n-        xmlXPathPErrMemory(ctxt); \\\n-    if (breakOnFirstHit) goto first_hit; }\n+        if (breakOnFirstHit) goto first_hit; }\n@@ -10874,1 +10424,1 @@\n-    obj = valuePop(ctxt);\n+    obj = xmlXPathValuePop(ctxt);\n@@ -10881,1 +10431,1 @@\n-        xmlXPathReleaseObject(xpctxt, obj);\n+            xmlXPathReleaseObject(xpctxt, obj);\n@@ -10883,1 +10433,1 @@\n-    }\n+        }\n@@ -10910,1 +10460,1 @@\n-        last = NULL;\n+            last = NULL;\n@@ -10912,1 +10462,1 @@\n-        mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n+            mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n@@ -10915,11 +10465,11 @@\n-        last = NULL;\n-        if (((test == NODE_TEST_NAME) || (test == NODE_TEST_ALL)) &&\n-        (type == NODE_TYPE_NODE))\n-        {\n-        \/*\n-        * Optimization if an element node type is 'element'.\n-        *\/\n-        next = xmlXPathNextChildElement;\n-        } else\n-        next = xmlXPathNextChild;\n-        mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n+            last = NULL;\n+            if (((test == NODE_TEST_NAME) || (test == NODE_TEST_ALL)) &&\n+                (type == NODE_TYPE_NODE))\n+            {\n+                \/*\n+                * Optimization if an element node type is 'element'.\n+                *\/\n+                next = xmlXPathNextChildElement;\n+            } else\n+                next = xmlXPathNextChild;\n+            mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n@@ -10928,1 +10478,1 @@\n-        last = NULL;\n+            last = NULL;\n@@ -10932,1 +10482,1 @@\n-        last = NULL;\n+            last = NULL;\n@@ -10936,1 +10486,1 @@\n-        last = NULL;\n+            last = NULL;\n@@ -10940,1 +10490,1 @@\n-        last = NULL;\n+            last = NULL;\n@@ -10945,1 +10495,1 @@\n-        last = NULL;\n+            last = NULL;\n@@ -10947,1 +10497,1 @@\n-        mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n+            mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n@@ -10963,1 +10513,1 @@\n-        last = NULL;\n+            last = NULL;\n@@ -10965,1 +10515,1 @@\n-        mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n+            mergeAndClear = xmlXPathNodeSetMergeAndClearNoDupls;\n@@ -10970,1 +10520,1 @@\n-    xmlXPathReleaseObject(xpctxt, obj);\n+        xmlXPathReleaseObject(xpctxt, obj);\n@@ -10975,1 +10525,1 @@\n-        valuePush(ctxt, obj);\n+        xmlXPathValuePush(ctxt, obj);\n@@ -11001,12 +10551,0 @@\n-    \/*\n-    * There's at least one predicate. 16 == XPATH_OP_PREDICATE\n-    *\/\n-    predOp = &ctxt->comp->steps[op->ch2];\n-    if (xmlXPathIsPositionalPredicate(ctxt, predOp, &maxPos)) {\n-        if (predOp->ch1 != -1) {\n-        \/*\n-        * Use the next inner predicate operator.\n-        *\/\n-        predOp = &ctxt->comp->steps[predOp->ch1];\n-        hasPredicateRange = 1;\n-        } else {\n@@ -11014,1 +10552,1 @@\n-        * There's no other predicate than the [n] predicate.\n+        * There's at least one predicate. 16 == XPATH_OP_PREDICATE\n@@ -11016,2 +10554,15 @@\n-        predOp = NULL;\n-        hasAxisRange = 1;\n+        predOp = &ctxt->comp->steps[op->ch2];\n+        if (xmlXPathIsPositionalPredicate(ctxt, predOp, &maxPos)) {\n+            if (predOp->ch1 != -1) {\n+                \/*\n+                * Use the next inner predicate operator.\n+                *\/\n+                predOp = &ctxt->comp->steps[predOp->ch1];\n+                hasPredicateRange = 1;\n+            } else {\n+                \/*\n+                * There's no other predicate than the [n] predicate.\n+                *\/\n+                predOp = NULL;\n+                hasAxisRange = 1;\n+            }\n@@ -11020,1 +10571,0 @@\n-    }\n@@ -11045,1 +10595,1 @@\n-    xpctxt->node = contextSeq->nodeTab[contextIdx++];\n+        xpctxt->node = contextSeq->nodeTab[contextIdx++];\n@@ -11047,2 +10597,0 @@\n-    if (seq == NULL) {\n-        seq = xmlXPathNodeSetCreate(NULL);\n@@ -11050,0 +10598,2 @@\n+            seq = xmlXPathNodeSetCreate(NULL);\n+            if (seq == NULL) {\n@@ -11051,2 +10601,3 @@\n-        total = 0;\n-        goto error;\n+                total = 0;\n+                goto error;\n+            }\n@@ -11054,7 +10605,6 @@\n-    }\n-    \/*\n-    * Traverse the axis and test the nodes.\n-    *\/\n-    pos = 0;\n-    cur = NULL;\n-    hasNsNodes = 0;\n+        \/*\n+        * Traverse the axis and test the nodes.\n+        *\/\n+        pos = 0;\n+        cur = NULL;\n+        hasNsNodes = 0;\n@@ -11069,3 +10619,3 @@\n-        \/*\n-        * QUESTION TODO: What does the \"first\" and \"last\" stuff do?\n-        *\/\n+            \/*\n+            * QUESTION TODO: What does the \"first\" and \"last\" stuff do?\n+            *\/\n@@ -11073,3 +10623,3 @@\n-        if (*first == cur)\n-            break;\n-        if (((total % 256) == 0) &&\n+                if (*first == cur)\n+                    break;\n+                if (((total % 256) == 0) &&\n@@ -11077,1 +10627,1 @@\n-            (xmlXPathCmpNodesExt(*first, cur) >= 0))\n+                    (xmlXPathCmpNodesExt(*first, cur) >= 0))\n@@ -11079,1 +10629,1 @@\n-            (xmlXPathCmpNodes(*first, cur) >= 0))\n+                    (xmlXPathCmpNodes(*first, cur) >= 0))\n@@ -11081,8 +10631,8 @@\n-        {\n-            break;\n-        }\n-        }\n-        if ((last != NULL) && (*last != NULL)) {\n-        if (*last == cur)\n-            break;\n-        if (((total % 256) == 0) &&\n+                {\n+                    break;\n+                }\n+            }\n+            if ((last != NULL) && (*last != NULL)) {\n+                if (*last == cur)\n+                    break;\n+                if (((total % 256) == 0) &&\n@@ -11090,1 +10640,1 @@\n-            (xmlXPathCmpNodesExt(cur, *last) >= 0))\n+                    (xmlXPathCmpNodesExt(cur, *last) >= 0))\n@@ -11092,1 +10642,1 @@\n-            (xmlXPathCmpNodes(cur, *last) >= 0))\n+                    (xmlXPathCmpNodes(cur, *last) >= 0))\n@@ -11094,4 +10644,4 @@\n-        {\n-            break;\n-        }\n-        }\n+                {\n+                    break;\n+                }\n+            }\n@@ -11101,1 +10651,1 @@\n-        switch (test) {\n+            switch (test) {\n@@ -11103,2 +10653,2 @@\n-            total = 0;\n-            goto error;\n+                    total = 0;\n+                    goto error;\n@@ -11106,20 +10656,20 @@\n-            if (type == NODE_TYPE_NODE) {\n-            switch (cur->type) {\n-                case XML_DOCUMENT_NODE:\n-                case XML_HTML_DOCUMENT_NODE:\n-                case XML_ELEMENT_NODE:\n-                case XML_ATTRIBUTE_NODE:\n-                case XML_PI_NODE:\n-                case XML_COMMENT_NODE:\n-                case XML_CDATA_SECTION_NODE:\n-                case XML_TEXT_NODE:\n-                XP_TEST_HIT\n-                break;\n-                case XML_NAMESPACE_DECL: {\n-                if (axis == AXIS_NAMESPACE) {\n-                    XP_TEST_HIT_NS\n-                } else {\n-                                hasNsNodes = 1;\n-                    XP_TEST_HIT\n-                }\n-                break;\n+                    if (type == NODE_TYPE_NODE) {\n+                        switch (cur->type) {\n+                            case XML_DOCUMENT_NODE:\n+                            case XML_HTML_DOCUMENT_NODE:\n+                            case XML_ELEMENT_NODE:\n+                            case XML_ATTRIBUTE_NODE:\n+                            case XML_PI_NODE:\n+                            case XML_COMMENT_NODE:\n+                            case XML_CDATA_SECTION_NODE:\n+                            case XML_TEXT_NODE:\n+                                XP_TEST_HIT\n+                                break;\n+                            case XML_NAMESPACE_DECL: {\n+                                if (axis == AXIS_NAMESPACE) {\n+                                    XP_TEST_HIT_NS\n+                                } else {\n+                                    hasNsNodes = 1;\n+                                    XP_TEST_HIT\n+                                }\n+                                break;\n@@ -11127,14 +10677,14 @@\n-                default:\n-                break;\n-            }\n-            } else if (cur->type == (xmlElementType) type) {\n-            if (cur->type == XML_NAMESPACE_DECL)\n-                XP_TEST_HIT_NS\n-            else\n-                XP_TEST_HIT\n-            } else if ((type == NODE_TYPE_TEXT) &&\n-             (cur->type == XML_CDATA_SECTION_NODE))\n-            {\n-            XP_TEST_HIT\n-            }\n-            break;\n+                            default:\n+                                break;\n+                        }\n+                    } else if (cur->type == (xmlElementType) type) {\n+                        if (cur->type == XML_NAMESPACE_DECL)\n+                            XP_TEST_HIT_NS\n+                        else\n+                            XP_TEST_HIT\n+                    } else if ((type == NODE_TYPE_TEXT) &&\n+                         (cur->type == XML_CDATA_SECTION_NODE))\n+                    {\n+                        XP_TEST_HIT\n+                    }\n+                    break;\n@@ -11144,2 +10694,2 @@\n-            {\n-            XP_TEST_HIT\n+                    {\n+                        XP_TEST_HIT\n@@ -11151,1 +10701,1 @@\n-            {\n+                        {\n@@ -11153,2 +10703,2 @@\n-                {\n-                XP_TEST_HIT\n+                            {\n+                                XP_TEST_HIT\n@@ -11156,3 +10706,3 @@\n-                (xmlStrEqual(URI, cur->ns->href)))\n-                {\n-                XP_TEST_HIT\n+                                (xmlStrEqual(URI, cur->ns->href)))\n+                            {\n+                                XP_TEST_HIT\n@@ -11163,2 +10713,2 @@\n-            {\n-                XP_TEST_HIT_NS\n+                        {\n+                            XP_TEST_HIT_NS\n@@ -11169,2 +10719,2 @@\n-                {\n-                XP_TEST_HIT\n+                            {\n+                                XP_TEST_HIT\n@@ -11173,3 +10723,3 @@\n-                (xmlStrEqual(URI, cur->ns->href)))\n-                {\n-                XP_TEST_HIT\n+                                (xmlStrEqual(URI, cur->ns->href)))\n+                            {\n+                                XP_TEST_HIT\n@@ -11187,2 +10737,2 @@\n-                break;\n-            } else if (axis == AXIS_NAMESPACE) {\n+                            break;\n+                    } else if (axis == AXIS_NAMESPACE) {\n@@ -11190,5 +10740,5 @@\n-                break;\n-            } else {\n-                if (cur->type != XML_ELEMENT_NODE)\n-                break;\n-            }\n+                            break;\n+                    } else {\n+                        if (cur->type != XML_ELEMENT_NODE)\n+                            break;\n+                    }\n@@ -11200,2 +10750,2 @@\n-                    {\n-                    XP_TEST_HIT\n+                                    {\n+                                        XP_TEST_HIT\n@@ -11206,2 +10756,2 @@\n-                    {\n-                    XP_TEST_HIT\n+                                    {\n+                                        XP_TEST_HIT\n@@ -11219,2 +10769,2 @@\n-                    {\n-                        XP_TEST_HIT\n+                                        {\n+                                            XP_TEST_HIT\n@@ -11225,3 +10775,3 @@\n-                          attr->ns->href)))\n-                    {\n-                        XP_TEST_HIT\n+                                              attr->ns->href)))\n+                                        {\n+                                            XP_TEST_HIT\n@@ -11239,2 +10789,2 @@\n-                {\n-                    XP_TEST_HIT_NS\n+                                {\n+                                    XP_TEST_HIT_NS\n@@ -11248,1 +10798,1 @@\n-        } \/* switch(test) *\/\n+            } \/* switch(test) *\/\n@@ -11251,1 +10801,1 @@\n-    goto apply_predicates;\n+        goto apply_predicates;\n@@ -11254,11 +10804,11 @@\n-    \/*\n-    * We have a \"\/foo[n]\", and position() = n was reached.\n-    * Note that we can have as well \"\/foo\/::parent::foo[1]\", so\n-    * a duplicate-aware merge is still needed.\n-    * Merge with the result.\n-    *\/\n-    if (outSeq == NULL) {\n-        outSeq = seq;\n-        seq = NULL;\n-    } else {\n-        outSeq = mergeAndClear(outSeq, seq);\n+        \/*\n+        * We have a \"\/foo[n]\", and position() = n was reached.\n+        * Note that we can have as well \"\/foo\/::parent::foo[1]\", so\n+        * a duplicate-aware merge is still needed.\n+        * Merge with the result.\n+        *\/\n+        if (outSeq == NULL) {\n+            outSeq = seq;\n+            seq = NULL;\n+        } else {\n+            outSeq = mergeAndClear(outSeq, seq);\n@@ -11268,6 +10818,6 @@\n-    \/*\n-    * Break if only a true\/false result was requested.\n-    *\/\n-    if (toBool)\n-        break;\n-    continue;\n+        \/*\n+        * Break if only a true\/false result was requested.\n+        *\/\n+        if (toBool)\n+            break;\n+        continue;\n@@ -11276,9 +10826,9 @@\n-    \/*\n-    * Break if only a true\/false result was requested and\n-    * no predicates existed and a node test succeeded.\n-    *\/\n-    if (outSeq == NULL) {\n-        outSeq = seq;\n-        seq = NULL;\n-    } else {\n-        outSeq = mergeAndClear(outSeq, seq);\n+        \/*\n+        * Break if only a true\/false result was requested and\n+        * no predicates existed and a node test succeeded.\n+        *\/\n+        if (outSeq == NULL) {\n+            outSeq = seq;\n+            seq = NULL;\n+        } else {\n+            outSeq = mergeAndClear(outSeq, seq);\n@@ -11288,1 +10838,1 @@\n-    break;\n+        break;\n@@ -11292,1 +10842,1 @@\n-        goto error;\n+            goto error;\n@@ -11295,30 +10845,1 @@\n-    * Apply predicates.\n-    *\/\n-        if ((predOp != NULL) && (seq->nodeNr > 0)) {\n-        \/*\n-        * E.g. when we have a \"\/foo[some expression][n]\".\n-        *\/\n-        \/*\n-        * QUESTION TODO: The old predicate evaluation took into\n-        *  account location-sets.\n-        *  (E.g. ctxt->value->type == XPATH_LOCATIONSET)\n-        *  Do we expect such a set here?\n-        *  All what I learned now from the evaluation semantics\n-        *  does not indicate that a location-set will be processed\n-        *  here, so this looks OK.\n-        *\/\n-        \/*\n-        * Iterate over all predicates, starting with the outermost\n-        * predicate.\n-        * TODO: Problem: we cannot execute the inner predicates first\n-        *  since we cannot go back *up* the operator tree!\n-        *  Options we have:\n-        *  1) Use of recursive functions (like is it currently done\n-        *     via xmlXPathCompOpEval())\n-        *  2) Add a predicate evaluation information stack to the\n-        *     context struct\n-        *  3) Change the way the operators are linked; we need a\n-        *     \"parent\" field on xmlXPathStepOp\n-        *\n-        * For the moment, I'll try to solve this with a recursive\n-        * function: xmlXPathCompOpEvalPredicate().\n+        * Apply predicates.\n@@ -11326,6 +10847,35 @@\n-        if (hasPredicateRange != 0)\n-        xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, maxPos, maxPos,\n-                        hasNsNodes);\n-        else\n-        xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, 1, seq->nodeNr,\n-                        hasNsNodes);\n+        if ((predOp != NULL) && (seq->nodeNr > 0)) {\n+            \/*\n+            * E.g. when we have a \"\/foo[some expression][n]\".\n+            *\/\n+            \/*\n+            * QUESTION TODO: The old predicate evaluation took into\n+            *  account location-sets.\n+            *  (E.g. ctxt->value->type == XPATH_LOCATIONSET)\n+            *  Do we expect such a set here?\n+            *  All what I learned now from the evaluation semantics\n+            *  does not indicate that a location-set will be processed\n+            *  here, so this looks OK.\n+            *\/\n+            \/*\n+            * Iterate over all predicates, starting with the outermost\n+            * predicate.\n+            * TODO: Problem: we cannot execute the inner predicates first\n+            *  since we cannot go back *up* the operator tree!\n+            *  Options we have:\n+            *  1) Use of recursive functions (like is it currently done\n+            *     via xmlXPathCompOpEval())\n+            *  2) Add a predicate evaluation information stack to the\n+            *     context struct\n+            *  3) Change the way the operators are linked; we need a\n+            *     \"parent\" field on xmlXPathStepOp\n+            *\n+            * For the moment, I'll try to solve this with a recursive\n+            * function: xmlXPathCompOpEvalPredicate().\n+            *\/\n+            if (hasPredicateRange != 0)\n+                xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, maxPos, maxPos,\n+                                            hasNsNodes);\n+            else\n+                xmlXPathCompOpEvalPredicate(ctxt, predOp, seq, 1, seq->nodeNr,\n+                                            hasNsNodes);\n@@ -11333,4 +10883,4 @@\n-        if (ctxt->error != XPATH_EXPRESSION_OK) {\n-        total = 0;\n-        goto error;\n-        }\n+            if (ctxt->error != XPATH_EXPRESSION_OK) {\n+                total = 0;\n+                goto error;\n+            }\n@@ -11340,8 +10890,8 @@\n-        \/*\n-        * Add to result set.\n-        *\/\n-        if (outSeq == NULL) {\n-        outSeq = seq;\n-        seq = NULL;\n-        } else {\n-        outSeq = mergeAndClear(outSeq, seq);\n+            \/*\n+            * Add to result set.\n+            *\/\n+            if (outSeq == NULL) {\n+                outSeq = seq;\n+                seq = NULL;\n+            } else {\n+                outSeq = mergeAndClear(outSeq, seq);\n@@ -11350,1 +10900,1 @@\n-        }\n+            }\n@@ -11354,1 +10904,1 @@\n-    }\n+        }\n@@ -11359,9 +10909,9 @@\n-    \/*\n-    * QUESTION TODO: What does this do and why?\n-    * TODO: Do we have to do this also for the \"error\"\n-    * cleanup further down?\n-    *\/\n-    ctxt->value->boolval = 1;\n-    ctxt->value->user = obj->user;\n-    obj->user = NULL;\n-    obj->boolval = 0;\n+        \/*\n+        * QUESTION TODO: What does this do and why?\n+        * TODO: Do we have to do this also for the \"error\"\n+        * cleanup further down?\n+        *\/\n+        ctxt->value->boolval = 1;\n+        ctxt->value->user = obj->user;\n+        obj->user = NULL;\n+        obj->boolval = 0;\n@@ -11375,2 +10925,2 @@\n-    if ((seq != NULL) && (seq->nodeNr == 0)) {\n-        outSeq = seq;\n+        if ((seq != NULL) && (seq->nodeNr == 0)) {\n+            outSeq = seq;\n@@ -11378,1 +10928,1 @@\n-        outSeq = xmlXPathNodeSetCreate(NULL);\n+            outSeq = xmlXPathNodeSetCreate(NULL);\n@@ -11384,1 +10934,1 @@\n-     xmlXPathFreeNodeSet(seq);\n+         xmlXPathFreeNodeSet(seq);\n@@ -11390,1 +10940,1 @@\n-    valuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt, outSeq));\n+    xmlXPathValuePush(ctxt, xmlXPathCacheWrapNodeSet(ctxt, outSeq));\n@@ -11409,1 +10959,1 @@\n-                  xmlXPathStepOpPtr op, xmlNodePtr * first);\n+                              xmlXPathStepOpPtr op, xmlNodePtr * first);\n@@ -11444,1 +10994,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11452,9 +11002,9 @@\n-        \/*\n-        * OPTIMIZE TODO: This implicitly sorts\n-        *  the result, even if not needed. E.g. if the argument\n-        *  of the count() function, no sorting is needed.\n-        * OPTIMIZE TODO: How do we know if the node-list wasn't\n-        *  already sorted?\n-        *\/\n-        if (ctxt->value->nodesetval->nodeNr > 1)\n-            xmlXPathNodeSetSort(ctxt->value->nodesetval);\n+                \/*\n+                * OPTIMIZE TODO: This implicitly sorts\n+                *  the result, even if not needed. E.g. if the argument\n+                *  of the count() function, no sorting is needed.\n+                * OPTIMIZE TODO: How do we know if the node-list wasn't\n+                *  already sorted?\n+                *\/\n+                if (ctxt->value->nodesetval->nodeNr > 1)\n+                    xmlXPathNodeSetSort(ctxt->value->nodesetval);\n@@ -11466,1 +11016,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11468,2 +11018,2 @@\n-            arg2 = valuePop(ctxt);\n-            arg1 = valuePop(ctxt);\n+            arg2 = xmlXPathValuePop(ctxt);\n+            arg1 = xmlXPathValuePop(ctxt);\n@@ -11472,2 +11022,2 @@\n-            xmlXPathReleaseObject(ctxt->context, arg1);\n-            xmlXPathReleaseObject(ctxt->context, arg2);\n+                xmlXPathReleaseObject(ctxt->context, arg1);\n+                xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -11483,2 +11033,2 @@\n-            xmlXPathReleaseObject(ctxt->context, arg1);\n-            xmlXPathReleaseObject(ctxt->context, arg2);\n+                xmlXPathReleaseObject(ctxt->context, arg1);\n+                xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -11495,5 +11045,2 @@\n-            valuePush(ctxt, arg1);\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n-            \/* optimizer *\/\n-        if (total > cur)\n-        xmlXPathCompSwap(op);\n+            xmlXPathValuePush(ctxt, arg1);\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -11508,1 +11055,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11511,3 +11058,3 @@\n-        CHECK_ERROR0;\n-        valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt,\n-        ctxt->context->node));\n+            CHECK_ERROR0;\n+            xmlXPathValuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt,\n+                ctxt->context->node));\n@@ -11520,1 +11067,1 @@\n-        CHECK_ERROR0;\n+                CHECK_ERROR0;\n@@ -11526,1 +11073,1 @@\n-            valuePush(ctxt, xmlXPathCacheObjectCopy(ctxt, op->value4));\n+            xmlXPathValuePush(ctxt, xmlXPathCacheObjectCopy(ctxt, op->value4));\n@@ -11533,1 +11080,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11537,1 +11084,1 @@\n-        && (ctxt->value->nodesetval->nodeNr > 1))\n+                && (ctxt->value->nodesetval->nodeNr > 1))\n@@ -11541,1 +11088,1 @@\n-    case XPATH_OP_FILTER:\n+        case XPATH_OP_FILTER:\n@@ -11586,1 +11133,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11594,2 +11141,2 @@\n-        if (ctxt->value->nodesetval->nodeNr > 1)\n-            xmlXPathNodeSetSort(ctxt->value->nodesetval);\n+                if (ctxt->value->nodesetval->nodeNr > 1)\n+                    xmlXPathNodeSetSort(ctxt->value->nodesetval);\n@@ -11603,1 +11150,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11610,2 +11157,2 @@\n-            arg2 = valuePop(ctxt);\n-            arg1 = valuePop(ctxt);\n+            arg2 = xmlXPathValuePop(ctxt);\n+            arg1 = xmlXPathValuePop(ctxt);\n@@ -11614,2 +11161,2 @@\n-            xmlXPathReleaseObject(ctxt->context, arg1);\n-            xmlXPathReleaseObject(ctxt->context, arg2);\n+                xmlXPathReleaseObject(ctxt->context, arg1);\n+                xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -11625,2 +11172,2 @@\n-            xmlXPathReleaseObject(ctxt->context, arg1);\n-            xmlXPathReleaseObject(ctxt->context, arg2);\n+                xmlXPathReleaseObject(ctxt->context, arg1);\n+                xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -11637,5 +11184,2 @@\n-            valuePush(ctxt, arg1);\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n-            \/* optimizer *\/\n-        if (total > cur)\n-        xmlXPathCompSwap(op);\n+            xmlXPathValuePush(ctxt, arg1);\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -11650,1 +11194,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11653,3 +11197,3 @@\n-        CHECK_ERROR0;\n-        valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt,\n-        ctxt->context->node));\n+            CHECK_ERROR0;\n+            xmlXPathValuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt,\n+                ctxt->context->node));\n@@ -11662,1 +11206,1 @@\n-        CHECK_ERROR0;\n+                CHECK_ERROR0;\n@@ -11668,1 +11212,1 @@\n-            valuePush(ctxt, xmlXPathCacheObjectCopy(ctxt, op->value4));\n+            xmlXPathValuePush(ctxt, xmlXPathCacheObjectCopy(ctxt, op->value4));\n@@ -11675,1 +11219,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11679,1 +11223,1 @@\n-        && (ctxt->value->nodesetval->nodeNr > 1))\n+                && (ctxt->value->nodesetval->nodeNr > 1))\n@@ -11694,1 +11238,1 @@\n-                  xmlXPathStepOpPtr op, xmlNodePtr * first)\n+                              xmlXPathStepOpPtr op, xmlNodePtr * first)\n@@ -11707,27 +11251,27 @@\n-    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n-    (comp->steps[op->ch2].op == XPATH_OP_SORT)) {\n-    int f = comp->steps[op->ch2].ch1;\n-\n-    if ((f != -1) &&\n-        (comp->steps[f].op == XPATH_OP_FUNCTION) &&\n-        (comp->steps[f].value5 == NULL) &&\n-        (comp->steps[f].value == 0) &&\n-        (comp->steps[f].value4 != NULL) &&\n-        (xmlStrEqual\n-        (comp->steps[f].value4, BAD_CAST \"last\"))) {\n-        xmlNodePtr last = NULL;\n-\n-        total +=\n-        xmlXPathCompOpEvalLast(ctxt,\n-            &comp->steps[op->ch1],\n-            &last);\n-        CHECK_ERROR0;\n-        \/*\n-        * The nodeset should be in document order,\n-        * Keep only the last value\n-        *\/\n-        if ((ctxt->value != NULL) &&\n-        (ctxt->value->type == XPATH_NODESET) &&\n-        (ctxt->value->nodesetval != NULL) &&\n-        (ctxt->value->nodesetval->nodeTab != NULL) &&\n-        (ctxt->value->nodesetval->nodeNr > 1)) {\n+        (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n+        (comp->steps[op->ch2].op == XPATH_OP_SORT)) {\n+        int f = comp->steps[op->ch2].ch1;\n+\n+        if ((f != -1) &&\n+            (comp->steps[f].op == XPATH_OP_FUNCTION) &&\n+            (comp->steps[f].value5 == NULL) &&\n+            (comp->steps[f].value == 0) &&\n+            (comp->steps[f].value4 != NULL) &&\n+            (xmlStrEqual\n+            (comp->steps[f].value4, BAD_CAST \"last\"))) {\n+            xmlNodePtr last = NULL;\n+\n+            total +=\n+                xmlXPathCompOpEvalLast(ctxt,\n+                    &comp->steps[op->ch1],\n+                    &last);\n+            CHECK_ERROR0;\n+            \/*\n+            * The nodeset should be in document order,\n+            * Keep only the last value\n+            *\/\n+            if ((ctxt->value != NULL) &&\n+                (ctxt->value->type == XPATH_NODESET) &&\n+                (ctxt->value->nodesetval != NULL) &&\n+                (ctxt->value->nodesetval->nodeTab != NULL) &&\n+                (ctxt->value->nodesetval->nodeNr > 1)) {\n@@ -11735,1 +11279,3 @@\n-        *first = *(ctxt->value->nodesetval->nodeTab);\n+                *first = *(ctxt->value->nodesetval->nodeTab);\n+            }\n+            return (total);\n@@ -11737,2 +11283,0 @@\n-        return (total);\n-    }\n@@ -11742,1 +11286,1 @@\n-    total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n+        total += xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n@@ -11745,1 +11289,1 @@\n-    return (total);\n+        return (total);\n@@ -11747,18 +11291,1 @@\n-    return (total);\n-\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    \/*\n-    * Hum are we filtering the result of an XPointer expression\n-    *\/\n-    if (ctxt->value->type == XPATH_LOCATIONSET) {\n-        xmlLocationSetPtr locset = ctxt->value->user;\n-\n-        if (locset != NULL) {\n-            xmlXPathLocationSetFilter(ctxt, locset, op->ch2, 1, 1);\n-            if (locset->locNr > 0)\n-                *first = (xmlNodePtr) locset->locTab[0]->user;\n-        }\n-\n-    return (total);\n-    }\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n+        return (total);\n@@ -11772,1 +11299,1 @@\n-    obj = valuePop(ctxt);\n+    obj = xmlXPathValuePop(ctxt);\n@@ -11779,1 +11306,1 @@\n-    valuePush(ctxt, obj);\n+    xmlXPathValuePush(ctxt, obj);\n@@ -11813,1 +11340,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11817,1 +11344,1 @@\n-            arg2 = valuePop(ctxt);\n+            arg2 = xmlXPathValuePop(ctxt);\n@@ -11819,4 +11346,4 @@\n-        if (ctxt->error) {\n-        xmlXPathFreeObject(arg2);\n-        break;\n-        }\n+            if (ctxt->error) {\n+                xmlXPathFreeObject(arg2);\n+                break;\n+            }\n@@ -11826,1 +11353,1 @@\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -11830,1 +11357,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11834,1 +11361,1 @@\n-            arg2 = valuePop(ctxt);\n+            arg2 = xmlXPathValuePop(ctxt);\n@@ -11836,4 +11363,4 @@\n-        if (ctxt->error) {\n-        xmlXPathFreeObject(arg2);\n-        break;\n-        }\n+            if (ctxt->error) {\n+                xmlXPathFreeObject(arg2);\n+                break;\n+            }\n@@ -11843,1 +11370,1 @@\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -11847,1 +11374,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11849,6 +11376,6 @@\n-        CHECK_ERROR0;\n-        if (op->value)\n-        equal = xmlXPathEqualValues(ctxt);\n-        else\n-        equal = xmlXPathNotEqualValues(ctxt);\n-        valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, equal));\n+            CHECK_ERROR0;\n+            if (op->value)\n+                equal = xmlXPathEqualValues(ctxt);\n+            else\n+                equal = xmlXPathNotEqualValues(ctxt);\n+            xmlXPathValuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, equal));\n@@ -11858,1 +11385,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11860,1 +11387,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11862,1 +11389,1 @@\n-        valuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, ret));\n+            xmlXPathValuePush(ctxt, xmlXPathCacheNewBoolean(ctxt, ret));\n@@ -11866,1 +11393,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11869,2 +11396,2 @@\n-        }\n-        CHECK_ERROR0;\n+            }\n+            CHECK_ERROR0;\n@@ -11884,1 +11411,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11886,1 +11413,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11896,1 +11423,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11898,1 +11425,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11900,2 +11427,2 @@\n-            arg2 = valuePop(ctxt);\n-            arg1 = valuePop(ctxt);\n+            arg2 = xmlXPathValuePop(ctxt);\n+            arg1 = xmlXPathValuePop(ctxt);\n@@ -11904,2 +11431,2 @@\n-            xmlXPathReleaseObject(ctxt->context, arg1);\n-            xmlXPathReleaseObject(ctxt->context, arg2);\n+                xmlXPathReleaseObject(ctxt->context, arg1);\n+                xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -11915,2 +11442,2 @@\n-            xmlXPathReleaseObject(ctxt->context, arg1);\n-            xmlXPathReleaseObject(ctxt->context, arg2);\n+                xmlXPathReleaseObject(ctxt->context, arg1);\n+                xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -11920,5 +11447,5 @@\n-        if (((arg2->nodesetval != NULL) &&\n-         (arg2->nodesetval->nodeNr != 0)))\n-        {\n-        arg1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,\n-                            arg2->nodesetval);\n+            if (((arg2->nodesetval != NULL) &&\n+                 (arg2->nodesetval->nodeNr != 0)))\n+            {\n+                arg1->nodesetval = xmlXPathNodeSetMerge(arg1->nodesetval,\n+                                                        arg2->nodesetval);\n@@ -11927,1 +11454,1 @@\n-        }\n+            }\n@@ -11929,2 +11456,2 @@\n-            valuePush(ctxt, arg1);\n-        xmlXPathReleaseObject(ctxt->context, arg2);\n+            xmlXPathValuePush(ctxt, arg1);\n+            xmlXPathReleaseObject(ctxt->context, arg2);\n@@ -11938,1 +11465,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -11941,2 +11468,2 @@\n-        CHECK_ERROR0;\n-        valuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt,\n+            CHECK_ERROR0;\n+            xmlXPathValuePush(ctxt, xmlXPathCacheNewNodeSet(ctxt,\n@@ -11950,1 +11477,1 @@\n-        CHECK_ERROR0;\n+                CHECK_ERROR0;\n@@ -11956,1 +11483,1 @@\n-            valuePush(ctxt, xmlXPathCacheObjectCopy(ctxt, op->value4));\n+            xmlXPathValuePush(ctxt, xmlXPathCacheObjectCopy(ctxt, op->value4));\n@@ -11959,1 +11486,1 @@\n-        xmlXPathObjectPtr val;\n+                xmlXPathObjectPtr val;\n@@ -11965,5 +11492,5 @@\n-            val = xmlXPathVariableLookup(ctxt->context, op->value4);\n-            if (val == NULL)\n-            XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);\n-                    valuePush(ctxt, val);\n-        } else {\n+                    val = xmlXPathVariableLookup(ctxt->context, op->value4);\n+                    if (val == NULL)\n+                        XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);\n+                    xmlXPathValuePush(ctxt, val);\n+                } else {\n@@ -11977,1 +11504,1 @@\n-            val = xmlXPathVariableLookupNS(ctxt->context,\n+                    val = xmlXPathVariableLookupNS(ctxt->context,\n@@ -11979,3 +11506,3 @@\n-            if (val == NULL)\n-            XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);\n-                    valuePush(ctxt, val);\n+                    if (val == NULL)\n+                        XP_ERROR0(XPATH_UNDEF_VARIABLE_ERROR);\n+                    xmlXPathValuePush(ctxt, val);\n@@ -11988,1 +11515,1 @@\n-        int i;\n+                int i;\n@@ -11998,5 +11525,5 @@\n-        if (ctxt->valueNr < frame + op->value)\n-            XP_ERROR0(XPATH_INVALID_OPERAND);\n-        for (i = 0; i < op->value; i++) {\n-            if (ctxt->valueTab[(ctxt->valueNr - 1) - i] == NULL)\n-            XP_ERROR0(XPATH_INVALID_OPERAND);\n+                if (ctxt->valueNr < frame + op->value)\n+                    XP_ERROR0(XPATH_INVALID_OPERAND);\n+                for (i = 0; i < op->value; i++) {\n+                    if (ctxt->valueTab[(ctxt->valueNr - 1) - i] == NULL)\n+                        XP_ERROR0(XPATH_INVALID_OPERAND);\n@@ -12040,1 +11567,1 @@\n-            CHECK_ERROR0;\n+                CHECK_ERROR0;\n@@ -12044,2 +11571,2 @@\n-            CHECK_ERROR0;\n-        }\n+                CHECK_ERROR0;\n+            }\n@@ -12057,9 +11584,9 @@\n-            \/*\n-            * FILTER TODO: Can we assume that the inner processing\n-            *  will result in an ordered list if we have an\n-            *  XPATH_OP_FILTER?\n-            *  What about an additional field or flag on\n-            *  xmlXPathObject like @sorted ? This way we wouldn't need\n-            *  to assume anything, so it would be more robust and\n-            *  easier to optimize.\n-            *\/\n+                    \/*\n+                    * FILTER TODO: Can we assume that the inner processing\n+                    *  will result in an ordered list if we have an\n+                    *  XPATH_OP_FILTER?\n+                    *  What about an additional field or flag on\n+                    *  xmlXPathObject like @sorted ? This way we wouldn't need\n+                    *  to assume anything, so it would be more robust and\n+                    *  easier to optimize.\n+                    *\/\n@@ -12067,1 +11594,1 @@\n-             (comp->steps[op->ch1].op == XPATH_OP_FILTER)) && \/* 17 *\/\n+                     (comp->steps[op->ch1].op == XPATH_OP_FILTER)) && \/* 17 *\/\n@@ -12069,1 +11596,1 @@\n-            (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n+                    (comp->steps[op->ch1].op == XPATH_OP_SORT) &&\n@@ -12083,1 +11610,1 @@\n-            CHECK_ERROR0;\n+                        CHECK_ERROR0;\n@@ -12118,1 +11645,1 @@\n-            CHECK_ERROR0;\n+                        CHECK_ERROR0;\n@@ -12132,11 +11659,11 @@\n-        \/*\n-        * Process inner predicates first.\n-        * Example \"index[parent::book][1]\":\n-        * ...\n-        *   PREDICATE   <-- we are here \"[1]\"\n-        *     PREDICATE <-- process \"[parent::book]\" first\n-        *       SORT\n-        *         COLLECT  'parent' 'name' 'node' book\n-        *           NODE\n-        *     ELEM Object is a number : 1\n-        *\/\n+                \/*\n+                * Process inner predicates first.\n+                * Example \"index[parent::book][1]\":\n+                * ...\n+                *   PREDICATE   <-- we are here \"[1]\"\n+                *     PREDICATE <-- process \"[parent::book]\" first\n+                *       SORT\n+                *         COLLECT  'parent' 'name' 'node' book\n+                *           NODE\n+                *     ELEM Object is a number : 1\n+                *\/\n@@ -12146,1 +11673,1 @@\n-        CHECK_ERROR0;\n+                CHECK_ERROR0;\n@@ -12152,12 +11679,0 @@\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-                \/*\n-                 * Hum are we filtering the result of an XPointer expression\n-                 *\/\n-                if (ctxt->value->type == XPATH_LOCATIONSET) {\n-                    xmlLocationSetPtr locset = ctxt->value->user;\n-                    xmlXPathLocationSetFilter(ctxt, locset, op->ch2,\n-                                              1, locset->locNr);\n-                    break;\n-                }\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n-\n@@ -12171,1 +11686,1 @@\n-                obj = valuePop(ctxt);\n+                obj = xmlXPathValuePop(ctxt);\n@@ -12176,1 +11691,1 @@\n-                valuePush(ctxt, obj);\n+                xmlXPathValuePush(ctxt, obj);\n@@ -12182,1 +11697,1 @@\n-        CHECK_ERROR0;\n+            CHECK_ERROR0;\n@@ -12186,2 +11701,2 @@\n-        (ctxt->value->nodesetval->nodeNr > 1))\n-        {\n+                (ctxt->value->nodesetval->nodeNr > 1))\n+            {\n@@ -12189,62 +11704,0 @@\n-        }\n-            break;\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-        case XPATH_OP_RANGETO:{\n-                xmlXPathObjectPtr range;\n-                xmlXPathObjectPtr res, obj;\n-                xmlXPathObjectPtr tmp;\n-                xmlLocationSetPtr newlocset = NULL;\n-            xmlLocationSetPtr oldlocset;\n-                xmlNodeSetPtr oldset;\n-                xmlNodePtr oldnode = ctxt->context->node;\n-                int oldcs = ctxt->context->contextSize;\n-                int oldpp = ctxt->context->proximityPosition;\n-                int i, j;\n-\n-                if (op->ch1 != -1) {\n-                    total +=\n-                        xmlXPathCompOpEval(ctxt, &comp->steps[op->ch1]);\n-                    CHECK_ERROR0;\n-                }\n-                if (ctxt->value == NULL) {\n-                    XP_ERROR0(XPATH_INVALID_OPERAND);\n-                }\n-                if (op->ch2 == -1)\n-                    break;\n-\n-                if (ctxt->value->type == XPATH_LOCATIONSET) {\n-                    \/*\n-                     * Extract the old locset, and then evaluate the result of the\n-                     * expression for all the element in the locset. use it to grow\n-                     * up a new locset.\n-                     *\/\n-                    CHECK_TYPE0(XPATH_LOCATIONSET);\n-\n-                    if ((ctxt->value->user == NULL) ||\n-                        (((xmlLocationSetPtr) ctxt->value->user)->locNr == 0))\n-                        break;\n-\n-                    obj = valuePop(ctxt);\n-                    oldlocset = obj->user;\n-\n-                    newlocset = xmlXPtrLocationSetCreate(NULL);\n-\n-                    for (i = 0; i < oldlocset->locNr; i++) {\n-                        \/*\n-                         * Run the evaluation with a node list made of a\n-                         * single item in the nodelocset.\n-                         *\/\n-                        ctxt->context->node = oldlocset->locTab[i]->user;\n-                        ctxt->context->contextSize = oldlocset->locNr;\n-                        ctxt->context->proximityPosition = i + 1;\n-                        tmp = xmlXPathCacheNewNodeSet(ctxt,\n-                                                      ctxt->context->node);\n-                        valuePush(ctxt, tmp);\n-\n-                        if (op->ch2 != -1)\n-                            total +=\n-                                xmlXPathCompOpEval(ctxt,\n-                                                   &comp->steps[op->ch2]);\n-            if (ctxt->error != XPATH_EXPRESSION_OK) {\n-                            xmlXPtrFreeLocationSet(newlocset);\n-                            goto rangeto_error;\n@@ -12252,98 +11705,1 @@\n-\n-                        res = valuePop(ctxt);\n-            if (res->type == XPATH_LOCATIONSET) {\n-                xmlLocationSetPtr rloc =\n-                    (xmlLocationSetPtr)res->user;\n-                for (j=0; j<rloc->locNr; j++) {\n-                    range = xmlXPtrNewRange(\n-                  oldlocset->locTab[i]->user,\n-                  oldlocset->locTab[i]->index,\n-                  rloc->locTab[j]->user2,\n-                  rloc->locTab[j]->index2);\n-                if (range != NULL) {\n-                    xmlXPtrLocationSetAdd(newlocset, range);\n-                }\n-                }\n-            } else {\n-                range = xmlXPtrNewRangeNodeObject(\n-                (xmlNodePtr)oldlocset->locTab[i]->user, res);\n-                            if (range != NULL) {\n-                                xmlXPtrLocationSetAdd(newlocset,range);\n-                }\n-                        }\n-\n-                        \/*\n-                         * Cleanup\n-                         *\/\n-                        if (res != NULL) {\n-                xmlXPathReleaseObject(ctxt->context, res);\n-            }\n-                        if (ctxt->value == tmp) {\n-                            res = valuePop(ctxt);\n-                xmlXPathReleaseObject(ctxt->context, res);\n-                        }\n-                    }\n-        } else {    \/* Not a location set *\/\n-                    CHECK_TYPE0(XPATH_NODESET);\n-                    obj = valuePop(ctxt);\n-                    oldset = obj->nodesetval;\n-\n-                    newlocset = xmlXPtrLocationSetCreate(NULL);\n-\n-                    if (oldset != NULL) {\n-                        for (i = 0; i < oldset->nodeNr; i++) {\n-                            \/*\n-                             * Run the evaluation with a node list made of a single item\n-                             * in the nodeset.\n-                             *\/\n-                            ctxt->context->node = oldset->nodeTab[i];\n-                \/*\n-                * OPTIMIZE TODO: Avoid recreation for every iteration.\n-                *\/\n-                            tmp = xmlXPathCacheNewNodeSet(ctxt,\n-                                                          ctxt->context->node);\n-                            valuePush(ctxt, tmp);\n-\n-                            if (op->ch2 != -1)\n-                                total +=\n-                                    xmlXPathCompOpEval(ctxt,\n-                                                   &comp->steps[op->ch2]);\n-                if (ctxt->error != XPATH_EXPRESSION_OK) {\n-                                xmlXPtrFreeLocationSet(newlocset);\n-                                goto rangeto_error;\n-                }\n-\n-                            res = valuePop(ctxt);\n-                            range =\n-                                xmlXPtrNewRangeNodeObject(oldset->nodeTab[i],\n-                                                      res);\n-                            if (range != NULL) {\n-                                xmlXPtrLocationSetAdd(newlocset, range);\n-                            }\n-\n-                            \/*\n-                             * Cleanup\n-                             *\/\n-                            if (res != NULL) {\n-                xmlXPathReleaseObject(ctxt->context, res);\n-                }\n-                            if (ctxt->value == tmp) {\n-                                res = valuePop(ctxt);\n-                xmlXPathReleaseObject(ctxt->context, res);\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                \/*\n-                 * The result is used as the new evaluation set.\n-                 *\/\n-                valuePush(ctxt, xmlXPtrWrapLocationSet(newlocset));\n-rangeto_error:\n-        xmlXPathReleaseObject(ctxt->context, obj);\n-                ctxt->context->node = oldnode;\n-                ctxt->context->contextSize = oldcs;\n-                ctxt->context->proximityPosition = oldpp;\n-                break;\n-            }\n-#endif \/* LIBXML_XPTR_LOCS_ENABLED *\/\n+            break;\n@@ -12369,2 +11725,2 @@\n-                xmlXPathStepOpPtr op,\n-                int isPredicate)\n+                            xmlXPathStepOpPtr op,\n+                            int isPredicate)\n@@ -12381,9 +11737,9 @@\n-    case XPATH_OP_VALUE:\n-        resObj = (xmlXPathObjectPtr) op->value4;\n-        if (isPredicate)\n-        return(xmlXPathEvaluatePredicateResult(ctxt, resObj));\n-        return(xmlXPathCastToBoolean(resObj));\n-    case XPATH_OP_SORT:\n-        \/*\n-        * We don't need sorting for boolean results. Skip this one.\n-        *\/\n+        case XPATH_OP_VALUE:\n+            resObj = (xmlXPathObjectPtr) op->value4;\n+            if (isPredicate)\n+                return(xmlXPathEvaluatePredicateResult(ctxt, resObj));\n+            return(xmlXPathCastToBoolean(resObj));\n+        case XPATH_OP_SORT:\n+            \/*\n+            * We don't need sorting for boolean results. Skip this one.\n+            *\/\n@@ -12391,7 +11747,7 @@\n-        op = &ctxt->comp->steps[op->ch1];\n-        goto start;\n-        }\n-        return(0);\n-    case XPATH_OP_COLLECT:\n-        if (op->ch1 == -1)\n-        return(0);\n+                op = &ctxt->comp->steps[op->ch1];\n+                goto start;\n+            }\n+            return(0);\n+        case XPATH_OP_COLLECT:\n+            if (op->ch1 == -1)\n+                return(0);\n@@ -12400,2 +11756,2 @@\n-        if (ctxt->error != XPATH_EXPRESSION_OK)\n-        return(-1);\n+            if (ctxt->error != XPATH_EXPRESSION_OK)\n+                return(-1);\n@@ -12404,2 +11760,2 @@\n-        if (ctxt->error != XPATH_EXPRESSION_OK)\n-        return(-1);\n+            if (ctxt->error != XPATH_EXPRESSION_OK)\n+                return(-1);\n@@ -12407,11 +11763,11 @@\n-        resObj = valuePop(ctxt);\n-        if (resObj == NULL)\n-        return(-1);\n-        break;\n-    default:\n-        \/*\n-        * Fallback to call xmlXPathCompOpEval().\n-        *\/\n-        xmlXPathCompOpEval(ctxt, op);\n-        if (ctxt->error != XPATH_EXPRESSION_OK)\n-        return(-1);\n+            resObj = xmlXPathValuePop(ctxt);\n+            if (resObj == NULL)\n+                return(-1);\n+            break;\n+        default:\n+            \/*\n+            * Fallback to call xmlXPathCompOpEval().\n+            *\/\n+            xmlXPathCompOpEval(ctxt, op);\n+            if (ctxt->error != XPATH_EXPRESSION_OK)\n+                return(-1);\n@@ -12419,4 +11775,4 @@\n-        resObj = valuePop(ctxt);\n-        if (resObj == NULL)\n-        return(-1);\n-        break;\n+            resObj = xmlXPathValuePop(ctxt);\n+            if (resObj == NULL)\n+                return(-1);\n+            break;\n@@ -12426,1 +11782,1 @@\n-    int res;\n+        int res;\n@@ -12428,17 +11784,17 @@\n-    if (resObj->type == XPATH_BOOLEAN) {\n-        res = resObj->boolval;\n-    } else if (isPredicate) {\n-        \/*\n-        * For predicates a result of type \"number\" is handled\n-        * differently:\n-        * SPEC XPath 1.0:\n-        * \"If the result is a number, the result will be converted\n-        *  to true if the number is equal to the context position\n-        *  and will be converted to false otherwise;\"\n-        *\/\n-        res = xmlXPathEvaluatePredicateResult(ctxt, resObj);\n-    } else {\n-        res = xmlXPathCastToBoolean(resObj);\n-    }\n-    xmlXPathReleaseObject(ctxt->context, resObj);\n-    return(res);\n+        if (resObj->type == XPATH_BOOLEAN) {\n+            res = resObj->boolval;\n+        } else if (isPredicate) {\n+            \/*\n+            * For predicates a result of type \"number\" is handled\n+            * differently:\n+            * SPEC XPath 1.0:\n+            * \"If the result is a number, the result will be converted\n+            *  to true if the number is equal to the context position\n+            *  and will be converted to false otherwise;\"\n+            *\/\n+            res = xmlXPathEvaluatePredicateResult(ctxt, resObj);\n+        } else {\n+            res = xmlXPathCastToBoolean(resObj);\n+        }\n+        xmlXPathReleaseObject(ctxt->context, resObj);\n+        return(res);\n@@ -12459,1 +11815,1 @@\n-              xmlXPathObjectPtr *resultSeq, int toBool)\n+                      xmlXPathObjectPtr *resultSeq, int toBool)\n@@ -12482,3 +11838,0 @@\n-#if 0\n-    printf(\"stream eval: depth %d from root %d\\n\", max_depth, from_root);\n-#endif\n@@ -12487,5 +11840,5 @@\n-    if (resultSeq == NULL)\n-        return(-1);\n-    *resultSeq = xmlXPathCacheNewNodeSet(pctxt, NULL);\n-    if (*resultSeq == NULL)\n-        return(-1);\n+        if (resultSeq == NULL)\n+            return(-1);\n+        *resultSeq = xmlXPathCacheNewNodeSet(pctxt, NULL);\n+        if (*resultSeq == NULL)\n+            return(-1);\n@@ -12500,4 +11853,4 @@\n-    if (from_root) {\n-        \/* Select \"\/\" *\/\n-        if (toBool)\n-        return(1);\n+        if (from_root) {\n+            \/* Select \"\/\" *\/\n+            if (toBool)\n+                return(1);\n@@ -12506,4 +11859,4 @@\n-    } else {\n-        \/* Select \"self::node()\" *\/\n-        if (toBool)\n-        return(1);\n+        } else {\n+            \/* Select \"self::node()\" *\/\n+            if (toBool)\n+                return(1);\n@@ -12512,1 +11865,1 @@\n-    }\n+        }\n@@ -12518,1 +11871,1 @@\n-    return(0);\n+        return(0);\n@@ -12529,2 +11882,2 @@\n-            cur = ctxt->node;\n-        break;\n+                cur = ctxt->node;\n+                break;\n@@ -12547,3 +11900,3 @@\n-        break;\n-    }\n-    limit = cur;\n+                break;\n+        }\n+        limit = cur;\n@@ -12558,1 +11911,1 @@\n-    return(-1);\n+        return(-1);\n@@ -12564,6 +11917,6 @@\n-    ret = xmlStreamPush(patstream, NULL, NULL);\n-    if (ret < 0) {\n-    } else if (ret == 1) {\n-        if (toBool)\n-        goto return_1;\n-        if (xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, cur) < 0)\n+        ret = xmlStreamPush(patstream, NULL, NULL);\n+        if (ret < 0) {\n+        } else if (ret == 1) {\n+            if (toBool)\n+                goto return_1;\n+            if (xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval, cur) < 0)\n@@ -12571,1 +11924,1 @@\n-    }\n+        }\n@@ -12586,13 +11939,13 @@\n-    switch (cur->type) {\n-        case XML_ELEMENT_NODE:\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        case XML_COMMENT_NODE:\n-        case XML_PI_NODE:\n-        if (cur->type == XML_ELEMENT_NODE) {\n-            ret = xmlStreamPush(patstream, cur->name,\n-                (cur->ns ? cur->ns->href : NULL));\n-        } else if (eval_all_nodes)\n-            ret = xmlStreamPushNode(patstream, NULL, NULL, cur->type);\n-        else\n-            break;\n+        switch (cur->type) {\n+            case XML_ELEMENT_NODE:\n+            case XML_TEXT_NODE:\n+            case XML_CDATA_SECTION_NODE:\n+            case XML_COMMENT_NODE:\n+            case XML_PI_NODE:\n+                if (cur->type == XML_ELEMENT_NODE) {\n+                    ret = xmlStreamPush(patstream, cur->name,\n+                                (cur->ns ? cur->ns->href : NULL));\n+                } else if (eval_all_nodes)\n+                    ret = xmlStreamPushNode(patstream, NULL, NULL, cur->type);\n+                else\n+                    break;\n@@ -12600,6 +11953,6 @@\n-        if (ret < 0) {\n-            xmlXPathPErrMemory(pctxt);\n-        } else if (ret == 1) {\n-            if (toBool)\n-            goto return_1;\n-            if (xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval,\n+                if (ret < 0) {\n+                    xmlXPathPErrMemory(pctxt);\n+                } else if (ret == 1) {\n+                    if (toBool)\n+                        goto return_1;\n+                    if (xmlXPathNodeSetAddUnique((*resultSeq)->nodesetval,\n@@ -12608,0 +11961,12 @@\n+                }\n+                if ((cur->children == NULL) || (depth >= max_depth)) {\n+                    ret = xmlStreamPop(patstream);\n+                    while (cur->next != NULL) {\n+                        cur = cur->next;\n+                        if ((cur->type != XML_ENTITY_DECL) &&\n+                            (cur->type != XML_DTD_NODE))\n+                            goto next_node;\n+                    }\n+                }\n+            default:\n+                break;\n@@ -12609,12 +11974,0 @@\n-        if ((cur->children == NULL) || (depth >= max_depth)) {\n-            ret = xmlStreamPop(patstream);\n-            while (cur->next != NULL) {\n-            cur = cur->next;\n-            if ((cur->type != XML_ENTITY_DECL) &&\n-                (cur->type != XML_DTD_NODE))\n-                goto next_node;\n-            }\n-        }\n-        default:\n-        break;\n-    }\n@@ -12623,13 +11976,14 @@\n-    if (cur->type == XML_NAMESPACE_DECL) break;\n-    if ((cur->children != NULL) && (depth < max_depth)) {\n-        \/*\n-         * Do not descend on entities declarations\n-         *\/\n-        if (cur->children->type != XML_ENTITY_DECL) {\n-        cur = cur->children;\n-        depth++;\n-        \/*\n-         * Skip DTDs\n-         *\/\n-        if (cur->type != XML_DTD_NODE)\n-            continue;\n+        if (cur->type == XML_NAMESPACE_DECL) break;\n+        if ((cur->children != NULL) && (depth < max_depth)) {\n+            \/*\n+             * Do not descend on entities declarations\n+             *\/\n+            if (cur->children->type != XML_ENTITY_DECL) {\n+                cur = cur->children;\n+                depth++;\n+                \/*\n+                 * Skip DTDs\n+                 *\/\n+                if (cur->type != XML_DTD_NODE)\n+                    continue;\n+            }\n@@ -12637,1 +11991,0 @@\n-    }\n@@ -12639,2 +11992,2 @@\n-    if (cur == limit)\n-        break;\n+        if (cur == limit)\n+            break;\n@@ -12642,6 +11995,6 @@\n-    while (cur->next != NULL) {\n-        cur = cur->next;\n-        if ((cur->type != XML_ENTITY_DECL) &&\n-        (cur->type != XML_DTD_NODE))\n-        goto next_node;\n-    }\n+        while (cur->next != NULL) {\n+            cur = cur->next;\n+            if ((cur->type != XML_ENTITY_DECL) &&\n+                (cur->type != XML_DTD_NODE))\n+                goto next_node;\n+        }\n@@ -12649,4 +12002,4 @@\n-    do {\n-        cur = cur->parent;\n-        depth--;\n-        if ((cur == NULL) || (cur == limit) ||\n+        do {\n+            cur = cur->parent;\n+            depth--;\n+            if ((cur == NULL) || (cur == limit) ||\n@@ -12654,16 +12007,16 @@\n-            goto done;\n-        if (cur->type == XML_ELEMENT_NODE) {\n-        ret = xmlStreamPop(patstream);\n-        } else if ((eval_all_nodes) &&\n-        ((cur->type == XML_TEXT_NODE) ||\n-         (cur->type == XML_CDATA_SECTION_NODE) ||\n-         (cur->type == XML_COMMENT_NODE) ||\n-         (cur->type == XML_PI_NODE)))\n-        {\n-        ret = xmlStreamPop(patstream);\n-        }\n-        if (cur->next != NULL) {\n-        cur = cur->next;\n-        break;\n-        }\n-    } while (cur != NULL);\n+                goto done;\n+            if (cur->type == XML_ELEMENT_NODE) {\n+                ret = xmlStreamPop(patstream);\n+            } else if ((eval_all_nodes) &&\n+                ((cur->type == XML_TEXT_NODE) ||\n+                 (cur->type == XML_CDATA_SECTION_NODE) ||\n+                 (cur->type == XML_COMMENT_NODE) ||\n+                 (cur->type == XML_PI_NODE)))\n+            {\n+                ret = xmlStreamPop(patstream);\n+            }\n+            if (cur->next != NULL) {\n+                cur = cur->next;\n+                break;\n+            }\n+        } while (cur != NULL);\n@@ -12676,1 +12029,1 @@\n-    xmlFreeStreamCtxt(patstream);\n+        xmlFreeStreamCtxt(patstream);\n@@ -12681,1 +12034,1 @@\n-    xmlFreeStreamCtxt(patstream);\n+        xmlFreeStreamCtxt(patstream);\n@@ -12700,1 +12053,1 @@\n-    return(-1);\n+        return(-1);\n@@ -12703,10 +12056,15 @@\n-    \/* Allocate the value stack *\/\n-    ctxt->valueTab = (xmlXPathObjectPtr *)\n-             xmlMalloc(10 * sizeof(xmlXPathObjectPtr));\n-    if (ctxt->valueTab == NULL) {\n-        xmlXPathPErrMemory(ctxt);\n-        return(-1);\n-    }\n-    ctxt->valueNr = 0;\n-    ctxt->valueMax = 10;\n-    ctxt->value = NULL;\n+#ifdef FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION\n+        int valueMax = 1;\n+#else\n+        int valueMax = 10;\n+#endif\n+\n+        \/* Allocate the value stack *\/\n+        ctxt->valueTab = xmlMalloc(valueMax * sizeof(xmlXPathObjectPtr));\n+        if (ctxt->valueTab == NULL) {\n+            xmlXPathPErrMemory(ctxt);\n+            return(-1);\n+        }\n+        ctxt->valueNr = 0;\n+        ctxt->valueMax = valueMax;\n+        ctxt->value = NULL;\n@@ -12716,1 +12074,1 @@\n-    int res;\n+        int res;\n@@ -12718,9 +12076,9 @@\n-    if (toBool) {\n-        \/*\n-        * Evaluation to boolean result.\n-        *\/\n-        res = xmlXPathRunStreamEval(ctxt, ctxt->comp->stream, NULL, 1);\n-        if (res != -1)\n-        return(res);\n-    } else {\n-        xmlXPathObjectPtr resObj = NULL;\n+        if (toBool) {\n+            \/*\n+            * Evaluation to boolean result.\n+            *\/\n+            res = xmlXPathRunStreamEval(ctxt, ctxt->comp->stream, NULL, 1);\n+            if (res != -1)\n+                return(res);\n+        } else {\n+            xmlXPathObjectPtr resObj = NULL;\n@@ -12728,4 +12086,4 @@\n-        \/*\n-        * Evaluation to a sequence.\n-        *\/\n-        res = xmlXPathRunStreamEval(ctxt, ctxt->comp->stream, &resObj, 0);\n+            \/*\n+            * Evaluation to a sequence.\n+            *\/\n+            res = xmlXPathRunStreamEval(ctxt, ctxt->comp->stream, &resObj, 0);\n@@ -12733,3 +12091,6 @@\n-        if ((res != -1) && (resObj != NULL)) {\n-        valuePush(ctxt, resObj);\n-        return(0);\n+            if ((res != -1) && (resObj != NULL)) {\n+                xmlXPathValuePush(ctxt, resObj);\n+                return(0);\n+            }\n+            if (resObj != NULL)\n+                xmlXPathReleaseObject(ctxt->context, resObj);\n@@ -12737,7 +12098,4 @@\n-        if (resObj != NULL)\n-        xmlXPathReleaseObject(ctxt->context, resObj);\n-    }\n-    \/*\n-    * QUESTION TODO: This falls back to normal XPath evaluation\n-    * if res == -1. Is this intended?\n-    *\/\n+        \/*\n+        * QUESTION TODO: This falls back to normal XPath evaluation\n+        * if res == -1. Is this intended?\n+        *\/\n@@ -12749,1 +12107,1 @@\n-    return(-1);\n+        return(-1);\n@@ -12753,2 +12111,2 @@\n-    return(xmlXPathCompOpEvalToBoolean(ctxt,\n-        &comp->steps[comp->last], 0));\n+        return(xmlXPathCompOpEvalToBoolean(ctxt,\n+            &comp->steps[comp->last], 0));\n@@ -12756,1 +12114,1 @@\n-    xmlXPathCompOpEval(ctxt, &comp->steps[comp->last]);\n+        xmlXPathCompOpEval(ctxt, &comp->steps[comp->last]);\n@@ -12763,3 +12121,3 @@\n- *                                    *\n- *            Public interfaces                *\n- *                                    *\n+ *                                                                      *\n+ *                      Public interfaces                               *\n+ *                                                                      *\n@@ -12789,1 +12147,1 @@\n-        return(res->boolval);\n+            return(res->boolval);\n@@ -12791,1 +12149,1 @@\n-        return(res->floatval == ctxt->proximityPosition);\n+            return(res->floatval == ctxt->proximityPosition);\n@@ -12794,3 +12152,3 @@\n-        if (res->nodesetval == NULL)\n-        return(0);\n-        return(res->nodesetval->nodeNr != 0);\n+            if (res->nodesetval == NULL)\n+                return(0);\n+            return(res->nodesetval->nodeNr != 0);\n@@ -12798,2 +12156,2 @@\n-        return((res->stringval != NULL) &&\n-               (xmlStrlen(res->stringval) != 0));\n+            return((res->stringval != NULL) &&\n+                   (xmlStrlen(res->stringval) != 0));\n@@ -12801,1 +12159,1 @@\n-        break;\n+            break;\n@@ -12828,1 +12186,1 @@\n-        return(res->boolval);\n+            return(res->boolval);\n@@ -12831,2 +12189,2 @@\n-        return((res->floatval == ctxt->context->proximityPosition) &&\n-               (!xmlXPathIsNaN(res->floatval))); \/* MSC pbm Mark Vakoc !*\/\n+            return((res->floatval == ctxt->context->proximityPosition) &&\n+                   (!xmlXPathIsNaN(res->floatval))); \/* MSC pbm Mark Vakoc !*\/\n@@ -12834,1 +12192,1 @@\n-        return(res->floatval == ctxt->context->proximityPosition);\n+            return(res->floatval == ctxt->context->proximityPosition);\n@@ -12838,3 +12196,3 @@\n-        if (res->nodesetval == NULL)\n-        return(0);\n-        return(res->nodesetval->nodeNr != 0);\n+            if (res->nodesetval == NULL)\n+                return(0);\n+            return(res->nodesetval->nodeNr != 0);\n@@ -12842,9 +12200,1 @@\n-        return((res->stringval != NULL) && (res->stringval[0] != 0));\n-#ifdef LIBXML_XPTR_LOCS_ENABLED\n-    case XPATH_LOCATIONSET:{\n-        xmlLocationSetPtr ptr = res->user;\n-        if (ptr == NULL)\n-            return(0);\n-        return (ptr->locNr != 0);\n-        }\n-#endif\n+            return((res->stringval != NULL) && (res->stringval[0] != 0));\n@@ -12852,1 +12202,1 @@\n-        break;\n+            break;\n@@ -12882,1 +12232,1 @@\n-    const xmlChar *tmp;\n+        const xmlChar *tmp;\n@@ -12885,20 +12235,12 @@\n-    \/*\n-     * We don't try to handle expressions using the verbose axis\n-     * specifiers (\"::\"), just the simplified form at this point.\n-     * Additionally, if there is no list of namespaces available and\n-     *  there's a \":\" in the expression, indicating a prefixed QName,\n-     *  then we won't try to compile either. xmlPatterncompile() needs\n-     *  to have a list of namespaces at compilation time in order to\n-     *  compile prefixed name tests.\n-     *\/\n-    tmp = xmlStrchr(str, ':');\n-    if ((tmp != NULL) &&\n-        ((ctxt == NULL) || (ctxt->nsNr == 0) || (tmp[1] == ':')))\n-        return(NULL);\n-\n-    if (ctxt != NULL) {\n-        dict = ctxt->dict;\n-        if (ctxt->nsNr > 0) {\n-        namespaces = xmlMalloc(2 * (ctxt->nsNr + 1) * sizeof(xmlChar*));\n-        if (namespaces == NULL) {\n-            xmlXPathErrMemory(ctxt);\n+        \/*\n+         * We don't try to handle expressions using the verbose axis\n+         * specifiers (\"::\"), just the simplified form at this point.\n+         * Additionally, if there is no list of namespaces available and\n+         *  there's a \":\" in the expression, indicating a prefixed QName,\n+         *  then we won't try to compile either. xmlPatterncompile() needs\n+         *  to have a list of namespaces at compilation time in order to\n+         *  compile prefixed name tests.\n+         *\/\n+        tmp = xmlStrchr(str, ':');\n+        if ((tmp != NULL) &&\n+            ((ctxt == NULL) || (ctxt->nsNr == 0) || (tmp[1] == ':')))\n@@ -12906,0 +12248,17 @@\n+\n+        if (ctxt != NULL) {\n+            dict = ctxt->dict;\n+            if (ctxt->nsNr > 0) {\n+                namespaces = xmlMalloc(2 * (ctxt->nsNr + 1) * sizeof(xmlChar*));\n+                if (namespaces == NULL) {\n+                    xmlXPathErrMemory(ctxt);\n+                    return(NULL);\n+                }\n+                for (i = 0, j = 0; (j < ctxt->nsNr); j++) {\n+                    ns = ctxt->namespaces[j];\n+                    namespaces[i++] = ns->href;\n+                    namespaces[i++] = ns->prefix;\n+                }\n+                namespaces[i++] = NULL;\n+                namespaces[i] = NULL;\n+            }\n@@ -12907,9 +12266,0 @@\n-        for (i = 0, j = 0; (j < ctxt->nsNr); j++) {\n-            ns = ctxt->namespaces[j];\n-            namespaces[i++] = ns->href;\n-            namespaces[i++] = ns->prefix;\n-        }\n-        namespaces[i++] = NULL;\n-        namespaces[i] = NULL;\n-        }\n-    }\n@@ -12917,1 +12267,1 @@\n-    res = xmlPatternCompileSafe(str, dict, XML_PATTERN_XPATH, namespaces,\n+        res = xmlPatternCompileSafe(str, dict, XML_PATTERN_XPATH, namespaces,\n@@ -12919,3 +12269,3 @@\n-    if (namespaces != NULL) {\n-        xmlFree((xmlChar **)namespaces);\n-    }\n+        if (namespaces != NULL) {\n+            xmlFree((xmlChar **)namespaces);\n+        }\n@@ -12926,6 +12276,12 @@\n-    if ((stream != NULL) && (xmlPatternStreamable(stream) == 1)) {\n-        comp = xmlXPathNewCompExpr();\n-        if (comp == NULL) {\n-        xmlXPathErrMemory(ctxt);\n-            xmlFreePattern(stream);\n-        return(NULL);\n+        if ((stream != NULL) && (xmlPatternStreamable(stream) == 1)) {\n+            comp = xmlXPathNewCompExpr();\n+            if (comp == NULL) {\n+                xmlXPathErrMemory(ctxt);\n+                xmlFreePattern(stream);\n+                return(NULL);\n+            }\n+            comp->stream = stream;\n+            comp->dict = dict;\n+            if (comp->dict)\n+                xmlDictReference(comp->dict);\n+            return(comp);\n@@ -12933,7 +12289,1 @@\n-        comp->stream = stream;\n-        comp->dict = dict;\n-        if (comp->dict)\n-        xmlDictReference(comp->dict);\n-        return(comp);\n-    }\n-    xmlFreePattern(stream);\n+        xmlFreePattern(stream);\n@@ -12999,1 +12349,1 @@\n-    }\n+        }\n@@ -13016,1 +12366,1 @@\n-    xmlXPathOptimizeExpression(pctxt, &comp->steps[op->ch2]);\n+        xmlXPathOptimizeExpression(pctxt, &comp->steps[op->ch2]);\n@@ -13076,8 +12426,8 @@\n-    \/*\n-     * aleksey: in some cases this line prints *second* error message\n-     * (see bug #78858) and probably this should be fixed.\n-     * However, we are not sure that all error messages are printed\n-     * out in other places. It's not critical so we leave it as-is for now\n-     *\/\n-    xmlXPatherror(pctxt, __FILE__, __LINE__, XPATH_EXPR_ERROR);\n-    comp = NULL;\n+        \/*\n+         * aleksey: in some cases this line prints *second* error message\n+         * (see bug #78858) and probably this should be fixed.\n+         * However, we are not sure that all error messages are printed\n+         * out in other places. It's not critical so we leave it as-is for now\n+         *\/\n+        xmlXPatherror(pctxt, __FILE__, __LINE__, XPATH_EXPR_ERROR);\n+        comp = NULL;\n@@ -13085,2 +12435,2 @@\n-    comp = pctxt->comp;\n-    if ((comp->nbStep > 1) && (comp->last >= 0)) {\n+        comp = pctxt->comp;\n+        if ((comp->nbStep > 1) && (comp->last >= 0)) {\n@@ -13089,1 +12439,1 @@\n-        xmlXPathOptimizeExpression(pctxt, &comp->steps[comp->last]);\n+            xmlXPathOptimizeExpression(pctxt, &comp->steps[comp->last]);\n@@ -13092,2 +12442,2 @@\n-    }\n-    pctxt->comp = NULL;\n+        }\n+        pctxt->comp = NULL;\n@@ -13100,1 +12450,1 @@\n-    comp->expr = xmlStrdup(str);\n+        comp->expr = xmlStrdup(str);\n@@ -13134,3 +12484,3 @@\n-                 xmlXPathContextPtr ctxt,\n-                 xmlXPathObjectPtr *resObjPtr,\n-                 int toBool)\n+                             xmlXPathContextPtr ctxt,\n+                             xmlXPathObjectPtr *resObjPtr,\n+                             int toBool)\n@@ -13140,3 +12490,0 @@\n-#ifndef LIBXML_THREAD_ENABLED\n-    static int reentance = 0;\n-#endif\n@@ -13146,1 +12493,1 @@\n-    return(-1);\n+        return(-1);\n@@ -13151,6 +12498,0 @@\n-#ifndef LIBXML_THREAD_ENABLED\n-    reentance++;\n-    if (reentance > 1)\n-    xmlXPathDisableOptimizer = 1;\n-#endif\n-\n@@ -13166,1 +12507,1 @@\n-            resObj = valuePop(pctxt);\n+            resObj = xmlXPathValuePop(pctxt);\n@@ -13176,3 +12517,0 @@\n-#ifndef LIBXML_THREAD_ENABLED\n-    reentance--;\n-#endif\n@@ -13215,1 +12553,1 @@\n-                  xmlXPathContextPtr ctxt)\n+                              xmlXPathContextPtr ctxt)\n@@ -13224,0 +12562,2 @@\n+ * DEPRECATED: Internal function, don't use.\n+ *\n@@ -13234,1 +12574,1 @@\n-    if (ctxt == NULL)\n+    if ((ctxt == NULL) || (ctxt->context == NULL))\n@@ -13248,1 +12588,1 @@\n-        xmlXPathFreeCompExpr(ctxt->comp);\n+            xmlXPathFreeCompExpr(ctxt->comp);\n@@ -13255,1 +12595,1 @@\n-    xmlXPathCompileExpr(ctxt, 1);\n+        xmlXPathCompileExpr(ctxt, 1);\n@@ -13264,1 +12604,1 @@\n-    if ((ctxt->comp->nbStep > 1) && (ctxt->comp->last >= 0)) {\n+        if ((ctxt->comp->nbStep > 1) && (ctxt->comp->last >= 0)) {\n@@ -13267,2 +12607,2 @@\n-        xmlXPathOptimizeExpression(ctxt,\n-        &ctxt->comp->steps[ctxt->comp->last]);\n+            xmlXPathOptimizeExpression(ctxt,\n+                &ctxt->comp->steps[ctxt->comp->last]);\n@@ -13305,1 +12645,1 @@\n-    res = NULL;\n+        res = NULL;\n@@ -13308,1 +12648,1 @@\n-    res = NULL;\n+        res = NULL;\n@@ -13310,1 +12650,1 @@\n-    res = valuePop(ctxt);\n+        res = xmlXPathValuePop(ctxt);\n@@ -13334,1 +12674,1 @@\n-    return(0);\n+        return(0);\n@@ -13375,113 +12715,0 @@\n-\/************************************************************************\n- *                                    *\n- *    Extra functions not pertaining to the XPath spec        *\n- *                                    *\n- ************************************************************************\/\n-\/**\n- * xmlXPathEscapeUriFunction:\n- * @ctxt:  the XPath Parser context\n- * @nargs:  the number of arguments\n- *\n- * Implement the escape-uri() XPath function\n- *    string escape-uri(string $str, bool $escape-reserved)\n- *\n- * This function applies the URI escaping rules defined in section 2 of [RFC\n- * 2396] to the string supplied as $uri-part, which typically represents all\n- * or part of a URI. The effect of the function is to replace any special\n- * character in the string by an escape sequence of the form %xx%yy...,\n- * where xxyy... is the hexadecimal representation of the octets used to\n- * represent the character in UTF-8.\n- *\n- * The set of characters that are escaped depends on the setting of the\n- * boolean argument $escape-reserved.\n- *\n- * If $escape-reserved is true, all characters are escaped other than lower\n- * case letters a-z, upper case letters A-Z, digits 0-9, and the characters\n- * referred to in [RFC 2396] as \"marks\": specifically, \"-\" | \"_\" | \".\" | \"!\"\n- * | \"~\" | \"*\" | \"'\" | \"(\" | \")\". The \"%\" character itself is escaped only\n- * if it is not followed by two hexadecimal digits (that is, 0-9, a-f, and\n- * A-F).\n- *\n- * If $escape-reserved is false, the behavior differs in that characters\n- * referred to in [RFC 2396] as reserved characters are not escaped. These\n- * characters are \";\" | \"\/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\".\n- *\n- * [RFC 2396] does not define whether escaped URIs should use lower case or\n- * upper case for hexadecimal digits. To ensure that escaped URIs can be\n- * compared using string comparison functions, this function must always use\n- * the upper-case letters A-F.\n- *\n- * Generally, $escape-reserved should be set to true when escaping a string\n- * that is to form a single part of a URI, and to false when escaping an\n- * entire URI or URI reference.\n- *\n- * In the case of non-ascii characters, the string is encoded according to\n- * utf-8 and then converted according to RFC 2396.\n- *\n- * Examples\n- *  xf:escape-uri (\"gopher:\/\/spinaltap.micro.umn.edu\/00\/Weather\/California\/Los%20Angeles#ocean\"), true())\n- *  returns \"gopher%3A%2F%2Fspinaltap.micro.umn.edu%2F00%2FWeather%2FCalifornia%2FLos%20Angeles%23ocean\"\n- *  xf:escape-uri (\"gopher:\/\/spinaltap.micro.umn.edu\/00\/Weather\/California\/Los%20Angeles#ocean\"), false())\n- *  returns \"gopher:\/\/spinaltap.micro.umn.edu\/00\/Weather\/California\/Los%20Angeles%23ocean\"\n- *\n- *\/\n-static void\n-xmlXPathEscapeUriFunction(xmlXPathParserContextPtr ctxt, int nargs) {\n-    xmlXPathObjectPtr str;\n-    int escape_reserved;\n-    xmlBufPtr target;\n-    xmlChar *cptr;\n-    xmlChar escape[4];\n-\n-    CHECK_ARITY(2);\n-\n-    escape_reserved = xmlXPathPopBoolean(ctxt);\n-\n-    CAST_TO_STRING;\n-    str = valuePop(ctxt);\n-\n-    target = xmlBufCreateSize(64);\n-\n-    escape[0] = '%';\n-    escape[3] = 0;\n-\n-    if (target) {\n-    for (cptr = str->stringval; *cptr; cptr++) {\n-        if ((*cptr >= 'A' && *cptr <= 'Z') ||\n-        (*cptr >= 'a' && *cptr <= 'z') ||\n-        (*cptr >= '0' && *cptr <= '9') ||\n-        *cptr == '-' || *cptr == '_' || *cptr == '.' ||\n-        *cptr == '!' || *cptr == '~' || *cptr == '*' ||\n-        *cptr == '\\''|| *cptr == '(' || *cptr == ')' ||\n-        (*cptr == '%' &&\n-         ((cptr[1] >= 'A' && cptr[1] <= 'F') ||\n-          (cptr[1] >= 'a' && cptr[1] <= 'f') ||\n-          (cptr[1] >= '0' && cptr[1] <= '9')) &&\n-         ((cptr[2] >= 'A' && cptr[2] <= 'F') ||\n-          (cptr[2] >= 'a' && cptr[2] <= 'f') ||\n-          (cptr[2] >= '0' && cptr[2] <= '9'))) ||\n-        (!escape_reserved &&\n-         (*cptr == ';' || *cptr == '\/' || *cptr == '?' ||\n-          *cptr == ':' || *cptr == '@' || *cptr == '&' ||\n-          *cptr == '=' || *cptr == '+' || *cptr == '$' ||\n-          *cptr == ','))) {\n-        xmlBufAdd(target, cptr, 1);\n-        } else {\n-        if ((*cptr >> 4) < 10)\n-            escape[1] = '0' + (*cptr >> 4);\n-        else\n-            escape[1] = 'A' - 10 + (*cptr >> 4);\n-        if ((*cptr & 0xF) < 10)\n-            escape[2] = '0' + (*cptr & 0xF);\n-        else\n-            escape[2] = 'A' - 10 + (*cptr & 0xF);\n-\n-        xmlBufAdd(target, &escape[0], 3);\n-        }\n-    }\n-    }\n-    valuePush(ctxt, xmlXPathCacheNewString(ctxt, xmlBufContent(target)));\n-    xmlBufFree(target);\n-    xmlXPathReleaseObject(ctxt->context, str);\n-}\n-\n@@ -13492,0 +12719,2 @@\n+ * DEPRECATED: No-op since 2.14.0.\n+ *\n@@ -13495,1 +12724,1 @@\n-xmlXPathRegisterAllFunctions(xmlXPathContextPtr ctxt)\n+xmlXPathRegisterAllFunctions(xmlXPathContextPtr ctxt ATTRIBUTE_UNUSED)\n@@ -13497,58 +12726,0 @@\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"boolean\",\n-                         xmlXPathBooleanFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"ceiling\",\n-                         xmlXPathCeilingFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"count\",\n-                         xmlXPathCountFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"concat\",\n-                         xmlXPathConcatFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"contains\",\n-                         xmlXPathContainsFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"id\",\n-                         xmlXPathIdFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"false\",\n-                         xmlXPathFalseFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"floor\",\n-                         xmlXPathFloorFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"last\",\n-                         xmlXPathLastFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"lang\",\n-                         xmlXPathLangFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"local-name\",\n-                         xmlXPathLocalNameFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"not\",\n-                         xmlXPathNotFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"name\",\n-                         xmlXPathNameFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"namespace-uri\",\n-                         xmlXPathNamespaceURIFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"normalize-space\",\n-                         xmlXPathNormalizeFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"number\",\n-                         xmlXPathNumberFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"position\",\n-                         xmlXPathPositionFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"round\",\n-                         xmlXPathRoundFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"string\",\n-                         xmlXPathStringFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"string-length\",\n-                         xmlXPathStringLengthFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"starts-with\",\n-                         xmlXPathStartsWithFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"substring\",\n-                         xmlXPathSubstringFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"substring-before\",\n-                         xmlXPathSubstringBeforeFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"substring-after\",\n-                         xmlXPathSubstringAfterFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"sum\",\n-                         xmlXPathSumFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"true\",\n-                         xmlXPathTrueFunction);\n-    xmlXPathRegisterFunc(ctxt, (const xmlChar *)\"translate\",\n-                         xmlXPathTranslateFunction);\n-\n-    xmlXPathRegisterFuncNS(ctxt, (const xmlChar *)\"escape-uri\",\n-     (const xmlChar *)\"http:\/\/www.w3.org\/2002\/08\/xquery-functions\",\n-                         xmlXPathEscapeUriFunction);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xpath.c","additions":3748,"deletions":4577,"binary":false,"changes":8325,"status":"modified"},{"patch":"@@ -4,3 +4,0 @@\n-#define HAVE_SYS_STAT_H\n-#define HAVE_STAT\n-#define HAVE_FCNTL_H\n@@ -21,0 +18,1 @@\n+#define XML_SYSCONFDIR \"\/etc\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/win32\/config.h","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -13,14 +13,0 @@\n-#include <libxml\/xmlexports.h>\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-\/*\n- * use those to be sure nothing nasty will happen if\n- * your library and includes mismatch\n- *\/\n-#ifndef LIBXML2_COMPILING_MSCCDEF\n-XMLPUBFUN void xmlCheckVersion(int version);\n-#endif \/* LIBXML2_COMPILING_MSCCDEF *\/\n-\n@@ -32,1 +18,1 @@\n-#define LIBXML_DOTTED_VERSION \"2.12.7\"\n+#define LIBXML_DOTTED_VERSION \"2.14.5undefined\"\n@@ -39,1 +25,1 @@\n-#define LIBXML_VERSION 21207\n+#define LIBXML_VERSION 21405\n@@ -46,1 +32,1 @@\n-#define LIBXML_VERSION_STRING \"21207\"\n+#define LIBXML_VERSION_STRING \"21405\"\n@@ -61,26 +47,1 @@\n-#define LIBXML_TEST_VERSION xmlCheckVersion(21207);\n-\n-#ifndef VMS\n-#if 0\n-\/**\n- * WITH_TRIO:\n- *\n- * defined if the trio support need to be configured in\n- *\/\n-#define WITH_TRIO\n-#else\n-\/**\n- * WITHOUT_TRIO:\n- *\n- * defined if the trio support should not be configured in\n- *\/\n-#define WITHOUT_TRIO\n-#endif\n-#else \/* VMS *\/\n-\/**\n- * WITH_TRIO:\n- *\n- * defined if the trio support need to be configured in\n- *\/\n-#define WITH_TRIO 1\n-#endif \/* VMS *\/\n+#define LIBXML_TEST_VERSION xmlCheckVersion(21405);\n@@ -109,1 +70,1 @@\n- * Whether the DOM like tree manipulation API support is configured in\n+ * Always enabled since 2.14.0\n@@ -111,1 +72,0 @@\n-#if 1\n@@ -113,1 +73,0 @@\n-#endif\n@@ -169,9 +128,0 @@\n-\/**\n- * LIBXML_FTP_ENABLED:\n- *\n- * Whether the FTP support is configured in\n- *\/\n-#if 0\n-#define LIBXML_FTP_ENABLED\n-#endif\n-\n@@ -208,1 +158,1 @@\n- * Whether the deprecated APIs are compiled in for compatibility\n+ * Removed in 2.14\n@@ -210,3 +160,1 @@\n-#if 0\n-#define LIBXML_LEGACY_ENABLED\n-#endif\n+#undef LIBXML_LEGACY_ENABLED\n@@ -250,9 +198,0 @@\n-\/**\n- * LIBXML_XPTR_LOCS_ENABLED:\n- *\n- * Whether support for XPointer locations is configured in\n- *\/\n-#if 0\n-#define LIBXML_XPTR_LOCS_ENABLED\n-#endif\n-\n@@ -304,18 +243,0 @@\n-\/**\n- * DEBUG_MEMORY_LOCATION:\n- *\n- * Whether the memory debugging is configured in\n- *\/\n-#if 0\n-#define DEBUG_MEMORY_LOCATION\n-#endif\n-\n-\/**\n- * LIBXML_DEBUG_RUNTIME:\n- *\n- * Removed\n- *\/\n-#if 0\n-#define LIBXML_DEBUG_RUNTIME\n-#endif\n-\n@@ -325,1 +246,1 @@\n- * Whether the Unicode related interfaces are compiled in\n+ * Removed in 2.14\n@@ -327,3 +248,1 @@\n-#if 0\n-#define LIBXML_UNICODE_ENABLED\n-#endif\n+#undef LIBXML_UNICODE_ENABLED\n@@ -350,1 +269,1 @@\n- * LIBXML_EXPR_ENABLED:\n+ * LIBXML_RELAXNG_ENABLED:\n@@ -352,3 +271,1 @@\n- * Whether the formal expressions interfaces are compiled in\n- *\n- * This code is unused and disabled unconditionally for now.\n+ * Whether the RelaxNG validation interfaces are compiled in\n@@ -357,1 +274,1 @@\n-#define LIBXML_EXPR_ENABLED\n+#define LIBXML_RELAXNG_ENABLED\n@@ -411,94 +328,1 @@\n-#ifdef __GNUC__\n-\/** DOC_DISABLE *\/\n-\n-#ifndef ATTRIBUTE_UNUSED\n-# if ((__GNUC__ > 2) || ((__GNUC__ == 2) && (__GNUC_MINOR__ >= 7)))\n-#  define ATTRIBUTE_UNUSED __attribute__((unused))\n-# else\n-#  define ATTRIBUTE_UNUSED\n-# endif\n-#endif\n-\n-#ifndef LIBXML_ATTR_ALLOC_SIZE\n-# if (!defined(__clang__) && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 3))))\n-#  define LIBXML_ATTR_ALLOC_SIZE(x) __attribute__((alloc_size(x)))\n-# else\n-#  define LIBXML_ATTR_ALLOC_SIZE(x)\n-# endif\n-#else\n-# define LIBXML_ATTR_ALLOC_SIZE(x)\n-#endif\n-\n-#ifndef LIBXML_ATTR_FORMAT\n-# if ((__GNUC__ > 3) || ((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)))\n-#  define LIBXML_ATTR_FORMAT(fmt,args) __attribute__((__format__(__printf__,fmt,args)))\n-# else\n-#  define LIBXML_ATTR_FORMAT(fmt,args)\n-# endif\n-#else\n-# define LIBXML_ATTR_FORMAT(fmt,args)\n-#endif\n-\n-#ifndef XML_DEPRECATED\n-#  if defined (IN_LIBXML) || (__GNUC__ * 100 + __GNUC_MINOR__ < 301)\n-#    define XML_DEPRECATED\n-\/* Available since at least GCC 3.1 *\/\n-#  else\n-#    define XML_DEPRECATED __attribute__((deprecated))\n-#  endif\n-#endif\n-\n-#if defined(__clang__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 406)\n-  #if defined(__clang__) || (__GNUC__ * 100 + __GNUC_MINOR__ >= 800)\n-    #define XML_IGNORE_FPTR_CAST_WARNINGS \\\n-      _Pragma(\"GCC diagnostic push\") \\\n-      _Pragma(\"GCC diagnostic ignored \\\"-Wpedantic\\\"\") \\\n-      _Pragma(\"GCC diagnostic ignored \\\"-Wcast-function-type\\\"\")\n-  #else\n-    #define XML_IGNORE_FPTR_CAST_WARNINGS \\\n-      _Pragma(\"GCC diagnostic push\") \\\n-      _Pragma(\"GCC diagnostic ignored \\\"-Wpedantic\\\"\")\n-  #endif\n-  #define XML_POP_WARNINGS \\\n-    _Pragma(\"GCC diagnostic pop\")\n-#else\n-  #define XML_IGNORE_FPTR_CAST_WARNINGS\n-  #define XML_POP_WARNINGS\n-#endif\n-\n-#else \/* ! __GNUC__ *\/\n-#define ATTRIBUTE_UNUSED\n-#define LIBXML_ATTR_ALLOC_SIZE(x)\n-#define LIBXML_ATTR_FORMAT(fmt,args)\n-#ifndef XML_DEPRECATED\n-#  if defined (IN_LIBXML) || !defined (_MSC_VER)\n-#    define XML_DEPRECATED\n-\/* Available since Visual Studio 2005 *\/\n-#  elif defined (_MSC_VER) && (_MSC_VER >= 1400)\n-#    define XML_DEPRECATED __declspec(deprecated)\n-#  endif\n-#endif\n-#if defined (_MSC_VER) && (_MSC_VER >= 1400)\n-#  define XML_IGNORE_FPTR_CAST_WARNINGS __pragma(warning(push))\n-#else\n-#  define XML_IGNORE_FPTR_CAST_WARNINGS\n-#endif\n-#ifndef XML_POP_WARNINGS\n-#  if defined (_MSC_VER) && (_MSC_VER >= 1400)\n-#    define XML_POP_WARNINGS __pragma(warning(pop))\n-#  else\n-#    define XML_POP_WARNINGS\n-#  endif\n-#endif\n-#endif \/* __GNUC__ *\/\n-\n-#define XML_NO_ATTR\n-\n-#ifdef LIBXML_THREAD_ENABLED\n-  #define XML_DECLARE_GLOBAL(name, type, attrs) \\\n-    attrs XMLPUBFUN type *__##name(void);\n-  #define XML_GLOBAL_MACRO(name) (*__##name())\n-#else\n-  #define XML_DECLARE_GLOBAL(name, type, attrs) \\\n-    attrs XMLPUBVAR type name;\n-#endif\n+#include <libxml\/xmlexports.h>\n@@ -506,3 +330,0 @@\n-#ifdef __cplusplus\n-}\n-#endif \/* __cplusplus *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/win32\/include\/libxml\/xmlversion.h","additions":13,"deletions":192,"binary":false,"changes":205,"status":"modified"}]}