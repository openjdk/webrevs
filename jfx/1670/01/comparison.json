{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## GNU Glib v2.80.4\n+## GNU Glib v2.82.4\n@@ -6,1 +6,1 @@\n-You are receiving a copy of GNU Glib, Version: 2.80.4 in either source or\n+You are receiving a copy of GNU Glib, Version: 2.82.4 in either source or\n@@ -8,1 +8,1 @@\n-Oracle license do NOT apply to the GNU Glib, Version: 2.80.4; it is\n+Oracle license do NOT apply to the GNU Glib, Version: 2.82.4; it is\n@@ -91,1 +91,1 @@\n-Copyright (C) 2002-2007\n+Copyright (C) 2002-2007 Soeren Sandmann (sandmann@daimi.au.dk)\n","filename":"modules\/javafx.media\/src\/main\/legal\/glib.md","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## GStreamer v1.24.6\n+## GStreamer v1.24.10\n@@ -6,1 +6,1 @@\n-You are receiving a copy of GStreamer, Version: 1.24.6 in either source or\n+You are receiving a copy of GStreamer, Version: 1.24.10 in either source or\n@@ -8,1 +8,1 @@\n-Oracle license do NOT apply to the GStreamer, Version: 1.24.6; it is\n+Oracle license do NOT apply to the GStreamer, Version: 1.24.10; it is\n@@ -62,2 +62,1 @@\n-Copyright (C) 2010 Collabora Multimedia\n-Copyright (C) 2009-2010 Edward Hervey <edward.hervey@collabora.co.uk>\n+Copyright (C) 2010 Edward Hervey <edward.hervey@collabora.co.uk>\n","filename":"modules\/javafx.media\/src\/main\/legal\/gstreamer.md","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-#define GLIB_BINARY_AGE 8004\n+#define GLIB_BINARY_AGE 8204\n@@ -57,1 +57,1 @@\n-#define GLIB_MINOR_VERSION 80\n+#define GLIB_MINOR_VERSION 82\n@@ -708,1 +708,1 @@\n-#define PACKAGE_STRING \"glib 2.80.4\"\n+#define PACKAGE_STRING \"glib 2.82.4\"\n@@ -717,1 +717,1 @@\n-#define PACKAGE_VERSION \"2.80.4\"\n+#define PACKAGE_VERSION \"2.82.4\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/build\/osx\/config.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-#define GLIB_MINOR_VERSION 80\n+#define GLIB_MINOR_VERSION 82\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/build\/osx\/glibconfig.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#define GLIB_BINARY_AGE 8004\n+#define GLIB_BINARY_AGE 8204\n@@ -56,1 +56,1 @@\n-#define GLIB_MINOR_VERSION 80\n+#define GLIB_MINOR_VERSION 82\n@@ -695,1 +695,1 @@\n-#define PACKAGE_STRING \"glib 2.80.4\"\n+#define PACKAGE_STRING \"glib 2.82.4\"\n@@ -704,1 +704,1 @@\n-#define PACKAGE_VERSION \"2.80.4\"\n+#define PACKAGE_VERSION \"2.82.4\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/build\/win32\/vs100\/config.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-#define GLIB_MINOR_VERSION 80\n+#define GLIB_MINOR_VERSION 82\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/build\/win32\/vs100\/glibconfig.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -210,0 +210,5 @@\n+ * Note that implementing weak references via @clear_func is not thread-safe:\n+ * clearing a pointer to the memory from the callback can race with another\n+ * thread trying to access it as @mem_block already has a reference count of 0\n+ * when the callback is called and will be freed.\n+ *\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/garcbox.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -933,5 +933,5 @@\n-    g_qsort_with_data (array->data,\n-                       array->len,\n-                       array->elt_size,\n-                       (GCompareDataFunc)compare_func,\n-                       NULL);\n+    g_sort_array (array->data,\n+                  array->len,\n+                  array->elt_size,\n+                  (GCompareDataFunc) compare_func,\n+                  NULL);\n@@ -965,5 +965,5 @@\n-    g_qsort_with_data (array->data,\n-                       array->len,\n-                       array->elt_size,\n-                       compare_func,\n-                       user_data);\n+    g_sort_array (array->data,\n+                  array->len,\n+                  array->elt_size,\n+                  compare_func,\n+                  user_data);\n@@ -2355,0 +2355,1 @@\n+  guint real_index;\n@@ -2358,1 +2359,1 @@\n-  g_return_if_fail (index_ <= (gint)rarray->len);\n+  g_return_if_fail (index_ < 0 || (guint) index_ <= rarray->len);\n@@ -2362,2 +2363,1 @@\n-  if (index_ < 0)\n-    index_ = rarray->len;\n+  real_index = (index_ >= 0) ? (guint) index_ : rarray->len;\n@@ -2365,4 +2365,4 @@\n-  if ((guint) index_ < rarray->len)\n-    memmove (&(rarray->pdata[index_ + 1]),\n-             &(rarray->pdata[index_]),\n-             (rarray->len - index_) * sizeof (gpointer));\n+  if (real_index < rarray->len)\n+    memmove (&(rarray->pdata[real_index + 1]),\n+             &(rarray->pdata[real_index]),\n+             (rarray->len - real_index) * sizeof (gpointer));\n@@ -2371,1 +2371,1 @@\n-  rarray->pdata[index_] = data;\n+  rarray->pdata[real_index] = data;\n@@ -2430,5 +2430,5 @@\n-    g_qsort_with_data (array->pdata,\n-                       array->len,\n-                       sizeof (gpointer),\n-                       (GCompareDataFunc)compare_func,\n-                       NULL);\n+    g_sort_array (array->pdata,\n+                  array->len,\n+                  sizeof (gpointer),\n+                  (GCompareDataFunc) compare_func,\n+                  NULL);\n@@ -2510,5 +2510,5 @@\n-    g_qsort_with_data (array->pdata,\n-                       array->len,\n-                       sizeof (gpointer),\n-                       compare_func,\n-                       user_data);\n+    g_sort_array (array->pdata,\n+                  array->len,\n+                  sizeof (gpointer),\n+                  compare_func,\n+                  user_data);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/garray.c","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n- * GAsyncQueue:\n+ * GAsyncQueue: (copy-func g_async_queue_ref) (free-func g_async_queue_unref)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gasyncqueue.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -439,1 +439,2 @@\n-  gint input_length, state = 0;\n+  gint state = 0;\n+  size_t input_length;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gbase64.c","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * GBytes:\n+ * GBytes: (copy-func g_bytes_ref) (free-func g_bytes_unref)\n@@ -612,1 +612,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gbytes.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-   * be repesented in the destination character set.\n+   * be represented in the destination character set.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gconvert.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2261,0 +2261,1 @@\n+  size_t format_len = strlen (format);\n@@ -2272,1 +2273,2 @@\n-  result = g_array_sized_new (FALSE, FALSE, sizeof (wchar_t), MAX (128, strlen (format) * 2));\n+  result = g_array_sized_new (FALSE, FALSE, sizeof (wchar_t),\n+                              (format_len <= 64) ? (guint) format_len * 2 : 128);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gdate.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1498,1 +1498,1 @@\n- * @text. ISO 8601 strings of the form <date><sep><time><tz> are supported, with\n+ * @text. ISO 8601 strings of the form `<date><sep><time><tz>` are supported, with\n@@ -1506,1 +1506,1 @@\n- * <sep> is the separator and can be either 'T', 't' or ' '. The latter two\n+ * `<sep>` is the separator and can be either 'T', 't' or ' '. The latter two\n@@ -1510,1 +1510,1 @@\n- * <date> is in the form:\n+ * `<date>` is in the form:\n@@ -1520,1 +1520,1 @@\n- * <time> is in the form:\n+ * `<time>` is in the form:\n@@ -1525,1 +1525,1 @@\n- * <tz> is an optional timezone suffix of the form:\n+ * `<tz>` is an optional timezone suffix of the form:\n@@ -3112,1 +3112,1 @@\n-  const gchar *tmp[10];\n+  const gchar *tmp[10] = { NULL, };\n@@ -3276,1 +3276,1 @@\n-  guint     len;\n+  size_t len;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gdatetime.c","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -650,1 +650,1 @@\n-  gint i, n;\n+  size_t i, n;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/genviron.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -376,1 +376,1 @@\n-      int extlen;\n+      size_t extlen;\n@@ -404,1 +404,1 @@\n-    if (extlen == q - p &&\n+      if (extlen == (size_t) (q - p) &&\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gfileutils.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n- * @user_data: user data passed to g_hash_table_remove()\n+ * @user_data: user data passed to the calling function\n@@ -130,4 +130,2 @@\n- * g_hash_table_foreach_remove(). It is called with each key\/value\n- * pair, together with the @user_data parameter passed to\n- * g_hash_table_foreach_remove(). It should return %TRUE if the\n- * key\/value pair should be removed from the #GHashTable.\n+ * [func@GLib.HashTable.find], [func@GLib.HashTable.foreach_remove], and\n+ * [func@GLib.HashTable.foreach_steal].\n@@ -135,2 +133,9 @@\n- * Returns: %TRUE if the key\/value pair should be removed from the\n- *     #GHashTable\n+ * The function is called with each key\/value pair, together with\n+ * the @user_data parameter passed to the calling function.\n+ *\n+ * The function should return true if the key\/value pair should be\n+ * selected, meaning it has been found or it should be removed from the\n+ * [struct@GLib.HashTable], depending on the calling function.\n+ *\n+ * Returns: true if the key\/value pair should be selected, and\n+ *   false otherwise\n@@ -1793,2 +1798,3 @@\n- * their keys, for example by using g_hash_table_add(). When stealing both the\n- * key and the value from such a dictionary, the value will be %NULL.\n+ * their keys, for example by using g_hash_table_add(). Before 2.82, when\n+ * stealing both the key and the value from such a dictionary, the value was\n+ * %NULL. Since 2.82, the returned value and key will be the same.\n@@ -1828,4 +1834,9 @@\n-  {\n-    *stolen_value = g_hash_table_fetch_key_or_value (hash_table->values, node_index, hash_table->have_big_values);\n-    g_hash_table_assign_key_or_value (hash_table->values, node_index, hash_table->have_big_values, NULL);\n-  }\n+    {\n+      if (stolen_key && hash_table->keys == hash_table->values)\n+        *stolen_value = *stolen_key;\n+      else\n+        {\n+          *stolen_value = g_hash_table_fetch_key_or_value (hash_table->values, node_index, hash_table->have_big_values);\n+          g_hash_table_assign_key_or_value (hash_table->values, node_index, hash_table->have_big_values, NULL);\n+        }\n+    }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/ghash.c","additions":24,"deletions":13,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gmessages.h\"\n@@ -706,0 +707,2 @@\n+  g_return_val_if_fail (hostname != NULL, NULL);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/ghostutils.c","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  guint do_encode      : 1; \/* The encoding uses the GIConv coverters *\/\n+  guint do_encode      : 1; \/* The encoding uses the GIConv converters *\/\n@@ -373,1 +373,1 @@\n- * descriptors. After calling g_io_add_watch() on a IO channel\n+ * descriptors. After calling g_io_add_watch() on an IO channel\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/giochannel.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"glib-private.h\"\n@@ -45,0 +46,4 @@\n+\/* Test that private macro G_SIGNEDNESS_OF() works as intended *\/\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (int) == 1);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (unsigned int) == 0);\n+\n@@ -80,0 +85,5 @@\n+\n+\/* It is platform-dependent whether gchar is signed or unsigned, so there\n+ * is no assertion here for it *\/\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (guchar) == 0);\n+\n@@ -98,0 +108,2 @@\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (gshort) == 1);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (gushort) == 0);\n@@ -104,0 +116,2 @@\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (gint) == 1);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (guint) == 0);\n@@ -111,0 +125,2 @@\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (glong) == 1);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (gulong) == 0);\n@@ -130,0 +146,4 @@\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (size_t) == 0);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (gsize) == 0);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (gssize) == 1);\n+\n@@ -142,0 +162,1 @@\n+\n@@ -146,0 +167,2 @@\n+\/* goffset is always signed *\/\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (goffset) == 1);\n@@ -156,0 +179,4 @@\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (gintptr) == 1);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (guintptr) == 0);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (intptr_t) == 1);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (uintptr_t) == 0);\n@@ -161,0 +188,4 @@\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (gint8) == 1);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (guint8) == 0);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (int8_t) == 1);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (uint8_t) == 0);\n@@ -166,0 +197,2 @@\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (int16_t) == 1);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (uint16_t) == 0);\n@@ -171,0 +204,4 @@\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (gint32) == 1);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (guint32) == 0);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (int32_t) == 1);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (uint32_t) == 0);\n@@ -176,0 +213,8 @@\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (gint64) == 1);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (guint64) == 0);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (int64_t) == 1);\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (uint64_t) == 0);\n+\n+\/* C11 ยง6.7, item 3 allows us to rely on this being allowed *\/\n+typedef struct Foo Foo;\n+typedef struct Foo Foo;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/glib-init.c","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -28,0 +28,10 @@\n+\/*\n+ * G_SIGNEDNESS_OF:\n+ * @T: a numeric type such as `unsigned int`\n+ *\n+ * An integer constant expression indicating whether @T is a signed type.\n+ *\n+ * Returns: 1 if @T is signed, 0 if it is unsigned\n+ *\/\n+#define G_SIGNEDNESS_OF(T) (((T) -1) <= 0)\n+\n@@ -50,1 +60,1 @@\n- * However MinGW doesn't support weak attribute properly (even if it advertises\n+ * However MinGW\/Cygwin doesn't support weak attribute properly (even if it advertises\n@@ -57,1 +67,1 @@\n-#elif defined (G_OS_UNIX) && !defined (__APPLE__) && g_macro__has_attribute (weak)\n+#elif defined (G_OS_UNIX) && !defined (__APPLE__) && !defined(__CYGWIN__) && g_macro__has_attribute (weak)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/glib-private.h","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"glib-private.h\"\n@@ -69,0 +70,1 @@\n+G_STATIC_ASSERT (G_SIGNEDNESS_OF (ssize_t) == 1);\n@@ -72,0 +74,1 @@\n+\/* It's platform-dependent whether pid_t is signed, so no assertion *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/glib-unix.c","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -986,1 +986,35 @@\n-#endif\n\\ No newline at end of file\n+#endif\n+\n+#if GLIB_VERSION_MIN_REQUIRED >= GLIB_VERSION_2_82\n+#define GLIB_DEPRECATED_IN_2_82 GLIB_DEPRECATED\n+#define GLIB_DEPRECATED_IN_2_82_FOR(f) GLIB_DEPRECATED_FOR (f)\n+#define GLIB_DEPRECATED_MACRO_IN_2_82 GLIB_DEPRECATED_MACRO\n+#define GLIB_DEPRECATED_MACRO_IN_2_82_FOR(f) GLIB_DEPRECATED_MACRO_FOR (f)\n+#define GLIB_DEPRECATED_ENUMERATOR_IN_2_82 GLIB_DEPRECATED_ENUMERATOR\n+#define GLIB_DEPRECATED_ENUMERATOR_IN_2_82_FOR(f) GLIB_DEPRECATED_ENUMERATOR_FOR (f)\n+#define GLIB_DEPRECATED_TYPE_IN_2_82 GLIB_DEPRECATED_TYPE\n+#define GLIB_DEPRECATED_TYPE_IN_2_82_FOR(f) GLIB_DEPRECATED_TYPE_FOR (f)\n+#else\n+#define GLIB_DEPRECATED_IN_2_82 _GLIB_EXTERN\n+#define GLIB_DEPRECATED_IN_2_82_FOR(f) _GLIB_EXTERN\n+#define GLIB_DEPRECATED_MACRO_IN_2_82\n+#define GLIB_DEPRECATED_MACRO_IN_2_82_FOR(f)\n+#define GLIB_DEPRECATED_ENUMERATOR_IN_2_82\n+#define GLIB_DEPRECATED_ENUMERATOR_IN_2_82_FOR(f)\n+#define GLIB_DEPRECATED_TYPE_IN_2_82\n+#define GLIB_DEPRECATED_TYPE_IN_2_82_FOR(f)\n+#endif\n+\n+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_82\n+#define GLIB_AVAILABLE_IN_2_82 GLIB_UNAVAILABLE (2, 82)\n+#define GLIB_AVAILABLE_STATIC_INLINE_IN_2_82 GLIB_UNAVAILABLE_STATIC_INLINE (2, 82)\n+#define GLIB_AVAILABLE_MACRO_IN_2_82 GLIB_UNAVAILABLE_MACRO (2, 82)\n+#define GLIB_AVAILABLE_ENUMERATOR_IN_2_82 GLIB_UNAVAILABLE_ENUMERATOR (2, 82)\n+#define GLIB_AVAILABLE_TYPE_IN_2_82 GLIB_UNAVAILABLE_TYPE (2, 82)\n+#else\n+#define GLIB_AVAILABLE_IN_2_82 _GLIB_EXTERN\n+#define GLIB_AVAILABLE_STATIC_INLINE_IN_2_82\n+#define GLIB_AVAILABLE_MACRO_IN_2_82\n+#define GLIB_AVAILABLE_ENUMERATOR_IN_2_82\n+#define GLIB_AVAILABLE_TYPE_IN_2_82\n+#endif\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/glib-visibility.h","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -864,1 +864,0 @@\n-#ifndef __GI_SCANNER__ \/* The static assert macro really confuses the introspection parser *\/\n@@ -867,0 +866,2 @@\n+\n+#ifndef __GI_SCANNER__ \/* The static assert macro really confuses the introspection parser *\/\n@@ -880,1 +881,4 @@\n-#endif \/* !__GI_SCANNER__ *\/\n+#else \/* __GI_SCANNER__ *\/\n+#define G_STATIC_ASSERT(expr) static int G_PASTE (_GStaticAssertGiScannerNoop, __LINE__) G_GNUC_UNUSED\n+#define G_STATIC_ASSERT_EXPR(expr) static int G_PASTE (_GStaticAssertGiScannerNoop, __LINE__) G_GNUC_UNUSED\n+#endif \/* __GI_SCANNER__ *\/\n@@ -1340,0 +1344,1 @@\n+#define _GLIB_AUTOPTR_DESTROY_FUNC_NAME(TypeName) glib_autoptr_destroy_##TypeName\n@@ -1359,0 +1364,2 @@\n+  static G_GNUC_UNUSED inline void _GLIB_AUTOPTR_DESTROY_FUNC_NAME(TypeName) (void *_ptr)                       \\\n+    { (cleanup) ((ParentName *) _ptr); }                                                                        \\\n@@ -1360,1 +1367,1 @@\n-    { g_list_free_full (*_l, (GDestroyNotify) (void(*)(void)) cleanup); }                                       \\\n+    { g_list_free_full (*_l, _GLIB_AUTOPTR_DESTROY_FUNC_NAME(TypeName)); }                                      \\\n@@ -1362,1 +1369,1 @@\n-    { g_slist_free_full (*_l, (GDestroyNotify) (void(*)(void)) cleanup); }                                      \\\n+    { g_slist_free_full (*_l, _GLIB_AUTOPTR_DESTROY_FUNC_NAME(TypeName)); }                                     \\\n@@ -1364,1 +1371,1 @@\n-    { if (*_q) g_queue_free_full (*_q, (GDestroyNotify) (void(*)(void)) cleanup); }                             \\\n+    { if (*_q) g_queue_free_full (*_q, _GLIB_AUTOPTR_DESTROY_FUNC_NAME(TypeName)); }                            \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gmacros.h","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -72,0 +72,4 @@\n+#ifdef HAVE_POLL_H\n+#include <poll.h>\n+#endif\n+\n@@ -192,1 +196,1 @@\n-  gint timeout;                 \/* Timeout for current iteration *\/\n+  gint64 timeout_usec; \/* Timeout for current iteration *\/\n@@ -324,4 +328,4 @@\n-             gint          max_priority,\n-gint         *timeout,\n-             GPollFD      *fds,\n-             gint          n_fds);\n+                                                 gint          max_priority,\n+                                                 gint64       *timeout_usec,\n+                                                 GPollFD      *fds,\n+                                                 gint          n_fds);\n@@ -334,1 +338,1 @@\n-                                                 int           timeout,\n+                                                 gint64        timeout_usec,\n@@ -461,1 +465,1 @@\n- * Increases the reference count on a #GMainContext object by one.\n+ * Increases the reference count on a [struct@GLib.MainContext] object by one.\n@@ -489,1 +493,2 @@\n- * Decreases the reference count on a #GMainContext object by one. If\n+ * Decreases the reference count on a [struct@GLib.MainContext] object by one.\n+ * If\n@@ -596,1 +601,1 @@\n- * Creates a new #GMainContext structure.\n+ * Creates a new [struct@GLib.MainContext] structure.\n@@ -611,1 +616,1 @@\n- * Creates a new #GMainContext structure.\n+ * Creates a new [struct@GLib.MainContext] structure.\n@@ -681,1 +686,1 @@\n- * g_main_context_get_thread_default().\n+ * [func@GLib.MainContext.get_thread_default].\n@@ -740,3 +745,3 @@\n- * changes the context returned by g_main_context_get_thread_default(),\n- * not the one returned by g_main_context_default(), so it does not affect\n- * the context used by functions like g_idle_add().\n+ * changes the context returned by [func@GLib.MainContext.get_thread_default],\n+ * not the one returned by [func@GLib.MainContext.default], so it does not\n+ * affect the context used by functions like [func@GLib.idle_add].\n@@ -745,2 +750,2 @@\n- * thread, passing it a #GMainContext which will be run by a\n- * #GMainLoop in that thread, to set a new default context for all\n+ * thread, passing it a [struct@GLib.MainContext] which will be run by a\n+ * [struct@GLib.MainLoop] in that thread, to set a new default context for all\n@@ -748,3 +753,3 @@\n- * ever call g_main_context_pop_thread_default(), assuming you want the\n- * new #GMainContext to be the default for the whole lifecycle of the\n- * thread.\n+ * ever call [method@GLib.MainContext.pop_thread_default], assuming you want\n+ * the new [struct@GLib.MainContext] to be the default for the whole lifecycle\n+ * of the thread.\n@@ -755,4 +760,5 @@\n- * the logic that needs to use the new #GMainContext inside a\n- * g_main_context_push_thread_default() \/ g_main_context_pop_thread_default()\n- * pair, otherwise threads that are re-used will end up never explicitly\n- * releasing the #GMainContext reference they hold.\n+ * the logic that needs to use the new [struct@GLib.MainContext] inside a\n+ * [method@GLib.MainContext.push_thread_default] \/\n+ * [method@GLib.MainContext.pop_thread_default] pair, otherwise threads that\n+ * are re-used will end up never explicitly releasing the\n+ * [struct@GLib.MainContext] reference they hold.\n@@ -764,2 +770,2 @@\n- * g_main_context_push_thread_default() \/\n- * g_main_context_pop_thread_default() pair, but it is up to you to\n+ * [method@GLib.MainContext.push_thread_default] \/\n+ * [method@GLib.MainContext.pop_thread_default] pair, but it is up to you to\n@@ -839,5 +845,5 @@\n- * g_main_context_ref_thread_default() to get a #GMainContext to add\n- * their #GSources to. (Note that even in single-threaded\n- * programs applications may sometimes want to temporarily push a\n- * non-default context, so it is not safe to assume that this will\n- * always return %NULL if you are running in the default thread.)\n+ * [func@GLib.MainContext.ref_thread_default] to get a\n+ * [struct@GLib.MainContext] to add their [struct@GLib.Source]s to. (Note that\n+ * even in single-threaded programs applications may sometimes want to\n+ * temporarily push a non-default context, so it is not safe to assume that\n+ * this will always return %NULL if you are running in the default thread.)\n@@ -846,1 +852,1 @@\n- * g_main_context_ref_thread_default() instead.\n+ * [func@GLib.MainContext.ref_thread_default] instead.\n@@ -868,6 +874,7 @@\n- * Gets the thread-default #GMainContext for this thread, as with\n- * g_main_context_get_thread_default(), but also adds a reference to\n- * it with g_main_context_ref(). In addition, unlike\n- * g_main_context_get_thread_default(), if the thread-default context\n- * is the global-default context, this will return that #GMainContext\n- * (with a ref added to it) rather than returning %NULL.\n+ * Gets the thread-default [struct@GLib.MainContext] for this thread, as with\n+ * [func@GLib.MainContext.get_thread_default], but also adds a reference to\n+ * it with [method@GLib.MainContext.ref]. In addition, unlike\n+ * [func@GLib.MainContext.get_thread_default], if the thread-default context\n+ * is the global-default context, this will return that\n+ * [struct@GLib.MainContext] (with a ref added to it) rather than returning\n+ * %NULL.\n@@ -876,1 +883,1 @@\n- *     with g_main_context_unref() when you are done with it.\n+ *     with [method@GLib.MainContext.unref] when you are done with it.\n@@ -897,1 +904,1 @@\n- * @struct_size: size of the #GSource structure to create.\n+ * @struct_size: size of the [struct@GLib.Source] structure to create.\n@@ -899,2 +906,2 @@\n- * Creates a new #GSource structure. The size is specified to\n- * allow creating structures derived from #GSource that contain\n+ * Creates a new [struct@GLib.Source] structure. The size is specified to\n+ * allow creating structures derived from [struct@GLib.Source] that contain\n@@ -905,1 +912,1 @@\n- * and must be added to one with g_source_attach() before it will be\n+ * and must be added to one with [method@GLib.Source.attach] before it will be\n@@ -959,2 +966,3 @@\n- * This means that at this point @source is still a valid #GSource and it is\n- * allow for the reference count to increase again until @dispose returns.\n+ * This means that at this point @source is still a valid [struct@GLib.Source]\n+ * and it is allow for the reference count to increase again until @dispose\n+ * returns.\n@@ -1239,2 +1247,2 @@\n- * Adds a #GSource to a @context so that it will be executed within\n- * that context. Remove it by calling g_source_destroy().\n+ * Adds a [struct@GLib.Source] to a @context so that it will be executed within\n+ * that context. Remove it by calling [method@GLib.Source.destroy].\n@@ -1342,1 +1350,1 @@\n- * Removes a source from its #GMainContext, if any, and mark it as\n+ * Removes a source from its [struct@GLib.MainContext], if any, and mark it as\n@@ -1347,2 +1355,2 @@\n- * This does not unref the #GSource: if you still hold a reference, use\n- * g_source_unref() to drop it.\n+ * This does not unref the [struct@GLib.Source]: if you still hold a reference,\n+ * use [method@GLib.Source.unref] to drop it.\n@@ -1351,1 +1359,1 @@\n- * the #GMainContext is running in.\n+ * the [struct@GLib.MainContext] is running in.\n@@ -1353,3 +1361,4 @@\n- * If the source is currently attached to a #GMainContext, destroying it\n- * will effectively unset the callback similar to calling g_source_set_callback().\n- * This can mean, that the data's #GDestroyNotify gets called right away.\n+ * If the source is currently attached to a [struct@GLib.MainContext],\n+ * destroying it will effectively unset the callback similar to calling\n+ * [method@GLib.Source.set_callback]. This can mean, that the data's\n+ * #GDestroyNotify gets called right away.\n@@ -1379,2 +1388,2 @@\n- * context. The reverse\n- * mapping from ID to source is done by g_main_context_find_source_by_id().\n+ * context. The reverse mapping from ID to source is done by\n+ * [method@GLib.MainContext.find_source_by_id].\n@@ -1383,3 +1392,4 @@\n- * #GMainContext instance; calling this function before g_source_attach()\n- * or after g_source_destroy() yields undefined behavior. The ID returned\n- * is unique within the #GMainContext instance passed to g_source_attach().\n+ * [struct@GLib.MainContext] instance; calling this function before\n+ * [method@GLib.Source.attach] or after [method@GLib.Source.destroy] yields\n+ * undefined behavior. The ID returned is unique within the\n+ * [struct@GLib.MainContext] instance passed to [method@GLib.Source.attach].\n@@ -1409,1 +1419,1 @@\n- * Gets the #GMainContext with which the source is associated.\n+ * Gets the [struct@GLib.MainContext] with which the source is associated.\n@@ -1412,2 +1422,2 @@\n- * that the #GMainContext it was attached to still exists (in which\n- * case it will return that #GMainContext). In particular, you can\n+ * that the [struct@GLib.MainContext] it was attached to still exists (in which\n+ * case it will return that [struct@GLib.MainContext]). In particular, you can\n@@ -1415,2 +1425,2 @@\n- * g_main_current_source(). But calling this function on a source\n- * whose #GMainContext has been destroyed is an error.\n+ * [func@GLib.main_current_source]. But calling this function on a source\n+ * whose [struct@GLib.MainContext] has been destroyed is an error.\n@@ -1439,1 +1449,1 @@\n- * this source. This is usually combined with g_source_new() to add an\n+ * this source. This is usually combined with [ctor@GLib.Source.new] to add an\n@@ -1444,2 +1454,2 @@\n- * This API is only intended to be used by implementations of #GSource.\n- * Do not call this API on a #GSource that you did not create.\n+ * This API is only intended to be used by implementations of [struct@GLib.Source].\n+ * Do not call this API on a [struct@GLib.Source] that you did not create.\n@@ -1449,1 +1459,1 @@\n- * g_source_add_unix_fd() instead of this API.\n+ * `g_source_add_unix_fd` instead of this API.\n@@ -1485,1 +1495,1 @@\n- * @fd: a #GPollFD structure previously passed to g_source_add_poll().\n+ * @fd: a #GPollFD structure previously passed to [method@GLib.Source.add_poll].\n@@ -1490,2 +1500,2 @@\n- * This API is only intended to be used by implementations of #GSource.\n- * Do not call this API on a #GSource that you did not create.\n+ * This API is only intended to be used by implementations of [struct@GLib.Source].\n+ * Do not call this API on a [struct@GLib.Source] that you did not create.\n@@ -1525,2 +1535,2 @@\n- * added to a #GMainContext, @child_source will be automatically added\n- * with the same priority, when @child_source is triggered, it will\n+ * added to a [struct@GLib.MainContext], @child_source will be automatically\n+ * added with the same priority, when @child_source is triggered, it will\n@@ -1539,2 +1549,3 @@\n- * This API is only intended to be used by implementations of #GSource.\n- * Do not call this API on a #GSource that you did not create.\n+ * This API is only intended to be used by implementations of\n+ * [struct@GLib.Source]. Do not call this API on a [struct@GLib.Source] that\n+ * you did not create.\n@@ -1598,1 +1609,1 @@\n- *     g_source_add_child_source().\n+ *     [method@GLib.Source.add_child_source].\n@@ -1680,1 +1691,1 @@\n- * g_source_set_callback_indirect() assumes\n+ * [method@GLib.Source.set_callback_indirect] assumes\n@@ -1740,1 +1751,1 @@\n- * parameter. Cast @func with G_SOURCE_FUNC() to avoid warnings about\n+ * parameter. Cast @func with [func@GLib.SOURCE_FUNC] to avoid warnings about\n@@ -1743,1 +1754,1 @@\n- * See [memory management of sources][mainloop-memory-management] for details\n+ * See [mainloop memory management](main-loop.html#memory-management-of-sources) for details\n@@ -1747,1 +1758,2 @@\n- * to the type of source you are using, such as g_idle_add() or g_timeout_add().\n+ * to the type of source you are using, such as [func@GLib.idle_add] or\n+ * [func@GLib.timeout_add].\n@@ -1753,1 +1765,1 @@\n- * Note that g_source_destroy() for a currently attached source has the effect\n+ * Note that [method@GLib.Source.destroy] for a currently attached source has the effect\n@@ -1949,1 +1961,1 @@\n- * destroyed with g_source_destroy().\n+ * destroyed with [method@GLib.Source.destroy].\n@@ -2001,1 +2013,1 @@\n- * g_source_set_ready_time().\n+ * [method@GLib.Source.set_ready_time].\n@@ -2055,1 +2067,1 @@\n- * see g_source_set_can_recurse().\n+ * see [method@GLib.Source.set_can_recurse].\n@@ -2122,1 +2134,1 @@\n- * accessing it with g_source_get_name(); that function does not copy\n+ * accessing it with [method@GLib.Source.get_name]; that function does not copy\n@@ -2126,1 +2138,1 @@\n- * Also see g_source_set_static_name().\n+ * Also see [method@GLib.Source.set_static_name].\n@@ -2142,1 +2154,1 @@\n- * A variant of g_source_set_name() that does not\n+ * A variant of [method@GLib.Source.set_name] that does not\n@@ -2160,1 +2172,1 @@\n- * name may be #NULL if it has never been set with g_source_set_name().\n+ * name may be #NULL if it has never been set with [method@GLib.Source.set_name].\n@@ -2183,1 +2195,1 @@\n- * value of g_idle_add(), g_timeout_add(), etc.\n+ * value of [func@GLib.idle_add], [func@GLib.timeout_add], etc.\n@@ -2191,1 +2203,1 @@\n- * scheduling an idle to run in another thread with g_idle_add(): the\n+ * scheduling an idle to run in another thread with [func@GLib.idle_add]: the\n@@ -2382,1 +2394,1 @@\n- * @source_id: the source ID, as returned by g_source_get_id().\n+ * @source_id: the source ID, as returned by [method@GLib.Source.get_id].\n@@ -2391,1 +2403,1 @@\n- * scheduling an idle to run in another thread with g_idle_add(): the\n+ * scheduling an idle to run in another thread with [func@GLib.idle_add]: the\n@@ -2428,1 +2440,1 @@\n- * @funcs: the @source_funcs passed to g_source_new().\n+ * @funcs: the @source_funcs passed to [ctor@GLib.Source.new].\n@@ -2526,1 +2538,1 @@\n- * use g_source_destroy() for sources added to a non-default main context.\n+ * use [method@GLib.Source.destroy] for sources added to a non-default main context.\n@@ -2528,5 +2540,6 @@\n- * The ID of a #GSource is given by g_source_get_id(), or will be\n- * returned by the functions g_source_attach(), g_idle_add(),\n- * g_idle_add_full(), g_timeout_add(), g_timeout_add_full(),\n- * g_child_watch_add(), g_child_watch_add_full(), g_io_add_watch(), and\n- * g_io_add_watch_full().\n+ * The ID of a #GSource is given by [method@GLib.Source.get_id], or will be\n+ * returned by the functions [method@GLib.Source.attach], [func@GLib.idle_add],\n+ * [func@GLib.idle_add_full], [func@GLib.timeout_add],\n+ * [func@GLib.timeout_add_full], [func@GLib.child_watch_add],\n+ * [func@GLib.child_watch_add_full], [func@GLib.io_add_watch], and\n+ * [func@GLib.io_add_watch_full].\n@@ -2539,1 +2552,1 @@\n- * scheduling an idle to run in another thread with g_idle_add(): the\n+ * scheduling an idle to run in another thread with [func@GLib.idle_add]: the\n@@ -2590,1 +2603,1 @@\n- * @funcs: The @source_funcs passed to g_source_new()\n+ * @funcs: The @source_funcs passed to [ctor@GLib.Source.new]\n@@ -2627,1 +2640,1 @@\n- * Otherwise, clear_func() is called with the ID as a parameter, and the tag is\n+ * Otherwise, @clear_func is called with the ID as a parameter, and the tag is\n@@ -2660,2 +2673,2 @@\n- * monitoring of the fd using g_source_remove_unix_fd() or\n- * g_source_modify_unix_fd().\n+ * monitoring of the fd using [method@GLib.Source.remove_unix_fd] or\n+ * [method@GLib.Source.modify_unix_fd].\n@@ -2712,1 +2725,1 @@\n- * @tag: (not nullable): the tag from g_source_add_unix_fd()\n+ * @tag: (not nullable): the tag from [method@GLib.Source.add_unix_fd]\n@@ -2717,1 +2730,1 @@\n- * @tag is the tag returned from g_source_add_unix_fd().\n+ * @tag is the tag returned from [method@GLib.Source.add_unix_fd].\n@@ -2720,1 +2733,1 @@\n- * Instead, call g_source_remove_unix_fd().\n+ * Instead, call [method@GLib.Source.remove_unix_fd].\n@@ -2753,1 +2766,1 @@\n- * @tag: (not nullable): the tag from g_source_add_unix_fd()\n+ * @tag: (not nullable): the tag from [method@GLib.Source.add_unix_fd]\n@@ -2755,1 +2768,1 @@\n- * Reverses the effect of a previous call to g_source_add_unix_fd().\n+ * Reverses the effect of a previous call to [method@GLib.Source.add_unix_fd].\n@@ -2801,1 +2814,1 @@\n- * @tag: (not nullable): the tag from g_source_add_unix_fd()\n+ * @tag: (not nullable): the tag from [method@GLib.Source.add_unix_fd]\n@@ -2840,1 +2853,1 @@\n- * You may find g_get_real_time() to be more convenient.\n+ * You may find [func@GLib.get_real_time] to be more convenient.\n@@ -2842,2 +2855,2 @@\n- * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use g_get_real_time()\n- *    instead.\n+ * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use\n+ *    [func@GLib.get_real_time] instead.\n@@ -2865,1 +2878,1 @@\n- * This call is functionally equivalent to g_get_current_time() except\n+ * This call is functionally equivalent to [func@GLib.get_current_time] except\n@@ -2870,1 +2883,1 @@\n- * wall-clock time.  g_get_monotonic_time() is probably more useful for\n+ * wall-clock time. [func@GLib.get_monotonic_time] is probably more useful for\n@@ -3045,1 +3058,1 @@\n- * g_main_context_dispatch() on any #GMainContext in the current thread.\n+ * [method@GLib.MainContext.dispatch] on any #GMainContext in the current thread.\n@@ -3047,3 +3060,3 @@\n- * called from within a callback from g_main_context_iteration()\n- * (or g_main_loop_run(), etc.) it returns 1. When called from within\n- * a callback to a recursive call to g_main_context_iteration(),\n+ * called from within a callback from [method@GLib.MainContext.iteration]\n+ * (or [method@GLib.MainLoop.run], etc.) it returns 1. When called from within\n+ * a callback to a recursive call to [method@GLib.MainContext.iteration],\n@@ -3090,1 +3103,1 @@\n- * recursive callback. This can be fixed by using g_main_depth()\n+ * recursive callback. This can be fixed by using [func@GLib.main_depth]\n@@ -3125,1 +3138,1 @@\n- * There is a temptation to use g_main_depth() to solve\n+ * There is a temptation to use [func@GLib.main_depth] to solve\n@@ -3130,1 +3143,1 @@\n- * and do nothing if g_main_depth() returns a value greater than 1.\n+ * and do nothing if [func@GLib.main_depth] returns a value greater than 1.\n@@ -3249,4 +3262,4 @@\n- * #GMainContext the #GSource is attached to are typically redundant, as the\n- * source could be destroyed immediately after this function returns. However,\n- * once a source is destroyed it cannot be un-destroyed, so this function can be\n- * used for opportunistic checks from any thread.\n+ * [struct@GLib.MainContext] the #GSource is attached to are typically\n+ * redundant, as the source could be destroyed immediately after this function\n+ * returns. However, once a source is destroyed it cannot be un-destroyed, so\n+ * this function can be used for opportunistic checks from any thread.\n@@ -3445,2 +3458,2 @@\n- * and will release ownership when g_main_context_release()\n- * is called as many times as g_main_context_acquire().\n+ * and will release ownership when [method@GLib.MainContext.release]\n+ * is called as many times as [method@GLib.MainContext.acquire].\n@@ -3449,2 +3462,3 @@\n- * can call g_main_context_prepare(), g_main_context_query(),\n- * g_main_context_check(), g_main_context_dispatch(), g_main_context_release().\n+ * can call [method@GLib.MainContext.prepare], [method@GLib.MainContext.query],\n+ * [method@GLib.MainContext.check], [method@GLib.MainContext.dispatch],\n+ * [method@GLib.MainContext.release].\n@@ -3505,2 +3519,2 @@\n- * with g_main_context_acquire(). If the context was acquired multiple\n- * times, the ownership will be released only when g_main_context_release()\n+ * with [method@GLib.MainContext.acquire]. If the context was acquired multiple\n+ * times, the ownership will be released only when [method@GLib.MainContext.release]\n@@ -3510,1 +3524,1 @@\n- * g_main_context_acquire() before you may call this function.\n+ * [method@GLib.MainContext.acquire] before you may call this function.\n@@ -3622,1 +3636,1 @@\n- * as with g_main_context_acquire(). But if another thread\n+ * as with [method@GLib.MainContext.acquire]. But if another thread\n@@ -3629,1 +3643,2 @@\n- * Deprecated: 2.58: Use g_main_context_is_owner() and separate locking instead.\n+ * Deprecated: 2.58: Use [method@GLib.MainContext.is_owner] and separate\n+ *    locking instead.\n@@ -3662,1 +3677,1 @@\n- * for polling is determined by calling g_main_context_query ().\n+ * for polling is determined by calling [method@GLib.MainContext.query].\n@@ -3665,1 +3680,1 @@\n- * g_main_context_acquire() before you may call this function.\n+ * [method@GLib.MainContext.acquire] before you may call this function.\n@@ -3688,0 +3703,39 @@\n+static inline int\n+round_timeout_to_msec (gint64 timeout_usec)\n+{\n+  \/* We need to round to milliseconds from our internal microseconds for\n+   * various external API and GPollFunc which requires milliseconds.\n+   *\n+   * However, we want to ensure a few invariants for this.\n+   *\n+   *   Return == -1 if we have no timeout specified\n+   *   Return ==  0 if we don't want to block at all\n+   *   Return  >  0 if we have any timeout to avoid spinning the CPU\n+   *\n+   * This does cause jitter if the microsecond timeout is < 1000 usec\n+   * because that is beyond our precision. However, using ppoll() instead\n+   * of poll() (when available) avoids this jitter.\n+   *\/\n+\n+  if (timeout_usec == 0)\n+    return 0;\n+\n+  if (timeout_usec > 0)\n+    {\n+      guint64 timeout_msec = (timeout_usec + 999) \/ 1000;\n+\n+      return (int) MIN (timeout_msec, G_MAXINT);\n+    }\n+\n+  return -1;\n+}\n+\n+static inline gint64\n+extend_timeout_to_usec (int timeout_msec)\n+{\n+  if (timeout_msec >= 0)\n+    return (gint64) timeout_msec * 1000;\n+\n+  return -1;\n+}\n+\n@@ -3731,1 +3785,1 @@\n-  context->timeout = -1;\n+  context->timeout_usec = -1;\n@@ -3736,1 +3790,1 @@\n-      gint source_timeout = -1;\n+      gint64 source_timeout_usec = -1;\n@@ -3754,0 +3808,1 @@\n+              int source_timeout_msec = -1;\n@@ -3760,2 +3815,4 @@\n-              result = (* prepare) (source, &source_timeout);\n-              TRACE (GLIB_MAIN_AFTER_PREPARE (source, prepare, source_timeout));\n+              result = (*prepare) (source, &source_timeout_msec);\n+              TRACE (GLIB_MAIN_AFTER_PREPARE (source, prepare, source_timeout_msec));\n+\n+              source_timeout_usec = extend_timeout_to_usec (source_timeout_msec);\n@@ -3785,1 +3842,1 @@\n-                  source_timeout = 0;\n+                  source_timeout_usec = 0;\n@@ -3788,1 +3845,2 @@\n-              else\n+              else if (source_timeout_usec < 0 ||\n+                       (source->priv->ready_time < context->time + source_timeout_usec))\n@@ -3790,7 +3848,1 @@\n-                  gint64 timeout;\n-\n-                  \/* rounding down will lead to spinning, so always round up *\/\n-                  timeout = (source->priv->ready_time - context->time + 999) \/ 1000;\n-\n-                  if (source_timeout < 0 || timeout < source_timeout)\n-                    source_timeout = MIN (timeout, G_MAXINT);\n+                  source_timeout_usec = MAX (0, source->priv->ready_time - context->time);\n@@ -3816,1 +3868,1 @@\n-    context->timeout = 0;\n+    context->timeout_usec = 0;\n@@ -3819,7 +3871,7 @@\n-      if (source_timeout >= 0)\n-  {\n-    if (context->timeout < 0)\n-      context->timeout = source_timeout;\n-    else\n-      context->timeout = MIN (context->timeout, source_timeout);\n-  }\n+      if (source_timeout_usec >= 0)\n+        {\n+          if (context->timeout_usec < 0)\n+            context->timeout_usec = source_timeout_usec;\n+          else\n+            context->timeout_usec = MIN (context->timeout_usec, source_timeout_usec);\n+        }\n@@ -3849,1 +3901,1 @@\n- * as is when calling g_main_context_check(), as this function relies\n+ * as is when calling [method@GLib.MainContext.check], as this function relies\n@@ -3853,1 +3905,1 @@\n- * g_main_context_acquire() before you may call this function.\n+ * [method@GLib.MainContext.acquire] before you may call this function.\n@@ -3862,1 +3914,1 @@\n-          gint         *timeout,\n+          gint         *timeout_msec,\n@@ -3866,0 +3918,1 @@\n+  gint64 timeout_usec;\n@@ -3873,1 +3926,1 @@\n-  n_poll = g_main_context_query_unlocked (context, max_priority, timeout, fds, n_fds);\n+  n_poll = g_main_context_query_unlocked (context, max_priority, &timeout_usec, fds, n_fds);\n@@ -3877,0 +3930,3 @@\n+  if (timeout_msec != NULL)\n+    *timeout_msec = round_timeout_to_msec (timeout_usec);\n+\n@@ -3883,1 +3939,1 @@\n-                               gint         *timeout,\n+                               gint64       *timeout_usec,\n@@ -3937,1 +3993,1 @@\n-  if (timeout)\n+  if (timeout_usec)\n@@ -3939,2 +3995,2 @@\n-      *timeout = context->timeout;\n-      if (*timeout != 0)\n+      *timeout_usec = context->timeout_usec;\n+      if (*timeout_usec != 0)\n@@ -3944,1 +4000,1 @@\n-  TRACE (GLIB_MAIN_CONTEXT_AFTER_QUERY (context, context->timeout,\n+  TRACE (GLIB_MAIN_CONTEXT_AFTER_QUERY (context, context->timeout_usec,\n@@ -3956,2 +4012,2 @@\n- *       the last call to g_main_context_query()\n- * @n_fds: return value of g_main_context_query()\n+ *       the last call to [method@GLib.MainContext.query]\n+ * @n_fds: return value of [method@GLib.MainContext.query]\n@@ -3961,1 +4017,1 @@\n- * g_main_context_query(), as this functions relies on assumptions\n+ * [method@GLib.MainContext.query], as this functions relies on assumptions\n@@ -3965,1 +4021,1 @@\n- * g_main_context_acquire() before you may call this function.\n+ * [method@GLib.MainContext.acquire] before you may call this function.\n@@ -4179,1 +4235,1 @@\n- * g_main_context_acquire() before you may call this function.\n+ * [method@GLib.MainContext.acquire] before you may call this function.\n@@ -4218,1 +4274,1 @@\n-  gint timeout;\n+  gint64 timeout_usec;\n@@ -4258,2 +4314,2 @@\n-            context, max_priority, &timeout, fds,\n-               allocated_nfds)) > allocated_nfds)\n+              context, max_priority, &timeout_usec, fds,\n+              allocated_nfds)) > allocated_nfds)\n@@ -4272,1 +4328,1 @@\n-    timeout = 0;\n+    timeout_usec = 0;\n@@ -4274,1 +4330,1 @@\n-  g_main_context_poll_unlocked (context, timeout, max_priority, fds, nfds);\n+  g_main_context_poll_unlocked (context, timeout_usec, max_priority, fds, nfds);\n@@ -4330,1 +4386,1 @@\n- * g_main_context_iteration() to return %FALSE, since the wait may\n+ * [method@GLib.MainContext.iteration] to return %FALSE, since the wait may\n@@ -4355,2 +4411,2 @@\n- * is not very important since calling g_main_loop_run() will set this to\n- * %TRUE anyway.\n+ * is not very important since calling [method@GLib.MainLoop.run] will set this\n+ * to %TRUE anyway.\n@@ -4358,1 +4414,1 @@\n- * Creates a new #GMainLoop structure.\n+ * Creates a new [struct@GLib.MainLoop] structure.\n@@ -4387,1 +4443,1 @@\n- * Increases the reference count on a #GMainLoop object by one.\n+ * Increases the reference count on a [struct@GLib.MainLoop] object by one.\n@@ -4406,1 +4462,1 @@\n- * Decreases the reference count on a #GMainLoop object by one. If\n+ * Decreases the reference count on a [struct@GLib.MainLoop] object by one. If\n@@ -4426,1 +4482,1 @@\n- * Runs a main loop until g_main_loop_quit() is called on the loop.\n+ * Runs a main loop until [method@GLib.MainLoop.quit] is called on the loop.\n@@ -4494,2 +4550,2 @@\n- * Stops a #GMainLoop from running. Any calls to g_main_loop_run()\n- * for the loop will return.\n+ * Stops a [struct@GLib.MainLoop] from running. Any calls to\n+ * [method@GLib.MainLoop.run] for the loop will return.\n@@ -4498,1 +4554,1 @@\n- * g_main_loop_quit() is called will still be executed.\n+ * [method@GLib.MainLoop.quit] is called will still be executed.\n@@ -4521,1 +4577,2 @@\n- * Checks to see if the main loop is currently being run via g_main_loop_run().\n+ * Checks to see if the main loop is currently being run via\n+ * [method@GLib.MainLoop.run].\n@@ -4538,1 +4595,1 @@\n- * Returns the #GMainContext of @loop.\n+ * Returns the [struct@GLib.MainContext] of @loop.\n@@ -4540,1 +4597,1 @@\n- * Returns: (transfer none): the #GMainContext of @loop\n+ * Returns: (transfer none): the [struct@GLib.MainContext] of @loop\n@@ -4554,1 +4611,1 @@\n-                              int           timeout,\n+                              gint64        timeout_usec,\n@@ -4567,1 +4624,1 @@\n-  if (n_fds || timeout != 0)\n+  if (n_fds || timeout_usec != 0)\n@@ -4575,3 +4632,3 @@\n-    g_print (\"polling context=%p n=%d timeout=%d\\n\",\n-       context, n_fds, timeout);\n-    poll_timer = g_timer_new ();\n+          g_print (\"polling context=%p n=%d timeout_usec=%\"G_GINT64_FORMAT\"\\n\",\n+                   context, n_fds, timeout_usec);\n+          poll_timer = g_timer_new ();\n@@ -4582,3 +4639,26 @@\n-      UNLOCK_CONTEXT (context);\n-      ret = (*poll_func) (fds, n_fds, timeout);\n-      LOCK_CONTEXT (context);\n+#if defined(HAVE_PPOLL) && defined(HAVE_POLL)\n+      if (poll_func == g_poll)\n+        {\n+          struct timespec spec;\n+          struct timespec *spec_p = NULL;\n+\n+          if (timeout_usec > -1)\n+            {\n+              spec.tv_sec = timeout_usec \/ G_USEC_PER_SEC;\n+              spec.tv_nsec = (timeout_usec % G_USEC_PER_SEC) * 1000L;\n+              spec_p = &spec;\n+            }\n+\n+          UNLOCK_CONTEXT (context);\n+          ret = ppoll ((struct pollfd *) fds, n_fds, spec_p, NULL);\n+          LOCK_CONTEXT (context);\n+        }\n+      else\n+#endif\n+        {\n+          int timeout_msec = round_timeout_to_msec (timeout_usec);\n+\n+          UNLOCK_CONTEXT (context);\n+          ret = (*poll_func) (fds, n_fds, timeout_msec);\n+          LOCK_CONTEXT (context);\n+        }\n@@ -4600,5 +4680,5 @@\n-    g_print (\"g_main_poll(%d) timeout: %d - elapsed %12.10f seconds\",\n-       n_fds,\n-       timeout,\n-       g_timer_elapsed (poll_timer, NULL));\n-    g_timer_destroy (poll_timer);\n+          g_print (\"g_main_poll(%d) timeout_usec: %\"G_GINT64_FORMAT\" - elapsed %12.10f seconds\",\n+                   n_fds,\n+                   timeout_usec,\n+                   g_timer_elapsed (poll_timer, NULL));\n+          g_timer_destroy (poll_timer);\n@@ -4638,1 +4718,1 @@\n-    } \/* if (n_fds || timeout != 0) *\/\n+    } \/* if (n_fds || timeout_usec != 0) *\/\n@@ -4648,2 +4728,2 @@\n- *      the same as the priority used for g_source_attach() to ensure that the\n- *      file descriptor is polled whenever the results may be needed.\n+ *      the same as the priority used for [method@GLib.Source.attach] to ensure\n+ *      that the file descriptor is polled whenever the results may be needed.\n@@ -4653,1 +4733,1 @@\n- * a typical event source will use g_source_add_unix_fd() instead.\n+ * a typical event source will use `g_source_add_unix_fd` instead.\n@@ -4725,1 +4805,2 @@\n- * @fd: a #GPollFD descriptor previously added with g_main_context_add_poll()\n+ * @fd: a #GPollFD descriptor previously added with\n+ *   [method@GLib.MainContext.add_poll]\n@@ -4788,1 +4869,1 @@\n- * g_get_current_time().\n+ * [func@GLib.get_current_time].\n@@ -4790,1 +4871,1 @@\n- * Deprecated: 2.28: use g_source_get_time() instead\n+ * Deprecated: 2.28: use [method@GLib.Source.get_time] instead\n@@ -4806,1 +4887,1 @@\n- * calling this function over calling g_get_monotonic_time() directly is\n+ * calling this function over calling [func@GLib.get_monotonic_time] directly is\n@@ -4811,1 +4892,1 @@\n- * other reasonable alternative otherwise.  See g_get_monotonic_time().\n+ * other reasonable alternative otherwise.  See [func@GLib.get_monotonic_time].\n@@ -4882,1 +4963,1 @@\n- * Gets the poll function set by g_main_context_set_poll_func().\n+ * Gets the poll function set by [method@GLib.MainContext.set_poll_func].\n@@ -4908,1 +4989,1 @@\n- * If @context is currently blocking in g_main_context_iteration()\n+ * If @context is currently blocking in [method@GLib.MainContext.iteration]\n@@ -4911,1 +4992,1 @@\n- * g_main_context_iteration() to return without blocking.\n+ * [method@GLib.MainContext.iteration] to return without blocking.\n@@ -4913,1 +4994,1 @@\n- * This API is useful for low-level control over #GMainContext; for\n+ * This API is useful for low-level control over [struct@GLib.MainContext]; for\n@@ -4915,1 +4996,1 @@\n- * #GMainLoop.\n+ * [struct@GLib.MainLoop].\n@@ -4956,1 +5037,1 @@\n- * ownership of this #GMainContext. This is useful to\n+ * ownership of this [struct@GLib.MainContext]. This is useful to\n@@ -5090,2 +5171,2 @@\n- * The source will not initially be associated with any #GMainContext\n- * and must be added to one with g_source_attach() before it will be\n+ * The source will not initially be associated with any [struct@GLib.MainContext]\n+ * and must be added to one with [method@GLib.Source.attach] before it will be\n@@ -5095,1 +5176,1 @@\n- * time.  See g_get_monotonic_time().\n+ * time.  See [func@GLib.get_monotonic_time].\n@@ -5112,3 +5193,3 @@\n- * The source will not initially be associated with any #GMainContext\n- * and must be added to one with g_source_attach() before it will be\n- * executed.\n+ * The source will not initially be associated with any\n+ * [struct@GLib.MainContext] and must be added to one with\n+ * [method@GLib.Source.attach] before it will be executed.\n@@ -5120,1 +5201,1 @@\n- * See g_get_monotonic_time().\n+ * See [func@GLib.get_monotonic_time].\n@@ -5169,1 +5250,2 @@\n- *   the range between %G_PRIORITY_DEFAULT and %G_PRIORITY_HIGH.\n+ *   the range between [const@GLib.PRIORITY_DEFAULT] and\n+ *   [const@GLib.PRIORITY_HIGH].\n@@ -5189,1 +5271,1 @@\n- * See [memory management of sources][mainloop-memory-management] for details\n+ * See [mainloop memory management](main-loop.html#memory-management-of-sources) for details\n@@ -5192,5 +5274,6 @@\n- * This internally creates a main loop source using g_timeout_source_new()\n- * and attaches it to the global #GMainContext using g_source_attach(), so\n- * the callback will be invoked in whichever thread is running that main\n- * context. You can do these steps manually if you need greater control or to\n- * use a custom main context.\n+ * This internally creates a main loop source using\n+ * [func@GLib.timeout_source_new] and attaches it to the global\n+ * [struct@GLib.MainContext] using [method@GLib.Source.attach], so the callback\n+ * will be invoked in whichever thread is running that main context. You can do\n+ * these steps manually if you need greater control or to use a custom main\n+ * context.\n@@ -5199,1 +5282,1 @@\n- * See g_get_monotonic_time().\n+ * See [func@GLib.get_monotonic_time].\n@@ -5221,1 +5304,1 @@\n- * priority, %G_PRIORITY_DEFAULT.\n+ * priority, [const@GLib.PRIORITY_DEFAULT].\n@@ -5223,4 +5306,4 @@\n- * The given @function is called repeatedly until it returns %G_SOURCE_REMOVE\n- * or %FALSE, at which point the timeout is automatically destroyed and the\n- * function will not be called again. The first call to the function will be\n- * at the end of the first @interval.\n+ * The given @function is called repeatedly until it returns\n+ * [const@GLib.SOURCE_REMOVE] or %FALSE, at which point the timeout is\n+ * automatically destroyed and the function will not be called again. The first\n+ * call to the function will be at the end of the first @interval.\n@@ -5234,1 +5317,1 @@\n- * See [memory management of sources][mainloop-memory-management] for details\n+ * See [mainloop memory management](main-loop.html#memory-management-of-sources) for details\n@@ -5239,1 +5322,1 @@\n- * g_timeout_add_seconds() function; this function allows for more\n+ * [func@GLib.timeout_add_seconds] function; this function allows for more\n@@ -5242,5 +5325,6 @@\n- * This internally creates a main loop source using g_timeout_source_new()\n- * and attaches it to the global #GMainContext using g_source_attach(), so\n- * the callback will be invoked in whichever thread is running that main\n- * context. You can do these steps manually if you need greater control or to\n- * use a custom main context.\n+ * This internally creates a main loop source using\n+ * [func@GLib.timeout_source_new] and attaches it to the global\n+ * [struct@GLib.MainContext] using [method@GLib.Source.attach], so the callback\n+ * will be invoked in whichever thread is running that main context. You can do\n+ * these steps manually if you need greater control or to use a custom main\n+ * context.\n@@ -5251,1 +5335,1 @@\n- * time.  See g_get_monotonic_time().\n+ * time. See [func@GLib.get_monotonic_time].\n@@ -5273,1 +5357,1 @@\n- * with the default priority, %G_PRIORITY_DEFAULT.\n+ * with the default priority, [const@GLib.PRIORITY_DEFAULT].\n@@ -5278,1 +5362,1 @@\n- * This function otherwise behaves like g_timeout_add().\n+ * This function otherwise behaves like [func@GLib.timeout_add].\n@@ -5295,1 +5379,2 @@\n- *   the range between %G_PRIORITY_DEFAULT and %G_PRIORITY_HIGH.\n+ *   the range between [const@GLib.PRIORITY_DEFAULT] and\n+ *   [const@GLib.PRIORITY_HIGH].\n@@ -5303,1 +5388,1 @@\n- * The function is called repeatedly until it returns %G_SOURCE_REMOVE\n+ * The function is called repeatedly until it returns [const@GLib.SOURCE_REMOVE]\n@@ -5307,7 +5392,7 @@\n- * Unlike g_timeout_add(), this function operates at whole second granularity.\n- * The initial starting point of the timer is determined by the implementation\n- * and the implementation is expected to group multiple timers together so that\n- * they fire all at the same time. To allow this grouping, the @interval to the\n- * first timer is rounded and can deviate up to one second from the specified\n- * interval. Subsequent timer iterations will generally run at the specified\n- * interval.\n+ * Unlike [func@GLib.timeout_add], this function operates at whole second\n+ * granularity. The initial starting point of the timer is determined by the\n+ * implementation and the implementation is expected to group multiple timers\n+ * together so that they fire all at the same time. To allow this grouping, the\n+ * @interval to the first timer is rounded and can deviate up to one second\n+ * from the specified interval. Subsequent timer iterations will generally run\n+ * at the specified interval.\n@@ -5320,1 +5405,1 @@\n- * See [memory management of sources][mainloop-memory-management] for details\n+ * See [mainloop memory management](main-loop.html#memory-management-of-sources) for details\n@@ -5323,2 +5408,2 @@\n- * If you want timing more precise than whole seconds, use g_timeout_add()\n- * instead.\n+ * If you want timing more precise than whole seconds, use\n+ * [func@GLib.timeout_add] instead.\n@@ -5329,1 +5414,2 @@\n- * use of g_timeout_add_seconds() is preferred over g_timeout_add().\n+ * use of [func@GLib.timeout_add_seconds] is preferred over\n+ * [func@GLib.timeout_add].\n@@ -5332,3 +5418,3 @@\n- * g_timeout_source_new_seconds() and attaches it to the main loop context\n- * using g_source_attach(). You can do these steps manually if you need\n- * greater control.\n+ * [func@GLib.timeout_source_new_seconds] and attaches it to the main loop\n+ * context using [method@GLib.Source.attach]. You can do these steps manually\n+ * if you need greater control.\n@@ -5339,1 +5425,1 @@\n- * time.  See g_get_monotonic_time().\n+ * time. See [func@GLib.get_monotonic_time].\n@@ -5362,1 +5448,1 @@\n- * priority, %G_PRIORITY_DEFAULT.\n+ * priority, [const@GLib.PRIORITY_DEFAULT].\n@@ -5364,1 +5450,1 @@\n- * The function is called repeatedly until it returns %G_SOURCE_REMOVE\n+ * The function is called repeatedly until it returns [const@GLib.SOURCE_REMOVE]\n@@ -5369,3 +5455,3 @@\n- * g_timeout_source_new_seconds() and attaches it to the main loop context\n- * using g_source_attach(). You can do these steps manually if you need\n- * greater control. Also see g_timeout_add_seconds_full().\n+ * [func@GLib.timeout_source_new_seconds] and attaches it to the main loop context\n+ * using [method@GLib.Source.attach]. You can do these steps manually if you need\n+ * greater control. Also see [func@GLib.timeout_add_seconds_full].\n@@ -5377,1 +5463,1 @@\n- * you may want to use g_timeout_add() instead.\n+ * you may want to use [func@GLib.timeout_add] instead.\n@@ -5379,1 +5465,1 @@\n- * See [memory management of sources][mainloop-memory-management] for details\n+ * See [mainloop memory management](main-loop.html#memory-management-of-sources) for details\n@@ -5383,1 +5469,1 @@\n- * time.  See g_get_monotonic_time().\n+ * time. See [func@GLib.get_monotonic_time].\n@@ -5405,1 +5491,2 @@\n- * This function behaves like g_timeout_add_once() but with a range in seconds.\n+ * This function behaves like [func@GLib.timeout_add_once] but with a range in\n+ * seconds.\n@@ -5680,0 +5767,3 @@\n+#endif\n+#ifdef SA_ONSTACK\n+      action.sa_flags |= SA_ONSTACK;\n@@ -5968,3 +6058,3 @@\n- * The source will not initially be associated with any #GMainContext\n- * and must be added to one with g_source_attach() before it will be\n- * executed.\n+ * The source will not initially be associated with any\n+ * [struct@GLib.MainContext] and must be added to one with\n+ * [method@GLib.Source.attach] before it will be executed.\n@@ -5976,1 +6066,1 @@\n- * (see g_spawn_close_pid()) @pid must not be closed while the\n+ * (see [func@GLib.spawn_close_pid]) @pid must not be closed while the\n@@ -5978,1 +6068,1 @@\n- * g_spawn_close_pid() in the callback function for the source.\n+ * [func@GLib.spawn_close_pid] in the callback function for the source.\n@@ -5993,2 +6083,2 @@\n- *   associated #GMainContext is acquired.\n- * * Before 2.78, even after destroying the #GSource, you could not\n+ *   associated [struct@GLib.MainContext] is acquired.\n+ * * Before 2.78, even after destroying the [struct@GLib.Source], you could not\n@@ -6084,1 +6174,2 @@\n- *   range between %G_PRIORITY_DEFAULT_IDLE and %G_PRIORITY_HIGH_IDLE.\n+ *   range between [const@GLib.PRIORITY_DEFAULT_IDLE] and\n+ *   [const@GLib.PRIORITY_HIGH_IDLE].\n@@ -6094,3 +6185,4 @@\n- * If you obtain @pid from g_spawn_async() or g_spawn_async_with_pipes()\n- * you will need to pass %G_SPAWN_DO_NOT_REAP_CHILD as flag to\n- * the spawn function for the child watching to work.\n+ * If you obtain @pid from [func@GLib.spawn_async] or\n+ * [func@GLib.spawn_async_with_pipes] you will need to pass\n+ * %G_SPAWN_DO_NOT_REAP_CHILD as flag to the spawn function for the child\n+ * watching to work.\n@@ -6098,1 +6190,1 @@\n- * In many programs, you will want to call g_spawn_check_wait_status()\n+ * In many programs, you will want to call [func@GLib.spawn_check_wait_status]\n@@ -6103,2 +6195,2 @@\n- * (see g_spawn_close_pid()) @pid must not be closed while the source\n- * is still active.  Typically, you should invoke g_spawn_close_pid()\n+ * (see [func@GLib.spawn_close_pid]) @pid must not be closed while the source\n+ * is still active.  Typically, you should invoke [func@GLib.spawn_close_pid]\n@@ -6109,1 +6201,1 @@\n- * g_child_watch_source_new() apply to this function.\n+ * [func@GLib.child_watch_source_new] apply to this function.\n@@ -6112,2 +6204,2 @@\n- * g_child_watch_source_new() and attaches it to the main loop context\n- * using g_source_attach(). You can do these steps manually if you\n+ * [func@GLib.child_watch_source_new] and attaches it to the main loop context\n+ * using [method@GLib.Source.attach]. You can do these steps manually if you\n@@ -6156,1 +6248,1 @@\n- * exits, at a default priority, %G_PRIORITY_DEFAULT.\n+ * exits, at a default priority, [const@GLib.PRIORITY_DEFAULT].\n@@ -6158,3 +6250,4 @@\n- * If you obtain @pid from g_spawn_async() or g_spawn_async_with_pipes()\n- * you will need to pass %G_SPAWN_DO_NOT_REAP_CHILD as flag to\n- * the spawn function for the child watching to work.\n+ * If you obtain @pid from [func@GLib.spawn_async] or\n+ * [func@GLib.spawn_async_with_pipes] you will need to pass\n+ * %G_SPAWN_DO_NOT_REAP_CHILD as flag to the spawn function for the child\n+ * watching to work.\n@@ -6163,1 +6256,1 @@\n- * (see g_spawn_close_pid()) @pid must not be closed while the\n+ * (see [func@GLib.spawn_close_pid]) @pid must not be closed while the\n@@ -6165,1 +6258,1 @@\n- * g_spawn_close_pid() in the callback function for the source.\n+ * [func@GLib.spawn_close_pid] in the callback function for the source.\n@@ -6169,1 +6262,1 @@\n- * g_child_watch_source_new() apply to this function.\n+ * [func@GLib.child_watch_source_new] apply to this function.\n@@ -6172,2 +6265,2 @@\n- * g_child_watch_source_new() and attaches it to the main loop context\n- * using g_source_attach(). You can do these steps manually if you\n+ * [func@GLib.child_watch_source_new] and attaches it to the main loop context\n+ * using [method@GLib.Source.attach]. You can do these steps manually if you\n@@ -6261,5 +6354,6 @@\n- * The source will not initially be associated with any #GMainContext\n- * and must be added to one with g_source_attach() before it will be\n- * executed. Note that the default priority for idle sources is\n- * %G_PRIORITY_DEFAULT_IDLE, as compared to other sources which\n- * have a default priority of %G_PRIORITY_DEFAULT.\n+ * The source will not initially be associated with any\n+ * [struct@GLib.MainContext] and must be added to one with\n+ * [method@GLib.Source.attach] before it will be executed. Note that the\n+ * default priority for idle sources is [const@GLib.PRIORITY_DEFAULT_IDLE], as\n+ * compared to other sources which have a default priority of\n+ * [const@GLib.PRIORITY_DEFAULT].\n@@ -6305,1 +6399,2 @@\n- *   range between %G_PRIORITY_DEFAULT_IDLE and %G_PRIORITY_HIGH_IDLE.\n+ *   range between [const@GLib.PRIORITY_DEFAULT_IDLE] and\n+ *   [const@GLib.PRIORITY_HIGH_IDLE].\n@@ -6313,1 +6408,1 @@\n- * If the function returns %G_SOURCE_REMOVE or %FALSE it is automatically\n+ * If the function returns [const@GLib.SOURCE_REMOVE] or %FALSE it is automatically\n@@ -6316,1 +6411,1 @@\n- * See [memory management of sources][mainloop-memory-management] for details\n+ * See [mainloop memory management](main-loop.html#memory-management-of-sources) for details\n@@ -6319,5 +6414,5 @@\n- * This internally creates a main loop source using g_idle_source_new()\n- * and attaches it to the global #GMainContext using g_source_attach(), so\n- * the callback will be invoked in whichever thread is running that main\n- * context. You can do these steps manually if you need greater control or to\n- * use a custom main context.\n+ * This internally creates a main loop source using [func@GLib.idle_source_new]\n+ * and attaches it to the global [struct@GLib.MainContext] using\n+ * [method@GLib.Source.attach], so the callback will be invoked in whichever\n+ * thread is running that main context. You can do these steps manually if you\n+ * need greater control or to use a custom main context.\n@@ -6343,1 +6438,1 @@\n- * default idle priority, %G_PRIORITY_DEFAULT_IDLE.  If the function\n+ * default idle priority, [const@GLib.PRIORITY_DEFAULT_IDLE].  If the function\n@@ -6347,1 +6442,1 @@\n- * See [memory management of sources][mainloop-memory-management] for details\n+ * See [mainloop memory management](main-loop.html#memory-management-of-sources) for details\n@@ -6350,5 +6445,5 @@\n- * This internally creates a main loop source using g_idle_source_new()\n- * and attaches it to the global #GMainContext using g_source_attach(), so\n- * the callback will be invoked in whichever thread is running that main\n- * context. You can do these steps manually if you need greater control or to\n- * use a custom main context.\n+ * This internally creates a main loop source using [func@GLib.idle_source_new]\n+ * and attaches it to the global [struct@GLib.MainContext] using\n+ * [method@GLib.Source.attach], so the callback will be invoked in whichever\n+ * thread is running that main context. You can do these steps manually if you\n+ * need greater control or to use a custom main context.\n@@ -6372,1 +6467,1 @@\n- * default idle priority, %G_PRIORITY_DEFAULT_IDLE.\n+ * default idle priority, [const@GLib.PRIORITY_DEFAULT_IDLE].\n@@ -6377,1 +6472,1 @@\n- * This function otherwise behaves like g_idle_add().\n+ * This function otherwise behaves like [func@GLib.idle_add].\n@@ -6414,2 +6509,2 @@\n- * If @context is %NULL then the global-default main context - as\n- * returned by g_main_context_default() - is used.\n+ * If @context is %NULL then the global-default main context โ as\n+ * returned by [func@GLib.MainContext.default] โ is used.\n@@ -6419,2 +6514,2 @@\n- * of the current thread and g_main_context_acquire() succeeds, then\n- * @function is called and g_main_context_release() is called\n+ * of the current thread and [method@GLib.MainContext.acquire] succeeds, then\n+ * @function is called and [method@GLib.MainContext.release] is called\n@@ -6425,1 +6520,1 @@\n- * thread).  The idle source is attached with %G_PRIORITY_DEFAULT\n+ * thread).  The idle source is attached with [const@GLib.PRIORITY_DEFAULT]\n@@ -6427,1 +6522,1 @@\n- * g_main_context_invoke_full().\n+ * [method@GLib.MainContext.invoke_full].\n@@ -6457,1 +6552,1 @@\n- * This function is the same as g_main_context_invoke() except that it\n+ * This function is the same as [method@GLib.MainContext.invoke] except that it\n@@ -6566,1 +6661,1 @@\n- * โstealsโ the reference). This is very similar to g_steal_pointer(),\n+ * โstealsโ the reference). This is very similar to [func@GLib.steal_pointer],\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gmain.c","additions":424,"deletions":329,"binary":false,"changes":753,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n- * Flags to pass to g_main_context_new_with_flags() which affect the behaviour\n- * of a #GMainContext.\n+ * Flags to pass to [ctor@GLib.MainContext.new_with_flags] which affect the\n+ * behaviour of a [struct@GLib.MainContext].\n@@ -124,5 +124,6 @@\n- *     connected to a callback using g_source_set_callback(). The @dispatch\n- *     function should call the callback function with @user_data and whatever\n- *     additional parameters are needed for this type of event source. The\n- *     return value of the @dispatch function should be %G_SOURCE_REMOVE if the\n- *     source should be removed or %G_SOURCE_CONTINUE to keep it.\n+ *     connected to a callback using [method@GLib.Source.set_callback]. The\n+ *     @dispatch function should call the callback function with @user_data and\n+ *     whatever additional parameters are needed for this type of event source.\n+ *     The return value of the @dispatch function should be\n+ *     [const@GLib.SOURCE_REMOVE] if the source should be removed or\n+ *     [const@GLib.SOURCE_CONTINUE] to keep it.\n@@ -131,2 +132,3 @@\n- *     from its #GMainContext, but it will still have its final reference count,\n- *     so methods can be called on it from within this function.\n+ *     from its [struct@GLib.MainContext], but it will still have its final\n+ *     reference count, so methods can be called on it from within this\n+ *     function.\n@@ -185,2 +187,3 @@\n- * Specifies the type of function passed to g_timeout_add(),\n- * g_timeout_add_full(), g_idle_add(), and g_idle_add_full().\n+ * Specifies the type of function passed to [func@GLib.timeout_add],\n+ * [func@GLib.timeout_add_full], [func@GLib.idle_add], and\n+ * [func@GLib.idle_add_full].\n@@ -188,3 +191,3 @@\n- * When calling g_source_set_callback(), you may need to cast a function of a\n- * different type to this type. Use G_SOURCE_FUNC() to avoid warnings about\n- * incompatible function types.\n+ * When calling [method@GLib.Source.set_callback], you may need to cast a\n+ * function of a different type to this type. Use [func@GLib.SOURCE_FUNC] to\n+ * avoid warnings about incompatible function types.\n@@ -192,2 +195,3 @@\n- * Returns: %FALSE if the source should be removed. %G_SOURCE_CONTINUE and\n- * %G_SOURCE_REMOVE are more memorable names for the return value.\n+ * Returns: %FALSE if the source should be removed.\n+ * [const@GLib.SOURCE_CONTINUE] and [const@GLib.SOURCE_REMOVE] are more\n+ * memorable names for the return value.\n@@ -205,1 +209,1 @@\n- * See: g_idle_add_once(), g_timeout_add_once()\n+ * See: [func@GLib.idle_add_once], [func@GLib.timeout_add_once]\n@@ -215,3 +219,3 @@\n- * Cast a function pointer to a #GSourceFunc, suppressing warnings from GCC 8\n- * onwards with `-Wextra` or `-Wcast-function-type` enabled about the function\n- * types being incompatible.\n+ * Cast a function pointer to a [callback@GLib.SourceFunc], suppressing\n+ * warnings from GCC 8 onwards with `-Wextra` or `-Wcast-function-type` enabled\n+ * about the function types being incompatible.\n@@ -220,4 +224,5 @@\n- * g_child_watch_source_new() is #GChildWatchFunc, which accepts more arguments\n- * than #GSourceFunc. Casting the function with `(GSourceFunc)` to call\n- * g_source_set_callback() will trigger a warning, even though it will be cast\n- * back to the correct type before it is called by the source.\n+ * [func@GLib.child_watch_source_new] is #GChildWatchFunc, which accepts more\n+ * arguments than [callback@GLib.SourceFunc]. Casting the function with\n+ * `(GSourceFunc)` to call [method@GLib.Source.set_callback] will trigger a\n+ * warning, even though it will be cast back to the correct type before it is\n+ * called by the source.\n@@ -234,1 +239,1 @@\n- * @user_data: user data passed to g_child_watch_add()\n+ * @user_data: user data passed to [func@GLib.child_watch_add]\n@@ -239,2 +244,2 @@\n- * To interpret @wait_status, see the documentation\n- * for g_spawn_check_wait_status(). In particular,\n+ * To interpret @wait_status, see the documentation for\n+ * [func@GLib.spawn_check_wait_status]. In particular,\n@@ -253,2 +258,2 @@\n- * Dispose function for @source. See g_source_set_dispose_function() for\n- * details.\n+ * Dispose function for @source. See [method@GLib.Source.set_dispose_function]\n+ * for details.\n@@ -304,0 +309,89 @@\n+\/**\n+ * GSourceFuncsPrepareFunc:\n+ * @source: The #GSource\n+ * @timeout_: (out) (optional): the maximum timeout (in milliseconds) which should be passed to the poll call\n+ *\n+ * Checks the source for readiness.\n+ *\n+ * Called before all the file descriptors are polled. If the\n+ * source can determine that it is ready here (without waiting for the\n+ * results of the poll call) it should return %TRUE. It can also return\n+ * a @timeout_ value which should be the maximum timeout (in milliseconds)\n+ * which should be passed to the poll call. The actual timeout used will\n+ * be `-1` if all sources returned `-1`, or it will be the minimum of all\n+ * the @timeout_ values returned which were greater than or equal to `0`.\n+ * If the prepare function returns a timeout and the source also has a\n+ * ready time set, then the lower of the two will be used.\n+ *\n+ * Since 2.36 this may be `NULL`, in which case the effect is as if the\n+ * function always returns `FALSE` with a timeout of `-1`.\n+ *\n+ * Returns: %TRUE if the source is ready, %FALSE otherwise\n+ *\n+ * Since: 2.82\n+ *\/\n+typedef gboolean (*GSourceFuncsPrepareFunc) (GSource *source,\n+                                             gint    *timeout_);\n+\n+\/**\n+ * GSourceFuncsCheckFunc:\n+ * @source: The #GSource\n+ *\n+ * Checks if the source is ready to be dispatched.\n+ *\n+ * Called after all the file descriptors are polled. The source\n+ * should return %TRUE if it is ready to be dispatched. Note that some\n+ * time may have passed since the previous prepare function was called,\n+ * so the source should be checked again here.\n+ *\n+ * Since 2.36 this may be `NULL`, in which case the effect is\n+ * as if the function always returns `FALSE`.\n+ *\n+ * Returns: %TRUE if ready to be dispatched, %FALSE otherwise\n+ *\n+ * Since: 2.82\n+ *\/\n+typedef gboolean (*GSourceFuncsCheckFunc) (GSource *source);\n+\n+\/**\n+ * GSourceFuncsDispatchFunc:\n+ * @source: The #GSource\n+ * @callback: (nullable): The #GSourceFunc to call\n+ * @user_data: (nullable): data to pass to @callback\n+ *\n+ * Dispatches the source callback.\n+ *\n+ * Called to dispatch the event source, after it has returned\n+ * `TRUE` in either its prepare or its check function, or if a ready time\n+ * has been reached. The dispatch function receives a callback function and\n+ * user data. The callback function may be `NULL` if the source was never\n+ * connected to a callback using [method@GLib.Source.set_callback]. The dispatch\n+ * function should call the callback function with @user_data and whatever\n+ * additional parameters are needed for this type of event source. The\n+ * return value of the dispatch function should be [const@GLib.SOURCE_REMOVE]\n+ * if the source should be removed or [const@GLib.SOURCE_CONTINUE] to keep it.\n+ *\n+ * Returns: [const@GLib.SOURCE_REMOVE] if the source should be removed,\n+ *   [const@GLib.SOURCE_CONTINUE] otherwise.\n+ *\n+ * Since: 2.82\n+ *\/\n+typedef gboolean (*GSourceFuncsDispatchFunc) (GSource     *source,\n+                                              GSourceFunc  callback,\n+                                              gpointer     user_data);\n+\n+\/**\n+ * GSourceFuncsFinalizeFunc:\n+ * @source: The #GSource\n+ *\n+ * Finalizes the source.\n+ *\n+ * Called when the source is finalized. At this point, the source\n+ * will have been destroyed, had its callback cleared, and have been removed\n+ * from its [type@GLib.MainContext], but it will still have its final reference\n+ * count, so methods can be called on it from within this function.\n+ *\n+ * Since: 2.82\n+ *\/\n+typedef void (*GSourceFuncsFinalizeFunc) (GSource *source);\n+\n@@ -306,7 +400,4 @@\n-  gboolean (*prepare)  (GSource    *source,\n-                        gint       *timeout_);\/* Can be NULL *\/\n-  gboolean (*check)    (GSource    *source);\/* Can be NULL *\/\n-  gboolean (*dispatch) (GSource    *source,\n-                        GSourceFunc callback,\n-                        gpointer    user_data);\n-  void     (*finalize) (GSource    *source); \/* Can be NULL *\/\n+  GSourceFuncsPrepareFunc prepare; \/* Can be NULL *\/\n+  GSourceFuncsCheckFunc check;     \/* Can be NULL *\/\n+  GSourceFuncsDispatchFunc dispatch;\n+  GSourceFuncsFinalizeFunc finalize; \/* Can be NULL *\/\n@@ -337,1 +428,1 @@\n- * with g_timeout_add(). In GDK this priority is used for events\n+ * with [func@GLib.timeout_add]. In GDK this priority is used for events\n@@ -360,1 +451,1 @@\n- * g_idle_add().\n+ * [func@GLib.idle_add].\n@@ -376,2 +467,2 @@\n- * Use this macro as the return value of a #GSourceFunc to remove\n- * the #GSource from the main loop.\n+ * Use this macro as the return value of a [callback@GLib.SourceFunc] to remove\n+ * the [struct@GLib.Source] from the main loop.\n@@ -386,2 +477,2 @@\n- * Use this macro as the return value of a #GSourceFunc to leave\n- * the #GSource in the main loop.\n+ * Use this macro as the return value of a [callback@GLib.SourceFunc] to leave\n+ * the [struct@GLib.Source] in the main loop.\n@@ -505,4 +596,4 @@\n- * thread, using g_main_context_push_thread_default(), and return a new\n- * #GMainContextPusher. Pop with g_main_context_pusher_free(). Using\n- * g_main_context_pop_thread_default() on @main_context while a\n- * #GMainContextPusher exists for it can lead to undefined behaviour.\n+ * thread, using [method@GLib.MainContext.push_thread_default], and return a\n+ * new [alias@GLib.MainContextPusher]. Pop with g_main_context_pusher_free().\n+ * Using [method@GLib.MainContext.pop_thread_default] on @main_context while a\n+ * [alias@GLib.MainContextPusher] exists for it can lead to undefined behaviour.\n@@ -510,2 +601,2 @@\n- * Using two #GMainContextPushers in the same scope is not allowed, as it leads\n- * to an undefined pop order.\n+ * Using two [alias@GLib.MainContextPusher]s in the same scope is not allowed,\n+ * as it leads to an undefined pop order.\n@@ -562,2 +653,2 @@\n- * This will pop the #GMainContext as the current thread-default main context,\n- * but will not call g_main_context_unref() on it.\n+ * This will pop the [struct@GLib.MainContext] as the current thread-default\n+ * main context, but will not call [method@GLib.MainContext.unref] on it.\n@@ -752,4 +843,4 @@\n- * Specifies the type of function passed to g_clear_handle_id().\n- * The implementation is expected to free the resource identified\n- * by @handle_id; for instance, if @handle_id is a #GSource ID,\n- * g_source_remove() can be used.\n+ * Specifies the type of function passed to [func@GLib.clear_handle_id] The\n+ * implementation is expected to free the resource identified by @handle_id;\n+ * for instance, if @handle_id is a [struct@GLib.Source] ID,\n+ * [func@GLib.Source.remove] can be used.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gmain.h","additions":145,"deletions":54,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n- * Returns: the contents of @file, or %NULL.\n+ * Returns: (transfer none) (nullable): the contents of @file, or %NULL.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gmappedfile.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n- * @destroy: a function to which a gpointer can be passed, to destroy *@pp\n+ * @destroy: a function to which a gpointer can be passed, to destroy `*pp`\n@@ -260,3 +260,26 @@\n- * compatible with being called as `GDestroyNotify` using the standard calling\n- * convention for the platform that GLib was compiled for; otherwise the program\n- * will experience undefined behaviour.\n+ * compatible with being called as [callback@GLib.DestroyNotify] using the\n+ * standard calling convention for the platform that GLib was compiled for;\n+ * otherwise the program will experience undefined behaviour.\n+ *\n+ * Examples of this kind of undefined behaviour include using many Windows Win32\n+ * APIs, as well as many if not all OpenGL and Vulkan calls on 32-bit Windows,\n+ * which typically use the `__stdcall` calling convention rather than the\n+ * `__cdecl` calling convention.\n+ *\n+ * The affected functions can be used by wrapping them in a\n+ * [callback@GLib.DestroyNotify] that is declared with the standard calling\n+ * convention:\n+ *\n+ * ```c\n+ * \/\/ Wrapper needed to avoid mismatched calling conventions on Windows\n+ * static void\n+ * destroy_sync (void *sync)\n+ * {\n+ *   glDeleteSync (sync);\n+ * }\n+ *\n+ * \/\/ โฆ\n+ *\n+ * g_clear_pointer (&sync, destroy_sync);\n+ * ```\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gmem.c","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#if defined(__linux__) && !defined(__BIONIC__)\n+#if defined(__linux__) && !defined(__ANDROID__)\n@@ -71,1 +71,1 @@\n-#if defined(__linux__) && !defined(__BIONIC__)\n+#if defined(__linux__) && !defined(__ANDROID__)\n@@ -1423,1 +1423,1 @@\n-  gint info_size = sizeof (FILE_NAME_INFO) + sizeof (WCHAR) * MAX_PATH;\n+  size_t info_size = sizeof (FILE_NAME_INFO) + sizeof (WCHAR) * MAX_PATH;\n@@ -1425,1 +1425,1 @@\n-  gint length;\n+  size_t length;\n@@ -1521,1 +1521,2 @@\n- * non-nul-terminated UTF-8 strings can be passed with their correct length.\n+ * non-nul-terminated UTF-8 strings can be passed with their correct length,\n+ * with the exception of `\"GLIB_DOMAIN\"` which was only fixed with GLib 2.82.3.\n@@ -2056,1 +2057,1 @@\n-#if defined(__linux__) && !defined(__BIONIC__)\n+#if defined(__linux__) && !defined(__ANDROID__)\n@@ -2101,1 +2102,1 @@\n-#if defined(__linux__) && !defined(__BIONIC__)\n+#if defined(__linux__) && !defined(__ANDROID__)\n@@ -2353,1 +2354,1 @@\n-#if defined(__linux__) && !defined(__BIONIC__) && defined(HAVE_MKOSTEMP) && defined(O_CLOEXEC)\n+#if defined(__linux__) && !defined(__ANDROID__) && defined(HAVE_MKOSTEMP) && defined(O_CLOEXEC)\n@@ -2627,0 +2628,1 @@\n+          fields[0].length < 0 &&\n@@ -2630,0 +2632,40 @@\n+#ifndef HAVE_MEMMEM\n+\/\/ memmem() is a GNU extension so if it's not available we'll need\n+\/\/ our own implementation here. Thanks C.\n+static void *\n+my_memmem (const void *haystack,\n+           size_t      haystacklen,\n+           const void *needle,\n+           size_t      needlelen)\n+{\n+  const guint8 *cur, *end;\n+\n+  if (needlelen > haystacklen)\n+    return NULL;\n+  if (needlelen == 0)\n+    return (void *) haystack;\n+\n+  cur = haystack;\n+  end = cur + haystacklen - needlelen;\n+\n+  for (; cur <= end; cur++)\n+    {\n+      if (memcmp (cur, needle, needlelen) == 0)\n+        return (void *) cur;\n+    }\n+\n+  return NULL;\n+}\n+#else\n+#define my_memmem memmem\n+#endif\n+\n+static void *\n+memmem_with_end_pointer (const void *haystack,\n+                         const void *haystack_end,\n+                         const void *needle,\n+                         size_t      needle_len)\n+{\n+  return my_memmem (haystack, (const char *) haystack_end - (const char *) haystack, needle, needle_len);\n+}\n+\n@@ -2632,1 +2674,2 @@\n-              const char  *log_domain)\n+              const char  *log_domain,\n+              gsize        log_domain_length)\n@@ -2634,4 +2677,3 @@\n-  guint len;\n-  const gchar *found;\n-\n-  len = strlen (log_domain);\n+  const gchar *found = domains;\n+  gsize domains_length = strlen (domains);\n+  const gchar *domains_end = domains + domains_length;\n@@ -2639,2 +2681,2 @@\n-  for (found = strstr (domains, log_domain); found;\n-       found = strstr (found + 1, log_domain))\n+  for (found = memmem_with_end_pointer (domains, domains_end, log_domain, log_domain_length); found;\n+       found = memmem_with_end_pointer (found + 1, domains_end, log_domain, log_domain_length))\n@@ -2643,1 +2685,1 @@\n-          && (found[len] == 0 || found[len] == ' '))\n+          && (found[log_domain_length] == 0 || found[log_domain_length] == ' '))\n@@ -2650,0 +2692,4 @@\n+#ifdef my_memmem\n+#undef my_memmem\n+#endif\n+\n@@ -2700,0 +2746,1 @@\n+      gsize log_domain_length;\n@@ -2723,0 +2770,4 @@\n+                  if (fields[i].length < 0)\n+                    log_domain_length = strlen (fields[i].value);\n+                  else\n+                    log_domain_length = fields[i].length;\n@@ -2727,0 +2778,4 @@\n+      else\n+        {\n+          log_domain_length = strlen (log_domain);\n+        }\n@@ -2729,1 +2784,1 @@\n-          (log_domain == NULL || !domain_found (g_log_global.domains, log_domain)))\n+          (log_domain == NULL || !domain_found (g_log_global.domains, log_domain, log_domain_length)))\n@@ -3261,1 +3316,1 @@\n-    \/* Largest char we escape is 0x0a, so we don't have to worry\n+    \/* Largest char we escape is 0x9f, so we don't have to worry\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gmessages.c","additions":73,"deletions":18,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -803,2 +803,4 @@\n- * g_node_traverse() and g_node_find(). The different orders are\n- * illustrated here:\n+ * g_node_traverse() and g_node_find().\n+ *\n+ * The different orders are illustrated here:\n+ *\n@@ -806,1 +808,6 @@\n- *   ![](Sorted_binary_tree_inorder.svg)\n+ *   <picture>\n+ *     <source srcset=\"Sorted_binary_tree_inorder-dark.svg\"\n+ *      media=\"(prefers-color-scheme: dark)\">\n+ *     <img src=\"Sorted_binary_tree_inorder.svg\"\n+ *      alt=\"Sorted binary tree, in-order traversal\">\n+ *   <\/picture>\n@@ -808,1 +815,6 @@\n- *   ![](Sorted_binary_tree_preorder.svg)\n+ *   <picture>\n+ *     <source srcset=\"Sorted_binary_tree_preorder-dark.svg\"\n+ *      media=\"(prefers-color-scheme: dark)\">\n+ *     <img src=\"Sorted_binary_tree_preorder.svg\"\n+ *      alt=\"Sorted binary tree, pre-order traversal\">\n+ *   <\/picture>\n@@ -810,1 +822,6 @@\n- *   ![](Sorted_binary_tree_postorder.svg)\n+ *   <picture>\n+ *     <source srcset=\"Sorted_binary_tree_postorder-dark.svg\"\n+ *      media=\"(prefers-color-scheme: dark)\">\n+ *     <img src=\"Sorted_binary_tree_postorder.svg\"\n+ *      alt=\"Sorted binary tree, post-order traversal\">\n+ *   <\/picture>\n@@ -812,1 +829,6 @@\n- *   ![](Sorted_binary_tree_breadth-first_traversal.svg)\n+ *   <picture>\n+ *     <source srcset=\"Sorted_binary_tree_breadth-first_traversal-dark.svg\"\n+ *      media=\"(prefers-color-scheme: dark)\">\n+ *     <img src=\"Sorted_binary_tree_breadth-first_traversal.svg\"\n+ *      alt=\"Sorted binary tree, breadth-first level order traversal\">\n+ *   <\/picture>\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gnode.c","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    gboolean bool;\n+    gboolean boolean;\n@@ -1464,1 +1464,1 @@\n-          gint len = strlen (group->entries[j].long_name);\n+          size_t len = strlen (group->entries[j].long_name);\n@@ -1588,1 +1588,1 @@\n-              *(gboolean *)change->arg_data = change->prev.bool;\n+              *(gboolean *)change->arg_data = change->prev.boolean;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/goption.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * A `GPatternSpec` struct is the 'compiled' form of a glob-style pattern.\n+ * A `GPatternSpec` struct is the โcompiledโ form of a glob-style pattern.\n@@ -39,3 +39,3 @@\n- * match a string against a pattern containing '*' and '?' wildcards with similar\n- * semantics as the standard `glob()` function: '*' matches an arbitrary,\n- * possibly empty, string, '?' matches an arbitrary character.\n+ * match a string against a pattern containing `*` and `?` wildcards with similar\n+ * semantics as the standard `glob()` function: `*` matches an arbitrary,\n+ * possibly empty, string, `?` matches an arbitrary character.\n@@ -43,2 +43,2 @@\n- * Note that in contrast to `glob()`, the '\/' character can be matched by\n- * the wildcards, there are no '[...]' character ranges and '*' and '?'\n+ * Note that in contrast to [`glob()`](man:glob(3)), the `\/` character can be\n+ * matched by the wildcards, there are no `[โฆ]` character ranges and `*` and `?`\n@@ -68,3 +68,3 @@\n-  guint      pattern_length;\n-  guint      min_length;\n-  guint      max_length;\n+  size_t     pattern_length;\n+  size_t     min_length;\n+  size_t     max_length;\n@@ -157,2 +157,2 @@\n- * @string_length: the length of @string (in bytes, i.e. strlen(),\n- *     not g_utf8_strlen())\n+ * @string_length: the length of @string (in bytes, i.e. `strlen()`,\n+ *    not [func@GLib.utf8_strlen])\n@@ -160,1 +160,1 @@\n- * @string_reversed: (nullable): the reverse of @string or %NULL\n+ * @string_reversed: (nullable): the reverse of @string\n@@ -162,1 +162,3 @@\n- * Matches a string against a compiled pattern. Passing the correct\n+ * Matches a string against a compiled pattern.\n+ *\n+ * Passing the correct\n@@ -164,1 +166,1 @@\n- * omitted by passing %NULL, this is more efficient if the reversed\n+ * omitted by passing `NULL`, this is more efficient if the reversed\n@@ -166,1 +168,1 @@\n- * g_pattern_match() will only construct it if the compiled pattern\n+ * [method@GLib.PatternSpec.match] will only construct it if the compiled pattern\n@@ -171,1 +173,1 @@\n- * some patterns will require a reversed string. In this case, it's\n+ * some patterns will require a reversed string. In this case, itโs\n@@ -173,1 +175,1 @@\n- * constructions thereof in the various calls to g_pattern_match().\n+ * constructions thereof in the various calls to [method@GLib.PatternSpec.match].\n@@ -176,1 +178,1 @@\n- * not be obtained by g_strreverse(). This works only if the string\n+ * not be obtained by [func@GLib.strreverse]. This works only if the string\n@@ -178,1 +180,1 @@\n- * g_utf8_strreverse() function to reverse UTF-8 encoded strings.\n+ * [func@GLib.utf8_strreverse] function to reverse UTF-8 encoded strings.\n@@ -240,2 +242,2 @@\n- * @string_length: the length of @string (in bytes, i.e. strlen(),\n- *     not g_utf8_strlen())\n+ * @string_length: the length of @string (in bytes, i.e. `strlen()`,\n+ *    not [func@GLib.utf8_strlen])\n@@ -243,1 +245,3 @@\n- * @string_reversed: (nullable): the reverse of @string or %NULL\n+ * @string_reversed: (nullable): the reverse of @string\n+ *\n+ * Matches a string against a compiled pattern.\n@@ -245,1 +249,1 @@\n- * Matches a string against a compiled pattern. Passing the correct\n+ * Passing the correct\n@@ -247,1 +251,1 @@\n- * omitted by passing %NULL, this is more efficient if the reversed\n+ * omitted by passing `NULL`, this is more efficient if the reversed\n@@ -249,1 +253,1 @@\n- * g_pattern_match() will only construct it if the compiled pattern\n+ * `g_pattern_match()` will only construct it if the compiled pattern\n@@ -254,1 +258,1 @@\n- * some patterns will require a reversed string. In this case, it's\n+ * some patterns will require a reversed string. In this case, itโs\n@@ -256,1 +260,1 @@\n- * constructions thereof in the various calls to g_pattern_match().\n+ * constructions thereof in the various calls to `g_pattern_match()`.\n@@ -259,1 +263,1 @@\n- * not be obtained by g_strreverse(). This works only if the string\n+ * not be obtained by [func@GLib.strreverse]. This works only if the string\n@@ -261,1 +265,1 @@\n- * g_utf8_strreverse() function to reverse UTF-8 encoded strings.\n+ * [func@GLib.utf8_strreverse] function to reverse UTF-8 encoded strings.\n@@ -264,1 +268,1 @@\n- * Deprecated: 2.70: Use g_pattern_spec_match() instead\n+ * Deprecated: 2.70: Use [method@GLib.PatternSpec.match] instead\n@@ -279,1 +283,1 @@\n- * Compiles a pattern to a #GPatternSpec.\n+ * Compiles a pattern to a [type@GLib.PatternSpec].\n@@ -281,1 +285,1 @@\n- * Returns: a newly-allocated #GPatternSpec\n+ * Returns: (transfer full): a newly-allocated [type@GLib.PatternSpec]\n@@ -395,1 +399,1 @@\n- * Copies @pspec in a new #GPatternSpec.\n+ * Copies @pspec in a new [type@GLib.PatternSpec].\n@@ -419,1 +423,1 @@\n- * Frees the memory allocated for the #GPatternSpec.\n+ * Frees the memory allocated for the [type@GLib.PatternSpec].\n@@ -457,1 +461,3 @@\n- * Matches a string against a compiled pattern. If the string is to be\n+ * Matches a string against a compiled pattern.\n+ *\n+ * If the string is to be\n@@ -459,1 +465,1 @@\n- * g_pattern_match() instead while supplying the reversed string.\n+ * [method@GLib.PatternSpec.match] instead while supplying the reversed string.\n@@ -480,1 +486,3 @@\n- * Matches a string against a compiled pattern. If the string is to be\n+ * Matches a string against a compiled pattern.\n+ *\n+ * If the string is to be\n@@ -482,1 +490,1 @@\n- * g_pattern_match() instead while supplying the reversed string.\n+ * [method@GLib.PatternSpec.match] instead while supplying the reversed string.\n@@ -485,1 +493,1 @@\n- * Deprecated: 2.70: Use g_pattern_spec_match_string() instead\n+ * Deprecated: 2.70: Use [method@GLib.PatternSpec.match_string] instead\n@@ -499,4 +507,6 @@\n- * Matches a string against a pattern given as a string. If this\n- * function is to be called in a loop, it's more efficient to compile\n- * the pattern once with g_pattern_spec_new() and call\n- * g_pattern_match_string() repeatedly.\n+ * Matches a string against a pattern given as a string.\n+ *\n+ * If this\n+ * function is to be called in a loop, itโs more efficient to compile\n+ * the pattern once with [ctor@GLib.PatternSpec.new] and call\n+ * [method@GLib.PatternSpec.match_string] repeatedly.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gpattern.c","additions":53,"deletions":43,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -292,2 +292,3 @@\n- * This is just like the standard C qsort() function, but\n- * the comparison routine accepts a user data argument.\n+ * This is just like the standard C [`qsort()`](man:qsort(3)) function, but\n+ * the comparison routine accepts a user data argument\n+ * (like [`qsort_r()`](man:qsort_r(3))).\n@@ -295,1 +296,4 @@\n- * This is guaranteed to be a stable sort since version 2.32.\n+ * Unlike `qsort()`, this is guaranteed to be a stable sort (since GLib 2.32).\n+ *\n+ * Deprecated: 2.82: `total_elems` is too small to represent larger arrays; use\n+ *   [func@GLib.sort_array] instead\n@@ -304,1 +308,27 @@\n-  msort_r ((gpointer)pbase, total_elems, size, compare_func, user_data);\n+  g_sort_array (pbase, total_elems, size, compare_func, user_data);\n+}\n+\n+\/**\n+ * g_sort_array:\n+ * @array: (not nullable) (array length=n_elements): start of array to sort\n+ * @n_elements: number of elements in the array\n+ * @element_size: size of each element\n+ * @compare_func: (scope call): function to compare elements\n+ * @user_data: data to pass to @compare_func\n+ *\n+ * This is just like the standard C [`qsort()`](man:qsort(3)) function, but\n+ * the comparison routine accepts a user data argument\n+ * (like [`qsort_r()`](man:qsort_r(3))).\n+ *\n+ * Unlike `qsort()`, this is guaranteed to be a stable sort.\n+ *\n+ * Since: 2.82\n+ *\/\n+void\n+g_sort_array (const void       *array,\n+              size_t            n_elements,\n+              size_t            element_size,\n+              GCompareDataFunc  compare_func,\n+              void             *user_data)\n+{\n+  msort_r ((void *) array, n_elements, element_size, compare_func, user_data);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gqsort.c","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-GLIB_AVAILABLE_IN_ALL\n+GLIB_DEPRECATED_IN_2_82_FOR(g_sort_array)\n@@ -45,0 +45,7 @@\n+GLIB_AVAILABLE_IN_2_82\n+void g_sort_array (const void       *array,\n+                   size_t            n_elements,\n+                   size_t            element_size,\n+                   GCompareDataFunc  compare_func,\n+                   void             *user_data);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gqsort.h","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1735,0 +1735,1 @@\n+      g_assert (node != NULL);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gsequence.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1992 @@\n+\/* gspawn.c - Process launching\n+ *\n+ *  Copyright 2000 Red Hat, Inc.\n+ *  g_execvpe implementation based on GNU libc execvp:\n+ *   Copyright 1991, 92, 95, 96, 97, 98, 99 Free Software Foundation, Inc.\n+ *\n+ * SPDX-License-Identifier: LGPL-2.1-or-later\n+ *\n+ * This library is free software; you can redistribute it and\/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 2.1 of the License, or (at your option) any later version.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this library; if not, see <http:\/\/www.gnu.org\/licenses\/>.\n+ *\/\n+\n+#include \"config.h\"\n+\n+#include <sys\/time.h>\n+#include <sys\/types.h>\n+#include <sys\/wait.h>\n+#include <unistd.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <signal.h>\n+#include <string.h>\n+#include <stdlib.h>   \/* for fdwalk *\/\n+#include <dirent.h>\n+#include <unistd.h>\n+\n+#ifdef HAVE_SPAWN_H\n+#include <spawn.h>\n+#endif \/* HAVE_SPAWN_H *\/\n+\n+#ifdef HAVE_CRT_EXTERNS_H\n+#include <crt_externs.h> \/* for _NSGetEnviron *\/\n+#endif\n+\n+#ifdef HAVE_SYS_SELECT_H\n+#include <sys\/select.h>\n+#endif \/* HAVE_SYS_SELECT_H *\/\n+\n+#ifdef HAVE_SYS_RESOURCE_H\n+#include <sys\/resource.h>\n+#endif \/* HAVE_SYS_RESOURCE_H *\/\n+\n+#if defined(__linux__) || defined(__DragonFly__)\n+#include <sys\/syscall.h>  \/* for syscall and SYS_getdents64 *\/\n+#endif\n+\n+#include \"gspawn.h\"\n+#include \"gspawn-private.h\"\n+#include \"gthread.h\"\n+#include \"gtrace-private.h\"\n+#include \"glib\/gstdio.h\"\n+\n+#include \"genviron.h\"\n+#include \"gmem.h\"\n+#include \"gshell.h\"\n+#include \"gstring.h\"\n+#include \"gstrfuncs.h\"\n+#include \"gtestutils.h\"\n+#include \"gutils.h\"\n+#include \"glibintl.h\"\n+#include \"glib-unix.h\"\n+\n+#if defined(__APPLE__) && defined(HAVE_LIBPROC_H)\n+#include <libproc.h>\n+#include <sys\/proc_info.h>\n+#endif\n+\n+#define INHERITS_OR_NULL_STDIN  (G_SPAWN_STDIN_FROM_DEV_NULL | G_SPAWN_CHILD_INHERITS_STDIN)\n+#define INHERITS_OR_NULL_STDOUT (G_SPAWN_STDOUT_TO_DEV_NULL | G_SPAWN_CHILD_INHERITS_STDOUT)\n+#define INHERITS_OR_NULL_STDERR (G_SPAWN_STDERR_TO_DEV_NULL | G_SPAWN_CHILD_INHERITS_STDERR)\n+\n+#define IS_STD_FILENO(_fd) ((_fd >= STDIN_FILENO) && (_fd <= STDERR_FILENO))\n+#define IS_VALID_FILENO(_fd) (_fd >= 0)\n+\n+\/* posix_spawn() is assumed the fastest way to spawn, but glibc's\n+ * implementation was buggy before glibc 2.24, so avoid it on old versions.\n+ *\/\n+#ifdef HAVE_POSIX_SPAWN\n+#ifdef __GLIBC__\n+\n+#if __GLIBC_PREREQ(2,24)\n+#define POSIX_SPAWN_AVAILABLE\n+#endif\n+\n+#else \/* !__GLIBC__ *\/\n+\/* Assume that all non-glibc posix_spawn implementations are fine. *\/\n+#define POSIX_SPAWN_AVAILABLE\n+#endif \/* __GLIBC__ *\/\n+#endif \/* HAVE_POSIX_SPAWN *\/\n+\n+#ifdef HAVE__NSGETENVIRON\n+#define environ (*_NSGetEnviron())\n+#else\n+extern char **environ;\n+#endif\n+\n+#ifndef O_CLOEXEC\n+#define O_CLOEXEC 0\n+#else\n+#define HAVE_O_CLOEXEC 1\n+#endif\n+\n+static gint g_execute (const gchar  *file,\n+                       gchar       **argv,\n+                       gchar       **argv_buffer,\n+                       gsize         argv_buffer_len,\n+                       gchar       **envp,\n+                       const gchar  *search_path,\n+                       gchar        *search_path_buffer,\n+                       gsize         search_path_buffer_len);\n+\n+static gboolean fork_exec (gboolean              intermediate_child,\n+                           const gchar          *working_directory,\n+                           const gchar * const  *argv,\n+                           const gchar * const  *envp,\n+                           gboolean              close_descriptors,\n+                           gboolean              search_path,\n+                           gboolean              search_path_from_envp,\n+                           gboolean              stdout_to_null,\n+                           gboolean              stderr_to_null,\n+                           gboolean              child_inherits_stdin,\n+                           gboolean              file_and_argv_zero,\n+                           gboolean              cloexec_pipes,\n+                           GSpawnChildSetupFunc  child_setup,\n+                           gpointer              user_data,\n+                           GPid                 *child_pid,\n+                           gint                 *stdin_pipe_out,\n+                           gint                 *stdout_pipe_out,\n+                           gint                 *stderr_pipe_out,\n+                           gint                  stdin_fd,\n+                           gint                  stdout_fd,\n+                           gint                  stderr_fd,\n+                           const gint           *source_fds,\n+                           const gint           *target_fds,\n+                           gsize                 n_fds,\n+                           GError              **error);\n+\n+G_DEFINE_QUARK (g-exec-error-quark, g_spawn_error)\n+G_DEFINE_QUARK (g-spawn-exit-error-quark, g_spawn_exit_error)\n+\n+\/* Some versions of OS X define READ_OK in public headers *\/\n+#undef READ_OK\n+\n+typedef enum\n+{\n+  READ_FAILED = 0, \/* FALSE *\/\n+  READ_OK,\n+  READ_EOF\n+} ReadResult;\n+\n+static ReadResult\n+read_data (GString *str,\n+           gint     fd,\n+           GError **error)\n+{\n+  gssize bytes;\n+  gchar buf[4096];\n+\n+ again:\n+  bytes = read (fd, buf, 4096);\n+\n+  if (bytes == 0)\n+    return READ_EOF;\n+  else if (bytes > 0)\n+    {\n+      g_string_append_len (str, buf, bytes);\n+      return READ_OK;\n+    }\n+  else if (errno == EINTR)\n+    goto again;\n+  else\n+    {\n+      int errsv = errno;\n+\n+      g_set_error (error,\n+                   G_SPAWN_ERROR,\n+                   G_SPAWN_ERROR_READ,\n+                   _(\"Failed to read data from child process (%s)\"),\n+                   g_strerror (errsv));\n+\n+      return READ_FAILED;\n+    }\n+}\n+\n+gboolean\n+g_spawn_sync_impl (const gchar           *working_directory,\n+                   gchar                **argv,\n+                   gchar                **envp,\n+                   GSpawnFlags            flags,\n+                   GSpawnChildSetupFunc   child_setup,\n+                   gpointer               user_data,\n+                   gchar                **standard_output,\n+                   gchar                **standard_error,\n+                   gint                  *wait_status,\n+                   GError               **error)\n+{\n+  gint outpipe = -1;\n+  gint errpipe = -1;\n+  GPid pid;\n+  gint ret;\n+  GString *outstr = NULL;\n+  GString *errstr = NULL;\n+  gboolean failed;\n+  gint status;\n+\n+  g_return_val_if_fail (argv != NULL, FALSE);\n+  g_return_val_if_fail (argv[0] != NULL, FALSE);\n+  g_return_val_if_fail (!(flags & G_SPAWN_DO_NOT_REAP_CHILD), FALSE);\n+  g_return_val_if_fail (standard_output == NULL ||\n+                        !(flags & G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);\n+  g_return_val_if_fail (standard_error == NULL ||\n+                        !(flags & G_SPAWN_STDERR_TO_DEV_NULL), FALSE);\n+\n+  \/* Just to ensure segfaults if callers try to use\n+   * these when an error is reported.\n+   *\/\n+  if (standard_output)\n+    *standard_output = NULL;\n+\n+  if (standard_error)\n+    *standard_error = NULL;\n+\n+  if (!fork_exec (FALSE,\n+                  working_directory,\n+                  (const gchar * const *) argv,\n+                  (const gchar * const *) envp,\n+                  !(flags & G_SPAWN_LEAVE_DESCRIPTORS_OPEN),\n+                  (flags & G_SPAWN_SEARCH_PATH) != 0,\n+                  (flags & G_SPAWN_SEARCH_PATH_FROM_ENVP) != 0,\n+                  (flags & G_SPAWN_STDOUT_TO_DEV_NULL) != 0,\n+                  (flags & G_SPAWN_STDERR_TO_DEV_NULL) != 0,\n+                  (flags & G_SPAWN_CHILD_INHERITS_STDIN) != 0,\n+                  (flags & G_SPAWN_FILE_AND_ARGV_ZERO) != 0,\n+                  (flags & G_SPAWN_CLOEXEC_PIPES) != 0,\n+                  child_setup,\n+                  user_data,\n+                  &pid,\n+                  NULL,\n+                  standard_output ? &outpipe : NULL,\n+                  standard_error ? &errpipe : NULL,\n+                  -1, -1, -1,\n+                  NULL, NULL, 0,\n+                  error))\n+    return FALSE;\n+\n+  \/* Read data from child. *\/\n+\n+  failed = FALSE;\n+\n+  if (outpipe >= 0)\n+    {\n+      outstr = g_string_new (NULL);\n+    }\n+\n+  if (errpipe >= 0)\n+    {\n+      errstr = g_string_new (NULL);\n+    }\n+\n+  \/* Read data until we get EOF on both pipes. *\/\n+  while (!failed &&\n+         (outpipe >= 0 ||\n+          errpipe >= 0))\n+    {\n+      \/* Any negative FD in the array is ignored, so we can use a fixed length.\n+       * We can use UNIX FDs here without worrying about Windows HANDLEs because\n+       * the Windows implementation is entirely in gspawn-win32.c. *\/\n+      GPollFD fds[] =\n+        {\n+          { outpipe, G_IO_IN | G_IO_HUP | G_IO_ERR, 0 },\n+          { errpipe, G_IO_IN | G_IO_HUP | G_IO_ERR, 0 },\n+        };\n+\n+      ret = g_poll (fds, G_N_ELEMENTS (fds), -1  \/* no timeout *\/);\n+\n+      if (ret < 0)\n+        {\n+          int errsv = errno;\n+\n+    if (errno == EINTR)\n+      continue;\n+\n+          failed = TRUE;\n+\n+          g_set_error (error,\n+                       G_SPAWN_ERROR,\n+                       G_SPAWN_ERROR_READ,\n+                       _(\"Unexpected error in reading data from a child process (%s)\"),\n+                       g_strerror (errsv));\n+\n+          break;\n+        }\n+\n+      if (outpipe >= 0 && fds[0].revents != 0)\n+        {\n+          switch (read_data (outstr, outpipe, error))\n+            {\n+            case READ_FAILED:\n+              failed = TRUE;\n+              break;\n+            case READ_EOF:\n+              g_clear_fd (&outpipe, NULL);\n+              break;\n+            default:\n+              break;\n+            }\n+\n+          if (failed)\n+            break;\n+        }\n+\n+      if (errpipe >= 0 && fds[1].revents != 0)\n+        {\n+          switch (read_data (errstr, errpipe, error))\n+            {\n+            case READ_FAILED:\n+              failed = TRUE;\n+              break;\n+            case READ_EOF:\n+              g_clear_fd (&errpipe, NULL);\n+              break;\n+            default:\n+              break;\n+            }\n+\n+          if (failed)\n+            break;\n+        }\n+    }\n+\n+  \/* These should only be open still if we had an error.  *\/\n+  g_clear_fd (&outpipe, NULL);\n+  g_clear_fd (&errpipe, NULL);\n+\n+  \/* Wait for child to exit, even if we have\n+   * an error pending.\n+   *\/\n+ again:\n+\n+  ret = waitpid (pid, &status, 0);\n+\n+  if (ret < 0)\n+    {\n+      if (errno == EINTR)\n+        goto again;\n+      else if (errno == ECHILD)\n+        {\n+          if (wait_status)\n+            {\n+              g_warning (\"In call to g_spawn_sync(), wait status of a child process was requested but ECHILD was received by waitpid(). See the documentation of g_child_watch_source_new() for possible causes.\");\n+            }\n+          else\n+            {\n+              \/* We don't need the wait status. *\/\n+            }\n+        }\n+      else\n+        {\n+          if (!failed) \/* avoid error pileups *\/\n+            {\n+              int errsv = errno;\n+\n+              failed = TRUE;\n+\n+              g_set_error (error,\n+                           G_SPAWN_ERROR,\n+                           G_SPAWN_ERROR_READ,\n+                           _(\"Unexpected error in waitpid() (%s)\"),\n+                           g_strerror (errsv));\n+            }\n+        }\n+    }\n+\n+  if (failed)\n+    {\n+      if (outstr)\n+        g_string_free (outstr, TRUE);\n+      if (errstr)\n+        g_string_free (errstr, TRUE);\n+\n+      return FALSE;\n+    }\n+  else\n+    {\n+      if (wait_status)\n+        *wait_status = status;\n+\n+      if (standard_output)\n+        *standard_output = g_string_free (outstr, FALSE);\n+\n+      if (standard_error)\n+        *standard_error = g_string_free (errstr, FALSE);\n+\n+      return TRUE;\n+    }\n+}\n+\n+gboolean\n+g_spawn_async_with_pipes_and_fds_impl (const gchar           *working_directory,\n+                                       const gchar * const   *argv,\n+                                       const gchar * const   *envp,\n+                                       GSpawnFlags            flags,\n+                                       GSpawnChildSetupFunc   child_setup,\n+                                       gpointer               user_data,\n+                                       gint                   stdin_fd,\n+                                       gint                   stdout_fd,\n+                                       gint                   stderr_fd,\n+                                       const gint            *source_fds,\n+                                       const gint            *target_fds,\n+                                       gsize                  n_fds,\n+                                       GPid                  *child_pid_out,\n+                                       gint                  *stdin_pipe_out,\n+                                       gint                  *stdout_pipe_out,\n+                                       gint                  *stderr_pipe_out,\n+                                       GError               **error)\n+{\n+  g_return_val_if_fail (argv != NULL, FALSE);\n+  g_return_val_if_fail (argv[0] != NULL, FALSE);\n+  \/* canโt both inherit and set pipes to \/dev\/null *\/\n+  g_return_val_if_fail ((flags & INHERITS_OR_NULL_STDIN) != INHERITS_OR_NULL_STDIN, FALSE);\n+  g_return_val_if_fail ((flags & INHERITS_OR_NULL_STDOUT) != INHERITS_OR_NULL_STDOUT, FALSE);\n+  g_return_val_if_fail ((flags & INHERITS_OR_NULL_STDERR) != INHERITS_OR_NULL_STDERR, FALSE);\n+  \/* canโt use pipes and stdin\/stdout\/stderr FDs *\/\n+  g_return_val_if_fail (stdin_pipe_out == NULL || stdin_fd < 0, FALSE);\n+  g_return_val_if_fail (stdout_pipe_out == NULL || stdout_fd < 0, FALSE);\n+  g_return_val_if_fail (stderr_pipe_out == NULL || stderr_fd < 0, FALSE);\n+\n+  if ((flags & INHERITS_OR_NULL_STDIN) != 0)\n+    stdin_pipe_out = NULL;\n+  if ((flags & INHERITS_OR_NULL_STDOUT) != 0)\n+    stdout_pipe_out = NULL;\n+  if ((flags & INHERITS_OR_NULL_STDERR) != 0)\n+    stderr_pipe_out = NULL;\n+\n+  return fork_exec (!(flags & G_SPAWN_DO_NOT_REAP_CHILD),\n+                    working_directory,\n+                    (const gchar * const *) argv,\n+                    (const gchar * const *) envp,\n+                    !(flags & G_SPAWN_LEAVE_DESCRIPTORS_OPEN),\n+                    (flags & G_SPAWN_SEARCH_PATH) != 0,\n+                    (flags & G_SPAWN_SEARCH_PATH_FROM_ENVP) != 0,\n+                    (flags & G_SPAWN_STDOUT_TO_DEV_NULL) != 0,\n+                    (flags & G_SPAWN_STDERR_TO_DEV_NULL) != 0,\n+                    (flags & G_SPAWN_CHILD_INHERITS_STDIN) != 0,\n+                    (flags & G_SPAWN_FILE_AND_ARGV_ZERO) != 0,\n+                    (flags & G_SPAWN_CLOEXEC_PIPES) != 0,\n+                    child_setup,\n+                    user_data,\n+                    child_pid_out,\n+                    stdin_pipe_out,\n+                    stdout_pipe_out,\n+                    stderr_pipe_out,\n+                    stdin_fd,\n+                    stdout_fd,\n+                    stderr_fd,\n+                    source_fds,\n+                    target_fds,\n+                    n_fds,\n+                    error);\n+}\n+\n+gboolean\n+g_spawn_check_wait_status_impl (gint     wait_status,\n+                                GError **error)\n+{\n+  gboolean ret = FALSE;\n+\n+  if (WIFEXITED (wait_status))\n+    {\n+      if (WEXITSTATUS (wait_status) != 0)\n+  {\n+    g_set_error (error, G_SPAWN_EXIT_ERROR, WEXITSTATUS (wait_status),\n+           _(\"Child process exited with code %ld\"),\n+           (long) WEXITSTATUS (wait_status));\n+    goto out;\n+  }\n+    }\n+  else if (WIFSIGNALED (wait_status))\n+    {\n+      g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,\n+       _(\"Child process killed by signal %ld\"),\n+       (long) WTERMSIG (wait_status));\n+      goto out;\n+    }\n+  else if (WIFSTOPPED (wait_status))\n+    {\n+      g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,\n+       _(\"Child process stopped by signal %ld\"),\n+       (long) WSTOPSIG (wait_status));\n+      goto out;\n+    }\n+  else\n+    {\n+      g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,\n+       _(\"Child process exited abnormally\"));\n+      goto out;\n+    }\n+\n+  ret = TRUE;\n+ out:\n+  return ret;\n+}\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)). *\/\n+static gssize\n+write_all (gint fd, gconstpointer vbuf, gsize to_write)\n+{\n+  gchar *buf = (gchar *) vbuf;\n+\n+  while (to_write > 0)\n+    {\n+      gssize count = write (fd, buf, to_write);\n+      if (count < 0)\n+        {\n+          if (errno != EINTR)\n+            return FALSE;\n+        }\n+      else\n+        {\n+          to_write -= count;\n+          buf += count;\n+        }\n+    }\n+\n+  return TRUE;\n+}\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)). *\/\n+G_NORETURN\n+static void\n+write_err_and_exit (gint fd, gint msg)\n+{\n+  gint en = errno;\n+\n+  write_all (fd, &msg, sizeof(msg));\n+  write_all (fd, &en, sizeof(en));\n+\n+  _exit (1);\n+}\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)). *\/\n+static void\n+set_cloexec (int fd)\n+{\n+  fcntl (fd, F_SETFD, FD_CLOEXEC);\n+}\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)). *\/\n+static void\n+unset_cloexec (int fd)\n+{\n+  int flags;\n+  int result;\n+\n+  flags = fcntl (fd, F_GETFD, 0);\n+\n+  if (flags != -1)\n+    {\n+      int errsv;\n+      flags &= (~FD_CLOEXEC);\n+      do\n+        {\n+          result = fcntl (fd, F_SETFD, flags);\n+          errsv = errno;\n+        }\n+      while (result == -1 && errsv == EINTR);\n+    }\n+}\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)). *\/\n+static int\n+dupfd_cloexec (int old_fd, int new_fd_min)\n+{\n+  int fd, errsv;\n+#ifdef F_DUPFD_CLOEXEC\n+  do\n+    {\n+      fd = fcntl (old_fd, F_DUPFD_CLOEXEC, new_fd_min);\n+      errsv = errno;\n+    }\n+  while (fd == -1 && errsv == EINTR);\n+#else\n+  \/* OS X Snow Lion and earlier don't have F_DUPFD_CLOEXEC:\n+   * https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=710962\n+   *\/\n+  int result, flags;\n+  do\n+    {\n+      fd = fcntl (old_fd, F_DUPFD, new_fd_min);\n+      errsv = errno;\n+    }\n+  while (fd == -1 && errsv == EINTR);\n+  flags = fcntl (fd, F_GETFD, 0);\n+  if (flags != -1)\n+    {\n+      flags |= FD_CLOEXEC;\n+      do\n+        {\n+          result = fcntl (fd, F_SETFD, flags);\n+          errsv = errno;\n+        }\n+      while (result == -1 && errsv == EINTR);\n+    }\n+#endif\n+  return fd;\n+}\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)). *\/\n+static gint\n+safe_dup2 (gint fd1, gint fd2)\n+{\n+  gint ret;\n+\n+  do\n+    ret = dup2 (fd1, fd2);\n+  while (ret < 0 && (errno == EINTR || errno == EBUSY));\n+\n+  return ret;\n+}\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)). *\/\n+static gboolean\n+relocate_fd_out_of_standard_range (gint *fd)\n+{\n+  gint ret = -1;\n+  const int min_fileno = STDERR_FILENO + 1;\n+\n+  do\n+    ret = fcntl (*fd, F_DUPFD, min_fileno);\n+  while (ret < 0 && errno == EINTR);\n+\n+  \/* Note we don't need to close the old fd, because the caller is expected\n+   * to close fds in the standard range itself.\n+   *\/\n+  if (ret >= min_fileno)\n+    {\n+      *fd = ret;\n+      return TRUE;\n+    }\n+\n+  return FALSE;\n+}\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)). *\/\n+static gint\n+safe_open (const char *path, gint mode)\n+{\n+  gint ret;\n+\n+  do\n+    ret = open (path, mode);\n+  while (ret < 0 && errno == EINTR);\n+\n+  return ret;\n+}\n+\n+enum\n+{\n+  CHILD_CHDIR_FAILED,\n+  CHILD_EXEC_FAILED,\n+  CHILD_OPEN_FAILED,\n+  CHILD_DUPFD_FAILED,\n+  CHILD_FORK_FAILED,\n+  CHILD_CLOSE_FAILED,\n+};\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)) until it calls exec().\n+ *\n+ * All callers must guarantee that @argv and @argv[0] are non-NULL. *\/\n+static void\n+do_exec (gint                  child_err_report_fd,\n+         gint                  stdin_fd,\n+         gint                  stdout_fd,\n+         gint                  stderr_fd,\n+         gint                 *source_fds,\n+         const gint           *target_fds,\n+         gsize                 n_fds,\n+         const gchar          *working_directory,\n+         const gchar * const  *argv,\n+         gchar               **argv_buffer,\n+         gsize                 argv_buffer_len,\n+         const gchar * const  *envp,\n+         gboolean              close_descriptors,\n+         const gchar          *search_path,\n+         gchar                *search_path_buffer,\n+         gsize                 search_path_buffer_len,\n+         gboolean              stdout_to_null,\n+         gboolean              stderr_to_null,\n+         gboolean              child_inherits_stdin,\n+         gboolean              file_and_argv_zero,\n+         GSpawnChildSetupFunc  child_setup,\n+         gpointer              user_data)\n+{\n+  gsize i;\n+  gint max_target_fd = 0;\n+\n+  if (working_directory && chdir (working_directory) < 0)\n+    write_err_and_exit (child_err_report_fd,\n+                        CHILD_CHDIR_FAILED);\n+\n+  \/* It's possible the caller assigned stdin to an fd with a\n+   * file number that is supposed to be reserved for\n+   * stdout or stderr.\n+   *\n+   * If so, move it up out of the standard range, so it doesn't\n+   * cause a conflict.\n+   *\/\n+  if (IS_STD_FILENO (stdin_fd) && stdin_fd != STDIN_FILENO)\n+    {\n+      int old_fd = stdin_fd;\n+\n+      if (!relocate_fd_out_of_standard_range (&stdin_fd))\n+        write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n+\n+      if (stdout_fd == old_fd)\n+        stdout_fd = stdin_fd;\n+\n+      if (stderr_fd == old_fd)\n+        stderr_fd = stdin_fd;\n+    }\n+\n+  \/* Redirect pipes as required\n+   *\n+   * There are two cases where we don't need to do the redirection\n+   * 1. Where the associated file descriptor is cleared\/invalid\n+   * 2. When the associated file descriptor is already given the\n+   * correct file number.\n+   *\/\n+  if (IS_VALID_FILENO (stdin_fd) && stdin_fd != STDIN_FILENO)\n+    {\n+      if (safe_dup2 (stdin_fd, 0) < 0)\n+        write_err_and_exit (child_err_report_fd,\n+                            CHILD_DUPFD_FAILED);\n+\n+      set_cloexec (stdin_fd);\n+    }\n+  else if (!child_inherits_stdin)\n+    {\n+      \/* Keep process from blocking on a read of stdin *\/\n+      gint read_null = safe_open (\"\/dev\/null\", O_RDONLY);\n+      if (read_null < 0)\n+        write_err_and_exit (child_err_report_fd,\n+                            CHILD_OPEN_FAILED);\n+      if (safe_dup2 (read_null, 0) < 0)\n+        write_err_and_exit (child_err_report_fd,\n+                            CHILD_DUPFD_FAILED);\n+      g_clear_fd (&read_null, NULL);\n+    }\n+\n+  \/* Like with stdin above, it's possible the caller assigned\n+   * stdout to an fd with a file number that's intruding on the\n+   * standard range.\n+   *\n+   * If so, move it out of the way, too.\n+   *\/\n+  if (IS_STD_FILENO (stdout_fd) && stdout_fd != STDOUT_FILENO)\n+    {\n+      int old_fd = stdout_fd;\n+\n+      if (!relocate_fd_out_of_standard_range (&stdout_fd))\n+        write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n+\n+      if (stderr_fd == old_fd)\n+        stderr_fd = stdout_fd;\n+    }\n+\n+  if (IS_VALID_FILENO (stdout_fd) && stdout_fd != STDOUT_FILENO)\n+    {\n+      if (safe_dup2 (stdout_fd, 1) < 0)\n+        write_err_and_exit (child_err_report_fd,\n+                            CHILD_DUPFD_FAILED);\n+\n+      set_cloexec (stdout_fd);\n+    }\n+  else if (stdout_to_null)\n+    {\n+      gint write_null = safe_open (\"\/dev\/null\", O_WRONLY);\n+      if (write_null < 0)\n+        write_err_and_exit (child_err_report_fd,\n+                            CHILD_OPEN_FAILED);\n+      if (safe_dup2 (write_null, 1) < 0)\n+        write_err_and_exit (child_err_report_fd,\n+                            CHILD_DUPFD_FAILED);\n+      g_clear_fd (&write_null, NULL);\n+    }\n+\n+  if (IS_STD_FILENO (stderr_fd) && stderr_fd != STDERR_FILENO)\n+    {\n+      if (!relocate_fd_out_of_standard_range (&stderr_fd))\n+        write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n+    }\n+\n+  \/* Like with stdin\/stdout above, it's possible the caller assigned\n+   * stderr to an fd with a file number that's intruding on the\n+   * standard range.\n+   *\n+   * Make sure it's out of the way, also.\n+   *\/\n+  if (IS_VALID_FILENO (stderr_fd) && stderr_fd != STDERR_FILENO)\n+    {\n+      if (safe_dup2 (stderr_fd, 2) < 0)\n+        write_err_and_exit (child_err_report_fd,\n+                            CHILD_DUPFD_FAILED);\n+\n+      set_cloexec (stderr_fd);\n+    }\n+  else if (stderr_to_null)\n+    {\n+      gint write_null = safe_open (\"\/dev\/null\", O_WRONLY);\n+      if (write_null < 0)\n+        write_err_and_exit (child_err_report_fd,\n+                            CHILD_OPEN_FAILED);\n+      if (safe_dup2 (write_null, 2) < 0)\n+        write_err_and_exit (child_err_report_fd,\n+                            CHILD_DUPFD_FAILED);\n+      g_clear_fd (&write_null, NULL);\n+    }\n+\n+  \/* Close all file descriptors but stdin, stdout and stderr, and any of source_fds,\n+   * before we exec. Note that this includes\n+   * child_err_report_fd, which keeps the parent from blocking\n+   * forever on the other end of that pipe.\n+   *\/\n+  if (close_descriptors)\n+    {\n+      if (child_setup == NULL && n_fds == 0)\n+        {\n+          if (safe_dup2 (child_err_report_fd, 3) < 0)\n+            write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n+          set_cloexec (3);\n+          if (g_closefrom (4) < 0)\n+            write_err_and_exit (child_err_report_fd, CHILD_CLOSE_FAILED);\n+          child_err_report_fd = 3;\n+        }\n+      else\n+        {\n+          if (g_fdwalk_set_cloexec (3) < 0)\n+            write_err_and_exit (child_err_report_fd, CHILD_CLOSE_FAILED);\n+        }\n+    }\n+  else\n+    {\n+      \/* We need to do child_err_report_fd anyway *\/\n+      set_cloexec (child_err_report_fd);\n+    }\n+\n+  \/*\n+   * Work through the @source_fds and @target_fds mapping.\n+   *\n+   * Based on code originally derived from\n+   * gnome-terminal:src\/terminal-screen.c:terminal_screen_child_setup(),\n+   * used under the LGPLv2+ with permission from author. (The code has\n+   * since migrated to vte:src\/spawn.cc:SpawnContext::exec and is no longer\n+   * terribly similar to what we have here.)\n+   *\/\n+\n+  if (n_fds > 0)\n+    {\n+      for (i = 0; i < n_fds; i++)\n+        max_target_fd = MAX (max_target_fd, target_fds[i]);\n+\n+      if (max_target_fd == G_MAXINT)\n+        {\n+          errno = EINVAL;\n+          write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n+        }\n+\n+      \/* If we're doing remapping fd assignments, we need to handle\n+       * the case where the user has specified e.g. 5 -> 4, 4 -> 6.\n+       * We do this by duping all source fds, taking care to ensure the new\n+       * fds are larger than any target fd to avoid introducing new conflicts.\n+       *\/\n+      for (i = 0; i < n_fds; i++)\n+        {\n+          if (source_fds[i] != target_fds[i])\n+            {\n+              source_fds[i] = dupfd_cloexec (source_fds[i], max_target_fd + 1);\n+              if (source_fds[i] < 0)\n+                write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n+            }\n+        }\n+\n+      for (i = 0; i < n_fds; i++)\n+        {\n+          \/* For basic fd assignments (where source == target), we can just\n+           * unset FD_CLOEXEC.\n+           *\/\n+          if (source_fds[i] == target_fds[i])\n+            {\n+              unset_cloexec (source_fds[i]);\n+            }\n+          else\n+            {\n+              \/* If any of the @target_fds conflict with @child_err_report_fd,\n+               * dup it so it doesnโt get conflated.\n+               *\/\n+              if (target_fds[i] == child_err_report_fd)\n+                {\n+                  child_err_report_fd = dupfd_cloexec (child_err_report_fd, max_target_fd + 1);\n+                  if (child_err_report_fd < 0)\n+                    write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n+                }\n+\n+              if (safe_dup2 (source_fds[i], target_fds[i]) < 0)\n+                write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n+\n+              g_clear_fd (&source_fds[i], NULL);\n+            }\n+        }\n+    }\n+\n+  \/* Call user function just before we exec *\/\n+  if (child_setup)\n+    {\n+      (* child_setup) (user_data);\n+    }\n+\n+  g_execute (argv[0],\n+             (gchar **) (file_and_argv_zero ? argv + 1 : argv),\n+             argv_buffer, argv_buffer_len,\n+             (gchar **) envp, search_path, search_path_buffer, search_path_buffer_len);\n+\n+  \/* Exec failed *\/\n+  write_err_and_exit (child_err_report_fd,\n+                      CHILD_EXEC_FAILED);\n+}\n+\n+static gboolean\n+read_ints (int      fd,\n+           gint*    buf,\n+           gint     n_ints_in_buf,\n+           gint    *n_ints_read,\n+           GError **error)\n+{\n+  gsize bytes = 0;\n+\n+  while (TRUE)\n+    {\n+      gssize chunk;\n+\n+      if (bytes >= sizeof(gint)*2)\n+        break; \/* give up, who knows what happened, should not be\n+                * possible.\n+                *\/\n+\n+    again:\n+      chunk = read (fd,\n+                    ((gchar*)buf) + bytes,\n+                    sizeof(gint) * n_ints_in_buf - bytes);\n+      if (chunk < 0 && errno == EINTR)\n+        goto again;\n+\n+      if (chunk < 0)\n+        {\n+          int errsv = errno;\n+\n+          \/* Some weird shit happened, bail out *\/\n+          g_set_error (error,\n+                       G_SPAWN_ERROR,\n+                       G_SPAWN_ERROR_FAILED,\n+                       _(\"Failed to read from child pipe (%s)\"),\n+                       g_strerror (errsv));\n+\n+          return FALSE;\n+        }\n+      else if (chunk == 0)\n+        break; \/* EOF *\/\n+      else \/* chunk > 0 *\/\n+  bytes += chunk;\n+    }\n+\n+  *n_ints_read = (gint)(bytes \/ sizeof(gint));\n+\n+  return TRUE;\n+}\n+\n+#ifdef POSIX_SPAWN_AVAILABLE\n+static gboolean\n+do_posix_spawn (const gchar * const *argv,\n+                const gchar * const *envp,\n+                gboolean    search_path,\n+                gboolean    stdout_to_null,\n+                gboolean    stderr_to_null,\n+                gboolean    child_inherits_stdin,\n+                gboolean    file_and_argv_zero,\n+                GPid       *child_pid,\n+                gint       *child_close_fds,\n+                gint        stdin_fd,\n+                gint        stdout_fd,\n+                gint        stderr_fd,\n+                const gint *source_fds,\n+                const gint *target_fds,\n+                gsize       n_fds)\n+{\n+  pid_t pid;\n+  gint *duped_source_fds = NULL;\n+  gint max_target_fd = 0;\n+  const gchar * const *argv_pass;\n+  posix_spawnattr_t attr;\n+  posix_spawn_file_actions_t file_actions;\n+  gint parent_close_fds[3];\n+  gsize num_parent_close_fds = 0;\n+  GSList *child_close = NULL;\n+  GSList *elem;\n+  sigset_t mask;\n+  gsize i;\n+  int r;\n+\n+  g_assert (argv != NULL && argv[0] != NULL);\n+\n+  if (*argv[0] == '\\0')\n+    {\n+      \/* We check the simple case first. *\/\n+      return ENOENT;\n+    }\n+\n+  r = posix_spawnattr_init (&attr);\n+  if (r != 0)\n+    return r;\n+\n+  if (child_close_fds)\n+    {\n+      int i = -1;\n+      while (child_close_fds[++i] != -1)\n+        child_close = g_slist_prepend (child_close,\n+                                       GINT_TO_POINTER (child_close_fds[i]));\n+    }\n+\n+  r = posix_spawnattr_setflags (&attr, POSIX_SPAWN_SETSIGDEF);\n+  if (r != 0)\n+    goto out_free_spawnattr;\n+\n+  \/* Reset some signal handlers that we may use *\/\n+  sigemptyset (&mask);\n+  sigaddset (&mask, SIGCHLD);\n+  sigaddset (&mask, SIGINT);\n+  sigaddset (&mask, SIGTERM);\n+  sigaddset (&mask, SIGHUP);\n+\n+  r = posix_spawnattr_setsigdefault (&attr, &mask);\n+  if (r != 0)\n+    goto out_free_spawnattr;\n+\n+  r = posix_spawn_file_actions_init (&file_actions);\n+  if (r != 0)\n+    goto out_free_spawnattr;\n+\n+  \/* Redirect pipes as required *\/\n+\n+  if (stdin_fd >= 0)\n+    {\n+      r = posix_spawn_file_actions_adddup2 (&file_actions, stdin_fd, 0);\n+      if (r != 0)\n+        goto out_close_fds;\n+\n+      if (!g_slist_find (child_close, GINT_TO_POINTER (stdin_fd)))\n+        child_close = g_slist_prepend (child_close, GINT_TO_POINTER (stdin_fd));\n+    }\n+  else if (!child_inherits_stdin)\n+    {\n+      \/* Keep process from blocking on a read of stdin *\/\n+      gint read_null = safe_open (\"\/dev\/null\", O_RDONLY | O_CLOEXEC);\n+      g_assert (read_null != -1);\n+      parent_close_fds[num_parent_close_fds++] = read_null;\n+\n+#ifndef HAVE_O_CLOEXEC\n+      fcntl (read_null, F_SETFD, FD_CLOEXEC);\n+#endif\n+\n+      r = posix_spawn_file_actions_adddup2 (&file_actions, read_null, 0);\n+      if (r != 0)\n+        goto out_close_fds;\n+    }\n+\n+  if (stdout_fd >= 0)\n+    {\n+      r = posix_spawn_file_actions_adddup2 (&file_actions, stdout_fd, 1);\n+      if (r != 0)\n+        goto out_close_fds;\n+\n+      if (!g_slist_find (child_close, GINT_TO_POINTER (stdout_fd)))\n+        child_close = g_slist_prepend (child_close, GINT_TO_POINTER (stdout_fd));\n+    }\n+  else if (stdout_to_null)\n+    {\n+      gint write_null = safe_open (\"\/dev\/null\", O_WRONLY | O_CLOEXEC);\n+      g_assert (write_null != -1);\n+      parent_close_fds[num_parent_close_fds++] = write_null;\n+\n+#ifndef HAVE_O_CLOEXEC\n+      fcntl (write_null, F_SETFD, FD_CLOEXEC);\n+#endif\n+\n+      r = posix_spawn_file_actions_adddup2 (&file_actions, write_null, 1);\n+      if (r != 0)\n+        goto out_close_fds;\n+    }\n+\n+  if (stderr_fd >= 0)\n+    {\n+      r = posix_spawn_file_actions_adddup2 (&file_actions, stderr_fd, 2);\n+      if (r != 0)\n+        goto out_close_fds;\n+\n+      if (!g_slist_find (child_close, GINT_TO_POINTER (stderr_fd)))\n+        child_close = g_slist_prepend (child_close, GINT_TO_POINTER (stderr_fd));\n+    }\n+  else if (stderr_to_null)\n+    {\n+      gint write_null = safe_open (\"\/dev\/null\", O_WRONLY | O_CLOEXEC);\n+      g_assert (write_null != -1);\n+      parent_close_fds[num_parent_close_fds++] = write_null;\n+\n+#ifndef HAVE_O_CLOEXEC\n+      fcntl (write_null, F_SETFD, FD_CLOEXEC);\n+#endif\n+\n+      r = posix_spawn_file_actions_adddup2 (&file_actions, write_null, 2);\n+      if (r != 0)\n+        goto out_close_fds;\n+    }\n+\n+  \/* If source_fds[i] != target_fds[i], we need to handle the case\n+   * where the user has specified, e.g., 5 -> 4, 4 -> 6. We do this\n+   * by duping the source fds, taking care to ensure the new fds are\n+   * larger than any target fd to avoid introducing new conflicts.\n+   *\n+   * If source_fds[i] == target_fds[i], then we just need to leak\n+   * the fd into the child process, which we *could* do by temporarily\n+   * unsetting CLOEXEC and then setting it again after we spawn if\n+   * it was originally set. POSIX requires that the addup2 action unset\n+   * CLOEXEC if source and target are identical, so you'd think doing it\n+   * manually wouldn't be needed, but unfortunately as of 2021 many\n+   * libcs still don't do so. Example nonconforming libcs:\n+   *  Bionic: https:\/\/android.googlesource.com\/platform\/bionic\/+\/f6e5b582604715729b09db3e36a7aeb8c24b36a4\/libc\/bionic\/spawn.cpp#71\n+   *  uclibc-ng: https:\/\/cgit.uclibc-ng.org\/cgi\/cgit\/uclibc-ng.git\/tree\/librt\/spawn.c?id=7c36bcae09d66bbaa35cbb02253ae0556f42677e#n88\n+   *\n+   * Anyway, unsetting CLOEXEC ourselves would open a small race window\n+   * where the fd could be inherited into a child process if another\n+   * thread spawns something at the same time, because we have not\n+   * called fork() and are multithreaded here. This race is avoidable by\n+   * using dupfd_cloexec, which we already have to do to handle the\n+   * source_fds[i] != target_fds[i] case. So let's always do it!\n+   *\/\n+\n+  for (i = 0; i < n_fds; i++)\n+    max_target_fd = MAX (max_target_fd, target_fds[i]);\n+\n+  if (max_target_fd == G_MAXINT)\n+    goto out_close_fds;\n+\n+  duped_source_fds = g_new (gint, n_fds);\n+  for (i = 0; i < n_fds; i++)\n+    duped_source_fds[i] = -1;  \/* initialise in case dupfd_cloexec() fails below *\/\n+  for (i = 0; i < n_fds; i++)\n+    {\n+      duped_source_fds[i] = dupfd_cloexec (source_fds[i], max_target_fd + 1);\n+      if (duped_source_fds[i] < 0)\n+        goto out_close_fds;\n+    }\n+\n+  for (i = 0; i < n_fds; i++)\n+    {\n+      r = posix_spawn_file_actions_adddup2 (&file_actions, duped_source_fds[i], target_fds[i]);\n+      if (r != 0)\n+        goto out_close_fds;\n+    }\n+\n+  \/* Intentionally close the fds in the child as the last file action,\n+   * having been careful not to add the same fd to this list twice.\n+   *\n+   * This is important to allow (e.g.) for the same fd to be passed as stdout\n+   * and stderr (we must not close it before we have dupped it in both places,\n+   * and we must not attempt to close it twice).\n+   *\/\n+  for (elem = child_close; elem != NULL; elem = elem->next)\n+    {\n+      r = posix_spawn_file_actions_addclose (&file_actions,\n+                                             GPOINTER_TO_INT (elem->data));\n+      if (r != 0)\n+        goto out_close_fds;\n+    }\n+\n+  argv_pass = file_and_argv_zero ? argv + 1 : argv;\n+  if (envp == NULL)\n+    envp = (const gchar * const *) environ;\n+\n+  \/* Don't search when it contains a slash. *\/\n+  if (!search_path || strchr (argv[0], '\/') != NULL)\n+    r = posix_spawn (&pid, argv[0], &file_actions, &attr, (char * const *) argv_pass, (char * const *) envp);\n+  else\n+    r = posix_spawnp (&pid, argv[0], &file_actions, &attr, (char * const *) argv_pass, (char * const *) envp);\n+\n+  if (r == 0 && child_pid != NULL)\n+    *child_pid = pid;\n+\n+out_close_fds:\n+  for (i = 0; i < num_parent_close_fds; i++)\n+    g_clear_fd (&parent_close_fds[i], NULL);\n+\n+  if (duped_source_fds != NULL)\n+    {\n+      for (i = 0; i < n_fds; i++)\n+        g_clear_fd (&duped_source_fds[i], NULL);\n+      g_free (duped_source_fds);\n+    }\n+\n+  posix_spawn_file_actions_destroy (&file_actions);\n+out_free_spawnattr:\n+  posix_spawnattr_destroy (&attr);\n+  g_slist_free (child_close);\n+\n+  return r;\n+}\n+#endif \/* POSIX_SPAWN_AVAILABLE *\/\n+\n+static gboolean\n+source_fds_collide_with_pipe (const GUnixPipe  *pipefd,\n+                              const int        *source_fds,\n+                              gsize             n_fds,\n+                              GError          **error)\n+{\n+  return (_g_spawn_invalid_source_fd (pipefd->fds[G_UNIX_PIPE_END_READ], source_fds, n_fds, error) ||\n+          _g_spawn_invalid_source_fd (pipefd->fds[G_UNIX_PIPE_END_WRITE], source_fds, n_fds, error));\n+}\n+\n+static gboolean\n+fork_exec (gboolean              intermediate_child,\n+           const gchar          *working_directory,\n+           const gchar * const  *argv,\n+           const gchar * const  *envp,\n+           gboolean              close_descriptors,\n+           gboolean              search_path,\n+           gboolean              search_path_from_envp,\n+           gboolean              stdout_to_null,\n+           gboolean              stderr_to_null,\n+           gboolean              child_inherits_stdin,\n+           gboolean              file_and_argv_zero,\n+           gboolean              cloexec_pipes,\n+           GSpawnChildSetupFunc  child_setup,\n+           gpointer              user_data,\n+           GPid                 *child_pid,\n+           gint                 *stdin_pipe_out,\n+           gint                 *stdout_pipe_out,\n+           gint                 *stderr_pipe_out,\n+           gint                  stdin_fd,\n+           gint                  stdout_fd,\n+           gint                  stderr_fd,\n+           const gint           *source_fds,\n+           const gint           *target_fds,\n+           gsize                 n_fds,\n+           GError              **error)\n+{\n+  GPid pid = -1;\n+  GUnixPipe child_err_report_pipe = G_UNIX_PIPE_INIT;\n+  GUnixPipe child_pid_report_pipe = G_UNIX_PIPE_INIT;\n+  guint pipe_flags = cloexec_pipes ? O_CLOEXEC : 0;\n+  gint status;\n+  const gchar *chosen_search_path;\n+  gchar *search_path_buffer = NULL;\n+  gchar *search_path_buffer_heap = NULL;\n+  gsize search_path_buffer_len = 0;\n+  gchar **argv_buffer = NULL;\n+  gchar **argv_buffer_heap = NULL;\n+  gsize argv_buffer_len = 0;\n+  GUnixPipe stdin_pipe = G_UNIX_PIPE_INIT;\n+  GUnixPipe stdout_pipe = G_UNIX_PIPE_INIT;\n+  GUnixPipe stderr_pipe = G_UNIX_PIPE_INIT;\n+  gint child_close_fds[4] = { -1, -1, -1, -1 };\n+  gint n_child_close_fds = 0;\n+  gint *source_fds_copy = NULL;\n+\n+  g_assert (argv != NULL && argv[0] != NULL);\n+  g_assert (stdin_pipe_out == NULL || stdin_fd < 0);\n+  g_assert (stdout_pipe_out == NULL || stdout_fd < 0);\n+  g_assert (stderr_pipe_out == NULL || stderr_fd < 0);\n+\n+  \/* If pipes have been requested, open them *\/\n+  if (stdin_pipe_out != NULL)\n+    {\n+      if (!g_unix_pipe_open (&stdin_pipe, pipe_flags, error))\n+        goto cleanup_and_fail;\n+      if (source_fds_collide_with_pipe (&stdin_pipe, source_fds, n_fds, error))\n+        goto cleanup_and_fail;\n+      child_close_fds[n_child_close_fds++] = g_unix_pipe_get (&stdin_pipe, G_UNIX_PIPE_END_WRITE);\n+      stdin_fd = g_unix_pipe_get (&stdin_pipe, G_UNIX_PIPE_END_READ);\n+    }\n+\n+  if (stdout_pipe_out != NULL)\n+    {\n+      if (!g_unix_pipe_open (&stdout_pipe, pipe_flags, error))\n+        goto cleanup_and_fail;\n+      if (source_fds_collide_with_pipe (&stdout_pipe, source_fds, n_fds, error))\n+        goto cleanup_and_fail;\n+      child_close_fds[n_child_close_fds++] = g_unix_pipe_get (&stdout_pipe, G_UNIX_PIPE_END_READ);\n+      stdout_fd = g_unix_pipe_get (&stdout_pipe, G_UNIX_PIPE_END_WRITE);\n+    }\n+\n+  if (stderr_pipe_out != NULL)\n+    {\n+      if (!g_unix_pipe_open (&stderr_pipe, pipe_flags, error))\n+        goto cleanup_and_fail;\n+      if (source_fds_collide_with_pipe (&stderr_pipe, source_fds, n_fds, error))\n+        goto cleanup_and_fail;\n+      child_close_fds[n_child_close_fds++] = g_unix_pipe_get (&stderr_pipe, G_UNIX_PIPE_END_READ);\n+      stderr_fd = g_unix_pipe_get (&stderr_pipe, G_UNIX_PIPE_END_WRITE);\n+    }\n+\n+  child_close_fds[n_child_close_fds++] = -1;\n+\n+#ifdef POSIX_SPAWN_AVAILABLE\n+  if (!intermediate_child && working_directory == NULL && !close_descriptors &&\n+      !search_path_from_envp && child_setup == NULL)\n+    {\n+      g_trace_mark (G_TRACE_CURRENT_TIME, 0,\n+                    \"GLib\", \"posix_spawn\",\n+                    \"%s\", argv[0]);\n+\n+      status = do_posix_spawn (argv,\n+                               envp,\n+                               search_path,\n+                               stdout_to_null,\n+                               stderr_to_null,\n+                               child_inherits_stdin,\n+                               file_and_argv_zero,\n+                               child_pid,\n+                               child_close_fds,\n+                               stdin_fd,\n+                               stdout_fd,\n+                               stderr_fd,\n+                               source_fds,\n+                               target_fds,\n+                               n_fds);\n+      if (status == 0)\n+        goto success;\n+\n+      if (status != ENOEXEC)\n+        {\n+          g_set_error (error,\n+                       G_SPAWN_ERROR,\n+                       G_SPAWN_ERROR_FAILED,\n+                       _(\"Failed to spawn child process โ%sโ (%s)\"),\n+                       argv[0],\n+                       g_strerror (status));\n+          goto cleanup_and_fail;\n+       }\n+\n+      \/* posix_spawn is not intended to support script execution. It does in\n+       * some situations on some glibc versions, but that will be fixed.\n+       * So if it fails with ENOEXEC, we fall through to the regular\n+       * gspawn codepath so that script execution can be attempted,\n+       * per standard gspawn behaviour. *\/\n+      g_debug (\"posix_spawn failed (ENOEXEC), fall back to regular gspawn\");\n+    }\n+  else\n+    {\n+      g_trace_mark (G_TRACE_CURRENT_TIME, 0,\n+                    \"GLib\", \"fork\",\n+                    \"posix_spawn avoided %s%s%s%s%s\",\n+                    !intermediate_child ? \"\" : \"(automatic reaping requested) \",\n+                    working_directory == NULL ? \"\" : \"(workdir specified) \",\n+                    !close_descriptors ? \"\" : \"(fd close requested) \",\n+                    !search_path_from_envp ? \"\" : \"(using envp for search path) \",\n+                    child_setup == NULL ? \"\" : \"(child_setup specified) \");\n+    }\n+#endif \/* POSIX_SPAWN_AVAILABLE *\/\n+\n+  \/* Choose a search path. This has to be done before calling fork()\n+   * as getenv() isnโt async-signal-safe (see `man 7 signal-safety`). *\/\n+  chosen_search_path = NULL;\n+  if (search_path_from_envp)\n+    chosen_search_path = g_environ_getenv ((gchar **) envp, \"PATH\");\n+  if (search_path && chosen_search_path == NULL)\n+    chosen_search_path = g_getenv (\"PATH\");\n+\n+  if ((search_path || search_path_from_envp) && chosen_search_path == NULL)\n+    {\n+      \/* There is no 'PATH' in the environment.  The default\n+       * * search path in libc is the current directory followed by\n+       * * the path 'confstr' returns for '_CS_PATH'.\n+       * *\/\n+\n+      \/* In GLib we put . last, for security, and don't use the\n+       * * unportable confstr(); UNIX98 does not actually specify\n+       * * what to search if PATH is unset. POSIX may, dunno.\n+       * *\/\n+\n+      chosen_search_path = \"\/bin:\/usr\/bin:.\";\n+    }\n+\n+  if (search_path || search_path_from_envp)\n+    g_assert (chosen_search_path != NULL);\n+  else\n+    g_assert (chosen_search_path == NULL);\n+\n+  \/* Allocate a buffer which the fork()ed child can use to assemble potential\n+   * paths for the binary to exec(), combining the argv[0] and elements from\n+   * the chosen_search_path. This canโt be done in the child because malloc()\n+   * (or alloca()) are not async-signal-safe (see `man 7 signal-safety`).\n+   *\n+   * Add 2 for the nul terminator and a leading `\/`. *\/\n+  if (chosen_search_path != NULL)\n+    {\n+      search_path_buffer_len = strlen (chosen_search_path) + strlen (argv[0]) + 2;\n+      if (search_path_buffer_len < 4000)\n+        {\n+          \/* Prefer small stack allocations to avoid valgrind leak warnings\n+           * in forked child. The 4000B cutoff is arbitrary. *\/\n+          search_path_buffer = g_alloca (search_path_buffer_len);\n+        }\n+      else\n+        {\n+          search_path_buffer_heap = g_malloc (search_path_buffer_len);\n+          search_path_buffer = search_path_buffer_heap;\n+        }\n+    }\n+\n+  if (search_path || search_path_from_envp)\n+    g_assert (search_path_buffer != NULL);\n+  else\n+    g_assert (search_path_buffer == NULL);\n+\n+  \/* And allocate a buffer which is 2 elements longer than @argv, so that if\n+   * script_execute() has to be called later on, it can build a wrapper argv\n+   * array in this buffer. *\/\n+  argv_buffer_len = g_strv_length ((gchar **) argv) + 2;\n+  if (argv_buffer_len < 4000 \/ sizeof (gchar *))\n+    {\n+      \/* Prefer small stack allocations to avoid valgrind leak warnings\n+       * in forked child. The 4000B cutoff is arbitrary. *\/\n+      argv_buffer = g_newa (gchar *, argv_buffer_len);\n+    }\n+  else\n+    {\n+      argv_buffer_heap = g_new (gchar *, argv_buffer_len);\n+      argv_buffer = argv_buffer_heap;\n+    }\n+\n+  \/* And one to hold a copy of @source_fds for later manipulation in do_exec(). *\/\n+  source_fds_copy = g_new (int, n_fds);\n+  if (n_fds > 0)\n+    memcpy (source_fds_copy, source_fds, sizeof (*source_fds) * n_fds);\n+\n+  if (!g_unix_pipe_open (&child_err_report_pipe, pipe_flags, error))\n+    goto cleanup_and_fail;\n+  if (source_fds_collide_with_pipe (&child_err_report_pipe, source_fds, n_fds, error))\n+    goto cleanup_and_fail;\n+\n+  if (intermediate_child)\n+    {\n+      if (!g_unix_pipe_open (&child_pid_report_pipe, pipe_flags, error))\n+        goto cleanup_and_fail;\n+      if (source_fds_collide_with_pipe (&child_pid_report_pipe, source_fds, n_fds, error))\n+        goto cleanup_and_fail;\n+    }\n+\n+  pid = fork ();\n+\n+  if (pid < 0)\n+    {\n+      int errsv = errno;\n+\n+      g_set_error (error,\n+                   G_SPAWN_ERROR,\n+                   G_SPAWN_ERROR_FORK,\n+                   _(\"Failed to fork (%s)\"),\n+                   g_strerror (errsv));\n+\n+      goto cleanup_and_fail;\n+    }\n+  else if (pid == 0)\n+    {\n+      \/* Immediate child. This may or may not be the child that\n+       * actually execs the new process.\n+       *\/\n+\n+      \/* Reset some signal handlers that we may use *\/\n+      signal (SIGCHLD, SIG_DFL);\n+      signal (SIGINT, SIG_DFL);\n+      signal (SIGTERM, SIG_DFL);\n+      signal (SIGHUP, SIG_DFL);\n+\n+      \/* Be sure we crash if the parent exits\n+       * and we write to the err_report_pipe\n+       *\/\n+      signal (SIGPIPE, SIG_DFL);\n+\n+      \/* Close the parent's end of the pipes;\n+       * not needed in the close_descriptors case,\n+       * though\n+       *\/\n+      g_unix_pipe_close (&child_err_report_pipe, G_UNIX_PIPE_END_READ, NULL);\n+      g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_READ, NULL);\n+      if (child_close_fds[0] != -1)\n+        {\n+           int i = -1;\n+           while (child_close_fds[++i] != -1)\n+             g_clear_fd (&child_close_fds[i], NULL);\n+        }\n+\n+      if (intermediate_child)\n+        {\n+          \/* We need to fork an intermediate child that launches the\n+           * final child. The purpose of the intermediate child\n+           * is to exit, so we can waitpid() it immediately.\n+           * Then the grandchild will not become a zombie.\n+           *\/\n+          GPid grandchild_pid;\n+\n+          grandchild_pid = fork ();\n+\n+          if (grandchild_pid < 0)\n+            {\n+              \/* report -1 as child PID *\/\n+              write_all (g_unix_pipe_get (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE),\n+                         &grandchild_pid, sizeof(grandchild_pid));\n+\n+              write_err_and_exit (g_unix_pipe_get (&child_err_report_pipe, G_UNIX_PIPE_END_WRITE),\n+                                  CHILD_FORK_FAILED);\n+            }\n+          else if (grandchild_pid == 0)\n+            {\n+              g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n+              do_exec (g_unix_pipe_get (&child_err_report_pipe, G_UNIX_PIPE_END_WRITE),\n+                       stdin_fd,\n+                       stdout_fd,\n+                       stderr_fd,\n+                       source_fds_copy,\n+                       target_fds,\n+                       n_fds,\n+                       working_directory,\n+                       argv,\n+                       argv_buffer,\n+                       argv_buffer_len,\n+                       envp,\n+                       close_descriptors,\n+                       chosen_search_path,\n+                       search_path_buffer,\n+                       search_path_buffer_len,\n+                       stdout_to_null,\n+                       stderr_to_null,\n+                       child_inherits_stdin,\n+                       file_and_argv_zero,\n+                       child_setup,\n+                       user_data);\n+            }\n+          else\n+            {\n+              write_all (g_unix_pipe_get (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE),\n+                         &grandchild_pid, sizeof(grandchild_pid));\n+              g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n+\n+              _exit (0);\n+            }\n+        }\n+      else\n+        {\n+          \/* Just run the child.\n+           *\/\n+\n+          do_exec (g_unix_pipe_get (&child_err_report_pipe, G_UNIX_PIPE_END_WRITE),\n+                   stdin_fd,\n+                   stdout_fd,\n+                   stderr_fd,\n+                   source_fds_copy,\n+                   target_fds,\n+                   n_fds,\n+                   working_directory,\n+                   argv,\n+                   argv_buffer,\n+                   argv_buffer_len,\n+                   envp,\n+                   close_descriptors,\n+                   chosen_search_path,\n+                   search_path_buffer,\n+                   search_path_buffer_len,\n+                   stdout_to_null,\n+                   stderr_to_null,\n+                   child_inherits_stdin,\n+                   file_and_argv_zero,\n+                   child_setup,\n+                   user_data);\n+        }\n+    }\n+  else\n+    {\n+      \/* Parent *\/\n+\n+      gint buf[2];\n+      gint n_ints = 0;\n+\n+      \/* Close the uncared-about ends of the pipes *\/\n+      g_unix_pipe_close (&child_err_report_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n+      g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n+\n+      \/* If we had an intermediate child, reap it *\/\n+      if (intermediate_child)\n+        {\n+        wait_again:\n+          if (waitpid (pid, &status, 0) < 0)\n+            {\n+              if (errno == EINTR)\n+                goto wait_again;\n+              else if (errno == ECHILD)\n+                ; \/* do nothing, child already reaped *\/\n+              else\n+                g_warning (\"waitpid() should not fail in 'fork_exec'\");\n+            }\n+        }\n+\n+\n+      if (!read_ints (g_unix_pipe_get (&child_err_report_pipe, G_UNIX_PIPE_END_READ),\n+                      buf, 2, &n_ints,\n+                      error))\n+        goto cleanup_and_fail;\n+\n+      if (n_ints >= 2)\n+        {\n+          \/* Error from the child. *\/\n+\n+          switch (buf[0])\n+            {\n+            case CHILD_CHDIR_FAILED:\n+              g_set_error (error,\n+                           G_SPAWN_ERROR,\n+                           G_SPAWN_ERROR_CHDIR,\n+                           _(\"Failed to change to directory โ%sโ (%s)\"),\n+                           working_directory,\n+                           g_strerror (buf[1]));\n+\n+              break;\n+\n+            case CHILD_EXEC_FAILED:\n+              g_set_error (error,\n+                           G_SPAWN_ERROR,\n+                           _g_spawn_exec_err_to_g_error (buf[1]),\n+                           _(\"Failed to execute child process โ%sโ (%s)\"),\n+                           argv[0],\n+                           g_strerror (buf[1]));\n+\n+              break;\n+\n+            case CHILD_OPEN_FAILED:\n+              g_set_error (error,\n+                           G_SPAWN_ERROR,\n+                           G_SPAWN_ERROR_FAILED,\n+                           _(\"Failed to open file to remap file descriptor (%s)\"),\n+                           g_strerror (buf[1]));\n+              break;\n+\n+            case CHILD_DUPFD_FAILED:\n+              g_set_error (error,\n+                           G_SPAWN_ERROR,\n+                           G_SPAWN_ERROR_FAILED,\n+                           _(\"Failed to duplicate file descriptor for child process (%s)\"),\n+                           g_strerror (buf[1]));\n+\n+              break;\n+\n+            case CHILD_FORK_FAILED:\n+              g_set_error (error,\n+                           G_SPAWN_ERROR,\n+                           G_SPAWN_ERROR_FORK,\n+                           _(\"Failed to fork child process (%s)\"),\n+                           g_strerror (buf[1]));\n+              break;\n+\n+            case CHILD_CLOSE_FAILED:\n+              g_set_error (error,\n+                           G_SPAWN_ERROR,\n+                           G_SPAWN_ERROR_FAILED,\n+                           _(\"Failed to close file descriptor for child process (%s)\"),\n+                           g_strerror (buf[1]));\n+              break;\n+\n+            default:\n+              g_set_error (error,\n+                           G_SPAWN_ERROR,\n+                           G_SPAWN_ERROR_FAILED,\n+                           _(\"Unknown error executing child process โ%sโ\"),\n+                           argv[0]);\n+              break;\n+            }\n+\n+          goto cleanup_and_fail;\n+        }\n+\n+      \/* Get child pid from intermediate child pipe. *\/\n+      if (intermediate_child)\n+        {\n+          n_ints = 0;\n+\n+          if (!read_ints (g_unix_pipe_get (&child_pid_report_pipe, G_UNIX_PIPE_END_READ),\n+                          buf, 1, &n_ints, error))\n+            goto cleanup_and_fail;\n+\n+          if (n_ints < 1)\n+            {\n+              int errsv = errno;\n+\n+              g_set_error (error,\n+                           G_SPAWN_ERROR,\n+                           G_SPAWN_ERROR_FAILED,\n+                           _(\"Failed to read enough data from child pid pipe (%s)\"),\n+                           g_strerror (errsv));\n+              goto cleanup_and_fail;\n+            }\n+          else\n+            {\n+              \/* we have the child pid *\/\n+              pid = buf[0];\n+            }\n+        }\n+\n+      \/* Success against all odds! return the information *\/\n+      g_unix_pipe_close (&child_err_report_pipe, G_UNIX_PIPE_END_READ, NULL);\n+      g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_READ, NULL);\n+\n+      g_free (search_path_buffer_heap);\n+      g_free (argv_buffer_heap);\n+      g_free (source_fds_copy);\n+\n+      if (child_pid)\n+        *child_pid = pid;\n+\n+      goto success;\n+    }\n+\n+success:\n+  \/* Close the uncared-about ends of the pipes *\/\n+  g_unix_pipe_close (&stdin_pipe, G_UNIX_PIPE_END_READ, NULL);\n+  g_unix_pipe_close (&stdout_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n+  g_unix_pipe_close (&stderr_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n+\n+  if (stdin_pipe_out != NULL)\n+    *stdin_pipe_out = g_unix_pipe_steal (&stdin_pipe, G_UNIX_PIPE_END_WRITE);\n+\n+  if (stdout_pipe_out != NULL)\n+    *stdout_pipe_out = g_unix_pipe_steal (&stdout_pipe, G_UNIX_PIPE_END_READ);\n+\n+  if (stderr_pipe_out != NULL)\n+    *stderr_pipe_out = g_unix_pipe_steal (&stderr_pipe, G_UNIX_PIPE_END_READ);\n+\n+  return TRUE;\n+\n+ cleanup_and_fail:\n+\n+  \/* There was an error from the Child, reap the child to avoid it being\n+     a zombie.\n+   *\/\n+\n+  if (pid > 0)\n+  {\n+    wait_failed:\n+     if (waitpid (pid, NULL, 0) < 0)\n+       {\n+          if (errno == EINTR)\n+            goto wait_failed;\n+          else if (errno == ECHILD)\n+            ; \/* do nothing, child already reaped *\/\n+          else\n+            g_warning (\"waitpid() should not fail in 'fork_exec'\");\n+       }\n+   }\n+\n+  g_unix_pipe_clear (&stdin_pipe);\n+  g_unix_pipe_clear (&stdout_pipe);\n+  g_unix_pipe_clear (&stderr_pipe);\n+  g_unix_pipe_clear (&child_err_report_pipe);\n+  g_unix_pipe_clear (&child_pid_report_pipe);\n+\n+  g_clear_pointer (&search_path_buffer_heap, g_free);\n+  g_clear_pointer (&argv_buffer_heap, g_free);\n+  g_clear_pointer (&source_fds_copy, g_free);\n+\n+  return FALSE;\n+}\n+\n+\/* Based on execvp from GNU C Library *\/\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)) until it calls exec(). *\/\n+static gboolean\n+script_execute (const gchar *file,\n+                gchar      **argv,\n+                gchar      **argv_buffer,\n+                gsize        argv_buffer_len,\n+                gchar      **envp)\n+{\n+  \/* Count the arguments.  *\/\n+  gsize argc = 0;\n+  while (argv[argc])\n+    ++argc;\n+\n+  \/* Construct an argument list for the shell. *\/\n+  if (argc + 2 > argv_buffer_len)\n+    return FALSE;\n+\n+  argv_buffer[0] = (char *) \"\/bin\/sh\";\n+  argv_buffer[1] = (char *) file;\n+  while (argc > 0)\n+    {\n+      argv_buffer[argc + 1] = argv[argc];\n+      --argc;\n+    }\n+\n+  \/* Execute the shell. *\/\n+  if (envp)\n+    execve (argv_buffer[0], argv_buffer, envp);\n+  else\n+    execv (argv_buffer[0], argv_buffer);\n+\n+  return TRUE;\n+}\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)). *\/\n+static gchar*\n+my_strchrnul (const gchar *str, gchar c)\n+{\n+  gchar *p = (gchar*) str;\n+  while (*p && (*p != c))\n+    ++p;\n+\n+  return p;\n+}\n+\n+\/* This function is called between fork() and exec() and hence must be\n+ * async-signal-safe (see signal-safety(7)) until it calls exec(). *\/\n+static gint\n+g_execute (const gchar  *file,\n+           gchar       **argv,\n+           gchar       **argv_buffer,\n+           gsize         argv_buffer_len,\n+           gchar       **envp,\n+           const gchar  *search_path,\n+           gchar        *search_path_buffer,\n+           gsize         search_path_buffer_len)\n+{\n+  if (file == NULL || *file == '\\0')\n+    {\n+      \/* We check the simple case first. *\/\n+      errno = ENOENT;\n+      return -1;\n+    }\n+\n+  if (search_path == NULL || strchr (file, '\/') != NULL)\n+    {\n+      \/* Don't search when it contains a slash. *\/\n+      if (envp)\n+        execve (file, argv, envp);\n+      else\n+        execv (file, argv);\n+\n+      if (errno == ENOEXEC &&\n+          !script_execute (file, argv, argv_buffer, argv_buffer_len, envp))\n+        {\n+          errno = ENOMEM;\n+          return -1;\n+        }\n+    }\n+  else\n+    {\n+      gboolean got_eacces = 0;\n+      const gchar *path, *p;\n+      gchar *name;\n+      gsize len;\n+      gsize pathlen;\n+\n+      path = search_path;\n+      len = strlen (file) + 1;\n+      pathlen = strlen (path);\n+      name = search_path_buffer;\n+\n+      if (search_path_buffer_len < pathlen + len + 1)\n+        {\n+          errno = ENOMEM;\n+          return -1;\n+        }\n+\n+      \/* Copy the file name at the top, including '\\0'  *\/\n+      memcpy (name + pathlen + 1, file, len);\n+      name = name + pathlen;\n+      \/* And add the slash before the filename  *\/\n+      *name = '\/';\n+\n+      p = path;\n+      do\n+  {\n+    char *startp;\n+\n+    path = p;\n+    p = my_strchrnul (path, ':');\n+\n+    if (p == path)\n+      \/* Two adjacent colons, or a colon at the beginning or the end\n+             * of 'PATH' means to search the current directory.\n+             *\/\n+      startp = name + 1;\n+    else\n+      startp = memcpy (name - (p - path), path, p - path);\n+\n+    \/* Try to execute this name.  If it works, execv will not return.  *\/\n+          if (envp)\n+            execve (startp, argv, envp);\n+          else\n+            execv (startp, argv);\n+\n+          if (errno == ENOEXEC &&\n+              !script_execute (startp, argv, argv_buffer, argv_buffer_len, envp))\n+            {\n+              errno = ENOMEM;\n+              return -1;\n+            }\n+\n+    switch (errno)\n+      {\n+      case EACCES:\n+        \/* Record the we got a 'Permission denied' error.  If we end\n+               * up finding no executable we can use, we want to diagnose\n+               * that we did find one but were denied access.\n+               *\/\n+        got_eacces = TRUE;\n+\n+              G_GNUC_FALLTHROUGH;\n+      case ENOENT:\n+#ifdef ESTALE\n+      case ESTALE:\n+#endif\n+#ifdef ENOTDIR\n+      case ENOTDIR:\n+#endif\n+        \/* Those errors indicate the file is missing or not executable\n+               * by us, in which case we want to just try the next path\n+               * directory.\n+               *\/\n+        break;\n+\n+      case ENODEV:\n+      case ETIMEDOUT:\n+        \/* Some strange filesystems like AFS return even\n+         * stranger error numbers.  They cannot reasonably mean anything\n+         * else so ignore those, too.\n+         *\/\n+        break;\n+\n+      default:\n+        \/* Some other error means we found an executable file, but\n+               * something went wrong executing it; return the error to our\n+               * caller.\n+               *\/\n+        return -1;\n+      }\n+  }\n+      while (*p++ != '\\0');\n+\n+      \/* We tried every element and none of them worked.  *\/\n+      if (got_eacces)\n+        \/* At least one failure was due to permissions, so report that\n+         * error.\n+         *\/\n+        errno = EACCES;\n+    }\n+\n+  \/* Return the error from the last attempt (probably ENOENT).  *\/\n+  return -1;\n+}\n+\n+void\n+g_spawn_close_pid_impl (GPid pid)\n+{\n+  \/* no-op *\/\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gspawn-posix.c","additions":1992,"deletions":0,"binary":false,"changes":1992,"status":"added"},{"patch":"@@ -30,0 +30,32 @@\n+\/* Platform-specific implementation functions. *\/\n+gboolean g_spawn_sync_impl (const gchar           *working_directory,\n+                            gchar                **argv,\n+                            gchar                **envp,\n+                            GSpawnFlags            flags,\n+                            GSpawnChildSetupFunc   child_setup,\n+                            gpointer               user_data,\n+                            gchar                **standard_output,\n+                            gchar                **standard_error,\n+                            gint                  *wait_status,\n+                            GError               **error);\n+gboolean g_spawn_async_with_pipes_and_fds_impl (const gchar           *working_directory,\n+                                                const gchar * const   *argv,\n+                                                const gchar * const   *envp,\n+                                                GSpawnFlags            flags,\n+                                                GSpawnChildSetupFunc   child_setup,\n+                                                gpointer               user_data,\n+                                                gint                   stdin_fd,\n+                                                gint                   stdout_fd,\n+                                                gint                   stderr_fd,\n+                                                const gint            *source_fds,\n+                                                const gint            *target_fds,\n+                                                gsize                  n_fds,\n+                                                GPid                  *child_pid_out,\n+                                                gint                  *stdin_pipe_out,\n+                                                gint                  *stdout_pipe_out,\n+                                                gint                  *stderr_pipe_out,\n+                                                GError               **error);\n+gboolean g_spawn_check_wait_status_impl (gint     wait_status,\n+                                         GError **error);\n+void g_spawn_close_pid_impl (GPid pid);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gspawn-private.h","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -348,22 +348,0 @@\n-gboolean\n-g_spawn_async (const gchar          *working_directory,\n-               gchar               **argv,\n-               gchar               **envp,\n-               GSpawnFlags           flags,\n-               GSpawnChildSetupFunc  child_setup,\n-               gpointer              user_data,\n-               GPid                 *child_pid,\n-               GError              **error)\n-{\n-  g_return_val_if_fail (argv != NULL && argv[0] != NULL, FALSE);\n-\n-  return g_spawn_async_with_pipes (working_directory,\n-                                   argv, envp,\n-                                   flags,\n-                                   child_setup,\n-                                   user_data,\n-                                   child_pid,\n-                                   NULL, NULL, NULL,\n-                                   error);\n-}\n-\n@@ -1109,10 +1087,10 @@\n-g_spawn_sync (const gchar          *working_directory,\n-              gchar               **argv,\n-              gchar               **envp,\n-              GSpawnFlags           flags,\n-              GSpawnChildSetupFunc  child_setup,\n-              gpointer              user_data,\n-              gchar               **standard_output,\n-              gchar               **standard_error,\n-              gint                 *wait_status,\n-              GError              **error)\n+g_spawn_sync_impl (const gchar           *working_directory,\n+                   gchar                **argv,\n+                   gchar                **envp,\n+                   GSpawnFlags            flags,\n+                   GSpawnChildSetupFunc   child_setup,\n+                   gpointer               user_data,\n+                   gchar                **standard_output,\n+                   gchar                **standard_error,\n+                   gint                  *wait_status,\n+                   GError               **error)\n@@ -1356,102 +1334,17 @@\n-g_spawn_async_with_pipes (const gchar          *working_directory,\n-                          gchar               **argv,\n-                          gchar               **envp,\n-                          GSpawnFlags           flags,\n-                          GSpawnChildSetupFunc  child_setup,\n-                          gpointer              user_data,\n-                          GPid                 *child_pid,\n-                          gint                 *standard_input,\n-                          gint                 *standard_output,\n-                          gint                 *standard_error,\n-                          GError              **error)\n-{\n-  g_return_val_if_fail (argv != NULL && argv[0] != NULL, FALSE);\n-  g_return_val_if_fail (standard_output == NULL ||\n-                        !(flags & G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);\n-  g_return_val_if_fail (standard_error == NULL ||\n-                        !(flags & G_SPAWN_STDERR_TO_DEV_NULL), FALSE);\n-  \/* can't inherit stdin if we have an input pipe. *\/\n-  g_return_val_if_fail (standard_input == NULL ||\n-                        !(flags & G_SPAWN_CHILD_INHERITS_STDIN), FALSE);\n-\n-  return fork_exec (NULL,\n-                    (flags & G_SPAWN_DO_NOT_REAP_CHILD),\n-                    working_directory,\n-                    (const gchar * const *) argv,\n-                    (const gchar * const *) envp,\n-                    flags,\n-                    child_setup,\n-                    user_data,\n-                    child_pid,\n-                    standard_input,\n-                    standard_output,\n-                    standard_error,\n-                    -1,\n-                    -1,\n-                    -1,\n-                    NULL, NULL, 0,\n-                    NULL,\n-                    error);\n-}\n-\n-gboolean\n-g_spawn_async_with_fds (const gchar          *working_directory,\n-                        gchar               **argv,\n-                        gchar               **envp,\n-                        GSpawnFlags           flags,\n-                        GSpawnChildSetupFunc  child_setup,\n-                        gpointer              user_data,\n-                        GPid                 *child_pid,\n-                        gint                  stdin_fd,\n-                        gint                  stdout_fd,\n-                        gint                  stderr_fd,\n-                        GError              **error)\n-{\n-  g_return_val_if_fail (argv != NULL && argv[0] != NULL, FALSE);\n-  g_return_val_if_fail (stdin_fd == -1 ||\n-                        !(flags & G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);\n-  g_return_val_if_fail (stderr_fd == -1 ||\n-                        !(flags & G_SPAWN_STDERR_TO_DEV_NULL), FALSE);\n-  \/* can't inherit stdin if we have an input pipe. *\/\n-  g_return_val_if_fail (stdin_fd == -1 ||\n-                        !(flags & G_SPAWN_CHILD_INHERITS_STDIN), FALSE);\n-\n-  return fork_exec (NULL,\n-                    (flags & G_SPAWN_DO_NOT_REAP_CHILD),\n-                    working_directory,\n-                    (const gchar * const *) argv,\n-                    (const gchar * const *) envp,\n-                    flags,\n-                    child_setup,\n-                    user_data,\n-                    child_pid,\n-                    NULL,\n-                    NULL,\n-                    NULL,\n-                    stdin_fd,\n-                    stdout_fd,\n-                    stderr_fd,\n-                    NULL, NULL, 0,\n-                    NULL,\n-                    error);\n-\n-}\n-\n-gboolean\n-g_spawn_async_with_pipes_and_fds (const gchar           *working_directory,\n-                                  const gchar * const   *argv,\n-                                  const gchar * const   *envp,\n-                                  GSpawnFlags            flags,\n-                                  GSpawnChildSetupFunc   child_setup,\n-                                  gpointer               user_data,\n-                                  gint                   stdin_fd,\n-                                  gint                   stdout_fd,\n-                                  gint                   stderr_fd,\n-                                  const gint            *source_fds,\n-                                  const gint            *target_fds,\n-                                  gsize                  n_fds,\n-                                  GPid                  *child_pid_out,\n-                                  gint                  *stdin_pipe_out,\n-                                  gint                  *stdout_pipe_out,\n-                                  gint                  *stderr_pipe_out,\n-                                  GError               **error)\n+g_spawn_async_with_pipes_and_fds_impl (const gchar           *working_directory,\n+                                       const gchar * const   *argv,\n+                                       const gchar * const   *envp,\n+                                       GSpawnFlags            flags,\n+                                       GSpawnChildSetupFunc   child_setup,\n+                                       gpointer               user_data,\n+                                       gint                   stdin_fd,\n+                                       gint                   stdout_fd,\n+                                       gint                   stderr_fd,\n+                                       const gint            *source_fds,\n+                                       const gint            *target_fds,\n+                                       gsize                  n_fds,\n+                                       GPid                  *child_pid_out,\n+                                       gint                  *stdin_pipe_out,\n+                                       gint                  *stdout_pipe_out,\n+                                       gint                  *stderr_pipe_out,\n+                                       GError               **error)\n@@ -1494,61 +1387,0 @@\n-gboolean\n-g_spawn_command_line_sync (const gchar  *command_line,\n-                           gchar       **standard_output,\n-                           gchar       **standard_error,\n-                           gint         *wait_status,\n-                           GError      **error)\n-{\n-  gboolean retval;\n-  gchar **argv = 0;\n-\n-  g_return_val_if_fail (command_line != NULL, FALSE);\n-\n-  \/* This will return a runtime error if @command_line is the empty string. *\/\n-  if (!g_shell_parse_argv (command_line,\n-                           NULL, &argv,\n-                           error))\n-    return FALSE;\n-\n-  retval = g_spawn_sync (NULL,\n-                         argv,\n-                         NULL,\n-                         G_SPAWN_SEARCH_PATH,\n-                         NULL,\n-                         NULL,\n-                         standard_output,\n-                         standard_error,\n-                         wait_status,\n-                         error);\n-  g_strfreev (argv);\n-\n-  return retval;\n-}\n-\n-gboolean\n-g_spawn_command_line_async (const gchar *command_line,\n-                            GError     **error)\n-{\n-  gboolean retval;\n-  gchar **argv = 0;\n-\n-  g_return_val_if_fail (command_line != NULL, FALSE);\n-\n-  \/* This will return a runtime error if @command_line is the empty string. *\/\n-  if (!g_shell_parse_argv (command_line,\n-                           NULL, &argv,\n-                           error))\n-    return FALSE;\n-\n-  retval = g_spawn_async (NULL,\n-                          argv,\n-                          NULL,\n-                          G_SPAWN_SEARCH_PATH,\n-                          NULL,\n-                          NULL,\n-                          NULL,\n-                          error);\n-  g_strfreev (argv);\n-\n-  return retval;\n-}\n-\n@@ -1556,1 +1388,1 @@\n-g_spawn_close_pid (GPid pid)\n+g_spawn_close_pid_impl (GPid pid)\n@@ -1565,2 +1397,2 @@\n-g_spawn_check_wait_status (gint      wait_status,\n-         GError  **error)\n+g_spawn_check_wait_status_impl (gint     wait_status,\n+                                GError **error)\n@@ -1585,7 +1417,0 @@\n-gboolean\n-g_spawn_check_exit_status (gint      wait_status,\n-                           GError  **error)\n-{\n-  return g_spawn_check_wait_status (wait_status, error);\n-}\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gspawn-win32.c","additions":30,"deletions":205,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -25,32 +25,0 @@\n-#include <sys\/time.h>\n-#include <sys\/types.h>\n-#include <sys\/wait.h>\n-#include <unistd.h>\n-#include <errno.h>\n-#include <fcntl.h>\n-#include <signal.h>\n-#include <string.h>\n-#include <stdlib.h>   \/* for fdwalk *\/\n-#include <dirent.h>\n-#include <unistd.h>\n-\n-#ifdef HAVE_SPAWN_H\n-#include <spawn.h>\n-#endif \/* HAVE_SPAWN_H *\/\n-\n-#ifdef HAVE_CRT_EXTERNS_H\n-#include <crt_externs.h> \/* for _NSGetEnviron *\/\n-#endif\n-\n-#ifdef HAVE_SYS_SELECT_H\n-#include <sys\/select.h>\n-#endif \/* HAVE_SYS_SELECT_H *\/\n-\n-#ifdef HAVE_SYS_RESOURCE_H\n-#include <sys\/resource.h>\n-#endif \/* HAVE_SYS_RESOURCE_H *\/\n-\n-#if defined(__linux__) || defined(__DragonFly__)\n-#include <sys\/syscall.h>  \/* for syscall and SYS_getdents64 *\/\n-#endif\n-\n@@ -59,3 +27,0 @@\n-#include \"gthread.h\"\n-#include \"gtrace-private.h\"\n-#include \"glib\/gstdio.h\"\n@@ -63,2 +28,1 @@\n-#include \"genviron.h\"\n-#include \"gmem.h\"\n+#include \"gmessages.h\"\n@@ -66,11 +30,0 @@\n-#include \"gstring.h\"\n-#include \"gstrfuncs.h\"\n-#include \"gtestutils.h\"\n-#include \"gutils.h\"\n-#include \"glibintl.h\"\n-#include \"glib-unix.h\"\n-\n-#if defined(__APPLE__) && defined(HAVE_LIBPROC_H)\n-#include <libproc.h>\n-#include <sys\/proc_info.h>\n-#endif\n@@ -82,69 +35,0 @@\n-#define IS_STD_FILENO(_fd) ((_fd >= STDIN_FILENO) && (_fd <= STDERR_FILENO))\n-#define IS_VALID_FILENO(_fd) (_fd >= 0)\n-\n-\/* posix_spawn() is assumed the fastest way to spawn, but glibc's\n- * implementation was buggy before glibc 2.24, so avoid it on old versions.\n- *\/\n-#ifdef HAVE_POSIX_SPAWN\n-#ifdef __GLIBC__\n-\n-#if __GLIBC_PREREQ(2,24)\n-#define POSIX_SPAWN_AVAILABLE\n-#endif\n-\n-#else \/* !__GLIBC__ *\/\n-\/* Assume that all non-glibc posix_spawn implementations are fine. *\/\n-#define POSIX_SPAWN_AVAILABLE\n-#endif \/* __GLIBC__ *\/\n-#endif \/* HAVE_POSIX_SPAWN *\/\n-\n-#ifdef HAVE__NSGETENVIRON\n-#define environ (*_NSGetEnviron())\n-#else\n-extern char **environ;\n-#endif\n-\n-#ifndef O_CLOEXEC\n-#define O_CLOEXEC 0\n-#else\n-#define HAVE_O_CLOEXEC 1\n-#endif\n-\n-static gint g_execute (const gchar  *file,\n-                       gchar       **argv,\n-                       gchar       **argv_buffer,\n-                       gsize         argv_buffer_len,\n-                       gchar       **envp,\n-                       const gchar  *search_path,\n-                       gchar        *search_path_buffer,\n-                       gsize         search_path_buffer_len);\n-\n-static gboolean fork_exec (gboolean              intermediate_child,\n-                           const gchar          *working_directory,\n-                           const gchar * const  *argv,\n-                           const gchar * const  *envp,\n-                           gboolean              close_descriptors,\n-                           gboolean              search_path,\n-                           gboolean              search_path_from_envp,\n-                           gboolean              stdout_to_null,\n-                           gboolean              stderr_to_null,\n-                           gboolean              child_inherits_stdin,\n-                           gboolean              file_and_argv_zero,\n-                           gboolean              cloexec_pipes,\n-                           GSpawnChildSetupFunc  child_setup,\n-                           gpointer              user_data,\n-                           GPid                 *child_pid,\n-                           gint                 *stdin_pipe_out,\n-                           gint                 *stdout_pipe_out,\n-                           gint                 *stderr_pipe_out,\n-                           gint                  stdin_fd,\n-                           gint                  stdout_fd,\n-                           gint                  stderr_fd,\n-                           const gint           *source_fds,\n-                           const gint           *target_fds,\n-                           gsize                 n_fds,\n-                           GError              **error);\n-\n-G_DEFINE_QUARK (g-exec-error-quark, g_spawn_error)\n-G_DEFINE_QUARK (g-spawn-exit-error-quark, g_spawn_exit_error)\n-\n@@ -205,44 +89,0 @@\n-\/* Some versions of OS X define READ_OK in public headers *\/\n-#undef READ_OK\n-\n-typedef enum\n-{\n-  READ_FAILED = 0, \/* FALSE *\/\n-  READ_OK,\n-  READ_EOF\n-} ReadResult;\n-\n-static ReadResult\n-read_data (GString *str,\n-           gint     fd,\n-           GError **error)\n-{\n-  gssize bytes;\n-  gchar buf[4096];\n-\n- again:\n-  bytes = read (fd, buf, 4096);\n-\n-  if (bytes == 0)\n-    return READ_EOF;\n-  else if (bytes > 0)\n-    {\n-      g_string_append_len (str, buf, bytes);\n-      return READ_OK;\n-    }\n-  else if (errno == EINTR)\n-    goto again;\n-  else\n-    {\n-      int errsv = errno;\n-\n-      g_set_error (error,\n-                   G_SPAWN_ERROR,\n-                   G_SPAWN_ERROR_READ,\n-                   _(\"Failed to read data from child process (%s)\"),\n-                   g_strerror (errsv));\n-\n-      return READ_FAILED;\n-    }\n-}\n-\n@@ -293,10 +133,10 @@\n-g_spawn_sync (const gchar          *working_directory,\n-              gchar               **argv,\n-              gchar               **envp,\n-              GSpawnFlags           flags,\n-              GSpawnChildSetupFunc  child_setup,\n-              gpointer              user_data,\n-              gchar               **standard_output,\n-              gchar               **standard_error,\n-              gint                 *wait_status,\n-              GError              **error)\n+g_spawn_sync (const gchar           *working_directory,\n+              gchar                **argv,\n+              gchar                **envp,\n+              GSpawnFlags            flags,\n+              GSpawnChildSetupFunc   child_setup,\n+              gpointer               user_data,\n+              gchar                **standard_output,\n+              gchar                **standard_error,\n+              gint                  *wait_status,\n+              GError               **error)\n@@ -304,9 +144,0 @@\n-  gint outpipe = -1;\n-  gint errpipe = -1;\n-  GPid pid;\n-  gint ret;\n-  GString *outstr = NULL;\n-  GString *errstr = NULL;\n-  gboolean failed;\n-  gint status;\n-\n@@ -321,182 +152,3 @@\n-  \/* Just to ensure segfaults if callers try to use\n-   * these when an error is reported.\n-   *\/\n-  if (standard_output)\n-    *standard_output = NULL;\n-\n-  if (standard_error)\n-    *standard_error = NULL;\n-\n-  if (!fork_exec (FALSE,\n-                  working_directory,\n-                  (const gchar * const *) argv,\n-                  (const gchar * const *) envp,\n-                  !(flags & G_SPAWN_LEAVE_DESCRIPTORS_OPEN),\n-                  (flags & G_SPAWN_SEARCH_PATH) != 0,\n-                  (flags & G_SPAWN_SEARCH_PATH_FROM_ENVP) != 0,\n-                  (flags & G_SPAWN_STDOUT_TO_DEV_NULL) != 0,\n-                  (flags & G_SPAWN_STDERR_TO_DEV_NULL) != 0,\n-                  (flags & G_SPAWN_CHILD_INHERITS_STDIN) != 0,\n-                  (flags & G_SPAWN_FILE_AND_ARGV_ZERO) != 0,\n-                  (flags & G_SPAWN_CLOEXEC_PIPES) != 0,\n-                  child_setup,\n-                  user_data,\n-                  &pid,\n-                  NULL,\n-                  standard_output ? &outpipe : NULL,\n-                  standard_error ? &errpipe : NULL,\n-                  -1, -1, -1,\n-                  NULL, NULL, 0,\n-                  error))\n-    return FALSE;\n-\n-  \/* Read data from child. *\/\n-\n-  failed = FALSE;\n-\n-  if (outpipe >= 0)\n-    {\n-      outstr = g_string_new (NULL);\n-    }\n-\n-  if (errpipe >= 0)\n-    {\n-      errstr = g_string_new (NULL);\n-    }\n-\n-  \/* Read data until we get EOF on both pipes. *\/\n-  while (!failed &&\n-         (outpipe >= 0 ||\n-          errpipe >= 0))\n-    {\n-      \/* Any negative FD in the array is ignored, so we can use a fixed length.\n-       * We can use UNIX FDs here without worrying about Windows HANDLEs because\n-       * the Windows implementation is entirely in gspawn-win32.c. *\/\n-      GPollFD fds[] =\n-        {\n-          { outpipe, G_IO_IN | G_IO_HUP | G_IO_ERR, 0 },\n-          { errpipe, G_IO_IN | G_IO_HUP | G_IO_ERR, 0 },\n-        };\n-\n-      ret = g_poll (fds, G_N_ELEMENTS (fds), -1  \/* no timeout *\/);\n-\n-      if (ret < 0)\n-        {\n-          int errsv = errno;\n-\n-    if (errno == EINTR)\n-      continue;\n-\n-          failed = TRUE;\n-\n-          g_set_error (error,\n-                       G_SPAWN_ERROR,\n-                       G_SPAWN_ERROR_READ,\n-                       _(\"Unexpected error in reading data from a child process (%s)\"),\n-                       g_strerror (errsv));\n-\n-          break;\n-        }\n-\n-      if (outpipe >= 0 && fds[0].revents != 0)\n-        {\n-          switch (read_data (outstr, outpipe, error))\n-            {\n-            case READ_FAILED:\n-              failed = TRUE;\n-              break;\n-            case READ_EOF:\n-              g_clear_fd (&outpipe, NULL);\n-              break;\n-            default:\n-              break;\n-            }\n-\n-          if (failed)\n-            break;\n-        }\n-\n-      if (errpipe >= 0 && fds[1].revents != 0)\n-        {\n-          switch (read_data (errstr, errpipe, error))\n-            {\n-            case READ_FAILED:\n-              failed = TRUE;\n-              break;\n-            case READ_EOF:\n-              g_clear_fd (&errpipe, NULL);\n-              break;\n-            default:\n-              break;\n-            }\n-\n-          if (failed)\n-            break;\n-        }\n-    }\n-\n-  \/* These should only be open still if we had an error.  *\/\n-  g_clear_fd (&outpipe, NULL);\n-  g_clear_fd (&errpipe, NULL);\n-\n-  \/* Wait for child to exit, even if we have\n-   * an error pending.\n-   *\/\n- again:\n-\n-  ret = waitpid (pid, &status, 0);\n-\n-  if (ret < 0)\n-    {\n-      if (errno == EINTR)\n-        goto again;\n-      else if (errno == ECHILD)\n-        {\n-          if (wait_status)\n-            {\n-              g_warning (\"In call to g_spawn_sync(), wait status of a child process was requested but ECHILD was received by waitpid(). See the documentation of g_child_watch_source_new() for possible causes.\");\n-            }\n-          else\n-            {\n-              \/* We don't need the wait status. *\/\n-            }\n-        }\n-      else\n-        {\n-          if (!failed) \/* avoid error pileups *\/\n-            {\n-              int errsv = errno;\n-\n-              failed = TRUE;\n-\n-              g_set_error (error,\n-                           G_SPAWN_ERROR,\n-                           G_SPAWN_ERROR_READ,\n-                           _(\"Unexpected error in waitpid() (%s)\"),\n-                           g_strerror (errsv));\n-            }\n-        }\n-    }\n-\n-  if (failed)\n-    {\n-      if (outstr)\n-        g_string_free (outstr, TRUE);\n-      if (errstr)\n-        g_string_free (errstr, TRUE);\n-\n-      return FALSE;\n-    }\n-  else\n-    {\n-      if (wait_status)\n-        *wait_status = status;\n-\n-      if (standard_output)\n-        *standard_output = g_string_free (outstr, FALSE);\n-\n-      if (standard_error)\n-        *standard_error = g_string_free (errstr, FALSE);\n-\n-      return TRUE;\n-    }\n+  return g_spawn_sync_impl (working_directory, argv, envp, flags, child_setup,\n+                            user_data, standard_output, standard_error,\n+                            wait_status, error);\n@@ -812,32 +464,8 @@\n-  if ((flags & INHERITS_OR_NULL_STDIN) != 0)\n-    stdin_pipe_out = NULL;\n-  if ((flags & INHERITS_OR_NULL_STDOUT) != 0)\n-    stdout_pipe_out = NULL;\n-  if ((flags & INHERITS_OR_NULL_STDERR) != 0)\n-    stderr_pipe_out = NULL;\n-\n-  return fork_exec (!(flags & G_SPAWN_DO_NOT_REAP_CHILD),\n-                    working_directory,\n-                    (const gchar * const *) argv,\n-                    (const gchar * const *) envp,\n-                    !(flags & G_SPAWN_LEAVE_DESCRIPTORS_OPEN),\n-                    (flags & G_SPAWN_SEARCH_PATH) != 0,\n-                    (flags & G_SPAWN_SEARCH_PATH_FROM_ENVP) != 0,\n-                    (flags & G_SPAWN_STDOUT_TO_DEV_NULL) != 0,\n-                    (flags & G_SPAWN_STDERR_TO_DEV_NULL) != 0,\n-                    (flags & G_SPAWN_CHILD_INHERITS_STDIN) != 0,\n-                    (flags & G_SPAWN_FILE_AND_ARGV_ZERO) != 0,\n-                    (flags & G_SPAWN_CLOEXEC_PIPES) != 0,\n-                    child_setup,\n-                    user_data,\n-                    child_pid_out,\n-                    stdin_pipe_out,\n-                    stdout_pipe_out,\n-                    stderr_pipe_out,\n-                    stdin_fd,\n-                    stdout_fd,\n-                    stderr_fd,\n-                    source_fds,\n-                    target_fds,\n-                    n_fds,\n-                    error);\n+  return g_spawn_async_with_pipes_and_fds_impl (working_directory, argv,\n+                                                envp, flags, child_setup,\n+                                                user_data, stdin_fd, stdout_fd,\n+                                                stderr_fd,\n+                                                source_fds, target_fds, n_fds,\n+                                                child_pid_out, stdin_pipe_out,\n+                                                stdout_pipe_out,\n+                                                stderr_pipe_out, error);\n@@ -884,2 +512,0 @@\n-  g_return_val_if_fail (argv != NULL, FALSE);\n-  g_return_val_if_fail (argv[0] != NULL, FALSE);\n@@ -894,21 +520,9 @@\n-  return fork_exec (!(flags & G_SPAWN_DO_NOT_REAP_CHILD),\n-                    working_directory,\n-                    (const gchar * const *) argv,\n-                    (const gchar * const *) envp,\n-                    !(flags & G_SPAWN_LEAVE_DESCRIPTORS_OPEN),\n-                    (flags & G_SPAWN_SEARCH_PATH) != 0,\n-                    (flags & G_SPAWN_SEARCH_PATH_FROM_ENVP) != 0,\n-                    (flags & G_SPAWN_STDOUT_TO_DEV_NULL) != 0,\n-                    (flags & G_SPAWN_STDERR_TO_DEV_NULL) != 0,\n-                    (flags & G_SPAWN_CHILD_INHERITS_STDIN) != 0,\n-                    (flags & G_SPAWN_FILE_AND_ARGV_ZERO) != 0,\n-                    (flags & G_SPAWN_CLOEXEC_PIPES) != 0,\n-                    child_setup,\n-                    user_data,\n-                    child_pid,\n-                    NULL, NULL, NULL,\n-                    stdin_fd,\n-                    stdout_fd,\n-                    stderr_fd,\n-                    NULL, NULL, 0,\n-                    error);\n+  return g_spawn_async_with_pipes_and_fds (working_directory,\n+                                           (const gchar * const *) argv,\n+                                           (const gchar * const *) envp,\n+                                           flags, child_setup, user_data,\n+                                           stdin_fd, stdout_fd, stderr_fd,\n+                                           NULL, NULL, 0,\n+                                           child_pid,\n+                                           NULL, NULL, NULL,\n+                                           error);\n@@ -1090,36 +704,1 @@\n-  gboolean ret = FALSE;\n-\n-  if (WIFEXITED (wait_status))\n-    {\n-      if (WEXITSTATUS (wait_status) != 0)\n-        {\n-          g_set_error (error, G_SPAWN_EXIT_ERROR, WEXITSTATUS (wait_status),\n-                       _(\"Child process exited with code %ld\"),\n-                       (long) WEXITSTATUS (wait_status));\n-          goto out;\n-        }\n-    }\n-  else if (WIFSIGNALED (wait_status))\n-    {\n-      g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,\n-                   _(\"Child process killed by signal %ld\"),\n-                   (long) WTERMSIG (wait_status));\n-      goto out;\n-    }\n-  else if (WIFSTOPPED (wait_status))\n-    {\n-      g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,\n-                   _(\"Child process stopped by signal %ld\"),\n-                   (long) WSTOPSIG (wait_status));\n-      goto out;\n-    }\n-  else\n-    {\n-      g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,\n-                   _(\"Child process exited abnormally\"));\n-      goto out;\n-    }\n-\n-  ret = TRUE;\n- out:\n-  return ret;\n+  return g_spawn_check_wait_status_impl (wait_status, error);\n@@ -1156,1474 +735,0 @@\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)). *\/\n-static gssize\n-write_all (gint fd, gconstpointer vbuf, gsize to_write)\n-{\n-  gchar *buf = (gchar *) vbuf;\n-\n-  while (to_write > 0)\n-    {\n-      gssize count = write (fd, buf, to_write);\n-      if (count < 0)\n-        {\n-          if (errno != EINTR)\n-            return FALSE;\n-        }\n-      else\n-        {\n-          to_write -= count;\n-          buf += count;\n-        }\n-    }\n-\n-  return TRUE;\n-}\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)). *\/\n-G_NORETURN\n-static void\n-write_err_and_exit (gint fd, gint msg)\n-{\n-  gint en = errno;\n-\n-  write_all (fd, &msg, sizeof(msg));\n-  write_all (fd, &en, sizeof(en));\n-\n-  _exit (1);\n-}\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)). *\/\n-static void\n-set_cloexec (int fd)\n-{\n-  fcntl (fd, F_SETFD, FD_CLOEXEC);\n-}\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)). *\/\n-static void\n-unset_cloexec (int fd)\n-{\n-  int flags;\n-  int result;\n-\n-  flags = fcntl (fd, F_GETFD, 0);\n-\n-  if (flags != -1)\n-    {\n-      int errsv;\n-      flags &= (~FD_CLOEXEC);\n-      do\n-        {\n-          result = fcntl (fd, F_SETFD, flags);\n-          errsv = errno;\n-        }\n-      while (result == -1 && errsv == EINTR);\n-    }\n-}\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)). *\/\n-static int\n-dupfd_cloexec (int old_fd, int new_fd_min)\n-{\n-  int fd, errsv;\n-#ifdef F_DUPFD_CLOEXEC\n-  do\n-    {\n-      fd = fcntl (old_fd, F_DUPFD_CLOEXEC, new_fd_min);\n-      errsv = errno;\n-    }\n-  while (fd == -1 && errsv == EINTR);\n-#else\n-  \/* OS X Snow Lion and earlier don't have F_DUPFD_CLOEXEC:\n-   * https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=710962\n-   *\/\n-  int result, flags;\n-  do\n-    {\n-      fd = fcntl (old_fd, F_DUPFD, new_fd_min);\n-      errsv = errno;\n-    }\n-  while (fd == -1 && errsv == EINTR);\n-  flags = fcntl (fd, F_GETFD, 0);\n-  if (flags != -1)\n-    {\n-      flags |= FD_CLOEXEC;\n-      do\n-        {\n-          result = fcntl (fd, F_SETFD, flags);\n-          errsv = errno;\n-        }\n-      while (result == -1 && errsv == EINTR);\n-    }\n-#endif\n-  return fd;\n-}\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)). *\/\n-static gint\n-safe_dup2 (gint fd1, gint fd2)\n-{\n-  gint ret;\n-\n-  do\n-    ret = dup2 (fd1, fd2);\n-  while (ret < 0 && (errno == EINTR || errno == EBUSY));\n-\n-  return ret;\n-}\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)). *\/\n-static gboolean\n-relocate_fd_out_of_standard_range (gint *fd)\n-{\n-  gint ret = -1;\n-  const int min_fileno = STDERR_FILENO + 1;\n-\n-  do\n-    ret = fcntl (*fd, F_DUPFD, min_fileno);\n-  while (ret < 0 && errno == EINTR);\n-\n-  \/* Note we don't need to close the old fd, because the caller is expected\n-   * to close fds in the standard range itself.\n-   *\/\n-  if (ret >= min_fileno)\n-    {\n-      *fd = ret;\n-      return TRUE;\n-    }\n-\n-  return FALSE;\n-}\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)). *\/\n-static gint\n-safe_open (const char *path, gint mode)\n-{\n-  gint ret;\n-\n-  do\n-    ret = open (path, mode);\n-  while (ret < 0 && errno == EINTR);\n-\n-  return ret;\n-}\n-\n-enum\n-{\n-  CHILD_CHDIR_FAILED,\n-  CHILD_EXEC_FAILED,\n-  CHILD_OPEN_FAILED,\n-  CHILD_DUPFD_FAILED,\n-  CHILD_FORK_FAILED,\n-  CHILD_CLOSE_FAILED,\n-};\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)) until it calls exec().\n- *\n- * All callers must guarantee that @argv and @argv[0] are non-NULL. *\/\n-static void\n-do_exec (gint                  child_err_report_fd,\n-         gint                  stdin_fd,\n-         gint                  stdout_fd,\n-         gint                  stderr_fd,\n-         gint                 *source_fds,\n-         const gint           *target_fds,\n-         gsize                 n_fds,\n-         const gchar          *working_directory,\n-         const gchar * const  *argv,\n-         gchar               **argv_buffer,\n-         gsize                 argv_buffer_len,\n-         const gchar * const  *envp,\n-         gboolean              close_descriptors,\n-         const gchar          *search_path,\n-         gchar                *search_path_buffer,\n-         gsize                 search_path_buffer_len,\n-         gboolean              stdout_to_null,\n-         gboolean              stderr_to_null,\n-         gboolean              child_inherits_stdin,\n-         gboolean              file_and_argv_zero,\n-         GSpawnChildSetupFunc  child_setup,\n-         gpointer              user_data)\n-{\n-  gsize i;\n-  gint max_target_fd = 0;\n-\n-  if (working_directory && chdir (working_directory) < 0)\n-    write_err_and_exit (child_err_report_fd,\n-                        CHILD_CHDIR_FAILED);\n-\n-  \/* It's possible the caller assigned stdin to an fd with a\n-   * file number that is supposed to be reserved for\n-   * stdout or stderr.\n-   *\n-   * If so, move it up out of the standard range, so it doesn't\n-   * cause a conflict.\n-   *\/\n-  if (IS_STD_FILENO (stdin_fd) && stdin_fd != STDIN_FILENO)\n-    {\n-      int old_fd = stdin_fd;\n-\n-      if (!relocate_fd_out_of_standard_range (&stdin_fd))\n-        write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n-\n-      if (stdout_fd == old_fd)\n-        stdout_fd = stdin_fd;\n-\n-      if (stderr_fd == old_fd)\n-        stderr_fd = stdin_fd;\n-    }\n-\n-  \/* Redirect pipes as required\n-   *\n-   * There are two cases where we don't need to do the redirection\n-   * 1. Where the associated file descriptor is cleared\/invalid\n-   * 2. When the associated file descriptor is already given the\n-   * correct file number.\n-   *\/\n-  if (IS_VALID_FILENO (stdin_fd) && stdin_fd != STDIN_FILENO)\n-    {\n-      if (safe_dup2 (stdin_fd, 0) < 0)\n-        write_err_and_exit (child_err_report_fd,\n-                            CHILD_DUPFD_FAILED);\n-\n-      set_cloexec (stdin_fd);\n-    }\n-  else if (!child_inherits_stdin)\n-    {\n-      \/* Keep process from blocking on a read of stdin *\/\n-      gint read_null = safe_open (\"\/dev\/null\", O_RDONLY);\n-      if (read_null < 0)\n-        write_err_and_exit (child_err_report_fd,\n-                            CHILD_OPEN_FAILED);\n-      if (safe_dup2 (read_null, 0) < 0)\n-        write_err_and_exit (child_err_report_fd,\n-                            CHILD_DUPFD_FAILED);\n-      g_clear_fd (&read_null, NULL);\n-    }\n-\n-  \/* Like with stdin above, it's possible the caller assigned\n-   * stdout to an fd with a file number that's intruding on the\n-   * standard range.\n-   *\n-   * If so, move it out of the way, too.\n-   *\/\n-  if (IS_STD_FILENO (stdout_fd) && stdout_fd != STDOUT_FILENO)\n-    {\n-      int old_fd = stdout_fd;\n-\n-      if (!relocate_fd_out_of_standard_range (&stdout_fd))\n-        write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n-\n-      if (stderr_fd == old_fd)\n-        stderr_fd = stdout_fd;\n-    }\n-\n-  if (IS_VALID_FILENO (stdout_fd) && stdout_fd != STDOUT_FILENO)\n-    {\n-      if (safe_dup2 (stdout_fd, 1) < 0)\n-        write_err_and_exit (child_err_report_fd,\n-                            CHILD_DUPFD_FAILED);\n-\n-      set_cloexec (stdout_fd);\n-    }\n-  else if (stdout_to_null)\n-    {\n-      gint write_null = safe_open (\"\/dev\/null\", O_WRONLY);\n-      if (write_null < 0)\n-        write_err_and_exit (child_err_report_fd,\n-                            CHILD_OPEN_FAILED);\n-      if (safe_dup2 (write_null, 1) < 0)\n-        write_err_and_exit (child_err_report_fd,\n-                            CHILD_DUPFD_FAILED);\n-      g_clear_fd (&write_null, NULL);\n-    }\n-\n-  if (IS_STD_FILENO (stderr_fd) && stderr_fd != STDERR_FILENO)\n-    {\n-      if (!relocate_fd_out_of_standard_range (&stderr_fd))\n-        write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n-    }\n-\n-  \/* Like with stdin\/stdout above, it's possible the caller assigned\n-   * stderr to an fd with a file number that's intruding on the\n-   * standard range.\n-   *\n-   * Make sure it's out of the way, also.\n-   *\/\n-  if (IS_VALID_FILENO (stderr_fd) && stderr_fd != STDERR_FILENO)\n-    {\n-      if (safe_dup2 (stderr_fd, 2) < 0)\n-        write_err_and_exit (child_err_report_fd,\n-                            CHILD_DUPFD_FAILED);\n-\n-      set_cloexec (stderr_fd);\n-    }\n-  else if (stderr_to_null)\n-    {\n-      gint write_null = safe_open (\"\/dev\/null\", O_WRONLY);\n-      if (write_null < 0)\n-        write_err_and_exit (child_err_report_fd,\n-                            CHILD_OPEN_FAILED);\n-      if (safe_dup2 (write_null, 2) < 0)\n-        write_err_and_exit (child_err_report_fd,\n-                            CHILD_DUPFD_FAILED);\n-      g_clear_fd (&write_null, NULL);\n-    }\n-\n-  \/* Close all file descriptors but stdin, stdout and stderr, and any of source_fds,\n-   * before we exec. Note that this includes\n-   * child_err_report_fd, which keeps the parent from blocking\n-   * forever on the other end of that pipe.\n-   *\/\n-  if (close_descriptors)\n-    {\n-      if (child_setup == NULL && n_fds == 0)\n-        {\n-          if (safe_dup2 (child_err_report_fd, 3) < 0)\n-            write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n-          set_cloexec (3);\n-          if (g_closefrom (4) < 0)\n-            write_err_and_exit (child_err_report_fd, CHILD_CLOSE_FAILED);\n-          child_err_report_fd = 3;\n-        }\n-      else\n-        {\n-          if (g_fdwalk_set_cloexec (3) < 0)\n-            write_err_and_exit (child_err_report_fd, CHILD_CLOSE_FAILED);\n-        }\n-    }\n-  else\n-    {\n-      \/* We need to do child_err_report_fd anyway *\/\n-      set_cloexec (child_err_report_fd);\n-    }\n-\n-  \/*\n-   * Work through the @source_fds and @target_fds mapping.\n-   *\n-   * Based on code originally derived from\n-   * gnome-terminal:src\/terminal-screen.c:terminal_screen_child_setup(),\n-   * used under the LGPLv2+ with permission from author. (The code has\n-   * since migrated to vte:src\/spawn.cc:SpawnContext::exec and is no longer\n-   * terribly similar to what we have here.)\n-   *\/\n-\n-  if (n_fds > 0)\n-    {\n-      for (i = 0; i < n_fds; i++)\n-        max_target_fd = MAX (max_target_fd, target_fds[i]);\n-\n-      if (max_target_fd == G_MAXINT)\n-        {\n-          errno = EINVAL;\n-          write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n-        }\n-\n-      \/* If we're doing remapping fd assignments, we need to handle\n-       * the case where the user has specified e.g. 5 -> 4, 4 -> 6.\n-       * We do this by duping all source fds, taking care to ensure the new\n-       * fds are larger than any target fd to avoid introducing new conflicts.\n-       *\/\n-      for (i = 0; i < n_fds; i++)\n-        {\n-          if (source_fds[i] != target_fds[i])\n-            {\n-              source_fds[i] = dupfd_cloexec (source_fds[i], max_target_fd + 1);\n-              if (source_fds[i] < 0)\n-                write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n-            }\n-        }\n-\n-      for (i = 0; i < n_fds; i++)\n-        {\n-          \/* For basic fd assignments (where source == target), we can just\n-           * unset FD_CLOEXEC.\n-           *\/\n-          if (source_fds[i] == target_fds[i])\n-            {\n-              unset_cloexec (source_fds[i]);\n-            }\n-          else\n-            {\n-              \/* If any of the @target_fds conflict with @child_err_report_fd,\n-               * dup it so it doesnโt get conflated.\n-               *\/\n-              if (target_fds[i] == child_err_report_fd)\n-                {\n-                  child_err_report_fd = dupfd_cloexec (child_err_report_fd, max_target_fd + 1);\n-                  if (child_err_report_fd < 0)\n-                    write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n-                }\n-\n-              if (safe_dup2 (source_fds[i], target_fds[i]) < 0)\n-                write_err_and_exit (child_err_report_fd, CHILD_DUPFD_FAILED);\n-\n-              g_clear_fd (&source_fds[i], NULL);\n-            }\n-        }\n-    }\n-\n-  \/* Call user function just before we exec *\/\n-  if (child_setup)\n-    {\n-      (* child_setup) (user_data);\n-    }\n-\n-  g_execute (argv[0],\n-             (gchar **) (file_and_argv_zero ? argv + 1 : argv),\n-             argv_buffer, argv_buffer_len,\n-             (gchar **) envp, search_path, search_path_buffer, search_path_buffer_len);\n-\n-  \/* Exec failed *\/\n-  write_err_and_exit (child_err_report_fd,\n-                      CHILD_EXEC_FAILED);\n-}\n-\n-static gboolean\n-read_ints (int      fd,\n-           gint*    buf,\n-           gint     n_ints_in_buf,\n-           gint    *n_ints_read,\n-           GError **error)\n-{\n-  gsize bytes = 0;\n-\n-  while (TRUE)\n-    {\n-      gssize chunk;\n-\n-      if (bytes >= sizeof(gint)*2)\n-        break; \/* give up, who knows what happened, should not be\n-                * possible.\n-                *\/\n-\n-    again:\n-      chunk = read (fd,\n-                    ((gchar*)buf) + bytes,\n-                    sizeof(gint) * n_ints_in_buf - bytes);\n-      if (chunk < 0 && errno == EINTR)\n-        goto again;\n-\n-      if (chunk < 0)\n-        {\n-          int errsv = errno;\n-\n-          \/* Some weird shit happened, bail out *\/\n-          g_set_error (error,\n-                       G_SPAWN_ERROR,\n-                       G_SPAWN_ERROR_FAILED,\n-                       _(\"Failed to read from child pipe (%s)\"),\n-                       g_strerror (errsv));\n-\n-          return FALSE;\n-        }\n-      else if (chunk == 0)\n-        break; \/* EOF *\/\n-      else \/* chunk > 0 *\/\n-  bytes += chunk;\n-    }\n-\n-  *n_ints_read = (gint)(bytes \/ sizeof(gint));\n-\n-  return TRUE;\n-}\n-\n-#ifdef POSIX_SPAWN_AVAILABLE\n-static gboolean\n-do_posix_spawn (const gchar * const *argv,\n-                const gchar * const *envp,\n-                gboolean    search_path,\n-                gboolean    stdout_to_null,\n-                gboolean    stderr_to_null,\n-                gboolean    child_inherits_stdin,\n-                gboolean    file_and_argv_zero,\n-                GPid       *child_pid,\n-                gint       *child_close_fds,\n-                gint        stdin_fd,\n-                gint        stdout_fd,\n-                gint        stderr_fd,\n-                const gint *source_fds,\n-                const gint *target_fds,\n-                gsize       n_fds)\n-{\n-  pid_t pid;\n-  gint *duped_source_fds = NULL;\n-  gint max_target_fd = 0;\n-  const gchar * const *argv_pass;\n-  posix_spawnattr_t attr;\n-  posix_spawn_file_actions_t file_actions;\n-  gint parent_close_fds[3];\n-  gsize num_parent_close_fds = 0;\n-  GSList *child_close = NULL;\n-  GSList *elem;\n-  sigset_t mask;\n-  gsize i;\n-  int r;\n-\n-  g_assert (argv != NULL && argv[0] != NULL);\n-\n-  if (*argv[0] == '\\0')\n-    {\n-      \/* We check the simple case first. *\/\n-      return ENOENT;\n-    }\n-\n-  r = posix_spawnattr_init (&attr);\n-  if (r != 0)\n-    return r;\n-\n-  if (child_close_fds)\n-    {\n-      int i = -1;\n-      while (child_close_fds[++i] != -1)\n-        child_close = g_slist_prepend (child_close,\n-                                       GINT_TO_POINTER (child_close_fds[i]));\n-    }\n-\n-  r = posix_spawnattr_setflags (&attr, POSIX_SPAWN_SETSIGDEF);\n-  if (r != 0)\n-    goto out_free_spawnattr;\n-\n-  \/* Reset some signal handlers that we may use *\/\n-  sigemptyset (&mask);\n-  sigaddset (&mask, SIGCHLD);\n-  sigaddset (&mask, SIGINT);\n-  sigaddset (&mask, SIGTERM);\n-  sigaddset (&mask, SIGHUP);\n-\n-  r = posix_spawnattr_setsigdefault (&attr, &mask);\n-  if (r != 0)\n-    goto out_free_spawnattr;\n-\n-  r = posix_spawn_file_actions_init (&file_actions);\n-  if (r != 0)\n-    goto out_free_spawnattr;\n-\n-  \/* Redirect pipes as required *\/\n-\n-  if (stdin_fd >= 0)\n-    {\n-      r = posix_spawn_file_actions_adddup2 (&file_actions, stdin_fd, 0);\n-      if (r != 0)\n-        goto out_close_fds;\n-\n-      if (!g_slist_find (child_close, GINT_TO_POINTER (stdin_fd)))\n-        child_close = g_slist_prepend (child_close, GINT_TO_POINTER (stdin_fd));\n-    }\n-  else if (!child_inherits_stdin)\n-    {\n-      \/* Keep process from blocking on a read of stdin *\/\n-      gint read_null = safe_open (\"\/dev\/null\", O_RDONLY | O_CLOEXEC);\n-      g_assert (read_null != -1);\n-      parent_close_fds[num_parent_close_fds++] = read_null;\n-\n-#ifndef HAVE_O_CLOEXEC\n-      fcntl (read_null, F_SETFD, FD_CLOEXEC);\n-#endif\n-\n-      r = posix_spawn_file_actions_adddup2 (&file_actions, read_null, 0);\n-      if (r != 0)\n-        goto out_close_fds;\n-    }\n-\n-  if (stdout_fd >= 0)\n-    {\n-      r = posix_spawn_file_actions_adddup2 (&file_actions, stdout_fd, 1);\n-      if (r != 0)\n-        goto out_close_fds;\n-\n-      if (!g_slist_find (child_close, GINT_TO_POINTER (stdout_fd)))\n-        child_close = g_slist_prepend (child_close, GINT_TO_POINTER (stdout_fd));\n-    }\n-  else if (stdout_to_null)\n-    {\n-      gint write_null = safe_open (\"\/dev\/null\", O_WRONLY | O_CLOEXEC);\n-      g_assert (write_null != -1);\n-      parent_close_fds[num_parent_close_fds++] = write_null;\n-\n-#ifndef HAVE_O_CLOEXEC\n-      fcntl (write_null, F_SETFD, FD_CLOEXEC);\n-#endif\n-\n-      r = posix_spawn_file_actions_adddup2 (&file_actions, write_null, 1);\n-      if (r != 0)\n-        goto out_close_fds;\n-    }\n-\n-  if (stderr_fd >= 0)\n-    {\n-      r = posix_spawn_file_actions_adddup2 (&file_actions, stderr_fd, 2);\n-      if (r != 0)\n-        goto out_close_fds;\n-\n-      if (!g_slist_find (child_close, GINT_TO_POINTER (stderr_fd)))\n-        child_close = g_slist_prepend (child_close, GINT_TO_POINTER (stderr_fd));\n-    }\n-  else if (stderr_to_null)\n-    {\n-      gint write_null = safe_open (\"\/dev\/null\", O_WRONLY | O_CLOEXEC);\n-      g_assert (write_null != -1);\n-      parent_close_fds[num_parent_close_fds++] = write_null;\n-\n-#ifndef HAVE_O_CLOEXEC\n-      fcntl (write_null, F_SETFD, FD_CLOEXEC);\n-#endif\n-\n-      r = posix_spawn_file_actions_adddup2 (&file_actions, write_null, 2);\n-      if (r != 0)\n-        goto out_close_fds;\n-    }\n-\n-  \/* If source_fds[i] != target_fds[i], we need to handle the case\n-   * where the user has specified, e.g., 5 -> 4, 4 -> 6. We do this\n-   * by duping the source fds, taking care to ensure the new fds are\n-   * larger than any target fd to avoid introducing new conflicts.\n-   *\n-   * If source_fds[i] == target_fds[i], then we just need to leak\n-   * the fd into the child process, which we *could* do by temporarily\n-   * unsetting CLOEXEC and then setting it again after we spawn if\n-   * it was originally set. POSIX requires that the addup2 action unset\n-   * CLOEXEC if source and target are identical, so you'd think doing it\n-   * manually wouldn't be needed, but unfortunately as of 2021 many\n-   * libcs still don't do so. Example nonconforming libcs:\n-   *  Bionic: https:\/\/android.googlesource.com\/platform\/bionic\/+\/f6e5b582604715729b09db3e36a7aeb8c24b36a4\/libc\/bionic\/spawn.cpp#71\n-   *  uclibc-ng: https:\/\/cgit.uclibc-ng.org\/cgi\/cgit\/uclibc-ng.git\/tree\/librt\/spawn.c?id=7c36bcae09d66bbaa35cbb02253ae0556f42677e#n88\n-   *\n-   * Anyway, unsetting CLOEXEC ourselves would open a small race window\n-   * where the fd could be inherited into a child process if another\n-   * thread spawns something at the same time, because we have not\n-   * called fork() and are multithreaded here. This race is avoidable by\n-   * using dupfd_cloexec, which we already have to do to handle the\n-   * source_fds[i] != target_fds[i] case. So let's always do it!\n-   *\/\n-\n-  for (i = 0; i < n_fds; i++)\n-    max_target_fd = MAX (max_target_fd, target_fds[i]);\n-\n-  if (max_target_fd == G_MAXINT)\n-    goto out_close_fds;\n-\n-  duped_source_fds = g_new (gint, n_fds);\n-  for (i = 0; i < n_fds; i++)\n-    duped_source_fds[i] = -1;  \/* initialise in case dupfd_cloexec() fails below *\/\n-  for (i = 0; i < n_fds; i++)\n-    {\n-      duped_source_fds[i] = dupfd_cloexec (source_fds[i], max_target_fd + 1);\n-      if (duped_source_fds[i] < 0)\n-        goto out_close_fds;\n-    }\n-\n-  for (i = 0; i < n_fds; i++)\n-    {\n-      r = posix_spawn_file_actions_adddup2 (&file_actions, duped_source_fds[i], target_fds[i]);\n-      if (r != 0)\n-        goto out_close_fds;\n-    }\n-\n-  \/* Intentionally close the fds in the child as the last file action,\n-   * having been careful not to add the same fd to this list twice.\n-   *\n-   * This is important to allow (e.g.) for the same fd to be passed as stdout\n-   * and stderr (we must not close it before we have dupped it in both places,\n-   * and we must not attempt to close it twice).\n-   *\/\n-  for (elem = child_close; elem != NULL; elem = elem->next)\n-    {\n-      r = posix_spawn_file_actions_addclose (&file_actions,\n-                                             GPOINTER_TO_INT (elem->data));\n-      if (r != 0)\n-        goto out_close_fds;\n-    }\n-\n-  argv_pass = file_and_argv_zero ? argv + 1 : argv;\n-  if (envp == NULL)\n-    envp = (const gchar * const *) environ;\n-\n-  \/* Don't search when it contains a slash. *\/\n-  if (!search_path || strchr (argv[0], '\/') != NULL)\n-    r = posix_spawn (&pid, argv[0], &file_actions, &attr, (char * const *) argv_pass, (char * const *) envp);\n-  else\n-    r = posix_spawnp (&pid, argv[0], &file_actions, &attr, (char * const *) argv_pass, (char * const *) envp);\n-\n-  if (r == 0 && child_pid != NULL)\n-    *child_pid = pid;\n-\n-out_close_fds:\n-  for (i = 0; i < num_parent_close_fds; i++)\n-    g_clear_fd (&parent_close_fds[i], NULL);\n-\n-  if (duped_source_fds != NULL)\n-    {\n-      for (i = 0; i < n_fds; i++)\n-        g_clear_fd (&duped_source_fds[i], NULL);\n-      g_free (duped_source_fds);\n-    }\n-\n-  posix_spawn_file_actions_destroy (&file_actions);\n-out_free_spawnattr:\n-  posix_spawnattr_destroy (&attr);\n-  g_slist_free (child_close);\n-\n-  return r;\n-}\n-#endif \/* POSIX_SPAWN_AVAILABLE *\/\n-\n-static gboolean\n-source_fds_collide_with_pipe (const GUnixPipe  *pipefd,\n-                              const int        *source_fds,\n-                              gsize             n_fds,\n-                              GError          **error)\n-{\n-  return (_g_spawn_invalid_source_fd (pipefd->fds[G_UNIX_PIPE_END_READ], source_fds, n_fds, error) ||\n-          _g_spawn_invalid_source_fd (pipefd->fds[G_UNIX_PIPE_END_WRITE], source_fds, n_fds, error));\n-}\n-\n-static gboolean\n-fork_exec (gboolean              intermediate_child,\n-           const gchar          *working_directory,\n-           const gchar * const  *argv,\n-           const gchar * const  *envp,\n-           gboolean              close_descriptors,\n-           gboolean              search_path,\n-           gboolean              search_path_from_envp,\n-           gboolean              stdout_to_null,\n-           gboolean              stderr_to_null,\n-           gboolean              child_inherits_stdin,\n-           gboolean              file_and_argv_zero,\n-           gboolean              cloexec_pipes,\n-           GSpawnChildSetupFunc  child_setup,\n-           gpointer              user_data,\n-           GPid                 *child_pid,\n-           gint                 *stdin_pipe_out,\n-           gint                 *stdout_pipe_out,\n-           gint                 *stderr_pipe_out,\n-           gint                  stdin_fd,\n-           gint                  stdout_fd,\n-           gint                  stderr_fd,\n-           const gint           *source_fds,\n-           const gint           *target_fds,\n-           gsize                 n_fds,\n-           GError              **error)\n-{\n-  GPid pid = -1;\n-  GUnixPipe child_err_report_pipe = G_UNIX_PIPE_INIT;\n-  GUnixPipe child_pid_report_pipe = G_UNIX_PIPE_INIT;\n-  guint pipe_flags = cloexec_pipes ? O_CLOEXEC : 0;\n-  gint status;\n-  const gchar *chosen_search_path;\n-  gchar *search_path_buffer = NULL;\n-  gchar *search_path_buffer_heap = NULL;\n-  gsize search_path_buffer_len = 0;\n-  gchar **argv_buffer = NULL;\n-  gchar **argv_buffer_heap = NULL;\n-  gsize argv_buffer_len = 0;\n-  GUnixPipe stdin_pipe = G_UNIX_PIPE_INIT;\n-  GUnixPipe stdout_pipe = G_UNIX_PIPE_INIT;\n-  GUnixPipe stderr_pipe = G_UNIX_PIPE_INIT;\n-  gint child_close_fds[4] = { -1, -1, -1, -1 };\n-  gint n_child_close_fds = 0;\n-  gint *source_fds_copy = NULL;\n-\n-  g_assert (argv != NULL && argv[0] != NULL);\n-  g_assert (stdin_pipe_out == NULL || stdin_fd < 0);\n-  g_assert (stdout_pipe_out == NULL || stdout_fd < 0);\n-  g_assert (stderr_pipe_out == NULL || stderr_fd < 0);\n-\n-  \/* If pipes have been requested, open them *\/\n-  if (stdin_pipe_out != NULL)\n-    {\n-      if (!g_unix_pipe_open (&stdin_pipe, pipe_flags, error))\n-        goto cleanup_and_fail;\n-      if (source_fds_collide_with_pipe (&stdin_pipe, source_fds, n_fds, error))\n-        goto cleanup_and_fail;\n-      child_close_fds[n_child_close_fds++] = g_unix_pipe_get (&stdin_pipe, G_UNIX_PIPE_END_WRITE);\n-      stdin_fd = g_unix_pipe_get (&stdin_pipe, G_UNIX_PIPE_END_READ);\n-    }\n-\n-  if (stdout_pipe_out != NULL)\n-    {\n-      if (!g_unix_pipe_open (&stdout_pipe, pipe_flags, error))\n-        goto cleanup_and_fail;\n-      if (source_fds_collide_with_pipe (&stdout_pipe, source_fds, n_fds, error))\n-        goto cleanup_and_fail;\n-      child_close_fds[n_child_close_fds++] = g_unix_pipe_get (&stdout_pipe, G_UNIX_PIPE_END_READ);\n-      stdout_fd = g_unix_pipe_get (&stdout_pipe, G_UNIX_PIPE_END_WRITE);\n-    }\n-\n-  if (stderr_pipe_out != NULL)\n-    {\n-      if (!g_unix_pipe_open (&stderr_pipe, pipe_flags, error))\n-        goto cleanup_and_fail;\n-      if (source_fds_collide_with_pipe (&stderr_pipe, source_fds, n_fds, error))\n-        goto cleanup_and_fail;\n-      child_close_fds[n_child_close_fds++] = g_unix_pipe_get (&stderr_pipe, G_UNIX_PIPE_END_READ);\n-      stderr_fd = g_unix_pipe_get (&stderr_pipe, G_UNIX_PIPE_END_WRITE);\n-    }\n-\n-  child_close_fds[n_child_close_fds++] = -1;\n-\n-#ifdef POSIX_SPAWN_AVAILABLE\n-  if (!intermediate_child && working_directory == NULL && !close_descriptors &&\n-      !search_path_from_envp && child_setup == NULL)\n-    {\n-      g_trace_mark (G_TRACE_CURRENT_TIME, 0,\n-                    \"GLib\", \"posix_spawn\",\n-                    \"%s\", argv[0]);\n-\n-      status = do_posix_spawn (argv,\n-                               envp,\n-                               search_path,\n-                               stdout_to_null,\n-                               stderr_to_null,\n-                               child_inherits_stdin,\n-                               file_and_argv_zero,\n-                               child_pid,\n-                               child_close_fds,\n-                               stdin_fd,\n-                               stdout_fd,\n-                               stderr_fd,\n-                               source_fds,\n-                               target_fds,\n-                               n_fds);\n-      if (status == 0)\n-        goto success;\n-\n-      if (status != ENOEXEC)\n-        {\n-          g_set_error (error,\n-                       G_SPAWN_ERROR,\n-                       G_SPAWN_ERROR_FAILED,\n-                       _(\"Failed to spawn child process '%s' (%s)\"),\n-                       argv[0],\n-                       g_strerror (status));\n-          goto cleanup_and_fail;\n-       }\n-\n-      \/* posix_spawn is not intended to support script execution. It does in\n-       * some situations on some glibc versions, but that will be fixed.\n-       * So if it fails with ENOEXEC, we fall through to the regular\n-       * gspawn codepath so that script execution can be attempted,\n-       * per standard gspawn behaviour. *\/\n-      g_debug (\"posix_spawn failed (ENOEXEC), fall back to regular gspawn\");\n-    }\n-  else\n-    {\n-      g_trace_mark (G_TRACE_CURRENT_TIME, 0,\n-                    \"GLib\", \"fork\",\n-                    \"posix_spawn avoided %s%s%s%s%s\",\n-                    !intermediate_child ? \"\" : \"(automatic reaping requested) \",\n-                    working_directory == NULL ? \"\" : \"(workdir specified) \",\n-                    !close_descriptors ? \"\" : \"(fd close requested) \",\n-                    !search_path_from_envp ? \"\" : \"(using envp for search path) \",\n-                    child_setup == NULL ? \"\" : \"(child_setup specified) \");\n-    }\n-#endif \/* POSIX_SPAWN_AVAILABLE *\/\n-\n-  \/* Choose a search path. This has to be done before calling fork()\n-   * as getenv() isnโt async-signal-safe (see `man 7 signal-safety`). *\/\n-  chosen_search_path = NULL;\n-  if (search_path_from_envp)\n-    chosen_search_path = g_environ_getenv ((gchar **) envp, \"PATH\");\n-  if (search_path && chosen_search_path == NULL)\n-    chosen_search_path = g_getenv (\"PATH\");\n-\n-  if ((search_path || search_path_from_envp) && chosen_search_path == NULL)\n-    {\n-      \/* There is no 'PATH' in the environment.  The default\n-       * * search path in libc is the current directory followed by\n-       * * the path 'confstr' returns for '_CS_PATH'.\n-       * *\/\n-\n-      \/* In GLib we put . last, for security, and don't use the\n-       * * unportable confstr(); UNIX98 does not actually specify\n-       * * what to search if PATH is unset. POSIX may, dunno.\n-       * *\/\n-\n-      chosen_search_path = \"\/bin:\/usr\/bin:.\";\n-    }\n-\n-  if (search_path || search_path_from_envp)\n-    g_assert (chosen_search_path != NULL);\n-  else\n-    g_assert (chosen_search_path == NULL);\n-\n-  \/* Allocate a buffer which the fork()ed child can use to assemble potential\n-   * paths for the binary to exec(), combining the argv[0] and elements from\n-   * the chosen_search_path. This canโt be done in the child because malloc()\n-   * (or alloca()) are not async-signal-safe (see `man 7 signal-safety`).\n-   *\n-   * Add 2 for the nul terminator and a leading `\/`. *\/\n-  if (chosen_search_path != NULL)\n-    {\n-      search_path_buffer_len = strlen (chosen_search_path) + strlen (argv[0]) + 2;\n-      if (search_path_buffer_len < 4000)\n-        {\n-          \/* Prefer small stack allocations to avoid valgrind leak warnings\n-           * in forked child. The 4000B cutoff is arbitrary. *\/\n-          search_path_buffer = g_alloca (search_path_buffer_len);\n-        }\n-      else\n-        {\n-          search_path_buffer_heap = g_malloc (search_path_buffer_len);\n-          search_path_buffer = search_path_buffer_heap;\n-        }\n-    }\n-\n-  if (search_path || search_path_from_envp)\n-    g_assert (search_path_buffer != NULL);\n-  else\n-    g_assert (search_path_buffer == NULL);\n-\n-  \/* And allocate a buffer which is 2 elements longer than @argv, so that if\n-   * script_execute() has to be called later on, it can build a wrapper argv\n-   * array in this buffer. *\/\n-  argv_buffer_len = g_strv_length ((gchar **) argv) + 2;\n-  if (argv_buffer_len < 4000 \/ sizeof (gchar *))\n-    {\n-      \/* Prefer small stack allocations to avoid valgrind leak warnings\n-       * in forked child. The 4000B cutoff is arbitrary. *\/\n-      argv_buffer = g_newa (gchar *, argv_buffer_len);\n-    }\n-  else\n-    {\n-      argv_buffer_heap = g_new (gchar *, argv_buffer_len);\n-      argv_buffer = argv_buffer_heap;\n-    }\n-\n-  \/* And one to hold a copy of @source_fds for later manipulation in do_exec(). *\/\n-  source_fds_copy = g_new (int, n_fds);\n-  if (n_fds > 0)\n-    memcpy (source_fds_copy, source_fds, sizeof (*source_fds) * n_fds);\n-\n-  if (!g_unix_pipe_open (&child_err_report_pipe, pipe_flags, error))\n-    goto cleanup_and_fail;\n-  if (source_fds_collide_with_pipe (&child_err_report_pipe, source_fds, n_fds, error))\n-    goto cleanup_and_fail;\n-\n-  if (intermediate_child)\n-    {\n-      if (!g_unix_pipe_open (&child_pid_report_pipe, pipe_flags, error))\n-        goto cleanup_and_fail;\n-      if (source_fds_collide_with_pipe (&child_pid_report_pipe, source_fds, n_fds, error))\n-        goto cleanup_and_fail;\n-    }\n-\n-  pid = fork ();\n-\n-  if (pid < 0)\n-    {\n-      int errsv = errno;\n-\n-      g_set_error (error,\n-                   G_SPAWN_ERROR,\n-                   G_SPAWN_ERROR_FORK,\n-                   _(\"Failed to fork (%s)\"),\n-                   g_strerror (errsv));\n-\n-      goto cleanup_and_fail;\n-    }\n-  else if (pid == 0)\n-    {\n-      \/* Immediate child. This may or may not be the child that\n-       * actually execs the new process.\n-       *\/\n-\n-      \/* Reset some signal handlers that we may use *\/\n-      signal (SIGCHLD, SIG_DFL);\n-      signal (SIGINT, SIG_DFL);\n-      signal (SIGTERM, SIG_DFL);\n-      signal (SIGHUP, SIG_DFL);\n-\n-      \/* Be sure we crash if the parent exits\n-       * and we write to the err_report_pipe\n-       *\/\n-      signal (SIGPIPE, SIG_DFL);\n-\n-      \/* Close the parent's end of the pipes;\n-       * not needed in the close_descriptors case,\n-       * though\n-       *\/\n-      g_unix_pipe_close (&child_err_report_pipe, G_UNIX_PIPE_END_READ, NULL);\n-      g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_READ, NULL);\n-      if (child_close_fds[0] != -1)\n-        {\n-           int i = -1;\n-           while (child_close_fds[++i] != -1)\n-             g_clear_fd (&child_close_fds[i], NULL);\n-        }\n-\n-      if (intermediate_child)\n-        {\n-          \/* We need to fork an intermediate child that launches the\n-           * final child. The purpose of the intermediate child\n-           * is to exit, so we can waitpid() it immediately.\n-           * Then the grandchild will not become a zombie.\n-           *\/\n-          GPid grandchild_pid;\n-\n-          grandchild_pid = fork ();\n-\n-          if (grandchild_pid < 0)\n-            {\n-              \/* report -1 as child PID *\/\n-              write_all (g_unix_pipe_get (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE),\n-                         &grandchild_pid, sizeof(grandchild_pid));\n-\n-              write_err_and_exit (g_unix_pipe_get (&child_err_report_pipe, G_UNIX_PIPE_END_WRITE),\n-                                  CHILD_FORK_FAILED);\n-            }\n-          else if (grandchild_pid == 0)\n-            {\n-              g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n-              do_exec (g_unix_pipe_get (&child_err_report_pipe, G_UNIX_PIPE_END_WRITE),\n-                       stdin_fd,\n-                       stdout_fd,\n-                       stderr_fd,\n-                       source_fds_copy,\n-                       target_fds,\n-                       n_fds,\n-                       working_directory,\n-                       argv,\n-                       argv_buffer,\n-                       argv_buffer_len,\n-                       envp,\n-                       close_descriptors,\n-                       chosen_search_path,\n-                       search_path_buffer,\n-                       search_path_buffer_len,\n-                       stdout_to_null,\n-                       stderr_to_null,\n-                       child_inherits_stdin,\n-                       file_and_argv_zero,\n-                       child_setup,\n-                       user_data);\n-            }\n-          else\n-            {\n-              write_all (g_unix_pipe_get (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE),\n-                         &grandchild_pid, sizeof(grandchild_pid));\n-              g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n-\n-              _exit (0);\n-            }\n-        }\n-      else\n-        {\n-          \/* Just run the child.\n-           *\/\n-\n-          do_exec (g_unix_pipe_get (&child_err_report_pipe, G_UNIX_PIPE_END_WRITE),\n-                   stdin_fd,\n-                   stdout_fd,\n-                   stderr_fd,\n-                   source_fds_copy,\n-                   target_fds,\n-                   n_fds,\n-                   working_directory,\n-                   argv,\n-                   argv_buffer,\n-                   argv_buffer_len,\n-                   envp,\n-                   close_descriptors,\n-                   chosen_search_path,\n-                   search_path_buffer,\n-                   search_path_buffer_len,\n-                   stdout_to_null,\n-                   stderr_to_null,\n-                   child_inherits_stdin,\n-                   file_and_argv_zero,\n-                   child_setup,\n-                   user_data);\n-        }\n-    }\n-  else\n-    {\n-      \/* Parent *\/\n-\n-      gint buf[2];\n-      gint n_ints = 0;\n-\n-      \/* Close the uncared-about ends of the pipes *\/\n-      g_unix_pipe_close (&child_err_report_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n-      g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n-\n-      \/* If we had an intermediate child, reap it *\/\n-      if (intermediate_child)\n-        {\n-        wait_again:\n-          if (waitpid (pid, &status, 0) < 0)\n-            {\n-              if (errno == EINTR)\n-                goto wait_again;\n-              else if (errno == ECHILD)\n-                ; \/* do nothing, child already reaped *\/\n-              else\n-                g_warning (\"waitpid() should not fail in 'fork_exec'\");\n-            }\n-        }\n-\n-\n-      if (!read_ints (g_unix_pipe_get (&child_err_report_pipe, G_UNIX_PIPE_END_READ),\n-                      buf, 2, &n_ints,\n-                      error))\n-        goto cleanup_and_fail;\n-\n-      if (n_ints >= 2)\n-        {\n-          \/* Error from the child. *\/\n-\n-          switch (buf[0])\n-            {\n-            case CHILD_CHDIR_FAILED:\n-              g_set_error (error,\n-                           G_SPAWN_ERROR,\n-                           G_SPAWN_ERROR_CHDIR,\n-                           _(\"Failed to change to directory '%s' (%s)\"),\n-                           working_directory,\n-                           g_strerror (buf[1]));\n-\n-              break;\n-\n-            case CHILD_EXEC_FAILED:\n-              g_set_error (error,\n-                           G_SPAWN_ERROR,\n-                           _g_spawn_exec_err_to_g_error (buf[1]),\n-                           _(\"Failed to execute child process '%s' (%s)\"),\n-                           argv[0],\n-                           g_strerror (buf[1]));\n-\n-              break;\n-\n-            case CHILD_OPEN_FAILED:\n-              g_set_error (error,\n-                           G_SPAWN_ERROR,\n-                           G_SPAWN_ERROR_FAILED,\n-                           _(\"Failed to open file to remap file descriptor (%s)\"),\n-                           g_strerror (buf[1]));\n-              break;\n-\n-            case CHILD_DUPFD_FAILED:\n-              g_set_error (error,\n-                           G_SPAWN_ERROR,\n-                           G_SPAWN_ERROR_FAILED,\n-                           _(\"Failed to duplicate file descriptor for child process (%s)\"),\n-                           g_strerror (buf[1]));\n-\n-              break;\n-\n-            case CHILD_FORK_FAILED:\n-              g_set_error (error,\n-                           G_SPAWN_ERROR,\n-                           G_SPAWN_ERROR_FORK,\n-                           _(\"Failed to fork child process (%s)\"),\n-                           g_strerror (buf[1]));\n-              break;\n-\n-            case CHILD_CLOSE_FAILED:\n-              g_set_error (error,\n-                           G_SPAWN_ERROR,\n-                           G_SPAWN_ERROR_FAILED,\n-                           _(\"Failed to close file descriptor for child process (%s)\"),\n-                           g_strerror (buf[1]));\n-              break;\n-\n-            default:\n-              g_set_error (error,\n-                           G_SPAWN_ERROR,\n-                           G_SPAWN_ERROR_FAILED,\n-                           _(\"Unknown error executing child process '%s'\"),\n-                           argv[0]);\n-              break;\n-            }\n-\n-          goto cleanup_and_fail;\n-        }\n-\n-      \/* Get child pid from intermediate child pipe. *\/\n-      if (intermediate_child)\n-        {\n-          n_ints = 0;\n-\n-          if (!read_ints (g_unix_pipe_get (&child_pid_report_pipe, G_UNIX_PIPE_END_READ),\n-                          buf, 1, &n_ints, error))\n-            goto cleanup_and_fail;\n-\n-          if (n_ints < 1)\n-            {\n-              int errsv = errno;\n-\n-              g_set_error (error,\n-                           G_SPAWN_ERROR,\n-                           G_SPAWN_ERROR_FAILED,\n-                           _(\"Failed to read enough data from child pid pipe (%s)\"),\n-                           g_strerror (errsv));\n-              goto cleanup_and_fail;\n-            }\n-          else\n-            {\n-              \/* we have the child pid *\/\n-              pid = buf[0];\n-            }\n-        }\n-\n-      \/* Success against all odds! return the information *\/\n-      g_unix_pipe_close (&child_err_report_pipe, G_UNIX_PIPE_END_READ, NULL);\n-      g_unix_pipe_close (&child_pid_report_pipe, G_UNIX_PIPE_END_READ, NULL);\n-\n-      g_free (search_path_buffer_heap);\n-      g_free (argv_buffer_heap);\n-      g_free (source_fds_copy);\n-\n-      if (child_pid)\n-        *child_pid = pid;\n-\n-      goto success;\n-    }\n-\n-success:\n-  \/* Close the uncared-about ends of the pipes *\/\n-  g_unix_pipe_close (&stdin_pipe, G_UNIX_PIPE_END_READ, NULL);\n-  g_unix_pipe_close (&stdout_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n-  g_unix_pipe_close (&stderr_pipe, G_UNIX_PIPE_END_WRITE, NULL);\n-\n-  if (stdin_pipe_out != NULL)\n-    *stdin_pipe_out = g_unix_pipe_steal (&stdin_pipe, G_UNIX_PIPE_END_WRITE);\n-\n-  if (stdout_pipe_out != NULL)\n-    *stdout_pipe_out = g_unix_pipe_steal (&stdout_pipe, G_UNIX_PIPE_END_READ);\n-\n-  if (stderr_pipe_out != NULL)\n-    *stderr_pipe_out = g_unix_pipe_steal (&stderr_pipe, G_UNIX_PIPE_END_READ);\n-\n-  return TRUE;\n-\n- cleanup_and_fail:\n-\n-  \/* There was an error from the Child, reap the child to avoid it being\n-     a zombie.\n-   *\/\n-\n-  if (pid > 0)\n-  {\n-    wait_failed:\n-     if (waitpid (pid, NULL, 0) < 0)\n-       {\n-          if (errno == EINTR)\n-            goto wait_failed;\n-          else if (errno == ECHILD)\n-            ; \/* do nothing, child already reaped *\/\n-          else\n-            g_warning (\"waitpid() should not fail in 'fork_exec'\");\n-       }\n-   }\n-\n-  g_unix_pipe_clear (&stdin_pipe);\n-  g_unix_pipe_clear (&stdout_pipe);\n-  g_unix_pipe_clear (&stderr_pipe);\n-  g_unix_pipe_clear (&child_err_report_pipe);\n-  g_unix_pipe_clear (&child_pid_report_pipe);\n-\n-  g_clear_pointer (&search_path_buffer_heap, g_free);\n-  g_clear_pointer (&argv_buffer_heap, g_free);\n-  g_clear_pointer (&source_fds_copy, g_free);\n-\n-  return FALSE;\n-}\n-\n-\/* Based on execvp from GNU C Library *\/\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)) until it calls exec(). *\/\n-static gboolean\n-script_execute (const gchar *file,\n-                gchar      **argv,\n-                gchar      **argv_buffer,\n-                gsize        argv_buffer_len,\n-                gchar      **envp)\n-{\n-  \/* Count the arguments.  *\/\n-  gsize argc = 0;\n-  while (argv[argc])\n-    ++argc;\n-\n-  \/* Construct an argument list for the shell. *\/\n-  if (argc + 2 > argv_buffer_len)\n-    return FALSE;\n-\n-  argv_buffer[0] = (char *) \"\/bin\/sh\";\n-  argv_buffer[1] = (char *) file;\n-  while (argc > 0)\n-    {\n-      argv_buffer[argc + 1] = argv[argc];\n-      --argc;\n-    }\n-\n-    \/* Execute the shell. *\/\n-  if (envp)\n-    execve (argv_buffer[0], argv_buffer, envp);\n-  else\n-    execv (argv_buffer[0], argv_buffer);\n-\n-  return TRUE;\n-}\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)). *\/\n-static gchar*\n-my_strchrnul (const gchar *str, gchar c)\n-{\n-  gchar *p = (gchar*) str;\n-  while (*p && (*p != c))\n-    ++p;\n-\n-  return p;\n-}\n-\n-\/* This function is called between fork() and exec() and hence must be\n- * async-signal-safe (see signal-safety(7)) until it calls exec(). *\/\n-static gint\n-g_execute (const gchar  *file,\n-           gchar       **argv,\n-           gchar       **argv_buffer,\n-           gsize         argv_buffer_len,\n-           gchar       **envp,\n-           const gchar  *search_path,\n-           gchar        *search_path_buffer,\n-           gsize         search_path_buffer_len)\n-{\n-  if (file == NULL || *file == '\\0')\n-    {\n-      \/* We check the simple case first. *\/\n-      errno = ENOENT;\n-      return -1;\n-    }\n-\n-  if (search_path == NULL || strchr (file, '\/') != NULL)\n-    {\n-      \/* Don't search when it contains a slash. *\/\n-      if (envp)\n-        execve (file, argv, envp);\n-      else\n-        execv (file, argv);\n-\n-      if (errno == ENOEXEC &&\n-          !script_execute (file, argv, argv_buffer, argv_buffer_len, envp))\n-        {\n-          errno = ENOMEM;\n-          return -1;\n-        }\n-    }\n-  else\n-    {\n-      gboolean got_eacces = 0;\n-      const gchar *path, *p;\n-      gchar *name;\n-      gsize len;\n-      gsize pathlen;\n-\n-      path = search_path;\n-      len = strlen (file) + 1;\n-      pathlen = strlen (path);\n-      name = search_path_buffer;\n-\n-      if (search_path_buffer_len < pathlen + len + 1)\n-        {\n-          errno = ENOMEM;\n-          return -1;\n-        }\n-\n-      \/* Copy the file name at the top, including '\\0'  *\/\n-      memcpy (name + pathlen + 1, file, len);\n-      name = name + pathlen;\n-      \/* And add the slash before the filename  *\/\n-      *name = '\/';\n-\n-      p = path;\n-      do\n-  {\n-    char *startp;\n-\n-    path = p;\n-    p = my_strchrnul (path, ':');\n-\n-    if (p == path)\n-      \/* Two adjacent colons, or a colon at the beginning or the end\n-             * of 'PATH' means to search the current directory.\n-             *\/\n-      startp = name + 1;\n-    else\n-      startp = memcpy (name - (p - path), path, p - path);\n-\n-    \/* Try to execute this name.  If it works, execv will not return.  *\/\n-          if (envp)\n-            execve (startp, argv, envp);\n-          else\n-            execv (startp, argv);\n-\n-          if (errno == ENOEXEC &&\n-              !script_execute (startp, argv, argv_buffer, argv_buffer_len, envp))\n-            {\n-              errno = ENOMEM;\n-              return -1;\n-            }\n-\n-    switch (errno)\n-      {\n-      case EACCES:\n-        \/* Record the we got a 'Permission denied' error.  If we end\n-               * up finding no executable we can use, we want to diagnose\n-               * that we did find one but were denied access.\n-               *\/\n-        got_eacces = TRUE;\n-\n-        G_GNUC_FALLTHROUGH;\n-      case ENOENT:\n-#ifdef ESTALE\n-      case ESTALE:\n-#endif\n-#ifdef ENOTDIR\n-      case ENOTDIR:\n-#endif\n-        \/* Those errors indicate the file is missing or not executable\n-               * by us, in which case we want to just try the next path\n-               * directory.\n-               *\/\n-        break;\n-\n-      case ENODEV:\n-      case ETIMEDOUT:\n-        \/* Some strange filesystems like AFS return even\n-         * stranger error numbers.  They cannot reasonably mean anything\n-         * else so ignore those, too.\n-         *\/\n-        break;\n-\n-      default:\n-        \/* Some other error means we found an executable file, but\n-               * something went wrong executing it; return the error to our\n-               * caller.\n-               *\/\n-        return -1;\n-      }\n-  }\n-      while (*p++ != '\\0');\n-\n-      \/* We tried every element and none of them worked.  *\/\n-      if (got_eacces)\n-  \/* At least one failure was due to permissions, so report that\n-         * error.\n-         *\/\n-        errno = EACCES;\n-    }\n-\n-  \/* Return the error from the last attempt (probably ENOENT).  *\/\n-  return -1;\n-}\n-\n@@ -2642,0 +747,1 @@\n+  g_spawn_close_pid_impl (pid);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gspawn.c","additions":33,"deletions":1927,"binary":false,"changes":1960,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n- * However, since Mac OS X 10.5 (Leopard) Apple provdes a hidden\n+ * However, since Mac OS X 10.5 (Leopard) Apple provides a hidden\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gstdioprivate.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -692,0 +692,1 @@\n+  locale_t c_locale;\n@@ -695,0 +696,1 @@\n+  c_locale = get_C_locale ();\n@@ -697,1 +699,1 @@\n-  return strtod_l (nptr, endptr, get_C_locale ());\n+  return strtod_l (nptr, endptr, c_locale);\n@@ -948,1 +950,1 @@\n-  int rest_len;\n+  size_t rest_len;\n@@ -1201,1 +1203,4 @@\n-  return strtoull_l (nptr, endptr, base, get_C_locale ());\n+  locale_t c_locale = get_C_locale ();\n+\n+  errno = 0;\n+  return strtoull_l (nptr, endptr, base, c_locale);\n@@ -1249,1 +1254,4 @@\n-  return strtoll_l (nptr, endptr, base, get_C_locale ());\n+  locale_t c_locale = get_C_locale ();\n+\n+  errno = 0;\n+  return strtoll_l (nptr, endptr, base, c_locale);\n@@ -2134,1 +2142,12 @@\n- * Replaces all escaped characters with their one byte equivalent.\n+ * Makes a copy of a string replacing C string-style escape\n+ * sequences with their one byte equivalent:\n+ *\n+ * - `\\b` โ [U+0008 Backspace](https:\/\/en.wikipedia.org\/wiki\/Backspace)\n+ * - `\\f` โ [U+000C Form Feed](https:\/\/en.wikipedia.org\/wiki\/Form_feed)\n+ * - `\\n` โ [U+000A Line Feed](https:\/\/en.wikipedia.org\/wiki\/Newline)\n+ * - `\\r` โ [U+000D Carriage Return](https:\/\/en.wikipedia.org\/wiki\/Carriage_return)\n+ * - `\\t` โ [U+0009 Horizontal Tabulation](https:\/\/en.wikipedia.org\/wiki\/Tab_character)\n+ * - `\\v` โ [U+000B Vertical Tabulation](https:\/\/en.wikipedia.org\/wiki\/Vertical_Tab)\n+ * - `\\` followed by one to three octal digits โ the numeric value (mod 255)\n+ * - `\\` followed by any other character โ the character as is.\n+ *   For example, `\\\\` will turn into a backslash (`\\`) and `\\\"` into a double quote (`\"`).\n@@ -2136,1 +2155,1 @@\n- * This function does the reverse conversion of [func@GLib.strescape].\n+ * [func@GLib.strescape] does the reverse conversion.\n@@ -2213,3 +2232,14 @@\n- * Escapes the special characters '\\b', '\\f', '\\n', '\\r', '\\t', '\\v', '\\'\n- * and '\"' in the string @source by inserting a '\\' before\n- * them. Additionally all characters in the range 0x01-0x1F (everything\n+ * It replaces the following special characters in the string @source\n+ * with their corresponding C escape sequence:\n+ *\n+ *  Symbol | Escape\n+ * ---|---\n+ *  [U+0008 Backspace](https:\/\/en.wikipedia.org\/wiki\/Backspace) | `\\b`\n+ *  [U+000C Form Feed](https:\/\/en.wikipedia.org\/wiki\/Form_feed) | `\\f`\n+ *  [U+000A Line Feed](https:\/\/en.wikipedia.org\/wiki\/Newline) | `\\n`\n+ *  [U+000D Carriage Return](https:\/\/en.wikipedia.org\/wiki\/Carriage_return) | `\\r`\n+ *  [U+0009 Horizontal Tabulation](https:\/\/en.wikipedia.org\/wiki\/Tab_character) | `\\t`\n+ *  [U+000B Vertical Tabulation](https:\/\/en.wikipedia.org\/wiki\/Vertical_Tab) | `\\v`\n+ *\n+ * It also inserts a backslash (`\\`) before any backslash or a double quote (`\"`).\n+ * Additionally all characters in the range 0x01-0x1F (everything\n@@ -2217,1 +2247,1 @@\n- * replaced with a '\\' followed by their octal representation.\n+ * replaced with a backslash followed by their octal representation.\n@@ -2757,1 +2787,5 @@\n- * Returns: a pointer to the found occurrence, or `NULL` if not found\n+ * The fact that this function returns `gchar *` rather than `const gchar *` is\n+ * a historical artifact.\n+ *\n+ * Returns: (transfer none) (nullable): a pointer to the found occurrence, or\n+ *    `NULL` if not found\n@@ -2809,1 +2843,5 @@\n- * Returns: a pointer to the found occurrence, or `NULL` if not found\n+ * The fact that this function returns `gchar *` rather than `const gchar *` is\n+ * a historical artifact.\n+ *\n+ * Returns: (transfer none) (nullable): a pointer to the found occurrence, or\n+ *    `NULL` if not found\n@@ -2860,1 +2898,5 @@\n- * Returns: a pointer to the found occurrence, or `NULL` if not found\n+ * The fact that this function returns `gchar *` rather than `const gchar *` is\n+ * a historical artifact.\n+ *\n+ * Returns: (transfer none) (nullable): a pointer to the found occurrence, or\n+ *    `NULL` if not found\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gstrfuncs.c","additions":55,"deletions":13,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -330,4 +330,0 @@\n-\/* Make a copy of a string interpreting C string -style escape\n- * sequences. Inverse of g_strescape. The recognized sequences are \\b\n- * \\f \\n \\r \\t \\\\ \\\" and the octal format.\n- *\/\n@@ -337,8 +333,0 @@\n-\/* Copy a string escaping nonprintable characters like in C strings.\n- * Inverse of g_strcompress. The exceptions parameter, if non-NULL, points\n- * to a string containing characters that are not to be escaped.\n- *\n- * Deprecated API: gchar* g_strescape (const gchar *source);\n- * Luckily this function wasn't used much, using NULL as second parameter\n- * provides mostly identical semantics.\n- *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gstrfuncs.h","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-      gint len;\n+      size_t len;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gstring.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+#if !defined(__cplusplus) || !G_GNUC_CHECK_VERSION (6, 1) || G_GNUC_CHECK_VERSION (7, 3)\n+\n@@ -77,0 +79,2 @@\n+#endif \/* !defined(__cplusplus) || !G_GNUC_CHECK_VERSION (6, 1) || G_GNUC_CHECK_VERSION (7, 3) *\/\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gstring.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,3 @@\n+#ifdef HAVE_FTW_H\n+#include <ftw.h>\n+#endif\n@@ -65,4 +68,2 @@\n-#define TAP_VERSION G_STRINGIFY (13)\n-\/* FIXME: Remove '#' prefix when we'll depend on a meson version supporting TAP 14\n- * See https:\/\/gitlab.gnome.org\/GNOME\/glib\/-\/issues\/2885 *\/\n-#define TAP_SUBTEST_PREFIX \"#    \"  \/* a 4-space indented line *\/\n+#define TAP_VERSION G_STRINGIFY (14)\n+#define TAP_SUBTEST_PREFIX \"    \"  \/* a 4-space indented line *\/\n@@ -1410,0 +1411,55 @@\n+#ifdef HAVE_FTW_H\n+static int\n+rm_rf_nftw_visitor (const char *fpath,\n+                    const struct stat *sb,\n+                    int typeflag,\n+                    struct FTW *ftwbuf)\n+{\n+  switch (typeflag)\n+    {\n+    case FTW_DP:\n+    case FTW_D:\n+    case FTW_DNR:\n+      if (g_rmdir (fpath) != 0)\n+        {\n+          int errsv = errno;\n+          g_printerr (\"Unable to clean up temporary directory %s: %s\\n\",\n+                      fpath,\n+                      g_strerror (errsv));\n+        }\n+      break;\n+\n+    default:\n+      if (g_remove (fpath) != 0)\n+        {\n+          int errsv = errno;\n+          g_printerr (\"Unable to clean up temporary file %s: %s\\n\",\n+                      fpath,\n+                      g_strerror (errsv));\n+        }\n+      break;\n+    }\n+\n+  return 0;\n+}\n+\n+static void\n+rm_rf (const gchar *path)\n+{\n+  \/* nopenfd specifies the maximum number of directories that [n]ftw() will\n+   * hold open simultaneously. Rather than attempt to determine how many file\n+   * descriptors are available, we assume that 5 are available when tearing\n+   * down a test case; if that assumption is invalid, the only harm is leaving\n+   * a temporary directory on disk.\n+   *\/\n+  const int nopenfd = 5;\n+  int ret = nftw (path, rm_rf_nftw_visitor, nopenfd, FTW_DEPTH | FTW_MOUNT | FTW_PHYS);\n+  if (ret != 0)\n+    {\n+      int errsv = errno;\n+      g_printerr (\"Unable to clean up temporary directory %s: %s\\n\",\n+                  path,\n+                  g_strerror (errsv));\n+    }\n+}\n+#else\n@@ -1436,0 +1492,1 @@\n+#endif\n@@ -2939,1 +2996,0 @@\n-  gboolean free_test_data = TRUE;\n@@ -2998,1 +3054,1 @@\n-              free_test_data = FALSE;\n+              tc->fixture_teardown = NULL;\n@@ -3016,7 +3072,0 @@\n-  \/* In case the test didnโt run (due to being skipped or an error), the test\n-   * data may still need to be freed, as the clientโs main() function may have\n-   * passed ownership of it into g_test_add_data_func_full() with a\n-   * #GDestroyNotify. *\/\n-  if (free_test_data && tc->fixture_size == 0 && tc->fixture_teardown != NULL)\n-    tc->fixture_teardown (tc->test_data, tc->test_data);\n-\n@@ -3037,1 +3086,1 @@\n-  int prefix_len = strlen (prefix);\n+  size_t prefix_len = strlen (prefix);\n@@ -3207,0 +3256,7 @@\n+  \/* In case the test didnโt run (due to being skipped or an error), the test\n+   * data may still need to be freed, as the clientโs main() function may have\n+   * passed ownership of it into g_test_add_data_func_full() with a\n+   * #GDestroyNotify. *\/\n+  if (test_case->fixture_size == 0 && test_case->fixture_teardown != NULL)\n+    test_case->fixture_teardown (test_case->test_data, test_case->test_data);\n+\n@@ -4310,1 +4366,3 @@\n-      guint l = strlen (msg->strings[ui]);\n+      guint l;\n+      g_assert (msg->strings[ui] != NULL);\n+      l = strlen (msg->strings[ui]);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gtestutils.c","additions":73,"deletions":15,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -149,33 +149,2 @@\n-\/**\n- * g_mutex_init:\n- * @mutex: an uninitialized #GMutex\n- *\n- * Initializes a #GMutex so that it can be used.\n- *\n- * This function is useful to initialize a mutex that has been\n- * allocated on the stack, or as part of a larger structure.\n- * It is not necessary to initialize a mutex that has been\n- * statically allocated.\n- *\n- * |[<!-- language=\"C\" -->\n- *   typedef struct {\n- *     GMutex m;\n- *     ...\n- *   } Blob;\n- *\n- * Blob *b;\n- *\n- * b = g_new (Blob, 1);\n- * g_mutex_init (&b->m);\n- * ]|\n- *\n- * To undo the effect of g_mutex_init() when a mutex is no longer\n- * needed, use g_mutex_clear().\n- *\n- * Calling g_mutex_init() on an already initialized #GMutex leads\n- * to undefined behaviour.\n- *\n- * Since: 2.32\n- *\/\n-void\n-g_mutex_init (GMutex *mutex)\n+G_ALWAYS_INLINE static inline void\n+g_mutex_init_impl (GMutex *mutex)\n@@ -186,16 +155,2 @@\n-\/**\n- * g_mutex_clear:\n- * @mutex: an initialized #GMutex\n- *\n- * Frees the resources allocated to a mutex with g_mutex_init().\n- *\n- * This function should not be used with a #GMutex that has been\n- * statically allocated.\n- *\n- * Calling g_mutex_clear() on a locked mutex leads to undefined\n- * behaviour.\n- *\n- * Since: 2.32\n- *\/\n-void\n-g_mutex_clear (GMutex *mutex)\n+G_ALWAYS_INLINE static inline void\n+g_mutex_clear_impl (GMutex *mutex)\n@@ -206,15 +161,2 @@\n-\/**\n- * g_mutex_lock:\n- * @mutex: a #GMutex\n- *\n- * Locks @mutex. If @mutex is already locked by another thread, the\n- * current thread will block until @mutex is unlocked by the other\n- * thread.\n- *\n- * #GMutex is neither guaranteed to be recursive nor to be\n- * non-recursive.  As such, calling g_mutex_lock() on a #GMutex that has\n- * already been locked by the same thread results in undefined behaviour\n- * (including but not limited to deadlocks).\n- *\/\n-void\n-g_mutex_lock (GMutex *mutex)\n+G_ALWAYS_INLINE static inline void\n+g_mutex_lock_impl (GMutex *mutex)\n@@ -228,12 +170,2 @@\n-\/**\n- * g_mutex_unlock:\n- * @mutex: a #GMutex\n- *\n- * Unlocks @mutex. If another thread is blocked in a g_mutex_lock()\n- * call for @mutex, it will become unblocked and can lock @mutex itself.\n- *\n- * Calling g_mutex_unlock() on a mutex that is not locked by the\n- * current thread leads to undefined behaviour.\n- *\/\n-void\n-g_mutex_unlock (GMutex *mutex)\n+G_ALWAYS_INLINE static inline void\n+g_mutex_unlock_impl (GMutex *mutex)\n@@ -247,17 +179,2 @@\n-\/**\n- * g_mutex_trylock:\n- * @mutex: a #GMutex\n- *\n- * Tries to lock @mutex. If @mutex is already locked by another thread,\n- * it immediately returns %FALSE. Otherwise it locks @mutex and returns\n- * %TRUE.\n- *\n- * #GMutex is neither guaranteed to be recursive nor to be\n- * non-recursive.  As such, calling g_mutex_lock() on a #GMutex that has\n- * already been locked by the same thread results in undefined behaviour\n- * (including but not limited to deadlocks or arbitrary return values).\n- *\n- * Returns: %TRUE if @mutex could be locked\n- *\/\n-gboolean\n-g_mutex_trylock (GMutex *mutex)\n+G_ALWAYS_INLINE static inline gboolean\n+g_mutex_trylock_impl (GMutex *mutex)\n@@ -321,35 +238,2 @@\n-\/**\n- * g_rec_mutex_init:\n- * @rec_mutex: an uninitialized #GRecMutex\n- *\n- * Initializes a #GRecMutex so that it can be used.\n- *\n- * This function is useful to initialize a recursive mutex\n- * that has been allocated on the stack, or as part of a larger\n- * structure.\n- *\n- * It is not necessary to initialise a recursive mutex that has been\n- * statically allocated.\n- *\n- * |[<!-- language=\"C\" -->\n- *   typedef struct {\n- *     GRecMutex m;\n- *     ...\n- *   } Blob;\n- *\n- * Blob *b;\n- *\n- * b = g_new (Blob, 1);\n- * g_rec_mutex_init (&b->m);\n- * ]|\n- *\n- * Calling g_rec_mutex_init() on an already initialized #GRecMutex\n- * leads to undefined behaviour.\n- *\n- * To undo the effect of g_rec_mutex_init() when a recursive mutex\n- * is no longer needed, use g_rec_mutex_clear().\n- *\n- * Since: 2.32\n- *\/\n-void\n-g_rec_mutex_init (GRecMutex *rec_mutex)\n+G_ALWAYS_INLINE static inline void\n+g_rec_mutex_init_impl (GRecMutex *rec_mutex)\n@@ -360,17 +244,2 @@\n-\/**\n- * g_rec_mutex_clear:\n- * @rec_mutex: an initialized #GRecMutex\n- *\n- * Frees the resources allocated to a recursive mutex with\n- * g_rec_mutex_init().\n- *\n- * This function should not be used with a #GRecMutex that has been\n- * statically allocated.\n- *\n- * Calling g_rec_mutex_clear() on a locked recursive mutex leads\n- * to undefined behaviour.\n- *\n- * Since: 2.32\n- *\/\n-void\n-g_rec_mutex_clear (GRecMutex *rec_mutex)\n+G_ALWAYS_INLINE static inline void\n+g_rec_mutex_clear_impl (GRecMutex *rec_mutex)\n@@ -381,15 +250,2 @@\n-\/**\n- * g_rec_mutex_lock:\n- * @rec_mutex: a #GRecMutex\n- *\n- * Locks @rec_mutex. If @rec_mutex is already locked by another\n- * thread, the current thread will block until @rec_mutex is\n- * unlocked by the other thread. If @rec_mutex is already locked\n- * by the current thread, the 'lock count' of @rec_mutex is increased.\n- * The mutex will only become available again when it is unlocked\n- * as many times as it has been locked.\n- *\n- * Since: 2.32\n- *\/\n-void\n-g_rec_mutex_lock (GRecMutex *mutex)\n+G_ALWAYS_INLINE static inline void\n+g_rec_mutex_lock_impl (GRecMutex *mutex)\n@@ -400,15 +256,2 @@\n-\/**\n- * g_rec_mutex_unlock:\n- * @rec_mutex: a #GRecMutex\n- *\n- * Unlocks @rec_mutex. If another thread is blocked in a\n- * g_rec_mutex_lock() call for @rec_mutex, it will become unblocked\n- * and can lock @rec_mutex itself.\n- *\n- * Calling g_rec_mutex_unlock() on a recursive mutex that is not\n- * locked by the current thread leads to undefined behaviour.\n- *\n- * Since: 2.32\n- *\/\n-void\n-g_rec_mutex_unlock (GRecMutex *rec_mutex)\n+G_ALWAYS_INLINE static inline void\n+g_rec_mutex_unlock_impl (GRecMutex *rec_mutex)\n@@ -419,14 +262,2 @@\n-\/**\n- * g_rec_mutex_trylock:\n- * @rec_mutex: a #GRecMutex\n- *\n- * Tries to lock @rec_mutex. If @rec_mutex is already locked\n- * by another thread, it immediately returns %FALSE. Otherwise\n- * it locks @rec_mutex and returns %TRUE.\n- *\n- * Returns: %TRUE if @rec_mutex could be locked\n- *\n- * Since: 2.32\n- *\/\n-gboolean\n-g_rec_mutex_trylock (GRecMutex *rec_mutex)\n+G_ALWAYS_INLINE static inline gboolean\n+g_rec_mutex_trylock_impl (GRecMutex *rec_mutex)\n@@ -481,33 +312,2 @@\n-\/**\n- * g_rw_lock_init:\n- * @rw_lock: an uninitialized #GRWLock\n- *\n- * Initializes a #GRWLock so that it can be used.\n- *\n- * This function is useful to initialize a lock that has been\n- * allocated on the stack, or as part of a larger structure.  It is not\n- * necessary to initialise a reader-writer lock that has been statically\n- * allocated.\n- *\n- * |[<!-- language=\"C\" -->\n- *   typedef struct {\n- *     GRWLock l;\n- *     ...\n- *   } Blob;\n- *\n- * Blob *b;\n- *\n- * b = g_new (Blob, 1);\n- * g_rw_lock_init (&b->l);\n- * ]|\n- *\n- * To undo the effect of g_rw_lock_init() when a lock is no longer\n- * needed, use g_rw_lock_clear().\n- *\n- * Calling g_rw_lock_init() on an already initialized #GRWLock leads\n- * to undefined behaviour.\n- *\n- * Since: 2.32\n- *\/\n-void\n-g_rw_lock_init (GRWLock *rw_lock)\n+G_ALWAYS_INLINE static inline void\n+g_rw_lock_init_impl (GRWLock *rw_lock)\n@@ -518,16 +318,2 @@\n-\/**\n- * g_rw_lock_clear:\n- * @rw_lock: an initialized #GRWLock\n- *\n- * Frees the resources allocated to a lock with g_rw_lock_init().\n- *\n- * This function should not be used with a #GRWLock that has been\n- * statically allocated.\n- *\n- * Calling g_rw_lock_clear() when any thread holds the lock\n- * leads to undefined behaviour.\n- *\n- * Since: 2.32\n- *\/\n-void\n-g_rw_lock_clear (GRWLock *rw_lock)\n+G_ALWAYS_INLINE static inline void\n+g_rw_lock_clear_impl (GRWLock *rw_lock)\n@@ -538,15 +324,2 @@\n-\/**\n- * g_rw_lock_writer_lock:\n- * @rw_lock: a #GRWLock\n- *\n- * Obtain a write lock on @rw_lock. If another thread currently holds\n- * a read or write lock on @rw_lock, the current thread will block\n- * until all other threads have dropped their locks on @rw_lock.\n- *\n- * Calling g_rw_lock_writer_lock() while the current thread already\n- * owns a read or write lock on @rw_lock leads to undefined behaviour.\n- *\n- * Since: 2.32\n- *\/\n-void\n-g_rw_lock_writer_lock (GRWLock *rw_lock)\n+G_ALWAYS_INLINE static inline void\n+g_rw_lock_writer_lock_impl (GRWLock *rw_lock)\n@@ -560,15 +333,2 @@\n-\/**\n- * g_rw_lock_writer_trylock:\n- * @rw_lock: a #GRWLock\n- *\n- * Tries to obtain a write lock on @rw_lock. If another thread\n- * currently holds a read or write lock on @rw_lock, it immediately\n- * returns %FALSE.\n- * Otherwise it locks @rw_lock and returns %TRUE.\n- *\n- * Returns: %TRUE if @rw_lock could be locked\n- *\n- * Since: 2.32\n- *\/\n-gboolean\n-g_rw_lock_writer_trylock (GRWLock *rw_lock)\n+G_ALWAYS_INLINE static inline gboolean\n+g_rw_lock_writer_trylock_impl (GRWLock *rw_lock)\n@@ -582,13 +342,2 @@\n-\/**\n- * g_rw_lock_writer_unlock:\n- * @rw_lock: a #GRWLock\n- *\n- * Release a write lock on @rw_lock.\n- *\n- * Calling g_rw_lock_writer_unlock() on a lock that is not held\n- * by the current thread leads to undefined behaviour.\n- *\n- * Since: 2.32\n- *\/\n-void\n-g_rw_lock_writer_unlock (GRWLock *rw_lock)\n+G_ALWAYS_INLINE static inline void\n+g_rw_lock_writer_unlock_impl (GRWLock *rw_lock)\n@@ -599,24 +348,2 @@\n-\/**\n- * g_rw_lock_reader_lock:\n- * @rw_lock: a #GRWLock\n- *\n- * Obtain a read lock on @rw_lock. If another thread currently holds\n- * the write lock on @rw_lock, the current thread will block until the\n- * write lock was (held and) released. If another thread does not hold\n- * the write lock, but is waiting for it, it is implementation defined\n- * whether the reader or writer will block. Read locks can be taken\n- * recursively.\n- *\n- * Calling g_rw_lock_reader_lock() while the current thread already\n- * owns a write lock leads to undefined behaviour. Read locks however\n- * can be taken recursively, in which case you need to make sure to\n- * call g_rw_lock_reader_unlock() the same amount of times.\n- *\n- * It is implementation-defined how many read locks are allowed to be\n- * held on the same lock simultaneously. If the limit is hit,\n- * or if a deadlock is detected, a critical warning will be emitted.\n- *\n- * Since: 2.32\n- *\/\n-void\n-g_rw_lock_reader_lock (GRWLock *rw_lock)\n+G_ALWAYS_INLINE static inline void\n+g_rw_lock_reader_lock_impl (GRWLock *rw_lock)\n@@ -630,14 +357,2 @@\n-\/**\n- * g_rw_lock_reader_trylock:\n- * @rw_lock: a #GRWLock\n- *\n- * Tries to obtain a read lock on @rw_lock and returns %TRUE if\n- * the read lock was successfully obtained. Otherwise it\n- * returns %FALSE.\n- *\n- * Returns: %TRUE if @rw_lock could be locked\n- *\n- * Since: 2.32\n- *\/\n-gboolean\n-g_rw_lock_reader_trylock (GRWLock *rw_lock)\n+G_ALWAYS_INLINE static inline gboolean\n+g_rw_lock_reader_trylock_impl (GRWLock *rw_lock)\n@@ -651,13 +366,2 @@\n-\/**\n- * g_rw_lock_reader_unlock:\n- * @rw_lock: a #GRWLock\n- *\n- * Release a read lock on @rw_lock.\n- *\n- * Calling g_rw_lock_reader_unlock() on a lock that is not held\n- * by the current thread leads to undefined behaviour.\n- *\n- * Since: 2.32\n- *\/\n-void\n-g_rw_lock_reader_unlock (GRWLock *rw_lock)\n+G_ALWAYS_INLINE static inline void\n+g_rw_lock_reader_unlock_impl (GRWLock *rw_lock)\n@@ -724,20 +428,2 @@\n-\/**\n- * g_cond_init:\n- * @cond: an uninitialized #GCond\n- *\n- * Initialises a #GCond so that it can be used.\n- *\n- * This function is useful to initialise a #GCond that has been\n- * allocated as part of a larger structure.  It is not necessary to\n- * initialise a #GCond that has been statically allocated.\n- *\n- * To undo the effect of g_cond_init() when a #GCond is no longer\n- * needed, use g_cond_clear().\n- *\n- * Calling g_cond_init() on an already-initialised #GCond leads\n- * to undefined behaviour.\n- *\n- * Since: 2.32\n- *\/\n-void\n-g_cond_init (GCond *cond)\n+G_ALWAYS_INLINE static inline void\n+g_cond_init_impl (GCond *cond)\n@@ -748,16 +434,2 @@\n-\/**\n- * g_cond_clear:\n- * @cond: an initialised #GCond\n- *\n- * Frees the resources allocated to a #GCond with g_cond_init().\n- *\n- * This function should not be used with a #GCond that has been\n- * statically allocated.\n- *\n- * Calling g_cond_clear() for a #GCond on which threads are\n- * blocking leads to undefined behaviour.\n- *\n- * Since: 2.32\n- *\/\n-void\n-g_cond_clear (GCond *cond)\n+G_ALWAYS_INLINE static inline void\n+g_cond_clear_impl (GCond *cond)\n@@ -768,23 +440,3 @@\n-\/**\n- * g_cond_wait:\n- * @cond: a #GCond\n- * @mutex: a #GMutex that is currently locked\n- *\n- * Atomically releases @mutex and waits until @cond is signalled.\n- * When this function returns, @mutex is locked again and owned by the\n- * calling thread.\n- *\n- * When using condition variables, it is possible that a spurious wakeup\n- * may occur (ie: g_cond_wait() returns even though g_cond_signal() was\n- * not called).  It's also possible that a stolen wakeup may occur.\n- * This is when g_cond_signal() is called, but another thread acquires\n- * @mutex before this thread and modifies the state of the program in\n- * such a way that when g_cond_wait() is able to return, the expected\n- * condition is no longer met.\n- *\n- * For this reason, g_cond_wait() must always be used in a loop.  See\n- * the documentation for #GCond for a complete example.\n- **\/\n-void\n-g_cond_wait (GCond  *cond,\n-             GMutex *mutex)\n+G_ALWAYS_INLINE static inline void\n+g_cond_wait_impl (GCond  *cond,\n+                  GMutex *mutex)\n@@ -798,11 +450,2 @@\n-\/**\n- * g_cond_signal:\n- * @cond: a #GCond\n- *\n- * If threads are waiting for @cond, at least one of them is unblocked.\n- * If no threads are waiting for @cond, this function has no effect.\n- * It is good practice to hold the same lock as the waiting thread\n- * while calling this function, though not required.\n- *\/\n-void\n-g_cond_signal (GCond *cond)\n+G_ALWAYS_INLINE static inline void\n+g_cond_signal_impl (GCond *cond)\n@@ -816,11 +459,2 @@\n-\/**\n- * g_cond_broadcast:\n- * @cond: a #GCond\n- *\n- * If threads are waiting for @cond, all of them are unblocked.\n- * If no threads are waiting for @cond, this function has no effect.\n- * It is good practice to lock the same mutex as the waiting threads\n- * while calling this function, though not required.\n- *\/\n-void\n-g_cond_broadcast (GCond *cond)\n+G_ALWAYS_INLINE static inline void\n+g_cond_broadcast_impl (GCond *cond)\n@@ -834,62 +468,4 @@\n-\/**\n- * g_cond_wait_until:\n- * @cond: a #GCond\n- * @mutex: a #GMutex that is currently locked\n- * @end_time: the monotonic time to wait until\n- *\n- * Waits until either @cond is signalled or @end_time has passed.\n- *\n- * As with g_cond_wait() it is possible that a spurious or stolen wakeup\n- * could occur.  For that reason, waiting on a condition variable should\n- * always be in a loop, based on an explicitly-checked predicate.\n- *\n- * %TRUE is returned if the condition variable was signalled (or in the\n- * case of a spurious wakeup).  %FALSE is returned if @end_time has\n- * passed.\n- *\n- * The following code shows how to correctly perform a timed wait on a\n- * condition variable (extending the example presented in the\n- * documentation for #GCond):\n- *\n- * |[<!-- language=\"C\" -->\n- * gpointer\n- * pop_data_timed (void)\n- * {\n- *   gint64 end_time;\n- *   gpointer data;\n- *\n- *   g_mutex_lock (&data_mutex);\n- *\n- *   end_time = g_get_monotonic_time () + 5 * G_TIME_SPAN_SECOND;\n- *   while (!current_data)\n- *     if (!g_cond_wait_until (&data_cond, &data_mutex, end_time))\n- *       {\n- *         \/\/ timeout has passed.\n- *         g_mutex_unlock (&data_mutex);\n- *         return NULL;\n- *       }\n- *\n- *   \/\/ there is data for us\n- *   data = current_data;\n- *   current_data = NULL;\n- *\n- *   g_mutex_unlock (&data_mutex);\n- *\n- *   return data;\n- * }\n- * ]|\n- *\n- * Notice that the end time is calculated once, before entering the\n- * loop and reused.  This is the motivation behind the use of absolute\n- * time on this API -- if a relative time of 5 seconds were passed\n- * directly to the call and a spurious wakeup occurred, the program would\n- * have to start over waiting again (which would lead to a total wait\n- * time of more than 5 seconds).\n- *\n- * Returns: %TRUE on a signal, %FALSE on a timeout\n- * Since: 2.32\n- **\/\n-gboolean\n-g_cond_wait_until (GCond  *cond,\n-                   GMutex *mutex,\n-                   gint64  end_time)\n+G_ALWAYS_INLINE static inline gboolean\n+g_cond_wait_until_impl (GCond  *cond,\n+                        GMutex *mutex,\n+                        gint64  end_time)\n@@ -947,76 +523,0 @@\n-\/**\n- * GPrivate:\n- *\n- * The #GPrivate struct is an opaque data structure to represent a\n- * thread-local data key. It is approximately equivalent to the\n- * pthread_setspecific()\/pthread_getspecific() APIs on POSIX and to\n- * TlsSetValue()\/TlsGetValue() on Windows.\n- *\n- * If you don't already know why you might want this functionality,\n- * then you probably don't need it.\n- *\n- * #GPrivate is a very limited resource (as far as 128 per program,\n- * shared between all libraries). It is also not possible to destroy a\n- * #GPrivate after it has been used. As such, it is only ever acceptable\n- * to use #GPrivate in static scope, and even then sparingly so.\n- *\n- * See G_PRIVATE_INIT() for a couple of examples.\n- *\n- * The #GPrivate structure should be considered opaque.  It should only\n- * be accessed via the g_private_ functions.\n- *\/\n-\n-\/**\n- * G_PRIVATE_INIT:\n- * @notify: a #GDestroyNotify\n- *\n- * A macro to assist with the static initialisation of a #GPrivate.\n- *\n- * This macro is useful for the case that a #GDestroyNotify function\n- * should be associated with the key.  This is needed when the key will be\n- * used to point at memory that should be deallocated when the thread\n- * exits.\n- *\n- * Additionally, the #GDestroyNotify will also be called on the previous\n- * value stored in the key when g_private_replace() is used.\n- *\n- * If no #GDestroyNotify is needed, then use of this macro is not\n- * required -- if the #GPrivate is declared in static scope then it will\n- * be properly initialised by default (ie: to all zeros).  See the\n- * examples below.\n- *\n- * |[<!-- language=\"C\" -->\n- * static GPrivate name_key = G_PRIVATE_INIT (g_free);\n- *\n- * \/\/ return value should not be freed\n- * const gchar *\n- * get_local_name (void)\n- * {\n- *   return g_private_get (&name_key);\n- * }\n- *\n- * void\n- * set_local_name (const gchar *name)\n- * {\n- *   g_private_replace (&name_key, g_strdup (name));\n- * }\n- *\n- *\n- * static GPrivate count_key;   \/\/ no free function\n- *\n- * gint\n- * get_local_count (void)\n- * {\n- *   return GPOINTER_TO_INT (g_private_get (&count_key));\n- * }\n- *\n- * void\n- * set_local_count (gint count)\n- * {\n- *   g_private_set (&count_key, GINT_TO_POINTER (count));\n- * }\n- * ]|\n- *\n- * Since: 2.32\n- **\/\n-\n@@ -1106,1 +606,1 @@\n-g_private_get_impl (GPrivate *key)\n+_g_private_get_impl (GPrivate *key)\n@@ -1145,14 +645,2 @@\n-\/**\n- * g_private_get:\n- * @key: a #GPrivate\n- *\n- * Returns the current value of the thread local variable @key.\n- *\n- * If the value has not yet been set in this thread, %NULL is returned.\n- * Values are never copied between threads (when a new thread is\n- * created, for example).\n- *\n- * Returns: the thread-local value\n- *\/\n-gpointer\n-g_private_get (GPrivate *key)\n+G_ALWAYS_INLINE static inline gpointer\n+g_private_get_impl (GPrivate *key)\n@@ -1161,1 +649,1 @@\n-  return pthread_getspecific (g_private_get_impl (key));\n+  return pthread_getspecific (_g_private_get_impl (key));\n@@ -1164,14 +652,3 @@\n-\/**\n- * g_private_set:\n- * @key: a #GPrivate\n- * @value: the new value\n- *\n- * Sets the thread local variable @key to have the value @value in the\n- * current thread.\n- *\n- * This function differs from g_private_replace() in the following way:\n- * the #GDestroyNotify for @key is not called on the old value.\n- *\/\n-void\n-g_private_set (GPrivate *key,\n-               gpointer  value)\n+G_ALWAYS_INLINE static inline void\n+g_private_set_impl (GPrivate *key,\n+                    gpointer  value)\n@@ -1181,1 +658,1 @@\n-  if G_UNLIKELY ((status = pthread_setspecific (g_private_get_impl (key), value)) != 0)\n+  if G_UNLIKELY ((status = pthread_setspecific (_g_private_get_impl (key), value)) != 0)\n@@ -1185,17 +662,3 @@\n-\/**\n- * g_private_replace:\n- * @key: a #GPrivate\n- * @value: the new value\n- *\n- * Sets the thread local variable @key to have the value @value in the\n- * current thread.\n- *\n- * This function differs from g_private_set() in the following way: if\n- * the previous value was non-%NULL then the #GDestroyNotify handler for\n- * @key is run on it.\n- *\n- * Since: 2.32\n- **\/\n-void\n-g_private_replace (GPrivate *key,\n-                   gpointer  value)\n+G_ALWAYS_INLINE static inline void\n+g_private_replace_impl (GPrivate *key,\n+                        gpointer  value)\n@@ -1203,1 +666,1 @@\n-  pthread_key_t impl = g_private_get_impl (key);\n+  pthread_key_t impl = _g_private_get_impl (key);\n@@ -1318,10 +781,2 @@\n-\/**\n- * g_thread_yield:\n- *\n- * Causes the calling thread to voluntarily relinquish the CPU, so\n- * that other threads can run.\n- *\n- * This function is often used as a method to make busy wait less evil.\n- *\/\n-void\n-g_thread_yield (void)\n+G_ALWAYS_INLINE static inline void\n+g_thread_yield_impl (void)\n@@ -1439,1 +894,1 @@\n-g_mutex_init (GMutex *mutex)\n+g_mutex_init_impl (GMutex *mutex)\n@@ -1445,1 +900,1 @@\n-g_mutex_clear (GMutex *mutex)\n+g_mutex_clear_impl (GMutex *mutex)\n@@ -1487,2 +942,2 @@\n-void\n-g_mutex_lock (GMutex *mutex)\n+inline void\n+g_mutex_lock_impl (GMutex *mutex)\n@@ -1498,1 +953,1 @@\n-g_mutex_unlock (GMutex *mutex)\n+g_mutex_unlock_impl (GMutex *mutex)\n@@ -1510,1 +965,1 @@\n-g_mutex_trylock (GMutex *mutex)\n+g_mutex_trylock_impl (GMutex *mutex)\n@@ -1535,1 +990,1 @@\n-g_cond_init (GCond *cond)\n+g_cond_init_impl (GCond *cond)\n@@ -1541,1 +996,1 @@\n-g_cond_clear (GCond *cond)\n+g_cond_clear_impl (GCond *cond)\n@@ -1546,2 +1001,2 @@\n-g_cond_wait (GCond  *cond,\n-             GMutex *mutex)\n+g_cond_wait_impl (GCond  *cond,\n+                  GMutex *mutex)\n@@ -1557,1 +1012,1 @@\n-g_cond_signal (GCond *cond)\n+g_cond_signal_impl (GCond *cond)\n@@ -1565,1 +1020,1 @@\n-g_cond_broadcast (GCond *cond)\n+g_cond_broadcast_impl (GCond *cond)\n@@ -1573,3 +1028,3 @@\n-g_cond_wait_until (GCond  *cond,\n-                   GMutex *mutex,\n-                   gint64  end_time)\n+g_cond_wait_until_impl (GCond  *cond,\n+                        GMutex *mutex,\n+                        gint64  end_time)\n@@ -1608,1 +1063,5 @@\n-   *   b) otherwise (or if that returns `ENOSYS`), we call the normal `futex`\n+   *   b) if `futex_time64` is available, but the Android runtime's API level\n+   *      is < 30, `futex_time64` is blocked by seccomp and using it will cause\n+   *      the app to be terminated. Skip to c).\n+   *         https:\/\/android-review.googlesource.com\/c\/platform\/bionic\/+\/1094758\n+   *   c) otherwise (or if that returns `ENOSYS`), we call the normal `futex`\n@@ -1613,1 +1072,1 @@\n-   *   c) With very old headers (~2.6.x), `__kernel_long_t` is not available, and\n+   *   d) With very old headers (~2.6.x), `__kernel_long_t` is not available, and\n@@ -1623,1 +1082,4 @@\n-#ifdef __NR_futex_time64\n+#if defined(HAVE_FUTEX_TIME64)\n+#if defined(__ANDROID__)\n+  if (__builtin_available (android 30, *)) {\n+#else\n@@ -1625,0 +1087,1 @@\n+#endif\n@@ -1640,1 +1103,1 @@\n-#  ifdef __NR_futex\n+#  if defined(HAVE_FUTEX)\n@@ -1642,1 +1105,1 @@\n-#  endif \/* defined(__NR_futex) *\/\n+#  endif \/* defined(HAVE_FUTEX) *\/\n@@ -1652,1 +1115,1 @@\n-#ifdef __NR_futex\n+#if defined(HAVE_FUTEX)\n@@ -1684,1 +1147,1 @@\n-#endif \/* defined(__NR_futex) *\/\n+#endif \/* defined(HAVE_FUTEX) *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gthread-posix.c","additions":95,"deletions":632,"binary":false,"changes":727,"status":"modified"},{"patch":"@@ -81,2 +81,2 @@\n-void\n-g_mutex_init (GMutex *mutex)\n+G_ALWAYS_INLINE static inline void\n+g_mutex_init_impl (GMutex *mutex)\n@@ -87,2 +87,2 @@\n-void\n-g_mutex_clear (GMutex *mutex)\n+G_ALWAYS_INLINE static inline void\n+g_mutex_clear_impl (GMutex *mutex)\n@@ -92,2 +92,2 @@\n-void\n-g_mutex_lock (GMutex *mutex)\n+G_ALWAYS_INLINE static inline void\n+g_mutex_lock_impl (GMutex *mutex)\n@@ -98,2 +98,2 @@\n-gboolean\n-g_mutex_trylock (GMutex *mutex)\n+G_ALWAYS_INLINE static inline gboolean\n+g_mutex_trylock_impl (GMutex *mutex)\n@@ -104,2 +104,2 @@\n-void\n-g_mutex_unlock (GMutex *mutex)\n+G_ALWAYS_INLINE static inline void\n+g_mutex_unlock_impl (GMutex *mutex)\n@@ -146,2 +146,2 @@\n-void\n-g_rec_mutex_init (GRecMutex *mutex)\n+G_ALWAYS_INLINE static inline void\n+g_rec_mutex_init_impl (GRecMutex *mutex)\n@@ -152,2 +152,2 @@\n-void\n-g_rec_mutex_clear (GRecMutex *mutex)\n+G_ALWAYS_INLINE static inline void\n+g_rec_mutex_clear_impl (GRecMutex *mutex)\n@@ -158,2 +158,2 @@\n-void\n-g_rec_mutex_lock (GRecMutex *mutex)\n+G_ALWAYS_INLINE static inline void\n+g_rec_mutex_lock_impl (GRecMutex *mutex)\n@@ -164,2 +164,2 @@\n-void\n-g_rec_mutex_unlock (GRecMutex *mutex)\n+G_ALWAYS_INLINE static inline void\n+g_rec_mutex_unlock_impl (GRecMutex *mutex)\n@@ -170,2 +170,2 @@\n-gboolean\n-g_rec_mutex_trylock (GRecMutex *mutex)\n+G_ALWAYS_INLINE static inline gboolean\n+g_rec_mutex_trylock_impl (GRecMutex *mutex)\n@@ -178,2 +178,2 @@\n-void\n-g_rw_lock_init (GRWLock *lock)\n+G_ALWAYS_INLINE static inline void\n+g_rw_lock_init_impl (GRWLock *lock)\n@@ -184,2 +184,2 @@\n-void\n-g_rw_lock_clear (GRWLock *lock)\n+G_ALWAYS_INLINE static inline void\n+g_rw_lock_clear_impl (GRWLock *lock)\n@@ -189,2 +189,2 @@\n-void\n-g_rw_lock_writer_lock (GRWLock *lock)\n+G_ALWAYS_INLINE static inline void\n+g_rw_lock_writer_lock_impl (GRWLock *lock)\n@@ -195,2 +195,2 @@\n-gboolean\n-g_rw_lock_writer_trylock (GRWLock *lock)\n+G_ALWAYS_INLINE static inline gboolean\n+g_rw_lock_writer_trylock_impl (GRWLock *lock)\n@@ -201,2 +201,2 @@\n-void\n-g_rw_lock_writer_unlock (GRWLock *lock)\n+G_ALWAYS_INLINE static inline void\n+g_rw_lock_writer_unlock_impl (GRWLock *lock)\n@@ -207,2 +207,2 @@\n-void\n-g_rw_lock_reader_lock (GRWLock *lock)\n+G_ALWAYS_INLINE static inline void\n+g_rw_lock_reader_lock_impl (GRWLock *lock)\n@@ -213,2 +213,2 @@\n-gboolean\n-g_rw_lock_reader_trylock (GRWLock *lock)\n+G_ALWAYS_INLINE static inline gboolean\n+g_rw_lock_reader_trylock_impl (GRWLock *lock)\n@@ -219,2 +219,2 @@\n-void\n-g_rw_lock_reader_unlock (GRWLock *lock)\n+G_ALWAYS_INLINE static inline void\n+g_rw_lock_reader_unlock_impl (GRWLock *lock)\n@@ -226,2 +226,2 @@\n-void\n-g_cond_init (GCond *cond)\n+G_ALWAYS_INLINE static inline void\n+g_cond_init_impl (GCond *cond)\n@@ -232,2 +232,2 @@\n-void\n-g_cond_clear (GCond *cond)\n+G_ALWAYS_INLINE static inline void\n+g_cond_clear_impl (GCond *cond)\n@@ -237,2 +237,2 @@\n-void\n-g_cond_signal (GCond *cond)\n+G_ALWAYS_INLINE static inline void\n+g_cond_signal_impl (GCond *cond)\n@@ -243,2 +243,2 @@\n-void\n-g_cond_broadcast (GCond *cond)\n+G_ALWAYS_INLINE static inline void\n+g_cond_broadcast_impl (GCond *cond)\n@@ -249,3 +249,3 @@\n-void\n-g_cond_wait (GCond  *cond,\n-             GMutex *entered_mutex)\n+G_ALWAYS_INLINE static inline void\n+g_cond_wait_impl (GCond  *cond,\n+                  GMutex *entered_mutex)\n@@ -256,4 +256,4 @@\n-gboolean\n-g_cond_wait_until (GCond  *cond,\n-                   GMutex *entered_mutex,\n-                   gint64  end_time)\n+G_ALWAYS_INLINE static inline gboolean\n+g_cond_wait_until_impl (GCond  *cond,\n+                        GMutex *entered_mutex,\n+                        gint64  end_time)\n@@ -310,1 +310,1 @@\n-g_private_get_impl (GPrivate *key)\n+_g_private_get_impl (GPrivate *key)\n@@ -368,2 +368,2 @@\n-gpointer\n-g_private_get (GPrivate *key)\n+G_ALWAYS_INLINE static inline gpointer\n+g_private_get_impl (GPrivate *key)\n@@ -371,1 +371,1 @@\n-  return TlsGetValue (g_private_get_impl (key));\n+  return TlsGetValue (_g_private_get_impl (key));\n@@ -374,3 +374,3 @@\n-void\n-g_private_set (GPrivate *key,\n-               gpointer  value)\n+G_ALWAYS_INLINE static inline void\n+g_private_set_impl (GPrivate *key,\n+                    gpointer  value)\n@@ -378,1 +378,1 @@\n-  TlsSetValue (g_private_get_impl (key), value);\n+  TlsSetValue (_g_private_get_impl (key), value);\n@@ -381,3 +381,3 @@\n-void\n-g_private_replace (GPrivate *key,\n-                   gpointer  value)\n+G_ALWAYS_INLINE static inline void\n+g_private_replace_impl (GPrivate *key,\n+                        gpointer  value)\n@@ -385,1 +385,1 @@\n-  DWORD impl = g_private_get_impl (key);\n+  DWORD impl = _g_private_get_impl (key);\n@@ -524,2 +524,2 @@\n-void\n-g_thread_yield (void)\n+G_ALWAYS_INLINE static inline void\n+g_thread_yield_impl (void)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gthread-win32.c","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -69,0 +69,57 @@\n+\/* In order that the API can be defined in one place (this file), the platform\n+ * specific code is moved out into separate files so this one doesnโt turn into\n+ * a massive #ifdef tangle.\n+ *\n+ * To avoid the functions in this file becoming tiny trampolines (`jmp` to the\n+ * relevant `_impl` function only), which would be a performance hit on some\n+ * hot paths, #include the platform specific implementations. They are marked as\n+ * `inline` so should be inlined correctly by the compiler without the need for\n+ * link time optimisation or any fancy tricks.\n+ *\/\n+static inline void g_mutex_init_impl (GMutex *mutex);\n+static inline void g_mutex_clear_impl (GMutex *mutex);\n+static inline void g_mutex_lock_impl (GMutex *mutex);\n+static inline void g_mutex_unlock_impl (GMutex *mutex);\n+static inline gboolean g_mutex_trylock_impl (GMutex *mutex);\n+\n+static inline void g_rec_mutex_init_impl (GRecMutex *rec_mutex);\n+static inline void g_rec_mutex_clear_impl (GRecMutex *rec_mutex);\n+static inline void g_rec_mutex_lock_impl (GRecMutex *mutex);\n+static inline void g_rec_mutex_unlock_impl (GRecMutex *rec_mutex);\n+static inline gboolean g_rec_mutex_trylock_impl (GRecMutex *rec_mutex);\n+\n+static inline void g_rw_lock_init_impl (GRWLock *rw_lock);\n+static inline void g_rw_lock_clear_impl (GRWLock *rw_lock);\n+static inline void g_rw_lock_writer_lock_impl (GRWLock *rw_lock);\n+static inline gboolean g_rw_lock_writer_trylock_impl (GRWLock *rw_lock);\n+static inline void g_rw_lock_writer_unlock_impl (GRWLock *rw_lock);\n+static inline void g_rw_lock_reader_lock_impl (GRWLock *rw_lock);\n+static inline gboolean g_rw_lock_reader_trylock_impl (GRWLock *rw_lock);\n+static inline void g_rw_lock_reader_unlock_impl (GRWLock *rw_lock);\n+\n+static inline void g_cond_init_impl (GCond *cond);\n+static inline void g_cond_clear_impl (GCond *cond);\n+static inline void g_cond_wait_impl (GCond  *cond,\n+                                     GMutex *mutex);\n+static inline void g_cond_signal_impl (GCond *cond);\n+static inline void g_cond_broadcast_impl (GCond *cond);\n+static inline gboolean g_cond_wait_until_impl (GCond  *cond,\n+                                               GMutex *mutex,\n+                                               gint64  end_time);\n+\n+static inline gpointer g_private_get_impl (GPrivate *key);\n+static inline void g_private_set_impl (GPrivate *key,\n+                                       gpointer  value);\n+static inline void g_private_replace_impl (GPrivate *key,\n+                                           gpointer  value);\n+\n+static inline void g_thread_yield_impl (void);\n+\n+#if defined(THREADS_POSIX)\n+#include \"gthread-posix.c\"\n+#elif defined(THREADS_WIN32)\n+#include \"gthread-win32.c\"\n+#else\n+#error \"No threads implementation\"\n+#endif\n+\n@@ -1132,0 +1189,726 @@\n+\/**\n+ * g_mutex_init:\n+ * @mutex: an uninitialized #GMutex\n+ *\n+ * Initializes a #GMutex so that it can be used.\n+ *\n+ * This function is useful to initialize a mutex that has been\n+ * allocated on the stack, or as part of a larger structure.\n+ * It is not necessary to initialize a mutex that has been\n+ * statically allocated.\n+ *\n+ * |[<!-- language=\"C\" -->\n+ *   typedef struct {\n+ *     GMutex m;\n+ *     ...\n+ *   } Blob;\n+ *\n+ * Blob *b;\n+ *\n+ * b = g_new (Blob, 1);\n+ * g_mutex_init (&b->m);\n+ * ]|\n+ *\n+ * To undo the effect of g_mutex_init() when a mutex is no longer\n+ * needed, use g_mutex_clear().\n+ *\n+ * Calling g_mutex_init() on an already initialized #GMutex leads\n+ * to undefined behaviour.\n+ *\n+ * Since: 2.32\n+ *\/\n+void\n+g_mutex_init (GMutex *mutex)\n+{\n+  g_mutex_init_impl (mutex);\n+}\n+\n+\/**\n+ * g_mutex_clear:\n+ * @mutex: an initialized #GMutex\n+ *\n+ * Frees the resources allocated to a mutex with g_mutex_init().\n+ *\n+ * This function should not be used with a #GMutex that has been\n+ * statically allocated.\n+ *\n+ * Calling g_mutex_clear() on a locked mutex leads to undefined\n+ * behaviour.\n+ *\n+ * Since: 2.32\n+ *\/\n+void\n+g_mutex_clear (GMutex *mutex)\n+{\n+  g_mutex_clear_impl (mutex);\n+}\n+\n+\/**\n+ * g_mutex_lock:\n+ * @mutex: a #GMutex\n+ *\n+ * Locks @mutex. If @mutex is already locked by another thread, the\n+ * current thread will block until @mutex is unlocked by the other\n+ * thread.\n+ *\n+ * #GMutex is neither guaranteed to be recursive nor to be\n+ * non-recursive.  As such, calling g_mutex_lock() on a #GMutex that has\n+ * already been locked by the same thread results in undefined behaviour\n+ * (including but not limited to deadlocks).\n+ *\/\n+void\n+g_mutex_lock (GMutex *mutex)\n+{\n+  g_mutex_lock_impl (mutex);\n+}\n+\n+\/**\n+ * g_mutex_unlock:\n+ * @mutex: a #GMutex\n+ *\n+ * Unlocks @mutex. If another thread is blocked in a g_mutex_lock()\n+ * call for @mutex, it will become unblocked and can lock @mutex itself.\n+ *\n+ * Calling g_mutex_unlock() on a mutex that is not locked by the\n+ * current thread leads to undefined behaviour.\n+ *\/\n+void\n+g_mutex_unlock (GMutex *mutex)\n+{\n+  g_mutex_unlock_impl (mutex);\n+}\n+\n+\/**\n+ * g_mutex_trylock:\n+ * @mutex: a #GMutex\n+ *\n+ * Tries to lock @mutex. If @mutex is already locked by another thread,\n+ * it immediately returns %FALSE. Otherwise it locks @mutex and returns\n+ * %TRUE.\n+ *\n+ * #GMutex is neither guaranteed to be recursive nor to be\n+ * non-recursive.  As such, calling g_mutex_lock() on a #GMutex that has\n+ * already been locked by the same thread results in undefined behaviour\n+ * (including but not limited to deadlocks or arbitrary return values).\n+ *\n+ * Returns: %TRUE if @mutex could be locked\n+ *\/\n+gboolean\n+g_mutex_trylock (GMutex *mutex)\n+{\n+  return g_mutex_trylock_impl (mutex);\n+}\n+\n+\/**\n+ * g_rec_mutex_init:\n+ * @rec_mutex: an uninitialized #GRecMutex\n+ *\n+ * Initializes a #GRecMutex so that it can be used.\n+ *\n+ * This function is useful to initialize a recursive mutex\n+ * that has been allocated on the stack, or as part of a larger\n+ * structure.\n+ *\n+ * It is not necessary to initialise a recursive mutex that has been\n+ * statically allocated.\n+ *\n+ * |[<!-- language=\"C\" -->\n+ *   typedef struct {\n+ *     GRecMutex m;\n+ *     ...\n+ *   } Blob;\n+ *\n+ * Blob *b;\n+ *\n+ * b = g_new (Blob, 1);\n+ * g_rec_mutex_init (&b->m);\n+ * ]|\n+ *\n+ * Calling g_rec_mutex_init() on an already initialized #GRecMutex\n+ * leads to undefined behaviour.\n+ *\n+ * To undo the effect of g_rec_mutex_init() when a recursive mutex\n+ * is no longer needed, use g_rec_mutex_clear().\n+ *\n+ * Since: 2.32\n+ *\/\n+void\n+g_rec_mutex_init (GRecMutex *rec_mutex)\n+{\n+  g_rec_mutex_init_impl (rec_mutex);\n+}\n+\n+\/**\n+ * g_rec_mutex_clear:\n+ * @rec_mutex: an initialized #GRecMutex\n+ *\n+ * Frees the resources allocated to a recursive mutex with\n+ * g_rec_mutex_init().\n+ *\n+ * This function should not be used with a #GRecMutex that has been\n+ * statically allocated.\n+ *\n+ * Calling g_rec_mutex_clear() on a locked recursive mutex leads\n+ * to undefined behaviour.\n+ *\n+ * Since: 2.32\n+ *\/\n+void\n+g_rec_mutex_clear (GRecMutex *rec_mutex)\n+{\n+  g_rec_mutex_clear_impl (rec_mutex);\n+}\n+\n+\/**\n+ * g_rec_mutex_lock:\n+ * @rec_mutex: a #GRecMutex\n+ *\n+ * Locks @rec_mutex. If @rec_mutex is already locked by another\n+ * thread, the current thread will block until @rec_mutex is\n+ * unlocked by the other thread. If @rec_mutex is already locked\n+ * by the current thread, the 'lock count' of @rec_mutex is increased.\n+ * The mutex will only become available again when it is unlocked\n+ * as many times as it has been locked.\n+ *\n+ * Since: 2.32\n+ *\/\n+void\n+g_rec_mutex_lock (GRecMutex *mutex)\n+{\n+  g_rec_mutex_lock_impl (mutex);\n+}\n+\n+\/**\n+ * g_rec_mutex_unlock:\n+ * @rec_mutex: a #GRecMutex\n+ *\n+ * Unlocks @rec_mutex. If another thread is blocked in a\n+ * g_rec_mutex_lock() call for @rec_mutex, it will become unblocked\n+ * and can lock @rec_mutex itself.\n+ *\n+ * Calling g_rec_mutex_unlock() on a recursive mutex that is not\n+ * locked by the current thread leads to undefined behaviour.\n+ *\n+ * Since: 2.32\n+ *\/\n+void\n+g_rec_mutex_unlock (GRecMutex *rec_mutex)\n+{\n+  g_rec_mutex_unlock_impl (rec_mutex);\n+}\n+\n+\/**\n+ * g_rec_mutex_trylock:\n+ * @rec_mutex: a #GRecMutex\n+ *\n+ * Tries to lock @rec_mutex. If @rec_mutex is already locked\n+ * by another thread, it immediately returns %FALSE. Otherwise\n+ * it locks @rec_mutex and returns %TRUE.\n+ *\n+ * Returns: %TRUE if @rec_mutex could be locked\n+ *\n+ * Since: 2.32\n+ *\/\n+gboolean\n+g_rec_mutex_trylock (GRecMutex *rec_mutex)\n+{\n+  return g_rec_mutex_trylock_impl (rec_mutex);\n+}\n+\n+\/* {{{1 GRWLock *\/\n+\n+\/**\n+ * g_rw_lock_init:\n+ * @rw_lock: an uninitialized #GRWLock\n+ *\n+ * Initializes a #GRWLock so that it can be used.\n+ *\n+ * This function is useful to initialize a lock that has been\n+ * allocated on the stack, or as part of a larger structure.  It is not\n+ * necessary to initialise a reader-writer lock that has been statically\n+ * allocated.\n+ *\n+ * |[<!-- language=\"C\" -->\n+ *   typedef struct {\n+ *     GRWLock l;\n+ *     ...\n+ *   } Blob;\n+ *\n+ * Blob *b;\n+ *\n+ * b = g_new (Blob, 1);\n+ * g_rw_lock_init (&b->l);\n+ * ]|\n+ *\n+ * To undo the effect of g_rw_lock_init() when a lock is no longer\n+ * needed, use g_rw_lock_clear().\n+ *\n+ * Calling g_rw_lock_init() on an already initialized #GRWLock leads\n+ * to undefined behaviour.\n+ *\n+ * Since: 2.32\n+ *\/\n+void\n+g_rw_lock_init (GRWLock *rw_lock)\n+{\n+  g_rw_lock_init_impl (rw_lock);\n+}\n+\n+\/**\n+ * g_rw_lock_clear:\n+ * @rw_lock: an initialized #GRWLock\n+ *\n+ * Frees the resources allocated to a lock with g_rw_lock_init().\n+ *\n+ * This function should not be used with a #GRWLock that has been\n+ * statically allocated.\n+ *\n+ * Calling g_rw_lock_clear() when any thread holds the lock\n+ * leads to undefined behaviour.\n+ *\n+ * Since: 2.32\n+ *\/\n+void\n+g_rw_lock_clear (GRWLock *rw_lock)\n+{\n+  g_rw_lock_clear_impl (rw_lock);\n+}\n+\n+\/**\n+ * g_rw_lock_writer_lock:\n+ * @rw_lock: a #GRWLock\n+ *\n+ * Obtain a write lock on @rw_lock. If another thread currently holds\n+ * a read or write lock on @rw_lock, the current thread will block\n+ * until all other threads have dropped their locks on @rw_lock.\n+ *\n+ * Calling g_rw_lock_writer_lock() while the current thread already\n+ * owns a read or write lock on @rw_lock leads to undefined behaviour.\n+ *\n+ * Since: 2.32\n+ *\/\n+void\n+g_rw_lock_writer_lock (GRWLock *rw_lock)\n+{\n+  g_rw_lock_writer_lock_impl (rw_lock);\n+}\n+\n+\/**\n+ * g_rw_lock_writer_trylock:\n+ * @rw_lock: a #GRWLock\n+ *\n+ * Tries to obtain a write lock on @rw_lock. If another thread\n+ * currently holds a read or write lock on @rw_lock, it immediately\n+ * returns %FALSE.\n+ * Otherwise it locks @rw_lock and returns %TRUE.\n+ *\n+ * Returns: %TRUE if @rw_lock could be locked\n+ *\n+ * Since: 2.32\n+ *\/\n+gboolean\n+g_rw_lock_writer_trylock (GRWLock *rw_lock)\n+{\n+  return g_rw_lock_writer_trylock_impl (rw_lock);\n+}\n+\n+\/**\n+ * g_rw_lock_writer_unlock:\n+ * @rw_lock: a #GRWLock\n+ *\n+ * Release a write lock on @rw_lock.\n+ *\n+ * Calling g_rw_lock_writer_unlock() on a lock that is not held\n+ * by the current thread leads to undefined behaviour.\n+ *\n+ * Since: 2.32\n+ *\/\n+void\n+g_rw_lock_writer_unlock (GRWLock *rw_lock)\n+{\n+  g_rw_lock_writer_unlock_impl (rw_lock);\n+}\n+\n+\/**\n+ * g_rw_lock_reader_lock:\n+ * @rw_lock: a #GRWLock\n+ *\n+ * Obtain a read lock on @rw_lock. If another thread currently holds\n+ * the write lock on @rw_lock, the current thread will block until the\n+ * write lock was (held and) released. If another thread does not hold\n+ * the write lock, but is waiting for it, it is implementation defined\n+ * whether the reader or writer will block. Read locks can be taken\n+ * recursively.\n+ *\n+ * Calling g_rw_lock_reader_lock() while the current thread already\n+ * owns a write lock leads to undefined behaviour. Read locks however\n+ * can be taken recursively, in which case you need to make sure to\n+ * call g_rw_lock_reader_unlock() the same amount of times.\n+ *\n+ * It is implementation-defined how many read locks are allowed to be\n+ * held on the same lock simultaneously. If the limit is hit,\n+ * or if a deadlock is detected, a critical warning will be emitted.\n+ *\n+ * Since: 2.32\n+ *\/\n+void\n+g_rw_lock_reader_lock (GRWLock *rw_lock)\n+{\n+  g_rw_lock_reader_lock_impl (rw_lock);\n+}\n+\n+\/**\n+ * g_rw_lock_reader_trylock:\n+ * @rw_lock: a #GRWLock\n+ *\n+ * Tries to obtain a read lock on @rw_lock and returns %TRUE if\n+ * the read lock was successfully obtained. Otherwise it\n+ * returns %FALSE.\n+ *\n+ * Returns: %TRUE if @rw_lock could be locked\n+ *\n+ * Since: 2.32\n+ *\/\n+gboolean\n+g_rw_lock_reader_trylock (GRWLock *rw_lock)\n+{\n+  return g_rw_lock_reader_trylock_impl (rw_lock);\n+}\n+\n+\/**\n+ * g_rw_lock_reader_unlock:\n+ * @rw_lock: a #GRWLock\n+ *\n+ * Release a read lock on @rw_lock.\n+ *\n+ * Calling g_rw_lock_reader_unlock() on a lock that is not held\n+ * by the current thread leads to undefined behaviour.\n+ *\n+ * Since: 2.32\n+ *\/\n+void\n+g_rw_lock_reader_unlock (GRWLock *rw_lock)\n+{\n+  g_rw_lock_reader_unlock_impl (rw_lock);\n+}\n+\n+\/* {{{1 GCond *\/\n+\n+\/**\n+ * g_cond_init:\n+ * @cond: an uninitialized #GCond\n+ *\n+ * Initialises a #GCond so that it can be used.\n+ *\n+ * This function is useful to initialise a #GCond that has been\n+ * allocated as part of a larger structure.  It is not necessary to\n+ * initialise a #GCond that has been statically allocated.\n+ *\n+ * To undo the effect of g_cond_init() when a #GCond is no longer\n+ * needed, use g_cond_clear().\n+ *\n+ * Calling g_cond_init() on an already-initialised #GCond leads\n+ * to undefined behaviour.\n+ *\n+ * Since: 2.32\n+ *\/\n+void\n+g_cond_init (GCond *cond)\n+{\n+  g_cond_init_impl (cond);\n+}\n+\n+\/**\n+ * g_cond_clear:\n+ * @cond: an initialised #GCond\n+ *\n+ * Frees the resources allocated to a #GCond with g_cond_init().\n+ *\n+ * This function should not be used with a #GCond that has been\n+ * statically allocated.\n+ *\n+ * Calling g_cond_clear() for a #GCond on which threads are\n+ * blocking leads to undefined behaviour.\n+ *\n+ * Since: 2.32\n+ *\/\n+void\n+g_cond_clear (GCond *cond)\n+{\n+  g_cond_clear_impl (cond);\n+}\n+\n+\/**\n+ * g_cond_wait:\n+ * @cond: a #GCond\n+ * @mutex: a #GMutex that is currently locked\n+ *\n+ * Atomically releases @mutex and waits until @cond is signalled.\n+ * When this function returns, @mutex is locked again and owned by the\n+ * calling thread.\n+ *\n+ * When using condition variables, it is possible that a spurious wakeup\n+ * may occur (ie: g_cond_wait() returns even though g_cond_signal() was\n+ * not called).  It's also possible that a stolen wakeup may occur.\n+ * This is when g_cond_signal() is called, but another thread acquires\n+ * @mutex before this thread and modifies the state of the program in\n+ * such a way that when g_cond_wait() is able to return, the expected\n+ * condition is no longer met.\n+ *\n+ * For this reason, g_cond_wait() must always be used in a loop.  See\n+ * the documentation for #GCond for a complete example.\n+ **\/\n+void\n+g_cond_wait (GCond  *cond,\n+             GMutex *mutex)\n+{\n+  g_cond_wait_impl (cond, mutex);\n+}\n+\n+\/**\n+ * g_cond_signal:\n+ * @cond: a #GCond\n+ *\n+ * If threads are waiting for @cond, at least one of them is unblocked.\n+ * If no threads are waiting for @cond, this function has no effect.\n+ * It is good practice to hold the same lock as the waiting thread\n+ * while calling this function, though not required.\n+ *\/\n+void\n+g_cond_signal (GCond *cond)\n+{\n+  g_cond_signal_impl (cond);\n+}\n+\n+\/**\n+ * g_cond_broadcast:\n+ * @cond: a #GCond\n+ *\n+ * If threads are waiting for @cond, all of them are unblocked.\n+ * If no threads are waiting for @cond, this function has no effect.\n+ * It is good practice to lock the same mutex as the waiting threads\n+ * while calling this function, though not required.\n+ *\/\n+void\n+g_cond_broadcast (GCond *cond)\n+{\n+  g_cond_broadcast_impl (cond);\n+}\n+\n+\/**\n+ * g_cond_wait_until:\n+ * @cond: a #GCond\n+ * @mutex: a #GMutex that is currently locked\n+ * @end_time: the monotonic time to wait until\n+ *\n+ * Waits until either @cond is signalled or @end_time has passed.\n+ *\n+ * As with g_cond_wait() it is possible that a spurious or stolen wakeup\n+ * could occur.  For that reason, waiting on a condition variable should\n+ * always be in a loop, based on an explicitly-checked predicate.\n+ *\n+ * %TRUE is returned if the condition variable was signalled (or in the\n+ * case of a spurious wakeup).  %FALSE is returned if @end_time has\n+ * passed.\n+ *\n+ * The following code shows how to correctly perform a timed wait on a\n+ * condition variable (extending the example presented in the\n+ * documentation for #GCond):\n+ *\n+ * |[<!-- language=\"C\" -->\n+ * gpointer\n+ * pop_data_timed (void)\n+ * {\n+ *   gint64 end_time;\n+ *   gpointer data;\n+ *\n+ *   g_mutex_lock (&data_mutex);\n+ *\n+ *   end_time = g_get_monotonic_time () + 5 * G_TIME_SPAN_SECOND;\n+ *   while (!current_data)\n+ *     if (!g_cond_wait_until (&data_cond, &data_mutex, end_time))\n+ *       {\n+ *         \/\/ timeout has passed.\n+ *         g_mutex_unlock (&data_mutex);\n+ *         return NULL;\n+ *       }\n+ *\n+ *   \/\/ there is data for us\n+ *   data = current_data;\n+ *   current_data = NULL;\n+ *\n+ *   g_mutex_unlock (&data_mutex);\n+ *\n+ *   return data;\n+ * }\n+ * ]|\n+ *\n+ * Notice that the end time is calculated once, before entering the\n+ * loop and reused.  This is the motivation behind the use of absolute\n+ * time on this API -- if a relative time of 5 seconds were passed\n+ * directly to the call and a spurious wakeup occurred, the program would\n+ * have to start over waiting again (which would lead to a total wait\n+ * time of more than 5 seconds).\n+ *\n+ * Returns: %TRUE on a signal, %FALSE on a timeout\n+ * Since: 2.32\n+ **\/\n+gboolean\n+g_cond_wait_until (GCond  *cond,\n+                   GMutex *mutex,\n+                   gint64  end_time)\n+{\n+  return g_cond_wait_until_impl (cond, mutex, end_time);\n+}\n+\n+\/* {{{1 GPrivate *\/\n+\n+\/**\n+ * GPrivate:\n+ *\n+ * The #GPrivate struct is an opaque data structure to represent a\n+ * thread-local data key. It is approximately equivalent to the\n+ * pthread_setspecific()\/pthread_getspecific() APIs on POSIX and to\n+ * TlsSetValue()\/TlsGetValue() on Windows.\n+ *\n+ * If you don't already know why you might want this functionality,\n+ * then you probably don't need it.\n+ *\n+ * #GPrivate is a very limited resource (as far as 128 per program,\n+ * shared between all libraries). It is also not possible to destroy a\n+ * #GPrivate after it has been used. As such, it is only ever acceptable\n+ * to use #GPrivate in static scope, and even then sparingly so.\n+ *\n+ * See G_PRIVATE_INIT() for a couple of examples.\n+ *\n+ * The #GPrivate structure should be considered opaque.  It should only\n+ * be accessed via the g_private_ functions.\n+ *\/\n+\n+\/**\n+ * G_PRIVATE_INIT:\n+ * @notify: a #GDestroyNotify\n+ *\n+ * A macro to assist with the static initialisation of a #GPrivate.\n+ *\n+ * This macro is useful for the case that a #GDestroyNotify function\n+ * should be associated with the key.  This is needed when the key will be\n+ * used to point at memory that should be deallocated when the thread\n+ * exits.\n+ *\n+ * Additionally, the #GDestroyNotify will also be called on the previous\n+ * value stored in the key when g_private_replace() is used.\n+ *\n+ * If no #GDestroyNotify is needed, then use of this macro is not\n+ * required -- if the #GPrivate is declared in static scope then it will\n+ * be properly initialised by default (ie: to all zeros).  See the\n+ * examples below.\n+ *\n+ * |[<!-- language=\"C\" -->\n+ * static GPrivate name_key = G_PRIVATE_INIT (g_free);\n+ *\n+ * \/\/ return value should not be freed\n+ * const gchar *\n+ * get_local_name (void)\n+ * {\n+ *   return g_private_get (&name_key);\n+ * }\n+ *\n+ * void\n+ * set_local_name (const gchar *name)\n+ * {\n+ *   g_private_replace (&name_key, g_strdup (name));\n+ * }\n+ *\n+ *\n+ * static GPrivate count_key;   \/\/ no free function\n+ *\n+ * gint\n+ * get_local_count (void)\n+ * {\n+ *   return GPOINTER_TO_INT (g_private_get (&count_key));\n+ * }\n+ *\n+ * void\n+ * set_local_count (gint count)\n+ * {\n+ *   g_private_set (&count_key, GINT_TO_POINTER (count));\n+ * }\n+ * ]|\n+ *\n+ * Since: 2.32\n+ **\/\n+\n+\/**\n+ * g_private_get:\n+ * @key: a #GPrivate\n+ *\n+ * Returns the current value of the thread local variable @key.\n+ *\n+ * If the value has not yet been set in this thread, %NULL is returned.\n+ * Values are never copied between threads (when a new thread is\n+ * created, for example).\n+ *\n+ * Returns: the thread-local value\n+ *\/\n+gpointer\n+g_private_get (GPrivate *key)\n+{\n+  return g_private_get_impl (key);\n+}\n+\n+\/**\n+ * g_private_set:\n+ * @key: a #GPrivate\n+ * @value: the new value\n+ *\n+ * Sets the thread local variable @key to have the value @value in the\n+ * current thread.\n+ *\n+ * This function differs from g_private_replace() in the following way:\n+ * the #GDestroyNotify for @key is not called on the old value.\n+ *\/\n+void\n+g_private_set (GPrivate *key,\n+               gpointer  value)\n+{\n+  g_private_set_impl (key, value);\n+}\n+\n+\/**\n+ * g_private_replace:\n+ * @key: a #GPrivate\n+ * @value: the new value\n+ *\n+ * Sets the thread local variable @key to have the value @value in the\n+ * current thread.\n+ *\n+ * This function differs from g_private_set() in the following way: if\n+ * the previous value was non-%NULL then the #GDestroyNotify handler for\n+ * @key is run on it.\n+ *\n+ * Since: 2.32\n+ **\/\n+void\n+g_private_replace (GPrivate *key,\n+                   gpointer  value)\n+{\n+  g_private_replace_impl (key, value);\n+}\n+\n+\/* {{{1 GThread *\/\n+\n+\/**\n+ * g_thread_yield:\n+ *\n+ * Causes the calling thread to voluntarily relinquish the CPU, so\n+ * that other threads can run.\n+ *\n+ * This function is often used as a method to make busy wait less evil.\n+ *\/\n+void\n+g_thread_yield (void)\n+{\n+  g_thread_yield_impl ();\n+}\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gthread.c","additions":783,"deletions":0,"binary":false,"changes":783,"status":"modified"},{"patch":"@@ -67,0 +67,6 @@\n+ * The `futex_time64` syscall is also skipped in favour of `futex` if the\n+ * Android runtimeโs API level is lower than 30, as itโs blocked by seccomp\n+ * there and using it will cause the app to be terminated:\n+ *   https:\/\/android-review.googlesource.com\/c\/platform\/bionic\/+\/1094758\n+ *   https:\/\/github.com\/aosp-mirror\/platform_bionic\/commit\/ee7bc3002dc3127faac110167d28912eb0e86a20\n+ *\n@@ -70,1 +76,27 @@\n-#if defined(__NR_futex) && defined(__NR_futex_time64)\n+#if defined(HAVE_FUTEX) && defined(HAVE_FUTEX_TIME64)\n+#if defined(__ANDROID__)\n+#define g_futex_simple(uaddr, futex_op, ...)                                     \\\n+  G_STMT_START                                                                   \\\n+  {                                                                              \\\n+    int saved_errno = errno;                                                     \\\n+    int res = 0;                                                                 \\\n+    if (__builtin_available (android 30, *))                                     \\\n+      {                                                                          \\\n+        res = syscall (__NR_futex_time64, uaddr, (gsize) futex_op, __VA_ARGS__); \\\n+        if (res < 0 && errno == ENOSYS)                                          \\\n+          {                                                                      \\\n+            errno = saved_errno;                                                 \\\n+            res = syscall (__NR_futex, uaddr, (gsize) futex_op, __VA_ARGS__);    \\\n+          }                                                                      \\\n+      }                                                                          \\\n+    else                                                                         \\\n+      {                                                                          \\\n+        res = syscall (__NR_futex, uaddr, (gsize) futex_op, __VA_ARGS__);        \\\n+      }                                                                          \\\n+    if (res < 0 && errno == EAGAIN)                                              \\\n+      {                                                                          \\\n+        errno = saved_errno;                                                     \\\n+      }                                                                          \\\n+  }                                                                              \\\n+  G_STMT_END\n+#else\n@@ -87,1 +119,2 @@\n-#elif defined(__NR_futex_time64)\n+#endif \/* defined(__ANDROID__) *\/\n+#elif defined(HAVE_FUTEX_TIME64)\n@@ -99,1 +132,1 @@\n-#elif defined(__NR_futex)\n+#elif defined(HAVE_FUTEX)\n@@ -111,3 +144,3 @@\n-#else \/* !defined(__NR_futex) && !defined(__NR_futex_time64) *\/\n-#error \"Neither __NR_futex nor __NR_futex_time64 are defined but were found by meson\"\n-#endif \/* defined(__NR_futex) && defined(__NR_futex_time64) *\/\n+#else \/* !defined(HAVE_FUTEX) && !defined(HAVE_FUTEX_TIME64) *\/\n+#error \"Neither __NR_futex nor __NR_futex_time64 are available\"\n+#endif \/* defined(HAVE_FUTEX) && defined(HAVE_FUTEX_TIME64) *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gthreadprivate.h","additions":39,"deletions":6,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -283,0 +283,1 @@\n+  g_return_val_if_fail (tz != NULL, NULL);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gtimezone.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-  guint language_len;\n+  size_t language_len;\n@@ -192,1 +192,1 @@\n-  guint territory_len = 0;\n+  size_t territory_len = 0;\n@@ -194,1 +194,1 @@\n-  guint modifier_len = 0;\n+  size_t modifier_len = 0;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gtranslit.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -809,1 +809,1 @@\n-#define g_utf8_next_char(p) (char *)((p) + g_utf8_skip[*(const guchar *)(p)])\n+#define g_utf8_next_char(p) ((p) + g_utf8_skip[*(const guchar *)(p)])\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gunicode.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gtestutils.h\"\n@@ -435,3 +436,2 @@\n-      if (n_wc > 0)\n-  {\n-    cc = COMBINING_CLASS (wc_buffer[old_n_wc]);\n+      \/* Each code path above *must* have appended at least gunichar to wc_buffer. *\/\n+      g_assert (n_wc > old_n_wc);\n@@ -439,6 +439,7 @@\n-    if (cc == 0)\n-      {\n-        g_unicode_canonical_ordering (wc_buffer + last_start, n_wc - last_start);\n-        last_start = old_n_wc;\n-      }\n-  }\n+      cc = COMBINING_CLASS (wc_buffer[old_n_wc]);\n+\n+      if (cc == 0)\n+        {\n+          g_unicode_canonical_ordering (wc_buffer + last_start, n_wc - last_start);\n+          last_start = old_n_wc;\n+        }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gunidecomp.c","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -808,1 +808,1 @@\n-  gint len;\n+  size_t len;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/guniprop.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n- * [in constrast to RFC 3986](https:\/\/tools.ietf.org\/html\/rfc3986#section-4.3),\n+ * [in contrast to RFC 3986](https:\/\/tools.ietf.org\/html\/rfc3986#section-4.3),\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/guri.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1253,1 +1253,1 @@\n-  gint n_bytes;\n+  size_t n_bytes;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gutf8.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-      const gint program_length = strlen (program);\n+      const size_t program_length = strlen (program);\n@@ -3305,1 +3305,1 @@\n-#elif defined(HAVE_ISSETUGID) && !defined(__BIONIC__)\n+#elif defined(HAVE_ISSETUGID) && !defined(__ANDROID__)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gutils.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -330,1 +330,1 @@\n-  gint length = strlen (token);\n+  size_t length = strlen (token);\n@@ -333,1 +333,1 @@\n-         stream->stream - stream->this == length &&\n+         (size_t) (stream->stream - stream->this) == length &&\n@@ -2590,1 +2590,1 @@\n- * the [GVariant varargs documentation][gvariant-varargs].\n+ * the [GVariant varargs documentation](gvariant-format-strings.html#varargs).\n@@ -2649,1 +2649,1 @@\n- * the [GVariant varargs documentation][gvariant-varargs].\n+ * the [GVariant varargs documentation](gvariant-format-strings.html#varargs).\n@@ -2702,1 +2702,1 @@\n- * the [GVariant varargs documentation][gvariant-varargs].\n+ * the [GVariant varargs documentation](gvariant-format-strings.html#varargs).\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gvariant-parser.c","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -907,0 +907,2 @@\n+  g_assert (value.size != 0 || offsets.length == 0);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gvariant-serialiser.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * GVariant:\n+ * GVariant: (copy-func g_variant_ref_sink) (free-func g_variant_unref)\n@@ -1115,1 +1115,1 @@\n- * [serialized data memory][gvariant-serialized-data-memory].\n+ * [serialized data memory](struct.Variant.html#serialized-data-memory).\n@@ -1261,1 +1261,1 @@\n- * [format string][gvariant-format-strings-maybe-types].\n+ * [format string](gvariant-format-strings.html#maybe-types).\n@@ -2644,1 +2644,1 @@\n- * The format is described [here][gvariant-text].\n+ * The format is described [here](gvariant-text-format.html).\n@@ -3525,1 +3525,1 @@\n-#ifdef G_ANALYZER_ANALYZING\n+#if G_ANALYZER_ANALYZING\n@@ -4382,1 +4382,1 @@\n- * See the section on [GVariant format strings][gvariant-format-strings].\n+ * See the section on [GVariant format strings](gvariant-format-strings.html).\n@@ -4641,1 +4641,1 @@\n-  gchar *dest;\n+  gsize i;\n@@ -4650,1 +4650,2 @@\n-  dest = new = g_malloc (*endptr - string + 1);\n+  new = g_malloc (*endptr - string + 1);\n+  i = 0;\n@@ -4654,1 +4655,1 @@\n-        *dest++ = *string;\n+        new[i++] = *string;\n@@ -4657,1 +4658,3 @@\n-  *dest = '\\0';\n+  new[i++] = '\\0';\n+\n+  g_assert (g_variant_type_string_is_valid (new));\n@@ -4659,1 +4662,1 @@\n-  return (GVariantType *) G_VARIANT_TYPE (new);\n+  return (GVariantType *) new;\n@@ -5397,1 +5400,1 @@\n- * [GVariant format strings][gvariant-format-strings]. Please note that\n+ * [GVariant format strings](gvariant-format-strings.html). Please note that\n@@ -5407,1 +5410,1 @@\n- * the [GVariant varargs documentation][gvariant-varargs].\n+ * the [GVariant varargs documentation](gvariant-format-strings.html#varargs).\n@@ -5468,1 +5471,1 @@\n- * See the [GVariant varargs documentation][gvariant-varargs].\n+ * See the [GVariant varargs documentation](gvariant-format-strings.html#varargs).\n@@ -5524,1 +5527,1 @@\n- * [GVariant format strings][gvariant-format-strings].\n+ * [GVariant format strings](gvariant-format-strings.html).\n@@ -5624,1 +5627,1 @@\n- * the [GVariant varargs documentation][gvariant-varargs].\n+ * the [GVariant varargs documentation](gvariant-format-strings.html#varargs).\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gvariant.c","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -400,1 +400,1 @@\n- * used by this function as that interfers with having several\n+ * used by this function as that interferes with having several\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/glib\/gwin32.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-       (bind_local ? 0 : RTLD_GLOBAL) | (bind_lazy ? RTLD_LAZY : RTLD_NOW));\n+                   (bind_local ? RTLD_LOCAL : RTLD_GLOBAL) | (bind_lazy ? RTLD_LAZY : RTLD_NOW));\n@@ -170,1 +170,1 @@\n-#if defined(__BIONIC__) || defined(__NetBSD__) || defined(__FreeBSD__)\n+#if defined(__ANDROID__) || defined(__NetBSD__) || defined(__FreeBSD__)\n@@ -185,1 +185,1 @@\n-#if defined(__BIONIC__) || defined(__NetBSD__) || defined(__FreeBSD__)\n+#if defined(__ANDROID__) || defined(__NetBSD__) || defined(__FreeBSD__)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gmodule\/gmodule-dl.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-  gint k;\n+  size_t k;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gmodule\/gmodule-win32.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-g_clear_pointer (&scanner, g_scanner_destroy);\n+  g_clear_pointer (&scanner, g_scanner_destroy);\n@@ -496,1 +496,1 @@\n-#if !defined(__BIONIC__) || !defined(__LP64__)\n+#if !defined(__ANDROID__) || !defined(__LP64__)\n@@ -643,1 +643,1 @@\n-      _g_module_close (module->handle);\n+          _g_module_close (module->handle);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gmodule\/gmodule.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-#define CHANGE_FIELD(_closure, _field, _OP, _value, _must_set, _SET_OLD, _SET_NEW)      \\\n+#define ATOMIC_CHANGE_FIELD(_closure, _field, _OP, _value, _must_set, _SET_OLD, _SET_NEW)      \\\n@@ -126,15 +126,6 @@\n-#define SWAP(_closure, _field, _value, _oldv)   CHANGE_FIELD (_closure, _field, =, _value, TRUE, *(_oldv) =,     (void) )\n-#define SET(_closure, _field, _value)           CHANGE_FIELD (_closure, _field, =, _value, TRUE,     (void),     (void) )\n-#define INC(_closure, _field)                   CHANGE_FIELD (_closure, _field, +=,     1, TRUE,     (void),     (void) )\n-#define INC_ASSIGN(_closure, _field, _newv)     CHANGE_FIELD (_closure, _field, +=,     1, TRUE,     (void), *(_newv) = )\n-#define DEC(_closure, _field)                   CHANGE_FIELD (_closure, _field, -=,     1, TRUE,     (void),     (void) )\n-#define DEC_ASSIGN(_closure, _field, _newv)     CHANGE_FIELD (_closure, _field, -=,     1, TRUE,     (void), *(_newv) = )\n-\n-#if 0   \/* for non-thread-safe closures *\/\n-#define SWAP(cl,f,v,o)     (void) (*(o) = cl->f, cl->f = v)\n-#define SET(cl,f,v)        (void) (cl->f = v)\n-#define INC(cl,f)          (void) (cl->f += 1)\n-#define INC_ASSIGN(cl,f,n) (void) (cl->f += 1, *(n) = cl->f)\n-#define DEC(cl,f)          (void) (cl->f -= 1)\n-#define DEC_ASSIGN(cl,f,n) (void) (cl->f -= 1, *(n) = cl->f)\n-#endif\n+#define ATOMIC_SWAP(_closure, _field, _value, _oldv)   ATOMIC_CHANGE_FIELD (_closure, _field, =, _value, TRUE, *(_oldv) =,     (void) )\n+#define ATOMIC_SET(_closure, _field, _value)           ATOMIC_CHANGE_FIELD (_closure, _field, =, _value, TRUE,     (void),     (void) )\n+#define ATOMIC_INC(_closure, _field)                   ATOMIC_CHANGE_FIELD (_closure, _field, +=,     1, TRUE,     (void),     (void) )\n+#define ATOMIC_INC_ASSIGN(_closure, _field, _newv)     ATOMIC_CHANGE_FIELD (_closure, _field, +=,     1, TRUE,     (void), *(_newv) = )\n+#define ATOMIC_DEC(_closure, _field)                   ATOMIC_CHANGE_FIELD (_closure, _field, -=,     1, TRUE,     (void),     (void) )\n+#define ATOMIC_DEC_ASSIGN(_closure, _field, _newv)     ATOMIC_CHANGE_FIELD (_closure, _field, -=,     1, TRUE,     (void), *(_newv) = )\n@@ -236,2 +227,2 @@\n-  SET (closure, ref_count, 1);\n-  SET (closure, floating, TRUE);\n+  ATOMIC_SET (closure, ref_count, 1);\n+  ATOMIC_SET (closure, floating, TRUE);\n@@ -272,1 +263,1 @@\n-    DEC_ASSIGN (closure, n_fnotifiers, &n);\n+    ATOMIC_DEC_ASSIGN (closure, n_fnotifiers, &n);\n@@ -283,1 +274,1 @@\n-      SET (closure, in_inotify, TRUE);\n+      ATOMIC_SET (closure, in_inotify, TRUE);\n@@ -287,1 +278,1 @@\n-          DEC_ASSIGN (closure, n_inotifiers, &n);\n+          ATOMIC_DEC_ASSIGN (closure, n_inotifiers, &n);\n@@ -296,1 +287,1 @@\n-      SET (closure, in_inotify, FALSE);\n+      ATOMIC_SET (closure, in_inotify, FALSE);\n@@ -440,1 +431,1 @@\n-  INC (closure, n_guards);\n+  ATOMIC_INC (closure, n_guards);\n@@ -477,1 +468,1 @@\n-  INC (closure, n_fnotifiers);\n+  ATOMIC_INC (closure, n_fnotifiers);\n@@ -508,1 +499,1 @@\n-  INC (closure, n_inotifiers);\n+  ATOMIC_INC (closure, n_inotifiers);\n@@ -522,1 +513,1 @@\n-  DEC (closure, n_inotifiers);\n+  ATOMIC_DEC (closure, n_inotifiers);\n@@ -542,1 +533,1 @@\n-  DEC (closure, n_fnotifiers);\n+  ATOMIC_DEC (closure, n_fnotifiers);\n@@ -572,1 +563,1 @@\n-  INC_ASSIGN (closure, ref_count, &new_ref_count);\n+  ATOMIC_INC_ASSIGN (closure, ref_count, &new_ref_count);\n@@ -578,0 +569,11 @@\n+static void\n+closure_invalidate_internal (GClosure *closure)\n+{\n+  gboolean was_invalid;\n+\n+  ATOMIC_SWAP (closure, is_invalid, TRUE, &was_invalid);\n+  \/* invalidate only once *\/\n+  if (!was_invalid)\n+    closure_invoke_notifiers (closure, INOTIFY);\n+}\n+\n@@ -605,1 +607,0 @@\n-      gboolean was_invalid;\n@@ -607,4 +608,1 @@\n-      SWAP (closure, is_invalid, TRUE, &was_invalid);\n-      \/* invalidate only once *\/\n-      if (!was_invalid)\n-        closure_invoke_notifiers (closure, INOTIFY);\n+      closure_invalidate_internal (closure);\n@@ -633,2 +631,3 @@\n-  if (closure->ref_count == 1)  \/* last unref, invalidate first *\/\n-    g_closure_invalidate (closure);\n+  \/* last unref, invalidate first *\/\n+  if (closure->ref_count == 1 && !closure->is_invalid)\n+    closure_invalidate_internal (closure);\n@@ -636,1 +635,1 @@\n-  DEC_ASSIGN (closure, ref_count, &new_ref_count);\n+  ATOMIC_DEC_ASSIGN (closure, ref_count, &new_ref_count);\n@@ -730,1 +729,1 @@\n-      SWAP (closure, floating, FALSE, &was_floating);\n+      ATOMIC_SWAP (closure, floating, FALSE, &was_floating);\n@@ -829,1 +828,1 @@\n-      SET (closure, in_marshal, TRUE);\n+      ATOMIC_SET (closure, in_marshal, TRUE);\n@@ -849,1 +848,1 @@\n-      SET (closure, in_marshal, in_marshal);\n+      ATOMIC_SET (closure, in_marshal, in_marshal);\n@@ -892,1 +891,1 @@\n-      SET (closure, in_marshal, TRUE);\n+      ATOMIC_SET (closure, in_marshal, TRUE);\n@@ -912,1 +911,1 @@\n-      SET (closure, in_marshal, in_marshal);\n+      ATOMIC_SET (closure, in_marshal, in_marshal);\n@@ -1030,1 +1029,1 @@\n-  SET (closure, derivative_flag, TRUE);\n+  ATOMIC_SET (closure, derivative_flag, TRUE);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gclosure.c","additions":41,"deletions":42,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -1023,1 +1023,1 @@\n-   * [canonical parameter names][canonical-parameter-names] as\n+   * [canonical parameter names][class@GObject.ParamSpec#parameter-names] as\n@@ -2995,1 +2995,1 @@\n-    object_set_property (object, pspec, value, nqueue, TRUE);\n+    object_set_property (object, pspec, value, nqueue, FALSE);\n@@ -3469,3 +3469,3 @@\n- * @...: #GCallback for the first signal, followed by data for the\n- *       first signal, followed optionally by more signal\n- *       spec\/callback\/data triples, followed by %NULL\n+ * @...: [type@GObject.Callback] for the first signal, followed by data for the\n+ *   first signal, followed optionally by more signal\n+ *   spec\/callback\/data triples, followed by `NULL`\n@@ -3476,22 +3476,24 @@\n- * \"modifier::signal_name\", where modifier can be one of the following:\n- * - signal: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_DEFAULT)\n- * - object-signal, object_signal: equivalent to g_signal_connect_object (..., G_CONNECT_DEFAULT)\n- * - swapped-signal, swapped_signal: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED)\n- * - swapped_object_signal, swapped-object-signal: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED)\n- * - signal_after, signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_AFTER)\n- * - object_signal_after, object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_AFTER)\n- * - swapped_signal_after, swapped-signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED | G_CONNECT_AFTER)\n- * - swapped_object_signal_after, swapped-object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED | G_CONNECT_AFTER)\n- *\n- * |[<!-- language=\"C\" -->\n- *   menu->toplevel = g_object_connect (g_object_new (GTK_TYPE_WINDOW,\n- *                                                 \"type\", GTK_WINDOW_POPUP,\n- *                                                 \"child\", menu,\n- *                                                 NULL),\n- *                                   \"signal::event\", gtk_menu_window_event, menu,\n- *                                   \"signal::size_request\", gtk_menu_window_size_request, menu,\n- *                                   \"signal::destroy\", gtk_widget_destroyed, &menu->toplevel,\n- *                                   NULL);\n- * ]|\n- *\n- * Returns: (transfer none) (type GObject.Object): @object\n+ * `modifier::signal_name`, where `modifier` can be one of the\n+ * following:\n+ *\n+ * - `signal`: equivalent to `g_signal_connect_data (..., NULL, G_CONNECT_DEFAULT)`\n+ * - `object-signal`, `object_signal`: equivalent to `g_signal_connect_object (..., G_CONNECT_DEFAULT)`\n+ * - `swapped-signal`, `swapped_signal`: equivalent to `g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED)`\n+ * - `swapped_object_signal`, `swapped-object-signal`: equivalent to `g_signal_connect_object (..., G_CONNECT_SWAPPED)`\n+ * - `signal_after`, `signal-after`: equivalent to `g_signal_connect_data (..., NULL, G_CONNECT_AFTER)`\n+ * - `object_signal_after`, `object-signal-after`: equivalent to `g_signal_connect_object (..., G_CONNECT_AFTER)`\n+ * - `swapped_signal_after`, `swapped-signal-after`: equivalent to `g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED | G_CONNECT_AFTER)`\n+ * - `swapped_object_signal_after`, `swapped-object-signal-after`: equivalent to `g_signal_connect_object (..., G_CONNECT_SWAPPED | G_CONNECT_AFTER)`\n+ *\n+ * ```c\n+ * menu->toplevel = g_object_connect (g_object_new (GTK_TYPE_WINDOW,\n+ *                                                  \"type\", GTK_WINDOW_POPUP,\n+ *                                                  \"child\", menu,\n+ *                                                  NULL),\n+ *                                    \"signal::event\", gtk_menu_window_event, menu,\n+ *                                    \"signal::size_request\", gtk_menu_window_size_request, menu,\n+ *                                    \"signal::destroy\", gtk_widget_destroyed, &menu->toplevel,\n+ *                                    NULL);\n+ * ```\n+ *\n+ * Returns: (transfer none) (type GObject.Object): the object\n@@ -3898,1 +3900,1 @@\n- * alway receives exactly one full reference to the value: either the\n+ * always receives exactly one full reference to the value: either the\n@@ -4632,1 +4634,1 @@\n- * It's up to the caller to free this as needed, which may\n+ * Itโs up to the caller to free this as needed, which may\n@@ -4847,1 +4849,1 @@\n- * It's up to the caller to free this as needed, which may\n+ * Itโs up to the caller to free this as needed, which may\n@@ -5607,0 +5609,1 @@\n+      g_assert (new_wrdata != NULL);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gobject.c","additions":33,"deletions":30,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -392,2 +392,2 @@\n- * See [canonical parameter names][canonical-parameter-names] for details of\n- * the rules for valid names.\n+ * See [canonical parameter names][class@GObject.ParamSpec#parameter-names]\n+ * for details of the rules for valid names.\n@@ -432,3 +432,3 @@\n- * See [canonical parameter names][canonical-parameter-names] for details of\n- * the rules for @name. Names which violate these rules lead to undefined\n- * behaviour.\n+ * See [canonical parameter names][class@GObject.ParamSpec#parameter-names]\n+ * for details of the rules for @name. Names which violate these rules lead\n+ * to undefined behaviour.\n@@ -1344,2 +1344,2 @@\n- * also 'depth' isn't a meaningful concept for interface\n- * prerequites.\n+ * Also 'depth' isn't a meaningful concept for interface\n+ * prerequisites.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gparam.c","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -286,3 +286,2 @@\n- * See [canonical parameter names][canonical-parameter-names] for details of\n- * the rules for valid names. The rules for signal names are the same as those\n- * for property names.\n+ * See [func@GObject.signal_new] for details of the rules for valid names.\n+ * The rules for signal names are the same as those for property names.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gsignal.c","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-#define _G_DEFINE_TYPE_EXTENDED_WITH_PRELUDE(TN, t_n, T_P, _f_, _P_, _C_)       _G_DEFINE_TYPE_EXTENDED_BEGIN_PRE (TN, t_n, T_P) {_P_;} _G_DEFINE_TYPE_EXTENDED_BEGIN_REGISTER (TN, t_n, T_P, _f_){_C_;} _G_DEFINE_TYPE_EXTENDED_END()\n+#define _G_DEFINE_TYPE_EXTENDED_WITH_PRELUDE(TN, t_n, T_P, _f_, _P_, _C_)     _G_DEFINE_TYPE_EXTENDED_BEGIN_PRE (TN, t_n) {_P_;} _G_DEFINE_TYPE_EXTENDED_BEGIN_REGISTER (TN, t_n, T_P, _f_){_C_;} _G_DEFINE_TYPE_EXTENDED_END()\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gtype-private.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1076,1 +1076,1 @@\n-  guint vtable_size = 0;\n+  size_t vtable_size = 0;\n@@ -1204,0 +1204,1 @@\n+\n@@ -1205,0 +1206,1 @@\n+  g_assert (node->data->common.value_table != NULL); \/* paranoid *\/\n@@ -1209,2 +1211,0 @@\n-  g_assert (node->data->common.value_table != NULL); \/* paranoid *\/\n-\n@@ -1509,1 +1509,1 @@\n-      return;                   \/* we already have that prerequisiste *\/\n+      return;      \/* we already have that prerequisiste *\/\n@@ -1558,1 +1558,1 @@\n-  g_return_if_fail (G_TYPE_IS_INTERFACE (interface_type));      \/* G_TYPE_IS_INTERFACE() is an external call: _U *\/\n+  g_return_if_fail (G_TYPE_IS_INTERFACE (interface_type));  \/* G_TYPE_IS_INTERFACE() is an external call: _U *\/\n@@ -1780,1 +1780,1 @@\n-  return iholder;       \/* we don't modify write lock upon returning NULL *\/\n+  return iholder;  \/* we don't modify write lock upon returning NULL *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gtype.c","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1098,1 +1098,1 @@\n- *  inititalization function for interface types. (optional) This function\n+ *  initialization function for interface types. (optional) This function\n@@ -2281,1 +2281,1 @@\n-#define _G_DEFINE_TYPE_EXTENDED_BEGIN_PRE(TypeName, type_name, TYPE_PARENT) \\\n+#define _G_DEFINE_TYPE_EXTENDED_BEGIN_PRE(TypeName, type_name) \\\n@@ -2333,2 +2333,2 @@\n-\/* This was defined before we had G_DEFINE_TYPE_WITH_CODE_AND_PRELUDE, it's simplest\n- * to keep it.\n+\/* This was defined before we had _G_DEFINE_TYPE_EXTENDED_WITH_PRELUDE in\n+ * gtype-private.h, it's simplest to keep it.\n@@ -2337,2 +2337,2 @@\n-  _G_DEFINE_TYPE_EXTENDED_BEGIN_PRE(TypeName, type_name, TYPE_PARENT) \\\n-  _G_DEFINE_TYPE_EXTENDED_BEGIN_REGISTER(TypeName, type_name, TYPE_PARENT, flags) \\\n+  _G_DEFINE_TYPE_EXTENDED_BEGIN_PRE (TypeName, type_name)                      \\\n+  _G_DEFINE_TYPE_EXTENDED_BEGIN_REGISTER (TypeName, type_name, TYPE_PARENT, flags)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gtype.h","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n- * Return a pointer to the value at @index_ containd in @value_array.\n+ * Return a pointer to the value at @index_ contained in @value_array.\n@@ -377,1 +377,1 @@\n-    g_qsort_with_data (value_array->values,\n+    g_sort_array (value_array->values,\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/3rd_party\/glib\/gobject\/gvaluearray.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2026,0 +2026,14 @@\n+  gboolean timeout_valid;\n+  gint64 end_time, now;\n+\n+  \/*\n+   * 0 is valid but has a special meaning for gst_app_sink_try_pull_object which fetches\n+   * a sample\/event that is available without waiting. For 0, we don't want to deduct\n+   * from the timeout to allow skipping all events and reading a sample directly.\n+   *\/\n+  timeout_valid = timeout != 0 && GST_CLOCK_TIME_IS_VALID (timeout);\n+\n+  if (timeout_valid)\n+    end_time =\n+        g_get_monotonic_time () + timeout \/ (GST_SECOND \/ G_TIME_SPAN_SECOND);\n+\n@@ -2037,0 +2051,8 @@\n+      if (timeout_valid) {\n+        now = g_get_monotonic_time ();\n+        if (now >= end_time) {\n+          \/* timeout expired *\/\n+          return NULL;\n+        }\n+        timeout = (end_time - now) * (GST_SECOND \/ G_TIME_SPAN_SECOND);\n+      }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/app\/gstappsink.c","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -503,2 +503,2 @@\n-      w_sub = GST_VIDEO_FORMAT_INFO_W_SUB (finfo, 1);\n-      h_sub = GST_VIDEO_FORMAT_INFO_H_SUB (finfo, 1);\n+      w_sub = 1 << GST_VIDEO_FORMAT_INFO_W_SUB (finfo, 1);\n+      h_sub = 1 << GST_VIDEO_FORMAT_INFO_H_SUB (finfo, 1);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/descriptions.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1267,1 +1267,1 @@\n-        scope->priv->earliest_time = timestamp + 2 * diff +\n+        scope->priv->earliest_time = timestamp + MIN (2 * diff, GST_SECOND) +\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/gstaudiovisualizer.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1197 +0,0 @@\n-\/* GStreamer\n- * Copyright (C) 2010 Collabora Multimedia\n- *               2010 Nokia Corporation\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Library General Public\n- * License as published by the Free Software Foundation; either\n- * version 2 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Library General Public License for more details.\n- *\n- * You should have received a copy of the GNU Library General Public\n- * License along with this library; if not, write to the\n- * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n- * Boston, MA 02110-1301, USA.\n- *\/\n-\n-#ifdef HAVE_CONFIG_H\n-#include \"config.h\"\n-#endif\n-\n-#include \"pbutils.h\"\n-#include \"pbutils-private.h\"\n-\n-static GstDiscovererStreamInfo\n-    * gst_discoverer_info_copy_int (GstDiscovererStreamInfo * info,\n-    GHashTable * stream_map);\n-\n-static GstDiscovererContainerInfo\n-    * gst_stream_container_info_copy_int (GstDiscovererContainerInfo * ptr,\n-    GHashTable * stream_map);\n-\n-static GstDiscovererAudioInfo\n-    * gst_discoverer_audio_info_copy_int (GstDiscovererAudioInfo * ptr);\n-\n-static GstDiscovererVideoInfo\n-    * gst_discoverer_video_info_copy_int (GstDiscovererVideoInfo * ptr);\n-\n-static GstDiscovererSubtitleInfo\n-    * gst_discoverer_subtitle_info_copy_int (GstDiscovererSubtitleInfo * ptr);\n-\n-\/* Per-stream information *\/\n-\n-G_DEFINE_TYPE (GstDiscovererStreamInfo, gst_discoverer_stream_info,\n-    G_TYPE_OBJECT);\n-\n-static void\n-gst_discoverer_stream_info_init (GstDiscovererStreamInfo * info)\n-{\n-  info->stream_number = -1;\n-}\n-\n-static void\n-gst_discoverer_stream_info_finalize (GObject * object)\n-{\n-  GstDiscovererStreamInfo *info = (GstDiscovererStreamInfo *) object;\n-\n-  if (info->next)\n-    g_object_unref ((GObject *) info->next);\n-\n-  if (info->caps)\n-    gst_caps_unref (info->caps);\n-\n-  if (info->tags)\n-    gst_tag_list_unref (info->tags);\n-\n-  if (info->toc)\n-    gst_toc_unref (info->toc);\n-\n-  g_free (info->stream_id);\n-\n-  if (info->misc)\n-    gst_structure_free (info->misc);\n-\n-  G_OBJECT_CLASS (gst_discoverer_stream_info_parent_class)->finalize (object);\n-}\n-\n-static void\n-gst_discoverer_stream_info_class_init (GObjectClass * klass)\n-{\n-  klass->finalize = gst_discoverer_stream_info_finalize;\n-}\n-\n-static GstDiscovererStreamInfo *\n-gst_discoverer_stream_info_new (void)\n-{\n-  return (GstDiscovererStreamInfo *)\n-      g_object_new (GST_TYPE_DISCOVERER_STREAM_INFO, NULL);\n-}\n-\n-static GstDiscovererStreamInfo *\n-gst_discoverer_info_copy_int (GstDiscovererStreamInfo * info,\n-    GHashTable * stream_map)\n-{\n-  GstDiscovererStreamInfo *ret;\n-  GType ltyp;\n-\n-  g_return_val_if_fail (info != NULL, NULL);\n-\n-  ltyp = G_TYPE_FROM_INSTANCE (info);\n-\n-  if (ltyp == GST_TYPE_DISCOVERER_CONTAINER_INFO) {\n-    ret = (GstDiscovererStreamInfo *)\n-        gst_stream_container_info_copy_int (\n-        (GstDiscovererContainerInfo *) info, stream_map);\n-  } else if (ltyp == GST_TYPE_DISCOVERER_AUDIO_INFO) {\n-    ret = (GstDiscovererStreamInfo *)\n-        gst_discoverer_audio_info_copy_int ((GstDiscovererAudioInfo *) info);\n-\n-  } else if (ltyp == GST_TYPE_DISCOVERER_VIDEO_INFO) {\n-    ret = (GstDiscovererStreamInfo *)\n-        gst_discoverer_video_info_copy_int ((GstDiscovererVideoInfo *) info);\n-\n-  } else if (ltyp == GST_TYPE_DISCOVERER_SUBTITLE_INFO) {\n-    ret = (GstDiscovererStreamInfo *)\n-        gst_discoverer_subtitle_info_copy_int ((GstDiscovererSubtitleInfo *)\n-        info);\n-\n-  } else\n-    ret = gst_discoverer_stream_info_new ();\n-\n-  if (info->next) {\n-    ret->next = gst_discoverer_info_copy_int (info->next, stream_map);\n-    ret->next->previous = ret;\n-  }\n-\n-  if (info->caps)\n-    ret->caps = gst_caps_copy (info->caps);\n-\n-  if (info->tags)\n-    ret->tags = gst_tag_list_copy (info->tags);\n-\n-  if (info->toc)\n-    ret->toc = gst_toc_ref (info->toc);\n-\n-  if (info->stream_id)\n-    ret->stream_id = g_strdup (info->stream_id);\n-\n-  if (info->misc)\n-    ret->misc = gst_structure_copy (info->misc);\n-\n-  if (stream_map)\n-    g_hash_table_insert (stream_map, info, ret);\n-\n-  ret->stream_number = info->stream_number;\n-\n-  return ret;\n-}\n-\n-\/* Container information *\/\n-G_DEFINE_TYPE (GstDiscovererContainerInfo, gst_discoverer_container_info,\n-    GST_TYPE_DISCOVERER_STREAM_INFO);\n-\n-static void\n-gst_discoverer_container_info_init (GstDiscovererContainerInfo * info)\n-{\n-  \/* Nothing to initialize *\/\n-}\n-\n-static GstDiscovererContainerInfo *\n-gst_discoverer_container_info_new (void)\n-{\n-  return (GstDiscovererContainerInfo *)\n-      g_object_new (GST_TYPE_DISCOVERER_CONTAINER_INFO, NULL);\n-}\n-\n-static void\n-gst_discoverer_container_info_finalize (GObject * object)\n-{\n-  GstDiscovererContainerInfo *info = (GstDiscovererContainerInfo *) object;\n-  GList *tmp;\n-\n-  for (tmp = ((GstDiscovererContainerInfo *) info)->streams; tmp;\n-      tmp = tmp->next)\n-    g_object_unref ((GObject *) tmp->data);\n-\n-  gst_discoverer_stream_info_list_free (info->streams);\n-\n-  if (info->tags)\n-    gst_tag_list_unref (info->tags);\n-\n-  G_OBJECT_CLASS (gst_discoverer_container_info_parent_class)->finalize\n-      (object);\n-}\n-\n-static void\n-gst_discoverer_container_info_class_init (GObjectClass * klass)\n-{\n-  klass->finalize = gst_discoverer_container_info_finalize;\n-}\n-\n-static GstDiscovererContainerInfo *\n-gst_stream_container_info_copy_int (GstDiscovererContainerInfo * ptr,\n-    GHashTable * stream_map)\n-{\n-  GstDiscovererContainerInfo *ret;\n-  GList *tmp;\n-\n-  g_return_val_if_fail (ptr != NULL, NULL);\n-\n-  ret = gst_discoverer_container_info_new ();\n-\n-  for (tmp = ((GstDiscovererContainerInfo *) ptr)->streams; tmp;\n-      tmp = tmp->next) {\n-    GstDiscovererStreamInfo *subtop = gst_discoverer_info_copy_int (tmp->data,\n-        stream_map);\n-    ret->streams = g_list_append (ret->streams, subtop);\n-    if (stream_map)\n-      g_hash_table_insert (stream_map, tmp->data, subtop);\n-  }\n-\n-  if (ptr->tags)\n-    ret->tags = gst_tag_list_copy (ptr->tags);\n-\n-  return ret;\n-}\n-\n-\/* Audio information *\/\n-G_DEFINE_TYPE (GstDiscovererAudioInfo, gst_discoverer_audio_info,\n-    GST_TYPE_DISCOVERER_STREAM_INFO);\n-\n-static void\n-gst_discoverer_audio_info_finalize (GObject * object)\n-{\n-  GstDiscovererAudioInfo *info = (GstDiscovererAudioInfo *) object;\n-\n-  g_free (info->language);\n-\n-  G_OBJECT_CLASS (gst_discoverer_audio_info_parent_class)->finalize (object);\n-}\n-\n-static void\n-gst_discoverer_audio_info_class_init (GObjectClass * klass)\n-{\n-  klass->finalize = gst_discoverer_audio_info_finalize;\n-}\n-\n-static void\n-gst_discoverer_audio_info_init (GstDiscovererAudioInfo * info)\n-{\n-  info->language = NULL;\n-}\n-\n-static GstDiscovererAudioInfo *\n-gst_discoverer_audio_info_new (void)\n-{\n-  return (GstDiscovererAudioInfo *)\n-      g_object_new (GST_TYPE_DISCOVERER_AUDIO_INFO, NULL);\n-}\n-\n-static GstDiscovererAudioInfo *\n-gst_discoverer_audio_info_copy_int (GstDiscovererAudioInfo * ptr)\n-{\n-  GstDiscovererAudioInfo *ret;\n-\n-  ret = gst_discoverer_audio_info_new ();\n-\n-  ret->channels = ptr->channels;\n-  ret->channel_mask = ptr->channel_mask;\n-  ret->sample_rate = ptr->sample_rate;\n-  ret->depth = ptr->depth;\n-  ret->bitrate = ptr->bitrate;\n-  ret->max_bitrate = ptr->max_bitrate;\n-  ret->language = g_strdup (ptr->language);\n-\n-  return ret;\n-}\n-\n-\/* Subtitle information *\/\n-G_DEFINE_TYPE (GstDiscovererSubtitleInfo, gst_discoverer_subtitle_info,\n-    GST_TYPE_DISCOVERER_STREAM_INFO);\n-\n-static void\n-gst_discoverer_subtitle_info_init (GstDiscovererSubtitleInfo * info)\n-{\n-  info->language = NULL;\n-}\n-\n-static void\n-gst_discoverer_subtitle_info_finalize (GObject * object)\n-{\n-  GstDiscovererSubtitleInfo *info = (GstDiscovererSubtitleInfo *) object;\n-\n-  g_free (info->language);\n-\n-  G_OBJECT_CLASS (gst_discoverer_subtitle_info_parent_class)->finalize (object);\n-}\n-\n-static void\n-gst_discoverer_subtitle_info_class_init (GObjectClass * klass)\n-{\n-  klass->finalize = gst_discoverer_subtitle_info_finalize;\n-}\n-\n-static GstDiscovererSubtitleInfo *\n-gst_discoverer_subtitle_info_new (void)\n-{\n-  return (GstDiscovererSubtitleInfo *)\n-      g_object_new (GST_TYPE_DISCOVERER_SUBTITLE_INFO, NULL);\n-}\n-\n-static GstDiscovererSubtitleInfo *\n-gst_discoverer_subtitle_info_copy_int (GstDiscovererSubtitleInfo * ptr)\n-{\n-  GstDiscovererSubtitleInfo *ret;\n-\n-  ret = gst_discoverer_subtitle_info_new ();\n-\n-  ret->language = g_strdup (ptr->language);\n-\n-  return ret;\n-}\n-\n-\/* Video information *\/\n-G_DEFINE_TYPE (GstDiscovererVideoInfo, gst_discoverer_video_info,\n-    GST_TYPE_DISCOVERER_STREAM_INFO);\n-\n-static void\n-gst_discoverer_video_info_class_init (GObjectClass * klass)\n-{\n-  \/* Nothing to initialize *\/\n-}\n-\n-static void\n-gst_discoverer_video_info_init (GstDiscovererVideoInfo * info)\n-{\n-  \/* Nothing to initialize *\/\n-}\n-\n-static GstDiscovererVideoInfo *\n-gst_discoverer_video_info_new (void)\n-{\n-  return (GstDiscovererVideoInfo *)\n-      g_object_new (GST_TYPE_DISCOVERER_VIDEO_INFO, NULL);\n-}\n-\n-static GstDiscovererVideoInfo *\n-gst_discoverer_video_info_copy_int (GstDiscovererVideoInfo * ptr)\n-{\n-  GstDiscovererVideoInfo *ret;\n-\n-  ret = gst_discoverer_video_info_new ();\n-\n-  ret->width = ptr->width;\n-  ret->height = ptr->height;\n-  ret->depth = ptr->depth;\n-  ret->framerate_num = ptr->framerate_num;\n-  ret->framerate_denom = ptr->framerate_denom;\n-  ret->par_num = ptr->par_num;\n-  ret->par_denom = ptr->par_denom;\n-  ret->interlaced = ptr->interlaced;\n-  ret->bitrate = ptr->bitrate;\n-  ret->max_bitrate = ptr->max_bitrate;\n-  ret->is_image = ptr->is_image;\n-\n-  return ret;\n-}\n-\n-\/* Global stream information *\/\n-G_DEFINE_TYPE (GstDiscovererInfo, gst_discoverer_info, G_TYPE_OBJECT);\n-\n-static void\n-gst_discoverer_info_init (GstDiscovererInfo * info)\n-{\n-  info->missing_elements_details = g_ptr_array_new_with_free_func (g_free);\n-}\n-\n-static void\n-gst_discoverer_info_finalize (GObject * object)\n-{\n-  GstDiscovererInfo *info = (GstDiscovererInfo *) object;\n-  g_free (info->uri);\n-\n-  if (info->stream_info)\n-    g_object_unref ((GObject *) info->stream_info);\n-\n-  if (info->misc)\n-    gst_structure_free (info->misc);\n-\n-  g_list_free (info->stream_list);\n-\n-  if (info->tags)\n-    gst_tag_list_unref (info->tags);\n-\n-  if (info->toc)\n-    gst_toc_unref (info->toc);\n-\n-  g_free (info->cachefile);\n-\n-  g_ptr_array_unref (info->missing_elements_details);\n-\n-  G_OBJECT_CLASS (gst_discoverer_info_parent_class)->finalize (object);\n-}\n-\n-static GstDiscovererInfo *\n-gst_discoverer_info_new (void)\n-{\n-  return (GstDiscovererInfo *) g_object_new (GST_TYPE_DISCOVERER_INFO, NULL);\n-}\n-\n-\/**\n- * gst_discoverer_info_copy:\n- * @ptr: (transfer none): a #GstDiscovererInfo\n- *\n- * Returns: (transfer full): A copy of the #GstDiscovererInfo\n- *\/\n-GstDiscovererInfo *\n-gst_discoverer_info_copy (GstDiscovererInfo * ptr)\n-{\n-  GstDiscovererInfo *ret;\n-  GHashTable *stream_map;\n-  GList *tmp;\n-\n-  g_return_val_if_fail (ptr != NULL, NULL);\n-\n-  stream_map = g_hash_table_new (g_direct_hash, NULL);\n-\n-  ret = gst_discoverer_info_new ();\n-\n-  ret->uri = g_strdup (ptr->uri);\n-  if (ptr->stream_info) {\n-    ret->stream_info = gst_discoverer_info_copy_int (ptr->stream_info,\n-        stream_map);\n-  }\n-  ret->duration = ptr->duration;\n-  ret->result = ptr->result;\n-  ret->seekable = ptr->seekable;\n-  ret->live = ptr->live;\n-  if (ptr->misc)\n-    ret->misc = gst_structure_copy (ptr->misc);\n-\n-  \/* We need to set up the new list of streams to correspond to old one. The\n-   * list just contains a set of pointers to streams in the stream_info tree,\n-   * so we keep a map of old stream info objects to the corresponding new\n-   * ones and use that to figure out correspondence in stream_list. *\/\n-  for (tmp = ptr->stream_list; tmp; tmp = tmp->next) {\n-    GstDiscovererStreamInfo *old_stream = (GstDiscovererStreamInfo *) tmp->data;\n-    GstDiscovererStreamInfo *new_stream = g_hash_table_lookup (stream_map,\n-        old_stream);\n-    g_assert (new_stream != NULL);\n-    ret->stream_list = g_list_append (ret->stream_list, new_stream);\n-  }\n-\n-  if (ptr->tags)\n-    ret->tags = gst_tag_list_copy (ptr->tags);\n-\n-  if (ptr->toc)\n-    ret->toc = gst_toc_ref (ptr->toc);\n-\n-  g_hash_table_destroy (stream_map);\n-  return ret;\n-}\n-\n-static void\n-gst_discoverer_info_class_init (GObjectClass * klass)\n-{\n-  klass->finalize = gst_discoverer_info_finalize;\n-}\n-\n-\/**\n- * gst_discoverer_stream_info_list_free:\n- * @infos: (element-type GstPbutils.DiscovererStreamInfo): a #GList of #GstDiscovererStreamInfo\n- *\n- * Decrements the reference count of all contained #GstDiscovererStreamInfo\n- * and fress the #GList.\n- *\/\n-void\n-gst_discoverer_stream_info_list_free (GList * infos)\n-{\n-  GList *tmp;\n-\n-  for (tmp = infos; tmp; tmp = tmp->next)\n-    gst_discoverer_stream_info_unref ((GstDiscovererStreamInfo *) tmp->data);\n-  g_list_free (infos);\n-}\n-\n-\/**\n- * gst_discoverer_info_get_streams:\n- * @info: a #GstDiscovererInfo\n- * @streamtype: a #GType derived from #GstDiscovererStreamInfo\n- *\n- * Finds the #GstDiscovererStreamInfo contained in @info that match the\n- * given @streamtype.\n- *\n- * Returns: (transfer full) (element-type GstPbutils.DiscovererStreamInfo): A #GList of\n- * matching #GstDiscovererStreamInfo. The caller should free it with\n- * gst_discoverer_stream_info_list_free().\n- *\/\n-GList *\n-gst_discoverer_info_get_streams (GstDiscovererInfo * info, GType streamtype)\n-{\n-  GList *tmp, *res = NULL;\n-\n-  for (tmp = info->stream_list; tmp; tmp = tmp->next) {\n-    GstDiscovererStreamInfo *stmp = (GstDiscovererStreamInfo *) tmp->data;\n-\n-    if (G_TYPE_CHECK_INSTANCE_TYPE (stmp, streamtype))\n-      res = g_list_append (res, gst_discoverer_stream_info_ref (stmp));\n-  }\n-\n-  return res;\n-}\n-\n-\/**\n- * gst_discoverer_info_get_audio_streams:\n- * @info: a #GstDiscovererInfo\n- *\n- * Finds all the #GstDiscovererAudioInfo contained in @info\n- *\n- * Returns: (transfer full) (element-type GstPbutils.DiscovererAudioInfo): A #GList of\n- * matching #GstDiscovererStreamInfo. The caller should free it with\n- * gst_discoverer_stream_info_list_free().\n- *\/\n-GList *\n-gst_discoverer_info_get_audio_streams (GstDiscovererInfo * info)\n-{\n-  return gst_discoverer_info_get_streams (info, GST_TYPE_DISCOVERER_AUDIO_INFO);\n-}\n-\n-\/**\n- * gst_discoverer_info_get_video_streams:\n- * @info: a #GstDiscovererInfo\n- *\n- * Finds all the #GstDiscovererVideoInfo contained in @info\n- *\n- * Returns: (transfer full) (element-type GstPbutils.DiscovererVideoInfo): A #GList of\n- * matching #GstDiscovererStreamInfo. The caller should free it with\n- * gst_discoverer_stream_info_list_free().\n- *\/\n-GList *\n-gst_discoverer_info_get_video_streams (GstDiscovererInfo * info)\n-{\n-  return gst_discoverer_info_get_streams (info, GST_TYPE_DISCOVERER_VIDEO_INFO);\n-}\n-\n-\/**\n- * gst_discoverer_info_get_subtitle_streams:\n- * @info: a #GstDiscovererInfo\n- *\n- * Finds all the #GstDiscovererSubtitleInfo contained in @info\n- *\n- * Returns: (transfer full) (element-type GstPbutils.DiscovererSubtitleInfo): A #GList of\n- * matching #GstDiscovererStreamInfo. The caller should free it with\n- * gst_discoverer_stream_info_list_free().\n- *\/\n-GList *\n-gst_discoverer_info_get_subtitle_streams (GstDiscovererInfo * info)\n-{\n-  return gst_discoverer_info_get_streams (info,\n-      GST_TYPE_DISCOVERER_SUBTITLE_INFO);\n-}\n-\n-\/**\n- * gst_discoverer_info_get_container_streams:\n- * @info: a #GstDiscovererInfo\n- *\n- * Finds all the #GstDiscovererContainerInfo contained in @info\n- *\n- * Returns: (transfer full) (element-type GstPbutils.DiscovererContainerInfo): A #GList of\n- * matching #GstDiscovererStreamInfo. The caller should free it with\n- * gst_discoverer_stream_info_list_free().\n- *\/\n-GList *\n-gst_discoverer_info_get_container_streams (GstDiscovererInfo * info)\n-{\n-  return gst_discoverer_info_get_streams (info,\n-      GST_TYPE_DISCOVERER_CONTAINER_INFO);\n-}\n-\n-\/**\n- * gst_discoverer_stream_info_get_stream_type_nick:\n- * @info: a #GstDiscovererStreamInfo\n- *\n- * Returns: a human readable name for the stream type of the given @info (ex : \"audio\",\n- * \"container\",...).\n- *\/\n-const gchar *\n-gst_discoverer_stream_info_get_stream_type_nick (GstDiscovererStreamInfo * info)\n-{\n-  if (GST_IS_DISCOVERER_CONTAINER_INFO (info))\n-    return \"container\";\n-  if (GST_IS_DISCOVERER_AUDIO_INFO (info))\n-    return \"audio\";\n-  if (GST_IS_DISCOVERER_VIDEO_INFO (info)) {\n-    if (gst_discoverer_video_info_is_image ((GstDiscovererVideoInfo *)\n-            info))\n-      return \"video(image)\";\n-    else\n-      return \"video\";\n-  }\n-  if (GST_IS_DISCOVERER_SUBTITLE_INFO (info))\n-    return \"subtitles\";\n-  return \"unknown\";\n-}\n-\n-\/* ACCESSORS *\/\n-\n-\n-#define GENERIC_ACCESSOR_CODE(parent, parenttype, parentgtype, fieldname, type, failval) \\\n-  type parent##_get_##fieldname(const parenttype info) {      \\\n-    g_return_val_if_fail(G_TYPE_CHECK_INSTANCE_TYPE((info), parentgtype), failval); \\\n-    return (info)->fieldname;       \\\n-  }\n-\n-\/**\n- * gst_discoverer_stream_info_get_previous:\n- * @info: a #GstDiscovererStreamInfo\n- *\n- * Returns: (transfer full) (nullable): the previous #GstDiscovererStreamInfo in a chain.\n- * %NULL for starting points. Unref with #gst_discoverer_stream_info_unref\n- * after usage.\n- *\/\n-GstDiscovererStreamInfo *\n-gst_discoverer_stream_info_get_previous (GstDiscovererStreamInfo * info)\n-{\n-  g_return_val_if_fail (GST_IS_DISCOVERER_STREAM_INFO (info), NULL);\n-\n-  if (info->previous)\n-    return gst_discoverer_stream_info_ref (info->previous);\n-  return NULL;\n-}\n-\n-\/**\n- * gst_discoverer_stream_info_get_next:\n- * @info: a #GstDiscovererStreamInfo\n- *\n- * Returns: (transfer full) (nullable): the next #GstDiscovererStreamInfo in a chain. %NULL\n- * for final streams.\n- * Unref with #gst_discoverer_stream_info_unref after usage.\n- *\/\n-GstDiscovererStreamInfo *\n-gst_discoverer_stream_info_get_next (GstDiscovererStreamInfo * info)\n-{\n-  g_return_val_if_fail (GST_IS_DISCOVERER_STREAM_INFO (info), NULL);\n-\n-  if (info->next)\n-    return gst_discoverer_stream_info_ref (info->next);\n-  return NULL;\n-}\n-\n-\n-\/**\n- * gst_discoverer_stream_info_get_caps:\n- * @info: a #GstDiscovererStreamInfo\n- *\n- * Returns: (transfer full) (nullable): the #GstCaps of the stream. Unref with\n- * #gst_caps_unref after usage.\n- *\/\n-GstCaps *\n-gst_discoverer_stream_info_get_caps (GstDiscovererStreamInfo * info)\n-{\n-  g_return_val_if_fail (GST_IS_DISCOVERER_STREAM_INFO (info), NULL);\n-\n-  if (info->caps)\n-    return gst_caps_ref (info->caps);\n-  return NULL;\n-}\n-\n-\/**\n- * gst_discoverer_stream_info_get_tags:\n- * @info: a #GstDiscovererStreamInfo\n- *\n- * Returns: (transfer none) (nullable): the tags contained in this stream. If you wish to\n- * use the tags after the life-time of @info you will need to copy them.\n- *\/\n-const GstTagList *\n-gst_discoverer_stream_info_get_tags (GstDiscovererStreamInfo * info)\n-{\n-  g_return_val_if_fail (GST_IS_DISCOVERER_STREAM_INFO (info), NULL);\n-\n-  return info->tags;\n-}\n-\n-\/**\n- * gst_discoverer_stream_info_get_toc:\n- * @info: a #GstDiscovererStreamInfo\n- *\n- * Returns: (transfer none) (nullable): the TOC contained in this stream. If you wish to\n- * use the TOC after the life-time of @info you will need to copy it.\n- *\/\n-const GstToc *\n-gst_discoverer_stream_info_get_toc (GstDiscovererStreamInfo * info)\n-{\n-  g_return_val_if_fail (GST_IS_DISCOVERER_STREAM_INFO (info), NULL);\n-\n-  return info->toc;\n-}\n-\n-\/**\n- * gst_discoverer_stream_info_get_stream_id:\n- * @info: a #GstDiscovererStreamInfo\n- *\n- * Returns: (transfer none) (nullable): the stream ID of this stream. If you wish to\n- * use the stream ID after the life-time of @info you will need to copy it.\n- *\/\n-const gchar *\n-gst_discoverer_stream_info_get_stream_id (GstDiscovererStreamInfo * info)\n-{\n-  g_return_val_if_fail (GST_IS_DISCOVERER_STREAM_INFO (info), NULL);\n-\n-  return info->stream_id;\n-}\n-\n-#ifndef GST_REMOVE_DEPRECATED\n-\/**\n- * gst_discoverer_stream_info_get_misc:\n- * @info: a #GstDiscovererStreamInfo\n- *\n- * Deprecated: This functions is deprecated since version 1.4, use\n- * #gst_discoverer_info_get_missing_elements_installer_details\n- *\n- * Returns: (transfer none) (nullable): additional information regarding the stream (for\n- * example codec version, profile, etc..). If you wish to use the #GstStructure\n- * after the life-time of @info you will need to copy it.\n- *\/\n-const GstStructure *\n-gst_discoverer_stream_info_get_misc (GstDiscovererStreamInfo * info)\n-{\n-  g_return_val_if_fail (GST_IS_DISCOVERER_STREAM_INFO (info), NULL);\n-\n-  return info->misc;\n-}\n-#endif\n-\n-\/**\n- * gst_discoverer_stream_info_get_stream_number:\n- * @info: a #GstDiscovererStreamInfo\n- *\n- * Returns: the stream number, -1 if no index could be determined. This property\n- * acts as a unique identifier as a 'int' for the stream.\n- *\n- * Since: 1.20\n- *\/\n-gint\n-gst_discoverer_stream_info_get_stream_number (GstDiscovererStreamInfo * info)\n-{\n-  g_return_val_if_fail (GST_IS_DISCOVERER_STREAM_INFO (info), -1);\n-\n-  return info->stream_number;\n-}\n-\n-\/* GstDiscovererContainerInfo *\/\n-\n-\/**\n- * gst_discoverer_container_info_get_streams:\n- * @info: a #GstDiscovererStreamInfo\n- *\n- * Returns: (transfer full) (element-type GstPbutils.DiscovererStreamInfo): the list of\n- * #GstDiscovererStreamInfo this container stream offers.\n- * Free with gst_discoverer_stream_info_list_free() after usage.\n- *\/\n-\n-GList *\n-gst_discoverer_container_info_get_streams (GstDiscovererContainerInfo * info)\n-{\n-  GList *res = NULL, *tmp;\n-\n-  g_return_val_if_fail (GST_IS_DISCOVERER_CONTAINER_INFO (info), NULL);\n-\n-  for (tmp = info->streams; tmp; tmp = tmp->next)\n-    res =\n-        g_list_append (res,\n-        gst_discoverer_stream_info_ref ((GstDiscovererStreamInfo *) tmp->data));\n-\n-  return res;\n-}\n-\n-\/**\n- * gst_discoverer_container_info_get_tags:\n- * @info: a #GstDiscovererStreamInfo\n- *\n- * Returns: (transfer none) (nullable): tags specific to the given container. If you wish to use\n- * the tags after the life-time of @info, you will need to copy them.\n- *\n- * Since: 1.20\n- *\/\n-const GstTagList *\n-gst_discoverer_container_info_get_tags (const GstDiscovererContainerInfo * info)\n-{\n-  g_return_val_if_fail (GST_IS_DISCOVERER_CONTAINER_INFO (info), NULL);\n-\n-  return info->tags;\n-}\n-\n-\/* GstDiscovererAudioInfo *\/\n-\n-#define AUDIO_INFO_ACCESSOR_CODE(fieldname, type, failval)    \\\n-  GENERIC_ACCESSOR_CODE(gst_discoverer_audio_info, GstDiscovererAudioInfo*, \\\n-      GST_TYPE_DISCOVERER_AUDIO_INFO,   \\\n-      fieldname, type, failval)\n-\n-\/**\n- * gst_discoverer_audio_info_get_channels:\n- * @info: a #GstDiscovererAudioInfo\n- *\n- * Returns: the number of channels in the stream.\n- *\/\n-\n-AUDIO_INFO_ACCESSOR_CODE (channels, guint, 0);\n-\n-\/**\n- * gst_discoverer_audio_info_get_channel_mask:\n- * @info: a #GstDiscovererAudioInfo\n- *\n- * Returns: the channel-mask of the stream, refer to\n- * gst_audio_channel_positions_from_mask() for more\n- * information.\n- *\n- * Since: 1.14\n- *\/\n-\n-AUDIO_INFO_ACCESSOR_CODE (channel_mask, guint64, G_MAXUINT64);\n-\n-\/**\n- * gst_discoverer_audio_info_get_sample_rate:\n- * @info: a #GstDiscovererAudioInfo\n- *\n- * Returns: the sample rate of the stream in Hertz.\n- *\/\n-\n-AUDIO_INFO_ACCESSOR_CODE (sample_rate, guint, 0);\n-\n-\/**\n- * gst_discoverer_audio_info_get_depth:\n- * @info: a #GstDiscovererAudioInfo\n- *\n- * Returns: the number of bits used per sample in each channel.\n- *\/\n-\n-AUDIO_INFO_ACCESSOR_CODE (depth, guint, 0);\n-\n-\/**\n- * gst_discoverer_audio_info_get_bitrate:\n- * @info: a #GstDiscovererAudioInfo\n- *\n- * Returns: the average or nominal bitrate of the stream in bits\/second.\n- *\/\n-\n-AUDIO_INFO_ACCESSOR_CODE (bitrate, guint, 0);\n-\n-\/**\n- * gst_discoverer_audio_info_get_max_bitrate:\n- * @info: a #GstDiscovererAudioInfo\n- *\n- * Returns: the maximum bitrate of the stream in bits\/second.\n- *\/\n-\n-AUDIO_INFO_ACCESSOR_CODE (max_bitrate, guint, 0);\n-\n-\/**\n- * gst_discoverer_audio_info_get_language:\n- * @info: a #GstDiscovererAudioInfo\n- *\n- * Returns: (nullable): the language of the stream, or NULL if unknown.\n- *\/\n-\n-AUDIO_INFO_ACCESSOR_CODE (language, const gchar *, NULL);\n-\n-\/* GstDiscovererVideoInfo *\/\n-\n-#define VIDEO_INFO_ACCESSOR_CODE(fieldname, type, failval)    \\\n-  GENERIC_ACCESSOR_CODE(gst_discoverer_video_info, GstDiscovererVideoInfo*, \\\n-      GST_TYPE_DISCOVERER_VIDEO_INFO,     \\\n-      fieldname, type, failval)\n-\n-\/**\n- * gst_discoverer_video_info_get_width:\n- * @info: a #GstDiscovererVideoInfo\n- *\n- * Returns: the width of the video stream in pixels.\n- *\/\n-\n-VIDEO_INFO_ACCESSOR_CODE (width, guint, 0);\n-\n-\/**\n- * gst_discoverer_video_info_get_height:\n- * @info: a #GstDiscovererVideoInfo\n- *\n- * Returns: the height of the video stream in pixels.\n- *\/\n-\n-VIDEO_INFO_ACCESSOR_CODE (height, guint, 0);\n-\n-\/**\n- * gst_discoverer_video_info_get_depth:\n- * @info: a #GstDiscovererVideoInfo\n- *\n- * Returns: the depth in bits of the video stream.\n- *\/\n-\n-VIDEO_INFO_ACCESSOR_CODE (depth, guint, 0);\n-\n-\/**\n- * gst_discoverer_video_info_get_framerate_num:\n- * @info: a #GstDiscovererVideoInfo\n- *\n- * Returns: the framerate of the video stream (numerator).\n- *\/\n-\n-VIDEO_INFO_ACCESSOR_CODE (framerate_num, guint, 0);\n-\n-\/**\n- * gst_discoverer_video_info_get_framerate_denom:\n- * @info: a #GstDiscovererVideoInfo\n- *\n- * Returns: the framerate of the video stream (denominator).\n- *\/\n-\n-VIDEO_INFO_ACCESSOR_CODE (framerate_denom, guint, 0);\n-\n-\/**\n- * gst_discoverer_video_info_get_par_num:\n- * @info: a #GstDiscovererVideoInfo\n- *\n- * Returns: the Pixel Aspect Ratio (PAR) of the video stream (numerator).\n- *\/\n-\n-VIDEO_INFO_ACCESSOR_CODE (par_num, guint, 0);\n-\n-\/**\n- * gst_discoverer_video_info_get_par_denom:\n- * @info: a #GstDiscovererVideoInfo\n- *\n- * Returns: the Pixel Aspect Ratio (PAR) of the video stream (denominator).\n- *\/\n-\n-VIDEO_INFO_ACCESSOR_CODE (par_denom, guint, 0);\n-\n-\/**\n- * gst_discoverer_video_info_is_interlaced:\n- * @info: a #GstDiscovererVideoInfo\n- *\n- * Returns: %TRUE if the stream is interlaced, else %FALSE.\n- *\/\n-gboolean\n-gst_discoverer_video_info_is_interlaced (const GstDiscovererVideoInfo * info)\n-{\n-  g_return_val_if_fail (GST_IS_DISCOVERER_VIDEO_INFO (info), FALSE);\n-\n-  return info->interlaced;\n-}\n-\n-\/**\n- * gst_discoverer_video_info_get_bitrate:\n- * @info: a #GstDiscovererVideoInfo\n- *\n- * Returns: the average or nominal bitrate of the video stream in bits\/second.\n- *\/\n-\n-VIDEO_INFO_ACCESSOR_CODE (bitrate, guint, 0);\n-\n-\/**\n- * gst_discoverer_video_info_get_max_bitrate:\n- * @info: a #GstDiscovererVideoInfo\n- *\n- * Returns: the maximum bitrate of the video stream in bits\/second.\n- *\/\n-\n-VIDEO_INFO_ACCESSOR_CODE (max_bitrate, guint, 0);\n-\n-\/**\n- * gst_discoverer_video_info_is_image:\n- * @info: a #GstDiscovererVideoInfo\n- *\n- * Returns: %TRUE if the video stream corresponds to an image (i.e. only contains\n- * one frame).\n- *\/\n-gboolean\n-gst_discoverer_video_info_is_image (const GstDiscovererVideoInfo * info)\n-{\n-  g_return_val_if_fail (GST_IS_DISCOVERER_VIDEO_INFO (info), FALSE);\n-\n-  return info->is_image;\n-}\n-\n-\/* GstDiscovererSubtitleInfo *\/\n-\n-#define SUBTITLE_INFO_ACCESSOR_CODE(fieldname, type, failval)                     \\\n-  GENERIC_ACCESSOR_CODE(gst_discoverer_subtitle_info, GstDiscovererSubtitleInfo*, \\\n-      GST_TYPE_DISCOVERER_SUBTITLE_INFO,                        \\\n-      fieldname, type, failval)\n-\n-\/**\n- * gst_discoverer_subtitle_info_get_language:\n- * @info: a #GstDiscovererSubtitleInfo\n- *\n- * Returns: (nullable): the language of the stream, or NULL if unknown.\n- *\/\n-\n-SUBTITLE_INFO_ACCESSOR_CODE (language, const gchar *, NULL);\n-\n-\/* GstDiscovererInfo *\/\n-\n-#define DISCOVERER_INFO_ACCESSOR_CODE(fieldname, type, failval)   \\\n-  GENERIC_ACCESSOR_CODE(gst_discoverer_info, GstDiscovererInfo*,  \\\n-      GST_TYPE_DISCOVERER_INFO,     \\\n-      fieldname, type, failval)\n-\n-\/**\n- * gst_discoverer_info_get_uri:\n- * @info: a #GstDiscovererInfo\n- *\n- * Returns: (transfer none): the URI to which this information corresponds to.\n- * Copy it if you wish to use it after the life-time of @info.\n- *\/\n-\n-DISCOVERER_INFO_ACCESSOR_CODE (uri, const gchar *, NULL);\n-\n-\/**\n- * gst_discoverer_info_get_result:\n- * @info: a #GstDiscovererInfo\n- *\n- * Returns: the result of the discovery as a #GstDiscovererResult.\n- *\/\n-\n-DISCOVERER_INFO_ACCESSOR_CODE (result, GstDiscovererResult, GST_DISCOVERER_OK);\n-\n-\/**\n- * gst_discoverer_info_get_stream_info:\n- * @info: a #GstDiscovererInfo\n- *\n- * Returns: (transfer full) (nullable): the structure (or topology) of the URI as a\n- * #GstDiscovererStreamInfo.\n- * This structure can be traversed to see the original hierarchy. Unref with\n- * gst_discoverer_stream_info_unref() after usage.\n- *\/\n-\n-GstDiscovererStreamInfo *\n-gst_discoverer_info_get_stream_info (GstDiscovererInfo * info)\n-{\n-  g_return_val_if_fail (GST_IS_DISCOVERER_INFO (info), NULL);\n-\n-  if (info->stream_info)\n-    return gst_discoverer_stream_info_ref (info->stream_info);\n-  return NULL;\n-}\n-\n-\/**\n- * gst_discoverer_info_get_stream_list:\n- * @info: a #GstDiscovererInfo\n- *\n- * Returns: (transfer full) (element-type GstPbutils.DiscovererStreamInfo): the list of\n- * all streams contained in the #info. Free after usage\n- * with gst_discoverer_stream_info_list_free().\n- *\/\n-GList *\n-gst_discoverer_info_get_stream_list (GstDiscovererInfo * info)\n-{\n-  GList *res = NULL, *tmp;\n-\n-  g_return_val_if_fail (GST_IS_DISCOVERER_INFO (info), NULL);\n-\n-  for (tmp = info->stream_list; tmp; tmp = tmp->next)\n-    res =\n-        g_list_append (res,\n-        gst_discoverer_stream_info_ref ((GstDiscovererStreamInfo *) tmp->data));\n-\n-  return res;\n-}\n-\n-\/**\n- * gst_discoverer_info_get_duration:\n- * @info: a #GstDiscovererInfo\n- *\n- * Returns: the duration of the URI in #GstClockTime (nanoseconds).\n- *\/\n-\n-DISCOVERER_INFO_ACCESSOR_CODE (duration, GstClockTime, GST_CLOCK_TIME_NONE);\n-\n-\/**\n- * gst_discoverer_info_get_seekable:\n- * @info: a #GstDiscovererInfo\n- *\n- * Returns: the whether the URI is seekable.\n- *\/\n-\n-DISCOVERER_INFO_ACCESSOR_CODE (seekable, gboolean, FALSE);\n-\n-\/**\n- * gst_discoverer_info_get_live:\n- * @info: a #GstDiscovererInfo\n- *\n- * Returns: whether the URI is live.\n- *\n- * Since: 1.14\n- *\/\n-\n-DISCOVERER_INFO_ACCESSOR_CODE (live, gboolean, FALSE);\n-\n-#ifndef GST_REMOVE_DEPRECATED\n-\/**\n- * gst_discoverer_info_get_misc:\n- * @info: a #GstDiscovererInfo\n- *\n- * Deprecated: This functions is deprecated since version 1.4, use\n- * #gst_discoverer_info_get_missing_elements_installer_details\n- *\n- * Returns: (transfer none) (nullable): Miscellaneous information stored as a #GstStructure\n- * (for example: information about missing plugins). If you wish to use the\n- * #GstStructure after the life-time of @info, you will need to copy it.\n- *\/\n-\n-DISCOVERER_INFO_ACCESSOR_CODE (misc, const GstStructure *, NULL);\n-\n-\/**\n- * gst_discoverer_info_get_tags:\n- * @info: a #GstDiscovererInfo\n- *\n- * Returns: (transfer none) (nullable): all tags contained in the URI. If you wish to use\n- * the tags after the life-time of @info, you will need to copy them.\n- *\n- * Deprecated: 1.20: Use gst_discoverer_{container,stream}_info_get_tags() instead.\n- *\/\n-\n-DISCOVERER_INFO_ACCESSOR_CODE (tags, const GstTagList *, NULL);\n-#endif\n-\n-\/**\n- * gst_discoverer_info_get_toc:\n- * @info: a #GstDiscovererInfo\n- *\n- * Returns: (transfer none) (nullable): TOC contained in the URI. If you wish to use\n- * the TOC after the life-time of @info, you will need to copy it.\n- *\/\n-\n-DISCOVERER_INFO_ACCESSOR_CODE (toc, const GstToc *, NULL);\n-\n-\/**\n- * gst_discoverer_info_ref:\n- * @info: a #GstDiscovererInfo\n- *\n- * Increments the reference count of @info.\n- *\n- * Returns: the same #GstDiscovererInfo object\n- *\/\n-\n-\/**\n- * gst_discoverer_info_unref:\n- * @info: a #GstDiscovererInfo\n- *\n- * Decrements the reference count of @info.\n- *\/\n-\n-\/**\n- * gst_discoverer_stream_info_ref:\n- * @info: a #GstDiscovererStreamInfo\n- *\n- * Increments the reference count of @info.\n- *\n- * Returns: the same #GstDiscovererStreamInfo object\n- *\/\n-\n-\/**\n- * gst_discoverer_stream_info_unref:\n- * @info: a #GstDiscovererStreamInfo\n- *\n- * Decrements the reference count of @info.\n- *\/\n-\n-\n-\/**\n- * gst_discoverer_info_get_missing_elements_installer_details:\n- * @info: a #GstDiscovererStreamInfo to retrieve installer detail\n- * for the missing element\n- *\n- * Get the installer details for missing elements\n- *\n- * Returns: (transfer none) (array zero-terminated=1): An array of strings\n- * containing information about how to install the various missing elements\n- * for @info to be usable. If you wish to use the strings after the life-time\n- * of @info, you will need to copy them.\n- *\n- * Since: 1.4\n- *\/\n-const gchar **\n-gst_discoverer_info_get_missing_elements_installer_details (const\n-    GstDiscovererInfo * info)\n-{\n-\n-  if (info->result != GST_DISCOVERER_MISSING_PLUGINS) {\n-    GST_WARNING_OBJECT (info, \"Trying to get missing element installed details \"\n-        \"but result is not 'MISSING_PLUGINS'\");\n-\n-    return NULL;\n-  }\n-\n-  if (info->missing_elements_details->pdata[info->missing_elements_details->\n-          len]) {\n-    GST_DEBUG (\"Adding NULL pointer to the end of missing_elements_details\");\n-    g_ptr_array_add (info->missing_elements_details, NULL);\n-  }\n-\n-  return (const gchar **) info->missing_elements_details->pdata;\n-}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/gstdiscoverer-types.c","additions":0,"deletions":1197,"binary":false,"changes":1197,"status":"deleted"},{"patch":"@@ -1,2775 +0,0 @@\n-\/* GStreamer\n- * Copyright (C) 2009 Edward Hervey <edward.hervey@collabora.co.uk>\n- *               2009 Nokia Corporation\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Library General Public\n- * License as published by the Free Software Foundation; either\n- * version 2 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Library General Public License for more details.\n- *\n- * You should have received a copy of the GNU Library General Public\n- * License along with this library; if not, write to the\n- * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n- * Boston, MA 02110-1301, USA.\n- *\/\n-\n-\/**\n- * SECTION:gstdiscoverer\n- * @title: GstDiscoverer\n- * @short_description: Utility for discovering information on URIs.\n- *\n- * The #GstDiscoverer is a utility object which allows to get as much\n- * information as possible from one or many URIs.\n- *\n- * It provides two APIs, allowing usage in blocking or non-blocking mode.\n- *\n- * The blocking mode just requires calling gst_discoverer_discover_uri()\n- * with the URI one wishes to discover.\n- *\n- * The non-blocking mode requires a running #GMainLoop iterating a\n- * #GMainContext, where one connects to the various signals, appends the\n- * URIs to be processed (through gst_discoverer_discover_uri_async()) and then\n- * asks for the discovery to begin (through gst_discoverer_start()).\n- * By default this will use the GLib default main context unless you have\n- * set a custom context using g_main_context_push_thread_default().\n- *\n- * All the information is returned in a #GstDiscovererInfo structure.\n- *\/\n-\n-#ifdef HAVE_CONFIG_H\n-#include \"config.h\"\n-#endif\n-\n-#include <gst\/video\/video.h>\n-#include <gst\/audio\/audio.h>\n-\n-#include <string.h>\n-\n-#include \"pbutils.h\"\n-#include \"pbutils-private.h\"\n-\n-\/* For g_stat () *\/\n-#include <glib\/gstdio.h>\n-\n-GST_DEBUG_CATEGORY_STATIC (discoverer_debug);\n-#define GST_CAT_DEFAULT discoverer_debug\n-#define CACHE_DIRNAME \"discoverer\"\n-\n-static GQuark _CAPS_QUARK;\n-static GQuark _TAGS_QUARK;\n-static GQuark _ELEMENT_SRCPAD_QUARK;\n-static GQuark _TOC_QUARK;\n-static GQuark _STREAM_ID_QUARK;\n-static GQuark _MISSING_PLUGIN_QUARK;\n-static GQuark _STREAM_TOPOLOGY_QUARK;\n-static GQuark _TOPOLOGY_PAD_QUARK;\n-\n-\n-typedef struct\n-{\n-  GstDiscoverer *dc;\n-  GstPad *pad;\n-  GstElement *queue;\n-  GstElement *sink;\n-  GstTagList *tags;\n-  GstToc *toc;\n-  gchar *stream_id;\n-  gulong probe_id;\n-} PrivateStream;\n-\n-struct _GstDiscovererPrivate\n-{\n-  gboolean async;\n-\n-  \/* allowed time to discover each uri in nanoseconds *\/\n-  GstClockTime timeout;\n-\n-  \/* list of pending URI to process (current excluded) *\/\n-  GList *pending_uris;\n-\n-  GMutex lock;\n-  \/* TRUE if cleaning up discoverer *\/\n-  gboolean cleanup;\n-\n-  \/* TRUE if processing a URI *\/\n-  gboolean processing;\n-\n-  \/* TRUE if discoverer has been started *\/\n-  gboolean running;\n-\n-  \/* current items *\/\n-  GstDiscovererInfo *current_info;\n-  GError *current_error;\n-  GstStructure *current_topology;\n-\n-  GstTagList *all_tags;\n-  GstTagList *global_tags;\n-\n-  \/* List of private streams *\/\n-  GList *streams;\n-\n-  \/* List of these sinks and their handler IDs (to remove the probe) *\/\n-  guint pending_subtitle_pads;\n-\n-  \/* Whether we received no_more_pads *\/\n-  gboolean no_more_pads;\n-\n-  GstState target_state;\n-  GstState current_state;\n-\n-  \/* Global elements *\/\n-  GstBin *pipeline;\n-  GstElement *uridecodebin;\n-  GstBus *bus;\n-\n-  \/* Custom main context variables *\/\n-  GMainContext *ctx;\n-  GSource *bus_source;\n-  GSource *timeout_source;\n-\n-  \/* reusable queries *\/\n-  GstQuery *seeking_query;\n-\n-  \/* Handler ids for various callbacks *\/\n-  gulong pad_added_id;\n-  gulong pad_remove_id;\n-  gulong no_more_pads_id;\n-  gulong source_chg_id;\n-  gulong bus_cb_id;\n-\n-  gboolean use_cache;\n-};\n-\n-#define DISCO_LOCK(dc) g_mutex_lock (&dc->priv->lock);\n-#define DISCO_UNLOCK(dc) g_mutex_unlock (&dc->priv->lock);\n-\n-static void\n-_do_init (void)\n-{\n-  GST_DEBUG_CATEGORY_INIT (discoverer_debug, \"discoverer\", 0, \"Discoverer\");\n-\n-  _CAPS_QUARK = g_quark_from_static_string (\"caps\");\n-  _ELEMENT_SRCPAD_QUARK = g_quark_from_static_string (\"element-srcpad\");\n-  _TAGS_QUARK = g_quark_from_static_string (\"tags\");\n-  _TOC_QUARK = g_quark_from_static_string (\"toc\");\n-  _STREAM_ID_QUARK = g_quark_from_static_string (\"stream-id\");\n-  _MISSING_PLUGIN_QUARK = g_quark_from_static_string (\"missing-plugin\");\n-  _STREAM_TOPOLOGY_QUARK = g_quark_from_static_string (\"stream-topology\");\n-  _TOPOLOGY_PAD_QUARK = g_quark_from_static_string (\"pad\");\n-};\n-\n-G_DEFINE_TYPE_EXTENDED (GstDiscoverer, gst_discoverer, G_TYPE_OBJECT, 0,\n-    G_ADD_PRIVATE (GstDiscoverer) _do_init ());\n-\n-enum\n-{\n-  SIGNAL_FINISHED,\n-  SIGNAL_STARTING,\n-  SIGNAL_DISCOVERED,\n-  SIGNAL_SOURCE_SETUP,\n-  SIGNAL_LOAD_SERIALIZED_INFO,\n-  LAST_SIGNAL\n-};\n-\n-#define DEFAULT_PROP_TIMEOUT 15 * GST_SECOND\n-#define DEFAULT_PROP_USE_CACHE FALSE\n-\n-enum\n-{\n-  PROP_0,\n-  PROP_TIMEOUT,\n-  PROP_USE_CACHE\n-};\n-\n-static guint gst_discoverer_signals[LAST_SIGNAL] = { 0 };\n-\n-static void gst_discoverer_set_timeout (GstDiscoverer * dc,\n-    GstClockTime timeout);\n-static gboolean async_timeout_cb (GstDiscoverer * dc);\n-\n-static void discoverer_bus_cb (GstBus * bus, GstMessage * msg,\n-    GstDiscoverer * dc);\n-static void uridecodebin_pad_added_cb (GstElement * uridecodebin, GstPad * pad,\n-    GstDiscoverer * dc);\n-static void uridecodebin_pad_removed_cb (GstElement * uridecodebin,\n-    GstPad * pad, GstDiscoverer * dc);\n-static void uridecodebin_no_more_pads_cb (GstElement * uridecodebin,\n-    GstDiscoverer * dc);\n-static void uridecodebin_source_changed_cb (GstElement * uridecodebin,\n-    GParamSpec * pspec, GstDiscoverer * dc);\n-\n-static void gst_discoverer_dispose (GObject * dc);\n-static void gst_discoverer_finalize (GObject * dc);\n-static void gst_discoverer_set_property (GObject * object, guint prop_id,\n-    const GValue * value, GParamSpec * pspec);\n-static void gst_discoverer_get_property (GObject * object, guint prop_id,\n-    GValue * value, GParamSpec * pspec);\n-static gboolean _setup_locked (GstDiscoverer * dc);\n-static void handle_current_async (GstDiscoverer * dc);\n-static gboolean emit_discovererd_and_next (GstDiscoverer * dc);\n-static GVariant *gst_discoverer_info_to_variant_recurse (GstDiscovererStreamInfo\n-    * sinfo, GstDiscovererSerializeFlags flags);\n-static GstDiscovererStreamInfo *_parse_discovery (GVariant * variant,\n-    GstDiscovererInfo * info);\n-static GstDiscovererInfo *load_serialized_info (GstDiscoverer * dc,\n-    gchar * uri);\n-\n-static gboolean\n-_gst_discoverer_info_accumulator (GSignalInvocationHint * ihint,\n-    GValue * return_accu, const GValue * handler_return, gpointer dummy)\n-{\n-  GstDiscovererInfo *info;\n-\n-  info = g_value_get_object (handler_return);\n-  GST_DEBUG (\"got discoverer info %\" GST_PTR_FORMAT, info);\n-\n-  g_value_set_object (return_accu, info);\n-\n-  \/* stop emission if we have a discoverer info *\/\n-  return (info == NULL);\n-}\n-\n-static void\n-gst_discoverer_class_init (GstDiscovererClass * klass)\n-{\n-  GObjectClass *gobject_class = (GObjectClass *) klass;\n-\n-  gobject_class->dispose = gst_discoverer_dispose;\n-  gobject_class->finalize = gst_discoverer_finalize;\n-\n-  gobject_class->set_property = gst_discoverer_set_property;\n-  gobject_class->get_property = gst_discoverer_get_property;\n-\n-  klass->load_serialize_info = load_serialized_info;\n-\n-\n-  \/* properties *\/\n-  \/**\n-   * GstDiscoverer:timeout:\n-   *\n-   * The duration (in nanoseconds) after which the discovery of an individual\n-   * URI will timeout.\n-   *\n-   * If the discovery of a URI times out, the %GST_DISCOVERER_TIMEOUT will be\n-   * set on the result flags.\n-   *\/\n-  g_object_class_install_property (gobject_class, PROP_TIMEOUT,\n-      g_param_spec_uint64 (\"timeout\", \"timeout\", \"Timeout\",\n-          GST_SECOND, 3600 * GST_SECOND, DEFAULT_PROP_TIMEOUT,\n-          G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS));\n-\n-  \/**\n-   * GstDiscoverer::use-cache:\n-   *\n-   * Whether to use a serialized version of the discoverer info from our\n-   * own cache if accessible. This allows the discovery to be much faster\n-   * as when using this option, we do not need to create a #GstPipeline\n-   * and run it, but instead, just reload the #GstDiscovererInfo in its\n-   * serialized form.\n-   *\n-   * The cache files are saved in `$XDG_CACHE_DIR\/gstreamer-1.0\/discoverer\/`.\n-   *\n-   * Since: 1.16\n-   *\/\n-  g_object_class_install_property (gobject_class, PROP_USE_CACHE,\n-      g_param_spec_boolean (\"use-cache\", \"use cache\", \"Use cache\",\n-          DEFAULT_PROP_USE_CACHE,\n-          G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS));\n-\n-  \/* signals *\/\n-  \/**\n-   * GstDiscoverer::finished:\n-   * @discoverer: the #GstDiscoverer\n-   *\n-   * Will be emitted in async mode when all pending URIs have been processed.\n-   *\/\n-  gst_discoverer_signals[SIGNAL_FINISHED] =\n-      g_signal_new (\"finished\", G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,\n-      G_STRUCT_OFFSET (GstDiscovererClass, finished), NULL, NULL, NULL,\n-      G_TYPE_NONE, 0, G_TYPE_NONE);\n-\n-  \/**\n-   * GstDiscoverer::starting:\n-   * @discoverer: the #GstDiscoverer\n-   *\n-   * Will be emitted when the discover starts analyzing the pending URIs\n-   *\/\n-  gst_discoverer_signals[SIGNAL_STARTING] =\n-      g_signal_new (\"starting\", G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,\n-      G_STRUCT_OFFSET (GstDiscovererClass, starting), NULL, NULL, NULL,\n-      G_TYPE_NONE, 0, G_TYPE_NONE);\n-\n-  \/**\n-   * GstDiscoverer::discovered:\n-   * @discoverer: the #GstDiscoverer\n-   * @info: the results #GstDiscovererInfo\n-   * @error: (allow-none) (type GLib.Error): #GError, which will be non-NULL\n-   *                                         if an error occurred during\n-   *                                         discovery. You must not free\n-   *                                         this #GError, it will be freed by\n-   *                                         the discoverer.\n-   *\n-   * Will be emitted in async mode when all information on a URI could be\n-   * discovered, or an error occurred.\n-   *\n-   * When an error occurs, @info might still contain some partial information,\n-   * depending on the circumstances of the error.\n-   *\/\n-  gst_discoverer_signals[SIGNAL_DISCOVERED] =\n-      g_signal_new (\"discovered\", G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,\n-      G_STRUCT_OFFSET (GstDiscovererClass, discovered), NULL, NULL, NULL,\n-      G_TYPE_NONE, 2, GST_TYPE_DISCOVERER_INFO,\n-      G_TYPE_ERROR | G_SIGNAL_TYPE_STATIC_SCOPE);\n-\n-  \/**\n-   * GstDiscoverer::source-setup:\n-   * @discoverer: the #GstDiscoverer\n-   * @source: source element\n-   *\n-   * This signal is emitted after the source element has been created for, so\n-   * the URI being discovered, so it can be configured by setting additional\n-   * properties (e.g. set a proxy server for an http source, or set the device\n-   * and read speed for an audio cd source).\n-   *\n-   * This signal is usually emitted from the context of a GStreamer streaming\n-   * thread.\n-   *\/\n-  gst_discoverer_signals[SIGNAL_SOURCE_SETUP] =\n-      g_signal_new (\"source-setup\", G_TYPE_FROM_CLASS (klass),\n-      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstDiscovererClass, source_setup),\n-      NULL, NULL, NULL, G_TYPE_NONE, 1, GST_TYPE_ELEMENT);\n-\n-  \/**\n-   * GstDiscoverer::load-serialized-info:\n-   * @discoverer: the #GstDiscoverer\n-   * @uri: THe URI to load the serialized info for\n-   *\n-   * Retrieves information about a URI from and external source of information,\n-   * like a cache file. This is used by the discoverer to speed up the\n-   * discovery.\n-   *\n-   * Returns: (nullable) (transfer full): The #GstDiscovererInfo representing\n-   * @uri, or %NULL if no information\n-   *\n-   * Since: 1.24\n-   *\/\n-  gst_discoverer_signals[SIGNAL_LOAD_SERIALIZED_INFO] =\n-      g_signal_new (\"load-serialized-info\", G_TYPE_FROM_CLASS (klass),\n-      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstDiscovererClass,\n-          load_serialize_info), _gst_discoverer_info_accumulator, NULL, NULL,\n-      GST_TYPE_DISCOVERER_INFO, 1, G_TYPE_STRING);\n-}\n-\n-static void\n-gst_discoverer_init (GstDiscoverer * dc)\n-{\n-  GstFormat format = GST_FORMAT_TIME;\n-\n-  dc->priv = gst_discoverer_get_instance_private (dc);\n-\n-  dc->priv->timeout = DEFAULT_PROP_TIMEOUT;\n-  dc->priv->use_cache = DEFAULT_PROP_USE_CACHE;\n-  dc->priv->async = FALSE;\n-\n-  g_mutex_init (&dc->priv->lock);\n-\n-  dc->priv->pending_subtitle_pads = 0;\n-\n-  dc->priv->current_state = GST_STATE_NULL;\n-  dc->priv->target_state = GST_STATE_NULL;\n-  dc->priv->no_more_pads = FALSE;\n-\n-  dc->priv->all_tags = NULL;\n-  dc->priv->global_tags = NULL;\n-\n-  GST_LOG (\"Creating pipeline\");\n-  dc->priv->pipeline = (GstBin *) gst_pipeline_new (\"Discoverer\");\n-  GST_LOG_OBJECT (dc, \"Creating uridecodebin\");\n-  dc->priv->uridecodebin =\n-      gst_element_factory_make (\"uridecodebin\", \"discoverer-uri\");\n-  if (G_UNLIKELY (dc->priv->uridecodebin == NULL)) {\n-    GST_ERROR (\"Can't create uridecodebin\");\n-    return;\n-  }\n-\n-  g_object_set (dc->priv->uridecodebin, \"post-stream-topology\", TRUE, NULL);\n-\n-  GST_LOG_OBJECT (dc, \"Adding uridecodebin to pipeline\");\n-  gst_bin_add (dc->priv->pipeline, dc->priv->uridecodebin);\n-\n-  dc->priv->pad_added_id =\n-      g_signal_connect_object (dc->priv->uridecodebin, \"pad-added\",\n-      G_CALLBACK (uridecodebin_pad_added_cb), dc, 0);\n-  dc->priv->pad_remove_id =\n-      g_signal_connect_object (dc->priv->uridecodebin, \"pad-removed\",\n-      G_CALLBACK (uridecodebin_pad_removed_cb), dc, 0);\n-  dc->priv->no_more_pads_id =\n-      g_signal_connect_object (dc->priv->uridecodebin, \"no-more-pads\",\n-      G_CALLBACK (uridecodebin_no_more_pads_cb), dc, 0);\n-  dc->priv->source_chg_id =\n-      g_signal_connect_object (dc->priv->uridecodebin, \"notify::source\",\n-      G_CALLBACK (uridecodebin_source_changed_cb), dc, 0);\n-\n-  GST_LOG_OBJECT (dc, \"Getting pipeline bus\");\n-  dc->priv->bus = gst_pipeline_get_bus ((GstPipeline *) dc->priv->pipeline);\n-\n-  dc->priv->bus_cb_id =\n-      g_signal_connect_object (dc->priv->bus, \"message\",\n-      G_CALLBACK (discoverer_bus_cb), dc, 0);\n-\n-  GST_DEBUG_OBJECT (dc, \"Done initializing Discoverer\");\n-\n-  \/* create queries *\/\n-  dc->priv->seeking_query = gst_query_new_seeking (format);\n-}\n-\n-static void\n-discoverer_reset (GstDiscoverer * dc)\n-{\n-  GST_DEBUG_OBJECT (dc, \"Resetting\");\n-\n-  if (dc->priv->pending_uris) {\n-    g_list_foreach (dc->priv->pending_uris, (GFunc) g_free, NULL);\n-    g_list_free (dc->priv->pending_uris);\n-    dc->priv->pending_uris = NULL;\n-  }\n-\n-  if (dc->priv->pipeline)\n-    gst_element_set_state ((GstElement *) dc->priv->pipeline, GST_STATE_NULL);\n-}\n-\n-#define DISCONNECT_SIGNAL(o,i) G_STMT_START{           \\\n-  if ((i) && g_signal_handler_is_connected ((o), (i))) \\\n-    g_signal_handler_disconnect ((o), (i));            \\\n-  (i) = 0;                                             \\\n-}G_STMT_END\n-\n-static void\n-gst_discoverer_dispose (GObject * obj)\n-{\n-  GstDiscoverer *dc = (GstDiscoverer *) obj;\n-\n-  GST_DEBUG_OBJECT (dc, \"Disposing\");\n-\n-  discoverer_reset (dc);\n-\n-  if (G_LIKELY (dc->priv->pipeline)) {\n-    \/* Workaround for bug #118536 *\/\n-    DISCONNECT_SIGNAL (dc->priv->uridecodebin, dc->priv->pad_added_id);\n-    DISCONNECT_SIGNAL (dc->priv->uridecodebin, dc->priv->pad_remove_id);\n-    DISCONNECT_SIGNAL (dc->priv->uridecodebin, dc->priv->no_more_pads_id);\n-    DISCONNECT_SIGNAL (dc->priv->uridecodebin, dc->priv->source_chg_id);\n-    DISCONNECT_SIGNAL (dc->priv->bus, dc->priv->bus_cb_id);\n-\n-    \/* pipeline was set to NULL in _reset *\/\n-    gst_object_unref (dc->priv->pipeline);\n-    if (dc->priv->bus)\n-      gst_object_unref (dc->priv->bus);\n-\n-    dc->priv->pipeline = NULL;\n-    dc->priv->uridecodebin = NULL;\n-    dc->priv->bus = NULL;\n-  }\n-\n-  gst_discoverer_stop (dc);\n-\n-  if (dc->priv->seeking_query) {\n-    gst_query_unref (dc->priv->seeking_query);\n-    dc->priv->seeking_query = NULL;\n-  }\n-\n-  G_OBJECT_CLASS (gst_discoverer_parent_class)->dispose (obj);\n-}\n-\n-static void\n-gst_discoverer_finalize (GObject * obj)\n-{\n-  GstDiscoverer *dc = (GstDiscoverer *) obj;\n-\n-  g_mutex_clear (&dc->priv->lock);\n-\n-  G_OBJECT_CLASS (gst_discoverer_parent_class)->finalize (obj);\n-}\n-\n-static void\n-gst_discoverer_set_property (GObject * object, guint prop_id,\n-    const GValue * value, GParamSpec * pspec)\n-{\n-  GstDiscoverer *dc = (GstDiscoverer *) object;\n-\n-  switch (prop_id) {\n-    case PROP_TIMEOUT:\n-      gst_discoverer_set_timeout (dc, g_value_get_uint64 (value));\n-      break;\n-    case PROP_USE_CACHE:\n-      DISCO_LOCK (dc);\n-      dc->priv->use_cache = g_value_get_boolean (value);\n-      DISCO_UNLOCK (dc);\n-      break;\n-    default:\n-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n-      break;\n-  }\n-}\n-\n-static void\n-gst_discoverer_get_property (GObject * object, guint prop_id,\n-    GValue * value, GParamSpec * pspec)\n-{\n-  GstDiscoverer *dc = (GstDiscoverer *) object;\n-\n-  switch (prop_id) {\n-    case PROP_TIMEOUT:\n-      DISCO_LOCK (dc);\n-      g_value_set_uint64 (value, dc->priv->timeout);\n-      DISCO_UNLOCK (dc);\n-      break;\n-    case PROP_USE_CACHE:\n-      DISCO_LOCK (dc);\n-      g_value_set_boolean (value, dc->priv->use_cache);\n-      DISCO_UNLOCK (dc);\n-      break;\n-    default:\n-      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n-      break;\n-  }\n-}\n-\n-static void\n-gst_discoverer_set_timeout (GstDiscoverer * dc, GstClockTime timeout)\n-{\n-  g_return_if_fail (GST_CLOCK_TIME_IS_VALID (timeout));\n-\n-  GST_DEBUG_OBJECT (dc, \"timeout : %\" GST_TIME_FORMAT, GST_TIME_ARGS (timeout));\n-\n-  \/* FIXME : update current pending timeout if we're running *\/\n-  DISCO_LOCK (dc);\n-  dc->priv->timeout = timeout;\n-  DISCO_UNLOCK (dc);\n-}\n-\n-static GstPadProbeReturn\n-_event_probe (GstPad * pad, GstPadProbeInfo * info, PrivateStream * ps)\n-{\n-  GstEvent *event = GST_PAD_PROBE_INFO_EVENT (info);\n-\n-  switch (GST_EVENT_TYPE (event)) {\n-    case GST_EVENT_TOC:{\n-      GstToc *tmp;\n-\n-      gst_event_parse_toc (event, &tmp, NULL);\n-      GST_DEBUG_OBJECT (pad, \"toc %\" GST_PTR_FORMAT, tmp);\n-      DISCO_LOCK (ps->dc);\n-      ps->toc = tmp;\n-      if (G_LIKELY (ps->dc->priv->processing)) {\n-        GST_DEBUG_OBJECT (pad, \"private stream %p toc %\" GST_PTR_FORMAT, ps,\n-            tmp);\n-      } else\n-        GST_DEBUG_OBJECT (pad, \"Dropping toc since preroll is done\");\n-      DISCO_UNLOCK (ps->dc);\n-      break;\n-    }\n-    case GST_EVENT_STREAM_START:{\n-      const gchar *stream_id;\n-\n-      gst_event_parse_stream_start (event, &stream_id);\n-\n-      g_free (ps->stream_id);\n-      ps->stream_id = stream_id ? g_strdup (stream_id) : NULL;\n-      break;\n-    }\n-    default:\n-      break;\n-  }\n-\n-  return GST_PAD_PROBE_OK;\n-}\n-\n-static GstStaticCaps subtitle_caps =\n-    GST_STATIC_CAPS\n-    (\"application\/x-ssa; application\/x-ass; application\/x-kate\");\n-\n-static gboolean\n-is_subtitle_caps (const GstCaps * caps)\n-{\n-  GstCaps *subs_caps;\n-  GstStructure *s;\n-  const gchar *name;\n-  gboolean ret;\n-\n-  s = gst_caps_get_structure (caps, 0);\n-  if (!s)\n-    return FALSE;\n-\n-  name = gst_structure_get_name (s);\n-  if (g_str_has_prefix (name, \"text\/\") ||\n-      g_str_has_prefix (name, \"subpicture\/\") ||\n-      g_str_has_prefix (name, \"subtitle\/\") ||\n-      g_str_has_prefix (name, \"closedcaption\/\") ||\n-      g_str_has_prefix (name, \"application\/x-subtitle\"))\n-    return TRUE;\n-\n-  subs_caps = gst_static_caps_get (&subtitle_caps);\n-  ret = gst_caps_can_intersect (caps, subs_caps);\n-  gst_caps_unref (subs_caps);\n-\n-  return ret;\n-}\n-\n-static GstPadProbeReturn\n-got_subtitle_data (GstPad * pad, GstPadProbeInfo * info, GstDiscoverer * dc)\n-{\n-  GstMessage *msg;\n-\n-  if (!(GST_IS_BUFFER (info->data) || (GST_IS_EVENT (info->data)\n-              && (GST_EVENT_TYPE ((GstEvent *) info->data) == GST_EVENT_GAP\n-                  || GST_EVENT_TYPE ((GstEvent *) info->data) ==\n-                  GST_EVENT_EOS))))\n-    return GST_PAD_PROBE_OK;\n-\n-\n-  DISCO_LOCK (dc);\n-\n-  dc->priv->pending_subtitle_pads--;\n-\n-  msg = gst_message_new_application (NULL,\n-      gst_structure_new_empty (\"DiscovererDone\"));\n-  gst_element_post_message ((GstElement *) dc->priv->pipeline, msg);\n-\n-  DISCO_UNLOCK (dc);\n-\n-  return GST_PAD_PROBE_REMOVE;\n-\n-}\n-\n-static void\n-uridecodebin_source_changed_cb (GstElement * uridecodebin,\n-    GParamSpec * pspec, GstDiscoverer * dc)\n-{\n-  GstElement *src;\n-  \/* get a handle to the source *\/\n-  g_object_get (uridecodebin, pspec->name, &src, NULL);\n-\n-  GST_DEBUG_OBJECT (dc, \"got a new source %p\", src);\n-\n-  g_signal_emit (dc, gst_discoverer_signals[SIGNAL_SOURCE_SETUP], 0, src);\n-  gst_object_unref (src);\n-}\n-\n-static void\n-uridecodebin_pad_added_cb (GstElement * uridecodebin, GstPad * pad,\n-    GstDiscoverer * dc)\n-{\n-  PrivateStream *ps;\n-  GstPad *sinkpad = NULL;\n-  GstCaps *caps;\n-  gchar *padname;\n-  gchar *tmpname;\n-\n-  GST_DEBUG_OBJECT (dc, \"pad %s:%s\", GST_DEBUG_PAD_NAME (pad));\n-\n-  DISCO_LOCK (dc);\n-  if (dc->priv->cleanup) {\n-    GST_WARNING_OBJECT (dc, \"Cleanup, not adding pad\");\n-    DISCO_UNLOCK (dc);\n-    return;\n-  }\n-  if (dc->priv->current_error) {\n-    GST_WARNING_OBJECT (dc, \"Ongoing error, not adding more pads\");\n-    DISCO_UNLOCK (dc);\n-    return;\n-  }\n-  ps = g_new0 (PrivateStream, 1);\n-\n-  ps->dc = dc;\n-  ps->pad = pad;\n-  padname = gst_pad_get_name (pad);\n-  tmpname = g_strdup_printf (\"discoverer-queue-%s\", padname);\n-  ps->queue = gst_element_factory_make (\"queue\", tmpname);\n-  g_free (tmpname);\n-  tmpname = g_strdup_printf (\"discoverer-sink-%s\", padname);\n-  ps->sink = gst_element_factory_make (\"fakesink\", tmpname);\n-  g_free (tmpname);\n-  g_free (padname);\n-\n-  if (G_UNLIKELY (ps->queue == NULL || ps->sink == NULL))\n-    goto error;\n-\n-  g_object_set (ps->sink, \"silent\", TRUE, NULL);\n-  g_object_set (ps->queue, \"max-size-buffers\", 1, \"silent\", TRUE, NULL);\n-\n-  sinkpad = gst_element_get_static_pad (ps->queue, \"sink\");\n-  if (sinkpad == NULL)\n-    goto error;\n-\n-  caps = gst_pad_get_current_caps (pad);\n-  if (!caps) {\n-    GST_WARNING (\"Couldn't get negotiated caps from %s:%s\",\n-        GST_DEBUG_PAD_NAME (pad));\n-    caps = gst_pad_query_caps (pad, NULL);\n-  }\n-\n-  if (caps && !gst_caps_is_empty (caps) && !gst_caps_is_any (caps)\n-      && is_subtitle_caps (caps)) {\n-    \/* Subtitle streams are sparse and may not provide any information - don't\n-     * wait for data to preroll *\/\n-    ps->probe_id =\n-        gst_pad_add_probe (sinkpad, GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM,\n-        (GstPadProbeCallback) got_subtitle_data, dc, NULL);\n-    g_object_set (ps->sink, \"async\", FALSE, NULL);\n-    dc->priv->pending_subtitle_pads++;\n-  }\n-\n-  if (caps)\n-    gst_caps_unref (caps);\n-\n-  gst_bin_add_many (dc->priv->pipeline, ps->queue, ps->sink, NULL);\n-\n-  if (!gst_element_link_pads_full (ps->queue, \"src\", ps->sink, \"sink\",\n-          GST_PAD_LINK_CHECK_NOTHING))\n-    goto error;\n-  if (!gst_element_sync_state_with_parent (ps->sink))\n-    goto error;\n-  if (!gst_element_sync_state_with_parent (ps->queue))\n-    goto error;\n-\n-  if (gst_pad_link_full (pad, sinkpad,\n-          GST_PAD_LINK_CHECK_NOTHING) != GST_PAD_LINK_OK)\n-    goto error;\n-  gst_object_unref (sinkpad);\n-\n-  \/* Add an event probe *\/\n-  gst_pad_add_probe (pad, GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM,\n-      (GstPadProbeCallback) _event_probe, ps, NULL);\n-\n-  dc->priv->streams = g_list_append (dc->priv->streams, ps);\n-  DISCO_UNLOCK (dc);\n-\n-  GST_DEBUG_OBJECT (dc, \"Done handling pad\");\n-\n-  return;\n-\n-error:\n-  GST_ERROR_OBJECT (dc, \"Error while handling pad\");\n-  if (sinkpad)\n-    gst_object_unref (sinkpad);\n-  if (ps->queue)\n-    gst_object_unref (ps->queue);\n-  if (ps->sink)\n-    gst_object_unref (ps->sink);\n-  g_free (ps);\n-  DISCO_UNLOCK (dc);\n-  return;\n-}\n-\n-static void\n-uridecodebin_no_more_pads_cb (GstElement * uridecodebin, GstDiscoverer * dc)\n-{\n-  GstMessage *msg = gst_message_new_application (NULL,\n-      gst_structure_new_empty (\"DiscovererDone\"));\n-\n-  DISCO_LOCK (dc);\n-  dc->priv->no_more_pads = TRUE;\n-  gst_element_post_message ((GstElement *) dc->priv->pipeline, msg);\n-  DISCO_UNLOCK (dc);\n-}\n-\n-static void\n-uridecodebin_pad_removed_cb (GstElement * uridecodebin, GstPad * pad,\n-    GstDiscoverer * dc)\n-{\n-  GList *tmp;\n-  PrivateStream *ps;\n-  GstPad *sinkpad;\n-\n-  GST_DEBUG_OBJECT (dc, \"pad %s:%s\", GST_DEBUG_PAD_NAME (pad));\n-\n-  \/* Find the PrivateStream *\/\n-  DISCO_LOCK (dc);\n-  for (tmp = dc->priv->streams; tmp; tmp = tmp->next) {\n-    ps = (PrivateStream *) tmp->data;\n-    if (ps->pad == pad)\n-      break;\n-  }\n-\n-  if (tmp == NULL) {\n-    DISCO_UNLOCK (dc);\n-    GST_DEBUG (\"The removed pad wasn't controlled by us !\");\n-    return;\n-  }\n-\n-  if (ps->probe_id)\n-    gst_pad_remove_probe (pad, ps->probe_id);\n-\n-  dc->priv->streams = g_list_delete_link (dc->priv->streams, tmp);\n-\n-  gst_element_set_state (ps->sink, GST_STATE_NULL);\n-  gst_element_set_state (ps->queue, GST_STATE_NULL);\n-  gst_element_unlink (ps->queue, ps->sink);\n-\n-  sinkpad = gst_element_get_static_pad (ps->queue, \"sink\");\n-  gst_pad_unlink (pad, sinkpad);\n-  gst_object_unref (sinkpad);\n-\n-  \/* references removed here *\/\n-  gst_bin_remove_many (dc->priv->pipeline, ps->sink, ps->queue, NULL);\n-\n-  DISCO_UNLOCK (dc);\n-  if (ps->tags) {\n-    gst_tag_list_unref (ps->tags);\n-  }\n-  if (ps->toc) {\n-    gst_toc_unref (ps->toc);\n-  }\n-  g_free (ps->stream_id);\n-\n-  g_free (ps);\n-\n-  GST_DEBUG (\"Done handling pad\");\n-}\n-\n-static GstStructure *\n-collect_stream_information (GstDiscoverer * dc, PrivateStream * ps, guint idx)\n-{\n-  GstCaps *caps;\n-  GstStructure *st;\n-  gchar *stname;\n-\n-  stname = g_strdup_printf (\"stream-%02d\", idx);\n-  st = gst_structure_new_empty (stname);\n-  g_free (stname);\n-\n-  \/* Get caps *\/\n-  caps = gst_pad_get_current_caps (ps->pad);\n-  if (!caps) {\n-    GST_WARNING (\"Couldn't get negotiated caps from %s:%s\",\n-        GST_DEBUG_PAD_NAME (ps->pad));\n-    caps = gst_pad_query_caps (ps->pad, NULL);\n-  }\n-  if (caps) {\n-    GST_DEBUG (\"stream-%02d, got caps %\" GST_PTR_FORMAT, idx, caps);\n-    gst_structure_id_set (st, _CAPS_QUARK, GST_TYPE_CAPS, caps, NULL);\n-    gst_caps_unref (caps);\n-  }\n-  if (ps->tags)\n-    gst_structure_id_set (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, ps->tags, NULL);\n-  if (ps->toc)\n-    gst_structure_id_set (st, _TOC_QUARK, GST_TYPE_TOC, ps->toc, NULL);\n-  if (ps->stream_id)\n-    gst_structure_id_set (st, _STREAM_ID_QUARK, G_TYPE_STRING, ps->stream_id,\n-        NULL);\n-\n-  return st;\n-}\n-\n-\/* takes ownership of new_tags, may replace *taglist with a new one *\/\n-static void\n-gst_discoverer_merge_and_replace_tags (GstTagList ** taglist,\n-    GstTagList * new_tags)\n-{\n-  if (new_tags == NULL)\n-    return;\n-\n-  if (*taglist == NULL) {\n-    *taglist = new_tags;\n-    return;\n-  }\n-\n-  gst_tag_list_insert (*taglist, new_tags, GST_TAG_MERGE_REPLACE);\n-  gst_tag_list_unref (new_tags);\n-}\n-\n-static void\n-collect_common_information (GstDiscovererStreamInfo * info,\n-    const GstStructure * st)\n-{\n-  if (gst_structure_id_has_field (st, _TOC_QUARK)) {\n-    gst_structure_id_get (st, _TOC_QUARK, GST_TYPE_TOC, &info->toc, NULL);\n-  }\n-\n-  if (gst_structure_id_has_field (st, _STREAM_ID_QUARK)) {\n-    gst_structure_id_get (st, _STREAM_ID_QUARK, G_TYPE_STRING, &info->stream_id,\n-        NULL);\n-  }\n-}\n-\n-static GstDiscovererStreamInfo *\n-make_info (GstDiscovererStreamInfo * parent, GType type, GstCaps * caps)\n-{\n-  GstDiscovererStreamInfo *info;\n-\n-  if (parent)\n-    info = gst_discoverer_stream_info_ref (parent);\n-  else {\n-    info = g_object_new (type, NULL);\n-    if (caps)\n-      info->caps = gst_caps_ref (caps);\n-  }\n-  return info;\n-}\n-\n-\/* Parses a set of caps and tags in st and populates a GstDiscovererStreamInfo\n- * structure (parent, if !NULL, otherwise it allocates one)\n- *\/\n-static GstDiscovererStreamInfo *\n-collect_information (GstDiscoverer * dc, const GstStructure * st,\n-    GstDiscovererStreamInfo * parent)\n-{\n-  GstPad *srcpad;\n-  GstCaps *caps = NULL;\n-  GstStructure *caps_st;\n-  GstTagList *tags_st;\n-  const gchar *name;\n-  gint tmp, tmp2;\n-  guint utmp;\n-\n-  if (!st || (!gst_structure_id_has_field (st, _CAPS_QUARK)\n-          && !gst_structure_id_has_field (st, _ELEMENT_SRCPAD_QUARK))) {\n-    GST_WARNING (\"Couldn't find caps !\");\n-    return make_info (parent, GST_TYPE_DISCOVERER_STREAM_INFO, NULL);\n-  }\n-\n-  if (gst_structure_id_get (st, _ELEMENT_SRCPAD_QUARK, GST_TYPE_PAD, &srcpad,\n-          NULL)) {\n-    caps = gst_pad_get_current_caps (srcpad);\n-    gst_object_unref (srcpad);\n-  }\n-  if (!caps) {\n-    gst_structure_id_get (st, _CAPS_QUARK, GST_TYPE_CAPS, &caps, NULL);\n-  }\n-\n-  if (!caps || gst_caps_is_empty (caps) || gst_caps_is_any (caps)) {\n-    GST_WARNING (\"Couldn't find caps !\");\n-    if (caps)\n-      gst_caps_unref (caps);\n-    return make_info (parent, GST_TYPE_DISCOVERER_STREAM_INFO, NULL);\n-  }\n-\n-  caps_st = gst_caps_get_structure (caps, 0);\n-  name = gst_structure_get_name (caps_st);\n-\n-  if (g_str_has_prefix (name, \"audio\/\")) {\n-    GstDiscovererAudioInfo *info;\n-    const gchar *format_str;\n-    guint64 channel_mask;\n-\n-    info = (GstDiscovererAudioInfo *) make_info (parent,\n-        GST_TYPE_DISCOVERER_AUDIO_INFO, caps);\n-\n-    if (gst_structure_get_int (caps_st, \"rate\", &tmp))\n-      info->sample_rate = (guint) tmp;\n-\n-    if (gst_structure_get_int (caps_st, \"channels\", &tmp))\n-      info->channels = (guint) tmp;\n-\n-    if (gst_structure_get (caps_st, \"channel-mask\", GST_TYPE_BITMASK,\n-            &channel_mask, NULL)) {\n-      info->channel_mask = channel_mask;\n-    } else if (info->channels) {\n-      info->channel_mask = gst_audio_channel_get_fallback_mask (info->channels);\n-    }\n-\n-    \/* FIXME: we only want to extract depth if raw audio is what's in the\n-     * container (i.e. not if there is a decoder involved) *\/\n-    format_str = gst_structure_get_string (caps_st, \"format\");\n-    if (format_str != NULL) {\n-      const GstAudioFormatInfo *finfo;\n-      GstAudioFormat format;\n-\n-      format = gst_audio_format_from_string (format_str);\n-      finfo = gst_audio_format_get_info (format);\n-      if (finfo)\n-        info->depth = GST_AUDIO_FORMAT_INFO_DEPTH (finfo);\n-    }\n-\n-    if (gst_structure_id_has_field (st, _TAGS_QUARK)) {\n-      gst_structure_id_get (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, &tags_st, NULL);\n-      if (gst_tag_list_get_uint (tags_st, GST_TAG_BITRATE, &utmp) ||\n-          gst_tag_list_get_uint (tags_st, GST_TAG_NOMINAL_BITRATE, &utmp))\n-        info->bitrate = utmp;\n-\n-      if (gst_tag_list_get_uint (tags_st, GST_TAG_MAXIMUM_BITRATE, &utmp))\n-        info->max_bitrate = utmp;\n-\n-      \/* FIXME: Is it worth it to remove the tags we've parsed? *\/\n-      gst_discoverer_merge_and_replace_tags (&info->parent.tags, tags_st);\n-    }\n-\n-    collect_common_information (&info->parent, st);\n-\n-    if (!info->language && ((GstDiscovererStreamInfo *) info)->tags) {\n-      gchar *language;\n-      if (gst_tag_list_get_string (((GstDiscovererStreamInfo *) info)->tags,\n-              GST_TAG_LANGUAGE_CODE, &language)) {\n-        info->language = language;\n-      }\n-    }\n-\n-    gst_caps_unref (caps);\n-    return (GstDiscovererStreamInfo *) info;\n-\n-  } else if (g_str_has_prefix (name, \"video\/\") ||\n-      g_str_has_prefix (name, \"image\/\")) {\n-    GstDiscovererVideoInfo *info;\n-    const gchar *caps_str;\n-\n-    info = (GstDiscovererVideoInfo *) make_info (parent,\n-        GST_TYPE_DISCOVERER_VIDEO_INFO, caps);\n-\n-    if (gst_structure_get_int (caps_st, \"width\", &tmp))\n-      info->width = (guint) tmp;\n-    if (gst_structure_get_int (caps_st, \"height\", &tmp))\n-      info->height = (guint) tmp;\n-\n-    if (gst_structure_get_fraction (caps_st, \"framerate\", &tmp, &tmp2)) {\n-      info->framerate_num = (guint) tmp;\n-      info->framerate_denom = (guint) tmp2;\n-    } else {\n-      info->framerate_num = 0;\n-      info->framerate_denom = 1;\n-    }\n-\n-    if (gst_structure_get_fraction (caps_st, \"pixel-aspect-ratio\", &tmp, &tmp2)) {\n-      info->par_num = (guint) tmp;\n-      info->par_denom = (guint) tmp2;\n-    } else {\n-      info->par_num = 1;\n-      info->par_denom = 1;\n-    }\n-\n-    \/* FIXME: we only want to extract depth if raw video is what's in the\n-     * container (i.e. not if there is a decoder involved) *\/\n-    caps_str = gst_structure_get_string (caps_st, \"format\");\n-    if (caps_str != NULL) {\n-      const GstVideoFormatInfo *finfo;\n-      GstVideoFormat format;\n-\n-      format = gst_video_format_from_string (caps_str);\n-      finfo = gst_video_format_get_info (format);\n-      if (finfo)\n-        info->depth = finfo->bits * finfo->n_components;\n-    }\n-\n-    caps_str = gst_structure_get_string (caps_st, \"interlace-mode\");\n-    if (!caps_str || strcmp (caps_str, \"progressive\") == 0)\n-      info->interlaced = FALSE;\n-    else\n-      info->interlaced = TRUE;\n-\n-    if (gst_structure_id_has_field (st, _TAGS_QUARK)) {\n-      gst_structure_id_get (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, &tags_st, NULL);\n-      if (gst_tag_list_get_uint (tags_st, GST_TAG_BITRATE, &utmp) ||\n-          gst_tag_list_get_uint (tags_st, GST_TAG_NOMINAL_BITRATE, &utmp))\n-        info->bitrate = utmp;\n-\n-      if (gst_tag_list_get_uint (tags_st, GST_TAG_MAXIMUM_BITRATE, &utmp))\n-        info->max_bitrate = utmp;\n-\n-      \/* FIXME: Is it worth it to remove the tags we've parsed? *\/\n-      gst_discoverer_merge_and_replace_tags (&info->parent.tags, tags_st);\n-    }\n-\n-    collect_common_information (&info->parent, st);\n-\n-    gst_caps_unref (caps);\n-    return (GstDiscovererStreamInfo *) info;\n-\n-  } else if (is_subtitle_caps (caps)) {\n-    GstDiscovererSubtitleInfo *info;\n-\n-    info = (GstDiscovererSubtitleInfo *) make_info (parent,\n-        GST_TYPE_DISCOVERER_SUBTITLE_INFO, caps);\n-\n-    if (gst_structure_id_has_field (st, _TAGS_QUARK)) {\n-      const gchar *language;\n-\n-      gst_structure_id_get (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, &tags_st, NULL);\n-\n-      language = gst_structure_get_string (caps_st, GST_TAG_LANGUAGE_CODE);\n-      if (language)\n-        info->language = g_strdup (language);\n-\n-      \/* FIXME: Is it worth it to remove the tags we've parsed? *\/\n-      gst_discoverer_merge_and_replace_tags (&info->parent.tags, tags_st);\n-    }\n-\n-    collect_common_information (&info->parent, st);\n-\n-    if (!info->language && ((GstDiscovererStreamInfo *) info)->tags) {\n-      gchar *language;\n-      if (gst_tag_list_get_string (((GstDiscovererStreamInfo *) info)->tags,\n-              GST_TAG_LANGUAGE_CODE, &language)) {\n-        info->language = language;\n-      }\n-    }\n-\n-    gst_caps_unref (caps);\n-    return (GstDiscovererStreamInfo *) info;\n-\n-  } else {\n-    \/* None of the above - populate what information we can *\/\n-    GstDiscovererStreamInfo *info;\n-\n-    info = make_info (parent, GST_TYPE_DISCOVERER_STREAM_INFO, caps);\n-\n-    if (gst_structure_id_get (st, _TAGS_QUARK, GST_TYPE_TAG_LIST, &tags_st,\n-            NULL)) {\n-      gst_discoverer_merge_and_replace_tags (&info->tags, tags_st);\n-    }\n-\n-    collect_common_information (info, st);\n-\n-    gst_caps_unref (caps);\n-    return info;\n-  }\n-\n-}\n-\n-static GstStructure *\n-find_stream_for_node (GstDiscoverer * dc, const GstStructure * topology)\n-{\n-  GstPad *pad;\n-  GstPad *target_pad = NULL;\n-  GstStructure *st = NULL;\n-  PrivateStream *ps;\n-  guint i;\n-  GList *tmp;\n-\n-  if (!dc->priv->streams) {\n-    return NULL;\n-  }\n-\n-  if (!gst_structure_id_has_field (topology, _TOPOLOGY_PAD_QUARK)) {\n-    GST_DEBUG (\"Could not find pad for node %\" GST_PTR_FORMAT, topology);\n-    return NULL;\n-  }\n-\n-  gst_structure_id_get (topology, _TOPOLOGY_PAD_QUARK,\n-      GST_TYPE_PAD, &pad, NULL);\n-\n-  for (i = 0, tmp = dc->priv->streams; tmp; tmp = tmp->next, i++) {\n-    ps = (PrivateStream *) tmp->data;\n-\n-    target_pad = gst_ghost_pad_get_target (GST_GHOST_PAD (ps->pad));\n-    if (target_pad == NULL)\n-      continue;\n-    gst_object_unref (target_pad);\n-\n-    if (target_pad == pad)\n-      break;\n-  }\n-\n-  if (tmp)\n-    st = collect_stream_information (dc, ps, i);\n-\n-  gst_object_unref (pad);\n-\n-  return st;\n-}\n-\n-\/* this can fail due to {framed,parsed}={TRUE,FALSE} differences, thus we filter\n- * the parent *\/\n-static gboolean\n-child_is_same_stream (const GstCaps * _parent, const GstCaps * child)\n-{\n-  GstCaps *parent;\n-  gboolean res;\n-\n-  if (_parent == child)\n-    return TRUE;\n-  if (!_parent)\n-    return FALSE;\n-  if (!child)\n-    return FALSE;\n-\n-  parent = copy_and_clean_caps (_parent);\n-  res = gst_caps_can_intersect (parent, child);\n-  gst_caps_unref (parent);\n-  return res;\n-}\n-\n-\n-static gboolean\n-child_is_raw_stream (const GstCaps * parent, const GstCaps * child)\n-{\n-  const GstStructure *st1, *st2;\n-  const gchar *name1, *name2;\n-\n-  if (parent == child)\n-    return TRUE;\n-  if (!parent)\n-    return FALSE;\n-  if (!child)\n-    return FALSE;\n-\n-  st1 = gst_caps_get_structure (parent, 0);\n-  name1 = gst_structure_get_name (st1);\n-  st2 = gst_caps_get_structure (child, 0);\n-  name2 = gst_structure_get_name (st2);\n-\n-  if ((g_str_has_prefix (name1, \"audio\/\") &&\n-          g_str_has_prefix (name2, \"audio\/x-raw\")) ||\n-      ((g_str_has_prefix (name1, \"video\/\") ||\n-              g_str_has_prefix (name1, \"image\/\")) &&\n-          g_str_has_prefix (name2, \"video\/x-raw\"))) {\n-    \/* child is the \"raw\" sub-stream corresponding to parent *\/\n-    return TRUE;\n-  }\n-\n-  if (is_subtitle_caps (parent))\n-    return TRUE;\n-\n-  return FALSE;\n-}\n-\n-\/* If a parent is non-NULL, collected stream information will be appended to it\n- * (and where the information exists, it will be overridden)\n- *\/\n-static GstDiscovererStreamInfo *\n-parse_stream_topology (GstDiscoverer * dc, const GstStructure * topology,\n-    GstDiscovererStreamInfo * parent)\n-{\n-  GstDiscovererStreamInfo *res = NULL;\n-  GstCaps *caps = NULL;\n-  const GValue *nval = NULL;\n-\n-  GST_DEBUG (\"parsing: %\" GST_PTR_FORMAT, topology);\n-\n-  nval = gst_structure_get_value (topology, \"next\");\n-\n-  if (nval == NULL || GST_VALUE_HOLDS_STRUCTURE (nval)) {\n-    GstStructure *st = find_stream_for_node (dc, topology);\n-    gboolean add_to_list = TRUE;\n-\n-    if (st) {\n-      res = collect_information (dc, st, parent);\n-      gst_structure_free (st);\n-    } else {\n-      \/* Didn't find a stream structure, so let's just use the caps we have *\/\n-      res = collect_information (dc, topology, parent);\n-    }\n-\n-    if (nval == NULL) {\n-      \/* FIXME : aggregate with information from main streams *\/\n-      GST_DEBUG (\"Couldn't find 'next' ! might be the last entry\");\n-    } else {\n-      GstPad *srcpad;\n-\n-      st = (GstStructure *) gst_value_get_structure (nval);\n-\n-      GST_DEBUG (\"next is a structure %\" GST_PTR_FORMAT, st);\n-\n-      if (!parent)\n-        parent = res;\n-\n-      if (gst_structure_id_get (st, _ELEMENT_SRCPAD_QUARK, GST_TYPE_PAD,\n-              &srcpad, NULL)) {\n-        caps = gst_pad_get_current_caps (srcpad);\n-        gst_object_unref (srcpad);\n-      }\n-      if (!caps) {\n-        gst_structure_id_get (st, _CAPS_QUARK, GST_TYPE_CAPS, &caps, NULL);\n-      }\n-\n-      if (caps) {\n-        if (child_is_same_stream (parent->caps, caps)) {\n-          \/* We sometimes get an extra sub-stream from the parser. If this is\n-           * the case, we just replace the parent caps with this stream's caps\n-           * since they might contain more information *\/\n-          gst_caps_replace (&parent->caps, caps);\n-\n-          parse_stream_topology (dc, st, parent);\n-          add_to_list = FALSE;\n-        } else if (child_is_raw_stream (parent->caps, caps)) {\n-          \/* This is the \"raw\" stream corresponding to the parent. This\n-           * contains more information than the parent, tags etc. *\/\n-          parse_stream_topology (dc, st, parent);\n-          add_to_list = FALSE;\n-        } else {\n-          GstDiscovererStreamInfo *next = parse_stream_topology (dc, st, NULL);\n-          res->next = next;\n-          next->previous = res;\n-        }\n-        gst_caps_unref (caps);\n-      }\n-    }\n-\n-    if (add_to_list) {\n-      res->stream_number = dc->priv->current_info->stream_count++;\n-      dc->priv->current_info->stream_list =\n-          g_list_append (dc->priv->current_info->stream_list, res);\n-    } else {\n-      gst_discoverer_stream_info_unref (res);\n-    }\n-\n-  } else if (GST_VALUE_HOLDS_LIST (nval)) {\n-    guint i, len;\n-    GstDiscovererContainerInfo *cont;\n-    GstPad *srcpad;\n-\n-    if (gst_structure_id_get (topology, _ELEMENT_SRCPAD_QUARK, GST_TYPE_PAD,\n-            &srcpad, NULL)) {\n-      caps = gst_pad_get_current_caps (srcpad);\n-      gst_object_unref (srcpad);\n-    }\n-    if (!caps) {\n-      gst_structure_id_get (topology, _CAPS_QUARK, GST_TYPE_CAPS, &caps, NULL);\n-    }\n-\n-    if (!caps)\n-      GST_WARNING (\"Couldn't find caps !\");\n-\n-    len = gst_value_list_get_size (nval);\n-    GST_DEBUG (\"next is a list of %d entries\", len);\n-\n-    cont = (GstDiscovererContainerInfo *)\n-        g_object_new (GST_TYPE_DISCOVERER_CONTAINER_INFO, NULL);\n-    cont->parent.caps = caps;\n-    if (dc->priv->global_tags)\n-      cont->tags = gst_tag_list_ref (dc->priv->global_tags);\n-    res = (GstDiscovererStreamInfo *) cont;\n-\n-    for (i = 0; i < len; i++) {\n-      const GValue *subv = gst_value_list_get_value (nval, i);\n-      const GstStructure *subst = gst_value_get_structure (subv);\n-      GstDiscovererStreamInfo *substream;\n-\n-      GST_DEBUG (\"%d %\" GST_PTR_FORMAT, i, subst);\n-\n-      substream = parse_stream_topology (dc, subst, NULL);\n-\n-      substream->previous = res;\n-      cont->streams =\n-          g_list_append (cont->streams,\n-          gst_discoverer_stream_info_ref (substream));\n-    }\n-  }\n-\n-  return res;\n-}\n-\n-\/* Required DISCO_LOCK to be taken, and will release it *\/\n-static void\n-setup_next_uri_locked (GstDiscoverer * dc)\n-{\n-  if (dc->priv->pending_uris != NULL) {\n-    gboolean ready = _setup_locked (dc);\n-    DISCO_UNLOCK (dc);\n-\n-    if (!ready) {\n-      \/* Start timeout *\/\n-      if (dc->priv->processing)\n-        handle_current_async (dc);\n-    } else {\n-      g_idle_add_full (G_PRIORITY_DEFAULT_IDLE,\n-          (GSourceFunc) emit_discovererd_and_next, gst_object_ref (dc),\n-          gst_object_unref);\n-    }\n-  } else {\n-    \/* We're done ! *\/\n-    DISCO_UNLOCK (dc);\n-    g_signal_emit (dc, gst_discoverer_signals[SIGNAL_FINISHED], 0);\n-  }\n-}\n-\n-static GstDiscovererInfo *\n-_ensure_info_tags (GstDiscoverer * dc)\n-{\n-  GstDiscovererInfo *info = dc->priv->current_info;\n-\n-  if (dc->priv->all_tags)\n-    info->tags = dc->priv->all_tags;\n-  dc->priv->all_tags = NULL;\n-  return info;\n-}\n-\n-static void\n-emit_discovererd (GstDiscoverer * dc)\n-{\n-  GstDiscovererInfo *info = _ensure_info_tags (dc);\n-  GST_DEBUG_OBJECT (dc, \"Emitting 'discoverered' %s\", info->uri);\n-  g_signal_emit (dc, gst_discoverer_signals[SIGNAL_DISCOVERED], 0,\n-      info, dc->priv->current_error);\n-  \/* Clients get a copy of current_info since it is a boxed type *\/\n-  gst_discoverer_info_unref (dc->priv->current_info);\n-  dc->priv->current_info = NULL;\n-}\n-\n-static gboolean\n-emit_discovererd_and_next (GstDiscoverer * dc)\n-{\n-  emit_discovererd (dc);\n-\n-  DISCO_LOCK (dc);\n-  setup_next_uri_locked (dc);\n-\n-  return G_SOURCE_REMOVE;\n-}\n-\n-\/* Called when pipeline is pre-rolled *\/\n-static void\n-discoverer_collect (GstDiscoverer * dc)\n-{\n-  GST_DEBUG (\"Collecting information\");\n-\n-  \/* Stop the timeout handler if present *\/\n-  if (dc->priv->timeout_source) {\n-    g_source_destroy (dc->priv->timeout_source);\n-    g_source_unref (dc->priv->timeout_source);\n-    dc->priv->timeout_source = NULL;\n-  }\n-\n-  if (dc->priv->use_cache && dc->priv->current_info\n-      && dc->priv->current_info->from_cache) {\n-    GST_DEBUG_OBJECT (dc,\n-        \"Nothing to collect as the info was built from\" \" the cache\");\n-    return;\n-  }\n-\n-  if (dc->priv->streams) {\n-    \/* FIXME : Make this querying optional *\/\n-    if (TRUE) {\n-      GstElement *pipeline = (GstElement *) dc->priv->pipeline;\n-      gint64 dur;\n-\n-      GST_DEBUG (\"Attempting to query duration\");\n-\n-      if (gst_element_query_duration (pipeline, GST_FORMAT_TIME, &dur)) {\n-        GST_DEBUG (\"Got duration %\" GST_TIME_FORMAT, GST_TIME_ARGS (dur));\n-        dc->priv->current_info->duration = (guint64) dur;\n-      } else if (dc->priv->current_info->result != GST_DISCOVERER_ERROR) {\n-        GstStateChangeReturn sret;\n-        \/* Note: We don't switch to PLAYING if we previously saw an ERROR since\n-         * the state of various element isn't guaranteed anymore *\/\n-\n-        \/* Some parsers may not even return a rough estimate right away, e.g.\n-         * because they've only processed a single frame so far, so if we\n-         * didn't get a duration the first time, spin a bit and try again.\n-         * Ugly, but still better than making parsers or other elements return\n-         * completely bogus values. We need some API extensions to solve this\n-         * better. *\/\n-        GST_INFO (\"No duration yet, try a bit harder..\");\n-        \/* Make sure we don't add\/remove elements while switching to PLAYING itself *\/\n-        DISCO_LOCK (dc);\n-        sret = gst_element_set_state (pipeline, GST_STATE_PLAYING);\n-        DISCO_UNLOCK (dc);\n-        if (sret != GST_STATE_CHANGE_FAILURE) {\n-          int i;\n-\n-          for (i = 0; i < 2; ++i) {\n-            g_usleep (G_USEC_PER_SEC \/ 20);\n-            if (gst_element_query_duration (pipeline, GST_FORMAT_TIME, &dur)\n-                && dur > 0) {\n-              GST_DEBUG (\"Got duration %\" GST_TIME_FORMAT, GST_TIME_ARGS (dur));\n-              dc->priv->current_info->duration = (guint64) dur;\n-              break;\n-            }\n-          }\n-          gst_element_set_state (pipeline, GST_STATE_PAUSED);\n-        }\n-      }\n-\n-      if (dc->priv->seeking_query) {\n-        if (gst_element_query (pipeline, dc->priv->seeking_query)) {\n-          GstFormat format;\n-          gboolean seekable;\n-\n-          gst_query_parse_seeking (dc->priv->seeking_query, &format,\n-              &seekable, NULL, NULL);\n-          if (format == GST_FORMAT_TIME) {\n-            GST_DEBUG (\"Got seekable %d\", seekable);\n-            dc->priv->current_info->seekable = seekable;\n-          }\n-        }\n-      }\n-    }\n-\n-    if (dc->priv->target_state == GST_STATE_PAUSED)\n-      dc->priv->current_info->live = FALSE;\n-    else\n-      dc->priv->current_info->live = TRUE;\n-\n-    if (dc->priv->current_topology) {\n-      dc->priv->current_info->stream_count = 1;\n-      dc->priv->current_info->stream_info = parse_stream_topology (dc,\n-          dc->priv->current_topology, NULL);\n-      if (dc->priv->current_info->stream_info)\n-        dc->priv->current_info->stream_info->stream_number = 0;\n-    }\n-\n-    \/*\n-     * Images need some special handling. They do not have a duration, have\n-     * caps named image\/<foo> (th exception being MJPEG video which is also\n-     * type image\/jpeg), and should consist of precisely one stream (actually\n-     * initially there are 2, the image and raw stream, but we squash these\n-     * while parsing the stream topology). At some point, if we find that these\n-     * conditions are not sufficient, we can count the number of decoders and\n-     * parsers in the chain, and if there's more than one decoder, or any\n-     * parser at all, we should not mark this as an image.\n-     *\/\n-    if (dc->priv->current_info->duration == 0 &&\n-        dc->priv->current_info->stream_info != NULL &&\n-        dc->priv->current_info->stream_info->next == NULL) {\n-      GstDiscovererStreamInfo *stream_info;\n-      GstStructure *st;\n-\n-      stream_info = dc->priv->current_info->stream_info;\n-      st = gst_caps_get_structure (stream_info->caps, 0);\n-\n-      if (g_str_has_prefix (gst_structure_get_name (st), \"image\/\"))\n-        ((GstDiscovererVideoInfo *) stream_info)->is_image = TRUE;\n-    }\n-  }\n-\n-  if (dc->priv->use_cache && dc->priv->current_info->cachefile &&\n-      dc->priv->current_info->result == GST_DISCOVERER_OK) {\n-    GVariant *variant = gst_discoverer_info_to_variant (dc->priv->current_info,\n-        GST_DISCOVERER_SERIALIZE_ALL);\n-\n-    g_file_set_contents (dc->priv->current_info->cachefile,\n-        g_variant_get_data (variant), g_variant_get_size (variant), NULL);\n-    g_variant_unref (variant);\n-  }\n-\n-  if (dc->priv->async)\n-    emit_discovererd (dc);\n-}\n-\n-static void\n-get_async_cb (gpointer cb_data, GSource * source, GSourceFunc * func,\n-    gpointer * data)\n-{\n-  *func = (GSourceFunc) async_timeout_cb;\n-  *data = cb_data;\n-}\n-\n-\/* Wrapper since GSourceCallbackFuncs don't expect a return value from ref() *\/\n-static void\n-_void_g_object_ref (gpointer object)\n-{\n-  g_object_ref (G_OBJECT (object));\n-}\n-\n-static void\n-handle_current_async (GstDiscoverer * dc)\n-{\n-  GSource *source;\n-  static GSourceCallbackFuncs cb_funcs = {\n-    _void_g_object_ref,\n-    g_object_unref,\n-    get_async_cb,\n-  };\n-\n-  \/* Attach a timeout to the main context *\/\n-  source = g_timeout_source_new (dc->priv->timeout \/ GST_MSECOND);\n-  g_source_set_callback_indirect (source, g_object_ref (dc), &cb_funcs);\n-  g_source_attach (source, dc->priv->ctx);\n-  dc->priv->timeout_source = source;\n-}\n-\n-\n-\/* Returns TRUE if processing should stop *\/\n-static gboolean\n-handle_message (GstDiscoverer * dc, GstMessage * msg)\n-{\n-  gboolean done = FALSE;\n-  const gchar *dump_name = NULL;\n-\n-  GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), \"got a %s message\",\n-      GST_MESSAGE_TYPE_NAME (msg));\n-\n-  switch (GST_MESSAGE_TYPE (msg)) {\n-    case GST_MESSAGE_ERROR:{\n-      GError *gerr;\n-      gchar *debug;\n-\n-      gst_message_parse_error (msg, &gerr, &debug);\n-      GST_WARNING_OBJECT (GST_MESSAGE_SRC (msg),\n-          \"Got an error [debug:%s], [message:%s]\", debug, gerr->message);\n-      dc->priv->current_error = gerr;\n-      g_free (debug);\n-\n-      \/* We need to stop *\/\n-      done = TRUE;\n-      dump_name = \"gst-discoverer-error\";\n-\n-      \/* Don't override missing plugin result code for missing plugin errors *\/\n-      if (dc->priv->current_info->result != GST_DISCOVERER_MISSING_PLUGINS ||\n-          (!g_error_matches (gerr, GST_CORE_ERROR,\n-                  GST_CORE_ERROR_MISSING_PLUGIN) &&\n-              !g_error_matches (gerr, GST_STREAM_ERROR,\n-                  GST_STREAM_ERROR_CODEC_NOT_FOUND))) {\n-        GST_DEBUG (\"Setting result to ERROR\");\n-        dc->priv->current_info->result = GST_DISCOVERER_ERROR;\n-      }\n-    }\n-      break;\n-\n-    case GST_MESSAGE_WARNING:{\n-      GError *err;\n-      gchar *debug = NULL;\n-\n-      gst_message_parse_warning (msg, &err, &debug);\n-      GST_WARNING_OBJECT (GST_MESSAGE_SRC (msg),\n-          \"Got a warning [debug:%s], [message:%s]\", debug, err->message);\n-      g_clear_error (&err);\n-      g_free (debug);\n-      dump_name = \"gst-discoverer-warning\";\n-      break;\n-    }\n-\n-    case GST_MESSAGE_EOS:\n-      GST_DEBUG (\"Got EOS !\");\n-      done = TRUE;\n-      dump_name = \"gst-discoverer-eos\";\n-      break;\n-\n-    case GST_MESSAGE_APPLICATION:{\n-      const gchar *name =\n-          gst_structure_get_name (gst_message_get_structure (msg));\n-\n-      if (g_strcmp0 (name, \"DiscovererDone\"))\n-        break;\n-\n-      \/* Maybe we already reached the target state, and all we're waiting for\n-       * is either the subtitle tags or no_more_pads\n-       *\/\n-      DISCO_LOCK (dc);\n-      if (dc->priv->pending_subtitle_pads == 0)\n-        done = dc->priv->no_more_pads\n-            && dc->priv->target_state == dc->priv->current_state;\n-      DISCO_UNLOCK (dc);\n-\n-      if (done)\n-        dump_name = \"gst-discoverer-application-message\";\n-    }\n-      break;\n-\n-    case GST_MESSAGE_STATE_CHANGED:{\n-      GstState old, new, pending;\n-\n-      gst_message_parse_state_changed (msg, &old, &new, &pending);\n-      if (GST_MESSAGE_SRC (msg) == (GstObject *) dc->priv->pipeline) {\n-        DISCO_LOCK (dc);\n-        dc->priv->current_state = new;\n-\n-        if (dc->priv->pending_subtitle_pads == 0)\n-          done = dc->priv->no_more_pads\n-              && dc->priv->target_state == dc->priv->current_state;\n-        \/* Else we should get unblocked in GST_MESSAGE_APPLICATION *\/\n-\n-        DISCO_UNLOCK (dc);\n-      }\n-\n-      if (done)\n-        dump_name = \"gst-discoverer-target-state\";\n-    }\n-      break;\n-\n-    case GST_MESSAGE_ELEMENT:\n-    {\n-      GQuark sttype;\n-      const GstStructure *structure;\n-\n-      structure = gst_message_get_structure (msg);\n-      sttype = gst_structure_get_name_id (structure);\n-      GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg),\n-          \"structure %\" GST_PTR_FORMAT, structure);\n-      if (sttype == _MISSING_PLUGIN_QUARK) {\n-        GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg),\n-            \"Setting result to MISSING_PLUGINS\");\n-        dc->priv->current_info->result = GST_DISCOVERER_MISSING_PLUGINS;\n-        \/* FIXME 2.0 Remove completely the ->misc\n-         * Keep the old behaviour for now.\n-         *\/\n-        if (dc->priv->current_info->misc)\n-          gst_structure_free (dc->priv->current_info->misc);\n-        dc->priv->current_info->misc = gst_structure_copy (structure);\n-        g_ptr_array_add (dc->priv->current_info->missing_elements_details,\n-            gst_missing_plugin_message_get_installer_detail (msg));\n-      } else if (sttype == _STREAM_TOPOLOGY_QUARK) {\n-        if (dc->priv->current_topology)\n-          gst_structure_free (dc->priv->current_topology);\n-        dc->priv->current_topology = gst_structure_copy (structure);\n-      }\n-    }\n-      break;\n-\n-    case GST_MESSAGE_TAG:\n-    {\n-      GstTagList *tl, *tmp = NULL;\n-      GstTagScope scope;\n-\n-      gst_message_parse_tag (msg, &tl);\n-      scope = gst_tag_list_get_scope (tl);\n-      GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), \"Got tags %\" GST_PTR_FORMAT, tl);\n-\n-      tmp = gst_tag_list_merge (dc->priv->all_tags, tl, GST_TAG_MERGE_APPEND);\n-      if (dc->priv->all_tags)\n-        gst_tag_list_unref (dc->priv->all_tags);\n-      dc->priv->all_tags = tmp;\n-\n-      if (scope == GST_TAG_SCOPE_STREAM) {\n-        for (GList * curr = dc->priv->streams; curr; curr = curr->next) {\n-          PrivateStream *ps = (PrivateStream *) curr->data;\n-          if (GST_MESSAGE_SRC (msg) == GST_OBJECT_CAST (ps->sink)) {\n-            tmp = gst_tag_list_merge (ps->tags, tl, GST_TAG_MERGE_APPEND);\n-            if (ps->tags)\n-              gst_tag_list_unref (ps->tags);\n-            ps->tags = tmp;\n-            GST_DEBUG_OBJECT (ps->pad, \"tags %\" GST_PTR_FORMAT, ps->tags);\n-            break;\n-          }\n-        }\n-      } else {\n-        tmp =\n-            gst_tag_list_merge (dc->priv->global_tags, tl,\n-            GST_TAG_MERGE_APPEND);\n-        if (dc->priv->global_tags)\n-          gst_tag_list_unref (dc->priv->global_tags);\n-        dc->priv->global_tags = tmp;\n-      }\n-      gst_tag_list_unref (tl);\n-    }\n-      break;\n-    case GST_MESSAGE_TOC:\n-    {\n-      GstToc *tmp;\n-\n-      gst_message_parse_toc (msg, &tmp, NULL);\n-      GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), \"Got toc %\" GST_PTR_FORMAT, tmp);\n-      if (dc->priv->current_info->toc)\n-        gst_toc_unref (dc->priv->current_info->toc);\n-      dc->priv->current_info->toc = tmp;        \/* transfer ownership *\/\n-      GST_DEBUG_OBJECT (GST_MESSAGE_SRC (msg), \"Current info %p, toc %\"\n-          GST_PTR_FORMAT, dc->priv->current_info, tmp);\n-    }\n-      break;\n-\n-    default:\n-      break;\n-  }\n-\n-  if (dump_name != NULL) {\n-    \/* dump graph when done or for warnings *\/\n-    GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS (GST_BIN (dc->priv->pipeline),\n-        GST_DEBUG_GRAPH_SHOW_ALL, dump_name);\n-  }\n-  return done;\n-}\n-\n-static void\n-handle_current_sync (GstDiscoverer * dc)\n-{\n-  GTimer *timer;\n-  gdouble deadline = ((gdouble) dc->priv->timeout) \/ GST_SECOND;\n-  GstMessage *msg;\n-  gboolean done = FALSE;\n-\n-  timer = g_timer_new ();\n-  g_timer_start (timer);\n-\n-  do {\n-    \/* poll bus with timeout *\/\n-    \/* FIXME : make the timeout more fine-tuned *\/\n-    if ((msg = gst_bus_timed_pop (dc->priv->bus, GST_SECOND \/ 2))) {\n-      done = handle_message (dc, msg);\n-      gst_message_unref (msg);\n-    }\n-  } while (!done && (g_timer_elapsed (timer, NULL) < deadline));\n-\n-  \/* return result *\/\n-  if (!done) {\n-    GST_DEBUG (\"we timed out! Setting result to TIMEOUT\");\n-    dc->priv->current_info->result = GST_DISCOVERER_TIMEOUT;\n-  }\n-\n-  DISCO_LOCK (dc);\n-  dc->priv->processing = FALSE;\n-  DISCO_UNLOCK (dc);\n-\n-\n-  GST_DEBUG (\"Done\");\n-\n-  g_timer_stop (timer);\n-  g_timer_destroy (timer);\n-}\n-\n-static gchar *\n-_serialized_info_get_path (GstDiscoverer * dc, gchar * uri)\n-{\n-  GChecksum *cs = NULL;\n-  GStatBuf file_status;\n-  gchar *location = NULL, *res = NULL, *cache_dir = NULL, *tmp = NULL,\n-      *protocol = gst_uri_get_protocol (uri), hash_dirname[3] = \"00\";\n-  const gchar *checksum;\n-\n-  if (g_ascii_strcasecmp (protocol, \"file\") != 0) {\n-    GST_DEBUG_OBJECT (dc, \"Can not work with serialized DiscovererInfo\"\n-        \" on non local files - protocol: %s\", protocol);\n-\n-    goto done;\n-  }\n-\n-  location = gst_uri_get_location (uri);\n-  if (g_stat (location, &file_status) < 0) {\n-    GST_DEBUG_OBJECT (dc, \"Could not get stat for file: %s\", location);\n-\n-    goto done;\n-  }\n-\n-  tmp = g_strdup_printf (\"%s-%\" G_GSIZE_FORMAT \"-%\" G_GINT64_FORMAT,\n-      location, (gsize) file_status.st_size, (gint64) file_status.st_mtime);\n-  cs = g_checksum_new (G_CHECKSUM_SHA1);\n-  g_checksum_update (cs, (const guchar *) tmp, strlen (tmp));\n-  checksum = g_checksum_get_string (cs);\n-\n-  hash_dirname[0] = checksum[0];\n-  hash_dirname[1] = checksum[1];\n-  cache_dir =\n-      g_build_filename (g_get_user_cache_dir (), \"gstreamer-\" GST_API_VERSION,\n-      CACHE_DIRNAME, hash_dirname, NULL);\n-  g_mkdir_with_parents (cache_dir, 0777);\n-\n-  res = g_build_filename (cache_dir, &checksum[2], NULL);\n-\n-done:\n-  g_checksum_free (cs);\n-  g_free (cache_dir);\n-  g_free (location);\n-  g_free (tmp);\n-  g_free (protocol);\n-\n-  return res;\n-}\n-\n-static GstDiscovererInfo *\n-_get_info_from_cachefile (GstDiscoverer * dc, gchar * cachefile)\n-{\n-  gchar *data;\n-  gsize length;\n-\n-  if (g_file_get_contents (cachefile, &data, &length, NULL)) {\n-    GstDiscovererInfo *info = NULL;\n-    GVariant *variant =\n-        g_variant_new_from_data (G_VARIANT_TYPE (\"v\"), data, length,\n-        TRUE, NULL, NULL);\n-\n-    info = gst_discoverer_info_from_variant (variant);\n-    g_variant_unref (variant);\n-\n-    if (info) {\n-      info->cachefile = cachefile;\n-      info->from_cache = (gpointer) 0x01;\n-    } else {\n-      g_free (cachefile);\n-    }\n-\n-    GST_INFO_OBJECT (dc, \"Got info from cache: %p\", info);\n-    g_free (data);\n-\n-    return info;\n-  } else {\n-    g_free (cachefile);\n-  }\n-\n-  return NULL;\n-}\n-\n-static GstDiscovererInfo *\n-load_serialized_info (GstDiscoverer * dc, gchar * uri)\n-{\n-  GstDiscovererInfo *res = NULL;\n-\n-  if (dc->priv->use_cache) {\n-    gchar *cachefile = _serialized_info_get_path (dc, uri);\n-\n-    if (cachefile) {\n-      res = _get_info_from_cachefile (dc, cachefile);\n-    }\n-  }\n-\n-  return res;\n-}\n-\n-static gboolean\n-_setup_locked (GstDiscoverer * dc)\n-{\n-  GstStateChangeReturn ret;\n-  gchar *uri = (gchar *) dc->priv->pending_uris->data;\n-\n-  dc->priv->pending_uris =\n-      g_list_delete_link (dc->priv->pending_uris, dc->priv->pending_uris);\n-\n-\n-  GST_DEBUG (\"Setting up\");\n-\n-  g_signal_emit (dc, gst_discoverer_signals[SIGNAL_LOAD_SERIALIZED_INFO], 0,\n-      uri, &dc->priv->current_info);\n-  if (dc->priv->current_info) {\n-    \/* Make sure the URI is exactly what the user passed in *\/\n-    g_free (dc->priv->current_info->uri);\n-    dc->priv->current_info->uri = uri;\n-\n-    dc->priv->processing = FALSE;\n-    dc->priv->target_state = GST_STATE_NULL;\n-\n-    return TRUE;\n-  }\n-\n-  \/* Pop URI off the pending URI list *\/\n-  dc->priv->current_info =\n-      (GstDiscovererInfo *) g_object_new (GST_TYPE_DISCOVERER_INFO, NULL);\n-  if (dc->priv->use_cache)\n-    dc->priv->current_info->cachefile = _serialized_info_get_path (dc, uri);\n-  dc->priv->current_info->uri = uri;\n-\n-  \/* set uri on uridecodebin *\/\n-  g_object_set (dc->priv->uridecodebin, \"uri\", dc->priv->current_info->uri,\n-      NULL);\n-\n-  GST_DEBUG (\"Current is now %s\", dc->priv->current_info->uri);\n-\n-  dc->priv->processing = TRUE;\n-\n-  dc->priv->target_state = GST_STATE_PAUSED;\n-\n-  \/* set pipeline to PAUSED *\/\n-  DISCO_UNLOCK (dc);\n-  GST_DEBUG (\"Setting pipeline to PAUSED\");\n-  ret =\n-      gst_element_set_state ((GstElement *) dc->priv->pipeline,\n-      dc->priv->target_state);\n-\n-  if (ret == GST_STATE_CHANGE_NO_PREROLL) {\n-    GST_DEBUG (\"Source is live, switching to PLAYING\");\n-    dc->priv->target_state = GST_STATE_PLAYING;\n-    ret =\n-        gst_element_set_state ((GstElement *) dc->priv->pipeline,\n-        dc->priv->target_state);\n-  }\n-  DISCO_LOCK (dc);\n-\n-\n-  GST_DEBUG_OBJECT (dc, \"Pipeline going to PAUSED : %s\",\n-      gst_element_state_change_return_get_name (ret));\n-\n-  return FALSE;\n-}\n-\n-static void\n-discoverer_cleanup (GstDiscoverer * dc)\n-{\n-  GST_DEBUG (\"Cleaning up\");\n-\n-  DISCO_LOCK (dc);\n-  dc->priv->cleanup = TRUE;\n-  DISCO_UNLOCK (dc);\n-\n-  gst_bus_set_flushing (dc->priv->bus, TRUE);\n-\n-  DISCO_LOCK (dc);\n-  if (dc->priv->current_error) {\n-    g_error_free (dc->priv->current_error);\n-    DISCO_UNLOCK (dc);\n-    gst_element_set_state ((GstElement *) dc->priv->pipeline, GST_STATE_NULL);\n-  } else {\n-    DISCO_UNLOCK (dc);\n-  }\n-\n-  gst_element_set_state ((GstElement *) dc->priv->pipeline, GST_STATE_READY);\n-  gst_bus_set_flushing (dc->priv->bus, FALSE);\n-\n-  DISCO_LOCK (dc);\n-  dc->priv->current_error = NULL;\n-  if (dc->priv->current_topology) {\n-    gst_structure_free (dc->priv->current_topology);\n-    dc->priv->current_topology = NULL;\n-  }\n-\n-  dc->priv->current_info = NULL;\n-\n-  if (dc->priv->all_tags) {\n-    gst_tag_list_unref (dc->priv->all_tags);\n-    dc->priv->all_tags = NULL;\n-  }\n-\n-  if (dc->priv->global_tags) {\n-    gst_tag_list_unref (dc->priv->global_tags);\n-    dc->priv->global_tags = NULL;\n-  }\n-\n-  dc->priv->pending_subtitle_pads = 0;\n-\n-  dc->priv->current_state = GST_STATE_NULL;\n-  dc->priv->target_state = GST_STATE_NULL;\n-  dc->priv->no_more_pads = FALSE;\n-  dc->priv->cleanup = FALSE;\n-\n-\n-  \/* Try popping the next uri *\/\n-  if (dc->priv->async) {\n-    setup_next_uri_locked (dc);\n-  } else\n-    DISCO_UNLOCK (dc);\n-\n-  GST_DEBUG (\"out\");\n-}\n-\n-static void\n-discoverer_bus_cb (GstBus * bus, GstMessage * msg, GstDiscoverer * dc)\n-{\n-  if (dc->priv->processing) {\n-    if (handle_message (dc, msg)) {\n-      GST_DEBUG (\"Stopping asynchronously\");\n-      \/* Serialise with _event_probe() *\/\n-      DISCO_LOCK (dc);\n-      dc->priv->processing = FALSE;\n-      DISCO_UNLOCK (dc);\n-      discoverer_collect (dc);\n-      discoverer_cleanup (dc);\n-    }\n-  }\n-}\n-\n-static gboolean\n-async_timeout_cb (GstDiscoverer * dc)\n-{\n-  if (!g_source_is_destroyed (g_main_current_source ())) {\n-    GST_DEBUG (\"Setting result to TIMEOUT\");\n-    dc->priv->current_info->result = GST_DISCOVERER_TIMEOUT;\n-    dc->priv->processing = FALSE;\n-    discoverer_collect (dc);\n-    discoverer_cleanup (dc);\n-  }\n-  return FALSE;\n-}\n-\n-\/* If there is a pending URI, it will pop it from the list of pending\n- * URIs and start the discovery on it.\n- *\n- * Returns GST_DISCOVERER_OK if the next URI was popped and is processing,\n- * else a error flag.\n- *\/\n-static GstDiscovererResult\n-start_discovering (GstDiscoverer * dc)\n-{\n-  gboolean ready;\n-  GstDiscovererResult res = GST_DISCOVERER_OK;\n-\n-  GST_DEBUG (\"Starting\");\n-\n-  DISCO_LOCK (dc);\n-  if (dc->priv->pending_uris == NULL) {\n-    GST_WARNING (\"No URI to process\");\n-    res = GST_DISCOVERER_URI_INVALID;\n-    DISCO_UNLOCK (dc);\n-    goto beach;\n-  }\n-\n-  if (dc->priv->current_info != NULL) {\n-    GST_WARNING (\"Already processing a file\");\n-    res = GST_DISCOVERER_BUSY;\n-    DISCO_UNLOCK (dc);\n-    goto beach;\n-  }\n-\n-  g_signal_emit (dc, gst_discoverer_signals[SIGNAL_STARTING], 0);\n-\n-  ready = _setup_locked (dc);\n-\n-  DISCO_UNLOCK (dc);\n-\n-  if (dc->priv->async) {\n-    if (ready) {\n-      GSource *source;\n-\n-      source = g_idle_source_new ();\n-      g_source_set_callback (source,\n-          (GSourceFunc) emit_discovererd_and_next, gst_object_ref (dc),\n-          gst_object_unref);\n-      g_source_attach (source, dc->priv->ctx);\n-      goto beach;\n-    }\n-    if (dc->priv->processing)\n-      handle_current_async (dc);\n-  } else {\n-    if (!ready)\n-      handle_current_sync (dc);\n-  }\n-\n-beach:\n-  return res;\n-}\n-\n-\/* Serializing code *\/\n-\n-static GVariant *\n-_serialize_common_stream_info (GstDiscovererStreamInfo * sinfo,\n-    GstDiscovererSerializeFlags flags)\n-{\n-  GVariant *common;\n-  GVariant *nextv = NULL;\n-  gchar *caps_str = NULL, *tags_str = NULL, *misc_str = NULL;\n-\n-  if (sinfo->caps && (flags & GST_DISCOVERER_SERIALIZE_CAPS))\n-    caps_str = gst_caps_to_string (sinfo->caps);\n-\n-  if (sinfo->tags && (flags & GST_DISCOVERER_SERIALIZE_TAGS))\n-    tags_str = gst_tag_list_to_string (sinfo->tags);\n-\n-  if (sinfo->misc && (flags & GST_DISCOVERER_SERIALIZE_MISC))\n-    misc_str = gst_structure_to_string (sinfo->misc);\n-\n-\n-  if (sinfo->next)\n-    nextv = gst_discoverer_info_to_variant_recurse (sinfo->next, flags);\n-  else\n-    nextv = g_variant_new (\"()\");\n-\n-  common =\n-      g_variant_new (\"(msmsmsmsv)\", sinfo->stream_id, caps_str, tags_str,\n-      misc_str, nextv);\n-\n-  g_free (caps_str);\n-  g_free (tags_str);\n-  g_free (misc_str);\n-\n-  return common;\n-}\n-\n-static GVariant *\n-_serialize_info (GstDiscovererInfo * info, GstDiscovererSerializeFlags flags)\n-{\n-  gchar *tags_str = NULL;\n-  GVariant *ret;\n-\n-  if (info->tags && (flags & GST_DISCOVERER_SERIALIZE_TAGS))\n-    tags_str = gst_tag_list_to_string (info->tags);\n-\n-  ret =\n-      g_variant_new (\"(mstbmsb)\", info->uri, info->duration, info->seekable,\n-      tags_str, info->live);\n-\n-  g_free (tags_str);\n-\n-  return ret;\n-}\n-\n-static GVariant *\n-_serialize_audio_stream_info (GstDiscovererAudioInfo * ainfo)\n-{\n-  return g_variant_new (\"(uuuuumst)\",\n-      ainfo->channels,\n-      ainfo->sample_rate,\n-      ainfo->bitrate, ainfo->max_bitrate, ainfo->depth, ainfo->language,\n-      ainfo->channel_mask);\n-}\n-\n-static GVariant *\n-_serialize_video_stream_info (GstDiscovererVideoInfo * vinfo)\n-{\n-  return g_variant_new (\"(uuuuuuubuub)\",\n-      vinfo->width,\n-      vinfo->height,\n-      vinfo->depth,\n-      vinfo->framerate_num,\n-      vinfo->framerate_denom,\n-      vinfo->par_num,\n-      vinfo->par_denom,\n-      vinfo->interlaced, vinfo->bitrate, vinfo->max_bitrate, vinfo->is_image);\n-}\n-\n-static GVariant *\n-_serialize_subtitle_stream_info (GstDiscovererSubtitleInfo * sinfo)\n-{\n-  return g_variant_new (\"ms\", sinfo->language);\n-}\n-\n-static GVariant *\n-gst_discoverer_info_to_variant_recurse (GstDiscovererStreamInfo * sinfo,\n-    GstDiscovererSerializeFlags flags)\n-{\n-  GVariant *stream_variant = NULL;\n-  GVariant *common_stream_variant =\n-      _serialize_common_stream_info (sinfo, flags);\n-\n-  if (GST_IS_DISCOVERER_CONTAINER_INFO (sinfo)) {\n-    GList *tmp;\n-    GList *streams =\n-        gst_discoverer_container_info_get_streams (GST_DISCOVERER_CONTAINER_INFO\n-        (sinfo));\n-\n-    if (g_list_length (streams) > 0) {\n-      GVariantBuilder children;\n-      GVariant *child_variant;\n-      g_variant_builder_init (&children, G_VARIANT_TYPE_ARRAY);\n-\n-      for (tmp = streams; tmp; tmp = tmp->next) {\n-        child_variant =\n-            gst_discoverer_info_to_variant_recurse (tmp->data, flags);\n-        g_variant_builder_add (&children, \"v\", child_variant);\n-      }\n-      stream_variant =\n-          g_variant_new (\"(yvav)\", 'c', common_stream_variant, &children);\n-    } else {\n-      stream_variant =\n-          g_variant_new (\"(yvav)\", 'c', common_stream_variant, NULL);\n-    }\n-\n-    gst_discoverer_stream_info_list_free (streams);\n-  } else if (GST_IS_DISCOVERER_AUDIO_INFO (sinfo)) {\n-    GVariant *audio_stream_info =\n-        _serialize_audio_stream_info (GST_DISCOVERER_AUDIO_INFO (sinfo));\n-    stream_variant =\n-        g_variant_new (\"(yvv)\", 'a', common_stream_variant, audio_stream_info);\n-  } else if (GST_IS_DISCOVERER_VIDEO_INFO (sinfo)) {\n-    GVariant *video_stream_info =\n-        _serialize_video_stream_info (GST_DISCOVERER_VIDEO_INFO (sinfo));\n-    stream_variant =\n-        g_variant_new (\"(yvv)\", 'v', common_stream_variant, video_stream_info);\n-  } else if (GST_IS_DISCOVERER_SUBTITLE_INFO (sinfo)) {\n-    GVariant *subtitle_stream_info =\n-        _serialize_subtitle_stream_info (GST_DISCOVERER_SUBTITLE_INFO (sinfo));\n-    stream_variant =\n-        g_variant_new (\"(yvv)\", 's', common_stream_variant,\n-        subtitle_stream_info);\n-  } else {\n-    GVariant *nextv = NULL;\n-    GstDiscovererStreamInfo *ninfo =\n-        gst_discoverer_stream_info_get_next (sinfo);\n-\n-    if (ninfo) {\n-      nextv = gst_discoverer_info_to_variant_recurse (ninfo, flags);\n-      stream_variant =\n-          g_variant_new (\"(yvv)\", 'n', common_stream_variant,\n-          g_variant_new (\"v\", nextv));\n-    } else {\n-      stream_variant = g_variant_new (\"(yv)\", 'n', common_stream_variant);\n-    }\n-  }\n-\n-  return stream_variant;\n-}\n-\n-\/* Parsing code *\/\n-\n-#define GET_FROM_TUPLE(v, t, n, val) G_STMT_START{         \\\n-  GVariant *child = g_variant_get_child_value (v, n); \\\n-  *val = g_variant_get_##t(child); \\\n-  g_variant_unref (child); \\\n-}G_STMT_END\n-\n-static const gchar *\n-_maybe_get_string_from_tuple (GVariant * tuple, guint index)\n-{\n-  const gchar *ret = NULL;\n-  GVariant *maybe;\n-  GET_FROM_TUPLE (tuple, maybe, index, &maybe);\n-  if (maybe) {\n-    ret = g_variant_get_string (maybe, NULL);\n-    g_variant_unref (maybe);\n-  }\n-\n-  return ret;\n-}\n-\n-static void\n-_parse_info (GstDiscovererInfo * info, GVariant * info_variant)\n-{\n-  const gchar *str;\n-\n-  str = _maybe_get_string_from_tuple (info_variant, 0);\n-  if (str)\n-    info->uri = g_strdup (str);\n-\n-  GET_FROM_TUPLE (info_variant, uint64, 1, &info->duration);\n-  GET_FROM_TUPLE (info_variant, boolean, 2, &info->seekable);\n-\n-  str = _maybe_get_string_from_tuple (info_variant, 3);\n-  if (str)\n-    info->tags = gst_tag_list_new_from_string (str);\n-\n-  GET_FROM_TUPLE (info_variant, boolean, 4, &info->live);\n-}\n-\n-static void\n-_parse_common_stream_info (GstDiscovererStreamInfo * sinfo, GVariant * common,\n-    GstDiscovererInfo * info)\n-{\n-  const gchar *str;\n-\n-  str = _maybe_get_string_from_tuple (common, 0);\n-  if (str)\n-    sinfo->stream_id = g_strdup (str);\n-\n-  str = _maybe_get_string_from_tuple (common, 1);\n-  if (str)\n-    sinfo->caps = gst_caps_from_string (str);\n-\n-  str = _maybe_get_string_from_tuple (common, 2);\n-  if (str)\n-    sinfo->tags = gst_tag_list_new_from_string (str);\n-\n-  str = _maybe_get_string_from_tuple (common, 3);\n-  if (str)\n-    sinfo->misc = gst_structure_new_from_string (str);\n-\n-  if (g_variant_n_children (common) > 4) {\n-    GVariant *nextv;\n-\n-    GET_FROM_TUPLE (common, variant, 4, &nextv);\n-    if (g_variant_n_children (nextv) > 0) {\n-      sinfo->next = _parse_discovery (nextv, info);\n-    }\n-    g_variant_unref (nextv);\n-  }\n-\n-  g_variant_unref (common);\n-}\n-\n-static void\n-_parse_audio_stream_info (GstDiscovererAudioInfo * ainfo, GVariant * specific)\n-{\n-  const gchar *str;\n-\n-  GET_FROM_TUPLE (specific, uint32, 0, &ainfo->channels);\n-  GET_FROM_TUPLE (specific, uint32, 1, &ainfo->sample_rate);\n-  GET_FROM_TUPLE (specific, uint32, 2, &ainfo->bitrate);\n-  GET_FROM_TUPLE (specific, uint32, 3, &ainfo->max_bitrate);\n-  GET_FROM_TUPLE (specific, uint32, 4, &ainfo->depth);\n-\n-  str = _maybe_get_string_from_tuple (specific, 5);\n-\n-  if (str)\n-    ainfo->language = g_strdup (str);\n-\n-  GET_FROM_TUPLE (specific, uint64, 6, &ainfo->channel_mask);\n-\n-  g_variant_unref (specific);\n-}\n-\n-static void\n-_parse_video_stream_info (GstDiscovererVideoInfo * vinfo, GVariant * specific)\n-{\n-  GET_FROM_TUPLE (specific, uint32, 0, &vinfo->width);\n-  GET_FROM_TUPLE (specific, uint32, 1, &vinfo->height);\n-  GET_FROM_TUPLE (specific, uint32, 2, &vinfo->depth);\n-  GET_FROM_TUPLE (specific, uint32, 3, &vinfo->framerate_num);\n-  GET_FROM_TUPLE (specific, uint32, 4, &vinfo->framerate_denom);\n-  GET_FROM_TUPLE (specific, uint32, 5, &vinfo->par_num);\n-  GET_FROM_TUPLE (specific, uint32, 6, &vinfo->par_denom);\n-  GET_FROM_TUPLE (specific, boolean, 7, &vinfo->interlaced);\n-  GET_FROM_TUPLE (specific, uint32, 8, &vinfo->bitrate);\n-  GET_FROM_TUPLE (specific, uint32, 9, &vinfo->max_bitrate);\n-  GET_FROM_TUPLE (specific, boolean, 10, &vinfo->is_image);\n-\n-  g_variant_unref (specific);\n-}\n-\n-static void\n-_parse_subtitle_stream_info (GstDiscovererSubtitleInfo * sinfo,\n-    GVariant * specific)\n-{\n-  GVariant *maybe;\n-\n-  maybe = g_variant_get_maybe (specific);\n-  if (maybe) {\n-    sinfo->language = g_strdup (g_variant_get_string (maybe, NULL));\n-    g_variant_unref (maybe);\n-  }\n-\n-  g_variant_unref (specific);\n-}\n-\n-static GstDiscovererStreamInfo *\n-_parse_discovery (GVariant * variant, GstDiscovererInfo * info)\n-{\n-  gchar type;\n-  GVariant *common = g_variant_get_child_value (variant, 1);\n-  GVariant *specific = NULL;\n-  GstDiscovererStreamInfo *sinfo = NULL;\n-\n-  if (g_variant_n_children (variant) > 2)\n-    specific = g_variant_get_child_value (variant, 2);\n-\n-  GET_FROM_TUPLE (variant, byte, 0, &type);\n-  switch (type) {\n-    case 'c':\n-      sinfo = g_object_new (GST_TYPE_DISCOVERER_CONTAINER_INFO, NULL);\n-      break;\n-    case 'a':\n-      sinfo = g_object_new (GST_TYPE_DISCOVERER_AUDIO_INFO, NULL);\n-      _parse_audio_stream_info (GST_DISCOVERER_AUDIO_INFO (sinfo),\n-          g_variant_get_child_value (specific, 0));\n-      break;\n-    case 'v':\n-      sinfo = g_object_new (GST_TYPE_DISCOVERER_VIDEO_INFO, NULL);\n-      _parse_video_stream_info (GST_DISCOVERER_VIDEO_INFO (sinfo),\n-          g_variant_get_child_value (specific, 0));\n-      break;\n-    case 's':\n-      sinfo = g_object_new (GST_TYPE_DISCOVERER_SUBTITLE_INFO, NULL);\n-      _parse_subtitle_stream_info (GST_DISCOVERER_SUBTITLE_INFO (sinfo),\n-          g_variant_get_child_value (specific, 0));\n-      break;\n-    case 'n':\n-      sinfo = g_object_new (GST_TYPE_DISCOVERER_STREAM_INFO, NULL);\n-      break;\n-    default:\n-      GST_WARNING (\"Unexpected discoverer info type %d\", type);\n-      goto out;\n-  }\n-\n-  _parse_common_stream_info (sinfo, g_variant_get_child_value (common, 0),\n-      info);\n-\n-  if (!GST_IS_DISCOVERER_CONTAINER_INFO (sinfo)) {\n-    info->stream_list = g_list_append (info->stream_list, sinfo);\n-  }\n-\n-  if (!info->stream_info) {\n-    info->stream_info = sinfo;\n-  }\n-\n-  if (GST_IS_DISCOVERER_CONTAINER_INFO (sinfo)) {\n-    GVariantIter iter;\n-    GVariant *child;\n-\n-    GstDiscovererContainerInfo *cinfo = GST_DISCOVERER_CONTAINER_INFO (sinfo);\n-    g_variant_iter_init (&iter, specific);\n-    cinfo->tags = sinfo->tags;\n-    while ((child = g_variant_iter_next_value (&iter))) {\n-      GstDiscovererStreamInfo *child_info;\n-      child_info = _parse_discovery (g_variant_get_variant (child), info);\n-      if (child_info != NULL) {\n-        cinfo->streams =\n-            g_list_append (cinfo->streams,\n-            gst_discoverer_stream_info_ref (child_info));\n-      }\n-      g_variant_unref (child);\n-    }\n-  }\n-\n-out:\n-\n-  g_variant_unref (common);\n-  if (specific)\n-    g_variant_unref (specific);\n-  g_variant_unref (variant);\n-  return sinfo;\n-}\n-\n-\/**\n- * gst_discoverer_start:\n- * @discoverer: A #GstDiscoverer\n- *\n- * Allow asynchronous discovering of URIs to take place.\n- * A #GMainLoop must be available for #GstDiscoverer to properly work in\n- * asynchronous mode.\n- *\/\n-void\n-gst_discoverer_start (GstDiscoverer * discoverer)\n-{\n-  GSource *source;\n-  GMainContext *ctx = NULL;\n-\n-  g_return_if_fail (GST_IS_DISCOVERER (discoverer));\n-\n-  GST_DEBUG_OBJECT (discoverer, \"Starting...\");\n-\n-  if (discoverer->priv->async) {\n-    GST_DEBUG_OBJECT (discoverer, \"We were already started\");\n-    return;\n-  }\n-\n-  discoverer->priv->async = TRUE;\n-  discoverer->priv->running = TRUE;\n-\n-  ctx = g_main_context_get_thread_default ();\n-\n-  \/* Connect to bus signals *\/\n-  if (ctx == NULL)\n-    ctx = g_main_context_default ();\n-\n-  source = gst_bus_create_watch (discoverer->priv->bus);\n-  g_source_set_callback (source, (GSourceFunc) gst_bus_async_signal_func,\n-      NULL, NULL);\n-  g_source_attach (source, ctx);\n-  discoverer->priv->bus_source = source;\n-  discoverer->priv->ctx = g_main_context_ref (ctx);\n-\n-  start_discovering (discoverer);\n-  GST_DEBUG_OBJECT (discoverer, \"Started\");\n-}\n-\n-\/**\n- * gst_discoverer_stop:\n- * @discoverer: A #GstDiscoverer\n- *\n- * Stop the discovery of any pending URIs and clears the list of\n- * pending URIS (if any).\n- *\/\n-void\n-gst_discoverer_stop (GstDiscoverer * discoverer)\n-{\n-  g_return_if_fail (GST_IS_DISCOVERER (discoverer));\n-\n-  GST_DEBUG_OBJECT (discoverer, \"Stopping...\");\n-\n-  if (!discoverer->priv->async) {\n-    GST_DEBUG_OBJECT (discoverer,\n-        \"We were already stopped, or running synchronously\");\n-    return;\n-  }\n-\n-  DISCO_LOCK (discoverer);\n-  if (discoverer->priv->processing) {\n-    \/* We prevent any further processing by setting the bus to\n-     * flushing and setting the pipeline to READY.\n-     * _reset() will take care of the rest of the cleanup *\/\n-    if (discoverer->priv->bus)\n-      gst_bus_set_flushing (discoverer->priv->bus, TRUE);\n-    if (discoverer->priv->pipeline)\n-      gst_element_set_state ((GstElement *) discoverer->priv->pipeline,\n-          GST_STATE_READY);\n-  }\n-  discoverer->priv->running = FALSE;\n-  DISCO_UNLOCK (discoverer);\n-\n-  \/* Remove timeout handler *\/\n-  if (discoverer->priv->timeout_source) {\n-    g_source_destroy (discoverer->priv->timeout_source);\n-    g_source_unref (discoverer->priv->timeout_source);\n-    discoverer->priv->timeout_source = NULL;\n-  }\n-  \/* Remove signal watch *\/\n-  if (discoverer->priv->bus_source) {\n-    g_source_destroy (discoverer->priv->bus_source);\n-    g_source_unref (discoverer->priv->bus_source);\n-    discoverer->priv->bus_source = NULL;\n-  }\n-  \/* Unref main context *\/\n-  if (discoverer->priv->ctx) {\n-    g_main_context_unref (discoverer->priv->ctx);\n-    discoverer->priv->ctx = NULL;\n-  }\n-  discoverer_reset (discoverer);\n-\n-  discoverer->priv->async = FALSE;\n-\n-  GST_DEBUG_OBJECT (discoverer, \"Stopped\");\n-}\n-\n-\/**\n- * gst_discoverer_discover_uri_async:\n- * @discoverer: A #GstDiscoverer\n- * @uri: the URI to add.\n- *\n- * Appends the given @uri to the list of URIs to discoverer. The actual\n- * discovery of the @uri will only take place if gst_discoverer_start() has\n- * been called.\n- *\n- * A copy of @uri will be made internally, so the caller can safely g_free()\n- * afterwards.\n- *\n- * Returns: %TRUE if the @uri was successfully appended to the list of pending\n- * uris, else %FALSE\n- *\/\n-gboolean\n-gst_discoverer_discover_uri_async (GstDiscoverer * discoverer,\n-    const gchar * uri)\n-{\n-  gboolean can_run;\n-\n-  g_return_val_if_fail (GST_IS_DISCOVERER (discoverer), FALSE);\n-\n-  GST_DEBUG_OBJECT (discoverer, \"uri : %s\", uri);\n-\n-  DISCO_LOCK (discoverer);\n-  can_run = (discoverer->priv->pending_uris == NULL);\n-  discoverer->priv->pending_uris =\n-      g_list_append (discoverer->priv->pending_uris, g_strdup (uri));\n-  DISCO_UNLOCK (discoverer);\n-\n-  if (can_run)\n-    start_discovering (discoverer);\n-\n-  return TRUE;\n-}\n-\n-\n-\/* Synchronous mode *\/\n-\/**\n- * gst_discoverer_discover_uri:\n- * @discoverer: A #GstDiscoverer\n- * @uri: The URI to run on.\n- * @err: If an error occurred, this field will be filled in.\n- *\n- * Synchronously discovers the given @uri.\n- *\n- * A copy of @uri will be made internally, so the caller can safely g_free()\n- * afterwards.\n- *\n- * Returns: (transfer full): the result of the scanning. Can be %NULL if an\n- * error occurred.\n- *\/\n-GstDiscovererInfo *\n-gst_discoverer_discover_uri (GstDiscoverer * discoverer, const gchar * uri,\n-    GError ** err)\n-{\n-  GstDiscovererResult res = 0;\n-  GstDiscovererInfo *info;\n-\n-  g_return_val_if_fail (GST_IS_DISCOVERER (discoverer), NULL);\n-  g_return_val_if_fail (uri, NULL);\n-\n-  GST_DEBUG_OBJECT (discoverer, \"uri:%s\", uri);\n-\n-  DISCO_LOCK (discoverer);\n-  if (G_UNLIKELY (discoverer->priv->current_info)) {\n-    DISCO_UNLOCK (discoverer);\n-    GST_WARNING_OBJECT (discoverer, \"Already handling a uri\");\n-    if (err)\n-      *err = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_FAILED,\n-          \"Already handling a uri\");\n-    return NULL;\n-  }\n-\n-  discoverer->priv->pending_uris =\n-      g_list_append (discoverer->priv->pending_uris, g_strdup (uri));\n-  DISCO_UNLOCK (discoverer);\n-\n-  res = start_discovering (discoverer);\n-  discoverer_collect (discoverer);\n-\n-  \/* Get results *\/\n-  if (err) {\n-    if (discoverer->priv->current_error)\n-      *err = g_error_copy (discoverer->priv->current_error);\n-    else\n-      *err = NULL;\n-  }\n-  if (res != GST_DISCOVERER_OK) {\n-    GST_DEBUG (\"Setting result to %d (was %d)\", res,\n-        discoverer->priv->current_info->result);\n-    discoverer->priv->current_info->result = res;\n-  }\n-  info = _ensure_info_tags (discoverer);\n-\n-  discoverer_cleanup (discoverer);\n-\n-  return info;\n-}\n-\n-\/**\n- * gst_discoverer_new:\n- * @timeout: timeout per file, in nanoseconds. Allowed are values between\n- *     one second (#GST_SECOND) and one hour (3600 * #GST_SECOND)\n- * @err: a pointer to a #GError. can be %NULL\n- *\n- * Creates a new #GstDiscoverer with the provided timeout.\n- *\n- * Returns: (transfer full): The new #GstDiscoverer.\n- * If an error occurred when creating the discoverer, @err will be set\n- * accordingly and %NULL will be returned. If @err is set, the caller must\n- * free it when no longer needed using g_error_free().\n- *\/\n-GstDiscoverer *\n-gst_discoverer_new (GstClockTime timeout, GError ** err)\n-{\n-  GstDiscoverer *res;\n-\n-  g_return_val_if_fail (GST_CLOCK_TIME_IS_VALID (timeout), NULL);\n-\n-  res = g_object_new (GST_TYPE_DISCOVERER, \"timeout\", timeout, NULL);\n-  if (res->priv->uridecodebin == NULL) {\n-    if (err)\n-      *err = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_MISSING_PLUGIN,\n-          \"Couldn't create 'uridecodebin' element\");\n-    gst_object_unref (res);\n-    res = NULL;\n-  }\n-  return res;\n-}\n-\n-\/**\n- * gst_discoverer_info_to_variant:\n- * @info: A #GstDiscovererInfo\n- * @flags: A combination of #GstDiscovererSerializeFlags to specify\n- * what needs to be serialized.\n- *\n- * Serializes @info to a #GVariant that can be parsed again\n- * through gst_discoverer_info_from_variant().\n- *\n- * Note that any #GstToc (s) that might have been discovered will not be serialized\n- * for now.\n- *\n- * Returns: (transfer full): A newly-allocated #GVariant representing @info.\n- *\n- * Since: 1.6\n- *\/\n-GVariant *\n-gst_discoverer_info_to_variant (GstDiscovererInfo * info,\n-    GstDiscovererSerializeFlags flags)\n-{\n-  \/* FIXME: implement TOC support *\/\n-  GVariant *stream_variant;\n-  GVariant *variant, *info_variant;\n-  GstDiscovererStreamInfo *sinfo;\n-  GVariant *wrapper;\n-\n-  g_return_val_if_fail (GST_IS_DISCOVERER_INFO (info), NULL);\n-  g_return_val_if_fail (gst_discoverer_info_get_result (info) ==\n-      GST_DISCOVERER_OK\n-      || gst_discoverer_info_get_result (info) ==\n-      GST_DISCOVERER_MISSING_PLUGINS, NULL);\n-\n-  sinfo = gst_discoverer_info_get_stream_info (info);\n-  stream_variant = gst_discoverer_info_to_variant_recurse (sinfo, flags);\n-  info_variant = _serialize_info (info, flags);\n-\n-  variant = g_variant_new (\"(vv)\", info_variant, stream_variant);\n-\n-  \/* Returning a wrapper implies some small overhead, but simplifies\n-   * deserializing from bytes *\/\n-  wrapper = g_variant_new_variant (variant);\n-\n-  gst_discoverer_stream_info_unref (sinfo);\n-  return wrapper;\n-}\n-\n-\/**\n- * gst_discoverer_info_from_variant:\n- * @variant: A #GVariant to deserialize into a #GstDiscovererInfo.\n- *\n- * Parses a #GVariant as produced by gst_discoverer_info_to_variant()\n- * back to a #GstDiscovererInfo.\n- *\n- * Returns: (transfer full): A newly-allocated #GstDiscovererInfo.\n- *\n- * Since: 1.6\n- *\/\n-GstDiscovererInfo *\n-gst_discoverer_info_from_variant (GVariant * variant)\n-{\n-  GstDiscovererInfo *info = g_object_new (GST_TYPE_DISCOVERER_INFO, NULL);\n-  GVariant *info_variant = g_variant_get_variant (variant);\n-  GVariant *info_specific_variant;\n-  GVariant *wrapped;\n-\n-  GET_FROM_TUPLE (info_variant, variant, 0, &info_specific_variant);\n-  GET_FROM_TUPLE (info_variant, variant, 1, &wrapped);\n-\n-  _parse_info (info, info_specific_variant);\n-  _parse_discovery (wrapped, info);\n-  g_variant_unref (info_specific_variant);\n-  g_variant_unref (info_variant);\n-\n-  return info;\n-}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/gstdiscoverer.c","additions":0,"deletions":2775,"binary":false,"changes":2775,"status":"deleted"},{"patch":"@@ -1,449 +0,0 @@\n-\/* GStreamer\n- * Copyright (C) 2009 Edward Hervey <edward.hervey@collabora.co.uk>\n- *               2009 Nokia Corporation\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Library General Public\n- * License as published by the Free Software Foundation; either\n- * version 2 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Library General Public License for more details.\n- *\n- * You should have received a copy of the GNU Library General Public\n- * License along with this library; if not, write to the\n- * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,\n- * Boston, MA 02110-1301, USA.\n- *\/\n-\n-#ifndef _GST_DISCOVERER_H_\n-#define _GST_DISCOVERER_H_\n-\n-#include <gst\/gst.h>\n-#include <gst\/pbutils\/pbutils-prelude.h>\n-\n-G_BEGIN_DECLS\n-\n-#define GST_TYPE_DISCOVERER_STREAM_INFO \\\n-  (gst_discoverer_stream_info_get_type ())\n-#define GST_DISCOVERER_STREAM_INFO(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DISCOVERER_STREAM_INFO, GstDiscovererStreamInfo))\n-#define GST_IS_DISCOVERER_STREAM_INFO(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DISCOVERER_STREAM_INFO))\n-typedef struct _GstDiscovererStreamInfo GstDiscovererStreamInfo;\n-typedef GObjectClass GstDiscovererStreamInfoClass;\n-\n-GST_PBUTILS_API\n-GType gst_discoverer_stream_info_get_type (void);\n-\n-\/**\n- * GstDiscovererStreamInfo:\n- *\n- * Base structure for information concerning a media stream. Depending on the\n- * stream type, one can find more media-specific information in\n- * #GstDiscovererAudioInfo, #GstDiscovererVideoInfo, and\n- * #GstDiscovererContainerInfo.\n- *\n- * The #GstDiscovererStreamInfo represents the topology of the stream. Siblings\n- * can be iterated over with gst_discoverer_stream_info_get_next() and\n- * gst_discoverer_stream_info_get_previous(). Children (sub-streams) of a\n- * stream can be accessed using the #GstDiscovererContainerInfo API.\n- *\n- * As a simple example, if you run #GstDiscoverer on an AVI file with one audio\n- * and one video stream, you will get a #GstDiscovererContainerInfo\n- * corresponding to the AVI container, which in turn will have a\n- * #GstDiscovererAudioInfo sub-stream and a #GstDiscovererVideoInfo sub-stream\n- * for the audio and video streams respectively.\n- *\/\n-#define gst_discoverer_stream_info_ref(info) ((GstDiscovererStreamInfo*) g_object_ref((GObject*) info))\n-#define gst_discoverer_stream_info_unref(info) (g_object_unref((GObject*) info))\n-\n-GST_PBUTILS_API\n-GstDiscovererStreamInfo* gst_discoverer_stream_info_get_previous(GstDiscovererStreamInfo* info);\n-\n-GST_PBUTILS_API\n-GstDiscovererStreamInfo* gst_discoverer_stream_info_get_next(GstDiscovererStreamInfo* info);\n-\n-GST_PBUTILS_API\n-GstCaps*                 gst_discoverer_stream_info_get_caps(GstDiscovererStreamInfo* info);\n-\n-GST_PBUTILS_API\n-const GstTagList*        gst_discoverer_stream_info_get_tags(GstDiscovererStreamInfo* info);\n-\n-GST_PBUTILS_API\n-const GstToc*            gst_discoverer_stream_info_get_toc(GstDiscovererStreamInfo* info);\n-\n-GST_PBUTILS_API\n-const gchar*             gst_discoverer_stream_info_get_stream_id(GstDiscovererStreamInfo* info);\n-\n-GST_PBUTILS_DEPRECATED_FOR(gst_discoverer_info_get_missing_elements_installer_details)\n-const GstStructure*      gst_discoverer_stream_info_get_misc(GstDiscovererStreamInfo* info);\n-\n-GST_PBUTILS_API\n-const gchar *            gst_discoverer_stream_info_get_stream_type_nick(GstDiscovererStreamInfo* info);\n-\n-GST_PBUTILS_API\n-gint                     gst_discoverer_stream_info_get_stream_number(GstDiscovererStreamInfo *info);\n-\n-\/**\n- * GstDiscovererContainerInfo:\n- *\n- * #GstDiscovererStreamInfo specific to container streams.\n- *\/\n-#define GST_TYPE_DISCOVERER_CONTAINER_INFO \\\n-  (gst_discoverer_container_info_get_type ())\n-#define GST_DISCOVERER_CONTAINER_INFO(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DISCOVERER_CONTAINER_INFO, GstDiscovererContainerInfo))\n-#define GST_IS_DISCOVERER_CONTAINER_INFO(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DISCOVERER_CONTAINER_INFO))\n-typedef struct _GstDiscovererContainerInfo GstDiscovererContainerInfo;\n-typedef GObjectClass GstDiscovererContainerInfoClass;\n-\n-GST_PBUTILS_API\n-GType gst_discoverer_container_info_get_type (void);\n-\n-GST_PBUTILS_API\n-GList *gst_discoverer_container_info_get_streams(GstDiscovererContainerInfo *info);\n-\n-GST_PBUTILS_API\n-const GstTagList* gst_discoverer_container_info_get_tags(const GstDiscovererContainerInfo *info);\n-\n-\n-\/**\n- * GstDiscovererAudioInfo:\n- *\n- * #GstDiscovererStreamInfo specific to audio streams.\n- *\/\n-#define GST_TYPE_DISCOVERER_AUDIO_INFO \\\n-  (gst_discoverer_audio_info_get_type ())\n-#define GST_DISCOVERER_AUDIO_INFO(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DISCOVERER_AUDIO_INFO, GstDiscovererAudioInfo))\n-#define GST_IS_DISCOVERER_AUDIO_INFO(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DISCOVERER_AUDIO_INFO))\n-typedef struct _GstDiscovererAudioInfo GstDiscovererAudioInfo;\n-typedef GObjectClass GstDiscovererAudioInfoClass;\n-\n-GST_PBUTILS_API\n-GType gst_discoverer_audio_info_get_type (void);\n-\n-GST_PBUTILS_API\n-guint gst_discoverer_audio_info_get_channels(const GstDiscovererAudioInfo* info);\n-\n-GST_PBUTILS_API\n-guint64 gst_discoverer_audio_info_get_channel_mask(const GstDiscovererAudioInfo* info);\n-\n-GST_PBUTILS_API\n-guint gst_discoverer_audio_info_get_sample_rate(const GstDiscovererAudioInfo* info);\n-\n-GST_PBUTILS_API\n-guint gst_discoverer_audio_info_get_depth(const GstDiscovererAudioInfo* info);\n-\n-GST_PBUTILS_API\n-guint gst_discoverer_audio_info_get_bitrate(const GstDiscovererAudioInfo* info);\n-\n-GST_PBUTILS_API\n-guint gst_discoverer_audio_info_get_max_bitrate(const GstDiscovererAudioInfo* info);\n-\n-GST_PBUTILS_API\n-const gchar * gst_discoverer_audio_info_get_language(const GstDiscovererAudioInfo* info);\n-\n-\/**\n- * GstDiscovererVideoInfo:\n- *\n- * #GstDiscovererStreamInfo specific to video streams (this includes images).\n- *\/\n-#define GST_TYPE_DISCOVERER_VIDEO_INFO \\\n-  (gst_discoverer_video_info_get_type ())\n-#define GST_DISCOVERER_VIDEO_INFO(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DISCOVERER_VIDEO_INFO, GstDiscovererVideoInfo))\n-#define GST_IS_DISCOVERER_VIDEO_INFO(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DISCOVERER_VIDEO_INFO))\n-typedef struct _GstDiscovererVideoInfo GstDiscovererVideoInfo;\n-typedef GObjectClass GstDiscovererVideoInfoClass;\n-\n-GST_PBUTILS_API\n-GType gst_discoverer_video_info_get_type (void);\n-\n-GST_PBUTILS_API\n-guint           gst_discoverer_video_info_get_width(const GstDiscovererVideoInfo* info);\n-\n-GST_PBUTILS_API\n-guint           gst_discoverer_video_info_get_height(const GstDiscovererVideoInfo* info);\n-\n-GST_PBUTILS_API\n-guint           gst_discoverer_video_info_get_depth(const GstDiscovererVideoInfo* info);\n-\n-GST_PBUTILS_API\n-guint           gst_discoverer_video_info_get_framerate_num(const GstDiscovererVideoInfo* info);\n-\n-GST_PBUTILS_API\n-guint           gst_discoverer_video_info_get_framerate_denom(const GstDiscovererVideoInfo* info);\n-\n-GST_PBUTILS_API\n-guint           gst_discoverer_video_info_get_par_num(const GstDiscovererVideoInfo* info);\n-\n-GST_PBUTILS_API\n-guint           gst_discoverer_video_info_get_par_denom(const GstDiscovererVideoInfo* info);\n-\n-GST_PBUTILS_API\n-gboolean        gst_discoverer_video_info_is_interlaced(const GstDiscovererVideoInfo* info);\n-\n-GST_PBUTILS_API\n-guint           gst_discoverer_video_info_get_bitrate(const GstDiscovererVideoInfo* info);\n-\n-GST_PBUTILS_API\n-guint           gst_discoverer_video_info_get_max_bitrate(const GstDiscovererVideoInfo* info);\n-\n-GST_PBUTILS_API\n-gboolean        gst_discoverer_video_info_is_image(const GstDiscovererVideoInfo* info);\n-\n-\/**\n- * GstDiscovererSubtitleInfo:\n- *\n- * #GstDiscovererStreamInfo specific to subtitle streams (this includes text and\n- * image based ones).\n- *\/\n-#define GST_TYPE_DISCOVERER_SUBTITLE_INFO \\\n-  (gst_discoverer_subtitle_info_get_type ())\n-#define GST_DISCOVERER_SUBTITLE_INFO(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DISCOVERER_SUBTITLE_INFO, GstDiscovererSubtitleInfo))\n-#define GST_IS_DISCOVERER_SUBTITLE_INFO(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DISCOVERER_SUBTITLE_INFO))\n-typedef struct _GstDiscovererSubtitleInfo GstDiscovererSubtitleInfo;\n-typedef GObjectClass GstDiscovererSubtitleInfoClass;\n-\n-GST_PBUTILS_API\n-GType gst_discoverer_subtitle_info_get_type (void);\n-\n-GST_PBUTILS_API\n-const gchar *   gst_discoverer_subtitle_info_get_language(const GstDiscovererSubtitleInfo* info);\n-\n-\/**\n- * GstDiscovererResult:\n- * @GST_DISCOVERER_OK: The discovery was successful\n- * @GST_DISCOVERER_URI_INVALID: the URI is invalid\n- * @GST_DISCOVERER_ERROR: an error happened and the GError is set\n- * @GST_DISCOVERER_TIMEOUT: the discovery timed-out\n- * @GST_DISCOVERER_BUSY: the discoverer was already discovering a file\n- * @GST_DISCOVERER_MISSING_PLUGINS: Some plugins are missing for full discovery\n- *\n- * Result values for the discovery process.\n- *\/\n-typedef enum {\n-  GST_DISCOVERER_OK               = 0,\n-  GST_DISCOVERER_URI_INVALID      = 1,\n-  GST_DISCOVERER_ERROR            = 2,\n-  GST_DISCOVERER_TIMEOUT          = 3,\n-  GST_DISCOVERER_BUSY             = 4,\n-  GST_DISCOVERER_MISSING_PLUGINS  = 5\n-} GstDiscovererResult;\n-\n-\/**\n- * GstDiscovererSerializeFlags:\n- * @GST_DISCOVERER_SERIALIZE_BASIC: Serialize only basic information, excluding\n- * caps, tags and miscellaneous information\n- * @GST_DISCOVERER_SERIALIZE_CAPS: Serialize the caps for each stream\n- * @GST_DISCOVERER_SERIALIZE_TAGS: Serialize the tags for each stream\n- * @GST_DISCOVERER_SERIALIZE_MISC: Serialize miscellaneous information for each stream\n- * @GST_DISCOVERER_SERIALIZE_ALL: Serialize all the available info, including\n- * caps, tags and miscellaneous information\n- *\n- * You can use these flags to control what is serialized by\n- * gst_discoverer_info_to_variant()\n- *\n- * Since: 1.6\n- *\/\n-\n-typedef enum {\n-  GST_DISCOVERER_SERIALIZE_BASIC = 0,\n-  GST_DISCOVERER_SERIALIZE_CAPS  = 1 << 0,\n-  GST_DISCOVERER_SERIALIZE_TAGS  = 1 << 1,\n-  GST_DISCOVERER_SERIALIZE_MISC  = 1 << 2,\n-  GST_DISCOVERER_SERIALIZE_ALL   = GST_DISCOVERER_SERIALIZE_CAPS | GST_DISCOVERER_SERIALIZE_TAGS | GST_DISCOVERER_SERIALIZE_MISC\n-} GstDiscovererSerializeFlags;\n-\n-\/**\n- * GstDiscovererInfo:\n- *\n- * Structure containing the information of a URI analyzed by #GstDiscoverer.\n- *\/\n-typedef struct _GstDiscovererInfo GstDiscovererInfo;\n-\n-#define GST_TYPE_DISCOVERER_INFO \\\n-  (gst_discoverer_info_get_type ())\n-#define GST_DISCOVERER_INFO(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DISCOVERER_INFO, GstDiscovererInfo))\n-#define GST_IS_DISCOVERER_INFO(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DISCOVERER_INFO))\n-typedef GObjectClass GstDiscovererInfoClass;\n-\n-GST_PBUTILS_API\n-GType gst_discoverer_info_get_type (void);\n-\n-#define gst_discoverer_info_unref(info) (g_object_unref((GObject*)info))\n-#define gst_discoverer_info_ref(info) (g_object_ref((GObject*)info))\n-\n-GST_PBUTILS_API\n-GstDiscovererInfo*        gst_discoverer_info_copy (GstDiscovererInfo * ptr);\n-\n-GST_PBUTILS_API\n-const gchar*              gst_discoverer_info_get_uri(const GstDiscovererInfo* info);\n-\n-GST_PBUTILS_API\n-GstDiscovererResult       gst_discoverer_info_get_result(const GstDiscovererInfo* info);\n-\n-GST_PBUTILS_API\n-GstDiscovererStreamInfo*  gst_discoverer_info_get_stream_info(GstDiscovererInfo* info);\n-\n-GST_PBUTILS_API\n-GList*                    gst_discoverer_info_get_stream_list(GstDiscovererInfo* info);\n-\n-GST_PBUTILS_API\n-GstClockTime              gst_discoverer_info_get_duration(const GstDiscovererInfo* info);\n-\n-GST_PBUTILS_API\n-gboolean                  gst_discoverer_info_get_seekable(const GstDiscovererInfo* info);\n-\n-GST_PBUTILS_API\n-gboolean                  gst_discoverer_info_get_live(const GstDiscovererInfo* info);\n-\n-GST_PBUTILS_DEPRECATED_FOR(gst_discoverer_info_get_missing_elements_installer_details)\n-const GstStructure*       gst_discoverer_info_get_misc(const GstDiscovererInfo* info);\n-\n-GST_PBUTILS_DEPRECATED\n-const GstTagList*         gst_discoverer_info_get_tags(const GstDiscovererInfo* info);\n-GST_PBUTILS_API\n-const GstToc*             gst_discoverer_info_get_toc(const GstDiscovererInfo* info);\n-\n-GST_PBUTILS_API\n-const gchar**             gst_discoverer_info_get_missing_elements_installer_details(const GstDiscovererInfo* info);\n-\n-GST_PBUTILS_API\n-GList *                   gst_discoverer_info_get_streams (GstDiscovererInfo *info,\n-                 GType streamtype);\n-\n-GST_PBUTILS_API\n-GList *                   gst_discoverer_info_get_audio_streams (GstDiscovererInfo *info);\n-\n-GST_PBUTILS_API\n-GList *                   gst_discoverer_info_get_video_streams (GstDiscovererInfo *info);\n-\n-GST_PBUTILS_API\n-GList *                   gst_discoverer_info_get_subtitle_streams (GstDiscovererInfo *info);\n-\n-GST_PBUTILS_API\n-GList *                   gst_discoverer_info_get_container_streams (GstDiscovererInfo *info);\n-\n-GST_PBUTILS_API\n-GVariant *                gst_discoverer_info_to_variant (GstDiscovererInfo *info,\n-                                                          GstDiscovererSerializeFlags flags);\n-\n-GST_PBUTILS_API\n-GstDiscovererInfo *       gst_discoverer_info_from_variant (GVariant *variant);\n-\n-GST_PBUTILS_API\n-void                      gst_discoverer_stream_info_list_free (GList *infos);\n-\n-#define GST_TYPE_DISCOVERER \\\n-  (gst_discoverer_get_type())\n-#define GST_DISCOVERER(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DISCOVERER,GstDiscoverer))\n-#define GST_DISCOVERER_CLASS(klass) \\\n-  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DISCOVERER,GstDiscovererClass))\n-#define GST_IS_DISCOVERER(obj) \\\n-  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DISCOVERER))\n-#define GST_IS_DISCOVERER_CLASS(klass) \\\n-  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DISCOVERER))\n-\n-typedef struct _GstDiscoverer GstDiscoverer;\n-typedef struct _GstDiscovererClass GstDiscovererClass;\n-typedef struct _GstDiscovererPrivate GstDiscovererPrivate;\n-\n-\/**\n- * GstDiscoverer:\n- *\n- * The #GstDiscoverer structure.\n- **\/\n-struct _GstDiscoverer {\n-  GObject parent;\n-\n-  \/*< private >*\/\n-  GstDiscovererPrivate *priv;\n-\n-  gpointer _reserved[GST_PADDING];\n-};\n-\n-struct _GstDiscovererClass {\n-  GObjectClass parentclass;\n-\n-  \/* signals *\/\n-  void        (*finished)        (GstDiscoverer *discoverer);\n-  void        (*starting)        (GstDiscoverer *discoverer);\n-  void        (*discovered)      (GstDiscoverer *discoverer,\n-                                  GstDiscovererInfo *info,\n-          const GError *err);\n-  void        (*source_setup)    (GstDiscoverer *discoverer,\n-                                  GstElement *source);\n-  \/**\n-   * GstDiscovererClass::load_serialize_info:\n-   * @dc: the #GstDiscoverer\n-   * @uri: the uri to load the info from\n-   *\n-   * Loads the serialized info from the given uri.\n-   *\n-   * Returns: (transfer full): the #GstDiscovererInfo or %NULL if it could not be loaded\n-   *\n-   * Since: 1.24\n-   *\/\n-  GstDiscovererInfo *\n-  (*load_serialize_info)          (GstDiscoverer *dc,\n-                                   gchar *uri);\n-\n-  gpointer _reserved[GST_PADDING - 1];\n-};\n-\n-GST_PBUTILS_API\n-GType          gst_discoverer_get_type (void);\n-\n-GST_PBUTILS_API\n-GstDiscoverer *gst_discoverer_new (GstClockTime timeout, GError **err);\n-\n-\/* Asynchronous API *\/\n-\n-GST_PBUTILS_API\n-void           gst_discoverer_start (GstDiscoverer *discoverer);\n-\n-GST_PBUTILS_API\n-void           gst_discoverer_stop (GstDiscoverer *discoverer);\n-\n-GST_PBUTILS_API\n-gboolean       gst_discoverer_discover_uri_async (GstDiscoverer *discoverer,\n-              const gchar *uri);\n-\n-\/* Synchronous API *\/\n-\n-GST_PBUTILS_API\n-GstDiscovererInfo *\n-gst_discoverer_discover_uri (GstDiscoverer * discoverer,\n-           const gchar * uri,\n-           GError ** err);\n-\n-G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstDiscoverer, gst_object_unref)\n-\n-G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstDiscovererAudioInfo, gst_object_unref)\n-\n-G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstDiscovererContainerInfo, gst_object_unref)\n-\n-G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstDiscovererInfo, gst_object_unref)\n-\n-G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstDiscovererStreamInfo, gst_object_unref)\n-\n-G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstDiscovererSubtitleInfo, gst_object_unref)\n-\n-G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstDiscovererVideoInfo, gst_object_unref)\n-\n-G_END_DECLS\n-\n-#endif \/* _GST_DISCOVERER_H *\/\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/gstdiscoverer.h","additions":0,"deletions":449,"binary":false,"changes":449,"status":"deleted"},{"patch":"@@ -16,0 +16,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -17,0 +18,1 @@\n+#endif \/\/ GSTREAMER_LITE\n@@ -44,0 +46,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -83,1 +86,0 @@\n-#ifndef GSTREAMER_LITE\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/pbutils-enumtypes.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -16,0 +16,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -23,0 +24,1 @@\n+#endif \/\/ GSTREAMER_LITE\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/pbutils-enumtypes.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -21,0 +21,1 @@\n+#ifndef GSTREAMER_LITE\n@@ -106,0 +107,1 @@\n+#endif \/\/ GSTREAMER_LITE\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/pbutils-private.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include <gst\/pbutils\/gstdiscoverer.h>\n@@ -35,0 +34,1 @@\n+#include <gst\/pbutils\/gstdiscoverer.h>\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/pbutils\/pbutils.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-static gboolean id3v2_frames_to_tag_list (ID3TagsWorking * work, guint size);\n+static gboolean id3v2_frames_to_tag_list (ID3TagsWorking * work);\n@@ -261,1 +261,1 @@\n-  id3v2_frames_to_tag_list (&work, work.hdr.frame_data_size);\n+  id3v2_frames_to_tag_list (&work);\n@@ -443,1 +443,1 @@\n-id3v2_frames_to_tag_list (ID3TagsWorking * work, guint size)\n+id3v2_frames_to_tag_list (ID3TagsWorking * work)\n@@ -449,0 +449,5 @@\n+    if (work->hdr.frame_data_size < 4) {\n+      GST_DEBUG (\"Tag has no extended header data. Broken tag\");\n+      return FALSE;\n+    }\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/tag\/id3v2.c","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -271,2 +271,5 @@\n-  \/* set caps *\/\n-  g_object_set (src, \"caps\", from_caps, NULL);\n+  \/* set input and output caps *\/\n+  g_object_set (src, \"caps\", from_caps, \"emit-signals\", TRUE,\n+      \"format\", GST_FORMAT_TIME, NULL);\n+  g_object_set (sink, \"caps\", to_caps, \"emit-signals\", TRUE, NULL);\n+\n@@ -284,1 +287,0 @@\n-  g_object_set (sink, \"caps\", to_caps, NULL);\n@@ -351,3 +353,0 @@\n-  g_object_set (src, \"emit-signals\", TRUE, NULL);\n-  g_object_set (sink, \"emit-signals\", TRUE, NULL);\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst-libs\/gst\/video\/convertframe.c","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -398,0 +398,2 @@\n+  GST_OBJECT_LOCK (this);\n+\n@@ -414,0 +416,1 @@\n+  GST_OBJECT_UNLOCK (this);\n@@ -769,2 +772,2 @@\n-gst_audio_convert_set_caps (GstBaseTransform * base, GstCaps * incaps,\n-    GstCaps * outcaps)\n+gst_audio_convert_ensure_converter (GstBaseTransform * base,\n+    GstAudioInfo * in_info, GstAudioInfo * out_info)\n@@ -773,3 +776,0 @@\n-  GstAudioInfo in_info;\n-  GstAudioInfo out_info;\n-  gboolean in_place;\n@@ -777,0 +777,2 @@\n+  gboolean in_place;\n+  gboolean ret = TRUE;\n@@ -778,3 +780,1 @@\n-  GST_DEBUG_OBJECT (base, \"incaps %\" GST_PTR_FORMAT \", outcaps %\"\n-      GST_PTR_FORMAT, incaps, outcaps);\n-\n+  GST_OBJECT_LOCK (this);\n@@ -782,2 +782,2 @@\n-    gst_audio_converter_free (this->convert);\n-    this->convert = NULL;\n+    GST_TRACE_OBJECT (this, \"We already have a converter\");\n+    goto done;\n@@ -786,4 +786,5 @@\n-  if (!gst_audio_info_from_caps (&in_info, incaps))\n-    goto invalid_in;\n-  if (!gst_audio_info_from_caps (&out_info, outcaps))\n-    goto invalid_out;\n+  if (!GST_AUDIO_INFO_IS_VALID (in_info) || !GST_AUDIO_INFO_IS_VALID (out_info)) {\n+    GST_LOG_OBJECT (this,\n+        \"No format information (yet), not creating converter\");\n+    goto done;\n+  }\n@@ -799,1 +800,1 @@\n-  if (this->mix_matrix_is_set)\n+  if (this->mix_matrix_is_set) {\n@@ -803,1 +804,4 @@\n-  this->convert = gst_audio_converter_new (0, &in_info, &out_info, config);\n+    this->convert = gst_audio_converter_new (0, in_info, out_info, config);\n+  } else {\n+    this->convert = gst_audio_converter_new (0, in_info, out_info, config);\n+  }\n@@ -809,0 +813,2 @@\n+  GST_OBJECT_UNLOCK (this);\n+\n@@ -814,2 +820,1 @@\n-  this->in_info = in_info;\n-  this->out_info = out_info;\n+  GST_OBJECT_LOCK (this);\n@@ -817,1 +822,41 @@\n-  return TRUE;\n+done:\n+  GST_OBJECT_UNLOCK (this);\n+  return ret;\n+\n+no_converter:\n+  GST_ERROR_OBJECT (this, \"Failed to make converter\");\n+  ret = FALSE;\n+  goto done;\n+}\n+\n+static gboolean\n+gst_audio_convert_set_caps (GstBaseTransform * base, GstCaps * incaps,\n+    GstCaps * outcaps)\n+{\n+  GstAudioConvert *this = GST_AUDIO_CONVERT (base);\n+  GstAudioInfo in_info;\n+  GstAudioInfo out_info;\n+  gboolean ret;\n+\n+  GST_DEBUG_OBJECT (base, \"incaps %\" GST_PTR_FORMAT \", outcaps %\"\n+      GST_PTR_FORMAT, incaps, outcaps);\n+\n+  if (this->convert) {\n+    gst_audio_converter_free (this->convert);\n+    this->convert = NULL;\n+  }\n+\n+  if (!gst_audio_info_from_caps (&in_info, incaps))\n+    goto invalid_in;\n+  if (!gst_audio_info_from_caps (&out_info, outcaps))\n+    goto invalid_out;\n+\n+  ret = gst_audio_convert_ensure_converter (base, &in_info, &out_info);\n+\n+  if (ret) {\n+    this->in_info = in_info;\n+    this->out_info = out_info;\n+  }\n+\n+done:\n+  return ret;\n@@ -823,1 +868,2 @@\n-    return FALSE;\n+    ret = FALSE;\n+    goto done;\n@@ -828,6 +874,2 @@\n-    return FALSE;\n-  }\n-no_converter:\n-  {\n-    GST_ERROR_OBJECT (base, \"could not make converter\");\n-    return FALSE;\n+    ret = FALSE;\n+    goto done;\n@@ -852,0 +894,7 @@\n+  gst_audio_convert_ensure_converter (base, &this->in_info, &this->out_info);\n+\n+  if (!this->convert) {\n+    GST_ERROR_OBJECT (this, \"No audio converter at transform time\");\n+    return GST_FLOW_ERROR;\n+  }\n+\n@@ -1001,0 +1050,68 @@\n+static void\n+gst_audio_convert_set_mix_matrix (GstAudioConvert * this, const GValue * value)\n+{\n+  gboolean mix_matrix_was_set;\n+  GstAudioConverter *old_converter;\n+  GValue old_mix_matrix = G_VALUE_INIT;\n+  gboolean restore = FALSE;\n+\n+  g_value_init (&old_mix_matrix, GST_TYPE_ARRAY);\n+\n+  GST_OBJECT_LOCK (this);\n+\n+  mix_matrix_was_set = this->mix_matrix_is_set;\n+  old_converter = this->convert;\n+  if (mix_matrix_was_set) {\n+    g_value_copy (&this->mix_matrix, &old_mix_matrix);\n+  }\n+\n+  if (this->convert) {\n+    this->convert = NULL;\n+  }\n+\n+  if (!gst_value_array_get_size (value)) {\n+    g_value_copy (value, &this->mix_matrix);\n+    this->mix_matrix_is_set = TRUE;\n+  } else {\n+    const GValue *first_row = gst_value_array_get_value (value, 0);\n+\n+    if (gst_value_array_get_size (first_row)) {\n+      g_value_copy (value, &this->mix_matrix);\n+      this->mix_matrix_is_set = TRUE;\n+    } else {\n+      g_warning (\"Empty mix matrix's first row.\");\n+      restore = TRUE;\n+      goto done;\n+    }\n+  }\n+\n+  GST_OBJECT_UNLOCK (this);\n+\n+  \/* We need to call this here already because gst_audio_convert_transform\n+   * might never get called otherwise if the element was set to passthrough.\n+   *\n+   * In any case if this succeeds we still want to reconfigure the sink to give\n+   * upstream a chance to renegotiate channels.\n+   *\/\n+  if (gst_audio_convert_ensure_converter (GST_BASE_TRANSFORM (this),\n+          &this->in_info, &this->out_info)) {\n+    gst_base_transform_reconfigure_sink (GST_BASE_TRANSFORM (this));\n+  } else {\n+    g_warning (\"Cannot build converter with this mix matrix\");\n+    restore = TRUE;\n+    goto done;\n+  }\n+\n+done:\n+  if (restore) {\n+    this->mix_matrix_is_set = mix_matrix_was_set;\n+    if (mix_matrix_was_set) {\n+      g_value_copy (&old_mix_matrix, &this->mix_matrix);\n+    }\n+    this->convert = old_converter;\n+  } else if (old_converter) {\n+    gst_audio_converter_free (old_converter);\n+  }\n+  g_value_unset (&old_mix_matrix);\n+}\n+\n@@ -1018,17 +1135,1 @@\n-      if (!gst_value_array_get_size (value)) {\n-        g_value_copy (value, &this->mix_matrix);\n-        this->mix_matrix_is_set = TRUE;\n-      } else {\n-        const GValue *first_row = gst_value_array_get_value (value, 0);\n-\n-        if (gst_value_array_get_size (first_row)) {\n-          g_value_copy (value, &this->mix_matrix);\n-          this->mix_matrix_is_set = TRUE;\n-\n-          \/* issue a reconfigure upstream *\/\n-          gst_base_transform_reconfigure_sink (GST_BASE_TRANSFORM (this));\n-        } else {\n-          g_warning (\"Empty mix matrix's first row.\");\n-          this->mix_matrix_is_set = FALSE;\n-        }\n-      }\n+      gst_audio_convert_set_mix_matrix (this, value);\n@@ -1059,0 +1160,1 @@\n+      GST_OBJECT_LOCK (object);\n@@ -1061,0 +1163,1 @@\n+      GST_OBJECT_UNLOCK (object);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-base\/gst\/audioconvert\/gstaudioconvert.c","additions":146,"deletions":43,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -3433,0 +3433,1 @@\n+  guint new_n_samples;\n@@ -3438,2 +3439,2 @@\n-  GST_LOG_OBJECT (qtdemux, \"parsing trun track-id %d; \"\n-      \"default dur %d, size %d, flags 0x%x, base offset %\" G_GINT64_FORMAT \", \"\n+  GST_LOG_OBJECT (qtdemux, \"parsing trun track-id %u; \"\n+      \"default dur %u, size %u, flags 0x%x, base offset %\" G_GINT64_FORMAT \", \"\n@@ -3478,1 +3479,1 @@\n-    GST_LOG_OBJECT (qtdemux, \"trun data offset %d\", data_offset);\n+    GST_LOG_OBJECT (qtdemux, \"trun data offset %u\", data_offset);\n@@ -3500,1 +3501,1 @@\n-  GST_LOG_OBJECT (qtdemux, \"trun offset %d, flags 0x%x, entries %d\",\n+  GST_LOG_OBJECT (qtdemux, \"trun offset %u, flags 0x%x, entries %u\",\n@@ -3544,2 +3545,2 @@\n-  if (stream->n_samples + samples_count >=\n-      QTDEMUX_MAX_SAMPLE_INDEX_SIZE \/ sizeof (QtDemuxSample))\n+  if (!g_uint_checked_add (&new_n_samples, stream->n_samples, samples_count) ||\n+      new_n_samples >= QTDEMUX_MAX_SAMPLE_INDEX_SIZE \/ sizeof (QtDemuxSample))\n@@ -3549,3 +3550,2 @@\n-      stream->n_samples + samples_count, (guint) sizeof (QtDemuxSample),\n-      (stream->n_samples + samples_count) *\n-      sizeof (QtDemuxSample) \/ (1024.0 * 1024.0));\n+      new_n_samples, (guint) sizeof (QtDemuxSample),\n+      (new_n_samples) * sizeof (QtDemuxSample) \/ (1024.0 * 1024.0));\n@@ -3560,1 +3560,1 @@\n-        stream->n_samples + samples_count);\n+        new_n_samples);\n@@ -3710,2 +3710,2 @@\n-    GST_WARNING_OBJECT (qtdemux, \"failed to allocate %d samples\",\n-        stream->n_samples);\n+    GST_WARNING_OBJECT (qtdemux, \"failed to allocate %u + %u samples\",\n+        stream->n_samples, samples_count);\n@@ -3716,2 +3716,3 @@\n-    GST_WARNING_OBJECT (qtdemux, \"not allocating index of %d samples, would \"\n-        \"be larger than %uMB (broken file?)\", stream->n_samples,\n+    GST_WARNING_OBJECT (qtdemux,\n+        \"not allocating index of %u + %u samples, would \"\n+        \"be larger than %uMB (broken file?)\", stream->n_samples, samples_count,\n@@ -3902,1 +3903,1 @@\n-    GstStructure * default_properties, GPtrArray * tack_properties_array,\n+    GstStructure * default_properties, GPtrArray * track_properties_array,\n@@ -3961,1 +3962,1 @@\n-      if (index < group_properties_array->len)\n+      if (group_properties_array && index < group_properties_array->len)\n@@ -3968,2 +3969,2 @@\n-      if (index < tack_properties_array->len)\n-        properties = g_ptr_array_index (tack_properties_array, index);\n+      if (track_properties_array && index < track_properties_array->len)\n+        properties = g_ptr_array_index (track_properties_array, index);\n@@ -4520,0 +4521,5 @@\n+      if (!info) {\n+        GST_ERROR_OBJECT (qtdemux, \"Have no valid protection scheme info\");\n+        goto fail;\n+      }\n+\n@@ -5282,1 +5288,4 @@\n-    qtdemux_prepare_streams (qtdemux);\n+    ret = qtdemux_prepare_streams (qtdemux);\n+    if (ret != GST_FLOW_OK)\n+      return ret;\n+\n@@ -5286,0 +5295,2 @@\n+    if (ret != GST_FLOW_OK)\n+      return ret;\n@@ -6221,0 +6232,5 @@\n+  \/* Strip off any leftover odd bytes and assume everything before is valid *\/\n+  if (ccpair_size % 2 != 0) {\n+    ccpair_size -= 1;\n+  }\n+\n@@ -6254,1 +6270,1 @@\n-  if (G_UNLIKELY (atom_length > size || atom_length == 8))\n+  if (G_UNLIKELY (atom_length > size || atom_length <= 8))\n@@ -6294,1 +6310,1 @@\n-          } else {\n+          } else if (fourcc == FOURCC_cdt2) {\n@@ -6302,0 +6318,4 @@\n+          } else {\n+            GST_WARNING_OBJECT (stream->pad,\n+                \"Unknown second data atom (%\" GST_FOURCC_FORMAT \") for CEA608\",\n+                GST_FOURCC_ARGS (fourcc));\n@@ -8188,1 +8208,4 @@\n-            qtdemux_parse_moov (demux, data, demux->neededbytes);\n+            if (!qtdemux_parse_moov (demux, data, demux->neededbytes)) {\n+              ret = GST_FLOW_ERROR;\n+              break;\n+            }\n@@ -8191,2 +8214,2 @@\n-          if (!qtdemux_parse_tree (demux))\n-          {\n+            if (!qtdemux_parse_tree (demux))\n+            {\n@@ -8197,1 +8220,1 @@\n-          }\n+            }\n@@ -8201,1 +8224,4 @@\n-            qtdemux_prepare_streams (demux);\n+            ret = qtdemux_prepare_streams (demux);\n+            if (ret != GST_FLOW_OK)\n+              break;\n+\n@@ -8203,1 +8229,1 @@\n-            qtdemux_expose_streams (demux);\n+            ret = qtdemux_expose_streams (demux);\n@@ -8205,0 +8231,2 @@\n+            if (ret != GST_FLOW_OK)\n+              break;\n@@ -8295,1 +8323,1 @@\n-              qtdemux_expose_streams (demux);\n+              ret = qtdemux_expose_streams (demux);\n@@ -8297,0 +8325,2 @@\n+              if (ret != GST_FLOW_OK)\n+                goto done;\n@@ -8906,1 +8936,1 @@\n-    gint size;\n+    guint32 size;\n@@ -8914,1 +8944,1 @@\n-    if (buf + size > end || size <= 0)\n+    if (end - buf < size || size < 8)\n@@ -10134,0 +10164,15 @@\n+  if (gst_byte_reader_get_remaining (&stream->stts) < 8) {\n+    GST_DEBUG_OBJECT (qtdemux, \"Too small stts\");\n+    return;\n+  }\n+\n+  if (stream->stco.size < 8) {\n+    GST_DEBUG_OBJECT (qtdemux, \"Too small stco\");\n+    return;\n+  }\n+\n+  if (stream->n_samples_per_chunk == 0) {\n+    GST_DEBUG_OBJECT (qtdemux, \"No samples per chunk\");\n+    return;\n+  }\n+\n@@ -10145,0 +10190,7 @@\n+  if (gst_byte_reader_get_remaining (&stream->stsc) <\n+      stream->n_samples_per_chunk * 3 * 4 +\n+      (stream->n_samples_per_chunk - 1) * 4) {\n+    GST_DEBUG_OBJECT (qtdemux, \"Too small stsc\");\n+    return;\n+  }\n+\n@@ -10697,3 +10749,3 @@\n-        cur->offset =\n-            qt_atom_parser_get_offset_unchecked (&stream->co_chunk,\n-            stream->co_size);\n+        if (!qt_atom_parser_get_offset (&stream->co_chunk,\n+                stream->co_size, &cur->offset))\n+          goto corrupt_file;\n@@ -11245,0 +11297,1 @@\n+                \/* Note: The size does *not* include the fourcc and the size field itself *\/\n@@ -11246,1 +11299,1 @@\n-                if (seqh_size > 0) {\n+                if (seqh_size > 0 && seqh_size <= size - 8) {\n@@ -11500,1 +11553,2 @@\n-    } else if (QTCHECK_MATRIX (matrix, G_MAXUINT16, 0, 0, G_MAXUINT16)) {\n+    } else if (QTCHECK_MATRIX (matrix, G_MAXUINT16, 0, 0, G_MAXUINT16) ||\n+        QTCHECK_MATRIX (matrix, G_MAXUINT16, 0, 0, 1)) {\n@@ -12044,0 +12098,1 @@\n+        goto corrupt_file;\n@@ -12048,1 +12103,1 @@\n-        if (!qtdemux_parse_protection_aavd (qtdemux, stream, enc, &fourcc))\n+        if (!qtdemux_parse_protection_aavd (qtdemux, stream, enc, &fourcc)) {\n@@ -12050,0 +12105,2 @@\n+          goto corrupt_file;\n+        }\n@@ -12058,1 +12115,1 @@\n-      if (!qtdemux_parse_protection_scheme_info (qtdemux, stream, enc, &fourcc))\n+      if (!qtdemux_parse_protection_scheme_info (qtdemux, stream, enc, &fourcc)) {\n@@ -12060,0 +12117,2 @@\n+        goto corrupt_file;\n+      }\n@@ -12329,1 +12388,1 @@\n-            guint len = QT_UINT32 (stsd_entry_data);\n+            guint32 len = QT_UINT32 (stsd_entry_data);\n@@ -12334,9 +12393,2 @@\n-            while (len >= 0x8) {\n-              guint size;\n-\n-              if (QT_UINT32 (avc_data) <= 0x8)\n-                size = 0;\n-              else if (QT_UINT32 (avc_data) <= len)\n-                size = QT_UINT32 (avc_data) - 0x8;\n-              else\n-                size = len - 0x8;\n+            while (len >= 8) {\n+              guint32 size = QT_UINT32 (avc_data);\n@@ -12344,2 +12396,1 @@\n-              if (size < 1)\n-                \/* No real data, so break out *\/\n+              if (size < 8 || size > len)\n@@ -12348,1 +12399,1 @@\n-              switch (QT_FOURCC (avc_data + 0x4)) {\n+              switch (QT_FOURCC (avc_data + 4)) {\n@@ -12354,0 +12405,3 @@\n+                  if (size < 8 + 1)\n+                    break;\n+\n@@ -12360,3 +12414,3 @@\n-                      avc_data + 8 + 1, size - 1);\n-                  buf = gst_buffer_new_and_alloc (size);\n-                  gst_buffer_fill (buf, 0, avc_data + 0x8, size);\n+                      avc_data + 8 + 1, size - 8 - 1);\n+                  buf = gst_buffer_new_and_alloc (size - 8);\n+                  gst_buffer_fill (buf, 0, avc_data + 8, size - 8);\n@@ -12373,0 +12427,3 @@\n+                  if (size < 8 + 40 + 1)\n+                    break;\n+\n@@ -12380,4 +12437,2 @@\n-                  size -= 40;   \/* we'll be skipping BITMAPINFOHEADER *\/\n-                  if (size > 1) {\n-                    gst_codec_utils_h264_caps_set_level_and_profile\n-                        (entry->caps, avc_data + 8 + 40 + 1, size - 1);\n+                  gst_codec_utils_h264_caps_set_level_and_profile\n+                      (entry->caps, avc_data + 8 + 40 + 1, size - 8 - 40 - 1);\n@@ -12385,6 +12440,5 @@\n-                    buf = gst_buffer_new_and_alloc (size);\n-                    gst_buffer_fill (buf, 0, avc_data + 8 + 40, size);\n-                    gst_caps_set_simple (entry->caps,\n-                        \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n-                    gst_buffer_unref (buf);\n-                  }\n+                  buf = gst_buffer_new_and_alloc (size - 8 - 40);\n+                  gst_buffer_fill (buf, 0, avc_data + 8 + 40, size - 8 - 40);\n+                  gst_caps_set_simple (entry->caps,\n+                      \"codec_data\", GST_TYPE_BUFFER, buf, NULL);\n+                  gst_buffer_unref (buf);\n@@ -12398,1 +12452,1 @@\n-                  if (size < 12)\n+                  if (size < 8 + 12)\n@@ -12401,2 +12455,2 @@\n-                  max_bitrate = QT_UINT32 (avc_data + 0xc);\n-                  avg_bitrate = QT_UINT32 (avc_data + 0x10);\n+                  max_bitrate = QT_UINT32 (avc_data + 8 + 4);\n+                  avg_bitrate = QT_UINT32 (avc_data + 8 + 8);\n@@ -12434,2 +12488,2 @@\n-              len -= size + 8;\n-              avc_data += size + 8;\n+              len -= size;\n+              avc_data += size;\n@@ -12446,1 +12500,1 @@\n-            guint len = QT_UINT32 (stsd_entry_data);\n+            guint32 len = QT_UINT32 (stsd_entry_data);\n@@ -12451,9 +12505,2 @@\n-            while (len >= 0x8) {\n-              guint size;\n-\n-              if (QT_UINT32 (hevc_data) <= 0x8)\n-                size = 0;\n-              else if (QT_UINT32 (hevc_data) <= len)\n-                size = QT_UINT32 (hevc_data) - 0x8;\n-              else\n-                size = len - 0x8;\n+            while (len >= 8) {\n+              guint32 size = QT_UINT32 (hevc_data);\n@@ -12461,2 +12508,1 @@\n-              if (size < 1)\n-                \/* No real data, so break out *\/\n+              if (size < 8 || size > len)\n@@ -12465,1 +12511,1 @@\n-              switch (QT_FOURCC (hevc_data + 0x4)) {\n+              switch (QT_FOURCC (hevc_data + 4)) {\n@@ -12471,0 +12517,3 @@\n+                  if (size < 8 + 1)\n+                    break;\n+\n@@ -12477,1 +12526,1 @@\n-                      (entry->caps, hevc_data + 8 + 1, size - 1);\n+                      (entry->caps, hevc_data + 8 + 1, size - 8 - 1);\n@@ -12479,2 +12528,2 @@\n-                  buf = gst_buffer_new_and_alloc (size);\n-                  gst_buffer_fill (buf, 0, hevc_data + 0x8, size);\n+                  buf = gst_buffer_new_and_alloc (size - 8);\n+                  gst_buffer_fill (buf, 0, hevc_data + 8, size - 8);\n@@ -12489,2 +12538,2 @@\n-              len -= size + 8;\n-              hevc_data += size + 8;\n+              len -= size;\n+              hevc_data += size;\n@@ -12870,1 +12919,1 @@\n-            guint len = QT_UINT32 (stsd_entry_data);\n+            guint32 len = QT_UINT32 (stsd_entry_data);\n@@ -12876,8 +12925,1 @@\n-              guint size;\n-\n-              if (QT_UINT32 (vc1_data) <= 8)\n-                size = 0;\n-              else if (QT_UINT32 (vc1_data) <= len)\n-                size = QT_UINT32 (vc1_data) - 8;\n-              else\n-                size = len - 8;\n+              guint32 size = QT_UINT32 (vc1_data);\n@@ -12885,2 +12927,1 @@\n-              if (size < 1)\n-                \/* No real data, so break out *\/\n+              if (size < 8 || size > len)\n@@ -12889,1 +12930,1 @@\n-              switch (QT_FOURCC (vc1_data + 0x4)) {\n+              switch (QT_FOURCC (vc1_data + 4)) {\n@@ -12895,2 +12936,2 @@\n-                  buf = gst_buffer_new_and_alloc (size);\n-                  gst_buffer_fill (buf, 0, vc1_data + 8, size);\n+                  buf = gst_buffer_new_and_alloc (size - 8);\n+                  gst_buffer_fill (buf, 0, vc1_data + 8, size - 8);\n@@ -12905,2 +12946,2 @@\n-              len -= size + 8;\n-              vc1_data += size + 8;\n+              len -= size;\n+              vc1_data += size;\n@@ -12912,1 +12953,1 @@\n-            guint len = QT_UINT32 (stsd_entry_data);\n+            guint32 len = QT_UINT32 (stsd_entry_data);\n@@ -12917,9 +12958,2 @@\n-            while (len >= 0x8) {\n-              guint size;\n-\n-              if (QT_UINT32 (av1_data) <= 0x8)\n-                size = 0;\n-              else if (QT_UINT32 (av1_data) <= len)\n-                size = QT_UINT32 (av1_data) - 0x8;\n-              else\n-                size = len - 0x8;\n+            while (len >= 8) {\n+              guint32 size = QT_UINT32 (av1_data);\n@@ -12927,2 +12961,1 @@\n-              if (size < 1)\n-                \/* No real data, so break out *\/\n+              if (size < 8 || size > len)\n@@ -12931,1 +12964,1 @@\n-              switch (QT_FOURCC (av1_data + 0x4)) {\n+              switch (QT_FOURCC (av1_data + 4)) {\n@@ -12941,1 +12974,1 @@\n-                  if (size < 4)\n+                  if (size < 8 + 4)\n@@ -12990,1 +13023,1 @@\n-                      buf = gst_buffer_new_and_alloc (size);\n+                      buf = gst_buffer_new_and_alloc (size - 8);\n@@ -12992,1 +13025,1 @@\n-                      gst_buffer_fill (buf, 0, av1_data + 8, size);\n+                      gst_buffer_fill (buf, 0, av1_data + 8, size - 8);\n@@ -13010,2 +13043,2 @@\n-              len -= size + 8;\n-              av1_data += size + 8;\n+              len -= size;\n+              av1_data += size;\n@@ -13022,1 +13055,1 @@\n-            guint len = QT_UINT32 (stsd_entry_data);\n+            guint32 len = QT_UINT32 (stsd_entry_data);\n@@ -13027,9 +13060,2 @@\n-            while (len >= 0x8) {\n-              guint size;\n-\n-              if (QT_UINT32 (vpcc_data) <= 0x8)\n-                size = 0;\n-              else if (QT_UINT32 (vpcc_data) <= len)\n-                size = QT_UINT32 (vpcc_data) - 0x8;\n-              else\n-                size = len - 0x8;\n+            while (len >= 8) {\n+              guint32 size = QT_UINT32 (vpcc_data);\n@@ -13037,2 +13063,1 @@\n-              if (size < 1)\n-                \/* No real data, so break out *\/\n+              if (size < 8 || size > len)\n@@ -13041,1 +13066,1 @@\n-              switch (QT_FOURCC (vpcc_data + 0x4)) {\n+              switch (QT_FOURCC (vpcc_data + 4)) {\n@@ -13057,1 +13082,1 @@\n-                  if (size < 12)\n+                  if (size < 8 + 12)\n@@ -13163,2 +13188,2 @@\n-              len -= size + 8;\n-              vpcc_data += size + 8;\n+              len -= size;\n+              vpcc_data += size;\n@@ -13505,1 +13530,1 @@\n-          guint len = QT_UINT32 (stsd_entry_data);\n+          guint32 len = QT_UINT32 (stsd_entry_data);\n@@ -13530,8 +13555,1 @@\n-            guint size;\n-\n-            if (QT_UINT32 (wfex_data) <= 0x8)\n-              size = 0;\n-            else if (QT_UINT32 (wfex_data) <= len)\n-              size = QT_UINT32 (wfex_data) - 8;\n-            else\n-              size = len - 8;\n+            guint32 size = QT_UINT32 (wfex_data);\n@@ -13539,2 +13557,1 @@\n-            if (size < 1)\n-              \/* No real data, so break out *\/\n+            if (size < 8 || size > len)\n@@ -13586,1 +13603,1 @@\n-                if (size > wfex.cbSize) {\n+                if (size > 8 + wfex.cbSize) {\n@@ -13589,1 +13606,1 @@\n-                  buf = gst_buffer_new_and_alloc (size - wfex.cbSize);\n+                  buf = gst_buffer_new_and_alloc (size - 8 - wfex.cbSize);\n@@ -13591,1 +13608,1 @@\n-                      size - wfex.cbSize);\n+                      size - 8 - wfex.cbSize);\n@@ -13608,2 +13625,2 @@\n-            len -= size + 8;\n-            wfex_data += size + 8;\n+            len -= size;\n+            wfex_data += size;\n@@ -13773,35 +13790,41 @@\n-          GNode *wavenode;\n-          GNode *waveheadernode;\n-\n-          wavenode = g_node_new ((guint8 *) data);\n-          if (qtdemux_parse_node (qtdemux, wavenode, data, datalen)) {\n-            const guint8 *waveheader;\n-            guint32 headerlen;\n-\n-            waveheadernode = qtdemux_tree_get_child_by_type (wavenode, fourcc);\n-            if (waveheadernode) {\n-              waveheader = (const guint8 *) waveheadernode->data;\n-              headerlen = QT_UINT32 (waveheader);\n-\n-              if (headerlen > 8) {\n-                gst_riff_strf_auds *header = NULL;\n-                GstBuffer *headerbuf;\n-                GstBuffer *extra;\n-\n-                waveheader += 8;\n-                headerlen -= 8;\n-\n-                headerbuf = gst_buffer_new_and_alloc (headerlen);\n-                gst_buffer_fill (headerbuf, 0, waveheader, headerlen);\n-\n-                if (gst_riff_parse_strf_auds (GST_ELEMENT_CAST (qtdemux),\n-                        headerbuf, &header, &extra)) {\n-                  gst_caps_unref (entry->caps);\n-                  \/* FIXME: Need to do something with the channel reorder map *\/\n-                  entry->caps =\n-                      gst_riff_create_audio_caps (header->format, NULL, header,\n-                      extra, NULL, NULL, NULL);\n-\n-                  if (extra)\n-                    gst_buffer_unref (extra);\n-                  g_free (header);\n+\n+          if (len < datalen || len - datalen < offset + 16) {\n+            GST_WARNING_OBJECT (qtdemux, \"Not enough data for waveheadernode\");\n+          } else {\n+            GNode *wavenode;\n+            GNode *waveheadernode;\n+\n+            wavenode = g_node_new ((guint8 *) data);\n+            if (qtdemux_parse_node (qtdemux, wavenode, data, datalen)) {\n+              const guint8 *waveheader;\n+              guint32 headerlen;\n+\n+              waveheadernode =\n+                  qtdemux_tree_get_child_by_type (wavenode, fourcc);\n+              if (waveheadernode) {\n+                waveheader = (const guint8 *) waveheadernode->data;\n+                headerlen = QT_UINT32 (waveheader);\n+\n+                if (headerlen > 8) {\n+                  gst_riff_strf_auds *header = NULL;\n+                  GstBuffer *headerbuf;\n+                  GstBuffer *extra;\n+\n+                  waveheader += 8;\n+                  headerlen -= 8;\n+\n+                  headerbuf = gst_buffer_new_and_alloc (headerlen);\n+                  gst_buffer_fill (headerbuf, 0, waveheader, headerlen);\n+\n+                  if (gst_riff_parse_strf_auds (GST_ELEMENT_CAST (qtdemux),\n+                          headerbuf, &header, &extra)) {\n+                    gst_caps_unref (entry->caps);\n+                    \/* FIXME: Need to do something with the channel reorder map *\/\n+                    entry->caps =\n+                        gst_riff_create_audio_caps (header->format, NULL,\n+                        header, extra, NULL, NULL, NULL);\n+\n+                    if (extra)\n+                      gst_buffer_unref (extra);\n+                    g_free (header);\n+                  }\n@@ -13809,3 +13832,4 @@\n-              }\n-            } else\n-              GST_DEBUG (\"Didn't find waveheadernode for this codec\");\n+              } else\n+                GST_DEBUG (\"Didn't find waveheadernode for this codec\");\n+            }\n+            g_node_destroy (wavenode);\n@@ -13813,1 +13837,0 @@\n-          g_node_destroy (wavenode);\n@@ -14207,0 +14230,3 @@\n+    if (!info)\n+      goto corrupt_file;\n+\n@@ -14484,1 +14510,2 @@\n-      if (!qtdemux_parse_samples (qtdemux, stream, sample_num))\n+      if (!qtdemux_parse_samples (qtdemux, stream, sample_num)) {\n+        ret = GST_FLOW_ERROR;\n@@ -14486,0 +14513,1 @@\n+      }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/qtdemux.c","additions":220,"deletions":192,"binary":false,"changes":412,"status":"modified"},{"patch":"@@ -839,0 +839,5 @@\n+  \/* Nothing to print below *\/\n+  if ((flags & (TR_SAMPLE_DURATION | TR_SAMPLE_SIZE | TR_SAMPLE_FLAGS |\n+              TR_COMPOSITION_TIME_OFFSETS)) == 0)\n+    return TRUE;\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/isomp4\/qtdemux_dump.c","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -810,0 +810,5 @@\n+  if (size < 4) {\n+    GST_WARNING_OBJECT (wav, \"broken file %d\", size);\n+    return FALSE;\n+  }\n+\n@@ -909,0 +914,3 @@\n+  if (size < 32)\n+    return FALSE;\n+\n@@ -1100,0 +1108,5 @@\n+  if (map.size < 6 * 4) {\n+    GST_WARNING_OBJECT (wav, \"Too small ds64 chunk (%\" G_GSIZE_FORMAT \")\",\n+        map.size);\n+    return FALSE;\n+  }\n@@ -1117,0 +1130,18 @@\n+static GstFlowReturn\n+gst_wavparse_pull_range_exact (GstWavParse * wav, guint64 offset, guint size,\n+    GstBuffer ** buffer)\n+{\n+  GstFlowReturn res;\n+\n+  res = gst_pad_pull_range (wav->sinkpad, offset, size, buffer);\n+  if (res != GST_FLOW_OK)\n+    return res;\n+\n+  if (gst_buffer_get_size (*buffer) < size) {\n+    gst_clear_buffer (buffer);\n+    return GST_FLOW_EOS;\n+  }\n+\n+  return res;\n+}\n+\n@@ -1312,1 +1343,1 @@\n-              gst_pad_pull_range (wav->sinkpad, wav->offset, 8,\n+              gst_wavparse_pull_range_exact (wav, wav->offset, 8,\n@@ -1319,1 +1350,1 @@\n-        goto header_read_error;\n+        goto header_pull_error;\n@@ -1337,1 +1368,1 @@\n-    if (upstream_size > 0 && size + wav->offset > upstream_size) {\n+    if (upstream_size > 0 && size + 8 + wav->offset > upstream_size) {\n@@ -1340,1 +1371,2 @@\n-      size = upstream_size - wav->offset;\n+      g_assert (upstream_size - wav->offset >= 8);\n+      size = upstream_size - wav->offset - 8;\n@@ -1427,1 +1459,1 @@\n-                    gst_pad_pull_range (wav->sinkpad, wav->offset + 8,\n+                    gst_wavparse_pull_range_exact (wav, wav->offset + 8,\n@@ -1434,1 +1466,1 @@\n-              goto header_read_error;\n+              goto header_pull_error;\n@@ -1451,2 +1483,1 @@\n-        const gst_riff_acid *acid = NULL;\n-        const guint data_size = sizeof (gst_riff_acid);\n+        const guint data_size = 24;\n@@ -1466,0 +1497,1 @@\n+          const guint8 *data;\n@@ -1470,3 +1502,2 @@\n-          acid = (const gst_riff_acid *) gst_adapter_map (wav->adapter,\n-              data_size);\n-          tempo = acid->tempo;\n+          data = gst_adapter_map (wav->adapter, data_size);\n+          tempo = GST_READ_FLOAT_LE (data + 20);\n@@ -1479,2 +1510,2 @@\n-                  gst_pad_pull_range (wav->sinkpad, wav->offset + 8,\n-                      size, &buf)) != GST_FLOW_OK)\n+                  gst_wavparse_pull_range_exact (wav, wav->offset + 8, size,\n+                      &buf)) != GST_FLOW_OK)\n@@ -1486,1 +1517,1 @@\n-            goto header_read_error;\n+            goto header_pull_error;\n@@ -1488,2 +1519,1 @@\n-          acid = (const gst_riff_acid *) map.data;\n-          tempo = acid->tempo;\n+          tempo = GST_READ_FLOAT_LE (map.data + 20);\n@@ -1511,0 +1541,4 @@\n+        \/* Need at least the ltag *\/\n+        if (size < 4)\n+          goto exit;\n+\n@@ -1524,1 +1558,1 @@\n-                  gst_pad_pull_range (wav->sinkpad, wav->offset, 12,\n+                  gst_wavparse_pull_range_exact (wav, wav->offset, 12,\n@@ -1531,1 +1565,1 @@\n-            goto header_read_error;\n+            goto header_pull_error;\n@@ -1558,1 +1592,1 @@\n-                        gst_pad_pull_range (wav->sinkpad, wav->offset,\n+                        gst_wavparse_pull_range_exact (wav, wav->offset,\n@@ -1565,1 +1599,1 @@\n-                  goto header_read_error;\n+                  goto header_pull_error;\n@@ -1603,1 +1637,1 @@\n-                      gst_pad_pull_range (wav->sinkpad, wav->offset,\n+                      gst_wavparse_pull_range_exact (wav, wav->offset,\n@@ -1605,1 +1639,1 @@\n-                goto header_read_error;\n+                goto header_pull_error;\n@@ -1649,1 +1683,1 @@\n-                  gst_pad_pull_range (wav->sinkpad, wav->offset,\n+                  gst_wavparse_pull_range_exact (wav, wav->offset,\n@@ -1651,1 +1685,1 @@\n-            goto header_read_error;\n+            goto header_pull_error;\n@@ -1693,1 +1727,1 @@\n-                  gst_pad_pull_range (wav->sinkpad, wav->offset,\n+                  gst_wavparse_pull_range_exact (wav, wav->offset,\n@@ -1695,1 +1729,1 @@\n-            goto header_read_error;\n+            goto header_pull_error;\n@@ -1847,0 +1881,11 @@\n+header_pull_error:\n+  {\n+    if (res == GST_FLOW_EOS) {\n+      GST_WARNING_OBJECT (wav, \"Couldn't pull header %d (%s)\", res,\n+          gst_flow_get_name (res));\n+    } else {\n+      GST_ELEMENT_ERROR (wav, STREAM, DEMUX, (NULL),\n+          (\"Couldn't pull header %d (%s)\", res, gst_flow_get_name (res)));\n+    }\n+    goto exit;\n+  }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/gst\/wavparse\/gstwavparse.c","additions":71,"deletions":26,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -248,0 +248,5 @@\n+    case GST_STATE_CHANGE_READY_TO_NULL:\n+      GST_OBJECT_LOCK (osxsink);\n+      osxsink->device_id = kAudioDeviceUnknown;\n+      GST_OBJECT_UNLOCK (osxsink);\n+      break;\n@@ -265,0 +270,1 @@\n+        GST_OBJECT_LOCK (osxsink);\n@@ -266,0 +272,1 @@\n+        GST_OBJECT_UNLOCK (osxsink);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxaudiosink.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -213,0 +213,6 @@\n+    case GST_STATE_CHANGE_READY_TO_NULL:{\n+      GST_OBJECT_LOCK (osxsrc);\n+      osxsrc->device_id = kAudioDeviceUnknown;\n+      GST_OBJECT_UNLOCK (osxsrc);\n+      break;\n+    }\n@@ -227,0 +233,1 @@\n+        GST_OBJECT_LOCK (osxsrc);\n@@ -228,0 +235,2 @@\n+        GST_OBJECT_UNLOCK (osxsrc);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gst-plugins-good\/sys\/osxaudio\/gstosxaudiosrc.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -436,0 +436,6 @@\n+  if (align > G_MAXSIZE || maxsize > G_MAXSIZE - align) {\n+    GST_CAT_WARNING (GST_CAT_MEMORY,\n+        \"Allocating %\" G_GSIZE_FORMAT \" bytes with alignment %\" G_GSIZE_FORMAT\n+        \"x overflows\", maxsize, align);\n+    return NULL;\n+  }\n@@ -438,0 +444,6 @@\n+  if (maxsize > G_MAXSIZE - sizeof (GstMemorySystem)) {\n+    GST_CAT_WARNING (GST_CAT_MEMORY,\n+        \"Allocating %\" G_GSIZE_FORMAT \" bytes with alignment %\" G_GSIZE_FORMAT\n+        \"x overflows\", maxsize, align);\n+    return NULL;\n+  }\n@@ -487,2 +499,1 @@\n-#ifdef GSTREAMER_LITE\n-  if (copy == NULL)\n+  if (!copy)\n@@ -490,1 +501,0 @@\n-#endif \/\/ GSTREAMER_LITE\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstallocator.c","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4000,1 +4000,0 @@\n-      GList *l, *contexts;\n@@ -4005,0 +4004,2 @@\n+        GList *l, *contexts;\n+\n@@ -4006,1 +4007,4 @@\n-        contexts = GST_ELEMENT_CAST (bin)->contexts;\n+        contexts =\n+            g_list_copy_deep (GST_ELEMENT_CAST (bin)->contexts,\n+            (GCopyFunc) gst_mini_object_ref, NULL);\n+        GST_OBJECT_UNLOCK (bin);\n@@ -4017,1 +4021,2 @@\n-        GST_OBJECT_UNLOCK (bin);\n+\n+        g_list_free_full (contexts, (GDestroyNotify) gst_mini_object_unref);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstbin.c","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -85,1 +85,2 @@\n-  return g_strcanon (g_strdup_printf (\"%s_%p\", GST_OBJECT_NAME (obj), obj),\n+  \/* must start with a letter to prevent dot from splitting names starting with [0-9] *\/\n+  return g_strcanon (g_strdup_printf (\"node_%s_%p\", GST_OBJECT_NAME (obj), obj),\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstdebugutils.c","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-\n+#include <gst\/gststructure.h>\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstmeta.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4570,1 +4570,1 @@\n-    if (!handled)\n+    if (data && !handled)\n@@ -5572,0 +5572,3 @@\n+  \/* Note: FLUSH_STOP is a serialized event, but must not propagate sticky\n+   * events. FLUSH_STOP is only targeted at removing the flushing state from\n+   * pads and elements, and not actually pushing data\/events. *\/\n@@ -5573,1 +5576,2 @@\n-      && (GST_EVENT_IS_SERIALIZED (event))) {\n+      && (GST_EVENT_IS_SERIALIZED (event))\n+      && GST_EVENT_TYPE (event) != GST_EVENT_FLUSH_STOP) {\n@@ -5639,1 +5643,1 @@\n-    if (ret != GST_FLOW_CUSTOM_SUCCESS_1)\n+    if (event && ret != GST_FLOW_CUSTOM_SUCCESS_1)\n@@ -5732,1 +5736,2 @@\n-  if (GST_PAD_IS_SRC (pad) && serialized) {\n+  if (GST_PAD_IS_SRC (pad) && serialized\n+      && GST_EVENT_TYPE (event) != GST_EVENT_FLUSH_STOP) {\n@@ -5736,1 +5741,7 @@\n-     * could potentially block. *\/\n+     * could potentially block.\n+     *\n+     * We must NOT propagate sticky events in response to FLUSH_STOP either, as\n+     * FLUSH_STOP is only targeted at removing the flushing state from pads and\n+     * elements, and not actually pushing data\/events. This also makes it\n+     * consistent with the way flush events are handled in \"blocking\" pad\n+     * probes. *\/\n@@ -6048,1 +6059,1 @@\n-    if (ret != GST_FLOW_CUSTOM_SUCCESS_1)\n+    if (event && ret != GST_FLOW_CUSTOM_SUCCESS_1)\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstpad.c","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -580,0 +580,1 @@\n+  gboolean starting;\n@@ -879,1 +880,0 @@\n-  gboolean entry_needs_unlock = FALSE;\n@@ -884,0 +884,1 @@\n+  priv->starting = FALSE;\n@@ -911,1 +912,0 @@\n-    entry_needs_unlock = TRUE;\n@@ -922,1 +922,1 @@\n-      goto next_entry;\n+      goto unlock_entry_and_next_entry;\n@@ -953,1 +953,1 @@\n-        goto next_entry;\n+        goto unlock_entry_and_next_entry;\n@@ -958,1 +958,0 @@\n-        entry_needs_unlock = FALSE;\n@@ -996,2 +995,1 @@\n-        if (entry_needs_unlock)\n-          GST_SYSTEM_CLOCK_ENTRY_UNLOCK ((GstClockEntryImpl *) entry);\n+        GST_SYSTEM_CLOCK_ENTRY_UNLOCK ((GstClockEntryImpl *) entry);\n@@ -1005,1 +1003,1 @@\n-        goto next_entry;\n+        goto unlock_entry_and_next_entry;\n@@ -1007,0 +1005,2 @@\n+  unlock_entry_and_next_entry:\n+    GST_SYSTEM_CLOCK_ENTRY_UNLOCK ((GstClockEntryImpl *) entry);\n@@ -1008,2 +1008,0 @@\n-    if (entry_needs_unlock)\n-      GST_SYSTEM_CLOCK_ENTRY_UNLOCK ((GstClockEntryImpl *) entry);\n@@ -1137,4 +1135,7 @@\n-  status = GST_CLOCK_ENTRY_STATUS (entry);\n-  if (G_UNLIKELY (status == GST_CLOCK_UNSCHEDULED)) {\n-    return GST_CLOCK_UNSCHEDULED;\n-  }\n+  \/* Getting the time from the clock locks the clock, so without unlocking the\n+   * entry we would have a lock order violation here that can lead to deadlocks.\n+   *\n+   * It's not a problem to take the mutex again after getting the times (which\n+   * might block for a moment) as waiting happens based on the absolute time.\n+   *\/\n+  GST_SYSTEM_CLOCK_ENTRY_UNLOCK ((GstClockEntryImpl *) entry);\n@@ -1147,0 +1148,7 @@\n+  GST_SYSTEM_CLOCK_ENTRY_LOCK ((GstClockEntryImpl *) entry);\n+  \/* Might have been unscheduled in the meantime *\/\n+  status = GST_CLOCK_ENTRY_STATUS (entry);\n+  if (G_UNLIKELY (status == GST_CLOCK_UNSCHEDULED)) {\n+    return GST_CLOCK_UNSCHEDULED;\n+  }\n+\n@@ -1240,0 +1248,2 @@\n+        GST_SYSTEM_CLOCK_ENTRY_UNLOCK ((GstClockEntryImpl *) entry);\n+\n@@ -1242,1 +1252,0 @@\n-        mono_ts = g_get_monotonic_time ();\n@@ -1244,0 +1253,9 @@\n+        mono_ts = g_get_monotonic_time ();\n+\n+        GST_SYSTEM_CLOCK_ENTRY_LOCK ((GstClockEntryImpl *) entry);\n+        \/* Might have been unscheduled in the meantime *\/\n+        status = GST_CLOCK_ENTRY_STATUS (entry);\n+        if (G_UNLIKELY (status == GST_CLOCK_UNSCHEDULED)) {\n+          goto done;\n+        }\n+\n@@ -1331,0 +1349,1 @@\n+  priv->starting = TRUE;\n@@ -1338,1 +1357,2 @@\n-  GST_SYSTEM_CLOCK_WAIT (clock);\n+  while (priv->starting)\n+    GST_SYSTEM_CLOCK_WAIT (clock);\n@@ -1345,0 +1365,1 @@\n+    priv->starting = FALSE;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstsystemclock.c","additions":37,"deletions":16,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1221,1 +1221,2 @@\n-              \"already linked or cannot be linked (peer = %p)\", peer);\n+              \"already linked or cannot be linked (peer = %\" GST_PTR_FORMAT \")\",\n+              peer);\n@@ -4474,1 +4475,1 @@\n-\/* Compute log2 of the passed 64-bit number by finding the highest set bit *\/\n+\/* Compute the number of bits needed at least to store `in` *\/\n@@ -4476,1 +4477,1 @@\n-gst_log2 (GstClockTime in)\n+gst_bit_storage_uint64 (guint64 in)\n@@ -4478,0 +4479,5 @@\n+#if defined(__GNUC__) && __GNUC__ >= 4\n+  return in ? 64 - __builtin_clzll (in) : 1;\n+#else\n+  \/* integer log2(v) from:\n+     <http:\/\/graphics.stanford.edu\/~seander\/bithacks.html#IntegerLog> *\/\n@@ -4491,1 +4497,2 @@\n-  return count;\n+  return count + 1;             \/\/ + 1 to get the number of storage bits needed\n+#endif\n@@ -4499,1 +4506,1 @@\n- * Return a max num of log2.\n+ * Returns smallest integral value not less than log2(v).\n@@ -4508,19 +4515,23 @@\n-  \/* Compute Ceil(Log2(v)) *\/\n-  \/* Derived from branchless code for integer log2(v) from:\n-     <http:\/\/graphics.stanford.edu\/~seander\/bithacks.html#IntegerLog> *\/\n-  guint r, shift;\n-\n-  v--;\n-  r = (v > 0xFFFF) << 4;\n-  v >>= r;\n-  shift = (v > 0xFF) << 3;\n-  v >>= shift;\n-  r |= shift;\n-  shift = (v > 0xF) << 2;\n-  v >>= shift;\n-  r |= shift;\n-  shift = (v > 0x3) << 1;\n-  v >>= shift;\n-  r |= shift;\n-  r |= (v >> 1);\n-  return r + 1;\n+  static const unsigned int t[6] = {\n+    0x00000000ull,\n+    0xFFFF0000ull,\n+    0x0000FF00ull,\n+    0x000000F0ull,\n+    0x0000000Cull,\n+    0x000000002ull\n+  };\n+\n+  g_return_val_if_fail (v != 0, -1);\n+\n+  int y = (((v & (v - 1)) == 0) ? 0 : 1);\n+  int j = 32;\n+  int i;\n+\n+  for (i = 0; i < 6; i++) {\n+    int k = (((v & t[i]) == 0) ? 0 : j);\n+    y += k;\n+    v >>= k;\n+    j >>= 1;\n+  }\n+\n+  return y;\n@@ -4660,4 +4671,14 @@\n-   * with a fallback loop that drops precision if things go pear-shaped *\/\n-  max_bits = gst_log2 (MAX (xmax - xmin, ymax - ymin)) * 7 \/ 8 + gst_log2 (n);\n-  if (max_bits > 64)\n-    pshift = max_bits - 64;\n+   * with a fallback loop that drops precision if things go pear-shaped.\n+   *\n+   * Each calculation of tmp during the iteration is multiplying two numbers and\n+   * then adding them together, or adding them together and then multiplying\n+   * them. The second case is worse and means we need at least twice\n+   * (multiplication) as many bits as the biggest number needs, plus another bit\n+   * (addition). At most 63 bits (signed 64 bit integer) are available.\n+   *\n+   * That means that each number must require at most (63 - 1) \/ 2 bits = 31\n+   * bits of storage.\n+   *\/\n+  max_bits = gst_bit_storage_uint64 (MAX (1, MAX (xmax - xmin, ymax - ymin)));\n+  if (max_bits > 31)\n+    pshift = max_bits - 31;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/gstreamer\/gst\/gstutils.c","additions":49,"deletions":28,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -473,1 +473,1 @@\n-#define PACKAGE_STRING \"GStreamer 1.24.6\"\n+#define PACKAGE_STRING \"GStreamer 1.24.10\"\n@@ -482,1 +482,1 @@\n-#define PACKAGE_VERSION \"1.24.6\"\n+#define PACKAGE_VERSION \"1.24.10\"\n@@ -522,1 +522,1 @@\n-#define VERSION \"1.24.6\"\n+#define VERSION \"1.24.10\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/projects\/build\/linux\/common\/config.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -477,1 +477,1 @@\n-#define PACKAGE_STRING \"GStreamer 1.24.6\"\n+#define PACKAGE_STRING \"GStreamer 1.24.10\"\n@@ -486,1 +486,1 @@\n-#define PACKAGE_VERSION \"1.24.6\"\n+#define PACKAGE_VERSION \"1.24.10\"\n@@ -526,1 +526,1 @@\n-#define VERSION \"1.24.6\"\n+#define VERSION \"1.24.10\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/projects\/build\/osx\/common\/x86_64\/config.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-#define PACKAGE_STRING \"GStreamer 1.24.6\"\n+#define PACKAGE_STRING \"GStreamer 1.24.10\"\n@@ -487,1 +487,1 @@\n-#define PACKAGE_VERSION \"1.24.6\"\n+#define PACKAGE_VERSION \"1.24.10\"\n@@ -527,1 +527,1 @@\n-#define VERSION \"1.24.6\"\n+#define VERSION \"1.24.10\"\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/gstreamer-lite\/projects\/build\/win32\/common\/config.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -205,2 +205,0 @@\n-          gst-plugins-base\/gst-libs\/gst\/pbutils\/gstdiscoverer.c \\\n-          gst-plugins-base\/gst-libs\/gst\/pbutils\/gstdiscoverer-types.c \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/linux\/gstreamer-lite\/Makefile","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+            glib\/gspawn-posix.c \\\n@@ -124,1 +125,0 @@\n-            glib\/gthread-posix.c \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/mac\/glib-lite\/Makefile","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -200,2 +200,0 @@\n-            gst-plugins-base\/gst-libs\/gst\/pbutils\/gstdiscoverer.c \\\n-            gst-plugins-base\/gst-libs\/gst\/pbutils\/gstdiscoverer-types.c \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/mac\/gstreamer-lite\/Makefile","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+        gspawn.c \\\n@@ -84,1 +85,0 @@\n-        gthread-win32.c \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/win\/glib-lite\/Makefile.glib","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,2 +139,0 @@\n-            gst-plugins-base\/gst-libs\/gst\/pbutils\/gstdiscoverer.c \\\n-            gst-plugins-base\/gst-libs\/gst\/pbutils\/gstdiscoverer-types.c \\\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/win\/gstreamer-lite\/Makefile.gstreamer","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}