{"files":[{"patch":"@@ -44,1 +44,8 @@\n-        Subscription.subscribe(nonNullCondition, current -> {\n+        Subscription.subscribe(nonNullCondition, this::conditionChanged);\n+    }\n+\n+    private void conditionChanged(boolean active) {\n+        if (!active && !isValid()) {\n+            getValue();  \/\/ makes binding valid, which it should always be when inactive\n+        }\n+        else if (isValid() && source.getValue() != getValue()) {\n@@ -46,0 +53,1 @@\n+        }\n@@ -47,4 +55,1 @@\n-            if (!current) {\n-                getValue();\n-            }\n-        });\n+        updateSubscription();\n@@ -65,0 +70,6 @@\n+        updateSubscription();\n+\n+        return source.getValue();\n+    }\n+\n+    private void updateSubscription() {\n@@ -73,2 +84,0 @@\n-\n-        return source.getValue();\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ConditionalBinding.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -82,20 +82,0 @@\n-\n-            \/*\n-             * Although the act of registering a listener already attempts to make\n-             * this binding valid, allowValidation won't allow it as the binding is\n-             * not observed yet. This is because isObserved will not yet return true\n-             * when the process of registering the listener hasn't completed yet.\n-             *\n-             * As the binding must be valid after it becomes observed the first time\n-             * 'get' is called again.\n-             *\n-             * See com.sun.javafx.binding.ExpressionHelper (which is used\n-             * by ObjectBinding) where it will do a call to ObservableValue#getValue\n-             * BEFORE adding the actual listener. This results in ObjectBinding#get\n-             * to be called in which the #allowValidation call will block it from\n-             * becoming valid as the condition is \"isObserved()\"; this is technically\n-             * correct as the listener wasn't added yet, but means we must call\n-             * #get again to make this binding valid.\n-             *\/\n-\n-            get(); \/\/ make binding valid as source wasn't tracked until now\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/LazyObjectBinding.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    private boolean isObserved;\n@@ -84,0 +85,1 @@\n+        isObserved = isObserved || listener != null;\n@@ -90,0 +92,1 @@\n+        isObserved = helper != null;\n@@ -94,0 +97,1 @@\n+        isObserved = isObserved || listener != null;\n@@ -100,0 +104,1 @@\n+        isObserved = helper != null;\n@@ -214,1 +219,1 @@\n-        return helper != null;\n+        return isObserved;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/ObjectBinding.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1033,0 +1033,23 @@\n+                @Test\n+                void shouldBeStronglyReferencedImmediatelyAfterConditionBecomesTrue() {\n+                    condition.set(false);\n+                    condition.set(true);\n+\n+                    ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> {\n+                        observableValue = null;\n+                        condition = null;\n+                    });\n+                }\n+\n+                @Test\n+                void shouldBeStronglyReferencedImmediatelyAfterConditionBecomesTrue_2() {\n+                    condition.set(false);\n+                    property.set(\"Middle\");\n+                    condition.set(true);\n+\n+                    ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> {\n+                        observableValue = null;\n+                        condition = null;\n+                    });\n+                }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/ObservableValueFluentBindingsTest.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+package test.javafx.beans.value;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.beans.property.StringProperty;\n+\n+public class ObservableValueWhenTest {\n+\n+    @Nested\n+    class WhenNotObserved {\n+\n+        @Nested\n+        class AndConditionStartsFalse {\n+            BooleanProperty condition = new SimpleBooleanProperty(false);\n+\n+            @Test\n+            void shouldNeverCallDownstreamMapFunction() {\n+                StringProperty property = new SimpleStringProperty(\"a\");\n+                List<String> observedMappings = new ArrayList<>();\n+\n+                property.when(condition).map(observedMappings::add);\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                property.set(\"b\");\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                condition.set(true);\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                property.set(\"c\");\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                condition.set(false);\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                property.set(\"d\");\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                condition.set(true);\n+\n+                assertEquals(List.of(), observedMappings);\n+            }\n+        }\n+\n+        @Nested\n+        class AndConditionStartsTrue {\n+            BooleanProperty condition = new SimpleBooleanProperty(true);\n+\n+            @Test\n+            void shouldNeverCallDownstreamMapFunction() {\n+                StringProperty property = new SimpleStringProperty(\"a\");\n+                List<String> observedMappings = new ArrayList<>();\n+\n+                property.when(condition).map(observedMappings::add);\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                property.set(\"b\");\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                condition.set(false);\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                property.set(\"c\");\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                condition.set(true);\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                property.set(\"d\");\n+\n+                assertEquals(List.of(), observedMappings);\n+\n+                condition.set(false);\n+\n+                assertEquals(List.of(), observedMappings);\n+            }\n+        }\n+    }\n+\n+    @Nested\n+    class WhenObserved {\n+        @Nested\n+        class AndConditionStartsFalse {\n+            BooleanProperty condition = new SimpleBooleanProperty(false);\n+\n+            @Test\n+            void shouldCallDownstreamMapFunctionOnlyWhenAbsolutelyNecessary() {\n+                StringProperty property = new SimpleStringProperty(\"a\");\n+                List<String> observedMappings = new ArrayList<>();\n+                List<String> observedChanges = new ArrayList<>();\n+\n+                property.when(condition)\n+                    .map(x -> { observedMappings.add(x); return x; })\n+                    .addListener((obs, old, current) -> observedChanges.add(old + \" -> \" + current));\n+\n+                assertEquals(List.of(\"a\"), observedMappings);\n+                assertEquals(List.of(), observedChanges);\n+\n+                property.set(\"b\");\n+\n+                assertEquals(List.of(\"a\"), observedMappings);\n+                assertEquals(List.of(), observedChanges);\n+\n+                condition.set(true);\n+\n+                assertEquals(List.of(\"a\", \"b\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\"), observedChanges);\n+\n+                property.set(\"c\");\n+\n+                assertEquals(List.of(\"a\", \"b\", \"c\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\", \"b -> c\"), observedChanges);\n+\n+                condition.set(false);\n+\n+                assertEquals(List.of(\"a\", \"b\", \"c\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\", \"b -> c\"), observedChanges);\n+\n+                property.set(\"d\");\n+\n+                assertEquals(List.of(\"a\", \"b\", \"c\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\", \"b -> c\"), observedChanges);\n+\n+                condition.set(true);\n+\n+                assertEquals(List.of(\"a\", \"b\", \"c\", \"d\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\", \"b -> c\", \"c -> d\"), observedChanges);\n+            }\n+        }\n+\n+        @Nested\n+        class AndConditionStartsTrue {\n+            BooleanProperty condition = new SimpleBooleanProperty(true);\n+\n+            @Test\n+            void shouldCallDownstreamMapFunctionOnlyWhenAbsolutelyNecessary() {\n+                StringProperty property = new SimpleStringProperty(\"a\");\n+                List<String> observedMappings = new ArrayList<>();\n+                List<String> observedChanges = new ArrayList<>();\n+\n+                property.when(condition)\n+                    .map(x -> { observedMappings.add(x); return x; })\n+                    .addListener((obs, old, current) -> observedChanges.add(old + \" -> \" + current));\n+\n+                assertEquals(List.of(\"a\"), observedMappings);\n+                assertEquals(List.of(), observedChanges);\n+\n+                property.set(\"b\");\n+\n+                assertEquals(List.of(\"a\", \"b\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\"), observedChanges);\n+\n+                condition.set(false);\n+\n+                assertEquals(List.of(\"a\", \"b\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\"), observedChanges);\n+\n+                property.set(\"c\");\n+\n+                assertEquals(List.of(\"a\", \"b\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\"), observedChanges);\n+\n+                condition.set(true);\n+\n+                assertEquals(List.of(\"a\", \"b\", \"c\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\", \"b -> c\"), observedChanges);\n+\n+                property.set(\"d\");\n+\n+                assertEquals(List.of(\"a\", \"b\", \"c\", \"d\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\", \"b -> c\", \"c -> d\"), observedChanges);\n+\n+                condition.set(false);\n+\n+                assertEquals(List.of(\"a\", \"b\", \"c\", \"d\"), observedMappings);\n+                assertEquals(List.of(\"a -> b\", \"b -> c\", \"c -> d\"), observedChanges);\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/ObservableValueWhenTest.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"}]}