{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,1 @@\n+            setFontSize(getDouble(StyleAttributeMap.FONT_SIZE)).\n@@ -116,0 +117,8 @@\n+    private Double getDouble(Object attr) {\n+        Object v = attrs.get(attr);\n+        if (v instanceof Number n) {\n+            return n.doubleValue();\n+        }\n+        return null;\n+    }\n+\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/AttrSet.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,4 @@\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CoderResult;\n@@ -63,0 +67,6 @@\n+    \/\/ For fcharset control word\n+    protected CharsetDecoder decoder;\n+    protected final ByteBuffer decoderBB = ByteBuffer.wrap(new byte[2]);\n+    private final char[] decoderCA = new char[1];\n+    private final CharBuffer decoderCB = CharBuffer.wrap(decoderCA);\n+\n@@ -101,0 +111,3 @@\n+    \/\/ Defined for replacement character\n+    private static final char REPLACEMENT_CHAR = '\\uFFFD';\n+\n@@ -108,0 +121,3 @@\n+        \/\/ Initialize byte buffer for CharsetDecoder\n+        decoderBB.clear();\n+        decoderBB.limit(1);\n@@ -172,0 +188,3 @@\n+                \/\/ SBCS: ASCII character\n+                \/\/ DBCS: Non lead byte\n+                ch = decode(ch);\n@@ -289,1 +308,2 @@\n-                ch = translationTable[pendingCharacter];\n+                \/\/ Use translationTable if decoder is not defined\n+                ch = decoder == null ? translationTable[pendingCharacter] : decode((char)pendingCharacter);\n@@ -346,0 +366,29 @@\n+\n+    private char decode(char ch) {\n+        if (decoder == null) return ch;\n+        decoderBB.put((byte) ch);\n+        decoderBB.rewind();\n+        decoderCB.clear();\n+        CoderResult cr = decoder.decode(decoderBB, decoderCB, false);\n+        if (cr.isUnderflow()) {\n+            if (decoderCB.position() == 1) {\n+                \/\/ Converted to Unicode (including replacement character)\n+                decoder.reset();\n+                decoderBB.clear();\n+                decoderBB.limit(1);\n+                return decoderCA[0];\n+            } else {\n+                \/\/ Detected lead byte\n+                decoder.reset();\n+                decoderBB.limit(2);\n+                decoderBB.position(1);\n+                return 0; \/\/ Skip write operation if return value is 0\n+            }\n+        } else {\n+            \/\/ Fallback, should not be called\n+            decoder.reset();\n+            decoderBB.clear();\n+            decoderBB.limit(1);\n+            return REPLACEMENT_CHAR;\n+        }\n+    }\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/RTFParser.java","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.nio.charset.Charset;\n+import java.nio.charset.CodingErrorAction;\n@@ -119,2 +121,28 @@\n-\n-    \/* TODO: per-font font encodings ( \\fcharset control word ) ? *\/\n+    \/** maps String font charset to String code page. *\/\n+    private static HashMap<String, String> fcharsetToCP = initFCharsetToCP();\n+    \/** maps Integer font numbers to Charset font charset. *\/\n+    private HashMap<Integer, Charset> fcharsetTable = new HashMap<>();\n+\n+    \/\/ Windows charsets\n+    private static final int ANSI_CHARSET        = 0;\n+    private static final int DEFAULT_CHARSET     = 1;\n+    private static final int SYMBOL_CHARSET      = 2;\n+    private static final int MAC_CHARSET         = 77;\n+    private static final int SHIFTJIS_CHARSET    = 128;\n+    private static final int HANGUL_CHARSET      = 129;\n+    private static final int JOHAB_CHARSET       = 130;\n+    private static final int GB2312_CHARSET      = 134;\n+    private static final int CHINESEBIG5_CHARSET = 136;\n+    private static final int GREEK_CHARSET       = 161;\n+    private static final int TURKISH_CHARSET     = 162;\n+    private static final int VIETNAMESE_CHARSET  = 163;\n+    private static final int HEBREW_CHARSET      = 177;\n+    private static final int ARABIC_CHARSET      = 178;\n+    private static final int BALTIC_CHARSET      = 186;\n+    private static final int RUSSIAN_CHARSET     = 204;\n+    private static final int THAI_CHARSET        = 222;\n+    private static final int EASTEUROPE_CHARSET  = 238;\n+    private static final int OEM_CHARSET         = 255;\n+\n+    \/\/ Defined for replacement character\n+    private static final String REPLACEMENT_CHAR = \"\\uFFFD\";\n@@ -128,1 +156,0 @@\n-        \/\/System.err.println(text); \/\/ FIX\n@@ -161,0 +188,1 @@\n+        m.put(\"line\", \"\\n\");\n@@ -176,0 +204,20 @@\n+    private static HashMap<String, String> initFCharsetToCP() {\n+        HashMap<String, String> m = new HashMap<String, String>();\n+        m.put(\"fcharset\" + ANSI_CHARSET, \"windows-1252\");\n+        m.put(\"fcharset\" + SHIFTJIS_CHARSET, \"ms932\");\n+        m.put(\"fcharset\" + HANGUL_CHARSET, \"ms949\");\n+        m.put(\"fcharset\" + JOHAB_CHARSET, \"ms1361\");\n+        m.put(\"fcharset\" + GB2312_CHARSET, \"ms936\");\n+        m.put(\"fcharset\" + CHINESEBIG5_CHARSET, \"ms950\");\n+        m.put(\"fcharset\" + GREEK_CHARSET, \"windows-1253\");\n+        m.put(\"fcharset\" + TURKISH_CHARSET, \"windows-1254\");\n+        m.put(\"fcharset\" + VIETNAMESE_CHARSET, \"windows-1258\");\n+        m.put(\"fcharset\" + HEBREW_CHARSET, \"windows-1255\");\n+        m.put(\"fcharset\" + ARABIC_CHARSET, \"windows-1256\");\n+        m.put(\"fcharset\" + BALTIC_CHARSET, \"windows-1257\");\n+        m.put(\"fcharset\" + RUSSIAN_CHARSET, \"windows-1251\");\n+        m.put(\"fcharset\" + THAI_CHARSET, \"ms874\");\n+        m.put(\"fcharset\" + EASTEUROPE_CHARSET, \"windows-1250\");\n+        return m;\n+    }\n+\n@@ -706,0 +754,19 @@\n+            \/\/ For fcharset control word\n+            if (keyword.equals(\"fcharset\")) {\n+                String fcharset = keyword + parameter;\n+                String csName = fcharsetToCP.get(fcharset);\n+                Charset cs;\n+                if (csName != null) {\n+                    try {\n+                        cs = Charset.forName(csName);\n+                    } catch (IllegalArgumentException iae) {\n+                        \/\/ Fallback, should not be called\n+                        cs = StandardCharsets.ISO_8859_1;\n+                    }\n+                } else {\n+                    \/\/ Fallback, fcharset control word number is not defined\n+                    cs = StandardCharsets.ISO_8859_1;\n+                }\n+                fcharsetTable.put(nextFontNumber, cs);\n+                return true;\n+            }\n@@ -1066,0 +1133,18 @@\n+                \/\/ Check lead byte is stored or not\n+                if (decoderBB.position() == 1) {\n+                    handleText(REPLACEMENT_CHAR);\n+                }\n+                \/\/ Reset decoder byte buffer\n+                decoderBB.clear();\n+                decoderBB.limit(1);\n+                \/\/ Check fcharset is used or not\n+                Charset cs = fcharsetTable.get(parameter);\n+                if (cs != null) {\n+                    decoder = cs.newDecoder();\n+                    decoder\n+                        .onMalformedInput(CodingErrorAction.REPLACE)\n+                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+                } else {\n+                    \/\/ fcharset is not used, use translationTable\n+                    decoder = null;\n+                }\n@@ -1170,1 +1255,1 @@\n-                characterAttributes.addAttribute(StyleAttributeMap.FONT_SIZE, (parameter \/ 2));\n+                characterAttributes.addAttribute(StyleAttributeMap.FONT_SIZE, (parameter \/ 2.0));\n@@ -1428,0 +1513,6 @@\n+                \/\/ Check lead byte is stored or not\n+                if (decoderBB.position() == 1) {\n+                    handleText(REPLACEMENT_CHAR);\n+                    decoderBB.clear();\n+                    decoderBB.limit(1);\n+                }\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/RTFReader.java","additions":95,"deletions":4,"binary":false,"changes":99,"status":"modified"}]}