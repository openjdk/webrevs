{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+        addAttributes(a);\n@@ -87,1 +88,2 @@\n-        return StyleAttributeMap.builder().\n+        StyleAttributeMap.Builder b = StyleAttributeMap.builder();\n+        b.\n@@ -91,0 +93,1 @@\n+            setStrikeThrough(getBoolean(StyleAttributeMap.STRIKE_THROUGH)).\n@@ -92,2 +95,6 @@\n-            setUnderline(getBoolean(StyleAttributeMap.UNDERLINE)).\n-            build();\n+            setUnderline(getBoolean(StyleAttributeMap.UNDERLINE));\n+        Double d = getDouble(StyleAttributeMap.FONT_SIZE);\n+        if (d != null) {\n+            b.setFontSize(d);\n+        }\n+        return b.build();\n@@ -116,0 +123,8 @@\n+    private Double getDouble(Object attr) {\n+        Object v = attrs.get(attr);\n+        if (v instanceof Number n) {\n+            return n.doubleValue();\n+        }\n+        return null;\n+    }\n+\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/AttrSet.java","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,4 @@\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CoderResult;\n@@ -63,0 +67,6 @@\n+    \/\/ For fcharset control word\n+    protected CharsetDecoder decoder;\n+    protected final ByteBuffer decoderBB = ByteBuffer.wrap(new byte[2]);\n+    private final char[] decoderCA = new char[1];\n+    private final CharBuffer decoderCB = CharBuffer.wrap(decoderCA);\n+\n@@ -101,0 +111,3 @@\n+    \/\/ Defined for replacement character\n+    private static final char REPLACEMENT_CHAR = '\\uFFFD';\n+\n@@ -108,0 +121,3 @@\n+        \/\/ Initialize byte buffer for CharsetDecoder\n+        decoderBB.clear();\n+        decoderBB.limit(1);\n@@ -172,0 +188,3 @@\n+                \/\/ SBCS: ASCII character\n+                \/\/ DBCS: Non lead byte\n+                ch = decode(ch);\n@@ -289,1 +308,2 @@\n-                ch = translationTable[pendingCharacter];\n+                \/\/ Use translationTable if decoder is not defined\n+                ch = decoder == null ? translationTable[pendingCharacter] : decode((char)pendingCharacter);\n@@ -346,0 +366,29 @@\n+\n+    private char decode(char ch) {\n+        if (decoder == null) return ch;\n+        decoderBB.put((byte) ch);\n+        decoderBB.rewind();\n+        decoderCB.clear();\n+        CoderResult cr = decoder.decode(decoderBB, decoderCB, false);\n+        if (cr.isUnderflow()) {\n+            if (decoderCB.position() == 1) {\n+                \/\/ Converted to Unicode (including replacement character)\n+                decoder.reset();\n+                decoderBB.clear();\n+                decoderBB.limit(1);\n+                return decoderCA[0];\n+            } else {\n+                \/\/ Detected lead byte\n+                decoder.reset();\n+                decoderBB.limit(2);\n+                decoderBB.position(1);\n+                return 0; \/\/ Skip write operation if return value is 0\n+            }\n+        } else {\n+            \/\/ Fallback, should not be called\n+            decoder.reset();\n+            decoderBB.clear();\n+            decoderBB.limit(1);\n+            return REPLACEMENT_CHAR;\n+        }\n+    }\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/RTFParser.java","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.nio.charset.Charset;\n+import java.nio.charset.CodingErrorAction;\n@@ -119,2 +121,28 @@\n-\n-    \/* TODO: per-font font encodings ( \\fcharset control word ) ? *\/\n+    \/** maps String font charset to String code page. *\/\n+    private static HashMap<String, String> fcharsetToCP = initFCharsetToCP();\n+    \/** maps Integer font numbers to Charset font charset. *\/\n+    private HashMap<Integer, Charset> fcharsetTable = new HashMap<>();\n+\n+    \/\/ Windows charsets\n+    private static final int ANSI_CHARSET        = 0;\n+    private static final int DEFAULT_CHARSET     = 1;\n+    private static final int SYMBOL_CHARSET      = 2;\n+    private static final int MAC_CHARSET         = 77;\n+    private static final int SHIFTJIS_CHARSET    = 128;\n+    private static final int HANGUL_CHARSET      = 129;\n+    private static final int JOHAB_CHARSET       = 130;\n+    private static final int GB2312_CHARSET      = 134;\n+    private static final int CHINESEBIG5_CHARSET = 136;\n+    private static final int GREEK_CHARSET       = 161;\n+    private static final int TURKISH_CHARSET     = 162;\n+    private static final int VIETNAMESE_CHARSET  = 163;\n+    private static final int HEBREW_CHARSET      = 177;\n+    private static final int ARABIC_CHARSET      = 178;\n+    private static final int BALTIC_CHARSET      = 186;\n+    private static final int RUSSIAN_CHARSET     = 204;\n+    private static final int THAI_CHARSET        = 222;\n+    private static final int EASTEUROPE_CHARSET  = 238;\n+    private static final int OEM_CHARSET         = 255;\n+\n+    \/\/ Defined for replacement character\n+    private static final String REPLACEMENT_CHAR = \"\\uFFFD\";\n@@ -128,1 +156,0 @@\n-        \/\/System.err.println(text); \/\/ FIX\n@@ -161,0 +188,1 @@\n+        m.put(\"line\", \"\\n\");\n@@ -176,0 +204,20 @@\n+    private static HashMap<String, String> initFCharsetToCP() {\n+        HashMap<String, String> m = new HashMap<String, String>();\n+        m.put(\"fcharset\" + ANSI_CHARSET, \"windows-1252\");\n+        m.put(\"fcharset\" + SHIFTJIS_CHARSET, \"ms932\");\n+        m.put(\"fcharset\" + HANGUL_CHARSET, \"ms949\");\n+        m.put(\"fcharset\" + JOHAB_CHARSET, \"ms1361\");\n+        m.put(\"fcharset\" + GB2312_CHARSET, \"ms936\");\n+        m.put(\"fcharset\" + CHINESEBIG5_CHARSET, \"ms950\");\n+        m.put(\"fcharset\" + GREEK_CHARSET, \"windows-1253\");\n+        m.put(\"fcharset\" + TURKISH_CHARSET, \"windows-1254\");\n+        m.put(\"fcharset\" + VIETNAMESE_CHARSET, \"windows-1258\");\n+        m.put(\"fcharset\" + HEBREW_CHARSET, \"windows-1255\");\n+        m.put(\"fcharset\" + ARABIC_CHARSET, \"windows-1256\");\n+        m.put(\"fcharset\" + BALTIC_CHARSET, \"windows-1257\");\n+        m.put(\"fcharset\" + RUSSIAN_CHARSET, \"windows-1251\");\n+        m.put(\"fcharset\" + THAI_CHARSET, \"ms874\");\n+        m.put(\"fcharset\" + EASTEUROPE_CHARSET, \"windows-1250\");\n+        return m;\n+    }\n+\n@@ -706,0 +754,19 @@\n+            \/\/ For fcharset control word\n+            if (keyword.equals(\"fcharset\")) {\n+                String fcharset = keyword + parameter;\n+                String csName = fcharsetToCP.get(fcharset);\n+                Charset cs;\n+                if (csName != null) {\n+                    try {\n+                        cs = Charset.forName(csName);\n+                    } catch (IllegalArgumentException iae) {\n+                        \/\/ Fallback, should not be called\n+                        cs = StandardCharsets.ISO_8859_1;\n+                    }\n+                } else {\n+                    \/\/ Fallback, fcharset control word number is not defined\n+                    cs = StandardCharsets.ISO_8859_1;\n+                }\n+                fcharsetTable.put(nextFontNumber, cs);\n+                return true;\n+            }\n@@ -1066,0 +1133,18 @@\n+                \/\/ Check lead byte is stored or not\n+                if (decoderBB.position() == 1) {\n+                    handleText(REPLACEMENT_CHAR);\n+                }\n+                \/\/ Reset decoder byte buffer\n+                decoderBB.clear();\n+                decoderBB.limit(1);\n+                \/\/ Check fcharset is used or not\n+                Charset cs = fcharsetTable.get(parameter);\n+                if (cs != null) {\n+                    decoder = cs.newDecoder();\n+                    decoder\n+                        .onMalformedInput(CodingErrorAction.REPLACE)\n+                        .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+                } else {\n+                    \/\/ fcharset is not used, use translationTable\n+                    decoder = null;\n+                }\n@@ -1170,1 +1255,1 @@\n-                characterAttributes.addAttribute(StyleAttributeMap.FONT_SIZE, (parameter \/ 2));\n+                characterAttributes.addAttribute(StyleAttributeMap.FONT_SIZE, (parameter \/ 2.0));\n@@ -1428,0 +1513,6 @@\n+                \/\/ Check lead byte is stored or not\n+                if (decoderBB.position() == 1) {\n+                    handleText(REPLACEMENT_CHAR);\n+                    decoderBB.clear();\n+                    decoderBB.limit(1);\n+                }\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/rtf\/RTFReader.java","additions":95,"deletions":4,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.jfx.incubator.scene.control.richtext.model;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import java.io.ByteArrayInputStream;\n+import java.nio.charset.StandardCharsets;\n+import javafx.scene.input.DataFormat;\n+import javafx.scene.paint.Color;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.RichTextModel;\n+import jfx.incubator.scene.control.richtext.model.StyleAttribute;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+\n+\/**\n+ * Tests RTF Import in RichTextModel.\n+ *\/\n+public class RTFImportTest {\n+    private RichTextModel model;\n+\n+    @BeforeEach\n+    public void beforeEach() {\n+        model = new RichTextModel();\n+    }\n+\n+    @Test\n+    public void characterAttributes() throws Exception {\n+        initModel(\n+            \"\"\"\n+            {\/rtf1\/ansi\/ansicpg1252\/cocoartf2821\n+            \/cocoatextscaling0\/cocoaplatform0{\/fonttbl\/f0\/fswiss\/fcharset0 Helvetica-Bold;\/f1\/fswiss\/fcharset0 Helvetica;\/f2\/fswiss\/fcharset0 ArialMT;\n+            \/f3\/fswiss\/fcharset0 Helvetica-Oblique;}\n+            {\/colortbl;\/red255\/green255\/blue255;\/red0\/green0\/blue0;\/red251\/green0\/blue7;}\n+            {\/*\/expandedcolortbl;;\/cssrgb\/c0\/c0\/c0;\/cssrgb\/c100000\/c0\/c0;}\n+            \/margl1440\/margr1440\/vieww11520\/viewh9000\/viewkind0\n+            \/deftab720\n+            \/pard\/pardeftab720\/partightenfactor0\n+\n+            \/f0\/b\/fs24 \/cf2 \/expnd0\/expndtw0\/kerning0\n+            bold\n+            \/f1\/b0 \/\n+\n+            \/f2\/fs36 font\n+            \/f1\/fs24 \/\n+            \/pard\/pardeftab720\/partightenfactor0\n+\n+            \/f3\/i \/cf2 italic\n+            \/f1\/i0 \/\n+            \/pard\/pardeftab720\/partightenfactor0\n+            \/cf2 \/strike \/strikec2 strikethrough\/strike0\/striked0 \/\n+            \/pard\/pardeftab720\/partightenfactor0\n+            \/cf3 text color\/cf2 \/\n+            \/pard\/pardeftab720\/sl398\/sa213\/partightenfactor0\n+            \/cf2 \/ul \/ulc2 underline\/ulnone \/\n+            }\n+            \"\"\");\n+\n+        assertEquals(7, model.size());\n+        \/\/ bold\n+        int ix = 0;\n+        checkCharAttr(ix, StyleAttributeMap.BOLD, Boolean.TRUE);\n+        checkCharAttr(ix, StyleAttributeMap.ITALIC, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.STRIKE_THROUGH, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.UNDERLINE, Boolean.FALSE);\n+        ix++;\n+        \/\/ font\n+        checkCharAttr(ix, StyleAttributeMap.BOLD, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.FONT_FAMILY, \"ArialMT\");\n+        checkCharAttr(ix, StyleAttributeMap.FONT_SIZE, 18.0);\n+        checkCharAttr(ix, StyleAttributeMap.ITALIC, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.STRIKE_THROUGH, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.UNDERLINE, Boolean.FALSE);\n+        ix++;\n+        \/\/ italic\n+        checkCharAttr(ix, StyleAttributeMap.BOLD, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.ITALIC, Boolean.TRUE);\n+        checkCharAttr(ix, StyleAttributeMap.STRIKE_THROUGH, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.UNDERLINE, Boolean.FALSE);\n+        ix++;\n+        \/\/ strikethrough\n+        checkCharAttr(ix, StyleAttributeMap.BOLD, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.ITALIC, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.STRIKE_THROUGH, Boolean.TRUE);\n+        checkCharAttr(ix, StyleAttributeMap.UNDERLINE, Boolean.FALSE);\n+        ix++;\n+        \/\/ text color\n+        checkCharAttr(ix, StyleAttributeMap.BOLD, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.ITALIC, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.TEXT_COLOR, Color.rgb(251, 0, 7));\n+        checkCharAttr(ix, StyleAttributeMap.STRIKE_THROUGH, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.UNDERLINE, Boolean.FALSE);\n+        ix++;\n+        \/\/ underline\n+        checkCharAttr(ix, StyleAttributeMap.BOLD, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.ITALIC, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.STRIKE_THROUGH, Boolean.FALSE);\n+        checkCharAttr(ix, StyleAttributeMap.UNDERLINE, Boolean.TRUE);\n+    }\n+\n+    @Test\n+    public void paragraphAttributes() throws Exception {\n+        \/\/ TODO\n+        \/\/ background color\n+        \/\/ bullet point\n+        \/\/ first line indent\n+        \/\/ line spacing\n+        \/\/ paragraph direction\n+        \/\/ space (above | below | left | right)\n+        \/\/ text alignment\n+    }\n+\n+    private <T> void checkCharAttr(int paragraphIndex, StyleAttribute<T> attribute, T value) {\n+        TextPos end = model.getEndOfParagraphTextPos(paragraphIndex);\n+        TextPos p = TextPos.ofLeading(paragraphIndex, end.charIndex() \/ 2);\n+        StyleAttributeMap attrs = model.getStyleAttributeMap(null, p);\n+\n+        assertEquals(value, attrs.get(attribute));\n+    }\n+\n+    private void initModel(String mangledRTF) throws Exception {\n+        \/\/ demangle to RTF (replace \/ with \\ characters)\n+        String rtf = mangledRTF.replace('\/', '\\\\');\n+        ByteArrayInputStream in = new ByteArrayInputStream(rtf.getBytes(StandardCharsets.US_ASCII));\n+        model.read(null, DataFormat.RTF, in);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/jfx\/incubator\/scene\/control\/richtext\/model\/RTFImportTest.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"}]}