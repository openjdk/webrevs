{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,0 +93,4 @@\n+    public static Window getWindowOwner(Window window) {\n+        return windowAccessor.getWindowOwner(window);\n+    }\n+\n@@ -148,0 +152,1 @@\n+        Window getWindowOwner(Window window);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/stage\/WindowHelper.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.stage;\n+\n+import javafx.stage.Screen;\n+\n+public interface WindowLocationAlgorithm {\n+\n+    record ComputedLocation(\n+        double x, double y,\n+        double xGravity, double yGravity) {}\n+\n+    ComputedLocation compute(Screen screen, double windowWidth, double windowHeight);\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/stage\/WindowLocationAlgorithm.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,327 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.stage;\n+\n+import com.sun.javafx.util.Utils;\n+import javafx.geometry.AnchorPoint;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Point2D;\n+import javafx.geometry.Rectangle2D;\n+import javafx.stage.AnchorPolicy;\n+import javafx.stage.Screen;\n+import javafx.stage.Window;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public final class WindowRelocator {\n+\n+    private WindowRelocator() {}\n+\n+    \/**\n+     * Creates a location algorithm that computes the position of the {@link Window} at the requested screen\n+     * coordinates using an {@link AnchorPoint}, {@link AnchorPolicy}, and per-edge screen constraints.\n+     * {@code screenAnchor} is specified relative to {@code userScreen}. If {@code userScreen} is {@code null},\n+     * the screen anchor is specified relative to the current window screen; if the window has not been shown\n+     * yet, it is specified relative to the primary screen.\n+     * <p>\n+     * Screen edge constraints are specified by {@code screenPadding}:\n+     * <ul>\n+     *     <li>values {@code >= 0} enable a constraint for the corresponding edge (minimum distance to keep)\n+     *     <li>values {@code < 0} disable the constraint for that edge\n+     * <\/ul>\n+     * Enabled constraints reduce the usable area for placement by the given insets.\n+     *\/\n+    public static WindowLocationAlgorithm newRelocationAlgorithm(Screen userScreen,\n+                                                                 AnchorPoint screenAnchor,\n+                                                                 Insets screenPadding,\n+                                                                 AnchorPoint stageAnchor,\n+                                                                 AnchorPolicy anchorPolicy) {\n+        Objects.requireNonNull(screenAnchor, \"screenAnchor cannot be null\");\n+        Objects.requireNonNull(screenPadding, \"screenPadding cannot be null\");\n+        Objects.requireNonNull(stageAnchor, \"stageAnchor cannot be null\");\n+        Objects.requireNonNull(anchorPolicy, \"anchorPolicy cannot be null\");\n+\n+        return (windowScreen, windowWidth, windowHeight) -> {\n+            double screenX, screenY;\n+            double gravityX, gravityY;\n+            Screen currentScreen = Objects.requireNonNullElse(userScreen, windowScreen);\n+            Rectangle2D currentBounds = Utils.hasFullScreenStage(currentScreen)\n+                ? currentScreen.getBounds()\n+                : currentScreen.getVisualBounds();\n+\n+            \/\/ Compute the absolute coordinates of the screen anchor.\n+            \/\/ If the screen anchor is specified in proportional coordinates, it is proportional to the complete\n+            \/\/ screen bounds when a full-screen stage is showing on the screen, and the visual bounds otherwise.\n+            if (screenAnchor.isProportional()) {\n+                screenX = currentBounds.getMinX() + screenAnchor.getX() * currentBounds.getWidth();\n+                screenY = currentBounds.getMinY() + screenAnchor.getY() * currentBounds.getHeight();\n+            } else {\n+                screenX = currentBounds.getMinX() + screenAnchor.getX();\n+                screenY = currentBounds.getMinY() + screenAnchor.getY();\n+            }\n+\n+            \/\/ The absolute screen anchor might be on a different screen than the current window, so we\n+            \/\/ need to recompute the actual screen and its bounds (complete when full-screen stage showing,\n+            \/\/ visual otherwise).\n+            Screen targetScreen = Utils.getScreenForPoint(screenX, screenY);\n+            Rectangle2D screenBounds = Utils.hasFullScreenStage(targetScreen)\n+                ? targetScreen.getBounds()\n+                : targetScreen.getVisualBounds();\n+\n+            Point2D location = computeAdjustedLocation(\n+                screenX, screenY,\n+                windowWidth, windowHeight,\n+                stageAnchor, anchorPolicy,\n+                screenBounds, screenPadding);\n+\n+            if (stageAnchor.isProportional()) {\n+                gravityX = stageAnchor.getX();\n+                gravityY = stageAnchor.getY();\n+            } else {\n+                gravityX = stageAnchor.getX() \/ windowWidth;\n+                gravityY = stageAnchor.getY() \/ windowHeight;\n+            }\n+\n+            return new WindowLocationAlgorithm.ComputedLocation(location.getX(), location.getY(), gravityX, gravityY);\n+        };\n+    }\n+\n+    \/**\n+     * Computes the adjusted top-left location of a window for a requested anchor position on screen.\n+     * <p>\n+     * The requested screen coordinates {@code (screenX, screenY)} are interpreted as the desired location\n+     * of {@code anchor} on the window. The raw (unadjusted) window position is derived from the anchor and\n+     * the given {@code width}\/{@code height}. If that raw position violates any enabled constraints, the\n+     * method considers alternative anchors depending on {@code policy} (for example, horizontally and\/or\n+     * vertically flipped anchors) and chooses the alternative that yields the smallest adjustment after\n+     * constraints are applied.\n+     * <p>\n+     * Screen edge constraints are specified by {@code screenPadding}:\n+     * values {@code >= 0} enable a constraint for the corresponding edge (minimum distance to keep),\n+     * values {@code < 0} disable the constraint for that edge. Enabled constraints reduce the usable area\n+     * for placement by the given insets.\n+     *\/\n+    public static Point2D computeAdjustedLocation(double screenX, double screenY,\n+                                                  double width, double height,\n+                                                  AnchorPoint anchor, AnchorPolicy policy,\n+                                                  Rectangle2D screenBounds, Insets screenPadding) {\n+        Constraints constraints = computeConstraints(screenBounds, width, height, screenPadding);\n+        Position preferredRaw = getRawForAnchor(screenX, screenY, anchor, width, height);\n+        boolean validH = isHorizontalValid(preferredRaw, constraints);\n+        boolean validV = isVerticalValid(preferredRaw, constraints);\n+        if (validH && validV) {\n+            return new Point2D(preferredRaw.x, preferredRaw.y);\n+        }\n+\n+        List<AnchorPoint> alternatives = computeAlternatives(anchor, policy, validH, validV, width, height);\n+        Point2D bestAdjusted = applyConstraints(preferredRaw, constraints);\n+        double bestCost = getAdjustmentCost(preferredRaw, bestAdjusted);\n+\n+        for (AnchorPoint alternative : alternatives) {\n+            Position raw = getRawForAnchor(screenX, screenY, alternative, width, height);\n+            Point2D adjusted = applyConstraints(raw, constraints);\n+            double cost = getAdjustmentCost(raw, adjusted);\n+\n+            if (cost < bestCost) {\n+                bestCost = cost;\n+                bestAdjusted = adjusted;\n+            }\n+        }\n+\n+        return bestAdjusted;\n+    }\n+\n+    \/**\n+     * Computes effective constraints from screen bounds, window size, and edge insets.\n+     * <p>\n+     * For each inset value:\n+     * <ul>\n+     *   <li>{@code >= 0} enables a constraint for that edge\n+     *   <li>{@code < 0} disables the constraint for that edge\n+     * <\/ul>\n+     * Enabled constraints shrink the usable region by the given amounts. The computed {@code maxX}\n+     * and {@code maxY} incorporate the window size (i.e., they are the maximum allowed top-left\n+     * coordinates that still keep the window within the constrained region).\n+     *\/\n+    private static Constraints computeConstraints(Rectangle2D screenBounds,\n+                                                  double width, double height,\n+                                                  Insets screenPadding) {\n+        boolean hasMinX = screenPadding.getLeft() >= 0;\n+        boolean hasMaxX = screenPadding.getRight() >= 0;\n+        boolean hasMinY = screenPadding.getTop() >= 0;\n+        boolean hasMaxY = screenPadding.getBottom() >= 0;\n+\n+        double minX = screenBounds.getMinX() + (hasMinX ? screenPadding.getLeft() : 0);\n+        double maxX = screenBounds.getMaxX() - (hasMaxX ? screenPadding.getRight() : 0) - width;\n+        double minY = screenBounds.getMinY() + (hasMinY ? screenPadding.getTop() : 0);\n+        double maxY = screenBounds.getMaxY() - (hasMaxY ? screenPadding.getBottom() : 0) - height;\n+\n+        return new Constraints(hasMinX, hasMaxX, hasMinY, hasMaxY, minX, maxX, minY, maxY);\n+    }\n+\n+    \/**\n+     * Computes the raw (unadjusted) top-left position for the given anchor.\n+     * <p>\n+     * The result is the position at which the window would be located if no edge constraints were applied.\n+     *\/\n+    private static Position getRawForAnchor(double screenX, double screenY, AnchorPoint anchor,\n+                                            double width, double height) {\n+        double x, y, relX, relY;\n+\n+        if (anchor.isProportional()) {\n+            x = width * anchor.getX();\n+            y = height * anchor.getY();\n+            relX = anchor.getX();\n+            relY = anchor.getY();\n+        } else {\n+            x = anchor.getX();\n+            y = anchor.getY();\n+            relX = width  != 0 ? anchor.getX() \/ width : 0;\n+            relY = height != 0 ? anchor.getY() \/ height : 0;\n+        }\n+\n+        return new Position(screenX - x, screenY - y, relX, relY);\n+    }\n+\n+    \/**\n+     * Computes the list of alternative candidate anchors to consider, based on the requested policy\n+     * and which constraint the preferred placement violates.\n+     * <p>\n+     * Candidates are ordered from most preferred to least preferred for the given policy.\n+     *\/\n+    private static List<AnchorPoint> computeAlternatives(AnchorPoint preferred, AnchorPolicy policy,\n+                                                         boolean validH, boolean validV,\n+                                                         double width, double height) {\n+        return switch (policy) {\n+            case FIXED -> List.of();\n+\n+            case FLIP_HORIZONTAL -> validH\n+                ? List.of()\n+                : List.of(flipAnchor(preferred, width, height, true, false));\n+\n+            case FLIP_VERTICAL -> validV\n+                ? List.of()\n+                : List.of(flipAnchor(preferred, width, height, false, true));\n+\n+            case AUTO -> {\n+                if (!validH && !validV) {\n+                    \/\/ Try diagonal flip first, then horizontal flip, then vertical flip\n+                    yield List.of(\n+                        flipAnchor(preferred, width, height, true, true),\n+                        flipAnchor(preferred, width, height, true, false),\n+                        flipAnchor(preferred, width, height, false, true));\n+                } else if (!validH) {\n+                    yield List.of(flipAnchor(preferred, width, height, true, false));\n+                } else if (!validV) {\n+                    yield List.of(flipAnchor(preferred, width, height, false, true));\n+                } else{\n+                    yield List.of();\n+                }\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Applies enabled edge constraints to a raw position.\n+     * <p>\n+     * Constraints may be disabled per edge (via negative inset values). When both edges for an axis\n+     * are enabled, the position is constrained to the resulting interval. When only one edge is enabled,\n+     * a one-sided minimum or maximum constraint is applied. If the constrained interval is too small to\n+     * fit the window, a side is chosen based on the relative anchor location.\n+     *\/\n+    private static Point2D applyConstraints(Position raw, Constraints c) {\n+        double x = raw.x;\n+        double y = raw.y;\n+\n+        if (c.hasMinX && c.hasMaxX) {\n+            if (c.maxX >= c.minX) {\n+                x = Utils.clamp(c.minX, x, c.maxX);\n+            } else {\n+                \/\/ Constrained space too small: choose a side based on anchor\n+                x = raw.relX > 0.5 ? c.maxX : c.minX;\n+            }\n+        } else if (c.hasMinX) {\n+            x = Math.max(x, c.minX);\n+        } else if (c.hasMaxX) {\n+            x = Math.min(x, c.maxX);\n+        }\n+\n+        if (c.hasMinY && c.hasMaxY) {\n+            if (c.maxY >= c.minY) {\n+                y = Utils.clamp(c.minY, y, c.maxY);\n+            } else {\n+                \/\/ Constrained space too small: choose a side based on anchor\n+                y = raw.relY > 0.5 ? c.maxY : c.minY;\n+            }\n+        } else if (c.hasMinY) {\n+            y = Math.max(y, c.minY);\n+        } else if (c.hasMaxY) {\n+            y = Math.min(y, c.maxY);\n+        }\n+\n+        return new Point2D(x, y);\n+    }\n+\n+    \/**\n+     * Computes a scalar \"adjustment cost\" used to select between candidate anchors.\n+     * <p>\n+     * The current implementation uses Manhattan distance (|dx| + |dy|) between the raw and adjusted positions.\n+     * Lower values indicate that fewer or smaller constraint adjustments were required.\n+     *\/\n+    private static double getAdjustmentCost(Position raw, Point2D adjusted) {\n+        return Math.abs(adjusted.getX() - raw.x) + Math.abs(adjusted.getY() - raw.y);\n+    }\n+\n+    private static boolean isHorizontalValid(Position raw, Constraints c) {\n+        return !(c.hasMinX && raw.x < c.minX) && !(c.hasMaxX && raw.x > c.maxX);\n+    }\n+\n+    private static boolean isVerticalValid(Position raw, Constraints c) {\n+        return !(c.hasMinY && raw.y < c.minY) && !(c.hasMaxY && raw.y > c.maxY);\n+    }\n+\n+    private static AnchorPoint flipAnchor(AnchorPoint anchor,\n+                                          double width, double height,\n+                                          boolean flipH, boolean flipV) {\n+        double x = anchor.getX();\n+        double y = anchor.getY();\n+\n+        return anchor.isProportional()\n+            ? AnchorPoint.proportional(\n+                flipH ? (1.0 - x) : x,\n+                flipV ? (1.0 - y) : y)\n+            : AnchorPoint.absolute(\n+                flipH ? (width - x) : x,\n+                flipV ? (height - y) : y);\n+    }\n+\n+    private record Constraints(boolean hasMinX, boolean hasMaxX,\n+                               boolean hasMinY, boolean hasMaxY,\n+                               double minX, double maxX,\n+                               double minY, double maxY) {}\n+\n+    private record Position(double x, double y, double relX, double relY) {}\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/stage\/WindowRelocator.java","additions":327,"deletions":0,"binary":false,"changes":327,"status":"added"},{"patch":"@@ -49,0 +49,1 @@\n+import com.sun.javafx.stage.WindowHelper;\n@@ -749,0 +750,18 @@\n+    public static Screen getScreenForWindow(Window window) {\n+        do {\n+            if (!Double.isNaN(window.getX()) && !Double.isNaN(window.getY())) {\n+                if (window.getWidth() >= 0 && window.getHeight() >= 0) {\n+                    var bounds = new Rectangle2D(window.getX(), window.getY(),\n+                                                 window.getWidth(), window.getHeight());\n+                    return getScreenForRectangle(bounds);\n+                } else {\n+                    return getScreenForPoint(window.getX(), window.getY());\n+                }\n+            }\n+\n+            window = WindowHelper.getWindowOwner(window);\n+        } while (window != null);\n+\n+        return Screen.getPrimary();\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/util\/Utils.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,192 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.geometry;\n+\n+\/**\n+ * Represents a reference point within a target area, used for anchoring geometry-dependent calculations\n+ * such as positioning a window relative to another location.\n+ * <p>\n+ * An {@code AnchorPoint} provides a {@code (x, y)} coordinate together with a flag indicating\n+ * how those coordinates should be interpreted:\n+ * <ul>\n+ *   <li>Proportional: {@code x} and {@code y} are expressed as fractions of the target width and height.\n+ *       In this coordinate system, {@code (0, 0)} refers to the top-left corner, and {@code (1, 1)} refers to\n+ *       the bottom-right corner. Values outside the {@code [0..1]} range represent points outside the bounds.\n+ *   <li>Absolute: {@code x} and {@code y} are expressed as offsets from the top-left corner of the target area.\n+ * <\/ul>\n+ *\n+ * @since 26\n+ *\/\n+public final class AnchorPoint {\n+\n+    \/**\n+     * Anchor at the top-left corner of the target area.\n+     * <p>\n+     * This constant is equivalent to {@code AnchorPoint.proportional(0, 0)}.\n+     *\/\n+    public static final AnchorPoint TOP_LEFT = new AnchorPoint(0, 0, true);\n+\n+    \/**\n+     * Anchor at the top-center midpoint of the target area.\n+     * <p>\n+     * This constant is equivalent to {@code AnchorPoint.proportional(0.5, 0)}.\n+     *\/\n+    public static final AnchorPoint TOP_CENTER = new AnchorPoint(0.5, 0, true);\n+\n+    \/**\n+     * Anchor at the top-right corner of the target area.\n+     * <p>\n+     * This constant is equivalent to {@code AnchorPoint.proportional(1, 0)}.\n+     *\/\n+    public static final AnchorPoint TOP_RIGHT = new AnchorPoint(1, 0, true);\n+\n+    \/**\n+     * Anchor at the center-left midpoint of the target area.\n+     * <p>\n+     * This constant is equivalent to {@code AnchorPoint.proportional(0, 0.5)}.\n+     *\/\n+    public static final AnchorPoint CENTER_LEFT = new AnchorPoint(0, 0.5, true);\n+\n+    \/**\n+     * Anchor at the center of the target area.\n+     * <p>\n+     * This constant is equivalent to {@code AnchorPoint.proportional(0.5, 0.5)}.\n+     *\/\n+    public static final AnchorPoint CENTER = new AnchorPoint(0.5, 0.5, true);\n+\n+    \/**\n+     * Anchor at the center-right midpoint of the target area.\n+     * <p>\n+     * This constant is equivalent to {@code AnchorPoint.proportional(1, 0.5)}.\n+     *\/\n+    public static final AnchorPoint CENTER_RIGHT = new AnchorPoint(1, 0.5, true);\n+\n+    \/**\n+     * Anchor at the bottom-left corner of the target area.\n+     * <p>\n+     * This constant is equivalent to {@code AnchorPoint.proportional(0, 1)}.\n+     *\/\n+    public static final AnchorPoint BOTTOM_LEFT = new AnchorPoint(0, 1, true);\n+\n+    \/**\n+     * Anchor at the bottom-center midpoint of the target area.\n+     * <p>\n+     * This constant is equivalent to {@code AnchorPoint.proportional(0.5, 1)}.\n+     *\/\n+    public static final AnchorPoint BOTTOM_CENTER = new AnchorPoint(0.5, 1, true);\n+\n+    \/**\n+     * Anchor at the bottom-right corner of the target area.\n+     * <p>\n+     * This constant is equivalent to {@code AnchorPoint.proportional(1, 1)}.\n+     *\/\n+    public static final AnchorPoint BOTTOM_RIGHT = new AnchorPoint(1, 1, true);\n+\n+    private final double x;\n+    private final double y;\n+    private final boolean proportional;\n+\n+    private AnchorPoint(double x, double y, boolean proportional) {\n+        this.x = x;\n+        this.y = y;\n+        this.proportional = proportional;\n+    }\n+\n+    \/**\n+     * Creates a proportional anchor point, expressed as fractions of the target area's width and height.\n+     * <p>\n+     * In proportional coordinates, {@code (0, 0)} refers to the top-left corner of the target area and\n+     * {@code (1, 1)} refers to the bottom-right corner. Values outside the {@code [0..1]} range represent\n+     * points outside the bounds.\n+     *\n+     * @param x the horizontal fraction of the target width\n+     * @param y the vertical fraction of the target height\n+     * @return a proportional {@code AnchorPoint}\n+     *\/\n+    public static AnchorPoint proportional(double x, double y) {\n+        return new AnchorPoint(x, y, true);\n+    }\n+\n+    \/**\n+     * Creates an absolute anchor point, expressed as offsets from the top-left corner of the target area.\n+     *\n+     * @param x the horizontal offset from the left edge of the target area\n+     * @param y the vertical offset from the top edge of the target area\n+     * @return an absolute {@code AnchorPoint}\n+     *\/\n+    public static AnchorPoint absolute(double x, double y) {\n+        return new AnchorPoint(x, y, false);\n+    }\n+\n+    \/**\n+     * Returns the horizontal coordinate of this anchor point.\n+     *\n+     * @return the horizontal coordinate of this anchor point\n+     *\/\n+    public double getX() {\n+        return x;\n+    }\n+\n+    \/**\n+     * Returns the vertical coordinate of this anchor point.\n+     *\n+     * @return the vertical coordinate of this anchor point\n+     *\/\n+    public double getY() {\n+        return y;\n+    }\n+\n+    \/**\n+     * Indicates whether the {@code x} and {@code y} coordinates are proportional to the size of the target area.\n+     *\n+     * @return {@code true} if the coordinates are proportional, {@code false} otherwise\n+     *\/\n+    public boolean isProportional() {\n+        return proportional;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        return obj instanceof AnchorPoint other\n+            && x == other.x\n+            && y == other.y\n+            && proportional == other.proportional;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hash = 7;\n+        hash = 37 * hash + Double.hashCode(this.x);\n+        hash = 37 * hash + Double.hashCode(this.y);\n+        hash = 37 * hash + Boolean.hashCode(this.proportional);\n+        return hash;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"AnchorPoint [x = \" + x + \", y = \" + y + \", proportional = \" + proportional + \"]\";\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/geometry\/AnchorPoint.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.stage;\n+\n+import javafx.geometry.AnchorPoint;\n+\n+\/**\n+ * Specifies how a window repositioning operation may adjust an anchor point when the preferred anchor\n+ * would place the window outside the usable screen area.\n+ * <p>\n+ * The stage anchor passed to {@link Stage#relocate(AnchorPoint,  AnchorPoint)} or specified by\n+ * {@link PopupWindow#anchorLocationProperty() PopupWindow.anchorLocation} identifies the point on the\n+ * window that should coincide with the requested screen coordinates. When the preferred anchor would place\n+ * the window outside the usable screen area (as defined by the screen bounds and any configured insets),\n+ * an {@code AnchorPolicy} can be used to select an alternative anchor before applying any final position\n+ * adjustment.\n+ *\n+ * @since 26\n+ *\/\n+public enum AnchorPolicy {\n+\n+    \/**\n+     * Always use the preferred anchor and never select an alternative anchor.\n+     * <p>\n+     * If the preferred anchor places the window outside the usable screen area, the window position is\n+     * adjusted for the window to fall within the usable screen area. If this is not possible, the window\n+     * is biased towards the edge that is closer to the anchor.\n+     *\/\n+    FIXED,\n+\n+    \/**\n+     * If the preferred anchor violates horizontal constraints, attempt a horizontally flipped anchor.\n+     * <p>\n+     * A horizontal flip mirrors the anchor across the vertical center line of the window (for example,\n+     * {@code TOP_LEFT} becomes {@code TOP_RIGHT}). If the horizontally flipped anchor does not improve\n+     * the placement, the original anchor is used and the final position is adjusted for the window to\n+     * fall within the usable screen area. If this is not possible, the window is biased towards the\n+     * edge that is closer to the anchor.\n+     *\/\n+    FLIP_HORIZONTAL,\n+\n+    \/**\n+     * If the preferred anchor violates vertical constraints, attempt a vertically flipped anchor.\n+     * <p>\n+     * A vertical flip mirrors the anchor across the horizontal center line of the window (for example,\n+     * {@code TOP_LEFT} becomes {@code BOTTOM_LEFT}). If the vertically flipped anchor does not improve\n+     * the placement, the original anchor is used and the final position is adjusted for the window to\n+     * fall within the usable screen area. If this is not possible, the window is biased towards the\n+     * edge that is closer to the anchor.\n+     *\/\n+    FLIP_VERTICAL,\n+\n+    \/**\n+     * Automatically chooses an alternative anchor based on which constraints are violated.\n+     * <p>\n+     * This policy selects the \"most natural\" flip for the current situation:\n+     * <ul>\n+     *   <li>If only horizontal constraints are violated, it behaves like {@link #FLIP_HORIZONTAL}.\n+     *   <li>If only vertical constraints are violated, it behaves like {@link #FLIP_VERTICAL}.\n+     *   <li>If both horizontal and vertical constraints are violated, it attempts a diagonal flip,\n+     *       then a horizontal flip, and finally a vertical flip.\n+     * <\/ul>\n+     * If no alternative anchor yields a better placement, the original anchor is used and the final\n+     * position is adjusted for the window to fall within the usable screen area.\n+     * If this is not possible, the window is biased towards the edge that is closer to the anchor.\n+     *\/\n+    AUTO\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/AnchorPolicy.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Objects;\n@@ -47,0 +48,1 @@\n+import javafx.geometry.AnchorPoint;\n@@ -49,0 +51,2 @@\n+import javafx.geometry.Insets;\n+import javafx.geometry.Point2D;\n@@ -64,0 +68,1 @@\n+import com.sun.javafx.stage.WindowRelocator;\n@@ -634,0 +639,26 @@\n+    \/**\n+     * Controls whether an alternative anchor location may be used when the preferred\n+     * {@link #anchorLocationProperty() anchorLocation} would place the popup window outside the screen bounds.\n+     * Depending on the policy, the preferred anchor location may be mirrored to the other side of the window\n+     * horizontally or vertically, or an anchor location may be selected automatically.\n+     * <p>\n+     * If no alternative anchor location yields a better placement, the specified {@code anchorLocation} is used.\n+     *\n+     * @defaultValue {@link AnchorPolicy#FIXED}\n+     * @since 26\n+     *\/\n+    private final ObjectProperty<AnchorPolicy> anchorPolicy =\n+            new SimpleObjectProperty<>(this, \"anchorPolicy\", AnchorPolicy.FIXED);\n+\n+    public final ObjectProperty<AnchorPolicy> anchorPolicyProperty() {\n+        return anchorPolicy;\n+    }\n+\n+    public final AnchorPolicy getAnchorPolicy() {\n+        return anchorPolicy.get();\n+    }\n+\n+    public final void setAnchorPolicy(AnchorPolicy value) {\n+        anchorPolicy.set(value);\n+    }\n+\n@@ -724,1 +755,1 @@\n-    void setXInternal(final double value) {\n+    void setXInternal(double value, float xGravity) {\n@@ -729,1 +760,1 @@\n-    void setYInternal(final double value) {\n+    void setYInternal(double value, float yGravity) {\n@@ -786,14 +817,6 @@\n-            if (anchorXCoef <= 0.5) {\n-                \/\/ left side of the popup is more important, try to keep it\n-                \/\/ visible if the popup width is larger than screen width\n-                anchorScrMinX = Math.min(anchorScrMinX,\n-                                         screenBounds.getMaxX()\n-                                             - anchorBounds.getWidth());\n-                anchorScrMinX = Math.max(anchorScrMinX, screenBounds.getMinX());\n-            } else {\n-                \/\/ right side of the popup is more important\n-                anchorScrMinX = Math.max(anchorScrMinX, screenBounds.getMinX());\n-                anchorScrMinX = Math.min(anchorScrMinX,\n-                                         screenBounds.getMaxX()\n-                                             - anchorBounds.getWidth());\n-            }\n+            Point2D location = WindowRelocator.computeAdjustedLocation(\n+                newAnchorX, newAnchorY,\n+                anchorBounds.getWidth(), anchorBounds.getHeight(),\n+                AnchorPoint.proportional(anchorXCoef, anchorYCoef),\n+                Objects.requireNonNullElse(getAnchorPolicy(), AnchorPolicy.FIXED),\n+                screenBounds, Insets.EMPTY);\n@@ -801,13 +824,2 @@\n-            if (anchorYCoef <= 0.5) {\n-                \/\/ top side of the popup is more important\n-                anchorScrMinY = Math.min(anchorScrMinY,\n-                                         screenBounds.getMaxY()\n-                                             - anchorBounds.getHeight());\n-                anchorScrMinY = Math.max(anchorScrMinY, screenBounds.getMinY());\n-            } else {\n-                \/\/ bottom side of the popup is more important\n-                anchorScrMinY = Math.max(anchorScrMinY, screenBounds.getMinY());\n-                anchorScrMinY = Math.min(anchorScrMinY,\n-                                         screenBounds.getMaxY()\n-                                             - anchorBounds.getHeight());\n-            }\n+            anchorScrMinX = location.getX();\n+            anchorScrMinY = location.getY();\n@@ -833,1 +845,1 @@\n-            super.setXInternal(windowScrMinX);\n+            super.setXInternal(windowScrMinX, 0);\n@@ -837,1 +849,1 @@\n-            super.setYInternal(windowScrMinY);\n+            super.setYInternal(windowScrMinY, 0);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/PopupWindow.java","additions":43,"deletions":31,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Objects;\n@@ -39,0 +40,2 @@\n+import javafx.geometry.AnchorPoint;\n+import javafx.geometry.Insets;\n@@ -53,0 +56,2 @@\n+import com.sun.javafx.stage.WindowLocationAlgorithm;\n+import com.sun.javafx.stage.WindowRelocator;\n@@ -1216,0 +1221,121 @@\n+    \/**\n+     * Positions this stage so that a point on the stage ({@code stageAnchor}) coincides with a point on\n+     * the screen ({@code screenAnchor}), and ensures that the stage is not placed off-screen.\n+     * <p>\n+     * This method may be called either before or after {@link #show()} or {@link #showAndWait()}.\n+     * If called <em>before<\/em> the stage is shown, then\n+     * <ol>\n+     *     <li>any previous call to {@code relocate(...)} or {@link #centerOnScreen()} is discarded,\n+     *     <li>the {@link #xProperty() X} and {@link #yProperty() Y} properties are not updated\n+     *         immediately; instead, they are updated after the stage is shown.\n+     * <\/ol>\n+     * Calling this method is equivalent to calling {@link #relocate(AnchorPoint, Insets, AnchorPoint, AnchorPolicy)\n+     * relocate(screenAnchor, Insets.EMPTY, stageAnchor, AnchorPolicy.FIXED)}.\n+     *\n+     * @param screenAnchor An anchor point in absolute or proportional coordinates relative to the screen that\n+     *                     currently contains this stage (current screen); if the stage does not have a location\n+     *                     yet, the primary screen is implied. If the screen anchor is\n+     *                     {@linkplain AnchorPoint#proportional(double, double) proportional}, it is first resolved\n+     *                     against the {@linkplain Screen#getVisualBounds() visual bounds} of the current screen;\n+     *                     if a full-screen stage is showing on the current screen, the screen anchor is resolved\n+     *                     against its complete {@linkplain Screen#getBounds() bounds}.\n+     * @param stageAnchor  An anchor point in absolute or proportional stage coordinates.\n+     * @throws NullPointerException if any of the parameters is {@code null}\n+     * @since 26\n+     *\/\n+    public final void relocate(AnchorPoint screenAnchor, AnchorPoint stageAnchor) {\n+        relocateImpl(null, screenAnchor, Insets.EMPTY, stageAnchor, AnchorPolicy.FIXED);\n+    }\n+\n+    \/**\n+     * Positions this stage so that a point on the stage ({@code stageAnchor}) coincides with a point on\n+     * the screen ({@code screenAnchor}), subject to the specified anchor policy and screen padding.\n+     * <p>\n+     * This method may be called either before or after {@link #show()} or {@link #showAndWait()}.\n+     * If called <em>before<\/em> the stage is shown, then\n+     * <ol>\n+     *     <li>any previous call to {@code relocate(...)} or {@link #centerOnScreen()} is discarded,\n+     *     <li>the {@link #xProperty() X} and {@link #yProperty() Y} properties are not updated\n+     *         immediately; instead, they are updated after the stage is shown.\n+     * <\/ol>\n+     *\n+     * @param screenAnchor  An anchor point in absolute or proportional coordinates relative to the screen that\n+     *                      currently contains this stage (current screen); if the stage does not have a location\n+     *                      yet, the primary screen is implied. If the screen anchor is\n+     *                      {@linkplain AnchorPoint#proportional(double, double) proportional}, it is first resolved\n+     *                      against the {@linkplain Screen#getVisualBounds() visual bounds} of the current screen;\n+     *                      if a full-screen stage is showing on the current screen, the screen anchor is resolved\n+     *                      against its complete {@linkplain Screen#getBounds() bounds}.\n+     * @param screenPadding Defines per-edge constraints against the screen bounds. Each inset value specifies the\n+     *                      minimum distance to maintain between the stage edge and the corresponding screen edge.\n+     *                      A value {@code >= 0} enables the corresponding edge constraint; a negative value disables\n+     *                      the constraint for that edge. Enabled constraints effectively shrink the usable screen\n+     *                      area by the given insets. For example, a left inset of {@code 10} ensures the stage will\n+     *                      not be placed closer than 10 pixels to the left screen edge.\n+     * @param stageAnchor   An anchor point in absolute or proportional stage coordinates.\n+     * @param anchorPolicy  Controls whether an alternative stage anchor may be used when the preferred anchor would\n+     *                      place the stage outside the usable screen area. Depending on the policy, the preferred\n+     *                      anchor location may be mirrored across the vertical\/horizontal center line of the stage,\n+     *                      or an anchor might be selected automatically. If no alternative anchor yields a better\n+     *                      placement, the specified {@code stageAnchor} is used.\n+     * @throws NullPointerException if any of the parameters is {@code null}\n+     * @since 26\n+     *\/\n+    public final void relocate(AnchorPoint screenAnchor, Insets screenPadding,\n+                               AnchorPoint stageAnchor, AnchorPolicy anchorPolicy) {\n+        relocateImpl(null, screenAnchor, screenPadding, stageAnchor, anchorPolicy);\n+    }\n+\n+    \/**\n+     * Positions this stage so that a point on the stage ({@code stageAnchor}) coincides with a point on\n+     * the screen ({@code screenAnchor}), subject to the specified anchor policy and screen padding.\n+     * <p>\n+     * This method may be called either before or after {@link #show()} or {@link #showAndWait()}.\n+     * If called <em>before<\/em> the stage is shown, then\n+     * <ol>\n+     *     <li>any previous call to {@code relocate(...)} or {@link #centerOnScreen()} is discarded,\n+     *     <li>the {@link #xProperty() X} and {@link #yProperty() Y} properties are not updated\n+     *         immediately; instead, they are updated after the stage is shown.\n+     * <\/ol>\n+     *\n+     * @param screen        The reference screen that defines the coordinate space for {@code screenAnchor}.\n+     * @param screenAnchor  An anchor point in absolute or proportional coordinates relative to {@code screen}.\n+     *                      If the screen anchor is {@linkplain AnchorPoint#proportional(double, double) proportional},\n+     *                      it is first resolved against the {@linkplain Screen#getVisualBounds() visual bounds} of\n+     *                      the screen; if a full-screen stage is showing on the screen, the screen anchor is resolved\n+     *                      against its complete {@linkplain Screen#getBounds() bounds}.\n+     * @param screenPadding Defines per-edge constraints against the screen bounds. Each inset value specifies the\n+     *                      minimum distance to maintain between the stage edge and the corresponding screen edge.\n+     *                      A value {@code >= 0} enables the corresponding edge constraint; a negative value disables\n+     *                      the constraint for that edge. Enabled constraints effectively shrink the usable screen\n+     *                      area by the given insets. For example, a left inset of {@code 10} ensures the stage will\n+     *                      not be placed closer than 10 pixels to the left screen edge.\n+     * @param stageAnchor   An anchor point in absolute or proportional stage coordinates.\n+     * @param anchorPolicy  Controls whether an alternative stage anchor may be used when the preferred anchor would\n+     *                      place the stage outside the usable screen area. Depending on the policy, the preferred\n+     *                      anchor location may be mirrored across the vertical\/horizontal center line of the stage,\n+     *                      or an anchor might be selected automatically. If no alternative anchor yields a better\n+     *                      placement, the specified {@code stageAnchor} is used.\n+     * @throws NullPointerException if any of the parameters is {@code null}\n+     * @since 26\n+     *\/\n+    public final void relocate(Screen screen, AnchorPoint screenAnchor, Insets screenPadding,\n+                               AnchorPoint stageAnchor, AnchorPolicy anchorPolicy) {\n+        Objects.requireNonNull(screen, \"screen cannot be null\");\n+        relocateImpl(screen, screenAnchor, screenPadding, stageAnchor, anchorPolicy);\n+    }\n+\n+    private void relocateImpl(Screen screen, AnchorPoint screenAnchor, Insets screenPadding,\n+                              AnchorPoint stageAnchor, AnchorPolicy anchorPolicy) {\n+        clearLocationExplicit();\n+\n+        WindowLocationAlgorithm algorithm = WindowRelocator.newRelocationAlgorithm(\n+            screen, screenAnchor, screenPadding, stageAnchor, anchorPolicy);\n+\n+        if (isShowing()) {\n+            applyLocationAlgorithm(algorithm);\n+        } else {\n+            this.locationAlgorithm = algorithm;\n+        }\n+    }\n+\n@@ -1318,0 +1444,13 @@\n+\n+    @Override\n+    final void clearLocationExplicit() {\n+        locationAlgorithm = null;\n+        super.clearLocationExplicit();\n+    }\n+\n+    @Override\n+    final WindowLocationAlgorithm getLocationAlgorithm() {\n+        return locationAlgorithm;\n+    }\n+\n+    private WindowLocationAlgorithm locationAlgorithm;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/Stage.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+import com.sun.javafx.stage.WindowLocationAlgorithm;\n@@ -138,0 +139,5 @@\n+                    @Override\n+                    public Window getWindowOwner(Window window) {\n+                        return window.getWindowOwner();\n+                    }\n+\n@@ -337,0 +343,10 @@\n+    private static final WindowLocationAlgorithm CENTER_ON_SCREEN_ALGORITHM = new WindowLocationAlgorithm() {\n+        @Override\n+        public ComputedLocation compute(Screen screen, double windowWidth, double windowHeight) {\n+            Rectangle2D bounds = screen.getVisualBounds();\n+            double centerX = bounds.getMinX() + (bounds.getWidth() - windowWidth) * CENTER_ON_SCREEN_X_FRACTION;\n+            double centerY = bounds.getMinY() + (bounds.getHeight() - windowHeight) * CENTER_ON_SCREEN_Y_FRACTION;\n+            return new ComputedLocation(centerX, centerY, CENTER_ON_SCREEN_X_FRACTION, CENTER_ON_SCREEN_Y_FRACTION);\n+        }\n+    };\n+\n@@ -344,2 +360,2 @@\n-        xExplicit = false;\n-        yExplicit = false;\n+        clearLocationExplicit();\n+\n@@ -347,13 +363,1 @@\n-            Rectangle2D bounds = getWindowScreen().getVisualBounds();\n-            double centerX =\n-                    bounds.getMinX() + (bounds.getWidth() - getWidth())\n-                                           * CENTER_ON_SCREEN_X_FRACTION;\n-            double centerY =\n-                    bounds.getMinY() + (bounds.getHeight() - getHeight())\n-                                           * CENTER_ON_SCREEN_Y_FRACTION;\n-\n-            x.set(centerX);\n-            y.set(centerY);\n-            peerBoundsConfigurator.setLocation(centerX, centerY,\n-                                               CENTER_ON_SCREEN_X_FRACTION,\n-                                               CENTER_ON_SCREEN_Y_FRACTION);\n+            applyLocationAlgorithm(CENTER_ON_SCREEN_ALGORITHM);\n@@ -550,1 +554,1 @@\n-        setXInternal(value);\n+        setXInternal(value, 0);\n@@ -555,1 +559,1 @@\n-    void setXInternal(double value) {\n+    void setXInternal(double value, float gravity) {\n@@ -557,1 +561,1 @@\n-        peerBoundsConfigurator.setX(value, 0);\n+        peerBoundsConfigurator.setX(value, gravity);\n@@ -581,1 +585,1 @@\n-        setYInternal(value);\n+        setYInternal(value, 0);\n@@ -586,1 +590,1 @@\n-    void setYInternal(double value) {\n+    void setYInternal(double value, float gravity) {\n@@ -588,1 +592,1 @@\n-        peerBoundsConfigurator.setY(value, 0);\n+        peerBoundsConfigurator.setY(value, gravity);\n@@ -604,0 +608,34 @@\n+    void clearLocationExplicit() {\n+        xExplicit = false;\n+        yExplicit = false;\n+    }\n+\n+    \/**\n+     * Allows subclasses to specify an algorithm that computes the window location.\n+     *\/\n+    WindowLocationAlgorithm getLocationAlgorithm() {\n+        return null;\n+    }\n+\n+    \/**\n+     * Applies the specified location algorithm, but does not change explicitly specified window coordinates.\n+     *\/\n+    final void applyLocationAlgorithm(WindowLocationAlgorithm algorithm) {\n+        if (xExplicit && yExplicit) {\n+            return;\n+        }\n+\n+        WindowLocationAlgorithm.ComputedLocation location =\n+            algorithm.compute(Utils.getScreenForWindow(this), getWidth(), getHeight());\n+\n+        if (!xExplicit) {\n+            x.set(location.x());\n+            peerBoundsConfigurator.setX(location.x(), (float)location.xGravity());\n+        }\n+\n+        if (!yExplicit) {\n+            y.set(location.y());\n+            peerBoundsConfigurator.setY(location.y(), (float)location.yGravity());\n+        }\n+    }\n+\n@@ -1063,0 +1101,1 @@\n+\n@@ -1064,0 +1103,2 @@\n+            WindowLocationAlgorithm locationAlgorithm = getLocationAlgorithm();\n+\n@@ -1113,6 +1154,5 @@\n-                    if (!xExplicit && !yExplicit) {\n-                        centerOnScreen();\n-                    } else {\n-                        peerBoundsConfigurator.setLocation(getX(), getY(),\n-                                                           0, 0);\n-                    }\n+                    \/\/ Set the location of the window peer first, because it might not have a location yet.\n+                    \/\/ This is the case when a window is hidden and then shown again: we have a location, but\n+                    \/\/ the new peer doesn't know about that yet. This location might be overwritten by a\n+                    \/\/ location algorithm later if X and Y are not specified explicitly.\n+                    peerBoundsConfigurator.setLocation(x.get(), y.get(), 0, 0);\n@@ -1120,1 +1160,3 @@\n-                    \/\/ set peer bounds before the window is shown\n+                    \/\/ If a derived class has provided us a location algorithm, now is the time to apply it.\n+                    \/\/ If we don't have a location algorithm, we use the default center-on-screen algorithm.\n+                    applyLocationAlgorithm(locationAlgorithm != null ? locationAlgorithm : CENTER_ON_SCREEN_ALGORITHM);\n@@ -1159,0 +1201,6 @@\n+\n+                    \/\/ If the window size has changed, we need to run the location algorithm again.\n+                    if (locationAlgorithm != null) {\n+                        applyLocationAlgorithm(locationAlgorithm);\n+                        applyBounds();\n+                    }\n@@ -1374,20 +1422,0 @@\n-    private Screen getWindowScreen() {\n-        Window window = this;\n-        do {\n-            if (!Double.isNaN(window.getX())\n-                    && !Double.isNaN(window.getY())\n-                    && !Double.isNaN(window.getWidth())\n-                    && !Double.isNaN(window.getHeight())) {\n-                return Utils.getScreenForRectangle(\n-                                     new Rectangle2D(window.getX(),\n-                                                     window.getY(),\n-                                                     window.getWidth(),\n-                                                     window.getHeight()));\n-            }\n-\n-            window = window.getWindowOwner();\n-        } while (window != null);\n-\n-        return Screen.getPrimary();\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/Window.java","additions":76,"deletions":48,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,3 @@\n+import java.util.stream.Stream;\n+import javafx.geometry.AnchorPoint;\n+import javafx.geometry.Insets;\n@@ -30,1 +33,0 @@\n-import com.sun.javafx.stage.WindowHelper;\n@@ -33,0 +35,3 @@\n+import javafx.stage.AnchorPolicy;\n+import javafx.stage.Screen;\n+import javafx.stage.Stage;\n@@ -36,0 +41,1 @@\n+import com.sun.javafx.stage.WindowHelper;\n@@ -37,1 +43,0 @@\n-import javafx.stage.Stage;\n@@ -42,3 +47,5 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -57,0 +64,2 @@\n+        toolkit.setScreens(new ScreenConfiguration(0, 0, 800, 600, 0, 0, 800, 600, 96));\n+\n@@ -58,3 +67,4 @@\n-        s.show();\n-        peer = (StubStage) WindowHelper.getPeer(s);\n-        initialNumTimesSetSizeAndLocation = peer.numTimesSetSizeAndLocation;\n+        s.setOnShown(_ -> {\n+            peer = (StubStage) WindowHelper.getPeer(s);\n+            initialNumTimesSetSizeAndLocation = peer.numTimesSetSizeAndLocation;\n+        });\n@@ -66,0 +76,1 @@\n+        toolkit.resetScreens();\n@@ -78,0 +89,1 @@\n+        s.show();\n@@ -91,0 +103,1 @@\n+        s.show();\n@@ -106,0 +119,1 @@\n+        s.show();\n@@ -125,0 +139,1 @@\n+        s.show();\n@@ -140,0 +155,1 @@\n+        s.show();\n@@ -155,0 +171,1 @@\n+        s.show();\n@@ -179,0 +196,1 @@\n+        s.show();\n@@ -194,0 +212,1 @@\n+        s.show();\n@@ -218,0 +237,1 @@\n+            s.show();\n@@ -241,0 +261,1 @@\n+            s.show();\n@@ -263,0 +284,1 @@\n+        s.show();\n@@ -288,0 +310,1 @@\n+        s.show();\n@@ -312,0 +335,1 @@\n+        s.show();\n@@ -330,0 +354,1 @@\n+        s.show();\n@@ -338,0 +363,1 @@\n+        s.show();\n@@ -356,0 +382,1 @@\n+        s.show();\n@@ -364,0 +391,1 @@\n+        s.show();\n@@ -382,0 +410,1 @@\n+        s.show();\n@@ -390,0 +419,1 @@\n+        s.show();\n@@ -408,0 +438,1 @@\n+        s.show();\n@@ -416,0 +447,1 @@\n+        s.show();\n@@ -434,0 +466,1 @@\n+        s.show();\n@@ -442,0 +475,1 @@\n+        s.show();\n@@ -521,0 +555,627 @@\n+\n+    @Test\n+    public void relocateNullArgumentsThrowNPE() {\n+        s.show();\n+        assertNotNull(peer);\n+        assertThrows(NullPointerException.class, () -> s.relocate(null, AnchorPoint.TOP_LEFT));\n+        assertThrows(NullPointerException.class, () -> s.relocate(AnchorPoint.TOP_LEFT, null));\n+\n+        assertThrows(NullPointerException.class, () -> s.relocate(null, Insets.EMPTY, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED));\n+        assertThrows(NullPointerException.class, () -> s.relocate(AnchorPoint.TOP_LEFT, Insets.EMPTY, null, AnchorPolicy.FIXED));\n+        assertThrows(NullPointerException.class, () -> s.relocate(AnchorPoint.TOP_LEFT, Insets.EMPTY, AnchorPoint.TOP_LEFT, null));\n+        assertThrows(NullPointerException.class, () -> s.relocate(AnchorPoint.TOP_LEFT, null, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED));\n+\n+        assertThrows(NullPointerException.class, () -> s.relocate(null, null, Insets.EMPTY, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED));\n+        assertThrows(NullPointerException.class, () -> s.relocate(null, AnchorPoint.TOP_LEFT, Insets.EMPTY, null, AnchorPolicy.FIXED));\n+        assertThrows(NullPointerException.class, () -> s.relocate(null, AnchorPoint.TOP_LEFT, Insets.EMPTY, AnchorPoint.TOP_LEFT, null));\n+        assertThrows(NullPointerException.class, () -> s.relocate(null, AnchorPoint.TOP_LEFT, null, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED));\n+    }\n+\n+    \/**\n+     * Tests that {@code relocate()} called before {@code show()} is applied when the stage is shown.\n+     *\/\n+    @Test\n+    public void relocateBeforeShowPositionsStageOnShow() {\n+        s.setWidth(300);\n+        s.setHeight(200);\n+        s.relocate(AnchorPoint.absolute(100, 120), Insets.EMPTY, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        assertEquals(100, peer.x, 0.0001);\n+        assertEquals(120, peer.y, 0.0001);\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Tests that {@code relocate()} called after {@code show()} updates the stage position immediately.\n+     *\/\n+    @Test\n+    public void relocateAfterShowMovesStageImmediately() {\n+        s.setWidth(300);\n+        s.setHeight(200);\n+        s.show();\n+        s.relocate(AnchorPoint.absolute(200, 220), Insets.EMPTY, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED);\n+        pulse();\n+\n+        assertEquals(200, peer.x, 0.0001);\n+        assertEquals(220, peer.y, 0.0001);\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Tests that proportional screen anchors resolve against visual bounds.\n+     *\/\n+    @Test\n+    public void relocateWithProportionalScreenAnchorResolvesAgainstVisualBounds() {\n+        \/\/ Visual bounds differ from full bounds (e.g., task bar \/ menu bar reserved area).\n+        toolkit.setScreens(new ScreenConfiguration(0, 0, 800, 600, 0, 30, 800, 570, 96));\n+\n+        s.setWidth(200);\n+        s.setHeight(100);\n+\n+        \/\/ Proportional screen anchors are resolved against visual bounds when no fullscreen stage is present.\n+        s.relocate(AnchorPoint.proportional(0, 0), Insets.EMPTY, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        assertEquals(0, peer.x, 0.0001);\n+        assertEquals(30, peer.y, 0.0001);\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Tests that proportional screen anchors resolve against the stage's current screen.\n+     *\/\n+    @Test\n+    public void relocateWithProportionalScreenAnchorUsesCurrentScreen() {\n+        toolkit.setScreens(\n+            new ScreenConfiguration(0, 0, 800, 600, 0, 0, 800, 600, 96),\n+            new ScreenConfiguration(800, 0, 800, 600, 800, 40, 800, 560, 96));\n+\n+        \/\/ Ensure the stage is on screen 2 when resolving the proportional screen anchor.\n+        s.setX(850);\n+        s.setY(10);\n+        s.setWidth(200);\n+        s.setHeight(200);\n+\n+        \/\/ Center stage on screen 2's visual bounds:\n+        \/\/ screen center = (800 + 0.5*800, 40 + 0.5*560) = (1200, 320)\n+        \/\/ stage top-left = center - (100, 100) = (1100, 220)\n+        s.relocate(AnchorPoint.proportional(0.5, 0.5), Insets.EMPTY, AnchorPoint.CENTER, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        assertEquals(1100, peer.x, 0.0001);\n+        assertEquals(220, peer.y, 0.0001);\n+        assertNotWithinBounds(peer, toolkit.getScreens().get(0), Insets.EMPTY);\n+        assertWithinBounds(peer, toolkit.getScreens().get(1), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Absolute screenAnchor is relative to the specified screen's reference rectangle.\n+     *\/\n+    @Test\n+    public void relocateWithScreenParameterAbsoluteAnchorIsRelativeToScreenVisualBounds() {\n+        toolkit.setScreens(\n+            new ScreenConfiguration(0, 0, 800, 600, 0, 0, 800, 600, 96),\n+            new ScreenConfiguration(800, 0, 800, 600, 800, 40, 800, 560, 96));\n+\n+        s.setWidth(100);\n+        s.setHeight(100);\n+\n+        Screen screen2 = Screen.getScreens().get(1);\n+\n+        \/\/ Absolute coordinates are relative to the reference rectangle of screen2.\n+        \/\/ Here: visual min = (800, 40), so (10, 20) => (810, 60)\n+        s.relocate(screen2, AnchorPoint.absolute(10, 20), Insets.EMPTY, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        assertEquals(810, peer.x, 0.0001);\n+        assertEquals(60, peer.y, 0.0001);\n+        assertNotWithinBounds(peer, toolkit.getScreens().get(0), Insets.EMPTY);\n+        assertWithinBounds(peer, toolkit.getScreens().get(1), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Proportional screenAnchor uses the specified screen even if the stage is currently on another screen.\n+     *\/\n+    @Test\n+    public void relocateWithScreenParameterProportionalAnchorUsesSpecifiedScreen() {\n+        toolkit.setScreens(\n+            new ScreenConfiguration(0, 0, 800, 600, 0, 0, 800, 600, 96),\n+            new ScreenConfiguration(800, 0, 800, 600, 800, 40, 800, 560, 96));\n+\n+        s.setX(10);\n+        s.setY(10);\n+        s.setWidth(200);\n+        s.setHeight(200);\n+        s.show();\n+\n+        Screen screen2 = Screen.getScreens().get(1);\n+\n+        \/\/ Center of screen2 visual bounds:\n+        \/\/ (800 + 0.5*800, 40 + 0.5*560) = (1200, 320)\n+        \/\/ Stage anchor CENTER => top-left = (1200-100, 320-100) = (1100, 220)\n+        s.relocate(screen2, AnchorPoint.proportional(0.5, 0.5), Insets.EMPTY, AnchorPoint.CENTER, AnchorPolicy.FIXED);\n+        pulse();\n+\n+        assertEquals(1100, peer.x, 0.0001);\n+        assertEquals(220, peer.y, 0.0001);\n+        assertNotWithinBounds(peer, toolkit.getScreens().get(0), Insets.EMPTY);\n+        assertWithinBounds(peer, toolkit.getScreens().get(1), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Constraints (screenPadding) are applied against the specified screen's usable bounds.\n+     *\/\n+    @Test\n+    public void relocateWithScreenParameterHonorsPaddingOnSpecifiedScreen() {\n+        toolkit.setScreens(\n+            new ScreenConfiguration(0, 0, 800, 600, 0, 0, 800, 600, 96),\n+            new ScreenConfiguration(800, 0, 800, 600, 800, 40, 800, 560, 96));\n+\n+        s.setWidth(300);\n+        s.setHeight(200);\n+\n+        Screen screen2 = Screen.getScreens().get(1);\n+        Insets padding = new Insets(10, 20, 30, 40); \/\/ top, right, bottom, left\n+\n+        \/\/ Request a TOP_LEFT placement beyond bottom-right; should clamp within padded usable area.\n+        \/\/ Screen2 visual: min=(800,40), size=(800,560)\n+        \/\/ Padded usable maxX = 800+800-20 = 1580; maxY = 40+560-30 = 570\n+        \/\/ Stage max top-left: x = 1580-300 = 1280; y = 570-200 = 370\n+        s.relocate(screen2, AnchorPoint.absolute(800, 560), padding, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        assertEquals(1280, peer.x, 0.0001);\n+        assertEquals(370, peer.y, 0.0001);\n+        assertNotWithinBounds(peer, toolkit.getScreens().get(0), padding);\n+        assertWithinBounds(peer, toolkit.getScreens().get(1), padding);\n+    }\n+\n+    \/**\n+     * \"Before show\" path works with the screen overload too (deferred application).\n+     *\/\n+    @Test\n+    public void relocateWithScreenParameterBeforeShowPositionsStageOnShow() {\n+        toolkit.setScreens(\n+            new ScreenConfiguration(0, 0, 800, 600, 0, 0, 800, 600, 96),\n+            new ScreenConfiguration(800, 0, 800, 600, 800, 40, 800, 560, 96));\n+\n+        Screen screen2 = Screen.getScreens().get(1);\n+\n+        s.setWidth(120);\n+        s.setHeight(80);\n+        s.relocate(screen2, AnchorPoint.TOP_LEFT, Insets.EMPTY, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        assertEquals(800, peer.x, 0.0001);\n+        assertEquals(40, peer.y, 0.0001);\n+        assertNotWithinBounds(peer, toolkit.getScreens().get(0), Insets.EMPTY);\n+        assertWithinBounds(peer, toolkit.getScreens().get(1), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Tests that {@code relocate()} called before show overrides any prior {@code centerOnScreen()} request.\n+     *\/\n+    @Test\n+    public void relocateCancelsCenterOnScreenWhenCalledBeforeShow() {\n+        s.setWidth(200);\n+        s.setHeight(200);\n+        s.centerOnScreen();\n+\n+        \/\/ If centerOnScreen were honored, we'd expect (300, 200) on 800x600.\n+        \/\/ relocate should override\/cancel it.\n+        s.relocate(AnchorPoint.absolute(0, 0), Insets.EMPTY, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        assertEquals(0, peer.x, 0.0001);\n+        assertEquals(0, peer.y, 0.0001);\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Tests that enabled padding insets constrain the resulting stage position.\n+     *\/\n+    @Test\n+    public void relocateHonorsPaddingForEnabledEdges() {\n+        s.setWidth(200);\n+        s.setHeight(200);\n+\n+        var padding = new Insets(10, 20, 30, 40); \/\/ top, right, bottom, left\n+\n+        \/\/ Ask to place the TOP_LEFT anchor beyond the bottom-right safe area to force adjustment\n+        s.relocate(AnchorPoint.absolute(800, 600), padding, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        \/\/ Allowed top-left: x <= 800 - 20 - 200 = 580, y <= 600 - 30 - 200 = 370\n+        assertEquals(580, peer.x, 0.0001);\n+        assertEquals(370, peer.y, 0.0001);\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), padding);\n+    }\n+\n+    \/**\n+     * Tests that negative insets disable constraints for the corresponding edges.\n+     *\/\n+    @Test\n+    public void relocateNegativeInsetsDisableConstraintsPerEdge() {\n+        s.setWidth(300);\n+        s.setHeight(200);\n+\n+        \/\/ Disable right and bottom constraints (negative), keep left\/top enabled at 0.\n+        var padding = new Insets(0, -1, -1, 0);\n+        s.relocate(AnchorPoint.absolute(790, 590), padding, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        assertEquals(790, peer.x, 0.0001);\n+        assertEquals(590, peer.y, 0.0001);\n+        assertNotWithinBounds(peer, toolkit.getScreens().getFirst(), padding);\n+    }\n+\n+    \/**\n+     * Tests that a single enabled left-edge constraint is honored.\n+     *\/\n+    @Test\n+    public void relocateOneSidedLeftConstraintOnly() {\n+        s.setWidth(300);\n+        s.setHeight(200);\n+\n+        \/\/ Enable left constraint (10), disable others\n+        var padding = new Insets(-1, -1, -1, 10);\n+        s.relocate(AnchorPoint.absolute(0, 100), padding, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        assertEquals(10, peer.x, 0.0001);\n+        assertEquals(100, peer.y, 0.0001);\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), padding);\n+    }\n+\n+    \/**\n+     * Tests that {@link AnchorPolicy#FLIP_HORIZONTAL} selects a horizontally flipped anchor to avoid right overflow.\n+     *\/\n+    @Test\n+    public void relocateFlipHorizontalFitsWithoutAdjustment() {\n+        s.setWidth(300);\n+        s.setHeight(200);\n+\n+        \/\/ TOP_LEFT at (790,10) overflows to the right.\n+        \/\/ TOP_RIGHT at (790,10) => rawX=790-300=490 fits.\n+        s.relocate(AnchorPoint.absolute(790, 10), Insets.EMPTY, AnchorPoint.TOP_LEFT, AnchorPolicy.FLIP_HORIZONTAL);\n+        s.show();\n+\n+        assertEquals(490, peer.x, 0.0001);\n+        assertEquals(10, peer.y, 0.0001);\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Tests that {@link AnchorPolicy#AUTO} prefers a diagonal flip when both horizontal and vertical\n+     * constraints are violated.\n+     *\/\n+    @Test\n+    public void relocateAutoDiagonalBeatsAdjustOnly() {\n+        s.setWidth(300);\n+        s.setHeight(200);\n+\n+        \/\/ TOP_LEFT at (790,590) overflows right and bottom.\n+        \/\/ AUTO should choose BOTTOM_RIGHT (diagonal flip) => raw=(490,390) fits with no adjustment.\n+        s.relocate(AnchorPoint.absolute(790, 590), Insets.EMPTY, AnchorPoint.TOP_LEFT, AnchorPolicy.AUTO);\n+        s.show();\n+\n+        assertEquals(490, peer.x, 0.0001);\n+        assertEquals(390, peer.y, 0.0001);\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Tests that {@link AnchorPolicy#FLIP_HORIZONTAL} may still require vertical clamping after flipping.\n+     *\/\n+    @Test\n+    public void relocateFlipHorizontalStillRequiresVerticalAdjustment() {\n+        s.setWidth(300);\n+        s.setHeight(200);\n+\n+        \/\/ Flip horizontally resolves X, but Y still needs adjustment.\n+        \/\/ TOP_RIGHT raw = (490,590) => y clamps to 400.\n+        s.relocate(AnchorPoint.absolute(790, 590), Insets.EMPTY, AnchorPoint.TOP_LEFT, AnchorPolicy.FLIP_HORIZONTAL);\n+        s.show();\n+\n+        assertEquals(490, peer.x, 0.0001);\n+        assertEquals(400, peer.y, 0.0001);\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Tests that {@link AnchorPolicy#FLIP_VERTICAL} may still require horizontal clamping after flipping.\n+     *\/\n+    @Test\n+    public void relocateFlipVerticalStillRequiresHorizontalAdjustment() {\n+        s.setWidth(300);\n+        s.setHeight(200);\n+\n+        \/\/ Flip vertically resolves Y, but X still needs adjustment.\n+        \/\/ BOTTOM_LEFT raw = (790,390) => x clamps to 500.\n+        s.relocate(AnchorPoint.absolute(790, 590), Insets.EMPTY, AnchorPoint.TOP_LEFT, AnchorPolicy.FLIP_VERTICAL);\n+        s.show();\n+\n+        assertEquals(500, peer.x, 0.0001);\n+        assertEquals(390, peer.y, 0.0001);\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Tests that {@link AnchorPolicy#AUTO} flips horizontally when only the right constraint is enabled and violated.\n+     *\/\n+    @Test\n+    public void relocateAutoWithRightOnlyConstraintFlipsHorizontally() {\n+        s.setWidth(300);\n+        s.setHeight(200);\n+\n+        \/\/ Only right edge constrained, others disabled\n+        var constraints = new Insets(-1, 0, -1, -1);\n+\n+        \/\/ Preferred TOP_LEFT: rawX=790 => violates right constraint (maxX=500)\n+        \/\/ AUTO should choose TOP_RIGHT: rawX = 790-300 = 490 (fits without adjustment)\n+        s.relocate(AnchorPoint.absolute(790, 10), constraints, AnchorPoint.TOP_LEFT, AnchorPolicy.AUTO);\n+        s.show();\n+\n+        assertEquals(490, peer.x, 0.0001);\n+        assertEquals(10, peer.y, 0.0001);\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Tests that {@link AnchorPolicy#AUTO} keeps the preferred anchor when flipping would worsen the adjustment.\n+     *\/\n+    @Test\n+    public void relocateAutoWithLeftOnlyConstraintDoesNotFlipWhenFlipWouldBeWorse() {\n+        s.setWidth(300);\n+        s.setHeight(200);\n+\n+        \/\/ Only left edge constrained to x >= 10, others disabled\n+        var constraints = new Insets(-1, -1, -1, 10);\n+\n+        \/\/ Preferred TOP_LEFT: rawX = 0 -> adjusted to 10 (cost 10)\n+        \/\/ Flipped TOP_RIGHT: rawX = 0-300 = -300 -> adjusted to 10 (cost 310)\n+        \/\/ AUTO may consider the flip, but should keep the original anchor as \"better\".\n+        s.relocate(AnchorPoint.absolute(0, 10), constraints, AnchorPoint.TOP_LEFT, AnchorPolicy.AUTO);\n+        s.show();\n+\n+        assertEquals(10, peer.x, 0.0001);\n+        assertEquals(10, peer.y, 0.0001);\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Tests that {@link AnchorPolicy#AUTO} flips vertically when only the bottom constraint is enabled and violated.\n+     *\/\n+    @Test\n+    public void relocateAutoWithBottomOnlyConstraintFlipsVertically() {\n+        s.setWidth(300);\n+        s.setHeight(200);\n+\n+        \/\/ Only bottom constrained, others disabled\n+        var constraints = new Insets(-1, -1, 0, -1);\n+\n+        \/\/ Preferred TOP_LEFT at y=590 => rawY=590 violates bottom maxY=400\n+        \/\/ Vertical flip to BOTTOM_LEFT yields rawY=590-200=390 (fits)\n+        s.relocate(AnchorPoint.absolute(100, 590), constraints, AnchorPoint.TOP_LEFT, AnchorPolicy.AUTO);\n+        s.show();\n+\n+        assertEquals(100, peer.x, 0.0001);\n+        assertEquals(390, peer.y, 0.0001);\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Tests that {@link AnchorPolicy#AUTO} ignores disabled edge constraints when deciding whether to flip.\n+     *\/\n+    @Test\n+    public void relocateAutoIgnoresDisabledEdgesWhenDecidingWhetherToFlip() {\n+        s.setWidth(300);\n+        s.setHeight(200);\n+\n+        \/\/ Disable right constraint, enable left constraint (x >= 0).\n+        \/\/ This means \"overflow to the right is allowed\", so AUTO should not flip horizontally\n+        \/\/ just because rawX would exceed the screen width.\n+        var constraints = new Insets(-1, -1, -1, 0);\n+\n+        s.relocate(AnchorPoint.absolute(790, 10), constraints, AnchorPoint.TOP_LEFT, AnchorPolicy.AUTO);\n+        s.show();\n+\n+        \/\/ With only left constraint, rawX=790 is allowed (since right is disabled).\n+        assertEquals(790.0, peer.x, 0.0001);\n+        assertEquals(10.0, peer.y, 0.0001);\n+        assertNotWithinBounds(peer, toolkit.getScreens().getFirst(), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Tests side selection when the stage cannot fit in the constrained span.\n+     *\/\n+    @Test\n+    public void relocateWhenStageDoesNotFitInConstrainedSpanUsesAnchorToChooseSide() {\n+        \/\/ Make a screen smaller than the stage, so maxX < minX (and maxY < minY).\n+        toolkit.setScreens(new ScreenConfiguration(0, 0, 200, 200, 0, 0, 200, 200, 96));\n+        s.setWidth(300);\n+        s.setHeight(250);\n+\n+        \/\/ With TOP_LEFT, choose minX\/minY in non-fit scenario.\n+        s.relocate(AnchorPoint.absolute(0, 0), Insets.EMPTY, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED);\n+        s.show();\n+        assertEquals(0, peer.x, 0.0001);\n+        assertEquals(0, peer.y, 0.0001);\n+\n+        \/\/ Now recreate with TOP_RIGHT and ensure we choose maxX\/minY in non-fit scenario.\n+        s.hide();\n+        s.setWidth(300);\n+        s.setHeight(250);\n+        s.relocate(AnchorPoint.absolute(0, 0), Insets.EMPTY, AnchorPoint.TOP_RIGHT, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        assertEquals(-100, peer.x, 0.0001); \/\/ maxX = 200 - 300 = -100\n+        assertEquals(0, peer.y, 0.0001); \/\/ choose minY because TOP_RIGHT has y = 0\n+    }\n+\n+    \/**\n+     * Tests that {@code relocate()} uses the screen containing the request point to apply constraints.\n+     *\/\n+    @Test\n+    public void relocateUsesSecondScreenBoundsForConstraints() {\n+        toolkit.setScreens(\n+            new ScreenConfiguration(0, 0, 1920, 1200, 0, 0, 1920, 1172, 96),\n+            new ScreenConfiguration(1920, 160, 1440, 900, 1920, 160, 1440, 900, 96));\n+\n+        s.setWidth(400);\n+        s.setHeight(300);\n+\n+        \/\/ Point on screen 2, but near its bottom-right corner.\n+        var p = AnchorPoint.absolute(1920 + 1440 - 1, 160 + 900 - 1);\n+        s.relocate(p, Insets.EMPTY, AnchorPoint.TOP_LEFT, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        \/\/ Clamp within screen 2: x <= 1920+1440-400 = 2960, y <= 160+900-300 = 760\n+        assertEquals(2960, peer.x, 0.0001);\n+        assertEquals(760, peer.y, 0.0001);\n+        assertNotWithinBounds(peer, toolkit.getScreens().get(0), Insets.EMPTY);\n+        assertWithinBounds(peer, toolkit.getScreens().get(1), Insets.EMPTY);\n+    }\n+\n+    \/**\n+     * Tests {@code relocate()} behavior for a zero-size stage with proportional anchors (no NaN\/Infinity).\n+     *\/\n+    @Test\n+    public void relocateWithZeroSizeAndProportionalAnchorDoesNotProduceNaNAndConstrainsNormally() {\n+        \/\/ Force zero size at positioning time.\n+        s.setWidth(0);\n+        s.setHeight(0);\n+\n+        \/\/ Enable all edges (Insets.EMPTY), so negative coordinate requests are constrained.\n+        s.relocate(AnchorPoint.absolute(-10, -20), Insets.EMPTY, AnchorPoint.CENTER, AnchorPolicy.AUTO);\n+        s.show();\n+\n+        \/\/ With width\/height == 0, maxX == 800, and maxY == 600; raw is (-10, -20) => constrained to (0,0)\n+        assertEquals(0, peer.x, 0.0001);\n+        assertEquals(0, peer.y, 0.0001);\n+        assertFalse(Double.isNaN(peer.x) || Double.isInfinite(peer.x));\n+        assertFalse(Double.isNaN(peer.y) || Double.isInfinite(peer.y));\n+    }\n+\n+    \/**\n+     * Tests side selection when constraints define an impossible usable area for a zero-size stage.\n+     *\/\n+    @Test\n+    public void relocateWithZeroSizeAndImpossibleConstraintsChoosesSideUsingAnchorPosition() {\n+        s.setWidth(0);\n+        s.setHeight(0);\n+\n+        \/\/ Make the constrained space impossible even for a zero-size window:\n+        \/\/ Horizontal: minX = 500, maxX = 800 - 400 - 0 = 400 => maxX < minX\n+        \/\/ Vertical:   minY = 300, maxY = 600 - 400 - 0 = 200 => maxY < minY\n+        var constraints = new Insets(300, 400, 400, 500);\n+\n+        \/\/ x = 0.25 => choose minX (since x <= 0.5)\n+        \/\/ y = 0.75 => choose maxY (since y > 0.5)\n+        var anchor = AnchorPoint.proportional(0.25, 0.75);\n+\n+        s.relocate(AnchorPoint.absolute(0, 0), constraints, anchor, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        assertEquals(500, peer.x, 0.0001);\n+        assertEquals(200, peer.y, 0.0001);\n+    }\n+\n+    \/**\n+     * Tests that zero-size relocation with absolute anchors does not divide by zero in fallback paths.\n+     *\/\n+    @Test\n+    public void relocateWithZeroSizeAndAbsoluteAnchorDoesNotDivideByZero() {\n+        s.setWidth(0);\n+        s.setHeight(0);\n+\n+        \/\/ Force max < min to exercise the \"choose side\" fallback.\n+        var constraints = new Insets(300, 400, 400, 500);\n+        var anchor = AnchorPoint.absolute(10, 10);\n+\n+        s.relocate(AnchorPoint.absolute(0, 0), constraints, anchor, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        assertEquals(500, peer.x, 0.0001); \/\/ minX\n+        assertEquals(300, peer.y, 0.0001); \/\/ minY\n+    }\n+\n+    \/**\n+     * Tests that {@link AnchorPolicy#FIXED} constrains the stage within screen bounds for several anchors.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"relocateHonorsScreenBounds_arguments\")\n+    public void relocateWithFixedAnchorPolicyHonorsScreenBounds(\n+            AnchorPoint stageAnchor,\n+            Insets screenPadding,\n+            double stageW, double stageH,\n+            double requestX, double requestY) {\n+        s.setWidth(stageW);\n+        s.setHeight(stageH);\n+        s.relocate(AnchorPoint.absolute(requestX, requestY), screenPadding, stageAnchor, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), screenPadding);\n+    }\n+\n+    \/**\n+     * Tests that {@link AnchorPolicy#FIXED} constrains the stage within padded usable bounds for several anchors.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"relocateHonorsScreenBoundsWithPadding_arguments\")\n+    public void relocateWithFixedAnchorPolicyHonorsScreenBoundsWithPadding(\n+            AnchorPoint stageAnchor,\n+            Insets screenPadding,\n+            double stageW, double stageH,\n+            double requestX, double requestY) {\n+        s.setWidth(stageW);\n+        s.setHeight(stageH);\n+        s.relocate(AnchorPoint.absolute(requestX, requestY), screenPadding, stageAnchor, AnchorPolicy.FIXED);\n+        s.show();\n+\n+        assertWithinBounds(peer, toolkit.getScreens().getFirst(), screenPadding);\n+    }\n+\n+    private static Stream<Arguments> relocateHonorsScreenBounds_arguments() {\n+        return relocateHonorsScreenBounds_argumentsImpl(false);\n+    }\n+\n+    private static Stream<Arguments> relocateHonorsScreenBoundsWithPadding_arguments() {\n+        return relocateHonorsScreenBounds_argumentsImpl(true);\n+    }\n+\n+    private static Stream<Arguments> relocateHonorsScreenBounds_argumentsImpl(boolean padding) {\n+        final double screenW = 800;\n+        final double screenH = 600;\n+        final double stageW = 200;\n+        final double stageH = 200;\n+        final double overshoot = 10; \/\/ push past the edge to force adjustment\n+        final var insets = padding ? new Insets(10, 20, 30, 40) : Insets.EMPTY;\n+\n+        Stream.Builder<Arguments> b = Stream.builder();\n+        b.add(Arguments.of(AnchorPoint.TOP_LEFT, insets, stageW, stageH,\n+                           screenW - stageW + overshoot, screenH - stageH + overshoot));\n+        b.add(Arguments.of(AnchorPoint.TOP_RIGHT, insets, stageW, stageH,\n+                           stageW - overshoot, screenH - stageH + overshoot));\n+        b.add(Arguments.of(AnchorPoint.BOTTOM_LEFT, insets, stageW, stageH,\n+                           screenW - stageW + overshoot, stageH - overshoot));\n+        b.add(Arguments.of(AnchorPoint.BOTTOM_RIGHT, insets, stageW, stageH,\n+                           stageW - overshoot, stageH - overshoot));\n+        return b.build();\n+    }\n+\n+    private static void assertWithinBounds(StubStage peer, ScreenConfiguration screen, Insets padding) {\n+        assertTrue(isWithinBounds(peer, screen, padding), \"Stage is not within bounds\");\n+    }\n+\n+    private static void assertNotWithinBounds(StubStage peer, ScreenConfiguration screen, Insets padding) {\n+        assertFalse(isWithinBounds(peer, screen, padding), \"Stage is within bounds\");\n+    }\n+\n+    private static boolean isWithinBounds(StubStage peer, ScreenConfiguration screen, Insets padding) {\n+        return screen.getMinX() + padding.getLeft() <= peer.x\n+            && screen.getMinY() + padding.getTop() <= peer.y\n+            && screen.getMinX() + screen.getWidth() - padding.getRight() >= peer.x + peer.width\n+            && screen.getMinY() + screen.getHeight() - padding.getBottom() >= peer.y + peer.height;\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/stage\/StageTest.java","additions":670,"deletions":9,"binary":false,"changes":679,"status":"modified"}]}