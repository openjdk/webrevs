{"files":[{"patch":"@@ -86,3 +86,1 @@\n-    protected void _setAlpha(long ptr, float alpha) {\n-        \/\/ Not supported\n-    }\n+    protected native void _setAlpha(long ptr, float alpha);\n@@ -91,4 +89,1 @@\n-    protected boolean _setBackground(long ptr, float r, float g, float b) {\n-        \/\/Not supported\n-        return false;\n-    }\n+    protected native boolean _setBackground(long ptr, float r, float g, float b);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkWindow.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-static GtkWindow *gdk_window_handle_to_gtk(jlong handle) {\n+static GdkWindow *get_gdk_window(jlong handle) {\n@@ -70,1 +70,1 @@\n-                ? ((WindowContext*)JLONG_TO_PTR(handle))->get_gtk_window()\n+                ? ((WindowContext*)JLONG_TO_PTR(handle))->get_gdk_window()\n@@ -74,0 +74,9 @@\n+static void on_dialog_realize_set_parent(GtkWidget *dialog, gpointer user_data) {\n+    GdkWindow *parent_gdk_window = (GdkWindow *) user_data;\n+    GdkWindow *dialog_gdk_window = gtk_widget_get_window(dialog);\n+\n+    if (dialog_gdk_window && parent_gdk_window) {\n+        gdk_window_set_transient_for(dialog_gdk_window, parent_gdk_window);\n+    }\n+}\n+\n@@ -115,1 +124,1 @@\n-    GtkWidget* chooser = gtk_file_chooser_dialog_new(chooser_title, gdk_window_handle_to_gtk(parent),\n+    GtkWidget* chooser = gtk_file_chooser_dialog_new(chooser_title, NULL,\n@@ -123,0 +132,2 @@\n+    g_signal_connect(chooser, \"realize\", G_CALLBACK(on_dialog_realize_set_parent), get_gdk_window(parent));\n+\n@@ -211,1 +222,1 @@\n-            gdk_window_handle_to_gtk(parent),\n+            NULL,\n@@ -219,0 +230,2 @@\n+    g_signal_connect(chooser, \"realize\", G_CALLBACK(on_dialog_realize_set_parent), get_gdk_window(parent));\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassCommonDialogs.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -22,1 +22,1 @@\n- * or visit www.oracle.com if you need additional information or have any\n+ * or visit www.oracle.com if you need additiFonal information or have any\n@@ -276,1 +276,1 @@\n-    tmp = glass_pixbuf_from_window(root_window, x, y, width, height);\n+    tmp = gdk_pixbuf_get_from_window(root_window, x, y, width, height);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassRobot.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -315,0 +315,31 @@\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setAlpha\n+ * Signature: (JF)V\n+ *\/\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setAlpha\n+  (JNIEnv * env, jobject obj, jlong ptr, jfloat alpha)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_alpha(alpha);\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_GtkWindow\n+ * Method:    _setBackground\n+ * Signature: (JFFF)Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setBackground\n+  (JNIEnv * env, jobject obj, jlong ptr, jfloat r, jfloat g, jfloat b)\n+{\n+    (void)env;\n+    (void)obj;\n+\n+    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n+    ctx->set_background(r, g, b);\n+    return JNI_TRUE;\n+}\n+\n@@ -516,7 +547,1 @@\n-    GdkWindow *win = ctx->get_gdk_window();\n-\n-    if (win == NULL) {\n-        return 0;\n-    }\n-\n-    return GDK_WINDOW_XID(win);\n+    return ctx->get_native_window();\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassWindow.cpp","additions":32,"deletions":7,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -569,1 +569,0 @@\n-static void configure_opaque_window(GtkWidget *window);\n@@ -577,10 +576,0 @@\n-GdkScreen * glass_gdk_window_get_screen(GdkWindow * gdkWindow)\n-{\n-#ifdef GLASS_GTK3\n-        GdkVisual * gdkVisual = gdk_window_get_visual(gdkWindow);\n-        return gdk_visual_get_screen(gdkVisual);\n-#else\n-        return gdk_window_get_screen(gdkWindow);\n-#endif\n-}\n-\n@@ -620,1 +609,0 @@\n-#ifdef GLASS_GTK3\n@@ -624,3 +612,0 @@\n-#else\n-        gdk_display_get_pointer(gdk_display_get_default(), NULL, x, y, NULL);\n-#endif\n@@ -631,6 +616,1 @@\n-#ifdef GLASS_GTK3\n-        return gdk_display_device_is_grabbed(gdk_display_get_default(), device);\n-#else\n-        (void) device;\n-        return gdk_display_pointer_is_grabbed(gdk_display_get_default());\n-#endif\n+    return gdk_display_device_is_grabbed(gdk_display_get_default(), device);\n@@ -641,6 +621,1 @@\n-#ifdef GLASS_GTK3\n-        gdk_device_ungrab(device, GDK_CURRENT_TIME);\n-#else\n-        (void) device;\n-        gdk_pointer_ungrab(GDK_CURRENT_TIME);\n-#endif\n+    gdk_device_ungrab(device, GDK_CURRENT_TIME);\n@@ -652,18 +627,1 @@\n-#ifdef GLASS_GTK3\n-        return gdk_device_get_window_at_position(device, x, y);\n-#else\n-        (void) device;\n-        return gdk_display_get_window_at_pointer(gdk_display_get_default(), x, y);\n-#endif\n-}\n-\n-void\n-glass_gtk_configure_transparency_and_realize(GtkWidget *window,\n-                                             gboolean transparent) {\n-        gboolean isTransparent = glass_configure_window_transparency(window, transparent);\n-        gtk_widget_realize(window);\n-}\n-\n-void\n-glass_gtk_window_configure_from_visual(GtkWidget *widget, GdkVisual *visual) {\n-    glass_widget_set_visual(widget, visual);\n+    return gdk_device_get_window_at_position(device, x, y);\n@@ -677,17 +635,7 @@\n-#ifdef GLASS_GTK3\n-        GdkVisual *visual = gdk_screen_get_rgba_visual(default_screen);\n-        if (visual\n-                && gdk_display_supports_composite(default_display)\n-                && gdk_screen_is_composited(default_screen)) {\n-            glass_widget_set_visual(window, visual);\n-            return TRUE;\n-        }\n-#else\n-        GdkColormap *colormap = gdk_screen_get_rgba_colormap(default_screen);\n-        if (colormap\n-                && gdk_display_supports_composite(default_display)\n-                && gdk_screen_is_composited(default_screen)) {\n-            gtk_widget_set_colormap(window, colormap);\n-            return TRUE;\n-        }\n-#endif\n+    GdkVisual *visual = gdk_screen_get_rgba_visual(default_screen);\n+    if (visual\n+            && gdk_display_supports_composite(default_display)\n+            && gdk_screen_is_composited(default_screen)) {\n+        glass_widget_set_visual(window, visual);\n+        return TRUE;\n+    }\n@@ -698,6 +646,0 @@\n-void\n-glass_gdk_window_get_size(GdkWindow *window, gint *w, gint *h) {\n-    *w = gdk_window_get_width(window);\n-    *h = gdk_window_get_height(window);\n-}\n-\n@@ -706,7 +648,3 @@\n-#ifdef GLASS_GTK3\n-        gdk_device_get_position(\n-            gdk_device_manager_get_client_pointer(\n-                gdk_display_get_device_manager(display)), NULL , x, y);\n-#else\n-        gdk_display_get_pointer(display, NULL, x, y, NULL);\n-#endif\n+    gdk_device_get_position(\n+        gdk_device_manager_get_client_pointer(\n+            gdk_display_get_device_manager(display)), NULL , x, y);\n@@ -728,11 +666,4 @@\n-static void\n-configure_opaque_window(GtkWidget *window) {\n-    (void) window;\n-\/* We need to pick a visual that really is glx compatible\n- * instead of using the default visual\n- *\/\n- \/* see: JDK-8087516 for why this is commented out\n-    glass_widget_set_visual(window,\n-                          gdk_screen_get_system_visual(\n-                              gdk_screen_get_default()));\n-  *\/\n+void glass_print_window_transparency_not_supported() {\n+    fprintf(stderr, \"Can't create transparent stage, because your screen doesn't support alpha channel.\"\n+           \" You need to enable XComposite extension.\\n\");\n+    fflush(stderr);\n@@ -748,4 +679,1 @@\n-        fprintf(stderr,\"Can't create transparent stage, because your screen doesn't\"\n-               \" support alpha channel.\"\n-               \" You need to enable XComposite extension.\\n\");\n-        fflush(stderr);\n+        glass_print_window_transparency_not_supported();\n@@ -754,1 +682,0 @@\n-    configure_opaque_window(window);\n@@ -765,10 +692,1 @@\n-#ifdef GLASS_GTK3\n-        ret = gdk_pixbuf_get_from_window (window, srcx, srcy, width, height);\n-#else\n-        ret = gdk_pixbuf_get_from_drawable (NULL,\n-            window,\n-            NULL,\n-            srcx, srcy,\n-            0, 0,\n-            width, height);\n-#endif\n+     gdk_pixbuf_get_from_window (window, srcx, srcy, width, height);\n@@ -778,37 +696,0 @@\n-void\n-glass_window_apply_shape_mask(GdkWindow *window,\n-    void* data, uint width, uint height)\n-{\n-#ifdef GLASS_GTK3\n-    (void) window;\n-    (void) data;\n-    (void) width;\n-    (void) height;\n-#else\n-        GdkPixbuf* pixbuf = gdk_pixbuf_new_from_data((guchar *) data,\n-                GDK_COLORSPACE_RGB, TRUE, 8, width, height, width * 4, NULL, NULL);\n-\n-        if (GDK_IS_PIXBUF(pixbuf)) {\n-            GdkBitmap* mask = NULL;\n-            gdk_pixbuf_render_pixmap_and_mask(pixbuf, NULL, &mask, 128);\n-\n-            gdk_window_input_shape_combine_mask(window, mask, 0, 0);\n-\n-            g_object_unref(pixbuf);\n-            if (mask) {\n-                g_object_unref(mask);\n-            }\n-        }\n-#endif\n-}\n-\n-void\n-glass_window_reset_input_shape_mask(GdkWindow *window)\n-{\n-#ifdef GLASS_GTK3\n-        gdk_window_input_shape_combine_region(window, NULL, 0, 0);\n-#else\n-        gdk_window_input_shape_combine_mask(window, NULL, 0, 0);\n-#endif\n-}\n-\n@@ -825,1 +706,0 @@\n-#ifdef GLASS_GTK3\n@@ -830,4 +710,0 @@\n-#else\n-    (void) display;\n-    (void) scale;\n-#endif\n@@ -841,1 +717,0 @@\n-#ifdef GLASS_GTK3\n@@ -843,4 +718,0 @@\n-#else\n-        GdkColormap *colormap = gdk_colormap_new(visual, TRUE);\n-        gtk_widget_set_colormap (widget, colormap);\n-#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.cpp","additions":19,"deletions":148,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -250,0 +250,1 @@\n+#define LOG6(msg, param1, param2, param3, param4, param5, param6) {printf(msg, param1, param2, param3, param4, param5, param6);fflush(stdout);}\n@@ -267,0 +268,1 @@\n+#define LOG6(msg, param1, param2, param3, param4, param5, param6)\n@@ -310,3 +312,0 @@\n-GdkScreen *\n-glass_gdk_window_get_screen(GdkWindow * gdkWindow);\n-\n@@ -322,6 +321,0 @@\n-void\n-glass_gdk_master_pointer_grab(GdkEvent *event, GdkWindow *window, GdkCursor *cursor);\n-\n-void\n-glass_gdk_master_pointer_ungrab(GdkEvent *event);\n-\n@@ -341,3 +334,0 @@\n-void\n-glass_gtk_configure_transparency_and_realize(GtkWidget *window,\n-                                                  gboolean transparent);\n@@ -350,6 +340,0 @@\n-void\n-glass_gtk_window_configure_from_visual(GtkWidget *widget, GdkVisual *visual);\n-\n-void\n-glass_gdk_window_get_size(GdkWindow *window, gint *w, gint *h);\n-\n@@ -362,0 +346,3 @@\n+void\n+glass_print_window_transparency_not_supported();\n+\n@@ -374,3 +361,0 @@\n-void\n-glass_window_reset_input_shape_mask(GdkWindow *window);\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.h","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -50,26 +50,0 @@\n-#define DEFAULT_WIDTH 320\n-#define DEFAULT_HEIGHT 200\n-\n-static gboolean event_realize(GtkWidget *widget, gpointer user_data) {\n-    WindowContext *ctx = USER_PTR_TO_CTX(user_data);\n-    ctx->process_realize();\n-\n-    return FALSE;\n-}\n-\n-gboolean enter_fullscreen_later(gpointer data) {\n-    GtkWindow *window = GTK_WINDOW(data);\n-\n-    \/\/ might have been destroyed\n-    if (GTK_IS_WINDOW(window)) {\n-        gtk_window_fullscreen(window);\n-    }\n-\n-    return G_SOURCE_REMOVE;\n-}\n-\n-static void process_pending_events() {\n-    while (gtk_events_pending()) {\n-        gtk_main_iteration_do(FALSE);\n-    }\n-}\n@@ -91,0 +65,15 @@\n+static bool gdk_visual_is_rgba(GdkVisual *visual) {\n+    if (!visual) return false;\n+\n+    int depth = gdk_visual_get_depth(visual);\n+    guint32 red_mask, green_mask, blue_mask;\n+    gdk_visual_get_red_pixel_details(visual, &red_mask, NULL, NULL);\n+    gdk_visual_get_green_pixel_details(visual, &green_mask, NULL, NULL);\n+    gdk_visual_get_blue_pixel_details(visual, &blue_mask, NULL, NULL);\n+\n+    return (depth == 32\n+            && red_mask == 0xff0000\n+            && green_mask == 0x00ff00\n+            && blue_mask == 0x0000ff);\n+}\n+\n@@ -96,1 +85,1 @@\n-static inline jint gtk_button_number_to_mouse_button(guint button) {\n+static inline jint gdk_button_number_to_mouse_button(guint button) {\n@@ -139,1 +128,1 @@\n-    was_mapped = false;\n+    mapped = false;\n@@ -142,2 +131,38 @@\n-    gtk_widget = gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);\n-    g_signal_connect(G_OBJECT(gtk_widget), \"realize\", G_CALLBACK(event_realize), this);\n+    if (frame_type != TITLED) {\n+        initial_wmf = GDK_FUNC_ALL;\n+    }\n+\n+    load_cached_extents();\n+    update_window_size();\n+\n+    GdkWindowAttributesType attr_types = (GdkWindowAttributesType) (GDK_WA_VISUAL);\n+    GdkWindowAttr attributes;\n+    attributes.visual = find_best_visual();\n+    attributes.wclass = GDK_INPUT_OUTPUT;\n+    attributes.event_mask = GDK_FILTERED_EVENTS_MASK;\n+    attributes.width = DEFAULT_WIDTH;\n+    attributes.height = DEFAULT_HEIGHT;\n+\n+    if (window_type == POPUP) {\n+        attributes.window_type = GDK_WINDOW_TEMP;\n+        attr_types = (GdkWindowAttributesType) (attr_types | GDK_WA_NOREDIR);\n+        attributes.override_redirect = TRUE;\n+    } else {\n+        attributes.window_type = GDK_WINDOW_TOPLEVEL;\n+        if (gchar* app_name = get_application_name()) {\n+            attributes.wmclass_name = app_name;\n+            attributes.wmclass_class = app_name;\n+            attr_types = (GdkWindowAttributesType) (attr_types | GDK_WA_WMCLASS);\n+        }\n+    }\n+\n+    if (window_type == UTILITY) {\n+        attributes.type_hint = GDK_WINDOW_TYPE_HINT_UTILITY;\n+        attr_types = (GdkWindowAttributesType) (attr_types | GDK_WA_TYPE_HINT);\n+    }\n+\n+    gdk_window = gdk_window_new(gdk_get_default_root_window(), &attributes, attr_types);\n+\n+    if (frame_type == TITLED) {\n+        request_frame_extents();\n+    }\n@@ -145,3 +170,14 @@\n-    if (gchar* app_name = get_application_name()) {\n-        gtk_window_set_wmclass(GTK_WINDOW(gtk_widget), app_name, app_name);\n-        g_free(app_name);\n+    if (frame_type != TRANSPARENT) {\n+        GdkRGBA white = { 1.0, 1.0, 1.0, 1.0 };\n+        gdk_window_set_background_rgba(gdk_window, &white);\n+    }\n+\n+    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);\n+    gdk_window_register_dnd(gdk_window);\n+\n+    if (initial_wmf) {\n+        gdk_window_set_functions(gdk_window, initial_wmf);\n+    }\n+\n+    if (frame_type != TITLED) {\n+        gdk_window_set_decorations(gdk_window,  (GdkWMDecoration) 0);\n@@ -153,1 +189,1 @@\n-            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);\n+            gdk_window_set_keep_above(gdk_window, TRUE);\n@@ -157,3 +193,3 @@\n-    if (type == UTILITY) {\n-        gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_UTILITY);\n-    }\n+    set_title(\"\");\n+    update_window_constraints();\n+}\n@@ -161,1 +197,6 @@\n-    glong xvisualID = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);\n+GdkVisual* WindowContext::find_best_visual() {\n+    \/\/ This comes from prism-es2\n+    static glong xvisualID = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);\n+    static GdkVisual *prismVisual = (xvisualID != 0)\n+                ? gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID)\n+                : NULL;\n@@ -163,3 +204,7 @@\n-    if (xvisualID != 0) {\n-        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);\n-        glass_gtk_window_configure_from_visual(gtk_widget, visual);\n+    if (frame_type == TRANSPARENT && !gdk_visual_is_rgba(prismVisual)) {\n+        GdkVisual *rgbaVisual = gdk_screen_get_rgba_visual(gdk_screen_get_default());\n+        if (rgbaVisual) {\n+            return rgbaVisual;\n+        } else {\n+            glass_print_window_transparency_not_supported();\n+        }\n@@ -168,4 +213,4 @@\n-    gtk_widget_set_app_paintable(gtk_widget, TRUE);\n-\n-    glass_configure_window_transparency(gtk_widget, frame_type == TRANSPARENT);\n-    gtk_window_set_title(GTK_WINDOW(gtk_widget), \"\");\n+    if (prismVisual != NULL) {\n+        LOG0(\"Using prism visual\");\n+        return prismVisual;\n+    }\n@@ -173,2 +218,2 @@\n-    gtk_window_set_decorated(GTK_WINDOW(gtk_widget), frame_type == TITLED);\n-    load_cached_extents();\n+    LOG0(\"Using GDK system visual\\n\");\n+    return gdk_screen_get_system_visual(gdk_screen_get_default());\n@@ -185,0 +230,9 @@\n+\/\/ Returns de XWindow ID to be used in rendering\n+XID WindowContext::get_native_window() {\n+    \/\/ This is used to delay the window map (it's only really mapped when there's\n+    \/\/ something rendered)\n+    if (!is_visible()) return 0;\n+\n+    return GDK_WINDOW_XID(gdk_window);\n+}\n+\n@@ -205,1 +259,1 @@\n-    if (was_mapped || window_type == POPUP) return;\n+    if (mapped || window_type == POPUP) return;\n@@ -207,1 +261,0 @@\n-    was_mapped = true;\n@@ -209,0 +262,2 @@\n+    move_resize(geometry.x, geometry.y, true, true, geometry.width.view, geometry.height.view);\n+    mapped = true;\n@@ -210,16 +265,0 @@\n-    \/\/ Work around JDK-8337400 (Initial window position is not centered on Xorg)\n-    if (geometry.x > 0 || geometry.y > 0) {\n-        move(geometry.x, geometry.y);\n-    }\n-\n-    if (geometry.width <= 0) {\n-        geometry.width = DEFAULT_WIDTH - geometry.extents.width;\n-    }\n-\n-    if (geometry.height <= 0) {\n-        geometry.height = DEFAULT_HEIGHT - geometry.extents.height;\n-    }\n-\n-    resize(geometry.width, geometry.height);\n-\n-    \/\/ Work-around for Xorg initial state before show to work\n@@ -227,1 +266,0 @@\n-        process_pending_events();\n@@ -292,5 +330,0 @@\n-        \/\/ FIX JDK-8226537: this method calls set_owner(NULL) which prevents\n-        \/\/ WindowContext::process_destroy() to call remove_child() (because children\n-        \/\/ is being iterated here) but also prevents gtk_window_set_transient_for from\n-        \/\/ being called - this causes the crash on gnome.\n-        gtk_window_set_transient_for((*it)->get_gtk_window(), NULL);\n@@ -329,0 +362,9 @@\n+void WindowContext::notify_repaint() {\n+    if (jview) {\n+        LOG0(\"jViewNotifyRepaint\\n\");\n+        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, 0, 0,\n+                            geometry.width.view, geometry.height.view);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+}\n+\n@@ -391,1 +433,1 @@\n-    jint button = gtk_button_number_to_mouse_button(event->button);\n+    jint button = gdk_button_number_to_mouse_button(event->button);\n@@ -584,2 +626,0 @@\n-    applyShapeMask(data, width, height);\n-\n@@ -599,1 +639,1 @@\n-    gtk_window_set_transient_for(child->get_gtk_window(), this->get_gtk_window());\n+    gdk_window_set_transient_for(child->get_gdk_window(), gdk_window);\n@@ -604,1 +644,0 @@\n-    gtk_window_set_transient_for(child->get_gtk_window(), NULL);\n@@ -608,1 +647,1 @@\n-    return gtk_widget_get_visible(gtk_widget);\n+    return gdk_window_is_visible(gdk_window);\n@@ -685,0 +724,5 @@\n+void WindowContext::set_background(float r, float g, float b) {\n+    GdkRGBA rgba = {r, g, b, 1.0};\n+    gdk_window_set_background_rgba(gdk_window, &rgba);\n+}\n+\n@@ -713,12 +757,0 @@\n-void WindowContext::update_window_size_location() {\n-    if (!geometry.needs_to_restore_geometry\n-        || (gdk_window_get_state(gdk_window) & (GDK_WINDOW_STATE_FULLSCREEN | GDK_WINDOW_STATE_MAXIMIZED))) {\n-        return;\n-    }\n-\n-    process_pending_events();\n-    geometry.needs_to_restore_geometry = false;\n-    move(geometry.x, geometry.y);\n-    LOG2(\"update_window_size_location: %d, %d\\n\", geometry.width, geometry.height);\n-    resize(geometry.width, geometry.height);\n-}\n@@ -747,1 +779,0 @@\n-\n@@ -767,6 +798,2 @@\n-            if (geometry.width <= 0 && geometry.height <= 0) {\n-                return;\n-            }\n-\n-            int newW = gdk_window_get_width(gdk_window);\n-            int newH = gdk_window_get_height(gdk_window);\n+            int newW = geometry.width.view;\n+            int newH = geometry.height.view;\n@@ -777,4 +804,6 @@\n-            \/\/ Re-add the extents and then subtract the new\n-            newW = newW\n-                + ((geometry.frame_extents_received) ? geometry.extents.width : 0)\n-                - rect.width;\n+            if (geometry.width.type == BOUNDSTYPE_WINDOW) {\n+                \/\/ Re-add the extents and then subtract the new\n+                newW = newW\n+                    + ((geometry.frame_extents_received) ? geometry.extents.width : 0)\n+                    - rect.width;\n+            }\n@@ -782,4 +811,6 @@\n-            \/\/ Re-add the extents and then subtract the new\n-            newH = newH\n-                + ((geometry.frame_extents_received) ? geometry.extents.height : 0)\n-                - rect.height;\n+            if (geometry.height.type == BOUNDSTYPE_WINDOW) {\n+                \/\/ Re-add the extents and then subtract the new\n+                newH = newH\n+                    + ((geometry.frame_extents_received) ? geometry.extents.height : 0)\n+                    - rect.height;\n+            }\n@@ -808,2 +839,2 @@\n-            geometry.width = newW;\n-            geometry.height = newH;\n+            geometry.width.view = newW;\n+            geometry.height.view = newH;\n@@ -812,0 +843,1 @@\n+            update_window_size();\n@@ -813,2 +845,2 @@\n-            LOG4(\"Geometry after frame extents: %d, %d - %d, %d\\n\", geometry.x,\n-                        geometry.y, geometry.width, geometry.height);\n+            LOG6(\"Geometry after frame extents: x,y: %d,%d \/ cw,ch: %d,%d \/ ww,wh: %d,%d\\n\", geometry.x, geometry.y,\n+                    geometry.width.view, geometry.height.view, geometry.width.window, geometry.height.window);\n@@ -816,1 +848,1 @@\n-            update_window_constraints(newW, newH);\n+            update_window_constraints();\n@@ -818,6 +850,2 @@\n-            if ((gdk_window_get_state(gdk_window)\n-                    & (GDK_WINDOW_STATE_FULLSCREEN | GDK_WINDOW_STATE_MAXIMIZED)) == 0) {\n-                resize(newW, newH);\n-                move(x, y);\n-            } else {\n-                geometry.needs_to_restore_geometry = true;\n+            if (is_window_floating(gdk_window_get_state(gdk_window))) {\n+                move_resize(x, y, true, true, newW, newH);\n@@ -829,6 +857,0 @@\n-void WindowContext::save_geometry() {\n-    geometry.width = gdk_window_get_width(gdk_window);\n-    geometry.height = gdk_window_get_height(gdk_window);\n-    gdk_window_get_root_origin(gdk_window, &geometry.x, &geometry.y);\n-}\n-\n@@ -903,0 +925,1 @@\n+    LOG0(\"process_state\\n\");\n@@ -910,9 +933,0 @@\n-    \/\/ Those represent the real current size in the state\n-    int cw = gdk_window_get_width(gdk_window);\n-    int ch = gdk_window_get_height(gdk_window);\n-\n-    int ww, wh;\n-    get_window_size(&ww, &wh);\n-\n-    LOG4(\"process_state: cw = %d, ch = %d, ww = %d, wh = %d\\n\", cw, ch, ww, wh);\n-\n@@ -922,1 +936,1 @@\n-        notify_window_resize(com_sun_glass_events_WindowEvent_RESTORE, ww, wh);\n+        notify_window_resize(com_sun_glass_events_WindowEvent_RESTORE);\n@@ -925,1 +939,1 @@\n-        notify_window_resize(com_sun_glass_events_WindowEvent_MINIMIZE, ww, wh);\n+        notify_window_resize(com_sun_glass_events_WindowEvent_MINIMIZE);\n@@ -928,1 +942,1 @@\n-        notify_window_resize(com_sun_glass_events_WindowEvent_MAXIMIZE, ww, wh);\n+        notify_window_resize(com_sun_glass_events_WindowEvent_MAXIMIZE);\n@@ -936,2 +950,1 @@\n-        GdkRectangle rect = { 0, 0, cw, ch };\n-        notify_repaint(&rect);\n+        notify_repaint();\n@@ -960,1 +973,1 @@\n-    notify_view_resize(cw, ch);\n+    notify_view_resize();\n@@ -964,12 +977,0 @@\n-\n-    \/\/ This only accounts MAXIMIZED and FULLSCREEN\n-    bool restored = (event->changed_mask & (GDK_WINDOW_STATE_MAXIMIZED\n-                                            | GDK_WINDOW_STATE_FULLSCREEN))\n-                    && ((event->new_window_state & (GDK_WINDOW_STATE_MAXIMIZED\n-                                            | GDK_WINDOW_STATE_FULLSCREEN)) == 0);\n-\n-    \/\/ In case the size or location changed while maximized of fullscreened\n-    if (restored && geometry.needs_to_restore_geometry) {\n-        LOG0(\"restored, call update_window_size_location\\n\");\n-        update_window_size_location();\n-    }\n@@ -978,22 +979,1 @@\n-void WindowContext::process_realize() {\n-    LOG0(\"realized\\n\");\n-    gdk_window = gtk_widget_get_window(gtk_widget);\n-\n-    if (frame_type == TITLED) {\n-        request_frame_extents();\n-    }\n-\n-    gdk_window_set_events(gdk_window, GDK_FILTERED_EVENTS_MASK);\n-    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);\n-    gdk_window_register_dnd(gdk_window);\n-\n-    if (frame_type != TITLED) {\n-        initial_wmf = GDK_FUNC_ALL;\n-    }\n-\n-    if (initial_wmf) {\n-        gdk_window_set_functions(gdk_window, initial_wmf);\n-    }\n-}\n-\n-void WindowContext::notify_window_resize(int state, int width, int height) {\n+void WindowContext::notify_window_resize(int state) {\n@@ -1001,2 +981,4 @@\n-        LOG3(\"jWindowNotifyResize: %d -> %d, %d\\n\", state, width, height);\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize, state, width, height);\n+        LOG3(\"jWindowNotifyResize: %d -> %d, %d\\n\", state,\n+                    geometry.width.window, geometry.height.window);\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize, state,\n+                    geometry.width.window, geometry.height.window);\n@@ -1007,1 +989,1 @@\n-void WindowContext::notify_window_move(int x, int y) {\n+void WindowContext::notify_window_move() {\n@@ -1009,2 +991,2 @@\n-        LOG2(\"jWindowNotifyMove: %d, %d\\n\", x, y);\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove, x, y);\n+        LOG2(\"jWindowNotifyMove: %d, %d\\n\", geometry.x, geometry.y);\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove, geometry.x, geometry.y);\n@@ -1015,1 +997,1 @@\n-void WindowContext::notify_view_resize(int width, int height) {\n+void WindowContext::notify_view_resize() {\n@@ -1017,2 +999,2 @@\n-        LOG2(\"jViewNotifyResize: %d, %d\\n\", width, height);\n-        mainEnv->CallVoidMethod(jview, jViewNotifyResize, width, height);\n+        LOG2(\"jViewNotifyResize: %d, %d\\n\", geometry.width.view, geometry.height.view);\n+        mainEnv->CallVoidMethod(jview, jViewNotifyResize, geometry.width.view, geometry.height.view);\n@@ -1024,8 +1006,1 @@\n-    int ww, wh, cw, ch;\n-\n-    get_window_size(&ww, &wh);\n-    get_view_size(&cw, &ch);\n-\n-    GdkWindowState state = (gtk_widget_get_realized(gtk_widget))\n-            ? gdk_window_get_state(gdk_window)\n-            : (GdkWindowState) 0;\n+    GdkWindowState state = gdk_window_get_state(gdk_window);\n@@ -1035,2 +1010,1 @@\n-                                : com_sun_glass_events_WindowEvent_RESIZE,\n-                                ww, wh);\n+                                : com_sun_glass_events_WindowEvent_RESIZE);\n@@ -1038,1 +1012,1 @@\n-    notify_view_resize(cw, ch);\n+    notify_view_resize();\n@@ -1060,1 +1034,1 @@\n-    gint root_x, root_y, origin_x, origin_y;\n+    int root_x, root_y, origin_x, origin_y;\n@@ -1071,8 +1045,2 @@\n-    int cw = event->width;\n-    int ch = event->height;\n-\n-    notify_view_resize(cw, ch);\n-    notify_view_move();\n-\n-    int ww = cw;\n-    int wh = ch;\n+    int ww = event->width;\n+    int wh = event->height;\n@@ -1089,0 +1057,9 @@\n+    if (mapped) {\n+        geometry.x = root_x;\n+        geometry.y = root_y;\n+        geometry.width.view = event->width;\n+        geometry.height.view = event->height;\n+        geometry.width.window = ww;\n+        geometry.height.window = wh;\n+    }\n+\n@@ -1091,2 +1068,2 @@\n-                            : com_sun_glass_events_WindowEvent_RESIZE,\n-                            ww, wh);\n+                            : com_sun_glass_events_WindowEvent_RESIZE);\n+    notify_view_resize();\n@@ -1094,1 +1071,2 @@\n-    notify_window_move(root_x, root_y);\n+    notify_window_move();\n+    notify_view_move();\n@@ -1109,12 +1087,0 @@\n-void WindowContext::remove_window_constraints() {\n-    LOG0(\"remove_window_constraints\\n\");\n-    GdkGeometry reset;\n-    reset.min_width = 1;\n-    reset.min_height = 1;\n-    reset.max_width = G_MAXINT;\n-    reset.max_height = G_MAXINT;\n-\n-    gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &reset,\n-                                    (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));\n-}\n-\n@@ -1122,3 +1088,1 @@\n-    int cw, ch;\n-    get_view_size(&cw, &ch);\n-    update_window_constraints(cw, ch);\n+    update_window_constraints(false);\n@@ -1127,1 +1091,1 @@\n-void WindowContext::update_window_constraints(int width, int height) {\n+void WindowContext::update_window_constraints(bool ignored_resizable) {\n@@ -1129,1 +1093,1 @@\n-    if ((gtk_widget_get_realized(gtk_widget) && !is_window_floating(gdk_window_get_state(gdk_window)))\n+    if (!is_window_floating(gdk_window_get_state(gdk_window))\n@@ -1137,1 +1101,1 @@\n-    if (resizable.value && !is_disabled) {\n+    if ((resizable.value || ignored_resizable) && !is_disabled) {\n@@ -1151,4 +1115,4 @@\n-        hints.min_width = width;\n-        hints.min_height = height;\n-        hints.max_width = width;\n-        hints.max_height = height;\n+        hints.min_width = geometry.width.view;\n+        hints.min_height = geometry.height.view;\n+        hints.max_width = geometry.width.view;\n+        hints.max_height = geometry.height.view;\n@@ -1160,2 +1124,3 @@\n-    gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &hints,\n-                                  (GdkWindowHints) (GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));\n+    \/\/ GDK_HINT_USER_POS is used for the initial position to work\n+    gdk_window_set_geometry_hints(gdk_window, &hints,\n+            (GdkWindowHints) (GDK_HINT_USER_POS |  GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));\n@@ -1165,0 +1130,1 @@\n+    LOG1(\"set_resizable: %d\\n\", res);\n@@ -1172,1 +1138,1 @@\n-        gtk_widget_show(gtk_widget);\n+        gdk_window_show(gdk_window);\n@@ -1180,1 +1146,1 @@\n-        gtk_widget_hide(gtk_widget);\n+        gdk_window_hide(gdk_window);\n@@ -1208,0 +1174,1 @@\n+        geometry.width.type = BOUNDSTYPE_WINDOW;\n@@ -1210,0 +1177,2 @@\n+        \/\/ once set to window, stick with it\n+        if (BOUNDSTYPE_UNKNOWN) geometry.width.type = BOUNDSTYPE_VIEW;\n@@ -1214,0 +1183,1 @@\n+        geometry.height.type = BOUNDSTYPE_WINDOW;\n@@ -1216,0 +1186,2 @@\n+        \/\/ once set to window, stick with it\n+        if (BOUNDSTYPE_UNKNOWN) geometry.height.type = BOUNDSTYPE_VIEW;\n@@ -1219,43 +1191,1 @@\n-    if (xSet) geometry.x = x;\n-    if (ySet) geometry.y = y;\n-\n-    if (newW > 0) geometry.width = newW;\n-    if (newH > 0) geometry.height = newH;\n-\n-    LOG2(\"set_bounds: geometry.width = %d, geometry.height = %d\\n\", geometry.width, geometry.height);\n-\n-    if (gtk_widget_get_realized(gtk_widget)) {\n-        GdkWindowState state = gdk_window_get_state(gdk_window);\n-\n-        \/\/ If it is in fullscreen mode, it will be applied later on restore\n-        if (!geometry.needs_to_restore_geometry &&\n-                (state & GDK_WINDOW_STATE_FULLSCREEN)) {\n-            LOG0(\"set_bounds: needs_to_restore_geometry = true\\n\");\n-            geometry.needs_to_restore_geometry = true;\n-        }\n-\n-        if (geometry.needs_to_restore_geometry || (state & GDK_WINDOW_STATE_MAXIMIZED)) {\n-            LOG0(\"need to restore geometry of maximized\\n\");\n-            \/\/ Report back to java with current sizes\n-            if (newW > 0 || newH > 0) {\n-                notify_current_sizes();\n-            }\n-\n-            if (xSet || xSet) {\n-                int x, y;\n-                gdk_window_get_root_origin(gdk_window, &x, &y);\n-                notify_window_move(x, y);\n-            }\n-\n-            return;\n-        }\n-    }\n-\n-    \/\/ Re-apply the constraints removed for fullscreen \/ maximize\n-    if (!resizable.value) {\n-        update_window_constraints(newW, newH);\n-    }\n-\n-    resize(newW, newH);\n-    move(x, y, xSet, ySet);\n-}\n+    GdkWindowState state = gdk_window_get_state(gdk_window);\n@@ -1263,2 +1193,4 @@\n-void WindowContext::applyShapeMask(void* data, uint width, uint height) {\n-    if (frame_type != TRANSPARENT) {\n+    \/\/ Ignore when maximized \/ fullscreen\n+    if (!is_window_floating(state)) {\n+        notify_current_sizes();\n+        notify_window_move();\n@@ -1268,1 +1200,1 @@\n-    glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);\n+    move_resize(x, y, xSet, ySet, newW, newH);\n@@ -1274,1 +1206,1 @@\n-        gtk_window_iconify(GTK_WINDOW(gtk_widget));\n+        gdk_window_iconify(gdk_window);\n@@ -1276,1 +1208,1 @@\n-        gtk_window_deiconify(GTK_WINDOW(gtk_widget));\n+        gdk_window_deiconify(gdk_window);\n@@ -1284,7 +1216,2 @@\n-\n-        if (!resizable.value) {\n-            remove_window_constraints();\n-            process_pending_events();\n-        }\n-\n-        gtk_window_maximize(GTK_WINDOW(gtk_widget));\n+        update_window_constraints(true);\n+        gdk_window_maximize(gdk_window);\n@@ -1292,1 +1219,1 @@\n-        gtk_window_unmaximize(GTK_WINDOW(gtk_widget));\n+        gdk_window_unmaximize(gdk_window);\n@@ -1298,1 +1225,1 @@\n-    if (was_mapped) {\n+    if (mapped) {\n@@ -1309,1 +1236,1 @@\n-    if (was_mapped) {\n+    if (mapped) {\n@@ -1320,14 +1247,3 @@\n-    if (was_mapped) {\n-        \/\/ save state before fullscreen to work-around an issue were\n-        \/\/ it would restore to max-size\n-        save_geometry();\n-        geometry.needs_to_restore_geometry = true;\n-\n-        if (!resizable.value) {\n-            remove_window_constraints();\n-            process_pending_events();\n-            \/\/ Needs to happen \"in the future\" because constraints removal are not applied immediately\n-            gdk_threads_add_idle((GSourceFunc) enter_fullscreen_later, GTK_WINDOW(gtk_widget));\n-        } else {\n-            gtk_window_fullscreen(GTK_WINDOW(gtk_widget));\n-        }\n+    if (mapped) {\n+        update_window_constraints(true);\n+        gdk_window_fullscreen(gdk_window);\n@@ -1341,2 +1257,2 @@\n-    if (was_mapped) {\n-        gtk_window_unfullscreen(GTK_WINDOW(gtk_widget));\n+    if (mapped) {\n+        gdk_window_unfullscreen(gdk_window);\n@@ -1352,1 +1268,1 @@\n-    gtk_window_present(GTK_WINDOW(gtk_widget));\n+    gdk_window_focus(gdk_window, gdk_x11_display_get_user_time(gdk_window_get_display(gdk_window)));\n@@ -1356,1 +1272,1 @@\n-    gtk_window_set_accept_focus(GTK_WINDOW(gtk_widget), focusable ? TRUE : FALSE);\n+    gdk_window_set_accept_focus(gdk_window, focusable ? TRUE : FALSE);\n@@ -1360,1 +1276,6 @@\n-    gtk_window_set_title(GTK_WINDOW(gtk_widget), title);\n+    gdk_window_set_title(gdk_window, title);\n+}\n+\n+\/\/ This only works o Xorg\n+void WindowContext::set_alpha(double alpha) {\n+    gdk_window_set_opacity(gdk_window, (gdouble)alpha);\n@@ -1382,2 +1303,7 @@\n-void WindowContext::set_icon(GdkPixbuf* pixbuf) {\n-    gtk_window_set_icon(GTK_WINDOW(gtk_widget), pixbuf);\n+void WindowContext::set_icon(GdkPixbuf* icon) {\n+    if (icon == NULL || !GDK_IS_PIXBUF (icon)) return;\n+\n+    GList *icons = NULL;\n+    icons = g_list_append(icons, icon);\n+    gdk_window_set_icon_list(gdk_window, icons);\n+    g_list_free(icons);\n@@ -1398,1 +1324,0 @@\n-        \/\/gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_DIALOG);\n@@ -1400,1 +1325,1 @@\n-            gtk_window_set_transient_for(GTK_WINDOW(gtk_widget), parent->get_gtk_window());\n+            gdk_window_set_transient_for(gdk_window, parent->get_gdk_window());\n@@ -1403,5 +1328,1 @@\n-    gtk_window_set_modal(GTK_WINDOW(gtk_widget), modal ? TRUE : FALSE);\n-}\n-\n-GtkWindow *WindowContext::get_gtk_window() {\n-    return GTK_WINDOW(gtk_widget);\n+    gdk_window_set_modal_hint(gdk_window, modal ? TRUE : FALSE);\n@@ -1416,1 +1337,1 @@\n-    gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), effective_on_top ? TRUE : FALSE);\n+    gdk_window_set_keep_above(gdk_window, effective_on_top ? TRUE : FALSE);\n@@ -1443,8 +1364,3 @@\n-void WindowContext::get_view_size(int *width, int *height) {\n-    if (gtk_widget_get_realized(gtk_widget)) {\n-        *width = gdk_window_get_width(gdk_window);\n-        *height = gdk_window_get_height(gdk_window);\n-    } else {\n-        *width = geometry.width;\n-        *height = geometry.height;\n-    }\n+void WindowContext::update_window_size() {\n+    geometry.width.window = geometry.width.view;\n+    geometry.height.window = geometry.height.view;\n@@ -1452,21 +1368,3 @@\n-    LOG2(\"get_view_size: %d, %d\\n\", *width, *height);\n-}\n-\n-void WindowContext::get_window_size(int *width, int *height) {\n-    int ww, wh;\n-    get_view_size(&ww, &wh);\n-\n-    if (gtk_widget_get_realized(gtk_widget)) {\n-        gint root_x, root_y, origin_x, origin_y;\n-        gdk_window_get_root_origin(gdk_window, &root_x, &root_y);\n-        gdk_window_get_origin(gdk_window, &origin_x, &origin_y);\n-\n-        \/\/ Here is detected if there are any decorations as it might vary, for example\n-        \/\/ if the window is fullscreen\n-        if ((origin_x - root_x) > 0) {\n-            ww += geometry.extents.width;\n-        }\n-\n-        if ((origin_y - root_y) > 0) {\n-            wh += geometry.extents.height;\n-        }\n+    if (frame_type == TITLED) {\n+        geometry.width.window += geometry.extents.width;\n+        geometry.height.window += geometry.extents.height;\n@@ -1474,4 +1372,0 @@\n-\n-    LOG2(\"get_window_size: %d, %d\\n\", ww, wh);\n-    *width = ww;\n-    *height = wh;\n@@ -1481,7 +1375,4 @@\n-void WindowContext::resize(int width, int height) {\n-    LOG2(\"resize (requested): %d, %d\\n\", width, height);\n-    int current_width, current_height;\n-    get_view_size(&current_width, &current_height);\n-\n-    int newW = (width <= 0) ? current_width : width;\n-    int newH = (height <= 0) ? current_height : height;\n+void WindowContext::move_resize(int x, int y, bool xSet, bool ySet, int width, int height) {\n+    LOG4(\"move_resize: x,y: %d,%d \/ cw,ch: %d,%d\\n\", x, y, width, height);\n+    int newW = (width > 0) ? width : geometry.width.view;\n+    int newH = (height > 0) ? height : geometry.height.view;\n@@ -1495,4 +1386,0 @@\n-    if (resizable.minh > 0 && newH < resizable.minh) {\n-        newH = NONNEGATIVE_OR(resizable.minh - geometry.extents.height, 1);\n-    }\n-\n@@ -1503,0 +1390,4 @@\n+    if (resizable.minh > 0 && newH < resizable.minh) {\n+        newH = NONNEGATIVE_OR(resizable.minh - geometry.extents.height, 1);\n+    }\n+\n@@ -1507,6 +1398,4 @@\n-    LOG2(\"resize (real): %d, %d\\n\", newW, newH);\n-\n-    if (gtk_widget_get_realized(gtk_widget)) {\n-        gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);\n-        \/\/ If not changed, configure event will not happen, so we need to notify here\n-        if (current_width == newW && current_height == newH)  notify_current_sizes();\n+    if (mapped && geometry.width.view == newW && geometry.height.view == newH) {\n+        \/\/ No change\n+        newW = -1;\n+        newH = -1;\n@@ -1514,4 +1403,2 @@\n-        gtk_window_set_default_size(GTK_WINDOW(gtk_widget), newW, newH);\n-        \/\/ If the GdkWindow is not yet created, report back to Java, because the configure event\n-        \/\/ won't happen\n-        notify_current_sizes();\n+        geometry.width.view = newW;\n+        geometry.height.view = newH;\n@@ -1519,1 +1406,0 @@\n-}\n@@ -1521,3 +1407,5 @@\n-void WindowContext::move(int x, int y) {\n-    move(x, y, true, true);\n-}\n+    update_window_size();\n+\n+    if (!resizable.value) {\n+        update_window_constraints();\n+    }\n@@ -1525,4 +1413,2 @@\n-void WindowContext::move(int x, int y, bool xSet, bool ySet) {\n-    LOG2(\"move %d, %d\\n\", x, y);\n-    int to_x = x;\n-    int to_y = y;\n+    if (xSet) geometry.x = x;\n+    if (ySet) geometry.y = y;\n@@ -1530,2 +1416,2 @@\n-    if (!xSet || !ySet) {\n-        int cur_x, cur_y;\n+    LOG6(\"gdk_window_move_resize: x,y: %d,%d \/ cw,ch: %d,%d \/ ww,wh: %d,%d\\n\",\n+        geometry.x, geometry.y, newW, newH, geometry.width.window, geometry.width.window);\n@@ -1533,6 +1419,1 @@\n-        if (gtk_widget_get_realized(gtk_widget)) {\n-            gdk_window_get_root_origin(gdk_window, &cur_x, &cur_y);\n-        } else {\n-            cur_x = geometry.x;\n-            cur_y = geometry.y;\n-        }\n+    gdk_window_move_resize(gdk_window, geometry.x, geometry.y, newW, newH);\n@@ -1540,2 +1421,4 @@\n-        if (!xSet) to_x = cur_x;\n-        if (!ySet) to_y = cur_y;\n+    \/\/ Or else let to process_configure\n+    if (!mapped) {\n+        notify_window_move();\n+        notify_current_sizes();\n@@ -1543,2 +1426,0 @@\n-\n-    gtk_window_move(GTK_WINDOW(gtk_widget), to_x, to_y);\n@@ -1547,1 +1428,0 @@\n-\n@@ -1567,1 +1447,1 @@\n-            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);\n+            gdk_window_set_keep_above(gdk_window, TRUE);\n@@ -1599,6 +1479,1 @@\n-        int cw, ch;\n-        get_view_size(&cw, &ch);\n-\n-        if (cw > 0 && ch > 0) {\n-            notify_view_resize(cw, ch);\n-        }\n+        notify_view_resize();\n@@ -1611,1 +1486,1 @@\n-    gtk_widget_destroy(gtk_widget);\n+    gdk_window_destroy(gdk_window);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.cpp","additions":272,"deletions":397,"binary":false,"changes":669,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#define DEFAULT_WIDTH 320\n+#define DEFAULT_HEIGHT 200\n@@ -53,0 +55,6 @@\n+enum BoundsType {\n+    BOUNDSTYPE_UNKNOWN,\n+    BOUNDSTYPE_VIEW,\n+    BOUNDSTYPE_WINDOW\n+};\n+\n@@ -57,2 +65,3 @@\n-    needs_to_restore_geometry(false),\n-    width(-1), height(-1), x(), y(), view_x(), view_y(),\n+    width{-1, -1, BOUNDSTYPE_UNKNOWN},\n+    height{-1, -1, BOUNDSTYPE_UNKNOWN},\n+    x(), y(), view_x(), view_y(),\n@@ -62,1 +71,5 @@\n-    bool needs_to_restore_geometry;\n+    struct {\n+        int window;\n+        int view;\n+        BoundsType type;\n+    } width;\n@@ -64,5 +77,5 @@\n-    \/\/ width, height, x, w are not update by user interactions and\n-    \/\/ may not reflect current geometry.\n-    \/\/ width \/ height are content size\n-    int width;\n-    int height;\n+    struct {\n+        int window;\n+        int view;\n+        BoundsType type;\n+    } height;\n@@ -96,1 +109,1 @@\n-    struct _Resizable {\/\/ we can't use set\/get gtk_window_resizable function\n+    struct _Resizable {\n@@ -117,1 +130,0 @@\n-    GtkWidget *gtk_widget;\n@@ -126,1 +138,1 @@\n-    bool was_mapped;\n+    bool mapped;\n@@ -164,0 +176,1 @@\n+    XID get_native_window();\n@@ -177,0 +190,1 @@\n+    void set_background(float, float, float);\n@@ -180,0 +194,1 @@\n+    void notify_repaint();\n@@ -187,1 +202,0 @@\n-    void process_realize();\n@@ -207,0 +221,1 @@\n+    void set_alpha(double);\n@@ -221,2 +236,0 @@\n-    GtkWindow *get_gtk_window();\n-    void update_window_size_location();\n@@ -227,2 +240,0 @@\n-protected:\n-    void applyShapeMask(void*, uint width, uint height);\n@@ -230,0 +241,1 @@\n+    GdkVisual* find_best_visual();\n@@ -232,5 +244,2 @@\n-    void get_view_size(int *, int *);\n-    void get_window_size(int *, int *);\n-    void resize(int, int);\n-    void move(int, int, bool, bool);\n-    void move(int, int);\n+    void update_window_size();\n+    void move_resize(int, int, bool, bool, int, int);\n@@ -239,1 +248,0 @@\n-    void save_geometry();\n@@ -241,3 +249,3 @@\n-    void notify_window_resize(int, int, int);\n-    void notify_window_move(int, int);\n-    void notify_view_resize(int, int);\n+    void notify_window_resize(int);\n+    void notify_window_move();\n+    void notify_view_resize();\n@@ -252,1 +260,0 @@\n-    void remove_window_constraints();\n@@ -254,1 +261,1 @@\n-    void update_window_constraints(int, int);\n+    void update_window_constraints(bool);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":34,"deletions":27,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import javafx.beans.property.DoubleProperty;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n@@ -30,1 +31,2 @@\n-import javafx.geometry.Orientation;\n+import javafx.geometry.Insets;\n+import javafx.scene.Scene;\n@@ -32,0 +34,1 @@\n+import javafx.scene.control.ButtonType;\n@@ -34,0 +37,2 @@\n+import javafx.scene.control.ContextMenu;\n+import javafx.scene.control.Dialog;\n@@ -35,1 +40,6 @@\n-import javafx.scene.control.Separator;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.Spinner;\n+import javafx.scene.control.SpinnerValueFactory;\n+import javafx.scene.control.TextField;\n+import javafx.scene.control.TitledPane;\n+import javafx.scene.control.Tooltip;\n@@ -37,4 +47,2 @@\n-import javafx.scene.layout.VBox;\n-import javafx.stage.StageStyle;\n-import javafx.scene.Scene;\n-import javafx.scene.layout.StackPane;\n+import javafx.scene.layout.BackgroundFill;\n+import javafx.scene.layout.CornerRadii;\n@@ -42,0 +50,3 @@\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.layout.VBox;\n@@ -44,0 +55,5 @@\n+import javafx.stage.StageStyle;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n@@ -46,18 +62,134 @@\n-    private Stage testStage = new Stage();\n-    private Label lblWidth = new Label();\n-    private Label lblHeight = new Label();\n-    private Label lblMinWidth = new Label();\n-    private Label lblMinHeight = new Label();\n-    private Label lblMaxWidth = new Label();\n-    private Label lblMaxHeight = new Label();\n-    private Label lblX = new Label();\n-    private Label lblY = new Label();\n-    private Label lblSceneWidth = new Label();\n-    private Label lblSceneHeight = new Label();\n-    private Label lblSceneX = new Label();\n-    private Label lblSceneY = new Label();\n-    private ComboBox<StageStyle> cbStageStyle = new ComboBox<>(FXCollections.observableArrayList(StageStyle.values()));\n-    private CheckBox cbIsFullScreen = new CheckBox(\"Is FullScreen\");\n-    private CheckBox cbIsMaximized = new CheckBox(\"Is Maximized\");\n-    private CheckBox cbIsIconified = new CheckBox(\"Is Iconified\");\n-    private CheckBox cbIsResizable = new CheckBox(\"Is Resizable\");\n+    private List<Stage> stages = new ArrayList<>();\n+    private Stage currentStage = null;\n+    private int stageCounter = 0;\n+\n+    private final Label lblWidth = new Label();\n+    private final Label lblHeight = new Label();\n+    private final Label lblMinWidth = new Label();\n+    private final Label lblMinHeight = new Label();\n+    private final Label lblMaxWidth = new Label();\n+    private final Label lblMaxHeight = new Label();\n+    private final Label lblX = new Label();\n+    private final Label lblY = new Label();\n+    private final Label lblSceneWidth = new Label();\n+    private final Label lblSceneHeight = new Label();\n+    private final Label lblSceneX = new Label();\n+    private final Label lblSceneY = new Label();\n+    private final Label lblCurrentStage = new Label();\n+    private final ComboBox<StageStyle> cbStageStyle = new ComboBox<>(FXCollections.observableArrayList(StageStyle.values()));\n+    private final CheckBox cbIsFullScreen = new CheckBox(\"Is FullScreen\");\n+    private final CheckBox cbIsMaximized = new CheckBox(\"Is Maximized\");\n+    private final CheckBox cbIsIconified = new CheckBox(\"Is Iconified\");\n+    private final CheckBox cbIsResizable = new CheckBox(\"Is Resizable\");\n+\n+    private final Button btnMaxminize = new Button(\"Maximize\");\n+    private final Button btnFullScreen = new Button(\"FullScreen\");\n+    private final Button btnIconify = new Button(\"Iconify\");\n+    private final Button btnResizable = new Button(\"Resizable\");\n+    private final Button btnToFront = new Button(\"To Front\");\n+    private final Button btnToBack = new Button(\"To Back\");\n+    private final Button btnCreate = new Button(\"Create\");\n+    private final Button btnSelectNone = new Button(\"Select None\");\n+    private final Button btnHide = new Button(\"Hide\");\n+    private final Button btnShow = new Button(\"Show\");\n+    private final Button btnSizeToScene = new Button(\"Size to scene\");\n+    private final Button btnCenterOnScreen = new Button(\"Center on screen\");\n+    private final Button btnResize = new Button(\"Resize\");\n+    private final Button btnMaxSize = new Button(\"Set Max Size\");\n+    private final Button btnUnsetMaxSize = new Button(\"Unset Max Size\");\n+    private final Button btnMove = new Button(\"Move\");\n+    private final Button btnFocus = new Button(\"Focus\");\n+    private final Button btnStack = new Button(\"Stack\");\n+\n+    private final ObjectProperty<StageStyle> initStyle = new SimpleObjectProperty<>(StageStyle.DECORATED);\n+\n+\n+    private void updateCommandButtonsState() {\n+        boolean noStagesCreated = stages.isEmpty();\n+\n+        btnShow.setDisable(noStagesCreated);\n+        btnHide.setDisable(noStagesCreated);\n+        btnSizeToScene.setDisable(noStagesCreated);\n+        btnCenterOnScreen.setDisable(noStagesCreated);\n+        btnResize.setDisable(noStagesCreated);\n+        btnMaxSize.setDisable(noStagesCreated);\n+        btnUnsetMaxSize.setDisable(noStagesCreated);\n+        btnMove.setDisable(noStagesCreated);\n+        btnIconify.setDisable(noStagesCreated);\n+        btnMaxminize.setDisable(noStagesCreated);\n+        btnFullScreen.setDisable(noStagesCreated);\n+        btnResizable.setDisable(noStagesCreated);\n+        btnToFront.setDisable(noStagesCreated);\n+        btnToBack.setDisable(noStagesCreated);\n+        btnFocus.setDisable(noStagesCreated);\n+        btnSelectNone.setDisable(noStagesCreated);\n+        btnStack.setDisable(noStagesCreated);\n+    }\n+\n+    private void updateBindings() {\n+        if (currentStage == null) {\n+            cbIsMaximized.selectedProperty().unbind();\n+            cbIsFullScreen.selectedProperty().unbind();\n+            cbIsIconified.selectedProperty().unbind();\n+            cbIsResizable.selectedProperty().unbind();\n+            lblWidth.textProperty().unbind();\n+            lblHeight.textProperty().unbind();\n+            lblMinWidth.textProperty().unbind();\n+            lblMinHeight.textProperty().unbind();\n+            lblMaxWidth.textProperty().unbind();\n+            lblMaxHeight.textProperty().unbind();\n+            lblX.textProperty().unbind();\n+            lblY.textProperty().unbind();\n+            lblSceneWidth.textProperty().unbind();\n+            lblSceneHeight.textProperty().unbind();\n+            lblSceneX.textProperty().unbind();\n+            lblSceneY.textProperty().unbind();\n+            lblCurrentStage.textProperty().unbind();\n+\n+\n+            cbIsMaximized.setSelected(false);\n+            cbIsFullScreen.setSelected(false);\n+            cbIsIconified.setSelected(false);\n+            cbIsResizable.setSelected(false);\n+            lblWidth.setText(\"Width: 0.00\");\n+            lblHeight.setText(\"Height: 0.00\");\n+            lblMinWidth.setText(\"Min Width: 0.00\");\n+            lblMinHeight.setText(\"Min Height: 0.00\");\n+            lblMaxWidth.setText(\"Max Width: 0.00\");\n+            lblMaxHeight.setText(\"Max Height: 0.00\");\n+            lblX.setText(\"X: 0.00\");\n+            lblY.setText(\"Y: 0.00\");\n+            lblSceneWidth.setText(\"Width: 0.00\");\n+            lblSceneHeight.setText(\"Height: 0.00\");\n+            lblSceneX.setText(\"X: 0.00\");\n+            lblSceneY.setText(\"Y: 0.00\");\n+            lblCurrentStage.setText(\"Current Stage: None\");\n+        } else {\n+            Scene scene = currentStage.getScene();\n+\n+            cbIsMaximized.selectedProperty().bind(currentStage.maximizedProperty());\n+            cbIsFullScreen.selectedProperty().bind(currentStage.fullScreenProperty());\n+            cbIsIconified.selectedProperty().bind(currentStage.iconifiedProperty());\n+            cbIsResizable.selectedProperty().bind(currentStage.resizableProperty());\n+\n+\n+            lblWidth.textProperty().bind(Bindings.format(\"Width: %.2f\", currentStage.widthProperty()));\n+            lblHeight.textProperty().bind(Bindings.format(\"Height: %.2f\", currentStage.heightProperty()));\n+            lblMinWidth.textProperty().bind(Bindings.format(\"Min Width: %.2f\", currentStage.minWidthProperty()));\n+            lblMinHeight.textProperty().bind(Bindings.format(\"Min Height: %.2f\", currentStage.minHeightProperty()));\n+            lblMaxWidth.textProperty().bind(Bindings.format(\"Max Width: %.2f\", currentStage.maxWidthProperty()));\n+            lblMaxHeight.textProperty().bind(Bindings.format(\"Max Height: %.2f\", currentStage.maxHeightProperty()));\n+            lblX.textProperty().bind(Bindings.format(\"X: %.2f\", currentStage.xProperty()));\n+            lblY.textProperty().bind(Bindings.format(\"Y: %.2f\", currentStage.yProperty()));\n+            lblCurrentStage.textProperty().bind(Bindings.format(\"Current Stage: %s\", currentStage.titleProperty()));\n+\n+            if (scene != null) {\n+                lblSceneWidth.textProperty().bind(Bindings.format(\"Width: %.2f\", scene.widthProperty()));\n+                lblSceneHeight.textProperty().bind(Bindings.format(\"Height: %.2f\", scene.heightProperty()));\n+                lblSceneX.textProperty().bind(Bindings.format(\"X: %.2f\", scene.xProperty()));\n+                lblSceneY.textProperty().bind(Bindings.format(\"Y: %.2f\", scene.yProperty()));\n+            }\n+        }\n+    }\n+\n+    private final CheckBox cbAlwaysOnTop = new CheckBox(\"Command Always On Top\");\n@@ -67,2 +199,11 @@\n-        cbStageStyle.valueProperty().addListener((observable, oldValue, newValue) -> {\n-            testStage.initStyle(StageStyle.valueOf(newValue.name()));\n+        cbStageStyle.getSelectionModel().select(StageStyle.DECORATED);\n+        initStyle.bind(cbStageStyle.valueProperty());\n+        stage.setAlwaysOnTop(true);\n+\n+        cbAlwaysOnTop.setSelected(stage.isAlwaysOnTop());\n+        cbAlwaysOnTop.setOnAction(e -> stage.setAlwaysOnTop(cbAlwaysOnTop.isSelected()));\n+\n+        btnMaxminize.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.setMaximized(!currentStage.isMaximized());\n+            }\n@@ -71,1 +212,17 @@\n-        cbStageStyle.getSelectionModel().select(StageStyle.DECORATED);\n+        btnFullScreen.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.setFullScreen(!currentStage.isFullScreen());\n+            }\n+        });\n+\n+        btnIconify.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.setIconified(!currentStage.isIconified());\n+            }\n+        });\n+\n+        btnResizable.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.setResizable(!currentStage.isResizable());\n+            }\n+        });\n@@ -73,2 +230,5 @@\n-        Button btnMaxminize = new Button(\"Toggle Maximize\");\n-        btnMaxminize.setOnAction(e -> testStage.setMaximized(!testStage.isMaximized()));\n+        btnToFront.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.toFront();\n+            }\n+        });\n@@ -76,2 +236,5 @@\n-        Button btnFullScreen = new Button(\"Toggle FullScreen\");\n-        btnFullScreen.setOnAction(e -> testStage.setFullScreen(!testStage.isFullScreen()));\n+        btnToBack.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.toBack();\n+            }\n+        });\n@@ -79,2 +242,1 @@\n-        Button btnIconify = new Button(\"Toggle Iconified\");\n-        btnIconify.setOnAction(e -> testStage.setIconified(!testStage.isIconified()));\n+        btnCreate.setOnAction(e -> createTestStage());\n@@ -82,2 +244,4 @@\n-        Button btnResizable = new Button(\"Toggle Resizable\");\n-        btnResizable.setOnAction(e -> testStage.setResizable(!testStage.isResizable()));\n+        btnSelectNone.setOnAction(e -> {\n+            currentStage = null;\n+            updateBindings();\n+        });\n@@ -85,3 +249,4 @@\n-        Button btnShow = new Button(\"Show\");\n-        btnShow.setOnAction(e -> {\n-            testStage.show();\n+        btnHide.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.hide();\n+            }\n@@ -90,4 +255,4 @@\n-        Button btnClose = new Button(\"Close\");\n-        btnClose.setOnAction(e -> {\n-            testStage.close();\n-            createTestStage();\n+        btnShow.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.show();\n+            }\n@@ -96,1 +261,0 @@\n-        Button btnSizeToScene = new Button(\"Size to scene\");\n@@ -98,1 +262,3 @@\n-            testStage.sizeToScene();\n+            if (currentStage != null) {\n+                currentStage.sizeToScene();\n+            }\n@@ -101,1 +267,0 @@\n-        Button btnCenterOnScreen = new Button(\"Center on screen\");\n@@ -103,1 +268,3 @@\n-            testStage.centerOnScreen();\n+            if (currentStage != null) {\n+                currentStage.centerOnScreen();\n+            }\n@@ -106,1 +273,0 @@\n-        Button btnResize = new Button(\"Resize\");\n@@ -108,2 +274,15 @@\n-            testStage.setWidth(300);\n-            testStage.setHeight(300);\n+            if (currentStage != null) {\n+                double[] dimensions = showValuesDialog(\n+                        \"Resize Stage\",\n+                        \"Width:\",\n+                        \"Height:\",\n+                        currentStage.getWidth(),\n+                        currentStage.getHeight(),\n+                        50,\n+                        2000);\n+\n+                if (dimensions != null) {\n+                    currentStage.setWidth(dimensions[0]);\n+                    currentStage.setHeight(dimensions[1]);\n+                }\n+            }\n@@ -112,1 +291,0 @@\n-        Button btnMaxSize = new Button(\"Set Max Size\");\n@@ -114,2 +292,15 @@\n-            testStage.setMaxWidth(250);\n-            testStage.setMaxHeight(250);\n+            if (currentStage != null) {\n+                double[] dimensions = showValuesDialog(\n+                        \"Set Max Size\",\n+                        \"Max Width:\",\n+                        \"Max Height:\",\n+                        currentStage.getMaxWidth(),\n+                        currentStage.getMaxHeight(),\n+                        50,\n+                        2000);\n+\n+                if (dimensions != null) {\n+                    currentStage.setMaxWidth(dimensions[0]);\n+                    currentStage.setMaxHeight(dimensions[1]);\n+                }\n+            }\n@@ -118,1 +309,0 @@\n-        Button btnUnsetMaxSize = new Button(\"Unset Max Size\");\n@@ -120,2 +310,4 @@\n-            testStage.setMaxWidth(Double.MAX_VALUE);\n-            testStage.setMaxHeight(Double.MAX_VALUE);\n+            if (currentStage != null) {\n+                currentStage.setMaxWidth(Double.MAX_VALUE);\n+                currentStage.setMaxHeight(Double.MAX_VALUE);\n+            }\n@@ -124,1 +316,0 @@\n-        Button btnMove = new Button(\"Move\");\n@@ -126,2 +317,21 @@\n-            testStage.setX(100);\n-            testStage.setY(100);\n+            if (currentStage != null) {\n+                double[] position = showValuesDialog(\n+                        \"Move Stage\",\n+                        \"X Position:\",\n+                        \"Y Position:\",\n+                        currentStage.getX(),\n+                        currentStage.getY(),\n+                        0,\n+                        3000);\n+\n+                if (position != null) {\n+                    currentStage.setX(position[0]);\n+                    currentStage.setY(position[1]);\n+                }\n+            }\n+        });\n+\n+        btnFocus.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.requestFocus();\n+            }\n@@ -130,0 +340,17 @@\n+        btnStack.setOnAction(e -> {\n+            if (!stages.isEmpty()) {\n+                double xOffset = 0;\n+                double yOffset = 0;\n+\n+                for (Stage stageWindow : stages) {\n+                    stageWindow.setX(xOffset);\n+                    stageWindow.setY(yOffset);\n+                    stageWindow.show();\n+                    xOffset += 50;\n+                    yOffset += 50;\n+                }\n+            }\n+        });\n+\n+        updateCommandButtonsState();\n+\n@@ -135,2 +362,3 @@\n-        FlowPane commandPane = new FlowPane(cbStageStyle, btnShow, btnClose, btnSizeToScene, btnCenterOnScreen,\n-                btnResize, btnMaxSize, btnUnsetMaxSize, btnMove, btnIconify, btnMaxminize, btnFullScreen, btnResizable);\n+        FlowPane commandPane = new FlowPane(cbStageStyle, btnCreate, btnShow, btnHide, btnSizeToScene,\n+                btnCenterOnScreen, btnResize, btnMaxSize, btnUnsetMaxSize, btnMove, btnIconify, btnMaxminize,\n+                btnFullScreen, btnResizable, btnToFront, btnToBack, btnStack, btnFocus, btnSelectNone, cbAlwaysOnTop);\n@@ -141,3 +369,2 @@\n-        VBox root = new VBox(commandPane,\n-                new Separator(Orientation.HORIZONTAL),\n-                new Label(\"Stage Properties:\"),\n+        VBox stagePropertiesBox = new VBox(\n+                lblCurrentStage,\n@@ -147,4 +374,20 @@\n-                lblWidth, lblHeight, lblX, lblY,\n-                new Separator(Orientation.HORIZONTAL),\n-                new Label(\"Scene Properties:\"),\n-                lblSceneWidth, lblSceneHeight, lblSceneX, lblSceneY);\n+                lblWidth, lblHeight, lblX, lblY\n+        );\n+        stagePropertiesBox.setSpacing(5);\n+\n+        VBox scenePropertiesBox = new VBox(\n+                lblSceneWidth, lblSceneHeight, lblSceneX, lblSceneY\n+        );\n+        scenePropertiesBox.setSpacing(5);\n+\n+        TitledPane stagePropertiesPane = new TitledPane(\"Stage Properties:\", stagePropertiesBox);\n+        stagePropertiesPane.setCollapsible(false);\n+\n+        TitledPane scenePropertiesPane = new TitledPane(\"Scene Properties:\", scenePropertiesBox);\n+        scenePropertiesPane.setCollapsible(false);\n+\n+        VBox root = new VBox(\n+                commandPane,\n+                stagePropertiesPane,\n+                scenePropertiesPane\n+        );\n@@ -154,2 +397,0 @@\n-        createTestStage();\n-\n@@ -163,28 +404,94 @@\n-        testStage = new Stage();\n-\n-        StackPane stackPane = new StackPane();\n-        stackPane.setBackground(Background.fill(Color.TRANSPARENT));\n-        testStage = new Stage();\n-        Scene testScene = new Scene(stackPane, 300, 300, Color.HOTPINK);\n-        testStage.setScene(testScene);\n-        testStage.initStyle(cbStageStyle.getValue());\n-        testStage.setTitle(\"Test Stage\");\n-        testStage.setWidth(800);\n-        testStage.setHeight(600);\n-\n-        cbIsMaximized.selectedProperty().bind(testStage.maximizedProperty());\n-        cbIsFullScreen.selectedProperty().bind(testStage.fullScreenProperty());\n-        cbIsIconified.selectedProperty().bind(testStage.iconifiedProperty());\n-        cbIsResizable.selectedProperty().bind(testStage.resizableProperty());\n-        lblWidth.textProperty().bind(Bindings.format(\"Width: %.2f\", testStage.widthProperty()));\n-        lblHeight.textProperty().bind(Bindings.format(\"Height: %.2f\", testStage.heightProperty()));\n-        lblMinWidth.textProperty().bind(Bindings.format(\"Min Width: %.2f\", testStage.minWidthProperty()));\n-        lblMinHeight.textProperty().bind(Bindings.format(\"Min Height: %.2f\", testStage.minHeightProperty()));\n-        lblMaxWidth.textProperty().bind(Bindings.format(\"Max Width: %.2f\", testStage.maxWidthProperty()));\n-        lblMaxHeight.textProperty().bind(Bindings.format(\"Max Height: %.2f\", testStage.maxHeightProperty()));\n-        lblX.textProperty().bind(Bindings.format(\"X: %.2f\", testStage.xProperty()));\n-        lblY.textProperty().bind(Bindings.format(\"Y: %.2f\", testStage.yProperty()));\n-        lblSceneWidth.textProperty().bind(Bindings.format(\"Width: %.2f\", testScene.widthProperty()));\n-        lblSceneHeight.textProperty().bind(Bindings.format(\"Height: %.2f\", testScene.heightProperty()));\n-        lblSceneX.textProperty().bind(Bindings.format(\"X: %.2f\", testScene.xProperty()));\n-        lblSceneY.textProperty().bind(Bindings.format(\"Y: %.2f\", testScene.yProperty()));\n+        Stage newStage = new Stage();\n+\n+        stageCounter++;\n+\n+        Scene testScene;\n+        StackPane root;\n+        if (initStyle.getValue() == StageStyle.TRANSPARENT) {\n+            root = new StackPane();\n+            BackgroundFill fill = new BackgroundFill(\n+                    Color.HOTPINK.deriveColor(0, 1, 1, 0.5),\n+                    CornerRadii.EMPTY,\n+                    Insets.EMPTY\n+            );\n+            root.setBackground(new Background(fill));\n+\n+            testScene = new Scene(root, 300, 300);\n+            testScene.setFill(Color.TRANSPARENT);\n+        } else {\n+            root = new StackPane();\n+            root.setBackground(Background.EMPTY);\n+            testScene = new Scene(root, 300, 300, Color.HOTPINK);\n+        }\n+\n+        setupContextMenu(root);\n+\n+        newStage.setScene(testScene);\n+        newStage.initStyle(initStyle.getValue());\n+        newStage.setTitle(\"Test Stage \" + stageCounter);\n+\n+        newStage.focusedProperty().addListener((obs, oldVal, newVal) -> {\n+            if (newVal) {\n+                currentStage = newStage;\n+                updateBindings();\n+            }\n+        });\n+\n+        stages.add(newStage);\n+        currentStage = newStage;\n+\n+        newStage.setOnHidden(e -> {\n+            stages.remove(newStage);\n+            if (currentStage == newStage) {\n+                currentStage = stages.isEmpty() ? null : stages.get(stages.size() - 1);\n+                updateBindings();\n+            }\n+            updateCommandButtonsState();\n+        });\n+\n+        updateBindings();\n+        updateCommandButtonsState();\n+    }\n+\n+    private double[] showValuesDialog(String title, String firstLabel, String secondLabel,\n+                                      double defaultFirst, double defaultSecond,\n+                                      double minValue, double maxValue) {\n+        Dialog<double[]> dialog = new Dialog<>();\n+        dialog.setTitle(title);\n+        dialog.setHeaderText(\"Enter values:\");\n+\n+        dialog.getDialogPane().getButtonTypes().addAll(ButtonType.OK, ButtonType.CANCEL);\n+\n+        Spinner<Double> firstSpinner = new Spinner<>();\n+        SpinnerValueFactory.DoubleSpinnerValueFactory firstValueFactory =\n+                new SpinnerValueFactory.DoubleSpinnerValueFactory(minValue, maxValue, defaultFirst, 1.0);\n+        firstSpinner.setValueFactory(firstValueFactory);\n+        firstSpinner.setEditable(true);\n+\n+        Spinner<Double> secondSpinner = new Spinner<>();\n+        SpinnerValueFactory.DoubleSpinnerValueFactory secondValueFactory =\n+                new SpinnerValueFactory.DoubleSpinnerValueFactory(minValue, maxValue, defaultSecond, 1.0);\n+        secondSpinner.setValueFactory(secondValueFactory);\n+        secondSpinner.setEditable(true);\n+\n+        GridPane grid = new GridPane();\n+        grid.setHgap(10);\n+        grid.setVgap(10);\n+        grid.setPadding(new Insets(20, 150, 10, 10));\n+\n+        grid.add(new Label(firstLabel), 0, 0);\n+        grid.add(firstSpinner, 1, 0);\n+        grid.add(new Label(secondLabel), 0, 1);\n+        grid.add(secondSpinner, 1, 1);\n+\n+        dialog.getDialogPane().setContent(grid);\n+\n+        dialog.setResultConverter(dialogButton -> {\n+            if (dialogButton == ButtonType.OK) {\n+                return new double[] {firstSpinner.getValue(), secondSpinner.getValue()};\n+            }\n+            return null;\n+        });\n+\n+        Optional<double[]> result = dialog.showAndWait();\n+        return result.orElse(null);\n@@ -196,0 +503,50 @@\n+\n+    private void createSceneWithTextField() {\n+        if (currentStage != null) {\n+            StackPane root = new StackPane();\n+\n+            TextField textField = new TextField();\n+            textField.setPromptText(\"Enter text here\");\n+\n+            root.getChildren().add(textField);\n+            setupContextMenu(root);\n+            Scene scene = new Scene(root, 300, 200);\n+\n+            currentStage.setScene(scene);\n+            updateSceneBindings(scene);\n+        }\n+    }\n+\n+    private void createSceneWithTooltipBox() {\n+        if (currentStage != null) {\n+            StackPane root = new StackPane();\n+\n+            StackPane coloredBox = new StackPane();\n+            coloredBox.setBackground(Background.fill(Color.CORNFLOWERBLUE));\n+\n+            Tooltip tooltip = new Tooltip(\"The quick brown fox jumps over the lazy dog.\");\n+            Tooltip.install(coloredBox, tooltip);\n+            root.getChildren().add(coloredBox);\n+            setupContextMenu(root);\n+            Scene scene = new Scene(root, 300, 200);\n+            currentStage.setScene(scene);\n+            updateSceneBindings(scene);\n+        }\n+    }\n+\n+    private void updateSceneBindings(Scene scene) {\n+        lblSceneWidth.textProperty().bind(Bindings.format(\"Width: %.2f\", scene.widthProperty()));\n+        lblSceneHeight.textProperty().bind(Bindings.format(\"Height: %.2f\", scene.heightProperty()));\n+        lblSceneX.textProperty().bind(Bindings.format(\"X: %.2f\", scene.xProperty()));\n+        lblSceneY.textProperty().bind(Bindings.format(\"Y: %.2f\", scene.yProperty()));\n+    }\n+\n+    private void setupContextMenu(StackPane root) {\n+        ContextMenu contextMenu = new ContextMenu();\n+        MenuItem textFieldMenuItem = new MenuItem(\"Create Scene with TextField\");\n+        textFieldMenuItem.setOnAction(e -> createSceneWithTextField());\n+        MenuItem tooltipBoxMenuItem = new MenuItem(\"Create Scene with Tooltip Box\");\n+        tooltipBoxMenuItem.setOnAction(e -> createSceneWithTooltipBox());\n+        contextMenu.getItems().addAll(textFieldMenuItem, tooltipBoxMenuItem);\n+        root.setOnContextMenuRequested(e -> contextMenu.show(root, e.getScreenX(), e.getScreenY()));\n+    }\n","filename":"tests\/manual\/stage\/TestStage.java","additions":455,"deletions":98,"binary":false,"changes":553,"status":"modified"},{"patch":"@@ -45,5 +45,0 @@\n-    private static final int SHOW_WIDTH = 500;\n-    private static final int SHOW_HEIGHT = 500;\n-    private static final int SHOW_X = 500;\n-    private static final int SHOW_Y = 500;\n-\n@@ -57,7 +52,0 @@\n-    private static final Consumer<Stage> CHANGE_GEOMETRY_TESTS_SETTINGS = s -> {\n-        s.setWidth(SHOW_WIDTH);\n-        s.setHeight(SHOW_HEIGHT);\n-        s.setX(SHOW_X);\n-        s.setY(SHOW_Y);\n-    };\n-\n@@ -93,42 +81,0 @@\n-    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n-    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n-    void testUnFullScreenChangedPosition(StageStyle stageStyle) {\n-        setupStageWithStyle(stageStyle, CHANGE_GEOMETRY_TESTS_SETTINGS);\n-\n-        Util.doTimeLine(LONG_WAIT,\n-                () -> getStage().setFullScreen(true),\n-                () -> assertTrue(getStage().isFullScreen()),\n-                () -> {\n-                    getStage().setX(POS_X);\n-                    getStage().setY(POS_Y);\n-                },\n-                () -> getStage().setFullScreen(false));\n-\n-        Util.sleep(LONG_WAIT);\n-\n-        assertEquals(POS_X, getStage().getX(), POSITION_DELTA,\n-                \"Window failed to restore position set while fullscreened\");\n-        assertEquals(POS_Y, getStage().getY(), POSITION_DELTA,\n-                \"Window failed to restore position set while fullscreened\");\n-    }\n-\n-    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n-    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n-    void testUnFullScreenChangedSize(StageStyle stageStyle) {\n-        setupStageWithStyle(stageStyle, CHANGE_GEOMETRY_TESTS_SETTINGS);\n-\n-        Util.doTimeLine(LONG_WAIT,\n-                () -> getStage().setFullScreen(true),\n-                () -> assertTrue(getStage().isFullScreen()),\n-                () -> {\n-                    getStage().setWidth(WIDTH);\n-                    getStage().setHeight(HEIGHT);\n-                },\n-                () -> getStage().setFullScreen(false));\n-\n-        Util.sleep(LONG_WAIT);\n-\n-        assertEquals(WIDTH, getStage().getWidth(), SIZING_DELTA, \"Window failed to restore size set while fullscreened\");\n-        assertEquals(HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Window failed to restore size set while fullscreened\");\n-    }\n-\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/FullScreenTest.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import javafx.scene.Scene;\n@@ -32,0 +33,1 @@\n+import javafx.scene.layout.StackPane;\n@@ -34,0 +36,1 @@\n+import org.junit.jupiter.api.Test;\n@@ -62,5 +65,5 @@\n-                             createLabel(\"Height: \", getStage().heightProperty()),\n-                             createLabel(\"Max Width: \", getStage().maxWidthProperty()),\n-                             createLabel(\"Max Height: \", getStage().maxHeightProperty()),\n-                             createLabel(\"Min Width: \", getStage().minWidthProperty()),\n-                             createLabel(\"Min Height: \", getStage().minHeightProperty()));\n+                createLabel(\"Height: \", getStage().heightProperty()),\n+                createLabel(\"Max Width: \", getStage().maxWidthProperty()),\n+                createLabel(\"Max Height: \", getStage().maxHeightProperty()),\n+                createLabel(\"Min Width: \", getStage().minWidthProperty()),\n+                createLabel(\"Min Height: \", getStage().minHeightProperty()));\n@@ -76,1 +79,0 @@\n-            s.initStyle(stageStyle);\n@@ -93,1 +95,0 @@\n-            s.initStyle(stageStyle);\n@@ -110,1 +111,0 @@\n-            s.initStyle(stageStyle);\n@@ -130,1 +130,0 @@\n-            s.initStyle(stageStyle);\n@@ -184,2 +183,1 @@\n-        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n-                \"Only max width should be limited\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Only max width should be limited\");\n@@ -191,4 +189,1 @@\n-        setupStageWithStyle(stageStyle, s -> {\n-            s.initStyle(stageStyle);\n-            s.setMaxHeight(MAX_HEIGHT);\n-        });\n+        setupStageWithStyle(stageStyle, s -> s.setMaxHeight(MAX_HEIGHT));\n@@ -205,2 +200,1 @@\n-        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA,\n-                \"Only max height should be limited\");\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA, \"Only max height should be limited\");\n@@ -215,1 +209,0 @@\n-            s.initStyle(stageStyle);\n@@ -238,4 +231,1 @@\n-        setupStageWithStyle(stageStyle, s -> {\n-            s.initStyle(stageStyle);\n-            s.setMinWidth(MIN_WIDTH);\n-        });\n+        setupStageWithStyle(stageStyle, s -> s.setMinWidth(MIN_WIDTH));\n@@ -254,2 +244,1 @@\n-        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n-                \"Only min width should be limited\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Only min width should be limited\");\n@@ -261,4 +250,1 @@\n-        setupStageWithStyle(stageStyle, s -> {\n-            s.initStyle(stageStyle);\n-            s.setMinHeight(MIN_HEIGHT);\n-        });\n+        setupStageWithStyle(stageStyle, s -> s.setMinHeight(MIN_HEIGHT));\n@@ -275,2 +261,1 @@\n-        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA,\n-                \"Only min height should be limited\");\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA, \"Only min height should be limited\");\n@@ -284,1 +269,1 @@\n-        setupStageWithStyle(stageStyle, s -> s.initStyle(stageStyle));\n+        setupStageWithStyle(stageStyle, null);\n@@ -295,4 +280,1 @@\n-        setupStageWithStyle(stageStyle, s -> {\n-            s.initStyle(stageStyle);\n-            s.setWidth(WIDTH);\n-        });\n+        setupStageWithStyle(stageStyle, s -> s.setWidth(WIDTH));\n@@ -309,4 +291,1 @@\n-        setupStageWithStyle(stageStyle, s -> {\n-            s.initStyle(stageStyle);\n-            s.setHeight(HEIGHT);\n-        });\n+        setupStageWithStyle(stageStyle, s -> s.setHeight(HEIGHT));\n@@ -319,0 +298,72 @@\n+\n+    @Test\n+    void testSceneSizeOnly() {\n+        setupStageWithStyle(StageStyle.DECORATED, s -> s.setScene(new Scene(new StackPane(), WIDTH, HEIGHT)));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(WIDTH, getScene().getWidth(), SIZING_DELTA,\n+                \"Scene width should not be affected by decoration if stage width not set\");\n+        assertEquals(HEIGHT, getScene().getHeight(), SIZING_DELTA,\n+                \"Scene height should not be affected by decoration if stage height not set\");\n+    }\n+\n+    @Test\n+    void testSceneWidthWithWindowHeight() {\n+        setupStageWithStyle(StageStyle.DECORATED, s -> {\n+            s.setScene(new Scene(new StackPane(), WIDTH, HEIGHT));\n+            s.setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(WIDTH, getScene().getWidth(),\n+                \"Scene width should not be affected by decoration if stage width not set\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Stage height should match the new height\");\n+    }\n+\n+    @Test\n+    void testSceneHeightWithWindowWidth() {\n+        setupStageWithStyle(StageStyle.DECORATED, s -> {\n+            s.setScene(new Scene(new StackPane(), WIDTH, HEIGHT));\n+            s.setWidth(NEW_WIDTH);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA, \"Stage with should match the set new width\");\n+        assertEquals(HEIGHT, getScene().getHeight(),\n+                \"Scene height should not be affected by decoration if stage height not set\");\n+    }\n+\n+    @Test\n+    void testSceneSizeThenStageSize() {\n+        setupStageWithStyle(StageStyle.DECORATED, s -> s.setScene(new Scene(new StackPane(), WIDTH, HEIGHT)));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Scene width should match the new stage width\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Scene height should match the new stage height\");\n+\n+        Util.runAndWait(() -> {\n+            StackPane stackPane = new StackPane();\n+            stackPane.setPrefSize(WIDTH, HEIGHT);\n+       });\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Scene width should match the new stage width\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Scene height should match the new stage height\");\n+\n+    }\n+\n+\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/SizingTest.java","additions":90,"deletions":39,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+            stage.initStyle(stageStyle);\n+            stage.setScene(createScene(stageStyle));\n@@ -103,2 +105,0 @@\n-            stage.initStyle(stageStyle);\n-            stage.setScene(createScene(stageStyle));\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/StageTestBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,438 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.robot.javafx.stage;\n+\n+import javafx.application.Platform;\n+import javafx.beans.binding.Bindings;\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Modality;\n+import javafx.stage.Screen;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.robot.testharness.VisualTestBase;\n+import test.util.Util;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+import static test.util.Util.TIMEOUT;\n+\n+class StageOwnershipTest extends VisualTestBase {\n+    private static final int WIDTH = 300;\n+    private static final int HEIGHT = 300;\n+    private static final double BOUNDS_EDGE_DELTA = 75;\n+    private Stage topStage;\n+    private Stage bottomStage;\n+    private static final Color TOP_COLOR = Color.RED;\n+    private static final Color BOTTOM_COLOR = Color.LIME;\n+    private static final Color COLOR1 = Color.RED;\n+    private static final Color COLOR2 = Color.ORANGE;\n+    private static final Color COLOR3 = Color.YELLOW;\n+    private static final Color COLOR4 = Color.GREEN;\n+    private static final Color COLOR5 = Color.BLUE;\n+    private static final Color COLOR6 = Color.INDIGO;\n+    private static final Color COLOR7 = Color.VIOLET;\n+    private static final double TOLERANCE = 0.07;\n+    private static final int WAIT_TIME = 500;\n+\n+    private void setupBottomStage() throws InterruptedException {\n+        final CountDownLatch shownLatch = new CountDownLatch(1);\n+\n+        runAndWait(() -> {\n+            bottomStage = getStage(false);\n+            bottomStage.initStyle(StageStyle.DECORATED);\n+            Scene bottomScene = new Scene(getFocusedLabel(BOTTOM_COLOR, bottomStage), WIDTH, HEIGHT);\n+            bottomScene.setFill(BOTTOM_COLOR);\n+            bottomStage.setScene(bottomScene);\n+            bottomStage.setX(0);\n+            bottomStage.setY(0);\n+            bottomStage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            bottomStage.show();\n+        });\n+        assertTrue(shownLatch.await(TIMEOUT, TimeUnit.MILLISECONDS),\n+                \"Timeout waiting for bottom stage to be shown\");\n+\n+        sleep(WAIT_TIME);\n+    }\n+\n+    private void setupTopStage(Stage owner, Modality modality) {\n+        runAndWait(() -> {\n+            topStage = getStage(true);\n+            topStage.initStyle(StageStyle.DECORATED);\n+            Scene topScene = new Scene(getFocusedLabel(TOP_COLOR, topStage), WIDTH, HEIGHT);\n+            topScene.setFill(TOP_COLOR);\n+            topStage.setScene(topScene);\n+            if (owner != null) {\n+                topStage.initOwner(owner);\n+            }\n+            if (modality != null) {\n+                topStage.initModality(modality);\n+            }\n+            topStage.setWidth(WIDTH);\n+            topStage.setHeight(HEIGHT);\n+            topStage.setX(0);\n+            topStage.setY(0);\n+        });\n+    }\n+\n+    private void assertColorEqualsVisualBounds(Color expected) {\n+        Rectangle2D visualBounds = Screen.getPrimary().getVisualBounds();\n+        int x = (int) (visualBounds.getWidth() - BOUNDS_EDGE_DELTA);\n+        int y = (int) (visualBounds.getHeight() - BOUNDS_EDGE_DELTA);\n+\n+        Color color = getColor(x, y);\n+        assertColorEquals(expected, color, TOLERANCE);\n+    }\n+\n+    @Test\n+    void testOpeningModalChildStageWhileMaximized() throws InterruptedException {\n+        setupBottomStage();\n+        setupTopStage(bottomStage, Modality.WINDOW_MODAL);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                () -> bottomStage.setMaximized(true),\n+                topStage::show,\n+                () -> {\n+                    assertTrue(bottomStage.isMaximized());\n+                    \/\/ Make sure state is still maximized\n+                    assertColorEqualsVisualBounds(BOTTOM_COLOR);\n+\n+                    Color color = getColor(100, 100);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+                });\n+    }\n+\n+    @Test\n+    void testOpeningModalChildStageWhileFullSceen() throws InterruptedException {\n+        setupBottomStage();\n+        setupTopStage(bottomStage, Modality.WINDOW_MODAL);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                () -> bottomStage.setFullScreen(true),\n+                topStage::show,\n+                () -> {\n+                    assertTrue(bottomStage.isFullScreen());\n+\n+                    \/\/ Make sure state is still fullscreen\n+                    assertColorEqualsVisualBounds(BOTTOM_COLOR);\n+\n+                    Color color = getColor(100, 100);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+                });\n+    }\n+\n+    @Test\n+    void testOpeningAppModalStageWhileMaximized() throws InterruptedException {\n+        setupBottomStage();\n+        setupTopStage(null, Modality.APPLICATION_MODAL);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                () -> bottomStage.setMaximized(true),\n+                topStage::show,\n+                () -> {\n+                    assertTrue(bottomStage.isMaximized());\n+\n+                    \/\/ Make sure state is still maximized\n+                    assertColorEqualsVisualBounds(BOTTOM_COLOR);\n+\n+                    Color color = getColor(100, 100);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+                });\n+    }\n+\n+    @Test\n+    void testOpeningAppModalStageWhileFullScreen() throws InterruptedException {\n+        setupBottomStage();\n+        setupTopStage(null, Modality.APPLICATION_MODAL);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                () -> bottomStage.setFullScreen(true),\n+                topStage::show,\n+                () -> {\n+                    assertTrue(bottomStage.isFullScreen());\n+\n+                    \/\/ Make sure state is still maximized\n+                    assertColorEqualsVisualBounds(BOTTOM_COLOR);\n+\n+                    Color color = getColor(100, 100);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+                });\n+    }\n+\n+    private Stage createStage(StageStyle stageStyle, Color color, Stage owner, Modality modality, int x, int y) {\n+        Stage stage = getStage(true);\n+        stage.initStyle(stageStyle);\n+        StackPane pane = getFocusedLabel(color, stage);\n+        Scene scene = new Scene(pane, WIDTH, HEIGHT);\n+        scene.setFill(color);\n+        stage.setScene(scene);\n+        stage.setWidth(WIDTH);\n+        stage.setHeight(HEIGHT);\n+        if (x > -1) stage.setX(x);\n+        if (y > -1) stage.setY(y);\n+        if (owner != null) {\n+            stage.initOwner(owner);\n+        }\n+        stage.initModality(modality);\n+        return stage;\n+    }\n+\n+    private static StackPane getFocusedLabel(Color color, Stage stage) {\n+        Label label = new Label();\n+        label.textProperty().bind(Bindings.when(stage.focusedProperty())\n+                .then(\"Focused\").otherwise(\"Unfocused\"));\n+        StackPane pane = new StackPane(label);\n+        pane.setBackground(Background.EMPTY);\n+\n+        double luminance = 0.2126 * color.getRed()\n+                + 0.7152 * color.getGreen()\n+                + 0.0722 * color.getBlue();\n+\n+        Color textColor = luminance < 0.5 ? Color.WHITE : Color.BLACK;\n+\n+        label.setTextFill(textColor);\n+        return pane;\n+    }\n+\n+    private void assertColorEquals(Color expected, Stage stage) {\n+        Color color = getColor((int) stage.getX() + 15, (int) stage.getY() + 55);\n+        assertColorEquals(expected, color, TOLERANCE);\n+    }\n+\n+    private void assertColorDoesNotEqual(Color notExpected, Stage stage) {\n+        Color color = getColor((int) stage.getX() + 15, (int) stage.getY() + 55);\n+        assertColorDoesNotEqual(notExpected, color, TOLERANCE);\n+    }\n+\n+    private Stage stage0;\n+    private Stage stage1;\n+    private Stage stage2;\n+    private Stage stage3;\n+    private Stage stage4;\n+    private Stage stage5;\n+    private Stage stage6;\n+\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"UNDECORATED\", \"DECORATED\"})\n+    void testLayeredModality(StageStyle style) {\n+        Util.runAndWait(() -> {\n+            stage0 = createStage(style, COLOR1, null, null, 100, 100);\n+            stage1 = createStage(style, COLOR2, stage0, Modality.WINDOW_MODAL, 150, 150);\n+            stage2 = createStage(style, COLOR3, stage1, Modality.WINDOW_MODAL, 200, 200);\n+            stage3 = createStage(style, COLOR4, stage2, Modality.WINDOW_MODAL, 250, 250);\n+            stage4 = createStage(style, COLOR5, stage3, Modality.WINDOW_MODAL,  300, 300);\n+            stage5 = createStage(style, COLOR6, stage4, Modality.WINDOW_MODAL,  350, 350);\n+            stage6 = createStage(style, COLOR7, stage5, Modality.WINDOW_MODAL,  400, 400);\n+        });\n+\n+        Util.doTimeLine(300,\n+                stage0::show,\n+                stage1::show,\n+                stage2::show,\n+                stage3::show,\n+                stage4::show,\n+                stage5::show,\n+                stage6::show,\n+                () -> {\n+                    assertColorEquals(COLOR1, stage0);\n+                    assertColorEquals(COLOR2, stage1);\n+                    assertColorEquals(COLOR3, stage2);\n+                    assertColorEquals(COLOR4, stage3);\n+                    assertColorEquals(COLOR5, stage4);\n+                    assertColorEquals(COLOR6, stage5);\n+                    assertColorEquals(COLOR7, stage6);\n+                },\n+                () -> assertTrue(stage6.isFocused()),\n+                stage5::close,\n+                () -> assertTrue(stage6.isFocused()),\n+                stage6::close,\n+                stage5::close,\n+                () -> assertColorEquals(COLOR5, stage4));\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"UNDECORATED\", \"DECORATED\"})\n+    void testMultiLayeredModality(StageStyle style) {\n+        Util.runAndWait(() -> {\n+            stage0 = createStage(style, COLOR1, null, Modality.NONE, 100, 100);\n+            stage1 = createStage(style, COLOR2, stage0, Modality.WINDOW_MODAL, 150, 150);\n+            stage2 = createStage(style, COLOR3, stage1, Modality.WINDOW_MODAL, 200, 200);\n+\n+            stage3 = createStage(style, COLOR4, null,  Modality.NONE, 600, 100);\n+            stage4 = createStage(style, COLOR5, stage3,  Modality.WINDOW_MODAL, 650, 150);\n+            stage5 = createStage(style, COLOR6, stage4,  Modality.WINDOW_MODAL, 700, 200);\n+        });\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                stage0::show,\n+                stage1::show,\n+                stage2::show,\n+                stage3::show,\n+                stage4::show,\n+                stage5::show,\n+                () -> {\n+                    assertColorEquals(COLOR1, stage0);\n+                    assertColorEquals(COLOR2, stage1);\n+                    assertColorEquals(COLOR3, stage2);\n+                    assertColorEquals(COLOR4, stage3);\n+                    assertColorEquals(COLOR5, stage4);\n+                    assertColorEquals(COLOR6, stage5);\n+                },\n+                () -> assertTrue(stage5.isFocused()),\n+                stage5::close,\n+                () -> assertTrue(stage4.isFocused()),\n+                stage4::close,\n+                () -> assertTrue(stage3.isFocused()),\n+                stage3::close,\n+                () -> assertTrue(stage2.isFocused()),\n+                stage2::close,\n+                () -> assertTrue(stage1.isFocused()),\n+                stage1::close,\n+                () -> assertTrue(stage0.isFocused()));\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"UNDECORATED\", \"DECORATED\"})\n+    void testIconfyRestoreChildren(StageStyle style) {\n+        Util.runAndWait(() -> {\n+            stage0 = createStage(style, COLOR1, null, Modality.NONE, 100, 100);\n+            stage1 = createStage(style, COLOR2, stage0, Modality.WINDOW_MODAL, 150, 150);\n+            stage2 = createStage(style, COLOR3, stage1, Modality.WINDOW_MODAL, 200, 200);\n+        });\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                stage0::show,\n+                stage1::show,\n+                stage2::show,\n+                () -> stage0.setIconified(true),\n+                () -> {\n+                    assertTrue(stage0.isIconified());\n+                    assertTrue(stage1.isIconified());\n+                    assertTrue(stage2.isIconified());\n+                    assertColorDoesNotEqual(COLOR1, stage0);\n+                    assertColorDoesNotEqual(COLOR2, stage1);\n+                    assertColorDoesNotEqual(COLOR3, stage2);\n+                },\n+                () -> stage2.setIconified(false),\n+                () -> {\n+                    assertColorEquals(COLOR1, stage0);\n+                    assertColorEquals(COLOR2, stage1);\n+                    assertColorEquals(COLOR3, stage2);\n+                });\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"UNDECORATED\", \"DECORATED\"})\n+    void testChildStageWithoutModality(StageStyle style) {\n+        Util.runAndWait(() -> {\n+            stage0 = createStage(style, COLOR1, null, Modality.NONE, 100, 100);\n+            stage1 = createStage(style, COLOR2, stage0, Modality.NONE, 150, 150);\n+            stage2 = createStage(style, COLOR3, stage1, Modality.NONE, 200, 200);\n+        });\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                stage0::show,\n+                stage1::show,\n+                stage2::show,\n+                () -> stage0.setIconified(true),\n+                () -> {\n+                    assertTrue(stage0.isIconified());\n+                    assertTrue(stage1.isIconified());\n+                    assertTrue(stage2.isIconified());\n+                    assertColorDoesNotEqual(COLOR1, stage0);\n+                    assertColorDoesNotEqual(COLOR2, stage1);\n+                    assertColorDoesNotEqual(COLOR3, stage2);\n+                },\n+                () -> stage2.setIconified(false),\n+                () -> {\n+                    assertColorEquals(COLOR1, stage0);\n+                    assertColorEquals(COLOR2, stage1);\n+                    assertColorEquals(COLOR3, stage2);\n+                });\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"UNDECORATED\", \"DECORATED\"})\n+    void testMultipleChildren(StageStyle style) {\n+        Util.runAndWait(() -> {\n+            stage0 = createStage(style, COLOR1, null, Modality.NONE, -1, -1);\n+            stage1 = createStage(style, COLOR2, stage0, Modality.NONE, -1, -1);\n+            stage2 = createStage(style, COLOR3, stage0, Modality.NONE, -1, -1);\n+        });\n+        Util.doTimeLine(WAIT_TIME,\n+                () -> {\n+                    stage0.show();\n+                    stage1.show();\n+                    stage2.show();\n+                },\n+                () -> {\n+                    stage2.setY(stage0.getY());\n+                    stage1.setX(stage0.getX() - 300);\n+                    stage1.setY(stage0.getY());\n+                    stage2.setX(stage0.getX() + 300);\n+                },\n+                () -> stage0.setIconified(true),\n+                () -> {\n+                    assertColorDoesNotEqual(COLOR1, stage0);\n+                    assertColorDoesNotEqual(COLOR2, stage1);\n+                    assertColorDoesNotEqual(COLOR3, stage2);\n+                },\n+                () -> stage0.setIconified(false),\n+                () -> {\n+                    assertColorEquals(COLOR1, stage0);\n+                    assertColorEquals(COLOR2, stage1);\n+                    assertColorEquals(COLOR3, stage2);\n+                });\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"UNDECORATED\", \"DECORATED\"})\n+    void testClosingAppModalShouldFocusParent(StageStyle style) {\n+        Util.runAndWait(() -> {\n+            stage0 = createStage(style, COLOR1, null, Modality.NONE, -1, -1);\n+            stage1 = createStage(style, COLOR2, null, Modality.NONE, -1, -1);\n+            stage2 = createStage(style, COLOR3, stage0, Modality.APPLICATION_MODAL, -1, -1);\n+        });\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                stage1::show,\n+                stage0::show,\n+                () -> stage1.requestFocus(),\n+                stage2::show,\n+                stage2::close,\n+                () -> assertTrue(stage1.isFocused()));\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageOwnershipTest.java","additions":438,"deletions":0,"binary":false,"changes":438,"status":"added"}]}