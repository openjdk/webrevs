{"files":[{"patch":"@@ -49,1 +49,3 @@\n-#define NONNEGATIVE_OR(val, fallback) (((val) < 0) ? (fallback) : (val))\n+constexpr int nonnegative_or(int val, int fallback) {\n+    return (val < 0) ? fallback : val;\n+}\n@@ -828,2 +830,2 @@\n-            newW = NONNEGATIVE_OR(newW, 1);\n-            newH = NONNEGATIVE_OR(newH, 1);\n+            newW = nonnegative_or(newW, 1);\n+            newH = nonnegative_or(newH, 1);\n@@ -839,1 +841,1 @@\n-                x = NONNEGATIVE_OR(x, 0);\n+                x = nonnegative_or(x, 0);\n@@ -844,1 +846,1 @@\n-                y = NONNEGATIVE_OR(y, 0);\n+                y = nonnegative_or(y, 0);\n@@ -979,3 +981,1 @@\n-            LOG(\"com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER\\n\");\n-            mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n+            notify_fullscreen(true);\n@@ -983,3 +983,1 @@\n-            LOG(\"com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT\\n\");\n-            mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n+            notify_fullscreen(false);\n@@ -995,0 +993,12 @@\n+void WindowContext::notify_fullscreen(bool enter) {\n+    if (enter) {\n+        LOG(\"com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER\\n\");\n+        mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    } else {\n+        LOG(\"com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT\\n\");\n+        mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+}\n+\n@@ -1116,1 +1126,1 @@\n-                     : NONNEGATIVE_OR(resizable.minw - geometry.extents.width, 1);\n+                     : nonnegative_or(resizable.minw - geometry.extents.width, 1);\n@@ -1119,1 +1129,1 @@\n-                     : NONNEGATIVE_OR(resizable.minh - geometry.extents.height, 1);\n+                     : nonnegative_or(resizable.minh - geometry.extents.height, 1);\n@@ -1122,1 +1132,1 @@\n-                    : NONNEGATIVE_OR(resizable.maxw - geometry.extents.width, 1);\n+                    : nonnegative_or(resizable.maxw - geometry.extents.width, 1);\n@@ -1125,1 +1135,1 @@\n-                    : NONNEGATIVE_OR(resizable.maxh - geometry.extents.height, 1);\n+                    : nonnegative_or(resizable.maxh - geometry.extents.height, 1);\n@@ -1181,1 +1191,1 @@\n-        newW = NONNEGATIVE_OR(w - geometry.extents.width, 1);\n+        newW = nonnegative_or(w - geometry.extents.width, 1);\n@@ -1190,1 +1200,1 @@\n-        newH = NONNEGATIVE_OR(h - geometry.extents.height, 1);\n+        newH = nonnegative_or(h - geometry.extents.height, 1);\n@@ -1254,0 +1264,6 @@\n+        if (owner) {\n+            \/\/ Report back that it's not fullscreen\n+            notify_fullscreen(false);\n+            return;\n+        }\n+\n@@ -1257,2 +1273,1 @@\n-        mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n+        notify_fullscreen(true);\n@@ -1389,1 +1404,1 @@\n-        newW = NONNEGATIVE_OR(resizable.minw - geometry.extents.width, 1);\n+        newW = nonnegative_or(resizable.minw - geometry.extents.width, 1);\n@@ -1393,1 +1408,1 @@\n-        newW = NONNEGATIVE_OR(resizable.maxw - geometry.extents.width, 1);\n+        newW = nonnegative_or(resizable.maxw - geometry.extents.width, 1);\n@@ -1397,1 +1412,1 @@\n-        newH = NONNEGATIVE_OR(resizable.minh - geometry.extents.height, 1);\n+        newH = nonnegative_or(resizable.minh - geometry.extents.height, 1);\n@@ -1401,1 +1416,1 @@\n-        newH = NONNEGATIVE_OR(resizable.maxh - geometry.extents.height, 1);\n+        newH = nonnegative_or(resizable.maxh - geometry.extents.height, 1);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.cpp","additions":38,"deletions":23,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -247,0 +247,1 @@\n+    void notify_fullscreen(bool);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,373 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.robot.javafx.stage;\n+\n+import javafx.application.Platform;\n+import javafx.beans.binding.Bindings;\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Modality;\n+import javafx.stage.Screen;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.api.Timeout;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import test.robot.testharness.VisualTestBase;\n+import test.util.Util;\n+\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+import static test.util.Util.TIMEOUT;\n+\n+@Timeout(value = TIMEOUT, unit = TimeUnit.MILLISECONDS)\n+class StageOwnershipAndFocusTest extends VisualTestBase {\n+    private static final int WIDTH = 200;\n+    private static final int HEIGHT = 200;\n+    private static final double BOUNDS_EDGE_DELTA = 75;\n+    private Stage topStage;\n+    private Stage bottomStage;\n+    private static final Color TOP_COLOR = Color.RED;\n+    private static final Color BOTTOM_COLOR = Color.LIME;\n+    private static final Color COLOR0 = Color.RED;\n+    private static final Color COLOR1 = Color.ORANGE;\n+    private static final Color COLOR2 = Color.YELLOW;\n+    private static final int X_DELTA = 15; \/\/ shadows\n+    private static final int Y_DELTA = 75; \/\/ shadows + decoration\n+\n+    private static final double TOLERANCE = 0.07;\n+    private static final int WAIT_TIME = 500;\n+    private static final int LONG_WAIT_TIME = 1000;\n+\n+    private void setupBottomStage() throws InterruptedException {\n+        final CountDownLatch shownLatch = new CountDownLatch(1);\n+\n+        runAndWait(() -> {\n+            bottomStage = getStage(false);\n+            bottomStage.initStyle(StageStyle.DECORATED);\n+            Scene bottomScene = new Scene(getFocusedLabel(BOTTOM_COLOR, bottomStage), WIDTH, HEIGHT);\n+            bottomScene.setFill(BOTTOM_COLOR);\n+            bottomStage.setScene(bottomScene);\n+            bottomStage.setX(0);\n+            bottomStage.setY(0);\n+            bottomStage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            bottomStage.show();\n+        });\n+        assertTrue(shownLatch.await(TIMEOUT, TimeUnit.MILLISECONDS),\n+                \"Timeout waiting for bottom stage to be shown\");\n+\n+        sleep(WAIT_TIME);\n+    }\n+\n+    private void setupTopStage(Stage owner, StageStyle stageStyle, Modality modality) {\n+        runAndWait(() -> {\n+            topStage = getStage(true);\n+            if (stageStyle != null) {\n+                topStage.initStyle(stageStyle);\n+            }\n+            Scene topScene = new Scene(getFocusedLabel(TOP_COLOR, topStage), WIDTH, HEIGHT);\n+            topScene.setFill(TOP_COLOR);\n+            topStage.setScene(topScene);\n+            if (owner != null) {\n+                topStage.initOwner(owner);\n+            }\n+            if (modality != null) {\n+                topStage.initModality(modality);\n+            }\n+            topStage.setWidth(WIDTH);\n+            topStage.setHeight(HEIGHT);\n+            topStage.setX(0);\n+            topStage.setY(0);\n+        });\n+    }\n+\n+    private void assertColorEqualsVisualBounds(Color expected) {\n+        Rectangle2D visualBounds = Screen.getPrimary().getVisualBounds();\n+        int x = (int) (visualBounds.getWidth() - BOUNDS_EDGE_DELTA);\n+        int y = (int) (visualBounds.getHeight() - BOUNDS_EDGE_DELTA);\n+\n+        Color color = getColor(x, y);\n+        assertColorEquals(expected, color, TOLERANCE);\n+    }\n+\n+    private Stage createStage(StageStyle stageStyle, Color color, Stage owner, Modality modality, int x, int y) {\n+        Stage stage = getStage(true);\n+        stage.initStyle(stageStyle);\n+        StackPane pane = getFocusedLabel(color, stage);\n+        Scene scene = new Scene(pane, WIDTH, HEIGHT);\n+        scene.setFill(color);\n+        stage.setScene(scene);\n+        stage.setWidth(WIDTH);\n+        stage.setHeight(HEIGHT);\n+        if (x != -1) {\n+            stage.setX(x);\n+        }\n+        if (y != -1) {\n+            stage.setY(y);\n+        }\n+        if (owner != null) {\n+            stage.initOwner(owner);\n+        }\n+        stage.initModality(modality);\n+        return stage;\n+    }\n+\n+    private static StackPane getFocusedLabel(Color color, Stage stage) {\n+        Label label = new Label();\n+        label.textProperty().bind(Bindings.when(stage.focusedProperty())\n+                .then(\"Focused\").otherwise(\"Unfocused\"));\n+        StackPane pane = new StackPane(label);\n+        pane.setBackground(Background.EMPTY);\n+\n+        double luminance = 0.2126 * color.getRed()\n+                + 0.7152 * color.getGreen()\n+                + 0.0722 * color.getBlue();\n+\n+        Color textColor = luminance < 0.5 ? Color.WHITE : Color.BLACK;\n+\n+        label.setTextFill(textColor);\n+        return pane;\n+    }\n+\n+    private void assertColorEquals(Color expected, Stage stage) {\n+        Color color = getColor((int) stage.getX() + X_DELTA, (int) stage.getY() + Y_DELTA);\n+        assertColorEquals(expected, color, TOLERANCE);\n+    }\n+\n+    private void assertColorDoesNotEqual(Color notExpected, Stage stage) {\n+        Color color = getColor((int) stage.getX() + X_DELTA, (int) stage.getY() + Y_DELTA);\n+        assertColorDoesNotEqual(notExpected, color, TOLERANCE);\n+    }\n+\n+    private static Stream<Arguments> getTestsParams() {\n+        return Stream.of(StageStyle.DECORATED, StageStyle.UNDECORATED)\n+                .flatMap(stageStyle -> Stream.of(Modality.APPLICATION_MODAL, Modality.WINDOW_MODAL)\n+                        .map(modality -> Arguments.of(stageStyle, modality)));\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @MethodSource(\"getTestsParams\")\n+    void testOpeningModalChildStageWhileMaximizedShouldHaveFocus(StageStyle stageStyle, Modality modality)\n+            throws InterruptedException {\n+        setupBottomStage();\n+        setupTopStage(bottomStage, stageStyle, modality);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                () -> bottomStage.setMaximized(true),\n+                topStage::show,\n+                () -> {\n+                    assertTrue(bottomStage.isMaximized());\n+                    \/\/ Make sure state is still maximized\n+                    assertColorEqualsVisualBounds(BOTTOM_COLOR);\n+\n+                    Color color = getColor(100, 100);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+                });\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @MethodSource(\"getTestsParams\")\n+    void testOpeningModalChildStageWhileFullSceenShouldHaveFocus(StageStyle stageStyle, Modality modality)\n+            throws InterruptedException {\n+        setupBottomStage();\n+        setupTopStage(bottomStage, stageStyle, modality);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                () -> bottomStage.setFullScreen(true),\n+                topStage::show,\n+                () -> {\n+                    assertTrue(bottomStage.isFullScreen());\n+\n+                    \/\/ Make sure state is still fullscreen\n+                    assertColorEqualsVisualBounds(BOTTOM_COLOR);\n+\n+                    Color color = getColor(100, 100);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+                });\n+    }\n+\n+    private Stage stage0;\n+    private Stage stage1;\n+    private Stage stage2;\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @MethodSource(\"getTestsParams\")\n+    void testClosingModalWindowShouldFocusParent(StageStyle style, Modality modality) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            stage0 = createStage(style, COLOR0, null, null, 100, 100);\n+            stage1 = createStage(style, COLOR1, stage0, null, 150, 150);\n+            stage2 = createStage(style, COLOR2, stage1, modality, 200, 200);\n+\n+            stage0.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            stage0.show();\n+        });\n+\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT_TIME);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                stage1::show,\n+                stage2::show,\n+                () -> {\n+                    assertTrue(stage2.isFocused());\n+                    assertColorEquals(COLOR2, stage2);\n+                    assertFalse(stage1.isFocused());\n+                    assertFalse(stage0.isFocused());\n+                },\n+                stage2::close,\n+                () -> {\n+                    assertTrue(stage1.isFocused());\n+                    assertColorEquals(COLOR1, stage1);\n+                    assertFalse(stage0.isFocused());\n+                },\n+                stage1::close,\n+                () -> {\n+                    assertTrue(stage0.isFocused());\n+                    assertColorEquals(COLOR0, stage0);\n+                });\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    void testIconifyParentShouldHideChildren(StageStyle style) {\n+        CountDownLatch shownLatch = new CountDownLatch(3);\n+        Util.runAndWait(() -> {\n+            stage0 = createStage(style, COLOR0, null, null, 100, 100);\n+            stage1 = createStage(style, COLOR1, stage0, null, 150, 150);\n+            stage2 = createStage(style, COLOR2, stage1, null, 200, 200);\n+\n+            List.of(stage0, stage1, stage2).forEach(stage -> {\n+                stage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+                stage.show();\n+            });\n+        });\n+\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT_TIME);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                () -> stage0.setIconified(true),\n+                () -> {\n+                    assertTrue(stage0.isIconified());\n+                    assertColorDoesNotEqual(COLOR0, stage0);\n+                    assertColorDoesNotEqual(COLOR1, stage1);\n+                    assertColorDoesNotEqual(COLOR2, stage2);\n+                },\n+                () -> stage0.setIconified(false),\n+                () -> {\n+                    assertFalse(stage0.isIconified());\n+                    assertColorEquals(COLOR0, stage0);\n+                    assertColorEquals(COLOR1, stage1);\n+                    assertColorEquals(COLOR2, stage2);\n+                });\n+    }\n+\n+    private static Stream<Arguments> getFullScreenOnChildTestParameters() {\n+        return Stream.of(StageStyle.DECORATED)\n+                .flatMap(stageStyle -> Stream.of(Modality.NONE, Modality.WINDOW_MODAL)\n+                        .map(modality -> Arguments.of(stageStyle, modality)));\n+    }\n+\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @MethodSource(\"getFullScreenOnChildTestParameters\")\n+    void testFullScreenOnChildAfterShowShouldNotBeAllowed(StageStyle style, Modality modality) {\n+        CountDownLatch stage0Latch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+                    stage0 = createStage(style, COLOR0, null, null, 0, 0);\n+                    stage0.setWidth(WIDTH * 3);\n+                    stage0.setHeight(HEIGHT * 3);\n+\n+                    stage0.setOnShown(e -> Platform.runLater(stage0Latch::countDown));\n+                    stage0.show();\n+                });\n+        Util.await(stage0Latch);\n+        Util.sleep(WAIT_TIME);\n+\n+        CountDownLatch stage1Latch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            stage1 = createStage(style, COLOR1, stage0, modality, 0, 0);\n+            stage1.setOnShown(e -> Platform.runLater(stage1Latch::countDown));\n+            stage1.show();\n+        });\n+\n+        Util.await(stage1Latch);\n+        Util.sleep(WAIT_TIME);\n+\n+        Util.doTimeLine(LONG_WAIT_TIME,\n+                () -> stage1.setFullScreen(true),\n+                () -> {\n+                    assertFalse(stage1.isFullScreen());\n+                    Color color = getColor(WIDTH * 2, HEIGHT * 2);\n+                    assertColorEquals(COLOR0, color, TOLERANCE);\n+                });\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @MethodSource(\"getFullScreenOnChildTestParameters\")\n+    void testFullScreenOnChildBeforeShowShouldNotBeAllowed(StageStyle style, Modality modality) {\n+        CountDownLatch stage0Latch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+                    stage0 = createStage(style, COLOR0, null, null, 0, 0);\n+                    stage0.setWidth(WIDTH * 3);\n+                    stage0.setHeight(HEIGHT * 3);\n+\n+                    stage0.setOnShown(e -> Platform.runLater(stage0Latch::countDown));\n+                    stage0.show();\n+                });\n+        Util.await(stage0Latch);\n+        Util.sleep(WAIT_TIME);\n+\n+        CountDownLatch stage1Latch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            stage1 = createStage(style, COLOR1, stage0, modality, 0, 0);\n+            stage1.setFullScreen(true);\n+            stage1.setOnShown(e -> Platform.runLater(stage1Latch::countDown));\n+            stage1.show();\n+        });\n+\n+        Util.await(stage1Latch);\n+        Util.sleep(LONG_WAIT_TIME);\n+\n+        Util.runAndWait(() -> {\n+            assertFalse(stage1.isFullScreen());\n+            Color color = getColor(WIDTH * 2, HEIGHT * 2);\n+            assertColorEquals(COLOR0, color, TOLERANCE);\n+        });\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageOwnershipAndFocusTest.java","additions":373,"deletions":0,"binary":false,"changes":373,"status":"added"},{"patch":"@@ -1,299 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.robot.javafx.stage;\n-\n-import javafx.application.Platform;\n-import javafx.beans.binding.Bindings;\n-import javafx.geometry.Rectangle2D;\n-import javafx.scene.Scene;\n-import javafx.scene.control.Label;\n-import javafx.scene.layout.Background;\n-import javafx.scene.layout.StackPane;\n-import javafx.scene.paint.Color;\n-import javafx.stage.Modality;\n-import javafx.stage.Screen;\n-import javafx.stage.Stage;\n-import javafx.stage.StageStyle;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.EnumSource;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import test.robot.testharness.VisualTestBase;\n-import test.util.Util;\n-\n-import java.util.List;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import java.util.stream.Stream;\n-\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n-import static test.util.Util.TIMEOUT;\n-\n-class StageOwnershipTest extends VisualTestBase {\n-    private static final int WIDTH = 200;\n-    private static final int HEIGHT = 200;\n-    private static final double BOUNDS_EDGE_DELTA = 75;\n-    private Stage topStage;\n-    private Stage bottomStage;\n-    private static final Color TOP_COLOR = Color.RED;\n-    private static final Color BOTTOM_COLOR = Color.LIME;\n-    private static final Color COLOR0 = Color.RED;\n-    private static final Color COLOR1 = Color.ORANGE;\n-    private static final Color COLOR2 = Color.YELLOW;\n-    private static final Color COLOR3 = Color.GREEN;\n-    private static final int X_DELTA = 15; \/\/ shadows\n-    private static final int Y_DELTA = 75; \/\/ shadows + decoration\n-\n-    private static final double TOLERANCE = 0.07;\n-    private static final int WAIT_TIME = 500;\n-\n-    private void setupBottomStage() throws InterruptedException {\n-        final CountDownLatch shownLatch = new CountDownLatch(1);\n-\n-        runAndWait(() -> {\n-            bottomStage = getStage(false);\n-            bottomStage.initStyle(StageStyle.DECORATED);\n-            Scene bottomScene = new Scene(getFocusedLabel(BOTTOM_COLOR, bottomStage), WIDTH, HEIGHT);\n-            bottomScene.setFill(BOTTOM_COLOR);\n-            bottomStage.setScene(bottomScene);\n-            bottomStage.setX(0);\n-            bottomStage.setY(0);\n-            bottomStage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n-            bottomStage.show();\n-        });\n-        assertTrue(shownLatch.await(TIMEOUT, TimeUnit.MILLISECONDS),\n-                \"Timeout waiting for bottom stage to be shown\");\n-\n-        sleep(WAIT_TIME);\n-    }\n-\n-    private void setupTopStage(Stage owner, StageStyle stageStyle, Modality modality) {\n-        runAndWait(() -> {\n-            topStage = getStage(true);\n-            if (stageStyle != null) {\n-                topStage.initStyle(stageStyle);\n-            }\n-            Scene topScene = new Scene(getFocusedLabel(TOP_COLOR, topStage), WIDTH, HEIGHT);\n-            topScene.setFill(TOP_COLOR);\n-            topStage.setScene(topScene);\n-            if (owner != null) {\n-                topStage.initOwner(owner);\n-            }\n-            if (modality != null) {\n-                topStage.initModality(modality);\n-            }\n-            topStage.setWidth(WIDTH);\n-            topStage.setHeight(HEIGHT);\n-            topStage.setX(0);\n-            topStage.setY(0);\n-        });\n-    }\n-\n-    private void assertColorEqualsVisualBounds(Color expected) {\n-        Rectangle2D visualBounds = Screen.getPrimary().getVisualBounds();\n-        int x = (int) (visualBounds.getWidth() - BOUNDS_EDGE_DELTA);\n-        int y = (int) (visualBounds.getHeight() - BOUNDS_EDGE_DELTA);\n-\n-        Color color = getColor(x, y);\n-        assertColorEquals(expected, color, TOLERANCE);\n-    }\n-\n-    private Stage createStage(StageStyle stageStyle, Color color, Stage owner, Modality modality, int x, int y) {\n-        Stage stage = getStage(true);\n-        stage.initStyle(stageStyle);\n-        StackPane pane = getFocusedLabel(color, stage);\n-        Scene scene = new Scene(pane, WIDTH, HEIGHT);\n-        scene.setFill(color);\n-        stage.setScene(scene);\n-        stage.setWidth(WIDTH);\n-        stage.setHeight(HEIGHT);\n-        if (x != -1) {\n-            stage.setX(x);\n-        }\n-        if (y != -1) {\n-            stage.setY(y);\n-        }\n-        if (owner != null) {\n-            stage.initOwner(owner);\n-        }\n-        stage.initModality(modality);\n-        return stage;\n-    }\n-\n-    private static StackPane getFocusedLabel(Color color, Stage stage) {\n-        Label label = new Label();\n-        label.textProperty().bind(Bindings.when(stage.focusedProperty())\n-                .then(\"Focused\").otherwise(\"Unfocused\"));\n-        StackPane pane = new StackPane(label);\n-        pane.setBackground(Background.EMPTY);\n-\n-        double luminance = 0.2126 * color.getRed()\n-                + 0.7152 * color.getGreen()\n-                + 0.0722 * color.getBlue();\n-\n-        Color textColor = luminance < 0.5 ? Color.WHITE : Color.BLACK;\n-\n-        label.setTextFill(textColor);\n-        return pane;\n-    }\n-\n-    private void assertColorEquals(Color expected, Stage stage) {\n-        Color color = getColor((int) stage.getX() + X_DELTA, (int) stage.getY() + Y_DELTA);\n-        assertColorEquals(expected, color, TOLERANCE);\n-    }\n-\n-    private void assertColorDoesNotEqual(Color notExpected, Stage stage) {\n-        Color color = getColor((int) stage.getX() + X_DELTA, (int) stage.getY() + Y_DELTA);\n-        assertColorDoesNotEqual(notExpected, color, TOLERANCE);\n-    }\n-\n-    private static Stream<Arguments> getTestsParams() {\n-        return Stream.of(StageStyle.DECORATED, StageStyle.UNDECORATED)\n-                .flatMap(stageStyle -> Stream.of(Modality.APPLICATION_MODAL, Modality.WINDOW_MODAL)\n-                        .map(modality -> Arguments.of(stageStyle, modality)));\n-    }\n-\n-    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n-    @MethodSource(\"getTestsParams\")\n-    void testOpeningModalChildStageWhileMaximizedShouldHaveFocus(StageStyle stageStyle, Modality modality)\n-            throws InterruptedException {\n-        setupBottomStage();\n-        setupTopStage(bottomStage, stageStyle, modality);\n-\n-        Util.doTimeLine(WAIT_TIME,\n-                () -> bottomStage.setMaximized(true),\n-                topStage::show,\n-                () -> {\n-                    assertTrue(bottomStage.isMaximized());\n-                    \/\/ Make sure state is still maximized\n-                    assertColorEqualsVisualBounds(BOTTOM_COLOR);\n-\n-                    Color color = getColor(100, 100);\n-                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n-                });\n-    }\n-\n-    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n-    @MethodSource(\"getTestsParams\")\n-    void testOpeningModalChildStageWhileFullSceenShouldHaveFocus(StageStyle stageStyle, Modality modality)\n-            throws InterruptedException {\n-        setupBottomStage();\n-        setupTopStage(bottomStage, stageStyle, modality);\n-\n-        Util.doTimeLine(WAIT_TIME,\n-                () -> bottomStage.setFullScreen(true),\n-                topStage::show,\n-                () -> {\n-                    assertTrue(bottomStage.isFullScreen());\n-\n-                    \/\/ Make sure state is still fullscreen\n-                    assertColorEqualsVisualBounds(BOTTOM_COLOR);\n-\n-                    Color color = getColor(100, 100);\n-                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n-                });\n-    }\n-\n-    private Stage stage0;\n-    private Stage stage1;\n-    private Stage stage2;\n-    private Stage stage3;\n-\n-    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n-    @MethodSource(\"getTestsParams\")\n-    void testClosingModalWindowShouldFocusParent(StageStyle style, Modality modality) {\n-        CountDownLatch shownLatch = new CountDownLatch(1);\n-        Util.runAndWait(() -> {\n-            stage0 = createStage(style, COLOR0, null, null, 100, 100);\n-            stage1 = createStage(style, COLOR1, stage0, null, 150, 150);\n-            stage2 = createStage(style, COLOR2, stage1, modality, 200, 200);\n-\n-            stage0.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n-            stage0.show();\n-        });\n-\n-        Util.await(shownLatch);\n-        Util.sleep(WAIT_TIME);\n-\n-        Util.doTimeLine(WAIT_TIME,\n-                stage1::show,\n-                stage2::show,\n-                () -> {\n-                    assertTrue(stage2.isFocused());\n-                    assertColorEquals(COLOR2, stage2);\n-                    assertFalse(stage1.isFocused());\n-                    assertFalse(stage0.isFocused());\n-                },\n-                stage2::close,\n-                () -> {\n-                    assertTrue(stage1.isFocused());\n-                    assertColorEquals(COLOR1, stage1);\n-                    assertFalse(stage0.isFocused());\n-                },\n-                stage1::close,\n-                () -> {\n-                    assertTrue(stage0.isFocused());\n-                    assertColorEquals(COLOR0, stage0);\n-                });\n-    }\n-\n-    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n-    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n-    void testIconifyParentShouldHideChildren(StageStyle style) {\n-        CountDownLatch shownLatch = new CountDownLatch(3);\n-        Util.runAndWait(() -> {\n-            stage0 = createStage(style, COLOR0, null, null, 100, 100);\n-            stage1 = createStage(style, COLOR1, stage0, null, 150, 150);\n-            stage2 = createStage(style, COLOR2, stage1, null, 200, 200);\n-\n-            List.of(stage0, stage1, stage2).forEach(stage -> {\n-                stage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n-                stage.show();\n-            });\n-        });\n-\n-        Util.await(shownLatch);\n-        Util.sleep(WAIT_TIME);\n-\n-        Util.doTimeLine(WAIT_TIME,\n-                () -> stage0.setIconified(true),\n-                () -> {\n-                    assertTrue(stage0.isIconified());\n-                    assertColorDoesNotEqual(COLOR0, stage0);\n-                    assertColorDoesNotEqual(COLOR1, stage1);\n-                    assertColorDoesNotEqual(COLOR2, stage2);\n-                },\n-                () -> stage0.setIconified(false),\n-                () -> {\n-                    assertFalse(stage0.isIconified());\n-                    assertColorEquals(COLOR0, stage0);\n-                    assertColorEquals(COLOR1, stage1);\n-                    assertColorEquals(COLOR2, stage2);\n-                });\n-    }\n-   }\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageOwnershipTest.java","additions":0,"deletions":299,"binary":false,"changes":299,"status":"deleted"}]}