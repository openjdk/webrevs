{"files":[{"patch":"@@ -101,0 +101,2 @@\n+    protected native void enterFullscreenImpl(long ptr, boolean animate, boolean keepRatio, boolean hideCursor);\n+\n@@ -102,1 +104,5 @@\n-    protected native boolean _enterFullscreen(long ptr, boolean animate, boolean keepRatio, boolean hideCursor);\n+    protected boolean _enterFullscreen(long ptr, boolean animate, boolean keepRatio, boolean hideCursor) {\n+        enterFullscreenImpl(ptr, animate, keepRatio, hideCursor);\n+\n+        return true;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkView.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -131,2 +131,6 @@\n-        notifyStateChanged(WindowEvent.MINIMIZE);\n-        return minimize;\n+\n+        if (!isVisible()) {\n+            notifyStateChanged(WindowEvent.MINIMIZE);\n+        }\n+\n+        return isMinimized();\n@@ -139,2 +143,1 @@\n-        notifyStateChanged(WindowEvent.MAXIMIZE);\n-        return maximize;\n+        return isMaximized();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkWindow.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -485,2 +485,0 @@\n-                    \/\/ let gtk handle it first to prevent a glitch\n-                    gtk_main_do_event(event);\n@@ -488,0 +486,1 @@\n+                    gtk_main_do_event(event);\n@@ -490,1 +489,1 @@\n-                    ctx->process_configure(&event->configure);\n+                    \/\/ Let gtk handle it first, so state values are updated\n@@ -492,0 +491,1 @@\n+                    ctx->process_configure(&event->configure);\n@@ -506,1 +506,1 @@\n-                    ctx->process_expose(&event->expose);\n+                    ctx->notify_repaint(&event->expose.area);\n@@ -509,1 +509,1 @@\n-                    ctx->process_state(&event->window_state);\n+                    \/\/ Let gtk handle it first, so state values are updated\n@@ -511,0 +511,1 @@\n+                    ctx->process_state(&event->window_state);\n@@ -538,1 +539,2 @@\n-                    \/\/ fall-through\n+                    ctx->process_map();\n+                    break;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassApplication.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-static GtkWindow *gdk_window_handle_to_gtk(jlong handle) {\n+static GdkWindow *get_gdk_window(jlong handle) {\n@@ -70,1 +70,1 @@\n-                ? ((WindowContext*)JLONG_TO_PTR(handle))->get_gtk_window()\n+                ? ((WindowContext*)JLONG_TO_PTR(handle))->get_gdk_window()\n@@ -74,0 +74,9 @@\n+static void on_dialog_realize_set_parent(GtkWidget *dialog, gpointer user_data) {\n+    GdkWindow *parent_gdk_window = (GdkWindow *) user_data;\n+    GdkWindow *dialog_gdk_window = gtk_widget_get_window(dialog);\n+\n+    if (dialog_gdk_window && parent_gdk_window) {\n+        gdk_window_set_transient_for(dialog_gdk_window, parent_gdk_window);\n+    }\n+}\n+\n@@ -115,1 +124,1 @@\n-    GtkWidget* chooser = gtk_file_chooser_dialog_new(chooser_title, gdk_window_handle_to_gtk(parent),\n+    GtkWidget* chooser = gtk_file_chooser_dialog_new(chooser_title, NULL,\n@@ -123,0 +132,2 @@\n+    g_signal_connect(chooser, \"realize\", G_CALLBACK(on_dialog_realize_set_parent), get_gdk_window(parent));\n+\n@@ -211,1 +222,1 @@\n-            gdk_window_handle_to_gtk(parent),\n+            NULL,\n@@ -219,0 +230,2 @@\n+    g_signal_connect(chooser, \"realize\", G_CALLBACK(on_dialog_realize_set_parent), get_gdk_window(parent));\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassCommonDialogs.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-    tmp = glass_pixbuf_from_window(root_window, x, y, width, height);\n+    tmp = gdk_pixbuf_get_from_window(root_window, x, y, width, height);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassRobot.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -274,2 +274,2 @@\n- * Method:    _enterFullscreen\n- * Signature: (JZZZ)Z\n+ * Method:    enterFullscreenImpl\n+ * Signature: (JZZZ)V\n@@ -277,3 +277,2 @@\n-JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkView__1enterFullscreen\n-  (JNIEnv * env, jobject obj, jlong ptr, jboolean animate, jboolean keepRation, jboolean hideCursor)\n-{\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkView_enterFullscreenImpl\n+  (JNIEnv * env, jobject obj, jlong ptr, jboolean animate, jboolean keepRation, jboolean hideCursor) {\n@@ -287,2 +286,0 @@\n-        env->CallVoidMethod(obj, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER);\n-        CHECK_JNI_EXCEPTION_RET(env, JNI_FALSE)\n@@ -290,1 +287,0 @@\n-    return JNI_TRUE;\n@@ -310,2 +306,0 @@\n-        env->CallVoidMethod(obj, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT);\n-        CHECK_JNI_EXCEPTION(env)\n@@ -313,1 +307,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassView.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    WindowContext* ctx = new WindowContextTop(obj,\n+    WindowContext* ctx = new WindowContext(obj,\n@@ -391,2 +391,0 @@\n-    if (w == -1) w = G_MAXSHORT;\n-    if (h == -1) h = G_MAXSHORT;\n@@ -549,7 +547,1 @@\n-    GdkWindow *win = ctx->get_gdk_window();\n-\n-    if (win == NULL) {\n-        return 0;\n-    }\n-\n-    return GDK_WINDOW_XID(win);\n+    return ctx->get_native_window();\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassWindow.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -83,2 +83,0 @@\n-jmethodID jGtkWindowNotifyStateChanged;\n-\n@@ -272,3 +270,0 @@\n-    jGtkWindowNotifyStateChanged =\n-            env->GetMethodID(clazz, \"notifyStateChanged\", \"(I)V\");\n-    if (env->ExceptionCheck()) return JNI_ERR;\n@@ -574,1 +569,0 @@\n-static void configure_opaque_window(GtkWidget *window);\n@@ -582,10 +576,0 @@\n-GdkScreen * glass_gdk_window_get_screen(GdkWindow * gdkWindow)\n-{\n-#ifdef GLASS_GTK3\n-        GdkVisual * gdkVisual = gdk_window_get_visual(gdkWindow);\n-        return gdk_visual_get_screen(gdkVisual);\n-#else\n-        return gdk_window_get_screen(gdkWindow);\n-#endif\n-}\n-\n@@ -625,1 +609,0 @@\n-#ifdef GLASS_GTK3\n@@ -629,3 +612,0 @@\n-#else\n-        gdk_display_get_pointer(gdk_display_get_default(), NULL, x, y, NULL);\n-#endif\n@@ -636,6 +616,1 @@\n-#ifdef GLASS_GTK3\n-        return gdk_display_device_is_grabbed(gdk_display_get_default(), device);\n-#else\n-        (void) device;\n-        return gdk_display_pointer_is_grabbed(gdk_display_get_default());\n-#endif\n+    return gdk_display_device_is_grabbed(gdk_display_get_default(), device);\n@@ -646,6 +621,1 @@\n-#ifdef GLASS_GTK3\n-        gdk_device_ungrab(device, GDK_CURRENT_TIME);\n-#else\n-        (void) device;\n-        gdk_pointer_ungrab(GDK_CURRENT_TIME);\n-#endif\n+    gdk_device_ungrab(device, GDK_CURRENT_TIME);\n@@ -657,18 +627,1 @@\n-#ifdef GLASS_GTK3\n-        return gdk_device_get_window_at_position(device, x, y);\n-#else\n-        (void) device;\n-        return gdk_display_get_window_at_pointer(gdk_display_get_default(), x, y);\n-#endif\n-}\n-\n-void\n-glass_gtk_configure_transparency_and_realize(GtkWidget *window,\n-                                             gboolean transparent) {\n-        gboolean isTransparent = glass_configure_window_transparency(window, transparent);\n-        gtk_widget_realize(window);\n-}\n-\n-void\n-glass_gtk_window_configure_from_visual(GtkWidget *widget, GdkVisual *visual) {\n-    glass_widget_set_visual(widget, visual);\n+    return gdk_device_get_window_at_position(device, x, y);\n@@ -682,17 +635,7 @@\n-#ifdef GLASS_GTK3\n-        GdkVisual *visual = gdk_screen_get_rgba_visual(default_screen);\n-        if (visual\n-                && gdk_display_supports_composite(default_display)\n-                && gdk_screen_is_composited(default_screen)) {\n-            glass_widget_set_visual(window, visual);\n-            return TRUE;\n-        }\n-#else\n-        GdkColormap *colormap = gdk_screen_get_rgba_colormap(default_screen);\n-        if (colormap\n-                && gdk_display_supports_composite(default_display)\n-                && gdk_screen_is_composited(default_screen)) {\n-            gtk_widget_set_colormap(window, colormap);\n-            return TRUE;\n-        }\n-#endif\n+    GdkVisual *visual = gdk_screen_get_rgba_visual(default_screen);\n+    if (visual\n+            && gdk_display_supports_composite(default_display)\n+            && gdk_screen_is_composited(default_screen)) {\n+        glass_widget_set_visual(window, visual);\n+        return TRUE;\n+    }\n@@ -703,6 +646,0 @@\n-void\n-glass_gdk_window_get_size(GdkWindow *window, gint *w, gint *h) {\n-    *w = gdk_window_get_width(window);\n-    *h = gdk_window_get_height(window);\n-}\n-\n@@ -711,7 +648,3 @@\n-#ifdef GLASS_GTK3\n-        gdk_device_get_position(\n-            gdk_device_manager_get_client_pointer(\n-                gdk_display_get_device_manager(display)), NULL , x, y);\n-#else\n-        gdk_display_get_pointer(display, NULL, x, y, NULL);\n-#endif\n+    gdk_device_get_position(\n+        gdk_device_manager_get_client_pointer(\n+            gdk_display_get_device_manager(display)), NULL , x, y);\n@@ -733,11 +666,4 @@\n-static void\n-configure_opaque_window(GtkWidget *window) {\n-    (void) window;\n-\/* We need to pick a visual that really is glx compatible\n- * instead of using the default visual\n- *\/\n- \/* see: JDK-8087516 for why this is commented out\n-    glass_widget_set_visual(window,\n-                          gdk_screen_get_system_visual(\n-                              gdk_screen_get_default()));\n-  *\/\n+void glass_print_window_transparency_not_supported() {\n+    fprintf(stderr, \"Can't create transparent stage, because your screen doesn't support alpha channel.\"\n+           \" You need to enable XComposite extension.\\n\");\n+    fflush(stderr);\n@@ -753,4 +679,1 @@\n-        fprintf(stderr,\"Can't create transparent stage, because your screen doesn't\"\n-               \" support alpha channel.\"\n-               \" You need to enable XComposite extension.\\n\");\n-        fflush(stderr);\n+        glass_print_window_transparency_not_supported();\n@@ -759,1 +682,0 @@\n-    configure_opaque_window(window);\n@@ -770,10 +692,1 @@\n-#ifdef GLASS_GTK3\n-        ret = gdk_pixbuf_get_from_window (window, srcx, srcy, width, height);\n-#else\n-        ret = gdk_pixbuf_get_from_drawable (NULL,\n-            window,\n-            NULL,\n-            srcx, srcy,\n-            0, 0,\n-            width, height);\n-#endif\n+     gdk_pixbuf_get_from_window (window, srcx, srcy, width, height);\n@@ -783,37 +696,0 @@\n-void\n-glass_window_apply_shape_mask(GdkWindow *window,\n-    void* data, uint width, uint height)\n-{\n-#ifdef GLASS_GTK3\n-    (void) window;\n-    (void) data;\n-    (void) width;\n-    (void) height;\n-#else\n-        GdkPixbuf* pixbuf = gdk_pixbuf_new_from_data((guchar *) data,\n-                GDK_COLORSPACE_RGB, TRUE, 8, width, height, width * 4, NULL, NULL);\n-\n-        if (GDK_IS_PIXBUF(pixbuf)) {\n-            GdkBitmap* mask = NULL;\n-            gdk_pixbuf_render_pixmap_and_mask(pixbuf, NULL, &mask, 128);\n-\n-            gdk_window_input_shape_combine_mask(window, mask, 0, 0);\n-\n-            g_object_unref(pixbuf);\n-            if (mask) {\n-                g_object_unref(mask);\n-            }\n-        }\n-#endif\n-}\n-\n-void\n-glass_window_reset_input_shape_mask(GdkWindow *window)\n-{\n-#ifdef GLASS_GTK3\n-        gdk_window_input_shape_combine_region(window, NULL, 0, 0);\n-#else\n-        gdk_window_input_shape_combine_mask(window, NULL, 0, 0);\n-#endif\n-}\n-\n@@ -830,1 +706,0 @@\n-#ifdef GLASS_GTK3\n@@ -835,4 +710,0 @@\n-#else\n-    (void) display;\n-    (void) scale;\n-#endif\n@@ -846,1 +717,0 @@\n-#ifdef GLASS_GTK3\n@@ -848,4 +718,0 @@\n-#else\n-        GdkColormap *colormap = gdk_colormap_new(visual, TRUE);\n-        gtk_widget_set_colormap (widget, colormap);\n-#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.cpp","additions":19,"deletions":153,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -197,2 +197,0 @@\n-    extern jmethodID jGtkWindowNotifyStateChanged; \/\/ com.sun.glass.ui.GtkWindow#notifyStateChanged (I)V\n-\n@@ -246,0 +244,1 @@\n+#define LOG(msg, ...) { printf(msg, ##__VA_ARGS__); fflush(stdout); }\n@@ -261,0 +260,1 @@\n+#define LOG(msg, ...)\n@@ -309,3 +309,0 @@\n-GdkScreen *\n-glass_gdk_window_get_screen(GdkWindow * gdkWindow);\n-\n@@ -321,6 +318,0 @@\n-void\n-glass_gdk_master_pointer_grab(GdkEvent *event, GdkWindow *window, GdkCursor *cursor);\n-\n-void\n-glass_gdk_master_pointer_ungrab(GdkEvent *event);\n-\n@@ -340,3 +331,0 @@\n-void\n-glass_gtk_configure_transparency_and_realize(GtkWidget *window,\n-                                                  gboolean transparent);\n@@ -349,6 +337,0 @@\n-void\n-glass_gtk_window_configure_from_visual(GtkWidget *widget, GdkVisual *visual);\n-\n-void\n-glass_gdk_window_get_size(GdkWindow *window, gint *w, gint *h);\n-\n@@ -361,0 +343,3 @@\n+void\n+glass_print_window_transparency_not_supported();\n+\n@@ -373,3 +358,0 @@\n-void\n-glass_window_reset_input_shape_mask(GdkWindow *window);\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.h","additions":5,"deletions":23,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"glass_evloop.h\"\n@@ -35,1 +36,0 @@\n-\n@@ -38,1 +38,0 @@\n-#include <X11\/extensions\/shape.h>\n@@ -40,2 +39,0 @@\n-#include <cairo-xlib.h>\n-#include <gdk\/gdkx.h>\n@@ -43,3 +40,0 @@\n-#ifdef GLASS_GTK3\n-#include <gtk\/gtkx.h>\n-#endif\n@@ -48,1 +42,0 @@\n-\n@@ -50,0 +43,1 @@\n+#include <optional>\n@@ -54,2 +48,7 @@\n-WindowContext * WindowContextBase::sm_grab_window = NULL;\n-WindowContext * WindowContextBase::sm_mouse_drag_window = NULL;\n+#define NONNEGATIVE_OR(val, fallback) (((val) < 0) ? (fallback) : (val))\n+\n+\n+void destroy_and_delete_ctx(WindowContext* ctx) {\n+    LOG(\"destroy_and_delete_ctx\\n\");\n+    if (ctx) {\n+        ctx->process_destroy();\n@@ -57,2 +56,7 @@\n-GdkWindow* WindowContextBase::get_gdk_window(){\n-    return gdk_window;\n+        if (!ctx->get_events_count()) {\n+            LOG(\"delete ctx\\n\");\n+            delete ctx;\n+        }\n+        \/\/ else: ctx will be deleted in EventsCounterHelper after completing\n+        \/\/ an event processing\n+    }\n@@ -61,2 +65,13 @@\n-jobject WindowContextBase::get_jview() {\n-    return jview;\n+static bool gdk_visual_is_rgba(GdkVisual *visual) {\n+    if (!visual) return false;\n+\n+    int depth = gdk_visual_get_depth(visual);\n+    guint32 red_mask, green_mask, blue_mask;\n+    gdk_visual_get_red_pixel_details(visual, &red_mask, NULL, NULL);\n+    gdk_visual_get_green_pixel_details(visual, &green_mask, NULL, NULL);\n+    gdk_visual_get_blue_pixel_details(visual, &blue_mask, NULL, NULL);\n+\n+    return (depth == 32\n+            && red_mask == 0xff0000\n+            && green_mask == 0x00ff00\n+            && blue_mask == 0x0000ff);\n@@ -65,2 +80,3 @@\n-jobject WindowContextBase::get_jwindow() {\n-    return jwindow;\n+static gboolean is_window_floating(GdkWindowState state) {\n+    return !(state & GDK_WINDOW_STATE_MAXIMIZED)\n+        && !(state & GDK_WINDOW_STATE_FULLSCREEN);\n@@ -69,7 +85,15 @@\n-bool WindowContextBase::isEnabled() {\n-    if (jwindow) {\n-        bool result = (JNI_TRUE == mainEnv->CallBooleanMethod(jwindow, jWindowIsEnabled));\n-        LOG_EXCEPTION(mainEnv)\n-        return result;\n-    } else {\n-        return false;\n+static inline jint gdk_button_number_to_mouse_button(guint button) {\n+    switch (button) {\n+        case 1:\n+            return com_sun_glass_events_MouseEvent_BUTTON_LEFT;\n+        case 2:\n+            return com_sun_glass_events_MouseEvent_BUTTON_OTHER;\n+        case 3:\n+            return com_sun_glass_events_MouseEvent_BUTTON_RIGHT;\n+        case MOUSE_BACK_BTN:\n+            return com_sun_glass_events_MouseEvent_BUTTON_BACK;\n+        case MOUSE_FORWARD_BTN:\n+            return com_sun_glass_events_MouseEvent_BUTTON_FORWARD;\n+        default:\n+            \/\/ Other buttons are not supported by quantum and are not reported by other platforms\n+            return com_sun_glass_events_MouseEvent_BUTTON_NONE;\n@@ -79,5 +103,2 @@\n-void WindowContextBase::notify_state(jint glass_state) {\n-    if (glass_state == com_sun_glass_events_WindowEvent_RESTORE) {\n-        if (is_maximized) {\n-            glass_state = com_sun_glass_events_WindowEvent_MAXIMIZE;\n-        }\n+WindowContext * WindowContext::sm_grab_window = NULL;\n+WindowContext * WindowContext::sm_mouse_drag_window = NULL;\n@@ -85,8 +106,27 @@\n-        int w, h;\n-        glass_gdk_window_get_size(gdk_window, &w, &h);\n-        if (jview) {\n-            mainEnv->CallVoidMethod(jview,\n-                    jViewNotifyRepaint,\n-                    0, 0, w, h);\n-            CHECK_JNI_EXCEPTION(mainEnv);\n-        }\n+\/\/ Work-around because frame extents are only obtained after window is shown.\n+\/\/ This is used to know the total window size (content + decoration)\n+\/\/ The first window will have a duplicated resize event, subsequent windows will use the cached value.\n+std::optional<GdkRectangle> WindowContext::normal_extents;\n+std::optional<GdkRectangle> WindowContext::utility_extents;\n+\n+WindowContext::WindowContext(jobject _jwindow, WindowContext* _owner, long _screen,\n+        WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :\n+            screen(_screen),\n+            frame_type(_frame_type),\n+            window_type(type),\n+            owner(_owner),\n+            geometry(),\n+            resizable(),\n+            im_ctx() {\n+    jwindow = mainEnv->NewGlobalRef(_jwindow);\n+    initial_wmf = wmf;\n+    current_wmf = wmf;\n+    is_mouse_entered = false;\n+    is_disabled = false;\n+    on_top = false;\n+    can_be_deleted = false;\n+    mapped = false;\n+    initial_state_mask = 0;\n+\n+    if (frame_type != TITLED) {\n+        initial_wmf = GDK_FUNC_ALL;\n@@ -95,5 +135,16 @@\n-    if (jwindow) {\n-       mainEnv->CallVoidMethod(jwindow,\n-               jGtkWindowNotifyStateChanged,\n-               glass_state);\n-       CHECK_JNI_EXCEPTION(mainEnv);\n+    load_cached_extents();\n+    update_window_size();\n+\n+    int attr_mask = GDK_WA_VISUAL;\n+    GdkWindowAttr attributes;\n+    attributes.visual = find_best_visual();\n+    attributes.wclass = GDK_INPUT_OUTPUT;\n+    attributes.event_mask = GDK_FILTERED_EVENTS_MASK;\n+    attributes.width = DEFAULT_WIDTH;\n+    attributes.height = DEFAULT_HEIGHT;\n+    attributes.window_type = (window_type == POPUP) ? GDK_WINDOW_TEMP : GDK_WINDOW_TOPLEVEL;\n+\n+    if (gchar* app_name = get_application_name()) {\n+        attributes.wmclass_name = app_name;\n+        attributes.wmclass_class = app_name;\n+        attr_mask |= GDK_WA_WMCLASS;\n@@ -101,1 +152,0 @@\n-}\n@@ -103,2 +153,4 @@\n-void WindowContextBase::process_state(GdkEventWindowState* event) {\n-    if (event->changed_mask & (GDK_WINDOW_STATE_ICONIFIED | GDK_WINDOW_STATE_MAXIMIZED)) {\n+    if (window_type == UTILITY) {\n+        attributes.type_hint = GDK_WINDOW_TYPE_HINT_UTILITY;\n+        attr_mask |=  GDK_WA_TYPE_HINT;\n+    }\n@@ -106,3 +158,5 @@\n-        if (event->changed_mask & GDK_WINDOW_STATE_ICONIFIED) {\n-            is_iconified = event->new_window_state & GDK_WINDOW_STATE_ICONIFIED;\n-        }\n+    gdk_window = gdk_window_new(gdk_get_default_root_window(), &attributes, attr_mask);\n+\n+    if (frame_type == TITLED) {\n+        request_frame_extents();\n+    }\n@@ -110,2 +164,20 @@\n-        if (event->changed_mask & GDK_WINDOW_STATE_MAXIMIZED) {\n-            is_maximized = event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED;\n+    if (frame_type != TRANSPARENT) {\n+        GdkRGBA white = { 1.0, 1.0, 1.0, 1.0 };\n+        gdk_window_set_background_rgba(gdk_window, &white);\n+    }\n+\n+    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);\n+    gdk_window_register_dnd(gdk_window);\n+\n+    if (initial_wmf) {\n+        gdk_window_set_functions(gdk_window, initial_wmf);\n+    }\n+\n+    if (frame_type != TITLED) {\n+        gdk_window_set_decorations(gdk_window,  (GdkWMDecoration) 0);\n+    }\n+\n+    if (owner) {\n+        owner->add_child(this);\n+        if (on_top_inherited()) {\n+            gdk_window_set_keep_above(gdk_window, TRUE);\n@@ -113,0 +185,5 @@\n+    }\n+\n+    set_title(\"\");\n+    update_window_constraints();\n+}\n@@ -114,1 +191,6 @@\n-        jint stateChangeEvent;\n+GdkVisual* WindowContext::find_best_visual() {\n+    \/\/ This comes from prism-es2\n+    static glong xvisualID = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);\n+    static GdkVisual *prismVisual = (xvisualID != 0)\n+                ? gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID)\n+                : NULL;\n@@ -116,4 +198,4 @@\n-        if (is_iconified) {\n-            stateChangeEvent = com_sun_glass_events_WindowEvent_MINIMIZE;\n-        } else if (is_maximized) {\n-            stateChangeEvent = com_sun_glass_events_WindowEvent_MAXIMIZE;\n+    if (frame_type == TRANSPARENT && !gdk_visual_is_rgba(prismVisual)) {\n+        GdkVisual *rgbaVisual = gdk_screen_get_rgba_visual(gdk_screen_get_default());\n+        if (rgbaVisual) {\n+            return rgbaVisual;\n@@ -121,7 +203,1 @@\n-            stateChangeEvent = com_sun_glass_events_WindowEvent_RESTORE;\n-            if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0\n-                || (gdk_windowManagerFunctions & GDK_FUNC_MAXIMIZE) == 0) {\n-                \/\/ in this case - the window manager will not support the programatic\n-                \/\/ request to iconify \/ maximize - so we need to restore it now.\n-                gdk_window_set_functions(gdk_window, gdk_windowManagerFunctions);\n-            }\n+            glass_print_window_transparency_not_supported();\n@@ -129,0 +205,1 @@\n+    }\n@@ -130,3 +207,3 @@\n-        notify_state(stateChangeEvent);\n-    } else if (event->changed_mask & GDK_WINDOW_STATE_ABOVE) {\n-        notify_on_top(event->new_window_state & GDK_WINDOW_STATE_ABOVE);\n+    if (prismVisual != NULL) {\n+        LOG(\"Using prism visual\\n\");\n+        return prismVisual;\n@@ -134,0 +211,3 @@\n+\n+    LOG(\"Using GDK system visual\\n\");\n+    return gdk_screen_get_system_visual(gdk_screen_get_default());\n@@ -136,3 +216,32 @@\n-void WindowContextBase::process_focus(GdkEventFocus* event) {\n-    if (!event->in && WindowContextBase::sm_grab_window == this) {\n-        ungrab_focus();\n+GdkWindow* WindowContext::get_gdk_window() {\n+    if (GDK_IS_WINDOW(gdk_window)) {\n+        return gdk_window;\n+    }\n+\n+    return NULL;\n+}\n+\n+\/\/ Returns de XWindow ID to be used in rendering\n+XID WindowContext::get_native_window() {\n+    \/\/ This is used to delay the window map (it's only really mapped when there's\n+    \/\/ something rendered)\n+    if (!is_visible()) return 0;\n+\n+    return GDK_WINDOW_XID(gdk_window);\n+}\n+\n+jobject WindowContext::get_jview() {\n+    return jview;\n+}\n+\n+jobject WindowContext::get_jwindow() {\n+    return jwindow;\n+}\n+\n+bool WindowContext::isEnabled() {\n+    if (jwindow) {\n+        bool result = (JNI_TRUE == mainEnv->CallBooleanMethod(jwindow, jWindowIsEnabled));\n+        LOG_EXCEPTION(mainEnv)\n+        return result;\n+    } else {\n+        return false;\n@@ -140,0 +249,16 @@\n+}\n+\n+void WindowContext::process_map() {\n+    \/\/ We need only first map\n+    if (mapped || window_type == POPUP) return;\n+\n+    LOG(\"--------------------------------------------------------> mapped\\n\");\n+    move_resize(geometry.x, geometry.y, true, true, geometry.width.view, geometry.height.view);\n+    mapped = true;\n+\n+    gdk_window_set_startup_id(gdk_window, NULL);\n+\n+    if (initial_state_mask != 0) {\n+        update_initial_state();\n+    }\n+}\n@@ -141,0 +266,2 @@\n+void WindowContext::process_focus(GdkEventFocus *event) {\n+    LOG(\"process_focus (keyboard): %d\\n\", event->in);\n@@ -148,0 +275,7 @@\n+}\n+\n+void WindowContext::process_focus(bool focus_in) {\n+    LOG(\"process_focus (state): %d\\n\", focus_in);\n+    if (focus_in && WindowContext::sm_grab_window == this) {\n+        ungrab_focus();\n+    }\n@@ -150,6 +284,1 @@\n-        if (!event->in || isEnabled()) {\n-            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus,\n-                    event->in ? com_sun_glass_events_WindowEvent_FOCUS_GAINED\n-                              : com_sun_glass_events_WindowEvent_FOCUS_LOST);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        } else {\n+        if (focus_in && !isEnabled()) {\n@@ -157,0 +286,1 @@\n+            LOG(\"jWindowNotifyFocusDisabled\");\n@@ -159,0 +289,8 @@\n+        } else {\n+            LOG(\"%s\\n\", (focus_in) ? \"com_sun_glass_events_WindowEvent_FOCUS_GAINED\"\n+                                  : \"com_sun_glass_events_WindowEvent_FOCUS_LOST\");\n+\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus,\n+                    focus_in ? com_sun_glass_events_WindowEvent_FOCUS_GAINED\n+                             : com_sun_glass_events_WindowEvent_FOCUS_LOST);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n@@ -163,1 +301,1 @@\n-void WindowContextBase::increment_events_counter() {\n+void WindowContext::increment_events_counter() {\n@@ -167,1 +305,1 @@\n-void WindowContextBase::decrement_events_counter() {\n+void WindowContext::decrement_events_counter() {\n@@ -171,1 +309,1 @@\n-size_t WindowContextBase::get_events_count() {\n+size_t WindowContext::get_events_count() {\n@@ -175,1 +313,1 @@\n-bool WindowContextBase::is_dead() {\n+bool WindowContext::is_dead() {\n@@ -179,3 +317,2 @@\n-void destroy_and_delete_ctx(WindowContext* ctx) {\n-    if (ctx) {\n-        ctx->process_destroy();\n+void WindowContext::process_destroy() {\n+    LOG(\"process_destroy\\n\");\n@@ -183,5 +320,2 @@\n-        if (!ctx->get_events_count()) {\n-            delete ctx;\n-        }\n-        \/\/ else: ctx will be deleted in EventsCounterHelper after completing\n-        \/\/ an event processing\n+    if (owner) {\n+        owner->remove_child(this);\n@@ -189,1 +323,0 @@\n-}\n@@ -191,2 +324,1 @@\n-void WindowContextBase::process_destroy() {\n-    if (WindowContextBase::sm_mouse_drag_window == this) {\n+    if (WindowContext::sm_mouse_drag_window == this) {\n@@ -196,1 +328,1 @@\n-    if (WindowContextBase::sm_grab_window == this) {\n+    if (WindowContext::sm_grab_window == this) {\n@@ -200,1 +332,1 @@\n-    std::set<WindowContextTop*>::iterator it;\n+    std::set<WindowContext*>::iterator it;\n@@ -202,5 +334,0 @@\n-        \/\/ FIX JDK-8226537: this method calls set_owner(NULL) which prevents\n-        \/\/ WindowContextTop::process_destroy() to call remove_child() (because children\n-        \/\/ is being iterated here) but also prevents gtk_window_set_transient_for from\n-        \/\/ being called - this causes the crash on gnome.\n-        gtk_window_set_transient_for((*it)->get_gtk_window(), NULL);\n@@ -230,1 +357,2 @@\n-void WindowContextBase::process_delete() {\n+void WindowContext::process_delete() {\n+    LOG(\"process_delete\\n\");\n@@ -232,0 +360,1 @@\n+        LOG(\"jWindowNotifyClose\\n\");\n@@ -237,1 +366,1 @@\n-void WindowContextBase::process_expose(GdkEventExpose* event) {\n+void WindowContext::notify_repaint() {\n@@ -239,1 +368,2 @@\n-        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, event->area.x, event->area.y, event->area.width, event->area.height);\n+        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, 0, 0,\n+                            geometry.width.view, geometry.height.view);\n@@ -244,15 +374,4 @@\n-static inline jint gtk_button_number_to_mouse_button(guint button) {\n-    switch (button) {\n-        case 1:\n-            return com_sun_glass_events_MouseEvent_BUTTON_LEFT;\n-        case 2:\n-            return com_sun_glass_events_MouseEvent_BUTTON_OTHER;\n-        case 3:\n-            return com_sun_glass_events_MouseEvent_BUTTON_RIGHT;\n-        case MOUSE_BACK_BTN:\n-            return com_sun_glass_events_MouseEvent_BUTTON_BACK;\n-        case MOUSE_FORWARD_BTN:\n-            return com_sun_glass_events_MouseEvent_BUTTON_FORWARD;\n-        default:\n-            \/\/ Other buttons are not supported by quantum and are not reported by other platforms\n-            return com_sun_glass_events_MouseEvent_BUTTON_NONE;\n+void WindowContext::notify_repaint(GdkRectangle *rect) {\n+    if (jview) {\n+        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, rect->x, rect->y, rect->width, rect->height);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n@@ -262,1 +381,1 @@\n-void WindowContextBase::process_mouse_button(GdkEventButton* event) {\n+void WindowContext::process_mouse_button(GdkEventButton *event) {\n@@ -317,1 +436,1 @@\n-    jint button = gtk_button_number_to_mouse_button(event->button);\n+    jint button = gdk_button_number_to_mouse_button(event->button);\n@@ -340,1 +459,1 @@\n-void WindowContextBase::process_mouse_motion(GdkEventMotion* event) {\n+void WindowContext::process_mouse_motion(GdkEventMotion *event) {\n@@ -350,1 +469,1 @@\n-    if (isDrag && WindowContextBase::sm_mouse_drag_window == NULL) {\n+    if (isDrag && WindowContext::sm_mouse_drag_window == NULL) {\n@@ -383,1 +502,1 @@\n-void WindowContextBase::process_mouse_scroll(GdkEventScroll* event) {\n+void WindowContext::process_mouse_scroll(GdkEventScroll *event) {\n@@ -423,1 +542,0 @@\n-\n@@ -426,1 +544,1 @@\n-void WindowContextBase::process_mouse_cross(GdkEventCrossing* event) {\n+void WindowContext::process_mouse_cross(GdkEventCrossing *event) {\n@@ -449,1 +567,1 @@\n-void WindowContextBase::process_key(GdkEventKey* event) {\n+void WindowContext::process_key(GdkEventKey *event) {\n@@ -486,0 +604,1 @@\n+    \/\/ TYPED events should only be sent for printable characters.\n@@ -487,1 +606,1 @@\n-    if (press && key > 0 && jview) { \/\/ TYPED events should only be sent for printable characters.\n+    if (press && key > 0 && jview) {\n@@ -497,2 +616,1 @@\n-void WindowContextBase::paint(void* data, jint width, jint height) {\n-#ifdef GLASS_GTK3\n+void WindowContext::paint(void* data, jint width, jint height) {\n@@ -502,1 +620,1 @@\n-#endif\n+\n@@ -511,2 +629,0 @@\n-    applyShapeMask(data, width, height);\n-\n@@ -517,1 +633,0 @@\n-#ifdef GLASS_GTK3\n@@ -520,1 +635,0 @@\n-#endif\n@@ -526,1 +640,1 @@\n-void WindowContextBase::add_child(WindowContextTop* child) {\n+void WindowContext::add_child(WindowContext* child) {\n@@ -528,1 +642,1 @@\n-    gtk_window_set_transient_for(child->get_gtk_window(), this->get_gtk_window());\n+    gdk_window_set_transient_for(child->get_gdk_window(), gdk_window);\n@@ -531,1 +645,1 @@\n-void WindowContextBase::remove_child(WindowContextTop* child) {\n+void WindowContext::remove_child(WindowContext* child) {\n@@ -533,21 +647,0 @@\n-    gtk_window_set_transient_for(child->get_gtk_window(), NULL);\n-}\n-\n-void WindowContextBase::set_visible(bool visible) {\n-    if (visible) {\n-        gtk_widget_show(gtk_widget);\n-    } else {\n-        gtk_widget_hide(gtk_widget);\n-        if (jview && is_mouse_entered) {\n-            is_mouse_entered = false;\n-            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n-                    com_sun_glass_events_MouseEvent_EXIT,\n-                    com_sun_glass_events_MouseEvent_BUTTON_NONE,\n-                    0, 0,\n-                    0, 0,\n-                    0,\n-                    JNI_FALSE,\n-                    JNI_FALSE);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n-    }\n@@ -556,2 +649,2 @@\n-bool WindowContextBase::is_visible() {\n-    return gtk_widget_get_visible(gtk_widget);\n+bool WindowContext::is_visible() {\n+    return gdk_window_is_visible(gdk_window);\n@@ -560,1 +653,1 @@\n-bool WindowContextBase::set_view(jobject view) {\n+bool WindowContext::set_view(jobject view) {\n@@ -581,1 +674,2 @@\n-bool WindowContextBase::grab_mouse_drag_focus() {\n+bool WindowContext::grab_mouse_drag_focus() {\n+    LOG(\"grab_mouse_drag_focus\\n\");\n@@ -584,1 +678,1 @@\n-        WindowContextBase::sm_mouse_drag_window = this;\n+        WindowContext::sm_mouse_drag_window = this;\n@@ -591,2 +685,7 @@\n-void WindowContextBase::ungrab_mouse_drag_focus() {\n-    WindowContextBase::sm_mouse_drag_window = NULL;\n+void WindowContext::ungrab_mouse_drag_focus() {\n+    if (!WindowContext::sm_mouse_drag_window) {\n+        return;\n+    }\n+\n+    LOG(\"ungrab_mouse_drag_focus\\n\");\n+    WindowContext::sm_mouse_drag_window = NULL;\n@@ -594,2 +693,2 @@\n-    if (WindowContextBase::sm_grab_window) {\n-        WindowContextBase::sm_grab_window->grab_focus();\n+    if (WindowContext::sm_grab_window) {\n+        WindowContext::sm_grab_window->grab_focus();\n@@ -599,2 +698,3 @@\n-bool WindowContextBase::grab_focus() {\n-    if (WindowContextBase::sm_mouse_drag_window\n+bool WindowContext::grab_focus() {\n+    LOG(\"grab_focus\\n\");\n+    if (WindowContext::sm_mouse_drag_window\n@@ -602,1 +702,1 @@\n-        WindowContextBase::sm_grab_window = this;\n+        WindowContext::sm_grab_window = this;\n@@ -609,2 +709,3 @@\n-void WindowContextBase::ungrab_focus() {\n-    if (!WindowContextBase::sm_mouse_drag_window) {\n+void WindowContext::ungrab_focus() {\n+    LOG(\"ungrab_focus\\n\");\n+    if (!WindowContext::sm_mouse_drag_window) {\n@@ -613,1 +714,2 @@\n-    WindowContextBase::sm_grab_window = NULL;\n+\n+    WindowContext::sm_grab_window = NULL;\n@@ -621,1 +723,1 @@\n-void WindowContextBase::set_cursor(GdkCursor* cursor) {\n+void WindowContext::set_cursor(GdkCursor* cursor) {\n@@ -623,1 +725,1 @@\n-        if (WindowContextBase::sm_mouse_drag_window) {\n+        if (WindowContext::sm_mouse_drag_window) {\n@@ -625,2 +727,2 @@\n-                    WindowContextBase::sm_mouse_drag_window->get_gdk_window(), cursor, FALSE);\n-        } else if (WindowContextBase::sm_grab_window) {\n+                    WindowContext::sm_mouse_drag_window->get_gdk_window(), cursor, FALSE);\n+        } else if (WindowContext::sm_grab_window) {\n@@ -628,1 +730,1 @@\n-                    WindowContextBase::sm_grab_window->get_gdk_window(), cursor, TRUE);\n+                    WindowContext::sm_grab_window->get_gdk_window(), cursor, TRUE);\n@@ -634,3 +736,3 @@\n-void WindowContextBase::set_background(float r, float g, float b) {\n-    GdkRGBA rgba = {r, g, b, 1.};\n-    gtk_widget_override_background_color(gtk_widget, GTK_STATE_FLAG_NORMAL, &rgba);\n+void WindowContext::set_background(float r, float g, float b) {\n+    GdkRGBA rgba = {r, g, b, 1.0};\n+    gdk_window_set_background_rgba(gdk_window, &rgba);\n@@ -639,3 +741,6 @@\n-WindowContextBase::~WindowContextBase() {\n-    disableIME();\n-    gtk_widget_destroy(gtk_widget);\n+GdkAtom WindowContext::get_net_frame_extents_atom() {\n+    static GdkAtom atom = NULL;\n+    if (atom == NULL) {\n+        atom = gdk_atom_intern_static_string(\"_NET_FRAME_EXTENTS\");\n+    }\n+    return atom;\n@@ -644,2 +749,3 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ WindowContextTop \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n+void WindowContext::request_frame_extents() {\n+    Display *display = GDK_DISPLAY_XDISPLAY(gdk_window_get_display(gdk_window));\n+    static Atom rfeAtom = XInternAtom(display, \"_NET_REQUEST_FRAME_EXTENTS\", False);\n@@ -647,5 +753,3 @@\n-\/\/ Work-around because frame extents are only obtained after window is shown.\n-\/\/ This is used to know the total window size (content + decoration)\n-\/\/ The first window will have a duplicated resize event, subsequent windows will use the cached value.\n-WindowFrameExtents WindowContextTop::normal_extents = {0, 0, 0, 0};\n-WindowFrameExtents WindowContextTop::utility_extents = {0, 0, 0, 0};\n+    if (rfeAtom != None) {\n+        XClientMessageEvent clientMessage;\n+        memset(&clientMessage, 0, sizeof(clientMessage));\n@@ -653,0 +757,4 @@\n+        clientMessage.type = ClientMessage;\n+        clientMessage.window = GDK_WINDOW_XID(gdk_window);\n+        clientMessage.message_type = rfeAtom;\n+        clientMessage.format = 32;\n@@ -654,3 +762,5 @@\n-static void event_realize(GtkWidget* self, gpointer user_data) {\n-    WindowContextTop *ctx = ((WindowContextTop *) user_data);\n-    ctx->process_realize();\n+        XSendEvent(display, XDefaultRootWindow(display), False,\n+                   SubstructureRedirectMask | SubstructureNotifyMask,\n+                   (XEvent *) &clientMessage);\n+        XFlush(display);\n+    }\n@@ -659,7 +769,0 @@\n-static int geometry_get_window_width(const WindowGeometry *windowGeometry) {\n-     return (windowGeometry->final_width.type == BOUNDSTYPE_WINDOW)\n-                   ? windowGeometry->final_width.value\n-                   : windowGeometry->final_width.value\n-                         + windowGeometry->extents.left\n-                         + windowGeometry->extents.right;\n-}\n@@ -667,7 +770,2 @@\n-static int geometry_get_window_height(const WindowGeometry *windowGeometry) {\n-    return (windowGeometry->final_height.type == BOUNDSTYPE_WINDOW)\n-                   ? windowGeometry->final_height.value\n-                   : windowGeometry->final_height.value\n-                         + windowGeometry->extents.top\n-                         + windowGeometry->extents.bottom;\n-}\n+void WindowContext::update_initial_state() {\n+    GdkWindowState state = gdk_window_get_state(gdk_window);\n@@ -675,7 +773,4 @@\n-static int geometry_get_content_width(WindowGeometry *windowGeometry) {\n-    return (windowGeometry->final_width.type == BOUNDSTYPE_CONTENT)\n-                   ? windowGeometry->final_width.value\n-                   : windowGeometry->final_width.value\n-                         - windowGeometry->extents.left\n-                         - windowGeometry->extents.right;\n-}\n+    if (initial_state_mask & GDK_WINDOW_STATE_MAXIMIZED) {\n+        LOG(\"update_initial_state: maximized\\n\");\n+        maximize(true);\n+    }\n@@ -683,7 +778,4 @@\n-static int geometry_get_content_height(WindowGeometry *windowGeometry) {\n-    return (windowGeometry->final_height.type == BOUNDSTYPE_CONTENT)\n-                   ? windowGeometry->final_height.value\n-                   : windowGeometry->final_height.value\n-                         - windowGeometry->extents.top\n-                         - windowGeometry->extents.bottom;\n-}\n+    if (initial_state_mask & GDK_WINDOW_STATE_FULLSCREEN) {\n+        LOG(\"update_initial_state: fullscreen\\n\");\n+        enter_fullscreen();\n+    }\n@@ -691,3 +783,6 @@\n-static GdkAtom get_net_frame_extents_atom() {\n-    static const char * extents_str = \"_NET_FRAME_EXTENTS\";\n-    return gdk_atom_intern(extents_str, FALSE);\n+    if (initial_state_mask & GDK_WINDOW_STATE_ICONIFIED) {\n+        LOG(\"update_initial_state: iconify\\n\");\n+        iconify(true);\n+    }\n+\n+    initial_state_mask = 0;\n@@ -696,13 +791,2 @@\n-WindowContextTop::WindowContextTop(jobject _jwindow, WindowContext* _owner, long _screen,\n-        WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :\n-            WindowContextBase(),\n-            screen(_screen),\n-            frame_type(_frame_type),\n-            window_type(type),\n-            owner(_owner),\n-            geometry(),\n-            resizable(),\n-            on_top(false),\n-            is_fullscreen(false) {\n-    jwindow = mainEnv->NewGlobalRef(_jwindow);\n-    gdk_windowManagerFunctions = wmf;\n+void WindowContext::update_frame_extents() {\n+    if (frame_type != TITLED) return;\n@@ -710,2 +794,1 @@\n-    gtk_widget = gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);\n-    g_signal_connect(G_OBJECT(gtk_widget), \"realize\", G_CALLBACK(event_realize), this);\n+    int top, left, bottom, right;\n@@ -713,4 +796,6 @@\n-    if (gchar* app_name = get_application_name()) {\n-        gtk_window_set_wmclass(GTK_WINDOW(gtk_widget), app_name, app_name);\n-        g_free(app_name);\n-    }\n+    if (get_frame_extents_property(&top, &left, &bottom, &right)) {\n+        if (top > 0 || right > 0 || bottom > 0 || left > 0) {\n+            bool changed = geometry.extents.x != left\n+                        || geometry.extents.y != top\n+                        || geometry.extents.width != (left + right)\n+                        || geometry.extents.height != (top + bottom);\n@@ -718,6 +803,1 @@\n-    if (owner) {\n-        owner->add_child(this);\n-        if (on_top_inherited()) {\n-            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);\n-        }\n-    }\n+            LOG(\" ------------------------------------------- frame extents - changed: %d\\n\", changed);\n@@ -725,3 +805,1 @@\n-    if (type == UTILITY) {\n-        gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_UTILITY);\n-    }\n+            if (!changed) return;\n@@ -729,2 +807,2 @@\n-    const char* wm_name = gdk_x11_screen_get_window_manager_name(gdk_screen_get_default());\n-    wmanager = (g_strcmp0(\"Compiz\", wm_name) == 0) ? COMPIZ : UNKNOWN;\n+            GdkRectangle rect = { left, top, (left + right), (top + bottom) };\n+            set_cached_extents(rect);\n@@ -732,3 +810,2 @@\n-\/\/    glong xdisplay = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationDisplay);\n-\/\/    gint  xscreenID = (gint)mainEnv->GetStaticIntField(jApplicationCls, jApplicationScreen);\n-    glong xvisualID = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);\n+            int newW = geometry.width.view;\n+            int newH = geometry.height.view;\n@@ -736,4 +813,2 @@\n-    if (xvisualID != 0) {\n-        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);\n-        glass_gtk_window_configure_from_visual(gtk_widget, visual);\n-    }\n+            \/\/ Here the user might change the desktop theme and in consequence\n+            \/\/ change decoration sizes.\n@@ -741,2 +816,6 @@\n-    gtk_widget_set_events(gtk_widget, GDK_FILTERED_EVENTS_MASK);\n-    gtk_widget_set_app_paintable(gtk_widget, TRUE);\n+            if (geometry.width.type == BOUNDSTYPE_WINDOW) {\n+                \/\/ Re-add the extents and then subtract the new\n+                newW = newW\n+                    + ((geometry.frame_extents_received) ? geometry.extents.width : 0)\n+                    - rect.width;\n+            }\n@@ -744,2 +823,6 @@\n-    glass_configure_window_transparency(gtk_widget, frame_type == TRANSPARENT);\n-    gtk_window_set_title(GTK_WINDOW(gtk_widget), \"\");\n+            if (geometry.height.type == BOUNDSTYPE_WINDOW) {\n+                \/\/ Re-add the extents and then subtract the new\n+                newH = newH\n+                    + ((geometry.frame_extents_received) ? geometry.extents.height : 0)\n+                    - rect.height;\n+            }\n@@ -747,6 +830,2 @@\n-    if (frame_type != TITLED) {\n-        gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);\n-    } else {\n-        geometry.extents = get_cached_extents();\n-    }\n-}\n+            newW = NONNEGATIVE_OR(newW, 1);\n+            newH = NONNEGATIVE_OR(newH, 1);\n@@ -754,11 +833,3 @@\n-\/\/ Applied to a temporary full screen window to prevent sending events to Java\n-void WindowContextTop::detach_from_java() {\n-    if (jview) {\n-        mainEnv->DeleteGlobalRef(jview);\n-        jview = NULL;\n-    }\n-    if (jwindow) {\n-        mainEnv->DeleteGlobalRef(jwindow);\n-        jwindow = NULL;\n-    }\n-}\n+            LOG(\"extents received -> new view size: %d, %d\\n\", newW, newH);\n+            int x = geometry.x;\n+            int y = geometry.y;\n@@ -766,3 +837,6 @@\n-void WindowContextTop::request_frame_extents() {\n-    Display *display = GDK_DISPLAY_XDISPLAY(gdk_window_get_display(gdk_window));\n-    static Atom rfeAtom = XInternAtom(display, \"_NET_REQUEST_FRAME_EXTENTS\", False);\n+            \/\/ Gravity x, y are used in centerOnScreen(). Here it's used to adjust the position\n+            \/\/ accounting decorations\n+            if (geometry.gravity_x > 0 && x > 0) {\n+                x -= geometry.gravity_x * (float) (geometry.extents.width);\n+                x = NONNEGATIVE_OR(x, 0);\n+            }\n@@ -770,3 +844,4 @@\n-    if (rfeAtom != None) {\n-        XClientMessageEvent clientMessage;\n-        memset(&clientMessage, 0, sizeof(clientMessage));\n+            if (geometry.gravity_y > 0 && y > 0) {\n+                y -= geometry.gravity_y  * (float) (geometry.extents.height);\n+                y = NONNEGATIVE_OR(y, 0);\n+            }\n@@ -774,4 +849,7 @@\n-        clientMessage.type = ClientMessage;\n-        clientMessage.window = GDK_WINDOW_XID(gdk_window);\n-        clientMessage.message_type = rfeAtom;\n-        clientMessage.format = 32;\n+            geometry.extents = rect;\n+            geometry.frame_extents_received = true;\n+            geometry.width.view = newW;\n+            geometry.height.view = newH;\n+            geometry.x = x;\n+            geometry.y = y;\n+            update_window_size();\n@@ -779,6 +857,2 @@\n-        XSendEvent(display, XDefaultRootWindow(display), False,\n-                   SubstructureRedirectMask | SubstructureNotifyMask,\n-                   (XEvent *) &clientMessage);\n-        XFlush(display);\n-    }\n-}\n+            LOG(\"Geometry after frame extents: x,y: %d,%d \/ cw,ch: %d,%d \/ ww,wh: %d,%d\\n\", geometry.x, geometry.y,\n+                    geometry.width.view, geometry.height.view, geometry.width.window, geometry.height.window);\n@@ -786,2 +860,1 @@\n-void WindowContextTop::update_frame_extents() {\n-    int top, left, bottom, right;\n+            update_window_constraints();\n@@ -789,35 +862,3 @@\n-    if (get_frame_extents_property(&top, &left, &bottom, &right)) {\n-        if (top > 0 || right > 0 || bottom > 0 || left > 0) {\n-            bool changed = geometry.extents.top != top\n-                            || geometry.extents.left != left\n-                            || geometry.extents.bottom != bottom\n-                            || geometry.extents.right != right;\n-\n-            if (changed) {\n-                geometry.extents.top = top;\n-                geometry.extents.left = left;\n-                geometry.extents.bottom = bottom;\n-                geometry.extents.right = right;\n-\n-                set_cached_extents(geometry.extents);\n-\n-                \/\/ set bounds again to correct window size\n-                \/\/ accounting decorations\n-                int w = geometry_get_window_width(&geometry);\n-                int h = geometry_get_window_height(&geometry);\n-                int cw = geometry_get_content_width(&geometry);\n-                int ch = geometry_get_content_height(&geometry);\n-\n-                int x = geometry.x;\n-                int y = geometry.y;\n-\n-                if (geometry.gravity_x != 0) {\n-                    x -= geometry.gravity_x * (float) (left + right);\n-                }\n-\n-                if (geometry.gravity_y != 0) {\n-                    y -= geometry.gravity_y * (float) (top + bottom);\n-                }\n-\n-                set_bounds(x, y, true, true, w, h, cw, ch, 0, 0);\n-           }\n+            if (is_window_floating(gdk_window_get_state(gdk_window))) {\n+                move_resize(x, y, true, true, newW, newH);\n+            }\n@@ -828,13 +869,1 @@\n-void WindowContextTop::set_cached_extents(WindowFrameExtents ex) {\n-    if (window_type == NORMAL) {\n-        normal_extents = ex;\n-    } else {\n-        utility_extents = ex;\n-    }\n-}\n-\n-WindowFrameExtents WindowContextTop::get_cached_extents() {\n-    return window_type == NORMAL ? normal_extents : utility_extents;\n-}\n-\n-bool WindowContextTop::get_frame_extents_property(int *top, int *left,\n+bool WindowContext::get_frame_extents_property(int *top, int *left,\n@@ -866,3 +895,16 @@\n-void WindowContextTop::work_around_compiz_state() {\n-    \/\/ Workaround for https:\/\/bugs.launchpad.net\/unity\/+bug\/998073\n-    if (wmanager != COMPIZ) {\n+void WindowContext::set_cached_extents(GdkRectangle ex) {\n+    if (window_type == UTILITY) {\n+        utility_extents = ex;\n+    } else {\n+        normal_extents = ex;\n+    }\n+}\n+\n+void WindowContext::load_cached_extents() {\n+    if (frame_type != TITLED) return;\n+\n+    if (window_type == NORMAL && normal_extents.has_value()) {\n+        geometry.extents = normal_extents.value();\n+        LOG(\"Loaded Normal Extents: x = %d, y = %d, width = %d, height = %d\\n\",\n+                    geometry.extents.x, geometry.extents.y, geometry.extents.width, geometry.extents.height);\n+        geometry.frame_extents_received = true;\n@@ -872,4 +914,7 @@\n-    static GdkAtom atom_atom = gdk_atom_intern_static_string(\"ATOM\");\n-    static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string(\"_NET_WM_STATE\");\n-    static GdkAtom atom_net_wm_state_hidden = gdk_atom_intern_static_string(\"_NET_WM_STATE_HIDDEN\");\n-    static GdkAtom atom_net_wm_state_above = gdk_atom_intern_static_string(\"_NET_WM_STATE_ABOVE\");\n+    if (window_type == UTILITY && utility_extents.has_value()) {\n+        geometry.extents = utility_extents.value();\n+        LOG(\"Loaded Utility Extents: x = %d, y = %d, width = %d, height = %d\\n\",\n+                    geometry.extents.x, geometry.extents.y, geometry.extents.width, geometry.extents.height);\n+        geometry.frame_extents_received = true;\n+    }\n+}\n@@ -877,1 +922,5 @@\n-    gint length;\n+void WindowContext::process_property_notify(GdkEventProperty *event) {\n+    if (event->atom == get_net_frame_extents_atom()) {\n+        update_frame_extents();\n+    }\n+}\n@@ -879,1 +928,8 @@\n-    glong* atoms = NULL;\n+void WindowContext::process_state(GdkEventWindowState *event) {\n+    if (!(event->changed_mask & (GDK_WINDOW_STATE_ICONIFIED\n+                                | GDK_WINDOW_STATE_MAXIMIZED\n+                                | GDK_WINDOW_STATE_FULLSCREEN\n+                                | GDK_WINDOW_STATE_ABOVE\n+                                | GDK_WINDOW_STATE_FOCUSED))) {\n+        return;\n+    }\n@@ -881,2 +937,1 @@\n-    if (gdk_property_get(gdk_window, atom_net_wm_state, atom_atom,\n-            0, G_MAXLONG, FALSE, NULL, NULL, &length, (guchar**) &atoms)) {\n+    LOG(\"process_state\\n\");\n@@ -884,9 +939,2 @@\n-        bool is_hidden = false;\n-        bool is_above = false;\n-        for (gint i = 0; i < (gint)(length \/ sizeof(glong)); i++) {\n-            if (atom_net_wm_state_hidden == (GdkAtom)atoms[i]) {\n-                is_hidden = true;\n-            } else if (atom_net_wm_state_above == (GdkAtom)atoms[i]) {\n-                is_above = true;\n-            }\n-        }\n+    if (event->changed_mask & GDK_WINDOW_STATE_FOCUSED) {\n+        process_focus(event->new_window_state & GDK_WINDOW_STATE_FOCUSED);\n@@ -894,1 +942,2 @@\n-        g_free(atoms);\n+        if (event->new_window_state == GDK_WINDOW_STATE_FOCUSED) return;\n+    }\n@@ -896,2 +945,2 @@\n-        if (is_iconified != is_hidden) {\n-            is_iconified = is_hidden;\n+    if (event->changed_mask & GDK_WINDOW_STATE_ABOVE) {\n+        notify_on_top(event->new_window_state & GDK_WINDOW_STATE_ABOVE);\n@@ -899,4 +948,3 @@\n-            notify_state((is_hidden)\n-                    ? com_sun_glass_events_WindowEvent_MINIMIZE\n-                    : com_sun_glass_events_WindowEvent_RESTORE);\n-        }\n+        \/\/ Only state mask\n+        if (event->new_window_state == GDK_WINDOW_STATE_ABOVE) return;\n+    }\n@@ -904,1 +952,10 @@\n-        notify_on_top(is_above);\n+    if ((event->changed_mask & (GDK_WINDOW_STATE_MAXIMIZED | GDK_WINDOW_STATE_ICONIFIED))\n+        && ((event->new_window_state & (GDK_WINDOW_STATE_MAXIMIZED | GDK_WINDOW_STATE_ICONIFIED)) == 0)) {\n+        LOG(\"com_sun_glass_events_WindowEvent_RESTORE\\n\");\n+        notify_window_resize(com_sun_glass_events_WindowEvent_RESTORE);\n+    } else if (event->new_window_state & (GDK_WINDOW_STATE_ICONIFIED)) {\n+        LOG(\"com_sun_glass_events_WindowEvent_MINIMIZE\\n\");\n+        notify_window_resize(com_sun_glass_events_WindowEvent_MINIMIZE);\n+    } else if (event->new_window_state & (GDK_WINDOW_STATE_MAXIMIZED)) {\n+        LOG(\"com_sun_glass_events_WindowEvent_MAXIMIZE\\n\");\n+        notify_window_resize(com_sun_glass_events_WindowEvent_MAXIMIZE);\n@@ -906,1 +963,0 @@\n-}\n@@ -908,2 +964,3 @@\n-void WindowContextTop::process_property_notify(GdkEventProperty* event) {\n-    static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string(\"_NET_WM_STATE\");\n+    if (event->changed_mask & GDK_WINDOW_STATE_ICONIFIED\n+        && (event->new_window_state & GDK_WINDOW_STATE_ICONIFIED) == 0) {\n+        remove_wmf(GDK_FUNC_MINIMIZE);\n@@ -911,6 +968,2 @@\n-    if (event->window == gdk_window) {\n-        if (event->atom == get_net_frame_extents_atom()) {\n-            update_frame_extents();\n-        } else if (event->atom == atom_net_wm_state) {\n-            work_around_compiz_state();\n-        }\n+        \/\/FIXME: remove when 8351867 is fixed\n+        notify_repaint();\n@@ -918,1 +971,0 @@\n-}\n@@ -920,4 +972,2 @@\n-void WindowContextTop::process_state(GdkEventWindowState* event) {\n-    if (event->changed_mask & GDK_WINDOW_STATE_FULLSCREEN) {\n-        is_fullscreen = event->new_window_state & GDK_WINDOW_STATE_FULLSCREEN;\n-    }\n+    \/\/ If only iconified, no further processing\n+    if (event->new_window_state == GDK_WINDOW_STATE_ICONIFIED) return;\n@@ -926,3 +976,14 @@\n-        && !(event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED)) {\n-        gtk_window_resize(GTK_WINDOW(gtk_widget), geometry_get_content_width(&geometry),\n-                                    geometry_get_content_height(&geometry));\n+        && (event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) == 0) {\n+        remove_wmf(GDK_FUNC_MAXIMIZE);\n+    }\n+\n+    if (jview && event->changed_mask & GDK_WINDOW_STATE_FULLSCREEN) {\n+        if (event->new_window_state & GDK_WINDOW_STATE_FULLSCREEN) {\n+            LOG(\"com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER\\n\");\n+            mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        } else {\n+            LOG(\"com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT\\n\");\n+            mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n@@ -931,1 +992,4 @@\n-    WindowContextBase::process_state(event);\n+    notify_view_resize();\n+    \/\/ Since FullScreen (or custom modes of maximized) can undecorate the\n+    \/\/ window, request view position change\n+    notify_view_move();\n@@ -934,4 +998,7 @@\n-void WindowContextTop::process_realize() {\n-    gdk_window = gtk_widget_get_window(gtk_widget);\n-    if (frame_type == TITLED) {\n-        request_frame_extents();\n+void WindowContext::notify_window_resize(int state) {\n+    if (jwindow) {\n+        LOG(\"jWindowNotifyResize: %d -> %d, %d\\n\", state,\n+                    geometry.width.window, geometry.height.window);\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize, state,\n+                    geometry.width.window, geometry.height.window);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n@@ -939,0 +1006,1 @@\n+}\n@@ -940,3 +1008,7 @@\n-    gdk_window_set_events(gdk_window, GDK_FILTERED_EVENTS_MASK);\n-    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);\n-    gdk_window_register_dnd(gdk_window);\n+void WindowContext::notify_window_move() {\n+    if (jwindow) {\n+        LOG(\"jWindowNotifyMove: %d, %d\\n\", geometry.x, geometry.y);\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove, geometry.x, geometry.y);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+}\n@@ -944,2 +1016,5 @@\n-    if (gdk_windowManagerFunctions) {\n-        gdk_window_set_functions(gdk_window, gdk_windowManagerFunctions);\n+void WindowContext::notify_view_resize() {\n+    if (jview) {\n+        LOG(\"jViewNotifyResize: %d, %d\\n\", geometry.width.view, geometry.height.view);\n+        mainEnv->CallVoidMethod(jview, jViewNotifyResize, geometry.width.view, geometry.height.view);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n@@ -949,3 +1024,2 @@\n-void WindowContextTop::process_configure(GdkEventConfigure* event) {\n-    int ww = event->width + geometry.extents.left + geometry.extents.right;\n-    int wh = event->height + geometry.extents.top + geometry.extents.bottom;\n+void WindowContext::notify_current_sizes() {\n+    GdkWindowState state = gdk_window_get_state(gdk_window);\n@@ -953,8 +1027,3 @@\n-    \/\/ Do not report if iconified, because Java side would set the state to NORMAL\n-    if (jwindow && !is_iconified) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,\n-                (is_maximized)\n-                    ? com_sun_glass_events_WindowEvent_MAXIMIZE\n-                    : com_sun_glass_events_WindowEvent_RESIZE,\n-                ww, wh);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n+    notify_window_resize((state & GDK_WINDOW_STATE_MAXIMIZED)\n+                                ? com_sun_glass_events_WindowEvent_MAXIMIZE\n+                                : com_sun_glass_events_WindowEvent_RESIZE);\n@@ -962,4 +1031,9 @@\n-        if (jview) {\n-            mainEnv->CallVoidMethod(jview, jViewNotifyResize, event->width, event->height);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n+    notify_view_resize();\n+}\n+\n+void WindowContext::notify_view_move() {\n+    if (jview) {\n+        LOG(\"com_sun_glass_events_ViewEvent_MOVE\\n\");\n+        mainEnv->CallVoidMethod(jview, jViewNotifyView,\n+                com_sun_glass_events_ViewEvent_MOVE);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n@@ -967,0 +1041,1 @@\n+}\n@@ -968,3 +1043,3 @@\n-    if (!is_iconified && !is_fullscreen && !is_maximized) {\n-        geometry.final_width.value = (geometry.final_width.type == BOUNDSTYPE_CONTENT)\n-                ? event->width : ww;\n+void WindowContext::process_configure(GdkEventConfigure *event) {\n+    LOG(\"Configure Event - send_event: %d, x: %d, y: %d, width: %d, height: %d\\n\",\n+            event->send_event, event->x, event->y, event->width, event->height);\n@@ -972,2 +1047,4 @@\n-        geometry.final_height.value = (geometry.final_height.type == BOUNDSTYPE_CONTENT)\n-                ? event->height : wh;\n+    GdkWindowState state = gdk_window_get_state(gdk_window);\n+\n+    if (state & GDK_WINDOW_STATE_ICONIFIED) {\n+        return;\n@@ -976,1 +1053,1 @@\n-    gint root_x, root_y, origin_x, origin_y;\n+    int root_x, root_y, origin_x, origin_y;\n@@ -980,6 +1057,3 @@\n-    \/\/ x and y represent the position of the top-left corner of the window relative to the desktop area\n-    geometry.x = root_x;\n-    geometry.y = root_y;\n-\n-    \/\/ view_x and view_y represent the position of the content relative to the top-left corner of the window,\n-    \/\/ taking into account window decorations (such as title bars and borders) applied by the window manager.\n+    \/\/ view_x and view_y represent the position of the content relative to the left corner of the window,\n+    \/\/ taking into account window decorations (such as title bars and borders) applied by the window manager\n+    \/\/ and might vary by window state.\n@@ -988,1 +1062,1 @@\n-    notify_window_move();\n+    LOG(\"view x, y: %d, %d\\n\", geometry.view_x, geometry.view_y);\n@@ -990,10 +1064,37 @@\n-    glong to_screen = getScreenPtrForLocation(geometry.x, geometry.y);\n-    if (to_screen != -1) {\n-        if (to_screen != screen) {\n-            if (jwindow) {\n-                \/\/notify screen changed\n-                jobject jScreen = createJavaScreen(mainEnv, to_screen);\n-                mainEnv->CallVoidMethod(jwindow, jWindowNotifyMoveToAnotherScreen, jScreen);\n-                CHECK_JNI_EXCEPTION(mainEnv)\n-            }\n-            screen = to_screen;\n+    int ww = event->width;\n+    int wh = event->height;\n+\n+    \/\/ Fullscreen usually have no decorations\n+    if (geometry.view_x > 0) {\n+        ww += geometry.extents.width;\n+    }\n+\n+    if (geometry.view_y > 0) {\n+        wh += geometry.extents.height;\n+    }\n+\n+    if (mapped) {\n+        geometry.x = root_x;\n+        geometry.y = root_y;\n+        geometry.width.view = event->width;\n+        geometry.height.view = event->height;\n+        geometry.width.window = ww;\n+        geometry.height.window = wh;\n+    }\n+\n+    notify_window_resize((state & GDK_WINDOW_STATE_MAXIMIZED)\n+                            ? com_sun_glass_events_WindowEvent_MAXIMIZE\n+                            : com_sun_glass_events_WindowEvent_RESIZE);\n+    notify_view_resize();\n+\n+    notify_window_move();\n+    notify_view_move();\n+\n+    glong to_screen = getScreenPtrForLocation(event->x, event->y);\n+    if (to_screen != -1 && to_screen != screen) {\n+        if (jwindow) {\n+            LOG(\"jWindowNotifyMoveToAnotherScreen\\n\");\n+            \/\/notify screen changed\n+            jobject jScreen = createJavaScreen(mainEnv, to_screen);\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyMoveToAnotherScreen, jScreen);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n@@ -1001,0 +1102,1 @@\n+        screen = to_screen;\n@@ -1004,2 +1106,3 @@\n-void WindowContextTop::update_window_constraints() {\n-    bool is_floating = !is_iconified && !is_fullscreen && !is_maximized;\n+void WindowContext::update_window_constraints() {\n+    update_window_constraints(false);\n+}\n@@ -1007,2 +1110,5 @@\n-    if (!is_floating) {\n-        \/\/ window is not floating on the screen\n+void WindowContext::update_window_constraints(bool ignored_resizable) {\n+    \/\/ Not ready to re-apply the constraints\n+    if (!is_window_floating(gdk_window_get_state(gdk_window))\n+        || !is_window_floating((GdkWindowState) initial_state_mask)) {\n+        LOG(\"not floating: update_window_constraints ignored\\n\");\n@@ -1014,14 +1120,13 @@\n-    if (resizable.value && !is_disabled) {\n-        int min_w = (resizable.minw == -1) ? 1\n-                      : resizable.minw - geometry.extents.left - geometry.extents.right;\n-        int min_h =  (resizable.minh == -1) ? 1\n-                      : resizable.minh - geometry.extents.top - geometry.extents.bottom;\n-\n-        hints.min_width = (min_w < 1) ? 1 : min_w;\n-        hints.min_height = (min_h < 1) ? 1 : min_h;\n-\n-        hints.max_width = (resizable.maxw == -1) ? G_MAXINT\n-                            : resizable.maxw - geometry.extents.left - geometry.extents.right;\n-\n-        hints.max_height = (resizable.maxh == -1) ? G_MAXINT\n-                           : resizable.maxh - geometry.extents.top - geometry.extents.bottom;\n+    if ((resizable.value || ignored_resizable) && !is_disabled) {\n+        hints.min_width = (resizable.minw == -1)\n+                     ? 1\n+                     : NONNEGATIVE_OR(resizable.minw - geometry.extents.width, 1);\n+        hints.min_height = (resizable.minh == -1)\n+                     ? 1\n+                     : NONNEGATIVE_OR(resizable.minh - geometry.extents.height, 1);\n+        hints.max_width = (resizable.maxw == -1)\n+                    ? G_MAXINT\n+                    : NONNEGATIVE_OR(resizable.maxw - geometry.extents.width, 1);\n+        hints.max_height = (resizable.maxh == -1)\n+                    ? G_MAXINT\n+                    : NONNEGATIVE_OR(resizable.maxh - geometry.extents.height, 1);\n@@ -1029,7 +1134,4 @@\n-        int w = geometry_get_content_width(&geometry);\n-        int h = geometry_get_content_height(&geometry);\n-\n-        hints.min_width = w;\n-        hints.min_height = h;\n-        hints.max_width = w;\n-        hints.max_height = h;\n+        hints.min_width = geometry.width.view;\n+        hints.min_height = geometry.height.view;\n+        hints.max_width = geometry.width.view;\n+        hints.max_height = geometry.height.view;\n@@ -1038,2 +1140,6 @@\n-    gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &hints,\n-                                  (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));\n+    LOG(\"geometry hints: min w,h: %d, %d - max w,h: %d, %d\\n\", hints.min_width,\n+            hints.min_height, hints.max_width, hints.max_height);\n+\n+    \/\/ GDK_HINT_USER_POS is used for the initial position to work\n+    gdk_window_set_geometry_hints(gdk_window, &hints,\n+            (GdkWindowHints) (GDK_HINT_USER_POS |  GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));\n@@ -1042,1 +1148,2 @@\n-void WindowContextTop::set_resizable(bool res) {\n+void WindowContext::set_resizable(bool res) {\n+    LOG(\"set_resizable: %d\\n\", res);\n@@ -1047,11 +1154,18 @@\n-void WindowContextTop::set_visible(bool visible) {\n-    WindowContextBase::set_visible(visible);\n-\n-    if (visible && !geometry.size_assigned) {\n-        set_bounds(0, 0, false, false, 320, 200, -1, -1, 0, 0);\n-    }\n-\n-    \/\/JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order\n-    if (visible && jwindow && isEnabled()) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);\n-        CHECK_JNI_EXCEPTION(mainEnv);\n+void WindowContext::set_visible(bool visible) {\n+    LOG(\"set_visible: %d\\n\", visible);\n+    if (visible) {\n+        gdk_window_show(gdk_window);\n+    } else {\n+        gdk_window_hide(gdk_window);\n+        if (jview && is_mouse_entered) {\n+            is_mouse_entered = false;\n+            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+                    com_sun_glass_events_MouseEvent_EXIT,\n+                    com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+                    0, 0,\n+                    0, 0,\n+                    0,\n+                    JNI_FALSE,\n+                    JNI_FALSE);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n@@ -1061,4 +1175,4 @@\n-void WindowContextTop::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch,\n-                                  float gravity_x, float gravity_y) {\n-\/\/     fprintf(stderr, \"set_bounds -> x = %d, y = %d, xset = %d, yset = %d, w = %d, h = %d, cw = %d, ch = %d, gx = %f, gy = %f\\n\",\n-\/\/            x, y, xSet, ySet, w, h, cw, ch, gravity_x, gravity_y);\n+void WindowContext::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch,\n+                               float gravity_x, float gravity_y) {\n+    LOG(\"set_bounds -> x = %d, y = %d, xset = %d, yset = %d, w = %d, h = %d, cw = %d, ch = %d, gx = %f, gy = %f\\n\",\n+            x, y, xSet, ySet, w, h, cw, ch, gravity_x, gravity_y);\n@@ -1073,3 +1187,2 @@\n-        geometry.final_width.type = BOUNDSTYPE_WINDOW;\n-        geometry.final_width.value = w;\n-        newW = w - (geometry.extents.left + geometry.extents.right);\n+        geometry.width.type = BOUNDSTYPE_WINDOW;\n+        newW = NONNEGATIVE_OR(w - geometry.extents.width, 1);\n@@ -1077,2 +1190,2 @@\n-        geometry.final_width.type = BOUNDSTYPE_CONTENT;\n-        geometry.final_width.value = cw;\n+        \/\/ once set to window, stick with it\n+        if (BOUNDSTYPE_UNKNOWN) geometry.width.type = BOUNDSTYPE_VIEW;\n@@ -1080,2 +1193,0 @@\n-    } else {\n-        newW = geometry_get_content_width(&geometry);\n@@ -1085,3 +1196,2 @@\n-        geometry.final_height.type = BOUNDSTYPE_WINDOW;\n-        geometry.final_height.value = h;\n-        newH = h - (geometry.extents.top + geometry.extents.bottom);\n+        geometry.height.type = BOUNDSTYPE_WINDOW;\n+        newH = NONNEGATIVE_OR(h - geometry.extents.height, 1);\n@@ -1089,2 +1199,2 @@\n-        geometry.final_height.type = BOUNDSTYPE_CONTENT;\n-        geometry.final_height.value = ch;\n+        \/\/ once set to window, stick with it\n+        if (BOUNDSTYPE_UNKNOWN) geometry.height.type = BOUNDSTYPE_VIEW;\n@@ -1092,2 +1202,0 @@\n-    } else {\n-        newH = geometry_get_content_height(&geometry);\n@@ -1096,0 +1204,1 @@\n+    GdkWindowState state = gdk_window_get_state(gdk_window);\n@@ -1097,23 +1206,3 @@\n-    if (newW > 0 || newH > 0) {\n-        \/\/ call update_window_constraints() to let gtk_window_resize succeed, because it's bound to geometry constraints\n-        update_window_constraints();\n-\n-        if (gtk_widget_get_realized(gtk_widget)) {\n-            gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);\n-        } else {\n-            gtk_window_set_default_size(GTK_WINDOW(gtk_widget), newW, newH);\n-        }\n-        geometry.size_assigned = true;\n-        notify_window_resize();\n-    }\n-\n-    if (xSet || ySet) {\n-        if (xSet) {\n-            geometry.x = x;\n-        }\n-\n-        if (ySet) {\n-            geometry.y = y;\n-        }\n-\n-        gtk_window_move(GTK_WINDOW(gtk_widget), geometry.x, geometry.y);\n+    \/\/ Ignore when maximized \/ fullscreen\n+    if (!is_window_floating(state)) {\n+        notify_current_sizes();\n@@ -1121,5 +1210,0 @@\n-    }\n-}\n-\n-void WindowContextTop::applyShapeMask(void* data, uint width, uint height) {\n-    if (frame_type != TRANSPARENT) {\n@@ -1129,1 +1213,1 @@\n-    glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);\n+    move_resize(x, y, xSet, ySet, newW, newH);\n@@ -1132,15 +1216,4 @@\n-void WindowContextTop::set_minimized(bool minimize) {\n-    is_iconified = minimize;\n-    if (minimize) {\n-        if (frame_type == TRANSPARENT && wmanager == COMPIZ) {\n-            \/\/ https:\/\/bugs.launchpad.net\/ubuntu\/+source\/unity\/+bug\/1245571\n-            glass_window_reset_input_shape_mask(gtk_widget_get_window(gtk_widget));\n-        }\n-\n-        if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0) {\n-            \/\/ in this case - the window manager will not support the programatic\n-            \/\/ request to iconify - so we need to disable this until we are restored.\n-            GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MINIMIZE);\n-            gdk_window_set_functions(gdk_window, wmf);\n-        }\n-        gtk_window_iconify(GTK_WINDOW(gtk_widget));\n+void WindowContext::iconify(bool state) {\n+    if (state) {\n+        add_wmf(GDK_FUNC_MINIMIZE);\n+        gdk_window_iconify(gdk_window);\n@@ -1148,1 +1221,1 @@\n-        gtk_window_deiconify(GTK_WINDOW(gtk_widget));\n+        gdk_window_deiconify(gdk_window);\n@@ -1153,7 +1226,9 @@\n-void WindowContextTop::set_maximized(bool maximize) {\n-    is_maximized = maximize;\n-    if (maximize) {\n-        \/\/ enable the functionality on the window manager as it might ignore the maximize command,\n-        \/\/ for example when the window is undecorated.\n-        GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MAXIMIZE);\n-        gdk_window_set_functions(gdk_window, wmf);\n+void WindowContext::maximize(bool state) {\n+    if (state) {\n+        add_wmf(GDK_FUNC_MAXIMIZE);\n+        update_window_constraints(true);\n+        gdk_window_maximize(gdk_window);\n+    } else {\n+        gdk_window_unmaximize(gdk_window);\n+    }\n+}\n@@ -1161,1 +1236,4 @@\n-        gtk_window_maximize(GTK_WINDOW(gtk_widget));\n+void WindowContext::set_minimized(bool state) {\n+    LOG(\"set_minimized = %d\\n\", state);\n+    if (mapped) {\n+        iconify(state);\n@@ -1163,1 +1241,3 @@\n-        gtk_window_unmaximize(GTK_WINDOW(gtk_widget));\n+        initial_state_mask = state\n+            ? (initial_state_mask | GDK_WINDOW_STATE_ICONIFIED)\n+            : (initial_state_mask & ~GDK_WINDOW_STATE_ICONIFIED);\n@@ -1167,3 +1247,10 @@\n-void WindowContextTop::enter_fullscreen() {\n-    gtk_window_fullscreen(GTK_WINDOW(gtk_widget));\n-    is_fullscreen = true;\n+void WindowContext::set_maximized(bool state) {\n+    LOG(\"set_maximized = %d\\n\", state);\n+    if (mapped) {\n+        maximize(state);\n+    } else {\n+        initial_state_mask = state\n+            ? (initial_state_mask | GDK_WINDOW_STATE_MAXIMIZED)\n+            : (initial_state_mask & ~GDK_WINDOW_STATE_MAXIMIZED);\n+        notify_window_resize(GDK_WINDOW_STATE_MAXIMIZED);\n+    }\n@@ -1172,2 +1259,10 @@\n-void WindowContextTop::exit_fullscreen() {\n-    gtk_window_unfullscreen(GTK_WINDOW(gtk_widget));\n+void WindowContext::enter_fullscreen() {\n+    LOG(\"enter_fullscreen\\n\");\n+    if (mapped) {\n+        update_window_constraints(true);\n+        gdk_window_fullscreen(gdk_window);\n+    } else {\n+        initial_state_mask |= GDK_WINDOW_STATE_FULLSCREEN;\n+        mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n@@ -1176,3 +1271,6 @@\n-void WindowContextTop::request_focus() {\n-    if (is_visible()) {\n-        gtk_window_present(GTK_WINDOW(gtk_widget));\n+void WindowContext::exit_fullscreen() {\n+    LOG(\"exit_fullscreen\\n\");\n+    if (mapped) {\n+        gdk_window_unfullscreen(gdk_window);\n+    } else {\n+        initial_state_mask &= ~GDK_WINDOW_STATE_FULLSCREEN;\n@@ -1182,2 +1280,9 @@\n-void WindowContextTop::set_focusable(bool focusable) {\n-    gtk_window_set_accept_focus(GTK_WINDOW(gtk_widget), focusable ? TRUE : FALSE);\n+void WindowContext::request_focus() {\n+    LOG(\"request_focus\\n\");\n+    if (!is_visible()) return;\n+\n+    gdk_window_focus(gdk_window, GDK_CURRENT_TIME);\n+}\n+\n+void WindowContext::set_focusable(bool focusable) {\n+    gdk_window_set_accept_focus(gdk_window, focusable ? TRUE : FALSE);\n@@ -1186,2 +1291,2 @@\n-void WindowContextTop::set_title(const char* title) {\n-    gtk_window_set_title(GTK_WINDOW(gtk_widget), title);\n+void WindowContext::set_title(const char* title) {\n+    gdk_window_set_title(gdk_window, title);\n@@ -1190,2 +1295,3 @@\n-void WindowContextTop::set_alpha(double alpha) {\n-    gtk_window_set_opacity(GTK_WINDOW(gtk_widget), (gdouble)alpha);\n+\/\/ This only works o Xorg\n+void WindowContext::set_alpha(double alpha) {\n+    gdk_window_set_opacity(gdk_window, (gdouble)alpha);\n@@ -1194,1 +1300,1 @@\n-void WindowContextTop::set_enabled(bool enabled) {\n+void WindowContext::set_enabled(bool enabled) {\n@@ -1199,3 +1305,4 @@\n-void WindowContextTop::set_minimum_size(int w, int h) {\n-    resizable.minw = (w <= 0) ? 1 : w;\n-    resizable.minh = (h <= 0) ? 1 : h;\n+void WindowContext::set_minimum_size(int w, int h) {\n+    LOG(\"set_minimum_size: %d, %d\\n\", w, h);\n+    resizable.minw = w;\n+    resizable.minh = h;\n@@ -1205,3 +1312,4 @@\n-void WindowContextTop::set_maximum_size(int w, int h) {\n-    resizable.maxw = w;\n-    resizable.maxh = h;\n+void WindowContext::set_maximum_size(int w, int h) {\n+    LOG(\"set_maximum_size: %d, %d\\n\", w, h);\n+    resizable.maxw = (w == -1) ? -1 : w;\n+    resizable.maxh = (h == -1) ? -1 : h;\n@@ -1211,2 +1319,7 @@\n-void WindowContextTop::set_icon(GdkPixbuf* pixbuf) {\n-    gtk_window_set_icon(GTK_WINDOW(gtk_widget), pixbuf);\n+void WindowContext::set_icon(GdkPixbuf* icon) {\n+    if (icon == NULL || !GDK_IS_PIXBUF (icon)) return;\n+\n+    GList *icons = NULL;\n+    icons = g_list_append(icons, icon);\n+    gdk_window_set_icon_list(gdk_window, icons);\n+    g_list_free(icons);\n@@ -1215,1 +1328,2 @@\n-void WindowContextTop::to_front() {\n+void WindowContext::to_front() {\n+    LOG(\"to_front\\n\");\n@@ -1219,1 +1333,2 @@\n-void WindowContextTop::to_back() {\n+void WindowContext::to_back() {\n+    LOG(\"to_back\\n\");\n@@ -1223,1 +1338,1 @@\n-void WindowContextTop::set_modal(bool modal, WindowContext* parent) {\n+void WindowContext::set_modal(bool modal, WindowContext* parent) {\n@@ -1225,1 +1340,0 @@\n-        \/\/gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_DIALOG);\n@@ -1227,1 +1341,1 @@\n-            gtk_window_set_transient_for(GTK_WINDOW(gtk_widget), parent->get_gtk_window());\n+            gdk_window_set_transient_for(gdk_window, parent->get_gdk_window());\n@@ -1230,1 +1344,1 @@\n-    gtk_window_set_modal(GTK_WINDOW(gtk_widget), modal ? TRUE : FALSE);\n+    gdk_window_set_modal_hint(gdk_window, modal ? TRUE : FALSE);\n@@ -1233,5 +1347,1 @@\n-GtkWindow *WindowContextTop::get_gtk_window() {\n-    return GTK_WINDOW(gtk_widget);\n-}\n-\n-WindowGeometry WindowContextTop::get_geometry() {\n+WindowGeometry WindowContext::get_geometry() {\n@@ -1241,1 +1351,1 @@\n-void WindowContextTop::update_ontop_tree(bool on_top) {\n+void WindowContext::update_ontop_tree(bool on_top) {\n@@ -1243,2 +1353,2 @@\n-    gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), effective_on_top ? TRUE : FALSE);\n-    for (std::set<WindowContextTop*>::iterator it = children.begin(); it != children.end(); ++it) {\n+    gdk_window_set_keep_above(gdk_window, effective_on_top ? TRUE : FALSE);\n+    for (std::set<WindowContext*>::iterator it = children.begin(); it != children.end(); ++it) {\n@@ -1249,1 +1359,1 @@\n-bool WindowContextTop::on_top_inherited() {\n+bool WindowContext::on_top_inherited() {\n@@ -1252,1 +1362,1 @@\n-        WindowContextTop* topO = dynamic_cast<WindowContextTop*>(o);\n+        WindowContext* topO = dynamic_cast<WindowContext*>(o);\n@@ -1262,1 +1372,1 @@\n-bool WindowContextTop::effective_on_top() {\n+bool WindowContext::effective_on_top() {\n@@ -1264,1 +1374,1 @@\n-        WindowContextTop* topO = dynamic_cast<WindowContextTop*>(owner);\n+        WindowContext* topO = dynamic_cast<WindowContext*>(owner);\n@@ -1270,1 +1380,73 @@\n-void WindowContextTop::notify_on_top(bool top) {\n+void WindowContext::update_window_size() {\n+    geometry.width.window = geometry.width.view;\n+    geometry.height.window = geometry.height.view;\n+\n+    if (frame_type == TITLED) {\n+        geometry.width.window += geometry.extents.width;\n+        geometry.height.window += geometry.extents.height;\n+    }\n+}\n+\n+\/\/ Values are view size\n+void WindowContext::move_resize(int x, int y, bool xSet, bool ySet, int width, int height) {\n+    LOG(\"move_resize: x,y: %d,%d \/ cw,ch: %d,%d\\n\", x, y, width, height);\n+    int newW = (width > 0) ? width : geometry.width.view;\n+    int newH = (height > 0) ? height : geometry.height.view;\n+\n+    \/\/ Windows that are undecorated or transparent will not respect\n+    \/\/ minimum or maximum size constraints\n+    if (resizable.minw > 0 && newW < resizable.minw) {\n+        newW = NONNEGATIVE_OR(resizable.minw - geometry.extents.width, 1);\n+    }\n+\n+    if (resizable.maxw > 0 && newW > resizable.maxw) {\n+        newW = NONNEGATIVE_OR(resizable.maxw - geometry.extents.width, 1);\n+    }\n+\n+    if (resizable.minh > 0 && newH < resizable.minh) {\n+        newH = NONNEGATIVE_OR(resizable.minh - geometry.extents.height, 1);\n+    }\n+\n+    if (resizable.maxh > 0 && newH > resizable.maxh) {\n+        newH = NONNEGATIVE_OR(resizable.maxh - geometry.extents.height, 1);\n+    }\n+\n+    geometry.width.view = newW;\n+    geometry.height.view = newH;\n+\n+    update_window_size();\n+\n+    if (!resizable.value) {\n+        update_window_constraints();\n+    }\n+\n+    if (xSet) geometry.x = x;\n+    if (ySet) geometry.y = y;\n+\n+    LOG(\"gdk_window_move_resize: x,y: %d,%d \/ cw,ch: %d,%d \/ ww,wh: %d,%d\\n\",\n+        geometry.x, geometry.y, newW, newH, geometry.width.window, geometry.height.window);\n+\n+    gdk_window_move_resize(gdk_window, geometry.x, geometry.y, newW, newH);\n+\n+    \/\/ Or else let to process_configure\n+    if (!mapped) {\n+        notify_window_move();\n+        notify_current_sizes();\n+    }\n+}\n+\n+void WindowContext::add_wmf(GdkWMFunction wmf) {\n+    if ((initial_wmf & wmf) == 0) {\n+        current_wmf = (GdkWMFunction)((int)current_wmf | (int)wmf);\n+        gdk_window_set_functions(gdk_window, current_wmf);\n+    }\n+}\n+\n+void WindowContext::remove_wmf(GdkWMFunction wmf) {\n+    if ((initial_wmf & wmf) == 0) {\n+        current_wmf = (GdkWMFunction)((int)current_wmf & ~(int)wmf);\n+        gdk_window_set_functions(gdk_window, current_wmf);\n+    }\n+}\n+\n+void WindowContext::notify_on_top(bool top) {\n@@ -1275,1 +1457,1 @@\n-            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);\n+            gdk_window_set_keep_above(gdk_window, TRUE);\n@@ -1287,1 +1469,1 @@\n-void WindowContextTop::set_level(int level) {\n+void WindowContext::set_level(int level) {\n@@ -1301,1 +1483,1 @@\n-void WindowContextTop::set_owner(WindowContext * owner_ctx) {\n+void WindowContext::set_owner(WindowContext * owner_ctx) {\n@@ -1305,10 +1487,1 @@\n-void WindowContextTop::update_view_size() {\n-    \/\/ Notify the view size only if size is oriented by WINDOW, otherwise it knows its own size\n-    if (geometry.final_width.type == BOUNDSTYPE_WINDOW\n-        || geometry.final_height.type == BOUNDSTYPE_WINDOW) {\n-\n-        notify_view_resize();\n-    }\n-}\n-\n-void WindowContextTop::notify_view_resize() {\n+void WindowContext::update_view_size() {\n@@ -1316,5 +1489,1 @@\n-        int cw = geometry_get_content_width(&geometry);\n-        int ch = geometry_get_content_height(&geometry);\n-\n-        mainEnv->CallVoidMethod(jview, jViewNotifyResize, cw, ch);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n+        notify_view_resize();\n@@ -1324,23 +1493,4 @@\n-void WindowContextTop::notify_window_resize() {\n-    int w = geometry_get_window_width(&geometry);\n-    int h = geometry_get_window_height(&geometry);\n-\n-    mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,\n-                 com_sun_glass_events_WindowEvent_RESIZE, w, h);\n-    CHECK_JNI_EXCEPTION(mainEnv)\n-\n-    notify_view_resize();\n-}\n-\n-void WindowContextTop::notify_window_move() {\n-    if (jwindow) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove,\n-                                 geometry.x, geometry.y);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n-\n-        if (jview) {\n-            mainEnv->CallVoidMethod(jview, jViewNotifyView,\n-                    com_sun_glass_events_ViewEvent_MOVE);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n-    }\n+WindowContext::~WindowContext() {\n+    LOG(\"~WindowContext\\n\");\n+    disableIME();\n+    gdk_window_destroy(gdk_window);\n@@ -1349,7 +1499,0 @@\n-void WindowContextTop::process_destroy() {\n-    if (owner) {\n-        owner->remove_child(this);\n-    }\n-\n-    WindowContextBase::process_destroy();\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.cpp","additions":781,"deletions":638,"binary":false,"changes":1419,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+#define USER_PTR_TO_CTX(value) ((WindowContext *) value)\n+#define DEFAULT_WIDTH 320\n+#define DEFAULT_HEIGHT 200\n+\n@@ -29,1 +33,0 @@\n-#include <X11\/Xlib.h>\n@@ -34,0 +37,1 @@\n+#include <optional>\n@@ -36,1 +40,0 @@\n-\n@@ -38,5 +41,1 @@\n-\n-enum WindowManager {\n-    COMPIZ,\n-    UNKNOWN\n-};\n+#include \"glass_general.h\"\n@@ -56,9 +55,0 @@\n-struct WindowFrameExtents {\n-    int top;\n-    int left;\n-    int bottom;\n-    int right;\n-};\n-\n-static const guint MOUSE_BUTTONS_MASK = (guint) (GDK_BUTTON1_MASK | GDK_BUTTON2_MASK | GDK_BUTTON3_MASK);\n-\n@@ -66,1 +56,2 @@\n-    BOUNDSTYPE_CONTENT,\n+    BOUNDSTYPE_UNKNOWN,\n+    BOUNDSTYPE_VIEW,\n@@ -70,0 +61,2 @@\n+static const guint MOUSE_BUTTONS_MASK = (guint) (GDK_BUTTON1_MASK | GDK_BUTTON2_MASK | GDK_BUTTON3_MASK);\n+\n@@ -71,4 +64,7 @@\n-    WindowGeometry(): final_width(), final_height(),\n-    size_assigned(false), x(), y(), view_x(), view_y(), gravity_x(), gravity_y(), extents() {}\n-    \/\/ estimate of the final width the window will get after all pending\n-    \/\/ configure requests are processed by the window manager\n+    WindowGeometry():\n+    width{-1, -1, BOUNDSTYPE_UNKNOWN},\n+    height{-1, -1, BOUNDSTYPE_UNKNOWN},\n+    x(), y(), view_x(), view_y(),\n+    gravity_x(), gravity_y(),\n+    extents(), frame_extents_received(false) {}\n+\n@@ -76,1 +72,2 @@\n-        int value;\n+        int window;\n+        int view;\n@@ -78,1 +75,1 @@\n-    } final_width;\n+    } width;\n@@ -81,1 +78,2 @@\n-        int value;\n+        int window;\n+        int view;\n@@ -83,3 +81,1 @@\n-    } final_height;\n-\n-    bool size_assigned;\n+    } height;\n@@ -89,0 +85,1 @@\n+\n@@ -95,1 +92,3 @@\n-    WindowFrameExtents extents;\n+    GdkRectangle extents;\n+\n+    bool frame_extents_received;\n@@ -98,1 +97,1 @@\n-class WindowContextTop;\n+class WindowContext;\n@@ -100,75 +99,4 @@\n-class WindowContext : public DeletedMemDebug<0xCC> {\n-public:\n-    virtual bool isEnabled() = 0;\n-    virtual bool hasIME() = 0;\n-    virtual bool filterIME(GdkEvent *) = 0;\n-    virtual void enableOrResetIME() = 0;\n-    virtual void updateCaretPos() = 0;\n-    virtual void disableIME() = 0;\n-    virtual void setOnPreEdit(bool) = 0;\n-    virtual void commitIME(gchar *) = 0;\n-\n-    virtual void paint(void* data, jint width, jint height) = 0;\n-    virtual WindowGeometry get_geometry() = 0;\n-\n-    virtual void enter_fullscreen() = 0;\n-    virtual void exit_fullscreen() = 0;\n-    virtual void set_visible(bool) = 0;\n-    virtual bool is_visible() = 0;\n-    virtual void set_bounds(int, int, bool, bool, int, int, int, int, float, float) = 0;\n-    virtual void set_resizable(bool) = 0;\n-    virtual void request_focus() = 0;\n-    virtual void set_focusable(bool)= 0;\n-    virtual bool grab_focus() = 0;\n-    virtual bool grab_mouse_drag_focus() = 0;\n-    virtual void ungrab_focus() = 0;\n-    virtual void ungrab_mouse_drag_focus() = 0;\n-    virtual void set_title(const char*) = 0;\n-    virtual void set_alpha(double) = 0;\n-    virtual void set_enabled(bool) = 0;\n-    virtual void set_minimum_size(int, int) = 0;\n-    virtual void set_maximum_size(int, int) = 0;\n-    virtual void set_minimized(bool) = 0;\n-    virtual void set_maximized(bool) = 0;\n-    virtual void set_icon(GdkPixbuf*) = 0;\n-    virtual void to_front() = 0;\n-    virtual void to_back() = 0;\n-    virtual void set_cursor(GdkCursor*) = 0;\n-    virtual void set_modal(bool, WindowContext* parent = NULL) = 0;\n-    virtual void set_level(int) = 0;\n-    virtual void set_background(float, float, float) = 0;\n-\n-    virtual void process_realize() = 0;\n-    virtual void process_property_notify(GdkEventProperty*) = 0;\n-    virtual void process_configure(GdkEventConfigure*) = 0;\n-    virtual void process_focus(GdkEventFocus*) = 0;\n-    virtual void process_destroy() = 0;\n-    virtual void process_delete() = 0;\n-    virtual void process_expose(GdkEventExpose*) = 0;\n-    virtual void process_mouse_button(GdkEventButton*) = 0;\n-    virtual void process_mouse_motion(GdkEventMotion*) = 0;\n-    virtual void process_mouse_scroll(GdkEventScroll*) = 0;\n-    virtual void process_mouse_cross(GdkEventCrossing*) = 0;\n-    virtual void process_key(GdkEventKey*) = 0;\n-    virtual void process_state(GdkEventWindowState*) = 0;\n-\n-    virtual void notify_state(jint) = 0;\n-    virtual void notify_on_top(bool) {}\n-    virtual void update_view_size() = 0;\n-    virtual void notify_view_resize() = 0;\n-\n-    virtual void add_child(WindowContextTop* child) = 0;\n-    virtual void remove_child(WindowContextTop* child) = 0;\n-    virtual bool set_view(jobject) = 0;\n-\n-    virtual GdkWindow *get_gdk_window() = 0;\n-    virtual GtkWindow *get_gtk_window() = 0;\n-    virtual jobject get_jview() = 0;\n-    virtual jobject get_jwindow() = 0;\n-\n-    virtual void increment_events_counter() = 0;\n-    virtual void decrement_events_counter() = 0;\n-    virtual size_t get_events_count() = 0;\n-    virtual bool is_dead() = 0;\n-    virtual ~WindowContext() {}\n-};\n+class WindowContext: public DeletedMemDebug<0xCC> {\n+private:\n+    static std::optional<GdkRectangle> normal_extents;\n+    static std::optional<GdkRectangle> utility_extents;\n@@ -176,1 +104,11 @@\n-class WindowContextBase: public WindowContext {\n+    jlong screen;\n+    WindowFrameType frame_type;\n+    WindowType window_type;\n+    struct WindowContext *owner;\n+    WindowGeometry geometry;\n+    struct _Resizable {\n+        _Resizable(): value(true),\n+                minw(-1), minh(-1), maxw(-1), maxh(-1) {}\n+        bool value; \/\/actual value of resizable for a window\n+        int minw, minh, maxw, maxh; \/\/minimum and maximum window width\/height;\n+    } resizable;\n@@ -186,4 +124,3 @@\n-    size_t events_processing_cnt;\n-    bool can_be_deleted;\n-protected:\n-    std::set<WindowContextTop*> children;\n+    size_t events_processing_cnt{};\n+\n+    std::set<WindowContext*> children;\n@@ -191,4 +128,5 @@\n-    jobject jview;\n-    GtkWidget* gtk_widget;\n-    GdkWindow* gdk_window = NULL;\n-    GdkWMFunction gdk_windowManagerFunctions;\n+    jobject jview{};\n+\n+    GdkWindow *gdk_window{};\n+    GdkWMFunction initial_wmf;\n+    GdkWMFunction current_wmf;\n@@ -196,2 +134,0 @@\n-    bool is_iconified;\n-    bool is_maximized;\n@@ -200,0 +136,3 @@\n+    bool on_top;\n+    bool can_be_deleted;\n+    bool mapped;\n@@ -201,0 +140,2 @@\n+    gint initial_state_mask;\n+protected:\n@@ -219,0 +160,1 @@\n+\n@@ -220,0 +162,2 @@\n+    WindowContext(jobject, WindowContext*, long, WindowFrameType, WindowType, GdkWMFunction);\n+\n@@ -222,1 +166,1 @@\n-    bool filterIME(GdkEvent *);\n+    bool filterIME(GdkEvent*);\n@@ -228,0 +172,1 @@\n+\n@@ -230,0 +175,1 @@\n+    XID get_native_window();\n@@ -233,2 +179,2 @@\n-    void add_child(WindowContextTop*);\n-    void remove_child(WindowContextTop*);\n+    void add_child(WindowContext*);\n+    void remove_child(WindowContext*);\n@@ -243,1 +189,0 @@\n-    void set_level(int) {}\n@@ -246,0 +191,1 @@\n+    void process_map();\n@@ -247,3 +193,3 @@\n-    void process_destroy();\n-    void process_delete();\n-    void process_expose(GdkEventExpose*);\n+    void process_focus(bool);\n+    void notify_repaint();\n+    void notify_repaint(GdkRectangle*);\n@@ -256,2 +202,4 @@\n-\n-    void notify_state(jint);\n+    void process_property_notify(GdkEventProperty*);\n+    void process_configure(GdkEventConfigure*);\n+    void process_delete();\n+    void process_destroy();\n@@ -264,35 +212,0 @@\n-    ~WindowContextBase();\n-protected:\n-    virtual void applyShapeMask(void*, uint width, uint height) = 0;\n-};\n-\n-class WindowContextTop: public WindowContextBase {\n-    jlong screen;\n-    WindowFrameType frame_type;\n-    WindowType window_type;\n-    struct WindowContext *owner;\n-    WindowGeometry geometry;\n-    struct _Resizable {\/\/ we can't use set\/get gtk_window_resizable function\n-        _Resizable(): value(true),\n-                minw(-1), minh(-1), maxw(-1), maxh(-1) {}\n-        bool value; \/\/actual value of resizable for a window\n-        int minw, minh, maxw, maxh; \/\/minimum and maximum window width\/height;\n-    } resizable;\n-\n-    bool on_top;\n-    bool is_fullscreen;\n-\n-    static WindowFrameExtents normal_extents;\n-    static WindowFrameExtents utility_extents;\n-\n-    WindowManager wmanager;\n-public:\n-    WindowContextTop(jobject, WindowContext*, long, WindowFrameType, WindowType, GdkWMFunction);\n-\n-    void process_realize();\n-    void process_property_notify(GdkEventProperty*);\n-    void process_state(GdkEventWindowState*);\n-    void process_configure(GdkEventConfigure*);\n-    void process_destroy();\n-    void work_around_compiz_state();\n-\n@@ -317,2 +230,1 @@\n-    void set_visible(bool);\n-    void notify_on_top(bool);\n+    void set_owner(WindowContext*);\n@@ -320,1 +232,0 @@\n-    void notify_view_resize();\n@@ -325,1 +236,1 @@\n-    void set_owner(WindowContext*);\n+    void update_initial_state();\n@@ -327,2 +238,1 @@\n-    GtkWindow *get_gtk_window();\n-    void detach_from_java();\n+    ~WindowContext();\n@@ -330,2 +240,0 @@\n-protected:\n-    void applyShapeMask(void*, uint width, uint height);\n@@ -333,0 +241,14 @@\n+    GdkVisual* find_best_visual();\n+    void maximize(bool);\n+    void iconify(bool);\n+    void update_window_size();\n+    void move_resize(int, int, bool, bool, int, int);\n+    void add_wmf(GdkWMFunction);\n+    void remove_wmf(GdkWMFunction);\n+    void notify_on_top(bool);\n+    void notify_window_resize(int);\n+    void notify_window_move();\n+    void notify_view_resize();\n+    void notify_view_move();\n+    void notify_current_sizes();\n+    GdkAtom get_net_frame_extents_atom();\n@@ -335,2 +257,2 @@\n-    void set_cached_extents(WindowFrameExtents ex);\n-    WindowFrameExtents get_cached_extents();\n+    void set_cached_extents(GdkRectangle);\n+    void load_cached_extents();\n@@ -339,0 +261,1 @@\n+    void update_window_constraints(bool);\n@@ -342,4 +265,0 @@\n-    void notify_window_move();\n-    void notify_window_resize();\n-    WindowContextTop(WindowContextTop&);\n-    WindowContextTop& operator= (const WindowContextTop&);\n@@ -364,0 +283,1 @@\n+                LOG(\"EventsCounterHelper: delete ctx\\n\");\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":93,"deletions":173,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-void WindowContextBase::commitIME(gchar *str) {\n+void WindowContext::commitIME(gchar *str) {\n@@ -118,1 +118,1 @@\n-bool WindowContextBase::hasIME() {\n+bool WindowContext::hasIME() {\n@@ -122,1 +122,1 @@\n-bool WindowContextBase::filterIME(GdkEvent *event) {\n+bool WindowContext::filterIME(GdkEvent *event) {\n@@ -139,1 +139,1 @@\n-void WindowContextBase::setOnPreEdit(bool preedit) {\n+void WindowContext::setOnPreEdit(bool preedit) {\n@@ -143,1 +143,1 @@\n-void WindowContextBase::updateCaretPos() {\n+void WindowContext::updateCaretPos() {\n@@ -164,1 +164,1 @@\n-void WindowContextBase::enableOrResetIME() {\n+void WindowContext::enableOrResetIME() {\n@@ -188,1 +188,1 @@\n-void WindowContextBase::disableIME() {\n+void WindowContext::disableIME() {\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window_ime.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,700 @@\n+\/*\n+ * Copyright (c) 2025 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\/*\n+ * Copyright (c) 2025 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javafx.application.Application;\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.ReadOnlyBooleanProperty;\n+import javafx.beans.property.ReadOnlyDoubleProperty;\n+import javafx.beans.property.ReadOnlyProperty;\n+import javafx.beans.property.ReadOnlyStringProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.beans.property.StringProperty;\n+import javafx.beans.value.ChangeListener;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.event.Event;\n+import javafx.geometry.HPos;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Pos;\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.CheckBox;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.ContextMenu;\n+import javafx.scene.control.Control;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.ScrollPane;\n+import javafx.scene.control.Spinner;\n+import javafx.scene.control.SpinnerValueFactory;\n+import javafx.scene.control.TextField;\n+import javafx.scene.control.TitledPane;\n+import javafx.scene.control.Tooltip;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.BackgroundFill;\n+import javafx.scene.layout.CornerRadii;\n+import javafx.scene.layout.FlowPane;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.Priority;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.paint.Color;\n+import javafx.stage.FileChooser;\n+import javafx.stage.Modality;\n+import javafx.stage.Screen;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.util.StringConverter;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.DoubleConsumer;\n+\n+public class TestStage extends Application {\n+    private final ObservableList<Stage> stages = FXCollections.observableArrayList();\n+    private int stageCounter = 0;\n+\n+    private final ComboBox<StageStyle> cbStageStyle =\n+            new ComboBox<>(FXCollections.observableArrayList(StageStyle.values()));\n+    private final ComboBox<Modality> cbModality = new ComboBox<>(FXCollections.observableArrayList(Modality.values()));\n+    private final ComboBox<Stage> cbOwner = new ComboBox<>();\n+\n+    private final Button btnToFront = new Button(\"To Front\");\n+    private final Button btnToBack = new Button(\"To Back\");\n+    private final Button btnCreate = new Button(\"Create\");\n+    private final Button btnCreateShow = new Button(\"Create\/Show\");\n+    private final Button btnSelectLast = new Button(\"Select Last\");\n+    private final Button btnSelectPrevious = new Button(\"\");\n+    private final Button btnSelectNone = new Button(\"None\");\n+    private final Button btnSelectNext = new Button(\"\");\n+    private final Button btnHide = new Button(\"Hide\/Close\");\n+    private final Button btnShow = new Button(\"Show\");\n+    private final Button btnSizeToScene = new Button(\"Size to Scene\");\n+    private final Button btnCenterOnScreen = new Button(\"Center on Screen\");\n+    private final Button btnFocus = new Button(\"Focus\");\n+    private final PropertyEditor propertyEditor = new PropertyEditor();\n+\n+    private final ObjectProperty<StageStyle> initStyle = new SimpleObjectProperty<>(StageStyle.DECORATED);\n+    private final ObjectProperty<Modality> initModality = new SimpleObjectProperty<>(Modality.NONE);\n+    private final ObjectProperty<Stage> initOwner = new SimpleObjectProperty<>(null);\n+    private Stage currentStage = null;\n+\n+    private static final double MAX_WIDTH = 7680;\n+    private static final double MAX_HEIGHT = 4320;\n+\n+    private void updateCommandButtonsState() {\n+        boolean disabled = stages.isEmpty() || currentStage == null;\n+\n+        btnShow.setDisable(disabled);\n+        btnHide.setDisable(disabled);\n+        btnSizeToScene.setDisable(disabled);\n+        btnCenterOnScreen.setDisable(disabled);\n+        btnToFront.setDisable(disabled);\n+        btnToBack.setDisable(disabled);\n+        btnFocus.setDisable(disabled);\n+        btnSelectNone.setDisable(disabled);\n+\n+        btnSelectLast.setDisable(stages.isEmpty() || currentStage == stages.getLast());\n+        btnSelectNext.setDisable(stages.isEmpty() || currentStage == null || currentStage == stages.getLast());\n+        btnSelectPrevious.setDisable(stages.isEmpty() || currentStage == null  || currentStage == stages.getFirst());\n+    }\n+\n+    private void updateBindings() {\n+        if (currentStage == null) {\n+            propertyEditor.unbind();\n+        } else {\n+            propertyEditor.bindToStage(currentStage);\n+        }\n+    }\n+\n+    private final CheckBox cbCommandAlwaysOnTop = new CheckBox(\"Command Always On Top\");\n+\n+    @Override\n+    public void start(Stage stage) {\n+        cbStageStyle.getSelectionModel().select(StageStyle.DECORATED);\n+        cbModality.getSelectionModel().select(Modality.NONE);\n+        cbOwner.itemsProperty().bind(Bindings.createObjectBinding(() -> {\n+            ObservableList<Stage> listWithNull = FXCollections.observableArrayList();\n+            listWithNull.add(null);\n+            listWithNull.addAll(stages);\n+            return listWithNull;\n+        }, stages));\n+\n+        cbOwner.setConverter(new StringConverter<>() {\n+            @Override\n+            public String toString(Stage stage) {\n+                if (stage == null) {\n+                    return \"None\";\n+                }\n+\n+                return stage.getTitle();\n+            }\n+\n+            @Override\n+            public Stage fromString(String string) {\n+                return null;\n+            }\n+        });\n+\n+        initStyle.bind(cbStageStyle.valueProperty());\n+        initModality.bind(cbModality.valueProperty());\n+        initOwner.bind(cbOwner.valueProperty());\n+\n+        btnToFront.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.toFront();\n+            }\n+        });\n+\n+        btnToBack.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.toBack();\n+            }\n+        });\n+\n+        btnCreate.setOnAction(e -> createTestStage());\n+\n+        btnCreateShow.setOnAction(e -> {\n+            createTestStage();\n+            currentStage.show();\n+        });\n+\n+        btnSelectNone.setOnAction(e -> {\n+            currentStage = null;\n+            updateBindings();\n+            updateCommandButtonsState();\n+        });\n+\n+        btnSelectLast.setOnAction(e -> {\n+            currentStage = stages.get(stages.size() - 1);\n+            updateBindings();\n+            updateCommandButtonsState();\n+        });\n+\n+        btnSelectNext.setOnAction(e -> {\n+            if (!stages.isEmpty()) {\n+                int index = stages.indexOf(currentStage);\n+                if (index < stages.size() - 1) {\n+                    currentStage = stages.get(index + 1);\n+                    updateBindings();\n+                    updateCommandButtonsState();\n+                }\n+            }\n+        });\n+\n+        btnSelectPrevious.setOnAction(e -> {\n+            if (!stages.isEmpty()) {\n+                int index = stages.indexOf(currentStage);\n+                if (index > 0) {\n+                    currentStage = stages.get(index - 1);\n+                    updateBindings();\n+                    updateCommandButtonsState();\n+                }\n+            }\n+        });\n+\n+        btnHide.setOnAction(e -> {\n+            if (currentStage != null) {\n+                boolean isShowing = currentStage.isShowing();\n+                currentStage.hide();\n+\n+                if (!isShowing) {\n+                    stages.remove(currentStage);\n+                    currentStage = stages.isEmpty() ? null : stages.getLast();\n+                    updateCommandButtonsState();\n+                    updateBindings();\n+                }\n+            }\n+        });\n+\n+        btnShow.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.show();\n+            }\n+        });\n+\n+        btnSizeToScene.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.sizeToScene();\n+            }\n+        });\n+\n+        btnCenterOnScreen.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.centerOnScreen();\n+            }\n+        });\n+\n+        btnFocus.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.requestFocus();\n+            }\n+        });\n+\n+        updateCommandButtonsState();\n+\n+        FlowPane flow0 = new FlowPane(label(\"Style: \", cbStageStyle), label(\"Modality: \", cbModality),\n+                label(\"Owner: \", cbOwner));\n+        FlowPane flow1 = new FlowPane(btnCreate, btnShow, btnCreateShow, btnHide);\n+        FlowPane flow2 = new FlowPane(btnCenterOnScreen, btnSizeToScene);\n+        FlowPane flow3 = new FlowPane(btnToFront, btnToBack, btnSelectNone, btnSelectLast, btnSelectPrevious,\n+                btnSelectNext, btnFocus);\n+\n+        List.of(flow0, flow1, flow2, flow3).forEach(flow -> {\n+            flow.setHgap(5);\n+            flow.setVgap(5);\n+        });\n+\n+        VBox commandPane = new VBox(cbCommandAlwaysOnTop, flow0, flow1, flow2, flow3);\n+        commandPane.setSpacing(5);\n+        commandPane.setFillWidth(true);\n+\n+        TitledPane commandPaneTitledPane = new TitledPane(\"Commands\", commandPane);\n+        commandPaneTitledPane.setCollapsible(false);\n+\n+        TitledPane editorTitledPane = new TitledPane(\"Properties\", propertyEditor);\n+        editorTitledPane.setCollapsible(false);\n+\n+        VBox root = new VBox(\n+                commandPaneTitledPane,\n+                editorTitledPane\n+        );\n+        root.setSpacing(5);\n+        root.setFillWidth(true);\n+\n+\n+        Scene scene = new Scene(root);\n+        stage.setTitle(\"Command Stage\");\n+        stage.setScene(scene);\n+        stage.setOnShown(e -> {\n+            Rectangle2D stageBounds = new Rectangle2D(\n+                    stage.getX(),\n+                    stage.getY(),\n+                    stage.getWidth(),\n+                    stage.getHeight()\n+            );\n+\n+            Screen currentScreen = Screen.getScreens()\n+                    .stream()\n+                    .filter(screen -> screen.getVisualBounds().intersects(stageBounds))\n+                    .findFirst()\n+                    .orElse(Screen.getPrimary());\n+\n+            Rectangle2D visualBounds = currentScreen.getVisualBounds();\n+            stage.setHeight(visualBounds.getHeight());\n+\n+            double x = visualBounds.getMaxX() - stage.getWidth();\n+            double y = visualBounds.getMaxY() - stage.getHeight();\n+\n+            stage.setX(x);\n+            stage.setY(y);\n+        });\n+        stage.setWidth(500);\n+        stage.show();\n+    }\n+\n+    private HBox label(String label, Control control) {\n+        HBox hbox = new HBox(new Label(label), control);\n+        hbox.setSpacing(5);\n+        hbox.setAlignment(Pos.CENTER_LEFT);\n+        return hbox;\n+    }\n+\n+    private void createTestStage() {\n+        Stage newStage = new Stage();\n+\n+        stageCounter++;\n+\n+        newStage.initStyle(initStyle.getValue());\n+        newStage.initModality(initModality.getValue());\n+        newStage.initOwner(initOwner.getValue());\n+        newStage.setTitle(\"Test Stage \" + stageCounter);\n+\n+        newStage.focusedProperty().addListener((obs, oldVal, newVal) -> {\n+            if (newVal) {\n+                currentStage = newStage;\n+                updateBindings();\n+                updateCommandButtonsState();\n+            }\n+        });\n+\n+        stages.add(newStage);\n+        currentStage = newStage;\n+        createDefaultScene();\n+\n+        newStage.setOnHidden(e -> {\n+            stages.remove(newStage);\n+            if (currentStage == newStage) {\n+                currentStage = stages.isEmpty() ? null : stages.getLast();\n+                updateBindings();\n+            }\n+            updateCommandButtonsState();\n+        });\n+\n+        updateBindings();\n+        updateCommandButtonsState();\n+    }\n+\n+    public static void main(String[] args) {\n+        launch(TestStage.class, args);\n+    }\n+\n+    private Label createLabel(String prefix, ReadOnlyProperty<?> property) {\n+        Label label = new Label();\n+        label.textProperty().bind(Bindings.concat(prefix, Bindings.convert(property)));\n+        return label;\n+    }\n+\n+    private void createDefaultScene() {\n+        Scene scene;\n+\n+        StringProperty lastEvent = new SimpleStringProperty();\n+\n+        Label ownerLabel = new Label(\"Owner: NONE\");\n+        if (currentStage.getOwner() instanceof Stage owner) {\n+            ownerLabel.setText(\"Owner: \" + owner.getTitle());\n+        }\n+\n+        VBox root = new VBox(createLabel(\"Focused: \", currentStage.focusedProperty()),\n+                            new Label(\"Modality: \" + currentStage.getModality()),\n+                            ownerLabel,\n+                            createLabel(\"Last Event: \", lastEvent));\n+        root.setBackground(Background.EMPTY);\n+\n+\n+        if (currentStage.getStyle() == StageStyle.TRANSPARENT) {\n+            BackgroundFill fill = new BackgroundFill(\n+                    Color.HOTPINK.deriveColor(0, 1, 1, 0.5),\n+                    CornerRadii.EMPTY,\n+                    Insets.EMPTY\n+            );\n+            root.setBackground(new Background(fill));\n+\n+            scene = new Scene(root, 300, 300);\n+            scene.setFill(Color.TRANSPARENT);\n+        } else {\n+            scene = new Scene(root, 300, 300, Color.HOTPINK);\n+        }\n+\n+        currentStage.addEventHandler(Event.ANY, e -> lastEvent.set(e.getEventType().getName()));\n+        setupContextMenu(root);\n+        currentStage.setScene(scene);\n+    }\n+\n+    private void createSceneWithTextField() {\n+        StackPane root = new StackPane();\n+\n+        TextField textField = new TextField();\n+        textField.setPromptText(\"Enter text here\");\n+\n+        root.getChildren().add(textField);\n+        setupContextMenu(root);\n+        Scene scene = new Scene(root, 300, 200);\n+\n+        currentStage.setScene(scene);\n+    }\n+\n+    private void createSceneWithTooltipBox() {\n+        StackPane root = new StackPane();\n+\n+        StackPane coloredBox = new StackPane();\n+        coloredBox.setBackground(Background.fill(Color.CORNFLOWERBLUE));\n+\n+        Tooltip tooltip = new Tooltip(\"The quick brown fox jumps over the lazy dog.\");\n+        Tooltip.install(coloredBox, tooltip);\n+        root.getChildren().add(coloredBox);\n+        setupContextMenu(root);\n+        Scene scene = new Scene(root, 300, 200);\n+        currentStage.setScene(scene);\n+    }\n+\n+    private void createAlert(boolean windowModal) {\n+        Alert alert = new Alert(Alert.AlertType.INFORMATION);\n+        alert.setTitle(\"Alert\");\n+        alert.setHeaderText(\"The quick brown fox jumps over the lazy dog.\");\n+\n+        if (windowModal) {\n+            alert.initModality(Modality.WINDOW_MODAL);\n+            alert.initOwner(currentStage);\n+        }\n+\n+        alert.showAndWait();\n+    }\n+\n+    private void createFileOpen() {\n+        FileChooser fileChooser = new FileChooser();\n+        fileChooser.setTitle(\"Open Resource File\");\n+        fileChooser.getExtensionFilters().addAll(\n+                new FileChooser.ExtensionFilter(\"All Files\", \"*.*\")\n+        );\n+        File file = fileChooser.showOpenDialog(currentStage);\n+\n+        if (file != null) {\n+            new Alert(Alert.AlertType.INFORMATION, \"File selected: \" + file.getAbsolutePath()).showAndWait();\n+        } else {\n+            new Alert(Alert.AlertType.WARNING, \"No file selected\").showAndWait();\n+        }\n+    }\n+\n+    private void setupContextMenu(Node root) {\n+        ContextMenu contextMenu = new ContextMenu();\n+\n+        MenuItem defaultSceneMenuItem = new MenuItem(\"Default Scene\");\n+        defaultSceneMenuItem.setOnAction(e -> createDefaultScene());\n+        MenuItem textFieldMenuItem = new MenuItem(\"Scene with TextField\");\n+        textFieldMenuItem.setOnAction(e -> createSceneWithTextField());\n+        MenuItem tooltipBoxMenuItem = new MenuItem(\"Scene with Tooltip Box\");\n+        tooltipBoxMenuItem.setOnAction(e -> createSceneWithTooltipBox());\n+        MenuItem alertMenuItem = new MenuItem(\"Alert - Application Modal\");\n+        alertMenuItem.setOnAction(e -> createAlert(false));\n+        MenuItem alertWindowModalMenuItem = new MenuItem(\"Alert - Window Modal\");\n+        alertWindowModalMenuItem.setOnAction(e -> createAlert(true));\n+        MenuItem fileOpenMenuItem = new MenuItem(\"File Open\");\n+        fileOpenMenuItem.setOnAction(e -> createFileOpen());\n+\n+\n+        contextMenu.getItems().addAll(defaultSceneMenuItem, textFieldMenuItem, tooltipBoxMenuItem,\n+                alertMenuItem, alertWindowModalMenuItem, fileOpenMenuItem);\n+        root.setOnContextMenuRequested(e -> contextMenu.show(root, e.getScreenX(), e.getScreenY()));\n+\n+        root.setOnMousePressed(e -> {\n+            if (contextMenu.isShowing()) {\n+                contextMenu.hide();\n+            }\n+        });\n+    }\n+\n+    class PropertyEditor extends VBox {\n+        private final PropertyEditorPane stagePane = new PropertyEditorPane(\"Stage\");\n+        private final PropertyEditorPane scenePane = new PropertyEditorPane(\"Scene\");\n+\n+        private final ObjectProperty<Scene> sceneProperty = new SimpleObjectProperty<>();\n+\n+        PropertyEditor() {\n+            getChildren().addAll(stagePane, scenePane);\n+            stagePane.setMaxHeight(550);\n+            setFillWidth(true);\n+        }\n+\n+        public void bindToStage(Stage stage) {\n+            unbind();\n+\n+            stagePane.addStringProperty(\"Title\", stage.titleProperty(), stage::setTitle);\n+            stagePane.addBooleanProperty(\"Always OnTop\", stage.alwaysOnTopProperty(), stage::setAlwaysOnTop);\n+            stagePane.addBooleanProperty(\"FullScreen\", stage.fullScreenProperty(), stage::setFullScreen);\n+            stagePane.addBooleanProperty(\"Maximized\", stage.maximizedProperty(), stage::setMaximized);\n+            stagePane.addBooleanProperty(\"Iconified\", stage.iconifiedProperty(), stage::setIconified);\n+            stagePane.addBooleanProperty(\"Resizeable\", stage.resizableProperty(), stage::setResizable);\n+            stagePane.addBooleanProperty(\"Focused\", stage.focusedProperty(), null);\n+            stagePane.addDoublePropery(\"X\", stage.xProperty(), stage::setX, 0, MAX_WIDTH * 2, 1.0);\n+            stagePane.addDoublePropery(\"Y\", stage.yProperty(), stage::setY, 0, MAX_HEIGHT * 2, 1.0);\n+            stagePane.addDoublePropery(\"Width\", stage.widthProperty(), stage::setWidth, 1, MAX_WIDTH, 1.0);\n+            stagePane.addDoublePropery(\"Height\", stage.heightProperty(), stage::setHeight, 1, MAX_HEIGHT, 1.0);\n+            stagePane.addDoublePropery(\"Min Width\", stage.minWidthProperty(), stage::setMinWidth, 1, MAX_WIDTH, 1.0);\n+            stagePane.addDoublePropery(\"Min Height\", stage.minHeightProperty(), stage::setMinHeight, 1, MAX_HEIGHT,\n+                    1.0);\n+            stagePane.addDoublePropery(\"Max Width\", stage.maxWidthProperty(), stage::setMaxWidth, 1, Double.MAX_VALUE,\n+                    1.0);\n+            stagePane.addDoublePropery(\"Max Height\", stage.maxHeightProperty(), stage::setMaxHeight, 1,\n+                    Double.MAX_VALUE, 1.0);\n+            stagePane.addDoublePropery(\"RenderScale X\", stage.renderScaleXProperty(), stage::setRenderScaleX, 0, 2,\n+                    0.25);\n+            stagePane.addDoublePropery(\"RenderScale Y\", stage.renderScaleYProperty(), stage::setRenderScaleY, 0, 2,\n+                    0.25);\n+            stagePane.addDoublePropery(\"Opacity\", stage.opacityProperty(), stage::setOpacity, 0, 1, 0.1);\n+\n+            sceneProperty.bind(stage.sceneProperty());\n+            bindScene(stage.getScene());\n+\n+            sceneProperty.addListener((obs, oldScene, newScene) -> {\n+                if (newScene != null) {\n+                    bindScene(newScene);\n+                }\n+            });\n+        }\n+\n+        private void bindScene(Scene scene) {\n+            scenePane.unbind();\n+            scenePane.addDoubleLabelProperty(\"X\", scene.xProperty());\n+            scenePane.addDoubleLabelProperty(\"Y\", scene.yProperty());\n+            scenePane.addDoubleLabelProperty(\"Width\", scene.widthProperty());\n+            scenePane.addDoubleLabelProperty(\"Height\", scene.heightProperty());\n+        }\n+\n+        public void unbind() {\n+            scenePane.unbind();\n+            stagePane.unbind();\n+        }\n+    }\n+\n+    class PropertyEditorPane extends TitledPane {\n+        private int currentRow = 0;\n+        private final List<Runnable> clearChangeListeners = new ArrayList<>();\n+        private final GridPane gridPane = new GridPane();\n+\n+        PropertyEditorPane(String title) {\n+            setText(title);\n+            ScrollPane propertiesScrollPane = new ScrollPane(propertyEditor);\n+            propertiesScrollPane.setFitToWidth(true);\n+            propertiesScrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);\n+            propertiesScrollPane.setContent(gridPane);\n+\n+            gridPane.setHgap(5);\n+            gridPane.setVgap(5);\n+            gridPane.setPadding(new Insets(10));\n+\n+            setContent(propertiesScrollPane);\n+        }\n+\n+        private <T> void addListener(ReadOnlyProperty<T> property, ChangeListener<T> changeListener) {\n+            property.addListener(changeListener);\n+            clearChangeListeners.add(() -> property.removeListener(changeListener));\n+        }\n+\n+        private void addLabel(String label) {\n+            Label lbl = new Label(label);\n+            gridPane.add(lbl, 0, currentRow);\n+            GridPane.setHgrow(lbl, Priority.SOMETIMES);\n+            GridPane.setHalignment(lbl, HPos.RIGHT);\n+        }\n+\n+        public void addDoubleLabelProperty(String label, ReadOnlyDoubleProperty property) {\n+            addLabel(label);\n+            Label lbl = new Label();\n+            lbl.textProperty().bind(property.asString(\"%.2f\"));\n+            gridPane.add(lbl, 1, currentRow);\n+            GridPane.setHgrow(lbl, Priority.ALWAYS);\n+            currentRow++;\n+        }\n+\n+        public void addDoublePropery(String label, ReadOnlyDoubleProperty property, DoubleConsumer setConsumer,\n+                                      double min, double max,\n+                                      double amountToStepBy) {\n+            addLabel(label);\n+            Spinner<Double> spinner = new Spinner<>();\n+            spinner.setEditable(true);\n+            SpinnerValueFactory.DoubleSpinnerValueFactory spinnerValueFactory =\n+                    new SpinnerValueFactory.DoubleSpinnerValueFactory(min, max, property.get(), amountToStepBy);\n+            spinner.setValueFactory(spinnerValueFactory);\n+            gridPane.add(spinner, 1, currentRow);\n+            GridPane.setHgrow(spinner, Priority.ALWAYS);\n+\n+            AtomicBoolean suppressListener = new AtomicBoolean(false);\n+            addListener(property, (obs, oldValue, newValue) -> {\n+                if (!newValue.equals(spinner.getValue())) {\n+                    try {\n+                        suppressListener.set(true);\n+                        spinnerValueFactory.setValue((Double) newValue);\n+                    } finally {\n+                        suppressListener.set(false);\n+                    }\n+                }\n+            });\n+\n+            if (setConsumer != null) {\n+                spinner.valueProperty().addListener((observable, oldValue, newValue) -> {\n+                    if (!newValue.equals(oldValue) && !suppressListener.get()) {\n+                        setConsumer.accept(newValue);\n+                    }\n+                });\n+            } else {\n+                spinner.setDisable(true);\n+            }\n+\n+            currentRow++;\n+        }\n+\n+        public void addStringProperty(String label, ReadOnlyStringProperty property, Consumer<String> setConsumer) {\n+            addLabel(label);\n+            TextField textField = new TextField(property.get());\n+            gridPane.add(textField, 1, currentRow);\n+            GridPane.setHgrow(textField, Priority.ALWAYS);\n+\n+            addListener(property, (obs, oldValue, newValue) -> textField.setText(newValue));\n+\n+            if (setConsumer != null) {\n+                textField.setOnAction(e -> setConsumer.accept(textField.getText()));\n+            } else {\n+                textField.setDisable(true);\n+            }\n+            currentRow++;\n+        }\n+\n+        public void addBooleanProperty(String label, ReadOnlyBooleanProperty property, Consumer<Boolean> setConsumer) {\n+            addLabel(label);\n+            CheckBox checkBox = new CheckBox();\n+            checkBox.setSelected(property.get());\n+            gridPane.add(checkBox, 1, currentRow);\n+\n+            addListener(property, (obs, oldValue, newValue) -> checkBox.setSelected(newValue));\n+\n+            if (setConsumer != null) {\n+                checkBox.setOnAction(e -> setConsumer.accept(checkBox.isSelected()));\n+            } else {\n+                checkBox.setDisable(true);\n+            }\n+            currentRow++;\n+        }\n+\n+        public void unbind() {\n+            clearChangeListeners.forEach(Runnable::run);\n+            gridPane.getChildren().clear();\n+            currentRow = 0;\n+        }\n+    }\n+}\n","filename":"tests\/manual\/stage\/TestStage.java","additions":700,"deletions":0,"binary":false,"changes":700,"status":"added"},{"patch":"@@ -27,3 +27,0 @@\n-import static org.junit.jupiter.api.Assumptions.assumeTrue;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n@@ -41,1 +38,0 @@\n-import com.sun.javafx.PlatformUtil;\n@@ -44,0 +40,3 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n@@ -93,3 +92,0 @@\n-        \/\/ Disable on Linux until JDK-8353556 is fixed\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/RestoreSceneSizeTest.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.stage;\n+\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.layout.Region;\n+import javafx.scene.layout.StackPane;\n+import javafx.stage.Screen;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.util.Util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+\n+class CenterOnScreenTest extends StageTestBase {\n+    private static final float CENTER_ON_SCREEN_X_FRACTION = 1.0f \/ 2;\n+    private static final float CENTER_ON_SCREEN_Y_FRACTION = 1.0f \/ 3;\n+\n+    private static final double STAGE_WIDTH = 400;\n+    private static final double STAGE_HEIGHT = 200;\n+\n+    \/\/ Must be cointained in Stage dimensions\n+    private static final double SCENE_WIDTH = 300;\n+    private static final double SCENE_HEIGHT = 100;\n+\n+    private static final double DECORATED_DELTA = 50.0;\n+\n+    @Override\n+    protected Region createRoot() {\n+        StackPane stackPane = new StackPane();\n+        stackPane.setPrefSize(SCENE_WIDTH, SCENE_HEIGHT);\n+        return stackPane;\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testStageCenterOnScreenWhenShown(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, stage -> {\n+            stage.setWidth(STAGE_WIDTH);\n+            stage.setHeight(STAGE_HEIGHT);\n+        });\n+        Util.sleep(MEDIUM_WAIT);\n+        assertStageCentered(stageStyle, false);\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testStageCenterOnScreenWhenShownWithSceneSize(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, null);\n+        Util.sleep(MEDIUM_WAIT);\n+        assertStageCentered(stageStyle, true);\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testStageCenterOnScreenAfterShown(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, stage -> {\n+            stage.setWidth(STAGE_WIDTH);\n+            stage.setHeight(STAGE_HEIGHT);\n+            stage.setX(0);\n+            stage.setY(0);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+        Util.runAndWait(() -> getStage().centerOnScreen());\n+        Util.sleep(MEDIUM_WAIT);\n+        assertStageCentered(stageStyle, false);\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testStageCenterOnScreenAfterShownWithSceneSize(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, stage -> {\n+            stage.setX(0);\n+            stage.setY(0);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+        Util.runAndWait(() -> getStage().centerOnScreen());\n+        Util.sleep(MEDIUM_WAIT);\n+        assertStageCentered(stageStyle, true);\n+    }\n+\n+\n+    private void assertStageCentered(StageStyle stageStyle, boolean useSceneSize) {\n+        Screen screen = Util.getScreen(getStage());\n+\n+        double delta = (stageStyle == StageStyle.DECORATED) ? DECORATED_DELTA : SIZING_DELTA;\n+\n+        Rectangle2D bounds = screen.getVisualBounds();\n+        double centerX =\n+                bounds.getMinX() + (bounds.getWidth() - ((useSceneSize) ? SCENE_WIDTH : STAGE_WIDTH))\n+                        * CENTER_ON_SCREEN_X_FRACTION;\n+        double centerY =\n+                bounds.getMinY() + (bounds.getHeight() - ((useSceneSize) ? SCENE_HEIGHT : STAGE_HEIGHT))\n+                        * CENTER_ON_SCREEN_Y_FRACTION;\n+\n+        assertEquals(centerX, getStage().getX(), delta, \"Stage is not centered in X axis\");\n+        assertEquals(centerY, getStage().getY(), delta, \"Stage is not centered in Y axis\");\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/CenterOnScreenTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.stage;\n+\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.util.Util;\n+\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+\n+class FullScreenTest extends StageTestBase {\n+    private static final int POS_X = 100;\n+    private static final int POS_Y = 150;\n+    private static final int WIDTH = 100;\n+    private static final int HEIGHT = 150;\n+\n+    private static final Consumer<Stage> TEST_SETTINGS = s -> {\n+        s.setWidth(WIDTH);\n+        s.setHeight(HEIGHT);\n+        s.setX(POS_X);\n+        s.setY(POS_Y);\n+    };\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testFullScreenShouldKeepGeometryOnRestore(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS);\n+\n+        Util.doTimeLine(LONG_WAIT,\n+                () -> getStage().setFullScreen(true),\n+                () -> assertTrue(getStage().isFullScreen()),\n+                () -> getStage().setFullScreen(false));\n+\n+        Util.sleep(LONG_WAIT);\n+        assertSizePosition();\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testFullScreenBeforeShowShouldKeepGeometryOnRestore(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS.andThen(s -> s.setFullScreen(true)));\n+\n+        Util.sleep(LONG_WAIT);\n+        Util.runAndWait(() -> {\n+            assertTrue(getStage().isFullScreen());\n+            getStage().setFullScreen(false);\n+        });\n+\n+        Util.sleep(LONG_WAIT);\n+        assertSizePosition();\n+    }\n+\n+    private void assertSizePosition() {\n+        assertEquals(WIDTH, getStage().getWidth(), SIZING_DELTA, \"Stage's width should have remained\");\n+        assertEquals(HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Stage's height should have remained\");\n+        assertEquals(POS_X, getStage().getX(), POSITION_DELTA,  \"Stage's X position should have remained\");\n+        assertEquals(POS_Y, getStage().getY(), POSITION_DELTA, \"Stage's Y position should have remained\");\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/FullScreenTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.stage;\n+\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.util.Util;\n+\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+\n+class MaximizeTest extends StageTestBase {\n+    private static final int WIDTH = 300;\n+    private static final int HEIGHT = 300;\n+    private static final int POS_X = 100;\n+    private static final int POS_Y = 150;\n+\n+    private static final Consumer<Stage> TEST_SETTINGS = s -> {\n+        s.setWidth(WIDTH);\n+        s.setHeight(HEIGHT);\n+        s.setX(POS_X);\n+        s.setY(POS_Y);\n+    };\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"UNDECORATED\", \"TRANSPARENT\"})\n+    void testMaximizeUndecorated(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS);\n+\n+        Util.doTimeLine(SHORT_WAIT,\n+                () -> getStage().setMaximized(true),\n+                () ->  {\n+                    assertTrue(getStage().isMaximized());\n+                    assertNotEquals(POS_X, getStage().getX());\n+                    assertNotEquals(POS_Y, getStage().getY());\n+                },\n+                () -> getStage().setMaximized(false));\n+\n+        Util.sleep(SHORT_WAIT);\n+\n+        assertEquals(POS_X, getStage().getX(), POSITION_DELTA, \"Stage maximized position changed\");\n+        assertEquals(POS_Y, getStage().getY(), POSITION_DELTA, \"Stage maximized position changed\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testMaximizeKeepGeometryOnRestore(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS);\n+\n+        Util.doTimeLine(SHORT_WAIT,\n+                () -> getStage().setMaximized(true),\n+                () -> assertTrue(getStage().isMaximized()),\n+                () -> getStage().setMaximized(false));\n+\n+        Util.sleep(SHORT_WAIT);\n+        assertSizePosition();\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testMaximizeBeforeShowShouldKeepGeometryOnRestore(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS.andThen(s -> s.setMaximized(true)));\n+        Util.sleep(SHORT_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            assertTrue(getStage().isMaximized());\n+            getStage().setMaximized(false);\n+        });\n+        Util.sleep(SHORT_WAIT);\n+        assertSizePosition();\n+    }\n+\n+    private void assertSizePosition() {\n+        assertEquals(WIDTH, getStage().getWidth(), SIZING_DELTA, \"Stage's width should have remained\");\n+        assertEquals(HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Stage's height should have remained\");\n+        assertEquals(POS_X, getStage().getX(), POSITION_DELTA, \"Stage's X position should have remained\");\n+        assertEquals(POS_Y, getStage().getY(), POSITION_DELTA, \"Stage's Y position should have remained\");\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/MaximizeTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.javafx.stage;\n-\n-import java.util.concurrent.CountDownLatch;\n-import javafx.application.Application;\n-import javafx.application.Platform;\n-import javafx.scene.Group;\n-import javafx.scene.Scene;\n-import javafx.stage.Stage;\n-import javafx.stage.StageStyle;\n-import javafx.stage.WindowEvent;\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.Test;\n-import test.util.Util;\n-\n-public class MaximizeUndecorated {\n-    static CountDownLatch startupLatch = new CountDownLatch(1);\n-    static Stage stage;\n-    static final int POS = 500;\n-\n-    public static class TestApp extends Application {\n-        @Override\n-        public void start(Stage primaryStage) throws Exception {\n-            primaryStage.setScene(new Scene(new Group()));\n-            stage = primaryStage;\n-            stage.addEventHandler(WindowEvent.WINDOW_SHOWN, e ->\n-                    Platform.runLater(startupLatch::countDown));\n-            stage.initStyle(StageStyle.UNDECORATED);\n-            stage.setX(POS);\n-            stage.setY(POS);\n-            stage.setOnShown(e -> stage.setMaximized(true));\n-            stage.show();\n-        }\n-    }\n-\n-    @BeforeAll\n-    public static void initFX() {\n-        Util.launch(startupLatch, TestApp.class);\n-    }\n-\n-    @AfterAll\n-    public static void teardown() {\n-        Util.shutdown();\n-    }\n-\n-    @Test\n-    public void testMaximize() throws Exception {\n-        Util.sleep(200);\n-\n-        boolean movedToTopCorner = stage.getY() != POS && stage.getX() != POS;\n-        Assertions.assertTrue(movedToTopCorner, \"Stage has moved to desktop top corner\");\n-    }\n-}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/MaximizeUndecorated.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -123,1 +123,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -135,1 +134,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -147,1 +145,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -159,1 +156,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -171,1 +167,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -184,1 +179,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -197,1 +191,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -210,1 +203,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/SizeToSceneTest.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,366 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.stage;\n+\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.ReadOnlyDoubleProperty;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.Region;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.layout.VBox;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.util.Util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+\n+class SizingTest extends StageTestBase {\n+    private static final int WIDTH = 300;\n+    private static final int HEIGHT = 300;\n+    private static final int MAX_WIDTH = 350;\n+    private static final int MAX_HEIGHT = 350;\n+    private static final int MIN_WIDTH = 500;\n+    private static final int MIN_HEIGHT = 500;\n+    private static final int NEW_WIDTH = 450;\n+    private static final int NEW_HEIGHT = 450;\n+\n+\n+    protected Label createLabel(String prefix, ReadOnlyDoubleProperty property) {\n+        Label label = new Label();\n+        label.textProperty().bind(Bindings.concat(prefix, Bindings.convert(property)));\n+        return label;\n+    }\n+\n+    @Override\n+    protected Region createRoot() {\n+        VBox vBox = new VBox(createLabel(\"Width: \", getStage().widthProperty()),\n+                createLabel(\"Height: \", getStage().heightProperty()),\n+                createLabel(\"Max Width: \", getStage().maxWidthProperty()),\n+                createLabel(\"Max Height: \", getStage().maxHeightProperty()),\n+                createLabel(\"Min Width: \", getStage().minWidthProperty()),\n+                createLabel(\"Min Height: \", getStage().minHeightProperty()));\n+        vBox.setBackground(Background.EMPTY);\n+\n+        return vBox;\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testMaximizeUnresizable(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.setWidth(WIDTH);\n+            s.setHeight(HEIGHT);\n+            s.setResizable(false);\n+        });\n+        Util.runAndWait(() -> getStage().setMaximized(true));\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertTrue(getStage().isMaximized(), \"Unresizable stage should be maximized\");\n+        assertTrue(getStage().getWidth() > WIDTH, \"Stage width should be maximized\");\n+        assertTrue(getStage().getHeight() > HEIGHT, \"Stage height should be maximized\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testFullScreenUnresizable(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.setWidth(WIDTH);\n+            s.setHeight(HEIGHT);\n+            s.setResizable(false);\n+        });\n+\n+        Util.runAndWait(() -> getStage().setFullScreen(true));\n+        Util.sleep(LONG_WAIT);\n+        assertTrue(getStage().isFullScreen(), \"Unresizable stage should be fullscreen\");\n+        assertTrue(getStage().getWidth() > WIDTH, \"Stage width should be fullscreen\");\n+        assertTrue(getStage().getHeight() > HEIGHT, \"Stage height should be fullscreen\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testResizeUnresizable(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.setWidth(WIDTH);\n+            s.setHeight(HEIGHT);\n+            s.setResizable(false);\n+        });\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA, \"Stage should have resized\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Stage should have resized\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testMaxSize(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.setMaxWidth(MAX_WIDTH);\n+            s.setMaxHeight(MAX_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(MAX_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been limited to max width\");\n+        assertEquals(MAX_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been limited to max height\");\n+\n+        \/\/ Reset it\n+        Util.runAndWait(() -> {\n+            getStage().setMaxWidth(Double.MAX_VALUE);\n+            getStage().setMaxHeight(Double.MAX_VALUE);\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been accepted after removing min width\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been accepted after removing min height\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testMaxWidth(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.initStyle(stageStyle);\n+            s.setMaxWidth(MAX_WIDTH);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(MAX_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been limited to max width\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Only max width should be limited\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testMaxHeight(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> s.setMaxHeight(MAX_HEIGHT));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA, \"Only max height should be limited\");\n+        assertEquals(MAX_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been limited to max height\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testMinSize(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.setMinWidth(MIN_WIDTH);\n+            s.setMinHeight(MIN_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(MIN_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been limited to min width\");\n+        assertEquals(MIN_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been limited to min height\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testMinWidth(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> s.setMinWidth(MIN_WIDTH));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(MIN_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been limited to min width\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Only min width should be limited\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testMinHeight(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> s.setMinHeight(MIN_HEIGHT));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA, \"Only min height should be limited\");\n+        assertEquals(MIN_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been limited to min height\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testNoSize(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, null);\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertTrue(getStage().getWidth() > 1, \"Stage width should be greater than 1\");\n+        assertTrue(getStage().getHeight() > 1, \"Stage height should be greater than 1\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testNoHeight(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> s.setWidth(WIDTH));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(WIDTH, getStage().getWidth(), SIZING_DELTA, \"Stage do not match the set width\");\n+        assertTrue(getStage().getHeight() > 1, \"Stage height should be greater than 1\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testNoWidth(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> s.setHeight(HEIGHT));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertTrue(getStage().getWidth() > 1, \"Stage width should be greater than 1\");\n+        assertEquals(HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Stage do not match the set height\");\n+    }\n+\n+    @Test\n+    void testSceneSizeOnly() {\n+        setupStageWithStyle(StageStyle.DECORATED, s -> s.setScene(new Scene(new StackPane(), WIDTH, HEIGHT)));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(WIDTH, getScene().getWidth(), SIZING_DELTA,\n+                \"Scene width should not be affected by decoration if stage width not set\");\n+        assertEquals(HEIGHT, getScene().getHeight(), SIZING_DELTA,\n+                \"Scene height should not be affected by decoration if stage height not set\");\n+    }\n+\n+    @Test\n+    void testSceneWidthWithWindowHeight() {\n+        setupStageWithStyle(StageStyle.DECORATED, s -> {\n+            s.setScene(new Scene(new StackPane(), WIDTH, HEIGHT));\n+            s.setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(WIDTH, getScene().getWidth(),\n+                \"Scene width should not be affected by decoration if stage width not set\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Stage height should match the new height\");\n+    }\n+\n+    @Test\n+    void testSceneHeightWithWindowWidth() {\n+        setupStageWithStyle(StageStyle.DECORATED, s -> {\n+            s.setScene(new Scene(new StackPane(), WIDTH, HEIGHT));\n+            s.setWidth(NEW_WIDTH);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA, \"Stage with should match the set new width\");\n+        assertEquals(HEIGHT, getScene().getHeight(),\n+                \"Scene height should not be affected by decoration if stage height not set\");\n+    }\n+\n+    @Test\n+    void testSceneSizeThenStageSize() {\n+        setupStageWithStyle(StageStyle.DECORATED, s -> s.setScene(new Scene(new StackPane(), WIDTH, HEIGHT)));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Scene width should match the new stage width\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Scene height should match the new stage height\");\n+\n+        Util.runAndWait(() -> getStage().setScene(new Scene(new StackPane(), WIDTH, HEIGHT)));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Scene width should remain unchanged after setting a new scene\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Scene height should remain unchanged after setting a new scene\");\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/SizingTest.java","additions":366,"deletions":0,"binary":false,"changes":366,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.stage;\n+\n+import javafx.application.Platform;\n+import javafx.geometry.Insets;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.BackgroundFill;\n+import javafx.scene.layout.CornerRadii;\n+import javafx.scene.layout.Region;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import test.util.Util;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+abstract class StageTestBase {\n+    private static final CountDownLatch startupLatch = new CountDownLatch(1);\n+    private Stage stage = null;\n+\n+    protected static final int SHORT_WAIT = 300;\n+    protected static final int MEDIUM_WAIT = 500;\n+    protected static final int LONG_WAIT = 1000;\n+    protected static final double SIZING_DELTA = 1.0;\n+    protected static final double POSITION_DELTA = 1.0;\n+\n+    \/**\n+     * Creates a Scene for the test stage acoording to the {@link StageStyle}\n+     * @param stageStyle {@link StageStyle} of the Stage\n+     * @return a {@link Scene}\n+     *\/\n+    protected Scene createScene(StageStyle stageStyle) {\n+        if (stageStyle == StageStyle.TRANSPARENT) {\n+            Region root = createRoot();\n+            BackgroundFill fill = new BackgroundFill(\n+                    Color.HOTPINK.deriveColor(0, 1, 1, 0.5),\n+                    CornerRadii.EMPTY,\n+                    Insets.EMPTY\n+            );\n+            root.setBackground(new Background(fill));\n+\n+            Scene scene = new Scene(root);\n+            scene.setFill(Color.TRANSPARENT);\n+\n+            return scene;\n+        }\n+\n+        return new Scene(createRoot(), Color.HOTPINK);\n+    }\n+\n+    \/**\n+     * Gets the Scene root\n+     *\/\n+    protected Region createRoot() {\n+        return new StackPane();\n+    }\n+\n+    \/**\n+     * Utility method to setup test Stages according to {@link StageStyle}\n+     * @param stageStyle The Stage Style.\n+     * @param pc A consumer to set state properties\n+     *\/\n+    protected void setupStageWithStyle(StageStyle stageStyle, Consumer<Stage> pc) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            assertNull(stage, \"Stage is not null\");\n+            stage = new Stage();\n+            stage.setAlwaysOnTop(true);\n+            stage.initStyle(stageStyle);\n+            stage.setScene(createScene(stageStyle));\n+            if (pc != null) {\n+                pc.accept(stage);\n+            }\n+            stage.setOnShown(e -> shownLatch.countDown());\n+            stage.show();\n+        });\n+\n+        Util.waitForLatch(shownLatch, 5, \"Stage failed to show\");\n+    }\n+\n+    @BeforeAll\n+    public static void initFX() {\n+        Platform.setImplicitExit(false);\n+        Util.startup(startupLatch, startupLatch::countDown);\n+    }\n+\n+    @AfterAll\n+    public static void teardown() {\n+        Util.shutdown();\n+    }\n+\n+    \/**\n+     * Hides the test stage after each test\n+     *\/\n+    @AfterEach\n+    public void cleanup() {\n+        if (stage != null) {\n+            CountDownLatch hideLatch = new CountDownLatch(1);\n+            stage.setOnHidden(e -> hideLatch.countDown());\n+            Util.runAndWait(stage::hide);\n+            Util.waitForLatch(hideLatch, 5, \"Stage failed to hide\");\n+            stage = null;\n+        }\n+    }\n+\n+    \/**\n+     * @return The stage that is created for each test\n+     *\/\n+    protected Stage getStage() {\n+        return stage;\n+    }\n+\n+    \/**\n+     * Gets the Scene of the test stage.\n+     * @return The Scene of the test stage.\n+     *\/\n+    protected Scene getScene() {\n+        return stage.getScene();\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/StageTestBase.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -150,4 +150,0 @@\n-        if (PlatformUtil.isLinux()) {\n-            Assumptions.assumeTrue(Boolean.getBoolean(\"unstable.test\")); \/\/ JDK-8321624\n-        }\n-\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/DualWindowTest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,1 +129,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ Skip due to JDK-8316891\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/IconifyTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,5 +28,0 @@\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assumptions.assumeTrue;\n-import static test.util.Util.TIMEOUT;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n@@ -39,2 +34,2 @@\n-import org.junit.jupiter.api.Test;\n-import com.sun.javafx.PlatformUtil;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n@@ -43,0 +38,7 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+import static test.util.Util.TIMEOUT;\n+\n@@ -53,0 +55,3 @@\n+    private static final int WAIT = 1000;\n+    private static final int SHORT_WAIT = 100;\n+\n@@ -57,1 +62,2 @@\n-    private void setupStages(boolean overlayed, boolean topShown) throws InterruptedException {\n+    private void setupStages(boolean overlayed, boolean topShown, StageStyle topStageStyle)\n+            throws InterruptedException {\n@@ -79,1 +85,1 @@\n-            topStage.initStyle(StageStyle.DECORATED);\n+            topStage.initStyle(topStageStyle);\n@@ -100,1 +106,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -103,7 +109,4 @@\n-    @Test\n-    public void testIconifiedStage() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(true, true);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(value = StageStyle.class, mode = EnumSource.Mode.INCLUDE, names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testIconifiedStage(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(true, true, stageStyle);\n@@ -119,1 +122,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -128,7 +131,4 @@\n-    @Test\n-    public void testMaximizedStage() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(false, true);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testMaximizedStage(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(false, true, stageStyle);\n@@ -144,1 +144,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -154,0 +154,5 @@\n+        \/\/ Do not test decorations for UNDECORATED\n+        if (stageStyle.equals(StageStyle.UNDECORATED)) {\n+            return;\n+        }\n+\n@@ -156,1 +161,1 @@\n-        sleep(100);\n+        sleep(SHORT_WAIT);\n@@ -166,7 +171,4 @@\n-    @Test\n-    public void testFullScreenStage() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(false, true);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testFullScreenStage(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(false, true, stageStyle);\n@@ -182,1 +184,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -194,1 +196,1 @@\n-        sleep(100);\n+        sleep(SHORT_WAIT);\n@@ -203,7 +205,4 @@\n-    @Test\n-    public void testIconifiedStageBeforeShow() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(true, false);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testIconifiedStageBeforeShow(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(true, false, stageStyle);\n@@ -221,1 +220,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -232,8 +231,4 @@\n-    @Test\n-    public void testMaximizedStageBeforeShow() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        \/\/  - JDK-8316425\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(false, false);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testMaximizedStageBeforeShow(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(false, false, stageStyle);\n@@ -250,1 +245,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -260,0 +255,6 @@\n+\n+        \/\/ Do not test decorations for UNDECORATED\n+        if (stageStyle.equals(StageStyle.UNDECORATED)) {\n+            return;\n+        }\n+\n@@ -262,1 +263,1 @@\n-        sleep(100);\n+        sleep(SHORT_WAIT);\n@@ -272,8 +273,4 @@\n-    @Test\n-    public void testFullScreenStageBeforeShow() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        \/\/  - JDK-8316425\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(false, false);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testFullScreenStageBeforeShow(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(false, false, stageStyle);\n@@ -290,1 +287,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -302,1 +299,1 @@\n-        sleep(100);\n+        sleep(SHORT_WAIT);\n@@ -310,1 +307,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageAttributesTest.java","additions":62,"deletions":65,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.robot.javafx.stage;\n+\n+import javafx.application.Platform;\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.ReadOnlyDoubleProperty;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.robot.testharness.VisualTestBase;\n+import test.util.Util;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+\n+class StageLocationTest extends VisualTestBase {\n+    private static final int WIDTH = 300;\n+    private static final int HEIGHT = 300;\n+    private static final int X = 100;\n+    private static final int Y = 100;\n+    private static final int TO_X = 500;\n+    private static final int TO_Y = 500;\n+    private static final Color COLOR = Color.RED;\n+    private static final double TOLERANCE = 0.07;\n+    private static final int WAIT = 300;\n+\n+    private Stage createStage(StageStyle stageStyle) {\n+        Stage s = getStage(true);\n+        s.initStyle(stageStyle);\n+        VBox vBox = new VBox(createLabel(\"X: \", s.xProperty()),\n+                createLabel(\"Y: \", s.yProperty()));\n+        vBox.setBackground(Background.EMPTY);\n+        Scene scene = new Scene(vBox, WIDTH, HEIGHT);\n+        scene.setFill(COLOR);\n+        s.setScene(scene);\n+        s.setWidth(WIDTH);\n+        s.setHeight(HEIGHT);\n+        return s;\n+    }\n+\n+    protected Label createLabel(String prefix, ReadOnlyDoubleProperty property) {\n+        Label label = new Label();\n+        label.textProperty().bind(Bindings.concat(prefix, Bindings.convert(property)));\n+        return label;\n+    }\n+\n+    private void assertColorEquals(Color expected, int x, int y) {\n+        Color color = getColor(x, y);\n+        assertColorEquals(expected, color, TOLERANCE);\n+    }\n+\n+    private Stage stage;\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"UTILITY\"})\n+    void testMove(StageStyle stageStyle) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            stage = createStage(stageStyle);\n+            stage.setX(X);\n+            stage.setY(Y);\n+            stage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            stage.show();\n+        });\n+\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT);\n+\n+        Util.doTimeLine(WAIT,\n+                () -> assertColorEquals(COLOR, X + 100, Y + 100),\n+                () -> {\n+                    stage.setX(TO_X);\n+                    stage.setY(TO_Y);\n+                },\n+                () -> assertColorEquals(COLOR, TO_X + 100, TO_Y + 100));\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"UTILITY\"})\n+    void testMoveXAxis(StageStyle stageStyle) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            stage = createStage(stageStyle);\n+            stage.setX(X);\n+            stage.setY(Y);\n+            stage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            stage.show();\n+        });\n+\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT);\n+\n+        Util.doTimeLine(WAIT,\n+                () -> assertColorEquals(COLOR, X + 100, Y + 100),\n+                () -> stage.setX(TO_X),\n+                () -> assertColorEquals(COLOR, TO_X + 100, Y + 100));\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"UTILITY\"})\n+    void testMoveYAxis(StageStyle stageStyle) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            stage = createStage(stageStyle);\n+            stage.setX(X);\n+            stage.setY(Y);\n+            stage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            stage.show();\n+        });\n+\n+\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT);\n+\n+        Util.doTimeLine(WAIT,\n+                () -> assertColorEquals(COLOR, X + 100, Y + 100),\n+                () -> stage.setY(TO_Y),\n+                () -> assertColorEquals(COLOR, X + 100, TO_Y + 100));\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"UTILITY\"})\n+    void testMoveAfterShow(StageStyle stageStyle) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            stage = createStage(stageStyle);\n+            stage.setX(X);\n+            stage.setY(Y);\n+            stage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            stage.show();\n+        });\n+\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT);\n+\n+        Util.doTimeLine(WAIT,\n+                () -> {\n+                    stage.setX(TO_X);\n+                    stage.setY(TO_Y);\n+                },\n+                () -> assertColorEquals(COLOR, TO_X + 100, TO_Y + 100));\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageLocationTest.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n-import javafx.animation.KeyFrame;\n-import javafx.animation.Timeline;\n-import javafx.geometry.Insets;\n+import javafx.application.Platform;\n@@ -32,4 +30,1 @@\n-import javafx.scene.layout.Background;\n-import javafx.scene.layout.BackgroundFill;\n-import javafx.scene.layout.CornerRadii;\n-import javafx.scene.layout.Pane;\n+import javafx.scene.layout.StackPane;\n@@ -39,3 +34,2 @@\n-import javafx.util.Duration;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n@@ -43,0 +37,1 @@\n+import test.util.Util;\n@@ -44,1 +39,0 @@\n-import java.util.Map;\n@@ -46,1 +40,0 @@\n-import java.util.concurrent.TimeUnit;\n@@ -48,2 +41,2 @@\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static test.util.Util.TIMEOUT;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n@@ -51,1 +44,1 @@\n-public class StageMixedSizeTest extends VisualTestBase {\n+class StageMixedSizeTest extends VisualTestBase {\n@@ -54,0 +47,1 @@\n+    private static final int WAIT = 300;\n@@ -56,3 +50,3 @@\n-    @Test\n-    public void testSetWidthOnlyAfterShownOnContentSizeWindow() throws Exception {\n-        CountDownLatch latch = new CountDownLatch(1);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    void testSetWidthOnlyAfterShownOnContentSizeWindow(StageStyle stageStyle) {\n@@ -62,3 +56,1 @@\n-        setupContentSizeTestStage(initialContentSize, initialContentSize,\n-                () -> doTimeLine(Map.of(500L, () -> testStage.setWidth(finalWidth),\n-                                        1000L, latch::countDown)));\n+        setupContentSizeTestStage(stageStyle, initialContentSize, initialContentSize);\n@@ -66,5 +58,5 @@\n-        assertTrue(latch.await(TIMEOUT, TimeUnit.MILLISECONDS), \"Timeout waiting for test stage to be shown\");\n-\n-        runAndWait(() -> assertColorDoesNotEqual(BACKGROUND_COLOR,\n-                getColor(initialContentSize - 10, initialContentSize \/ 2), TOLERANCE));\n-        Assertions.assertEquals(finalWidth, testStage.getWidth(), \"Window width should be \" + finalWidth);\n+        Util.doTimeLine(WAIT,\n+                () -> testStage.setWidth(finalWidth),\n+                () -> assertColorDoesNotEqual(BACKGROUND_COLOR,\n+                        getColor(initialContentSize - 10, initialContentSize \/ 2), TOLERANCE),\n+                () -> assertEquals(finalWidth, testStage.getWidth(), \"Window width should be \" + finalWidth));\n@@ -73,3 +65,3 @@\n-    @Test\n-    public void testSetHeightOnlyAfterShownOnContentSizeWindow() throws Exception {\n-        CountDownLatch latch = new CountDownLatch(1);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    void testSetHeightOnlyAfterShownOnContentSizeWindow(StageStyle stageStyle) {\n@@ -79,5 +71,1 @@\n-        setupContentSizeTestStage(initialContentSize, initialContentSize,\n-                () -> doTimeLine(Map.of(500L, () -> testStage.setHeight(finalHeight),\n-                                        1000L, latch::countDown)));\n-\n-        assertTrue(latch.await(TIMEOUT, TimeUnit.MILLISECONDS), \"Timeout waiting for test stage to be shown\");\n+        setupContentSizeTestStage(stageStyle, initialContentSize, initialContentSize);\n@@ -85,3 +73,5 @@\n-        runAndWait(() -> assertColorDoesNotEqual(BACKGROUND_COLOR,\n-                getColor(initialContentSize \/ 2, initialContentSize - 10), TOLERANCE));\n-        Assertions.assertEquals(finalHeight, testStage.getHeight(), \"Window height should be \" + finalHeight);\n+        Util.doTimeLine(WAIT,\n+                () -> testStage.setHeight(finalHeight),\n+                () -> assertColorDoesNotEqual(BACKGROUND_COLOR,\n+                        getColor(initialContentSize \/ 2, initialContentSize - 10), TOLERANCE),\n+                () -> assertEquals(finalHeight, testStage.getHeight(), \"Window height should be \" + finalHeight));\n@@ -90,15 +80,13 @@\n-    private void setupContentSizeTestStage(int width, int height, Runnable onShown) {\n-        runAndWait(() -> {\n-            testStage = getStage(true);\n-            testStage.initStyle(StageStyle.TRANSPARENT);\n-            Pane pane = new Pane();\n-            pane.setPrefSize(width, height);\n-            pane.setBackground(new Background(new BackgroundFill(BACKGROUND_COLOR, CornerRadii.EMPTY, Insets.EMPTY)));\n-            Scene scene = new Scene(pane);\n-            testStage.setScene(scene);\n-            testStage.setX(0);\n-            testStage.setY(0);\n-            testStage.setOnShown(e -> onShown.run());\n-            testStage.show();\n-        });\n-    }\n+    private void setupContentSizeTestStage(StageStyle stageStyle, int width, int height) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+\n+        Util.runAndWait(() -> {\n+                    testStage = getStage(true);\n+                    testStage.initStyle(stageStyle);\n+                    Scene scene = new Scene(new StackPane(), width, height, BACKGROUND_COLOR);\n+                    testStage.setScene(scene);\n+                    testStage.setX(0);\n+                    testStage.setY(0);\n+                    testStage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+                    testStage.show();\n+                });\n@@ -106,6 +94,2 @@\n-    private void doTimeLine(Map<Long, Runnable> keyFrames) {\n-        Timeline timeline = new Timeline();\n-        timeline.setCycleCount(1);\n-        keyFrames.forEach((duration, runnable) ->\n-                timeline.getKeyFrames().add(new KeyFrame(Duration.millis(duration), e -> runnable.run())));\n-        timeline.play();\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT);\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageMixedSizeTest.java","additions":43,"deletions":59,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.robot.javafx.stage;\n+\n+import javafx.application.Platform;\n+import javafx.beans.binding.Bindings;\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Modality;\n+import javafx.stage.Screen;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import test.robot.testharness.VisualTestBase;\n+import test.util.Util;\n+\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+import static test.util.Util.TIMEOUT;\n+\n+class StageOwnershipTest extends VisualTestBase {\n+    private static final int WIDTH = 200;\n+    private static final int HEIGHT = 200;\n+    private static final double BOUNDS_EDGE_DELTA = 75;\n+    private Stage topStage;\n+    private Stage bottomStage;\n+    private static final Color TOP_COLOR = Color.RED;\n+    private static final Color BOTTOM_COLOR = Color.LIME;\n+    private static final Color COLOR0 = Color.RED;\n+    private static final Color COLOR1 = Color.ORANGE;\n+    private static final Color COLOR2 = Color.YELLOW;\n+    private static final int X_DELTA = 15; \/\/ shadows\n+    private static final int Y_DELTA = 75; \/\/ shadows + decoration\n+\n+    private static final double TOLERANCE = 0.07;\n+    private static final int WAIT_TIME = 500;\n+\n+    private void setupBottomStage() throws InterruptedException {\n+        final CountDownLatch shownLatch = new CountDownLatch(1);\n+\n+        runAndWait(() -> {\n+            bottomStage = getStage(false);\n+            bottomStage.initStyle(StageStyle.DECORATED);\n+            Scene bottomScene = new Scene(getFocusedLabel(BOTTOM_COLOR, bottomStage), WIDTH, HEIGHT);\n+            bottomScene.setFill(BOTTOM_COLOR);\n+            bottomStage.setScene(bottomScene);\n+            bottomStage.setX(0);\n+            bottomStage.setY(0);\n+            bottomStage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            bottomStage.show();\n+        });\n+        assertTrue(shownLatch.await(TIMEOUT, TimeUnit.MILLISECONDS),\n+                \"Timeout waiting for bottom stage to be shown\");\n+\n+        sleep(WAIT_TIME);\n+    }\n+\n+    private void setupTopStage(Stage owner, StageStyle stageStyle, Modality modality) {\n+        runAndWait(() -> {\n+            topStage = getStage(true);\n+            if (stageStyle != null) {\n+                topStage.initStyle(stageStyle);\n+            }\n+            Scene topScene = new Scene(getFocusedLabel(TOP_COLOR, topStage), WIDTH, HEIGHT);\n+            topScene.setFill(TOP_COLOR);\n+            topStage.setScene(topScene);\n+            if (owner != null) {\n+                topStage.initOwner(owner);\n+            }\n+            if (modality != null) {\n+                topStage.initModality(modality);\n+            }\n+            topStage.setWidth(WIDTH);\n+            topStage.setHeight(HEIGHT);\n+            topStage.setX(0);\n+            topStage.setY(0);\n+        });\n+    }\n+\n+    private void assertColorEqualsVisualBounds(Color expected) {\n+        Rectangle2D visualBounds = Screen.getPrimary().getVisualBounds();\n+        int x = (int) (visualBounds.getWidth() - BOUNDS_EDGE_DELTA);\n+        int y = (int) (visualBounds.getHeight() - BOUNDS_EDGE_DELTA);\n+\n+        Color color = getColor(x, y);\n+        assertColorEquals(expected, color, TOLERANCE);\n+    }\n+\n+    private Stage createStage(StageStyle stageStyle, Color color, Stage owner, Modality modality, int x, int y) {\n+        Stage stage = getStage(true);\n+        stage.initStyle(stageStyle);\n+        StackPane pane = getFocusedLabel(color, stage);\n+        Scene scene = new Scene(pane, WIDTH, HEIGHT);\n+        scene.setFill(color);\n+        stage.setScene(scene);\n+        stage.setWidth(WIDTH);\n+        stage.setHeight(HEIGHT);\n+        if (x != -1) {\n+            stage.setX(x);\n+        }\n+        if (y != -1) {\n+            stage.setY(y);\n+        }\n+        if (owner != null) {\n+            stage.initOwner(owner);\n+        }\n+        stage.initModality(modality);\n+        return stage;\n+    }\n+\n+    private static StackPane getFocusedLabel(Color color, Stage stage) {\n+        Label label = new Label();\n+        label.textProperty().bind(Bindings.when(stage.focusedProperty())\n+                .then(\"Focused\").otherwise(\"Unfocused\"));\n+        StackPane pane = new StackPane(label);\n+        pane.setBackground(Background.EMPTY);\n+\n+        double luminance = 0.2126 * color.getRed()\n+                + 0.7152 * color.getGreen()\n+                + 0.0722 * color.getBlue();\n+\n+        Color textColor = luminance < 0.5 ? Color.WHITE : Color.BLACK;\n+\n+        label.setTextFill(textColor);\n+        return pane;\n+    }\n+\n+    private void assertColorEquals(Color expected, Stage stage) {\n+        Color color = getColor((int) stage.getX() + X_DELTA, (int) stage.getY() + Y_DELTA);\n+        assertColorEquals(expected, color, TOLERANCE);\n+    }\n+\n+    private void assertColorDoesNotEqual(Color notExpected, Stage stage) {\n+        Color color = getColor((int) stage.getX() + X_DELTA, (int) stage.getY() + Y_DELTA);\n+        assertColorDoesNotEqual(notExpected, color, TOLERANCE);\n+    }\n+\n+    private static Stream<Arguments> getTestsParams() {\n+        return Stream.of(StageStyle.DECORATED, StageStyle.UNDECORATED)\n+                .flatMap(stageStyle -> Stream.of(Modality.APPLICATION_MODAL, Modality.WINDOW_MODAL)\n+                        .map(modality -> Arguments.of(stageStyle, modality)));\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @MethodSource(\"getTestsParams\")\n+    void testOpeningModalChildStageWhileMaximizedShouldHaveFocus(StageStyle stageStyle, Modality modality)\n+            throws InterruptedException {\n+        setupBottomStage();\n+        setupTopStage(bottomStage, stageStyle, modality);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                () -> bottomStage.setMaximized(true),\n+                topStage::show,\n+                () -> {\n+                    assertTrue(bottomStage.isMaximized());\n+                    \/\/ Make sure state is still maximized\n+                    assertColorEqualsVisualBounds(BOTTOM_COLOR);\n+\n+                    Color color = getColor(100, 100);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+                });\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @MethodSource(\"getTestsParams\")\n+    void testOpeningModalChildStageWhileFullSceenShouldHaveFocus(StageStyle stageStyle, Modality modality)\n+            throws InterruptedException {\n+        setupBottomStage();\n+        setupTopStage(bottomStage, stageStyle, modality);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                () -> bottomStage.setFullScreen(true),\n+                topStage::show,\n+                () -> {\n+                    assertTrue(bottomStage.isFullScreen());\n+\n+                    \/\/ Make sure state is still fullscreen\n+                    assertColorEqualsVisualBounds(BOTTOM_COLOR);\n+\n+                    Color color = getColor(100, 100);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+                });\n+    }\n+\n+    private Stage stage0;\n+    private Stage stage1;\n+    private Stage stage2;\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @MethodSource(\"getTestsParams\")\n+    void testClosingModalWindowShouldFocusParent(StageStyle style, Modality modality) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            stage0 = createStage(style, COLOR0, null, null, 100, 100);\n+            stage1 = createStage(style, COLOR1, stage0, null, 150, 150);\n+            stage2 = createStage(style, COLOR2, stage1, modality, 200, 200);\n+\n+            stage0.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            stage0.show();\n+        });\n+\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT_TIME);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                stage1::show,\n+                stage2::show,\n+                () -> {\n+                    assertTrue(stage2.isFocused());\n+                    assertColorEquals(COLOR2, stage2);\n+                    assertFalse(stage1.isFocused());\n+                    assertFalse(stage0.isFocused());\n+                },\n+                stage2::close,\n+                () -> {\n+                    assertTrue(stage1.isFocused());\n+                    assertColorEquals(COLOR1, stage1);\n+                    assertFalse(stage0.isFocused());\n+                },\n+                stage1::close,\n+                () -> {\n+                    assertTrue(stage0.isFocused());\n+                    assertColorEquals(COLOR0, stage0);\n+                });\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    void testIconifyParentShouldHideChildren(StageStyle style) {\n+        CountDownLatch shownLatch = new CountDownLatch(3);\n+        Util.runAndWait(() -> {\n+            stage0 = createStage(style, COLOR0, null, null, 100, 100);\n+            stage1 = createStage(style, COLOR1, stage0, null, 150, 150);\n+            stage2 = createStage(style, COLOR2, stage1, null, 200, 200);\n+\n+            List.of(stage0, stage1, stage2).forEach(stage -> {\n+                stage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+                stage.show();\n+            });\n+        });\n+\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT_TIME);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+                () -> stage0.setIconified(true),\n+                () -> {\n+                    assertTrue(stage0.isIconified());\n+                    assertColorDoesNotEqual(COLOR0, stage0);\n+                    assertColorDoesNotEqual(COLOR1, stage1);\n+                    assertColorDoesNotEqual(COLOR2, stage2);\n+                },\n+                () -> stage0.setIconified(false),\n+                () -> {\n+                    assertFalse(stage0.isIconified());\n+                    assertColorEquals(COLOR0, stage0);\n+                    assertColorEquals(COLOR1, stage1);\n+                    assertColorEquals(COLOR2, stage2);\n+                });\n+    }\n+\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageOwnershipTest.java","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n@@ -40,0 +42,1 @@\n+import java.util.concurrent.ExecutionException;\n@@ -41,0 +44,4 @@\n+import java.util.concurrent.TimeoutException;\n+\n+import javafx.animation.KeyFrame;\n+import javafx.animation.Timeline;\n@@ -50,0 +57,1 @@\n+import javafx.stage.Stage;\n@@ -51,0 +59,1 @@\n+import javafx.util.Duration;\n@@ -58,0 +67,2 @@\n+    public static final String PARAMETERIZED_TEST_DISPLAY = \"{displayName} [{index}] {arguments}\";\n+\n@@ -456,0 +467,90 @@\n+\n+    \/**\n+     * Creates a {@link Timeline} where each {@link KeyFrame} runs a {@link Runnable}.\n+     * Each {@link Runnable} will be scheduled at an increment of {@code msToIncrement} milliseconds.\n+     *\n+     * @param msToIncrement the number of milliseconds to increment between each {@link KeyFrame}\n+     * @param runnables     the list of {@link Runnable} instances to execute sequentially\n+     *\/\n+    public static void doTimeLine(int msToIncrement, Runnable... runnables) {\n+        long millis = msToIncrement;\n+\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+\n+        Timeline timeline = new Timeline();\n+        timeline.setCycleCount(1);\n+        for (Runnable runnable : runnables) {\n+            timeline.getKeyFrames().add(new KeyFrame(Duration.millis(millis), e -> {\n+                try {\n+                    runnable.run();\n+                } catch (Throwable ex) {\n+                    future.completeExceptionally(ex);\n+                }\n+            }));\n+            millis += msToIncrement;\n+        }\n+        timeline.setOnFinished(e -> future.complete(null));\n+        timeline.play();\n+\n+        final long waitms = millis + 5000;\n+\n+        try {\n+            future.get(waitms, TimeUnit.MILLISECONDS);\n+        } catch (ExecutionException | InterruptedException | TimeoutException ex) {\n+            throwError(ex);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a {@link Timeline} where each {@link KeyFrame} executes a {@link Runnable}.\n+     *\n+     * @param runnables a {@link Map} where the key is the {@link Duration} at which to trigger the action,\n+     *                  and the value is the {@link Runnable} to execute at that time\n+     *\/\n+    public static void doTimeLine(Map<Duration, Runnable> runnables) {\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+\n+        Timeline timeline = new Timeline();\n+        timeline.setCycleCount(1);\n+        Duration totalDuration = Duration.seconds(5);\n+\n+        for (Map.Entry<Duration, Runnable> entry : runnables.entrySet()) {\n+            Duration duration = entry.getKey();\n+            Runnable runnable = entry.getValue();\n+            totalDuration = totalDuration.add(duration);\n+            timeline.getKeyFrames().add(new KeyFrame(duration, e -> {\n+                try {\n+                    runnable.run();\n+                } catch (Throwable ex) {\n+                    future.completeExceptionally(ex);\n+                }\n+            }));\n+        }\n+\n+        timeline.setOnFinished(e -> future.complete(null));\n+        timeline.play();\n+\n+        long waitms = (long) totalDuration.toMillis();\n+        try {\n+            future.get(waitms, TimeUnit.MILLISECONDS);\n+        } catch (ExecutionException | InterruptedException | TimeoutException ex) {\n+            throwError(ex);\n+        }\n+    }\n+\n+    \/**\n+     * Finds the {@link Screen} where the top-left corner of the given {@link Stage} is located.\n+     *\n+     * @param stage the {@link Stage} to check\n+     * @return the {@link Screen} containing the stage's top-left corner or {@link Screen#getPrimary()}\n+     *\/\n+    public static Screen getScreen(Stage stage) {\n+        for (Screen screen : Screen.getScreens()) {\n+            Rectangle2D bounds = screen.getVisualBounds();\n+            if (bounds.contains(stage.getX(), stage.getY())) {\n+                return screen;\n+            }\n+        }\n+\n+        return Screen.getPrimary();\n+    }\n","filename":"tests\/system\/src\/test\/java\/test\/util\/Util.java","additions":102,"deletions":1,"binary":false,"changes":103,"status":"modified"}]}