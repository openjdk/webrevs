{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.glass.events.ViewEvent;\n@@ -101,0 +102,2 @@\n+    protected native void enterFullscreenImpl(long ptr, boolean animate, boolean keepRatio, boolean hideCursor);\n+\n@@ -102,1 +105,9 @@\n-    protected native boolean _enterFullscreen(long ptr, boolean animate, boolean keepRatio, boolean hideCursor);\n+    protected boolean _enterFullscreen(long ptr, boolean animate, boolean keepRatio, boolean hideCursor) {\n+        enterFullscreenImpl(ptr, animate, keepRatio, hideCursor);\n+\n+        if (getWindow() != null && !getWindow().isVisible()) {\n+            notifyView(ViewEvent.FULLSCREEN_ENTER);\n+        }\n+\n+        return true;\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkView.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -86,1 +86,3 @@\n-    protected native void _setAlpha(long ptr, float alpha);\n+    protected void _setAlpha(long ptr, float alpha) {\n+        \/\/ Not supported\n+    }\n@@ -89,1 +91,4 @@\n-    protected native boolean _setBackground(long ptr, float r, float g, float b);\n+    protected boolean _setBackground(long ptr, float r, float g, float b) {\n+        \/\/Not supported\n+        return false;\n+    }\n@@ -131,2 +136,6 @@\n-        notifyStateChanged(WindowEvent.MINIMIZE);\n-        return minimize;\n+\n+        if (!isVisible()) {\n+            notifyStateChanged(WindowEvent.MINIMIZE);\n+        }\n+\n+        return isMinimized();\n@@ -139,2 +148,6 @@\n-        notifyStateChanged(WindowEvent.MAXIMIZE);\n-        return maximize;\n+\n+        if (!isVisible()) {\n+            notifyStateChanged(WindowEvent.MAXIMIZE);\n+        }\n+\n+        return isMaximized();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkWindow.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -485,2 +485,0 @@\n-                    \/\/ let gtk handle it first to prevent a glitch\n-                    gtk_main_do_event(event);\n@@ -488,0 +486,1 @@\n+                    gtk_main_do_event(event);\n@@ -490,1 +489,0 @@\n-                    ctx->process_configure(&event->configure);\n@@ -492,0 +490,1 @@\n+                    ctx->process_configure(&event->configure);\n@@ -506,1 +505,1 @@\n-                    ctx->process_expose(&event->expose);\n+                    ctx->notify_repaint(&event->expose.area);\n@@ -509,1 +508,1 @@\n-                    ctx->process_state(&event->window_state);\n+                    \/\/ Let gtk handle it first, so state functions are updated\n@@ -511,0 +510,1 @@\n+                    ctx->process_state(&event->window_state);\n@@ -538,1 +538,2 @@\n-                    \/\/ fall-through\n+                    ctx->process_map();\n+                    break;\n@@ -553,0 +554,1 @@\n+        \/\/FIXME: Those do not work anymore\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassApplication.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -274,2 +274,2 @@\n- * Method:    _enterFullscreen\n- * Signature: (JZZZ)Z\n+ * Method:    enterFullscreenImpl\n+ * Signature: (JZZZ)V\n@@ -277,3 +277,2 @@\n-JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkView__1enterFullscreen\n-  (JNIEnv * env, jobject obj, jlong ptr, jboolean animate, jboolean keepRation, jboolean hideCursor)\n-{\n+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkView_enterFullscreenImpl\n+  (JNIEnv * env, jobject obj, jlong ptr, jboolean animate, jboolean keepRation, jboolean hideCursor) {\n@@ -287,2 +286,0 @@\n-        env->CallVoidMethod(obj, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER);\n-        CHECK_JNI_EXCEPTION_RET(env, JNI_FALSE)\n@@ -290,1 +287,0 @@\n-    return JNI_TRUE;\n@@ -310,2 +306,0 @@\n-        env->CallVoidMethod(obj, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT);\n-        CHECK_JNI_EXCEPTION(env)\n@@ -313,1 +307,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassView.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    WindowContext* ctx = new WindowContextTop(obj,\n+    WindowContext* ctx = new WindowContext(obj,\n@@ -315,31 +315,0 @@\n-\/*\n- * Class:     com_sun_glass_ui_gtk_GtkWindow\n- * Method:    _setAlpha\n- * Signature: (JF)V\n- *\/\n-JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setAlpha\n-  (JNIEnv * env, jobject obj, jlong ptr, jfloat alpha)\n-{\n-    (void)env;\n-    (void)obj;\n-\n-    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n-    ctx->set_alpha(alpha);\n-}\n-\n-\/*\n- * Class:     com_sun_glass_ui_gtk_GtkWindow\n- * Method:    _setBackground\n- * Signature: (JFFF)Z\n- *\/\n-JNIEXPORT jboolean JNICALL Java_com_sun_glass_ui_gtk_GtkWindow__1setBackground\n-  (JNIEnv * env, jobject obj, jlong ptr, jfloat r, jfloat g, jfloat b)\n-{\n-    (void)env;\n-    (void)obj;\n-\n-    WindowContext* ctx = JLONG_TO_WINDOW_CTX(ptr);\n-    ctx->set_background(r, g, b);\n-    return JNI_TRUE;\n-}\n-\n@@ -391,2 +360,0 @@\n-    if (w == -1) w = G_MAXSHORT;\n-    if (h == -1) h = G_MAXSHORT;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassWindow.cpp","additions":1,"deletions":34,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -83,2 +83,0 @@\n-jmethodID jGtkWindowNotifyStateChanged;\n-\n@@ -272,3 +270,0 @@\n-    jGtkWindowNotifyStateChanged =\n-            env->GetMethodID(clazz, \"notifyStateChanged\", \"(I)V\");\n-    if (env->ExceptionCheck()) return JNI_ERR;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -197,2 +197,0 @@\n-    extern jmethodID jGtkWindowNotifyStateChanged; \/\/ com.sun.glass.ui.GtkWindow#notifyStateChanged (I)V\n-\n@@ -252,0 +250,2 @@\n+#define LOG10(msg, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10) \\\n+    {printf(msg, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10);fflush(stdout);}\n@@ -267,0 +267,1 @@\n+#define LOG10(msg, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10)\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"glass_evloop.h\"\n@@ -35,1 +36,0 @@\n-\n@@ -38,1 +38,0 @@\n-#include <X11\/extensions\/shape.h>\n@@ -40,2 +39,0 @@\n-#include <cairo-xlib.h>\n-#include <gdk\/gdkx.h>\n@@ -43,3 +40,0 @@\n-#ifdef GLASS_GTK3\n-#include <gtk\/gtkx.h>\n-#endif\n@@ -48,1 +42,0 @@\n-\n@@ -50,0 +43,1 @@\n+#include <optional>\n@@ -54,2 +48,109 @@\n-WindowContext * WindowContextBase::sm_grab_window = NULL;\n-WindowContext * WindowContextBase::sm_mouse_drag_window = NULL;\n+#define NONNEGATIVE_OR(val, fallback) (((val) < 0) ? (fallback) : (val))\n+\n+#define DEFAULT_WIDTH 320\n+#define DEFAULT_HEIGHT 200\n+\n+static gboolean event_realize(GtkWidget *widget, gpointer user_data) {\n+    WindowContext *ctx = USER_PTR_TO_CTX(user_data);\n+    ctx->process_realize();\n+\n+    return FALSE;\n+}\n+\n+gboolean enter_fullscreen_later(gpointer data) {\n+    GtkWindow *window = GTK_WINDOW(data);\n+\n+    \/\/ might have been destroyed\n+    if (GTK_IS_WINDOW(window)) {\n+        gtk_window_fullscreen(window);\n+    }\n+\n+    return G_SOURCE_REMOVE;\n+}\n+\n+static void process_pending_events() {\n+    while (gtk_events_pending()) {\n+        gtk_main_iteration_do(FALSE);\n+    }\n+}\n+\n+void destroy_and_delete_ctx(WindowContext* ctx) {\n+    LOG0(\"destroy_and_delete_ctx\\n\");\n+    if (ctx) {\n+        ctx->process_destroy();\n+\n+        if (!ctx->get_events_count()) {\n+            LOG0(\"delete ctx\\n\");\n+            delete ctx;\n+        }\n+        \/\/ else: ctx will be deleted in EventsCounterHelper after completing\n+        \/\/ an event processing\n+    }\n+}\n+\n+static gboolean is_window_floating(GdkWindowState state) {\n+    return !(state & GDK_WINDOW_STATE_MAXIMIZED)\n+        && !(state & GDK_WINDOW_STATE_FULLSCREEN);\n+}\n+\n+static inline jint gtk_button_number_to_mouse_button(guint button) {\n+    switch (button) {\n+        case 1:\n+            return com_sun_glass_events_MouseEvent_BUTTON_LEFT;\n+        case 2:\n+            return com_sun_glass_events_MouseEvent_BUTTON_OTHER;\n+        case 3:\n+            return com_sun_glass_events_MouseEvent_BUTTON_RIGHT;\n+        case MOUSE_BACK_BTN:\n+            return com_sun_glass_events_MouseEvent_BUTTON_BACK;\n+        case MOUSE_FORWARD_BTN:\n+            return com_sun_glass_events_MouseEvent_BUTTON_FORWARD;\n+        default:\n+            \/\/ Other buttons are not supported by quantum and are not reported by other platforms\n+            return com_sun_glass_events_MouseEvent_BUTTON_NONE;\n+    }\n+}\n+\n+WindowContext * WindowContext::sm_grab_window = NULL;\n+WindowContext * WindowContext::sm_mouse_drag_window = NULL;\n+\n+\/\/ Work-around because frame extents are only obtained after window is shown.\n+\/\/ This is used to know the total window size (content + decoration)\n+\/\/ The first window will have a duplicated resize event, subsequent windows will use the cached value.\n+std::optional<GdkRectangle> WindowContext::normal_extents;\n+std::optional<GdkRectangle> WindowContext::utility_extents;\n+\n+WindowContext::WindowContext(jobject _jwindow, WindowContext* _owner, long _screen,\n+        WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :\n+            screen(_screen),\n+            frame_type(_frame_type),\n+            window_type(type),\n+            owner(_owner),\n+            geometry(),\n+            resizable(),\n+            im_ctx() {\n+    jwindow = mainEnv->NewGlobalRef(_jwindow);\n+    initial_wmf = wmf;\n+    current_wmf = wmf;\n+    \/\/ Default to white\n+    is_mouse_entered = false;\n+    is_disabled = false;\n+    on_top = false;\n+    can_be_deleted = false;\n+    was_mapped = false;\n+    initial_state_mask = 0;\n+\n+    gtk_widget = gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);\n+    g_signal_connect(G_OBJECT(gtk_widget), \"realize\", G_CALLBACK(event_realize), this);\n+\n+    if (gchar* app_name = get_application_name()) {\n+        gtk_window_set_wmclass(GTK_WINDOW(gtk_widget), app_name, app_name);\n+        g_free(app_name);\n+    }\n+\n+    if (owner) {\n+        owner->add_child(this);\n+        if (on_top_inherited()) {\n+            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);\n+        }\n+    }\n@@ -57,2 +158,26 @@\n-GdkWindow* WindowContextBase::get_gdk_window(){\n-    return gdk_window;\n+    if (type == UTILITY) {\n+        gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_UTILITY);\n+    }\n+\n+    glong xvisualID = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);\n+\n+    if (xvisualID != 0) {\n+        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);\n+        glass_gtk_window_configure_from_visual(gtk_widget, visual);\n+    }\n+\n+    gtk_widget_set_app_paintable(gtk_widget, TRUE);\n+\n+    glass_configure_window_transparency(gtk_widget, frame_type == TRANSPARENT);\n+    gtk_window_set_title(GTK_WINDOW(gtk_widget), \"\");\n+\n+    gtk_window_set_decorated(GTK_WINDOW(gtk_widget), frame_type == TITLED);\n+    load_cached_extents();\n+}\n+\n+GdkWindow* WindowContext::get_gdk_window() {\n+    if (GDK_IS_WINDOW(gdk_window)) {\n+        return gdk_window;\n+    }\n+\n+    return NULL;\n@@ -61,1 +186,1 @@\n-jobject WindowContextBase::get_jview() {\n+jobject WindowContext::get_jview() {\n@@ -65,1 +190,1 @@\n-jobject WindowContextBase::get_jwindow() {\n+jobject WindowContext::get_jwindow() {\n@@ -69,1 +194,1 @@\n-bool WindowContextBase::isEnabled() {\n+bool WindowContext::isEnabled() {\n@@ -79,5 +204,3 @@\n-void WindowContextBase::notify_state(jint glass_state) {\n-    if (glass_state == com_sun_glass_events_WindowEvent_RESTORE) {\n-        if (is_maximized) {\n-            glass_state = com_sun_glass_events_WindowEvent_MAXIMIZE;\n-        }\n+void WindowContext::process_map() {\n+    \/\/ We need only first map\n+    if (was_mapped || window_type == POPUP) return;\n@@ -85,9 +208,2 @@\n-        int w, h;\n-        glass_gdk_window_get_size(gdk_window, &w, &h);\n-        if (jview) {\n-            mainEnv->CallVoidMethod(jview,\n-                    jViewNotifyRepaint,\n-                    0, 0, w, h);\n-            CHECK_JNI_EXCEPTION(mainEnv);\n-        }\n-    }\n+    was_mapped = true;\n+    LOG0(\"--------------------------------------------------------> mapped\\n\");\n@@ -95,5 +211,3 @@\n-    if (jwindow) {\n-       mainEnv->CallVoidMethod(jwindow,\n-               jGtkWindowNotifyStateChanged,\n-               glass_state);\n-       CHECK_JNI_EXCEPTION(mainEnv);\n+    \/\/ Work around JDK-8337400 (Initial window position is not centered on Xorg)\n+    if (geometry.x > 0 || geometry.y > 0) {\n+        move(geometry.x, geometry.y);\n@@ -101,4 +215,0 @@\n-}\n-\n-void WindowContextBase::process_state(GdkEventWindowState* event) {\n-    if (event->changed_mask & (GDK_WINDOW_STATE_ICONIFIED | GDK_WINDOW_STATE_MAXIMIZED)) {\n@@ -106,7 +216,3 @@\n-        if (event->changed_mask & GDK_WINDOW_STATE_ICONIFIED) {\n-            is_iconified = event->new_window_state & GDK_WINDOW_STATE_ICONIFIED;\n-        }\n-\n-        if (event->changed_mask & GDK_WINDOW_STATE_MAXIMIZED) {\n-            is_maximized = event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED;\n-        }\n+    if (geometry.width <= 0) {\n+        geometry.width = DEFAULT_WIDTH - geometry.extents.width;\n+    }\n@@ -114,1 +220,3 @@\n-        jint stateChangeEvent;\n+    if (geometry.height <= 0) {\n+        geometry.height = DEFAULT_HEIGHT - geometry.extents.height;\n+    }\n@@ -116,13 +224,1 @@\n-        if (is_iconified) {\n-            stateChangeEvent = com_sun_glass_events_WindowEvent_MINIMIZE;\n-        } else if (is_maximized) {\n-            stateChangeEvent = com_sun_glass_events_WindowEvent_MAXIMIZE;\n-        } else {\n-            stateChangeEvent = com_sun_glass_events_WindowEvent_RESTORE;\n-            if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0\n-                || (gdk_windowManagerFunctions & GDK_FUNC_MAXIMIZE) == 0) {\n-                \/\/ in this case - the window manager will not support the programatic\n-                \/\/ request to iconify \/ maximize - so we need to restore it now.\n-                gdk_window_set_functions(gdk_window, gdk_windowManagerFunctions);\n-            }\n-        }\n+    resize(geometry.width, geometry.height);\n@@ -130,3 +226,4 @@\n-        notify_state(stateChangeEvent);\n-    } else if (event->changed_mask & GDK_WINDOW_STATE_ABOVE) {\n-        notify_on_top(event->new_window_state & GDK_WINDOW_STATE_ABOVE);\n+    \/\/ Work-around for Xorg initial state before show to work\n+    if (initial_state_mask != 0) {\n+        process_pending_events();\n+        update_initial_state();\n@@ -136,2 +233,2 @@\n-void WindowContextBase::process_focus(GdkEventFocus* event) {\n-    if (!event->in && WindowContextBase::sm_grab_window == this) {\n+void WindowContext::process_focus(GdkEventFocus *event) {\n+    if (!event->in && WindowContext::sm_grab_window == this) {\n@@ -163,1 +260,1 @@\n-void WindowContextBase::increment_events_counter() {\n+void WindowContext::increment_events_counter() {\n@@ -167,1 +264,1 @@\n-void WindowContextBase::decrement_events_counter() {\n+void WindowContext::decrement_events_counter() {\n@@ -171,1 +268,1 @@\n-size_t WindowContextBase::get_events_count() {\n+size_t WindowContext::get_events_count() {\n@@ -175,1 +272,1 @@\n-bool WindowContextBase::is_dead() {\n+bool WindowContext::is_dead() {\n@@ -179,3 +276,2 @@\n-void destroy_and_delete_ctx(WindowContext* ctx) {\n-    if (ctx) {\n-        ctx->process_destroy();\n+void WindowContext::process_destroy() {\n+    LOG0(\"process_destroy\\n\");\n@@ -183,5 +279,2 @@\n-        if (!ctx->get_events_count()) {\n-            delete ctx;\n-        }\n-        \/\/ else: ctx will be deleted in EventsCounterHelper after completing\n-        \/\/ an event processing\n+    if (owner) {\n+        owner->remove_child(this);\n@@ -189,1 +282,0 @@\n-}\n@@ -191,2 +283,1 @@\n-void WindowContextBase::process_destroy() {\n-    if (WindowContextBase::sm_mouse_drag_window == this) {\n+    if (WindowContext::sm_mouse_drag_window == this) {\n@@ -196,1 +287,1 @@\n-    if (WindowContextBase::sm_grab_window == this) {\n+    if (WindowContext::sm_grab_window == this) {\n@@ -200,1 +291,1 @@\n-    std::set<WindowContextTop*>::iterator it;\n+    std::set<WindowContext*>::iterator it;\n@@ -203,1 +294,1 @@\n-        \/\/ WindowContextTop::process_destroy() to call remove_child() (because children\n+        \/\/ WindowContext::process_destroy() to call remove_child() (because children\n@@ -230,1 +321,2 @@\n-void WindowContextBase::process_delete() {\n+void WindowContext::process_delete() {\n+    LOG0(\"process_delete\\n\");\n@@ -232,0 +324,1 @@\n+        LOG0(\"jWindowNotifyClose\\n\");\n@@ -237,1 +330,1 @@\n-void WindowContextBase::process_expose(GdkEventExpose* event) {\n+void WindowContext::notify_repaint(GdkRectangle *rect) {\n@@ -239,1 +332,1 @@\n-        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, event->area.x, event->area.y, event->area.width, event->area.height);\n+        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, rect->x, rect->y, rect->width, rect->height);\n@@ -244,19 +337,1 @@\n-static inline jint gtk_button_number_to_mouse_button(guint button) {\n-    switch (button) {\n-        case 1:\n-            return com_sun_glass_events_MouseEvent_BUTTON_LEFT;\n-        case 2:\n-            return com_sun_glass_events_MouseEvent_BUTTON_OTHER;\n-        case 3:\n-            return com_sun_glass_events_MouseEvent_BUTTON_RIGHT;\n-        case MOUSE_BACK_BTN:\n-            return com_sun_glass_events_MouseEvent_BUTTON_BACK;\n-        case MOUSE_FORWARD_BTN:\n-            return com_sun_glass_events_MouseEvent_BUTTON_FORWARD;\n-        default:\n-            \/\/ Other buttons are not supported by quantum and are not reported by other platforms\n-            return com_sun_glass_events_MouseEvent_BUTTON_NONE;\n-    }\n-}\n-\n-void WindowContextBase::process_mouse_button(GdkEventButton* event) {\n+void WindowContext::process_mouse_button(GdkEventButton *event) {\n@@ -340,1 +415,1 @@\n-void WindowContextBase::process_mouse_motion(GdkEventMotion* event) {\n+void WindowContext::process_mouse_motion(GdkEventMotion *event) {\n@@ -350,1 +425,1 @@\n-    if (isDrag && WindowContextBase::sm_mouse_drag_window == NULL) {\n+    if (isDrag && WindowContext::sm_mouse_drag_window == NULL) {\n@@ -383,1 +458,1 @@\n-void WindowContextBase::process_mouse_scroll(GdkEventScroll* event) {\n+void WindowContext::process_mouse_scroll(GdkEventScroll *event) {\n@@ -423,1 +498,0 @@\n-\n@@ -426,1 +500,1 @@\n-void WindowContextBase::process_mouse_cross(GdkEventCrossing* event) {\n+void WindowContext::process_mouse_cross(GdkEventCrossing *event) {\n@@ -449,1 +523,1 @@\n-void WindowContextBase::process_key(GdkEventKey* event) {\n+void WindowContext::process_key(GdkEventKey *event) {\n@@ -486,0 +560,1 @@\n+    \/\/ TYPED events should only be sent for printable characters.\n@@ -487,1 +562,1 @@\n-    if (press && key > 0 && jview) { \/\/ TYPED events should only be sent for printable characters.\n+    if (press && key > 0 && jview) {\n@@ -497,2 +572,1 @@\n-void WindowContextBase::paint(void* data, jint width, jint height) {\n-#ifdef GLASS_GTK3\n+void WindowContext::paint(void* data, jint width, jint height) {\n@@ -502,1 +576,1 @@\n-#endif\n+\n@@ -517,1 +591,0 @@\n-#ifdef GLASS_GTK3\n@@ -520,1 +593,0 @@\n-#endif\n@@ -526,1 +598,1 @@\n-void WindowContextBase::add_child(WindowContextTop* child) {\n+void WindowContext::add_child(WindowContext* child) {\n@@ -531,1 +603,1 @@\n-void WindowContextBase::remove_child(WindowContextTop* child) {\n+void WindowContext::remove_child(WindowContext* child) {\n@@ -536,21 +608,1 @@\n-void WindowContextBase::set_visible(bool visible) {\n-    if (visible) {\n-        gtk_widget_show(gtk_widget);\n-    } else {\n-        gtk_widget_hide(gtk_widget);\n-        if (jview && is_mouse_entered) {\n-            is_mouse_entered = false;\n-            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n-                    com_sun_glass_events_MouseEvent_EXIT,\n-                    com_sun_glass_events_MouseEvent_BUTTON_NONE,\n-                    0, 0,\n-                    0, 0,\n-                    0,\n-                    JNI_FALSE,\n-                    JNI_FALSE);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n-    }\n-}\n-\n-bool WindowContextBase::is_visible() {\n+bool WindowContext::is_visible() {\n@@ -560,1 +612,1 @@\n-bool WindowContextBase::set_view(jobject view) {\n+bool WindowContext::set_view(jobject view) {\n@@ -581,1 +633,1 @@\n-bool WindowContextBase::grab_mouse_drag_focus() {\n+bool WindowContext::grab_mouse_drag_focus() {\n@@ -584,1 +636,1 @@\n-        WindowContextBase::sm_mouse_drag_window = this;\n+        WindowContext::sm_mouse_drag_window = this;\n@@ -591,2 +643,2 @@\n-void WindowContextBase::ungrab_mouse_drag_focus() {\n-    WindowContextBase::sm_mouse_drag_window = NULL;\n+void WindowContext::ungrab_mouse_drag_focus() {\n+    WindowContext::sm_mouse_drag_window = NULL;\n@@ -594,2 +646,2 @@\n-    if (WindowContextBase::sm_grab_window) {\n-        WindowContextBase::sm_grab_window->grab_focus();\n+    if (WindowContext::sm_grab_window) {\n+        WindowContext::sm_grab_window->grab_focus();\n@@ -599,2 +651,2 @@\n-bool WindowContextBase::grab_focus() {\n-    if (WindowContextBase::sm_mouse_drag_window\n+bool WindowContext::grab_focus() {\n+    if (WindowContext::sm_mouse_drag_window\n@@ -602,1 +654,1 @@\n-        WindowContextBase::sm_grab_window = this;\n+        WindowContext::sm_grab_window = this;\n@@ -609,2 +661,2 @@\n-void WindowContextBase::ungrab_focus() {\n-    if (!WindowContextBase::sm_mouse_drag_window) {\n+void WindowContext::ungrab_focus() {\n+    if (!WindowContext::sm_mouse_drag_window) {\n@@ -613,1 +665,1 @@\n-    WindowContextBase::sm_grab_window = NULL;\n+    WindowContext::sm_grab_window = NULL;\n@@ -621,1 +673,1 @@\n-void WindowContextBase::set_cursor(GdkCursor* cursor) {\n+void WindowContext::set_cursor(GdkCursor* cursor) {\n@@ -623,1 +675,1 @@\n-        if (WindowContextBase::sm_mouse_drag_window) {\n+        if (WindowContext::sm_mouse_drag_window) {\n@@ -625,2 +677,2 @@\n-                    WindowContextBase::sm_mouse_drag_window->get_gdk_window(), cursor, FALSE);\n-        } else if (WindowContextBase::sm_grab_window) {\n+                    WindowContext::sm_mouse_drag_window->get_gdk_window(), cursor, FALSE);\n+        } else if (WindowContext::sm_grab_window) {\n@@ -628,1 +680,1 @@\n-                    WindowContextBase::sm_grab_window->get_gdk_window(), cursor, TRUE);\n+                    WindowContext::sm_grab_window->get_gdk_window(), cursor, TRUE);\n@@ -634,3 +686,6 @@\n-void WindowContextBase::set_background(float r, float g, float b) {\n-    GdkRGBA rgba = {r, g, b, 1.};\n-    gtk_widget_override_background_color(gtk_widget, GTK_STATE_FLAG_NORMAL, &rgba);\n+GdkAtom WindowContext::get_net_frame_extents_atom() {\n+    static GdkAtom atom = NULL;\n+    if (atom == NULL) {\n+        atom = gdk_atom_intern_static_string(\"_NET_FRAME_EXTENTS\");\n+    }\n+    return atom;\n@@ -639,4 +694,3 @@\n-WindowContextBase::~WindowContextBase() {\n-    disableIME();\n-    gtk_widget_destroy(gtk_widget);\n-}\n+void WindowContext::request_frame_extents() {\n+    Display *display = GDK_DISPLAY_XDISPLAY(gdk_window_get_display(gdk_window));\n+    static Atom rfeAtom = XInternAtom(display, \"_NET_REQUEST_FRAME_EXTENTS\", False);\n@@ -644,1 +698,3 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ WindowContextTop \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    if (rfeAtom != None) {\n+        XClientMessageEvent clientMessage;\n+        memset(&clientMessage, 0, sizeof(clientMessage));\n@@ -646,0 +702,4 @@\n+        clientMessage.type = ClientMessage;\n+        clientMessage.window = GDK_WINDOW_XID(gdk_window);\n+        clientMessage.message_type = rfeAtom;\n+        clientMessage.format = 32;\n@@ -647,5 +707,6 @@\n-\/\/ Work-around because frame extents are only obtained after window is shown.\n-\/\/ This is used to know the total window size (content + decoration)\n-\/\/ The first window will have a duplicated resize event, subsequent windows will use the cached value.\n-WindowFrameExtents WindowContextTop::normal_extents = {0, 0, 0, 0};\n-WindowFrameExtents WindowContextTop::utility_extents = {0, 0, 0, 0};\n+        XSendEvent(display, XDefaultRootWindow(display), False,\n+                   SubstructureRedirectMask | SubstructureNotifyMask,\n+                   (XEvent *) &clientMessage);\n+        XFlush(display);\n+    }\n+}\n@@ -653,0 +714,5 @@\n+void WindowContext::update_window_size_location() {\n+    if (!geometry.needs_to_restore_geometry\n+        || (gdk_window_get_state(gdk_window) & (GDK_WINDOW_STATE_FULLSCREEN | GDK_WINDOW_STATE_MAXIMIZED))) {\n+        return;\n+    }\n@@ -654,3 +720,5 @@\n-static void event_realize(GtkWidget* self, gpointer user_data) {\n-    WindowContextTop *ctx = ((WindowContextTop *) user_data);\n-    ctx->process_realize();\n+    process_pending_events();\n+    geometry.needs_to_restore_geometry = false;\n+    move(geometry.x, geometry.y);\n+    LOG2(\"update_window_size_location: %d, %d\\n\", geometry.width, geometry.height);\n+    resize(geometry.width, geometry.height);\n@@ -659,7 +727,2 @@\n-static int geometry_get_window_width(const WindowGeometry *windowGeometry) {\n-     return (windowGeometry->final_width.type == BOUNDSTYPE_WINDOW)\n-                   ? windowGeometry->final_width.value\n-                   : windowGeometry->final_width.value\n-                         + windowGeometry->extents.left\n-                         + windowGeometry->extents.right;\n-}\n+void WindowContext::update_initial_state() {\n+    GdkWindowState state = gdk_window_get_state(gdk_window);\n@@ -667,7 +730,4 @@\n-static int geometry_get_window_height(const WindowGeometry *windowGeometry) {\n-    return (windowGeometry->final_height.type == BOUNDSTYPE_WINDOW)\n-                   ? windowGeometry->final_height.value\n-                   : windowGeometry->final_height.value\n-                         + windowGeometry->extents.top\n-                         + windowGeometry->extents.bottom;\n-}\n+    if (initial_state_mask & GDK_WINDOW_STATE_MAXIMIZED) {\n+        LOG0(\"update_initial_state: maximized\\n\");\n+        maximize(true);\n+    }\n@@ -675,7 +735,4 @@\n-static int geometry_get_content_width(WindowGeometry *windowGeometry) {\n-    return (windowGeometry->final_width.type == BOUNDSTYPE_CONTENT)\n-                   ? windowGeometry->final_width.value\n-                   : windowGeometry->final_width.value\n-                         - windowGeometry->extents.left\n-                         - windowGeometry->extents.right;\n-}\n+    if (initial_state_mask & GDK_WINDOW_STATE_FULLSCREEN) {\n+        LOG0(\"update_initial_state: fullscreen\\n\");\n+        enter_fullscreen();\n+    }\n@@ -683,7 +740,4 @@\n-static int geometry_get_content_height(WindowGeometry *windowGeometry) {\n-    return (windowGeometry->final_height.type == BOUNDSTYPE_CONTENT)\n-                   ? windowGeometry->final_height.value\n-                   : windowGeometry->final_height.value\n-                         - windowGeometry->extents.top\n-                         - windowGeometry->extents.bottom;\n-}\n+    if (initial_state_mask & GDK_WINDOW_STATE_ICONIFIED) {\n+        LOG0(\"update_initial_state: iconify\\n\");\n+        iconify(true);\n+    }\n@@ -691,3 +745,1 @@\n-static GdkAtom get_net_frame_extents_atom() {\n-    static const char * extents_str = \"_NET_FRAME_EXTENTS\";\n-    return gdk_atom_intern(extents_str, FALSE);\n+    initial_state_mask = 0;\n@@ -696,13 +748,0 @@\n-WindowContextTop::WindowContextTop(jobject _jwindow, WindowContext* _owner, long _screen,\n-        WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :\n-            WindowContextBase(),\n-            screen(_screen),\n-            frame_type(_frame_type),\n-            window_type(type),\n-            owner(_owner),\n-            geometry(),\n-            resizable(),\n-            on_top(false),\n-            is_fullscreen(false) {\n-    jwindow = mainEnv->NewGlobalRef(_jwindow);\n-    gdk_windowManagerFunctions = wmf;\n@@ -710,2 +749,2 @@\n-    gtk_widget = gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);\n-    g_signal_connect(G_OBJECT(gtk_widget), \"realize\", G_CALLBACK(event_realize), this);\n+void WindowContext::update_frame_extents() {\n+    if (frame_type != TITLED) return;\n@@ -713,4 +752,1 @@\n-    if (gchar* app_name = get_application_name()) {\n-        gtk_window_set_wmclass(GTK_WINDOW(gtk_widget), app_name, app_name);\n-        g_free(app_name);\n-    }\n+    int top, left, bottom, right;\n@@ -718,6 +754,6 @@\n-    if (owner) {\n-        owner->add_child(this);\n-        if (on_top_inherited()) {\n-            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);\n-        }\n-    }\n+    if (get_frame_extents_property(&top, &left, &bottom, &right)) {\n+        if (top > 0 || right > 0 || bottom > 0 || left > 0) {\n+            bool changed = geometry.extents.x != left\n+                        || geometry.extents.y != top\n+                        || geometry.extents.width != (left + right)\n+                        || geometry.extents.height != (top + bottom);\n@@ -725,3 +761,1 @@\n-    if (type == UTILITY) {\n-        gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_UTILITY);\n-    }\n+            LOG1(\" ------------------------------------------- frame extents - changed: %d\\n\", changed);\n@@ -729,2 +763,1 @@\n-    const char* wm_name = gdk_x11_screen_get_window_manager_name(gdk_screen_get_default());\n-    wmanager = (g_strcmp0(\"Compiz\", wm_name) == 0) ? COMPIZ : UNKNOWN;\n+            if (!changed) return;\n@@ -732,3 +765,2 @@\n-\/\/    glong xdisplay = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationDisplay);\n-\/\/    gint  xscreenID = (gint)mainEnv->GetStaticIntField(jApplicationCls, jApplicationScreen);\n-    glong xvisualID = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);\n+            GdkRectangle rect = { left, top, (left + right), (top + bottom) };\n+            set_cached_extents(rect);\n@@ -736,4 +768,3 @@\n-    if (xvisualID != 0) {\n-        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);\n-        glass_gtk_window_configure_from_visual(gtk_widget, visual);\n-    }\n+            if (geometry.width <= 0 && geometry.height <= 0) {\n+                return;\n+            }\n@@ -741,2 +772,2 @@\n-    gtk_widget_set_events(gtk_widget, GDK_FILTERED_EVENTS_MASK);\n-    gtk_widget_set_app_paintable(gtk_widget, TRUE);\n+            int newW = gdk_window_get_width(gdk_window);\n+            int newH = gdk_window_get_height(gdk_window);\n@@ -744,2 +775,2 @@\n-    glass_configure_window_transparency(gtk_widget, frame_type == TRANSPARENT);\n-    gtk_window_set_title(GTK_WINDOW(gtk_widget), \"\");\n+            \/\/ Here the user might change the desktop theme and in consequence\n+            \/\/ change decoration sizes.\n@@ -747,6 +778,4 @@\n-    if (frame_type != TITLED) {\n-        gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);\n-    } else {\n-        geometry.extents = get_cached_extents();\n-    }\n-}\n+            \/\/ Re-add the extents and then subtract the new\n+            newW = newW\n+                + ((geometry.frame_extents_received) ? geometry.extents.width : 0)\n+                - rect.width;\n@@ -754,11 +783,4 @@\n-\/\/ Applied to a temporary full screen window to prevent sending events to Java\n-void WindowContextTop::detach_from_java() {\n-    if (jview) {\n-        mainEnv->DeleteGlobalRef(jview);\n-        jview = NULL;\n-    }\n-    if (jwindow) {\n-        mainEnv->DeleteGlobalRef(jwindow);\n-        jwindow = NULL;\n-    }\n-}\n+            \/\/ Re-add the extents and then subtract the new\n+            newH = newH\n+                + ((geometry.frame_extents_received) ? geometry.extents.height : 0)\n+                - rect.height;\n@@ -766,3 +788,2 @@\n-void WindowContextTop::request_frame_extents() {\n-    Display *display = GDK_DISPLAY_XDISPLAY(gdk_window_get_display(gdk_window));\n-    static Atom rfeAtom = XInternAtom(display, \"_NET_REQUEST_FRAME_EXTENTS\", False);\n+            newW = NONNEGATIVE_OR(newW, 1);\n+            newH = NONNEGATIVE_OR(newH, 1);\n@@ -770,3 +791,3 @@\n-    if (rfeAtom != None) {\n-        XClientMessageEvent clientMessage;\n-        memset(&clientMessage, 0, sizeof(clientMessage));\n+            LOG2(\"extents received -> new view size: %d, %d\\n\", newW, newH);\n+            int x = geometry.x;\n+            int y = geometry.y;\n@@ -774,4 +795,6 @@\n-        clientMessage.type = ClientMessage;\n-        clientMessage.window = GDK_WINDOW_XID(gdk_window);\n-        clientMessage.message_type = rfeAtom;\n-        clientMessage.format = 32;\n+            \/\/ Gravity x, y are used in centerOnScreen(). Here it's used to adjust the position\n+            \/\/ accounting decorations\n+            if (geometry.gravity_x > 0 && x > 0) {\n+                x -= geometry.gravity_x * (float) (geometry.extents.width);\n+                x = NONNEGATIVE_OR(x, 0);\n+            }\n@@ -779,6 +802,4 @@\n-        XSendEvent(display, XDefaultRootWindow(display), False,\n-                   SubstructureRedirectMask | SubstructureNotifyMask,\n-                   (XEvent *) &clientMessage);\n-        XFlush(display);\n-    }\n-}\n+            if (geometry.gravity_y > 0 && y > 0) {\n+                y -= geometry.gravity_y  * (float) (geometry.extents.height);\n+                y = NONNEGATIVE_OR(y, 0);\n+            }\n@@ -786,2 +807,6 @@\n-void WindowContextTop::update_frame_extents() {\n-    int top, left, bottom, right;\n+            geometry.extents = rect;\n+            geometry.frame_extents_received = true;\n+            geometry.width = newW;\n+            geometry.height = newH;\n+            geometry.x = x;\n+            geometry.y = y;\n@@ -789,38 +814,2 @@\n-    if (get_frame_extents_property(&top, &left, &bottom, &right)) {\n-        if (top > 0 || right > 0 || bottom > 0 || left > 0) {\n-            bool changed = geometry.extents.top != top\n-                            || geometry.extents.left != left\n-                            || geometry.extents.bottom != bottom\n-                            || geometry.extents.right != right;\n-\n-            if (changed) {\n-                geometry.extents.top = top;\n-                geometry.extents.left = left;\n-                geometry.extents.bottom = bottom;\n-                geometry.extents.right = right;\n-\n-                set_cached_extents(geometry.extents);\n-\n-                \/\/ set bounds again to correct window size\n-                \/\/ accounting decorations\n-                int w = geometry_get_window_width(&geometry);\n-                int h = geometry_get_window_height(&geometry);\n-                int cw = geometry_get_content_width(&geometry);\n-                int ch = geometry_get_content_height(&geometry);\n-\n-                int x = geometry.x;\n-                int y = geometry.y;\n-\n-                if (geometry.gravity_x != 0) {\n-                    x -= geometry.gravity_x * (float) (left + right);\n-                }\n-\n-                if (geometry.gravity_y != 0) {\n-                    y -= geometry.gravity_y * (float) (top + bottom);\n-                }\n-\n-                set_bounds(x, y, true, true, w, h, cw, ch, 0, 0);\n-           }\n-        }\n-    }\n-}\n+            LOG4(\"Geometry after frame extents: %d, %d - %d, %d\\n\", geometry.x,\n+                        geometry.y, geometry.width, geometry.height);\n@@ -828,5 +817,10 @@\n-void WindowContextTop::set_cached_extents(WindowFrameExtents ex) {\n-    if (window_type == NORMAL) {\n-        normal_extents = ex;\n-    } else {\n-        utility_extents = ex;\n+            update_window_constraints(newW, newH);\n+\n+            if ((gdk_window_get_state(gdk_window)\n+                    & (GDK_WINDOW_STATE_FULLSCREEN | GDK_WINDOW_STATE_MAXIMIZED)) == 0) {\n+                resize(newW, newH);\n+                move(x, y);\n+            } else {\n+                geometry.needs_to_restore_geometry = true;\n+            }\n+        }\n@@ -836,2 +830,4 @@\n-WindowFrameExtents WindowContextTop::get_cached_extents() {\n-    return window_type == NORMAL ? normal_extents : utility_extents;\n+void WindowContext::save_geometry() {\n+    geometry.width = gdk_window_get_width(gdk_window);\n+    geometry.height = gdk_window_get_height(gdk_window);\n+    gdk_window_get_root_origin(gdk_window, &geometry.x, &geometry.y);\n@@ -840,1 +836,1 @@\n-bool WindowContextTop::get_frame_extents_property(int *top, int *left,\n+bool WindowContext::get_frame_extents_property(int *top, int *left,\n@@ -866,3 +862,16 @@\n-void WindowContextTop::work_around_compiz_state() {\n-    \/\/ Workaround for https:\/\/bugs.launchpad.net\/unity\/+bug\/998073\n-    if (wmanager != COMPIZ) {\n+void WindowContext::set_cached_extents(GdkRectangle ex) {\n+    if (window_type == UTILITY) {\n+        utility_extents = ex;\n+    } else {\n+        normal_extents = ex;\n+    }\n+}\n+\n+void WindowContext::load_cached_extents() {\n+    if (frame_type != TITLED) return;\n+\n+    if (window_type == NORMAL && normal_extents.has_value()) {\n+        geometry.extents = normal_extents.value();\n+        LOG4(\"Loaded Normal Extents: x = %d, y = %d, width = %d, height = %d\\n\",\n+                    geometry.extents.x, geometry.extents.y, geometry.extents.width, geometry.extents.height);\n+        geometry.frame_extents_received = true;\n@@ -872,4 +881,7 @@\n-    static GdkAtom atom_atom = gdk_atom_intern_static_string(\"ATOM\");\n-    static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string(\"_NET_WM_STATE\");\n-    static GdkAtom atom_net_wm_state_hidden = gdk_atom_intern_static_string(\"_NET_WM_STATE_HIDDEN\");\n-    static GdkAtom atom_net_wm_state_above = gdk_atom_intern_static_string(\"_NET_WM_STATE_ABOVE\");\n+    if (window_type == UTILITY && utility_extents.has_value()) {\n+        geometry.extents = utility_extents.value();\n+        LOG4(\"Loaded Utility Extents: x = %d, y = %d, width = %d, height = %d\\n\",\n+                    geometry.extents.x, geometry.extents.y, geometry.extents.width, geometry.extents.height);\n+        geometry.frame_extents_received = true;\n+    }\n+}\n@@ -877,1 +889,6 @@\n-    gint length;\n+void WindowContext::process_property_notify(GdkEventProperty *event) {\n+\/\/    LOG1(\"process_property_notify: %s\\n\", gdk_atom_name(event->atom));\n+    if (event->atom == get_net_frame_extents_atom()) {\n+        update_frame_extents();\n+    }\n+}\n@@ -879,1 +896,7 @@\n-    glong* atoms = NULL;\n+void WindowContext::process_state(GdkEventWindowState *event) {\n+    if (!(event->changed_mask & (GDK_WINDOW_STATE_ICONIFIED\n+                                | GDK_WINDOW_STATE_MAXIMIZED\n+                                | GDK_WINDOW_STATE_FULLSCREEN\n+                                | GDK_WINDOW_STATE_ABOVE))) {\n+        return;\n+    }\n@@ -881,2 +904,2 @@\n-    if (gdk_property_get(gdk_window, atom_net_wm_state, atom_atom,\n-            0, G_MAXLONG, FALSE, NULL, NULL, &length, (guchar**) &atoms)) {\n+    if (event->changed_mask & GDK_WINDOW_STATE_ABOVE) {\n+        notify_on_top(event->new_window_state & GDK_WINDOW_STATE_ABOVE);\n@@ -884,9 +907,3 @@\n-        bool is_hidden = false;\n-        bool is_above = false;\n-        for (gint i = 0; i < (gint)(length \/ sizeof(glong)); i++) {\n-            if (atom_net_wm_state_hidden == (GdkAtom)atoms[i]) {\n-                is_hidden = true;\n-            } else if (atom_net_wm_state_above == (GdkAtom)atoms[i]) {\n-                is_above = true;\n-            }\n-        }\n+        \/\/ Only state mask\n+        if (event->new_window_state == GDK_WINDOW_STATE_ABOVE) return;\n+    }\n@@ -894,1 +911,3 @@\n-        g_free(atoms);\n+    \/\/ Those represent the real current size in the state\n+    int cw = gdk_window_get_width(gdk_window);\n+    int ch = gdk_window_get_height(gdk_window);\n@@ -896,2 +915,2 @@\n-        if (is_iconified != is_hidden) {\n-            is_iconified = is_hidden;\n+    int ww, wh;\n+    get_window_size(&ww, &wh);\n@@ -899,4 +918,1 @@\n-            notify_state((is_hidden)\n-                    ? com_sun_glass_events_WindowEvent_MINIMIZE\n-                    : com_sun_glass_events_WindowEvent_RESTORE);\n-        }\n+    LOG4(\"process_state: cw = %d, ch = %d, ww = %d, wh = %d\\n\", cw, ch, ww, wh);\n@@ -904,1 +920,10 @@\n-        notify_on_top(is_above);\n+    if ((event->changed_mask & (GDK_WINDOW_STATE_MAXIMIZED | GDK_WINDOW_STATE_ICONIFIED))\n+        && ((event->new_window_state & (GDK_WINDOW_STATE_MAXIMIZED | GDK_WINDOW_STATE_ICONIFIED)) == 0)) {\n+        LOG0(\"com_sun_glass_events_WindowEvent_RESTORE\\n\");\n+        notify_window_resize(com_sun_glass_events_WindowEvent_RESTORE, ww, wh);\n+    } else if (event->new_window_state & (GDK_WINDOW_STATE_ICONIFIED)) {\n+        LOG0(\"com_sun_glass_events_WindowEvent_MINIMIZE\\n\");\n+        notify_window_resize(com_sun_glass_events_WindowEvent_MINIMIZE, ww, wh);\n+    } else if (event->new_window_state & (GDK_WINDOW_STATE_MAXIMIZED)) {\n+        LOG0(\"com_sun_glass_events_WindowEvent_MAXIMIZE\\n\");\n+        notify_window_resize(com_sun_glass_events_WindowEvent_MAXIMIZE, ww, wh);\n@@ -906,1 +931,0 @@\n-}\n@@ -908,2 +932,3 @@\n-void WindowContextTop::process_property_notify(GdkEventProperty* event) {\n-    static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string(\"_NET_WM_STATE\");\n+    if (event->changed_mask & GDK_WINDOW_STATE_ICONIFIED\n+        && (event->new_window_state & GDK_WINDOW_STATE_ICONIFIED) == 0) {\n+        remove_wmf(GDK_FUNC_MINIMIZE);\n@@ -911,6 +936,3 @@\n-    if (event->window == gdk_window) {\n-        if (event->atom == get_net_frame_extents_atom()) {\n-            update_frame_extents();\n-        } else if (event->atom == atom_net_wm_state) {\n-            work_around_compiz_state();\n-        }\n+        \/\/FIXME: remove when 8351867 is fixed\n+        GdkRectangle rect = { 0, 0, cw, ch };\n+        notify_repaint(&rect);\n@@ -918,1 +940,0 @@\n-}\n@@ -920,4 +941,2 @@\n-void WindowContextTop::process_state(GdkEventWindowState* event) {\n-    if (event->changed_mask & GDK_WINDOW_STATE_FULLSCREEN) {\n-        is_fullscreen = event->new_window_state & GDK_WINDOW_STATE_FULLSCREEN;\n-    }\n+    \/\/ If only iconified, no further processing\n+    if (event->new_window_state == GDK_WINDOW_STATE_ICONIFIED) return;\n@@ -926,3 +945,2 @@\n-        && !(event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED)) {\n-        gtk_window_resize(GTK_WINDOW(gtk_widget), geometry_get_content_width(&geometry),\n-                                    geometry_get_content_height(&geometry));\n+        && (event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) == 0) {\n+        remove_wmf(GDK_FUNC_MAXIMIZE);\n@@ -931,1 +949,28 @@\n-    WindowContextBase::process_state(event);\n+    if (jview && event->changed_mask & GDK_WINDOW_STATE_FULLSCREEN) {\n+        if (event->new_window_state & GDK_WINDOW_STATE_FULLSCREEN) {\n+            LOG0(\"com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER\\n\");\n+            mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        } else {\n+            LOG0(\"com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT\\n\");\n+            mainEnv->CallVoidMethod(jview, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n+    }\n+\n+    notify_view_resize(cw, ch);\n+    \/\/ Since FullScreen (or custom modes of maximized) can undecorate the\n+    \/\/ window, request view position change\n+    notify_view_move();\n+\n+    \/\/ This only accounts MAXIMIZED and FULLSCREEN\n+    bool restored = (event->changed_mask & (GDK_WINDOW_STATE_MAXIMIZED\n+                                            | GDK_WINDOW_STATE_FULLSCREEN))\n+                    && ((event->new_window_state & (GDK_WINDOW_STATE_MAXIMIZED\n+                                            | GDK_WINDOW_STATE_FULLSCREEN)) == 0);\n+\n+    \/\/ In case the size or location changed while maximized of fullscreened\n+    if (restored && geometry.needs_to_restore_geometry) {\n+        LOG0(\"restored, call update_window_size_location\\n\");\n+        update_window_size_location();\n+    }\n@@ -934,1 +979,2 @@\n-void WindowContextTop::process_realize() {\n+void WindowContext::process_realize() {\n+    LOG0(\"realized\\n\");\n@@ -936,0 +982,1 @@\n+\n@@ -944,2 +991,6 @@\n-    if (gdk_windowManagerFunctions) {\n-        gdk_window_set_functions(gdk_window, gdk_windowManagerFunctions);\n+    if (frame_type != TITLED) {\n+        initial_wmf = GDK_FUNC_ALL;\n+    }\n+\n+    if (initial_wmf) {\n+        gdk_window_set_functions(gdk_window, initial_wmf);\n@@ -949,3 +1000,7 @@\n-void WindowContextTop::process_configure(GdkEventConfigure* event) {\n-    int ww = event->width + geometry.extents.left + geometry.extents.right;\n-    int wh = event->height + geometry.extents.top + geometry.extents.bottom;\n+void WindowContext::notify_window_resize(int state, int width, int height) {\n+    if (jwindow) {\n+        LOG3(\"jWindowNotifyResize: %d -> %d, %d\\n\", state, width, height);\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize, state, width, height);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+}\n@@ -953,7 +1008,4 @@\n-    \/\/ Do not report if iconified, because Java side would set the state to NORMAL\n-    if (jwindow && !is_iconified) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,\n-                (is_maximized)\n-                    ? com_sun_glass_events_WindowEvent_MAXIMIZE\n-                    : com_sun_glass_events_WindowEvent_RESIZE,\n-                ww, wh);\n+void WindowContext::notify_window_move(int x, int y) {\n+    if (jwindow) {\n+        LOG2(\"jWindowNotifyMove: %d, %d\\n\", x, y);\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove, x, y);\n@@ -961,0 +1013,2 @@\n+    }\n+}\n@@ -962,4 +1016,5 @@\n-        if (jview) {\n-            mainEnv->CallVoidMethod(jview, jViewNotifyResize, event->width, event->height);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n+void WindowContext::notify_view_resize(int width, int height) {\n+    if (jview) {\n+        LOG2(\"jViewNotifyResize: %d, %d\\n\", width, height);\n+        mainEnv->CallVoidMethod(jview, jViewNotifyResize, width, height);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n@@ -967,0 +1022,7 @@\n+}\n+\n+void WindowContext::notify_current_sizes() {\n+    int ww, wh, cw, ch;\n+\n+    get_window_size(&ww, &wh);\n+    get_view_size(&cw, &ch);\n@@ -968,3 +1030,3 @@\n-    if (!is_iconified && !is_fullscreen && !is_maximized) {\n-        geometry.final_width.value = (geometry.final_width.type == BOUNDSTYPE_CONTENT)\n-                ? event->width : ww;\n+    GdkWindowState state = (gtk_widget_get_realized(gtk_widget))\n+            ? gdk_window_get_state(gdk_window)\n+            : (GdkWindowState) 0;\n@@ -972,2 +1034,25 @@\n-        geometry.final_height.value = (geometry.final_height.type == BOUNDSTYPE_CONTENT)\n-                ? event->height : wh;\n+    notify_window_resize((state & GDK_WINDOW_STATE_MAXIMIZED)\n+                                ? com_sun_glass_events_WindowEvent_MAXIMIZE\n+                                : com_sun_glass_events_WindowEvent_RESIZE,\n+                                ww, wh);\n+\n+    notify_view_resize(cw, ch);\n+}\n+\n+void WindowContext::notify_view_move() {\n+    if (jview) {\n+        LOG0(\"com_sun_glass_events_ViewEvent_MOVE\\n\");\n+        mainEnv->CallVoidMethod(jview, jViewNotifyView,\n+                com_sun_glass_events_ViewEvent_MOVE);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+}\n+\n+void WindowContext::process_configure(GdkEventConfigure *event) {\n+    LOG5(\"Configure Event - send_event: %d, x: %d, y: %d, width: %d, height: %d\\n\",\n+            event->send_event, event->x, event->y, event->width, event->height);\n+\n+    GdkWindowState state = gdk_window_get_state(gdk_window);\n+\n+    if (state & GDK_WINDOW_STATE_ICONIFIED) {\n+        return;\n@@ -980,6 +1065,3 @@\n-    \/\/ x and y represent the position of the top-left corner of the window relative to the desktop area\n-    geometry.x = root_x;\n-    geometry.y = root_y;\n-\n-    \/\/ view_x and view_y represent the position of the content relative to the top-left corner of the window,\n-    \/\/ taking into account window decorations (such as title bars and borders) applied by the window manager.\n+    \/\/ view_x and view_y represent the position of the content relative to the left corner of the window,\n+    \/\/ taking into account window decorations (such as title bars and borders) applied by the window manager\n+    \/\/ and might vary by window state.\n@@ -988,12 +1070,35 @@\n-    notify_window_move();\n-\n-    glong to_screen = getScreenPtrForLocation(geometry.x, geometry.y);\n-    if (to_screen != -1) {\n-        if (to_screen != screen) {\n-            if (jwindow) {\n-                \/\/notify screen changed\n-                jobject jScreen = createJavaScreen(mainEnv, to_screen);\n-                mainEnv->CallVoidMethod(jwindow, jWindowNotifyMoveToAnotherScreen, jScreen);\n-                CHECK_JNI_EXCEPTION(mainEnv)\n-            }\n-            screen = to_screen;\n+    LOG2(\"view x, y: %d, %d\\n\", geometry.view_x, geometry.view_y);\n+\n+    int cw = event->width;\n+    int ch = event->height;\n+\n+    notify_view_resize(cw, ch);\n+    notify_view_move();\n+\n+    int ww = cw;\n+    int wh = ch;\n+\n+    \/\/ Fullscreen usually have no decorations\n+    if (geometry.view_x > 0) {\n+        ww += geometry.extents.width;\n+    }\n+\n+    if (geometry.view_y > 0) {\n+        wh += geometry.extents.height;\n+    }\n+\n+    notify_window_resize((state & GDK_WINDOW_STATE_MAXIMIZED)\n+                            ? com_sun_glass_events_WindowEvent_MAXIMIZE\n+                            : com_sun_glass_events_WindowEvent_RESIZE,\n+                            ww, wh);\n+\n+    notify_window_move(root_x, root_y);\n+\n+    glong to_screen = getScreenPtrForLocation(event->x, event->y);\n+    if (to_screen != -1 && to_screen != screen) {\n+        if (jwindow) {\n+            LOG0(\"jWindowNotifyMoveToAnotherScreen\\n\");\n+            \/\/notify screen changed\n+            jobject jScreen = createJavaScreen(mainEnv, to_screen);\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyMoveToAnotherScreen, jScreen);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n@@ -1001,0 +1106,1 @@\n+        screen = to_screen;\n@@ -1004,2 +1110,17 @@\n-void WindowContextTop::update_window_constraints() {\n-    bool is_floating = !is_iconified && !is_fullscreen && !is_maximized;\n+void WindowContext::remove_window_constraints() {\n+    LOG0(\"remove_window_constraints\\n\");\n+    GdkGeometry reset;\n+    reset.min_width = 1;\n+    reset.min_height = 1;\n+    reset.max_width = G_MAXINT;\n+    reset.max_height = G_MAXINT;\n+\n+    gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &reset,\n+                                    (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));\n+}\n+\n+void WindowContext::update_window_constraints() {\n+    int cw, ch;\n+    get_view_size(&cw, &ch);\n+    update_window_constraints(cw, ch);\n+}\n@@ -1007,2 +1128,5 @@\n-    if (!is_floating) {\n-        \/\/ window is not floating on the screen\n+void WindowContext::update_window_constraints(int width, int height) {\n+    \/\/ Not ready to re-apply the constraints\n+    if ((gtk_widget_get_realized(gtk_widget) && !is_window_floating(gdk_window_get_state(gdk_window)))\n+        || !is_window_floating((GdkWindowState) initial_state_mask)) {\n+        LOG0(\"not floating: update_window_constraints ignored\\n\");\n@@ -1015,13 +1139,12 @@\n-        int min_w = (resizable.minw == -1) ? 1\n-                      : resizable.minw - geometry.extents.left - geometry.extents.right;\n-        int min_h =  (resizable.minh == -1) ? 1\n-                      : resizable.minh - geometry.extents.top - geometry.extents.bottom;\n-\n-        hints.min_width = (min_w < 1) ? 1 : min_w;\n-        hints.min_height = (min_h < 1) ? 1 : min_h;\n-\n-        hints.max_width = (resizable.maxw == -1) ? G_MAXINT\n-                            : resizable.maxw - geometry.extents.left - geometry.extents.right;\n-\n-        hints.max_height = (resizable.maxh == -1) ? G_MAXINT\n-                           : resizable.maxh - geometry.extents.top - geometry.extents.bottom;\n+        hints.min_width = (resizable.minw == -1)\n+                     ? 1\n+                     : NONNEGATIVE_OR(resizable.minw - geometry.extents.width, 1);\n+        hints.min_height = (resizable.minh == -1)\n+                     ? 1\n+                     : NONNEGATIVE_OR(resizable.minh - geometry.extents.height, 1);\n+        hints.max_width = (resizable.maxw == -1)\n+                    ? G_MAXINT\n+                    : NONNEGATIVE_OR(resizable.maxw - geometry.extents.width, 1);\n+        hints.max_height = (resizable.maxh == -1)\n+                    ? G_MAXINT\n+                    : NONNEGATIVE_OR(resizable.maxh - geometry.extents.height, 1);\n@@ -1029,7 +1152,4 @@\n-        int w = geometry_get_content_width(&geometry);\n-        int h = geometry_get_content_height(&geometry);\n-\n-        hints.min_width = w;\n-        hints.min_height = h;\n-        hints.max_width = w;\n-        hints.max_height = h;\n+        hints.min_width = width;\n+        hints.min_height = height;\n+        hints.max_width = width;\n+        hints.max_height = height;\n@@ -1038,0 +1158,3 @@\n+    LOG4(\"geometry hints: min w,h: %d, %d - max w,h: %d, %d\\n\", hints.min_width,\n+            hints.min_height, hints.max_width, hints.max_height);\n+\n@@ -1039,1 +1162,1 @@\n-                                  (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));\n+                                  (GdkWindowHints) (GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));\n@@ -1042,1 +1165,1 @@\n-void WindowContextTop::set_resizable(bool res) {\n+void WindowContext::set_resizable(bool res) {\n@@ -1047,6 +1170,4 @@\n-void WindowContextTop::set_visible(bool visible) {\n-    WindowContextBase::set_visible(visible);\n-\n-    if (visible && !geometry.size_assigned) {\n-        set_bounds(0, 0, false, false, 320, 200, -1, -1, 0, 0);\n-    }\n+void WindowContext::set_visible(bool visible) {\n+    LOG1(\"set_visible: %d\\n\", visible);\n+    if (visible) {\n+        gtk_widget_show(gtk_widget);\n@@ -1054,4 +1175,19 @@\n-    \/\/JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order\n-    if (visible && jwindow && isEnabled()) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);\n-        CHECK_JNI_EXCEPTION(mainEnv);\n+        \/\/ JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order\n+        if (jwindow && isEnabled()) {\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);\n+            CHECK_JNI_EXCEPTION(mainEnv);\n+        }\n+    } else {\n+        gtk_widget_hide(gtk_widget);\n+        if (jview && is_mouse_entered) {\n+            is_mouse_entered = false;\n+            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+                    com_sun_glass_events_MouseEvent_EXIT,\n+                    com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+                    0, 0,\n+                    0, 0,\n+                    0,\n+                    JNI_FALSE,\n+                    JNI_FALSE);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n@@ -1061,4 +1197,4 @@\n-void WindowContextTop::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch,\n-                                  float gravity_x, float gravity_y) {\n-\/\/     fprintf(stderr, \"set_bounds -> x = %d, y = %d, xset = %d, yset = %d, w = %d, h = %d, cw = %d, ch = %d, gx = %f, gy = %f\\n\",\n-\/\/            x, y, xSet, ySet, w, h, cw, ch, gravity_x, gravity_y);\n+void WindowContext::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch,\n+                               float gravity_x, float gravity_y) {\n+    LOG10(\"set_bounds -> x = %d, y = %d, xset = %d, yset = %d, w = %d, h = %d, cw = %d, ch = %d, gx = %f, gy = %f\\n\",\n+            x, y, xSet, ySet, w, h, cw, ch, gravity_x, gravity_y);\n@@ -1073,3 +1209,1 @@\n-        geometry.final_width.type = BOUNDSTYPE_WINDOW;\n-        geometry.final_width.value = w;\n-        newW = w - (geometry.extents.left + geometry.extents.right);\n+        newW = NONNEGATIVE_OR(w - geometry.extents.width, 1);\n@@ -1077,2 +1211,0 @@\n-        geometry.final_width.type = BOUNDSTYPE_CONTENT;\n-        geometry.final_width.value = cw;\n@@ -1080,2 +1212,0 @@\n-    } else {\n-        newW = geometry_get_content_width(&geometry);\n@@ -1085,3 +1215,1 @@\n-        geometry.final_height.type = BOUNDSTYPE_WINDOW;\n-        geometry.final_height.value = h;\n-        newH = h - (geometry.extents.top + geometry.extents.bottom);\n+        newH = NONNEGATIVE_OR(h - geometry.extents.height, 1);\n@@ -1089,2 +1217,0 @@\n-        geometry.final_height.type = BOUNDSTYPE_CONTENT;\n-        geometry.final_height.value = ch;\n@@ -1092,2 +1218,0 @@\n-    } else {\n-        newH = geometry_get_content_height(&geometry);\n@@ -1096,0 +1220,2 @@\n+    if (xSet) geometry.x = x;\n+    if (ySet) geometry.y = y;\n@@ -1097,3 +1223,2 @@\n-    if (newW > 0 || newH > 0) {\n-        \/\/ call update_window_constraints() to let gtk_window_resize succeed, because it's bound to geometry constraints\n-        update_window_constraints();\n+    if (newW > 0) geometry.width = newW;\n+    if (newH > 0) geometry.height = newH;\n@@ -1101,8 +1226,1 @@\n-        if (gtk_widget_get_realized(gtk_widget)) {\n-            gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);\n-        } else {\n-            gtk_window_set_default_size(GTK_WINDOW(gtk_widget), newW, newH);\n-        }\n-        geometry.size_assigned = true;\n-        notify_window_resize();\n-    }\n+    LOG2(\"set_bounds: geometry.width = %d, geometry.height = %d\\n\", geometry.width, geometry.height);\n@@ -1110,3 +1228,8 @@\n-    if (xSet || ySet) {\n-        if (xSet) {\n-            geometry.x = x;\n+    if (gtk_widget_get_realized(gtk_widget)) {\n+        GdkWindowState state = gdk_window_get_state(gdk_window);\n+\n+        \/\/ If it is in fullscreen mode, it will be applied later on restore\n+        if (!geometry.needs_to_restore_geometry &&\n+                (state & GDK_WINDOW_STATE_FULLSCREEN)) {\n+            LOG0(\"set_bounds: needs_to_restore_geometry = true\\n\");\n+            geometry.needs_to_restore_geometry = true;\n@@ -1115,2 +1238,14 @@\n-        if (ySet) {\n-            geometry.y = y;\n+        if (geometry.needs_to_restore_geometry || (state & GDK_WINDOW_STATE_MAXIMIZED)) {\n+            LOG0(\"need to restore geometry of maximized\\n\");\n+            \/\/ Report back to java with current sizes\n+            if (newW > 0 || newH > 0) {\n+                notify_current_sizes();\n+            }\n+\n+            if (xSet || xSet) {\n+                int x, y;\n+                gdk_window_get_root_origin(gdk_window, &x, &y);\n+                notify_window_move(x, y);\n+            }\n+\n+            return;\n@@ -1118,0 +1253,1 @@\n+    }\n@@ -1119,2 +1255,3 @@\n-        gtk_window_move(GTK_WINDOW(gtk_widget), geometry.x, geometry.y);\n-        notify_window_move();\n+    \/\/ Re-apply the constraints removed for fullscreen \/ maximize\n+    if (!resizable.value) {\n+        update_window_constraints(newW, newH);\n@@ -1122,0 +1259,3 @@\n+\n+    resize(newW, newH);\n+    move(x, y, xSet, ySet);\n@@ -1124,1 +1264,1 @@\n-void WindowContextTop::applyShapeMask(void* data, uint width, uint height) {\n+void WindowContext::applyShapeMask(void* data, uint width, uint height) {\n@@ -1132,14 +1272,3 @@\n-void WindowContextTop::set_minimized(bool minimize) {\n-    is_iconified = minimize;\n-    if (minimize) {\n-        if (frame_type == TRANSPARENT && wmanager == COMPIZ) {\n-            \/\/ https:\/\/bugs.launchpad.net\/ubuntu\/+source\/unity\/+bug\/1245571\n-            glass_window_reset_input_shape_mask(gtk_widget_get_window(gtk_widget));\n-        }\n-\n-        if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0) {\n-            \/\/ in this case - the window manager will not support the programatic\n-            \/\/ request to iconify - so we need to disable this until we are restored.\n-            GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MINIMIZE);\n-            gdk_window_set_functions(gdk_window, wmf);\n-        }\n+void WindowContext::iconify(bool state) {\n+    if (state) {\n+        add_wmf(GDK_FUNC_MINIMIZE);\n@@ -1153,7 +1282,8 @@\n-void WindowContextTop::set_maximized(bool maximize) {\n-    is_maximized = maximize;\n-    if (maximize) {\n-        \/\/ enable the functionality on the window manager as it might ignore the maximize command,\n-        \/\/ for example when the window is undecorated.\n-        GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MAXIMIZE);\n-        gdk_window_set_functions(gdk_window, wmf);\n+void WindowContext::maximize(bool state) {\n+    if (state) {\n+        add_wmf(GDK_FUNC_MAXIMIZE);\n+\n+        if (!resizable.value) {\n+            remove_window_constraints();\n+            process_pending_events();\n+        }\n@@ -1167,3 +1297,9 @@\n-void WindowContextTop::enter_fullscreen() {\n-    gtk_window_fullscreen(GTK_WINDOW(gtk_widget));\n-    is_fullscreen = true;\n+void WindowContext::set_minimized(bool state) {\n+    LOG1(\"set_minimized = %d\\n\", state);\n+    if (was_mapped) {\n+        iconify(state);\n+    } else {\n+        initial_state_mask = state\n+            ? (initial_state_mask | GDK_WINDOW_STATE_ICONIFIED)\n+            : (initial_state_mask & ~GDK_WINDOW_STATE_ICONIFIED);\n+    }\n@@ -1172,2 +1308,9 @@\n-void WindowContextTop::exit_fullscreen() {\n-    gtk_window_unfullscreen(GTK_WINDOW(gtk_widget));\n+void WindowContext::set_maximized(bool state) {\n+    LOG1(\"set_maximized = %d\\n\", state);\n+    if (was_mapped) {\n+        maximize(state);\n+    } else {\n+        initial_state_mask = state\n+            ? (initial_state_mask | GDK_WINDOW_STATE_MAXIMIZED)\n+            : (initial_state_mask & ~GDK_WINDOW_STATE_MAXIMIZED);\n+    }\n@@ -1176,3 +1319,18 @@\n-void WindowContextTop::request_focus() {\n-    if (is_visible()) {\n-        gtk_window_present(GTK_WINDOW(gtk_widget));\n+void WindowContext::enter_fullscreen() {\n+    LOG0(\"enter_fullscreen\\n\");\n+    if (was_mapped) {\n+        \/\/ save state before fullscreen to work-around an issue were\n+        \/\/ it would restore to max-size\n+        save_geometry();\n+        geometry.needs_to_restore_geometry = true;\n+\n+        if (!resizable.value) {\n+            remove_window_constraints();\n+            process_pending_events();\n+            \/\/ Needs to happen \"in the future\" because constraints removal are not applied immediately\n+            gdk_threads_add_idle((GSourceFunc) enter_fullscreen_later, GTK_WINDOW(gtk_widget));\n+        } else {\n+            gtk_window_fullscreen(GTK_WINDOW(gtk_widget));\n+        }\n+    } else {\n+        initial_state_mask |= GDK_WINDOW_STATE_FULLSCREEN;\n@@ -1182,2 +1340,7 @@\n-void WindowContextTop::set_focusable(bool focusable) {\n-    gtk_window_set_accept_focus(GTK_WINDOW(gtk_widget), focusable ? TRUE : FALSE);\n+void WindowContext::exit_fullscreen() {\n+    LOG0(\"exit_fullscreen\\n\");\n+    if (was_mapped) {\n+        gtk_window_unfullscreen(GTK_WINDOW(gtk_widget));\n+    } else {\n+        initial_state_mask &= ~GDK_WINDOW_STATE_FULLSCREEN;\n+    }\n@@ -1186,2 +1349,5 @@\n-void WindowContextTop::set_title(const char* title) {\n-    gtk_window_set_title(GTK_WINDOW(gtk_widget), title);\n+void WindowContext::request_focus() {\n+    LOG0(\"request_focus\\n\");\n+    if (!is_visible()) return;\n+\n+    gtk_window_present(GTK_WINDOW(gtk_widget));\n@@ -1190,2 +1356,6 @@\n-void WindowContextTop::set_alpha(double alpha) {\n-    gtk_window_set_opacity(GTK_WINDOW(gtk_widget), (gdouble)alpha);\n+void WindowContext::set_focusable(bool focusable) {\n+    gtk_window_set_accept_focus(GTK_WINDOW(gtk_widget), focusable ? TRUE : FALSE);\n+}\n+\n+void WindowContext::set_title(const char* title) {\n+    gtk_window_set_title(GTK_WINDOW(gtk_widget), title);\n@@ -1194,1 +1364,1 @@\n-void WindowContextTop::set_enabled(bool enabled) {\n+void WindowContext::set_enabled(bool enabled) {\n@@ -1199,3 +1369,4 @@\n-void WindowContextTop::set_minimum_size(int w, int h) {\n-    resizable.minw = (w <= 0) ? 1 : w;\n-    resizable.minh = (h <= 0) ? 1 : h;\n+void WindowContext::set_minimum_size(int w, int h) {\n+    LOG2(\"set_minimum_size: %d, %d\\n\", w, h);\n+    resizable.minw = w;\n+    resizable.minh = h;\n@@ -1205,3 +1376,4 @@\n-void WindowContextTop::set_maximum_size(int w, int h) {\n-    resizable.maxw = w;\n-    resizable.maxh = h;\n+void WindowContext::set_maximum_size(int w, int h) {\n+    LOG2(\"set_maximum_size: %d, %d\\n\", w, h);\n+    resizable.maxw = (w == -1) ? -1 : w;\n+    resizable.maxh = (h == -1) ? -1 : h;\n@@ -1211,1 +1383,1 @@\n-void WindowContextTop::set_icon(GdkPixbuf* pixbuf) {\n+void WindowContext::set_icon(GdkPixbuf* pixbuf) {\n@@ -1215,1 +1387,2 @@\n-void WindowContextTop::to_front() {\n+void WindowContext::to_front() {\n+    LOG0(\"to_front\\n\");\n@@ -1219,1 +1392,2 @@\n-void WindowContextTop::to_back() {\n+void WindowContext::to_back() {\n+    LOG0(\"to_back\\n\");\n@@ -1223,1 +1397,1 @@\n-void WindowContextTop::set_modal(bool modal, WindowContext* parent) {\n+void WindowContext::set_modal(bool modal, WindowContext* parent) {\n@@ -1233,1 +1407,1 @@\n-GtkWindow *WindowContextTop::get_gtk_window() {\n+GtkWindow *WindowContext::get_gtk_window() {\n@@ -1237,1 +1411,1 @@\n-WindowGeometry WindowContextTop::get_geometry() {\n+WindowGeometry WindowContext::get_geometry() {\n@@ -1241,1 +1415,1 @@\n-void WindowContextTop::update_ontop_tree(bool on_top) {\n+void WindowContext::update_ontop_tree(bool on_top) {\n@@ -1244,1 +1418,1 @@\n-    for (std::set<WindowContextTop*>::iterator it = children.begin(); it != children.end(); ++it) {\n+    for (std::set<WindowContext*>::iterator it = children.begin(); it != children.end(); ++it) {\n@@ -1249,1 +1423,1 @@\n-bool WindowContextTop::on_top_inherited() {\n+bool WindowContext::on_top_inherited() {\n@@ -1252,1 +1426,1 @@\n-        WindowContextTop* topO = dynamic_cast<WindowContextTop*>(o);\n+        WindowContext* topO = dynamic_cast<WindowContext*>(o);\n@@ -1262,1 +1436,1 @@\n-bool WindowContextTop::effective_on_top() {\n+bool WindowContext::effective_on_top() {\n@@ -1264,1 +1438,1 @@\n-        WindowContextTop* topO = dynamic_cast<WindowContextTop*>(owner);\n+        WindowContext* topO = dynamic_cast<WindowContext*>(owner);\n@@ -1270,1 +1444,120 @@\n-void WindowContextTop::notify_on_top(bool top) {\n+void WindowContext::get_view_size(int *width, int *height) {\n+    if (gtk_widget_get_realized(gtk_widget)) {\n+        *width = gdk_window_get_width(gdk_window);\n+        *height = gdk_window_get_height(gdk_window);\n+    } else {\n+        *width = geometry.width;\n+        *height = geometry.height;\n+    }\n+\n+    LOG2(\"get_view_size: %d, %d\\n\", *width, *height);\n+}\n+\n+void WindowContext::get_window_size(int *width, int *height) {\n+    int ww, wh;\n+    get_view_size(&ww, &wh);\n+\n+    if (gtk_widget_get_realized(gtk_widget)) {\n+        gint root_x, root_y, origin_x, origin_y;\n+        gdk_window_get_root_origin(gdk_window, &root_x, &root_y);\n+        gdk_window_get_origin(gdk_window, &origin_x, &origin_y);\n+\n+        \/\/ Here is detected if there are any decorations as it might vary, for example\n+        \/\/ if the window is fullscreen\n+        if ((origin_x - root_x) > 0) {\n+            ww += geometry.extents.width;\n+        }\n+\n+        if ((origin_y - root_y) > 0) {\n+            wh += geometry.extents.height;\n+        }\n+    }\n+\n+    LOG2(\"get_window_size: %d, %d\\n\", ww, wh);\n+    *width = ww;\n+    *height = wh;\n+}\n+\n+\/\/ Values are view size\n+void WindowContext::resize(int width, int height) {\n+    LOG2(\"resize (requested): %d, %d\\n\", width, height);\n+    int current_width, current_height;\n+    get_view_size(&current_width, &current_height);\n+\n+    int newW = (width <= 0) ? current_width : width;\n+    int newH = (height <= 0) ? current_height : height;\n+\n+    \/\/ Windows that are undecorated or transparent will not respect\n+    \/\/ minimum or maximum size constraints\n+    if (resizable.minw > 0 && newW < resizable.minw) {\n+        newW = NONNEGATIVE_OR(resizable.minw - geometry.extents.width, 1);\n+    }\n+\n+    if (resizable.minh > 0 && newH < resizable.minh) {\n+        newH = NONNEGATIVE_OR(resizable.minh - geometry.extents.height, 1);\n+    }\n+\n+    if (resizable.maxw > 0 && newW > resizable.maxw) {\n+        newW = NONNEGATIVE_OR(resizable.maxw - geometry.extents.width, 1);\n+    }\n+\n+    if (resizable.maxh > 0 && newH > resizable.maxh) {\n+        newH = NONNEGATIVE_OR(resizable.maxh - geometry.extents.height, 1);\n+    }\n+\n+    LOG2(\"resize (real): %d, %d\\n\", newW, newH);\n+\n+    if (gtk_widget_get_realized(gtk_widget)) {\n+        gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);\n+        \/\/ If not changed, configure event will not happen, so we need to notify here\n+        if (current_width == newW && current_height == newH)  notify_current_sizes();\n+    } else {\n+        gtk_window_set_default_size(GTK_WINDOW(gtk_widget), newW, newH);\n+        \/\/ If the GdkWindow is not yet created, report back to Java, because the configure event\n+        \/\/ won't happen\n+        notify_current_sizes();\n+    }\n+}\n+\n+void WindowContext::move(int x, int y) {\n+    move(x, y, true, true);\n+}\n+\n+void WindowContext::move(int x, int y, bool xSet, bool ySet) {\n+    LOG2(\"move %d, %d\\n\", x, y);\n+    int to_x = x;\n+    int to_y = y;\n+\n+    if (!xSet || !ySet) {\n+        int cur_x, cur_y;\n+\n+        if (gtk_widget_get_realized(gtk_widget)) {\n+            gdk_window_get_root_origin(gdk_window, &cur_x, &cur_y);\n+        } else {\n+            cur_x = geometry.x;\n+            cur_y = geometry.y;\n+        }\n+\n+        if (!xSet) to_x = cur_x;\n+        if (!ySet) to_y = cur_y;\n+    }\n+\n+    gtk_window_move(GTK_WINDOW(gtk_widget), to_x, to_y);\n+}\n+\n+\n+void WindowContext::add_wmf(GdkWMFunction wmf) {\n+    if ((initial_wmf & wmf) == 0) {\n+        current_wmf = (GdkWMFunction)((int)current_wmf | (int)wmf);\n+        gdk_window_set_functions(gdk_window, current_wmf);\n+    }\n+}\n+\n+void WindowContext::remove_wmf(GdkWMFunction wmf) {\n+    if ((initial_wmf & wmf) == 0) {\n+        current_wmf = (GdkWMFunction)((int)current_wmf & ~(int)wmf);\n+        gdk_window_set_functions(gdk_window, current_wmf);\n+    }\n+}\n+\n+void WindowContext::notify_on_top(bool top) {\n@@ -1287,1 +1580,1 @@\n-void WindowContextTop::set_level(int level) {\n+void WindowContext::set_level(int level) {\n@@ -1301,1 +1594,1 @@\n-void WindowContextTop::set_owner(WindowContext * owner_ctx) {\n+void WindowContext::set_owner(WindowContext * owner_ctx) {\n@@ -1305,10 +1598,1 @@\n-void WindowContextTop::update_view_size() {\n-    \/\/ Notify the view size only if size is oriented by WINDOW, otherwise it knows its own size\n-    if (geometry.final_width.type == BOUNDSTYPE_WINDOW\n-        || geometry.final_height.type == BOUNDSTYPE_WINDOW) {\n-\n-        notify_view_resize();\n-    }\n-}\n-\n-void WindowContextTop::notify_view_resize() {\n+void WindowContext::update_view_size() {\n@@ -1316,11 +1600,2 @@\n-        int cw = geometry_get_content_width(&geometry);\n-        int ch = geometry_get_content_height(&geometry);\n-\n-        mainEnv->CallVoidMethod(jview, jViewNotifyResize, cw, ch);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n-    }\n-}\n-\n-void WindowContextTop::notify_window_resize() {\n-    int w = geometry_get_window_width(&geometry);\n-    int h = geometry_get_window_height(&geometry);\n+        int cw, ch;\n+        get_view_size(&cw, &ch);\n@@ -1328,17 +1603,2 @@\n-    mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,\n-                 com_sun_glass_events_WindowEvent_RESIZE, w, h);\n-    CHECK_JNI_EXCEPTION(mainEnv)\n-\n-    notify_view_resize();\n-}\n-\n-void WindowContextTop::notify_window_move() {\n-    if (jwindow) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove,\n-                                 geometry.x, geometry.y);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n-\n-        if (jview) {\n-            mainEnv->CallVoidMethod(jview, jViewNotifyView,\n-                    com_sun_glass_events_ViewEvent_MOVE);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n+        if (cw > 0 && ch > 0) {\n+            notify_view_resize(cw, ch);\n@@ -1349,6 +1609,4 @@\n-void WindowContextTop::process_destroy() {\n-    if (owner) {\n-        owner->remove_child(this);\n-    }\n-\n-    WindowContextBase::process_destroy();\n+WindowContext::~WindowContext() {\n+    LOG0(\"~WindowContext\\n\");\n+    disableIME();\n+    gtk_widget_destroy(gtk_widget);\n@@ -1356,0 +1614,1 @@\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.cpp","additions":845,"deletions":586,"binary":false,"changes":1431,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#define USER_PTR_TO_CTX(value) ((WindowContext *) value)\n+\n@@ -29,1 +31,0 @@\n-#include <X11\/Xlib.h>\n@@ -34,0 +35,1 @@\n+#include <optional>\n@@ -36,1 +38,0 @@\n-\n@@ -38,5 +39,1 @@\n-\n-enum WindowManager {\n-    COMPIZ,\n-    UNKNOWN\n-};\n+#include \"glass_general.h\"\n@@ -56,7 +53,0 @@\n-struct WindowFrameExtents {\n-    int top;\n-    int left;\n-    int bottom;\n-    int right;\n-};\n-\n@@ -65,5 +55,0 @@\n-enum BoundsType {\n-    BOUNDSTYPE_CONTENT,\n-    BOUNDSTYPE_WINDOW\n-};\n-\n@@ -71,15 +56,13 @@\n-    WindowGeometry(): final_width(), final_height(),\n-    size_assigned(false), x(), y(), view_x(), view_y(), gravity_x(), gravity_y(), extents() {}\n-    \/\/ estimate of the final width the window will get after all pending\n-    \/\/ configure requests are processed by the window manager\n-    struct {\n-        int value;\n-        BoundsType type;\n-    } final_width;\n-\n-    struct {\n-        int value;\n-        BoundsType type;\n-    } final_height;\n-\n-    bool size_assigned;\n+    WindowGeometry():\n+    needs_to_restore_geometry(false),\n+    width(-1), height(-1), x(), y(), view_x(), view_y(),\n+    gravity_x(), gravity_y(),\n+    extents(), frame_extents_received(false) {}\n+\n+    bool needs_to_restore_geometry;\n+\n+    \/\/ width, height, x, w are not update by user interactions and\n+    \/\/ may not reflect current geometry.\n+    \/\/ width \/ height are content size\n+    int width;\n+    int height;\n@@ -89,0 +72,1 @@\n+\n@@ -95,1 +79,3 @@\n-    WindowFrameExtents extents;\n+    GdkRectangle extents;\n+\n+    bool frame_extents_received;\n@@ -98,1 +84,1 @@\n-class WindowContextTop;\n+class WindowContext;\n@@ -100,75 +86,4 @@\n-class WindowContext : public DeletedMemDebug<0xCC> {\n-public:\n-    virtual bool isEnabled() = 0;\n-    virtual bool hasIME() = 0;\n-    virtual bool filterIME(GdkEvent *) = 0;\n-    virtual void enableOrResetIME() = 0;\n-    virtual void updateCaretPos() = 0;\n-    virtual void disableIME() = 0;\n-    virtual void setOnPreEdit(bool) = 0;\n-    virtual void commitIME(gchar *) = 0;\n-\n-    virtual void paint(void* data, jint width, jint height) = 0;\n-    virtual WindowGeometry get_geometry() = 0;\n-\n-    virtual void enter_fullscreen() = 0;\n-    virtual void exit_fullscreen() = 0;\n-    virtual void set_visible(bool) = 0;\n-    virtual bool is_visible() = 0;\n-    virtual void set_bounds(int, int, bool, bool, int, int, int, int, float, float) = 0;\n-    virtual void set_resizable(bool) = 0;\n-    virtual void request_focus() = 0;\n-    virtual void set_focusable(bool)= 0;\n-    virtual bool grab_focus() = 0;\n-    virtual bool grab_mouse_drag_focus() = 0;\n-    virtual void ungrab_focus() = 0;\n-    virtual void ungrab_mouse_drag_focus() = 0;\n-    virtual void set_title(const char*) = 0;\n-    virtual void set_alpha(double) = 0;\n-    virtual void set_enabled(bool) = 0;\n-    virtual void set_minimum_size(int, int) = 0;\n-    virtual void set_maximum_size(int, int) = 0;\n-    virtual void set_minimized(bool) = 0;\n-    virtual void set_maximized(bool) = 0;\n-    virtual void set_icon(GdkPixbuf*) = 0;\n-    virtual void to_front() = 0;\n-    virtual void to_back() = 0;\n-    virtual void set_cursor(GdkCursor*) = 0;\n-    virtual void set_modal(bool, WindowContext* parent = NULL) = 0;\n-    virtual void set_level(int) = 0;\n-    virtual void set_background(float, float, float) = 0;\n-\n-    virtual void process_realize() = 0;\n-    virtual void process_property_notify(GdkEventProperty*) = 0;\n-    virtual void process_configure(GdkEventConfigure*) = 0;\n-    virtual void process_focus(GdkEventFocus*) = 0;\n-    virtual void process_destroy() = 0;\n-    virtual void process_delete() = 0;\n-    virtual void process_expose(GdkEventExpose*) = 0;\n-    virtual void process_mouse_button(GdkEventButton*) = 0;\n-    virtual void process_mouse_motion(GdkEventMotion*) = 0;\n-    virtual void process_mouse_scroll(GdkEventScroll*) = 0;\n-    virtual void process_mouse_cross(GdkEventCrossing*) = 0;\n-    virtual void process_key(GdkEventKey*) = 0;\n-    virtual void process_state(GdkEventWindowState*) = 0;\n-\n-    virtual void notify_state(jint) = 0;\n-    virtual void notify_on_top(bool) {}\n-    virtual void update_view_size() = 0;\n-    virtual void notify_view_resize() = 0;\n-\n-    virtual void add_child(WindowContextTop* child) = 0;\n-    virtual void remove_child(WindowContextTop* child) = 0;\n-    virtual bool set_view(jobject) = 0;\n-\n-    virtual GdkWindow *get_gdk_window() = 0;\n-    virtual GtkWindow *get_gtk_window() = 0;\n-    virtual jobject get_jview() = 0;\n-    virtual jobject get_jwindow() = 0;\n-\n-    virtual void increment_events_counter() = 0;\n-    virtual void decrement_events_counter() = 0;\n-    virtual size_t get_events_count() = 0;\n-    virtual bool is_dead() = 0;\n-    virtual ~WindowContext() {}\n-};\n+class WindowContext: public DeletedMemDebug<0xCC> {\n+private:\n+    static std::optional<GdkRectangle> normal_extents;\n+    static std::optional<GdkRectangle> utility_extents;\n@@ -176,1 +91,11 @@\n-class WindowContextBase: public WindowContext {\n+    jlong screen;\n+    WindowFrameType frame_type;\n+    WindowType window_type;\n+    struct WindowContext *owner;\n+    WindowGeometry geometry;\n+    struct _Resizable {\/\/ we can't use set\/get gtk_window_resizable function\n+        _Resizable(): value(true),\n+                minw(-1), minh(-1), maxw(-1), maxh(-1) {}\n+        bool value; \/\/actual value of resizable for a window\n+        int minw, minh, maxw, maxh; \/\/minimum and maximum window width\/height;\n+    } resizable;\n@@ -186,4 +111,3 @@\n-    size_t events_processing_cnt;\n-    bool can_be_deleted;\n-protected:\n-    std::set<WindowContextTop*> children;\n+    size_t events_processing_cnt{};\n+\n+    std::set<WindowContext*> children;\n@@ -191,4 +115,6 @@\n-    jobject jview;\n-    GtkWidget* gtk_widget;\n-    GdkWindow* gdk_window = NULL;\n-    GdkWMFunction gdk_windowManagerFunctions;\n+    jobject jview{};\n+\n+    GtkWidget *gtk_widget;\n+    GdkWindow *gdk_window{};\n+    GdkWMFunction initial_wmf;\n+    GdkWMFunction current_wmf;\n@@ -196,2 +122,0 @@\n-    bool is_iconified;\n-    bool is_maximized;\n@@ -200,0 +124,3 @@\n+    bool on_top;\n+    bool can_be_deleted;\n+    bool was_mapped;\n@@ -201,0 +128,3 @@\n+    gint initial_state_mask;\n+protected:\n+protected:\n@@ -219,0 +149,1 @@\n+\n@@ -220,0 +151,2 @@\n+    WindowContext(jobject, WindowContext*, long, WindowFrameType, WindowType, GdkWMFunction);\n+\n@@ -222,1 +155,1 @@\n-    bool filterIME(GdkEvent *);\n+    bool filterIME(GdkEvent*);\n@@ -228,0 +161,1 @@\n+\n@@ -233,2 +167,2 @@\n-    void add_child(WindowContextTop*);\n-    void remove_child(WindowContextTop*);\n+    void add_child(WindowContext*);\n+    void remove_child(WindowContext*);\n@@ -243,2 +177,0 @@\n-    void set_level(int) {}\n-    void set_background(float, float, float);\n@@ -246,0 +178,1 @@\n+    void process_map();\n@@ -247,3 +180,1 @@\n-    void process_destroy();\n-    void process_delete();\n-    void process_expose(GdkEventExpose*);\n+    void notify_repaint(GdkRectangle*);\n@@ -256,2 +187,5 @@\n-\n-    void notify_state(jint);\n+    void process_realize();\n+    void process_property_notify(GdkEventProperty*);\n+    void process_configure(GdkEventConfigure*);\n+    void process_delete();\n+    void process_destroy();\n@@ -264,35 +198,0 @@\n-    ~WindowContextBase();\n-protected:\n-    virtual void applyShapeMask(void*, uint width, uint height) = 0;\n-};\n-\n-class WindowContextTop: public WindowContextBase {\n-    jlong screen;\n-    WindowFrameType frame_type;\n-    WindowType window_type;\n-    struct WindowContext *owner;\n-    WindowGeometry geometry;\n-    struct _Resizable {\/\/ we can't use set\/get gtk_window_resizable function\n-        _Resizable(): value(true),\n-                minw(-1), minh(-1), maxw(-1), maxh(-1) {}\n-        bool value; \/\/actual value of resizable for a window\n-        int minw, minh, maxw, maxh; \/\/minimum and maximum window width\/height;\n-    } resizable;\n-\n-    bool on_top;\n-    bool is_fullscreen;\n-\n-    static WindowFrameExtents normal_extents;\n-    static WindowFrameExtents utility_extents;\n-\n-    WindowManager wmanager;\n-public:\n-    WindowContextTop(jobject, WindowContext*, long, WindowFrameType, WindowType, GdkWMFunction);\n-\n-    void process_realize();\n-    void process_property_notify(GdkEventProperty*);\n-    void process_state(GdkEventWindowState*);\n-    void process_configure(GdkEventConfigure*);\n-    void process_destroy();\n-    void work_around_compiz_state();\n-\n@@ -308,1 +207,0 @@\n-    void set_alpha(double);\n@@ -317,2 +215,1 @@\n-    void set_visible(bool);\n-    void notify_on_top(bool);\n+    void set_owner(WindowContext*);\n@@ -320,1 +217,0 @@\n-    void notify_view_resize();\n@@ -325,2 +221,0 @@\n-    void set_owner(WindowContext*);\n-\n@@ -328,1 +222,4 @@\n-    void detach_from_java();\n+    void update_window_size_location();\n+    void update_initial_state();\n+\n+    ~WindowContext();\n@@ -333,0 +230,17 @@\n+    void maximize(bool);\n+    void iconify(bool);\n+    void get_view_size(int *, int *);\n+    void get_window_size(int *, int *);\n+    void resize(int, int);\n+    void move(int, int, bool, bool);\n+    void move(int, int);\n+    void add_wmf(GdkWMFunction);\n+    void remove_wmf(GdkWMFunction);\n+    void save_geometry();\n+    void notify_on_top(bool);\n+    void notify_window_resize(int, int, int);\n+    void notify_window_move(int, int);\n+    void notify_view_resize(int, int);\n+    void notify_view_move();\n+    void notify_current_sizes();\n+    GdkAtom get_net_frame_extents_atom();\n@@ -335,2 +249,2 @@\n-    void set_cached_extents(WindowFrameExtents ex);\n-    WindowFrameExtents get_cached_extents();\n+    void set_cached_extents(GdkRectangle);\n+    void load_cached_extents();\n@@ -338,0 +252,1 @@\n+    void remove_window_constraints();\n@@ -339,0 +254,1 @@\n+    void update_window_constraints(int, int);\n@@ -342,4 +258,0 @@\n-    void notify_window_move();\n-    void notify_window_resize();\n-    WindowContextTop(WindowContextTop&);\n-    WindowContextTop& operator= (const WindowContextTop&);\n@@ -364,0 +276,1 @@\n+                LOG0(\"EventsCounterHelper: delete ctx\\n\");\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":93,"deletions":180,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-void WindowContextBase::commitIME(gchar *str) {\n+void WindowContext::commitIME(gchar *str) {\n@@ -118,1 +118,1 @@\n-bool WindowContextBase::hasIME() {\n+bool WindowContext::hasIME() {\n@@ -122,1 +122,1 @@\n-bool WindowContextBase::filterIME(GdkEvent *event) {\n+bool WindowContext::filterIME(GdkEvent *event) {\n@@ -139,1 +139,1 @@\n-void WindowContextBase::setOnPreEdit(bool preedit) {\n+void WindowContext::setOnPreEdit(bool preedit) {\n@@ -143,1 +143,1 @@\n-void WindowContextBase::updateCaretPos() {\n+void WindowContext::updateCaretPos() {\n@@ -164,1 +164,1 @@\n-void WindowContextBase::enableOrResetIME() {\n+void WindowContext::enableOrResetIME() {\n@@ -188,1 +188,1 @@\n-void WindowContextBase::disableIME() {\n+void WindowContext::disableIME() {\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window_ime.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2025 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javafx.application.Application;\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.DoubleProperty;\n+import javafx.collections.FXCollections;\n+import javafx.geometry.Orientation;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.CheckBox;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Separator;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.VBox;\n+import javafx.stage.StageStyle;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.layout.FlowPane;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Stage;\n+\n+public class TestStage extends Application {\n+    private Stage testStage = new Stage();\n+    private Label lblWidth = new Label();\n+    private Label lblHeight = new Label();\n+    private Label lblMinWidth = new Label();\n+    private Label lblMinHeight = new Label();\n+    private Label lblMaxWidth = new Label();\n+    private Label lblMaxHeight = new Label();\n+    private Label lblX = new Label();\n+    private Label lblY = new Label();\n+    private Label lblSceneWidth = new Label();\n+    private Label lblSceneHeight = new Label();\n+    private Label lblSceneX = new Label();\n+    private Label lblSceneY = new Label();\n+    private ComboBox<StageStyle> cbStageStyle = new ComboBox<>(FXCollections.observableArrayList(StageStyle.values()));\n+    private CheckBox cbIsFullScreen = new CheckBox(\"Is FullScreen\");\n+    private CheckBox cbIsMaximized = new CheckBox(\"Is Maximized\");\n+    private CheckBox cbIsIconified = new CheckBox(\"Is Iconified\");\n+    private CheckBox cbIsResizable = new CheckBox(\"Is Resizable\");\n+\n+    @Override\n+    public void start(Stage stage) {\n+        cbStageStyle.valueProperty().addListener((observable, oldValue, newValue) -> {\n+            testStage.initStyle(StageStyle.valueOf(newValue.name()));\n+        });\n+\n+        cbStageStyle.getSelectionModel().select(StageStyle.DECORATED);\n+\n+        Button btnMaxminize = new Button(\"Toggle Maximize\");\n+        btnMaxminize.setOnAction(e -> testStage.setMaximized(!testStage.isMaximized()));\n+\n+        Button btnFullScreen = new Button(\"Toggle FullScreen\");\n+        btnFullScreen.setOnAction(e -> testStage.setFullScreen(!testStage.isFullScreen()));\n+\n+        Button btnIconify = new Button(\"Toggle Iconified\");\n+        btnIconify.setOnAction(e -> testStage.setIconified(!testStage.isIconified()));\n+\n+        Button btnResizable = new Button(\"Toggle Resizable\");\n+        btnResizable.setOnAction(e -> testStage.setResizable(!testStage.isResizable()));\n+\n+        Button btnShow = new Button(\"Show\");\n+        btnShow.setOnAction(e -> {\n+            testStage.show();\n+        });\n+\n+        Button btnClose = new Button(\"Close\");\n+        btnClose.setOnAction(e -> {\n+            testStage.close();\n+            createTestStage();\n+        });\n+\n+        Button btnSizeToScene = new Button(\"Size to scene\");\n+        btnSizeToScene.setOnAction(e -> {\n+            testStage.sizeToScene();\n+        });\n+\n+        Button btnCenterOnScreen = new Button(\"Center on screen\");\n+        btnCenterOnScreen.setOnAction(e -> {\n+            testStage.centerOnScreen();\n+        });\n+\n+        Button btnResize = new Button(\"Resize\");\n+        btnResize.setOnAction(e -> {\n+            testStage.setWidth(300);\n+            testStage.setHeight(300);\n+        });\n+\n+        Button btnMaxSize = new Button(\"Set Max Size\");\n+        btnMaxSize.setOnAction(e -> {\n+            testStage.setMaxWidth(250);\n+            testStage.setMaxHeight(250);\n+        });\n+\n+        Button btnUnsetMaxSize = new Button(\"Unset Max Size\");\n+        btnUnsetMaxSize.setOnAction(e -> {\n+            testStage.setMaxWidth(Double.MAX_VALUE);\n+            testStage.setMaxHeight(Double.MAX_VALUE);\n+        });\n+\n+        Button btnMove = new Button(\"Move\");\n+        btnMove.setOnAction(e -> {\n+            testStage.setX(100);\n+            testStage.setY(100);\n+        });\n+\n+        cbIsMaximized.setDisable(true);\n+        cbIsFullScreen.setDisable(true);\n+        cbIsIconified.setDisable(true);\n+        cbIsResizable.setDisable(true);\n+\n+        FlowPane commandPane = new FlowPane(cbStageStyle, btnShow, btnClose, btnSizeToScene, btnCenterOnScreen,\n+                btnResize, btnMaxSize, btnUnsetMaxSize, btnMove, btnIconify, btnMaxminize, btnFullScreen, btnResizable);\n+        commandPane.setHgap(5);\n+        commandPane.setVgap(5);\n+\n+\n+        VBox root = new VBox(commandPane,\n+                new Separator(Orientation.HORIZONTAL),\n+                new Label(\"Stage Properties:\"),\n+                cbIsIconified, cbIsMaximized,\n+                cbIsFullScreen, cbIsResizable,\n+                lblMinWidth, lblMinHeight, lblMaxWidth, lblMaxHeight,\n+                lblWidth, lblHeight, lblX, lblY,\n+                new Separator(Orientation.HORIZONTAL),\n+                new Label(\"Scene Properties:\"),\n+                lblSceneWidth, lblSceneHeight, lblSceneX, lblSceneY);\n+        root.setSpacing(5);\n+        root.setFillWidth(true);\n+\n+        createTestStage();\n+\n+        Scene scene = new Scene(root, 500, 600);\n+        stage.setTitle(\"Command Stage\");\n+        stage.setScene(scene);\n+        stage.show();\n+    }\n+\n+    private void createTestStage() {\n+        testStage = new Stage();\n+\n+        StackPane stackPane = new StackPane();\n+        stackPane.setBackground(Background.fill(Color.TRANSPARENT));\n+        testStage = new Stage();\n+        Scene testScene = new Scene(stackPane, 300, 300, Color.HOTPINK);\n+        testStage.setScene(testScene);\n+        testStage.initStyle(cbStageStyle.getValue());\n+        testStage.setTitle(\"Test Stage\");\n+        testStage.setWidth(800);\n+        testStage.setHeight(600);\n+\n+        cbIsMaximized.selectedProperty().bind(testStage.maximizedProperty());\n+        cbIsFullScreen.selectedProperty().bind(testStage.fullScreenProperty());\n+        cbIsIconified.selectedProperty().bind(testStage.iconifiedProperty());\n+        cbIsResizable.selectedProperty().bind(testStage.resizableProperty());\n+        lblWidth.textProperty().bind(Bindings.format(\"Width: %.2f\", testStage.widthProperty()));\n+        lblHeight.textProperty().bind(Bindings.format(\"Height: %.2f\", testStage.heightProperty()));\n+        lblMinWidth.textProperty().bind(Bindings.format(\"Min Width: %.2f\", testStage.minWidthProperty()));\n+        lblMinHeight.textProperty().bind(Bindings.format(\"Min Height: %.2f\", testStage.minHeightProperty()));\n+        lblMaxWidth.textProperty().bind(Bindings.format(\"Max Width: %.2f\", testStage.maxWidthProperty()));\n+        lblMaxHeight.textProperty().bind(Bindings.format(\"Max Height: %.2f\", testStage.maxHeightProperty()));\n+        lblX.textProperty().bind(Bindings.format(\"X: %.2f\", testStage.xProperty()));\n+        lblY.textProperty().bind(Bindings.format(\"Y: %.2f\", testStage.yProperty()));\n+        lblSceneWidth.textProperty().bind(Bindings.format(\"Width: %.2f\", testScene.widthProperty()));\n+        lblSceneHeight.textProperty().bind(Bindings.format(\"Height: %.2f\", testScene.heightProperty()));\n+        lblSceneX.textProperty().bind(Bindings.format(\"X: %.2f\", testScene.xProperty()));\n+        lblSceneY.textProperty().bind(Bindings.format(\"Y: %.2f\", testScene.yProperty()));\n+    }\n+\n+    public static void main(String[] args) {\n+        launch(TestStage.class, args);\n+    }\n+}\n","filename":"tests\/manual\/stage\/TestStage.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -94,2 +94,1 @@\n-        \/\/ Disable on Linux until JDK-8353556 is fixed\n-        assumeTrue(!(PlatformUtil.isMac() || PlatformUtil.isLinux()));\n+        assumeTrue(!PlatformUtil.isMac());\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/RestoreSceneSizeTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.stage;\n+\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.layout.Region;\n+import javafx.scene.layout.StackPane;\n+import javafx.stage.Screen;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.util.Util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+\n+class CenterOnScreenTest extends StageTestBase {\n+    private static final float CENTER_ON_SCREEN_X_FRACTION = 1.0f \/ 2;\n+    private static final float CENTER_ON_SCREEN_Y_FRACTION = 1.0f \/ 3;\n+\n+    private static final double STAGE_WIDTH = 400;\n+    private static final double STAGE_HEIGHT = 200;\n+\n+    \/\/ Must be cointained in Stage dimensions\n+    private static final double SCENE_WIDTH = 300;\n+    private static final double SCENE_HEIGHT = 100;\n+\n+    private static final double DECORATED_DELTA = 50.0;\n+\n+    @Override\n+    protected Region createRoot() {\n+        StackPane stackPane = new StackPane();\n+        stackPane.setPrefSize(SCENE_WIDTH, SCENE_HEIGHT);\n+        return stackPane;\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testStateCenterOnScreenWhenShown(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, stage -> {\n+            stage.setWidth(STAGE_WIDTH);\n+            stage.setHeight(STAGE_HEIGHT);\n+        });\n+        Util.sleep(MEDIUM_WAIT);\n+        assertStageCentered(stageStyle, false);\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testStateCenterOnScreenWhenShownWithSceneSize(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, null);\n+        Util.sleep(MEDIUM_WAIT);\n+        assertStageCentered(stageStyle, true);\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testStateCenterOnScreenAfterShown(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, stage -> {\n+            stage.setWidth(STAGE_WIDTH);\n+            stage.setHeight(STAGE_HEIGHT);\n+            stage.setX(0);\n+            stage.setY(0);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+        Util.runAndWait(() -> getStage().centerOnScreen());\n+        Util.sleep(MEDIUM_WAIT);\n+        assertStageCentered(stageStyle, false);\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testStateCenterOnScreenAfterShownWithSceneSize(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, stage -> {\n+            stage.setX(0);\n+            stage.setY(0);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+        Util.runAndWait(() -> getStage().centerOnScreen());\n+        Util.sleep(MEDIUM_WAIT);\n+        assertStageCentered(stageStyle, true);\n+    }\n+\n+\n+    private void assertStageCentered(StageStyle stageStyle, boolean useSceneSize) {\n+        Screen screen = Util.getScreen(getStage());\n+\n+        double delta = (stageStyle == StageStyle.DECORATED) ? DECORATED_DELTA : SIZING_DELTA;\n+\n+        Rectangle2D bounds = screen.getVisualBounds();\n+        double centerX =\n+                bounds.getMinX() + (bounds.getWidth() - ((useSceneSize) ? SCENE_WIDTH : STAGE_WIDTH))\n+                        * CENTER_ON_SCREEN_X_FRACTION;\n+        double centerY =\n+                bounds.getMinY() + (bounds.getHeight() - ((useSceneSize) ? SCENE_HEIGHT : STAGE_HEIGHT))\n+                        * CENTER_ON_SCREEN_Y_FRACTION;\n+\n+        assertEquals(centerX, getStage().getX(), delta, \"Stage is not centered in X axis\");\n+        assertEquals(centerY, getStage().getY(), delta, \"Stage is not centered in Y axis\");\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/CenterOnScreenTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.stage;\n+\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.util.Util;\n+\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+\n+class FullScreenTest extends StageTestBase {\n+    private static final int POS_X = 100;\n+    private static final int POS_Y = 150;\n+    private static final int WIDTH = 100;\n+    private static final int HEIGHT = 150;\n+\n+    private static final int SHOW_WIDTH = 500;\n+    private static final int SHOW_HEIGHT = 500;\n+    private static final int SHOW_X = 500;\n+    private static final int SHOW_Y = 500;\n+\n+    private static final Consumer<Stage> TEST_SETTINGS = s -> {\n+        s.setWidth(WIDTH);\n+        s.setHeight(HEIGHT);\n+        s.setX(POS_X);\n+        s.setY(POS_Y);\n+    };\n+\n+    private static final Consumer<Stage> CHANGE_GEOMETRY_TESTS_SETTINGS = s -> {\n+        s.setWidth(SHOW_WIDTH);\n+        s.setHeight(SHOW_HEIGHT);\n+        s.setX(SHOW_X);\n+        s.setY(SHOW_Y);\n+    };\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testFullScreenShouldKeepGeometryOnRestore(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS);\n+\n+        Util.doTimeLine(LONG_WAIT,\n+                () -> getStage().setFullScreen(true),\n+                () -> assertTrue(getStage().isFullScreen()),\n+                () -> getStage().setFullScreen(false));\n+\n+        Util.sleep(LONG_WAIT);\n+        assertSizePosition();\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testFullScreenBeforeShowShouldKeepGeometryOnRestore(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS.andThen(s -> s.setFullScreen(true)));\n+\n+        Util.sleep(LONG_WAIT);\n+        Util.runAndWait(() -> {\n+            assertTrue(getStage().isFullScreen());\n+            getStage().setFullScreen(false);\n+        });\n+\n+        Util.sleep(LONG_WAIT);\n+        assertSizePosition();\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testUnFullScreenChangedPosition(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, CHANGE_GEOMETRY_TESTS_SETTINGS);\n+\n+        Util.doTimeLine(LONG_WAIT,\n+                () -> getStage().setFullScreen(true),\n+                () -> assertTrue(getStage().isFullScreen()),\n+                () -> {\n+                    getStage().setX(POS_X);\n+                    getStage().setY(POS_Y);\n+                },\n+                () -> getStage().setFullScreen(false));\n+\n+        Util.sleep(LONG_WAIT);\n+\n+        assertEquals(POS_X, getStage().getX(), POSITION_DELTA,\n+                \"Window failed to restore position set while fullscreened\");\n+        assertEquals(POS_Y, getStage().getY(), POSITION_DELTA,\n+                \"Window failed to restore position set while fullscreened\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testUnFullScreenChangedSize(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, CHANGE_GEOMETRY_TESTS_SETTINGS);\n+\n+        Util.doTimeLine(LONG_WAIT,\n+                () -> getStage().setFullScreen(true),\n+                () -> assertTrue(getStage().isFullScreen()),\n+                () -> {\n+                    getStage().setWidth(WIDTH);\n+                    getStage().setHeight(HEIGHT);\n+                },\n+                () -> getStage().setFullScreen(false));\n+\n+        Util.sleep(LONG_WAIT);\n+\n+        assertEquals(WIDTH, getStage().getWidth(), SIZING_DELTA, \"Window failed to restore size set while fullscreened\");\n+        assertEquals(HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Window failed to restore size set while fullscreened\");\n+    }\n+\n+    private void assertSizePosition() {\n+        assertEquals(WIDTH, getStage().getWidth(), SIZING_DELTA, \"Stage's width should have remained\");\n+        assertEquals(HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Stage's height should have remained\");\n+        assertEquals(POS_X, getStage().getX(), POSITION_DELTA,  \"Stage's X position should have remained\");\n+        assertEquals(POS_Y, getStage().getY(), POSITION_DELTA, \"Stage's Y position should have remained\");\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/FullScreenTest.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.stage;\n+\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.util.Util;\n+\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+\n+class MaximizeTest extends StageTestBase {\n+    private static final int WIDTH = 300;\n+    private static final int HEIGHT = 300;\n+    private static final int POS_X = 100;\n+    private static final int POS_Y = 150;\n+\n+    private static final Consumer<Stage> TEST_SETTINGS = s -> {\n+        s.setWidth(WIDTH);\n+        s.setHeight(HEIGHT);\n+        s.setX(POS_X);\n+        s.setY(POS_Y);\n+    };\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"UNDECORATED\", \"TRANSPARENT\"})\n+    void testMaximizeUndecorated(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS);\n+\n+        Util.doTimeLine(SHORT_WAIT,\n+                () -> getStage().setMaximized(true),\n+                () ->  {\n+                    assertTrue(getStage().isMaximized());\n+                    assertNotEquals(POS_X, getStage().getX());\n+                    assertNotEquals(POS_Y, getStage().getY());\n+                },\n+                () -> getStage().setMaximized(false));\n+\n+        Util.sleep(SHORT_WAIT);\n+\n+        assertEquals(POS_X, getStage().getX(), POSITION_DELTA, \"Stage maximized position changed\");\n+        assertEquals(POS_Y, getStage().getY(), POSITION_DELTA, \"Stage maximized position changed\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testMaximizeKeepGeometryOnRestore(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS);\n+\n+        Util.doTimeLine(SHORT_WAIT,\n+                () -> getStage().setMaximized(true),\n+                () -> assertTrue(getStage().isMaximized()),\n+                () -> getStage().setMaximized(false));\n+\n+        Util.sleep(SHORT_WAIT);\n+        assertSizePosition();\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testMaximizeBeforeShowShouldKeepGeometryOnRestore(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS.andThen(s -> s.setMaximized(true)));\n+        Util.sleep(SHORT_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            assertTrue(getStage().isMaximized());\n+            getStage().setMaximized(false);\n+        });\n+        Util.sleep(SHORT_WAIT);\n+        assertSizePosition();\n+    }\n+\n+    private void assertSizePosition() {\n+        assertEquals(WIDTH, getStage().getWidth(), SIZING_DELTA, \"Stage's width should have remained\");\n+        assertEquals(HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Stage's height should have remained\");\n+        assertEquals(POS_X, getStage().getX(), POSITION_DELTA, \"Stage's X position should have remained\");\n+        assertEquals(POS_Y, getStage().getY(), POSITION_DELTA, \"Stage's Y position should have remained\");\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/MaximizeTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.javafx.stage;\n-\n-import java.util.concurrent.CountDownLatch;\n-import javafx.application.Application;\n-import javafx.application.Platform;\n-import javafx.scene.Group;\n-import javafx.scene.Scene;\n-import javafx.stage.Stage;\n-import javafx.stage.StageStyle;\n-import javafx.stage.WindowEvent;\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.Test;\n-import test.util.Util;\n-\n-public class MaximizeUndecorated {\n-    static CountDownLatch startupLatch = new CountDownLatch(1);\n-    static Stage stage;\n-    static final int POS = 500;\n-\n-    public static class TestApp extends Application {\n-        @Override\n-        public void start(Stage primaryStage) throws Exception {\n-            primaryStage.setScene(new Scene(new Group()));\n-            stage = primaryStage;\n-            stage.addEventHandler(WindowEvent.WINDOW_SHOWN, e ->\n-                    Platform.runLater(startupLatch::countDown));\n-            stage.initStyle(StageStyle.UNDECORATED);\n-            stage.setX(POS);\n-            stage.setY(POS);\n-            stage.setOnShown(e -> stage.setMaximized(true));\n-            stage.show();\n-        }\n-    }\n-\n-    @BeforeAll\n-    public static void initFX() {\n-        Util.launch(startupLatch, TestApp.class);\n-    }\n-\n-    @AfterAll\n-    public static void teardown() {\n-        Util.shutdown();\n-    }\n-\n-    @Test\n-    public void testMaximize() throws Exception {\n-        Util.sleep(200);\n-\n-        boolean movedToTopCorner = stage.getY() != POS && stage.getX() != POS;\n-        Assertions.assertTrue(movedToTopCorner, \"Stage has moved to desktop top corner\");\n-    }\n-}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/MaximizeUndecorated.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -123,1 +123,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -135,1 +134,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -147,1 +145,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -159,1 +156,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -171,1 +167,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -184,1 +179,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -197,1 +191,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -210,1 +203,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/SizeToSceneTest.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.stage;\n+\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.ReadOnlyDoubleProperty;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.Region;\n+import javafx.scene.layout.VBox;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.util.Util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+\n+class SizingTest extends StageTestBase {\n+    private static final int WIDTH = 300;\n+    private static final int HEIGHT = 300;\n+    private static final int MAX_WIDTH = 350;\n+    private static final int MAX_HEIGHT = 350;\n+    private static final int MIN_WIDTH = 500;\n+    private static final int MIN_HEIGHT = 500;\n+    private static final int NEW_WIDTH = 450;\n+    private static final int NEW_HEIGHT = 450;\n+\n+\n+    protected Label createLabel(String prefix, ReadOnlyDoubleProperty property) {\n+        Label label = new Label();\n+        label.textProperty().bind(Bindings.concat(prefix, Bindings.convert(property)));\n+        return label;\n+    }\n+\n+    @Override\n+    protected Region createRoot() {\n+        VBox vBox = new VBox(createLabel(\"Width: \", getStage().widthProperty()),\n+                             createLabel(\"Height: \", getStage().heightProperty()),\n+                             createLabel(\"Max Width: \", getStage().maxWidthProperty()),\n+                             createLabel(\"Max Height: \", getStage().maxHeightProperty()),\n+                             createLabel(\"Min Width: \", getStage().minWidthProperty()),\n+                             createLabel(\"Min Height: \", getStage().minHeightProperty()));\n+        vBox.setBackground(Background.EMPTY);\n+\n+        return vBox;\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testMaximizeUnresizable(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.initStyle(stageStyle);\n+            s.setWidth(WIDTH);\n+            s.setHeight(HEIGHT);\n+            s.setResizable(false);\n+        });\n+        Util.runAndWait(() -> getStage().setMaximized(true));\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertTrue(getStage().isMaximized(), \"Unresizable stage should be maximized\");\n+        assertTrue(getStage().getWidth() > WIDTH, \"Stage width should be maximized\");\n+        assertTrue(getStage().getHeight() > HEIGHT, \"Stage height should be maximized\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\"})\n+    void testFullScreenUnresizable(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.initStyle(stageStyle);\n+            s.setWidth(WIDTH);\n+            s.setHeight(HEIGHT);\n+            s.setResizable(false);\n+        });\n+\n+        Util.runAndWait(() -> getStage().setFullScreen(true));\n+        Util.sleep(LONG_WAIT);\n+        assertTrue(getStage().isFullScreen(), \"Unresizable stage should be fullscreen\");\n+        assertTrue(getStage().getWidth() > WIDTH, \"Stage width should be fullscreen\");\n+        assertTrue(getStage().getHeight() > HEIGHT, \"Stage height should be fullscreen\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testResizeUnresizable(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.initStyle(stageStyle);\n+            s.setWidth(WIDTH);\n+            s.setHeight(HEIGHT);\n+            s.setResizable(false);\n+        });\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA, \"Stage should have resized\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Stage should have resized\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testMaxSize(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.initStyle(stageStyle);\n+            s.setMaxWidth(MAX_WIDTH);\n+            s.setMaxHeight(MAX_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(MAX_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been limited to max width\");\n+        assertEquals(MAX_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been limited to max height\");\n+\n+        \/\/ Reset it\n+        Util.runAndWait(() -> {\n+            getStage().setMaxWidth(Double.MAX_VALUE);\n+            getStage().setMaxHeight(Double.MAX_VALUE);\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been accepted after removing min width\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been accepted after removing min height\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testMaxWidth(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.initStyle(stageStyle);\n+            s.setMaxWidth(MAX_WIDTH);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(MAX_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been limited to max width\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Only max width should be limited\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testMaxHeight(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.initStyle(stageStyle);\n+            s.setMaxHeight(MAX_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Only max height should be limited\");\n+        assertEquals(MAX_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been limited to max height\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testMinSize(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.initStyle(stageStyle);\n+            s.setMinWidth(MIN_WIDTH);\n+            s.setMinHeight(MIN_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(MIN_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been limited to min width\");\n+        assertEquals(MIN_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been limited to min height\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testMinWidth(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.initStyle(stageStyle);\n+            s.setMinWidth(MIN_WIDTH);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(MIN_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been limited to min width\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Only min width should be limited\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testMinHeight(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.initStyle(stageStyle);\n+            s.setMinHeight(MIN_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Only min height should be limited\");\n+        assertEquals(MIN_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been limited to min height\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testNoSize(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> s.initStyle(stageStyle));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertTrue(getStage().getWidth() > 1, \"Stage width should be greater than 1\");\n+        assertTrue(getStage().getHeight() > 1, \"Stage height should be greater than 1\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testNoHeight(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.initStyle(stageStyle);\n+            s.setWidth(WIDTH);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(WIDTH, getStage().getWidth(), SIZING_DELTA, \"Stage do not match the set width\");\n+        assertTrue(getStage().getHeight() > 1, \"Stage height should be greater than 1\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void testNoWidth(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.initStyle(stageStyle);\n+            s.setHeight(HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertTrue(getStage().getWidth() > 1, \"Stage width should be greater than 1\");\n+        assertEquals(HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Stage do not match the set height\");\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/SizingTest.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.stage;\n+\n+import javafx.application.Platform;\n+import javafx.geometry.Insets;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.BackgroundFill;\n+import javafx.scene.layout.CornerRadii;\n+import javafx.scene.layout.Region;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import test.util.Util;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+abstract class StageTestBase {\n+    private static final CountDownLatch startupLatch = new CountDownLatch(1);\n+    private Stage stage = null;\n+\n+    protected static final int SHORT_WAIT = 300;\n+    protected static final int MEDIUM_WAIT = 500;\n+    protected static final int LONG_WAIT = 1000;\n+    protected static final double SIZING_DELTA = 1.0;\n+    protected static final double POSITION_DELTA = 1.0;\n+\n+    \/**\n+     * Creates a Scene for the test stage acoording to the {@link StageStyle}\n+     * @param stageStyle {@link StageStyle} of the Stage\n+     * @return a {@link Scene}\n+     *\/\n+    protected Scene createScene(StageStyle stageStyle) {\n+        if (stageStyle == StageStyle.TRANSPARENT) {\n+            Region root = createRoot();\n+            BackgroundFill fill = new BackgroundFill(\n+                    Color.HOTPINK.deriveColor(0, 1, 1, 0.5),\n+                    CornerRadii.EMPTY,\n+                    Insets.EMPTY\n+            );\n+            root.setBackground(new Background(fill));\n+\n+            Scene scene = new Scene(root);\n+            scene.setFill(Color.TRANSPARENT);\n+\n+            return scene;\n+        }\n+\n+        return new Scene(createRoot(), Color.HOTPINK);\n+    }\n+\n+    \/**\n+     * Gets the Scene root\n+     *\/\n+    protected Region createRoot() {\n+        return new StackPane();\n+    }\n+\n+    \/**\n+     * Utility method to setup test Stages according to {@link StageStyle}\n+     * @param stageStyle The Stage Style.\n+     * @param pc A consumer to set state properties\n+     *\/\n+    protected void setupStageWithStyle(StageStyle stageStyle, Consumer<Stage> pc) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            assertNull(stage, \"Stage is not null\");\n+            stage = new Stage();\n+            stage.setAlwaysOnTop(true);\n+            if (pc != null) {\n+                pc.accept(stage);\n+            }\n+            stage.initStyle(stageStyle);\n+            stage.setScene(createScene(stageStyle));\n+            stage.setOnShown(e -> shownLatch.countDown());\n+            stage.show();\n+        });\n+\n+        Util.waitForLatch(shownLatch, 5, \"Stage failed to show\");\n+    }\n+\n+    @BeforeAll\n+    public static void initFX() {\n+        Platform.setImplicitExit(false);\n+        Util.startup(startupLatch, startupLatch::countDown);\n+    }\n+\n+    @AfterAll\n+    public static void teardown() {\n+        Util.shutdown();\n+    }\n+\n+    \/**\n+     * Hides the test stage after each test\n+     *\/\n+    @AfterEach\n+    public void cleanup() {\n+        if (stage != null) {\n+            CountDownLatch hideLatch = new CountDownLatch(1);\n+            stage.setOnHidden(e -> hideLatch.countDown());\n+            Util.runAndWait(stage::hide);\n+            Util.waitForLatch(hideLatch, 5, \"Stage failed to hide\");\n+            stage = null;\n+        }\n+    }\n+\n+    \/**\n+     * @return The stage that is created for each test\n+     *\/\n+    protected Stage getStage() {\n+        return stage;\n+    }\n+\n+    \/**\n+     * Gets the Scene of the test stage.\n+     * @return The Scene of the test stage.\n+     *\/\n+    protected Scene getScene() {\n+        return stage.getScene();\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/StageTestBase.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -150,4 +150,0 @@\n-        if (PlatformUtil.isLinux()) {\n-            Assumptions.assumeTrue(Boolean.getBoolean(\"unstable.test\")); \/\/ JDK-8321624\n-        }\n-\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/DualWindowTest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,1 +129,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ Skip due to JDK-8316891\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/IconifyTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,5 +28,0 @@\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assumptions.assumeTrue;\n-import static test.util.Util.TIMEOUT;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n@@ -39,2 +34,2 @@\n-import org.junit.jupiter.api.Test;\n-import com.sun.javafx.PlatformUtil;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n@@ -42,0 +37,9 @@\n+import test.util.Util;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+import static test.util.Util.TIMEOUT;\n@@ -53,0 +57,3 @@\n+    private static final int WAIT = 1000;\n+    private static final int SHORT_WAIT = 100;\n+\n@@ -57,1 +64,2 @@\n-    private void setupStages(boolean overlayed, boolean topShown) throws InterruptedException {\n+    private void setupStages(boolean overlayed, boolean topShown, StageStyle topStageStyle)\n+            throws InterruptedException {\n@@ -79,1 +87,1 @@\n-            topStage.initStyle(StageStyle.DECORATED);\n+            topStage.initStyle(topStageStyle);\n@@ -100,1 +108,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -103,7 +111,4 @@\n-    @Test\n-    public void testIconifiedStage() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(true, true);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(value = StageStyle.class, mode = EnumSource.Mode.INCLUDE, names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testIconifiedStage(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(true, true, stageStyle);\n@@ -119,1 +124,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -128,7 +133,4 @@\n-    @Test\n-    public void testMaximizedStage() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(false, true);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testMaximizedStage(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(false, true, stageStyle);\n@@ -144,1 +146,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -154,0 +156,5 @@\n+        \/\/ Do not test decorations for UNDECORATED\n+        if (stageStyle.equals(StageStyle.UNDECORATED)) {\n+            return;\n+        }\n+\n@@ -156,1 +163,1 @@\n-        sleep(100);\n+        sleep(SHORT_WAIT);\n@@ -166,7 +173,4 @@\n-    @Test\n-    public void testFullScreenStage() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(false, true);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testFullScreenStage(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(false, true, stageStyle);\n@@ -182,1 +186,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -194,1 +198,1 @@\n-        sleep(100);\n+        sleep(SHORT_WAIT);\n@@ -203,7 +207,4 @@\n-    @Test\n-    public void testIconifiedStageBeforeShow() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(true, false);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testIconifiedStageBeforeShow(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(true, false, stageStyle);\n@@ -221,1 +222,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -232,8 +233,4 @@\n-    @Test\n-    public void testMaximizedStageBeforeShow() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        \/\/  - JDK-8316425\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(false, false);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testMaximizedStageBeforeShow(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(false, false, stageStyle);\n@@ -250,1 +247,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -260,0 +257,6 @@\n+\n+        \/\/ Do not test decorations for UNDECORATED\n+        if (stageStyle.equals(StageStyle.UNDECORATED)) {\n+            return;\n+        }\n+\n@@ -262,1 +265,1 @@\n-        sleep(100);\n+        sleep(SHORT_WAIT);\n@@ -272,8 +275,4 @@\n-    @Test\n-    public void testFullScreenStageBeforeShow() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        \/\/  - JDK-8316425\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(false, false);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testFullScreenStageBeforeShow(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(false, false, stageStyle);\n@@ -290,1 +289,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -302,1 +301,1 @@\n-        sleep(100);\n+        sleep(SHORT_WAIT);\n@@ -310,1 +309,127 @@\n-}\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    void testStageStatePrecedenceOrderIconifiedMaximizedBeforeShow(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(false, false, stageStyle);\n+\n+        Util.doTimeLine(WAIT,\n+                () -> {\n+                    Color color = getColor(200, 200);\n+                    assertColorEquals(BOTTOM_COLOR, color, TOLERANCE);\n+\n+                    topStage.setIconified(true);\n+                    topStage.setMaximized(true);\n+                    topStage.show();\n+                },\n+                () -> {\n+                    assertTrue(topStage.isIconified());\n+                    assertTrue(topStage.isMaximized());\n+\n+                    Color color = getColor(200, 200);\n+                    \/\/ Should remain iconified\n+                    assertColorEquals(BOTTOM_COLOR, color, TOLERANCE);\n+                },\n+                () -> topStage.setIconified(false),\n+                () -> {\n+                    assertTrue(topStage.isMaximized());\n+                    assertFalse(topStage.isIconified());\n+\n+                    Color color = getColor(200, 200);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+                });\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    void testStageStatePrecedenceOrderIconifiedFullScreenBeforeShow(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(false, false, stageStyle);\n+\n+        Util.doTimeLine(WAIT,\n+                () -> {\n+                    Color color = getColor(200, 200);\n+                    assertColorEquals(BOTTOM_COLOR, color, TOLERANCE);\n+\n+                    topStage.setIconified(true);\n+                    topStage.setFullScreen(true);\n+                    topStage.show();\n+                },\n+                () -> {\n+                    assertTrue(topStage.isIconified());\n+                    assertTrue(topStage.isFullScreen());\n+\n+                    Color color = getColor(200, 200);\n+                    \/\/ Should remain iconified\n+                    assertColorEquals(BOTTOM_COLOR, color, TOLERANCE);\n+                },\n+                () -> topStage.setIconified(false),\n+                () -> {\n+                    assertTrue(topStage.isFullScreen());\n+                    assertFalse(topStage.isIconified());\n+\n+                    Color color = getColor(200, 200);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+                });\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    void testStageStatePrecedenceOrderIconifiedMaximizedAfterShow(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(true, true, stageStyle);\n+\n+        Util.doTimeLine(WAIT,\n+                () -> {\n+                    Color color = getColor(200, 200);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+\n+                    topStage.setIconified(true);\n+                    topStage.setMaximized(true);\n+                },\n+                () -> {\n+                    assertTrue(topStage.isMaximized());\n+                    assertTrue(topStage.isIconified());\n+\n+                    Color color = getColor(200, 200);\n+                    \/\/ Should remain iconified\n+                    assertColorEquals(BOTTOM_COLOR, color, TOLERANCE);\n+                },\n+                () -> topStage.setIconified(false),\n+                () -> {\n+                    assertTrue(topStage.isMaximized());\n+                    assertFalse(topStage.isIconified());\n+\n+                    Color color = getColor(200, 200);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+                });\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    void testStageStatePrecedenceOrderIconifiedFullScreenAfterShow(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(true, true, stageStyle);\n+\n+        Util.doTimeLine(WAIT,\n+                () -> {\n+                    Color color = getColor(200, 200);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+\n+                    topStage.setIconified(true);\n+                    topStage.setFullScreen(true);\n+                },\n+                () -> {\n+                    assertTrue(topStage.isFullScreen());\n+                    assertTrue(topStage.isIconified());\n+\n+                    Color color = getColor(200, 200);\n+                    \/\/ Should remain iconified\n+                    assertColorEquals(BOTTOM_COLOR, color, TOLERANCE);\n+                },\n+                () -> topStage.setIconified(false),\n+                () -> {\n+                    assertTrue(topStage.isFullScreen());\n+                    assertFalse(topStage.isIconified());\n+\n+                    Color color = getColor(200, 200);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+                });\n+    }\n+}\n\\ No newline at end of file\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageAttributesTest.java","additions":190,"deletions":65,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.robot.javafx.stage;\n+\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.ReadOnlyDoubleProperty;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.robot.testharness.VisualTestBase;\n+import test.util.Util;\n+\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+\n+class StageLocationTest extends VisualTestBase {\n+    private static final int WIDTH = 300;\n+    private static final int HEIGHT = 300;\n+    private static final int X = 100;\n+    private static final int Y = 100;\n+    private static final int TO_X = 500;\n+    private static final int TO_Y = 500;\n+    private static final Color COLOR = Color.RED;\n+    private static final double TOLERANCE = 0.07;\n+    private static final int WAIT = 300;\n+\n+    private Stage createStage(StageStyle stageStyle) {\n+        Stage s = getStage(true);\n+        s.initStyle(stageStyle);\n+        VBox vBox = new VBox(createLabel(\"X: \", s.xProperty()),\n+                createLabel(\"Y: \", s.yProperty()));\n+        vBox.setBackground(Background.EMPTY);\n+        Scene scene = new Scene(vBox, WIDTH, HEIGHT);\n+        scene.setFill(COLOR);\n+        s.setScene(scene);\n+        s.setWidth(WIDTH);\n+        s.setHeight(HEIGHT);\n+        return s;\n+    }\n+\n+    protected Label createLabel(String prefix, ReadOnlyDoubleProperty property) {\n+        Label label = new Label();\n+        label.textProperty().bind(Bindings.concat(prefix, Bindings.convert(property)));\n+        return label;\n+    }\n+\n+    private void assertColorEquals(Color expected, int x, int y) {\n+        Color color = getColor(x, y);\n+        assertColorEquals(expected, color, TOLERANCE);\n+    }\n+\n+    private Stage stage;\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"UTILITY\"})\n+    void testMove(StageStyle stageStyle) {\n+        Util.runAndWait(() -> stage = createStage(stageStyle));\n+\n+        Util.doTimeLine(WAIT,\n+                () -> {\n+                    stage.setX(X);\n+                    stage.setY(Y);\n+                },\n+                stage::show,\n+                () -> assertColorEquals(COLOR, X + 100, Y + 100),\n+                () -> {\n+                    stage.setX(TO_X);\n+                    stage.setY(TO_Y);\n+                },\n+                () -> assertColorEquals(COLOR, TO_X + 100, TO_Y + 100));\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"UTILITY\"})\n+    void testMoveXAxis(StageStyle stageStyle) {\n+        Util.runAndWait(() -> stage = createStage(stageStyle));\n+\n+        Util.doTimeLine(WAIT,\n+                () -> {\n+                    stage.setX(X);\n+                    stage.setY(Y);\n+                },\n+                stage::show,\n+                () -> assertColorEquals(COLOR, X + 100, Y + 100),\n+                () -> stage.setX(TO_X),\n+                () -> assertColorEquals(COLOR, TO_X + 100, Y + 100));\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"UTILITY\"})\n+    void testMoveYAxis(StageStyle stageStyle) {\n+        Util.runAndWait(() -> stage = createStage(stageStyle));\n+\n+        Util.doTimeLine(WAIT,\n+                () -> {\n+                    stage.setX(X);\n+                    stage.setY(Y);\n+                },\n+                stage::show,\n+                () -> assertColorEquals(COLOR, X + 100, Y + 100),\n+                () -> stage.setY(TO_Y),\n+                () -> assertColorEquals(COLOR, X + 100, TO_Y + 100));\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"UTILITY\"})\n+    void testMoveAfterShow(StageStyle stageStyle) {\n+        Util.runAndWait(() -> stage = createStage(stageStyle));\n+\n+        Util.doTimeLine(WAIT,\n+                stage::show,\n+                () -> {\n+                    stage.setX(TO_X);\n+                    stage.setY(TO_Y);\n+                },\n+                () -> assertColorEquals(COLOR, TO_X + 100, TO_Y + 100));\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageLocationTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import javafx.animation.KeyFrame;\n-import javafx.animation.Timeline;\n-import javafx.geometry.Insets;\n@@ -32,4 +29,1 @@\n-import javafx.scene.layout.Background;\n-import javafx.scene.layout.BackgroundFill;\n-import javafx.scene.layout.CornerRadii;\n-import javafx.scene.layout.Pane;\n+import javafx.scene.layout.StackPane;\n@@ -39,3 +33,2 @@\n-import javafx.util.Duration;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n@@ -43,0 +36,1 @@\n+import test.util.Util;\n@@ -44,3 +38,2 @@\n-import java.util.Map;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n@@ -48,4 +41,1 @@\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static test.util.Util.TIMEOUT;\n-\n-public class StageMixedSizeTest extends VisualTestBase {\n+class StageMixedSizeTest extends VisualTestBase {\n@@ -54,0 +44,1 @@\n+    private static final int WAIT = 300;\n@@ -56,3 +47,3 @@\n-    @Test\n-    public void testSetWidthOnlyAfterShownOnContentSizeWindow() throws Exception {\n-        CountDownLatch latch = new CountDownLatch(1);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    void testSetWidthOnlyAfterShownOnContentSizeWindow(StageStyle stageStyle) {\n@@ -62,9 +53,6 @@\n-        setupContentSizeTestStage(initialContentSize, initialContentSize,\n-                () -> doTimeLine(Map.of(500L, () -> testStage.setWidth(finalWidth),\n-                                        1000L, latch::countDown)));\n-\n-        assertTrue(latch.await(TIMEOUT, TimeUnit.MILLISECONDS), \"Timeout waiting for test stage to be shown\");\n-\n-        runAndWait(() -> assertColorDoesNotEqual(BACKGROUND_COLOR,\n-                getColor(initialContentSize - 10, initialContentSize \/ 2), TOLERANCE));\n-        Assertions.assertEquals(finalWidth, testStage.getWidth(), \"Window width should be \" + finalWidth);\n+        Util.doTimeLine(WAIT,\n+                () -> setupContentSizeTestStage(stageStyle, initialContentSize, initialContentSize),\n+                () -> testStage.setWidth(finalWidth),\n+                () -> assertColorDoesNotEqual(BACKGROUND_COLOR,\n+                        getColor(initialContentSize - 10, initialContentSize \/ 2), TOLERANCE),\n+                () -> assertEquals(finalWidth, testStage.getWidth(), \"Window width should be \" + finalWidth));\n@@ -73,3 +61,3 @@\n-    @Test\n-    public void testSetHeightOnlyAfterShownOnContentSizeWindow() throws Exception {\n-        CountDownLatch latch = new CountDownLatch(1);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    void testSetHeightOnlyAfterShownOnContentSizeWindow(StageStyle stageStyle) {\n@@ -79,25 +67,6 @@\n-        setupContentSizeTestStage(initialContentSize, initialContentSize,\n-                () -> doTimeLine(Map.of(500L, () -> testStage.setHeight(finalHeight),\n-                                        1000L, latch::countDown)));\n-\n-        assertTrue(latch.await(TIMEOUT, TimeUnit.MILLISECONDS), \"Timeout waiting for test stage to be shown\");\n-\n-        runAndWait(() -> assertColorDoesNotEqual(BACKGROUND_COLOR,\n-                getColor(initialContentSize \/ 2, initialContentSize - 10), TOLERANCE));\n-        Assertions.assertEquals(finalHeight, testStage.getHeight(), \"Window height should be \" + finalHeight);\n-    }\n-\n-    private void setupContentSizeTestStage(int width, int height, Runnable onShown) {\n-        runAndWait(() -> {\n-            testStage = getStage(true);\n-            testStage.initStyle(StageStyle.TRANSPARENT);\n-            Pane pane = new Pane();\n-            pane.setPrefSize(width, height);\n-            pane.setBackground(new Background(new BackgroundFill(BACKGROUND_COLOR, CornerRadii.EMPTY, Insets.EMPTY)));\n-            Scene scene = new Scene(pane);\n-            testStage.setScene(scene);\n-            testStage.setX(0);\n-            testStage.setY(0);\n-            testStage.setOnShown(e -> onShown.run());\n-            testStage.show();\n-        });\n+        Util.doTimeLine(WAIT,\n+                () -> setupContentSizeTestStage(stageStyle, initialContentSize, initialContentSize),\n+                () -> testStage.setHeight(finalHeight),\n+                () -> assertColorDoesNotEqual(BACKGROUND_COLOR,\n+                        getColor(initialContentSize \/ 2, initialContentSize - 10), TOLERANCE),\n+                () -> assertEquals(finalHeight, testStage.getHeight(), \"Window height should be \" + finalHeight));\n@@ -106,6 +75,8 @@\n-    private void doTimeLine(Map<Long, Runnable> keyFrames) {\n-        Timeline timeline = new Timeline();\n-        timeline.setCycleCount(1);\n-        keyFrames.forEach((duration, runnable) ->\n-                timeline.getKeyFrames().add(new KeyFrame(Duration.millis(duration), e -> runnable.run())));\n-        timeline.play();\n+    private void setupContentSizeTestStage(StageStyle stageStyle, int width, int height) {\n+        testStage = getStage(true);\n+        testStage.initStyle(stageStyle);\n+        Scene scene = new Scene(new StackPane(), width, height, BACKGROUND_COLOR);\n+        testStage.setScene(scene);\n+        testStage.setX(0);\n+        testStage.setY(0);\n+        testStage.show();\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageMixedSizeTest.java","additions":35,"deletions":64,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n@@ -40,0 +42,1 @@\n+import java.util.concurrent.ExecutionException;\n@@ -41,0 +44,4 @@\n+import java.util.concurrent.TimeoutException;\n+\n+import javafx.animation.KeyFrame;\n+import javafx.animation.Timeline;\n@@ -50,0 +57,1 @@\n+import javafx.stage.Stage;\n@@ -51,0 +59,1 @@\n+import javafx.util.Duration;\n@@ -58,0 +67,2 @@\n+    public static final String PARAMETERIZED_TEST_DISPLAY = \"{displayName} [{index}] {arguments}\";\n+\n@@ -456,0 +467,90 @@\n+\n+    \/**\n+     * Creates a {@link Timeline} where each {@link KeyFrame} runs a {@link Runnable}.\n+     * Each {@link Runnable} will be scheduled at an increment of {@code msToIncrement} milliseconds.\n+     *\n+     * @param msToIncrement the number of milliseconds to increment between each {@link KeyFrame}\n+     * @param runnables     the list of {@link Runnable} instances to execute sequentially\n+     *\/\n+    public static void doTimeLine(int msToIncrement, Runnable... runnables) {\n+        long millis = msToIncrement;\n+\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+\n+        Timeline timeline = new Timeline();\n+        timeline.setCycleCount(1);\n+        for (Runnable runnable : runnables) {\n+            timeline.getKeyFrames().add(new KeyFrame(Duration.millis(millis), e -> {\n+                try {\n+                    runnable.run();\n+                } catch (Throwable ex) {\n+                    future.completeExceptionally(ex);\n+                }\n+            }));\n+            millis += msToIncrement;\n+        }\n+        timeline.setOnFinished(e -> future.complete(null));\n+        timeline.play();\n+\n+        final long waitms = millis + 5000;\n+\n+        try {\n+            future.get(waitms, TimeUnit.MILLISECONDS);\n+        } catch (ExecutionException | InterruptedException | TimeoutException ex) {\n+            throwError(ex);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a {@link Timeline} where each {@link KeyFrame} executes a {@link Runnable}.\n+     *\n+     * @param runnables a {@link Map} where the key is the {@link Duration} at which to trigger the action,\n+     *                  and the value is the {@link Runnable} to execute at that time\n+     *\/\n+    public static void doTimeLine(Map<Duration, Runnable> runnables) {\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+\n+        Timeline timeline = new Timeline();\n+        timeline.setCycleCount(1);\n+        Duration totalDuration = Duration.seconds(5);\n+\n+        for (Map.Entry<Duration, Runnable> entry : runnables.entrySet()) {\n+            Duration duration = entry.getKey();\n+            Runnable runnable = entry.getValue();\n+            totalDuration = totalDuration.add(duration);\n+            timeline.getKeyFrames().add(new KeyFrame(duration, e -> {\n+                try {\n+                    runnable.run();\n+                } catch (Throwable ex) {\n+                    future.completeExceptionally(ex);\n+                }\n+            }));\n+        }\n+\n+        timeline.setOnFinished(e -> future.complete(null));\n+        timeline.play();\n+\n+        long waitms = (long) totalDuration.toMillis();\n+        try {\n+            future.get(waitms, TimeUnit.MILLISECONDS);\n+        } catch (ExecutionException | InterruptedException | TimeoutException ex) {\n+            throwError(ex);\n+        }\n+    }\n+\n+    \/**\n+     * Finds the {@link Screen} where the top-left corner of the given {@link Stage} is located.\n+     *\n+     * @param stage the {@link Stage} to check\n+     * @return the {@link Screen} containing the stage's top-left corner or {@link Screen#getPrimary()}\n+     *\/\n+    public static Screen getScreen(Stage stage) {\n+        for (Screen screen : Screen.getScreens()) {\n+            Rectangle2D bounds = screen.getVisualBounds();\n+            if (bounds.contains(stage.getX(), stage.getY())) {\n+                return screen;\n+            }\n+        }\n+\n+        return Screen.getPrimary();\n+    }\n","filename":"tests\/system\/src\/test\/java\/test\/util\/Util.java","additions":102,"deletions":1,"binary":false,"changes":103,"status":"modified"}]}