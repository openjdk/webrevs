{"files":[{"patch":"@@ -133,2 +133,6 @@\n-        notifyStateChanged(WindowEvent.MINIMIZE);\n-        return minimize;\n+\n+        if (!isVisible()) {\n+            notifyStateChanged(WindowEvent.MINIMIZE);\n+        }\n+\n+        return isMinimized();\n@@ -141,2 +145,1 @@\n-        notifyStateChanged(WindowEvent.MAXIMIZE);\n-        return maximize;\n+        return isMaximized();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkWindow.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -491,2 +491,0 @@\n-                    \/\/ let gtk handle it first to prevent a glitch\n-                    gtk_main_do_event(event);\n@@ -494,0 +492,1 @@\n+                    gtk_main_do_event(event);\n@@ -496,1 +495,1 @@\n-                    ctx->process_configure(&event->configure);\n+                    \/\/ Let gtk handle it first, so state values are updated\n@@ -498,0 +497,1 @@\n+                    ctx->process_configure(&event->configure);\n@@ -515,1 +515,1 @@\n-                    ctx->process_state(&event->window_state);\n+                    \/\/ Let gtk handle it first, so state values are updated\n@@ -517,0 +517,1 @@\n+                    ctx->process_state(&event->window_state);\n@@ -545,1 +546,2 @@\n-                    \/\/ fall-through\n+                    ctx->process_map();\n+                    break;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassApplication.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-static GtkWindow *gdk_window_handle_to_gtk(jlong handle) {\n+static GdkWindow *get_gdk_window(jlong handle) {\n@@ -70,1 +70,1 @@\n-                ? ((WindowContext*)JLONG_TO_PTR(handle))->get_gtk_window()\n+                ? ((WindowContext*)JLONG_TO_PTR(handle))->get_gdk_window()\n@@ -74,0 +74,9 @@\n+static void on_dialog_realize_set_parent(GtkWidget *dialog, gpointer user_data) {\n+    GdkWindow *parent_gdk_window = (GdkWindow *) user_data;\n+    GdkWindow *dialog_gdk_window = gtk_widget_get_window(dialog);\n+\n+    if (dialog_gdk_window && parent_gdk_window) {\n+        gdk_window_set_transient_for(dialog_gdk_window, parent_gdk_window);\n+    }\n+}\n+\n@@ -115,1 +124,1 @@\n-    GtkWidget* chooser = gtk_file_chooser_dialog_new(chooser_title, gdk_window_handle_to_gtk(parent),\n+    GtkWidget* chooser = gtk_file_chooser_dialog_new(chooser_title, NULL,\n@@ -123,0 +132,2 @@\n+    g_signal_connect(chooser, \"realize\", G_CALLBACK(on_dialog_realize_set_parent), get_gdk_window(parent));\n+\n@@ -211,1 +222,1 @@\n-            gdk_window_handle_to_gtk(parent),\n+            NULL,\n@@ -219,0 +230,2 @@\n+    g_signal_connect(chooser, \"realize\", G_CALLBACK(on_dialog_realize_set_parent), get_gdk_window(parent));\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassCommonDialogs.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-    tmp = glass_pixbuf_from_window(root_window, x, y, width, height);\n+    tmp = gdk_pixbuf_get_from_window(root_window, x, y, width, height);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassRobot.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-        return view->current_window->get_geometry().view_x;\n+        return view->current_window->get_view_position().x;\n@@ -123,1 +123,1 @@\n-        return view->current_window->get_geometry().view_y;\n+        return view->current_window->get_view_position().y;\n@@ -272,0 +272,1 @@\n+\n@@ -278,2 +279,2 @@\n-  (JNIEnv * env, jobject obj, jlong ptr, jboolean animate, jboolean keepRation, jboolean hideCursor)\n-{\n+    (JNIEnv * env, jobject obj, jlong ptr, jboolean animate, jboolean keepRation, jboolean hideCursor) {\n+\n@@ -287,2 +288,0 @@\n-        env->CallVoidMethod(obj, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER);\n-        CHECK_JNI_EXCEPTION_RET(env, JNI_FALSE)\n@@ -290,0 +289,1 @@\n+\n@@ -310,2 +310,0 @@\n-        env->CallVoidMethod(obj, jViewNotifyView, com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT);\n-        CHECK_JNI_EXCEPTION(env)\n@@ -313,1 +311,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassView.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -90,7 +90,7 @@\n-    WindowContext* ctx = new WindowContextTop(obj,\n-            parent,\n-            screen,\n-            glass_mask_to_window_frame_type(mask),\n-            glass_mask_to_window_type(mask),\n-            glass_mask_to_wm_function(mask)\n-            );\n+    WindowType type = glass_mask_to_window_type(mask);\n+    WindowFrameType frameType = glass_mask_to_window_frame_type(mask);\n+    GdkWMFunction wmFunctions = glass_mask_to_wm_function(mask);\n+\n+    WindowContext* ctx = (frameType == EXTENDED)\n+        ? new WindowContextExtended(obj, parent, screen, wmFunctions)\n+        : new WindowContext(obj, parent, screen, frameType, type, wmFunctions);\n@@ -411,2 +411,0 @@\n-    if (w == -1) w = G_MAXSHORT;\n-    if (h == -1) h = G_MAXSHORT;\n@@ -538,7 +536,1 @@\n-    GdkWindow *win = ctx->get_gdk_window();\n-\n-    if (win == NULL) {\n-        return 0;\n-    }\n-\n-    return GDK_WINDOW_XID(win);\n+    return ctx->get_native_window();\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/GlassWindow.cpp","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include <X11\/Xlib.h>\n@@ -576,1 +577,0 @@\n-static void configure_opaque_window(GtkWidget *window);\n@@ -584,10 +584,0 @@\n-GdkScreen * glass_gdk_window_get_screen(GdkWindow * gdkWindow)\n-{\n-#ifdef GLASS_GTK3\n-        GdkVisual * gdkVisual = gdk_window_get_visual(gdkWindow);\n-        return gdk_visual_get_screen(gdkVisual);\n-#else\n-        return gdk_window_get_screen(gdkWindow);\n-#endif\n-}\n-\n@@ -627,1 +617,0 @@\n-#ifdef GLASS_GTK3\n@@ -631,3 +620,0 @@\n-#else\n-        gdk_display_get_pointer(gdk_display_get_default(), NULL, x, y, NULL);\n-#endif\n@@ -638,6 +624,1 @@\n-#ifdef GLASS_GTK3\n-        return gdk_display_device_is_grabbed(gdk_display_get_default(), device);\n-#else\n-        (void) device;\n-        return gdk_display_pointer_is_grabbed(gdk_display_get_default());\n-#endif\n+    return gdk_display_device_is_grabbed(gdk_display_get_default(), device);\n@@ -648,6 +629,1 @@\n-#ifdef GLASS_GTK3\n-        gdk_device_ungrab(device, GDK_CURRENT_TIME);\n-#else\n-        (void) device;\n-        gdk_pointer_ungrab(GDK_CURRENT_TIME);\n-#endif\n+    gdk_device_ungrab(device, GDK_CURRENT_TIME);\n@@ -659,18 +635,1 @@\n-#ifdef GLASS_GTK3\n-        return gdk_device_get_window_at_position(device, x, y);\n-#else\n-        (void) device;\n-        return gdk_display_get_window_at_pointer(gdk_display_get_default(), x, y);\n-#endif\n-}\n-\n-void\n-glass_gtk_configure_transparency_and_realize(GtkWidget *window,\n-                                             gboolean transparent) {\n-        gboolean isTransparent = glass_configure_window_transparency(window, transparent);\n-        gtk_widget_realize(window);\n-}\n-\n-void\n-glass_gtk_window_configure_from_visual(GtkWidget *widget, GdkVisual *visual) {\n-    glass_widget_set_visual(widget, visual);\n+    return gdk_device_get_window_at_position(device, x, y);\n@@ -684,17 +643,7 @@\n-#ifdef GLASS_GTK3\n-        GdkVisual *visual = gdk_screen_get_rgba_visual(default_screen);\n-        if (visual\n-                && gdk_display_supports_composite(default_display)\n-                && gdk_screen_is_composited(default_screen)) {\n-            glass_widget_set_visual(window, visual);\n-            return TRUE;\n-        }\n-#else\n-        GdkColormap *colormap = gdk_screen_get_rgba_colormap(default_screen);\n-        if (colormap\n-                && gdk_display_supports_composite(default_display)\n-                && gdk_screen_is_composited(default_screen)) {\n-            gtk_widget_set_colormap(window, colormap);\n-            return TRUE;\n-        }\n-#endif\n+    GdkVisual *visual = gdk_screen_get_rgba_visual(default_screen);\n+    if (visual\n+            && gdk_display_supports_composite(default_display)\n+            && gdk_screen_is_composited(default_screen)) {\n+        glass_widget_set_visual(window, visual);\n+        return TRUE;\n+    }\n@@ -705,6 +654,0 @@\n-void\n-glass_gdk_window_get_size(GdkWindow *window, gint *w, gint *h) {\n-    *w = gdk_window_get_width(window);\n-    *h = gdk_window_get_height(window);\n-}\n-\n@@ -713,7 +656,3 @@\n-#ifdef GLASS_GTK3\n-        gdk_device_get_position(\n-            gdk_device_manager_get_client_pointer(\n-                gdk_display_get_device_manager(display)), NULL , x, y);\n-#else\n-        gdk_display_get_pointer(display, NULL, x, y, NULL);\n-#endif\n+    gdk_device_get_position(\n+        gdk_device_manager_get_client_pointer(\n+            gdk_display_get_device_manager(display)), NULL , x, y);\n@@ -735,13 +674,0 @@\n-static void\n-configure_opaque_window(GtkWidget *window) {\n-    (void) window;\n-\/* We need to pick a visual that really is glx compatible\n- * instead of using the default visual\n- *\/\n- \/* see: JDK-8087516 for why this is commented out\n-    glass_widget_set_visual(window,\n-                          gdk_screen_get_system_visual(\n-                              gdk_screen_get_default()));\n-  *\/\n-}\n-\n@@ -755,3 +681,1 @@\n-        fprintf(stderr,\"Can't create transparent stage, because your screen doesn't\"\n-               \" support alpha channel.\"\n-               \" You need to enable XComposite extension.\\n\");\n+        fprintf(stderr, ALPHA_CHANNEL_ERROR_MSG);\n@@ -761,1 +685,0 @@\n-    configure_opaque_window(window);\n@@ -772,10 +695,1 @@\n-#ifdef GLASS_GTK3\n-        ret = gdk_pixbuf_get_from_window (window, srcx, srcy, width, height);\n-#else\n-        ret = gdk_pixbuf_get_from_drawable (NULL,\n-            window,\n-            NULL,\n-            srcx, srcy,\n-            0, 0,\n-            width, height);\n-#endif\n+    gdk_pixbuf_get_from_window (window, srcx, srcy, width, height);\n@@ -785,37 +699,0 @@\n-void\n-glass_window_apply_shape_mask(GdkWindow *window,\n-    void* data, uint width, uint height)\n-{\n-#ifdef GLASS_GTK3\n-    (void) window;\n-    (void) data;\n-    (void) width;\n-    (void) height;\n-#else\n-        GdkPixbuf* pixbuf = gdk_pixbuf_new_from_data((guchar *) data,\n-                GDK_COLORSPACE_RGB, TRUE, 8, width, height, width * 4, NULL, NULL);\n-\n-        if (GDK_IS_PIXBUF(pixbuf)) {\n-            GdkBitmap* mask = NULL;\n-            gdk_pixbuf_render_pixmap_and_mask(pixbuf, NULL, &mask, 128);\n-\n-            gdk_window_input_shape_combine_mask(window, mask, 0, 0);\n-\n-            g_object_unref(pixbuf);\n-            if (mask) {\n-                g_object_unref(mask);\n-            }\n-        }\n-#endif\n-}\n-\n-void\n-glass_window_reset_input_shape_mask(GdkWindow *window)\n-{\n-#ifdef GLASS_GTK3\n-        gdk_window_input_shape_combine_region(window, NULL, 0, 0);\n-#else\n-        gdk_window_input_shape_combine_mask(window, NULL, 0, 0);\n-#endif\n-}\n-\n@@ -832,1 +709,0 @@\n-#ifdef GLASS_GTK3\n@@ -837,4 +713,0 @@\n-#else\n-    (void) display;\n-    (void) scale;\n-#endif\n@@ -848,1 +720,0 @@\n-#ifdef GLASS_GTK3\n@@ -850,4 +721,0 @@\n-#else\n-        GdkColormap *colormap = gdk_colormap_new(visual, TRUE);\n-        gtk_widget_set_colormap (widget, colormap);\n-#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.cpp","additions":16,"deletions":149,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include <X11\/Xlib.h>\n@@ -33,1 +32,0 @@\n-#include <gdk\/gdkx.h>\n@@ -35,1 +33,0 @@\n-\n@@ -47,0 +44,4 @@\n+#define ALPHA_CHANNEL_ERROR_MSG \\\n+    \"Can't create transparent stage, because your screen doesn't support alpha channel. \" \\\n+    \"You need to enable XComposite extension.\\n\"\n+\n@@ -239,0 +240,1 @@\n+#define LOG(msg, ...) { printf(msg, ##__VA_ARGS__); fflush(stdout); }\n@@ -254,0 +256,1 @@\n+#define LOG(msg, ...)\n@@ -272,6 +275,6 @@\n-    gchar* get_application_name();\n-    void glass_throw_exception(JNIEnv * env,\n-            const char * exceptionClass,\n-            const char * exceptionMessage);\n-    int glass_throw_oom(JNIEnv * env, const char * exceptionMessage);\n-    void dump_jstring_array(JNIEnv*, jobjectArray);\n+gchar* get_application_name();\n+void glass_throw_exception(JNIEnv * env,\n+        const char * exceptionClass,\n+        const char * exceptionMessage);\n+int glass_throw_oom(JNIEnv * env, const char * exceptionMessage);\n+void dump_jstring_array(JNIEnv*, jobjectArray);\n@@ -279,1 +282,1 @@\n-    guint8* convert_BGRA_to_RGBA(const int* pixels, int stride, int height);\n+guint8* convert_BGRA_to_RGBA(const int* pixels, int stride, int height);\n@@ -281,1 +284,1 @@\n-    gboolean check_and_clear_exception(JNIEnv *env);\n+gboolean check_and_clear_exception(JNIEnv *env);\n@@ -283,1 +286,1 @@\n-    jboolean is_display_valid();\n+jboolean is_display_valid();\n@@ -285,1 +288,1 @@\n-    gsize get_files_count(gchar **uris);\n+gsize get_files_count(gchar **uris);\n@@ -287,1 +290,1 @@\n-    jobject uris_to_java(JNIEnv *env, gchar **uris, gboolean files);\n+jobject uris_to_java(JNIEnv *env, gchar **uris, gboolean files);\n@@ -302,3 +305,0 @@\n-GdkScreen *\n-glass_gdk_window_get_screen(GdkWindow * gdkWindow);\n-\n@@ -314,6 +314,0 @@\n-void\n-glass_gdk_master_pointer_grab(GdkEvent *event, GdkWindow *window, GdkCursor *cursor);\n-\n-void\n-glass_gdk_master_pointer_ungrab(GdkEvent *event);\n-\n@@ -333,3 +327,0 @@\n-void\n-glass_gtk_configure_transparency_and_realize(GtkWidget *window,\n-                                                  gboolean transparent);\n@@ -342,6 +333,0 @@\n-void\n-glass_gtk_window_configure_from_visual(GtkWidget *widget, GdkVisual *visual);\n-\n-void\n-glass_gdk_window_get_size(GdkWindow *window, gint *w, gint *h);\n-\n@@ -366,3 +351,0 @@\n-void\n-glass_window_reset_input_shape_mask(GdkWindow *window);\n-\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_general.h","additions":17,"deletions":35,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include <X11\/Xlib.h>\n@@ -33,0 +34,1 @@\n+#include <gdk\/gdkx.h>\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_key.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"glass_evloop.h\"\n@@ -35,1 +36,0 @@\n-\n@@ -38,1 +38,0 @@\n-#include <X11\/extensions\/shape.h>\n@@ -40,2 +39,0 @@\n-#include <cairo-xlib.h>\n-#include <gdk\/gdkx.h>\n@@ -43,3 +40,1 @@\n-#ifdef GLASS_GTK3\n-#include <gtk\/gtkx.h>\n-#endif\n+#include <gdk\/gdkx.h>\n@@ -48,1 +43,0 @@\n-\n@@ -50,0 +44,1 @@\n+#include <optional>\n@@ -57,2 +52,0 @@\n-WindowContext * WindowContextBase::sm_grab_window = NULL;\n-WindowContext * WindowContextBase::sm_mouse_drag_window = NULL;\n@@ -60,2 +53,12 @@\n-GdkWindow* WindowContextBase::get_gdk_window(){\n-    return gdk_window;\n+void destroy_and_delete_ctx(WindowContext* ctx) {\n+    LOG(\"destroy_and_delete_ctx\\n\");\n+    if (ctx) {\n+        ctx->process_destroy();\n+\n+        if (!ctx->get_events_count()) {\n+            LOG(\"delete ctx\\n\");\n+            delete ctx;\n+        }\n+        \/\/ else: ctx will be deleted in EventsCounterHelper after completing\n+        \/\/ an event processing\n+    }\n@@ -64,2 +67,13 @@\n-jobject WindowContextBase::get_jview() {\n-    return jview;\n+static bool gdk_visual_is_rgba(GdkVisual *visual) {\n+    if (!visual) return false;\n+\n+    int depth = gdk_visual_get_depth(visual);\n+    guint32 red_mask, green_mask, blue_mask;\n+    gdk_visual_get_red_pixel_details(visual, &red_mask, nullptr, nullptr);\n+    gdk_visual_get_green_pixel_details(visual, &green_mask, nullptr, nullptr);\n+    gdk_visual_get_blue_pixel_details(visual, &blue_mask, nullptr, nullptr);\n+\n+    return (depth == 32\n+            && red_mask == 0xff0000\n+            && green_mask == 0x00ff00\n+            && blue_mask == 0x0000ff);\n@@ -68,2 +82,3 @@\n-jobject WindowContextBase::get_jwindow() {\n-    return jwindow;\n+\/\/ Iconified not considered here\n+static bool is_state_floating(GdkWindowState state) {\n+    return (state & (GDK_WINDOW_STATE_MAXIMIZED | GDK_WINDOW_STATE_FULLSCREEN)) == 0;\n@@ -72,7 +87,15 @@\n-bool WindowContextBase::isEnabled() {\n-    if (jwindow) {\n-        bool result = (JNI_TRUE == mainEnv->CallBooleanMethod(jwindow, jWindowIsEnabled));\n-        LOG_EXCEPTION(mainEnv)\n-        return result;\n-    } else {\n-        return false;\n+static inline jint gdk_button_number_to_mouse_button(guint button) {\n+    switch (button) {\n+        case 1:\n+            return com_sun_glass_events_MouseEvent_BUTTON_LEFT;\n+        case 2:\n+            return com_sun_glass_events_MouseEvent_BUTTON_OTHER;\n+        case 3:\n+            return com_sun_glass_events_MouseEvent_BUTTON_RIGHT;\n+        case MOUSE_BACK_BTN:\n+            return com_sun_glass_events_MouseEvent_BUTTON_BACK;\n+        case MOUSE_FORWARD_BTN:\n+            return com_sun_glass_events_MouseEvent_BUTTON_FORWARD;\n+        default:\n+            \/\/ Other buttons are not supported by quantum and are not reported by other platforms\n+            return com_sun_glass_events_MouseEvent_BUTTON_NONE;\n@@ -82,5 +105,2 @@\n-void WindowContextBase::notify_state(jint glass_state) {\n-    if (glass_state == com_sun_glass_events_WindowEvent_RESTORE) {\n-        if (is_maximized) {\n-            glass_state = com_sun_glass_events_WindowEvent_MAXIMIZE;\n-        }\n+WindowContext * WindowContext::sm_grab_window = nullptr;\n+WindowContext * WindowContext::sm_mouse_drag_window = nullptr;\n@@ -88,8 +108,18 @@\n-        int w, h;\n-        glass_gdk_window_get_size(gdk_window, &w, &h);\n-        if (jview) {\n-            mainEnv->CallVoidMethod(jview,\n-                    jViewNotifyRepaint,\n-                    0, 0, w, h);\n-            CHECK_JNI_EXCEPTION(mainEnv);\n-        }\n+\/\/ Work-around because frame extents are only obtained after window is shown.\n+\/\/ This is used to know the total window size (content + decoration)\n+\/\/ The first window will have a duplicated resize event, subsequent windows will use the cached value.\n+std::optional<Rectangle> WindowContext::normal_extents;\n+std::optional<Rectangle> WindowContext::utility_extents;\n+\n+WindowContext::WindowContext(jobject _jwindow, WindowContext* _owner, long _screen,\n+        WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :\n+            owner(_owner),\n+            screen(_screen),\n+            frame_type(_frame_type),\n+            window_type(type),\n+            initial_wmf(wmf),\n+            current_wmf(wmf) {\n+    jwindow = mainEnv->NewGlobalRef(_jwindow);\n+\n+    if (frame_type != TITLED) {\n+        initial_wmf = GDK_FUNC_ALL;\n@@ -98,5 +128,18 @@\n-    if (jwindow) {\n-       mainEnv->CallVoidMethod(jwindow,\n-               jGtkWindowNotifyStateChanged,\n-               glass_state);\n-       CHECK_JNI_EXCEPTION(mainEnv);\n+    int attr_mask = GDK_WA_VISUAL;\n+    GdkWindowAttr attributes;\n+    attributes.visual = find_best_visual();\n+    attributes.wclass = GDK_INPUT_OUTPUT;\n+    attributes.event_mask = GDK_FILTERED_EVENTS_MASK;\n+    attributes.width = DEFAULT_WIDTH;\n+    attributes.height = DEFAULT_HEIGHT;\n+    attributes.window_type = (window_type == POPUP) ? GDK_WINDOW_TEMP : GDK_WINDOW_TOPLEVEL;\n+\n+    if (gchar* app_name = get_application_name()) {\n+        attributes.wmclass_name = app_name;\n+        attributes.wmclass_class = app_name;\n+        attr_mask |= GDK_WA_WMCLASS;\n+    }\n+\n+    if (window_type == UTILITY && frame_type != EXTENDED) {\n+        attributes.type_hint = GDK_WINDOW_TYPE_HINT_UTILITY;\n+        attr_mask |=  GDK_WA_TYPE_HINT;\n@@ -104,1 +147,0 @@\n-}\n@@ -106,2 +148,1 @@\n-void WindowContextBase::process_state(GdkEventWindowState* event) {\n-    if (event->changed_mask & (GDK_WINDOW_STATE_ICONIFIED | GDK_WINDOW_STATE_MAXIMIZED)) {\n+    gdk_window = gdk_window_new(gdk_get_default_root_window(), &attributes, attr_mask);\n@@ -109,3 +150,3 @@\n-        if (event->changed_mask & GDK_WINDOW_STATE_ICONIFIED) {\n-            is_iconified = event->new_window_state & GDK_WINDOW_STATE_ICONIFIED;\n-        }\n+    if (frame_type == TITLED) {\n+        request_frame_extents();\n+    }\n@@ -113,2 +154,20 @@\n-        if (event->changed_mask & GDK_WINDOW_STATE_MAXIMIZED) {\n-            is_maximized = event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED;\n+    if (frame_type != TRANSPARENT) {\n+        GdkRGBA white = { 1.0, 1.0, 1.0, 1.0 };\n+        gdk_window_set_background_rgba(gdk_window, &white);\n+    }\n+\n+    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, nullptr);\n+    gdk_window_register_dnd(gdk_window);\n+\n+    if (initial_wmf) {\n+        gdk_window_set_functions(gdk_window, initial_wmf);\n+    }\n+\n+    if (frame_type != TITLED) {\n+        gdk_window_set_decorations(gdk_window,  (GdkWMDecoration) 0);\n+    }\n+\n+    if (owner) {\n+        owner->add_child(this);\n+        if (on_top_inherited()) {\n+            gdk_window_set_keep_above(gdk_window, true);\n@@ -116,0 +175,41 @@\n+    }\n+\n+    set_title(\"\");\n+    update_window_constraints();\n+\n+    window_location.setOnChange([this](const Point& point) {\n+        notify_window_move();\n+    });\n+\n+    view_position.setOnChange([this](const Point& point) {\n+        LOG(\"view_position: %d, %d\\n\", point.x, point.y);\n+        notify_view_move();\n+    });\n+\n+    window_size.setOnChange([this](const Size& size) {\n+        notify_window_resize(is_maximized()\n+                                ? com_sun_glass_events_WindowEvent_MAXIMIZE\n+                                : com_sun_glass_events_WindowEvent_RESIZE);\n+    });\n+\n+    view_size.setOnChange([this](const Size& size) {\n+        notify_view_resize();\n+        update_window_constraints();\n+    });\n+\n+    window_extents.setOnChange([this](const Rectangle& rect) {\n+        update_window_constraints();\n+        update_window_size();\n+    });\n+\n+    resizable.setOnChange([this](const bool& resizable) {\n+        update_window_constraints();\n+    });\n+\n+    minimum_size.setOnChange([this](const Size& size) {\n+        update_window_constraints();\n+    });\n+\n+    sys_min_size.setOnChange([this](const Size& size) {\n+        update_window_constraints();\n+    });\n@@ -117,1 +217,13 @@\n-        jint stateChangeEvent;\n+    maximum_size.setOnChange([this](const Size& size) {\n+        update_window_constraints();\n+    });\n+\n+    load_cached_extents();\n+}\n+\n+GdkVisual* WindowContext::find_best_visual() {\n+    \/\/ This comes from prism-es2\n+    static glong xvisualID = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);\n+    static GdkVisual *prismVisual = (xvisualID != 0)\n+                ? gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID)\n+                : nullptr;\n@@ -119,4 +231,4 @@\n-        if (is_iconified) {\n-            stateChangeEvent = com_sun_glass_events_WindowEvent_MINIMIZE;\n-        } else if (is_maximized) {\n-            stateChangeEvent = com_sun_glass_events_WindowEvent_MAXIMIZE;\n+    if (frame_type == TRANSPARENT && !gdk_visual_is_rgba(prismVisual)) {\n+        GdkVisual *rgbaVisual = gdk_screen_get_rgba_visual(gdk_screen_get_default());\n+        if (rgbaVisual) {\n+            return rgbaVisual;\n@@ -124,7 +236,2 @@\n-            stateChangeEvent = com_sun_glass_events_WindowEvent_RESTORE;\n-            if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0\n-                || (gdk_windowManagerFunctions & GDK_FUNC_MAXIMIZE) == 0) {\n-                \/\/ in this case - the window manager will not support the programatic\n-                \/\/ request to iconify \/ maximize - so we need to restore it now.\n-                gdk_window_set_functions(gdk_window, gdk_windowManagerFunctions);\n-            }\n+            fprintf(stderr, ALPHA_CHANNEL_ERROR_MSG);\n+            fflush(stderr);\n@@ -132,0 +239,1 @@\n+    }\n@@ -133,3 +241,54 @@\n-        notify_state(stateChangeEvent);\n-    } else if (event->changed_mask & GDK_WINDOW_STATE_ABOVE) {\n-        notify_on_top(event->new_window_state & GDK_WINDOW_STATE_ABOVE);\n+    if (prismVisual != nullptr) {\n+        LOG(\"Using prism visual\\n\");\n+        return prismVisual;\n+    }\n+\n+    LOG(\"Using GDK system visual\\n\");\n+    return gdk_screen_get_system_visual(gdk_screen_get_default());\n+}\n+\n+GdkWindow* WindowContext::get_gdk_window() {\n+    if (GDK_IS_WINDOW(gdk_window)) {\n+        return gdk_window;\n+    }\n+\n+    return nullptr;\n+}\n+\n+\/\/ Returns de XWindow ID to be used in rendering\n+XID WindowContext::get_native_window() {\n+    \/\/ This is used to delay the window map (it's only really mapped when there's\n+    \/\/ something rendered)\n+    if (!is_visible()) return 0;\n+\n+    return GDK_WINDOW_XID(gdk_window);\n+}\n+\n+bool WindowContext::isEnabled() {\n+    if (jwindow) {\n+        bool result = (JNI_TRUE == mainEnv->CallBooleanMethod(jwindow, jWindowIsEnabled));\n+        LOG_EXCEPTION(mainEnv)\n+        return result;\n+    } else {\n+        return false;\n+    }\n+}\n+\n+void WindowContext::process_expose(GdkEventExpose* event) {\n+    GdkRectangle r = event->area;\n+    notify_repaint({ r.x, r.y, r.width, r.height });\n+}\n+\n+void WindowContext::process_map() {\n+    \/\/ We need only first map\n+    if (mapped || window_type == POPUP) return;\n+\n+    LOG(\"--------------------------------------------------------> mapped\\n\");\n+    Point loc = window_location.get();\n+    Size size = view_size.get();\n+\n+    move_resize(loc.x, loc.y, true, true, size.width, size.height);\n+    mapped = true;\n+\n+    if (initial_state_mask != 0) {\n+        update_initial_state();\n@@ -139,2 +298,3 @@\n-void WindowContextBase::process_focus(GdkEventFocus* event) {\n-    if (!event->in && WindowContextBase::sm_grab_window == this) {\n+void WindowContext::process_focus(GdkEventFocus *event) {\n+    LOG(\"process_focus (keyboard): %d\\n\", event->in);\n+    if (!event->in && WindowContext::sm_grab_window == this) {\n@@ -153,6 +313,1 @@\n-        if (!event->in || isEnabled()) {\n-            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus,\n-                    event->in ? com_sun_glass_events_WindowEvent_FOCUS_GAINED\n-                              : com_sun_glass_events_WindowEvent_FOCUS_LOST);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        } else {\n+        if (event->in && !isEnabled()) {\n@@ -160,0 +315,1 @@\n+            LOG(\"jWindowNotifyFocusDisabled\");\n@@ -162,0 +318,8 @@\n+        } else {\n+            LOG(\"%s\\n\", (event->in) ? \"com_sun_glass_events_WindowEvent_FOCUS_GAINED\"\n+                                  : \"com_sun_glass_events_WindowEvent_FOCUS_LOST\");\n+\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus,\n+                    event->in ? com_sun_glass_events_WindowEvent_FOCUS_GAINED\n+                             : com_sun_glass_events_WindowEvent_FOCUS_LOST);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n@@ -166,1 +330,1 @@\n-void WindowContextBase::increment_events_counter() {\n+void WindowContext::increment_events_counter() {\n@@ -170,1 +334,1 @@\n-void WindowContextBase::decrement_events_counter() {\n+void WindowContext::decrement_events_counter() {\n@@ -174,1 +338,1 @@\n-size_t WindowContextBase::get_events_count() {\n+size_t WindowContext::get_events_count() {\n@@ -178,1 +342,1 @@\n-bool WindowContextBase::is_dead() {\n+bool WindowContext::is_dead() {\n@@ -182,9 +346,4 @@\n-void destroy_and_delete_ctx(WindowContext* ctx) {\n-    if (ctx) {\n-        ctx->process_destroy();\n-\n-        if (!ctx->get_events_count()) {\n-            delete ctx;\n-        }\n-        \/\/ else: ctx will be deleted in EventsCounterHelper after completing\n-        \/\/ an event processing\n+void WindowContext::process_destroy() {\n+    LOG(\"process_destroy\\n\");\n+    if (owner) {\n+        owner->remove_child(this);\n@@ -192,1 +351,0 @@\n-}\n@@ -194,2 +352,1 @@\n-void WindowContextBase::process_destroy() {\n-    if (WindowContextBase::sm_mouse_drag_window == this) {\n+    if (WindowContext::sm_mouse_drag_window == this) {\n@@ -199,1 +356,1 @@\n-    if (WindowContextBase::sm_grab_window == this) {\n+    if (WindowContext::sm_grab_window == this) {\n@@ -203,1 +360,1 @@\n-    std::set<WindowContextTop*>::iterator it;\n+    std::set<WindowContext*>::iterator it;\n@@ -205,6 +362,1 @@\n-        \/\/ FIX JDK-8226537: this method calls set_owner(NULL) which prevents\n-        \/\/ WindowContextTop::process_destroy() to call remove_child() (because children\n-        \/\/ is being iterated here) but also prevents gtk_window_set_transient_for from\n-        \/\/ being called - this causes the crash on gnome.\n-        gtk_window_set_transient_for((*it)->get_gtk_window(), NULL);\n-        (*it)->set_owner(NULL);\n+        (*it)->set_owner(nullptr);\n@@ -222,1 +374,1 @@\n-        jview = NULL;\n+        jview = nullptr;\n@@ -227,1 +379,1 @@\n-        jwindow = NULL;\n+        jwindow = nullptr;\n@@ -233,1 +385,2 @@\n-void WindowContextBase::process_delete() {\n+void WindowContext::process_delete() {\n+    LOG(\"process_delete\\n\");\n@@ -235,0 +388,1 @@\n+        LOG(\"jWindowNotifyClose\\n\");\n@@ -240,5 +394,3 @@\n-void WindowContextBase::process_expose(GdkEventExpose* event) {\n-    if (jview) {\n-        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, event->area.x, event->area.y, event->area.width, event->area.height);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n-    }\n+void WindowContext::notify_repaint() {\n+    Size size = view_size.get();\n+    notify_repaint({ 0, 0, size.width, size.height });\n@@ -247,15 +399,4 @@\n-static inline jint gtk_button_number_to_mouse_button(guint button) {\n-    switch (button) {\n-        case 1:\n-            return com_sun_glass_events_MouseEvent_BUTTON_LEFT;\n-        case 2:\n-            return com_sun_glass_events_MouseEvent_BUTTON_OTHER;\n-        case 3:\n-            return com_sun_glass_events_MouseEvent_BUTTON_RIGHT;\n-        case MOUSE_BACK_BTN:\n-            return com_sun_glass_events_MouseEvent_BUTTON_BACK;\n-        case MOUSE_FORWARD_BTN:\n-            return com_sun_glass_events_MouseEvent_BUTTON_FORWARD;\n-        default:\n-            \/\/ Other buttons are not supported by quantum and are not reported by other platforms\n-            return com_sun_glass_events_MouseEvent_BUTTON_NONE;\n+void WindowContext::notify_repaint(Rectangle rect) {\n+    if (jview) {\n+        mainEnv->CallVoidMethod(jview, jViewNotifyRepaint, rect.x, rect.y, rect.width, rect.height);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n@@ -265,1 +406,2 @@\n-void WindowContextBase::process_mouse_button(GdkEventButton* event, bool synthesized) {\n+void WindowContext::process_mouse_button(GdkEventButton* event, bool synthesized) {\n+    LOG(\"process_mouse_button\\n\");\n@@ -306,2 +448,2 @@\n-                && (glass_gdk_device_get_window_at_position(device, NULL, NULL)\n-                == NULL)) {\n+                && (glass_gdk_device_get_window_at_position(device, nullptr, nullptr)\n+                == nullptr)) {\n@@ -325,1 +467,1 @@\n-    jint button = gtk_button_number_to_mouse_button(event->button);\n+    jint button = gdk_button_number_to_mouse_button(event->button);\n@@ -348,1 +490,1 @@\n-void WindowContextBase::process_mouse_motion(GdkEventMotion* event) {\n+void WindowContext::process_mouse_motion(GdkEventMotion *event) {\n@@ -358,1 +500,1 @@\n-    if (isDrag && WindowContextBase::sm_mouse_drag_window == NULL) {\n+    if (isDrag && WindowContext::sm_mouse_drag_window == nullptr) {\n@@ -391,1 +533,1 @@\n-void WindowContextBase::process_mouse_scroll(GdkEventScroll* event) {\n+void WindowContext::process_mouse_scroll(GdkEventScroll *event) {\n@@ -431,1 +573,0 @@\n-\n@@ -434,1 +575,1 @@\n-void WindowContextBase::process_mouse_cross(GdkEventCrossing* event) {\n+void WindowContext::process_mouse_cross(GdkEventCrossing *event) {\n@@ -457,1 +598,1 @@\n-void WindowContextBase::process_key(GdkEventKey* event) {\n+void WindowContext::process_key(GdkEventKey *event) {\n@@ -466,1 +607,1 @@\n-    jcharArray jChars = NULL;\n+    jcharArray jChars = nullptr;\n@@ -494,0 +635,1 @@\n+    \/\/ TYPED events should only be sent for printable characters.\n@@ -495,1 +637,1 @@\n-    if (press && key > 0 && jview) { \/\/ TYPED events should only be sent for printable characters.\n+    if (press && key > 0 && jview) {\n@@ -505,2 +647,1 @@\n-void WindowContextBase::paint(void* data, jint width, jint height) {\n-#ifdef GLASS_GTK3\n+void WindowContext::paint(void* data, jint width, jint height) {\n@@ -510,1 +651,1 @@\n-#endif\n+\n@@ -519,2 +660,0 @@\n-    applyShapeMask(data, width, height);\n-\n@@ -525,1 +664,0 @@\n-#ifdef GLASS_GTK3\n@@ -528,1 +666,0 @@\n-#endif\n@@ -534,1 +671,1 @@\n-void WindowContextBase::add_child(WindowContextTop* child) {\n+void WindowContext::add_child(WindowContext* child) {\n@@ -536,1 +673,1 @@\n-    gtk_window_set_transient_for(child->get_gtk_window(), this->get_gtk_window());\n+    gdk_window_set_transient_for(child->get_gdk_window(), gdk_window);\n@@ -539,1 +676,1 @@\n-void WindowContextBase::remove_child(WindowContextTop* child) {\n+void WindowContext::remove_child(WindowContext* child) {\n@@ -541,25 +678,0 @@\n-    gtk_window_set_transient_for(child->get_gtk_window(), NULL);\n-}\n-\n-void WindowContextBase::set_visible(bool visible) {\n-    if (visible) {\n-        gtk_widget_show(gtk_widget);\n-    } else {\n-        gtk_widget_hide(gtk_widget);\n-        if (jview && is_mouse_entered) {\n-            is_mouse_entered = false;\n-            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n-                    com_sun_glass_events_MouseEvent_EXIT,\n-                    com_sun_glass_events_MouseEvent_BUTTON_NONE,\n-                    0, 0,\n-                    0, 0,\n-                    0,\n-                    JNI_FALSE,\n-                    JNI_FALSE);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n-    }\n-}\n-\n-bool WindowContextBase::is_visible() {\n-    return gtk_widget_get_visible(gtk_widget);\n@@ -568,2 +680,2 @@\n-bool WindowContextBase::is_resizable() {\n-    return false;\n+bool WindowContext::is_visible() {\n+    return gdk_window_is_visible(gdk_window);\n@@ -572,1 +684,2 @@\n-bool WindowContextBase::set_view(jobject view) {\n+bool WindowContext::set_view(jobject view) {\n+    LOG(\"set_view\\n\");\n@@ -588,1 +701,1 @@\n-        jview = NULL;\n+        jview = nullptr;\n@@ -590,1 +703,1 @@\n-    return TRUE;\n+    return true;\n@@ -593,1 +706,2 @@\n-bool WindowContextBase::grab_mouse_drag_focus() {\n+bool WindowContext::grab_mouse_drag_focus() {\n+    LOG(\"grab_mouse_drag_focus\\n\");\n@@ -595,2 +709,2 @@\n-            gdk_window, gdk_window_get_cursor(gdk_window), FALSE)) {\n-        WindowContextBase::sm_mouse_drag_window = this;\n+            gdk_window, gdk_window_get_cursor(gdk_window), false)) {\n+        WindowContext::sm_mouse_drag_window = this;\n@@ -603,2 +717,7 @@\n-void WindowContextBase::ungrab_mouse_drag_focus() {\n-    WindowContextBase::sm_mouse_drag_window = NULL;\n+void WindowContext::ungrab_mouse_drag_focus() {\n+    if (!WindowContext::sm_mouse_drag_window) {\n+        return;\n+    }\n+\n+    LOG(\"ungrab_mouse_drag_focus\\n\");\n+    WindowContext::sm_mouse_drag_window = nullptr;\n@@ -606,2 +725,2 @@\n-    if (WindowContextBase::sm_grab_window) {\n-        WindowContextBase::sm_grab_window->grab_focus();\n+    if (WindowContext::sm_grab_window) {\n+        WindowContext::sm_grab_window->grab_focus();\n@@ -611,2 +730,3 @@\n-bool WindowContextBase::grab_focus() {\n-    if (WindowContextBase::sm_mouse_drag_window\n+bool WindowContext::grab_focus() {\n+    LOG(\"grab_focus\\n\");\n+    if (WindowContext::sm_mouse_drag_window\n@@ -614,1 +734,1 @@\n-        WindowContextBase::sm_grab_window = this;\n+        WindowContext::sm_grab_window = this;\n@@ -621,2 +741,3 @@\n-void WindowContextBase::ungrab_focus() {\n-    if (!WindowContextBase::sm_mouse_drag_window) {\n+void WindowContext::ungrab_focus() {\n+    LOG(\"ungrab_focus\\n\");\n+    if (!WindowContext::sm_mouse_drag_window) {\n@@ -625,1 +746,2 @@\n-    WindowContextBase::sm_grab_window = NULL;\n+\n+    WindowContext::sm_grab_window = nullptr;\n@@ -628,0 +750,1 @@\n+        LOG(\"jWindowNotifyFocusUngrab\\n\");\n@@ -633,1 +756,1 @@\n-void WindowContextBase::set_cursor(GdkCursor* cursor) {\n+void WindowContext::set_cursor(GdkCursor* cursor) {\n@@ -635,1 +758,1 @@\n-        if (WindowContextBase::sm_mouse_drag_window) {\n+        if (WindowContext::sm_mouse_drag_window) {\n@@ -637,2 +760,2 @@\n-                    WindowContextBase::sm_mouse_drag_window->get_gdk_window(), cursor, FALSE);\n-        } else if (WindowContextBase::sm_grab_window) {\n+                    WindowContext::sm_mouse_drag_window->get_gdk_window(), cursor, false);\n+        } else if (WindowContext::sm_grab_window) {\n@@ -640,1 +763,1 @@\n-                    WindowContextBase::sm_grab_window->get_gdk_window(), cursor, TRUE);\n+                    WindowContext::sm_grab_window->get_gdk_window(), cursor, true);\n@@ -646,1 +769,1 @@\n-    if (gdk_cursor_override == NULL) {\n+    if (gdk_cursor_override == nullptr) {\n@@ -651,1 +774,1 @@\n-void WindowContextBase::set_cursor_override(GdkCursor* cursor) {\n+void WindowContext::set_cursor_override(GdkCursor* cursor) {\n@@ -658,1 +781,1 @@\n-    if (cursor != NULL) {\n+    if (cursor != nullptr) {\n@@ -665,7 +788,3 @@\n-void WindowContextBase::set_background(float r, float g, float b) {\n-    GdkRGBA rgba = {r, g, b, 1.};\n-    gtk_widget_override_background_color(gtk_widget, GTK_STATE_FLAG_NORMAL, &rgba);\n-}\n-\n-bool WindowContextBase::get_window_edge(int x, int y, GdkWindowEdge* window_edge) {\n-    return false;\n+void WindowContext::set_background(float r, float g, float b) {\n+    GdkRGBA rgba = {r, g, b, 1.0};\n+    gdk_window_set_background_rgba(gdk_window, &rgba);\n@@ -674,3 +793,6 @@\n-WindowContextBase::~WindowContextBase() {\n-    disableIME();\n-    gtk_widget_destroy(gtk_widget);\n+GdkAtom WindowContext::get_net_frame_extents_atom() {\n+    static GdkAtom atom = nullptr;\n+    if (atom == nullptr) {\n+        atom = gdk_atom_intern_static_string(\"_NET_FRAME_EXTENTS\");\n+    }\n+    return atom;\n@@ -679,2 +801,3 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ WindowContextTop \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n+void WindowContext::request_frame_extents() {\n+    Display *display = GDK_DISPLAY_XDISPLAY(gdk_window_get_display(gdk_window));\n+    static Atom rfeAtom = XInternAtom(display, \"_NET_REQUEST_FRAME_EXTENTS\", False);\n@@ -682,5 +805,3 @@\n-\/\/ Work-around because frame extents are only obtained after window is shown.\n-\/\/ This is used to know the total window size (content + decoration)\n-\/\/ The first window will have a duplicated resize event, subsequent windows will use the cached value.\n-WindowFrameExtents WindowContextTop::normal_extents = {0, 0, 0, 0};\n-WindowFrameExtents WindowContextTop::utility_extents = {0, 0, 0, 0};\n+    if (rfeAtom != None) {\n+        XClientMessageEvent clientMessage;\n+        memset(&clientMessage, 0, sizeof(clientMessage));\n@@ -688,0 +809,4 @@\n+        clientMessage.type = ClientMessage;\n+        clientMessage.window = GDK_WINDOW_XID(gdk_window);\n+        clientMessage.message_type = rfeAtom;\n+        clientMessage.format = 32;\n@@ -689,3 +814,5 @@\n-static void event_realize(GtkWidget* self, gpointer user_data) {\n-    WindowContextTop *ctx = ((WindowContextTop *) user_data);\n-    ctx->process_realize();\n+        XSendEvent(display, XDefaultRootWindow(display), False,\n+                   SubstructureRedirectMask | SubstructureNotifyMask,\n+                   (XEvent *) &clientMessage);\n+        XFlush(display);\n+    }\n@@ -694,7 +821,2 @@\n-static int geometry_get_window_width(const WindowGeometry *windowGeometry) {\n-     return (windowGeometry->final_width.type == BOUNDSTYPE_WINDOW)\n-                   ? windowGeometry->final_width.value\n-                   : windowGeometry->final_width.value\n-                         + windowGeometry->extents.left\n-                         + windowGeometry->extents.right;\n-}\n+void WindowContext::update_initial_state() {\n+    GdkWindowState state = gdk_window_get_state(gdk_window);\n@@ -702,7 +824,4 @@\n-static int geometry_get_window_height(const WindowGeometry *windowGeometry) {\n-    return (windowGeometry->final_height.type == BOUNDSTYPE_WINDOW)\n-                   ? windowGeometry->final_height.value\n-                   : windowGeometry->final_height.value\n-                         + windowGeometry->extents.top\n-                         + windowGeometry->extents.bottom;\n-}\n+    if (initial_state_mask & GDK_WINDOW_STATE_MAXIMIZED) {\n+        LOG(\"update_initial_state: maximized\\n\");\n+        maximize(true);\n+    }\n@@ -710,7 +829,4 @@\n-static int geometry_get_content_width(WindowGeometry *windowGeometry) {\n-    return (windowGeometry->final_width.type == BOUNDSTYPE_CONTENT)\n-                   ? windowGeometry->final_width.value\n-                   : windowGeometry->final_width.value\n-                         - windowGeometry->extents.left\n-                         - windowGeometry->extents.right;\n-}\n+    if (initial_state_mask & GDK_WINDOW_STATE_FULLSCREEN) {\n+        LOG(\"update_initial_state: fullscreen\\n\");\n+        enter_fullscreen();\n+    }\n@@ -718,7 +834,4 @@\n-static int geometry_get_content_height(WindowGeometry *windowGeometry) {\n-    return (windowGeometry->final_height.type == BOUNDSTYPE_CONTENT)\n-                   ? windowGeometry->final_height.value\n-                   : windowGeometry->final_height.value\n-                         - windowGeometry->extents.top\n-                         - windowGeometry->extents.bottom;\n-}\n+    if (initial_state_mask & GDK_WINDOW_STATE_ICONIFIED) {\n+        LOG(\"update_initial_state: iconify\\n\");\n+        iconify(true);\n+    }\n@@ -726,3 +839,1 @@\n-static GdkAtom get_net_frame_extents_atom() {\n-    static const char * extents_str = \"_NET_FRAME_EXTENTS\";\n-    return gdk_atom_intern(extents_str, FALSE);\n+    initial_state_mask = 0;\n@@ -731,13 +842,2 @@\n-WindowContextTop::WindowContextTop(jobject _jwindow, WindowContext* _owner, long _screen,\n-        WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf) :\n-            WindowContextBase(),\n-            screen(_screen),\n-            frame_type(_frame_type),\n-            window_type(type),\n-            owner(_owner),\n-            geometry(),\n-            resizable(),\n-            on_top(false),\n-            is_fullscreen(false) {\n-    jwindow = mainEnv->NewGlobalRef(_jwindow);\n-    gdk_windowManagerFunctions = wmf;\n+void WindowContext::update_frame_extents() {\n+    if (frame_type != TITLED) return;\n@@ -745,14 +845,1 @@\n-    gtk_widget = gtk_window_new(type == POPUP ? GTK_WINDOW_POPUP : GTK_WINDOW_TOPLEVEL);\n-    g_signal_connect(G_OBJECT(gtk_widget), \"realize\", G_CALLBACK(event_realize), this);\n-\n-    if (gchar* app_name = get_application_name()) {\n-        gtk_window_set_wmclass(GTK_WINDOW(gtk_widget), app_name, app_name);\n-        g_free(app_name);\n-    }\n-\n-    if (owner) {\n-        owner->add_child(this);\n-        if (on_top_inherited()) {\n-            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);\n-        }\n-    }\n+    int top, left, bottom, right;\n@@ -760,3 +847,5 @@\n-    if (type == UTILITY && frame_type != EXTENDED) {\n-        gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_UTILITY);\n-    }\n+    if (get_frame_extents_property(&top, &left, &bottom, &right)) {\n+        if (top > 0 || right > 0 || bottom > 0 || left > 0) {\n+            Rectangle old_extents = window_extents.get();\n+            Rectangle new_extents = { left, top, (left + right), (top + bottom) };\n+            bool changed = old_extents != new_extents;\n@@ -764,2 +853,1 @@\n-    const char* wm_name = gdk_x11_screen_get_window_manager_name(gdk_screen_get_default());\n-    wmanager = (g_strcmp0(\"Compiz\", wm_name) == 0) ? COMPIZ : UNKNOWN;\n+            LOG(\"------------------------------------------- frame extents - changed: %d\\n\", changed);\n@@ -767,3 +855,1 @@\n-\/\/    glong xdisplay = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationDisplay);\n-\/\/    gint  xscreenID = (gint)mainEnv->GetStaticIntField(jApplicationCls, jApplicationScreen);\n-    glong xvisualID = (glong)mainEnv->GetStaticLongField(jApplicationCls, jApplicationVisualID);\n+            if (!changed) return;\n@@ -771,4 +857,1 @@\n-    if (xvisualID != 0) {\n-        GdkVisual *visual = gdk_x11_screen_lookup_visual(gdk_screen_get_default(), xvisualID);\n-        glass_gtk_window_configure_from_visual(gtk_widget, visual);\n-    }\n+            set_cached_extents(new_extents);\n@@ -776,2 +859,6 @@\n-    gtk_widget_set_events(gtk_widget, GDK_FILTERED_EVENTS_MASK);\n-    gtk_widget_set_app_paintable(gtk_widget, TRUE);\n+            if (!is_floating()) {\n+                \/\/ Delay for then window is restored\n+                needs_to_update_frame_extents = true;\n+                LOG(\"Frame extents will be updated on restore\");\n+                return;\n+            }\n@@ -779,2 +866,3 @@\n-    glass_configure_window_transparency(gtk_widget, frame_type == TRANSPARENT);\n-    gtk_window_set_title(GTK_WINDOW(gtk_widget), \"\");\n+            Size size = view_size.get();\n+            int newW = size.width;\n+            int newH = size.height;\n@@ -782,6 +870,6 @@\n-    if (frame_type != TITLED) {\n-        gtk_window_set_decorated(GTK_WINDOW(gtk_widget), FALSE);\n-    } else {\n-        geometry.extents = get_cached_extents();\n-    }\n-}\n+            \/\/ Here the user might change the desktop theme and in consequence\n+            \/\/ change decoration sizes.\n+            if (width_type == BOUNDSTYPE_WINDOW) {\n+                \/\/ Re-add the extents and then subtract the new\n+                newW = newW + old_extents.width - new_extents.width;\n+            }\n@@ -789,11 +877,4 @@\n-\/\/ Applied to a temporary full screen window to prevent sending events to Java\n-void WindowContextTop::detach_from_java() {\n-    if (jview) {\n-        mainEnv->DeleteGlobalRef(jview);\n-        jview = NULL;\n-    }\n-    if (jwindow) {\n-        mainEnv->DeleteGlobalRef(jwindow);\n-        jwindow = NULL;\n-    }\n-}\n+            if (height_type == BOUNDSTYPE_WINDOW) {\n+                \/\/ Re-add the extents and then subtract the new\n+                newH = newH + old_extents.height - new_extents.height;\n+            }\n@@ -801,3 +882,2 @@\n-void WindowContextTop::request_frame_extents() {\n-    Display *display = GDK_DISPLAY_XDISPLAY(gdk_window_get_display(gdk_window));\n-    static Atom rfeAtom = XInternAtom(display, \"_NET_REQUEST_FRAME_EXTENTS\", False);\n+            newW = std::clamp(newW, 1, MAX_WINDOW_SIZE);\n+            newH = std::clamp(newH, 1, MAX_WINDOW_SIZE);\n@@ -805,3 +885,1 @@\n-    if (rfeAtom != None) {\n-        XClientMessageEvent clientMessage;\n-        memset(&clientMessage, 0, sizeof(clientMessage));\n+            LOG(\"extents received -> new view size: %d, %d\\n\", newW, newH);\n@@ -809,4 +887,3 @@\n-        clientMessage.type = ClientMessage;\n-        clientMessage.window = GDK_WINDOW_XID(gdk_window);\n-        clientMessage.message_type = rfeAtom;\n-        clientMessage.format = 32;\n+            Point loc = window_location.get();\n+            int x = loc.x;\n+            int y = loc.y;\n@@ -814,6 +891,5 @@\n-        XSendEvent(display, XDefaultRootWindow(display), False,\n-                   SubstructureRedirectMask | SubstructureNotifyMask,\n-                   (XEvent *) &clientMessage);\n-        XFlush(display);\n-    }\n-}\n+            \/\/ Gravity x, y are used in centerOnScreen(). Here it's used to adjust the position\n+            \/\/ accounting decorations\n+            if (gravity_x > 0 && x > 0) {\n+                x -= gravity_x * (float) (new_extents.width);\n+            }\n@@ -821,2 +897,3 @@\n-void WindowContextTop::update_frame_extents() {\n-    int top, left, bottom, right;\n+            if (gravity_y > 0 && y > 0) {\n+                y -= gravity_y  * (float) (new_extents.height);\n+            }\n@@ -824,35 +901,4 @@\n-    if (get_frame_extents_property(&top, &left, &bottom, &right)) {\n-        if (top > 0 || right > 0 || bottom > 0 || left > 0) {\n-            bool changed = geometry.extents.top != top\n-                            || geometry.extents.left != left\n-                            || geometry.extents.bottom != bottom\n-                            || geometry.extents.right != right;\n-\n-            if (changed) {\n-                geometry.extents.top = top;\n-                geometry.extents.left = left;\n-                geometry.extents.bottom = bottom;\n-                geometry.extents.right = right;\n-\n-                set_cached_extents(geometry.extents);\n-\n-                \/\/ set bounds again to correct window size\n-                \/\/ accounting decorations\n-                int w = geometry_get_window_width(&geometry);\n-                int h = geometry_get_window_height(&geometry);\n-                int cw = geometry_get_content_width(&geometry);\n-                int ch = geometry_get_content_height(&geometry);\n-\n-                int x = geometry.x;\n-                int y = geometry.y;\n-\n-                if (geometry.gravity_x != 0) {\n-                    x -= geometry.gravity_x * (float) (left + right);\n-                }\n-\n-                if (geometry.gravity_y != 0) {\n-                    y -= geometry.gravity_y * (float) (top + bottom);\n-                }\n-\n-                set_bounds(x, y, true, true, w, h, cw, ch, 0, 0);\n-           }\n+            window_extents.set(new_extents);\n+            view_size.set({newW, newH});\n+            window_location.set({x, y});\n+            move_resize(x, y, true, true, newW, newH);\n@@ -863,13 +909,1 @@\n-void WindowContextTop::set_cached_extents(WindowFrameExtents ex) {\n-    if (window_type == NORMAL) {\n-        normal_extents = ex;\n-    } else {\n-        utility_extents = ex;\n-    }\n-}\n-\n-WindowFrameExtents WindowContextTop::get_cached_extents() {\n-    return window_type == NORMAL ? normal_extents : utility_extents;\n-}\n-\n-bool WindowContextTop::get_frame_extents_property(int *top, int *left,\n+bool WindowContext::get_frame_extents_property(int *top, int *left,\n@@ -881,1 +915,1 @@\n-            gdk_atom_intern(\"CARDINAL\", FALSE),\n+            gdk_atom_intern(\"CARDINAL\", false),\n@@ -884,4 +918,4 @@\n-            FALSE,\n-            NULL,\n-            NULL,\n-            NULL,\n+            false,\n+            nullptr,\n+            nullptr,\n+            nullptr,\n@@ -901,4 +935,5 @@\n-void WindowContextTop::work_around_compiz_state() {\n-    \/\/ Workaround for https:\/\/bugs.launchpad.net\/unity\/+bug\/998073\n-    if (wmanager != COMPIZ) {\n-        return;\n+void WindowContext::set_cached_extents(Rectangle ex) {\n+    if (window_type == UTILITY) {\n+        utility_extents = ex;\n+    } else {\n+        normal_extents = ex;\n@@ -906,0 +941,1 @@\n+}\n@@ -907,4 +943,2 @@\n-    static GdkAtom atom_atom = gdk_atom_intern_static_string(\"ATOM\");\n-    static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string(\"_NET_WM_STATE\");\n-    static GdkAtom atom_net_wm_state_hidden = gdk_atom_intern_static_string(\"_NET_WM_STATE_HIDDEN\");\n-    static GdkAtom atom_net_wm_state_above = gdk_atom_intern_static_string(\"_NET_WM_STATE_ABOVE\");\n+void WindowContext::load_cached_extents() {\n+    if (frame_type != TITLED) return;\n@@ -912,1 +946,4 @@\n-    gint length;\n+    if (window_type == NORMAL && normal_extents.has_value()) {\n+        window_extents.set(normal_extents.value());\n+        return;\n+    }\n@@ -914,1 +951,4 @@\n-    glong* atoms = NULL;\n+    if (window_type == UTILITY && utility_extents.has_value()) {\n+        window_extents.set(utility_extents.value());\n+    }\n+}\n@@ -916,2 +956,5 @@\n-    if (gdk_property_get(gdk_window, atom_net_wm_state, atom_atom,\n-            0, G_MAXLONG, FALSE, NULL, NULL, &length, (guchar**) &atoms)) {\n+void WindowContext::process_property_notify(GdkEventProperty *event) {\n+    if (event->atom == get_net_frame_extents_atom()) {\n+        update_frame_extents();\n+    }\n+}\n@@ -919,9 +962,7 @@\n-        bool is_hidden = false;\n-        bool is_above = false;\n-        for (gint i = 0; i < (gint)(length \/ sizeof(glong)); i++) {\n-            if (atom_net_wm_state_hidden == (GdkAtom)atoms[i]) {\n-                is_hidden = true;\n-            } else if (atom_net_wm_state_above == (GdkAtom)atoms[i]) {\n-                is_above = true;\n-            }\n-        }\n+void WindowContext::process_state(GdkEventWindowState *event) {\n+    if (!(event->changed_mask & (GDK_WINDOW_STATE_ICONIFIED\n+                                | GDK_WINDOW_STATE_MAXIMIZED\n+                                | GDK_WINDOW_STATE_FULLSCREEN\n+                                | GDK_WINDOW_STATE_ABOVE))) {\n+        return;\n+    }\n@@ -929,1 +970,1 @@\n-        g_free(atoms);\n+    LOG(\"process_state\\n\");\n@@ -931,2 +972,2 @@\n-        if (is_iconified != is_hidden) {\n-            is_iconified = is_hidden;\n+    if (event->changed_mask & GDK_WINDOW_STATE_ABOVE) {\n+        notify_on_top(event->new_window_state & GDK_WINDOW_STATE_ABOVE);\n@@ -934,4 +975,2 @@\n-            notify_state((is_hidden)\n-                    ? com_sun_glass_events_WindowEvent_MINIMIZE\n-                    : com_sun_glass_events_WindowEvent_RESTORE);\n-        }\n+        if (event->changed_mask == GDK_WINDOW_STATE_ABOVE) return;\n+    }\n@@ -939,1 +978,10 @@\n-        notify_on_top(is_above);\n+    if ((event->changed_mask & (GDK_WINDOW_STATE_MAXIMIZED | GDK_WINDOW_STATE_ICONIFIED))\n+        && ((event->new_window_state & (GDK_WINDOW_STATE_MAXIMIZED | GDK_WINDOW_STATE_ICONIFIED)) == 0)) {\n+        LOG(\"com_sun_glass_events_WindowEvent_RESTORE\\n\");\n+        notify_window_resize(com_sun_glass_events_WindowEvent_RESTORE);\n+    } else if (event->new_window_state & (GDK_WINDOW_STATE_ICONIFIED)) {\n+        LOG(\"com_sun_glass_events_WindowEvent_MINIMIZE\\n\");\n+        notify_window_resize(com_sun_glass_events_WindowEvent_MINIMIZE);\n+    } else if (event->new_window_state & (GDK_WINDOW_STATE_MAXIMIZED)) {\n+        LOG(\"com_sun_glass_events_WindowEvent_MAXIMIZE\\n\");\n+        notify_window_resize(com_sun_glass_events_WindowEvent_MAXIMIZE);\n@@ -941,1 +989,0 @@\n-}\n@@ -943,2 +990,4 @@\n-void WindowContextTop::process_property_notify(GdkEventProperty* event) {\n-    static GdkAtom atom_net_wm_state = gdk_atom_intern_static_string(\"_NET_WM_STATE\");\n+    if (event->changed_mask & GDK_WINDOW_STATE_ICONIFIED\n+        && (event->new_window_state & GDK_WINDOW_STATE_ICONIFIED) == 0) {\n+        remove_wmf(GDK_FUNC_MINIMIZE);\n+    }\n@@ -946,6 +995,6 @@\n-    if (event->window == gdk_window) {\n-        if (event->atom == get_net_frame_extents_atom()) {\n-            update_frame_extents();\n-        } else if (event->atom == atom_net_wm_state) {\n-            work_around_compiz_state();\n-        }\n+    \/\/ If only iconified, no further processing\n+    if (event->changed_mask == GDK_WINDOW_STATE_ICONIFIED) return;\n+\n+    if (event->changed_mask & GDK_WINDOW_STATE_MAXIMIZED\n+        && (event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) == 0) {\n+        remove_wmf(GDK_FUNC_MAXIMIZE);\n@@ -953,1 +1002,0 @@\n-}\n@@ -955,3 +1003,2 @@\n-void WindowContextTop::process_state(GdkEventWindowState* event) {\n-    if (event->changed_mask & GDK_WINDOW_STATE_FULLSCREEN) {\n-        is_fullscreen = event->new_window_state & GDK_WINDOW_STATE_FULLSCREEN;\n+    if (jview && event->changed_mask & GDK_WINDOW_STATE_FULLSCREEN) {\n+        notify_fullscreen(event->new_window_state & GDK_WINDOW_STATE_FULLSCREEN);\n@@ -960,4 +1007,4 @@\n-    if (event->changed_mask & GDK_WINDOW_STATE_MAXIMIZED\n-        && !(event->new_window_state & GDK_WINDOW_STATE_MAXIMIZED)) {\n-        gtk_window_resize(GTK_WINDOW(gtk_widget), geometry_get_content_width(&geometry),\n-                                    geometry_get_content_height(&geometry));\n+    \/\/ Since FullScreen (or custom modes of maximized) can undecorate the\n+    \/\/ window, request view position change\n+    if (frame_type == TITLED) {\n+        notify_view_move();\n@@ -966,1 +1013,8 @@\n-    WindowContextBase::process_state(event);\n+    bool restored = (event->changed_mask & (GDK_WINDOW_STATE_MAXIMIZED | GDK_WINDOW_STATE_FULLSCREEN))\n+                    && ((event->new_window_state & (GDK_WINDOW_STATE_MAXIMIZED | GDK_WINDOW_STATE_FULLSCREEN)) == 0);\n+\n+    if (restored && needs_to_update_frame_extents) {\n+        LOG(\"State restored\");\n+        needs_to_update_frame_extents = false;\n+        load_cached_extents();\n+    }\n@@ -969,4 +1023,14 @@\n-void WindowContextTop::process_realize() {\n-    gdk_window = gtk_widget_get_window(gtk_widget);\n-    if (frame_type == TITLED) {\n-        request_frame_extents();\n+void WindowContext::notify_fullscreen(bool enter) {\n+    LOG(\"com_sun_glass_events_ViewEvent_FULLSCREEN_%s\\n\", enter ? \"ENTER\" : \"EXIT\");\n+    mainEnv->CallVoidMethod(jview, jViewNotifyView, enter\n+                                        ? com_sun_glass_events_ViewEvent_FULLSCREEN_ENTER\n+                                        : com_sun_glass_events_ViewEvent_FULLSCREEN_EXIT);\n+    CHECK_JNI_EXCEPTION(mainEnv)\n+}\n+\n+void WindowContext::notify_window_resize(int state) {\n+    if (jwindow) {\n+        Size size = window_size.get();\n+        LOG(\"jWindowNotifyResize: %d -> %d, %d\\n\", state, size.width, size.height);\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize, state, size.width, size.height);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n@@ -974,0 +1038,1 @@\n+}\n@@ -975,3 +1040,8 @@\n-    gdk_window_set_events(gdk_window, GDK_FILTERED_EVENTS_MASK);\n-    g_object_set_data_full(G_OBJECT(gdk_window), GDK_WINDOW_DATA_CONTEXT, this, NULL);\n-    gdk_window_register_dnd(gdk_window);\n+void WindowContext::notify_window_move() {\n+    if (jwindow) {\n+        Point point = window_location.get();\n+        LOG(\"jWindowNotifyMove: %d, %d\\n\", point.x, point.y);\n+        mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove, point.x, point.y);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n+    }\n+}\n@@ -979,2 +1049,6 @@\n-    if (gdk_windowManagerFunctions) {\n-        gdk_window_set_functions(gdk_window, gdk_windowManagerFunctions);\n+void WindowContext::notify_view_resize() {\n+    if (jview) {\n+        Size size = view_size.get();\n+        LOG(\"jViewNotifyResize: %d, %d\\n\", size.width, size.height);\n+        mainEnv->CallVoidMethod(jview, jViewNotifyResize, size.width, size.height);\n+        CHECK_JNI_EXCEPTION(mainEnv)\n@@ -984,3 +1058,4 @@\n-void WindowContextTop::process_configure(GdkEventConfigure* event) {\n-    int ww = event->width + geometry.extents.left + geometry.extents.right;\n-    int wh = event->height + geometry.extents.top + geometry.extents.bottom;\n+void WindowContext::notify_current_sizes() {\n+    notify_window_resize(is_maximized()\n+                            ? com_sun_glass_events_WindowEvent_MAXIMIZE\n+                            : com_sun_glass_events_WindowEvent_RESIZE);\n@@ -988,7 +1063,8 @@\n-    \/\/ Do not report if iconified, because Java side would set the state to NORMAL\n-    if (jwindow && !is_iconified) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,\n-                (is_maximized)\n-                    ? com_sun_glass_events_WindowEvent_MAXIMIZE\n-                    : com_sun_glass_events_WindowEvent_RESIZE,\n-                ww, wh);\n+    notify_view_resize();\n+}\n+\n+void WindowContext::notify_view_move() {\n+    if (jview) {\n+        LOG(\"com_sun_glass_events_ViewEvent_MOVE\\n\");\n+        mainEnv->CallVoidMethod(jview, jViewNotifyView,\n+                com_sun_glass_events_ViewEvent_MOVE);\n@@ -996,0 +1072,2 @@\n+    }\n+}\n@@ -997,4 +1075,7 @@\n-        if (jview) {\n-            mainEnv->CallVoidMethod(jview, jViewNotifyResize, event->width, event->height);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n+void WindowContext::process_configure(GdkEventConfigure *event) {\n+    LOG(\"Configure Event - send_event: %d, x: %d, y: %d, width: %d, height: %d\\n\",\n+            event->send_event, event->x, event->y, event->width, event->height);\n+\n+    if (mapped && !event->send_event) {\n+        \/\/ This is used to let the compositor detect the resize\n+        gdk_window_invalidate_rect(gdk_window, nullptr, false);\n@@ -1003,3 +1084,15 @@\n-    if (!is_iconified && !is_fullscreen && !is_maximized) {\n-        geometry.final_width.value = (geometry.final_width.type == BOUNDSTYPE_CONTENT)\n-                ? event->width : ww;\n+    int x, y;\n+    int view_x = 0, view_y = 0;\n+\n+    if (frame_type == TITLED) {\n+        \/\/ view_x and view_y represent the position of the content relative to the left corner of the window,\n+        \/\/ taking into account window decorations (such as title bars and borders) applied by the window manager\n+        \/\/ and might vary by window state.\n+        int root_x, root_y;\n+        gdk_window_get_root_origin(gdk_window, &root_x, &root_y);\n+\n+        view_x = event->x - root_x;\n+        view_y = event->y - root_y;\n+\n+        x = root_x;\n+        y = root_y;\n@@ -1007,2 +1100,5 @@\n-        geometry.final_height.value = (geometry.final_height.type == BOUNDSTYPE_CONTENT)\n-                ? event->height : wh;\n+        view_position.set({view_x, view_y});\n+    } else {\n+        view_position.set({0, 0});\n+        x = event->x;\n+        y = event->y;\n@@ -1011,3 +1107,4 @@\n-    gint root_x, root_y, origin_x, origin_y;\n-    gdk_window_get_root_origin(gdk_window, &root_x, &root_y);\n-    gdk_window_get_origin(gdk_window, &origin_x, &origin_y);\n+    int ww = event->width;\n+    int wh = event->height;\n+\n+    Rectangle extents = window_extents.get();\n@@ -1015,3 +1112,4 @@\n-    \/\/ x and y represent the position of the top-left corner of the window relative to the desktop area\n-    geometry.x = root_x;\n-    geometry.y = root_y;\n+    \/\/ Fullscreen usually have no decorations\n+    if (view_x > 0) {\n+        ww += extents.width;\n+    }\n@@ -1019,5 +1117,3 @@\n-    \/\/ view_x and view_y represent the position of the content relative to the top-left corner of the window,\n-    \/\/ taking into account window decorations (such as title bars and borders) applied by the window manager.\n-    geometry.view_x = origin_x - root_x;\n-    geometry.view_y = origin_y - root_y;\n-    notify_window_move();\n+    if (view_y > 0) {\n+        wh += extents.height;\n+    }\n@@ -1025,10 +1121,14 @@\n-    glong to_screen = getScreenPtrForLocation(geometry.x, geometry.y);\n-    if (to_screen != -1) {\n-        if (to_screen != screen) {\n-            if (jwindow) {\n-                \/\/notify screen changed\n-                jobject jScreen = createJavaScreen(mainEnv, to_screen);\n-                mainEnv->CallVoidMethod(jwindow, jWindowNotifyMoveToAnotherScreen, jScreen);\n-                CHECK_JNI_EXCEPTION(mainEnv)\n-            }\n-            screen = to_screen;\n+    if (mapped) {\n+        window_location.set({x, y});\n+        view_size.set({event->width, event->height});\n+        window_size.set({ww, wh});\n+    }\n+\n+    glong to_screen = getScreenPtrForLocation(event->x, event->y);\n+    if (to_screen != -1 && to_screen != screen) {\n+        if (jwindow) {\n+            LOG(\"jWindowNotifyMoveToAnotherScreen\\n\");\n+            \/\/notify screen changed\n+            jobject jScreen = createJavaScreen(mainEnv, to_screen);\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyMoveToAnotherScreen, jScreen);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n@@ -1036,0 +1136,1 @@\n+        screen = to_screen;\n@@ -1039,5 +1140,5 @@\n-void WindowContextTop::update_window_constraints() {\n-    bool is_floating = !is_iconified && !is_fullscreen && !is_maximized;\n-\n-    if (!is_floating) {\n-        \/\/ window is not floating on the screen\n+void WindowContext::update_window_constraints() {\n+    LOG(\"update_window_constraints\\n\")\n+    \/\/ Not ready to re-apply the constraints\n+    if (!is_floating() || !is_state_floating((GdkWindowState) initial_state_mask)) {\n+        LOG(\"not floating: update_window_constraints ignored\\n\");\n@@ -1050,2 +1151,1 @@\n-        int w = std::max(resizable.sysminw, resizable.minw);\n-        int h = std::max(resizable.sysminh, resizable.minh);\n+        Size min = minimum_size.get().max(sys_min_size.get());\n@@ -1053,2 +1153,1 @@\n-        int min_w = (w == -1) ? 1 : w - geometry.extents.left - geometry.extents.right;\n-        int min_h =  (h == -1) ? 1 : h - geometry.extents.top - geometry.extents.bottom;\n+        Rectangle extents = window_extents.get();\n@@ -1056,2 +1155,2 @@\n-        hints.min_width = (min_w < 1) ? 1 : min_w;\n-        hints.min_height = (min_h < 1) ? 1 : min_h;\n+        hints.min_width = std::clamp(min.width - extents.width, 1, MAX_WINDOW_SIZE);\n+        hints.min_height = std::clamp(min.height - extents.height, 1, MAX_WINDOW_SIZE);\n@@ -1059,2 +1158,1 @@\n-        hints.max_width = (resizable.maxw == -1) ? G_MAXINT\n-                            : resizable.maxw - geometry.extents.left - geometry.extents.right;\n+        Size max = maximum_size.get();\n@@ -1062,2 +1160,2 @@\n-        hints.max_height = (resizable.maxh == -1) ? G_MAXINT\n-                           : resizable.maxh - geometry.extents.top - geometry.extents.bottom;\n+        hints.max_width = std::clamp(max.width - extents.width, 1, MAX_WINDOW_SIZE);\n+        hints.max_height = std::clamp(max.height - extents.height, 1, MAX_WINDOW_SIZE);\n@@ -1065,2 +1163,3 @@\n-        int w = geometry_get_content_width(&geometry);\n-        int h = geometry_get_content_height(&geometry);\n+        Size size = view_size.get();\n+        int w = std::clamp(size.width, 1, MAX_WINDOW_SIZE);\n+        int h = std::clamp(size.height, 1, MAX_WINDOW_SIZE);\n@@ -1074,2 +1173,6 @@\n-    gtk_window_set_geometry_hints(GTK_WINDOW(gtk_widget), NULL, &hints,\n-                                  (GdkWindowHints)(GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));\n+    LOG(\"geometry hints: min w,h: %d, %d - max w,h: %d, %d\\n\", hints.min_width,\n+            hints.min_height, hints.max_width, hints.max_height);\n+\n+    \/\/ GDK_HINT_USER_POS is used for the initial position to work\n+    gdk_window_set_geometry_hints(gdk_window, &hints,\n+            (GdkWindowHints) (GDK_HINT_USER_POS |  GDK_HINT_MIN_SIZE | GDK_HINT_MAX_SIZE));\n@@ -1078,3 +1181,3 @@\n-void WindowContextTop::set_resizable(bool res) {\n-    resizable.value = res;\n-    update_window_constraints();\n+void WindowContext::set_resizable(bool res) {\n+    LOG(\"set_resizable: %d\\n\", res);\n+    resizable.set(res);\n@@ -1083,2 +1186,2 @@\n-bool WindowContextTop::is_resizable() {\n-    return resizable.value;\n+bool WindowContext::is_resizable() {\n+    return resizable.get();\n@@ -1087,2 +1190,3 @@\n-void WindowContextTop::set_visible(bool visible) {\n-    WindowContextBase::set_visible(visible);\n+bool WindowContext::is_maximized() {\n+    return gdk_window_get_state(gdk_window) & GDK_WINDOW_STATE_MAXIMIZED;\n+}\n@@ -1090,3 +1194,3 @@\n-    if (visible && !geometry.size_assigned) {\n-        set_bounds(0, 0, false, false, 320, 200, -1, -1, 0, 0);\n-    }\n+bool WindowContext::is_fullscreen() {\n+    return gdk_window_get_state(gdk_window) & GDK_WINDOW_STATE_FULLSCREEN;\n+}\n@@ -1094,4 +1198,31 @@\n-    \/\/JDK-8220272 - fire event first because GDK_FOCUS_CHANGE is not always in order\n-    if (visible && jwindow && isEnabled()) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);\n-        CHECK_JNI_EXCEPTION(mainEnv);\n+bool WindowContext::is_iconified() {\n+    return gdk_window_get_state(gdk_window) & GDK_WINDOW_STATE_ICONIFIED;\n+}\n+\n+bool WindowContext::is_floating() {\n+    return is_state_floating(gdk_window_get_state(gdk_window));\n+}\n+\n+void WindowContext::set_visible(bool visible) {\n+    LOG(\"set_visible: %d\\n\", visible);\n+    if (visible) {\n+        gdk_window_show(gdk_window);\n+\n+        if (jwindow && isEnabled()) {\n+            mainEnv->CallVoidMethod(jwindow, jWindowNotifyFocus, com_sun_glass_events_WindowEvent_FOCUS_GAINED);\n+            CHECK_JNI_EXCEPTION(mainEnv);\n+        }\n+    } else {\n+        gdk_window_hide(gdk_window);\n+        if (jview && is_mouse_entered) {\n+            is_mouse_entered = false;\n+            mainEnv->CallVoidMethod(jview, jViewNotifyMouse,\n+                    com_sun_glass_events_MouseEvent_EXIT,\n+                    com_sun_glass_events_MouseEvent_BUTTON_NONE,\n+                    0, 0,\n+                    0, 0,\n+                    0,\n+                    JNI_FALSE,\n+                    JNI_FALSE);\n+            CHECK_JNI_EXCEPTION(mainEnv)\n+        }\n@@ -1101,4 +1232,4 @@\n-void WindowContextTop::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch,\n-                                  float gravity_x, float gravity_y) {\n-\/\/     fprintf(stderr, \"set_bounds -> x = %d, y = %d, xset = %d, yset = %d, w = %d, h = %d, cw = %d, ch = %d, gx = %f, gy = %f\\n\",\n-\/\/            x, y, xSet, ySet, w, h, cw, ch, gravity_x, gravity_y);\n+void WindowContext::set_bounds(int x, int y, bool xSet, bool ySet, int w, int h, int cw, int ch,\n+                               float gravity_x, float gravity_y) {\n+    LOG(\"set_bounds -> x = %d, y = %d, xset = %d, yset = %d, w = %d, h = %d, cw = %d, ch = %d, gx = %f, gy = %f\\n\",\n+            x, y, xSet, ySet, w, h, cw, ch, gravity_x, gravity_y);\n@@ -1109,2 +1240,2 @@\n-    geometry.gravity_x = gravity_x;\n-    geometry.gravity_y = gravity_y;\n+    this->gravity_x = gravity_x;\n+    this->gravity_y = gravity_y;\n@@ -1113,3 +1244,2 @@\n-        geometry.final_width.type = BOUNDSTYPE_WINDOW;\n-        geometry.final_width.value = w;\n-        newW = w - (geometry.extents.left + geometry.extents.right);\n+        width_type = BOUNDSTYPE_WINDOW;\n+        newW = std::clamp(w - window_extents.get().width, 1, MAX_WINDOW_SIZE);\n@@ -1117,2 +1247,4 @@\n-        geometry.final_width.type = BOUNDSTYPE_CONTENT;\n-        geometry.final_width.value = cw;\n+        \/\/ once set to window, stick with it\n+        if (width_type == BOUNDSTYPE_UNKNOWN) {\n+            width_type = BOUNDSTYPE_VIEW;\n+        }\n@@ -1120,2 +1252,0 @@\n-    } else {\n-        newW = geometry_get_content_width(&geometry);\n@@ -1125,3 +1255,2 @@\n-        geometry.final_height.type = BOUNDSTYPE_WINDOW;\n-        geometry.final_height.value = h;\n-        newH = h - (geometry.extents.top + geometry.extents.bottom);\n+        height_type = BOUNDSTYPE_WINDOW;\n+        newH = std::clamp(h - window_extents.get().height, 1, MAX_WINDOW_SIZE);\n@@ -1129,16 +1258,3 @@\n-        geometry.final_height.type = BOUNDSTYPE_CONTENT;\n-        geometry.final_height.value = ch;\n-        newH = ch;\n-    } else {\n-        newH = geometry_get_content_height(&geometry);\n-    }\n-\n-\n-    if (newW > 0 || newH > 0) {\n-        \/\/ call update_window_constraints() to let gtk_window_resize succeed, because it's bound to geometry constraints\n-        update_window_constraints();\n-\n-        if (gtk_widget_get_realized(gtk_widget)) {\n-            gtk_window_resize(GTK_WINDOW(gtk_widget), newW, newH);\n-        } else {\n-            gtk_window_set_default_size(GTK_WINDOW(gtk_widget), newW, newH);\n+        \/\/ once set to window, stick with it\n+        if (width_type == BOUNDSTYPE_UNKNOWN) {\n+            height_type = BOUNDSTYPE_VIEW;\n@@ -1146,2 +1262,1 @@\n-        geometry.size_assigned = true;\n-        notify_window_resize();\n+        newH = ch;\n@@ -1150,10 +1265,4 @@\n-    if (xSet || ySet) {\n-        if (xSet) {\n-            geometry.x = x;\n-        }\n-\n-        if (ySet) {\n-            geometry.y = y;\n-        }\n-\n-        gtk_window_move(GTK_WINDOW(gtk_widget), geometry.x, geometry.y);\n+    \/\/ Ignore when maximized \/ fullscreen (not floating)\n+    \/\/ Report back to java to correct the values\n+    if (mapped && !is_floating()) {\n+        notify_current_sizes();\n@@ -1161,5 +1270,0 @@\n-    }\n-}\n-\n-void WindowContextTop::applyShapeMask(void* data, uint width, uint height) {\n-    if (frame_type != TRANSPARENT) {\n@@ -1169,1 +1273,1 @@\n-    glass_window_apply_shape_mask(gtk_widget_get_window(gtk_widget), data, width, height);\n+    move_resize(x, y, xSet, ySet, newW, newH);\n@@ -1172,15 +1276,4 @@\n-void WindowContextTop::set_minimized(bool minimize) {\n-    is_iconified = minimize;\n-    if (minimize) {\n-        if (frame_type == TRANSPARENT && wmanager == COMPIZ) {\n-            \/\/ https:\/\/bugs.launchpad.net\/ubuntu\/+source\/unity\/+bug\/1245571\n-            glass_window_reset_input_shape_mask(gtk_widget_get_window(gtk_widget));\n-        }\n-\n-        if ((gdk_windowManagerFunctions & GDK_FUNC_MINIMIZE) == 0) {\n-            \/\/ in this case - the window manager will not support the programatic\n-            \/\/ request to iconify - so we need to disable this until we are restored.\n-            GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MINIMIZE);\n-            gdk_window_set_functions(gdk_window, wmf);\n-        }\n-        gtk_window_iconify(GTK_WINDOW(gtk_widget));\n+void WindowContext::iconify(bool state) {\n+    if (state) {\n+        add_wmf(GDK_FUNC_MINIMIZE);\n+        gdk_window_iconify(gdk_window);\n@@ -1188,1 +1281,1 @@\n-        gtk_window_deiconify(GTK_WINDOW(gtk_widget));\n+        gdk_window_deiconify(gdk_window);\n@@ -1193,7 +1286,8 @@\n-void WindowContextTop::set_maximized(bool maximize) {\n-    is_maximized = maximize;\n-    if (maximize) {\n-        \/\/ enable the functionality on the window manager as it might ignore the maximize command,\n-        \/\/ for example when the window is undecorated.\n-        GdkWMFunction wmf = (GdkWMFunction)(gdk_windowManagerFunctions | GDK_FUNC_MAXIMIZE);\n-        gdk_window_set_functions(gdk_window, wmf);\n+void WindowContext::maximize(bool state) {\n+    if (state) {\n+        add_wmf(GDK_FUNC_MAXIMIZE);\n+        gdk_window_maximize(gdk_window);\n+    } else {\n+        gdk_window_unmaximize(gdk_window);\n+    }\n+}\n@@ -1201,1 +1295,4 @@\n-        gtk_window_maximize(GTK_WINDOW(gtk_widget));\n+void WindowContext::set_minimized(bool state) {\n+    LOG(\"set_minimized = %d\\n\", state);\n+    if (mapped) {\n+        iconify(state);\n@@ -1203,1 +1300,3 @@\n-        gtk_window_unmaximize(GTK_WINDOW(gtk_widget));\n+        initial_state_mask = state\n+            ? (initial_state_mask | GDK_WINDOW_STATE_ICONIFIED)\n+            : (initial_state_mask & ~GDK_WINDOW_STATE_ICONIFIED);\n@@ -1207,3 +1306,9 @@\n-void WindowContextTop::enter_fullscreen() {\n-    gtk_window_fullscreen(GTK_WINDOW(gtk_widget));\n-    is_fullscreen = true;\n+void WindowContext::set_maximized(bool state) {\n+    LOG(\"set_maximized = %d\\n\", state);\n+    if (mapped) {\n+        maximize(state);\n+    } else {\n+        initial_state_mask = state\n+            ? (initial_state_mask | GDK_WINDOW_STATE_MAXIMIZED)\n+            : (initial_state_mask & ~GDK_WINDOW_STATE_MAXIMIZED);\n+    }\n@@ -1212,2 +1317,7 @@\n-void WindowContextTop::exit_fullscreen() {\n-    gtk_window_unfullscreen(GTK_WINDOW(gtk_widget));\n+void WindowContext::enter_fullscreen() {\n+    LOG(\"enter_fullscreen\\n\");\n+    if (mapped) {\n+        gdk_window_fullscreen(gdk_window);\n+    } else {\n+        initial_state_mask |= GDK_WINDOW_STATE_FULLSCREEN;\n+    }\n@@ -1216,3 +1326,6 @@\n-void WindowContextTop::request_focus() {\n-    if (is_visible()) {\n-        gtk_window_present(GTK_WINDOW(gtk_widget));\n+void WindowContext::exit_fullscreen() {\n+    LOG(\"exit_fullscreen\\n\");\n+    if (mapped) {\n+        gdk_window_unfullscreen(gdk_window);\n+    } else {\n+        initial_state_mask &= ~GDK_WINDOW_STATE_FULLSCREEN;\n@@ -1222,2 +1335,9 @@\n-void WindowContextTop::set_focusable(bool focusable) {\n-    gtk_window_set_accept_focus(GTK_WINDOW(gtk_widget), focusable ? TRUE : FALSE);\n+void WindowContext::request_focus() {\n+    LOG(\"request_focus\\n\");\n+    if (!is_visible()) return;\n+\n+    gdk_window_focus(gdk_window, GDK_CURRENT_TIME);\n+}\n+\n+void WindowContext::set_focusable(bool focusable) {\n+    gdk_window_set_accept_focus(gdk_window, focusable ? true : false);\n@@ -1226,2 +1346,2 @@\n-void WindowContextTop::set_title(const char* title) {\n-    gtk_window_set_title(GTK_WINDOW(gtk_widget), title);\n+void WindowContext::set_title(const char* title) {\n+    gdk_window_set_title(gdk_window, title);\n@@ -1230,2 +1350,3 @@\n-void WindowContextTop::set_alpha(double alpha) {\n-    gtk_window_set_opacity(GTK_WINDOW(gtk_widget), (gdouble)alpha);\n+\/\/ This only works on Xorg\n+void WindowContext::set_alpha(double alpha) {\n+    gdk_window_set_opacity(gdk_window, (gdouble)alpha);\n@@ -1234,1 +1355,1 @@\n-void WindowContextTop::set_enabled(bool enabled) {\n+void WindowContext::set_enabled(bool enabled) {\n@@ -1239,4 +1360,3 @@\n-void WindowContextTop::set_system_minimum_size(int w, int h) {\n-    resizable.sysminw = w;\n-    resizable.sysminh = h;\n-    update_window_constraints();\n+void WindowContext::set_minimum_size(int w, int h) {\n+    LOG(\"set_minimum_size: %d, %d\\n\", w, h);\n+    minimum_size.set({w, h});\n@@ -1245,4 +1365,3 @@\n-void WindowContextTop::set_minimum_size(int w, int h) {\n-    resizable.minw = (w <= 0) ? 1 : w;\n-    resizable.minh = (h <= 0) ? 1 : h;\n-    update_window_constraints();\n+void WindowContext::set_system_minimum_size(int w, int h) {\n+    LOG(\"set_system_minimum_size: %d,%d\\n\", w, h)\n+    sys_min_size.set({w, h});\n@@ -1251,4 +1370,6 @@\n-void WindowContextTop::set_maximum_size(int w, int h) {\n-    resizable.maxw = w;\n-    resizable.maxh = h;\n-    update_window_constraints();\n+void WindowContext::set_maximum_size(int w, int h) {\n+    LOG(\"set_maximum_size: %d, %d\\n\", w, h);\n+    int maxw = (w == -1) ? G_MAXINT : w;\n+    int maxh = (h == -1) ? G_MAXINT : h;\n+\n+    maximum_size.set({maxw, maxh});\n@@ -1257,2 +1378,7 @@\n-void WindowContextTop::set_icon(GdkPixbuf* pixbuf) {\n-    gtk_window_set_icon(GTK_WINDOW(gtk_widget), pixbuf);\n+void WindowContext::set_icon(GdkPixbuf* icon) {\n+    if (icon == nullptr || !GDK_IS_PIXBUF(icon)) return;\n+\n+    GList *icons = nullptr;\n+    icons = g_list_append(icons, icon);\n+    gdk_window_set_icon_list(gdk_window, icons);\n+    g_list_free(icons);\n@@ -1261,1 +1387,2 @@\n-void WindowContextTop::to_front() {\n+void WindowContext::to_front() {\n+    LOG(\"to_front\\n\");\n@@ -1265,1 +1392,2 @@\n-void WindowContextTop::to_back() {\n+void WindowContext::to_back() {\n+    LOG(\"to_back\\n\");\n@@ -1269,1 +1397,1 @@\n-void WindowContextTop::set_modal(bool modal, WindowContext* parent) {\n+void WindowContext::set_modal(bool modal, WindowContext* parent) {\n@@ -1271,1 +1399,0 @@\n-        \/\/gtk_window_set_type_hint(GTK_WINDOW(gtk_widget), GDK_WINDOW_TYPE_HINT_DIALOG);\n@@ -1273,1 +1400,1 @@\n-            gtk_window_set_transient_for(GTK_WINDOW(gtk_widget), parent->get_gtk_window());\n+            gdk_window_set_transient_for(gdk_window, parent->get_gdk_window());\n@@ -1276,5 +1403,1 @@\n-    gtk_window_set_modal(GTK_WINDOW(gtk_widget), modal ? TRUE : FALSE);\n-}\n-\n-GtkWindow *WindowContextTop::get_gtk_window() {\n-    return GTK_WINDOW(gtk_widget);\n+    gdk_window_set_modal_hint(gdk_window, modal ? true : false);\n@@ -1283,5 +1406,1 @@\n-WindowGeometry WindowContextTop::get_geometry() {\n-    return geometry;\n-}\n-\n-void WindowContextTop::update_ontop_tree(bool on_top) {\n+void WindowContext::update_ontop_tree(bool on_top) {\n@@ -1289,2 +1408,2 @@\n-    gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), effective_on_top ? TRUE : FALSE);\n-    for (std::set<WindowContextTop*>::iterator it = children.begin(); it != children.end(); ++it) {\n+    gdk_window_set_keep_above(gdk_window, effective_on_top ? true : false);\n+    for (std::set<WindowContext*>::iterator it = children.begin(); it != children.end(); ++it) {\n@@ -1295,1 +1414,1 @@\n-bool WindowContextTop::on_top_inherited() {\n+bool WindowContext::on_top_inherited() {\n@@ -1298,1 +1417,1 @@\n-        WindowContextTop* topO = dynamic_cast<WindowContextTop*>(o);\n+        WindowContext* topO = dynamic_cast<WindowContext*>(o);\n@@ -1308,1 +1427,1 @@\n-bool WindowContextTop::effective_on_top() {\n+bool WindowContext::effective_on_top() {\n@@ -1310,1 +1429,1 @@\n-        WindowContextTop* topO = dynamic_cast<WindowContextTop*>(owner);\n+        WindowContext* topO = dynamic_cast<WindowContext*>(owner);\n@@ -1316,1 +1435,89 @@\n-void WindowContextTop::notify_on_top(bool top) {\n+void WindowContext::update_window_size() {\n+    LOG(\"update_window_size\\n\")\n+    Size size = view_size.get();\n+\n+    if (frame_type == TITLED) {\n+        window_size.set({size.width + window_extents.get().width, size.height + window_extents.get().height});\n+    } else {\n+        window_size.set(size);\n+    }\n+}\n+\n+void WindowContext::move_resize(int x, int y, bool xSet, bool ySet, int width, int height) {\n+    LOG(\"move_resize: x,y: %d,%d \/ cw,ch: %d,%d\\n\", x, y, width, height);\n+    Size size = view_size.get();\n+    int newW = (width > 0) ? width : size.width;\n+    int newH = (height > 0) ? height : size.height;\n+\n+    Rectangle extents = window_extents.get();\n+    int boundsW = newW, boundsH = newH;\n+\n+    Size max_size = maximum_size.get();\n+    Size min_size = minimum_size.get().max(sys_min_size.get());\n+\n+    \/\/ Windows that are undecorated or transparent will not respect\n+    \/\/ minimum or maximum size constraints\n+    if (min_size.width > 0 && newW < min_size.width) {\n+        boundsW = min_size.width - extents.width;\n+    }\n+\n+    if (max_size.width > 0 && newW > max_size.width) {\n+        boundsW = max_size.height - extents.width;\n+    }\n+\n+    if (min_size.height > 0 && newH < min_size.height) {\n+        boundsH = min_size.height - extents.height;\n+    }\n+\n+    if (max_size.height > 0 && newH > max_size.height) {\n+        boundsH = max_size.height - extents.height;\n+    }\n+\n+    boundsW = std::clamp(boundsW, 1, MAX_WINDOW_SIZE);\n+    boundsH = std::clamp(boundsH, 1, MAX_WINDOW_SIZE);\n+\n+    Size current_size = view_size.get();\n+\n+    \/\/ Need to force notify back to java, because it probably\n+    \/\/ has wrong sizes\n+    if ((newW != boundsW && current_size.width == boundsW)\n+            || newH != boundsH && current_size.height == boundsH) {\n+        view_size.invalidate();\n+        window_size.invalidate();\n+    }\n+\n+    Point loc = window_location.get();\n+    int newX = (xSet) ? x : loc.x;\n+    int newY = (ySet) ? y : loc.y;\n+\n+    if (!mapped) {\n+        view_size.set({boundsW, boundsH});\n+        update_window_size();\n+        window_location.set({newX, newY});\n+    }\n+\n+    LOG(\"gdk_window_move_resize: x,y: %d,%d \/ cw,ch: %d,%d\\n\", newX, newY, boundsW, boundsH);\n+\n+    if (!is_resizable()) {\n+        view_size.set({boundsW, boundsH});\n+        update_window_constraints();\n+    }\n+\n+    gdk_window_move_resize(gdk_window, newX, newY, boundsW, boundsH);\n+}\n+\n+void WindowContext::add_wmf(GdkWMFunction wmf) {\n+    if ((initial_wmf & wmf) == 0) {\n+        current_wmf = (GdkWMFunction)((int)current_wmf | (int)wmf);\n+        gdk_window_set_functions(gdk_window, current_wmf);\n+    }\n+}\n+\n+void WindowContext::remove_wmf(GdkWMFunction wmf) {\n+    if ((initial_wmf & wmf) == 0) {\n+        current_wmf = (GdkWMFunction)((int)current_wmf & ~(int)wmf);\n+        gdk_window_set_functions(gdk_window, current_wmf);\n+    }\n+}\n+\n+void WindowContext::notify_on_top(bool top) {\n@@ -1321,1 +1528,1 @@\n-            gtk_window_set_keep_above(GTK_WINDOW(gtk_widget), TRUE);\n+            gdk_window_set_keep_above(gdk_window, true);\n@@ -1333,1 +1540,1 @@\n-void WindowContextTop::set_level(int level) {\n+void WindowContext::set_level(int level) {\n@@ -1347,1 +1554,1 @@\n-void WindowContextTop::set_owner(WindowContext * owner_ctx) {\n+void WindowContext::set_owner(WindowContext * owner_ctx) {\n@@ -1351,27 +1558,2 @@\n-void WindowContextTop::update_view_size() {\n-    \/\/ Notify the view size only if size is oriented by WINDOW, otherwise it knows its own size\n-    if (geometry.final_width.type == BOUNDSTYPE_WINDOW\n-        || geometry.final_height.type == BOUNDSTYPE_WINDOW) {\n-\n-        notify_view_resize();\n-    }\n-}\n-\n-void WindowContextTop::notify_view_resize() {\n-    if (jview) {\n-        int cw = geometry_get_content_width(&geometry);\n-        int ch = geometry_get_content_height(&geometry);\n-\n-        mainEnv->CallVoidMethod(jview, jViewNotifyResize, cw, ch);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n-    }\n-}\n-\n-void WindowContextTop::notify_window_resize() {\n-    int w = geometry_get_window_width(&geometry);\n-    int h = geometry_get_window_height(&geometry);\n-\n-    mainEnv->CallVoidMethod(jwindow, jWindowNotifyResize,\n-                 com_sun_glass_events_WindowEvent_RESIZE, w, h);\n-    CHECK_JNI_EXCEPTION(mainEnv)\n-\n+void WindowContext::update_view_size() {\n+    LOG(\"update_view_size\\n\");\n@@ -1381,15 +1563,1 @@\n-void WindowContextTop::notify_window_move() {\n-    if (jwindow) {\n-        mainEnv->CallVoidMethod(jwindow, jWindowNotifyMove,\n-                                 geometry.x, geometry.y);\n-        CHECK_JNI_EXCEPTION(mainEnv)\n-\n-        if (jview) {\n-            mainEnv->CallVoidMethod(jview, jViewNotifyView,\n-                    com_sun_glass_events_ViewEvent_MOVE);\n-            CHECK_JNI_EXCEPTION(mainEnv)\n-        }\n-    }\n-}\n-\n-void WindowContextTop::show_system_menu(int x, int y) {\n+void WindowContext::show_system_menu(int x, int y) {\n@@ -1421,0 +1589,21 @@\n+Size WindowContext::get_view_size() {\n+    return view_size.get();\n+}\n+\n+Point WindowContext::get_view_position() {\n+    return view_position.get();\n+}\n+\n+WindowContext::~WindowContext() {\n+    LOG(\"~WindowContext\\n\");\n+    disableIME();\n+    gdk_window_destroy(gdk_window);\n+}\n+\n+WindowContextExtended::WindowContextExtended(jobject jwin,\n+                                             WindowContext* owner,\n+                                             long screen,\n+                                             GdkWMFunction wmf)\n+                        : WindowContext(jwin, owner, screen, EXTENDED, NORMAL, wmf) {\n+}\n+\n@@ -1426,1 +1615,2 @@\n-void WindowContextTop::process_mouse_button(GdkEventButton* event, bool synthesized) {\n+void WindowContextExtended::process_mouse_button(GdkEventButton* event, bool synthesized) {\n+    LOG(\"WindowContextExtended::process_mouse_button\\n\");\n@@ -1429,2 +1619,2 @@\n-    if (is_fullscreen || frame_type != EXTENDED || jwindow == NULL) {\n-        WindowContextBase::process_mouse_button(event);\n+    if (is_fullscreen() || get_jwindow() == nullptr) {\n+        WindowContext::process_mouse_button(event);\n@@ -1437,1 +1627,1 @@\n-            jwindow, jGtkWindowDragAreaHitTest, (jint)event->x, (jint)event->y);\n+           get_jwindow(), jGtkWindowDragAreaHitTest, (jint)event->x, (jint)event->y);\n@@ -1441,1 +1631,1 @@\n-            set_maximized(!is_maximized);\n+            set_maximized(!is_maximized());\n@@ -1450,1 +1640,1 @@\n-        bool shouldStartResizeDrag = is_resizable() && !is_maximized && get_window_edge(event->x, event->y, &edge);\n+        bool shouldStartResizeDrag = is_resizable() && !is_maximized() && get_window_edge(event->x, event->y, &edge);\n@@ -1457,1 +1647,1 @@\n-            WindowContextBase::process_mouse_button(event, true);\n+            WindowContext::process_mouse_button(event, true);\n@@ -1459,1 +1649,1 @@\n-            WindowContextBase::process_mouse_button(event, true);\n+            WindowContext::process_mouse_button(event, true);\n@@ -1463,1 +1653,1 @@\n-            gtk_window_begin_resize_drag(get_gtk_window(), edge, 1, rx, ry, event->time);\n+            gdk_window_begin_resize_drag(get_gdk_window(), edge, 1, rx, ry, event->time);\n@@ -1468,1 +1658,1 @@\n-            jwindow, jGtkWindowDragAreaHitTest, (jint)event->x, (jint)event->y);\n+            get_jwindow(), jGtkWindowDragAreaHitTest, (jint)event->x, (jint)event->y);\n@@ -1474,1 +1664,1 @@\n-            WindowContextBase::process_mouse_button(event, true);\n+            WindowContext::process_mouse_button(event, true);\n@@ -1476,1 +1666,1 @@\n-            WindowContextBase::process_mouse_button(event, true);\n+            WindowContext::process_mouse_button(event, true);\n@@ -1480,1 +1670,1 @@\n-            gtk_window_begin_move_drag(get_gtk_window(), 1, rx, ry, event->time);\n+            gdk_window_begin_move_drag(get_gdk_window(), 1, rx, ry, event->time);\n@@ -1486,1 +1676,1 @@\n-    WindowContextBase::process_mouse_button(event);\n+    WindowContext::process_mouse_button(event);\n@@ -1494,1 +1684,1 @@\n-void WindowContextTop::process_mouse_motion(GdkEventMotion* event) {\n+void WindowContextExtended::process_mouse_motion(GdkEventMotion* event) {\n@@ -1498,3 +1688,1 @@\n-    if (is_fullscreen\n-            || is_maximized\n-            || frame_type != EXTENDED\n+    if (!is_floating()\n@@ -1503,2 +1691,2 @@\n-        set_cursor_override(NULL);\n-        WindowContextBase::process_mouse_motion(event);\n+        set_cursor_override(nullptr);\n+        WindowContext::process_mouse_motion(event);\n@@ -1507,13 +1695,1 @@\n-\n-    static const struct Cursors {\n-        GdkCursor* NORTH = gdk_cursor_new(GDK_TOP_SIDE);\n-        GdkCursor* NORTH_EAST = gdk_cursor_new(GDK_TOP_RIGHT_CORNER);\n-        GdkCursor* EAST = gdk_cursor_new(GDK_RIGHT_SIDE);\n-        GdkCursor* SOUTH_EAST = gdk_cursor_new(GDK_BOTTOM_RIGHT_CORNER);\n-        GdkCursor* SOUTH = gdk_cursor_new(GDK_BOTTOM_SIDE);\n-        GdkCursor* SOUTH_WEST = gdk_cursor_new(GDK_BOTTOM_LEFT_CORNER);\n-        GdkCursor* WEST = gdk_cursor_new(GDK_LEFT_SIDE);\n-        GdkCursor* NORTH_WEST = gdk_cursor_new(GDK_TOP_LEFT_CORNER);\n-    } cursors;\n-\n-    GdkCursor* cursor = NULL;\n+    GdkCursor* cursor = nullptr;\n@@ -1522,8 +1698,8 @@\n-        case GDK_WINDOW_EDGE_NORTH: cursor = cursors.NORTH; break;\n-        case GDK_WINDOW_EDGE_NORTH_EAST: cursor = cursors.NORTH_EAST; break;\n-        case GDK_WINDOW_EDGE_EAST: cursor = cursors.EAST; break;\n-        case GDK_WINDOW_EDGE_SOUTH_EAST: cursor = cursors.SOUTH_EAST; break;\n-        case GDK_WINDOW_EDGE_SOUTH: cursor = cursors.SOUTH; break;\n-        case GDK_WINDOW_EDGE_SOUTH_WEST: cursor = cursors.SOUTH_WEST; break;\n-        case GDK_WINDOW_EDGE_WEST: cursor = cursors.WEST; break;\n-        case GDK_WINDOW_EDGE_NORTH_WEST: cursor = cursors.NORTH_WEST; break;\n+        case GDK_WINDOW_EDGE_NORTH: cursor = EdgeCursors::instance().NORTH; break;\n+        case GDK_WINDOW_EDGE_NORTH_EAST: cursor = EdgeCursors::instance().NORTH_EAST; break;\n+        case GDK_WINDOW_EDGE_EAST: cursor = EdgeCursors::instance().EAST; break;\n+        case GDK_WINDOW_EDGE_SOUTH_EAST: cursor = EdgeCursors::instance().SOUTH_EAST; break;\n+        case GDK_WINDOW_EDGE_SOUTH: cursor = EdgeCursors::instance().SOUTH; break;\n+        case GDK_WINDOW_EDGE_SOUTH_WEST: cursor = EdgeCursors::instance().SOUTH_WEST; break;\n+        case GDK_WINDOW_EDGE_WEST: cursor = EdgeCursors::instance().WEST; break;\n+        case GDK_WINDOW_EDGE_NORTH_WEST: cursor = EdgeCursors::instance().NORTH_WEST; break;\n@@ -1535,2 +1711,2 @@\n-    if (cursor == NULL) {\n-        WindowContextBase::process_mouse_motion(event);\n+    if (cursor == nullptr) {\n+        WindowContext::process_mouse_motion(event);\n@@ -1544,1 +1720,1 @@\n-bool WindowContextTop::get_window_edge(int x, int y, GdkWindowEdge* window_edge) {\n+bool WindowContextExtended::get_window_edge(int x, int y, GdkWindowEdge* window_edge) {\n@@ -1546,2 +1722,1 @@\n-    gint width, height;\n-    gtk_window_get_size(get_gtk_window(), &width, &height);\n+    Size size = get_view_size();\n@@ -1551,1 +1726,1 @@\n-        else if (y >= height - 2 * RESIZE_BORDER_WIDTH) edge = GDK_WINDOW_EDGE_SOUTH_WEST;\n+        else if (y >= size.height - 2 * RESIZE_BORDER_WIDTH) edge = GDK_WINDOW_EDGE_SOUTH_WEST;\n@@ -1553,1 +1728,1 @@\n-    } else if (x >= width - RESIZE_BORDER_WIDTH) {\n+    } else if (x >= size.width - RESIZE_BORDER_WIDTH) {\n@@ -1555,1 +1730,1 @@\n-        else if (y >= height - 2 * RESIZE_BORDER_WIDTH) edge = GDK_WINDOW_EDGE_SOUTH_EAST;\n+        else if (y >= size.height - 2 * RESIZE_BORDER_WIDTH) edge = GDK_WINDOW_EDGE_SOUTH_EAST;\n@@ -1559,1 +1734,1 @@\n-    } else if (y >= height - RESIZE_BORDER_WIDTH) {\n+    } else if (y >= size.height - RESIZE_BORDER_WIDTH) {\n@@ -1565,1 +1740,1 @@\n-    if (window_edge != NULL) {\n+    if (window_edge != nullptr) {\n@@ -1571,8 +1746,0 @@\n-\n-void WindowContextTop::process_destroy() {\n-    if (owner) {\n-        owner->remove_child(this);\n-    }\n-\n-    WindowContextBase::process_destroy();\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.cpp","additions":900,"deletions":733,"binary":false,"changes":1633,"status":"modified"},{"patch":"@@ -28,0 +28,9 @@\n+#define DEFAULT_WIDTH 320\n+#define DEFAULT_HEIGHT 200\n+\n+\/\/  Native Windows wider or taller than 32767 pixels are not supported\n+#define MAX_WINDOW_SIZE 32767\n+\n+#define GETTER(type, name) \\\n+    type get_##name() const { return name; }\n+\n@@ -34,0 +43,1 @@\n+#include <optional>\n@@ -36,1 +46,0 @@\n-\n@@ -38,0 +47,20 @@\n+#include \"glass_general.h\"\n+\n+#include <iostream>\n+#include <functional>\n+\n+template<typename T>\n+class Observable {\n+private:\n+    T value;\n+    std::function<void(const T&)> onChange;\n+\n+public:\n+    Observable(const T& initialValue = T()) : value(initialValue) {}\n+\n+    void set(const T& newValue) {\n+        if (value != newValue) {\n+            value = newValue;\n+            invalidate();\n+        }\n+    }\n@@ -39,3 +68,27 @@\n-enum WindowManager {\n-    COMPIZ,\n-    UNKNOWN\n+    void invalidate() {\n+        if (onChange) {\n+            onChange(value);\n+        }\n+    }\n+\n+    \/\/ This resets the value without notifying\n+    void reset(const T& newValue) {\n+        value = newValue;\n+    }\n+\n+    const T& get() const {\n+        return value;\n+    }\n+\n+    operator T() const {\n+        return value;\n+    }\n+\n+    Observable<T>& operator=(const T& newValue) {\n+        set(newValue);\n+        return *this;\n+    }\n+\n+    void setOnChange(std::function<void(const T&)> callback) {\n+        onChange = callback;\n+    }\n@@ -44,0 +97,45 @@\n+struct Rectangle {\n+    int x, y, width, height;\n+\n+    bool operator!=(const Rectangle& other) const {\n+        return x != other.x || y != other.y\n+               || width != other.width || height != other.height;\n+    }\n+\n+    bool operator==(const Rectangle& other) const {\n+        return x == other.x && y == other.y\n+               && width == other.width && height == other.height;\n+    }\n+};\n+\n+struct Size {\n+    int width, height;\n+\n+    bool operator!=(const Size& other) const {\n+        return width != other.width || height != other.height;\n+    }\n+\n+    bool operator==(const Size& other) const {\n+        return width == other.width && height == other.height;\n+    }\n+\n+    Size max(const Size& other) const {\n+        int w = std::max(other.width, width);\n+        int h = std::max(other.height, height);\n+        return {w, h};\n+    }\n+};\n+\n+struct Point {\n+    int x, y;\n+\n+    bool operator!=(const Point& other) const {\n+        return x != other.x || y != other.y;\n+    }\n+\n+    bool operator==(const Point& other) const {\n+        return x == other.x && y == other.y;\n+    }\n+};\n+\n+\n@@ -57,9 +155,0 @@\n-struct WindowFrameExtents {\n-    int top;\n-    int left;\n-    int bottom;\n-    int right;\n-};\n-\n-static const guint MOUSE_BUTTONS_MASK = (guint) (GDK_BUTTON1_MASK | GDK_BUTTON2_MASK | GDK_BUTTON3_MASK);\n-\n@@ -67,1 +156,2 @@\n-    BOUNDSTYPE_CONTENT,\n+    BOUNDSTYPE_UNKNOWN,\n+    BOUNDSTYPE_VIEW,\n@@ -71,24 +161,30 @@\n-struct WindowGeometry {\n-    WindowGeometry(): final_width(), final_height(),\n-    size_assigned(false), x(), y(), view_x(), view_y(), gravity_x(), gravity_y(), extents() {}\n-    \/\/ estimate of the final width the window will get after all pending\n-    \/\/ configure requests are processed by the window manager\n-    struct {\n-        int value;\n-        BoundsType type;\n-    } final_width;\n-\n-    struct {\n-        int value;\n-        BoundsType type;\n-    } final_height;\n-\n-    bool size_assigned;\n-\n-    int x;\n-    int y;\n-    int view_x;\n-    int view_y;\n-\n-    float gravity_x;\n-    float gravity_y;\n+struct EdgeCursors {\n+    GdkCursor* NORTH;\n+    GdkCursor* NORTH_EAST;\n+    GdkCursor* EAST;\n+    GdkCursor* SOUTH_EAST;\n+    GdkCursor* SOUTH;\n+    GdkCursor* SOUTH_WEST;\n+    GdkCursor* WEST;\n+    GdkCursor* NORTH_WEST;\n+\n+    EdgeCursors()\n+        : NORTH(gdk_cursor_new(GDK_TOP_SIDE)),\n+          NORTH_EAST(gdk_cursor_new(GDK_TOP_RIGHT_CORNER)),\n+          EAST(gdk_cursor_new(GDK_RIGHT_SIDE)),\n+          SOUTH_EAST(gdk_cursor_new(GDK_BOTTOM_RIGHT_CORNER)),\n+          SOUTH(gdk_cursor_new(GDK_BOTTOM_SIDE)),\n+          SOUTH_WEST(gdk_cursor_new(GDK_BOTTOM_LEFT_CORNER)),\n+          WEST(gdk_cursor_new(GDK_LEFT_SIDE)),\n+          NORTH_WEST(gdk_cursor_new(GDK_TOP_LEFT_CORNER)) {}\n+\n+    ~EdgeCursors() {\n+        g_object_unref(NORTH);\n+        g_object_unref(NORTH_EAST);\n+        g_object_unref(EAST);\n+        g_object_unref(SOUTH_EAST);\n+        g_object_unref(SOUTH);\n+        g_object_unref(SOUTH_WEST);\n+        g_object_unref(WEST);\n+        g_object_unref(NORTH_WEST);\n+    }\n@@ -96,1 +192,4 @@\n-    WindowFrameExtents extents;\n+    static EdgeCursors& instance() {\n+        static EdgeCursors cursors;\n+        return cursors;\n+    }\n@@ -99,1 +198,1 @@\n-class WindowContextTop;\n+static const guint MOUSE_BUTTONS_MASK = (guint) (GDK_BUTTON1_MASK | GDK_BUTTON2_MASK | GDK_BUTTON3_MASK);\n@@ -101,79 +200,0 @@\n-class WindowContext : public DeletedMemDebug<0xCC> {\n-public:\n-    virtual bool isEnabled() = 0;\n-    virtual bool hasIME() = 0;\n-    virtual bool filterIME(GdkEvent *) = 0;\n-    virtual void enableOrResetIME() = 0;\n-    virtual void updateCaretPos() = 0;\n-    virtual void disableIME() = 0;\n-    virtual void setOnPreEdit(bool) = 0;\n-    virtual void commitIME(gchar *) = 0;\n-\n-    virtual void paint(void* data, jint width, jint height) = 0;\n-    virtual WindowGeometry get_geometry() = 0;\n-\n-    virtual void show_system_menu(int x, int y) = 0;\n-    virtual void enter_fullscreen() = 0;\n-    virtual void exit_fullscreen() = 0;\n-    virtual void set_visible(bool) = 0;\n-    virtual bool is_visible() = 0;\n-    virtual void set_bounds(int, int, bool, bool, int, int, int, int, float, float) = 0;\n-    virtual void set_resizable(bool) = 0;\n-    virtual bool is_resizable() = 0;\n-    virtual void request_focus() = 0;\n-    virtual void set_focusable(bool)= 0;\n-    virtual bool grab_focus() = 0;\n-    virtual bool grab_mouse_drag_focus() = 0;\n-    virtual void ungrab_focus() = 0;\n-    virtual void ungrab_mouse_drag_focus() = 0;\n-    virtual void set_title(const char*) = 0;\n-    virtual void set_alpha(double) = 0;\n-    virtual void set_enabled(bool) = 0;\n-    virtual void set_system_minimum_size(int, int) = 0;\n-    virtual void set_minimum_size(int, int) = 0;\n-    virtual void set_maximum_size(int, int) = 0;\n-    virtual void set_minimized(bool) = 0;\n-    virtual void set_maximized(bool) = 0;\n-    virtual void set_icon(GdkPixbuf*) = 0;\n-    virtual void to_front() = 0;\n-    virtual void to_back() = 0;\n-    virtual void set_cursor(GdkCursor*) = 0;\n-    virtual void set_modal(bool, WindowContext* parent = NULL) = 0;\n-    virtual void set_level(int) = 0;\n-    virtual void set_background(float, float, float) = 0;\n-\n-    virtual void process_realize() = 0;\n-    virtual void process_property_notify(GdkEventProperty*) = 0;\n-    virtual void process_configure(GdkEventConfigure*) = 0;\n-    virtual void process_focus(GdkEventFocus*) = 0;\n-    virtual void process_destroy() = 0;\n-    virtual void process_delete() = 0;\n-    virtual void process_expose(GdkEventExpose*) = 0;\n-    virtual void process_mouse_button(GdkEventButton*, bool synthesized = false) = 0;\n-    virtual void process_mouse_motion(GdkEventMotion*) = 0;\n-    virtual void process_mouse_scroll(GdkEventScroll*) = 0;\n-    virtual void process_mouse_cross(GdkEventCrossing*) = 0;\n-    virtual void process_key(GdkEventKey*) = 0;\n-    virtual void process_state(GdkEventWindowState*) = 0;\n-\n-    virtual void notify_state(jint) = 0;\n-    virtual void notify_on_top(bool) {}\n-    virtual void update_view_size() = 0;\n-    virtual void notify_view_resize() = 0;\n-\n-    virtual void add_child(WindowContextTop* child) = 0;\n-    virtual void remove_child(WindowContextTop* child) = 0;\n-    virtual bool set_view(jobject) = 0;\n-\n-    virtual GdkWindow *get_gdk_window() = 0;\n-    virtual GtkWindow *get_gtk_window() = 0;\n-    virtual jobject get_jview() = 0;\n-    virtual jobject get_jwindow() = 0;\n-\n-    virtual void increment_events_counter() = 0;\n-    virtual void decrement_events_counter() = 0;\n-    virtual size_t get_events_count() = 0;\n-    virtual bool get_window_edge(int x, int y, GdkWindowEdge*) = 0;\n-    virtual bool is_dead() = 0;\n-    virtual ~WindowContext() {}\n-};\n@@ -181,1 +201,2 @@\n-class WindowContextBase: public WindowContext {\n+class WindowContext;\n+class WindowContextExtended;\n@@ -183,1 +204,8 @@\n-    struct ImContext {\n+class WindowContext: public DeletedMemDebug<0xCC> {\n+private:\n+    static std::optional<Rectangle> normal_extents;\n+    static std::optional<Rectangle> utility_extents;\n+\n+    struct _ImContext {\n+        _ImContext(): ctx(nullptr), enabled(false), on_preedit(false),\n+                     send_keypress(false), on_key_event(false) {}\n@@ -192,4 +220,3 @@\n-    size_t events_processing_cnt;\n-    bool can_be_deleted;\n-protected:\n-    std::set<WindowContextTop*> children;\n+    size_t events_processing_cnt{};\n+    std::set<WindowContext*> children;\n+\n@@ -197,11 +224,37 @@\n-    jobject jview;\n-    GtkWidget* gtk_widget;\n-    GdkWindow* gdk_window = NULL;\n-    GdkCursor* gdk_cursor = NULL;\n-    GdkCursor* gdk_cursor_override = NULL;\n-    GdkWMFunction gdk_windowManagerFunctions;\n-\n-    bool is_iconified;\n-    bool is_maximized;\n-    bool is_mouse_entered;\n-    bool is_disabled;\n+    jobject jview{};\n+\n+    struct WindowContext *owner;\n+    jlong screen;\n+\n+    bool is_mouse_entered{false};\n+    bool is_disabled{false};\n+    bool on_top{false};\n+    bool can_be_deleted{false};\n+    bool mapped{false};\n+    gint initial_state_mask{0};\n+\n+    WindowFrameType frame_type;\n+    WindowType window_type;\n+\n+    GdkWindow *gdk_window{};\n+\n+    GdkWMFunction initial_wmf;\n+    GdkWMFunction current_wmf;\n+\n+    GdkCursor* gdk_cursor{};\n+    GdkCursor* gdk_cursor_override{};\n+\n+    Observable<Size> minimum_size = Size{1, 1};\n+    Observable<Size> maximum_size = Size{G_MAXINT, G_MAXINT};\n+    Observable<Size> sys_min_size = Size{1, 1};\n+    Observable<bool> resizable{true};\n+    Observable<Point> view_position = Point{0, 0}; \/\/Default for non-titled windows\n+    Observable<Size> view_size = Size{-1, -1};\n+    Observable<Size> window_size = Size{-1, -1};\n+    Observable<Point> window_location = Point{-1, -1};\n+    Observable<Rectangle> window_extents = Rectangle{0, 0, 0, 0};\n+    bool needs_to_update_frame_extents{false};\n+    float gravity_x{0};\n+    float gravity_y{0};\n+    BoundsType width_type{BOUNDSTYPE_UNKNOWN};\n+    BoundsType height_type{BOUNDSTYPE_UNKNOWN};\n@@ -227,0 +280,1 @@\n+\n@@ -228,0 +282,12 @@\n+    WindowContext() = delete;\n+    WindowContext(jobject, WindowContext* _owner, long _screen,\n+                  WindowFrameType _frame_type, WindowType type, GdkWMFunction wmf);\n+\n+    GETTER(jobject, jwindow)\n+    GETTER(jobject, jview)\n+    GETTER(WindowFrameType, frame_type);\n+    GETTER(WindowType, window_type);\n+\n+    Size get_view_size();\n+    Point get_view_position();\n+\n@@ -230,1 +296,1 @@\n-    bool filterIME(GdkEvent *);\n+    bool filterIME(GdkEvent*);\n@@ -236,0 +302,1 @@\n+\n@@ -238,2 +305,1 @@\n-    jobject get_jwindow();\n-    jobject get_jview();\n+    XID get_native_window();\n@@ -241,2 +307,2 @@\n-    void add_child(WindowContextTop*);\n-    void remove_child(WindowContextTop*);\n+    void add_child(WindowContext*);\n+    void remove_child(WindowContext*);\n@@ -245,0 +311,1 @@\n+    bool is_iconified();\n@@ -246,0 +313,3 @@\n+    bool is_maximized();\n+    bool is_fullscreen();\n+    bool is_floating();\n@@ -248,1 +318,0 @@\n-    bool grab_mouse_drag_focus();\n@@ -250,1 +319,0 @@\n-    void ungrab_mouse_drag_focus();\n@@ -253,1 +321,0 @@\n-    void set_level(int) {}\n@@ -256,3 +323,1 @@\n-    void process_focus(GdkEventFocus*);\n-    void process_destroy();\n-    void process_delete();\n+    void process_map();\n@@ -260,2 +325,3 @@\n-    void process_mouse_button(GdkEventButton*, bool synthesized = false);\n-    void process_mouse_motion(GdkEventMotion*);\n+    void process_focus(GdkEventFocus*);\n+    virtual void process_mouse_button(GdkEventButton*, bool synthesized = false);\n+    virtual void process_mouse_motion(GdkEventMotion*);\n@@ -266,2 +332,4 @@\n-\n-    void notify_state(jint);\n+    void process_property_notify(GdkEventProperty*);\n+    void process_configure(GdkEventConfigure*);\n+    void process_delete();\n+    void process_destroy();\n@@ -272,1 +340,0 @@\n-    bool get_window_edge(int x, int y, GdkWindowEdge*);\n@@ -275,40 +342,0 @@\n-    ~WindowContextBase();\n-protected:\n-    virtual void applyShapeMask(void*, uint width, uint height) = 0;\n-};\n-\n-class WindowContextTop: public WindowContextBase {\n-    jlong screen;\n-    WindowFrameType frame_type;\n-    WindowType window_type;\n-    struct WindowContext *owner;\n-    WindowGeometry geometry;\n-    struct _Resizable {\/\/ we can't use set\/get gtk_window_resizable function\n-        _Resizable(): value(true),\n-                minw(-1), minh(-1), maxw(-1), maxh(-1), sysminw(-1), sysminh(-1) {}\n-        bool value; \/\/actual value of resizable for a window\n-        int minw, minh, maxw, maxh; \/\/minimum and maximum window width\/height;\n-        int sysminw, sysminh; \/\/ size of window button area of EXTENDED windows\n-    } resizable;\n-\n-    bool on_top;\n-    bool is_fullscreen;\n-\n-    static WindowFrameExtents normal_extents;\n-    static WindowFrameExtents utility_extents;\n-\n-    WindowManager wmanager;\n-public:\n-    WindowContextTop(jobject, WindowContext*, long, WindowFrameType, WindowType, GdkWMFunction);\n-\n-    void process_realize();\n-    void process_property_notify(GdkEventProperty*);\n-    void process_state(GdkEventWindowState*);\n-    void process_configure(GdkEventConfigure*);\n-    void process_destroy();\n-    void process_mouse_motion(GdkEventMotion*);\n-    void process_mouse_button(GdkEventButton*, bool synthesized = false);\n-    void work_around_compiz_state();\n-\n-    WindowGeometry get_geometry();\n-\n@@ -319,1 +346,0 @@\n-    bool is_resizable();\n@@ -325,1 +351,0 @@\n-    void set_system_minimum_size(int, int);\n@@ -331,1 +356,1 @@\n-    void set_modal(bool, WindowContext* parent = NULL);\n+    void set_modal(bool, WindowContext* parent = nullptr);\n@@ -333,2 +358,1 @@\n-    void set_visible(bool);\n-    void notify_on_top(bool);\n+    void set_owner(WindowContext*);\n@@ -336,3 +360,0 @@\n-    void notify_view_resize();\n-\n-    void show_system_menu(int x, int y);\n@@ -341,0 +362,2 @@\n+    void show_system_menu(int, int);\n+    void set_system_minimum_size(int, int);\n@@ -342,4 +365,1 @@\n-    void set_owner(WindowContext*);\n-\n-    GtkWindow *get_gtk_window();\n-    void detach_from_java();\n+    virtual ~WindowContext();\n@@ -347,2 +367,0 @@\n-protected:\n-    void applyShapeMask(void*, uint width, uint height);\n@@ -350,0 +368,17 @@\n+    GdkVisual* find_best_visual();\n+    void maximize(bool);\n+    void iconify(bool);\n+    void update_window_size();\n+    void move_resize(int, int, bool, bool, int, int);\n+    void add_wmf(GdkWMFunction);\n+    void remove_wmf(GdkWMFunction);\n+    void notify_on_top(bool);\n+    void notify_fullscreen(bool);\n+    void notify_window_resize(int);\n+    void notify_window_move();\n+    void notify_view_resize();\n+    void notify_view_move();\n+    void notify_current_sizes();\n+    void notify_repaint();\n+    void notify_repaint(Rectangle);\n+    GdkAtom get_net_frame_extents_atom();\n@@ -352,2 +387,2 @@\n-    void set_cached_extents(WindowFrameExtents ex);\n-    WindowFrameExtents get_cached_extents();\n+    void set_cached_extents(Rectangle);\n+    void load_cached_extents();\n@@ -359,5 +394,19 @@\n-    void notify_window_move();\n-    void notify_window_resize();\n-    bool get_window_edge(int x, int y, GdkWindowEdge*);\n-    WindowContextTop(WindowContextTop&);\n-    WindowContextTop& operator= (const WindowContextTop&);\n+\n+    void update_initial_state();\n+    bool grab_mouse_drag_focus();\n+    void ungrab_mouse_drag_focus();\n+};\n+\n+class WindowContextExtended : public WindowContext {\n+public:\n+    WindowContextExtended() = delete;\n+    WindowContextExtended(jobject jwin,\n+                          WindowContext* owner,\n+                          long screen,\n+                          GdkWMFunction wmf);\n+\n+    void process_mouse_button(GdkEventButton*, bool synthesized = false) override;\n+    void process_mouse_motion(GdkEventMotion*) override;\n+\n+private:\n+    bool get_window_edge(int, int, GdkWindowEdge*);\n@@ -382,0 +431,1 @@\n+                LOG(\"EventsCounterHelper: delete ctx\\n\");\n@@ -384,1 +434,1 @@\n-            ctx = NULL;\n+            ctx = nullptr;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window.h","additions":264,"deletions":214,"binary":false,"changes":478,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-void WindowContextBase::commitIME(gchar *str) {\n+void WindowContext::commitIME(gchar *str) {\n@@ -118,1 +118,1 @@\n-bool WindowContextBase::hasIME() {\n+bool WindowContext::hasIME() {\n@@ -122,1 +122,1 @@\n-bool WindowContextBase::filterIME(GdkEvent *event) {\n+bool WindowContext::filterIME(GdkEvent *event) {\n@@ -148,1 +148,1 @@\n-void WindowContextBase::setOnPreEdit(bool preedit) {\n+void WindowContext::setOnPreEdit(bool preedit) {\n@@ -152,1 +152,1 @@\n-void WindowContextBase::updateCaretPos() {\n+void WindowContext::updateCaretPos() {\n@@ -159,1 +159,1 @@\n-    nativePos = mainEnv->GetDoubleArrayElements(pos, NULL);\n+    nativePos = mainEnv->GetDoubleArrayElements(pos, nullptr);\n@@ -173,1 +173,1 @@\n-void WindowContextBase::enableOrResetIME() {\n+void WindowContext::enableOrResetIME() {\n@@ -199,2 +199,2 @@\n-void WindowContextBase::disableIME() {\n-    if (im_ctx.ctx != NULL) {\n+void WindowContext::disableIME() {\n+    if (im_ctx.ctx != nullptr) {\n@@ -202,1 +202,1 @@\n-        im_ctx.ctx = NULL;\n+        im_ctx.ctx = nullptr;\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_window_ime.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,705 @@\n+\/*\n+ * Copyright (c) 2025 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javafx.application.Application;\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.ReadOnlyBooleanProperty;\n+import javafx.beans.property.ReadOnlyDoubleProperty;\n+import javafx.beans.property.ReadOnlyProperty;\n+import javafx.beans.property.ReadOnlyStringProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.beans.property.StringProperty;\n+import javafx.beans.value.ChangeListener;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.event.Event;\n+import javafx.geometry.HPos;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Pos;\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.CheckBox;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.ContextMenu;\n+import javafx.scene.control.Control;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.ScrollPane;\n+import javafx.scene.control.Spinner;\n+import javafx.scene.control.SpinnerValueFactory;\n+import javafx.scene.control.TextField;\n+import javafx.scene.control.TitledPane;\n+import javafx.scene.control.Tooltip;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.BackgroundFill;\n+import javafx.scene.layout.CornerRadii;\n+import javafx.scene.layout.FlowPane;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.Priority;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.layout.HeaderBar;\n+import javafx.scene.layout.HeaderDragType;\n+import javafx.scene.paint.Color;\n+import javafx.scene.image.Image;\n+import javafx.stage.FileChooser;\n+import javafx.stage.Modality;\n+import javafx.stage.Screen;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.util.StringConverter;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.DoubleConsumer;\n+\n+public class TestStage extends Application {\n+    private final ObservableList<Stage> stages = FXCollections.observableArrayList();\n+    private int stageCounter = 0;\n+\n+    private final ComboBox<StageStyle> cbStageStyle =\n+            new ComboBox<>(FXCollections.observableArrayList(StageStyle.values()));\n+    private final ComboBox<Modality> cbModality = new ComboBox<>(FXCollections.observableArrayList(Modality.values()));\n+    private final ComboBox<Stage> cbOwner = new ComboBox<>();\n+\n+    private final Button btnToFront = new Button(\"To Front\");\n+    private final Button btnToBack = new Button(\"To Back\");\n+    private final Button btnCreate = new Button(\"Create\");\n+    private final Button btnCreateShow = new Button(\"Create\/Show\");\n+    private final Button btnSelectLast = new Button(\"Select Last\");\n+    private final Button btnSelectPrevious = new Button(\"\");\n+    private final Button btnSelectNone = new Button(\"None\");\n+    private final Button btnSelectNext = new Button(\"\");\n+    private final Button btnHide = new Button(\"Hide\/Close\");\n+    private final Button btnShow = new Button(\"Show\");\n+    private final Button btnSizeToScene = new Button(\"Size to Scene\");\n+    private final Button btnCenterOnScreen = new Button(\"Center on Screen\");\n+    private final Button btnFocus = new Button(\"Focus\");\n+    private final PropertyEditor propertyEditor = new PropertyEditor();\n+\n+    private final ObjectProperty<StageStyle> initStyle = new SimpleObjectProperty<>(StageStyle.DECORATED);\n+    private final ObjectProperty<Modality> initModality = new SimpleObjectProperty<>(Modality.NONE);\n+    private final ObjectProperty<Stage> initOwner = new SimpleObjectProperty<>(null);\n+    private Stage currentStage = null;\n+\n+    private static final double MAX_WIDTH = 7680;\n+    private static final double MAX_HEIGHT = 4320;\n+\n+    private void updateCommandButtonsState() {\n+        boolean disabled = stages.isEmpty() || currentStage == null;\n+\n+        btnShow.setDisable(disabled);\n+        btnHide.setDisable(disabled);\n+        btnSizeToScene.setDisable(disabled);\n+        btnCenterOnScreen.setDisable(disabled);\n+        btnToFront.setDisable(disabled);\n+        btnToBack.setDisable(disabled);\n+        btnFocus.setDisable(disabled);\n+        btnSelectNone.setDisable(disabled);\n+\n+        btnSelectLast.setDisable(stages.isEmpty() || currentStage == stages.getLast());\n+        btnSelectNext.setDisable(stages.isEmpty() || currentStage == null || currentStage == stages.getLast());\n+        btnSelectPrevious.setDisable(stages.isEmpty() || currentStage == null  || currentStage == stages.getFirst());\n+    }\n+\n+    private void updateBindings() {\n+        if (currentStage == null) {\n+            propertyEditor.unbind();\n+        } else {\n+            propertyEditor.bindToStage(currentStage);\n+        }\n+    }\n+\n+    private final CheckBox cbCommandAlwaysOnTop = new CheckBox(\"Command Always On Top\");\n+\n+    @Override\n+    public void start(Stage stage) {\n+        cbStageStyle.getSelectionModel().select(StageStyle.DECORATED);\n+        cbModality.getSelectionModel().select(Modality.NONE);\n+        cbOwner.itemsProperty().bind(Bindings.createObjectBinding(() -> {\n+            ObservableList<Stage> listWithNull = FXCollections.observableArrayList();\n+            listWithNull.add(null);\n+            listWithNull.addAll(stages);\n+            return listWithNull;\n+        }, stages));\n+\n+        cbOwner.setConverter(new StringConverter<>() {\n+            @Override\n+            public String toString(Stage stage) {\n+                if (stage == null) {\n+                    return \"None\";\n+                }\n+\n+                return stage.getTitle();\n+            }\n+\n+            @Override\n+            public Stage fromString(String string) {\n+                return null;\n+            }\n+        });\n+\n+        initStyle.bind(cbStageStyle.valueProperty());\n+        initModality.bind(cbModality.valueProperty());\n+        initOwner.bind(cbOwner.valueProperty());\n+\n+        btnToFront.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.toFront();\n+            }\n+        });\n+\n+        btnToBack.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.toBack();\n+            }\n+        });\n+\n+        btnCreate.setOnAction(e -> createTestStage());\n+\n+        btnCreateShow.setOnAction(e -> {\n+            createTestStage();\n+            currentStage.show();\n+        });\n+\n+        btnSelectNone.setOnAction(e -> {\n+            currentStage = null;\n+            updateBindings();\n+            updateCommandButtonsState();\n+        });\n+\n+        btnSelectLast.setOnAction(e -> {\n+            currentStage = stages.get(stages.size() - 1);\n+            updateBindings();\n+            updateCommandButtonsState();\n+        });\n+\n+        btnSelectNext.setOnAction(e -> {\n+            if (!stages.isEmpty()) {\n+                int index = stages.indexOf(currentStage);\n+                if (index < stages.size() - 1) {\n+                    currentStage = stages.get(index + 1);\n+                    updateBindings();\n+                    updateCommandButtonsState();\n+                }\n+            }\n+        });\n+\n+        btnSelectPrevious.setOnAction(e -> {\n+            if (!stages.isEmpty()) {\n+                int index = stages.indexOf(currentStage);\n+                if (index > 0) {\n+                    currentStage = stages.get(index - 1);\n+                    updateBindings();\n+                    updateCommandButtonsState();\n+                }\n+            }\n+        });\n+\n+        btnHide.setOnAction(e -> {\n+            if (currentStage != null) {\n+                boolean isShowing = currentStage.isShowing();\n+                currentStage.hide();\n+\n+                if (!isShowing) {\n+                    stages.remove(currentStage);\n+                    currentStage = stages.isEmpty() ? null : stages.getLast();\n+                    updateCommandButtonsState();\n+                    updateBindings();\n+                }\n+            }\n+        });\n+\n+        btnShow.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.show();\n+            }\n+        });\n+\n+        btnSizeToScene.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.sizeToScene();\n+            }\n+        });\n+\n+        btnCenterOnScreen.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.centerOnScreen();\n+            }\n+        });\n+\n+        btnFocus.setOnAction(e -> {\n+            if (currentStage != null) {\n+                currentStage.requestFocus();\n+            }\n+        });\n+\n+        updateCommandButtonsState();\n+\n+        FlowPane flow0 = new FlowPane(label(\"Style: \", cbStageStyle), label(\"Modality: \", cbModality),\n+                label(\"Owner: \", cbOwner));\n+        FlowPane flow1 = new FlowPane(btnCreate, btnShow, btnCreateShow, btnHide);\n+        FlowPane flow2 = new FlowPane(btnCenterOnScreen, btnSizeToScene);\n+        FlowPane flow3 = new FlowPane(btnToFront, btnToBack, btnSelectNone, btnSelectLast, btnSelectPrevious,\n+                btnSelectNext, btnFocus);\n+\n+        List.of(flow0, flow1, flow2, flow3).forEach(flow -> {\n+            flow.setHgap(5);\n+            flow.setVgap(5);\n+        });\n+\n+        VBox commandPane = new VBox(cbCommandAlwaysOnTop, flow0, flow1, flow2, flow3);\n+        commandPane.setSpacing(5);\n+        commandPane.setFillWidth(true);\n+\n+        TitledPane commandPaneTitledPane = new TitledPane(\"Commands\", commandPane);\n+        commandPaneTitledPane.setCollapsible(false);\n+\n+        TitledPane editorTitledPane = new TitledPane(\"Properties\", propertyEditor);\n+        editorTitledPane.setCollapsible(false);\n+\n+        VBox root = new VBox(\n+                commandPaneTitledPane,\n+                editorTitledPane\n+        );\n+        root.setSpacing(5);\n+        root.setFillWidth(true);\n+\n+\n+        Scene scene = new Scene(root);\n+        stage.setTitle(\"Command Stage\");\n+        stage.setScene(scene);\n+        stage.setOnShown(e -> {\n+            Rectangle2D stageBounds = new Rectangle2D(\n+                    stage.getX(),\n+                    stage.getY(),\n+                    stage.getWidth(),\n+                    stage.getHeight()\n+            );\n+\n+            Screen currentScreen = Screen.getScreens()\n+                    .stream()\n+                    .filter(screen -> screen.getVisualBounds().intersects(stageBounds))\n+                    .findFirst()\n+                    .orElse(Screen.getPrimary());\n+\n+            Rectangle2D visualBounds = currentScreen.getVisualBounds();\n+            stage.setHeight(visualBounds.getHeight());\n+\n+            double x = visualBounds.getMaxX() - stage.getWidth();\n+            double y = visualBounds.getMaxY() - stage.getHeight();\n+\n+            stage.setX(x);\n+            stage.setY(y);\n+        });\n+        stage.setWidth(500);\n+        stage.show();\n+    }\n+\n+    private HBox label(String label, Control control) {\n+        HBox hbox = new HBox(new Label(label), control);\n+        hbox.setSpacing(5);\n+        hbox.setAlignment(Pos.CENTER_LEFT);\n+        return hbox;\n+    }\n+\n+    private void createTestStage() {\n+        Stage newStage = new Stage();\n+\n+        stageCounter++;\n+\n+        newStage.initStyle(initStyle.getValue());\n+        newStage.initModality(initModality.getValue());\n+        newStage.initOwner(initOwner.getValue());\n+        newStage.setTitle(\"Test Stage \" + stageCounter);\n+\n+        newStage.focusedProperty().addListener((obs, oldVal, newVal) -> {\n+            if (newVal) {\n+                currentStage = newStage;\n+                updateBindings();\n+                updateCommandButtonsState();\n+            }\n+        });\n+\n+        stages.add(newStage);\n+        currentStage = newStage;\n+        createDefaultScene();\n+\n+        newStage.setOnHidden(e -> {\n+            stages.remove(newStage);\n+            if (currentStage == newStage) {\n+                currentStage = stages.isEmpty() ? null : stages.getLast();\n+                updateBindings();\n+            }\n+            updateCommandButtonsState();\n+        });\n+\n+        updateBindings();\n+        updateCommandButtonsState();\n+    }\n+\n+    public static void main(String[] args) {\n+        launch(TestStage.class, args);\n+    }\n+\n+    private Label createLabel(String prefix, ReadOnlyProperty<?> property) {\n+        Label label = new Label();\n+        label.textProperty().bind(Bindings.concat(prefix, Bindings.convert(property)));\n+        return label;\n+    }\n+\n+    private void createDefaultScene() {\n+        Scene scene;\n+\n+        StringProperty lastEvent = new SimpleStringProperty();\n+\n+        Label ownerLabel = new Label(\"Owner: NONE\");\n+        if (currentStage.getOwner() instanceof Stage owner) {\n+            ownerLabel.setText(\"Owner: \" + owner.getTitle());\n+        }\n+\n+        VBox root = new VBox();\n+        if (currentStage.getStyle() == StageStyle.EXTENDED) {\n+            HeaderBar headerbar = new HeaderBar();\n+            Label headerLabel = new Label();\n+            var headerPane = new StackPane(headerLabel);\n+            headerLabel.textProperty().bind(currentStage.titleProperty());\n+            headerbar.setCenter(headerPane);\n+            headerbar.setDragType(headerPane, HeaderDragType.DRAGGABLE_SUBTREE);\n+            root.getChildren().add(headerbar);\n+        }\n+\n+        root.getChildren().addAll(createLabel(\"Focused: \", currentStage.focusedProperty()),\n+                            new Label(\"Modality: \" + currentStage.getModality()),\n+                            ownerLabel,\n+                            createLabel(\"Last Event: \", lastEvent));\n+        root.setBackground(Background.EMPTY);\n+\n+        if (currentStage.getStyle() == StageStyle.TRANSPARENT) {\n+            BackgroundFill fill = new BackgroundFill(\n+                    Color.HOTPINK.deriveColor(0, 1, 1, 0.5),\n+                    CornerRadii.EMPTY,\n+                    Insets.EMPTY\n+            );\n+            root.setBackground(new Background(fill));\n+\n+            scene = new Scene(root, 300, 300);\n+            scene.setFill(Color.TRANSPARENT);\n+        } else {\n+            scene = new Scene(root, 300, 300, Color.HOTPINK);\n+        }\n+\n+        currentStage.addEventHandler(Event.ANY, e -> lastEvent.set(e.getEventType().getName()));\n+        setupContextMenu(root);\n+        currentStage.setScene(scene);\n+    }\n+\n+    private void createSceneWithTextField() {\n+        StackPane root = new StackPane();\n+\n+        TextField textField = new TextField();\n+        textField.setPromptText(\"Enter text here\");\n+\n+        root.getChildren().add(textField);\n+        setupContextMenu(root);\n+        Scene scene = new Scene(root, 300, 200);\n+\n+        currentStage.setScene(scene);\n+    }\n+\n+    private void createSceneWithTooltipBox() {\n+        StackPane root = new StackPane();\n+\n+        StackPane coloredBox = new StackPane();\n+        coloredBox.setBackground(Background.fill(Color.CORNFLOWERBLUE));\n+\n+        Tooltip tooltip = new Tooltip(\"The quick brown fox jumps over the lazy dog.\");\n+        Tooltip.install(coloredBox, tooltip);\n+        root.getChildren().add(coloredBox);\n+        setupContextMenu(root);\n+        Scene scene = new Scene(root, 300, 200);\n+        currentStage.setScene(scene);\n+    }\n+\n+    private void createAlert(boolean windowModal) {\n+        Alert alert = new Alert(Alert.AlertType.INFORMATION);\n+        alert.setTitle(\"Alert\");\n+        alert.setHeaderText(\"The quick brown fox jumps over the lazy dog.\");\n+\n+        if (windowModal) {\n+            alert.initModality(Modality.WINDOW_MODAL);\n+            alert.initOwner(currentStage);\n+        }\n+\n+        alert.showAndWait();\n+    }\n+\n+    private void createFileOpen() {\n+        FileChooser fileChooser = new FileChooser();\n+        fileChooser.setTitle(\"Open Resource File\");\n+        fileChooser.getExtensionFilters().addAll(\n+                new FileChooser.ExtensionFilter(\"All Files\", \"*.*\")\n+        );\n+        File file = fileChooser.showOpenDialog(currentStage);\n+\n+        if (file != null) {\n+            new Alert(Alert.AlertType.INFORMATION, \"File selected: \" + file.getAbsolutePath()).showAndWait();\n+        } else {\n+            new Alert(Alert.AlertType.WARNING, \"No file selected\").showAndWait();\n+        }\n+    }\n+\n+    private void setStageIcon() {\n+        FileChooser fileChooser = new FileChooser();\n+        fileChooser.setTitle(\"Choose Icon Image\");\n+        fileChooser.getExtensionFilters().addAll(\n+                new FileChooser.ExtensionFilter(\"Image Files\", \"*.png\", \"*.jpg\", \"*.jpeg\", \"*.gif\")\n+        );\n+\n+        File file = fileChooser.showOpenDialog(currentStage);\n+        if (file != null) {\n+            Image icon = new Image(file.toURI().toString());\n+            currentStage.getIcons().clear();\n+            currentStage.getIcons().add(icon);\n+        }\n+    }\n+\n+    private void setupContextMenu(Node root) {\n+        ContextMenu contextMenu = new ContextMenu();\n+\n+        MenuItem defaultSceneMenuItem = new MenuItem(\"Default Scene\");\n+        defaultSceneMenuItem.setOnAction(e -> createDefaultScene());\n+        MenuItem textFieldMenuItem = new MenuItem(\"Scene with TextField\");\n+        textFieldMenuItem.setOnAction(e -> createSceneWithTextField());\n+        MenuItem tooltipBoxMenuItem = new MenuItem(\"Scene with Tooltip Box\");\n+        tooltipBoxMenuItem.setOnAction(e -> createSceneWithTooltipBox());\n+        MenuItem alertMenuItem = new MenuItem(\"Alert - Application Modal\");\n+        alertMenuItem.setOnAction(e -> createAlert(false));\n+        MenuItem alertWindowModalMenuItem = new MenuItem(\"Alert - Window Modal\");\n+        alertWindowModalMenuItem.setOnAction(e -> createAlert(true));\n+        MenuItem fileOpenMenuItem = new MenuItem(\"File Open\");\n+        fileOpenMenuItem.setOnAction(e -> createFileOpen());\n+        MenuItem iconMenuItem = new MenuItem(\"Set Stage Icon\");\n+        iconMenuItem.setOnAction(e -> setStageIcon());\n+\n+        contextMenu.getItems().addAll(defaultSceneMenuItem, textFieldMenuItem, tooltipBoxMenuItem,\n+                alertMenuItem, alertWindowModalMenuItem, fileOpenMenuItem, iconMenuItem);\n+        root.setOnContextMenuRequested(e -> contextMenu.show(root, e.getScreenX(), e.getScreenY()));\n+\n+        root.setOnMousePressed(e -> {\n+            if (contextMenu.isShowing()) {\n+                contextMenu.hide();\n+            }\n+        });\n+    }\n+\n+    class PropertyEditor extends VBox {\n+        private final PropertyEditorPane stagePane = new PropertyEditorPane(\"Stage\");\n+        private final PropertyEditorPane scenePane = new PropertyEditorPane(\"Scene\");\n+\n+        private final ObjectProperty<Scene> sceneProperty = new SimpleObjectProperty<>();\n+\n+        PropertyEditor() {\n+            getChildren().addAll(stagePane, scenePane);\n+            stagePane.setMaxHeight(550);\n+            setFillWidth(true);\n+        }\n+\n+        public void bindToStage(Stage stage) {\n+            unbind();\n+\n+            stagePane.addStringProperty(\"Title\", stage.titleProperty(), stage::setTitle);\n+            stagePane.addBooleanProperty(\"Always OnTop\", stage.alwaysOnTopProperty(), stage::setAlwaysOnTop);\n+            stagePane.addBooleanProperty(\"FullScreen\", stage.fullScreenProperty(), stage::setFullScreen);\n+            stagePane.addBooleanProperty(\"Maximized\", stage.maximizedProperty(), stage::setMaximized);\n+            stagePane.addBooleanProperty(\"Iconified\", stage.iconifiedProperty(), stage::setIconified);\n+            stagePane.addBooleanProperty(\"Resizeable\", stage.resizableProperty(), stage::setResizable);\n+            stagePane.addBooleanProperty(\"Focused\", stage.focusedProperty(), null);\n+            stagePane.addDoublePropery(\"X\", stage.xProperty(), stage::setX, 0, MAX_WIDTH * 2, 1.0);\n+            stagePane.addDoublePropery(\"Y\", stage.yProperty(), stage::setY, 0, MAX_HEIGHT * 2, 1.0);\n+            stagePane.addDoublePropery(\"Width\", stage.widthProperty(), stage::setWidth, 1, MAX_WIDTH, 1.0);\n+            stagePane.addDoublePropery(\"Height\", stage.heightProperty(), stage::setHeight, 1, MAX_HEIGHT, 1.0);\n+            stagePane.addDoublePropery(\"Min Width\", stage.minWidthProperty(), stage::setMinWidth, 1, MAX_WIDTH, 1.0);\n+            stagePane.addDoublePropery(\"Min Height\", stage.minHeightProperty(), stage::setMinHeight, 1, MAX_HEIGHT,\n+                    1.0);\n+            stagePane.addDoublePropery(\"Max Width\", stage.maxWidthProperty(), stage::setMaxWidth, 1, Double.MAX_VALUE,\n+                    1.0);\n+            stagePane.addDoublePropery(\"Max Height\", stage.maxHeightProperty(), stage::setMaxHeight, 1,\n+                    Double.MAX_VALUE, 1.0);\n+            stagePane.addDoublePropery(\"RenderScale X\", stage.renderScaleXProperty(), stage::setRenderScaleX, 0, 2,\n+                    0.25);\n+            stagePane.addDoublePropery(\"RenderScale Y\", stage.renderScaleYProperty(), stage::setRenderScaleY, 0, 2,\n+                    0.25);\n+            stagePane.addDoublePropery(\"Opacity\", stage.opacityProperty(), stage::setOpacity, 0, 1, 0.1);\n+\n+            sceneProperty.bind(stage.sceneProperty());\n+            bindScene(stage.getScene());\n+\n+            sceneProperty.addListener((obs, oldScene, newScene) -> {\n+                if (newScene != null) {\n+                    bindScene(newScene);\n+                }\n+            });\n+        }\n+\n+        private void bindScene(Scene scene) {\n+            scenePane.unbind();\n+            scenePane.addDoubleLabelProperty(\"X\", scene.xProperty());\n+            scenePane.addDoubleLabelProperty(\"Y\", scene.yProperty());\n+            scenePane.addDoubleLabelProperty(\"Width\", scene.widthProperty());\n+            scenePane.addDoubleLabelProperty(\"Height\", scene.heightProperty());\n+        }\n+\n+        public void unbind() {\n+            scenePane.unbind();\n+            stagePane.unbind();\n+        }\n+    }\n+\n+    class PropertyEditorPane extends TitledPane {\n+        private int currentRow = 0;\n+        private final List<Runnable> clearChangeListeners = new ArrayList<>();\n+        private final GridPane gridPane = new GridPane();\n+\n+        PropertyEditorPane(String title) {\n+            setText(title);\n+            ScrollPane propertiesScrollPane = new ScrollPane(propertyEditor);\n+            propertiesScrollPane.setFitToWidth(true);\n+            propertiesScrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);\n+            propertiesScrollPane.setContent(gridPane);\n+\n+            gridPane.setHgap(5);\n+            gridPane.setVgap(5);\n+            gridPane.setPadding(new Insets(10));\n+\n+            setContent(propertiesScrollPane);\n+        }\n+\n+        private <T> void addListener(ReadOnlyProperty<T> property, ChangeListener<T> changeListener) {\n+            property.addListener(changeListener);\n+            clearChangeListeners.add(() -> property.removeListener(changeListener));\n+        }\n+\n+        private void addLabel(String label) {\n+            Label lbl = new Label(label);\n+            gridPane.add(lbl, 0, currentRow);\n+            GridPane.setHgrow(lbl, Priority.SOMETIMES);\n+            GridPane.setHalignment(lbl, HPos.RIGHT);\n+        }\n+\n+        public void addDoubleLabelProperty(String label, ReadOnlyDoubleProperty property) {\n+            addLabel(label);\n+            Label lbl = new Label();\n+            lbl.textProperty().bind(property.asString(\"%.2f\"));\n+            gridPane.add(lbl, 1, currentRow);\n+            GridPane.setHgrow(lbl, Priority.ALWAYS);\n+            currentRow++;\n+        }\n+\n+        public void addDoublePropery(String label, ReadOnlyDoubleProperty property, DoubleConsumer setConsumer,\n+                                      double min, double max,\n+                                      double amountToStepBy) {\n+            addLabel(label);\n+            Spinner<Double> spinner = new Spinner<>();\n+            spinner.setEditable(true);\n+            SpinnerValueFactory.DoubleSpinnerValueFactory spinnerValueFactory =\n+                    new SpinnerValueFactory.DoubleSpinnerValueFactory(min, max, property.get(), amountToStepBy);\n+            spinner.setValueFactory(spinnerValueFactory);\n+            gridPane.add(spinner, 1, currentRow);\n+            GridPane.setHgrow(spinner, Priority.ALWAYS);\n+\n+            AtomicBoolean suppressListener = new AtomicBoolean(false);\n+            addListener(property, (obs, oldValue, newValue) -> {\n+                if (!newValue.equals(spinner.getValue())) {\n+                    try {\n+                        suppressListener.set(true);\n+                        spinnerValueFactory.setValue((Double) newValue);\n+                    } finally {\n+                        suppressListener.set(false);\n+                    }\n+                }\n+            });\n+\n+            if (setConsumer != null) {\n+                spinner.valueProperty().addListener((observable, oldValue, newValue) -> {\n+                    if (!newValue.equals(oldValue) && !suppressListener.get()) {\n+                        setConsumer.accept(newValue);\n+                    }\n+                });\n+            } else {\n+                spinner.setDisable(true);\n+            }\n+\n+            currentRow++;\n+        }\n+\n+        public void addStringProperty(String label, ReadOnlyStringProperty property, Consumer<String> setConsumer) {\n+            addLabel(label);\n+            TextField textField = new TextField(property.get());\n+            gridPane.add(textField, 1, currentRow);\n+            GridPane.setHgrow(textField, Priority.ALWAYS);\n+\n+            addListener(property, (obs, oldValue, newValue) -> textField.setText(newValue));\n+\n+            if (setConsumer != null) {\n+                textField.setOnAction(e -> setConsumer.accept(textField.getText()));\n+            } else {\n+                textField.setDisable(true);\n+            }\n+            currentRow++;\n+        }\n+\n+        public void addBooleanProperty(String label, ReadOnlyBooleanProperty property, Consumer<Boolean> setConsumer) {\n+            addLabel(label);\n+            CheckBox checkBox = new CheckBox();\n+            checkBox.setSelected(property.get());\n+            gridPane.add(checkBox, 1, currentRow);\n+\n+            addListener(property, (obs, oldValue, newValue) -> checkBox.setSelected(newValue));\n+\n+            if (setConsumer != null) {\n+                checkBox.setOnAction(e -> setConsumer.accept(checkBox.isSelected()));\n+            } else {\n+                checkBox.setDisable(true);\n+            }\n+            currentRow++;\n+        }\n+\n+        public void unbind() {\n+            clearChangeListeners.forEach(Runnable::run);\n+            gridPane.getChildren().clear();\n+            currentRow = 0;\n+        }\n+    }\n+}\n","filename":"tests\/manual\/stage\/TestStage.java","additions":705,"deletions":0,"binary":false,"changes":705,"status":"added"},{"patch":"@@ -27,3 +27,0 @@\n-import static org.junit.jupiter.api.Assumptions.assumeTrue;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n@@ -41,1 +38,0 @@\n-import com.sun.javafx.PlatformUtil;\n@@ -44,0 +40,3 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n@@ -93,3 +92,0 @@\n-        \/\/ Disable on Linux until JDK-8353556 is fixed\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/RestoreSceneSizeTest.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.stage;\n+\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.util.Util;\n+\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+\n+class FullScreenTest extends StageTestBase {\n+    private static final int POS_X = 100;\n+    private static final int POS_Y = 150;\n+    private static final int WIDTH = 200;\n+    private static final int HEIGHT = 250;\n+\n+    private static final Consumer<Stage> TEST_SETTINGS = s -> {\n+        s.setWidth(WIDTH);\n+        s.setHeight(HEIGHT);\n+        s.setX(POS_X);\n+        s.setY(POS_Y);\n+    };\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"TRANSPARENT\"})\n+    void fullScreenShouldKeepGeometryOnRestore(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS);\n+\n+        Util.doTimeLine(LONG_WAIT,\n+                () -> getStage().setFullScreen(true),\n+                () -> assertTrue(getStage().isFullScreen()),\n+                () -> getStage().setFullScreen(false));\n+\n+        Util.sleep(LONG_WAIT);\n+        assertSizePosition();\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"TRANSPARENT\"})\n+    void fullScreenBeforeShowShouldKeepGeometryOnRestore(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS.andThen(s -> s.setFullScreen(true)));\n+\n+        Util.sleep(LONG_WAIT);\n+        Util.runAndWait(() -> {\n+            assertTrue(getStage().isFullScreen());\n+            getStage().setFullScreen(false);\n+        });\n+\n+        Util.sleep(LONG_WAIT);\n+        assertSizePosition();\n+    }\n+\n+    private void assertSizePosition() {\n+        assertEquals(WIDTH, getStage().getWidth(), SIZING_DELTA, \"Stage's width should have remained\");\n+        assertEquals(HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Stage's height should have remained\");\n+        assertEquals(POS_X, getStage().getX(), POSITION_DELTA,  \"Stage's X position should have remained\");\n+        assertEquals(POS_Y, getStage().getY(), POSITION_DELTA, \"Stage's Y position should have remained\");\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/FullScreenTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.stage;\n+\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.util.Util;\n+\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+\n+class MaximizeTest extends StageTestBase {\n+    private static final int WIDTH = 300;\n+    private static final int HEIGHT = 300;\n+    private static final int POS_X = 100;\n+    private static final int POS_Y = 150;\n+\n+    private static final Consumer<Stage> TEST_SETTINGS = s -> {\n+        s.setWidth(WIDTH);\n+        s.setHeight(HEIGHT);\n+        s.setX(POS_X);\n+        s.setY(POS_Y);\n+    };\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"UNDECORATED\", \"EXTENDED\", \"TRANSPARENT\"})\n+    void maximizeUndecorated(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS);\n+\n+        Util.doTimeLine(MEDIUM_WAIT,\n+                () -> getStage().setMaximized(true),\n+                () ->  {\n+                    assertTrue(getStage().isMaximized());\n+                    assertNotEquals(POS_X, getStage().getX());\n+                    assertNotEquals(POS_Y, getStage().getY());\n+                },\n+                () -> getStage().setMaximized(false));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(POS_X, getStage().getX(), POSITION_DELTA, \"Stage maximized position changed\");\n+        assertEquals(POS_Y, getStage().getY(), POSITION_DELTA, \"Stage maximized position changed\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"TRANSPARENT\"})\n+    void maximizeShouldKeepGeometryOnRestore(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS);\n+\n+        Util.doTimeLine(MEDIUM_WAIT,\n+                () -> getStage().setMaximized(true),\n+                () -> assertTrue(getStage().isMaximized()),\n+                () -> getStage().setMaximized(false));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+        assertSizePosition();\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"TRANSPARENT\"})\n+    void maximizeBeforeShowShouldKeepGeometryOnRestore(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, TEST_SETTINGS.andThen(s -> s.setMaximized(true)));\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            assertTrue(getStage().isMaximized());\n+            getStage().setMaximized(false);\n+        });\n+        Util.sleep(MEDIUM_WAIT);\n+        assertSizePosition();\n+    }\n+\n+    private void assertSizePosition() {\n+        assertEquals(WIDTH, getStage().getWidth(), SIZING_DELTA, \"Stage's width should have remained\");\n+        assertEquals(HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Stage's height should have remained\");\n+        assertEquals(POS_X, getStage().getX(), POSITION_DELTA, \"Stage's X position should have remained\");\n+        assertEquals(POS_Y, getStage().getY(), POSITION_DELTA, \"Stage's Y position should have remained\");\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/MaximizeTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package test.javafx.stage;\n-\n-import java.util.concurrent.CountDownLatch;\n-import javafx.application.Application;\n-import javafx.application.Platform;\n-import javafx.scene.Group;\n-import javafx.scene.Scene;\n-import javafx.stage.Stage;\n-import javafx.stage.StageStyle;\n-import javafx.stage.WindowEvent;\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.Test;\n-import test.util.Util;\n-\n-public class MaximizeUndecorated {\n-    static CountDownLatch startupLatch = new CountDownLatch(1);\n-    static Stage stage;\n-    static final int POS = 500;\n-\n-    public static class TestApp extends Application {\n-        @Override\n-        public void start(Stage primaryStage) throws Exception {\n-            primaryStage.setScene(new Scene(new Group()));\n-            stage = primaryStage;\n-            stage.addEventHandler(WindowEvent.WINDOW_SHOWN, e ->\n-                    Platform.runLater(startupLatch::countDown));\n-            stage.initStyle(StageStyle.UNDECORATED);\n-            stage.setX(POS);\n-            stage.setY(POS);\n-            stage.setOnShown(e -> stage.setMaximized(true));\n-            stage.show();\n-        }\n-    }\n-\n-    @BeforeAll\n-    public static void initFX() {\n-        Util.launch(startupLatch, TestApp.class);\n-    }\n-\n-    @AfterAll\n-    public static void teardown() {\n-        Util.shutdown();\n-    }\n-\n-    @Test\n-    public void testMaximize() throws Exception {\n-        Util.sleep(200);\n-\n-        boolean movedToTopCorner = stage.getY() != POS && stage.getX() != POS;\n-        Assertions.assertTrue(movedToTopCorner, \"Stage has moved to desktop top corner\");\n-    }\n-}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/MaximizeUndecorated.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -123,1 +123,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -135,1 +134,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -147,1 +145,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -159,1 +156,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -171,1 +167,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -184,1 +179,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -197,1 +191,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n@@ -210,1 +203,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8353612\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/SizeToSceneTest.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,315 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.stage;\n+\n+import com.sun.javafx.PlatformUtil;\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.ReadOnlyDoubleProperty;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.Region;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.layout.VBox;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.util.Util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+\n+class SizingTest extends StageTestBase {\n+    private static final int WIDTH = 300;\n+    private static final int HEIGHT = 300;\n+    private static final int MAX_WIDTH = 350;\n+    private static final int MAX_HEIGHT = 350;\n+    private static final int MIN_WIDTH = 500;\n+    private static final int MIN_HEIGHT = 500;\n+    private static final int NEW_WIDTH = 450;\n+    private static final int NEW_HEIGHT = 450;\n+\n+    protected Label createLabel(String prefix, ReadOnlyDoubleProperty property) {\n+        Label label = new Label();\n+        label.textProperty().bind(Bindings.concat(prefix, Bindings.convert(property)));\n+        return label;\n+    }\n+\n+    @Override\n+    protected Region createRoot() {\n+        VBox vBox = new VBox(createLabel(\"Width: \", getStage().widthProperty()),\n+                createLabel(\"Height: \", getStage().heightProperty()),\n+                createLabel(\"Max Width: \", getStage().maxWidthProperty()),\n+                createLabel(\"Max Height: \", getStage().maxHeightProperty()),\n+                createLabel(\"Min Width: \", getStage().minWidthProperty()),\n+                createLabel(\"Min Height: \", getStage().minHeightProperty()));\n+        vBox.setBackground(Background.EMPTY);\n+\n+        return vBox;\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void maxSize(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.setMaxWidth(MAX_WIDTH);\n+            s.setMaxHeight(MAX_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(MAX_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been limited to max width\");\n+        assertEquals(MAX_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been limited to max height\");\n+\n+        \/\/ Reset it\n+        Util.runAndWait(() -> {\n+            getStage().setMaxWidth(Double.MAX_VALUE);\n+            getStage().setMaxHeight(Double.MAX_VALUE);\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been accepted after removing min width\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been accepted after removing min height\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void maxWidth(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.initStyle(stageStyle);\n+            s.setMaxWidth(MAX_WIDTH);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(MAX_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been limited to max width\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Only max width should be limited\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void maxHeight(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> s.setMaxHeight(MAX_HEIGHT));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA, \"Only max height should be limited\");\n+        assertEquals(MAX_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been limited to max height\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void minSize(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> {\n+            s.setMinWidth(MIN_WIDTH);\n+            s.setMinHeight(MIN_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(MIN_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been limited to min width\");\n+        assertEquals(MIN_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been limited to min height\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void minWidth(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> s.setMinWidth(MIN_WIDTH));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(MIN_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Stage width should have been limited to min width\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Only min width should be limited\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void minHeight(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> s.setMinHeight(MIN_HEIGHT));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA, \"Only min height should be limited\");\n+        assertEquals(MIN_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Stage height should have been limited to min height\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void noSize(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, null);\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertTrue(getStage().getWidth() > 1, \"Stage width should be greater than 1\");\n+        assertTrue(getStage().getHeight() > 1, \"Stage height should be greater than 1\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void noHeight(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> s.setWidth(WIDTH));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(WIDTH, getStage().getWidth(), SIZING_DELTA, \"Stage do not match the set width\");\n+        assertTrue(getStage().getHeight() > 1, \"Stage height should be greater than 1\");\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"TRANSPARENT\", \"UTILITY\"})\n+    void noWidth(StageStyle stageStyle) {\n+        setupStageWithStyle(stageStyle, s -> s.setHeight(HEIGHT));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertTrue(getStage().getWidth() > 1, \"Stage width should be greater than 1\");\n+        assertEquals(HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Stage do not match the set height\");\n+    }\n+\n+    @Test\n+    void sceneSizeOnly() {\n+        setupStageWithStyle(StageStyle.DECORATED, s -> s.setScene(new Scene(new StackPane(), WIDTH, HEIGHT)));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(WIDTH, getScene().getWidth(), SIZING_DELTA,\n+                \"Scene width should not be affected by decoration if stage width not set\");\n+        assertEquals(HEIGHT, getScene().getHeight(), SIZING_DELTA,\n+                \"Scene height should not be affected by decoration if stage height not set\");\n+    }\n+\n+    @Test\n+    void sceneWidthWithWindowHeight() {\n+        setupStageWithStyle(StageStyle.DECORATED, s -> {\n+            s.setScene(new Scene(new StackPane(), WIDTH, HEIGHT));\n+            s.setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(WIDTH, getScene().getWidth(),\n+                \"Scene width should not be affected by decoration if stage width not set\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA, \"Stage height should match the new height\");\n+    }\n+\n+    @Test\n+    void sceneHeightWithWindowWidth() {\n+        setupStageWithStyle(StageStyle.DECORATED, s -> {\n+            s.setScene(new Scene(new StackPane(), WIDTH, HEIGHT));\n+            s.setWidth(NEW_WIDTH);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA, \"Stage with should match the set new width\");\n+        assertEquals(HEIGHT, getScene().getHeight(),\n+                \"Scene height should not be affected by decoration if stage height not set\");\n+    }\n+\n+    @Test\n+    void sceneSizeThenStageSize() {\n+        setupStageWithStyle(StageStyle.DECORATED, s -> s.setScene(new Scene(new StackPane(), WIDTH, HEIGHT)));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        Util.runAndWait(() -> {\n+            getStage().setWidth(NEW_WIDTH);\n+            getStage().setHeight(NEW_HEIGHT);\n+        });\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Scene width should match the new stage width\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Scene height should match the new stage height\");\n+\n+        Util.runAndWait(() -> getStage().setScene(new Scene(new StackPane(), WIDTH, HEIGHT)));\n+\n+        Util.sleep(MEDIUM_WAIT);\n+\n+        assertEquals(NEW_WIDTH, getStage().getWidth(), SIZING_DELTA,\n+                \"Scene width should remain unchanged after setting a new scene\");\n+        assertEquals(NEW_HEIGHT, getStage().getHeight(), SIZING_DELTA,\n+                \"Scene height should remain unchanged after setting a new scene\");\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/SizingTest.java","additions":315,"deletions":0,"binary":false,"changes":315,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.stage;\n+\n+import javafx.application.Platform;\n+import javafx.geometry.Insets;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.BackgroundFill;\n+import javafx.scene.layout.CornerRadii;\n+import javafx.scene.layout.Region;\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import test.util.Util;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.function.Consumer;\n+\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+abstract class StageTestBase {\n+    private static final CountDownLatch startupLatch = new CountDownLatch(1);\n+    private Stage stage = null;\n+\n+    protected static final int SHORT_WAIT = 300;\n+    protected static final int MEDIUM_WAIT = 500;\n+    protected static final int LONG_WAIT = 1000;\n+    protected static final double SIZING_DELTA = 1.0;\n+    protected static final double POSITION_DELTA = 1.0;\n+\n+    \/**\n+     * Creates a Scene for the test stage acoording to the {@link StageStyle}\n+     * @param stageStyle {@link StageStyle} of the Stage\n+     * @return a {@link Scene}\n+     *\/\n+    protected Scene createScene(StageStyle stageStyle) {\n+        if (stageStyle == StageStyle.TRANSPARENT) {\n+            Region root = createRoot();\n+            BackgroundFill fill = new BackgroundFill(\n+                    Color.HOTPINK.deriveColor(0, 1, 1, 0.5),\n+                    CornerRadii.EMPTY,\n+                    Insets.EMPTY\n+            );\n+            root.setBackground(new Background(fill));\n+\n+            Scene scene = new Scene(root);\n+            scene.setFill(Color.TRANSPARENT);\n+\n+            return scene;\n+        }\n+\n+        return new Scene(createRoot(), Color.HOTPINK);\n+    }\n+\n+    \/**\n+     * Gets the Scene root\n+     *\/\n+    protected Region createRoot() {\n+        return new StackPane();\n+    }\n+\n+    \/**\n+     * Utility method to setup test Stages according to {@link StageStyle}\n+     * @param stageStyle The Stage Style.\n+     * @param pc A consumer to set state properties\n+     *\/\n+    protected void setupStageWithStyle(StageStyle stageStyle, Consumer<Stage> pc) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            assertNull(stage, \"Stage is not null\");\n+            stage = new Stage();\n+            stage.setAlwaysOnTop(true);\n+            stage.initStyle(stageStyle);\n+            stage.setScene(createScene(stageStyle));\n+            if (pc != null) {\n+                pc.accept(stage);\n+            }\n+            stage.setOnShown(e -> shownLatch.countDown());\n+            stage.show();\n+        });\n+\n+        Util.waitForLatch(shownLatch, 5, \"Stage failed to show\");\n+    }\n+\n+    @BeforeAll\n+    public static void initFX() {\n+        Platform.setImplicitExit(false);\n+        Util.startup(startupLatch, startupLatch::countDown);\n+    }\n+\n+    @AfterAll\n+    public static void teardown() {\n+        Util.shutdown();\n+    }\n+\n+    \/**\n+     * Hides the test stage after each test\n+     *\/\n+    @AfterEach\n+    public void cleanup() {\n+        if (stage != null) {\n+            CountDownLatch hideLatch = new CountDownLatch(1);\n+            stage.setOnHidden(e -> hideLatch.countDown());\n+            Util.runAndWait(stage::hide);\n+            Util.waitForLatch(hideLatch, 5, \"Stage failed to hide\");\n+            stage = null;\n+        }\n+    }\n+\n+    \/**\n+     * @return The stage that is created for each test\n+     *\/\n+    protected Stage getStage() {\n+        return stage;\n+    }\n+\n+    \/**\n+     * Gets the Scene of the test stage.\n+     * @return The Scene of the test stage.\n+     *\/\n+    protected Scene getScene() {\n+        return stage.getScene();\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/stage\/StageTestBase.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -150,4 +150,0 @@\n-        if (PlatformUtil.isLinux()) {\n-            Assumptions.assumeTrue(Boolean.getBoolean(\"unstable.test\")); \/\/ JDK-8321624\n-        }\n-\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/DualWindowTest.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -129,1 +129,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ Skip due to JDK-8316891\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/IconifyTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,5 +28,0 @@\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assumptions.assumeTrue;\n-import static test.util.Util.TIMEOUT;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n@@ -39,2 +34,2 @@\n-import org.junit.jupiter.api.Test;\n-import com.sun.javafx.PlatformUtil;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n@@ -42,0 +37,8 @@\n+import test.util.Util;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+import static test.util.Util.TIMEOUT;\n@@ -53,0 +56,3 @@\n+    private static final int WAIT = 1000;\n+    private static final int SHORT_WAIT = 100;\n+\n@@ -57,1 +63,2 @@\n-    private void setupStages(boolean overlayed, boolean topShown) throws InterruptedException {\n+    private void setupStages(boolean overlayed, boolean topShown, StageStyle topStageStyle)\n+            throws InterruptedException {\n@@ -79,1 +86,1 @@\n-            topStage.initStyle(StageStyle.DECORATED);\n+            topStage.initStyle(topStageStyle);\n@@ -100,1 +107,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -103,7 +110,4 @@\n-    @Test\n-    public void testIconifiedStage() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(true, true);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testIconifiedStage(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(true, true, stageStyle);\n@@ -119,1 +123,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -128,7 +132,4 @@\n-    @Test\n-    public void testMaximizedStage() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(false, true);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testMaximizedStage(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(false, true, stageStyle);\n@@ -144,1 +145,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -154,0 +155,5 @@\n+        \/\/ Do not test decorations for UNDECORATED\n+        if (stageStyle.equals(StageStyle.UNDECORATED)) {\n+            return;\n+        }\n+\n@@ -156,1 +162,1 @@\n-        sleep(100);\n+        sleep(SHORT_WAIT);\n@@ -166,5 +172,7 @@\n-    @Test\n-    public void testFullScreenStage() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        assumeTrue(!PlatformUtil.isLinux());\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testFullScreenStage(StageStyle stageStyle) throws InterruptedException {\n+        \/\/ Causes Stage to hang on Wayland\n+        if (stageStyle == StageStyle.UNDECORATED && Util.isOnWayland()) {\n+            return;\n+        }\n@@ -172,1 +180,1 @@\n-        setupStages(false, true);\n+        setupStages(false, true, stageStyle);\n@@ -182,1 +190,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -187,1 +195,1 @@\n-            \/\/ fullscreen stage should take over the bottom stage\n+            \/\/ screen stage should take over the bottom stage\n@@ -194,1 +202,1 @@\n-        sleep(100);\n+        sleep(SHORT_WAIT);\n@@ -203,7 +211,4 @@\n-    @Test\n-    public void testIconifiedStageBeforeShow() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(true, false);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testIconifiedStageBeforeShow(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(true, false, stageStyle);\n@@ -221,1 +226,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -232,8 +237,4 @@\n-    @Test\n-    public void testMaximizedStageBeforeShow() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        \/\/  - JDK-8316425\n-        assumeTrue(!PlatformUtil.isLinux());\n-\n-        setupStages(false, false);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testMaximizedStageBeforeShow(StageStyle stageStyle) throws InterruptedException {\n+        setupStages(false, false, stageStyle);\n@@ -250,1 +251,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -260,0 +261,6 @@\n+\n+        \/\/ Do not test decorations for UNDECORATED\n+        if (stageStyle.equals(StageStyle.UNDECORATED)) {\n+            return;\n+        }\n+\n@@ -262,1 +269,1 @@\n-        sleep(100);\n+        sleep(SHORT_WAIT);\n@@ -272,6 +279,7 @@\n-    @Test\n-    public void testFullScreenStageBeforeShow() throws InterruptedException {\n-        \/\/ Skip on Linux due to:\n-        \/\/  - JDK-8316423\n-        \/\/  - JDK-8316425\n-        assumeTrue(!PlatformUtil.isLinux());\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    public void testFullScreenStageBeforeShow(StageStyle stageStyle) throws InterruptedException {\n+        \/\/ Causes Stage to hang on Wayland\n+        if (stageStyle == StageStyle.UNDECORATED && Util.isOnWayland()) {\n+            return;\n+        }\n@@ -279,1 +287,1 @@\n-        setupStages(false, false);\n+        setupStages(false, false, stageStyle);\n@@ -290,1 +298,1 @@\n-        sleep(1000);\n+        sleep(WAIT);\n@@ -302,1 +310,1 @@\n-        sleep(100);\n+        sleep(SHORT_WAIT);\n@@ -310,1 +318,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageAttributesTest.java","additions":72,"deletions":64,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import com.sun.javafx.PlatformUtil;\n@@ -55,1 +54,0 @@\n-import static org.junit.jupiter.api.Assumptions.assumeTrue;\n@@ -111,2 +109,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8367893\n-\n@@ -184,2 +180,0 @@\n-        assumeTrue(!PlatformUtil.isLinux()); \/\/ JDK-8367893\n-\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageFocusTest.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.robot.javafx.stage;\n+\n+import javafx.application.Platform;\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.ReadOnlyDoubleProperty;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.api.Timeout;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import test.robot.testharness.VisualTestBase;\n+import test.util.Util;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+import static test.util.Util.TIMEOUT;\n+\n+@Timeout(value = TIMEOUT, unit= TimeUnit.MILLISECONDS)\n+class StageLocationTest extends VisualTestBase {\n+    private static final int WIDTH = 300;\n+    private static final int HEIGHT = 300;\n+    private static final int X = 100;\n+    private static final int Y = 100;\n+    private static final int TO_X = 500;\n+    private static final int TO_Y = 500;\n+    private static final Color COLOR = Color.RED;\n+    private static final double TOLERANCE = 0.07;\n+    private static final int WAIT = 300;\n+\n+    private Stage createStage(StageStyle stageStyle) {\n+        Stage s = getStage(true);\n+        s.initStyle(stageStyle);\n+        VBox vBox = new VBox(createLabel(\"X: \", s.xProperty()),\n+                createLabel(\"Y: \", s.yProperty()));\n+        vBox.setBackground(Background.EMPTY);\n+        Scene scene = new Scene(vBox, WIDTH, HEIGHT);\n+        scene.setFill(COLOR);\n+        s.setScene(scene);\n+        s.setWidth(WIDTH);\n+        s.setHeight(HEIGHT);\n+        return s;\n+    }\n+\n+    protected Label createLabel(String prefix, ReadOnlyDoubleProperty property) {\n+        Label label = new Label();\n+        label.textProperty().bind(Bindings.concat(prefix, Bindings.convert(property)));\n+        return label;\n+    }\n+\n+    private void assertColorEquals(Color expected, int x, int y) {\n+        Color color = getColor(x, y);\n+        assertColorEquals(expected, color, TOLERANCE);\n+    }\n+\n+    private Stage stage;\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\",  \"EXTENDED\", \"UTILITY\"})\n+    void moveXY(StageStyle stageStyle) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            stage = createStage(stageStyle);\n+            stage.setX(X);\n+            stage.setY(Y);\n+            stage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            stage.show();\n+        });\n+\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT);\n+\n+        Util.doTimeLine(WAIT,\n+                () -> assertColorEquals(COLOR, X + 100, Y + 100),\n+                () -> {\n+                    stage.setX(TO_X);\n+                    stage.setY(TO_Y);\n+                },\n+                () -> assertColorEquals(COLOR, TO_X + 100, TO_Y + 100));\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"UTILITY\"})\n+    void moveX(StageStyle stageStyle) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            stage = createStage(stageStyle);\n+            stage.setX(X);\n+            stage.setY(Y);\n+            stage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            stage.show();\n+        });\n+\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT);\n+\n+        Util.doTimeLine(WAIT,\n+                () -> assertColorEquals(COLOR, X + 100, Y + 100),\n+                () -> stage.setX(TO_X),\n+                () -> assertColorEquals(COLOR, TO_X + 100, Y + 100));\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"UTILITY\"})\n+    void moveY(StageStyle stageStyle) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            stage = createStage(stageStyle);\n+            stage.setX(X);\n+            stage.setY(Y);\n+            stage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            stage.show();\n+        });\n+\n+\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT);\n+\n+        Util.doTimeLine(WAIT,\n+                () -> assertColorEquals(COLOR, X + 100, Y + 100),\n+                () -> stage.setY(TO_Y),\n+                () -> assertColorEquals(COLOR, X + 100, TO_Y + 100));\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\", \"UTILITY\"})\n+    void moveAfterShow(StageStyle stageStyle) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            stage = createStage(stageStyle);\n+            stage.setX(X);\n+            stage.setY(Y);\n+            stage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            stage.show();\n+        });\n+\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT);\n+\n+        Util.doTimeLine(WAIT,\n+                () -> {\n+                    stage.setX(TO_X);\n+                    stage.setY(TO_Y);\n+                },\n+                () -> assertColorEquals(COLOR, TO_X + 100, TO_Y + 100));\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageLocationTest.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n-import javafx.animation.KeyFrame;\n-import javafx.animation.Timeline;\n-import javafx.geometry.Insets;\n+import javafx.application.Platform;\n@@ -32,4 +30,1 @@\n-import javafx.scene.layout.Background;\n-import javafx.scene.layout.BackgroundFill;\n-import javafx.scene.layout.CornerRadii;\n-import javafx.scene.layout.Pane;\n+import javafx.scene.layout.StackPane;\n@@ -39,3 +34,3 @@\n-import javafx.util.Duration;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.Timeout;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n@@ -43,0 +38,1 @@\n+import test.util.Util;\n@@ -44,1 +40,0 @@\n-import java.util.Map;\n@@ -48,1 +43,2 @@\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n@@ -51,1 +47,2 @@\n-public class StageMixedSizeTest extends VisualTestBase {\n+@Timeout(value = TIMEOUT, unit= TimeUnit.MILLISECONDS)\n+class StageMixedSizeTest extends VisualTestBase {\n@@ -54,0 +51,1 @@\n+    private static final int WAIT = 300;\n@@ -56,3 +54,3 @@\n-    @Test\n-    public void testSetWidthOnlyAfterShownOnContentSizeWindow() throws Exception {\n-        CountDownLatch latch = new CountDownLatch(1);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    void testSetWidthOnlyAfterShownOnContentSizeWindow(StageStyle stageStyle) {\n@@ -62,3 +60,1 @@\n-        setupContentSizeTestStage(initialContentSize, initialContentSize,\n-                () -> doTimeLine(Map.of(500L, () -> testStage.setWidth(finalWidth),\n-                                        1000L, latch::countDown)));\n+        setupContentSizeTestStage(stageStyle, initialContentSize, initialContentSize);\n@@ -66,5 +62,5 @@\n-        assertTrue(latch.await(TIMEOUT, TimeUnit.MILLISECONDS), \"Timeout waiting for test stage to be shown\");\n-\n-        runAndWait(() -> assertColorDoesNotEqual(BACKGROUND_COLOR,\n-                getColor(initialContentSize - 10, initialContentSize \/ 2), TOLERANCE));\n-        Assertions.assertEquals(finalWidth, testStage.getWidth(), \"Window width should be \" + finalWidth);\n+        Util.doTimeLine(WAIT,\n+                () -> testStage.setWidth(finalWidth),\n+                () -> assertColorDoesNotEqual(BACKGROUND_COLOR,\n+                        getColor(initialContentSize - 10, initialContentSize \/ 2), TOLERANCE),\n+                () -> assertEquals(finalWidth, testStage.getWidth(), \"Window width should be \" + finalWidth));\n@@ -73,3 +69,3 @@\n-    @Test\n-    public void testSetHeightOnlyAfterShownOnContentSizeWindow() throws Exception {\n-        CountDownLatch latch = new CountDownLatch(1);\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\"})\n+    void testSetHeightOnlyAfterShownOnContentSizeWindow(StageStyle stageStyle) {\n@@ -79,5 +75,1 @@\n-        setupContentSizeTestStage(initialContentSize, initialContentSize,\n-                () -> doTimeLine(Map.of(500L, () -> testStage.setHeight(finalHeight),\n-                                        1000L, latch::countDown)));\n-\n-        assertTrue(latch.await(TIMEOUT, TimeUnit.MILLISECONDS), \"Timeout waiting for test stage to be shown\");\n+        setupContentSizeTestStage(stageStyle, initialContentSize, initialContentSize);\n@@ -85,3 +77,5 @@\n-        runAndWait(() -> assertColorDoesNotEqual(BACKGROUND_COLOR,\n-                getColor(initialContentSize \/ 2, initialContentSize - 10), TOLERANCE));\n-        Assertions.assertEquals(finalHeight, testStage.getHeight(), \"Window height should be \" + finalHeight);\n+        Util.doTimeLine(WAIT,\n+                () -> testStage.setHeight(finalHeight),\n+                () -> assertColorDoesNotEqual(BACKGROUND_COLOR,\n+                        getColor(initialContentSize \/ 2, initialContentSize - 10), TOLERANCE),\n+                () -> assertEquals(finalHeight, testStage.getHeight(), \"Window height should be \" + finalHeight));\n@@ -90,15 +84,13 @@\n-    private void setupContentSizeTestStage(int width, int height, Runnable onShown) {\n-        runAndWait(() -> {\n-            testStage = getStage(true);\n-            testStage.initStyle(StageStyle.TRANSPARENT);\n-            Pane pane = new Pane();\n-            pane.setPrefSize(width, height);\n-            pane.setBackground(new Background(new BackgroundFill(BACKGROUND_COLOR, CornerRadii.EMPTY, Insets.EMPTY)));\n-            Scene scene = new Scene(pane);\n-            testStage.setScene(scene);\n-            testStage.setX(0);\n-            testStage.setY(0);\n-            testStage.setOnShown(e -> onShown.run());\n-            testStage.show();\n-        });\n-    }\n+    private void setupContentSizeTestStage(StageStyle stageStyle, int width, int height) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+\n+        Util.runAndWait(() -> {\n+                    testStage = getStage(true);\n+                    testStage.initStyle(stageStyle);\n+                    Scene scene = new Scene(new StackPane(), width, height, BACKGROUND_COLOR);\n+                    testStage.setScene(scene);\n+                    testStage.setX(0);\n+                    testStage.setY(0);\n+                    testStage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+                    testStage.show();\n+                });\n@@ -106,6 +98,2 @@\n-    private void doTimeLine(Map<Long, Runnable> keyFrames) {\n-        Timeline timeline = new Timeline();\n-        timeline.setCycleCount(1);\n-        keyFrames.forEach((duration, runnable) ->\n-                timeline.getKeyFrames().add(new KeyFrame(Duration.millis(duration), e -> runnable.run())));\n-        timeline.play();\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT);\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageMixedSizeTest.java","additions":45,"deletions":57,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -0,0 +1,319 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.robot.javafx.stage;\n+\n+import com.sun.javafx.PlatformUtil;\n+import javafx.application.Platform;\n+import javafx.beans.binding.Bindings;\n+import javafx.geometry.Pos;\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Label;\n+import javafx.scene.layout.Background;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.Pane;\n+import javafx.scene.paint.Color;\n+import javafx.stage.Modality;\n+import javafx.stage.Screen;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.api.Timeout;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import test.robot.testharness.VisualTestBase;\n+import test.util.Util;\n+\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assumptions.assumeTrue;\n+import static test.util.Util.PARAMETERIZED_TEST_DISPLAY;\n+import static test.util.Util.TIMEOUT;\n+\n+@Timeout(value = TIMEOUT, unit = TimeUnit.MILLISECONDS)\n+class StageOwnershipTest extends VisualTestBase {\n+    private static final int WIDTH = 200;\n+    private static final int HEIGHT = 200;\n+    private static final double BOUNDS_EDGE_DELTA = 75;\n+    private Stage topStage;\n+    private Stage bottomStage;\n+    private static final Color TOP_COLOR = Color.RED;\n+    private static final Color BOTTOM_COLOR = Color.LIME;\n+    private static final Color COLOR0 = Color.RED;\n+    private static final Color COLOR1 = Color.ORANGE;\n+    private static final Color COLOR2 = Color.YELLOW;\n+    private static final Color COLOR3 = Color.GREEN;\n+    private static final int X_DELTA = 15; \/\/ shadows\n+    private static final int Y_DELTA = 75; \/\/ shadows + decoration\n+\n+    private static final double TOLERANCE = 0.07;\n+    private static final int WAIT_TIME = 500;\n+    private static final int LONG_WAIT_TIME = 1000;\n+\n+    @Override\n+    protected Stage getStage(boolean alwaysOnTop) {\n+        Stage stage = super.getStage(alwaysOnTop);\n+        stage.setFullScreenExitHint(\n+                \"Will BEEP on macOS when exiting fullscreen due to OS trying to focus a disabled stage\");\n+        return stage;\n+    }\n+\n+    private void setupBottomStage() throws InterruptedException {\n+        final CountDownLatch shownLatch = new CountDownLatch(1);\n+\n+        runAndWait(() -> {\n+            bottomStage = getStage(false);\n+            bottomStage.initStyle(StageStyle.DECORATED);\n+            Scene bottomScene = new Scene(getFocusedLabel(BOTTOM_COLOR, bottomStage), WIDTH, HEIGHT);\n+            bottomScene.setFill(BOTTOM_COLOR);\n+            bottomStage.setScene(bottomScene);\n+            bottomStage.setX(0);\n+            bottomStage.setY(0);\n+            bottomStage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            bottomStage.show();\n+        });\n+        assertTrue(shownLatch.await(TIMEOUT, TimeUnit.MILLISECONDS),\n+                \"Timeout waiting for bottom stage to be shown\");\n+\n+        sleep(WAIT_TIME);\n+    }\n+\n+    private void setupTopStage(Stage owner, StageStyle stageStyle, Modality modality) {\n+        runAndWait(() -> {\n+            topStage = getStage(true);\n+            if (stageStyle != null) {\n+                topStage.initStyle(stageStyle);\n+            }\n+            Scene topScene = new Scene(getFocusedLabel(TOP_COLOR, topStage), WIDTH, HEIGHT);\n+            topScene.setFill(TOP_COLOR);\n+            topStage.setScene(topScene);\n+            if (owner != null) {\n+                topStage.initOwner(owner);\n+            }\n+            if (modality != null) {\n+                topStage.initModality(modality);\n+            }\n+            topStage.setWidth(WIDTH);\n+            topStage.setHeight(HEIGHT);\n+            topStage.setX(0);\n+            topStage.setY(0);\n+        });\n+    }\n+\n+    private void assertColorEqualsVisualBounds(Color expected) {\n+        Rectangle2D visualBounds = Screen.getPrimary().getVisualBounds();\n+        int x = (int) (visualBounds.getWidth() - BOUNDS_EDGE_DELTA);\n+        int y = (int) (visualBounds.getHeight() - BOUNDS_EDGE_DELTA);\n+\n+        Color color = getColor(x, y);\n+        assertColorEquals(expected, color, TOLERANCE);\n+    }\n+\n+    private Stage createStage(StageStyle stageStyle, Color color, Stage owner, Modality modality, int x, int y) {\n+        Stage stage = getStage(true);\n+        stage.initStyle(stageStyle);\n+        Pane pane = getFocusedLabel(color, stage);\n+        Scene scene = new Scene(pane, WIDTH, HEIGHT);\n+        scene.setFill(color);\n+        stage.setScene(scene);\n+        stage.setWidth(WIDTH);\n+        stage.setHeight(HEIGHT);\n+        if (x != -1) {\n+            stage.setX(x);\n+        }\n+        if (y != -1) {\n+            stage.setY(y);\n+        }\n+        if (owner != null) {\n+            stage.initOwner(owner);\n+        }\n+        stage.initModality(modality);\n+        return stage;\n+    }\n+\n+    private static Pane getFocusedLabel(Color color, Stage stage) {\n+        Label label = new Label();\n+        label.textProperty().bind(Bindings.when(stage.focusedProperty())\n+                .then(\"Focused\").otherwise(\"Unfocused\"));\n+\n+        BorderPane pane = new BorderPane();\n+        pane.setBackground(Background.EMPTY);\n+        pane.setBottom(label);\n+        BorderPane.setAlignment(label, Pos.CENTER_RIGHT);\n+\n+        double luminance = 0.2126 * color.getRed()\n+                + 0.7152 * color.getGreen()\n+                + 0.0722 * color.getBlue();\n+\n+        Color textColor = luminance < 0.5 ? Color.WHITE : Color.BLACK;\n+\n+        label.setTextFill(textColor);\n+        return pane;\n+    }\n+\n+    private void assertColorEquals(Color expected, Stage stage) {\n+        Color color = getColor((int) stage.getX() + X_DELTA, (int) stage.getY() + Y_DELTA);\n+        assertColorEquals(expected, color, TOLERANCE);\n+    }\n+\n+    private static Stream<Arguments> getTestsParams() {\n+        return Stream.of(StageStyle.DECORATED, StageStyle.UNDECORATED, StageStyle.EXTENDED)\n+                .flatMap(stageStyle -> Stream.of(Modality.APPLICATION_MODAL, Modality.WINDOW_MODAL)\n+                        .map(modality -> Arguments.of(stageStyle, modality)));\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @MethodSource(\"getTestsParams\")\n+    void openingModalChildStageWhileMaximizedShouldNotUnmaximize(StageStyle stageStyle, Modality modality)\n+            throws InterruptedException {\n+        setupBottomStage();\n+        setupTopStage(bottomStage, stageStyle, modality);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+            () -> bottomStage.setMaximized(true),\n+            topStage::show,\n+            () -> {\n+                assertTrue(bottomStage.isMaximized());\n+                \/\/ Make sure state is still maximized\n+                assertColorEqualsVisualBounds(BOTTOM_COLOR);\n+\n+                Color color = getColor(100, 100);\n+                assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+            });\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @MethodSource(\"getTestsParams\")\n+    \/\/ This test causes BEEP on macOS\n+    void openingModalChildStageWhileFullScreenShouldHaveFocus(StageStyle stageStyle, Modality modality)\n+            throws InterruptedException {\n+        setupBottomStage();\n+        setupTopStage(bottomStage, stageStyle, modality);\n+\n+        Util.doTimeLine(LONG_WAIT_TIME,\n+                () -> bottomStage.setFullScreen(true),\n+                topStage::show,\n+                () -> {\n+                    assertTrue(bottomStage.isFullScreen());\n+\n+                    \/\/ Make sure state is still fullscreen\n+                    assertColorEqualsVisualBounds(BOTTOM_COLOR);\n+\n+                    Color color = getColor(100, 100);\n+                    assertColorEquals(TOP_COLOR, color, TOLERANCE);\n+                });\n+    }\n+\n+    private Stage stage0;\n+    private Stage stage1;\n+    private Stage stage2;\n+    private Stage stage3;\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @MethodSource(\"getTestsParams\")\n+    void closingModalWindowShouldFocusParent(StageStyle style, Modality modality) {\n+        CountDownLatch shownLatch = new CountDownLatch(1);\n+        Util.runAndWait(() -> {\n+            stage0 = createStage(style, COLOR0, null, null, 100, 100);\n+            stage1 = createStage(style, COLOR1, stage0, null, 150, 150);\n+            stage2 = createStage(style, COLOR2, stage1, modality, 200, 200);\n+\n+            stage0.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+            stage0.show();\n+        });\n+\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT_TIME);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+            stage1::show,\n+            stage2::show,\n+            () -> {\n+                assertTrue(stage2.isFocused());\n+                assertColorEquals(COLOR2, stage2);\n+                assertFalse(stage1.isFocused());\n+                assertFalse(stage0.isFocused());\n+            },\n+            stage2::close,\n+            () -> {\n+                assertTrue(stage1.isFocused());\n+                assertColorEquals(COLOR1, stage1);\n+                assertFalse(stage0.isFocused());\n+            },\n+            stage1::close,\n+            () -> {\n+                assertTrue(stage0.isFocused());\n+                assertColorEquals(COLOR0, stage0);\n+            });\n+    }\n+\n+    @ParameterizedTest(name = PARAMETERIZED_TEST_DISPLAY)\n+    @EnumSource(names = {\"DECORATED\", \"UNDECORATED\", \"EXTENDED\"})\n+    void iconifyParentShouldHideChildren(StageStyle style) {\n+        if (style == StageStyle.EXTENDED || style == StageStyle.DECORATED) {\n+            \/\/ Windows just hides the first-level ownership (bug?)\n+            assumeTrue(!PlatformUtil.isWindows());\n+        }\n+\n+        CountDownLatch shownLatch = new CountDownLatch(4);\n+        Util.runAndWait(() -> {\n+            stage0 = createStage(StageStyle.UNDECORATED, COLOR0, null, null, 0, 0);\n+            stage0.setMaximized(true);\n+            stage1 = createStage(style, COLOR1, null, null, 100, 100);\n+            stage2 = createStage(style, COLOR2, stage1, null, 200, 150);\n+            stage3 = createStage(style, COLOR3, stage2, null, 300, 200);\n+\n+            List.of(stage0, stage1, stage2, stage3).forEach(stage -> {\n+                stage.setOnShown(e -> Platform.runLater(shownLatch::countDown));\n+                stage.show();\n+            });\n+        });\n+\n+        Util.await(shownLatch);\n+        Util.sleep(WAIT_TIME);\n+\n+        Util.doTimeLine(WAIT_TIME,\n+            () -> stage1.setIconified(true),\n+            () -> {\n+                assertTrue(stage1.isIconified());\n+                assertColorEquals(COLOR0, stage1);\n+                assertColorEquals(COLOR0, stage2);\n+                assertColorEquals(COLOR0, stage3);\n+            },\n+            () -> stage1.setIconified(false),\n+            () -> {\n+                assertFalse(stage1.isIconified());\n+                assertColorEquals(COLOR1, stage1);\n+                assertColorEquals(COLOR2, stage2);\n+                assertColorEquals(COLOR3, stage3);\n+            });\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/stage\/StageOwnershipTest.java","additions":319,"deletions":0,"binary":false,"changes":319,"status":"added"},{"patch":"@@ -39,0 +39,2 @@\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n@@ -40,0 +42,1 @@\n+import java.util.concurrent.ExecutionException;\n@@ -41,0 +44,4 @@\n+import java.util.concurrent.TimeoutException;\n+\n+import javafx.animation.KeyFrame;\n+import javafx.animation.Timeline;\n@@ -50,0 +57,1 @@\n+import javafx.stage.Stage;\n@@ -51,0 +59,1 @@\n+import javafx.util.Duration;\n@@ -58,0 +67,2 @@\n+    public static final String PARAMETERIZED_TEST_DISPLAY = \"{displayName} [{index}] {arguments}\";\n+\n@@ -456,0 +467,90 @@\n+\n+    \/**\n+     * Creates a {@link Timeline} where each {@link KeyFrame} runs a {@link Runnable}.\n+     * Each {@link Runnable} will be scheduled at an increment of {@code msToIncrement} milliseconds.\n+     *\n+     * @param msToIncrement the number of milliseconds to increment between each {@link KeyFrame}\n+     * @param runnables     the list of {@link Runnable} instances to execute sequentially\n+     *\/\n+    public static void doTimeLine(int msToIncrement, Runnable... runnables) {\n+        long millis = msToIncrement;\n+\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+\n+        Timeline timeline = new Timeline();\n+        timeline.setCycleCount(1);\n+        for (Runnable runnable : runnables) {\n+            timeline.getKeyFrames().add(new KeyFrame(Duration.millis(millis), e -> {\n+                try {\n+                    runnable.run();\n+                } catch (Throwable ex) {\n+                    future.completeExceptionally(ex);\n+                }\n+            }));\n+            millis += msToIncrement;\n+        }\n+        timeline.setOnFinished(e -> future.complete(null));\n+        timeline.play();\n+\n+        final long waitms = millis + 5000;\n+\n+        try {\n+            future.get(waitms, TimeUnit.MILLISECONDS);\n+        } catch (ExecutionException | InterruptedException | TimeoutException ex) {\n+            throwError(ex);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a {@link Timeline} where each {@link KeyFrame} executes a {@link Runnable}.\n+     *\n+     * @param runnables a {@link Map} where the key is the {@link Duration} at which to trigger the action,\n+     *                  and the value is the {@link Runnable} to execute at that time\n+     *\/\n+    public static void doTimeLine(Map<Duration, Runnable> runnables) {\n+        CompletableFuture<Void> future = new CompletableFuture<>();\n+\n+        Timeline timeline = new Timeline();\n+        timeline.setCycleCount(1);\n+        Duration totalDuration = Duration.seconds(5);\n+\n+        for (Map.Entry<Duration, Runnable> entry : runnables.entrySet()) {\n+            Duration duration = entry.getKey();\n+            Runnable runnable = entry.getValue();\n+            totalDuration = totalDuration.add(duration);\n+            timeline.getKeyFrames().add(new KeyFrame(duration, e -> {\n+                try {\n+                    runnable.run();\n+                } catch (Throwable ex) {\n+                    future.completeExceptionally(ex);\n+                }\n+            }));\n+        }\n+\n+        timeline.setOnFinished(e -> future.complete(null));\n+        timeline.play();\n+\n+        long waitms = (long) totalDuration.toMillis();\n+        try {\n+            future.get(waitms, TimeUnit.MILLISECONDS);\n+        } catch (ExecutionException | InterruptedException | TimeoutException ex) {\n+            throwError(ex);\n+        }\n+    }\n+\n+    \/**\n+     * Finds the {@link Screen} where the top-left corner of the given {@link Stage} is located.\n+     *\n+     * @param stage the {@link Stage} to check\n+     * @return the {@link Screen} containing the stage's top-left corner or {@link Screen#getPrimary()}\n+     *\/\n+    public static Screen getScreen(Stage stage) {\n+        for (Screen screen : Screen.getScreens()) {\n+            Rectangle2D bounds = screen.getVisualBounds();\n+            if (bounds.contains(stage.getX(), stage.getY())) {\n+                return screen;\n+            }\n+        }\n+\n+        return Screen.getPrimary();\n+    }\n","filename":"tests\/system\/src\/test\/java\/test\/util\/Util.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"modified"}]}