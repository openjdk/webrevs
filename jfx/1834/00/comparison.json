{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.glass.ui.gtk.screencast.XdgDesktopPortal;\n@@ -38,14 +39,0 @@\n-    private static final String screenshotMethod;\n-    private static final String METHOD_GTK = \"gtk\";\n-    private static final String METHOD_SCREENCAST = \"dbusScreencast\";\n-\n-    static {\n-        String waylandDisplay = System.getenv(\"WAYLAND_DISPLAY\");\n-        boolean isOnWayland = waylandDisplay != null && !waylandDisplay.isBlank();\n-\n-        String method =\n-            System.getProperty(\"javafx.robot.screenshotMethod\",\n-                isOnWayland ? METHOD_SCREENCAST : METHOD_GTK);\n-        screenshotMethod = method;\n-    }\n-\n@@ -65,1 +52,5 @@\n-        _keyPress(code.getCode());\n+        if (XdgDesktopPortal.isRemoteDesktop() && ScreencastHelper.isAvailable()) {\n+            ScreencastHelper.remoteDesktopKey(true, code.getCode());\n+        } else {\n+            _keyPress(code.getCode());\n+        }\n@@ -73,1 +64,5 @@\n-        _keyRelease(code.getCode());\n+        if (XdgDesktopPortal.isRemoteDesktop() && ScreencastHelper.isAvailable()) {\n+            ScreencastHelper.remoteDesktopKey(false, code.getCode());\n+        } else {\n+            _keyRelease(code.getCode());\n+        }\n@@ -84,0 +79,5 @@\n+        if (XdgDesktopPortal.isRemoteDesktop() && ScreencastHelper.isAvailable()) {\n+            \/\/ We still call _mouseMove on purpose to change the mouse position\n+            \/\/ within the XWayland server so that we can retrieve it later.\n+            ScreencastHelper.remoteDesktopMouseMove((int) x, (int) y);\n+        }\n@@ -89,1 +89,5 @@\n-        _mousePress(GlassRobot.convertToRobotMouseButton(buttons));\n+        if (XdgDesktopPortal.isRemoteDesktop() && ScreencastHelper.isAvailable()) {\n+            ScreencastHelper.remoteDesktopMouseButton(true, GlassRobot.convertToRobotMouseButton(buttons));\n+        } else {\n+            _mousePress(GlassRobot.convertToRobotMouseButton(buttons));\n+        }\n@@ -97,1 +101,5 @@\n-        _mouseRelease(GlassRobot.convertToRobotMouseButton(buttons));\n+        if (XdgDesktopPortal.isRemoteDesktop() && ScreencastHelper.isAvailable()) {\n+            ScreencastHelper.remoteDesktopMouseButton(false, GlassRobot.convertToRobotMouseButton(buttons));\n+        } else {\n+            _mouseRelease(GlassRobot.convertToRobotMouseButton(buttons));\n+        }\n@@ -105,1 +113,5 @@\n-        _mouseWheel(wheelAmt);\n+        if (XdgDesktopPortal.isRemoteDesktop() && ScreencastHelper.isAvailable()) {\n+            ScreencastHelper.remoteDesktopMouseWheel(wheelAmt);\n+        } else {\n+            _mouseWheel(wheelAmt);\n+        }\n@@ -133,1 +145,2 @@\n-        if (METHOD_SCREENCAST.equals(screenshotMethod)) {\n+        if ((XdgDesktopPortal.isScreencast()\n+                || XdgDesktopPortal.isRemoteDesktop()) && ScreencastHelper.isAvailable()) {\n@@ -146,1 +159,2 @@\n-        if (METHOD_SCREENCAST.equals(screenshotMethod)) {\n+        if ((XdgDesktopPortal.isScreencast()\n+                || XdgDesktopPortal.isRemoteDesktop()) && ScreencastHelper.isAvailable()) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/GtkRobot.java","additions":35,"deletions":21,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.function.Function;\n@@ -36,1 +37,0 @@\n-import java.util.function.Supplier;\n@@ -44,1 +44,1 @@\n-public class ScreencastHelper {\n+public final class ScreencastHelper {\n@@ -49,1 +49,0 @@\n-\n@@ -53,0 +52,4 @@\n+    private static final int NO_STREAMS = -13;\n+\n+    private static final int XDG_METHOD_SCREENCAST = 0;\n+    private static final int XDG_METHOD_REMOTE_DESKTOP = 1;\n@@ -61,2 +64,1 @@\n-    private ScreencastHelper() {\n-    }\n+    private ScreencastHelper() {}\n@@ -65,9 +67,21 @@\n-        boolean isDebugEnabled =\n-                ((Supplier<Boolean>) () -> {\n-                    final String str =\n-                            System.getProperty(\"javafx.robot.screenshotDebug\", \"false\");\n-                    return \"true\".equalsIgnoreCase(str);\n-                }).get();\n-        SCREENCAST_DEBUG = isDebugEnabled;\n-\n-        IS_NATIVE_LOADED = loadPipewire(SCREENCAST_DEBUG);\n+        SCREENCAST_DEBUG = Boolean.getBoolean(\"javafx.robot.screenshotDebug\");\n+\n+        boolean loadFailed = false;\n+\n+        boolean shouldLoadNative = XdgDesktopPortal.isRemoteDesktop()\n+                || XdgDesktopPortal.isScreencast();\n+\n+        int methodId = XdgDesktopPortal.isScreencast()\n+                ? XDG_METHOD_SCREENCAST\n+                : XDG_METHOD_REMOTE_DESKTOP;\n+\n+        if (!(shouldLoadNative && loadPipewire(methodId, SCREENCAST_DEBUG))) {\n+\n+            System.err.println(\n+                    \"Could not load native libraries for ScreencastHelper\"\n+            );\n+\n+            loadFailed = true;\n+        }\n+\n+        IS_NATIVE_LOADED = !loadFailed;\n@@ -80,1 +94,1 @@\n-    private static native boolean loadPipewire(boolean screencastDebug);\n+    private static native boolean loadPipewire(int method, boolean isDebug);\n@@ -199,1 +213,1 @@\n-    private static void debugReturnValue(int retVal) {\n+    private static boolean debugReturnValue(int retVal) {\n@@ -201,1 +215,0 @@\n-            \/\/ user explicitly denied the capture, no more tries.\n@@ -203,1 +216,1 @@\n-                System.err.println(\"Screen Capture in the selected area was not allowed\");\n+                System.err.println(\"robot action: access denied by user.\");\n@@ -207,1 +220,1 @@\n-                System.err.println(\"Screen capture failed.\");\n+                System.err.println(\"robot action: failed.\");\n@@ -214,0 +227,4 @@\n+        } else if (retVal == NO_STREAMS) {\n+            if (SCREENCAST_DEBUG) {\n+                System.err.println(\"robot action: no streams available\");\n+            }\n@@ -215,0 +232,1 @@\n+        return retVal != ERROR;\n@@ -216,0 +234,37 @@\n+\n+    private static void performWithToken(Function<String, Integer> func) {\n+        if (!XdgDesktopPortal.isRemoteDesktop() || !IS_NATIVE_LOADED) return;\n+\n+        timerCloseSessionRestart();\n+\n+        for (TokenItem tokenItem : TokenStorage.getTokens(getSystemScreensBounds())) {\n+            int retVal = func.apply(tokenItem.token);\n+\n+            if (retVal >= 0 || !debugReturnValue(retVal)) {\n+                return;\n+            }\n+        }\n+\n+        debugReturnValue(func.apply(null));\n+    }\n+\n+    public static synchronized void remoteDesktopMouseMove(int x, int y) {\n+        performWithToken((token) -> remoteDesktopMouseMoveImpl(x, y, token));\n+    }\n+\n+    public static synchronized void remoteDesktopMouseButton(boolean isPress, int buttons) {\n+        performWithToken((token) -> remoteDesktopMouseButtonImpl(isPress, buttons, token));\n+    }\n+\n+    public static synchronized void remoteDesktopMouseWheel(int wheel) {\n+        performWithToken((token) -> remoteDesktopMouseWheelImpl(wheel, token));\n+    }\n+\n+    public static synchronized void remoteDesktopKey(boolean isPress, int key) {\n+        performWithToken((token) -> remoteDesktopKeyImpl(isPress, key, token));\n+    }\n+\n+    private static synchronized native int remoteDesktopMouseMoveImpl(int x, int y, String token);\n+    private static synchronized native int remoteDesktopMouseButtonImpl(boolean isPress, int buttons, String token);\n+    private static synchronized native int remoteDesktopMouseWheelImpl(int wheelAmt, String token);\n+    private static synchronized native int remoteDesktopKeyImpl(boolean isPress, int key, String token);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/screencast\/ScreencastHelper.java","additions":75,"deletions":20,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,3 @@\n+    private static final String REL_RD_NAME =\n+            \".java\/robot\/remote-desktop-tokens.properties\";\n+\n@@ -75,3 +78,1 @@\n-        Path propsPath = setupPath();\n-\n-        PROPS_PATH = propsPath;\n+        PROPS_PATH = setupPath();\n@@ -98,2 +99,12 @@\n-        Path primaryPath = Path.of(userHome, REL_NAME);\n-        Path secondaryPath = Path.of(userHome, REL_NAME_SECONDARY);\n+        Path path;\n+        Path secondaryPath = null;\n+\n+        if (XdgDesktopPortal.isRemoteDesktop()) {\n+            path = Path.of(userHome, REL_RD_NAME);\n+        } else {\n+            path = Path.of(userHome, REL_NAME);\n+            secondaryPath = Path.of(userHome, REL_NAME_SECONDARY);\n+        }\n+\n+        boolean copyFromSecondary = !Files.isWritable(path)\n+                && secondaryPath != null && Files.isWritable(secondaryPath);\n@@ -101,3 +112,0 @@\n-        Path path = Files.isWritable(secondaryPath) && !Files.isWritable(primaryPath)\n-                ? secondaryPath\n-                : primaryPath;\n@@ -141,1 +149,11 @@\n-        if (Files.exists(path)) {\n+        if (copyFromSecondary) {\n+            if (SCREENCAST_DEBUG) {\n+                System.out.println(\"Token storage: copying from the secondary location \"\n+                                        + secondaryPath);\n+            }\n+            synchronized (PROPS) {\n+                if (readTokens(secondaryPath)) {\n+                    store(path, \"copy from the secondary location\");\n+                }\n+            }\n+        } else if (Files.exists(path)) {\n@@ -169,1 +187,1 @@\n-    private static class WatcherThread extends Thread {\n+    private static final class WatcherThread extends Thread {\n@@ -296,1 +314,1 @@\n-                store(\"save tokens\");\n+                store(PROPS_PATH, \"save tokens\");\n@@ -309,1 +327,1 @@\n-        } catch (IOException e) {\n+        } catch (IOException | IllegalArgumentException e) {\n@@ -404,1 +422,1 @@\n-        if (!isWritable()\n+        if (!isWritable(PROPS_PATH)\n@@ -418,1 +436,1 @@\n-            store(\"remove malformed records\");\n+            store(PROPS_PATH, \"remove malformed records\");\n@@ -422,2 +440,2 @@\n-    private static void store(String failMsg) {\n-        if (!isWritable()) {\n+    private static void store(Path path, String failMsg) {\n+        if (!isWritable(path)) {\n@@ -428,1 +446,1 @@\n-            try (BufferedWriter writer = Files.newBufferedWriter(PROPS_PATH)) {\n+            try (BufferedWriter writer = Files.newBufferedWriter(path)) {\n@@ -439,3 +457,3 @@\n-    private static boolean isWritable() {\n-        if (PROPS_PATH == null\n-            || (Files.exists(PROPS_PATH) && !Files.isWritable(PROPS_PATH))) {\n+    private static boolean isWritable(Path path) {\n+        if (path == null\n+            || (Files.exists(path) && !Files.isWritable(path))) {\n@@ -445,1 +463,1 @@\n-                        \"Token storage: %s is not writable\\n\", PROPS_PATH);\n+                        \"Token storage: %s is not writable\\n\", path);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/screencast\/TokenStorage.java","additions":40,"deletions":22,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui.gtk.screencast;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public class XdgDesktopPortal {\n+    private static final String METHOD_GTK = \"gtk\";\n+    private static final String METHOD_SCREENCAST = \"dbusScreencast\";\n+    private static final String METHOD_REMOTE_DESKTOP = \"dbusRemoteDesktop\";\n+\n+    private static final String method;\n+    private static final boolean isRemoteDesktop;\n+    private static final boolean isScreencast;\n+\n+    private XdgDesktopPortal() {}\n+\n+    static {\n+        String waylandDisplay = System.getenv(\"WAYLAND_DISPLAY\");\n+        boolean isOnWayland = waylandDisplay != null && !waylandDisplay.isBlank();\n+\n+        String defaultMethod = METHOD_GTK;\n+        if (isOnWayland) {\n+            Integer gnomeShellVersion = null;\n+\n+            if (\"gnome\".equals(getDesktop())) {\n+                gnomeShellVersion = getGnomeShellMajorVersion();\n+            }\n+\n+            defaultMethod = (gnomeShellVersion != null && gnomeShellVersion >= 47)\n+                    ? METHOD_REMOTE_DESKTOP\n+                    : METHOD_SCREENCAST;\n+        }\n+\n+        String m = System.getProperty(\"javafx.robot.screenshotMethod\", defaultMethod);\n+\n+        if (!METHOD_REMOTE_DESKTOP.equals(m)\n+                && !METHOD_SCREENCAST.equals(m)\n+                && !METHOD_GTK.equals(m)) {\n+            m = defaultMethod;\n+        }\n+\n+        isRemoteDesktop = METHOD_REMOTE_DESKTOP.equals(m);\n+        isScreencast = METHOD_SCREENCAST.equals(m);\n+        method = m;\n+    }\n+\n+    public static String getMethod() {\n+        return method;\n+    }\n+\n+    public static boolean isRemoteDesktop() {\n+        return isRemoteDesktop;\n+    }\n+\n+    public static boolean isScreencast() {\n+        return isScreencast;\n+    }\n+\n+    private static String getDesktop() {\n+        String gnome = \"gnome\";\n+        String gsi = System.getenv(\"GNOME_DESKTOP_SESSION_ID\");\n+        if (gsi != null) {\n+            return gnome;\n+        }\n+\n+        String desktop = System.getenv(\"XDG_CURRENT_DESKTOP\");\n+        return (desktop != null && desktop.toLowerCase().contains(gnome))\n+                ? gnome : null;\n+    }\n+\n+    private static Integer getGnomeShellMajorVersion() {\n+        try {\n+            Process process =\n+                    new ProcessBuilder(\"\/usr\/bin\/gnome-shell\", \"--version\")\n+                            .start();\n+            try (BufferedReader reader = process.inputReader()) {\n+                if (process.waitFor(2, SECONDS) &&  process.exitValue() == 0) {\n+                    String line = reader.readLine();\n+                    if (line != null) {\n+                        String[] versionComponents = line\n+                                .replaceAll(\"[^\\\\d.]\", \"\")\n+                                .split(\"\\\\.\");\n+\n+                        if (versionComponents.length >= 1) {\n+                            return Integer.parseInt(versionComponents[0]);\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException\n+                 | InterruptedException\n+                 | IllegalThreadStateException\n+                 | NumberFormatException ignored) {\n+        }\n+\n+        return null;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/gtk\/screencast\/XdgDesktopPortal.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifdef HEADLESS\n-#error This file should not be included in headless library\n-#endif\n-#ifndef _FP_PIPEWIRE_H\n-#define _FP_PIPEWIRE_H\n-\n-\n-struct pw_buffer *(*fp_pw_stream_dequeue_buffer)(struct pw_stream *stream);\n-const char * (*fp_pw_stream_state_as_string)(enum pw_stream_state state);\n-int (*fp_pw_stream_queue_buffer)(struct pw_stream *stream,\n-                                 struct pw_buffer *buffer);\n-int (*fp_pw_stream_set_active)(struct pw_stream *stream, bool active);\n-\n-int (*fp_pw_stream_connect)(\n-        struct pw_stream *stream,\n-        enum pw_direction direction,\n-        uint32_t target_id,\n-        enum pw_stream_flags flags,\n-        const struct spa_pod **params,\n-        uint32_t n_params);\n-\n-struct pw_stream *(*fp_pw_stream_new)(\n-        struct pw_core *core,\n-        const char *name,\n-        struct pw_properties *props\n-);\n-void (*fp_pw_stream_add_listener)(struct pw_stream *stream,\n-                            struct spa_hook *listener,\n-                            const struct pw_stream_events *events,\n-                            void *data);\n-int (*fp_pw_stream_disconnect)(struct pw_stream *stream);\n-void (*fp_pw_stream_destroy)(struct pw_stream *stream);\n-\n-\n-void (*fp_pw_init)(int *argc, char **argv[]);\n-\n-struct pw_core *\n-(*fp_pw_context_connect_fd)(struct pw_context *context,\n-                      int fd,\n-                      struct pw_properties *properties,\n-                      size_t user_data_size);\n-\n-int (*fp_pw_core_disconnect)(struct pw_core *core);\n-\n-struct pw_context * (*fp_pw_context_new)(struct pw_loop *main_loop,\n-                                   struct pw_properties *props,\n-                                   size_t user_data_size);\n-\n-struct pw_thread_loop *\n-(*fp_pw_thread_loop_new)(const char *name, const struct spa_dict *props);\n-struct pw_loop * (*fp_pw_thread_loop_get_loop)(struct pw_thread_loop *loop);\n-void (*fp_pw_thread_loop_signal)(struct pw_thread_loop *loop,\n-                                 bool wait_for_accept);\n-void (*fp_pw_thread_loop_wait)(struct pw_thread_loop *loop);\n-void (*fp_pw_thread_loop_accept)(struct pw_thread_loop *loop);\n-int (*fp_pw_thread_loop_start)(struct pw_thread_loop *loop);\n-void (*fp_pw_thread_loop_stop)(struct pw_thread_loop *loop);\n-void (*fp_pw_thread_loop_destroy)(struct pw_thread_loop *loop);\n-void (*fp_pw_thread_loop_lock)(struct pw_thread_loop *loop);\n-void (*fp_pw_thread_loop_unlock)(struct pw_thread_loop *loop);\n-\n-struct pw_properties * (*fp_pw_properties_new)(const char *key, ...);\n-\n-\n-#endif \/\/_FP_PIPEWIRE_H\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/fp_pipewire.h","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"scancodes.h\"\n@@ -37,0 +38,2 @@\n+static gboolean key_initialized_remote_desktop = FALSE;\n+extern gboolean isRemoteDesktop;\n@@ -47,0 +50,3 @@\n+\/\/ GDK_KEY_{A..Z} to scancode map for QWERTY layout\n+static std::map<gint, guint32> keyval_to_scancode;\n+\n@@ -263,0 +269,77 @@\n+static void initialize_key_remote_desktop() {\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(a)] = SCANCODE_A;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(b)] = SCANCODE_B;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(c)] = SCANCODE_C;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(d)] = SCANCODE_D;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(e)] = SCANCODE_E;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(f)] = SCANCODE_F;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(g)] = SCANCODE_G;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(h)] = SCANCODE_H;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(i)] = SCANCODE_I;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(j)] = SCANCODE_J;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(k)] = SCANCODE_K;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(l)] = SCANCODE_L;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(m)] = SCANCODE_M;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(n)] = SCANCODE_N;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(o)] = SCANCODE_O;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(p)] = SCANCODE_P;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(q)] = SCANCODE_Q;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(r)] = SCANCODE_R;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(s)] = SCANCODE_S;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(t)] = SCANCODE_T;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(u)] = SCANCODE_U;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(v)] = SCANCODE_V;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(w)] = SCANCODE_W;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(x)] = SCANCODE_X;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(y)] = SCANCODE_Y;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(z)] = SCANCODE_Z;\n+\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(A)] = SCANCODE_A;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(B)] = SCANCODE_B;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(C)] = SCANCODE_C;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(D)] = SCANCODE_D;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(E)] = SCANCODE_E;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(F)] = SCANCODE_F;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(G)] = SCANCODE_G;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(H)] = SCANCODE_H;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(I)] = SCANCODE_I;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(J)] = SCANCODE_J;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(K)] = SCANCODE_K;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(L)] = SCANCODE_L;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(M)] = SCANCODE_M;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(N)] = SCANCODE_N;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(O)] = SCANCODE_O;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(P)] = SCANCODE_P;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(Q)] = SCANCODE_Q;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(R)] = SCANCODE_R;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(S)] = SCANCODE_S;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(T)] = SCANCODE_T;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(U)] = SCANCODE_U;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(V)] = SCANCODE_V;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(W)] = SCANCODE_W;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(X)] = SCANCODE_X;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(Y)] = SCANCODE_Y;\n+    keyval_to_scancode[GLASS_GDK_KEY_CONSTANT(Z)] = SCANCODE_Z;\n+\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_NUMPAD0] = GLASS_GDK_KEY_CONSTANT(KP_Insert);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_NUMPAD1] = GLASS_GDK_KEY_CONSTANT(KP_End);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_NUMPAD2] = GLASS_GDK_KEY_CONSTANT(KP_Down);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_NUMPAD3] = GLASS_GDK_KEY_CONSTANT(KP_Page_Down);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_NUMPAD4] = GLASS_GDK_KEY_CONSTANT(KP_Left);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_NUMPAD5] = GLASS_GDK_KEY_CONSTANT(KP_Begin);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_NUMPAD6] = GLASS_GDK_KEY_CONSTANT(KP_Right);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_NUMPAD7] = GLASS_GDK_KEY_CONSTANT(KP_Home);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_NUMPAD8] = GLASS_GDK_KEY_CONSTANT(KP_Up);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_NUMPAD9] = GLASS_GDK_KEY_CONSTANT(KP_Page_Up);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_DECIMAL] = GLASS_GDK_KEY_CONSTANT(KP_Delete);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_WINDOWS] = GLASS_GDK_KEY_CONSTANT(Super_L);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_CONTEXT_MENU] = GLASS_GDK_KEY_CONSTANT(Menu);\n+    robot_java_to_keyval[com_sun_glass_events_KeyEvent_VK_CLEAR] = GLASS_GDK_KEY_CONSTANT(KP_Begin);\n+\n+    \/\/ javafx\/scene\/input\/KeyCode.java\n+    robot_java_to_keyval[0xE0] = GLASS_GDK_KEY_CONSTANT(KP_Up);    \/\/ Numpad Up\n+    robot_java_to_keyval[0xE1] = GLASS_GDK_KEY_CONSTANT(KP_Down);  \/\/ Numpad Down\n+    robot_java_to_keyval[0xE2] = GLASS_GDK_KEY_CONSTANT(KP_Left);  \/\/ Numpad Left\n+    robot_java_to_keyval[0xE3] = GLASS_GDK_KEY_CONSTANT(KP_Right); \/\/ Numpad Right\n+}\n+\n@@ -281,0 +364,5 @@\n+\n+    if (isRemoteDesktop && !key_initialized_remote_desktop) {\n+        initialize_key_remote_desktop();\n+        key_initialized_remote_desktop = TRUE;\n+    }\n@@ -348,0 +436,1 @@\n+    init_keymap();\n@@ -356,1 +445,0 @@\n-    init_keymap();\n@@ -367,0 +455,9 @@\n+gint find_scancode_for_gdk_keyval(gint keyval) {\n+    init_keymap();\n+    auto i = keyval_to_scancode.find(keyval);\n+    if (i != keyval_to_scancode.end()) {\n+        return i->second;\n+    }\n+    return -1;\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_key.cpp","additions":98,"deletions":1,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n@@ -38,0 +41,4 @@\n+gint find_scancode_for_gdk_keyval(gint keyval);\n+#ifdef __cplusplus\n+}\n+#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/glass_key.h","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SCANCODES_H\n+#define SCANCODES_H\n+\n+#define SCANCODE_A 30\n+#define SCANCODE_B 48\n+#define SCANCODE_C 46\n+#define SCANCODE_D 32\n+#define SCANCODE_E 18\n+#define SCANCODE_F 33\n+#define SCANCODE_G 34\n+#define SCANCODE_H 35\n+#define SCANCODE_I 23\n+#define SCANCODE_J 36\n+#define SCANCODE_K 37\n+#define SCANCODE_L 38\n+#define SCANCODE_M 50\n+#define SCANCODE_N 49\n+#define SCANCODE_O 24\n+#define SCANCODE_P 25\n+#define SCANCODE_Q 16\n+#define SCANCODE_R 19\n+#define SCANCODE_S 31\n+#define SCANCODE_T 20\n+#define SCANCODE_U 22\n+#define SCANCODE_V 47\n+#define SCANCODE_W 17\n+#define SCANCODE_X 45\n+#define SCANCODE_Y 21\n+#define SCANCODE_Z 44\n+\n+#endif \/\/SCANCODES_H\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/scancodes.h","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include <X11\/Xlib.h>\n@@ -32,1 +33,65 @@\n-#include \"fp_pipewire.h\"\n+#include \"glass_key.h\"\n+\n+#define JNU_CHECK_EXCEPTION_RETURN(env, y)      \\\n+    do {                                        \\\n+        if ((*env)->ExceptionCheck(env)) {      \\\n+            return (y);                         \\\n+        }                                       \\\n+    } while (0)\n+\n+struct pw_buffer *(*fp_pw_stream_dequeue_buffer)(struct pw_stream *stream);\n+const char * (*fp_pw_stream_state_as_string)(enum pw_stream_state state);\n+int (*fp_pw_stream_queue_buffer)(struct pw_stream *stream,\n+                                 struct pw_buffer *buffer);\n+int (*fp_pw_stream_set_active)(struct pw_stream *stream, bool active);\n+\n+int (*fp_pw_stream_connect)(\n+        struct pw_stream *stream,\n+        enum pw_direction direction,\n+        uint32_t target_id,\n+        enum pw_stream_flags flags,\n+        const struct spa_pod **params,\n+        uint32_t n_params);\n+\n+struct pw_stream *(*fp_pw_stream_new)(\n+        struct pw_core *core,\n+        const char *name,\n+        struct pw_properties *props\n+);\n+void (*fp_pw_stream_add_listener)(struct pw_stream *stream,\n+                            struct spa_hook *listener,\n+                            const struct pw_stream_events *events,\n+                            void *data);\n+int (*fp_pw_stream_disconnect)(struct pw_stream *stream);\n+void (*fp_pw_stream_destroy)(struct pw_stream *stream);\n+\n+\n+void (*fp_pw_init)(int *argc, char **argv[]);\n+\n+struct pw_core *\n+(*fp_pw_context_connect_fd)(struct pw_context *context,\n+                      int fd,\n+                      struct pw_properties *properties,\n+                      size_t user_data_size);\n+\n+int (*fp_pw_core_disconnect)(struct pw_core *core);\n+\n+struct pw_context * (*fp_pw_context_new)(struct pw_loop *main_loop,\n+                                   struct pw_properties *props,\n+                                   size_t user_data_size);\n+\n+struct pw_thread_loop *\n+(*fp_pw_thread_loop_new)(const char *name, const struct spa_dict *props);\n+struct pw_loop * (*fp_pw_thread_loop_get_loop)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_signal)(struct pw_thread_loop *loop,\n+                                 bool wait_for_accept);\n+void (*fp_pw_thread_loop_wait)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_accept)(struct pw_thread_loop *loop);\n+int (*fp_pw_thread_loop_start)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_stop)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_destroy)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_lock)(struct pw_thread_loop *loop);\n+void (*fp_pw_thread_loop_unlock)(struct pw_thread_loop *loop);\n+\n+struct pw_properties * (*fp_pw_properties_new)(const char *key, ...);\n+\n@@ -49,0 +114,1 @@\n+gboolean isRemoteDesktop = FALSE;\n@@ -53,5 +119,0 @@\n-#if defined(AIX) && defined(__open_xl_version__) && __open_xl_version__ >= 17\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n-#endif\n-\n@@ -139,1 +200,1 @@\n-static gboolean initScreencast(const gchar *token,\n+static gboolean initPortal(const gchar *token,\n@@ -166,2 +227,2 @@\n-        || (pw.pwFd = getPipewireFd(token,\n-                                    affectedBounds,\n+        || !initAndStartSession(token, &pw.pwFd)\n+        || (pw.pwFd = getPipewireFd(affectedBounds,\n@@ -791,1 +852,1 @@\n- * Signature: (Z)Z\n+ * Signature: (IZ)Z\n@@ -794,1 +855,1 @@\n-        JNIEnv *env, jclass cls, jboolean screencastDebug\n+        JNIEnv *env, jclass cls, jint method, jboolean screencastDebug\n@@ -798,0 +859,9 @@\n+    if (method != XDG_METHOD_SCREENCAST\n+        && method != XDG_METHOD_REMOTE_DESKTOP) {\n+        return JNI_FALSE;\n+    }\n+\n+    isRemoteDesktop = method == XDG_METHOD_REMOTE_DESKTOP;\n+\n+    DEBUG_SCREENCAST(\"method %d\\n\", method)\n+\n@@ -870,1 +940,1 @@\n-    if (!initScreencast(token, affectedScreenBounds, affectedBoundsLength)) {\n+    if (!initPortal(token, affectedScreenBounds, affectedBoundsLength)) {\n@@ -940,0 +1010,1 @@\n+    JNU_CHECK_EXCEPTION_RETURN(env, RESULT_ERROR);\n@@ -942,1 +1013,1 @@\n-            \"taking screenshot at \\n\\tx: %5i y %5i w %5i h %5i with token |%s|\\n\",\n+            \"taking screenshot at \\n\\tx: %5i y %5i w %5i h %5i\\n\\twith token |%s|\\n\",\n@@ -1031,0 +1102,166 @@\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_screencast_ScreencastHelper\n+ * Method:    remoteDesktopMouseMove\n+ * Signature: (IILjava\/lang\/String;)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_screencast_ScreencastHelper_remoteDesktopMouseMoveImpl\n+        (JNIEnv *env, jclass cls, jint jx, jint jy, jstring jtoken) {\n+\n+\n+    const gchar *token = jtoken\n+                         ? (*env)->GetStringUTFChars(env, jtoken, NULL)\n+                         : NULL;\n+    JNU_CHECK_EXCEPTION_RETURN(env, RESULT_ERROR);\n+\n+    DEBUG_SCREENCAST(\"moving mouse to\\n\\t%d %d\\n\\twith token |%s|\\n\", jx, jy, token);\n+\n+    gboolean result = initPortal(token, NULL, 0);\n+    DEBUG_SCREENCAST(\"init result %b, moving to %d %d\\n\", result, jx, jy)\n+\n+    if (result) {\n+        if (!remoteDesktopMouseMove(jx, jy)) {\n+            releaseToken(env, jtoken, token);\n+            return RESULT_DENIED;\n+        }\n+    }\n+\n+    releaseToken(env, jtoken, token);\n+\n+    return result ? RESULT_OK : pw.pwFd;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_screencast_ScreencastHelper\n+ * Method:    remoteDesktopMouseButtonImpl\n+ * Signature: (ZILjava\/lang\/String;)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_screencast_ScreencastHelper_remoteDesktopMouseButtonImpl\n+        (JNIEnv *env, jclass cls, jboolean isPress, jint buttons, jstring jtoken) {\n+\n+    const gchar *token = jtoken\n+                         ? (*env)->GetStringUTFChars(env, jtoken, NULL)\n+                         : NULL;\n+    JNU_CHECK_EXCEPTION_RETURN(env, RESULT_ERROR);\n+\n+    gboolean result = initPortal(token, NULL, 0);\n+    DEBUG_SCREENCAST(\"init result %b, mouse pressing %d, buttons %d\\n\", result, isPress, buttons)\n+\n+    if (result) {\n+        if (!remoteDesktopMouse(isPress, buttons)) {\n+            releaseToken(env, jtoken, token);\n+            return RESULT_DENIED;\n+        }\n+    }\n+\n+    releaseToken(env, jtoken, token);\n+\n+    return result ? RESULT_OK : pw.pwFd;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_screencast_ScreencastHelper\n+ * Method:    remoteDesktopMouseWheelImpl\n+ * Signature: (ILjava\/lang\/String;)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_screencast_ScreencastHelper_remoteDesktopMouseWheelImpl\n+        (JNIEnv *env, jclass cls, jint jWheelAmt, jstring jtoken) {\n+\n+    const gchar *token = jtoken\n+                         ? (*env)->GetStringUTFChars(env, jtoken, NULL)\n+                         : NULL;\n+    JNU_CHECK_EXCEPTION_RETURN(env, RESULT_ERROR);\n+\n+    gboolean result = initPortal(token, NULL, 0);\n+    DEBUG_SCREENCAST(\"init result %b, mouse wheel %d\\n\", result, jWheelAmt)\n+\n+    if (result) {\n+        if (!remoteDesktopMouseWheel(jWheelAmt)) {\n+            releaseToken(env, jtoken, token);\n+            return RESULT_DENIED;\n+        }\n+    }\n+\n+    releaseToken(env, jtoken, token);\n+\n+    return result ? RESULT_OK : pw.pwFd;\n+}\n+\n+\n+static int getLettersScancode(gint gdk_keyval) {\n+    int keycode = find_gdk_keycode_for_keyval(gdk_keyval);\n+    if (keycode == -1) {\n+        return -1;\n+    }\n+\n+    \/\/ Gdk keyval and Xlib keysym shares the same value for variables\n+    \/\/ This find_gdk_keycode_for_keyval > XKeycodeToKeysym trick\n+    \/\/ allows us to map the actual keyboard layout to QWERTY\n+    \/\/ and get its scancode later on.\n+    \/\/ (e.g. QWERTZ Z-Y swap)\n+    KeySym ks = XKeycodeToKeysym(gdk_x11_get_default_xdisplay(), keycode, 0);\n+\n+    if (ks == NoSymbol) {\n+        return -1;\n+    }\n+\n+    return find_scancode_for_gdk_keyval(ks);\n+}\n+\n+static int keyButton(jint jkey, gboolean *isKeyval) {\n+    int keyval = find_gdk_keyval_for_glass_keycode(jkey);\n+    keyval = gdk_keyval_to_lower(keyval);\n+\n+    if (keyval >= GDK_KEY_a && keyval <= GDK_KEY_z) {\n+        \/\/ In most cases, simply calling NotifyKeyboardKeysym with the keyval would suffice.\n+        \/\/ However, for non-Latin layout letters, it does not work (e.g., Cyrillic).\n+        \/\/ But we can try pressing the key by its scancode.\n+\n+        int keyCode = getLettersScancode(keyval);\n+        if (keyCode > 0) {\n+            *isKeyval = FALSE;\n+            return keyCode;\n+        }\n+    }\n+\n+    *isKeyval = TRUE;\n+    return keyval;\n+}\n+\n+\/*\n+ * Class:     com_sun_glass_ui_gtk_screencast_ScreencastHelper\n+ * Method:    remoteDesktopKeyImpl\n+ * Signature: (ZILjava\/lang\/String;)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_com_sun_glass_ui_gtk_screencast_ScreencastHelper_remoteDesktopKeyImpl\n+        (JNIEnv *env, jclass cls, jboolean isPress, jint jkey, jstring jtoken) {\n+\n+    gboolean isKeyval = TRUE;\n+    int key = keyButton(jkey, &isKeyval);\n+\n+    if (key < 0 || (*env)->ExceptionCheck(env)) {\n+        DEBUG_SCREENCAST(\"failed to find a key: jkey %d -> %d isPress %b\\n\",\n+                         jkey, key, isPress)\n+        return RESULT_ERROR;\n+    }\n+\n+    const gchar *token = jtoken\n+                         ? (*env)->GetStringUTFChars(env, jtoken, NULL)\n+                         : NULL;\n+    JNU_CHECK_EXCEPTION_RETURN(env, RESULT_ERROR);\n+\n+    gboolean result = initPortal(token, NULL, 0);\n+    DEBUG_SCREENCAST(\"init result %b, jkey %d -> %d isKeyval %d isPress %b\\n\",\n+                     result, isKeyval, jkey, key, isPress)\n+\n+    if (result) {\n+        if (!remoteDesktopKey(isPress, isKeyval, key)) {\n+            releaseToken(env, jtoken, token);\n+            return RESULT_DENIED;\n+        }\n+    }\n+\n+    releaseToken(env, jtoken, token);\n+\n+    return result ? RESULT_OK : pw.pwFd;\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/screencast_pipewire.c","additions":251,"deletions":14,"binary":false,"changes":265,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,2 @@\n+void print_gvariant_content(gchar *caption, GVariant *response);\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/screencast_pipewire.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-#include <sys\/stat.h>\n-#include <fcntl.h>\n@@ -34,2 +32,1 @@\n-#include <pwd.h>\n-#include <unistd.h>\n+\n@@ -38,0 +35,1 @@\n+#include <com_sun_glass_ui_GlassRobot.h>\n@@ -39,0 +37,1 @@\n+extern gboolean isRemoteDesktop;\n@@ -43,0 +42,5 @@\n+extern int DEBUG_SCREENCAST_ENABLED;\n+\n+GDBusProxy *getProxy() {\n+    return isRemoteDesktop ? portal->remoteDesktopProxy : portal->screenCastProxy;\n+}\n@@ -152,2 +156,3 @@\n- * Checks screencast protocol version\n- * @return FALSE if version < 4, or could not be determined\n+ * Checks the version of the Screencast\/Remote Desktop protocol\n+ * to determine whether it supports the restore_token.\n+ * @return FALSE if version is below required, or could not be determined\n@@ -157,0 +162,5 @@\n+\n+    const gchar *interface = isRemoteDesktop\n+            ? PORTAL_IFACE_REMOTE_DESKTOP\n+            : PORTAL_IFACE_SCREENCAST;\n+\n@@ -159,0 +169,1 @@\n+\n@@ -160,1 +171,1 @@\n-                portal->screenCastProxy,\n+                getProxy(),\n@@ -163,1 +174,1 @@\n-                                   \"org.freedesktop.portal.ScreenCast\",\n+                                   interface,\n@@ -169,0 +180,6 @@\n+        if (isRemoteDesktop) {\n+            print_gvariant_content(\"checkVersion Remote Desktop\", retVersion);\n+        } else {\n+            print_gvariant_content(\"checkVersion ScreenCast\", retVersion);\n+        }\n+\n@@ -170,2 +187,1 @@\n-            DEBUG_SCREENCAST(\"!!! could not detect the screencast version\\n\",\n-                             NULL);\n+            DEBUG_SCREENCAST(\"!!! could not detect the %s version\\n\", interface);\n@@ -182,2 +198,1 @@\n-            DEBUG_SCREENCAST(\"!!! could not get the screencast version\\n\",\n-                             NULL);\n+            DEBUG_SCREENCAST(\"!!! could not get the %s version\\n\", interface);\n@@ -194,3 +209,6 @@\n-    DEBUG_SCREENCAST(\"ScreenCast protocol version %d\\n\", version);\n-    if (version < 4) {\n-        DEBUG_SCREENCAST(\"!!! ScreenCast protocol version %d < 4,\"\n+    gboolean isVersionOk = isRemoteDesktop\n+            ? version >= PORTAL_MIN_VERSION_REMOTE_DESKTOP\n+            : version >= PORTAL_MIN_VERSION_SCREENCAST;\n+\n+    if (!isVersionOk) {\n+        DEBUG_SCREENCAST(\"!!! %s protocol version %d < %d,\"\n@@ -198,1 +216,6 @@\n-                         version);\n+                         interface,\n+                         version,\n+                         isRemoteDesktop\n+                             ? PORTAL_MIN_VERSION_REMOTE_DESKTOP\n+                             : PORTAL_MIN_VERSION_SCREENCAST\n+                         );\n@@ -201,3 +224,1 @@\n-    \/\/ restore_token was added in version 4, without it,\n-    \/\/ user confirmation is required for every screenshot.\n-    return version >= 4;\n+    return isVersionOk;\n@@ -254,3 +275,3 @@\n-            \"org.freedesktop.portal.Desktop\",\n-            \"\/org\/freedesktop\/portal\/desktop\",\n-            \"org.freedesktop.portal.ScreenCast\",\n+            PORTAL_DESKTOP_BUS_NAME,\n+            PORTAL_DESKTOP_OBJECT_PATH,\n+            PORTAL_IFACE_SCREENCAST,\n@@ -265,0 +286,23 @@\n+    } else {\n+        DEBUG_SCREENCAST(\"%s: connection\/sender name %s \/ %s\\n\",\n+                         \"ScreenCast\", name,\n+                         portal->senderName);\n+    }\n+\n+    if (isRemoteDesktop) {\n+        portal->remoteDesktopProxy = g_dbus_proxy_new_sync(\n+                portal->connection,\n+                G_DBUS_PROXY_FLAGS_NONE,\n+                NULL,\n+                PORTAL_DESKTOP_BUS_NAME,\n+                PORTAL_DESKTOP_OBJECT_PATH,\n+                PORTAL_IFACE_REMOTE_DESKTOP,\n+                NULL,\n+                &err\n+        );\n+\n+        if (err) {\n+            DEBUG_SCREENCAST(\"Failed to get Remote Desktop portal: %s\", err->message);\n+            ERR_HANDLE(err);\n+            return FALSE;\n+        }\n@@ -334,2 +378,2 @@\n-            \"org.freedesktop.portal.Desktop\",\n-            \"org.freedesktop.portal.Request\",\n+            PORTAL_DESKTOP_BUS_NAME,\n+            PORTAL_IFACE_REQUEST,\n@@ -380,1 +424,2 @@\n-        g_variant_lookup(result, \"session_handle\", \"s\", helper->data);\n+        gboolean returned = g_variant_lookup(result, \"session_handle\", \"s\", helper->data);\n+        DEBUG_SCREENCAST(\"session_handle returned %b %p\\n\", returned, helper->data)\n@@ -427,0 +472,3 @@\n+\n+    DEBUG_SCREENCAST(\"sessionToken %s \\n\", sessionToken)\n+\n@@ -434,0 +482,6 @@\n+    DEBUG_SCREENCAST(\"portalScreenCastCreateSession: proxy %s %p (rd: %p \/ sc: %p)\\n\",\n+                     isRemoteDesktop ? \"remoteDesktop\" : \"screencast\",\n+                     getProxy(),\n+                     portal->remoteDesktopProxy,\n+                     portal->screenCastProxy);\n+\n@@ -435,1 +489,1 @@\n-            portal->screenCastProxy,\n+            getProxy(),\n@@ -444,0 +498,2 @@\n+    print_gvariant_content(\"CreateSession\", response);\n+\n@@ -452,0 +508,2 @@\n+    DEBUG_SCREENCAST(\"portal->screenCastSessionHandle %s\\n\", portal->screenCastSessionHandle);\n+\n@@ -496,0 +554,33 @@\n+static void callbackRemoteDesktopSelectDevices(\n+        GDBusConnection *connection,\n+        const char *senderName,\n+        const char *objectPath,\n+        const char *interfaceName,\n+        const char *signalName,\n+        GVariant *parameters,\n+        void *data\n+) {\n+    struct DBusCallbackHelper *helper = data;\n+\n+    helper->data = (void *) 0;\n+\n+    uint32_t status;\n+    GVariant* result = NULL;\n+\n+    g_variant_get(parameters, \"(u@a{sv})\", &status, &result);\n+\n+    if (status != 0) {\n+        DEBUG_SCREENCAST(\"Failed select devices: %u\\n\", status);\n+    } else {\n+        helper->data = (void *) 1;\n+    }\n+\n+    helper->isDone = TRUE;\n+\n+    if (result) {\n+        g_variant_unref(result);\n+    }\n+\n+    gtk_main_quit();\n+}\n+\n@@ -541,0 +632,3 @@\n+    \/\/ In the case of Remote Desktop,\n+    \/\/ we add the restore_token and persist_mode to the SelectDevices call.\n+\n@@ -544,8 +638,1 @@\n-    g_variant_builder_add(\n-            &builder,\n-            \"{sv}\",\n-            \"persist_mode\",\n-            g_variant_new_uint32(2)\n-    );\n-\n-    if (validateToken(token)) {\n+    if (!isRemoteDesktop) {\n@@ -555,2 +642,2 @@\n-                \"restore_token\",\n-                g_variant_new_string(token)\n+                \"persist_mode\",\n+                g_variant_new_uint32(2)\n@@ -560,0 +647,12 @@\n+    if (!isRemoteDesktop) {\n+        if (validateToken(token)) {\n+            DEBUG_SCREENCAST(\">>> adding token %s\\n\", token);\n+            g_variant_builder_add(\n+                    &builder,\n+                    \"{sv}\",\n+                    \"restore_token\",\n+                    g_variant_new_string(token)\n+            );\n+        }\n+    }\n+\n@@ -570,0 +669,2 @@\n+    print_gvariant_content(\"SelectSources\", response);\n+\n@@ -621,0 +722,10 @@\n+    print_gvariant_content(\"Streams\", streams);\n+\n+    if (!streams) {\n+        DEBUG_SCREENCAST(\"No streams available with current token\\n\",  NULL);\n+        startHelper->result = RESULT_NO_STREAMS;\n+        helper->isDone = TRUE;\n+        gtk_main_quit();\n+        return;\n+    }\n+\n@@ -657,3 +768,1 @@\n-    if (streams) {\n-        g_variant_unref(streams);\n-    }\n+    g_variant_unref(streams);\n@@ -702,1 +811,1 @@\n-            portal->screenCastProxy,\n+            getProxy(),\n@@ -711,0 +820,2 @@\n+    print_gvariant_content(\"Start\", response);\n+\n@@ -804,1 +915,1 @@\n-                \"org.freedesktop.portal.Desktop\",\n+                PORTAL_DESKTOP_BUS_NAME,\n@@ -806,1 +917,1 @@\n-                \"org.freedesktop.portal.Session\",\n+                PORTAL_IFACE_SESSION,\n@@ -885,0 +996,98 @@\n+gboolean remoteDesktopSelectDevicesIfNeeded(const gchar* token) {\n+    if (!isRemoteDesktop || !portal->remoteDesktopProxy) {\n+        DEBUG_SCREENCAST(\"Skipping, remote desktop is not selected \\n\", NULL);\n+        return TRUE;\n+    }\n+\n+    GError* err = NULL;\n+\n+    gchar *requestPath = NULL;\n+    gchar *requestToken = NULL;\n+\n+    struct DBusCallbackHelper helper = {0};\n+\n+\n+    updateRequestPath(\n+            &requestPath,\n+            &requestToken\n+    );\n+\n+    registerScreenCastCallback(\n+            requestPath,\n+            &helper,\n+            callbackRemoteDesktopSelectDevices\n+    );\n+\n+    GVariantBuilder builder;\n+\n+    g_variant_builder_init(\n+            &builder,\n+            G_VARIANT_TYPE_VARDICT\n+    );\n+\n+    g_variant_builder_add(\n+            &builder,\n+            \"{sv}\", \"handle_token\",\n+            g_variant_new_string(requestToken)\n+    );\n+\n+    \/\/ 1: KEYBOARD\n+    \/\/ 2: POINTER\n+    \/\/ 4: TOUCHSCREEN\n+    g_variant_builder_add(\n+            &builder, \"{sv}\", \"types\",\n+            g_variant_new_uint32(1 | 2)\n+    );\n+\n+    \/\/ 0: Do not persist (default)\n+    \/\/ 1: Permissions persist as long as the application is running\n+    \/\/ 2: Permissions persist until explicitly revoked\n+    g_variant_builder_add(\n+            &builder,\n+            \"{sv}\",\n+            \"persist_mode\",\n+            g_variant_new_uint32(2)\n+    );\n+\n+    if (validateToken(token)) {\n+        g_variant_builder_add(\n+                &builder,\n+                \"{sv}\",\n+                \"restore_token\",\n+                g_variant_new_string(token)\n+        );\n+    }\n+\n+    GVariant *response = g_dbus_proxy_call_sync(\n+            portal->remoteDesktopProxy,\n+            \"SelectDevices\",\n+            g_variant_new(\"(oa{sv})\", portal->screenCastSessionHandle, &builder),\n+            G_DBUS_CALL_FLAGS_NONE,\n+            -1,\n+            NULL,\n+            &err\n+    );\n+\n+    print_gvariant_content(\"SelectDevices\", response);\n+\n+    if (err) {\n+        DEBUG_SCREENCAST(\"Failed to call SelectDevices: %s\\n\", err->message);\n+        ERR_HANDLE(err);\n+    } else {\n+        gtk_main();\n+    }\n+\n+    unregisterScreenCastCallback(&helper);\n+    if (response) {\n+        g_variant_unref(response);\n+    }\n+\n+    free(requestPath);\n+    free(requestToken);\n+\n+    return helper.data != NULL;\n+}\n+\n+gboolean initAndStartSession(const gchar *token, int *retVal) {\n+\n+    *retVal = RESULT_ERROR;\n@@ -886,3 +1095,0 @@\n-int getPipewireFd(const gchar *token,\n-                  GdkRectangle *affectedBounds,\n-                  gint affectedBoundsLength) {\n@@ -891,1 +1097,1 @@\n-        return RESULT_ERROR;\n+        return FALSE;\n@@ -896,1 +1102,5 @@\n-        return RESULT_ERROR;\n+        return FALSE;\n+    }\n+\n+    if (!remoteDesktopSelectDevicesIfNeeded(token)) {\n+        return FALSE;\n@@ -901,0 +1111,1 @@\n+\n@@ -902,10 +1113,17 @@\n-        DEBUG_SCREENCAST(\"Failed to start\\n\", NULL);\n-        return startResult;\n-    } else {\n-        if (!checkCanCaptureAllRequiredScreens(affectedBounds,\n-                                               affectedBoundsLength)) {\n-            DEBUG_SCREENCAST(\"The location of the screens has changed, \"\n-                             \"the capture area is outside the allowed \"\n-                             \"area.\\n\", NULL)\n-            return RESULT_OUT_OF_BOUNDS;\n-        }\n+        DEBUG_SCREENCAST(\"Failed to start %d\\n\", startResult);\n+        *retVal = startResult;\n+        return FALSE;\n+    }\n+\n+    *retVal = RESULT_OK;\n+    return TRUE;\n+}\n+\n+int getPipewireFd(GdkRectangle *affectedBounds,\n+                  gint affectedBoundsLength) {\n+    if (!checkCanCaptureAllRequiredScreens(affectedBounds,\n+                                           affectedBoundsLength)) {\n+        DEBUG_SCREENCAST(\"The location of the screens has changed, \"\n+                         \"the capture area is outside the allowed \"\n+                         \"area.\\n\", NULL)\n+        return RESULT_OUT_OF_BOUNDS;\n@@ -924,0 +1142,181 @@\n+\n+\n+void print_gvariant_content(gchar *caption, GVariant *response) {\n+    if (!DEBUG_SCREENCAST_ENABLED) {\n+        return;\n+    }\n+\n+    gchar *str = NULL;\n+    if (response != NULL) {\n+        str = g_variant_print(response, TRUE);\n+    }\n+\n+    DEBUG_SCREENCAST(\"%s response:\\n\\t%s\\n\",\n+                     caption, str);\n+\n+    g_free(str);\n+}\n+\n+static gboolean callRemoteDesktop(const gchar* methodName, GVariant *params) {\n+    GError *err = NULL;\n+    GVariantBuilder builder;\n+    g_variant_builder_init (&builder, G_VARIANT_TYPE_VARDICT);\n+\n+    GVariant *response = g_dbus_proxy_call_sync(\n+            portal->remoteDesktopProxy,\n+            methodName,\n+            params,\n+            G_DBUS_CALL_FLAGS_NONE,\n+            -1,\n+            NULL,\n+            &err\n+    );\n+\n+    gchar * caption = g_strconcat(\"callRemoteDesktop \", methodName, NULL);\n+    print_gvariant_content(caption, response);\n+    g_free(caption);\n+\n+    DEBUG_SCREENCAST(\"%s: response %p err %p\\n\", methodName, response, err);\n+\n+    if (err) {\n+        DEBUG_SCREENCAST(\"Failed to call %s: %s\\n\", methodName, err->message);\n+        ERR_HANDLE(err);\n+\n+        \/\/ e.g. user denied mouse keyboard\/interaction\n+        return FALSE;\n+    }\n+\n+    return TRUE;\n+}\n+\n+void clampCoordsIfNeeded(int *x, int *y) {\n+    if (screenSpace.screenCount <= 0 || x == NULL || y == NULL) {\n+        return;\n+    }\n+\n+    GdkRectangle s0 = screenSpace.screens[0].bounds;\n+    int minX = s0.x;\n+    int minY = s0.y;\n+    int maxX = s0.x + s0.width;\n+    int maxY = s0.y + s0.height;\n+\n+    for (int i = 1; i < screenSpace.screenCount; ++i) {\n+        GdkRectangle s = screenSpace.screens[i].bounds;\n+        if (s.x < minX) minX = s.x;\n+        if (s.y < minY) minY = s.y;\n+        if (s.x + s.width > maxX) maxX = s.x + s.width;\n+        if (s.y + s.height > maxY) maxY = s.y + s.height;\n+    }\n+\n+    if (*x < minX) {\n+        *x = minX;\n+    } else if (*x > maxX) {\n+        *x = maxX - 1;\n+    }\n+\n+    if (*y < minY) {\n+        *y = minY;\n+    } else if (*y > maxY) {\n+        *y = maxY - 1;\n+    }\n+}\n+\n+gboolean remoteDesktopMouseMove(int x, int y) {\n+    guint32 streamId = 0;\n+    int relX = -1;\n+    int relY = -1;\n+\n+    DEBUG_SCREENCAST(\"mouseMove %d %d\\n\", x, y);\n+    clampCoordsIfNeeded(&x, &y);\n+    DEBUG_SCREENCAST(\"after clamping %d %d\\n\", x, y);\n+\n+    for (int i = 0; i < screenSpace.screenCount; ++i) {\n+        struct ScreenProps *screenProps = &screenSpace.screens[i];\n+        GdkRectangle rect = screenProps->bounds;\n+\n+        if (x >= rect.x &&\n+             y >= rect.y &&\n+             x <  rect.x + rect.width &&\n+             y <  rect.y + rect.height) {\n+            streamId = screenProps->id;\n+            relX = x - rect.x;\n+            relY = y - rect.y;\n+\n+            DEBUG_SCREENCAST(\"screenId#%i point %dx%d (rel %i %i) inside of screen (%d, %d, %d, %d)\\n\",\n+                             streamId,\n+                             x, y, relX, relY,\n+                             rect.x, rect.y, rect.width, rect.height);\n+\n+            break;\n+        }\n+    }\n+\n+    if (streamId == 0) {\n+        DEBUG_SCREENCAST(\"outside of available screens\\n\", NULL);\n+        return TRUE;\n+    }\n+\n+    GVariantBuilder builder;\n+    g_variant_builder_init (&builder, G_VARIANT_TYPE_VARDICT);\n+    GVariant *params = g_variant_new(\"(oa{sv}udd)\", portal->screenCastSessionHandle, &builder,\n+                                          streamId, (double) relX, (double) relY);\n+    return callRemoteDesktop(\"NotifyPointerMotionAbsolute\", params);\n+}\n+\n+gboolean callRemoteDesktopNotifyPointerButton(gboolean isPress, int evdevButton) {\n+    DEBUG_SCREENCAST(\"isPress %d evdevButton %d\\n\", isPress, evdevButton);\n+\n+    GVariantBuilder builder;\n+    g_variant_builder_init(&builder, G_VARIANT_TYPE_VARDICT);\n+    GVariant *params = g_variant_new(\"(oa{sv}iu)\",\n+                                          portal->screenCastSessionHandle, &builder, evdevButton, isPress);\n+    return callRemoteDesktop(\"NotifyPointerButton\", params);\n+}\n+\n+gboolean remoteDesktopMouse(gboolean isPress, int buttons) {\n+    DEBUG_SCREENCAST(\"isPress %d awt buttons mask %d\\n\", isPress, buttons);\n+\n+    if (buttons & com_sun_glass_ui_GlassRobot_MOUSE_LEFT_BTN) {\n+        return callRemoteDesktopNotifyPointerButton(isPress, 0x110); \/\/ BTN_LEFT\n+    }\n+\n+    if (buttons & com_sun_glass_ui_GlassRobot_MOUSE_MIDDLE_BTN) {\n+        return callRemoteDesktopNotifyPointerButton(isPress, 0x112); \/\/ BTN_MIDDLE\n+    }\n+\n+    if (buttons & com_sun_glass_ui_GlassRobot_MOUSE_RIGHT_BTN) {\n+        return callRemoteDesktopNotifyPointerButton(isPress, 0x111); \/\/ BTN_RIGHT\n+    }\n+\n+    if (buttons & com_sun_glass_ui_GlassRobot_MOUSE_BACK_BTN) {\n+        return callRemoteDesktopNotifyPointerButton(isPress, 0x113); \/\/ BTN_SIDE\n+    }\n+\n+    if (buttons & com_sun_glass_ui_GlassRobot_MOUSE_FORWARD_BTN) {\n+        return callRemoteDesktopNotifyPointerButton(isPress, 0x114); \/\/ BTN_EXTRA\n+    }\n+\n+    return TRUE;\n+}\n+\n+gboolean remoteDesktopMouseWheel(int wheelAmt) {\n+    DEBUG_SCREENCAST(\"MouseWheel %d\\n\", wheelAmt);\n+\n+    GVariantBuilder builder;\n+    g_variant_builder_init(&builder, G_VARIANT_TYPE_VARDICT);\n+    GVariant *params = g_variant_new(\"(oa{sv}ui)\", portal->screenCastSessionHandle, &builder, 0, wheelAmt);\n+    return callRemoteDesktop(\"NotifyPointerAxisDiscrete\", params);\n+}\n+\n+gboolean remoteDesktopKey(gboolean isPress, gboolean isKeyval, int key) {\n+    DEBUG_SCREENCAST(\"Key%s isKeyval %d key %d -> \\n\", isPress ? \"Press\" : \"Release\", isKeyval, key);\n+\n+    GVariantBuilder builder;\n+    g_variant_builder_init(&builder, G_VARIANT_TYPE_VARDICT);\n+    GVariant *params = g_variant_new (\"(oa{sv}iu)\", portal->screenCastSessionHandle, &builder, key, isPress);\n+    if (isKeyval) {\n+        return callRemoteDesktop(\"NotifyKeyboardKeysym\", params);\n+    } else {\n+        return callRemoteDesktop(\"NotifyKeyboardKeycode\", params);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/screencast_portal.c","additions":457,"deletions":58,"binary":false,"changes":515,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,11 @@\n+#define PORTAL_DESKTOP_BUS_NAME \"org.freedesktop.portal.Desktop\"\n+#define PORTAL_DESKTOP_OBJECT_PATH \"\/org\/freedesktop\/portal\/desktop\"\n+\n+#define PORTAL_IFACE_REQUEST \"org.freedesktop.portal.Request\"\n+#define PORTAL_IFACE_SESSION \"org.freedesktop.portal.Session\"\n+#define PORTAL_IFACE_SCREENCAST \"org.freedesktop.portal.ScreenCast\"\n+#define PORTAL_IFACE_REMOTE_DESKTOP \"org.freedesktop.portal.RemoteDesktop\"\n+\n+#define PORTAL_MIN_VERSION_SCREENCAST 4\n+#define PORTAL_MIN_VERSION_REMOTE_DESKTOP 2\n+\n@@ -44,3 +55,2 @@\n-int getPipewireFd(const gchar *token,\n-                  GdkRectangle *affectedBounds,\n-                  gint affectedBoundsLength);\n+gboolean initAndStartSession(const gchar *token, int *retVal);\n+int getPipewireFd(GdkRectangle *affectedBounds, gint affectedBoundsLength);\n@@ -54,0 +64,5 @@\n+gboolean remoteDesktopMouseMove(int x, int y);\n+gboolean remoteDesktopMouseWheel(int wheelAmt);\n+gboolean remoteDesktopMouse(gboolean isPress, int buttons);\n+gboolean remoteDesktopKey(gboolean isPress, gboolean isKeyval, int key);\n+\n@@ -56,0 +71,1 @@\n+    GDBusProxy *remoteDesktopProxy;\n@@ -72,0 +88,1 @@\n+    RESULT_NO_STREAMS = -13,\n@@ -74,0 +91,5 @@\n+typedef enum {\n+    XDG_METHOD_SCREENCAST = 0,\n+    XDG_METHOD_REMOTE_DESKTOP = 1,\n+} XdgPortalMethod;\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/gtk\/screencast_portal.h","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"}]}