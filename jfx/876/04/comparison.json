{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -274,2 +274,1 @@\n-        MultipleSelectionModel<?> sm = getSelectionModel();\n-        boolean isAlreadySelected = sm.isSelected(index);\n+        boolean isAlreadySelected;\n@@ -277,3 +276,2 @@\n-        if (isAlreadySelected && shortcutDown) {\n-            sm.clearSelection(index);\n-            getFocusModel().focus(index);\n+        MultipleSelectionModel<?> sm = getSelectionModel();\n+        if (sm == null) {\n@@ -282,1 +280,9 @@\n-            sm.clearAndSelect(index);\n+            isAlreadySelected = sm.isSelected(index);\n+\n+            if (isAlreadySelected && shortcutDown) {\n+                sm.clearSelection(index);\n+                getFocusModel().focus(index);\n+                isAlreadySelected = false;\n+            } else {\n+                sm.clearAndSelect(index);\n+            }\n@@ -303,0 +309,4 @@\n+        if (getSelectionModel() == null) {\n+            return;\n+        }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/CellBehaviorBase.java","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,3 +203,1 @@\n-        final int row = getNode().getIndex();\n-        final TableColumnBase<S,T> column = getTableColumn();\n-        boolean isAlreadySelected = sm.isSelected(row, column);\n+        boolean isAlreadySelected;\n@@ -207,3 +205,1 @@\n-        if (isAlreadySelected && shortcutDown) {\n-            sm.clearSelection(row, column);\n-            getFocusModel().focus(row, (TC) column);\n+        if (sm == null) {\n@@ -212,2 +208,12 @@\n-            \/\/ we check if cell selection is enabled to fix RT-33897\n-            sm.clearAndSelect(row, column);\n+            final int row = getNode().getIndex();\n+            final TableColumnBase<S,T> column = getTableColumn();\n+            isAlreadySelected = sm.isSelected(row, column);\n+\n+            if (isAlreadySelected && shortcutDown) {\n+                sm.clearSelection(row, column);\n+                getFocusModel().focus(row, (TC) column);\n+                isAlreadySelected = false;\n+            } else {\n+                \/\/ we check if cell selection is enabled to fix RT-33897\n+                sm.clearAndSelect(row, column);\n+            }\n@@ -220,0 +226,1 @@\n+        \/\/ this method will not be called if selection model is null\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TableCellBehaviorBase.java","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import javafx.collections.FXCollections;\n@@ -117,1 +118,6 @@\n-        return getNode().getSelectionModel().getSelectedCells();\n+        TableViewSelectionModel<T> sm = getNode().getSelectionModel();\n+        if (sm == null) {\n+            return FXCollections.emptyObservableList();\n+        } else {\n+            return sm.getSelectedCells();\n+        }\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TableViewBehavior.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import javafx.collections.FXCollections;\n@@ -41,0 +42,1 @@\n+import javafx.scene.control.TreeTableView.TreeTableViewSelectionModel;\n@@ -124,1 +126,6 @@\n-        return getNode().getSelectionModel().getSelectedCells();\n+        TreeTableViewSelectionModel<T> sm = getNode().getSelectionModel();\n+        if (sm == null) {\n+            return FXCollections.observableArrayList();\n+        } else {\n+            return sm.getSelectedCells();\n+        }\n@@ -190,1 +197,2 @@\n-        if (getNode().getSelectionModel().isCellSelectionEnabled()) {\n+        TreeTableViewSelectionModel<T> sm = getNode().getSelectionModel();\n+        if ((sm != null) && sm.isCellSelectionEnabled()) {\n@@ -202,1 +210,2 @@\n-        if (getNode().getSelectionModel().isCellSelectionEnabled()) {\n+        TreeTableViewSelectionModel<T> sm = getNode().getSelectionModel();\n+        if ((sm != null) && sm.isCellSelectionEnabled()) {\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TreeTableViewBehavior.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -998,0 +998,1 @@\n+                oldValue.clearSelection();\n@@ -1570,2 +1571,4 @@\n-        final List<TablePosition> prevState = new ArrayList<>(getSelectionModel().getSelectedCells());\n-        final int itemCount = prevState.size();\n+        TableViewSelectionModel<S> selectionModel = getSelectionModel();\n+        final List<TablePosition> prevState = selectionModel == null ?\n+                null :\n+                new ArrayList<>(selectionModel.getSelectedCells());\n@@ -1576,1 +1579,3 @@\n-        getSelectionModel().startAtomic();\n+        if (selectionModel != null) {\n+            selectionModel.startAtomic();\n+        }\n@@ -1583,1 +1588,3 @@\n-        getSelectionModel().stopAtomic();\n+        if (selectionModel != null) {\n+            selectionModel.stopAtomic();\n+        }\n@@ -1596,2 +1603,2 @@\n-            if (getSelectionModel() instanceof TableViewArrayListSelectionModel) {\n-                final TableViewArrayListSelectionModel<S> sm = (TableViewArrayListSelectionModel<S>) getSelectionModel();\n+            if (selectionModel instanceof TableViewArrayListSelectionModel) {\n+                final TableViewArrayListSelectionModel<S> sm = (TableViewArrayListSelectionModel<S>)selectionModel;\n@@ -1601,4 +1608,5 @@\n-                for (int i = 0; i < itemCount; i++) {\n-                    TablePosition<S, ?> prevItem = prevState.get(i);\n-                    if (!newState.contains(prevItem)) {\n-                        removed.add(prevItem);\n+                if(prevState != null) {\n+                    for (TablePosition<S, ?> prevItem: prevState) {\n+                        if (!newState.contains(prevItem)) {\n+                            removed.add(prevItem);\n+                        }\n@@ -1614,0 +1622,1 @@\n+                    int itemCount = prevState == null ? 0 : prevState.size();\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TableView.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -442,1 +442,0 @@\n-        if (getTreeTableView().getSelectionModel() == null) return;\n@@ -444,2 +443,7 @@\n-        boolean isSelected = getTreeTableView().getSelectionModel().isSelected(index, null);\n-        if (isSelected() == isSelected) return;\n+        TreeTableViewSelectionModel<T> sm = getTreeTableView().getSelectionModel();\n+        if (sm == null) {\n+            if (isSelected()) {\n+                updateSelected(false);\n+            }\n+            return;\n+        }\n@@ -447,1 +451,4 @@\n-        updateSelected(isSelected);\n+        boolean isSelected = !sm.isCellSelectionEnabled() && sm.isSelected(index);\n+        if (isSelected() != isSelected) {\n+            updateSelected(isSelected);\n+        }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeTableRow.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1072,0 +1072,1 @@\n+                        oldValue.clearSelection();\n@@ -1081,1 +1082,6 @@\n-                    if (oldValue != null) {\n+                    if (oldValue == null) {\n+                        \/\/ show no focused rows with a null selection model\n+                        if (getFocusModel() != null) {\n+                            getFocusModel().setFocusedIndex(-1);\n+                        }\n+                    } else {\n@@ -1851,2 +1857,4 @@\n-        final List<TreeTablePosition<S,?>> prevState = new ArrayList<>(getSelectionModel().getSelectedCells());\n-        final int itemCount = prevState.size();\n+        TreeTableViewSelectionModel<S> selectionModel = getSelectionModel();\n+        final List<TreeTablePosition<S,?>> prevState = (selectionModel == null) ?\n+                null :\n+                new ArrayList<>(selectionModel.getSelectedCells());\n@@ -1857,1 +1865,3 @@\n-        getSelectionModel().startAtomic();\n+        if (selectionModel != null) {\n+            selectionModel.startAtomic();\n+        }\n@@ -1867,11 +1877,13 @@\n-        if (getSortMode() == TreeSortMode.ALL_DESCENDANTS) {\n-            Set<TreeItem<S>> sortedParents = new HashSet<>();\n-            for (TreeTablePosition<S,?> selectedPosition : prevState) {\n-                \/\/ This null check is not required ideally.\n-                \/\/ The selectedPosition.getTreeItem() should always return a valid TreeItem.\n-                \/\/ But, it is possible to be null due to JDK-8248217.\n-                if (selectedPosition.getTreeItem() != null) {\n-                    TreeItem<S> parent = selectedPosition.getTreeItem().getParent();\n-                    while (parent != null && sortedParents.add(parent)) {\n-                        parent.getChildren();\n-                        parent = parent.getParent();\n+        if (prevState != null) {\n+            if (getSortMode() == TreeSortMode.ALL_DESCENDANTS) {\n+                Set<TreeItem<S>> sortedParents = new HashSet<>();\n+                for (TreeTablePosition<S,?> selectedPosition : prevState) {\n+                    \/\/ This null check is not required ideally.\n+                    \/\/ The selectedPosition.getTreeItem() should always return a valid TreeItem.\n+                    \/\/ But, it is possible to be null due to JDK-8248217.\n+                    if (selectedPosition.getTreeItem() != null) {\n+                        TreeItem<S> parent = selectedPosition.getTreeItem().getParent();\n+                        while (parent != null && sortedParents.add(parent)) {\n+                            parent.getChildren();\n+                            parent = parent.getParent();\n+                        }\n@@ -1882,1 +1894,4 @@\n-        getSelectionModel().stopAtomic();\n+\n+        if (selectionModel != null) {\n+            selectionModel.stopAtomic();\n+        }\n@@ -1895,2 +1910,2 @@\n-            if (getSelectionModel() instanceof TreeTableViewArrayListSelectionModel) {\n-                final TreeTableViewArrayListSelectionModel<S> sm = (TreeTableViewArrayListSelectionModel<S>) getSelectionModel();\n+            if (selectionModel instanceof TreeTableViewArrayListSelectionModel) {\n+                final TreeTableViewArrayListSelectionModel<S> sm = (TreeTableViewArrayListSelectionModel<S>)selectionModel;\n@@ -1900,4 +1915,5 @@\n-                for (int i = 0; i < itemCount; i++) {\n-                    TreeTablePosition<S, ?> prevItem = prevState.get(i);\n-                    if (!newState.contains(prevItem)) {\n-                        removed.add(prevItem);\n+                if (prevState != null) {\n+                    for (TreeTablePosition<S, ?> prevItem: prevState) {\n+                        if (!newState.contains(prevItem)) {\n+                            removed.add(prevItem);\n+                        }\n@@ -1906,0 +1922,1 @@\n+\n@@ -1912,0 +1929,1 @@\n+                    int itemCount = prevState == null ? 0 : prevState.size();\n@@ -1916,2 +1934,6 @@\n-            getSelectionModel().setSelectedIndex(getRow(getSelectionModel().getSelectedItem()));\n-            getFocusModel().focus(getSelectionModel().getSelectedIndex());\n+\n+            if (selectionModel != null) {\n+                selectionModel.setSelectedIndex(getRow(selectionModel.getSelectedItem()));\n+            }\n+\n+            getFocusModel().focus(selectionModel == null ? -1 : selectionModel.getSelectedIndex());\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/TreeTableView.java","additions":46,"deletions":24,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,10 +150,14 @@\n-                \/\/ FIXME this could be optimised to iterate over cellsMap only\n-                \/\/ (selectedCells could be big, cellsMap is much smaller)\n-                List<Node> selection = new ArrayList<>();\n-                int index = getSkinnable().getIndex();\n-                for (TablePosition<T,?> pos : getTableView().getSelectionModel().getSelectedCells()) {\n-                    if (pos.getRow() == index) {\n-                        TableColumn<T,?> column = pos.getTableColumn();\n-                        if (column == null) {\n-                            \/* This is the row-based case *\/\n-                            column = getTableView().getVisibleLeafColumn(0);\n+                if (getTableView().getSelectionModel() != null) {\n+                    \/\/ FIXME this could be optimised to iterate over cellsMap only\n+                    \/\/ (selectedCells could be big, cellsMap is much smaller)\n+                    List<Node> selection = new ArrayList<>();\n+                    int index = getSkinnable().getIndex();\n+                    for (TablePosition<T,?> pos : getTableView().getSelectionModel().getSelectedCells()) {\n+                        if (pos.getRow() == index) {\n+                            TableColumn<T,?> column = pos.getTableColumn();\n+                            if (column == null) {\n+                                \/* This is the row-based case *\/\n+                                column = getTableView().getVisibleLeafColumn(0);\n+                            }\n+                            TableCell<T,?> cell = cellsMap.get(column).get();\n+                            if (cell != null) selection.add(cell);\n@@ -161,2 +165,1 @@\n-                        TableCell<T,?> cell = cellsMap.get(column).get();\n-                        if (cell != null) selection.add(cell);\n+                        return FXCollections.observableArrayList(selection);\n@@ -164,1 +167,0 @@\n-                    return FXCollections.observableArrayList(selection);\n@@ -167,0 +169,1 @@\n+            \/\/ fall through\n@@ -175,0 +178,1 @@\n+            \/\/ fall through\n@@ -188,0 +192,1 @@\n+            \/\/ fall through\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableRowSkin.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,3 +155,5 @@\n-                for (TablePosition<T,?> pos : sm.getSelectedCells()) {\n-                    TableRow<T> row = flow.getPrivateCell(pos.getRow());\n-                    if (row != null) selection.add(row);\n+                if (sm != null) {\n+                    for (TablePosition<T,?> pos : sm.getSelectedCells()) {\n+                        TableRow<T> row = flow.getPrivateCell(pos.getRow());\n+                        if (row != null) selection.add(row);\n+                    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableViewSkin.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -808,0 +808,4 @@\n+        if (sm == null) {\n+            return false;\n+        }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableViewSkinBase.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -458,10 +458,14 @@\n-                \/\/ FIXME this could be optimised to iterate over cellsMap only\n-                \/\/ (selectedCells could be big, cellsMap is much smaller)\n-                List<Node> selection = new ArrayList<>();\n-                int index = getSkinnable().getIndex();\n-                for (TreeTablePosition<T,?> pos : treeTableView.getSelectionModel().getSelectedCells()) {\n-                    if (pos.getRow() == index) {\n-                        TreeTableColumn<T,?> column = pos.getTableColumn();\n-                        if (column == null) {\n-                            \/* This is the row-based case *\/\n-                            column = treeTableView.getVisibleLeafColumn(0);\n+                if (treeTableView.getSelectionModel() != null) {\n+                    \/\/ FIXME this could be optimised to iterate over cellsMap only\n+                    \/\/ (selectedCells could be big, cellsMap is much smaller)\n+                    List<Node> selection = new ArrayList<>();\n+                    int index = getSkinnable().getIndex();\n+                    for (TreeTablePosition<T,?> pos : treeTableView.getSelectionModel().getSelectedCells()) {\n+                        if (pos.getRow() == index) {\n+                            TreeTableColumn<T,?> column = pos.getTableColumn();\n+                            if (column == null) {\n+                                \/* This is the row-based case *\/\n+                                column = treeTableView.getVisibleLeafColumn(0);\n+                            }\n+                            TreeTableCell<T,?> cell = cellsMap.get(column).get();\n+                            if (cell != null) selection.add(cell);\n@@ -469,2 +473,1 @@\n-                        TreeTableCell<T,?> cell = cellsMap.get(column).get();\n-                        if (cell != null) selection.add(cell);\n+                        return FXCollections.observableArrayList(selection);\n@@ -472,1 +475,0 @@\n-                    return FXCollections.observableArrayList(selection);\n@@ -475,0 +477,1 @@\n+            \/\/ fall through\n@@ -483,0 +486,1 @@\n+            \/\/ fall through\n@@ -496,0 +500,1 @@\n+            \/\/ fall through\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TreeTableRowSkin.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,3 +221,5 @@\n-                for (TreeTablePosition<T,?> pos : sm.getSelectedCells()) {\n-                    TreeTableRow<T> row = flow.getPrivateCell(pos.getRow());\n-                    if (row != null) selection.add(row);\n+                if (sm != null) {\n+                    for (TreeTablePosition<T,?> pos : sm.getSelectedCells()) {\n+                        TreeTableRow<T> row = flow.getPrivateCell(pos.getRow());\n+                        if (row != null) selection.add(row);\n+                    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TreeTableViewSkin.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.control;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.junit.Test;\n+import com.sun.javafx.tk.Toolkit;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.css.PseudoClass;\n+import javafx.event.EventTarget;\n+import javafx.scene.Node;\n+import javafx.scene.control.TableCell;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableView;\n+import javafx.scene.control.TableView.TableViewSelectionModel;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.control.TreeTableColumn;\n+import javafx.scene.control.TreeTableView;\n+import javafx.scene.control.TreeTableView.TreeTableViewSelectionModel;\n+import javafx.scene.control.skin.TableColumnHeader;\n+import javafx.scene.input.MouseEvent;\n+import test.com.sun.javafx.scene.control.infrastructure.KeyModifier;\n+import test.com.sun.javafx.scene.control.infrastructure.MouseEventFirer;\n+import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;\n+\n+\/**\n+ * Tests for:\n+ * - NPE with null selection model JDK-8187145\n+ *\/\n+public class TreeAndTableViewTest {\n+    \/** Sorting TableView with a null selection model should not generate an NPE *\/\n+    @Test\n+    public void test_TableView_jdk_8187145() {\n+        TableView<String> table = new TableView<>();\n+        table.requestFocus();\n+        table.getColumns().addAll(\n+            createTableColumn(\"C0\"),\n+            createTableColumn(\"C1\"),\n+            createTableColumn(\"C2\")\n+            );\n+        table.getItems().addAll(\n+            \"\",\n+            \"\",\n+            \"\"\n+            );\n+\n+        \/\/ important: actually creates cells\n+        VirtualFlowTestUtils.getCell(table, 0);\n+\n+        \/\/ row selection mode\n+        TableViewSelectionModel<String> oldSelectionModel = table.getSelectionModel();\n+        table.getSelectionModel().selectAll();\n+        table.setSelectionModel(null);\n+\n+        \/\/ verify none have 'selected' pseudostyle\n+        {\n+            List cells = table.lookupAll(\".table-cell\").\n+                stream().\n+                filter((n) -> ((n instanceof TableCell) && containsPseudoclass(n, \"selected\"))).\n+                collect(Collectors.toList());\n+            assertEquals(0, cells.size());\n+        }\n+\n+        \/\/ cell selection mode\n+        table.setSelectionModel(oldSelectionModel);\n+        table.getSelectionModel().setCellSelectionEnabled(true);\n+        table.getSelectionModel().selectAll();\n+        table.setSelectionModel(null);\n+\n+        \/\/ verify none have 'selected' pseudostyle\n+        {\n+            List cells = table.lookupAll(\".table-cell\").\n+                stream().\n+                filter((n) -> ((n instanceof TableCell) && containsPseudoclass(n, \"selected\"))).\n+                collect(Collectors.toList());\n+            assertEquals(0, cells.size());\n+        }\n+\n+        \/\/ verify no NPE when sorting by clicking on every table column cell,\n+        \/\/ toggling sorting ascending -> descending -> none\n+        {\n+            for (Object x: table.lookupAll(\".table-column\")) {\n+                if (x instanceof TableColumnHeader n) {\n+                    mouseClick(n);\n+                    assertEquals(1, table.getSortOrder().size());\n+                    table.sort();\n+\n+                    mouseClick(n);\n+                    assertEquals(1, table.getSortOrder().size());\n+                    table.sort();\n+\n+                    mouseClick(n);\n+                    assertEquals(0, table.getSortOrder().size());\n+                    table.sort();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Sorting TreeTableView with a null selection model should not generate an NPE *\/\n+    @Test\n+    public void test_TreeTableView_jdk_8187145() {\n+        TreeItem<String> root = new TreeItem<String>(\"\");\n+        root.setExpanded(true);\n+        root.getChildren().setAll(\n+            new TreeItem<>(\"\"),\n+            new TreeItem<>(\"\"),\n+            new TreeItem<>(\"\")\n+            );\n+\n+        TreeTableView<String> tree = new TreeTableView<>();\n+        tree.setRoot(root);\n+        tree.setShowRoot(false);\n+        tree.requestFocus();\n+        tree.getColumns().addAll(\n+            createTreeTableColumn(\"C0\"),\n+            createTreeTableColumn(\"C1\"),\n+            createTreeTableColumn(\"C2\")\n+            );\n+\n+        \/\/ important: actually creates cells\n+        VirtualFlowTestUtils.getCell(tree, 0);\n+\n+        \/\/ row selection mode\n+        TreeTableViewSelectionModel<String> oldSelectionModel = tree.getSelectionModel();\n+        tree.getSelectionModel().selectAll();\n+        tree.setSelectionModel(null);\n+\n+        \/\/ verify none have 'selected' pseudostyle\n+        {\n+            List cells = tree.lookupAll(\".table-cell\").\n+                stream().\n+                filter((n) -> ((n instanceof TableCell) && containsPseudoclass(n, \"selected\"))).\n+                collect(Collectors.toList());\n+            assertEquals(0, cells.size());\n+        }\n+\n+        \/\/ cell selection mode\n+        tree.setSelectionModel(oldSelectionModel);\n+        tree.getSelectionModel().setCellSelectionEnabled(true);\n+        tree.getSelectionModel().selectAll();\n+        tree.setSelectionModel(null);\n+\n+        \/\/ verify none have 'selected' pseudostyle\n+        {\n+            List cells = tree.lookupAll(\".table-cell\").\n+                stream().\n+                filter((n) -> ((n instanceof TableCell) && containsPseudoclass(n, \"selected\"))).\n+                collect(Collectors.toList());\n+            assertEquals(0, cells.size());\n+        }\n+\n+        \/\/ verify no NPE when sorting by clicking on every table column cell,\n+        \/\/ toggling sorting ascending -> descending -> none\n+        {\n+            for (Object x: tree.lookupAll(\".table-column\")) {\n+                if (x instanceof TableColumnHeader n) {\n+                    mouseClick(n);\n+                    assertEquals(1, tree.getSortOrder().size());\n+                    tree.sort();\n+\n+                    mouseClick(n);\n+                    assertEquals(1, tree.getSortOrder().size());\n+                    tree.sort();\n+\n+                    mouseClick(n);\n+                    assertEquals(0, tree.getSortOrder().size());\n+                    tree.sort();\n+                }\n+            }\n+        }\n+    }\n+\n+    protected static TreeTableColumn createTreeTableColumn(String name) {\n+        TreeTableColumn c = new TreeTableColumn(name);\n+        c.setCellValueFactory((f) -> new SimpleStringProperty(\"...\"));\n+        return c;\n+    }\n+\n+    protected static void mouseClick(EventTarget t, KeyModifier... modifiers) {\n+        MouseEventFirer m = new MouseEventFirer(t);\n+        m.fireMousePressAndRelease(modifiers);\n+        m.fireMouseEvent(MouseEvent.MOUSE_RELEASED, modifiers);\n+        m.dispose();\n+\n+        Toolkit.getToolkit().firePulse();\n+    }\n+\n+    protected static TableColumn createTableColumn(String name) {\n+        TableColumn c = new TableColumn(name);\n+        c.setCellValueFactory((f) -> new SimpleStringProperty(\"...\"));\n+        return c;\n+    }\n+\n+    protected static <T extends Node> List<T> collectNodes(Node root, String selector, Class<T> type) {\n+        return (List<T>)root.\n+            lookupAll(selector).\n+            stream().\n+            filter((n) -> (n.getClass().isAssignableFrom(type))).\n+            collect(Collectors.toList());\n+    }\n+\n+    protected static boolean containsPseudoclass(Node n, String pseudoclass) {\n+        for (PseudoClass pc: n.getPseudoClassStates()) {\n+            if(pseudoclass.equals(pc.getPseudoClassName())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeAndTableViewTest.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"}]}