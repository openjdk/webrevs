{"files":[{"patch":"@@ -334,1 +334,1 @@\n-                    child.minHeight(childWidth) : computeChildPrefAreaHeight(child, -1, null, childWidth)) + bottom);\n+                    child.minHeight(childWidth) : computeChildPrefAreaHeight(child, -1, null, childWidth, true)) + bottom);\n@@ -351,1 +351,1 @@\n-        return computeChildPrefAreaHeight(child, -1, Insets.EMPTY, width);\n+        return computeChildPrefAreaHeight(child, -1, Insets.EMPTY, width, true);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/AnchorPane.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -629,2 +629,2 @@\n-            return minimum ? computeChildMinAreaHeight(child, -1, margin, width):\n-                                   computeChildPrefAreaHeight(child, -1, margin, width);\n+            return minimum ? computeChildMinAreaHeight(child, -1, margin, width, false):\n+                                   computeChildPrefAreaHeight(child, -1, margin, width, false);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/BorderPane.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1450,2 +1450,7 @@\n-            double childPrefAreaHeight = computeChildPrefAreaHeight(child, isNodePositionedByBaseline(child) ? rowPrefBaselineComplement[start] : -1, getMargin(child),\n-                    widths == null ? -1 : getTotalWidthOfNodeColumns(child, widths));\n+            double childPrefAreaHeight = computeChildPrefAreaHeight(\n+                child,\n+                isNodePositionedByBaseline(child) ? rowPrefBaselineComplement[start] : -1,\n+                getMargin(child),\n+                widths == null ? -1 : getTotalWidthOfNodeColumns(child, widths),\n+                false\n+            );\n@@ -1493,2 +1498,7 @@\n-            double childMinAreaHeight = computeChildMinAreaHeight(child, isNodePositionedByBaseline(child) ? rowMinBaselineComplement[start] : -1, getMargin(child),\n-                             widths == null ? -1 : getTotalWidthOfNodeColumns(child, widths));\n+            double childMinAreaHeight = computeChildMinAreaHeight(\n+                child,\n+                isNodePositionedByBaseline(child) ? rowMinBaselineComplement[start] : -1,\n+                getMargin(child),\n+                widths == null ? -1 : getTotalWidthOfNodeColumns(child, widths),\n+                false\n+            );\n@@ -1584,0 +1594,7 @@\n+            double childPrefAreaWidth = computeChildPrefAreaWidth(\n+                child,\n+                getBaselineComplementForChild(child),\n+                getMargin(child),\n+                heights == null ? -1 : getTotalHeightOfNodeRows(child, heights),\n+                false\n+            );\n@@ -1587,3 +1604,1 @@\n-                result.setMaxSize(start, boundedSize(min < 0 ? 0 : min, computeChildPrefAreaWidth(child,\n-                        getBaselineComplementForChild(child), getMargin(child),\n-                        heights == null ? -1 : getTotalHeightOfNodeRows(child, heights), false),\n+                result.setMaxSize(start, boundedSize(min < 0 ? 0 : min, childPrefAreaWidth,\n@@ -1592,3 +1607,1 @@\n-                result.setMaxMultiSize(start, end + 1, computeChildPrefAreaWidth(child, getBaselineComplementForChild(child),\n-                        getMargin(child),\n-                        heights == null ? -1 : getTotalHeightOfNodeRows(child, heights), false));\n+                result.setMaxMultiSize(start, end + 1, childPrefAreaWidth);\n@@ -1630,0 +1643,7 @@\n+            double childMinAreaWidth = computeChildMinAreaWidth(\n+                child,\n+                getBaselineComplementForChild(child),\n+                getMargin(child),\n+                heights == null ? -1 : getTotalHeightOfNodeRows(child, heights),\n+                false\n+            );\n@@ -1631,3 +1651,1 @@\n-                result.setMaxSize(start, computeChildMinAreaWidth(child, getBaselineComplementForChild(child),\n-                        getMargin(child),\n-                        heights == null ? -1 : getTotalHeightOfNodeRows(child, heights),false));\n+                result.setMaxSize(start, childMinAreaWidth);\n@@ -1635,3 +1653,1 @@\n-                result.setMaxMultiSize(start, end + 1, computeChildMinAreaWidth(child, getBaselineComplementForChild(child),\n-                        getMargin(child),\n-                        heights == null ? -1 : getTotalHeightOfNodeRows(child, heights), false));\n+                result.setMaxMultiSize(start, end + 1, childMinAreaWidth);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/GridPane.java","additions":32,"deletions":16,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -420,1 +420,1 @@\n-            contentHeight = computeMaxMinAreaHeight(managed, marginAccessor, prefWidths[0], getAlignmentInternal().getVpos());\n+            contentHeight = computeMaxMinAreaHeight(managed, marginAccessor, prefWidths[0], false, getAlignmentInternal().getVpos());\n@@ -443,1 +443,1 @@\n-            contentHeight = computeMaxPrefAreaHeight(managed, marginAccessor, prefWidths[0], getAlignmentInternal().getVpos());\n+            contentHeight = computeMaxPrefAreaHeight(managed, marginAccessor, prefWidths[0], false, getAlignmentInternal().getVpos());\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HBox.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1875,1 +1875,1 @@\n-    double computeChildMinAreaWidth(Node child, double baselineComplement, Insets margin, double height, boolean fillHeight) {\n+    double computeChildMinAreaWidth(Node child, double baselineComplement, Insets margin, double availableHeight, boolean fillHeight) {\n@@ -1880,1 +1880,1 @@\n-        if (height != -1 && child.isResizable() && child.getContentBias() == Orientation.VERTICAL) { \/\/ width depends on height\n+        if (availableHeight != -1 && child.isResizable() && child.getContentBias() == Orientation.VERTICAL) { \/\/ width depends on height\n@@ -1885,12 +1885,3 @@\n-                    height - top - bottom - baselineComplement :\n-                     height - top - bottom;\n-            if (fillHeight) {\n-                alt = snapSizeY(boundedSize(\n-                        child.minHeight(-1), contentHeight,\n-                        child.maxHeight(-1)));\n-            } else {\n-                alt = snapSizeY(boundedSize(\n-                        child.minHeight(-1),\n-                        child.prefHeight(-1),\n-                        Math.min(child.maxHeight(-1), contentHeight)));\n-            }\n+                    availableHeight - top - bottom - baselineComplement :\n+                    availableHeight - top - bottom;\n+            alt = computedBoundedHeight(child, fillHeight, contentHeight);\n@@ -1902,1 +1893,1 @@\n-        return computeChildMinAreaHeight(child, -1, margin, -1);\n+        return computeChildMinAreaHeight(child, -1, margin, -1, false);\n@@ -1905,1 +1896,1 @@\n-    double computeChildMinAreaHeight(Node child, double minBaselineComplement, Insets margin, double width) {\n+    double computeChildMinAreaHeight(Node child, double minBaselineComplement, Insets margin, double availableWidth, boolean fillWidth) {\n@@ -1911,5 +1902,4 @@\n-        if (child.isResizable() && child.getContentBias() == Orientation.HORIZONTAL) { \/\/ height depends on width\n-            double left = margin != null? snapSpaceX(margin.getLeft(), snap) : 0;\n-            double right = margin != null? snapSpaceX(margin.getRight(), snap) : 0;\n-            alt = snapSizeX(width != -1? boundedSize(child.minWidth(-1), width - left - right, child.maxWidth(-1)) :\n-                    child.maxWidth(-1));\n+        if (availableWidth != -1 && child.isResizable() && child.getContentBias() == Orientation.HORIZONTAL) { \/\/ height depends on width\n+            double contentWidth = computeContentWidth(margin, availableWidth);\n+\n+            alt = computeBoundedWidth(child, fillWidth, contentWidth);\n@@ -1936,1 +1926,1 @@\n-    double computeChildPrefAreaWidth(Node child, double baselineComplement, Insets margin, double height, boolean fillHeight) {\n+    double computeChildPrefAreaWidth(Node child, double baselineComplement, Insets margin, double availableHeight, boolean fillHeight) {\n@@ -1941,1 +1931,1 @@\n-        if (height != -1 && child.isResizable() && child.getContentBias() == Orientation.VERTICAL) { \/\/ width depends on height\n+        if (availableHeight != -1 && child.isResizable() && child.getContentBias() == Orientation.VERTICAL) { \/\/ width depends on height\n@@ -1946,12 +1936,3 @@\n-                    height - top - bottom - baselineComplement :\n-                     height - top - bottom;\n-            if (fillHeight) {\n-                alt = snapSizeY(boundedSize(\n-                        child.minHeight(-1), contentHeight,\n-                        child.maxHeight(-1)));\n-            } else {\n-                alt = snapSizeY(boundedSize(\n-                        child.minHeight(-1),\n-                        child.prefHeight(-1),\n-                        Math.min(child.maxHeight(-1), contentHeight)));\n-            }\n+                    availableHeight - top - bottom - baselineComplement :\n+                    availableHeight - top - bottom;\n+            alt = computedBoundedHeight(child, fillHeight, contentHeight);\n@@ -1963,1 +1944,1 @@\n-        return computeChildPrefAreaHeight(child, -1, margin, -1);\n+        return computeChildPrefAreaHeight(child, -1, margin, -1, false);\n@@ -1966,1 +1947,1 @@\n-    double computeChildPrefAreaHeight(Node child, double prefBaselineComplement, Insets margin, double width) {\n+    double computeChildPrefAreaHeight(Node child, double prefBaselineComplement, Insets margin, double availableWidth, boolean fillWidth) {\n@@ -1972,6 +1953,4 @@\n-        if (child.isResizable() && child.getContentBias() == Orientation.HORIZONTAL) { \/\/ height depends on width\n-            double left = margin != null ? snapSpaceX(margin.getLeft(), snap) : 0;\n-            double right = margin != null ? snapSpaceX(margin.getRight(), snap) : 0;\n-            alt = snapSizeX(boundedSize(\n-                    child.minWidth(-1), width != -1 ? width - left - right\n-                    : child.prefWidth(-1), child.maxWidth(-1)));\n+        if (availableWidth != -1 && child.isResizable() && child.getContentBias() == Orientation.HORIZONTAL) { \/\/ height depends on width\n+            double contentWidth = computeContentWidth(margin, availableWidth);\n+\n+            alt = computeBoundedWidth(child, fillWidth, contentWidth);\n@@ -1997,1 +1976,1 @@\n-    double computeChildMaxAreaWidth(Node child, double baselineComplement, Insets margin, double height, boolean fillHeight) {\n+    double computeChildMaxAreaWidth(Node child, double baselineComplement, Insets margin, double availableHeight, boolean fillHeight) {\n@@ -2006,1 +1985,1 @@\n-        if (height != -1 && child.isResizable() && child.getContentBias() == Orientation.VERTICAL) { \/\/ width depends on height\n+        if (availableHeight != -1 && child.isResizable() && child.getContentBias() == Orientation.VERTICAL) { \/\/ width depends on height\n@@ -2011,12 +1990,4 @@\n-                    height - top - bottom - baselineComplement :\n-                     height - top - bottom;\n-            if (fillHeight) {\n-                alt = snapSizeY(boundedSize(\n-                        child.minHeight(-1), contentHeight,\n-                        child.maxHeight(-1)));\n-            } else {\n-                alt = snapSizeY(boundedSize(\n-                        child.minHeight(-1),\n-                        child.prefHeight(-1),\n-                        Math.min(child.maxHeight(-1), contentHeight)));\n-            }\n+                    availableHeight - top - bottom - baselineComplement :\n+                    availableHeight - top - bottom;\n+\n+            alt = computedBoundedHeight(child, fillHeight, contentHeight);\n@@ -2029,1 +2000,1 @@\n-    double computeChildMaxAreaHeight(Node child, double maxBaselineComplement, Insets margin, double width) {\n+    double computeChildMaxAreaHeight(Node child, double maxBaselineComplement, Insets margin, double availableWidth, boolean fillWidth) {\n@@ -2039,5 +2010,4 @@\n-        if (child.isResizable() && child.getContentBias() == Orientation.HORIZONTAL) { \/\/ height depends on width\n-            double left = margin != null? snapSpaceX(margin.getLeft(), snap) : 0;\n-            double right = margin != null? snapSpaceX(margin.getRight(), snap) : 0;\n-            alt = snapSizeX(width != -1? boundedSize(child.minWidth(-1), width - left - right, child.maxWidth(-1)) :\n-                child.minWidth(-1));\n+        if (availableWidth != -1 && child.isResizable() && child.getContentBias() == Orientation.HORIZONTAL) { \/\/ height depends on width\n+            double contentWidth = computeContentWidth(margin, availableWidth);\n+\n+            alt = computeBoundedWidth(child, fillWidth, contentWidth);\n@@ -2050,1 +2020,1 @@\n-                return top + snapSizeY(boundedSize(child.minHeight(alt), child.maxHeight(alt), Double.MAX_VALUE)) + bottom\n+                return top + snapSizeY(boundedSize(child.minHeight(alt), max, Double.MAX_VALUE)) + bottom\n@@ -2061,0 +2031,67 @@\n+    \/*\n+     * Definition of used terms:\n+     *\n+     * # available width\/heights:\n+     *\n+     * Sizes provided by the container that may be used as a dependent value when\n+     * calculating sizes for biased controls. These may be set to -1 to indicate\n+     * no such information is available. If given, the sizes include the Margin\n+     * of the child. As such the Margin must be removed before passing these\n+     * values as a dependent value to min\/pref\/max width\/height functions.\n+     *\n+     * # content width\/heights:\n+     *\n+     * The space allocated to a child, minus its margins. A content size is\n+     * always a real value (not NaN) and never negative.\n+     *\n+     * # bounded width\/heights:\n+     *\n+     * The space allocated to a child, minus its margins, adjusted according to\n+     * its constraints (min <= X <= max). A bounded size is always a real value\n+     * (not NaN) and never negative.\n+     *\/\n+\n+    \/*\n+     * Given a content width, limits it by the child's constraints. The fill boolean\n+     * controls whether the content width or the child's preferred width is used to compute\n+     * the bounded width.\n+     *\/\n+    private double computeBoundedWidth(Node child, boolean fill, double contentWidth) {\n+        double min = child.minWidth(-1);\n+        double max = child.maxWidth(-1);\n+\n+        if (fill) {\n+            return snapSizeX(boundedSize(min, contentWidth, max));\n+        }\n+\n+        return snapSizeX(boundedSize(min, child.prefWidth(-1), Math.min(max, contentWidth)));\n+    }\n+\n+    \/*\n+     * Given a content height, limits it by the child's constraints. The fill boolean\n+     * controls whether the content height or the child's preferred height is used to compute\n+     * the bounded height.\n+     *\/\n+    private double computedBoundedHeight(Node child, boolean fill, double contentHeight) {\n+        double min = child.minHeight(-1);\n+        double max = child.maxHeight(-1);\n+\n+        if (fill) {\n+            return snapSizeY(boundedSize(min, contentHeight, max));\n+        }\n+\n+        return snapSizeY(boundedSize(min, child.prefHeight(-1), Math.min(max, contentHeight)));\n+    }\n+\n+    \/*\n+     * Removes the given Margin (if any) from a width which still includes margins\n+     * to create a content width.\n+     *\/\n+    private double computeContentWidth(Insets margin, double width) {\n+        boolean snap = isSnapToPixel();\n+        double left = margin != null ? snapSpaceX(margin.getLeft(), snap) : 0;\n+        double right = margin != null ? snapSpaceX(margin.getRight(), snap) : 0;\n+\n+        return width - left - right;\n+    }\n+\n@@ -2067,1 +2104,2 @@\n-    double computeMaxMinAreaWidth(List<Node> children, Callback<Node, Insets> margins, double height, boolean fillHeight) {\n+    double computeMaxMinAreaWidth(List<Node> children, Callback<Node, Insets> margins, double height,\n+            boolean fillHeight) {\n@@ -2071,1 +2109,2 @@\n-    double computeMaxMinAreaWidth(List<Node> children, Callback<Node, Insets> childMargins, double childHeights[], boolean fillHeight) {\n+    double computeMaxMinAreaWidth(List<Node> children, Callback<Node, Insets> childMargins,\n+            double[] childHeights, boolean fillHeight) {\n@@ -2077,2 +2116,2 @@\n-    double computeMaxMinAreaHeight(List<Node>children, Callback<Node, Insets> margins, VPos valignment) {\n-        return getMaxAreaHeight(children, margins, null, valignment, true);\n+    double computeMaxMinAreaHeight(List<Node> children, Callback<Node, Insets> margins, VPos valignment) {\n+        return getMaxAreaHeight(children, margins, null, false, true, valignment);\n@@ -2081,2 +2120,3 @@\n-    double computeMaxMinAreaHeight(List<Node>children, Callback<Node, Insets> margins, VPos valignment, double width) {\n-        return getMaxAreaHeight(children, margins, new double[] { width }, valignment, true);\n+    double computeMaxMinAreaHeight(List<Node> children, Callback<Node, Insets> margins, double width,\n+            boolean fillWidth, VPos valignment) {\n+        return getMaxAreaHeight(children, margins, new double[] { width }, fillWidth, true, valignment);\n@@ -2085,2 +2125,3 @@\n-    double computeMaxMinAreaHeight(List<Node>children, Callback<Node, Insets> childMargins, double childWidths[], VPos valignment) {\n-        return getMaxAreaHeight(children, childMargins, childWidths, valignment, true);\n+    double computeMaxMinAreaHeight(List<Node> children, Callback<Node, Insets> childMargins,\n+            double[] childWidths, boolean fillWidth, VPos valignment) {\n+        return getMaxAreaHeight(children, childMargins, childWidths, fillWidth, true, valignment);\n@@ -2091,1 +2132,1 @@\n-    double computeMaxPrefAreaWidth(List<Node>children, Callback<Node, Insets> margins) {\n+    double computeMaxPrefAreaWidth(List<Node> children, Callback<Node, Insets> margins) {\n@@ -2095,1 +2136,1 @@\n-    double computeMaxPrefAreaWidth(List<Node>children, Callback<Node, Insets> margins, double height,\n+    double computeMaxPrefAreaWidth(List<Node> children, Callback<Node, Insets> margins, double height,\n@@ -2100,2 +2141,2 @@\n-    double computeMaxPrefAreaWidth(List<Node>children, Callback<Node, Insets> childMargins,\n-            double childHeights[], boolean fillHeight) {\n+    double computeMaxPrefAreaWidth(List<Node> children, Callback<Node, Insets> childMargins,\n+            double[] childHeights, boolean fillHeight) {\n@@ -2107,2 +2148,2 @@\n-    double computeMaxPrefAreaHeight(List<Node>children, Callback<Node, Insets> margins, VPos valignment) {\n-        return getMaxAreaHeight(children, margins, null, valignment, false);\n+    double computeMaxPrefAreaHeight(List<Node> children, Callback<Node, Insets> margins, VPos valignment) {\n+        return getMaxAreaHeight(children, margins, null, false, false, valignment);\n@@ -2111,2 +2152,3 @@\n-    double computeMaxPrefAreaHeight(List<Node>children, Callback<Node, Insets> margins, double width, VPos valignment) {\n-        return getMaxAreaHeight(children, margins, new double[] { width }, valignment, false);\n+    double computeMaxPrefAreaHeight(List<Node> children, Callback<Node, Insets> margins, double width,\n+            boolean fillWidth, VPos valignment) {\n+        return getMaxAreaHeight(children, margins, new double[] { width }, fillWidth, false, valignment);\n@@ -2115,2 +2157,3 @@\n-    double computeMaxPrefAreaHeight(List<Node>children, Callback<Node, Insets> childMargins, double childWidths[], VPos valignment) {\n-        return getMaxAreaHeight(children, childMargins, childWidths, valignment, false);\n+    double computeMaxPrefAreaHeight(List<Node> children, Callback<Node, Insets> childMargins,\n+            double[] childWidths, boolean fillWidth, VPos valignment) {\n+        return getMaxAreaHeight(children, childMargins, childWidths, fillWidth, false, valignment);\n@@ -2178,1 +2221,4 @@\n-    private double getMaxAreaHeight(List<Node> children, Callback<Node,Insets> childMargins,  double childWidths[], VPos valignment, boolean minimum) {\n+    private double getMaxAreaHeight(\n+        List<Node> children, Callback<Node, Insets> childMargins, double[] childWidths,\n+        boolean fillWidth, boolean minimum, VPos valignment\n+    ) {\n@@ -2209,2 +2255,2 @@\n-                    computeChildMinAreaHeight(child, -1, margin, childWidth) :\n-                        computeChildPrefAreaHeight(child, -1, margin, childWidth));\n+                    computeChildMinAreaHeight(child, -1, margin, childWidth, fillWidth) :\n+                        computeChildPrefAreaHeight(child, -1, margin, childWidth, fillWidth));\n@@ -2217,2 +2263,2 @@\n-    private double getMaxAreaWidth(List<javafx.scene.Node> children,\n-            Callback<Node, Insets> childMargins, double childHeights[], boolean fillHeight, boolean minimum) {\n+    private double getMaxAreaWidth(List<Node> children,\n+            Callback<Node, Insets> childMargins, double[] childHeights, boolean fillHeight, boolean minimum) {\n@@ -2227,1 +2273,1 @@\n-                computeChildMinAreaWidth(children.get(i), -1, margin, childHeight, fillHeight) :\n+                computeChildMinAreaWidth(child, -1, margin, childHeight, fillHeight) :\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Region.java","additions":134,"deletions":88,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-               computeMaxMinAreaHeight(managed, marginAccessor, getAlignmentInternal().getVpos(), width) +\n+               computeMaxMinAreaHeight(managed, marginAccessor, width, true, getAlignmentInternal().getVpos()) +\n@@ -313,1 +313,1 @@\n-                                        (width == -1) ? -1 : (width - padding.getLeft() - padding.getRight()),\n+                                        (width == -1) ? -1 : (width - padding.getLeft() - padding.getRight()), true,\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/StackPane.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -858,1 +858,1 @@\n-                h = computeMaxPrefAreaHeight(managed, marginAccessor, -1, getTileAlignmentInternal().getVpos());\n+                h = computeMaxPrefAreaHeight(managed, marginAccessor, -1, true, getTileAlignmentInternal().getVpos());\n@@ -882,1 +882,1 @@\n-            return snapSizeY(computeMaxPrefAreaHeight(managed, marginAccessor, w, getTileAlignmentInternal().getVpos()));\n+            return snapSizeY(computeMaxPrefAreaHeight(managed, marginAccessor, w, true, getTileAlignmentInternal().getVpos()));\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/TilePane.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -444,5 +444,1 @@\n-                if (insideWidth != -1 && isFillWidth) {\n-                    temp[0][i] = computeChildMinAreaHeight(child, -1, margin, insideWidth);\n-                } else {\n-                    temp[0][i] = computeChildMinAreaHeight(child, -1, margin, -1);\n-                }\n+                temp[0][i] = computeChildMinAreaHeight(child, -1, margin, insideWidth, isFillWidth);\n@@ -450,5 +446,1 @@\n-                if (insideWidth != -1 && isFillWidth) {\n-                    temp[0][i] = computeChildPrefAreaHeight(child, -1, margin, insideWidth);\n-                } else {\n-                    temp[0][i] = computeChildPrefAreaHeight(child, -1, margin, -1);\n-                }\n+                temp[0][i] = computeChildPrefAreaHeight(child, -1, margin, insideWidth, isFillWidth);\n@@ -485,0 +477,1 @@\n+        final boolean isFillWidth = isFillWidth();\n@@ -490,1 +483,1 @@\n-                temp[i] = computeChildMinAreaHeight(child, -1, getMargin(child), width);\n+                temp[i] = computeChildMinAreaHeight(child, -1, getMargin(child), width, isFillWidth);\n@@ -494,6 +487,7 @@\n-            final Node child = managed.get(i);\n-            if (getVgrow(child) == priority) {\n-                temp[i] = computeChildMaxAreaHeight(child, -1, getMargin(child), width);\n-                adjustingNumber++;\n-            } else {\n-                temp[i] = -1;\n+                final Node child = managed.get(i);\n+                if (getVgrow(child) == priority) {\n+                    temp[i] = computeChildMaxAreaHeight(child, -1, getMargin(child), width, isFillWidth);\n+                    adjustingNumber++;\n+                } else {\n+                    temp[i] = -1;\n+                }\n@@ -502,1 +496,0 @@\n-        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/VBox.java","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-            Node child, double maxBaselineComplement, Insets margin, double width) {\n-        return r.computeChildMaxAreaHeight(child, maxBaselineComplement, margin, width);\n+            Node child, double maxBaselineComplement, Insets margin, double width, boolean fillWidth) {\n+        return r.computeChildMaxAreaHeight(child, maxBaselineComplement, margin, width, fillWidth);\n@@ -56,0 +56,5 @@\n+    public static double computeChildMinAreaHeight(Region r,\n+            Node child, Insets margin) {\n+        return r.computeChildMinAreaHeight(child, margin);\n+    }\n+\n@@ -58,1 +63,1 @@\n-            Insets margin, double width) {\n+            Insets margin, double width, boolean fillWidth) {\n@@ -61,1 +66,1 @@\n-                margin, width );\n+                margin, width, fillWidth);\n@@ -84,1 +89,1 @@\n-            Insets margin, double width) {\n+            Insets margin, double width, boolean fillWidth) {\n@@ -86,1 +91,1 @@\n-                prefBaselineComplement, margin, width);\n+                prefBaselineComplement, margin, width, fillWidth);\n@@ -171,3 +176,3 @@\n-        @Override public void addImageListener(Image image) {\n-            super.addImageListener(image);\n-        }\n+    @Override public void addImageListener(Image image) {\n+        super.addImageListener(image);\n+    }\n@@ -175,3 +180,3 @@\n-        @Override public void removeImageListener(Image image) {\n-            super.removeImageListener(image);\n-        }\n+    @Override public void removeImageListener(Image image) {\n+        super.removeImageListener(image);\n+    }\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/javafx\/scene\/layout\/RegionShim.java","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -349,1 +349,1 @@\n-        assertEquals(50, borderpane.minHeight(-1), 1e-10);\n+        assertEquals(20 \/*t*\/ + 200 \/*c*\/ + 20 \/*b*\/, borderpane.minHeight(-1), 1e-10);\n@@ -351,1 +351,1 @@\n-        assertEquals(221, borderpane.minHeight(300), 1e-10);\n+        assertEquals(20 \/*t*\/ + 200 \/*c*\/ + 20 \/*b*\/, borderpane.minHeight(300), 1e-10);\n@@ -457,2 +457,4 @@\n-        assertEquals(240, borderpane.prefHeight(500), 1e-200);\n-        borderpane.resize(500, 240);\n+        \/\/ Preferred height should be preferred height of top + bottom, plus max of left\/center\/right\n+        \/\/ In other words: 100 + max(100, 100, 100) + 100\n+        assertEquals(300, borderpane.prefHeight(500), 1e-200);\n+        borderpane.resize(500, 300);\n@@ -461,0 +463,25 @@\n+        \/\/ Resize to 500x240\n+        \/\/ +-------------------------------------------------------+\n+        \/\/ | top: 500 wide means 200 * 100 \/ 500 high (500 x 40)   |\n+        \/\/ +-------------------------------------------------------+\n+        \/\/ | left: height   | center: it is given   | right: see   |\n+        \/\/ | left over is   | a width of 500 - 200. | left for     |\n+        \/\/ | 300 - 40 - 100 | With a width of 300   | calculation. |\n+        \/\/ | so it becomes  | it becomes 67 high:   |              |\n+        \/\/ |   100 x 160    |       300 x 67        |   100 x 160  |\n+        \/\/ +-------------------------------------------------------+\n+        \/\/ | bottom: 500 x 100                                     |\n+        \/\/ +-------------------------------------------------------+\n+        \/\/\n+        \/\/ The widths of the middle area is determined as follows:\n+        \/\/ The total width available is 500. Subtracting the preferred widths\n+        \/\/ of left and right leaves 300 pixels, which are all allocated to the\n+        \/\/ center.\n+        \/\/\n+        \/\/ The height of the middle area is determined by taken the\n+        \/\/ total height (300) subtracting the final heights of the\n+        \/\/ top and bottom areas which are laid out first. The top becomes\n+        \/\/ 500 x 40 (due to bias, 200 * 100 \/ 500 = 40). The bottom just\n+        \/\/ takes the preferred height (100).  This leaves 160 pixels for\n+        \/\/ the middle area.\n+\n@@ -469,1 +496,1 @@\n-        assertEquals(100, left.getLayoutBounds().getHeight(), 1e-200);\n+        assertEquals(160, left.getLayoutBounds().getHeight(), 1e-200);\n@@ -472,2 +499,6 @@\n-        \/\/ 57 because the default alignment is Pos.CENTER\n-        assertEquals(57, center.getLayoutY(), 1e-200);\n+        \/\/ At 300 wide, the biased control in the center area only needs\n+        \/\/ a height of 200 * 100 \/ 300 = 66.7; The height available is\n+        \/\/ 160, and so it will be vertically centered (the default for the\n+        \/\/ center area in a BorderPane). The expected Y position then\n+        \/\/ becomes 40 (height of top) + (160 - 66.7) \/ 2 = 87 (with snap)\n+        assertEquals(87, center.getLayoutY(), 1e-200);\n@@ -480,1 +511,1 @@\n-        assertEquals(100, right.getLayoutBounds().getHeight(), 1e-200);\n+        assertEquals(160, right.getLayoutBounds().getHeight(), 1e-200);\n@@ -483,1 +514,1 @@\n-        assertEquals(140, bottom.getLayoutY(), 1e-200);\n+        assertEquals(200, bottom.getLayoutY(), 1e-200);\n@@ -505,2 +536,8 @@\n-        assertEquals(367, borderpane.prefHeight(300), 1e-200);\n-        borderpane.resize(300, 367);\n+        \/\/ The preferred height of the center pane at 100 pixels wide (which\n+        \/\/ is what is left over from the given 300 pixels after subtracting the\n+        \/\/ left and right preferred widths) will be 200. The middle area will\n+        \/\/ then contribute 200 pixels to the preferred height of the BorderPane\n+        \/\/ as the left and right areas only need 100 pixels of height. The top\n+        \/\/ and bottom areas contribute 100 pixels each. 100 + 200 + 100 = 400.\n+        assertEquals(400, borderpane.prefHeight(300), 1e-200);\n+        borderpane.resize(300, 400);\n@@ -509,0 +546,25 @@\n+        \/\/ Resize to 300x400\n+        \/\/ +-------------------------------------------------------+\n+        \/\/ | top: 300 wide means 200 * 100 \/ 300 high (300 x 67)   |\n+        \/\/ +-------------------------------------------------------+\n+        \/\/ | left: height   | center: it is given   | right: see   |\n+        \/\/ | left over is   | a width of 300 - 200. | left for     |\n+        \/\/ | 400 - 67 - 100 | With a width of 100   | calculation. |\n+        \/\/ | so it becomes  | it becomes 200 high:  |              |\n+        \/\/ |   100 x 233    |       100 x 200       |   100 x 233  |\n+        \/\/ +-------------------------------------------------------+\n+        \/\/ | bottom: 300 x 100                                     |\n+        \/\/ +-------------------------------------------------------+\n+        \/\/\n+        \/\/ The widths of the middle area is determined as follows:\n+        \/\/ The total width available is 300. Subtracting the preferred widths\n+        \/\/ of left and right leaves 100 pixels which are all allocated to the\n+        \/\/ center.\n+        \/\/\n+        \/\/ The height of the middle area is determined by taken the\n+        \/\/ total height (400) subtracting the final heights of the\n+        \/\/ top and bottom areas which are laid out first. The top becomes\n+        \/\/ 300 x 67 (due to bias, 200 * 100 \/ 300 = 67). The bottom just\n+        \/\/ takes the preferred height (100).  This leaves 233 pixels for\n+        \/\/ the middle area.\n+\n@@ -517,1 +579,1 @@\n-        assertEquals(200, left.getLayoutBounds().getHeight(), 1e-200);\n+        assertEquals(233, left.getLayoutBounds().getHeight(), 1e-200);\n@@ -520,1 +582,1 @@\n-        assertEquals(67, center.getLayoutY(), 1e-200);\n+        assertEquals(84, center.getLayoutY(), 1e-200);\n@@ -527,1 +589,1 @@\n-        assertEquals(200, right.getLayoutBounds().getHeight(), 1e-200);\n+        assertEquals(233, right.getLayoutBounds().getHeight(), 1e-200);\n@@ -530,1 +592,1 @@\n-        assertEquals(267, bottom.getLayoutY(), 1e-200);\n+        assertEquals(300, bottom.getLayoutY(), 1e-200);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/BorderPaneTest.java","additions":77,"deletions":15,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -837,1 +837,0 @@\n-        System.out.println(\"************************************\");\n@@ -850,1 +849,1 @@\n-        assertEquals(1, hbox.minHeight(-1), 1e-100); \/\/ If both have max width, min height can be indeed 1\n+        assertEquals(200, hbox.minHeight(-1), 1e-100); \/\/ minimum height of biased2 (when queried correctly)\n@@ -852,1 +851,0 @@\n-        System.out.println(\"************************************\");\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/HBoxTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1012,1 +1012,625 @@\n-    public void testChildMinAreaWidth() {\n+    public void testChildMinAreaWidthExtensively() {\n+        Pane pane = new Pane();\n+\n+        Region c1 = new MockBiased(Orientation.VERTICAL, 100, 200);\n+        Region c2 = new MockBiased(Orientation.HORIZONTAL, 100, 200);\n+        Region c3 = new MockRegion(10, 10, 100, 100, 1000, 1000);\n+\n+        pane.getChildren().addAll(c1, c2, c3);\n+\n+        \/*\n+         * Ensure that no fillHeight\/height combinations have effect on controls that are not vertically biased:\n+         *\/\n+\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c2, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c2, -1, new Insets(1), -1, true), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c2, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c2, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c2, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c2, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c2, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c2, -1, new Insets(1), 50000, true), 1e-100);\n+\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c3, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c3, -1, new Insets(1), -1, true), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c3, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c3, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c3, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c3, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c3, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaWidth(pane, c3, -1, new Insets(1), 50000, true), 1e-100);\n+\n+        \/*\n+         * Tests biased control with no available height provided:\n+         *\n+         * Note: MockBiased returns a minimum height based on its preferred width.\n+         *\n+         * Expect 102 == insets + minWidth(-1)\n+         * - insets are 1 + 1 = 2\n+         * - minWidth(-1) returns 100 as MockBiased will base the minimum width on a\n+         *   reasonable height (in this case the result of prefHeight(-1) which is 200).\n+         *   When the MockBiased is 200 high, it becomes 100 wide.\n+         *\/\n+        assertEquals(2 + 100, RegionShim.computeChildMinAreaWidth(pane, c1, -1, new Insets(1), -1, false), 1e-100);\n+\n+        \/*\n+         * Ensure that fillHeight has no effect when there is no available height provided:\n+         *\/\n+\n+        assertEquals(2 + 100, RegionShim.computeChildMinAreaWidth(pane, c1, -1, new Insets(1), -1, true), 1e-100);\n+\n+        \/*\n+         * When the given available height is less than a vertically biased control's preferred height, then\n+         * fillHeight should not have any effect as in both cases the height to use for determine the width\n+         * is capped at the smallest of the two height values; expect the control to be resized to the\n+         * available height, and that its width will be derived from this height as it is vertically biased:\n+         *\/\n+\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildMinAreaWidth(pane, c1, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildMinAreaWidth(pane, c1, -1, new Insets(1), 50, false), 1e-100);\n+\n+        \/\/ with baseline\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2 - 10)), RegionShim.computeChildMinAreaWidth(pane, c1, 10, new Insets(1), 50, true), 1e-100);\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2 - 10)), RegionShim.computeChildMinAreaWidth(pane, c1, 10, new Insets(1), 50, false), 1e-100);\n+\n+        \/*\n+         * When the given available height is greater than a vertically biased control's preferred height, then\n+         * fillHeight decides which of the two is used; when fillHeight is true, expect the control to be resized to the\n+         * available height, and that its width will be derived from this height as it is vertically biased:\n+         *\/\n+\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (500.0 - 2)), RegionShim.computeChildMinAreaWidth(pane, c1, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (500.0 - 2 - 10)), RegionShim.computeChildMinAreaWidth(pane, c1, 10, new Insets(1), 500, true), 1e-100);\n+\n+        \/*\n+         * When the given available height is greater than a vertically biased control's preferred height, then\n+         * fillHeight decides which of the two is used; when fillHeight is false, expect the control to be resized to the\n+         * its preferred height, and that its width will be derived from this height as it is vertically biased:\n+         *\/\n+\n+        assertEquals(102, RegionShim.computeChildMinAreaWidth(pane, c1, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildMinAreaWidth(pane, c1, 10, new Insets(1), 500, false), 1e-100);\n+\n+        \/*\n+         * When the given available height is greater than a vertically biased control's maximum height, then\n+         * fillHeight decides which of the two is used; when fillHeight is true, expect the control to be resized to the\n+         * available height, and that its width will be derived from this height as it is vertically biased:\n+         *\/\n+\n+        assertEquals(2 + 1, RegionShim.computeChildMinAreaWidth(pane, c1, -1, new Insets(1), 50000, true), 1e-100);\n+        assertEquals(2 + 1, RegionShim.computeChildMinAreaWidth(pane, c1, 10, new Insets(1), 50000, true), 1e-100);\n+\n+        \/*\n+         * When the given available height is greater than a vertically biased control's maximum height, then\n+         * fillHeight decides which of the two is used; when fillHeight is false, expect the control to be resized to the\n+         * its maximum height, and that its width will be derived from this height as it is vertically biased:\n+         *\n+         * Note: MockBiased returns a maximum height based on its preferred width.\n+         *\/\n+\n+        assertEquals(2 + 100, RegionShim.computeChildMinAreaWidth(pane, c1, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(2 + 100, RegionShim.computeChildMinAreaWidth(pane, c1, 10, new Insets(1), 50000, false), 1e-100);\n+    }\n+\n+    @Test\n+    public void testChildMinAreaHeightExtensively() {\n+        Pane pane = new Pane();\n+\n+        Region c1 = new MockBiased(Orientation.HORIZONTAL, 100, 200);\n+        Region c2 = new MockBiased(Orientation.VERTICAL, 100, 200);\n+        Region c3 = new MockRegion(10, 10, 100, 100, 1000, 1000);\n+\n+        pane.getChildren().addAll(c1, c2, c3);\n+\n+        \/*\n+         * Ensure that no fillWidth\/width combinations have effect on controls that are not horizontally biased:\n+         *\/\n+\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c2, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c2, -1, new Insets(1), -1, true), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c2, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c2, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c2, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c2, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c2, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c2, -1, new Insets(1), 50000, true), 1e-100);\n+\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c3, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c3, -1, new Insets(1), -1, true), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c3, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c3, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c3, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c3, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c3, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c3, -1, new Insets(1), 50000, true), 1e-100);\n+\n+        \/*\n+         * Tests biased control with no available width provided:\n+         *\n+         * Note: MockBiased returns a minimum width based on its preferred height.\n+         *\n+         * Expect 202 == insets + minHeight(-1)\n+         * - insets are 1 + 1 = 2\n+         * - minHeight(-1) returns 200 as MockBiased will base the minimum height on a\n+         *   reasonable width (in this case the result of prefWidth(-1) which is 100).\n+         *   When the MockBiased is 100 wide, it becomes 200 high.\n+         *\/\n+        assertEquals(2 + 200, RegionShim.computeChildMinAreaHeight(pane, c1, -1, new Insets(1), -1, false), 1e-100);\n+\n+        \/*\n+         * Ensure that fillWidth has no effect when there is no available width provided:\n+         *\/\n+\n+        assertEquals(2 + 200, RegionShim.computeChildMinAreaHeight(pane, c1, -1, new Insets(1), -1, true), 1e-100);\n+\n+        \/*\n+         * When the given available width is less than a horizontally biased control's preferred width, then\n+         * fillWidth should not have any effect as in both cases the width to use for determine the height\n+         * is capped at the smallest of the two width values; expect the control to be resized to the\n+         * available width, and that its height will be derived from this width as it is horizontally biased:\n+         *\/\n+\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildMinAreaHeight(pane, c1, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildMinAreaHeight(pane, c1, -1, new Insets(1), 50, false), 1e-100);\n+\n+        \/\/ with baseline\n+        assertEquals(2 + 10 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildMinAreaHeight(pane, c1, 10, new Insets(1), 50, true), 1e-100);\n+        assertEquals(2 + 10 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildMinAreaHeight(pane, c1, 10, new Insets(1), 50, false), 1e-100);\n+\n+        \/*\n+         * When the given available width is greater than a horizontally biased control's preferred width, then\n+         * fillWidth decides which of the two is used; when fillWidth is true, expect the control to be resized to the\n+         * available width, and that its height will be derived from this width as it is horizontally biased:\n+         *\/\n+\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (500.0 - 2)), RegionShim.computeChildMinAreaHeight(pane, c1, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(2 + 10 + Math.ceil(100 * 200 \/ (500.0 - 2)), RegionShim.computeChildMinAreaHeight(pane, c1, 10, new Insets(1), 500, true), 1e-100);\n+\n+        \/*\n+         * When the given available width is greater than a horizontally biased control's preferred width, then\n+         * fillWidth decides which of the two is used; when fillWidth is false, expect the control to be resized to the\n+         * its preferred width, and that its height will be derived from this width as it is horizontally biased:\n+         *\/\n+\n+        assertEquals(2 + 200, RegionShim.computeChildMinAreaHeight(pane, c1, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(2 + 10 + 200, RegionShim.computeChildMinAreaHeight(pane, c1, 10, new Insets(1), 500, false), 1e-100);\n+\n+        \/*\n+         * When the given available width is greater than a horizontally biased control's maximum width, then\n+         * fillWidth decides which of the two is used; when fillWidth is true, expect the control to be resized to the\n+         * available width, and that its height will be derived from this width as it is horizontally biased:\n+         *\/\n+\n+        assertEquals(2 + 1, RegionShim.computeChildMinAreaHeight(pane, c1, -1, new Insets(1), 50000, true), 1e-100);\n+        assertEquals(2 + 10 + 1, RegionShim.computeChildMinAreaHeight(pane, c1, 10, new Insets(1), 50000, true), 1e-100);\n+\n+        \/*\n+         * When the given available width is greater than a horizontally biased control's maximum width, then\n+         * fillWidth decides which of the two is used; when fillWidth is false, expect the control to be resized to the\n+         * its maximum width, and that its height will be derived from this width as it is horizontally biased:\n+         *\n+         * Note: MockBiased returns a maximum width based on its preferred height.\n+         *\/\n+\n+        assertEquals(2 + 200, RegionShim.computeChildMinAreaHeight(pane, c1, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(2 + 10 + 200, RegionShim.computeChildMinAreaHeight(pane, c1, 10, new Insets(1), 50000, false), 1e-100);\n+    }\n+\n+    @Test\n+    public void testChilPrefAreaWidthExtensively() {\n+        Pane pane = new Pane();\n+\n+        Region c1 = new MockBiased(Orientation.VERTICAL, 100, 200);\n+        Region c2 = new MockBiased(Orientation.HORIZONTAL, 100, 200);\n+        Region c3 = new MockRegion(10, 10, 100, 100, 1000, 1000);\n+\n+        pane.getChildren().addAll(c1, c2, c3);\n+\n+        \/*\n+         * Ensure that no fillHeight\/height combinations have effect on controls that are not vertically biased:\n+         *\/\n+\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c2, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c2, -1, new Insets(1), -1, true), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c2, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c2, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c2, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c2, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c2, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c2, -1, new Insets(1), 50000, true), 1e-100);\n+\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c3, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c3, -1, new Insets(1), -1, true), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c3, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c3, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c3, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c3, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c3, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c3, -1, new Insets(1), 50000, true), 1e-100);\n+\n+        \/*\n+         * Tests biased control with no available height provided:\n+         *\n+         * Note: MockBiased returns a minimum height based on its preferred width.\n+         *\n+         * Expect 102 == insets + minWidth(-1)\n+         * - insets are 1 + 1 = 2\n+         * - maxWidth(-1) returns 100 as MockBiased will base the maximum width on a\n+         *   reasonable height (in this case the result of prefHeight(-1) which is 200).\n+         *   When the MockBiased is 200 high, it becomes 100 wide.\n+         *\/\n+        assertEquals(2 + 100, RegionShim.computeChildPrefAreaWidth(pane, c1, -1, new Insets(1), -1, false), 1e-100);\n+\n+        \/*\n+         * Ensure that fillHeight has no effect when there is no available height provided:\n+         *\/\n+\n+        assertEquals(2 + 100, RegionShim.computeChildPrefAreaWidth(pane, c1, -1, new Insets(1), -1, true), 1e-100);\n+\n+        \/*\n+         * When the given available height is less than a vertically biased control's preferred height, then\n+         * fillHeight should not have any effect as in both cases the height to use for determine the width\n+         * is capped at the smallest of the two height values; expect the control to be resized to the\n+         * available height, and that its width will be derived from this height as it is vertically biased:\n+         *\/\n+\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildPrefAreaWidth(pane, c1, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildPrefAreaWidth(pane, c1, -1, new Insets(1), 50, false), 1e-100);\n+\n+        \/\/ with baseline\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2 - 10)), RegionShim.computeChildPrefAreaWidth(pane, c1, 10, new Insets(1), 50, true), 1e-100);\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2 - 10)), RegionShim.computeChildPrefAreaWidth(pane, c1, 10, new Insets(1), 50, false), 1e-100);\n+\n+        \/*\n+         * When the given available height is greater than a vertically biased control's preferred height, then\n+         * fillHeight decides which of the two is used; when fillHeight is true, expect the control to be resized to the\n+         * available height, and that its width will be derived from this height as it is vertically biased:\n+         *\/\n+\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (500.0 - 2)), RegionShim.computeChildPrefAreaWidth(pane, c1, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (500.0 - 2 - 10)), RegionShim.computeChildPrefAreaWidth(pane, c1, 10, new Insets(1), 500, true), 1e-100);\n+\n+        \/*\n+         * When the given available height is greater than a vertically biased control's preferred height, then\n+         * fillHeight decides which of the two is used; when fillHeight is false, expect the control to be resized to the\n+         * its preferred height, and that its width will be derived from this height as it is vertically biased:\n+         *\/\n+\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c1, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaWidth(pane, c1, 10, new Insets(1), 500, false), 1e-100);\n+\n+        \/*\n+         * When the given available height is greater than a vertically biased control's maximum height, then\n+         * fillHeight decides which of the two is used; when fillHeight is true, expect the control to be resized to the\n+         * available height, and that its width will be derived from this height as it is vertically biased:\n+         *\/\n+\n+        assertEquals(2 + 1, RegionShim.computeChildPrefAreaWidth(pane, c1, -1, new Insets(1), 50000, true), 1e-100);\n+        assertEquals(2 + 1, RegionShim.computeChildPrefAreaWidth(pane, c1, 10, new Insets(1), 50000, true), 1e-100);\n+\n+        \/*\n+         * When the given available height is greater than a vertically biased control's maximum height, then\n+         * fillHeight decides which of the two is used; when fillHeight is false, expect the control to be resized to the\n+         * its maximum height, and that its width will be derived from this height as it is vertically biased:\n+         *\n+         * Note: MockBiased returns a maximum height based on its preferred width.\n+         *\/\n+\n+        assertEquals(2 + 100, RegionShim.computeChildPrefAreaWidth(pane, c1, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(2 + 100, RegionShim.computeChildPrefAreaWidth(pane, c1, 10, new Insets(1), 50000, false), 1e-100);\n+    }\n+\n+    @Test\n+    public void testChildPrefAreaHeightExtensively() {\n+        Pane pane = new Pane();\n+\n+        Region c1 = new MockBiased(Orientation.HORIZONTAL, 100, 200);\n+        Region c2 = new MockBiased(Orientation.VERTICAL, 100, 200);\n+        Region c3 = new MockRegion(10, 10, 100, 100, 1000, 1000);\n+\n+        pane.getChildren().addAll(c1, c2, c3);\n+\n+        \/*\n+         * Ensure that no fillWidth\/width combinations have effect on controls that are not horizontally biased:\n+         *\/\n+\n+        assertEquals(202, RegionShim.computeChildPrefAreaHeight(pane, c2, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(202, RegionShim.computeChildPrefAreaHeight(pane, c2, -1, new Insets(1), -1, true), 1e-100);\n+        assertEquals(202, RegionShim.computeChildPrefAreaHeight(pane, c2, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(202, RegionShim.computeChildPrefAreaHeight(pane, c2, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(202, RegionShim.computeChildPrefAreaHeight(pane, c2, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(202, RegionShim.computeChildPrefAreaHeight(pane, c2, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(202, RegionShim.computeChildPrefAreaHeight(pane, c2, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(202, RegionShim.computeChildPrefAreaHeight(pane, c2, -1, new Insets(1), 50000, true), 1e-100);\n+\n+        assertEquals(102, RegionShim.computeChildPrefAreaHeight(pane, c3, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaHeight(pane, c3, -1, new Insets(1), -1, true), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaHeight(pane, c3, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaHeight(pane, c3, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaHeight(pane, c3, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaHeight(pane, c3, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaHeight(pane, c3, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildPrefAreaHeight(pane, c3, -1, new Insets(1), 50000, true), 1e-100);\n+\n+        \/*\n+         * Tests biased control with no available width provided:\n+         *\n+         * Note: MockBiased returns a maximum width based on its preferred height.\n+         *\n+         * Expect 202 == insets + maxHeight(-1)\n+         * - insets are 1 + 1 = 2\n+         * - maxHeight(-1) returns 200 as MockBiased will base the maximum height on a\n+         *   reasonable width (in this case the result of prefWidth(-1) which is 100).\n+         *   When the MockBiased is 100 wide, it becomes 200 high.\n+         *\/\n+        assertEquals(2 + 200, RegionShim.computeChildPrefAreaHeight(pane, c1, -1, new Insets(1), -1, false), 1e-100);\n+\n+        \/*\n+         * Ensure that fillWidth has no effect when there is no available width provided:\n+         *\/\n+\n+        assertEquals(2 + 200, RegionShim.computeChildPrefAreaHeight(pane, c1, -1, new Insets(1), -1, true), 1e-100);\n+\n+        \/*\n+         * When the given available width is less than a horizontally biased control's preferred width, then\n+         * fillWidth should not have any effect as in both cases the width to use for determine the height\n+         * is capped at the smallest of the two width values; expect the control to be resized to the\n+         * available width, and that its height will be derived from this width as it is horizontally biased:\n+         *\/\n+\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildPrefAreaHeight(pane, c1, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildPrefAreaHeight(pane, c1, -1, new Insets(1), 50, false), 1e-100);\n+\n+        \/\/ with baseline\n+        assertEquals(2 + 10 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildPrefAreaHeight(pane, c1, 10, new Insets(1), 50, true), 1e-100);\n+        assertEquals(2 + 10 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildPrefAreaHeight(pane, c1, 10, new Insets(1), 50, false), 1e-100);\n+\n+        \/*\n+         * When the given available width is greater than a horizontally biased control's preferred width, then\n+         * fillWidth decides which of the two is used; when fillWidth is true, expect the control to be resized to the\n+         * available width, and that its height will be derived from this width as it is horizontally biased:\n+         *\/\n+\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (500.0 - 2)), RegionShim.computeChildPrefAreaHeight(pane, c1, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(2 + 10 + Math.ceil(100 * 200 \/ (500.0 - 2)), RegionShim.computeChildPrefAreaHeight(pane, c1, 10, new Insets(1), 500, true), 1e-100);\n+\n+        \/*\n+         * When the given available width is greater than a horizontally biased control's preferred width, then\n+         * fillWidth decides which of the two is used; when fillWidth is false, expect the control to be resized to the\n+         * its preferred width, and that its height will be derived from this width as it is horizontally biased:\n+         *\/\n+\n+        assertEquals(2 + 200, RegionShim.computeChildPrefAreaHeight(pane, c1, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(2 + 10 + 200, RegionShim.computeChildPrefAreaHeight(pane, c1, 10, new Insets(1), 500, false), 1e-100);\n+\n+        \/*\n+         * When the given available width is greater than a horizontally biased control's maximum width, then\n+         * fillWidth decides which of the two is used; when fillWidth is true, expect the control to be resized to the\n+         * available width, and that its height will be derived from this width as it is horizontally biased:\n+         *\/\n+\n+        assertEquals(2 + 1, RegionShim.computeChildPrefAreaHeight(pane, c1, -1, new Insets(1), 50000, true), 1e-100);\n+        assertEquals(2 + 10 + 1, RegionShim.computeChildPrefAreaHeight(pane, c1, 10, new Insets(1), 50000, true), 1e-100);\n+\n+        \/*\n+         * When the given available width is greater than a horizontally biased control's maximum width, then\n+         * fillWidth decides which of the two is used; when fillWidth is false, expect the control to be resized to the\n+         * its maximum width, and that its height will be derived from this width as it is horizontally biased:\n+         *\n+         * Note: MockBiased returns a maximum width based on its preferred height.\n+         *\/\n+\n+        assertEquals(2 + 200, RegionShim.computeChildPrefAreaHeight(pane, c1, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(2 + 10 + 200, RegionShim.computeChildPrefAreaHeight(pane, c1, 10, new Insets(1), 50000, false), 1e-100);\n+    }\n+\n+    @Test\n+    public void testChildMaxAreaWidthExtensively() {\n+        Pane pane = new Pane();\n+\n+        Region c1 = new MockBiased(Orientation.VERTICAL, 100, 200);\n+        Region c2 = new MockBiased(Orientation.HORIZONTAL, 100, 200);\n+        Region c3 = new MockRegion(10, 10, 100, 100, 1000, 1000);\n+\n+        pane.getChildren().addAll(c1, c2, c3);\n+\n+        \/*\n+         * Ensure that no fillHeight\/height combinations have effect on controls that are not vertically biased:\n+         *\/\n+\n+        assertEquals(20002, RegionShim.computeChildMaxAreaWidth(pane, c2, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(20002, RegionShim.computeChildMaxAreaWidth(pane, c2, -1, new Insets(1), -1, true), 1e-100);\n+        assertEquals(20002, RegionShim.computeChildMaxAreaWidth(pane, c2, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(20002, RegionShim.computeChildMaxAreaWidth(pane, c2, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(20002, RegionShim.computeChildMaxAreaWidth(pane, c2, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(20002, RegionShim.computeChildMaxAreaWidth(pane, c2, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(20002, RegionShim.computeChildMaxAreaWidth(pane, c2, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(20002, RegionShim.computeChildMaxAreaWidth(pane, c2, -1, new Insets(1), 50000, true), 1e-100);\n+\n+        assertEquals(1002, RegionShim.computeChildMaxAreaWidth(pane, c3, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaWidth(pane, c3, -1, new Insets(1), -1, true), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaWidth(pane, c3, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaWidth(pane, c3, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaWidth(pane, c3, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaWidth(pane, c3, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaWidth(pane, c3, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaWidth(pane, c3, -1, new Insets(1), 50000, true), 1e-100);\n+\n+        \/*\n+         * Tests biased control with no available height provided:\n+         *\n+         * Note: MockBiased returns a minimum height based on its preferred width.\n+         *\n+         * Expect 102 == insets + minWidth(-1)\n+         * - insets are 1 + 1 = 2\n+         * - maxWidth(-1) returns 100 as MockBiased will base the maximum width on a\n+         *   reasonable height (in this case the result of prefHeight(-1) which is 200).\n+         *   When the MockBiased is 200 high, it becomes 100 wide.\n+         *\/\n+        assertEquals(2 + 100, RegionShim.computeChildMaxAreaWidth(pane, c1, -1, new Insets(1), -1, false), 1e-100);\n+\n+        \/*\n+         * Ensure that fillHeight has no effect when there is no available height provided:\n+         *\/\n+\n+        assertEquals(2 + 100, RegionShim.computeChildMaxAreaWidth(pane, c1, -1, new Insets(1), -1, true), 1e-100);\n+\n+        \/*\n+         * When the given available height is less than a vertically biased control's preferred height, then\n+         * fillHeight should not have any effect as in both cases the height to use for determine the width\n+         * is capped at the smallest of the two height values; expect the control to be resized to the\n+         * available height, and that its width will be derived from this height as it is vertically biased:\n+         *\/\n+\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildMaxAreaWidth(pane, c1, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildMaxAreaWidth(pane, c1, -1, new Insets(1), 50, false), 1e-100);\n+\n+        \/\/ with baseline\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2 - 10)), RegionShim.computeChildMaxAreaWidth(pane, c1, 10, new Insets(1), 50, true), 1e-100);\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2 - 10)), RegionShim.computeChildMaxAreaWidth(pane, c1, 10, new Insets(1), 50, false), 1e-100);\n+\n+        \/*\n+         * When the given available height is greater than a vertically biased control's preferred height, then\n+         * fillHeight decides which of the two is used; when fillHeight is true, expect the control to be resized to the\n+         * available height, and that its width will be derived from this height as it is vertically biased:\n+         *\/\n+\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (500.0 - 2)), RegionShim.computeChildMaxAreaWidth(pane, c1, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (500.0 - 2 - 10)), RegionShim.computeChildMaxAreaWidth(pane, c1, 10, new Insets(1), 500, true), 1e-100);\n+\n+        \/*\n+         * When the given available height is greater than a vertically biased control's preferred height, then\n+         * fillHeight decides which of the two is used; when fillHeight is false, expect the control to be resized to the\n+         * its preferred height, and that its width will be derived from this height as it is vertically biased:\n+         *\/\n+\n+        assertEquals(102, RegionShim.computeChildMaxAreaWidth(pane, c1, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(102, RegionShim.computeChildMaxAreaWidth(pane, c1, 10, new Insets(1), 500, false), 1e-100);\n+\n+        \/*\n+         * When the given available height is greater than a vertically biased control's maximum height, then\n+         * fillHeight decides which of the two is used; when fillHeight is true, expect the control to be resized to the\n+         * available height, and that its width will be derived from this height as it is vertically biased:\n+         *\/\n+\n+        assertEquals(2 + 1, RegionShim.computeChildMaxAreaWidth(pane, c1, -1, new Insets(1), 50000, true), 1e-100);\n+        assertEquals(2 + 1, RegionShim.computeChildMaxAreaWidth(pane, c1, 10, new Insets(1), 50000, true), 1e-100);\n+\n+        \/*\n+         * When the given available height is greater than a vertically biased control's maximum height, then\n+         * fillHeight decides which of the two is used; when fillHeight is false, expect the control to be resized to the\n+         * its maximum height, and that its width will be derived from this height as it is vertically biased:\n+         *\n+         * Note: MockBiased returns a maximum height based on its preferred width.\n+         *\/\n+\n+        assertEquals(2 + 100, RegionShim.computeChildMaxAreaWidth(pane, c1, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(2 + 100, RegionShim.computeChildMaxAreaWidth(pane, c1, 10, new Insets(1), 50000, false), 1e-100);\n+    }\n+\n+    @Test\n+    public void testChildMaxAreaHeightExtensively() {\n+        Pane pane = new Pane();\n+\n+        Region c1 = new MockBiased(Orientation.HORIZONTAL, 100, 200);\n+        Region c2 = new MockBiased(Orientation.VERTICAL, 100, 200);\n+        Region c3 = new MockRegion(10, 10, 100, 100, 1000, 1000);\n+\n+        pane.getChildren().addAll(c1, c2, c3);\n+\n+        \/*\n+         * Ensure that no fillWidth\/width combinations have effect on controls that are not horizontally biased:\n+         *\/\n+\n+        assertEquals(20002, RegionShim.computeChildMaxAreaHeight(pane, c2, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(20002, RegionShim.computeChildMaxAreaHeight(pane, c2, -1, new Insets(1), -1, true), 1e-100);\n+        assertEquals(20002, RegionShim.computeChildMaxAreaHeight(pane, c2, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(20002, RegionShim.computeChildMaxAreaHeight(pane, c2, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(20002, RegionShim.computeChildMaxAreaHeight(pane, c2, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(20002, RegionShim.computeChildMaxAreaHeight(pane, c2, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(20002, RegionShim.computeChildMaxAreaHeight(pane, c2, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(20002, RegionShim.computeChildMaxAreaHeight(pane, c2, -1, new Insets(1), 50000, true), 1e-100);\n+\n+        assertEquals(1002, RegionShim.computeChildMaxAreaHeight(pane, c3, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaHeight(pane, c3, -1, new Insets(1), -1, true), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaHeight(pane, c3, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaHeight(pane, c3, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaHeight(pane, c3, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaHeight(pane, c3, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaHeight(pane, c3, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaHeight(pane, c3, -1, new Insets(1), 50000, true), 1e-100);\n+\n+        \/*\n+         * Tests biased control with no available width provided:\n+         *\n+         * Note: MockBiased returns a maximum width based on its preferred height.\n+         *\n+         * Expect 202 == insets + maxHeight(-1)\n+         * - insets are 1 + 1 = 2\n+         * - maxHeight(-1) returns 200 as MockBiased will base the maximum height on a\n+         *   reasonable width (in this case the result of prefWidth(-1) which is 100).\n+         *   When the MockBiased is 100 wide, it becomes 200 high.\n+         *\/\n+        assertEquals(2 + 200, RegionShim.computeChildMaxAreaHeight(pane, c1, -1, new Insets(1), -1, false), 1e-100);\n+\n+        \/*\n+         * Ensure that fillWidth has no effect when there is no available width provided:\n+         *\/\n+\n+        assertEquals(2 + 200, RegionShim.computeChildMaxAreaHeight(pane, c1, -1, new Insets(1), -1, true), 1e-100);\n+\n+        \/*\n+         * When the given available width is less than a horizontally biased control's preferred width, then\n+         * fillWidth should not have any effect as in both cases the width to use for determine the height\n+         * is capped at the smallest of the two width values; expect the control to be resized to the\n+         * available width, and that its height will be derived from this width as it is horizontally biased:\n+         *\/\n+\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildMaxAreaHeight(pane, c1, -1, new Insets(1), 50, true), 1e-100);\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildMaxAreaHeight(pane, c1, -1, new Insets(1), 50, false), 1e-100);\n+\n+        \/\/ with baseline\n+        assertEquals(2 + 10 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildMaxAreaHeight(pane, c1, 10, new Insets(1), 50, true), 1e-100);\n+        assertEquals(2 + 10 + Math.ceil(100 * 200 \/ (50.0 - 2)), RegionShim.computeChildMaxAreaHeight(pane, c1, 10, new Insets(1), 50, false), 1e-100);\n+\n+        \/*\n+         * When the given available width is greater than a horizontally biased control's preferred width, then\n+         * fillWidth decides which of the two is used; when fillWidth is true, expect the control to be resized to the\n+         * available width, and that its height will be derived from this width as it is horizontally biased:\n+         *\/\n+\n+        assertEquals(2 + Math.ceil(100 * 200 \/ (500.0 - 2)), RegionShim.computeChildMaxAreaHeight(pane, c1, -1, new Insets(1), 500, true), 1e-100);\n+        assertEquals(2 + 10 + Math.ceil(100 * 200 \/ (500.0 - 2)), RegionShim.computeChildMaxAreaHeight(pane, c1, 10, new Insets(1), 500, true), 1e-100);\n+\n+        \/*\n+         * When the given available width is greater than a horizontally biased control's preferred width, then\n+         * fillWidth decides which of the two is used; when fillWidth is false, expect the control to be resized to the\n+         * its preferred width, and that its height will be derived from this width as it is horizontally biased:\n+         *\/\n+\n+        assertEquals(2 + 200, RegionShim.computeChildMaxAreaHeight(pane, c1, -1, new Insets(1), 500, false), 1e-100);\n+        assertEquals(2 + 10 + 200, RegionShim.computeChildMaxAreaHeight(pane, c1, 10, new Insets(1), 500, false), 1e-100);\n+\n+        \/*\n+         * When the given available width is greater than a horizontally biased control's maximum width, then\n+         * fillWidth decides which of the two is used; when fillWidth is true, expect the control to be resized to the\n+         * available width, and that its height will be derived from this width as it is horizontally biased:\n+         *\/\n+\n+        assertEquals(2 + 1, RegionShim.computeChildMaxAreaHeight(pane, c1, -1, new Insets(1), 50000, true), 1e-100);\n+        assertEquals(2 + 10 + 1, RegionShim.computeChildMaxAreaHeight(pane, c1, 10, new Insets(1), 50000, true), 1e-100);\n+\n+        \/*\n+         * When the given available width is greater than a horizontally biased control's maximum width, then\n+         * fillWidth decides which of the two is used; when fillWidth is false, expect the control to be resized to the\n+         * its maximum width, and that its height will be derived from this width as it is horizontally biased:\n+         *\n+         * Note: MockBiased returns a maximum width based on its preferred height.\n+         *\/\n+\n+        assertEquals(2 + 200, RegionShim.computeChildMaxAreaHeight(pane, c1, -1, new Insets(1), 50000, false), 1e-100);\n+        assertEquals(2 + 10 + 200, RegionShim.computeChildMaxAreaHeight(pane, c1, 10, new Insets(1), 50000, false), 1e-100);\n+    }\n+\n+    @Test\n+    public void testChildMinAreaWidth() {  \/\/ See improved version of this test above\n@@ -1032,1 +1656,1 @@\n-    public void testChildMinAreaHeight() {\n+    public void testChildMinAreaHeight() {  \/\/ See improved version of this test above\n@@ -1041,7 +1665,12 @@\n-        assertEquals(3, RegionShim.computeChildMinAreaHeight(pane, c1, -1, new Insets(1), -1), 1e-100); \/*Insets + minimal for biased is 1 *\/\n-        assertEquals(2 + Math.ceil(100*100\/48.0), RegionShim.computeChildMinAreaHeight(pane, c1, -1, new Insets(1), 50), 1e-100);\n-        assertEquals(12 + Math.ceil(100*100\/48.0), RegionShim.computeChildMinAreaHeight(pane, c1, 10, new Insets(1), 50), 1e-100);\n-        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c2, -1, new Insets(1), -1), 1e-100);\n-        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c2, -1, new Insets(1), 50), 1e-100);\n-        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c3, -1, new Insets(1), -1), 1e-100);\n-        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c3, -1, new Insets(1), 50), 1e-100);\n+        \/\/ This used to assert 3, but this is incorrect. The control involved is biased\n+        \/\/ and its minWidth(-1) will never return 1 (see MockBiased code). Instead,\n+        \/\/ minWidth(-1) returns 100 as it assumes a reasonable height (in this case\n+        \/\/ the result of prefHeight(-1) which is 100).\n+        assertEquals(102, RegionShim.computeChildMinAreaHeight(pane, c1, -1, new Insets(1), -1, false), 1e-100);\n+\n+        assertEquals(2 + Math.ceil(100*100\/48.0), RegionShim.computeChildMinAreaHeight(pane, c1, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(12 + Math.ceil(100*100\/48.0), RegionShim.computeChildMinAreaHeight(pane, c1, 10, new Insets(1), 50, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c2, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c2, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c3, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(12, RegionShim.computeChildMinAreaHeight(pane, c3, -1, new Insets(1), 50, false), 1e-100);\n@@ -1051,1 +1680,1 @@\n-    public void testChildMaxAreaWidth() {\n+    public void testChildMaxAreaWidth() {  \/\/ See improved version of this test above\n@@ -1070,1 +1699,1 @@\n-    public void testChildMaxAreaHeight() {\n+    public void testChildMaxAreaHeight() {  \/\/ See improved version of this test above\n@@ -1079,7 +1708,27 @@\n-        assertEquals(1002, RegionShim.computeChildMaxAreaHeight(pane,c1, -1, new Insets(1), -1), 1e-100);\n-        assertEquals(2 + Math.ceil(100*100\/48.0), RegionShim.computeChildMaxAreaHeight(pane,c1, -1, new Insets(1), 50), 1e-100);\n-        assertEquals(12 + Math.ceil(100*100\/48.0), RegionShim.computeChildMaxAreaHeight(pane,c1, 10, new Insets(1), 50), 1e-100);\n-        assertEquals(10002, RegionShim.computeChildMaxAreaHeight(pane,c2, -1, new Insets(1), -1), 1e-100);\n-        assertEquals(10002, RegionShim.computeChildMaxAreaHeight(pane,c2, -1, new Insets(1), 50), 1e-100);\n-        assertEquals(1002, RegionShim.computeChildMaxAreaHeight(pane,c3, -1, new Insets(1), -1), 1e-100);\n-        assertEquals(1002, RegionShim.computeChildMaxAreaHeight(pane,c3, -1, new Insets(1), 50), 1e-100);\n+        \/\/ This used to assert 1002, but this is incorrect.\n+        \/\/\n+        \/\/ This control is horizontally biased, but no available width\n+        \/\/ is provided (it is set to -1). This means that no bias should be used\n+        \/\/ and the result should simply be the result of maxHeight(-1). The\n+        \/\/ MockBiased instance will then return 100 (see MockBiased#maxHeight\n+        \/\/ implementation).\n+        \/\/\n+        \/\/ How did the old code arrive at 1002?\n+        \/\/\n+        \/\/ There was a bug in computeChildMaxAreaHeight where the bias logic was\n+        \/\/ still partially executed. It would call \"child.minWidth(-1)\" which\n+        \/\/ is 10 for a horizontal MockBiased instance. Even though the bias logic\n+        \/\/ should be skipped, it would still use this value to do its call to maxHeight\n+        \/\/ instead of using -1. A call of child.maxHeight(10) is basically asking\n+        \/\/ what should the height be if the width is 10? As MockBiased tries to\n+        \/\/ always display exactly prefWidth*prefHeight pixels (100 * 100 in this\n+        \/\/ case) the answer is (100 * 100) \/ 10 = 1000. Adding the insets gets\n+        \/\/ us 1002.\n+        assertEquals(102, RegionShim.computeChildMaxAreaHeight(pane,c1, -1, new Insets(1), -1, false), 1e-100);\n+\n+        assertEquals(2 + Math.ceil(100*100\/48.0), RegionShim.computeChildMaxAreaHeight(pane,c1, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(12 + Math.ceil(100*100\/48.0), RegionShim.computeChildMaxAreaHeight(pane,c1, 10, new Insets(1), 50, false), 1e-100);\n+        assertEquals(10002, RegionShim.computeChildMaxAreaHeight(pane,c2, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(10002, RegionShim.computeChildMaxAreaHeight(pane,c2, -1, new Insets(1), 50, false), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaHeight(pane,c3, -1, new Insets(1), -1, false), 1e-100);\n+        assertEquals(1002, RegionShim.computeChildMaxAreaHeight(pane,c3, -1, new Insets(1), 50, false), 1e-100);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/RegionTest.java","additions":667,"deletions":18,"binary":false,"changes":685,"status":"modified"}]}