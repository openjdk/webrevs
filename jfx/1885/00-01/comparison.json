{"files":[{"patch":"@@ -30,0 +30,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -31,1 +33,7 @@\n-abstract class IterableMapChange<K, V> extends MapChangeListener.Change<K, V> {\n+\/**\n+ * Base class for map changes that support bulk change iteration.\n+ *\n+ * @param <K> the key type\n+ * @param <V> the value type\n+ *\/\n+public sealed abstract class IterableMapChange<K, V> extends MapChangeListener.Change<K, V> {\n@@ -33,1 +41,1 @@\n-    public IterableMapChange(ObservableMap<K, V> map) {\n+    private IterableMapChange(ObservableMap<K, V> map) {\n@@ -37,1 +45,12 @@\n-    public abstract boolean nextChange();\n+    \/**\n+     * Returns {@code this} object instance if there is another change to report, or {@code null} if there\n+     * are no more changes. If this method returns another change, the implementation must configure this\n+     * object instance to represent the next change.\n+     * <p>\n+     * Note that this narrows down the {@link MapChangeListener.Change#next()} specification, which does\n+     * not mandate that the same object instance is returned on each call.\n+     *\n+     * @return this instance, representing the next change, or {@code null} if there are no more changes\n+     *\/\n+    @Override\n+    public abstract MapChangeListener.Change<K, V> next();\n@@ -39,0 +58,3 @@\n+    \/**\n+     * Resets this {@code IterableMapChange} instance to the first change.\n+     *\/\n@@ -40,0 +62,160 @@\n+\n+    @Override\n+    public final String toString() {\n+        StringBuilder builder = new StringBuilder();\n+\n+        if (wasAdded()) {\n+            if (wasRemoved()) {\n+                builder.append(getValueRemoved()).append(\" replaced by \").append(getValueAdded());\n+            } else {\n+                builder.append(getValueAdded()).append(\" added\");\n+            }\n+        } else {\n+            builder.append(getValueRemoved()).append(\" removed\");\n+        }\n+\n+        return builder.append(\" at key \").append(getKey()).toString();\n+    }\n+\n+    public final static class Remove<K, V> extends IterableMapChange<K, V> {\n+\n+        private record Entry<K, V>(K key, V value) {}\n+\n+        private final List<Entry<K, V>> changes;\n+        private int index;\n+\n+        public Remove(ObservableMap<K, V> map) {\n+            super(map);\n+            changes = new ArrayList<>();\n+        }\n+\n+        public Remove(ObservableMap<K, V> map, int initialCapacity) {\n+            super(map);\n+            changes = new ArrayList<>(initialCapacity);\n+        }\n+\n+        @Override\n+        public MapChangeListener.Change<K, V> next() {\n+            if (index < changes.size() - 1) {\n+                ++index;\n+                return this;\n+            }\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public void reset() {\n+            index = 0;\n+        }\n+\n+        @Override\n+        public boolean wasAdded() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean wasRemoved() {\n+            return true;\n+        }\n+\n+        @Override\n+        public K getKey() {\n+            return changes.get(index).key;\n+        }\n+\n+        @Override\n+        public V getValueAdded() {\n+            return null;\n+        }\n+\n+        @Override\n+        public V getValueRemoved() {\n+            return changes.get(index).value;\n+        }\n+\n+        public void nextRemoved(K key, V value) {\n+            changes.add(new Entry<>(key, value));\n+        }\n+    }\n+\n+    public final static class Generic<K, V> extends IterableMapChange<K, V> {\n+\n+        private static final Object NO_VALUE = new Object();\n+\n+        private record Entry<K, V>(K key, V newValue, V oldValue) {\n+            boolean wasAdded() {\n+                return newValue != NO_VALUE;\n+            }\n+\n+            boolean wasRemoved() {\n+                return oldValue != NO_VALUE;\n+            }\n+        }\n+\n+        private final List<Entry<K, V>> changes;\n+        private int index;\n+\n+        public Generic(ObservableMap<K, V> map) {\n+            super(map);\n+            changes = new ArrayList<>();\n+        }\n+\n+        @Override\n+        public MapChangeListener.Change<K, V> next() {\n+            if (index < changes.size() - 1) {\n+                ++index;\n+                return this;\n+            }\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public void reset() {\n+            index = 0;\n+        }\n+\n+        @Override\n+        public boolean wasAdded() {\n+            return changes.get(index).wasAdded();\n+        }\n+\n+        @Override\n+        public boolean wasRemoved() {\n+            return changes.get(index).wasRemoved();\n+        }\n+\n+        @Override\n+        public K getKey() {\n+            return changes.get(index).key;\n+        }\n+\n+        @Override\n+        public V getValueAdded() {\n+            var change = changes.get(index);\n+            return change.wasAdded() ? change.newValue : null;\n+        }\n+\n+        @Override\n+        public V getValueRemoved() {\n+            var change = changes.get(index);\n+            return change.wasRemoved() ? change.oldValue : null;\n+        }\n+\n+        public void nextAdded(K key, V value) {\n+            @SuppressWarnings(\"unchecked\")\n+            var entry = new Entry<>(key, value, (V)NO_VALUE);\n+            changes.add(entry);\n+        }\n+\n+        public void nextRemoved(K key, V value) {\n+            @SuppressWarnings(\"unchecked\")\n+            var entry = new Entry<>(key, (V)NO_VALUE, value);\n+            changes.add(entry);\n+        }\n+\n+        public void nextReplaced(K key, V oldValue, V newValue) {\n+            changes.add(new Entry<>(key, newValue, oldValue));\n+        }\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/IterableMapChange.java","additions":185,"deletions":3,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.List;\n@@ -31,1 +32,6 @@\n-abstract class IterableSetChange<E> extends SetChangeListener.Change<E> {\n+\/**\n+ * Base class for set changes that support bulk change iteration.\n+ *\n+ * @param <E> the element type\n+ *\/\n+public sealed abstract class IterableSetChange<E> extends SetChangeListener.Change<E> {\n@@ -33,1 +39,1 @@\n-    public IterableSetChange(ObservableSet<E> set) {\n+    private IterableSetChange(ObservableSet<E> set) {\n@@ -37,1 +43,12 @@\n-    public abstract boolean nextChange();\n+    \/**\n+     * Returns {@code this} object instance if there is another change to report, or {@code null} if there\n+     * are no more changes. If this method returns another change, the implementation must configure this\n+     * object instance to represent the next change.\n+     * <p>\n+     * Note that this narrows down the {@link SetChangeListener.Change#next()} specification, which does\n+     * not mandate that the same object instance is returned on each call.\n+     *\n+     * @return this instance, representing the next change, or {@code null} if there are no more changes\n+     *\/\n+    @Override\n+    public abstract SetChangeListener.Change<E> next();\n@@ -39,0 +56,3 @@\n+    \/**\n+     * Resets this {@code IterableSetChange} instance to the first change.\n+     *\/\n@@ -40,0 +60,102 @@\n+\n+    public static final class Add<E> extends IterableSetChange<E> {\n+\n+        private final List<E> elements;\n+        private int index;\n+\n+        public Add(ObservableSet<E> set, List<E> elements) {\n+            super(set);\n+            this.elements = elements;\n+        }\n+\n+        @Override\n+        public SetChangeListener.Change<E> next() {\n+            if (index < elements.size() - 1) {\n+                ++index;\n+                return this;\n+            }\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public void reset() {\n+            index = 0;\n+        }\n+\n+        @Override\n+        public boolean wasAdded() {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean wasRemoved() {\n+            return false;\n+        }\n+\n+        @Override\n+        public E getElementAdded() {\n+            return elements.get(index);\n+        }\n+\n+        @Override\n+        public E getElementRemoved() {\n+            return null;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"added \" + elements.get(index);\n+        }\n+    }\n+\n+    public static final class Remove<E> extends IterableSetChange<E> {\n+\n+        private final List<E> elements;\n+        private int index;\n+\n+        public Remove(ObservableSet<E> set, List<E> elements) {\n+            super(set);\n+            this.elements = elements;\n+        }\n+\n+        @Override\n+        public SetChangeListener.Change<E> next() {\n+            if (index < elements.size() - 1) {\n+                ++index;\n+                return this;\n+            }\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public void reset() {\n+            index = 0;\n+        }\n+\n+        @Override\n+        public boolean wasAdded() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean wasRemoved() {\n+            return true;\n+        }\n+\n+        @Override\n+        public E getElementAdded() {\n+            return null;\n+        }\n+\n+        @Override\n+        public E getElementRemoved() {\n+            return elements.get(index);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"removed \" + elements.get(index);\n+        }\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/IterableSetChange.java","additions":125,"deletions":3,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-            } while (change instanceof IterableMapChange<? extends K, ? extends V> c && c.nextChange());\n+            } while (change instanceof IterableMapChange<? extends K, ? extends V> c && c.next() != null);\n@@ -358,1 +358,1 @@\n-                } while (change.nextChange());\n+                } while (change.next() != null);\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/MapListenerHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-            var change = new BulkChange.AddReplace<>(this, size);\n+            var change = new IterableMapChange.Generic<>(this);\n@@ -156,1 +156,0 @@\n-            change.complete();\n@@ -188,2 +187,1 @@\n-                        int capacity = backingMap.size() - i + 1;\n-                        var bulkChange = new BulkChange.AddReplace<>(ObservableMapWrapper.this, capacity);\n+                        var bulkChange = new IterableMapChange.Generic<>(ObservableMapWrapper.this);\n@@ -193,1 +191,1 @@\n-                    } else if (change instanceof BulkChange.AddReplace<K, V> bulkChange) {\n+                    } else if (change instanceof IterableMapChange.Generic<K, V> bulkChange) {\n@@ -211,4 +209,0 @@\n-        if (change instanceof BulkChange<K, V> bulkChange) {\n-            bulkChange.complete();\n-        }\n-\n@@ -230,1 +224,1 @@\n-            var change = new BulkChange.Remove<>(this, size);\n+            var change = new IterableMapChange.Remove<>(this, size);\n@@ -236,1 +230,0 @@\n-            change.complete();\n@@ -253,5 +246,1 @@\n-                    int capacity = remove\n-                        ? Math.min(backingMap.size() + 1, c.size())\n-                        : backingMap.size() + 1;\n-\n-                    var bulkChange = new BulkChange.Remove<>(ObservableMapWrapper.this, capacity);\n+                    var bulkChange = new IterableMapChange.Remove<>(ObservableMapWrapper.this);\n@@ -261,1 +250,1 @@\n-                } else if (change instanceof BulkChange.Remove<K, V> bulkChange) {\n+                } else if (change instanceof IterableMapChange.Remove<K, V> bulkChange) {\n@@ -275,4 +264,0 @@\n-        if (change instanceof BulkChange<K, V> bulkChange) {\n-            bulkChange.complete();\n-        }\n-\n@@ -844,148 +829,0 @@\n-    private static abstract sealed class BulkChange<K, V> extends IterableMapChange<K, V> {\n-\n-        final int capacity;\n-        final K[] keys;\n-        int size;\n-        int index;\n-\n-        @SuppressWarnings(\"unchecked\")\n-        BulkChange(ObservableMapWrapper<K, V> map, int capacity) {\n-            super(map);\n-            this.capacity = capacity;\n-            this.keys = (K[])new Object[capacity];\n-        }\n-\n-        final void complete() {\n-            size = index;\n-            index = 0;\n-        }\n-\n-        @Override\n-        public final boolean nextChange() {\n-            if (index < size - 1) {\n-                ++index;\n-                return true;\n-            }\n-\n-            return false;\n-        }\n-\n-        @Override\n-        public final MapChangeListener.Change<K, V> next() {\n-            if (index < size - 1) {\n-                ++index;\n-                return this;\n-            }\n-\n-            return null;\n-        }\n-\n-        @Override\n-        public final void reset() {\n-            index = 0;\n-        }\n-\n-        @Override\n-        public final String toString() {\n-            return changeToString(this);\n-        }\n-\n-        final static class Remove<K, V> extends BulkChange<K, V> {\n-\n-            private final V[] values;\n-\n-            @SuppressWarnings(\"unchecked\")\n-            Remove(ObservableMapWrapper<K, V> map, int capacity) {\n-                super(map, capacity);\n-                this.values = (V[])new Object[capacity];\n-            }\n-\n-            void nextRemoved(K key, V value) {\n-                keys[index] = key;\n-                values[index] = value;\n-                ++index;\n-            }\n-\n-            @Override\n-            public boolean wasAdded() {\n-                return false;\n-            }\n-\n-            @Override\n-            public boolean wasRemoved() {\n-                return true;\n-            }\n-\n-            @Override\n-            public K getKey() {\n-                return keys[index];\n-            }\n-\n-            @Override\n-            public V getValueAdded() {\n-                return values[index];\n-            }\n-\n-            @Override\n-            public V getValueRemoved() {\n-                return values[index];\n-            }\n-        }\n-\n-        final static class AddReplace<K, V> extends BulkChange<K, V> {\n-\n-            private static final int ADDED = 1;\n-            private static final int REMOVED = 2;\n-\n-            private final V[] values;\n-            private final int[] addedRemoved;\n-\n-            @SuppressWarnings(\"unchecked\")\n-            AddReplace(ObservableMapWrapper<K, V> map, int capacity) {\n-                super(map, capacity);\n-                this.values = (V[])new Object[capacity * 2];\n-                this.addedRemoved = new int[capacity];\n-            }\n-\n-            void nextAdded(K key, V value) {\n-                keys[index] = key;\n-                values[index * 2 + 1] = value;\n-                addedRemoved[index] = ADDED;\n-                ++index;\n-            }\n-\n-            void nextReplaced(K key, V oldValue, V newValue) {\n-                keys[index] = key;\n-                values[index * 2] = oldValue;\n-                values[index * 2 + 1] = newValue;\n-                addedRemoved[index] = ADDED | REMOVED;\n-                ++index;\n-            }\n-\n-            @Override\n-            public boolean wasAdded() {\n-                return (addedRemoved[index] & ADDED) != 0;\n-            }\n-\n-            @Override\n-            public boolean wasRemoved() {\n-                return (addedRemoved[index] & REMOVED) != 0;\n-            }\n-\n-            @Override\n-            public K getKey() {\n-                return keys[index];\n-            }\n-\n-            @Override\n-            public V getValueAdded() {\n-                return values[index * 2 + 1];\n-            }\n-\n-            @Override\n-            public V getValueRemoved() {\n-                return values[index * 2];\n-            }\n-        }\n-    }\n-\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ObservableMapWrapper.java","additions":6,"deletions":169,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -127,101 +127,0 @@\n-    private abstract static sealed class AbstractIterableSetChange<E> extends IterableSetChange<E>\n-            permits IterableAddChange, IterableRemoveChange {\n-\n-        final List<E> elements;\n-        int index;\n-\n-        public AbstractIterableSetChange(ObservableSet<E> set, List<E> elements) {\n-            super(set);\n-            this.elements = elements;\n-        }\n-\n-        @Override\n-        public final boolean nextChange() {\n-            if (index < elements.size() - 1) {\n-                ++index;\n-                return true;\n-            }\n-\n-            return false;\n-        }\n-\n-        @Override\n-        public final SetChangeListener.Change<E> next() {\n-            if (index < elements.size() - 1) {\n-                ++index;\n-                return this;\n-            }\n-\n-            return null;\n-        }\n-\n-        @Override\n-        public final void reset() {\n-            index = 0;\n-        }\n-    }\n-\n-    private static final class IterableAddChange<E> extends AbstractIterableSetChange<E> {\n-\n-        IterableAddChange(ObservableSet<E> set, List<E> elements) {\n-            super(set, elements);\n-        }\n-\n-        @Override\n-        public boolean wasAdded() {\n-            return true;\n-        }\n-\n-        @Override\n-        public boolean wasRemoved() {\n-            return false;\n-        }\n-\n-        @Override\n-        public E getElementAdded() {\n-            return elements.get(index);\n-        }\n-\n-        @Override\n-        public E getElementRemoved() {\n-            return null;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"added \" + elements.get(index);\n-        }\n-    }\n-\n-    private static final class IterableRemoveChange<E> extends AbstractIterableSetChange<E> {\n-\n-        IterableRemoveChange(ObservableSet<E> set, List<E> elements) {\n-            super(set, elements);\n-        }\n-\n-        @Override\n-        public boolean wasAdded() {\n-            return false;\n-        }\n-\n-        @Override\n-        public boolean wasRemoved() {\n-            return true;\n-        }\n-\n-        @Override\n-        public E getElementAdded() {\n-            return null;\n-        }\n-\n-        @Override\n-        public E getElementRemoved() {\n-            return elements.get(index);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"removed \" + elements.get(index);\n-        }\n-    }\n-\n@@ -441,1 +340,1 @@\n-            callObservers(new IterableAddChange<>(this, addedList));\n+            callObservers(new IterableSetChange.Add<>(this, addedList));\n@@ -518,1 +417,1 @@\n-            callObservers(new IterableRemoveChange<>(this, removedList));\n+            callObservers(new IterableSetChange.Remove<>(this, removedList));\n@@ -537,1 +436,1 @@\n-            callObservers(new IterableRemoveChange<>(this, Arrays.asList(removed)));\n+            callObservers(new IterableSetChange.Remove<>(this, Arrays.asList(removed)));\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ObservableSetWrapper.java","additions":3,"deletions":104,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-            } while (change instanceof IterableSetChange<? extends E> c && c.nextChange());\n+            } while (change instanceof IterableSetChange<? extends E> c && c.next() != null);\n@@ -358,1 +358,1 @@\n-                } while (change.nextChange());\n+                } while (change.next() != null);\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/SetListenerHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import com.sun.javafx.binding.MapExpressionHelper;\n+import com.sun.javafx.collections.IterableMapChange;\n+import com.sun.javafx.collections.MapListenerHelper;\n@@ -41,1 +42,0 @@\n-import java.util.List;\n@@ -46,1 +46,0 @@\n-import java.util.concurrent.CopyOnWriteArrayList;\n@@ -79,2 +78,1 @@\n-    private final List<InvalidationListener> invalidationListeners = new CopyOnWriteArrayList<>();\n-    private final List<MapChangeListener<? super String, Object>> mapChangeListeners = new CopyOnWriteArrayList<>();\n+    private MapListenerHelper<String, Object> helper;\n@@ -108,1 +106,1 @@\n-        invalidationListeners.add(listener);\n+        helper = MapListenerHelper.addListener(helper, listener);\n@@ -113,1 +111,1 @@\n-        invalidationListeners.remove(listener);\n+        helper = MapListenerHelper.removeListener(helper, listener);\n@@ -118,1 +116,1 @@\n-        mapChangeListeners.add(listener);\n+        helper = MapListenerHelper.addListener(helper, listener);\n@@ -123,1 +121,1 @@\n-        mapChangeListeners.remove(listener);\n+        helper = MapListenerHelper.removeListener(helper, listener);\n@@ -314,2 +312,1 @@\n-        invalidationListeners.forEach(listener -> listener.invalidated(this));\n-        var change = new MapExpressionHelper.SimpleChange<>(this);\n+        var change = new IterableMapChange.Generic<>(this);\n@@ -322,1 +319,1 @@\n-                change.setAdded(entry.getKey(), newValue);\n+                change.nextAdded(entry.getKey(), newValue);\n@@ -324,1 +321,1 @@\n-                change.setRemoved(entry.getKey(), oldValue);\n+                change.nextRemoved(entry.getKey(), oldValue);\n@@ -326,5 +323,1 @@\n-                change.setPut(entry.getKey(), oldValue, newValue);\n-            }\n-\n-            for (var listener : mapChangeListeners) {\n-                listener.onChanged(change);\n+                change.nextReplaced(entry.getKey(), oldValue, newValue);\n@@ -333,0 +326,2 @@\n+\n+        MapListenerHelper.fireValueChangedEvent(helper, change);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/application\/preferences\/PlatformPreferences.java","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"}]}