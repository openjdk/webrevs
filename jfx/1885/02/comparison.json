{"files":[{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.collections;\n+\n+import javafx.collections.MapChangeListener;\n+import javafx.collections.ObservableMap;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Base class for map changes that support bulk change iteration.\n+ *\n+ * @param <K> the key type\n+ * @param <V> the value type\n+ *\/\n+public sealed abstract class IterableMapChange<K, V> extends MapChangeListener.Change<K, V> {\n+\n+    private IterableMapChange(ObservableMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    \/**\n+     * Returns {@code this} object instance if there is another change to report, or {@code null} if there\n+     * are no more changes. If this method returns another change, the implementation must configure this\n+     * object instance to represent the next change.\n+     * <p>\n+     * Note that this narrows down the {@link MapChangeListener.Change#next()} specification, which does\n+     * not mandate that the same object instance is returned on each call.\n+     *\n+     * @return this instance, representing the next change, or {@code null} if there are no more changes\n+     *\/\n+    @Override\n+    public abstract MapChangeListener.Change<K, V> next();\n+\n+    \/**\n+     * Resets this {@code IterableMapChange} instance to the first change.\n+     *\/\n+    public abstract void reset();\n+\n+    @Override\n+    public final String toString() {\n+        StringBuilder builder = new StringBuilder();\n+\n+        if (wasAdded()) {\n+            if (wasRemoved()) {\n+                builder.append(getValueRemoved()).append(\" replaced by \").append(getValueAdded());\n+            } else {\n+                builder.append(getValueAdded()).append(\" added\");\n+            }\n+        } else {\n+            builder.append(getValueRemoved()).append(\" removed\");\n+        }\n+\n+        return builder.append(\" at key \").append(getKey()).toString();\n+    }\n+\n+    public final static class Remove<K, V> extends IterableMapChange<K, V> {\n+\n+        private record Entry<K, V>(K key, V value) {}\n+\n+        private final List<Entry<K, V>> changes;\n+        private int index;\n+\n+        public Remove(ObservableMap<K, V> map) {\n+            super(map);\n+            changes = new ArrayList<>();\n+        }\n+\n+        public Remove(ObservableMap<K, V> map, int initialCapacity) {\n+            super(map);\n+            changes = new ArrayList<>(initialCapacity);\n+        }\n+\n+        @Override\n+        public MapChangeListener.Change<K, V> next() {\n+            if (index < changes.size() - 1) {\n+                ++index;\n+                return this;\n+            }\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public void reset() {\n+            index = 0;\n+        }\n+\n+        @Override\n+        public boolean wasAdded() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean wasRemoved() {\n+            return true;\n+        }\n+\n+        @Override\n+        public K getKey() {\n+            return changes.get(index).key;\n+        }\n+\n+        @Override\n+        public V getValueAdded() {\n+            return null;\n+        }\n+\n+        @Override\n+        public V getValueRemoved() {\n+            return changes.get(index).value;\n+        }\n+\n+        public void nextRemoved(K key, V value) {\n+            changes.add(new Entry<>(key, value));\n+        }\n+    }\n+\n+    public final static class Generic<K, V> extends IterableMapChange<K, V> {\n+\n+        private static final Object NO_VALUE = new Object();\n+\n+        private record Entry<K, V>(K key, V newValue, V oldValue) {\n+            boolean wasAdded() {\n+                return newValue != NO_VALUE;\n+            }\n+\n+            boolean wasRemoved() {\n+                return oldValue != NO_VALUE;\n+            }\n+        }\n+\n+        private final List<Entry<K, V>> changes;\n+        private int index;\n+\n+        public Generic(ObservableMap<K, V> map) {\n+            super(map);\n+            changes = new ArrayList<>();\n+        }\n+\n+        @Override\n+        public MapChangeListener.Change<K, V> next() {\n+            if (index < changes.size() - 1) {\n+                ++index;\n+                return this;\n+            }\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public void reset() {\n+            index = 0;\n+        }\n+\n+        @Override\n+        public boolean wasAdded() {\n+            return changes.get(index).wasAdded();\n+        }\n+\n+        @Override\n+        public boolean wasRemoved() {\n+            return changes.get(index).wasRemoved();\n+        }\n+\n+        @Override\n+        public K getKey() {\n+            return changes.get(index).key;\n+        }\n+\n+        @Override\n+        public V getValueAdded() {\n+            var change = changes.get(index);\n+            return change.wasAdded() ? change.newValue : null;\n+        }\n+\n+        @Override\n+        public V getValueRemoved() {\n+            var change = changes.get(index);\n+            return change.wasRemoved() ? change.oldValue : null;\n+        }\n+\n+        public void nextAdded(K key, V value) {\n+            @SuppressWarnings(\"unchecked\")\n+            var entry = new Entry<>(key, value, (V)NO_VALUE);\n+            changes.add(entry);\n+        }\n+\n+        public void nextRemoved(K key, V value) {\n+            @SuppressWarnings(\"unchecked\")\n+            var entry = new Entry<>(key, (V)NO_VALUE, value);\n+            changes.add(entry);\n+        }\n+\n+        public void nextReplaced(K key, V oldValue, V newValue) {\n+            changes.add(new Entry<>(key, newValue, oldValue));\n+        }\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/IterableMapChange.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.collections;\n+\n+import javafx.collections.ObservableSet;\n+import javafx.collections.SetChangeListener;\n+import java.util.List;\n+\n+\/**\n+ * Base class for set changes that support bulk change iteration.\n+ *\n+ * @param <E> the element type\n+ *\/\n+public sealed abstract class IterableSetChange<E> extends SetChangeListener.Change<E> {\n+\n+    private IterableSetChange(ObservableSet<E> set) {\n+        super(set);\n+    }\n+\n+    \/**\n+     * Returns {@code this} object instance if there is another change to report, or {@code null} if there\n+     * are no more changes. If this method returns another change, the implementation must configure this\n+     * object instance to represent the next change.\n+     * <p>\n+     * Note that this narrows down the {@link SetChangeListener.Change#next()} specification, which does\n+     * not mandate that the same object instance is returned on each call.\n+     *\n+     * @return this instance, representing the next change, or {@code null} if there are no more changes\n+     *\/\n+    @Override\n+    public abstract SetChangeListener.Change<E> next();\n+\n+    \/**\n+     * Resets this {@code IterableSetChange} instance to the first change.\n+     *\/\n+    public abstract void reset();\n+\n+    public static final class Add<E> extends IterableSetChange<E> {\n+\n+        private final List<E> elements;\n+        private int index;\n+\n+        public Add(ObservableSet<E> set, List<E> elements) {\n+            super(set);\n+            this.elements = elements;\n+        }\n+\n+        @Override\n+        public SetChangeListener.Change<E> next() {\n+            if (index < elements.size() - 1) {\n+                ++index;\n+                return this;\n+            }\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public void reset() {\n+            index = 0;\n+        }\n+\n+        @Override\n+        public boolean wasAdded() {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean wasRemoved() {\n+            return false;\n+        }\n+\n+        @Override\n+        public E getElementAdded() {\n+            return elements.get(index);\n+        }\n+\n+        @Override\n+        public E getElementRemoved() {\n+            return null;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"added \" + elements.get(index);\n+        }\n+    }\n+\n+    public static final class Remove<E> extends IterableSetChange<E> {\n+\n+        private final List<E> elements;\n+        private int index;\n+\n+        public Remove(ObservableSet<E> set, List<E> elements) {\n+            super(set);\n+            this.elements = elements;\n+        }\n+\n+        @Override\n+        public SetChangeListener.Change<E> next() {\n+            if (index < elements.size() - 1) {\n+                ++index;\n+                return this;\n+            }\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public void reset() {\n+            index = 0;\n+        }\n+\n+        @Override\n+        public boolean wasAdded() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean wasRemoved() {\n+            return true;\n+        }\n+\n+        @Override\n+        public E getElementAdded() {\n+            return null;\n+        }\n+\n+        @Override\n+        public E getElementRemoved() {\n+            return elements.get(index);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"removed \" + elements.get(index);\n+        }\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/IterableSetChange.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,3 @@\n-public class MapAdapterChange<K, V> extends MapChangeListener.Change<K, V> {\n-    private final Change<? extends K, ? extends V> change;\n+public final class MapAdapterChange<K, V> extends MapChangeListener.Change<K, V> {\n+\n+    private Change<? extends K, ? extends V> change;\n@@ -65,0 +66,11 @@\n+    @Override\n+    public Change<K, V> next() {\n+        Change<? extends K, ? extends V> nextChange = change.next();\n+        if (nextChange != null) {\n+            change = nextChange;\n+            return this;\n+        }\n+\n+        return null;\n+    }\n+\n@@ -69,1 +81,0 @@\n-\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/MapAdapterChange.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,0 +160,8 @@\n+            if (change instanceof IterableMapChange<? extends K, ? extends V> iterableChange) {\n+                fireMapChangeEvent(iterableChange);\n+            } else {\n+                fireMapChangeEvent(change);\n+            }\n+        }\n+\n+        private void fireMapChangeEvent(MapChangeListener.Change<? extends K, ? extends V> change) {\n@@ -166,0 +174,10 @@\n+\n+        private void fireMapChangeEvent(IterableMapChange<? extends K, ? extends V> change) {\n+            do {\n+                try {\n+                    listener.onChanged(change);\n+                } catch (Exception e) {\n+                    Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+                }\n+            } while (change.next() != null);\n+        }\n@@ -323,1 +341,28 @@\n-                for (int i = 0; i < curChangeSize; i++) {\n+\n+                if (change instanceof IterableMapChange<? extends K, ? extends V> iterableChange) {\n+                    fireMapChangeEvent(iterableChange, curChangeList, curChangeSize);\n+                } else {\n+                    fireMapChangeEvent(change, curChangeList, curChangeSize);\n+                }\n+            } finally {\n+                locked = false;\n+            }\n+        }\n+\n+        private static <K, V> void fireMapChangeEvent(MapChangeListener.Change<? extends K, ? extends V> change,\n+                                                      MapChangeListener<? super K, ? super V>[] curChangeList,\n+                                                      int curChangeSize) {\n+            for (int i = 0; i < curChangeSize; i++) {\n+                try {\n+                    curChangeList[i].onChanged(change);\n+                } catch (Exception e) {\n+                    Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+                }\n+            }\n+        }\n+\n+        private static <K, V> void fireMapChangeEvent(IterableMapChange<? extends K, ? extends V> change,\n+                                                      MapChangeListener<? super K, ? super V>[] curChangeList,\n+                                                      int curChangeSize) {\n+            for (int i = 0; i < curChangeSize; i++) {\n+                do {\n@@ -329,3 +374,3 @@\n-                }\n-            } finally {\n-                locked = false;\n+                } while (change.next() != null);\n+\n+                change.reset();\n@@ -335,1 +380,0 @@\n-\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/MapListenerHelper.java","additions":50,"deletions":6,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.ConcurrentModificationException;\n@@ -35,0 +36,1 @@\n+import java.util.Objects;\n@@ -36,0 +38,1 @@\n+import java.util.function.BiFunction;\n@@ -53,61 +56,0 @@\n-    private class SimpleChange extends MapChangeListener.Change<K,V> {\n-\n-        private final K key;\n-        private final V old;\n-        private final V added;\n-        private final boolean wasAdded;\n-        private final boolean wasRemoved;\n-\n-        public SimpleChange(K key, V old, V added, boolean wasAdded, boolean wasRemoved) {\n-            super(ObservableMapWrapper.this);\n-            assert(wasAdded || wasRemoved);\n-            this.key = key;\n-            this.old = old;\n-            this.added = added;\n-            this.wasAdded = wasAdded;\n-            this.wasRemoved = wasRemoved;\n-        }\n-\n-        @Override\n-        public boolean wasAdded() {\n-            return wasAdded;\n-        }\n-\n-        @Override\n-        public boolean wasRemoved() {\n-            return wasRemoved;\n-        }\n-\n-        @Override\n-        public K getKey() {\n-            return key;\n-        }\n-\n-        @Override\n-        public V getValueAdded() {\n-            return added;\n-        }\n-\n-        @Override\n-        public V getValueRemoved() {\n-            return old;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder builder = new StringBuilder();\n-            if (wasAdded) {\n-                if (wasRemoved) {\n-                    builder.append(old).append(\" replaced by \").append(added);\n-                } else {\n-                    builder.append(added).append(\" added\");\n-                }\n-            } else {\n-                builder.append(old).append(\" removed\");\n-            }\n-            builder.append(\" at key \").append(key);\n-            return builder.toString();\n-        }\n-\n-    }\n-\n@@ -191,2 +133,25 @@\n-        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n-            put(e.getKey(), e.getValue());\n+        int size = m.size();\n+\n+        if (size == 1) {\n+            var entry = m.entrySet().iterator().next();\n+            put(entry.getKey(), entry.getValue());\n+        } else if (size > 1) {\n+            var change = new IterableMapChange.Generic<>(this);\n+\n+            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n+                K key = e.getKey();\n+                V newValue = e.getValue();\n+\n+                if (!backingMap.containsKey(key)) {\n+                    change.nextAdded(key, newValue);\n+                } else {\n+                    V oldValue = backingMap.get(key);\n+\n+                    if (!Objects.equals(oldValue, newValue)) {\n+                        change.nextReplaced(key, oldValue, newValue);\n+                    }\n+                }\n+            }\n+\n+            backingMap.putAll(m);\n+            callObservers(change);\n@@ -196,0 +161,48 @@\n+    @Override\n+    public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n+        Objects.requireNonNull(function);\n+        MapChangeListener.Change<K, V> change = null;\n+\n+        for (Map.Entry<K, V> entry : backingMap.entrySet()) {\n+            K key;\n+            V oldValue;\n+\n+            try {\n+                key = entry.getKey();\n+                oldValue = entry.getValue();\n+            } catch (IllegalStateException ex) {\n+                \/\/ This usually means the entry is no longer in the map.\n+                throw new ConcurrentModificationException(ex);\n+            }\n+\n+            \/\/ IllegalStateException thrown from function is not a ConcurrentModificationException.\n+            V newValue = function.apply(key, oldValue);\n+\n+            try {\n+                if (!Objects.equals(oldValue, newValue)) {\n+                    entry.setValue(newValue);\n+\n+                    if (change instanceof SimpleChange) {\n+                        var bulkChange = new IterableMapChange.Generic<>(ObservableMapWrapper.this);\n+                        bulkChange.nextReplaced(change.getKey(), change.getValueRemoved(), change.getValueAdded());\n+                        bulkChange.nextReplaced(key, oldValue, newValue);\n+                        change = bulkChange;\n+                    } else if (change instanceof IterableMapChange.Generic<K, V> bulkChange) {\n+                        bulkChange.nextReplaced(key, oldValue, newValue);\n+                    } else {\n+                        change = new SimpleChange(key, oldValue, newValue, true, true);\n+                    }\n+                }\n+            } catch (IllegalStateException ex) {\n+                \/\/ This usually means the entry is no longer in the map.\n+                throw new ConcurrentModificationException(ex);\n+            }\n+        }\n+\n+        if (change == null) {\n+            return;\n+        }\n+\n+        callObservers(change);\n+    }\n+\n@@ -198,5 +211,8 @@\n-        for (Iterator<Entry<K, V>> i = backingMap.entrySet().iterator(); i.hasNext(); ) {\n-            Entry<K, V> e = i.next();\n-            K key = e.getKey();\n-            V val = e.getValue();\n-            i.remove();\n+        int size = backingMap.size();\n+\n+        if (size == 1) {\n+            Iterator<Entry<K, V>> it = backingMap.entrySet().iterator();\n+            Entry<K, V> entry = it.next();\n+            K key = entry.getKey();\n+            V val = entry.getValue();\n+            it.remove();\n@@ -204,0 +220,9 @@\n+        } else if (size > 1) {\n+            var change = new IterableMapChange.Remove<>(this, size);\n+\n+            for (Map.Entry<? extends K, ? extends V> e : backingMap.entrySet()) {\n+                change.nextRemoved(e.getKey(), e.getValue());\n+            }\n+\n+            backingMap.clear();\n+            callObservers(change);\n@@ -207,0 +232,33 @@\n+    private boolean removeRetain(Collection<?> c, ContainsPredicate<K, V> p, boolean remove) {\n+        MapChangeListener.Change<K, V> change = null;\n+\n+        for (Iterator<Entry<K, V>> it = backingMap.entrySet().iterator(); it.hasNext();) {\n+            Entry<K, V> e = it.next();\n+\n+            if (remove == p.contains(c, e)) {\n+                K key = e.getKey();\n+                V value = e.getValue();\n+\n+                if (change instanceof SimpleChange) {\n+                    var bulkChange = new IterableMapChange.Remove<>(ObservableMapWrapper.this);\n+                    bulkChange.nextRemoved(change.getKey(), change.getValueRemoved());\n+                    bulkChange.nextRemoved(key, value);\n+                    change = bulkChange;\n+                } else if (change instanceof IterableMapChange.Remove<K, V> bulkChange) {\n+                    bulkChange.nextRemoved(key, value);\n+                } else {\n+                    change = new SimpleChange(key, value, null, false, true);\n+                }\n+\n+                it.remove();\n+            }\n+        }\n+\n+        if (change == null) {\n+            return false;\n+        }\n+\n+        callObservers(change);\n+        return true;\n+    }\n+\n@@ -246,1 +304,1 @@\n-    private class ObservableKeySet implements Set<K>{\n+    private class ObservableKeySet implements Set<K>, ContainsPredicate<K, V> {\n@@ -334,16 +392,1 @@\n-            return removeRetain(c, false);\n-        }\n-\n-        private boolean removeRetain(Collection<?> c, boolean remove) {\n-            boolean removed = false;\n-            for (Iterator<Entry<K, V>> i = backingMap.entrySet().iterator(); i.hasNext();) {\n-                Entry<K, V> e = i.next();\n-                if (remove == c.contains(e.getKey())) {\n-                    removed = true;\n-                    K key = e.getKey();\n-                    V value = e.getValue();\n-                    i.remove();\n-                    callObservers(new SimpleChange(key, value, null, false, true));\n-                }\n-            }\n-            return removed;\n+            return removeRetain(c, this, false);\n@@ -359,1 +402,1 @@\n-            return removeRetain(c, true);\n+            return removeRetain(c, this, true);\n@@ -382,0 +425,4 @@\n+        @Override\n+        public boolean contains(Collection<?> c, Entry<K, V> e) {\n+            return c.contains(e.getKey());\n+        }\n@@ -384,1 +431,1 @@\n-    private class ObservableValues implements Collection<V> {\n+    private class ObservableValues implements Collection<V>, ContainsPredicate<K, V> {\n@@ -473,16 +520,1 @@\n-            return removeRetain(c, true);\n-        }\n-\n-        private boolean removeRetain(Collection<?> c, boolean remove) {\n-            boolean removed = false;\n-            for (Iterator<Entry<K, V>> i = backingMap.entrySet().iterator(); i.hasNext();) {\n-                Entry<K, V> e = i.next();\n-                if (remove == c.contains(e.getValue())) {\n-                    removed = true;\n-                    K key = e.getKey();\n-                    V value = e.getValue();\n-                    i.remove();\n-                    callObservers(new SimpleChange(key, value, null, false, true));\n-                }\n-            }\n-            return removed;\n+            return removeRetain(c, this, true);\n@@ -503,1 +535,1 @@\n-            return removeRetain(c, false);\n+            return removeRetain(c, this, false);\n@@ -526,3 +558,4 @@\n-\n-\n-\n+        @Override\n+        public boolean contains(Collection<?> c, Entry<K, V> e) {\n+            return c.contains(e.getValue());\n+        }\n@@ -552,1 +585,5 @@\n-            callObservers(new SimpleChange(getKey(), oldValue, value, true, true));\n+\n+            if (!Objects.equals(oldValue, value)) {\n+                callObservers(new SimpleChange(getKey(), oldValue, value, true, true));\n+            }\n+\n@@ -689,16 +726,1 @@\n-            return removeRetain(c, false);\n-        }\n-\n-        private boolean removeRetain(Collection<?> c, boolean remove) {\n-            boolean removed = false;\n-            for (Iterator<Entry<K, V>> i = backingMap.entrySet().iterator(); i.hasNext();) {\n-                Entry<K, V> e = i.next();\n-                if (remove == c.contains(e)) {\n-                    removed = true;\n-                    K key = e.getKey();\n-                    V value = e.getValue();\n-                    i.remove();\n-                    callObservers(new SimpleChange(key, value, null, false, true));\n-                }\n-            }\n-            return removed;\n+            return removeRetain(c, Collection::contains, false);\n@@ -714,1 +736,1 @@\n-            return removeRetain(c, true);\n+            return removeRetain(c, Collection::contains, true);\n@@ -739,0 +761,68 @@\n+    private static String changeToString(MapChangeListener.Change<?, ?> change) {\n+        StringBuilder builder = new StringBuilder();\n+\n+        if (change.wasAdded()) {\n+            if (change.wasRemoved()) {\n+                builder.append(change.getValueRemoved()).append(\" replaced by \").append(change.getValueAdded());\n+            } else {\n+                builder.append(change.getValueAdded()).append(\" added\");\n+            }\n+        } else {\n+            builder.append(change.getValueRemoved()).append(\" removed\");\n+        }\n+\n+        return builder.append(\" at key \").append(change.getKey()).toString();\n+    }\n+\n+    private class SimpleChange extends MapChangeListener.Change<K,V> {\n+\n+        private final K key;\n+        private final V old;\n+        private final V added;\n+        private final boolean wasAdded;\n+        private final boolean wasRemoved;\n+\n+        public SimpleChange(K key, V old, V added, boolean wasAdded, boolean wasRemoved) {\n+            super(ObservableMapWrapper.this);\n+            assert(wasAdded || wasRemoved);\n+            this.key = key;\n+            this.old = old;\n+            this.added = added;\n+            this.wasAdded = wasAdded;\n+            this.wasRemoved = wasRemoved;\n+        }\n+\n+        @Override\n+        public boolean wasAdded() {\n+            return wasAdded;\n+        }\n+\n+        @Override\n+        public boolean wasRemoved() {\n+            return wasRemoved;\n+        }\n+\n+        @Override\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        @Override\n+        public V getValueAdded() {\n+            return added;\n+        }\n+\n+        @Override\n+        public V getValueRemoved() {\n+            return old;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return changeToString(this);\n+        }\n+    }\n+\n+    private interface ContainsPredicate<K, V> {\n+        boolean contains(Collection<?> c, Entry<K, V> e);\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ObservableMapWrapper.java","additions":216,"deletions":126,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,2 @@\n-\n+import java.util.ArrayList;\n+import java.util.Arrays;\n@@ -34,0 +35,1 @@\n+import java.util.List;\n@@ -88,1 +90,0 @@\n-\n@@ -124,1 +125,0 @@\n-\n@@ -315,2 +315,4 @@\n-    public boolean addAll(Collection<?extends E> c) {\n-        boolean ret = false;\n+    public boolean addAll(Collection<? extends E> c) {\n+        E addedElement = null;\n+        List<E> addedList = null;\n+\n@@ -318,1 +320,12 @@\n-            ret |= add(element);\n+            if (backingSet.add(element)) {\n+                if (addedList != null) {\n+                    addedList.add(element);\n+                } else if (addedElement != null) {\n+                    addedList = new ArrayList<>(c.size());\n+                    addedList.add(addedElement);\n+                    addedList.add(element);\n+                    addedElement = null;\n+                } else {\n+                    addedElement = element;\n+                }\n+            }\n@@ -320,1 +333,12 @@\n-        return ret;\n+\n+        if (addedElement != null) {\n+            callObservers(new SimpleAddChange(addedElement));\n+            return true;\n+        }\n+\n+        if (addedList != null) {\n+            callObservers(new IterableSetChange.Add<>(this, addedList));\n+            return true;\n+        }\n+\n+        return false;\n@@ -366,1 +390,3 @@\n-        boolean removed = false;\n+        E removedElement = null;\n+        List<E> removedList = null;\n+\n@@ -370,1 +396,11 @@\n-                removed = true;\n+                if (removedList != null) {\n+                    removedList.add(element);\n+                } else if (removedElement != null) {\n+                    removedList = new ArrayList<>(c.size());\n+                    removedList.add(removedElement);\n+                    removedList.add(element);\n+                    removedElement = null;\n+                } else {\n+                    removedElement = element;\n+                }\n+\n@@ -372,1 +408,0 @@\n-                callObservers(new SimpleRemoveChange(element));\n@@ -375,1 +410,12 @@\n-        return removed;\n+\n+        if (removedElement != null) {\n+            callObservers(new SimpleRemoveChange(removedElement));\n+            return true;\n+        }\n+\n+        if (removedList != null) {\n+            callObservers(new IterableSetChange.Remove<>(this, removedList));\n+            return true;\n+        }\n+\n+        return false;\n@@ -385,3 +431,6 @@\n-        for (Iterator<E> i = backingSet.iterator(); i.hasNext(); ) {\n-            E element = i.next();\n-            i.remove();\n+        int size = backingSet.size();\n+\n+        if (size == 1) {\n+            Iterator<E> it = backingSet.iterator();\n+            E element = it.next();\n+            it.remove();\n@@ -389,0 +438,6 @@\n+        } else if (size > 1) {\n+            @SuppressWarnings(\"unchecked\")\n+            E[] removed = (E[])new Object[size];\n+            backingSet.toArray(removed);\n+            backingSet.clear();\n+            callObservers(new IterableSetChange.Remove<>(this, Arrays.asList(removed)));\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ObservableSetWrapper.java","additions":70,"deletions":15,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,3 @@\n-public class SetAdapterChange<E> extends SetChangeListener.Change<E> {\n-    private final Change<? extends E> change;\n+public final class SetAdapterChange<E> extends SetChangeListener.Change<E> {\n+\n+    private Change<? extends E> change;\n@@ -65,0 +66,10 @@\n+    @Override\n+    public Change<E> next() {\n+        Change<? extends E> nextChange = change.next();\n+        if (nextChange != null) {\n+            change = nextChange;\n+            return this;\n+        }\n+\n+        return null;\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/SetAdapterChange.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,0 +160,8 @@\n+            if (change instanceof IterableSetChange<? extends E> iterableChange) {\n+                fireSetChangedEvent(iterableChange);\n+            } else {\n+                fireSetChangedEvent(change);\n+            }\n+        }\n+\n+        private void fireSetChangedEvent(SetChangeListener.Change<? extends E> change) {\n@@ -166,0 +174,10 @@\n+\n+        private void fireSetChangedEvent(IterableSetChange<? extends E> change) {\n+            do {\n+                try {\n+                    listener.onChanged(change);\n+                } catch (Exception e) {\n+                    Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+                }\n+            } while (change.next() != null);\n+        }\n@@ -323,1 +341,28 @@\n-                for (int i = 0; i < curChangeSize; i++) {\n+\n+                if (change instanceof IterableSetChange<? extends E> iterableChange) {\n+                    fireSetChangeEvent(iterableChange, curChangeList, curChangeSize);\n+                } else {\n+                    fireSetChangeEvent(change, curChangeList, curChangeSize);\n+                }\n+            } finally {\n+                locked = false;\n+            }\n+        }\n+\n+        private static <E> void fireSetChangeEvent(SetChangeListener.Change<? extends E> change,\n+                                                   SetChangeListener<? super E>[] curChangeList,\n+                                                   int curChangeSize) {\n+            for (int i = 0; i < curChangeSize; i++) {\n+                try {\n+                    curChangeList[i].onChanged(change);\n+                } catch (Exception e) {\n+                    Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+                }\n+            }\n+        }\n+\n+        private static <E> void fireSetChangeEvent(IterableSetChange<? extends E> change,\n+                                                   SetChangeListener<? super E>[] curChangeList,\n+                                                   int curChangeSize) {\n+            for (int i = 0; i < curChangeSize; i++) {\n+                do {\n@@ -329,3 +374,3 @@\n-                }\n-            } finally {\n-                locked = false;\n+                } while (change.next() != null);\n+\n+                change.reset();\n@@ -335,1 +380,0 @@\n-\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/SetListenerHelper.java","additions":50,"deletions":6,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,28 @@\n+        \/**\n+         * Gets the next change in a series of changes.\n+         * <p>\n+         * Repeatedly calling this method allows a listener to fetch all subsequent changes of a bulk\n+         * map modification that would otherwise be reported as repeated invocations of the listener.\n+         * If the listener only fetches some of the pending changes, the rest of the changes will be\n+         * reported with subsequent listener invocations.\n+         * <p>\n+         * After this method has been called, the current {@code Change} instance is no longer valid and\n+         * calling any method on it may result in undefined behavior. Callers must not make any assumptions\n+         * about the identity of the {@code Change} instance returned by this method; even if the returned\n+         * instance is the same as the current instance, it must be treated as a distinct change.\n+         * <p>\n+         * Since this method must not be called before inspecting the first change, listeners will\n+         * usually use a do-while loop to iterate over multiple changes:\n+         * <pre>{@code\n+         *     map.addListener((MapChangeListener<String, String>) change -> {\n+         *         do {\n+         *             \/\/ Inspect the change\n+         *             \/\/ ...\n+         *         } while ((change = change.next()) != null);\n+         *     });\n+         * }<\/pre>\n+         *\n+         * @return the next change, or {@code null} if there are no more changes\n+         * @since 26\n+         *\/\n+        public Change<K, V> next() { return null; }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/collections\/MapChangeListener.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,28 @@\n+        \/**\n+         * Gets the next change in a series of changes.\n+         * <p>\n+         * Repeatedly calling this method allows a listener to fetch all subsequent changes of a bulk\n+         * set modification that would otherwise be reported as repeated invocations of the listener.\n+         * If the listener only fetches some of the pending changes, the rest of the changes will be\n+         * reported with subsequent listener invocations.\n+         * <p>\n+         * After this method has been called, the current {@code Change} instance is no longer valid and\n+         * calling any method on it may result in undefined behavior. Callers must not make any assumptions\n+         * about the identity of the {@code Change} instance returned by this method; even if the returned\n+         * instance is the same as the current instance, it must be treated as a distinct change.\n+         * <p>\n+         * Since this method must not be called before inspecting the first change, listeners will\n+         * usually use a do-while loop to iterate over multiple changes:\n+         * <pre>{@code\n+         *     set.addListener((SetChangeListener<String>) change -> {\n+         *         do {\n+         *             \/\/ Inspect the change\n+         *             \/\/ ...\n+         *         } while ((change = change.next()) != null);\n+         *     });\n+         * }<\/pre>\n+         *\n+         * @return the next change, or {@code null} if there are no more changes\n+         * @since 26\n+         *\/\n+        public Change<E> next() { return null; }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/collections\/SetChangeListener.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javafx.collections.MapChangeListener;\n@@ -32,0 +33,1 @@\n+import java.util.ArrayList;\n@@ -35,0 +37,2 @@\n+import java.util.LinkedHashMap;\n+import java.util.List;\n@@ -42,0 +46,76 @@\n+    @Test\n+    public void partialChangeIterationCausesSubsequentListenerInvocation() {\n+        var trace = new ArrayList<String>();\n+        var invocations = new int[1];\n+        var map = new ObservableMapWrapper<String, String>(new HashMap<>());\n+\n+        \/\/ This listener only processes 2 changes in each invocation.\n+        map.addListener((MapChangeListener<String, String>) change -> {\n+            invocations[0]++;\n+            trace.add(change.toString());\n+\n+            change = change.next();\n+            trace.add(change.toString());\n+        });\n+\n+        map.putAll(new LinkedHashMap<>() {{\n+            put(\"k1\", \"a\");\n+            put(\"k2\", \"b\");\n+            put(\"k3\", \"c\");\n+            put(\"k4\", \"d\");\n+            put(\"k5\", \"e\");\n+            put(\"k6\", \"f\");\n+        }});\n+\n+        assertEquals(3, invocations[0]);\n+        assertEquals(\n+            List.of(\n+                \"a added at key k1\",\n+                \"b added at key k2\",\n+                \"c added at key k3\",\n+                \"d added at key k4\",\n+                \"e added at key k5\",\n+                \"f added at key k6\"),\n+            trace);\n+    }\n+\n+    @Nested\n+    class ClearTest {\n+        @Test\n+        public void singleEntry() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\"));\n+            map.clear();\n+            map.assertTraceEquals(\"a removed at key k1\");\n+        }\n+\n+        @Test\n+        public void multipleEntries() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+            map.clear();\n+            map.assertTraceEquals(\n+                \"a removed at key k1\",\n+                \"b removed at key k2\",\n+                \"c removed at key k3\");\n+        }\n+    }\n+\n+    @Nested\n+    class PutAllTest {\n+        @Test\n+        public void singleEntry() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+            map.putAll(Map.of(\"k1\", \"d\"));\n+            map.assertTraceEquals(\"a replaced by d at key k1\");\n+        }\n+\n+        @Test\n+        public void multipleEntries() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+            map.putAll(Map.of(\"k1\", \"d\", \"k2\", \"e\", \"k4\", \"f\"));\n+            map.assertTraceEquals(\n+                \"a replaced by d at key k1\",\n+                \"b replaced by e at key k2\",\n+                \"f added at key k4\");\n+        }\n+    }\n+\n@@ -44,0 +124,17 @@\n+        @Test\n+        public void singleEntry() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+            map.keySet().removeAll(List.of(\"k1\"));\n+            map.assertTraceEquals(\"a removed at key k1\");\n+        }\n+\n+        @Test\n+        public void multipleEntries() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+            map.keySet().removeAll(List.of(\"k1\", \"k2\", \"k3\"));\n+            map.assertTraceEquals(\n+                \"a removed at key k1\",\n+                \"b removed at key k2\",\n+                \"c removed at key k3\");\n+        }\n+\n@@ -100,0 +197,14 @@\n+        @Test\n+        public void singleEntry() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+            map.keySet().retainAll(List.of(\"k1\"));\n+            map.assertTraceEquals(\"b removed at key k2\", \"c removed at key k3\");\n+        }\n+\n+        @Test\n+        public void multipleEntries() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+            map.keySet().retainAll(List.of(\"k1\", \"k3\"));\n+            map.assertTraceEquals(\"b removed at key k2\");\n+        }\n+\n@@ -154,0 +265,57 @@\n+    @Nested\n+    class ReplaceAllTest {\n+        @Test\n+        public void singleEntry() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+\n+            map.replaceAll((key, value) -> switch (key) {\n+                case \"k2\" -> \"e\";\n+                default -> value;\n+            });\n+\n+            map.assertTraceEquals(\"b replaced by e at key k2\");\n+        }\n+\n+        @Test\n+        public void multipleEntries() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+\n+            map.replaceAll((key, value) -> switch (key) {\n+                case \"k1\" -> \"d\";\n+                case \"k2\" -> \"e\";\n+                case \"k3\" -> \"f\";\n+                default -> value;\n+            });\n+\n+            map.assertTraceEquals(\n+                \"a replaced by d at key k1\",\n+                \"b replaced by e at key k2\",\n+                \"c replaced by f at key k3\");\n+        }\n+    }\n+\n+    private static class TestObservableMapWrapper extends ObservableMapWrapper<String, String> {\n+        final Set<String> bulkChangeTrace = new HashSet<>();\n+        final Set<String> singleChangeTrace = new HashSet<>();\n+\n+        public TestObservableMapWrapper(Map<String, String> map) {\n+            super(new HashMap<>(map));\n+\n+            addListener((MapChangeListener<? super String, ? super String>) change -> {\n+                do {\n+                    bulkChangeTrace.add(change.toString());\n+                } while ((change = change.next()) != null);\n+            });\n+\n+            addListener((MapChangeListener<? super String, ? super String>) change -> {\n+                singleChangeTrace.add(change.toString());\n+            });\n+        }\n+\n+        void assertTraceEquals(String... expected) {\n+            var expectedSet = Set.of(expected);\n+            assertEquals(expectedSet, bulkChangeTrace);\n+            assertEquals(expectedSet, singleChangeTrace);\n+        }\n+    }\n+\n@@ -188,1 +356,0 @@\n-\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/collections\/ObservableMapWrapperTest.java","additions":169,"deletions":2,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javafx.collections.SetChangeListener;\n@@ -31,0 +32,1 @@\n+import java.util.ArrayList;\n@@ -33,0 +35,1 @@\n+import java.util.List;\n@@ -39,0 +42,44 @@\n+    @Test\n+    public void partialChangeIterationCausesSubsequentListenerInvocation() {\n+        var trace = new ArrayList<String>();\n+        var invocations = new int[1];\n+        var set = new ObservableSetWrapper<String>(new HashSet<>());\n+\n+        \/\/ This listener only processes 2 changes in each invocation.\n+        set.addListener((SetChangeListener<String>) change -> {\n+            invocations[0]++;\n+            trace.add(change.toString());\n+\n+            change = change.next();\n+            trace.add(change.toString());\n+        });\n+\n+        set.addAll(List.of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"));\n+        assertEquals(3, invocations[0]);\n+        assertEquals(List.of(\"added a\", \"added b\", \"added c\", \"added d\", \"added e\", \"added f\"), trace);\n+    }\n+\n+    @Nested\n+    class AddAllTest {\n+        @Test\n+        public void duplicateElement() {\n+            var set = new TestObservableSetWrapper(Set.of(\"a\", \"b\", \"c\"));\n+            set.addAll(Set.of(\"b\"));\n+            set.assertTraceEquals();\n+        }\n+\n+        @Test\n+        public void singleElement() {\n+            var set = new TestObservableSetWrapper(Set.of(\"a\", \"b\", \"c\"));\n+            set.addAll(Set.of(\"d\"));\n+            set.assertTraceEquals(\"added d\");\n+        }\n+\n+        @Test\n+        public void multipleElements() {\n+            var set = new TestObservableSetWrapper(Set.of(\"a\", \"b\", \"c\"));\n+            set.addAll(Set.of(\"b\", \"c\", \"d\", \"e\"));\n+            set.assertTraceEquals(\"added d\", \"added e\");\n+        }\n+    }\n+\n@@ -41,0 +88,14 @@\n+        @Test\n+        public void singleElement() {\n+            var set = new TestObservableSetWrapper(Set.of(\"a\", \"b\", \"c\"));\n+            set.removeAll(Set.of(\"b\"));\n+            set.assertTraceEquals(\"removed b\");\n+        }\n+\n+        @Test\n+        public void multipleElements() {\n+            var set = new TestObservableSetWrapper(Set.of(\"a\", \"b\", \"c\"));\n+            set.removeAll(Set.of(\"a\", \"b\", \"c\"));\n+            set.assertTraceEquals(\"removed a\", \"removed b\", \"removed c\");\n+        }\n+\n@@ -69,0 +130,14 @@\n+        @Test\n+        public void singleElement() {\n+            var set = new TestObservableSetWrapper(Set.of(\"a\", \"b\", \"c\"));\n+            set.retainAll(Set.of(\"b\"));\n+            set.assertTraceEquals(\"removed a\", \"removed c\");\n+        }\n+\n+        @Test\n+        public void multipleElements() {\n+            var set = new TestObservableSetWrapper(Set.of(\"a\", \"b\", \"c\"));\n+            set.retainAll(Set.of(\"a\", \"c\"));\n+            set.assertTraceEquals(\"removed b\");\n+        }\n+\n@@ -94,0 +169,24 @@\n+    private static class TestObservableSetWrapper extends ObservableSetWrapper<String> {\n+        final Set<String> bulkChangeTrace = new HashSet<>();\n+        final Set<String> singleChangeTrace = new HashSet<>();\n+\n+        public TestObservableSetWrapper(Set<String> set) {\n+            super(new HashSet<>(set));\n+\n+            addListener((SetChangeListener<String>) change -> {\n+                do {\n+                    bulkChangeTrace.add(change.toString());\n+                } while ((change = change.next()) != null);\n+            });\n+\n+            addListener((SetChangeListener<String>) change -> {\n+                singleChangeTrace.add(change.toString());\n+            });\n+        }\n+\n+        void assertTraceEquals(String... expected) {\n+            var expectedSet = Set.of(expected);\n+            assertEquals(expectedSet, bulkChangeTrace);\n+            assertEquals(expectedSet, singleChangeTrace);\n+        }\n+    }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/collections\/ObservableSetWrapperTest.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import org.junit.jupiter.api.Test;\n-\n@@ -185,0 +183,15 @@\n+    @ParameterizedTest\n+    @MethodSource(\"createParameters\")\n+    @SuppressWarnings(\"unchecked\")\n+    public void testReplaceAll(Callable<ObservableMap<String, String>> mapFactory) throws Exception {\n+        setUp(mapFactory);\n+\n+        observableMap.replaceAll((key, value) -> switch (key) {\n+            case \"one\" -> \"2\";\n+            case \"two\" -> \"3\";\n+            default -> value;\n+        });\n+\n+        observer.assertMultipleCalls(call(\"one\", \"1\", \"2\"), call(\"two\", \"2\", \"3\"));\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/collections\/ObservableMapTest.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import com.sun.javafx.binding.MapExpressionHelper;\n+import com.sun.javafx.collections.IterableMapChange;\n+import com.sun.javafx.collections.MapListenerHelper;\n@@ -41,1 +42,0 @@\n-import java.util.List;\n@@ -46,1 +46,0 @@\n-import java.util.concurrent.CopyOnWriteArrayList;\n@@ -79,2 +78,1 @@\n-    private final List<InvalidationListener> invalidationListeners = new CopyOnWriteArrayList<>();\n-    private final List<MapChangeListener<? super String, Object>> mapChangeListeners = new CopyOnWriteArrayList<>();\n+    private MapListenerHelper<String, Object> helper;\n@@ -108,1 +106,1 @@\n-        invalidationListeners.add(listener);\n+        helper = MapListenerHelper.addListener(helper, listener);\n@@ -113,1 +111,1 @@\n-        invalidationListeners.remove(listener);\n+        helper = MapListenerHelper.removeListener(helper, listener);\n@@ -118,1 +116,1 @@\n-        mapChangeListeners.add(listener);\n+        helper = MapListenerHelper.addListener(helper, listener);\n@@ -123,1 +121,1 @@\n-        mapChangeListeners.remove(listener);\n+        helper = MapListenerHelper.removeListener(helper, listener);\n@@ -314,2 +312,1 @@\n-        invalidationListeners.forEach(listener -> listener.invalidated(this));\n-        var change = new MapExpressionHelper.SimpleChange<>(this);\n+        var change = new IterableMapChange.Generic<>(this);\n@@ -322,1 +319,1 @@\n-                change.setAdded(entry.getKey(), newValue);\n+                change.nextAdded(entry.getKey(), newValue);\n@@ -324,1 +321,1 @@\n-                change.setRemoved(entry.getKey(), oldValue);\n+                change.nextRemoved(entry.getKey(), oldValue);\n@@ -326,5 +323,1 @@\n-                change.setPut(entry.getKey(), oldValue, newValue);\n-            }\n-\n-            for (var listener : mapChangeListeners) {\n-                listener.onChanged(change);\n+                change.nextReplaced(entry.getKey(), oldValue, newValue);\n@@ -333,0 +326,2 @@\n+\n+        MapListenerHelper.fireValueChangedEvent(helper, change);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/application\/preferences\/PlatformPreferences.java","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"}]}