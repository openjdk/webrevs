{"files":[{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.collections;\n+\n+import javafx.collections.MapChangeListener;\n+import javafx.collections.ObservableMap;\n+\n+abstract class IterableMapChange<K, V> extends MapChangeListener.Change<K, V> {\n+\n+    public IterableMapChange(ObservableMap<K, V> map) {\n+        super(map);\n+    }\n+\n+    public abstract boolean nextChange();\n+\n+    public abstract void reset();\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/IterableMapChange.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.collections;\n+\n+import javafx.collections.ObservableSet;\n+import javafx.collections.SetChangeListener;\n+\n+abstract class IterableSetChange<E> extends SetChangeListener.Change<E> {\n+\n+    public IterableSetChange(ObservableSet<E> set) {\n+        super(set);\n+    }\n+\n+    public abstract boolean nextChange();\n+\n+    public abstract void reset();\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/IterableSetChange.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,3 @@\n-public class MapAdapterChange<K, V> extends MapChangeListener.Change<K, V> {\n-    private final Change<? extends K, ? extends V> change;\n+public final class MapAdapterChange<K, V> extends MapChangeListener.Change<K, V> {\n+\n+    private Change<? extends K, ? extends V> change;\n@@ -65,0 +66,11 @@\n+    @Override\n+    public Change<K, V> next() {\n+        Change<? extends K, ? extends V> nextChange = change.next();\n+        if (nextChange != null) {\n+            change = nextChange;\n+            return this;\n+        }\n+\n+        return null;\n+    }\n+\n@@ -69,1 +81,0 @@\n-\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/MapAdapterChange.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,5 +160,7 @@\n-            try {\n-                listener.onChanged(change);\n-            } catch (Exception e) {\n-                Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n-            }\n+            do {\n+                try {\n+                    listener.onChanged(change);\n+                } catch (Exception e) {\n+                    Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+                }\n+            } while (change instanceof IterableMapChange<? extends K, ? extends V> c && c.nextChange());\n@@ -323,1 +325,28 @@\n-                for (int i = 0; i < curChangeSize; i++) {\n+\n+                if (change instanceof IterableMapChange<? extends K, ? extends V> iterableChange) {\n+                    fireMapChangeEvent(iterableChange, curChangeList, curChangeSize);\n+                } else {\n+                    fireMapChangeEvent(change, curChangeList, curChangeSize);\n+                }\n+            } finally {\n+                locked = false;\n+            }\n+        }\n+\n+        private static <K, V> void fireMapChangeEvent(MapChangeListener.Change<? extends K, ? extends V> change,\n+                                                      MapChangeListener<? super K, ? super V>[] curChangeList,\n+                                                      int curChangeSize) {\n+            for (int i = 0; i < curChangeSize; i++) {\n+                try {\n+                    curChangeList[i].onChanged(change);\n+                } catch (Exception e) {\n+                    Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+                }\n+            }\n+        }\n+\n+        private static <K, V> void fireMapChangeEvent(IterableMapChange<? extends K, ? extends V> change,\n+                                                      MapChangeListener<? super K, ? super V>[] curChangeList,\n+                                                      int curChangeSize) {\n+            for (int i = 0; i < curChangeSize; i++) {\n+                do {\n@@ -329,3 +358,3 @@\n-                }\n-            } finally {\n-                locked = false;\n+                } while (change.nextChange());\n+\n+                change.reset();\n@@ -335,1 +364,0 @@\n-\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/MapListenerHelper.java","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.ConcurrentModificationException;\n@@ -35,0 +36,1 @@\n+import java.util.Objects;\n@@ -36,0 +38,1 @@\n+import java.util.function.BiFunction;\n@@ -53,61 +56,0 @@\n-    private class SimpleChange extends MapChangeListener.Change<K,V> {\n-\n-        private final K key;\n-        private final V old;\n-        private final V added;\n-        private final boolean wasAdded;\n-        private final boolean wasRemoved;\n-\n-        public SimpleChange(K key, V old, V added, boolean wasAdded, boolean wasRemoved) {\n-            super(ObservableMapWrapper.this);\n-            assert(wasAdded || wasRemoved);\n-            this.key = key;\n-            this.old = old;\n-            this.added = added;\n-            this.wasAdded = wasAdded;\n-            this.wasRemoved = wasRemoved;\n-        }\n-\n-        @Override\n-        public boolean wasAdded() {\n-            return wasAdded;\n-        }\n-\n-        @Override\n-        public boolean wasRemoved() {\n-            return wasRemoved;\n-        }\n-\n-        @Override\n-        public K getKey() {\n-            return key;\n-        }\n-\n-        @Override\n-        public V getValueAdded() {\n-            return added;\n-        }\n-\n-        @Override\n-        public V getValueRemoved() {\n-            return old;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            StringBuilder builder = new StringBuilder();\n-            if (wasAdded) {\n-                if (wasRemoved) {\n-                    builder.append(old).append(\" replaced by \").append(added);\n-                } else {\n-                    builder.append(added).append(\" added\");\n-                }\n-            } else {\n-                builder.append(old).append(\" removed\");\n-            }\n-            builder.append(\" at key \").append(key);\n-            return builder.toString();\n-        }\n-\n-    }\n-\n@@ -191,2 +133,26 @@\n-        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n-            put(e.getKey(), e.getValue());\n+        int size = m.size();\n+\n+        if (size == 1) {\n+            var entry = m.entrySet().iterator().next();\n+            put(entry.getKey(), entry.getValue());\n+        } else if (size > 1) {\n+            var change = new BulkChange.AddReplace<>(this, size);\n+\n+            for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n+                K key = e.getKey();\n+                V newValue = e.getValue();\n+\n+                if (!backingMap.containsKey(key)) {\n+                    change.nextAdded(key, newValue);\n+                } else {\n+                    V oldValue = backingMap.get(key);\n+\n+                    if (!Objects.equals(oldValue, newValue)) {\n+                        change.nextReplaced(key, oldValue, newValue);\n+                    }\n+                }\n+            }\n+\n+            change.complete();\n+            backingMap.putAll(m);\n+            callObservers(change);\n@@ -196,0 +162,56 @@\n+    @Override\n+    public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n+        Objects.requireNonNull(function);\n+        MapChangeListener.Change<K, V> change = null;\n+        int i = 0;\n+\n+        for (Map.Entry<K, V> entry : backingMap.entrySet()) {\n+            K key;\n+            V oldValue;\n+\n+            try {\n+                key = entry.getKey();\n+                oldValue = entry.getValue();\n+            } catch (IllegalStateException ex) {\n+                \/\/ This usually means the entry is no longer in the map.\n+                throw new ConcurrentModificationException(ex);\n+            }\n+\n+            \/\/ IllegalStateException thrown from function is not a ConcurrentModificationException.\n+            V newValue = function.apply(key, oldValue);\n+\n+            try {\n+                if (!Objects.equals(oldValue, newValue)) {\n+                    entry.setValue(newValue);\n+\n+                    if (change instanceof SimpleChange) {\n+                        int capacity = backingMap.size() - i + 1;\n+                        var bulkChange = new BulkChange.AddReplace<>(ObservableMapWrapper.this, capacity);\n+                        bulkChange.nextReplaced(change.getKey(), change.getValueRemoved(), change.getValueAdded());\n+                        bulkChange.nextReplaced(key, oldValue, newValue);\n+                        change = bulkChange;\n+                    } else if (change instanceof BulkChange.AddReplace<K, V> bulkChange) {\n+                        bulkChange.nextReplaced(key, oldValue, newValue);\n+                    } else {\n+                        change = new SimpleChange(key, oldValue, newValue, true, true);\n+                    }\n+                }\n+            } catch (IllegalStateException ex) {\n+                \/\/ This usually means the entry is no longer in the map.\n+                throw new ConcurrentModificationException(ex);\n+            }\n+\n+            ++i;\n+        }\n+\n+        if (change == null) {\n+            return;\n+        }\n+\n+        if (change instanceof BulkChange<K, V> bulkChange) {\n+            bulkChange.complete();\n+        }\n+\n+        callObservers(change);\n+    }\n+\n@@ -198,5 +220,8 @@\n-        for (Iterator<Entry<K, V>> i = backingMap.entrySet().iterator(); i.hasNext(); ) {\n-            Entry<K, V> e = i.next();\n-            K key = e.getKey();\n-            V val = e.getValue();\n-            i.remove();\n+        int size = backingMap.size();\n+\n+        if (size == 1) {\n+            Iterator<Entry<K, V>> it = backingMap.entrySet().iterator();\n+            Entry<K, V> entry = it.next();\n+            K key = entry.getKey();\n+            V val = entry.getValue();\n+            it.remove();\n@@ -204,0 +229,10 @@\n+        } else if (size > 1) {\n+            var change = new BulkChange.Remove<>(this, size);\n+\n+            for (Map.Entry<? extends K, ? extends V> e : backingMap.entrySet()) {\n+                change.nextRemoved(e.getKey(), e.getValue());\n+            }\n+\n+            change.complete();\n+            backingMap.clear();\n+            callObservers(change);\n@@ -207,0 +242,41 @@\n+    private boolean removeRetain(Collection<?> c, ContainsPredicate<K, V> p, boolean remove) {\n+        MapChangeListener.Change<K, V> change = null;\n+\n+        for (Iterator<Entry<K, V>> it = backingMap.entrySet().iterator(); it.hasNext();) {\n+            Entry<K, V> e = it.next();\n+\n+            if (remove == p.contains(c, e)) {\n+                K key = e.getKey();\n+                V value = e.getValue();\n+\n+                if (change instanceof SimpleChange) {\n+                    int capacity = remove\n+                        ? Math.min(backingMap.size() + 1, c.size())\n+                        : backingMap.size() + 1;\n+\n+                    var bulkChange = new BulkChange.Remove<>(ObservableMapWrapper.this, capacity);\n+                    bulkChange.nextRemoved(change.getKey(), change.getValueRemoved());\n+                    bulkChange.nextRemoved(key, value);\n+                    change = bulkChange;\n+                } else if (change instanceof BulkChange.Remove<K, V> bulkChange) {\n+                    bulkChange.nextRemoved(key, value);\n+                } else {\n+                    change = new SimpleChange(key, value, null, false, true);\n+                }\n+\n+                it.remove();\n+            }\n+        }\n+\n+        if (change == null) {\n+            return false;\n+        }\n+\n+        if (change instanceof BulkChange<K, V> bulkChange) {\n+            bulkChange.complete();\n+        }\n+\n+        callObservers(change);\n+        return true;\n+    }\n+\n@@ -246,1 +322,1 @@\n-    private class ObservableKeySet implements Set<K>{\n+    private class ObservableKeySet implements Set<K>, ContainsPredicate<K, V> {\n@@ -334,16 +410,1 @@\n-            return removeRetain(c, false);\n-        }\n-\n-        private boolean removeRetain(Collection<?> c, boolean remove) {\n-            boolean removed = false;\n-            for (Iterator<Entry<K, V>> i = backingMap.entrySet().iterator(); i.hasNext();) {\n-                Entry<K, V> e = i.next();\n-                if (remove == c.contains(e.getKey())) {\n-                    removed = true;\n-                    K key = e.getKey();\n-                    V value = e.getValue();\n-                    i.remove();\n-                    callObservers(new SimpleChange(key, value, null, false, true));\n-                }\n-            }\n-            return removed;\n+            return removeRetain(c, this, false);\n@@ -359,1 +420,1 @@\n-            return removeRetain(c, true);\n+            return removeRetain(c, this, true);\n@@ -382,0 +443,4 @@\n+        @Override\n+        public boolean contains(Collection<?> c, Entry<K, V> e) {\n+            return c.contains(e.getKey());\n+        }\n@@ -384,1 +449,1 @@\n-    private class ObservableValues implements Collection<V> {\n+    private class ObservableValues implements Collection<V>, ContainsPredicate<K, V> {\n@@ -473,16 +538,1 @@\n-            return removeRetain(c, true);\n-        }\n-\n-        private boolean removeRetain(Collection<?> c, boolean remove) {\n-            boolean removed = false;\n-            for (Iterator<Entry<K, V>> i = backingMap.entrySet().iterator(); i.hasNext();) {\n-                Entry<K, V> e = i.next();\n-                if (remove == c.contains(e.getValue())) {\n-                    removed = true;\n-                    K key = e.getKey();\n-                    V value = e.getValue();\n-                    i.remove();\n-                    callObservers(new SimpleChange(key, value, null, false, true));\n-                }\n-            }\n-            return removed;\n+            return removeRetain(c, this, true);\n@@ -503,1 +553,1 @@\n-            return removeRetain(c, false);\n+            return removeRetain(c, this, false);\n@@ -526,3 +576,4 @@\n-\n-\n-\n+        @Override\n+        public boolean contains(Collection<?> c, Entry<K, V> e) {\n+            return c.contains(e.getValue());\n+        }\n@@ -552,1 +603,5 @@\n-            callObservers(new SimpleChange(getKey(), oldValue, value, true, true));\n+\n+            if (!Objects.equals(oldValue, value)) {\n+                callObservers(new SimpleChange(getKey(), oldValue, value, true, true));\n+            }\n+\n@@ -689,16 +744,1 @@\n-            return removeRetain(c, false);\n-        }\n-\n-        private boolean removeRetain(Collection<?> c, boolean remove) {\n-            boolean removed = false;\n-            for (Iterator<Entry<K, V>> i = backingMap.entrySet().iterator(); i.hasNext();) {\n-                Entry<K, V> e = i.next();\n-                if (remove == c.contains(e)) {\n-                    removed = true;\n-                    K key = e.getKey();\n-                    V value = e.getValue();\n-                    i.remove();\n-                    callObservers(new SimpleChange(key, value, null, false, true));\n-                }\n-            }\n-            return removed;\n+            return removeRetain(c, Collection::contains, false);\n@@ -714,1 +754,1 @@\n-            return removeRetain(c, true);\n+            return removeRetain(c, Collection::contains, true);\n@@ -739,0 +779,216 @@\n+    private static String changeToString(MapChangeListener.Change<?, ?> change) {\n+        StringBuilder builder = new StringBuilder();\n+\n+        if (change.wasAdded()) {\n+            if (change.wasRemoved()) {\n+                builder.append(change.getValueRemoved()).append(\" replaced by \").append(change.getValueAdded());\n+            } else {\n+                builder.append(change.getValueAdded()).append(\" added\");\n+            }\n+        } else {\n+            builder.append(change.getValueRemoved()).append(\" removed\");\n+        }\n+\n+        return builder.append(\" at key \").append(change.getKey()).toString();\n+    }\n+\n+    private class SimpleChange extends MapChangeListener.Change<K,V> {\n+\n+        private final K key;\n+        private final V old;\n+        private final V added;\n+        private final boolean wasAdded;\n+        private final boolean wasRemoved;\n+\n+        public SimpleChange(K key, V old, V added, boolean wasAdded, boolean wasRemoved) {\n+            super(ObservableMapWrapper.this);\n+            assert(wasAdded || wasRemoved);\n+            this.key = key;\n+            this.old = old;\n+            this.added = added;\n+            this.wasAdded = wasAdded;\n+            this.wasRemoved = wasRemoved;\n+        }\n+\n+        @Override\n+        public boolean wasAdded() {\n+            return wasAdded;\n+        }\n+\n+        @Override\n+        public boolean wasRemoved() {\n+            return wasRemoved;\n+        }\n+\n+        @Override\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        @Override\n+        public V getValueAdded() {\n+            return added;\n+        }\n+\n+        @Override\n+        public V getValueRemoved() {\n+            return old;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return changeToString(this);\n+        }\n+    }\n+\n+    private static abstract sealed class BulkChange<K, V> extends IterableMapChange<K, V> {\n+\n+        final int capacity;\n+        final K[] keys;\n+        int size;\n+        int index;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        BulkChange(ObservableMapWrapper<K, V> map, int capacity) {\n+            super(map);\n+            this.capacity = capacity;\n+            this.keys = (K[])new Object[capacity];\n+        }\n+\n+        final void complete() {\n+            size = index;\n+            index = 0;\n+        }\n+\n+        @Override\n+        public final boolean nextChange() {\n+            if (index < size - 1) {\n+                ++index;\n+                return true;\n+            }\n+\n+            return false;\n+        }\n+\n+        @Override\n+        public final MapChangeListener.Change<K, V> next() {\n+            if (index < size - 1) {\n+                ++index;\n+                return this;\n+            }\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public final void reset() {\n+            index = 0;\n+        }\n+\n+        @Override\n+        public final String toString() {\n+            return changeToString(this);\n+        }\n+\n+        final static class Remove<K, V> extends BulkChange<K, V> {\n+\n+            private final V[] values;\n+\n+            @SuppressWarnings(\"unchecked\")\n+            Remove(ObservableMapWrapper<K, V> map, int capacity) {\n+                super(map, capacity);\n+                this.values = (V[])new Object[capacity];\n+            }\n+\n+            void nextRemoved(K key, V value) {\n+                keys[index] = key;\n+                values[index] = value;\n+                ++index;\n+            }\n+\n+            @Override\n+            public boolean wasAdded() {\n+                return false;\n+            }\n+\n+            @Override\n+            public boolean wasRemoved() {\n+                return true;\n+            }\n+\n+            @Override\n+            public K getKey() {\n+                return keys[index];\n+            }\n+\n+            @Override\n+            public V getValueAdded() {\n+                return values[index];\n+            }\n+\n+            @Override\n+            public V getValueRemoved() {\n+                return values[index];\n+            }\n+        }\n+\n+        final static class AddReplace<K, V> extends BulkChange<K, V> {\n+\n+            private static final int ADDED = 1;\n+            private static final int REMOVED = 2;\n+\n+            private final V[] values;\n+            private final int[] addedRemoved;\n+\n+            @SuppressWarnings(\"unchecked\")\n+            AddReplace(ObservableMapWrapper<K, V> map, int capacity) {\n+                super(map, capacity);\n+                this.values = (V[])new Object[capacity * 2];\n+                this.addedRemoved = new int[capacity];\n+            }\n+\n+            void nextAdded(K key, V value) {\n+                keys[index] = key;\n+                values[index * 2 + 1] = value;\n+                addedRemoved[index] = ADDED;\n+                ++index;\n+            }\n+\n+            void nextReplaced(K key, V oldValue, V newValue) {\n+                keys[index] = key;\n+                values[index * 2] = oldValue;\n+                values[index * 2 + 1] = newValue;\n+                addedRemoved[index] = ADDED | REMOVED;\n+                ++index;\n+            }\n+\n+            @Override\n+            public boolean wasAdded() {\n+                return (addedRemoved[index] & ADDED) != 0;\n+            }\n+\n+            @Override\n+            public boolean wasRemoved() {\n+                return (addedRemoved[index] & REMOVED) != 0;\n+            }\n+\n+            @Override\n+            public K getKey() {\n+                return keys[index];\n+            }\n+\n+            @Override\n+            public V getValueAdded() {\n+                return values[index * 2 + 1];\n+            }\n+\n+            @Override\n+            public V getValueRemoved() {\n+                return values[index * 2];\n+            }\n+        }\n+    }\n+\n+    private interface ContainsPredicate<K, V> {\n+        boolean contains(Collection<?> c, Entry<K, V> e);\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ObservableMapWrapper.java","additions":382,"deletions":126,"binary":false,"changes":508,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,2 @@\n-\n+import java.util.ArrayList;\n+import java.util.Arrays;\n@@ -34,0 +35,1 @@\n+import java.util.List;\n@@ -88,1 +90,0 @@\n-\n@@ -124,0 +125,54 @@\n+    }\n+\n+    private abstract static sealed class AbstractIterableSetChange<E> extends IterableSetChange<E>\n+            permits IterableAddChange, IterableRemoveChange {\n+\n+        final List<E> elements;\n+        int index;\n+\n+        public AbstractIterableSetChange(ObservableSet<E> set, List<E> elements) {\n+            super(set);\n+            this.elements = elements;\n+        }\n+\n+        @Override\n+        public final boolean nextChange() {\n+            if (index < elements.size() - 1) {\n+                ++index;\n+                return true;\n+            }\n+\n+            return false;\n+        }\n+\n+        @Override\n+        public final SetChangeListener.Change<E> next() {\n+            if (index < elements.size() - 1) {\n+                ++index;\n+                return this;\n+            }\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public final void reset() {\n+            index = 0;\n+        }\n+    }\n+\n+    private static final class IterableAddChange<E> extends AbstractIterableSetChange<E> {\n+\n+        IterableAddChange(ObservableSet<E> set, List<E> elements) {\n+            super(set, elements);\n+        }\n+\n+        @Override\n+        public boolean wasAdded() {\n+            return true;\n+        }\n+\n+        @Override\n+        public boolean wasRemoved() {\n+            return false;\n+        }\n@@ -125,0 +180,46 @@\n+        @Override\n+        public E getElementAdded() {\n+            return elements.get(index);\n+        }\n+\n+        @Override\n+        public E getElementRemoved() {\n+            return null;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"added \" + elements.get(index);\n+        }\n+    }\n+\n+    private static final class IterableRemoveChange<E> extends AbstractIterableSetChange<E> {\n+\n+        IterableRemoveChange(ObservableSet<E> set, List<E> elements) {\n+            super(set, elements);\n+        }\n+\n+        @Override\n+        public boolean wasAdded() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean wasRemoved() {\n+            return true;\n+        }\n+\n+        @Override\n+        public E getElementAdded() {\n+            return null;\n+        }\n+\n+        @Override\n+        public E getElementRemoved() {\n+            return elements.get(index);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"removed \" + elements.get(index);\n+        }\n@@ -315,2 +416,4 @@\n-    public boolean addAll(Collection<?extends E> c) {\n-        boolean ret = false;\n+    public boolean addAll(Collection<? extends E> c) {\n+        E addedElement = null;\n+        List<E> addedList = null;\n+\n@@ -318,1 +421,12 @@\n-            ret |= add(element);\n+            if (backingSet.add(element)) {\n+                if (addedList != null) {\n+                    addedList.add(element);\n+                } else if (addedElement != null) {\n+                    addedList = new ArrayList<>(c.size());\n+                    addedList.add(addedElement);\n+                    addedList.add(element);\n+                    addedElement = null;\n+                } else {\n+                    addedElement = element;\n+                }\n+            }\n@@ -320,1 +434,12 @@\n-        return ret;\n+\n+        if (addedElement != null) {\n+            callObservers(new SimpleAddChange(addedElement));\n+            return true;\n+        }\n+\n+        if (addedList != null) {\n+            callObservers(new IterableAddChange<>(this, addedList));\n+            return true;\n+        }\n+\n+        return false;\n@@ -366,1 +491,3 @@\n-        boolean removed = false;\n+        E removedElement = null;\n+        List<E> removedList = null;\n+\n@@ -370,1 +497,11 @@\n-                removed = true;\n+                if (removedList != null) {\n+                    removedList.add(element);\n+                } else if (removedElement != null) {\n+                    removedList = new ArrayList<>(c.size());\n+                    removedList.add(removedElement);\n+                    removedList.add(element);\n+                    removedElement = null;\n+                } else {\n+                    removedElement = element;\n+                }\n+\n@@ -372,1 +509,0 @@\n-                callObservers(new SimpleRemoveChange(element));\n@@ -375,1 +511,12 @@\n-        return removed;\n+\n+        if (removedElement != null) {\n+            callObservers(new SimpleRemoveChange(removedElement));\n+            return true;\n+        }\n+\n+        if (removedList != null) {\n+            callObservers(new IterableRemoveChange<>(this, removedList));\n+            return true;\n+        }\n+\n+        return false;\n@@ -385,3 +532,10 @@\n-        for (Iterator<E> i = backingSet.iterator(); i.hasNext(); ) {\n-            E element = i.next();\n-            i.remove();\n+        if (backingSet.size() > 1) {\n+            @SuppressWarnings(\"unchecked\")\n+            E[] removed = (E[])new Object[backingSet.size()];\n+            backingSet.toArray(removed);\n+            backingSet.clear();\n+            callObservers(new IterableRemoveChange<>(this, Arrays.asList(removed)));\n+        } else if (backingSet.size() == 1) {\n+            Iterator<E> it = backingSet.iterator();\n+            E element = it.next();\n+            it.remove();\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ObservableSetWrapper.java","additions":168,"deletions":14,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,3 @@\n-public class SetAdapterChange<E> extends SetChangeListener.Change<E> {\n-    private final Change<? extends E> change;\n+public final class SetAdapterChange<E> extends SetChangeListener.Change<E> {\n+\n+    private Change<? extends E> change;\n@@ -65,0 +66,10 @@\n+    @Override\n+    public Change<E> next() {\n+        Change<? extends E> nextChange = change.next();\n+        if (nextChange != null) {\n+            change = nextChange;\n+            return this;\n+        }\n+\n+        return null;\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/SetAdapterChange.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,5 +160,7 @@\n-            try {\n-                listener.onChanged(change);\n-            } catch (Exception e) {\n-                Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n-            }\n+            do {\n+                try {\n+                    listener.onChanged(change);\n+                } catch (Exception e) {\n+                    Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+                }\n+            } while (change instanceof IterableSetChange<? extends E> c && c.nextChange());\n@@ -323,1 +325,28 @@\n-                for (int i = 0; i < curChangeSize; i++) {\n+\n+                if (change instanceof IterableSetChange<? extends E> iterableChange) {\n+                    fireSetChangeEvent(iterableChange, curChangeList, curChangeSize);\n+                } else {\n+                    fireSetChangeEvent(change, curChangeList, curChangeSize);\n+                }\n+            } finally {\n+                locked = false;\n+            }\n+        }\n+\n+        private static <E> void fireSetChangeEvent(SetChangeListener.Change<? extends E> change,\n+                                                   SetChangeListener<? super E>[] curChangeList,\n+                                                   int curChangeSize) {\n+            for (int i = 0; i < curChangeSize; i++) {\n+                try {\n+                    curChangeList[i].onChanged(change);\n+                } catch (Exception e) {\n+                    Thread.currentThread().getUncaughtExceptionHandler().uncaughtException(Thread.currentThread(), e);\n+                }\n+            }\n+        }\n+\n+        private static <E> void fireSetChangeEvent(IterableSetChange<? extends E> change,\n+                                                   SetChangeListener<? super E>[] curChangeList,\n+                                                   int curChangeSize) {\n+            for (int i = 0; i < curChangeSize; i++) {\n+                do {\n@@ -329,3 +358,3 @@\n-                }\n-            } finally {\n-                locked = false;\n+                } while (change.nextChange());\n+\n+                change.reset();\n@@ -335,1 +364,0 @@\n-\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/SetListenerHelper.java","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,28 @@\n+        \/**\n+         * Gets the next change in a series of changes.\n+         * <p>\n+         * Repeatedly calling this method allows a listener to fetch all subsequent changes of a bulk\n+         * map modification that would otherwise be reported as repeated invocations of the listener.\n+         * If the listener only fetches some of the pending changes, the rest of the changes will be\n+         * reported with subsequent listener invocations.\n+         * <p>\n+         * After this method has been called, the current {@code Change} instance is no longer valid and\n+         * calling any method on it may result in undefined behavior. Callers must not make any assumptions\n+         * about the identity of the {@code Change} instance returned by this method; even if the returned\n+         * instance is the same as the current instance, it must be treated as a distinct change.\n+         * <p>\n+         * Since this method must not be called before inspecting the first change, listeners will\n+         * usually use a do-while loop to iterate over multiple changes:\n+         * <pre>{@code\n+         *     map.addListener((MapChangeListener<String, String>) change -> {\n+         *         do {\n+         *             \/\/ Inspect the change\n+         *             \/\/ ...\n+         *         } while ((change = change.next()) != null);\n+         *     });\n+         * }<\/pre>\n+         *\n+         * @return the next change, or {@code null} if there are no more changes\n+         * @since 26\n+         *\/\n+        public Change<K, V> next() { return null; }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/collections\/MapChangeListener.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,28 @@\n+        \/**\n+         * Gets the next change in a series of changes.\n+         * <p>\n+         * Repeatedly calling this method allows a listener to fetch all subsequent changes of a bulk\n+         * set modification that would otherwise be reported as repeated invocations of the listener.\n+         * If the listener only fetches some of the pending changes, the rest of the changes will be\n+         * reported with subsequent listener invocations.\n+         * <p>\n+         * After this method has been called, the current {@code Change} instance is no longer valid and\n+         * calling any method on it may result in undefined behavior. Callers must not make any assumptions\n+         * about the identity of the {@code Change} instance returned by this method; even if the returned\n+         * instance is the same as the current instance, it must be treated as a distinct change.\n+         * <p>\n+         * Since this method must not be called before inspecting the first change, listeners will\n+         * usually use a do-while loop to iterate over multiple changes:\n+         * <pre>{@code\n+         *     set.addListener((SetChangeListener<String>) change -> {\n+         *         do {\n+         *             \/\/ Inspect the change\n+         *             \/\/ ...\n+         *         } while ((change = change.next()) != null);\n+         *     });\n+         * }<\/pre>\n+         *\n+         * @return the next change, or {@code null} if there are no more changes\n+         * @since 26\n+         *\/\n+        public Change<E> next() { return null; }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/collections\/SetChangeListener.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javafx.collections.MapChangeListener;\n@@ -32,0 +33,1 @@\n+import java.util.ArrayList;\n@@ -35,0 +37,2 @@\n+import java.util.LinkedHashMap;\n+import java.util.List;\n@@ -42,0 +46,76 @@\n+    @Test\n+    public void partialChangeIterationCausesSubsequentListenerInvocation() {\n+        var trace = new ArrayList<String>();\n+        var invocations = new int[1];\n+        var map = new ObservableMapWrapper<String, String>(new HashMap<>());\n+\n+        \/\/ This listener only processes 2 changes in each invocation.\n+        map.addListener((MapChangeListener<String, String>) change -> {\n+            invocations[0]++;\n+            trace.add(change.toString());\n+\n+            change = change.next();\n+            trace.add(change.toString());\n+        });\n+\n+        map.putAll(new LinkedHashMap<>() {{\n+            put(\"k1\", \"a\");\n+            put(\"k2\", \"b\");\n+            put(\"k3\", \"c\");\n+            put(\"k4\", \"d\");\n+            put(\"k5\", \"e\");\n+            put(\"k6\", \"f\");\n+        }});\n+\n+        assertEquals(3, invocations[0]);\n+        assertEquals(\n+            List.of(\n+                \"a added at key k1\",\n+                \"b added at key k2\",\n+                \"c added at key k3\",\n+                \"d added at key k4\",\n+                \"e added at key k5\",\n+                \"f added at key k6\"),\n+            trace);\n+    }\n+\n+    @Nested\n+    class ClearTest {\n+        @Test\n+        public void singleEntry() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\"));\n+            map.clear();\n+            map.assertTraceEquals(\"a removed at key k1\");\n+        }\n+\n+        @Test\n+        public void multipleEntries() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+            map.clear();\n+            map.assertTraceEquals(\n+                \"a removed at key k1\",\n+                \"b removed at key k2\",\n+                \"c removed at key k3\");\n+        }\n+    }\n+\n+    @Nested\n+    class PutAllTest {\n+        @Test\n+        public void singleEntry() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+            map.putAll(Map.of(\"k1\", \"d\"));\n+            map.assertTraceEquals(\"a replaced by d at key k1\");\n+        }\n+\n+        @Test\n+        public void multipleEntries() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+            map.putAll(Map.of(\"k1\", \"d\", \"k2\", \"e\", \"k4\", \"f\"));\n+            map.assertTraceEquals(\n+                \"a replaced by d at key k1\",\n+                \"b replaced by e at key k2\",\n+                \"f added at key k4\");\n+        }\n+    }\n+\n@@ -44,0 +124,17 @@\n+        @Test\n+        public void singleEntry() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+            map.keySet().removeAll(List.of(\"k1\"));\n+            map.assertTraceEquals(\"a removed at key k1\");\n+        }\n+\n+        @Test\n+        public void multipleEntries() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+            map.keySet().removeAll(List.of(\"k1\", \"k2\", \"k3\"));\n+            map.assertTraceEquals(\n+                \"a removed at key k1\",\n+                \"b removed at key k2\",\n+                \"c removed at key k3\");\n+        }\n+\n@@ -100,0 +197,14 @@\n+        @Test\n+        public void singleEntry() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+            map.keySet().retainAll(List.of(\"k1\"));\n+            map.assertTraceEquals(\"b removed at key k2\", \"c removed at key k3\");\n+        }\n+\n+        @Test\n+        public void multipleEntries() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+            map.keySet().retainAll(List.of(\"k1\", \"k3\"));\n+            map.assertTraceEquals(\"b removed at key k2\");\n+        }\n+\n@@ -154,0 +265,57 @@\n+    @Nested\n+    class ReplaceAllTest {\n+        @Test\n+        public void singleEntry() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+\n+            map.replaceAll((key, value) -> switch (key) {\n+                case \"k2\" -> \"e\";\n+                default -> value;\n+            });\n+\n+            map.assertTraceEquals(\"b replaced by e at key k2\");\n+        }\n+\n+        @Test\n+        public void multipleEntries() {\n+            var map = new TestObservableMapWrapper(Map.of(\"k1\", \"a\", \"k2\", \"b\", \"k3\", \"c\"));\n+\n+            map.replaceAll((key, value) -> switch (key) {\n+                case \"k1\" -> \"d\";\n+                case \"k2\" -> \"e\";\n+                case \"k3\" -> \"f\";\n+                default -> value;\n+            });\n+\n+            map.assertTraceEquals(\n+                \"a replaced by d at key k1\",\n+                \"b replaced by e at key k2\",\n+                \"c replaced by f at key k3\");\n+        }\n+    }\n+\n+    private static class TestObservableMapWrapper extends ObservableMapWrapper<String, String> {\n+        final Set<String> bulkChangeTrace = new HashSet<>();\n+        final Set<String> singleChangeTrace = new HashSet<>();\n+\n+        public TestObservableMapWrapper(Map<String, String> map) {\n+            super(new HashMap<>(map));\n+\n+            addListener((MapChangeListener<? super String, ? super String>) change -> {\n+                do {\n+                    bulkChangeTrace.add(change.toString());\n+                } while ((change = change.next()) != null);\n+            });\n+\n+            addListener((MapChangeListener<? super String, ? super String>) change -> {\n+                singleChangeTrace.add(change.toString());\n+            });\n+        }\n+\n+        void assertTraceEquals(String... expected) {\n+            var expectedSet = Set.of(expected);\n+            assertEquals(expectedSet, bulkChangeTrace);\n+            assertEquals(expectedSet, singleChangeTrace);\n+        }\n+    }\n+\n@@ -188,1 +356,0 @@\n-\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/collections\/ObservableMapWrapperTest.java","additions":169,"deletions":2,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javafx.collections.SetChangeListener;\n@@ -31,0 +32,1 @@\n+import java.util.ArrayList;\n@@ -33,0 +35,1 @@\n+import java.util.List;\n@@ -39,0 +42,44 @@\n+    @Test\n+    public void partialChangeIterationCausesSubsequentListenerInvocation() {\n+        var trace = new ArrayList<String>();\n+        var invocations = new int[1];\n+        var set = new ObservableSetWrapper<String>(new HashSet<>());\n+\n+        \/\/ This listener only processes 2 changes in each invocation.\n+        set.addListener((SetChangeListener<String>) change -> {\n+            invocations[0]++;\n+            trace.add(change.toString());\n+\n+            change = change.next();\n+            trace.add(change.toString());\n+        });\n+\n+        set.addAll(List.of(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"));\n+        assertEquals(3, invocations[0]);\n+        assertEquals(List.of(\"added a\", \"added b\", \"added c\", \"added d\", \"added e\", \"added f\"), trace);\n+    }\n+\n+    @Nested\n+    class AddAllTest {\n+        @Test\n+        public void duplicateElement() {\n+            var set = new TestObservableSetWrapper(Set.of(\"a\", \"b\", \"c\"));\n+            set.addAll(Set.of(\"b\"));\n+            set.assertTraceEquals();\n+        }\n+\n+        @Test\n+        public void singleElement() {\n+            var set = new TestObservableSetWrapper(Set.of(\"a\", \"b\", \"c\"));\n+            set.addAll(Set.of(\"d\"));\n+            set.assertTraceEquals(\"added d\");\n+        }\n+\n+        @Test\n+        public void multipleElements() {\n+            var set = new TestObservableSetWrapper(Set.of(\"a\", \"b\", \"c\"));\n+            set.addAll(Set.of(\"b\", \"c\", \"d\", \"e\"));\n+            set.assertTraceEquals(\"added d\", \"added e\");\n+        }\n+    }\n+\n@@ -41,0 +88,14 @@\n+        @Test\n+        public void singleElement() {\n+            var set = new TestObservableSetWrapper(Set.of(\"a\", \"b\", \"c\"));\n+            set.removeAll(Set.of(\"b\"));\n+            set.assertTraceEquals(\"removed b\");\n+        }\n+\n+        @Test\n+        public void multipleElements() {\n+            var set = new TestObservableSetWrapper(Set.of(\"a\", \"b\", \"c\"));\n+            set.removeAll(Set.of(\"a\", \"b\", \"c\"));\n+            set.assertTraceEquals(\"removed a\", \"removed b\", \"removed c\");\n+        }\n+\n@@ -69,0 +130,14 @@\n+        @Test\n+        public void singleElement() {\n+            var set = new TestObservableSetWrapper(Set.of(\"a\", \"b\", \"c\"));\n+            set.retainAll(Set.of(\"b\"));\n+            set.assertTraceEquals(\"removed a\", \"removed c\");\n+        }\n+\n+        @Test\n+        public void multipleElements() {\n+            var set = new TestObservableSetWrapper(Set.of(\"a\", \"b\", \"c\"));\n+            set.retainAll(Set.of(\"a\", \"c\"));\n+            set.assertTraceEquals(\"removed b\");\n+        }\n+\n@@ -94,0 +169,24 @@\n+    private static class TestObservableSetWrapper extends ObservableSetWrapper<String> {\n+        final Set<String> bulkChangeTrace = new HashSet<>();\n+        final Set<String> singleChangeTrace = new HashSet<>();\n+\n+        public TestObservableSetWrapper(Set<String> set) {\n+            super(new HashSet<>(set));\n+\n+            addListener((SetChangeListener<String>) change -> {\n+                do {\n+                    bulkChangeTrace.add(change.toString());\n+                } while ((change = change.next()) != null);\n+            });\n+\n+            addListener((SetChangeListener<String>) change -> {\n+                singleChangeTrace.add(change.toString());\n+            });\n+        }\n+\n+        void assertTraceEquals(String... expected) {\n+            var expectedSet = Set.of(expected);\n+            assertEquals(expectedSet, bulkChangeTrace);\n+            assertEquals(expectedSet, singleChangeTrace);\n+        }\n+    }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/collections\/ObservableSetWrapperTest.java","additions":100,"deletions":1,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import org.junit.jupiter.api.Test;\n-\n@@ -185,0 +183,15 @@\n+    @ParameterizedTest\n+    @MethodSource(\"createParameters\")\n+    @SuppressWarnings(\"unchecked\")\n+    public void testReplaceAll(Callable<ObservableMap<String, String>> mapFactory) throws Exception {\n+        setUp(mapFactory);\n+\n+        observableMap.replaceAll((key, value) -> switch (key) {\n+            case \"one\" -> \"2\";\n+            case \"two\" -> \"3\";\n+            default -> value;\n+        });\n+\n+        observer.assertMultipleCalls(call(\"one\", \"1\", \"2\"), call(\"two\", \"2\", \"3\"));\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/collections\/ObservableMapTest.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"}]}