{"files":[{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx;\n+\n+import javafx.beans.WeakListener;\n+import java.util.function.Predicate;\n+\n+public final class WeakListenerArrayUtil {\n+\n+    private static final Predicate<Object> collectedTest =\n+        t -> t instanceof WeakListener && ((WeakListener)t).wasGarbageCollected();\n+\n+    private WeakListenerArrayUtil() {}\n+\n+    public static int trim(int size, Object[] listeners) {\n+        int index = 0;\n+        for (; index < size; index++) {\n+            if (collectedTest.test(listeners[index])) {\n+                break;\n+            }\n+        }\n+\n+        if (index < size) {\n+            for (int src = index + 1; src < size; src++) {\n+                if (!collectedTest.test(listeners[src])) {\n+                    listeners[index++] = listeners[src];\n+                }\n+            }\n+            int oldSize = size;\n+            size = index;\n+            for (; index < oldSize; index++) {\n+                listeners[index] = null;\n+            }\n+        }\n+\n+        return size;\n+    }\n+\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/WeakListenerArrayUtil.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.beans;\n+\n+import javafx.beans.property.ReadOnlyProperty;\n+\n+public enum BeanErrors {\n+\n+    BINDING_TARGET_NULL(\"Binding target cannot be null.\"),\n+    BINDING_SOURCE_NULL(\"Binding source cannot be null.\"),\n+    CANNOT_SET_BOUND_PROPERTY(\"Cannot set the value of a bound property.\"),\n+    CANNOT_SET_CONTENT_BOUND_PROPERTY(\"Cannot set the value of a content-bound property.\"),\n+    CANNOT_BIND_PROPERTY_TO_ITSELF(\"Cannot bind property to itself.\"),\n+    CANNOT_UNBIND_PROPERTY_FROM_ITSELF(\"Cannot unbind property from itself.\"),\n+    CANNOT_BIND_COLLECTION_TO_ITSELF(\"Cannot bind collection to itself.\"),\n+    CANNOT_UNBIND_COLLECTION_FROM_ITSELF(\"Cannot unbind collection from itself.\"),\n+    BIND_CONFLICT_BIDIRECTIONAL(\"Bidirectional binding cannot target a bound property.\"),\n+    BIND_CONFLICT_UNIDIRECTIONAL(\"Cannot bind a property that is targeted by a bidirectional binding.\"),\n+    CONTENT_BIND_CONFLICT_BIDIRECTIONAL(\"Bidirectional content binding cannot target a bound collection.\"),\n+    CONTENT_BIND_CONFLICT_UNIDIRECTIONAL(\"Cannot bind a collection that is targeted by a bidirectional content binding.\"),\n+    ILLEGAL_LIST_MODIFICATION(\"Illegal list modification: Content binding was removed because the lists are out-of-sync.\"),\n+    ILLEGAL_SET_MODIFICATION(\"Illegal set modification: Content binding was removed because the sets are out-of-sync.\"),\n+    ILLEGAL_MAP_MODIFICATION(\"Illegal map modification: Content binding was removed because the maps are out-of-sync.\");\n+\n+    BeanErrors(String message) {\n+        this.message = message;\n+    }\n+\n+    private final String message;\n+\n+    \/**\n+     * Returns the error message.\n+     *\/\n+    public String getMessage() {\n+        return message;\n+    }\n+\n+    \/**\n+     * Returns the error message.\n+     * If the specified value is a {@link ReadOnlyProperty}, the returned message includes the\n+     * name of the property; otherwise it is identical to {@link #getMessage()}.\n+     *\/\n+    public String getMessage(Object property) {\n+        return formatPropertyName(property) + message;\n+    }\n+\n+    private String formatPropertyName(Object property) {\n+        if (property instanceof ReadOnlyProperty<?>) {\n+            Object bean = ((ReadOnlyProperty<?>)property).getBean();\n+            String name = ((ReadOnlyProperty<?>)property).getName();\n+            if (bean != null && name != null && !name.isBlank()) {\n+                return bean.getClass().getName() + \".\" + name + \": \";\n+            }\n+        }\n+\n+        return \"\";\n+    }\n+\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/beans\/BeanErrors.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+import javafx.beans.binding.Bindings;\n@@ -32,1 +33,0 @@\n-import javafx.beans.value.ObservableValue;\n@@ -40,0 +40,2 @@\n+import static com.sun.javafx.beans.BeanErrors.*;\n+\n@@ -50,5 +52,30 @@\n-    private static void checkParameters(Object property1, Object property2) {\n-        Objects.requireNonNull(property1, \"Both properties must be specified.\");\n-        Objects.requireNonNull(property2, \"Both properties must be specified.\");\n-        if (property1 == property2) {\n-            throw new IllegalArgumentException(\"Cannot bind property to itself\");\n+    \/**\n+     * Exceptions thrown here will be surfaced by {@link Bindings#bindBidirectional(Property, Property)}\n+     * and by {@link Property#bindBidirectional(Property)}. In the latter case, the 'target'\n+     * argument is the 'this' pointer of the Property class. If 'this' is a bound property, we\n+     * throw an IllegalStateException instead of an IllegalArgumentException, because from the\n+     * perspective of a user of the Property class, 'target' was not specified as an argument.\n+     *\n+     * However, when using the Bindings class to set up a bidirectional binding, we catch the\n+     * IllegalStateException and re-throw it as an IllegalArgumentException. From the perspective\n+     * of a user of the Bindings class, 'target' was specified as an argument.\n+     *\/\n+    private static void checkBindParameters(Property<?> target, Property<?> source) {\n+        if (target == null) {\n+            throw new NullPointerException(BINDING_TARGET_NULL.getMessage());\n+        }\n+\n+        if (source == null) {\n+            throw new NullPointerException(BINDING_SOURCE_NULL.getMessage(target));\n+        }\n+\n+        if (target == source) {\n+            throw new IllegalArgumentException(CANNOT_BIND_PROPERTY_TO_ITSELF.getMessage(target));\n+        }\n+\n+        if (target.isBound()) {\n+            throw new IllegalStateException(BIND_CONFLICT_BIDIRECTIONAL.getMessage(target));\n+        }\n+\n+        if (source.isBound()) {\n+            throw new IllegalArgumentException(BIND_CONFLICT_BIDIRECTIONAL.getMessage(source));\n@@ -58,19 +85,12 @@\n-    public static <T> BidirectionalBinding bind(Property<T> property1, Property<T> property2) {\n-        checkParameters(property1, property2);\n-        final BidirectionalBinding binding =\n-                ((property1 instanceof DoubleProperty) && (property2 instanceof DoubleProperty)) ?\n-                        new BidirectionalDoubleBinding((DoubleProperty) property1, (DoubleProperty) property2)\n-                : ((property1 instanceof FloatProperty) && (property2 instanceof FloatProperty)) ?\n-                        new BidirectionalFloatBinding((FloatProperty) property1, (FloatProperty) property2)\n-                : ((property1 instanceof IntegerProperty) && (property2 instanceof IntegerProperty)) ?\n-                        new BidirectionalIntegerBinding((IntegerProperty) property1, (IntegerProperty) property2)\n-                : ((property1 instanceof LongProperty) && (property2 instanceof LongProperty)) ?\n-                        new BidirectionalLongBinding((LongProperty) property1, (LongProperty) property2)\n-                : ((property1 instanceof BooleanProperty) && (property2 instanceof BooleanProperty)) ?\n-                        new BidirectionalBooleanBinding((BooleanProperty) property1, (BooleanProperty) property2)\n-                : new TypedGenericBidirectionalBinding<T>(property1, property2);\n-        property1.setValue(property2.getValue());\n-        property1.getValue();\n-        property1.addListener(binding);\n-        property2.addListener(binding);\n-        return binding;\n+    private static void checkUnbindParameters(Property<?> target, Property<?> source) {\n+        if (target == null) {\n+            throw new NullPointerException(BINDING_TARGET_NULL.getMessage());\n+        }\n+\n+        if (source == null) {\n+            throw new NullPointerException(BINDING_SOURCE_NULL.getMessage(target));\n+        }\n+\n+        if (target == source) {\n+            throw new IllegalArgumentException(CANNOT_UNBIND_PROPERTY_FROM_ITSELF.getMessage(target));\n+        }\n@@ -79,8 +99,26 @@\n-    public static Object bind(Property<String> stringProperty, Property<?> otherProperty, Format format) {\n-        checkParameters(stringProperty, otherProperty);\n-        Objects.requireNonNull(format, \"Format cannot be null\");\n-        final var binding = new StringFormatBidirectionalBinding(stringProperty, otherProperty, format);\n-        stringProperty.setValue(format.format(otherProperty.getValue()));\n-        stringProperty.getValue();\n-        stringProperty.addListener(binding);\n-        otherProperty.addListener(binding);\n+    public static <T> BidirectionalBinding bind(Property<T> target, Property<T> source) {\n+        checkBindParameters(target, source);\n+        final BidirectionalBinding binding =\n+                ((target instanceof DoubleProperty) && (source instanceof DoubleProperty)) ?\n+                        new BidirectionalDoubleBinding((DoubleProperty) target, (DoubleProperty) source)\n+                : ((target instanceof FloatProperty) && (source instanceof FloatProperty)) ?\n+                        new BidirectionalFloatBinding((FloatProperty) target, (FloatProperty) source)\n+                : ((target instanceof IntegerProperty) && (source instanceof IntegerProperty)) ?\n+                        new BidirectionalIntegerBinding((IntegerProperty) target, (IntegerProperty) source)\n+                : ((target instanceof LongProperty) && (source instanceof LongProperty)) ?\n+                        new BidirectionalLongBinding((LongProperty) target, (LongProperty) source)\n+                : ((target instanceof BooleanProperty) && (source instanceof BooleanProperty)) ?\n+                        new BidirectionalBooleanBinding((BooleanProperty) target, (BooleanProperty) source)\n+                : new TypedGenericBidirectionalBinding<T>(target, source);\n+\n+        \/\/ We can't know whether the two properties are already bidirectionally bound.\n+        \/\/ However, since BidirectionalBinding instances are equal if their endpoints are identical, removing\n+        \/\/ the newly-created binding has the effect of removing an already existing bidirectional binding.\n+        target.removeListener(binding);\n+        source.removeListener(binding);\n+\n+        target.setValue(source.getValue());\n+        target.getValue();\n+        target.addListener(binding);\n+        source.addListener(binding);\n+\n@@ -90,8 +128,10 @@\n-    public static <T> Object bind(Property<String> stringProperty, Property<T> otherProperty, StringConverter<T> converter) {\n-        checkParameters(stringProperty, otherProperty);\n-        Objects.requireNonNull(converter, \"Converter cannot be null\");\n-        final var binding = new StringConverterBidirectionalBinding<>(stringProperty, otherProperty, converter);\n-        stringProperty.setValue(converter.toString(otherProperty.getValue()));\n-        stringProperty.getValue();\n-        stringProperty.addListener(binding);\n-        otherProperty.addListener(binding);\n+    public static Object bind(Property<String> target, Property<?> source, Format format) {\n+        Objects.requireNonNull(format, \"Format cannot be null.\");\n+        checkBindParameters(target, source);\n+        final var binding = new StringFormatBidirectionalBinding(target, source, format);\n+        target.removeListener(binding);\n+        source.removeListener(binding);\n+        target.setValue(format.format(source.getValue()));\n+        target.getValue();\n+        target.addListener(binding);\n+        source.addListener(binding);\n@@ -101,5 +141,11 @@\n-    public static <T> void unbind(Property<T> property1, Property<T> property2) {\n-        checkParameters(property1, property2);\n-        final BidirectionalBinding binding = new UntypedGenericBidirectionalBinding(property1, property2);\n-        property1.removeListener(binding);\n-        property2.removeListener(binding);\n+    public static <T> Object bind(Property<String> target, Property<T> source, StringConverter<T> converter) {\n+        Objects.requireNonNull(converter, \"Converter cannot be null.\");\n+        checkBindParameters(target, source);\n+        final var binding = new StringConverterBidirectionalBinding<>(target, source, converter);\n+        target.removeListener(binding);\n+        source.removeListener(binding);\n+        target.setValue(converter.toString(source.getValue()));\n+        target.getValue();\n+        target.addListener(binding);\n+        source.addListener(binding);\n+        return binding;\n@@ -108,9 +154,5 @@\n-    public static void unbind(Object property1, Object property2) {\n-        checkParameters(property1, property2);\n-        final BidirectionalBinding binding = new UntypedGenericBidirectionalBinding(property1, property2);\n-        if (property1 instanceof ObservableValue) {\n-            ((ObservableValue<?>)property1).removeListener(binding);\n-        }\n-        if (property2 instanceof ObservableValue) {\n-            ((ObservableValue<?>)property2).removeListener(binding);\n-        }\n+    public static void unbind(Property<?> target, Property<?> source) {\n+        checkUnbindParameters(target, source);\n+        final BidirectionalBinding binding = new UntypedGenericBidirectionalBinding(target, source);\n+        target.removeListener(binding);\n+        source.removeListener(binding);\n@@ -119,2 +161,2 @@\n-    public static BidirectionalBinding bindNumber(Property<Integer> property1, IntegerProperty property2) {\n-        return bindNumber(property1, (Property<Number>)property2);\n+    public static BidirectionalBinding bindNumber(Property<Integer> target, IntegerProperty source) {\n+        return bindNumber(target, (Property<Number>)source);\n@@ -123,2 +165,2 @@\n-    public static BidirectionalBinding bindNumber(Property<Long> property1, LongProperty property2) {\n-        return bindNumber(property1, (Property<Number>)property2);\n+    public static BidirectionalBinding bindNumber(Property<Long> target, LongProperty source) {\n+        return bindNumber(target, (Property<Number>)source);\n@@ -127,2 +169,2 @@\n-    public static BidirectionalBinding bindNumber(Property<Float> property1, FloatProperty property2) {\n-        return bindNumber(property1, (Property<Number>)property2);\n+    public static BidirectionalBinding bindNumber(Property<Float> target, FloatProperty source) {\n+        return bindNumber(target, (Property<Number>)source);\n@@ -131,2 +173,2 @@\n-    public static BidirectionalBinding bindNumber(Property<Double> property1, DoubleProperty property2) {\n-        return bindNumber(property1, (Property<Number>)property2);\n+    public static BidirectionalBinding bindNumber(Property<Double> target, DoubleProperty source) {\n+        return bindNumber(target, (Property<Number>)source);\n@@ -135,2 +177,2 @@\n-    public static BidirectionalBinding bindNumber(IntegerProperty property1, Property<Integer> property2) {\n-        return bindNumberObject(property1, property2);\n+    public static BidirectionalBinding bindNumber(IntegerProperty target, Property<Integer> source) {\n+        return bindNumberObject(target, source);\n@@ -139,2 +181,2 @@\n-    public static BidirectionalBinding bindNumber(LongProperty property1, Property<Long> property2) {\n-        return bindNumberObject(property1, property2);\n+    public static BidirectionalBinding bindNumber(LongProperty target, Property<Long> source) {\n+        return bindNumberObject(target, source);\n@@ -143,2 +185,2 @@\n-    public static BidirectionalBinding bindNumber(FloatProperty property1, Property<Float> property2) {\n-        return bindNumberObject(property1, property2);\n+    public static BidirectionalBinding bindNumber(FloatProperty target, Property<Float> source) {\n+        return bindNumberObject(target, source);\n@@ -147,2 +189,2 @@\n-    public static BidirectionalBinding bindNumber(DoubleProperty property1, Property<Double> property2) {\n-        return bindNumberObject(property1, property2);\n+    public static BidirectionalBinding bindNumber(DoubleProperty target, Property<Double> source) {\n+        return bindNumberObject(target, source);\n@@ -151,9 +193,9 @@\n-    private static <T extends Number> BidirectionalBinding bindNumberObject(Property<Number> property1, Property<T> property2) {\n-        checkParameters(property1, property2);\n-\n-        final BidirectionalBinding binding = new TypedNumberBidirectionalBinding<>(property2, property1);\n-\n-        property1.setValue(property2.getValue());\n-        property1.getValue();\n-        property1.addListener(binding);\n-        property2.addListener(binding);\n+    private static <T extends Number> BidirectionalBinding bindNumberObject(Property<Number> target, Property<T> source) {\n+        checkBindParameters(target, source);\n+        final BidirectionalBinding binding = new TypedNumberBidirectionalBinding<>(source, target);\n+        target.removeListener(binding);\n+        source.removeListener(binding);\n+        target.setValue(source.getValue());\n+        target.getValue();\n+        target.addListener(binding);\n+        source.addListener(binding);\n@@ -163,9 +205,9 @@\n-    private static <T extends Number> BidirectionalBinding bindNumber(Property<T> property1, Property<Number> property2) {\n-        checkParameters(property1, property2);\n-\n-        final BidirectionalBinding binding = new TypedNumberBidirectionalBinding<>(property1, property2);\n-\n-        property1.setValue((T)property2.getValue());\n-        property1.getValue();\n-        property1.addListener(binding);\n-        property2.addListener(binding);\n+    private static <T extends Number> BidirectionalBinding bindNumber(Property<T> target, Property<Number> source) {\n+        checkBindParameters(target, source);\n+        final BidirectionalBinding binding = new TypedNumberBidirectionalBinding<>(target, source);\n+        target.removeListener(binding);\n+        source.removeListener(binding);\n+        target.setValue((T)source.getValue());\n+        target.getValue();\n+        target.addListener(binding);\n+        source.addListener(binding);\n@@ -177,1 +219,1 @@\n-    private BidirectionalBinding(Object property1, Object property2) {\n+    private BidirectionalBinding(Property<?> property1, Property<?> property2) {\n@@ -181,1 +223,1 @@\n-    protected abstract Object getProperty1();\n+    protected abstract Property<?> getProperty1();\n@@ -183,1 +225,1 @@\n-    protected abstract Object getProperty2();\n+    protected abstract Property<?> getProperty2();\n@@ -201,2 +243,2 @@\n-        final Object propertyA1 = getProperty1();\n-        final Object propertyA2 = getProperty2();\n+        final Property<?> propertyA1 = getProperty1();\n+        final Property<?> propertyA2 = getProperty2();\n@@ -209,2 +251,2 @@\n-            final Object propertyB1 = otherBinding.getProperty1();\n-            final Object propertyB2 = otherBinding.getProperty2();\n+            final Property<?> propertyB1 = otherBinding.getProperty1();\n+            final Property<?> propertyB2 = otherBinding.getProperty2();\n@@ -765,2 +807,2 @@\n-        private final Object property1;\n-        private final Object property2;\n+        private final Property<?> property1;\n+        private final Property<?> property2;\n@@ -768,1 +810,1 @@\n-        public UntypedGenericBidirectionalBinding(Object property1, Object property2) {\n+        public UntypedGenericBidirectionalBinding(Property<?> property1, Property<?> property2) {\n@@ -775,1 +817,1 @@\n-        protected Object getProperty1() {\n+        protected Property<?> getProperty1() {\n@@ -780,1 +822,1 @@\n-        protected Object getProperty2() {\n+        protected Property<?> getProperty2() {\n@@ -806,1 +848,1 @@\n-        protected Object getProperty1() {\n+        protected Property<?> getProperty1() {\n@@ -811,1 +853,1 @@\n-        protected Object getProperty2() {\n+        protected Property<?> getProperty2() {\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/BidirectionalBinding.java","additions":145,"deletions":103,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -29,1 +30,11 @@\n-import javafx.collections.*;\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.ReadOnlyListProperty;\n+import javafx.beans.property.ReadOnlyMapProperty;\n+import javafx.beans.property.ReadOnlyProperty;\n+import javafx.beans.property.ReadOnlySetProperty;\n+import javafx.collections.ListChangeListener;\n+import javafx.collections.MapChangeListener;\n+import javafx.collections.ObservableList;\n+import javafx.collections.ObservableMap;\n+import javafx.collections.ObservableSet;\n+import javafx.collections.SetChangeListener;\n@@ -35,3 +46,28 @@\n-\/**\n- *\/\n-public class BidirectionalContentBinding {\n+import static com.sun.javafx.beans.BeanErrors.*;\n+\n+public abstract class BidirectionalContentBinding implements WeakListener {\n+\n+    \/**\n+     * Exceptions thrown here will be surfaced by {@link Bindings#bindContentBidirectional(ObservableList, ObservableList)}\n+     * and by {@link ReadOnlyListProperty#bindContentBidirectional(ObservableList)} (set\/map similarly).\n+     * In the latter case, the 'target' argument is the 'this' pointer of the ReadOnlyListProperty class.\n+     * If 'this' is content-bound, we throw an IllegalStateException instead of an IllegalArgumentException,\n+     * because from the perspective of a user of the ReadOnlyListProperty class, 'target' was not specified\n+     * as an argument.\n+     *\n+     * However, when using the Bindings class to set up a bidirectional content binding, we catch the\n+     * IllegalStateException and re-throw it as an IllegalArgumentException. From the perspective of a user of\n+     * the Bindings class, 'target' was specified as an argument.\n+     *\/\n+    private static void checkParameters(Object target, Object source, Class<?> collectionType) {\n+        if (target == null) {\n+            throw new NullPointerException(BINDING_TARGET_NULL.getMessage());\n+        }\n+\n+        if (source == null) {\n+            throw new NullPointerException(BINDING_SOURCE_NULL.getMessage(target));\n+        }\n+\n+        if (isContentBound(target)) {\n+            throw new IllegalStateException(CONTENT_BIND_CONFLICT_BIDIRECTIONAL.getMessage(target));\n+        }\n@@ -39,3 +75,2 @@\n-    private static void checkParameters(Object property1, Object property2) {\n-        if ((property1 == null) || (property2 == null)) {\n-            throw new NullPointerException(\"Both parameters must be specified.\");\n+        if (isContentBound(source)) {\n+            throw new IllegalArgumentException(CONTENT_BIND_CONFLICT_BIDIRECTIONAL.getMessage(source));\n@@ -43,2 +78,22 @@\n-        if (property1 == property2) {\n-            throw new IllegalArgumentException(\"Cannot bind object to itself\");\n+\n+        Object c1 = unwrapObservableCollection(target, collectionType);\n+        Object c2 = unwrapObservableCollection(source, collectionType);\n+\n+        if (c1 != null && c1 == c2) {\n+            throw new IllegalArgumentException(CANNOT_BIND_COLLECTION_TO_ITSELF.getMessage(c1));\n+        }\n+    }\n+\n+    private static boolean isContentBound(Object c) {\n+        return c instanceof ReadOnlyListProperty<?> && ((ReadOnlyListProperty<?>)c).isContentBound()\n+            || c instanceof ReadOnlySetProperty<?> && ((ReadOnlySetProperty<?>)c).isContentBound()\n+            || c instanceof ReadOnlyMapProperty<?, ?> && ((ReadOnlyMapProperty<?, ?>)c).isContentBound();\n+    }\n+\n+    private static Object unwrapObservableCollection(Object property, Class<?> collectionType) {\n+        while (property != null) {\n+            if (property instanceof ReadOnlyProperty<?>) {\n+                property = ((ReadOnlyProperty<?>)property).getValue();\n+            } else {\n+                return collectionType.isInstance(property) ? property : null;\n+            }\n@@ -46,0 +101,2 @@\n+\n+        return null;\n@@ -48,6 +105,8 @@\n-    public static <E> Object bind(ObservableList<E> list1, ObservableList<E> list2) {\n-        checkParameters(list1, list2);\n-        final ListContentBinding<E> binding = new ListContentBinding<E>(list1, list2);\n-        list1.setAll(list2);\n-        list1.addListener(binding);\n-        list2.addListener(binding);\n+    public static <E> Object bind(ObservableList<E> target, ObservableList<E> source) {\n+        checkParameters(target, source, ObservableList.class);\n+        final ListContentBinding<E> binding = new ListContentBinding<>(target, source);\n+        target.removeListener(binding);\n+        source.removeListener(binding);\n+        target.setAll(source);\n+        target.addListener(binding);\n+        source.addListener(binding);\n@@ -57,7 +116,9 @@\n-    public static <E> Object bind(ObservableSet<E> set1, ObservableSet<E> set2) {\n-        checkParameters(set1, set2);\n-        final SetContentBinding<E> binding = new SetContentBinding<E>(set1, set2);\n-        set1.clear();\n-        set1.addAll(set2);\n-        set1.addListener(binding);\n-        set2.addListener(binding);\n+    public static <E> Object bind(ObservableSet<E> target, ObservableSet<E> source) {\n+        checkParameters(target, source, ObservableSet.class);\n+        final SetContentBinding<E> binding = new SetContentBinding<>(target, source);\n+        target.removeListener(binding);\n+        source.removeListener(binding);\n+        target.clear();\n+        target.addAll(source);\n+        target.addListener(binding);\n+        source.addListener(binding);\n@@ -67,7 +128,9 @@\n-    public static <K, V> Object bind(ObservableMap<K, V> map1, ObservableMap<K, V> map2) {\n-        checkParameters(map1, map2);\n-        final MapContentBinding<K, V> binding = new MapContentBinding<K, V>(map1, map2);\n-        map1.clear();\n-        map1.putAll(map2);\n-        map1.addListener(binding);\n-        map2.addListener(binding);\n+    public static <K, V> Object bind(ObservableMap<K, V> target, ObservableMap<K, V> source) {\n+        checkParameters(target, source, ObservableMap.class);\n+        final MapContentBinding<K, V> binding = new MapContentBinding<>(target, source);\n+        target.removeListener(binding);\n+        source.removeListener(binding);\n+        target.clear();\n+        target.putAll(source);\n+        target.addListener(binding);\n+        source.addListener(binding);\n@@ -77,21 +140,19 @@\n-    public static void unbind(Object obj1, Object obj2) {\n-        checkParameters(obj1, obj2);\n-        if ((obj1 instanceof ObservableList) && (obj2 instanceof ObservableList)) {\n-            final ObservableList list1 = (ObservableList)obj1;\n-            final ObservableList list2 = (ObservableList)obj2;\n-            final ListContentBinding binding = new ListContentBinding(list1, list2);\n-            list1.removeListener(binding);\n-            list2.removeListener(binding);\n-        } else if ((obj1 instanceof ObservableSet) && (obj2 instanceof ObservableSet)) {\n-            final ObservableSet set1 = (ObservableSet)obj1;\n-            final ObservableSet set2 = (ObservableSet)obj2;\n-            final SetContentBinding binding = new SetContentBinding(set1, set2);\n-            set1.removeListener(binding);\n-            set2.removeListener(binding);\n-        } else if ((obj1 instanceof ObservableMap) && (obj2 instanceof ObservableMap)) {\n-            final ObservableMap map1 = (ObservableMap)obj1;\n-            final ObservableMap map2 = (ObservableMap)obj2;\n-            final MapContentBinding binding = new MapContentBinding(map1, map2);\n-            map1.removeListener(binding);\n-            map2.removeListener(binding);\n-        }\n+    public static <E> void unbind(ObservableList<E> target, ObservableList<E> source) {\n+        checkParameters(target, source, ObservableList.class);\n+        final ListContentBinding<E> binding = new ListContentBinding<>(target, source);\n+        target.removeListener(binding);\n+        source.removeListener(binding);\n+    }\n+\n+    public static <E> void unbind(ObservableSet<E> target, ObservableSet<E> source) {\n+        checkParameters(target, source, ObservableSet.class);\n+        final SetContentBinding<E> binding = new SetContentBinding<>(target, source);\n+        target.removeListener(binding);\n+        source.removeListener(binding);\n+    }\n+\n+    public static <K, V> void unbind(ObservableMap<K, V> target, ObservableMap<K, V> source) {\n+        checkParameters(target, source, ObservableMap.class);\n+        final MapContentBinding<K, V> binding = new MapContentBinding<>(target, source);\n+        target.removeListener(binding);\n+        source.removeListener(binding);\n@@ -100,1 +161,2 @@\n-    private static class ListContentBinding<E> implements ListChangeListener<E>, WeakListener {\n+    private static class ListContentBinding<E>\n+            extends BidirectionalContentBinding implements ListChangeListener<E> {\n@@ -194,1 +256,2 @@\n-    private static class SetContentBinding<E> implements SetChangeListener<E>, WeakListener {\n+    private static class SetContentBinding<E>\n+            extends BidirectionalContentBinding implements SetChangeListener<E> {\n@@ -280,1 +343,2 @@\n-    private static class MapContentBinding<K, V> implements MapChangeListener<K, V>, WeakListener {\n+    private static class MapContentBinding<K, V>\n+            extends BidirectionalContentBinding implements MapChangeListener<K, V> {\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/BidirectionalContentBinding.java","additions":118,"deletions":54,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.binding;\n+\n+public abstract class CollectionExpressionHelperBase extends ExpressionHelperBase {\n+\n+    public static ContentBinding getContentBinding(CollectionExpressionHelperBase helper) {\n+        return helper != null ? helper.getContentBinding() : null;\n+    }\n+\n+    public static boolean isContentBoundBidirectional(CollectionExpressionHelperBase helper) {\n+        return helper != null && helper.isContentBoundBidirectional();\n+    }\n+\n+    protected abstract ContentBinding getContentBinding();\n+\n+    protected abstract boolean isContentBoundBidirectional();\n+\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/CollectionExpressionHelperBase.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import javafx.beans.property.ReadOnlyProperty;\n@@ -36,3 +37,16 @@\n-\/**\n- *\/\n-public class ContentBinding {\n+import static com.sun.javafx.beans.BeanErrors.*;\n+\n+public abstract class ContentBinding implements WeakListener {\n+\n+    private static void checkBindParameters(\n+            Object target, Object source, Class<?> collectionType, CollectionExpressionHelperBase helper) {\n+        if (target == null) {\n+            throw new NullPointerException(BINDING_TARGET_NULL.getMessage());\n+        }\n+\n+        if (source == null) {\n+            throw new NullPointerException(BINDING_SOURCE_NULL.getMessage(target));\n+        }\n+\n+        Object c1 = unwrapObservableCollection(target, collectionType);\n+        Object c2 = unwrapObservableCollection(source, collectionType);\n@@ -40,3 +54,2 @@\n-    private static void checkParameters(Object property1, Object property2) {\n-        if ((property1 == null) || (property2 == null)) {\n-            throw new NullPointerException(\"Both parameters must be specified.\");\n+        if (c1 != null && c1 == c2) {\n+            throw new IllegalArgumentException(CANNOT_BIND_COLLECTION_TO_ITSELF.getMessage(target));\n@@ -44,2 +57,27 @@\n-        if (property1 == property2) {\n-            throw new IllegalArgumentException(\"Cannot bind object to itself\");\n+\n+        if (CollectionExpressionHelperBase.isContentBoundBidirectional(helper)) {\n+            throw new IllegalStateException(CONTENT_BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target));\n+        }\n+    }\n+\n+    private static void checkUnbindParameters(Object target, Object source) {\n+        if (target == null) {\n+            throw new NullPointerException(BINDING_TARGET_NULL.getMessage());\n+        }\n+\n+        if (source == null) {\n+            throw new NullPointerException(BINDING_SOURCE_NULL.getMessage(target));\n+        }\n+\n+        if (target == source) {\n+            throw new IllegalArgumentException(CANNOT_UNBIND_COLLECTION_FROM_ITSELF.getMessage(target));\n+        }\n+    }\n+\n+    private static Object unwrapObservableCollection(Object property, Class<?> collectionType) {\n+        while (property != null) {\n+            if (property instanceof ReadOnlyProperty<?>) {\n+                property = ((ReadOnlyProperty<?>)property).getValue();\n+            } else {\n+                return collectionType.isInstance(property) ? property : null;\n+            }\n@@ -47,0 +85,2 @@\n+\n+        return null;\n@@ -50,2 +90,8 @@\n-        checkParameters(list1, list2);\n-        final ListContentBinding<E> contentBinding = new ListContentBinding<E>(list1);\n+        return bind(list1, list2, null);\n+    }\n+\n+    public static <E> Object bind(\n+            List<E> list1, ObservableList<? extends E> list2, CollectionExpressionHelperBase helper) {\n+        checkBindParameters(list1, list2, ObservableList.class, helper);\n+\n+        final ListContentBinding<E> contentBinding = new ListContentBinding<>(list1, list2);\n@@ -53,1 +99,2 @@\n-            ((ObservableList) list1).setAll(list2);\n+            ((ObservableList<E>)list1).removeListener(contentBinding);\n+            ((ObservableList<E>)list1).setAll(list2);\n@@ -58,0 +105,1 @@\n+\n@@ -60,0 +108,5 @@\n+\n+        if (list1 instanceof ObservableList<?>) {\n+            ((ObservableList<E>)list1).addListener(contentBinding);\n+        }\n+\n@@ -64,2 +117,13 @@\n-        checkParameters(set1, set2);\n-        final SetContentBinding<E> contentBinding = new SetContentBinding<E>(set1);\n+        return bind(set1, set2, null);\n+    }\n+\n+    public static <E> Object bind(\n+            Set<E> set1, ObservableSet<? extends E> set2, CollectionExpressionHelperBase helper) {\n+        checkBindParameters(set1, set2, ObservableSet.class, helper);\n+\n+        final SetContentBinding<E> contentBinding = new SetContentBinding<>(set1, set2);\n+        if (set1 instanceof ObservableSet<?>) {\n+            ((ObservableSet<E>)set1).removeListener(contentBinding);\n+        }\n+\n+        set2.removeListener(contentBinding);\n@@ -68,1 +132,0 @@\n-        set2.removeListener(contentBinding);\n@@ -70,0 +133,5 @@\n+\n+        if (set1 instanceof ObservableSet<?>) {\n+            ((ObservableSet<E>)set1).addListener(contentBinding);\n+        }\n+\n@@ -74,2 +142,13 @@\n-        checkParameters(map1, map2);\n-        final MapContentBinding<K, V> contentBinding = new MapContentBinding<K, V>(map1);\n+        return bind(map1, map2, null);\n+    }\n+\n+    public static <K, V> Object bind(\n+            Map<K, V> map1, ObservableMap<? extends K, ? extends V> map2, CollectionExpressionHelperBase helper) {\n+        checkBindParameters(map1, map2, ObservableMap.class, helper);\n+\n+        final MapContentBinding<K, V> contentBinding = new MapContentBinding<>(map1, map2);\n+        if (map1 instanceof ObservableMap<?, ?>) {\n+            ((ObservableMap<? extends K, ? extends V>)map1).removeListener(contentBinding);\n+        }\n+\n+        map2.removeListener(contentBinding);\n@@ -78,1 +157,0 @@\n-        map2.removeListener(contentBinding);\n@@ -80,0 +158,5 @@\n+\n+        if (map1 instanceof ObservableMap<?, ?>) {\n+            ((ObservableMap<? extends K, ? extends V>)map1).addListener(contentBinding);\n+        }\n+\n@@ -83,8 +166,8 @@\n-    public static void unbind(Object obj1, Object obj2) {\n-        checkParameters(obj1, obj2);\n-        if ((obj1 instanceof List) && (obj2 instanceof ObservableList)) {\n-            ((ObservableList)obj2).removeListener(new ListContentBinding((List)obj1));\n-        } else if ((obj1 instanceof Set) && (obj2 instanceof ObservableSet)) {\n-            ((ObservableSet)obj2).removeListener(new SetContentBinding((Set)obj1));\n-        } else if ((obj1 instanceof Map) && (obj2 instanceof ObservableMap)) {\n-            ((ObservableMap)obj2).removeListener(new MapContentBinding((Map)obj1));\n+    public static <E> void unbind(List<E> obj1, ObservableList<? extends E> obj2) {\n+        checkUnbindParameters(obj1, obj2);\n+\n+        var binding = new ListContentBinding<>(obj1, obj2);\n+        obj2.removeListener(binding);\n+\n+        if (obj1 instanceof ObservableList<?>) {\n+            ((ObservableList<? extends E>)obj1).removeListener(binding);\n@@ -94,1 +177,2 @@\n-    private static class ListContentBinding<E> implements ListChangeListener<E>, WeakListener {\n+    public static <E> void unbind(Set<E> obj1, ObservableSet<? extends E> obj2) {\n+        checkUnbindParameters(obj1, obj2);\n@@ -96,1 +180,2 @@\n-        private final WeakReference<List<E>> listRef;\n+        var binding = new SetContentBinding<>(obj1, obj2);\n+        obj2.removeListener(binding);\n@@ -98,2 +183,31 @@\n-        public ListContentBinding(List<E> list) {\n-            this.listRef = new WeakReference<List<E>>(list);\n+        if (obj1 instanceof ObservableSet<?>) {\n+            ((ObservableSet<? extends E>)obj1).removeListener(binding);\n+        }\n+    }\n+\n+    public static <K, V> void unbind(Map<K, V> obj1, ObservableMap<? extends K, ? extends V> obj2) {\n+        checkUnbindParameters(obj1, obj2);\n+\n+        var binding = new MapContentBinding<>(obj1, obj2);\n+        obj2.removeListener(binding);\n+\n+        if (obj1 instanceof ObservableMap<?, ?>) {\n+            ((ObservableMap<? extends K, ? extends V>)obj1).removeListener(binding);\n+        }\n+    }\n+\n+    \/**\n+     * Returns whether the specified object is the target of the content binding (as opposed to the source).\n+     *\/\n+    public abstract boolean isTarget(Object obj);\n+\n+    public abstract void dispose();\n+\n+    private static class ListContentBinding<E> extends ContentBinding implements ListChangeListener<E> {\n+        private final WeakReference<List<E>> list1;\n+        private final WeakReference<ObservableList<? extends E>> list2;\n+        private boolean updating;\n+\n+        public ListContentBinding(List<E> list1, ObservableList<? extends E> list2) {\n+            this.list1 = new WeakReference<>(list1);\n+            this.list2 = new WeakReference<>(list2);\n@@ -104,2 +218,21 @@\n-            final List<E> list = listRef.get();\n-            if (list == null) {\n+            if (updating) {\n+                return;\n+            }\n+\n+            final List<E> list1 = this.list1.get();\n+\n+            \/\/ If the change is originating from list1 (which is the bound list), the change is an\n+            \/\/ illegal list modification. Since the content binding is now in an undefined state, the\n+            \/\/ only thing we can do is to error out and remove the binding.\n+            if (change.getList() == list1) {\n+                ((ObservableList<E>)list1).removeListener(this);\n+\n+                ObservableList<? extends E> list2 = this.list2.get();\n+                if (list2 != null) {\n+                    list2.removeListener(this);\n+                }\n+\n+                throw new RuntimeException(ILLEGAL_LIST_MODIFICATION.getMessage());\n+            }\n+\n+            if (list1 == null) {\n@@ -108,10 +241,14 @@\n-                while (change.next()) {\n-                    if (change.wasPermutated()) {\n-                        list.subList(change.getFrom(), change.getTo()).clear();\n-                        list.addAll(change.getFrom(), change.getList().subList(change.getFrom(), change.getTo()));\n-                    } else {\n-                        if (change.wasRemoved()) {\n-                            list.subList(change.getFrom(), change.getFrom() + change.getRemovedSize()).clear();\n-                        }\n-                        if (change.wasAdded()) {\n-                            list.addAll(change.getFrom(), change.getAddedSubList());\n+                try {\n+                    updating = true;\n+\n+                    while (change.next()) {\n+                        if (change.wasPermutated()) {\n+                            list1.subList(change.getFrom(), change.getTo()).clear();\n+                            list1.addAll(change.getFrom(), change.getList().subList(change.getFrom(), change.getTo()));\n+                        } else {\n+                            if (change.wasRemoved()) {\n+                                list1.subList(change.getFrom(), change.getFrom() + change.getRemovedSize()).clear();\n+                            }\n+                            if (change.wasAdded()) {\n+                                list1.addAll(change.getFrom(), change.getAddedSubList());\n+                            }\n@@ -120,0 +257,2 @@\n+                } finally {\n+                    updating = false;\n@@ -124,0 +263,19 @@\n+        @Override\n+        public boolean isTarget(Object obj) {\n+            return obj != null && obj == list1.get();\n+        }\n+\n+        @Override\n+        public void dispose() {\n+            List<E> list1 = this.list1.get();\n+            ObservableList<? extends E> list2 = this.list2.get();\n+\n+            if (list1 instanceof ObservableList<?>) {\n+                ((ObservableList<E>)list1).removeListener(this);\n+            }\n+\n+            if (list2 != null) {\n+                list2.removeListener(this);\n+            }\n+        }\n+\n@@ -126,1 +284,1 @@\n-            return listRef.get() == null;\n+            return list1.get() == null || list2.get() == null;\n@@ -131,2 +289,5 @@\n-            final List<E> list = listRef.get();\n-            return (list == null)? 0 : list.hashCode();\n+            final List<E> list1 = this.list1.get();\n+            final ObservableList<? extends E> list2 = this.list2.get();\n+            final int hc1 = (list1 == null) ? 0 : list1.hashCode();\n+            final int hc2 = (list2 == null) ? 0 : list2.hashCode();\n+            return hc1 * hc2;\n@@ -141,2 +302,3 @@\n-            final List<E> list1 = listRef.get();\n-            if (list1 == null) {\n+            final Object listA1 = list1.get();\n+            final Object listA2 = list2.get();\n+            if ((listA1 == null) || (listA2 == null)) {\n@@ -147,3 +309,14 @@\n-                final ListContentBinding<?> other = (ListContentBinding<?>) obj;\n-                final List<?> list2 = other.listRef.get();\n-                return list1 == list2;\n+                final ListContentBinding<?> otherBinding = (ListContentBinding<?>)obj;\n+                final Object listB1 = otherBinding.list1.get();\n+                final Object listB2 = otherBinding.list2.get();\n+                if ((listB1 == null) || (listB2 == null)) {\n+                    return false;\n+                }\n+\n+                if ((listA1 == listB1) && (listA2 == listB2)) {\n+                    return true;\n+                }\n+\n+                if ((listA1 == listB2) && (listA2 == listB1)) {\n+                    return true;\n+                }\n@@ -151,0 +324,1 @@\n+\n@@ -155,3 +329,4 @@\n-    private static class SetContentBinding<E> implements SetChangeListener<E>, WeakListener {\n-\n-        private final WeakReference<Set<E>> setRef;\n+    private static class SetContentBinding<E> extends ContentBinding implements SetChangeListener<E> {\n+        private final WeakReference<Set<E>> set1;\n+        private final WeakReference<ObservableSet<? extends E>> set2;\n+        private boolean updating;\n@@ -159,2 +334,3 @@\n-        public SetContentBinding(Set<E> set) {\n-            this.setRef = new WeakReference<Set<E>>(set);\n+        public SetContentBinding(Set<E> set1, ObservableSet<? extends E> set2) {\n+            this.set1 = new WeakReference<>(set1);\n+            this.set2 = new WeakReference<>(set2);\n@@ -165,2 +341,21 @@\n-            final Set<E> set = setRef.get();\n-            if (set == null) {\n+            if (updating) {\n+                return;\n+            }\n+\n+            final Set<E> set1 = this.set1.get();\n+\n+            \/\/ If the change is originating from set1 (which is the bound set), the change is an\n+            \/\/ illegal set modification. Since the content binding is now in an undefined state, the\n+            \/\/ only thing we can do is to error out and remove the binding.\n+            if (change.getSet() == set1) {\n+                ((ObservableSet<E>)set1).removeListener(this);\n+\n+                ObservableSet<? extends E> set2 = this.set2.get();\n+                if (set2 != null) {\n+                    set2.removeListener(this);\n+                }\n+\n+                throw new RuntimeException(ILLEGAL_SET_MODIFICATION.getMessage());\n+            }\n+\n+            if (set1 == null) {\n@@ -169,4 +364,10 @@\n-                if (change.wasRemoved()) {\n-                    set.remove(change.getElementRemoved());\n-                } else {\n-                    set.add(change.getElementAdded());\n+                try {\n+                    updating = true;\n+\n+                    if (change.wasRemoved()) {\n+                        set1.remove(change.getElementRemoved());\n+                    } else {\n+                        set1.add(change.getElementAdded());\n+                    }\n+                } finally {\n+                    updating = false;\n@@ -177,0 +378,19 @@\n+        @Override\n+        public boolean isTarget(Object obj) {\n+            return obj != null && obj == set1.get();\n+        }\n+\n+        @Override\n+        public void dispose() {\n+            Set<E> set1 = this.set1.get();\n+            ObservableSet<? extends E> set2 = this.set2.get();\n+\n+            if (set1 instanceof ObservableSet<?>) {\n+                ((ObservableSet<E>)set1).removeListener(this);\n+            }\n+\n+            if (set2 != null) {\n+                set2.removeListener(this);\n+            }\n+        }\n+\n@@ -179,1 +399,1 @@\n-            return setRef.get() == null;\n+            return set1.get() == null || set2.get() == null;\n@@ -184,2 +404,5 @@\n-            final Set<E> set = setRef.get();\n-            return (set == null)? 0 : set.hashCode();\n+            final Set<E> set1 = this.set1.get();\n+            final ObservableSet<? extends E> set2 = this.set2.get();\n+            final int hc1 = (set1 == null) ? 0 : set1.hashCode();\n+            final int hc2 = (set2 == null) ? 0 : set2.hashCode();\n+            return hc1 * hc2;\n@@ -194,2 +417,3 @@\n-            final Set<E> set1 = setRef.get();\n-            if (set1 == null) {\n+            final Object setA1 = set1.get();\n+            final Object setA2 = set2.get();\n+            if ((setA1 == null) || (setA2 == null)) {\n@@ -200,3 +424,14 @@\n-                final SetContentBinding<?> other = (SetContentBinding<?>) obj;\n-                final Set<?> set2 = other.setRef.get();\n-                return set1 == set2;\n+                final SetContentBinding<?> otherBinding = (SetContentBinding<?>)obj;\n+                final Object setB1 = otherBinding.set1.get();\n+                final Object setB2 = otherBinding.set2.get();\n+                if ((setB1 == null) || (setB2 == null)) {\n+                    return false;\n+                }\n+\n+                if ((setA1 == setB1) && (setA2 == setB2)) {\n+                    return true;\n+                }\n+\n+                if ((setA1 == setB2) && (setA2 == setB1)) {\n+                    return true;\n+                }\n@@ -204,0 +439,1 @@\n+\n@@ -208,3 +444,4 @@\n-    private static class MapContentBinding<K, V> implements MapChangeListener<K, V>, WeakListener {\n-\n-        private final WeakReference<Map<K, V>> mapRef;\n+    private static class MapContentBinding<K, V> extends ContentBinding implements MapChangeListener<K, V> {\n+        private final WeakReference<Map<K, V>> map1;\n+        private final WeakReference<ObservableMap<? extends K, ? extends V>> map2;\n+        private boolean updating;\n@@ -212,2 +449,3 @@\n-        public MapContentBinding(Map<K, V> map) {\n-            this.mapRef = new WeakReference<Map<K, V>>(map);\n+        public MapContentBinding(Map<K, V> map1, ObservableMap<? extends K, ? extends V> map2) {\n+            this.map1 = new WeakReference<>(map1);\n+            this.map2 = new WeakReference<>(map2);\n@@ -218,2 +456,21 @@\n-            final Map<K, V> map = mapRef.get();\n-            if (map == null) {\n+            if (updating) {\n+                return;\n+            }\n+\n+            final Map<K, V> map1 = this.map1.get();\n+\n+            \/\/ If the change is originating from map1 (which is the bound map), the change is an\n+            \/\/ illegal map modification. Since the content binding is now in an undefined state, the\n+            \/\/ only thing we can do is to error out and remove the binding.\n+            if (change.getMap() == map1) {\n+                ((ObservableMap<? extends K, ? extends V>)map1).removeListener(this);\n+\n+                ObservableMap<? extends K, ? extends V> map2 = this.map2.get();\n+                if (map2 != null) {\n+                    map2.removeListener(this);\n+                }\n+\n+                throw new RuntimeException(ILLEGAL_MAP_MODIFICATION.getMessage());\n+            }\n+\n+            if (map1 == null) {\n@@ -222,5 +479,11 @@\n-                if (change.wasRemoved()) {\n-                    map.remove(change.getKey());\n-                }\n-                if (change.wasAdded()) {\n-                    map.put(change.getKey(), change.getValueAdded());\n+                try {\n+                    updating = true;\n+\n+                    if (change.wasRemoved()) {\n+                        map1.remove(change.getKey());\n+                    }\n+                    if (change.wasAdded()) {\n+                        map1.put(change.getKey(), change.getValueAdded());\n+                    }\n+                } finally {\n+                    updating = false;\n@@ -231,0 +494,19 @@\n+        @Override\n+        public boolean isTarget(Object obj) {\n+            return obj != null && obj == map1.get();\n+        }\n+\n+        @Override\n+        public void dispose() {\n+            Map<K, V> map1 = this.map1.get();\n+            ObservableMap<? extends K, ? extends V> map2 = this.map2.get();\n+\n+            if (map1 instanceof ObservableMap<?, ?>) {\n+                ((ObservableMap<? extends K, ? extends V>)map1).removeListener(this);\n+            }\n+\n+            if (map2 != null) {\n+                map2.removeListener(this);\n+            }\n+        }\n+\n@@ -233,1 +515,1 @@\n-            return mapRef.get() == null;\n+            return map1.get() == null || map2.get() == null;\n@@ -238,2 +520,5 @@\n-            final Map<K, V> map = mapRef.get();\n-            return (map == null)? 0 : map.hashCode();\n+            final Map<K, V> map1 = this.map1.get();\n+            final ObservableMap<? extends K, ? extends V> map2 = this.map2.get();\n+            final int hc1 = (map1 == null) ? 0 : map1.hashCode();\n+            final int hc2 = (map2 == null) ? 0 : map2.hashCode();\n+            return hc1 * hc2;\n@@ -248,2 +533,3 @@\n-            final Map<K, V> map1 = mapRef.get();\n-            if (map1 == null) {\n+            final Object mapA1 = map1.get();\n+            final Object mapA2 = map2.get();\n+            if ((mapA1 == null) || (mapA2 == null)) {\n@@ -254,3 +540,14 @@\n-                final MapContentBinding<?, ?> other = (MapContentBinding<?, ?>) obj;\n-                final Map<?, ?> map2 = other.mapRef.get();\n-                return map1 == map2;\n+                final MapContentBinding<?, ?> otherBinding = (MapContentBinding<?, ?>)obj;\n+                final Object mapB1 = otherBinding.map1.get();\n+                final Object mapB2 = otherBinding.map2.get();\n+                if ((mapB1 == null) || (mapB2 == null)) {\n+                    return false;\n+                }\n+\n+                if ((mapA1 == mapB1) && (mapA2 == mapB2)) {\n+                    return true;\n+                }\n+\n+                if ((mapA1 == mapB2) && (mapA2 == mapB1)) {\n+                    return true;\n+                }\n@@ -258,0 +555,1 @@\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ContentBinding.java","additions":387,"deletions":89,"binary":false,"changes":476,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.WeakListenerArrayUtil;\n@@ -133,0 +134,5 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            return listener instanceof BidirectionalBinding;\n+        }\n+\n@@ -174,0 +180,5 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            return false;\n+        }\n+\n@@ -231,1 +242,1 @@\n-                    invalidationSize = trim(invalidationSize, invalidationListeners);\n+                    invalidationSize = WeakListenerArrayUtil.trim(invalidationSize, invalidationListeners);\n@@ -288,1 +299,1 @@\n-                    changeSize = trim(changeSize, changeListeners);\n+                    changeSize = WeakListenerArrayUtil.trim(changeSize, changeListeners);\n@@ -337,0 +348,11 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            for (int i = 0; i < invalidationSize; ++i) {\n+                if (invalidationListeners[i] instanceof BidirectionalBinding) {\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ExpressionHelper.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-import java.util.function.Predicate;\n-import javafx.beans.WeakListener;\n+public abstract class ExpressionHelperBase {\n@@ -31,22 +30,3 @@\n-public class ExpressionHelperBase {\n-\n-    protected static int trim(int size, Object[] listeners) {\n-        Predicate<Object> p = t -> t instanceof WeakListener &&\n-                ((WeakListener)t).wasGarbageCollected();\n-        int index = 0;\n-        for (; index < size; index++) {\n-            if (p.test(listeners[index])) {\n-                break;\n-            }\n-        }\n-        if (index < size) {\n-            for (int src = index + 1; src < size; src++) {\n-                if (!p.test(listeners[src])) {\n-                    listeners[index++] = listeners[src];\n-                }\n-            }\n-            int oldSize = size;\n-            size = index;\n-            for (; index < oldSize; index++) {\n-                listeners[index] = null;\n-            }\n+    public static void fireValueChangedEvent(ExpressionHelperBase helper) {\n+        if (helper != null) {\n+            helper.fireValueChangedEvent();\n@@ -54,0 +34,1 @@\n+    }\n@@ -55,1 +36,2 @@\n-        return size;\n+    public static boolean isBoundBidirectional(ExpressionHelperBase helper) {\n+        return helper != null && helper.isBoundBidirectional();\n@@ -58,0 +40,4 @@\n+    protected abstract boolean isBoundBidirectional();\n+\n+    protected abstract void fireValueChangedEvent();\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ExpressionHelperBase.java","additions":12,"deletions":26,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.WeakListenerArrayUtil;\n@@ -38,1 +39,0 @@\n-import java.util.List;\n@@ -52,1 +52,1 @@\n-public abstract class ListExpressionHelper<E> extends ExpressionHelperBase {\n+public abstract class ListExpressionHelper<E> extends CollectionExpressionHelperBase {\n@@ -101,6 +101,0 @@\n-    public static <E> void fireValueChangedEvent(ListExpressionHelper<E> helper) {\n-        if (helper != null) {\n-            helper.fireValueChangedEvent();\n-        }\n-    }\n-\n@@ -131,1 +125,0 @@\n-    protected abstract void fireValueChangedEvent();\n@@ -176,0 +169,15 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            return listener instanceof BidirectionalBinding;\n+        }\n+\n+        @Override\n+        protected ContentBinding getContentBinding() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected boolean isContentBoundBidirectional() {\n+            return false;\n+        }\n+\n@@ -228,0 +236,15 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            return false;\n+        }\n+\n+        @Override\n+        protected ContentBinding getContentBinding() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected boolean isContentBoundBidirectional() {\n+            return false;\n+        }\n+\n@@ -284,0 +307,15 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            return false;\n+        }\n+\n+        @Override\n+        protected ContentBinding getContentBinding() {\n+            return listener instanceof ContentBinding ? (ContentBinding)listener : null;\n+        }\n+\n+        @Override\n+        protected boolean isContentBoundBidirectional() {\n+            return listener instanceof BidirectionalContentBinding;\n+        }\n+\n@@ -373,1 +411,1 @@\n-                    invalidationSize = trim(invalidationSize, invalidationListeners);\n+                    invalidationSize = WeakListenerArrayUtil.trim(invalidationSize, invalidationListeners);\n@@ -432,1 +470,1 @@\n-                    changeSize = trim(changeSize, changeListeners);\n+                    changeSize = WeakListenerArrayUtil.trim(changeSize, changeListeners);\n@@ -494,1 +532,1 @@\n-                    listChangeSize = trim(listChangeSize, listChangeListeners);\n+                    listChangeSize = WeakListenerArrayUtil.trim(listChangeSize, listChangeListeners);\n@@ -545,0 +583,33 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            for (int i = 0; i < invalidationSize; ++i) {\n+                if (invalidationListeners[i] instanceof BidirectionalBinding) {\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        @Override\n+        protected ContentBinding getContentBinding() {\n+            for (int i = 0; i < listChangeSize; ++i) {\n+                if (listChangeListeners[i] instanceof ContentBinding) {\n+                    return (ContentBinding)listChangeListeners[i];\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        @Override\n+        protected boolean isContentBoundBidirectional() {\n+            for (int i = 0; i < listChangeSize; ++i) {\n+                if (listChangeListeners[i] instanceof BidirectionalContentBinding) {\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/ListExpressionHelper.java","additions":84,"deletions":13,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.WeakListenerArrayUtil;\n@@ -39,1 +40,1 @@\n-public abstract class MapExpressionHelper<K, V> extends ExpressionHelperBase {\n+public abstract class MapExpressionHelper<K, V> extends CollectionExpressionHelperBase {\n@@ -87,6 +88,0 @@\n-    public static <K, V> void fireValueChangedEvent(MapExpressionHelper<K, V> helper) {\n-        if (helper != null) {\n-            helper.fireValueChangedEvent();\n-        }\n-    }\n-\n@@ -117,1 +112,0 @@\n-    protected abstract void fireValueChangedEvent();\n@@ -162,0 +156,15 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            return listener instanceof BidirectionalBinding;\n+        }\n+\n+        @Override\n+        protected ContentBinding getContentBinding() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected boolean isContentBoundBidirectional() {\n+            return false;\n+        }\n+\n@@ -214,0 +223,15 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            return false;\n+        }\n+\n+        @Override\n+        protected ContentBinding getContentBinding() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected boolean isContentBoundBidirectional() {\n+            return false;\n+        }\n+\n@@ -270,0 +294,15 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            return false;\n+        }\n+\n+        @Override\n+        protected ContentBinding getContentBinding() {\n+            return listener instanceof ContentBinding ? (ContentBinding)listener : null;\n+        }\n+\n+        @Override\n+        protected boolean isContentBoundBidirectional() {\n+            return listener instanceof BidirectionalContentBinding;\n+        }\n+\n@@ -382,1 +421,1 @@\n-                    invalidationSize = trim(invalidationSize, invalidationListeners);\n+                    invalidationSize = WeakListenerArrayUtil.trim(invalidationSize, invalidationListeners);\n@@ -441,1 +480,1 @@\n-                    changeSize = trim(changeSize, changeListeners);\n+                    changeSize = WeakListenerArrayUtil.trim(changeSize, changeListeners);\n@@ -503,1 +542,1 @@\n-                    mapChangeSize = trim(mapChangeSize, mapChangeListeners);\n+                    mapChangeSize = WeakListenerArrayUtil.trim(mapChangeSize, mapChangeListeners);\n@@ -554,0 +593,33 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            for (int i = 0; i < invalidationSize; ++i) {\n+                if (invalidationListeners[i] instanceof BidirectionalBinding) {\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        @Override\n+        protected ContentBinding getContentBinding() {\n+            for (int i = 0; i < mapChangeSize; ++i) {\n+                if (mapChangeListeners[i] instanceof ContentBinding) {\n+                    return (ContentBinding)mapChangeListeners[i];\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        @Override\n+        protected boolean isContentBoundBidirectional() {\n+            for (int i = 0; i < mapChangeSize; ++i) {\n+                if (mapChangeListeners[i] instanceof BidirectionalContentBinding) {\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/MapExpressionHelper.java","additions":84,"deletions":12,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.WeakListenerArrayUtil;\n@@ -38,1 +39,1 @@\n-public abstract class SetExpressionHelper<E> extends ExpressionHelperBase {\n+public abstract class SetExpressionHelper<E> extends CollectionExpressionHelperBase {\n@@ -86,6 +87,0 @@\n-    public static <E> void fireValueChangedEvent(SetExpressionHelper<E> helper) {\n-        if (helper != null) {\n-            helper.fireValueChangedEvent();\n-        }\n-    }\n-\n@@ -116,1 +111,0 @@\n-    protected abstract void fireValueChangedEvent();\n@@ -161,0 +155,15 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            return listener instanceof BidirectionalBinding;\n+        }\n+\n+        @Override\n+        protected ContentBinding getContentBinding() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected boolean isContentBoundBidirectional() {\n+            return false;\n+        }\n+\n@@ -213,0 +222,15 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            return false;\n+        }\n+\n+        @Override\n+        protected ContentBinding getContentBinding() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected boolean isContentBoundBidirectional() {\n+            return false;\n+        }\n+\n@@ -269,0 +293,15 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            return false;\n+        }\n+\n+        @Override\n+        protected ContentBinding getContentBinding() {\n+            return listener instanceof ContentBinding ? (ContentBinding)listener : null;\n+        }\n+\n+        @Override\n+        protected boolean isContentBoundBidirectional() {\n+            return listener instanceof BidirectionalContentBinding;\n+        }\n+\n@@ -373,1 +412,1 @@\n-                    invalidationSize = trim(invalidationSize, invalidationListeners);\n+                    invalidationSize = WeakListenerArrayUtil.trim(invalidationSize, invalidationListeners);\n@@ -432,1 +471,1 @@\n-                    changeSize = trim(changeSize, changeListeners);\n+                    changeSize = WeakListenerArrayUtil.trim(changeSize, changeListeners);\n@@ -494,1 +533,1 @@\n-                    setChangeSize = trim(setChangeSize, setChangeListeners);\n+                    setChangeSize = WeakListenerArrayUtil.trim(setChangeSize, setChangeListeners);\n@@ -545,0 +584,33 @@\n+        @Override\n+        protected boolean isBoundBidirectional() {\n+            for (int i = 0; i < invalidationSize; ++i) {\n+                if (invalidationListeners[i] instanceof BidirectionalBinding) {\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        @Override\n+        protected ContentBinding getContentBinding() {\n+            for (int i = 0; i < setChangeSize; ++i) {\n+                if (setChangeListeners[i] instanceof ContentBinding) {\n+                    return (ContentBinding)setChangeListeners[i];\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        @Override\n+        protected boolean isContentBoundBidirectional() {\n+            for (int i = 0; i < setChangeSize; ++i) {\n+                if (setChangeListeners[i] instanceof BidirectionalContentBinding) {\n+                    return true;\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/SetExpressionHelper.java","additions":84,"deletions":12,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n-import com.sun.javafx.binding.ExpressionHelperBase;\n-import java.util.Arrays;\n+import com.sun.javafx.WeakListenerArrayUtil;\n@@ -32,1 +31,0 @@\n-import com.sun.javafx.logging.PlatformLogger;\n@@ -34,3 +32,3 @@\n-\/**\n- *\/\n-public abstract class ArrayListenerHelper<T extends ObservableArray<T>> extends ExpressionHelperBase {\n+import java.util.Arrays;\n+\n+public abstract class ArrayListenerHelper<T extends ObservableArray<T>> {\n@@ -216,1 +214,1 @@\n-                    invalidationSize = trim(invalidationSize, invalidationListeners);\n+                    invalidationSize = WeakListenerArrayUtil.trim(invalidationSize, invalidationListeners);\n@@ -273,1 +271,1 @@\n-                    changeSize = trim(changeSize, changeListeners);\n+                    changeSize = WeakListenerArrayUtil.trim(changeSize, changeListeners);\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ArrayListenerHelper.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import com.sun.javafx.binding.ExpressionHelperBase;\n+import com.sun.javafx.WeakListenerArrayUtil;\n@@ -31,1 +31,0 @@\n-import com.sun.javafx.logging.PlatformLogger;\n@@ -35,3 +34,1 @@\n-\/**\n- *\/\n-public abstract class ListListenerHelper<E> extends ExpressionHelperBase {\n+public abstract class ListListenerHelper<E> {\n@@ -207,1 +204,1 @@\n-                    invalidationSize = trim(invalidationSize, invalidationListeners);\n+                    invalidationSize = WeakListenerArrayUtil.trim(invalidationSize, invalidationListeners);\n@@ -264,1 +261,1 @@\n-                    changeSize = trim(changeSize, changeListeners);\n+                    changeSize = WeakListenerArrayUtil.trim(changeSize, changeListeners);\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/ListListenerHelper.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import com.sun.javafx.binding.ExpressionHelperBase;\n+import com.sun.javafx.WeakListenerArrayUtil;\n@@ -31,1 +31,0 @@\n-import com.sun.javafx.logging.PlatformLogger;\n@@ -37,1 +36,1 @@\n-public abstract class MapListenerHelper<K, V> extends ExpressionHelperBase {\n+public abstract class MapListenerHelper<K, V> {\n@@ -206,1 +205,1 @@\n-                    invalidationSize = trim(invalidationSize, invalidationListeners);\n+                    invalidationSize = WeakListenerArrayUtil.trim(invalidationSize, invalidationListeners);\n@@ -263,1 +262,1 @@\n-                    changeSize = trim(changeSize, changeListeners);\n+                    changeSize = WeakListenerArrayUtil.trim(changeSize, changeListeners);\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/MapListenerHelper.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import com.sun.javafx.binding.ExpressionHelperBase;\n+import com.sun.javafx.WeakListenerArrayUtil;\n@@ -31,1 +31,0 @@\n-import com.sun.javafx.logging.PlatformLogger;\n@@ -35,3 +34,1 @@\n-\/**\n- *\/\n-public abstract class SetListenerHelper<E> extends ExpressionHelperBase {\n+public abstract class SetListenerHelper<E> {\n@@ -206,1 +203,1 @@\n-                    invalidationSize = trim(invalidationSize, invalidationListeners);\n+                    invalidationSize = WeakListenerArrayUtil.trim(invalidationSize, invalidationListeners);\n@@ -263,1 +260,1 @@\n-                    changeSize = trim(changeSize, changeListeners);\n+                    changeSize = WeakListenerArrayUtil.trim(changeSize, changeListeners);\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/collections\/SetListenerHelper.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.property;\n+\n+import com.sun.javafx.binding.ExpressionHelperBase;\n+import javafx.beans.property.Property;\n+import javafx.beans.property.ReadOnlyProperty;\n+import javafx.beans.value.ObservableValue;\n+\n+import static com.sun.javafx.beans.BeanErrors.*;\n+\n+public class PropertyHelper {\n+\n+    private PropertyHelper() {}\n+\n+    public static String toString(\n+            ReadOnlyProperty<?> property, Class<? extends ReadOnlyProperty> displayClass) {\n+        return toString(property, displayClass, false);\n+    }\n+\n+    public static String toString(\n+            ReadOnlyProperty<?> property, Class<? extends ReadOnlyProperty> displayClass, boolean valid) {\n+        StringBuilder result = new StringBuilder(displayClass.getSimpleName()).append(\" [\");\n+        Object bean = property.getBean();\n+        String name = property.getName();\n+\n+        if (bean != null) {\n+            result.append(\"bean: \").append(bean).append(\", \");\n+        }\n+\n+        if (name != null && !name.isBlank()) {\n+            result.append(\"name: \").append(name).append(\", \");\n+        }\n+\n+        if (property instanceof Property<?> && ((Property<?>)property).isBound()) {\n+            result.append(\"bound, \");\n+\n+            if (valid) {\n+                result.append(\"value: \").append(property.getValue());\n+            } else {\n+                result.append(\"invalid\");\n+            }\n+        } else {\n+            result.append(\"value: \").append(property.getValue());\n+        }\n+\n+        result.append(\"]\");\n+        return result.toString();\n+    }\n+\n+    public static void checkBind(Property<?> self, ObservableValue<?> source, ExpressionHelperBase helper) {\n+        if (source == null) {\n+            throw new NullPointerException(BINDING_SOURCE_NULL.getMessage());\n+        }\n+\n+        if (self == source) {\n+            throw new IllegalArgumentException(CANNOT_BIND_PROPERTY_TO_ITSELF.getMessage(self));\n+        }\n+\n+        if (ExpressionHelperBase.isBoundBidirectional(helper)) {\n+            throw new IllegalStateException(BIND_CONFLICT_UNIDIRECTIONAL.getMessage(self));\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/property\/PropertyHelper.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -855,0 +855,3 @@\n+     * <p>\n+     * If the two properties are already bidirectionally bound, the existing binding\n+     * will be removed as if by calling {@link #unbindBidirectional(Object, Object)}.\n@@ -868,1 +871,5 @@\n-        BidirectionalBinding.bind(property1, property2);\n+        try {\n+            BidirectionalBinding.bind(property1, property2);\n+        } catch (IllegalStateException ex) {\n+            throw new IllegalArgumentException(ex.getMessage());\n+        }\n@@ -875,2 +882,0 @@\n-     * @param <T>\n-     *            the types of the properties\n@@ -878,1 +883,1 @@\n-     *            the first {@code Property<T>}\n+     *            the first {@code Property}\n@@ -880,1 +885,1 @@\n-     *            the second {@code Property<T>}\n+     *            the second {@code Property}\n@@ -886,1 +891,1 @@\n-    public static <T> void unbindBidirectional(Property<T> property1, Property<T> property2) {\n+    public static void unbindBidirectional(Property<?> property1, Property<?> property2) {\n@@ -903,0 +908,2 @@\n+     * @throws ClassCastException\n+     *            if the specified objects are not {@code Property} instances\n@@ -904,0 +911,1 @@\n+     * @deprecated use {@link #unbindBidirectional(Property, Property)} instead\n@@ -905,0 +913,1 @@\n+    @Deprecated(since = \"18\", forRemoval = true)\n@@ -906,1 +915,1 @@\n-        BidirectionalBinding.unbind(property1, property2);\n+        BidirectionalBinding.unbind((Property<?>)property1, (Property<?>)property2);\n@@ -929,0 +938,3 @@\n+     * <p>\n+     * If the two properties are already bidirectionally bound, the existing binding\n+     * will be removed as if by calling {@link #unbindBidirectional(Object, Object)}.\n@@ -943,1 +955,5 @@\n-        BidirectionalBinding.bind(stringProperty, otherProperty, format);\n+        try {\n+            BidirectionalBinding.bind(stringProperty, otherProperty, format);\n+        } catch (IllegalStateException ex) {\n+            throw new IllegalArgumentException(ex.getMessage());\n+        }\n@@ -966,0 +982,3 @@\n+     * <p>\n+     * If the two properties are already bidirectionally bound, the existing binding\n+     * will be removed as if by calling {@link #unbindBidirectional(Object, Object)}.\n@@ -981,1 +1000,5 @@\n-        BidirectionalBinding.bind(stringProperty, otherProperty, converter);\n+        try {\n+            BidirectionalBinding.bind(stringProperty, otherProperty, converter);\n+        } catch (IllegalStateException ex) {\n+            throw new IllegalArgumentException(ex.getMessage());\n+        }\n@@ -1006,0 +1029,3 @@\n+     * <p>\n+     * If the two lists are already bidirectionally content-bound, the existing binding\n+     * will be removed as if by calling {@link #unbindContentBidirectional(Object, Object)}.\n@@ -1020,1 +1046,5 @@\n-        BidirectionalContentBinding.bind(list1, list2);\n+        try {\n+            BidirectionalContentBinding.bind(list1, list2);\n+        } catch (IllegalStateException ex) {\n+            throw new IllegalArgumentException(ex.getMessage());\n+        }\n@@ -1045,0 +1075,3 @@\n+     * <p>\n+     * If the two sets are already bidirectionally content-bound, the existing binding\n+     * will be removed as if by calling {@link #unbindContentBidirectional(Object, Object)}.\n@@ -1059,1 +1092,5 @@\n-        BidirectionalContentBinding.bind(set1, set2);\n+        try {\n+            BidirectionalContentBinding.bind(set1, set2);\n+        } catch (IllegalStateException ex) {\n+            throw new IllegalArgumentException(ex.getMessage());\n+        }\n@@ -1084,0 +1121,3 @@\n+     * <p>\n+     * If the two maps are already bidirectionally content-bound, the existing binding\n+     * will be removed as if by calling {@link #unbindContentBidirectional(Object, Object)}.\n@@ -1093,0 +1133,4 @@\n+     * @throws NullPointerException\n+     *            if one of the maps is {@code null}\n+     * @throws IllegalArgumentException\n+     *            if {@code map1} == {@code map2}\n@@ -1096,1 +1140,5 @@\n-        BidirectionalContentBinding.bind(map1, map2);\n+        try {\n+            BidirectionalContentBinding.bind(map1, map2);\n+        } catch (IllegalStateException ex) {\n+            throw new IllegalArgumentException(ex.getMessage());\n+        }\n@@ -1107,0 +1155,3 @@\n+     * @deprecated use {@link #unbindContentBidirectional(ObservableList, ObservableList)},\n+     *             {@link #unbindContentBidirectional(ObservableSet, ObservableSet)}, or\n+     *             {@link #unbindContentBidirectional(ObservableMap, ObservableMap)} instead\n@@ -1108,0 +1159,1 @@\n+    @Deprecated(since = \"18\", forRemoval = true)\n@@ -1109,1 +1161,58 @@\n-        BidirectionalContentBinding.unbind(obj1, obj2);\n+        if (obj1 instanceof ObservableList && obj2 instanceof ObservableList) {\n+            unbindContentBidirectional((ObservableList)obj1, (ObservableList)obj2);\n+        } else if (obj1 instanceof ObservableSet && obj2 instanceof ObservableSet) {\n+            unbindContentBidirectional((ObservableSet)obj1, (ObservableSet)obj2);\n+        } else if (obj1 instanceof ObservableMap && obj2 instanceof ObservableMap) {\n+            unbindContentBidirectional((ObservableMap)obj1, (ObservableMap)obj2);\n+        }\n+    }\n+\n+    \/**\n+     * Removes a bidirectional content binding.\n+     *\n+     * @param list1\n+     *            the first {@code ObservableList}\n+     * @param list2\n+     *            the second {@code ObservableList}\n+     * @throws NullPointerException\n+     *            if one of the lists is {@code null}\n+     * @throws IllegalArgumentException\n+     *            if {@code list1} == {@code list2}\n+     * @since 18\n+     *\/\n+    public static <E> void unbindContentBidirectional(ObservableList<E> list1, ObservableList<E> list2) {\n+        BidirectionalContentBinding.unbind(list1, list2);\n+    }\n+\n+    \/**\n+     * Removes a bidirectional content binding.\n+     *\n+     * @param set1\n+     *            the first {@code ObservableSet}\n+     * @param set2\n+     *            the second {@code ObservableSet}\n+     * @throws NullPointerException\n+     *            if one of the sets is {@code null}\n+     * @throws IllegalArgumentException\n+     *            if {@code set1} == {@code set2}\n+     * @since 18\n+     *\/\n+    public static <E> void unbindContentBidirectional(ObservableSet<E> set1, ObservableSet<E> set2) {\n+        BidirectionalContentBinding.unbind(set1, set2);\n+    }\n+\n+    \/**\n+     * Removes a bidirectional content binding.\n+     *\n+     * @param map1\n+     *            the first {@code ObservableMap}\n+     * @param map2\n+     *            the second {@code ObservableMap}\n+     * @throws NullPointerException\n+     *            if one of the maps is {@code null}\n+     * @throws IllegalArgumentException\n+     *            if {@code map1} == {@code map2}\n+     * @since 18\n+     *\/\n+    public static <K, V> void unbindContentBidirectional(ObservableMap<K, V> map1, ObservableMap<K, V> map2) {\n+        BidirectionalContentBinding.unbind(map1, map2);\n@@ -1122,0 +1231,3 @@\n+     * <p>\n+     * If the two lists are already content-bound, the existing binding will be removed\n+     * as if by calling {@link #unbindContent(Object, Object)}.\n@@ -1129,0 +1241,4 @@\n+     * @throws NullPointerException\n+     *            if one of the lists is {@code null}\n+     * @throws IllegalArgumentException\n+     *            if {@code list1} == {@code list2}\n@@ -1132,1 +1248,5 @@\n-        ContentBinding.bind(list1, list2);\n+        try {\n+            ContentBinding.bind(list1, list2);\n+        } catch (IllegalStateException ex) {\n+            throw new IllegalArgumentException(ex.getMessage());\n+        }\n@@ -1145,0 +1265,3 @@\n+     * <p>\n+     * If the two sets are already content-bound, the existing binding will be removed\n+     * as if by calling {@link #unbindContent(Object, Object)}.\n@@ -1159,1 +1282,5 @@\n-        ContentBinding.bind(set1, set2);\n+        try {\n+            ContentBinding.bind(set1, set2);\n+        } catch (IllegalStateException ex) {\n+            throw new IllegalArgumentException(ex.getMessage());\n+        }\n@@ -1172,0 +1299,3 @@\n+     * <p>\n+     * If the two maps are already content-bound, the existing binding will be removed\n+     * as if by calling {@link #unbindContent(Object, Object)}.\n@@ -1188,1 +1318,56 @@\n-        ContentBinding.bind(map1, map2);\n+        try {\n+            ContentBinding.bind(map1, map2);\n+        } catch (IllegalStateException ex) {\n+            throw new IllegalArgumentException(ex.getMessage());\n+        }\n+    }\n+\n+    \/**\n+     * Removes a content binding.\n+     *\n+     * @param list1\n+     *            the first {@code List}\n+     * @param list2\n+     *            the second {@code ObservableList}\n+     * @throws NullPointerException\n+     *            if one of the lists is {@code null}\n+     * @throws IllegalArgumentException\n+     *            if {@code list1} == {@code list2}\n+     * @since 18\n+     *\/\n+    public static <E> void unbindContent(List<E> list1, ObservableList<E> list2) {\n+        ContentBinding.unbind(list1, list2);\n+    }\n+\n+    \/**\n+     * Removes a content binding.\n+     *\n+     * @param set1\n+     *            the first {@code Set}\n+     * @param set2\n+     *            the second {@code ObservableSet}\n+     * @throws NullPointerException\n+     *            if one of the sets is {@code null}\n+     * @throws IllegalArgumentException\n+     *            if {@code set1} == {@code set2}\n+     * @since 18\n+     *\/\n+    public static <E> void unbindContent(Set<E> set1, ObservableSet<E> set2) {\n+        ContentBinding.unbind(set1, set2);\n+    }\n+\n+    \/**\n+     * Removes a content binding.\n+     *\n+     * @param map1\n+     *            the first {@code Map}\n+     * @param map2\n+     *            the second {@code ObservableMap}\n+     * @throws NullPointerException\n+     *            if one of the maps is {@code null}\n+     * @throws IllegalArgumentException\n+     *            if {@code map1} == {@code map2}\n+     * @since 18\n+     *\/\n+    public static <K, V> void unbindContent(Map<K, V> map1, ObservableMap<K, V> map2) {\n+        ContentBinding.unbind(map1, map2);\n@@ -1203,0 +1388,3 @@\n+     * @deprecated use {@link #unbindContent(List, ObservableList)},\n+     *             {@link #unbindContent(Set, ObservableSet)} or\n+     *             {@link #unbindContent(Map, ObservableMap)} instead\n@@ -1204,0 +1392,1 @@\n+    @Deprecated(since = \"18\", forRemoval = true)\n@@ -1205,1 +1394,7 @@\n-        ContentBinding.unbind(obj1, obj2);\n+        if (obj1 instanceof List && obj2 instanceof ObservableList) {\n+            unbindContent((List)obj1, (ObservableList)obj2);\n+        } else if (obj1 instanceof Set && obj2 instanceof ObservableSet) {\n+            unbindContent((Set)obj1, (ObservableSet)obj2);\n+        } else if (obj1 instanceof Map && obj2 instanceof ObservableMap) {\n+            unbindContent((Map)obj1, (ObservableMap)obj2);\n+        }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/Bindings.java","additions":212,"deletions":17,"binary":false,"changes":229,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,3 @@\n-import javafx.beans.binding.Bindings;\n+import com.sun.javafx.binding.Logging;\n+import com.sun.javafx.property.PropertyHelper;\n+\n@@ -34,1 +36,0 @@\n-import com.sun.javafx.binding.Logging;\n@@ -88,1 +89,1 @@\n-        Bindings.bindBidirectional(this, other);\n+        BidirectionalBinding.bind(this, other);\n@@ -96,1 +97,1 @@\n-        Bindings.unbindBidirectional(this, other);\n+        BidirectionalBinding.unbind(this, other);\n@@ -105,12 +106,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"BooleanProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, BooleanProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/BooleanProperty.java","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,5 @@\n+import java.lang.ref.WeakReference;\n+\n+import com.sun.javafx.beans.BeanErrors;\n+import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -30,0 +35,1 @@\n+import javafx.beans.WeakListener;\n@@ -35,4 +41,0 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n-import java.lang.ref.WeakReference;\n-import javafx.beans.WeakListener;\n-\n@@ -140,2 +142,1 @@\n-            throw new java.lang.RuntimeException((getBean() != null && getName() != null ?\n-                    getBean().getClass().getSimpleName() + \".\" + getName() + \" : \": \"\") + \"A bound value cannot be set.\");\n+            throw new IllegalStateException(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(this));\n@@ -143,0 +144,1 @@\n+\n@@ -159,1 +161,0 @@\n-     * Note:\n@@ -162,4 +163,2 @@\n-    public void bind(final ObservableValue<? extends Boolean> rawObservable) {\n-        if (rawObservable == null) {\n-            throw new NullPointerException(\"Cannot bind to null\");\n-        }\n+    public void bind(final ObservableValue<? extends Boolean> source) {\n+        PropertyHelper.checkBind(this, source, helper);\n@@ -167,2 +166,2 @@\n-        final ObservableBooleanValue newObservable = (rawObservable instanceof ObservableBooleanValue) ? (ObservableBooleanValue) rawObservable\n-                : new ValueWrapper(rawObservable);\n+        final ObservableBooleanValue newObservable = (source instanceof ObservableBooleanValue) ?\n+                (ObservableBooleanValue) source : new ValueWrapper(source);\n@@ -202,21 +201,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\"BooleanProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        if (isBound()) {\n-            result.append(\"bound, \");\n-            if (valid) {\n-                result.append(\"value: \").append(get());\n-            } else {\n-                result.append(\"invalid\");\n-            }\n-        } else {\n-            result.append(\"value: \").append(get());\n-        }\n-        result.append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, BooleanProperty.class, valid);\n@@ -249,2 +228,2 @@\n-    private class ValueWrapper extends BooleanBinding {\n-        private ObservableValue<? extends Boolean> observable;\n+    private static class ValueWrapper extends BooleanBinding {\n+        private final ObservableValue<? extends Boolean> observable;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/BooleanPropertyBase.java","additions":16,"deletions":37,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import com.sun.javafx.property.PropertyHelper;\n@@ -33,1 +34,0 @@\n-import javafx.beans.binding.Bindings;\n@@ -87,1 +87,1 @@\n-        Bindings.bindBidirectional(this, other);\n+        BidirectionalBinding.bind(this, other);\n@@ -95,1 +95,1 @@\n-        Bindings.unbindBidirectional(this, other);\n+        BidirectionalBinding.unbind(this, other);\n@@ -104,12 +104,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"DoubleProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, DoubleProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/DoubleProperty.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,5 @@\n+import java.lang.ref.WeakReference;\n+\n+import com.sun.javafx.beans.BeanErrors;\n+import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -30,0 +35,1 @@\n+import javafx.beans.WeakListener;\n@@ -32,5 +38,0 @@\n-import javafx.beans.value.ObservableValue;\n-\n-import com.sun.javafx.binding.ExpressionHelper;\n-import java.lang.ref.WeakReference;\n-import javafx.beans.WeakListener;\n@@ -39,0 +40,1 @@\n+import javafx.beans.value.ObservableValue;\n@@ -143,2 +145,1 @@\n-            throw new java.lang.RuntimeException((getBean() != null && getName() != null ?\n-                    getBean().getClass().getSimpleName() + \".\" + getName() + \" : \": \"\") + \"A bound value cannot be set.\");\n+            throw new IllegalStateException(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(this));\n@@ -146,0 +147,1 @@\n+\n@@ -164,4 +166,2 @@\n-    public void bind(final ObservableValue<? extends Number> rawObservable) {\n-        if (rawObservable == null) {\n-            throw new NullPointerException(\"Cannot bind to null\");\n-        }\n+    public void bind(final ObservableValue<? extends Number> source) {\n+        PropertyHelper.checkBind(this, source, helper);\n@@ -170,5 +170,5 @@\n-        if (rawObservable instanceof ObservableDoubleValue) {\n-            newObservable = (ObservableDoubleValue)rawObservable;\n-        } else if (rawObservable instanceof ObservableNumberValue) {\n-            final ObservableNumberValue numberValue = (ObservableNumberValue)rawObservable;\n-            newObservable = new ValueWrapper(rawObservable) {\n+        if (source instanceof ObservableDoubleValue) {\n+            newObservable = (ObservableDoubleValue)source;\n+        } else if (source instanceof ObservableNumberValue) {\n+            final ObservableNumberValue numberValue = (ObservableNumberValue)source;\n+            newObservable = new ValueWrapper(source) {\n@@ -182,1 +182,1 @@\n-            newObservable = new ValueWrapper(rawObservable) {\n+            newObservable = new ValueWrapper(source) {\n@@ -186,1 +186,1 @@\n-                    final Number value = rawObservable.getValue();\n+                    final Number value = source.getValue();\n@@ -224,21 +224,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\"DoubleProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        if (isBound()) {\n-            result.append(\"bound, \");\n-            if (valid) {\n-                result.append(\"value: \").append(get());\n-            } else {\n-                result.append(\"invalid\");\n-            }\n-        } else {\n-            result.append(\"value: \").append(get());\n-        }\n-        result.append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, DoubleProperty.class, valid);\n@@ -271,3 +251,2 @@\n-    private abstract class ValueWrapper extends DoubleBinding {\n-\n-        private ObservableValue<? extends Number> observable;\n+    private abstract static class ValueWrapper extends DoubleBinding {\n+        private final ObservableValue<? extends Number> observable;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/DoublePropertyBase.java","additions":22,"deletions":43,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,3 @@\n-import javafx.beans.binding.Bindings;\n+import com.sun.javafx.binding.Logging;\n+import com.sun.javafx.property.PropertyHelper;\n+\n@@ -34,1 +36,0 @@\n-import com.sun.javafx.binding.Logging;\n@@ -86,1 +87,1 @@\n-        Bindings.bindBidirectional(this, other);\n+        BidirectionalBinding.bind(this, other);\n@@ -94,1 +95,1 @@\n-        Bindings.unbindBidirectional(this, other);\n+        BidirectionalBinding.unbind(this, other);\n@@ -103,12 +104,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"FloatProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, FloatProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/FloatProperty.java","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,4 @@\n+import com.sun.javafx.beans.BeanErrors;\n+import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.property.PropertyHelper;\n+\n@@ -30,0 +34,1 @@\n+import javafx.beans.WeakListener;\n@@ -32,0 +37,2 @@\n+import javafx.beans.value.ObservableFloatValue;\n+import javafx.beans.value.ObservableNumberValue;\n@@ -34,1 +41,0 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n@@ -36,3 +42,0 @@\n-import javafx.beans.WeakListener;\n-import javafx.beans.value.ObservableFloatValue;\n-import javafx.beans.value.ObservableNumberValue;\n@@ -143,2 +146,1 @@\n-            throw new java.lang.RuntimeException((getBean() != null && getName() != null ?\n-                    getBean().getClass().getSimpleName() + \".\" + getName() + \" : \": \"\") + \"A bound value cannot be set.\");\n+            throw new IllegalStateException(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(this));\n@@ -146,0 +148,1 @@\n+\n@@ -164,4 +167,2 @@\n-    public void bind(final ObservableValue<? extends Number> rawObservable) {\n-        if (rawObservable == null) {\n-            throw new NullPointerException(\"Cannot bind to null\");\n-        }\n+    public void bind(final ObservableValue<? extends Number> source) {\n+        PropertyHelper.checkBind(this, source, helper);\n@@ -170,5 +171,5 @@\n-        if (rawObservable instanceof ObservableFloatValue) {\n-            newObservable = (ObservableFloatValue)rawObservable;\n-        } else if (rawObservable instanceof ObservableNumberValue) {\n-            final ObservableNumberValue numberValue = (ObservableNumberValue)rawObservable;\n-            newObservable = new ValueWrapper(rawObservable) {\n+        if (source instanceof ObservableFloatValue) {\n+            newObservable = (ObservableFloatValue)source;\n+        } else if (source instanceof ObservableNumberValue) {\n+            final ObservableNumberValue numberValue = (ObservableNumberValue)source;\n+            newObservable = new ValueWrapper(source) {\n@@ -182,1 +183,1 @@\n-            newObservable = new ValueWrapper(rawObservable) {\n+            newObservable = new ValueWrapper(source) {\n@@ -186,1 +187,1 @@\n-                    final Number value = rawObservable.getValue();\n+                    final Number value = source.getValue();\n@@ -225,21 +226,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\"FloatProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        if (isBound()) {\n-            result.append(\"bound, \");\n-            if (valid) {\n-                result.append(\"value: \").append(get());\n-            } else {\n-                result.append(\"invalid\");\n-            }\n-        } else {\n-            result.append(\"value: \").append(get());\n-        }\n-        result.append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, FloatProperty.class, valid);\n@@ -272,3 +253,2 @@\n-    private abstract class ValueWrapper extends FloatBinding {\n-\n-        private ObservableValue<? extends Number> observable;\n+    private abstract static class ValueWrapper extends FloatBinding {\n+        private final ObservableValue<? extends Number> observable;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/FloatPropertyBase.java","additions":22,"deletions":42,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,3 @@\n-import javafx.beans.binding.Bindings;\n+import com.sun.javafx.binding.Logging;\n+import com.sun.javafx.property.PropertyHelper;\n+\n@@ -34,1 +36,0 @@\n-import com.sun.javafx.binding.Logging;\n@@ -86,1 +87,1 @@\n-        Bindings.bindBidirectional(this, other);\n+        BidirectionalBinding.bind(this, other);\n@@ -94,1 +95,1 @@\n-        Bindings.unbindBidirectional(this, other);\n+        BidirectionalBinding.unbind(this, other);\n@@ -103,12 +104,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"IntegerProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, IntegerProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/IntegerProperty.java","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,5 @@\n+import java.lang.ref.WeakReference;\n+\n+import com.sun.javafx.beans.BeanErrors;\n+import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -30,0 +35,1 @@\n+import javafx.beans.WeakListener;\n@@ -32,5 +38,0 @@\n-import javafx.beans.value.ObservableValue;\n-\n-import com.sun.javafx.binding.ExpressionHelper;\n-import java.lang.ref.WeakReference;\n-import javafx.beans.WeakListener;\n@@ -39,0 +40,1 @@\n+import javafx.beans.value.ObservableValue;\n@@ -143,2 +145,1 @@\n-            throw new java.lang.RuntimeException((getBean() != null && getName() != null ?\n-                    getBean().getClass().getSimpleName() + \".\" + getName() + \" : \": \"\") + \"A bound value cannot be set.\");\n+            throw new IllegalStateException(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(this));\n@@ -146,0 +147,1 @@\n+\n@@ -164,4 +166,2 @@\n-    public void bind(final ObservableValue<? extends Number> rawObservable) {\n-        if (rawObservable == null) {\n-            throw new NullPointerException(\"Cannot bind to null\");\n-        }\n+    public void bind(final ObservableValue<? extends Number> source) {\n+        PropertyHelper.checkBind(this, source, helper);\n@@ -170,5 +170,5 @@\n-        if (rawObservable instanceof ObservableIntegerValue) {\n-            newObservable = (ObservableIntegerValue)rawObservable;\n-        } else if (rawObservable instanceof ObservableNumberValue) {\n-            final ObservableNumberValue numberValue = (ObservableNumberValue)rawObservable;\n-            newObservable = new ValueWrapper(rawObservable) {\n+        if (source instanceof ObservableIntegerValue) {\n+            newObservable = (ObservableIntegerValue)source;\n+        } else if (source instanceof ObservableNumberValue) {\n+            final ObservableNumberValue numberValue = (ObservableNumberValue)source;\n+            newObservable = new ValueWrapper(source) {\n@@ -182,1 +182,1 @@\n-            newObservable = new ValueWrapper(rawObservable) {\n+            newObservable = new ValueWrapper(source) {\n@@ -186,1 +186,1 @@\n-                    final Number value = rawObservable.getValue();\n+                    final Number value = source.getValue();\n@@ -224,21 +224,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\"IntegerProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        if (isBound()) {\n-            result.append(\"bound, \");\n-            if (valid) {\n-                result.append(\"value: \").append(get());\n-            } else {\n-                result.append(\"invalid\");\n-            }\n-        } else {\n-            result.append(\"value: \").append(get());\n-        }\n-        result.append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, IntegerProperty.class, valid);\n@@ -271,3 +251,2 @@\n-    private abstract class ValueWrapper extends IntegerBinding {\n-\n-        private ObservableValue<? extends Number> observable;\n+    private abstract static class ValueWrapper extends IntegerBinding {\n+        private final ObservableValue<? extends Number> observable;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/IntegerPropertyBase.java","additions":22,"deletions":43,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-import javafx.beans.binding.Bindings;\n+import com.sun.javafx.binding.BidirectionalBinding;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -78,1 +79,1 @@\n-        Bindings.bindBidirectional(this, other);\n+        BidirectionalBinding.bind(this, other);\n@@ -86,1 +87,1 @@\n-        Bindings.unbindBidirectional(this, other);\n+        BidirectionalBinding.unbind(this, other);\n@@ -95,12 +96,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"ListProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, ListProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ListProperty.java","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.javafx.beans.BeanErrors;\n+import com.sun.javafx.binding.ContentBinding;\n@@ -29,1 +31,1 @@\n-import java.lang.ref.WeakReference;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -38,0 +40,3 @@\n+import java.lang.ref.WeakReference;\n+import java.util.Objects;\n+\n@@ -225,2 +230,0 @@\n-\n-\n@@ -252,2 +255,5 @@\n-            throw new java.lang.RuntimeException((getBean() != null && getName() != null ?\n-                    getBean().getClass().getSimpleName() + \".\" + getName() + \" : \": \"\") + \"A bound value cannot be set.\");\n+            throw new IllegalStateException(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(this));\n+        }\n+\n+        if (isContentBound()) {\n+            throw new IllegalStateException(BeanErrors.CANNOT_SET_CONTENT_BOUND_PROPERTY.getMessage(this));\n@@ -255,0 +261,1 @@\n+\n@@ -268,4 +275,2 @@\n-    public void bind(final ObservableValue<? extends ObservableList<E>> newObservable) {\n-        if (newObservable == null) {\n-            throw new NullPointerException(\"Cannot bind to null\");\n-        }\n+    public void bind(final ObservableValue<? extends ObservableList<E>> source) {\n+        PropertyHelper.checkBind(this, source, helper);\n@@ -273,1 +278,1 @@\n-        if (newObservable != observable) {\n+        if (source != observable) {\n@@ -275,1 +280,1 @@\n-            observable = newObservable;\n+            observable = source;\n@@ -293,0 +298,27 @@\n+    @Override\n+    public void bindContent(ObservableList<E> source) {\n+        ContentBinding.bind(this, source, helper);\n+    }\n+\n+    @Override\n+    public void unbindContent() {\n+        ContentBinding binding = ListExpressionHelper.getContentBinding(helper);\n+        if (binding != null && binding.isTarget(this)) {\n+            binding.dispose();\n+        }\n+    }\n+\n+    @Override\n+    public void unbindContent(Object source) {\n+        Objects.requireNonNull(source);\n+        if (source instanceof ObservableList<?>) {\n+            ContentBinding.unbind(this, (ObservableList<E>)source);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isContentBound() {\n+        ContentBinding binding = ListExpressionHelper.getContentBinding(helper);\n+        return binding != null && binding.isTarget(this);\n+    }\n+\n@@ -299,21 +331,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\"ListProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        if (isBound()) {\n-            result.append(\"bound, \");\n-            if (valid) {\n-                result.append(\"value: \").append(get());\n-            } else {\n-                result.append(\"invalid\");\n-            }\n-        } else {\n-            result.append(\"value: \").append(get());\n-        }\n-        result.append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, ListProperty.class, valid);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ListPropertyBase.java","additions":44,"deletions":32,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,3 @@\n-import javafx.beans.binding.Bindings;\n+import com.sun.javafx.binding.Logging;\n+import com.sun.javafx.property.PropertyHelper;\n+\n@@ -34,1 +36,0 @@\n-import com.sun.javafx.binding.Logging;\n@@ -85,1 +86,1 @@\n-        Bindings.bindBidirectional(this, other);\n+        BidirectionalBinding.bind(this, other);\n@@ -93,1 +94,1 @@\n-        Bindings.unbindBidirectional(this, other);\n+        BidirectionalBinding.unbind(this, other);\n@@ -102,11 +103,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\"LongProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, LongProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/LongProperty.java","additions":7,"deletions":16,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,5 @@\n+import java.lang.ref.WeakReference;\n+\n+import com.sun.javafx.beans.BeanErrors;\n+import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -30,0 +35,1 @@\n+import javafx.beans.WeakListener;\n@@ -32,5 +38,0 @@\n-import javafx.beans.value.ObservableValue;\n-\n-import com.sun.javafx.binding.ExpressionHelper;\n-import java.lang.ref.WeakReference;\n-import javafx.beans.WeakListener;\n@@ -39,0 +40,1 @@\n+import javafx.beans.value.ObservableValue;\n@@ -143,2 +145,1 @@\n-            throw new java.lang.RuntimeException((getBean() != null && getName() != null ?\n-                    getBean().getClass().getSimpleName() + \".\" + getName() + \" : \": \"\") + \"A bound value cannot be set.\");\n+            throw new IllegalStateException(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(this));\n@@ -146,0 +147,1 @@\n+\n@@ -164,4 +166,2 @@\n-    public void bind(final ObservableValue<? extends Number> rawObservable) {\n-        if (rawObservable == null) {\n-            throw new NullPointerException(\"Cannot bind to null\");\n-        }\n+    public void bind(final ObservableValue<? extends Number> source) {\n+        PropertyHelper.checkBind(this, source, helper);\n@@ -170,5 +170,5 @@\n-        if (rawObservable instanceof ObservableLongValue) {\n-            newObservable = (ObservableLongValue)rawObservable;\n-        } else if (rawObservable instanceof ObservableNumberValue) {\n-            final ObservableNumberValue numberValue = (ObservableNumberValue)rawObservable;\n-            newObservable = new ValueWrapper(rawObservable) {\n+        if (source instanceof ObservableLongValue) {\n+            newObservable = (ObservableLongValue)source;\n+        } else if (source instanceof ObservableNumberValue) {\n+            final ObservableNumberValue numberValue = (ObservableNumberValue)source;\n+            newObservable = new ValueWrapper(source) {\n@@ -182,1 +182,1 @@\n-            newObservable = new ValueWrapper(rawObservable) {\n+            newObservable = new ValueWrapper(source) {\n@@ -186,1 +186,1 @@\n-                    final Number value = rawObservable.getValue();\n+                    final Number value = source.getValue();\n@@ -224,21 +224,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\"LongProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        if (isBound()) {\n-            result.append(\"bound, \");\n-            if (valid) {\n-                result.append(\"value: \").append(get());\n-            } else {\n-                result.append(\"invalid\");\n-            }\n-        } else {\n-            result.append(\"value: \").append(get());\n-        }\n-        result.append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, LongProperty.class, valid);\n@@ -271,3 +251,2 @@\n-    private abstract class ValueWrapper extends LongBinding {\n-\n-        private ObservableValue<? extends Number> observable;\n+    private abstract static class ValueWrapper extends LongBinding {\n+        private final ObservableValue<? extends Number> observable;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/LongPropertyBase.java","additions":22,"deletions":43,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-import javafx.beans.binding.Bindings;\n+import com.sun.javafx.binding.BidirectionalBinding;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -79,1 +80,1 @@\n-        Bindings.bindBidirectional(this, other);\n+        BidirectionalBinding.bind(this, other);\n@@ -87,1 +88,1 @@\n-        Bindings.unbindBidirectional(this, other);\n+        BidirectionalBinding.unbind(this, other);\n@@ -96,12 +97,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"MapProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, MapProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/MapProperty.java","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.javafx.beans.BeanErrors;\n+import com.sun.javafx.binding.ContentBinding;\n@@ -29,0 +31,1 @@\n+import com.sun.javafx.property.PropertyHelper;\n@@ -227,2 +230,0 @@\n-\n-\n@@ -254,2 +255,5 @@\n-            throw new java.lang.RuntimeException((getBean() != null && getName() != null ?\n-                    getBean().getClass().getSimpleName() + \".\" + getName() + \" : \": \"\") + \"A bound value cannot be set.\");\n+            throw new IllegalStateException(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(this));\n+        }\n+\n+        if (isContentBound()) {\n+            throw new IllegalStateException(BeanErrors.CANNOT_SET_CONTENT_BOUND_PROPERTY.getMessage(this));\n@@ -257,0 +261,1 @@\n+\n@@ -270,5 +275,4 @@\n-    public void bind(final ObservableValue<? extends ObservableMap<K, V>> newObservable) {\n-        if (newObservable == null) {\n-            throw new NullPointerException(\"Cannot bind to null\");\n-        }\n-        if (newObservable != observable) {\n+    public void bind(final ObservableValue<? extends ObservableMap<K, V>> source) {\n+        PropertyHelper.checkBind(this, source, helper);\n+\n+        if (source != observable) {\n@@ -276,1 +280,1 @@\n-            observable = newObservable;\n+            observable = source;\n@@ -294,0 +298,26 @@\n+    @Override\n+    public void bindContent(ObservableMap<K, V> source) {\n+        ContentBinding.bind(this, source, helper);\n+    }\n+\n+    @Override\n+    public void unbindContent() {\n+        ContentBinding binding = MapExpressionHelper.getContentBinding(helper);\n+        if (binding != null && binding.isTarget(this)) {\n+            binding.dispose();\n+        }\n+    }\n+\n+    @Override\n+    public void unbindContent(Object object) {\n+        if (object instanceof ObservableMap<?, ?>) {\n+            ContentBinding.unbind(this, (ObservableMap<K, V>)object);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isContentBound() {\n+        ContentBinding binding = MapExpressionHelper.getContentBinding(helper);\n+        return binding != null && binding.isTarget(this);\n+    }\n+\n@@ -300,21 +330,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\"MapProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        if (isBound()) {\n-            result.append(\"bound, \");\n-            if (valid) {\n-                result.append(\"value: \").append(get());\n-            } else {\n-                result.append(\"invalid\");\n-            }\n-        } else {\n-            result.append(\"value: \").append(get());\n-        }\n-        result.append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, MapProperty.class, valid);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/MapPropertyBase.java","additions":41,"deletions":31,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-import javafx.beans.binding.Bindings;\n+import com.sun.javafx.binding.BidirectionalBinding;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -86,1 +87,1 @@\n-        Bindings.bindBidirectional(this, other);\n+        BidirectionalBinding.bind(this, other);\n@@ -94,1 +95,1 @@\n-        Bindings.unbindBidirectional(this, other);\n+        BidirectionalBinding.unbind(this, other);\n@@ -103,12 +104,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"ObjectProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, ObjectProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ObjectProperty.java","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,5 @@\n+import java.lang.ref.WeakReference;\n+\n+import com.sun.javafx.beans.BeanErrors;\n+import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -30,0 +35,1 @@\n+import javafx.beans.WeakListener;\n@@ -33,4 +39,0 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n-import java.lang.ref.WeakReference;\n-import javafx.beans.WeakListener;\n-\n@@ -142,2 +144,1 @@\n-            throw new java.lang.RuntimeException((getBean() != null && getName() != null ?\n-                    getBean().getClass().getSimpleName() + \".\" + getName() + \" : \": \"\") + \"A bound value cannot be set.\");\n+            throw new IllegalStateException(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(this));\n@@ -145,0 +146,1 @@\n+\n@@ -163,4 +165,2 @@\n-    public void bind(final ObservableValue<? extends T> newObservable) {\n-        if (newObservable == null) {\n-            throw new NullPointerException(\"Cannot bind to null\");\n-        }\n+    public void bind(final ObservableValue<? extends T> source) {\n+        PropertyHelper.checkBind(this, source, helper);\n@@ -168,1 +168,1 @@\n-        if (!newObservable.equals(this.observable)) {\n+        if (!source.equals(this.observable)) {\n@@ -170,1 +170,1 @@\n-            observable = newObservable;\n+            observable = source;\n@@ -197,21 +197,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\"ObjectProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        if (isBound()) {\n-            result.append(\"bound, \");\n-            if (valid) {\n-                result.append(\"value: \").append(get());\n-            } else {\n-                result.append(\"invalid\");\n-            }\n-        } else {\n-            result.append(\"value: \").append(get());\n-        }\n-        result.append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, ObjectProperty.class, valid);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ObjectPropertyBase.java","additions":14,"deletions":34,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,2 @@\n-     * Create a unidirection binding for this {@code Property}.\n+     * Establishes a unidirectional binding between this property (the <em>bound property<\/em>)\n+     * and an {@link ObservableValue} (the <em>binding source<\/em>).\n@@ -45,2 +46,18 @@\n-     * Note that JavaFX has all the bind calls implemented through weak listeners. This means the bound property\n-     * can be garbage collected and stopped from being updated.\n+     * After establishing the binding, the value of the bound property is synchronized with the value\n+     * of the binding source: any change to the value of the binding source will immediately result in\n+     * the value of the bound property being changed accordingly. Furthermore, the bound property becomes\n+     * effectively read-only: any call to {@link #setValue(Object)} will fail with an exception.\n+     * When the binding is first established, the value of the bound property is set to the current value\n+     * of the binding source.\n+     * <p>\n+     * The bound property <em>strongly<\/em> references the binding source; this means that, as long as\n+     * the bound property is alive, the binding source will not be garbage-collected. As a consequence,\n+     * a bound property will not unexpectedly be unbound if its binding source would otherwise become\n+     * unreachable.\n+     * <p>\n+     * Conversely, the binding source only <em>weakly<\/em> references the bound property. In order to be\n+     * eligible for garbage collection, a bound property need not be unbound from its binding source.\n+     * <p>\n+     * If this method is called when the property is already bound, the previous binding is removed\n+     * as if by calling {@link #unbind()} before establishing the new binding. If this property is\n+     * already bidirectionally bound, calling this method will fail with an exception.\n@@ -48,4 +65,3 @@\n-     * @param observable\n-     *            The observable this {@code Property} should be bound to.\n-     * @throws NullPointerException\n-     *             if {@code observable} is {@code null}\n+     * @param source the binding source\n+     * @throws NullPointerException if {@code source} is {@code null}\n+     * @throws IllegalStateException if this property is bidirectionally bound\n@@ -53,1 +69,1 @@\n-    void bind(ObservableValue<? extends T> observable);\n+    void bind(ObservableValue<? extends T> source);\n@@ -56,4 +72,4 @@\n-     * Remove the unidirectional binding for this {@code Property}.\n-     *\n-     * If the {@code Property} is not bound, calling this method has no effect.\n-     * @see #bind(javafx.beans.value.ObservableValue)\n+     * Removes the unidirectional binding that was established with {@link #bind(ObservableValue)}.\n+     * <p>\n+     * The value of this property will remain unchanged.\n+     * If this property is not bound, calling this method has no effect.\n@@ -64,2 +80,5 @@\n-     * Can be used to check, if a {@code Property} is bound.\n-     * @see #bind(javafx.beans.value.ObservableValue)\n+     * Returns whether this property is bound by a unidirectional binding that was\n+     * established by calling {@link Property#bind(ObservableValue)}.\n+     * <p>\n+     * Note that this method does not account for bidirectional bindings that were\n+     * established by calling {@link Property#bindBidirectional(Property)}.\n@@ -67,2 +86,1 @@\n-     * @return {@code true} if the {@code Property} is bound, {@code false}\n-     *         otherwise\n+     * @return whether this property is unidirectionally bound\n@@ -73,5 +91,6 @@\n-     * Create a bidirectional binding between this {@code Property} and another\n-     * one.\n-     * Bidirectional bindings exists independently of unidirectional bindings. So it is possible to\n-     * add unidirectional binding to a property with bidirectional binding and vice-versa. However, this practice is\n-     * discouraged.\n+     * Establishes a bidirectional binding between this property and another {@link Property}.\n+     * <p>\n+     * After establishing the binding, the values of both properties are synchronized: any change\n+     * to the value of one property will immediately result in the value of the other property being\n+     * changed accordingly. When the binding is first established, the value of the this property\n+     * is set to the current value of the other property.\n@@ -79,1 +98,5 @@\n-     * It is possible to have multiple bidirectional bindings of one Property.\n+     * While it is not possible for a property to be bound by more than one unidirectional binding,\n+     * it is legal to establish multiple bidirectional bindings for the same property. However,\n+     * since a bidirectional binding allows for the values of both properties to be changed\n+     * by calling {@link #setValue(Object)}, {@link #isBound()} will return {@code false} for\n+     * both properties.\n@@ -81,2 +104,14 @@\n-     * JavaFX bidirectional binding implementation use weak listeners. This means bidirectional binding does not prevent\n-     * properties from being garbage collected.\n+     * Both properties of a bidirectional binding <em>weakly<\/em> reference their counterparts.\n+     * This is different from a unidirectional binding, where the target property <em>strongly<\/em>\n+     * references its binding source. In practice, this means that if any of the bidirectionally\n+     * bound properties become unreachable, the binding is eligible for garbage collection.\n+     * Furthermore, neither of the bidirectionally bound properties will keep its counterpart\n+     * alive if the counterpart would otherwise become unreachable.\n+     * <p>\n+     * Bidirectional bindings and unidirectional bindings are mutually exclusive. If a property is\n+     * unidirectionally bound, any attempt to establish a bidirectional binding will fail with an\n+     * exception.\n+     * <p>\n+     * If this property is already bidirectionally bound to the other property, the existing binding\n+     * will be removed as if by calling {@link #unbindBidirectional(Property)} before the new binding\n+     * is established.\n@@ -84,6 +119,6 @@\n-     * @param other\n-     *            the other {@code Property}\n-     * @throws NullPointerException\n-     *             if {@code other} is {@code null}\n-     * @throws IllegalArgumentException\n-     *             if {@code other} is {@code this}\n+     * @param other the other property\n+     * @throws NullPointerException if {@code other} is {@code null}\n+     * @throws IllegalArgumentException if {@code other} is {@code this}\n+     * @throws IllegalStateException if this property or the other property is unidirectionally bound\n+     *\n+     * @see #bind(ObservableValue)\n@@ -94,12 +129,8 @@\n-     * Remove a bidirectional binding between this {@code Property} and another\n-     * one.\n-     *\n-     * If no bidirectional binding between the properties exists, calling this\n-     * method has no effect.\n-     *\n-     * It is possible to unbind by a call on the second property. This code will work:\n-     *\n-     * <blockquote><pre>\n-     *     property1.bindBirectional(property2);\n-     *     property2.unbindBidirectional(property1);\n-     * <\/pre><\/blockquote>\n+     * Removes the bidirectional binding that was established with {@link #bindBidirectional(Property)}.\n+     * <p>\n+     * Bidirectional bindings can be removed by calling this method on either of the two properties:\n+     * <pre>{@code\n+     * property1.bindBidirectional(property2);\n+     * property2.unbindBidirectional(property1);\n+     * }<\/pre>\n+     * If the properties are not bidirectionally bound, calling this method has no effect.\n@@ -107,6 +138,1 @@\n-     * @param other\n-     *            the other {@code Property}\n-     * @throws NullPointerException\n-     *             if {@code other} is {@code null}\n-     * @throws IllegalArgumentException\n-     *             if {@code other} is {@code this}\n+     * @param other the other property\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/Property.java","additions":75,"deletions":49,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.property.PropertyHelper;\n@@ -29,1 +30,0 @@\n-import javafx.beans.Observable;\n@@ -57,12 +57,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"ReadOnlyBooleanProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && !name.equals(\"\")) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, ReadOnlyBooleanProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyBooleanProperty.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.property.PropertyHelper;\n@@ -29,1 +30,0 @@\n-import javafx.beans.Observable;\n@@ -57,12 +57,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"ReadOnlyDoubleProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && !name.equals(\"\")) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, ReadOnlyDoubleProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyDoubleProperty.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.property.PropertyHelper;\n@@ -29,1 +30,0 @@\n-import javafx.beans.Observable;\n@@ -57,12 +57,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"ReadOnlyFloatProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && !name.equals(\"\")) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, ReadOnlyFloatProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyFloatProperty.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.property.PropertyHelper;\n@@ -29,1 +30,0 @@\n-import javafx.beans.Observable;\n@@ -58,12 +58,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"ReadOnlyIntegerProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && !name.equals(\"\")) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, ReadOnlyIntegerProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyIntegerProperty.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,4 @@\n-import javafx.beans.binding.Bindings;\n+import java.util.Objects;\n+\n+import com.sun.javafx.binding.BidirectionalContentBinding;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -55,2 +58,2 @@\n-     * Creates a bidirectional content binding of the {@link javafx.collections.ObservableList}, that is\n-     * wrapped in this {@code ReadOnlyListProperty}, and another {@code ObservableList}.\n+     * Creates a bidirectional content binding between the {@link javafx.collections.ObservableList} that is\n+     * wrapped in this {@code ReadOnlyListProperty} and another {@code ObservableList}.\n@@ -58,2 +61,2 @@\n-     * A bidirectional content binding ensures that the content of two {@code ObservableLists} is the\n-     * same. If the content of one of the lists changes, the other one will be updated automatically.\n+     * A bidirectional content binding ensures that the content of the two lists is the same.\n+     * If the content of one of the lists changes, the content of the other list will be updated automatically.\n@@ -61,3 +64,3 @@\n-     * @param list the {@code ObservableList} this property should be bound to\n-     * @throws NullPointerException if {@code list} is {@code null}\n-     * @throws IllegalArgumentException if {@code list} is the same list that this {@code ReadOnlyListProperty} points to\n+     * @param other the {@code ObservableList} this property should be bound to\n+     * @throws NullPointerException if {@code other} is {@code null}\n+     * @throws IllegalArgumentException if {@code other} is the list wrapped in this {@code ReadOnlyListProperty}\n@@ -65,2 +68,2 @@\n-    public void bindContentBidirectional(ObservableList<E> list) {\n-        Bindings.bindContentBidirectional(this, list);\n+    public void bindContentBidirectional(ObservableList<E> other) {\n+        BidirectionalContentBinding.bind(this, other);\n@@ -70,2 +73,10 @@\n-     * Deletes a bidirectional content binding between the {@link javafx.collections.ObservableList}, that is\n-     * wrapped in this {@code ReadOnlyListProperty}, and another {@code Object}.\n+     * Removes the bidirectional content binding that was established with\n+     * {@link #bindContentBidirectional(ObservableList)}.\n+     * <p>\n+     * Bidirectional content bindings can be removed by calling this method on either of the two endpoints:\n+     * <pre>{@code\n+     * property1.bindContentBidirectional(property2);\n+     * property2.unbindContentBidirectional(property1);\n+     * }<\/pre>\n+     * The content of the wrapped list will remain unchanged.\n+     * If this property is not bidirectionally content-bound, calling this method has no effect.\n@@ -73,3 +84,4 @@\n-     * @param object the {@code Object} to which the bidirectional binding should be removed\n-     * @throws NullPointerException if {@code object} is {@code null}\n-     * @throws IllegalArgumentException if {@code object} is the same list that this {@code ReadOnlyListProperty} points to\n+     * @param other the {@code ObservableList} to which the bidirectional content binding should be removed\n+     * @throws NullPointerException if {@code other} is {@code null}\n+     * @throws IllegalArgumentException if {@code other} is the list wrapped in this {@code ReadOnlyListProperty}\n+     * @since 18\n@@ -77,2 +89,2 @@\n-    public void unbindContentBidirectional(Object object) {\n-        Bindings.unbindContentBidirectional(this, object);\n+    public void unbindContentBidirectional(ObservableList<E> other) {\n+        BidirectionalContentBinding.unbind(this, other);\n@@ -82,2 +94,2 @@\n-     * Creates a content binding between the {@link javafx.collections.ObservableList}, that is\n-     * wrapped in this {@code ReadOnlyListProperty}, and another {@code ObservableList}.\n+     * Removes the bidirectional content binding that was established with\n+     * {@link #bindContentBidirectional(ObservableList)}.\n@@ -85,3 +97,7 @@\n-     * A content binding ensures that the content of the wrapped {@code ObservableLists} is the\n-     * same as that of the other list. If the content of the other list changes, the wrapped list will be updated\n-     * automatically. Once the wrapped list is bound to another list, you must not change it directly.\n+     * Bidirectional content bindings can be removed by calling this method on either of the two endpoints:\n+     * <pre>{@code\n+     * property1.bindContentBidirectional(property2);\n+     * property2.unbindContentBidirectional(property1);\n+     * }<\/pre>\n+     * The content of the wrapped list will remain unchanged.\n+     * If this property is not bidirectionally content-bound, calling this method has no effect.\n@@ -89,3 +105,4 @@\n-     * @param list the {@code ObservableList} this property should be bound to\n-     * @throws NullPointerException if {@code list} is {@code null}\n-     * @throws IllegalArgumentException if {@code list} is the same list that this {@code ReadOnlyListProperty} points to\n+     * @param other the {@code Object} to which the bidirectional content binding should be removed\n+     * @throws NullPointerException if {@code other} is {@code null}\n+     * @throws IllegalArgumentException if {@code other} is the list wrapped in this {@code ReadOnlyListProperty}\n+     * @deprecated use {@link #unbindContentBidirectional(ObservableList)} instead\n@@ -93,2 +110,6 @@\n-    public void bindContent(ObservableList<E> list) {\n-        Bindings.bindContent(this, list);\n+    @Deprecated(since = \"18\", forRemoval = true)\n+    public void unbindContentBidirectional(Object other) {\n+        Objects.requireNonNull(other);\n+        if (other instanceof ObservableList<?>) {\n+            BidirectionalContentBinding.unbind(this, (ObservableList<E>)other);\n+        }\n@@ -98,2 +119,13 @@\n-     * Deletes a content binding between the {@link javafx.collections.ObservableList}, that is\n-     * wrapped in this {@code ReadOnlyListProperty}, and another {@code Object}.\n+     * Creates a content binding between the {@link javafx.collections.ObservableList} that is wrapped\n+     * in this {@code ReadOnlyListProperty} (the <em>bound list<\/em>) and another {@code ObservableList}\n+     * (the <em>source list<\/em>).\n+     * <p>\n+     * A content binding ensures that the content of the bound list is the same as that of the source list.\n+     * If the content of the source list changes, the content of the bound list will be updated automatically.\n+     * In contrast, a regular binding will replace the bound list instance with the source list instance,\n+     * which means that only a single list instance exists for both properties.\n+     * <p>\n+     * Once a content binding is established, the bound list becomes effectively read-only: any attempt to\n+     * change the content of the bound list by calling a mutating method of {@link ObservableList} will cause\n+     * the content binding to fail. In this case, the content binding is removed because the bound list and\n+     * the source list may be out-of-sync.\n@@ -101,3 +133,3 @@\n-     * @param object the {@code Object} to which the binding should be removed\n-     * @throws NullPointerException if {@code object} is {@code null}\n-     * @throws IllegalArgumentException if {@code object} is the same list that this {@code ReadOnlyListProperty} points to\n+     * @param source the source {@code ObservableList} this property should be bound to\n+     * @throws NullPointerException if {@code source} is {@code null}\n+     * @throws IllegalArgumentException if {@code source} is the list wrapped in this {@code ReadOnlyListProperty}\n@@ -105,2 +137,42 @@\n-    public void unbindContent(Object object) {\n-        Bindings.unbindContent(this, object);\n+    public void bindContent(ObservableList<E> source) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Removes the content binding that was established with {@link #bindContent(ObservableList)}.\n+     * <p>\n+     * The content of the wrapped list will remain unchanged.\n+     * If this property is not content-bound, calling this method has no effect.\n+     *\n+     * @since 18\n+     *\/\n+    public void unbindContent() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Removes the content binding that was established with {@link #bindContent(ObservableList)}.\n+     * <p>\n+     * The content of the wrapped list will remain unchanged.\n+     * If this property is not content-bound, calling this method has no effect.\n+     *\n+     * @param source the content binding source\n+     * @deprecated use {@link #unbindContent()}\n+     *\/\n+    @Deprecated(since = \"18\", forRemoval = true)\n+    public void unbindContent(Object source) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Returns whether this property is bound by a unidirectional content binding that was\n+     * established by calling {@link #bindContent(ObservableList)}.\n+     * <p>\n+     * Note that this method does not account for bidirectional content bindings that were\n+     * established by calling {@link #bindContentBidirectional(ObservableList)}.\n+     *\n+     * @return whether this property is bound by a unidirectional content binding\n+     * @since 18\n+     *\/\n+    public boolean isContentBound() {\n+        return false;\n@@ -148,12 +220,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"ReadOnlyListProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && !name.equals(\"\")) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, ReadOnlyListProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyListProperty.java","additions":108,"deletions":47,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.binding.ContentBinding;\n@@ -34,0 +35,2 @@\n+import java.util.Objects;\n+\n@@ -114,0 +117,12 @@\n+    @Override\n+    public void bindContent(ObservableList<E> source) {\n+        ContentBinding.bind(this, source, helper);\n+    }\n+\n+    @Override\n+    public void unbindContent() {\n+        ContentBinding binding = ListExpressionHelper.getContentBinding(helper);\n+        if (binding != null && binding.isTarget(this)) {\n+            binding.dispose();\n+        }\n+    }\n@@ -115,0 +130,13 @@\n+    @Override\n+    public void unbindContent(Object source) {\n+        Objects.requireNonNull(source);\n+        if (source instanceof ObservableList<?>) {\n+            ContentBinding.unbind(this, (ObservableList<? extends E>)source);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isContentBound() {\n+        ContentBinding binding = ListExpressionHelper.getContentBinding(helper);\n+        return binding != null && binding.isTarget(this);\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyListPropertyBase.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.property.PropertyHelper;\n@@ -29,1 +30,0 @@\n-import javafx.beans.Observable;\n@@ -57,11 +57,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\"ReadOnlyLongProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && !name.equals(\"\")) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, ReadOnlyLongProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyLongProperty.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,2 @@\n-import java.util.Iterator;\n-import java.util.Map;\n-import java.util.Map.Entry;\n-import javafx.beans.binding.Bindings;\n+import com.sun.javafx.binding.BidirectionalContentBinding;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -35,0 +33,3 @@\n+import java.util.Map;\n+import java.util.Objects;\n+\n@@ -56,2 +57,2 @@\n-     * Creates a bidirectional content binding of the {@link javafx.collections.ObservableMap}, that is\n-     * wrapped in this {@code ReadOnlyMapProperty}, and another {@code ObservableMap}.\n+     * Creates a bidirectional content binding between the {@link javafx.collections.ObservableMap} that is\n+     * wrapped in this {@code ReadOnlyMapProperty} and another {@code ObservableMap}.\n@@ -59,2 +60,2 @@\n-     * A bidirectional content binding ensures that the content of two {@code ObservableMaps} is the\n-     * same. If the content of one of the maps changes, the other one will be updated automatically.\n+     * A bidirectional content binding ensures that the content of two maps is the same.\n+     * If the content of one of the maps changes, the content of the other map will be updated automatically.\n@@ -62,3 +63,3 @@\n-     * @param map the {@code ObservableMap} this property should be bound to\n-     * @throws NullPointerException if {@code map} is {@code null}\n-     * @throws IllegalArgumentException if {@code map} is the same map that this {@code ReadOnlyMapProperty} points to\n+     * @param other the {@code ObservableMap} this property should be bound to\n+     * @throws NullPointerException if {@code other} is {@code null}\n+     * @throws IllegalArgumentException if {@code other} is the map wrapped in this {@code ReadOnlyMapProperty}\n@@ -66,2 +67,2 @@\n-    public void bindContentBidirectional(ObservableMap<K, V> map) {\n-        Bindings.bindContentBidirectional(this, map);\n+    public void bindContentBidirectional(ObservableMap<K, V> other) {\n+        BidirectionalContentBinding.bind(this, other);\n@@ -71,2 +72,10 @@\n-     * Deletes a bidirectional content binding between the {@link javafx.collections.ObservableMap}, that is\n-     * wrapped in this {@code ReadOnlyMapProperty}, and another {@code Object}.\n+     * Removes the bidirectional content binding that was established with\n+     * {@link #bindContentBidirectional(ObservableMap)}.\n+     * <p>\n+     * Bidirectional content bindings can be removed by calling this method on either of the two endpoints:\n+     * <pre>{@code\n+     * property1.bindContentBidirectional(property2);\n+     * property2.unbindContentBidirectional(property1);\n+     * }<\/pre>\n+     * The content of the wrapped map will remain unchanged.\n+     * If this property is not bidirectionally content-bound, calling this method has no effect.\n@@ -74,3 +83,4 @@\n-     * @param object the {@code Object} to which the bidirectional binding should be removed\n-     * @throws NullPointerException if {@code object} is {@code null}\n-     * @throws IllegalArgumentException if {@code object} is the same map that this {@code ReadOnlyMapProperty} points to\n+     * @param other the {@code ObservableMap} to which the bidirectional content binding should be removed\n+     * @throws NullPointerException if {@code other} is {@code null}\n+     * @throws IllegalArgumentException if {@code other} is the map wrapped in this {@code ReadOnlyMapProperty}\n+     * @since 18\n@@ -78,2 +88,2 @@\n-    public void unbindContentBidirectional(Object object) {\n-        Bindings.unbindContentBidirectional(this, object);\n+    public void unbindContentBidirectional(ObservableMap<K, V> other) {\n+        BidirectionalContentBinding.unbind(this, other);\n@@ -83,2 +93,33 @@\n-     * Creates a content binding between the {@link javafx.collections.ObservableMap}, that is\n-     * wrapped in this {@code ReadOnlyMapProperty}, and another {@code ObservableMap}.\n+     * Removes the bidirectional content binding that was established with\n+     * {@link #bindContentBidirectional(ObservableMap)}.\n+     * <p>\n+     * Bidirectional content bindings can be removed by calling this method on either of the two endpoints:\n+     * <pre>{@code\n+     * property1.bindContentBidirectional(property2);\n+     * property2.unbindContentBidirectional(property1);\n+     * }<\/pre>\n+     * The content of the wrapped map will remain unchanged.\n+     * If this property is not bidirectionally content-bound, calling this method has no effect.\n+     *\n+     * @param other the {@code Object} to which the bidirectional content binding should be removed\n+     * @throws NullPointerException if {@code other} is {@code null}\n+     * @throws IllegalArgumentException if {@code other} is the map wrapped in this {@code ReadOnlyMapProperty}\n+     * @deprecated use {@link #unbindContentBidirectional(ObservableMap)} instead\n+     *\/\n+    @Deprecated(since = \"18\", forRemoval = true)\n+    public void unbindContentBidirectional(Object other) {\n+        Objects.requireNonNull(other);\n+        if (other instanceof ObservableMap<?, ?>) {\n+            BidirectionalContentBinding.unbind(this, (ObservableMap<K, V>)other);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a content binding between the {@link javafx.collections.ObservableMap} that is wrapped\n+     * in this {@code ReadOnlyMapProperty} (the <em>bound map<\/em>) and another {@code ObservableMap}\n+     * (the <em>source map<\/em>).\n+     * <p>\n+     * A content binding ensures that the content of the bound map is the same as that of the source map.\n+     * If the content of the source map changes, the content of the bound map will be updated automatically.\n+     * In contrast, a regular binding will replace the bound map instance with the source map instance,\n+     * which means that only a single map instance exists for both properties.\n@@ -86,3 +127,4 @@\n-     * A content binding ensures that the content of the wrapped {@code ObservableMaps} is the\n-     * same as that of the other map. If the content of the other map changes, the wrapped map will be updated\n-     * automatically. Once the wrapped list is bound to another map, you must not change it directly.\n+     * Once a content binding is established, the bound map becomes effectively read-only: any attempt to\n+     * change the content of the bound map by calling a mutating method of {@link ObservableMap} will cause\n+     * the content binding to fail. In this case, the content binding is removed because the bound map and\n+     * the source map may be out-of-sync.\n@@ -90,3 +132,3 @@\n-     * @param map the {@code ObservableMap} this property should be bound to\n-     * @throws NullPointerException if {@code map} is {@code null}\n-     * @throws IllegalArgumentException if {@code map} is the same map that this {@code ReadOnlyMapProperty} points to\n+     * @param source the source {@code ObservableMap} this property should be bound to\n+     * @throws NullPointerException if {@code source} is {@code null}\n+     * @throws IllegalArgumentException if {@code source} is the map wrapped in this {@code ReadOnlyMapProperty}\n@@ -94,2 +136,12 @@\n-    public void bindContent(ObservableMap<K, V> map) {\n-        Bindings.bindContent(this, map);\n+    public void bindContent(ObservableMap<K, V> source) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Deletes a content binding between the {@link javafx.collections.ObservableMap}, that is\n+     * wrapped in this {@code ReadOnlyMapProperty}, and another {@code Object}.\n+     *\n+     * @since 18\n+     *\/\n+    public void unbindContent() {\n+        throw new UnsupportedOperationException();\n@@ -105,0 +157,1 @@\n+     * @deprecated use {@link #unbindContent()} instead\n@@ -106,0 +159,1 @@\n+    @Deprecated(since = \"18\", forRemoval = true)\n@@ -107,1 +161,15 @@\n-        Bindings.unbindContent(this, object);\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Returns whether this property is bound by a unidirectional content binding that was\n+     * established by calling {@link #bindContent(ObservableMap)}.\n+     * <p>\n+     * Note that this method does not account for bidirectional content bindings that were\n+     * established by calling {@link #bindContentBidirectional(ObservableMap)}.\n+     *\n+     * @return whether this property is bound by a unidirectional content binding\n+     * @since 18\n+     *\/\n+    public boolean isContentBound() {\n+        return false;\n@@ -161,12 +229,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"ReadOnlyMapProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && !name.equals(\"\")) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, ReadOnlyMapProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyMapProperty.java","additions":101,"deletions":44,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.binding.ContentBinding;\n@@ -34,0 +35,2 @@\n+import java.util.Objects;\n+\n@@ -113,0 +116,12 @@\n+    @Override\n+    public void bindContent(ObservableMap<K, V> source) {\n+        ContentBinding.bind(this, source, helper);\n+    }\n+\n+    @Override\n+    public void unbindContent() {\n+        ContentBinding binding = MapExpressionHelper.getContentBinding(helper);\n+        if (binding != null && binding.isTarget(this)) {\n+            binding.dispose();\n+        }\n+    }\n@@ -114,0 +129,13 @@\n+    @Override\n+    public void unbindContent(Object object) {\n+        Objects.requireNonNull(object);\n+        if (object instanceof ObservableMap<?, ?>) {\n+            ContentBinding.unbind(this, (ObservableMap<? extends K, ? extends V>)object);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isContentBound() {\n+        ContentBinding binding = MapExpressionHelper.getContentBinding(helper);\n+        return binding != null && binding.isTarget(this);\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyMapPropertyBase.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.property.PropertyHelper;\n@@ -64,12 +65,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"ReadOnlyObjectProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && !name.equals(\"\")) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, ReadOnlyObjectProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyObjectProperty.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,2 @@\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.Set;\n-import javafx.beans.binding.Bindings;\n+import com.sun.javafx.binding.BidirectionalContentBinding;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -33,1 +31,0 @@\n-import javafx.collections.ObservableList;\n@@ -36,0 +33,3 @@\n+import java.util.Objects;\n+import java.util.Set;\n+\n@@ -56,2 +56,17 @@\n-     * Creates a bidirectional content binding of the {@link javafx.collections.ObservableSet}, that is\n-     * wrapped in this {@code ReadOnlySetProperty}, and another {@code ObservableSet}.\n+     * Creates a bidirectional content binding between the {@link javafx.collections.ObservableSet} that is\n+     * wrapped in this {@code ReadOnlySetProperty} and another {@code ObservableSet}.\n+     * <p>\n+     * A bidirectional content binding ensures that the content of the two sets is the same.\n+     * If the content of one of the sets changes, the content of the other set will be updated automatically.\n+     *\n+     * @param other the {@code ObservableSet} this property should be bound to\n+     * @throws NullPointerException if {@code other} is {@code null}\n+     * @throws IllegalArgumentException if {@code other} is the set wrapped in this {@code ReadOnlySetProperty}\n+     *\/\n+    public void bindContentBidirectional(ObservableSet<E> other) {\n+        BidirectionalContentBinding.bind(this, other);\n+    }\n+\n+    \/**\n+     * Removes the bidirectional content binding that was established with\n+     * {@link #bindContentBidirectional(ObservableSet)}.\n@@ -59,2 +74,7 @@\n-     * A bidirectional content binding ensures that the content of two {@code ObservableSets} is the\n-     * same. If the content of one of the sets changes, the other one will be updated automatically.\n+     * Bidirectional content bindings can be removed by calling this method on either of the two endpoints:\n+     * <pre>{@code\n+     * property1.bindContentBidirectional(property2);\n+     * property2.unbindContentBidirectional(property1);\n+     * }<\/pre>\n+     * The content of the wrapped set will remain unchanged.\n+     * If this property is not bidirectionally content-bound, calling this method has no effect.\n@@ -62,3 +82,4 @@\n-     * @param set the {@code ObservableSet} this property should be bound to\n-     * @throws NullPointerException if {@code set} is {@code null}\n-     * @throws IllegalArgumentException if {@code set} is the same set that this {@code ReadOnlySetProperty} points to\n+     * @param other the {@code ObservableSet} to which the bidirectional content binding should be removed\n+     * @throws NullPointerException if {@code other} is {@code null}\n+     * @throws IllegalArgumentException if {@code other} is the set wrapped in this {@code ReadOnlySetProperty}\n+     * @since 18\n@@ -66,2 +87,2 @@\n-    public void bindContentBidirectional(ObservableSet<E> set) {\n-        Bindings.bindContentBidirectional(this, set);\n+    public void unbindContentBidirectional(ObservableSet<E> other) {\n+        BidirectionalContentBinding.unbind(this, other);\n@@ -71,2 +92,10 @@\n-     * Deletes a bidirectional content binding between the {@link javafx.collections.ObservableSet}, that is\n-     * wrapped in this {@code ReadOnlySetProperty}, and another {@code Object}.\n+     * Removes the bidirectional content binding that was established with\n+     * {@link #bindContentBidirectional(ObservableSet)}.\n+     * <p>\n+     * Bidirectional content bindings can be removed by calling this method on either of the two endpoints:\n+     * <pre>{@code\n+     * property1.bindContentBidirectional(property2);\n+     * property2.unbindContentBidirectional(property1);\n+     * }<\/pre>\n+     * The content of the wrapped set will remain unchanged.\n+     * If this property is not bidirectionally content-bound, calling this method has no effect.\n@@ -74,3 +103,4 @@\n-     * @param object the {@code Object} to which the bidirectional binding should be removed\n-     * @throws NullPointerException if {@code object} is {@code null}\n-     * @throws IllegalArgumentException if {@code object} is the same set that this {@code ReadOnlySetProperty} points to\n+     * @param other the {@code Object} to which the bidirectional content binding should be removed\n+     * @throws NullPointerException if {@code other} is {@code null}\n+     * @throws IllegalArgumentException if {@code other} is the set wrapped in this {@code ReadOnlySetProperty}\n+     * @deprecated use {@link #unbindContentBidirectional(ObservableSet)} instead\n@@ -78,2 +108,6 @@\n-    public void unbindContentBidirectional(Object object) {\n-        Bindings.unbindContentBidirectional(this, object);\n+    @Deprecated(since = \"18\", forRemoval = true)\n+    public void unbindContentBidirectional(Object other) {\n+        Objects.requireNonNull(other);\n+        if (other instanceof ObservableSet<?>) {\n+            BidirectionalContentBinding.unbind(this, (ObservableSet<E>)other);\n+        }\n@@ -83,2 +117,3 @@\n-     * Creates a content binding between the {@link javafx.collections.ObservableSet}, that is\n-     * wrapped in this {@code ReadOnlySetProperty}, and another {@code ObservableSet}.\n+     * Creates a content binding between the {@link javafx.collections.ObservableSet} that is wrapped\n+     * in this {@code ReadOnlySetProperty} (the <em>bound set<\/em>) and another {@code ObservableSet}\n+     * (the <em>source set<\/em>).\n@@ -86,3 +121,9 @@\n-     * A content binding ensures that the content of the wrapped {@code ObservableSets} is the\n-     * same as that of the other set. If the content of the other set changes, the wrapped set will be updated\n-     * automatically. Once the wrapped set is bound to another set, you must not change it directly.\n+     * A content binding ensures that the content of the bound set is the same as that of the source set.\n+     * If the content of the source set changes, the content of the bound set will be updated automatically.\n+     * In contrast, a regular binding will replace the bound set instance with the source set instance,\n+     * which means that only a single set instance exists for both properties.\n+     * <p>\n+     * Once a content binding is established, the bound set becomes effectively read-only: any attempt to\n+     * change the content of the bound set by calling a mutating method of {@link ObservableSet} will cause\n+     * the content binding to fail. In this case, the content binding is removed because the bound set and\n+     * the source set may be out-of-sync.\n@@ -90,3 +131,3 @@\n-     * @param set the {@code ObservableSet} this property should be bound to\n-     * @throws NullPointerException if {@code set} is {@code null}\n-     * @throws IllegalArgumentException if {@code set} is the same set that this {@code ReadOnlySetProperty} points to\n+     * @param source the source {@code ObservableSet} this property should be bound to\n+     * @throws NullPointerException if {@code source} is {@code null}\n+     * @throws IllegalArgumentException if {@code source} is the set wrapped in this {@code ReadOnlySetProperty}\n@@ -94,2 +135,2 @@\n-    public void bindContent(ObservableSet<E> set) {\n-        Bindings.bindContent(this, set);\n+    public void bindContent(ObservableSet<E> source) {\n+        throw new UnsupportedOperationException();\n@@ -99,2 +140,4 @@\n-     * Deletes a content binding between the {@link javafx.collections.ObservableSet}, that is\n-     * wrapped in this {@code ReadOnlySetProperty}, and another {@code Object}.\n+     * Removes the content binding that was established with {@link #bindContent(ObservableSet)}.\n+     * <p>\n+     * The content of the wrapped set will remain unchanged.\n+     * If this property is not content-bound, calling this method has no effect.\n@@ -102,3 +145,1 @@\n-     * @param object the {@code Object} to which the binding should be removed\n-     * @throws NullPointerException if {@code object} is {@code null}\n-     * @throws IllegalArgumentException if {@code object} is the same set that this {@code ReadOnlySetProperty} points to\n+     * @since 18\n@@ -106,2 +147,32 @@\n-    public void unbindContent(Object object) {\n-        Bindings.unbindContent(this, object);\n+    public void unbindContent() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Removes the content binding that was established with {@link #bindContent(ObservableSet)}.\n+     * <p>\n+     * The content of the wrapped set will remain unchanged.\n+     * If this property is not content-bound, calling this method has no effect.\n+     *\n+     * @param source the content binding source\n+     * @throws NullPointerException if {@code source} is {@code null}\n+     * @throws IllegalArgumentException if {@code source} is the set wrapped in this {@code ReadOnlySetProperty}\n+     * @deprecated use {@link #unbindContent()}\n+     *\/\n+    @Deprecated(since = \"18\", forRemoval = true)\n+    public void unbindContent(Object source) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/**\n+     * Returns whether this property is bound by a unidirectional content binding that was\n+     * established by calling {@link #bindContent(ObservableSet)}.\n+     * <p>\n+     * Note that this method does not account for bidirectional content bindings that were\n+     * established by calling {@link #bindContentBidirectional(ObservableSet)}.\n+     *\n+     * @return whether this property is unidirectionally content-bound\n+     * @since 18\n+     *\/\n+    public boolean isContentBound() {\n+        return false;\n@@ -149,12 +220,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"ReadOnlySetProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && !name.equals(\"\")) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, ReadOnlySetProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlySetProperty.java","additions":111,"deletions":51,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.binding.ContentBinding;\n@@ -34,0 +35,2 @@\n+import java.util.Objects;\n+\n@@ -115,0 +118,12 @@\n+    @Override\n+    public void bindContent(ObservableSet<E> source) {\n+        ContentBinding.bind(this, source, helper);\n+    }\n+\n+    @Override\n+    public void unbindContent() {\n+        ContentBinding binding = SetExpressionHelper.getContentBinding(helper);\n+        if (binding != null && binding.isTarget(this)) {\n+            binding.dispose();\n+        }\n+    }\n@@ -116,0 +131,13 @@\n+    @Override\n+    public void unbindContent(Object source) {\n+        Objects.requireNonNull(source);\n+        if (source instanceof ObservableSet<?>) {\n+            ContentBinding.unbind(this, (ObservableSet<? extends E>)source);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isContentBound() {\n+        ContentBinding binding = SetExpressionHelper.getContentBinding(helper);\n+        return binding != null && binding.isTarget(this);\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlySetPropertyBase.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.property.PropertyHelper;\n@@ -54,12 +55,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"ReadOnlyStringProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && !name.equals(\"\")) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, ReadOnlyStringProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyStringProperty.java","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-import javafx.beans.binding.Bindings;\n-import javafx.beans.value.WritableListValue;\n+import com.sun.javafx.binding.BidirectionalBinding;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -31,1 +31,0 @@\n-import javafx.collections.ObservableList;\n@@ -80,1 +79,1 @@\n-        Bindings.bindBidirectional(this, other);\n+        BidirectionalBinding.bind(this, other);\n@@ -88,1 +87,1 @@\n-        Bindings.unbindBidirectional(this, other);\n+        BidirectionalBinding.unbind(this, other);\n@@ -97,12 +96,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"SetProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, SetProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/SetProperty.java","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.javafx.beans.BeanErrors;\n+import com.sun.javafx.binding.ContentBinding;\n@@ -29,1 +31,1 @@\n-import java.lang.ref.WeakReference;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -38,0 +40,2 @@\n+import java.lang.ref.WeakReference;\n+\n@@ -227,2 +231,0 @@\n-\n-\n@@ -254,2 +256,5 @@\n-            throw new java.lang.RuntimeException((getBean() != null && getName() != null ?\n-                    getBean().getClass().getSimpleName() + \".\" + getName() + \" : \": \"\") + \"A bound value cannot be set.\");\n+            throw new IllegalStateException(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(this));\n+        }\n+\n+        if (isContentBound()) {\n+            throw new IllegalStateException(BeanErrors.CANNOT_SET_CONTENT_BOUND_PROPERTY.getMessage(this));\n@@ -257,0 +262,1 @@\n+\n@@ -270,4 +276,2 @@\n-    public void bind(final ObservableValue<? extends ObservableSet<E>> newObservable) {\n-        if (newObservable == null) {\n-            throw new NullPointerException(\"Cannot bind to null\");\n-        }\n+    public void bind(final ObservableValue<? extends ObservableSet<E>> source) {\n+        PropertyHelper.checkBind(this, source, helper);\n@@ -275,1 +279,1 @@\n-        if (newObservable != this.observable) {\n+        if (source != this.observable) {\n@@ -277,1 +281,1 @@\n-            observable = newObservable;\n+            observable = source;\n@@ -295,0 +299,26 @@\n+    @Override\n+    public void bindContent(ObservableSet<E> source) {\n+        ContentBinding.bind(this, source, helper);\n+    }\n+\n+    @Override\n+    public void unbindContent() {\n+        ContentBinding binding = SetExpressionHelper.getContentBinding(helper);\n+        if (binding != null && binding.isTarget(this)) {\n+            binding.dispose();\n+        }\n+    }\n+\n+    @Override\n+    public void unbindContent(Object source) {\n+        if (source instanceof ObservableSet<?>) {\n+            ContentBinding.unbind(this, (ObservableSet<E>)source);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isContentBound() {\n+        ContentBinding binding = SetExpressionHelper.getContentBinding(helper);\n+        return binding != null && binding.isTarget(this);\n+    }\n+\n@@ -301,21 +331,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\"SetProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        if (isBound()) {\n-            result.append(\"bound, \");\n-            if (valid) {\n-                result.append(\"value: \").append(get());\n-            } else {\n-                result.append(\"invalid\");\n-            }\n-        } else {\n-            result.append(\"value: \").append(get());\n-        }\n-        result.append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, SetProperty.class, valid);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/SetPropertyBase.java","additions":42,"deletions":32,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-import javafx.beans.binding.Bindings;\n+import com.sun.javafx.binding.BidirectionalBinding;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -32,1 +33,0 @@\n-\n@@ -79,1 +79,1 @@\n-        Bindings.bindBidirectional(this, other);\n+        BidirectionalBinding.bind(this, other);\n@@ -98,1 +98,1 @@\n-        Bindings.bindBidirectional(this, other, format);\n+        BidirectionalBinding.bind(this, other, format);\n@@ -118,1 +118,1 @@\n-        Bindings.bindBidirectional(this, other, converter);\n+        BidirectionalBinding.bind(this, other, converter);\n@@ -126,1 +126,1 @@\n-        Bindings.unbindBidirectional(this, other);\n+        BidirectionalBinding.unbind(this, other);\n@@ -138,2 +138,0 @@\n-     * @throws NullPointerException\n-     *             if {@code other} is {@code null}\n@@ -144,0 +142,1 @@\n+    @Deprecated(since = \"18\", forRemoval = true)\n@@ -145,1 +144,3 @@\n-        Bindings.unbindBidirectional(this, other);\n+        if (other instanceof Property<?>) {\n+            BidirectionalBinding.unbind(this, (Property<?>)other);\n+        }\n@@ -154,12 +155,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\n-                \"StringProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        result.append(\"value: \").append(get()).append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, StringProperty.class);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/StringProperty.java","additions":12,"deletions":22,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,5 @@\n+import java.lang.ref.WeakReference;\n+\n+import com.sun.javafx.beans.BeanErrors;\n+import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.property.PropertyHelper;\n@@ -30,0 +35,1 @@\n+import javafx.beans.WeakListener;\n@@ -33,4 +39,0 @@\n-import com.sun.javafx.binding.ExpressionHelper;\n-import java.lang.ref.WeakReference;\n-import javafx.beans.WeakListener;\n-\n@@ -140,2 +142,1 @@\n-            throw new java.lang.RuntimeException((getBean() != null && getName() != null ?\n-                    getBean().getClass().getSimpleName() + \".\" + getName() + \" : \": \"\") + \"A bound value cannot be set.\");\n+            throw new IllegalStateException(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(this));\n@@ -143,0 +144,1 @@\n+\n@@ -161,5 +163,4 @@\n-    public void bind(ObservableValue<? extends String> newObservable) {\n-        if (newObservable == null) {\n-            throw new NullPointerException(\"Cannot bind to null\");\n-        }\n-        if (!newObservable.equals(observable)) {\n+    public void bind(ObservableValue<? extends String> source) {\n+        PropertyHelper.checkBind(this, source, helper);\n+\n+        if (!source.equals(observable)) {\n@@ -167,1 +168,1 @@\n-            observable = newObservable;\n+            observable = source;\n@@ -194,21 +195,1 @@\n-        final Object bean = getBean();\n-        final String name = getName();\n-        final StringBuilder result = new StringBuilder(\"StringProperty [\");\n-        if (bean != null) {\n-            result.append(\"bean: \").append(bean).append(\", \");\n-        }\n-        if ((name != null) && (!name.equals(\"\"))) {\n-            result.append(\"name: \").append(name).append(\", \");\n-        }\n-        if (isBound()) {\n-            result.append(\"bound, \");\n-            if (valid) {\n-                result.append(\"value: \").append(get());\n-            } else {\n-                result.append(\"invalid\");\n-            }\n-        } else {\n-            result.append(\"value: \").append(get());\n-        }\n-        result.append(\"]\");\n-        return result.toString();\n+        return PropertyHelper.toString(this, StringProperty.class, valid);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/StringPropertyBase.java","additions":15,"deletions":34,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -161,2 +161,2 @@\n-    public void bind(ObservableValue<? extends Boolean> observable) {\n-        if (observable == null) {\n+    public void bind(ObservableValue<? extends Boolean> source) {\n+        if (source == null) {\n@@ -166,1 +166,1 @@\n-        if (!observable.equals(this.observable)) {\n+        if (!source.equals(this.observable)) {\n@@ -168,2 +168,2 @@\n-            set(observable.getValue());\n-            this.observable = observable;\n+            set(source.getValue());\n+            this.observable = source;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/adapter\/JavaBeanBooleanProperty.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -162,2 +162,2 @@\n-    public void bind(ObservableValue<? extends Number> observable) {\n-        if (observable == null) {\n+    public void bind(ObservableValue<? extends Number> source) {\n+        if (source == null) {\n@@ -167,1 +167,1 @@\n-        if (!observable.equals(this.observable)) {\n+        if (!source.equals(this.observable)) {\n@@ -169,2 +169,2 @@\n-            set(observable.getValue().doubleValue());\n-            this.observable = observable;\n+            set(source.getValue().doubleValue());\n+            this.observable = source;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/adapter\/JavaBeanDoubleProperty.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -161,2 +161,2 @@\n-    public void bind(ObservableValue<? extends Number> observable) {\n-        if (observable == null) {\n+    public void bind(ObservableValue<? extends Number> source) {\n+        if (source == null) {\n@@ -166,1 +166,1 @@\n-        if (!observable.equals(this.observable)) {\n+        if (!source.equals(this.observable)) {\n@@ -168,2 +168,2 @@\n-            set(observable.getValue().floatValue());\n-            this.observable = observable;\n+            set(source.getValue().floatValue());\n+            this.observable = source;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/adapter\/JavaBeanFloatProperty.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -161,2 +161,2 @@\n-    public void bind(ObservableValue<? extends Number> observable) {\n-        if (observable == null) {\n+    public void bind(ObservableValue<? extends Number> source) {\n+        if (source == null) {\n@@ -166,1 +166,1 @@\n-        if (!observable.equals(this.observable)) {\n+        if (!source.equals(this.observable)) {\n@@ -168,2 +168,2 @@\n-            set(observable.getValue().intValue());\n-            this.observable = observable;\n+            set(source.getValue().intValue());\n+            this.observable = source;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/adapter\/JavaBeanIntegerProperty.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -161,2 +161,2 @@\n-    public void bind(ObservableValue<? extends Number> observable) {\n-        if (observable == null) {\n+    public void bind(ObservableValue<? extends Number> source) {\n+        if (source == null) {\n@@ -166,1 +166,1 @@\n-        if (!observable.equals(this.observable)) {\n+        if (!source.equals(this.observable)) {\n@@ -168,2 +168,2 @@\n-            set(observable.getValue().longValue());\n-            this.observable = observable;\n+            set(source.getValue().longValue());\n+            this.observable = source;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/adapter\/JavaBeanLongProperty.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -164,2 +164,2 @@\n-    public void bind(ObservableValue<? extends T> observable) {\n-        if (observable == null) {\n+    public void bind(ObservableValue<? extends T> source) {\n+        if (source == null) {\n@@ -169,1 +169,1 @@\n-        if (!observable.equals(this.observable)) {\n+        if (!source.equals(this.observable)) {\n@@ -171,2 +171,2 @@\n-            set(observable.getValue());\n-            this.observable = observable;\n+            set(source.getValue());\n+            this.observable = source;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/adapter\/JavaBeanObjectProperty.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -160,2 +160,2 @@\n-    public void bind(ObservableValue<? extends String> observable) {\n-        if (observable == null) {\n+    public void bind(ObservableValue<? extends String> source) {\n+        if (source == null) {\n@@ -165,1 +165,1 @@\n-        if (!observable.equals(this.observable)) {\n+        if (!source.equals(this.observable)) {\n@@ -167,2 +167,2 @@\n-            set(observable.getValue());\n-            this.observable = observable;\n+            set(source.getValue());\n+            this.observable = source;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/adapter\/JavaBeanStringProperty.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.javafx.binding;\n-\n-public class ExpressionHelperBaseShim extends ExpressionHelperBase {\n-\n-    public static int trim(int size, Object[] listeners) {\n-        return ExpressionHelperBase.trim(size, listeners);\n-    }\n-\n-}\n","filename":"modules\/javafx.base\/src\/shims\/java\/com\/sun\/javafx\/binding\/ExpressionHelperBaseShim.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -2,0 +2,2 @@\n+--add-exports javafx.base\/com.sun.javafx=ALL-UNNAMED\n+--add-exports javafx.base\/com.sun.javafx.beans=ALL-UNNAMED\n","filename":"modules\/javafx.base\/src\/test\/addExports","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx;\n+\n+import com.sun.javafx.WeakListenerArrayUtil;\n+import static org.junit.Assert.*;\n+\n+import javafx.beans.WeakListener;\n+import org.junit.Test;\n+\n+public class WeakListenerArrayUtilTest {\n+\n+    private static final Object listener = new Object();\n+    private static final Object listener2 = new Object();\n+\n+    private static final WeakListener validWeakListener = () -> false;\n+\n+    private static final WeakListener gcedWeakListener = () -> true;\n+\n+    @Test\n+    public void testEmptyArray() {\n+        Object[] array = new Object[0];\n+        assertEquals(0, WeakListenerArrayUtil.trim(0, array));\n+        assertArrayEquals(new Object[0], array);\n+\n+        array = new Object[1];\n+        assertEquals(0, WeakListenerArrayUtil.trim(0, array));\n+        assertArrayEquals(new Object[1], array);\n+    }\n+\n+    @Test\n+    public void testSingleElement() {\n+        Object[] array = new Object[] {listener};\n+        assertEquals(1, WeakListenerArrayUtil.trim(1, array));\n+        assertArrayEquals(new Object[] {listener}, array);\n+\n+        array = new Object[] {validWeakListener};\n+        assertEquals(1, WeakListenerArrayUtil.trim(1, array));\n+        assertArrayEquals(new Object[] {validWeakListener}, array);\n+\n+        array = new Object[] {gcedWeakListener};\n+        assertEquals(0, WeakListenerArrayUtil.trim(1, array));\n+        assertArrayEquals(new Object[] {null}, array);\n+\n+        array = new Object[] {listener, null};\n+        assertEquals(1, WeakListenerArrayUtil.trim(1, array));\n+        assertArrayEquals(new Object[] {listener, null}, array);\n+\n+        array = new Object[] {validWeakListener, null};\n+        assertEquals(1, WeakListenerArrayUtil.trim(1, array));\n+        assertArrayEquals(new Object[] {validWeakListener, null}, array);\n+\n+        array = new Object[] {gcedWeakListener, null};\n+        assertEquals(0, WeakListenerArrayUtil.trim(1, array));\n+        assertArrayEquals(new Object[] {null, null}, array);\n+    }\n+\n+    @Test\n+    public void testMultipleElements() {\n+        Object[] array = new Object[] {validWeakListener, listener, listener2};\n+        assertEquals(3, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {validWeakListener, listener, listener2}, array);\n+\n+        array = new Object[] {listener, validWeakListener, listener2};\n+        assertEquals(3, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {listener, validWeakListener, listener2}, array);\n+\n+        array = new Object[] {listener, listener2, validWeakListener};\n+        assertEquals(3, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {listener, listener2, validWeakListener}, array);\n+\n+        array = new Object[] {validWeakListener, listener, listener2, null};\n+        assertEquals(3, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {validWeakListener, listener, listener2, null}, array);\n+\n+        array = new Object[] {listener, validWeakListener, listener2, null};\n+        assertEquals(3, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {listener, validWeakListener, listener2, null}, array);\n+\n+        array = new Object[] {listener, listener2, validWeakListener, null};\n+        assertEquals(3, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {listener, listener2, validWeakListener, null}, array);\n+\n+        array = new Object[] {gcedWeakListener, validWeakListener, listener};\n+        assertEquals(2, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {validWeakListener, listener, null}, array);\n+\n+        array = new Object[] {gcedWeakListener, listener, validWeakListener};\n+        assertEquals(2, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {listener, validWeakListener, null}, array);\n+\n+        array = new Object[] {gcedWeakListener, validWeakListener, listener, null};\n+        assertEquals(2, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {validWeakListener, listener, null, null}, array);\n+\n+        array = new Object[] {gcedWeakListener, listener, validWeakListener, null};\n+        assertEquals(2, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {listener, validWeakListener, null, null}, array);\n+\n+\n+        array = new Object[] {validWeakListener, gcedWeakListener, listener};\n+        assertEquals(2, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {validWeakListener, listener, null}, array);\n+\n+        array = new Object[] {listener, gcedWeakListener, validWeakListener};\n+        assertEquals(2, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {listener, validWeakListener, null}, array);\n+\n+        array = new Object[] {validWeakListener, gcedWeakListener, listener, null};\n+        assertEquals(2, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {validWeakListener, listener, null, null}, array);\n+\n+        array = new Object[] {listener, gcedWeakListener, validWeakListener, null};\n+        assertEquals(2, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {listener, validWeakListener, null, null}, array);\n+\n+\n+        array = new Object[] {validWeakListener, listener, gcedWeakListener};\n+        assertEquals(2, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {validWeakListener, listener, null}, array);\n+\n+        array = new Object[] {listener, validWeakListener, gcedWeakListener};\n+        assertEquals(2, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {listener, validWeakListener, null}, array);\n+\n+        array = new Object[] {validWeakListener, listener, gcedWeakListener, null};\n+        assertEquals(2, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {validWeakListener, listener, null, null}, array);\n+\n+        array = new Object[] {listener, validWeakListener, gcedWeakListener, null};\n+        assertEquals(2, WeakListenerArrayUtil.trim(3, array));\n+        assertArrayEquals(new Object[] {listener, validWeakListener, null, null}, array);\n+\n+\n+        array = new Object[] {gcedWeakListener, gcedWeakListener};\n+        assertEquals(0, WeakListenerArrayUtil.trim(2, array));\n+        assertArrayEquals(new Object[] {null, null}, array);\n+\n+        array = new Object[] {gcedWeakListener, gcedWeakListener, null};\n+        assertEquals(0, WeakListenerArrayUtil.trim(2, array));\n+        assertArrayEquals(new Object[] {null, null, null}, array);\n+    }\n+\n+\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/WeakListenerArrayUtilTest.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -41,0 +42,1 @@\n+import static test.util.MoreAssertions.*;\n@@ -244,1 +246,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -246,1 +248,2 @@\n-        Bindings.bindBidirectional(null, op2);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.bindBidirectional(null, op2));\n+        assertEquals(BeanErrors.BINDING_TARGET_NULL.getMessage(), ex.getMessage());\n@@ -249,1 +252,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -251,1 +254,2 @@\n-        Bindings.bindBidirectional(op1, null);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.bindBidirectional(op1, null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(op1), ex.getMessage());\n@@ -254,1 +258,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -256,1 +260,2 @@\n-        Bindings.bindBidirectional(op1, op1);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> Bindings.bindBidirectional(op1, op1));\n+        assertEquals(BeanErrors.CANNOT_BIND_PROPERTY_TO_ITSELF.getMessage(op1), ex.getMessage());\n@@ -259,1 +264,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -261,1 +266,2 @@\n-        Bindings.unbindBidirectional(null, op2);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.unbindBidirectional(null, op2));\n+        assertEquals(BeanErrors.BINDING_TARGET_NULL.getMessage(), ex.getMessage());\n@@ -264,1 +270,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -266,1 +272,2 @@\n-        Bindings.unbindBidirectional(op1, null);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.unbindBidirectional(op1, null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(op1), ex.getMessage());\n@@ -269,1 +276,1 @@\n-    @Test(expected=IllegalArgumentException.class)\n+    @Test\n@@ -271,1 +278,2 @@\n-        Bindings.unbindBidirectional(op1, op1);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> Bindings.unbindBidirectional(op1, op1));\n+        assertEquals(BeanErrors.CANNOT_UNBIND_PROPERTY_FROM_ITSELF.getMessage(op1), ex.getMessage());\n@@ -275,9 +283,4 @@\n-    public void testBrokenBind() {\n-        Bindings.bindBidirectional(op1, op2);\n-        op1.bind(op3);\n-        assertEquals(op3.getValue(), op1.getValue());\n-        assertEquals(op2.getValue(), op1.getValue());\n-\n-        op2.setValue(v[2]);\n-        assertEquals(op3.getValue(), op1.getValue());\n-        assertEquals(op2.getValue(), op1.getValue());\n+    public void testBind_UnboundX_BoundY() {\n+        op3.bind(op4);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> Bindings.bindBidirectional(op1, op3));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(op3), ex.getMessage());\n@@ -287,15 +290,4 @@\n-    public void testDoubleBrokenBind() {\n-        Bindings.bindBidirectional(op1, op2);\n-        op1.bind(op3);\n-        op4.setValue(v[0]);\n-\n-        op2.bind(op4);\n-        assertEquals(op4.getValue(), op2.getValue());\n-        assertEquals(op3.getValue(), op1.getValue());\n-        \/\/ Test that bidirectional binding was unbound in this case\n-        op3.setValue(v[0]);\n-        op4.setValue(v[1]);\n-        assertEquals(op4.getValue(), op2.getValue());\n-        assertEquals(op3.getValue(), op1.getValue());\n-        assertEquals(v[0], op1.getValue());\n-        assertEquals(v[1], op2.getValue());\n+    public void testBind_BoundX_UnboundY() {\n+        op1.bind(op2);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> Bindings.bindBidirectional(op1, op3));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(op1), ex.getMessage());\n@@ -324,14 +316,14 @@\n-            { new Factory(() -> new SimpleBooleanProperty(), booleanData) },\n-            { new Factory(() -> new SimpleDoubleProperty(), doubleData) },\n-            { new Factory(() -> new SimpleFloatProperty(), floatData) },\n-            { new Factory(() -> new SimpleIntegerProperty(), integerData) },\n-            { new Factory(() -> new SimpleLongProperty(), longData) },\n-            { new Factory(() -> new SimpleObjectProperty<>(), objectData) },\n-            { new Factory(() -> new SimpleStringProperty(), stringData) },\n-            { new Factory(() -> new ReadOnlyBooleanWrapper(), booleanData) },\n-            { new Factory(() -> new ReadOnlyDoubleWrapper(), doubleData) },\n-            { new Factory(() -> new ReadOnlyFloatWrapper(), floatData) },\n-            { new Factory(() -> new ReadOnlyIntegerWrapper(), integerData) },\n-            { new Factory(() -> new ReadOnlyLongWrapper(), longData) },\n-            { new Factory(() -> new ReadOnlyObjectWrapper<>(), objectData) },\n-            { new Factory(() -> new ReadOnlyStringWrapper(), stringData) },\n+            { new Factory(() -> new SimpleBooleanProperty(BEAN, nextName()), booleanData) },\n+            { new Factory(() -> new SimpleDoubleProperty(BEAN, nextName()), doubleData) },\n+            { new Factory(() -> new SimpleFloatProperty(BEAN, nextName()), floatData) },\n+            { new Factory(() -> new SimpleIntegerProperty(BEAN, nextName()), integerData) },\n+            { new Factory(() -> new SimpleLongProperty(BEAN, nextName()), longData) },\n+            { new Factory(() -> new SimpleObjectProperty<>(BEAN, nextName()), objectData) },\n+            { new Factory(() -> new SimpleStringProperty(BEAN, nextName()), stringData) },\n+            { new Factory(() -> new ReadOnlyBooleanWrapper(BEAN, nextName()), booleanData) },\n+            { new Factory(() -> new ReadOnlyDoubleWrapper(BEAN, nextName()), doubleData) },\n+            { new Factory(() -> new ReadOnlyFloatWrapper(BEAN, nextName()), floatData) },\n+            { new Factory(() -> new ReadOnlyIntegerWrapper(BEAN, nextName()), integerData) },\n+            { new Factory(() -> new ReadOnlyLongWrapper(BEAN, nextName()), longData) },\n+            { new Factory(() -> new ReadOnlyObjectWrapper<>(BEAN, nextName()), objectData) },\n+            { new Factory(() -> new ReadOnlyStringWrapper(BEAN, nextName()), stringData) },\n@@ -340,0 +332,6 @@\n+\n+    private static final Object BEAN = new Object() {};\n+\n+    private static String nextName() {\n+        return Integer.toHexString((int)Double.doubleToLongBits(Math.random())).toUpperCase();\n+    }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/BidirectionalBindingTest.java","additions":48,"deletions":50,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.ref.WeakReference;\n@@ -41,0 +42,1 @@\n+import java.util.ArrayList;\n@@ -44,0 +46,1 @@\n+import java.util.List;\n@@ -55,1 +58,1 @@\n-        void unbind(Object obj0, Object obj1);\n+        void unbind(PropertyMock<?> obj0, PropertyMock<?> obj1);\n@@ -209,2 +212,2 @@\n-                    public void unbind(Object op0, Object op1) {\n-                        Bindings.unbindBidirectional(op0, op1);\n+                    public void unbind(PropertyMock<?> op0, PropertyMock<?> op1) {\n+                        BidirectionalBinding.unbind(op0, op1);\n@@ -246,2 +249,2 @@\n-                    public void unbind(Object op0, Object op1) {\n-                        Bindings.unbindBidirectional(op0, op1);\n+                    public void unbind(PropertyMock<?> op0, PropertyMock<?> op1) {\n+                        BidirectionalBinding.unbind(op0, op1);\n@@ -276,1 +279,1 @@\n-        private int listenerCount = 0;\n+        private final List<WeakReference<InvalidationListener>> listeners = new ArrayList<>();\n@@ -280,1 +283,2 @@\n-            return listenerCount;\n+            listeners.removeIf(ref -> ref.get() == null);\n+            return listeners.size();\n@@ -286,1 +290,1 @@\n-            listenerCount++;\n+            listeners.add(new WeakReference<>(listener));\n@@ -292,1 +296,7 @@\n-            listenerCount--;\n+            var it = listeners.listIterator();\n+            while (it.hasNext()) {\n+                if (it.next().get() == listener) {\n+                    it.remove();\n+                    return;\n+                }\n+            }\n@@ -298,1 +308,1 @@\n-        private int listenerCount = 0;\n+        private final List<WeakReference<InvalidationListener>> listeners = new ArrayList<>();\n@@ -302,1 +312,2 @@\n-            return listenerCount;\n+            listeners.removeIf(ref -> ref.get() == null);\n+            return listeners.size();\n@@ -308,1 +319,1 @@\n-            listenerCount++;\n+            listeners.add(new WeakReference<>(listener));\n@@ -314,1 +325,7 @@\n-            listenerCount--;\n+            var it = listeners.listIterator();\n+            while (it.hasNext()) {\n+                if (it.next().get() == listener) {\n+                    it.remove();\n+                    return;\n+                }\n+            }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/BidirectionalBindingWithConversionTest.java","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -40,0 +41,1 @@\n+import static test.util.MoreAssertions.assertThrows;\n@@ -283,5 +285,0 @@\n-    @Test\n-    public void testUnbindWrongMethod() {\n-        Bindings.bindContentBidirectional(op1, op2);\n-        Bindings.unbindBidirectional(op1, op2);\n-    }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/BidirectionalContentBindingListTest.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -40,0 +41,1 @@\n+import static test.util.MoreAssertions.*;\n@@ -87,1 +89,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -89,1 +91,2 @@\n-        Bindings.bindContent(null, op2);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.bindContent(null, op2));\n+        assertEquals(BeanErrors.BINDING_TARGET_NULL.getMessage(), ex.getMessage());\n@@ -92,1 +95,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -94,1 +97,2 @@\n-        Bindings.bindContent(op1, null);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.bindContent(op1, null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(), ex.getMessage());\n@@ -97,1 +101,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -99,1 +103,2 @@\n-        Bindings.bindContent(op2, op2);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> Bindings.bindContent(op2, op2));\n+        assertEquals(BeanErrors.CANNOT_BIND_COLLECTION_TO_ITSELF.getMessage(), ex.getMessage());\n@@ -126,1 +131,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -128,1 +133,2 @@\n-        Bindings.unbindContent(null, op2);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.unbindContent(null, op2));\n+        assertEquals(BeanErrors.BINDING_TARGET_NULL.getMessage(), ex.getMessage());\n@@ -131,1 +137,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -133,1 +139,2 @@\n-        Bindings.unbindContent(op1, null);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.unbindContent(op1, null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(), ex.getMessage());\n@@ -136,1 +143,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -138,1 +145,2 @@\n-        Bindings.unbindContent(op2, op2);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> Bindings.unbindContent(op2, op2));\n+        assertEquals(BeanErrors.CANNOT_UNBIND_COLLECTION_FROM_ITSELF.getMessage(), ex.getMessage());\n@@ -231,0 +239,23 @@\n+\n+    @Test\n+    public void testContentBoundListThrowsExceptionWhenModified() {\n+        var target = FXCollections.observableArrayList();\n+        var source = FXCollections.observableArrayList(\"foo\", \"bar\");\n+        ContentBinding.bind(target, source);\n+\n+        var exceptions = new ArrayList<Throwable>();\n+        var oldHandler = Thread.currentThread().getUncaughtExceptionHandler();\n+        Thread.currentThread().setUncaughtExceptionHandler((t, e) -> exceptions.add(e));\n+\n+        try {\n+            source.add(\"qux\");\n+            assertEquals(0, exceptions.size());\n+\n+            target.remove(0);\n+            assertEquals(1, exceptions.size());\n+            assertEquals(BeanErrors.ILLEGAL_LIST_MODIFICATION.getMessage(), exceptions.get(0).getMessage());\n+        } finally {\n+            Thread.currentThread().setUncaughtExceptionHandler(oldHandler);\n+        }\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ContentBindingListTest.java","additions":44,"deletions":13,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -35,0 +36,1 @@\n+import java.util.ArrayList;\n@@ -39,0 +41,1 @@\n+import static test.util.MoreAssertions.*;\n@@ -90,1 +93,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -92,1 +95,2 @@\n-        Bindings.bindContent(null, op2);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.bindContent(null, op2));\n+        assertEquals(BeanErrors.BINDING_TARGET_NULL.getMessage(), ex.getMessage());\n@@ -95,1 +99,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -97,1 +101,2 @@\n-        Bindings.bindContent(op1, null);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.bindContent(op1, null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(), ex.getMessage());\n@@ -100,1 +105,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -102,1 +107,2 @@\n-        Bindings.bindContent(op2, op2);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> Bindings.bindContent(op2, op2));\n+        assertEquals(BeanErrors.CANNOT_BIND_COLLECTION_TO_ITSELF.getMessage(), ex.getMessage());\n@@ -130,1 +136,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -132,1 +138,2 @@\n-        Bindings.unbindContent(null, op2);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.unbindContent(null, op2));\n+        assertEquals(BeanErrors.BINDING_TARGET_NULL.getMessage(), ex.getMessage());\n@@ -135,1 +142,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -137,1 +144,2 @@\n-        Bindings.unbindContent(op1, null);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.unbindContent(op1, null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(), ex.getMessage());\n@@ -140,1 +148,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -142,1 +150,2 @@\n-        Bindings.unbindContent(op2, op2);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> Bindings.unbindContent(op2, op2));\n+        assertEquals(BeanErrors.CANNOT_UNBIND_COLLECTION_FROM_ITSELF.getMessage(), ex.getMessage());\n@@ -218,0 +227,23 @@\n+\n+    @Test\n+    public void testContentBoundMapThrowsExceptionWhenModified() {\n+        var target = FXCollections.observableHashMap();\n+        var source = FXCollections.observableHashMap();\n+        ContentBinding.bind(target, source);\n+\n+        var exceptions = new ArrayList<Throwable>();\n+        var oldHandler = Thread.currentThread().getUncaughtExceptionHandler();\n+        Thread.currentThread().setUncaughtExceptionHandler((t, e) -> exceptions.add(e));\n+\n+        try {\n+            source.put(\"foo\", \"bar\");\n+            assertEquals(0, exceptions.size());\n+\n+            target.remove(\"foo\");\n+            assertEquals(1, exceptions.size());\n+            assertEquals(BeanErrors.ILLEGAL_MAP_MODIFICATION.getMessage(), exceptions.get(0).getMessage());\n+        } finally {\n+            Thread.currentThread().setUncaughtExceptionHandler(oldHandler);\n+        }\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ContentBindingMapTest.java","additions":45,"deletions":13,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -35,0 +36,1 @@\n+import java.util.ArrayList;\n@@ -39,0 +41,1 @@\n+import static test.util.MoreAssertions.*;\n@@ -86,1 +89,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -88,1 +91,2 @@\n-        Bindings.bindContent(null, op2);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.bindContent(null, op2));\n+        assertEquals(BeanErrors.BINDING_TARGET_NULL.getMessage(), ex.getMessage());\n@@ -91,1 +95,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -93,1 +97,2 @@\n-        Bindings.bindContent(op1, null);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.bindContent(op1, null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(), ex.getMessage());\n@@ -96,1 +101,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -98,1 +103,2 @@\n-        Bindings.bindContent(op2, op2);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> Bindings.bindContent(op2, op2));\n+        assertEquals(BeanErrors.CANNOT_BIND_COLLECTION_TO_ITSELF.getMessage(), ex.getMessage());\n@@ -126,1 +132,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -128,1 +134,2 @@\n-        Bindings.unbindContent(null, op2);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.unbindContent(null, op2));\n+        assertEquals(BeanErrors.BINDING_TARGET_NULL.getMessage(), ex.getMessage());\n@@ -131,1 +138,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -133,1 +140,2 @@\n-        Bindings.unbindContent(op1, null);\n+        var ex = assertThrows(NullPointerException.class, () -> Bindings.unbindContent(op1, null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(), ex.getMessage());\n@@ -136,1 +144,1 @@\n-    @Test(expected = IllegalArgumentException.class)\n+    @Test\n@@ -138,1 +146,2 @@\n-        Bindings.unbindContent(op2, op2);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> Bindings.unbindContent(op2, op2));\n+        assertEquals(BeanErrors.CANNOT_UNBIND_COLLECTION_FROM_ITSELF.getMessage(), ex.getMessage());\n@@ -206,0 +215,23 @@\n+\n+    @Test\n+    public void testContentBoundSetThrowsExceptionWhenModified() {\n+        var target = FXCollections.observableSet();\n+        var source = FXCollections.observableSet();\n+        ContentBinding.bind(target, source);\n+\n+        var exceptions = new ArrayList<Throwable>();\n+        var oldHandler = Thread.currentThread().getUncaughtExceptionHandler();\n+        Thread.currentThread().setUncaughtExceptionHandler((t, e) -> exceptions.add(e));\n+\n+        try {\n+            source.add(\"qux\");\n+            assertEquals(0, exceptions.size());\n+\n+            target.remove(\"qux\");\n+            assertEquals(1, exceptions.size());\n+            assertEquals(BeanErrors.ILLEGAL_SET_MODIFICATION.getMessage(), exceptions.get(0).getMessage());\n+        } finally {\n+            Thread.currentThread().setUncaughtExceptionHandler(oldHandler);\n+        }\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ContentBindingSetTest.java","additions":45,"deletions":13,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1,168 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package test.com.sun.javafx.binding;\n-\n-import com.sun.javafx.binding.ExpressionHelperBaseShim;\n-import static org.junit.Assert.*;\n-\n-import javafx.beans.WeakListener;\n-import org.junit.Test;\n-\n-public class ExpressionHelperBaseTest {\n-\n-    private static final Object listener = new Object();\n-    private static final Object listener2 = new Object();\n-\n-    private static final WeakListener validWeakListener = () -> false;\n-\n-    private static final WeakListener gcedWeakListener = () -> true;\n-\n-    @Test\n-    public void testEmptyArray() {\n-        Object[] array = new Object[0];\n-        assertEquals(0, ExpressionHelperBaseShim.trim(0, array));\n-        assertArrayEquals(new Object[0], array);\n-\n-        array = new Object[1];\n-        assertEquals(0, ExpressionHelperBaseShim.trim(0, array));\n-        assertArrayEquals(new Object[1], array);\n-    }\n-\n-    @Test\n-    public void testSingleElement() {\n-        Object[] array = new Object[] {listener};\n-        assertEquals(1, ExpressionHelperBaseShim.trim(1, array));\n-        assertArrayEquals(new Object[] {listener}, array);\n-\n-        array = new Object[] {validWeakListener};\n-        assertEquals(1, ExpressionHelperBaseShim.trim(1, array));\n-        assertArrayEquals(new Object[] {validWeakListener}, array);\n-\n-        array = new Object[] {gcedWeakListener};\n-        assertEquals(0, ExpressionHelperBaseShim.trim(1, array));\n-        assertArrayEquals(new Object[] {null}, array);\n-\n-        array = new Object[] {listener, null};\n-        assertEquals(1, ExpressionHelperBaseShim.trim(1, array));\n-        assertArrayEquals(new Object[] {listener, null}, array);\n-\n-        array = new Object[] {validWeakListener, null};\n-        assertEquals(1, ExpressionHelperBaseShim.trim(1, array));\n-        assertArrayEquals(new Object[] {validWeakListener, null}, array);\n-\n-        array = new Object[] {gcedWeakListener, null};\n-        assertEquals(0, ExpressionHelperBaseShim.trim(1, array));\n-        assertArrayEquals(new Object[] {null, null}, array);\n-    }\n-\n-    @Test\n-    public void testMultipleElements() {\n-        Object[] array = new Object[] {validWeakListener, listener, listener2};\n-        assertEquals(3, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {validWeakListener, listener, listener2}, array);\n-\n-        array = new Object[] {listener, validWeakListener, listener2};\n-        assertEquals(3, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {listener, validWeakListener, listener2}, array);\n-\n-        array = new Object[] {listener, listener2, validWeakListener};\n-        assertEquals(3, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {listener, listener2, validWeakListener}, array);\n-\n-        array = new Object[] {validWeakListener, listener, listener2, null};\n-        assertEquals(3, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {validWeakListener, listener, listener2, null}, array);\n-\n-        array = new Object[] {listener, validWeakListener, listener2, null};\n-        assertEquals(3, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {listener, validWeakListener, listener2, null}, array);\n-\n-        array = new Object[] {listener, listener2, validWeakListener, null};\n-        assertEquals(3, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {listener, listener2, validWeakListener, null}, array);\n-\n-        array = new Object[] {gcedWeakListener, validWeakListener, listener};\n-        assertEquals(2, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {validWeakListener, listener, null}, array);\n-\n-        array = new Object[] {gcedWeakListener, listener, validWeakListener};\n-        assertEquals(2, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {listener, validWeakListener, null}, array);\n-\n-        array = new Object[] {gcedWeakListener, validWeakListener, listener, null};\n-        assertEquals(2, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {validWeakListener, listener, null, null}, array);\n-\n-        array = new Object[] {gcedWeakListener, listener, validWeakListener, null};\n-        assertEquals(2, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {listener, validWeakListener, null, null}, array);\n-\n-\n-        array = new Object[] {validWeakListener, gcedWeakListener, listener};\n-        assertEquals(2, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {validWeakListener, listener, null}, array);\n-\n-        array = new Object[] {listener, gcedWeakListener, validWeakListener};\n-        assertEquals(2, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {listener, validWeakListener, null}, array);\n-\n-        array = new Object[] {validWeakListener, gcedWeakListener, listener, null};\n-        assertEquals(2, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {validWeakListener, listener, null, null}, array);\n-\n-        array = new Object[] {listener, gcedWeakListener, validWeakListener, null};\n-        assertEquals(2, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {listener, validWeakListener, null, null}, array);\n-\n-\n-        array = new Object[] {validWeakListener, listener, gcedWeakListener};\n-        assertEquals(2, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {validWeakListener, listener, null}, array);\n-\n-        array = new Object[] {listener, validWeakListener, gcedWeakListener};\n-        assertEquals(2, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {listener, validWeakListener, null}, array);\n-\n-        array = new Object[] {validWeakListener, listener, gcedWeakListener, null};\n-        assertEquals(2, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {validWeakListener, listener, null, null}, array);\n-\n-        array = new Object[] {listener, validWeakListener, gcedWeakListener, null};\n-        assertEquals(2, ExpressionHelperBaseShim.trim(3, array));\n-        assertArrayEquals(new Object[] {listener, validWeakListener, null, null}, array);\n-\n-\n-        array = new Object[] {gcedWeakListener, gcedWeakListener};\n-        assertEquals(0, ExpressionHelperBaseShim.trim(2, array));\n-        assertArrayEquals(new Object[] {null, null}, array);\n-\n-        array = new Object[] {gcedWeakListener, gcedWeakListener, null};\n-        assertEquals(0, ExpressionHelperBaseShim.trim(2, array));\n-        assertArrayEquals(new Object[] {null, null, null}, array);\n-    }\n-\n-\n-}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ExpressionHelperBaseTest.java","additions":0,"deletions":168,"binary":false,"changes":168,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -34,0 +35,1 @@\n+import static test.util.MoreAssertions.*;\n@@ -204,1 +206,1 @@\n-    @Test(expected=RuntimeException.class)\n+    @Test\n@@ -208,1 +210,2 @@\n-        property.set(true);\n+        var ex = assertThrows(RuntimeException.class, () -> property.set(true));\n+        assertEquals(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(v), ex.getMessage());\n@@ -351,1 +354,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -353,1 +356,8 @@\n-        property.bind(null);\n+        var ex = assertThrows(NullPointerException.class, () -> property.bind(null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(property), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindToSelf() {\n+        var ex = assertThrows(IllegalArgumentException.class, () -> property.bind(property));\n+        assertEquals(BeanErrors.CANNOT_BIND_PROPERTY_TO_ITSELF.getMessage(property), ex.getMessage());\n@@ -421,0 +431,28 @@\n+    @Test\n+    public void testBindBidirectional_targetIsBound() {\n+        var target = new SimpleBooleanProperty(this, \"target\");\n+        var source = new SimpleBooleanProperty(this, \"source\");\n+        target.bind(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindBidirectional_sourceIsBound() {\n+        var target = new SimpleBooleanProperty(this, \"target\");\n+        var source = new SimpleBooleanProperty(this, \"source\");\n+        var other = new SimpleBooleanProperty(this, \"other\");\n+        source.bind(other);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(source), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBind_targetIsBoundBidirectionally() {\n+        var target = new SimpleBooleanProperty(this, \"target\");\n+        var source = new SimpleBooleanProperty(this, \"source\");\n+        target.bindBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bind(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/BooleanPropertyBaseTest.java","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -195,1 +195,0 @@\n-            fail(\"Not in use\");\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/BooleanPropertyTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -34,0 +35,1 @@\n+import static test.util.MoreAssertions.*;\n@@ -205,1 +207,1 @@\n-    @Test(expected=RuntimeException.class)\n+    @Test\n@@ -209,1 +211,2 @@\n-        property.set(Math.PI);\n+        var ex = assertThrows(RuntimeException.class, () -> property.set(Math.PI));\n+        assertEquals(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(v), ex.getMessage());\n@@ -356,1 +359,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -358,1 +361,8 @@\n-        property.bind(null);\n+        var ex = assertThrows(NullPointerException.class, () -> property.bind(null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(property), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindToSelf() {\n+        var ex = assertThrows(IllegalArgumentException.class, () -> property.bind(property));\n+        assertEquals(BeanErrors.CANNOT_BIND_PROPERTY_TO_ITSELF.getMessage(property), ex.getMessage());\n@@ -454,0 +464,28 @@\n+    @Test\n+    public void testBindBidirectional_targetIsBound() {\n+        var target = new SimpleDoubleProperty(this, \"target\");\n+        var source = new SimpleDoubleProperty(this, \"source\");\n+        target.bind(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindBidirectional_sourceIsBound() {\n+        var target = new SimpleDoubleProperty(this, \"target\");\n+        var source = new SimpleDoubleProperty(this, \"source\");\n+        var other = new SimpleDoubleProperty(this, \"other\");\n+        source.bind(other);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(source), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBind_targetIsBoundBidirectionally() {\n+        var target = new SimpleDoubleProperty(this, \"target\");\n+        var source = new SimpleDoubleProperty(this, \"source\");\n+        target.bindBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bind(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/DoublePropertyBaseTest.java","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -197,1 +197,0 @@\n-            fail(\"Not in use\");\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/DoublePropertyTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -34,0 +35,1 @@\n+import static test.util.MoreAssertions.*;\n@@ -207,1 +209,1 @@\n-    @Test(expected=RuntimeException.class)\n+    @Test\n@@ -211,1 +213,2 @@\n-        property.set(PI);\n+        var ex = assertThrows(RuntimeException.class, () -> property.set(PI));\n+        assertEquals(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(v), ex.getMessage());\n@@ -360,1 +363,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -362,1 +365,8 @@\n-        property.bind(null);\n+        var ex = assertThrows(NullPointerException.class, () -> property.bind(null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(property), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindToSelf() {\n+        var ex = assertThrows(IllegalArgumentException.class, () -> property.bind(property));\n+        assertEquals(BeanErrors.CANNOT_BIND_PROPERTY_TO_ITSELF.getMessage(property), ex.getMessage());\n@@ -458,0 +468,28 @@\n+    @Test\n+    public void testBindBidirectional_targetIsBound() {\n+        var target = new SimpleFloatProperty(this, \"target\");\n+        var source = new SimpleFloatProperty(this, \"source\");\n+        target.bind(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindBidirectional_sourceIsBound() {\n+        var target = new SimpleFloatProperty(this, \"target\");\n+        var source = new SimpleFloatProperty(this, \"source\");\n+        var other = new SimpleFloatProperty(this, \"other\");\n+        source.bind(other);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(source), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBind_targetIsBoundBidirectionally() {\n+        var target = new SimpleFloatProperty(this, \"target\");\n+        var source = new SimpleFloatProperty(this, \"source\");\n+        target.bindBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bind(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/FloatPropertyBaseTest.java","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -197,1 +197,0 @@\n-            fail(\"Not in use\");\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/FloatPropertyTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -34,0 +35,1 @@\n+import static test.util.MoreAssertions.*;\n@@ -206,1 +208,1 @@\n-    @Test(expected=RuntimeException.class)\n+    @Test\n@@ -210,1 +212,2 @@\n-        property.set(VALUE_1);\n+        var ex = assertThrows(RuntimeException.class, () -> property.set(VALUE_1));\n+        assertEquals(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(v), ex.getMessage());\n@@ -351,1 +354,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -353,1 +356,8 @@\n-        property.bind(null);\n+        var ex = assertThrows(NullPointerException.class, () -> property.bind(null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(property), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindToSelf() {\n+        var ex = assertThrows(IllegalArgumentException.class, () -> property.bind(property));\n+        assertEquals(BeanErrors.CANNOT_BIND_PROPERTY_TO_ITSELF.getMessage(property), ex.getMessage());\n@@ -449,0 +459,28 @@\n+    @Test\n+    public void testBindBidirectional_targetIsBound() {\n+        var target = new SimpleIntegerProperty(this, \"target\");\n+        var source = new SimpleIntegerProperty(this, \"source\");\n+        target.bind(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindBidirectional_sourceIsBound() {\n+        var target = new SimpleIntegerProperty(this, \"target\");\n+        var source = new SimpleIntegerProperty(this, \"source\");\n+        var other = new SimpleIntegerProperty(this, \"other\");\n+        source.bind(other);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(source), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBind_targetIsBoundBidirectionally() {\n+        var target = new SimpleIntegerProperty(this, \"target\");\n+        var source = new SimpleIntegerProperty(this, \"source\");\n+        target.bindBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bind(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/IntegerPropertyBaseTest.java","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -197,1 +197,0 @@\n-            fail(\"Not in use\");\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/IntegerPropertyTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+\n+import com.sun.javafx.beans.BeanErrors;\n+import javafx.collections.ListChangeListener;\n@@ -47,0 +50,1 @@\n+import static test.util.MoreAssertions.*;\n@@ -479,1 +483,1 @@\n-    @Test(expected = RuntimeException.class)\n+    @Test\n@@ -483,1 +487,2 @@\n-        property.set(VALUE_1a);\n+        var ex = assertThrows(RuntimeException.class, () -> property.set(VALUE_1a));\n+        assertEquals(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(v), ex.getMessage());\n@@ -585,1 +590,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -587,1 +592,8 @@\n-        property.bind(null);\n+        var ex = assertThrows(NullPointerException.class, () -> property.bind(null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(property), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindToSelf() {\n+        var ex = assertThrows(IllegalArgumentException.class, () -> property.bind(property));\n+        assertEquals(BeanErrors.CANNOT_BIND_PROPERTY_TO_ITSELF.getMessage(property), ex.getMessage());\n@@ -692,0 +704,119 @@\n+    @Test\n+    public void testBindBidirectional_targetIsBound() {\n+        var target = new SimpleListProperty<>(this, \"target\");\n+        var source = new SimpleListProperty<>(this, \"source\");\n+        target.bind(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindBidirectional_sourceIsBound() {\n+        var target = new SimpleListProperty<>(this, \"target\");\n+        var source = new SimpleListProperty<>(this, \"source\");\n+        var other = new SimpleListProperty<>(this, \"other\");\n+        source.bind(other);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(source), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBind_targetIsBoundBidirectionally() {\n+        var target = new SimpleListProperty<>(this, \"target\");\n+        var source = new SimpleListProperty<>(this, \"source\");\n+        target.bindBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bind(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindContentBidirectional_targetIsContentBound() {\n+        var target = new SimpleListProperty<>(this, \"target\", FXCollections.<String>observableArrayList());\n+        var source = new SimpleListProperty<>(this, \"source\", FXCollections.<String>observableArrayList());\n+        target.bindContent(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindContentBidirectional(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindContentBidirectional_sourceIsContentBound() {\n+        var target = new SimpleListProperty<>(this, \"target\", FXCollections.<String>observableArrayList());\n+        var source = new SimpleListProperty<>(this, \"source\", FXCollections.<String>observableArrayList());\n+        var other = new SimpleListProperty<>(this, \"source\", FXCollections.<String>observableArrayList());\n+        source.bindContent(other);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> target.bindContentBidirectional(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_BIDIRECTIONAL.getMessage(source), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindContent_targetIsContentBoundBidirectionally() {\n+        var target = new SimpleListProperty<>(this, \"target\", FXCollections.<String>observableArrayList());\n+        var source = new SimpleListProperty<>(this, \"source\", FXCollections.<String>observableArrayList());\n+        target.bindContentBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindContent(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testSetValueOfContentBoundPropertyFails() {\n+        var target = new SimpleListProperty<>(this, \"target\", FXCollections.<String>observableArrayList());\n+        var source = new SimpleListProperty<>(this, \"source\", FXCollections.<String>observableArrayList());\n+        target.bindContent(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.set(FXCollections.observableArrayList()));\n+        assertEquals(BeanErrors.CANNOT_SET_CONTENT_BOUND_PROPERTY.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testContentBindingIsReplaced() {\n+        var target = new SimpleListProperty<>(FXCollections.<String>observableArrayList());\n+        var source = new SimpleListProperty<>(FXCollections.<String>observableArrayList());\n+        target.bindContent(source);\n+        target.bindContent(source);\n+\n+        int[] calls = new int[1];\n+        target.addListener((ListChangeListener<? super String>)change -> calls[0]++);\n+\n+        source.add(\"foo\");\n+        assertEquals(1, calls[0]);\n+    }\n+\n+    @Test\n+    public void testContentBindingIsRemoved() {\n+        var target = new SimpleListProperty<>(FXCollections.<String>observableArrayList());\n+        var source = new SimpleListProperty<>(FXCollections.<String>observableArrayList());\n+        target.bindContent(source);\n+        source.add(\"foo\");\n+        assertEquals(1, target.size());\n+\n+        target.unbindContent();\n+        source.add(\"bar\");\n+        assertEquals(1, target.size());\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBindingIsReplaced() {\n+        var target = new SimpleListProperty<>(FXCollections.<String>observableArrayList());\n+        var source = new SimpleListProperty<>(FXCollections.<String>observableArrayList());\n+        target.bindContentBidirectional(source);\n+        target.bindContentBidirectional(source);\n+\n+        int[] calls = new int[1];\n+        target.addListener((ListChangeListener<? super String>)change -> calls[0]++);\n+\n+        source.add(\"foo\");\n+        assertEquals(1, calls[0]);\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBindingIsRemoved() {\n+        var target = new SimpleListProperty<>(FXCollections.<String>observableArrayList());\n+        var source = new SimpleListProperty<>(FXCollections.<String>observableArrayList());\n+        target.bindContentBidirectional(source);\n+        source.add(\"foo\");\n+        assertEquals(1, target.size());\n+\n+        target.unbindContentBidirectional(source);\n+        source.add(\"bar\");\n+        assertEquals(1, target.size());\n+    }\n+\n@@ -865,0 +996,1 @@\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/ListPropertyBaseTest.java","additions":136,"deletions":4,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,1 +155,0 @@\n-            fail(\"Not in use\");\n@@ -200,0 +199,30 @@\n+\n+        @Override\n+        public void bindContentBidirectional(ObservableList<Object> other) {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void unbindContentBidirectional(ObservableList<Object> other) {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void unbindContentBidirectional(Object other) {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void bindContent(ObservableList<Object> source) {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void unbindContent() {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void unbindContent(Object source) {\n+            fail(\"Not in use\");\n+        }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/ListPropertyTest.java","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -34,0 +35,1 @@\n+import static test.util.MoreAssertions.*;\n@@ -206,1 +208,1 @@\n-    @Test(expected=RuntimeException.class)\n+    @Test\n@@ -210,1 +212,2 @@\n-        property.set(VALUE_1);\n+        var ex = assertThrows(RuntimeException.class, () -> property.set(VALUE_1));\n+        assertEquals(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(v), ex.getMessage());\n@@ -351,1 +354,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -353,1 +356,8 @@\n-        property.bind(null);\n+        var ex = assertThrows(NullPointerException.class, () -> property.bind(null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(property), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindToSelf() {\n+        var ex = assertThrows(IllegalArgumentException.class, () -> property.bind(property));\n+        assertEquals(BeanErrors.CANNOT_BIND_PROPERTY_TO_ITSELF.getMessage(property), ex.getMessage());\n@@ -449,0 +459,28 @@\n+    @Test\n+    public void testBindBidirectional_targetIsBound() {\n+        var target = new SimpleLongProperty(this, \"target\");\n+        var source = new SimpleLongProperty(this, \"source\");\n+        target.bind(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindBidirectional_sourceIsBound() {\n+        var target = new SimpleLongProperty(this, \"target\");\n+        var source = new SimpleLongProperty(this, \"source\");\n+        var other = new SimpleLongProperty(this, \"other\");\n+        source.bind(other);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(source), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBind_targetIsBoundBidirectionally() {\n+        var target = new SimpleLongProperty(this, \"target\");\n+        var source = new SimpleLongProperty(this, \"source\");\n+        target.bindBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bind(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/LongPropertyBaseTest.java","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -195,1 +195,0 @@\n-            fail(\"Not in use\");\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/LongPropertyTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.javafx.beans.BeanErrors;\n+import javafx.collections.MapChangeListener;\n@@ -44,0 +46,1 @@\n+import static test.util.MoreAssertions.*;\n@@ -502,1 +505,1 @@\n-    @Test(expected = RuntimeException.class)\n+    @Test\n@@ -506,1 +509,2 @@\n-        property.set(VALUE_1a);\n+        var ex = assertThrows(RuntimeException.class, () -> property.set(VALUE_1a));\n+        assertEquals(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(v), ex.getMessage());\n@@ -608,1 +612,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -610,1 +614,8 @@\n-        property.bind(null);\n+        var ex = assertThrows(NullPointerException.class, () -> property.bind(null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(property), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindToSelf() {\n+        var ex = assertThrows(IllegalArgumentException.class, () -> property.bind(property));\n+        assertEquals(BeanErrors.CANNOT_BIND_PROPERTY_TO_ITSELF.getMessage(property), ex.getMessage());\n@@ -713,0 +724,119 @@\n+    @Test\n+    public void testBindBidirectional_targetIsBound() {\n+        var target = new SimpleMapProperty<>(this, \"target\");\n+        var source = new SimpleMapProperty<>(this, \"source\");\n+        target.bind(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindBidirectional_sourceIsBound() {\n+        var target = new SimpleMapProperty<>(this, \"target\");\n+        var source = new SimpleMapProperty<>(this, \"source\");\n+        var other = new SimpleMapProperty<>(this, \"other\");\n+        source.bind(other);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(source), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBind_targetIsBoundBidirectionally() {\n+        var target = new SimpleMapProperty<>(this, \"target\");\n+        var source = new SimpleMapProperty<>(this, \"source\");\n+        target.bindBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bind(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindContentBidirectional_targetIsContentBound() {\n+        var target = new SimpleMapProperty<>(this, \"target\", FXCollections.<String, String>observableHashMap());\n+        var source = new SimpleMapProperty<>(this, \"source\", FXCollections.<String, String>observableHashMap());\n+        target.bindContent(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindContentBidirectional(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindContentBidirectional_sourceIsContentBound() {\n+        var target = new SimpleMapProperty<>(this, \"target\", FXCollections.<String, String>observableHashMap());\n+        var source = new SimpleMapProperty<>(this, \"source\", FXCollections.<String, String>observableHashMap());\n+        var other = new SimpleMapProperty<>(this, \"source\", FXCollections.<String, String>observableHashMap());\n+        source.bindContent(other);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> target.bindContentBidirectional(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_BIDIRECTIONAL.getMessage(source), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindContent_targetIsContentBoundBidirectionally() {\n+        var target = new SimpleMapProperty<>(this, \"target\", FXCollections.<String, String>observableHashMap());\n+        var source = new SimpleMapProperty<>(this, \"source\", FXCollections.<String, String>observableHashMap());\n+        target.bindContentBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindContent(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testSetValueOfContentBoundPropertyFails() {\n+        var target = new SimpleMapProperty<String, String>(FXCollections.observableHashMap());\n+        var source = new SimpleMapProperty<String, String>(FXCollections.observableHashMap());\n+        target.bindContent(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.set(FXCollections.observableHashMap()));\n+        assertEquals(BeanErrors.CANNOT_SET_CONTENT_BOUND_PROPERTY.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testContentBindingIsReplaced() {\n+        var target = new SimpleMapProperty<String, String>(FXCollections.observableHashMap());\n+        var source = new SimpleMapProperty<String, String>(FXCollections.observableHashMap());\n+        target.bindContent(source);\n+        target.bindContent(source);\n+\n+        int[] calls = new int[1];\n+        target.addListener((MapChangeListener<String, String>) change -> calls[0]++);\n+\n+        source.put(\"foo\", \"bar\");\n+        assertEquals(1, calls[0]);\n+    }\n+\n+    @Test\n+    public void testContentBindingIsRemoved() {\n+        var target = new SimpleMapProperty<String, String>(FXCollections.observableHashMap());\n+        var source = new SimpleMapProperty<String, String>(FXCollections.observableHashMap());\n+        target.bindContent(source);\n+        source.put(\"foo\", \"bar\");\n+        assertEquals(1, target.size());\n+\n+        target.unbindContent();\n+        source.put(\"qux\", \"quux\");\n+        assertEquals(1, target.size());\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBindingIsReplaced() {\n+        var target = new SimpleMapProperty<String, String>(FXCollections.observableHashMap());\n+        var source = new SimpleMapProperty<String, String>(FXCollections.observableHashMap());\n+        target.bindContentBidirectional(source);\n+        target.bindContentBidirectional(source);\n+\n+        int[] calls = new int[1];\n+        target.addListener((MapChangeListener<String, String>)change -> calls[0]++);\n+\n+        source.put(\"foo\", \"bar\");\n+        assertEquals(1, calls[0]);\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBindingIsRemoved() {\n+        var target = new SimpleMapProperty<String, String>(FXCollections.observableHashMap());\n+        var source = new SimpleMapProperty<String, String>(FXCollections.observableHashMap());\n+        target.bindContentBidirectional(source);\n+        source.put(\"foo\", \"bar\");\n+        assertEquals(1, target.size());\n+\n+        target.unbindContentBidirectional(source);\n+        source.put(\"qux\", \"quux\");\n+        assertEquals(1, target.size());\n+    }\n+\n@@ -834,0 +964,1 @@\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/MapPropertyBaseTest.java","additions":135,"deletions":4,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,1 +158,0 @@\n-            fail(\"Not in use\");\n@@ -203,0 +202,30 @@\n+\n+        @Override\n+        public void bindContentBidirectional(ObservableMap<Object, Object> other) {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void unbindContentBidirectional(ObservableMap<Object, Object> other) {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void unbindContentBidirectional(Object other) {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void bindContent(ObservableMap<Object, Object> source) {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void unbindContent() {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void unbindContent(Object object) {\n+            fail(\"Not in use\");\n+        }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/MapPropertyTest.java","additions":31,"deletions":2,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -34,0 +35,1 @@\n+import static test.util.MoreAssertions.*;\n@@ -207,1 +209,1 @@\n-    @Test(expected=RuntimeException.class)\n+    @Test\n@@ -211,1 +213,2 @@\n-        property.set(VALUE_1a);\n+        var ex = assertThrows(RuntimeException.class, () -> property.set(VALUE_1a));\n+        assertEquals(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(v), ex.getMessage());\n@@ -278,1 +281,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -280,1 +283,8 @@\n-        property.bind(null);\n+        var ex = assertThrows(NullPointerException.class, () -> property.bind(null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(property), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindToSelf() {\n+        var ex = assertThrows(IllegalArgumentException.class, () -> property.bind(property));\n+        assertEquals(BeanErrors.CANNOT_BIND_PROPERTY_TO_ITSELF.getMessage(property), ex.getMessage());\n@@ -348,0 +358,28 @@\n+    @Test\n+    public void testBindBidirectional_targetIsBound() {\n+        var target = new SimpleObjectProperty<>(this, \"target\");\n+        var source = new SimpleObjectProperty<>(this, \"source\");\n+        target.bind(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindBidirectional_sourceIsBound() {\n+        var target = new SimpleObjectProperty<>(this, \"target\");\n+        var source = new SimpleObjectProperty<>(this, \"source\");\n+        var other = new SimpleObjectProperty<>(this, \"other\");\n+        source.bind(other);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(source), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBind_targetIsBoundBidirectionally() {\n+        var target = new SimpleObjectProperty<>(this, \"target\");\n+        var source = new SimpleObjectProperty<>(this, \"source\");\n+        target.bindBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bind(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/ObjectPropertyBaseTest.java","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -150,1 +150,0 @@\n-            fail(\"Not in use\");\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/ObjectPropertyTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -32,0 +33,1 @@\n+import javafx.collections.ListChangeListener;\n@@ -39,0 +41,1 @@\n+import static org.junit.Assert.assertEquals;\n@@ -40,0 +43,1 @@\n+import static test.util.MoreAssertions.assertThrows;\n@@ -89,0 +93,7 @@\n+        public ReadOnlyPropertyMock() {}\n+\n+        public ReadOnlyPropertyMock(ObservableList<Object> value) {\n+            this.value = value;\n+            value.addListener((ListChangeListener<? super Object>)this::fireValueChangedEvent);\n+        }\n+\n@@ -124,0 +135,72 @@\n+    @Test\n+    public void testContentBoundPropertyThrowsExceptionWhenBidirectionalContentBindingIsAdded() {\n+        var target = new ReadOnlyPropertyMock(FXCollections.observableArrayList());\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableArrayList());\n+        target.bindContent(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindContentBidirectional(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBoundPropertyThrowsExceptionWhenContentBindingIsAdded() {\n+        var target = new ReadOnlyPropertyMock(FXCollections.observableArrayList());\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableArrayList());\n+        target.bindContentBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindContent(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testContentBindingIsReplaced() {\n+        var target = new ReadOnlyPropertyMock(FXCollections.observableArrayList());\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableArrayList());\n+        target.bindContent(source);\n+        target.bindContent(source);\n+\n+        int[] calls = new int[1];\n+        target.addListener((ListChangeListener<Object>)change -> calls[0]++);\n+\n+        source.add(\"foo\");\n+        assertEquals(1, calls[0]);\n+    }\n+\n+    @Test\n+    public void testContentBindingIsRemoved() {\n+        var target = new ReadOnlyPropertyMock(FXCollections.observableArrayList());\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableArrayList());\n+        target.bindContent(source);\n+        source.add(\"foo\");\n+        assertEquals(1, target.size());\n+\n+        target.unbindContent();\n+        source.add(\"bar\");\n+        assertEquals(1, target.size());\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBindingIsReplaced() {\n+        var target = new ReadOnlyPropertyMock(FXCollections.observableArrayList());\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableArrayList());\n+        target.bindContentBidirectional(source);\n+        target.bindContentBidirectional(source);\n+\n+        int[] calls = new int[1];\n+        target.addListener((ListChangeListener<Object>) change -> calls[0]++);\n+\n+        source.add(\"foo\");\n+        assertEquals(1, calls[0]);\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBindingIsRemoved() {\n+        var target = new ReadOnlyPropertyMock(FXCollections.observableArrayList());\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableArrayList());\n+        target.bindContentBidirectional(source);\n+        source.add(\"foo\");\n+        assertEquals(1, target.size());\n+\n+        target.unbindContentBidirectional(source);\n+        source.add(\"bar\");\n+        assertEquals(1, target.size());\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/ReadOnlyListPropertyBaseTest.java","additions":84,"deletions":1,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,0 +122,24 @@\n+\n+        @Override\n+        public void bindContentBidirectional(ObservableList<Object> other) {\n+        }\n+\n+        @Override\n+        public void unbindContentBidirectional(ObservableList<Object> other) {\n+        }\n+\n+        @Override\n+        public void unbindContentBidirectional(Object other) {\n+        }\n+\n+        @Override\n+        public void bindContent(ObservableList<Object> source) {\n+        }\n+\n+        @Override\n+        public void unbindContent(Object source) {\n+        }\n+\n+        @Override\n+        public void unbindContent() {\n+        }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/ReadOnlyListPropertyTest.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.beans.BeanErrors;\n+import javafx.collections.MapChangeListener;\n@@ -36,1 +38,0 @@\n-import java.util.HashMap;\n@@ -42,0 +43,1 @@\n+import static org.junit.Assert.assertEquals;\n@@ -43,0 +45,1 @@\n+import static test.util.MoreAssertions.assertThrows;\n@@ -92,0 +95,7 @@\n+        public ReadOnlyPropertyMock() {}\n+\n+        public ReadOnlyPropertyMock(ObservableMap<Object, Object> value) {\n+            this.value = value;\n+            value.addListener((MapChangeListener<? super Object, ? super Object>)this::fireValueChangedEvent);\n+        }\n+\n@@ -127,0 +137,72 @@\n+    @Test\n+    public void testContentBoundPropertyThrowsExceptionWhenBidirectionalContentBindingIsAdded() {\n+        var target = new ReadOnlyPropertyMock();\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableHashMap());\n+        target.bindContent(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindContentBidirectional(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBoundPropertyThrowsExceptionWhenContentBindingIsAdded() {\n+        var target = new ReadOnlyPropertyMock();\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableHashMap());\n+        target.bindContentBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindContent(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testContentBindingIsReplaced() {\n+        var target = new ReadOnlyPropertyMock(FXCollections.observableHashMap());\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableHashMap());\n+        target.bindContent(source);\n+        target.bindContent(source);\n+\n+        int[] calls = new int[1];\n+        target.addListener((MapChangeListener<Object, Object>)change -> calls[0]++);\n+\n+        source.put(\"foo\", \"bar\");\n+        assertEquals(1, calls[0]);\n+    }\n+\n+    @Test\n+    public void testContentBindingIsRemoved() {\n+        var target = new ReadOnlyPropertyMock(FXCollections.observableHashMap());\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableHashMap());\n+        target.bindContent(source);\n+        source.put(\"foo\", \"bar\");\n+        assertEquals(1, target.size());\n+\n+        target.unbindContent();\n+        source.put(\"qux\", \"quux\");\n+        assertEquals(1, target.size());\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBindingIsReplaced() {\n+        var target = new ReadOnlyPropertyMock(FXCollections.observableHashMap());\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableHashMap());\n+        target.bindContentBidirectional(source);\n+        target.bindContentBidirectional(source);\n+\n+        int[] calls = new int[1];\n+        target.addListener((MapChangeListener<Object, Object>)change -> calls[0]++);\n+\n+        source.put(\"foo\", \"bar\");\n+        assertEquals(1, calls[0]);\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBindingIsRemoved() {\n+        var target = new ReadOnlyPropertyMock(FXCollections.observableHashMap());\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableHashMap());\n+        target.bindContentBidirectional(source);\n+        source.put(\"foo\", \"bar\");\n+        assertEquals(1, target.size());\n+\n+        target.unbindContentBidirectional(source);\n+        source.put(\"qux\", \"quux\");\n+        assertEquals(1, target.size());\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/ReadOnlyMapPropertyBaseTest.java","additions":84,"deletions":2,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,24 @@\n+\n+        @Override\n+        public void bindContentBidirectional(ObservableMap<Object, Object> other) {\n+        }\n+\n+        @Override\n+        public void unbindContentBidirectional(ObservableMap<Object, Object> other) {\n+        }\n+\n+        @Override\n+        public void unbindContentBidirectional(Object other) {\n+        }\n+\n+        @Override\n+        public void bindContent(ObservableMap<Object, Object> source) {\n+        }\n+\n+        @Override\n+        public void unbindContent() {\n+        }\n+\n+        @Override\n+        public void unbindContent(Object object) {\n+        }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/ReadOnlyMapPropertyTest.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -32,0 +33,1 @@\n+import javafx.collections.SetChangeListener;\n@@ -39,0 +41,1 @@\n+import static org.junit.Assert.assertEquals;\n@@ -40,0 +43,1 @@\n+import static test.util.MoreAssertions.assertThrows;\n@@ -89,0 +93,7 @@\n+        public ReadOnlyPropertyMock() {}\n+\n+        public ReadOnlyPropertyMock(ObservableSet<Object> value) {\n+            this.value = value;\n+            value.addListener((SetChangeListener<? super Object>)this::fireValueChangedEvent);\n+        }\n+\n@@ -124,0 +135,72 @@\n+    @Test\n+    public void testContentBoundPropertyThrowsExceptionWhenBidirectionalContentBindingIsAdded() {\n+        var target = new ReadOnlyPropertyMock();\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableSet());\n+        target.bindContent(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindContentBidirectional(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBoundPropertyThrowsExceptionWhenContentBindingIsAdded() {\n+        var target = new ReadOnlyPropertyMock();\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableSet());\n+        target.bindContentBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindContent(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testContentBindingIsReplaced() {\n+        var target = new ReadOnlyPropertyMock(FXCollections.observableSet());\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableSet());\n+        target.bindContent(source);\n+        target.bindContent(source);\n+\n+        int[] calls = new int[1];\n+        target.addListener((SetChangeListener<Object>)change -> calls[0]++);\n+\n+        source.add(\"foo\");\n+        assertEquals(1, calls[0]);\n+    }\n+\n+    @Test\n+    public void testContentBindingIsRemoved() {\n+        var target = new ReadOnlyPropertyMock(FXCollections.observableSet());\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableSet());\n+        target.bindContent(source);\n+        source.add(\"foo\");\n+        assertEquals(1, target.size());\n+\n+        target.unbindContent();\n+        source.add(\"bar\");\n+        assertEquals(1, target.size());\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBindingIsReplaced() {\n+        var target = new ReadOnlyPropertyMock(FXCollections.observableSet());\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableSet());\n+        target.bindContentBidirectional(source);\n+        target.bindContentBidirectional(source);\n+\n+        int[] calls = new int[1];\n+        target.addListener((SetChangeListener<Object>)change -> calls[0]++);\n+\n+        source.add(\"foo\");\n+        assertEquals(1, calls[0]);\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBindingIsRemoved() {\n+        var target = new ReadOnlyPropertyMock(FXCollections.observableSet());\n+        var source = new ReadOnlyPropertyMock(FXCollections.observableSet());\n+        target.bindContentBidirectional(source);\n+        source.add(\"foo\");\n+        assertEquals(1, target.size());\n+\n+        target.unbindContentBidirectional(source);\n+        source.add(\"bar\");\n+        assertEquals(1, target.size());\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/ReadOnlySetPropertyBaseTest.java","additions":84,"deletions":1,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,0 +122,29 @@\n+\n+        @Override\n+        public void bindContentBidirectional(ObservableSet<Object> other) {\n+        }\n+\n+        @Override\n+        public void unbindContentBidirectional(ObservableSet<Object> other) {\n+        }\n+\n+        @Override\n+        public void unbindContentBidirectional(Object other) {\n+        }\n+\n+        @Override\n+        public void bindContent(ObservableSet<Object> source) {\n+        }\n+\n+        @Override\n+        public void unbindContent() {\n+        }\n+\n+        @Override\n+        public void unbindContent(Object source) {\n+        }\n+\n+        @Override\n+        public boolean isContentBound() {\n+            return false;\n+        }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/ReadOnlySetPropertyTest.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -29,1 +30,0 @@\n-import java.util.HashSet;\n@@ -43,0 +43,1 @@\n+import static test.util.MoreAssertions.*;\n@@ -439,1 +440,1 @@\n-    @Test(expected = RuntimeException.class)\n+    @Test\n@@ -443,1 +444,2 @@\n-        property.set(VALUE_1a);\n+        var ex = assertThrows(RuntimeException.class, () -> property.set(VALUE_1a));\n+        assertEquals(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(v), ex.getMessage());\n@@ -545,1 +547,1 @@\n-    @Test(expected = NullPointerException.class)\n+    @Test\n@@ -547,1 +549,8 @@\n-        property.bind(null);\n+        var ex = assertThrows(NullPointerException.class, () -> property.bind(null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(property), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindToSelf() {\n+        var ex = assertThrows(IllegalArgumentException.class, () -> property.bind(property));\n+        assertEquals(BeanErrors.CANNOT_BIND_PROPERTY_TO_ITSELF.getMessage(property), ex.getMessage());\n@@ -650,0 +659,119 @@\n+    @Test\n+    public void testBindBidirectional_targetIsBound() {\n+        var target = new SimpleSetProperty<>(this, \"target\");\n+        var source = new SimpleSetProperty<>(this, \"source\");\n+        target.bind(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindBidirectional_sourceIsBound() {\n+        var target = new SimpleSetProperty<>(this, \"target\");\n+        var source = new SimpleSetProperty<>(this, \"source\");\n+        var other = new SimpleSetProperty<>(this, \"other\");\n+        source.bind(other);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(source), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBind_targetIsBoundBidirectionally() {\n+        var target = new SimpleSetProperty<>(this, \"target\");\n+        var source = new SimpleSetProperty<>(this, \"source\");\n+        target.bindBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bind(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindContentBidirectional_targetIsContentBound() {\n+        var target = new SimpleSetProperty<>(this, \"target\", FXCollections.<String>observableSet());\n+        var source = new SimpleSetProperty<>(this, \"source\", FXCollections.<String>observableSet());\n+        target.bindContent(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindContentBidirectional(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindContentBidirectional_sourceIsContentBound() {\n+        var target = new SimpleSetProperty<>(this, \"target\", FXCollections.<String>observableSet());\n+        var source = new SimpleSetProperty<>(this, \"source\", FXCollections.<String>observableSet());\n+        var other = new SimpleSetProperty<>(this, \"source\", FXCollections.<String>observableSet());\n+        source.bindContent(other);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> target.bindContentBidirectional(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_BIDIRECTIONAL.getMessage(source), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindContent_targetIsContentBoundBidirectionally() {\n+        var target = new SimpleSetProperty<>(this, \"target\", FXCollections.<String>observableSet());\n+        var source = new SimpleSetProperty<>(this, \"source\", FXCollections.<String>observableSet());\n+        target.bindContentBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindContent(source));\n+        assertEquals(BeanErrors.CONTENT_BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testSetValueOfContentBoundPropertyFails() {\n+        var target = new SimpleSetProperty<>(FXCollections.<String>observableSet());\n+        var source = new SimpleSetProperty<>(FXCollections.<String>observableSet());\n+        target.bindContent(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.set(FXCollections.observableSet()));\n+        assertEquals(BeanErrors.CANNOT_SET_CONTENT_BOUND_PROPERTY.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testContentBindingIsReplaced() {\n+        var target = new SimpleSetProperty<>(FXCollections.<String>observableSet());\n+        var source = new SimpleSetProperty<>(FXCollections.<String>observableSet());\n+        target.bindContent(source);\n+        target.bindContent(source);\n+\n+        int[] calls = new int[1];\n+        target.addListener((SetChangeListener<? super String>)change -> calls[0]++);\n+\n+        source.add(\"foo\");\n+        assertEquals(1, calls[0]);\n+    }\n+\n+    @Test\n+    public void testContentBindingIsRemoved() {\n+        var target = new SimpleSetProperty<>(FXCollections.<String>observableSet());\n+        var source = new SimpleSetProperty<>(FXCollections.<String>observableSet());\n+        target.bindContent(source);\n+        source.add(\"foo\");\n+        assertEquals(1, target.size());\n+\n+        target.unbindContent();\n+        source.add(\"bar\");\n+        assertEquals(1, target.size());\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBindingIsReplaced() {\n+        var target = new SimpleSetProperty<>(FXCollections.<String>observableSet());\n+        var source = new SimpleSetProperty<>(FXCollections.<String>observableSet());\n+        target.bindContentBidirectional(source);\n+        target.bindContentBidirectional(source);\n+\n+        int[] calls = new int[1];\n+        target.addListener((SetChangeListener<? super String>)change -> calls[0]++);\n+\n+        source.add(\"foo\");\n+        assertEquals(1, calls[0]);\n+    }\n+\n+    @Test\n+    public void testBidirectionalContentBindingIsRemoved() {\n+        var target = new SimpleSetProperty<>(FXCollections.<String>observableSet());\n+        var source = new SimpleSetProperty<>(FXCollections.<String>observableSet());\n+        target.bindContentBidirectional(source);\n+        source.add(\"foo\");\n+        assertEquals(1, target.size());\n+\n+        target.unbindContentBidirectional(source);\n+        source.add(\"bar\");\n+        assertEquals(1, target.size());\n+    }\n+\n@@ -769,0 +897,1 @@\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/SetPropertyBaseTest.java","additions":134,"deletions":5,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,1 +155,0 @@\n-            fail(\"Not in use\");\n@@ -200,0 +199,36 @@\n+\n+        @Override\n+        public void bindContentBidirectional(ObservableSet<Object> other) {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void unbindContentBidirectional(ObservableSet<Object> other) {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void unbindContentBidirectional(Object other) {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void bindContent(ObservableSet<Object> source) {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void unbindContent() {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public void unbindContent(Object source) {\n+            fail(\"Not in use\");\n+        }\n+\n+        @Override\n+        public boolean isContentBound() {\n+            fail(\"Not in use\");\n+            return false;\n+        }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/SetPropertyTest.java","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.beans.BeanErrors;\n@@ -34,0 +35,1 @@\n+import static test.util.MoreAssertions.*;\n@@ -206,1 +208,1 @@\n-    @Test(expected=RuntimeException.class)\n+    @Test\n@@ -210,1 +212,2 @@\n-        property.set(VALUE_1a);\n+        var ex = assertThrows(RuntimeException.class, () -> property.set(VALUE_1a));\n+        assertEquals(BeanErrors.CANNOT_SET_BOUND_PROPERTY.getMessage(v), ex.getMessage());\n@@ -277,1 +280,1 @@\n-    @Test(expected=NullPointerException.class)\n+    @Test\n@@ -279,1 +282,8 @@\n-        property.bind(null);\n+        var ex = assertThrows(NullPointerException.class, () -> property.bind(null));\n+        assertEquals(BeanErrors.BINDING_SOURCE_NULL.getMessage(property), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindToSelf() {\n+        var ex = assertThrows(IllegalArgumentException.class, () -> property.bind(property));\n+        assertEquals(BeanErrors.CANNOT_BIND_PROPERTY_TO_ITSELF.getMessage(property), ex.getMessage());\n@@ -347,0 +357,28 @@\n+    @Test\n+    public void testBindBidirectional_targetIsBound() {\n+        var target = new SimpleStringProperty(this, \"target\");\n+        var source = new SimpleStringProperty(this, \"source\");\n+        target.bind(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBindBidirectional_sourceIsBound() {\n+        var target = new SimpleStringProperty(this, \"target\");\n+        var source = new SimpleStringProperty(this, \"source\");\n+        var other = new SimpleStringProperty(this, \"other\");\n+        source.bind(other);\n+        var ex = assertThrows(IllegalArgumentException.class, () -> target.bindBidirectional(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_BIDIRECTIONAL.getMessage(source), ex.getMessage());\n+    }\n+\n+    @Test\n+    public void testBind_targetIsBoundBidirectionally() {\n+        var target = new SimpleStringProperty(this, \"target\");\n+        var source = new SimpleStringProperty(this, \"source\");\n+        target.bindBidirectional(source);\n+        var ex = assertThrows(IllegalStateException.class, () -> target.bind(source));\n+        assertEquals(BeanErrors.BIND_CONFLICT_UNIDIRECTIONAL.getMessage(target), ex.getMessage());\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/StringPropertyBaseTest.java","additions":42,"deletions":4,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -150,1 +150,0 @@\n-            fail(\"Not in use\");\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/StringPropertyTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.util;\n+\n+import org.junit.Assert;\n+\n+public class MoreAssertions {\n+\n+    public static <T extends Throwable> T assertThrows(Class<? extends T> ex, Runnable test) {\n+        try {\n+            test.run();\n+        } catch (Throwable t) {\n+            if (ex.isInstance(t)) {\n+                return (T)t;\n+            }\n+\n+            Assert.fail(\"Expected = \" + ex.getName() + \", actual = \" + t.getClass().getName());\n+        }\n+\n+        Assert.fail(\"Expected = \" + ex.getName() + \", actual = no exception\");\n+        return null;\n+    }\n+\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/util\/MoreAssertions.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"}]}