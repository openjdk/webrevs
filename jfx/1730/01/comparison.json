{"files":[{"patch":"@@ -46,1 +46,1 @@\n-        super.addListener(listener);\n+        updateSubscriptionBeforeAdd();\n@@ -48,1 +48,1 @@\n-        updateSubscriptionAfterAdd();\n+        super.addListener(listener);\n@@ -60,1 +60,1 @@\n-        super.addListener(listener);\n+        updateSubscriptionBeforeAdd();\n@@ -62,1 +62,1 @@\n-        updateSubscriptionAfterAdd();\n+        super.addListener(listener);\n@@ -78,1 +78,6 @@\n-     * Called after a listener was added to start observing inputs if they're not observed already.\n+     * Called before a listener was added to start observing inputs if they're not observed already.\n+     * This is done before the addition of a listener to be able to start observing its source\n+     * before the first listener queries the current value. By doing this, this first query will\n+     * also be immediately cached, as observed bindings are allowed to do so. This potentially avoids\n+     * many redundant compute value calls, especially if the source was also not yet observed (and\n+     * its source, and so on).\n@@ -80,1 +85,1 @@\n-    private void updateSubscriptionAfterAdd() {\n+    private void updateSubscriptionBeforeAdd() {\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/LazyObjectBinding.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -371,1 +371,0 @@\n-        valueSubscriber.accept(getValue());  \/\/ eagerly send current value\n@@ -374,0 +373,10 @@\n+        \/*\n+         * Below we eagerly send the current value. This is done after the listener\n+         * was added so that observables that may only cache values when observed\n+         * can first become observed (allowing caching) and are then queried (likely\n+         * getting the value from the cache). Doing this the other way around would\n+         * result in the value (or chain of values) being computed twice.\n+         *\/\n+\n+        valueSubscriber.accept(getValue());\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/ObservableValue.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -60,1 +61,124 @@\n-    private StringProperty property = new SimpleStringProperty(\"Initial\");\n+    private final StringProperty property = new SimpleStringProperty(\"Initial\");\n+\n+    @Nested\n+    class GivenAQuadMappedObservable {\n+\n+        AtomicInteger calls1 = new AtomicInteger(0);\n+        AtomicInteger calls2 = new AtomicInteger(0);\n+        AtomicInteger calls3 = new AtomicInteger(0);\n+        AtomicInteger calls4 = new AtomicInteger(0);\n+\n+        ObservableValue<String> observableValue = property\n+            .map(x -> x + calls1.incrementAndGet())\n+            .map(x -> x + calls2.incrementAndGet())\n+            .map(x -> x + calls3.incrementAndGet())\n+            .map(x -> x + calls4.incrementAndGet());\n+\n+        {\n+            assertEquals(0, calls1.get());\n+            assertEquals(0, calls2.get());\n+            assertEquals(0, calls3.get());\n+            assertEquals(0, calls4.get());\n+        }\n+\n+        @Nested\n+        class WhenObservedByInvalidationListener {\n+            {\n+                observableValue.addListener(obs -> {});\n+            }\n+\n+            @Test\n+            void computeValueShouldBeCalledOnlyOnce() {\n+                assertEquals(1, calls1.get());\n+                assertEquals(1, calls2.get());\n+                assertEquals(1, calls3.get());\n+                assertEquals(1, calls4.get());\n+            }\n+        }\n+\n+        @Nested\n+        class WhenObservedByChangeListener {\n+            {\n+                observableValue.addListener((obs, o, n) -> {});\n+            }\n+\n+            @Test\n+            void computeValueShouldBeCalledOnlyOnce() {\n+                assertEquals(1, calls1.get());\n+                assertEquals(1, calls2.get());\n+                assertEquals(1, calls3.get());\n+                assertEquals(1, calls4.get());\n+            }\n+        }\n+\n+        @Nested\n+        class WhenObservedByInvalidationSubscriber {\n+            {\n+                observableValue.subscribe(() -> {});\n+            }\n+\n+            @Test\n+            void computeValueShouldBeCalledOnlyOnce() {\n+                assertEquals(1, calls1.get());\n+                assertEquals(1, calls2.get());\n+                assertEquals(1, calls3.get());\n+                assertEquals(1, calls4.get());\n+            }\n+        }\n+\n+        @Nested\n+        class WhenObservedByValueSubscriber {\n+            {\n+                observableValue.subscribe(v -> {});\n+            }\n+\n+            @Test\n+            void computeValueShouldBeCalledOnlyOnce() {\n+                assertEquals(1, calls1.get());\n+                assertEquals(1, calls2.get());\n+                assertEquals(1, calls3.get());\n+                assertEquals(1, calls4.get());\n+            }\n+        }\n+\n+        @Nested\n+        class WhenObservedByChangeSubscriber {\n+            {\n+                observableValue.subscribe((o, n) -> {});\n+            }\n+\n+            @Test\n+            void computeValueShouldBeCalledOnlyOnce() {\n+                assertEquals(1, calls1.get());\n+                assertEquals(1, calls2.get());\n+                assertEquals(1, calls3.get());\n+                assertEquals(1, calls4.get());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void computeValueShouldBeCalledOnlyOnceWhenNewlyObserved() {\n+        AtomicInteger calls1 = new AtomicInteger(0);\n+        AtomicInteger calls2 = new AtomicInteger(0);\n+        AtomicInteger calls3 = new AtomicInteger(0);\n+        AtomicInteger calls4 = new AtomicInteger(0);\n+\n+        ObservableValue<String> observableValue = property\n+            .map(x -> x + calls1.incrementAndGet())\n+            .map(x -> x + calls2.incrementAndGet())\n+            .map(x -> x + calls3.incrementAndGet())\n+            .map(x -> x + calls4.incrementAndGet());\n+\n+        assertEquals(0, calls1.get());\n+        assertEquals(0, calls2.get());\n+        assertEquals(0, calls3.get());\n+        assertEquals(0, calls4.get());\n+\n+        observableValue.addListener((obs, o, n) -> {});\n+\n+        assertEquals(1, calls1.get());\n+        assertEquals(1, calls2.get());\n+        assertEquals(1, calls3.get());\n+        assertEquals(1, calls4.get());\n+    }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/ObservableValueFluentBindingsTest.java","additions":125,"deletions":1,"binary":false,"changes":126,"status":"modified"}]}