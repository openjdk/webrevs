{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,0 +160,8 @@\n+    \/**\n+     * Returns ConnectionHolder for additional audio stream if any.\n+     * Currently used by HLS with EXT-X-MEDIA tag.\n+     *\/\n+    public ConnectionHolder getAudioStream() {\n+        return null;\n+    }\n+\n","filename":"modules\/javafx.media\/src\/main\/java\/com\/sun\/media\/jfxmedia\/locator\/ConnectionHolder.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.media.jfxmedia.MediaException;\n@@ -41,0 +42,2 @@\n+import java.util.Arrays;\n+import java.util.Iterator;\n@@ -46,0 +49,10 @@\n+import java.util.stream.Stream;\n+\n+import static com.sun.media.jfxmedia.locator.HLSConnectionHolder.CHARSET_US_ASCII;\n+import static com.sun.media.jfxmedia.locator.HLSConnectionHolder.CHARSET_UTF_8;\n+import static com.sun.media.jfxmedia.locator.HLSConnectionHolder.HLS_VALUE_MIMETYPE_AAC;\n+import static com.sun.media.jfxmedia.locator.HLSConnectionHolder.HLS_VALUE_MIMETYPE_FMP4;\n+import static com.sun.media.jfxmedia.locator.HLSConnectionHolder.HLS_VALUE_MIMETYPE_MP2T;\n+import static com.sun.media.jfxmedia.locator.HLSConnectionHolder.HLS_VALUE_MIMETYPE_MP3;\n+import static com.sun.media.jfxmedia.locator.HLSConnectionHolder.HLS_VALUE_MIMETYPE_UNKNOWN;\n+import static com.sun.media.jfxmedia.locator.HLSConnectionHolder.stripParameters;\n@@ -49,0 +62,3 @@\n+    \/\/ If true HLSConnectionHolder represents additional audio renditions\n+    private boolean isAudioExtStream = false;\n+    private HLSConnectionHolder audioConnectionHolder = null;\n@@ -52,1 +68,1 @@\n-    private PlaylistThread playlistThread = new PlaylistThread();\n+    private final PlaylistLoader playlistLoader;\n@@ -55,4 +71,4 @@\n-    private int mediaFileIndex = -1;\n-    private CountDownLatch readySignal = new CountDownLatch(1);\n-    private Semaphore liveSemaphore = new Semaphore(0);\n-    private boolean isPlaylistClosed = false;\n+    \/\/ If set we need to switch to new current playlist.\n+    \/\/ Used by audio ext streams when switching bitrates.\n+    private Playlist newCurrentPlaylist = null;\n+    private final Object newPlaylistLock = new Object();\n@@ -60,1 +76,2 @@\n-    private long startTime = -1;\n+    private boolean hasAudioExtStream = false;\n+    private long readStartTime = -1;\n@@ -62,13 +79,21 @@\n-    private static final long HLS_VALUE_FLOAT_MULTIPLIER = 1000;\n-    private static final int HLS_PROP_GET_DURATION = 1;\n-    private static final int HLS_PROP_GET_HLS_MODE = 2;\n-    private static final int HLS_PROP_GET_MIMETYPE = 3;\n-    private static final int HLS_PROP_LOAD_SEGMENT = 4;\n-    private static final int HLS_PROP_SEGMENT_START_TIME = 5;\n-    private static final int HLS_VALUE_MIMETYPE_UNKNOWN = -1;\n-    private static final int HLS_VALUE_MIMETYPE_MP2T = 1;\n-    private static final int HLS_VALUE_MIMETYPE_MP3 = 2;\n-    private static final int HLS_VALUE_MIMETYPE_FMP4 = 3;\n-    private static final int HLS_VALUE_MIMETYPE_AAC = 4;\n-    private static final String CHARSET_UTF_8 = \"UTF-8\";\n-    private static final String CHARSET_US_ASCII = \"US-ASCII\";\n+    private boolean isInitialized = false;\n+    private int duration = -1;\n+    \/\/ Will be set to adjusted start time of segment.\n+    \/\/ Seek will set this value and HLS_PROP_SEGMENT_START_TIME\n+    \/\/ should return it if set.\n+    private int segmentStartTimeAfterSeek = -1;\n+    \/\/private Semaphore loadSegmentsSemaphore = null;\n+    static final long HLS_VALUE_FLOAT_MULTIPLIER = 1000;\n+    static final int HLS_PROP_GET_DURATION = 1;\n+    static final int HLS_PROP_GET_HLS_MODE = 2;\n+    static final int HLS_PROP_GET_MIMETYPE = 3;\n+    static final int HLS_PROP_LOAD_SEGMENT = 4;\n+    static final int HLS_PROP_SEGMENT_START_TIME = 5;\n+    static final int HLS_PROP_HAS_AUDIO_EXT_STREAM = 6;\n+    static final int HLS_VALUE_MIMETYPE_UNKNOWN = -1;\n+    static final int HLS_VALUE_MIMETYPE_MP2T = 1;\n+    static final int HLS_VALUE_MIMETYPE_MP3 = 2;\n+    static final int HLS_VALUE_MIMETYPE_FMP4 = 3;\n+    static final int HLS_VALUE_MIMETYPE_AAC = 4;\n+    static final String CHARSET_UTF_8 = \"UTF-8\";\n+    static final String CHARSET_US_ASCII = \"US-ASCII\";\n@@ -77,1 +102,2 @@\n-        playlistThread.setPlaylistURI(uri);\n+        playlistLoader = new PlaylistLoader();\n+        playlistLoader.setPlaylistURI(uri);\n@@ -81,0 +107,8 @@\n+    \/\/ if isAudioExtStream is true then this HLSConnectionHolder\n+    \/\/ represents additional audio renditions from EXT-X-MEDIA tag.\n+    HLSConnectionHolder(Playlist currentPlaylist, boolean isAudioExtStream) {\n+        playlistLoader = null;\n+        this.currentPlaylist = currentPlaylist;\n+        this.isAudioExtStream = isAudioExtStream;\n+    }\n+\n@@ -82,2 +116,2 @@\n-        playlistThread.putState(PlaylistThread.STATE_INIT);\n-        playlistThread.start();\n+        playlistLoader.putState(PlaylistLoader.STATE_INIT);\n+        playlistLoader.start();\n@@ -88,2 +122,2 @@\n-        if (isBitrateAdjustable && startTime == -1) {\n-            startTime = System.currentTimeMillis();\n+        if (isBitrateAdjustable && readStartTime == -1) {\n+            readStartTime = System.currentTimeMillis();\n@@ -107,2 +141,2 @@\n-            long readTime = System.currentTimeMillis() - startTime;\n-            startTime = -1;\n+            long readTime = System.currentTimeMillis() - readStartTime;\n+            readStartTime = -1;\n@@ -110,0 +144,2 @@\n+        } else if (isAudioExtStream && read == -1) {\n+            adjustBitrateAudioExt();\n@@ -137,3 +173,1 @@\n-        try {\n-            readySignal.await();\n-        } catch (InterruptedException e) {\n+        if (!isReady()) {\n@@ -143,1 +177,25 @@\n-        return (long) (currentPlaylist.seek(position) * HLS_VALUE_FLOAT_MULTIPLIER);\n+        if (hasAudioExtStream && position != 0) {\n+            if (getAudioStream() == null || getAudioStream().getCurrentPlaylist() == null) {\n+                return -1; \/\/ Something wrong or EOS\n+            }\n+\n+            \/\/ Video stream with audio extenstion.\n+            \/\/ Get start of audio segment for seek position. This is same start position for\n+            \/\/ audio stream when seek to \"position\".\n+            double audioPosition = getAudioStream().getCurrentPlaylist().seekGetStartTime(position);\n+\n+            \/\/ Seek this video stream to audioPosition. Note: If we seek video stream to position,\n+            \/\/ we might get segment which will not be aligned with audio start time after seek, since\n+            \/\/ target duration (length of audio and video segments) is not same.\n+            if (currentPlaylist.seek((long)audioPosition) == -1) {\n+                return -1; \/\/ Something wrong or EOS\n+            }\n+\n+            \/\/ Now video stream at correct segment, but its start time will not be aligned with\n+            \/\/ audio segment, so we need to return audio segment start time instead. In this\n+            \/\/ case GStreamer will drop all frames before start time and audio and video will\n+            \/\/ be in sync.\n+            return (long) (audioPosition * HLS_VALUE_FLOAT_MULTIPLIER);\n+        } else {\n+            return (long) (currentPlaylist.seek(position) * HLS_VALUE_FLOAT_MULTIPLIER);\n+        }\n@@ -151,1 +209,1 @@\n-        playlistThread.putState(PlaylistThread.STATE_EXIT);\n+        playlistLoader.putState(PlaylistLoader.STATE_EXIT);\n@@ -156,3 +214,1 @@\n-        try {\n-            readySignal.await();\n-        } catch (InterruptedException e) {\n+        if (!isReady()) {\n@@ -164,1 +220,1 @@\n-                return (int)(currentPlaylist.getDuration() * HLS_VALUE_FLOAT_MULTIPLIER);\n+                return duration;\n@@ -172,1 +228,10 @@\n-                return (int)(currentPlaylist.getMediaFileStartTime() * HLS_VALUE_FLOAT_MULTIPLIER);\n+                int segmentStart = -1;\n+                if (segmentStartTimeAfterSeek != -1) {\n+                    segmentStart = segmentStartTimeAfterSeek;\n+                    segmentStartTimeAfterSeek = -1;\n+                } else {\n+                    segmentStart = (int) (currentPlaylist.getMediaFileStartTime() * HLS_VALUE_FLOAT_MULTIPLIER);\n+                }\n+                return segmentStart;\n+            case HLS_PROP_HAS_AUDIO_EXT_STREAM:\n+                return hasAudioExtStream ? 1 : 0;\n@@ -178,0 +243,80 @@\n+    @Override\n+    public HLSConnectionHolder getAudioStream() {\n+        if (!hasAudioExtStream) {\n+            return null;\n+        }\n+\n+        if (audioConnectionHolder != null) {\n+            return audioConnectionHolder;\n+        }\n+\n+        \/\/ currentPlaylist should be set by now\n+        if (variantPlaylist != null && currentPlaylist != null) {\n+            String audioGroupID = currentPlaylist.getAudioGroupID();\n+            Playlist playlist = variantPlaylist.getAudioExtPlaylist(audioGroupID);\n+            audioConnectionHolder = new HLSConnectionHolder(playlist, true);\n+            return audioConnectionHolder;\n+        }\n+\n+        return null;\n+    }\n+\n+    \/\/ Will block if we are not ready yet.\n+    \/\/ Once ready it will do additional initialization like getting\n+    \/\/ playlists from PlayListLoader\n+    private synchronized boolean isReady() {\n+        if (playlistLoader != null) {\n+            if (!playlistLoader.waitForReady()) {\n+                return false;\n+            }\n+        }\n+\n+        if (isInitialized) {\n+            return true;\n+        }\n+\n+        if (playlistLoader != null) {\n+            variantPlaylist = playlistLoader.getVariantPlaylist();\n+            currentPlaylist = playlistLoader.getCurrentPlaylist();\n+        }\n+\n+        \/\/ Always start with first data playlist\n+        if (variantPlaylist != null) {\n+            currentPlaylist = variantPlaylist.getPlaylist(0);\n+            isBitrateAdjustable = true;\n+            hasAudioExtStream = !variantPlaylist.getAudioExtMedia().isEmpty();\n+        }\n+\n+        \/\/ Figure out duration. Duration might be slightly different\n+        \/\/ for streams with separate audio and video stream, so we will\n+        \/\/ take the largest one. Audio stream does not need to do this and\n+        \/\/ video stream will set correct duration.\n+        if (currentPlaylist != null && !isAudioExtStream) {\n+            duration = (int) (currentPlaylist.getDuration() * HLS_VALUE_FLOAT_MULTIPLIER);\n+            if (hasAudioExtStream) {\n+                int audioDuration = (int) (variantPlaylist.getAudioExtMedia().get(0)\n+                        .getPlaylist().getDuration() * HLS_VALUE_FLOAT_MULTIPLIER);\n+                if (duration < audioDuration) {\n+                    duration = audioDuration;\n+                }\n+\n+                \/\/ Tell audio stream which duration to report to GStreamer.\n+                HLSConnectionHolder audioStream = getAudioStream();\n+                if (audioStream != null) {\n+                     audioStream.setDuration(duration);\n+                }\n+            }\n+        }\n+\n+        \/\/ If we have playlist with fMP4, set flag to add header\n+        \/\/ to first data segment and adjust index to 0\n+        if (currentPlaylist != null && currentPlaylist.isFragmentedMP4()) {\n+            sendHeader = true;\n+            currentPlaylist.setMediaFileIndex(0);\n+        }\n+\n+        isInitialized = true;\n+\n+        return true;\n+    }\n+\n@@ -192,2 +337,2 @@\n-        } catch (IOException ioex) {}\n-        finally {\n+        } catch (IOException ioex) {\n+        } finally {\n@@ -201,0 +346,11 @@\n+    void setNewCurrentPlaylist(Playlist value) {\n+        synchronized(newPlaylistLock) {\n+            if (currentPlaylist != value) {\n+                newCurrentPlaylist = value;\n+            }\n+        }\n+    }\n+\n+    void setDuration(int value) {\n+        duration = value;\n+    }\n@@ -260,1 +416,1 @@\n-        int avgBitrate = (int)(((long) urlConnection.getContentLength() * 8 * 1000) \/ readTime);\n+        int avgBitrate = (int) (((long) urlConnection.getContentLength() * 8 * 1000) \/ readTime);\n@@ -266,1 +422,1 @@\n-                playlistThread.setReloadPlaylist(playlist);\n+                playlistLoader.setReloadPlaylist(playlist);\n@@ -270,0 +426,3 @@\n+            \/\/ Copy index when switching playlist, so we continue reading\n+            \/\/ from correct position.\n+            playlist.setMediaFileIndex(currentPlaylist.getMediaFileIndex());\n@@ -274,0 +433,31 @@\n+\n+            \/\/ We switched playlist and we need to check if we need to\n+            \/\/ switch audio stream as well.\n+            if (getAudioStream() != null) {\n+                String audioGroupID = currentPlaylist.getAudioGroupID();\n+                Playlist audioPlaylist = variantPlaylist.getAudioExtPlaylist(audioGroupID);\n+                getAudioStream().setNewCurrentPlaylist(audioPlaylist);\n+            }\n+        }\n+    }\n+\n+    private void adjustBitrateAudioExt() {\n+        \/\/ If video stream provided new playlist, then use it.\n+        synchronized(newPlaylistLock) {\n+            if (newCurrentPlaylist != null && newCurrentPlaylist != currentPlaylist) {\n+                if (currentPlaylist.isLive()) {\n+                    newCurrentPlaylist.update(currentPlaylist.getNextMediaFile());\n+                    playlistLoader.setReloadAudioExtPlaylist(newCurrentPlaylist);\n+                }\n+\n+                newCurrentPlaylist.setForceDiscontinuity(true);\n+                \/\/ Copy index when switching playlist, so we continue reading\n+                \/\/ from correct position.\n+                newCurrentPlaylist.setMediaFileIndex(currentPlaylist.getMediaFileIndex());\n+                currentPlaylist = newCurrentPlaylist;\n+                if (currentPlaylist.isFragmentedMP4()) {\n+                    sendHeader = true;\n+                }\n+\n+                newCurrentPlaylist = null;\n+            }\n@@ -277,1 +467,1 @@\n-    private static String stripParameters(String mediaFile) {\n+    static String stripParameters(String mediaFile) {\n@@ -285,1 +475,4 @@\n-    private class PlaylistThread extends Thread {\n+    Playlist getCurrentPlaylist() {\n+        return currentPlaylist;\n+    }\n+}\n@@ -287,8 +480,14 @@\n-        public static final int STATE_INIT = 0;\n-        public static final int STATE_EXIT = 1;\n-        public static final int STATE_RELOAD_PLAYLIST = 2;\n-        private final BlockingQueue<Integer> stateQueue = new LinkedBlockingQueue<>();\n-        private URI playlistURI = null;\n-        private Playlist reloadPlaylist = null;\n-        private final Object reloadLock = new Object();\n-        private volatile boolean stopped = false;\n+class PlaylistLoader extends Thread {\n+\n+    public static final int STATE_INIT = 0;\n+    public static final int STATE_EXIT = 1;\n+    public static final int STATE_RELOAD_PLAYLIST = 2;\n+    private final BlockingQueue<Integer> stateQueue = new LinkedBlockingQueue<>();\n+    private URI playlistURI = null;\n+    private Playlist reloadPlaylist = null;\n+    private Playlist reloadAudioExtPlaylist = null;\n+    private final Object reloadLock = new Object();\n+    private volatile boolean stopped = false;\n+    private final CountDownLatch readySignal = new CountDownLatch(1);\n+    private VariantPlaylist variantPlaylist = null;\n+    private Playlist currentPlaylist = null;\n@@ -296,4 +495,4 @@\n-        private PlaylistThread() {\n-            setName(\"JFXMedia HLS Playlist Thread\");\n-            setDaemon(true);\n-        }\n+    PlaylistLoader() {\n+        setName(\"JFXMedia HLS Playlist Thread\");\n+        setDaemon(true);\n+    }\n@@ -301,2 +500,6 @@\n-        private void setPlaylistURI(URI playlistURI) {\n-            this.playlistURI = playlistURI;\n+    boolean waitForReady() {\n+        try {\n+            readySignal.await();\n+            return true;\n+        } catch (InterruptedException e) {\n+            return false;\n@@ -304,0 +507,1 @@\n+    }\n@@ -305,4 +509,15 @@\n-        private void setReloadPlaylist(Playlist playlist) {\n-            synchronized(reloadLock) {\n-                reloadPlaylist = playlist;\n-            }\n+    VariantPlaylist getVariantPlaylist() {\n+        return variantPlaylist;\n+    }\n+\n+    Playlist getCurrentPlaylist() {\n+        return currentPlaylist;\n+    }\n+\n+    void setPlaylistURI(URI playlistURI) {\n+        this.playlistURI = playlistURI;\n+    }\n+\n+    void setReloadPlaylist(Playlist playlist) {\n+        synchronized (reloadLock) {\n+            reloadPlaylist = playlist;\n@@ -310,0 +525,1 @@\n+    }\n@@ -311,21 +527,3 @@\n-        @Override\n-        public void run() {\n-            while (!stopped) {\n-                try {\n-                    int state = stateQueue.take();\n-                    switch (state) {\n-                        case STATE_INIT:\n-                            stateInit();\n-                            break;\n-                        case STATE_EXIT:\n-                            stopped = true;\n-                            break;\n-                        case STATE_RELOAD_PLAYLIST:\n-                            stateReloadPlaylist();\n-                            break;\n-                        default:\n-                            break;\n-                    }\n-                } catch (InterruptedException e) {\n-                }\n-            }\n+    void setReloadAudioExtPlaylist(Playlist playlist) {\n+        synchronized (reloadLock) {\n+            reloadAudioExtPlaylist = playlist;\n@@ -333,0 +531,1 @@\n+    }\n@@ -334,5 +533,17 @@\n-        private void putState(int state) {\n-            if (stateQueue != null) {\n-                try {\n-                    stateQueue.put(state);\n-                } catch (InterruptedException ex) {\n+    @Override\n+    public void run() {\n+        while (!stopped) {\n+            try {\n+                int state = stateQueue.take();\n+                switch (state) {\n+                    case STATE_INIT:\n+                        stateInit();\n+                        break;\n+                    case STATE_EXIT:\n+                        stopped = true;\n+                        break;\n+                    case STATE_RELOAD_PLAYLIST:\n+                        stateReloadPlaylist();\n+                        break;\n+                    default:\n+                        break;\n@@ -340,0 +551,1 @@\n+            } catch (InterruptedException e) {\n@@ -342,0 +554,1 @@\n+    }\n@@ -343,5 +556,2 @@\n-        private void stateInit() {\n-            if (playlistURI == null) {\n-                return;\n-            }\n-\n+    void putState(int state) {\n+        if (stateQueue != null) {\n@@ -349,5 +559,5 @@\n-                PlaylistParser parser = new PlaylistParser();\n-                parser.load(playlistURI);\n-\n-                if (parser.isVariantPlaylist()) {\n-                    variantPlaylist = new VariantPlaylist(playlistURI);\n+                stateQueue.put(state);\n+            } catch (InterruptedException ex) {\n+            }\n+        }\n+    }\n@@ -355,8 +565,4 @@\n-                    while (parser.hasNext()) {\n-                        variantPlaylist.addPlaylistInfo(parser.getString(), parser.getInteger());\n-                    }\n-                } else {\n-                    if (currentPlaylist == null) {\n-                        currentPlaylist = new Playlist(parser.isLivePlaylist(), parser.getTargetDuration());\n-                        currentPlaylist.setPlaylistURI(playlistURI);\n-                    }\n+    private void stateInit() {\n+        if (playlistURI == null) {\n+            return;\n+        }\n@@ -364,5 +570,3 @@\n-                    if (currentPlaylist.setSequenceNumber(parser.getSequenceNumber())) {\n-                        while (parser.hasNext()) {\n-                            currentPlaylist.addMediaFile(parser.getString(), parser.getDouble(), parser.getBoolean());\n-                        }\n-                    }\n+        try {\n+            PlaylistParser parser = new PlaylistParser();\n+            parser.load(playlistURI);\n@@ -370,3 +574,5 @@\n-                    if (variantPlaylist != null) {\n-                        variantPlaylist.addPlaylist(currentPlaylist);\n-                    }\n+            if (parser.getVariantPlaylistOrNull() != null) {\n+                variantPlaylist = parser.getVariantPlaylistOrNull();\n+            } else {\n+                if (currentPlaylist == null) {\n+                    currentPlaylist = parser.getPlaylistOrNull();\n@@ -374,0 +580,1 @@\n+            }\n@@ -375,9 +582,19 @@\n-                \/\/ Update variant playlists\n-                if (variantPlaylist != null) {\n-                    while (variantPlaylist.hasNext()) {\n-                        try {\n-                            currentPlaylist = new Playlist(variantPlaylist.getPlaylistURI());\n-                            currentPlaylist.update(null);\n-                            variantPlaylist.addPlaylist(currentPlaylist);\n-                        } catch (URISyntaxException | MalformedURLException e) {\n-                        }\n+            if (variantPlaylist != null) {\n+                \/\/ Load playlists (EXT-X-STREAM-INF) inside variant playlist if needed\n+                variantPlaylist.getExtStreamInf().forEach((ExtStreamInf ext) -> {\n+                    Playlist playlist = new Playlist(ext.getPlaylistURI());\n+                    playlist.update(null);\n+                    playlist.setAudioGroupID(ext.getAudioGroupID());\n+                    ext.setPlaylist(playlist);\n+                });\n+                variantPlaylist.validateExtStreamInf();\n+\n+                final boolean isVideoStreamFragmentedMP4;\n+                final long videoStreamTargetDuration;\n+                currentPlaylist = variantPlaylist.getPlaylist(0);\n+                if (currentPlaylist != null) {\n+                    isVideoStreamFragmentedMP4 = currentPlaylist.isFragmentedMP4();\n+                    if (isVideoStreamFragmentedMP4) {\n+                        videoStreamTargetDuration = currentPlaylist.getTargetDuration();\n+                    } else {\n+                        videoStreamTargetDuration = 0;\n@@ -385,0 +602,3 @@\n+                } else {\n+                    isVideoStreamFragmentedMP4 = false;\n+                    videoStreamTargetDuration = 0;\n@@ -387,5 +607,10 @@\n-                \/\/ Always start with first data playlist\n-                if (variantPlaylist != null) {\n-                    currentPlaylist = variantPlaylist.getPlaylist(0);\n-                    isBitrateAdjustable = true;\n-                }\n+                \/\/ Load Audio Ext Media playlist if needed\n+                variantPlaylist.getAudioExtMedia().forEach((AudioExtMedia ext) -> {\n+                    Playlist playlist = new Playlist(ext.getPlaylistURI());\n+                    playlist.setIsVideoStreamFragmentedMP4(isVideoStreamFragmentedMP4);\n+                    playlist.setVideoStreamTargetDuration(videoStreamTargetDuration);\n+                    playlist.update(null);\n+                    ext.setPlaylist(playlist);\n+                });\n+                variantPlaylist.validateAudioExtMedia();\n+            }\n@@ -393,0 +618,2 @@\n+            if (variantPlaylist != null) {\n+                currentPlaylist = variantPlaylist.getPlaylist(0);\n@@ -394,1 +621,1 @@\n-                if (currentPlaylist.isLive()) {\n+                if (currentPlaylist != null && currentPlaylist.isLive()) {\n@@ -396,2 +623,0 @@\n-                    putState(STATE_RELOAD_PLAYLIST);\n-                }\n@@ -399,5 +624,8 @@\n-                \/\/ If we have playlist with fMP4, set flag to add header\n-                \/\/ to first data segment and adjust index to 0\n-                if (currentPlaylist.isFragmentedMP4()) {\n-                    sendHeader = true;\n-                    mediaFileIndex = 0;\n+                    \/\/ Add audio ext playlist for reload if we have one\n+                    Playlist audioExtPlaylist = variantPlaylist\n+                        .getAudioExtPlaylist(currentPlaylist.getAudioGroupID());\n+                    if (audioExtPlaylist != null && audioExtPlaylist.isLive()) {\n+                        this.setReloadAudioExtPlaylist(audioExtPlaylist);\n+                    }\n+\n+                    putState(STATE_RELOAD_PLAYLIST);\n@@ -405,2 +633,0 @@\n-            } finally {\n-                readySignal.countDown();\n@@ -408,0 +634,2 @@\n+        } finally {\n+            readySignal.countDown();\n@@ -409,0 +637,1 @@\n+    }\n@@ -410,9 +639,5 @@\n-        private void stateReloadPlaylist() {\n-            try {\n-                long timeout;\n-                synchronized(reloadLock) {\n-                    timeout = reloadPlaylist.getTargetDuration() \/ 2;\n-                }\n-                Thread.sleep(timeout);\n-            } catch (InterruptedException ex) {\n-                return;\n+    private void stateReloadPlaylist() {\n+        try {\n+            long timeout;\n+            synchronized (reloadLock) {\n+                timeout = reloadPlaylist.getTargetDuration() \/ 2;\n@@ -420,0 +645,4 @@\n+            Thread.sleep(timeout);\n+        } catch (InterruptedException ex) {\n+            return;\n+        }\n@@ -421,2 +650,4 @@\n-            synchronized(reloadLock) {\n-                reloadPlaylist.update(null);\n+        synchronized (reloadLock) {\n+            reloadPlaylist.update(null);\n+            if (reloadAudioExtPlaylist != null) {\n+                reloadAudioExtPlaylist.update(null);\n@@ -424,2 +655,0 @@\n-\n-            putState(STATE_RELOAD_PLAYLIST);\n@@ -427,1 +656,0 @@\n-    }\n@@ -429,1 +657,3 @@\n-    private static class PlaylistParser {\n+        putState(STATE_RELOAD_PLAYLIST);\n+    }\n+}\n@@ -431,13 +661,1 @@\n-        private boolean isFirstLine = true;\n-        private boolean isLineMediaFileURI = false;\n-        private boolean isEndList = false;\n-        private boolean isLinePlaylistURI = false;\n-        private boolean isVariantPlaylist = false;\n-        private boolean isDiscontinuity = false;\n-        private int targetDuration = 0;\n-        private int sequenceNumber = 0;\n-        private int dataListIndex = -1;\n-        private List<String> dataListString = new ArrayList<>();\n-        private List<Integer> dataListInteger = new ArrayList<>();\n-        private List<Double> dataListDouble = new ArrayList<>();\n-        private List<Boolean> dataListBoolean = new ArrayList<>();\n+class PlaylistParser {\n@@ -445,6 +663,24 @@\n-        private void load(URI uri) {\n-            HttpURLConnection connection = null;\n-            BufferedReader reader = null;\n-            try {\n-                connection = (HttpURLConnection) uri.toURL().openConnection();\n-                connection.setRequestMethod(\"GET\");\n+    private URI playlistURI = null;\n+    private boolean isDiscontinuity = false;\n+    private VariantPlaylist variantPlaylist = null;\n+    private Playlist playlist = null;\n+    private boolean isEndList = false;\n+\n+    private final String TAG_PARAM_TYPE = \"TYPE\";\n+    private final String TAG_PARAM_TYPE_AUDIO = \"AUDIO\";\n+    private final String TAG_PARAM_GROUP_ID = \"GROUP-ID\";\n+    private final String TAG_PARAM_AUTOSELECT = \"AUTOSELECT\";\n+    private final String TAG_PARAM_DEFAULT = \"DEFAULT\";\n+    private final String TAG_PARAM_URI = \"URI\";\n+    private final String TAG_PARAM_BANDWIDTH = \"BANDWIDTH\";\n+    private final String TAG_PARAM_AUDIO = \"AUDIO\";\n+    private final String TAG_VALUE_YES = \"YES\";\n+\n+    void load(URI uri) {\n+        playlistURI = uri;\n+\n+        HttpURLConnection connection = null;\n+        BufferedReader reader = null;\n+        try {\n+            connection = (HttpURLConnection) uri.toURL().openConnection();\n+            connection.setRequestMethod(\"GET\");\n@@ -452,3 +688,4 @@\n-                if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {\n-                    MediaUtils.error(this, MediaError.ERROR_LOCATOR_CONNECTION_LOST.code(), \"HTTP responce code: \" + connection.getResponseCode(), null);\n-                }\n+            if (connection.getResponseCode() != HttpURLConnection.HTTP_OK) {\n+                MediaUtils.error(this, MediaError.ERROR_LOCATOR_CONNECTION_LOST.code(),\n+                        \"HTTP responce code: \" + connection.getResponseCode(), null);\n+            }\n@@ -456,4 +693,4 @@\n-                Charset charset = getCharset(uri.toURL().toExternalForm(), connection.getContentType());\n-                if (charset != null) {\n-                    reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), charset));\n-                }\n+            Charset charset = getCharset(uri.toURL().toExternalForm(), connection.getContentType());\n+            if (charset != null) {\n+                reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), charset));\n+            }\n@@ -461,5 +698,4 @@\n-                if (reader != null) {\n-                    boolean result;\n-                    do {\n-                        result = parseLine(reader.readLine());\n-                    } while (result);\n+            if (reader != null) {\n+                \/\/ First line cannot be null and should be #EXTM3U\n+                if (\"#EXTM3U\".equals(reader.readLine())) {\n+                    parse(reader);\n@@ -467,9 +703,7 @@\n-            } catch (MalformedURLException e) {\n-            } catch (IOException e) {\n-            } finally {\n-                if (reader != null) {\n-                    try {\n-                        reader.close();\n-                    } catch (IOException e) {}\n-\n-                    Locator.closeConnection(connection);\n+            }\n+        } catch (IOException e) {\n+        } finally {\n+            if (reader != null) {\n+                try {\n+                    reader.close();\n+                } catch (IOException e) {\n@@ -477,0 +711,2 @@\n+\n+                Locator.closeConnection(connection);\n@@ -479,0 +715,1 @@\n+    }\n@@ -480,2 +717,3 @@\n-        private boolean isVariantPlaylist() {\n-            return isVariantPlaylist;\n+    private VariantPlaylist getVariantPlaylist() {\n+        if (variantPlaylist == null) {\n+            variantPlaylist = new VariantPlaylist(playlistURI);\n@@ -484,3 +722,2 @@\n-        private boolean isLivePlaylist() {\n-            return !isEndList;\n-        }\n+        return variantPlaylist;\n+    }\n@@ -488,3 +725,3 @@\n-        private int getTargetDuration() {\n-            return targetDuration;\n-        }\n+    VariantPlaylist getVariantPlaylistOrNull() {\n+        return variantPlaylist;\n+    }\n@@ -492,3 +729,3 @@\n-        private int getSequenceNumber() {\n-            return sequenceNumber;\n-        }\n+    void setPlaylist(Playlist value) {\n+        playlist = value;\n+    }\n@@ -496,6 +733,3 @@\n-        private boolean hasNext() {\n-            dataListIndex++;\n-            return dataListString.size() > dataListIndex ||\n-                    dataListInteger.size() > dataListIndex ||\n-                    dataListDouble.size() > dataListIndex ||\n-                    dataListBoolean.size() > dataListIndex;\n+    private Playlist getPlaylist() {\n+        if (playlist == null) {\n+            playlist = new Playlist(playlistURI);\n@@ -504,3 +738,2 @@\n-        private String getString() {\n-            return dataListString.get(dataListIndex);\n-        }\n+        return playlist;\n+    }\n@@ -508,3 +741,3 @@\n-        private Integer getInteger() {\n-            return dataListInteger.get(dataListIndex);\n-        }\n+    Playlist getPlaylistOrNull() {\n+        return playlist;\n+    }\n@@ -512,3 +745,3 @@\n-        private Double getDouble() {\n-            return dataListDouble.get(dataListIndex);\n-        }\n+    boolean isLivePlaylist() {\n+        return !isEndList;\n+    }\n@@ -516,2 +749,3 @@\n-        private Boolean getBoolean() {\n-            return dataListBoolean.get(dataListIndex);\n+    private void validateArray(String[] tagParams, int length) {\n+        if (tagParams.length < length) {\n+            throw new MediaException(\"Invalid HLS playlist\");\n@@ -519,0 +753,1 @@\n+    }\n@@ -520,3 +755,8 @@\n-        private boolean parseLine(String line) {\n-            if (line == null) {\n-                return false;\n+    private String getNextLine(BufferedReader reader) throws IOException {\n+        String line;\n+        while ((line = reader.readLine()) != null) {\n+            \/\/ Ignore blank lines, comments and tags\n+            if (line.isEmpty() || line.startsWith(\"#\")) {\n+                continue;\n+            } else {\n+                return line;\n@@ -524,0 +764,1 @@\n+        }\n@@ -525,9 +766,2 @@\n-            \/\/ First line of playlist must be \"#EXTM3U\"\n-            if (isFirstLine) {\n-                if (line.compareTo(\"#EXTM3U\") != 0) {\n-                    return false;\n-                }\n-\n-                isFirstLine = false;\n-                return true;\n-            }\n+        throw new MediaException(\"Invalid HLS playlist\");\n+    }\n@@ -535,0 +769,3 @@\n+    private void parse(BufferedReader reader) throws IOException {\n+        String line;\n+        while ((line = reader.readLine()) != null) {\n@@ -537,1 +774,1 @@\n-                return true;\n+                continue;\n@@ -540,8 +777,18 @@\n-            if (line.startsWith(\"#EXTINF\")) { \/\/ #EXTINF\n-                \/\/#EXTINF:<duration>,<title>\n-                String[] s1 = line.split(\":\");\n-                if (s1.length == 2 && s1[1].length() > 0) {\n-                    String[] s2 = s1[1].split(\",\");\n-                    if (s2.length >= 1) { \/\/ We have duration\n-                        dataListDouble.add(Double.parseDouble(s2[0]));\n-                    }\n+            \/\/ If line is not a blank or comment, then it can be tags or URI.\n+            \/\/ URI lines should be read when we're parsing tags, so here we\n+            \/\/ should only get tags. We can have tags with or without\n+            \/\/ parameters. Tag and parameters are separated by \":\".\n+            String[] tagParams = line.split(\":\");\n+            validateArray(tagParams, 1);\n+\n+            switch (tagParams[0]) {\n+                case \"#EXTINF\": { \/\/ #EXTINF:<duration>\n+                    validateArray(tagParams, 2);\n+                    String[] params = tagParams[1].split(\",\");\n+                    validateArray(params, 1);\n+                    String URI = getNextLine(reader);\n+                    getPlaylist().addMediaFile(URI,\n+                            Double.parseDouble(params[0]), isDiscontinuity);\n+                    \/\/ Clear discontinue flag, until it is set again by parser.\n+                    isDiscontinuity = false;\n+                    break;\n@@ -549,7 +796,5 @@\n-\n-                isLineMediaFileURI = true;\n-            } else if (line.startsWith(\"#EXT-X-TARGETDURATION\")) {\n-                \/\/ #EXT-X-TARGETDURATION:<s>\n-                String[] s1 = line.split(\":\");\n-                if (s1.length == 2 && s1[1].length() > 0) {\n-                    targetDuration = Integer.parseInt(s1[1]);\n+                case \"#EXT-X-TARGETDURATION\": { \/\/ #EXT-X-TARGETDURATION:<s>\n+                    validateArray(tagParams, 2);\n+                    getPlaylist().setTargetDuration(\n+                            Integer.parseInt(tagParams[1]));\n+                    break;\n@@ -557,5 +802,5 @@\n-            } else if (line.startsWith(\"#EXT-X-MEDIA-SEQUENCE\")) {\n-                \/\/ #EXT-X-MEDIA-SEQUENCE:<number>\n-                String[] s1 = line.split(\":\");\n-                if (s1.length == 2 && s1[1].length() > 0) {\n-                    sequenceNumber = Integer.parseInt(s1[1]);\n+                case \"#EXT-X-MEDIA-SEQUENCE\": { \/\/ #EXT-X-MEDIA-SEQUENCE:<number>\n+                    validateArray(tagParams, 2);\n+                    getPlaylist().setSequenceNumber(\n+                            Integer.parseInt(tagParams[1]));\n+                    break;\n@@ -563,19 +808,10 @@\n-            } else if (line.startsWith(\"#EXT-X-STREAM-INF\")) {\n-                \/\/ #EXT-X-STREAM-INF:<attribute-list>\n-                isVariantPlaylist = true;\n-\n-                int bitrate = 0;\n-                String[] s1 = line.split(\":\");\n-                if (s1.length == 2 && s1[1].length() > 0) {\n-                    String[] s2 = s1[1].split(\",\");\n-                    if (s2.length > 0) {\n-                        for (int i = 0; i < s2.length; i++) {\n-                            s2[i] = s2[i].trim();\n-                            if (s2[i].startsWith(\"BANDWIDTH\")) {\n-                                String[] s3 = s2[i].split(\"=\");\n-                                if (s3.length == 2 && s3[1].length() > 0) {\n-                                    bitrate = Integer.parseInt(s3[1]);\n-                                }\n-                            }\n-                        }\n-                    }\n+                case \"#EXT-X-STREAM-INF\": { \/\/ #EXT-X-STREAM-INF:<attribute-list>\n+                    validateArray(tagParams, 2);\n+                    String[] params = tagParams[1].split(\",\");\n+                    int bitrate = getIntegerParams(TAG_PARAM_BANDWIDTH, params);\n+                    String audioGroupID = getStringParams(TAG_PARAM_AUDIO, params);\n+                    String location = getNextLine(reader);\n+                    ExtStreamInf item = new ExtStreamInf(location, bitrate);\n+                    item.setAudioGroupID(audioGroupID);\n+                    getVariantPlaylist().addExtStreamInf(item);\n+                    break;\n@@ -583,3 +819,3 @@\n-\n-                if (bitrate < 1) {\n-                    return false;\n+                case \"#EXT-X-ENDLIST\": { \/\/ #EXT-X-ENDLIST\n+                    isEndList = true;\n+                    break;\n@@ -587,27 +823,39 @@\n-\n-                dataListInteger.add(bitrate);\n-\n-                isLinePlaylistURI = true; \/\/ Next line will be URI to playlist\n-            } else if (line.startsWith(\"#EXT-X-ENDLIST\")) { \/\/ #EXT-X-ENDLIST\n-                isEndList = true;\n-            } else if (line.startsWith(\"#EXT-X-DISCONTINUITY\")) { \/\/ #EXT-X-DISCONTINUITY\n-                isDiscontinuity = true;\n-            } else if (line.startsWith(\"#EXT-X-MAP\")) {\n-                String[] s1 = line.split(\":\");\n-                if (s1.length == 2 && s1[1].length() > 0) {\n-                    String[] s2 = s1[1].split(\",\");\n-                    if (s2.length > 0) {\n-                        for (int i = 0; i < s2.length; i++) {\n-                            s2[i] = s2[i].trim();\n-                            if (s2[i].startsWith(\"URI\")) {\n-                                String[] s3 = s2[i].split(\"=\");\n-                                if (s3.length == 2 && s3[1].length() > 0) {\n-                                    String dataFile =\n-                                            s3[1].replaceAll(\"^\\\"+|\\\"+$\", \"\");\n-                                    dataListString.add(dataFile);\n-                                    \/\/ GStreamer expects start of stream to be\n-                                    \/\/ discontinuity.\n-                                    dataListBoolean.add(true);\n-                                    dataListDouble.add(Double.valueOf(targetDuration));\n-                                }\n-                            }\n+                case \"#EXT-X-DISCONTINUITY\": { \/\/ #EXT-X-DISCONTINUITY\n+                    isDiscontinuity = true;\n+                    break;\n+                }\n+                case \"#EXT-X-MAP\": { \/\/ #EXT-X-MAP\n+                    validateArray(tagParams, 2);\n+                    String[] params = tagParams[1].split(\",\");\n+                    String uri = getStringParams(TAG_PARAM_URI, params);\n+                    getPlaylist().addMediaFile(uri,\n+                            getPlaylist().getTargetDuration(), true);\n+                    break;\n+                }\n+                case \"#EXT-X-MEDIA\": { \/\/ #EXT-X-MEDIA\n+                    validateArray(tagParams, 2);\n+                    String[] params = tagParams[1].split(\",\");\n+                    String type = getStringParams(TAG_PARAM_TYPE, params);\n+                    if (type.equals(TAG_PARAM_TYPE_AUDIO)) {\n+                        \/\/ Required\n+                        String groupID = getStringParams(TAG_PARAM_GROUP_ID, params);\n+                        \/\/ Optional (YES or NO)\n+                        \/\/ We should assume value NO if DEFAULT or AUTOSELECT is absent.\n+                        \/\/ According to spec we should not auto select streams if both\n+                        \/\/ DEFAULT and AUTOSELECT are NO. Currently, we do not provide APIs\n+                        \/\/ to manually select additional streams, so we will drop it in case\n+                        \/\/ when both DEFAULT and AUTOSELECT are NO.\n+                        String isAutoSelect = getStringParams(TAG_PARAM_AUTOSELECT, params);\n+                        String isDefault = getStringParams(TAG_PARAM_DEFAULT, params);\n+                        \/\/ Optional\n+                        \/\/ Looks like URI can be null for closed caption and video. If it is null,\n+                        \/\/ then stream is included with EXT-X-STREAM-INF, but in case for audio\n+                        \/\/ it is not clear how it will work. Also, there is no example for such case\n+                        \/\/ in documentations. Examples are only for video. For now, we will ignore\n+                        \/\/ any audio streams without URI.\n+                        String location = getStringParams(TAG_PARAM_URI, params);\n+                        boolean autoSelectBool = TAG_VALUE_YES.equalsIgnoreCase(isAutoSelect);\n+                        boolean defaultBool = TAG_VALUE_YES.equalsIgnoreCase(isDefault);\n+                        if (location != null && (autoSelectBool || defaultBool)) {\n+                            AudioExtMedia item = new AudioExtMedia(groupID, location);\n+                            getVariantPlaylist().addAudioExtMedia(item);\n@@ -616,0 +864,1 @@\n+                    break;\n@@ -617,11 +866,2 @@\n-            } else if (isLinePlaylistURI) {\n-                isLinePlaylistURI = false;\n-                dataListString.add(line);\n-            } else if (isLineMediaFileURI) {\n-                \/\/ We can have additional tags after #EXTINF such as\n-                \/\/ #EXT-X-BITRATE for fMP4 playlist, so ignore them.\n-                if (!line.startsWith(\"#\")) {\n-                    isLineMediaFileURI = false;\n-                    dataListString.add(line);\n-                    dataListBoolean.add(isDiscontinuity);\n-                    isDiscontinuity = false;\n+                default: { \/\/ Unsupported tag. Ok to ignore.\n+                    break;\n@@ -630,2 +870,0 @@\n-\n-            return true;\n@@ -633,0 +871,1 @@\n+    }\n@@ -634,10 +873,16 @@\n-        private Charset getCharset(String url, String mimeType) {\n-            if ((url != null && stripParameters(url).endsWith(\".m3u8\")) || (mimeType != null && mimeType.equals(\"application\/vnd.apple.mpegurl\"))) {\n-                if (Charset.isSupported(CHARSET_UTF_8)) {\n-                    return Charset.forName(CHARSET_UTF_8);\n-                }\n-            } else if ((url != null && stripParameters(url).endsWith(\".m3u\")) || (mimeType != null && mimeType.equals(\"audio\/mpegurl\"))) {\n-                if (Charset.isSupported(CHARSET_US_ASCII)) {\n-                    return Charset.forName(CHARSET_US_ASCII);\n-                }\n-            }\n+    private String getStringParams(String name, String[] params) {\n+        Stream<String> stream = Arrays.stream(params);\n+        return stream.filter(x -> x.startsWith(name))\n+                .flatMap(x -> {\n+                    String param = x.trim();\n+                    String[] paramValuePair = param.split(\"=\");\n+                    if (paramValuePair.length == 2 &&\n+                            !paramValuePair[1].isEmpty()) {\n+                        return Stream.of(\n+                                paramValuePair[1].replaceAll(\"^\\\"+|\\\"+$\", \"\"));\n+                    }\n+                    return Stream.empty();\n+                })\n+                .findFirst()\n+                .orElse(null);\n+    }\n@@ -645,1 +890,27 @@\n-            return null;\n+    private int getIntegerParams(String name, String[] params) {\n+        Stream<String> stream = Arrays.stream(params);\n+        return stream.filter(x -> x.startsWith(name))\n+                .flatMap(x -> {\n+                    String param = x.trim();\n+                    String[] paramValuePair = param.split(\"=\");\n+                    if (paramValuePair.length == 2 &&\n+                            !paramValuePair[1].isEmpty()) {\n+                        return Stream.of(Integer.parseInt(paramValuePair[1]));\n+                    }\n+                    return Stream.empty();\n+                })\n+                .findFirst()\n+                .orElse(null);\n+    }\n+\n+    private Charset getCharset(String url, String mimeType) {\n+        if ((url != null && stripParameters(url).endsWith(\".m3u8\"))\n+                || (mimeType != null && mimeType.equals(\"application\/vnd.apple.mpegurl\"))) {\n+            if (Charset.isSupported(CHARSET_UTF_8)) {\n+                return Charset.forName(CHARSET_UTF_8);\n+            }\n+        } else if ((url != null && stripParameters(url).endsWith(\".m3u\"))\n+                || (mimeType != null && mimeType.equals(\"audio\/mpegurl\"))) {\n+            if (Charset.isSupported(CHARSET_US_ASCII)) {\n+                return Charset.forName(CHARSET_US_ASCII);\n+            }\n@@ -647,0 +918,17 @@\n+\n+        return null;\n+    }\n+}\n+\n+\/\/ Contains information from EXT-X-STREAM-INF tag and corresponding playlist\n+\/\/ with media segments.\n+class ExtStreamInf {\n+    private String location = null;\n+    private int bitrate = 0;\n+    private String audioGroupID = null;\n+    private URI playlistURI = null;\n+    private Playlist playlist = null;\n+\n+    ExtStreamInf(String location, int bitrate) {\n+        this.location = location;\n+        this.bitrate = bitrate;\n@@ -649,1 +937,3 @@\n-    private static class VariantPlaylist {\n+    int getBitrate() {\n+        return bitrate;\n+    }\n@@ -651,6 +941,3 @@\n-        private URI playlistURI = null;\n-        private int infoIndex = -1;\n-        private List<String> playlistsLocations = new ArrayList<>();\n-        private List<Integer> playlistsBitrates = new ArrayList<>();\n-        private List<Playlist> playlists = new ArrayList<>();\n-        private String mediaFileExtension = null; \/\/ Will be set to media file extension of first playlist\n+    void setAudioGroupID(String value) {\n+        audioGroupID = value;\n+    }\n@@ -658,3 +945,7 @@\n-        private VariantPlaylist(URI uri) {\n-            playlistURI = uri;\n-        }\n+    String getAudioGroupID() {\n+        return audioGroupID;\n+    }\n+\n+    String getLocation() {\n+        return location;\n+    }\n@@ -662,3 +953,73 @@\n-        private void addPlaylistInfo(String location, int bitrate) {\n-            playlistsLocations.add(location);\n-            playlistsBitrates.add(bitrate);\n+    void setPlaylistURI(URI uri) {\n+        playlistURI = uri;\n+    }\n+\n+    URI getPlaylistURI() {\n+        return playlistURI;\n+    }\n+\n+    void setPlaylist(Playlist value) {\n+        playlist = value;\n+    }\n+\n+    Playlist getPlaylist() {\n+        return playlist;\n+    }\n+}\n+\n+\/\/ Contains information from EXT-X-MEDIA tag and corresponding playlist with\n+\/\/ media segments. This class supports only AUDIO type.\n+class AudioExtMedia {\n+\n+    private String groupID = null;\n+    private String location = null;\n+    private URI playlistURI = null;\n+    private Playlist playlist = null;\n+\n+    AudioExtMedia(String groupID, String location) {\n+        this.groupID = groupID;\n+        this.location = location;\n+    }\n+\n+    String getGroupID() {\n+        return groupID;\n+    }\n+\n+    String getLocation() {\n+        return location;\n+    }\n+\n+    void setPlaylistURI(URI uri) {\n+        playlistURI = uri;\n+    }\n+\n+    URI getPlaylistURI() {\n+        return playlistURI;\n+    }\n+\n+    void setPlaylist(Playlist value) {\n+        playlist = value;\n+    }\n+\n+    Playlist getPlaylist() {\n+        return playlist;\n+    }\n+}\n+\n+class VariantPlaylist {\n+\n+    private URI playlistURI = null;\n+    private final List<ExtStreamInf> extStreamInf = new ArrayList<>();\n+    private final List<AudioExtMedia> audioExtMedia = new ArrayList<>();\n+    private final List<Integer> playlistBitrates = new ArrayList<>();\n+\n+    VariantPlaylist(URI uri) {\n+        playlistURI = uri;\n+    }\n+\n+    void addExtStreamInf(ExtStreamInf item) {\n+        \/\/ Before adding ext stream inf we need to resolve URI against variant playlist.\n+        try {\n+            item.setPlaylistURI(locationToURI(item.getLocation()));\n+        } catch (URISyntaxException | MalformedURLException e) {\n+            throw new MediaException(\"Invalid HLS playlist\");\n@@ -666,0 +1027,2 @@\n+        extStreamInf.add(item);\n+    }\n@@ -667,3 +1030,16 @@\n-        private void addPlaylist(Playlist playlist) {\n-            if (mediaFileExtension == null) {\n-                mediaFileExtension = playlist.getMediaFileExtension();\n+    List<ExtStreamInf> getExtStreamInf() {\n+        return extStreamInf;\n+    }\n+\n+    \/\/ Should be called after ExtStreamInf is fully loaded including playlist\n+    \/\/ itself.\n+    \/\/ It will do final validation and drop anything we do not want.\n+    void validateExtStreamInf() {\n+        String extension = null; \/\/ Will be set to media file extension of first playlist\n+        boolean hasAudioGroupID = false; \/\/ Will be set to true if first playlist has group ID.\n+        Iterator<ExtStreamInf> it = extStreamInf.iterator();\n+        while (it.hasNext()) {\n+            ExtStreamInf item = it.next();\n+            Playlist playlist = item.getPlaylist();\n+            if (playlist == null) {\n+                it.remove();\n@@ -671,5 +1047,13 @@\n-                if (!mediaFileExtension.equals(playlist.getMediaFileExtension())) {\n-                    playlistsLocations.remove(infoIndex);\n-                    playlistsBitrates.remove(infoIndex);\n-                    infoIndex--;\n-                    return; \/\/ Ignore playlist with different media type\n+                if (extension == null) {\n+                    extension = playlist.getMediaFileExtension();\n+                    hasAudioGroupID = (item.getAudioGroupID() != null);\n+                } else {\n+                    if (!extension.equals(playlist.getMediaFileExtension())) {\n+                        it.remove();\n+                    }\n+                    \/\/ If at least one stream has audio group id (separate audio stream), we\n+                    \/\/ need to make sure that they all have it. Our pipeline does not support\n+                    \/\/ such cases and it is not clear if they can exist.\n+                    if (hasAudioGroupID && (item.getAudioGroupID() == null)) {\n+                        it.remove();\n+                    }\n@@ -678,1 +1062,0 @@\n-            playlists.add(playlist);\n@@ -681,6 +1064,3 @@\n-        private Playlist getPlaylist(int index) {\n-            if (playlists.size() > index) {\n-                return playlists.get(index);\n-            } else {\n-                return null;\n-            }\n+        if (extStreamInf.isEmpty()) {\n+            \/\/ We did not found any supported streams\n+            throw new MediaException(\"Invalid HLS playlist\");\n@@ -689,5 +1069,5 @@\n-        private boolean hasNext() {\n-            infoIndex++;\n-            return playlistsLocations.size() > infoIndex &&\n-                    playlistsBitrates.size() > infoIndex;\n-        }\n+        \/\/ Load bitrates for switching playlists\n+        extStreamInf.forEach((ext) -> {\n+            playlistBitrates.add(ext.getBitrate());\n+        });\n+    }\n@@ -695,7 +1075,7 @@\n-        private URI getPlaylistURI() throws URISyntaxException, MalformedURLException {\n-            String location = playlistsLocations.get(infoIndex);\n-            if (location.startsWith(\"http:\/\/\") || location.startsWith(\"https:\/\/\")) {\n-                return new URI(location);\n-            } else {\n-                return new URI(playlistURI.toURL().toString().substring(0, playlistURI.toURL().toString().lastIndexOf(\"\/\") + 1) + location);\n-            }\n+    void addAudioExtMedia(AudioExtMedia item) {\n+        \/\/ Before adding audio ext media we need to resolve URI against variant\n+        \/\/ playlist.\n+        try {\n+            item.setPlaylistURI(locationToURI(item.getLocation()));\n+        } catch (URISyntaxException | MalformedURLException e) {\n+            throw new MediaException(\"Invalid HLS playlist\");\n@@ -703,0 +1083,2 @@\n+        audioExtMedia.add(item);\n+    }\n@@ -704,3 +1086,3 @@\n-        private Playlist getPlaylistBasedOnBitrate(int bitrate) {\n-            int playlistIndex = -1;\n-            int playlistBitrate = 0;\n+    List<AudioExtMedia> getAudioExtMedia() {\n+        return audioExtMedia;\n+    }\n@@ -708,11 +1090,17 @@\n-            \/\/ Get bitrate that less then requested bitrate, but most closed to it\n-            for (int i = 0; i < playlistsBitrates.size(); i++) {\n-                int b = playlistsBitrates.get(i);\n-                if (b < bitrate) {\n-                    if (playlistIndex != -1) {\n-                        if (b > playlistBitrate) {\n-                            playlistBitrate = b;\n-                            playlistIndex = i;\n-                        }\n-                    } else {\n-                        playlistIndex = i;\n+    \/\/ Should be called after AudioExtMedia is fully loaded including playlist\n+    \/\/ itself.\n+    \/\/ It will do final validation and drop anything we do not want.\n+    void validateAudioExtMedia() {\n+        String extension = null; \/\/ Will be set to media file extension of first playlist\n+        Iterator<AudioExtMedia> it = audioExtMedia.iterator();\n+        while (it.hasNext()) {\n+            AudioExtMedia item = it.next();\n+            Playlist playlist = item.getPlaylist();\n+            if (playlist == null) {\n+                it.remove();\n+            } else {\n+                if (extension == null) {\n+                    extension = playlist.getMediaFileExtension();\n+                } else {\n+                    if (!extension.equals(playlist.getMediaFileExtension())) {\n+                        it.remove();\n@@ -722,0 +1110,2 @@\n+        }\n+    }\n@@ -723,10 +1113,7 @@\n-            \/\/ If we did not find one (stall), then get the lowest bitrate possible\n-            if (playlistIndex == -1) {\n-                for (int i = 0; i < playlistsBitrates.size(); i++) {\n-                    int b = playlistsBitrates.get(i);\n-                    if (b < playlistBitrate || playlistIndex == -1) {\n-                        playlistBitrate = b;\n-                        playlistIndex = i;\n-                    }\n-                }\n-            }\n+    Playlist getPlaylist(int index) {\n+        if (index < 0 || index >= extStreamInf.size()) {\n+            return null;\n+        } else {\n+            return extStreamInf.get(index).getPlaylist();\n+        }\n+    }\n@@ -734,6 +1121,23 @@\n-            \/\/ Just in case\n-            if (playlistIndex < 0 || playlistIndex >= playlists.size()) {\n-                return null;\n-             } else {\n-                return playlists.get(playlistIndex);\n-            }\n+    Playlist getAudioExtPlaylist(String audioGroupID) {\n+        if (audioGroupID == null || audioExtMedia.isEmpty()) {\n+            return null;\n+        }\n+\n+        AudioExtMedia item = audioExtMedia.stream()\n+            .filter(ext -> ext.getGroupID().equals(audioGroupID))\n+            .findFirst().orElse(null);\n+\n+        return item == null ? null : item.getPlaylist();\n+    }\n+\n+    \/\/ Converts playlist location to URI. .m3u8 playlist can have absolute URI or\n+    \/\/ relatively to\n+    \/\/ variant playlist. This function takes string value from playlist and returns\n+    \/\/ resolved URI\n+    private URI locationToURI(String location) throws URISyntaxException, MalformedURLException {\n+        if (location.startsWith(\"http:\/\/\") || location.startsWith(\"https:\/\/\")) {\n+            return new URI(location);\n+        } else {\n+            return new URI(\n+                    playlistURI.toURL().toString().substring(0, playlistURI.toURL().toString().lastIndexOf(\"\/\") + 1)\n+                            + location);\n@@ -743,24 +1147,3 @@\n-    private class Playlist {\n-\n-        private boolean isLive = false;\n-        private volatile boolean isLiveWaiting = false;\n-        private volatile boolean isLiveStop = false;\n-        private long targetDuration = 0;\n-        private URI playlistURI = null;\n-        private final Object lock = new Object();\n-        private final List<String> mediaFiles = new ArrayList<>();\n-        private final List<Double> mediaFilesStartTimes = new ArrayList<>();\n-        private final List<Boolean> mediaFilesDiscontinuities = new ArrayList<>();\n-        private boolean needBaseURI = true;\n-        private String baseURI = null;\n-        private double startTime = 0.0;\n-        private double duration = 0.0;\n-        private int sequenceNumber = -1;\n-        private int sequenceNumberStart = -1;\n-        private boolean sequenceNumberUpdated = false;\n-        private boolean forceDiscontinuity = false;\n-        private int mimeType = HLS_VALUE_MIMETYPE_UNKNOWN;\n-\n-        private Playlist(boolean isLive, int targetDuration) {\n-            this.isLive = isLive;\n-            this.targetDuration = targetDuration * 1000;\n+    Playlist getPlaylistBasedOnBitrate(int bitrate) {\n+        int playlistIndex = -1;\n+        int playlistBitrate = 0;\n@@ -768,2 +1151,12 @@\n-            if (isLive) {\n-                duration = -1.0;\n+        \/\/ Get bitrate that less than requested bitrate, but most closed to it\n+        for (int i = 0; i < playlistBitrates.size(); i++) {\n+            int b = playlistBitrates.get(i);\n+            if (b < bitrate) {\n+                if (playlistIndex != -1) {\n+                    if (b > playlistBitrate) {\n+                        playlistBitrate = b;\n+                        playlistIndex = i;\n+                    }\n+                } else {\n+                    playlistIndex = i;\n+                }\n@@ -773,2 +1166,9 @@\n-        private Playlist(URI uri) {\n-            playlistURI = uri;\n+        \/\/ If we did not find one (stall), then get the lowest bitrate possible\n+        if (playlistIndex == -1) {\n+            for (int i = 0; i < playlistBitrates.size(); i++) {\n+                int b = playlistBitrates.get(i);\n+                if (b < playlistBitrate || playlistIndex == -1) {\n+                    playlistBitrate = b;\n+                    playlistIndex = i;\n+                }\n+            }\n@@ -777,3 +1177,4 @@\n-        private void update(String nextMediaFile) {\n-            PlaylistParser parser = new PlaylistParser();\n-            parser.load(playlistURI);\n+        \/\/ Just in case\n+        return getPlaylist(playlistIndex);\n+    }\n+}\n@@ -781,2 +1182,37 @@\n-            isLive = parser.isLivePlaylist();\n-            targetDuration = parser.getTargetDuration() * 1000;\n+class Playlist {\n+\n+    private boolean isLive = false;\n+    private volatile boolean isLiveWaiting = false;\n+    private volatile boolean isLiveStop = false;\n+    private long targetDuration = 0;\n+    private URI playlistURI = null;\n+    private final Object lock = new Object();\n+    private final List<String> mediaFiles = new ArrayList<>();\n+    final List<Double> mediaFilesStartTimes = new ArrayList<>();\n+    private final List<Boolean> mediaFilesDiscontinuities = new ArrayList<>();\n+    private boolean needBaseURI = true;\n+    private String baseURI = null;\n+    private double startTime = 0.0;\n+    private double duration = 0.0;\n+    private int sequenceNumber = -1;\n+    private int sequenceNumberStart = -1;\n+    private boolean sequenceNumberUpdated = false;\n+    private boolean forceDiscontinuity = false;\n+    private int mimeType = HLS_VALUE_MIMETYPE_UNKNOWN;\n+    private int mediaFileIndex = -1;\n+    private final Semaphore liveSemaphore = new Semaphore(0);\n+    private boolean isPlaylistClosed = false;\n+    \/\/ Valid only if this playlist represent audio extension\n+    private boolean isVideoStreamFragmentedMP4 = false;\n+    \/\/ Target duration of video stream. For fMP4 streams PTS\n+    \/\/ starts with target duration, but for raw audio it will\n+    \/\/ start with 0, so if we have video stream in fMP4, but\n+    \/\/ audio extension as raw audio we will need to adjust\n+    \/\/ start time by video stream target duration, so PTS\n+    \/\/ will align properly.\n+    private long videoStreamTargetDuration = 0;\n+    private String audioGroupID = null;\n+\n+    Playlist(URI uri) {\n+        playlistURI = uri;\n+    }\n@@ -784,3 +1220,4 @@\n-            if (isLive) {\n-                duration = -1.0;\n-            }\n+    void update(String nextMediaFile) {\n+        PlaylistParser parser = new PlaylistParser();\n+        parser.setPlaylist(this);\n+        parser.load(playlistURI);\n@@ -788,5 +1225,4 @@\n-            if (setSequenceNumber(parser.getSequenceNumber())) {\n-                while (parser.hasNext()) {\n-                    addMediaFile(parser.getString(), parser.getDouble(), parser.getBoolean());\n-                }\n-            }\n+        isLive = parser.isLivePlaylist();\n+        if (isLive) {\n+            duration = -1.0;\n+        }\n@@ -794,8 +1230,7 @@\n-            if (nextMediaFile != null) {\n-                synchronized (lock) {\n-                    for (int i = 0; i < mediaFiles.size(); i++) {\n-                        String mediaFile = mediaFiles.get(i);\n-                        if (nextMediaFile.endsWith(mediaFile)) {\n-                            mediaFileIndex = i - 1;\n-                            break;\n-                        }\n+        if (nextMediaFile != null) {\n+            synchronized (lock) {\n+                for (int i = 0; i < mediaFiles.size(); i++) {\n+                    String mediaFile = mediaFiles.get(i);\n+                    if (nextMediaFile.endsWith(mediaFile)) {\n+                        mediaFileIndex = i - 1;\n+                        break;\n@@ -806,0 +1241,1 @@\n+    }\n@@ -807,3 +1243,3 @@\n-        private boolean isLive() {\n-            return isLive;\n-        }\n+    void setMediaFileIndex(int value) {\n+        mediaFileIndex = value;\n+    }\n@@ -811,3 +1247,3 @@\n-        private boolean isFragmentedMP4() {\n-            return (getMimeType() == HLS_VALUE_MIMETYPE_FMP4);\n-        }\n+    int getMediaFileIndex() {\n+        return mediaFileIndex;\n+    }\n@@ -815,3 +1251,3 @@\n-        private long getTargetDuration() {\n-            return targetDuration;\n-        }\n+    boolean isLive() {\n+        return isLive;\n+    }\n@@ -819,3 +1255,3 @@\n-        private void setPlaylistURI(URI uri) {\n-            playlistURI = uri;\n-        }\n+    boolean isFragmentedMP4() {\n+        return (getMimeType() == HLS_VALUE_MIMETYPE_FMP4);\n+    }\n@@ -823,2 +1259,3 @@\n-        private void addMediaFile(String URI, double duration, boolean isDiscontinuity) {\n-            synchronized (lock) {\n+    void setTargetDuration(long value) {\n+        targetDuration = value;\n+    }\n@@ -826,3 +1263,3 @@\n-                if (needBaseURI) {\n-                    setBaseURI(playlistURI.toString(), URI);\n-                }\n+    long getTargetDuration() {\n+        return targetDuration;\n+    }\n@@ -830,17 +1267,3 @@\n-                if (isLive) {\n-                    if (sequenceNumberUpdated) {\n-                        int index = mediaFiles.indexOf(URI);\n-                        if (index != -1) {\n-                            for (int i = 0; i < index; i++) {\n-                                mediaFiles.remove(0);\n-                                mediaFilesDiscontinuities.remove(0);\n-                                if (mediaFileIndex == -1) {\n-                                    forceDiscontinuity = true;\n-                                }\n-                                if (mediaFileIndex >= 0) {\n-                                    mediaFileIndex--;\n-                                }\n-                            }\n-                        }\n-                        sequenceNumberUpdated = false;\n-                    }\n+    void setVideoStreamTargetDuration(long value) {\n+        videoStreamTargetDuration = value;\n+    }\n@@ -848,4 +1271,3 @@\n-                    if (mediaFiles.contains(URI)) {\n-                        return; \/\/ Nothing to add\n-                    }\n-                }\n+    void setIsVideoStreamFragmentedMP4(boolean value) {\n+        isVideoStreamFragmentedMP4 = value;\n+    }\n@@ -853,2 +1275,2 @@\n-                mediaFiles.add(URI);\n-                mediaFilesDiscontinuities.add(isDiscontinuity);\n+    void addMediaFile(String URI, double duration, boolean isDiscontinuity) {\n+        synchronized (lock) {\n@@ -856,18 +1278,2 @@\n-                if (isLive) {\n-                    if (isLiveWaiting) {\n-                        liveSemaphore.release();\n-                    }\n-                } else {\n-                    mediaFilesStartTimes.add(this.startTime);\n-                    this.startTime += duration;\n-\n-                    \/\/ For fragmented MP4 we should not add duration of first\n-                    \/\/ segment, since it is header without actuall data.\n-                    if (mediaFiles.size() == 1) {\n-                        if (!isFragmentedMP4()) {\n-                            this.duration += duration;\n-                        }\n-                    } else {\n-                        this.duration += duration;\n-                    }\n-                }\n+            if (needBaseURI) {\n+                setBaseURI(playlistURI.toString(), URI);\n@@ -875,1 +1281,0 @@\n-        }\n@@ -877,1 +1282,0 @@\n-        private String getNextMediaFile() {\n@@ -879,10 +1283,12 @@\n-                synchronized (lock) {\n-                    isLiveWaiting = ((mediaFileIndex + 1) >= mediaFiles.size());\n-                }\n-                if (isLiveWaiting) {\n-                    try {\n-                        liveSemaphore.acquire();\n-                        isLiveWaiting = false;\n-                        if (isLiveStop) {\n-                            isLiveStop = false;\n-                            return null;\n+                if (sequenceNumberUpdated) {\n+                    int index = mediaFiles.indexOf(URI);\n+                    if (index != -1) {\n+                        for (int i = 0; i < index; i++) {\n+                            mediaFiles.remove(0);\n+                            mediaFilesDiscontinuities.remove(0);\n+                            if (mediaFileIndex == -1) {\n+                                forceDiscontinuity = true;\n+                            }\n+                            if (mediaFileIndex >= 0) {\n+                                mediaFileIndex--;\n+                            }\n@@ -890,3 +1296,0 @@\n-                    } catch (InterruptedException e) {\n-                        isLiveWaiting = false;\n-                        return null;\n@@ -894,0 +1297,1 @@\n+                    sequenceNumberUpdated = false;\n@@ -895,2 +1299,3 @@\n-                if (isPlaylistClosed) {\n-                    return null;\n+\n+                if (mediaFiles.contains(URI)) {\n+                    return; \/\/ Nothing to add\n@@ -900,7 +1305,16 @@\n-            synchronized (lock) {\n-                mediaFileIndex++;\n-                if (mediaFileIndex < mediaFiles.size()) {\n-                    if (baseURI != null) {\n-                        return baseURI + mediaFiles.get(mediaFileIndex);\n-                    } else {\n-                        return mediaFiles.get(mediaFileIndex);\n+            mediaFiles.add(URI);\n+            mediaFilesDiscontinuities.add(isDiscontinuity);\n+\n+            if (isLive) {\n+                if (isLiveWaiting) {\n+                    liveSemaphore.release();\n+                }\n+            } else {\n+                mediaFilesStartTimes.add(this.startTime);\n+                this.startTime += duration;\n+\n+                \/\/ For fragmented MP4 we should not add duration of first\n+                \/\/ segment, since it is header without actually data.\n+                if (mediaFiles.size() == 1) {\n+                    if (!isFragmentedMP4()) {\n+                        this.duration += duration;\n@@ -909,1 +1323,1 @@\n-                    return null;\n+                    this.duration += duration;\n@@ -913,0 +1327,1 @@\n+    }\n@@ -914,1 +1329,2 @@\n-        private String getHeaderFile() {\n+    String getNextMediaFile() {\n+        if (isLive) {\n@@ -916,5 +1332,9 @@\n-                if (mediaFiles.size() > 0) {\n-                    if (baseURI != null) {\n-                        return baseURI + mediaFiles.get(0);\n-                    } else {\n-                        return mediaFiles.get(0);\n+                isLiveWaiting = ((mediaFileIndex + 1) >= mediaFiles.size());\n+            }\n+            if (isLiveWaiting) {\n+                try {\n+                    liveSemaphore.acquire();\n+                    isLiveWaiting = false;\n+                    if (isLiveStop) {\n+                        isLiveStop = false;\n+                        return null;\n@@ -922,1 +1342,2 @@\n-                } else {\n+                } catch (InterruptedException e) {\n+                    isLiveWaiting = false;\n@@ -926,0 +1347,3 @@\n+            if (isPlaylistClosed) {\n+                return null;\n+            }\n@@ -928,1 +1352,2 @@\n-        private double getMediaFileStartTime() {\n+        synchronized (lock) {\n+            mediaFileIndex++;\n@@ -930,1 +1355,7 @@\n-                return mediaFilesStartTimes.get(mediaFileIndex);\n+                if (baseURI != null) {\n+                    return baseURI + mediaFiles.get(mediaFileIndex);\n+                } else {\n+                    return mediaFiles.get(mediaFileIndex);\n+                }\n+            } else {\n+                return null;\n@@ -932,2 +1363,0 @@\n-\n-            return 0.0;\n@@ -935,0 +1364,1 @@\n+    }\n@@ -936,2 +1366,11 @@\n-        private double getDuration() {\n-            return duration;\n+    String getHeaderFile() {\n+        synchronized (lock) {\n+            if (mediaFiles.size() > 0) {\n+                if (baseURI != null) {\n+                    return baseURI + mediaFiles.get(0);\n+                } else {\n+                    return mediaFiles.get(0);\n+                }\n+            } else {\n+                return null;\n+            }\n@@ -939,0 +1378,1 @@\n+    }\n@@ -940,3 +1380,3 @@\n-        private void setForceDiscontinuity(boolean value) {\n-            forceDiscontinuity = value;\n-        }\n+    double getMediaFileStartTime() {\n+        return getMediaFileStartTime(mediaFileIndex);\n+    }\n@@ -944,4 +1384,5 @@\n-        private boolean isCurrentMediaFileDiscontinuity() {\n-            if (forceDiscontinuity) {\n-                forceDiscontinuity = false;\n-                return true;\n+    double getMediaFileStartTime(int index) {\n+        if (index >= 0 && index < mediaFilesStartTimes.size()) {\n+            \/\/ Special case if video is fMP4 and audio ext is not\n+            if (isVideoStreamFragmentedMP4 && !isFragmentedMP4() && index != 0) {\n+                return (mediaFilesStartTimes.get(index) + (double)videoStreamTargetDuration);\n@@ -949,1 +1390,1 @@\n-                return mediaFilesDiscontinuities.get(mediaFileIndex);\n+                return mediaFilesStartTimes.get(index);\n@@ -953,31 +1394,51 @@\n-        private double seek(long time) {\n-            synchronized (lock) {\n-                if (isLive) {\n-                    if (time == 0) {\n-                        if (isFragmentedMP4()) {\n-                            mediaFileIndex = 0; \/\/ Skip header at 0 index\n-                            \/\/ we will send it with first segment if needed.\n-                        } else {\n-                            mediaFileIndex = -1;\n-                        }\n-                        if (isLiveWaiting) {\n-                            isLiveStop = true;\n-                            liveSemaphore.release();\n-                        }\n-                        return 0;\n-                    }\n-                } else {\n-                    time += targetDuration \/ 2000;\n-\n-                    int mediaFileStartTimeSize = mediaFilesStartTimes.size();\n-\n-                    for (int index = 0; index < mediaFileStartTimeSize; index++) {\n-                        if (time >= mediaFilesStartTimes.get(index)) {\n-                            if (index + 1 < mediaFileStartTimeSize) {\n-                                if (time < mediaFilesStartTimes.get(index + 1)) {\n-                                    if (isFragmentedMP4()) {\n-                                        mediaFileIndex = index;\n-                                    } else {\n-                                        mediaFileIndex = index - 1; \/\/ Seek will load segment and increment mediaFileIndex\n-                                    }\n-                                    return mediaFilesStartTimes.get(index);\n+        return -1.0;\n+    }\n+\n+    double getDuration() {\n+        return duration;\n+    }\n+\n+    void setForceDiscontinuity(boolean value) {\n+        forceDiscontinuity = value;\n+    }\n+\n+    boolean isCurrentMediaFileDiscontinuity() {\n+        if (forceDiscontinuity) {\n+            forceDiscontinuity = false;\n+            return true;\n+        } else {\n+            return mediaFilesDiscontinuities.get(mediaFileIndex);\n+        }\n+    }\n+\n+    double seekGetStartTime(long time) {\n+        synchronized (lock) {\n+            int newIndex = 0;\n+            if (isLive) {\n+                if (time == 0) {\n+                    return 0.0;\n+                }\n+            } else {\n+                time += targetDuration \/ 2000;\n+\n+                int mediaFileStartTimeSize = mediaFilesStartTimes.size();\n+\n+                for (int index = 0; index < mediaFileStartTimeSize; index++) {\n+                    if (time >= mediaFilesStartTimes.get(index)) {\n+                        if (index + 1 < mediaFileStartTimeSize) {\n+                            if (time < mediaFilesStartTimes.get(index + 1)) {\n+                                if (isFragmentedMP4()) {\n+                                    newIndex = index; \/\/ We need to skip header\n+                                } else {\n+                                    newIndex = index - 1; \/\/ Load segment will increment mediaFileIndex\n+                                }\n+                                \/\/ Special case for seek to 0 and fragmented MP4.\n+                                \/\/ We should return 0, instead of first segment, since\n+                                \/\/ first segment starts with target duration, but\n+                                \/\/ GStreamer expects 0 as start of stream time.\n+                                \/\/ Start of segment will be set to target duration\n+                                \/\/ when reported from HLS_PROP_SEGMENT_START_TIME.\n+                                \/\/ Same should be for video fMP4 and raw audio.\n+                                \/\/if (time == 0 && (isFragmentedMP4() || (isVideoStreamFragmentedMP4 && !isFragmentedMP4()))) {\n+                                if (time == 0 && isFragmentedMP4()) {\n+                                    return 0.0;\n@@ -985,10 +1446,9 @@\n-                            } else {\n-                                if ((time - targetDuration \/ 2000) < duration) {\n-                                    if (isFragmentedMP4()) {\n-                                        mediaFileIndex = index;\n-                                    } else {\n-                                        mediaFileIndex = index - 1; \/\/ Seek will load segment and increment mediaFileIndex\n-                                    }\n-                                    return mediaFilesStartTimes.get(index);\n-                                } else if (Double.compare(time - targetDuration \/ 2000, duration) == 0) {\n-                                    return duration;\n+                                \/\/ Return start time of segment we will load (mediaFileIndex + 1)\n+                                return getMediaFileStartTime(newIndex + 1);\n+                            }\n+                        } else {\n+                            if ((time - targetDuration \/ 2000) < duration) {\n+                                if (isFragmentedMP4()) {\n+                                    newIndex = index; \/\/ We need to skip header\n+                                } else {\n+                                    newIndex = index - 1; \/\/ Load segment will increment mediaFileIndex\n@@ -996,0 +1456,4 @@\n+                                \/\/ Return start time of segment we will load (mediaFileIndex + 1)\n+                                return getMediaFileStartTime(newIndex + 1);\n+                            } else if (Double.compare(time - targetDuration \/ 2000, duration) == 0) {\n+                                return duration;\n@@ -1001,2 +1465,0 @@\n-\n-            return -1;\n@@ -1005,13 +1467,59 @@\n-        private int getMimeType() {\n-            synchronized (lock) {\n-                if (mimeType == HLS_VALUE_MIMETYPE_UNKNOWN) {\n-                    if (mediaFiles.size() > 0) {\n-                        if (stripParameters(mediaFiles.get(0)).endsWith(\".ts\")) {\n-                            mimeType = HLS_VALUE_MIMETYPE_MP2T;\n-                        } else if (stripParameters(mediaFiles.get(0)).endsWith(\".mp3\")) {\n-                            mimeType = HLS_VALUE_MIMETYPE_MP3;\n-                        } else if (stripParameters(mediaFiles.get(0)).endsWith(\".mp4\")\n-                                || stripParameters(mediaFiles.get(0)).endsWith(\".m4s\")) {\n-                            mimeType = HLS_VALUE_MIMETYPE_FMP4;\n-                        } else if (stripParameters(mediaFiles.get(0)).endsWith(\".aac\")) {\n-                            mimeType = HLS_VALUE_MIMETYPE_AAC;\n+        return -1.0;\n+    }\n+\n+    double seek(long time) {\n+        synchronized (lock) {\n+            if (isLive) {\n+                if (time == 0) {\n+                    if (isFragmentedMP4()) {\n+                        mediaFileIndex = 0; \/\/ Skip header at 0 index\n+                        \/\/ we will send it with first segment if needed.\n+                    } else {\n+                        mediaFileIndex = -1;\n+                    }\n+                    if (isLiveWaiting) {\n+                        isLiveStop = true;\n+                        liveSemaphore.release();\n+                    }\n+                    return 0;\n+                }\n+            } else {\n+                time += targetDuration \/ 2000;\n+\n+                int mediaFileStartTimeSize = mediaFilesStartTimes.size();\n+\n+                for (int index = 0; index < mediaFileStartTimeSize; index++) {\n+                    if (time >= mediaFilesStartTimes.get(index)) {\n+                        if (index + 1 < mediaFileStartTimeSize) {\n+                            if (time < mediaFilesStartTimes.get(index + 1)) {\n+                                if (isFragmentedMP4()) {\n+                                    mediaFileIndex = index; \/\/ We need to skip header\n+                                } else {\n+                                    mediaFileIndex = index - 1; \/\/ Load segment will increment mediaFileIndex\n+                                }\n+                                \/\/ Special case for seek to 0 and fragmented MP4.\n+                                \/\/ We should return 0, instead of first segment, since\n+                                \/\/ first segment starts with target duration, but\n+                                \/\/ GStreamer expects 0 as start of stream time.\n+                                \/\/ Start of segment will be set to target duration\n+                                \/\/ when reported from HLS_PROP_SEGMENT_START_TIME.\n+                                \/\/ Same should be for video fMP4 and raw audio.\n+                                \/\/if (time == 0 && (isFragmentedMP4() || (isVideoStreamFragmentedMP4 && !isFragmentedMP4()))) {\n+                                if (time == 0 && isFragmentedMP4()) {\n+                                    return 0.0;\n+                                }\n+                                \/\/ Return start time of segment we will load (mediaFileIndex + 1)\n+                                return getMediaFileStartTime(mediaFileIndex + 1);\n+                            }\n+                        } else {\n+                            if ((time - targetDuration \/ 2000) < duration) {\n+                                if (isFragmentedMP4()) {\n+                                    mediaFileIndex = index; \/\/ We need to skip header\n+                                } else {\n+                                    mediaFileIndex = index - 1; \/\/ Load segment will increment mediaFileIndex\n+                                }\n+                                \/\/ Return start time of segment we will load (mediaFileIndex + 1)\n+                                return getMediaFileStartTime(mediaFileIndex + 1);\n+                            } else if (Double.compare(time - targetDuration \/ 2000, duration) == 0) {\n+                                return duration;\n+                            }\n@@ -1022,2 +1530,0 @@\n-\n-            return mimeType;\n@@ -1026,2 +1532,6 @@\n-        private String getMediaFileExtension() {\n-            synchronized (lock) {\n+        return -1;\n+    }\n+\n+    int getMimeType() {\n+        synchronized (lock) {\n+            if (mimeType == HLS_VALUE_MIMETYPE_UNKNOWN) {\n@@ -1029,4 +1539,9 @@\n-                    String mediaFile = stripParameters(mediaFiles.get(0));\n-                    int index = mediaFile.lastIndexOf(\".\");\n-                    if (index != -1) {\n-                        return mediaFile.substring(index);\n+                    if (stripParameters(mediaFiles.get(0)).endsWith(\".ts\")) {\n+                        mimeType = HLS_VALUE_MIMETYPE_MP2T;\n+                    } else if (stripParameters(mediaFiles.get(0)).endsWith(\".mp3\")) {\n+                        mimeType = HLS_VALUE_MIMETYPE_MP3;\n+                    } else if (stripParameters(mediaFiles.get(0)).endsWith(\".mp4\")\n+                            || stripParameters(mediaFiles.get(0)).endsWith(\".m4s\")) {\n+                        mimeType = HLS_VALUE_MIMETYPE_FMP4;\n+                    } else if (stripParameters(mediaFiles.get(0)).endsWith(\".aac\")) {\n+                        mimeType = HLS_VALUE_MIMETYPE_AAC;\n@@ -1036,2 +1551,0 @@\n-\n-            return null;\n@@ -1040,8 +1553,11 @@\n-        private boolean setSequenceNumber(int value) {\n-            if (sequenceNumberStart == -1) {\n-                sequenceNumberStart = value;\n-            } else if (sequenceNumber != value) {\n-                sequenceNumberUpdated = true;\n-                sequenceNumber = value;\n-            } else {\n-                return false;\n+        return mimeType;\n+    }\n+\n+    String getMediaFileExtension() {\n+        synchronized (lock) {\n+            if (mediaFiles.size() > 0) {\n+                String mediaFile = stripParameters(mediaFiles.get(0));\n+                int index = mediaFile.lastIndexOf(\".\");\n+                if (index != -1) {\n+                    return mediaFile.substring(index);\n+                }\n@@ -1049,0 +1565,1 @@\n+        }\n@@ -1050,1 +1567,11 @@\n-            return true;\n+        return null;\n+    }\n+\n+    boolean setSequenceNumber(int value) {\n+        if (sequenceNumberStart == -1) {\n+            sequenceNumberStart = value;\n+        } else if (sequenceNumber != value) {\n+            sequenceNumberUpdated = true;\n+            sequenceNumber = value;\n+        } else {\n+            return false;\n@@ -1053,5 +1580,7 @@\n-        private void close() {\n-            if (isLive) {\n-                isPlaylistClosed = true;\n-                liveSemaphore.release();\n-            }\n+        return true;\n+    }\n+\n+    void close() {\n+        if (isLive) {\n+            isPlaylistClosed = true;\n+            liveSemaphore.release();\n@@ -1059,0 +1588,1 @@\n+    }\n@@ -1060,5 +1590,3 @@\n-        private void setBaseURI(String playlistURI, String URI) {\n-            if (!URI.startsWith(\"http:\/\/\") && !URI.startsWith(\"https:\/\/\")) {\n-                baseURI = playlistURI.substring(0, playlistURI.lastIndexOf(\"\/\") + 1);\n-            }\n-            needBaseURI = false;\n+    private void setBaseURI(String playlistURI, String URI) {\n+        if (!URI.startsWith(\"http:\/\/\") && !URI.startsWith(\"https:\/\/\")) {\n+            baseURI = playlistURI.substring(0, playlistURI.lastIndexOf(\"\/\") + 1);\n@@ -1066,0 +1594,9 @@\n+        needBaseURI = false;\n+    }\n+\n+    void setAudioGroupID(String value) {\n+        audioGroupID = value;\n+    }\n+\n+    String getAudioGroupID() {\n+        return audioGroupID;\n","filename":"modules\/javafx.media\/src\/main\/java\/com\/sun\/media\/jfxmedia\/locator\/HLSConnectionHolder.java","additions":1171,"deletions":634,"binary":false,"changes":1805,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -634,0 +634,8 @@\n+    public ConnectionHolder getAudioStreamConnectionHolder(ConnectionHolder connectionHolder) throws IOException {\n+        if (connectionHolder == null) {\n+            return null;\n+        }\n+\n+        return connectionHolder.getAudioStream();\n+    }\n+\n","filename":"modules\/javafx.media\/src\/main\/java\/com\/sun\/media\/jfxmedia\/locator\/Locator.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n- *     <td><a href=\"http:\/\/tools.ietf.org\/html\/draft-pantos-http-live-streaming\">Internet-Draft: HTTP Live Streaming<\/a><\/td>\n+ *     <td><a href=\"https:\/\/datatracker.ietf.org\/doc\/html\/rfc8216\">HTTP Live Streaming (RFC 8216)<\/a><\/td>\n@@ -159,2 +159,3 @@\n- *     <li>Elementary MP3 audio streams (audio\/mpegurl) and multiplexed MP2T streams\n- *         (application\/vnd.apple.mpegurl) with one AAC audio and one H.264\/AVC video track.<\/li>\n+ *     <li>Elementary MP3 and AAC audio streams (audio\/mpegurl).<\/li>\n+ *     <li>Multiplexed MP2T streams (application\/vnd.apple.mpegurl) with one AAC audio and one H.264\/AVC video track.<\/li>\n+ *     <li>Multiplexed fMP4 streams (application\/vnd.apple.mpegurl) with one AAC audio and one H.264\/AVC or H.265\/HEVC video track.<\/li>\n@@ -162,0 +163,7 @@\n+ *     <li>Additional audio renditions via #EXT-X-MEDIA tag:\n+ *         <ul>\n+ *             <li>MP2T streams with one H.264\/AVC video track and elementary AAC audio stream via #EXT-X-MEDIA tag.<\/li>\n+ *             <li>fMP4 streams with one H.264\/AVC or H.265\/HEVC video track and elementary AAC audio stream via #EXT-X-MEDIA tag.<\/li>\n+ *             <li>fMP4 streams with one H.264\/AVC or H.265\/HEVC video track and fMP4 streams with one AAC audio track via #EXT-X-MEDIA tag.<\/li>\n+ *         <\/ul>\n+ *     <\/li>\n","filename":"modules\/javafx.media\/src\/main\/java\/javafx\/scene\/media\/package-info.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -660,1 +660,1 @@\n-    g_print(\"audiodecoder: ts=%.4f, duration=%.4f \",\n+    g_print(\"audiodecoder: input buffer ts=%.4f, duration=%.4f\\n\",\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/av\/audiodecoder.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -459,1 +459,1 @@\n-                        time != GST_CLOCK_TIME_NONE ? (double)time\/GST_SECOND : -1.0);\n+                    segment.time != GST_CLOCK_TIME_NONE ? (double)segment.time\/GST_SECOND : -1.0);\n@@ -752,1 +752,3 @@\n-            g_print(\"MpegTS: [Video] NEWSEGMENT: last_stop = %.4f\\n\", (double) stream->segment.last_stop \/ GST_SECOND);\n+            g_print(\"MpegTS: [Video] NEWSEGMENT: start = %.4f stop = %.4f time = %.4f position = %.4f\\n\",\n+                (double) newsegment.start \/ GST_SECOND, (double) newsegment.stop \/ GST_SECOND,\n+                (double) newsegment.time \/ GST_SECOND, (double) newsegment.position \/ GST_SECOND);\n@@ -839,1 +841,3 @@\n-            g_print(\"MpegTS: [Audio] NEWSEGMENT: last_stop = %.4f\\n\", (double) stream->segment.last_stop \/ GST_SECOND);\n+            g_print(\"MpegTS: [Audio] NEWSEGMENT: start = %.4f stop = %.4f time = %.4f position = %.4f\\n\",\n+                (double) newsegment.start \/ GST_SECOND, (double) newsegment.stop \/ GST_SECOND,\n+                (double) newsegment.time \/ GST_SECOND, (double) newsegment.position \/ GST_SECOND);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/av\/mpegtsdemuxer.c","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -911,1 +911,3 @@\n-                g_print(\"videodecoder: pushing buffer ts=%.4f sec\", (double)GST_BUFFER_TIMESTAMP(outbuf)\/GST_SECOND);\n+                g_print(\"videodecoder: pushing buffer ts=%.4f, duration=%.4f\\n\",\n+                    GST_BUFFER_TIMESTAMP_IS_VALID(outbuf) ? (double)GST_BUFFER_TIMESTAMP(outbuf)\/GST_SECOND : -1.0,\n+                    GST_BUFFER_DURATION_IS_VALID(outbuf) ? (double)GST_BUFFER_DURATION(outbuf)\/GST_SECOND : -1.0);\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/av\/videodecoder.c","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,0 +112,5 @@\n+    \/\/ If set MP2T demuxer will not reset PTS to 0 after\n+    \/\/ seek. Required to be true when we playback two\n+    \/\/ separate streams like video in TS and raw audio.\n+    \/\/ Used by HLS with EXT-X-MEDIA.\n+    PROP_DISABLE_MP2T_PTS_RESET\n@@ -278,0 +283,4 @@\n+\n+    g_object_class_install_property (gobject_class, PROP_DISABLE_MP2T_PTS_RESET,\n+        g_param_spec_boolean (\"disable-mp2t-pts-reset\", \"MP2T PTS Reset\", \"Disable\/Enable PTS reset\", FALSE,\n+        (GParamFlags)(G_PARAM_WRITABLE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS)));\n@@ -358,1 +367,1 @@\n-    decoder->set_base_pts = FALSE;\n+    decoder->disable_mp2t_pts_reset = FALSE;\n@@ -423,0 +432,2 @@\n+    case PROP_DISABLE_MP2T_PTS_RESET:\n+        decoder->disable_mp2t_pts_reset = g_value_get_boolean(value);\n@@ -668,2 +679,12 @@\n-                if (gst_pts >= decoder->base_pts && gst_pts > decoder->last_pts[index] && gst_pts - decoder->last_pts[index] < PTS_WRAPAROUND_THRESHOLD)\n-                    GST_BUFFER_TIMESTAMP(pBuffer) = gst_pts - decoder->base_pts;\n+                \/\/ If last_pts is not valid, just set PTS on buffer, otherwise we will be\n+                \/\/ missing PTS on first buffer.\n+                if (GST_CLOCK_TIME_IS_VALID(decoder->last_pts[index]))\n+                {\n+                    if (gst_pts >= decoder->base_pts && gst_pts > decoder->last_pts[index] && gst_pts - decoder->last_pts[index] < PTS_WRAPAROUND_THRESHOLD)\n+                        GST_BUFFER_TIMESTAMP(pBuffer) = gst_pts - decoder->base_pts;\n+                }\n+                else\n+                {\n+                    if (gst_pts >= decoder->base_pts)\n+                        GST_BUFFER_TIMESTAMP(pBuffer) = gst_pts - decoder->base_pts;\n+                }\n@@ -735,1 +756,1 @@\n-            \/\/ Use it only for uncomressed data. For compressed it is valid to have backward PTS.\n+            \/\/ Use it only for uncompressed data. For compressed it is valid to have backward PTS.\n@@ -3005,1 +3026,2 @@\n-        if (decoder->eInputFormat == MEDIA_FORMAT_STREAM_MP2T) \/\/ Resend new segment event with GST_FORMAT_TIME\n+        \/\/ Resend new segment event with GST_FORMAT_TIME\n+        if (!decoder->disable_mp2t_pts_reset && decoder->eInputFormat == MEDIA_FORMAT_STREAM_MP2T)\n@@ -3269,1 +3291,3 @@\n-                    decoder->base_pts = GST_CLOCK_TIME_NONE;\n+                    \/\/ Do not reset base PTS, if PTS reset disabled\n+                    if (!decoder->disable_mp2t_pts_reset)\n+                        decoder->base_pts = GST_CLOCK_TIME_NONE;\n@@ -3273,1 +3297,1 @@\n-                        decoder->last_pts[index] = 0;\n+                        decoder->last_pts[index] = GST_CLOCK_TIME_NONE;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/dshowwrapper\/dshowwrapper.cpp","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,0 @@\n-    gboolean set_base_pts;\n@@ -160,0 +159,2 @@\n+\n+    gboolean disable_mp2t_pts_reset;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/dshowwrapper\/dshowwrapper.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -148,0 +148,1 @@\n+gst_bin_recalculate_latency\t@148\tNONAME\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/win\/gstreamer-lite.def","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,2 +56,3 @@\n-    static jmethodID mid_GetStringLocation = NULL;\n-    jstring result = NULL;\n+    if (env == NULL || locator == NULL)\n+        return NULL;\n+\n@@ -60,0 +61,1 @@\n+    static jmethodID mid_GetStringLocation = NULL;\n@@ -72,1 +74,1 @@\n-    result = (jstring)env->CallObjectMethod(locator, mid_GetStringLocation);\n+    jstring result = (jstring)env->CallObjectMethod(locator, mid_GetStringLocation);\n@@ -81,0 +83,52 @@\n+jobject CLocator::CreateConnectionHolder(JNIEnv *env, jobject locator)\n+{\n+    if (env == NULL || locator == NULL)\n+        return NULL;\n+\n+    CJavaEnvironment javaEnv(env);\n+\n+    static jmethodID mid_CreateConnectionHolder = NULL;\n+    if (mid_CreateConnectionHolder == NULL)\n+    {\n+        jclass klass = env->GetObjectClass(locator);\n+        mid_CreateConnectionHolder = env->GetMethodID(klass,\n+                \"createConnectionHolder\", \"()Lcom\/sun\/media\/jfxmedia\/locator\/ConnectionHolder;\");\n+        env->DeleteLocalRef(klass);\n+        if (javaEnv.reportException() || (mid_CreateConnectionHolder == NULL))\n+            return NULL;\n+    }\n+\n+    jobject connectionHolder = env->CallObjectMethod(locator, mid_CreateConnectionHolder);\n+    if (javaEnv.reportException())\n+        return NULL;\n+\n+    return connectionHolder;\n+}\n+\n+jobject CLocator::GetAudioStreamConnectionHolder(JNIEnv *env, jobject locator, jobject connectionHolder)\n+{\n+    if (env == NULL || locator == NULL || connectionHolder == NULL)\n+        return NULL;\n+\n+    CJavaEnvironment javaEnv(env);\n+\n+    static jmethodID mid_GetAudioStreamConnectionHolder = NULL;\n+    if (mid_GetAudioStreamConnectionHolder == NULL)\n+    {\n+        jclass klass = env->GetObjectClass(locator);\n+        mid_GetAudioStreamConnectionHolder = env->GetMethodID(klass,\n+                \"getAudioStreamConnectionHolder\",\n+                \"(Lcom\/sun\/media\/jfxmedia\/locator\/ConnectionHolder;)Lcom\/sun\/media\/jfxmedia\/locator\/ConnectionHolder;\");\n+        env->DeleteLocalRef(klass);\n+        if (javaEnv.reportException() || (GetAudioStreamConnectionHolder == NULL))\n+            return NULL;\n+    }\n+\n+    jobject audioStreamConnectionHolder = env->CallObjectMethod(locator,\n+            mid_GetAudioStreamConnectionHolder, connectionHolder);\n+    if (javaEnv.reportException())\n+        return NULL;\n+\n+    return audioStreamConnectionHolder;\n+}\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/Locator\/Locator.cpp","additions":58,"deletions":4,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,3 @@\n+    static jobject CreateConnectionHolder(JNIEnv *env, jobject locator);\n+    static jobject GetAudioStreamConnectionHolder(JNIEnv *env, jobject locator, jobject connectionHolder);\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/Locator\/Locator.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+    m_pAudioStreamCallbacks = NULL;\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/Locator\/LocatorStream.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,0 +86,3 @@\n+    inline void SetAudioCallbacks(CStreamCallbacks *callbacks) { m_pAudioStreamCallbacks = callbacks; }\n+    inline CStreamCallbacks* GetAudioCallbacks() { return m_pAudioStreamCallbacks; }\n+\n@@ -88,0 +91,5 @@\n+    \/\/ Callbacks to read separate audio stream. Current use case is HLS.\n+    \/\/ ContentType of CLocatorStream is set to content type of main URL.\n+    \/\/ Actual media mimetype of stream is read via HLS_PROP_GET_MIMETYPE property for HLS.\n+    \/\/ For non-HLS streams media mimetype is same as contentType.\n+    CStreamCallbacks *m_pAudioStreamCallbacks;\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/Locator\/LocatorStream.h","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,28 +114,0 @@\n-bool CMediaManager::CanPlayContentType(string contentType)\n-{\n-    CPipelineFactory*   pPipelineFactory = NULL;\n-    uint32_t            uRetCode;\n-\n-    uRetCode = CPipelineFactory::GetInstance(&pPipelineFactory);\n-    if (ERROR_NONE != uRetCode)\n-        return false;\n-    else if (NULL == pPipelineFactory)\n-        return false;\n-\n-    return pPipelineFactory->CanPlayContentType(contentType);\n-}\n-\n-const ContentTypesList& CMediaManager::GetSupportedContentTypes()\n-{\n-    CPipelineFactory*   pPipelineFactory = NULL;\n-    uint32_t            uRetCode;\n-\n-    uRetCode = CPipelineFactory::GetInstance(&pPipelineFactory);\n-    if (ERROR_NONE != uRetCode)\n-        return EMPTY_LIST;\n-    else if (NULL == pPipelineFactory)\n-        return EMPTY_LIST;\n-\n-    return pPipelineFactory->GetSupportedContentTypes();\n-}\n-\n@@ -194,66 +166,0 @@\n-\n-\/**\n- * CMediaManager::CreateMedia(CLocator locator)\n- *\n- * Creates a media object, given a locator and a set of options.\n- *\n- * @param   pLocator    pointer to a CLocator object\n- * @param   pOptions    pointer to a CPipelienOptions object\n- *\n- * @return  Pointer to a new CMedia object.\n- *\/\n-uint32_t CMediaManager::CreateMedia(CLocator* pLocator, CPipelineOptions* pOptions, CMedia** ppMedia)\n-{\n-    CPipeline*          pPipeline = NULL;\n-    CPipelineFactory*   pPipelineFactory = NULL;\n-    uint32_t            uRetCode;\n-\n-    if (NULL == pLocator)\n-        return ERROR_LOCATOR_NULL;\n-\n-    uRetCode = CPipelineFactory::GetInstance(&pPipelineFactory);\n-    if (ERROR_NONE != uRetCode)\n-        return uRetCode;\n-    else if (NULL == pPipelineFactory)\n-        return ERROR_FACTORY_NULL;\n-\n-    \/\/***** Initialize the return value\n-    *ppMedia    = NULL;\n-\n-    \/\/***** If we have a null option object, create one\n-    if (NULL == pOptions)\n-    {\n-        pOptions = new (nothrow) CPipelineOptions();\n-        if (NULL == pOptions)\n-            return ERROR_MEMORY_ALLOCATION;\n-    }\n-\n-    \/\/***** Do the real work\n-    if ((CPipelineOptions::kAudioPlaybackPipeline == pOptions->GetPipelineType()) || (CPipelineOptions::kAVPlaybackPipeline == pOptions->GetPipelineType()))\n-    {\n-        \/\/***** Create a player pipleine first\n-#if JFXMEDIA_DEBUG\n-        printf(\"-- CreateMedia : create player pipeline\\n\");\n-#endif\n-        uRetCode = pPipelineFactory->CreatePlayerPipeline(pLocator, pOptions, &pPipeline);\n-\n-        \/\/***** Create the new CMedia object\n-        if (ERROR_NONE == uRetCode)\n-        {\n-            \/\/***** Create a media object and attach the pipeline to the media object\n-            *ppMedia    = new(nothrow) CMedia(pPipeline);\n-\n-            if (NULL == *ppMedia)\n-            {\n-                \/\/Cleanup if media creation failed.\n-                delete pPipeline;\n-                uRetCode = ERROR_MEDIA_CREATION;\n-            }\n-        }\n-    }\n-\n-#if JFXMEDIA_DEBUG\n-        printf(\"-- CreateMedia : finish\\n\");\n-#endif\n-    return uRetCode;\n-}\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/MediaManagement\/MediaManager.cpp","additions":1,"deletions":95,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,3 +56,0 @@\n-    bool CanPlayContentType(string contentType);\n-    const ContentTypesList& GetSupportedContentTypes();\n-\n@@ -60,1 +57,0 @@\n-    uint32_t    CreateMedia(CLocator* pLocator, CPipelineOptions* pOptions, CMedia** ppMedia);\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/MediaManagement\/MediaManager.h","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,2 @@\n-class CMedia;\n+#define DEFAULT_AUDIO_TRACK_ID 0\n+#define DEFAULT_VIDEO_TRACK_ID 1\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/PipelineManagement\/Pipeline.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,3 +42,0 @@\n-    virtual bool CanPlayContentType(string contentType) = 0;\n-    virtual const ContentTypesList& GetSupportedContentTypes() = 0;\n-\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/PipelineManagement\/PipelineFactory.h","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,0 @@\n-#include <string.h>\n-#include <PipelineManagement\/VideoFrame.h>\n-#include <jni\/Logger.h>\n@@ -43,2 +40,2 @@\n-        kAudioPlaybackPipeline  = 0,\n-        kAVPlaybackPipeline     = 1\n+        kSingleSourcePipeline  = 0, \/\/ Indicates that pipeline is single source. It can be audio or video.\n+        kAudioSourcePipeline   = 1, \/\/ Indicates that pipeline is multi source and audio is secondary stream.\n@@ -47,1 +44,1 @@\n-    CPipelineOptions(int pipelineType=kAVPlaybackPipeline, bool havePreferredFormat = false)\n+    CPipelineOptions(int pipelineType = kSingleSourcePipeline)\n@@ -51,1 +48,3 @@\n-        m_bHLSModeEnabled(false)\n+        m_AudioStreamMimeType(-1),\n+        m_bHLSModeEnabled(false),\n+        m_audioFlags(0)\n@@ -56,0 +55,1 @@\n+    inline void SetPipelineType(int pipelineType) { m_PipelineType = pipelineType; }\n@@ -61,0 +61,3 @@\n+    inline void SetContentType(string contentType) { m_ContentType = contentType; }\n+    inline const string GetContentType() { return m_ContentType; }\n+\n@@ -64,0 +67,3 @@\n+    inline void SetAudioStreamMimeType(int audioStreamMimeType) { m_AudioStreamMimeType = audioStreamMimeType; }\n+    inline int GetAudioStreamMimeType() { return m_AudioStreamMimeType; }\n+\n@@ -67,0 +73,27 @@\n+    inline void  SetAudioFlags(int audioFlags) { m_audioFlags = audioFlags; }\n+    inline int  GetAudioFlags() { return m_audioFlags; }\n+\n+    \/\/ Returns true if we need to force default track ID. For multi source streams\n+    \/\/ two demuxers (qtdemux in case of fMP4 HLS with EXT-X-MEDIA) will report same\n+    \/\/ ID, since two demuxers are not aware of each other and that we actually\n+    \/\/ have two streams. Our code expects unique ID. We do not have actual use\n+    \/\/ of IDs except they shoule be unique.\n+    inline bool ForceDefaultTrackID() { return (m_PipelineType == kAudioSourcePipeline); }\n+\n+    inline CPipelineOptions* SetStreamParser(string streamParser) { m_StreamParser = streamParser; return this;}\n+    inline CPipelineOptions* SetAudioStreamParser(string ausioStreamParser) { m_AudioStreamParser = ausioStreamParser; return this;}\n+    inline CPipelineOptions* SetVideoDecoder(string videoDecoder) { m_VideoDecoder = videoDecoder; return this;}\n+    inline CPipelineOptions* SetAudioDecoder(string audioDecoder) { m_AudioDecoder = audioDecoder; return this;}\n+\n+    inline const char* GetStreamParser() { return GetCharFromString(&m_StreamParser); }\n+    inline const char* GetAudioStreamParser() { return GetCharFromString(&m_AudioStreamParser); }\n+    inline const char* GetVideoDecoder() { return GetCharFromString(&m_VideoDecoder); }\n+    inline const char* GetAudioDecoder() { return GetCharFromString(&m_AudioDecoder); }\n+\n+    inline const char* GetCharFromString(string *str) {\n+        if (str->empty())\n+            return NULL;\n+        else\n+            return str->c_str();\n+    }\n+\n@@ -70,0 +103,3 @@\n+    \/\/ ContentType based on content type of main URL.\n+    string      m_ContentType;\n+    \/\/ Main stream mime type, might be different than ContentType for HLS.\n@@ -71,0 +107,3 @@\n+    \/\/ Audio stream mime type, might be different than ContentType\n+    \/\/ and main stream mime type HLS.\n+    int         m_AudioStreamMimeType;\n@@ -72,0 +111,11 @@\n+    int         m_audioFlags;\n+\n+    \/\/ Audio parser or demultiplexer for main stream\n+    string      m_StreamParser;\n+    \/\/ Audio parser or demultiplexer for audio stream\n+    string      m_AudioStreamParser;\n+    \/\/ Audio decoder. Will be used with main stream if audio stream is not\n+    \/\/ present or will be used with audio stream if present\n+    string      m_AudioDecoder;\n+    \/\/ Video decoder. Always used with main stream.\n+    string      m_VideoDecoder;\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/PipelineManagement\/PipelineOptions.h","additions":58,"deletions":8,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-bool CJavaInputStreamCallbacks::Init(JNIEnv *env, jobject jLocator)\n+bool CJavaInputStreamCallbacks::Init(JNIEnv *env, jobject jConnectionHolder)\n@@ -53,0 +53,3 @@\n+    if (NULL == jConnectionHolder)\n+        return false;\n+\n@@ -62,15 +65,1 @@\n-    static jmethodID createConnectionHolder = NULL;\n-    if (NULL == createConnectionHolder)\n-    {\n-        jclass klass = env->GetObjectClass(jLocator);\n-        createConnectionHolder = env->GetMethodID(klass, \"createConnectionHolder\", \"()Lcom\/sun\/media\/jfxmedia\/locator\/ConnectionHolder;\");\n-        env->DeleteLocalRef(klass);\n-        if (javaEnv.reportException() || (NULL == createConnectionHolder))\n-            return false;\n-    }\n-\n-    jobject connectionHolder = env->CallObjectMethod(jLocator, createConnectionHolder);\n-    if (javaEnv.reportException() || (NULL == connectionHolder))\n-        return false;\n-\n-    m_ConnectionHolder = env->NewGlobalRef(connectionHolder);\n+    m_ConnectionHolder = env->NewGlobalRef(jConnectionHolder);\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/jni\/JavaInputStreamCallbacks.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    bool Init(JNIEnv *env, jobject jLocator);\n+    bool Init(JNIEnv *env, jobject jConnectionHolder);\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/jni\/JavaInputStreamCallbacks.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,0 +89,13 @@\n+    if (m_Elements[AUDIO_PARSER])\n+    {\n+        GstPad *src_pad = gst_element_get_static_pad(m_Elements[AUDIO_PARSER], \"src\");\n+        if (src_pad == NULL)\n+        {\n+            g_signal_connect(m_Elements[AUDIO_PARSER], \"pad-added\", G_CALLBACK (on_pad_added), this);\n+            g_signal_connect(m_Elements[AUDIO_PARSER], \"no-more-pads\", G_CALLBACK (no_more_pads), this);\n+        }\n+        else\n+        {\n+            gst_object_unref(src_pad);\n+        }\n+    }\n@@ -881,2 +894,4 @@\n-        if (!gst_structure_get_int(pStructure, \"track_id\", &trackID)) {\n-            trackID = 1; \/\/ default to 1 for video track, in case container doesn't have track IDs\n+        if (pPipeline->m_pOptions->ForceDefaultTrackID() ||\n+                !gst_structure_get_int(pStructure, \"track_id\", &trackID)) {\n+             \/\/ Use default ID in case container doesn't have track IDs\n+            trackID = DEFAULT_VIDEO_TRACK_ID;\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstAVPlaybackPipeline.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include <jni\/Logger.h>\n@@ -164,2 +165,26 @@\n-    if (m_Elements[AV_DEMUXER] == NULL)\n-        bStaticDecoderBin = true;\n+    if (m_pOptions->GetPipelineType() == CPipelineOptions::kAudioSourcePipeline)\n+    {\n+        \/\/ For pipeline with separate audio source we need to check AUDIO_PARSER.\n+        \/\/ If it is not set, then audio is static, otherwise we need to check if\n+        \/\/ AUDIO_PARSER has static src pad or not. If it has static src pad, then\n+        \/\/ audio is static, otherwise AVPipeline will handle dynamic audio parser.\n+        \/\/ AV_DEMUXER is video only.\n+        if (m_Elements[AUDIO_PARSER] == NULL)\n+        {\n+            bStaticDecoderBin = true;\n+        }\n+        else\n+        {\n+            GstPad *src_pad = gst_element_get_static_pad(m_Elements[AUDIO_PARSER], \"src\");\n+            if (src_pad != NULL)\n+            {\n+                bStaticDecoderBin = true;\n+                gst_object_unref(src_pad);\n+            }\n+        }\n+    }\n+    else\n+    {\n+        if (m_Elements[AV_DEMUXER] == NULL)\n+            bStaticDecoderBin = true;\n+    }\n@@ -178,1 +203,1 @@\n-        if (m_Elements[AUDIO_PARSER]) \/\/ Add method to link parser to decoder.\n+        if (m_Elements[AUDIO_PARSER] && m_pOptions->GetPipelineType() != CPipelineOptions::kAudioSourcePipeline) \/\/ Add method to link parser to decoder.\n@@ -193,0 +218,2 @@\n+        bool bUseAudioDecoder = true;\n+\n@@ -195,0 +222,1 @@\n+            \/\/ Audio parser might not have static src pad and in this case use audio decoder.\n@@ -196,4 +224,6 @@\n-            if (NULL == pPad)\n-                return ERROR_GSTREAMER_ELEMENT_GET_PAD;\n-            m_audioSourcePadProbeHID = gst_pad_add_probe(pPad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback)AudioSourcePadProbe, this, NULL);\n-            gst_object_unref(pPad);\n+            if (NULL != pPad)\n+            {\n+                m_audioSourcePadProbeHID = gst_pad_add_probe(pPad, GST_PAD_PROBE_TYPE_BUFFER, (GstPadProbeCallback)AudioSourcePadProbe, this, NULL);\n+                gst_object_unref(pPad);\n+                bUseAudioDecoder = false; \/\/ No need to use audio decoder for AudioTrack info.\n+            }\n@@ -201,1 +231,2 @@\n-        else if (m_Elements[AUDIO_DECODER])\n+\n+        if (bUseAudioDecoder && m_Elements[AUDIO_DECODER])\n@@ -583,3 +614,1 @@\n-    if (m_Elements[AUDIO_SINK] != NULL && m_bHasAudio && gst_element_seek(m_Elements[AUDIO_SINK], m_fRate, GST_FORMAT_TIME, seekFlags,\n-        GST_SEEK_TYPE_SET, seek_time,\n-        GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))\n+    if (m_pOptions->GetPipelineType() == CPipelineOptions::kAudioSourcePipeline)\n@@ -587,3 +616,11 @@\n-        m_SeekLock->Exit();\n-        CheckQueueSize(NULL);\n-        return ERROR_NONE;\n+        gboolean bSeekResult = FALSE;\n+        bSeekResult |= gst_element_seek(m_Elements[PIPELINE], m_fRate, GST_FORMAT_TIME, seekFlags,\n+                    GST_SEEK_TYPE_SET, seek_time,\n+                    GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE);\n+\n+        if (bSeekResult)\n+        {\n+            m_SeekLock->Exit();\n+            CheckQueueSize(NULL);\n+            return ERROR_NONE;\n+        }\n@@ -591,3 +628,1 @@\n-    else if (m_Elements[VIDEO_SINK] != NULL && m_bHasVideo && gst_element_seek(m_Elements[VIDEO_SINK], m_fRate, GST_FORMAT_TIME, seekFlags,\n-        GST_SEEK_TYPE_SET, seek_time,\n-        GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))\n+    else\n@@ -595,3 +630,16 @@\n-        m_SeekLock->Exit();\n-        CheckQueueSize(NULL);\n-        return ERROR_NONE;\n+        if (m_Elements[AUDIO_SINK] != NULL && m_bHasAudio && gst_element_seek(m_Elements[AUDIO_SINK], m_fRate, GST_FORMAT_TIME, seekFlags,\n+            GST_SEEK_TYPE_SET, seek_time,\n+            GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))\n+        {\n+            m_SeekLock->Exit();\n+            CheckQueueSize(NULL);\n+            return ERROR_NONE;\n+        }\n+        else if (m_Elements[VIDEO_SINK] != NULL && m_bHasVideo && gst_element_seek(m_Elements[VIDEO_SINK], m_fRate, GST_FORMAT_TIME, seekFlags,\n+            GST_SEEK_TYPE_SET, seek_time,\n+            GST_SEEK_TYPE_NONE, GST_CLOCK_TIME_NONE))\n+        {\n+            m_SeekLock->Exit();\n+            CheckQueueSize(NULL);\n+            return ERROR_NONE;\n+        }\n@@ -1512,0 +1560,4 @@\n+        case GST_MESSAGE_LATENCY:\n+            gst_bin_recalculate_latency (GST_BIN(pPipeline->m_Elements[PIPELINE]));\n+            break;\n+\n@@ -1909,2 +1961,4 @@\n-    if (!gst_structure_get_int(pStructure, \"track_id\", &trackID)) {\n-        trackID = 0; \/\/ default audio track ID if none present (can only be one in that case)\n+    if (pPipeline->m_pOptions->ForceDefaultTrackID() ||\n+            !gst_structure_get_int(pStructure, \"track_id\", &trackID)) {\n+        \/\/ Use default ID in case container doesn't have track IDs\n+        trackID = DEFAULT_AUDIO_TRACK_ID;\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstAudioPlaybackPipeline.cpp","additions":77,"deletions":23,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,3 @@\n+    AUDIO_SOURCE,\n+    SOURCE_BUFFER,\n+    AUDIO_SOURCE_BUFFER,\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstElementContainer.h","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,2 @@\n+#define HLS_PROP_HAS_AUDIO_EXT_STREAM 6\n+\n@@ -88,1 +90,0 @@\n-        CLocator *locator;\n@@ -90,1 +91,2 @@\n-        if (NULL == callbacks)\n+        jobject jConnectionHolder = CLocator::CreateConnectionHolder(env, jLocator);\n+        if (NULL == callbacks || NULL == jConnectionHolder)\n@@ -93,1 +95,1 @@\n-        if (!callbacks->Init(env, jLocator))\n+        if (!callbacks->Init(env, jConnectionHolder))\n@@ -101,1 +103,1 @@\n-        locator = new(nothrow) CLocatorStream(callbacks, pjContent, pjLocation, (int64_t)jSizeHint);\n+        CLocatorStream *locator = new(nothrow) CLocatorStream(callbacks, pjContent, pjLocation, (int64_t)jSizeHint);\n@@ -106,0 +108,2 @@\n+        {\n+            delete callbacks;\n@@ -107,0 +111,28 @@\n+        }\n+\n+        \/\/ Load any additional streams if needed.\n+        \/\/ HLS_PROP_HAS_AUDIO_EXT_STREAM\n+        int hasAudioStream = callbacks->Property(HLS_PROP_HAS_AUDIO_EXT_STREAM, 0);\n+        if (hasAudioStream)\n+        {\n+            CJavaInputStreamCallbacks *audioStreamCallbacks =\n+                    new (nothrow) CJavaInputStreamCallbacks();\n+            jobject jAudioStreamConnectionHolder =\n+                    CLocator::GetAudioStreamConnectionHolder(env, jLocator, jConnectionHolder);\n+            if (NULL == audioStreamCallbacks || NULL == jAudioStreamConnectionHolder)\n+            {\n+                delete callbacks;\n+                delete locator;\n+                return ERROR_MEMORY_ALLOCATION;\n+            }\n+\n+            if (!audioStreamCallbacks->Init(env, jAudioStreamConnectionHolder))\n+            {\n+                delete callbacks;\n+                delete audioStreamCallbacks;\n+                delete locator;\n+                return ERROR_MEDIA_CREATION;\n+            }\n+\n+            locator->SetAudioCallbacks(audioStreamCallbacks);\n+        }\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstMedia.cpp","additions":37,"deletions":5,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,9 +58,0 @@\n-    m_ContentTypes.push_back(CONTENT_TYPE_AIFF);\n-    m_ContentTypes.push_back(CONTENT_TYPE_MP3);\n-    m_ContentTypes.push_back(CONTENT_TYPE_MPA);\n-    m_ContentTypes.push_back(CONTENT_TYPE_WAV);\n-    m_ContentTypes.push_back(CONTENT_TYPE_MP4);\n-    m_ContentTypes.push_back(CONTENT_TYPE_M4A);\n-    m_ContentTypes.push_back(CONTENT_TYPE_M4V);\n-    m_ContentTypes.push_back(CONTENT_TYPE_M3U8);\n-    m_ContentTypes.push_back(CONTENT_TYPE_M3U);\n@@ -75,10 +66,0 @@\n-bool CGstPipelineFactory::CanPlayContentType(string contentType)\n-{\n-    return find(m_ContentTypes.begin(), m_ContentTypes.end(), contentType) != m_ContentTypes.end();\n-}\n-\n-const ContentTypesList& CGstPipelineFactory::GetSupportedContentTypes()\n-{\n-    return m_ContentTypes;\n-}\n-\n@@ -89,1 +70,22 @@\n-    if (NULL == locator)\n+    uint32_t uRetCode = ERROR_NONE;\n+\n+    GstElementContainer Elements;\n+\n+    \/\/ *ppPipeline should be set to NULL\n+    if (NULL == locator || NULL == pOptions || NULL != *ppPipeline)\n+        return ERROR_FUNCTION_PARAM_NULL;\n+\n+    if (locator->GetType() != CLocator::kStreamLocatorType)\n+        return ERROR_LOCATOR_UNSUPPORTED_TYPE;\n+\n+    if (locator->GetContentType().empty())\n+        return ERROR_LOCATOR_CONTENT_TYPE_NULL;\n+\n+    \/\/ Save content type to options\n+    pOptions->SetContentType(locator->GetContentType());\n+\n+    CLocatorStream* streamLocator = (CLocatorStream*)locator;\n+    CStreamCallbacks *callbacks = streamLocator->GetCallbacks();\n+    CStreamCallbacks *audioCallbacks = streamLocator->GetAudioCallbacks();\n+\n+    if (NULL == callbacks)\n@@ -92,2 +94,10 @@\n-    GstElement* pSource;\n-    uint32_t    uRetCode = CreateSourceElement(locator, &pSource, pOptions);\n+    int hlsMode = callbacks->Property(HLS_PROP_GET_HLS_MODE, 0);\n+    pOptions->SetHLSModeEnabled(hlsMode == 1);\n+    int streamMimeType = callbacks->Property(HLS_PROP_GET_MIMETYPE, 0);\n+    pOptions->SetStreamMimeType(streamMimeType);\n+\n+    \/\/ Create main source.\n+    GstElement* pSource = NULL;\n+    GstElement* pBuffer = NULL;\n+    uRetCode = CreateSourceElement(locator, callbacks,\n+            streamMimeType, &pSource, &pBuffer, pOptions);\n@@ -97,2 +107,24 @@\n-    if (locator->GetContentType().empty())\n-        return ERROR_LOCATOR_CONTENT_TYPE_NULL;\n+    \/\/ Store source element, so it can be used to build rest of pipeline\n+    Elements.add(SOURCE, pSource);\n+    Elements.add(SOURCE_BUFFER, pBuffer);\n+\n+    \/\/ Check to see if we have separate audio stream\n+    if (audioCallbacks != NULL)\n+    {\n+        int streamMimeType = audioCallbacks->Property(HLS_PROP_GET_MIMETYPE, 0);\n+        pOptions->SetAudioStreamMimeType(streamMimeType);\n+\n+        GstElement* pAudioSource = NULL;\n+        GstElement* pAudioBuffer = NULL;\n+        uRetCode = CreateSourceElement(locator, audioCallbacks,\n+                streamMimeType, &pAudioSource, &pAudioBuffer, pOptions);\n+        if (ERROR_NONE != uRetCode)\n+            return uRetCode;\n+\n+        \/\/ Store source element, so it can be used to build audio portion of pipeline\n+        Elements.add(AUDIO_SOURCE, pAudioSource);\n+        Elements.add(AUDIO_SOURCE_BUFFER, pAudioBuffer);\n+\n+        \/\/ Mark pipeline as multi source\n+        pOptions->SetPipelineType(CPipelineOptions::kAudioSourcePipeline);\n+    }\n@@ -100,2 +132,6 @@\n-    \/\/***** Initialize the return pipeline\n-    *ppPipeline = NULL;\n+    uRetCode = CreatePipeline(pOptions, &Elements, ppPipeline);\n+    if (ERROR_NONE != uRetCode)\n+        return uRetCode;\n+\n+    if (NULL == *ppPipeline)\n+        return ERROR_PIPELINE_CREATION;\n@@ -103,3 +139,19 @@\n-    if (CONTENT_TYPE_MP4 == locator->GetContentType() ||\n-        CONTENT_TYPE_M4A == locator->GetContentType() ||\n-        CONTENT_TYPE_M4V == locator->GetContentType())\n+    LOWLEVELPERF_EXECTIMESTOP(\"CGstPipelineFactory::CreatePlayerPipeline()\");\n+\n+    return uRetCode;\n+}\n+\n+\/\/ Creates pipeline based on options provided.\n+\/\/ Basically calls Create*Pipeline() based on options.\n+uint32_t CGstPipelineFactory::CreatePipeline(CPipelineOptions *pOptions, GstElementContainer* pElements, CPipeline** ppPipeline)\n+{\n+    LOWLEVELPERF_EXECTIMESTART(\"CGstPipelineFactory::CreatePipeline()\");\n+\n+    uint32_t uRetCode = ERROR_NONE;\n+\n+    if (NULL == pOptions)\n+        return ERROR_FUNCTION_PARAM_NULL;\n+\n+    if (CONTENT_TYPE_MP4 == pOptions->GetContentType() ||\n+        CONTENT_TYPE_M4A == pOptions->GetContentType() ||\n+        CONTENT_TYPE_M4V == pOptions->GetContentType())\n@@ -114,3 +166,3 @@\n-        if (CONTENT_TYPE_MP4 == locator->GetContentType() ||\n-                   CONTENT_TYPE_M4A == locator->GetContentType() ||\n-                   CONTENT_TYPE_M4V == locator->GetContentType())\n+        if (CONTENT_TYPE_MP4 == pOptions->GetContentType() ||\n+            CONTENT_TYPE_M4A == pOptions->GetContentType() ||\n+            CONTENT_TYPE_M4V == pOptions->GetContentType())\n@@ -118,1 +170,1 @@\n-            uRetCode = CreateMP4Pipeline(pSource, pVideoSink, (CPipelineOptions*) pOptions, ppPipeline);\n+            uRetCode = CreateMP4Pipeline(pVideoSink, pOptions, pElements, ppPipeline);\n@@ -123,2 +175,2 @@\n-    else if (CONTENT_TYPE_MPA == locator->GetContentType() ||\n-             CONTENT_TYPE_MP3 == locator->GetContentType())\n+    else if (CONTENT_TYPE_MPA == pOptions->GetContentType() ||\n+             CONTENT_TYPE_MP3 == pOptions->GetContentType())\n@@ -126,1 +178,1 @@\n-        uRetCode = CreateMp3AudioPipeline(pSource, pOptions, ppPipeline);\n+        uRetCode = CreateMp3AudioPipeline(pOptions, pElements, ppPipeline);\n@@ -130,1 +182,1 @@\n-    else if (CONTENT_TYPE_WAV == locator->GetContentType())\n+    else if (CONTENT_TYPE_WAV == pOptions->GetContentType())\n@@ -132,1 +184,1 @@\n-        uRetCode = CreateWavPcmAudioPipeline(pSource, pOptions, ppPipeline);\n+        uRetCode = CreateWavPcmAudioPipeline(pOptions, pElements, ppPipeline);\n@@ -136,1 +188,1 @@\n-    else if (CONTENT_TYPE_AIFF == locator->GetContentType())\n+    else if (CONTENT_TYPE_AIFF == pOptions->GetContentType())\n@@ -138,1 +190,1 @@\n-        uRetCode = CreateAiffPcmAudioPipeline(pSource, pOptions, ppPipeline);\n+        uRetCode = CreateAiffPcmAudioPipeline(pOptions, pElements, ppPipeline);\n@@ -142,2 +194,2 @@\n-    else if (CONTENT_TYPE_M3U8 == locator->GetContentType() ||\n-             CONTENT_TYPE_M3U == locator->GetContentType())\n+    else if (CONTENT_TYPE_M3U8 == pOptions->GetContentType() ||\n+             CONTENT_TYPE_M3U == pOptions->GetContentType())\n@@ -152,1 +204,1 @@\n-        uRetCode = CreateHLSPipeline(pSource, pVideoSink, pOptions, ppPipeline);\n+        uRetCode = CreateHLSPipeline(pVideoSink, pOptions, pElements, ppPipeline);\n@@ -164,1 +216,1 @@\n-    LOWLEVELPERF_EXECTIMESTOP(\"CGstPipelineFactory::CreatePlayerPipeline()\");\n+    LOWLEVELPERF_EXECTIMESTOP(\"CGstPipelineFactory::CreatePipeline()\");\n@@ -170,1 +222,1 @@\n-  * GstElement* CreateSourceElement(char* uri)\n+  * GstElement* CreateSourceElement()\n@@ -173,0 +225,1 @@\n+  * @param   callbacks Callbacks to read\/control media stream.\n@@ -176,1 +229,3 @@\n-uint32_t CGstPipelineFactory::CreateSourceElement(CLocator* locator, GstElement** ppElement, CPipelineOptions *pOptions)\n+uint32_t CGstPipelineFactory::CreateSourceElement(CLocator *locator, CStreamCallbacks *callbacks,\n+                                                  int streamMimeType, GstElement **ppElement,\n+                                                   GstElement **ppBuffer, CPipelineOptions *pOptions)\n@@ -179,0 +234,1 @@\n+    GstElement *buffer = NULL;\n@@ -180,7 +236,2 @@\n-#if ! ENABLE_NATIVE_SOURCE\n-    switch (locator->GetType())\n-    {\n-        case CLocator::kStreamLocatorType:\n-        {\n-            CLocatorStream* streamLocator = (CLocatorStream*)locator;\n-            CStreamCallbacks *callbacks = streamLocator->GetCallbacks();\n+   if (NULL == locator || NULL == callbacks)\n+        return ERROR_FUNCTION_PARAM_NULL;\n@@ -188,9 +239,3 @@\n-#if TARGET_OS_MAC\n-            if ((CONTENT_TYPE_M3U8 == locator->GetContentType() || CONTENT_TYPE_M3U == locator->GetContentType()) && callbacks->Property(HLS_PROP_GET_MIMETYPE, 0) != HLS_VALUE_MIMETYPE_MP3)\n-            {\n-                callbacks->CloseConnection();\n-                delete callbacks;\n-                delete pOptions;\n-                return ERROR_PLATFORM_UNSUPPORTED;\n-            }\n-#endif \/\/ TARGET_OS_MAC\n+    GstElement *javaSource = CreateElement(\"javasource\");\n+    if (NULL == javaSource)\n+        return ERROR_GSTREAMER_ELEMENT_CREATE;\n@@ -198,3 +243,1 @@\n-            GstElement *javaSource = CreateElement (\"javasource\");\n-            if (NULL == javaSource)\n-                return ERROR_GSTREAMER_ELEMENT_CREATE;\n+    bool isRandomAccess = callbacks->IsRandomAccess();\n@@ -202,43 +245,5 @@\n-            bool isRandomAccess = callbacks->IsRandomAccess();\n-            int hlsMode = callbacks->Property(HLS_PROP_GET_HLS_MODE, 0);\n-            int streamMimeType = callbacks->Property(HLS_PROP_GET_MIMETYPE, 0);\n-            pOptions->SetHLSModeEnabled(hlsMode == 1);\n-            pOptions->SetStreamMimeType(streamMimeType);\n-\n-            g_signal_connect (javaSource, \"read-next-block\", G_CALLBACK (SourceReadNextBlock), callbacks);\n-            g_signal_connect (javaSource, \"copy-block\", G_CALLBACK (SourceCopyBlock), callbacks);\n-            g_signal_connect (javaSource, \"seek-data\", G_CALLBACK (SourceSeekData), callbacks);\n-            g_signal_connect (javaSource, \"close-connection\", G_CALLBACK (SourceCloseConnection), callbacks);\n-            g_signal_connect (javaSource, \"property\", G_CALLBACK (SourceProperty), callbacks);\n-\n-            if (isRandomAccess)\n-                g_signal_connect (javaSource, \"read-block\", G_CALLBACK (SourceReadBlock), callbacks);\n-\n-            if (hlsMode == 1)\n-                g_object_set (javaSource, \"hls-mode\", TRUE, NULL);\n-\n-            if (streamMimeType == HLS_VALUE_MIMETYPE_MP2T)\n-                g_object_set (javaSource, \"mimetype\", CONTENT_TYPE_MP2T, NULL);\n-            else if (streamMimeType == HLS_VALUE_MIMETYPE_MP3)\n-                g_object_set (javaSource, \"mimetype\", CONTENT_TYPE_MPA, NULL);\n-            else if (streamMimeType == HLS_VALUE_MIMETYPE_FMP4)\n-                g_object_set (javaSource, \"mimetype\", CONTENT_TYPE_FMP4, NULL);\n-            else if (streamMimeType == HLS_VALUE_MIMETYPE_AAC)\n-                g_object_set (javaSource, \"mimetype\", CONTENT_TYPE_AAC, NULL);\n-\n-            g_object_set (javaSource,\n-                \"size\", (gint64)locator->GetSizeHint(),\n-                \"is-seekable\", (gboolean)callbacks->IsSeekable(),\n-                \"is-random-access\", (gboolean)isRandomAccess,\n-                \"location\", locator->GetLocation().c_str(),\n-                NULL);\n-\n-            bool needBuffer = callbacks->NeedBuffer();\n-            pOptions->SetBufferingEnabled(needBuffer);\n-\n-            if (needBuffer)\n-            {\n-                g_object_set (javaSource, \"stop-on-pause\", FALSE, NULL);\n-                source = gst_bin_new(NULL);\n-                if (NULL == source)\n-                    return ERROR_GSTREAMER_BIN_CREATE;\n+    g_signal_connect(javaSource, \"read-next-block\", G_CALLBACK(SourceReadNextBlock), callbacks);\n+    g_signal_connect(javaSource, \"copy-block\", G_CALLBACK(SourceCopyBlock), callbacks);\n+    g_signal_connect(javaSource, \"seek-data\", G_CALLBACK(SourceSeekData), callbacks);\n+    g_signal_connect(javaSource, \"close-connection\", G_CALLBACK(SourceCloseConnection), callbacks);\n+    g_signal_connect(javaSource, \"property\", G_CALLBACK(SourceProperty), callbacks);\n@@ -246,5 +251,2 @@\n-                GstElement *buffer = NULL;\n-                if (hlsMode == 1)\n-                    buffer = CreateElement (\"hlsprogressbuffer\");\n-                else\n-                    buffer = CreateElement (\"progressbuffer\");\n+    if (isRandomAccess)\n+        g_signal_connect(javaSource, \"read-block\", G_CALLBACK(SourceReadBlock), callbacks);\n@@ -252,2 +254,2 @@\n-                if (NULL == buffer)\n-                    return ERROR_GSTREAMER_ELEMENT_CREATE;\n+    if (pOptions->GetHLSModeEnabled())\n+        g_object_set(javaSource, \"hls-mode\", TRUE, NULL);\n@@ -255,1 +257,8 @@\n-                gst_bin_add_many(GST_BIN(source), javaSource, buffer, NULL);\n+    if (streamMimeType == HLS_VALUE_MIMETYPE_MP2T)\n+        g_object_set(javaSource, \"mimetype\", CONTENT_TYPE_MP2T, NULL);\n+    else if (streamMimeType == HLS_VALUE_MIMETYPE_MP3)\n+        g_object_set(javaSource, \"mimetype\", CONTENT_TYPE_MPA, NULL);\n+    else if (streamMimeType == HLS_VALUE_MIMETYPE_FMP4)\n+        g_object_set(javaSource, \"mimetype\", CONTENT_TYPE_FMP4, NULL);\n+    else if (streamMimeType == HLS_VALUE_MIMETYPE_AAC)\n+        g_object_set(javaSource, \"mimetype\", CONTENT_TYPE_AAC, NULL);\n@@ -257,7 +266,6 @@\n-                if (!gst_element_link(javaSource, buffer))\n-                    return ERROR_GSTREAMER_ELEMENT_LINK;\n-            }\n-            else\n-                source = javaSource;\n-        }\n-        break;\n+    g_object_set(javaSource,\n+                 \"size\", (gint64)locator->GetSizeHint(),\n+                 \"is-seekable\", (gboolean)callbacks->IsSeekable(),\n+                 \"is-random-access\", (gboolean)isRandomAccess,\n+                 \"location\", locator->GetLocation().c_str(),\n+                 NULL);\n@@ -265,7 +273,4 @@\n-        default:\n-            return ERROR_LOCATOR_UNSUPPORTED_TYPE;\n-        break;\n-    }\n-#else \/\/ ENABLE_NATIVE_SOURCE\n-    const gchar* location = locator->GetLocation().c_str();\n-    if(g_str_has_prefix(location, \"file\"))\n+    bool needBuffer = callbacks->NeedBuffer();\n+    pOptions->SetBufferingEnabled(needBuffer);\n+\n+    if (needBuffer)\n@@ -273,6 +278,2 @@\n-        source = CreateElement(\"filesrc\");\n-        if (NULL == source)\n-            return ERROR_GSTREAMER_ELEMENT_CREATE;\n-        g_object_set (source, \"location\", location + 7, NULL);\n-    } else { \/\/ assume HTTP\n-        source = CreateElement(\"souphttpsrc\");\n+        g_object_set(javaSource, \"stop-on-pause\", FALSE, NULL);\n+        source = gst_bin_new(NULL);\n@@ -280,0 +281,8 @@\n+            return ERROR_GSTREAMER_BIN_CREATE;\n+\n+        if (pOptions->GetHLSModeEnabled())\n+            buffer = CreateElement(\"hlsprogressbuffer\");\n+        else\n+            buffer = CreateElement(\"progressbuffer\");\n+\n+        if (NULL == buffer)\n@@ -281,1 +290,9 @@\n-        g_object_set (source, \"location\", location, NULL);\n+\n+        gst_bin_add_many(GST_BIN(source), javaSource, buffer, NULL);\n+\n+        if (!gst_element_link(javaSource, buffer))\n+            return ERROR_GSTREAMER_ELEMENT_LINK;\n+    }\n+    else\n+    {\n+        source = javaSource;\n@@ -283,1 +300,0 @@\n-#endif \/\/ ENABLE_NATIVE_SOURCE\n@@ -286,0 +302,1 @@\n+    *ppBuffer = buffer;\n@@ -400,1 +417,1 @@\n-uint32_t CGstPipelineFactory::AttachToSource(GstBin* bin, GstElement* source, GstElement* element)\n+uint32_t CGstPipelineFactory::AttachToSource(GstBin* bin, GstElement* source, GstElement* buffer, GstElement* element)\n@@ -403,2 +420,2 @@\n-    GstElement* buffer = GetByFactoryName(source, \"progressbuffer\");\n-    if (buffer)\n+    GstElement* progressbuffer = GetByFactoryName(source, \"progressbuffer\");\n+    if (progressbuffer)\n@@ -413,1 +430,1 @@\n-        g_signal_connect (buffer, \"pad-added\", G_CALLBACK (OnBufferPadAdded), dataBreaker);\n+        g_signal_connect (progressbuffer, \"pad-added\", G_CALLBACK (OnBufferPadAdded), dataBreaker);\n@@ -415,1 +432,1 @@\n-        g_signal_connect (buffer, \"pad-added\", G_CALLBACK (OnBufferPadAdded), element);\n+        g_signal_connect (progressbuffer, \"pad-added\", G_CALLBACK (OnBufferPadAdded), element);\n@@ -417,1 +434,1 @@\n-        gst_object_unref(buffer);\n+        gst_object_unref(progressbuffer);\n@@ -433,1 +450,1 @@\n-    buffer = GetByFactoryName(source, \"hlsprogressbuffer\");\n+    GstElement* hlsprogressbuffer = NULL;\n@@ -436,1 +453,9 @@\n-        GstPad* src_pad = gst_element_get_static_pad(buffer, \"src\");\n+        gst_object_ref(buffer);\n+        hlsprogressbuffer = buffer;\n+    }\n+    else\n+        hlsprogressbuffer = GetByFactoryName(source, \"hlsprogressbuffer\");\n+\n+    if (hlsprogressbuffer)\n+    {\n+        GstPad* src_pad = gst_element_get_static_pad(hlsprogressbuffer, \"src\");\n@@ -440,1 +465,2 @@\n-        GstPad* ghost_pad = gst_ghost_pad_new(\"src\", src_pad);\n+        \/\/ Auto assign pad name, since we might have several of them\n+        GstPad* ghost_pad = gst_ghost_pad_new(NULL, src_pad);\n@@ -455,1 +481,1 @@\n-        gst_object_unref(buffer);\n+        gst_object_unref(hlsprogressbuffer);\n@@ -479,2 +505,2 @@\n-uint32_t CGstPipelineFactory::CreateMP4Pipeline(GstElement* source, GstElement* pVideoSink,\n-                                                CPipelineOptions* pOptions, CPipeline** ppPipeline)\n+uint32_t CGstPipelineFactory::CreateMP4Pipeline(GstElement* pVideoSink,\n+                                                CPipelineOptions* pOptions, GstElementContainer* pElements, CPipeline** ppPipeline)\n@@ -485,1 +511,2 @@\n-    return CreateAVPipeline(source, \"qtdemux\", \"dshowwrapper\", true, NULL, pVideoSink, pOptions, ppPipeline);\n+    pOptions->SetStreamParser(\"qtdemux\")->SetAudioDecoder(\"dshowwrapper\");\n+    return CreateAVPipeline(true, pVideoSink, pOptions, pElements, ppPipeline);\n@@ -487,1 +514,1 @@\n-    return CreateAVPipeline(source, \"qtdemux\", \"audioconverter\", true, \"avcdecoder\", pVideoSink, pOptions, ppPipeline);\n+    return ERROR_PLATFORM_UNSUPPORTED;\n@@ -489,6 +516,2 @@\n-#if ENABLE_GST_FFMPEG\n-    return CreateAVPipeline(source, \"qtdemux\", \"ffdec_aac\", true,\n-                            \"ffdec_h264\", pVideoSink, pOptions, ppPipeline);\n-#else \/\/ ENABLE_GST_FFMPEG\n-    return CreateAVPipeline(source, \"qtdemux\", \"avaudiodecoder\", false, \"avvideodecoder\", pVideoSink, pOptions, ppPipeline);\n-#endif \/\/ ENABLE_GST_FFMPEG\n+    pOptions->SetStreamParser(\"qtdemux\")->SetAudioDecoder(\"avaudiodecoder\")->SetVideoDecoder(\"avvideodecoder\");\n+    return CreateAVPipeline(false, pVideoSink, pOptions, pElements, ppPipeline);\n@@ -510,1 +533,1 @@\n-uint32_t CGstPipelineFactory::CreateMp3AudioPipeline(GstElement* source, CPipelineOptions *pOptions, CPipeline** ppPipeline)\n+uint32_t CGstPipelineFactory::CreateMp3AudioPipeline(CPipelineOptions *pOptions, GstElementContainer* pElements, CPipeline** ppPipeline)\n@@ -513,1 +536,1 @@\n-    return CreateAudioPipeline(source, \"mpegaudioparse\", \"dshowwrapper\", false, pOptions, ppPipeline);\n+    pOptions->SetStreamParser(\"mpegaudioparse\")->SetAudioDecoder(\"dshowwrapper\");\n@@ -515,1 +538,1 @@\n-    return CreateAudioPipeline(source, \"mpegaudioparse\", \"audioconverter\", true, pOptions, ppPipeline);\n+    return ERROR_PLATFORM_UNSUPPORTED;\n@@ -517,6 +540,1 @@\n-#if ENABLE_GST_FFMPEG\n-    return CreateAudioPipeline(source, \"mpegaudioparse\", \"ffdec_mp3\", true,\n-                               pOptions, ppPipeline);\n-#else \/\/ ENABLE_GST_FFMPEG\n-    return CreateAudioPipeline(source, \"mpegaudioparse\", \"avaudiodecoder\", false, pOptions, ppPipeline);\n-#endif \/\/ ENABLE_GST_FFMPEG\n+    pOptions->SetStreamParser(\"mpegaudioparse\")->SetAudioDecoder(\"avaudiodecoder\");\n@@ -526,0 +544,2 @@\n+\n+    return CreateAudioPipeline(false, pOptions, pElements, ppPipeline);\n@@ -528,1 +548,1 @@\n-uint32_t CGstPipelineFactory::CreateWavPcmAudioPipeline(GstElement* source, CPipelineOptions *pOptions, CPipeline** ppPipeline)\n+uint32_t CGstPipelineFactory::CreateWavPcmAudioPipeline(CPipelineOptions *pOptions, GstElementContainer* pElements, CPipeline** ppPipeline)\n@@ -530,1 +550,2 @@\n-    return CreateAudioPipeline(source, \"wavparse\", NULL, true, pOptions, ppPipeline);\n+    pOptions->SetStreamParser(\"wavparse\");\n+    return CreateAudioPipeline(true, pOptions, pElements, ppPipeline);\n@@ -533,1 +554,1 @@\n-uint32_t CGstPipelineFactory::CreateAiffPcmAudioPipeline(GstElement* source, CPipelineOptions *pOptions, CPipeline** ppPipeline)\n+uint32_t CGstPipelineFactory::CreateAiffPcmAudioPipeline(CPipelineOptions *pOptions, GstElementContainer* pElements, CPipeline** ppPipeline)\n@@ -535,1 +556,2 @@\n-    return CreateAudioPipeline(source, \"aiffparse\", NULL, true, pOptions, ppPipeline);\n+    pOptions->SetStreamParser(\"aiffparse\");\n+    return CreateAudioPipeline(true, pOptions, pElements, ppPipeline);\n@@ -538,1 +560,1 @@\n-uint32_t CGstPipelineFactory::CreateHLSPipeline(GstElement* source, GstElement* pVideoSink, CPipelineOptions* pOptions, CPipeline** ppPipeline)\n+uint32_t CGstPipelineFactory::CreateHLSPipeline(GstElement* pVideoSink, CPipelineOptions* pOptions, GstElementContainer* pElements, CPipeline** ppPipeline)\n@@ -541,9 +563,20 @@\n-    if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_MP2T)\n-        return CreateAVPipeline(source, \"dshowwrapper\", \"dshowwrapper\", true, \"dshowwrapper\", pVideoSink, pOptions, ppPipeline);\n-    else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_MP3)\n-        return CreateAudioPipeline(source, \"mpegaudioparse\", \"dshowwrapper\", false, pOptions, ppPipeline);\n-    else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_AAC)\n-        return CreateAudioPipeline(source, NULL, \"dshowwrapper\", false, pOptions, ppPipeline);\n-    else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_FMP4)\n-        \/\/ Video decoder is loaded dynamically\n-        return CreateAVPipeline(source, \"qtdemux\", \"dshowwrapper\", true, NULL, pVideoSink, pOptions, ppPipeline);\n+    if (pOptions->GetPipelineType() == CPipelineOptions::kAudioSourcePipeline)\n+    {\n+        \/\/ For HLS streams with EXT-X-MEDIA first stream (video) is MP2T or FMP4\n+        if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_MP2T)\n+            pOptions->SetStreamParser(\"dshowwrapper\")->SetVideoDecoder(\"dshowwrapper\");\n+        else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_FMP4)\n+            pOptions->SetStreamParser(\"qtdemux\"); \/\/ Video decoder loaded dynamically\n+        else\n+            return ERROR_PLATFORM_UNSUPPORTED;\n+\n+        \/\/ Audio stream can be FMP4 or AAC\n+        if (pOptions->GetAudioStreamMimeType() == HLS_VALUE_MIMETYPE_FMP4)\n+            pOptions->SetAudioStreamParser(\"qtdemux\")->SetAudioDecoder(\"dshowwrapper\");\n+        else if (pOptions->GetAudioStreamMimeType() == HLS_VALUE_MIMETYPE_AAC)\n+            pOptions->SetAudioDecoder(\"dshowwrapper\");\n+        else\n+            return ERROR_PLATFORM_UNSUPPORTED;\n+\n+        return CreateAVPipeline(true, pVideoSink, pOptions, pElements, ppPipeline);\n+    }\n@@ -551,1 +584,27 @@\n-        return ERROR_PLATFORM_UNSUPPORTED;\n+    {\n+        if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_MP2T)\n+        {\n+            pOptions->SetStreamParser(\"dshowwrapper\")->SetAudioDecoder(\"dshowwrapper\")->SetVideoDecoder(\"dshowwrapper\");\n+            return CreateAVPipeline(true, pVideoSink, pOptions, pElements, ppPipeline);\n+        }\n+        else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_MP3)\n+        {\n+            pOptions->SetStreamParser(\"mpegaudioparse\")->SetAudioDecoder(\"dshowwrapper\");\n+            return CreateAudioPipeline(false, pOptions, pElements, ppPipeline);\n+        }\n+        else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_AAC)\n+        {\n+            pOptions->SetAudioDecoder(\"dshowwrapper\");\n+            return CreateAudioPipeline(false, pOptions, pElements, ppPipeline);\n+        }\n+        else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_FMP4)\n+        {\n+            \/\/ Video decoder is loaded dynamically\n+            pOptions->SetStreamParser(\"qtdemux\")->SetAudioDecoder(\"dshowwrapper\");\n+            return CreateAVPipeline(true, pVideoSink, pOptions, pElements, ppPipeline);\n+        }\n+        else\n+        {\n+            return ERROR_PLATFORM_UNSUPPORTED;\n+        }\n+    }\n@@ -553,2 +612,0 @@\n-    if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_MP3)\n-        return CreateAudioPipeline(source, \"mpegaudioparse\", \"audioconverter\", true, pOptions, ppPipeline);\n@@ -557,8 +614,29 @@\n-    if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_MP2T)\n-        return CreateAVPipeline(source, \"avmpegtsdemuxer\", \"avaudiodecoder\", false, \"avvideodecoder\", pVideoSink, pOptions, ppPipeline);\n-    else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_MP3)\n-        return CreateAudioPipeline(source, \"mpegaudioparse\", \"avaudiodecoder\", false, pOptions, ppPipeline);\n-    else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_AAC)\n-        return CreateAudioPipeline(source, \"aacparse\", \"avaudiodecoder\", false, pOptions, ppPipeline);\n-    else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_FMP4)\n-        return CreateAVPipeline(source, \"qtdemux\", \"avaudiodecoder\", true, \"avvideodecoder\", pVideoSink, pOptions, ppPipeline);\n+    if (pOptions->GetPipelineType() == CPipelineOptions::kAudioSourcePipeline)\n+    {\n+        bool bConvertFormat = false;\n+\n+        \/\/ For HLS streams with EXT-X-MEDIA first stream (video) is MP2T or FMP4\n+        if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_MP2T)\n+            pOptions->SetStreamParser(\"avmpegtsdemuxer\")->SetVideoDecoder(\"avvideodecoder\");\n+        else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_FMP4)\n+            pOptions->SetStreamParser(\"qtdemux\")->SetVideoDecoder(\"avvideodecoder\");\n+        else\n+            return ERROR_PLATFORM_UNSUPPORTED;\n+\n+        \/\/ Audio stream can be FMP4 or AAC\n+        if (pOptions->GetAudioStreamMimeType() == HLS_VALUE_MIMETYPE_FMP4)\n+        {\n+            pOptions->SetAudioStreamParser(\"qtdemux\")->SetAudioDecoder(\"avaudiodecoder\");\n+            bConvertFormat = true;\n+        }\n+        else if (pOptions->GetAudioStreamMimeType() == HLS_VALUE_MIMETYPE_AAC)\n+        {\n+            pOptions->SetAudioStreamParser(\"aacparse\")->SetAudioDecoder(\"avaudiodecoder\");\n+            bConvertFormat = false;\n+            \/\/pOptions->SetAudioDecoder(\"avaudiodecoder\");\n+        }\n+        else\n+            return ERROR_PLATFORM_UNSUPPORTED;\n+\n+        return CreateAVPipeline(bConvertFormat, pVideoSink, pOptions, pElements, ppPipeline);\n+    }\n@@ -566,1 +644,26 @@\n-        return ERROR_PLATFORM_UNSUPPORTED;\n+    {\n+        if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_MP2T)\n+        {\n+            pOptions->SetStreamParser(\"avmpegtsdemuxer\")->SetAudioDecoder(\"avaudiodecoder\")->SetVideoDecoder(\"avvideodecoder\");\n+            return CreateAVPipeline(false, pVideoSink, pOptions, pElements, ppPipeline);\n+        }\n+        else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_MP3)\n+        {\n+            pOptions->SetStreamParser(\"mpegaudioparse\")->SetAudioDecoder(\"avaudiodecoder\");\n+            return CreateAudioPipeline(false, pOptions, pElements, ppPipeline);\n+        }\n+        else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_AAC)\n+        {\n+            pOptions->SetStreamParser(\"aacparse\")->SetAudioDecoder(\"avaudiodecoder\");\n+            return CreateAudioPipeline(false, pOptions, pElements, ppPipeline);\n+        }\n+        else if (pOptions->GetStreamMimeType() == HLS_VALUE_MIMETYPE_FMP4)\n+        {\n+            pOptions->SetStreamParser(\"qtdemux\")->SetAudioDecoder(\"avaudiodecoder\")->SetVideoDecoder(\"avvideodecoder\");\n+            return CreateAVPipeline(true, pVideoSink, pOptions, pElements, ppPipeline);\n+        }\n+        else\n+        {\n+            return ERROR_PLATFORM_UNSUPPORTED;\n+        }\n+    }\n@@ -572,2 +675,1 @@\n-uint32_t CGstPipelineFactory::CreateAudioPipeline(GstElement* source, const char* strParserName, const char* strDecoderName,\n-                                                  bool bConvertFormat, CPipelineOptions *pOptions, CPipeline** ppPipeline)\n+uint32_t CGstPipelineFactory::CreateAudioPipeline(bool bConvertFormat, CPipelineOptions *pOptions, GstElementContainer* pElements, CPipeline** ppPipeline)\n@@ -577,0 +679,5 @@\n+    \/\/ All audio pipelines are single source for now\n+    GstElement* source = (*pElements)[SOURCE];\n+    if (NULL == source)\n+        return ERROR_FUNCTION_PARAM_NULL;\n+\n@@ -583,1 +690,0 @@\n-    GstElementContainer elements;\n@@ -586,1 +692,3 @@\n-    uRetCode = CreateAudioBin(strParserName, strDecoderName, bConvertFormat, &elements, &flags, &audiobin);\n+    uRetCode = CreateAudioBin(pOptions->GetStreamParser(),\n+                              pOptions->GetAudioDecoder(),\n+                              bConvertFormat, pElements, &flags, &audiobin);\n@@ -590,1 +698,1 @@\n-    uRetCode = AttachToSource(GST_BIN (pipeline), source, audiobin);\n+    uRetCode = AttachToSource(GST_BIN (pipeline), source, NULL, audiobin);\n@@ -594,2 +702,1 @@\n-    elements.add(PIPELINE, pipeline).\n-    add(SOURCE, source);\n+    pElements->add(PIPELINE, pipeline);\n@@ -597,1 +704,1 @@\n-    *ppPipeline = new CGstAudioPlaybackPipeline(elements, flags, pOptions);\n+    *ppPipeline = new CGstAudioPlaybackPipeline(*pElements, flags, pOptions);\n@@ -620,3 +727,3 @@\n-uint32_t CGstPipelineFactory::CreateAVPipeline(GstElement* source, const char* strDemultiplexerName,\n-                                               const char* strAudioDecoderName, bool bConvertFormat, const char* strVideoDecoderName,\n-                                               GstElement* pVideoSink, CPipelineOptions* pOptions, CPipeline** ppPipeline)\n+uint32_t CGstPipelineFactory::CreateAVPipeline(bool bConvertFormat, GstElement* pVideoSink,\n+                                               CPipelineOptions* pOptions, GstElementContainer* pElements,\n+                                               CPipeline** ppPipeline)\n@@ -625,0 +732,1 @@\n+    bool bAudioStream = (pOptions->GetPipelineType() == CPipelineOptions::kAudioSourcePipeline);\n@@ -626,2 +734,10 @@\n-    \/\/ Pipeline and demuxer\n-    GstElement *pipeline = gst_pipeline_new (NULL);\n+    GstElement* source = (*pElements)[SOURCE];\n+    if (NULL == source)\n+        return ERROR_FUNCTION_PARAM_NULL;\n+\n+    GstElement* audioSource = (*pElements)[AUDIO_SOURCE];\n+    if (bAudioStream && NULL == audioSource)\n+        return ERROR_FUNCTION_PARAM_NULL;\n+\n+    \/\/ Create pipeline\n+    GstElement *pipeline = gst_pipeline_new(NULL);\n@@ -630,1 +746,3 @@\n-    GstElement *demuxer  = CreateElement (strDemultiplexerName);\n+\n+    \/\/ Add demuxer and attached it to source for video and audio stream or video only\n+    GstElement *demuxer = CreateElement(pOptions->GetStreamParser());\n@@ -633,0 +751,4 @@\n+    \/\/ Configure demuxer if needed\n+    if (bAudioStream) {\n+        g_object_set(demuxer, \"disable-mp2t-pts-reset\", TRUE, NULL);\n+    }\n@@ -635,2 +757,1 @@\n-\n-    uRetCode= AttachToSource(GST_BIN (pipeline), source, demuxer);\n+    uRetCode = AttachToSource(GST_BIN (pipeline), source, (*pElements)[SOURCE_BUFFER], demuxer);\n@@ -640,1 +761,18 @@\n-    GstElementContainer elements;\n+    GstElement *audioDemuxer = NULL;\n+    if (audioSource)\n+    {\n+        if (!gst_bin_add (GST_BIN (pipeline), audioSource))\n+            return ERROR_GSTREAMER_BIN_ADD_ELEMENT;\n+\n+        if (pOptions->GetAudioStreamParser() != NULL)\n+        {\n+            audioDemuxer = CreateElement(pOptions->GetAudioStreamParser());\n+            if (NULL == audioDemuxer)\n+                return ERROR_GSTREAMER_ELEMENT_CREATE;\n+\n+            uRetCode = AttachToSource(GST_BIN (pipeline), audioSource, (*pElements)[AUDIO_SOURCE_BUFFER], audioDemuxer);\n+            if (ERROR_NONE != uRetCode)\n+                return uRetCode;\n+        }\n+    }\n+\n@@ -642,3 +780,3 @@\n-    GstElement *audiobin;\n-    uRetCode = CreateAudioBin(NULL, strAudioDecoderName, bConvertFormat,\n-                              &elements, &audioFlags, &audiobin);\n+    GstElement *audiobin = NULL;\n+    uRetCode = CreateAudioBin(NULL, pOptions->GetAudioDecoder(), bConvertFormat,\n+                              pElements, &audioFlags, &audiobin);\n@@ -648,0 +786,23 @@\n+    \/\/ Attach audio bin to audio source if we have one\n+    if (bAudioStream && audioDemuxer == NULL)\n+    {\n+        uRetCode = AttachToSource(GST_BIN (pipeline), audioSource, (*pElements)[AUDIO_SOURCE_BUFFER], audiobin);\n+        if (ERROR_NONE != uRetCode)\n+            return uRetCode;\n+    }\n+    else if (bAudioStream && audioDemuxer != NULL)\n+    {\n+        \/\/ Audio demuxer can have static or dynamic src pad.\n+        \/\/ If static then connect it here. For dynamic we\n+        \/\/ will connect it in GstAVPlaybackPipeline.\n+        GstPad *src_pad = gst_element_get_static_pad(audioDemuxer, \"src\");\n+        if (src_pad != NULL)\n+        {\n+            gst_object_unref(src_pad);\n+            if (!gst_bin_add(GST_BIN (pipeline), audiobin))\n+                return ERROR_GSTREAMER_BIN_ADD_ELEMENT;\n+            if (!gst_element_link(audioDemuxer, audiobin))\n+                return ERROR_GSTREAMER_ELEMENT_LINK;\n+        }\n+    }\n+\n@@ -649,1 +810,1 @@\n-    uRetCode = CreateVideoBin(strVideoDecoderName, pVideoSink, &elements, &videobin);\n+    uRetCode = CreateVideoBin(pOptions->GetVideoDecoder(), pVideoSink, pElements, &videobin);\n@@ -652,3 +813,0 @@\n-    elements.add(PIPELINE, pipeline).\n-    add(SOURCE, source).\n-    add(AV_DEMUXER, demuxer);\n@@ -656,7 +814,4 @@\n-    if (elements[VIDEO_DECODER] != NULL && NULL != g_object_class_find_property(G_OBJECT_GET_CLASS(G_OBJECT(elements[VIDEO_DECODER])), \"location\") &&\n-        elements[SOURCE] != NULL && NULL != g_object_class_find_property(G_OBJECT_GET_CLASS(G_OBJECT(elements[SOURCE])), \"location\"))\n-    {\n-        gchar* location = NULL;\n-        g_object_get(G_OBJECT(elements[SOURCE]), \"location\", &location, NULL);\n-        g_object_set(G_OBJECT(elements[VIDEO_DECODER]), \"location\", location, NULL);\n-    }\n+    pElements->add(PIPELINE, pipeline);\n+    pElements->add(AV_DEMUXER, demuxer);\n+    if (audioDemuxer != NULL)\n+        pElements->add(AUDIO_PARSER, audioDemuxer);\n@@ -664,1 +819,1 @@\n-    *ppPipeline = new CGstAVPlaybackPipeline(elements, audioFlags, pOptions);\n+    *ppPipeline = new CGstAVPlaybackPipeline(*pElements, audioFlags, pOptions);\n@@ -900,0 +1055,3 @@\n+    if (strFactoryName == NULL)\n+        return NULL;\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstPipelineFactory.cpp","additions":384,"deletions":226,"binary":false,"changes":610,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include <Locator\/LocatorStream.h>\n@@ -43,3 +44,0 @@\n-    virtual bool CanPlayContentType(string contentType);\n-    virtual const ContentTypesList& GetSupportedContentTypes();\n-\n@@ -59,5 +57,7 @@\n-    uint32_t    CreateMP4Pipeline(GstElement* source, GstElement* videosink, CPipelineOptions* pOptions, CPipeline** ppPipeline);\n-    uint32_t    CreateMp3AudioPipeline(GstElement* source, CPipelineOptions* pOptions, CPipeline** ppPipeline);\n-    uint32_t    CreateWavPcmAudioPipeline(GstElement* source, CPipelineOptions* pOptions, CPipeline **ppPipeline);\n-    uint32_t    CreateAiffPcmAudioPipeline(GstElement* source, CPipelineOptions* pOptions, CPipeline **ppPipeline);\n-    uint32_t    CreateHLSPipeline(GstElement* source, GstElement* pVideoSink, CPipelineOptions* pOptions, CPipeline** ppPipeline);\n+    uint32_t    CreatePipeline(CPipelineOptions* pOptions, GstElementContainer* pElements, CPipeline** ppPipeline);\n+\n+    uint32_t    CreateMP4Pipeline(GstElement* videosink, CPipelineOptions* pOptions, GstElementContainer* pElements, CPipeline** ppPipeline);\n+    uint32_t    CreateMp3AudioPipeline(CPipelineOptions* pOptions, GstElementContainer* pElements, CPipeline** ppPipeline);\n+    uint32_t    CreateWavPcmAudioPipeline(CPipelineOptions* pOptions, GstElementContainer* pElements, CPipeline **ppPipeline);\n+    uint32_t    CreateAiffPcmAudioPipeline(CPipelineOptions* pOptions, GstElementContainer* pElements, CPipeline **ppPipeline);\n+    uint32_t    CreateHLSPipeline(GstElement* pVideoSink, CPipelineOptions* pOptions, GstElementContainer* pElements, CPipeline** ppPipeline);\n@@ -65,1 +65,2 @@\n-    uint32_t    CreateSourceElement(CLocator* locator, GstElement** ppElement, CPipelineOptions *pOptions);\n+    uint32_t    CreateSourceElement(CLocator *locator, CStreamCallbacks *callbacks, int streamMimeType,\n+                                    GstElement** ppElement, GstElement** ppBuffer, CPipelineOptions *pOptions);\n@@ -67,1 +68,1 @@\n-    uint32_t    AttachToSource(GstBin* bin, GstElement* source, GstElement* demuxer);\n+    uint32_t    AttachToSource(GstBin* bin, GstElement* source, GstElement* buffer, GstElement* demuxer);\n@@ -69,6 +70,2 @@\n-    uint32_t    CreateAudioPipeline(GstElement* source,\n-                                    const char* strParserName, const char* strDecoderName, bool bConvertFormat,\n-                                    CPipelineOptions *pOptions, CPipeline** ppPipeline);\n-    uint32_t    CreateAVPipeline(GstElement* source, const char* strDemultiplexerName,\n-                                 const char* strAudioDecoderName, bool bConvertFormat, const char* strVideoDecoderName,\n-                                 GstElement* pVideoSink, CPipelineOptions* pOptions, CPipeline** ppPipeline);\n+    uint32_t    CreateAudioPipeline(bool bConvertFormat, CPipelineOptions *pOptions, GstElementContainer* pElements, CPipeline** ppPipeline);\n+    uint32_t    CreateAVPipeline(bool bConvertFormat, GstElement* pVideoSink, CPipelineOptions* pOptions, GstElementContainer* pElements, CPipeline** ppPipeline);\n@@ -94,3 +91,0 @@\n-\n-private:\n-    ContentTypesList m_ContentTypes;\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstPipelineFactory.h","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include <jni\/Logger.h>\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/gstreamer\/GstVideoFrame.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#import <jni\/Logger.h>\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/osx\/OSXPlatform.mm","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#import <jni\/Logger.h>\n","filename":"modules\/javafx.media\/src\/main\/native\/jfxmedia\/platform\/osx\/avf\/AVFMediaPlayer.mm","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}