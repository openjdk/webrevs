{"files":[{"patch":"@@ -53,0 +53,1 @@\n+    private static final String LIST_LISTENER_HELPER_GENERIC               = \"com.sun.javafx.collections.ListListenerHelper$Generic\";\n@@ -202,1 +203,1 @@\n-        final Object helper = getExpressionHelper(observable);\n+        Object helper = getExpressionHelper(observable);\n@@ -204,1 +205,4 @@\n-            return Collections.emptyList();\n+            helper = getListExpressionHelper(observable);\n+            if (helper == null) {\n+                return Collections.emptyList();\n+            }\n@@ -237,0 +241,17 @@\n+        try {\n+            final Class clazz = Class.forName(LIST_LISTENER_HELPER_GENERIC);\n+            if (clazz.isAssignableFrom(helperClass)) {\n+                try {\n+                    final Field field = clazz.getDeclaredField(\"changeListeners\");\n+                    field.setAccessible(true);\n+                    final ListChangeListener<? super E>[] listeners = (ListChangeListener[])field.get(helper);\n+                    if (listeners != null) {\n+                        final Field sizeField = clazz.getDeclaredField(\"changeSize\");\n+                        sizeField.setAccessible(true);\n+                        final int size = sizeField.getInt(helper);\n+                        return Arrays.asList(Arrays.copyOf(listeners, size));\n+                    }\n+                } catch (Exception ex) { }\n+            }\n+        } catch (ClassNotFoundException ex) { }\n+\n@@ -331,0 +352,13 @@\n+    private static Object getListExpressionHelper(Object bean) {\n+        Class clazz = bean.getClass();\n+        while (clazz != Object.class) {\n+            try {\n+                final Field field = clazz.getDeclaredField(\"listenerHelper\");\n+                field.setAccessible(true);\n+                return field.get(bean);\n+            } catch (Exception ex) {}\n+            clazz = clazz.getSuperclass();\n+        }\n+        return null;\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ExpressionHelperUtility.java","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -135,0 +135,4 @@\n+    \/* It's okay to have the value Weak, because we only remember it to remove the listener later on *\/\n+    private static Map<ListChangeListener<MenuItem>, WeakReference<ListChangeListener<MenuItem>>>\n+            menuListChangeListenerMap = new WeakHashMap<>();\n+\n@@ -139,6 +143,17 @@\n-        items.addListener((ListChangeListener<MenuItem>) c -> {\n-            while (c.next()) {\n-                if (c.wasRemoved()) {\n-                    \/\/ remove accelerators from the scene\n-                    removeAcceleratorsFromScene(c.getRemoved(), scene);\n-                }\n+        \/\/ We need to store the ListChangeListener for later so that we can clean up, so ideally we'd use the items\n+        \/\/ list as a key in a WeakHashMap with the ListChangeListener as the value. Unfortunately items can't be used\n+        \/\/ as a key as is because its equals method compares the list contents which breaks immediately for empty\n+        \/\/ lists.\n+        \/\/ Instead we have to use an identity wrapper over the items as a key, but since the HashMap is weak, we also\n+        \/\/ have to retain a reference to the identity wrapper class. This could be avoided if there was a\n+        \/\/ WeakIdentityHashMap class available.\n+        \/\/ One way is to use the ListChangeListener itself as the identity wrapper: IdentityWrapperListChangeListener\n+        \/\/ since the items list will have a reference to it. We can create temporary instances of the\n+        \/\/ IdentityWrapperListChangeListener when we need to retrieve items from the WeakHashMap to get the real one.\n+        ListChangeListener<MenuItem> listChangeListener = new IdentityWrapperListChangeListener(items) {\n+            @Override\n+            public void onChanged(Change<? extends MenuItem> c) {\n+                while (c.next()) {\n+                    if (c.wasRemoved()) {\n+                        removeAcceleratorsFromScene(c.getRemoved(), scene);\n+                    }\n@@ -146,2 +161,3 @@\n-                if (c.wasAdded()) {\n-                    ControlAcceleratorSupport.doAcceleratorInstall(c.getAddedSubList(), scene);\n+                    if (c.wasAdded()) {\n+                        doAcceleratorInstall(c.getAddedSubList(), scene);\n+                    }\n@@ -150,1 +166,9 @@\n-        });\n+        };\n+\n+        \/\/ There should only ever be one ListChangeListener from ControlAcceleratorSupport on each items list\n+        \/\/ If there is one somehow, this removes it from the list, and replaces the entry in the HashMap.\n+        WeakReference<ListChangeListener<MenuItem>> previousW = menuListChangeListenerMap.get(listChangeListener);\n+        ListChangeListener<MenuItem> previous = previousW == null ? null : previousW.get();\n+        if (previous != null) {\n+            items.removeListener(previous);\n+        }\n@@ -152,0 +176,2 @@\n+        menuListChangeListenerMap.put(listChangeListener, new WeakReference<>(listChangeListener));\n+        items.addListener(listChangeListener);\n@@ -228,1 +254,1 @@\n-    public static void removeAcceleratorsFromScene(List<? extends MenuItem> items, Tab anchor) {\n+    public static void removeAcceleratorsFromScene(ObservableList<? extends MenuItem> items, Tab anchor) {\n@@ -236,1 +262,1 @@\n-    public static void removeAcceleratorsFromScene(List<? extends MenuItem> items, TableColumnBase<?,?> anchor) {\n+    public static void removeAcceleratorsFromScene(ObservableList<? extends MenuItem> items, TableColumnBase<?,?> anchor) {\n@@ -247,1 +273,1 @@\n-    public static void removeAcceleratorsFromScene(List<? extends MenuItem> items, Node anchor) {\n+    public static void removeAcceleratorsFromScene(ObservableList<? extends MenuItem> items, Node anchor) {\n@@ -264,1 +290,14 @@\n-    public static void removeAcceleratorsFromScene(List<? extends MenuItem> items, Scene scene) {\n+    public static void removeAcceleratorsFromScene(ObservableList<? extends MenuItem> items, Scene scene) {\n+        \/\/ use a temporary IdentityWrapperListChangeListener to get the actual one that's listening to items\n+        WeakReference<ListChangeListener<MenuItem>> listenerW =\n+                menuListChangeListenerMap.get(new IdentityWrapperListChangeListener(items));\n+        if (listenerW != null) {\n+            ListChangeListener<MenuItem> listChangeListener = listenerW.get();\n+            if (listChangeListener != null) {\n+                items.removeListener(listChangeListener);\n+            }\n+        }\n+        removeAcceleratorsFromScene((List<MenuItem>)items, scene);\n+    }\n+\n+    private static void removeAcceleratorsFromScene(List<? extends MenuItem> items, Scene scene) {\n@@ -314,0 +353,44 @@\n+\n+    \/**\n+     * We need to store all the listeners added to each ObservableList so that we can remove them. For this we need\n+     * a map mapping ObservableList to various listeners such as ListChangeListeners, but the map needs to be a\n+     * WeakHashMap.\n+     * The ideal key to the WeakHashMap would be the ObservableList itself, except for the fact that its equals method\n+     * compares the list contents. If a WeakIdentityHashMap existed, we could use that instead with the ObservableList\n+     * as the key.\n+     * We can't use an IdentityWrapper as the key to the HashMap because we need a strong reference (ideally from the\n+     * ObservableList itself) to the IdentityWrapper else it'll be garbage collected.\n+     * Since every ObservableList gets a ListChangeListener, we can use that as an IdentityWrapper and rely on the fact\n+     * ObservableList has a strong reference to the ListChangeListener.\n+     *\/\n+    static class IdentityWrapperListChangeListener implements ListChangeListener<MenuItem> {\n+\n+        ObservableList<? extends MenuItem> innerList;\n+\n+        public IdentityWrapperListChangeListener(ObservableList<? extends MenuItem> list) {\n+            this.innerList = list;\n+        }\n+\n+        @Override\n+        public void onChanged(Change<? extends MenuItem> c) {\n+            \/\/ In some cases this class is used as a key to fetch an item in a HashMap only, and then discarded\n+            \/\/ In other cases the onChanged method is overridden and this is used as a ListChangeListener\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return System.identityHashCode(innerList);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (!(o instanceof IdentityWrapperListChangeListener)) {\n+                return false;\n+            }\n+            IdentityWrapperListChangeListener that = (IdentityWrapperListChangeListener) o;\n+            return innerList == that.innerList;\n+        }\n+    };\n@@ -315,0 +398,2 @@\n+\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/ControlAcceleratorSupport.java","additions":98,"deletions":13,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -10,0 +10,2 @@\n+--add-opens javafx.base\/com.sun.javafx.collections=ALL-UNNAMED\n+--add-opens javafx.base\/javafx.collections=ALL-UNNAMED\n","filename":"modules\/javafx.controls\/src\/test\/addExports","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.tk.Toolkit;\n@@ -29,4 +30,3 @@\n-import javafx.scene.control.MenuBar;\n-import javafx.scene.control.Menu;\n-import javafx.scene.control.MenuButton;\n-import javafx.scene.control.MenuItem;\n+import javafx.collections.ListChangeListener;\n+import javafx.scene.Scene;\n+import javafx.scene.control.*;\n@@ -36,0 +36,1 @@\n+import org.junit.Ignore;\n@@ -42,0 +43,3 @@\n+\n+import java.lang.ref.WeakReference;\n+\n@@ -44,1 +48,1 @@\n-\n+import static org.junit.Assert.assertFalse;\n@@ -162,0 +166,280 @@\n+\n+    @Test\n+    public void testMenuButtonSceneChangeDoesntLeakScene() {\n+        \/\/ JDK-8283551\n+        \/\/ The scene was leaked in a ListChangeListener added by ControlAcceleratorSupport\n+        MenuItem menuItem = new MenuItem(\"Menu Item\");\n+        MenuButton menuButton = new MenuButton(\"Menu Button\", null, menuItem);\n+        StackPane root = new StackPane(menuButton);\n+        StackPane root2 = new StackPane();\n+        StageLoader sl1 = new StageLoader(root);\n+        StageLoader sl2 = new StageLoader(root2);\n+        WeakReference<Scene> scene1 = new WeakReference<>(sl1.getStage().getScene());\n+        root2.getChildren().add(menuButton);\n+        sl1.dispose();\n+        JMemoryBuddy.assertCollectable(scene1);\n+        sl2.dispose();\n+    }\n+\n+    @Test\n+    public void testMenuButtonSceneChangeDoesntAddExtraListChangeListeners() {\n+        \/\/ JDK-8283551\n+        MenuItem menuItem = new MenuItem(\"Menu Item\");\n+        Menu subMenu = new Menu(\"Sub Menu\", null);\n+        MenuButton menuButton = new MenuButton(\"Menu Button\", null, menuItem, subMenu);\n+\n+        StackPane root = new StackPane(menuButton);\n+        StackPane root2 = new StackPane();\n+        StageLoader sl1 = new StageLoader(root);\n+        StageLoader sl2 = new StageLoader(root2);\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(menuButton.getItems()).size());\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(subMenu.getItems()).size());\n+\n+        ListChangeListener originalMenuButtonListChangeListener =\n+                ExpressionHelperUtility.getListChangeListeners(menuButton.getItems()).get(1);\n+        ListChangeListener originalSubMenuListChangeListener =\n+                ExpressionHelperUtility.getListChangeListeners(subMenu.getItems()).get(1);\n+\n+        \/\/ move the menu to another scene and check that the listeners got removed and recreated\n+        root2.getChildren().add(menuButton);\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(menuButton.getItems()).size());\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(subMenu.getItems()).size());\n+\n+        ListChangeListener newMenuButtonListChangeListener =\n+                ExpressionHelperUtility.getListChangeListeners(menuButton.getItems()).get(1);\n+        ListChangeListener newSubMenuListChangeListener =\n+                ExpressionHelperUtility.getListChangeListeners(subMenu.getItems()).get(1);\n+\n+        \/\/ use == instead of .equals because the list change listeners override equals to compare the observable list\n+        assertFalse(originalMenuButtonListChangeListener == newMenuButtonListChangeListener);\n+        assertFalse(originalSubMenuListChangeListener == newSubMenuListChangeListener);\n+\n+        \/\/ Change to weak references and check that there are no remaining references\n+        WeakReference<ListChangeListener> wOriginalMenuButtonListChangeListener =\n+                new WeakReference<>(originalMenuButtonListChangeListener);\n+        WeakReference<ListChangeListener> wOriginalSubMenuListChangeListener =\n+                new WeakReference<>(originalSubMenuListChangeListener);\n+        originalMenuButtonListChangeListener = null;\n+        originalSubMenuListChangeListener = null;\n+        JMemoryBuddy.assertCollectable(wOriginalMenuButtonListChangeListener);\n+        JMemoryBuddy.assertCollectable(wOriginalSubMenuListChangeListener);\n+\n+        sl1.dispose();\n+        sl2.dispose();\n+    }\n+\n+    private void setActionMenuItem(Tab tab, MenuItem menuItem) {\n+        menuItem.setOnAction(e -> tab.setText(\"Tab Renamed\"));\n+    }\n+\n+    @Ignore(\"JDK-8283449\")\n+    @Test\n+    public void testTabWithContextMenuReferencingTabDoesntCauseMemoryLeak() {\n+        \/\/ JDK-8283449 Tab with context menu that references tab gets leaked\n+        Tab tab = new Tab(\"Tab\");\n+        TabPane tabPane = new TabPane(tab);\n+\n+        MenuItem menuItemWithReferenceToTab = new MenuItem(\"RenameTabMenuItem\");\n+        \/\/ method call so that we can set tab to null later without dealing with\n+        \/\/ \"variable used in lambda expression should be final or effectively final\"\n+        setActionMenuItem(tab, menuItemWithReferenceToTab);\n+        ContextMenu contextMenu = new ContextMenu(menuItemWithReferenceToTab);\n+        tab.setContextMenu(contextMenu);\n+\n+        StackPane root = new StackPane(tabPane);\n+        StageLoader sl = new StageLoader(root);\n+\n+        WeakReference<Tab> wTab = new WeakReference<>(tab);\n+        tab = null;\n+        menuItemWithReferenceToTab = null; \/\/ also holds a reference to tab through its action\n+        contextMenu = null;\n+        JMemoryBuddy.assertNotCollectable(wTab);\n+        tabPane.getTabs().remove(0);\n+        tabPane.getTabs().add(new Tab());\n+        \/\/ the TabPane still holds onto the tab through a reference in stackpane\n+        \/\/ adding a new tab and running a pulse gets rid of it\n+        Toolkit.getToolkit().firePulse();\n+        JMemoryBuddy.assertCollectable(wTab);\n+        sl.dispose();\n+    }\n+\n+    @Test\n+    public void testSingleTabContextMenuGetsNewListChangeListenersWhenSceneChange() {\n+        \/\/ JDK-8283551\n+        \/\/ Test moving a tab pane from one scene to another removes and re-adds the appropriate ListChangeListeners\n+        Tab t = new Tab();\n+        TabPane tabPane = new TabPane(t);\n+\n+        ContextMenu contextMenu1 = new ContextMenu();\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        StackPane root = new StackPane(tabPane);\n+        t.setContextMenu(contextMenu1); \/\/ set before in scene\n+        StageLoader sl1 = new StageLoader(root);\n+\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        \/\/ removing and re-adding removes and re-adds listeners\n+        root.getChildren().clear();\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        root.getChildren().add(tabPane);\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        ListChangeListener<? super MenuItem> originalListener1 =\n+                ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).get(1);\n+\n+        StageLoader sl2 = new StageLoader(root); \/\/ change the scene\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        root.getChildren().clear();\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        root.getChildren().add(tabPane);\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+\n+        \/\/ the listeners are new\n+        for (ListChangeListener l : ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems())) {\n+            \/\/ can't use contains because the equals method for one of these listeners will return true\n+            assertFalse(l == originalListener1);\n+        }\n+        sl1.dispose();\n+        sl2.dispose();\n+    }\n+\n+    @Ignore \/\/ Only the first tab's context menu gets a scene change listener right now\n+    @Test\n+    public void testMultipleTabContextMenuGetsNewListChangeListenersWhenSceneChange() {\n+        Tab t = new Tab();\n+        Tab t2 = new Tab();\n+        TabPane tabPane = new TabPane(t,t2);\n+\n+        ContextMenu contextMenu1 = new ContextMenu();\n+        ContextMenu contextMenu2 = new ContextMenu();\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        StackPane root = new StackPane(tabPane);\n+        t.setContextMenu(contextMenu1); \/\/ set before in scene\n+        t2.setContextMenu(contextMenu2);\n+        StageLoader sl1 = new StageLoader(root);\n+\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        \/\/ removing and re-adding removes and re-adds listeners\n+        root.getChildren().clear();\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        root.getChildren().add(tabPane);\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        ListChangeListener<? super MenuItem> originalListener1 =\n+                ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).get(1);\n+        ListChangeListener<? super MenuItem> originalListener2 =\n+                ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).get(1);\n+\n+        StageLoader sl2 = new StageLoader(root); \/\/ change the scene\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        root.getChildren().clear();\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        root.getChildren().add(tabPane);\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+\n+        \/\/ the listeners are new\n+        for (ListChangeListener l : ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems())) {\n+            \/\/ can't use contains because the equals method for one of these listeners will return true\n+            assertFalse(l == originalListener1);\n+        }\n+        for (ListChangeListener l : ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems())) {\n+            \/\/ can't use contains because the equals method for one of these listeners will return true\n+            assertFalse(l == originalListener2);\n+        }\n+        sl1.dispose();\n+        sl2.dispose();\n+    }\n+\n+    @Test\n+    public void testTabContextMenuSceneChangeDoesntLeakScene() {\n+        \/\/ JDK-8283551\n+        \/\/ The scene was leaked in a ListChangeListener added by ControlAcceleratorSupport\n+        \/\/ For tab context menus, either the ListChangeListener is removed when the TabPane changes scenes\n+        \/\/ or when a new context menu is set. Both removals are tested here.\n+\n+        Tab t = new Tab();\n+        TabPane tabPane = new TabPane(t);\n+\n+        ContextMenu contextMenu1 = new ContextMenu();\n+        ContextMenu contextMenu2 = new ContextMenu();\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        StackPane root = new StackPane(tabPane);\n+        StageLoader sl1 = new StageLoader(root);\n+        t.setContextMenu(contextMenu1);\n+\n+        \/\/ adding the context menu to the tab adds a list change listener\n+        assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+\n+        \/\/ swapping the context menu removes the previously added list change listener\n+        t.setContextMenu(contextMenu2);\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+\n+        \/\/ This assert fails because right now each anchor has one scene change listener only\n+        \/\/ There needs to be a scene change listener per ObservableList\n+        \/\/assertEquals(2, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+\n+        \/\/ Both context menus shouldn't have a list change listener that references the scene after its removed\n+        WeakReference<Scene> scene1 = new WeakReference<>(sl1.getStage().getScene());\n+        sl1.dispose();\n+\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu2.getItems()).size());\n+        JMemoryBuddy.assertCollectable(scene1);\n+    }\n+\n+    @Ignore(\"JDK-8268374\")\n+    @Test\n+    public void testContextMenuOnTabSetToNullWhenNotInSceneRemovesListeners() {\n+        \/\/ JDK-8268374\n+        Tab t = new Tab();\n+        TabPane tabPane = new TabPane(t);\n+\n+        ContextMenu contextMenu1 = new ContextMenu();\n+        MenuItem item1 = new MenuItem();\n+        contextMenu1.getItems().add(item1);\n+        assertEquals(0, getListenerCount(item1.acceleratorProperty()));\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        t.setContextMenu(contextMenu1);\n+        StackPane root = new StackPane(tabPane);\n+        StageLoader sl1 = new StageLoader(root);\n+        assertEquals(1, getListenerCount(item1.acceleratorProperty()));\n+        root.getChildren().setAll(new StackPane()); \/\/ remove tabpane from scene\n+        assertEquals(0, getListenerCount(item1.acceleratorProperty()));\n+        t.setContextMenu(null);\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        root.getChildren().setAll(tabPane);\n+        assertEquals(0, getListenerCount(item1.acceleratorProperty()));\n+        sl1.dispose();\n+    }\n+\n+    @Ignore(\"JDK-8268374\")\n+    @Test\n+    public void testContextMenuOnTabSetToNullAfterTabIsRemoved() {\n+        \/\/ JDK-8268374\n+        Tab t = new Tab();\n+        TabPane tabPane = new TabPane(t);\n+\n+        ContextMenu contextMenu1 = new ContextMenu();\n+        MenuItem item1 = new MenuItem();\n+        contextMenu1.getItems().add(item1);\n+        assertEquals(0, getListenerCount(item1.acceleratorProperty()));\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        t.setContextMenu(contextMenu1);\n+        StackPane root = new StackPane(tabPane);\n+        StageLoader sl1 = new StageLoader(root);\n+        assertEquals(1, getListenerCount(item1.acceleratorProperty()));\n+        root.getChildren().setAll(new StackPane());\n+        tabPane.getTabs().remove(0);\n+        assertEquals(0, getListenerCount(item1.acceleratorProperty()));\n+        t.setContextMenu(null);\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        tabPane.getTabs().add(t);\n+        root.getChildren().setAll(tabPane);\n+        assertEquals(0, getListenerCount(item1.acceleratorProperty()));\n+        sl1.dispose();\n+    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ControlAcceleratorSupportTest.java","additions":289,"deletions":5,"binary":false,"changes":294,"status":"modified"}]}