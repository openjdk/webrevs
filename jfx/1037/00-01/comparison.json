{"files":[{"patch":"@@ -51,1 +51,0 @@\n-import java.util.Objects;\n@@ -144,0 +143,10 @@\n+        \/\/ We need to store the ListChangeListener for later so that we can clean up, so ideally we'd use the items\n+        \/\/ list as a key in a WeakHashMap with the ListChangeListener as the value. Unfortunately items can't be used\n+        \/\/ as a key as is because its equals method compares the list contents which breaks immediately for empty\n+        \/\/ lists.\n+        \/\/ Instead we have to use an identity wrapper over the items as a key, but since the HashMap is weak, we also\n+        \/\/ have to retain a reference to the identity wrapper class. This could be avoided if there was a\n+        \/\/ WeakIdentityHashMap class available.\n+        \/\/ One way is to use the ListChangeListener itself as the identity wrapper: IdentityWrapperListChangeListener\n+        \/\/ since the items list will have a reference to it. We can create temporary instances of the\n+        \/\/ IdentityWrapperListChangeListener when we need to retrieve items from the WeakHashMap to get the real one.\n@@ -149,1 +158,0 @@\n-                        \/\/ remove accelerators from the scene\n@@ -154,1 +162,1 @@\n-                        ControlAcceleratorSupport.doAcceleratorInstall(c.getAddedSubList(), scene);\n+                        doAcceleratorInstall(c.getAddedSubList(), scene);\n@@ -160,0 +168,8 @@\n+        \/\/ There should only ever be one ListChangeListener from ControlAcceleratorSupport on each items list\n+        \/\/ If there is one somehow, this removes it from the list, and replaces the entry in the HashMap.\n+        WeakReference<ListChangeListener<MenuItem>> previousW = menuListChangeListenerMap.get(listChangeListener);\n+        ListChangeListener<MenuItem> previous = previousW == null ? null : previousW.get();\n+        if (previous != null) {\n+            items.removeListener(previous);\n+        }\n+\n@@ -275,1 +291,3 @@\n-        WeakReference<ListChangeListener<MenuItem>> listenerW = menuListChangeListenerMap.get(new IdentityWrapperListChangeListener(items));\n+        \/\/ use a temporary IdentityWrapperListChangeListener to get the actual one that's listening to items\n+        WeakReference<ListChangeListener<MenuItem>> listenerW =\n+                menuListChangeListenerMap.get(new IdentityWrapperListChangeListener(items));\n@@ -336,10 +354,12 @@\n-    \/\/ We need to store all the listeners added to each ObservableList so that we can remove them. For this we need\n-    \/\/ a map mapping ObservableList to various listeners such as ListChangeListeners, but the map needs to be a\n-    \/\/ WeakHashMap.\n-    \/\/ The ideal key to the WeakHashMap would be the ObservableList itself, except for the fact that its equals method\n-    \/\/ compares the list contents. If a WeakIdentityHashMap existed, we could use that instead with the ObservableList\n-    \/\/ as the key.\n-    \/\/ We can't use an IdentityWrapper as the key to the HashMap because we need a strong reference (ideally from the\n-    \/\/ ObservableList itself) to the IdentityWrapper else it'll be garbage collected.\n-    \/\/ Since every ObservableList gets a ListChangeListener, we can use that as an IdentityWrapper and rely on the fact\n-    \/\/ ObservableList has a strong reference to the ListChangeListener.\n+    \/**\n+     * We need to store all the listeners added to each ObservableList so that we can remove them. For this we need\n+     * a map mapping ObservableList to various listeners such as ListChangeListeners, but the map needs to be a\n+     * WeakHashMap.\n+     * The ideal key to the WeakHashMap would be the ObservableList itself, except for the fact that its equals method\n+     * compares the list contents. If a WeakIdentityHashMap existed, we could use that instead with the ObservableList\n+     * as the key.\n+     * We can't use an IdentityWrapper as the key to the HashMap because we need a strong reference (ideally from the\n+     * ObservableList itself) to the IdentityWrapper else it'll be garbage collected.\n+     * Since every ObservableList gets a ListChangeListener, we can use that as an IdentityWrapper and rely on the fact\n+     * ObservableList has a strong reference to the ListChangeListener.\n+     *\/\n@@ -356,0 +376,2 @@\n+            \/\/ In some cases this class is used as a key to fetch an item in a HashMap only, and then discarded\n+            \/\/ In other cases the onChanged method is overridden and this is used as a ListChangeListener\n@@ -360,1 +382,1 @@\n-            return Objects.hashCode(innerList);\n+            return System.identityHashCode(innerList);\n@@ -365,2 +387,6 @@\n-            if (this == o) return true;\n-            if (o == null || !(o instanceof IdentityWrapperListChangeListener)) return false;\n+            if (this == o) {\n+                return true;\n+            }\n+            if (!(o instanceof IdentityWrapperListChangeListener)) {\n+                return false;\n+            }\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/ControlAcceleratorSupport.java","additions":43,"deletions":17,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.tk.Toolkit;\n@@ -253,0 +254,2 @@\n+        menuItemWithReferenceToTab = null; \/\/ also holds a reference to tab through its action\n+        contextMenu = null;\n@@ -255,0 +258,4 @@\n+        tabPane.getTabs().add(new Tab());\n+        \/\/ the TabPane still holds onto the tab through a reference in stackpane\n+        \/\/ adding a new tab and running a pulse gets rid of it\n+        Toolkit.getToolkit().firePulse();\n@@ -297,1 +304,1 @@\n-    @Ignore\n+    @Ignore \/\/ Only the first tab's context menu gets a scene change listener right now\n@@ -300,2 +307,0 @@\n-        \/\/ JDK-8283551\n-        \/\/ Test moving a tab pane from one scene to another removes and re-adds the appropriate ListChangeListeners\n@@ -389,0 +394,52 @@\n+\n+    @Ignore(\"JDK-8268374\")\n+    @Test\n+    public void testContextMenuOnTabSetToNullWhenNotInSceneRemovesListeners() {\n+        \/\/ JDK-8268374\n+        Tab t = new Tab();\n+        TabPane tabPane = new TabPane(t);\n+\n+        ContextMenu contextMenu1 = new ContextMenu();\n+        MenuItem item1 = new MenuItem();\n+        contextMenu1.getItems().add(item1);\n+        assertEquals(0, getListenerCount(item1.acceleratorProperty()));\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        t.setContextMenu(contextMenu1);\n+        StackPane root = new StackPane(tabPane);\n+        StageLoader sl1 = new StageLoader(root);\n+        assertEquals(1, getListenerCount(item1.acceleratorProperty()));\n+        root.getChildren().setAll(new StackPane()); \/\/ remove tabpane from scene\n+        assertEquals(0, getListenerCount(item1.acceleratorProperty()));\n+        t.setContextMenu(null);\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        root.getChildren().setAll(tabPane);\n+        assertEquals(0, getListenerCount(item1.acceleratorProperty()));\n+        sl1.dispose();\n+    }\n+\n+    @Ignore(\"JDK-8268374\")\n+    @Test\n+    public void testContextMenuOnTabSetToNullAfterTabIsRemoved() {\n+        \/\/ JDK-8268374\n+        Tab t = new Tab();\n+        TabPane tabPane = new TabPane(t);\n+\n+        ContextMenu contextMenu1 = new ContextMenu();\n+        MenuItem item1 = new MenuItem();\n+        contextMenu1.getItems().add(item1);\n+        assertEquals(0, getListenerCount(item1.acceleratorProperty()));\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        t.setContextMenu(contextMenu1);\n+        StackPane root = new StackPane(tabPane);\n+        StageLoader sl1 = new StageLoader(root);\n+        assertEquals(1, getListenerCount(item1.acceleratorProperty()));\n+        root.getChildren().setAll(new StackPane());\n+        tabPane.getTabs().remove(0);\n+        assertEquals(0, getListenerCount(item1.acceleratorProperty()));\n+        t.setContextMenu(null);\n+        assertEquals(0, ExpressionHelperUtility.getListChangeListeners(contextMenu1.getItems()).size());\n+        tabPane.getTabs().add(t);\n+        root.getChildren().setAll(tabPane);\n+        assertEquals(0, getListenerCount(item1.acceleratorProperty()));\n+        sl1.dispose();\n+    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/ControlAcceleratorSupportTest.java","additions":60,"deletions":3,"binary":false,"changes":63,"status":"modified"}]}