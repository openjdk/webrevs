{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## xmlsoft.org: libxml2 v2.9.13\n+## xmlsoft.org: libxml2 v2.9.14\n","filename":"modules\/javafx.web\/src\/main\/legal\/libxml2.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## xmlsoft.org: libxslt v1.1.34\n+## xmlsoft.org: libxslt v1.1.35\n","filename":"modules\/javafx.web\/src\/main\/legal\/libxslt.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-10. Helper commands for removing tabs and trailing whitespaces from source files(.h and .c).\n+10. Update version info in 'modules\/javafx.web\/src\/main\/legal\/libxml.md'.Also, update copyright if any new files are added.\n@@ -46,1 +46,1 @@\n-10.1 > cd modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\n+11. Helper commands for removing tabs and trailing whitespaces from source files(.h and .c).\n@@ -48,1 +48,3 @@\n-10.2 Remove tabs from source files:\n+11.1 > cd modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\n+\n+11.2 Remove tabs from source files:\n@@ -53,1 +55,1 @@\n-10.3 Remove trailing whitespaces from source files:\n+11.3 Remove trailing whitespaces from source files:\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/UPDATING.txt","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-#define PACKAGE_STRING \"libxml2 2.9.13\"\n+#define PACKAGE_STRING \"libxml2 2.9.14\"\n@@ -253,1 +253,1 @@\n-#define PACKAGE_VERSION \"2.9.13\"\n+#define PACKAGE_VERSION \"2.9.14\"\n@@ -268,1 +268,1 @@\n-#define VERSION \"2.9.13\"\n+#define VERSION \"2.9.14\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/linux\/config.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#define LIBXML_DOTTED_VERSION \"2.9.13\"\n+#define LIBXML_DOTTED_VERSION \"2.9.14\"\n@@ -39,1 +39,1 @@\n-#define LIBXML_VERSION 20913\n+#define LIBXML_VERSION 20914\n@@ -46,1 +46,1 @@\n-#define LIBXML_VERSION_STRING \"20913\"\n+#define LIBXML_VERSION_STRING \"20914\"\n@@ -61,1 +61,1 @@\n-#define LIBXML_TEST_VERSION xmlCheckVersion(20913);\n+#define LIBXML_TEST_VERSION xmlCheckVersion(20914);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/linux\/include\/libxml\/xmlversion.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n-\/* Define to 1 if you have the <dirent.h> header file. *\/\n+\/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.\n+   *\/\n@@ -32,1 +33,1 @@\n-\/* #undef HAVE_DLOPEN *\/\n+#define HAVE_DLOPEN \/**\/\n@@ -64,6 +65,0 @@\n-\/* Define if isinf is there *\/\n-#define HAVE_ISINF \/**\/\n-\n-\/* Define if isnan is there *\/\n-#define HAVE_ISNAN \/**\/\n-\n@@ -73,3 +68,0 @@\n-\/* Define if pthread library is there (-lpthread) *\/\n-#define HAVE_LIBPTHREAD \/**\/\n-\n@@ -94,3 +86,0 @@\n-\/* Define to 1 if you have the <memory.h> header file. *\/\n-#define HAVE_MEMORY_H 1\n-\n@@ -133,1 +122,1 @@\n-\/* #undef HAVE_RAND_R 1 *\/\n+#define HAVE_RAND_R 1\n@@ -168,0 +157,3 @@\n+\/* Define to 1 if you have the <stdio.h> header file. *\/\n+#define HAVE_STDIO_H 1\n+\n@@ -237,1 +229,1 @@\n-\/* #undef ICONV_CONST *\/\n+#define ICONV_CONST\n@@ -249,1 +241,1 @@\n-#define PACKAGE_NAME \"\"\n+#define PACKAGE_NAME \"libxml2\"\n@@ -252,1 +244,1 @@\n-#define PACKAGE_STRING \"\"\n+#define PACKAGE_STRING \"libxml2 2.9.14\"\n@@ -255,1 +247,1 @@\n-#define PACKAGE_TARNAME \"\"\n+#define PACKAGE_TARNAME \"libxml2\"\n@@ -261,1 +253,1 @@\n-#define PACKAGE_VERSION \"\"\n+#define PACKAGE_VERSION \"2.9.14\"\n@@ -266,1 +258,3 @@\n-\/* Define to 1 if you have the ANSI C header files. *\/\n+\/* Define to 1 if all of the C90 standard headers exist (not just the ones\n+   required in a freestanding environment). This macro is provided for\n+   backward compatibility; new code need not use it. *\/\n@@ -276,1 +270,1 @@\n-#define VERSION \"2.9.12\"\n+#define VERSION \"2.9.14\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/mac\/config.h","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#define LIBXML_DOTTED_VERSION \"2.9.13\"\n+#define LIBXML_DOTTED_VERSION \"2.9.14\"\n@@ -39,1 +39,1 @@\n-#define LIBXML_VERSION 20913\n+#define LIBXML_VERSION 20914\n@@ -46,1 +46,1 @@\n-#define LIBXML_VERSION_STRING \"20913\"\n+#define LIBXML_VERSION_STRING \"20914\"\n@@ -61,1 +61,1 @@\n-#define LIBXML_TEST_VERSION xmlCheckVersion(20913);\n+#define LIBXML_TEST_VERSION xmlCheckVersion(20914);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/mac\/include\/libxml\/xmlversion.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -617,1 +617,2 @@\n-        res++;\n+        if (res < INT_MAX)\n+            res++;\n@@ -3963,20 +3964,0 @@\n-        \/*\n-         * The recovery code is disabled for now as it can result in\n-         * quadratic behavior with the push parser. htmlParseStartTag\n-         * must consume all content up to the final '>' in order to avoid\n-         * rescanning for this terminator.\n-         *\n-         * For a proper fix in line with HTML5, htmlParseStartTag and\n-         * htmlParseElement should only be called when there's an ASCII\n-         * alpha character following the initial '<'. Otherwise, the '<'\n-         * should be emitted as text (unless followed by '!', '\/' or '?').\n-         *\/\n-#if 0\n-        \/* if recover preserve text on classic misconstructs *\/\n-        if ((ctxt->recovery) && ((IS_BLANK_CH(CUR)) || (CUR == '<') ||\n-            (CUR == '=') || (CUR == '>') || (((CUR >= '0') && (CUR <= '9'))))) {\n-            htmlParseCharDataInternal(ctxt, '<');\n-            return(-1);\n-        }\n-#endif\n-\n@@ -4435,1 +4416,1 @@\n-            else if (CUR == '<') {\n+            else if ((CUR == '<') && IS_ASCII_LETTER(NXT(1))) {\n@@ -4438,0 +4419,6 @@\n+            else if (CUR == '<') {\n+                if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                    (ctxt->sax->characters != NULL))\n+                    ctxt->sax->characters(ctxt->userData, BAD_CAST \"<\", 1);\n+                NEXT;\n+            }\n@@ -4834,1 +4821,1 @@\n-            else if (CUR == '<') {\n+            else if ((CUR == '<') && IS_ASCII_LETTER(NXT(1))) {\n@@ -4841,0 +4828,6 @@\n+            else if (CUR == '<') {\n+                if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                    (ctxt->sax->characters != NULL))\n+                    ctxt->sax->characters(ctxt->userData, BAD_CAST \"<\", 1);\n+                NEXT;\n+            }\n@@ -6007,1 +6000,1 @@\n-                    } else if (cur == '<') {\n+                    } else if ((cur == '<') && IS_ASCII_LETTER(next)) {\n@@ -6017,0 +6010,6 @@\n+                    } else if (cur == '<') {\n+                        if ((ctxt->sax != NULL) && (!ctxt->disableSAX) &&\n+                            (ctxt->sax->characters != NULL))\n+                            ctxt->sax->characters(ctxt->userData,\n+                                                  BAD_CAST \"<\", 1);\n+                        NEXT;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/HTMLparser.c","additions":23,"deletions":24,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -4,6 +4,30 @@\n-The change log at \n-ChangeLog.html\n- describes the recents commits\n-to the GIT at \n-https:\/\/gitlab.gnome.org\/GNOME\/libxml2\n- code base.Here is the list of public releases:\n+v2.9.14: May 02 2022:\n+   - Security:\n+  [CVE-2022-29824] Integer overflow in xmlBuf and xmlBuffer\n+  Fix potential double-free in xmlXPtrStringRangeFunction\n+  Fix memory leak in xmlFindCharEncodingHandler\n+  Normalize XPath strings in-place\n+  Prevent integer-overflow in htmlSkipBlankChars() and xmlSkipBlankChars()\n+    (David Kilzer)\n+  Fix leak of xmlElementContent (David Kilzer)\n+\n+   - Bug fixes:\n+  Fix parsing of subtracted regex character classes\n+  Fix recursion check in xinclude.c\n+  Reset last error in xmlCleanupGlobals\n+  Fix certain combinations of regex range quantifiers\n+  Fix range quantifier on subregex\n+\n+   - Improvements:\n+  Fix recovery from invalid HTML start tags\n+\n+   - Build system, portability:\n+  Define LFS macros before including system headers\n+  Initialize XPath floating-point globals\n+  configure: check for icu DEFS (James Hilliard)\n+  configure.ac: produce tar.xz only (GNOME policy) (David Seifert)\n+  CMakeLists.txt: Fix LIBXML_VERSION_NUMBER\n+  Fix build with older Python versions\n+  Fix --without-valid build\n+\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/NEWS","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -20,0 +20,93 @@\n+## Build instructions\n+\n+libxml2 can be built with GNU Autotools, CMake, or several other build\n+systems in platform-specific subdirectories.\n+\n+### Autotools (for POSIX systems like Linux, BSD, macOS)\n+\n+If you build from a Git tree, you have to install Autotools and start\n+by generating the configuration files with:\n+\n+    .\/autogen.sh\n+\n+If you build from a source tarball, extract the archive with:\n+\n+    tar xf libxml2-xxx.tar.gz\n+    cd libxml2-xxx\n+\n+To see a list of build options:\n+\n+    .\/configure --help\n+\n+Also see the INSTALL file for additional instructions. Then you can\n+configure and build the library:\n+\n+    .\/configure [possible options]\n+    make\n+\n+Now you can run the test suite with:\n+\n+    make check\n+\n+Please report test failures to the mailing list or bug tracker.\n+\n+Then you can install the library:\n+\n+    make install\n+\n+At that point you may have to rerun ldconfig or a similar utility to\n+update your list of installed shared libs.\n+\n+### CMake (mainly for Windows)\n+\n+Another option for compiling libxml is using CMake:\n+\n+    cmake -E tar xf libxml2-xxx.tar.gz\n+    cmake -S libxml2-xxx -B libxml2-xxx-build [possible options]\n+    cmake --build libxml2-xxx-build\n+    cmake --install libxml2-xxx-build\n+\n+Common CMake options include:\n+\n+    -D BUILD_SHARED_LIBS=OFF            # build static libraries\n+    -D CMAKE_BUILD_TYPE=Release         # specify build type\n+    -D CMAKE_INSTALL_PREFIX=\/usr\/local  # specify the install path\n+    -D LIBXML2_WITH_ICONV=OFF           # disable iconv\n+    -D LIBXML2_WITH_LZMA=OFF            # disable liblzma\n+    -D LIBXML2_WITH_PYTHON=OFF          # disable Python\n+    -D LIBXML2_WITH_ZLIB=OFF            # disable libz\n+\n+You can also open the libxml source directory with its CMakeLists.txt\n+directly in various IDEs such as CLion, QtCreator, or Visual Studio.\n+\n+## Dependencies\n+\n+Libxml does not require any other libraries. A platform with somewhat\n+recent POSIX support should be sufficient (please report any violation\n+to this rule you may find).\n+\n+However, if found at configuration time, libxml will detect and use\n+the following libraries:\n+\n+- [libz](https:\/\/zlib.net\/), a highly portable and widely available\n+  compression library.\n+- [liblzma](https:\/\/tukaani.org\/xz\/), another compression library.\n+- [libiconv](https:\/\/www.gnu.org\/software\/libiconv\/), a character encoding\n+  conversion library. The iconv function is part of POSIX.1-2001, so\n+  libiconv isn't required on modern UNIX-like systems like Linux, BSD or\n+  macOS.\n+- [ICU](https:\/\/icu.unicode.org\/), a Unicode library. Mainly useful as an\n+  alternative to iconv on Windows. Unnecessary on most other systems.\n+\n+## Contributing\n+\n+The current version of the code can be found in GNOME's GitLab at \n+at <https:\/\/gitlab.gnome.org\/GNOME\/libxml2>. The best way to get involved\n+is by creating issues and merge requests on GitLab. Alternatively, you can\n+start discussions and send patches to the mailing list. If you want to\n+work with patches, please format them with git-format-patch and use plain\n+text attachments.\n+\n+All code must conform to C89 and pass the GitLab CI tests. Add regression\n+tests if possible.\n+\n@@ -28,0 +121,1 @@\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/README.md","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+#ifndef SIZE_MAX\n+#define SIZE_MAX ((size_t) -1)\n+#endif\n+\n@@ -159,0 +163,2 @@\n+    if (size == SIZE_MAX)\n+        return(NULL);\n@@ -169,2 +175,2 @@\n-    ret->size = (size ? size+2 : 0);         \/* +1 for ending null *\/\n-    ret->compat_size = (int) ret->size;\n+    ret->size = (size ? size + 1 : 0);         \/* +1 for ending null *\/\n+    ret->compat_size = (ret->size > INT_MAX ? INT_MAX : ret->size);\n@@ -445,1 +451,1 @@\n-    if (buf->use + len < buf->size)\n+    if (len < buf->size - buf->use)\n@@ -447,0 +453,2 @@\n+    if (len > SIZE_MAX - buf->use)\n+        return(0);\n@@ -448,14 +456,6 @@\n-    \/*\n-     * Windows has a BIG problem on realloc timing, so we try to double\n-     * the buffer size (if that's enough) (bug 146697)\n-     * Apparently BSD too, and it's probably best for linux too\n-     * On an embedded system this may be something to change\n-     *\/\n-#if 1\n-    if (buf->size > (size_t) len)\n-        size = buf->size * 2;\n-    else\n-        size = buf->use + len + 100;\n-#else\n-    size = buf->use + len + 100;\n-#endif\n+    if (buf->size > (size_t) len) {\n+        size = buf->size > SIZE_MAX \/ 2 ? SIZE_MAX : buf->size * 2;\n+    } else {\n+        size = buf->use + len;\n+        size = size > SIZE_MAX - 100 ? SIZE_MAX : size + 100;\n+    }\n@@ -747,1 +747,1 @@\n-    unsigned int newSize;\n+    size_t newSize;\n@@ -775,1 +775,5 @@\n-            newSize = (buf->size ? buf->size*2 : size + 10);\n+            if (buf->size == 0) {\n+                newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);\n+            } else {\n+                newSize = buf->size;\n+            }\n@@ -777,1 +781,1 @@\n-                if (newSize > UINT_MAX \/ 2) {\n+                if (newSize > SIZE_MAX \/ 2) {\n@@ -785,1 +789,1 @@\n-            newSize = size+10;\n+            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);\n@@ -791,1 +795,1 @@\n-                newSize = buf->size * 2;\n+                newSize = buf->size;\n@@ -793,1 +797,1 @@\n-                    if (newSize > UINT_MAX \/ 2) {\n+                    if (newSize > SIZE_MAX \/ 2) {\n@@ -803,1 +807,1 @@\n-            newSize = size+10;\n+            newSize = (size > SIZE_MAX - 10 ? SIZE_MAX : size + 10);\n@@ -869,1 +873,1 @@\n-    unsigned int needSize;\n+    size_t needSize;\n@@ -891,2 +895,4 @@\n-    needSize = buf->use + len + 2;\n-    if (needSize > buf->size){\n+    if ((size_t) len >= buf->size - buf->use) {\n+        if ((size_t) len >= SIZE_MAX - buf->use)\n+            return(-1);\n+        needSize = buf->use + len + 1;\n@@ -1028,25 +1034,1 @@\n-    const char *cur;\n-\n-    if ((buf == NULL) || (buf->error))\n-        return(-1);\n-    CHECK_COMPAT(buf)\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;\n-    if (str == NULL) {\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufCCat: str == NULL\\n\");\n-#endif\n-        return -1;\n-    }\n-    for (cur = str;*cur != 0;cur++) {\n-        if (buf->use  + 10 >= buf->size) {\n-            if (!xmlBufResize(buf, buf->use+10)){\n-                xmlBufMemoryError(buf, \"growing buffer\");\n-                return XML_ERR_NO_MEMORY;\n-            }\n-        }\n-        buf->content[buf->use++] = *cur;\n-    }\n-    buf->content[buf->use] = 0;\n-    UPDATE_COMPAT(buf)\n-    return 0;\n+    return xmlBufCat(buf, (const xmlChar *) str);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/buf.c","additions":34,"deletions":52,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-m4_define([MICRO_VERSION], 13)\n+m4_define([MICRO_VERSION], 14)\n@@ -43,1 +43,1 @@\n-AM_INIT_AUTOMAKE([foreign])\n+AM_INIT_AUTOMAKE([foreign no-dist-gzip dist-xz])\n@@ -1478,0 +1478,7 @@\n+    if test \"x$have_libicu\" = \"xyes\"; then\n+        PKG_CHECK_VAR([ICU_DEFS], [icu-i18n], [DEFS])\n+        if test \"x$ICU_DEFS\" != \"x\"; then\n+            CPPFLAGS=\"$CPPFLAGS $ICU_DEFS\"\n+        fi\n+    fi\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/configure.ac","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1741,0 +1741,4 @@\n+            if (icv_in != (iconv_t) -1)\n+                iconv_close(icv_in);\n+            else\n+                iconv_close(icv_out);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/encoding.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,14 +53,0 @@\n-\/**\n- * xmlCleanupGlobals:\n- *\n- * Additional cleanup for multi-threading\n- *\/\n-void xmlCleanupGlobals(void)\n-{\n-    if (xmlThrDefMutex != NULL) {\n-        xmlFreeMutex(xmlThrDefMutex);\n-        xmlThrDefMutex = NULL;\n-    }\n-    __xmlGlobalInitMutexDestroy();\n-}\n-\n@@ -580,0 +566,16 @@\n+\/**\n+ * xmlCleanupGlobals:\n+ *\n+ * Additional cleanup for multi-threading\n+ *\/\n+void xmlCleanupGlobals(void)\n+{\n+    xmlResetError(&xmlLastError);\n+\n+    if (xmlThrDefMutex != NULL) {\n+        xmlFreeMutex(xmlThrDefMutex);\n+        xmlThrDefMutex = NULL;\n+    }\n+    __xmlGlobalInitMutexDestroy();\n+}\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/globals.c","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -12,2 +12,4 @@\n-#include <libxml\/xmlstring.h>\n-\n+\/*\n+ * These macros must be defined before including system headers.\n+ * Do not add any #include directives above this block.\n+ *\/\n@@ -42,0 +44,1 @@\n+#include <libxml\/xmlstring.h>\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml.h","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-Version: 2.9.13\n+Version: 2.9.14\n@@ -207,2 +207,2 @@\n-* Tue Mar 22 2022 Daniel Veillard <veillard@redhat.com>\n-- upstream release 2.9.13\n+* Fri May 13 2022 Daniel Veillard <veillard@redhat.com>\n+- upstream release 2.9.14\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/libxml2.spec","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2211,1 +2211,2 @@\n-            res++;\n+            if (res < INT_MAX)\n+                res++;\n@@ -2247,1 +2248,2 @@\n-            res++;\n+            if (res < INT_MAX)\n+                res++;\n@@ -14752,1 +14754,0 @@\n-    xmlResetLastError();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/parser.c","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -7107,0 +7107,2 @@\n+    if (size >= UINT_MAX)\n+        return(NULL);\n@@ -7114,1 +7116,1 @@\n-    ret->size = (size ? size+2 : 0);         \/* +1 for ending null *\/\n+    ret->size = (size ? size + 1 : 0);         \/* +1 for ending null *\/\n@@ -7174,0 +7176,2 @@\n+    if (size > UINT_MAX)\n+        return(NULL);\n@@ -7321,1 +7325,1 @@\n-    int size;\n+    unsigned int size;\n@@ -7327,1 +7331,4 @@\n-    if (len + buf->use < buf->size) return(0);\n+    if (len < buf->size - buf->use)\n+        return(0);\n+    if (len > UINT_MAX - buf->use)\n+        return(-1);\n@@ -7329,14 +7336,6 @@\n-    \/*\n-     * Windows has a BIG problem on realloc timing, so we try to double\n-     * the buffer size (if that's enough) (bug 146697)\n-     * Apparently BSD too, and it's probably best for linux too\n-     * On an embedded system this may be something to change\n-     *\/\n-#if 1\n-    if (buf->size > len)\n-        size = buf->size * 2;\n-    else\n-        size = buf->use + len + 100;\n-#else\n-    size = buf->use + len + 100;\n-#endif\n+    if (buf->size > (size_t) len) {\n+        size = buf->size > UINT_MAX \/ 2 ? UINT_MAX : buf->size * 2;\n+    } else {\n+        size = buf->use + len;\n+        size = size > UINT_MAX - 100 ? UINT_MAX : size + 100;\n+    }\n@@ -7469,1 +7468,4 @@\n-            newSize = (buf->size ? buf->size : size + 10);\n+            if (buf->size == 0)\n+                newSize = (size > UINT_MAX - 10 ? UINT_MAX : size + 10);\n+            else\n+                newSize = buf->size;\n@@ -7479,1 +7481,1 @@\n-            newSize = size+10;\n+            newSize = (size > UINT_MAX - 10 ? UINT_MAX : size + 10);;\n@@ -7497,1 +7499,1 @@\n-            newSize = size+10;\n+            newSize = (size > UINT_MAX - 10 ? UINT_MAX : size + 10);;\n@@ -7583,2 +7585,4 @@\n-    needSize = buf->use + len + 2;\n-    if (needSize > buf->size){\n+    if ((unsigned) len >= buf->size - buf->use) {\n+        if ((unsigned) len >= UINT_MAX - buf->use)\n+            return XML_ERR_NO_MEMORY;\n+        needSize = buf->use + len + 1;\n@@ -7697,23 +7701,1 @@\n-    const char *cur;\n-\n-    if (buf == NULL)\n-        return(-1);\n-    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;\n-    if (str == NULL) {\n-#ifdef DEBUG_BUFFER\n-        xmlGenericError(xmlGenericErrorContext,\n-                \"xmlBufferCCat: str == NULL\\n\");\n-#endif\n-        return -1;\n-    }\n-    for (cur = str;*cur != 0;cur++) {\n-        if (buf->use  + 10 >= buf->size) {\n-            if (!xmlBufferResize(buf, buf->use+10)){\n-                xmlTreeErrMemory(\"growing buffer\");\n-                return XML_ERR_NO_MEMORY;\n-            }\n-        }\n-        buf->content[buf->use++] = *cur;\n-    }\n-    buf->content[buf->use] = 0;\n-    return 0;\n+    return xmlBufferCat(buf, (const xmlChar *) str);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/tree.c","additions":27,"deletions":45,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-                               int create);\n+                                   int create);\n@@ -34,3 +34,3 @@\n-#define TODO                                \\\n-    xmlGenericError(xmlGenericErrorContext,             \\\n-        \"Unimplemented block at %s:%d\\n\",               \\\n+#define TODO                                                            \\\n+    xmlGenericError(xmlGenericErrorContext,                             \\\n+            \"Unimplemented block at %s:%d\\n\",                           \\\n@@ -45,3 +45,3 @@\n- *                                  *\n- *          Error handling routines             *\n- *                                  *\n+ *                                                                      *\n+ *                      Error handling routines                         *\n+ *                                                                      *\n@@ -67,8 +67,8 @@\n-    \/* Use the special values to detect if it is part of a parsing\n-       context *\/\n-    if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n-        (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n-        long delta = (char *) ctxt - (char *) ctxt->userData;\n-        if ((delta > 0) && (delta < 250))\n-        pctxt = ctxt->userData;\n-    }\n+        \/* Use the special values to detect if it is part of a parsing\n+           context *\/\n+        if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n+            (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n+            long delta = (char *) ctxt - (char *) ctxt->userData;\n+            if ((delta > 0) && (delta < 250))\n+                pctxt = ctxt->userData;\n+        }\n@@ -107,8 +107,8 @@\n-    \/* Use the special values to detect if it is part of a parsing\n-       context *\/\n-    if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n-        (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n-        long delta = (char *) ctxt - (char *) ctxt->userData;\n-        if ((delta > 0) && (delta < 250))\n-        pctxt = ctxt->userData;\n-    }\n+        \/* Use the special values to detect if it is part of a parsing\n+           context *\/\n+        if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n+            (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n+            long delta = (char *) ctxt - (char *) ctxt->userData;\n+            if ((delta > 0) && (delta < 250))\n+                pctxt = ctxt->userData;\n+        }\n@@ -154,8 +154,8 @@\n-    \/* Use the special values to detect if it is part of a parsing\n-       context *\/\n-    if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n-        (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n-        long delta = (char *) ctxt - (char *) ctxt->userData;\n-        if ((delta > 0) && (delta < 250))\n-        pctxt = ctxt->userData;\n-    }\n+        \/* Use the special values to detect if it is part of a parsing\n+           context *\/\n+        if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n+            (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n+            long delta = (char *) ctxt - (char *) ctxt->userData;\n+            if ((delta > 0) && (delta < 250))\n+                pctxt = ctxt->userData;\n+        }\n@@ -197,8 +197,8 @@\n-    \/* Use the special values to detect if it is part of a parsing\n-       context *\/\n-    if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n-        (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n-        long delta = (char *) ctxt - (char *) ctxt->userData;\n-        if ((delta > 0) && (delta < 250))\n-        pctxt = ctxt->userData;\n-    }\n+        \/* Use the special values to detect if it is part of a parsing\n+           context *\/\n+        if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n+            (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n+            long delta = (char *) ctxt - (char *) ctxt->userData;\n+            if ((delta > 0) && (delta < 250))\n+                pctxt = ctxt->userData;\n+        }\n@@ -238,8 +238,8 @@\n-    \/* Use the special values to detect if it is part of a parsing\n-       context *\/\n-    if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n-        (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n-        long delta = (char *) ctxt - (char *) ctxt->userData;\n-        if ((delta > 0) && (delta < 250))\n-        pctxt = ctxt->userData;\n-    }\n+        \/* Use the special values to detect if it is part of a parsing\n+           context *\/\n+        if ((ctxt->finishDtd == XML_CTXT_FINISH_DTD_0) ||\n+            (ctxt->finishDtd == XML_CTXT_FINISH_DTD_1)) {\n+            long delta = (char *) ctxt - (char *) ctxt->userData;\n+            if ((delta > 0) && (delta < 250))\n+                pctxt = ctxt->userData;\n+        }\n@@ -267,3 +267,3 @@\n-    xmlElementPtr    elemDecl;  \/* pointer to the content model *\/\n-    xmlNodePtr           node;      \/* pointer to the current node *\/\n-    xmlRegExecCtxtPtr    exec;      \/* regexp runtime *\/\n+    xmlElementPtr        elemDecl;      \/* pointer to the content model *\/\n+    xmlNodePtr           node;          \/* pointer to the current node *\/\n+    xmlRegExecCtxtPtr    exec;          \/* regexp runtime *\/\n@@ -276,3 +276,3 @@\n-    ctxt->vstateMax = 10;\n-    ctxt->vstateTab = (xmlValidState *) xmlMalloc(ctxt->vstateMax *\n-                      sizeof(ctxt->vstateTab[0]));\n+        ctxt->vstateMax = 10;\n+        ctxt->vstateTab = (xmlValidState *) xmlMalloc(ctxt->vstateMax *\n+                              sizeof(ctxt->vstateTab[0]));\n@@ -280,3 +280,3 @@\n-        xmlVErrMemory(ctxt, \"malloc failed\");\n-        return(-1);\n-    }\n+            xmlVErrMemory(ctxt, \"malloc failed\");\n+            return(-1);\n+        }\n@@ -288,2 +288,2 @@\n-    tmp = (xmlValidState *) xmlRealloc(ctxt->vstateTab,\n-                 2 * ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n+        tmp = (xmlValidState *) xmlRealloc(ctxt->vstateTab,\n+                     2 * ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n@@ -291,5 +291,5 @@\n-        xmlVErrMemory(ctxt, \"realloc failed\");\n-        return(-1);\n-    }\n-    ctxt->vstateMax *= 2;\n-    ctxt->vstateTab = tmp;\n+            xmlVErrMemory(ctxt, \"realloc failed\");\n+            return(-1);\n+        }\n+        ctxt->vstateMax *= 2;\n+        ctxt->vstateTab = tmp;\n@@ -301,12 +301,12 @@\n-    if (elemDecl->contModel == NULL)\n-        xmlValidBuildContentModel(ctxt, elemDecl);\n-    if (elemDecl->contModel != NULL) {\n-        ctxt->vstateTab[ctxt->vstateNr].exec =\n-        xmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);\n-    } else {\n-        ctxt->vstateTab[ctxt->vstateNr].exec = NULL;\n-        xmlErrValidNode(ctxt, (xmlNodePtr) elemDecl,\n-                        XML_ERR_INTERNAL_ERROR,\n-                \"Failed to build content model regexp for %s\\n\",\n-                node->name, NULL, NULL);\n-    }\n+        if (elemDecl->contModel == NULL)\n+            xmlValidBuildContentModel(ctxt, elemDecl);\n+        if (elemDecl->contModel != NULL) {\n+            ctxt->vstateTab[ctxt->vstateNr].exec =\n+                xmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);\n+        } else {\n+            ctxt->vstateTab[ctxt->vstateNr].exec = NULL;\n+            xmlErrValidNode(ctxt, (xmlNodePtr) elemDecl,\n+                            XML_ERR_INTERNAL_ERROR,\n+                            \"Failed to build content model regexp for %s\\n\",\n+                            node->name, NULL, NULL);\n+        }\n@@ -327,1 +327,1 @@\n-    xmlRegFreeExecCtxt(ctxt->vstateTab[ctxt->vstateNr].exec);\n+        xmlRegFreeExecCtxt(ctxt->vstateTab[ctxt->vstateNr].exec);\n@@ -331,1 +331,1 @@\n-    ctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr - 1];\n+        ctxt->vstate = &ctxt->vstateTab[ctxt->vstateNr - 1];\n@@ -333,1 +333,1 @@\n-    ctxt->vstate = NULL;\n+        ctxt->vstate = NULL;\n@@ -348,1 +348,1 @@\n-#define ROLLBACK_OR 0\n+#define ROLLBACK_OR     0\n@@ -375,2 +375,2 @@\n-        xmlNodePtr node, unsigned char depth, long occurs,\n-        unsigned char state) {\n+            xmlNodePtr node, unsigned char depth, long occurs,\n+            unsigned char state) {\n@@ -380,8 +380,0 @@\n-    return(-1);\n-    }\n-    if (ctxt->vstateTab == NULL) {\n-    ctxt->vstateMax = 8;\n-    ctxt->vstateTab = (xmlValidState *) xmlMalloc(\n-             ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n-    if (ctxt->vstateTab == NULL) {\n-        xmlVErrMemory(ctxt, \"malloc failed\");\n@@ -390,0 +382,8 @@\n+    if (ctxt->vstateTab == NULL) {\n+        ctxt->vstateMax = 8;\n+        ctxt->vstateTab = (xmlValidState *) xmlMalloc(\n+                     ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n+        if (ctxt->vstateTab == NULL) {\n+            xmlVErrMemory(ctxt, \"malloc failed\");\n+            return(-1);\n+        }\n@@ -395,1 +395,1 @@\n-                 2 * ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n+                     2 * ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n@@ -397,6 +397,6 @@\n-        xmlVErrMemory(ctxt, \"malloc failed\");\n-        return(-1);\n-    }\n-    ctxt->vstateMax *= 2;\n-    ctxt->vstateTab = tmp;\n-    ctxt->vstate = &ctxt->vstateTab[0];\n+            xmlVErrMemory(ctxt, \"malloc failed\");\n+            return(-1);\n+        }\n+        ctxt->vstateMax *= 2;\n+        ctxt->vstateTab = tmp;\n+        ctxt->vstate = &ctxt->vstateTab[0];\n@@ -408,5 +408,5 @@\n-    (ctxt->vstateTab[i].node == node) &&\n-    (ctxt->vstateTab[i].depth == depth) &&\n-    (ctxt->vstateTab[i].occurs == occurs) &&\n-    (ctxt->vstateTab[i].state == state))\n-    return(ctxt->vstateNr);\n+        (ctxt->vstateTab[i].node == node) &&\n+        (ctxt->vstateTab[i].depth == depth) &&\n+        (ctxt->vstateTab[i].occurs == occurs) &&\n+        (ctxt->vstateTab[i].state == state))\n+        return(ctxt->vstateNr);\n@@ -445,1 +445,1 @@\n-        xmlVErrMemory(ctxt, \"malloc failed\");\n+            xmlVErrMemory(ctxt, \"malloc failed\");\n@@ -453,1 +453,1 @@\n-                  ctxt->nodeMax * 2 * sizeof(ctxt->nodeTab[0]));\n+                              ctxt->nodeMax * 2 * sizeof(ctxt->nodeTab[0]));\n@@ -455,1 +455,1 @@\n-        xmlVErrMemory(ctxt, \"realloc failed\");\n+            xmlVErrMemory(ctxt, \"realloc failed\");\n@@ -459,1 +459,1 @@\n-    ctxt->nodeTab = tmp;\n+        ctxt->nodeTab = tmp;\n@@ -486,2 +486,2 @@\n-    xmlGenericError(xmlGenericErrorContext, \"null\");\n-    return;\n+        xmlGenericError(xmlGenericErrorContext, \"null\");\n+        return;\n@@ -490,39 +490,39 @@\n-    case XML_ELEMENT_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"%s \", cur->name);\n-        break;\n-    case XML_TEXT_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"text \");\n-        break;\n-    case XML_CDATA_SECTION_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"cdata \");\n-        break;\n-    case XML_ENTITY_REF_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"&%s; \", cur->name);\n-        break;\n-    case XML_PI_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"pi(%s) \", cur->name);\n-        break;\n-    case XML_COMMENT_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"comment \");\n-        break;\n-    case XML_ATTRIBUTE_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"?attr? \");\n-        break;\n-    case XML_ENTITY_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"?ent? \");\n-        break;\n-    case XML_DOCUMENT_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"?doc? \");\n-        break;\n-    case XML_DOCUMENT_TYPE_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"?doctype? \");\n-        break;\n-    case XML_DOCUMENT_FRAG_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"?frag? \");\n-        break;\n-    case XML_NOTATION_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"?nota? \");\n-        break;\n-    case XML_HTML_DOCUMENT_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"?html? \");\n-        break;\n+        case XML_ELEMENT_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"%s \", cur->name);\n+            break;\n+        case XML_TEXT_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"text \");\n+            break;\n+        case XML_CDATA_SECTION_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"cdata \");\n+            break;\n+        case XML_ENTITY_REF_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"&%s; \", cur->name);\n+            break;\n+        case XML_PI_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"pi(%s) \", cur->name);\n+            break;\n+        case XML_COMMENT_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"comment \");\n+            break;\n+        case XML_ATTRIBUTE_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"?attr? \");\n+            break;\n+        case XML_ENTITY_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"?ent? \");\n+            break;\n+        case XML_DOCUMENT_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"?doc? \");\n+            break;\n+        case XML_DOCUMENT_TYPE_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"?doctype? \");\n+            break;\n+        case XML_DOCUMENT_FRAG_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"?frag? \");\n+            break;\n+        case XML_NOTATION_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"?nota? \");\n+            break;\n+        case XML_HTML_DOCUMENT_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"?html? \");\n+            break;\n@@ -530,3 +530,3 @@\n-    case XML_DOCB_DOCUMENT_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"?docb? \");\n-        break;\n+        case XML_DOCB_DOCUMENT_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"?docb? \");\n+            break;\n@@ -534,21 +534,21 @@\n-    case XML_DTD_NODE:\n-        xmlGenericError(xmlGenericErrorContext, \"?dtd? \");\n-        break;\n-    case XML_ELEMENT_DECL:\n-        xmlGenericError(xmlGenericErrorContext, \"?edecl? \");\n-        break;\n-    case XML_ATTRIBUTE_DECL:\n-        xmlGenericError(xmlGenericErrorContext, \"?adecl? \");\n-        break;\n-    case XML_ENTITY_DECL:\n-        xmlGenericError(xmlGenericErrorContext, \"?entdecl? \");\n-        break;\n-    case XML_NAMESPACE_DECL:\n-        xmlGenericError(xmlGenericErrorContext, \"?nsdecl? \");\n-        break;\n-    case XML_XINCLUDE_START:\n-        xmlGenericError(xmlGenericErrorContext, \"incstart \");\n-        break;\n-    case XML_XINCLUDE_END:\n-        xmlGenericError(xmlGenericErrorContext, \"incend \");\n-        break;\n+        case XML_DTD_NODE:\n+            xmlGenericError(xmlGenericErrorContext, \"?dtd? \");\n+            break;\n+        case XML_ELEMENT_DECL:\n+            xmlGenericError(xmlGenericErrorContext, \"?edecl? \");\n+            break;\n+        case XML_ATTRIBUTE_DECL:\n+            xmlGenericError(xmlGenericErrorContext, \"?adecl? \");\n+            break;\n+        case XML_ENTITY_DECL:\n+            xmlGenericError(xmlGenericErrorContext, \"?entdecl? \");\n+            break;\n+        case XML_NAMESPACE_DECL:\n+            xmlGenericError(xmlGenericErrorContext, \"?nsdecl? \");\n+            break;\n+        case XML_XINCLUDE_START:\n+            xmlGenericError(xmlGenericErrorContext, \"incstart \");\n+            break;\n+        case XML_XINCLUDE_END:\n+            xmlGenericError(xmlGenericErrorContext, \"incend \");\n+            break;\n@@ -561,1 +561,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"null \");\n+        xmlGenericError(xmlGenericErrorContext, \"null \");\n@@ -563,2 +563,2 @@\n-    xmlValidPrintNode(cur);\n-    cur = cur->next;\n+        xmlValidPrintNode(cur);\n+        cur = cur->next;\n@@ -584,1 +584,1 @@\n-    xmlGenericError(xmlGenericErrorContext, \"null,\");\n+        xmlGenericError(xmlGenericErrorContext, \"null,\");\n@@ -586,1 +586,1 @@\n-    switch (state->cont->type) {\n+        switch (state->cont->type) {\n@@ -588,2 +588,2 @@\n-        xmlGenericError(xmlGenericErrorContext, \"pcdata,\");\n-        break;\n+                xmlGenericError(xmlGenericErrorContext, \"pcdata,\");\n+                break;\n@@ -591,3 +591,3 @@\n-        xmlGenericError(xmlGenericErrorContext, \"%s,\",\n-                    state->cont->name);\n-        break;\n+                xmlGenericError(xmlGenericErrorContext, \"%s,\",\n+                                state->cont->name);\n+                break;\n@@ -595,2 +595,2 @@\n-        xmlGenericError(xmlGenericErrorContext, \"seq,\");\n-        break;\n+                xmlGenericError(xmlGenericErrorContext, \"seq,\");\n+                break;\n@@ -598,3 +598,3 @@\n-        xmlGenericError(xmlGenericErrorContext, \"or,\");\n-        break;\n-    }\n+                xmlGenericError(xmlGenericErrorContext, \"or,\");\n+                break;\n+        }\n@@ -603,1 +603,1 @@\n-        state->depth, state->occurs, state->state);\n+            state->depth, state->occurs, state->state);\n@@ -613,1 +613,1 @@\n-        ctxt->vstateNr - 1);\n+            ctxt->vstateNr - 1);\n@@ -615,1 +615,1 @@\n-    xmlValidDebugState(&ctxt->vstateTab[j]);\n+        xmlValidDebugState(&ctxt->vstateTab[j]);\n@@ -624,1 +624,1 @@\n-#define DEBUG_VALID_MSG(m)                  \\\n+#define DEBUG_VALID_MSG(m)                                      \\\n@@ -635,4 +635,4 @@\n-#define CHECK_DTD                       \\\n-   if (doc == NULL) return(0);                  \\\n-   else if ((doc->intSubset == NULL) &&             \\\n-        (doc->extSubset == NULL)) return(0)\n+#define CHECK_DTD                                               \\\n+   if (doc == NULL) return(0);                                  \\\n+   else if ((doc->intSubset == NULL) &&                         \\\n+            (doc->extSubset == NULL)) return(0)\n@@ -643,3 +643,3 @@\n- *                                  *\n- *      Content model validation based on the regexps       *\n- *                                  *\n+ *                                                                      *\n+ *              Content model validation based on the regexps           *\n+ *                                                                      *\n@@ -660,2 +660,2 @@\n-                   xmlValidCtxtPtr ctxt,\n-                   const xmlChar *name) {\n+                           xmlValidCtxtPtr ctxt,\n+                           const xmlChar *name) {\n@@ -663,7 +663,0 @@\n-    xmlErrValidNode(ctxt, NULL, XML_ERR_INTERNAL_ERROR,\n-            \"Found NULL content in content model of %s\\n\",\n-            name, NULL, NULL);\n-    return(0);\n-    }\n-    switch (content->type) {\n-    case XML_ELEMENT_CONTENT_PCDATA:\n@@ -671,2 +664,2 @@\n-                \"Found PCDATA in content model of %s\\n\",\n-                    name, NULL, NULL);\n+                        \"Found NULL content in content model of %s\\n\",\n+                        name, NULL, NULL);\n@@ -674,5 +667,12 @@\n-        break;\n-    case XML_ELEMENT_CONTENT_ELEMENT: {\n-        xmlAutomataStatePtr oldstate = ctxt->state;\n-        xmlChar fn[50];\n-        xmlChar *fullname;\n+    }\n+    switch (content->type) {\n+        case XML_ELEMENT_CONTENT_PCDATA:\n+            xmlErrValidNode(ctxt, NULL, XML_ERR_INTERNAL_ERROR,\n+                            \"Found PCDATA in content model of %s\\n\",\n+                            name, NULL, NULL);\n+            return(0);\n+            break;\n+        case XML_ELEMENT_CONTENT_ELEMENT: {\n+            xmlAutomataStatePtr oldstate = ctxt->state;\n+            xmlChar fn[50];\n+            xmlChar *fullname;\n@@ -680,5 +680,5 @@\n-        fullname = xmlBuildQName(content->name, content->prefix, fn, 50);\n-        if (fullname == NULL) {\n-            xmlVErrMemory(ctxt, \"Building content model\");\n-        return(0);\n-        }\n+            fullname = xmlBuildQName(content->name, content->prefix, fn, 50);\n+            if (fullname == NULL) {\n+                xmlVErrMemory(ctxt, \"Building content model\");\n+                return(0);\n+            }\n@@ -686,21 +686,25 @@\n-        switch (content->ocur) {\n-        case XML_ELEMENT_CONTENT_ONCE:\n-            ctxt->state = xmlAutomataNewTransition(ctxt->am,\n-                ctxt->state, NULL, fullname, NULL);\n-            break;\n-        case XML_ELEMENT_CONTENT_OPT:\n-            ctxt->state = xmlAutomataNewTransition(ctxt->am,\n-                ctxt->state, NULL, fullname, NULL);\n-            xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n-            break;\n-        case XML_ELEMENT_CONTENT_PLUS:\n-            ctxt->state = xmlAutomataNewTransition(ctxt->am,\n-                ctxt->state, NULL, fullname, NULL);\n-            xmlAutomataNewTransition(ctxt->am, ctxt->state,\n-                                 ctxt->state, fullname, NULL);\n-            break;\n-        case XML_ELEMENT_CONTENT_MULT:\n-            ctxt->state = xmlAutomataNewEpsilon(ctxt->am,\n-                        ctxt->state, NULL);\n-            xmlAutomataNewTransition(ctxt->am,\n-                ctxt->state, ctxt->state, fullname, NULL);\n+            switch (content->ocur) {\n+                case XML_ELEMENT_CONTENT_ONCE:\n+                    ctxt->state = xmlAutomataNewTransition(ctxt->am,\n+                            ctxt->state, NULL, fullname, NULL);\n+                    break;\n+                case XML_ELEMENT_CONTENT_OPT:\n+                    ctxt->state = xmlAutomataNewTransition(ctxt->am,\n+                            ctxt->state, NULL, fullname, NULL);\n+                    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n+                    break;\n+                case XML_ELEMENT_CONTENT_PLUS:\n+                    ctxt->state = xmlAutomataNewTransition(ctxt->am,\n+                            ctxt->state, NULL, fullname, NULL);\n+                    xmlAutomataNewTransition(ctxt->am, ctxt->state,\n+                                             ctxt->state, fullname, NULL);\n+                    break;\n+                case XML_ELEMENT_CONTENT_MULT:\n+                    ctxt->state = xmlAutomataNewEpsilon(ctxt->am,\n+                                            ctxt->state, NULL);\n+                    xmlAutomataNewTransition(ctxt->am,\n+                            ctxt->state, ctxt->state, fullname, NULL);\n+                    break;\n+            }\n+            if ((fullname != fn) && (fullname != content->name))\n+                xmlFree(fullname);\n@@ -709,7 +713,3 @@\n-        if ((fullname != fn) && (fullname != content->name))\n-        xmlFree(fullname);\n-        break;\n-    }\n-    case XML_ELEMENT_CONTENT_SEQ: {\n-        xmlAutomataStatePtr oldstate, oldend;\n-        xmlElementContentOccur ocur;\n+        case XML_ELEMENT_CONTENT_SEQ: {\n+            xmlAutomataStatePtr oldstate, oldend;\n+            xmlElementContentOccur ocur;\n@@ -717,29 +717,31 @@\n-        \/*\n-         * Simply iterate over the content\n-         *\/\n-        oldstate = ctxt->state;\n-        ocur = content->ocur;\n-        if (ocur != XML_ELEMENT_CONTENT_ONCE) {\n-        ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);\n-        oldstate = ctxt->state;\n-        }\n-        do {\n-        xmlValidBuildAContentModel(content->c1, ctxt, name);\n-        content = content->c2;\n-        } while ((content->type == XML_ELEMENT_CONTENT_SEQ) &&\n-             (content->ocur == XML_ELEMENT_CONTENT_ONCE));\n-        xmlValidBuildAContentModel(content, ctxt, name);\n-        oldend = ctxt->state;\n-        ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);\n-        switch (ocur) {\n-        case XML_ELEMENT_CONTENT_ONCE:\n-            break;\n-        case XML_ELEMENT_CONTENT_OPT:\n-            xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n-            break;\n-        case XML_ELEMENT_CONTENT_MULT:\n-            xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n-            xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n-            break;\n-        case XML_ELEMENT_CONTENT_PLUS:\n-            xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n+            \/*\n+             * Simply iterate over the content\n+             *\/\n+            oldstate = ctxt->state;\n+            ocur = content->ocur;\n+            if (ocur != XML_ELEMENT_CONTENT_ONCE) {\n+                ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldstate, NULL);\n+                oldstate = ctxt->state;\n+            }\n+            do {\n+                xmlValidBuildAContentModel(content->c1, ctxt, name);\n+                content = content->c2;\n+            } while ((content->type == XML_ELEMENT_CONTENT_SEQ) &&\n+                     (content->ocur == XML_ELEMENT_CONTENT_ONCE));\n+            xmlValidBuildAContentModel(content, ctxt, name);\n+            oldend = ctxt->state;\n+            ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);\n+            switch (ocur) {\n+                case XML_ELEMENT_CONTENT_ONCE:\n+                    break;\n+                case XML_ELEMENT_CONTENT_OPT:\n+                    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n+                    break;\n+                case XML_ELEMENT_CONTENT_MULT:\n+                    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n+                    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n+                    break;\n+                case XML_ELEMENT_CONTENT_PLUS:\n+                    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n+                    break;\n+            }\n@@ -748,14 +750,12 @@\n-        break;\n-    }\n-    case XML_ELEMENT_CONTENT_OR: {\n-        xmlAutomataStatePtr oldstate, oldend;\n-        xmlElementContentOccur ocur;\n-\n-        ocur = content->ocur;\n-        if ((ocur == XML_ELEMENT_CONTENT_PLUS) ||\n-        (ocur == XML_ELEMENT_CONTENT_MULT)) {\n-        ctxt->state = xmlAutomataNewEpsilon(ctxt->am,\n-            ctxt->state, NULL);\n-        }\n-        oldstate = ctxt->state;\n-        oldend = xmlAutomataNewState(ctxt->am);\n+        case XML_ELEMENT_CONTENT_OR: {\n+            xmlAutomataStatePtr oldstate, oldend;\n+            xmlElementContentOccur ocur;\n+\n+            ocur = content->ocur;\n+            if ((ocur == XML_ELEMENT_CONTENT_PLUS) ||\n+                (ocur == XML_ELEMENT_CONTENT_MULT)) {\n+                ctxt->state = xmlAutomataNewEpsilon(ctxt->am,\n+                        ctxt->state, NULL);\n+            }\n+            oldstate = ctxt->state;\n+            oldend = xmlAutomataNewState(ctxt->am);\n@@ -763,27 +763,29 @@\n-        \/*\n-         * iterate over the subtypes and remerge the end with an\n-         * epsilon transition\n-         *\/\n-        do {\n-        ctxt->state = oldstate;\n-        xmlValidBuildAContentModel(content->c1, ctxt, name);\n-        xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);\n-        content = content->c2;\n-        } while ((content->type == XML_ELEMENT_CONTENT_OR) &&\n-             (content->ocur == XML_ELEMENT_CONTENT_ONCE));\n-        ctxt->state = oldstate;\n-        xmlValidBuildAContentModel(content, ctxt, name);\n-        xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);\n-        ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);\n-        switch (ocur) {\n-        case XML_ELEMENT_CONTENT_ONCE:\n-            break;\n-        case XML_ELEMENT_CONTENT_OPT:\n-            xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n-            break;\n-        case XML_ELEMENT_CONTENT_MULT:\n-            xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n-            xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n-            break;\n-        case XML_ELEMENT_CONTENT_PLUS:\n-            xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n+            \/*\n+             * iterate over the subtypes and remerge the end with an\n+             * epsilon transition\n+             *\/\n+            do {\n+                ctxt->state = oldstate;\n+                xmlValidBuildAContentModel(content->c1, ctxt, name);\n+                xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);\n+                content = content->c2;\n+            } while ((content->type == XML_ELEMENT_CONTENT_OR) &&\n+                     (content->ocur == XML_ELEMENT_CONTENT_ONCE));\n+            ctxt->state = oldstate;\n+            xmlValidBuildAContentModel(content, ctxt, name);\n+            xmlAutomataNewEpsilon(ctxt->am, ctxt->state, oldend);\n+            ctxt->state = xmlAutomataNewEpsilon(ctxt->am, oldend, NULL);\n+            switch (ocur) {\n+                case XML_ELEMENT_CONTENT_ONCE:\n+                    break;\n+                case XML_ELEMENT_CONTENT_OPT:\n+                    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n+                    break;\n+                case XML_ELEMENT_CONTENT_MULT:\n+                    xmlAutomataNewEpsilon(ctxt->am, oldstate, ctxt->state);\n+                    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n+                    break;\n+                case XML_ELEMENT_CONTENT_PLUS:\n+                    xmlAutomataNewEpsilon(ctxt->am, oldend, oldstate);\n+                    break;\n+            }\n@@ -792,7 +794,5 @@\n-        break;\n-    }\n-    default:\n-        xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n-                    \"ContentModel broken for element %s\\n\",\n-            (const char *) name);\n-        return(0);\n+        default:\n+            xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"ContentModel broken for element %s\\n\",\n+                        (const char *) name);\n+            return(0);\n@@ -816,1 +816,1 @@\n-    return(0);\n+        return(0);\n@@ -818,1 +818,1 @@\n-    return(0);\n+        return(0);\n@@ -820,1 +820,1 @@\n-    return(1);\n+        return(1);\n@@ -823,5 +823,5 @@\n-    if (!xmlRegexpIsDeterminist(elem->contModel)) {\n-        ctxt->valid = 0;\n-        return(0);\n-    }\n-    return(1);\n+        if (!xmlRegexpIsDeterminist(elem->contModel)) {\n+            ctxt->valid = 0;\n+            return(0);\n+        }\n+        return(1);\n@@ -832,5 +832,5 @@\n-    xmlErrValidNode(ctxt, (xmlNodePtr) elem,\n-                    XML_ERR_INTERNAL_ERROR,\n-                    \"Cannot create automata for element %s\\n\",\n-                elem->name, NULL, NULL);\n-    return(0);\n+        xmlErrValidNode(ctxt, (xmlNodePtr) elem,\n+                        XML_ERR_INTERNAL_ERROR,\n+                        \"Cannot create automata for element %s\\n\",\n+                        elem->name, NULL, NULL);\n+        return(0);\n@@ -843,7 +843,7 @@\n-    char expr[5000];\n-    expr[0] = 0;\n-    xmlSnprintfElementContent(expr, 5000, elem->content, 1);\n-    xmlErrValidNode(ctxt, (xmlNodePtr) elem,\n-                    XML_DTD_CONTENT_NOT_DETERMINIST,\n-           \"Content model of %s is not determinist: %s\\n\",\n-           elem->name, BAD_CAST expr, NULL);\n+        char expr[5000];\n+        expr[0] = 0;\n+        xmlSnprintfElementContent(expr, 5000, elem->content, 1);\n+        xmlErrValidNode(ctxt, (xmlNodePtr) elem,\n+                        XML_DTD_CONTENT_NOT_DETERMINIST,\n+               \"Content model of %s is not determinist: %s\\n\",\n+               elem->name, BAD_CAST expr, NULL);\n@@ -854,4 +854,4 @@\n-    ctxt->state = NULL;\n-    xmlFreeAutomata(ctxt->am);\n-    ctxt->am = NULL;\n-    return(0);\n+        ctxt->state = NULL;\n+        xmlFreeAutomata(ctxt->am);\n+        ctxt->am = NULL;\n+        return(0);\n@@ -868,3 +868,3 @@\n- *                              *\n- *  Util functions for data allocation\/deallocation     *\n- *                              *\n+ *                                                              *\n+ *      Util functions for data allocation\/deallocation         *\n+ *                                                              *\n@@ -884,2 +884,2 @@\n-    xmlVErrMemory(NULL, \"malloc failed\");\n-    return (NULL);\n+        xmlVErrMemory(NULL, \"malloc failed\");\n+        return (NULL);\n@@ -930,7 +930,7 @@\n-    case XML_ELEMENT_CONTENT_ELEMENT:\n-        if (name == NULL) {\n-            xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n-            \"xmlNewElementContent : name == NULL !\\n\",\n-            NULL);\n-        }\n-        break;\n+        case XML_ELEMENT_CONTENT_ELEMENT:\n+            if (name == NULL) {\n+                xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n+                        \"xmlNewElementContent : name == NULL !\\n\",\n+                        NULL);\n+            }\n+            break;\n@@ -938,3 +938,9 @@\n-    case XML_ELEMENT_CONTENT_SEQ:\n-    case XML_ELEMENT_CONTENT_OR:\n-        if (name != NULL) {\n+        case XML_ELEMENT_CONTENT_SEQ:\n+        case XML_ELEMENT_CONTENT_OR:\n+            if (name != NULL) {\n+                xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n+                        \"xmlNewElementContent : name != NULL !\\n\",\n+                        NULL);\n+            }\n+            break;\n+        default:\n@@ -942,9 +948,3 @@\n-            \"xmlNewElementContent : name != NULL !\\n\",\n-            NULL);\n-        }\n-        break;\n-    default:\n-        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n-            \"Internal: ELEMENT content corrupted invalid type\\n\",\n-            NULL);\n-        return(NULL);\n+                    \"Internal: ELEMENT content corrupted invalid type\\n\",\n+                    NULL);\n+            return(NULL);\n@@ -954,2 +954,2 @@\n-    xmlVErrMemory(NULL, \"malloc failed\");\n-    return(NULL);\n+        xmlVErrMemory(NULL, \"malloc failed\");\n+        return(NULL);\n@@ -962,1 +962,1 @@\n-    const xmlChar *tmp;\n+        const xmlChar *tmp;\n@@ -964,10 +964,6 @@\n-    tmp = xmlSplitQName3(name, &l);\n-    if (tmp == NULL) {\n-        if (dict == NULL)\n-        ret->name = xmlStrdup(name);\n-        else\n-            ret->name = xmlDictLookup(dict, name, -1);\n-    } else {\n-        if (dict == NULL) {\n-        ret->prefix = xmlStrndup(name, l);\n-        ret->name = xmlStrdup(tmp);\n+        tmp = xmlSplitQName3(name, &l);\n+        if (tmp == NULL) {\n+            if (dict == NULL)\n+                ret->name = xmlStrdup(name);\n+            else\n+                ret->name = xmlDictLookup(dict, name, -1);\n@@ -975,2 +971,7 @@\n-            ret->prefix = xmlDictLookup(dict, name, l);\n-        ret->name = xmlDictLookup(dict, tmp, -1);\n+            if (dict == NULL) {\n+                ret->prefix = xmlStrndup(name, l);\n+                ret->name = xmlStrdup(tmp);\n+            } else {\n+                ret->prefix = xmlDictLookup(dict, name, l);\n+                ret->name = xmlDictLookup(dict, tmp, -1);\n+            }\n@@ -979,1 +980,0 @@\n-    }\n@@ -1019,2 +1019,2 @@\n-    xmlVErrMemory(NULL, \"malloc failed\");\n-    return(NULL);\n+        xmlVErrMemory(NULL, \"malloc failed\");\n+        return(NULL);\n@@ -1026,4 +1026,4 @@\n-    if (dict)\n-        ret->name = xmlDictLookup(dict, cur->name, -1);\n-    else\n-        ret->name = xmlStrdup(cur->name);\n+        if (dict)\n+            ret->name = xmlDictLookup(dict, cur->name, -1);\n+        else\n+            ret->name = xmlStrdup(cur->name);\n@@ -1033,4 +1033,4 @@\n-    if (dict)\n-        ret->prefix = xmlDictLookup(dict, cur->prefix, -1);\n-    else\n-        ret->prefix = xmlStrdup(cur->prefix);\n+        if (dict)\n+            ret->prefix = xmlDictLookup(dict, cur->prefix, -1);\n+        else\n+            ret->prefix = xmlStrdup(cur->prefix);\n@@ -1041,1 +1041,1 @@\n-    ret->c1->parent = ret;\n+        ret->c1->parent = ret;\n@@ -1044,17 +1044,18 @@\n-    cur = cur->c2;\n-    while (cur != NULL) {\n-        tmp = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));\n-        if (tmp == NULL) {\n-        xmlVErrMemory(NULL, \"malloc failed\");\n-        return(ret);\n-        }\n-        memset(tmp, 0, sizeof(xmlElementContent));\n-        tmp->type = cur->type;\n-        tmp->ocur = cur->ocur;\n-        prev->c2 = tmp;\n-        if (cur->name != NULL) {\n-        if (dict)\n-            tmp->name = xmlDictLookup(dict, cur->name, -1);\n-        else\n-            tmp->name = xmlStrdup(cur->name);\n-        }\n+        cur = cur->c2;\n+        while (cur != NULL) {\n+            tmp = (xmlElementContentPtr) xmlMalloc(sizeof(xmlElementContent));\n+            if (tmp == NULL) {\n+                xmlVErrMemory(NULL, \"malloc failed\");\n+                return(ret);\n+            }\n+            memset(tmp, 0, sizeof(xmlElementContent));\n+            tmp->type = cur->type;\n+            tmp->ocur = cur->ocur;\n+            prev->c2 = tmp;\n+            tmp->parent = prev;\n+            if (cur->name != NULL) {\n+                if (dict)\n+                    tmp->name = xmlDictLookup(dict, cur->name, -1);\n+                else\n+                    tmp->name = xmlStrdup(cur->name);\n+            }\n@@ -1062,5 +1063,12 @@\n-        if (cur->prefix != NULL) {\n-        if (dict)\n-            tmp->prefix = xmlDictLookup(dict, cur->prefix, -1);\n-        else\n-            tmp->prefix = xmlStrdup(cur->prefix);\n+            if (cur->prefix != NULL) {\n+                if (dict)\n+                    tmp->prefix = xmlDictLookup(dict, cur->prefix, -1);\n+                else\n+                    tmp->prefix = xmlStrdup(cur->prefix);\n+            }\n+            if (cur->c1 != NULL)\n+                tmp->c1 = xmlCopyDocElementContent(doc,cur->c1);\n+            if (tmp->c1 != NULL)\n+                tmp->c1->parent = ret;\n+            prev = tmp;\n+            cur = cur->c2;\n@@ -1068,7 +1076,0 @@\n-        if (cur->c1 != NULL)\n-            tmp->c1 = xmlCopyDocElementContent(doc,cur->c1);\n-        if (tmp->c1 != NULL)\n-        tmp->c1->parent = ret;\n-        prev = tmp;\n-        cur = cur->c2;\n-    }\n@@ -1118,21 +1119,21 @@\n-    switch (cur->type) {\n-        case XML_ELEMENT_CONTENT_PCDATA:\n-        case XML_ELEMENT_CONTENT_ELEMENT:\n-        case XML_ELEMENT_CONTENT_SEQ:\n-        case XML_ELEMENT_CONTENT_OR:\n-        break;\n-        default:\n-        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n-            \"Internal: ELEMENT content corrupted invalid type\\n\",\n-            NULL);\n-        return;\n-    }\n-    if (dict) {\n-        if ((cur->name != NULL) && (!xmlDictOwns(dict, cur->name)))\n-            xmlFree((xmlChar *) cur->name);\n-        if ((cur->prefix != NULL) && (!xmlDictOwns(dict, cur->prefix)))\n-            xmlFree((xmlChar *) cur->prefix);\n-    } else {\n-        if (cur->name != NULL) xmlFree((xmlChar *) cur->name);\n-        if (cur->prefix != NULL) xmlFree((xmlChar *) cur->prefix);\n-    }\n+        switch (cur->type) {\n+            case XML_ELEMENT_CONTENT_PCDATA:\n+            case XML_ELEMENT_CONTENT_ELEMENT:\n+            case XML_ELEMENT_CONTENT_SEQ:\n+            case XML_ELEMENT_CONTENT_OR:\n+                break;\n+            default:\n+                xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n+                        \"Internal: ELEMENT content corrupted invalid type\\n\",\n+                        NULL);\n+                return;\n+        }\n+        if (dict) {\n+            if ((cur->name != NULL) && (!xmlDictOwns(dict, cur->name)))\n+                xmlFree((xmlChar *) cur->name);\n+            if ((cur->prefix != NULL) && (!xmlDictOwns(dict, cur->prefix)))\n+                xmlFree((xmlChar *) cur->prefix);\n+        } else {\n+            if (cur->name != NULL) xmlFree((xmlChar *) cur->name);\n+            if (cur->prefix != NULL) xmlFree((xmlChar *) cur->prefix);\n+        }\n@@ -1148,1 +1149,1 @@\n-    xmlFree(cur);\n+        xmlFree(cur);\n@@ -1151,1 +1152,1 @@\n-        cur = parent->c2;\n+            cur = parent->c2;\n@@ -1281,2 +1282,2 @@\n-                     xmlElementContentPtr content ATTRIBUTE_UNUSED,\n-             int englob ATTRIBUTE_UNUSED) {\n+                         xmlElementContentPtr content ATTRIBUTE_UNUSED,\n+                         int englob ATTRIBUTE_UNUSED) {\n@@ -1303,3 +1304,3 @@\n-    if ((size - len > 4) && (buf[len - 1] != '.'))\n-        strcat(buf, \" ...\");\n-    return;\n+        if ((size - len > 4) && (buf[len - 1] != '.'))\n+            strcat(buf, \" ...\");\n+        return;\n@@ -1311,2 +1312,2 @@\n-        break;\n-    case XML_ELEMENT_CONTENT_ELEMENT: {\n+            break;\n+        case XML_ELEMENT_CONTENT_ELEMENT: {\n@@ -1315,1 +1316,1 @@\n-        if (content->prefix != NULL)\n+            if (content->prefix != NULL)\n@@ -1317,23 +1318,11 @@\n-        if (size - len < qnameLen + 10) {\n-        strcat(buf, \" ...\");\n-        return;\n-        }\n-        if (content->prefix != NULL) {\n-        strcat(buf, (char *) content->prefix);\n-        strcat(buf, \":\");\n-        }\n-        if (content->name != NULL)\n-        strcat(buf, (char *) content->name);\n-        break;\n-        }\n-    case XML_ELEMENT_CONTENT_SEQ:\n-        if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n-            (content->c1->type == XML_ELEMENT_CONTENT_SEQ))\n-        xmlSnprintfElementContent(buf, size, content->c1, 1);\n-        else\n-        xmlSnprintfElementContent(buf, size, content->c1, 0);\n-        len = strlen(buf);\n-        if (size - len < 50) {\n-        if ((size - len > 4) && (buf[len - 1] != '.'))\n-            strcat(buf, \" ...\");\n-        return;\n+            if (size - len < qnameLen + 10) {\n+                strcat(buf, \" ...\");\n+                return;\n+            }\n+            if (content->prefix != NULL) {\n+                strcat(buf, (char *) content->prefix);\n+                strcat(buf, \":\");\n+            }\n+            if (content->name != NULL)\n+                strcat(buf, (char *) content->name);\n+            break;\n@@ -1341,0 +1330,12 @@\n+        case XML_ELEMENT_CONTENT_SEQ:\n+            if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n+                (content->c1->type == XML_ELEMENT_CONTENT_SEQ))\n+                xmlSnprintfElementContent(buf, size, content->c1, 1);\n+            else\n+                xmlSnprintfElementContent(buf, size, content->c1, 0);\n+            len = strlen(buf);\n+            if (size - len < 50) {\n+                if ((size - len > 4) && (buf[len - 1] != '.'))\n+                    strcat(buf, \" ...\");\n+                return;\n+            }\n@@ -1342,19 +1343,19 @@\n-        if (((content->c2->type == XML_ELEMENT_CONTENT_OR) ||\n-         (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&\n-        (content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))\n-        xmlSnprintfElementContent(buf, size, content->c2, 1);\n-        else\n-        xmlSnprintfElementContent(buf, size, content->c2, 0);\n-        break;\n-    case XML_ELEMENT_CONTENT_OR:\n-        if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n-            (content->c1->type == XML_ELEMENT_CONTENT_SEQ))\n-        xmlSnprintfElementContent(buf, size, content->c1, 1);\n-        else\n-        xmlSnprintfElementContent(buf, size, content->c1, 0);\n-        len = strlen(buf);\n-        if (size - len < 50) {\n-        if ((size - len > 4) && (buf[len - 1] != '.'))\n-            strcat(buf, \" ...\");\n-        return;\n-        }\n+            if (((content->c2->type == XML_ELEMENT_CONTENT_OR) ||\n+                 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&\n+                (content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))\n+                xmlSnprintfElementContent(buf, size, content->c2, 1);\n+            else\n+                xmlSnprintfElementContent(buf, size, content->c2, 0);\n+            break;\n+        case XML_ELEMENT_CONTENT_OR:\n+            if ((content->c1->type == XML_ELEMENT_CONTENT_OR) ||\n+                (content->c1->type == XML_ELEMENT_CONTENT_SEQ))\n+                xmlSnprintfElementContent(buf, size, content->c1, 1);\n+            else\n+                xmlSnprintfElementContent(buf, size, content->c1, 0);\n+            len = strlen(buf);\n+            if (size - len < 50) {\n+                if ((size - len > 4) && (buf[len - 1] != '.'))\n+                    strcat(buf, \" ...\");\n+                return;\n+            }\n@@ -1362,7 +1363,7 @@\n-        if (((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||\n-         (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&\n-        (content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))\n-        xmlSnprintfElementContent(buf, size, content->c2, 1);\n-        else\n-        xmlSnprintfElementContent(buf, size, content->c2, 0);\n-        break;\n+            if (((content->c2->type == XML_ELEMENT_CONTENT_SEQ) ||\n+                 (content->c2->ocur != XML_ELEMENT_CONTENT_ONCE)) &&\n+                (content->c2->type != XML_ELEMENT_CONTENT_ELEMENT))\n+                xmlSnprintfElementContent(buf, size, content->c2, 1);\n+            else\n+                xmlSnprintfElementContent(buf, size, content->c2, 0);\n+            break;\n@@ -1375,1 +1376,1 @@\n-        break;\n+            break;\n@@ -1377,2 +1378,2 @@\n-        strcat(buf, \"?\");\n-        break;\n+            strcat(buf, \"?\");\n+            break;\n@@ -1380,2 +1381,2 @@\n-        strcat(buf, \"*\");\n-        break;\n+            strcat(buf, \"*\");\n+            break;\n@@ -1383,2 +1384,2 @@\n-        strcat(buf, \"+\");\n-        break;\n+            strcat(buf, \"+\");\n+            break;\n@@ -1389,3 +1390,3 @@\n- *                              *\n- *  Registration of DTD declarations            *\n- *                              *\n+ *                                                              *\n+ *      Registration of DTD declarations                        *\n+ *                                                              *\n@@ -1406,1 +1407,1 @@\n-    xmlFree((xmlChar *) elem->name);\n+        xmlFree((xmlChar *) elem->name);\n@@ -1408,1 +1409,1 @@\n-    xmlFree((xmlChar *) elem->prefix);\n+        xmlFree((xmlChar *) elem->prefix);\n@@ -1411,1 +1412,1 @@\n-    xmlRegFreeRegexp(elem->contModel);\n+        xmlRegFreeRegexp(elem->contModel);\n@@ -1433,1 +1434,1 @@\n-          xmlElementContentPtr content) {\n+                  xmlElementContentPtr content) {\n@@ -1440,1 +1441,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1443,1 +1444,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1448,36 +1449,36 @@\n-        if (content != NULL) {\n-        xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n-                \"xmlAddElementDecl: content != NULL for EMPTY\\n\",\n-            NULL);\n-        return(NULL);\n-        }\n-        break;\n-    case XML_ELEMENT_TYPE_ANY:\n-        if (content != NULL) {\n-        xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n-                \"xmlAddElementDecl: content != NULL for ANY\\n\",\n-            NULL);\n-        return(NULL);\n-        }\n-        break;\n-    case XML_ELEMENT_TYPE_MIXED:\n-        if (content == NULL) {\n-        xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n-                \"xmlAddElementDecl: content == NULL for MIXED\\n\",\n-            NULL);\n-        return(NULL);\n-        }\n-        break;\n-    case XML_ELEMENT_TYPE_ELEMENT:\n-        if (content == NULL) {\n-        xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n-                \"xmlAddElementDecl: content == NULL for ELEMENT\\n\",\n-            NULL);\n-        return(NULL);\n-        }\n-        break;\n-    default:\n-        xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n-            \"Internal: ELEMENT decl corrupted invalid type\\n\",\n-            NULL);\n-        return(NULL);\n+            if (content != NULL) {\n+                xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"xmlAddElementDecl: content != NULL for EMPTY\\n\",\n+                        NULL);\n+                return(NULL);\n+            }\n+            break;\n+        case XML_ELEMENT_TYPE_ANY:\n+            if (content != NULL) {\n+                xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"xmlAddElementDecl: content != NULL for ANY\\n\",\n+                        NULL);\n+                return(NULL);\n+            }\n+            break;\n+        case XML_ELEMENT_TYPE_MIXED:\n+            if (content == NULL) {\n+                xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"xmlAddElementDecl: content == NULL for MIXED\\n\",\n+                        NULL);\n+                return(NULL);\n+            }\n+            break;\n+        case XML_ELEMENT_TYPE_ELEMENT:\n+            if (content == NULL) {\n+                xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n+                        \"xmlAddElementDecl: content == NULL for ELEMENT\\n\",\n+                        NULL);\n+                return(NULL);\n+            }\n+            break;\n+        default:\n+            xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n+                    \"Internal: ELEMENT decl corrupted invalid type\\n\",\n+                    NULL);\n+            return(NULL);\n@@ -1491,1 +1492,1 @@\n-    name = uqname;\n+        name = uqname;\n@@ -1498,1 +1499,1 @@\n-    xmlDictPtr dict = NULL;\n+        xmlDictPtr dict = NULL;\n@@ -1500,2 +1501,2 @@\n-    if (dtd->doc != NULL)\n-        dict = dtd->doc->dict;\n+        if (dtd->doc != NULL)\n+            dict = dtd->doc->dict;\n@@ -1503,1 +1504,1 @@\n-    dtd->elements = (void *) table;\n+        dtd->elements = (void *) table;\n@@ -1506,1 +1507,1 @@\n-    xmlVErrMemory(ctxt,\n+        xmlVErrMemory(ctxt,\n@@ -1508,4 +1509,4 @@\n-    if (uqname != NULL)\n-        xmlFree(uqname);\n-    if (ns != NULL)\n-        xmlFree(ns);\n+        if (uqname != NULL)\n+            xmlFree(uqname);\n+        if (ns != NULL)\n+            xmlFree(ns);\n@@ -1520,7 +1521,7 @@\n-    ret = xmlHashLookup2(dtd->doc->intSubset->elements, name, ns);\n-    if ((ret != NULL) && (ret->etype == XML_ELEMENT_TYPE_UNDEFINED)) {\n-        oldAttributes = ret->attributes;\n-        ret->attributes = NULL;\n-        xmlHashRemoveEntry2(dtd->doc->intSubset->elements, name, ns, NULL);\n-        xmlFreeElement(ret);\n-    }\n+        ret = xmlHashLookup2(dtd->doc->intSubset->elements, name, ns);\n+        if ((ret != NULL) && (ret->etype == XML_ELEMENT_TYPE_UNDEFINED)) {\n+            oldAttributes = ret->attributes;\n+            ret->attributes = NULL;\n+            xmlHashRemoveEntry2(dtd->doc->intSubset->elements, name, ns, NULL);\n+            xmlFreeElement(ret);\n+        }\n@@ -1535,1 +1536,1 @@\n-    if (ret->etype != XML_ELEMENT_TYPE_UNDEFINED) {\n+        if (ret->etype != XML_ELEMENT_TYPE_UNDEFINED) {\n@@ -1537,6 +1538,6 @@\n-        \/*\n-         * The element is already defined in this DTD.\n-         *\/\n-        xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,\n-                        \"Redefinition of element %s\\n\",\n-                name, NULL, NULL);\n+            \/*\n+             * The element is already defined in this DTD.\n+             *\/\n+            xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,\n+                            \"Redefinition of element %s\\n\",\n+                            name, NULL, NULL);\n@@ -1544,2 +1545,2 @@\n-        if (uqname != NULL)\n-        xmlFree(uqname);\n+            if (uqname != NULL)\n+                xmlFree(uqname);\n@@ -1547,0 +1548,4 @@\n+                xmlFree(ns);\n+            return(NULL);\n+        }\n+        if (ns != NULL) {\n@@ -1548,6 +1553,2 @@\n-        return(NULL);\n-    }\n-    if (ns != NULL) {\n-        xmlFree(ns);\n-        ns = NULL;\n-    }\n+            ns = NULL;\n+        }\n@@ -1555,5 +1556,5 @@\n-    ret = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\n-    if (ret == NULL) {\n-        xmlVErrMemory(ctxt, \"malloc failed\");\n-        if (uqname != NULL)\n-        xmlFree(uqname);\n+        ret = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\n+        if (ret == NULL) {\n+            xmlVErrMemory(ctxt, \"malloc failed\");\n+            if (uqname != NULL)\n+                xmlFree(uqname);\n@@ -1561,5 +1562,5 @@\n-            xmlFree(ns);\n-        return(NULL);\n-    }\n-    memset(ret, 0, sizeof(xmlElement));\n-    ret->type = XML_ELEMENT_DECL;\n+                xmlFree(ns);\n+            return(NULL);\n+        }\n+        memset(ret, 0, sizeof(xmlElement));\n+        ret->type = XML_ELEMENT_DECL;\n@@ -1567,8 +1568,8 @@\n-    \/*\n-     * fill the structure.\n-     *\/\n-    ret->name = xmlStrdup(name);\n-    if (ret->name == NULL) {\n-        xmlVErrMemory(ctxt, \"malloc failed\");\n-        if (uqname != NULL)\n-        xmlFree(uqname);\n+        \/*\n+         * fill the structure.\n+         *\/\n+        ret->name = xmlStrdup(name);\n+        if (ret->name == NULL) {\n+            xmlVErrMemory(ctxt, \"malloc failed\");\n+            if (uqname != NULL)\n+                xmlFree(uqname);\n@@ -1576,5 +1577,5 @@\n-            xmlFree(ns);\n-        xmlFree(ret);\n-        return(NULL);\n-    }\n-    ret->prefix = ns;\n+                xmlFree(ns);\n+            xmlFree(ret);\n+            return(NULL);\n+        }\n+        ret->prefix = ns;\n@@ -1582,6 +1583,0 @@\n-    \/*\n-     * Validity Check:\n-     * Insertion must not fail\n-     *\/\n-    if (xmlHashAddEntry2(table, name, ns, ret)) {\n-#ifdef LIBXML_VALID_ENABLED\n@@ -1589,1 +1584,2 @@\n-         * The element is already defined in this DTD.\n+         * Validity Check:\n+         * Insertion must not fail\n@@ -1591,3 +1587,8 @@\n-        xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,\n-                        \"Redefinition of element %s\\n\",\n-                name, NULL, NULL);\n+        if (xmlHashAddEntry2(table, name, ns, ret)) {\n+#ifdef LIBXML_VALID_ENABLED\n+            \/*\n+             * The element is already defined in this DTD.\n+             *\/\n+            xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ELEM_REDEFINED,\n+                            \"Redefinition of element %s\\n\",\n+                            name, NULL, NULL);\n@@ -1595,10 +1596,10 @@\n-        xmlFreeElement(ret);\n-        if (uqname != NULL)\n-        xmlFree(uqname);\n-        return(NULL);\n-    }\n-    \/*\n-     * For new element, may have attributes from earlier\n-     * definition in internal subset\n-     *\/\n-    ret->attributes = oldAttributes;\n+            xmlFreeElement(ret);\n+            if (uqname != NULL)\n+                xmlFree(uqname);\n+            return(NULL);\n+        }\n+        \/*\n+         * For new element, may have attributes from earlier\n+         * definition in internal subset\n+         *\/\n+        ret->attributes = oldAttributes;\n@@ -1619,3 +1620,3 @@\n-    ret->content = content;\n-    if (content != NULL)\n-        content->parent = (xmlElementContentPtr) 1;\n+        ret->content = content;\n+        if (content != NULL)\n+            content->parent = (xmlElementContentPtr) 1;\n@@ -1623,1 +1624,1 @@\n-    ret->content = xmlCopyDocElementContent(dtd->doc, content);\n+        ret->content = xmlCopyDocElementContent(dtd->doc, content);\n@@ -1632,1 +1633,1 @@\n-    dtd->children = dtd->last = (xmlNodePtr) ret;\n+        dtd->children = dtd->last = (xmlNodePtr) ret;\n@@ -1635,2 +1636,2 @@\n-    ret->prev = dtd->last;\n-    dtd->last = (xmlNodePtr) ret;\n+        ret->prev = dtd->last;\n+        dtd->last = (xmlNodePtr) ret;\n@@ -1639,1 +1640,1 @@\n-    xmlFree(uqname);\n+        xmlFree(uqname);\n@@ -1675,2 +1676,2 @@\n-    xmlVErrMemory(NULL, \"malloc failed\");\n-    return(NULL);\n+        xmlVErrMemory(NULL, \"malloc failed\");\n+        return(NULL);\n@@ -1682,1 +1683,1 @@\n-    cur->name = xmlStrdup(elem->name);\n+        cur->name = xmlStrdup(elem->name);\n@@ -1684,1 +1685,1 @@\n-    cur->name = NULL;\n+        cur->name = NULL;\n@@ -1686,1 +1687,1 @@\n-    cur->prefix = xmlStrdup(elem->prefix);\n+        cur->prefix = xmlStrdup(elem->prefix);\n@@ -1688,1 +1689,1 @@\n-    cur->prefix = NULL;\n+        cur->prefix = NULL;\n@@ -1723,44 +1724,44 @@\n-    case XML_ELEMENT_TYPE_EMPTY:\n-        xmlBufferWriteChar(buf, \"<!ELEMENT \");\n-        if (elem->prefix != NULL) {\n-        xmlBufferWriteCHAR(buf, elem->prefix);\n-        xmlBufferWriteChar(buf, \":\");\n-        }\n-        xmlBufferWriteCHAR(buf, elem->name);\n-        xmlBufferWriteChar(buf, \" EMPTY>\\n\");\n-        break;\n-    case XML_ELEMENT_TYPE_ANY:\n-        xmlBufferWriteChar(buf, \"<!ELEMENT \");\n-        if (elem->prefix != NULL) {\n-        xmlBufferWriteCHAR(buf, elem->prefix);\n-        xmlBufferWriteChar(buf, \":\");\n-        }\n-        xmlBufferWriteCHAR(buf, elem->name);\n-        xmlBufferWriteChar(buf, \" ANY>\\n\");\n-        break;\n-    case XML_ELEMENT_TYPE_MIXED:\n-        xmlBufferWriteChar(buf, \"<!ELEMENT \");\n-        if (elem->prefix != NULL) {\n-        xmlBufferWriteCHAR(buf, elem->prefix);\n-        xmlBufferWriteChar(buf, \":\");\n-        }\n-        xmlBufferWriteCHAR(buf, elem->name);\n-        xmlBufferWriteChar(buf, \" \");\n-        xmlDumpElementContent(buf, elem->content);\n-        xmlBufferWriteChar(buf, \">\\n\");\n-        break;\n-    case XML_ELEMENT_TYPE_ELEMENT:\n-        xmlBufferWriteChar(buf, \"<!ELEMENT \");\n-        if (elem->prefix != NULL) {\n-        xmlBufferWriteCHAR(buf, elem->prefix);\n-        xmlBufferWriteChar(buf, \":\");\n-        }\n-        xmlBufferWriteCHAR(buf, elem->name);\n-        xmlBufferWriteChar(buf, \" \");\n-        xmlDumpElementContent(buf, elem->content);\n-        xmlBufferWriteChar(buf, \">\\n\");\n-        break;\n-    default:\n-        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n-            \"Internal: ELEMENT struct corrupted invalid type\\n\",\n-            NULL);\n+        case XML_ELEMENT_TYPE_EMPTY:\n+            xmlBufferWriteChar(buf, \"<!ELEMENT \");\n+            if (elem->prefix != NULL) {\n+                xmlBufferWriteCHAR(buf, elem->prefix);\n+                xmlBufferWriteChar(buf, \":\");\n+            }\n+            xmlBufferWriteCHAR(buf, elem->name);\n+            xmlBufferWriteChar(buf, \" EMPTY>\\n\");\n+            break;\n+        case XML_ELEMENT_TYPE_ANY:\n+            xmlBufferWriteChar(buf, \"<!ELEMENT \");\n+            if (elem->prefix != NULL) {\n+                xmlBufferWriteCHAR(buf, elem->prefix);\n+                xmlBufferWriteChar(buf, \":\");\n+            }\n+            xmlBufferWriteCHAR(buf, elem->name);\n+            xmlBufferWriteChar(buf, \" ANY>\\n\");\n+            break;\n+        case XML_ELEMENT_TYPE_MIXED:\n+            xmlBufferWriteChar(buf, \"<!ELEMENT \");\n+            if (elem->prefix != NULL) {\n+                xmlBufferWriteCHAR(buf, elem->prefix);\n+                xmlBufferWriteChar(buf, \":\");\n+            }\n+            xmlBufferWriteCHAR(buf, elem->name);\n+            xmlBufferWriteChar(buf, \" \");\n+            xmlDumpElementContent(buf, elem->content);\n+            xmlBufferWriteChar(buf, \">\\n\");\n+            break;\n+        case XML_ELEMENT_TYPE_ELEMENT:\n+            xmlBufferWriteChar(buf, \"<!ELEMENT \");\n+            if (elem->prefix != NULL) {\n+                xmlBufferWriteCHAR(buf, elem->prefix);\n+                xmlBufferWriteChar(buf, \":\");\n+            }\n+            xmlBufferWriteCHAR(buf, elem->name);\n+            xmlBufferWriteChar(buf, \" \");\n+            xmlDumpElementContent(buf, elem->content);\n+            xmlBufferWriteChar(buf, \">\\n\");\n+            break;\n+        default:\n+            xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n+                    \"Internal: ELEMENT struct corrupted invalid type\\n\",\n+                    NULL);\n@@ -1814,1 +1815,1 @@\n-    xmlVErrMemory(NULL, \"malloc failed\");\n+        xmlVErrMemory(NULL, \"malloc failed\");\n@@ -1880,1 +1881,1 @@\n-    xmlBufferWriteChar(buf, \")\");\n+        xmlBufferWriteChar(buf, \")\");\n@@ -1882,2 +1883,2 @@\n-    xmlBufferWriteChar(buf, \" | \");\n-    xmlDumpEnumeration(buf, cur->next);\n+        xmlBufferWriteChar(buf, \" | \");\n+        xmlDumpEnumeration(buf, cur->next);\n@@ -1909,7 +1910,7 @@\n-        ret ++;\n-        if ((ret > 1) && (err))\n-        xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_MULTIPLE_ID,\n-           \"Element %s has too many ID attributes defined : %s\\n\",\n-               elem->name, cur->name, NULL);\n-    }\n-    cur = cur->nexth;\n+            ret ++;\n+            if ((ret > 1) && (err))\n+                xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_MULTIPLE_ID,\n+               \"Element %s has too many ID attributes defined : %s\\n\",\n+                       elem->name, cur->name, NULL);\n+        }\n+        cur = cur->nexth;\n@@ -1933,1 +1934,1 @@\n-    dict = attr->doc->dict;\n+        dict = attr->doc->dict;\n@@ -1935,1 +1936,1 @@\n-    dict = NULL;\n+        dict = NULL;\n@@ -1941,1 +1942,1 @@\n-        xmlFree((xmlChar *) attr->elem);\n+            xmlFree((xmlChar *) attr->elem);\n@@ -1943,1 +1944,1 @@\n-        xmlFree((xmlChar *) attr->name);\n+            xmlFree((xmlChar *) attr->name);\n@@ -1945,1 +1946,1 @@\n-        xmlFree((xmlChar *) attr->prefix);\n+            xmlFree((xmlChar *) attr->prefix);\n@@ -1947,2 +1948,2 @@\n-        (!xmlDictOwns(dict, attr->defaultValue)))\n-        xmlFree((xmlChar *) attr->defaultValue);\n+            (!xmlDictOwns(dict, attr->defaultValue)))\n+            xmlFree((xmlChar *) attr->defaultValue);\n@@ -1950,8 +1951,8 @@\n-    if (attr->elem != NULL)\n-        xmlFree((xmlChar *) attr->elem);\n-    if (attr->name != NULL)\n-        xmlFree((xmlChar *) attr->name);\n-    if (attr->defaultValue != NULL)\n-        xmlFree((xmlChar *) attr->defaultValue);\n-    if (attr->prefix != NULL)\n-        xmlFree((xmlChar *) attr->prefix);\n+        if (attr->elem != NULL)\n+            xmlFree((xmlChar *) attr->elem);\n+        if (attr->name != NULL)\n+            xmlFree((xmlChar *) attr->name);\n+        if (attr->defaultValue != NULL)\n+            xmlFree((xmlChar *) attr->defaultValue);\n+        if (attr->prefix != NULL)\n+            xmlFree((xmlChar *) attr->prefix);\n@@ -1984,2 +1985,2 @@\n-            xmlAttributeType type, xmlAttributeDefault def,\n-            const xmlChar *defaultValue, xmlEnumerationPtr tree) {\n+                    xmlAttributeType type, xmlAttributeDefault def,\n+                    const xmlChar *defaultValue, xmlEnumerationPtr tree) {\n@@ -1992,2 +1993,2 @@\n-    xmlFreeEnumeration(tree);\n-    return(NULL);\n+        xmlFreeEnumeration(tree);\n+        return(NULL);\n@@ -1996,2 +1997,2 @@\n-    xmlFreeEnumeration(tree);\n-    return(NULL);\n+        xmlFreeEnumeration(tree);\n+        return(NULL);\n@@ -2000,2 +2001,2 @@\n-    xmlFreeEnumeration(tree);\n-    return(NULL);\n+        xmlFreeEnumeration(tree);\n+        return(NULL);\n@@ -2004,1 +2005,1 @@\n-    dict = dtd->doc->dict;\n+        dict = dtd->doc->dict;\n@@ -2012,1 +2013,1 @@\n-        break;\n+            break;\n@@ -2014,1 +2015,1 @@\n-        break;\n+            break;\n@@ -2016,1 +2017,1 @@\n-        break;\n+            break;\n@@ -2018,1 +2019,1 @@\n-        break;\n+            break;\n@@ -2020,1 +2021,1 @@\n-        break;\n+            break;\n@@ -2022,1 +2023,1 @@\n-        break;\n+            break;\n@@ -2024,1 +2025,1 @@\n-        break;\n+            break;\n@@ -2026,1 +2027,1 @@\n-        break;\n+            break;\n@@ -2028,1 +2029,1 @@\n-        break;\n+            break;\n@@ -2030,7 +2031,7 @@\n-        break;\n-    default:\n-        xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n-            \"Internal: ATTRIBUTE struct corrupted invalid type\\n\",\n-            NULL);\n-        xmlFreeEnumeration(tree);\n-        return(NULL);\n+            break;\n+        default:\n+            xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n+                    \"Internal: ATTRIBUTE struct corrupted invalid type\\n\",\n+                    NULL);\n+            xmlFreeEnumeration(tree);\n+            return(NULL);\n@@ -2040,6 +2041,6 @@\n-    xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_DEFAULT,\n-                    \"Attribute %s of %s: invalid default value\\n\",\n-                    elem, name, defaultValue);\n-    defaultValue = NULL;\n-    if (ctxt != NULL)\n-        ctxt->valid = 0;\n+        xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_DEFAULT,\n+                        \"Attribute %s of %s: invalid default value\\n\",\n+                        elem, name, defaultValue);\n+        defaultValue = NULL;\n+        if (ctxt != NULL)\n+            ctxt->valid = 0;\n@@ -2054,2 +2055,2 @@\n-    (dtd->doc->intSubset != NULL) &&\n-    (dtd->doc->intSubset->attributes != NULL)) {\n+        (dtd->doc->intSubset != NULL) &&\n+        (dtd->doc->intSubset->attributes != NULL)) {\n@@ -2057,4 +2058,4 @@\n-    if (ret != NULL) {\n-        xmlFreeEnumeration(tree);\n-        return(NULL);\n-    }\n+        if (ret != NULL) {\n+            xmlFreeEnumeration(tree);\n+            return(NULL);\n+        }\n@@ -2069,1 +2070,1 @@\n-    dtd->attributes = (void *) table;\n+        dtd->attributes = (void *) table;\n@@ -2072,1 +2073,1 @@\n-    xmlVErrMemory(ctxt,\n+        xmlVErrMemory(ctxt,\n@@ -2074,1 +2075,1 @@\n-    xmlFreeEnumeration(tree);\n+        xmlFreeEnumeration(tree);\n@@ -2081,3 +2082,3 @@\n-    xmlVErrMemory(ctxt, \"malloc failed\");\n-    xmlFreeEnumeration(tree);\n-    return(NULL);\n+        xmlVErrMemory(ctxt, \"malloc failed\");\n+        xmlFreeEnumeration(tree);\n+        return(NULL);\n@@ -2099,3 +2100,3 @@\n-    ret->name = xmlDictLookup(dict, name, -1);\n-    ret->prefix = xmlDictLookup(dict, ns, -1);\n-    ret->elem = xmlDictLookup(dict, elem, -1);\n+        ret->name = xmlDictLookup(dict, name, -1);\n+        ret->prefix = xmlDictLookup(dict, ns, -1);\n+        ret->elem = xmlDictLookup(dict, elem, -1);\n@@ -2103,3 +2104,3 @@\n-    ret->name = xmlStrdup(name);\n-    ret->prefix = xmlStrdup(ns);\n-    ret->elem = xmlStrdup(elem);\n+        ret->name = xmlStrdup(name);\n+        ret->prefix = xmlStrdup(ns);\n+        ret->elem = xmlStrdup(elem);\n@@ -2111,3 +2112,3 @@\n-        ret->defaultValue = xmlDictLookup(dict, defaultValue, -1);\n-    else\n-        ret->defaultValue = xmlStrdup(defaultValue);\n+            ret->defaultValue = xmlDictLookup(dict, defaultValue, -1);\n+        else\n+            ret->defaultValue = xmlStrdup(defaultValue);\n@@ -2122,6 +2123,6 @@\n-    \/*\n-     * The attribute is already defined in this DTD.\n-     *\/\n-    xmlErrValidWarning(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_REDEFINED,\n-         \"Attribute %s of element %s: already defined\\n\",\n-         name, elem, NULL);\n+        \/*\n+         * The attribute is already defined in this DTD.\n+         *\/\n+        xmlErrValidWarning(ctxt, (xmlNodePtr) dtd, XML_DTD_ATTRIBUTE_REDEFINED,\n+                 \"Attribute %s of element %s: already defined\\n\",\n+                 name, elem, NULL);\n@@ -2129,2 +2130,2 @@\n-    xmlFreeAttribute(ret);\n-    return(NULL);\n+        xmlFreeAttribute(ret);\n+        return(NULL);\n@@ -2142,7 +2143,7 @@\n-        (xmlScanIDAttributeDecl(NULL, elemDef, 1) != 0)) {\n-        xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_MULTIPLE_ID,\n-       \"Element %s has too may ID attributes defined : %s\\n\",\n-           elem, name, NULL);\n-        if (ctxt != NULL)\n-        ctxt->valid = 0;\n-    }\n+            (xmlScanIDAttributeDecl(NULL, elemDef, 1) != 0)) {\n+            xmlErrValidNode(ctxt, (xmlNodePtr) dtd, XML_DTD_MULTIPLE_ID,\n+           \"Element %s has too may ID attributes defined : %s\\n\",\n+                   elem, name, NULL);\n+            if (ctxt != NULL)\n+                ctxt->valid = 0;\n+        }\n@@ -2151,14 +2152,5 @@\n-    \/*\n-     * Insert namespace default def first they need to be\n-     * processed first.\n-     *\/\n-    if ((xmlStrEqual(ret->name, BAD_CAST \"xmlns\")) ||\n-        ((ret->prefix != NULL &&\n-         (xmlStrEqual(ret->prefix, BAD_CAST \"xmlns\"))))) {\n-        ret->nexth = elemDef->attributes;\n-        elemDef->attributes = ret;\n-    } else {\n-        xmlAttributePtr tmp = elemDef->attributes;\n-\n-        while ((tmp != NULL) &&\n-           ((xmlStrEqual(tmp->name, BAD_CAST \"xmlns\")) ||\n+        \/*\n+         * Insert namespace default def first they need to be\n+         * processed first.\n+         *\/\n+        if ((xmlStrEqual(ret->name, BAD_CAST \"xmlns\")) ||\n@@ -2166,8 +2158,3 @@\n-             (xmlStrEqual(ret->prefix, BAD_CAST \"xmlns\")))))) {\n-        if (tmp->nexth == NULL)\n-            break;\n-        tmp = tmp->nexth;\n-        }\n-        if (tmp != NULL) {\n-        ret->nexth = tmp->nexth;\n-            tmp->nexth = ret;\n+             (xmlStrEqual(ret->prefix, BAD_CAST \"xmlns\"))))) {\n+            ret->nexth = elemDef->attributes;\n+            elemDef->attributes = ret;\n@@ -2175,5 +2162,1 @@\n-        ret->nexth = elemDef->attributes;\n-        elemDef->attributes = ret;\n-        }\n-    }\n-    }\n+            xmlAttributePtr tmp = elemDef->attributes;\n@@ -2181,1 +2164,19 @@\n-    \/*\n+            while ((tmp != NULL) &&\n+                   ((xmlStrEqual(tmp->name, BAD_CAST \"xmlns\")) ||\n+                    ((ret->prefix != NULL &&\n+                     (xmlStrEqual(ret->prefix, BAD_CAST \"xmlns\")))))) {\n+                if (tmp->nexth == NULL)\n+                    break;\n+                tmp = tmp->nexth;\n+            }\n+            if (tmp != NULL) {\n+                ret->nexth = tmp->nexth;\n+                tmp->nexth = ret;\n+            } else {\n+                ret->nexth = elemDef->attributes;\n+                elemDef->attributes = ret;\n+            }\n+        }\n+    }\n+\n+    \/*\n@@ -2186,1 +2187,1 @@\n-    dtd->children = dtd->last = (xmlNodePtr) ret;\n+        dtd->children = dtd->last = (xmlNodePtr) ret;\n@@ -2189,2 +2190,2 @@\n-    ret->prev = dtd->last;\n-    dtd->last = (xmlNodePtr) ret;\n+        ret->prev = dtd->last;\n+        dtd->last = (xmlNodePtr) ret;\n@@ -2227,2 +2228,2 @@\n-    xmlVErrMemory(NULL, \"malloc failed\");\n-    return(NULL);\n+        xmlVErrMemory(NULL, \"malloc failed\");\n+        return(NULL);\n@@ -2236,1 +2237,1 @@\n-    cur->elem = xmlStrdup(attr->elem);\n+        cur->elem = xmlStrdup(attr->elem);\n@@ -2238,1 +2239,1 @@\n-    cur->name = xmlStrdup(attr->name);\n+        cur->name = xmlStrdup(attr->name);\n@@ -2240,1 +2241,1 @@\n-    cur->prefix = xmlStrdup(attr->prefix);\n+        cur->prefix = xmlStrdup(attr->prefix);\n@@ -2242,1 +2243,1 @@\n-    cur->defaultValue = xmlStrdup(attr->defaultValue);\n+        cur->defaultValue = xmlStrdup(attr->defaultValue);\n@@ -2277,2 +2278,2 @@\n-    xmlBufferWriteCHAR(buf, attr->prefix);\n-    xmlBufferWriteChar(buf, \":\");\n+        xmlBufferWriteCHAR(buf, attr->prefix);\n+        xmlBufferWriteChar(buf, \":\");\n@@ -2282,36 +2283,36 @@\n-    case XML_ATTRIBUTE_CDATA:\n-        xmlBufferWriteChar(buf, \" CDATA\");\n-        break;\n-    case XML_ATTRIBUTE_ID:\n-        xmlBufferWriteChar(buf, \" ID\");\n-        break;\n-    case XML_ATTRIBUTE_IDREF:\n-        xmlBufferWriteChar(buf, \" IDREF\");\n-        break;\n-    case XML_ATTRIBUTE_IDREFS:\n-        xmlBufferWriteChar(buf, \" IDREFS\");\n-        break;\n-    case XML_ATTRIBUTE_ENTITY:\n-        xmlBufferWriteChar(buf, \" ENTITY\");\n-        break;\n-    case XML_ATTRIBUTE_ENTITIES:\n-        xmlBufferWriteChar(buf, \" ENTITIES\");\n-        break;\n-    case XML_ATTRIBUTE_NMTOKEN:\n-        xmlBufferWriteChar(buf, \" NMTOKEN\");\n-        break;\n-    case XML_ATTRIBUTE_NMTOKENS:\n-        xmlBufferWriteChar(buf, \" NMTOKENS\");\n-        break;\n-    case XML_ATTRIBUTE_ENUMERATION:\n-        xmlBufferWriteChar(buf, \" (\");\n-        xmlDumpEnumeration(buf, attr->tree);\n-        break;\n-    case XML_ATTRIBUTE_NOTATION:\n-        xmlBufferWriteChar(buf, \" NOTATION (\");\n-        xmlDumpEnumeration(buf, attr->tree);\n-        break;\n-    default:\n-        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n-            \"Internal: ATTRIBUTE struct corrupted invalid type\\n\",\n-            NULL);\n+        case XML_ATTRIBUTE_CDATA:\n+            xmlBufferWriteChar(buf, \" CDATA\");\n+            break;\n+        case XML_ATTRIBUTE_ID:\n+            xmlBufferWriteChar(buf, \" ID\");\n+            break;\n+        case XML_ATTRIBUTE_IDREF:\n+            xmlBufferWriteChar(buf, \" IDREF\");\n+            break;\n+        case XML_ATTRIBUTE_IDREFS:\n+            xmlBufferWriteChar(buf, \" IDREFS\");\n+            break;\n+        case XML_ATTRIBUTE_ENTITY:\n+            xmlBufferWriteChar(buf, \" ENTITY\");\n+            break;\n+        case XML_ATTRIBUTE_ENTITIES:\n+            xmlBufferWriteChar(buf, \" ENTITIES\");\n+            break;\n+        case XML_ATTRIBUTE_NMTOKEN:\n+            xmlBufferWriteChar(buf, \" NMTOKEN\");\n+            break;\n+        case XML_ATTRIBUTE_NMTOKENS:\n+            xmlBufferWriteChar(buf, \" NMTOKENS\");\n+            break;\n+        case XML_ATTRIBUTE_ENUMERATION:\n+            xmlBufferWriteChar(buf, \" (\");\n+            xmlDumpEnumeration(buf, attr->tree);\n+            break;\n+        case XML_ATTRIBUTE_NOTATION:\n+            xmlBufferWriteChar(buf, \" NOTATION (\");\n+            xmlDumpEnumeration(buf, attr->tree);\n+            break;\n+        default:\n+            xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n+                    \"Internal: ATTRIBUTE struct corrupted invalid type\\n\",\n+                    NULL);\n@@ -2320,15 +2321,15 @@\n-    case XML_ATTRIBUTE_NONE:\n-        break;\n-    case XML_ATTRIBUTE_REQUIRED:\n-        xmlBufferWriteChar(buf, \" #REQUIRED\");\n-        break;\n-    case XML_ATTRIBUTE_IMPLIED:\n-        xmlBufferWriteChar(buf, \" #IMPLIED\");\n-        break;\n-    case XML_ATTRIBUTE_FIXED:\n-        xmlBufferWriteChar(buf, \" #FIXED\");\n-        break;\n-    default:\n-        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n-            \"Internal: ATTRIBUTE struct corrupted invalid def\\n\",\n-            NULL);\n+        case XML_ATTRIBUTE_NONE:\n+            break;\n+        case XML_ATTRIBUTE_REQUIRED:\n+            xmlBufferWriteChar(buf, \" #REQUIRED\");\n+            break;\n+        case XML_ATTRIBUTE_IMPLIED:\n+            xmlBufferWriteChar(buf, \" #IMPLIED\");\n+            break;\n+        case XML_ATTRIBUTE_FIXED:\n+            xmlBufferWriteChar(buf, \" #FIXED\");\n+            break;\n+        default:\n+            xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n+                    \"Internal: ATTRIBUTE struct corrupted invalid def\\n\",\n+                    NULL);\n@@ -2337,2 +2338,2 @@\n-    xmlBufferWriteChar(buf, \" \");\n-    xmlBufferWriteQuotedString(buf, attr->defaultValue);\n+        xmlBufferWriteChar(buf, \" \");\n+        xmlBufferWriteQuotedString(buf, attr->defaultValue);\n@@ -2372,3 +2373,3 @@\n- *                                  *\n- *              NOTATIONs               *\n- *                                  *\n+ *                                                                      *\n+ *                              NOTATIONs                               *\n+ *                                                                      *\n@@ -2386,1 +2387,1 @@\n-    xmlFree((xmlChar *) nota->name);\n+        xmlFree((xmlChar *) nota->name);\n@@ -2388,1 +2389,1 @@\n-    xmlFree((xmlChar *) nota->PublicID);\n+        xmlFree((xmlChar *) nota->PublicID);\n@@ -2390,1 +2391,1 @@\n-    xmlFree((xmlChar *) nota->SystemID);\n+        xmlFree((xmlChar *) nota->SystemID);\n@@ -2409,1 +2410,1 @@\n-               const xmlChar *name,\n+                   const xmlChar *name,\n@@ -2415,1 +2416,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2418,1 +2419,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2421,1 +2422,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2429,3 +2430,3 @@\n-    xmlDictPtr dict = NULL;\n-    if (dtd->doc != NULL)\n-        dict = dtd->doc->dict;\n+        xmlDictPtr dict = NULL;\n+        if (dtd->doc != NULL)\n+            dict = dtd->doc->dict;\n@@ -2436,2 +2437,2 @@\n-    xmlVErrMemory(ctxt,\n-        \"xmlAddNotationDecl: Table creation failed!\\n\");\n+        xmlVErrMemory(ctxt,\n+                \"xmlAddNotationDecl: Table creation failed!\\n\");\n@@ -2443,2 +2444,2 @@\n-    xmlVErrMemory(ctxt, \"malloc failed\");\n-    return(NULL);\n+        xmlVErrMemory(ctxt, \"malloc failed\");\n+        return(NULL);\n@@ -2463,3 +2464,3 @@\n-    xmlErrValid(NULL, XML_DTD_NOTATION_REDEFINED,\n-            \"xmlAddNotationDecl: %s already defined\\n\",\n-            (const char *) name);\n+        xmlErrValid(NULL, XML_DTD_NOTATION_REDEFINED,\n+                    \"xmlAddNotationDecl: %s already defined\\n\",\n+                    (const char *) name);\n@@ -2467,2 +2468,2 @@\n-    xmlFreeNotation(ret);\n-    return(NULL);\n+        xmlFreeNotation(ret);\n+        return(NULL);\n@@ -2505,2 +2506,2 @@\n-    xmlVErrMemory(NULL, \"malloc failed\");\n-    return(NULL);\n+        xmlVErrMemory(NULL, \"malloc failed\");\n+        return(NULL);\n@@ -2509,1 +2510,1 @@\n-    cur->name = xmlStrdup(nota->name);\n+        cur->name = xmlStrdup(nota->name);\n@@ -2511,1 +2512,1 @@\n-    cur->name = NULL;\n+        cur->name = NULL;\n@@ -2513,1 +2514,1 @@\n-    cur->PublicID = xmlStrdup(nota->PublicID);\n+        cur->PublicID = xmlStrdup(nota->PublicID);\n@@ -2515,1 +2516,1 @@\n-    cur->PublicID = NULL;\n+        cur->PublicID = NULL;\n@@ -2517,1 +2518,1 @@\n-    cur->SystemID = xmlStrdup(nota->SystemID);\n+        cur->SystemID = xmlStrdup(nota->SystemID);\n@@ -2519,1 +2520,1 @@\n-    cur->SystemID = NULL;\n+        cur->SystemID = NULL;\n@@ -2552,6 +2553,6 @@\n-    xmlBufferWriteChar(buf, \" PUBLIC \");\n-    xmlBufferWriteQuotedString(buf, nota->PublicID);\n-    if (nota->SystemID != NULL) {\n-        xmlBufferWriteChar(buf, \" \");\n-        xmlBufferWriteQuotedString(buf, nota->SystemID);\n-    }\n+        xmlBufferWriteChar(buf, \" PUBLIC \");\n+        xmlBufferWriteQuotedString(buf, nota->PublicID);\n+        if (nota->SystemID != NULL) {\n+            xmlBufferWriteChar(buf, \" \");\n+            xmlBufferWriteQuotedString(buf, nota->SystemID);\n+        }\n@@ -2559,2 +2560,2 @@\n-    xmlBufferWriteChar(buf, \" SYSTEM \");\n-    xmlBufferWriteQuotedString(buf, nota->SystemID);\n+        xmlBufferWriteChar(buf, \" SYSTEM \");\n+        xmlBufferWriteQuotedString(buf, nota->SystemID);\n@@ -2594,3 +2595,3 @@\n- *                                  *\n- *              IDs                 *\n- *                                  *\n+ *                                                                      *\n+ *                              IDs                                     *\n+ *                                                                      *\n@@ -2605,4 +2606,4 @@\n-#define DICT_FREE(str)                      \\\n-    if ((str) && ((!dict) ||                \\\n-        (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n-        xmlFree((char *)(str));\n+#define DICT_FREE(str)                                          \\\n+        if ((str) && ((!dict) ||                                \\\n+            (xmlDictOwns(dict, (const xmlChar *)(str)) == 0)))  \\\n+            xmlFree((char *)(str));\n@@ -2628,7 +2629,7 @@\n-    if (*src == 0x20) {\n-        while (*src == 0x20) src++;\n-        if (*src != 0)\n-        *dst++ = 0x20;\n-    } else {\n-        *dst++ = *src++;\n-    }\n+        if (*src == 0x20) {\n+            while (*src == 0x20) src++;\n+            if (*src != 0)\n+                *dst++ = 0x20;\n+        } else {\n+            *dst++ = *src++;\n+        }\n@@ -2673,1 +2674,1 @@\n-    DICT_FREE(id->value)\n+        DICT_FREE(id->value)\n@@ -2675,1 +2676,1 @@\n-    DICT_FREE(id->name)\n+        DICT_FREE(id->name)\n@@ -2698,1 +2699,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2701,1 +2702,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2704,1 +2705,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2715,2 +2716,2 @@\n-    xmlVErrMemory(ctxt,\n-        \"xmlAddID: Table creation failed!\\n\");\n+        xmlVErrMemory(ctxt,\n+                \"xmlAddID: Table creation failed!\\n\");\n@@ -2722,2 +2723,2 @@\n-    xmlVErrMemory(ctxt, \"malloc failed\");\n-    return(NULL);\n+        xmlVErrMemory(ctxt, \"malloc failed\");\n+        return(NULL);\n@@ -2732,8 +2733,8 @@\n-    \/*\n-     * Operating in streaming mode, attr is gonna disappear\n-     *\/\n-    if (doc->dict != NULL)\n-        ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n-    else\n-        ret->name = xmlStrdup(attr->name);\n-    ret->attr = NULL;\n+        \/*\n+         * Operating in streaming mode, attr is gonna disappear\n+         *\/\n+        if (doc->dict != NULL)\n+            ret->name = xmlDictLookup(doc->dict, attr->name, -1);\n+        else\n+            ret->name = xmlStrdup(attr->name);\n+        ret->attr = NULL;\n@@ -2741,2 +2742,2 @@\n-    ret->attr = attr;\n-    ret->name = NULL;\n+        ret->attr = attr;\n+        ret->name = NULL;\n@@ -2748,7 +2749,7 @@\n-    \/*\n-     * The id is already defined in this DTD.\n-     *\/\n-    if (ctxt != NULL) {\n-        xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n-                \"ID %s already defined\\n\", value, NULL, NULL);\n-    }\n+        \/*\n+         * The id is already defined in this DTD.\n+         *\/\n+        if (ctxt != NULL) {\n+            xmlErrValidNode(ctxt, attr->parent, XML_DTD_ID_REDEFINED,\n+                            \"ID %s already defined\\n\", value, NULL, NULL);\n+        }\n@@ -2756,2 +2757,2 @@\n-    xmlFreeID(ret);\n-    return(NULL);\n+        xmlFreeID(ret);\n+        return(NULL);\n@@ -2760,1 +2761,1 @@\n-    attr->atype = XML_ATTRIBUTE_ID;\n+        attr->atype = XML_ATTRIBUTE_ID;\n@@ -2799,1 +2800,1 @@\n-    return(1);\n+        return(1);\n@@ -2803,1 +2804,1 @@\n-    return(0);\n+        return(0);\n@@ -2806,4 +2807,4 @@\n-        ((xmlStrEqual(BAD_CAST \"name\", attr->name)) &&\n-        ((elem == NULL) || (xmlStrEqual(elem->name, BAD_CAST \"a\")))))\n-        return(1);\n-    return(0);\n+            ((xmlStrEqual(BAD_CAST \"name\", attr->name)) &&\n+            ((elem == NULL) || (xmlStrEqual(elem->name, BAD_CAST \"a\")))))\n+            return(1);\n+        return(0);\n@@ -2811,1 +2812,1 @@\n-    return(0);\n+        return(0);\n@@ -2813,1 +2814,1 @@\n-    xmlAttributePtr attrDecl = NULL;\n+        xmlAttributePtr attrDecl = NULL;\n@@ -2815,2 +2816,2 @@\n-    xmlChar felem[50], fattr[50];\n-    xmlChar *fullelemname, *fullattrname;\n+        xmlChar felem[50], fattr[50];\n+        xmlChar *fullelemname, *fullattrname;\n@@ -2818,3 +2819,3 @@\n-    fullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?\n-        xmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :\n-        (xmlChar *)elem->name;\n+        fullelemname = (elem->ns != NULL && elem->ns->prefix != NULL) ?\n+            xmlBuildQName(elem->name, elem->ns->prefix, felem, 50) :\n+            (xmlChar *)elem->name;\n@@ -2822,3 +2823,3 @@\n-    fullattrname = (attr->ns != NULL && attr->ns->prefix != NULL) ?\n-        xmlBuildQName(attr->name, attr->ns->prefix, fattr, 50) :\n-        (xmlChar *)attr->name;\n+        fullattrname = (attr->ns != NULL && attr->ns->prefix != NULL) ?\n+            xmlBuildQName(attr->name, attr->ns->prefix, fattr, 50) :\n+            (xmlChar *)attr->name;\n@@ -2826,7 +2827,7 @@\n-    if (fullelemname != NULL && fullattrname != NULL) {\n-        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullelemname,\n-                                 fullattrname);\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullelemname,\n-                         fullattrname);\n-    }\n+        if (fullelemname != NULL && fullattrname != NULL) {\n+            attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullelemname,\n+                                         fullattrname);\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullelemname,\n+                                             fullattrname);\n+        }\n@@ -2834,4 +2835,4 @@\n-    if ((fullattrname != fattr) && (fullattrname != attr->name))\n-        xmlFree(fullattrname);\n-    if ((fullelemname != felem) && (fullelemname != elem->name))\n-        xmlFree(fullelemname);\n+        if ((fullattrname != fattr) && (fullattrname != attr->name))\n+            xmlFree(fullattrname);\n+        if ((fullelemname != felem) && (fullelemname != elem->name))\n+            xmlFree(fullelemname);\n@@ -2840,1 +2841,1 @@\n-        return(1);\n+            return(1);\n@@ -2899,1 +2900,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2903,1 +2904,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2912,1 +2913,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2914,5 +2915,5 @@\n-    \/*\n-     * We are operating on a stream, return a well known reference\n-     * since the attribute node doesn't exist anymore\n-     *\/\n-    return((xmlAttrPtr) doc);\n+        \/*\n+         * We are operating on a stream, return a well known reference\n+         * since the attribute node doesn't exist anymore\n+         *\/\n+        return((xmlAttrPtr) doc);\n@@ -2924,3 +2925,3 @@\n- *                                  *\n- *              Refs                    *\n- *                                  *\n+ *                                                                      *\n+ *                              Refs                                    *\n+ *                                                                      *\n@@ -2930,2 +2931,2 @@\n-    xmlListPtr l;\n-    xmlAttrPtr ap;\n+        xmlListPtr l;\n+        xmlAttrPtr ap;\n@@ -3045,1 +3046,1 @@\n-    xmlVErrMemory(ctxt,\n+        xmlVErrMemory(ctxt,\n@@ -3052,1 +3053,1 @@\n-    xmlVErrMemory(ctxt, \"malloc failed\");\n+        xmlVErrMemory(ctxt, \"malloc failed\");\n@@ -3061,5 +3062,5 @@\n-    \/*\n-     * Operating in streaming mode, attr is gonna disappear\n-     *\/\n-    ret->name = xmlStrdup(attr->name);\n-    ret->attr = NULL;\n+        \/*\n+         * Operating in streaming mode, attr is gonna disappear\n+         *\/\n+        ret->name = xmlStrdup(attr->name);\n+        ret->attr = NULL;\n@@ -3067,2 +3068,2 @@\n-    ret->name = NULL;\n-    ret->attr = attr;\n+        ret->name = NULL;\n+        ret->attr = attr;\n@@ -3081,4 +3082,4 @@\n-        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n-            \"xmlAddRef: Reference list creation failed!\\n\",\n-            NULL);\n-        goto failed;\n+            xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n+                    \"xmlAddRef: Reference list creation failed!\\n\",\n+                    NULL);\n+            goto failed;\n@@ -3088,4 +3089,4 @@\n-        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n-            \"xmlAddRef: Reference list insertion failed!\\n\",\n-            NULL);\n-        goto failed;\n+            xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n+                    \"xmlAddRef: Reference list insertion failed!\\n\",\n+                    NULL);\n+            goto failed;\n@@ -3095,3 +3096,3 @@\n-    xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n-            \"xmlAddRef: Reference list insertion failed!\\n\",\n-            NULL);\n+        xmlErrValid(NULL, XML_ERR_INTERNAL_ERROR,\n+                    \"xmlAddRef: Reference list insertion failed!\\n\",\n+                    NULL);\n@@ -3104,1 +3105,1 @@\n-        xmlFree((char *)ret->value);\n+            xmlFree((char *)ret->value);\n@@ -3106,1 +3107,1 @@\n-        xmlFree((char *)ret->name);\n+            xmlFree((char *)ret->name);\n@@ -3141,1 +3142,1 @@\n-    if (doc == NULL) return(0);\n+        if (doc == NULL) return(0);\n@@ -3156,1 +3157,1 @@\n-                                 elem->name, attr->name);\n+                                         elem->name, attr->name);\n@@ -3158,4 +3159,4 @@\n-    if ((attrDecl != NULL) &&\n-        (attrDecl->atype == XML_ATTRIBUTE_IDREF ||\n-         attrDecl->atype == XML_ATTRIBUTE_IDREFS))\n-    return(1);\n+        if ((attrDecl != NULL) &&\n+            (attrDecl->atype == XML_ATTRIBUTE_IDREF ||\n+             attrDecl->atype == XML_ATTRIBUTE_IDREFS))\n+        return(1);\n@@ -3251,3 +3252,3 @@\n- *                                  *\n- *      Routines for validity checking              *\n- *                                  *\n+ *                                                                      *\n+ *              Routines for validity checking                          *\n+ *                                                                      *\n@@ -3274,1 +3275,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3304,1 +3305,1 @@\n-    xmlDictPtr dict = NULL;\n+        xmlDictPtr dict = NULL;\n@@ -3306,2 +3307,2 @@\n-    if (dtd->doc != NULL)\n-        dict = dtd->doc->dict;\n+        if (dtd->doc != NULL)\n+            dict = dtd->doc->dict;\n@@ -3309,14 +3310,14 @@\n-    if (!create)\n-        return(NULL);\n-    \/*\n-     * Create the Element table if needed.\n-     *\/\n-    table = (xmlElementTablePtr) dtd->elements;\n-    if (table == NULL) {\n-        table = xmlHashCreateDict(0, dict);\n-        dtd->elements = (void *) table;\n-    }\n-    if (table == NULL) {\n-        xmlVErrMemory(NULL, \"element table allocation failed\");\n-        return(NULL);\n-    }\n+        if (!create)\n+            return(NULL);\n+        \/*\n+         * Create the Element table if needed.\n+         *\/\n+        table = (xmlElementTablePtr) dtd->elements;\n+        if (table == NULL) {\n+            table = xmlHashCreateDict(0, dict);\n+            dtd->elements = (void *) table;\n+        }\n+        if (table == NULL) {\n+            xmlVErrMemory(NULL, \"element table allocation failed\");\n+            return(NULL);\n+        }\n@@ -3331,7 +3332,7 @@\n-    cur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\n-    if (cur == NULL) {\n-        xmlVErrMemory(NULL, \"malloc failed\");\n-        return(NULL);\n-    }\n-    memset(cur, 0, sizeof(xmlElement));\n-    cur->type = XML_ELEMENT_DECL;\n+        cur = (xmlElementPtr) xmlMalloc(sizeof(xmlElement));\n+        if (cur == NULL) {\n+            xmlVErrMemory(NULL, \"malloc failed\");\n+            return(NULL);\n+        }\n+        memset(cur, 0, sizeof(xmlElement));\n+        cur->type = XML_ELEMENT_DECL;\n@@ -3339,6 +3340,6 @@\n-    \/*\n-     * fill the structure.\n-     *\/\n-    cur->name = xmlStrdup(name);\n-    cur->prefix = xmlStrdup(prefix);\n-    cur->etype = XML_ELEMENT_TYPE_UNDEFINED;\n+        \/*\n+         * fill the structure.\n+         *\/\n+        cur->name = xmlStrdup(name);\n+        cur->prefix = xmlStrdup(prefix);\n+        cur->etype = XML_ELEMENT_TYPE_UNDEFINED;\n@@ -3346,1 +3347,1 @@\n-    xmlHashAddEntry2(table, name, prefix, cur);\n+        xmlHashAddEntry2(table, name, prefix, cur);\n@@ -3366,1 +3367,1 @@\n-                  const xmlChar *prefix) {\n+                      const xmlChar *prefix) {\n@@ -3399,1 +3400,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -3404,3 +3405,3 @@\n-    cur = xmlHashLookup3(table, uqname, prefix, elem);\n-    if (prefix != NULL) xmlFree(prefix);\n-    if (uqname != NULL) xmlFree(uqname);\n+        cur = xmlHashLookup3(table, uqname, prefix, elem);\n+        if (prefix != NULL) xmlFree(prefix);\n+        if (uqname != NULL) xmlFree(uqname);\n@@ -3408,1 +3409,1 @@\n-    cur = xmlHashLookup3(table, name, NULL, elem);\n+        cur = xmlHashLookup3(table, name, NULL, elem);\n@@ -3427,1 +3428,1 @@\n-              const xmlChar *prefix) {\n+                  const xmlChar *prefix) {\n@@ -3480,1 +3481,1 @@\n-    notaDecl = xmlGetDtdNotationDesc(doc->extSubset, notationName);\n+        notaDecl = xmlGetDtdNotationDesc(doc->extSubset, notationName);\n@@ -3483,4 +3484,4 @@\n-    xmlErrValidNode(ctxt, (xmlNodePtr) doc, XML_DTD_UNKNOWN_NOTATION,\n-                    \"NOTATION %s is not declared\\n\",\n-                notationName, NULL, NULL);\n-    return(0);\n+        xmlErrValidNode(ctxt, (xmlNodePtr) doc, XML_DTD_UNKNOWN_NOTATION,\n+                        \"NOTATION %s is not declared\\n\",\n+                        notationName, NULL, NULL);\n+        return(0);\n@@ -3511,1 +3512,1 @@\n-    elemDecl = xmlGetDtdElementDesc(doc->extSubset, name);\n+        elemDecl = xmlGetDtdElementDesc(doc->extSubset, name);\n@@ -3514,4 +3515,4 @@\n-    case XML_ELEMENT_TYPE_UNDEFINED:\n-        return(-1);\n-    case XML_ELEMENT_TYPE_ELEMENT:\n-        return(0);\n+        case XML_ELEMENT_TYPE_UNDEFINED:\n+            return(-1);\n+        case XML_ELEMENT_TYPE_ELEMENT:\n+            return(0);\n@@ -3519,7 +3520,7 @@\n-        \/*\n-         * return 1 for EMPTY since we want VC error to pop up\n-         * on <empty>     <\/empty> for example\n-         *\/\n-    case XML_ELEMENT_TYPE_ANY:\n-    case XML_ELEMENT_TYPE_MIXED:\n-        return(1);\n+            \/*\n+             * return 1 for EMPTY since we want VC error to pop up\n+             * on <empty>     <\/empty> for example\n+             *\/\n+        case XML_ELEMENT_TYPE_ANY:\n+        case XML_ELEMENT_TYPE_MIXED:\n+            return(1);\n@@ -3536,19 +3537,19 @@\n-     * Use the new checks of production [4] [4a] amd [5] of the\n-     * Update 5 of XML-1.0\n-     *\/\n-    if (((c >= 'a') && (c <= 'z')) ||\n-        ((c >= 'A') && (c <= 'Z')) ||\n-        (c == '_') || (c == ':') ||\n-        ((c >= 0xC0) && (c <= 0xD6)) ||\n-        ((c >= 0xD8) && (c <= 0xF6)) ||\n-        ((c >= 0xF8) && (c <= 0x2FF)) ||\n-        ((c >= 0x370) && (c <= 0x37D)) ||\n-        ((c >= 0x37F) && (c <= 0x1FFF)) ||\n-        ((c >= 0x200C) && (c <= 0x200D)) ||\n-        ((c >= 0x2070) && (c <= 0x218F)) ||\n-        ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n-        ((c >= 0x3001) && (c <= 0xD7FF)) ||\n-        ((c >= 0xF900) && (c <= 0xFDCF)) ||\n-        ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n-        ((c >= 0x10000) && (c <= 0xEFFFF)))\n-        return(1);\n+         * Use the new checks of production [4] [4a] amd [5] of the\n+         * Update 5 of XML-1.0\n+         *\/\n+        if (((c >= 'a') && (c <= 'z')) ||\n+            ((c >= 'A') && (c <= 'Z')) ||\n+            (c == '_') || (c == ':') ||\n+            ((c >= 0xC0) && (c <= 0xD6)) ||\n+            ((c >= 0xD8) && (c <= 0xF6)) ||\n+            ((c >= 0xF8) && (c <= 0x2FF)) ||\n+            ((c >= 0x370) && (c <= 0x37D)) ||\n+            ((c >= 0x37F) && (c <= 0x1FFF)) ||\n+            ((c >= 0x200C) && (c <= 0x200D)) ||\n+            ((c >= 0x2070) && (c <= 0x218F)) ||\n+            ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n+            ((c >= 0x3001) && (c <= 0xD7FF)) ||\n+            ((c >= 0xF900) && (c <= 0xFDCF)) ||\n+            ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n+            ((c >= 0x10000) && (c <= 0xEFFFF)))\n+            return(1);\n@@ -3557,1 +3558,1 @@\n-        return(1);\n+            return(1);\n@@ -3566,23 +3567,23 @@\n-     * Use the new checks of production [4] [4a] amd [5] of the\n-     * Update 5 of XML-1.0\n-     *\/\n-    if (((c >= 'a') && (c <= 'z')) ||\n-        ((c >= 'A') && (c <= 'Z')) ||\n-        ((c >= '0') && (c <= '9')) || \/* !start *\/\n-        (c == '_') || (c == ':') ||\n-        (c == '-') || (c == '.') || (c == 0xB7) || \/* !start *\/\n-        ((c >= 0xC0) && (c <= 0xD6)) ||\n-        ((c >= 0xD8) && (c <= 0xF6)) ||\n-        ((c >= 0xF8) && (c <= 0x2FF)) ||\n-        ((c >= 0x300) && (c <= 0x36F)) || \/* !start *\/\n-        ((c >= 0x370) && (c <= 0x37D)) ||\n-        ((c >= 0x37F) && (c <= 0x1FFF)) ||\n-        ((c >= 0x200C) && (c <= 0x200D)) ||\n-        ((c >= 0x203F) && (c <= 0x2040)) || \/* !start *\/\n-        ((c >= 0x2070) && (c <= 0x218F)) ||\n-        ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n-        ((c >= 0x3001) && (c <= 0xD7FF)) ||\n-        ((c >= 0xF900) && (c <= 0xFDCF)) ||\n-        ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n-        ((c >= 0x10000) && (c <= 0xEFFFF)))\n-         return(1);\n+         * Use the new checks of production [4] [4a] amd [5] of the\n+         * Update 5 of XML-1.0\n+         *\/\n+        if (((c >= 'a') && (c <= 'z')) ||\n+            ((c >= 'A') && (c <= 'Z')) ||\n+            ((c >= '0') && (c <= '9')) || \/* !start *\/\n+            (c == '_') || (c == ':') ||\n+            (c == '-') || (c == '.') || (c == 0xB7) || \/* !start *\/\n+            ((c >= 0xC0) && (c <= 0xD6)) ||\n+            ((c >= 0xD8) && (c <= 0xF6)) ||\n+            ((c >= 0xF8) && (c <= 0x2FF)) ||\n+            ((c >= 0x300) && (c <= 0x36F)) || \/* !start *\/\n+            ((c >= 0x370) && (c <= 0x37D)) ||\n+            ((c >= 0x37F) && (c <= 0x1FFF)) ||\n+            ((c >= 0x200C) && (c <= 0x200D)) ||\n+            ((c >= 0x203F) && (c <= 0x2040)) || \/* !start *\/\n+            ((c >= 0x2070) && (c <= 0x218F)) ||\n+            ((c >= 0x2C00) && (c <= 0x2FEF)) ||\n+            ((c >= 0x3001) && (c <= 0xD7FF)) ||\n+            ((c >= 0xF900) && (c <= 0xFDCF)) ||\n+            ((c >= 0xFDF0) && (c <= 0xFFFD)) ||\n+            ((c >= 0x10000) && (c <= 0xEFFFF)))\n+             return(1);\n@@ -3592,4 +3593,4 @@\n-        (c == '_') || (c == ':') ||\n-        (IS_COMBINING(c)) ||\n-        (IS_EXTENDER(c)))\n-        return(1);\n+            (c == '_') || (c == ':') ||\n+            (IS_COMBINING(c)) ||\n+            (IS_EXTENDER(c)))\n+            return(1);\n@@ -3620,1 +3621,1 @@\n-    return(0);\n+        return(0);\n@@ -3625,2 +3626,2 @@\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    cur += len;\n+        val = xmlStringCurrentChar(NULL, cur, &len);\n+        cur += len;\n@@ -3669,1 +3670,1 @@\n-    return(0);\n+        return(0);\n@@ -3674,7 +3675,0 @@\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    cur += len;\n-    }\n-\n-    \/* Should not test IS_BLANK(val) here -- see erratum E20*\/\n-    while (val == 0x20) {\n-    while (val == 0x20) {\n@@ -3685,2 +3679,6 @@\n-    if (!xmlIsDocNameStartChar(doc, val))\n-        return(0);\n+    \/* Should not test IS_BLANK(val) here -- see erratum E20*\/\n+    while (val == 0x20) {\n+        while (val == 0x20) {\n+            val = xmlStringCurrentChar(NULL, cur, &len);\n+            cur += len;\n+        }\n@@ -3688,2 +3686,2 @@\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    cur += len;\n+        if (!xmlIsDocNameStartChar(doc, val))\n+            return(0);\n@@ -3691,1 +3689,0 @@\n-    while (xmlIsDocNameChar(doc, val)) {\n@@ -3694,1 +3691,5 @@\n-    }\n+\n+        while (xmlIsDocNameChar(doc, val)) {\n+            val = xmlStringCurrentChar(NULL, cur, &len);\n+            cur += len;\n+        }\n@@ -3739,1 +3740,1 @@\n-    return(0);\n+        return(0);\n@@ -3744,2 +3745,2 @@\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    cur += len;\n+        val = xmlStringCurrentChar(NULL, cur, &len);\n+        cur += len;\n@@ -3792,2 +3793,2 @@\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    cur += len;\n+        val = xmlStringCurrentChar(NULL, cur, &len);\n+        cur += len;\n@@ -3797,1 +3798,1 @@\n-    return(0);\n+        return(0);\n@@ -3800,2 +3801,2 @@\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    cur += len;\n+        val = xmlStringCurrentChar(NULL, cur, &len);\n+        cur += len;\n@@ -3806,1 +3807,9 @@\n-    while (val == 0x20) {\n+        while (val == 0x20) {\n+            val = xmlStringCurrentChar(NULL, cur, &len);\n+            cur += len;\n+        }\n+        if (val == 0) return(1);\n+\n+        if (!xmlIsDocNameChar(doc, val))\n+            return(0);\n+\n@@ -3809,2 +3818,0 @@\n-    }\n-    if (val == 0) return(1);\n@@ -3812,10 +3819,4 @@\n-    if (!xmlIsDocNameChar(doc, val))\n-        return(0);\n-\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    cur += len;\n-\n-    while (xmlIsDocNameChar(doc, val)) {\n-        val = xmlStringCurrentChar(NULL, cur, &len);\n-        cur += len;\n-    }\n+        while (xmlIsDocNameChar(doc, val)) {\n+            val = xmlStringCurrentChar(NULL, cur, &len);\n+            cur += len;\n+        }\n@@ -3883,13 +3884,13 @@\n-    case XML_ATTRIBUTE_ENTITIES:\n-    case XML_ATTRIBUTE_IDREFS:\n-        return(xmlValidateNamesValueInternal(doc, value));\n-    case XML_ATTRIBUTE_ENTITY:\n-    case XML_ATTRIBUTE_IDREF:\n-    case XML_ATTRIBUTE_ID:\n-    case XML_ATTRIBUTE_NOTATION:\n-        return(xmlValidateNameValueInternal(doc, value));\n-    case XML_ATTRIBUTE_NMTOKENS:\n-    case XML_ATTRIBUTE_ENUMERATION:\n-        return(xmlValidateNmtokensValueInternal(doc, value));\n-    case XML_ATTRIBUTE_NMTOKEN:\n-        return(xmlValidateNmtokenValueInternal(doc, value));\n+        case XML_ATTRIBUTE_ENTITIES:\n+        case XML_ATTRIBUTE_IDREFS:\n+            return(xmlValidateNamesValueInternal(doc, value));\n+        case XML_ATTRIBUTE_ENTITY:\n+        case XML_ATTRIBUTE_IDREF:\n+        case XML_ATTRIBUTE_ID:\n+        case XML_ATTRIBUTE_NOTATION:\n+            return(xmlValidateNameValueInternal(doc, value));\n+        case XML_ATTRIBUTE_NMTOKENS:\n+        case XML_ATTRIBUTE_ENUMERATION:\n+            return(xmlValidateNmtokensValueInternal(doc, value));\n+        case XML_ATTRIBUTE_NMTOKEN:\n+            return(xmlValidateNmtokenValueInternal(doc, value));\n@@ -3897,1 +3898,1 @@\n-        break;\n+            break;\n@@ -3965,6 +3966,6 @@\n-    case XML_ATTRIBUTE_IDREFS:\n-    case XML_ATTRIBUTE_IDREF:\n-    case XML_ATTRIBUTE_ID:\n-    case XML_ATTRIBUTE_NMTOKENS:\n-    case XML_ATTRIBUTE_ENUMERATION:\n-    case XML_ATTRIBUTE_NMTOKEN:\n+        case XML_ATTRIBUTE_IDREFS:\n+        case XML_ATTRIBUTE_IDREF:\n+        case XML_ATTRIBUTE_ID:\n+        case XML_ATTRIBUTE_NMTOKENS:\n+        case XML_ATTRIBUTE_ENUMERATION:\n+        case XML_ATTRIBUTE_NMTOKEN:\n@@ -3972,13 +3973,13 @@\n-        break;\n-    case XML_ATTRIBUTE_ENTITY: {\n-        xmlEntityPtr ent;\n-\n-        ent = xmlGetDocEntity(doc, value);\n-        \/* yeah it's a bit messy... *\/\n-        if ((ent == NULL) && (doc->standalone == 1)) {\n-        doc->standalone = 0;\n-        ent = xmlGetDocEntity(doc, value);\n-        }\n-        if (ent == NULL) {\n-        xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n-                XML_DTD_UNKNOWN_ENTITY,\n+            break;\n+        case XML_ATTRIBUTE_ENTITY: {\n+            xmlEntityPtr ent;\n+\n+            ent = xmlGetDocEntity(doc, value);\n+            \/* yeah it's a bit messy... *\/\n+            if ((ent == NULL) && (doc->standalone == 1)) {\n+                doc->standalone = 0;\n+                ent = xmlGetDocEntity(doc, value);\n+            }\n+            if (ent == NULL) {\n+                xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n+                                XML_DTD_UNKNOWN_ENTITY,\n@@ -3986,5 +3987,5 @@\n-               name, value, NULL);\n-        ret = 0;\n-        } else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n-        xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n-                XML_DTD_ENTITY_TYPE,\n+                       name, value, NULL);\n+                ret = 0;\n+            } else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n+                xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n+                                XML_DTD_ENTITY_TYPE,\n@@ -3992,4 +3993,4 @@\n-               name, value, NULL);\n-        ret = 0;\n-        }\n-        break;\n+                       name, value, NULL);\n+                ret = 0;\n+            }\n+            break;\n@@ -3997,3 +3998,3 @@\n-    case XML_ATTRIBUTE_ENTITIES: {\n-        xmlChar *dup, *nam = NULL, *cur, save;\n-        xmlEntityPtr ent;\n+        case XML_ATTRIBUTE_ENTITIES: {\n+            xmlChar *dup, *nam = NULL, *cur, save;\n+            xmlEntityPtr ent;\n@@ -4001,13 +4002,13 @@\n-        dup = xmlStrdup(value);\n-        if (dup == NULL)\n-        return(0);\n-        cur = dup;\n-        while (*cur != 0) {\n-        nam = cur;\n-        while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n-        save = *cur;\n-        *cur = 0;\n-        ent = xmlGetDocEntity(doc, nam);\n-        if (ent == NULL) {\n-            xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n-                    XML_DTD_UNKNOWN_ENTITY,\n+            dup = xmlStrdup(value);\n+            if (dup == NULL)\n+                return(0);\n+            cur = dup;\n+            while (*cur != 0) {\n+                nam = cur;\n+                while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n+                save = *cur;\n+                *cur = 0;\n+                ent = xmlGetDocEntity(doc, nam);\n+                if (ent == NULL) {\n+                    xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n+                                    XML_DTD_UNKNOWN_ENTITY,\n@@ -4015,5 +4016,5 @@\n-               name, nam, NULL);\n-            ret = 0;\n-        } else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n-            xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n-                    XML_DTD_ENTITY_TYPE,\n+                           name, nam, NULL);\n+                    ret = 0;\n+                } else if (ent->etype != XML_EXTERNAL_GENERAL_UNPARSED_ENTITY) {\n+                    xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n+                                    XML_DTD_ENTITY_TYPE,\n@@ -4021,4 +4022,9 @@\n-               name, nam, NULL);\n-            ret = 0;\n-        }\n-        if (save == 0)\n+                           name, nam, NULL);\n+                    ret = 0;\n+                }\n+                if (save == 0)\n+                    break;\n+                *cur = save;\n+                while (IS_BLANK_CH(*cur)) cur++;\n+            }\n+            xmlFree(dup);\n@@ -4026,2 +4032,0 @@\n-        *cur = save;\n-        while (IS_BLANK_CH(*cur)) cur++;\n@@ -4029,5 +4033,2 @@\n-        xmlFree(dup);\n-        break;\n-    }\n-    case XML_ATTRIBUTE_NOTATION: {\n-        xmlNotationPtr nota;\n+        case XML_ATTRIBUTE_NOTATION: {\n+            xmlNotationPtr nota;\n@@ -4035,3 +4036,3 @@\n-        nota = xmlGetDtdNotationDesc(doc->intSubset, value);\n-        if ((nota == NULL) && (doc->extSubset != NULL))\n-        nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n+            nota = xmlGetDtdNotationDesc(doc->intSubset, value);\n+            if ((nota == NULL) && (doc->extSubset != NULL))\n+                nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n@@ -4039,3 +4040,3 @@\n-        if (nota == NULL) {\n-        xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n-                        XML_DTD_UNKNOWN_NOTATION,\n+            if (nota == NULL) {\n+                xmlErrValidNode(ctxt, (xmlNodePtr) doc,\n+                                XML_DTD_UNKNOWN_NOTATION,\n@@ -4043,4 +4044,4 @@\n-               name, value, NULL);\n-        ret = 0;\n-        }\n-        break;\n+                       name, value, NULL);\n+                ret = 0;\n+            }\n+            break;\n@@ -4078,1 +4079,1 @@\n-         xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n+             xmlNodePtr elem, const xmlChar *name, const xmlChar *value) {\n@@ -4089,2 +4090,2 @@\n-    xmlChar fn[50];\n-    xmlChar *fullname;\n+        xmlChar fn[50];\n+        xmlChar *fullname;\n@@ -4092,11 +4093,11 @@\n-    fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n-    if (fullname == NULL)\n-        return(NULL);\n-    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);\n-    if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n-        attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);\n-        if (attrDecl != NULL)\n-        extsubset = 1;\n-    }\n-    if ((fullname != fn) && (fullname != elem->name))\n-        xmlFree(fullname);\n+        fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n+        if (fullname == NULL)\n+            return(NULL);\n+        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, name);\n+        if ((attrDecl == NULL) && (doc->extSubset != NULL)) {\n+            attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname, name);\n+            if (attrDecl != NULL)\n+                extsubset = 1;\n+        }\n+        if ((fullname != fn) && (fullname != elem->name))\n+            xmlFree(fullname);\n@@ -4105,1 +4106,1 @@\n-    attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n+        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, elem->name, name);\n@@ -4107,3 +4108,3 @@\n-    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n-    if (attrDecl != NULL)\n-        extsubset = 1;\n+        attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n+        if (attrDecl != NULL)\n+            extsubset = 1;\n@@ -4113,1 +4114,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4115,1 +4116,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4119,1 +4120,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4122,1 +4123,1 @@\n-    xmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n+        xmlErrValidNode(ctxt, elem, XML_DTD_NOT_STANDALONE,\n@@ -4124,2 +4125,2 @@\n-           name, elem->name, NULL);\n-    ctxt->valid = 0;\n+               name, elem->name, NULL);\n+        ctxt->valid = 0;\n@@ -4151,1 +4152,1 @@\n-                    const xmlChar *name, const xmlChar *value) {\n+                                const xmlChar *name, const xmlChar *value) {\n@@ -4161,2 +4162,2 @@\n-    xmlChar fn[50];\n-    xmlChar *fullname;\n+        xmlChar fn[50];\n+        xmlChar *fullname;\n@@ -4164,5 +4165,5 @@\n-    fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n-    if (fullname == NULL)\n-        return(NULL);\n-    if ((fullname != fn) && (fullname != elem->name))\n-        xmlFree(fullname);\n+        fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n+        if (fullname == NULL)\n+            return(NULL);\n+        if ((fullname != fn) && (fullname != elem->name))\n+            xmlFree(fullname);\n@@ -4172,1 +4173,1 @@\n-    attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n+        attrDecl = xmlGetDtdAttrDesc(doc->extSubset, elem->name, name);\n@@ -4175,1 +4176,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4177,1 +4178,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4181,1 +4182,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -4188,1 +4189,1 @@\n-                           const xmlChar *name ATTRIBUTE_UNUSED) {\n+                               const xmlChar *name ATTRIBUTE_UNUSED) {\n@@ -4223,7 +4224,7 @@\n-    val = xmlValidateAttributeValueInternal(doc, attr->atype,\n-                                            attr->defaultValue);\n-    if (val == 0) {\n-        xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_DEFAULT,\n-           \"Syntax of default value for attribute %s of %s is not valid\\n\",\n-               attr->name, attr->elem, NULL);\n-    }\n+        val = xmlValidateAttributeValueInternal(doc, attr->atype,\n+                                                attr->defaultValue);\n+        if (val == 0) {\n+            xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_DEFAULT,\n+               \"Syntax of default value for attribute %s of %s is not valid\\n\",\n+                   attr->name, attr->elem, NULL);\n+        }\n@@ -4236,2 +4237,2 @@\n-    (attr->def != XML_ATTRIBUTE_REQUIRED)) {\n-    xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_FIXED,\n+        (attr->def != XML_ATTRIBUTE_REQUIRED)) {\n+        xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_FIXED,\n@@ -4239,2 +4240,2 @@\n-           attr->name, attr->elem, NULL);\n-    ret = 0;\n+               attr->name, attr->elem, NULL);\n+        ret = 0;\n@@ -4247,1 +4248,1 @@\n-    \/* the trick is that we parse DtD as their own internal subset *\/\n+        \/* the trick is that we parse DtD as their own internal subset *\/\n@@ -4249,5 +4250,5 @@\n-                                              attr->elem);\n-    if (elem != NULL) {\n-        nbId = xmlScanIDAttributeDecl(NULL, elem, 0);\n-    } else {\n-        xmlAttributeTablePtr table;\n+                                                  attr->elem);\n+        if (elem != NULL) {\n+            nbId = xmlScanIDAttributeDecl(NULL, elem, 0);\n+        } else {\n+            xmlAttributeTablePtr table;\n@@ -4255,9 +4256,10 @@\n-        \/*\n-         * The attribute may be declared in the internal subset and the\n-         * element in the external subset.\n-         *\/\n-        nbId = 0;\n-        if (doc->intSubset != NULL) {\n-        table = (xmlAttributeTablePtr) doc->intSubset->attributes;\n-        xmlHashScan3(table, NULL, NULL, attr->elem,\n-                 xmlValidateAttributeIdCallback, &nbId);\n+            \/*\n+             * The attribute may be declared in the internal subset and the\n+             * element in the external subset.\n+             *\/\n+            nbId = 0;\n+            if (doc->intSubset != NULL) {\n+                table = (xmlAttributeTablePtr) doc->intSubset->attributes;\n+                xmlHashScan3(table, NULL, NULL, attr->elem,\n+                             xmlValidateAttributeIdCallback, &nbId);\n+            }\n@@ -4265,2 +4267,1 @@\n-    }\n-    if (nbId > 1) {\n+        if (nbId > 1) {\n@@ -4268,1 +4269,1 @@\n-        xmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n+            xmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n@@ -4270,9 +4271,9 @@\n-           attr->elem, nbId, attr->name);\n-    } else if (doc->extSubset != NULL) {\n-        int extId = 0;\n-        elem = xmlGetDtdElementDesc(doc->extSubset, attr->elem);\n-        if (elem != NULL) {\n-        extId = xmlScanIDAttributeDecl(NULL, elem, 0);\n-        }\n-        if (extId > 1) {\n-        xmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n+                   attr->elem, nbId, attr->name);\n+        } else if (doc->extSubset != NULL) {\n+            int extId = 0;\n+            elem = xmlGetDtdElementDesc(doc->extSubset, attr->elem);\n+            if (elem != NULL) {\n+                extId = xmlScanIDAttributeDecl(NULL, elem, 0);\n+            }\n+            if (extId > 1) {\n+                xmlErrValidNodeNr(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n@@ -4280,3 +4281,3 @@\n-               attr->elem, extId, attr->name);\n-        } else if (extId + nbId > 1) {\n-        xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n+                       attr->elem, extId, attr->name);\n+            } else if (extId + nbId > 1) {\n+                xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ID_SUBSET,\n@@ -4284,1 +4285,2 @@\n-               attr->elem, attr->name, NULL);\n+                       attr->elem, attr->name, NULL);\n+            }\n@@ -4287,1 +4289,0 @@\n-    }\n@@ -4292,6 +4293,6 @@\n-    while (tree != NULL) {\n-        if (xmlStrEqual(tree->name, attr->defaultValue)) break;\n-        tree = tree->next;\n-    }\n-    if (tree == NULL) {\n-        xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_VALUE,\n+        while (tree != NULL) {\n+            if (xmlStrEqual(tree->name, attr->defaultValue)) break;\n+            tree = tree->next;\n+        }\n+        if (tree == NULL) {\n+            xmlErrValidNode(ctxt, (xmlNodePtr) attr, XML_DTD_ATTRIBUTE_VALUE,\n@@ -4299,3 +4300,3 @@\n-           attr->defaultValue, attr->name, attr->elem);\n-        ret = 0;\n-    }\n+                   attr->defaultValue, attr->name, attr->elem);\n+            ret = 0;\n+        }\n@@ -4342,1 +4343,1 @@\n-    xmlElementContentPtr cur, next;\n+        xmlElementContentPtr cur, next;\n@@ -4345,19 +4346,40 @@\n-    cur = elem->content;\n-    while (cur != NULL) {\n-        if (cur->type != XML_ELEMENT_CONTENT_OR) break;\n-        if (cur->c1 == NULL) break;\n-        if (cur->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {\n-        name = cur->c1->name;\n-        next = cur->c2;\n-        while (next != NULL) {\n-            if (next->type == XML_ELEMENT_CONTENT_ELEMENT) {\n-                if ((xmlStrEqual(next->name, name)) &&\n-                (xmlStrEqual(next->prefix, cur->c1->prefix))) {\n-                if (cur->c1->prefix == NULL) {\n-                xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n-           \"Definition of %s has duplicate references of %s\\n\",\n-                       elem->name, name, NULL);\n-                } else {\n-                xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n-           \"Definition of %s has duplicate references of %s:%s\\n\",\n-                       elem->name, cur->c1->prefix, name);\n+        cur = elem->content;\n+        while (cur != NULL) {\n+            if (cur->type != XML_ELEMENT_CONTENT_OR) break;\n+            if (cur->c1 == NULL) break;\n+            if (cur->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {\n+                name = cur->c1->name;\n+                next = cur->c2;\n+                while (next != NULL) {\n+                    if (next->type == XML_ELEMENT_CONTENT_ELEMENT) {\n+                        if ((xmlStrEqual(next->name, name)) &&\n+                            (xmlStrEqual(next->prefix, cur->c1->prefix))) {\n+                            if (cur->c1->prefix == NULL) {\n+                                xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n+                   \"Definition of %s has duplicate references of %s\\n\",\n+                                       elem->name, name, NULL);\n+                            } else {\n+                                xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n+                   \"Definition of %s has duplicate references of %s:%s\\n\",\n+                                       elem->name, cur->c1->prefix, name);\n+                            }\n+                            ret = 0;\n+                        }\n+                        break;\n+                    }\n+                    if (next->c1 == NULL) break;\n+                    if (next->c1->type != XML_ELEMENT_CONTENT_ELEMENT) break;\n+                    if ((xmlStrEqual(next->c1->name, name)) &&\n+                        (xmlStrEqual(next->c1->prefix, cur->c1->prefix))) {\n+                        if (cur->c1->prefix == NULL) {\n+                            xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n+               \"Definition of %s has duplicate references to %s\\n\",\n+                                   elem->name, name, NULL);\n+                        } else {\n+                            xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n+               \"Definition of %s has duplicate references to %s:%s\\n\",\n+                                   elem->name, cur->c1->prefix, name);\n+                        }\n+                        ret = 0;\n+                    }\n+                    next = next->c2;\n@@ -4365,18 +4387,0 @@\n-                ret = 0;\n-            }\n-            break;\n-            }\n-            if (next->c1 == NULL) break;\n-            if (next->c1->type != XML_ELEMENT_CONTENT_ELEMENT) break;\n-            if ((xmlStrEqual(next->c1->name, name)) &&\n-                (xmlStrEqual(next->c1->prefix, cur->c1->prefix))) {\n-            if (cur->c1->prefix == NULL) {\n-                xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n-           \"Definition of %s has duplicate references to %s\\n\",\n-                   elem->name, name, NULL);\n-            } else {\n-                xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_CONTENT_ERROR,\n-           \"Definition of %s has duplicate references to %s:%s\\n\",\n-                   elem->name, cur->c1->prefix, name);\n-            }\n-            ret = 0;\n@@ -4384,2 +4388,1 @@\n-            next = next->c2;\n-        }\n+            cur = cur->c2;\n@@ -4387,2 +4390,0 @@\n-        cur = cur->c2;\n-    }\n@@ -4394,7 +4395,7 @@\n-    ((tst->prefix == elem->prefix) ||\n-     (xmlStrEqual(tst->prefix, elem->prefix))) &&\n-    (tst->etype != XML_ELEMENT_TYPE_UNDEFINED)) {\n-    xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_ELEM_REDEFINED,\n-                    \"Redefinition of element %s\\n\",\n-               elem->name, NULL, NULL);\n-    ret = 0;\n+        ((tst->prefix == elem->prefix) ||\n+         (xmlStrEqual(tst->prefix, elem->prefix))) &&\n+        (tst->etype != XML_ELEMENT_TYPE_UNDEFINED)) {\n+        xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_ELEM_REDEFINED,\n+                        \"Redefinition of element %s\\n\",\n+                       elem->name, NULL, NULL);\n+        ret = 0;\n@@ -4404,7 +4405,7 @@\n-    ((tst->prefix == elem->prefix) ||\n-     (xmlStrEqual(tst->prefix, elem->prefix))) &&\n-    (tst->etype != XML_ELEMENT_TYPE_UNDEFINED)) {\n-    xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_ELEM_REDEFINED,\n-                    \"Redefinition of element %s\\n\",\n-               elem->name, NULL, NULL);\n-    ret = 0;\n+        ((tst->prefix == elem->prefix) ||\n+         (xmlStrEqual(tst->prefix, elem->prefix))) &&\n+        (tst->etype != XML_ELEMENT_TYPE_UNDEFINED)) {\n+        xmlErrValidNode(ctxt, (xmlNodePtr) elem, XML_DTD_ELEM_REDEFINED,\n+                        \"Redefinition of element %s\\n\",\n+                       elem->name, NULL, NULL);\n+        ret = 0;\n@@ -4415,1 +4416,1 @@\n-    ret = 0;\n+        ret = 0;\n@@ -4458,2 +4459,2 @@\n-    xmlChar fn[50];\n-    xmlChar *fullname;\n+        xmlChar fn[50];\n+        xmlChar *fullname;\n@@ -4461,17 +4462,17 @@\n-    fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n-    if (fullname == NULL)\n-        return(0);\n-    if (attr->ns != NULL) {\n-        attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,\n-                                  attr->name, attr->ns->prefix);\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,\n-                          attr->name, attr->ns->prefix);\n-    } else {\n-        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, attr->name);\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n-                         fullname, attr->name);\n-    }\n-    if ((fullname != fn) && (fullname != elem->name))\n-        xmlFree(fullname);\n+        fullname = xmlBuildQName(elem->name, elem->ns->prefix, fn, 50);\n+        if (fullname == NULL)\n+            return(0);\n+        if (attr->ns != NULL) {\n+            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,\n+                                          attr->name, attr->ns->prefix);\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,\n+                                              attr->name, attr->ns->prefix);\n+        } else {\n+            attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname, attr->name);\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n+                                             fullname, attr->name);\n+        }\n+        if ((fullname != fn) && (fullname != elem->name))\n+            xmlFree(fullname);\n@@ -4480,13 +4481,13 @@\n-    if (attr->ns != NULL) {\n-        attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,\n-                                  attr->name, attr->ns->prefix);\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,\n-                          attr->name, attr->ns->prefix);\n-    } else {\n-        attrDecl = xmlGetDtdAttrDesc(doc->intSubset,\n-                                 elem->name, attr->name);\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n-                         elem->name, attr->name);\n-    }\n+        if (attr->ns != NULL) {\n+            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,\n+                                          attr->name, attr->ns->prefix);\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,\n+                                              attr->name, attr->ns->prefix);\n+        } else {\n+            attrDecl = xmlGetDtdAttrDesc(doc->intSubset,\n+                                         elem->name, attr->name);\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n+                                             elem->name, attr->name);\n+        }\n@@ -4498,4 +4499,4 @@\n-    xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n-           \"No declaration for attribute %s of element %s\\n\",\n-           attr->name, elem->name, NULL);\n-    return(0);\n+        xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n+               \"No declaration for attribute %s of element %s\\n\",\n+               attr->name, elem->name, NULL);\n+        return(0);\n@@ -4507,3 +4508,3 @@\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n-       \"Syntax of value for attribute %s of %s is not valid\\n\",\n-           attr->name, elem->name, NULL);\n+            xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n+           \"Syntax of value for attribute %s of %s is not valid\\n\",\n+               attr->name, elem->name, NULL);\n@@ -4515,6 +4516,6 @@\n-    if (!xmlStrEqual(value, attrDecl->defaultValue)) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n-       \"Value for attribute %s of %s is different from default \\\"%s\\\"\\n\",\n-           attr->name, elem->name, attrDecl->defaultValue);\n-        ret = 0;\n-    }\n+        if (!xmlStrEqual(value, attrDecl->defaultValue)) {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n+           \"Value for attribute %s of %s is different from default \\\"%s\\\"\\n\",\n+                   attr->name, elem->name, attrDecl->defaultValue);\n+            ret = 0;\n+        }\n@@ -4526,1 +4527,1 @@\n-        ret = 0;\n+            ret = 0;\n@@ -4530,1 +4531,1 @@\n-    (attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {\n+        (attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {\n@@ -4532,1 +4533,1 @@\n-        ret = 0;\n+            ret = 0;\n@@ -4541,3 +4542,3 @@\n-    nota = xmlGetDtdNotationDesc(doc->intSubset, value);\n-    if (nota == NULL)\n-        nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n+        nota = xmlGetDtdNotationDesc(doc->intSubset, value);\n+        if (nota == NULL)\n+            nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n@@ -4545,2 +4546,2 @@\n-    if (nota == NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n+        if (nota == NULL) {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n@@ -4548,2 +4549,2 @@\n-           value, attr->name, elem->name);\n-        ret = 0;\n+                   value, attr->name, elem->name);\n+            ret = 0;\n@@ -4552,7 +4553,7 @@\n-    \/* Second, verify that it's among the list *\/\n-    while (tree != NULL) {\n-        if (xmlStrEqual(tree->name, value)) break;\n-        tree = tree->next;\n-    }\n-    if (tree == NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n+        \/* Second, verify that it's among the list *\/\n+        while (tree != NULL) {\n+            if (xmlStrEqual(tree->name, value)) break;\n+            tree = tree->next;\n+        }\n+        if (tree == NULL) {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n@@ -4560,3 +4561,3 @@\n-           value, attr->name, elem->name);\n-        ret = 0;\n-    }\n+                   value, attr->name, elem->name);\n+            ret = 0;\n+        }\n@@ -4568,6 +4569,6 @@\n-    while (tree != NULL) {\n-        if (xmlStrEqual(tree->name, value)) break;\n-        tree = tree->next;\n-    }\n-    if (tree == NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n+        while (tree != NULL) {\n+            if (xmlStrEqual(tree->name, value)) break;\n+            tree = tree->next;\n+        }\n+        if (tree == NULL) {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n@@ -4575,3 +4576,3 @@\n-           value, attr->name, elem->name);\n-        ret = 0;\n-    }\n+                   value, attr->name, elem->name);\n+            ret = 0;\n+        }\n@@ -4583,3 +4584,3 @@\n-    xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n-       \"Value for attribute %s of %s must be \\\"%s\\\"\\n\",\n-           attr->name, elem->name, attrDecl->defaultValue);\n+        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n+           \"Value for attribute %s of %s must be \\\"%s\\\"\\n\",\n+               attr->name, elem->name, attrDecl->defaultValue);\n@@ -4591,1 +4592,1 @@\n-                      attrDecl->atype, value);\n+                                      attrDecl->atype, value);\n@@ -4635,2 +4636,2 @@\n-    xmlChar fn[50];\n-    xmlChar *fullname;\n+        xmlChar fn[50];\n+        xmlChar *fullname;\n@@ -4638,20 +4639,20 @@\n-    fullname = xmlBuildQName(elem->name, prefix, fn, 50);\n-    if (fullname == NULL) {\n-        xmlVErrMemory(ctxt, \"Validating namespace\");\n-        return(0);\n-    }\n-    if (ns->prefix != NULL) {\n-        attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,\n-                                  ns->prefix, BAD_CAST \"xmlns\");\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,\n-                      ns->prefix, BAD_CAST \"xmlns\");\n-    } else {\n-        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname,\n-                                 BAD_CAST \"xmlns\");\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname,\n-                             BAD_CAST \"xmlns\");\n-    }\n-    if ((fullname != fn) && (fullname != elem->name))\n-        xmlFree(fullname);\n+        fullname = xmlBuildQName(elem->name, prefix, fn, 50);\n+        if (fullname == NULL) {\n+            xmlVErrMemory(ctxt, \"Validating namespace\");\n+            return(0);\n+        }\n+        if (ns->prefix != NULL) {\n+            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, fullname,\n+                                          ns->prefix, BAD_CAST \"xmlns\");\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, fullname,\n+                                          ns->prefix, BAD_CAST \"xmlns\");\n+        } else {\n+            attrDecl = xmlGetDtdAttrDesc(doc->intSubset, fullname,\n+                                         BAD_CAST \"xmlns\");\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdAttrDesc(doc->extSubset, fullname,\n+                                         BAD_CAST \"xmlns\");\n+        }\n+        if ((fullname != fn) && (fullname != elem->name))\n+            xmlFree(fullname);\n@@ -4660,13 +4661,13 @@\n-    if (ns->prefix != NULL) {\n-        attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,\n-                                  ns->prefix, BAD_CAST \"xmlns\");\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,\n-                          ns->prefix, BAD_CAST \"xmlns\");\n-    } else {\n-        attrDecl = xmlGetDtdAttrDesc(doc->intSubset,\n-                                 elem->name, BAD_CAST \"xmlns\");\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n-                         elem->name, BAD_CAST \"xmlns\");\n-    }\n+        if (ns->prefix != NULL) {\n+            attrDecl = xmlGetDtdQAttrDesc(doc->intSubset, elem->name,\n+                                          ns->prefix, BAD_CAST \"xmlns\");\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdQAttrDesc(doc->extSubset, elem->name,\n+                                              ns->prefix, BAD_CAST \"xmlns\");\n+        } else {\n+            attrDecl = xmlGetDtdAttrDesc(doc->intSubset,\n+                                         elem->name, BAD_CAST \"xmlns\");\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdAttrDesc(doc->extSubset,\n+                                             elem->name, BAD_CAST \"xmlns\");\n+        }\n@@ -4678,10 +4679,10 @@\n-    if (ns->prefix != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n-           \"No declaration for attribute xmlns:%s of element %s\\n\",\n-           ns->prefix, elem->name, NULL);\n-    } else {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n-           \"No declaration for attribute xmlns of element %s\\n\",\n-           elem->name, NULL, NULL);\n-    }\n-    return(0);\n+        if (ns->prefix != NULL) {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n+                   \"No declaration for attribute xmlns:%s of element %s\\n\",\n+                   ns->prefix, elem->name, NULL);\n+        } else {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ATTRIBUTE,\n+                   \"No declaration for attribute xmlns of element %s\\n\",\n+                   elem->name, NULL, NULL);\n+        }\n+        return(0);\n@@ -4692,9 +4693,9 @@\n-    if (ns->prefix != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,\n-           \"Syntax of value for attribute xmlns:%s of %s is not valid\\n\",\n-           ns->prefix, elem->name, NULL);\n-    } else {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,\n-           \"Syntax of value for attribute xmlns of %s is not valid\\n\",\n-           elem->name, NULL, NULL);\n-    }\n+        if (ns->prefix != NULL) {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,\n+               \"Syntax of value for attribute xmlns:%s of %s is not valid\\n\",\n+                   ns->prefix, elem->name, NULL);\n+        } else {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_DEFAULT,\n+               \"Syntax of value for attribute xmlns of %s is not valid\\n\",\n+                   elem->name, NULL, NULL);\n+        }\n@@ -4706,3 +4707,3 @@\n-    if (!xmlStrEqual(value, attrDecl->defaultValue)) {\n-        if (ns->prefix != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n+        if (!xmlStrEqual(value, attrDecl->defaultValue)) {\n+            if (ns->prefix != NULL) {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n@@ -4710,3 +4711,3 @@\n-               ns->prefix, elem->name, attrDecl->defaultValue);\n-        } else {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n+                       ns->prefix, elem->name, attrDecl->defaultValue);\n+            } else {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_DEFAULT,\n@@ -4714,1 +4715,3 @@\n-               elem->name, attrDecl->defaultValue, NULL);\n+                       elem->name, attrDecl->defaultValue, NULL);\n+            }\n+            ret = 0;\n@@ -4716,2 +4719,0 @@\n-        ret = 0;\n-    }\n@@ -4729,1 +4730,1 @@\n-        ret = 0;\n+            ret = 0;\n@@ -4733,1 +4734,1 @@\n-    (attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {\n+        (attrDecl->atype == XML_ATTRIBUTE_IDREFS)) {\n@@ -4735,1 +4736,1 @@\n-        ret = 0;\n+            ret = 0;\n@@ -4745,3 +4746,3 @@\n-    nota = xmlGetDtdNotationDesc(doc->intSubset, value);\n-    if (nota == NULL)\n-        nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n+        nota = xmlGetDtdNotationDesc(doc->intSubset, value);\n+        if (nota == NULL)\n+            nota = xmlGetDtdNotationDesc(doc->extSubset, value);\n@@ -4749,3 +4750,3 @@\n-    if (nota == NULL) {\n-        if (ns->prefix != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n+        if (nota == NULL) {\n+            if (ns->prefix != NULL) {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n@@ -4753,3 +4754,3 @@\n-               value, ns->prefix, elem->name);\n-        } else {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n+                       value, ns->prefix, elem->name);\n+            } else {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_NOTATION,\n@@ -4757,3 +4758,3 @@\n-               value, elem->name, NULL);\n-        }\n-        ret = 0;\n+                       value, elem->name, NULL);\n+            }\n+            ret = 0;\n@@ -4762,8 +4763,8 @@\n-    \/* Second, verify that it's among the list *\/\n-    while (tree != NULL) {\n-        if (xmlStrEqual(tree->name, value)) break;\n-        tree = tree->next;\n-    }\n-    if (tree == NULL) {\n-        if (ns->prefix != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n+        \/* Second, verify that it's among the list *\/\n+        while (tree != NULL) {\n+            if (xmlStrEqual(tree->name, value)) break;\n+            tree = tree->next;\n+        }\n+        if (tree == NULL) {\n+            if (ns->prefix != NULL) {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n@@ -4771,3 +4772,3 @@\n-               value, ns->prefix, elem->name);\n-        } else {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n+                       value, ns->prefix, elem->name);\n+            } else {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_NOTATION_VALUE,\n@@ -4775,1 +4776,3 @@\n-               value, elem->name, NULL);\n+                       value, elem->name, NULL);\n+            }\n+            ret = 0;\n@@ -4777,2 +4780,0 @@\n-        ret = 0;\n-    }\n@@ -4784,7 +4785,7 @@\n-    while (tree != NULL) {\n-        if (xmlStrEqual(tree->name, value)) break;\n-        tree = tree->next;\n-    }\n-    if (tree == NULL) {\n-        if (ns->prefix != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n+        while (tree != NULL) {\n+            if (xmlStrEqual(tree->name, value)) break;\n+            tree = tree->next;\n+        }\n+        if (tree == NULL) {\n+            if (ns->prefix != NULL) {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n@@ -4792,3 +4793,3 @@\n-               value, ns->prefix, elem->name);\n-        } else {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n+                       value, ns->prefix, elem->name);\n+            } else {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_ATTRIBUTE_VALUE,\n@@ -4796,1 +4797,3 @@\n-               value, elem->name, NULL);\n+                       value, elem->name, NULL);\n+            }\n+            ret = 0;\n@@ -4798,2 +4801,0 @@\n-        ret = 0;\n-    }\n@@ -4805,9 +4806,9 @@\n-    if (ns->prefix != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n-           \"Value for attribute xmlns:%s of %s must be \\\"%s\\\"\\n\",\n-           ns->prefix, elem->name, attrDecl->defaultValue);\n-    } else {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n-           \"Value for attribute xmlns of %s must be \\\"%s\\\"\\n\",\n-           elem->name, attrDecl->defaultValue, NULL);\n-    }\n+        if (ns->prefix != NULL) {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n+                   \"Value for attribute xmlns:%s of %s must be \\\"%s\\\"\\n\",\n+                   ns->prefix, elem->name, attrDecl->defaultValue);\n+        } else {\n+            xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n+                   \"Value for attribute xmlns of %s must be \\\"%s\\\"\\n\",\n+                   elem->name, attrDecl->defaultValue, NULL);\n+        }\n@@ -4819,2 +4820,2 @@\n-    ret &= xmlValidateAttributeValue2(ctxt, doc, ns->prefix,\n-                      attrDecl->atype, value);\n+        ret &= xmlValidateAttributeValue2(ctxt, doc, ns->prefix,\n+                                          attrDecl->atype, value);\n@@ -4822,2 +4823,2 @@\n-    ret &= xmlValidateAttributeValue2(ctxt, doc, BAD_CAST \"xmlns\",\n-                      attrDecl->atype, value);\n+        ret &= xmlValidateAttributeValue2(ctxt, doc, BAD_CAST \"xmlns\",\n+                                          attrDecl->atype, value);\n@@ -4843,18 +4844,18 @@\n-    switch (child->type) {\n-        \/* These things are ignored (skipped) during validation.  *\/\n-        case XML_PI_NODE:\n-        case XML_COMMENT_NODE:\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        child = child->next;\n-        break;\n-        case XML_TEXT_NODE:\n-        if (xmlIsBlankNode(child))\n-            child = child->next;\n-        else\n-            return(child);\n-        break;\n-        \/* keep current node *\/\n-        default:\n-        return(child);\n-    }\n+        switch (child->type) {\n+            \/* These things are ignored (skipped) during validation.  *\/\n+            case XML_PI_NODE:\n+            case XML_COMMENT_NODE:\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+                child = child->next;\n+                break;\n+            case XML_TEXT_NODE:\n+                if (xmlIsBlankNode(child))\n+                    child = child->next;\n+                else\n+                    return(child);\n+                break;\n+            \/* keep current node *\/\n+            default:\n+                return(child);\n+        }\n@@ -4883,1 +4884,1 @@\n-    return(1);\n+        return(1);\n@@ -4885,3 +4886,3 @@\n-    ((CONT->ocur == XML_ELEMENT_CONTENT_MULT) ||\n-     (CONT->ocur == XML_ELEMENT_CONTENT_OPT))) {\n-    return(1);\n+        ((CONT->ocur == XML_ELEMENT_CONTENT_MULT) ||\n+         (CONT->ocur == XML_ELEMENT_CONTENT_OPT))) {\n+        return(1);\n@@ -4891,1 +4892,1 @@\n-    return(-2);\n+        return(-2);\n@@ -4903,4 +4904,4 @@\n-    DEBUG_VALID_MSG(\"restored parent branch\");\n-    DEBUG_VALID_STATE(NODE, CONT)\n-    ret = 1;\n-    goto analyze;\n+        DEBUG_VALID_MSG(\"restored parent branch\");\n+        DEBUG_VALID_STATE(NODE, CONT)\n+        ret = 1;\n+        goto analyze;\n@@ -4915,8 +4916,8 @@\n-    ((CONT->parent == NULL) ||\n-     (CONT->parent->type != XML_ELEMENT_CONTENT_OR)) &&\n-    ((CONT->ocur == XML_ELEMENT_CONTENT_MULT) ||\n-     (CONT->ocur == XML_ELEMENT_CONTENT_OPT) ||\n-     ((CONT->ocur == XML_ELEMENT_CONTENT_PLUS) && (OCCURRENCE)))) {\n-    DEBUG_VALID_MSG(\"saving parent branch\");\n-    if (vstateVPush(ctxt, CONT, NODE, DEPTH, OCCURS, ROLLBACK_PARENT) < 0)\n-        return(0);\n+        ((CONT->parent == NULL) ||\n+         (CONT->parent->type != XML_ELEMENT_CONTENT_OR)) &&\n+        ((CONT->ocur == XML_ELEMENT_CONTENT_MULT) ||\n+         (CONT->ocur == XML_ELEMENT_CONTENT_OPT) ||\n+         ((CONT->ocur == XML_ELEMENT_CONTENT_PLUS) && (OCCURRENCE)))) {\n+        DEBUG_VALID_MSG(\"saving parent branch\");\n+        if (vstateVPush(ctxt, CONT, NODE, DEPTH, OCCURS, ROLLBACK_PARENT) < 0)\n+            return(0);\n@@ -4930,22 +4931,22 @@\n-    case XML_ELEMENT_CONTENT_PCDATA:\n-        if (NODE == NULL) {\n-        DEBUG_VALID_MSG(\"pcdata failed no node\");\n-        ret = 0;\n-        break;\n-        }\n-        if (NODE->type == XML_TEXT_NODE) {\n-        DEBUG_VALID_MSG(\"pcdata found, skip to next\");\n-        \/*\n-         * go to next element in the content model\n-         * skipping ignorable elems\n-         *\/\n-        do {\n-            NODE = NODE->next;\n-            NODE = xmlValidateSkipIgnorable(NODE);\n-            if ((NODE != NULL) &&\n-            (NODE->type == XML_ENTITY_REF_NODE))\n-            return(-2);\n-        } while ((NODE != NULL) &&\n-             ((NODE->type != XML_ELEMENT_NODE) &&\n-              (NODE->type != XML_TEXT_NODE) &&\n-              (NODE->type != XML_CDATA_SECTION_NODE)));\n+        case XML_ELEMENT_CONTENT_PCDATA:\n+            if (NODE == NULL) {\n+                DEBUG_VALID_MSG(\"pcdata failed no node\");\n+                ret = 0;\n+                break;\n+            }\n+            if (NODE->type == XML_TEXT_NODE) {\n+                DEBUG_VALID_MSG(\"pcdata found, skip to next\");\n+                \/*\n+                 * go to next element in the content model\n+                 * skipping ignorable elems\n+                 *\/\n+                do {\n+                    NODE = NODE->next;\n+                    NODE = xmlValidateSkipIgnorable(NODE);\n+                    if ((NODE != NULL) &&\n+                        (NODE->type == XML_ENTITY_REF_NODE))\n+                        return(-2);\n+                } while ((NODE != NULL) &&\n+                         ((NODE->type != XML_ELEMENT_NODE) &&\n+                          (NODE->type != XML_TEXT_NODE) &&\n+                          (NODE->type != XML_CDATA_SECTION_NODE)));\n@@ -4953,70 +4954,70 @@\n-        break;\n-        } else {\n-        DEBUG_VALID_MSG(\"pcdata failed\");\n-        ret = 0;\n-        break;\n-        }\n-        break;\n-    case XML_ELEMENT_CONTENT_ELEMENT:\n-        if (NODE == NULL) {\n-        DEBUG_VALID_MSG(\"element failed no node\");\n-        ret = 0;\n-        break;\n-        }\n-        ret = ((NODE->type == XML_ELEMENT_NODE) &&\n-           (xmlStrEqual(NODE->name, CONT->name)));\n-        if (ret == 1) {\n-        if ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n-            ret = (CONT->prefix == NULL);\n-        } else if (CONT->prefix == NULL) {\n-            ret = 0;\n-        } else {\n-            ret = xmlStrEqual(NODE->ns->prefix, CONT->prefix);\n-        }\n-        }\n-        if (ret == 1) {\n-        DEBUG_VALID_MSG(\"element found, skip to next\");\n-        \/*\n-         * go to next element in the content model\n-         * skipping ignorable elems\n-         *\/\n-        do {\n-            NODE = NODE->next;\n-            NODE = xmlValidateSkipIgnorable(NODE);\n-            if ((NODE != NULL) &&\n-            (NODE->type == XML_ENTITY_REF_NODE))\n-            return(-2);\n-        } while ((NODE != NULL) &&\n-             ((NODE->type != XML_ELEMENT_NODE) &&\n-              (NODE->type != XML_TEXT_NODE) &&\n-              (NODE->type != XML_CDATA_SECTION_NODE)));\n-        } else {\n-        DEBUG_VALID_MSG(\"element failed\");\n-        ret = 0;\n-        break;\n-        }\n-        break;\n-    case XML_ELEMENT_CONTENT_OR:\n-        \/*\n-         * Small optimization.\n-         *\/\n-        if (CONT->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {\n-        if ((NODE == NULL) ||\n-            (!xmlStrEqual(NODE->name, CONT->c1->name))) {\n-            DEPTH++;\n-            CONT = CONT->c2;\n-            goto cont;\n-        }\n-        if ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n-            ret = (CONT->c1->prefix == NULL);\n-        } else if (CONT->c1->prefix == NULL) {\n-            ret = 0;\n-        } else {\n-            ret = xmlStrEqual(NODE->ns->prefix, CONT->c1->prefix);\n-        }\n-        if (ret == 0) {\n-            DEPTH++;\n-            CONT = CONT->c2;\n-            goto cont;\n-        }\n-        }\n+                break;\n+            } else {\n+                DEBUG_VALID_MSG(\"pcdata failed\");\n+                ret = 0;\n+                break;\n+            }\n+            break;\n+        case XML_ELEMENT_CONTENT_ELEMENT:\n+            if (NODE == NULL) {\n+                DEBUG_VALID_MSG(\"element failed no node\");\n+                ret = 0;\n+                break;\n+            }\n+            ret = ((NODE->type == XML_ELEMENT_NODE) &&\n+                   (xmlStrEqual(NODE->name, CONT->name)));\n+            if (ret == 1) {\n+                if ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n+                    ret = (CONT->prefix == NULL);\n+                } else if (CONT->prefix == NULL) {\n+                    ret = 0;\n+                } else {\n+                    ret = xmlStrEqual(NODE->ns->prefix, CONT->prefix);\n+                }\n+            }\n+            if (ret == 1) {\n+                DEBUG_VALID_MSG(\"element found, skip to next\");\n+                \/*\n+                 * go to next element in the content model\n+                 * skipping ignorable elems\n+                 *\/\n+                do {\n+                    NODE = NODE->next;\n+                    NODE = xmlValidateSkipIgnorable(NODE);\n+                    if ((NODE != NULL) &&\n+                        (NODE->type == XML_ENTITY_REF_NODE))\n+                        return(-2);\n+                } while ((NODE != NULL) &&\n+                         ((NODE->type != XML_ELEMENT_NODE) &&\n+                          (NODE->type != XML_TEXT_NODE) &&\n+                          (NODE->type != XML_CDATA_SECTION_NODE)));\n+            } else {\n+                DEBUG_VALID_MSG(\"element failed\");\n+                ret = 0;\n+                break;\n+            }\n+            break;\n+        case XML_ELEMENT_CONTENT_OR:\n+            \/*\n+             * Small optimization.\n+             *\/\n+            if (CONT->c1->type == XML_ELEMENT_CONTENT_ELEMENT) {\n+                if ((NODE == NULL) ||\n+                    (!xmlStrEqual(NODE->name, CONT->c1->name))) {\n+                    DEPTH++;\n+                    CONT = CONT->c2;\n+                    goto cont;\n+                }\n+                if ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n+                    ret = (CONT->c1->prefix == NULL);\n+                } else if (CONT->c1->prefix == NULL) {\n+                    ret = 0;\n+                } else {\n+                    ret = xmlStrEqual(NODE->ns->prefix, CONT->c1->prefix);\n+                }\n+                if (ret == 0) {\n+                    DEPTH++;\n+                    CONT = CONT->c2;\n+                    goto cont;\n+                }\n+            }\n@@ -5024,19 +5025,7 @@\n-        \/*\n-         * save the second branch 'or' branch\n-         *\/\n-        DEBUG_VALID_MSG(\"saving 'or' branch\");\n-        if (vstateVPush(ctxt, CONT->c2, NODE, (unsigned char)(DEPTH + 1),\n-                OCCURS, ROLLBACK_OR) < 0)\n-        return(-1);\n-        DEPTH++;\n-        CONT = CONT->c1;\n-        goto cont;\n-    case XML_ELEMENT_CONTENT_SEQ:\n-        \/*\n-         * Small optimization.\n-         *\/\n-        if ((CONT->c1->type == XML_ELEMENT_CONTENT_ELEMENT) &&\n-        ((CONT->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n-         (CONT->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {\n-        if ((NODE == NULL) ||\n-            (!xmlStrEqual(NODE->name, CONT->c1->name))) {\n+            \/*\n+             * save the second branch 'or' branch\n+             *\/\n+            DEBUG_VALID_MSG(\"saving 'or' branch\");\n+            if (vstateVPush(ctxt, CONT->c2, NODE, (unsigned char)(DEPTH + 1),\n+                            OCCURS, ROLLBACK_OR) < 0)\n+                return(-1);\n@@ -5044,1 +5033,1 @@\n-            CONT = CONT->c2;\n+            CONT = CONT->c1;\n@@ -5046,9 +5035,26 @@\n-        }\n-        if ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n-            ret = (CONT->c1->prefix == NULL);\n-        } else if (CONT->c1->prefix == NULL) {\n-            ret = 0;\n-        } else {\n-            ret = xmlStrEqual(NODE->ns->prefix, CONT->c1->prefix);\n-        }\n-        if (ret == 0) {\n+        case XML_ELEMENT_CONTENT_SEQ:\n+            \/*\n+             * Small optimization.\n+             *\/\n+            if ((CONT->c1->type == XML_ELEMENT_CONTENT_ELEMENT) &&\n+                ((CONT->c1->ocur == XML_ELEMENT_CONTENT_OPT) ||\n+                 (CONT->c1->ocur == XML_ELEMENT_CONTENT_MULT))) {\n+                if ((NODE == NULL) ||\n+                    (!xmlStrEqual(NODE->name, CONT->c1->name))) {\n+                    DEPTH++;\n+                    CONT = CONT->c2;\n+                    goto cont;\n+                }\n+                if ((NODE->ns == NULL) || (NODE->ns->prefix == NULL)) {\n+                    ret = (CONT->c1->prefix == NULL);\n+                } else if (CONT->c1->prefix == NULL) {\n+                    ret = 0;\n+                } else {\n+                    ret = xmlStrEqual(NODE->ns->prefix, CONT->c1->prefix);\n+                }\n+                if (ret == 0) {\n+                    DEPTH++;\n+                    CONT = CONT->c2;\n+                    goto cont;\n+                }\n+            }\n@@ -5056,1 +5062,1 @@\n-            CONT = CONT->c2;\n+            CONT = CONT->c1;\n@@ -5058,5 +5064,0 @@\n-        }\n-        }\n-        DEPTH++;\n-        CONT = CONT->c1;\n-        goto cont;\n@@ -5069,2 +5070,2 @@\n-    DEBUG_VALID_MSG(\"error found returning\");\n-    return(ret);\n+        DEBUG_VALID_MSG(\"error found returning\");\n+        return(ret);\n@@ -5074,34 +5075,34 @@\n-    \/*\n-     * First do the analysis depending on the occurrence model at\n-     * this level.\n-     *\/\n-    if (ret == 0) {\n-        switch (CONT->ocur) {\n-        xmlNodePtr cur;\n-\n-        case XML_ELEMENT_CONTENT_ONCE:\n-            cur = ctxt->vstate->node;\n-            DEBUG_VALID_MSG(\"Once branch failed, rollback\");\n-            if (vstateVPop(ctxt) < 0 ) {\n-            DEBUG_VALID_MSG(\"exhaustion, failed\");\n-            return(0);\n-            }\n-            if (cur != ctxt->vstate->node)\n-            determinist = -3;\n-            goto cont;\n-        case XML_ELEMENT_CONTENT_PLUS:\n-            if (OCCURRENCE == 0) {\n-            cur = ctxt->vstate->node;\n-            DEBUG_VALID_MSG(\"Plus branch failed, rollback\");\n-            if (vstateVPop(ctxt) < 0 ) {\n-                DEBUG_VALID_MSG(\"exhaustion, failed\");\n-                return(0);\n-            }\n-            if (cur != ctxt->vstate->node)\n-                determinist = -3;\n-            goto cont;\n-            }\n-            DEBUG_VALID_MSG(\"Plus branch found\");\n-            ret = 1;\n-            break;\n-        case XML_ELEMENT_CONTENT_MULT:\n+        \/*\n+         * First do the analysis depending on the occurrence model at\n+         * this level.\n+         *\/\n+        if (ret == 0) {\n+            switch (CONT->ocur) {\n+                xmlNodePtr cur;\n+\n+                case XML_ELEMENT_CONTENT_ONCE:\n+                    cur = ctxt->vstate->node;\n+                    DEBUG_VALID_MSG(\"Once branch failed, rollback\");\n+                    if (vstateVPop(ctxt) < 0 ) {\n+                        DEBUG_VALID_MSG(\"exhaustion, failed\");\n+                        return(0);\n+                    }\n+                    if (cur != ctxt->vstate->node)\n+                        determinist = -3;\n+                    goto cont;\n+                case XML_ELEMENT_CONTENT_PLUS:\n+                    if (OCCURRENCE == 0) {\n+                        cur = ctxt->vstate->node;\n+                        DEBUG_VALID_MSG(\"Plus branch failed, rollback\");\n+                        if (vstateVPop(ctxt) < 0 ) {\n+                            DEBUG_VALID_MSG(\"exhaustion, failed\");\n+                            return(0);\n+                        }\n+                        if (cur != ctxt->vstate->node)\n+                            determinist = -3;\n+                        goto cont;\n+                    }\n+                    DEBUG_VALID_MSG(\"Plus branch found\");\n+                    ret = 1;\n+                    break;\n+                case XML_ELEMENT_CONTENT_MULT:\n@@ -5109,5 +5110,5 @@\n-            if (OCCURRENCE == 0) {\n-            DEBUG_VALID_MSG(\"Mult branch failed\");\n-            } else {\n-            DEBUG_VALID_MSG(\"Mult branch found\");\n-            }\n+                    if (OCCURRENCE == 0) {\n+                        DEBUG_VALID_MSG(\"Mult branch failed\");\n+                    } else {\n+                        DEBUG_VALID_MSG(\"Mult branch found\");\n+                    }\n@@ -5115,36 +5116,6 @@\n-            ret = 1;\n-            break;\n-        case XML_ELEMENT_CONTENT_OPT:\n-            DEBUG_VALID_MSG(\"Option branch failed\");\n-            ret = 1;\n-            break;\n-        }\n-    } else {\n-        switch (CONT->ocur) {\n-        case XML_ELEMENT_CONTENT_OPT:\n-            DEBUG_VALID_MSG(\"Option branch succeeded\");\n-            ret = 1;\n-            break;\n-        case XML_ELEMENT_CONTENT_ONCE:\n-            DEBUG_VALID_MSG(\"Once branch succeeded\");\n-            ret = 1;\n-            break;\n-        case XML_ELEMENT_CONTENT_PLUS:\n-            if (STATE == ROLLBACK_PARENT) {\n-            DEBUG_VALID_MSG(\"Plus branch rollback\");\n-            ret = 1;\n-            break;\n-            }\n-            if (NODE == NULL) {\n-            DEBUG_VALID_MSG(\"Plus branch exhausted\");\n-            ret = 1;\n-            break;\n-            }\n-            DEBUG_VALID_MSG(\"Plus branch succeeded, continuing\");\n-            SET_OCCURRENCE;\n-            goto cont;\n-        case XML_ELEMENT_CONTENT_MULT:\n-            if (STATE == ROLLBACK_PARENT) {\n-            DEBUG_VALID_MSG(\"Mult branch rollback\");\n-            ret = 1;\n-            break;\n+                    ret = 1;\n+                    break;\n+                case XML_ELEMENT_CONTENT_OPT:\n+                    DEBUG_VALID_MSG(\"Option branch failed\");\n+                    ret = 1;\n+                    break;\n@@ -5152,4 +5123,38 @@\n-            if (NODE == NULL) {\n-            DEBUG_VALID_MSG(\"Mult branch exhausted\");\n-            ret = 1;\n-            break;\n+        } else {\n+            switch (CONT->ocur) {\n+                case XML_ELEMENT_CONTENT_OPT:\n+                    DEBUG_VALID_MSG(\"Option branch succeeded\");\n+                    ret = 1;\n+                    break;\n+                case XML_ELEMENT_CONTENT_ONCE:\n+                    DEBUG_VALID_MSG(\"Once branch succeeded\");\n+                    ret = 1;\n+                    break;\n+                case XML_ELEMENT_CONTENT_PLUS:\n+                    if (STATE == ROLLBACK_PARENT) {\n+                        DEBUG_VALID_MSG(\"Plus branch rollback\");\n+                        ret = 1;\n+                        break;\n+                    }\n+                    if (NODE == NULL) {\n+                        DEBUG_VALID_MSG(\"Plus branch exhausted\");\n+                        ret = 1;\n+                        break;\n+                    }\n+                    DEBUG_VALID_MSG(\"Plus branch succeeded, continuing\");\n+                    SET_OCCURRENCE;\n+                    goto cont;\n+                case XML_ELEMENT_CONTENT_MULT:\n+                    if (STATE == ROLLBACK_PARENT) {\n+                        DEBUG_VALID_MSG(\"Mult branch rollback\");\n+                        ret = 1;\n+                        break;\n+                    }\n+                    if (NODE == NULL) {\n+                        DEBUG_VALID_MSG(\"Mult branch exhausted\");\n+                        ret = 1;\n+                        break;\n+                    }\n+                    DEBUG_VALID_MSG(\"Mult branch succeeded, continuing\");\n+                    \/* SET_OCCURRENCE; *\/\n+                    goto cont;\n@@ -5157,3 +5162,0 @@\n-            DEBUG_VALID_MSG(\"Mult branch succeeded, continuing\");\n-            \/* SET_OCCURRENCE; *\/\n-            goto cont;\n@@ -5161,2 +5163,1 @@\n-    }\n-    STATE = 0;\n+        STATE = 0;\n@@ -5164,6 +5165,6 @@\n-    \/*\n-     * Then act accordingly at the parent level\n-     *\/\n-    RESET_OCCURRENCE;\n-    if (CONT->parent == NULL)\n-        break;\n+        \/*\n+         * Then act accordingly at the parent level\n+         *\/\n+        RESET_OCCURRENCE;\n+        if (CONT->parent == NULL)\n+            break;\n@@ -5171,31 +5172,32 @@\n-    switch (CONT->parent->type) {\n-        case XML_ELEMENT_CONTENT_PCDATA:\n-        DEBUG_VALID_MSG(\"Error: parent pcdata\");\n-        return(-1);\n-        case XML_ELEMENT_CONTENT_ELEMENT:\n-        DEBUG_VALID_MSG(\"Error: parent element\");\n-        return(-1);\n-        case XML_ELEMENT_CONTENT_OR:\n-        if (ret == 1) {\n-            DEBUG_VALID_MSG(\"Or succeeded\");\n-            CONT = CONT->parent;\n-            DEPTH--;\n-        } else {\n-            DEBUG_VALID_MSG(\"Or failed\");\n-            CONT = CONT->parent;\n-            DEPTH--;\n-        }\n-        break;\n-        case XML_ELEMENT_CONTENT_SEQ:\n-        if (ret == 0) {\n-            DEBUG_VALID_MSG(\"Sequence failed\");\n-            CONT = CONT->parent;\n-            DEPTH--;\n-        } else if (CONT == CONT->parent->c1) {\n-            DEBUG_VALID_MSG(\"Sequence testing 2nd branch\");\n-            CONT = CONT->parent->c2;\n-            goto cont;\n-        } else {\n-            DEBUG_VALID_MSG(\"Sequence succeeded\");\n-            CONT = CONT->parent;\n-            DEPTH--;\n+        switch (CONT->parent->type) {\n+            case XML_ELEMENT_CONTENT_PCDATA:\n+                DEBUG_VALID_MSG(\"Error: parent pcdata\");\n+                return(-1);\n+            case XML_ELEMENT_CONTENT_ELEMENT:\n+                DEBUG_VALID_MSG(\"Error: parent element\");\n+                return(-1);\n+            case XML_ELEMENT_CONTENT_OR:\n+                if (ret == 1) {\n+                    DEBUG_VALID_MSG(\"Or succeeded\");\n+                    CONT = CONT->parent;\n+                    DEPTH--;\n+                } else {\n+                    DEBUG_VALID_MSG(\"Or failed\");\n+                    CONT = CONT->parent;\n+                    DEPTH--;\n+                }\n+                break;\n+            case XML_ELEMENT_CONTENT_SEQ:\n+                if (ret == 0) {\n+                    DEBUG_VALID_MSG(\"Sequence failed\");\n+                    CONT = CONT->parent;\n+                    DEPTH--;\n+                } else if (CONT == CONT->parent->c1) {\n+                    DEBUG_VALID_MSG(\"Sequence testing 2nd branch\");\n+                    CONT = CONT->parent->c2;\n+                    goto cont;\n+                } else {\n+                    DEBUG_VALID_MSG(\"Sequence succeeded\");\n+                    CONT = CONT->parent;\n+                    DEPTH--;\n+                }\n@@ -5204,1 +5206,0 @@\n-    }\n@@ -5206,1 +5207,1 @@\n-    xmlNodePtr cur;\n+        xmlNodePtr cur;\n@@ -5208,9 +5209,9 @@\n-    cur = ctxt->vstate->node;\n-    DEBUG_VALID_MSG(\"Failed, remaining input, rollback\");\n-    if (vstateVPop(ctxt) < 0 ) {\n-        DEBUG_VALID_MSG(\"exhaustion, failed\");\n-        return(0);\n-    }\n-    if (cur != ctxt->vstate->node)\n-        determinist = -3;\n-    goto cont;\n+        cur = ctxt->vstate->node;\n+        DEBUG_VALID_MSG(\"Failed, remaining input, rollback\");\n+        if (vstateVPop(ctxt) < 0 ) {\n+            DEBUG_VALID_MSG(\"exhaustion, failed\");\n+            return(0);\n+        }\n+        if (cur != ctxt->vstate->node)\n+            determinist = -3;\n+        goto cont;\n@@ -5219,1 +5220,1 @@\n-    xmlNodePtr cur;\n+        xmlNodePtr cur;\n@@ -5221,9 +5222,9 @@\n-    cur = ctxt->vstate->node;\n-    DEBUG_VALID_MSG(\"Failure, rollback\");\n-    if (vstateVPop(ctxt) < 0 ) {\n-        DEBUG_VALID_MSG(\"exhaustion, failed\");\n-        return(0);\n-    }\n-    if (cur != ctxt->vstate->node)\n-        determinist = -3;\n-    goto cont;\n+        cur = ctxt->vstate->node;\n+        DEBUG_VALID_MSG(\"Failure, rollback\");\n+        if (vstateVPop(ctxt) < 0 ) {\n+            DEBUG_VALID_MSG(\"exhaustion, failed\");\n+            return(0);\n+        }\n+        if (cur != ctxt->vstate->node)\n+            determinist = -3;\n+        goto cont;\n@@ -5254,10 +5255,2 @@\n-    len = strlen(buf);\n-    if (size - len < 50) {\n-        if ((size - len > 4) && (buf[len - 1] != '.'))\n-        strcat(buf, \" ...\");\n-        return;\n-    }\n-        switch (cur->type) {\n-            case XML_ELEMENT_NODE:\n-        if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n-            if (size - len < xmlStrlen(cur->ns->prefix) + 10) {\n+        len = strlen(buf);\n+        if (size - len < 50) {\n@@ -5267,3 +5260,0 @@\n-            }\n-            strcat(buf, (char *) cur->ns->prefix);\n-            strcat(buf, \":\");\n@@ -5271,0 +5261,11 @@\n+        switch (cur->type) {\n+            case XML_ELEMENT_NODE:\n+                if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n+                    if (size - len < xmlStrlen(cur->ns->prefix) + 10) {\n+                        if ((size - len > 4) && (buf[len - 1] != '.'))\n+                            strcat(buf, \" ...\");\n+                        return;\n+                    }\n+                    strcat(buf, (char *) cur->ns->prefix);\n+                    strcat(buf, \":\");\n+                }\n@@ -5272,8 +5273,8 @@\n-            if ((size - len > 4) && (buf[len - 1] != '.'))\n-            strcat(buf, \" ...\");\n-            return;\n-        }\n-            strcat(buf, (char *) cur->name);\n-        if (cur->next != NULL)\n-            strcat(buf, \" \");\n-        break;\n+                    if ((size - len > 4) && (buf[len - 1] != '.'))\n+                        strcat(buf, \" ...\");\n+                    return;\n+                }\n+                strcat(buf, (char *) cur->name);\n+                if (cur->next != NULL)\n+                    strcat(buf, \" \");\n+                break;\n@@ -5281,2 +5282,2 @@\n-        if (xmlIsBlankNode(cur))\n-            break;\n+                if (xmlIsBlankNode(cur))\n+                    break;\n@@ -5286,4 +5287,4 @@\n-            strcat(buf, \"CDATA\");\n-        if (cur->next != NULL)\n-            strcat(buf, \" \");\n-        break;\n+                strcat(buf, \"CDATA\");\n+                if (cur->next != NULL)\n+                    strcat(buf, \" \");\n+                break;\n@@ -5293,1 +5294,1 @@\n-        case XML_DOCB_DOCUMENT_NODE:\n+            case XML_DOCB_DOCUMENT_NODE:\n@@ -5295,1 +5296,1 @@\n-        case XML_HTML_DOCUMENT_NODE:\n+            case XML_HTML_DOCUMENT_NODE:\n@@ -5299,5 +5300,5 @@\n-        case XML_NAMESPACE_DECL:\n-            strcat(buf, \"???\");\n-        if (cur->next != NULL)\n-            strcat(buf, \" \");\n-        break;\n+            case XML_NAMESPACE_DECL:\n+                strcat(buf, \"???\");\n+                if (cur->next != NULL)\n+                    strcat(buf, \" \");\n+                break;\n@@ -5308,8 +5309,8 @@\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_ENTITY_DECL:\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        break;\n-    }\n-    cur = cur->next;\n+            case XML_ELEMENT_DECL:\n+            case XML_ATTRIBUTE_DECL:\n+            case XML_ENTITY_DECL:\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+                break;\n+        }\n+        cur = cur->next;\n@@ -5345,1 +5346,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5352,1 +5353,1 @@\n-    ret = xmlValidBuildContentModel(ctxt, elemDecl);\n+        ret = xmlValidBuildContentModel(ctxt, elemDecl);\n@@ -5354,5 +5355,0 @@\n-    return(-1);\n-    } else {\n-    xmlRegExecCtxtPtr exec;\n-\n-    if (!xmlRegexpIsDeterminist(elemDecl->contModel)) {\n@@ -5360,34 +5356,2 @@\n-    }\n-    ctxt->nodeMax = 0;\n-    ctxt->nodeNr = 0;\n-    ctxt->nodeTab = NULL;\n-    exec = xmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);\n-    if (exec != NULL) {\n-        cur = child;\n-        while (cur != NULL) {\n-        switch (cur->type) {\n-            case XML_ENTITY_REF_NODE:\n-            \/*\n-             * Push the current node to be able to roll back\n-             * and process within the entity\n-             *\/\n-            if ((cur->children != NULL) &&\n-                (cur->children->children != NULL)) {\n-                nodeVPush(ctxt, cur);\n-                cur = cur->children->children;\n-                continue;\n-            }\n-            break;\n-            case XML_TEXT_NODE:\n-            if (xmlIsBlankNode(cur))\n-                break;\n-            ret = 0;\n-            goto fail;\n-            case XML_CDATA_SECTION_NODE:\n-            \/* TODO *\/\n-            ret = 0;\n-            goto fail;\n-            case XML_ELEMENT_NODE:\n-            if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n-                xmlChar fn[50];\n-                xmlChar *fullname;\n+    } else {\n+        xmlRegExecCtxtPtr exec;\n@@ -5395,6 +5359,43 @@\n-                fullname = xmlBuildQName(cur->name,\n-                                     cur->ns->prefix, fn, 50);\n-                if (fullname == NULL) {\n-                ret = -1;\n-                goto fail;\n-                }\n+        if (!xmlRegexpIsDeterminist(elemDecl->contModel)) {\n+            return(-1);\n+        }\n+        ctxt->nodeMax = 0;\n+        ctxt->nodeNr = 0;\n+        ctxt->nodeTab = NULL;\n+        exec = xmlRegNewExecCtxt(elemDecl->contModel, NULL, NULL);\n+        if (exec != NULL) {\n+            cur = child;\n+            while (cur != NULL) {\n+                switch (cur->type) {\n+                    case XML_ENTITY_REF_NODE:\n+                        \/*\n+                         * Push the current node to be able to roll back\n+                         * and process within the entity\n+                         *\/\n+                        if ((cur->children != NULL) &&\n+                            (cur->children->children != NULL)) {\n+                            nodeVPush(ctxt, cur);\n+                            cur = cur->children->children;\n+                            continue;\n+                        }\n+                        break;\n+                    case XML_TEXT_NODE:\n+                        if (xmlIsBlankNode(cur))\n+                            break;\n+                        ret = 0;\n+                        goto fail;\n+                    case XML_CDATA_SECTION_NODE:\n+                        \/* TODO *\/\n+                        ret = 0;\n+                        goto fail;\n+                    case XML_ELEMENT_NODE:\n+                        if ((cur->ns != NULL) && (cur->ns->prefix != NULL)) {\n+                            xmlChar fn[50];\n+                            xmlChar *fullname;\n+\n+                            fullname = xmlBuildQName(cur->name,\n+                                                     cur->ns->prefix, fn, 50);\n+                            if (fullname == NULL) {\n+                                ret = -1;\n+                                goto fail;\n+                            }\n@@ -5402,4 +5403,19 @@\n-                if ((fullname != fn) && (fullname != cur->name))\n-                xmlFree(fullname);\n-            } else {\n-                ret = xmlRegExecPushString(exec, cur->name, NULL);\n+                            if ((fullname != fn) && (fullname != cur->name))\n+                                xmlFree(fullname);\n+                        } else {\n+                            ret = xmlRegExecPushString(exec, cur->name, NULL);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+                \/*\n+                 * Switch to next element\n+                 *\/\n+                cur = cur->next;\n+                while (cur == NULL) {\n+                    cur = nodeVPop(ctxt);\n+                    if (cur == NULL)\n+                        break;\n+                    cur = cur->next;\n+                }\n@@ -5407,16 +5423,1 @@\n-            break;\n-            default:\n-            break;\n-        }\n-        \/*\n-         * Switch to next element\n-         *\/\n-        cur = cur->next;\n-        while (cur == NULL) {\n-            cur = nodeVPop(ctxt);\n-            if (cur == NULL)\n-            break;\n-            cur = cur->next;\n-        }\n-        }\n-        ret = xmlRegExecPushString(exec, NULL, NULL);\n+            ret = xmlRegExecPushString(exec, NULL, NULL);\n@@ -5424,2 +5425,2 @@\n-        xmlRegFreeExecCtxt(exec);\n-    }\n+            xmlRegFreeExecCtxt(exec);\n+        }\n@@ -5433,1 +5434,1 @@\n-         ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n+                 ctxt->vstateMax * sizeof(ctxt->vstateTab[0]));\n@@ -5435,2 +5436,2 @@\n-    xmlVErrMemory(ctxt, \"malloc failed\");\n-    return(-1);\n+        xmlVErrMemory(ctxt, \"malloc failed\");\n+        return(-1);\n@@ -5442,91 +5443,2 @@\n-    ctxt->nodeNr = 0;\n-    ctxt->nodeTab = NULL;\n-    ctxt->vstate = &ctxt->vstateTab[0];\n-    ctxt->vstateNr = 1;\n-    CONT = cont;\n-    NODE = child;\n-    DEPTH = 0;\n-    OCCURS = 0;\n-    STATE = 0;\n-    ret = xmlValidateElementType(ctxt);\n-    if ((ret == -3) && (warn)) {\n-    xmlErrValidWarning(ctxt, child, XML_DTD_CONTENT_NOT_DETERMINIST,\n-           \"Content model for Element %s is ambiguous\\n\",\n-                       name, NULL, NULL);\n-    } else if (ret == -2) {\n-    \/*\n-     * An entities reference appeared at this level.\n-     * Build a minimal representation of this node content\n-     * sufficient to run the validation process on it\n-     *\/\n-    DEBUG_VALID_MSG(\"Found an entity reference, linearizing\");\n-    cur = child;\n-    while (cur != NULL) {\n-        switch (cur->type) {\n-        case XML_ENTITY_REF_NODE:\n-            \/*\n-             * Push the current node to be able to roll back\n-             * and process within the entity\n-             *\/\n-            if ((cur->children != NULL) &&\n-            (cur->children->children != NULL)) {\n-            nodeVPush(ctxt, cur);\n-            cur = cur->children->children;\n-            continue;\n-            }\n-            break;\n-        case XML_TEXT_NODE:\n-            if (xmlIsBlankNode(cur))\n-            break;\n-            \/* no break on purpose *\/\n-        case XML_CDATA_SECTION_NODE:\n-            \/* no break on purpose *\/\n-        case XML_ELEMENT_NODE:\n-            \/*\n-             * Allocate a new node and minimally fills in\n-             * what's required\n-             *\/\n-            tmp = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n-            if (tmp == NULL) {\n-            xmlVErrMemory(ctxt, \"malloc failed\");\n-            xmlFreeNodeList(repl);\n-            ret = -1;\n-            goto done;\n-            }\n-            tmp->type = cur->type;\n-            tmp->name = cur->name;\n-            tmp->ns = cur->ns;\n-            tmp->next = NULL;\n-            tmp->content = NULL;\n-            if (repl == NULL)\n-            repl = last = tmp;\n-            else {\n-            last->next = tmp;\n-            last = tmp;\n-            }\n-            if (cur->type == XML_CDATA_SECTION_NODE) {\n-            \/*\n-             * E59 spaces in CDATA does not match the\n-             * nonterminal S\n-             *\/\n-            tmp->content = xmlStrdup(BAD_CAST \"CDATA\");\n-            }\n-            break;\n-        default:\n-            break;\n-        }\n-        \/*\n-         * Switch to next element\n-         *\/\n-        cur = cur->next;\n-        while (cur == NULL) {\n-        cur = nodeVPop(ctxt);\n-        if (cur == NULL)\n-            break;\n-        cur = cur->next;\n-        }\n-    }\n-\n-    \/*\n-     * Relaunch the validation\n-     *\/\n+    ctxt->nodeNr = 0;\n+    ctxt->nodeTab = NULL;\n@@ -5536,1 +5448,1 @@\n-    NODE = repl;\n+    NODE = child;\n@@ -5541,0 +5453,89 @@\n+    if ((ret == -3) && (warn)) {\n+        xmlErrValidWarning(ctxt, child, XML_DTD_CONTENT_NOT_DETERMINIST,\n+               \"Content model for Element %s is ambiguous\\n\",\n+                           name, NULL, NULL);\n+    } else if (ret == -2) {\n+        \/*\n+         * An entities reference appeared at this level.\n+         * Build a minimal representation of this node content\n+         * sufficient to run the validation process on it\n+         *\/\n+        DEBUG_VALID_MSG(\"Found an entity reference, linearizing\");\n+        cur = child;\n+        while (cur != NULL) {\n+            switch (cur->type) {\n+                case XML_ENTITY_REF_NODE:\n+                    \/*\n+                     * Push the current node to be able to roll back\n+                     * and process within the entity\n+                     *\/\n+                    if ((cur->children != NULL) &&\n+                        (cur->children->children != NULL)) {\n+                        nodeVPush(ctxt, cur);\n+                        cur = cur->children->children;\n+                        continue;\n+                    }\n+                    break;\n+                case XML_TEXT_NODE:\n+                    if (xmlIsBlankNode(cur))\n+                        break;\n+                    \/* no break on purpose *\/\n+                case XML_CDATA_SECTION_NODE:\n+                    \/* no break on purpose *\/\n+                case XML_ELEMENT_NODE:\n+                    \/*\n+                     * Allocate a new node and minimally fills in\n+                     * what's required\n+                     *\/\n+                    tmp = (xmlNodePtr) xmlMalloc(sizeof(xmlNode));\n+                    if (tmp == NULL) {\n+                        xmlVErrMemory(ctxt, \"malloc failed\");\n+                        xmlFreeNodeList(repl);\n+                        ret = -1;\n+                        goto done;\n+                    }\n+                    tmp->type = cur->type;\n+                    tmp->name = cur->name;\n+                    tmp->ns = cur->ns;\n+                    tmp->next = NULL;\n+                    tmp->content = NULL;\n+                    if (repl == NULL)\n+                        repl = last = tmp;\n+                    else {\n+                        last->next = tmp;\n+                        last = tmp;\n+                    }\n+                    if (cur->type == XML_CDATA_SECTION_NODE) {\n+                        \/*\n+                         * E59 spaces in CDATA does not match the\n+                         * nonterminal S\n+                         *\/\n+                        tmp->content = xmlStrdup(BAD_CAST \"CDATA\");\n+                    }\n+                    break;\n+                default:\n+                    break;\n+            }\n+            \/*\n+             * Switch to next element\n+             *\/\n+            cur = cur->next;\n+            while (cur == NULL) {\n+                cur = nodeVPop(ctxt);\n+                if (cur == NULL)\n+                    break;\n+                cur = cur->next;\n+            }\n+        }\n+\n+        \/*\n+         * Relaunch the validation\n+         *\/\n+        ctxt->vstate = &ctxt->vstateTab[0];\n+        ctxt->vstateNr = 1;\n+        CONT = cont;\n+        NODE = repl;\n+        DEPTH = 0;\n+        OCCURS = 0;\n+        STATE = 0;\n+        ret = xmlValidateElementType(ctxt);\n@@ -5544,3 +5545,3 @@\n-    if (ctxt != NULL) {\n-        char expr[5000];\n-        char list[5000];\n+        if (ctxt != NULL) {\n+            char expr[5000];\n+            char list[5000];\n@@ -5548,3 +5549,3 @@\n-        expr[0] = 0;\n-        xmlSnprintfElementContent(&expr[0], 5000, cont, 1);\n-        list[0] = 0;\n+            expr[0] = 0;\n+            xmlSnprintfElementContent(&expr[0], 5000, cont, 1);\n+            list[0] = 0;\n@@ -5552,3 +5553,3 @@\n-        if (repl != NULL)\n-        xmlSnprintfElements(&list[0], 5000, repl, 1);\n-        else\n+            if (repl != NULL)\n+                xmlSnprintfElements(&list[0], 5000, repl, 1);\n+            else\n@@ -5556,1 +5557,1 @@\n-        xmlSnprintfElements(&list[0], 5000, child, 1);\n+                xmlSnprintfElements(&list[0], 5000, child, 1);\n@@ -5558,14 +5559,9 @@\n-        if (name != NULL) {\n-        xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n-       \"Element %s content does not follow the DTD, expecting %s, got %s\\n\",\n-               name, BAD_CAST expr, BAD_CAST list);\n-        } else {\n-        xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n-       \"Element content does not follow the DTD, expecting %s, got %s\\n\",\n-               BAD_CAST expr, BAD_CAST list, NULL);\n-        }\n-    } else {\n-        if (name != NULL) {\n-        xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n-               \"Element %s content does not follow the DTD\\n\",\n-               name, NULL, NULL);\n+            if (name != NULL) {\n+                xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n+           \"Element %s content does not follow the DTD, expecting %s, got %s\\n\",\n+                       name, BAD_CAST expr, BAD_CAST list);\n+            } else {\n+                xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n+           \"Element content does not follow the DTD, expecting %s, got %s\\n\",\n+                       BAD_CAST expr, BAD_CAST list, NULL);\n+            }\n@@ -5573,3 +5569,9 @@\n-        xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n-               \"Element content does not follow the DTD\\n\",\n-                        NULL, NULL, NULL);\n+            if (name != NULL) {\n+                xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n+                       \"Element %s content does not follow the DTD\\n\",\n+                       name, NULL, NULL);\n+            } else {\n+                xmlErrValidNode(ctxt, parent, XML_DTD_CONTENT_MODEL,\n+                       \"Element content does not follow the DTD\\n\",\n+                                NULL, NULL, NULL);\n+            }\n@@ -5577,2 +5579,1 @@\n-    }\n-    ret = 0;\n+        ret = 0;\n@@ -5581,1 +5582,1 @@\n-    ret = 1;\n+        ret = 1;\n@@ -5589,3 +5590,3 @@\n-    tmp = repl->next;\n-    xmlFree(repl);\n-    repl = tmp;\n+        tmp = repl->next;\n+        xmlFree(repl);\n+        repl = tmp;\n@@ -5595,2 +5596,2 @@\n-    xmlFree(ctxt->vstateTab);\n-    ctxt->vstateTab = NULL;\n+        xmlFree(ctxt->vstateTab);\n+        ctxt->vstateTab = NULL;\n@@ -5602,2 +5603,2 @@\n-    xmlFree(ctxt->nodeTab);\n-    ctxt->nodeTab = NULL;\n+        xmlFree(ctxt->nodeTab);\n+        ctxt->nodeTab = NULL;\n@@ -5627,1 +5628,1 @@\n-    return(0);\n+        return(0);\n@@ -5633,2 +5634,22 @@\n-    switch (cur->type) {\n-        case XML_ENTITY_REF_NODE:\n+        switch (cur->type) {\n+            case XML_ENTITY_REF_NODE:\n+                \/*\n+                 * Push the current node to be able to roll back\n+                 * and process within the entity\n+                 *\/\n+                if ((cur->children != NULL) &&\n+                    (cur->children->children != NULL)) {\n+                    nodeVPush(ctxt, cur);\n+                    cur = cur->children->children;\n+                    continue;\n+                }\n+                break;\n+            case XML_COMMENT_NODE:\n+            case XML_PI_NODE:\n+            case XML_TEXT_NODE:\n+            case XML_CDATA_SECTION_NODE:\n+                break;\n+            default:\n+                ret = 0;\n+                goto done;\n+        }\n@@ -5636,2 +5657,1 @@\n-         * Push the current node to be able to roll back\n-         * and process within the entity\n+         * Switch to next element\n@@ -5639,24 +5659,0 @@\n-        if ((cur->children != NULL) &&\n-            (cur->children->children != NULL)) {\n-            nodeVPush(ctxt, cur);\n-            cur = cur->children->children;\n-            continue;\n-        }\n-        break;\n-        case XML_COMMENT_NODE:\n-        case XML_PI_NODE:\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        break;\n-        default:\n-        ret = 0;\n-        goto done;\n-    }\n-    \/*\n-     * Switch to next element\n-     *\/\n-    cur = cur->next;\n-    while (cur == NULL) {\n-        cur = nodeVPop(ctxt);\n-        if (cur == NULL)\n-        break;\n@@ -5664,1 +5660,6 @@\n-    }\n+        while (cur == NULL) {\n+            cur = nodeVPop(ctxt);\n+            if (cur == NULL)\n+                break;\n+            cur = cur->next;\n+        }\n@@ -5670,2 +5671,2 @@\n-    xmlFree(ctxt->nodeTab);\n-    ctxt->nodeTab = NULL;\n+        xmlFree(ctxt->nodeTab);\n+        ctxt->nodeTab = NULL;\n@@ -5688,1 +5689,1 @@\n-                  xmlElementContentPtr cont, const xmlChar *qname) {\n+                      xmlElementContentPtr cont, const xmlChar *qname) {\n@@ -5694,17 +5695,19 @@\n-    while (cont != NULL) {\n-        if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n-        if ((cont->prefix == NULL) && (xmlStrEqual(cont->name, qname)))\n-            return(1);\n-        } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n-           (cont->c1 != NULL) &&\n-           (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n-        if ((cont->c1->prefix == NULL) &&\n-            (xmlStrEqual(cont->c1->name, qname)))\n-            return(1);\n-        } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n-        (cont->c1 == NULL) ||\n-        (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n-        xmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,\n-            \"Internal: MIXED struct corrupted\\n\",\n-            NULL);\n-        break;\n+        while (cont != NULL) {\n+            if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n+                if ((cont->prefix == NULL) && (xmlStrEqual(cont->name, qname)))\n+                    return(1);\n+            } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n+               (cont->c1 != NULL) &&\n+               (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n+                if ((cont->c1->prefix == NULL) &&\n+                    (xmlStrEqual(cont->c1->name, qname)))\n+                    return(1);\n+            } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n+                (cont->c1 == NULL) ||\n+                (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n+                xmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,\n+                        \"Internal: MIXED struct corrupted\\n\",\n+                        NULL);\n+                break;\n+            }\n+            cont = cont->c2;\n@@ -5712,2 +5715,0 @@\n-        cont = cont->c2;\n-    }\n@@ -5715,20 +5716,22 @@\n-    while (cont != NULL) {\n-        if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n-        if ((cont->prefix != NULL) &&\n-            (xmlStrncmp(cont->prefix, qname, plen) == 0) &&\n-            (xmlStrEqual(cont->name, name)))\n-            return(1);\n-        } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n-           (cont->c1 != NULL) &&\n-           (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n-        if ((cont->c1->prefix != NULL) &&\n-            (xmlStrncmp(cont->c1->prefix, qname, plen) == 0) &&\n-            (xmlStrEqual(cont->c1->name, name)))\n-            return(1);\n-        } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n-        (cont->c1 == NULL) ||\n-        (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n-        xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,\n-            \"Internal: MIXED struct corrupted\\n\",\n-            NULL);\n-        break;\n+        while (cont != NULL) {\n+            if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n+                if ((cont->prefix != NULL) &&\n+                    (xmlStrncmp(cont->prefix, qname, plen) == 0) &&\n+                    (xmlStrEqual(cont->name, name)))\n+                    return(1);\n+            } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n+               (cont->c1 != NULL) &&\n+               (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n+                if ((cont->c1->prefix != NULL) &&\n+                    (xmlStrncmp(cont->c1->prefix, qname, plen) == 0) &&\n+                    (xmlStrEqual(cont->c1->name, name)))\n+                    return(1);\n+            } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n+                (cont->c1 == NULL) ||\n+                (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n+                xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,\n+                        \"Internal: MIXED struct corrupted\\n\",\n+                        NULL);\n+                break;\n+            }\n+            cont = cont->c2;\n@@ -5736,2 +5739,0 @@\n-        cont = cont->c2;\n-    }\n@@ -5756,1 +5757,1 @@\n-                xmlNodePtr elem, int *extsubset) {\n+                    xmlNodePtr elem, int *extsubset) {\n@@ -5764,1 +5765,1 @@\n-    *extsubset = 0;\n+        *extsubset = 0;\n@@ -5770,1 +5771,1 @@\n-    prefix = elem->ns->prefix;\n+        prefix = elem->ns->prefix;\n@@ -5773,8 +5774,8 @@\n-    elemDecl = xmlGetDtdQElementDesc(doc->intSubset,\n-                                 elem->name, prefix);\n-    if ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n-        elemDecl = xmlGetDtdQElementDesc(doc->extSubset,\n-                                     elem->name, prefix);\n-        if ((elemDecl != NULL) && (extsubset != NULL))\n-        *extsubset = 1;\n-    }\n+        elemDecl = xmlGetDtdQElementDesc(doc->intSubset,\n+                                         elem->name, prefix);\n+        if ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n+            elemDecl = xmlGetDtdQElementDesc(doc->extSubset,\n+                                             elem->name, prefix);\n+            if ((elemDecl != NULL) && (extsubset != NULL))\n+                *extsubset = 1;\n+        }\n@@ -5789,6 +5790,6 @@\n-    elemDecl = xmlGetDtdElementDesc(doc->intSubset, elem->name);\n-    if ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n-        elemDecl = xmlGetDtdElementDesc(doc->extSubset, elem->name);\n-        if ((elemDecl != NULL) && (extsubset != NULL))\n-        *extsubset = 1;\n-    }\n+        elemDecl = xmlGetDtdElementDesc(doc->intSubset, elem->name);\n+        if ((elemDecl == NULL) && (doc->extSubset != NULL)) {\n+            elemDecl = xmlGetDtdElementDesc(doc->extSubset, elem->name);\n+            if ((elemDecl != NULL) && (extsubset != NULL))\n+                *extsubset = 1;\n+        }\n@@ -5797,4 +5798,4 @@\n-    xmlErrValidNode(ctxt, elem,\n-            XML_DTD_UNKNOWN_ELEM,\n-           \"No declaration for element %s\\n\",\n-           elem->name, NULL, NULL);\n+        xmlErrValidNode(ctxt, elem,\n+                        XML_DTD_UNKNOWN_ELEM,\n+               \"No declaration for element %s\\n\",\n+               elem->name, NULL, NULL);\n@@ -5828,2 +5829,2 @@\n-    xmlValidStatePtr state = ctxt->vstate;\n-    xmlElementPtr elemDecl;\n+        xmlValidStatePtr state = ctxt->vstate;\n+        xmlElementPtr elemDecl;\n@@ -5831,5 +5832,5 @@\n-    \/*\n-     * Check the new element against the content model of the new elem.\n-     *\/\n-    if (state->elemDecl != NULL) {\n-        elemDecl = state->elemDecl;\n+        \/*\n+         * Check the new element against the content model of the new elem.\n+         *\/\n+        if (state->elemDecl != NULL) {\n+            elemDecl = state->elemDecl;\n@@ -5837,53 +5838,55 @@\n-        switch(elemDecl->etype) {\n-        case XML_ELEMENT_TYPE_UNDEFINED:\n-            ret = 0;\n-            break;\n-        case XML_ELEMENT_TYPE_EMPTY:\n-            xmlErrValidNode(ctxt, state->node,\n-                    XML_DTD_NOT_EMPTY,\n-           \"Element %s was declared EMPTY this one has content\\n\",\n-               state->node->name, NULL, NULL);\n-            ret = 0;\n-            break;\n-        case XML_ELEMENT_TYPE_ANY:\n-            \/* I don't think anything is required then *\/\n-            break;\n-        case XML_ELEMENT_TYPE_MIXED:\n-            \/* simple case of declared as #PCDATA *\/\n-            if ((elemDecl->content != NULL) &&\n-            (elemDecl->content->type ==\n-             XML_ELEMENT_CONTENT_PCDATA)) {\n-            xmlErrValidNode(ctxt, state->node,\n-                    XML_DTD_NOT_PCDATA,\n-           \"Element %s was declared #PCDATA but contains non text nodes\\n\",\n-                state->node->name, NULL, NULL);\n-            ret = 0;\n-            } else {\n-            ret = xmlValidateCheckMixed(ctxt, elemDecl->content,\n-                                    qname);\n-            if (ret != 1) {\n-                xmlErrValidNode(ctxt, state->node,\n-                        XML_DTD_INVALID_CHILD,\n-           \"Element %s is not declared in %s list of possible children\\n\",\n-                    qname, state->node->name, NULL);\n-            }\n-            }\n-            break;\n-        case XML_ELEMENT_TYPE_ELEMENT:\n-            \/*\n-             * TODO:\n-             * VC: Standalone Document Declaration\n-             *     - element types with element content, if white space\n-             *       occurs directly within any instance of those types.\n-             *\/\n-            if (state->exec != NULL) {\n-            ret = xmlRegExecPushString(state->exec, qname, NULL);\n-            if (ret < 0) {\n-                xmlErrValidNode(ctxt, state->node,\n-                        XML_DTD_CONTENT_MODEL,\n-           \"Element %s content does not follow the DTD, Misplaced %s\\n\",\n-                   state->node->name, qname, NULL);\n-                ret = 0;\n-            } else {\n-                ret = 1;\n-            }\n+            switch(elemDecl->etype) {\n+                case XML_ELEMENT_TYPE_UNDEFINED:\n+                    ret = 0;\n+                    break;\n+                case XML_ELEMENT_TYPE_EMPTY:\n+                    xmlErrValidNode(ctxt, state->node,\n+                                    XML_DTD_NOT_EMPTY,\n+               \"Element %s was declared EMPTY this one has content\\n\",\n+                           state->node->name, NULL, NULL);\n+                    ret = 0;\n+                    break;\n+                case XML_ELEMENT_TYPE_ANY:\n+                    \/* I don't think anything is required then *\/\n+                    break;\n+                case XML_ELEMENT_TYPE_MIXED:\n+                    \/* simple case of declared as #PCDATA *\/\n+                    if ((elemDecl->content != NULL) &&\n+                        (elemDecl->content->type ==\n+                         XML_ELEMENT_CONTENT_PCDATA)) {\n+                        xmlErrValidNode(ctxt, state->node,\n+                                        XML_DTD_NOT_PCDATA,\n+               \"Element %s was declared #PCDATA but contains non text nodes\\n\",\n+                                state->node->name, NULL, NULL);\n+                        ret = 0;\n+                    } else {\n+                        ret = xmlValidateCheckMixed(ctxt, elemDecl->content,\n+                                                    qname);\n+                        if (ret != 1) {\n+                            xmlErrValidNode(ctxt, state->node,\n+                                            XML_DTD_INVALID_CHILD,\n+               \"Element %s is not declared in %s list of possible children\\n\",\n+                                    qname, state->node->name, NULL);\n+                        }\n+                    }\n+                    break;\n+                case XML_ELEMENT_TYPE_ELEMENT:\n+                    \/*\n+                     * TODO:\n+                     * VC: Standalone Document Declaration\n+                     *     - element types with element content, if white space\n+                     *       occurs directly within any instance of those types.\n+                     *\/\n+                    if (state->exec != NULL) {\n+                        ret = xmlRegExecPushString(state->exec, qname, NULL);\n+                        if (ret < 0) {\n+                            xmlErrValidNode(ctxt, state->node,\n+                                            XML_DTD_CONTENT_MODEL,\n+               \"Element %s content does not follow the DTD, Misplaced %s\\n\",\n+                                   state->node->name, qname, NULL);\n+                            ret = 0;\n+                        } else {\n+                            ret = 1;\n+                        }\n+                    }\n+                    break;\n@@ -5891,1 +5894,0 @@\n-            break;\n@@ -5894,1 +5896,0 @@\n-    }\n@@ -5918,1 +5919,1 @@\n-    return(ret);\n+        return(ret);\n@@ -5920,2 +5921,2 @@\n-    xmlValidStatePtr state = ctxt->vstate;\n-    xmlElementPtr elemDecl;\n+        xmlValidStatePtr state = ctxt->vstate;\n+        xmlElementPtr elemDecl;\n@@ -5923,5 +5924,5 @@\n-    \/*\n-     * Check the new element against the content model of the new elem.\n-     *\/\n-    if (state->elemDecl != NULL) {\n-        elemDecl = state->elemDecl;\n+        \/*\n+         * Check the new element against the content model of the new elem.\n+         *\/\n+        if (state->elemDecl != NULL) {\n+            elemDecl = state->elemDecl;\n@@ -5929,16 +5930,16 @@\n-        switch(elemDecl->etype) {\n-        case XML_ELEMENT_TYPE_UNDEFINED:\n-            ret = 0;\n-            break;\n-        case XML_ELEMENT_TYPE_EMPTY:\n-            xmlErrValidNode(ctxt, state->node,\n-                    XML_DTD_NOT_EMPTY,\n-           \"Element %s was declared EMPTY this one has content\\n\",\n-               state->node->name, NULL, NULL);\n-            ret = 0;\n-            break;\n-        case XML_ELEMENT_TYPE_ANY:\n-            break;\n-        case XML_ELEMENT_TYPE_MIXED:\n-            break;\n-        case XML_ELEMENT_TYPE_ELEMENT: {\n+            switch(elemDecl->etype) {\n+                case XML_ELEMENT_TYPE_UNDEFINED:\n+                    ret = 0;\n+                    break;\n+                case XML_ELEMENT_TYPE_EMPTY:\n+                    xmlErrValidNode(ctxt, state->node,\n+                                    XML_DTD_NOT_EMPTY,\n+               \"Element %s was declared EMPTY this one has content\\n\",\n+                           state->node->name, NULL, NULL);\n+                    ret = 0;\n+                    break;\n+                case XML_ELEMENT_TYPE_ANY:\n+                    break;\n+                case XML_ELEMENT_TYPE_MIXED:\n+                    break;\n+                case XML_ELEMENT_TYPE_ELEMENT: {\n@@ -5965,0 +5966,1 @@\n+            }\n@@ -5967,1 +5969,0 @@\n-    }\n@@ -5986,1 +5987,1 @@\n-              const xmlChar *qname ATTRIBUTE_UNUSED) {\n+                      const xmlChar *qname ATTRIBUTE_UNUSED) {\n@@ -5993,2 +5994,2 @@\n-    xmlValidStatePtr state = ctxt->vstate;\n-    xmlElementPtr elemDecl;\n+        xmlValidStatePtr state = ctxt->vstate;\n+        xmlElementPtr elemDecl;\n@@ -5996,20 +5997,22 @@\n-    \/*\n-     * Check the new element against the content model of the new elem.\n-     *\/\n-    if (state->elemDecl != NULL) {\n-        elemDecl = state->elemDecl;\n-\n-        if (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT) {\n-        if (state->exec != NULL) {\n-            ret = xmlRegExecPushString(state->exec, NULL, NULL);\n-            if (ret == 0) {\n-            xmlErrValidNode(ctxt, state->node,\n-                            XML_DTD_CONTENT_MODEL,\n-       \"Element %s content does not follow the DTD, Expecting more child\\n\",\n-                   state->node->name, NULL,NULL);\n-            } else {\n-            \/*\n-             * previous validation errors should not generate\n-             * a new one here\n-             *\/\n-            ret = 1;\n+        \/*\n+         * Check the new element against the content model of the new elem.\n+         *\/\n+        if (state->elemDecl != NULL) {\n+            elemDecl = state->elemDecl;\n+\n+            if (elemDecl->etype == XML_ELEMENT_TYPE_ELEMENT) {\n+                if (state->exec != NULL) {\n+                    ret = xmlRegExecPushString(state->exec, NULL, NULL);\n+                    if (ret == 0) {\n+                        xmlErrValidNode(ctxt, state->node,\n+                                        XML_DTD_CONTENT_MODEL,\n+           \"Element %s content does not follow the DTD, Expecting more child\\n\",\n+                               state->node->name, NULL,NULL);\n+                    } else {\n+                        \/*\n+                         * previous validation errors should not generate\n+                         * a new one here\n+                         *\/\n+                        ret = 1;\n+                    }\n+                }\n@@ -6018,3 +6021,1 @@\n-        }\n-    }\n-    vstateVPop(ctxt);\n+        vstateVPop(ctxt);\n@@ -6060,3 +6061,3 @@\n-        xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n-           \"Attribute element not expected\\n\", NULL, NULL ,NULL);\n-        return(0);\n+            xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n+                   \"Attribute element not expected\\n\", NULL, NULL ,NULL);\n+            return(0);\n@@ -6064,19 +6065,19 @@\n-        if (elem->children != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n-                        \"Text element has children !\\n\",\n-                NULL,NULL,NULL);\n-        return(0);\n-        }\n-        if (elem->ns != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n-                        \"Text element has namespace !\\n\",\n-                NULL,NULL,NULL);\n-        return(0);\n-        }\n-        if (elem->content == NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n-                        \"Text element has no content !\\n\",\n-                NULL,NULL,NULL);\n-        return(0);\n-        }\n-        return(1);\n+            if (elem->children != NULL) {\n+                xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n+                                \"Text element has children !\\n\",\n+                                NULL,NULL,NULL);\n+                return(0);\n+            }\n+            if (elem->ns != NULL) {\n+                xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n+                                \"Text element has namespace !\\n\",\n+                                NULL,NULL,NULL);\n+                return(0);\n+            }\n+            if (elem->content == NULL) {\n+                xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n+                                \"Text element has no content !\\n\",\n+                                NULL,NULL,NULL);\n+                return(0);\n+            }\n+            return(1);\n@@ -6090,1 +6091,1 @@\n-        return(1);\n+            return(1);\n@@ -6092,3 +6093,3 @@\n-        xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n-           \"Entity element not expected\\n\", NULL, NULL ,NULL);\n-        return(0);\n+            xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n+                   \"Entity element not expected\\n\", NULL, NULL ,NULL);\n+            return(0);\n@@ -6096,3 +6097,3 @@\n-        xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n-           \"Notation element not expected\\n\", NULL, NULL ,NULL);\n-        return(0);\n+            xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n+                   \"Notation element not expected\\n\", NULL, NULL ,NULL);\n+            return(0);\n@@ -6102,3 +6103,3 @@\n-        xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n-           \"Document element not expected\\n\", NULL, NULL ,NULL);\n-        return(0);\n+            xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n+                   \"Document element not expected\\n\", NULL, NULL ,NULL);\n+            return(0);\n@@ -6106,3 +6107,3 @@\n-        xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n-           \"HTML Document not expected\\n\", NULL, NULL ,NULL);\n-        return(0);\n+            xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n+                   \"HTML Document not expected\\n\", NULL, NULL ,NULL);\n+            return(0);\n@@ -6110,5 +6111,5 @@\n-        break;\n-    default:\n-        xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n-           \"unknown element type\\n\", NULL, NULL ,NULL);\n-        return(0);\n+            break;\n+        default:\n+            xmlErrValidNode(ctxt, elem, XML_ERR_INTERNAL_ERROR,\n+                   \"unknown element type\\n\", NULL, NULL ,NULL);\n+            return(0);\n@@ -6122,1 +6123,1 @@\n-    return(0);\n+        return(0);\n@@ -6132,8 +6133,2 @@\n-        xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ELEM,\n-                        \"No declaration for element %s\\n\",\n-           elem->name, NULL, NULL);\n-        return(0);\n-        case XML_ELEMENT_TYPE_EMPTY:\n-        if (elem->children != NULL) {\n-        xmlErrValidNode(ctxt, elem, XML_DTD_NOT_EMPTY,\n-           \"Element %s was declared EMPTY this one has content\\n\",\n+            xmlErrValidNode(ctxt, elem, XML_DTD_UNKNOWN_ELEM,\n+                            \"No declaration for element %s\\n\",\n@@ -6141,56 +6136,7 @@\n-        ret = 0;\n-        }\n-        break;\n-        case XML_ELEMENT_TYPE_ANY:\n-        \/* I don't think anything is required then *\/\n-        break;\n-        case XML_ELEMENT_TYPE_MIXED:\n-\n-        \/* simple case of declared as #PCDATA *\/\n-        if ((elemDecl->content != NULL) &&\n-        (elemDecl->content->type == XML_ELEMENT_CONTENT_PCDATA)) {\n-        ret = xmlValidateOneCdataElement(ctxt, doc, elem);\n-        if (!ret) {\n-            xmlErrValidNode(ctxt, elem, XML_DTD_NOT_PCDATA,\n-           \"Element %s was declared #PCDATA but contains non text nodes\\n\",\n-               elem->name, NULL, NULL);\n-        }\n-        break;\n-        }\n-        child = elem->children;\n-        \/* Hum, this start to get messy *\/\n-        while (child != NULL) {\n-            if (child->type == XML_ELEMENT_NODE) {\n-            name = child->name;\n-            if ((child->ns != NULL) && (child->ns->prefix != NULL)) {\n-            xmlChar fn[50];\n-            xmlChar *fullname;\n-\n-            fullname = xmlBuildQName(child->name, child->ns->prefix,\n-                                 fn, 50);\n-            if (fullname == NULL)\n-                return(0);\n-            cont = elemDecl->content;\n-            while (cont != NULL) {\n-                if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n-                if (xmlStrEqual(cont->name, fullname))\n-                    break;\n-                } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n-                   (cont->c1 != NULL) &&\n-                   (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n-                if (xmlStrEqual(cont->c1->name, fullname))\n-                    break;\n-                } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n-                (cont->c1 == NULL) ||\n-                (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n-                xmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,\n-                    \"Internal: MIXED struct corrupted\\n\",\n-                    NULL);\n-                break;\n-                }\n-                cont = cont->c2;\n-            }\n-            if ((fullname != fn) && (fullname != child->name))\n-                xmlFree(fullname);\n-            if (cont != NULL)\n-                goto child_ok;\n+            return(0);\n+        case XML_ELEMENT_TYPE_EMPTY:\n+            if (elem->children != NULL) {\n+                xmlErrValidNode(ctxt, elem, XML_DTD_NOT_EMPTY,\n+               \"Element %s was declared EMPTY this one has content\\n\",\n+                       elem->name, NULL, NULL);\n+                ret = 0;\n@@ -6198,14 +6144,15 @@\n-            cont = elemDecl->content;\n-            while (cont != NULL) {\n-                if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n-                if (xmlStrEqual(cont->name, name)) break;\n-            } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n-               (cont->c1 != NULL) &&\n-               (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)) {\n-                if (xmlStrEqual(cont->c1->name, name)) break;\n-            } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n-                (cont->c1 == NULL) ||\n-                (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)) {\n-                xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,\n-                    \"Internal: MIXED struct corrupted\\n\",\n-                    NULL);\n+            break;\n+        case XML_ELEMENT_TYPE_ANY:\n+            \/* I don't think anything is required then *\/\n+            break;\n+        case XML_ELEMENT_TYPE_MIXED:\n+\n+            \/* simple case of declared as #PCDATA *\/\n+            if ((elemDecl->content != NULL) &&\n+                (elemDecl->content->type == XML_ELEMENT_CONTENT_PCDATA)) {\n+                ret = xmlValidateOneCdataElement(ctxt, doc, elem);\n+                if (!ret) {\n+                    xmlErrValidNode(ctxt, elem, XML_DTD_NOT_PCDATA,\n+               \"Element %s was declared #PCDATA but contains non text nodes\\n\",\n+                           elem->name, NULL, NULL);\n+                }\n@@ -6214,9 +6161,63 @@\n-            cont = cont->c2;\n-            }\n-            if (cont == NULL) {\n-            xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_CHILD,\n-           \"Element %s is not declared in %s list of possible children\\n\",\n-                   name, elem->name, NULL);\n-            ret = 0;\n-            }\n-        }\n+            child = elem->children;\n+            \/* Hum, this start to get messy *\/\n+            while (child != NULL) {\n+                if (child->type == XML_ELEMENT_NODE) {\n+                    name = child->name;\n+                    if ((child->ns != NULL) && (child->ns->prefix != NULL)) {\n+                        xmlChar fn[50];\n+                        xmlChar *fullname;\n+\n+                        fullname = xmlBuildQName(child->name, child->ns->prefix,\n+                                                 fn, 50);\n+                        if (fullname == NULL)\n+                            return(0);\n+                        cont = elemDecl->content;\n+                        while (cont != NULL) {\n+                            if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n+                                if (xmlStrEqual(cont->name, fullname))\n+                                    break;\n+                            } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n+                               (cont->c1 != NULL) &&\n+                               (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)){\n+                                if (xmlStrEqual(cont->c1->name, fullname))\n+                                    break;\n+                            } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n+                                (cont->c1 == NULL) ||\n+                                (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)){\n+                                xmlErrValid(NULL, XML_DTD_MIXED_CORRUPT,\n+                                        \"Internal: MIXED struct corrupted\\n\",\n+                                        NULL);\n+                                break;\n+                            }\n+                            cont = cont->c2;\n+                        }\n+                        if ((fullname != fn) && (fullname != child->name))\n+                            xmlFree(fullname);\n+                        if (cont != NULL)\n+                            goto child_ok;\n+                    }\n+                    cont = elemDecl->content;\n+                    while (cont != NULL) {\n+                        if (cont->type == XML_ELEMENT_CONTENT_ELEMENT) {\n+                            if (xmlStrEqual(cont->name, name)) break;\n+                        } else if ((cont->type == XML_ELEMENT_CONTENT_OR) &&\n+                           (cont->c1 != NULL) &&\n+                           (cont->c1->type == XML_ELEMENT_CONTENT_ELEMENT)) {\n+                            if (xmlStrEqual(cont->c1->name, name)) break;\n+                        } else if ((cont->type != XML_ELEMENT_CONTENT_OR) ||\n+                            (cont->c1 == NULL) ||\n+                            (cont->c1->type != XML_ELEMENT_CONTENT_PCDATA)) {\n+                            xmlErrValid(ctxt, XML_DTD_MIXED_CORRUPT,\n+                                    \"Internal: MIXED struct corrupted\\n\",\n+                                    NULL);\n+                            break;\n+                        }\n+                        cont = cont->c2;\n+                    }\n+                    if (cont == NULL) {\n+                        xmlErrValidNode(ctxt, elem, XML_DTD_INVALID_CHILD,\n+               \"Element %s is not declared in %s list of possible children\\n\",\n+                               name, elem->name, NULL);\n+                        ret = 0;\n+                    }\n+                }\n@@ -6224,3 +6225,3 @@\n-            child = child->next;\n-        }\n-        break;\n+                child = child->next;\n+            }\n+            break;\n@@ -6228,16 +6229,16 @@\n-        if ((doc->standalone == 1) && (extsubset == 1)) {\n-        \/*\n-         * VC: Standalone Document Declaration\n-         *     - element types with element content, if white space\n-         *       occurs directly within any instance of those types.\n-         *\/\n-        child = elem->children;\n-        while (child != NULL) {\n-            if (child->type == XML_TEXT_NODE) {\n-            const xmlChar *content = child->content;\n-\n-            while (IS_BLANK_CH(*content))\n-                content++;\n-            if (*content == 0) {\n-                xmlErrValidNode(ctxt, elem,\n-                                XML_DTD_STANDALONE_WHITE_SPACE,\n+            if ((doc->standalone == 1) && (extsubset == 1)) {\n+                \/*\n+                 * VC: Standalone Document Declaration\n+                 *     - element types with element content, if white space\n+                 *       occurs directly within any instance of those types.\n+                 *\/\n+                child = elem->children;\n+                while (child != NULL) {\n+                    if (child->type == XML_TEXT_NODE) {\n+                        const xmlChar *content = child->content;\n+\n+                        while (IS_BLANK_CH(*content))\n+                            content++;\n+                        if (*content == 0) {\n+                            xmlErrValidNode(ctxt, elem,\n+                                            XML_DTD_STANDALONE_WHITE_SPACE,\n@@ -6245,4 +6246,7 @@\n-                   elem->name, NULL, NULL);\n-                ret = 0;\n-                break;\n-            }\n+                                   elem->name, NULL, NULL);\n+                            ret = 0;\n+                            break;\n+                        }\n+                    }\n+                    child =child->next;\n+                }\n@@ -6250,9 +6254,6 @@\n-            child =child->next;\n-        }\n-        }\n-        child = elem->children;\n-        cont = elemDecl->content;\n-        tmp = xmlValidateElementContent(ctxt, child, elemDecl, 1, elem);\n-        if (tmp <= 0)\n-        ret = tmp;\n-        break;\n+            child = elem->children;\n+            cont = elemDecl->content;\n+            tmp = xmlValidateElementContent(ctxt, child, elemDecl, 1, elem);\n+            if (tmp <= 0)\n+                ret = tmp;\n+            break;\n@@ -6265,47 +6266,22 @@\n-    if (attr->def == XML_ATTRIBUTE_REQUIRED) {\n-        int qualified = -1;\n-\n-        if ((attr->prefix == NULL) &&\n-        (xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) {\n-        xmlNsPtr ns;\n-\n-        ns = elem->nsDef;\n-        while (ns != NULL) {\n-            if (ns->prefix == NULL)\n-            goto found;\n-            ns = ns->next;\n-        }\n-        } else if (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\")) {\n-        xmlNsPtr ns;\n-\n-        ns = elem->nsDef;\n-        while (ns != NULL) {\n-            if (xmlStrEqual(attr->name, ns->prefix))\n-            goto found;\n-            ns = ns->next;\n-        }\n-        } else {\n-        xmlAttrPtr attrib;\n-\n-        attrib = elem->properties;\n-        while (attrib != NULL) {\n-            if (xmlStrEqual(attrib->name, attr->name)) {\n-            if (attr->prefix != NULL) {\n-                xmlNsPtr nameSpace = attrib->ns;\n-\n-                if (nameSpace == NULL)\n-                nameSpace = elem->ns;\n-                \/*\n-                 * qualified names handling is problematic, having a\n-                 * different prefix should be possible but DTDs don't\n-                 * allow to define the URI instead of the prefix :-(\n-                 *\/\n-                if (nameSpace == NULL) {\n-                if (qualified < 0)\n-                    qualified = 0;\n-                } else if (!xmlStrEqual(nameSpace->prefix,\n-                            attr->prefix)) {\n-                if (qualified < 1)\n-                    qualified = 1;\n-                } else\n-                goto found;\n+        if (attr->def == XML_ATTRIBUTE_REQUIRED) {\n+            int qualified = -1;\n+\n+            if ((attr->prefix == NULL) &&\n+                (xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) {\n+                xmlNsPtr ns;\n+\n+                ns = elem->nsDef;\n+                while (ns != NULL) {\n+                    if (ns->prefix == NULL)\n+                        goto found;\n+                    ns = ns->next;\n+                }\n+            } else if (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\")) {\n+                xmlNsPtr ns;\n+\n+                ns = elem->nsDef;\n+                while (ns != NULL) {\n+                    if (xmlStrEqual(attr->name, ns->prefix))\n+                        goto found;\n+                    ns = ns->next;\n+                }\n@@ -6313,7 +6289,36 @@\n-                \/*\n-                 * We should allow applications to define namespaces\n-                 * for their application even if the DTD doesn't\n-                 * carry one, otherwise, basically we would always\n-                 * break.\n-                 *\/\n-                goto found;\n+                xmlAttrPtr attrib;\n+\n+                attrib = elem->properties;\n+                while (attrib != NULL) {\n+                    if (xmlStrEqual(attrib->name, attr->name)) {\n+                        if (attr->prefix != NULL) {\n+                            xmlNsPtr nameSpace = attrib->ns;\n+\n+                            if (nameSpace == NULL)\n+                                nameSpace = elem->ns;\n+                            \/*\n+                             * qualified names handling is problematic, having a\n+                             * different prefix should be possible but DTDs don't\n+                             * allow to define the URI instead of the prefix :-(\n+                             *\/\n+                            if (nameSpace == NULL) {\n+                                if (qualified < 0)\n+                                    qualified = 0;\n+                            } else if (!xmlStrEqual(nameSpace->prefix,\n+                                                    attr->prefix)) {\n+                                if (qualified < 1)\n+                                    qualified = 1;\n+                            } else\n+                                goto found;\n+                        } else {\n+                            \/*\n+                             * We should allow applications to define namespaces\n+                             * for their application even if the DTD doesn't\n+                             * carry one, otherwise, basically we would always\n+                             * break.\n+                             *\/\n+                            goto found;\n+                        }\n+                    }\n+                    attrib = attrib->next;\n+                }\n@@ -6321,0 +6326,20 @@\n+            if (qualified == -1) {\n+                if (attr->prefix == NULL) {\n+                    xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,\n+                       \"Element %s does not carry attribute %s\\n\",\n+                           elem->name, attr->name, NULL);\n+                    ret = 0;\n+                } else {\n+                    xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,\n+                       \"Element %s does not carry attribute %s:%s\\n\",\n+                           elem->name, attr->prefix,attr->name);\n+                    ret = 0;\n+                }\n+            } else if (qualified == 0) {\n+                xmlErrValidWarning(ctxt, elem, XML_DTD_NO_PREFIX,\n+                   \"Element %s required attribute %s:%s has no prefix\\n\",\n+                       elem->name, attr->prefix, attr->name);\n+            } else if (qualified == 1) {\n+                xmlErrValidWarning(ctxt, elem, XML_DTD_DIFFERENT_PREFIX,\n+                   \"Element %s required attribute %s:%s has different prefix\\n\",\n+                       elem->name, attr->prefix, attr->name);\n@@ -6322,40 +6347,16 @@\n-            attrib = attrib->next;\n-        }\n-        }\n-        if (qualified == -1) {\n-        if (attr->prefix == NULL) {\n-            xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,\n-               \"Element %s does not carry attribute %s\\n\",\n-               elem->name, attr->name, NULL);\n-            ret = 0;\n-            } else {\n-            xmlErrValidNode(ctxt, elem, XML_DTD_MISSING_ATTRIBUTE,\n-               \"Element %s does not carry attribute %s:%s\\n\",\n-               elem->name, attr->prefix,attr->name);\n-            ret = 0;\n-        }\n-        } else if (qualified == 0) {\n-        xmlErrValidWarning(ctxt, elem, XML_DTD_NO_PREFIX,\n-           \"Element %s required attribute %s:%s has no prefix\\n\",\n-               elem->name, attr->prefix, attr->name);\n-        } else if (qualified == 1) {\n-        xmlErrValidWarning(ctxt, elem, XML_DTD_DIFFERENT_PREFIX,\n-           \"Element %s required attribute %s:%s has different prefix\\n\",\n-               elem->name, attr->prefix, attr->name);\n-        }\n-    } else if (attr->def == XML_ATTRIBUTE_FIXED) {\n-        \/*\n-         * Special tests checking #FIXED namespace declarations\n-         * have the right value since this is not done as an\n-         * attribute checking\n-         *\/\n-        if ((attr->prefix == NULL) &&\n-        (xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) {\n-        xmlNsPtr ns;\n-\n-        ns = elem->nsDef;\n-        while (ns != NULL) {\n-            if (ns->prefix == NULL) {\n-            if (!xmlStrEqual(attr->defaultValue, ns->href)) {\n-                xmlErrValidNode(ctxt, elem,\n-                       XML_DTD_ELEM_DEFAULT_NAMESPACE,\n+        } else if (attr->def == XML_ATTRIBUTE_FIXED) {\n+            \/*\n+             * Special tests checking #FIXED namespace declarations\n+             * have the right value since this is not done as an\n+             * attribute checking\n+             *\/\n+            if ((attr->prefix == NULL) &&\n+                (xmlStrEqual(attr->name, BAD_CAST \"xmlns\"))) {\n+                xmlNsPtr ns;\n+\n+                ns = elem->nsDef;\n+                while (ns != NULL) {\n+                    if (ns->prefix == NULL) {\n+                        if (!xmlStrEqual(attr->defaultValue, ns->href)) {\n+                            xmlErrValidNode(ctxt, elem,\n+                                   XML_DTD_ELEM_DEFAULT_NAMESPACE,\n@@ -6363,20 +6364,23 @@\n-                   elem->name, NULL, NULL);\n-                ret = 0;\n-            }\n-            goto found;\n-            }\n-            ns = ns->next;\n-        }\n-        } else if (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\")) {\n-        xmlNsPtr ns;\n-\n-        ns = elem->nsDef;\n-        while (ns != NULL) {\n-            if (xmlStrEqual(attr->name, ns->prefix)) {\n-            if (!xmlStrEqual(attr->defaultValue, ns->href)) {\n-                xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n-           \"Element %s namespace name for %s does not match the DTD\\n\",\n-                   elem->name, ns->prefix, NULL);\n-                ret = 0;\n-            }\n-            goto found;\n+                                   elem->name, NULL, NULL);\n+                            ret = 0;\n+                        }\n+                        goto found;\n+                    }\n+                    ns = ns->next;\n+                }\n+            } else if (xmlStrEqual(attr->prefix, BAD_CAST \"xmlns\")) {\n+                xmlNsPtr ns;\n+\n+                ns = elem->nsDef;\n+                while (ns != NULL) {\n+                    if (xmlStrEqual(attr->name, ns->prefix)) {\n+                        if (!xmlStrEqual(attr->defaultValue, ns->href)) {\n+                            xmlErrValidNode(ctxt, elem, XML_DTD_ELEM_NAMESPACE,\n+                   \"Element %s namespace name for %s does not match the DTD\\n\",\n+                                   elem->name, ns->prefix, NULL);\n+                            ret = 0;\n+                        }\n+                        goto found;\n+                    }\n+                    ns = ns->next;\n+                }\n@@ -6384,1 +6388,0 @@\n-            ns = ns->next;\n@@ -6386,2 +6389,0 @@\n-        }\n-    }\n@@ -6417,2 +6418,2 @@\n-    xmlErrValid(ctxt, XML_DTD_NO_ROOT,\n-                \"no root element\\n\", NULL);\n+        xmlErrValid(ctxt, XML_DTD_NO_ROOT,\n+                    \"no root element\\n\", NULL);\n@@ -6427,8 +6428,8 @@\n-    (doc->intSubset->name != NULL)) {\n-    \/*\n-     * Check first the document root against the NQName\n-     *\/\n-    if (!xmlStrEqual(doc->intSubset->name, root->name)) {\n-        if ((root->ns != NULL) && (root->ns->prefix != NULL)) {\n-        xmlChar fn[50];\n-        xmlChar *fullname;\n+        (doc->intSubset->name != NULL)) {\n+        \/*\n+         * Check first the document root against the NQName\n+         *\/\n+        if (!xmlStrEqual(doc->intSubset->name, root->name)) {\n+            if ((root->ns != NULL) && (root->ns->prefix != NULL)) {\n+                xmlChar fn[50];\n+                xmlChar *fullname;\n@@ -6436,3 +6437,17 @@\n-        fullname = xmlBuildQName(root->name, root->ns->prefix, fn, 50);\n-        if (fullname == NULL) {\n-            xmlVErrMemory(ctxt, NULL);\n+                fullname = xmlBuildQName(root->name, root->ns->prefix, fn, 50);\n+                if (fullname == NULL) {\n+                    xmlVErrMemory(ctxt, NULL);\n+                    return(0);\n+                }\n+                ret = xmlStrEqual(doc->intSubset->name, fullname);\n+                if ((fullname != fn) && (fullname != root->name))\n+                    xmlFree(fullname);\n+                if (ret == 1)\n+                    goto name_ok;\n+            }\n+            if ((xmlStrEqual(doc->intSubset->name, BAD_CAST \"HTML\")) &&\n+                (xmlStrEqual(root->name, BAD_CAST \"html\")))\n+                goto name_ok;\n+            xmlErrValidNode(ctxt, root, XML_DTD_ROOT_NAME,\n+                   \"root and DTD name do not match '%s' and '%s'\\n\",\n+                   root->name, doc->intSubset->name, NULL);\n@@ -6441,14 +6456,0 @@\n-        ret = xmlStrEqual(doc->intSubset->name, fullname);\n-        if ((fullname != fn) && (fullname != root->name))\n-            xmlFree(fullname);\n-        if (ret == 1)\n-            goto name_ok;\n-        }\n-        if ((xmlStrEqual(doc->intSubset->name, BAD_CAST \"HTML\")) &&\n-        (xmlStrEqual(root->name, BAD_CAST \"html\")))\n-        goto name_ok;\n-        xmlErrValidNode(ctxt, root, XML_DTD_ROOT_NAME,\n-           \"root and DTD name do not match '%s' and '%s'\\n\",\n-           root->name, doc->intSubset->name, NULL);\n-        return(0);\n-    }\n@@ -6487,3 +6488,3 @@\n-    (elem->type == XML_XINCLUDE_END) ||\n-    (elem->type == XML_NAMESPACE_DECL))\n-    return(1);\n+        (elem->type == XML_XINCLUDE_END) ||\n+        (elem->type == XML_NAMESPACE_DECL))\n+        return(1);\n@@ -6497,1 +6498,1 @@\n-    return(1);\n+        return(1);\n@@ -6502,18 +6503,18 @@\n-    attr = elem->properties;\n-    while (attr != NULL) {\n-        value = xmlNodeListGetString(doc, attr->children, 0);\n-        ret &= xmlValidateOneAttribute(ctxt, doc, elem, attr, value);\n-        if (value != NULL)\n-        xmlFree((char *)value);\n-        attr= attr->next;\n-    }\n-    ns = elem->nsDef;\n-    while (ns != NULL) {\n-        if (elem->ns == NULL)\n-        ret &= xmlValidateOneNamespace(ctxt, doc, elem, NULL,\n-                           ns, ns->href);\n-        else\n-        ret &= xmlValidateOneNamespace(ctxt, doc, elem,\n-                                       elem->ns->prefix, ns, ns->href);\n-        ns = ns->next;\n-    }\n+        attr = elem->properties;\n+        while (attr != NULL) {\n+            value = xmlNodeListGetString(doc, attr->children, 0);\n+            ret &= xmlValidateOneAttribute(ctxt, doc, elem, attr, value);\n+            if (value != NULL)\n+                xmlFree((char *)value);\n+            attr= attr->next;\n+        }\n+        ns = elem->nsDef;\n+        while (ns != NULL) {\n+            if (elem->ns == NULL)\n+                ret &= xmlValidateOneNamespace(ctxt, doc, elem, NULL,\n+                                               ns, ns->href);\n+            else\n+                ret &= xmlValidateOneNamespace(ctxt, doc, elem,\n+                                               elem->ns->prefix, ns, ns->href);\n+            ns = ns->next;\n+        }\n@@ -6539,1 +6540,1 @@\n-                       const xmlChar *name) {\n+                           const xmlChar *name) {\n@@ -6544,1 +6545,1 @@\n-    return;\n+        return;\n@@ -6546,1 +6547,1 @@\n-    return;\n+        return;\n@@ -6549,1 +6550,1 @@\n-    xmlChar *dup, *str = NULL, *cur, save;\n+        xmlChar *dup, *str = NULL, *cur, save;\n@@ -6551,17 +6552,4 @@\n-    dup = xmlStrdup(name);\n-    if (dup == NULL) {\n-        ctxt->valid = 0;\n-        return;\n-    }\n-    cur = dup;\n-    while (*cur != 0) {\n-        str = cur;\n-        while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n-        save = *cur;\n-        *cur = 0;\n-        id = xmlGetID(ctxt->doc, str);\n-        if (id == NULL) {\n-        xmlErrValidNodeNr(ctxt, NULL, XML_DTD_UNKNOWN_ID,\n-       \"attribute %s line %d references an unknown ID \\\"%s\\\"\\n\",\n-               ref->name, ref->lineno, str);\n-        ctxt->valid = 0;\n+        dup = xmlStrdup(name);\n+        if (dup == NULL) {\n+            ctxt->valid = 0;\n+            return;\n@@ -6569,6 +6557,19 @@\n-        if (save == 0)\n-        break;\n-        *cur = save;\n-        while (IS_BLANK_CH(*cur)) cur++;\n-    }\n-    xmlFree(dup);\n+        cur = dup;\n+        while (*cur != 0) {\n+            str = cur;\n+            while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n+            save = *cur;\n+            *cur = 0;\n+            id = xmlGetID(ctxt->doc, str);\n+            if (id == NULL) {\n+                xmlErrValidNodeNr(ctxt, NULL, XML_DTD_UNKNOWN_ID,\n+           \"attribute %s line %d references an unknown ID \\\"%s\\\"\\n\",\n+                       ref->name, ref->lineno, str);\n+                ctxt->valid = 0;\n+            }\n+            if (save == 0)\n+                break;\n+            *cur = save;\n+            while (IS_BLANK_CH(*cur)) cur++;\n+        }\n+        xmlFree(dup);\n@@ -6576,7 +6577,7 @@\n-    id = xmlGetID(ctxt->doc, name);\n-    if (id == NULL) {\n-        xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n-       \"IDREF attribute %s references an unknown ID \\\"%s\\\"\\n\",\n-           attr->name, name, NULL);\n-        ctxt->valid = 0;\n-    }\n+        id = xmlGetID(ctxt->doc, name);\n+        if (id == NULL) {\n+            xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n+           \"IDREF attribute %s references an unknown ID \\\"%s\\\"\\n\",\n+                   attr->name, name, NULL);\n+            ctxt->valid = 0;\n+        }\n@@ -6584,1 +6585,1 @@\n-    xmlChar *dup, *str = NULL, *cur, save;\n+        xmlChar *dup, *str = NULL, *cur, save;\n@@ -6586,18 +6587,5 @@\n-    dup = xmlStrdup(name);\n-    if (dup == NULL) {\n-        xmlVErrMemory(ctxt, \"IDREFS split\");\n-        ctxt->valid = 0;\n-        return;\n-    }\n-    cur = dup;\n-    while (*cur != 0) {\n-        str = cur;\n-        while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n-        save = *cur;\n-        *cur = 0;\n-        id = xmlGetID(ctxt->doc, str);\n-        if (id == NULL) {\n-        xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n-       \"IDREFS attribute %s references an unknown ID \\\"%s\\\"\\n\",\n-                 attr->name, str, NULL);\n-        ctxt->valid = 0;\n+        dup = xmlStrdup(name);\n+        if (dup == NULL) {\n+            xmlVErrMemory(ctxt, \"IDREFS split\");\n+            ctxt->valid = 0;\n+            return;\n@@ -6605,6 +6593,19 @@\n-        if (save == 0)\n-        break;\n-        *cur = save;\n-        while (IS_BLANK_CH(*cur)) cur++;\n-    }\n-    xmlFree(dup);\n+        cur = dup;\n+        while (*cur != 0) {\n+            str = cur;\n+            while ((*cur != 0) && (!IS_BLANK_CH(*cur))) cur++;\n+            save = *cur;\n+            *cur = 0;\n+            id = xmlGetID(ctxt->doc, str);\n+            if (id == NULL) {\n+                xmlErrValidNode(ctxt, attr->parent, XML_DTD_UNKNOWN_ID,\n+           \"IDREFS attribute %s references an unknown ID \\\"%s\\\"\\n\",\n+                             attr->name, str, NULL);\n+                ctxt->valid = 0;\n+            }\n+            if (save == 0)\n+                break;\n+            *cur = save;\n+            while (IS_BLANK_CH(*cur)) cur++;\n+        }\n+        xmlFree(dup);\n@@ -6624,3 +6625,3 @@\n-    xmlValidateMemoPtr memo = (xmlValidateMemoPtr)user;\n-    xmlValidateRef((xmlRefPtr)data, memo->ctxt, memo->name);\n-    return 1;\n+        xmlValidateMemoPtr memo = (xmlValidateMemoPtr)user;\n+        xmlValidateRef((xmlRefPtr)data, memo->ctxt, memo->name);\n+        return 1;\n@@ -6643,1 +6644,1 @@\n-    return;\n+        return;\n@@ -6675,2 +6676,2 @@\n-        \"xmlValidateDocumentFinal: doc == NULL\\n\", NULL);\n-    return(0);\n+                \"xmlValidateDocumentFinal: doc == NULL\\n\", NULL);\n+        return(0);\n@@ -6731,3 +6732,3 @@\n-    doc->extSubset = oldExt;\n-    doc->intSubset = oldInt;\n-    return(ret);\n+        doc->extSubset = oldExt;\n+        doc->intSubset = oldInt;\n+        return(ret);\n@@ -6753,1 +6754,1 @@\n-                        const xmlChar *name ATTRIBUTE_UNUSED) {\n+                            const xmlChar *name ATTRIBUTE_UNUSED) {\n@@ -6757,1 +6758,1 @@\n-    return;\n+        return;\n@@ -6759,1 +6760,1 @@\n-    xmlChar *notation = cur->content;\n+        xmlChar *notation = cur->content;\n@@ -6761,2 +6762,2 @@\n-    if (notation != NULL) {\n-        int ret;\n+        if (notation != NULL) {\n+            int ret;\n@@ -6764,3 +6765,4 @@\n-        ret = xmlValidateNotationUse(ctxt, cur->doc, notation);\n-        if (ret != 1) {\n-        ctxt->valid = 0;\n+            ret = xmlValidateNotationUse(ctxt, cur->doc, notation);\n+            if (ret != 1) {\n+                ctxt->valid = 0;\n+            }\n@@ -6769,1 +6771,0 @@\n-    }\n@@ -6774,1 +6775,1 @@\n-                         const xmlChar *name ATTRIBUTE_UNUSED) {\n+                             const xmlChar *name ATTRIBUTE_UNUSED) {\n@@ -6782,1 +6783,1 @@\n-    return;\n+        return;\n@@ -6784,28 +6785,28 @@\n-    case XML_ATTRIBUTE_CDATA:\n-    case XML_ATTRIBUTE_ID:\n-    case XML_ATTRIBUTE_IDREF    :\n-    case XML_ATTRIBUTE_IDREFS:\n-    case XML_ATTRIBUTE_NMTOKEN:\n-    case XML_ATTRIBUTE_NMTOKENS:\n-    case XML_ATTRIBUTE_ENUMERATION:\n-        break;\n-    case XML_ATTRIBUTE_ENTITY:\n-    case XML_ATTRIBUTE_ENTITIES:\n-    case XML_ATTRIBUTE_NOTATION:\n-        if (cur->defaultValue != NULL) {\n-\n-        ret = xmlValidateAttributeValue2(ctxt, ctxt->doc, cur->name,\n-                                     cur->atype, cur->defaultValue);\n-        if ((ret == 0) && (ctxt->valid == 1))\n-            ctxt->valid = 0;\n-        }\n-        if (cur->tree != NULL) {\n-        xmlEnumerationPtr tree = cur->tree;\n-        while (tree != NULL) {\n-            ret = xmlValidateAttributeValue2(ctxt, ctxt->doc,\n-                    cur->name, cur->atype, tree->name);\n-            if ((ret == 0) && (ctxt->valid == 1))\n-            ctxt->valid = 0;\n-            tree = tree->next;\n-        }\n-        }\n+        case XML_ATTRIBUTE_CDATA:\n+        case XML_ATTRIBUTE_ID:\n+        case XML_ATTRIBUTE_IDREF        :\n+        case XML_ATTRIBUTE_IDREFS:\n+        case XML_ATTRIBUTE_NMTOKEN:\n+        case XML_ATTRIBUTE_NMTOKENS:\n+        case XML_ATTRIBUTE_ENUMERATION:\n+            break;\n+        case XML_ATTRIBUTE_ENTITY:\n+        case XML_ATTRIBUTE_ENTITIES:\n+        case XML_ATTRIBUTE_NOTATION:\n+            if (cur->defaultValue != NULL) {\n+\n+                ret = xmlValidateAttributeValue2(ctxt, ctxt->doc, cur->name,\n+                                                 cur->atype, cur->defaultValue);\n+                if ((ret == 0) && (ctxt->valid == 1))\n+                    ctxt->valid = 0;\n+            }\n+            if (cur->tree != NULL) {\n+                xmlEnumerationPtr tree = cur->tree;\n+                while (tree != NULL) {\n+                    ret = xmlValidateAttributeValue2(ctxt, ctxt->doc,\n+                                    cur->name, cur->atype, tree->name);\n+                    if ((ret == 0) && (ctxt->valid == 1))\n+                        ctxt->valid = 0;\n+                    tree = tree->next;\n+                }\n+            }\n@@ -6814,7 +6815,7 @@\n-    doc = cur->doc;\n-    if (cur->elem == NULL) {\n-        xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n-           \"xmlValidateAttributeCallback(%s): internal error\\n\",\n-           (const char *) cur->name);\n-        return;\n-    }\n+        doc = cur->doc;\n+        if (cur->elem == NULL) {\n+            xmlErrValid(ctxt, XML_ERR_INTERNAL_ERROR,\n+                   \"xmlValidateAttributeCallback(%s): internal error\\n\",\n+                   (const char *) cur->name);\n+            return;\n+        }\n@@ -6822,19 +6823,19 @@\n-    if (doc != NULL)\n-        elem = xmlGetDtdElementDesc(doc->intSubset, cur->elem);\n-    if ((elem == NULL) && (doc != NULL))\n-        elem = xmlGetDtdElementDesc(doc->extSubset, cur->elem);\n-    if ((elem == NULL) && (cur->parent != NULL) &&\n-        (cur->parent->type == XML_DTD_NODE))\n-        elem = xmlGetDtdElementDesc((xmlDtdPtr) cur->parent, cur->elem);\n-    if (elem == NULL) {\n-        xmlErrValidNode(ctxt, NULL, XML_DTD_UNKNOWN_ELEM,\n-           \"attribute %s: could not find decl for element %s\\n\",\n-           cur->name, cur->elem, NULL);\n-        return;\n-    }\n-    if (elem->etype == XML_ELEMENT_TYPE_EMPTY) {\n-        xmlErrValidNode(ctxt, NULL, XML_DTD_EMPTY_NOTATION,\n-           \"NOTATION attribute %s declared for EMPTY element %s\\n\",\n-           cur->name, cur->elem, NULL);\n-        ctxt->valid = 0;\n-    }\n+        if (doc != NULL)\n+            elem = xmlGetDtdElementDesc(doc->intSubset, cur->elem);\n+        if ((elem == NULL) && (doc != NULL))\n+            elem = xmlGetDtdElementDesc(doc->extSubset, cur->elem);\n+        if ((elem == NULL) && (cur->parent != NULL) &&\n+            (cur->parent->type == XML_DTD_NODE))\n+            elem = xmlGetDtdElementDesc((xmlDtdPtr) cur->parent, cur->elem);\n+        if (elem == NULL) {\n+            xmlErrValidNode(ctxt, NULL, XML_DTD_UNKNOWN_ELEM,\n+                   \"attribute %s: could not find decl for element %s\\n\",\n+                   cur->name, cur->elem, NULL);\n+            return;\n+        }\n+        if (elem->etype == XML_ELEMENT_TYPE_EMPTY) {\n+            xmlErrValidNode(ctxt, NULL, XML_DTD_EMPTY_NOTATION,\n+                   \"NOTATION attribute %s declared for EMPTY element %s\\n\",\n+                   cur->name, cur->elem, NULL);\n+            ctxt->valid = 0;\n+        }\n@@ -6869,1 +6870,1 @@\n-    return(0);\n+        return(0);\n@@ -6874,2 +6875,2 @@\n-    table = (xmlAttributeTablePtr) dtd->attributes;\n-    xmlHashScan(table, xmlValidateAttributeCallback, ctxt);\n+        table = (xmlAttributeTablePtr) dtd->attributes;\n+        xmlHashScan(table, xmlValidateAttributeCallback, ctxt);\n@@ -6878,2 +6879,2 @@\n-    entities = (xmlEntitiesTablePtr) dtd->entities;\n-    xmlHashScan(entities, xmlValidateNotationCallback, ctxt);\n+        entities = (xmlEntitiesTablePtr) dtd->entities;\n+        xmlHashScan(entities, xmlValidateNotationCallback, ctxt);\n@@ -6883,2 +6884,2 @@\n-    table = (xmlAttributeTablePtr) dtd->attributes;\n-    xmlHashScan(table, xmlValidateAttributeCallback, ctxt);\n+        table = (xmlAttributeTablePtr) dtd->attributes;\n+        xmlHashScan(table, xmlValidateAttributeCallback, ctxt);\n@@ -6887,2 +6888,2 @@\n-    entities = (xmlEntitiesTablePtr) dtd->entities;\n-    xmlHashScan(entities, xmlValidateNotationCallback, ctxt);\n+        entities = (xmlEntitiesTablePtr) dtd->entities;\n+        xmlHashScan(entities, xmlValidateNotationCallback, ctxt);\n@@ -6916,2 +6917,2 @@\n-                \"no DTD found!\\n\", NULL);\n-    return(0);\n+                    \"no DTD found!\\n\", NULL);\n+        return(0);\n@@ -6920,13 +6921,13 @@\n-    (doc->intSubset->ExternalID != NULL)) && (doc->extSubset == NULL)) {\n-    xmlChar *sysID;\n-    if (doc->intSubset->SystemID != NULL) {\n-        sysID = xmlBuildURI(doc->intSubset->SystemID,\n-            doc->URL);\n-        if (sysID == NULL) {\n-            xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n-            \"Could not build URI for external subset \\\"%s\\\"\\n\",\n-            (const char *) doc->intSubset->SystemID);\n-        return 0;\n-        }\n-    } else\n-        sysID = NULL;\n+        (doc->intSubset->ExternalID != NULL)) && (doc->extSubset == NULL)) {\n+        xmlChar *sysID;\n+        if (doc->intSubset->SystemID != NULL) {\n+            sysID = xmlBuildURI(doc->intSubset->SystemID,\n+                        doc->URL);\n+            if (sysID == NULL) {\n+                xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n+                        \"Could not build URI for external subset \\\"%s\\\"\\n\",\n+                        (const char *) doc->intSubset->SystemID);\n+                return 0;\n+            }\n+        } else\n+            sysID = NULL;\n@@ -6934,3 +6935,3 @@\n-            (const xmlChar *)sysID);\n-    if (sysID != NULL)\n-        xmlFree(sysID);\n+                        (const xmlChar *)sysID);\n+        if (sysID != NULL)\n+            xmlFree(sysID);\n@@ -6938,8 +6939,10 @@\n-        if (doc->intSubset->SystemID != NULL) {\n-        xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n-               \"Could not load the external subset \\\"%s\\\"\\n\",\n-               (const char *) doc->intSubset->SystemID);\n-        } else {\n-        xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n-               \"Could not load the external subset \\\"%s\\\"\\n\",\n-               (const char *) doc->intSubset->ExternalID);\n+            if (doc->intSubset->SystemID != NULL) {\n+                xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n+                       \"Could not load the external subset \\\"%s\\\"\\n\",\n+                       (const char *) doc->intSubset->SystemID);\n+            } else {\n+                xmlErrValid(ctxt, XML_DTD_LOAD_ERROR,\n+                       \"Could not load the external subset \\\"%s\\\"\\n\",\n+                       (const char *) doc->intSubset->ExternalID);\n+            }\n+            return(0);\n@@ -6947,2 +6950,0 @@\n-        return(0);\n-    }\n@@ -6969,3 +6970,3 @@\n- *                                  *\n- *      Routines for dynamic validation editing         *\n- *                                  *\n+ *                                                                      *\n+ *              Routines for dynamic validation editing                 *\n+ *                                                                      *\n@@ -6997,18 +6998,18 @@\n-    case XML_ELEMENT_CONTENT_PCDATA:\n-        for (i = 0; i < *len;i++)\n-        if (xmlStrEqual(BAD_CAST \"#PCDATA\", names[i])) return(*len);\n-        names[(*len)++] = BAD_CAST \"#PCDATA\";\n-        break;\n-    case XML_ELEMENT_CONTENT_ELEMENT:\n-        for (i = 0; i < *len;i++)\n-        if (xmlStrEqual(ctree->name, names[i])) return(*len);\n-        names[(*len)++] = ctree->name;\n-        break;\n-    case XML_ELEMENT_CONTENT_SEQ:\n-        xmlValidGetPotentialChildren(ctree->c1, names, len, max);\n-        xmlValidGetPotentialChildren(ctree->c2, names, len, max);\n-        break;\n-    case XML_ELEMENT_CONTENT_OR:\n-        xmlValidGetPotentialChildren(ctree->c1, names, len, max);\n-        xmlValidGetPotentialChildren(ctree->c2, names, len, max);\n-        break;\n+        case XML_ELEMENT_CONTENT_PCDATA:\n+            for (i = 0; i < *len;i++)\n+                if (xmlStrEqual(BAD_CAST \"#PCDATA\", names[i])) return(*len);\n+            names[(*len)++] = BAD_CAST \"#PCDATA\";\n+            break;\n+        case XML_ELEMENT_CONTENT_ELEMENT:\n+            for (i = 0; i < *len;i++)\n+                if (xmlStrEqual(ctree->name, names[i])) return(*len);\n+            names[(*len)++] = ctree->name;\n+            break;\n+        case XML_ELEMENT_CONTENT_SEQ:\n+            xmlValidGetPotentialChildren(ctree->c1, names, len, max);\n+            xmlValidGetPotentialChildren(ctree->c2, names, len, max);\n+            break;\n+        case XML_ELEMENT_CONTENT_OR:\n+            xmlValidGetPotentialChildren(ctree->c1, names, len, max);\n+            xmlValidGetPotentialChildren(ctree->c2, names, len, max);\n+            break;\n@@ -7080,1 +7081,1 @@\n-    vctxt.error = xmlNoValidityErr; \/* this suppresses err\/warn output *\/\n+    vctxt.error = xmlNoValidityErr;     \/* this suppresses err\/warn output *\/\n@@ -7127,1 +7128,1 @@\n-               elements, &nb_elements, 256);\n+                       elements, &nb_elements, 256);\n@@ -7130,9 +7131,9 @@\n-    test_node->name = elements[i];\n-    if (xmlValidateOneElement(&vctxt, parent->doc, parent)) {\n-        int j;\n-\n-        for (j = 0; j < nb_valid_elements;j++)\n-        if (xmlStrEqual(elements[i], names[j])) break;\n-        names[nb_valid_elements++] = elements[i];\n-        if (nb_valid_elements >= max) break;\n-    }\n+        test_node->name = elements[i];\n+        if (xmlValidateOneElement(&vctxt, parent->doc, parent)) {\n+            int j;\n+\n+            for (j = 0; j < nb_valid_elements;j++)\n+                if (xmlStrEqual(elements[i], names[j])) break;\n+            names[nb_valid_elements++] = elements[i];\n+            if (nb_valid_elements >= max) break;\n+        }\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/valid.c","additions":2882,"deletions":2881,"binary":false,"changes":5763,"status":"modified"},{"patch":"@@ -491,3 +491,3 @@\n-double xmlXPathNAN;\n-double xmlXPathPINF;\n-double xmlXPathNINF;\n+double xmlXPathNAN = 0.0;\n+double xmlXPathPINF = 0.0;\n+double xmlXPathNINF = 0.0;\n@@ -9263,13 +9263,2 @@\n-  xmlXPathObjectPtr obj = NULL;\n-  xmlChar *source = NULL;\n-  xmlBufPtr target;\n-  xmlChar blank;\n-\n-  if (ctxt == NULL) return;\n-  if (nargs == 0) {\n-    \/* Use current context node *\/\n-      valuePush(ctxt,\n-          xmlXPathCacheWrapString(ctxt->context,\n-            xmlXPathCastNodeToString(ctxt->context->node)));\n-    nargs = 1;\n-  }\n+    xmlChar *source, *target;\n+    int blank;\n@@ -9277,5 +9266,8 @@\n-  CHECK_ARITY(1);\n-  CAST_TO_STRING;\n-  CHECK_TYPE(XPATH_STRING);\n-  obj = valuePop(ctxt);\n-  source = obj->stringval;\n+    if (ctxt == NULL) return;\n+    if (nargs == 0) {\n+        \/* Use current context node *\/\n+        valuePush(ctxt,\n+            xmlXPathCacheWrapString(ctxt->context,\n+                xmlXPathCastNodeToString(ctxt->context->node)));\n+        nargs = 1;\n+    }\n@@ -9283,2 +9275,7 @@\n-  target = xmlBufCreate();\n-  if (target && source) {\n+    CHECK_ARITY(1);\n+    CAST_TO_STRING;\n+    CHECK_TYPE(XPATH_STRING);\n+    source = ctxt->value->stringval;\n+    if (source == NULL)\n+        return;\n+    target = source;\n@@ -9288,1 +9285,1 @@\n-      source++;\n+        source++;\n@@ -9293,6 +9290,8 @@\n-      if (IS_BLANK_CH(*source)) {\n-        blank = 0x20;\n-      } else {\n-        if (blank) {\n-          xmlBufAdd(target, &blank, 1);\n-          blank = 0;\n+        if (IS_BLANK_CH(*source)) {\n+            blank = 1;\n+        } else {\n+            if (blank) {\n+                *target++ = 0x20;\n+                blank = 0;\n+            }\n+            *target++ = *source;\n@@ -9300,3 +9299,1 @@\n-        xmlBufAdd(target, source, 1);\n-      }\n-      source++;\n+        source++;\n@@ -9304,5 +9301,1 @@\n-    valuePush(ctxt, xmlXPathCacheNewString(ctxt->context,\n-        xmlBufContent(target)));\n-    xmlBufFree(target);\n-  }\n-  xmlXPathReleaseObject(ctxt->context, obj);\n+    *target = 0;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/src\/xpath.c","additions":31,"deletions":38,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    : ((_fpclass(d) == _FPCLASS_NINF) ? -1 : 0))\n+                 : ((_fpclass(d) == _FPCLASS_NINF) ? -1 : 0))\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/win32\/config.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#define LIBXML_DOTTED_VERSION \"2.9.13\"\n+#define LIBXML_DOTTED_VERSION \"2.9.14\"\n@@ -39,1 +39,1 @@\n-#define LIBXML_VERSION 20913\n+#define LIBXML_VERSION 20914\n@@ -46,1 +46,1 @@\n-#define LIBXML_VERSION_STRING \"20913\"\n+#define LIBXML_VERSION_STRING \"20914\"\n@@ -61,1 +61,1 @@\n-#define LIBXML_TEST_VERSION xmlCheckVersion(20913);\n+#define LIBXML_TEST_VERSION xmlCheckVersion(20914);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxml\/win32\/include\/libxml\/xmlversion.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+Updating libxslt in OpenJFX:\n+\n+1. Download respective libxslt source tarball from here: https:\/\/gitlab.gnome.org\/GNOME\/libxslt\/-\/releases.\n+Alternatively we can also clone the libxslt repo from github. (url- https:\/\/gitlab.gnome.org\/GNOME\/libxslt.git)\n+\n+2. Extract contents into 'modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src' directory.\n+3. We do not have any local changes in the libxslt source but libxslt source needs to be configured before integrating into JavaFX.\n+Below are platform wise steps to configure.\n+\n+- For windows\n+4. Configure libxslt.\n+        > cd modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/win32\n+        > cscript configure.js compiler=msvc xslt_debug=no  iconv=no mem_debug=no modules=no  zlib=no profiler=no trio=no\n+        - Above command generates a header file 'src\/config.h' file (on all platforms) and libxslt\\src\\libxslt\\xsltconfig.h.\n+4.1 Copy `libxslt\\src\\config.h` to `libxslt\\win32\\config.h'. config.h file defines several macros to control libxslt features.\n+We do not require all of the features to be enabled.\n+4.2 Compare the generated `libxslt\\src\\config.h` with existing `libxslt\\win32\\config.h' and update the macros based on the output of .\/configure.\n+4.3 Update version related info in libxslt\\src\\libxslt\\xsltconfig.h.\n+\n+5. Remove files & directories which are not relevant to JavaFX WebKit.\n+\n+- For Mac\n+6. Prerequisites to compile libxslt: libtool, autoconf, automake\n+7. Configure libxslt.\n+        > cd modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\n+        > .\/autogen.sh\n+        > .\/configure\n+7.1 Copy `libxslt\/src\/config.h` to `libxslt\/mac\/config.h` and follow same guidelines as Windows to retain changes from our repo.\n+\n+- For Linux\n+8. Prerequisites to compile libxslt: libtool, autoconf, automake\n+9. Configure libxslt.\n+        > cd modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\n+        > .\/configure\n+9.1 Copy `libxslt\/src\/config.h` to `libxslt\/linux\/config.h` and follow same guidelines as Windows to retain changes from our repo.\n+\n+10. Update version info in 'modules\/javafx.web\/src\/main\/legal\/libxslt.md'.Also, update copyright if any new files are added.\n+\n+11. Remove tabs and trailing whitespaces from source files(.h and .c).\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/UPDATING.txt","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -5,1 +5,1 @@\n-\n+#define HAVE_CLOCK_GETTIME 1\n@@ -32,1 +32,1 @@\n-\n+\/* #undef HAVE_GCRYPT *\/\n@@ -56,1 +56,1 @@\n-\n+#define HAVE_LOCALTIME 1\n@@ -143,1 +143,1 @@\n-\n+\/* #undef HAVE_XLOCALE_H *\/\n@@ -148,2 +148,1 @@\n-\/* Define to the sub-directory in which libtool stores uninstalled libraries.\n-   *\/\n+\/* Define to the sub-directory where libtool stores uninstalled libraries. *\/\n@@ -162,1 +161,1 @@\n-#define PACKAGE_STRING \"libxslt 1.1.34\"\n+#define PACKAGE_STRING \"libxslt 1.1.35\"\n@@ -171,1 +170,1 @@\n-#define PACKAGE_VERSION \"1.1.34\"\n+#define PACKAGE_VERSION \"1.1.35\"\n@@ -199,1 +198,1 @@\n-#define VERSION \"1.1.34\"\n+#define VERSION \"1.1.35\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/linux\/config.h","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -21,1 +21,1 @@\n-#define LIBEXSLT_DOTTED_VERSION \"1.1.34\"\n+#define LIBEXSLT_DOTTED_VERSION \"0.8.20\"\n@@ -49,1 +49,1 @@\n-#if 1\n+#if 0\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/linux\/libexslt\/exsltconfig.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#define LIBXSLT_DOTTED_VERSION \"1.1.34\"\n+#define LIBXSLT_DOTTED_VERSION \"1.1.35\"\n@@ -33,1 +33,1 @@\n-#define LIBXSLT_VERSION 10134\n+#define LIBXSLT_VERSION 10135\n@@ -40,1 +40,1 @@\n-#define LIBXSLT_VERSION_STRING \"10134\"\n+#define LIBXSLT_VERSION_STRING \"10135\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/linux\/libxslt\/xsltwin32config.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-\n+#define HAVE_LOCALTIME 1\n@@ -64,2 +64,2 @@\n-\/* Define to 1 if you have the <memory.h> header file. *\/\n-#define HAVE_MEMORY_H 1\n+\/* Define to 1 if you have the <minix\/config.h> header file. *\/\n+\/* #undef HAVE_MINIX_CONFIG_H *\/\n@@ -97,0 +97,3 @@\n+\/* Define to 1 if you have the <stdio.h> header file. *\/\n+#define HAVE_STDIO_H 1\n+\n@@ -142,0 +145,3 @@\n+\/* Define to 1 if you have the <wchar.h> header file. *\/\n+#define HAVE_WCHAR_H 1\n+\n@@ -161,1 +167,1 @@\n-#define PACKAGE_STRING \"libxslt 1.1.34\"\n+#define PACKAGE_STRING \"libxslt 1.1.35\"\n@@ -170,1 +176,1 @@\n-#define PACKAGE_VERSION \"1.1.34\"\n+#define PACKAGE_VERSION \"1.1.35\"\n@@ -172,1 +178,3 @@\n-\/* Define to 1 if you have the ANSI C header files. *\/\n+\/* Define to 1 if all of the C90 standard headers exist (not just the ones\n+   required in a freestanding environment). This macro is provided for\n+   backward compatibility; new code need not use it. *\/\n@@ -198,1 +206,1 @@\n-#define VERSION \"1.1.34\"\n+#define VERSION \"1.1.35\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/mac\/config.h","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-either the GNOME FTP or the xmlsoft.org server:\n+either the GNOME download server or the GitLab release page:\n@@ -9,1 +9,2 @@\n-  ftp:\/\/xmlsoft.org\/\n+    https:\/\/gitlab.gnome.org\/GNOME\/libxml2\/-\/releases\n+    https:\/\/download.gnome.org\/sources\/libxml2\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/INSTALL","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+\t     CMakeLists.txt config.h.cmake.in FindGcrypt.cmake libxslt-config.cmake.in libxslt-config.cmake.cmake.in \\\n@@ -76,0 +77,3 @@\n+cmakedir = $(libdir)\/cmake\/libxslt\n+cmake_DATA = FindGcrypt.cmake libxslt-config.cmake\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/Makefile.am","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n-    http:\/\/xmlsoft.org\/XSLT\/\n+    https:\/\/gitlab.gnome.org\/GNOME\/libxslt\/-\/wikis\n@@ -10,1 +10,1 @@\n-  http:\/\/xmlsoft.org\/XSLT\/bugs.html\n+    https:\/\/gitlab.gnome.org\/GNOME\/libxslt\/-\/issues\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/README","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,2 +63,2 @@\n-\/* Define to 1 if you have the <memory.h> header file. *\/\n-#undef HAVE_MEMORY_H\n+\/* Define to 1 if you have the <minix\/config.h> header file. *\/\n+#undef HAVE_MINIX_CONFIG_H\n@@ -96,0 +96,3 @@\n+\/* Define to 1 if you have the <stdio.h> header file. *\/\n+#undef HAVE_STDIO_H\n+\n@@ -141,0 +144,3 @@\n+\/* Define to 1 if you have the <wchar.h> header file. *\/\n+#undef HAVE_WCHAR_H\n+\n@@ -147,2 +153,1 @@\n-\/* Define to the sub-directory in which libtool stores uninstalled libraries.\n-   *\/\n+\/* Define to the sub-directory where libtool stores uninstalled libraries. *\/\n@@ -172,1 +177,3 @@\n-\/* Define to 1 if you have the ANSI C header files. *\/\n+\/* Define to 1 if all of the C90 standard headers exist (not just the ones\n+   required in a freestanding environment). This macro is provided for\n+   backward compatibility; new code need not use it. *\/\n@@ -179,0 +186,8 @@\n+\/* Enable general extensions on macOS.  *\/\n+#ifndef _DARWIN_C_SOURCE\n+# undef _DARWIN_C_SOURCE\n+#endif\n+\/* Enable general extensions on Solaris.  *\/\n+#ifndef __EXTENSIONS__\n+# undef __EXTENSIONS__\n+#endif\n@@ -183,1 +198,30 @@\n-\/* Enable threading extensions on Solaris.  *\/\n+\/* Enable X\/Open compliant socket functions that do not require linking\n+   with -lxnet on HP-UX 11.11.  *\/\n+#ifndef _HPUX_ALT_XOPEN_SOCKET_API\n+# undef _HPUX_ALT_XOPEN_SOCKET_API\n+#endif\n+\/* Identify the host operating system as Minix.\n+   This macro does not affect the system headers' behavior.\n+   A future release of Autoconf may stop defining this macro.  *\/\n+#ifndef _MINIX\n+# undef _MINIX\n+#endif\n+\/* Enable general extensions on NetBSD.\n+   Enable NetBSD compatibility extensions on Minix.  *\/\n+#ifndef _NETBSD_SOURCE\n+# undef _NETBSD_SOURCE\n+#endif\n+\/* Enable OpenBSD compatibility extensions on NetBSD.\n+   Oddly enough, this does nothing on OpenBSD.  *\/\n+#ifndef _OPENBSD_SOURCE\n+# undef _OPENBSD_SOURCE\n+#endif\n+\/* Define to 1 if needed for POSIX-compatible behavior.  *\/\n+#ifndef _POSIX_SOURCE\n+# undef _POSIX_SOURCE\n+#endif\n+\/* Define to 2 if needed for POSIX-compatible behavior.  *\/\n+#ifndef _POSIX_1_SOURCE\n+# undef _POSIX_1_SOURCE\n+#endif\n+\/* Enable POSIX-compatible threading on Solaris.  *\/\n@@ -187,0 +231,28 @@\n+\/* Enable extensions specified by ISO\/IEC TS 18661-5:2014.  *\/\n+#ifndef __STDC_WANT_IEC_60559_ATTRIBS_EXT__\n+# undef __STDC_WANT_IEC_60559_ATTRIBS_EXT__\n+#endif\n+\/* Enable extensions specified by ISO\/IEC TS 18661-1:2014.  *\/\n+#ifndef __STDC_WANT_IEC_60559_BFP_EXT__\n+# undef __STDC_WANT_IEC_60559_BFP_EXT__\n+#endif\n+\/* Enable extensions specified by ISO\/IEC TS 18661-2:2015.  *\/\n+#ifndef __STDC_WANT_IEC_60559_DFP_EXT__\n+# undef __STDC_WANT_IEC_60559_DFP_EXT__\n+#endif\n+\/* Enable extensions specified by ISO\/IEC TS 18661-4:2015.  *\/\n+#ifndef __STDC_WANT_IEC_60559_FUNCS_EXT__\n+# undef __STDC_WANT_IEC_60559_FUNCS_EXT__\n+#endif\n+\/* Enable extensions specified by ISO\/IEC TS 18661-3:2015.  *\/\n+#ifndef __STDC_WANT_IEC_60559_TYPES_EXT__\n+# undef __STDC_WANT_IEC_60559_TYPES_EXT__\n+#endif\n+\/* Enable extensions specified by ISO\/IEC TR 24731-2:2010.  *\/\n+#ifndef __STDC_WANT_LIB_EXT2__\n+# undef __STDC_WANT_LIB_EXT2__\n+#endif\n+\/* Enable extensions specified by ISO\/IEC 24747:2009.  *\/\n+#ifndef __STDC_WANT_MATH_SPEC_FUNCS__\n+# undef __STDC_WANT_MATH_SPEC_FUNCS__\n+#endif\n@@ -191,3 +263,4 @@\n-\/* Enable general extensions on Solaris.  *\/\n-#ifndef __EXTENSIONS__\n-# undef __EXTENSIONS__\n+\/* Enable X\/Open extensions.  Define to 500 only if necessary\n+   to make mbstate_t available.  *\/\n+#ifndef _XOPEN_SOURCE\n+# undef _XOPEN_SOURCE\n@@ -205,10 +278,0 @@\n-\n-\/* Define to 1 if on MINIX. *\/\n-#undef _MINIX\n-\n-\/* Define to 2 if the system does not provide POSIX.1 features except with\n-   this defined. *\/\n-#undef _POSIX_1_SOURCE\n-\n-\/* Define to 1 if you need to in order for `stat' and other things to work. *\/\n-#undef _POSIX_SOURCE\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/config.h.in","additions":82,"deletions":19,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-m4_define([MICRO_VERSION], [34])\n+m4_define([MICRO_VERSION], [35])\n@@ -112,0 +112,7 @@\n+AC_ARG_ENABLE(rebuild-docs,\n+[  --enable-rebuild-docs[[=yes\/no]]  rebuild some generated docs [[default=no]]])\n+if test \"$enable_rebuild_docs\" = \"yes\" -a \"$srcdir\" != \".\"; then\n+  AC_MSG_ERROR([cannot rebuild docs when builddir != srcdir])\n+fi\n+AM_CONDITIONAL([REBUILD_DOCS], [test \"$enable_rebuild_docs\" = \"yes\"])\n+\n@@ -149,0 +156,1 @@\n+WITH_THREADS=0\n@@ -154,0 +162,1 @@\n+       WITH_THREADS=\"1\"\n@@ -158,0 +167,1 @@\n+AC_SUBST(WITH_THREADS)\n@@ -233,0 +243,1 @@\n+PYTHON_TESTS=\n@@ -234,1 +245,5 @@\n-AC_ARG_WITH(python, [  --with-python[=DIR]    Build Python bindings if found])\n+AC_ARG_WITH(python,\n+[  --with-python[[=DIR]]     build Python bindings if found])\n+AC_ARG_WITH(python_install_dir,\n+[  --with-python-install-dir=DIR\n+                          install Python bindings in DIR])\n@@ -241,6 +256,6 @@\n-\tif test -x \"$with_python\"\n-\tthen\n-\t    echo Found python in $with_python\n-\t    PYTHON=\"$with_python\"\n-\telse\n-            if test -x \"$PYTHON\"\n+        if test -x \"$with_python\/python.exe\"\n+        then\n+            echo Found python in $with_python\/python.exe\n+            PYTHON=\"$with_python\/python.exe\"\n+        else\n+            if test -x \"$with_python\"\n@@ -248,4 +263,10 @@\n-                echo Found python in environment PYTHON=$PYTHON\n-                with_python=`$PYTHON -c \"import sys; print sys.exec_prefix\"`\n-\t    else\n-\t        AC_PATH_PROG(PYTHON, python python2.4 python2.3 python2.2 python2.1 python2.0 python1.6 python1.5)\n+                echo Found python in $with_python\n+                PYTHON=\"$with_python\"\n+            else\n+                if test -x \"$PYTHON\"\n+                then\n+                    echo Found python in environment PYTHON=$PYTHON\n+                    with_python=`$PYTHON -c \"import sys; print(sys.exec_prefix)\"`\n+                else\n+                    AC_PATH_PROG(PYTHON, python python2.6 python2.5 python2.4 python2.3 python2.2 python2.1 python2.0 python1.6 python1.5)\n+\t\tfi\n@@ -257,2 +278,5 @@\n-        echo \"PYTHON is pointing at $PYTHON\"\n-        PYTHON_VERSION=`$PYTHON -c \"import sys; print sys.version[[0:3]]\"`\n+        PYTHON_VERSION=`$PYTHON -c \"from distutils import sysconfig; print(sysconfig.get_python_version())\"`\n+\tPYTHON_INCLUDES=`$PYTHON -c \"from distutils import sysconfig; print(sysconfig.get_python_inc())\"`\n+# does not work as it produce a \/usr\/lib\/python path instead of\/usr\/lib64\/python\n+#\n+#\tPYTHON_SITE_PACKAGES=`$PYTHON -c \"from distutils import sysconfig; print(sysconfig.get_python_lib())\"`\n@@ -260,2 +284,7 @@\n-\tLIBXML2_PYTHON=`$PYTHON -c \"try : import libxml2 ; print 1\n-except: print 0\"`\n+  LIBXML2_PYTHON=`$PYTHON -c \"import sys\n+try:\n+    import libxml2\n+    sys.stdout.write('1')\n+except:\n+    sys.stdout.write('0')\n+\"`\n@@ -267,1 +296,1 @@\n-\tfi\n+  fi\n@@ -269,1 +298,1 @@\n-    if test \"$PYTHON_VERSION\" != \"\"\n+    if test \"$PYTHON_VERSION\" != \"\" -a \"$PYTHON_INCLUDES\" = \"\"\n@@ -271,2 +300,1 @@\n-\tif test -r $with_python\/include\/python$PYTHON_VERSION\/Python.h -a \\\n-\t   -d $with_python\/lib\/python$PYTHON_VERSION\/site-packages\n+\tif test -r $with_python\/include\/python$PYTHON_VERSION\/Python.h\n@@ -275,1 +303,0 @@\n-\t    PYTHON_SITE_PACKAGES='$(libdir)\/python$(PYTHON_VERSION)\/site-packages'\n@@ -280,1 +307,0 @@\n-\t\tPYTHON_SITE_PACKAGES='$(libdir)\/python$(PYTHON_VERSION)\/site-packages'\n@@ -285,1 +311,0 @@\n-\t\t    PYTHON_SITE_PACKAGES='$(libdir)\/python$(PYTHON_VERSION)\/site-packages'\n@@ -287,1 +312,6 @@\n-\t\t    echo could not find python$PYTHON_VERSION\/Python.h\n+\t            if test -r $with_python\/include\/Python.h\n+\t            then\n+\t                PYTHON_INCLUDES=$with_python\/include\n+\t            else\n+\t\t        echo could not find python$PYTHON_VERSION\/Python.h or $with_python\/include\/Python.h\n+\t\t    fi\n@@ -290,4 +320,0 @@\n-\t    if test ! -d \"$PYTHON_SITE_PACKAGES\"\n-\t    then\n-\t\t    PYTHON_SITE_PACKAGES=`$PYTHON -c \"from distutils import sysconfig; print sysconfig.get_python_lib()\"`\n-\t    fi\n@@ -295,1 +321,0 @@\n-        PYTHON_LIBS=`python$PYTHON_VERSION-config --libs`\n@@ -297,1 +322,1 @@\n-    if test \"$with_python\" != \"\"\n+    if test \"$with_python_install_dir\" != \"\"\n@@ -299,3 +324,1 @@\n-        pythondir='$(PYTHON_SITE_PACKAGES)'\n-    else\n-        pythondir='$(libdir)\/python$(PYTHON_VERSION)\/site-packages'\n+\tPYTHON_SITE_PACKAGES=\"$with_python_install_dir\"\n@@ -303,0 +326,18 @@\n+    if test \"$PYTHON_VERSION\" != \"\" -a \"$PYTHON_SITE_PACKAGES\" = \"\"\n+    then\n+\tif test -d $libdir\/python$PYTHON_VERSION\/site-packages\n+\tthen\n+\t    PYTHON_SITE_PACKAGES=$libdir\/python$PYTHON_VERSION\/site-packages\n+\telse\n+\t    if test -d $with_python\/lib\/site-packages\n+\t    then\n+\t\tPYTHON_SITE_PACKAGES=$with_python\/lib\/site-packages\n+\t    else\n+\t\tPYTHON_SITE_PACKAGES=$($PYTHON -c 'from distutils import sysconfig; print(sysconfig.get_python_lib(True,False,\"${exec_prefix}\"))')\n+\t    fi\n+\tfi\n+    fi\n+    pythondir='$(PYTHON_SITE_PACKAGES)'\n+    PYTHON_LIBS=`python$PYTHON_VERSION-config --ldflags`\n+else\n+    PYTHON=\n@@ -477,1 +518,1 @@\n-    CFLAGS=\"${CFLAGS} -Wall -Wextra -Wformat=2 -Wmissing-format-attribute\"\n+    CFLAGS=\"${CFLAGS} -Wall -Wextra -Wformat=2 -Wmissing-format-attribute -Wshadow\"\n@@ -494,0 +535,1 @@\n+xml_config_dynamic=\n@@ -518,3 +560,3 @@\n-            LIBXML_LIBS=\"-L${LIBXML_SRC} `$XML_CONFIG --libs --dynamic`\"\n-        else\n-            LIBXML_LIBS=\"-L${LIBXML_SRC} `$XML_CONFIG --libs`\"\n+            if $XML_CONFIG --help | grep -q '\\--dynamic'; then\n+                xml_config_dynamic=--dynamic\n+            fi\n@@ -522,0 +564,1 @@\n+        LIBXML_LIBS=\"-L${LIBXML_SRC} `$XML_CONFIG --libs $xml_config_dynamic`\"\n@@ -549,1 +592,1 @@\n-if test \"x$LIBXML_LIBS\" = \"x\" && ${XML_CONFIG} --libs print > \/dev\/null 2>&1\n+if test \"x$LIBXML_LIBS\" = \"x\" && ${XML_CONFIG} --libs > \/dev\/null 2>&1\n@@ -560,3 +603,3 @@\n-        LIBXML_LIBS=\"`$XML_CONFIG --libs --dynamic`\"\n-    else\n-        LIBXML_LIBS=\"`$XML_CONFIG --libs`\"\n+        if $XML_CONFIG --help | grep -q '\\--dynamic'; then\n+            xml_config_dynamic=--dynamic\n+        fi\n@@ -564,2 +607,3 @@\n-\tLIBXML_CFLAGS=\"`$XML_CONFIG --cflags`\"\n-        WITH_MODULES=\"`$XML_CONFIG --modules`\"\n+    LIBXML_LIBS=\"`$XML_CONFIG --libs $xml_config_dynamic`\"\n+    LIBXML_CFLAGS=\"`$XML_CONFIG --cflags`\"\n+    WITH_MODULES=\"`$XML_CONFIG --modules`\"\n@@ -570,1 +614,1 @@\n-\tAC_MSG_ERROR([Could not find libxml2 anywhere, check ftp:\/\/xmlsoft.org\/.])\n+\tAC_MSG_ERROR([Could not find libxml2 anywhere.])\n@@ -653,1 +697,0 @@\n-EXSLT_LIBS=\"-lexslt $XSLT_LIBS\"\n@@ -657,1 +700,0 @@\n-AC_SUBST(EXSLT_LIBS)\n@@ -675,0 +717,1 @@\n+libxslt-config.cmake\n@@ -713,0 +756,2 @@\n+doc\/devhelp\/Makefile\n+doc\/EXSLT\/devhelp\/Makefile\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/configure.ac","additions":91,"deletions":46,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-Requires: libxml-2.0\n+Requires: libxml-2.0, libxslt\n@@ -12,1 +12,1 @@\n-Libs: @EXSLT_LIBDIR@ @EXSLT_LIBS@\n+Libs: @EXSLT_LIBDIR@ -lexslt\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libexslt.pc.in","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-        printf(\"*** You need a version of libxslt newer than %d.%d.%d. The latest version of\\n\",\n+        printf(\"*** You need a version of libxslt newer than %d.%d.%d.\\n\",\n@@ -127,1 +127,0 @@\n-        printf(\"*** libxslt is always available from ftp:\/\/ftp.xmlsoft.org.\\n\");\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt.m4","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-Libs: @XSLT_LIBDIR@ @XSLT_LIBS@ @EXTRA_LIBS@\n+Libs: @XSLT_LIBDIR@ -lxslt\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt.pc.in","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-Version: 1.1.34\n+Version: 1.1.35\n@@ -7,1 +7,1 @@\n-Source: ftp:\/\/xmlsoft.org\/XSLT\/libxslt-%{version}.tar.gz\n+Source: https:\/\/download.gnome.org\/sources\/libxslt\/1.1\/libxslt-%{version}.tar.xz\n@@ -9,1 +9,1 @@\n-URL: http:\/\/xmlsoft.org\/XSLT\/\n+URL: https:\/\/gitlab.gnome.org\/GNOME\/libxslt\n@@ -131,2 +131,2 @@\n-* Thu Nov 14 2019 Daniel Veillard <veillard@redhat.com>\n-- upstream release 1.1.34 see http:\/\/xmlsoft.org\/XSLT\/news.html\n+* Fri May 13 2022 Daniel Veillard <veillard@redhat.com>\n+- upstream release 1.1.35\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt.spec","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -7,1 +7,1 @@\n-Source: ftp:\/\/xmlsoft.org\/XSLT\/libxslt-%{version}.tar.gz\n+Source: https:\/\/download.gnome.org\/sources\/libxslt\/@LIBXSLT_MAJOR_VERSION@.@LIBXSLT_MINOR_VERSION@\/libxslt-%{version}.tar.xz\n@@ -9,1 +9,1 @@\n-URL: http:\/\/xmlsoft.org\/XSLT\/\n+URL: https:\/\/gitlab.gnome.org\/GNOME\/libxslt\n@@ -132,1 +132,1 @@\n-- upstream release @VERSION@ see http:\/\/xmlsoft.org\/XSLT\/news.html\n+- upstream release @VERSION@\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt.spec.in","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-#define IS_BLANK_NODE(n)                        \\\n+#define IS_BLANK_NODE(n)                                                \\\n@@ -117,3 +117,3 @@\n- *                                  *\n- *          XSLT Attribute handling             *\n- *                                  *\n+ *                                                                      *\n+ *                      XSLT Attribute handling                         *\n+ *                                                                      *\n@@ -137,2 +137,2 @@\n-        \"xsltNewAttrElem : malloc failed\\n\");\n-    return(NULL);\n+                \"xsltNewAttrElem : malloc failed\\n\");\n+        return(NULL);\n@@ -167,3 +167,3 @@\n-    next = list->next;\n-    xsltFreeAttrElem(list);\n-    list = next;\n+        next = list->next;\n+        xsltFreeAttrElem(list);\n+        list = next;\n@@ -187,1 +187,1 @@\n-    return(list);\n+        return(list);\n@@ -189,1 +189,1 @@\n-    return(xsltNewAttrElem(attr));\n+        return(xsltNewAttrElem(attr));\n@@ -192,6 +192,6 @@\n-    next = cur->next;\n-    if (next == NULL) {\n-        cur->next = xsltNewAttrElem(attr);\n-        return(list);\n-    }\n-    cur = next;\n+        next = cur->next;\n+        if (next == NULL) {\n+            cur->next = xsltNewAttrElem(attr);\n+            return(list);\n+        }\n+        cur = next;\n@@ -218,2 +218,2 @@\n-        \"xsltNewUseAttrSet : malloc failed\\n\");\n-    return(NULL);\n+                \"xsltNewUseAttrSet : malloc failed\\n\");\n+        return(NULL);\n@@ -249,3 +249,3 @@\n-    next = list->next;\n-    xsltFreeUseAttrSet(list);\n-    list = next;\n+        next = list->next;\n+        xsltFreeUseAttrSet(list);\n+        list = next;\n@@ -273,1 +273,1 @@\n-    return(xsltNewUseAttrSet(ncname, ns));\n+        return(xsltNewUseAttrSet(ncname, ns));\n@@ -278,6 +278,6 @@\n-    next = cur->next;\n-    if (next == NULL) {\n-        cur->next = xsltNewUseAttrSet(ncname, ns);\n-        return(list);\n-    }\n-    cur = next;\n+        next = cur->next;\n+        if (next == NULL) {\n+            cur->next = xsltNewUseAttrSet(ncname, ns);\n+            return(list);\n+        }\n+        cur = next;\n@@ -302,2 +302,2 @@\n-        \"xsltNewAttrSet : malloc failed\\n\");\n-    return(NULL);\n+                \"xsltNewAttrSet : malloc failed\\n\");\n+        return(NULL);\n@@ -340,6 +340,6 @@\n-    \/*\n-     * Check that the attribute is not yet in the list\n-     *\/\n-    cur = set->attrs;\n-    add = 1;\n-    while (cur != NULL) {\n+        \/*\n+         * Check that the attribute is not yet in the list\n+         *\/\n+        cur = set->attrs;\n+        add = 1;\n+        while (cur != NULL) {\n@@ -354,2 +354,2 @@\n-        if (cur->next == NULL)\n-        break;\n+            if (cur->next == NULL)\n+                break;\n@@ -357,1 +357,1 @@\n-    }\n+        }\n@@ -359,5 +359,6 @@\n-    if (add == 1) {\n-        if (cur == NULL) {\n-        set->attrs = xsltNewAttrElem(old->attr);\n-        } else if (add) {\n-        cur->next = xsltNewAttrElem(old->attr);\n+        if (add == 1) {\n+            if (cur == NULL) {\n+                set->attrs = xsltNewAttrElem(old->attr);\n+            } else if (add) {\n+                cur->next = xsltNewAttrElem(old->attr);\n+            }\n@@ -365,1 +366,0 @@\n-    }\n@@ -367,1 +367,1 @@\n-    old = old->next;\n+        old = old->next;\n@@ -372,3 +372,3 @@\n- *                                  *\n- *          Module interfaces               *\n- *                                  *\n+ *                                                                      *\n+ *                      Module interfaces                               *\n+ *                                                                      *\n@@ -395,1 +395,1 @@\n-    return;\n+        return;\n@@ -399,2 +399,2 @@\n-    xsltGenericError(xsltGenericErrorContext,\n-         \"xsl:attribute-set : name is missing\\n\");\n+        xsltGenericError(xsltGenericErrorContext,\n+             \"xsl:attribute-set : name is missing\\n\");\n@@ -402,2 +402,2 @@\n-        xmlFree(value);\n-    return;\n+            xmlFree(value);\n+        return;\n@@ -432,2 +432,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-        \"creating attribute set table\\n\");\n+        xsltGenericDebug(xsltGenericDebugContext,\n+            \"creating attribute set table\\n\");\n@@ -435,1 +435,1 @@\n-    style->attributeSets = xmlHashCreate(10);\n+        style->attributeSets = xmlHashCreate(10);\n@@ -438,1 +438,1 @@\n-    return;\n+        return;\n@@ -453,19 +453,19 @@\n-    \/*\n-    * Report invalid nodes.\n-    *\/\n-    if ((child->type != XML_ELEMENT_NODE) ||\n-        (child->ns == NULL) ||\n-        (! IS_XSLT_ELEM(child)))\n-    {\n-        if (child->type == XML_ELEMENT_NODE)\n-        xsltTransformError(NULL, style, child,\n-            \"xsl:attribute-set : unexpected child %s\\n\",\n-                         child->name);\n-        else\n-        xsltTransformError(NULL, style, child,\n-            \"xsl:attribute-set : child of unexpected type\\n\");\n-    } else if (!IS_XSLT_NAME(child, \"attribute\")) {\n-        xsltTransformError(NULL, style, child,\n-        \"xsl:attribute-set : unexpected child xsl:%s\\n\",\n-        child->name);\n-    } else {\n+        \/*\n+        * Report invalid nodes.\n+        *\/\n+        if ((child->type != XML_ELEMENT_NODE) ||\n+            (child->ns == NULL) ||\n+            (! IS_XSLT_ELEM(child)))\n+        {\n+            if (child->type == XML_ELEMENT_NODE)\n+                xsltTransformError(NULL, style, child,\n+                        \"xsl:attribute-set : unexpected child %s\\n\",\n+                                 child->name);\n+            else\n+                xsltTransformError(NULL, style, child,\n+                        \"xsl:attribute-set : child of unexpected type\\n\");\n+        } else if (!IS_XSLT_NAME(child, \"attribute\")) {\n+            xsltTransformError(NULL, style, child,\n+                \"xsl:attribute-set : unexpected child xsl:%s\\n\",\n+                child->name);\n+        } else {\n@@ -473,2 +473,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-        \"add attribute to list %s\\n\", ncname);\n+            xsltGenericDebug(xsltGenericDebugContext,\n+                \"add attribute to list %s\\n\", ncname);\n@@ -491,1 +491,1 @@\n-            set->attrs = xsltAddAttrElemList(set->attrs, child);\n+                set->attrs = xsltAddAttrElemList(set->attrs, child);\n@@ -493,1 +493,1 @@\n-    }\n+        }\n@@ -495,1 +495,1 @@\n-    child = child->next;\n+        child = child->next;\n@@ -503,12 +503,12 @@\n-    const xmlChar *curval, *endval;\n-    curval = value;\n-    while (*curval != 0) {\n-        while (IS_BLANK(*curval)) curval++;\n-        if (*curval == 0)\n-        break;\n-        endval = curval;\n-        while ((*endval != 0) && (!IS_BLANK(*endval))) endval++;\n-        curval = xmlDictLookup(style->dict, curval, endval - curval);\n-        if (curval) {\n-        const xmlChar *ncname2 = NULL;\n-        const xmlChar *prefix2 = NULL;\n+        const xmlChar *curval, *endval;\n+        curval = value;\n+        while (*curval != 0) {\n+            while (IS_BLANK(*curval)) curval++;\n+            if (*curval == 0)\n+                break;\n+            endval = curval;\n+            while ((*endval != 0) && (!IS_BLANK(*endval))) endval++;\n+            curval = xmlDictLookup(style->dict, curval, endval - curval);\n+            if (curval) {\n+                const xmlChar *ncname2 = NULL;\n+                const xmlChar *prefix2 = NULL;\n@@ -518,2 +518,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsl:attribute-set : %s adds use %s\\n\", ncname, curval);\n+                xsltGenericDebug(xsltGenericDebugContext,\n+                    \"xsl:attribute-set : %s adds use %s\\n\", ncname, curval);\n@@ -531,1 +531,1 @@\n-        ncname2 = xsltSplitQName(style->dict, curval, &prefix2);\n+                ncname2 = xsltSplitQName(style->dict, curval, &prefix2);\n@@ -547,0 +547,2 @@\n+            }\n+            curval = endval;\n@@ -548,4 +550,2 @@\n-        curval = endval;\n-    }\n-    xmlFree(value);\n-    value = NULL;\n+        xmlFree(value);\n+        value = NULL;\n@@ -556,1 +556,1 @@\n-    \"updated attribute list %s\\n\", ncname);\n+        \"updated attribute list %s\\n\", ncname);\n@@ -570,1 +570,1 @@\n-               int depth) {\n+                       int depth) {\n@@ -624,1 +624,1 @@\n-    xsltTransformError(NULL, topStyle, NULL,\n+        xsltTransformError(NULL, topStyle, NULL,\n@@ -632,3 +632,3 @@\n-    xsltTransformError(NULL, topStyle, NULL,\n-        \"xsl:attribute-set : use-attribute-sets maximum recursion \"\n-        \"depth exceeded on %s\\n\", name);\n+        xsltTransformError(NULL, topStyle, NULL,\n+                \"xsl:attribute-set : use-attribute-sets maximum recursion \"\n+                \"depth exceeded on %s\\n\", name);\n@@ -636,1 +636,1 @@\n-    return;\n+        return;\n@@ -678,2 +678,2 @@\n-                   const xmlChar *name, const xmlChar *ns,\n-               ATTRIBUTE_UNUSED const xmlChar *ignored) {\n+                       const xmlChar *name, const xmlChar *ns,\n+                       ATTRIBUTE_UNUSED const xmlChar *ignored) {\n@@ -694,1 +694,1 @@\n-        xsltGenericError(xsltGenericErrorContext,\n+            xsltGenericError(xsltGenericErrorContext,\n@@ -714,1 +714,1 @@\n-        \"Resolving attribute sets references\\n\");\n+            \"Resolving attribute sets references\\n\");\n@@ -719,2 +719,2 @@\n-    if (cur->attributeSets != NULL) {\n-        if (style->attributeSets == NULL) {\n+        if (cur->attributeSets != NULL) {\n+            if (style->attributeSets == NULL) {\n@@ -722,2 +722,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-            \"creating attribute set table\\n\");\n+                xsltGenericDebug(xsltGenericDebugContext,\n+                    \"creating attribute set table\\n\");\n@@ -725,2 +725,2 @@\n-        style->attributeSets = xmlHashCreate(10);\n-        }\n+                style->attributeSets = xmlHashCreate(10);\n+            }\n@@ -728,1 +728,1 @@\n-        xmlHashScanFull(cur->attributeSets, xsltResolveSASCallback,\n+            xmlHashScanFull(cur->attributeSets, xsltResolveSASCallback,\n@@ -739,2 +739,2 @@\n-    }\n-    cur = xsltNextImport(cur);\n+        }\n+        cur = xsltNextImport(cur);\n@@ -755,1 +755,1 @@\n-          xmlNodePtr contextNode,\n+              xmlNodePtr contextNode,\n@@ -757,1 +757,1 @@\n-          xsltElemPreCompPtr castedComp)\n+              xsltElemPreCompPtr castedComp)\n@@ -761,1 +761,1 @@\n-    (xsltStyleItemAttributePtr) castedComp;\n+        (xsltStyleItemAttributePtr) castedComp;\n@@ -797,2 +797,2 @@\n-        \"Internal error in xsltAttribute(): \"\n-        \"The XSLT 'attribute' instruction was not compiled.\\n\");\n+            \"Internal error in xsltAttribute(): \"\n+            \"The XSLT 'attribute' instruction was not compiled.\\n\");\n@@ -817,1 +817,1 @@\n-    return;\n+        return;\n@@ -830,4 +830,4 @@\n-    \/*\n-    * NOTE: Ah! This seems to be intended to support streamed\n-    *  result generation!.\n-    *\/\n+        \/*\n+        * NOTE: Ah! This seems to be intended to support streamed\n+        *  result generation!.\n+        *\/\n@@ -835,3 +835,3 @@\n-        \"xsl:attribute: Cannot add attributes to an \"\n-        \"element if children have been already added \"\n-        \"to the element.\\n\");\n+            \"xsl:attribute: Cannot add attributes to an \"\n+            \"element if children have been already added \"\n+            \"to the element.\\n\");\n@@ -852,1 +852,1 @@\n-    \/* TODO: fix attr acquisition wrt to the XSLT namespace *\/\n+        \/* TODO: fix attr acquisition wrt to the XSLT namespace *\/\n@@ -854,1 +854,1 @@\n-        (const xmlChar *) \"name\", XSLT_NAMESPACE);\n+            (const xmlChar *) \"name\", XSLT_NAMESPACE);\n@@ -857,1 +857,1 @@\n-        \"xsl:attribute: The attribute 'name' is missing.\\n\");\n+                \"xsl:attribute: The attribute 'name' is missing.\\n\");\n@@ -860,6 +860,6 @@\n-    if (xmlValidateQName(prop, 0)) {\n-        xsltTransformError(ctxt, NULL, inst,\n-        \"xsl:attribute: The effective name '%s' is not a \"\n-        \"valid QName.\\n\", prop);\n-        \/* we fall through to catch any further errors, if possible *\/\n-    }\n+        if (xmlValidateQName(prop, 0)) {\n+            xsltTransformError(ctxt, NULL, inst,\n+                \"xsl:attribute: The effective name '%s' is not a \"\n+                \"valid QName.\\n\", prop);\n+            \/* we fall through to catch any further errors, if possible *\/\n+        }\n@@ -867,4 +867,4 @@\n-    \/*\n-    * Reject a name of \"xmlns\".\n-    *\/\n-    if (xmlStrEqual(prop, BAD_CAST \"xmlns\")) {\n+        \/*\n+        * Reject a name of \"xmlns\".\n+        *\/\n+        if (xmlStrEqual(prop, BAD_CAST \"xmlns\")) {\n@@ -873,3 +873,3 @@\n-        xmlFree(prop);\n-        goto error;\n-    }\n+            xmlFree(prop);\n+            goto error;\n+        }\n@@ -877,2 +877,2 @@\n-    name = xsltSplitQName(ctxt->dict, prop, &prefix);\n-    xmlFree(prop);\n+        name = xsltSplitQName(ctxt->dict, prop, &prefix);\n+        xmlFree(prop);\n@@ -880,3 +880,3 @@\n-    \/*\n-    * The \"name\" value was static.\n-    *\/\n+        \/*\n+        * The \"name\" value was static.\n+        *\/\n@@ -884,2 +884,2 @@\n-    prefix = comp->nsPrefix;\n-    name = comp->name;\n+        prefix = comp->nsPrefix;\n+        name = comp->name;\n@@ -887,1 +887,1 @@\n-    name = xsltSplitQName(ctxt->dict, comp->name, &prefix);\n+        name = xsltSplitQName(ctxt->dict, comp->name, &prefix);\n@@ -898,4 +898,0 @@\n-    \/*\n-    * The \"namespace\" attribute was existent.\n-    *\/\n-    if (comp->ns != NULL) {\n@@ -903,1 +899,1 @@\n-        * No AVT; just plain text for the namespace name.\n+        * The \"namespace\" attribute was existent.\n@@ -905,22 +901,26 @@\n-        if (comp->ns[0] != 0)\n-        nsName = comp->ns;\n-    } else {\n-        xmlChar *tmpNsName;\n-        \/*\n-        * Eval the AVT.\n-        *\/\n-        \/* TODO: check attr acquisition wrt to the XSLT namespace *\/\n-        tmpNsName = xsltEvalAttrValueTemplate(ctxt, inst,\n-        (const xmlChar *) \"namespace\", XSLT_NAMESPACE);\n-        \/*\n-        * This fixes bug #302020: The AVT might also evaluate to the\n-        * empty string; this means that the empty string also indicates\n-        * \"no namespace\".\n-        * SPEC XSLT 1.0:\n-        *  \"If the string is empty, then the expanded-name of the\n-        *  attribute has a null namespace URI.\"\n-        *\/\n-        if ((tmpNsName != NULL) && (tmpNsName[0] != 0))\n-        nsName = xmlDictLookup(ctxt->dict, BAD_CAST tmpNsName, -1);\n-        xmlFree(tmpNsName);\n-    }\n+        if (comp->ns != NULL) {\n+            \/*\n+            * No AVT; just plain text for the namespace name.\n+            *\/\n+            if (comp->ns[0] != 0)\n+                nsName = comp->ns;\n+        } else {\n+            xmlChar *tmpNsName;\n+            \/*\n+            * Eval the AVT.\n+            *\/\n+            \/* TODO: check attr acquisition wrt to the XSLT namespace *\/\n+            tmpNsName = xsltEvalAttrValueTemplate(ctxt, inst,\n+                (const xmlChar *) \"namespace\", XSLT_NAMESPACE);\n+            \/*\n+            * This fixes bug #302020: The AVT might also evaluate to the\n+            * empty string; this means that the empty string also indicates\n+            * \"no namespace\".\n+            * SPEC XSLT 1.0:\n+            *  \"If the string is empty, then the expanded-name of the\n+            *  attribute has a null namespace URI.\"\n+            *\/\n+            if ((tmpNsName != NULL) && (tmpNsName[0] != 0))\n+                nsName = xmlDictLookup(ctxt->dict, BAD_CAST tmpNsName, -1);\n+            xmlFree(tmpNsName);\n+        }\n@@ -940,9 +940,0 @@\n-    \/*\n-    * SPEC XSLT 1.0:\n-    *  \"If the namespace attribute is not present, then the QName is\n-    *  expanded into an expanded-name using the namespace declarations\n-    *  in effect for the xsl:attribute element, *not* including any\n-    *  default namespace declaration.\"\n-    *\/\n-    ns = xmlSearchNs(inst->doc, inst, prefix);\n-    if (ns == NULL) {\n@@ -950,2 +941,5 @@\n-        * Note that this is treated as an error now (checked with\n-        *  Saxon, Xalan-J and MSXML).\n+        * SPEC XSLT 1.0:\n+        *  \"If the namespace attribute is not present, then the QName is\n+        *  expanded into an expanded-name using the namespace declarations\n+        *  in effect for the xsl:attribute element, *not* including any\n+        *  default namespace declaration.\"\n@@ -953,7 +947,13 @@\n-        xsltTransformError(ctxt, NULL, inst,\n-        \"xsl:attribute: The QName '%s:%s' has no \"\n-        \"namespace binding in scope in the stylesheet; \"\n-        \"this is an error, since the namespace was not \"\n-        \"specified by the instruction itself.\\n\", prefix, name);\n-    } else\n-        nsName = ns->href;\n+        ns = xmlSearchNs(inst->doc, inst, prefix);\n+        if (ns == NULL) {\n+            \/*\n+            * Note that this is treated as an error now (checked with\n+            *  Saxon, Xalan-J and MSXML).\n+            *\/\n+            xsltTransformError(ctxt, NULL, inst,\n+                \"xsl:attribute: The QName '%s:%s' has no \"\n+                \"namespace binding in scope in the stylesheet; \"\n+                \"this is an error, since the namespace was not \"\n+                \"specified by the instruction itself.\\n\", prefix, name);\n+        } else\n+            nsName = ns->href;\n@@ -969,10 +969,0 @@\n-    \/*\n-    * OPTIMIZE TODO: How do we know if we are adding to a\n-    *  fragment or to the result tree?\n-    *\n-    * If we are adding to a result tree fragment (i.e., not to the\n-    * actual result tree), we'll don't bother searching for the\n-    * ns-decl, but just store it in the dummy-doc of the result\n-    * tree fragment.\n-    *\/\n-    if (nsName != NULL) {\n@@ -980,1 +970,7 @@\n-        * TODO: Get the doc of @targetElem.\n+        * OPTIMIZE TODO: How do we know if we are adding to a\n+        *  fragment or to the result tree?\n+        *\n+        * If we are adding to a result tree fragment (i.e., not to the\n+        * actual result tree), we'll don't bother searching for the\n+        * ns-decl, but just store it in the dummy-doc of the result\n+        * tree fragment.\n@@ -982,2 +978,6 @@\n-        ns = xsltTreeAcquireStoredNs(some doc, nsName, prefix);\n-    }\n+        if (nsName != NULL) {\n+            \/*\n+            * TODO: Get the doc of @targetElem.\n+            *\/\n+            ns = xsltTreeAcquireStoredNs(some doc, nsName, prefix);\n+        }\n@@ -988,14 +988,14 @@\n-    \/*\n-    * Something about ns-prefixes:\n-    * SPEC XSLT 1.0:\n-    *  \"XSLT processors may make use of the prefix of the QName specified\n-    *  in the name attribute when selecting the prefix used for outputting\n-    *  the created attribute as XML; however, they are not required to do\n-    *  so and, if the prefix is xmlns, they must not do so\"\n-    *\/\n-    \/*\n-    * xsl:attribute can produce a scenario where the prefix is NULL,\n-    * so generate a prefix.\n-    *\/\n-    if ((prefix == NULL) || xmlStrEqual(prefix, BAD_CAST \"xmlns\")) {\n-        xmlChar *pref = xmlStrdup(BAD_CAST \"ns_1\");\n+        \/*\n+        * Something about ns-prefixes:\n+        * SPEC XSLT 1.0:\n+        *  \"XSLT processors may make use of the prefix of the QName specified\n+        *  in the name attribute when selecting the prefix used for outputting\n+        *  the created attribute as XML; however, they are not required to do\n+        *  so and, if the prefix is xmlns, they must not do so\"\n+        *\/\n+        \/*\n+        * xsl:attribute can produce a scenario where the prefix is NULL,\n+        * so generate a prefix.\n+        *\/\n+        if ((prefix == NULL) || xmlStrEqual(prefix, BAD_CAST \"xmlns\")) {\n+            xmlChar *pref = xmlStrdup(BAD_CAST \"ns_1\");\n@@ -1003,1 +1003,1 @@\n-        ns = xsltGetSpecialNamespace(ctxt, inst, nsName, pref, targetElem);\n+            ns = xsltGetSpecialNamespace(ctxt, inst, nsName, pref, targetElem);\n@@ -1005,12 +1005,12 @@\n-        xmlFree(pref);\n-    } else {\n-        ns = xsltGetSpecialNamespace(ctxt, inst, nsName, prefix,\n-        targetElem);\n-    }\n-    if (ns == NULL) {\n-        xsltTransformError(ctxt, NULL, inst,\n-        \"Namespace fixup error: Failed to acquire an in-scope \"\n-        \"namespace binding for the generated attribute '{%s}%s'.\\n\",\n-        nsName, name);\n-        goto error;\n-    }\n+            xmlFree(pref);\n+        } else {\n+            ns = xsltGetSpecialNamespace(ctxt, inst, nsName, prefix,\n+                targetElem);\n+        }\n+        if (ns == NULL) {\n+            xsltTransformError(ctxt, NULL, inst,\n+                \"Namespace fixup error: Failed to acquire an in-scope \"\n+                \"namespace binding for the generated attribute '{%s}%s'.\\n\",\n+                nsName, name);\n+            goto error;\n+        }\n@@ -1023,5 +1023,5 @@\n-    \/*\n-    * No content.\n-    * TODO: Do we need to put the empty string in ?\n-    *\/\n-    attr = xmlSetNsProp(ctxt->insert, ns, name, (const xmlChar *) \"\");\n+        \/*\n+        * No content.\n+        * TODO: Do we need to put the empty string in ?\n+        *\/\n+        attr = xmlSetNsProp(ctxt->insert, ns, name, (const xmlChar *) \"\");\n@@ -1029,2 +1029,2 @@\n-        ((inst->children->type == XML_TEXT_NODE) ||\n-         (inst->children->type == XML_CDATA_SECTION_NODE)))\n+            ((inst->children->type == XML_TEXT_NODE) ||\n+             (inst->children->type == XML_CDATA_SECTION_NODE)))\n@@ -1032,1 +1032,1 @@\n-    xmlNodePtr copyTxt;\n+        xmlNodePtr copyTxt;\n@@ -1034,16 +1034,0 @@\n-    \/*\n-    * xmlSetNsProp() will take care of duplicates.\n-    *\/\n-    attr = xmlSetNsProp(ctxt->insert, ns, name, NULL);\n-    if (attr == NULL) \/* TODO: report error ? *\/\n-        goto error;\n-    \/*\n-    * This was taken over from xsltCopyText() (transform.c).\n-    *\/\n-    if (ctxt->internalized &&\n-        (ctxt->insert->doc != NULL) &&\n-        (ctxt->insert->doc->dict == ctxt->dict))\n-    {\n-        copyTxt = xmlNewText(NULL);\n-        if (copyTxt == NULL) \/* TODO: report error *\/\n-        goto error;\n@@ -1051,2 +1035,7 @@\n-        * This is a safe scenario where we don't need to lookup\n-        * the dict.\n+        * xmlSetNsProp() will take care of duplicates.\n+        *\/\n+        attr = xmlSetNsProp(ctxt->insert, ns, name, NULL);\n+        if (attr == NULL) \/* TODO: report error ? *\/\n+            goto error;\n+        \/*\n+        * This was taken over from xsltCopyText() (transform.c).\n@@ -1054,1 +1043,30 @@\n-        copyTxt->content = inst->children->content;\n+        if (ctxt->internalized &&\n+            (ctxt->insert->doc != NULL) &&\n+            (ctxt->insert->doc->dict == ctxt->dict))\n+        {\n+            copyTxt = xmlNewText(NULL);\n+            if (copyTxt == NULL) \/* TODO: report error *\/\n+                goto error;\n+            \/*\n+            * This is a safe scenario where we don't need to lookup\n+            * the dict.\n+            *\/\n+            copyTxt->content = inst->children->content;\n+            \/*\n+            * Copy \"disable-output-escaping\" information.\n+            * TODO: Does this have any effect for attribute values\n+            *  anyway?\n+            *\/\n+            if (inst->children->name == xmlStringTextNoenc)\n+                copyTxt->name = xmlStringTextNoenc;\n+        } else {\n+            \/*\n+            * Copy the value.\n+            *\/\n+            copyTxt = xmlNewText(inst->children->content);\n+            if (copyTxt == NULL) \/* TODO: report error *\/\n+                goto error;\n+        }\n+        attr->children = attr->last = copyTxt;\n+        copyTxt->parent = (xmlNodePtr) attr;\n+        copyTxt->doc = attr->doc;\n@@ -1061,19 +1079,1 @@\n-        copyTxt->name = xmlStringTextNoenc;\n-    } else {\n-        \/*\n-        * Copy the value.\n-        *\/\n-        copyTxt = xmlNewText(inst->children->content);\n-        if (copyTxt == NULL) \/* TODO: report error *\/\n-        goto error;\n-    }\n-    attr->children = attr->last = copyTxt;\n-    copyTxt->parent = (xmlNodePtr) attr;\n-    copyTxt->doc = attr->doc;\n-    \/*\n-    * Copy \"disable-output-escaping\" information.\n-    * TODO: Does this have any effect for attribute values\n-    *  anyway?\n-    *\/\n-    if (inst->children->name == xmlStringTextNoenc)\n-        copyTxt->name = xmlStringTextNoenc;\n+            copyTxt->name = xmlStringTextNoenc;\n@@ -1088,8 +1088,0 @@\n-    } else {\n-    \/*\n-    * The sequence constructor might be complex, so instantiate it.\n-    *\/\n-    value = xsltEvalTemplateString(ctxt, contextNode, inst);\n-    if (value != NULL) {\n-        attr = xmlSetNsProp(ctxt->insert, ns, name, value);\n-        xmlFree(value);\n@@ -1098,3 +1090,1 @@\n-        * TODO: Do we have to add the empty string to the attr?\n-        * TODO: Does a  value of NULL indicate an\n-        *  error in xsltEvalTemplateString() ?\n+        * The sequence constructor might be complex, so instantiate it.\n@@ -1102,3 +1092,13 @@\n-        attr = xmlSetNsProp(ctxt->insert, ns, name,\n-        (const xmlChar *) \"\");\n-    }\n+        value = xsltEvalTemplateString(ctxt, contextNode, inst);\n+        if (value != NULL) {\n+            attr = xmlSetNsProp(ctxt->insert, ns, name, value);\n+            xmlFree(value);\n+        } else {\n+            \/*\n+            * TODO: Do we have to add the empty string to the attr?\n+            * TODO: Does a  value of NULL indicate an\n+            *  error in xsltEvalTemplateString() ?\n+            *\/\n+            attr = xmlSetNsProp(ctxt->insert, ns, name,\n+                (const xmlChar *) \"\");\n+        }\n@@ -1135,9 +1135,9 @@\n-    if (inst == NULL)\n-        return;\n-    else {\n-        \/*\n-        * Extract the value from @inst.\n-        *\/\n-        if (inst->type == XML_ATTRIBUTE_NODE) {\n-        if ( ((xmlAttrPtr) inst)->children != NULL)\n-            attrSets = ((xmlAttrPtr) inst)->children->content;\n+        if (inst == NULL)\n+            return;\n+        else {\n+            \/*\n+            * Extract the value from @inst.\n+            *\/\n+            if (inst->type == XML_ATTRIBUTE_NODE) {\n+                if ( ((xmlAttrPtr) inst)->children != NULL)\n+                    attrSets = ((xmlAttrPtr) inst)->children->content;\n@@ -1145,0 +1145,7 @@\n+            }\n+            if (attrSets == NULL) {\n+                \/*\n+                * TODO: Return an error?\n+                *\/\n+                return;\n+            }\n@@ -1146,7 +1153,0 @@\n-        if (attrSets == NULL) {\n-        \/*\n-        * TODO: Return an error?\n-        *\/\n-        return;\n-        }\n-    }\n@@ -1185,1 +1185,1 @@\n-            ns = xmlSearchNs(inst->doc, inst, prefix);\n+                ns = xmlSearchNs(inst->doc, inst, prefix);\n@@ -1199,3 +1199,3 @@\n-        (style->attributeSets != NULL) &&\n-        (ctxt->debugStatus != XSLT_DEBUG_NONE))\n-        {\n+                (style->attributeSets != NULL) &&\n+                (ctxt->debugStatus != XSLT_DEBUG_NONE))\n+            {\n@@ -1206,1 +1206,1 @@\n-            ctxt);\n+                        ctxt);\n@@ -1209,2 +1209,2 @@\n-        \/*\n-        * Lookup the referenced attribute-set. All attribute sets were\n+            \/*\n+            * Lookup the referenced attribute-set. All attribute sets were\n@@ -1213,1 +1213,1 @@\n-        *\/\n+            *\/\n@@ -1245,2 +1245,2 @@\n-    xmlHashFree((xmlHashTablePtr) style->attributeSets,\n-            xsltFreeAttributeSetsEntry);\n+        xmlHashFree((xmlHashTablePtr) style->attributeSets,\n+                    xsltFreeAttributeSetsEntry);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/attributes.c","additions":330,"deletions":330,"binary":false,"changes":660,"status":"modified"},{"patch":"@@ -22,2 +22,2 @@\n-    xsltParseStylesheetAttributeSet (xsltStylesheetPtr style,\n-                     xmlNodePtr cur);\n+        xsltParseStylesheetAttributeSet (xsltStylesheetPtr style,\n+                                         xmlNodePtr cur);\n@@ -25,1 +25,1 @@\n-    xsltFreeAttributeSetsHashes (xsltStylesheetPtr style);\n+        xsltFreeAttributeSetsHashes     (xsltStylesheetPtr style);\n@@ -27,4 +27,4 @@\n-    xsltApplyAttributeSet       (xsltTransformContextPtr ctxt,\n-                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     const xmlChar *attributes);\n+        xsltApplyAttributeSet           (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         const xmlChar *attributes);\n@@ -32,1 +32,1 @@\n-    xsltResolveStylesheetAttributeSet(xsltStylesheetPtr style);\n+        xsltResolveStylesheetAttributeSet(xsltStylesheetPtr style);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/attributes.h","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,3 +40,3 @@\n-    int nb_seg;     \/* Number of segments *\/\n-    int max_seg;    \/* max capacity before re-alloc needed *\/\n-    int strstart;   \/* is the start a string *\/\n+    int nb_seg;         \/* Number of segments *\/\n+    int max_seg;        \/* max capacity before re-alloc needed *\/\n+    int strstart;       \/* is the start a string *\/\n@@ -74,4 +74,4 @@\n-    xsltTransformError(NULL, style, NULL,\n-        \"xsltNewAttrVTPtr : malloc failed\\n\");\n-    if (style != NULL) style->errors++;\n-    return(NULL);\n+        xsltTransformError(NULL, style, NULL,\n+                \"xsltNewAttrVTPtr : malloc failed\\n\");\n+        if (style != NULL) style->errors++;\n+        return(NULL);\n@@ -107,5 +107,5 @@\n-    for (i = 0;i < avt->nb_seg; i += 2)\n-        if (avt->segments[i] != NULL)\n-        xmlFree((xmlChar *) avt->segments[i]);\n-    for (i = 1;i < avt->nb_seg; i += 2)\n-        xmlXPathFreeCompExpr((xmlXPathCompExprPtr) avt->segments[i]);\n+        for (i = 0;i < avt->nb_seg; i += 2)\n+            if (avt->segments[i] != NULL)\n+                xmlFree((xmlChar *) avt->segments[i]);\n+        for (i = 1;i < avt->nb_seg; i += 2)\n+            xmlXPathFreeCompExpr((xmlXPathCompExprPtr) avt->segments[i]);\n@@ -113,5 +113,5 @@\n-    for (i = 0;i < avt->nb_seg; i += 2)\n-        xmlXPathFreeCompExpr((xmlXPathCompExprPtr) avt->segments[i]);\n-    for (i = 1;i < avt->nb_seg; i += 2)\n-        if (avt->segments[i] != NULL)\n-        xmlFree((xmlChar *) avt->segments[i]);\n+        for (i = 0;i < avt->nb_seg; i += 2)\n+            xmlXPathFreeCompExpr((xmlXPathCompExprPtr) avt->segments[i]);\n+        for (i = 1;i < avt->nb_seg; i += 2)\n+            if (avt->segments[i] != NULL)\n+                xmlFree((xmlChar *) avt->segments[i]);\n@@ -136,2 +136,2 @@\n-    xsltFreeAttrVT(cur);\n-    cur = next;\n+        xsltFreeAttrVT(cur);\n+        cur = next;\n@@ -157,2 +157,2 @@\n-    xsltAttrVTPtr tmp = (xsltAttrVTPtr) xmlRealloc(avt, size);\n-    if (tmp == NULL) {\n+        xsltAttrVTPtr tmp = (xsltAttrVTPtr) xmlRealloc(avt, size);\n+        if (tmp == NULL) {\n@@ -160,2 +160,2 @@\n-        return NULL;\n-    }\n+            return NULL;\n+        }\n@@ -163,2 +163,2 @@\n-    memset(&avt->segments[avt->nb_seg], 0, MAX_AVT_SEG*sizeof(void *));\n-    avt->max_seg += MAX_AVT_SEG;\n+        memset(&avt->segments[avt->nb_seg], 0, MAX_AVT_SEG*sizeof(void *));\n+        avt->max_seg += MAX_AVT_SEG;\n@@ -193,4 +193,4 @@\n-        \"Attribute '%s': The content is expected to be a single text \"\n-        \"node when compiling an AVT.\\n\", attr->name);\n-    style->errors++;\n-    return;\n+            \"Attribute '%s': The content is expected to be a single text \"\n+            \"node when compiling an AVT.\\n\", attr->name);\n+        style->errors++;\n+        return;\n@@ -204,1 +204,1 @@\n-            \"Found AVT %s: %s\\n\", attr->name, str);\n+                    \"Found AVT %s: %s\\n\", attr->name, str);\n@@ -208,2 +208,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-            \"AVT %s: already compiled\\n\", attr->name);\n+        xsltGenericDebug(xsltGenericDebugContext,\n+                        \"AVT %s: already compiled\\n\", attr->name);\n@@ -218,1 +218,1 @@\n-    return;\n+        return;\n@@ -223,2 +223,2 @@\n-    while (avt->nsList[i] != NULL)\n-        i++;\n+        while (avt->nsList[i] != NULL)\n+            i++;\n@@ -230,2 +230,25 @@\n-    if (*cur == '{') {\n-        if (*(cur+1) == '{') {  \/* escaped '{' *\/\n+        if (*cur == '{') {\n+            if (*(cur+1) == '{') {      \/* escaped '{' *\/\n+                cur++;\n+                ret = xmlStrncat(ret, str, cur - str);\n+                cur++;\n+                str = cur;\n+                continue;\n+            }\n+            if (*(cur+1) == '}') {      \/* skip empty AVT *\/\n+                ret = xmlStrncat(ret, str, cur - str);\n+                cur += 2;\n+                str = cur;\n+                continue;\n+            }\n+            if ((ret != NULL) || (cur - str > 0)) {\n+                ret = xmlStrncat(ret, str, cur - str);\n+                str = cur;\n+                if (avt->nb_seg == 0)\n+                    avt->strstart = 1;\n+                if ((avt = xsltSetAttrVTsegment(avt, (void *) ret)) == NULL)\n+                    goto error;\n+                ret = NULL;\n+                lastavt = 0;\n+            }\n+\n@@ -233,12 +256,68 @@\n-        ret = xmlStrncat(ret, str, cur - str);\n-        cur++;\n-        str = cur;\n-        continue;\n-        }\n-        if (*(cur+1) == '}') {  \/* skip empty AVT *\/\n-        ret = xmlStrncat(ret, str, cur - str);\n-            cur += 2;\n-        str = cur;\n-        continue;\n-        }\n-        if ((ret != NULL) || (cur - str > 0)) {\n+            while ((*cur != 0) && (*cur != '}')) {\n+                \/* Need to check for literal (bug539741) *\/\n+                if ((*cur == '\\'') || (*cur == '\"')) {\n+                    char delim = *(cur++);\n+                    while ((*cur != 0) && (*cur != delim))\n+                        cur++;\n+                    if (*cur != 0)\n+                        cur++;  \/* skip the ending delimiter *\/\n+                } else\n+                    cur++;\n+            }\n+            if (*cur == 0) {\n+                xsltTransformError(NULL, style, attr->parent,\n+                     \"Attribute '%s': The AVT has an unmatched '{'.\\n\",\n+                     attr->name);\n+                style->errors++;\n+                goto error;\n+            }\n+            str++;\n+            expr = xmlStrndup(str, cur - str);\n+            if (expr == NULL) {\n+                \/*\n+                * TODO: What needs to be done here?\n+                *\/\n+                XSLT_TODO\n+                goto error;\n+            } else {\n+                xmlXPathCompExprPtr comp;\n+\n+                comp = xsltXPathCompile(style, expr);\n+                if (comp == NULL) {\n+                    xsltTransformError(NULL, style, attr->parent,\n+                         \"Attribute '%s': Failed to compile the expression \"\n+                         \"'%s' in the AVT.\\n\", attr->name, expr);\n+                    style->errors++;\n+                    goto error;\n+                }\n+                if (avt->nb_seg == 0)\n+                    avt->strstart = 0;\n+                if (lastavt == 1) {\n+                    if ((avt = xsltSetAttrVTsegment(avt, NULL)) == NULL)\n+                        goto error;\n+                }\n+                if ((avt = xsltSetAttrVTsegment(avt, (void *) comp)) == NULL)\n+                    goto error;\n+                lastavt = 1;\n+                xmlFree(expr);\n+                expr = NULL;\n+            }\n+            cur++;\n+            str = cur;\n+        } else if (*cur == '}') {\n+            cur++;\n+            if (*cur == '}') {  \/* escaped '}' *\/\n+                ret = xmlStrncat(ret, str, cur - str);\n+                cur++;\n+                str = cur;\n+                continue;\n+            } else {\n+                xsltTransformError(NULL, style, attr->parent,\n+                     \"Attribute '%s': The AVT has an unmatched '}'.\\n\",\n+                     attr->name);\n+                goto error;\n+            }\n+        } else\n+            cur++;\n+    }\n+    if ((ret != NULL) || (cur - str > 0)) {\n@@ -252,79 +331,0 @@\n-        lastavt = 0;\n-        }\n-\n-        cur++;\n-        while ((*cur != 0) && (*cur != '}')) {\n-        \/* Need to check for literal (bug539741) *\/\n-        if ((*cur == '\\'') || (*cur == '\"')) {\n-            char delim = *(cur++);\n-            while ((*cur != 0) && (*cur != delim))\n-            cur++;\n-            if (*cur != 0)\n-            cur++;  \/* skip the ending delimiter *\/\n-        } else\n-            cur++;\n-        }\n-        if (*cur == 0) {\n-            xsltTransformError(NULL, style, attr->parent,\n-             \"Attribute '%s': The AVT has an unmatched '{'.\\n\",\n-             attr->name);\n-        style->errors++;\n-        goto error;\n-        }\n-        str++;\n-        expr = xmlStrndup(str, cur - str);\n-        if (expr == NULL) {\n-        \/*\n-        * TODO: What needs to be done here?\n-        *\/\n-            XSLT_TODO\n-        goto error;\n-        } else {\n-        xmlXPathCompExprPtr comp;\n-\n-        comp = xsltXPathCompile(style, expr);\n-        if (comp == NULL) {\n-            xsltTransformError(NULL, style, attr->parent,\n-             \"Attribute '%s': Failed to compile the expression \"\n-             \"'%s' in the AVT.\\n\", attr->name, expr);\n-            style->errors++;\n-            goto error;\n-        }\n-        if (avt->nb_seg == 0)\n-            avt->strstart = 0;\n-        if (lastavt == 1) {\n-            if ((avt = xsltSetAttrVTsegment(avt, NULL)) == NULL)\n-                goto error;\n-        }\n-        if ((avt = xsltSetAttrVTsegment(avt, (void *) comp)) == NULL)\n-            goto error;\n-        lastavt = 1;\n-        xmlFree(expr);\n-        expr = NULL;\n-        }\n-        cur++;\n-        str = cur;\n-    } else if (*cur == '}') {\n-        cur++;\n-        if (*cur == '}') {  \/* escaped '}' *\/\n-        ret = xmlStrncat(ret, str, cur - str);\n-        cur++;\n-        str = cur;\n-        continue;\n-        } else {\n-            xsltTransformError(NULL, style, attr->parent,\n-             \"Attribute '%s': The AVT has an unmatched '}'.\\n\",\n-             attr->name);\n-        goto error;\n-        }\n-    } else\n-        cur++;\n-    }\n-    if ((ret != NULL) || (cur - str > 0)) {\n-    ret = xmlStrncat(ret, str, cur - str);\n-    str = cur;\n-    if (avt->nb_seg == 0)\n-        avt->strstart = 1;\n-    if ((avt = xsltSetAttrVTsegment(avt, (void *) ret)) == NULL)\n-        goto error;\n-    ret = NULL;\n@@ -336,1 +336,1 @@\n-        \"xsltCompileAttr: malloc problem\\n\");\n+                \"xsltCompileAttr: malloc problem\\n\");\n@@ -340,8 +340,8 @@\n-        \/*\n-         * This is a \"hack\", but I can't see any clean method of\n-         * doing it.  If a re-alloc has taken place, then the pointer\n-         * for this AVT may have changed.  style->attVTs was set by\n-         * xsltNewAttrVT, so it needs to be re-set to the new value!\n-         *\/\n-        style->attVTs = avt;\n-    }\n+            \/*\n+             * This is a \"hack\", but I can't see any clean method of\n+             * doing it.  If a re-alloc has taken place, then the pointer\n+             * for this AVT may have changed.  style->attVTs was set by\n+             * xsltNewAttrVT, so it needs to be re-set to the new value!\n+             *\/\n+            style->attVTs = avt;\n+        }\n@@ -350,1 +350,1 @@\n-    xmlFree(ret);\n+        xmlFree(ret);\n@@ -352,1 +352,1 @@\n-    xmlFree(expr);\n+        xmlFree(expr);\n@@ -380,8 +380,1 @@\n-        ret = xmlStrcat(ret, (const xmlChar *) cur->segments[i]);\n-    } else {\n-        comp = (xmlXPathCompExprPtr) cur->segments[i];\n-        tmp = xsltEvalXPathStringNs(ctxt, comp, cur->nsNr, cur->nsList);\n-        if (tmp != NULL) {\n-            if (ret != NULL) {\n-            ret = xmlStrcat(ret, tmp);\n-            xmlFree(tmp);\n+            ret = xmlStrcat(ret, (const xmlChar *) cur->segments[i]);\n@@ -389,2 +382,10 @@\n-            ret = tmp;\n-        }\n+            comp = (xmlXPathCompExprPtr) cur->segments[i];\n+            tmp = xsltEvalXPathStringNs(ctxt, comp, cur->nsNr, cur->nsList);\n+            if (tmp != NULL) {\n+                if (ret != NULL) {\n+                    ret = xmlStrcat(ret, tmp);\n+                    xmlFree(tmp);\n+                } else {\n+                    ret = tmp;\n+                }\n+            }\n@@ -392,2 +393,1 @@\n-    }\n-    str = !str;\n+        str = !str;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/attrvt.c","additions":151,"deletions":151,"binary":false,"changes":302,"status":"modified"},{"patch":"@@ -39,3 +39,3 @@\n- *                                  *\n- *      Hooks for the document loader               *\n- *                                  *\n+ *                                                                      *\n+ *              Hooks for the document loader                           *\n+ *                                                                      *\n@@ -63,1 +63,1 @@\n-             xsltLoadType type ATTRIBUTE_UNUSED)\n+                         xsltLoadType type ATTRIBUTE_UNUSED)\n@@ -74,1 +74,1 @@\n-    pctxt->dict = NULL;\n+        pctxt->dict = NULL;\n@@ -77,2 +77,2 @@\n-    pctxt->dict = dict;\n-    xmlDictReference(pctxt->dict);\n+        pctxt->dict = dict;\n+        xmlDictReference(pctxt->dict);\n@@ -80,1 +80,1 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n+        xsltGenericDebug(xsltGenericDebugContext,\n@@ -88,1 +88,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -129,3 +129,3 @@\n- *                                  *\n- *          Module interfaces               *\n- *                                  *\n+ *                                                                      *\n+ *                      Module interfaces                               *\n+ *                                                                      *\n@@ -149,3 +149,3 @@\n-    xsltTransformError(ctxt, NULL, (xmlNodePtr) doc,\n-        \"xsltNewDocument : malloc failed\\n\");\n-    return(NULL);\n+        xsltTransformError(ctxt, NULL, (xmlNodePtr) doc,\n+                \"xsltNewDocument : malloc failed\\n\");\n+        return(NULL);\n@@ -157,12 +157,12 @@\n-        cur->next = ctxt->docList;\n-        ctxt->docList = cur;\n-    }\n-    \/*\n-    * A key with a specific name for a specific document\n-    * will only be computed if there's a call to the key()\n-    * function using that specific name for that specific\n-    * document. I.e. computation of keys will be done in\n-    * xsltGetKey() (keys.c) on an on-demand basis.\n-    *\n-    * xsltInitCtxtKeys(ctxt, cur); not called here anymore\n-    *\/\n+            cur->next = ctxt->docList;\n+            ctxt->docList = cur;\n+        }\n+        \/*\n+        * A key with a specific name for a specific document\n+        * will only be computed if there's a call to the key()\n+        * function using that specific name for that specific\n+        * document. I.e. computation of keys will be done in\n+        * xsltGetKey() (keys.c) on an on-demand basis.\n+        *\n+        * xsltInitCtxtKeys(ctxt, cur); not called here anymore\n+        *\/\n@@ -188,3 +188,3 @@\n-    xsltTransformError(NULL, style, (xmlNodePtr) doc,\n-        \"xsltNewStyleDocument : malloc failed\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, style, (xmlNodePtr) doc,\n+                \"xsltNewStyleDocument : malloc failed\\n\");\n+        return(NULL);\n@@ -195,2 +195,2 @@\n-    cur->next = style->docList;\n-    style->docList = cur;\n+        cur->next = style->docList;\n+        style->docList = cur;\n@@ -217,1 +217,1 @@\n-    return;\n+        return;\n@@ -221,1 +221,1 @@\n-    nsMap = XSLT_GET_INTERNAL_NSMAP(style);\n+        nsMap = XSLT_GET_INTERNAL_NSMAP(style);\n@@ -223,1 +223,1 @@\n-    nsMap = NULL;\n+        nsMap = NULL;\n@@ -228,2 +228,2 @@\n-    doc = cur;\n-    cur = cur->next;\n+        doc = cur;\n+        cur = cur->next;\n@@ -231,5 +231,5 @@\n-    \/*\n-    * Restore all changed namespace URIs of ns-decls.\n-    *\/\n-    if (nsMap)\n-        xsltRestoreDocumentNamespaces(nsMap, doc->doc);\n+        \/*\n+        * Restore all changed namespace URIs of ns-decls.\n+        *\/\n+        if (nsMap)\n+            xsltRestoreDocumentNamespaces(nsMap, doc->doc);\n@@ -237,3 +237,3 @@\n-    xsltFreeDocumentKeys(doc);\n-    if (!doc->main)\n-        xmlFreeDoc(doc->doc);\n+        xsltFreeDocumentKeys(doc);\n+        if (!doc->main)\n+            xmlFreeDoc(doc->doc);\n@@ -256,5 +256,5 @@\n-    doc = cur;\n-    cur = cur->next;\n-    xsltFreeDocumentKeys(doc);\n-    if (!doc->main)\n-        xmlFreeDoc(doc->doc);\n+        doc = cur;\n+        cur = cur->next;\n+        xsltFreeDocumentKeys(doc);\n+        if (!doc->main)\n+            xmlFreeDoc(doc->doc);\n@@ -265,5 +265,5 @@\n-    doc = cur;\n-    cur = cur->next;\n-    xsltFreeDocumentKeys(doc);\n-    if (!doc->main)\n-        xmlFreeDoc(doc->doc);\n+        doc = cur;\n+        cur = cur->next;\n+        xsltFreeDocumentKeys(doc);\n+        if (!doc->main)\n+            xmlFreeDoc(doc->doc);\n@@ -290,1 +290,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -296,1 +296,1 @@\n-    int res;\n+        int res;\n@@ -298,2 +298,2 @@\n-    res = xsltCheckRead(ctxt->sec, ctxt, URI);\n-    if (res <= 0) {\n+        res = xsltCheckRead(ctxt->sec, ctxt, URI);\n+        if (res <= 0) {\n@@ -304,2 +304,2 @@\n-        return(NULL);\n-    }\n+            return(NULL);\n+        }\n@@ -313,4 +313,4 @@\n-    if ((ret->doc != NULL) && (ret->doc->URL != NULL) &&\n-        (xmlStrEqual(ret->doc->URL, URI)))\n-        return(ret);\n-    ret = ret->next;\n+        if ((ret->doc != NULL) && (ret->doc->URL != NULL) &&\n+            (xmlStrEqual(ret->doc->URL, URI)))\n+            return(ret);\n+        ret = ret->next;\n@@ -323,1 +323,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -328,1 +328,1 @@\n-    xmlXIncludeProcessFlags(doc, ctxt->parserOptions);\n+        xmlXIncludeProcessFlags(doc, ctxt->parserOptions);\n@@ -330,1 +330,1 @@\n-    xmlXIncludeProcess(doc);\n+        xmlXIncludeProcess(doc);\n@@ -333,3 +333,3 @@\n-    xsltTransformError(ctxt, NULL, NULL,\n-        \"xsltLoadDocument(%s) : XInclude processing not compiled in\\n\",\n-                     URI);\n+        xsltTransformError(ctxt, NULL, NULL,\n+            \"xsltLoadDocument(%s) : XInclude processing not compiled in\\n\",\n+                         URI);\n@@ -342,1 +342,1 @@\n-    xsltApplyStripSpaces(ctxt, xmlDocGetRootElement(doc));\n+        xsltApplyStripSpaces(ctxt, xmlDocGetRootElement(doc));\n@@ -344,1 +344,1 @@\n-    xmlXPathOrderDocElems(doc);\n+        xmlXPathOrderDocElems(doc);\n@@ -366,1 +366,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -373,1 +373,1 @@\n-    int res;\n+        int res;\n@@ -375,2 +375,2 @@\n-    res = xsltCheckRead(sec, NULL, URI);\n-    if (res <= 0) {\n+        res = xsltCheckRead(sec, NULL, URI);\n+        if (res <= 0) {\n@@ -381,2 +381,2 @@\n-        return(NULL);\n-    }\n+            return(NULL);\n+        }\n@@ -390,4 +390,4 @@\n-    if ((ret->doc != NULL) && (ret->doc->URL != NULL) &&\n-        (xmlStrEqual(ret->doc->URL, URI)))\n-        return(ret);\n-    ret = ret->next;\n+        if ((ret->doc != NULL) && (ret->doc->URL != NULL) &&\n+            (xmlStrEqual(ret->doc->URL, URI)))\n+            return(ret);\n+        ret = ret->next;\n@@ -399,1 +399,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -421,1 +421,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -428,3 +428,3 @@\n-    if (ret->doc == doc)\n-        return(ret);\n-    ret = ret->next;\n+        if (ret->doc == doc)\n+            return(ret);\n+        ret = ret->next;\n@@ -433,1 +433,1 @@\n-    return(ctxt->document);\n+        return(ctxt->document);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/documents.c","additions":89,"deletions":89,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -24,2 +24,2 @@\n-        xsltNewDocument     (xsltTransformContextPtr ctxt,\n-                     xmlDocPtr doc);\n+                xsltNewDocument         (xsltTransformContextPtr ctxt,\n+                                         xmlDocPtr doc);\n@@ -27,2 +27,2 @@\n-        xsltLoadDocument    (xsltTransformContextPtr ctxt,\n-                     const xmlChar *URI);\n+                xsltLoadDocument        (xsltTransformContextPtr ctxt,\n+                                         const xmlChar *URI);\n@@ -30,2 +30,2 @@\n-        xsltFindDocument    (xsltTransformContextPtr ctxt,\n-                     xmlDocPtr doc);\n+                xsltFindDocument        (xsltTransformContextPtr ctxt,\n+                                         xmlDocPtr doc);\n@@ -33,1 +33,1 @@\n-        xsltFreeDocuments   (xsltTransformContextPtr ctxt);\n+                xsltFreeDocuments       (xsltTransformContextPtr ctxt);\n@@ -36,2 +36,2 @@\n-        xsltLoadStyleDocument   (xsltStylesheetPtr style,\n-                     const xmlChar *URI);\n+                xsltLoadStyleDocument   (xsltStylesheetPtr style,\n+                                         const xmlChar *URI);\n@@ -39,2 +39,2 @@\n-        xsltNewStyleDocument    (xsltStylesheetPtr style,\n-                     xmlDocPtr doc);\n+                xsltNewStyleDocument    (xsltStylesheetPtr style,\n+                                         xmlDocPtr doc);\n@@ -42,1 +42,1 @@\n-        xsltFreeStyleDocuments  (xsltStylesheetPtr style);\n+                xsltFreeStyleDocuments  (xsltStylesheetPtr style);\n@@ -54,1 +54,1 @@\n-    XSLT_LOAD_START = 0,    \/* loading for a top stylesheet *\/\n+    XSLT_LOAD_START = 0,        \/* loading for a top stylesheet *\/\n@@ -56,1 +56,1 @@\n-    XSLT_LOAD_DOCUMENT = 2  \/* loading document at transformation time *\/\n+    XSLT_LOAD_DOCUMENT = 2      \/* loading document at transformation time *\/\n@@ -76,5 +76,5 @@\n-typedef xmlDocPtr (*xsltDocLoaderFunc)      (const xmlChar *URI,\n-                         xmlDictPtr dict,\n-                         int options,\n-                         void *ctxt,\n-                         xsltLoadType type);\n+typedef xmlDocPtr (*xsltDocLoaderFunc)          (const xmlChar *URI,\n+                                                 xmlDictPtr dict,\n+                                                 int options,\n+                                                 void *ctxt,\n+                                                 xsltLoadType type);\n@@ -83,1 +83,1 @@\n-        xsltSetLoaderFunc       (xsltDocLoaderFunc f);\n+                xsltSetLoaderFunc               (xsltDocLoaderFunc f);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/documents.h","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -47,3 +47,3 @@\n- *                                  *\n- *          Private Types and Globals           *\n- *                                  *\n+ *                                                                      *\n+ *                      Private Types and Globals                       *\n+ *                                                                      *\n@@ -92,3 +92,3 @@\n- *                                  *\n- *          Type functions                  *\n- *                                  *\n+ *                                                                      *\n+ *                      Type functions                                  *\n+ *                                                                      *\n@@ -396,2 +396,2 @@\n-    if (NULL == ext_directory)\n-      return (-1);\n+        if (NULL == ext_directory)\n+          return (-1);\n@@ -402,1 +402,1 @@\n-               \"LIBXSLT_PLUGINS_PATH is %s\\n\", ext_directory);\n+                       \"LIBXSLT_PLUGINS_PATH is %s\\n\", ext_directory);\n@@ -418,1 +418,1 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n+        xsltGenericDebug(xsltGenericDebugContext,\n@@ -431,1 +431,1 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n+        xsltGenericDebug(xsltGenericDebugContext,\n@@ -448,4 +448,4 @@\n-     * Call the module's init function.  Note that this function\n-     * calls xsltRegisterExtModuleFull which will add the module\n-     * to xsltExtensionsHash (together with it's entry points).\n-     *\/\n+         * Call the module's init function.  Note that this function\n+         * calls xsltRegisterExtModuleFull which will add the module\n+         * to xsltExtensionsHash (together with it's entry points).\n+         *\/\n@@ -461,1 +461,1 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n+        xsltGenericDebug(xsltGenericDebugContext,\n@@ -483,3 +483,3 @@\n- *                                  *\n- *      The stylesheet extension prefixes handling      *\n- *                                  *\n+ *                                                                      *\n+ *              The stylesheet extension prefixes handling              *\n+ *                                                                      *\n@@ -530,1 +530,1 @@\n-    \"Registering extension namespace '%s'.\\n\", URI);\n+        \"Registering extension namespace '%s'.\\n\", URI);\n@@ -587,3 +587,3 @@\n- *                                  *\n- *      The extensions modules interfaces           *\n- *                                  *\n+ *                                                                      *\n+ *              The extensions modules interfaces                       *\n+ *                                                                      *\n@@ -681,1 +681,1 @@\n-                     const xmlChar * URI)\n+                                     const xmlChar * URI)\n@@ -688,1 +688,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -692,2 +692,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-        \"Not registered extension module: %s\\n\", URI);\n+        xsltGenericDebug(xsltGenericDebugContext,\n+            \"Not registered extension module: %s\\n\", URI);\n@@ -695,1 +695,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -706,2 +706,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-        \"Not registered extension module: %s\\n\", URI);\n+        xsltGenericDebug(xsltGenericDebugContext,\n+            \"Not registered extension module: %s\\n\", URI);\n@@ -709,1 +709,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -715,3 +715,3 @@\n-    style->extInfos = xmlHashCreate(10);\n-    if (style->extInfos == NULL)\n-        return (NULL);\n+        style->extInfos = xmlHashCreate(10);\n+        if (style->extInfos == NULL)\n+            return (NULL);\n@@ -724,2 +724,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-        \"Initializing module with *no* callback: %s\\n\", URI);\n+        xsltGenericDebug(xsltGenericDebugContext,\n+            \"Initializing module with *no* callback: %s\\n\", URI);\n@@ -729,2 +729,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-        \"Initializing module with callback: %s\\n\", URI);\n+        xsltGenericDebug(xsltGenericDebugContext,\n+            \"Initializing module with callback: %s\\n\", URI);\n@@ -732,4 +732,4 @@\n-    \/*\n-    * Fire the initialization callback.\n-    *\/\n-    userData = module->styleInitFunc(style, URI);\n+        \/*\n+        * Fire the initialization callback.\n+        *\/\n+        userData = module->styleInitFunc(style, URI);\n@@ -742,1 +742,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -745,1 +745,1 @@\n-    (void *) dataContainer) < 0)\n+        (void *) dataContainer) < 0)\n@@ -747,7 +747,7 @@\n-    xsltTransformError(NULL, style, NULL,\n-        \"Failed to register module '%s'.\\n\", URI);\n-    style->errors++;\n-    if (module->styleShutdownFunc)\n-        module->styleShutdownFunc(style, URI, userData);\n-    xsltFreeExtData(dataContainer);\n-    return (NULL);\n+        xsltTransformError(NULL, style, NULL,\n+            \"Failed to register module '%s'.\\n\", URI);\n+        style->errors++;\n+        if (module->styleShutdownFunc)\n+            module->styleShutdownFunc(style, URI, userData);\n+        xsltFreeExtData(dataContainer);\n+        return (NULL);\n@@ -779,2 +779,2 @@\n-    (xsltExtensionsHash == NULL))\n-    return (NULL);\n+        (xsltExtensionsHash == NULL))\n+        return (NULL);\n@@ -790,1 +790,1 @@\n-    tmpStyle = tmpStyle->parent;\n+        tmpStyle = tmpStyle->parent;\n@@ -792,10 +792,10 @@\n-    dataContainer =\n-        (xsltExtDataPtr) xmlHashLookup(tmpStyle->extInfos, URI);\n-    if (dataContainer != NULL) {\n-        \/*\n-        * The module was already initialized in the context\n-        * of this stylesheet; just return the user-data that\n-        * comes with it.\n-        *\/\n-        return(dataContainer->extData);\n-    }\n+        dataContainer =\n+            (xsltExtDataPtr) xmlHashLookup(tmpStyle->extInfos, URI);\n+        if (dataContainer != NULL) {\n+            \/*\n+            * The module was already initialized in the context\n+            * of this stylesheet; just return the user-data that\n+            * comes with it.\n+            *\/\n+            return(dataContainer->extData);\n+        }\n@@ -809,5 +809,6 @@\n-    if (tmpStyle->extInfos != NULL) {\n-        dataContainer =\n-        (xsltExtDataPtr) xmlHashLookup(tmpStyle->extInfos, URI);\n-        if (dataContainer != NULL) {\n-        return(dataContainer->extData);\n+        if (tmpStyle->extInfos != NULL) {\n+            dataContainer =\n+                (xsltExtDataPtr) xmlHashLookup(tmpStyle->extInfos, URI);\n+            if (dataContainer != NULL) {\n+                return(dataContainer->extData);\n+            }\n@@ -815,2 +816,1 @@\n-    }\n-    tmpStyle = xsltNextImport(tmpStyle);\n+        tmpStyle = xsltNextImport(tmpStyle);\n@@ -824,1 +824,1 @@\n-    return (dataContainer->extData);\n+        return (dataContainer->extData);\n@@ -841,1 +841,1 @@\n-                   const xmlChar * URI)\n+                                   const xmlChar * URI)\n@@ -846,2 +846,2 @@\n-    (xsltExtensionsHash == NULL))\n-    return (NULL);\n+        (xsltExtensionsHash == NULL))\n+        return (NULL);\n@@ -850,8 +850,8 @@\n-    dataContainer = (xsltExtDataPtr) xmlHashLookup(style->extInfos, URI);\n-    \/*\n-    * The module was already initialized in the context\n-    * of this stylesheet; just return the user-data that\n-    * comes with it.\n-    *\/\n-    if (dataContainer)\n-        return(dataContainer->extData);\n+        dataContainer = (xsltExtDataPtr) xmlHashLookup(style->extInfos, URI);\n+        \/*\n+        * The module was already initialized in the context\n+        * of this stylesheet; just return the user-data that\n+        * comes with it.\n+        *\/\n+        if (dataContainer)\n+            return(dataContainer->extData);\n@@ -863,1 +863,1 @@\n-    return (dataContainer->extData);\n+        return (dataContainer->extData);\n@@ -1179,2 +1179,2 @@\n-    (XSLT_CCTXT(style)->inode == NULL) ||\n-    (XSLT_CCTXT(style)->inode->extElemNs == NULL))\n+        (XSLT_CCTXT(style)->inode == NULL) ||\n+        (XSLT_CCTXT(style)->inode->extElemNs == NULL))\n@@ -1187,8 +1187,9 @@\n-    int i;\n-    xsltPointerListPtr list = XSLT_CCTXT(style)->inode->extElemNs;\n-\n-    for (i = 0; i < list->number; i++) {\n-        if (xmlStrEqual((const xmlChar *) list->items[i],\n-        URI))\n-        {\n-        return(1);\n+        int i;\n+        xsltPointerListPtr list = XSLT_CCTXT(style)->inode->extElemNs;\n+\n+        for (i = 0; i < list->number; i++) {\n+            if (xmlStrEqual((const xmlChar *) list->items[i],\n+                URI))\n+            {\n+                return(1);\n+            }\n@@ -1197,1 +1198,0 @@\n-    }\n@@ -1207,6 +1207,6 @@\n-    \/*\n-    * NOTE: This was change to work on namespace names rather\n-    * than namespace prefixes. This fixes bug #339583.\n-    * TODO: Consider renaming the field \"prefix\" of xsltExtDef\n-    *  to \"href\".\n-    *\/\n+        \/*\n+        * NOTE: This was change to work on namespace names rather\n+        * than namespace prefixes. This fixes bug #339583.\n+        * TODO: Consider renaming the field \"prefix\" of xsltExtDef\n+        *  to \"href\".\n+        *\/\n@@ -1598,16 +1598,16 @@\n-    \/*\n-    * REVISIT TODO: Check if the text below is correct.\n-    * This will return a xsltElemPreComp structure or NULL.\n-    * 1) If the the author of the extension needs a\n-    *  custom structure to hold the specific values of\n-    *  this extension, he will derive a structure based on\n-    *  xsltElemPreComp; thus we obviously *cannot* refactor\n-    *  the xsltElemPreComp structure, since all already derived\n-    *  user-defined strucures will break.\n-    *  Example: For the extension xsl:document,\n-    *   in xsltDocumentComp() (preproc.c), the structure\n-    *   xsltStyleItemDocument is allocated, filled with\n-    *   specific values and returned.\n-    * 2) If the author needs no values to be stored in\n-    *  this structure, then he'll return NULL;\n-    *\/\n+        \/*\n+        * REVISIT TODO: Check if the text below is correct.\n+        * This will return a xsltElemPreComp structure or NULL.\n+        * 1) If the the author of the extension needs a\n+        *  custom structure to hold the specific values of\n+        *  this extension, he will derive a structure based on\n+        *  xsltElemPreComp; thus we obviously *cannot* refactor\n+        *  the xsltElemPreComp structure, since all already derived\n+        *  user-defined strucures will break.\n+        *  Example: For the extension xsl:document,\n+        *   in xsltDocumentComp() (preproc.c), the structure\n+        *   xsltStyleItemDocument is allocated, filled with\n+        *   specific values and returned.\n+        * 2) If the author needs no values to be stored in\n+        *  this structure, then he'll return NULL;\n+        *\/\n@@ -1617,5 +1617,5 @@\n-    \/*\n-    * Default creation of a xsltElemPreComp structure, if\n-    * the author of this extension did not create a custom\n-    * structure.\n-    *\/\n+        \/*\n+        * Default creation of a xsltElemPreComp structure, if\n+        * the author of this extension did not create a custom\n+        * structure.\n+        *\/\n@@ -1737,1 +1737,1 @@\n-              xmlHashLookup2(xsltElementsHash, name, URI);\n+                  xmlHashLookup2(xsltElementsHash, name, URI);\n@@ -1777,1 +1777,1 @@\n-              xmlHashLookup2(xsltElementsHash, name, URI);\n+                  xmlHashLookup2(xsltElementsHash, name, URI);\n@@ -1972,9 +1972,3 @@\n- *                                  *\n- *      Test module http:\/\/xmlsoft.org\/XSLT\/            *\n- *                                  *\n- ************************************************************************\/\n-\n-\/************************************************************************\n- *                                  *\n- *      Test of the extension module API            *\n- *                                  *\n+ *                                                                      *\n+ *              Test of the extension module API                        *\n+ *                                                                      *\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/extensions.c","additions":127,"deletions":133,"binary":false,"changes":260,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-        xsltInitGlobals                 (void);\n+                xsltInitGlobals                 (void);\n@@ -45,2 +45,2 @@\n-typedef void * (*xsltStyleExtInitFunction)  (xsltStylesheetPtr style,\n-                         const xmlChar *URI);\n+typedef void * (*xsltStyleExtInitFunction)      (xsltStylesheetPtr style,\n+                                                 const xmlChar *URI);\n@@ -57,2 +57,2 @@\n-                         const xmlChar *URI,\n-                         void *data);\n+                                                 const xmlChar *URI,\n+                                                 void *data);\n@@ -70,1 +70,1 @@\n-                     const xmlChar *URI);\n+                                         const xmlChar *URI);\n@@ -81,2 +81,2 @@\n-                     const xmlChar *URI,\n-                     void *data);\n+                                         const xmlChar *URI,\n+                                         void *data);\n@@ -85,3 +85,3 @@\n-        xsltRegisterExtModule   (const xmlChar *URI,\n-                     xsltExtInitFunction initFunc,\n-                     xsltExtShutdownFunction shutdownFunc);\n+                xsltRegisterExtModule   (const xmlChar *URI,\n+                                         xsltExtInitFunction initFunc,\n+                                         xsltExtShutdownFunction shutdownFunc);\n@@ -89,6 +89,6 @@\n-        xsltRegisterExtModuleFull\n-                    (const xmlChar * URI,\n-                     xsltExtInitFunction initFunc,\n-                     xsltExtShutdownFunction shutdownFunc,\n-                     xsltStyleExtInitFunction styleInitFunc,\n-                     xsltStyleExtShutdownFunction styleShutdownFunc);\n+                xsltRegisterExtModuleFull\n+                                        (const xmlChar * URI,\n+                                         xsltExtInitFunction initFunc,\n+                                         xsltExtShutdownFunction shutdownFunc,\n+                                         xsltStyleExtInitFunction styleInitFunc,\n+                                         xsltStyleExtShutdownFunction styleShutdownFunc);\n@@ -97,1 +97,1 @@\n-        xsltUnregisterExtModule (const xmlChar * URI);\n+                xsltUnregisterExtModule (const xmlChar * URI);\n@@ -100,2 +100,2 @@\n-        xsltGetExtData      (xsltTransformContextPtr ctxt,\n-                     const xmlChar *URI);\n+                xsltGetExtData          (xsltTransformContextPtr ctxt,\n+                                         const xmlChar *URI);\n@@ -104,2 +104,2 @@\n-        xsltStyleGetExtData (xsltStylesheetPtr style,\n-                     const xmlChar *URI);\n+                xsltStyleGetExtData     (xsltStylesheetPtr style,\n+                                         const xmlChar *URI);\n@@ -108,3 +108,3 @@\n-        xsltStyleStylesheetLevelGetExtData(\n-                     xsltStylesheetPtr style,\n-                     const xmlChar * URI);\n+                xsltStyleStylesheetLevelGetExtData(\n+                                         xsltStylesheetPtr style,\n+                                         const xmlChar * URI);\n@@ -113,1 +113,1 @@\n-        xsltShutdownCtxtExts    (xsltTransformContextPtr ctxt);\n+                xsltShutdownCtxtExts    (xsltTransformContextPtr ctxt);\n@@ -116,1 +116,1 @@\n-        xsltShutdownExts    (xsltStylesheetPtr style);\n+                xsltShutdownExts        (xsltStylesheetPtr style);\n@@ -119,2 +119,2 @@\n-        xsltXPathGetTransformContext\n-                    (xmlXPathParserContextPtr ctxt);\n+                xsltXPathGetTransformContext\n+                                        (xmlXPathParserContextPtr ctxt);\n@@ -126,4 +126,4 @@\n-        xsltRegisterExtModuleFunction\n-                    (const xmlChar *name,\n-                     const xmlChar *URI,\n-                     xmlXPathFunction function);\n+                xsltRegisterExtModuleFunction\n+                                        (const xmlChar *name,\n+                                         const xmlChar *URI,\n+                                         xmlXPathFunction function);\n@@ -131,2 +131,2 @@\n-    xsltExtModuleFunctionLookup (const xmlChar *name,\n-                     const xmlChar *URI);\n+        xsltExtModuleFunctionLookup     (const xmlChar *name,\n+                                         const xmlChar *URI);\n@@ -134,3 +134,3 @@\n-        xsltUnregisterExtModuleFunction\n-                    (const xmlChar *name,\n-                     const xmlChar *URI);\n+                xsltUnregisterExtModuleFunction\n+                                        (const xmlChar *name,\n+                                         const xmlChar *URI);\n@@ -142,3 +142,3 @@\n-                    (xsltStylesheetPtr style,\n-                     xmlNodePtr inst,\n-                     xsltTransformFunction function);\n+                                        (xsltStylesheetPtr style,\n+                                         xmlNodePtr inst,\n+                                         xsltTransformFunction function);\n@@ -147,3 +147,3 @@\n-        xsltNewElemPreComp  (xsltStylesheetPtr style,\n-                     xmlNodePtr inst,\n-                     xsltTransformFunction function);\n+                xsltNewElemPreComp      (xsltStylesheetPtr style,\n+                                         xmlNodePtr inst,\n+                                         xsltTransformFunction function);\n@@ -151,5 +151,5 @@\n-        xsltInitElemPreComp (xsltElemPreCompPtr comp,\n-                     xsltStylesheetPtr style,\n-                     xmlNodePtr inst,\n-                     xsltTransformFunction function,\n-                     xsltElemPreCompDeallocator freeFunc);\n+                xsltInitElemPreComp     (xsltElemPreCompPtr comp,\n+                                         xsltStylesheetPtr style,\n+                                         xmlNodePtr inst,\n+                                         xsltTransformFunction function,\n+                                         xsltElemPreCompDeallocator freeFunc);\n@@ -158,5 +158,5 @@\n-        xsltRegisterExtModuleElement\n-                    (const xmlChar *name,\n-                     const xmlChar *URI,\n-                     xsltPreComputeFunction precomp,\n-                     xsltTransformFunction transform);\n+                xsltRegisterExtModuleElement\n+                                        (const xmlChar *name,\n+                                         const xmlChar *URI,\n+                                         xsltPreComputeFunction precomp,\n+                                         xsltTransformFunction transform);\n@@ -164,3 +164,3 @@\n-        xsltExtElementLookup    (xsltTransformContextPtr ctxt,\n-                     const xmlChar *name,\n-                     const xmlChar *URI);\n+                xsltExtElementLookup    (xsltTransformContextPtr ctxt,\n+                                         const xmlChar *name,\n+                                         const xmlChar *URI);\n@@ -168,3 +168,3 @@\n-        xsltExtModuleElementLookup\n-                    (const xmlChar *name,\n-                     const xmlChar *URI);\n+                xsltExtModuleElementLookup\n+                                        (const xmlChar *name,\n+                                         const xmlChar *URI);\n@@ -172,3 +172,3 @@\n-        xsltExtModuleElementPreComputeLookup\n-                    (const xmlChar *name,\n-                     const xmlChar *URI);\n+                xsltExtModuleElementPreComputeLookup\n+                                        (const xmlChar *name,\n+                                         const xmlChar *URI);\n@@ -176,3 +176,3 @@\n-        xsltUnregisterExtModuleElement\n-                    (const xmlChar *name,\n-                     const xmlChar *URI);\n+                xsltUnregisterExtModuleElement\n+                                        (const xmlChar *name,\n+                                         const xmlChar *URI);\n@@ -184,1 +184,1 @@\n-                     xmlNodePtr inst);\n+                                         xmlNodePtr inst);\n@@ -187,4 +187,4 @@\n-        xsltRegisterExtModuleTopLevel\n-                    (const xmlChar *name,\n-                     const xmlChar *URI,\n-                     xsltTopLevelFunction function);\n+                xsltRegisterExtModuleTopLevel\n+                                        (const xmlChar *name,\n+                                         const xmlChar *URI,\n+                                         xsltTopLevelFunction function);\n@@ -192,3 +192,3 @@\n-        xsltExtModuleTopLevelLookup\n-                    (const xmlChar *name,\n-                     const xmlChar *URI);\n+                xsltExtModuleTopLevelLookup\n+                                        (const xmlChar *name,\n+                                         const xmlChar *URI);\n@@ -196,3 +196,3 @@\n-        xsltUnregisterExtModuleTopLevel\n-                    (const xmlChar *name,\n-                     const xmlChar *URI);\n+                xsltUnregisterExtModuleTopLevel\n+                                        (const xmlChar *name,\n+                                         const xmlChar *URI);\n@@ -203,4 +203,4 @@\n-        xsltRegisterExtFunction (xsltTransformContextPtr ctxt,\n-                     const xmlChar *name,\n-                     const xmlChar *URI,\n-                     xmlXPathFunction function);\n+                xsltRegisterExtFunction (xsltTransformContextPtr ctxt,\n+                                         const xmlChar *name,\n+                                         const xmlChar *URI,\n+                                         xmlXPathFunction function);\n@@ -208,4 +208,4 @@\n-        xsltRegisterExtElement  (xsltTransformContextPtr ctxt,\n-                     const xmlChar *name,\n-                     const xmlChar *URI,\n-                     xsltTransformFunction function);\n+                xsltRegisterExtElement  (xsltTransformContextPtr ctxt,\n+                                         const xmlChar *name,\n+                                         const xmlChar *URI,\n+                                         xsltTransformFunction function);\n@@ -219,3 +219,3 @@\n-        xsltRegisterExtPrefix   (xsltStylesheetPtr style,\n-                     const xmlChar *prefix,\n-                     const xmlChar *URI);\n+                xsltRegisterExtPrefix   (xsltStylesheetPtr style,\n+                                         const xmlChar *prefix,\n+                                         const xmlChar *URI);\n@@ -223,2 +223,2 @@\n-        xsltCheckExtPrefix  (xsltStylesheetPtr style,\n-                     const xmlChar *URI);\n+                xsltCheckExtPrefix      (xsltStylesheetPtr style,\n+                                         const xmlChar *URI);\n@@ -226,2 +226,2 @@\n-        xsltCheckExtURI     (xsltStylesheetPtr style,\n-                     const xmlChar *URI);\n+                xsltCheckExtURI         (xsltStylesheetPtr style,\n+                                         const xmlChar *URI);\n@@ -229,1 +229,1 @@\n-        xsltInitCtxtExts    (xsltTransformContextPtr ctxt);\n+                xsltInitCtxtExts        (xsltTransformContextPtr ctxt);\n@@ -231,1 +231,1 @@\n-        xsltFreeCtxtExts    (xsltTransformContextPtr ctxt);\n+                xsltFreeCtxtExts        (xsltTransformContextPtr ctxt);\n@@ -233,1 +233,1 @@\n-        xsltFreeExts        (xsltStylesheetPtr style);\n+                xsltFreeExts            (xsltStylesheetPtr style);\n@@ -236,3 +236,3 @@\n-        xsltPreComputeExtModuleElement\n-                    (xsltStylesheetPtr style,\n-                     xmlNodePtr inst);\n+                xsltPreComputeExtModuleElement\n+                                        (xsltStylesheetPtr style,\n+                                         xmlNodePtr inst);\n@@ -245,2 +245,2 @@\n-        xsltGetExtInfo      (xsltStylesheetPtr style,\n-                     const xmlChar *URI);\n+                xsltGetExtInfo          (xsltStylesheetPtr style,\n+                                         const xmlChar *URI);\n@@ -249,1 +249,1 @@\n- * Test module http:\/\/xmlsoft.org\/XSLT\/\n+ * Test of the extension module API\n@@ -252,1 +252,1 @@\n-        xsltRegisterTestModule  (void);\n+                xsltRegisterTestModule  (void);\n@@ -254,1 +254,1 @@\n-        xsltDebugDumpExtensions (FILE * output);\n+                xsltDebugDumpExtensions (FILE * output);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/extensions.h","additions":103,"deletions":103,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -40,3 +40,3 @@\n- *                                  *\n- *      Handling of XSLT debugging              *\n- *                                  *\n+ *                                                                      *\n+ *              Handling of XSLT debugging                              *\n+ *                                                                      *\n@@ -115,3 +115,3 @@\n- *                                  *\n- *      Classic extensions as described by M. Kay       *\n- *                                  *\n+ *                                                                      *\n+ *              Classic extensions as described by M. Kay               *\n+ *                                                                      *\n@@ -133,4 +133,4 @@\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"node-set() : expects one result-tree arg\\n\");\n-    ctxt->error = XPATH_INVALID_ARITY;\n-    return;\n+        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+                \"node-set() : expects one result-tree arg\\n\");\n+        ctxt->error = XPATH_INVALID_ARITY;\n+        return;\n@@ -139,6 +139,6 @@\n-    ((ctxt->value->type != XPATH_XSLT_TREE) &&\n-     (ctxt->value->type != XPATH_NODESET))) {\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"node-set() invalid arg expecting a result tree\\n\");\n-    ctxt->error = XPATH_INVALID_TYPE;\n-    return;\n+        ((ctxt->value->type != XPATH_XSLT_TREE) &&\n+         (ctxt->value->type != XPATH_NODESET))) {\n+        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+            \"node-set() invalid arg expecting a result tree\\n\");\n+        ctxt->error = XPATH_INVALID_TYPE;\n+        return;\n@@ -147,1 +147,1 @@\n-    ctxt->value->type = XPATH_NODESET;\n+        ctxt->value->type = XPATH_NODESET;\n@@ -171,2 +171,2 @@\n-                  XSLT_LIBXSLT_NAMESPACE,\n-                  xsltFunctionNodeSet);\n+                                  XSLT_LIBXSLT_NAMESPACE,\n+                                  xsltFunctionNodeSet);\n@@ -174,2 +174,2 @@\n-                  XSLT_SAXON_NAMESPACE,\n-                  xsltFunctionNodeSet);\n+                                  XSLT_SAXON_NAMESPACE,\n+                                  xsltFunctionNodeSet);\n@@ -177,2 +177,2 @@\n-                  XSLT_XT_NAMESPACE,\n-                  xsltFunctionNodeSet);\n+                                  XSLT_XT_NAMESPACE,\n+                                  xsltFunctionNodeSet);\n@@ -180,3 +180,3 @@\n-                 XSLT_LIBXSLT_NAMESPACE,\n-                 NULL,\n-                 xsltDebug);\n+                                 XSLT_LIBXSLT_NAMESPACE,\n+                                 NULL,\n+                                 xsltDebug);\n@@ -184,3 +184,3 @@\n-                 XSLT_SAXON_NAMESPACE,\n-                 xsltDocumentComp,\n-                 xsltDocumentElem);\n+                                 XSLT_SAXON_NAMESPACE,\n+                                 xsltDocumentComp,\n+                                 xsltDocumentElem);\n@@ -188,3 +188,3 @@\n-                 XSLT_XALAN_NAMESPACE,\n-                 xsltDocumentComp,\n-                 xsltDocumentElem);\n+                                 XSLT_XALAN_NAMESPACE,\n+                                 xsltDocumentComp,\n+                                 xsltDocumentElem);\n@@ -192,3 +192,3 @@\n-                 XSLT_XT_NAMESPACE,\n-                 xsltDocumentComp,\n-                 xsltDocumentElem);\n+                                 XSLT_XT_NAMESPACE,\n+                                 xsltDocumentComp,\n+                                 xsltDocumentElem);\n@@ -196,3 +196,3 @@\n-                 XSLT_NAMESPACE,\n-                 xsltDocumentComp,\n-                 xsltDocumentElem);\n+                                 XSLT_NAMESPACE,\n+                                 xsltDocumentComp,\n+                                 xsltDocumentElem);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/extra.c","additions":38,"deletions":38,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-#define XSLT_XALAN_NAMESPACE ((xmlChar *)   \\\n-                            \"org.apache.xalan.xslt.extensions.Redirect\")\n+#define XSLT_XALAN_NAMESPACE ((xmlChar *)       \\\n+                                \"org.apache.xalan.xslt.extensions.Redirect\")\n@@ -53,2 +53,2 @@\n-        xsltFunctionNodeSet (xmlXPathParserContextPtr ctxt,\n-                     int nargs);\n+                xsltFunctionNodeSet     (xmlXPathParserContextPtr ctxt,\n+                                         int nargs);\n@@ -56,4 +56,4 @@\n-        xsltDebug       (xsltTransformContextPtr ctxt,\n-                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n+                xsltDebug               (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n@@ -63,1 +63,1 @@\n-        xsltRegisterExtras  (xsltTransformContextPtr ctxt);\n+                xsltRegisterExtras      (xsltTransformContextPtr ctxt);\n@@ -65,1 +65,1 @@\n-        xsltRegisterAllExtras   (void);\n+                xsltRegisterAllExtras   (void);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/extra.h","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-             const xmlChar *name, const xmlChar *ns_uri) {\n+                         const xmlChar *name, const xmlChar *ns_uri) {\n@@ -74,1 +74,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -88,1 +88,1 @@\n-    ret = xsltExtModuleFunctionLookup(name, ns_uri);\n+        ret = xsltExtModuleFunctionLookup(name, ns_uri);\n@@ -100,3 +100,3 @@\n- *                                  *\n- *          Module interfaces               *\n- *                                  *\n+ *                                                                      *\n+ *                      Module interfaces                               *\n+ *                                                                      *\n@@ -118,4 +118,4 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"document() : internal error tctxt == NULL\\n\");\n-    valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n-    return;\n+        xsltTransformError(NULL, NULL, NULL,\n+            \"document() : internal error tctxt == NULL\\n\");\n+        valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n+        return;\n@@ -126,4 +126,4 @@\n-    xsltTransformError(tctxt, NULL, NULL,\n-        \"document() : failed to parse URI\\n\");\n-    valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n-    return;\n+        xsltTransformError(tctxt, NULL, NULL,\n+            \"document() : failed to parse URI\\n\");\n+        valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n+        return;\n@@ -138,4 +138,4 @@\n-    uri->fragment = NULL;\n-    newURI = xmlSaveUri(uri);\n-    idoc = xsltLoadDocument(tctxt, newURI);\n-    xmlFree(newURI);\n+        uri->fragment = NULL;\n+        newURI = xmlSaveUri(uri);\n+        idoc = xsltLoadDocument(tctxt, newURI);\n+        xmlFree(newURI);\n@@ -143,1 +143,1 @@\n-    idoc = xsltLoadDocument(tctxt, URI);\n+        idoc = xsltLoadDocument(tctxt, URI);\n@@ -147,11 +147,11 @@\n-    if ((URI == NULL) ||\n-        (URI[0] == '#') ||\n-        ((tctxt->style->doc != NULL) &&\n-        (xmlStrEqual(tctxt->style->doc->URL, URI))))\n-    {\n-        \/*\n-        * This selects the stylesheet's doc itself.\n-        *\/\n-        doc = tctxt->style->doc;\n-    } else {\n-        valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n+        if ((URI == NULL) ||\n+            (URI[0] == '#') ||\n+            ((tctxt->style->doc != NULL) &&\n+            (xmlStrEqual(tctxt->style->doc->URL, URI))))\n+        {\n+            \/*\n+            * This selects the stylesheet's doc itself.\n+            *\/\n+            doc = tctxt->style->doc;\n+        } else {\n+            valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n@@ -159,2 +159,2 @@\n-        if (fragment != NULL)\n-        xmlFree(fragment);\n+            if (fragment != NULL)\n+                xmlFree(fragment);\n@@ -162,2 +162,2 @@\n-        return;\n-    }\n+            return;\n+        }\n@@ -165,1 +165,1 @@\n-    doc = idoc->doc;\n+        doc = idoc->doc;\n@@ -168,2 +168,2 @@\n-    valuePush(ctxt, xmlXPathNewNodeSet((xmlNodePtr) doc));\n-    return;\n+        valuePush(ctxt, xmlXPathNewNodeSet((xmlNodePtr) doc));\n+        return;\n@@ -176,3 +176,3 @@\n-    xsltTransformError(tctxt, NULL, NULL,\n-        \"document() : internal error xptrctxt == NULL\\n\");\n-    goto out_fragment;\n+        xsltTransformError(tctxt, NULL, NULL,\n+            \"document() : internal error xptrctxt == NULL\\n\");\n+        goto out_fragment;\n@@ -181,0 +181,10 @@\n+#if LIBXML_VERSION >= 20911 || \\\n+    defined(FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION)\n+    xptrctxt->opLimit = ctxt->context->opLimit;\n+    xptrctxt->opCount = ctxt->context->opCount;\n+    xptrctxt->depth = ctxt->context->depth;\n+\n+    resObj = xmlXPtrEval(fragment, xptrctxt);\n+\n+    ctxt->context->opCount = xptrctxt->opCount;\n+#else\n@@ -182,1 +192,0 @@\n-    xmlXPathFreeContext(xptrctxt);\n@@ -185,0 +194,3 @@\n+    xmlXPathFreeContext(xptrctxt);\n+#endif \/* LIBXML_XPTR_ENABLED *\/\n+\n@@ -186,1 +198,1 @@\n-    goto out_fragment;\n+        goto out_fragment;\n@@ -189,15 +201,15 @@\n-    case XPATH_NODESET:\n-        break;\n-    case XPATH_UNDEFINED:\n-    case XPATH_BOOLEAN:\n-    case XPATH_NUMBER:\n-    case XPATH_STRING:\n-    case XPATH_POINT:\n-    case XPATH_USERS:\n-    case XPATH_XSLT_TREE:\n-    case XPATH_RANGE:\n-    case XPATH_LOCATIONSET:\n-        xsltTransformError(tctxt, NULL, NULL,\n-        \"document() : XPointer does not select a node set: #%s\\n\",\n-        fragment);\n-    goto out_object;\n+        case XPATH_NODESET:\n+            break;\n+        case XPATH_UNDEFINED:\n+        case XPATH_BOOLEAN:\n+        case XPATH_NUMBER:\n+        case XPATH_STRING:\n+        case XPATH_POINT:\n+        case XPATH_USERS:\n+        case XPATH_XSLT_TREE:\n+        case XPATH_RANGE:\n+        case XPATH_LOCATIONSET:\n+            xsltTransformError(tctxt, NULL, NULL,\n+                \"document() : XPointer does not select a node set: #%s\\n\",\n+                fragment);\n+        goto out_object;\n@@ -317,1 +329,1 @@\n-            (target->type == XML_PI_NODE)) {\n+                (target->type == XML_PI_NODE)) {\n@@ -343,3 +355,3 @@\n-        xsltDocumentFunctionLoadDocument( ctxt, URI );\n-        xmlFree(URI);\n-    }\n+            xsltDocumentFunctionLoadDocument( ctxt, URI );\n+            xmlFree(URI);\n+        }\n@@ -365,4 +377,4 @@\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"key() : expects two arguments\\n\");\n-    ctxt->error = XPATH_INVALID_ARITY;\n-    return;\n+        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+                \"key() : expects two arguments\\n\");\n+        ctxt->error = XPATH_INVALID_ARITY;\n+        return;\n@@ -377,5 +389,5 @@\n-    (ctxt->value == NULL) || (ctxt->value->type != XPATH_STRING)) {\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"key() : invalid arg expecting a string\\n\");\n-    ctxt->error = XPATH_INVALID_TYPE;\n-    xmlXPathFreeObject(obj2);\n+        (ctxt->value == NULL) || (ctxt->value->type != XPATH_STRING)) {\n+        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+            \"key() : invalid arg expecting a string\\n\");\n+        ctxt->error = XPATH_INVALID_TYPE;\n+        xmlXPathFreeObject(obj2);\n@@ -383,1 +395,1 @@\n-    return;\n+        return;\n@@ -391,2 +403,2 @@\n-    int i;\n-    xmlXPathObjectPtr newobj, ret;\n+        int i;\n+        xmlXPathObjectPtr newobj, ret;\n@@ -394,1 +406,1 @@\n-    ret = xmlXPathNewNodeSet(NULL);\n+        ret = xmlXPathNewNodeSet(NULL);\n@@ -396,11 +408,12 @@\n-    if (obj2->nodesetval != NULL) {\n-        for (i = 0; i < obj2->nodesetval->nodeNr; i++) {\n-        valuePush(ctxt, xmlXPathObjectCopy(obj1));\n-        valuePush(ctxt,\n-              xmlXPathNewNodeSet(obj2->nodesetval->nodeTab[i]));\n-        xmlXPathStringFunction(ctxt, 1);\n-        xsltKeyFunction(ctxt, 2);\n-        newobj = valuePop(ctxt);\n-        ret->nodesetval = xmlXPathNodeSetMerge(ret->nodesetval,\n-                               newobj->nodesetval);\n-        xmlXPathFreeObject(newobj);\n+        if (obj2->nodesetval != NULL) {\n+            for (i = 0; i < obj2->nodesetval->nodeNr; i++) {\n+                valuePush(ctxt, xmlXPathObjectCopy(obj1));\n+                valuePush(ctxt,\n+                          xmlXPathNewNodeSet(obj2->nodesetval->nodeTab[i]));\n+                xmlXPathStringFunction(ctxt, 1);\n+                xsltKeyFunction(ctxt, 2);\n+                newobj = valuePop(ctxt);\n+                ret->nodesetval = xmlXPathNodeSetMerge(ret->nodesetval,\n+                                                       newobj->nodesetval);\n+                xmlXPathFreeObject(newobj);\n+            }\n@@ -408,2 +421,1 @@\n-    }\n-    valuePush(ctxt, ret);\n+        valuePush(ctxt, ret);\n@@ -411,8 +423,8 @@\n-    xmlNodeSetPtr nodelist = NULL;\n-    xmlChar *key = NULL, *value;\n-    const xmlChar *keyURI;\n-    xsltTransformContextPtr tctxt;\n-    xmlChar *qname, *prefix;\n-    xmlXPathContextPtr xpctxt = ctxt->context;\n-    xmlNodePtr tmpNode = NULL;\n-    xsltDocumentPtr oldDocInfo;\n+        xmlNodeSetPtr nodelist = NULL;\n+        xmlChar *key = NULL, *value;\n+        const xmlChar *keyURI;\n+        xsltTransformContextPtr tctxt;\n+        xmlChar *qname, *prefix;\n+        xmlXPathContextPtr xpctxt = ctxt->context;\n+        xmlNodePtr tmpNode = NULL;\n+        xsltDocumentPtr oldDocInfo;\n@@ -420,1 +432,1 @@\n-    tctxt = xsltXPathGetTransformContext(ctxt);\n+        tctxt = xsltXPathGetTransformContext(ctxt);\n@@ -422,1 +434,1 @@\n-    oldDocInfo = tctxt->document;\n+        oldDocInfo = tctxt->document;\n@@ -424,21 +436,1 @@\n-    if (xpctxt->node == NULL) {\n-        xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"Internal error in xsltKeyFunction(): \"\n-        \"The context node is not set on the XPath context.\\n\");\n-        tctxt->state = XSLT_STATE_STOPPED;\n-        goto error;\n-    }\n-    \/*\n-     * Get the associated namespace URI if qualified name\n-     *\/\n-    qname = obj1->stringval;\n-    key = xmlSplitQName2(qname, &prefix);\n-    if (key == NULL) {\n-        key = xmlStrdup(obj1->stringval);\n-        keyURI = NULL;\n-        if (prefix != NULL)\n-        xmlFree(prefix);\n-    } else {\n-        if (prefix != NULL) {\n-        keyURI = xmlXPathNsLookup(xpctxt, prefix);\n-        if (keyURI == NULL) {\n+        if (xpctxt->node == NULL) {\n@@ -446,4 +438,4 @@\n-            \"key() : prefix %s is not bound\\n\", prefix);\n-            \/*\n-            * TODO: Shouldn't we stop here?\n-            *\/\n+                \"Internal error in xsltKeyFunction(): \"\n+                \"The context node is not set on the XPath context.\\n\");\n+            tctxt->state = XSLT_STATE_STOPPED;\n+            goto error;\n@@ -451,1 +443,10 @@\n-        xmlFree(prefix);\n+        \/*\n+         * Get the associated namespace URI if qualified name\n+         *\/\n+        qname = obj1->stringval;\n+        key = xmlSplitQName2(qname, &prefix);\n+        if (key == NULL) {\n+            key = xmlStrdup(obj1->stringval);\n+            keyURI = NULL;\n+            if (prefix != NULL)\n+                xmlFree(prefix);\n@@ -453,1 +454,13 @@\n-        keyURI = NULL;\n+            if (prefix != NULL) {\n+                keyURI = xmlXPathNsLookup(xpctxt, prefix);\n+                if (keyURI == NULL) {\n+                    xsltTransformError(tctxt, NULL, tctxt->inst,\n+                        \"key() : prefix %s is not bound\\n\", prefix);\n+                    \/*\n+                    * TODO: Shouldn't we stop here?\n+                    *\/\n+                }\n+                xmlFree(prefix);\n+            } else {\n+                keyURI = NULL;\n+            }\n@@ -455,1 +468,0 @@\n-    }\n@@ -457,25 +469,0 @@\n-    \/*\n-     * Force conversion of first arg to string\n-     *\/\n-    valuePush(ctxt, obj2);\n-    xmlXPathStringFunction(ctxt, 1);\n-    if ((ctxt->value == NULL) || (ctxt->value->type != XPATH_STRING)) {\n-        xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"key() : invalid arg expecting a string\\n\");\n-        ctxt->error = XPATH_INVALID_TYPE;\n-        goto error;\n-    }\n-    obj2 = valuePop(ctxt);\n-    value = obj2->stringval;\n-\n-    \/*\n-    * We need to ensure that ctxt->document is available for\n-    * xsltGetKey().\n-    * First find the relevant doc, which is the context node's\n-    * owner doc; using context->doc is not safe, since\n-    * the doc could have been acquired via the document() function,\n-    * or the doc might be a Result Tree Fragment.\n-    * FUTURE INFO: In XSLT 2.0 the key() function takes an additional\n-    * argument indicating the doc to use.\n-    *\/\n-    if (xpctxt->node->type == XML_NAMESPACE_DECL) {\n@@ -483,8 +470,9 @@\n-        * REVISIT: This is a libxml hack! Check xpath.c for details.\n-        * The XPath module sets the owner element of a ns-node on\n-        * the ns->next field.\n-        *\/\n-        if ((((xmlNsPtr) xpctxt->node)->next != NULL) &&\n-        (((xmlNsPtr) xpctxt->node)->next->type == XML_ELEMENT_NODE))\n-        {\n-        tmpNode = (xmlNodePtr) ((xmlNsPtr) xpctxt->node)->next;\n+         * Force conversion of first arg to string\n+         *\/\n+        valuePush(ctxt, obj2);\n+        xmlXPathStringFunction(ctxt, 1);\n+        if ((ctxt->value == NULL) || (ctxt->value->type != XPATH_STRING)) {\n+            xsltTransformError(tctxt, NULL, tctxt->inst,\n+                \"key() : invalid arg expecting a string\\n\");\n+            ctxt->error = XPATH_INVALID_TYPE;\n+            goto error;\n@@ -492,9 +480,2 @@\n-    } else\n-        tmpNode = xpctxt->node;\n-\n-    if ((tmpNode == NULL) || (tmpNode->doc == NULL)) {\n-        xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"Internal error in xsltKeyFunction(): \"\n-        \"Couldn't get the doc of the XPath context node.\\n\");\n-        goto error;\n-    }\n+        obj2 = valuePop(ctxt);\n+        value = obj2->stringval;\n@@ -502,4 +483,0 @@\n-    if ((tctxt->document == NULL) ||\n-        (tctxt->document->doc != tmpNode->doc))\n-    {\n-        if (tmpNode->doc->name && (tmpNode->doc->name[0] == ' ')) {\n@@ -507,1 +484,8 @@\n-        * This is a Result Tree Fragment.\n+        * We need to ensure that ctxt->document is available for\n+        * xsltGetKey().\n+        * First find the relevant doc, which is the context node's\n+        * owner doc; using context->doc is not safe, since\n+        * the doc could have been acquired via the document() function,\n+        * or the doc might be a Result Tree Fragment.\n+        * FUTURE INFO: In XSLT 2.0 the key() function takes an additional\n+        * argument indicating the doc to use.\n@@ -509,3 +493,18 @@\n-        if (tmpNode->doc->_private == NULL) {\n-            tmpNode->doc->_private = xsltNewDocument(tctxt, tmpNode->doc);\n-            if (tmpNode->doc->_private == NULL)\n+        if (xpctxt->node->type == XML_NAMESPACE_DECL) {\n+            \/*\n+            * REVISIT: This is a libxml hack! Check xpath.c for details.\n+            * The XPath module sets the owner element of a ns-node on\n+            * the ns->next field.\n+            *\/\n+            if ((((xmlNsPtr) xpctxt->node)->next != NULL) &&\n+                (((xmlNsPtr) xpctxt->node)->next->type == XML_ELEMENT_NODE))\n+            {\n+                tmpNode = (xmlNodePtr) ((xmlNsPtr) xpctxt->node)->next;\n+            }\n+        } else\n+            tmpNode = xpctxt->node;\n+\n+        if ((tmpNode == NULL) || (tmpNode->doc == NULL)) {\n+            xsltTransformError(tctxt, NULL, tctxt->inst,\n+                \"Internal error in xsltKeyFunction(): \"\n+                \"Couldn't get the doc of the XPath context node.\\n\");\n@@ -514,2 +513,29 @@\n-        tctxt->document = (xsltDocumentPtr) tmpNode->doc->_private;\n-        } else {\n+\n+        if ((tctxt->document == NULL) ||\n+            (tctxt->document->doc != tmpNode->doc))\n+        {\n+            if (tmpNode->doc->name && (tmpNode->doc->name[0] == ' ')) {\n+                \/*\n+                * This is a Result Tree Fragment.\n+                *\/\n+                if (tmpNode->doc->_private == NULL) {\n+                    tmpNode->doc->_private = xsltNewDocument(tctxt, tmpNode->doc);\n+                    if (tmpNode->doc->_private == NULL)\n+                        goto error;\n+                }\n+                tctxt->document = (xsltDocumentPtr) tmpNode->doc->_private;\n+            } else {\n+                \/*\n+                * May be the initial source doc or a doc acquired via the\n+                * document() function.\n+                *\/\n+                tctxt->document = xsltFindDocument(tctxt, tmpNode->doc);\n+            }\n+            if (tctxt->document == NULL) {\n+                xsltTransformError(tctxt, NULL, tctxt->inst,\n+                    \"Internal error in xsltKeyFunction(): \"\n+                    \"Could not get the document info of a context doc.\\n\");\n+                tctxt->state = XSLT_STATE_STOPPED;\n+                goto error;\n+            }\n+        }\n@@ -517,2 +543,1 @@\n-        * May be the initial source doc or a doc acquired via the\n-        * document() function.\n+        * Get\/compute the key value.\n@@ -520,14 +545,1 @@\n-        tctxt->document = xsltFindDocument(tctxt, tmpNode->doc);\n-        }\n-        if (tctxt->document == NULL) {\n-        xsltTransformError(tctxt, NULL, tctxt->inst,\n-            \"Internal error in xsltKeyFunction(): \"\n-            \"Could not get the document info of a context doc.\\n\");\n-        tctxt->state = XSLT_STATE_STOPPED;\n-        goto error;\n-        }\n-    }\n-    \/*\n-    * Get\/compute the key value.\n-    *\/\n-    nodelist = xsltGetKey(tctxt, key, keyURI, value);\n+        nodelist = xsltGetKey(tctxt, key, keyURI, value);\n@@ -536,5 +548,5 @@\n-    tctxt->document = oldDocInfo;\n-    valuePush(ctxt, xmlXPathWrapNodeSet(\n-        xmlXPathNodeSetMerge(NULL, nodelist)));\n-    if (key != NULL)\n-        xmlFree(key);\n+        tctxt->document = oldDocInfo;\n+        valuePush(ctxt, xmlXPathWrapNodeSet(\n+            xmlXPathNodeSetMerge(NULL, nodelist)));\n+        if (key != NULL)\n+            xmlFree(key);\n@@ -544,1 +556,1 @@\n-    xmlXPathFreeObject(obj1);\n+        xmlXPathFreeObject(obj1);\n@@ -546,1 +558,1 @@\n-    xmlXPathFreeObject(obj2);\n+        xmlXPathFreeObject(obj2);\n@@ -564,3 +576,3 @@\n-        \"unparsed-entity-uri() : expects one string arg\\n\");\n-    ctxt->error = XPATH_INVALID_ARITY;\n-    return;\n+                \"unparsed-entity-uri() : expects one string arg\\n\");\n+        ctxt->error = XPATH_INVALID_ARITY;\n+        return;\n@@ -570,1 +582,1 @@\n-    obj = xmlXPathConvertString(obj);\n+        obj = xmlXPathConvertString(obj);\n@@ -575,6 +587,0 @@\n-    valuePush(ctxt, xmlXPathNewString((const xmlChar *)\"\"));\n-    } else {\n-    xmlEntityPtr entity;\n-\n-    entity = xmlGetDocEntity(ctxt->context->doc, str);\n-    if (entity == NULL) {\n@@ -583,5 +589,11 @@\n-        if (entity->URI != NULL)\n-        valuePush(ctxt, xmlXPathNewString(entity->URI));\n-        else\n-        valuePush(ctxt, xmlXPathNewString((const xmlChar *)\"\"));\n-    }\n+        xmlEntityPtr entity;\n+\n+        entity = xmlGetDocEntity(ctxt->context->doc, str);\n+        if (entity == NULL) {\n+            valuePush(ctxt, xmlXPathNewString((const xmlChar *)\"\"));\n+        } else {\n+            if (entity->URI != NULL)\n+                valuePush(ctxt, xmlXPathNewString(entity->URI));\n+            else\n+                valuePush(ctxt, xmlXPathNewString((const xmlChar *)\"\"));\n+        }\n@@ -616,1 +628,1 @@\n-    return;\n+        return;\n@@ -619,1 +631,1 @@\n-    return;\n+        return;\n@@ -624,2 +636,2 @@\n-    CAST_TO_STRING;\n-    decimalObj = valuePop(ctxt);\n+        CAST_TO_STRING;\n+        decimalObj = valuePop(ctxt);\n@@ -641,1 +653,1 @@\n-        formatValues = xsltDecimalFormatGetByQName(sheet, nsUri, ncname);\n+            formatValues = xsltDecimalFormatGetByQName(sheet, nsUri, ncname);\n@@ -643,6 +655,6 @@\n-    if (formatValues == NULL) {\n-        xsltTransformError(tctxt, NULL, NULL,\n-            \"format-number() : undeclared decimal format '%s'\\n\",\n-            decimalObj->stringval);\n-    }\n-    \/* Intentional fall-through *\/\n+        if (formatValues == NULL) {\n+            xsltTransformError(tctxt, NULL, NULL,\n+                    \"format-number() : undeclared decimal format '%s'\\n\",\n+                    decimalObj->stringval);\n+        }\n+        \/* Intentional fall-through *\/\n@@ -650,5 +662,5 @@\n-    CAST_TO_STRING;\n-    formatObj = valuePop(ctxt);\n-    CAST_TO_NUMBER;\n-    numberObj = valuePop(ctxt);\n-    break;\n+        CAST_TO_STRING;\n+        formatObj = valuePop(ctxt);\n+        CAST_TO_NUMBER;\n+        numberObj = valuePop(ctxt);\n+        break;\n@@ -656,1 +668,1 @@\n-    XP_ERROR(XPATH_INVALID_ARITY);\n+        XP_ERROR(XPATH_INVALID_ARITY);\n@@ -660,7 +672,7 @@\n-    if (xsltFormatNumberConversion(formatValues,\n-                       formatObj->stringval,\n-                       numberObj->floatval,\n-                       &result) == XPATH_EXPRESSION_OK) {\n-        valuePush(ctxt, xmlXPathNewString(result));\n-        xmlFree(result);\n-    }\n+        if (xsltFormatNumberConversion(formatValues,\n+                                       formatObj->stringval,\n+                                       numberObj->floatval,\n+                                       &result) == XPATH_EXPRESSION_OK) {\n+            valuePush(ctxt, xmlXPathNewString(result));\n+            xmlFree(result);\n+        }\n@@ -691,1 +703,1 @@\n-    cur = ctxt->context->node;\n+        cur = ctxt->context->node;\n@@ -693,2 +705,2 @@\n-    xmlNodeSetPtr nodelist;\n-    int i, ret;\n+        xmlNodeSetPtr nodelist;\n+        int i, ret;\n@@ -696,2 +708,20 @@\n-    if ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) {\n-        ctxt->error = XPATH_INVALID_TYPE;\n+        if ((ctxt->value == NULL) || (ctxt->value->type != XPATH_NODESET)) {\n+            ctxt->error = XPATH_INVALID_TYPE;\n+            xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+                \"generate-id() : invalid arg expecting a node-set\\n\");\n+            return;\n+        }\n+        obj = valuePop(ctxt);\n+        nodelist = obj->nodesetval;\n+        if ((nodelist == NULL) || (nodelist->nodeNr <= 0)) {\n+            xmlXPathFreeObject(obj);\n+            valuePush(ctxt, xmlXPathNewCString(\"\"));\n+            return;\n+        }\n+        cur = nodelist->nodeTab[0];\n+        for (i = 1;i < nodelist->nodeNr;i++) {\n+            ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]);\n+            if (ret == -1)\n+                cur = nodelist->nodeTab[i];\n+        }\n+    } else {\n@@ -699,8 +729,2 @@\n-        \"generate-id() : invalid arg expecting a node-set\\n\");\n-        return;\n-    }\n-    obj = valuePop(ctxt);\n-    nodelist = obj->nodesetval;\n-    if ((nodelist == NULL) || (nodelist->nodeNr <= 0)) {\n-        xmlXPathFreeObject(obj);\n-        valuePush(ctxt, xmlXPathNewCString(\"\"));\n+                \"generate-id() : invalid number of args %d\\n\", nargs);\n+        ctxt->error = XPATH_INVALID_ARITY;\n@@ -709,12 +733,0 @@\n-    cur = nodelist->nodeTab[0];\n-    for (i = 1;i < nodelist->nodeNr;i++) {\n-        ret = xmlXPathCmpNodes(cur, nodelist->nodeTab[i]);\n-        if (ret == -1)\n-            cur = nodelist->nodeTab[i];\n-    }\n-    } else {\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"generate-id() : invalid number of args %d\\n\", nargs);\n-    ctxt->error = XPATH_INVALID_ARITY;\n-    return;\n-    }\n@@ -749,4 +761,4 @@\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"system-property() : expects one string arg\\n\");\n-    ctxt->error = XPATH_INVALID_ARITY;\n-    return;\n+        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+                \"system-property() : expects one string arg\\n\");\n+        ctxt->error = XPATH_INVALID_ARITY;\n+        return;\n@@ -755,4 +767,4 @@\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"system-property() : invalid arg expecting a string\\n\");\n-    ctxt->error = XPATH_INVALID_TYPE;\n-    return;\n+        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+            \"system-property() : invalid arg expecting a string\\n\");\n+        ctxt->error = XPATH_INVALID_TYPE;\n+        return;\n@@ -762,5 +774,1 @@\n-    valuePush(ctxt, xmlXPathNewString((const xmlChar *)\"\"));\n-    } else {\n-    name = xmlSplitQName2(obj->stringval, &prefix);\n-    if (name == NULL) {\n-        name = xmlStrdup(obj->stringval);\n+        valuePush(ctxt, xmlXPathNewString((const xmlChar *)\"\"));\n@@ -768,4 +776,9 @@\n-        nsURI = xmlXPathNsLookup(ctxt->context, prefix);\n-        if (nsURI == NULL) {\n-        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-            \"system-property() : prefix %s is not bound\\n\", prefix);\n+        name = xmlSplitQName2(obj->stringval, &prefix);\n+        if (name == NULL) {\n+            name = xmlStrdup(obj->stringval);\n+        } else {\n+            nsURI = xmlXPathNsLookup(ctxt->context, prefix);\n+            if (nsURI == NULL) {\n+                xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+                    \"system-property() : prefix %s is not bound\\n\", prefix);\n+            }\n@@ -773,1 +786,0 @@\n-    }\n@@ -775,1 +787,1 @@\n-    if (xmlStrEqual(nsURI, XSLT_NAMESPACE)) {\n+        if (xmlStrEqual(nsURI, XSLT_NAMESPACE)) {\n@@ -777,19 +789,19 @@\n-        if (xmlStrEqual(name, (const xmlChar *)\"vendor\")) {\n-        xsltStylesheetPtr sheet;\n-        xsltTransformContextPtr tctxt;\n-\n-        tctxt = xsltXPathGetTransformContext(ctxt);\n-        if ((tctxt != NULL) && (tctxt->inst != NULL) &&\n-            (xmlStrEqual(tctxt->inst->name, BAD_CAST \"variable\")) &&\n-            (tctxt->inst->parent != NULL) &&\n-            (xmlStrEqual(tctxt->inst->parent->name,\n-                 BAD_CAST \"template\")))\n-            sheet = tctxt->style;\n-        else\n-            sheet = NULL;\n-        if ((sheet != NULL) && (sheet->doc != NULL) &&\n-            (sheet->doc->URL != NULL) &&\n-            (xmlStrstr(sheet->doc->URL,\n-                   (const xmlChar *)\"chunk\") != NULL)) {\n-            valuePush(ctxt, xmlXPathNewString(\n-            (const xmlChar *)\"libxslt (SAXON 6.2 compatible)\"));\n+            if (xmlStrEqual(name, (const xmlChar *)\"vendor\")) {\n+                xsltStylesheetPtr sheet;\n+                xsltTransformContextPtr tctxt;\n+\n+                tctxt = xsltXPathGetTransformContext(ctxt);\n+                if ((tctxt != NULL) && (tctxt->inst != NULL) &&\n+                    (xmlStrEqual(tctxt->inst->name, BAD_CAST \"variable\")) &&\n+                    (tctxt->inst->parent != NULL) &&\n+                    (xmlStrEqual(tctxt->inst->parent->name,\n+                                 BAD_CAST \"template\")))\n+                    sheet = tctxt->style;\n+                else\n+                    sheet = NULL;\n+                if ((sheet != NULL) && (sheet->doc != NULL) &&\n+                    (sheet->doc->URL != NULL) &&\n+                    (xmlStrstr(sheet->doc->URL,\n+                               (const xmlChar *)\"chunk\") != NULL)) {\n+                    valuePush(ctxt, xmlXPathNewString(\n+                        (const xmlChar *)\"libxslt (SAXON 6.2 compatible)\"));\n@@ -797,5 +809,5 @@\n-        } else {\n-            valuePush(ctxt, xmlXPathNewString(\n-            (const xmlChar *)XSLT_DEFAULT_VENDOR));\n-        }\n-        } else\n+                } else {\n+                    valuePush(ctxt, xmlXPathNewString(\n+                        (const xmlChar *)XSLT_DEFAULT_VENDOR));\n+                }\n+            } else\n@@ -803,4 +815,4 @@\n-        if (xmlStrEqual(name, (const xmlChar *)\"vendor\")) {\n-        valuePush(ctxt, xmlXPathNewString(\n-              (const xmlChar *)XSLT_DEFAULT_VENDOR));\n-        } else\n+            if (xmlStrEqual(name, (const xmlChar *)\"vendor\")) {\n+                valuePush(ctxt, xmlXPathNewString(\n+                          (const xmlChar *)XSLT_DEFAULT_VENDOR));\n+            } else\n@@ -808,6 +820,9 @@\n-        if (xmlStrEqual(name, (const xmlChar *)\"version\")) {\n-        valuePush(ctxt, xmlXPathNewString(\n-            (const xmlChar *)XSLT_DEFAULT_VERSION));\n-        } else if (xmlStrEqual(name, (const xmlChar *)\"vendor-url\")) {\n-        valuePush(ctxt, xmlXPathNewString(\n-            (const xmlChar *)XSLT_DEFAULT_URL));\n+            if (xmlStrEqual(name, (const xmlChar *)\"version\")) {\n+                valuePush(ctxt, xmlXPathNewString(\n+                    (const xmlChar *)XSLT_DEFAULT_VERSION));\n+            } else if (xmlStrEqual(name, (const xmlChar *)\"vendor-url\")) {\n+                valuePush(ctxt, xmlXPathNewString(\n+                    (const xmlChar *)XSLT_DEFAULT_URL));\n+            } else {\n+                valuePush(ctxt, xmlXPathNewString((const xmlChar *)\"\"));\n+            }\n@@ -815,1 +830,1 @@\n-        valuePush(ctxt, xmlXPathNewString((const xmlChar *)\"\"));\n+            valuePush(ctxt, xmlXPathNewString((const xmlChar *)\"\"));\n@@ -817,7 +832,4 @@\n-    } else {\n-        valuePush(ctxt, xmlXPathNewString((const xmlChar *)\"\"));\n-        }\n-    if (name != NULL)\n-        xmlFree(name);\n-    if (prefix != NULL)\n-        xmlFree(prefix);\n+        if (name != NULL)\n+            xmlFree(name);\n+        if (prefix != NULL)\n+            xmlFree(prefix);\n@@ -844,4 +856,4 @@\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"element-available() : expects one string arg\\n\");\n-    ctxt->error = XPATH_INVALID_ARITY;\n-    return;\n+        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+                \"element-available() : expects one string arg\\n\");\n+        ctxt->error = XPATH_INVALID_ARITY;\n+        return;\n@@ -851,4 +863,4 @@\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"element-available() : invalid arg expecting a string\\n\");\n-    ctxt->error = XPATH_INVALID_TYPE;\n-    return;\n+        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+            \"element-available() : invalid arg expecting a string\\n\");\n+        ctxt->error = XPATH_INVALID_TYPE;\n+        return;\n@@ -859,5 +871,5 @@\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"element-available() : internal error tctxt == NULL\\n\");\n-    xmlXPathFreeObject(obj);\n-    valuePush(ctxt, xmlXPathNewBoolean(0));\n-    return;\n+        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+                \"element-available() : internal error tctxt == NULL\\n\");\n+        xmlXPathFreeObject(obj);\n+        valuePush(ctxt, xmlXPathNewBoolean(0));\n+        return;\n@@ -869,1 +881,1 @@\n-    xmlNsPtr ns;\n+        xmlNsPtr ns;\n@@ -871,3 +883,3 @@\n-    name = xmlStrdup(obj->stringval);\n-    ns = xmlSearchNs(tctxt->inst->doc, tctxt->inst, NULL);\n-    if (ns != NULL) nsURI = ns->href;\n+        name = xmlStrdup(obj->stringval);\n+        ns = xmlSearchNs(tctxt->inst->doc, tctxt->inst, NULL);\n+        if (ns != NULL) nsURI = ns->href;\n@@ -875,5 +887,5 @@\n-    nsURI = xmlXPathNsLookup(ctxt->context, prefix);\n-    if (nsURI == NULL) {\n-        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"element-available() : prefix %s is not bound\\n\", prefix);\n-    }\n+        nsURI = xmlXPathNsLookup(ctxt->context, prefix);\n+        if (nsURI == NULL) {\n+            xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+                \"element-available() : prefix %s is not bound\\n\", prefix);\n+        }\n@@ -883,1 +895,1 @@\n-    valuePush(ctxt, xmlXPathNewBoolean(1));\n+        valuePush(ctxt, xmlXPathNewBoolean(1));\n@@ -885,1 +897,1 @@\n-    valuePush(ctxt, xmlXPathNewBoolean(0));\n+        valuePush(ctxt, xmlXPathNewBoolean(0));\n@@ -890,1 +902,1 @@\n-    xmlFree(name);\n+        xmlFree(name);\n@@ -892,1 +904,1 @@\n-    xmlFree(prefix);\n+        xmlFree(prefix);\n@@ -910,4 +922,4 @@\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"function-available() : expects one string arg\\n\");\n-    ctxt->error = XPATH_INVALID_ARITY;\n-    return;\n+        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+                \"function-available() : expects one string arg\\n\");\n+        ctxt->error = XPATH_INVALID_ARITY;\n+        return;\n@@ -917,4 +929,4 @@\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"function-available() : invalid arg expecting a string\\n\");\n-    ctxt->error = XPATH_INVALID_TYPE;\n-    return;\n+        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+            \"function-available() : invalid arg expecting a string\\n\");\n+        ctxt->error = XPATH_INVALID_TYPE;\n+        return;\n@@ -926,1 +938,1 @@\n-    name = xmlStrdup(obj->stringval);\n+        name = xmlStrdup(obj->stringval);\n@@ -928,5 +940,5 @@\n-    nsURI = xmlXPathNsLookup(ctxt->context, prefix);\n-    if (nsURI == NULL) {\n-        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"function-available() : prefix %s is not bound\\n\", prefix);\n-    }\n+        nsURI = xmlXPathNsLookup(ctxt->context, prefix);\n+        if (nsURI == NULL) {\n+            xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+                \"function-available() : prefix %s is not bound\\n\", prefix);\n+        }\n@@ -936,1 +948,1 @@\n-    valuePush(ctxt, xmlXPathNewBoolean(1));\n+        valuePush(ctxt, xmlXPathNewBoolean(1));\n@@ -938,1 +950,1 @@\n-    valuePush(ctxt, xmlXPathNewBoolean(0));\n+        valuePush(ctxt, xmlXPathNewBoolean(0));\n@@ -943,1 +955,1 @@\n-    xmlFree(name);\n+        xmlFree(name);\n@@ -945,1 +957,1 @@\n-    xmlFree(prefix);\n+        xmlFree(prefix);\n@@ -961,4 +973,4 @@\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"current() : function uses no argument\\n\");\n-    ctxt->error = XPATH_INVALID_ARITY;\n-    return;\n+        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+                \"current() : function uses no argument\\n\");\n+        ctxt->error = XPATH_INVALID_ARITY;\n+        return;\n@@ -968,3 +980,3 @@\n-    xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n-        \"current() : internal error tctxt == NULL\\n\");\n-    valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n+        xsltTransformError(xsltXPathGetTransformContext(ctxt), NULL, NULL,\n+                \"current() : internal error tctxt == NULL\\n\");\n+        valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n@@ -972,1 +984,1 @@\n-    valuePush(ctxt, xmlXPathNewNodeSet(tctxt->node)); \/* current *\/\n+        valuePush(ctxt, xmlXPathNewNodeSet(tctxt->node)); \/* current *\/\n@@ -977,3 +989,3 @@\n- *                                  *\n- *      Registration of XSLT and libxslt functions      *\n- *                                  *\n+ *                                                                      *\n+ *              Registration of XSLT and libxslt functions              *\n+ *                                                                      *\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/functions.c","additions":392,"deletions":380,"binary":false,"changes":772,"status":"modified"},{"patch":"@@ -27,4 +27,4 @@\n-#define XSLT_REGISTER_FUNCTION_LOOKUP(ctxt)         \\\n-    xmlXPathRegisterFuncLookup((ctxt)->xpathCtxt,       \\\n-    xsltXPathFunctionLookup,                \\\n-    (void *)(ctxt->xpathCtxt));\n+#define XSLT_REGISTER_FUNCTION_LOOKUP(ctxt)                     \\\n+    xmlXPathRegisterFuncLookup((ctxt)->xpathCtxt,               \\\n+        xsltXPathFunctionLookup,                                \\\n+        (void *)(ctxt->xpathCtxt));\n@@ -33,3 +33,3 @@\n-    xsltXPathFunctionLookup     (void *vctxt,\n-                     const xmlChar *name,\n-                     const xmlChar *ns_uri);\n+        xsltXPathFunctionLookup         (void *vctxt,\n+                                         const xmlChar *name,\n+                                         const xmlChar *ns_uri);\n@@ -42,2 +42,2 @@\n-    xsltDocumentFunction        (xmlXPathParserContextPtr ctxt,\n-                     int nargs);\n+        xsltDocumentFunction            (xmlXPathParserContextPtr ctxt,\n+                                         int nargs);\n@@ -45,2 +45,2 @@\n-    xsltKeyFunction         (xmlXPathParserContextPtr ctxt,\n-                     int nargs);\n+        xsltKeyFunction                 (xmlXPathParserContextPtr ctxt,\n+                                         int nargs);\n@@ -48,2 +48,2 @@\n-    xsltUnparsedEntityURIFunction   (xmlXPathParserContextPtr ctxt,\n-                     int nargs);\n+        xsltUnparsedEntityURIFunction   (xmlXPathParserContextPtr ctxt,\n+                                         int nargs);\n@@ -51,2 +51,2 @@\n-    xsltFormatNumberFunction    (xmlXPathParserContextPtr ctxt,\n-                     int nargs);\n+        xsltFormatNumberFunction        (xmlXPathParserContextPtr ctxt,\n+                                         int nargs);\n@@ -54,2 +54,2 @@\n-    xsltGenerateIdFunction      (xmlXPathParserContextPtr ctxt,\n-                     int nargs);\n+        xsltGenerateIdFunction          (xmlXPathParserContextPtr ctxt,\n+                                         int nargs);\n@@ -57,2 +57,2 @@\n-    xsltSystemPropertyFunction  (xmlXPathParserContextPtr ctxt,\n-                     int nargs);\n+        xsltSystemPropertyFunction      (xmlXPathParserContextPtr ctxt,\n+                                         int nargs);\n@@ -60,2 +60,2 @@\n-    xsltElementAvailableFunction    (xmlXPathParserContextPtr ctxt,\n-                     int nargs);\n+        xsltElementAvailableFunction    (xmlXPathParserContextPtr ctxt,\n+                                         int nargs);\n@@ -63,2 +63,2 @@\n-    xsltFunctionAvailableFunction   (xmlXPathParserContextPtr ctxt,\n-                     int nargs);\n+        xsltFunctionAvailableFunction   (xmlXPathParserContextPtr ctxt,\n+                                         int nargs);\n@@ -71,1 +71,1 @@\n-    xsltRegisterAllFunctions    (xmlXPathContextPtr ctxt);\n+        xsltRegisterAllFunctions        (xmlXPathContextPtr ctxt);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/functions.h","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -52,3 +52,3 @@\n- *                                  *\n- *          Module interfaces               *\n- *                                  *\n+ *                                                                      *\n+ *                      Module interfaces                               *\n+ *                                                                      *\n@@ -66,1 +66,1 @@\n-            xsltStylesheetPtr style) {\n+                        xsltStylesheetPtr style) {\n@@ -96,1 +96,1 @@\n-    return (ret);\n+        return (ret);\n@@ -100,3 +100,3 @@\n-    xsltTransformError(NULL, style, cur,\n-        \"xsl:import : missing href attribute\\n\");\n-    goto error;\n+        xsltTransformError(NULL, style, cur,\n+            \"xsl:import : missing href attribute\\n\");\n+        goto error;\n@@ -108,3 +108,3 @@\n-    xsltTransformError(NULL, style, cur,\n-        \"xsl:import : invalid URI reference %s\\n\", uriRef);\n-    goto error;\n+        xsltTransformError(NULL, style, cur,\n+            \"xsl:import : invalid URI reference %s\\n\", uriRef);\n+        goto error;\n@@ -116,7 +116,7 @@\n-        break;\n-    if (xmlStrEqual(res->doc->URL, URI)) {\n-        xsltTransformError(NULL, style, cur,\n-           \"xsl:import : recursion detected on imported URL %s\\n\", URI);\n-        goto error;\n-    }\n-    res = res->parent;\n+            break;\n+        if (xmlStrEqual(res->doc->URL, URI)) {\n+            xsltTransformError(NULL, style, cur,\n+               \"xsl:import : recursion detected on imported URL %s\\n\", URI);\n+            goto error;\n+        }\n+        res = res->parent;\n@@ -130,1 +130,1 @@\n-    int secres;\n+        int secres;\n@@ -132,2 +132,2 @@\n-    secres = xsltCheckRead(sec, NULL, URI);\n-    if (secres <= 0) {\n+        secres = xsltCheckRead(sec, NULL, URI);\n+        if (secres <= 0) {\n@@ -138,2 +138,2 @@\n-        goto error;\n-    }\n+            goto error;\n+        }\n@@ -145,3 +145,3 @@\n-    xsltTransformError(NULL, style, cur,\n-        \"xsl:import : unable to load %s\\n\", URI);\n-    goto error;\n+        xsltTransformError(NULL, style, cur,\n+            \"xsl:import : unable to load %s\\n\", URI);\n+        goto error;\n@@ -152,6 +152,6 @@\n-    res->next = style->imports;\n-    style->imports = res;\n-    if (style->parent == NULL) {\n-        xsltFixImportedCompSteps(style, res);\n-    }\n-    ret = 0;\n+        res->next = style->imports;\n+        style->imports = res;\n+        if (style->parent == NULL) {\n+            xsltFixImportedCompSteps(style, res);\n+        }\n+        ret = 0;\n@@ -159,2 +159,2 @@\n-    xmlFreeDoc(import);\n-    }\n+        xmlFreeDoc(import);\n+        }\n@@ -164,1 +164,1 @@\n-    xmlFree(uriRef);\n+        xmlFree(uriRef);\n@@ -166,1 +166,1 @@\n-    xmlFree(base);\n+        xmlFree(base);\n@@ -168,1 +168,1 @@\n-    xmlFree(URI);\n+        xmlFree(URI);\n@@ -196,1 +196,1 @@\n-    return (ret);\n+        return (ret);\n@@ -200,3 +200,3 @@\n-    xsltTransformError(NULL, style, cur,\n-        \"xsl:include : missing href attribute\\n\");\n-    goto error;\n+        xsltTransformError(NULL, style, cur,\n+            \"xsl:include : missing href attribute\\n\");\n+        goto error;\n@@ -208,3 +208,3 @@\n-    xsltTransformError(NULL, style, cur,\n-        \"xsl:include : invalid URI reference %s\\n\", uriRef);\n-    goto error;\n+        xsltTransformError(NULL, style, cur,\n+            \"xsl:include : invalid URI reference %s\\n\", uriRef);\n+        goto error;\n@@ -220,5 +220,5 @@\n-        xsltTransformError(NULL, style, cur,\n-            \"xsl:include : recursion detected on included URL %s\\n\", URI);\n-        goto error;\n-    }\n-    docptr = docptr->includes;\n+            xsltTransformError(NULL, style, cur,\n+                \"xsl:include : recursion detected on included URL %s\\n\", URI);\n+            goto error;\n+        }\n+        docptr = docptr->includes;\n@@ -229,3 +229,3 @@\n-    xsltTransformError(NULL, style, cur,\n-        \"xsl:include : unable to load %s\\n\", URI);\n-    goto error;\n+        xsltTransformError(NULL, style, cur,\n+            \"xsl:include : unable to load %s\\n\", URI);\n+        goto error;\n@@ -235,1 +235,1 @@\n-    ((xsltStyleItemIncludePtr) cur->psvi)->include = include;\n+        ((xsltStyleItemIncludePtr) cur->psvi)->include = include;\n@@ -237,4 +237,4 @@\n-    xsltTransformError(NULL, style, cur,\n-        \"Internal error: (xsltParseStylesheetInclude) \"\n-        \"The xsl:include element was not compiled.\\n\", URI);\n-    style->errors++;\n+        xsltTransformError(NULL, style, cur,\n+            \"Internal error: (xsltParseStylesheetInclude) \"\n+            \"The xsl:include element was not compiled.\\n\", URI);\n+        style->errors++;\n@@ -262,2 +262,2 @@\n-    ret = -1;\n-    goto error;\n+        ret = -1;\n+        goto error;\n@@ -269,1 +269,1 @@\n-    xmlFree(uriRef);\n+        xmlFree(uriRef);\n@@ -271,1 +271,1 @@\n-    xmlFree(base);\n+        xmlFree(base);\n@@ -273,1 +273,1 @@\n-    xmlFree(URI);\n+        xmlFree(URI);\n@@ -290,1 +290,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -292,1 +292,1 @@\n-    return(cur->imports);\n+        return(cur->imports);\n@@ -294,1 +294,1 @@\n-    return(cur->next) ;\n+        return(cur->next) ;\n@@ -296,3 +296,3 @@\n-    cur = cur->parent;\n-    if (cur == NULL) break;\n-    if (cur->next != NULL) return(cur->next);\n+        cur = cur->parent;\n+        if (cur == NULL) break;\n+        if (cur->next != NULL) return(cur->next);\n@@ -317,1 +317,1 @@\n-    return(0);\n+        return(0);\n@@ -320,3 +320,3 @@\n-    if (style->stripSpaces != NULL)\n-        return(1);\n-    style = xsltNextImport(style);\n+        if (style->stripSpaces != NULL)\n+            return(1);\n+        style = xsltNextImport(style);\n@@ -345,1 +345,1 @@\n-    return(0);\n+        return(0);\n@@ -348,3 +348,3 @@\n-    if (node->ns != NULL) {\n-        val = (const xmlChar *)\n-          xmlHashLookup2(style->stripSpaces, node->name, node->ns->href);\n+        if (node->ns != NULL) {\n+            val = (const xmlChar *)\n+              xmlHashLookup2(style->stripSpaces, node->name, node->ns->href);\n@@ -356,14 +356,14 @@\n-    } else {\n-        val = (const xmlChar *)\n-          xmlHashLookup2(style->stripSpaces, node->name, NULL);\n-    }\n-    if (val != NULL) {\n-        if (xmlStrEqual(val, (xmlChar *) \"strip\"))\n-        return(1);\n-        if (xmlStrEqual(val, (xmlChar *) \"preserve\"))\n-        return(0);\n-    }\n-    if (style->stripAll == 1)\n-        return(1);\n-    if (style->stripAll == -1)\n-        return(0);\n+        } else {\n+            val = (const xmlChar *)\n+                  xmlHashLookup2(style->stripSpaces, node->name, NULL);\n+        }\n+        if (val != NULL) {\n+            if (xmlStrEqual(val, (xmlChar *) \"strip\"))\n+                return(1);\n+            if (xmlStrEqual(val, (xmlChar *) \"preserve\"))\n+                return(0);\n+        }\n+        if (style->stripAll == 1)\n+            return(1);\n+        if (style->stripAll == -1)\n+            return(0);\n@@ -371,1 +371,1 @@\n-    style = xsltNextImport(style);\n+        style = xsltNextImport(style);\n@@ -395,1 +395,1 @@\n-             const xmlChar *nameURI) {\n+                 const xmlChar *nameURI) {\n@@ -400,1 +400,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -410,1 +410,1 @@\n-    style = xsltNextImport(style);\n+        style = xsltNextImport(style);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/imports.c","additions":94,"deletions":94,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -27,6 +27,6 @@\n-#define XSLT_GET_IMPORT_PTR(res, style, name) {         \\\n-    xsltStylesheetPtr st = style;               \\\n-    res = NULL;                         \\\n-    while (st != NULL) {                    \\\n-    if (st->name != NULL) { res = st->name; break; }    \\\n-    st = xsltNextImport(st);                \\\n+#define XSLT_GET_IMPORT_PTR(res, style, name) {                 \\\n+    xsltStylesheetPtr st = style;                               \\\n+    res = NULL;                                                 \\\n+    while (st != NULL) {                                        \\\n+        if (st->name != NULL) { res = st->name; break; }        \\\n+        st = xsltNextImport(st);                                \\\n@@ -40,6 +40,6 @@\n-#define XSLT_GET_IMPORT_INT(res, style, name) {         \\\n-    xsltStylesheetPtr st = style;               \\\n-    res = -1;                           \\\n-    while (st != NULL) {                    \\\n-    if (st->name != -1) { res = st->name; break; }  \\\n-    st = xsltNextImport(st);                \\\n+#define XSLT_GET_IMPORT_INT(res, style, name) {                 \\\n+    xsltStylesheetPtr st = style;                               \\\n+    res = -1;                                                   \\\n+    while (st != NULL) {                                        \\\n+        if (st->name != -1) { res = st->name; break; }  \\\n+        st = xsltNextImport(st);                                \\\n@@ -52,2 +52,2 @@\n-            xsltParseStylesheetImport(xsltStylesheetPtr style,\n-                          xmlNodePtr cur);\n+                        xsltParseStylesheetImport(xsltStylesheetPtr style,\n+                                                  xmlNodePtr cur);\n@@ -55,3 +55,3 @@\n-            xsltParseStylesheetInclude\n-                         (xsltStylesheetPtr style,\n-                          xmlNodePtr cur);\n+                        xsltParseStylesheetInclude\n+                                                 (xsltStylesheetPtr style,\n+                                                  xmlNodePtr cur);\n@@ -59,1 +59,1 @@\n-            xsltNextImport       (xsltStylesheetPtr style);\n+                        xsltNextImport           (xsltStylesheetPtr style);\n@@ -61,1 +61,1 @@\n-            xsltNeedElemSpaceHandling(xsltTransformContextPtr ctxt);\n+                        xsltNeedElemSpaceHandling(xsltTransformContextPtr ctxt);\n@@ -63,2 +63,2 @@\n-            xsltFindElemSpaceHandling(xsltTransformContextPtr ctxt,\n-                          xmlNodePtr node);\n+                        xsltFindElemSpaceHandling(xsltTransformContextPtr ctxt,\n+                                                  xmlNodePtr node);\n@@ -66,3 +66,3 @@\n-            xsltFindTemplate     (xsltTransformContextPtr ctxt,\n-                          const xmlChar *name,\n-                          const xmlChar *nameURI);\n+                        xsltFindTemplate         (xsltTransformContextPtr ctxt,\n+                                                  const xmlChar *name,\n+                                                  const xmlChar *nameURI);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/imports.h","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -41,3 +41,3 @@\n- *                                  *\n- *          Type functions                  *\n- *                                  *\n+ *                                                                      *\n+ *                      Type functions                                  *\n+ *                                                                      *\n@@ -61,3 +61,3 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltNewKeyDef : malloc failed\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, NULL,\n+                \"xsltNewKeyDef : malloc failed\\n\");\n+        return(NULL);\n@@ -67,1 +67,1 @@\n-    cur->name = xmlStrdup(name);\n+        cur->name = xmlStrdup(name);\n@@ -69,1 +69,1 @@\n-    cur->nameURI = xmlStrdup(nameURI);\n+        cur->nameURI = xmlStrdup(nameURI);\n@@ -83,1 +83,1 @@\n-    return;\n+        return;\n@@ -85,1 +85,1 @@\n-    xmlXPathFreeCompExpr(keyd->comp);\n+        xmlXPathFreeCompExpr(keyd->comp);\n@@ -87,1 +87,1 @@\n-    xmlXPathFreeCompExpr(keyd->usecomp);\n+        xmlXPathFreeCompExpr(keyd->usecomp);\n@@ -89,1 +89,1 @@\n-    xmlFree(keyd->name);\n+        xmlFree(keyd->name);\n@@ -91,1 +91,1 @@\n-    xmlFree(keyd->nameURI);\n+        xmlFree(keyd->nameURI);\n@@ -93,1 +93,1 @@\n-    xmlFree(keyd->match);\n+        xmlFree(keyd->match);\n@@ -95,1 +95,1 @@\n-    xmlFree(keyd->use);\n+        xmlFree(keyd->use);\n@@ -113,3 +113,3 @@\n-    cur = keyd;\n-    keyd = keyd->next;\n-    xsltFreeKeyDef(cur);\n+        cur = keyd;\n+        keyd = keyd->next;\n+        xsltFreeKeyDef(cur);\n@@ -134,3 +134,3 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltNewKeyTable : malloc failed\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, NULL,\n+                \"xsltNewKeyTable : malloc failed\\n\");\n+        return(NULL);\n@@ -140,1 +140,1 @@\n-    cur->name = xmlStrdup(name);\n+        cur->name = xmlStrdup(name);\n@@ -142,1 +142,1 @@\n-    cur->nameURI = xmlStrdup(nameURI);\n+        cur->nameURI = xmlStrdup(nameURI);\n@@ -161,1 +161,1 @@\n-    return;\n+        return;\n@@ -163,1 +163,1 @@\n-    xmlFree(keyt->name);\n+        xmlFree(keyt->name);\n@@ -165,1 +165,1 @@\n-    xmlFree(keyt->nameURI);\n+        xmlFree(keyt->nameURI);\n@@ -167,1 +167,1 @@\n-    xmlHashFree(keyt->keys, xsltFreeNodeSetEntry);\n+        xmlHashFree(keyt->keys, xsltFreeNodeSetEntry);\n@@ -183,3 +183,3 @@\n-    cur = keyt;\n-    keyt = keyt->next;\n-    xsltFreeKeyTable(cur);\n+        cur = keyt;\n+        keyt = keyt->next;\n+        xsltFreeKeyTable(cur);\n@@ -190,3 +190,3 @@\n- *                                  *\n- *      The interpreter for the precompiled patterns        *\n- *                                  *\n+ *                                                                      *\n+ *              The interpreter for the precompiled patterns            *\n+ *                                                                      *\n@@ -205,1 +205,1 @@\n-    xsltFreeKeyDefList((xsltKeyDefPtr) style->keys);\n+        xsltFreeKeyDefList((xsltKeyDefPtr) style->keys);\n@@ -227,2 +227,2 @@\n-        return(end + 1);\n-    end++;\n+            return(end + 1);\n+        end++;\n@@ -251,5 +251,5 @@\n-        end = skipString(cur, end);\n-        if (end <= 0)\n-            return(-1);\n-        continue;\n-    } else if (cur[end] == '[') {\n+            end = skipString(cur, end);\n+            if (end <= 0)\n+                return(-1);\n+            continue;\n+        } else if (cur[end] == '[') {\n@@ -257,1 +257,1 @@\n-    } else if (cur[end] == ']') {\n+        } else if (cur[end] == ']') {\n@@ -259,1 +259,1 @@\n-            return(end + 1);\n+                return(end + 1);\n@@ -262,1 +262,1 @@\n-    end++;\n+        end++;\n@@ -282,2 +282,2 @@\n-       const xmlChar *nameURI, const xmlChar *match,\n-       const xmlChar *use, xmlNodePtr inst) {\n+           const xmlChar *nameURI, const xmlChar *match,\n+           const xmlChar *use, xmlNodePtr inst) {\n@@ -289,1 +289,1 @@\n-    return(-1);\n+        return(-1);\n@@ -293,1 +293,1 @@\n-    \"Add key %s, match %s, use %s\\n\", name, match, use);\n+        \"Add key %s, match %s, use %s\\n\", name, match, use);\n@@ -303,1 +303,1 @@\n-        i++;\n+            i++;\n@@ -312,8 +312,18 @@\n-    start = current;\n-    while (IS_BLANK_CH(match[current]))\n-        current++;\n-    end = current;\n-    while ((match[end] != 0) && (match[end] != '|')) {\n-        if (match[end] == '[') {\n-            end = skipPredicate(match, end);\n-        if (end <= 0) {\n+        start = current;\n+        while (IS_BLANK_CH(match[current]))\n+            current++;\n+        end = current;\n+        while ((match[end] != 0) && (match[end] != '|')) {\n+            if (match[end] == '[') {\n+                end = skipPredicate(match, end);\n+                if (end <= 0) {\n+                    xsltTransformError(NULL, style, inst,\n+                        \"xsl:key : 'match' pattern is malformed: %s\",\n+                        key->match);\n+                    if (style != NULL) style->errors++;\n+                    goto error;\n+                }\n+            } else\n+                end++;\n+        }\n+        if (current == end) {\n@@ -321,2 +331,1 @@\n-                \"xsl:key : 'match' pattern is malformed: %s\",\n-                key->match);\n+                               \"xsl:key : 'match' pattern is empty\\n\");\n@@ -326,11 +335,8 @@\n-        } else\n-        end++;\n-    }\n-    if (current == end) {\n-        xsltTransformError(NULL, style, inst,\n-                   \"xsl:key : 'match' pattern is empty\\n\");\n-        if (style != NULL) style->errors++;\n-        goto error;\n-    }\n-    if (match[start] != '\/') {\n-        pattern = xmlStrcat(pattern, (xmlChar *)\"\/\/\");\n+        if (match[start] != '\/') {\n+            pattern = xmlStrcat(pattern, (xmlChar *)\"\/\/\");\n+            if (pattern == NULL) {\n+                if (style != NULL) style->errors++;\n+                goto error;\n+            }\n+        }\n+        pattern = xmlStrncat(pattern, &match[start], end - start);\n@@ -338,2 +344,2 @@\n-        if (style != NULL) style->errors++;\n-        goto error;\n+            if (style != NULL) style->errors++;\n+            goto error;\n@@ -341,6 +347,0 @@\n-    }\n-    pattern = xmlStrncat(pattern, &match[start], end - start);\n-    if (pattern == NULL) {\n-        if (style != NULL) style->errors++;\n-        goto error;\n-    }\n@@ -348,5 +348,5 @@\n-    if (match[end] == '|') {\n-        pattern = xmlStrcat(pattern, (xmlChar *)\"|\");\n-        end++;\n-    }\n-    current = end;\n+        if (match[end] == '|') {\n+            pattern = xmlStrcat(pattern, (xmlChar *)\"|\");\n+            end++;\n+        }\n+        current = end;\n@@ -362,1 +362,1 @@\n-    \"   resulting pattern %s\\n\", pattern);\n+        \"   resulting pattern %s\\n\", pattern);\n@@ -378,4 +378,4 @@\n-    xsltTransformError(NULL, style, inst,\n-        \"xsl:key : 'match' pattern compilation failed '%s'\\n\",\n-                 pattern);\n-    if (style != NULL) style->errors++;\n+        xsltTransformError(NULL, style, inst,\n+                \"xsl:key : 'match' pattern compilation failed '%s'\\n\",\n+                         pattern);\n+        if (style != NULL) style->errors++;\n@@ -389,4 +389,4 @@\n-    xsltTransformError(NULL, style, inst,\n-        \"xsl:key : 'use' expression compilation failed '%s'\\n\",\n-                 use);\n-    if (style != NULL) style->errors++;\n+        xsltTransformError(NULL, style, inst,\n+                \"xsl:key : 'use' expression compilation failed '%s'\\n\",\n+                         use);\n+        if (style != NULL) style->errors++;\n@@ -401,1 +401,1 @@\n-    style->keys = key;\n+        style->keys = key;\n@@ -405,2 +405,2 @@\n-    while (prev->next != NULL)\n-        prev = prev->next;\n+        while (prev->next != NULL)\n+            prev = prev->next;\n@@ -408,1 +408,1 @@\n-    prev->next = key;\n+        prev->next = key;\n@@ -415,1 +415,1 @@\n-    xmlFree(pattern);\n+        xmlFree(pattern);\n@@ -436,1 +436,1 @@\n-       const xmlChar *nameURI, const xmlChar *value) {\n+           const xmlChar *nameURI, const xmlChar *value) {\n@@ -442,2 +442,2 @@\n-    (ctxt->document == NULL))\n-    return(NULL);\n+        (ctxt->document == NULL))\n+        return(NULL);\n@@ -447,1 +447,1 @@\n-    \"Get key %s, value %s\\n\", name, value);\n+        \"Get key %s, value %s\\n\", name, value);\n@@ -456,4 +456,4 @@\n-     * If non-recursive behaviour, just try to initialize all keys\n-     *\/\n-    if (xsltInitAllDocKeys(ctxt))\n-        return(NULL);\n+         * If non-recursive behaviour, just try to initialize all keys\n+         *\/\n+        if (xsltInitAllDocKeys(ctxt))\n+            return(NULL);\n@@ -465,8 +465,8 @@\n-    if (((nameURI != NULL) == (table->nameURI != NULL)) &&\n-        xmlStrEqual(table->name, name) &&\n-        xmlStrEqual(table->nameURI, nameURI))\n-    {\n-        ret = (xmlNodeSetPtr)xmlHashLookup(table->keys, value);\n-        return(ret);\n-    }\n-    table = table->next;\n+        if (((nameURI != NULL) == (table->nameURI != NULL)) &&\n+            xmlStrEqual(table->name, name) &&\n+            xmlStrEqual(table->nameURI, nameURI))\n+        {\n+            ret = (xmlNodeSetPtr)xmlHashLookup(table->keys, value);\n+            return(ret);\n+        }\n+        table = table->next;\n@@ -477,3 +477,3 @@\n-     * Apparently one key is recursive and this one is needed,\n-     * initialize just it, that time and retry\n-     *\/\n+         * Apparently one key is recursive and this one is needed,\n+         * initialize just it, that time and retry\n+         *\/\n@@ -481,2 +481,2 @@\n-    init_table = 1;\n-    goto retry;\n+        init_table = 1;\n+        goto retry;\n@@ -510,11 +510,13 @@\n-    keyd = (xsltKeyDefPtr) style->keys;\n-    while (keyd != NULL) {\n-        if (((keyd->nameURI != NULL) ==\n-         (nameURI != NULL)) &&\n-        xmlStrEqual(keyd->name, name) &&\n-        xmlStrEqual(keyd->nameURI, nameURI))\n-        {\n-        xsltInitCtxtKey(ctxt, ctxt->document, keyd);\n-        if (ctxt->document->nbKeysComputed == ctxt->nbKeys)\n-            return(0);\n-        found = 1;\n+        keyd = (xsltKeyDefPtr) style->keys;\n+        while (keyd != NULL) {\n+            if (((keyd->nameURI != NULL) ==\n+                 (nameURI != NULL)) &&\n+                xmlStrEqual(keyd->name, name) &&\n+                xmlStrEqual(keyd->nameURI, nameURI))\n+            {\n+                xsltInitCtxtKey(ctxt, ctxt->document, keyd);\n+                if (ctxt->document->nbKeysComputed == ctxt->nbKeys)\n+                    return(0);\n+                found = 1;\n+            }\n+            keyd = keyd->next;\n@@ -522,3 +524,1 @@\n-        keyd = keyd->next;\n-    }\n-    style = xsltNextImport(style);\n+        style = xsltNextImport(style);\n@@ -528,2 +528,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltInitDocKeyTable: did not found %s\\n\", name));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltInitDocKeyTable: did not found %s\\n\", name));\n@@ -531,3 +531,3 @@\n-    xsltTransformError(ctxt, NULL, keyd? keyd->inst : NULL,\n-        \"Failed to find key definition for %s\\n\", name);\n-    ctxt->state = XSLT_STATE_STOPPED;\n+        xsltTransformError(ctxt, NULL, keyd? keyd->inst : NULL,\n+            \"Failed to find key definition for %s\\n\", name);\n+        ctxt->state = XSLT_STATE_STOPPED;\n@@ -560,1 +560,1 @@\n-    return(-1);\n+        return(-1);\n@@ -568,1 +568,1 @@\n-    return(0);\n+        return(0);\n@@ -576,2 +576,2 @@\n-    keyd = (xsltKeyDefPtr) style->keys;\n-    while (keyd != NULL) {\n+        keyd = (xsltKeyDefPtr) style->keys;\n+        while (keyd != NULL) {\n@@ -581,11 +581,21 @@\n-        \/*\n-        * Check if keys with this QName have been already\n-        * computed.\n-        *\/\n-        table = (xsltKeyTablePtr) ctxt->document->keys;\n-        while (table) {\n-        if (((keyd->nameURI != NULL) == (table->nameURI != NULL)) &&\n-            xmlStrEqual(keyd->name, table->name) &&\n-            xmlStrEqual(keyd->nameURI, table->nameURI))\n-        {\n-            break;\n+            \/*\n+            * Check if keys with this QName have been already\n+            * computed.\n+            *\/\n+            table = (xsltKeyTablePtr) ctxt->document->keys;\n+            while (table) {\n+                if (((keyd->nameURI != NULL) == (table->nameURI != NULL)) &&\n+                    xmlStrEqual(keyd->name, table->name) &&\n+                    xmlStrEqual(keyd->nameURI, table->nameURI))\n+                {\n+                    break;\n+                }\n+                table = table->next;\n+            }\n+            if (table == NULL) {\n+                \/*\n+                * Keys with this QName have not been yet computed.\n+                *\/\n+                xsltInitDocKeyTable(ctxt, keyd->name, keyd->nameURI);\n+            }\n+            keyd = keyd->next;\n@@ -593,11 +603,1 @@\n-        table = table->next;\n-        }\n-        if (table == NULL) {\n-        \/*\n-        * Keys with this QName have not been yet computed.\n-        *\/\n-        xsltInitDocKeyTable(ctxt, keyd->name, keyd->nameURI);\n-        }\n-        keyd = keyd->next;\n-    }\n-    style = xsltNextImport(style);\n+        style = xsltNextImport(style);\n@@ -623,1 +623,1 @@\n-            xsltKeyDefPtr keyDef)\n+                xsltKeyDefPtr keyDef)\n@@ -645,1 +645,1 @@\n-    return(-1);\n+        return(-1);\n@@ -652,4 +652,4 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,\n-               xsltGenericDebug(xsltGenericDebugContext,\n-               \"xsltInitCtxtKey: key definition of %s is recursive\\n\",\n-               keyDef->name));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,\n+                   xsltGenericDebug(xsltGenericDebugContext,\n+                       \"xsltInitCtxtKey: key definition of %s is recursive\\n\",\n+                       keyDef->name));\n@@ -657,3 +657,3 @@\n-    xsltTransformError(ctxt, NULL, keyDef->inst,\n-        \"Key definition for %s is recursive\\n\", keyDef->name);\n-    ctxt->state = XSLT_STATE_STOPPED;\n+        xsltTransformError(ctxt, NULL, keyDef->inst,\n+            \"Key definition for %s is recursive\\n\", keyDef->name);\n+        ctxt->state = XSLT_STATE_STOPPED;\n@@ -701,2 +701,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltInitCtxtKey: %s evaluation failed\\n\", keyDef->match));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltInitCtxtKey: %s evaluation failed\\n\", keyDef->match));\n@@ -704,4 +704,4 @@\n-    xsltTransformError(ctxt, NULL, keyDef->inst,\n-        \"Failed to evaluate the 'match' expression.\\n\");\n-    ctxt->state = XSLT_STATE_STOPPED;\n-    goto error;\n+        xsltTransformError(ctxt, NULL, keyDef->inst,\n+            \"Failed to evaluate the 'match' expression.\\n\");\n+        ctxt->state = XSLT_STATE_STOPPED;\n+        goto error;\n@@ -709,2 +709,2 @@\n-    if (matchRes->type == XPATH_NODESET) {\n-        matchList = matchRes->nodesetval;\n+        if (matchRes->type == XPATH_NODESET) {\n+            matchList = matchRes->nodesetval;\n@@ -713,4 +713,4 @@\n-        if (matchList != NULL)\n-        XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltInitCtxtKey: %s evaluates to %d nodes\\n\",\n-                 keyDef->match, matchList->nodeNr));\n+            if (matchList != NULL)\n+                XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext,\n+                     \"xsltInitCtxtKey: %s evaluates to %d nodes\\n\",\n+                                 keyDef->match, matchList->nodeNr));\n@@ -718,4 +718,4 @@\n-    } else {\n-        \/*\n-        * Is not a node set, but must be.\n-        *\/\n+        } else {\n+            \/*\n+            * Is not a node set, but must be.\n+            *\/\n@@ -723,2 +723,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltInitCtxtKey: %s is not a node set\\n\", keyDef->match));\n+            XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext,\n+                 \"xsltInitCtxtKey: %s is not a node set\\n\", keyDef->match));\n@@ -726,5 +726,5 @@\n-        xsltTransformError(ctxt, NULL, keyDef->inst,\n-        \"The 'match' expression did not evaluate to a node set.\\n\");\n-        ctxt->state = XSLT_STATE_STOPPED;\n-        goto error;\n-    }\n+            xsltTransformError(ctxt, NULL, keyDef->inst,\n+                \"The 'match' expression did not evaluate to a node set.\\n\");\n+            ctxt->state = XSLT_STATE_STOPPED;\n+            goto error;\n+        }\n@@ -733,1 +733,1 @@\n-    goto exit;\n+        goto exit;\n@@ -742,5 +742,5 @@\n-        (((keyDef->nameURI == NULL) && (table->nameURI == NULL)) ||\n-         ((keyDef->nameURI != NULL) && (table->nameURI != NULL) &&\n-          (xmlStrEqual(table->nameURI, keyDef->nameURI)))))\n-        break;\n-    table = table->next;\n+            (((keyDef->nameURI == NULL) && (table->nameURI == NULL)) ||\n+             ((keyDef->nameURI != NULL) && (table->nameURI != NULL) &&\n+              (xmlStrEqual(table->nameURI, keyDef->nameURI)))))\n+            break;\n+        table = table->next;\n@@ -755,1 +755,1 @@\n-        goto error;\n+            goto error;\n@@ -770,3 +770,3 @@\n-    cur = matchList->nodeTab[i];\n-    if (! IS_XSLT_REAL_NODE(cur))\n-        continue;\n+        cur = matchList->nodeTab[i];\n+        if (! IS_XSLT_REAL_NODE(cur))\n+            continue;\n@@ -774,29 +774,1 @@\n-    xpctxt->node = cur;\n-    \/*\n-    * Process the 'use' of the xsl:key.\n-    * SPEC XSLT 1.0:\n-    * \"The use attribute is an expression specifying the values of\n-    *  the key; the expression is evaluated once for each node that\n-    *  matches the pattern.\"\n-    *\/\n-    if (useRes != NULL)\n-        xmlXPathFreeObject(useRes);\n-    useRes = xmlXPathCompiledEval(keyDef->usecomp, xpctxt);\n-    if (useRes == NULL) {\n-        xsltTransformError(ctxt, NULL, keyDef->inst,\n-        \"Failed to evaluate the 'use' expression.\\n\");\n-        ctxt->state = XSLT_STATE_STOPPED;\n-        break;\n-    }\n-    if (useRes->type == XPATH_NODESET) {\n-        if ((useRes->nodesetval != NULL) &&\n-        (useRes->nodesetval->nodeNr != 0))\n-        {\n-        len = useRes->nodesetval->nodeNr;\n-        str = xmlXPathCastNodeToString(useRes->nodesetval->nodeTab[0]);\n-        } else {\n-        continue;\n-        }\n-    } else {\n-        len = 1;\n-        if (useRes->type == XPATH_STRING) {\n+        xpctxt->node = cur;\n@@ -804,1 +776,5 @@\n-        * Consume the string value.\n+        * Process the 'use' of the xsl:key.\n+        * SPEC XSLT 1.0:\n+        * \"The use attribute is an expression specifying the values of\n+        *  the key; the expression is evaluated once for each node that\n+        *  matches the pattern.\"\n@@ -806,2 +782,18 @@\n-        str = useRes->stringval;\n-        useRes->stringval = NULL;\n+        if (useRes != NULL)\n+            xmlXPathFreeObject(useRes);\n+        useRes = xmlXPathCompiledEval(keyDef->usecomp, xpctxt);\n+        if (useRes == NULL) {\n+            xsltTransformError(ctxt, NULL, keyDef->inst,\n+                \"Failed to evaluate the 'use' expression.\\n\");\n+            ctxt->state = XSLT_STATE_STOPPED;\n+            break;\n+        }\n+        if (useRes->type == XPATH_NODESET) {\n+            if ((useRes->nodesetval != NULL) &&\n+                (useRes->nodesetval->nodeNr != 0))\n+            {\n+                len = useRes->nodesetval->nodeNr;\n+                str = xmlXPathCastNodeToString(useRes->nodesetval->nodeTab[0]);\n+            } else {\n+                continue;\n+            }\n@@ -809,1 +801,10 @@\n-        str = xmlXPathCastToString(useRes);\n+            len = 1;\n+            if (useRes->type == XPATH_STRING) {\n+                \/*\n+                * Consume the string value.\n+                *\/\n+                str = useRes->stringval;\n+                useRes->stringval = NULL;\n+            } else {\n+                str = xmlXPathCastToString(useRes);\n+            }\n@@ -811,8 +812,7 @@\n-    }\n-    \/*\n-    * Process all strings.\n-    *\/\n-    k = 0;\n-    while (1) {\n-        if (str == NULL)\n-        goto next_string;\n+        \/*\n+        * Process all strings.\n+        *\/\n+        k = 0;\n+        while (1) {\n+            if (str == NULL)\n+                goto next_string;\n@@ -821,2 +821,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext,\n-        \"xsl:key : node associated to ('%s', '%s')\\n\", keyDef->name, str));\n+            XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext,\n+                \"xsl:key : node associated to ('%s', '%s')\\n\", keyDef->name, str));\n@@ -825,32 +825,32 @@\n-        keylist = xmlHashLookup(table->keys, str);\n-        if (keylist == NULL) {\n-        keylist = xmlXPathNodeSetCreate(cur);\n-        if (keylist == NULL)\n-            goto error;\n-        xmlHashAddEntry(table->keys, str, keylist);\n-        } else {\n-        \/*\n-        * TODO: How do we know if this function failed?\n-        *\/\n-        xmlXPathNodeSetAdd(keylist, cur);\n-        }\n-        switch (cur->type) {\n-        case XML_ELEMENT_NODE:\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        case XML_PI_NODE:\n-        case XML_COMMENT_NODE:\n-            cur->psvi = keyDef;\n-            break;\n-        case XML_ATTRIBUTE_NODE:\n-            ((xmlAttrPtr) cur)->psvi = keyDef;\n-            break;\n-        case XML_DOCUMENT_NODE:\n-        case XML_HTML_DOCUMENT_NODE:\n-            ((xmlDocPtr) cur)->psvi = keyDef;\n-            break;\n-        default:\n-            break;\n-        }\n-        xmlFree(str);\n-        str = NULL;\n+            keylist = xmlHashLookup(table->keys, str);\n+            if (keylist == NULL) {\n+                keylist = xmlXPathNodeSetCreate(cur);\n+                if (keylist == NULL)\n+                    goto error;\n+                xmlHashAddEntry(table->keys, str, keylist);\n+            } else {\n+                \/*\n+                * TODO: How do we know if this function failed?\n+                *\/\n+                xmlXPathNodeSetAdd(keylist, cur);\n+            }\n+            switch (cur->type) {\n+                case XML_ELEMENT_NODE:\n+                case XML_TEXT_NODE:\n+                case XML_CDATA_SECTION_NODE:\n+                case XML_PI_NODE:\n+                case XML_COMMENT_NODE:\n+                    cur->psvi = keyDef;\n+                    break;\n+                case XML_ATTRIBUTE_NODE:\n+                    ((xmlAttrPtr) cur)->psvi = keyDef;\n+                    break;\n+                case XML_DOCUMENT_NODE:\n+                case XML_HTML_DOCUMENT_NODE:\n+                    ((xmlDocPtr) cur)->psvi = keyDef;\n+                    break;\n+                default:\n+                    break;\n+            }\n+            xmlFree(str);\n+            str = NULL;\n@@ -859,5 +859,5 @@\n-        k++;\n-        if (k >= len)\n-        break;\n-        str = xmlXPathCastNodeToString(useRes->nodesetval->nodeTab[k]);\n-    }\n+            k++;\n+            if (k >= len)\n+                break;\n+            str = xmlXPathCastNodeToString(useRes->nodesetval->nodeTab[k]);\n+        }\n@@ -884,1 +884,1 @@\n-    xmlFree(str);\n+        xmlFree(str);\n@@ -886,1 +886,1 @@\n-    xmlXPathFreeObject(useRes);\n+        xmlXPathFreeObject(useRes);\n@@ -888,1 +888,1 @@\n-    xmlXPathFreeObject(matchRes);\n+        xmlXPathFreeObject(matchRes);\n@@ -907,1 +907,1 @@\n-    return;\n+        return;\n@@ -915,2 +915,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext, \"Initializing keys on %s\\n\",\n-             idoc->doc->URL));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_KEYS,xsltGenericDebug(xsltGenericDebugContext, \"Initializing keys on %s\\n\",\n+                     idoc->doc->URL));\n@@ -920,3 +920,3 @@\n-    keyDef = (xsltKeyDefPtr) style->keys;\n-    while (keyDef != NULL) {\n-        xsltInitCtxtKey(ctxt, idoc, keyDef);\n+        keyDef = (xsltKeyDefPtr) style->keys;\n+        while (keyDef != NULL) {\n+            xsltInitCtxtKey(ctxt, idoc, keyDef);\n@@ -924,2 +924,2 @@\n-        keyDef = keyDef->next;\n-    }\n+            keyDef = keyDef->next;\n+        }\n@@ -927,1 +927,1 @@\n-    style = xsltNextImport(style);\n+        style = xsltNextImport(style);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/keys.c","additions":297,"deletions":297,"binary":false,"changes":594,"status":"modified"},{"patch":"@@ -29,6 +29,6 @@\n-        xsltAddKey      (xsltStylesheetPtr style,\n-                     const xmlChar *name,\n-                     const xmlChar *nameURI,\n-                     const xmlChar *match,\n-                     const xmlChar *use,\n-                     xmlNodePtr inst);\n+                xsltAddKey              (xsltStylesheetPtr style,\n+                                         const xmlChar *name,\n+                                         const xmlChar *nameURI,\n+                                         const xmlChar *match,\n+                                         const xmlChar *use,\n+                                         xmlNodePtr inst);\n@@ -36,4 +36,4 @@\n-        xsltGetKey      (xsltTransformContextPtr ctxt,\n-                     const xmlChar *name,\n-                     const xmlChar *nameURI,\n-                     const xmlChar *value);\n+                xsltGetKey              (xsltTransformContextPtr ctxt,\n+                                         const xmlChar *name,\n+                                         const xmlChar *nameURI,\n+                                         const xmlChar *value);\n@@ -41,2 +41,2 @@\n-        xsltInitCtxtKeys    (xsltTransformContextPtr ctxt,\n-                     xsltDocumentPtr doc);\n+                xsltInitCtxtKeys        (xsltTransformContextPtr ctxt,\n+                                         xsltDocumentPtr doc);\n@@ -44,1 +44,1 @@\n-        xsltFreeKeys        (xsltStylesheetPtr style);\n+                xsltFreeKeys            (xsltStylesheetPtr style);\n@@ -46,1 +46,1 @@\n-        xsltFreeDocumentKeys    (xsltDocumentPtr doc);\n+                xsltFreeDocumentKeys    (xsltDocumentPtr doc);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/keys.h","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-Web site http:\/\/xmlsoft.org\/XSLT\/ .\n+Web site https:\/\/gitlab.gnome.org\/GNOME\/libxslt .\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/libxslt.3","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,3 +53,3 @@\n- *                                  *\n- *          Module interfaces               *\n- *                                  *\n+ *                                                                      *\n+ *                      Module interfaces                               *\n+ *                                                                      *\n@@ -65,1 +65,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -69,4 +69,4 @@\n-    xsltTransformError(NULL, cctxt->style, NULL,\n-        \"Internal error in xsltNewNsAlias(): Memory allocation failed.\\n\");\n-    cctxt->style->errors++;\n-    return(NULL);\n+        xsltTransformError(NULL, cctxt->style, NULL,\n+            \"Internal error in xsltNewNsAlias(): Memory allocation failed.\\n\");\n+        cctxt->style->errors++;\n+        return(NULL);\n@@ -104,1 +104,1 @@\n-    return;\n+        return;\n@@ -130,3 +130,3 @@\n-    xsltTransformError(NULL, style, node,\n-        \"The attribute 'stylesheet-prefix' is missing.\\n\");\n-    return;\n+        xsltTransformError(NULL, style, node,\n+            \"The attribute 'stylesheet-prefix' is missing.\\n\");\n+        return;\n@@ -135,1 +135,1 @@\n-    literalNs = xmlSearchNs(node->doc, node, NULL);\n+        literalNs = xmlSearchNs(node->doc, node, NULL);\n@@ -137,8 +137,8 @@\n-    literalNs = xmlSearchNs(node->doc, node, stylePrefix);\n-    if (literalNs == NULL) {\n-        xsltTransformError(NULL, style, node,\n-            \"Attribute 'stylesheet-prefix': There's no namespace \"\n-        \"declaration in scope for the prefix '%s'.\\n\",\n-            stylePrefix);\n-        goto error;\n-    }\n+        literalNs = xmlSearchNs(node->doc, node, stylePrefix);\n+        if (literalNs == NULL) {\n+            xsltTransformError(NULL, style, node,\n+                \"Attribute 'stylesheet-prefix': There's no namespace \"\n+                \"declaration in scope for the prefix '%s'.\\n\",\n+                    stylePrefix);\n+            goto error;\n+        }\n@@ -151,3 +151,3 @@\n-    xsltTransformError(NULL, style, node,\n-        \"The attribute 'result-prefix' is missing.\\n\");\n-    goto error;\n+        xsltTransformError(NULL, style, node,\n+            \"The attribute 'result-prefix' is missing.\\n\");\n+        goto error;\n@@ -156,1 +156,1 @@\n-    targetNs = xmlSearchNs(node->doc, node, NULL);\n+        targetNs = xmlSearchNs(node->doc, node, NULL);\n@@ -158,1 +158,1 @@\n-    targetNs = xmlSearchNs(node->doc, node, resultPrefix);\n+        targetNs = xmlSearchNs(node->doc, node, resultPrefix);\n@@ -161,6 +161,6 @@\n-       xsltTransformError(NULL, style, node,\n-            \"Attribute 'result-prefix': There's no namespace \"\n-        \"declaration in scope for the prefix '%s'.\\n\",\n-            stylePrefix);\n-        goto error;\n-    }\n+           xsltTransformError(NULL, style, node,\n+                \"Attribute 'result-prefix': There's no namespace \"\n+                \"declaration in scope for the prefix '%s'.\\n\",\n+                    stylePrefix);\n+            goto error;\n+        }\n@@ -207,1 +207,1 @@\n-    return;\n+        return;\n@@ -219,1 +219,1 @@\n-    return;\n+        return;\n@@ -223,3 +223,3 @@\n-    xsltTransformError(NULL, style, node,\n-        \"namespace-alias: stylesheet-prefix attribute missing\\n\");\n-    return;\n+        xsltTransformError(NULL, style, node,\n+            \"namespace-alias: stylesheet-prefix attribute missing\\n\");\n+        return;\n@@ -229,3 +229,3 @@\n-    xsltTransformError(NULL, style, node,\n-        \"namespace-alias: result-prefix attribute missing\\n\");\n-    goto error;\n+        xsltTransformError(NULL, style, node,\n+            \"namespace-alias: result-prefix attribute missing\\n\");\n+        goto error;\n@@ -235,5 +235,5 @@\n-    literalNs = xmlSearchNs(node->doc, node, NULL);\n-    if (literalNs == NULL) {\n-        literalNsName = NULL;\n-    } else\n-        literalNsName = literalNs->href; \/* Yes - set for nsAlias table *\/\n+        literalNs = xmlSearchNs(node->doc, node, NULL);\n+        if (literalNs == NULL) {\n+            literalNsName = NULL;\n+        } else\n+            literalNsName = literalNs->href; \/* Yes - set for nsAlias table *\/\n@@ -241,9 +241,9 @@\n-    literalNs = xmlSearchNs(node->doc, node, stylePrefix);\n-\n-    if ((literalNs == NULL) || (literalNs->href == NULL)) {\n-        xsltTransformError(NULL, style, node,\n-            \"namespace-alias: prefix %s not bound to any namespace\\n\",\n-                    stylePrefix);\n-        goto error;\n-    } else\n-        literalNsName = literalNs->href;\n+        literalNs = xmlSearchNs(node->doc, node, stylePrefix);\n+\n+        if ((literalNs == NULL) || (literalNs->href == NULL)) {\n+            xsltTransformError(NULL, style, node,\n+                \"namespace-alias: prefix %s not bound to any namespace\\n\",\n+                                        stylePrefix);\n+            goto error;\n+        } else\n+            literalNsName = literalNs->href;\n@@ -258,5 +258,5 @@\n-    targetNs = xmlSearchNs(node->doc, node, NULL);\n-    if (targetNs == NULL) {\n-        targetNsName = UNDEFINED_DEFAULT_NS;\n-    } else\n-        targetNsName = targetNs->href;\n+        targetNs = xmlSearchNs(node->doc, node, NULL);\n+        if (targetNs == NULL) {\n+            targetNsName = UNDEFINED_DEFAULT_NS;\n+        } else\n+            targetNsName = targetNs->href;\n@@ -264,1 +264,1 @@\n-    targetNs = xmlSearchNs(node->doc, node, resultPrefix);\n+        targetNs = xmlSearchNs(node->doc, node, resultPrefix);\n@@ -267,6 +267,6 @@\n-        xsltTransformError(NULL, style, node,\n-            \"namespace-alias: prefix %s not bound to any namespace\\n\",\n-                    resultPrefix);\n-        goto error;\n-    } else\n-        targetNsName = targetNs->href;\n+            xsltTransformError(NULL, style, node,\n+                \"namespace-alias: prefix %s not bound to any namespace\\n\",\n+                                        resultPrefix);\n+            goto error;\n+        } else\n+            targetNsName = targetNs->href;\n@@ -281,11 +281,11 @@\n-        \/*\n-        * BUG TODO: Is it not sufficient to have only 1 field for\n-        *  this, since subsequently alias declarations will\n-        *  overwrite this.\n-        *  Example:\n-        *   <xsl:namespace-alias result-prefix=\"foo\"\n-        *                        stylesheet-prefix=\"#default\"\/>\n-        *   <xsl:namespace-alias result-prefix=\"bar\"\n-        *                        stylesheet-prefix=\"#default\"\/>\n-        *  The mapping for \"foo\" won't be visible anymore.\n-        *\/\n+            \/*\n+            * BUG TODO: Is it not sufficient to have only 1 field for\n+            *  this, since subsequently alias declarations will\n+            *  overwrite this.\n+            *  Example:\n+            *   <xsl:namespace-alias result-prefix=\"foo\"\n+            *                        stylesheet-prefix=\"#default\"\/>\n+            *   <xsl:namespace-alias result-prefix=\"bar\"\n+            *                        stylesheet-prefix=\"#default\"\/>\n+            *  The mapping for \"foo\" won't be visible anymore.\n+            *\/\n@@ -293,1 +293,1 @@\n-    }\n+        }\n@@ -296,1 +296,1 @@\n-        style->nsAliases = xmlHashCreate(10);\n+            style->nsAliases = xmlHashCreate(10);\n@@ -298,3 +298,3 @@\n-        xsltTransformError(NULL, style, node,\n-            \"namespace-alias: cannot create hash table\\n\");\n-        goto error;\n+            xsltTransformError(NULL, style, node,\n+                \"namespace-alias: cannot create hash table\\n\");\n+            goto error;\n@@ -302,2 +302,2 @@\n-    xmlHashAddEntry((xmlHashTablePtr) style->nsAliases,\n-        literalNsName, (void *) targetNsName);\n+        xmlHashAddEntry((xmlHashTablePtr) style->nsAliases,\n+            literalNsName, (void *) targetNsName);\n@@ -309,1 +309,1 @@\n-    xmlFree(stylePrefix);\n+        xmlFree(stylePrefix);\n@@ -311,1 +311,1 @@\n-    xmlFree(resultPrefix);\n+        xmlFree(resultPrefix);\n@@ -338,2 +338,2 @@\n-        const xmlChar *nsName, const xmlChar *nsPrefix,\n-        xmlNodePtr target)\n+                const xmlChar *nsName, const xmlChar *nsPrefix,\n+                xmlNodePtr target)\n@@ -345,2 +345,2 @@\n-    (target->type != XML_ELEMENT_NODE))\n-    return(NULL);\n+        (target->type != XML_ELEMENT_NODE))\n+        return(NULL);\n@@ -363,42 +363,0 @@\n-    \/*\n-    * NOTE: the \"undeclaration\" of the default namespace was\n-    * part of the logic of the old xsltGetSpecialNamespace() code,\n-    * so we'll keep that mechanism.\n-    * Related to the old code: bug #302020:\n-    *\/\n-    \/*\n-    * OPTIMIZE TODO: This all could be optimized by keeping track of\n-    *  the ns-decls currently in-scope via a specialized context.\n-    *\/\n-    \/*\n-    * Search on the result element itself.\n-    *\/\n-    if (target->nsDef != NULL) {\n-        ns = target->nsDef;\n-        do {\n-        if (ns->prefix == NULL) {\n-            if ((ns->href != NULL) && (ns->href[0] != 0)) {\n-            \/*\n-            * Raise a namespace normalization error.\n-            *\/\n-            xsltTransformError(ctxt, NULL, invocNode,\n-                \"Namespace normalization error: Cannot undeclare \"\n-                \"the default namespace, since the default namespace \"\n-                \"'%s' is already declared on the result element \"\n-                \"'%s'.\\n\", ns->href, target->name);\n-            return(NULL);\n-            } else {\n-            \/*\n-            * The default namespace was undeclared on the\n-            * result element.\n-            *\/\n-            return(NULL);\n-            }\n-            break;\n-        }\n-        ns = ns->next;\n-        } while (ns != NULL);\n-    }\n-    if ((target->parent != NULL) &&\n-        (target->parent->type == XML_ELEMENT_NODE))\n-    {\n@@ -406,2 +364,4 @@\n-        * The parent element is in no namespace, so assume\n-        * that there is no default namespace in scope.\n+        * NOTE: the \"undeclaration\" of the default namespace was\n+        * part of the logic of the old xsltGetSpecialNamespace() code,\n+        * so we'll keep that mechanism.\n+        * Related to the old code: bug #302020:\n@@ -409,5 +369,0 @@\n-        if (target->parent->ns == NULL)\n-        return(NULL);\n-\n-        ns = xmlSearchNs(target->doc, target->parent,\n-        NULL);\n@@ -415,2 +370,2 @@\n-        * Fine if there's no default ns is scope, or if the\n-        * default ns was undeclared.\n+        * OPTIMIZE TODO: This all could be optimized by keeping track of\n+        *  the ns-decls currently in-scope via a specialized context.\n@@ -418,3 +373,0 @@\n-        if ((ns == NULL) || (ns->href == NULL) || (ns->href[0] == 0))\n-        return(NULL);\n-\n@@ -422,1 +374,1 @@\n-        * Undeclare the default namespace.\n+        * Search on the result element itself.\n@@ -424,2 +376,52 @@\n-        xmlNewNs(target, BAD_CAST \"\", NULL);\n-        \/* TODO: Check result *\/\n+        if (target->nsDef != NULL) {\n+            ns = target->nsDef;\n+            do {\n+                if (ns->prefix == NULL) {\n+                    if ((ns->href != NULL) && (ns->href[0] != 0)) {\n+                        \/*\n+                        * Raise a namespace normalization error.\n+                        *\/\n+                        xsltTransformError(ctxt, NULL, invocNode,\n+                            \"Namespace normalization error: Cannot undeclare \"\n+                            \"the default namespace, since the default namespace \"\n+                            \"'%s' is already declared on the result element \"\n+                            \"'%s'.\\n\", ns->href, target->name);\n+                        return(NULL);\n+                    } else {\n+                        \/*\n+                        * The default namespace was undeclared on the\n+                        * result element.\n+                        *\/\n+                        return(NULL);\n+                    }\n+                    break;\n+                }\n+                ns = ns->next;\n+            } while (ns != NULL);\n+        }\n+        if ((target->parent != NULL) &&\n+            (target->parent->type == XML_ELEMENT_NODE))\n+        {\n+            \/*\n+            * The parent element is in no namespace, so assume\n+            * that there is no default namespace in scope.\n+            *\/\n+            if (target->parent->ns == NULL)\n+                return(NULL);\n+\n+            ns = xmlSearchNs(target->doc, target->parent,\n+                NULL);\n+            \/*\n+            * Fine if there's no default ns is scope, or if the\n+            * default ns was undeclared.\n+            *\/\n+            if ((ns == NULL) || (ns->href == NULL) || (ns->href[0] == 0))\n+                return(NULL);\n+\n+            \/*\n+            * Undeclare the default namespace.\n+            *\/\n+            xmlNewNs(target, BAD_CAST \"\", NULL);\n+            \/* TODO: Check result *\/\n+            return(NULL);\n+        }\n@@ -428,2 +430,0 @@\n-    return(NULL);\n-    }\n@@ -435,2 +435,2 @@\n-    (nsPrefix[0] == 'x') && (nsPrefix[1] == 'm') &&\n-    (nsPrefix[2] == 'l') && (nsPrefix[3] == 0))\n+        (nsPrefix[0] == 'x') && (nsPrefix[1] == 'm') &&\n+        (nsPrefix[2] == 'l') && (nsPrefix[3] == 0))\n@@ -438,1 +438,1 @@\n-    return(xmlSearchNs(target->doc, target, nsPrefix));\n+        return(xmlSearchNs(target->doc, target, nsPrefix));\n@@ -444,17 +444,17 @@\n-    ns = target->nsDef;\n-    do {\n-        if ((ns->prefix == NULL) == (nsPrefix == NULL)) {\n-        if (ns->prefix == nsPrefix) {\n-            if (xmlStrEqual(ns->href, nsName))\n-            return(ns);\n-            prefixOccupied = 1;\n-            break;\n-        } else if (xmlStrEqual(ns->prefix, nsPrefix)) {\n-            if (xmlStrEqual(ns->href, nsName))\n-            return(ns);\n-            prefixOccupied = 1;\n-            break;\n-        }\n-        }\n-        ns = ns->next;\n-    } while (ns != NULL);\n+        ns = target->nsDef;\n+        do {\n+            if ((ns->prefix == NULL) == (nsPrefix == NULL)) {\n+                if (ns->prefix == nsPrefix) {\n+                    if (xmlStrEqual(ns->href, nsName))\n+                        return(ns);\n+                    prefixOccupied = 1;\n+                    break;\n+                } else if (xmlStrEqual(ns->prefix, nsPrefix)) {\n+                    if (xmlStrEqual(ns->href, nsName))\n+                        return(ns);\n+                    prefixOccupied = 1;\n+                    break;\n+                }\n+            }\n+            ns = ns->next;\n+        } while (ns != NULL);\n@@ -463,13 +463,13 @@\n-    \/*\n-    * If the ns-prefix is occupied by an other ns-decl on the\n-    * result element, then this means:\n-    * 1) The desired prefix is shadowed\n-    * 2) There's no way around changing the prefix\n-    *\n-    * Try a desperate search for an in-scope ns-decl\n-    * with a matching ns-name before we use the last option,\n-    * which is to recreate the ns-decl with a modified prefix.\n-    *\/\n-    ns = xmlSearchNsByHref(target->doc, target, nsName);\n-    if (ns != NULL)\n-        return(ns);\n+        \/*\n+        * If the ns-prefix is occupied by an other ns-decl on the\n+        * result element, then this means:\n+        * 1) The desired prefix is shadowed\n+        * 2) There's no way around changing the prefix\n+        *\n+        * Try a desperate search for an in-scope ns-decl\n+        * with a matching ns-name before we use the last option,\n+        * which is to recreate the ns-decl with a modified prefix.\n+        *\/\n+        ns = xmlSearchNsByHref(target->doc, target, nsName);\n+        if (ns != NULL)\n+            return(ns);\n@@ -477,3 +477,3 @@\n-    \/*\n-    * Fallback to changing the prefix.\n-    *\/\n+        \/*\n+        * Fallback to changing the prefix.\n+        *\/\n@@ -481,10 +481,1 @@\n-    (target->parent->type == XML_ELEMENT_NODE))\n-    {\n-    \/*\n-    * Try to find a matching ns-decl in the ancestor-axis.\n-    *\n-    * Check the common case: The parent element of the current\n-    * result element is in the same namespace (with an equal ns-prefix).\n-    *\/\n-    if ((target->parent->ns != NULL) &&\n-        ((target->parent->ns->prefix != NULL) == (nsPrefix != NULL)))\n+        (target->parent->type == XML_ELEMENT_NODE))\n@@ -492,7 +483,8 @@\n-        ns = target->parent->ns;\n-\n-        if (nsPrefix == NULL) {\n-        if (xmlStrEqual(ns->href, nsName))\n-            return(ns);\n-        } else if (xmlStrEqual(ns->prefix, nsPrefix) &&\n-        xmlStrEqual(ns->href, nsName))\n+        \/*\n+        * Try to find a matching ns-decl in the ancestor-axis.\n+        *\n+        * Check the common case: The parent element of the current\n+        * result element is in the same namespace (with an equal ns-prefix).\n+        *\/\n+        if ((target->parent->ns != NULL) &&\n+            ((target->parent->ns->prefix != NULL) == (nsPrefix != NULL)))\n@@ -500,1 +492,10 @@\n-        return(ns);\n+            ns = target->parent->ns;\n+\n+            if (nsPrefix == NULL) {\n+                if (xmlStrEqual(ns->href, nsName))\n+                    return(ns);\n+            } else if (xmlStrEqual(ns->prefix, nsPrefix) &&\n+                xmlStrEqual(ns->href, nsName))\n+            {\n+                return(ns);\n+            }\n@@ -502,8 +503,0 @@\n-    }\n-    \/*\n-    * Lookup the remaining in-scope namespaces.\n-    *\/\n-    ns = xmlSearchNs(target->doc, target->parent, nsPrefix);\n-    if (ns != NULL) {\n-        if (xmlStrEqual(ns->href, nsName))\n-        return(ns);\n@@ -511,8 +504,1 @@\n-        * Now check for a nasty case: We need to ensure that the new\n-        * ns-decl won't shadow a prefix in-use by an existing attribute.\n-        * <foo xmlns:a=\"urn:test:a\">\n-        *   <bar a:a=\"val-a\">\n-        *     <xsl:attribute xmlns:a=\"urn:test:b\" name=\"a:b\">\n-        *        val-b<\/xsl:attribute>\n-        *   <\/bar>\n-        * <\/foo>\n+        * Lookup the remaining in-scope namespaces.\n@@ -520,6 +506,4 @@\n-        if (target->properties) {\n-        xmlAttrPtr attr = target->properties;\n-        do {\n-            if ((attr->ns) &&\n-            xmlStrEqual(attr->ns->prefix, nsPrefix))\n-            {\n+        ns = xmlSearchNs(target->doc, target->parent, nsPrefix);\n+        if (ns != NULL) {\n+            if (xmlStrEqual(ns->href, nsName))\n+                return(ns);\n@@ -527,4 +511,8 @@\n-            * Bad, this prefix is already in use.\n-            * Since we'll change the prefix anyway, try\n-            * a search for a matching ns-decl based on the\n-            * namespace name.\n+            * Now check for a nasty case: We need to ensure that the new\n+            * ns-decl won't shadow a prefix in-use by an existing attribute.\n+            * <foo xmlns:a=\"urn:test:a\">\n+            *   <bar a:a=\"val-a\">\n+            *     <xsl:attribute xmlns:a=\"urn:test:b\" name=\"a:b\">\n+            *        val-b<\/xsl:attribute>\n+            *   <\/bar>\n+            * <\/foo>\n@@ -532,0 +520,38 @@\n+            if (target->properties) {\n+                xmlAttrPtr attr = target->properties;\n+                do {\n+                    if ((attr->ns) &&\n+                        xmlStrEqual(attr->ns->prefix, nsPrefix))\n+                    {\n+                        \/*\n+                        * Bad, this prefix is already in use.\n+                        * Since we'll change the prefix anyway, try\n+                        * a search for a matching ns-decl based on the\n+                        * namespace name.\n+                        *\/\n+                        ns = xmlSearchNsByHref(target->doc, target, nsName);\n+                        if (ns != NULL)\n+                            return(ns);\n+                        goto declare_new_prefix;\n+                    }\n+                    attr = attr->next;\n+                } while (attr != NULL);\n+            }\n+        } else {\n+            \/*\n+            * Either no matching ns-prefix was found or the namespace is\n+            * shadowed.\n+            * Create a new ns-decl on the current result element.\n+            *\n+            * Hmm, we could also try to reuse an in-scope\n+            * namespace with a matching ns-name but a different\n+            * ns-prefix.\n+            * What has higher priority?\n+            *  1) If keeping the prefix: create a new ns-decl.\n+            *  2) If reusal: first lookup ns-names; then fallback\n+            *     to creation of a new ns-decl.\n+            * REVISIT: this currently uses case 1) although\n+            *  the old way was use xmlSearchNsByHref() and to let change\n+            *  the prefix.\n+            *\/\n+#if 0\n@@ -535,4 +561,1 @@\n-            goto declare_new_prefix;\n-            }\n-            attr = attr->next;\n-        } while (attr != NULL);\n+#endif\n@@ -540,1 +563,0 @@\n-    } else {\n@@ -542,14 +564,1 @@\n-        * Either no matching ns-prefix was found or the namespace is\n-        * shadowed.\n-        * Create a new ns-decl on the current result element.\n-        *\n-        * Hmm, we could also try to reuse an in-scope\n-        * namespace with a matching ns-name but a different\n-        * ns-prefix.\n-        * What has higher priority?\n-        *  1) If keeping the prefix: create a new ns-decl.\n-        *  2) If reusal: first lookup ns-names; then fallback\n-        *     to creation of a new ns-decl.\n-        * REVISIT: this currently uses case 1) although\n-        *  the old way was use xmlSearchNsByHref() and to let change\n-        *  the prefix.\n+        * Create the ns-decl on the current result element.\n@@ -557,3 +566,2 @@\n-#if 0\n-        ns = xmlSearchNsByHref(target->doc, target, nsName);\n-        if (ns != NULL)\n+        ns = xmlNewNs(target, nsName, nsPrefix);\n+        \/* TODO: check errors *\/\n@@ -561,8 +569,0 @@\n-#endif\n-    }\n-    \/*\n-    * Create the ns-decl on the current result element.\n-    *\/\n-    ns = xmlNewNs(target, nsName, nsPrefix);\n-    \/* TODO: check errors *\/\n-    return(ns);\n@@ -570,6 +570,6 @@\n-    \/*\n-    * This is either the root of the tree or something weird is going on.\n-    *\/\n-    ns = xmlNewNs(target, nsName, nsPrefix);\n-    \/* TODO: Check result *\/\n-    return(ns);\n+        \/*\n+        * This is either the root of the tree or something weird is going on.\n+        *\/\n+        ns = xmlNewNs(target, nsName, nsPrefix);\n+        \/* TODO: Check result *\/\n+        return(ns);\n@@ -584,6 +584,2 @@\n-    xmlChar pref[30];\n-    int counter = 1;\n-\n-    if (nsPrefix == NULL) {\n-        nsPrefix = BAD_CAST \"ns\";\n-    }\n+        xmlChar pref[30];\n+        int counter = 1;\n@@ -591,9 +587,2 @@\n-    do {\n-        snprintf((char *) pref, 30, \"%s_%d\", nsPrefix, counter++);\n-        ns = xmlSearchNs(target->doc, target, BAD_CAST pref);\n-        if (counter > 1000) {\n-        xsltTransformError(ctxt, NULL, invocNode,\n-            \"Internal error in xsltAcquireResultInScopeNs(): \"\n-            \"Failed to compute a unique ns-prefix for the \"\n-            \"generated element\");\n-        return(NULL);\n+        if (nsPrefix == NULL) {\n+            nsPrefix = BAD_CAST \"ns\";\n@@ -601,4 +590,15 @@\n-    } while (ns != NULL);\n-    ns = xmlNewNs(target, nsName, BAD_CAST pref);\n-    \/* TODO: Check result *\/\n-    return(ns);\n+\n+        do {\n+            snprintf((char *) pref, 30, \"%s_%d\", nsPrefix, counter++);\n+            ns = xmlSearchNs(target->doc, target, BAD_CAST pref);\n+            if (counter > 1000) {\n+                xsltTransformError(ctxt, NULL, invocNode,\n+                    \"Internal error in xsltAcquireResultInScopeNs(): \"\n+                    \"Failed to compute a unique ns-prefix for the \"\n+                    \"generated element\");\n+                return(NULL);\n+            }\n+        } while (ns != NULL);\n+        ns = xmlNewNs(target, nsName, BAD_CAST pref);\n+        \/* TODO: Check result *\/\n+        return(ns);\n@@ -635,1 +635,1 @@\n-             xmlNodePtr out)\n+                 xmlNodePtr out)\n@@ -639,1 +639,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -651,2 +651,2 @@\n-    xsltStylesheetPtr style;\n-    const xmlChar *URI = NULL; \/* the replacement URI *\/\n+        xsltStylesheetPtr style;\n+        const xmlChar *URI = NULL; \/* the replacement URI *\/\n@@ -654,2 +654,2 @@\n-    if ((ctxt == NULL) || (cur == NULL) || (out == NULL))\n-        return(NULL);\n+        if ((ctxt == NULL) || (cur == NULL) || (out == NULL))\n+            return(NULL);\n@@ -657,7 +657,7 @@\n-    style = ctxt->style;\n-    while (style != NULL) {\n-        if (style->nsAliases != NULL)\n-        URI = (const xmlChar *)\n-        xmlHashLookup(style->nsAliases, ns->href);\n-        if (URI != NULL)\n-        break;\n+        style = ctxt->style;\n+        while (style != NULL) {\n+            if (style->nsAliases != NULL)\n+                URI = (const xmlChar *)\n+                xmlHashLookup(style->nsAliases, ns->href);\n+            if (URI != NULL)\n+                break;\n@@ -665,2 +665,2 @@\n-        style = xsltNextImport(style);\n-    }\n+            style = xsltNextImport(style);\n+        }\n@@ -669,2 +669,2 @@\n-    if (URI == UNDEFINED_DEFAULT_NS) {\n-        return(xsltGetSpecialNamespace(ctxt, cur, NULL, NULL, out));\n+        if (URI == UNDEFINED_DEFAULT_NS) {\n+            return(xsltGetSpecialNamespace(ctxt, cur, NULL, NULL, out));\n@@ -672,11 +672,11 @@\n-        \/*\n-        * TODO: Removed, since wrong. If there was no default\n-        * namespace in the stylesheet then this must resolve to\n-        * the NULL namespace.\n-        *\/\n-        xmlNsPtr dflt;\n-        dflt = xmlSearchNs(cur->doc, cur, NULL);\n-        if (dflt != NULL)\n-        URI = dflt->href;\n-        else\n-        return NULL;\n+            \/*\n+            * TODO: Removed, since wrong. If there was no default\n+            * namespace in the stylesheet then this must resolve to\n+            * the NULL namespace.\n+            *\/\n+            xmlNsPtr dflt;\n+            dflt = xmlSearchNs(cur->doc, cur, NULL);\n+            if (dflt != NULL)\n+                URI = dflt->href;\n+            else\n+                return NULL;\n@@ -684,2 +684,2 @@\n-    } else if (URI == NULL)\n-        URI = ns->href;\n+        } else if (URI == NULL)\n+            URI = ns->href;\n@@ -687,1 +687,1 @@\n-    return(xsltGetSpecialNamespace(ctxt, cur, URI, ns->prefix, out));\n+        return(xsltGetSpecialNamespace(ctxt, cur, URI, ns->prefix, out));\n@@ -736,1 +736,1 @@\n-                  xmlNsPtr cur) {\n+                      xmlNsPtr cur) {\n@@ -741,1 +741,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -743,1 +743,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -749,1 +749,1 @@\n-    node = NULL;\n+        node = NULL;\n@@ -752,2 +752,2 @@\n-    if (cur->type != XML_NAMESPACE_DECL)\n-        break;\n+        if (cur->type != XML_NAMESPACE_DECL)\n+            break;\n@@ -755,15 +755,16 @@\n-    \/*\n-     * Avoid duplicating namespace declarations in the tree if\n-     * a matching declaration is in scope.\n-     *\/\n-    if (node != NULL) {\n-        if ((node->ns != NULL) &&\n-        (xmlStrEqual(node->ns->prefix, cur->prefix)) &&\n-    (xmlStrEqual(node->ns->href, cur->href))) {\n-        cur = cur->next;\n-        continue;\n-        }\n-        tmp = xmlSearchNs(node->doc, node, cur->prefix);\n-        if ((tmp != NULL) && (xmlStrEqual(tmp->href, cur->href))) {\n-        cur = cur->next;\n-        continue;\n+        \/*\n+         * Avoid duplicating namespace declarations in the tree if\n+         * a matching declaration is in scope.\n+         *\/\n+        if (node != NULL) {\n+            if ((node->ns != NULL) &&\n+                (xmlStrEqual(node->ns->prefix, cur->prefix)) &&\n+        (xmlStrEqual(node->ns->href, cur->href))) {\n+                cur = cur->next;\n+                continue;\n+            }\n+            tmp = xmlSearchNs(node->doc, node, cur->prefix);\n+            if ((tmp != NULL) && (xmlStrEqual(tmp->href, cur->href))) {\n+                cur = cur->next;\n+                continue;\n+            }\n@@ -771,1 +772,0 @@\n-    }\n@@ -773,27 +773,4 @@\n-    \/*\n-    * Namespace exclusion and ns-aliasing is performed at\n-    * compilation-time in the refactored code.\n-    *\/\n-    q = xmlNewNs(node, cur->href, cur->prefix);\n-    if (p == NULL) {\n-        ret = p = q;\n-    } else {\n-        p->next = q;\n-        p = q;\n-    }\n-#else\n-    \/*\n-    * TODO: Remove this if the refactored code gets enabled.\n-    *\/\n-    if (!xmlStrEqual(cur->href, XSLT_NAMESPACE)) {\n-        const xmlChar *URI;\n-        \/* TODO apply cascading *\/\n-        URI = (const xmlChar *) xmlHashLookup(ctxt->style->nsAliases,\n-                                          cur->href);\n-        if (URI == UNDEFINED_DEFAULT_NS) {\n-        cur = cur->next;\n-            continue;\n-        }\n-        if (URI != NULL) {\n-        q = xmlNewNs(node, URI, cur->prefix);\n-        } else {\n+        \/*\n+        * Namespace exclusion and ns-aliasing is performed at\n+        * compilation-time in the refactored code.\n+        *\/\n@@ -801,1 +778,0 @@\n-        }\n@@ -803,1 +779,1 @@\n-        ret = p = q;\n+            ret = p = q;\n@@ -805,2 +781,27 @@\n-        p->next = q;\n-        p = q;\n+            p->next = q;\n+            p = q;\n+        }\n+#else\n+        \/*\n+        * TODO: Remove this if the refactored code gets enabled.\n+        *\/\n+        if (!xmlStrEqual(cur->href, XSLT_NAMESPACE)) {\n+            const xmlChar *URI;\n+            \/* TODO apply cascading *\/\n+            URI = (const xmlChar *) xmlHashLookup(ctxt->style->nsAliases,\n+                                                  cur->href);\n+            if (URI == UNDEFINED_DEFAULT_NS) {\n+                cur = cur->next;\n+                continue;\n+            }\n+            if (URI != NULL) {\n+                q = xmlNewNs(node, URI, cur->prefix);\n+            } else {\n+                q = xmlNewNs(node, cur->href, cur->prefix);\n+            }\n+            if (p == NULL) {\n+                ret = p = q;\n+            } else {\n+                p->next = q;\n+                p = q;\n+            }\n@@ -808,1 +809,0 @@\n-    }\n@@ -810,1 +810,1 @@\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -828,1 +828,1 @@\n-          xmlNodePtr elem, xmlNsPtr ns)\n+                  xmlNodePtr elem, xmlNsPtr ns)\n@@ -831,1 +831,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -836,1 +836,1 @@\n-    return(xmlNewNs(NULL, ns->href, ns->prefix));\n+        return(xmlNewNs(NULL, ns->href, ns->prefix));\n@@ -838,1 +838,1 @@\n-    return(xmlNewNs(elem, ns->href, ns->prefix));\n+        return(xmlNewNs(elem, ns->href, ns->prefix));\n@@ -851,1 +851,1 @@\n-    xmlHashFree((xmlHashTablePtr) style->nsAliases, NULL);\n+        xmlHashFree((xmlHashTablePtr) style->nsAliases, NULL);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/namespaces.c","additions":375,"deletions":375,"binary":false,"changes":750,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-        xsltNamespaceAlias  (xsltStylesheetPtr style,\n-                     xmlNodePtr node);\n+                xsltNamespaceAlias      (xsltStylesheetPtr style,\n+                                         xmlNodePtr node);\n@@ -36,4 +36,4 @@\n-        xsltGetNamespace    (xsltTransformContextPtr ctxt,\n-                     xmlNodePtr cur,\n-                     xmlNsPtr ns,\n-                     xmlNodePtr out);\n+                xsltGetNamespace        (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr cur,\n+                                         xmlNsPtr ns,\n+                                         xmlNodePtr out);\n@@ -41,4 +41,4 @@\n-        xsltGetPlainNamespace   (xsltTransformContextPtr ctxt,\n-                     xmlNodePtr cur,\n-                     xmlNsPtr ns,\n-                     xmlNodePtr out);\n+                xsltGetPlainNamespace   (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr cur,\n+                                         xmlNsPtr ns,\n+                                         xmlNodePtr out);\n@@ -46,5 +46,5 @@\n-        xsltGetSpecialNamespace (xsltTransformContextPtr ctxt,\n-                     xmlNodePtr cur,\n-                     const xmlChar *URI,\n-                     const xmlChar *prefix,\n-                     xmlNodePtr out);\n+                xsltGetSpecialNamespace (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr cur,\n+                                         const xmlChar *URI,\n+                                         const xmlChar *prefix,\n+                                         xmlNodePtr out);\n@@ -52,3 +52,3 @@\n-        xsltCopyNamespace   (xsltTransformContextPtr ctxt,\n-                     xmlNodePtr elem,\n-                     xmlNsPtr ns);\n+                xsltCopyNamespace       (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr elem,\n+                                         xmlNsPtr ns);\n@@ -56,3 +56,3 @@\n-        xsltCopyNamespaceList   (xsltTransformContextPtr ctxt,\n-                     xmlNodePtr node,\n-                     xmlNsPtr cur);\n+                xsltCopyNamespaceList   (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNsPtr cur);\n@@ -60,2 +60,2 @@\n-        xsltFreeNamespaceAliasHashes\n-                    (xsltStylesheetPtr style);\n+                xsltFreeNamespaceAliasHashes\n+                                        (xsltStylesheetPtr style);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/namespaces.h","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#define SYMBOL_QUOTE        ((xmlChar)'\\'')\n+#define SYMBOL_QUOTE            ((xmlChar)'\\'')\n@@ -39,2 +39,2 @@\n-#define DEFAULT_TOKEN       '0'\n-#define DEFAULT_SEPARATOR   \".\"\n+#define DEFAULT_TOKEN           '0'\n+#define DEFAULT_SEPARATOR       \".\"\n@@ -42,1 +42,1 @@\n-#define MAX_TOKENS      1024\n+#define MAX_TOKENS              1024\n@@ -47,3 +47,3 @@\n-    xmlChar *separator;\n-    int      token;\n-    int      width;\n+    xmlChar     *separator;\n+    int          token;\n+    int          width;\n@@ -55,4 +55,4 @@\n-    xmlChar     *start;\n-    xsltFormatToken  tokens[MAX_TOKENS];\n-    int          nTokens;\n-    xmlChar     *end;\n+    xmlChar             *start;\n+    xsltFormatToken      tokens[MAX_TOKENS];\n+    int                  nTokens;\n+    xmlChar             *end;\n@@ -97,3 +97,3 @@\n- *                                  *\n- *          Utility functions               *\n- *                                  *\n+ *                                                                      *\n+ *                      Utility functions                               *\n+ *                                                                      *\n@@ -102,2 +102,2 @@\n-#define IS_SPECIAL(self,letter)         \\\n-    ((xsltUTF8Charcmp((letter), (self)->zeroDigit) == 0)        ||  \\\n+#define IS_SPECIAL(self,letter)                 \\\n+    ((xsltUTF8Charcmp((letter), (self)->zeroDigit) == 0)            ||  \\\n@@ -126,1 +126,1 @@\n-    return TRUE;\n+        return TRUE;\n@@ -128,1 +128,1 @@\n-    return FALSE;\n+        return FALSE;\n@@ -134,6 +134,6 @@\n-            double number,\n-            int digit_zero,\n-            int width,\n-            int digitsPerGroup,\n-            int groupingCharacter,\n-            int groupingCharacterLen)\n+                        double number,\n+                        int digit_zero,\n+                        int width,\n+                        int digitsPerGroup,\n+                        int groupingCharacter,\n+                        int groupingCharacterLen)\n@@ -161,8 +161,11 @@\n-    if ((i >= width) && (fabs(number) < 1.0))\n-        break; \/* for *\/\n-    if ((i > 0) && (groupingCharacter != 0) &&\n-        (digitsPerGroup > 0) &&\n-        ((i % digitsPerGroup) == 0)) {\n-        if (pointer - groupingCharacterLen < temp_string) {\n-            i = -1;     \/* flag error *\/\n-        break;\n+        if ((i >= width) && (fabs(number) < 1.0))\n+            break; \/* for *\/\n+        if ((i > 0) && (groupingCharacter != 0) &&\n+            (digitsPerGroup > 0) &&\n+            ((i % digitsPerGroup) == 0)) {\n+            if (pointer - groupingCharacterLen < temp_string) {\n+                i = -1;         \/* flag error *\/\n+                break;\n+            }\n+            pointer -= groupingCharacterLen;\n+            xmlCopyCharMultiByte(pointer, groupingCharacter);\n@@ -170,3 +173,0 @@\n-        pointer -= groupingCharacterLen;\n-        xmlCopyCharMultiByte(pointer, groupingCharacter);\n-    }\n@@ -174,5 +174,7 @@\n-    val = digit_zero + (int)fmod(number, 10.0);\n-    if (val < 0x80) {           \/* shortcut if ASCII *\/\n-        if (pointer <= temp_string) {   \/* Check enough room *\/\n-            i = -1;\n-        break;\n+        val = digit_zero + (int)fmod(number, 10.0);\n+        if (val < 0x80) {                       \/* shortcut if ASCII *\/\n+            if (pointer <= temp_string) {       \/* Check enough room *\/\n+                i = -1;\n+                break;\n+            }\n+            *(--pointer) = (xmlChar)val;\n@@ -180,13 +182,14 @@\n-        *(--pointer) = val;\n-    }\n-    else {\n-    \/*\n-     * Here we have a multibyte character.  It's a little messy,\n-     * because until we generate the char we don't know how long\n-     * it is.  So, we generate it into the buffer temp_char, then\n-     * copy from there into temp_string.\n-     *\/\n-        len = xmlCopyCharMultiByte(temp_char, val);\n-        if ( (pointer - len) < temp_string ) {\n-            i = -1;\n-        break;\n+        else {\n+        \/*\n+         * Here we have a multibyte character.  It's a little messy,\n+         * because until we generate the char we don't know how long\n+         * it is.  So, we generate it into the buffer temp_char, then\n+         * copy from there into temp_string.\n+         *\/\n+            len = xmlCopyCharMultiByte(temp_char, val);\n+            if ( (pointer - len) < temp_string ) {\n+                i = -1;\n+                break;\n+            }\n+            pointer -= len;\n+            memcpy(pointer, temp_char, len);\n@@ -194,5 +197,2 @@\n-        pointer -= len;\n-        memcpy(pointer, temp_char, len);\n-    }\n-    number \/= 10.0;\n-    ++i;\n+        number \/= 10.0;\n+        ++i;\n@@ -202,1 +202,1 @@\n-        \"xsltNumberFormatDecimal: Internal buffer size exceeded\\n\");\n+                \"xsltNumberFormatDecimal: Internal buffer size exceeded\\n\");\n@@ -208,3 +208,3 @@\n-              xmlBufferPtr buffer,\n-              double number,\n-              int is_upper)\n+                      xmlBufferPtr buffer,\n+                      double number,\n+                      int is_upper)\n@@ -244,5 +244,5 @@\n-    number--;\n-    *(--pointer) = alpha_list[((int)fmod(number, alpha_size))];\n-    number \/= alpha_size;\n-    if (number < 1.0)\n-        break; \/* for *\/\n+        number--;\n+        *(--pointer) = alpha_list[((int)fmod(number, alpha_size))];\n+        number \/= alpha_size;\n+        if (number < 1.0)\n+            break; \/* for *\/\n@@ -255,3 +255,3 @@\n-              xmlBufferPtr buffer,\n-              double number,\n-              int is_upper)\n+                      xmlBufferPtr buffer,\n+                      double number,\n+                      int is_upper)\n@@ -275,2 +275,2 @@\n-    xmlBufferCCat(buffer, (is_upper) ? \"M\" : \"m\");\n-    number -= 1000.0;\n+        xmlBufferCCat(buffer, (is_upper) ? \"M\" : \"m\");\n+        number -= 1000.0;\n@@ -279,2 +279,2 @@\n-    xmlBufferCCat(buffer, (is_upper) ? \"CM\" : \"cm\");\n-    number -= 900.0;\n+        xmlBufferCCat(buffer, (is_upper) ? \"CM\" : \"cm\");\n+        number -= 900.0;\n@@ -283,2 +283,2 @@\n-    xmlBufferCCat(buffer, (is_upper) ? \"D\" : \"d\");\n-    number -= 500.0;\n+        xmlBufferCCat(buffer, (is_upper) ? \"D\" : \"d\");\n+        number -= 500.0;\n@@ -287,2 +287,2 @@\n-    xmlBufferCCat(buffer, (is_upper) ? \"CD\" : \"cd\");\n-    number -= 400.0;\n+        xmlBufferCCat(buffer, (is_upper) ? \"CD\" : \"cd\");\n+        number -= 400.0;\n@@ -291,2 +291,2 @@\n-    xmlBufferCCat(buffer, (is_upper) ? \"C\" : \"c\");\n-    number -= 100.0;\n+        xmlBufferCCat(buffer, (is_upper) ? \"C\" : \"c\");\n+        number -= 100.0;\n@@ -295,2 +295,2 @@\n-    xmlBufferCCat(buffer, (is_upper) ? \"XC\" : \"xc\");\n-    number -= 90.0;\n+        xmlBufferCCat(buffer, (is_upper) ? \"XC\" : \"xc\");\n+        number -= 90.0;\n@@ -299,2 +299,2 @@\n-    xmlBufferCCat(buffer, (is_upper) ? \"L\" : \"l\");\n-    number -= 50.0;\n+        xmlBufferCCat(buffer, (is_upper) ? \"L\" : \"l\");\n+        number -= 50.0;\n@@ -303,2 +303,2 @@\n-    xmlBufferCCat(buffer, (is_upper) ? \"XL\" : \"xl\");\n-    number -= 40.0;\n+        xmlBufferCCat(buffer, (is_upper) ? \"XL\" : \"xl\");\n+        number -= 40.0;\n@@ -307,2 +307,2 @@\n-    xmlBufferCCat(buffer, (is_upper) ? \"X\" : \"x\");\n-    number -= 10.0;\n+        xmlBufferCCat(buffer, (is_upper) ? \"X\" : \"x\");\n+        number -= 10.0;\n@@ -311,2 +311,2 @@\n-    xmlBufferCCat(buffer, (is_upper) ? \"IX\" : \"ix\");\n-    number -= 9.0;\n+        xmlBufferCCat(buffer, (is_upper) ? \"IX\" : \"ix\");\n+        number -= 9.0;\n@@ -315,2 +315,2 @@\n-    xmlBufferCCat(buffer, (is_upper) ? \"V\" : \"v\");\n-    number -= 5.0;\n+        xmlBufferCCat(buffer, (is_upper) ? \"V\" : \"v\");\n+        number -= 5.0;\n@@ -319,2 +319,2 @@\n-    xmlBufferCCat(buffer, (is_upper) ? \"IV\" : \"iv\");\n-    number -= 4.0;\n+        xmlBufferCCat(buffer, (is_upper) ? \"IV\" : \"iv\");\n+        number -= 4.0;\n@@ -323,2 +323,2 @@\n-    xmlBufferCCat(buffer, (is_upper) ? \"I\" : \"i\");\n-    number--;\n+        xmlBufferCCat(buffer, (is_upper) ? \"I\" : \"i\");\n+        number--;\n@@ -330,1 +330,1 @@\n-             xsltFormatPtr tokens)\n+                         xsltFormatPtr tokens)\n@@ -351,4 +351,4 @@\n-          IS_DIGIT(val)) ) {\n-    if (format[ix] == 0)        \/* if end of format string *\/\n-        break; \/* while *\/\n-    ix += len;\n+              IS_DIGIT(val)) ) {\n+        if (format[ix] == 0)            \/* if end of format string *\/\n+            break; \/* while *\/\n+        ix += len;\n@@ -357,1 +357,1 @@\n-    tokens->start = xmlStrndup(format, ix);\n+        tokens->start = xmlStrndup(format, ix);\n@@ -361,12 +361,3 @@\n-     tokens->nTokens++) {\n-    if (format[ix] == 0)\n-        break; \/* for *\/\n-\n-    \/*\n-     * separator has already been parsed (except for the first\n-     * number) in tokens->end, recover it.\n-     *\/\n-    if (tokens->nTokens > 0) {\n-        tokens->tokens[tokens->nTokens].separator = tokens->end;\n-        tokens->end = NULL;\n-    }\n+         tokens->nTokens++) {\n+        if (format[ix] == 0)\n+            break; \/* for *\/\n@@ -374,8 +365,7 @@\n-    val = xmlStringCurrentChar(NULL, format+ix, &len);\n-    if (IS_DIGIT_ONE(val) ||\n-         IS_DIGIT_ZERO(val)) {\n-        tokens->tokens[tokens->nTokens].width = 1;\n-        while (IS_DIGIT_ZERO(val)) {\n-        tokens->tokens[tokens->nTokens].width++;\n-        ix += len;\n-        val = xmlStringCurrentChar(NULL, format+ix, &len);\n+        \/*\n+         * separator has already been parsed (except for the first\n+         * number) in tokens->end, recover it.\n+         *\/\n+        if (tokens->nTokens > 0) {\n+            tokens->tokens[tokens->nTokens].separator = tokens->end;\n+            tokens->end = NULL;\n@@ -383,3 +373,1 @@\n-        if (IS_DIGIT_ONE(val)) {\n-        tokens->tokens[tokens->nTokens].token = val - 1;\n-        ix += len;\n+\n@@ -387,1 +375,13 @@\n-        } else {\n+        if (IS_DIGIT_ONE(val) ||\n+                 IS_DIGIT_ZERO(val)) {\n+            tokens->tokens[tokens->nTokens].width = 1;\n+            while (IS_DIGIT_ZERO(val)) {\n+                tokens->tokens[tokens->nTokens].width++;\n+                ix += len;\n+                val = xmlStringCurrentChar(NULL, format+ix, &len);\n+            }\n+            if (IS_DIGIT_ONE(val)) {\n+                tokens->tokens[tokens->nTokens].token = val - 1;\n+                ix += len;\n+                val = xmlStringCurrentChar(NULL, format+ix, &len);\n+            } else {\n@@ -391,13 +391,25 @@\n-    } else if ( (val == 'A') ||\n-            (val == 'a') ||\n-            (val == 'I') ||\n-            (val == 'i') ) {\n-        tokens->tokens[tokens->nTokens].token = val;\n-        ix += len;\n-        val = xmlStringCurrentChar(NULL, format+ix, &len);\n-    } else {\n-        \/* XSLT section 7.7\n-         * \"Any other format token indicates a numbering sequence\n-         *  that starts with that token. If an implementation does\n-         *  not support a numbering sequence that starts with that\n-         *  token, it must use a format token of 1.\"\n+        } else if ( (val == 'A') ||\n+                    (val == 'a') ||\n+                    (val == 'I') ||\n+                    (val == 'i') ) {\n+            tokens->tokens[tokens->nTokens].token = val;\n+            ix += len;\n+            val = xmlStringCurrentChar(NULL, format+ix, &len);\n+        } else {\n+            \/* XSLT section 7.7\n+             * \"Any other format token indicates a numbering sequence\n+             *  that starts with that token. If an implementation does\n+             *  not support a numbering sequence that starts with that\n+             *  token, it must use a format token of 1.\"\n+             *\/\n+            tokens->tokens[tokens->nTokens].token = '0';\n+            tokens->tokens[tokens->nTokens].width = 1;\n+        }\n+        \/*\n+         * Skip over remaining alphanumeric characters from the Nd\n+         * (Number, decimal digit), Nl (Number, letter), No (Number,\n+         * other), Lu (Letter, uppercase), Ll (Letter, lowercase), Lt\n+         * (Letters, titlecase), Lm (Letters, modifiers), and Lo\n+         * (Letters, other (uncased)) Unicode categories. This happens\n+         * to correspond to the Letter and Digit classes from XML (and\n+         * one wonders why XSLT doesn't refer to these instead).\n@@ -405,16 +417,4 @@\n-        tokens->tokens[tokens->nTokens].token = '0';\n-        tokens->tokens[tokens->nTokens].width = 1;\n-    }\n-    \/*\n-     * Skip over remaining alphanumeric characters from the Nd\n-     * (Number, decimal digit), Nl (Number, letter), No (Number,\n-     * other), Lu (Letter, uppercase), Ll (Letter, lowercase), Lt\n-     * (Letters, titlecase), Lm (Letters, modifiers), and Lo\n-     * (Letters, other (uncased)) Unicode categories. This happens\n-     * to correspond to the Letter and Digit classes from XML (and\n-     * one wonders why XSLT doesn't refer to these instead).\n-     *\/\n-    while (IS_LETTER(val) || IS_DIGIT(val)) {\n-        ix += len;\n-        val = xmlStringCurrentChar(NULL, format+ix, &len);\n-    }\n+        while (IS_LETTER(val) || IS_DIGIT(val)) {\n+            ix += len;\n+            val = xmlStringCurrentChar(NULL, format+ix, &len);\n+        }\n@@ -422,12 +422,12 @@\n-    \/*\n-     * Insert temporary non-alphanumeric final tooken.\n-     *\/\n-    j = ix;\n-    while (! (IS_LETTER(val) || IS_DIGIT(val))) {\n-        if (val == 0)\n-        break; \/* while *\/\n-        ix += len;\n-        val = xmlStringCurrentChar(NULL, format+ix, &len);\n-    }\n-    if (ix > j)\n-        tokens->end = xmlStrndup(&format[j], ix - j);\n+        \/*\n+         * Insert temporary non-alphanumeric final tooken.\n+         *\/\n+        j = ix;\n+        while (! (IS_LETTER(val) || IS_DIGIT(val))) {\n+            if (val == 0)\n+                break; \/* while *\/\n+            ix += len;\n+            val = xmlStringCurrentChar(NULL, format+ix, &len);\n+        }\n+        if (ix > j)\n+            tokens->end = xmlStrndup(&format[j], ix - j);\n@@ -439,4 +439,4 @@\n-                  double *numbers,\n-                  int numbers_max,\n-                  xsltFormatPtr tokens,\n-                  xmlBufferPtr buffer)\n+                              double *numbers,\n+                              int numbers_max,\n+                              xsltFormatPtr tokens,\n+                              xmlBufferPtr buffer)\n@@ -452,1 +452,1 @@\n-     xmlBufferCat(buffer, tokens->start);\n+         xmlBufferCat(buffer, tokens->start);\n@@ -455,2 +455,2 @@\n-    \/* Insert number *\/\n-    number = numbers[(numbers_max - 1) - i];\n+        \/* Insert number *\/\n+        number = numbers[(numbers_max - 1) - i];\n@@ -474,39 +474,13 @@\n-    if (i < tokens->nTokens) {\n-      \/*\n-       * The \"n\"th format token will be used to format the \"n\"th\n-       * number in the list\n-       *\/\n-      token = &(tokens->tokens[i]);\n-    } else if (tokens->nTokens > 0) {\n-      \/*\n-       * If there are more numbers than format tokens, then the\n-       * last format token will be used to format the remaining\n-       * numbers.\n-       *\/\n-      token = &(tokens->tokens[tokens->nTokens - 1]);\n-    } else {\n-      \/*\n-       * If there are no format tokens, then a format token of\n-       * 1 is used to format all numbers.\n-       *\/\n-      token = &default_token;\n-    }\n-\n-    \/* Print separator, except for the first number *\/\n-    if (i > 0) {\n-        if (token->separator != NULL)\n-        xmlBufferCat(buffer, token->separator);\n-        else\n-        xmlBufferCCat(buffer, DEFAULT_SEPARATOR);\n-    }\n-\n-    switch (xmlXPathIsInf(number)) {\n-    case -1:\n-        xmlBufferCCat(buffer, \"-Infinity\");\n-        break;\n-    case 1:\n-        xmlBufferCCat(buffer, \"Infinity\");\n-        break;\n-    default:\n-        if (xmlXPathIsNaN(number)) {\n-        xmlBufferCCat(buffer, \"NaN\");\n+        if (i < tokens->nTokens) {\n+          \/*\n+           * The \"n\"th format token will be used to format the \"n\"th\n+           * number in the list\n+           *\/\n+          token = &(tokens->tokens[i]);\n+        } else if (tokens->nTokens > 0) {\n+          \/*\n+           * If there are more numbers than format tokens, then the\n+           * last format token will be used to format the remaining\n+           * numbers.\n+           *\/\n+          token = &(tokens->tokens[tokens->nTokens - 1]);\n@@ -514,0 +488,6 @@\n+          \/*\n+           * If there are no format tokens, then a format token of\n+           * 1 is used to format all numbers.\n+           *\/\n+          token = &default_token;\n+        }\n@@ -515,9 +495,11 @@\n-        switch (token->token) {\n-        case 'A':\n-            xsltNumberFormatAlpha(data, buffer, number, TRUE);\n-            break;\n-        case 'a':\n-            xsltNumberFormatAlpha(data, buffer, number, FALSE);\n-            break;\n-        case 'I':\n-            xsltNumberFormatRoman(data, buffer, number, TRUE);\n+        \/* Print separator, except for the first number *\/\n+        if (i > 0) {\n+            if (token->separator != NULL)\n+                xmlBufferCat(buffer, token->separator);\n+            else\n+                xmlBufferCCat(buffer, DEFAULT_SEPARATOR);\n+        }\n+\n+        switch (xmlXPathIsInf(number)) {\n+        case -1:\n+            xmlBufferCCat(buffer, \"-Infinity\");\n@@ -525,2 +507,2 @@\n-        case 'i':\n-            xsltNumberFormatRoman(data, buffer, number, FALSE);\n+        case 1:\n+            xmlBufferCCat(buffer, \"Infinity\");\n@@ -529,8 +511,29 @@\n-            if (IS_DIGIT_ZERO(token->token)) {\n-            xsltNumberFormatDecimal(buffer,\n-                        number,\n-                        token->token,\n-                        token->width,\n-                        data->digitsPerGroup,\n-                        data->groupingCharacter,\n-                        data->groupingCharacterLen);\n+            if (xmlXPathIsNaN(number)) {\n+                xmlBufferCCat(buffer, \"NaN\");\n+            } else {\n+\n+                switch (token->token) {\n+                case 'A':\n+                    xsltNumberFormatAlpha(data, buffer, number, TRUE);\n+                    break;\n+                case 'a':\n+                    xsltNumberFormatAlpha(data, buffer, number, FALSE);\n+                    break;\n+                case 'I':\n+                    xsltNumberFormatRoman(data, buffer, number, TRUE);\n+                    break;\n+                case 'i':\n+                    xsltNumberFormatRoman(data, buffer, number, FALSE);\n+                    break;\n+                default:\n+                    if (IS_DIGIT_ZERO(token->token)) {\n+                        xsltNumberFormatDecimal(buffer,\n+                                                number,\n+                                                token->token,\n+                                                token->width,\n+                                                data->digitsPerGroup,\n+                                                data->groupingCharacter,\n+                                                data->groupingCharacterLen);\n+                    }\n+                    break;\n+                }\n@@ -538,3 +541,0 @@\n-            break;\n-        }\n-        }\n@@ -542,1 +542,1 @@\n-    }\n+        }\n@@ -549,1 +549,1 @@\n-     xmlBufferCat(buffer, tokens->end);\n+         xmlBufferCat(buffer, tokens->end);\n@@ -592,4 +592,4 @@\n-                xmlNodePtr node,\n-                xsltCompMatchPtr countPat,\n-                xsltCompMatchPtr fromPat,\n-                double *array)\n+                            xmlNodePtr node,\n+                            xsltCompMatchPtr countPat,\n+                            xsltCompMatchPtr fromPat,\n+                            double *array)\n@@ -602,7 +602,7 @@\n-    \/* process current node *\/\n-    if (xsltTestCompMatchCount(context, cur, countPat, node))\n-        cnt++;\n-    if ((fromPat != NULL) &&\n-        xsltTestCompMatchList(context, cur, fromPat)) {\n-        break; \/* while *\/\n-    }\n+        \/* process current node *\/\n+        if (xsltTestCompMatchCount(context, cur, countPat, node))\n+            cnt++;\n+        if ((fromPat != NULL) &&\n+            xsltTestCompMatchList(context, cur, fromPat)) {\n+            break; \/* while *\/\n+        }\n@@ -610,2 +610,2 @@\n-    \/* Skip to next preceding or ancestor *\/\n-    if ((cur->type == XML_DOCUMENT_NODE) ||\n+        \/* Skip to next preceding or ancestor *\/\n+        if ((cur->type == XML_DOCUMENT_NODE) ||\n@@ -616,1 +616,1 @@\n-        break; \/* while *\/\n+            break; \/* while *\/\n@@ -646,5 +646,5 @@\n-                 xmlNodePtr node,\n-                 xsltCompMatchPtr countPat,\n-                 xsltCompMatchPtr fromPat,\n-                 double *array,\n-                 int max)\n+                                 xmlNodePtr node,\n+                                 xsltCompMatchPtr countPat,\n+                                 xsltCompMatchPtr fromPat,\n+                                 double *array,\n+                                 int max)\n@@ -662,6 +662,6 @@\n-    \/* ancestor-or-self::*[count] *\/\n-    ancestor = node;\n-    while ((ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE)) {\n-        if ((fromPat != NULL) &&\n-        xsltTestCompMatchList(context, ancestor, fromPat))\n-        break; \/* for *\/\n+        \/* ancestor-or-self::*[count] *\/\n+        ancestor = node;\n+        while ((ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE)) {\n+            if ((fromPat != NULL) &&\n+                xsltTestCompMatchList(context, ancestor, fromPat))\n+                break; \/* for *\/\n@@ -676,3 +676,3 @@\n-        if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {\n-        \/* count(preceding-sibling::*) *\/\n-        cnt = 1;\n+            if (xsltTestCompMatchCount(context, ancestor, countPat, node)) {\n+                \/* count(preceding-sibling::*) *\/\n+                cnt = 1;\n@@ -682,1 +682,1 @@\n-                if (xsltTestCompMatchCount(context, preceding, countPat,\n+                    if (xsltTestCompMatchCount(context, preceding, countPat,\n@@ -684,1 +684,1 @@\n-            cnt++;\n+                        cnt++;\n@@ -688,5 +688,5 @@\n-        }\n-        array[amount++] = (double)cnt;\n-        if (amount >= max)\n-            break; \/* for *\/\n-        }\n+                }\n+                array[amount++] = (double)cnt;\n+                if (amount >= max)\n+                    break; \/* for *\/\n+            }\n@@ -695,2 +695,2 @@\n-    }\n-    xmlXPathFreeParserContext(parser);\n+        }\n+        xmlXPathFreeParserContext(parser);\n@@ -704,3 +704,3 @@\n-             xmlNodePtr node,\n-             const xmlChar *value,\n-             double *number)\n+                         xmlNodePtr node,\n+                         const xmlChar *value,\n+                         double *number)\n@@ -714,12 +714,12 @@\n-    xmlBufferCCat(pattern, \"number(\");\n-    xmlBufferCat(pattern, value);\n-    xmlBufferCCat(pattern, \")\");\n-    context->node = node;\n-    obj = xmlXPathEvalExpression(xmlBufferContent(pattern),\n-                     context);\n-    if (obj != NULL) {\n-        *number = obj->floatval;\n-        amount++;\n-        xmlXPathFreeObject(obj);\n-    }\n-    xmlBufferFree(pattern);\n+        xmlBufferCCat(pattern, \"number(\");\n+        xmlBufferCat(pattern, value);\n+        xmlBufferCCat(pattern, \")\");\n+        context->node = node;\n+        obj = xmlXPathEvalExpression(xmlBufferContent(pattern),\n+                                     context);\n+        if (obj != NULL) {\n+            *number = obj->floatval;\n+            amount++;\n+            xmlXPathFreeObject(obj);\n+        }\n+        xmlBufferFree(pattern);\n@@ -740,2 +740,2 @@\n-         xsltNumberDataPtr data,\n-         xmlNodePtr node)\n+                 xsltNumberDataPtr data,\n+                 xmlNodePtr node)\n@@ -754,1 +754,1 @@\n-    \/* The format needs to be recomputed each time *\/\n+        \/* The format needs to be recomputed each time *\/\n@@ -757,3 +757,3 @@\n-    format = xsltEvalAttrValueTemplate(ctxt, data->node,\n-                         (const xmlChar *) \"format\",\n-                         XSLT_NAMESPACE);\n+        format = xsltEvalAttrValueTemplate(ctxt, data->node,\n+                                             (const xmlChar *) \"format\",\n+                                             XSLT_NAMESPACE);\n@@ -763,1 +763,1 @@\n-    xmlFree(format);\n+        xmlFree(format);\n@@ -768,1 +768,1 @@\n-    goto XSLT_NUMBER_FORMAT_END;\n+        goto XSLT_NUMBER_FORMAT_END;\n@@ -774,11 +774,11 @@\n-    amount = xsltNumberFormatGetValue(ctxt->xpathCtxt,\n-                      node,\n-                      data->value,\n-                      &number);\n-    if (amount == 1) {\n-        xsltNumberFormatInsertNumbers(data,\n-                      &number,\n-                      1,\n-                      &tokens,\n-                      output);\n-    }\n+        amount = xsltNumberFormatGetValue(ctxt->xpathCtxt,\n+                                          node,\n+                                          data->value,\n+                                          &number);\n+        if (amount == 1) {\n+            xsltNumberFormatInsertNumbers(data,\n+                                          &number,\n+                                          1,\n+                                          &tokens,\n+                                          output);\n+        }\n@@ -788,42 +788,43 @@\n-    if (xmlStrEqual(data->level, (const xmlChar *) \"single\")) {\n-        amount = xsltNumberFormatGetMultipleLevel(ctxt,\n-                              node,\n-                              data->countPat,\n-                              data->fromPat,\n-                              &number,\n-                              1);\n-        if (amount == 1) {\n-        xsltNumberFormatInsertNumbers(data,\n-                          &number,\n-                          1,\n-                          &tokens,\n-                          output);\n-        }\n-    } else if (xmlStrEqual(data->level, (const xmlChar *) \"multiple\")) {\n-        double numarray[1024];\n-        int max = sizeof(numarray)\/sizeof(numarray[0]);\n-        amount = xsltNumberFormatGetMultipleLevel(ctxt,\n-                              node,\n-                              data->countPat,\n-                              data->fromPat,\n-                              numarray,\n-                              max);\n-        if (amount > 0) {\n-        xsltNumberFormatInsertNumbers(data,\n-                          numarray,\n-                          amount,\n-                          &tokens,\n-                          output);\n-        }\n-    } else if (xmlStrEqual(data->level, (const xmlChar *) \"any\")) {\n-        amount = xsltNumberFormatGetAnyLevel(ctxt,\n-                         node,\n-                         data->countPat,\n-                         data->fromPat,\n-                         &number);\n-        if (amount > 0) {\n-        xsltNumberFormatInsertNumbers(data,\n-                          &number,\n-                          1,\n-                          &tokens,\n-                          output);\n+        if (xmlStrEqual(data->level, (const xmlChar *) \"single\")) {\n+            amount = xsltNumberFormatGetMultipleLevel(ctxt,\n+                                                      node,\n+                                                      data->countPat,\n+                                                      data->fromPat,\n+                                                      &number,\n+                                                      1);\n+            if (amount == 1) {\n+                xsltNumberFormatInsertNumbers(data,\n+                                              &number,\n+                                              1,\n+                                              &tokens,\n+                                              output);\n+            }\n+        } else if (xmlStrEqual(data->level, (const xmlChar *) \"multiple\")) {\n+            double numarray[1024];\n+            int max = sizeof(numarray)\/sizeof(numarray[0]);\n+            amount = xsltNumberFormatGetMultipleLevel(ctxt,\n+                                                      node,\n+                                                      data->countPat,\n+                                                      data->fromPat,\n+                                                      numarray,\n+                                                      max);\n+            if (amount > 0) {\n+                xsltNumberFormatInsertNumbers(data,\n+                                              numarray,\n+                                              amount,\n+                                              &tokens,\n+                                              output);\n+            }\n+        } else if (xmlStrEqual(data->level, (const xmlChar *) \"any\")) {\n+            amount = xsltNumberFormatGetAnyLevel(ctxt,\n+                                                 node,\n+                                                 data->countPat,\n+                                                 data->fromPat,\n+                                                 &number);\n+            if (amount > 0) {\n+                xsltNumberFormatInsertNumbers(data,\n+                                              &number,\n+                                              1,\n+                                              &tokens,\n+                                              output);\n+            }\n@@ -831,1 +832,0 @@\n-    }\n@@ -850,1 +850,1 @@\n-    xmlFree(tokens.start);\n+        xmlFree(tokens.start);\n@@ -852,1 +852,1 @@\n-    xmlFree(tokens.end);\n+        xmlFree(tokens.end);\n@@ -854,2 +854,2 @@\n-    if (tokens.tokens[i].separator != NULL)\n-        xmlFree(tokens.tokens[i].separator);\n+        if (tokens.tokens[i].separator != NULL)\n+            xmlFree(tokens.tokens[i].separator);\n@@ -867,18 +867,0 @@\n-    \/*\n-     * prefix \/ suffix ends at end of string or at\n-     * first 'special' character\n-     *\/\n-    if (**format == 0)\n-        return count;\n-    \/* if next character 'escaped' just count it *\/\n-    if (**format == SYMBOL_QUOTE) {\n-        if (*++(*format) == 0)\n-        return -1;\n-    }\n-    else if (IS_SPECIAL(self, *format))\n-        return count;\n-    \/*\n-     * else treat percent\/per-mille as special cases,\n-     * depending on whether +ve or -ve\n-     *\/\n-    else {\n@@ -886,2 +868,2 @@\n-         * for +ve prefix\/suffix, allow only a\n-         * single occurence of either\n+         * prefix \/ suffix ends at end of string or at\n+         * first 'special' character\n@@ -889,10 +871,29 @@\n-        if (xsltUTF8Charcmp(*format, self->percent) == 0) {\n-        if (info->is_multiplier_set)\n-            return -1;\n-        info->multiplier = 100;\n-        info->is_multiplier_set = TRUE;\n-        } else if (xsltUTF8Charcmp(*format, self->permille) == 0) {\n-        if (info->is_multiplier_set)\n-            return -1;\n-        info->multiplier = 1000;\n-        info->is_multiplier_set = TRUE;\n+        if (**format == 0)\n+            return count;\n+        \/* if next character 'escaped' just count it *\/\n+        if (**format == SYMBOL_QUOTE) {\n+            if (*++(*format) == 0)\n+                return -1;\n+        }\n+        else if (IS_SPECIAL(self, *format))\n+            return count;\n+        \/*\n+         * else treat percent\/per-mille as special cases,\n+         * depending on whether +ve or -ve\n+         *\/\n+        else {\n+            \/*\n+             * for +ve prefix\/suffix, allow only a\n+             * single occurence of either\n+             *\/\n+            if (xsltUTF8Charcmp(*format, self->percent) == 0) {\n+                if (info->is_multiplier_set)\n+                    return -1;\n+                info->multiplier = 100;\n+                info->is_multiplier_set = TRUE;\n+            } else if (xsltUTF8Charcmp(*format, self->permille) == 0) {\n+                if (info->is_multiplier_set)\n+                    return -1;\n+                info->multiplier = 1000;\n+                info->is_multiplier_set = TRUE;\n+            }\n@@ -900,1 +901,0 @@\n-    }\n@@ -902,4 +902,4 @@\n-    if ((len=xmlUTF8Strsize(*format, 1)) < 1)\n-        return -1;\n-    count += len;\n-    *format += len;\n+        if ((len=xmlUTF8Strsize(*format, 1)) < 1)\n+            return -1;\n+        count += len;\n+        *format += len;\n@@ -953,3 +953,3 @@\n-               xmlChar *format,\n-               double number,\n-               xmlChar **result)\n+                           xmlChar *format,\n+                           double number,\n+                           xmlChar **result)\n@@ -963,1 +963,1 @@\n-    int     j, len;\n+    int     j, len = 0;\n@@ -970,1 +970,1 @@\n-    int     delayed_multiplier = 0;\n+    int         delayed_multiplier = 0;\n@@ -972,1 +972,1 @@\n-    char    default_sign = 0;\n+    char        default_sign = 0;\n@@ -974,1 +974,1 @@\n-    char    found_error = 0;\n+    char        found_error = 0;\n@@ -977,1 +977,1 @@\n-    xsltTransformError(NULL, NULL, NULL,\n+        xsltTransformError(NULL, NULL, NULL,\n@@ -979,1 +979,1 @@\n-        \"Invalid format (0-length)\\n\");\n+                \"Invalid format (0-length)\\n\");\n@@ -983,20 +983,20 @@\n-    case -1:\n-        if (self->minusSign == NULL)\n-        *result = xmlStrdup(BAD_CAST \"-\");\n-        else\n-        *result = xmlStrdup(self->minusSign);\n-        \/* Intentional fall-through *\/\n-    case 1:\n-        if ((self == NULL) || (self->infinity == NULL))\n-        *result = xmlStrcat(*result, BAD_CAST \"Infinity\");\n-        else\n-        *result = xmlStrcat(*result, self->infinity);\n-        return(status);\n-    default:\n-        if (xmlXPathIsNaN(number)) {\n-        if ((self == NULL) || (self->noNumber == NULL))\n-            *result = xmlStrdup(BAD_CAST \"NaN\");\n-        else\n-            *result = xmlStrdup(self->noNumber);\n-        return(status);\n-        }\n+        case -1:\n+            if (self->minusSign == NULL)\n+                *result = xmlStrdup(BAD_CAST \"-\");\n+            else\n+                *result = xmlStrdup(self->minusSign);\n+            \/* Intentional fall-through *\/\n+        case 1:\n+            if ((self == NULL) || (self->infinity == NULL))\n+                *result = xmlStrcat(*result, BAD_CAST \"Infinity\");\n+            else\n+                *result = xmlStrcat(*result, self->infinity);\n+            return(status);\n+        default:\n+            if (xmlXPathIsNaN(number)) {\n+                if ((self == NULL) || (self->noNumber == NULL))\n+                    *result = xmlStrdup(BAD_CAST \"NaN\");\n+                else\n+                    *result = xmlStrdup(self->noNumber);\n+                return(status);\n+            }\n@@ -1007,1 +1007,1 @@\n-    return XPATH_MEMORY_ERROR;\n+        return XPATH_MEMORY_ERROR;\n@@ -1029,2 +1029,2 @@\n-    found_error = 1;\n-    goto OUTPUT_NUMBER;\n+        found_error = 1;\n+        goto OUTPUT_NUMBER;\n@@ -1042,2 +1042,2 @@\n-       (xsltUTF8Charcmp(the_format, self->decimalPoint) != 0) &&\n-       (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) {\n+           (xsltUTF8Charcmp(the_format, self->decimalPoint) != 0) &&\n+           (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) {\n@@ -1045,33 +1045,4 @@\n-    if (delayed_multiplier != 0) {\n-        format_info.multiplier = delayed_multiplier;\n-        format_info.is_multiplier_set = TRUE;\n-        delayed_multiplier = 0;\n-    }\n-    if (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n-        if (format_info.integer_digits > 0) {\n-        found_error = 1;\n-        goto OUTPUT_NUMBER;\n-        }\n-        format_info.integer_hash++;\n-        if (format_info.group >= 0)\n-        format_info.group++;\n-    } else if (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n-        format_info.integer_digits++;\n-        if (format_info.group >= 0)\n-        format_info.group++;\n-    } else if ((self_grouping_len > 0) &&\n-        (!xmlStrncmp(the_format, self->grouping, self_grouping_len))) {\n-        \/* Reset group count *\/\n-        format_info.group = 0;\n-        the_format += self_grouping_len;\n-        continue;\n-    } else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n-        if (format_info.is_multiplier_set) {\n-        found_error = 1;\n-        goto OUTPUT_NUMBER;\n-        }\n-        delayed_multiplier = 100;\n-    } else  if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n-        if (format_info.is_multiplier_set) {\n-        found_error = 1;\n-        goto OUTPUT_NUMBER;\n+        if (delayed_multiplier != 0) {\n+            format_info.multiplier = delayed_multiplier;\n+            format_info.is_multiplier_set = TRUE;\n+            delayed_multiplier = 0;\n@@ -1079,3 +1050,32 @@\n-        delayed_multiplier = 1000;\n-    } else\n-        break; \/* while *\/\n+        if (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n+            if (format_info.integer_digits > 0) {\n+                found_error = 1;\n+                goto OUTPUT_NUMBER;\n+            }\n+            format_info.integer_hash++;\n+            if (format_info.group >= 0)\n+                format_info.group++;\n+        } else if (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n+            format_info.integer_digits++;\n+            if (format_info.group >= 0)\n+                format_info.group++;\n+        } else if ((self_grouping_len > 0) &&\n+            (!xmlStrncmp(the_format, self->grouping, self_grouping_len))) {\n+            \/* Reset group count *\/\n+            format_info.group = 0;\n+            the_format += self_grouping_len;\n+            continue;\n+        } else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n+            if (format_info.is_multiplier_set) {\n+                found_error = 1;\n+                goto OUTPUT_NUMBER;\n+            }\n+            delayed_multiplier = 100;\n+        } else  if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n+            if (format_info.is_multiplier_set) {\n+                found_error = 1;\n+                goto OUTPUT_NUMBER;\n+            }\n+            delayed_multiplier = 1000;\n+        } else\n+            break; \/* while *\/\n@@ -1083,5 +1083,5 @@\n-    if ((len=xmlUTF8Strsize(the_format, 1)) < 1) {\n-        found_error = 1;\n-        goto OUTPUT_NUMBER;\n-    }\n-    the_format += len;\n+        if ((len=xmlUTF8Strsize(the_format, 1)) < 1) {\n+            found_error = 1;\n+            goto OUTPUT_NUMBER;\n+        }\n+        the_format += len;\n@@ -1099,1 +1099,1 @@\n-    the_format += len;  \/* Skip over the decimal *\/\n+        the_format += len;      \/* Skip over the decimal *\/\n@@ -1104,12 +1104,34 @@\n-    if (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n-        if (format_info.frac_hash != 0) {\n-        found_error = 1;\n-        goto OUTPUT_NUMBER;\n-        }\n-        format_info.frac_digits++;\n-    } else if (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n-        format_info.frac_hash++;\n-    } else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n-        if (format_info.is_multiplier_set) {\n-        found_error = 1;\n-        goto OUTPUT_NUMBER;\n+        if (xsltUTF8Charcmp(the_format, self->zeroDigit) == 0) {\n+            if (format_info.frac_hash != 0) {\n+                found_error = 1;\n+                goto OUTPUT_NUMBER;\n+            }\n+            format_info.frac_digits++;\n+        } else if (xsltUTF8Charcmp(the_format, self->digit) == 0) {\n+            format_info.frac_hash++;\n+        } else if (xsltUTF8Charcmp(the_format, self->percent) == 0) {\n+            if (format_info.is_multiplier_set) {\n+                found_error = 1;\n+                goto OUTPUT_NUMBER;\n+            }\n+            delayed_multiplier = 100;\n+            if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n+                found_error = 1;\n+                goto OUTPUT_NUMBER;\n+            }\n+            the_format += len;\n+            continue; \/* while *\/\n+        } else if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n+            if (format_info.is_multiplier_set) {\n+                found_error = 1;\n+                goto OUTPUT_NUMBER;\n+            }\n+            delayed_multiplier = 1000;\n+            if  ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n+                found_error = 1;\n+                goto OUTPUT_NUMBER;\n+            }\n+            the_format += len;\n+            continue; \/* while *\/\n+        } else if (xsltUTF8Charcmp(the_format, self->grouping) != 0) {\n+            break; \/* while *\/\n@@ -1117,1 +1139,0 @@\n-        delayed_multiplier = 100;\n@@ -1120,1 +1141,1 @@\n-        goto OUTPUT_NUMBER;\n+            goto OUTPUT_NUMBER;\n@@ -1123,10 +1144,4 @@\n-        continue; \/* while *\/\n-    } else if (xsltUTF8Charcmp(the_format, self->permille) == 0) {\n-        if (format_info.is_multiplier_set) {\n-        found_error = 1;\n-        goto OUTPUT_NUMBER;\n-        }\n-        delayed_multiplier = 1000;\n-        if  ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n-            found_error = 1;\n-        goto OUTPUT_NUMBER;\n+        if (delayed_multiplier != 0) {\n+            format_info.multiplier = delayed_multiplier;\n+            delayed_multiplier = 0;\n+            format_info.is_multiplier_set = TRUE;\n@@ -1134,15 +1149,0 @@\n-        the_format += len;\n-        continue; \/* while *\/\n-    } else if (xsltUTF8Charcmp(the_format, self->grouping) != 0) {\n-        break; \/* while *\/\n-    }\n-    if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n-        found_error = 1;\n-        goto OUTPUT_NUMBER;\n-    }\n-    the_format += len;\n-    if (delayed_multiplier != 0) {\n-        format_info.multiplier = delayed_multiplier;\n-        delayed_multiplier = 0;\n-        format_info.is_multiplier_set = TRUE;\n-    }\n@@ -1156,2 +1156,2 @@\n-    the_format -= len;\n-    delayed_multiplier = 0;\n+        the_format -= len;\n+        delayed_multiplier = 0;\n@@ -1163,4 +1163,4 @@\n-     ((*the_format != 0) &&\n-      (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) ) {\n-    found_error = 1;\n-    goto OUTPUT_NUMBER;\n+         ((*the_format != 0) &&\n+          (xsltUTF8Charcmp(the_format, self->patternSeparator) != 0)) ) {\n+        found_error = 1;\n+        goto OUTPUT_NUMBER;\n@@ -1175,14 +1175,2 @@\n-     * Note that j is the number of UTF8 chars before the separator,\n-     * not the number of bytes! (bug 151975)\n-     *\/\n-        j =  xmlUTF8Strloc(format, self->patternSeparator);\n-    if (j < 0) {\n-    \/* No -ve pattern present, so use default signing *\/\n-        default_sign = 1;\n-    }\n-    else {\n-        \/* Skip over pattern separator (accounting for UTF8) *\/\n-        the_format = (xmlChar *)xmlUTF8Strpos(format, j + 1);\n-        \/*\n-         * Flag changes interpretation of percent\/permille\n-         * in -ve pattern\n+         * Note that j is the number of UTF8 chars before the separator,\n+         * not the number of bytes! (bug 151975)\n@@ -1190,10 +1178,4 @@\n-        format_info.is_negative_pattern = TRUE;\n-        format_info.is_multiplier_set = FALSE;\n-\n-        \/* First do the -ve prefix *\/\n-        nprefix = the_format;\n-        nprefix_length = xsltFormatNumberPreSuffix(self,\n-                    &the_format, &format_info);\n-        if (nprefix_length<0) {\n-        found_error = 1;\n-        goto OUTPUT_NUMBER;\n+        j =  xmlUTF8Strloc(format, self->patternSeparator);\n+        if (j < 0) {\n+        \/* No -ve pattern present, so use default signing *\/\n+            default_sign = 1;\n@@ -1201,0 +1183,18 @@\n+        else {\n+            \/* Skip over pattern separator (accounting for UTF8) *\/\n+            the_format = (xmlChar *)xmlUTF8Strpos(format, j + 1);\n+            \/*\n+             * Flag changes interpretation of percent\/permille\n+             * in -ve pattern\n+             *\/\n+            format_info.is_negative_pattern = TRUE;\n+            format_info.is_multiplier_set = FALSE;\n+\n+            \/* First do the -ve prefix *\/\n+            nprefix = the_format;\n+            nprefix_length = xsltFormatNumberPreSuffix(self,\n+                                        &the_format, &format_info);\n+            if (nprefix_length<0) {\n+                found_error = 1;\n+                goto OUTPUT_NUMBER;\n+            }\n@@ -1202,6 +1202,23 @@\n-        while (*the_format != 0) {\n-        if ( (xsltUTF8Charcmp(the_format, (self)->percent) == 0) ||\n-             (xsltUTF8Charcmp(the_format, (self)->permille)== 0) ) {\n-            if (format_info.is_multiplier_set) {\n-            found_error = 1;\n-            goto OUTPUT_NUMBER;\n+            while (*the_format != 0) {\n+                if ( (xsltUTF8Charcmp(the_format, (self)->percent) == 0) ||\n+                     (xsltUTF8Charcmp(the_format, (self)->permille)== 0) ) {\n+                    if (format_info.is_multiplier_set) {\n+                        found_error = 1;\n+                        goto OUTPUT_NUMBER;\n+                    }\n+                    format_info.is_multiplier_set = TRUE;\n+                    delayed_multiplier = 1;\n+                }\n+                else if (IS_SPECIAL(self, the_format))\n+                    delayed_multiplier = 0;\n+                else\n+                    break; \/* while *\/\n+                if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n+                    found_error = 1;\n+                    goto OUTPUT_NUMBER;\n+                }\n+                the_format += len;\n+            }\n+            if (delayed_multiplier != 0) {\n+                format_info.is_multiplier_set = FALSE;\n+                the_format -= len;\n@@ -1209,17 +1226,0 @@\n-            format_info.is_multiplier_set = TRUE;\n-            delayed_multiplier = 1;\n-        }\n-        else if (IS_SPECIAL(self, the_format))\n-            delayed_multiplier = 0;\n-        else\n-            break; \/* while *\/\n-        if ((len = xmlUTF8Strsize(the_format, 1)) < 1) {\n-            found_error = 1;\n-            goto OUTPUT_NUMBER;\n-        }\n-        the_format += len;\n-        }\n-        if (delayed_multiplier != 0) {\n-        format_info.is_multiplier_set = FALSE;\n-        the_format -= len;\n-        }\n@@ -1227,32 +1227,34 @@\n-        \/* Finally do the -ve suffix *\/\n-        if (*the_format != 0) {\n-        nsuffix = the_format;\n-        nsuffix_length = xsltFormatNumberPreSuffix(self,\n-                    &the_format, &format_info);\n-        if (nsuffix_length < 0) {\n-            found_error = 1;\n-            goto OUTPUT_NUMBER;\n-        }\n-        }\n-        else\n-        nsuffix_length = 0;\n-        if (*the_format != 0) {\n-        found_error = 1;\n-        goto OUTPUT_NUMBER;\n-        }\n-        \/*\n-         * Here's another Java peculiarity:\n-         * if -ve prefix\/suffix == +ve ones, discard & use default\n-         *\/\n-        if ((nprefix_length != prefix_length) ||\n-        (nsuffix_length != suffix_length) ||\n-        ((nprefix_length > 0) &&\n-         (xmlStrncmp(nprefix, prefix, prefix_length) !=0 )) ||\n-        ((nsuffix_length > 0) &&\n-         (xmlStrncmp(nsuffix, suffix, suffix_length) !=0 ))) {\n-        prefix = nprefix;\n-        prefix_length = nprefix_length;\n-        suffix = nsuffix;\n-        suffix_length = nsuffix_length;\n-        } \/* else {\n-        default_sign = 1;\n+            \/* Finally do the -ve suffix *\/\n+            if (*the_format != 0) {\n+                nsuffix = the_format;\n+                nsuffix_length = xsltFormatNumberPreSuffix(self,\n+                                        &the_format, &format_info);\n+                if (nsuffix_length < 0) {\n+                    found_error = 1;\n+                    goto OUTPUT_NUMBER;\n+                }\n+            }\n+            else\n+                nsuffix_length = 0;\n+            if (*the_format != 0) {\n+                found_error = 1;\n+                goto OUTPUT_NUMBER;\n+            }\n+            \/*\n+             * Here's another Java peculiarity:\n+             * if -ve prefix\/suffix == +ve ones, discard & use default\n+             *\/\n+            if ((nprefix_length != prefix_length) ||\n+                (nsuffix_length != suffix_length) ||\n+                ((nprefix_length > 0) &&\n+                 (xmlStrncmp(nprefix, prefix, prefix_length) !=0 )) ||\n+                ((nsuffix_length > 0) &&\n+                 (xmlStrncmp(nsuffix, suffix, suffix_length) !=0 ))) {\n+                prefix = nprefix;\n+                prefix_length = nprefix_length;\n+                suffix = nsuffix;\n+                suffix_length = nsuffix_length;\n+            } \/* else {\n+                default_sign = 1;\n+            }\n+            *\/\n@@ -1260,2 +1262,0 @@\n-        *\/\n-    }\n@@ -1266,1 +1266,1 @@\n-    xsltTransformError(NULL, NULL, NULL,\n+        xsltTransformError(NULL, NULL, NULL,\n@@ -1268,10 +1268,10 @@\n-        \"error in format string '%s', using default\\n\", format);\n-    default_sign = (number < 0.0) ? 1 : 0;\n-    prefix_length = suffix_length = 0;\n-    format_info.integer_hash = 0;\n-    format_info.integer_digits = 1;\n-    format_info.frac_digits = 1;\n-    format_info.frac_hash = 4;\n-    format_info.group = -1;\n-    format_info.multiplier = 1;\n-    format_info.add_decimal = TRUE;\n+                \"error in format string '%s', using default\\n\", format);\n+        default_sign = (number < 0.0) ? 1 : 0;\n+        prefix_length = suffix_length = 0;\n+        format_info.integer_hash = 0;\n+        format_info.integer_digits = 1;\n+        format_info.frac_digits = 1;\n+        format_info.frac_hash = 4;\n+        format_info.group = -1;\n+        format_info.multiplier = 1;\n+        format_info.add_decimal = TRUE;\n@@ -1282,1 +1282,1 @@\n-    xmlBufferAdd(buffer, self->minusSign, xmlUTF8Strsize(self->minusSign, 1));\n+        xmlBufferAdd(buffer, self->minusSign, xmlUTF8Strsize(self->minusSign, 1));\n@@ -1286,1 +1286,1 @@\n-    if (*prefix == SYMBOL_QUOTE)\n+        if (*prefix == SYMBOL_QUOTE)\n@@ -1302,6 +1302,6 @@\n-    len = xmlStrlen(self->grouping);\n-    gchar = xsltGetUTF8Char(self->grouping, &len);\n-    xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n-                format_info.integer_digits,\n-                format_info.group,\n-                gchar, len);\n+        len = xmlStrlen(self->grouping);\n+        gchar = xsltGetUTF8Char(self->grouping, &len);\n+        xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n+                                format_info.integer_digits,\n+                                format_info.group,\n+                                gchar, len);\n@@ -1309,4 +1309,4 @@\n-    xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n-                format_info.integer_digits,\n-                format_info.group,\n-                ',', 1);\n+        xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n+                                format_info.integer_digits,\n+                                format_info.group,\n+                                ',', 1);\n@@ -1316,1 +1316,1 @@\n-     format_info.frac_digits == 0) && (format_info.frac_hash > 0)) {\n+         format_info.frac_digits == 0) && (format_info.frac_hash > 0)) {\n@@ -1318,1 +1318,1 @@\n-    --format_info.frac_hash;\n+        --format_info.frac_hash;\n@@ -1323,1 +1323,1 @@\n-    (format_info.integer_digits + format_info.frac_digits == 0)) {\n+        (format_info.integer_digits + format_info.frac_digits == 0)) {\n@@ -1330,2 +1330,2 @@\n-        xmlBufferAdd(buffer, self->decimalPoint,\n-             xmlUTF8Strsize(self->decimalPoint, 1));\n+            xmlBufferAdd(buffer, self->decimalPoint,\n+                         xmlUTF8Strsize(self->decimalPoint, 1));\n@@ -1335,8 +1335,12 @@\n-    if ((number != 0) || (format_info.frac_digits != 0)) {\n-        xmlBufferAdd(buffer, self->decimalPoint,\n-             xmlUTF8Strsize(self->decimalPoint, 1));\n-        number = floor(scale * number + 0.5);\n-        for (j = format_info.frac_hash; j > 0; j--) {\n-        if (fmod(number, 10.0) >= 1.0)\n-            break; \/* for *\/\n-        number \/= 10.0;\n+        if ((number != 0) || (format_info.frac_digits != 0)) {\n+            xmlBufferAdd(buffer, self->decimalPoint,\n+                         xmlUTF8Strsize(self->decimalPoint, 1));\n+            number = floor(scale * number + 0.5);\n+            for (j = format_info.frac_hash; j > 0; j--) {\n+                if (fmod(number, 10.0) >= 1.0)\n+                    break; \/* for *\/\n+                number \/= 10.0;\n+            }\n+            xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n+                                format_info.frac_digits + j,\n+                                0, 0, 0);\n@@ -1344,4 +1348,0 @@\n-        xsltNumberFormatDecimal(buffer, floor(number), self->zeroDigit[0],\n-                format_info.frac_digits + j,\n-                0, 0, 0);\n-    }\n@@ -1351,1 +1351,1 @@\n-    if (*suffix == SYMBOL_QUOTE)\n+        if (*suffix == SYMBOL_QUOTE)\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/numbers.c","additions":633,"deletions":633,"binary":false,"changes":1266,"status":"modified"},{"patch":"@@ -59,7 +59,7 @@\n-    int     integer_hash;   \/* Number of '#' in integer part *\/\n-    int     integer_digits; \/* Number of '0' in integer part *\/\n-    int     frac_digits;    \/* Number of '0' in fractional part *\/\n-    int     frac_hash;      \/* Number of '#' in fractional part *\/\n-    int     group;      \/* Number of chars per display 'group' *\/\n-    int     multiplier;     \/* Scaling for percent or permille *\/\n-    char    add_decimal;    \/* Flag for whether decimal point appears in pattern *\/\n+    int     integer_hash;       \/* Number of '#' in integer part *\/\n+    int     integer_digits;     \/* Number of '0' in integer part *\/\n+    int     frac_digits;        \/* Number of '0' in fractional part *\/\n+    int     frac_hash;          \/* Number of '#' in fractional part *\/\n+    int     group;              \/* Number of chars per display 'group' *\/\n+    int     multiplier;         \/* Scaling for percent or permille *\/\n+    char    add_decimal;        \/* Flag for whether decimal point appears in pattern *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/numbersInternals.h","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -113,2 +113,2 @@\n-    xmlNsPtr *nsList;       \/* the namespaces in scope *\/\n-    int nsNr;           \/* the number of namespaces in scope *\/\n+    xmlNsPtr *nsList;           \/* the namespaces in scope *\/\n+    int nsNr;                   \/* the number of namespaces in scope *\/\n@@ -121,8 +121,8 @@\n-    xsltStylesheetPtr style;        \/* the stylesheet *\/\n-    xsltTransformContextPtr ctxt;   \/* the transformation or NULL *\/\n-    const xmlChar *cur;         \/* the current char being parsed *\/\n-    const xmlChar *base;        \/* the full expression *\/\n-    xmlDocPtr      doc;         \/* the source document *\/\n-    xmlNodePtr    elem;         \/* the source element *\/\n-    int error;              \/* error code *\/\n-    xsltCompMatchPtr comp;      \/* the result *\/\n+    xsltStylesheetPtr style;            \/* the stylesheet *\/\n+    xsltTransformContextPtr ctxt;       \/* the transformation or NULL *\/\n+    const xmlChar *cur;                 \/* the current char being parsed *\/\n+    const xmlChar *base;                \/* the full expression *\/\n+    xmlDocPtr      doc;                 \/* the source document *\/\n+    xmlNodePtr    elem;                 \/* the source element *\/\n+    int error;                          \/* error code *\/\n+    xsltCompMatchPtr comp;              \/* the result *\/\n@@ -132,3 +132,3 @@\n- *                                  *\n- *          Type functions                  *\n- *                                  *\n+ *                                                                      *\n+ *                      Type functions                                  *\n+ *                                                                      *\n@@ -150,3 +150,3 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltNewCompMatch : out of memory error\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, NULL,\n+                \"xsltNewCompMatch : out of memory error\\n\");\n+        return(NULL);\n@@ -160,4 +160,4 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltNewCompMatch : out of memory error\\n\");\n-    xmlFree(cur);\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, NULL,\n+                \"xsltNewCompMatch : out of memory error\\n\");\n+        xmlFree(cur);\n+        return(NULL);\n@@ -183,1 +183,1 @@\n-    return;\n+        return;\n@@ -185,1 +185,1 @@\n-    xmlFree((xmlChar *)comp->pattern);\n+        xmlFree((xmlChar *)comp->pattern);\n@@ -187,1 +187,1 @@\n-    xmlFree(comp->nsList);\n+        xmlFree(comp->nsList);\n@@ -189,9 +189,9 @@\n-    op = &comp->steps[i];\n-    if (op->value != NULL)\n-        xmlFree(op->value);\n-    if (op->value2 != NULL)\n-        xmlFree(op->value2);\n-    if (op->value3 != NULL)\n-        xmlFree(op->value3);\n-    if (op->comp != NULL)\n-        xmlXPathFreeCompExpr(op->comp);\n+        op = &comp->steps[i];\n+        if (op->value != NULL)\n+            xmlFree(op->value);\n+        if (op->value2 != NULL)\n+            xmlFree(op->value2);\n+        if (op->value3 != NULL)\n+            xmlFree(op->value3);\n+        if (op->comp != NULL)\n+            xmlXPathFreeCompExpr(op->comp);\n@@ -215,3 +215,3 @@\n-    cur = comp;\n-    comp = comp->next;\n-    xsltFreeCompMatch(cur);\n+        cur = comp;\n+        comp = comp->next;\n+        xsltFreeCompMatch(cur);\n@@ -264,3 +264,3 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltNewParserContext : malloc failed\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, NULL,\n+                \"xsltNewParserContext : malloc failed\\n\");\n+        return(NULL);\n@@ -283,1 +283,1 @@\n-    return;\n+        return;\n@@ -307,13 +307,13 @@\n-    tmp = (xsltStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *\n-                                     sizeof(xsltStepOp));\n-    if (tmp == NULL) {\n-        xsltGenericError(xsltGenericErrorContext,\n-         \"xsltCompMatchAdd: memory re-allocation failure.\\n\");\n-        if (ctxt->style != NULL)\n-        ctxt->style->errors++;\n-        if (value)\n-            xmlFree(value);\n-        if (value2)\n-            xmlFree(value2);\n-        return (-1);\n-    }\n+        tmp = (xsltStepOpPtr) xmlRealloc(comp->steps, comp->maxStep * 2 *\n+                                         sizeof(xsltStepOp));\n+        if (tmp == NULL) {\n+            xsltGenericError(xsltGenericErrorContext,\n+             \"xsltCompMatchAdd: memory re-allocation failure.\\n\");\n+            if (ctxt->style != NULL)\n+                ctxt->style->errors++;\n+            if (value)\n+                xmlFree(value);\n+            if (value2)\n+                xmlFree(value2);\n+            return (-1);\n+        }\n@@ -321,1 +321,1 @@\n-    comp->steps = tmp;\n+        comp->steps = tmp;\n@@ -329,6 +329,6 @@\n-    comp->steps[comp->nbStep].previousExtra =\n-        xsltAllocateExtraCtxt(ctxt->ctxt);\n-    comp->steps[comp->nbStep].indexExtra =\n-        xsltAllocateExtraCtxt(ctxt->ctxt);\n-    comp->steps[comp->nbStep].lenExtra =\n-        xsltAllocateExtraCtxt(ctxt->ctxt);\n+        comp->steps[comp->nbStep].previousExtra =\n+            xsltAllocateExtraCtxt(ctxt->ctxt);\n+        comp->steps[comp->nbStep].indexExtra =\n+            xsltAllocateExtraCtxt(ctxt->ctxt);\n+        comp->steps[comp->nbStep].lenExtra =\n+            xsltAllocateExtraCtxt(ctxt->ctxt);\n@@ -336,6 +336,6 @@\n-    comp->steps[comp->nbStep].previousExtra =\n-        xsltAllocateExtra(ctxt->style);\n-    comp->steps[comp->nbStep].indexExtra =\n-        xsltAllocateExtra(ctxt->style);\n-    comp->steps[comp->nbStep].lenExtra =\n-        xsltAllocateExtra(ctxt->style);\n+        comp->steps[comp->nbStep].previousExtra =\n+            xsltAllocateExtra(ctxt->style);\n+        comp->steps[comp->nbStep].indexExtra =\n+            xsltAllocateExtra(ctxt->style);\n+        comp->steps[comp->nbStep].lenExtra =\n+            xsltAllocateExtra(ctxt->style);\n@@ -347,2 +347,2 @@\n-    if (novar != 0)\n-        flags = XML_XPATH_NOVAR;\n+        if (novar != 0)\n+            flags = XML_XPATH_NOVAR;\n@@ -350,1 +350,1 @@\n-    comp->steps[comp->nbStep].comp = xsltXPathCompileFlags(ctxt->style,\n+        comp->steps[comp->nbStep].comp = xsltXPathCompileFlags(ctxt->style,\n@@ -352,6 +352,6 @@\n-    if (comp->steps[comp->nbStep].comp == NULL) {\n-        xsltTransformError(NULL, ctxt->style, ctxt->elem,\n-            \"Failed to compile predicate\\n\");\n-        if (ctxt->style != NULL)\n-        ctxt->style->errors++;\n-    }\n+        if (comp->steps[comp->nbStep].comp == NULL) {\n+            xsltTransformError(NULL, ctxt->style, ctxt->elem,\n+                    \"Failed to compile predicate\\n\");\n+            if (ctxt->style != NULL)\n+                ctxt->style->errors++;\n+        }\n@@ -375,29 +375,29 @@\n-    register xmlChar *tmp;\n-    register xsltOp op;\n-    register xmlXPathCompExprPtr expr;\n-    register int t;\n-    i = j - 1;\n-    tmp = comp->steps[i].value;\n-    comp->steps[i].value = comp->steps[j].value;\n-    comp->steps[j].value = tmp;\n-    tmp = comp->steps[i].value2;\n-    comp->steps[i].value2 = comp->steps[j].value2;\n-    comp->steps[j].value2 = tmp;\n-    tmp = comp->steps[i].value3;\n-    comp->steps[i].value3 = comp->steps[j].value3;\n-    comp->steps[j].value3 = tmp;\n-    op = comp->steps[i].op;\n-    comp->steps[i].op = comp->steps[j].op;\n-    comp->steps[j].op = op;\n-    expr = comp->steps[i].comp;\n-    comp->steps[i].comp = comp->steps[j].comp;\n-    comp->steps[j].comp = expr;\n-    t = comp->steps[i].previousExtra;\n-    comp->steps[i].previousExtra = comp->steps[j].previousExtra;\n-    comp->steps[j].previousExtra = t;\n-    t = comp->steps[i].indexExtra;\n-    comp->steps[i].indexExtra = comp->steps[j].indexExtra;\n-    comp->steps[j].indexExtra = t;\n-    t = comp->steps[i].lenExtra;\n-    comp->steps[i].lenExtra = comp->steps[j].lenExtra;\n-    comp->steps[j].lenExtra = t;\n+        register xmlChar *tmp;\n+        register xsltOp op;\n+        register xmlXPathCompExprPtr expr;\n+        register int t;\n+        i = j - 1;\n+        tmp = comp->steps[i].value;\n+        comp->steps[i].value = comp->steps[j].value;\n+        comp->steps[j].value = tmp;\n+        tmp = comp->steps[i].value2;\n+        comp->steps[i].value2 = comp->steps[j].value2;\n+        comp->steps[j].value2 = tmp;\n+        tmp = comp->steps[i].value3;\n+        comp->steps[i].value3 = comp->steps[j].value3;\n+        comp->steps[j].value3 = tmp;\n+        op = comp->steps[i].op;\n+        comp->steps[i].op = comp->steps[j].op;\n+        comp->steps[j].op = op;\n+        expr = comp->steps[i].comp;\n+        comp->steps[i].comp = comp->steps[j].comp;\n+        comp->steps[j].comp = expr;\n+        t = comp->steps[i].previousExtra;\n+        comp->steps[i].previousExtra = comp->steps[j].previousExtra;\n+        comp->steps[j].previousExtra = t;\n+        t = comp->steps[i].indexExtra;\n+        comp->steps[i].indexExtra = comp->steps[j].indexExtra;\n+        comp->steps[j].indexExtra = t;\n+        t = comp->steps[i].lenExtra;\n+        comp->steps[i].lenExtra = comp->steps[j].lenExtra;\n+        comp->steps[j].lenExtra = t;\n@@ -420,31 +420,31 @@\n-    register xmlChar *tmp;\n-    register xsltOp op;\n-    register xmlXPathCompExprPtr expr;\n-    register int t;\n-\n-    tmp = comp->steps[i].value;\n-    comp->steps[i].value = comp->steps[j].value;\n-    comp->steps[j].value = tmp;\n-    tmp = comp->steps[i].value2;\n-    comp->steps[i].value2 = comp->steps[j].value2;\n-    comp->steps[j].value2 = tmp;\n-    tmp = comp->steps[i].value3;\n-    comp->steps[i].value3 = comp->steps[j].value3;\n-    comp->steps[j].value3 = tmp;\n-    op = comp->steps[i].op;\n-    comp->steps[i].op = comp->steps[j].op;\n-    comp->steps[j].op = op;\n-    expr = comp->steps[i].comp;\n-    comp->steps[i].comp = comp->steps[j].comp;\n-    comp->steps[j].comp = expr;\n-    t = comp->steps[i].previousExtra;\n-    comp->steps[i].previousExtra = comp->steps[j].previousExtra;\n-    comp->steps[j].previousExtra = t;\n-    t = comp->steps[i].indexExtra;\n-    comp->steps[i].indexExtra = comp->steps[j].indexExtra;\n-    comp->steps[j].indexExtra = t;\n-    t = comp->steps[i].lenExtra;\n-    comp->steps[i].lenExtra = comp->steps[j].lenExtra;\n-    comp->steps[j].lenExtra = t;\n-    j--;\n-    i++;\n+        register xmlChar *tmp;\n+        register xsltOp op;\n+        register xmlXPathCompExprPtr expr;\n+        register int t;\n+\n+        tmp = comp->steps[i].value;\n+        comp->steps[i].value = comp->steps[j].value;\n+        comp->steps[j].value = tmp;\n+        tmp = comp->steps[i].value2;\n+        comp->steps[i].value2 = comp->steps[j].value2;\n+        comp->steps[j].value2 = tmp;\n+        tmp = comp->steps[i].value3;\n+        comp->steps[i].value3 = comp->steps[j].value3;\n+        comp->steps[j].value3 = tmp;\n+        op = comp->steps[i].op;\n+        comp->steps[i].op = comp->steps[j].op;\n+        comp->steps[j].op = op;\n+        expr = comp->steps[i].comp;\n+        comp->steps[i].comp = comp->steps[j].comp;\n+        comp->steps[j].comp = expr;\n+        t = comp->steps[i].previousExtra;\n+        comp->steps[i].previousExtra = comp->steps[j].previousExtra;\n+        comp->steps[j].previousExtra = t;\n+        t = comp->steps[i].indexExtra;\n+        comp->steps[i].indexExtra = comp->steps[j].indexExtra;\n+        comp->steps[j].indexExtra = t;\n+        t = comp->steps[i].lenExtra;\n+        comp->steps[i].lenExtra = comp->steps[j].lenExtra;\n+        comp->steps[j].lenExtra = t;\n+        j--;\n+        i++;\n@@ -455,2 +455,2 @@\n-     * Detect consecutive XSLT_OP_PREDICATE and predicates on ops which\n-     * haven't been optimized yet indicating a direct matching should be done.\n+     * Detect consecutive XSLT_OP_PREDICATE indicating a direct matching\n+     * should be done.\n@@ -459,1 +459,2 @@\n-        xsltOp op = comp->steps[i].op;\n+        if ((comp->steps[i].op == XSLT_OP_PREDICATE) &&\n+            (comp->steps[i + 1].op == XSLT_OP_PREDICATE)) {\n@@ -461,3 +462,3 @@\n-        if ((op != XSLT_OP_ELEM) &&\n-            (op != XSLT_OP_ALL) &&\n-        (comp->steps[i + 1].op == XSLT_OP_PREDICATE)) {\n+            comp->direct = 1;\n+            if (comp->pattern[0] != '\/') {\n+                xmlChar *query;\n@@ -465,3 +466,2 @@\n-        comp->direct = 1;\n-        if (comp->pattern[0] != '\/') {\n-        xmlChar *query;\n+                query = xmlStrdup((const xmlChar *)\"\/\/\");\n+                query = xmlStrcat(query, comp->pattern);\n@@ -469,5 +469,4 @@\n-        query = xmlStrdup((const xmlChar *)\"\/\/\");\n-        query = xmlStrcat(query, comp->pattern);\n-\n-        xmlFree((xmlChar *) comp->pattern);\n-        comp->pattern = query;\n+                xmlFree((xmlChar *) comp->pattern);\n+                comp->pattern = query;\n+            }\n+            break;\n@@ -475,2 +474,0 @@\n-        break;\n-    }\n@@ -481,3 +478,3 @@\n- *                                  *\n- *      The interpreter for the precompiled patterns        *\n- *                                  *\n+ *                                                                      *\n+ *              The interpreter for the precompiled patterns            *\n+ *                                                                      *\n@@ -491,2 +488,2 @@\n-    states->nbstates = 0;\n-    states->states = xmlMalloc(4 * sizeof(xsltStepState));\n+        states->nbstates = 0;\n+        states->states = xmlMalloc(4 * sizeof(xsltStepState));\n@@ -497,10 +494,10 @@\n-    tmp = (xsltStepStatePtr) xmlRealloc(states->states,\n-                   2 * states->maxstates * sizeof(xsltStepState));\n-    if (tmp == NULL) {\n-        xsltGenericError(xsltGenericErrorContext,\n-         \"xsltPatPushState: memory re-allocation failure.\\n\");\n-        ctxt->state = XSLT_STATE_STOPPED;\n-        return(-1);\n-    }\n-    states->states = tmp;\n-    states->maxstates *= 2;\n+        tmp = (xsltStepStatePtr) xmlRealloc(states->states,\n+                               2 * states->maxstates * sizeof(xsltStepState));\n+        if (tmp == NULL) {\n+            xsltGenericError(xsltGenericErrorContext,\n+             \"xsltPatPushState: memory re-allocation failure.\\n\");\n+            ctxt->state = XSLT_STATE_STOPPED;\n+            return(-1);\n+        }\n+        states->states = tmp;\n+        states->maxstates *= 2;\n@@ -536,1 +533,1 @@\n-                    xmlNodePtr node, xmlNsPtr *nsList, int nsNr) {\n+                        xmlNodePtr node, xmlNsPtr *nsList, int nsNr) {\n@@ -547,1 +544,1 @@\n-    isRVT = 1;\n+        isRVT = 1;\n@@ -549,1 +546,1 @@\n-    isRVT = 0;\n+        isRVT = 0;\n@@ -553,1 +550,1 @@\n-    XSLT_RUNTIME_EXTRA(ctxt, sel->previousExtra, ptr);\n+        XSLT_RUNTIME_EXTRA(ctxt, sel->previousExtra, ptr);\n@@ -556,1 +553,1 @@\n-    XSLT_RUNTIME_EXTRA_LST(ctxt, sel->lenExtra);\n+        XSLT_RUNTIME_EXTRA_LST(ctxt, sel->lenExtra);\n@@ -559,50 +556,50 @@\n-    xmlXPathObjectPtr newlist;\n-    xmlNodePtr parent = node->parent;\n-    xmlDocPtr olddoc;\n-    xmlNodePtr oldnode;\n-    int oldNsNr, oldContextSize, oldProximityPosition;\n-    xmlNsPtr *oldNamespaces;\n-\n-    oldnode = ctxt->xpathCtxt->node;\n-    olddoc = ctxt->xpathCtxt->doc;\n-    oldNsNr = ctxt->xpathCtxt->nsNr;\n-    oldNamespaces = ctxt->xpathCtxt->namespaces;\n-    oldContextSize = ctxt->xpathCtxt->contextSize;\n-    oldProximityPosition = ctxt->xpathCtxt->proximityPosition;\n-    ctxt->xpathCtxt->node = node;\n-    ctxt->xpathCtxt->doc = doc;\n-    ctxt->xpathCtxt->namespaces = nsList;\n-    ctxt->xpathCtxt->nsNr = nsNr;\n-    newlist = xmlXPathEval(comp->pattern, ctxt->xpathCtxt);\n-    ctxt->xpathCtxt->node = oldnode;\n-    ctxt->xpathCtxt->doc = olddoc;\n-    ctxt->xpathCtxt->namespaces = oldNamespaces;\n-    ctxt->xpathCtxt->nsNr = oldNsNr;\n-    ctxt->xpathCtxt->contextSize = oldContextSize;\n-    ctxt->xpathCtxt->proximityPosition = oldProximityPosition;\n-    if (newlist == NULL)\n-        return(-1);\n-    if (newlist->type != XPATH_NODESET) {\n-        xmlXPathFreeObject(newlist);\n-        return(-1);\n-    }\n-    ix = 0;\n-\n-    if ((parent == NULL) || (node->doc == NULL) || isRVT)\n-        nocache = 1;\n-\n-    if (nocache == 0) {\n-        if (list != NULL)\n-        xmlXPathFreeObject(list);\n-        list = newlist;\n-\n-        XSLT_RUNTIME_EXTRA_LST(ctxt, sel->lenExtra) =\n-        (void *) list;\n-        XSLT_RUNTIME_EXTRA(ctxt, sel->previousExtra, ptr) =\n-        (void *) doc;\n-        XSLT_RUNTIME_EXTRA(ctxt, sel->indexExtra, ival) =\n-        0;\n-        XSLT_RUNTIME_EXTRA_FREE(ctxt, sel->lenExtra) =\n-        xmlXPathFreeObjectWrapper;\n-    } else\n-        list = newlist;\n+        xmlXPathObjectPtr newlist;\n+        xmlNodePtr parent = node->parent;\n+        xmlDocPtr olddoc;\n+        xmlNodePtr oldnode;\n+        int oldNsNr, oldContextSize, oldProximityPosition;\n+        xmlNsPtr *oldNamespaces;\n+\n+        oldnode = ctxt->xpathCtxt->node;\n+        olddoc = ctxt->xpathCtxt->doc;\n+        oldNsNr = ctxt->xpathCtxt->nsNr;\n+        oldNamespaces = ctxt->xpathCtxt->namespaces;\n+        oldContextSize = ctxt->xpathCtxt->contextSize;\n+        oldProximityPosition = ctxt->xpathCtxt->proximityPosition;\n+        ctxt->xpathCtxt->node = node;\n+        ctxt->xpathCtxt->doc = doc;\n+        ctxt->xpathCtxt->namespaces = nsList;\n+        ctxt->xpathCtxt->nsNr = nsNr;\n+        newlist = xmlXPathEval(comp->pattern, ctxt->xpathCtxt);\n+        ctxt->xpathCtxt->node = oldnode;\n+        ctxt->xpathCtxt->doc = olddoc;\n+        ctxt->xpathCtxt->namespaces = oldNamespaces;\n+        ctxt->xpathCtxt->nsNr = oldNsNr;\n+        ctxt->xpathCtxt->contextSize = oldContextSize;\n+        ctxt->xpathCtxt->proximityPosition = oldProximityPosition;\n+        if (newlist == NULL)\n+            return(-1);\n+        if (newlist->type != XPATH_NODESET) {\n+            xmlXPathFreeObject(newlist);\n+            return(-1);\n+        }\n+        ix = 0;\n+\n+        if ((parent == NULL) || (node->doc == NULL) || isRVT)\n+            nocache = 1;\n+\n+        if (nocache == 0) {\n+            if (list != NULL)\n+                xmlXPathFreeObject(list);\n+            list = newlist;\n+\n+            XSLT_RUNTIME_EXTRA_LST(ctxt, sel->lenExtra) =\n+                (void *) list;\n+            XSLT_RUNTIME_EXTRA(ctxt, sel->previousExtra, ptr) =\n+                (void *) doc;\n+            XSLT_RUNTIME_EXTRA(ctxt, sel->indexExtra, ival) =\n+                0;\n+            XSLT_RUNTIME_EXTRA_FREE(ctxt, sel->lenExtra) =\n+                xmlXPathFreeObjectWrapper;\n+        } else\n+            list = newlist;\n@@ -611,4 +608,4 @@\n-    (list->nodesetval->nodeNr <= 0)) {\n-    if (nocache == 1)\n-        xmlXPathFreeObject(list);\n-    return(0);\n+        (list->nodesetval->nodeNr <= 0)) {\n+        if (nocache == 1)\n+            xmlXPathFreeObject(list);\n+        return(0);\n@@ -618,5 +615,6 @@\n-    for (j = 0;j < list->nodesetval->nodeNr;j++) {\n-        if (list->nodesetval->nodeTab[j] == node) {\n-        if (nocache == 1)\n-            xmlXPathFreeObject(list);\n-        return(1);\n+        for (j = 0;j < list->nodesetval->nodeNr;j++) {\n+            if (list->nodesetval->nodeTab[j] == node) {\n+                if (nocache == 1)\n+                    xmlXPathFreeObject(list);\n+                return(1);\n+            }\n@@ -624,1 +622,0 @@\n-    }\n@@ -628,1 +625,1 @@\n-    xmlXPathFreeObject(list);\n+        xmlXPathFreeObject(list);\n@@ -632,0 +629,146 @@\n+\/**\n+ * xsltTestStepMatch:\n+ * @ctxt:  a XSLT process context\n+ * @node: a node\n+ * @step:  the step\n+ *\n+ * Test whether the node matches the step.\n+ *\n+ * Returns 1 if it matches, 0 if it doesn't and -1 in case of failure\n+ *\/\n+static int\n+xsltTestStepMatch(xsltTransformContextPtr ctxt, xmlNodePtr node,\n+                  xsltStepOpPtr step) {\n+    switch (step->op) {\n+        case XSLT_OP_ROOT:\n+            if ((node->type == XML_DOCUMENT_NODE) ||\n+#ifdef LIBXML_DOCB_ENABLED\n+                (node->type == XML_DOCB_DOCUMENT_NODE) ||\n+#endif\n+                (node->type == XML_HTML_DOCUMENT_NODE))\n+                return(1);\n+            if ((node->type == XML_ELEMENT_NODE) && (node->name[0] == ' '))\n+                return(1);\n+            return(0);\n+        case XSLT_OP_ELEM:\n+            if (node->type != XML_ELEMENT_NODE)\n+                return(0);\n+            if (step->value == NULL)\n+                return(1);\n+            if (step->value[0] != node->name[0])\n+                return(0);\n+            if (!xmlStrEqual(step->value, node->name))\n+                return(0);\n+\n+            \/* Namespace test *\/\n+            if (node->ns == NULL) {\n+                if (step->value2 != NULL)\n+                    return(0);\n+            } else if (node->ns->href != NULL) {\n+                if (step->value2 == NULL)\n+                    return(0);\n+                if (!xmlStrEqual(step->value2, node->ns->href))\n+                    return(0);\n+            }\n+            return(1);\n+        case XSLT_OP_ATTR:\n+            if (node->type != XML_ATTRIBUTE_NODE)\n+                return(0);\n+            if (step->value != NULL) {\n+                if (step->value[0] != node->name[0])\n+                    return(0);\n+                if (!xmlStrEqual(step->value, node->name))\n+                    return(0);\n+            }\n+            \/* Namespace test *\/\n+            if (node->ns == NULL) {\n+                if (step->value2 != NULL)\n+                    return(0);\n+            } else if (step->value2 != NULL) {\n+                if (!xmlStrEqual(step->value2, node->ns->href))\n+                    return(0);\n+            }\n+            return(1);\n+        case XSLT_OP_ID: {\n+            \/* TODO Handle IDs decently, must be done differently *\/\n+            xmlAttrPtr id;\n+\n+            if (node->type != XML_ELEMENT_NODE)\n+                return(0);\n+\n+            id = xmlGetID(node->doc, step->value);\n+            if ((id == NULL) || (id->parent != node))\n+                return(0);\n+            break;\n+        }\n+        case XSLT_OP_KEY: {\n+            xmlNodeSetPtr list;\n+            int indx;\n+\n+            list = xsltGetKey(ctxt, step->value,\n+                              step->value3, step->value2);\n+            if (list == NULL)\n+                return(0);\n+            for (indx = 0;indx < list->nodeNr;indx++)\n+                if (list->nodeTab[indx] == node)\n+                    break;\n+            if (indx >= list->nodeNr)\n+                return(0);\n+            break;\n+        }\n+        case XSLT_OP_NS:\n+            if (node->type != XML_ELEMENT_NODE)\n+                return(0);\n+            if (node->ns == NULL) {\n+                if (step->value != NULL)\n+                    return(0);\n+            } else if (node->ns->href != NULL) {\n+                if (step->value == NULL)\n+                    return(0);\n+                if (!xmlStrEqual(step->value, node->ns->href))\n+                    return(0);\n+            }\n+            break;\n+        case XSLT_OP_ALL:\n+            if (node->type != XML_ELEMENT_NODE)\n+                return(0);\n+            break;\n+        case XSLT_OP_PI:\n+            if (node->type != XML_PI_NODE)\n+                return(0);\n+            if (step->value != NULL) {\n+                if (!xmlStrEqual(step->value, node->name))\n+                    return(0);\n+            }\n+            break;\n+        case XSLT_OP_COMMENT:\n+            if (node->type != XML_COMMENT_NODE)\n+                return(0);\n+            break;\n+        case XSLT_OP_TEXT:\n+            if ((node->type != XML_TEXT_NODE) &&\n+                (node->type != XML_CDATA_SECTION_NODE))\n+                return(0);\n+            break;\n+        case XSLT_OP_NODE:\n+            switch (node->type) {\n+                case XML_ELEMENT_NODE:\n+                case XML_CDATA_SECTION_NODE:\n+                case XML_PI_NODE:\n+                case XML_COMMENT_NODE:\n+                case XML_TEXT_NODE:\n+                    break;\n+                default:\n+                    return(0);\n+            }\n+            break;\n+        default:\n+            xsltTransformError(ctxt, NULL, node,\n+                    \"xsltTestStepMatch: unexpected step op %d\\n\",\n+                    step->op);\n+            return(-1);\n+    }\n+\n+    return(1);\n+}\n+\n@@ -659,0 +802,2 @@\n+    if (sel == NULL)\n+        return(0);\n@@ -669,2 +814,6 @@\n-     * TODO: Make this work for additional ops. Currently, only XSLT_OP_ELEM\n-     * and XSLT_OP_ALL are supported.\n+     * This could be improved in the following ways:\n+     *\n+     * - Skip recomputation if predicates don't use position() or last()\n+     * - Keep data for multiple parents. This would require a hash table\n+     *   or an unused member in xmlNode.\n+     * - Store node test results in a bitmap to avoid computing them twice.\n@@ -674,5 +823,1 @@\n-    if ((sel != NULL) &&\n-        (sel->op == XSLT_OP_ELEM) &&\n-        (sel->value != NULL) &&\n-        (node->type == XML_ELEMENT_NODE) &&\n-        (node->parent != NULL)) {\n+    {\n@@ -695,11 +840,2 @@\n-                if ((sibling->type == XML_ELEMENT_NODE) &&\n-                    (previous->name != NULL) &&\n-                    (sibling->name != NULL) &&\n-                    (previous->name[0] == sibling->name[0]) &&\n-                    (xmlStrEqual(previous->name, sibling->name)))\n-                {\n-                    if ((sel->value2 == NULL) ||\n-                        ((sibling->ns != NULL) &&\n-                         (xmlStrEqual(sel->value2, sibling->ns->href))))\n-                        indx++;\n-                }\n+                if (xsltTestStepMatch(ctxt, sibling, sel))\n+                    indx++;\n@@ -715,14 +851,2 @@\n-                    if ((sibling->type == XML_ELEMENT_NODE) &&\n-                        (previous->name != NULL) &&\n-                        (sibling->name != NULL) &&\n-                        (previous->name[0] == sibling->name[0]) &&\n-                        (xmlStrEqual(previous->name, sibling->name)))\n-                    {\n-                        if ((sel->value2 == NULL) ||\n-                            ((sibling->ns != NULL) &&\n-                            (xmlStrEqual(sel->value2,\n-                            sibling->ns->href))))\n-                        {\n-                            indx--;\n-                        }\n-                    }\n+                    if (xsltTestStepMatch(ctxt, sibling, sel))\n+                        indx--;\n@@ -759,13 +883,5 @@\n-                if (siblings->type == XML_ELEMENT_NODE) {\n-                    if (siblings == node) {\n-                        len++;\n-                        pos = len;\n-                    } else if ((node->name != NULL) &&\n-                               (siblings->name != NULL) &&\n-                        (node->name[0] == siblings->name[0]) &&\n-                        (xmlStrEqual(node->name, siblings->name))) {\n-                        if ((sel->value2 == NULL) ||\n-                            ((siblings->ns != NULL) &&\n-                             (xmlStrEqual(sel->value2, siblings->ns->href))))\n-                            len++;\n-                    }\n+                if (siblings == node) {\n+                    len++;\n+                    pos = len;\n+                } else if (xsltTestStepMatch(ctxt, siblings, sel)) {\n+                    len++;\n@@ -800,90 +916,0 @@\n-    } else if ((sel != NULL) && (sel->op == XSLT_OP_ALL) &&\n-               (node->type == XML_ELEMENT_NODE)) {\n-        xmlNodePtr previous;\n-        int nocache = 0;\n-\n-        previous = (xmlNodePtr)\n-            XSLT_RUNTIME_EXTRA(ctxt, sel->previousExtra, ptr);\n-        if ((previous != NULL) &&\n-            (previous->parent == node->parent)) {\n-            \/*\n-             * just walk back to adjust the index\n-             *\/\n-            int indx = 0;\n-            xmlNodePtr sibling = node;\n-\n-            while (sibling != NULL) {\n-                if (sibling == previous)\n-                    break;\n-                if (sibling->type == XML_ELEMENT_NODE)\n-                    indx++;\n-                sibling = sibling->prev;\n-            }\n-            if (sibling == NULL) {\n-                \/* hum going backward in document order ... *\/\n-                indx = 0;\n-                sibling = node;\n-                while (sibling != NULL) {\n-                    if (sibling == previous)\n-                        break;\n-                    if (sibling->type == XML_ELEMENT_NODE)\n-                        indx--;\n-                    sibling = sibling->next;\n-                }\n-            }\n-            if (sibling != NULL) {\n-                pos = XSLT_RUNTIME_EXTRA(ctxt,\n-                    sel->indexExtra, ival) + indx;\n-                \/*\n-                 * If the node is in a Value Tree we cannot\n-                 * cache it !\n-                 *\/\n-                if ((node->doc != NULL) && !isRVT) {\n-                    len = XSLT_RUNTIME_EXTRA(ctxt, sel->lenExtra, ival);\n-                    XSLT_RUNTIME_EXTRA(ctxt, sel->previousExtra, ptr) = node;\n-                    XSLT_RUNTIME_EXTRA(ctxt, sel->indexExtra, ival) = pos;\n-                }\n-            } else\n-                pos = 0;\n-        } else {\n-            \/*\n-             * recompute the index\n-             *\/\n-            xmlNodePtr parent = node->parent;\n-            xmlNodePtr siblings = NULL;\n-\n-            if (parent) siblings = parent->children;\n-\n-            while (siblings != NULL) {\n-                if (siblings->type == XML_ELEMENT_NODE) {\n-                    len++;\n-                    if (siblings == node) {\n-                        pos = len;\n-                    }\n-                }\n-                siblings = siblings->next;\n-            }\n-            if ((parent == NULL) || (node->doc == NULL))\n-                nocache = 1;\n-            else {\n-                while (parent->parent != NULL)\n-                    parent = parent->parent;\n-                if (((parent->type != XML_DOCUMENT_NODE) &&\n-                     (parent->type != XML_HTML_DOCUMENT_NODE)) ||\n-                     (parent != (xmlNodePtr) node->doc))\n-                    nocache = 1;\n-            }\n-        }\n-        if (pos != 0) {\n-            ctxt->xpathCtxt->contextSize = len;\n-            ctxt->xpathCtxt->proximityPosition = pos;\n-            \/*\n-             * If the node is in a Value Tree we cannot\n-             * cache it !\n-             *\/\n-            if ((node->doc != NULL) && (nocache == 0) && !isRVT) {\n-                XSLT_RUNTIME_EXTRA(ctxt, sel->previousExtra, ptr) = node;\n-                XSLT_RUNTIME_EXTRA(ctxt, sel->indexExtra, ival) = pos;\n-                XSLT_RUNTIME_EXTRA(ctxt, sel->lenExtra, ival) = len;\n-            }\n-        }\n@@ -920,2 +946,2 @@\n-              xmlNodePtr matchNode, const xmlChar *mode,\n-          const xmlChar *modeURI) {\n+                  xmlNodePtr matchNode, const xmlChar *mode,\n+                  const xmlChar *modeURI) {\n@@ -930,2 +956,2 @@\n-    xsltTransformError(ctxt, NULL, node,\n-        \"xsltTestCompMatch: null arg\\n\");\n+        xsltTransformError(ctxt, NULL, node,\n+                \"xsltTestCompMatch: null arg\\n\");\n@@ -935,7 +961,7 @@\n-    if (comp->mode == NULL)\n-        return(0);\n-    \/*\n-     * both mode strings must be interned on the stylesheet dictionary\n-     *\/\n-    if (comp->mode != mode)\n-        return(0);\n+        if (comp->mode == NULL)\n+            return(0);\n+        \/*\n+         * both mode strings must be interned on the stylesheet dictionary\n+         *\/\n+        if (comp->mode != mode)\n+            return(0);\n@@ -943,2 +969,2 @@\n-    if (comp->mode != NULL)\n-        return(0);\n+        if (comp->mode != NULL)\n+            return(0);\n@@ -947,7 +973,7 @@\n-    if (comp->modeURI == NULL)\n-        return(0);\n-    \/*\n-     * both modeURI strings must be interned on the stylesheet dictionary\n-     *\/\n-    if (comp->modeURI != modeURI)\n-        return(0);\n+        if (comp->modeURI == NULL)\n+            return(0);\n+        \/*\n+         * both modeURI strings must be interned on the stylesheet dictionary\n+         *\/\n+        if (comp->modeURI != modeURI)\n+            return(0);\n@@ -955,2 +981,2 @@\n-    if (comp->modeURI != NULL)\n-        return(0);\n+        if (comp->modeURI != NULL)\n+            return(0);\n@@ -966,4 +992,4 @@\n-    step = &comp->steps[i];\n-    if (step->op != XSLT_OP_PREDICATE)\n-        sel = step;\n-    switch (step->op) {\n+        step = &comp->steps[i];\n+        if (step->op != XSLT_OP_PREDICATE)\n+            sel = step;\n+        switch (step->op) {\n@@ -971,50 +997,1 @@\n-        goto found;\n-            case XSLT_OP_ROOT:\n-        if ((node->type == XML_DOCUMENT_NODE) ||\n-#ifdef LIBXML_DOCB_ENABLED\n-            (node->type == XML_DOCB_DOCUMENT_NODE) ||\n-#endif\n-            (node->type == XML_HTML_DOCUMENT_NODE))\n-            continue;\n-        if ((node->type == XML_ELEMENT_NODE) && (node->name[0] == ' '))\n-            continue;\n-        goto rollback;\n-            case XSLT_OP_ELEM:\n-        if (node->type != XML_ELEMENT_NODE)\n-            goto rollback;\n-        if (step->value == NULL)\n-            continue;\n-        if (step->value[0] != node->name[0])\n-            goto rollback;\n-        if (!xmlStrEqual(step->value, node->name))\n-            goto rollback;\n-\n-        \/* Namespace test *\/\n-        if (node->ns == NULL) {\n-            if (step->value2 != NULL)\n-            goto rollback;\n-        } else if (node->ns->href != NULL) {\n-            if (step->value2 == NULL)\n-            goto rollback;\n-            if (!xmlStrEqual(step->value2, node->ns->href))\n-            goto rollback;\n-        }\n-        continue;\n-            case XSLT_OP_ATTR:\n-        if (node->type != XML_ATTRIBUTE_NODE)\n-            goto rollback;\n-        if (step->value != NULL) {\n-            if (step->value[0] != node->name[0])\n-            goto rollback;\n-            if (!xmlStrEqual(step->value, node->name))\n-            goto rollback;\n-        }\n-        \/* Namespace test *\/\n-        if (node->ns == NULL) {\n-            if (step->value2 != NULL)\n-            goto rollback;\n-        } else if (step->value2 != NULL) {\n-            if (!xmlStrEqual(step->value2, node->ns->href))\n-            goto rollback;\n-        }\n-        continue;\n+                goto found;\n@@ -1022,2 +999,2 @@\n-        if ((node->type == XML_DOCUMENT_NODE) ||\n-            (node->type == XML_HTML_DOCUMENT_NODE) ||\n+                if ((node->type == XML_DOCUMENT_NODE) ||\n+                    (node->type == XML_HTML_DOCUMENT_NODE) ||\n@@ -1025,1 +1002,1 @@\n-            (node->type == XML_DOCB_DOCUMENT_NODE) ||\n+                    (node->type == XML_DOCB_DOCUMENT_NODE) ||\n@@ -1027,22 +1004,22 @@\n-            (node->type == XML_NAMESPACE_DECL))\n-            goto rollback;\n-        node = node->parent;\n-        if (node == NULL)\n-            goto rollback;\n-        if (step->value == NULL)\n-            continue;\n-        if (step->value[0] != node->name[0])\n-            goto rollback;\n-        if (!xmlStrEqual(step->value, node->name))\n-            goto rollback;\n-        \/* Namespace test *\/\n-        if (node->ns == NULL) {\n-            if (step->value2 != NULL)\n-            goto rollback;\n-        } else if (node->ns->href != NULL) {\n-            if (step->value2 == NULL)\n-            goto rollback;\n-            if (!xmlStrEqual(step->value2, node->ns->href))\n-            goto rollback;\n-        }\n-        continue;\n+                    (node->type == XML_NAMESPACE_DECL))\n+                    goto rollback;\n+                node = node->parent;\n+                if (node == NULL)\n+                    goto rollback;\n+                if (step->value == NULL)\n+                    continue;\n+                if (step->value[0] != node->name[0])\n+                    goto rollback;\n+                if (!xmlStrEqual(step->value, node->name))\n+                    goto rollback;\n+                \/* Namespace test *\/\n+                if (node->ns == NULL) {\n+                    if (step->value2 != NULL)\n+                        goto rollback;\n+                } else if (node->ns->href != NULL) {\n+                    if (step->value2 == NULL)\n+                        goto rollback;\n+                    if (!xmlStrEqual(step->value2, node->ns->href))\n+                        goto rollback;\n+                }\n+                continue;\n@@ -1050,17 +1027,17 @@\n-        \/* TODO: implement coalescing of ANCESTOR\/NODE ops *\/\n-        if (step->value == NULL) {\n-            step = &comp->steps[i+1];\n-            if (step->op == XSLT_OP_ROOT)\n-            goto found;\n-            \/* added NS, ID and KEY as a result of bug 168208 *\/\n-            if ((step->op != XSLT_OP_ELEM) &&\n-            (step->op != XSLT_OP_ALL) &&\n-            (step->op != XSLT_OP_NS) &&\n-            (step->op != XSLT_OP_ID) &&\n-            (step->op != XSLT_OP_KEY))\n-            goto rollback;\n-        }\n-        if (node == NULL)\n-            goto rollback;\n-        if ((node->type == XML_DOCUMENT_NODE) ||\n-            (node->type == XML_HTML_DOCUMENT_NODE) ||\n+                \/* TODO: implement coalescing of ANCESTOR\/NODE ops *\/\n+                if (step->value == NULL) {\n+                    step = &comp->steps[i+1];\n+                    if (step->op == XSLT_OP_ROOT)\n+                        goto found;\n+                    \/* added NS, ID and KEY as a result of bug 168208 *\/\n+                    if ((step->op != XSLT_OP_ELEM) &&\n+                        (step->op != XSLT_OP_ALL) &&\n+                        (step->op != XSLT_OP_NS) &&\n+                        (step->op != XSLT_OP_ID) &&\n+                        (step->op != XSLT_OP_KEY))\n+                        goto rollback;\n+                }\n+                if (node == NULL)\n+                    goto rollback;\n+                if ((node->type == XML_DOCUMENT_NODE) ||\n+                    (node->type == XML_HTML_DOCUMENT_NODE) ||\n@@ -1068,1 +1045,1 @@\n-            (node->type == XML_DOCB_DOCUMENT_NODE) ||\n+                    (node->type == XML_DOCB_DOCUMENT_NODE) ||\n@@ -1070,87 +1047,44 @@\n-            (node->type == XML_NAMESPACE_DECL))\n-            goto rollback;\n-        node = node->parent;\n-        if ((step->op != XSLT_OP_ELEM) && step->op != XSLT_OP_ALL) {\n-            xsltPatPushState(ctxt, &states, i, node);\n-            continue;\n-        }\n-        i++;\n-        if (step->value == NULL) {\n-            xsltPatPushState(ctxt, &states, i - 1, node);\n-            continue;\n-        }\n-        while (node != NULL) {\n-            if ((node->type == XML_ELEMENT_NODE) &&\n-            (step->value[0] == node->name[0]) &&\n-            (xmlStrEqual(step->value, node->name))) {\n-            \/* Namespace test *\/\n-            if (node->ns == NULL) {\n-                if (step->value2 == NULL)\n-                break;\n-            } else if (node->ns->href != NULL) {\n-                if ((step->value2 != NULL) &&\n-                    (xmlStrEqual(step->value2, node->ns->href)))\n-                break;\n-            }\n-            }\n-            node = node->parent;\n-        }\n-        if (node == NULL)\n-            goto rollback;\n-        xsltPatPushState(ctxt, &states, i - 1, node);\n-        continue;\n-            case XSLT_OP_ID: {\n-        \/* TODO Handle IDs decently, must be done differently *\/\n-        xmlAttrPtr id;\n-\n-        if (node->type != XML_ELEMENT_NODE)\n-            goto rollback;\n-\n-        id = xmlGetID(node->doc, step->value);\n-        if ((id == NULL) || (id->parent != node))\n-            goto rollback;\n-        break;\n-        }\n-            case XSLT_OP_KEY: {\n-        xmlNodeSetPtr list;\n-        int indx;\n-\n-        list = xsltGetKey(ctxt, step->value,\n-                      step->value3, step->value2);\n-        if (list == NULL)\n-            goto rollback;\n-        for (indx = 0;indx < list->nodeNr;indx++)\n-            if (list->nodeTab[indx] == node)\n-            break;\n-        if (indx >= list->nodeNr)\n-            goto rollback;\n-        break;\n-        }\n-            case XSLT_OP_NS:\n-        if (node->type != XML_ELEMENT_NODE)\n-            goto rollback;\n-        if (node->ns == NULL) {\n-            if (step->value != NULL)\n-            goto rollback;\n-        } else if (node->ns->href != NULL) {\n-            if (step->value == NULL)\n-            goto rollback;\n-            if (!xmlStrEqual(step->value, node->ns->href))\n-            goto rollback;\n-        }\n-        break;\n-            case XSLT_OP_ALL:\n-        if (node->type != XML_ELEMENT_NODE)\n-            goto rollback;\n-        break;\n-        case XSLT_OP_PREDICATE: {\n-        \/*\n-         * When there is cascading XSLT_OP_PREDICATE or a predicate\n-         * after an op which hasn't been optimized yet, then use a\n-         * direct computation approach. It's not done directly\n-         * at the beginning of the routine to filter out as much\n-         * as possible this costly computation.\n-         *\/\n-        if (comp->direct) {\n-            found = xsltTestCompMatchDirect(ctxt, comp, matchNode,\n-                            comp->nsList, comp->nsNr);\n+                    (node->type == XML_NAMESPACE_DECL))\n+                    goto rollback;\n+                node = node->parent;\n+                if ((step->op != XSLT_OP_ELEM) && step->op != XSLT_OP_ALL) {\n+                    xsltPatPushState(ctxt, &states, i, node);\n+                    continue;\n+                }\n+                i++;\n+                sel = step;\n+                if (step->value == NULL) {\n+                    xsltPatPushState(ctxt, &states, i - 1, node);\n+                    continue;\n+                }\n+                while (node != NULL) {\n+                    if ((node->type == XML_ELEMENT_NODE) &&\n+                        (step->value[0] == node->name[0]) &&\n+                        (xmlStrEqual(step->value, node->name))) {\n+                        \/* Namespace test *\/\n+                        if (node->ns == NULL) {\n+                            if (step->value2 == NULL)\n+                                break;\n+                        } else if (node->ns->href != NULL) {\n+                            if ((step->value2 != NULL) &&\n+                                (xmlStrEqual(step->value2, node->ns->href)))\n+                                break;\n+                        }\n+                    }\n+                    node = node->parent;\n+                }\n+                if (node == NULL)\n+                    goto rollback;\n+                xsltPatPushState(ctxt, &states, i - 1, node);\n+                continue;\n+            case XSLT_OP_PREDICATE: {\n+                \/*\n+                 * When there is cascading XSLT_OP_PREDICATE or a predicate\n+                 * after an op which hasn't been optimized yet, then use a\n+                 * direct computation approach. It's not done directly\n+                 * at the beginning of the routine to filter out as much\n+                 * as possible this costly computation.\n+                 *\/\n+                if (comp->direct) {\n+                    found = xsltTestCompMatchDirect(ctxt, comp, matchNode,\n+                                                    comp->nsList, comp->nsNr);\n@@ -1158,1 +1092,1 @@\n-        }\n+                }\n@@ -1160,2 +1094,2 @@\n-        if (!xsltTestPredicateMatch(ctxt, comp, node, step, sel))\n-            goto rollback;\n+                if (!xsltTestPredicateMatch(ctxt, comp, node, step, sel))\n+                    goto rollback;\n@@ -1163,8 +1097,6 @@\n-        break;\n-        }\n-            case XSLT_OP_PI:\n-        if (node->type != XML_PI_NODE)\n-            goto rollback;\n-        if (step->value != NULL) {\n-            if (!xmlStrEqual(step->value, node->name))\n-            goto rollback;\n+                break;\n+            }\n+            default:\n+                if (xsltTestStepMatch(ctxt, node, step) != 1)\n+                    goto rollback;\n+                break;\n@@ -1172,23 +1104,0 @@\n-        break;\n-            case XSLT_OP_COMMENT:\n-        if (node->type != XML_COMMENT_NODE)\n-            goto rollback;\n-        break;\n-            case XSLT_OP_TEXT:\n-        if ((node->type != XML_TEXT_NODE) &&\n-            (node->type != XML_CDATA_SECTION_NODE))\n-            goto rollback;\n-        break;\n-            case XSLT_OP_NODE:\n-        switch (node->type) {\n-            case XML_ELEMENT_NODE:\n-            case XML_CDATA_SECTION_NODE:\n-            case XML_PI_NODE:\n-            case XML_COMMENT_NODE:\n-            case XML_TEXT_NODE:\n-            break;\n-            default:\n-            goto rollback;\n-        }\n-        break;\n-    }\n@@ -1202,1 +1111,1 @@\n-    xmlFree(states.states);\n+        xmlFree(states.states);\n@@ -1209,1 +1118,1 @@\n-    goto exit;\n+        goto exit;\n@@ -1232,1 +1141,1 @@\n-                  xsltCompMatchPtr comp) {\n+                      xsltCompMatchPtr comp) {\n@@ -1236,1 +1145,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1238,4 +1147,4 @@\n-    ret = xsltTestCompMatch(ctxt, comp, node, NULL, NULL);\n-    if (ret == 1)\n-        return(1);\n-    comp = comp->next;\n+        ret = xsltTestCompMatch(ctxt, comp, node, NULL, NULL);\n+        if (ret == 1)\n+            return(1);\n+        comp = comp->next;\n@@ -1275,3 +1184,3 @@\n- *                                  *\n- *          Dedicated parser for templates          *\n- *                                  *\n+ *                                                                      *\n+ *                      Dedicated parser for templates                  *\n+ *                                                                      *\n@@ -1285,1 +1194,1 @@\n-#define SKIP_BLANKS                         \\\n+#define SKIP_BLANKS                                                     \\\n@@ -1292,1 +1201,1 @@\n-#define PUSH(op, val, val2, novar)                      \\\n+#define PUSH(op, val, val2, novar)                                              \\\n@@ -1295,1 +1204,1 @@\n-#define SWAP()                      \\\n+#define SWAP()                                          \\\n@@ -1298,2 +1207,2 @@\n-#define XSLT_ERROR(X)                           \\\n-    { xsltError(ctxt, __FILE__, __LINE__, X);           \\\n+#define XSLT_ERROR(X)                                                   \\\n+    { xsltError(ctxt, __FILE__, __LINE__, X);                   \\\n@@ -1302,2 +1211,2 @@\n-#define XSLT_ERROR0(X)                          \\\n-    { xsltError(ctxt, __FILE__, __LINE__, X);           \\\n+#define XSLT_ERROR0(X)                                                  \\\n+    { xsltError(ctxt, __FILE__, __LINE__, X);                   \\\n@@ -1327,4 +1236,1 @@\n-    cur = q = CUR_PTR;\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    while ((IS_CHAR(val)) && (val != '\"')) {\n-        cur += len;\n+        cur = q = CUR_PTR;\n@@ -1332,6 +1238,3 @@\n-    }\n-    if (!IS_CHAR(val)) {\n-        ctxt->error = 1;\n-        return(NULL);\n-    } else {\n-        ret = xmlStrndup(q, cur - q);\n+        while ((IS_CHAR(val)) && (val != '\"')) {\n+            cur += len;\n+            val = xmlStringCurrentChar(NULL, cur, &len);\n@@ -1339,2 +1242,8 @@\n-    cur += len;\n-    CUR_PTR = cur;\n+        if (!IS_CHAR(val)) {\n+            ctxt->error = 1;\n+            return(NULL);\n+        } else {\n+            ret = xmlStrndup(q, cur - q);\n+        }\n+        cur += len;\n+        CUR_PTR = cur;\n@@ -1343,4 +1252,1 @@\n-    cur = q = CUR_PTR;\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n-    while ((IS_CHAR(val)) && (val != '\\'')) {\n-        cur += len;\n+        cur = q = CUR_PTR;\n@@ -1348,6 +1254,3 @@\n-    }\n-    if (!IS_CHAR(val)) {\n-        ctxt->error = 1;\n-        return(NULL);\n-    } else {\n-        ret = xmlStrndup(q, cur - q);\n+        while ((IS_CHAR(val)) && (val != '\\'')) {\n+            cur += len;\n+            val = xmlStringCurrentChar(NULL, cur, &len);\n@@ -1355,2 +1258,8 @@\n-    cur += len;\n-    CUR_PTR = cur;\n+        if (!IS_CHAR(val)) {\n+            ctxt->error = 1;\n+            return(NULL);\n+        } else {\n+            ret = xmlStrndup(q, cur - q);\n+        }\n+        cur += len;\n+        CUR_PTR = cur;\n@@ -1358,3 +1267,3 @@\n-    \/* XP_ERROR(XPATH_START_LITERAL_ERROR); *\/\n-    ctxt->error = 1;\n-    return(NULL);\n+        \/* XP_ERROR(XPATH_START_LITERAL_ERROR); *\/\n+        ctxt->error = 1;\n+        return(NULL);\n@@ -1385,1 +1294,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1389,5 +1298,5 @@\n-       (val == '_') ||\n-       (IS_COMBINING(val)) ||\n-       (IS_EXTENDER(val))) {\n-    cur += len;\n-    val = xmlStringCurrentChar(NULL, cur, &len);\n+           (val == '_') ||\n+           (IS_COMBINING(val)) ||\n+           (IS_EXTENDER(val))) {\n+        cur += len;\n+        val = xmlStringCurrentChar(NULL, cur, &len);\n@@ -1419,1 +1328,1 @@\n-        int aid, int novar, xsltAxis axis) {\n+                int aid, int novar, xsltAxis axis) {\n@@ -1424,7 +1333,0 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltCompileIdKeyPattern : ( expected\\n\");\n-    ctxt->error = 1;\n-    return;\n-    }\n-    if ((aid) && (xmlStrEqual(name, (const xmlChar *)\"id\"))) {\n-    if (axis != 0) {\n@@ -1432,1 +1334,1 @@\n-            \"xsltCompileIdKeyPattern : NodeTest expected\\n\");\n+                \"xsltCompileIdKeyPattern : ( expected\\n\");\n@@ -1436,2 +1338,9 @@\n-    NEXT;\n-    SKIP_BLANKS;\n+    if ((aid) && (xmlStrEqual(name, (const xmlChar *)\"id\"))) {\n+        if (axis != 0) {\n+            xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileIdKeyPattern : NodeTest expected\\n\");\n+            ctxt->error = 1;\n+            return;\n+        }\n+        NEXT;\n+        SKIP_BLANKS;\n@@ -1439,16 +1348,17 @@\n-    if (ctxt->error) {\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileIdKeyPattern : Literal expected\\n\");\n-        return;\n-    }\n-    SKIP_BLANKS;\n-    if (CUR != ')') {\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileIdKeyPattern : ) expected\\n\");\n-        xmlFree(lit);\n-        ctxt->error = 1;\n-        return;\n-    }\n-    NEXT;\n-    PUSH(XSLT_OP_ID, lit, NULL, novar);\n-    lit = NULL;\n+        if (ctxt->error) {\n+            xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileIdKeyPattern : Literal expected\\n\");\n+            xmlFree(lit);\n+            return;\n+        }\n+        SKIP_BLANKS;\n+        if (CUR != ')') {\n+            xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileIdKeyPattern : ) expected\\n\");\n+            xmlFree(lit);\n+            ctxt->error = 1;\n+            return;\n+        }\n+        NEXT;\n+        PUSH(XSLT_OP_ID, lit, NULL, novar);\n+        lit = NULL;\n@@ -1456,8 +1366,8 @@\n-    if (axis != 0) {\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileIdKeyPattern : NodeTest expected\\n\");\n-        ctxt->error = 1;\n-        return;\n-    }\n-    NEXT;\n-    SKIP_BLANKS;\n+        if (axis != 0) {\n+            xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileIdKeyPattern : NodeTest expected\\n\");\n+            ctxt->error = 1;\n+            return;\n+        }\n+        NEXT;\n+        SKIP_BLANKS;\n@@ -1465,15 +1375,16 @@\n-    if (ctxt->error) {\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileIdKeyPattern : Literal expected\\n\");\n-        return;\n-    }\n-    SKIP_BLANKS;\n-    if (CUR != ',') {\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileIdKeyPattern : , expected\\n\");\n-        xmlFree(lit);\n-        ctxt->error = 1;\n-        return;\n-    }\n-    NEXT;\n-    SKIP_BLANKS;\n+        if (ctxt->error) {\n+            xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileIdKeyPattern : Literal expected\\n\");\n+            xmlFree(lit);\n+            return;\n+        }\n+        SKIP_BLANKS;\n+        if (CUR != ',') {\n+            xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileIdKeyPattern : , expected\\n\");\n+            xmlFree(lit);\n+            ctxt->error = 1;\n+            return;\n+        }\n+        NEXT;\n+        SKIP_BLANKS;\n@@ -1481,25 +1392,0 @@\n-    if (ctxt->error) {\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileIdKeyPattern : Literal expected\\n\");\n-        xmlFree(lit);\n-        return;\n-    }\n-    SKIP_BLANKS;\n-    if (CUR != ')') {\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileIdKeyPattern : ) expected\\n\");\n-        xmlFree(lit);\n-        xmlFree(lit2);\n-        ctxt->error = 1;\n-        return;\n-    }\n-    NEXT;\n-    \/* URGENT TODO: support namespace in keys *\/\n-    PUSH(XSLT_OP_KEY, lit, lit2, novar);\n-    lit = NULL;\n-    lit2 = NULL;\n-    } else if (xmlStrEqual(name, (const xmlChar *)\"processing-instruction\")) {\n-    NEXT;\n-    SKIP_BLANKS;\n-    if (CUR != ')') {\n-        lit = xsltScanLiteral(ctxt);\n@@ -1507,3 +1393,4 @@\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileIdKeyPattern : Literal expected\\n\");\n-        return;\n+            xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileIdKeyPattern : Literal expected\\n\");\n+            xmlFree(lit);\n+            return;\n@@ -1513,3 +1400,20 @@\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileIdKeyPattern : ) expected\\n\");\n-        ctxt->error = 1;\n+            xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileIdKeyPattern : ) expected\\n\");\n+            xmlFree(lit);\n+            xmlFree(lit2);\n+            ctxt->error = 1;\n+            return;\n+        }\n+        NEXT;\n+        \/* URGENT TODO: support namespace in keys *\/\n+        PUSH(XSLT_OP_KEY, lit, lit2, novar);\n+        lit = NULL;\n+        lit2 = NULL;\n+    } else if (xmlStrEqual(name, (const xmlChar *)\"processing-instruction\")) {\n+        NEXT;\n+        SKIP_BLANKS;\n+        if (CUR != ')') {\n+            lit = xsltScanLiteral(ctxt);\n+            if (ctxt->error) {\n+                xsltTransformError(NULL, NULL, NULL,\n+                        \"xsltCompileIdKeyPattern : Literal expected\\n\");\n@@ -1517,1 +1421,10 @@\n-        return;\n+                return;\n+            }\n+            SKIP_BLANKS;\n+            if (CUR != ')') {\n+                xsltTransformError(NULL, NULL, NULL,\n+                        \"xsltCompileIdKeyPattern : ) expected\\n\");\n+                ctxt->error = 1;\n+                xmlFree(lit);\n+                return;\n+            }\n@@ -1519,4 +1432,3 @@\n-    }\n-    NEXT;\n-    PUSH(XSLT_OP_PI, lit, NULL, novar);\n-    lit = NULL;\n+        NEXT;\n+        PUSH(XSLT_OP_PI, lit, NULL, novar);\n+        lit = NULL;\n@@ -1524,10 +1436,10 @@\n-    NEXT;\n-    SKIP_BLANKS;\n-    if (CUR != ')') {\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileIdKeyPattern : ) expected\\n\");\n-        ctxt->error = 1;\n-        return;\n-    }\n-    NEXT;\n-    PUSH(XSLT_OP_TEXT, NULL, NULL, novar);\n+        NEXT;\n+        SKIP_BLANKS;\n+        if (CUR != ')') {\n+            xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileIdKeyPattern : ) expected\\n\");\n+            ctxt->error = 1;\n+            return;\n+        }\n+        NEXT;\n+        PUSH(XSLT_OP_TEXT, NULL, NULL, novar);\n@@ -1535,3 +1447,27 @@\n-    NEXT;\n-    SKIP_BLANKS;\n-    if (CUR != ')') {\n+        NEXT;\n+        SKIP_BLANKS;\n+        if (CUR != ')') {\n+            xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileIdKeyPattern : ) expected\\n\");\n+            ctxt->error = 1;\n+            return;\n+        }\n+        NEXT;\n+        PUSH(XSLT_OP_COMMENT, NULL, NULL, novar);\n+    } else if (xmlStrEqual(name, (const xmlChar *)\"node\")) {\n+        NEXT;\n+        SKIP_BLANKS;\n+        if (CUR != ')') {\n+            xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileIdKeyPattern : ) expected\\n\");\n+            ctxt->error = 1;\n+            return;\n+        }\n+        NEXT;\n+        if (axis == AXIS_ATTRIBUTE) {\n+            PUSH(XSLT_OP_ATTR, NULL, NULL, novar);\n+        }\n+        else {\n+            PUSH(XSLT_OP_NODE, NULL, NULL, novar);\n+        }\n+    } else if (aid) {\n@@ -1539,1 +1475,1 @@\n-            \"xsltCompileIdKeyPattern : ) expected\\n\");\n+            \"xsltCompileIdKeyPattern : expecting 'key' or 'id' or node type\\n\");\n@@ -1542,7 +1478,1 @@\n-    }\n-    NEXT;\n-    PUSH(XSLT_OP_COMMENT, NULL, NULL, novar);\n-    } else if (xmlStrEqual(name, (const xmlChar *)\"node\")) {\n-    NEXT;\n-    SKIP_BLANKS;\n-    if (CUR != ')') {\n+    } else {\n@@ -1550,1 +1480,1 @@\n-            \"xsltCompileIdKeyPattern : ) expected\\n\");\n+            \"xsltCompileIdKeyPattern : node type\\n\");\n@@ -1554,18 +1484,0 @@\n-    NEXT;\n-    if (axis == AXIS_ATTRIBUTE) {\n-        PUSH(XSLT_OP_ATTR, NULL, NULL, novar);\n-    }\n-    else {\n-        PUSH(XSLT_OP_NODE, NULL, NULL, novar);\n-    }\n-    } else if (aid) {\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltCompileIdKeyPattern : expecting 'key' or 'id' or node type\\n\");\n-    ctxt->error = 1;\n-    return;\n-    } else {\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltCompileIdKeyPattern : node type\\n\");\n-    ctxt->error = 1;\n-    return;\n-    }\n@@ -1608,1 +1520,1 @@\n-    NEXT;\n+        NEXT;\n@@ -1613,1 +1525,1 @@\n-    token = xsltScanNCName(ctxt);\n+        token = xsltScanNCName(ctxt);\n@@ -1615,3 +1527,3 @@\n-    if (CUR == '*') {\n-        NEXT;\n-        if (axis == AXIS_ATTRIBUTE) {\n+        if (CUR == '*') {\n+            NEXT;\n+            if (axis == AXIS_ATTRIBUTE) {\n@@ -1623,7 +1535,7 @@\n-        goto parse_predicate;\n-    } else {\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileStepPattern : Name expected\\n\");\n-        ctxt->error = 1;\n-        goto error;\n-    }\n+            goto parse_predicate;\n+        } else {\n+            xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileStepPattern : Name expected\\n\");\n+            ctxt->error = 1;\n+            goto error;\n+        }\n@@ -1635,5 +1547,5 @@\n-    xsltCompileIdKeyPattern(ctxt, token, 0, novar, axis);\n-    xmlFree(token);\n-    token = NULL;\n-    if (ctxt->error)\n-        goto error;\n+        xsltCompileIdKeyPattern(ctxt, token, 0, novar, axis);\n+        xmlFree(token);\n+        token = NULL;\n+        if (ctxt->error)\n+            goto error;\n@@ -1641,4 +1553,4 @@\n-    NEXT;\n-    if (CUR != ':') {\n-        xmlChar *prefix = token;\n-        xmlNsPtr ns;\n+        NEXT;\n+        if (CUR != ':') {\n+            xmlChar *prefix = token;\n+            xmlNsPtr ns;\n@@ -1646,21 +1558,21 @@\n-        \/*\n-         * This is a namespace match\n-         *\/\n-        token = xsltScanNCName(ctxt);\n-        ns = xmlSearchNs(ctxt->doc, ctxt->elem, prefix);\n-        if (ns == NULL) {\n-        xsltTransformError(NULL, NULL, NULL,\n-        \"xsltCompileStepPattern : no namespace bound to prefix %s\\n\",\n-                 prefix);\n-        xmlFree(prefix);\n-        prefix=NULL;\n-        ctxt->error = 1;\n-        goto error;\n-        } else {\n-        URL = xmlStrdup(ns->href);\n-        }\n-        xmlFree(prefix);\n-        prefix=NULL;\n-        if (token == NULL) {\n-        if (CUR == '*') {\n-            NEXT;\n+            \/*\n+             * This is a namespace match\n+             *\/\n+            token = xsltScanNCName(ctxt);\n+            ns = xmlSearchNs(ctxt->doc, ctxt->elem, prefix);\n+            if (ns == NULL) {\n+                xsltTransformError(NULL, NULL, NULL,\n+            \"xsltCompileStepPattern : no namespace bound to prefix %s\\n\",\n+                                 prefix);\n+                xmlFree(prefix);\n+                prefix=NULL;\n+                ctxt->error = 1;\n+                goto error;\n+            } else {\n+                URL = xmlStrdup(ns->href);\n+            }\n+            xmlFree(prefix);\n+            prefix=NULL;\n+            if (token == NULL) {\n+                if (CUR == '*') {\n+                    NEXT;\n@@ -1669,1 +1581,1 @@\n-            URL = NULL;\n+                        URL = NULL;\n@@ -1673,1 +1585,1 @@\n-            URL = NULL;\n+                        URL = NULL;\n@@ -1675,4 +1587,4 @@\n-        } else {\n-            xsltTransformError(NULL, NULL, NULL,\n-                \"xsltCompileStepPattern : Name expected\\n\");\n-            ctxt->error = 1;\n+                } else {\n+                    xsltTransformError(NULL, NULL, NULL,\n+                            \"xsltCompileStepPattern : Name expected\\n\");\n+                    ctxt->error = 1;\n@@ -1680,3 +1592,3 @@\n-            goto error;\n-        }\n-        } else {\n+                    goto error;\n+                }\n+            } else {\n@@ -1685,2 +1597,2 @@\n-            token = NULL;\n-            URL = NULL;\n+                    token = NULL;\n+                    URL = NULL;\n@@ -1690,2 +1602,2 @@\n-            token = NULL;\n-            URL = NULL;\n+                    token = NULL;\n+                    URL = NULL;\n@@ -1693,13 +1605,1 @@\n-        }\n-    } else {\n-        if (axis != 0) {\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileStepPattern : NodeTest expected\\n\");\n-        ctxt->error = 1;\n-        goto error;\n-        }\n-        NEXT;\n-        if (xmlStrEqual(token, (const xmlChar *) \"child\")) {\n-            axis = AXIS_CHILD;\n-        } else if (xmlStrEqual(token, (const xmlChar *) \"attribute\")) {\n-            axis = AXIS_ATTRIBUTE;\n+            }\n@@ -1707,7 +1607,19 @@\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileStepPattern : 'child' or 'attribute' expected\\n\");\n-        ctxt->error = 1;\n-        goto error;\n-        }\n-        xmlFree(token);\n-        token = NULL;\n+            if (axis != 0) {\n+                xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileStepPattern : NodeTest expected\\n\");\n+                ctxt->error = 1;\n+                goto error;\n+            }\n+            NEXT;\n+            if (xmlStrEqual(token, (const xmlChar *) \"child\")) {\n+                axis = AXIS_CHILD;\n+            } else if (xmlStrEqual(token, (const xmlChar *) \"attribute\")) {\n+                axis = AXIS_ATTRIBUTE;\n+            } else {\n+                xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileStepPattern : 'child' or 'attribute' expected\\n\");\n+                ctxt->error = 1;\n+                goto error;\n+            }\n+            xmlFree(token);\n+            token = NULL;\n@@ -1716,2 +1628,2 @@\n-        goto parse_node_test;\n-    }\n+            goto parse_node_test;\n+        }\n@@ -1719,8 +1631,8 @@\n-    URI = xsltGetQNameURI(ctxt->elem, &token);\n-    if (token == NULL) {\n-        ctxt->error = 1;\n-        goto error;\n-    }\n-    if (URI != NULL)\n-        URL = xmlStrdup(URI);\n-        if (axis == AXIS_ATTRIBUTE) {\n+        URI = xsltGetQNameURI(ctxt->elem, &token);\n+        if (token == NULL) {\n+            ctxt->error = 1;\n+            goto error;\n+        }\n+        if (URI != NULL)\n+            URL = xmlStrdup(URI);\n+        if (axis == AXIS_ATTRIBUTE) {\n@@ -1728,2 +1640,2 @@\n-        token = NULL;\n-        URL = NULL;\n+            token = NULL;\n+            URL = NULL;\n@@ -1733,2 +1645,2 @@\n-        token = NULL;\n-        URL = NULL;\n+            token = NULL;\n+            URL = NULL;\n@@ -1741,2 +1653,2 @@\n-    const xmlChar *q;\n-    xmlChar *ret = NULL;\n+        const xmlChar *q;\n+        xmlChar *ret = NULL;\n@@ -1744,6 +1656,0 @@\n-    level++;\n-    NEXT;\n-    q = CUR_PTR;\n-    while (CUR != 0) {\n-        \/* Skip over nested predicates *\/\n-        if (CUR == '[')\n@@ -1751,5 +1657,0 @@\n-        else if (CUR == ']') {\n-        level--;\n-        if (level == 0)\n-            break;\n-        } else if (CUR == '\"') {\n@@ -1757,5 +1658,18 @@\n-        while ((CUR != 0) && (CUR != '\"'))\n-            NEXT;\n-        } else if (CUR == '\\'') {\n-        NEXT;\n-        while ((CUR != 0) && (CUR != '\\''))\n+        q = CUR_PTR;\n+        while (CUR != 0) {\n+            \/* Skip over nested predicates *\/\n+            if (CUR == '[')\n+                level++;\n+            else if (CUR == ']') {\n+                level--;\n+                if (level == 0)\n+                    break;\n+            } else if (CUR == '\"') {\n+                NEXT;\n+                while ((CUR != 0) && (CUR != '\"'))\n+                    NEXT;\n+            } else if (CUR == '\\'') {\n+                NEXT;\n+                while ((CUR != 0) && (CUR != '\\''))\n+                    NEXT;\n+            }\n@@ -1764,7 +1678,5 @@\n-        NEXT;\n-    }\n-    if (CUR == 0) {\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileStepPattern : ']' expected\\n\");\n-        ctxt->error = 1;\n-        return;\n+        if (CUR == 0) {\n+            xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileStepPattern : ']' expected\\n\");\n+            ctxt->error = 1;\n+            return;\n@@ -1772,7 +1684,7 @@\n-    ret = xmlStrndup(q, CUR_PTR - q);\n-    PUSH(XSLT_OP_PREDICATE, ret, NULL, novar);\n-    ret = NULL;\n-    \/* push the predicate lower than local test *\/\n-    SWAP();\n-    NEXT;\n-    SKIP_BLANKS;\n+        ret = xmlStrndup(q, CUR_PTR - q);\n+        PUSH(XSLT_OP_PREDICATE, ret, NULL, novar);\n+        ret = NULL;\n+        \/* push the predicate lower than local test *\/\n+        SWAP();\n+        NEXT;\n+        SKIP_BLANKS;\n@@ -1783,1 +1695,1 @@\n-    xmlFree(token);\n+        xmlFree(token);\n@@ -1785,1 +1697,1 @@\n-    xmlFree(name);\n+        xmlFree(name);\n@@ -1805,1 +1717,1 @@\n-    goto error;\n+        goto error;\n@@ -1808,9 +1720,16 @@\n-    if ((CUR == '\/') && (NXT(1) == '\/')) {\n-        PUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);\n-        NEXT;\n-        NEXT;\n-        SKIP_BLANKS;\n-        xsltCompileStepPattern(ctxt, NULL, novar);\n-    } else if (CUR == '\/') {\n-        PUSH(XSLT_OP_PARENT, NULL, NULL, novar);\n-        NEXT;\n+        if ((CUR == '\/') && (NXT(1) == '\/')) {\n+            PUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);\n+            NEXT;\n+            NEXT;\n+            SKIP_BLANKS;\n+            xsltCompileStepPattern(ctxt, NULL, novar);\n+        } else if (CUR == '\/') {\n+            PUSH(XSLT_OP_PARENT, NULL, NULL, novar);\n+            NEXT;\n+            SKIP_BLANKS;\n+            xsltCompileStepPattern(ctxt, NULL, novar);\n+        } else {\n+            ctxt->error = 1;\n+        }\n+        if (ctxt->error)\n+            goto error;\n@@ -1818,7 +1737,0 @@\n-        xsltCompileStepPattern(ctxt, NULL, novar);\n-    } else {\n-        ctxt->error = 1;\n-    }\n-    if (ctxt->error)\n-        goto error;\n-    SKIP_BLANKS;\n@@ -1846,41 +1758,4 @@\n-    \/*\n-     * since we reverse the query\n-     * a leading \/\/ can be safely ignored\n-     *\/\n-    NEXT;\n-    NEXT;\n-    ctxt->comp->priority = 0.5; \/* '\/\/' means not 0 priority *\/\n-    xsltCompileRelativePathPattern(ctxt, NULL, novar);\n-    } else if (CUR == '\/') {\n-    \/*\n-     * We need to find root as the parent\n-     *\/\n-    NEXT;\n-    SKIP_BLANKS;\n-    PUSH(XSLT_OP_ROOT, NULL, NULL, novar);\n-    if ((CUR != 0) && (CUR != '|')) {\n-        PUSH(XSLT_OP_PARENT, NULL, NULL, novar);\n-        xsltCompileRelativePathPattern(ctxt, NULL, novar);\n-    }\n-    } else if (CUR == '*') {\n-    xsltCompileRelativePathPattern(ctxt, NULL, novar);\n-    } else if (CUR == '@') {\n-    xsltCompileRelativePathPattern(ctxt, NULL, novar);\n-    } else {\n-    xmlChar *name;\n-    name = xsltScanNCName(ctxt);\n-    if (name == NULL) {\n-        xsltTransformError(NULL, NULL, NULL,\n-            \"xsltCompileLocationPathPattern : Name expected\\n\");\n-        ctxt->error = 1;\n-        return;\n-    }\n-    SKIP_BLANKS;\n-    if ((CUR == '(') && !xmlXPathIsNodeType(name)) {\n-        xsltCompileIdKeyPattern(ctxt, name, 1, novar, 0);\n-        xmlFree(name);\n-        name = NULL;\n-            if (ctxt->error)\n-                return;\n-        if ((CUR == '\/') && (NXT(1) == '\/')) {\n-        PUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);\n+        \/*\n+         * since we reverse the query\n+         * a leading \/\/ can be safely ignored\n+         *\/\n@@ -1889,1 +1764,1 @@\n-        SKIP_BLANKS;\n+        ctxt->comp->priority = 0.5;     \/* '\/\/' means not 0 priority *\/\n@@ -1891,2 +1766,4 @@\n-        } else if (CUR == '\/') {\n-        PUSH(XSLT_OP_PARENT, NULL, NULL, novar);\n+    } else if (CUR == '\/') {\n+        \/*\n+         * We need to find root as the parent\n+         *\/\n@@ -1895,0 +1772,8 @@\n+        PUSH(XSLT_OP_ROOT, NULL, NULL, novar);\n+        if ((CUR != 0) && (CUR != '|')) {\n+            PUSH(XSLT_OP_PARENT, NULL, NULL, novar);\n+            xsltCompileRelativePathPattern(ctxt, NULL, novar);\n+        }\n+    } else if (CUR == '*') {\n+        xsltCompileRelativePathPattern(ctxt, NULL, novar);\n+    } else if (CUR == '@') {\n@@ -1896,0 +1781,8 @@\n+    } else {\n+        xmlChar *name;\n+        name = xsltScanNCName(ctxt);\n+        if (name == NULL) {\n+            xsltTransformError(NULL, NULL, NULL,\n+                    \"xsltCompileLocationPathPattern : Name expected\\n\");\n+            ctxt->error = 1;\n+            return;\n@@ -1897,3 +1790,22 @@\n-        return;\n-    }\n-    xsltCompileRelativePathPattern(ctxt, name, novar);\n+        SKIP_BLANKS;\n+        if ((CUR == '(') && !xmlXPathIsNodeType(name)) {\n+            xsltCompileIdKeyPattern(ctxt, name, 1, novar, 0);\n+            xmlFree(name);\n+            name = NULL;\n+            if (ctxt->error)\n+                return;\n+            if ((CUR == '\/') && (NXT(1) == '\/')) {\n+                PUSH(XSLT_OP_ANCESTOR, NULL, NULL, novar);\n+                NEXT;\n+                NEXT;\n+                SKIP_BLANKS;\n+                xsltCompileRelativePathPattern(ctxt, NULL, novar);\n+            } else if (CUR == '\/') {\n+                PUSH(XSLT_OP_PARENT, NULL, NULL, novar);\n+                NEXT;\n+                SKIP_BLANKS;\n+                xsltCompileRelativePathPattern(ctxt, NULL, novar);\n+            }\n+            return;\n+        }\n+        xsltCompileRelativePathPattern(ctxt, name, novar);\n@@ -1924,2 +1836,2 @@\n-               xmlNodePtr node, xsltStylesheetPtr style,\n-           xsltTransformContextPtr runtime, int novar) {\n+                   xmlNodePtr node, xsltStylesheetPtr style,\n+                   xsltTransformContextPtr runtime, int novar) {\n@@ -1931,3 +1843,3 @@\n-    xsltTransformError(NULL, NULL, node,\n-             \"xsltCompilePattern : NULL pattern\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, node,\n+                         \"xsltCompilePattern : NULL pattern\\n\");\n+        return(NULL);\n@@ -1938,1 +1850,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1943,17 +1855,21 @@\n-    start = current;\n-    while (IS_BLANK_CH(pattern[current]))\n-        current++;\n-    end = current;\n-    level = 0;\n-    while ((pattern[end] != 0) && ((pattern[end] != '|') || (level != 0))) {\n-        if (pattern[end] == '[')\n-        level++;\n-        else if (pattern[end] == ']')\n-        level--;\n-        else if (pattern[end] == '\\'') {\n-        end++;\n-        while ((pattern[end] != 0) && (pattern[end] != '\\''))\n-            end++;\n-        } else if (pattern[end] == '\"') {\n-        end++;\n-        while ((pattern[end] != 0) && (pattern[end] != '\"'))\n+        start = current;\n+        while (IS_BLANK_CH(pattern[current]))\n+            current++;\n+        end = current;\n+        level = 0;\n+        while ((pattern[end] != 0) && ((pattern[end] != '|') || (level != 0))) {\n+            if (pattern[end] == '[')\n+                level++;\n+            else if (pattern[end] == ']')\n+                level--;\n+            else if (pattern[end] == '\\'') {\n+                end++;\n+                while ((pattern[end] != 0) && (pattern[end] != '\\''))\n+                    end++;\n+            } else if (pattern[end] == '\"') {\n+                end++;\n+                while ((pattern[end] != 0) && (pattern[end] != '\"'))\n+                    end++;\n+            }\n+            if (pattern[end] == 0)\n+                break;\n@@ -1962,25 +1878,21 @@\n-        if (pattern[end] == 0)\n-            break;\n-        end++;\n-    }\n-    if (current == end) {\n-        xsltTransformError(NULL, NULL, node,\n-                 \"xsltCompilePattern : NULL pattern\\n\");\n-        goto error;\n-    }\n-    element = xsltNewCompMatch();\n-    if (element == NULL) {\n-        goto error;\n-    }\n-    if (first == NULL)\n-        first = element;\n-    else if (previous != NULL)\n-        previous->next = element;\n-    previous = element;\n-\n-    ctxt->comp = element;\n-    ctxt->base = xmlStrndup(&pattern[start], end - start);\n-    if (ctxt->base == NULL)\n-        goto error;\n-    ctxt->cur = &(ctxt->base)[current - start];\n-    element->pattern = ctxt->base;\n+        if (current == end) {\n+            xsltTransformError(NULL, NULL, node,\n+                             \"xsltCompilePattern : NULL pattern\\n\");\n+            goto error;\n+        }\n+        element = xsltNewCompMatch();\n+        if (element == NULL) {\n+            goto error;\n+        }\n+        if (first == NULL)\n+            first = element;\n+        else if (previous != NULL)\n+            previous->next = element;\n+        previous = element;\n+\n+        ctxt->comp = element;\n+        ctxt->base = xmlStrndup(&pattern[start], end - start);\n+        if (ctxt->base == NULL)\n+            goto error;\n+        ctxt->cur = &(ctxt->base)[current - start];\n+        element->pattern = ctxt->base;\n@@ -1988,7 +1900,7 @@\n-    element->nsList = xmlGetNsList(doc, node);\n-    j = 0;\n-    if (element->nsList != NULL) {\n-        while (element->nsList[j] != NULL)\n-        j++;\n-    }\n-    element->nsNr = j;\n+        element->nsList = xmlGetNsList(doc, node);\n+        j = 0;\n+        if (element->nsList != NULL) {\n+            while (element->nsList[j] != NULL)\n+                j++;\n+        }\n+        element->nsNr = j;\n@@ -1998,3 +1910,3 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltCompilePattern : parsing '%s'\\n\",\n-             element->pattern);\n+        xsltGenericDebug(xsltGenericDebugContext,\n+                         \"xsltCompilePattern : parsing '%s'\\n\",\n+                         element->pattern);\n@@ -2002,13 +1914,13 @@\n-    \/*\n-     Preset default priority to be zero.\n-     This may be changed by xsltCompileLocationPathPattern.\n-     *\/\n-    element->priority = 0;\n-    xsltCompileLocationPathPattern(ctxt, novar);\n-    if (ctxt->error) {\n-        xsltTransformError(NULL, style, node,\n-                 \"xsltCompilePattern : failed to compile '%s'\\n\",\n-                 element->pattern);\n-        if (style != NULL) style->errors++;\n-        goto error;\n-    }\n+        \/*\n+         Preset default priority to be zero.\n+         This may be changed by xsltCompileLocationPathPattern.\n+         *\/\n+        element->priority = 0;\n+        xsltCompileLocationPathPattern(ctxt, novar);\n+        if (ctxt->error) {\n+            xsltTransformError(NULL, style, node,\n+                             \"xsltCompilePattern : failed to compile '%s'\\n\",\n+                             element->pattern);\n+            if (style != NULL) style->errors++;\n+            goto error;\n+        }\n@@ -2016,4 +1928,4 @@\n-    \/*\n-     * Reverse for faster interpretation.\n-     *\/\n-    xsltReverseCompMatch(ctxt, element);\n+        \/*\n+         * Reverse for faster interpretation.\n+         *\/\n+        xsltReverseCompMatch(ctxt, element);\n@@ -2021,32 +1933,33 @@\n-    \/*\n-     * Set-up the priority\n-     *\/\n-    if (element->priority == 0) {   \/* if not yet determined *\/\n-        if (((element->steps[0].op == XSLT_OP_ELEM) ||\n-         (element->steps[0].op == XSLT_OP_ATTR) ||\n-         (element->steps[0].op == XSLT_OP_PI)) &&\n-        (element->steps[0].value != NULL) &&\n-        (element->steps[1].op == XSLT_OP_END)) {\n-        ;   \/* previously preset *\/\n-        } else if ((element->steps[0].op == XSLT_OP_ATTR) &&\n-               (element->steps[0].value2 != NULL) &&\n-               (element->steps[1].op == XSLT_OP_END)) {\n-            element->priority = -0.25;\n-        } else if ((element->steps[0].op == XSLT_OP_NS) &&\n-               (element->steps[0].value != NULL) &&\n-               (element->steps[1].op == XSLT_OP_END)) {\n-            element->priority = -0.25;\n-        } else if ((element->steps[0].op == XSLT_OP_ATTR) &&\n-               (element->steps[0].value == NULL) &&\n-               (element->steps[0].value2 == NULL) &&\n-               (element->steps[1].op == XSLT_OP_END)) {\n-            element->priority = -0.5;\n-        } else if (((element->steps[0].op == XSLT_OP_PI) ||\n-               (element->steps[0].op == XSLT_OP_TEXT) ||\n-               (element->steps[0].op == XSLT_OP_ALL) ||\n-               (element->steps[0].op == XSLT_OP_NODE) ||\n-               (element->steps[0].op == XSLT_OP_COMMENT)) &&\n-               (element->steps[1].op == XSLT_OP_END)) {\n-            element->priority = -0.5;\n-        } else {\n-        element->priority = 0.5;\n+        \/*\n+         * Set-up the priority\n+         *\/\n+        if (element->priority == 0) {   \/* if not yet determined *\/\n+            if (((element->steps[0].op == XSLT_OP_ELEM) ||\n+                 (element->steps[0].op == XSLT_OP_ATTR) ||\n+                 (element->steps[0].op == XSLT_OP_PI)) &&\n+                (element->steps[0].value != NULL) &&\n+                (element->steps[1].op == XSLT_OP_END)) {\n+                ;       \/* previously preset *\/\n+            } else if ((element->steps[0].op == XSLT_OP_ATTR) &&\n+                       (element->steps[0].value2 != NULL) &&\n+                       (element->steps[1].op == XSLT_OP_END)) {\n+                        element->priority = -0.25;\n+            } else if ((element->steps[0].op == XSLT_OP_NS) &&\n+                       (element->steps[0].value != NULL) &&\n+                       (element->steps[1].op == XSLT_OP_END)) {\n+                        element->priority = -0.25;\n+            } else if ((element->steps[0].op == XSLT_OP_ATTR) &&\n+                       (element->steps[0].value == NULL) &&\n+                       (element->steps[0].value2 == NULL) &&\n+                       (element->steps[1].op == XSLT_OP_END)) {\n+                        element->priority = -0.5;\n+            } else if (((element->steps[0].op == XSLT_OP_PI) ||\n+                       (element->steps[0].op == XSLT_OP_TEXT) ||\n+                       (element->steps[0].op == XSLT_OP_ALL) ||\n+                       (element->steps[0].op == XSLT_OP_NODE) ||\n+                       (element->steps[0].op == XSLT_OP_COMMENT)) &&\n+                       (element->steps[1].op == XSLT_OP_END)) {\n+                        element->priority = -0.5;\n+            } else {\n+                element->priority = 0.5;\n+            }\n@@ -2054,1 +1967,0 @@\n-    }\n@@ -2056,3 +1968,3 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltCompilePattern : parsed %s, default priority %f\\n\",\n-             element->pattern, element->priority);\n+        xsltGenericDebug(xsltGenericDebugContext,\n+                     \"xsltCompilePattern : parsed %s, default priority %f\\n\",\n+                         element->pattern, element->priority);\n@@ -2060,3 +1972,3 @@\n-    if (pattern[end] == '|')\n-        end++;\n-    current = end;\n+        if (pattern[end] == '|')\n+            end++;\n+        current = end;\n@@ -2065,4 +1977,4 @@\n-    xsltTransformError(NULL, style, node,\n-             \"xsltCompilePattern : NULL pattern\\n\");\n-    if (style != NULL) style->errors++;\n-    goto error;\n+        xsltTransformError(NULL, style, node,\n+                         \"xsltCompilePattern : NULL pattern\\n\");\n+        if (style != NULL) style->errors++;\n+        goto error;\n@@ -2076,1 +1988,1 @@\n-    xsltFreeParserContext(ctxt);\n+        xsltFreeParserContext(ctxt);\n@@ -2078,1 +1990,1 @@\n-    xsltFreeCompMatchList(first);\n+        xsltFreeCompMatchList(first);\n@@ -2100,2 +2012,2 @@\n-               xmlNodePtr node, xsltStylesheetPtr style,\n-           xsltTransformContextPtr runtime) {\n+                   xmlNodePtr node, xsltStylesheetPtr style,\n+                   xsltTransformContextPtr runtime) {\n@@ -2106,3 +2018,3 @@\n- *                                  *\n- *          Module interfaces               *\n- *                                  *\n+ *                                                                      *\n+ *                      Module interfaces                               *\n+ *                                                                      *\n@@ -2124,1 +2036,1 @@\n-            const xmlChar *mode, const xmlChar *modeURI) {\n+                const xmlChar *mode, const xmlChar *modeURI) {\n@@ -2130,1 +2042,1 @@\n-    void **top = NULL;\n+    xsltCompMatchPtr *top = NULL;\n@@ -2135,1 +2047,4 @@\n-    return(-1);\n+        return(-1);\n+\n+    if (cur->next != NULL)\n+        cur->position = cur->next->position + 1;\n@@ -2166,1 +2081,1 @@\n-    return(0);\n+        return(0);\n@@ -2171,1 +2086,1 @@\n-            style, NULL, 1);\n+                    style, NULL, 1);\n@@ -2173,1 +2088,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2175,11 +2090,3 @@\n-    next = pat->next;\n-    pat->next = NULL;\n-    name = NULL;\n-\n-    pat->template = cur;\n-    if (mode != NULL)\n-        pat->mode = xmlDictLookup(style->dict, mode, -1);\n-    if (modeURI != NULL)\n-        pat->modeURI = xmlDictLookup(style->dict, modeURI, -1);\n-    if (priority != XSLT_PAT_NO_PRIORITY)\n-        pat->priority = priority;\n+        next = pat->next;\n+        pat->next = NULL;\n+        name = NULL;\n@@ -2187,4 +2094,12 @@\n-    \/*\n-     * insert it in the hash table list corresponding to its lookup name\n-     *\/\n-    switch (pat->steps[0].op) {\n+        pat->template = cur;\n+        if (mode != NULL)\n+            pat->mode = xmlDictLookup(style->dict, mode, -1);\n+        if (modeURI != NULL)\n+            pat->modeURI = xmlDictLookup(style->dict, modeURI, -1);\n+        if (priority != XSLT_PAT_NO_PRIORITY)\n+            pat->priority = priority;\n+\n+        \/*\n+         * insert it in the hash table list corresponding to its lookup name\n+         *\/\n+        switch (pat->steps[0].op) {\n@@ -2192,5 +2107,5 @@\n-        if (pat->steps[0].value != NULL)\n-        name = pat->steps[0].value;\n-        else\n-        top = &(style->attrMatch);\n-        break;\n+            if (pat->steps[0].value != NULL)\n+                name = pat->steps[0].value;\n+            else\n+                top = &(style->attrMatch);\n+            break;\n@@ -2199,2 +2114,2 @@\n-        top = &(style->elemMatch);\n-        break;\n+            top = &(style->elemMatch);\n+            break;\n@@ -2202,2 +2117,2 @@\n-        top = &(style->rootMatch);\n-        break;\n+            top = &(style->rootMatch);\n+            break;\n@@ -2205,2 +2120,2 @@\n-        top = &(style->keyMatch);\n-        break;\n+            top = &(style->keyMatch);\n+            break;\n@@ -2208,1 +2123,1 @@\n-        \/* TODO optimize ID !!! *\/\n+            \/* TODO optimize ID !!! *\/\n@@ -2211,2 +2126,2 @@\n-        top = &(style->elemMatch);\n-        break;\n+            top = &(style->elemMatch);\n+            break;\n@@ -2214,33 +2129,3 @@\n-    case XSLT_OP_PREDICATE:\n-        xsltTransformError(NULL, style, NULL,\n-                 \"xsltAddTemplate: invalid compiled pattern\\n\");\n-        xsltFreeCompMatch(pat);\n-        return(-1);\n-        \/*\n-         * TODO: some flags at the top level about type based patterns\n-         *       would be faster than inclusion in the hash table.\n-         *\/\n-    case XSLT_OP_PI:\n-        if (pat->steps[0].value != NULL)\n-        name = pat->steps[0].value;\n-        else\n-        top = &(style->piMatch);\n-        break;\n-    case XSLT_OP_COMMENT:\n-        top = &(style->commentMatch);\n-        break;\n-    case XSLT_OP_TEXT:\n-        top = &(style->textMatch);\n-        break;\n-        case XSLT_OP_ELEM:\n-    case XSLT_OP_NODE:\n-        if (pat->steps[0].value != NULL)\n-        name = pat->steps[0].value;\n-        else\n-        top = &(style->elemMatch);\n-        break;\n-    }\n-    if (name != NULL) {\n-        if (style->templatesHash == NULL) {\n-        style->templatesHash = xmlHashCreate(1024);\n-        if (style->templatesHash == NULL) {\n+        case XSLT_OP_PREDICATE:\n+            xsltTransformError(NULL, style, NULL,\n+                             \"xsltAddTemplate: invalid compiled pattern\\n\");\n@@ -2249,9 +2134,0 @@\n-        }\n-        xmlHashAddEntry3(style->templatesHash, name, mode, modeURI, pat);\n-        } else {\n-        list = (xsltCompMatchPtr) xmlHashLookup3(style->templatesHash,\n-                             name, mode, modeURI);\n-        if (list == NULL) {\n-            xmlHashAddEntry3(style->templatesHash, name,\n-                     mode, modeURI, pat);\n-        } else {\n@@ -2259,3 +2135,2 @@\n-             * Note '<=' since one must choose among the matching\n-             * template rules that are left, the one that occurs\n-             * last in the stylesheet\n+             * TODO: some flags at the top level about type based patterns\n+             *       would be faster than inclusion in the hash table.\n@@ -2263,4 +2138,28 @@\n-            if (list->priority <= pat->priority) {\n-            pat->next = list;\n-            xmlHashUpdateEntry3(style->templatesHash, name,\n-                        mode, modeURI, pat, NULL);\n+        case XSLT_OP_PI:\n+            if (pat->steps[0].value != NULL)\n+                name = pat->steps[0].value;\n+            else\n+                top = &(style->piMatch);\n+            break;\n+        case XSLT_OP_COMMENT:\n+            top = &(style->commentMatch);\n+            break;\n+        case XSLT_OP_TEXT:\n+            top = &(style->textMatch);\n+            break;\n+        case XSLT_OP_ELEM:\n+        case XSLT_OP_NODE:\n+            if (pat->steps[0].value != NULL)\n+                name = pat->steps[0].value;\n+            else\n+                top = &(style->elemMatch);\n+            break;\n+        }\n+        if (name != NULL) {\n+            if (style->templatesHash == NULL) {\n+                style->templatesHash = xmlHashCreate(1024);\n+                if (style->templatesHash == NULL) {\n+                    xsltFreeCompMatch(pat);\n+                    return(-1);\n+                }\n+                xmlHashAddEntry3(style->templatesHash, name, mode, modeURI, pat);\n@@ -2268,4 +2167,25 @@\n-            while (list->next != NULL) {\n-                if (list->next->priority <= pat->priority)\n-                break;\n-                list = list->next;\n+                list = (xsltCompMatchPtr) xmlHashLookup3(style->templatesHash,\n+                                                         name, mode, modeURI);\n+                if (list == NULL) {\n+                    xmlHashAddEntry3(style->templatesHash, name,\n+                                     mode, modeURI, pat);\n+                } else {\n+                    \/*\n+                     * Note '<=' since one must choose among the matching\n+                     * template rules that are left, the one that occurs\n+                     * last in the stylesheet\n+                     *\/\n+                    if (list->priority <= pat->priority) {\n+                        pat->next = list;\n+                        xmlHashUpdateEntry3(style->templatesHash, name,\n+                                            mode, modeURI, pat, NULL);\n+                    } else {\n+                        while (list->next != NULL) {\n+                            if (list->next->priority <= pat->priority)\n+                                break;\n+                            list = list->next;\n+                        }\n+                        pat->next = list->next;\n+                        list->next = pat;\n+                    }\n+                }\n@@ -2273,2 +2193,16 @@\n-            pat->next = list->next;\n-            list->next = pat;\n+        } else if (top != NULL) {\n+            list = *top;\n+            if (list == NULL) {\n+                *top = pat;\n+                pat->next = NULL;\n+            } else if (list->priority <= pat->priority) {\n+                pat->next = list;\n+                *top = pat;\n+            } else {\n+                while (list->next != NULL) {\n+                    if (list->next->priority <= pat->priority)\n+                        break;\n+                    list = list->next;\n+                }\n+                pat->next = list->next;\n+                list->next = pat;\n@@ -2276,10 +2210,0 @@\n-        }\n-        }\n-    } else if (top != NULL) {\n-        list = *top;\n-        if (list == NULL) {\n-        *top = pat;\n-        pat->next = NULL;\n-        } else if (list->priority <= pat->priority) {\n-        pat->next = list;\n-        *top = pat;\n@@ -2287,7 +2211,4 @@\n-        while (list->next != NULL) {\n-            if (list->next->priority <= pat->priority)\n-            break;\n-            list = list->next;\n-        }\n-        pat->next = list->next;\n-        list->next = pat;\n+            xsltTransformError(NULL, style, NULL,\n+                             \"xsltAddTemplate: invalid compiled pattern\\n\");\n+            xsltFreeCompMatch(pat);\n+            return(-1);\n@@ -2295,6 +2216,0 @@\n-    } else {\n-        xsltTransformError(NULL, style, NULL,\n-                 \"xsltAddTemplate: invalid compiled pattern\\n\");\n-        xsltFreeCompMatch(pat);\n-        return(-1);\n-    }\n@@ -2302,8 +2217,8 @@\n-    if (mode)\n-        xsltGenericDebug(xsltGenericDebugContext,\n-             \"added pattern : '%s' mode '%s' priority %f\\n\",\n-                 pat->pattern, pat->mode, pat->priority);\n-    else\n-        xsltGenericDebug(xsltGenericDebugContext,\n-             \"added pattern : '%s' priority %f\\n\",\n-                 pat->pattern, pat->priority);\n+        if (mode)\n+            xsltGenericDebug(xsltGenericDebugContext,\n+                         \"added pattern : '%s' mode '%s' priority %f\\n\",\n+                             pat->pattern, pat->mode, pat->priority);\n+        else\n+            xsltGenericDebug(xsltGenericDebugContext,\n+                         \"added pattern : '%s' priority %f\\n\",\n+                             pat->pattern, pat->priority);\n@@ -2312,1 +2227,1 @@\n-    pat = next;\n+        pat = next;\n@@ -2321,4 +2236,4 @@\n-    xsltTransformError(ctxt, NULL, ctxt->inst,\n-        \"Internal error in xsltComputeAllKeys(): \"\n-        \"Bad arguments.\\n\");\n-    return(-1);\n+        xsltTransformError(ctxt, NULL, ctxt->inst,\n+            \"Internal error in xsltComputeAllKeys(): \"\n+            \"Bad arguments.\\n\");\n+        return(-1);\n@@ -2328,11 +2243,11 @@\n-    \/*\n-    * The document info will only be NULL if we have a RTF.\n-    *\/\n-    if (contextNode->doc->_private != NULL)\n-        goto doc_info_mismatch;\n-    \/*\n-    * On-demand creation of the document info (needed for keys).\n-    *\/\n-    ctxt->document = xsltNewDocument(ctxt, contextNode->doc);\n-    if (ctxt->document == NULL)\n-        return(-1);\n+        \/*\n+        * The document info will only be NULL if we have a RTF.\n+        *\/\n+        if (contextNode->doc->_private != NULL)\n+            goto doc_info_mismatch;\n+        \/*\n+        * On-demand creation of the document info (needed for keys).\n+        *\/\n+        ctxt->document = xsltNewDocument(ctxt, contextNode->doc);\n+        if (ctxt->document == NULL)\n+            return(-1);\n@@ -2344,3 +2259,3 @@\n-    \"Internal error in xsltComputeAllKeys(): \"\n-    \"The context's document info doesn't match the \"\n-    \"document info of the current result tree.\\n\");\n+        \"Internal error in xsltComputeAllKeys(): \"\n+        \"The context's document info doesn't match the \"\n+        \"document info of the current result tree.\\n\");\n@@ -2364,1 +2279,1 @@\n-            xsltStylesheetPtr style)\n+                xsltStylesheetPtr style)\n@@ -2374,1 +2289,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2377,1 +2292,1 @@\n-    curstyle = ctxt->style;\n+        curstyle = ctxt->style;\n@@ -2379,1 +2294,1 @@\n-    curstyle = xsltNextImport(style);\n+        curstyle = xsltNextImport(style);\n@@ -2383,10 +2298,10 @@\n-    priority = XSLT_PAT_NO_PRIORITY;\n-    \/* TODO : handle IDs\/keys here ! *\/\n-    if (curstyle->templatesHash != NULL) {\n-        \/*\n-         * Use the top name as selector\n-         *\/\n-        switch (node->type) {\n-        case XML_ELEMENT_NODE:\n-            if (node->name[0] == ' ')\n-            break;\n+        priority = XSLT_PAT_NO_PRIORITY;\n+        \/* TODO : handle IDs\/keys here ! *\/\n+        if (curstyle->templatesHash != NULL) {\n+            \/*\n+             * Use the top name as selector\n+             *\/\n+            switch (node->type) {\n+                case XML_ELEMENT_NODE:\n+                    if (node->name[0] == ' ')\n+                        break;\n@@ -2394,24 +2309,24 @@\n-        case XML_ATTRIBUTE_NODE:\n-        case XML_PI_NODE:\n-            name = node->name;\n-            break;\n-        case XML_DOCUMENT_NODE:\n-        case XML_HTML_DOCUMENT_NODE:\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        case XML_COMMENT_NODE:\n-        case XML_ENTITY_REF_NODE:\n-        case XML_ENTITY_NODE:\n-        case XML_DOCUMENT_TYPE_NODE:\n-        case XML_DOCUMENT_FRAG_NODE:\n-        case XML_NOTATION_NODE:\n-        case XML_DTD_NODE:\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_ENTITY_DECL:\n-        case XML_NAMESPACE_DECL:\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-            break;\n-        default:\n-            return(NULL);\n+                case XML_ATTRIBUTE_NODE:\n+                case XML_PI_NODE:\n+                    name = node->name;\n+                    break;\n+                case XML_DOCUMENT_NODE:\n+                case XML_HTML_DOCUMENT_NODE:\n+                case XML_TEXT_NODE:\n+                case XML_CDATA_SECTION_NODE:\n+                case XML_COMMENT_NODE:\n+                case XML_ENTITY_REF_NODE:\n+                case XML_ENTITY_NODE:\n+                case XML_DOCUMENT_TYPE_NODE:\n+                case XML_DOCUMENT_FRAG_NODE:\n+                case XML_NOTATION_NODE:\n+                case XML_DTD_NODE:\n+                case XML_ELEMENT_DECL:\n+                case XML_ATTRIBUTE_DECL:\n+                case XML_ENTITY_DECL:\n+                case XML_NAMESPACE_DECL:\n+                case XML_XINCLUDE_START:\n+                case XML_XINCLUDE_END:\n+                    break;\n+                default:\n+                    return(NULL);\n@@ -2419,0 +2334,1 @@\n+            }\n@@ -2420,2 +2336,19 @@\n-    }\n-    if (name != NULL) {\n+        if (name != NULL) {\n+            \/*\n+             * find the list of applicable expressions based on the name\n+             *\/\n+            list = (xsltCompMatchPtr) xmlHashLookup3(curstyle->templatesHash,\n+                                             name, ctxt->mode, ctxt->modeURI);\n+        } else\n+            list = NULL;\n+        while (list != NULL) {\n+            if (xsltTestCompMatch(ctxt, list, node,\n+                                  ctxt->mode, ctxt->modeURI) == 1) {\n+                ret = list->template;\n+                priority = list->priority;\n+                break;\n+            }\n+            list = list->next;\n+        }\n+        list = NULL;\n+\n@@ -2423,1 +2356,1 @@\n-         * find the list of applicable expressions based on the name\n+         * find alternate generic matches\n@@ -2425,14 +2358,10 @@\n-        list = (xsltCompMatchPtr) xmlHashLookup3(curstyle->templatesHash,\n-                         name, ctxt->mode, ctxt->modeURI);\n-    } else\n-        list = NULL;\n-    while (list != NULL) {\n-        if (xsltTestCompMatch(ctxt, list, node,\n-                      ctxt->mode, ctxt->modeURI) == 1) {\n-        ret = list->template;\n-        priority = list->priority;\n-        break;\n-        }\n-        list = list->next;\n-    }\n-    list = NULL;\n+        switch (node->type) {\n+            case XML_ELEMENT_NODE:\n+                if (node->name[0] == ' ')\n+                    list = curstyle->rootMatch;\n+                else\n+                    list = curstyle->elemMatch;\n+                if (node->psvi != NULL) keyed = 1;\n+                break;\n+            case XML_ATTRIBUTE_NODE: {\n+                xmlAttrPtr attr;\n@@ -2440,83 +2369,42 @@\n-    \/*\n-     * find alternate generic matches\n-     *\/\n-    switch (node->type) {\n-        case XML_ELEMENT_NODE:\n-        if (node->name[0] == ' ')\n-            list = curstyle->rootMatch;\n-        else\n-            list = curstyle->elemMatch;\n-        if (node->psvi != NULL) keyed = 1;\n-        break;\n-        case XML_ATTRIBUTE_NODE: {\n-            xmlAttrPtr attr;\n-\n-        list = curstyle->attrMatch;\n-        attr = (xmlAttrPtr) node;\n-        if (attr->psvi != NULL) keyed = 1;\n-        break;\n-        }\n-        case XML_PI_NODE:\n-        list = curstyle->piMatch;\n-        if (node->psvi != NULL) keyed = 1;\n-        break;\n-        case XML_DOCUMENT_NODE:\n-        case XML_HTML_DOCUMENT_NODE: {\n-            xmlDocPtr doc;\n-\n-        list = curstyle->rootMatch;\n-        doc = (xmlDocPtr) node;\n-        if (doc->psvi != NULL) keyed = 1;\n-        break;\n-        }\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        list = curstyle->textMatch;\n-        if (node->psvi != NULL) keyed = 1;\n-        break;\n-        case XML_COMMENT_NODE:\n-        list = curstyle->commentMatch;\n-        if (node->psvi != NULL) keyed = 1;\n-        break;\n-        case XML_ENTITY_REF_NODE:\n-        case XML_ENTITY_NODE:\n-        case XML_DOCUMENT_TYPE_NODE:\n-        case XML_DOCUMENT_FRAG_NODE:\n-        case XML_NOTATION_NODE:\n-        case XML_DTD_NODE:\n-        case XML_ELEMENT_DECL:\n-        case XML_ATTRIBUTE_DECL:\n-        case XML_ENTITY_DECL:\n-        case XML_NAMESPACE_DECL:\n-        case XML_XINCLUDE_START:\n-        case XML_XINCLUDE_END:\n-        break;\n-        default:\n-        break;\n-    }\n-    while ((list != NULL) &&\n-           ((ret == NULL)  || (list->priority > priority))) {\n-        if (xsltTestCompMatch(ctxt, list, node,\n-                      ctxt->mode, ctxt->modeURI) == 1) {\n-        ret = list->template;\n-        priority = list->priority;\n-        break;\n-        }\n-        list = list->next;\n-    }\n-    \/*\n-     * Some of the tests for elements can also apply to documents\n-     *\/\n-    if ((node->type == XML_DOCUMENT_NODE) ||\n-        (node->type == XML_HTML_DOCUMENT_NODE) ||\n-        (node->type == XML_TEXT_NODE)) {\n-        list = curstyle->elemMatch;\n-        while ((list != NULL) &&\n-           ((ret == NULL)  || (list->priority > priority))) {\n-        if (xsltTestCompMatch(ctxt, list, node,\n-                      ctxt->mode, ctxt->modeURI) == 1) {\n-            ret = list->template;\n-            priority = list->priority;\n-            break;\n-        }\n-        list = list->next;\n+                list = curstyle->attrMatch;\n+                attr = (xmlAttrPtr) node;\n+                if (attr->psvi != NULL) keyed = 1;\n+                break;\n+            }\n+            case XML_PI_NODE:\n+                list = curstyle->piMatch;\n+                if (node->psvi != NULL) keyed = 1;\n+                break;\n+            case XML_DOCUMENT_NODE:\n+            case XML_HTML_DOCUMENT_NODE: {\n+                xmlDocPtr doc;\n+\n+                list = curstyle->rootMatch;\n+                doc = (xmlDocPtr) node;\n+                if (doc->psvi != NULL) keyed = 1;\n+                break;\n+            }\n+            case XML_TEXT_NODE:\n+            case XML_CDATA_SECTION_NODE:\n+                list = curstyle->textMatch;\n+                if (node->psvi != NULL) keyed = 1;\n+                break;\n+            case XML_COMMENT_NODE:\n+                list = curstyle->commentMatch;\n+                if (node->psvi != NULL) keyed = 1;\n+                break;\n+            case XML_ENTITY_REF_NODE:\n+            case XML_ENTITY_NODE:\n+            case XML_DOCUMENT_TYPE_NODE:\n+            case XML_DOCUMENT_FRAG_NODE:\n+            case XML_NOTATION_NODE:\n+            case XML_DTD_NODE:\n+            case XML_ELEMENT_DECL:\n+            case XML_ATTRIBUTE_DECL:\n+            case XML_ENTITY_DECL:\n+            case XML_NAMESPACE_DECL:\n+            case XML_XINCLUDE_START:\n+            case XML_XINCLUDE_END:\n+                break;\n+            default:\n+                break;\n@@ -2524,3 +2412,0 @@\n-    } else if ((node->type == XML_PI_NODE) ||\n-           (node->type == XML_COMMENT_NODE)) {\n-        list = curstyle->elemMatch;\n@@ -2528,6 +2413,11 @@\n-           ((ret == NULL)  || (list->priority > priority))) {\n-        if (xsltTestCompMatch(ctxt, list, node,\n-                      ctxt->mode, ctxt->modeURI) == 1) {\n-            ret = list->template;\n-            priority = list->priority;\n-            break;\n+               ((ret == NULL) ||\n+                (list->priority > priority) ||\n+                ((list->priority == priority) &&\n+                 (list->template->position > ret->position)))) {\n+            if (xsltTestCompMatch(ctxt, list, node,\n+                                  ctxt->mode, ctxt->modeURI) == 1) {\n+                ret = list->template;\n+                priority = list->priority;\n+                break;\n+            }\n+            list = list->next;\n@@ -2535,1 +2425,36 @@\n-        list = list->next;\n+        \/*\n+         * Some of the tests for elements can also apply to documents\n+         *\/\n+        if ((node->type == XML_DOCUMENT_NODE) ||\n+            (node->type == XML_HTML_DOCUMENT_NODE) ||\n+            (node->type == XML_TEXT_NODE)) {\n+            list = curstyle->elemMatch;\n+            while ((list != NULL) &&\n+                   ((ret == NULL) ||\n+                    (list->priority > priority) ||\n+                    ((list->priority == priority) &&\n+                     (list->template->position > ret->position)))) {\n+                if (xsltTestCompMatch(ctxt, list, node,\n+                                      ctxt->mode, ctxt->modeURI) == 1) {\n+                    ret = list->template;\n+                    priority = list->priority;\n+                    break;\n+                }\n+                list = list->next;\n+            }\n+        } else if ((node->type == XML_PI_NODE) ||\n+                   (node->type == XML_COMMENT_NODE)) {\n+            list = curstyle->elemMatch;\n+            while ((list != NULL) &&\n+                   ((ret == NULL) ||\n+                    (list->priority > priority) ||\n+                    ((list->priority == priority) &&\n+                     (list->template->position > ret->position)))) {\n+                if (xsltTestCompMatch(ctxt, list, node,\n+                                      ctxt->mode, ctxt->modeURI) == 1) {\n+                    ret = list->template;\n+                    priority = list->priority;\n+                    break;\n+                }\n+                list = list->next;\n+            }\n@@ -2537,1 +2462,0 @@\n-    }\n@@ -2540,11 +2464,15 @@\n-    if (keyed) {\n-        list = curstyle->keyMatch;\n-        while ((list != NULL) &&\n-           ((ret == NULL)  || (list->priority > priority))) {\n-        if (xsltTestCompMatch(ctxt, list, node,\n-                      ctxt->mode, ctxt->modeURI) == 1) {\n-            ret = list->template;\n-            priority = list->priority;\n-            break;\n-        }\n-        list = list->next;\n+        if (keyed) {\n+            list = curstyle->keyMatch;\n+            while ((list != NULL) &&\n+                   ((ret == NULL) ||\n+                    (list->priority > priority) ||\n+                    ((list->priority == priority) &&\n+                     (list->template->position > ret->position)))) {\n+                if (xsltTestCompMatch(ctxt, list, node,\n+                                      ctxt->mode, ctxt->modeURI) == 1) {\n+                    ret = list->template;\n+                    priority = list->priority;\n+                    break;\n+                }\n+                list = list->next;\n+            }\n@@ -2552,32 +2480,34 @@\n-    }\n-    else if (ctxt->hasTemplKeyPatterns &&\n-        ((ctxt->document == NULL) ||\n-         (ctxt->document->nbKeysComputed < ctxt->nbKeys)))\n-    {\n-        \/*\n-        * Compute all remaining keys for this document.\n-        *\n-        * REVISIT TODO: I think this could be further optimized.\n-        *\/\n-        if (xsltComputeAllKeys(ctxt, node) == -1)\n-        goto error;\n-\n-        switch (node->type) {\n-        case XML_ELEMENT_NODE:\n-            if (node->psvi != NULL) keyed = 1;\n-            break;\n-        case XML_ATTRIBUTE_NODE:\n-            if (((xmlAttrPtr) node)->psvi != NULL) keyed = 1;\n-            break;\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        case XML_COMMENT_NODE:\n-        case XML_PI_NODE:\n-            if (node->psvi != NULL) keyed = 1;\n-            break;\n-        case XML_DOCUMENT_NODE:\n-        case XML_HTML_DOCUMENT_NODE:\n-            if (((xmlDocPtr) node)->psvi != NULL) keyed = 1;\n-            break;\n-        default:\n-            break;\n+        else if (ctxt->hasTemplKeyPatterns &&\n+            ((ctxt->document == NULL) ||\n+             (ctxt->document->nbKeysComputed < ctxt->nbKeys)))\n+        {\n+            \/*\n+            * Compute all remaining keys for this document.\n+            *\n+            * REVISIT TODO: I think this could be further optimized.\n+            *\/\n+            if (xsltComputeAllKeys(ctxt, node) == -1)\n+                goto error;\n+\n+            switch (node->type) {\n+                case XML_ELEMENT_NODE:\n+                    if (node->psvi != NULL) keyed = 1;\n+                    break;\n+                case XML_ATTRIBUTE_NODE:\n+                    if (((xmlAttrPtr) node)->psvi != NULL) keyed = 1;\n+                    break;\n+                case XML_TEXT_NODE:\n+                case XML_CDATA_SECTION_NODE:\n+                case XML_COMMENT_NODE:\n+                case XML_PI_NODE:\n+                    if (node->psvi != NULL) keyed = 1;\n+                    break;\n+                case XML_DOCUMENT_NODE:\n+                case XML_HTML_DOCUMENT_NODE:\n+                    if (((xmlDocPtr) node)->psvi != NULL) keyed = 1;\n+                    break;\n+                default:\n+                    break;\n+            }\n+            if (keyed)\n+                goto keyed_match;\n@@ -2585,5 +2515,2 @@\n-        if (keyed)\n-        goto keyed_match;\n-    }\n-    if (ret != NULL)\n-        return(ret);\n+        if (ret != NULL)\n+            return(ret);\n@@ -2591,4 +2518,4 @@\n-    \/*\n-     * Cycle on next curstylesheet import.\n-     *\/\n-    curstyle = xsltNextImport(curstyle);\n+        \/*\n+         * Cycle on next curstylesheet import.\n+         *\/\n+        curstyle = xsltNextImport(curstyle);\n@@ -2621,2 +2548,1 @@\n-    xmlHashFree((xmlHashTablePtr) style->templatesHash,\n-            xsltFreeCompMatchListEntry);\n+        xmlHashFree(style->templatesHash, xsltFreeCompMatchListEntry);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/pattern.c","additions":1364,"deletions":1438,"binary":false,"changes":2802,"status":"modified"},{"patch":"@@ -36,5 +36,5 @@\n-        xsltCompilePattern  (const xmlChar *pattern,\n-                     xmlDocPtr doc,\n-                     xmlNodePtr node,\n-                     xsltStylesheetPtr style,\n-                     xsltTransformContextPtr runtime);\n+                xsltCompilePattern      (const xmlChar *pattern,\n+                                         xmlDocPtr doc,\n+                                         xmlNodePtr node,\n+                                         xsltStylesheetPtr style,\n+                                         xsltTransformContextPtr runtime);\n@@ -42,1 +42,1 @@\n-        xsltFreeCompMatchList   (xsltCompMatchPtr comp);\n+                xsltFreeCompMatchList   (xsltCompMatchPtr comp);\n@@ -44,3 +44,3 @@\n-        xsltTestCompMatchList   (xsltTransformContextPtr ctxt,\n-                     xmlNodePtr node,\n-                     xsltCompMatchPtr comp);\n+                xsltTestCompMatchList   (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xsltCompMatchPtr comp);\n@@ -48,2 +48,2 @@\n-        xsltCompMatchClearCache (xsltTransformContextPtr ctxt,\n-                     xsltCompMatchPtr comp);\n+                xsltCompMatchClearCache (xsltTransformContextPtr ctxt,\n+                                         xsltCompMatchPtr comp);\n@@ -51,3 +51,3 @@\n-        xsltNormalizeCompSteps  (void *payload,\n-                     void *data,\n-                     const xmlChar *name);\n+                xsltNormalizeCompSteps  (void *payload,\n+                                         void *data,\n+                                         const xmlChar *name);\n@@ -59,4 +59,4 @@\n-        xsltAddTemplate     (xsltStylesheetPtr style,\n-                     xsltTemplatePtr cur,\n-                     const xmlChar *mode,\n-                     const xmlChar *modeURI);\n+                xsltAddTemplate         (xsltStylesheetPtr style,\n+                                         xsltTemplatePtr cur,\n+                                         const xmlChar *mode,\n+                                         const xmlChar *modeURI);\n@@ -64,3 +64,3 @@\n-        xsltGetTemplate     (xsltTransformContextPtr ctxt,\n-                     xmlNodePtr node,\n-                     xsltStylesheetPtr style);\n+                xsltGetTemplate         (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xsltStylesheetPtr style);\n@@ -68,1 +68,1 @@\n-        xsltFreeTemplateHashes  (xsltStylesheetPtr style);\n+                xsltFreeTemplateHashes  (xsltStylesheetPtr style);\n@@ -70,1 +70,1 @@\n-        xsltCleanupTemplates    (xsltStylesheetPtr style);\n+                xsltCleanupTemplates    (xsltStylesheetPtr style);\n@@ -73,5 +73,5 @@\n-int     xsltMatchPattern    (xsltTransformContextPtr ctxt,\n-                     xmlNodePtr node,\n-                     const xmlChar *pattern,\n-                     xmlDocPtr ctxtdoc,\n-                     xmlNodePtr ctxtnode);\n+int             xsltMatchPattern        (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         const xmlChar *pattern,\n+                                         xmlDocPtr ctxtdoc,\n+                                         xmlNodePtr ctxtnode);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/pattern.h","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -51,3 +51,3 @@\n- *                                  *\n- *          Grammar checks                  *\n- *                                  *\n+ *                                                                      *\n+ *                      Grammar checks                                  *\n+ *                                                                      *\n@@ -80,5 +80,5 @@\n-        xsltTransformError(NULL, style, inst,\n-            \"internal problem: element has no parent\\n\");\n-        style->errors++;\n-    }\n-    return(0);\n+            xsltTransformError(NULL, style, inst,\n+                    \"internal problem: element has no parent\\n\");\n+            style->errors++;\n+        }\n+        return(0);\n@@ -88,10 +88,10 @@\n-     (!xmlStrEqual(parent->ns->href, inst->ns->href))) ||\n-    ((!xmlStrEqual(parent->name, BAD_CAST \"stylesheet\")) &&\n-     (!xmlStrEqual(parent->name, BAD_CAST \"transform\")))) {\n-    if (err) {\n-        xsltTransformError(NULL, style, inst,\n-            \"element %s only allowed as child of stylesheet\\n\",\n-                   inst->name);\n-        style->errors++;\n-    }\n-    return(0);\n+         (!xmlStrEqual(parent->ns->href, inst->ns->href))) ||\n+        ((!xmlStrEqual(parent->name, BAD_CAST \"stylesheet\")) &&\n+         (!xmlStrEqual(parent->name, BAD_CAST \"transform\")))) {\n+        if (err) {\n+            xsltTransformError(NULL, style, inst,\n+                    \"element %s only allowed as child of stylesheet\\n\",\n+                               inst->name);\n+            style->errors++;\n+        }\n+        return(0);\n@@ -122,4 +122,4 @@\n-    xsltTransformError(NULL, style, inst,\n-        \"internal problem: element has no parent\\n\");\n-    style->errors++;\n-    return;\n+        xsltTransformError(NULL, style, inst,\n+                \"internal problem: element has no parent\\n\");\n+        style->errors++;\n+        return;\n@@ -129,8 +129,8 @@\n-         ((parent->ns != NULL) &&\n-          (xmlStrEqual(parent->ns->href, inst->ns->href)))) &&\n-        ((xmlStrEqual(parent->name, BAD_CAST \"template\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"param\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"attribute\")) ||\n-         (xmlStrEqual(parent->name, BAD_CAST \"variable\")))) {\n-        return;\n-    }\n+             ((parent->ns != NULL) &&\n+              (xmlStrEqual(parent->ns->href, inst->ns->href)))) &&\n+            ((xmlStrEqual(parent->name, BAD_CAST \"template\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"param\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"attribute\")) ||\n+             (xmlStrEqual(parent->name, BAD_CAST \"variable\")))) {\n+            return;\n+        }\n@@ -138,7 +138,7 @@\n-    \/*\n-     * if we are within an extension element all bets are off\n-     * about the semantic there e.g. xsl:param within func:function\n-     *\/\n-    if ((has_ext) && (parent->ns != NULL) &&\n-        (xmlHashLookup(style->extInfos, parent->ns->href) != NULL))\n-        return;\n+        \/*\n+         * if we are within an extension element all bets are off\n+         * about the semantic there e.g. xsl:param within func:function\n+         *\/\n+        if ((has_ext) && (parent->ns != NULL) &&\n+            (xmlHashLookup(style->extInfos, parent->ns->href) != NULL))\n+            return;\n@@ -149,2 +149,2 @@\n-        \"element %s only allowed within a template, variable or param\\n\",\n-                   inst->name);\n+            \"element %s only allowed within a template, variable or param\\n\",\n+                           inst->name);\n@@ -175,4 +175,4 @@\n-    xsltTransformError(NULL, style, inst,\n-        \"internal problem: element has no parent\\n\");\n-    style->errors++;\n-    return;\n+        xsltTransformError(NULL, style, inst,\n+                \"internal problem: element has no parent\\n\");\n+        style->errors++;\n+        return;\n@@ -181,5 +181,5 @@\n-     ((parent->ns != NULL) &&\n-      (xmlStrEqual(parent->ns->href, inst->ns->href)))) &&\n-    ((xmlStrEqual(parent->name, allow1)) ||\n-     (xmlStrEqual(parent->name, allow2)))) {\n-    return;\n+         ((parent->ns != NULL) &&\n+          (xmlStrEqual(parent->ns->href, inst->ns->href)))) &&\n+        ((xmlStrEqual(parent->name, allow1)) ||\n+         (xmlStrEqual(parent->name, allow2)))) {\n+        return;\n@@ -189,11 +189,11 @@\n-    while ((parent != NULL) && (parent->type != XML_DOCUMENT_NODE)) {\n-        \/*\n-         * if we are within an extension element all bets are off\n-         * about the semantic there e.g. xsl:param within func:function\n-         *\/\n-        if ((parent->ns != NULL) &&\n-        (xmlHashLookup(style->extInfos, parent->ns->href) != NULL))\n-        return;\n-\n-        parent = parent->parent;\n-    }\n+        while ((parent != NULL) && (parent->type != XML_DOCUMENT_NODE)) {\n+            \/*\n+             * if we are within an extension element all bets are off\n+             * about the semantic there e.g. xsl:param within func:function\n+             *\/\n+            if ((parent->ns != NULL) &&\n+                (xmlHashLookup(style->extInfos, parent->ns->href) != NULL))\n+                return;\n+\n+            parent = parent->parent;\n+        }\n@@ -202,2 +202,2 @@\n-               \"element %s is not allowed within that context\\n\",\n-               inst->name);\n+                       \"element %s is not allowed within that context\\n\",\n+                       inst->name);\n@@ -209,3 +209,3 @@\n- *                                  *\n- *          handling of precomputed data            *\n- *                                  *\n+ *                                                                      *\n+ *                      handling of precomputed data                    *\n+ *                                                                      *\n@@ -274,15 +274,15 @@\n-    case XSLT_FUNC_WITHPARAM:\n-        size = sizeof(xsltStyleItemWithParam); break;\n-    case XSLT_FUNC_PARAM:\n-        size = sizeof(xsltStyleItemParam); break;\n-    case XSLT_FUNC_VARIABLE:\n-        size = sizeof(xsltStyleItemVariable); break;\n-    case XSLT_FUNC_WHEN:\n-        size = sizeof(xsltStyleItemWhen); break;\n-    case XSLT_FUNC_OTHERWISE:\n-        size = sizeof(xsltStyleItemOtherwise); break;\n-    default:\n-        xsltTransformError(NULL, style, NULL,\n-            \"xsltNewStylePreComp : invalid type %d\\n\", type);\n-        style->errors++;\n-        return(NULL);\n+        case XSLT_FUNC_WITHPARAM:\n+            size = sizeof(xsltStyleItemWithParam); break;\n+        case XSLT_FUNC_PARAM:\n+            size = sizeof(xsltStyleItemParam); break;\n+        case XSLT_FUNC_VARIABLE:\n+            size = sizeof(xsltStyleItemVariable); break;\n+        case XSLT_FUNC_WHEN:\n+            size = sizeof(xsltStyleItemWhen); break;\n+        case XSLT_FUNC_OTHERWISE:\n+            size = sizeof(xsltStyleItemOtherwise); break;\n+        default:\n+            xsltTransformError(NULL, style, NULL,\n+                    \"xsltNewStylePreComp : invalid type %d\\n\", type);\n+            style->errors++;\n+            return(NULL);\n@@ -295,4 +295,4 @@\n-    xsltTransformError(NULL, style, NULL,\n-        \"xsltNewStylePreComp : malloc failed\\n\");\n-    style->errors++;\n-    return(NULL);\n+        xsltTransformError(NULL, style, NULL,\n+                \"xsltNewStylePreComp : malloc failed\\n\");\n+        style->errors++;\n+        return(NULL);\n@@ -308,4 +308,4 @@\n-    xsltTransformError(NULL, style, NULL,\n-        \"xsltNewStylePreComp : malloc failed\\n\");\n-    style->errors++;\n-    return(NULL);\n+        xsltTransformError(NULL, style, NULL,\n+                \"xsltNewStylePreComp : malloc failed\\n\");\n+        style->errors++;\n+        return(NULL);\n@@ -335,1 +335,1 @@\n-        break;\n+            break;\n@@ -356,11 +356,11 @@\n-    case XSLT_FUNC_WITHPARAM:\n-    case XSLT_FUNC_PARAM:\n-    case XSLT_FUNC_VARIABLE:\n-    case XSLT_FUNC_WHEN:\n-        break;\n-    default:\n-    if (cur->func == NULL) {\n-        xsltTransformError(NULL, style, NULL,\n-            \"xsltNewStylePreComp : no function for type %d\\n\", type);\n-        style->errors++;\n-    }\n+        case XSLT_FUNC_WITHPARAM:\n+        case XSLT_FUNC_PARAM:\n+        case XSLT_FUNC_VARIABLE:\n+        case XSLT_FUNC_WHEN:\n+            break;\n+        default:\n+        if (cur->func == NULL) {\n+            xsltTransformError(NULL, style, NULL,\n+                    \"xsltNewStylePreComp : no function for type %d\\n\", type);\n+            style->errors++;\n+        }\n@@ -383,1 +383,1 @@\n-    return;\n+        return;\n@@ -389,3 +389,3 @@\n-    case XSLT_FUNC_LITERAL_RESULT_ELEMENT:\n-        break;\n-    case XSLT_FUNC_COPY:\n+        case XSLT_FUNC_LITERAL_RESULT_ELEMENT:\n+            break;\n+        case XSLT_FUNC_COPY:\n@@ -394,6 +394,6 @@\n-        xsltStyleItemSortPtr item = (xsltStyleItemSortPtr) comp;\n-        if (item->locale != (xsltLocale)0)\n-            xsltFreeLocale(item->locale);\n-        if (item->comp != NULL)\n-            xmlXPathFreeCompExpr(item->comp);\n-        }\n+                xsltStyleItemSortPtr item = (xsltStyleItemSortPtr) comp;\n+                if (item->locale != (xsltLocale)0)\n+                    xsltFreeLocale(item->locale);\n+                if (item->comp != NULL)\n+                    xmlXPathFreeCompExpr(item->comp);\n+            }\n@@ -410,1 +410,1 @@\n-        break;\n+            break;\n@@ -412,4 +412,4 @@\n-        xsltStyleItemCopyOfPtr item = (xsltStyleItemCopyOfPtr) comp;\n-        if (item->comp != NULL)\n-            xmlXPathFreeCompExpr(item->comp);\n-        }\n+                xsltStyleItemCopyOfPtr item = (xsltStyleItemCopyOfPtr) comp;\n+                if (item->comp != NULL)\n+                    xmlXPathFreeCompExpr(item->comp);\n+            }\n@@ -418,4 +418,4 @@\n-        xsltStyleItemValueOfPtr item = (xsltStyleItemValueOfPtr) comp;\n-        if (item->comp != NULL)\n-            xmlXPathFreeCompExpr(item->comp);\n-        }\n+                xsltStyleItemValueOfPtr item = (xsltStyleItemValueOfPtr) comp;\n+                if (item->comp != NULL)\n+                    xmlXPathFreeCompExpr(item->comp);\n+            }\n@@ -436,5 +436,5 @@\n-        xsltStyleItemApplyTemplatesPtr item =\n-            (xsltStyleItemApplyTemplatesPtr) comp;\n-        if (item->comp != NULL)\n-            xmlXPathFreeCompExpr(item->comp);\n-        }\n+                xsltStyleItemApplyTemplatesPtr item =\n+                    (xsltStyleItemApplyTemplatesPtr) comp;\n+                if (item->comp != NULL)\n+                    xmlXPathFreeCompExpr(item->comp);\n+            }\n@@ -445,4 +445,4 @@\n-        xsltStyleItemIfPtr item = (xsltStyleItemIfPtr) comp;\n-        if (item->comp != NULL)\n-            xmlXPathFreeCompExpr(item->comp);\n-        }\n+                xsltStyleItemIfPtr item = (xsltStyleItemIfPtr) comp;\n+                if (item->comp != NULL)\n+                    xmlXPathFreeCompExpr(item->comp);\n+            }\n@@ -451,5 +451,5 @@\n-        xsltStyleItemForEachPtr item =\n-            (xsltStyleItemForEachPtr) comp;\n-        if (item->comp != NULL)\n-            xmlXPathFreeCompExpr(item->comp);\n-        }\n+                xsltStyleItemForEachPtr item =\n+                    (xsltStyleItemForEachPtr) comp;\n+                if (item->comp != NULL)\n+                    xmlXPathFreeCompExpr(item->comp);\n+            }\n@@ -459,38 +459,38 @@\n-    case XSLT_FUNC_WITHPARAM: {\n-        xsltStyleItemWithParamPtr item =\n-            (xsltStyleItemWithParamPtr) comp;\n-        if (item->comp != NULL)\n-            xmlXPathFreeCompExpr(item->comp);\n-        }\n-        break;\n-    case XSLT_FUNC_PARAM: {\n-        xsltStyleItemParamPtr item =\n-            (xsltStyleItemParamPtr) comp;\n-        if (item->comp != NULL)\n-            xmlXPathFreeCompExpr(item->comp);\n-        }\n-        break;\n-    case XSLT_FUNC_VARIABLE: {\n-        xsltStyleItemVariablePtr item =\n-            (xsltStyleItemVariablePtr) comp;\n-        if (item->comp != NULL)\n-            xmlXPathFreeCompExpr(item->comp);\n-        }\n-        break;\n-    case XSLT_FUNC_WHEN: {\n-        xsltStyleItemWhenPtr item =\n-            (xsltStyleItemWhenPtr) comp;\n-        if (item->comp != NULL)\n-            xmlXPathFreeCompExpr(item->comp);\n-        }\n-        break;\n-    case XSLT_FUNC_OTHERWISE:\n-    case XSLT_FUNC_FALLBACK:\n-    case XSLT_FUNC_MESSAGE:\n-    case XSLT_FUNC_INCLUDE:\n-    case XSLT_FUNC_ATTRSET:\n-\n-        break;\n-    default:\n-        \/* TODO: Raise error. *\/\n-        break;\n+        case XSLT_FUNC_WITHPARAM: {\n+                xsltStyleItemWithParamPtr item =\n+                    (xsltStyleItemWithParamPtr) comp;\n+                if (item->comp != NULL)\n+                    xmlXPathFreeCompExpr(item->comp);\n+            }\n+            break;\n+        case XSLT_FUNC_PARAM: {\n+                xsltStyleItemParamPtr item =\n+                    (xsltStyleItemParamPtr) comp;\n+                if (item->comp != NULL)\n+                    xmlXPathFreeCompExpr(item->comp);\n+            }\n+            break;\n+        case XSLT_FUNC_VARIABLE: {\n+                xsltStyleItemVariablePtr item =\n+                    (xsltStyleItemVariablePtr) comp;\n+                if (item->comp != NULL)\n+                    xmlXPathFreeCompExpr(item->comp);\n+            }\n+            break;\n+        case XSLT_FUNC_WHEN: {\n+                xsltStyleItemWhenPtr item =\n+                    (xsltStyleItemWhenPtr) comp;\n+                if (item->comp != NULL)\n+                    xmlXPathFreeCompExpr(item->comp);\n+            }\n+            break;\n+        case XSLT_FUNC_OTHERWISE:\n+        case XSLT_FUNC_FALLBACK:\n+        case XSLT_FUNC_MESSAGE:\n+        case XSLT_FUNC_INCLUDE:\n+        case XSLT_FUNC_ATTRSET:\n+\n+            break;\n+        default:\n+            \/* TODO: Raise error. *\/\n+            break;\n@@ -500,1 +500,1 @@\n-    xsltFreeLocale(comp->locale);\n+        xsltFreeLocale(comp->locale);\n@@ -502,1 +502,1 @@\n-    xmlXPathFreeCompExpr(comp->comp);\n+        xmlXPathFreeCompExpr(comp->comp);\n@@ -508,1 +508,1 @@\n-    xmlFree(comp->nsList);\n+        xmlFree(comp->nsList);\n@@ -516,3 +516,3 @@\n- *                                  *\n- *          XSLT-1.1 extensions                 *\n- *                                  *\n+ *                                                                      *\n+ *                  XSLT-1.1 extensions                                 *\n+ *                                                                      *\n@@ -533,1 +533,1 @@\n-         xsltTransformFunction function ATTRIBUTE_UNUSED) {\n+                 xsltTransformFunction function ATTRIBUTE_UNUSED) {\n@@ -555,1 +555,1 @@\n-    xsltNewStylePreComp(style, XSLT_FUNC_DOCUMENT);\n+        xsltNewStylePreComp(style, XSLT_FUNC_DOCUMENT);\n@@ -561,1 +561,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -567,2 +567,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-        \"Found saxon:output extension\\n\");\n+        xsltGenericDebug(xsltGenericDebugContext,\n+            \"Found saxon:output extension\\n\");\n@@ -570,11 +570,11 @@\n-    \/*\n-    * The element \"output\" is in the namespace XSLT_SAXON_NAMESPACE\n-    *   (http:\/\/icl.com\/saxon)\n-    * The @file is in no namespace; it is an AVT.\n-    *   (http:\/\/www.computerwizards.com\/saxon\/doc\/extensions.html#saxon:output)\n-    *\n-    * TODO: Do we need not to check the namespace here?\n-    *\/\n-    filename = xsltEvalStaticAttrValueTemplate(style, inst,\n-             (const xmlChar *)\"file\",\n-             NULL, &comp->has_filename);\n+        \/*\n+        * The element \"output\" is in the namespace XSLT_SAXON_NAMESPACE\n+        *   (http:\/\/icl.com\/saxon)\n+        * The @file is in no namespace; it is an AVT.\n+        *   (http:\/\/www.computerwizards.com\/saxon\/doc\/extensions.html#saxon:output)\n+        *\n+        * TODO: Do we need not to check the namespace here?\n+        *\/\n+        filename = xsltEvalStaticAttrValueTemplate(style, inst,\n+                         (const xmlChar *)\"file\",\n+                         NULL, &comp->has_filename);\n@@ -583,2 +583,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-        \"Found xalan:write extension\\n\");\n+        xsltGenericDebug(xsltGenericDebugContext,\n+            \"Found xalan:write extension\\n\");\n@@ -586,12 +586,1 @@\n-    \/* the filename need to be interpreted *\/\n-    \/*\n-    * TODO: Is \"filename need to be interpreted\" meant to be a todo?\n-    *   Where will be the filename of xalan:write be processed?\n-    *\n-    * TODO: Do we need not to check the namespace here?\n-    *   The extension ns is \"http:\/\/xml.apache.org\/xalan\/redirect\".\n-    *   See http:\/\/xml.apache.org\/xalan-j\/extensionslib.html.\n-    *\/\n-    } else if (xmlStrEqual(inst->name, (const xmlChar *) \"document\")) {\n-    if (inst->ns != NULL) {\n-        if (xmlStrEqual(inst->ns->href, XSLT_NAMESPACE)) {\n+        \/* the filename need to be interpreted *\/\n@@ -599,2 +588,6 @@\n-        * Mark the instruction as being of\n-        * XSLT version 1.1 (abandoned).\n+        * TODO: Is \"filename need to be interpreted\" meant to be a todo?\n+        *   Where will be the filename of xalan:write be processed?\n+        *\n+        * TODO: Do we need not to check the namespace here?\n+        *   The extension ns is \"http:\/\/xml.apache.org\/xalan\/redirect\".\n+        *   See http:\/\/xml.apache.org\/xalan-j\/extensionslib.html.\n@@ -602,1 +595,8 @@\n-        comp->ver11 = 1;\n+    } else if (xmlStrEqual(inst->name, (const xmlChar *) \"document\")) {\n+        if (inst->ns != NULL) {\n+            if (xmlStrEqual(inst->ns->href, XSLT_NAMESPACE)) {\n+                \/*\n+                * Mark the instruction as being of\n+                * XSLT version 1.1 (abandoned).\n+                *\/\n+                comp->ver11 = 1;\n@@ -604,2 +604,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-            \"Found xslt11:document construct\\n\");\n+                xsltGenericDebug(xsltGenericDebugContext,\n+                    \"Found xslt11:document construct\\n\");\n@@ -607,4 +607,4 @@\n-        } else {\n-        if (xmlStrEqual(inst->ns->href,\n-            (const xmlChar *)\"http:\/\/exslt.org\/common\")) {\n-            \/* EXSLT. *\/\n+            } else {\n+                if (xmlStrEqual(inst->ns->href,\n+                    (const xmlChar *)\"http:\/\/exslt.org\/common\")) {\n+                    \/* EXSLT. *\/\n@@ -612,2 +612,2 @@\n-            xsltGenericDebug(xsltGenericDebugContext,\n-            \"Found exslt:document extension\\n\");\n+                    xsltGenericDebug(xsltGenericDebugContext,\n+                        \"Found exslt:document extension\\n\");\n@@ -615,2 +615,2 @@\n-        } else if (xmlStrEqual(inst->ns->href, XSLT_XT_NAMESPACE)) {\n-            \/* James Clark's XT. *\/\n+                } else if (xmlStrEqual(inst->ns->href, XSLT_XT_NAMESPACE)) {\n+                    \/* James Clark's XT. *\/\n@@ -618,2 +618,2 @@\n-            xsltGenericDebug(xsltGenericDebugContext,\n-            \"Found xt:document extension\\n\");\n+                    xsltGenericDebug(xsltGenericDebugContext,\n+                        \"Found xt:document extension\\n\");\n@@ -621,0 +621,2 @@\n+                }\n+            }\n@@ -622,31 +624,29 @@\n-        }\n-    }\n-    \/*\n-    * The element \"document\" is used in conjunction with the\n-    * following namespaces:\n-    *\n-    * 1) XSLT_NAMESPACE (http:\/\/www.w3.org\/1999\/XSL\/Transform version 1.1)\n-    *    <!ELEMENT xsl:document %template;>\n-    *    <!ATTLIST xsl:document\n-    *       href %avt; #REQUIRED\n-    *    @href is an AVT\n-    *    IMPORTANT: xsl:document was in the abandoned XSLT 1.1 draft,\n-    *    it was removed and isn't available in XSLT 1.1 anymore.\n-    *    In XSLT 2.0 it was renamed to xsl:result-document.\n-    *\n-    *   All other attributes are identical to the attributes\n-    *   on xsl:output\n-    *\n-    * 2) EXSLT_COMMON_NAMESPACE (http:\/\/exslt.org\/common)\n-    *    <exsl:document\n-    *       href = { uri-reference }\n-    *    TODO: is @href is an AVT?\n-    *\n-    * 3) XSLT_XT_NAMESPACE (http:\/\/www.jclark.com\/xt)\n-    *     Example: <xt:document method=\"xml\" href=\"myFile.xml\">\n-    *    TODO: is @href is an AVT?\n-    *\n-    * In all cases @href is in no namespace.\n-    *\/\n-    filename = xsltEvalStaticAttrValueTemplate(style, inst,\n-        (const xmlChar *)\"href\", NULL, &comp->has_filename);\n+        \/*\n+        * The element \"document\" is used in conjunction with the\n+        * following namespaces:\n+        *\n+        * 1) XSLT_NAMESPACE (http:\/\/www.w3.org\/1999\/XSL\/Transform version 1.1)\n+        *    <!ELEMENT xsl:document %template;>\n+        *    <!ATTLIST xsl:document\n+        *       href %avt; #REQUIRED\n+        *    @href is an AVT\n+        *    IMPORTANT: xsl:document was in the abandoned XSLT 1.1 draft,\n+        *    it was removed and isn't available in XSLT 1.1 anymore.\n+        *    In XSLT 2.0 it was renamed to xsl:result-document.\n+        *\n+        *   All other attributes are identical to the attributes\n+        *   on xsl:output\n+        *\n+        * 2) EXSLT_COMMON_NAMESPACE (http:\/\/exslt.org\/common)\n+        *    <exsl:document\n+        *       href = { uri-reference }\n+        *    TODO: is @href is an AVT?\n+        *\n+        * 3) XSLT_XT_NAMESPACE (http:\/\/www.jclark.com\/xt)\n+        *     Example: <xt:document method=\"xml\" href=\"myFile.xml\">\n+        *    TODO: is @href is an AVT?\n+        *\n+        * In all cases @href is in no namespace.\n+        *\/\n+        filename = xsltEvalStaticAttrValueTemplate(style, inst,\n+            (const xmlChar *)\"href\", NULL, &comp->has_filename);\n@@ -655,1 +655,1 @@\n-    goto error;\n+        goto error;\n@@ -664,3 +664,3 @@\n- *                                  *\n- *      Most of the XSLT-1.0 transformations            *\n- *                                  *\n+ *                                                                      *\n+ *              Most of the XSLT-1.0 transformations                    *\n+ *                                                                      *\n@@ -684,1 +684,1 @@\n-    return;\n+        return;\n@@ -693,1 +693,1 @@\n-    return;\n+        return;\n@@ -698,2 +698,2 @@\n-             (const xmlChar *)\"data-type\",\n-             NULL, &comp->has_stype);\n+                         (const xmlChar *)\"data-type\",\n+                         NULL, &comp->has_stype);\n@@ -701,10 +701,10 @@\n-    if (xmlStrEqual(comp->stype, (const xmlChar *) \"text\"))\n-        comp->number = 0;\n-    else if (xmlStrEqual(comp->stype, (const xmlChar *) \"number\"))\n-        comp->number = 1;\n-    else {\n-        xsltTransformError(NULL, style, inst,\n-         \"xsltSortComp: no support for data-type = %s\\n\", comp->stype);\n-        comp->number = 0; \/* use default *\/\n-        if (style != NULL) style->warnings++;\n-    }\n+        if (xmlStrEqual(comp->stype, (const xmlChar *) \"text\"))\n+            comp->number = 0;\n+        else if (xmlStrEqual(comp->stype, (const xmlChar *) \"number\"))\n+            comp->number = 1;\n+        else {\n+            xsltTransformError(NULL, style, inst,\n+                 \"xsltSortComp: no support for data-type = %s\\n\", comp->stype);\n+            comp->number = 0; \/* use default *\/\n+            if (style != NULL) style->warnings++;\n+        }\n@@ -713,2 +713,2 @@\n-                  (const xmlChar *)\"order\",\n-                  NULL, &comp->has_order);\n+                              (const xmlChar *)\"order\",\n+                              NULL, &comp->has_order);\n@@ -716,10 +716,10 @@\n-    if (xmlStrEqual(comp->order, (const xmlChar *) \"ascending\"))\n-        comp->descending = 0;\n-    else if (xmlStrEqual(comp->order, (const xmlChar *) \"descending\"))\n-        comp->descending = 1;\n-    else {\n-        xsltTransformError(NULL, style, inst,\n-         \"xsltSortComp: invalid value %s for order\\n\", comp->order);\n-        comp->descending = 0; \/* use default *\/\n-        if (style != NULL) style->warnings++;\n-    }\n+        if (xmlStrEqual(comp->order, (const xmlChar *) \"ascending\"))\n+            comp->descending = 0;\n+        else if (xmlStrEqual(comp->order, (const xmlChar *) \"descending\"))\n+            comp->descending = 1;\n+        else {\n+            xsltTransformError(NULL, style, inst,\n+                 \"xsltSortComp: invalid value %s for order\\n\", comp->order);\n+            comp->descending = 0; \/* use default *\/\n+            if (style != NULL) style->warnings++;\n+        }\n@@ -728,2 +728,2 @@\n-                  (const xmlChar *)\"case-order\",\n-                  NULL, &comp->has_use);\n+                              (const xmlChar *)\"case-order\",\n+                              NULL, &comp->has_use);\n@@ -731,10 +731,10 @@\n-    if (xmlStrEqual(comp->case_order, (const xmlChar *) \"upper-first\"))\n-        comp->lower_first = 0;\n-    else if (xmlStrEqual(comp->case_order, (const xmlChar *) \"lower-first\"))\n-        comp->lower_first = 1;\n-    else {\n-        xsltTransformError(NULL, style, inst,\n-         \"xsltSortComp: invalid value %s for order\\n\", comp->order);\n-        comp->lower_first = 0; \/* use default *\/\n-        if (style != NULL) style->warnings++;\n-    }\n+        if (xmlStrEqual(comp->case_order, (const xmlChar *) \"upper-first\"))\n+            comp->lower_first = 0;\n+        else if (xmlStrEqual(comp->case_order, (const xmlChar *) \"lower-first\"))\n+            comp->lower_first = 1;\n+        else {\n+            xsltTransformError(NULL, style, inst,\n+                 \"xsltSortComp: invalid value %s for order\\n\", comp->order);\n+            comp->lower_first = 0; \/* use default *\/\n+            if (style != NULL) style->warnings++;\n+        }\n@@ -744,2 +744,2 @@\n-                 (const xmlChar *)\"lang\",\n-                 NULL, &comp->has_lang);\n+                                 (const xmlChar *)\"lang\",\n+                                 NULL, &comp->has_lang);\n@@ -747,1 +747,1 @@\n-    comp->locale = xsltNewLocale(comp->lang);\n+        comp->locale = xsltNewLocale(comp->lang);\n@@ -755,6 +755,6 @@\n-    \/*\n-     * The default value of the select attribute is ., which will\n-     * cause the string-value of the current node to be used as\n-     * the sort key.\n-     *\/\n-    comp->select = xmlDictLookup(style->dict, BAD_CAST \".\", 1);\n+        \/*\n+         * The default value of the select attribute is ., which will\n+         * cause the string-value of the current node to be used as\n+         * the sort key.\n+         *\/\n+        comp->select = xmlDictLookup(style->dict, BAD_CAST \".\", 1);\n@@ -764,4 +764,4 @@\n-    xsltTransformError(NULL, style, inst,\n-         \"xsltSortComp: could not compile select expression '%s'\\n\",\n-                     comp->select);\n-    if (style != NULL) style->errors++;\n+        xsltTransformError(NULL, style, inst,\n+             \"xsltSortComp: could not compile select expression '%s'\\n\",\n+                         comp->select);\n+        if (style != NULL) style->errors++;\n@@ -770,3 +770,3 @@\n-    xsltTransformError(NULL, style, inst,\n-    \"xsl:sort : is not empty\\n\");\n-    if (style != NULL) style->errors++;\n+        xsltTransformError(NULL, style, inst,\n+        \"xsl:sort : is not empty\\n\");\n+        if (style != NULL) style->errors++;\n@@ -792,1 +792,1 @@\n-    return;\n+        return;\n@@ -800,1 +800,1 @@\n-    return;\n+        return;\n@@ -806,1 +806,1 @@\n-                    XSLT_NAMESPACE);\n+                                    XSLT_NAMESPACE);\n@@ -808,1 +808,1 @@\n-    comp->has_use = 0;\n+        comp->has_use = 0;\n@@ -810,1 +810,1 @@\n-    comp->has_use = 1;\n+        comp->has_use = 1;\n@@ -836,1 +836,1 @@\n-    return;\n+        return;\n@@ -844,1 +844,1 @@\n-    return;\n+        return;\n@@ -850,2 +850,2 @@\n-        (const xmlChar *)\"disable-output-escaping\",\n-            XSLT_NAMESPACE);\n+            (const xmlChar *)\"disable-output-escaping\",\n+                        XSLT_NAMESPACE);\n@@ -853,8 +853,8 @@\n-    if (xmlStrEqual(prop, (const xmlChar *)\"yes\")) {\n-        comp->noescape = 1;\n-    } else if (!xmlStrEqual(prop,\n-        (const xmlChar *)\"no\")){\n-        xsltTransformError(NULL, style, inst,\n-        \"xsl:text: disable-output-escaping allows only yes or no\\n\");\n-        if (style != NULL) style->warnings++;\n-    }\n+        if (xmlStrEqual(prop, (const xmlChar *)\"yes\")) {\n+            comp->noescape = 1;\n+        } else if (!xmlStrEqual(prop,\n+            (const xmlChar *)\"no\")){\n+            xsltTransformError(NULL, style, inst,\n+                \"xsl:text: disable-output-escaping allows only yes or no\\n\");\n+            if (style != NULL) style->warnings++;\n+        }\n@@ -889,1 +889,1 @@\n-    return;\n+        return;\n@@ -898,1 +898,1 @@\n-    return;\n+        return;\n@@ -909,1 +909,1 @@\n-    (const xmlChar *)\"name\", NULL, &comp->has_name);\n+        (const xmlChar *)\"name\", NULL, &comp->has_name);\n@@ -911,4 +911,4 @@\n-    xsltTransformError(NULL, style, inst,\n-        \"xsl:element: The attribute 'name' is missing.\\n\");\n-    style->errors++;\n-    goto error;\n+        xsltTransformError(NULL, style, inst,\n+            \"xsl:element: The attribute 'name' is missing.\\n\");\n+        style->errors++;\n+        goto error;\n@@ -923,1 +923,1 @@\n-    (const xmlChar *)\"namespace\", NULL, &comp->has_ns);\n+        (const xmlChar *)\"namespace\", NULL, &comp->has_ns);\n@@ -926,23 +926,23 @@\n-    if (xmlValidateQName(comp->name, 0)) {\n-        xsltTransformError(NULL, style, inst,\n-        \"xsl:element: The value '%s' of the attribute 'name' is \"\n-        \"not a valid QName.\\n\", comp->name);\n-        style->errors++;\n-    } else {\n-        const xmlChar *prefix = NULL, *name;\n-\n-        name = xsltSplitQName(style->dict, comp->name, &prefix);\n-        if (comp->has_ns == 0) {\n-        xmlNsPtr ns;\n-\n-        \/*\n-        * SPEC XSLT 1.0:\n-        *  \"If the namespace attribute is not present, then the QName is\n-        *  expanded into an expanded-name using the namespace declarations\n-        *  in effect for the xsl:element element, including any default\n-        *  namespace declaration.\n-        *\/\n-        ns = xmlSearchNs(inst->doc, inst, prefix);\n-        if (ns != NULL) {\n-            comp->ns = xmlDictLookup(style->dict, ns->href, -1);\n-            comp->has_ns = 1;\n+        if (xmlValidateQName(comp->name, 0)) {\n+            xsltTransformError(NULL, style, inst,\n+                \"xsl:element: The value '%s' of the attribute 'name' is \"\n+                \"not a valid QName.\\n\", comp->name);\n+            style->errors++;\n+        } else {\n+            const xmlChar *prefix = NULL, *name;\n+\n+            name = xsltSplitQName(style->dict, comp->name, &prefix);\n+            if (comp->has_ns == 0) {\n+                xmlNsPtr ns;\n+\n+                \/*\n+                * SPEC XSLT 1.0:\n+                *  \"If the namespace attribute is not present, then the QName is\n+                *  expanded into an expanded-name using the namespace declarations\n+                *  in effect for the xsl:element element, including any default\n+                *  namespace declaration.\n+                *\/\n+                ns = xmlSearchNs(inst->doc, inst, prefix);\n+                if (ns != NULL) {\n+                    comp->ns = xmlDictLookup(style->dict, ns->href, -1);\n+                    comp->has_ns = 1;\n@@ -950,2 +950,2 @@\n-            comp->nsPrefix = prefix;\n-            comp->name = name;\n+                    comp->nsPrefix = prefix;\n+                    comp->name = name;\n@@ -955,16 +955,17 @@\n-        } else if (prefix != NULL) {\n-            xsltTransformError(NULL, style, inst,\n-            \"xsl:element: The prefixed QName '%s' \"\n-            \"has no namespace binding in scope in the \"\n-            \"stylesheet; this is an error, since the namespace was \"\n-            \"not specified by the instruction itself.\\n\", comp->name);\n-            style->errors++;\n-        }\n-        }\n-        if ((prefix != NULL) &&\n-        (!xmlStrncasecmp(prefix, (xmlChar *)\"xml\", 3)))\n-        {\n-        \/*\n-        * Mark is to be skipped.\n-        *\/\n-        comp->has_name = 0;\n+                } else if (prefix != NULL) {\n+                    xsltTransformError(NULL, style, inst,\n+                        \"xsl:element: The prefixed QName '%s' \"\n+                        \"has no namespace binding in scope in the \"\n+                        \"stylesheet; this is an error, since the namespace was \"\n+                        \"not specified by the instruction itself.\\n\", comp->name);\n+                    style->errors++;\n+                }\n+            }\n+            if ((prefix != NULL) &&\n+                (!xmlStrncasecmp(prefix, (xmlChar *)\"xml\", 3)))\n+            {\n+                \/*\n+                * Mark is to be skipped.\n+                *\/\n+                comp->has_name = 0;\n+            }\n@@ -973,1 +974,0 @@\n-    }\n@@ -978,2 +978,2 @@\n-               (const xmlChar *)\"use-attribute-sets\",\n-               NULL, &comp->has_use);\n+                       (const xmlChar *)\"use-attribute-sets\",\n+                       NULL, &comp->has_use);\n@@ -1008,1 +1008,1 @@\n-    return;\n+        return;\n@@ -1012,1 +1012,1 @@\n-    XSLT_FUNC_ATTRIBUTE);\n+        XSLT_FUNC_ATTRIBUTE);\n@@ -1018,1 +1018,1 @@\n-    return;\n+        return;\n@@ -1029,2 +1029,2 @@\n-                 (const xmlChar *)\"name\",\n-                 NULL, &comp->has_name);\n+                                 (const xmlChar *)\"name\",\n+                                 NULL, &comp->has_name);\n@@ -1032,4 +1032,4 @@\n-    xsltTransformError(NULL, style, inst,\n-        \"XSLT-attribute: The attribute 'name' is missing.\\n\");\n-    style->errors++;\n-    return;\n+        xsltTransformError(NULL, style, inst,\n+            \"XSLT-attribute: The attribute 'name' is missing.\\n\");\n+        style->errors++;\n+        return;\n@@ -1044,2 +1044,2 @@\n-    (const xmlChar *)\"namespace\",\n-    NULL, &comp->has_ns);\n+        (const xmlChar *)\"namespace\",\n+        NULL, &comp->has_ns);\n@@ -1048,5 +1048,5 @@\n-    if (xmlValidateQName(comp->name, 0)) {\n-        xsltTransformError(NULL, style, inst,\n-        \"xsl:attribute: The value '%s' of the attribute 'name' is \"\n-        \"not a valid QName.\\n\", comp->name);\n-        style->errors++;\n+        if (xmlValidateQName(comp->name, 0)) {\n+            xsltTransformError(NULL, style, inst,\n+                \"xsl:attribute: The value '%s' of the attribute 'name' is \"\n+                \"not a valid QName.\\n\", comp->name);\n+            style->errors++;\n@@ -1054,1 +1054,1 @@\n-        xsltTransformError(NULL, style, inst,\n+            xsltTransformError(NULL, style, inst,\n@@ -1056,20 +1056,20 @@\n-        style->errors++;\n-    } else {\n-        const xmlChar *prefix = NULL, *name;\n-\n-        name = xsltSplitQName(style->dict, comp->name, &prefix);\n-        if (prefix != NULL) {\n-        if (comp->has_ns == 0) {\n-            xmlNsPtr ns;\n-\n-            \/*\n-            * SPEC XSLT 1.0:\n-            *  \"If the namespace attribute is not present, then the\n-            *  QName is expanded into an expanded-name using the\n-            *  namespace declarations in effect for the xsl:element\n-            *  element, including any default namespace declaration.\n-            *\/\n-            ns = xmlSearchNs(inst->doc, inst, prefix);\n-            if (ns != NULL) {\n-            comp->ns = xmlDictLookup(style->dict, ns->href, -1);\n-            comp->has_ns = 1;\n+            style->errors++;\n+        } else {\n+            const xmlChar *prefix = NULL, *name;\n+\n+            name = xsltSplitQName(style->dict, comp->name, &prefix);\n+            if (prefix != NULL) {\n+                if (comp->has_ns == 0) {\n+                    xmlNsPtr ns;\n+\n+                    \/*\n+                    * SPEC XSLT 1.0:\n+                    *  \"If the namespace attribute is not present, then the\n+                    *  QName is expanded into an expanded-name using the\n+                    *  namespace declarations in effect for the xsl:element\n+                    *  element, including any default namespace declaration.\n+                    *\/\n+                    ns = xmlSearchNs(inst->doc, inst, prefix);\n+                    if (ns != NULL) {\n+                        comp->ns = xmlDictLookup(style->dict, ns->href, -1);\n+                        comp->has_ns = 1;\n@@ -1077,2 +1077,2 @@\n-            comp->nsPrefix = prefix;\n-            comp->name = name;\n+                        comp->nsPrefix = prefix;\n+                        comp->name = name;\n@@ -1082,8 +1082,10 @@\n-            } else {\n-            xsltTransformError(NULL, style, inst,\n-                \"xsl:attribute: The prefixed QName '%s' \"\n-                \"has no namespace binding in scope in the \"\n-                \"stylesheet; this is an error, since the \"\n-                \"namespace was not specified by the instruction \"\n-                \"itself.\\n\", comp->name);\n-            style->errors++;\n+                    } else {\n+                        xsltTransformError(NULL, style, inst,\n+                            \"xsl:attribute: The prefixed QName '%s' \"\n+                            \"has no namespace binding in scope in the \"\n+                            \"stylesheet; this is an error, since the \"\n+                            \"namespace was not specified by the instruction \"\n+                            \"itself.\\n\", comp->name);\n+                        style->errors++;\n+                    }\n+                }\n@@ -1092,2 +1094,0 @@\n-        }\n-    }\n@@ -1113,1 +1113,1 @@\n-    return;\n+        return;\n@@ -1122,1 +1122,1 @@\n-    return;\n+        return;\n@@ -1143,1 +1143,1 @@\n-    return;\n+        return;\n@@ -1152,1 +1152,1 @@\n-    return;\n+        return;\n@@ -1157,2 +1157,2 @@\n-                 (const xmlChar *)\"name\",\n-                 XSLT_NAMESPACE, &comp->has_name);\n+                                 (const xmlChar *)\"name\",\n+                                 XSLT_NAMESPACE, &comp->has_name);\n@@ -1177,1 +1177,1 @@\n-    return;\n+        return;\n@@ -1186,1 +1186,1 @@\n-    return;\n+        return;\n@@ -1191,1 +1191,1 @@\n-                            XSLT_NAMESPACE);\n+                                XSLT_NAMESPACE);\n@@ -1193,4 +1193,4 @@\n-    xsltTransformError(NULL, style, inst,\n-         \"xsl:copy-of : select is missing\\n\");\n-    if (style != NULL) style->errors++;\n-    return;\n+        xsltTransformError(NULL, style, inst,\n+             \"xsl:copy-of : select is missing\\n\");\n+        if (style != NULL) style->errors++;\n+        return;\n@@ -1200,4 +1200,4 @@\n-    xsltTransformError(NULL, style, inst,\n-         \"xsl:copy-of : could not compile select expression '%s'\\n\",\n-                     comp->select);\n-    if (style != NULL) style->errors++;\n+        xsltTransformError(NULL, style, inst,\n+             \"xsl:copy-of : could not compile select expression '%s'\\n\",\n+                         comp->select);\n+        if (style != NULL) style->errors++;\n@@ -1224,1 +1224,1 @@\n-    return;\n+        return;\n@@ -1233,1 +1233,1 @@\n-    return;\n+        return;\n@@ -1238,2 +1238,2 @@\n-        (const xmlChar *)\"disable-output-escaping\",\n-            XSLT_NAMESPACE);\n+            (const xmlChar *)\"disable-output-escaping\",\n+                        XSLT_NAMESPACE);\n@@ -1241,5 +1241,5 @@\n-    if (xmlStrEqual(prop, (const xmlChar *)\"yes\")) {\n-        comp->noescape = 1;\n-    } else if (!xmlStrEqual(prop,\n-                (const xmlChar *)\"no\")){\n-        xsltTransformError(NULL, style, inst,\n+        if (xmlStrEqual(prop, (const xmlChar *)\"yes\")) {\n+            comp->noescape = 1;\n+        } else if (!xmlStrEqual(prop,\n+                                (const xmlChar *)\"no\")){\n+            xsltTransformError(NULL, style, inst,\n@@ -1247,2 +1247,2 @@\n-        if (style != NULL) style->warnings++;\n-    }\n+            if (style != NULL) style->warnings++;\n+        }\n@@ -1251,1 +1251,1 @@\n-                            XSLT_NAMESPACE);\n+                                XSLT_NAMESPACE);\n@@ -1253,4 +1253,4 @@\n-    xsltTransformError(NULL, style, inst,\n-         \"xsl:value-of : select is missing\\n\");\n-    if (style != NULL) style->errors++;\n-    return;\n+        xsltTransformError(NULL, style, inst,\n+             \"xsl:value-of : select is missing\\n\");\n+        if (style != NULL) style->errors++;\n+        return;\n@@ -1260,4 +1260,4 @@\n-    xsltTransformError(NULL, style, inst,\n-         \"xsl:value-of : could not compile select expression '%s'\\n\",\n-                     comp->select);\n-    if (style != NULL) style->errors++;\n+        xsltTransformError(NULL, style, inst,\n+             \"xsl:value-of : could not compile select expression '%s'\\n\",\n+                         comp->select);\n+        if (style != NULL) style->errors++;\n@@ -1269,4 +1269,4 @@\n-             const xmlChar *propName,\n-             int mandatory,\n-             int *hasProp, const xmlChar **nsName,\n-             const xmlChar** localName)\n+                     const xmlChar *propName,\n+                     int mandatory,\n+                     int *hasProp, const xmlChar **nsName,\n+                     const xmlChar** localName)\n@@ -1277,1 +1277,1 @@\n-    *nsName = NULL;\n+        *nsName = NULL;\n@@ -1279,1 +1279,1 @@\n-    *localName = NULL;\n+        *localName = NULL;\n@@ -1281,1 +1281,1 @@\n-    *hasProp = 0;\n+        *hasProp = 0;\n@@ -1285,6 +1285,6 @@\n-    if (mandatory) {\n-        xsltTransformError(NULL, style, inst,\n-        \"The attribute '%s' is missing.\\n\", propName);\n-        style->errors++;\n-        return;\n-    }\n+        if (mandatory) {\n+            xsltTransformError(NULL, style, inst,\n+                \"The attribute '%s' is missing.\\n\", propName);\n+            style->errors++;\n+            return;\n+        }\n@@ -1294,13 +1294,6 @@\n-    if (xmlValidateQName(prop, 0)) {\n-        xsltTransformError(NULL, style, inst,\n-        \"The value '%s' of the attribute \"\n-        \"'%s' is not a valid QName.\\n\", prop, propName);\n-        style->errors++;\n-        return;\n-    } else {\n-        \/*\n-        * @prop will be in the string dict afterwards, @URI not.\n-        *\/\n-        URI = xsltGetQNameURI2(style, inst, &prop);\n-        if (prop == NULL) {\n-        style->errors++;\n+        if (xmlValidateQName(prop, 0)) {\n+            xsltTransformError(NULL, style, inst,\n+                \"The value '%s' of the attribute \"\n+                \"'%s' is not a valid QName.\\n\", prop, propName);\n+            style->errors++;\n+            return;\n@@ -1308,5 +1301,0 @@\n-        if (localName)\n-            *localName = prop;\n-        if (hasProp)\n-            *hasProp = 1;\n-        if (URI != NULL) {\n@@ -1314,3 +1302,1 @@\n-            * Fixes bug #308441: Put the ns-name in the dict\n-            * in order to pointer compare names during XPath's\n-            * variable lookup.\n+            * @prop will be in the string dict afterwards, @URI not.\n@@ -1318,4 +1304,19 @@\n-            if (nsName)\n-            *nsName = xmlDictLookup(style->dict, URI, -1);\n-            \/* comp->has_ns = 1; *\/\n-        }\n+            URI = xsltGetQNameURI2(style, inst, &prop);\n+            if (prop == NULL) {\n+                style->errors++;\n+            } else {\n+                if (localName)\n+                    *localName = prop;\n+                if (hasProp)\n+                    *hasProp = 1;\n+                if (URI != NULL) {\n+                    \/*\n+                    * Fixes bug #308441: Put the ns-name in the dict\n+                    * in order to pointer compare names during XPath's\n+                    * variable lookup.\n+                    *\/\n+                    if (nsName)\n+                        *nsName = xmlDictLookup(style->dict, URI, -1);\n+                    \/* comp->has_ns = 1; *\/\n+                }\n+            }\n@@ -1324,1 +1325,0 @@\n-    }\n@@ -1350,1 +1350,1 @@\n-    return;\n+        return;\n@@ -1359,1 +1359,1 @@\n-    return;\n+        return;\n@@ -1367,1 +1367,1 @@\n-    1, &(comp->has_name), &(comp->ns), &(comp->name));\n+        1, &(comp->has_name), &(comp->ns), &(comp->name));\n@@ -1369,1 +1369,1 @@\n-    comp->has_ns = 1;\n+        comp->has_ns = 1;\n@@ -1374,1 +1374,1 @@\n-                            XSLT_NAMESPACE);\n+                                XSLT_NAMESPACE);\n@@ -1376,13 +1376,13 @@\n-    comp->comp = xsltXPathCompile(style, comp->select);\n-    if (comp->comp == NULL) {\n-        xsltTransformError(NULL, style, inst,\n-         \"XSLT-with-param: Failed to compile select \"\n-         \"expression '%s'\\n\", comp->select);\n-        style->errors++;\n-    }\n-    if (inst->children != NULL) {\n-        xsltTransformError(NULL, style, inst,\n-        \"XSLT-with-param: The content should be empty since \"\n-        \"the attribute select is present.\\n\");\n-        style->warnings++;\n-    }\n+        comp->comp = xsltXPathCompile(style, comp->select);\n+        if (comp->comp == NULL) {\n+            xsltTransformError(NULL, style, inst,\n+                 \"XSLT-with-param: Failed to compile select \"\n+                 \"expression '%s'\\n\", comp->select);\n+            style->errors++;\n+        }\n+        if (inst->children != NULL) {\n+            xsltTransformError(NULL, style, inst,\n+                \"XSLT-with-param: The content should be empty since \"\n+                \"the attribute select is present.\\n\");\n+            style->warnings++;\n+        }\n@@ -1409,1 +1409,1 @@\n-    return;\n+        return;\n@@ -1418,1 +1418,1 @@\n-    return;\n+        return;\n@@ -1424,1 +1424,1 @@\n-                                    XSLT_NAMESPACE);\n+                                        XSLT_NAMESPACE);\n@@ -1427,2 +1427,2 @@\n-             (const xmlChar *)\"format\",\n-             XSLT_NAMESPACE, &comp->numdata.has_format);\n+                         (const xmlChar *)\"format\",\n+                         XSLT_NAMESPACE, &comp->numdata.has_format);\n@@ -1430,1 +1430,1 @@\n-    comp->numdata.format = xmlDictLookup(style->dict, BAD_CAST \"\" , 0);\n+        comp->numdata.format = xmlDictLookup(style->dict, BAD_CAST \"\" , 0);\n@@ -1432,1 +1432,1 @@\n-    comp->numdata.format = prop;\n+        comp->numdata.format = prop;\n@@ -1442,1 +1442,1 @@\n-    comp->numdata.countPat = xsltCompilePattern(prop, cur->doc, cur, style,\n+        comp->numdata.countPat = xsltCompilePattern(prop, cur->doc, cur, style,\n@@ -1448,1 +1448,1 @@\n-    comp->numdata.fromPat = xsltCompilePattern(prop, cur->doc, cur, style,\n+        comp->numdata.fromPat = xsltCompilePattern(prop, cur->doc, cur, style,\n@@ -1454,9 +1454,9 @@\n-    if (xmlStrEqual(prop, BAD_CAST(\"single\")) ||\n-        xmlStrEqual(prop, BAD_CAST(\"multiple\")) ||\n-        xmlStrEqual(prop, BAD_CAST(\"any\"))) {\n-        comp->numdata.level = prop;\n-    } else {\n-        xsltTransformError(NULL, style, cur,\n-             \"xsl:number : invalid value %s for level\\n\", prop);\n-        if (style != NULL) style->warnings++;\n-    }\n+        if (xmlStrEqual(prop, BAD_CAST(\"single\")) ||\n+            xmlStrEqual(prop, BAD_CAST(\"multiple\")) ||\n+            xmlStrEqual(prop, BAD_CAST(\"any\"))) {\n+            comp->numdata.level = prop;\n+        } else {\n+            xsltTransformError(NULL, style, cur,\n+                         \"xsl:number : invalid value %s for level\\n\", prop);\n+            if (style != NULL) style->warnings++;\n+        }\n@@ -1467,3 +1467,3 @@\n-        xsltTransformError(NULL, style, cur,\n-         \"xsl:number : lang attribute not implemented\\n\");\n-    XSLT_TODO; \/* xsl:number lang attribute *\/\n+            xsltTransformError(NULL, style, cur,\n+                 \"xsl:number : lang attribute not implemented\\n\");\n+        XSLT_TODO; \/* xsl:number lang attribute *\/\n@@ -1474,15 +1474,15 @@\n-    if (xmlStrEqual(prop, BAD_CAST(\"alphabetic\"))) {\n-        xsltTransformError(NULL, style, cur,\n-         \"xsl:number : letter-value 'alphabetic' not implemented\\n\");\n-        if (style != NULL) style->warnings++;\n-        XSLT_TODO; \/* xsl:number letter-value attribute alphabetic *\/\n-    } else if (xmlStrEqual(prop, BAD_CAST(\"traditional\"))) {\n-        xsltTransformError(NULL, style, cur,\n-         \"xsl:number : letter-value 'traditional' not implemented\\n\");\n-        if (style != NULL) style->warnings++;\n-        XSLT_TODO; \/* xsl:number letter-value attribute traditional *\/\n-    } else {\n-        xsltTransformError(NULL, style, cur,\n-             \"xsl:number : invalid value %s for letter-value\\n\", prop);\n-        if (style != NULL) style->warnings++;\n-    }\n+        if (xmlStrEqual(prop, BAD_CAST(\"alphabetic\"))) {\n+            xsltTransformError(NULL, style, cur,\n+                 \"xsl:number : letter-value 'alphabetic' not implemented\\n\");\n+            if (style != NULL) style->warnings++;\n+            XSLT_TODO; \/* xsl:number letter-value attribute alphabetic *\/\n+        } else if (xmlStrEqual(prop, BAD_CAST(\"traditional\"))) {\n+            xsltTransformError(NULL, style, cur,\n+                 \"xsl:number : letter-value 'traditional' not implemented\\n\");\n+            if (style != NULL) style->warnings++;\n+            XSLT_TODO; \/* xsl:number letter-value attribute traditional *\/\n+        } else {\n+            xsltTransformError(NULL, style, cur,\n+                     \"xsl:number : invalid value %s for letter-value\\n\", prop);\n+            if (style != NULL) style->warnings++;\n+        }\n@@ -1492,1 +1492,1 @@\n-                    XSLT_NAMESPACE);\n+                        XSLT_NAMESPACE);\n@@ -1495,2 +1495,4 @@\n-    comp->numdata.groupingCharacter =\n-        xsltGetUTF8Char(prop, &(comp->numdata.groupingCharacterLen));\n+        comp->numdata.groupingCharacter =\n+            xsltGetUTF8Char(prop, &(comp->numdata.groupingCharacterLen));\n+        if (comp->numdata.groupingCharacter < 0)\n+            comp->numdata.groupingCharacter = 0;\n@@ -1501,1 +1503,1 @@\n-    sscanf((char *)prop, \"%d\", &comp->numdata.digitsPerGroup);\n+        sscanf((char *)prop, \"%d\", &comp->numdata.digitsPerGroup);\n@@ -1503,1 +1505,1 @@\n-    comp->numdata.groupingCharacter = 0;\n+        comp->numdata.groupingCharacter = 0;\n@@ -1508,4 +1510,4 @@\n-    if (comp->numdata.level == NULL) {\n-        comp->numdata.level = xmlDictLookup(style->dict,\n-                                            BAD_CAST\"single\", 6);\n-    }\n+        if (comp->numdata.level == NULL) {\n+            comp->numdata.level = xmlDictLookup(style->dict,\n+                                                BAD_CAST\"single\", 6);\n+        }\n@@ -1532,1 +1534,1 @@\n-    return;\n+        return;\n@@ -1541,1 +1543,1 @@\n-    return;\n+        return;\n@@ -1562,1 +1564,1 @@\n-    return;\n+        return;\n@@ -1566,1 +1568,1 @@\n-    xsltNewStylePreComp(style, XSLT_FUNC_CALLTEMPLATE);\n+        xsltNewStylePreComp(style, XSLT_FUNC_CALLTEMPLATE);\n@@ -1572,1 +1574,1 @@\n-    return;\n+        return;\n@@ -1580,1 +1582,1 @@\n-    1, &(comp->has_name), &(comp->ns), &(comp->name));\n+        1, &(comp->has_name), &(comp->ns), &(comp->name));\n@@ -1582,1 +1584,1 @@\n-    comp->has_ns = 1;\n+        comp->has_ns = 1;\n@@ -1601,1 +1603,1 @@\n-    return;\n+        return;\n@@ -1605,1 +1607,1 @@\n-    xsltNewStylePreComp(style, XSLT_FUNC_APPLYTEMPLATES);\n+        xsltNewStylePreComp(style, XSLT_FUNC_APPLYTEMPLATES);\n@@ -1611,1 +1613,1 @@\n-    return;\n+        return;\n@@ -1619,1 +1621,1 @@\n-    0, NULL, &(comp->modeURI), &(comp->mode));\n+        0, NULL, &(comp->modeURI), &(comp->mode));\n@@ -1624,1 +1626,1 @@\n-    XSLT_NAMESPACE);\n+        XSLT_NAMESPACE);\n@@ -1626,7 +1628,7 @@\n-    comp->comp = xsltXPathCompile(style, comp->select);\n-    if (comp->comp == NULL) {\n-        xsltTransformError(NULL, style, inst,\n-        \"XSLT-apply-templates: could not compile select \"\n-        \"expression '%s'\\n\", comp->select);\n-         style->errors++;\n-    }\n+        comp->comp = xsltXPathCompile(style, comp->select);\n+        if (comp->comp == NULL) {\n+            xsltTransformError(NULL, style, inst,\n+                \"XSLT-apply-templates: could not compile select \"\n+                \"expression '%s'\\n\", comp->select);\n+             style->errors++;\n+        }\n@@ -1653,1 +1655,1 @@\n-    return;\n+        return;\n@@ -1657,1 +1659,1 @@\n-    xsltNewStylePreComp(style, XSLT_FUNC_CHOOSE);\n+        xsltNewStylePreComp(style, XSLT_FUNC_CHOOSE);\n@@ -1663,1 +1665,1 @@\n-    return;\n+        return;\n@@ -1684,1 +1686,1 @@\n-    return;\n+        return;\n@@ -1688,1 +1690,1 @@\n-    xsltNewStylePreComp(style, XSLT_FUNC_IF);\n+        xsltNewStylePreComp(style, XSLT_FUNC_IF);\n@@ -1694,1 +1696,1 @@\n-    return;\n+        return;\n@@ -1700,4 +1702,4 @@\n-    xsltTransformError(NULL, style, inst,\n-         \"xsl:if : test is not defined\\n\");\n-    if (style != NULL) style->errors++;\n-    return;\n+        xsltTransformError(NULL, style, inst,\n+             \"xsl:if : test is not defined\\n\");\n+        if (style != NULL) style->errors++;\n+        return;\n@@ -1707,4 +1709,4 @@\n-    xsltTransformError(NULL, style, inst,\n-         \"xsl:if : could not compile test expression '%s'\\n\",\n-                     comp->test);\n-    if (style != NULL) style->errors++;\n+        xsltTransformError(NULL, style, inst,\n+             \"xsl:if : could not compile test expression '%s'\\n\",\n+                         comp->test);\n+        if (style != NULL) style->errors++;\n@@ -1730,1 +1732,1 @@\n-    return;\n+        return;\n@@ -1734,1 +1736,1 @@\n-    xsltNewStylePreComp(style, XSLT_FUNC_WHEN);\n+        xsltNewStylePreComp(style, XSLT_FUNC_WHEN);\n@@ -1740,1 +1742,1 @@\n-    return;\n+        return;\n@@ -1746,4 +1748,4 @@\n-    xsltTransformError(NULL, style, inst,\n-         \"xsl:when : test is not defined\\n\");\n-    if (style != NULL) style->errors++;\n-    return;\n+        xsltTransformError(NULL, style, inst,\n+             \"xsl:when : test is not defined\\n\");\n+        if (style != NULL) style->errors++;\n+        return;\n@@ -1753,4 +1755,4 @@\n-    xsltTransformError(NULL, style, inst,\n-         \"xsl:when : could not compile test expression '%s'\\n\",\n-                     comp->test);\n-    if (style != NULL) style->errors++;\n+        xsltTransformError(NULL, style, inst,\n+             \"xsl:when : could not compile test expression '%s'\\n\",\n+                         comp->test);\n+        if (style != NULL) style->errors++;\n@@ -1776,1 +1778,1 @@\n-    return;\n+        return;\n@@ -1780,1 +1782,1 @@\n-    xsltNewStylePreComp(style, XSLT_FUNC_FOREACH);\n+        xsltNewStylePreComp(style, XSLT_FUNC_FOREACH);\n@@ -1786,1 +1788,1 @@\n-    return;\n+        return;\n@@ -1791,1 +1793,1 @@\n-                            XSLT_NAMESPACE);\n+                                XSLT_NAMESPACE);\n@@ -1793,6 +1795,0 @@\n-    xsltTransformError(NULL, style, inst,\n-        \"xsl:for-each : select is missing\\n\");\n-    if (style != NULL) style->errors++;\n-    } else {\n-    comp->comp = xsltXPathCompile(style, comp->select);\n-    if (comp->comp == NULL) {\n@@ -1800,2 +1796,1 @@\n-     \"xsl:for-each : could not compile select expression '%s'\\n\",\n-                 comp->select);\n+                \"xsl:for-each : select is missing\\n\");\n@@ -1803,1 +1798,8 @@\n-    }\n+    } else {\n+        comp->comp = xsltXPathCompile(style, comp->select);\n+        if (comp->comp == NULL) {\n+            xsltTransformError(NULL, style, inst,\n+     \"xsl:for-each : could not compile select expression '%s'\\n\",\n+                             comp->select);\n+            if (style != NULL) style->errors++;\n+        }\n@@ -1824,1 +1826,1 @@\n-    return;\n+        return;\n@@ -1828,1 +1830,1 @@\n-    xsltNewStylePreComp(style, XSLT_FUNC_VARIABLE);\n+        xsltNewStylePreComp(style, XSLT_FUNC_VARIABLE);\n@@ -1834,1 +1836,1 @@\n-    return;\n+        return;\n@@ -1846,1 +1848,1 @@\n-    1, &(comp->has_name), &(comp->ns), &(comp->name));\n+        1, &(comp->has_name), &(comp->ns), &(comp->name));\n@@ -1848,1 +1850,1 @@\n-    comp->has_ns = 1;\n+        comp->has_ns = 1;\n@@ -1853,1 +1855,1 @@\n-                            XSLT_NAMESPACE);\n+                                XSLT_NAMESPACE);\n@@ -1858,7 +1860,7 @@\n-    comp->comp = xsltXPathCompile(style, comp->select);\n-    if (comp->comp == NULL) {\n-        xsltTransformError(NULL, style, inst,\n-        \"XSLT-variable: Failed to compile the XPath expression '%s'.\\n\",\n-        comp->select);\n-        style->errors++;\n-    }\n+        comp->comp = xsltXPathCompile(style, comp->select);\n+        if (comp->comp == NULL) {\n+            xsltTransformError(NULL, style, inst,\n+                \"XSLT-variable: Failed to compile the XPath expression '%s'.\\n\",\n+                comp->select);\n+            style->errors++;\n+        }\n@@ -1866,6 +1868,6 @@\n-    if (inst->children != NULL) {\n-        xsltTransformError(NULL, style, inst,\n-        \"XSLT-variable: There must be no child nodes, since the \"\n-        \"attribute 'select' was specified.\\n\");\n-        style->errors++;\n-    }\n+        if (inst->children != NULL) {\n+            xsltTransformError(NULL, style, inst,\n+                \"XSLT-variable: There must be no child nodes, since the \"\n+                \"attribute 'select' was specified.\\n\");\n+            style->errors++;\n+        }\n@@ -1903,1 +1905,1 @@\n-    return;\n+        return;\n@@ -1907,1 +1909,1 @@\n-    xsltNewStylePreComp(style, XSLT_FUNC_PARAM);\n+        xsltNewStylePreComp(style, XSLT_FUNC_PARAM);\n@@ -1913,1 +1915,1 @@\n-    return;\n+        return;\n@@ -1921,1 +1923,1 @@\n-    1, &(comp->has_name), &(comp->ns), &(comp->name));\n+        1, &(comp->has_name), &(comp->ns), &(comp->name));\n@@ -1923,1 +1925,1 @@\n-    comp->has_ns = 1;\n+        comp->has_ns = 1;\n@@ -1928,1 +1930,1 @@\n-                            XSLT_NAMESPACE);\n+                                XSLT_NAMESPACE);\n@@ -1930,13 +1932,13 @@\n-    comp->comp = xsltXPathCompile(style, comp->select);\n-    if (comp->comp == NULL) {\n-        xsltTransformError(NULL, style, inst,\n-        \"XSLT-param: could not compile select expression '%s'.\\n\",\n-        comp->select);\n-        style->errors++;\n-    }\n-    if (inst->children != NULL) {\n-        xsltTransformError(NULL, style, inst,\n-        \"XSLT-param: The content should be empty since the \"\n-        \"attribute 'select' is present.\\n\");\n-        style->warnings++;\n-    }\n+        comp->comp = xsltXPathCompile(style, comp->select);\n+        if (comp->comp == NULL) {\n+            xsltTransformError(NULL, style, inst,\n+                \"XSLT-param: could not compile select expression '%s'.\\n\",\n+                comp->select);\n+            style->errors++;\n+        }\n+        if (inst->children != NULL) {\n+            xsltTransformError(NULL, style, inst,\n+                \"XSLT-param: The content should be empty since the \"\n+                \"attribute 'select' is present.\\n\");\n+            style->warnings++;\n+        }\n@@ -1947,3 +1949,3 @@\n- *                                  *\n- *          Generic interface                   *\n- *                                  *\n+ *                                                                      *\n+ *                  Generic interface                                   *\n+ *                                                                      *\n@@ -1963,1 +1965,1 @@\n-    return;\n+        return;\n@@ -1967,6 +1969,6 @@\n-    next = cur->next;\n-    if (cur->type == XSLT_FUNC_EXTENSION)\n-        cur->free(cur);\n-    else\n-        xsltFreeStylePreComp((xsltStylePreCompPtr) cur);\n-    cur = next;\n+        next = cur->next;\n+        if (cur->type == XSLT_FUNC_EXTENSION)\n+            cur->free(cur);\n+        else\n+            xsltFreeStylePreComp((xsltStylePreCompPtr) cur);\n+        cur = next;\n@@ -1994,3 +1996,3 @@\n-    if ((node != NULL) && (node->type == XML_ELEMENT_NODE))\n-        node->psvi = NULL;\n-    return;\n+        if ((node != NULL) && (node->type == XML_ELEMENT_NODE))\n+            node->psvi = NULL;\n+        return;\n@@ -1999,1 +2001,1 @@\n-    return;\n+        return;\n@@ -2001,1 +2003,1 @@\n-    return;\n+        return;\n@@ -2005,161 +2007,84 @@\n-    switch (XSLT_CCTXT(style)->inode->type) {\n-        case XSLT_FUNC_APPLYTEMPLATES:\n-        xsltApplyTemplatesComp(style, node);\n-        break;\n-        case XSLT_FUNC_WITHPARAM:\n-        xsltWithParamComp(style, node);\n-        break;\n-        case XSLT_FUNC_VALUEOF:\n-        xsltValueOfComp(style, node);\n-        break;\n-        case XSLT_FUNC_COPY:\n-        xsltCopyComp(style, node);\n-        break;\n-        case XSLT_FUNC_COPYOF:\n-        xsltCopyOfComp(style, node);\n-        break;\n-        case XSLT_FUNC_IF:\n-        xsltIfComp(style, node);\n-        break;\n-        case XSLT_FUNC_CHOOSE:\n-        xsltChooseComp(style, node);\n-        break;\n-        case XSLT_FUNC_WHEN:\n-        xsltWhenComp(style, node);\n-        break;\n-        case XSLT_FUNC_OTHERWISE:\n-        \/* NOP yet *\/\n-        return;\n-        case XSLT_FUNC_FOREACH:\n-        xsltForEachComp(style, node);\n-        break;\n-        case XSLT_FUNC_APPLYIMPORTS:\n-        xsltApplyImportsComp(style, node);\n-        break;\n-        case XSLT_FUNC_ATTRIBUTE:\n-        xsltAttributeComp(style, node);\n-        break;\n-        case XSLT_FUNC_ELEMENT:\n-        xsltElementComp(style, node);\n-        break;\n-        case XSLT_FUNC_SORT:\n-        xsltSortComp(style, node);\n-        break;\n-        case XSLT_FUNC_COMMENT:\n-        xsltCommentComp(style, node);\n-        break;\n-        case XSLT_FUNC_NUMBER:\n-        xsltNumberComp(style, node);\n-        break;\n-        case XSLT_FUNC_PI:\n-        xsltProcessingInstructionComp(style, node);\n-        break;\n-        case XSLT_FUNC_CALLTEMPLATE:\n-        xsltCallTemplateComp(style, node);\n-        break;\n-        case XSLT_FUNC_PARAM:\n-        xsltParamComp(style, node);\n-        break;\n-        case XSLT_FUNC_VARIABLE:\n-        xsltVariableComp(style, node);\n-        break;\n-        case XSLT_FUNC_FALLBACK:\n-        \/* NOP yet *\/\n-        return;\n-        case XSLT_FUNC_DOCUMENT:\n-        \/* The extra one *\/\n-        node->psvi = (void *) xsltDocumentComp(style, node,\n-            xsltDocumentElem);\n-        break;\n-        case XSLT_FUNC_MESSAGE:\n-        \/* NOP yet *\/\n-        return;\n-        default:\n-        \/*\n-        * NOTE that xsl:text, xsl:template, xsl:stylesheet,\n-        *  xsl:transform, xsl:import, xsl:include are not expected\n-        *  to be handed over to this function.\n-        *\/\n-        xsltTransformError(NULL, style, node,\n-            \"Internal error: (xsltStylePreCompute) cannot handle \"\n-            \"the XSLT element '%s'.\\n\", node->name);\n-        style->errors++;\n-        return;\n-    }\n-    } else {\n-    \/*\n-    * Fallback to string comparison.\n-    *\/\n-    if (IS_XSLT_NAME(node, \"apply-templates\")) {\n-        xsltApplyTemplatesComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"with-param\")) {\n-        xsltWithParamComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"value-of\")) {\n-        xsltValueOfComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"copy\")) {\n-        xsltCopyComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"copy-of\")) {\n-        xsltCopyOfComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"if\")) {\n-        xsltIfComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"choose\")) {\n-        xsltChooseComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"when\")) {\n-        xsltWhenComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"otherwise\")) {\n-        \/* NOP yet *\/\n-        return;\n-    } else if (IS_XSLT_NAME(node, \"for-each\")) {\n-        xsltForEachComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"apply-imports\")) {\n-        xsltApplyImportsComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"attribute\")) {\n-        xsltAttributeComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"element\")) {\n-        xsltElementComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"sort\")) {\n-        xsltSortComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"comment\")) {\n-        xsltCommentComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"number\")) {\n-        xsltNumberComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"processing-instruction\")) {\n-        xsltProcessingInstructionComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"call-template\")) {\n-        xsltCallTemplateComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"param\")) {\n-        xsltParamComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"variable\")) {\n-        xsltVariableComp(style, node);\n-    } else if (IS_XSLT_NAME(node, \"fallback\")) {\n-        \/* NOP yet *\/\n-        return;\n-    } else if (IS_XSLT_NAME(node, \"document\")) {\n-        \/* The extra one *\/\n-        node->psvi = (void *) xsltDocumentComp(style, node,\n-        xsltDocumentElem);\n-    } else if (IS_XSLT_NAME(node, \"output\")) {\n-        \/* Top-level *\/\n-        return;\n-    } else if (IS_XSLT_NAME(node, \"preserve-space\")) {\n-        \/* Top-level *\/\n-        return;\n-    } else if (IS_XSLT_NAME(node, \"strip-space\")) {\n-        \/* Top-level *\/\n-        return;\n-    } else if (IS_XSLT_NAME(node, \"key\")) {\n-        \/* Top-level *\/\n-        return;\n-    } else if (IS_XSLT_NAME(node, \"message\")) {\n-        return;\n-    } else if (IS_XSLT_NAME(node, \"attribute-set\")) {\n-        \/* Top-level *\/\n-        return;\n-    } else if (IS_XSLT_NAME(node, \"namespace-alias\")) {\n-        \/* Top-level *\/\n-        return;\n-    } else if (IS_XSLT_NAME(node, \"decimal-format\")) {\n-        \/* Top-level *\/\n-        return;\n-    } else if (IS_XSLT_NAME(node, \"include\")) {\n-        \/* Top-level *\/\n+        switch (XSLT_CCTXT(style)->inode->type) {\n+            case XSLT_FUNC_APPLYTEMPLATES:\n+                xsltApplyTemplatesComp(style, node);\n+                break;\n+            case XSLT_FUNC_WITHPARAM:\n+                xsltWithParamComp(style, node);\n+                break;\n+            case XSLT_FUNC_VALUEOF:\n+                xsltValueOfComp(style, node);\n+                break;\n+            case XSLT_FUNC_COPY:\n+                xsltCopyComp(style, node);\n+                break;\n+            case XSLT_FUNC_COPYOF:\n+                xsltCopyOfComp(style, node);\n+                break;\n+            case XSLT_FUNC_IF:\n+                xsltIfComp(style, node);\n+                break;\n+            case XSLT_FUNC_CHOOSE:\n+                xsltChooseComp(style, node);\n+                break;\n+            case XSLT_FUNC_WHEN:\n+                xsltWhenComp(style, node);\n+                break;\n+            case XSLT_FUNC_OTHERWISE:\n+                \/* NOP yet *\/\n+                return;\n+            case XSLT_FUNC_FOREACH:\n+                xsltForEachComp(style, node);\n+                break;\n+            case XSLT_FUNC_APPLYIMPORTS:\n+                xsltApplyImportsComp(style, node);\n+                break;\n+            case XSLT_FUNC_ATTRIBUTE:\n+                xsltAttributeComp(style, node);\n+                break;\n+            case XSLT_FUNC_ELEMENT:\n+                xsltElementComp(style, node);\n+                break;\n+            case XSLT_FUNC_SORT:\n+                xsltSortComp(style, node);\n+                break;\n+            case XSLT_FUNC_COMMENT:\n+                xsltCommentComp(style, node);\n+                break;\n+            case XSLT_FUNC_NUMBER:\n+                xsltNumberComp(style, node);\n+                break;\n+            case XSLT_FUNC_PI:\n+                xsltProcessingInstructionComp(style, node);\n+                break;\n+            case XSLT_FUNC_CALLTEMPLATE:\n+                xsltCallTemplateComp(style, node);\n+                break;\n+            case XSLT_FUNC_PARAM:\n+                xsltParamComp(style, node);\n+                break;\n+            case XSLT_FUNC_VARIABLE:\n+                xsltVariableComp(style, node);\n+                break;\n+            case XSLT_FUNC_FALLBACK:\n+                \/* NOP yet *\/\n+                return;\n+            case XSLT_FUNC_DOCUMENT:\n+                \/* The extra one *\/\n+                node->psvi = (void *) xsltDocumentComp(style, node,\n+                    xsltDocumentElem);\n+                break;\n+            case XSLT_FUNC_MESSAGE:\n+                \/* NOP yet *\/\n+                return;\n+            default:\n+                \/*\n+                * NOTE that xsl:text, xsl:template, xsl:stylesheet,\n+                *  xsl:transform, xsl:import, xsl:include are not expected\n+                *  to be handed over to this function.\n+                *\/\n+                xsltTransformError(NULL, style, node,\n+                    \"Internal error: (xsltStylePreCompute) cannot handle \"\n+                    \"the XSLT element '%s'.\\n\", node->name);\n+                style->errors++;\n+                return;\n+        }\n@@ -2168,3 +2093,1 @@\n-        * NOTE that xsl:text, xsl:template, xsl:stylesheet,\n-        *  xsl:transform, xsl:import, xsl:include are not expected\n-        *  to be handed over to this function.\n+        * Fallback to string comparison.\n@@ -2172,6 +2095,85 @@\n-        xsltTransformError(NULL, style, node,\n-        \"Internal error: (xsltStylePreCompute) cannot handle \"\n-        \"the XSLT element '%s'.\\n\", node->name);\n-        style->errors++;\n-        return;\n-    }\n+        if (IS_XSLT_NAME(node, \"apply-templates\")) {\n+            xsltApplyTemplatesComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"with-param\")) {\n+            xsltWithParamComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"value-of\")) {\n+            xsltValueOfComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"copy\")) {\n+            xsltCopyComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"copy-of\")) {\n+            xsltCopyOfComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"if\")) {\n+            xsltIfComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"choose\")) {\n+            xsltChooseComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"when\")) {\n+            xsltWhenComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"otherwise\")) {\n+            \/* NOP yet *\/\n+            return;\n+        } else if (IS_XSLT_NAME(node, \"for-each\")) {\n+            xsltForEachComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"apply-imports\")) {\n+            xsltApplyImportsComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"attribute\")) {\n+            xsltAttributeComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"element\")) {\n+            xsltElementComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"sort\")) {\n+            xsltSortComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"comment\")) {\n+            xsltCommentComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"number\")) {\n+            xsltNumberComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"processing-instruction\")) {\n+            xsltProcessingInstructionComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"call-template\")) {\n+            xsltCallTemplateComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"param\")) {\n+            xsltParamComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"variable\")) {\n+            xsltVariableComp(style, node);\n+        } else if (IS_XSLT_NAME(node, \"fallback\")) {\n+            \/* NOP yet *\/\n+            return;\n+        } else if (IS_XSLT_NAME(node, \"document\")) {\n+            \/* The extra one *\/\n+            node->psvi = (void *) xsltDocumentComp(style, node,\n+                xsltDocumentElem);\n+        } else if (IS_XSLT_NAME(node, \"output\")) {\n+            \/* Top-level *\/\n+            return;\n+        } else if (IS_XSLT_NAME(node, \"preserve-space\")) {\n+            \/* Top-level *\/\n+            return;\n+        } else if (IS_XSLT_NAME(node, \"strip-space\")) {\n+            \/* Top-level *\/\n+            return;\n+        } else if (IS_XSLT_NAME(node, \"key\")) {\n+            \/* Top-level *\/\n+            return;\n+        } else if (IS_XSLT_NAME(node, \"message\")) {\n+            return;\n+        } else if (IS_XSLT_NAME(node, \"attribute-set\")) {\n+            \/* Top-level *\/\n+            return;\n+        } else if (IS_XSLT_NAME(node, \"namespace-alias\")) {\n+            \/* Top-level *\/\n+            return;\n+        } else if (IS_XSLT_NAME(node, \"decimal-format\")) {\n+            \/* Top-level *\/\n+            return;\n+        } else if (IS_XSLT_NAME(node, \"include\")) {\n+            \/* Top-level *\/\n+        } else {\n+            \/*\n+            * NOTE that xsl:text, xsl:template, xsl:stylesheet,\n+            *  xsl:transform, xsl:import, xsl:include are not expected\n+            *  to be handed over to this function.\n+            *\/\n+            xsltTransformError(NULL, style, node,\n+                \"Internal error: (xsltStylePreCompute) cannot handle \"\n+                \"the XSLT element '%s'.\\n\", node->name);\n+                style->errors++;\n+            return;\n+        }\n@@ -2184,2 +2186,2 @@\n-    ((xsltStylePreCompPtr) node->psvi)->inScopeNs =\n-        XSLT_CCTXT(style)->inode->inScopeNs;\n+        ((xsltStylePreCompPtr) node->psvi)->inScopeNs =\n+            XSLT_CCTXT(style)->inode->inScopeNs;\n@@ -2211,1 +2213,1 @@\n-    return;\n+        return;\n@@ -2214,1 +2216,1 @@\n-    xsltStylePreCompPtr cur;\n+        xsltStylePreCompPtr cur;\n@@ -2216,66 +2218,1 @@\n-    if (IS_XSLT_NAME(inst, \"apply-templates\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        xsltApplyTemplatesComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"with-param\")) {\n-        xsltCheckParentElement(style, inst, BAD_CAST \"apply-templates\",\n-                               BAD_CAST \"call-template\");\n-        xsltWithParamComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"value-of\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        xsltValueOfComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"copy\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        xsltCopyComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"copy-of\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        xsltCopyOfComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"if\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        xsltIfComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"when\")) {\n-        xsltCheckParentElement(style, inst, BAD_CAST \"choose\", NULL);\n-        xsltWhenComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"choose\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        xsltChooseComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"for-each\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        xsltForEachComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"apply-imports\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        xsltApplyImportsComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"attribute\")) {\n-        xmlNodePtr parent = inst->parent;\n-\n-        if ((parent == NULL) ||\n-            (parent->type != XML_ELEMENT_NODE) || (parent->ns == NULL) ||\n-        ((parent->ns != inst->ns) &&\n-         (!xmlStrEqual(parent->ns->href, inst->ns->href))) ||\n-        (!xmlStrEqual(parent->name, BAD_CAST \"attribute-set\"))) {\n-        xsltCheckInstructionElement(style, inst);\n-        }\n-        xsltAttributeComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"element\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        xsltElementComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"text\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        xsltTextComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"sort\")) {\n-        xsltCheckParentElement(style, inst, BAD_CAST \"apply-templates\",\n-                               BAD_CAST \"for-each\");\n-        xsltSortComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"comment\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        xsltCommentComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"number\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        xsltNumberComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"processing-instruction\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        xsltProcessingInstructionComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"call-template\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        xsltCallTemplateComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"param\")) {\n-        if (xsltCheckTopLevelElement(style, inst, 0) == 0)\n+        if (IS_XSLT_NAME(inst, \"apply-templates\")) {\n@@ -2283,3 +2220,6 @@\n-        xsltParamComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"variable\")) {\n-        if (xsltCheckTopLevelElement(style, inst, 0) == 0)\n+            xsltApplyTemplatesComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"with-param\")) {\n+            xsltCheckParentElement(style, inst, BAD_CAST \"apply-templates\",\n+                                   BAD_CAST \"call-template\");\n+            xsltWithParamComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"value-of\")) {\n@@ -2287,26 +2227,122 @@\n-        xsltVariableComp(style, inst);\n-    } else if (IS_XSLT_NAME(inst, \"otherwise\")) {\n-        xsltCheckParentElement(style, inst, BAD_CAST \"choose\", NULL);\n-        xsltCheckInstructionElement(style, inst);\n-        return;\n-    } else if (IS_XSLT_NAME(inst, \"template\")) {\n-        xsltCheckTopLevelElement(style, inst, 1);\n-        return;\n-    } else if (IS_XSLT_NAME(inst, \"output\")) {\n-        xsltCheckTopLevelElement(style, inst, 1);\n-        return;\n-    } else if (IS_XSLT_NAME(inst, \"preserve-space\")) {\n-        xsltCheckTopLevelElement(style, inst, 1);\n-        return;\n-    } else if (IS_XSLT_NAME(inst, \"strip-space\")) {\n-        xsltCheckTopLevelElement(style, inst, 1);\n-        return;\n-    } else if ((IS_XSLT_NAME(inst, \"stylesheet\")) ||\n-               (IS_XSLT_NAME(inst, \"transform\"))) {\n-        xmlNodePtr parent = inst->parent;\n-\n-        if ((parent == NULL) || (parent->type != XML_DOCUMENT_NODE)) {\n-        xsltTransformError(NULL, style, inst,\n-            \"element %s only allowed only as root element\\n\",\n-                   inst->name);\n-        style->errors++;\n+            xsltValueOfComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"copy\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            xsltCopyComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"copy-of\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            xsltCopyOfComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"if\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            xsltIfComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"when\")) {\n+            xsltCheckParentElement(style, inst, BAD_CAST \"choose\", NULL);\n+            xsltWhenComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"choose\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            xsltChooseComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"for-each\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            xsltForEachComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"apply-imports\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            xsltApplyImportsComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"attribute\")) {\n+            xmlNodePtr parent = inst->parent;\n+\n+            if ((parent == NULL) ||\n+                (parent->type != XML_ELEMENT_NODE) || (parent->ns == NULL) ||\n+                ((parent->ns != inst->ns) &&\n+                 (!xmlStrEqual(parent->ns->href, inst->ns->href))) ||\n+                (!xmlStrEqual(parent->name, BAD_CAST \"attribute-set\"))) {\n+                xsltCheckInstructionElement(style, inst);\n+            }\n+            xsltAttributeComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"element\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            xsltElementComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"text\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            xsltTextComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"sort\")) {\n+            xsltCheckParentElement(style, inst, BAD_CAST \"apply-templates\",\n+                                   BAD_CAST \"for-each\");\n+            xsltSortComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"comment\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            xsltCommentComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"number\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            xsltNumberComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"processing-instruction\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            xsltProcessingInstructionComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"call-template\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            xsltCallTemplateComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"param\")) {\n+            if (xsltCheckTopLevelElement(style, inst, 0) == 0)\n+                xsltCheckInstructionElement(style, inst);\n+            xsltParamComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"variable\")) {\n+            if (xsltCheckTopLevelElement(style, inst, 0) == 0)\n+                xsltCheckInstructionElement(style, inst);\n+            xsltVariableComp(style, inst);\n+        } else if (IS_XSLT_NAME(inst, \"otherwise\")) {\n+            xsltCheckParentElement(style, inst, BAD_CAST \"choose\", NULL);\n+            xsltCheckInstructionElement(style, inst);\n+            return;\n+        } else if (IS_XSLT_NAME(inst, \"template\")) {\n+            xsltCheckTopLevelElement(style, inst, 1);\n+            return;\n+        } else if (IS_XSLT_NAME(inst, \"output\")) {\n+            xsltCheckTopLevelElement(style, inst, 1);\n+            return;\n+        } else if (IS_XSLT_NAME(inst, \"preserve-space\")) {\n+            xsltCheckTopLevelElement(style, inst, 1);\n+            return;\n+        } else if (IS_XSLT_NAME(inst, \"strip-space\")) {\n+            xsltCheckTopLevelElement(style, inst, 1);\n+            return;\n+        } else if ((IS_XSLT_NAME(inst, \"stylesheet\")) ||\n+                   (IS_XSLT_NAME(inst, \"transform\"))) {\n+            xmlNodePtr parent = inst->parent;\n+\n+            if ((parent == NULL) || (parent->type != XML_DOCUMENT_NODE)) {\n+                xsltTransformError(NULL, style, inst,\n+                    \"element %s only allowed only as root element\\n\",\n+                                   inst->name);\n+                style->errors++;\n+            }\n+            return;\n+        } else if (IS_XSLT_NAME(inst, \"key\")) {\n+            xsltCheckTopLevelElement(style, inst, 1);\n+            return;\n+        } else if (IS_XSLT_NAME(inst, \"message\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            return;\n+        } else if (IS_XSLT_NAME(inst, \"attribute-set\")) {\n+            xsltCheckTopLevelElement(style, inst, 1);\n+            return;\n+        } else if (IS_XSLT_NAME(inst, \"namespace-alias\")) {\n+            xsltCheckTopLevelElement(style, inst, 1);\n+            return;\n+        } else if (IS_XSLT_NAME(inst, \"include\")) {\n+            xsltCheckTopLevelElement(style, inst, 1);\n+            return;\n+        } else if (IS_XSLT_NAME(inst, \"import\")) {\n+            xsltCheckTopLevelElement(style, inst, 1);\n+            return;\n+        } else if (IS_XSLT_NAME(inst, \"decimal-format\")) {\n+            xsltCheckTopLevelElement(style, inst, 1);\n+            return;\n+        } else if (IS_XSLT_NAME(inst, \"fallback\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            return;\n+        } else if (IS_XSLT_NAME(inst, \"document\")) {\n+            xsltCheckInstructionElement(style, inst);\n+            inst->psvi = (void *) xsltDocumentComp(style, inst,\n+                                xsltDocumentElem);\n+        } else if ((style == NULL) || (style->forwards_compatible == 0)) {\n+            xsltTransformError(NULL, style, inst,\n+                 \"xsltStylePreCompute: unknown xsl:%s\\n\", inst->name);\n+            if (style != NULL) style->warnings++;\n@@ -2314,34 +2350,0 @@\n-        return;\n-    } else if (IS_XSLT_NAME(inst, \"key\")) {\n-        xsltCheckTopLevelElement(style, inst, 1);\n-        return;\n-    } else if (IS_XSLT_NAME(inst, \"message\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        return;\n-    } else if (IS_XSLT_NAME(inst, \"attribute-set\")) {\n-        xsltCheckTopLevelElement(style, inst, 1);\n-        return;\n-    } else if (IS_XSLT_NAME(inst, \"namespace-alias\")) {\n-        xsltCheckTopLevelElement(style, inst, 1);\n-        return;\n-    } else if (IS_XSLT_NAME(inst, \"include\")) {\n-        xsltCheckTopLevelElement(style, inst, 1);\n-        return;\n-    } else if (IS_XSLT_NAME(inst, \"import\")) {\n-        xsltCheckTopLevelElement(style, inst, 1);\n-        return;\n-    } else if (IS_XSLT_NAME(inst, \"decimal-format\")) {\n-        xsltCheckTopLevelElement(style, inst, 1);\n-        return;\n-    } else if (IS_XSLT_NAME(inst, \"fallback\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        return;\n-    } else if (IS_XSLT_NAME(inst, \"document\")) {\n-        xsltCheckInstructionElement(style, inst);\n-        inst->psvi = (void *) xsltDocumentComp(style, inst,\n-                xsltDocumentElem);\n-    } else if ((style == NULL) || (style->forwards_compatible == 0)) {\n-        xsltTransformError(NULL, style, inst,\n-         \"xsltStylePreCompute: unknown xsl:%s\\n\", inst->name);\n-        if (style != NULL) style->warnings++;\n-    }\n@@ -2349,7 +2351,7 @@\n-    cur = (xsltStylePreCompPtr) inst->psvi;\n-    \/*\n-    * A ns-list is build for every XSLT item in the\n-    * node-tree. This is needed for XPath expressions.\n-    *\/\n-    if (cur != NULL) {\n-        int i = 0;\n+        cur = (xsltStylePreCompPtr) inst->psvi;\n+        \/*\n+        * A ns-list is build for every XSLT item in the\n+        * node-tree. This is needed for XPath expressions.\n+        *\/\n+        if (cur != NULL) {\n+            int i = 0;\n@@ -2357,1 +2359,1 @@\n-        cur->nsList = xmlGetNsList(inst->doc, inst);\n+            cur->nsList = xmlGetNsList(inst->doc, inst);\n@@ -2359,2 +2361,4 @@\n-        while (cur->nsList[i] != NULL)\n-            i++;\n+                while (cur->nsList[i] != NULL)\n+                    i++;\n+            }\n+            cur->nsNr = i;\n@@ -2362,2 +2366,0 @@\n-        cur->nsNr = i;\n-    }\n@@ -2365,2 +2367,2 @@\n-    inst->psvi =\n-        (void *) xsltPreComputeExtModuleElement(style, inst);\n+        inst->psvi =\n+            (void *) xsltPreComputeExtModuleElement(style, inst);\n@@ -2368,6 +2370,6 @@\n-    \/*\n-     * Unknown element, maybe registered at the context\n-     * level. Mark it for later recognition.\n-     *\/\n-    if (inst->psvi == NULL)\n-        inst->psvi = (void *) xsltExtMarker;\n+        \/*\n+         * Unknown element, maybe registered at the context\n+         * level. Mark it for later recognition.\n+         *\/\n+        if (inst->psvi == NULL)\n+            inst->psvi = (void *) xsltExtMarker;\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/preproc.c","additions":1002,"deletions":1000,"binary":false,"changes":2002,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-extern const xmlChar *xsltExtMarker;\n+XSLTPUBVAR const xmlChar *xsltExtMarker;\n@@ -28,3 +28,3 @@\n-        xsltDocumentComp    (xsltStylesheetPtr style,\n-                     xmlNodePtr inst,\n-                     xsltTransformFunction function);\n+                xsltDocumentComp        (xsltStylesheetPtr style,\n+                                         xmlNodePtr inst,\n+                                         xsltTransformFunction function);\n@@ -33,2 +33,2 @@\n-        xsltStylePreCompute (xsltStylesheetPtr style,\n-                     xmlNodePtr inst);\n+                xsltStylePreCompute     (xsltStylesheetPtr style,\n+                                         xmlNodePtr inst);\n@@ -36,1 +36,1 @@\n-        xsltFreeStylePreComps   (xsltStylesheetPtr style);\n+                xsltFreeStylePreComps   (xsltStylesheetPtr style);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/preproc.h","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -76,3 +76,3 @@\n- *                                  *\n- *          Module interfaces               *\n- *                                  *\n+ *                                                                      *\n+ *                      Module interfaces                               *\n+ *                                                                      *\n@@ -96,3 +96,3 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltNewSecurityPrefs : malloc failed\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, NULL,\n+                \"xsltNewSecurityPrefs : malloc failed\\n\");\n+        return(NULL);\n@@ -113,1 +113,1 @@\n-    return;\n+        return;\n@@ -132,1 +132,1 @@\n-    return(-1);\n+        return(-1);\n@@ -160,1 +160,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -211,1 +211,1 @@\n-                     xsltTransformContextPtr ctxt) {\n+                         xsltTransformContextPtr ctxt) {\n@@ -213,1 +213,1 @@\n-    return(-1);\n+        return(-1);\n@@ -231,2 +231,2 @@\n-              xsltTransformContextPtr ctxt ATTRIBUTE_UNUSED,\n-          const char *value ATTRIBUTE_UNUSED) {\n+                  xsltTransformContextPtr ctxt ATTRIBUTE_UNUSED,\n+                  const char *value ATTRIBUTE_UNUSED) {\n@@ -248,2 +248,2 @@\n-              xsltTransformContextPtr ctxt ATTRIBUTE_UNUSED,\n-          const char *value ATTRIBUTE_UNUSED) {\n+                  xsltTransformContextPtr ctxt ATTRIBUTE_UNUSED,\n+                  const char *value ATTRIBUTE_UNUSED) {\n@@ -254,3 +254,3 @@\n- *                                  *\n- *          Internal interfaces             *\n- *                                  *\n+ *                                                                      *\n+ *                      Internal interfaces                             *\n+ *                                                                      *\n@@ -285,1 +285,1 @@\n-    dwAttrs = GetFileAttributes(path);\n+    dwAttrs = GetFileAttributesA(path);\n@@ -289,1 +289,1 @@\n-        }\n+                }\n@@ -307,2 +307,2 @@\n-           xsltTransformContextPtr ctxt,\n-           const char *path)\n+                   xsltTransformContextPtr ctxt,\n+                   const char *path)\n@@ -316,6 +316,6 @@\n-    ret = check(sec, ctxt, path);\n-    if (ret == 0) {\n-        xsltTransformError(ctxt, NULL, NULL,\n-                   \"File write for %s refused\\n\", path);\n-        return(0);\n-    }\n+        ret = check(sec, ctxt, path);\n+        if (ret == 0) {\n+            xsltTransformError(ctxt, NULL, NULL,\n+                               \"File write for %s refused\\n\", path);\n+            return(0);\n+        }\n@@ -327,9 +327,1 @@\n-    ret = xsltCheckFilename(directory);\n-    if (ret == 0) {\n-        \/*\n-         * The directory doesn't exist check for creation\n-         *\/\n-        check = xsltGetSecurityPrefs(sec,\n-                     XSLT_SECPREF_CREATE_DIRECTORY);\n-        if (check != NULL) {\n-        ret = check(sec, ctxt, directory);\n+        ret = xsltCheckFilename(directory);\n@@ -337,6 +329,18 @@\n-            xsltTransformError(ctxt, NULL, NULL,\n-                       \"Directory creation for %s refused\\n\",\n-                       path);\n-            xmlFree(directory);\n-            return(0);\n-        }\n+            \/*\n+             * The directory doesn't exist check for creation\n+             *\/\n+            check = xsltGetSecurityPrefs(sec,\n+                                         XSLT_SECPREF_CREATE_DIRECTORY);\n+            if (check != NULL) {\n+                ret = check(sec, ctxt, directory);\n+                if (ret == 0) {\n+                    xsltTransformError(ctxt, NULL, NULL,\n+                                       \"Directory creation for %s refused\\n\",\n+                                       path);\n+                    xmlFree(directory);\n+                    return(0);\n+                }\n+            }\n+            ret = xsltCheckWritePath(sec, ctxt, directory);\n+            if (ret == 1)\n+                ret = mkdir(directory, 0755);\n@@ -344,7 +348,3 @@\n-        ret = xsltCheckWritePath(sec, ctxt, directory);\n-        if (ret == 1)\n-        ret = mkdir(directory, 0755);\n-    }\n-    xmlFree(directory);\n-    if (ret < 0)\n-        return(ret);\n+        xmlFree(directory);\n+        if (ret < 0)\n+            return(ret);\n@@ -369,1 +369,1 @@\n-           xsltTransformContextPtr ctxt, const xmlChar *URL) {\n+               xsltTransformContextPtr ctxt, const xmlChar *URL) {\n@@ -377,6 +377,6 @@\n-    if (uri == NULL) {\n-        xsltTransformError(ctxt, NULL, NULL,\n-         \"xsltCheckWrite: out of memory for %s\\n\", URL);\n-        return(-1);\n-    }\n-    uri->path = (char *)xmlStrdup(URL);\n+        if (uri == NULL) {\n+            xsltTransformError(ctxt, NULL, NULL,\n+             \"xsltCheckWrite: out of memory for %s\\n\", URL);\n+            return(-1);\n+        }\n+        uri->path = (char *)xmlStrdup(URL);\n@@ -385,1 +385,1 @@\n-    (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST \"file\"))) {\n+        (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST \"file\"))) {\n@@ -397,1 +397,1 @@\n-        ret = xsltCheckWritePath(sec, ctxt, uri->path);\n+            ret = xsltCheckWritePath(sec, ctxt, uri->path);\n@@ -400,4 +400,4 @@\n-    if (ret <= 0) {\n-        xmlFreeURI(uri);\n-        return(ret);\n-    }\n+        if (ret <= 0) {\n+            xmlFreeURI(uri);\n+            return(ret);\n+        }\n@@ -405,11 +405,12 @@\n-    \/*\n-     * Check if we are allowed to write this network resource\n-     *\/\n-    check = xsltGetSecurityPrefs(sec, XSLT_SECPREF_WRITE_NETWORK);\n-    if (check != NULL) {\n-        ret = check(sec, ctxt, (const char *)URL);\n-        if (ret == 0) {\n-        xsltTransformError(ctxt, NULL, NULL,\n-                 \"File write for %s refused\\n\", URL);\n-        xmlFreeURI(uri);\n-        return(0);\n+        \/*\n+         * Check if we are allowed to write this network resource\n+         *\/\n+        check = xsltGetSecurityPrefs(sec, XSLT_SECPREF_WRITE_NETWORK);\n+        if (check != NULL) {\n+            ret = check(sec, ctxt, (const char *)URL);\n+            if (ret == 0) {\n+                xsltTransformError(ctxt, NULL, NULL,\n+                             \"File write for %s refused\\n\", URL);\n+                xmlFreeURI(uri);\n+                return(0);\n+            }\n@@ -418,1 +419,0 @@\n-    }\n@@ -436,1 +436,1 @@\n-          xsltTransformContextPtr ctxt, const xmlChar *URL) {\n+              xsltTransformContextPtr ctxt, const xmlChar *URL) {\n@@ -443,4 +443,4 @@\n-    xsltTransformError(ctxt, NULL, NULL,\n-     \"xsltCheckRead: URL parsing failed for %s\\n\",\n-             URL);\n-    return(-1);\n+        xsltTransformError(ctxt, NULL, NULL,\n+         \"xsltCheckRead: URL parsing failed for %s\\n\",\n+                         URL);\n+        return(-1);\n@@ -449,1 +449,1 @@\n-    (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST \"file\"))) {\n+        (xmlStrEqual(BAD_CAST uri->scheme, BAD_CAST \"file\"))) {\n@@ -451,11 +451,12 @@\n-    \/*\n-     * Check if we are allowed to read this file\n-     *\/\n-    check = xsltGetSecurityPrefs(sec, XSLT_SECPREF_READ_FILE);\n-    if (check != NULL) {\n-        ret = check(sec, ctxt, uri->path);\n-        if (ret == 0) {\n-        xsltTransformError(ctxt, NULL, NULL,\n-                 \"Local file read for %s refused\\n\", URL);\n-        xmlFreeURI(uri);\n-        return(0);\n+        \/*\n+         * Check if we are allowed to read this file\n+         *\/\n+        check = xsltGetSecurityPrefs(sec, XSLT_SECPREF_READ_FILE);\n+        if (check != NULL) {\n+            ret = check(sec, ctxt, uri->path);\n+            if (ret == 0) {\n+                xsltTransformError(ctxt, NULL, NULL,\n+                             \"Local file read for %s refused\\n\", URL);\n+                xmlFreeURI(uri);\n+                return(0);\n+            }\n@@ -463,1 +464,0 @@\n-    }\n@@ -465,11 +465,12 @@\n-    \/*\n-     * Check if we are allowed to write this network resource\n-     *\/\n-    check = xsltGetSecurityPrefs(sec, XSLT_SECPREF_READ_NETWORK);\n-    if (check != NULL) {\n-        ret = check(sec, ctxt, (const char *)URL);\n-        if (ret == 0) {\n-        xsltTransformError(ctxt, NULL, NULL,\n-                 \"Network file read for %s refused\\n\", URL);\n-        xmlFreeURI(uri);\n-        return(0);\n+        \/*\n+         * Check if we are allowed to write this network resource\n+         *\/\n+        check = xsltGetSecurityPrefs(sec, XSLT_SECPREF_READ_NETWORK);\n+        if (check != NULL) {\n+            ret = check(sec, ctxt, (const char *)URL);\n+            if (ret == 0) {\n+                xsltTransformError(ctxt, NULL, NULL,\n+                             \"Network file read for %s refused\\n\", URL);\n+                xmlFreeURI(uri);\n+                return(0);\n+            }\n@@ -478,1 +479,0 @@\n-    }\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/security.c","additions":105,"deletions":105,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -51,3 +51,3 @@\n-typedef int (*xsltSecurityCheck)    (xsltSecurityPrefsPtr sec,\n-                     xsltTransformContextPtr ctxt,\n-                     const char *value);\n+typedef int (*xsltSecurityCheck)        (xsltSecurityPrefsPtr sec,\n+                                         xsltTransformContextPtr ctxt,\n+                                         const char *value);\n@@ -59,1 +59,1 @@\n-            xsltNewSecurityPrefs    (void);\n+                    xsltNewSecurityPrefs        (void);\n@@ -61,1 +61,1 @@\n-            xsltFreeSecurityPrefs   (xsltSecurityPrefsPtr sec);\n+                    xsltFreeSecurityPrefs       (xsltSecurityPrefsPtr sec);\n@@ -63,3 +63,3 @@\n-            xsltSetSecurityPrefs    (xsltSecurityPrefsPtr sec,\n-                         xsltSecurityOption option,\n-                         xsltSecurityCheck func);\n+                    xsltSetSecurityPrefs        (xsltSecurityPrefsPtr sec,\n+                                                 xsltSecurityOption option,\n+                                                 xsltSecurityCheck func);\n@@ -67,2 +67,2 @@\n-            xsltGetSecurityPrefs    (xsltSecurityPrefsPtr sec,\n-                         xsltSecurityOption option);\n+                    xsltGetSecurityPrefs        (xsltSecurityPrefsPtr sec,\n+                                                 xsltSecurityOption option);\n@@ -71,1 +71,1 @@\n-            xsltSetDefaultSecurityPrefs (xsltSecurityPrefsPtr sec);\n+                    xsltSetDefaultSecurityPrefs (xsltSecurityPrefsPtr sec);\n@@ -73,1 +73,1 @@\n-            xsltGetDefaultSecurityPrefs (void);\n+                    xsltGetDefaultSecurityPrefs (void);\n@@ -76,2 +76,2 @@\n-            xsltSetCtxtSecurityPrefs    (xsltSecurityPrefsPtr sec,\n-                         xsltTransformContextPtr ctxt);\n+                    xsltSetCtxtSecurityPrefs    (xsltSecurityPrefsPtr sec,\n+                                                 xsltTransformContextPtr ctxt);\n@@ -80,3 +80,3 @@\n-            xsltSecurityAllow       (xsltSecurityPrefsPtr sec,\n-                         xsltTransformContextPtr ctxt,\n-                         const char *value);\n+                    xsltSecurityAllow           (xsltSecurityPrefsPtr sec,\n+                                                 xsltTransformContextPtr ctxt,\n+                                                 const char *value);\n@@ -84,3 +84,3 @@\n-            xsltSecurityForbid      (xsltSecurityPrefsPtr sec,\n-                         xsltTransformContextPtr ctxt,\n-                         const char *value);\n+                    xsltSecurityForbid          (xsltSecurityPrefsPtr sec,\n+                                                 xsltTransformContextPtr ctxt,\n+                                                 const char *value);\n@@ -91,3 +91,3 @@\n-            xsltCheckWrite      (xsltSecurityPrefsPtr sec,\n-                         xsltTransformContextPtr ctxt,\n-                         const xmlChar *URL);\n+                    xsltCheckWrite              (xsltSecurityPrefsPtr sec,\n+                                                 xsltTransformContextPtr ctxt,\n+                                                 const xmlChar *URL);\n@@ -95,3 +95,3 @@\n-            xsltCheckRead       (xsltSecurityPrefsPtr sec,\n-                         xsltTransformContextPtr ctxt,\n-                         const xmlChar *URL);\n+                    xsltCheckRead               (xsltSecurityPrefsPtr sec,\n+                                                 xsltTransformContextPtr ctxt,\n+                                                 const xmlChar *URL);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/security.h","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -39,3 +39,3 @@\n- *                                  *\n- *          Module interfaces               *\n- *                                  *\n+ *                                                                      *\n+ *                      Module interfaces                               *\n+ *                                                                      *\n@@ -58,1 +58,1 @@\n-               xmlNsPtr *nsList, int nsNr) {\n+                       xmlNsPtr *nsList, int nsNr) {\n@@ -85,2 +85,2 @@\n-    ret = xmlXPathEvalPredicate(ctxt->xpathCtxt, res);\n-    xmlXPathFreeObject(res);\n+        ret = xmlXPathEvalPredicate(ctxt->xpathCtxt, res);\n+        xmlXPathFreeObject(res);\n@@ -88,2 +88,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltEvalXPathPredicate: returns %d\\n\", ret));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltEvalXPathPredicate: returns %d\\n\", ret));\n@@ -93,2 +93,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltEvalXPathPredicate: failed\\n\"));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltEvalXPathPredicate: failed\\n\"));\n@@ -96,2 +96,2 @@\n-    ctxt->state = XSLT_STATE_STOPPED;\n-    ret = 0;\n+        ctxt->state = XSLT_STATE_STOPPED;\n+        ret = 0;\n@@ -124,1 +124,1 @@\n-                  int nsNr, xmlNsPtr *nsList) {\n+                      int nsNr, xmlNsPtr *nsList) {\n@@ -152,3 +152,3 @@\n-    if (res->type != XPATH_STRING)\n-        res = xmlXPathConvertString(res);\n-    if (res->type == XPATH_STRING) {\n+        if (res->type != XPATH_STRING)\n+            res = xmlXPathConvertString(res);\n+        if (res->type == XPATH_STRING) {\n@@ -156,6 +156,6 @@\n-        res->stringval = NULL;\n-    } else {\n-        xsltTransformError(ctxt, NULL, NULL,\n-         \"xpath : string() function didn't return a String\\n\");\n-    }\n-    xmlXPathFreeObject(res);\n+            res->stringval = NULL;\n+        } else {\n+            xsltTransformError(ctxt, NULL, NULL,\n+                 \"xpath : string() function didn't return a String\\n\");\n+        }\n+        xmlXPathFreeObject(res);\n@@ -163,1 +163,1 @@\n-    ctxt->state = XSLT_STATE_STOPPED;\n+        ctxt->state = XSLT_STATE_STOPPED;\n@@ -167,1 +167,1 @@\n-     \"xsltEvalXPathString: returns %s\\n\", ret));\n+         \"xsltEvalXPathString: returns %s\\n\", ret));\n@@ -208,2 +208,2 @@\n-               xmlNodePtr contextNode,\n-                   xmlNodePtr inst)\n+                       xmlNodePtr contextNode,\n+                       xmlNodePtr inst)\n@@ -213,0 +213,2 @@\n+    const xmlChar *oldLastText;\n+    int oldLastTextSize, oldLastTextUse;\n@@ -216,1 +218,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -219,1 +221,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -228,1 +230,1 @@\n-                       (const xmlChar *)\"fake\", NULL);\n+                           (const xmlChar *)\"fake\", NULL);\n@@ -230,3 +232,3 @@\n-    xsltTransformError(ctxt, NULL, contextNode,\n-        \"Failed to create temporary node\\n\");\n-    return(NULL);\n+        xsltTransformError(ctxt, NULL, contextNode,\n+                \"Failed to create temporary node\\n\");\n+        return(NULL);\n@@ -236,0 +238,3 @@\n+    oldLastText = ctxt->lasttext;\n+    oldLastTextSize = ctxt->lasttsize;\n+    oldLastTextUse = ctxt->lasttuse;\n@@ -242,0 +247,3 @@\n+    ctxt->lasttext = oldLastText;\n+    ctxt->lasttsize = oldLastTextSize;\n+    ctxt->lasttuse = oldLastTextUse;\n@@ -245,1 +253,1 @@\n-    xmlFreeNode(insert);\n+        xmlFreeNode(insert);\n@@ -271,1 +279,1 @@\n-      const xmlChar *str, xmlNodePtr inst)\n+          const xmlChar *str, xmlNodePtr inst)\n@@ -281,1 +289,1 @@\n-    return(xmlStrndup((xmlChar *)\"\", 0));\n+        return(xmlStrndup((xmlChar *)\"\", 0));\n@@ -285,20 +293,10 @@\n-    if (*cur == '{') {\n-        if (*(cur+1) == '{') {  \/* escaped '{' *\/\n-            cur++;\n-        ret = xmlStrncat(ret, str, cur - str);\n-        cur++;\n-        str = cur;\n-        continue;\n-        }\n-        ret = xmlStrncat(ret, str, cur - str);\n-        str = cur;\n-        cur++;\n-        while ((*cur != 0) && (*cur != '}')) {\n-        \/* Need to check for literal (bug539741) *\/\n-        if ((*cur == '\\'') || (*cur == '\"')) {\n-            char delim = *(cur++);\n-            while ((*cur != 0) && (*cur != delim))\n-            cur++;\n-            if (*cur != 0)\n-            cur++;  \/* skip the ending delimiter *\/\n-        } else\n+        if (*cur == '{') {\n+            if (*(cur+1) == '{') {      \/* escaped '{' *\/\n+                cur++;\n+                ret = xmlStrncat(ret, str, cur - str);\n+                cur++;\n+                str = cur;\n+                continue;\n+            }\n+            ret = xmlStrncat(ret, str, cur - str);\n+            str = cur;\n@@ -306,0 +304,10 @@\n+            while ((*cur != 0) && (*cur != '}')) {\n+                \/* Need to check for literal (bug539741) *\/\n+                if ((*cur == '\\'') || (*cur == '\"')) {\n+                    char delim = *(cur++);\n+                    while ((*cur != 0) && (*cur != delim))\n+                        cur++;\n+                    if (*cur != 0)\n+                        cur++;  \/* skip the ending delimiter *\/\n+                } else\n+                    cur++;\n@@ -307,26 +315,5 @@\n-        if (*cur == 0) {\n-            xsltTransformError(ctxt, NULL, inst,\n-            \"xsltAttrTemplateValueProcessNode: unmatched '{'\\n\");\n-        ret = xmlStrncat(ret, str, cur - str);\n-        goto exit;\n-        }\n-        str++;\n-        expr = xmlStrndup(str, cur - str);\n-        if (expr == NULL)\n-        goto exit;\n-        else if (*expr == '{') {\n-        ret = xmlStrcat(ret, expr);\n-        xmlFree(expr);\n-        } else {\n-        xmlXPathCompExprPtr comp;\n-        \/*\n-         * TODO: keep precompiled form around\n-         *\/\n-        if ((nsList == NULL) && (inst != NULL)) {\n-            int i = 0;\n-\n-            nsList = xmlGetNsList(inst->doc, inst);\n-            if (nsList != NULL) {\n-            while (nsList[i] != NULL)\n-                i++;\n-            nsNr = i;\n+            if (*cur == 0) {\n+                xsltTransformError(ctxt, NULL, inst,\n+                        \"xsltAttrTemplateValueProcessNode: unmatched '{'\\n\");\n+                ret = xmlStrncat(ret, str, cur - str);\n+                goto exit;\n@@ -334,2 +321,23 @@\n-        }\n-        comp = xmlXPathCtxtCompile(ctxt->xpathCtxt, expr);\n+            str++;\n+            expr = xmlStrndup(str, cur - str);\n+            if (expr == NULL)\n+                goto exit;\n+            else if (*expr == '{') {\n+                ret = xmlStrcat(ret, expr);\n+                xmlFree(expr);\n+            } else {\n+                xmlXPathCompExprPtr comp;\n+                \/*\n+                 * TODO: keep precompiled form around\n+                 *\/\n+                if ((nsList == NULL) && (inst != NULL)) {\n+                    int i = 0;\n+\n+                    nsList = xmlGetNsList(inst->doc, inst);\n+                    if (nsList != NULL) {\n+                        while (nsList[i] != NULL)\n+                            i++;\n+                        nsNr = i;\n+                    }\n+                }\n+                comp = xmlXPathCtxtCompile(ctxt->xpathCtxt, expr);\n@@ -337,22 +345,22 @@\n-        xmlXPathFreeCompExpr(comp);\n-        xmlFree(expr);\n-        if (val != NULL) {\n-            ret = xmlStrcat(ret, val);\n-            xmlFree(val);\n-        }\n-        }\n-        cur++;\n-        str = cur;\n-    } else if (*cur == '}') {\n-        cur++;\n-        if (*cur == '}') {  \/* escaped '}' *\/\n-        ret = xmlStrncat(ret, str, cur - str);\n-        cur++;\n-        str = cur;\n-        continue;\n-        } else {\n-            xsltTransformError(ctxt, NULL, inst,\n-             \"xsltAttrTemplateValueProcessNode: unmatched '}'\\n\");\n-        }\n-    } else\n-        cur++;\n+                xmlXPathFreeCompExpr(comp);\n+                xmlFree(expr);\n+                if (val != NULL) {\n+                    ret = xmlStrcat(ret, val);\n+                    xmlFree(val);\n+                }\n+            }\n+            cur++;\n+            str = cur;\n+        } else if (*cur == '}') {\n+            cur++;\n+            if (*cur == '}') {  \/* escaped '}' *\/\n+                ret = xmlStrncat(ret, str, cur - str);\n+                cur++;\n+                str = cur;\n+                continue;\n+            } else {\n+                xsltTransformError(ctxt, NULL, inst,\n+                     \"xsltAttrTemplateValueProcessNode: unmatched '}'\\n\");\n+            }\n+        } else\n+            cur++;\n@@ -361,1 +369,1 @@\n-    ret = xmlStrncat(ret, str, cur - str);\n+        ret = xmlStrncat(ret, str, cur - str);\n@@ -366,1 +374,1 @@\n-    xmlFree(nsList);\n+        xmlFree(nsList);\n@@ -403,1 +411,1 @@\n-                      const xmlChar *name, const xmlChar *ns)\n+                          const xmlChar *name, const xmlChar *ns)\n@@ -410,1 +418,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -414,1 +422,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -425,1 +433,1 @@\n-     \"xsltEvalAttrValueTemplate: %s returns %s\\n\", expr, ret));\n+         \"xsltEvalAttrValueTemplate: %s returns %s\\n\", expr, ret));\n@@ -428,1 +436,1 @@\n-    xmlFree(expr);\n+        xmlFree(expr);\n@@ -449,1 +457,1 @@\n-            const xmlChar *name, const xmlChar *ns, int *found) {\n+                        const xmlChar *name, const xmlChar *ns, int *found) {\n@@ -455,1 +463,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -459,2 +467,2 @@\n-    *found = 0;\n-    return(NULL);\n+        *found = 0;\n+        return(NULL);\n@@ -466,2 +474,2 @@\n-    xmlFree(expr);\n-    return(NULL);\n+        xmlFree(expr);\n+        return(NULL);\n@@ -490,1 +498,1 @@\n-                    xmlAttrPtr attr)\n+                        xmlAttrPtr attr)\n@@ -497,1 +505,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -500,1 +508,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -507,1 +515,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -510,1 +518,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -516,11 +524,11 @@\n-    if ((attr->children->type != XML_TEXT_NODE) ||\n-        (attr->children->next != NULL))\n-    {\n-        xsltTransformError(ctxt, NULL, attr->parent,\n-        \"Internal error: The children of an attribute node of a \"\n-        \"literal result element are not in the expected form.\\n\");\n-        return(NULL);\n-    }\n-    value = attr->children->content;\n-    if (value == NULL)\n-        value = xmlDictLookup(ctxt->dict, BAD_CAST \"\", 0);\n+        if ((attr->children->type != XML_TEXT_NODE) ||\n+            (attr->children->next != NULL))\n+        {\n+            xsltTransformError(ctxt, NULL, attr->parent,\n+                \"Internal error: The children of an attribute node of a \"\n+                \"literal result element are not in the expected form.\\n\");\n+            return(NULL);\n+        }\n+        value = attr->children->content;\n+        if (value == NULL)\n+            value = xmlDictLookup(ctxt->dict, BAD_CAST \"\", 0);\n@@ -528,1 +536,1 @@\n-    value = xmlDictLookup(ctxt->dict, BAD_CAST \"\", 0);\n+        value = xmlDictLookup(ctxt->dict, BAD_CAST \"\", 0);\n@@ -535,5 +543,5 @@\n-        xmlStrEqual(ret->name, attr->name) &&\n-        ((attr->ns == NULL) || xmlStrEqual(ret->ns->href, attr->ns->href)))\n-    {\n-        break;\n-    }\n+            xmlStrEqual(ret->name, attr->name) &&\n+            ((attr->ns == NULL) || xmlStrEqual(ret->ns->href, attr->ns->href)))\n+        {\n+            break;\n+        }\n@@ -544,10 +552,10 @@\n-    xmlFreeNodeList(ret->children);\n-    ret->children = ret->last = NULL;\n-    \/*\n-    * Adjust ns-prefix if needed.\n-    *\/\n-    if ((ret->ns != NULL) &&\n-        (! xmlStrEqual(ret->ns->prefix, attr->ns->prefix)))\n-    {\n-        ret->ns = xsltGetNamespace(ctxt, attr->parent, attr->ns, target);\n-    }\n+        xmlFreeNodeList(ret->children);\n+        ret->children = ret->last = NULL;\n+        \/*\n+        * Adjust ns-prefix if needed.\n+        *\/\n+        if ((ret->ns != NULL) &&\n+            (! xmlStrEqual(ret->ns->prefix, attr->ns->prefix)))\n+        {\n+            ret->ns = xsltGetNamespace(ctxt, attr->parent, attr->ns, target);\n+        }\n@@ -556,6 +564,6 @@\n-    if (attr->ns != NULL)\n-        ret = xmlNewNsProp(target,\n-        xsltGetNamespace(ctxt, attr->parent, attr->ns, target),\n-            attr->name, NULL);\n-    else\n-        ret = xmlNewNsProp(target, NULL, attr->name, NULL);\n+        if (attr->ns != NULL)\n+            ret = xmlNewNsProp(target,\n+                xsltGetNamespace(ctxt, attr->parent, attr->ns, target),\n+                    attr->name, NULL);\n+        else\n+            ret = xmlNewNsProp(target, NULL, attr->name, NULL);\n@@ -570,4 +578,4 @@\n-    if (text != NULL) {\n-        ret->last = ret->children = text;\n-        text->parent = (xmlNodePtr) ret;\n-        text->doc = ret->doc;\n+        if (text != NULL) {\n+            ret->last = ret->children = text;\n+            text->parent = (xmlNodePtr) ret;\n+            text->doc = ret->doc;\n@@ -575,16 +583,31 @@\n-        if (attr->psvi != NULL) {\n-        \/*\n-        * Evaluate the Attribute Value Template.\n-        *\/\n-        xmlChar *val;\n-        val = xsltEvalAVT(ctxt, attr->psvi, attr->parent);\n-        if (val == NULL) {\n-            \/*\n-            * TODO: Damn, we need an easy mechanism to report\n-            * qualified names!\n-            *\/\n-            if (attr->ns) {\n-            xsltTransformError(ctxt, NULL, attr->parent,\n-                \"Internal error: Failed to evaluate the AVT \"\n-                \"of attribute '{%s}%s'.\\n\",\n-                attr->ns->href, attr->name);\n+            if (attr->psvi != NULL) {\n+                \/*\n+                * Evaluate the Attribute Value Template.\n+                *\/\n+                xmlChar *val;\n+                val = xsltEvalAVT(ctxt, attr->psvi, attr->parent);\n+                if (val == NULL) {\n+                    \/*\n+                    * TODO: Damn, we need an easy mechanism to report\n+                    * qualified names!\n+                    *\/\n+                    if (attr->ns) {\n+                        xsltTransformError(ctxt, NULL, attr->parent,\n+                            \"Internal error: Failed to evaluate the AVT \"\n+                            \"of attribute '{%s}%s'.\\n\",\n+                            attr->ns->href, attr->name);\n+                    } else {\n+                        xsltTransformError(ctxt, NULL, attr->parent,\n+                            \"Internal error: Failed to evaluate the AVT \"\n+                            \"of attribute '%s'.\\n\",\n+                            attr->name);\n+                    }\n+                    text->content = xmlStrdup(BAD_CAST \"\");\n+                } else {\n+                    text->content = val;\n+                }\n+            } else if ((ctxt->internalized) && (target != NULL) &&\n+                       (target->doc != NULL) &&\n+                       (target->doc->dict == ctxt->dict) &&\n+                       xmlDictOwns(ctxt->dict, value)) {\n+                text->content = (xmlChar *) value;\n@@ -592,4 +615,1 @@\n-            xsltTransformError(ctxt, NULL, attr->parent,\n-                \"Internal error: Failed to evaluate the AVT \"\n-                \"of attribute '%s'.\\n\",\n-                attr->name);\n+                text->content = xmlStrdup(value);\n@@ -597,3 +617,0 @@\n-            text->content = xmlStrdup(BAD_CAST \"\");\n-        } else {\n-            text->content = val;\n@@ -601,5 +618,5 @@\n-        } else if ((ctxt->internalized) && (target != NULL) &&\n-                   (target->doc != NULL) &&\n-               (target->doc->dict == ctxt->dict) &&\n-               xmlDictOwns(ctxt->dict, value)) {\n-        text->content = (xmlChar *) value;\n+    } else {\n+        if (attr->ns) {\n+            xsltTransformError(ctxt, NULL, attr->parent,\n+                \"Internal error: Failed to create attribute '{%s}%s'.\\n\",\n+                attr->ns->href, attr->name);\n@@ -607,1 +624,3 @@\n-        text->content = xmlStrdup(value);\n+            xsltTransformError(ctxt, NULL, attr->parent,\n+                \"Internal error: Failed to create attribute '%s'.\\n\",\n+                attr->name);\n@@ -610,11 +629,0 @@\n-    } else {\n-    if (attr->ns) {\n-        xsltTransformError(ctxt, NULL, attr->parent,\n-        \"Internal error: Failed to create attribute '{%s}%s'.\\n\",\n-        attr->ns->href, attr->name);\n-    } else {\n-        xsltTransformError(ctxt, NULL, attr->parent,\n-        \"Internal error: Failed to create attribute '%s'.\\n\",\n-        attr->name);\n-    }\n-    }\n@@ -646,1 +654,1 @@\n-                        xmlNodePtr target, xmlAttrPtr attrs)\n+                            xmlNodePtr target, xmlAttrPtr attrs)\n@@ -657,1 +665,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -668,5 +676,5 @@\n-    if ((attr->psvi == xsltXSLTAttrMarker) &&\n-        xmlStrEqual(attr->name, (const xmlChar *)\"use-attribute-sets\"))\n-    {\n-        xsltApplyAttributeSet(ctxt, ctxt->node, (xmlNodePtr) attr, NULL);\n-    }\n+        if ((attr->psvi == xsltXSLTAttrMarker) &&\n+            xmlStrEqual(attr->name, (const xmlChar *)\"use-attribute-sets\"))\n+        {\n+            xsltApplyAttributeSet(ctxt, ctxt->node, (xmlNodePtr) attr, NULL);\n+        }\n@@ -674,6 +682,6 @@\n-    if ((attr->ns != NULL) &&\n-        xmlStrEqual(attr->name, (const xmlChar *)\"use-attribute-sets\") &&\n-        xmlStrEqual(attr->ns->href, XSLT_NAMESPACE))\n-    {\n-        xsltApplyAttributeSet(ctxt, ctxt->node, (xmlNodePtr) attr, NULL);\n-    }\n+        if ((attr->ns != NULL) &&\n+            xmlStrEqual(attr->name, (const xmlChar *)\"use-attribute-sets\") &&\n+            xmlStrEqual(attr->ns->href, XSLT_NAMESPACE))\n+        {\n+            xsltApplyAttributeSet(ctxt, ctxt->node, (xmlNodePtr) attr, NULL);\n+        }\n@@ -681,1 +689,1 @@\n-    attr = attr->next;\n+        attr = attr->next;\n@@ -693,3 +701,3 @@\n-    \/*\n-    * Skip XSLT attributes.\n-    *\/\n+        \/*\n+        * Skip XSLT attributes.\n+        *\/\n@@ -697,3 +705,3 @@\n-    if (attr->psvi == xsltXSLTAttrMarker) {\n-        goto next_attribute;\n-    }\n+        if (attr->psvi == xsltXSLTAttrMarker) {\n+            goto next_attribute;\n+        }\n@@ -701,12 +709,2 @@\n-    if ((attr->ns != NULL) &&\n-        xmlStrEqual(attr->ns->href, XSLT_NAMESPACE))\n-    {\n-        goto next_attribute;\n-    }\n-#endif\n-    \/*\n-    * Get the value.\n-    *\/\n-    if (attr->children != NULL) {\n-        if ((attr->children->type != XML_TEXT_NODE) ||\n-        (attr->children->next != NULL))\n+        if ((attr->ns != NULL) &&\n+            xmlStrEqual(attr->ns->href, XSLT_NAMESPACE))\n@@ -714,4 +712,1 @@\n-        xsltTransformError(ctxt, NULL, attr->parent,\n-            \"Internal error: The children of an attribute node of a \"\n-            \"literal result element are not in the expected form.\\n\");\n-        goto error;\n+            goto next_attribute;\n@@ -719,5 +714,18 @@\n-        value = attr->children->content;\n-        if (value == NULL)\n-        value = xmlDictLookup(ctxt->dict, BAD_CAST \"\", 0);\n-    } else\n-        value = xmlDictLookup(ctxt->dict, BAD_CAST \"\", 0);\n+#endif\n+        \/*\n+        * Get the value.\n+        *\/\n+        if (attr->children != NULL) {\n+            if ((attr->children->type != XML_TEXT_NODE) ||\n+                (attr->children->next != NULL))\n+            {\n+                xsltTransformError(ctxt, NULL, attr->parent,\n+                    \"Internal error: The children of an attribute node of a \"\n+                    \"literal result element are not in the expected form.\\n\");\n+                goto error;\n+            }\n+            value = attr->children->content;\n+            if (value == NULL)\n+                value = xmlDictLookup(ctxt->dict, BAD_CAST \"\", 0);\n+        } else\n+            value = xmlDictLookup(ctxt->dict, BAD_CAST \"\", 0);\n@@ -725,6 +733,6 @@\n-    \/*\n-    * Get the namespace. Avoid lookups of same namespaces.\n-    *\/\n-    if (attr->ns != origNs) {\n-        origNs = attr->ns;\n-        if (attr->ns != NULL) {\n+        \/*\n+        * Get the namespace. Avoid lookups of same namespaces.\n+        *\/\n+        if (attr->ns != origNs) {\n+            origNs = attr->ns;\n+            if (attr->ns != NULL) {\n@@ -732,2 +740,2 @@\n-        copyNs = xsltGetSpecialNamespace(ctxt, attr->parent,\n-            attr->ns->href, attr->ns->prefix, target);\n+                copyNs = xsltGetSpecialNamespace(ctxt, attr->parent,\n+                    attr->ns->href, attr->ns->prefix, target);\n@@ -735,2 +743,2 @@\n-        copyNs = xsltGetNamespace(ctxt, attr->parent,\n-            attr->ns, target);\n+                copyNs = xsltGetNamespace(ctxt, attr->parent,\n+                    attr->ns, target);\n@@ -738,8 +746,8 @@\n-        if (copyNs == NULL)\n-            goto error;\n-        } else\n-        copyNs = NULL;\n-    }\n-    \/*\n-    * Create a new attribute.\n-    *\/\n+                if (copyNs == NULL)\n+                    goto error;\n+            } else\n+                copyNs = NULL;\n+        }\n+        \/*\n+        * Create a new attribute.\n+        *\/\n@@ -747,1 +755,1 @@\n-        copy = xmlSetNsProp(target, copyNs, attr->name, NULL);\n+            copy = xmlSetNsProp(target, copyNs, attr->name, NULL);\n@@ -753,1 +761,1 @@\n-        copy = xmlNewDocProp(target->doc, attr->name, NULL);\n+            copy = xmlNewDocProp(target->doc, attr->name, NULL);\n@@ -755,1 +763,1 @@\n-        if (copy != NULL) {\n+            if (copy != NULL) {\n@@ -772,9 +780,11 @@\n-    if (copy == NULL) {\n-        if (attr->ns) {\n-        xsltTransformError(ctxt, NULL, attr->parent,\n-            \"Internal error: Failed to create attribute '{%s}%s'.\\n\",\n-            attr->ns->href, attr->name);\n-        } else {\n-        xsltTransformError(ctxt, NULL, attr->parent,\n-            \"Internal error: Failed to create attribute '%s'.\\n\",\n-            attr->name);\n+        if (copy == NULL) {\n+            if (attr->ns) {\n+                xsltTransformError(ctxt, NULL, attr->parent,\n+                    \"Internal error: Failed to create attribute '{%s}%s'.\\n\",\n+                    attr->ns->href, attr->name);\n+            } else {\n+                xsltTransformError(ctxt, NULL, attr->parent,\n+                    \"Internal error: Failed to create attribute '%s'.\\n\",\n+                    attr->name);\n+            }\n+            goto error;\n@@ -782,11 +792,0 @@\n-        goto error;\n-    }\n-\n-    \/*\n-    * Set the value.\n-    *\/\n-    text = xmlNewText(NULL);\n-    if (text != NULL) {\n-        copy->last = copy->children = text;\n-        text->parent = (xmlNodePtr) copy;\n-        text->doc = copy->doc;\n@@ -794,1 +793,0 @@\n-        if (attr->psvi != NULL) {\n@@ -796,1 +794,1 @@\n-        * Evaluate the Attribute Value Template.\n+        * Set the value.\n@@ -798,11 +796,38 @@\n-        valueAVT = xsltEvalAVT(ctxt, attr->psvi, attr->parent);\n-        if (valueAVT == NULL) {\n-            \/*\n-            * TODO: Damn, we need an easy mechanism to report\n-            * qualified names!\n-            *\/\n-            if (attr->ns) {\n-            xsltTransformError(ctxt, NULL, attr->parent,\n-                \"Internal error: Failed to evaluate the AVT \"\n-                \"of attribute '{%s}%s'.\\n\",\n-                attr->ns->href, attr->name);\n+        text = xmlNewText(NULL);\n+        if (text != NULL) {\n+            copy->last = copy->children = text;\n+            text->parent = (xmlNodePtr) copy;\n+            text->doc = copy->doc;\n+\n+            if (attr->psvi != NULL) {\n+                \/*\n+                * Evaluate the Attribute Value Template.\n+                *\/\n+                valueAVT = xsltEvalAVT(ctxt, attr->psvi, attr->parent);\n+                if (valueAVT == NULL) {\n+                    \/*\n+                    * TODO: Damn, we need an easy mechanism to report\n+                    * qualified names!\n+                    *\/\n+                    if (attr->ns) {\n+                        xsltTransformError(ctxt, NULL, attr->parent,\n+                            \"Internal error: Failed to evaluate the AVT \"\n+                            \"of attribute '{%s}%s'.\\n\",\n+                            attr->ns->href, attr->name);\n+                    } else {\n+                        xsltTransformError(ctxt, NULL, attr->parent,\n+                            \"Internal error: Failed to evaluate the AVT \"\n+                            \"of attribute '%s'.\\n\",\n+                            attr->name);\n+                    }\n+                    text->content = xmlStrdup(BAD_CAST \"\");\n+                    goto error;\n+                } else {\n+                    text->content = valueAVT;\n+                }\n+            } else if ((ctxt->internalized) &&\n+                (target->doc != NULL) &&\n+                (target->doc->dict == ctxt->dict) &&\n+                xmlDictOwns(ctxt->dict, value))\n+            {\n+                text->content = (xmlChar *) value;\n@@ -810,4 +835,1 @@\n-            xsltTransformError(ctxt, NULL, attr->parent,\n-                \"Internal error: Failed to evaluate the AVT \"\n-                \"of attribute '%s'.\\n\",\n-                attr->name);\n+                text->content = xmlStrdup(value);\n@@ -815,14 +837,0 @@\n-            text->content = xmlStrdup(BAD_CAST \"\");\n-            goto error;\n-        } else {\n-            text->content = valueAVT;\n-        }\n-        } else if ((ctxt->internalized) &&\n-        (target->doc != NULL) &&\n-        (target->doc->dict == ctxt->dict) &&\n-        xmlDictOwns(ctxt->dict, value))\n-        {\n-        text->content = (xmlChar *) value;\n-        } else {\n-        text->content = xmlStrdup(value);\n-        }\n@@ -832,1 +840,1 @@\n-    }\n+        }\n@@ -835,1 +843,1 @@\n-    attr = attr->next;\n+        attr = attr->next;\n@@ -859,1 +867,1 @@\n-    return(NULL);\n+        return(NULL);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/templates.c","additions":324,"deletions":316,"binary":false,"changes":640,"status":"modified"},{"patch":"@@ -24,4 +24,4 @@\n-        xsltEvalXPathPredicate      (xsltTransformContextPtr ctxt,\n-                         xmlXPathCompExprPtr comp,\n-                                         xmlNsPtr *nsList,\n-                         int nsNr);\n+                xsltEvalXPathPredicate          (xsltTransformContextPtr ctxt,\n+                                                 xmlXPathCompExprPtr comp,\n+                                                 xmlNsPtr *nsList,\n+                                                 int nsNr);\n@@ -29,3 +29,3 @@\n-        xsltEvalTemplateString      (xsltTransformContextPtr ctxt,\n-                         xmlNodePtr contextNode,\n-                         xmlNodePtr inst);\n+                xsltEvalTemplateString          (xsltTransformContextPtr ctxt,\n+                                                 xmlNodePtr contextNode,\n+                                                 xmlNodePtr inst);\n@@ -33,4 +33,4 @@\n-        xsltEvalAttrValueTemplate   (xsltTransformContextPtr ctxt,\n-                         xmlNodePtr node,\n-                         const xmlChar *name,\n-                         const xmlChar *ns);\n+                xsltEvalAttrValueTemplate       (xsltTransformContextPtr ctxt,\n+                                                 xmlNodePtr node,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns);\n@@ -38,5 +38,5 @@\n-        xsltEvalStaticAttrValueTemplate (xsltStylesheetPtr style,\n-                         xmlNodePtr node,\n-                         const xmlChar *name,\n-                         const xmlChar *ns,\n-                         int *found);\n+                xsltEvalStaticAttrValueTemplate (xsltStylesheetPtr style,\n+                                                 xmlNodePtr node,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns,\n+                                                 int *found);\n@@ -46,2 +46,2 @@\n-        xsltEvalXPathString     (xsltTransformContextPtr ctxt,\n-                         xmlXPathCompExprPtr comp);\n+                xsltEvalXPathString             (xsltTransformContextPtr ctxt,\n+                                                 xmlXPathCompExprPtr comp);\n@@ -49,4 +49,4 @@\n-        xsltEvalXPathStringNs       (xsltTransformContextPtr ctxt,\n-                         xmlXPathCompExprPtr comp,\n-                         int nsNr,\n-                         xmlNsPtr *nsList);\n+                xsltEvalXPathStringNs           (xsltTransformContextPtr ctxt,\n+                                                 xmlXPathCompExprPtr comp,\n+                                                 int nsNr,\n+                                                 xmlNsPtr *nsList);\n@@ -55,2 +55,2 @@\n-        xsltTemplateProcess     (xsltTransformContextPtr ctxt,\n-                         xmlNodePtr node);\n+                xsltTemplateProcess             (xsltTransformContextPtr ctxt,\n+                                                 xmlNodePtr node);\n@@ -58,3 +58,3 @@\n-        xsltAttrListTemplateProcess (xsltTransformContextPtr ctxt,\n-                         xmlNodePtr target,\n-                         xmlAttrPtr cur);\n+                xsltAttrListTemplateProcess     (xsltTransformContextPtr ctxt,\n+                                                 xmlNodePtr target,\n+                                                 xmlAttrPtr cur);\n@@ -62,3 +62,3 @@\n-        xsltAttrTemplateProcess     (xsltTransformContextPtr ctxt,\n-                         xmlNodePtr target,\n-                         xmlAttrPtr attr);\n+                xsltAttrTemplateProcess         (xsltTransformContextPtr ctxt,\n+                                                 xmlNodePtr target,\n+                                                 xmlAttrPtr attr);\n@@ -66,2 +66,2 @@\n-        xsltAttrTemplateValueProcess    (xsltTransformContextPtr ctxt,\n-                         const xmlChar* attr);\n+                xsltAttrTemplateValueProcess    (xsltTransformContextPtr ctxt,\n+                                                 const xmlChar* attr);\n@@ -69,3 +69,3 @@\n-        xsltAttrTemplateValueProcessNode(xsltTransformContextPtr ctxt,\n-                         const xmlChar* str,\n-                         xmlNodePtr node);\n+                xsltAttrTemplateValueProcessNode(xsltTransformContextPtr ctxt,\n+                                                 const xmlChar* str,\n+                                                 xmlNodePtr node);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/templates.h","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-              const xmlChar **systemID);\n+                          const xmlChar **systemID);\n@@ -82,1 +82,1 @@\n-#define IS_BLANK_NODE(n)                        \\\n+#define IS_BLANK_NODE(n)                                                \\\n@@ -95,2 +95,2 @@\n-         xmlNodePtr node, xmlNodePtr insert, int isLRE,\n-         int topElemVisited);\n+             xmlNodePtr node, xmlNodePtr insert, int isLRE,\n+             int topElemVisited);\n@@ -100,2 +100,2 @@\n-                 xmlNodePtr contextNode, xmlNodePtr list,\n-                 xsltTemplatePtr templ);\n+                             xmlNodePtr contextNode, xmlNodePtr list,\n+                             xsltTemplatePtr templ);\n@@ -105,4 +105,4 @@\n-              xmlNodePtr contextNode,\n-              xmlNodePtr list,\n-              xsltTemplatePtr templ,\n-              xsltStackElemPtr withParams);\n+                      xmlNodePtr contextNode,\n+                      xmlNodePtr list,\n+                      xsltTemplatePtr templ,\n+                      xsltStackElemPtr withParams);\n@@ -193,8 +193,8 @@\n-    if (ctxt->varsNr <= limitNr)\n-        break;\n-    variable = ctxt->varsTab[ctxt->varsNr - 1];\n-    if (variable->level <= level)\n-        break;\n-    if (variable->level >= 0)\n-        xsltFreeStackElemList(variable);\n-    ctxt->varsNr--;\n+        if (ctxt->varsNr <= limitNr)\n+            break;\n+        variable = ctxt->varsTab[ctxt->varsNr - 1];\n+        if (variable->level <= level)\n+            break;\n+        if (variable->level >= 0)\n+            xsltFreeStackElemList(variable);\n+        ctxt->varsNr--;\n@@ -220,8 +220,8 @@\n-    param = ctxt->varsTab[ctxt->varsNr -1];\n-    \/*\n-    * Free xsl:param items.\n-    * xsl:with-param items will have a level of -1 or -2.\n-    *\/\n-    if (param->level >= 0) {\n-        xsltFreeStackElemList(param);\n-    }\n+        param = ctxt->varsTab[ctxt->varsNr -1];\n+        \/*\n+        * Free xsl:param items.\n+        * xsl:with-param items will have a level of -1 or -2.\n+        *\/\n+        if (param->level >= 0) {\n+            xsltFreeStackElemList(param);\n+        }\n@@ -446,3 +446,3 @@\n- *                                  *\n- *          XInclude default settings           *\n- *                                  *\n+ *                                                                      *\n+ *                      XInclude default settings                       *\n+ *                                                                      *\n@@ -485,1 +485,1 @@\n-    xsltDefaultTrace = val;\n+        xsltDefaultTrace = val;\n@@ -496,1 +496,1 @@\n-    return xsltDefaultTrace;\n+        return xsltDefaultTrace;\n@@ -500,3 +500,3 @@\n- *                                  *\n- *          Handling of Transformation Contexts     *\n- *                                  *\n+ *                                                                      *\n+ *                      Handling of Transformation Contexts             *\n+ *                                                                      *\n@@ -512,3 +512,3 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltTransformCacheCreate : malloc failed\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, NULL,\n+            \"xsltTransformCacheCreate : malloc failed\\n\");\n+        return(NULL);\n@@ -524,1 +524,1 @@\n-    return;\n+        return;\n@@ -529,10 +529,12 @@\n-    xmlDocPtr tmp, cur = cache->RVT;\n-    while (cur) {\n-        tmp = cur;\n-        cur = (xmlDocPtr) cur->next;\n-        if (tmp->_private != NULL) {\n-        \/*\n-        * Tree the document info.\n-        *\/\n-        xsltFreeDocumentKeys((xsltDocumentPtr) tmp->_private);\n-        xmlFree(tmp->_private);\n+        xmlDocPtr tmp, cur = cache->RVT;\n+        while (cur) {\n+            tmp = cur;\n+            cur = (xmlDocPtr) cur->next;\n+            if (tmp->_private != NULL) {\n+                \/*\n+                * Tree the document info.\n+                *\/\n+                xsltFreeDocumentKeys((xsltDocumentPtr) tmp->_private);\n+                xmlFree(tmp->_private);\n+            }\n+            xmlFreeDoc(tmp);\n@@ -540,2 +542,0 @@\n-        xmlFreeDoc(tmp);\n-    }\n@@ -547,10 +547,10 @@\n-    xsltStackElemPtr tmp, cur = cache->stackItems;\n-    while (cur) {\n-        tmp = cur;\n-        cur = cur->next;\n-        \/*\n-        * REVISIT TODO: Should be call a destruction-function\n-        * instead?\n-        *\/\n-        xmlFree(tmp);\n-    }\n+        xsltStackElemPtr tmp, cur = cache->stackItems;\n+        while (cur) {\n+            tmp = cur;\n+            cur = cur->next;\n+            \/*\n+            * REVISIT TODO: Should be call a destruction-function\n+            * instead?\n+            *\/\n+            xmlFree(tmp);\n+        }\n@@ -580,3 +580,3 @@\n-    xsltTransformError(NULL, NULL, (xmlNodePtr)doc,\n-        \"xsltNewTransformContext : malloc failed\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, (xmlNodePtr)doc,\n+                \"xsltNewTransformContext : malloc failed\\n\");\n+        return(NULL);\n@@ -588,1 +588,1 @@\n-    goto internal_err;\n+        goto internal_err;\n@@ -597,1 +597,1 @@\n-         \"Creating sub-dictionary from stylesheet for transformation\\n\");\n+             \"Creating sub-dictionary from stylesheet for transformation\\n\");\n@@ -604,1 +604,1 @@\n-            xmlMalloc(10 * sizeof(xsltTemplatePtr));\n+                xmlMalloc(10 * sizeof(xsltTemplatePtr));\n@@ -606,3 +606,3 @@\n-    xsltTransformError(NULL, NULL, (xmlNodePtr) doc,\n-        \"xsltNewTransformContext: out of memory\\n\");\n-    goto internal_err;\n+        xsltTransformError(NULL, NULL, (xmlNodePtr) doc,\n+                \"xsltNewTransformContext: out of memory\\n\");\n+        goto internal_err;\n@@ -619,1 +619,1 @@\n-            xmlMalloc(10 * sizeof(xsltStackElemPtr));\n+                xmlMalloc(10 * sizeof(xsltStackElemPtr));\n@@ -622,2 +622,2 @@\n-        \"xsltNewTransformContext: out of memory\\n\");\n-    goto internal_err;\n+                \"xsltNewTransformContext: out of memory\\n\");\n+        goto internal_err;\n@@ -643,3 +643,3 @@\n-    xsltTransformError(NULL, NULL, (xmlNodePtr) doc,\n-        \"xsltNewTransformContext : xmlXPathNewContext failed\\n\");\n-    goto internal_err;\n+        xsltTransformError(NULL, NULL, (xmlNodePtr) doc,\n+                \"xsltNewTransformContext : xmlXPathNewContext failed\\n\");\n+        goto internal_err;\n@@ -651,1 +651,1 @@\n-    goto internal_err;\n+        goto internal_err;\n@@ -656,14 +656,14 @@\n-    cur->extrasMax = style->extrasNr + 20;\n-    cur->extras = (xsltRuntimeExtraPtr)\n-        xmlMalloc(cur->extrasMax * sizeof(xsltRuntimeExtra));\n-    if (cur->extras == NULL) {\n-        xmlGenericError(xmlGenericErrorContext,\n-            \"xsltNewTransformContext: out of memory\\n\");\n-        goto internal_err;\n-    }\n-    cur->extrasNr = style->extrasNr;\n-    for (i = 0;i < cur->extrasMax;i++) {\n-        cur->extras[i].info = NULL;\n-        cur->extras[i].deallocate = NULL;\n-        cur->extras[i].val.ptr = NULL;\n-    }\n+        cur->extrasMax = style->extrasNr + 20;\n+        cur->extras = (xsltRuntimeExtraPtr)\n+            xmlMalloc(cur->extrasMax * sizeof(xsltRuntimeExtra));\n+        if (cur->extras == NULL) {\n+            xmlGenericError(xmlGenericErrorContext,\n+                    \"xsltNewTransformContext: out of memory\\n\");\n+            goto internal_err;\n+        }\n+        cur->extrasNr = style->extrasNr;\n+        for (i = 0;i < cur->extrasMax;i++) {\n+            cur->extras[i].info = NULL;\n+            cur->extras[i].deallocate = NULL;\n+            cur->extras[i].val.ptr = NULL;\n+        }\n@@ -671,3 +671,3 @@\n-    cur->extras = NULL;\n-    cur->extrasNr = 0;\n-    cur->extrasMax = 0;\n+        cur->extras = NULL;\n+        cur->extrasNr = 0;\n+        cur->extrasMax = 0;\n@@ -696,3 +696,3 @@\n-    xsltTransformError(cur, NULL, (xmlNodePtr)doc,\n-        \"xsltNewTransformContext : xsltNewDocument failed\\n\");\n-    goto internal_err;\n+        xsltTransformError(cur, NULL, (xmlNodePtr)doc,\n+                \"xsltNewTransformContext : xsltNewDocument failed\\n\");\n+        goto internal_err;\n@@ -714,1 +714,1 @@\n-    xsltFreeTransformContext(cur);\n+        xsltFreeTransformContext(cur);\n@@ -727,1 +727,1 @@\n-    return;\n+        return;\n@@ -736,2 +736,2 @@\n-    ctxt->xpathCtxt->nsHash = NULL;\n-    xmlXPathFreeContext(ctxt->xpathCtxt);\n+        ctxt->xpathCtxt->nsHash = NULL;\n+        xmlXPathFreeContext(ctxt->xpathCtxt);\n@@ -740,1 +740,1 @@\n-    xmlFree(ctxt->templTab);\n+        xmlFree(ctxt->templTab);\n@@ -742,1 +742,1 @@\n-    xmlFree(ctxt->varsTab);\n+        xmlFree(ctxt->varsTab);\n@@ -744,1 +744,1 @@\n-    xmlFree(ctxt->profTab);\n+        xmlFree(ctxt->profTab);\n@@ -746,1 +746,1 @@\n-    int i;\n+        int i;\n@@ -748,6 +748,6 @@\n-    for (i = 0;i < ctxt->extrasNr;i++) {\n-        if ((ctxt->extras[i].deallocate != NULL) &&\n-        (ctxt->extras[i].info != NULL))\n-        ctxt->extras[i].deallocate(ctxt->extras[i].info);\n-    }\n-    xmlFree(ctxt->extras);\n+        for (i = 0;i < ctxt->extrasNr;i++) {\n+            if ((ctxt->extras[i].deallocate != NULL) &&\n+                (ctxt->extras[i].info != NULL))\n+                ctxt->extras[i].deallocate(ctxt->extras[i].info);\n+        }\n+        xmlFree(ctxt->extras);\n@@ -770,3 +770,3 @@\n- *                                  *\n- *          Copy of Nodes in an XSLT fashion        *\n- *                                  *\n+ *                                                                      *\n+ *                      Copy of Nodes in an XSLT fashion                *\n+ *                                                                      *\n@@ -814,1 +814,1 @@\n-          const xmlChar *string, int len) {\n+                  const xmlChar *string, int len) {\n@@ -833,2 +833,2 @@\n-        xmlChar *newbuf;\n-        int size;\n+            xmlChar *newbuf;\n+            int size;\n@@ -848,5 +848,9 @@\n-        newbuf = (xmlChar *) xmlRealloc(target->content,size);\n-        if (newbuf == NULL) {\n-        xsltTransformError(ctxt, NULL, target,\n-         \"xsltCopyText: text allocation failed\\n\");\n-        return(NULL);\n+            newbuf = (xmlChar *) xmlRealloc(target->content,size);\n+            if (newbuf == NULL) {\n+                xsltTransformError(ctxt, NULL, target,\n+                 \"xsltCopyText: text allocation failed\\n\");\n+                return(NULL);\n+            }\n+            ctxt->lasttsize = size;\n+            ctxt->lasttext = newbuf;\n+            target->content = newbuf;\n@@ -854,7 +858,3 @@\n-        ctxt->lasttsize = size;\n-        ctxt->lasttext = newbuf;\n-        target->content = newbuf;\n-    }\n-    memcpy(&(target->content[ctxt->lasttuse]), string, len);\n-    ctxt->lasttuse += len;\n-    target->content[ctxt->lasttuse] = 0;\n+        memcpy(&(target->content[ctxt->lasttuse]), string, len);\n+        ctxt->lasttuse += len;\n+        target->content[ctxt->lasttuse] = 0;\n@@ -862,5 +862,5 @@\n-    xmlNodeAddContent(target, string);\n-    ctxt->lasttext = target->content;\n-    len = xmlStrlen(target->content);\n-    ctxt->lasttsize = len;\n-    ctxt->lasttuse = len;\n+        xmlNodeAddContent(target, string);\n+        ctxt->lasttext = target->content;\n+        len = xmlStrlen(target->content);\n+        ctxt->lasttsize = len;\n+        ctxt->lasttuse = len;\n@@ -886,1 +886,1 @@\n-               const xmlChar *string, int noescape)\n+                   const xmlChar *string, int noescape)\n@@ -892,1 +892,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -896,2 +896,2 @@\n-             \"xsltCopyTextString: copy text %s\\n\",\n-             string));\n+                     \"xsltCopyTextString: copy text %s\\n\",\n+                     string));\n@@ -905,1 +905,1 @@\n-    ctxt->lasttext = NULL;\n+        ctxt->lasttext = NULL;\n@@ -911,9 +911,9 @@\n-    (ctxt->style->cdataSection != NULL) &&\n-    (target != NULL) &&\n-    (target->type == XML_ELEMENT_NODE) &&\n-    (((target->ns == NULL) &&\n-      (xmlHashLookup2(ctxt->style->cdataSection,\n-                  target->name, NULL) != NULL)) ||\n-     ((target->ns != NULL) &&\n-      (xmlHashLookup2(ctxt->style->cdataSection,\n-                      target->name, target->ns->href) != NULL))))\n+        (ctxt->style->cdataSection != NULL) &&\n+        (target != NULL) &&\n+        (target->type == XML_ELEMENT_NODE) &&\n+        (((target->ns == NULL) &&\n+          (xmlHashLookup2(ctxt->style->cdataSection,\n+                          target->name, NULL) != NULL)) ||\n+         ((target->ns != NULL) &&\n+          (xmlHashLookup2(ctxt->style->cdataSection,\n+                          target->name, target->ns->href) != NULL))))\n@@ -921,9 +921,9 @@\n-    \/*\n-    * Process \"cdata-section-elements\".\n-    *\/\n-    if ((target->last != NULL) &&\n-        (target->last->type == XML_CDATA_SECTION_NODE))\n-    {\n-        return(xsltAddTextString(ctxt, target->last, string, len));\n-    }\n-    copy = xmlNewCDataBlock(ctxt->output, string, len);\n+        \/*\n+        * Process \"cdata-section-elements\".\n+        *\/\n+        if ((target->last != NULL) &&\n+            (target->last->type == XML_CDATA_SECTION_NODE))\n+        {\n+            return(xsltAddTextString(ctxt, target->last, string, len));\n+        }\n+        copy = xmlNewCDataBlock(ctxt->output, string, len);\n@@ -931,12 +931,12 @@\n-    \/*\n-    * Process \"disable-output-escaping\".\n-    *\/\n-    if ((target != NULL) && (target->last != NULL) &&\n-        (target->last->type == XML_TEXT_NODE) &&\n-        (target->last->name == xmlStringTextNoenc))\n-    {\n-        return(xsltAddTextString(ctxt, target->last, string, len));\n-    }\n-    copy = xmlNewTextLen(string, len);\n-    if (copy != NULL)\n-        copy->name = xmlStringTextNoenc;\n+        \/*\n+        * Process \"disable-output-escaping\".\n+        *\/\n+        if ((target != NULL) && (target->last != NULL) &&\n+            (target->last->type == XML_TEXT_NODE) &&\n+            (target->last->name == xmlStringTextNoenc))\n+        {\n+            return(xsltAddTextString(ctxt, target->last, string, len));\n+        }\n+        copy = xmlNewTextLen(string, len);\n+        if (copy != NULL)\n+            copy->name = xmlStringTextNoenc;\n@@ -944,9 +944,9 @@\n-    \/*\n-    * Default processing.\n-    *\/\n-    if ((target != NULL) && (target->last != NULL) &&\n-        (target->last->type == XML_TEXT_NODE) &&\n-        (target->last->name == xmlStringText)) {\n-        return(xsltAddTextString(ctxt, target->last, string, len));\n-    }\n-    copy = xmlNewTextLen(string, len);\n+        \/*\n+        * Default processing.\n+        *\/\n+        if ((target != NULL) && (target->last != NULL) &&\n+            (target->last->type == XML_TEXT_NODE) &&\n+            (target->last->name == xmlStringText)) {\n+            return(xsltAddTextString(ctxt, target->last, string, len));\n+        }\n+        copy = xmlNewTextLen(string, len);\n@@ -955,1 +955,1 @@\n-    copy = xsltAddChild(target, copy);\n+        copy = xsltAddChild(target, copy);\n@@ -957,3 +957,3 @@\n-    ctxt->lasttext = copy->content;\n-    ctxt->lasttsize = len;\n-    ctxt->lasttuse = len;\n+        ctxt->lasttext = copy->content;\n+        ctxt->lasttsize = len;\n+        ctxt->lasttuse = len;\n@@ -961,3 +961,3 @@\n-    xsltTransformError(ctxt, NULL, target,\n-             \"xsltCopyTextString: text copy failed\\n\");\n-    ctxt->lasttext = NULL;\n+        xsltTransformError(ctxt, NULL, target,\n+                         \"xsltCopyTextString: text copy failed\\n\");\n+        ctxt->lasttext = NULL;\n@@ -982,1 +982,1 @@\n-         xmlNodePtr cur, int interned)\n+             xmlNodePtr cur, int interned)\n@@ -987,2 +987,2 @@\n-    (cur->type != XML_CDATA_SECTION_NODE))\n-    return(NULL);\n+        (cur->type != XML_CDATA_SECTION_NODE))\n+        return(NULL);\n@@ -990,1 +990,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -994,3 +994,3 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltCopyText: copy CDATA text %s\\n\",\n-             cur->content));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,\n+                         \"xsltCopyText: copy CDATA text %s\\n\",\n+                         cur->content));\n@@ -998,3 +998,3 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltCopyText: copy unescaped text %s\\n\",\n-             cur->content));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,\n+                     \"xsltCopyText: copy unescaped text %s\\n\",\n+                         cur->content));\n@@ -1002,3 +1002,3 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltCopyText: copy text %s\\n\",\n-             cur->content));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_COPY_TEXT,xsltGenericDebug(xsltGenericDebugContext,\n+                         \"xsltCopyText: copy text %s\\n\",\n+                         cur->content));\n@@ -1013,1 +1013,1 @@\n-    ctxt->lasttext = NULL;\n+        ctxt->lasttext = NULL;\n@@ -1017,23 +1017,9 @@\n-    (ctxt->type == XSLT_OUTPUT_XML) &&\n-    (target != NULL) &&\n-    (target->type == XML_ELEMENT_NODE) &&\n-    (((target->ns == NULL) &&\n-      (xmlHashLookup2(ctxt->style->cdataSection,\n-                  target->name, NULL) != NULL)) ||\n-     ((target->ns != NULL) &&\n-      (xmlHashLookup2(ctxt->style->cdataSection,\n-                      target->name, target->ns->href) != NULL))))\n-    {\n-    \/*\n-    * Process \"cdata-section-elements\".\n-    *\/\n-    \/*\n-    * OPTIMIZE TODO: xsltCopyText() is also used for attribute content.\n-    *\/\n-    \/*\n-    * TODO: Since this doesn't merge adjacent CDATA-section nodes,\n-    * we'll get: <![CDATA[x]]><!CDATA[y]]>.\n-    * TODO: Reported in #321505.\n-    *\/\n-    if ((target->last != NULL) &&\n-         (target->last->type == XML_CDATA_SECTION_NODE))\n+        (ctxt->type == XSLT_OUTPUT_XML) &&\n+        (target != NULL) &&\n+        (target->type == XML_ELEMENT_NODE) &&\n+        (((target->ns == NULL) &&\n+          (xmlHashLookup2(ctxt->style->cdataSection,\n+                          target->name, NULL) != NULL)) ||\n+         ((target->ns != NULL) &&\n+          (xmlHashLookup2(ctxt->style->cdataSection,\n+                          target->name, target->ns->href) != NULL))))\n@@ -1042,1 +1028,1 @@\n-        * Append to existing CDATA-section node.\n+        * Process \"cdata-section-elements\".\n@@ -1044,14 +1030,28 @@\n-        copy = xsltAddTextString(ctxt, target->last, cur->content,\n-        xmlStrlen(cur->content));\n-        goto exit;\n-    } else {\n-        unsigned int len;\n-\n-        len = xmlStrlen(cur->content);\n-        copy = xmlNewCDataBlock(ctxt->output, cur->content, len);\n-        if (copy == NULL)\n-        goto exit;\n-        ctxt->lasttext = copy->content;\n-        ctxt->lasttsize = len;\n-        ctxt->lasttuse = len;\n-    }\n+        \/*\n+        * OPTIMIZE TODO: xsltCopyText() is also used for attribute content.\n+        *\/\n+        \/*\n+        * TODO: Since this doesn't merge adjacent CDATA-section nodes,\n+        * we'll get: <![CDATA[x]]><!CDATA[y]]>.\n+        * TODO: Reported in #321505.\n+        *\/\n+        if ((target->last != NULL) &&\n+             (target->last->type == XML_CDATA_SECTION_NODE))\n+        {\n+            \/*\n+            * Append to existing CDATA-section node.\n+            *\/\n+            copy = xsltAddTextString(ctxt, target->last, cur->content,\n+                xmlStrlen(cur->content));\n+            goto exit;\n+        } else {\n+            unsigned int len;\n+\n+            len = xmlStrlen(cur->content);\n+            copy = xmlNewCDataBlock(ctxt->output, cur->content, len);\n+            if (copy == NULL)\n+                goto exit;\n+            ctxt->lasttext = copy->content;\n+            ctxt->lasttsize = len;\n+            ctxt->lasttuse = len;\n+        }\n@@ -1059,4 +1059,4 @@\n-    (target->last != NULL) &&\n-    \/* both escaped or both non-escaped text-nodes *\/\n-    (((target->last->type == XML_TEXT_NODE) &&\n-    (target->last->name == cur->name)) ||\n+        (target->last != NULL) &&\n+        \/* both escaped or both non-escaped text-nodes *\/\n+        (((target->last->type == XML_TEXT_NODE) &&\n+        (target->last->name == cur->name)) ||\n@@ -1064,2 +1064,2 @@\n-    (((target->last->type == XML_CDATA_SECTION_NODE) &&\n-    (cur->name == xmlStringTextNoenc)))))\n+        (((target->last->type == XML_CDATA_SECTION_NODE) &&\n+        (cur->name == xmlStringTextNoenc)))))\n@@ -1067,6 +1067,6 @@\n-    \/*\n-     * we are appending to an existing text node\n-     *\/\n-    copy = xsltAddTextString(ctxt, target->last, cur->content,\n-        xmlStrlen(cur->content));\n-    goto exit;\n+        \/*\n+         * we are appending to an existing text node\n+         *\/\n+        copy = xsltAddTextString(ctxt, target->last, cur->content,\n+            xmlStrlen(cur->content));\n+        goto exit;\n@@ -1074,2 +1074,2 @@\n-    (target->doc != NULL) &&\n-    (target->doc->dict == ctxt->dict))\n+        (target->doc != NULL) &&\n+        (target->doc->dict == ctxt->dict))\n@@ -1077,3 +1077,3 @@\n-    \/*\n-    * TODO: DO we want to use this also for \"text\" output?\n-    *\/\n+        \/*\n+        * TODO: DO we want to use this also for \"text\" output?\n+        *\/\n@@ -1081,4 +1081,4 @@\n-    if (copy == NULL)\n-        goto exit;\n-    if (cur->name == xmlStringTextNoenc)\n-        copy->name = xmlStringTextNoenc;\n+        if (copy == NULL)\n+            goto exit;\n+        if (cur->name == xmlStringTextNoenc)\n+            copy->name = xmlStringTextNoenc;\n@@ -1086,11 +1086,11 @@\n-    \/*\n-     * Must confirm that content is in dict (bug 302821)\n-     * TODO: This check should be not needed for text coming\n-     * from the stylesheets\n-     *\/\n-    if (xmlDictOwns(ctxt->dict, cur->content))\n-        copy->content = cur->content;\n-    else {\n-        if ((copy->content = xmlStrdup(cur->content)) == NULL)\n-        return NULL;\n-    }\n+        \/*\n+         * Must confirm that content is in dict (bug 302821)\n+         * TODO: This check should be not needed for text coming\n+         * from the stylesheets\n+         *\/\n+        if (xmlDictOwns(ctxt->dict, cur->content))\n+            copy->content = cur->content;\n+        else {\n+            if ((copy->content = xmlStrdup(cur->content)) == NULL)\n+                return NULL;\n+        }\n@@ -1098,1 +1098,1 @@\n-    ctxt->lasttext = NULL;\n+        ctxt->lasttext = NULL;\n@@ -1101,3 +1101,3 @@\n-     * normal processing. keep counters to extend the text node\n-     * in xsltAddTextString if needed.\n-     *\/\n+         * normal processing. keep counters to extend the text node\n+         * in xsltAddTextString if needed.\n+         *\/\n@@ -1106,9 +1106,9 @@\n-    len = xmlStrlen(cur->content);\n-    copy = xmlNewTextLen(cur->content, len);\n-    if (copy == NULL)\n-        goto exit;\n-    if (cur->name == xmlStringTextNoenc)\n-        copy->name = xmlStringTextNoenc;\n-    ctxt->lasttext = copy->content;\n-    ctxt->lasttsize = len;\n-    ctxt->lasttuse = len;\n+        len = xmlStrlen(cur->content);\n+        copy = xmlNewTextLen(cur->content, len);\n+        if (copy == NULL)\n+            goto exit;\n+        if (cur->name == xmlStringTextNoenc)\n+            copy->name = xmlStringTextNoenc;\n+        ctxt->lasttext = copy->content;\n+        ctxt->lasttsize = len;\n+        ctxt->lasttuse = len;\n@@ -1117,9 +1117,9 @@\n-    if (target != NULL) {\n-        copy->doc = target->doc;\n-        \/*\n-        * MAYBE TODO: Maybe we should reset the ctxt->lasttext here\n-        *  to ensure that the optimized text-merging mechanism\n-        *  won't interfere with normal node-merging in any case.\n-        *\/\n-        copy = xsltAddChild(target, copy);\n-    }\n+        if (target != NULL) {\n+            copy->doc = target->doc;\n+            \/*\n+            * MAYBE TODO: Maybe we should reset the ctxt->lasttext here\n+            *  to ensure that the optimized text-merging mechanism\n+            *  won't interfere with normal node-merging in any case.\n+            *\/\n+            copy = xsltAddChild(target, copy);\n+        }\n@@ -1127,2 +1127,2 @@\n-    xsltTransformError(ctxt, NULL, target,\n-             \"xsltCopyText: text copy failed\\n\");\n+        xsltTransformError(ctxt, NULL, target,\n+                         \"xsltCopyText: text copy failed\\n\");\n@@ -1133,4 +1133,4 @@\n-    xsltTransformError(ctxt, NULL, target,\n-        \"Internal error in xsltCopyText(): \"\n-        \"Failed to copy the string.\\n\");\n-    ctxt->state = XSLT_STATE_STOPPED;\n+        xsltTransformError(ctxt, NULL, target,\n+            \"Internal error in xsltCopyText(): \"\n+            \"Failed to copy the string.\\n\");\n+        ctxt->state = XSLT_STATE_STOPPED;\n@@ -1158,1 +1158,1 @@\n-         xmlNodePtr target, xmlAttrPtr attr)\n+             xmlNodePtr target, xmlAttrPtr attr)\n@@ -1164,1 +1164,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1167,3 +1167,3 @@\n-    xsltTransformError(ctxt, NULL, invocNode,\n-        \"Cannot add an attribute node to a non-element node.\\n\");\n-    return(NULL);\n+        xsltTransformError(ctxt, NULL, invocNode,\n+            \"Cannot add an attribute node to a non-element node.\\n\");\n+        return(NULL);\n@@ -1173,4 +1173,4 @@\n-    xsltTransformError(ctxt, NULL, invocNode,\n-        \"Attribute nodes must be added before \"\n-        \"any child nodes to an element.\\n\");\n-    return(NULL);\n+        xsltTransformError(ctxt, NULL, invocNode,\n+            \"Attribute nodes must be added before \"\n+            \"any child nodes to an element.\\n\");\n+        return(NULL);\n@@ -1181,1 +1181,1 @@\n-    xmlNsPtr ns;\n+        xmlNsPtr ns;\n@@ -1183,7 +1183,11 @@\n-    ns = xsltGetSpecialNamespace(ctxt, invocNode,\n-        attr->ns->href, attr->ns->prefix, target);\n-    if (ns == NULL) {\n-        xsltTransformError(ctxt, NULL, invocNode,\n-        \"Namespace fixup error: Failed to acquire an in-scope \"\n-        \"namespace binding of the copied attribute '{%s}%s'.\\n\",\n-        attr->ns->href, attr->name);\n+        ns = xsltGetSpecialNamespace(ctxt, invocNode,\n+            attr->ns->href, attr->ns->prefix, target);\n+        if (ns == NULL) {\n+            xsltTransformError(ctxt, NULL, invocNode,\n+                \"Namespace fixup error: Failed to acquire an in-scope \"\n+                \"namespace binding of the copied attribute '{%s}%s'.\\n\",\n+                attr->ns->href, attr->name);\n+            \/*\n+            * TODO: Should we just stop here?\n+            *\/\n+        }\n@@ -1191,1 +1195,2 @@\n-        * TODO: Should we just stop here?\n+        * Note that xmlSetNsProp() will take care of duplicates\n+        * and assigns the new namespace even to a duplicate.\n@@ -1193,6 +1198,1 @@\n-    }\n-    \/*\n-    * Note that xmlSetNsProp() will take care of duplicates\n-    * and assigns the new namespace even to a duplicate.\n-    *\/\n-    copy = xmlSetNsProp(target, ns, attr->name, value);\n+        copy = xmlSetNsProp(target, ns, attr->name, value);\n@@ -1200,1 +1200,1 @@\n-    copy = xmlSetNsProp(target, NULL, attr->name, value);\n+        copy = xmlSetNsProp(target, NULL, attr->name, value);\n@@ -1203,1 +1203,1 @@\n-    xmlFree(value);\n+        xmlFree(value);\n@@ -1206,1 +1206,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1221,13 +1221,13 @@\n-    txtNode = xmlNewDocText(target->doc, NULL);\n-    if (txtNode == NULL)\n-        return(NULL);\n-    if ((target->doc != NULL) &&\n-        (target->doc->dict != NULL))\n-    {\n-        txtNode->content =\n-        (xmlChar *) xmlDictLookup(target->doc->dict,\n-            BAD_CAST value, -1);\n-        xmlFree(value);\n-    } else\n-        txtNode->content = value;\n-    copy->children = txtNode;\n+        txtNode = xmlNewDocText(target->doc, NULL);\n+        if (txtNode == NULL)\n+            return(NULL);\n+        if ((target->doc != NULL) &&\n+            (target->doc->dict != NULL))\n+        {\n+            txtNode->content =\n+                (xmlChar *) xmlDictLookup(target->doc->dict,\n+                    BAD_CAST value, -1);\n+            xmlFree(value);\n+        } else\n+            txtNode->content = value;\n+        copy->children = txtNode;\n@@ -1257,2 +1257,2 @@\n-                xmlNodePtr invocNode,\n-                xmlNodePtr target, xmlAttrPtr attr)\n+                            xmlNodePtr invocNode,\n+                            xmlNodePtr target, xmlAttrPtr attr)\n@@ -1269,19 +1269,19 @@\n-    \/*\n-    * Find a namespace node in the tree of @target.\n-    * Avoid searching for the same ns.\n-    *\/\n-    if (attr->ns != origNs) {\n-        origNs = attr->ns;\n-        if (attr->ns != NULL) {\n-        copyNs = xsltGetSpecialNamespace(ctxt, invocNode,\n-            attr->ns->href, attr->ns->prefix, target);\n-        if (copyNs == NULL)\n-            return(-1);\n-        } else\n-        copyNs = NULL;\n-    }\n-    \/*\n-     * If attribute has a value, we need to copy it (watching out\n-     * for possible entities)\n-     *\/\n-    if ((attr->children) && (attr->children->type == XML_TEXT_NODE) &&\n+        \/*\n+        * Find a namespace node in the tree of @target.\n+        * Avoid searching for the same ns.\n+        *\/\n+        if (attr->ns != origNs) {\n+            origNs = attr->ns;\n+            if (attr->ns != NULL) {\n+                copyNs = xsltGetSpecialNamespace(ctxt, invocNode,\n+                    attr->ns->href, attr->ns->prefix, target);\n+                if (copyNs == NULL)\n+                    return(-1);\n+            } else\n+                copyNs = NULL;\n+        }\n+        \/*\n+         * If attribute has a value, we need to copy it (watching out\n+         * for possible entities)\n+         *\/\n+        if ((attr->children) && (attr->children->type == XML_TEXT_NODE) &&\n@@ -1292,1 +1292,1 @@\n-        value = xmlNodeListGetString(attr->doc, attr->children, 1);\n+            value = xmlNodeListGetString(attr->doc, attr->children, 1);\n@@ -1294,1 +1294,1 @@\n-        xmlFree(value);\n+            xmlFree(value);\n@@ -1299,2 +1299,2 @@\n-    if (copy == NULL)\n-        return(-1);\n+        if (copy == NULL)\n+            return(-1);\n@@ -1302,1 +1302,1 @@\n-    attr = attr->next;\n+        attr = attr->next;\n@@ -1333,1 +1333,1 @@\n-            xmlNodePtr insert, int isLRE)\n+                    xmlNodePtr insert, int isLRE)\n@@ -1338,1 +1338,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1340,2 +1340,2 @@\n-    (node->type == XML_CDATA_SECTION_NODE))\n-    return(xsltCopyText(ctxt, insert, node, 0));\n+        (node->type == XML_CDATA_SECTION_NODE))\n+        return(xsltCopyText(ctxt, insert, node, 0));\n@@ -1345,2 +1345,2 @@\n-    copy->doc = ctxt->output;\n-    copy = xsltAddChild(insert, copy);\n+        copy->doc = ctxt->output;\n+        copy = xsltAddChild(insert, copy);\n@@ -1353,14 +1353,14 @@\n-    if (node->type == XML_ELEMENT_NODE) {\n-        \/*\n-         * Add namespaces as they are needed\n-         *\/\n-        if (node->nsDef != NULL) {\n-        \/*\n-        * TODO: Remove the LRE case in the refactored code\n-        * gets enabled.\n-        *\/\n-        if (isLRE)\n-            xsltCopyNamespaceList(ctxt, copy, node->nsDef);\n-        else\n-            xsltCopyNamespaceListInternal(copy, node->nsDef);\n-        }\n+        if (node->type == XML_ELEMENT_NODE) {\n+            \/*\n+             * Add namespaces as they are needed\n+             *\/\n+            if (node->nsDef != NULL) {\n+                \/*\n+                * TODO: Remove the LRE case in the refactored code\n+                * gets enabled.\n+                *\/\n+                if (isLRE)\n+                    xsltCopyNamespaceList(ctxt, copy, node->nsDef);\n+                else\n+                    xsltCopyNamespaceListInternal(copy, node->nsDef);\n+            }\n@@ -1368,9 +1368,0 @@\n-        \/*\n-        * URGENT TODO: The problem with this is that it does not\n-        *  copy over all namespace nodes in scope.\n-        *  The damn thing about this is, that we would need to\n-        *  use the xmlGetNsList(), for every single node; this is\n-        *  also done in xsltCopyTree(), but only for the top node.\n-        *\/\n-        if (node->ns != NULL) {\n-        if (isLRE) {\n@@ -1378,3 +1369,5 @@\n-            * REVISIT TODO: Since the non-refactored code still does\n-            *  ns-aliasing, we need to call xsltGetNamespace() here.\n-            *  Remove this when ready.\n+            * URGENT TODO: The problem with this is that it does not\n+            *  copy over all namespace nodes in scope.\n+            *  The damn thing about this is, that we would need to\n+            *  use the xmlGetNsList(), for every single node; this is\n+            *  also done in xsltCopyTree(), but only for the top node.\n@@ -1382,4 +1375,11 @@\n-            copy->ns = xsltGetNamespace(ctxt, node, node->ns, copy);\n-        } else {\n-            copy->ns = xsltGetSpecialNamespace(ctxt,\n-            node, node->ns->href, node->ns->prefix, copy);\n+            if (node->ns != NULL) {\n+                if (isLRE) {\n+                    \/*\n+                    * REVISIT TODO: Since the non-refactored code still does\n+                    *  ns-aliasing, we need to call xsltGetNamespace() here.\n+                    *  Remove this when ready.\n+                    *\/\n+                    copy->ns = xsltGetNamespace(ctxt, node, node->ns, copy);\n+                } else {\n+                    copy->ns = xsltGetSpecialNamespace(ctxt,\n+                        node, node->ns->href, node->ns->prefix, copy);\n@@ -1387,0 +1387,9 @@\n+                }\n+            } else if ((insert->type == XML_ELEMENT_NODE) &&\n+                       (insert->ns != NULL))\n+            {\n+                \/*\n+                * \"Undeclare\" the default namespace.\n+                *\/\n+                xsltGetSpecialNamespace(ctxt, node, NULL, NULL, copy);\n+            }\n@@ -1388,9 +1397,0 @@\n-        } else if ((insert->type == XML_ELEMENT_NODE) &&\n-               (insert->ns != NULL))\n-        {\n-        \/*\n-        * \"Undeclare\" the default namespace.\n-        *\/\n-        xsltGetSpecialNamespace(ctxt, node, NULL, NULL, copy);\n-        }\n-    }\n@@ -1398,2 +1398,2 @@\n-    xsltTransformError(ctxt, NULL, node,\n-        \"xsltShallowCopyElem: copy %s failed\\n\", node->name);\n+        xsltTransformError(ctxt, NULL, node,\n+                \"xsltShallowCopyElem: copy %s failed\\n\", node->name);\n@@ -1425,2 +1425,2 @@\n-         xmlNodePtr list,\n-         xmlNodePtr insert, int isLRE, int topElemVisited)\n+                 xmlNodePtr list,\n+                 xmlNodePtr insert, int isLRE, int topElemVisited)\n@@ -1431,5 +1431,6 @@\n-    copy = xsltCopyTree(ctxt, invocNode,\n-        list, insert, isLRE, topElemVisited);\n-    if (copy != NULL) {\n-        if (ret == NULL) {\n-        ret = copy;\n+        copy = xsltCopyTree(ctxt, invocNode,\n+            list, insert, isLRE, topElemVisited);\n+        if (copy != NULL) {\n+            if (ret == NULL) {\n+                ret = copy;\n+            }\n@@ -1437,2 +1438,1 @@\n-    }\n-    list = list->next;\n+        list = list->next;\n@@ -1465,1 +1465,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1470,1 +1470,1 @@\n-    elem = NULL;\n+        elem = NULL;\n@@ -1473,12 +1473,19 @@\n-    if (ns->type != XML_NAMESPACE_DECL)\n-        break;\n-    \/*\n-     * Avoid duplicating namespace declarations on the tree.\n-     *\/\n-    if (elem != NULL) {\n-        if ((elem->ns != NULL) &&\n-        xmlStrEqual(elem->ns->prefix, ns->prefix) &&\n-        xmlStrEqual(elem->ns->href, ns->href))\n-        {\n-        ns = ns->next;\n-        continue;\n+        if (ns->type != XML_NAMESPACE_DECL)\n+            break;\n+        \/*\n+         * Avoid duplicating namespace declarations on the tree.\n+         *\/\n+        if (elem != NULL) {\n+            if ((elem->ns != NULL) &&\n+                xmlStrEqual(elem->ns->prefix, ns->prefix) &&\n+                xmlStrEqual(elem->ns->href, ns->href))\n+            {\n+                ns = ns->next;\n+                continue;\n+            }\n+            luNs = xmlSearchNs(elem->doc, elem, ns->prefix);\n+            if ((luNs != NULL) && (xmlStrEqual(luNs->href, ns->href)))\n+            {\n+                ns = ns->next;\n+                continue;\n+            }\n@@ -1486,5 +1493,6 @@\n-        luNs = xmlSearchNs(elem->doc, elem, ns->prefix);\n-        if ((luNs != NULL) && (xmlStrEqual(luNs->href, ns->href)))\n-        {\n-        ns = ns->next;\n-        continue;\n+        q = xmlNewNs(elem, ns->href, ns->prefix);\n+        if (p == NULL) {\n+            ret = p = q;\n+        } else if (q != NULL) {\n+            p->next = q;\n+            p = q;\n@@ -1492,9 +1500,1 @@\n-    }\n-    q = xmlNewNs(elem, ns->href, ns->prefix);\n-    if (p == NULL) {\n-        ret = p = q;\n-    } else if (q != NULL) {\n-        p->next = q;\n-        p = q;\n-    }\n-    ns = ns->next;\n+        ns = ns->next;\n@@ -1518,3 +1518,3 @@\n-              xmlNodePtr invocNode,\n-              xmlNodePtr insert,\n-              xmlNsPtr ns)\n+                      xmlNodePtr invocNode,\n+                      xmlNodePtr insert,\n+                      xmlNsPtr ns)\n@@ -1529,1 +1529,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1532,4 +1532,4 @@\n-    xsltTransformError(ctxt, NULL, invocNode,\n-        \"Namespace nodes must be added before \"\n-        \"any child nodes are added to an element.\\n\");\n-    return(NULL);\n+        xsltTransformError(ctxt, NULL, invocNode,\n+            \"Namespace nodes must be added before \"\n+            \"any child nodes are added to an element.\\n\");\n+        return(NULL);\n@@ -1552,10 +1552,10 @@\n-    \/*\n-    * If we are adding ns-nodes to an element using e.g.\n-    * <xsl:copy-of select=\"\/foo\/namespace::*\">, then we need\n-    * to ensure that we don't incorrectly declare a default\n-    * namespace on an element in no namespace, which otherwise\n-    * would move the element incorrectly into a namespace, if\n-    * the node tree is serialized.\n-    *\/\n-    if (insert->ns == NULL)\n-        goto occupied;\n+        \/*\n+        * If we are adding ns-nodes to an element using e.g.\n+        * <xsl:copy-of select=\"\/foo\/namespace::*\">, then we need\n+        * to ensure that we don't incorrectly declare a default\n+        * namespace on an element in no namespace, which otherwise\n+        * would move the element incorrectly into a namespace, if\n+        * the node tree is serialized.\n+        *\/\n+        if (insert->ns == NULL)\n+            goto occupied;\n@@ -1563,1 +1563,1 @@\n-    xmlStrEqual(ns->prefix, BAD_CAST \"xml\"))\n+        xmlStrEqual(ns->prefix, BAD_CAST \"xml\"))\n@@ -1565,4 +1565,4 @@\n-    \/*\n-    * The XML namespace is built in.\n-    *\/\n-    return(NULL);\n+        \/*\n+        * The XML namespace is built in.\n+        *\/\n+        return(NULL);\n@@ -1572,16 +1572,16 @@\n-    tmpns = insert->nsDef;\n-    do {\n-        if ((tmpns->prefix == NULL) == (ns->prefix == NULL)) {\n-        if ((tmpns->prefix == ns->prefix) ||\n-            xmlStrEqual(tmpns->prefix, ns->prefix))\n-        {\n-            \/*\n-            * Same prefix.\n-            *\/\n-            if (xmlStrEqual(tmpns->href, ns->href))\n-            return(NULL);\n-            goto occupied;\n-        }\n-        }\n-        tmpns = tmpns->next;\n-    } while (tmpns != NULL);\n+        tmpns = insert->nsDef;\n+        do {\n+            if ((tmpns->prefix == NULL) == (ns->prefix == NULL)) {\n+                if ((tmpns->prefix == ns->prefix) ||\n+                    xmlStrEqual(tmpns->prefix, ns->prefix))\n+                {\n+                    \/*\n+                    * Same prefix.\n+                    *\/\n+                    if (xmlStrEqual(tmpns->href, ns->href))\n+                        return(NULL);\n+                    goto occupied;\n+                }\n+            }\n+            tmpns = tmpns->next;\n+        } while (tmpns != NULL);\n@@ -1591,1 +1591,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1629,2 +1629,2 @@\n-         xmlNodePtr node, xmlNodePtr insert, int isLRE,\n-         int topElemVisited)\n+             xmlNodePtr node, xmlNodePtr insert, int isLRE,\n+             int topElemVisited)\n@@ -1635,1 +1635,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1647,1 +1647,1 @@\n-        break;\n+            break;\n@@ -1649,3 +1649,3 @@\n-        int noenc = (node->name == xmlStringTextNoenc);\n-        return(xsltCopyTextString(ctxt, insert, node->content, noenc));\n-        }\n+            int noenc = (node->name == xmlStringTextNoenc);\n+            return(xsltCopyTextString(ctxt, insert, node->content, noenc));\n+            }\n@@ -1653,1 +1653,1 @@\n-        return(xsltCopyTextString(ctxt, insert, node->content, 0));\n+            return(xsltCopyTextString(ctxt, insert, node->content, 0));\n@@ -1655,2 +1655,2 @@\n-        return((xmlNodePtr)\n-        xsltShallowCopyAttr(ctxt, invocNode, insert, (xmlAttrPtr) node));\n+            return((xmlNodePtr)\n+                xsltShallowCopyAttr(ctxt, invocNode, insert, (xmlAttrPtr) node));\n@@ -1658,2 +1658,2 @@\n-        return((xmlNodePtr) xsltShallowCopyNsNode(ctxt, invocNode,\n-        insert, (xmlNsPtr) node));\n+            return((xmlNodePtr) xsltShallowCopyNsNode(ctxt, invocNode,\n+                insert, (xmlNsPtr) node));\n@@ -1673,6 +1673,6 @@\n-    if (node->children != NULL)\n-        copy = xsltCopyTreeList(ctxt, invocNode,\n-        node->children, insert, 0, 0);\n-    else\n-        copy = NULL;\n-    return(copy);\n+        if (node->children != NULL)\n+            copy = xsltCopyTreeList(ctxt, invocNode,\n+                node->children, insert, 0, 0);\n+        else\n+            copy = NULL;\n+        return(copy);\n@@ -1682,2 +1682,2 @@\n-    copy->doc = ctxt->output;\n-    copy = xsltAddChild(insert, copy);\n+        copy->doc = ctxt->output;\n+        copy = xsltAddChild(insert, copy);\n@@ -1689,27 +1689,0 @@\n-    \/*\n-     * The node may have been coalesced into another text node.\n-     *\/\n-    if (insert->last != copy)\n-        return(insert->last);\n-    copy->next = NULL;\n-\n-    if (node->type == XML_ELEMENT_NODE) {\n-        \/*\n-        * Copy in-scope namespace nodes.\n-        *\n-        * REVISIT: Since we try to reuse existing in-scope ns-decls by\n-        *  using xmlSearchNsByHref(), this will eventually change\n-        *  the prefix of an original ns-binding; thus it might\n-        *  break QNames in element\/attribute content.\n-        * OPTIMIZE TODO: If we had a xmlNsPtr * on the transformation\n-        *  context, plus a ns-lookup function, which writes directly\n-        *  to a given list, then we wouldn't need to create\/free the\n-        *  nsList every time.\n-        *\/\n-        if ((topElemVisited == 0) &&\n-        (node->parent != NULL) &&\n-        (node->parent->type != XML_DOCUMENT_NODE) &&\n-        (node->parent->type != XML_HTML_DOCUMENT_NODE))\n-        {\n-        xmlNsPtr *nsList, *curns, ns;\n-\n@@ -1717,6 +1690,5 @@\n-        * If this is a top-most element in a tree to be\n-        * copied, then we need to ensure that all in-scope\n-        * namespaces are copied over. For nodes deeper in the\n-        * tree, it is sufficient to reconcile only the ns-decls\n-        * (node->nsDef entries).\n-        *\/\n+         * The node may have been coalesced into another text node.\n+         *\/\n+        if (insert->last != copy)\n+            return(insert->last);\n+        copy->next = NULL;\n@@ -1724,4 +1696,1 @@\n-        nsList = xmlGetNsList(node->doc, node);\n-        if (nsList != NULL) {\n-            curns = nsList;\n-            do {\n+        if (node->type == XML_ELEMENT_NODE) {\n@@ -1729,2 +1698,10 @@\n-            * Search by prefix first in order to break as less\n-            * QNames in element\/attribute content as possible.\n+            * Copy in-scope namespace nodes.\n+            *\n+            * REVISIT: Since we try to reuse existing in-scope ns-decls by\n+            *  using xmlSearchNsByHref(), this will eventually change\n+            *  the prefix of an original ns-binding; thus it might\n+            *  break QNames in element\/attribute content.\n+            * OPTIMIZE TODO: If we had a xmlNsPtr * on the transformation\n+            *  context, plus a ns-lookup function, which writes directly\n+            *  to a given list, then we wouldn't need to create\/free the\n+            *  nsList every time.\n@@ -1732,5 +1709,4 @@\n-            ns = xmlSearchNs(insert->doc, insert,\n-                (*curns)->prefix);\n-\n-            if ((ns == NULL) ||\n-                (! xmlStrEqual(ns->href, (*curns)->href)))\n+            if ((topElemVisited == 0) &&\n+                (node->parent != NULL) &&\n+                (node->parent->type != XML_DOCUMENT_NODE) &&\n+                (node->parent->type != XML_HTML_DOCUMENT_NODE))\n@@ -1738,1 +1714,2 @@\n-                ns = NULL;\n+                xmlNsPtr *nsList, *curns, ns;\n+\n@@ -1740,2 +1717,5 @@\n-                * Search by namespace name.\n-                * REVISIT TODO: Currently disabled.\n+                * If this is a top-most element in a tree to be\n+                * copied, then we need to ensure that all in-scope\n+                * namespaces are copied over. For nodes deeper in the\n+                * tree, it is sufficient to reconcile only the ns-decls\n+                * (node->nsDef entries).\n@@ -1743,0 +1723,20 @@\n+\n+                nsList = xmlGetNsList(node->doc, node);\n+                if (nsList != NULL) {\n+                    curns = nsList;\n+                    do {\n+                        \/*\n+                        * Search by prefix first in order to break as less\n+                        * QNames in element\/attribute content as possible.\n+                        *\/\n+                        ns = xmlSearchNs(insert->doc, insert,\n+                            (*curns)->prefix);\n+\n+                        if ((ns == NULL) ||\n+                            (! xmlStrEqual(ns->href, (*curns)->href)))\n+                        {\n+                            ns = NULL;\n+                            \/*\n+                            * Search by namespace name.\n+                            * REVISIT TODO: Currently disabled.\n+                            *\/\n@@ -1744,5 +1744,24 @@\n-                ns = xmlSearchNsByHref(insert->doc,\n-                insert, (*curns)->href);\n-#endif\n-            }\n-            if (ns == NULL) {\n+                            ns = xmlSearchNsByHref(insert->doc,\n+                                insert, (*curns)->href);\n+#endif\n+                        }\n+                        if (ns == NULL) {\n+                            \/*\n+                            * Declare a new namespace on the copied element.\n+                            *\/\n+                            ns = xmlNewNs(copy, (*curns)->href,\n+                                (*curns)->prefix);\n+                            \/* TODO: Handle errors *\/\n+                        }\n+                        if (node->ns == *curns) {\n+                            \/*\n+                            * If this was the original's namespace then set\n+                            * the generated counterpart on the copy.\n+                            *\/\n+                            copy->ns = ns;\n+                        }\n+                        curns++;\n+                    } while (*curns != NULL);\n+                    xmlFree(nsList);\n+                }\n+            } else if (node->nsDef != NULL) {\n@@ -1750,1 +1769,1 @@\n-                * Declare a new namespace on the copied element.\n+                * Copy over all namespace declaration attributes.\n@@ -1752,3 +1771,6 @@\n-                ns = xmlNewNs(copy, (*curns)->href,\n-                (*curns)->prefix);\n-                \/* TODO: Handle errors *\/\n+                if (node->nsDef != NULL) {\n+                    if (isLRE)\n+                        xsltCopyNamespaceList(ctxt, copy, node->nsDef);\n+                    else\n+                        xsltCopyNamespaceListInternal(copy, node->nsDef);\n+                }\n@@ -1756,1 +1778,15 @@\n-            if (node->ns == *curns) {\n+            \/*\n+            * Set the namespace.\n+            *\/\n+            if (node->ns != NULL) {\n+                if (copy->ns == NULL) {\n+                    \/*\n+                    * This will map copy->ns to one of the newly created\n+                    * in-scope ns-decls, OR create a new ns-decl on @copy.\n+                    *\/\n+                    copy->ns = xsltGetSpecialNamespace(ctxt, invocNode,\n+                        node->ns->href, node->ns->prefix, copy);\n+                }\n+            } else if ((insert->type == XML_ELEMENT_NODE) &&\n+                (insert->ns != NULL))\n+            {\n@@ -1758,2 +1794,1 @@\n-                * If this was the original's namespace then set\n-                * the generated counterpart on the copy.\n+                * \"Undeclare\" the default namespace on @copy with xmlns=\"\".\n@@ -1761,1 +1796,1 @@\n-                copy->ns = ns;\n+                xsltGetSpecialNamespace(ctxt, invocNode, NULL, NULL, copy);\n@@ -1763,20 +1798,0 @@\n-            curns++;\n-            } while (*curns != NULL);\n-            xmlFree(nsList);\n-        }\n-        } else if (node->nsDef != NULL) {\n-        \/*\n-        * Copy over all namespace declaration attributes.\n-        *\/\n-        if (node->nsDef != NULL) {\n-            if (isLRE)\n-            xsltCopyNamespaceList(ctxt, copy, node->nsDef);\n-            else\n-            xsltCopyNamespaceListInternal(copy, node->nsDef);\n-        }\n-        }\n-        \/*\n-        * Set the namespace.\n-        *\/\n-        if (node->ns != NULL) {\n-        if (copy->ns == NULL) {\n@@ -1784,2 +1799,1 @@\n-            * This will map copy->ns to one of the newly created\n-            * in-scope ns-decls, OR create a new ns-decl on @copy.\n+            * Copy attribute nodes.\n@@ -1787,10 +1801,6 @@\n-            copy->ns = xsltGetSpecialNamespace(ctxt, invocNode,\n-            node->ns->href, node->ns->prefix, copy);\n-        }\n-        } else if ((insert->type == XML_ELEMENT_NODE) &&\n-        (insert->ns != NULL))\n-        {\n-        \/*\n-        * \"Undeclare\" the default namespace on @copy with xmlns=\"\".\n-        *\/\n-        xsltGetSpecialNamespace(ctxt, invocNode, NULL, NULL, copy);\n+            if (node->properties != NULL) {\n+                xsltCopyAttrListNoOverwrite(ctxt, invocNode,\n+                    copy, node->properties);\n+            }\n+            if (topElemVisited == 0)\n+                topElemVisited = 1;\n@@ -1799,1 +1809,1 @@\n-        * Copy attribute nodes.\n+        * Copy the subtree.\n@@ -1801,3 +1811,3 @@\n-        if (node->properties != NULL) {\n-        xsltCopyAttrListNoOverwrite(ctxt, invocNode,\n-            copy, node->properties);\n+        if (node->children != NULL) {\n+            xsltCopyTreeList(ctxt, invocNode,\n+                node->children, copy, isLRE, topElemVisited);\n@@ -1805,10 +1815,0 @@\n-        if (topElemVisited == 0)\n-        topElemVisited = 1;\n-    }\n-    \/*\n-    * Copy the subtree.\n-    *\/\n-    if (node->children != NULL) {\n-        xsltCopyTreeList(ctxt, invocNode,\n-        node->children, copy, isLRE, topElemVisited);\n-    }\n@@ -1816,2 +1816,2 @@\n-    xsltTransformError(ctxt, NULL, invocNode,\n-        \"xsltCopyTree: Copying of '%s' failed.\\n\", node->name);\n+        xsltTransformError(ctxt, NULL, invocNode,\n+            \"xsltCopyTree: Copying of '%s' failed.\\n\", node->name);\n@@ -1823,3 +1823,3 @@\n- *                                  *\n- *      Error\/fallback processing               *\n- *                                  *\n+ *                                                                      *\n+ *              Error\/fallback processing                               *\n+ *                                                                      *\n@@ -1840,1 +1840,1 @@\n-               xmlNodePtr inst) {\n+                   xmlNodePtr inst) {\n@@ -1846,2 +1846,2 @@\n-    (inst->children == NULL))\n-    return(0);\n+        (inst->children == NULL))\n+        return(0);\n@@ -1854,2 +1854,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-                 \"applying xsl:fallback\\n\");\n+            xsltGenericDebug(xsltGenericDebugContext,\n+                             \"applying xsl:fallback\\n\");\n@@ -1857,5 +1857,5 @@\n-        ret++;\n-        xsltApplySequenceConstructor(ctxt, node, child->children,\n-        NULL);\n-    }\n-    child = child->next;\n+            ret++;\n+            xsltApplySequenceConstructor(ctxt, node, child->children,\n+                NULL);\n+        }\n+        child = child->next;\n@@ -1867,3 +1867,3 @@\n- *                                  *\n- *          Default processing              *\n- *                                  *\n+ *                                                                      *\n+ *                      Default processing                              *\n+ *                                                                      *\n@@ -1896,1 +1896,1 @@\n-              xsltStackElemPtr params) {\n+                          xsltStackElemPtr params) {\n@@ -1898,1 +1898,1 @@\n-    xmlNodePtr delete = NULL, cur;\n+    xmlNodePtr cur;\n@@ -1908,5 +1908,5 @@\n-    case XML_DOCUMENT_NODE:\n-    case XML_HTML_DOCUMENT_NODE:\n-    case XML_ELEMENT_NODE:\n-        break;\n-    case XML_CDATA_SECTION_NODE:\n+        case XML_DOCUMENT_NODE:\n+        case XML_HTML_DOCUMENT_NODE:\n+        case XML_ELEMENT_NODE:\n+            break;\n+        case XML_CDATA_SECTION_NODE:\n@@ -1914,3 +1914,3 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltDefaultProcessOneNode: copy CDATA %s\\n\",\n-        node->content));\n+            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltDefaultProcessOneNode: copy CDATA %s\\n\",\n+                node->content));\n@@ -1918,7 +1918,7 @@\n-        copy = xsltCopyText(ctxt, ctxt->insert, node, 0);\n-        if (copy == NULL) {\n-        xsltTransformError(ctxt, NULL, node,\n-         \"xsltDefaultProcessOneNode: cdata copy failed\\n\");\n-        }\n-        return;\n-    case XML_TEXT_NODE:\n+            copy = xsltCopyText(ctxt, ctxt->insert, node, 0);\n+            if (copy == NULL) {\n+                xsltTransformError(ctxt, NULL, node,\n+                 \"xsltDefaultProcessOneNode: cdata copy failed\\n\");\n+            }\n+            return;\n+        case XML_TEXT_NODE:\n@@ -1926,8 +1926,8 @@\n-        if (node->content == NULL) {\n-        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltDefaultProcessOneNode: copy empty text\\n\"));\n-        return;\n-        } else {\n-        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltDefaultProcessOneNode: copy text %s\\n\",\n-            node->content));\n+            if (node->content == NULL) {\n+                XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+                 \"xsltDefaultProcessOneNode: copy empty text\\n\"));\n+                return;\n+            } else {\n+                XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+                 \"xsltDefaultProcessOneNode: copy text %s\\n\",\n+                        node->content));\n@@ -1936,14 +1936,14 @@\n-        copy = xsltCopyText(ctxt, ctxt->insert, node, 0);\n-        if (copy == NULL) {\n-        xsltTransformError(ctxt, NULL, node,\n-         \"xsltDefaultProcessOneNode: text copy failed\\n\");\n-        }\n-        return;\n-    case XML_ATTRIBUTE_NODE:\n-        cur = node->children;\n-        while ((cur != NULL) && (cur->type != XML_TEXT_NODE))\n-        cur = cur->next;\n-        if (cur == NULL) {\n-        xsltTransformError(ctxt, NULL, node,\n-         \"xsltDefaultProcessOneNode: no text for attribute\\n\");\n-        } else {\n+            copy = xsltCopyText(ctxt, ctxt->insert, node, 0);\n+            if (copy == NULL) {\n+                xsltTransformError(ctxt, NULL, node,\n+                 \"xsltDefaultProcessOneNode: text copy failed\\n\");\n+            }\n+            return;\n+        case XML_ATTRIBUTE_NODE:\n+            cur = node->children;\n+            while ((cur != NULL) && (cur->type != XML_TEXT_NODE))\n+                cur = cur->next;\n+            if (cur == NULL) {\n+                xsltTransformError(ctxt, NULL, node,\n+                 \"xsltDefaultProcessOneNode: no text for attribute\\n\");\n+            } else {\n@@ -1951,7 +1951,7 @@\n-        if (cur->content == NULL) {\n-            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltDefaultProcessOneNode: copy empty text\\n\"));\n-        } else {\n-            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltDefaultProcessOneNode: copy text %s\\n\",\n-            cur->content));\n+                if (cur->content == NULL) {\n+                    XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+                     \"xsltDefaultProcessOneNode: copy empty text\\n\"));\n+                } else {\n+                    XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+                     \"xsltDefaultProcessOneNode: copy text %s\\n\",\n+                        cur->content));\n@@ -1960,9 +1960,9 @@\n-        copy = xsltCopyText(ctxt, ctxt->insert, cur, 0);\n-        if (copy == NULL) {\n-            xsltTransformError(ctxt, NULL, node,\n-             \"xsltDefaultProcessOneNode: text copy failed\\n\");\n-        }\n-        }\n-        return;\n-    default:\n-        return;\n+                copy = xsltCopyText(ctxt, ctxt->insert, cur, 0);\n+                if (copy == NULL) {\n+                    xsltTransformError(ctxt, NULL, node,\n+                     \"xsltDefaultProcessOneNode: text copy failed\\n\");\n+                }\n+            }\n+            return;\n+        default:\n+            return;\n@@ -1971,1 +1971,1 @@\n-     * Handling of Elements: first pass, cleanup and counting\n+     * Handling of Elements: first pass, counting\n@@ -1975,44 +1975,3 @@\n-    switch (cur->type) {\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        case XML_DOCUMENT_NODE:\n-        case XML_HTML_DOCUMENT_NODE:\n-        case XML_ELEMENT_NODE:\n-        case XML_PI_NODE:\n-        case XML_COMMENT_NODE:\n-        nbchild++;\n-        break;\n-            case XML_DTD_NODE:\n-        \/* Unlink the DTD, it's still reachable using doc->intSubset *\/\n-        if (cur->next != NULL)\n-            cur->next->prev = cur->prev;\n-        if (cur->prev != NULL)\n-            cur->prev->next = cur->next;\n-        break;\n-        default:\n-#ifdef WITH_XSLT_DEBUG_PROCESS\n-        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltDefaultProcessOneNode: skipping node type %d\\n\",\n-                         cur->type));\n-#endif\n-        delete = cur;\n-    }\n-    cur = cur->next;\n-    if (delete != NULL) {\n-#ifdef WITH_XSLT_DEBUG_PROCESS\n-        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltDefaultProcessOneNode: removing ignorable blank node\\n\"));\n-#endif\n-        xmlUnlinkNode(delete);\n-        xmlFreeNode(delete);\n-        delete = NULL;\n-    }\n-    }\n-    if (delete != NULL) {\n-#ifdef WITH_XSLT_DEBUG_PROCESS\n-    XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltDefaultProcessOneNode: removing ignorable blank node\\n\"));\n-#endif\n-    xmlUnlinkNode(delete);\n-    xmlFreeNode(delete);\n-    delete = NULL;\n+        if (IS_XSLT_REAL_NODE(cur))\n+            nbchild++;\n+        cur = cur->next;\n@@ -2031,12 +1990,12 @@\n-    childno++;\n-    switch (cur->type) {\n-        case XML_DOCUMENT_NODE:\n-        case XML_HTML_DOCUMENT_NODE:\n-        case XML_ELEMENT_NODE:\n-        ctxt->xpathCtxt->contextSize = nbchild;\n-        ctxt->xpathCtxt->proximityPosition = childno;\n-        xsltProcessOneNode(ctxt, cur, params);\n-        break;\n-        case XML_CDATA_SECTION_NODE:\n-        template = xsltGetTemplate(ctxt, cur, NULL);\n-        if (template) {\n+        childno++;\n+        switch (cur->type) {\n+            case XML_DOCUMENT_NODE:\n+            case XML_HTML_DOCUMENT_NODE:\n+            case XML_ELEMENT_NODE:\n+                ctxt->xpathCtxt->contextSize = nbchild;\n+                ctxt->xpathCtxt->proximityPosition = childno;\n+                xsltProcessOneNode(ctxt, cur, params);\n+                break;\n+            case XML_CDATA_SECTION_NODE:\n+                template = xsltGetTemplate(ctxt, cur, NULL);\n+                if (template) {\n@@ -2044,3 +2003,3 @@\n-            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltDefaultProcessOneNode: applying template for CDATA %s\\n\",\n-                     cur->content));\n+                    XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+                 \"xsltDefaultProcessOneNode: applying template for CDATA %s\\n\",\n+                                     cur->content));\n@@ -2048,6 +2007,6 @@\n-            \/*\n-            * Instantiate the xsl:template.\n-            *\/\n-            xsltApplyXSLTTemplate(ctxt, cur, template->content,\n-            template, params);\n-        } else \/* if (ctxt->mode == NULL) *\/ {\n+                    \/*\n+                    * Instantiate the xsl:template.\n+                    *\/\n+                    xsltApplyXSLTTemplate(ctxt, cur, template->content,\n+                        template, params);\n+                } else \/* if (ctxt->mode == NULL) *\/ {\n@@ -2055,14 +2014,14 @@\n-            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltDefaultProcessOneNode: copy CDATA %s\\n\",\n-                     cur->content));\n-#endif\n-            copy = xsltCopyText(ctxt, ctxt->insert, cur, 0);\n-            if (copy == NULL) {\n-            xsltTransformError(ctxt, NULL, cur,\n-                \"xsltDefaultProcessOneNode: cdata copy failed\\n\");\n-            }\n-        }\n-        break;\n-        case XML_TEXT_NODE:\n-        template = xsltGetTemplate(ctxt, cur, NULL);\n-        if (template) {\n+                    XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+                     \"xsltDefaultProcessOneNode: copy CDATA %s\\n\",\n+                                     cur->content));\n+#endif\n+                    copy = xsltCopyText(ctxt, ctxt->insert, cur, 0);\n+                    if (copy == NULL) {\n+                        xsltTransformError(ctxt, NULL, cur,\n+                            \"xsltDefaultProcessOneNode: cdata copy failed\\n\");\n+                    }\n+                }\n+                break;\n+            case XML_TEXT_NODE:\n+                template = xsltGetTemplate(ctxt, cur, NULL);\n+                if (template) {\n@@ -2070,3 +2029,3 @@\n-            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltDefaultProcessOneNode: applying template for text %s\\n\",\n-                     cur->content));\n+                    XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltDefaultProcessOneNode: applying template for text %s\\n\",\n+                                     cur->content));\n@@ -2074,8 +2033,8 @@\n-            ctxt->xpathCtxt->contextSize = nbchild;\n-            ctxt->xpathCtxt->proximityPosition = childno;\n-            \/*\n-            * Instantiate the xsl:template.\n-            *\/\n-            xsltApplyXSLTTemplate(ctxt, cur, template->content,\n-            template, params);\n-        } else \/* if (ctxt->mode == NULL) *\/ {\n+                    ctxt->xpathCtxt->contextSize = nbchild;\n+                    ctxt->xpathCtxt->proximityPosition = childno;\n+                    \/*\n+                    * Instantiate the xsl:template.\n+                    *\/\n+                    xsltApplyXSLTTemplate(ctxt, cur, template->content,\n+                        template, params);\n+                } else \/* if (ctxt->mode == NULL) *\/ {\n@@ -2083,7 +2042,7 @@\n-            if (cur->content == NULL) {\n-            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltDefaultProcessOneNode: copy empty text\\n\"));\n-            } else {\n-            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltDefaultProcessOneNode: copy text %s\\n\",\n-                     cur->content));\n+                    if (cur->content == NULL) {\n+                        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+                         \"xsltDefaultProcessOneNode: copy empty text\\n\"));\n+                    } else {\n+                        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+                     \"xsltDefaultProcessOneNode: copy text %s\\n\",\n+                                         cur->content));\n@@ -2092,11 +2051,11 @@\n-            copy = xsltCopyText(ctxt, ctxt->insert, cur, 0);\n-            if (copy == NULL) {\n-            xsltTransformError(ctxt, NULL, cur,\n-                \"xsltDefaultProcessOneNode: text copy failed\\n\");\n-            }\n-        }\n-        break;\n-        case XML_PI_NODE:\n-        case XML_COMMENT_NODE:\n-        template = xsltGetTemplate(ctxt, cur, NULL);\n-        if (template) {\n+                    copy = xsltCopyText(ctxt, ctxt->insert, cur, 0);\n+                    if (copy == NULL) {\n+                        xsltTransformError(ctxt, NULL, cur,\n+                            \"xsltDefaultProcessOneNode: text copy failed\\n\");\n+                    }\n+                }\n+                break;\n+            case XML_PI_NODE:\n+            case XML_COMMENT_NODE:\n+                template = xsltGetTemplate(ctxt, cur, NULL);\n+                if (template) {\n@@ -2104,7 +2063,7 @@\n-            if (cur->type == XML_PI_NODE) {\n-            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltDefaultProcessOneNode: template found for PI %s\\n\",\n-                             cur->name));\n-            } else if (cur->type == XML_COMMENT_NODE) {\n-            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltDefaultProcessOneNode: template found for comment\\n\"));\n+                    if (cur->type == XML_PI_NODE) {\n+                        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+                     \"xsltDefaultProcessOneNode: template found for PI %s\\n\",\n+                                         cur->name));\n+                    } else if (cur->type == XML_COMMENT_NODE) {\n+                        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+                     \"xsltDefaultProcessOneNode: template found for comment\\n\"));\n@@ -2113,7 +2072,11 @@\n-            ctxt->xpathCtxt->contextSize = nbchild;\n-            ctxt->xpathCtxt->proximityPosition = childno;\n-            \/*\n-            * Instantiate the xsl:template.\n-            *\/\n-            xsltApplyXSLTTemplate(ctxt, cur, template->content,\n-            template, params);\n+                    ctxt->xpathCtxt->contextSize = nbchild;\n+                    ctxt->xpathCtxt->proximityPosition = childno;\n+                    \/*\n+                    * Instantiate the xsl:template.\n+                    *\/\n+                    xsltApplyXSLTTemplate(ctxt, cur, template->content,\n+                        template, params);\n+                }\n+                break;\n+            default:\n+                break;\n@@ -2121,5 +2084,1 @@\n-        break;\n-        default:\n-        break;\n-    }\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -2142,1 +2101,1 @@\n-               xsltStackElemPtr withParams)\n+                   xsltStackElemPtr withParams)\n@@ -2153,13 +2112,13 @@\n-    if (contextNode->type == XML_DOCUMENT_NODE) {\n-        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltProcessOneNode: no template found for \/\\n\"));\n-    } else if (contextNode->type == XML_CDATA_SECTION_NODE) {\n-        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltProcessOneNode: no template found for CDATA\\n\"));\n-    } else if (contextNode->type == XML_ATTRIBUTE_NODE) {\n-        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltProcessOneNode: no template found for attribute %s\\n\",\n-                         ((xmlAttrPtr) contextNode)->name));\n-    } else  {\n-        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltProcessOneNode: no template found for %s\\n\", contextNode->name));\n+        if (contextNode->type == XML_DOCUMENT_NODE) {\n+            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltProcessOneNode: no template found for \/\\n\"));\n+        } else if (contextNode->type == XML_CDATA_SECTION_NODE) {\n+            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltProcessOneNode: no template found for CDATA\\n\"));\n+        } else if (contextNode->type == XML_ATTRIBUTE_NODE) {\n+            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltProcessOneNode: no template found for attribute %s\\n\",\n+                             ((xmlAttrPtr) contextNode)->name));\n+        } else  {\n+            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltProcessOneNode: no template found for %s\\n\", contextNode->name));\n@@ -2168,5 +2127,5 @@\n-    oldNode = ctxt->node;\n-    ctxt->node = contextNode;\n-    xsltDefaultProcessOneNode(ctxt, contextNode, withParams);\n-    ctxt->node = oldNode;\n-    return;\n+        oldNode = ctxt->node;\n+        ctxt->node = contextNode;\n+        xsltDefaultProcessOneNode(ctxt, contextNode, withParams);\n+        ctxt->node = oldNode;\n+        return;\n@@ -2176,5 +2135,5 @@\n-    xsltTemplatePtr oldCurTempRule = ctxt->currentTemplateRule;\n-    \/*\n-    * Set the \"current template rule\".\n-    *\/\n-    ctxt->currentTemplateRule = templ;\n+        xsltTemplatePtr oldCurTempRule = ctxt->currentTemplateRule;\n+        \/*\n+        * Set the \"current template rule\".\n+        *\/\n+        ctxt->currentTemplateRule = templ;\n@@ -2183,3 +2142,3 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltProcessOneNode: applying template '%s' for attribute %s\\n\",\n-                     templ->match, contextNode->name));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltProcessOneNode: applying template '%s' for attribute %s\\n\",\n+                         templ->match, contextNode->name));\n@@ -2187,1 +2146,1 @@\n-    xsltApplyXSLTTemplate(ctxt, contextNode, templ->content, templ, withParams);\n+        xsltApplyXSLTTemplate(ctxt, contextNode, templ->content, templ, withParams);\n@@ -2189,1 +2148,1 @@\n-    ctxt->currentTemplateRule = oldCurTempRule;\n+        ctxt->currentTemplateRule = oldCurTempRule;\n@@ -2191,5 +2150,5 @@\n-    xsltTemplatePtr oldCurTempRule = ctxt->currentTemplateRule;\n-    \/*\n-    * Set the \"current template rule\".\n-    *\/\n-    ctxt->currentTemplateRule = templ;\n+        xsltTemplatePtr oldCurTempRule = ctxt->currentTemplateRule;\n+        \/*\n+        * Set the \"current template rule\".\n+        *\/\n+        ctxt->currentTemplateRule = templ;\n@@ -2198,8 +2157,8 @@\n-    if (contextNode->type == XML_DOCUMENT_NODE) {\n-        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltProcessOneNode: applying template '%s' for \/\\n\",\n-                         templ->match));\n-    } else {\n-        XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltProcessOneNode: applying template '%s' for %s\\n\",\n-                         templ->match, contextNode->name));\n+        if (contextNode->type == XML_DOCUMENT_NODE) {\n+            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltProcessOneNode: applying template '%s' for \/\\n\",\n+                             templ->match));\n+        } else {\n+            XSLT_TRACE(ctxt,XSLT_TRACE_PROCESS_NODE,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltProcessOneNode: applying template '%s' for %s\\n\",\n+                             templ->match, contextNode->name));\n@@ -2208,1 +2167,1 @@\n-    xsltApplyXSLTTemplate(ctxt, contextNode, templ->content, templ, withParams);\n+        xsltApplyXSLTTemplate(ctxt, contextNode, templ->content, templ, withParams);\n@@ -2210,1 +2169,1 @@\n-    ctxt->currentTemplateRule = oldCurTempRule;\n+        ctxt->currentTemplateRule = oldCurTempRule;\n@@ -2217,4 +2176,4 @@\n-                     xmlNodePtr contextNode,\n-                     xmlNodePtr list,\n-                     xsltTemplatePtr templ,\n-                     int *addCallResult)\n+                                     xmlNodePtr contextNode,\n+                                     xmlNodePtr list,\n+                                     xsltTemplatePtr templ,\n+                                     int *addCallResult)\n@@ -2266,2 +2225,2 @@\n-              xsltStackElemPtr variable,\n-              int level)\n+                      xsltStackElemPtr variable,\n+                      int level)\n@@ -2270,8 +2229,8 @@\n-    ctxt->varsMax = 10;\n-    ctxt->varsTab =\n-        (xsltStackElemPtr *) xmlMalloc(ctxt->varsMax *\n-        sizeof(ctxt->varsTab[0]));\n-    if (ctxt->varsTab == NULL) {\n-        xmlGenericError(xmlGenericErrorContext, \"malloc failed !\\n\");\n-        return (-1);\n-    }\n+        ctxt->varsMax = 10;\n+        ctxt->varsTab =\n+            (xsltStackElemPtr *) xmlMalloc(ctxt->varsMax *\n+            sizeof(ctxt->varsTab[0]));\n+        if (ctxt->varsTab == NULL) {\n+            xmlGenericError(xmlGenericErrorContext, \"malloc failed !\\n\");\n+            return (-1);\n+        }\n@@ -2280,9 +2239,9 @@\n-    ctxt->varsMax *= 2;\n-    ctxt->varsTab =\n-        (xsltStackElemPtr *) xmlRealloc(ctxt->varsTab,\n-        ctxt->varsMax *\n-        sizeof(ctxt->varsTab[0]));\n-    if (ctxt->varsTab == NULL) {\n-        xmlGenericError(xmlGenericErrorContext, \"realloc failed !\\n\");\n-        return (-1);\n-    }\n+        ctxt->varsMax *= 2;\n+        ctxt->varsTab =\n+            (xsltStackElemPtr *) xmlRealloc(ctxt->varsTab,\n+            ctxt->varsMax *\n+            sizeof(ctxt->varsTab[0]));\n+        if (ctxt->varsTab == NULL) {\n+            xmlGenericError(xmlGenericErrorContext, \"realloc failed !\\n\");\n+            return (-1);\n+        }\n@@ -2356,2 +2315,2 @@\n-                 xmlNodePtr contextNode, xmlNodePtr list,\n-                 xsltTemplatePtr templ)\n+                             xmlNodePtr contextNode, xmlNodePtr list,\n+                             xsltTemplatePtr templ)\n@@ -2374,1 +2333,1 @@\n-    return;\n+        return;\n@@ -2378,5 +2337,5 @@\n-    debuggedNode =\n-        xsltDebuggerStartSequenceConstructor(ctxt, contextNode,\n-        list, templ, &addCallResult);\n-    if (debuggedNode == NULL)\n-        return;\n+        debuggedNode =\n+            xsltDebuggerStartSequenceConstructor(ctxt, contextNode,\n+                list, templ, &addCallResult);\n+        if (debuggedNode == NULL)\n+            return;\n@@ -2396,1 +2355,1 @@\n-        \"xsltApplySequenceConstructor: A potential infinite template \"\n+            \"xsltApplySequenceConstructor: A potential infinite template \"\n@@ -2398,4 +2357,4 @@\n-        \"You can adjust xsltMaxDepth (--maxdepth) in order to \"\n-        \"raise the maximum number of nested template calls and \"\n-        \"variables\/params (currently set to %d).\\n\",\n-        ctxt->maxTemplateDepth);\n+            \"You can adjust xsltMaxDepth (--maxdepth) in order to \"\n+            \"raise the maximum number of nested template calls and \"\n+            \"variables\/params (currently set to %d).\\n\",\n+            ctxt->maxTemplateDepth);\n@@ -2403,1 +2362,1 @@\n-    ctxt->state = XSLT_STATE_STOPPED;\n+        ctxt->state = XSLT_STATE_STOPPED;\n@@ -2424,2 +2383,2 @@\n-        xsltTransformError(ctxt, NULL, cur,\n-            \"xsltApplySequenceConstructor: \"\n+                xsltTransformError(ctxt, NULL, cur,\n+                    \"xsltApplySequenceConstructor: \"\n@@ -2427,1 +2386,1 @@\n-            ctxt->state = XSLT_STATE_STOPPED;\n+                ctxt->state = XSLT_STATE_STOPPED;\n@@ -2450,1 +2409,1 @@\n-        \"xsltApplySequenceConstructor: insert == NULL !\\n\"));\n+                \"xsltApplySequenceConstructor: insert == NULL !\\n\"));\n@@ -2461,63 +2420,2 @@\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        info = (xsltStylePreCompPtr) cur->psvi;\n-        \/*\n-        * We expect a compiled representation on:\n-        * 1) XSLT instructions of this XSLT version (1.0)\n-        *    (with a few exceptions)\n-        * 2) Literal result elements\n-        * 3) Extension instructions\n-        * 4) XSLT instructions of future XSLT versions\n-        *    (forwards-compatible mode).\n-        *\/\n-        if (info == NULL) {\n-        \/*\n-        * Handle the rare cases where we don't expect a compiled\n-        * representation on an XSLT element.\n-        *\/\n-        if (IS_XSLT_ELEM_FAST(cur) && IS_XSLT_NAME(cur, \"message\")) {\n-            xsltMessage(ctxt, contextNode, cur);\n-            goto skip_children;\n-        }\n-        \/*\n-        * Something really went wrong:\n-        *\/\n-        xsltTransformError(ctxt, NULL, cur,\n-            \"Internal error in xsltApplySequenceConstructor(): \"\n-            \"The element '%s' in the stylesheet has no compiled \"\n-            \"representation.\\n\",\n-            cur->name);\n-                goto skip_children;\n-            }\n-\n-        if (info->type == XSLT_FUNC_LITERAL_RESULT_ELEMENT) {\n-        xsltStyleItemLRElementInfoPtr lrInfo =\n-            (xsltStyleItemLRElementInfoPtr) info;\n-        \/*\n-        * Literal result elements\n-        * --------------------------------------------------------\n-        *\/\n-#ifdef WITH_XSLT_DEBUG_PROCESS\n-        XSLT_TRACE(ctxt, XSLT_TRACE_APPLY_TEMPLATE,\n-            xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltApplySequenceConstructor: copy literal result \"\n-            \"element '%s'\\n\", cur->name));\n-#endif\n-        \/*\n-        * Copy the raw element-node.\n-        * OLD: if ((copy = xsltShallowCopyElem(ctxt, cur, insert))\n-        *     == NULL)\n-        *   goto error;\n-        *\/\n-        copy = xmlDocCopyNode(cur, insert->doc, 0);\n-        if (copy == NULL) {\n-            xsltTransformError(ctxt, NULL, cur,\n-            \"Internal error in xsltApplySequenceConstructor(): \"\n-            \"Failed to copy literal result element '%s'.\\n\",\n-            cur->name);\n-            goto error;\n-        } else {\n-            \/*\n-            * Add the element-node to the result tree.\n-            *\/\n-            copy->doc = ctxt->output;\n-            copy = xsltAddChild(insert, copy);\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            info = (xsltStylePreCompPtr) cur->psvi;\n@@ -2525,2 +2423,7 @@\n-            * Create effective namespaces declarations.\n-            * OLD: xsltCopyNamespaceList(ctxt, copy, cur->nsDef);\n+            * We expect a compiled representation on:\n+            * 1) XSLT instructions of this XSLT version (1.0)\n+            *    (with a few exceptions)\n+            * 2) Literal result elements\n+            * 3) Extension instructions\n+            * 4) XSLT instructions of future XSLT versions\n+            *    (forwards-compatible mode).\n@@ -2528,5 +2431,1 @@\n-            if (lrInfo->effectiveNs != NULL) {\n-            xsltEffectiveNsPtr effNs = lrInfo->effectiveNs;\n-            xmlNsPtr ns, lastns = NULL;\n-\n-            while (effNs != NULL) {\n+            if (info == NULL) {\n@@ -2534,3 +2433,2 @@\n-                * Avoid generating redundant namespace\n-                * declarations; thus lookup if there is already\n-                * such a ns-decl in the result.\n+                * Handle the rare cases where we don't expect a compiled\n+                * representation on an XSLT element.\n@@ -2538,6 +2436,3 @@\n-                ns = xmlSearchNs(copy->doc, copy, effNs->prefix);\n-                if ((ns != NULL) &&\n-                (xmlStrEqual(ns->href, effNs->nsName)))\n-                {\n-                effNs = effNs->next;\n-                continue;\n+                if (IS_XSLT_ELEM_FAST(cur) && IS_XSLT_NAME(cur, \"message\")) {\n+                    xsltMessage(ctxt, contextNode, cur);\n+                    goto skip_children;\n@@ -2545,2 +2440,3 @@\n-                ns = xmlNewNs(copy, effNs->nsName, effNs->prefix);\n-                if (ns == NULL) {\n+                \/*\n+                * Something really went wrong:\n+                *\/\n@@ -2548,80 +2444,5 @@\n-                    \"Internal error in \"\n-                    \"xsltApplySequenceConstructor(): \"\n-                    \"Failed to copy a namespace \"\n-                    \"declaration.\\n\");\n-                goto error;\n-                }\n-\n-                if (lastns == NULL)\n-                copy->nsDef = ns;\n-                else\n-                lastns->next =ns;\n-                lastns = ns;\n-\n-                effNs = effNs->next;\n-            }\n-\n-            }\n-            \/*\n-            * NOTE that we don't need to apply ns-alising: this was\n-            *  already done at compile-time.\n-            *\/\n-            if (cur->ns != NULL) {\n-            \/*\n-            * If there's no such ns-decl in the result tree,\n-            * then xsltGetSpecialNamespace() will\n-            * create a ns-decl on the copied node.\n-            *\/\n-            copy->ns = xsltGetSpecialNamespace(ctxt, cur,\n-                cur->ns->href, cur->ns->prefix, copy);\n-            } else {\n-            \/*\n-            * Undeclare the default namespace if needed.\n-            * This can be skipped, if the result element has\n-            *  no ns-decls, in which case the result element\n-            *  obviously does not declare a default namespace;\n-            *  AND there's either no parent, or the parent\n-            *  element is in no namespace; this means there's no\n-            *  default namespace is scope to care about.\n-            *\n-            * REVISIT: This might result in massive\n-            *  generation of ns-decls if nodes in a default\n-            *  namespaces are mixed with nodes in no namespace.\n-            *\n-            *\/\n-            if (copy->nsDef ||\n-                ((insert != NULL) &&\n-                 (insert->type == XML_ELEMENT_NODE) &&\n-                 (insert->ns != NULL)))\n-            {\n-                xsltGetSpecialNamespace(ctxt, cur,\n-                NULL, NULL, copy);\n-            }\n-            }\n-        }\n-        \/*\n-        * SPEC XSLT 2.0 \"Each attribute of the literal result\n-        *  element, other than an attribute in the XSLT namespace,\n-        *  is processed to produce an attribute for the element in\n-        *  the result tree.\"\n-        * NOTE: See bug #341325.\n-        *\/\n-        if (cur->properties != NULL) {\n-            xsltAttrListTemplateProcess(ctxt, copy, cur->properties);\n-        }\n-        } else if (IS_XSLT_ELEM_FAST(cur)) {\n-        \/*\n-        * XSLT instructions\n-        * --------------------------------------------------------\n-        *\/\n-        if (info->type == XSLT_FUNC_UNKOWN_FORWARDS_COMPAT) {\n-            \/*\n-            * We hit an unknown XSLT element.\n-            * Try to apply one of the fallback cases.\n-            *\/\n-            ctxt->insert = insert;\n-            if (!xsltApplyFallbacks(ctxt, contextNode, cur)) {\n-            xsltTransformError(ctxt, NULL, cur,\n-                \"The is no fallback behaviour defined for \"\n-                \"the unknown XSLT element '%s'.\\n\",\n-                cur->name);\n+                    \"Internal error in xsltApplySequenceConstructor(): \"\n+                    \"The element '%s' in the stylesheet has no compiled \"\n+                    \"representation.\\n\",\n+                    cur->name);\n+                goto skip_children;\n@@ -2629,6 +2450,0 @@\n-            ctxt->insert = oldInsert;\n-        } else if (info->func != NULL) {\n-            \/*\n-            * Execute the XSLT instruction.\n-            *\/\n-            ctxt->insert = insert;\n@@ -2636,2 +2451,71 @@\n-            info->func(ctxt, contextNode, cur,\n-            (xsltElemPreCompPtr) info);\n+            if (info->type == XSLT_FUNC_LITERAL_RESULT_ELEMENT) {\n+                xsltStyleItemLRElementInfoPtr lrInfo =\n+                    (xsltStyleItemLRElementInfoPtr) info;\n+                \/*\n+                * Literal result elements\n+                * --------------------------------------------------------\n+                *\/\n+#ifdef WITH_XSLT_DEBUG_PROCESS\n+                XSLT_TRACE(ctxt, XSLT_TRACE_APPLY_TEMPLATE,\n+                    xsltGenericDebug(xsltGenericDebugContext,\n+                    \"xsltApplySequenceConstructor: copy literal result \"\n+                    \"element '%s'\\n\", cur->name));\n+#endif\n+                \/*\n+                * Copy the raw element-node.\n+                * OLD: if ((copy = xsltShallowCopyElem(ctxt, cur, insert))\n+                *     == NULL)\n+                *   goto error;\n+                *\/\n+                copy = xmlDocCopyNode(cur, insert->doc, 0);\n+                if (copy == NULL) {\n+                    xsltTransformError(ctxt, NULL, cur,\n+                        \"Internal error in xsltApplySequenceConstructor(): \"\n+                        \"Failed to copy literal result element '%s'.\\n\",\n+                        cur->name);\n+                    goto error;\n+                } else {\n+                    \/*\n+                    * Add the element-node to the result tree.\n+                    *\/\n+                    copy->doc = ctxt->output;\n+                    copy = xsltAddChild(insert, copy);\n+                    \/*\n+                    * Create effective namespaces declarations.\n+                    * OLD: xsltCopyNamespaceList(ctxt, copy, cur->nsDef);\n+                    *\/\n+                    if (lrInfo->effectiveNs != NULL) {\n+                        xsltEffectiveNsPtr effNs = lrInfo->effectiveNs;\n+                        xmlNsPtr ns, lastns = NULL;\n+\n+                        while (effNs != NULL) {\n+                            \/*\n+                            * Avoid generating redundant namespace\n+                            * declarations; thus lookup if there is already\n+                            * such a ns-decl in the result.\n+                            *\/\n+                            ns = xmlSearchNs(copy->doc, copy, effNs->prefix);\n+                            if ((ns != NULL) &&\n+                                (xmlStrEqual(ns->href, effNs->nsName)))\n+                            {\n+                                effNs = effNs->next;\n+                                continue;\n+                            }\n+                            ns = xmlNewNs(copy, effNs->nsName, effNs->prefix);\n+                            if (ns == NULL) {\n+                                xsltTransformError(ctxt, NULL, cur,\n+                                    \"Internal error in \"\n+                                    \"xsltApplySequenceConstructor(): \"\n+                                    \"Failed to copy a namespace \"\n+                                    \"declaration.\\n\");\n+                                goto error;\n+                            }\n+\n+                            if (lastns == NULL)\n+                                copy->nsDef = ns;\n+                            else\n+                                lastns->next =ns;\n+                            lastns = ns;\n+\n+                            effNs = effNs->next;\n+                        }\n@@ -2639,5 +2523,71 @@\n-            \/*\n-            * Cleanup temporary tree fragments.\n-            *\/\n-            if (oldLocalFragmentTop != ctxt->localRVT)\n-            xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);\n+                    }\n+                    \/*\n+                    * NOTE that we don't need to apply ns-alising: this was\n+                    *  already done at compile-time.\n+                    *\/\n+                    if (cur->ns != NULL) {\n+                        \/*\n+                        * If there's no such ns-decl in the result tree,\n+                        * then xsltGetSpecialNamespace() will\n+                        * create a ns-decl on the copied node.\n+                        *\/\n+                        copy->ns = xsltGetSpecialNamespace(ctxt, cur,\n+                            cur->ns->href, cur->ns->prefix, copy);\n+                    } else {\n+                        \/*\n+                        * Undeclare the default namespace if needed.\n+                        * This can be skipped, if the result element has\n+                        *  no ns-decls, in which case the result element\n+                        *  obviously does not declare a default namespace;\n+                        *  AND there's either no parent, or the parent\n+                        *  element is in no namespace; this means there's no\n+                        *  default namespace is scope to care about.\n+                        *\n+                        * REVISIT: This might result in massive\n+                        *  generation of ns-decls if nodes in a default\n+                        *  namespaces are mixed with nodes in no namespace.\n+                        *\n+                        *\/\n+                        if (copy->nsDef ||\n+                            ((insert != NULL) &&\n+                             (insert->type == XML_ELEMENT_NODE) &&\n+                             (insert->ns != NULL)))\n+                        {\n+                            xsltGetSpecialNamespace(ctxt, cur,\n+                                NULL, NULL, copy);\n+                        }\n+                    }\n+                }\n+                \/*\n+                * SPEC XSLT 2.0 \"Each attribute of the literal result\n+                *  element, other than an attribute in the XSLT namespace,\n+                *  is processed to produce an attribute for the element in\n+                *  the result tree.\"\n+                * NOTE: See bug #341325.\n+                *\/\n+                if (cur->properties != NULL) {\n+                    xsltAttrListTemplateProcess(ctxt, copy, cur->properties);\n+                }\n+            } else if (IS_XSLT_ELEM_FAST(cur)) {\n+                \/*\n+                * XSLT instructions\n+                * --------------------------------------------------------\n+                *\/\n+                if (info->type == XSLT_FUNC_UNKOWN_FORWARDS_COMPAT) {\n+                    \/*\n+                    * We hit an unknown XSLT element.\n+                    * Try to apply one of the fallback cases.\n+                    *\/\n+                    ctxt->insert = insert;\n+                    if (!xsltApplyFallbacks(ctxt, contextNode, cur)) {\n+                        xsltTransformError(ctxt, NULL, cur,\n+                            \"The is no fallback behaviour defined for \"\n+                            \"the unknown XSLT element '%s'.\\n\",\n+                            cur->name);\n+                    }\n+                    ctxt->insert = oldInsert;\n+                } else if (info->func != NULL) {\n+                    \/*\n+                    * Execute the XSLT instruction.\n+                    *\/\n+                    ctxt->insert = insert;\n@@ -2645,3 +2595,2 @@\n-            ctxt->insert = oldInsert;\n-        } else if (info->type == XSLT_FUNC_VARIABLE) {\n-            xsltStackElemPtr tmpvar = ctxt->vars;\n+                    info->func(ctxt, contextNode, cur,\n+                        (xsltElemPreCompPtr) info);\n@@ -2649,1 +2598,5 @@\n-            xsltParseStylesheetVariable(ctxt, cur);\n+                    \/*\n+                    * Cleanup temporary tree fragments.\n+                    *\/\n+                    if (oldLocalFragmentTop != ctxt->localRVT)\n+                        xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);\n@@ -2651,19 +2604,25 @@\n-            if (tmpvar != ctxt->vars) {\n-            \/*\n-            * TODO: Using a @tmpvar is an annoying workaround, but\n-            *  the current mechanisms do not provide any other way\n-            *  of knowing if the var was really pushed onto the\n-            *  stack.\n-            *\/\n-            ctxt->vars->level = level;\n-            }\n-        } else if (info->type == XSLT_FUNC_MESSAGE) {\n-            \/*\n-            * TODO: Won't be hit, since we don't compile xsl:message.\n-            *\/\n-            xsltMessage(ctxt, contextNode, cur);\n-        } else {\n-            xsltTransformError(ctxt, NULL, cur,\n-            \"Unexpected XSLT element '%s'.\\n\", cur->name);\n-        }\n-        goto skip_children;\n+                    ctxt->insert = oldInsert;\n+                } else if (info->type == XSLT_FUNC_VARIABLE) {\n+                    xsltStackElemPtr tmpvar = ctxt->vars;\n+\n+                    xsltParseStylesheetVariable(ctxt, cur);\n+\n+                    if (tmpvar != ctxt->vars) {\n+                        \/*\n+                        * TODO: Using a @tmpvar is an annoying workaround, but\n+                        *  the current mechanisms do not provide any other way\n+                        *  of knowing if the var was really pushed onto the\n+                        *  stack.\n+                        *\/\n+                        ctxt->vars->level = level;\n+                    }\n+                } else if (info->type == XSLT_FUNC_MESSAGE) {\n+                    \/*\n+                    * TODO: Won't be hit, since we don't compile xsl:message.\n+                    *\/\n+                    xsltMessage(ctxt, contextNode, cur);\n+                } else {\n+                    xsltTransformError(ctxt, NULL, cur,\n+                        \"Unexpected XSLT element '%s'.\\n\", cur->name);\n+                }\n+                goto skip_children;\n@@ -2671,16 +2630,16 @@\n-        } else {\n-        xsltTransformFunction func;\n-        \/*\n-        * Extension intructions (elements)\n-        * --------------------------------------------------------\n-        *\/\n-        if (cur->psvi == xsltExtMarker) {\n-            \/*\n-            * The xsltExtMarker was set during the compilation\n-            * of extension instructions if there was no registered\n-            * handler for this specific extension function at\n-            * compile-time.\n-            * Libxslt will now lookup if a handler is\n-            * registered in the context of this transformation.\n-            *\/\n-            func = xsltExtElementLookup(ctxt, cur->name,\n+            } else {\n+                xsltTransformFunction func;\n+                \/*\n+                * Extension intructions (elements)\n+                * --------------------------------------------------------\n+                *\/\n+                if (cur->psvi == xsltExtMarker) {\n+                    \/*\n+                    * The xsltExtMarker was set during the compilation\n+                    * of extension instructions if there was no registered\n+                    * handler for this specific extension function at\n+                    * compile-time.\n+                    * Libxslt will now lookup if a handler is\n+                    * registered in the context of this transformation.\n+                    *\/\n+                    func = xsltExtElementLookup(ctxt, cur->name,\n@@ -2688,2 +2647,2 @@\n-        } else\n-            func = ((xsltElemPreCompPtr) cur->psvi)->func;\n+                } else\n+                    func = ((xsltElemPreCompPtr) cur->psvi)->func;\n@@ -2691,5 +2650,5 @@\n-        if (func == NULL) {\n-            \/*\n-            * No handler available.\n-            * Try to execute fallback behaviour via xsl:fallback.\n-            *\/\n+                if (func == NULL) {\n+                    \/*\n+                    * No handler available.\n+                    * Try to execute fallback behaviour via xsl:fallback.\n+                    *\/\n@@ -2697,4 +2656,4 @@\n-            XSLT_TRACE(ctxt, XSLT_TRACE_APPLY_TEMPLATE,\n-            xsltGenericDebug(xsltGenericDebugContext,\n-                \"xsltApplySequenceConstructor: unknown extension %s\\n\",\n-                cur->name));\n+                    XSLT_TRACE(ctxt, XSLT_TRACE_APPLY_TEMPLATE,\n+                        xsltGenericDebug(xsltGenericDebugContext,\n+                            \"xsltApplySequenceConstructor: unknown extension %s\\n\",\n+                            cur->name));\n@@ -2702,11 +2661,11 @@\n-            ctxt->insert = insert;\n-            if (!xsltApplyFallbacks(ctxt, contextNode, cur)) {\n-            xsltTransformError(ctxt, NULL, cur,\n-                \"Unknown extension instruction '{%s}%s'.\\n\",\n-                cur->ns->href, cur->name);\n-            }\n-            ctxt->insert = oldInsert;\n-        } else {\n-            \/*\n-            * Execute the handler-callback.\n-            *\/\n+                    ctxt->insert = insert;\n+                    if (!xsltApplyFallbacks(ctxt, contextNode, cur)) {\n+                        xsltTransformError(ctxt, NULL, cur,\n+                            \"Unknown extension instruction '{%s}%s'.\\n\",\n+                            cur->ns->href, cur->name);\n+                    }\n+                    ctxt->insert = oldInsert;\n+                } else {\n+                    \/*\n+                    * Execute the handler-callback.\n+                    *\/\n@@ -2714,3 +2673,3 @@\n-            XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltApplySequenceConstructor: extension construct %s\\n\",\n-            cur->name));\n+                    XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,\n+                        \"xsltApplySequenceConstructor: extension construct %s\\n\",\n+                        cur->name));\n@@ -2730,1 +2689,1 @@\n-            ctxt->insert = insert;\n+                    ctxt->insert = insert;\n@@ -2732,1 +2691,1 @@\n-            func(ctxt, contextNode, cur, cur->psvi);\n+                    func(ctxt, contextNode, cur, cur->psvi);\n@@ -2734,5 +2693,5 @@\n-            \/*\n-            * Cleanup temporary tree fragments.\n-            *\/\n-            if (oldLocalFragmentTop != ctxt->localRVT)\n-            xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);\n+                    \/*\n+                    * Cleanup temporary tree fragments.\n+                    *\/\n+                    if (oldLocalFragmentTop != ctxt->localRVT)\n+                        xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);\n@@ -2740,4 +2699,4 @@\n-            ctxt->insert = oldInsert;\n-        }\n-        goto skip_children;\n-        }\n+                    ctxt->insert = oldInsert;\n+                }\n+                goto skip_children;\n+            }\n@@ -2745,5 +2704,5 @@\n-    } else if (XSLT_IS_TEXT_NODE(cur)) {\n-        \/*\n-        * Text\n-        * ------------------------------------------------------------\n-        *\/\n+        } else if (XSLT_IS_TEXT_NODE(cur)) {\n+            \/*\n+            * Text\n+            * ------------------------------------------------------------\n+            *\/\n@@ -2753,3 +2712,3 @@\n-            xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltApplySequenceConstructor: copy unescaped text '%s'\\n\",\n-            cur->content));\n+                    xsltGenericDebug(xsltGenericDebugContext,\n+                    \"xsltApplySequenceConstructor: copy unescaped text '%s'\\n\",\n+                    cur->content));\n@@ -2758,3 +2717,3 @@\n-            xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltApplySequenceConstructor: copy text '%s'\\n\",\n-            cur->content));\n+                    xsltGenericDebug(xsltGenericDebugContext,\n+                    \"xsltApplySequenceConstructor: copy text '%s'\\n\",\n+                    cur->content));\n@@ -2764,2 +2723,2 @@\n-        goto error;\n-    }\n+                goto error;\n+        }\n@@ -2785,2 +2744,2 @@\n-                \"xsltApplySequenceConstructor: %s was not compiled\\n\",\n-                cur->name);\n+                            \"xsltApplySequenceConstructor: %s was not compiled\\n\",\n+                            cur->name);\n@@ -2794,2 +2753,2 @@\n-        oldCurInst = ctxt->inst;\n-        ctxt->inst = cur;\n+                oldCurInst = ctxt->inst;\n+                ctxt->inst = cur;\n@@ -2800,5 +2759,5 @@\n-        \/*\n-        * Cleanup temporary tree fragments.\n-        *\/\n-        if (oldLocalFragmentTop != ctxt->localRVT)\n-            xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);\n+                \/*\n+                * Cleanup temporary tree fragments.\n+                *\/\n+                if (oldLocalFragmentTop != ctxt->localRVT)\n+                    xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);\n@@ -2807,1 +2766,1 @@\n-        ctxt->inst = oldCurInst;\n+                ctxt->inst = oldCurInst;\n@@ -2812,1 +2771,1 @@\n-        xsltStackElemPtr tmpvar = ctxt->vars;\n+                xsltStackElemPtr tmpvar = ctxt->vars;\n@@ -2814,2 +2773,2 @@\n-        oldCurInst = ctxt->inst;\n-        ctxt->inst = cur;\n+                oldCurInst = ctxt->inst;\n+                ctxt->inst = cur;\n@@ -2817,1 +2776,1 @@\n-        xsltParseStylesheetVariable(ctxt, cur);\n+                xsltParseStylesheetVariable(ctxt, cur);\n@@ -2819,1 +2778,1 @@\n-        ctxt->inst = oldCurInst;\n+                ctxt->inst = oldCurInst;\n@@ -2821,9 +2780,9 @@\n-        if (tmpvar != ctxt->vars) {\n-            \/*\n-            * TODO: Using a @tmpvar is an annoying workaround, but\n-            *  the current mechanisms do not provide any other way\n-            *  of knowing if the var was really pushed onto the\n-            *  stack.\n-            *\/\n-            ctxt->vars->level = level;\n-        }\n+                if (tmpvar != ctxt->vars) {\n+                    \/*\n+                    * TODO: Using a @tmpvar is an annoying workaround, but\n+                    *  the current mechanisms do not provide any other way\n+                    *  of knowing if the var was really pushed onto the\n+                    *  stack.\n+                    *\/\n+                    ctxt->vars->level = level;\n+                }\n@@ -2833,2 +2792,2 @@\n-        xsltTransformError(ctxt, NULL, cur,\n-            \"Unexpected XSLT element '%s'.\\n\", cur->name);\n+                xsltTransformError(ctxt, NULL, cur,\n+                    \"Unexpected XSLT element '%s'.\\n\", cur->name);\n@@ -2861,1 +2820,1 @@\n-        goto error;\n+                goto error;\n@@ -2866,2 +2825,2 @@\n-        oldCurInst = ctxt->inst;\n-        ctxt->inst = cur;\n+            oldCurInst = ctxt->inst;\n+            ctxt->inst = cur;\n@@ -2883,1 +2842,1 @@\n-            \"xsltApplySequenceConstructor: unknown extension %s\\n\",\n+                    \"xsltApplySequenceConstructor: unknown extension %s\\n\",\n@@ -2894,1 +2853,1 @@\n-            {\n+                    {\n@@ -2897,1 +2856,1 @@\n-                child->children, NULL);\n+                            child->children, NULL);\n@@ -2905,2 +2864,2 @@\n-            \"xsltApplySequenceConstructor: failed to find extension %s\\n\",\n-            cur->name);\n+                        \"xsltApplySequenceConstructor: failed to find extension %s\\n\",\n+                        cur->name);\n@@ -2911,1 +2870,1 @@\n-            \"xsltApplySequenceConstructor: extension construct %s\\n\",\n+                    \"xsltApplySequenceConstructor: extension construct %s\\n\",\n@@ -2924,1 +2883,1 @@\n-                ctxt->lasttext = NULL;\n+                    ctxt->lasttext = NULL;\n@@ -2930,5 +2889,5 @@\n-        \/*\n-        * Cleanup temporary tree fragments.\n-        *\/\n-        if (oldLocalFragmentTop != ctxt->localRVT)\n-            xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);\n+                \/*\n+                * Cleanup temporary tree fragments.\n+                *\/\n+                if (oldLocalFragmentTop != ctxt->localRVT)\n+                    xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);\n@@ -2939,1 +2898,1 @@\n-        ctxt->inst = oldCurInst;\n+            ctxt->inst = oldCurInst;\n@@ -2944,1 +2903,1 @@\n-        \"xsltApplySequenceConstructor: copy node %s\\n\",\n+                \"xsltApplySequenceConstructor: copy node %s\\n\",\n@@ -2947,2 +2906,2 @@\n-        oldCurInst = ctxt->inst;\n-        ctxt->inst = cur;\n+            oldCurInst = ctxt->inst;\n+            ctxt->inst = cur;\n@@ -2951,1 +2910,1 @@\n-        goto error;\n+                goto error;\n@@ -2955,1 +2914,1 @@\n-         * \"real\" template.\n+             * \"real\" template.\n@@ -2963,2 +2922,2 @@\n-            const xmlChar *URI = NULL;\n-            xsltStylesheetPtr style;\n+                    const xmlChar *URI = NULL;\n+                    xsltStylesheetPtr style;\n@@ -2967,3 +2926,3 @@\n-            \/* Note that the XSLT namespace was already excluded\n-            * in xsltGetInheritedNsList().\n-            *\/\n+                    \/* Note that the XSLT namespace was already excluded\n+                    * in xsltGetInheritedNsList().\n+                    *\/\n@@ -2971,26 +2930,32 @@\n-            if (xmlStrEqual(ns->href, XSLT_NAMESPACE))\n-            continue;\n-#endif\n-            style = ctxt->style;\n-            while (style != NULL) {\n-            if (style->nsAliases != NULL)\n-                URI = (const xmlChar *)\n-                xmlHashLookup(style->nsAliases, ns->href);\n-            if (URI != NULL)\n-                break;\n-\n-            style = xsltNextImport(style);\n-            }\n-            if (URI == UNDEFINED_DEFAULT_NS)\n-            continue;\n-            if (URI == NULL)\n-            URI = ns->href;\n-            \/*\n-            * TODO: The following will still be buggy for the\n-            * non-refactored code.\n-            *\/\n-            ret = xmlSearchNs(copy->doc, copy, ns->prefix);\n-            if ((ret == NULL) || (!xmlStrEqual(ret->href, URI)))\n-            {\n-            xmlNewNs(copy, URI, ns->prefix);\n-            }\n+                    if (xmlStrEqual(ns->href, XSLT_NAMESPACE))\n+                        continue;\n+#endif\n+                    style = ctxt->style;\n+                    while (style != NULL) {\n+                        if (style->nsAliases != NULL)\n+                            URI = (const xmlChar *)\n+                                xmlHashLookup(style->nsAliases, ns->href);\n+                        if (URI != NULL)\n+                            break;\n+\n+                        style = xsltNextImport(style);\n+                    }\n+                    if (URI == UNDEFINED_DEFAULT_NS)\n+                        continue;\n+                    if (URI == NULL)\n+                        URI = ns->href;\n+                    \/*\n+                    * TODO: The following will still be buggy for the\n+                    * non-refactored code.\n+                    *\/\n+                    ret = xmlSearchNs(copy->doc, copy, ns->prefix);\n+                    if ((ret == NULL) || (!xmlStrEqual(ret->href, URI)))\n+                    {\n+                        xmlNewNs(copy, URI, ns->prefix);\n+                    }\n+                }\n+                if (copy->ns != NULL) {\n+                    \/*\n+                     * Fix the node namespace if needed\n+                     *\/\n+                    copy->ns = xsltGetNamespace(ctxt, cur, copy->ns, copy);\n@@ -2998,6 +2963,0 @@\n-        if (copy->ns != NULL) {\n-            \/*\n-             * Fix the node namespace if needed\n-             *\/\n-            copy->ns = xsltGetNamespace(ctxt, cur, copy->ns, copy);\n-        }\n@@ -3005,1 +2964,1 @@\n-        \/*\n+            \/*\n@@ -3011,1 +2970,1 @@\n-        ctxt->inst = oldCurInst;\n+            ctxt->inst = oldCurInst;\n@@ -3021,1 +2980,1 @@\n-        level++;\n+                level++;\n@@ -3029,8 +2988,8 @@\n-    \/*\n-    * If xslt:message was just processed, we might have hit a\n-    * terminate='yes'; if so, then break the loop and clean up.\n-    * TODO: Do we need to check this also before trying to descend\n-    *  into the content?\n-    *\/\n-    if (ctxt->state == XSLT_STATE_STOPPED)\n-        break;\n+        \/*\n+        * If xslt:message was just processed, we might have hit a\n+        * terminate='yes'; if so, then break the loop and clean up.\n+        * TODO: Do we need to check this also before trying to descend\n+        *  into the content?\n+        *\/\n+        if (ctxt->state == XSLT_STATE_STOPPED)\n+            break;\n@@ -3044,7 +3003,7 @@\n-        level--;\n-        \/*\n-        * Pop variables\/params (xsl:variable and xsl:param).\n-        *\/\n-        if ((ctxt->varsNr > oldVarsNr) && (ctxt->vars->level > level)) {\n-        xsltLocalVariablePop(ctxt, oldVarsNr, level);\n-        }\n+            level--;\n+            \/*\n+            * Pop variables\/params (xsl:variable and xsl:param).\n+            *\/\n+            if ((ctxt->varsNr > oldVarsNr) && (ctxt->vars->level > level)) {\n+                xsltLocalVariablePop(ctxt, oldVarsNr, level);\n+            }\n@@ -3071,1 +3030,1 @@\n-    xsltLocalVariablePop(ctxt, oldVarsNr, -1);\n+        xsltLocalVariablePop(ctxt, oldVarsNr, -1);\n@@ -3104,4 +3063,4 @@\n-              xmlNodePtr contextNode,\n-              xmlNodePtr list,\n-              xsltTemplatePtr templ,\n-              xsltStackElemPtr withParams)\n+                      xmlNodePtr contextNode,\n+                      xmlNodePtr list,\n+                      xsltTemplatePtr templ,\n+                      xsltStackElemPtr withParams)\n@@ -3128,1 +3087,1 @@\n-    return;\n+        return;\n@@ -3130,3 +3089,3 @@\n-    xsltTransformError(ctxt, NULL, list,\n-        \"xsltApplyXSLTTemplate: Bad arguments; @templ is mandatory.\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, list,\n+            \"xsltApplyXSLTTemplate: Bad arguments; @templ is mandatory.\\n\");\n+        return;\n@@ -3137,3 +3096,3 @@\n-    if (xsltDebuggerStartSequenceConstructor(ctxt, contextNode,\n-        list, templ, &addCallResult) == NULL)\n-        return;\n+        if (xsltDebuggerStartSequenceConstructor(ctxt, contextNode,\n+                list, templ, &addCallResult) == NULL)\n+            return;\n@@ -3148,1 +3107,1 @@\n-    {\n+        {\n@@ -3150,5 +3109,5 @@\n-        \"xsltApplyXSLTTemplate: A potential infinite template recursion \"\n-        \"was detected.\\n\"\n-        \"You can adjust maxTemplateVars (--maxvars) in order to \"\n-        \"raise the maximum number of variables\/params (currently set to %d).\\n\",\n-        ctxt->maxTemplateVars);\n+            \"xsltApplyXSLTTemplate: A potential infinite template recursion \"\n+            \"was detected.\\n\"\n+            \"You can adjust maxTemplateVars (--maxvars) in order to \"\n+            \"raise the maximum number of variables\/params (currently set to %d).\\n\",\n+            ctxt->maxTemplateVars);\n@@ -3156,1 +3115,1 @@\n-    ctxt->state = XSLT_STATE_STOPPED;\n+        ctxt->state = XSLT_STATE_STOPPED;\n@@ -3158,1 +3117,1 @@\n-    }\n+        }\n@@ -3173,4 +3132,4 @@\n-    templ->nbCalls++;\n-    start = xsltTimestamp();\n-    profPush(ctxt, 0);\n-    profCallgraphAdd(templ, ctxt->templ);\n+        templ->nbCalls++;\n+        start = xsltTimestamp();\n+        profPush(ctxt, 0);\n+        profCallgraphAdd(templ, ctxt->templ);\n@@ -3187,2 +3146,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,\n-    \"applying xsl:template '%s'\\n\", templ->name));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,\n+        \"applying xsl:template '%s'\\n\", templ->name));\n@@ -3196,12 +3155,12 @@\n-    if (cur->type == XML_TEXT_NODE) {\n-        cur = cur->next;\n-        continue;\n-    }\n-    if ((cur->type != XML_ELEMENT_NODE) ||\n-        (cur->name[0] != 'p') ||\n-        (cur->psvi == NULL) ||\n-        (! xmlStrEqual(cur->name, BAD_CAST \"param\")) ||\n-        (! IS_XSLT_ELEM(cur)))\n-    {\n-        break;\n-    }\n+        if (cur->type == XML_TEXT_NODE) {\n+            cur = cur->next;\n+            continue;\n+        }\n+        if ((cur->type != XML_ELEMENT_NODE) ||\n+            (cur->name[0] != 'p') ||\n+            (cur->psvi == NULL) ||\n+            (! xmlStrEqual(cur->name, BAD_CAST \"param\")) ||\n+            (! IS_XSLT_ELEM(cur)))\n+        {\n+            break;\n+        }\n@@ -3209,1 +3168,1 @@\n-    list = cur->next;\n+        list = cur->next;\n@@ -3212,1 +3171,1 @@\n-    iparam = (xsltStyleItemParamPtr) cur->psvi;\n+        iparam = (xsltStyleItemParamPtr) cur->psvi;\n@@ -3214,1 +3173,1 @@\n-    iparam = (xsltStylePreCompPtr) cur->psvi;\n+        iparam = (xsltStylePreCompPtr) cur->psvi;\n@@ -3217,28 +3176,0 @@\n-    \/*\n-    * Substitute xsl:param for a given xsl:with-param.\n-    * Since the XPath expression will reference the params\/vars\n-    * by index, we need to slot the xsl:with-params in the\n-    * order of encountered xsl:params to keep the sequence of\n-    * params\/variables in the stack exactly as it was at\n-    * compile time,\n-    *\/\n-    tmpParam = NULL;\n-    if (withParams) {\n-        tmpParam = withParams;\n-        do {\n-        if ((tmpParam->name == (iparam->name)) &&\n-            (tmpParam->nameURI == (iparam->ns)))\n-        {\n-            \/*\n-            * Push the caller-parameter.\n-            *\/\n-            xsltLocalVariablePush(ctxt, tmpParam, -1);\n-            break;\n-        }\n-        tmpParam = tmpParam->next;\n-        } while (tmpParam != NULL);\n-    }\n-    \/*\n-    * Push the xsl:param.\n-    *\/\n-    if (tmpParam == NULL) {\n@@ -3246,2 +3177,6 @@\n-        * Note that we must assume that the added parameter\n-        * has a @depth of 0.\n+        * Substitute xsl:param for a given xsl:with-param.\n+        * Since the XPath expression will reference the params\/vars\n+        * by index, we need to slot the xsl:with-params in the\n+        * order of encountered xsl:params to keep the sequence of\n+        * params\/variables in the stack exactly as it was at\n+        * compile time,\n@@ -3249,3 +3184,27 @@\n-        xsltParseStylesheetParam(ctxt, cur);\n-    }\n-    cur = cur->next;\n+        tmpParam = NULL;\n+        if (withParams) {\n+            tmpParam = withParams;\n+            do {\n+                if ((tmpParam->name == (iparam->name)) &&\n+                    (tmpParam->nameURI == (iparam->ns)))\n+                {\n+                    \/*\n+                    * Push the caller-parameter.\n+                    *\/\n+                    xsltLocalVariablePush(ctxt, tmpParam, -1);\n+                    break;\n+                }\n+                tmpParam = tmpParam->next;\n+            } while (tmpParam != NULL);\n+        }\n+        \/*\n+        * Push the xsl:param.\n+        *\/\n+        if (tmpParam == NULL) {\n+            \/*\n+            * Note that we must assume that the added parameter\n+            * has a @depth of 0.\n+            *\/\n+            xsltParseStylesheetParam(ctxt, cur);\n+        }\n+        cur = cur->next;\n@@ -3263,1 +3222,1 @@\n-    xsltTemplateParamsCleanup(ctxt);\n+        xsltTemplateParamsCleanup(ctxt);\n@@ -3273,1 +3232,1 @@\n-    xmlDocPtr curdoc = ctxt->tmpRVT, tmp;\n+        xmlDocPtr curdoc = ctxt->tmpRVT, tmp;\n@@ -3275,5 +3234,5 @@\n-    while (curdoc != NULL) {\n-        tmp = curdoc;\n-        curdoc = (xmlDocPtr) curdoc->next;\n-        xsltReleaseRVT(ctxt, tmp);\n-    }\n+        while (curdoc != NULL) {\n+            tmp = curdoc;\n+            curdoc = (xmlDocPtr) curdoc->next;\n+            xsltReleaseRVT(ctxt, tmp);\n+        }\n@@ -3290,1 +3249,1 @@\n-    long spent, child, total, end;\n+        long spent, child, total, end;\n@@ -3292,12 +3251,12 @@\n-    end = xsltTimestamp();\n-    child = profPop(ctxt);\n-    total = end - start;\n-    spent = total - child;\n-    if (spent <= 0) {\n-        \/*\n-        * Not possible unless the original calibration failed\n-        * we can try to correct it on the fly.\n-        *\/\n-        xsltCalibrateAdjust(spent);\n-        spent = 0;\n-    }\n+        end = xsltTimestamp();\n+        child = profPop(ctxt);\n+        total = end - start;\n+        spent = total - child;\n+        if (spent <= 0) {\n+            \/*\n+            * Not possible unless the original calibration failed\n+            * we can try to correct it on the fly.\n+            *\/\n+            xsltCalibrateAdjust(spent);\n+            spent = 0;\n+        }\n@@ -3305,3 +3264,3 @@\n-    templ->time += spent;\n-    if (ctxt->profNr > 0)\n-        ctxt->profTab[ctxt->profNr - 1] += total;\n+        templ->time += spent;\n+        if (ctxt->profNr > 0)\n+            ctxt->profTab[ctxt->profNr - 1] += total;\n@@ -3351,1 +3310,1 @@\n-             xmlNodePtr contextNode,\n+                     xmlNodePtr contextNode,\n@@ -3353,1 +3312,1 @@\n-             xsltTemplatePtr templ ATTRIBUTE_UNUSED,\n+                     xsltTemplatePtr templ ATTRIBUTE_UNUSED,\n@@ -3357,1 +3316,1 @@\n-    return;\n+        return;\n@@ -3361,6 +3320,6 @@\n-    \/*\n-     * This code should be obsolete - was previously used\n-     * by libexslt\/functions.c, but due to bug 381319 the\n-     * logic there was changed.\n-     *\/\n-    int oldVarsNr = ctxt->varsNr;\n+        \/*\n+         * This code should be obsolete - was previously used\n+         * by libexslt\/functions.c, but due to bug 381319 the\n+         * logic there was changed.\n+         *\/\n+        int oldVarsNr = ctxt->varsNr;\n@@ -3368,12 +3327,12 @@\n-    \/*\n-    * Push the given xsl:param(s) onto the variable stack.\n-    *\/\n-    while (params != NULL) {\n-        xsltLocalVariablePush(ctxt, params, -1);\n-        params = params->next;\n-    }\n-    xsltApplySequenceConstructor(ctxt, contextNode, list, templ);\n-    \/*\n-    * Pop the given xsl:param(s) from the stack but don't free them.\n-    *\/\n-    xsltLocalVariablePop(ctxt, oldVarsNr, -2);\n+        \/*\n+        * Push the given xsl:param(s) onto the variable stack.\n+        *\/\n+        while (params != NULL) {\n+            xsltLocalVariablePush(ctxt, params, -1);\n+            params = params->next;\n+        }\n+        xsltApplySequenceConstructor(ctxt, contextNode, list, templ);\n+        \/*\n+        * Pop the given xsl:param(s) from the stack but don't free them.\n+        *\/\n+        xsltLocalVariablePop(ctxt, oldVarsNr, -2);\n@@ -3381,1 +3340,1 @@\n-    xsltApplySequenceConstructor(ctxt, contextNode, list, templ);\n+        xsltApplySequenceConstructor(ctxt, contextNode, list, templ);\n@@ -3385,3 +3344,3 @@\n- *                                  *\n- *          XSLT-1.1 extensions                 *\n- *                                  *\n+ *                                                                      *\n+ *                  XSLT-1.1 extensions                                 *\n+ *                                                                      *\n@@ -3431,5 +3390,5 @@\n-        \/*\n-        * The element \"output\" is in the namespace XSLT_SAXON_NAMESPACE\n-        *   (http:\/\/icl.com\/saxon)\n-        * The @file is in no namespace.\n-        *\/\n+            \/*\n+            * The element \"output\" is in the namespace XSLT_SAXON_NAMESPACE\n+            *   (http:\/\/icl.com\/saxon)\n+            * The @file is in no namespace.\n+            *\/\n@@ -3444,2 +3403,2 @@\n-        if (URL == NULL)\n-        URL = xsltEvalAttrValueTemplate(ctxt, inst,\n+            if (URL == NULL)\n+                URL = xsltEvalAttrValueTemplate(ctxt, inst,\n@@ -3457,3 +3416,3 @@\n-        if (URL != NULL) {\n-        xmlXPathCompExprPtr cmp;\n-        xmlChar *val;\n+            if (URL != NULL) {\n+                xmlXPathCompExprPtr cmp;\n+                xmlChar *val;\n@@ -3461,7 +3420,7 @@\n-        \/*\n-         * Trying to handle bug #59212\n-         * The value of the \"select\" attribute is an\n-         * XPath expression.\n-         * (see http:\/\/xml.apache.org\/xalan-j\/extensionslib.html#redirect)\n-         *\/\n-        cmp = xmlXPathCtxtCompile(ctxt->xpathCtxt, URL);\n+                \/*\n+                 * Trying to handle bug #59212\n+                 * The value of the \"select\" attribute is an\n+                 * XPath expression.\n+                 * (see http:\/\/xml.apache.org\/xalan-j\/extensionslib.html#redirect)\n+                 *\/\n+                cmp = xmlXPathCtxtCompile(ctxt->xpathCtxt, URL);\n@@ -3469,14 +3428,14 @@\n-        xmlXPathFreeCompExpr(cmp);\n-        xmlFree(URL);\n-        URL = val;\n-        }\n-        if (URL == NULL)\n-        URL = xsltEvalAttrValueTemplate(ctxt, inst,\n-                             (const xmlChar *)\n-                             \"file\",\n-                             XSLT_XALAN_NAMESPACE);\n-        if (URL == NULL)\n-        URL = xsltEvalAttrValueTemplate(ctxt, inst,\n-                             (const xmlChar *)\n-                             \"href\",\n-                             XSLT_XALAN_NAMESPACE);\n+                xmlXPathFreeCompExpr(cmp);\n+                xmlFree(URL);\n+                URL = val;\n+            }\n+            if (URL == NULL)\n+                URL = xsltEvalAttrValueTemplate(ctxt, inst,\n+                                                     (const xmlChar *)\n+                                                     \"file\",\n+                                                     XSLT_XALAN_NAMESPACE);\n+            if (URL == NULL)\n+                URL = xsltEvalAttrValueTemplate(ctxt, inst,\n+                                                     (const xmlChar *)\n+                                                     \"href\",\n+                                                     XSLT_XALAN_NAMESPACE);\n@@ -3494,3 +3453,3 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-                 \"xsltDocumentElem: href\/URI-Reference not found\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+                         \"xsltDocumentElem: href\/URI-Reference not found\\n\");\n+        return;\n@@ -3504,1 +3463,1 @@\n-    xmlChar *escURL;\n+        xmlChar *escURL;\n@@ -3506,5 +3465,5 @@\n-    escURL=xmlURIEscapeStr(URL, BAD_CAST \":\/.?,\");\n-    if (escURL != NULL) {\n-        filename = xmlBuildURI(escURL, (const xmlChar *) ctxt->outputFile);\n-        xmlFree(escURL);\n-    }\n+        escURL=xmlURIEscapeStr(URL, BAD_CAST \":\/.?,\");\n+        if (escURL != NULL) {\n+            filename = xmlBuildURI(escURL, (const xmlChar *) ctxt->outputFile);\n+            xmlFree(escURL);\n+        }\n@@ -3514,5 +3473,5 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-                 \"xsltDocumentElem: URL computation failed for %s\\n\",\n-             URL);\n-    xmlFree(URL);\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+                         \"xsltDocumentElem: URL computation failed for %s\\n\",\n+                         URL);\n+        xmlFree(URL);\n+        return;\n@@ -3525,2 +3484,2 @@\n-    ret = xsltCheckWrite(ctxt->sec, ctxt, filename);\n-    if (ret <= 0) {\n+        ret = xsltCheckWrite(ctxt->sec, ctxt, filename);\n+        if (ret <= 0) {\n@@ -3531,4 +3490,4 @@\n-        xmlFree(URL);\n-        xmlFree(filename);\n-        return;\n-    }\n+            xmlFree(URL);\n+            xmlFree(filename);\n+            return;\n+        }\n@@ -3545,1 +3504,1 @@\n-    xsltTransformError(ctxt, NULL, inst,\n+        xsltTransformError(ctxt, NULL, inst,\n@@ -3555,2 +3514,2 @@\n-                     (const xmlChar *) \"version\",\n-                     NULL);\n+                                     (const xmlChar *) \"version\",\n+                                     NULL);\n@@ -3558,3 +3517,3 @@\n-    if (style->version != NULL)\n-        xmlFree(style->version);\n-    style->version = prop;\n+        if (style->version != NULL)\n+            xmlFree(style->version);\n+        style->version = prop;\n@@ -3563,2 +3522,2 @@\n-                     (const xmlChar *) \"encoding\",\n-                     NULL);\n+                                     (const xmlChar *) \"encoding\",\n+                                     NULL);\n@@ -3566,3 +3525,3 @@\n-    if (style->encoding != NULL)\n-        xmlFree(style->encoding);\n-    style->encoding = prop;\n+        if (style->encoding != NULL)\n+            xmlFree(style->encoding);\n+        style->encoding = prop;\n@@ -3571,2 +3530,2 @@\n-                     (const xmlChar *) \"method\",\n-                     NULL);\n+                                     (const xmlChar *) \"method\",\n+                                     NULL);\n@@ -3574,17 +3533,22 @@\n-    const xmlChar *URI;\n-\n-    if (style->method != NULL)\n-        xmlFree(style->method);\n-    style->method = NULL;\n-    if (style->methodURI != NULL)\n-        xmlFree(style->methodURI);\n-    style->methodURI = NULL;\n-\n-    URI = xsltGetQNameURI(inst, &prop);\n-    if (prop == NULL) {\n-        if (style != NULL) style->errors++;\n-    } else if (URI == NULL) {\n-        if ((xmlStrEqual(prop, (const xmlChar *) \"xml\")) ||\n-        (xmlStrEqual(prop, (const xmlChar *) \"html\")) ||\n-        (xmlStrEqual(prop, (const xmlChar *) \"text\"))) {\n-        style->method = prop;\n+        const xmlChar *URI;\n+\n+        if (style->method != NULL)\n+            xmlFree(style->method);\n+        style->method = NULL;\n+        if (style->methodURI != NULL)\n+            xmlFree(style->methodURI);\n+        style->methodURI = NULL;\n+\n+        URI = xsltGetQNameURI(inst, &prop);\n+        if (prop == NULL) {\n+            if (style != NULL) style->errors++;\n+        } else if (URI == NULL) {\n+            if ((xmlStrEqual(prop, (const xmlChar *) \"xml\")) ||\n+                (xmlStrEqual(prop, (const xmlChar *) \"html\")) ||\n+                (xmlStrEqual(prop, (const xmlChar *) \"text\"))) {\n+                style->method = prop;\n+            } else {\n+                xsltTransformError(ctxt, NULL, inst,\n+                                 \"invalid value for method: %s\\n\", prop);\n+                if (style != NULL) style->warnings++;\n+            }\n@@ -3592,3 +3556,2 @@\n-        xsltTransformError(ctxt, NULL, inst,\n-                 \"invalid value for method: %s\\n\", prop);\n-        if (style != NULL) style->warnings++;\n+            style->method = prop;\n+            style->methodURI = xmlStrdup(URI);\n@@ -3596,4 +3559,0 @@\n-    } else {\n-        style->method = prop;\n-        style->methodURI = xmlStrdup(URI);\n-    }\n@@ -3602,2 +3561,2 @@\n-                     (const xmlChar *)\n-                     \"doctype-system\", NULL);\n+                                     (const xmlChar *)\n+                                     \"doctype-system\", NULL);\n@@ -3605,3 +3564,3 @@\n-    if (style->doctypeSystem != NULL)\n-        xmlFree(style->doctypeSystem);\n-    style->doctypeSystem = prop;\n+        if (style->doctypeSystem != NULL)\n+            xmlFree(style->doctypeSystem);\n+        style->doctypeSystem = prop;\n@@ -3610,2 +3569,2 @@\n-                     (const xmlChar *)\n-                     \"doctype-public\", NULL);\n+                                     (const xmlChar *)\n+                                     \"doctype-public\", NULL);\n@@ -3613,3 +3572,3 @@\n-    if (style->doctypePublic != NULL)\n-        xmlFree(style->doctypePublic);\n-    style->doctypePublic = prop;\n+        if (style->doctypePublic != NULL)\n+            xmlFree(style->doctypePublic);\n+        style->doctypePublic = prop;\n@@ -3618,2 +3577,2 @@\n-                     (const xmlChar *) \"standalone\",\n-                     NULL);\n+                                     (const xmlChar *) \"standalone\",\n+                                     NULL);\n@@ -3621,11 +3580,11 @@\n-    if (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n-        style->standalone = 1;\n-    } else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n-        style->standalone = 0;\n-    } else {\n-        xsltTransformError(ctxt, NULL, inst,\n-                 \"invalid value for standalone: %s\\n\",\n-                 prop);\n-        if (style != NULL) style->warnings++;\n-    }\n-    xmlFree(prop);\n+        if (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n+            style->standalone = 1;\n+        } else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n+            style->standalone = 0;\n+        } else {\n+            xsltTransformError(ctxt, NULL, inst,\n+                             \"invalid value for standalone: %s\\n\",\n+                             prop);\n+            if (style != NULL) style->warnings++;\n+        }\n+        xmlFree(prop);\n@@ -3635,2 +3594,2 @@\n-                     (const xmlChar *) \"indent\",\n-                     NULL);\n+                                     (const xmlChar *) \"indent\",\n+                                     NULL);\n@@ -3638,10 +3597,10 @@\n-    if (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n-        style->indent = 1;\n-    } else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n-        style->indent = 0;\n-    } else {\n-        xsltTransformError(ctxt, NULL, inst,\n-                 \"invalid value for indent: %s\\n\", prop);\n-        if (style != NULL) style->warnings++;\n-    }\n-    xmlFree(prop);\n+        if (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n+            style->indent = 1;\n+        } else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n+            style->indent = 0;\n+        } else {\n+            xsltTransformError(ctxt, NULL, inst,\n+                             \"invalid value for indent: %s\\n\", prop);\n+            if (style != NULL) style->warnings++;\n+        }\n+        xmlFree(prop);\n@@ -3651,3 +3610,3 @@\n-                     (const xmlChar *)\n-                     \"omit-xml-declaration\",\n-                     NULL);\n+                                     (const xmlChar *)\n+                                     \"omit-xml-declaration\",\n+                                     NULL);\n@@ -3655,11 +3614,11 @@\n-    if (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n-        style->omitXmlDeclaration = 1;\n-    } else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n-        style->omitXmlDeclaration = 0;\n-    } else {\n-        xsltTransformError(ctxt, NULL, inst,\n-                 \"invalid value for omit-xml-declaration: %s\\n\",\n-                 prop);\n-        if (style != NULL) style->warnings++;\n-    }\n-    xmlFree(prop);\n+        if (xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n+            style->omitXmlDeclaration = 1;\n+        } else if (xmlStrEqual(prop, (const xmlChar *) \"no\")) {\n+            style->omitXmlDeclaration = 0;\n+        } else {\n+            xsltTransformError(ctxt, NULL, inst,\n+                             \"invalid value for omit-xml-declaration: %s\\n\",\n+                             prop);\n+            if (style != NULL) style->warnings++;\n+        }\n+        xmlFree(prop);\n@@ -3669,3 +3628,3 @@\n-                     (const xmlChar *)\n-                     \"cdata-section-elements\",\n-                     NULL);\n+                                         (const xmlChar *)\n+                                         \"cdata-section-elements\",\n+                                         NULL);\n@@ -3673,4 +3632,6 @@\n-    if (style->stripSpaces == NULL)\n-        style->stripSpaces = xmlHashCreate(10);\n-    if (style->stripSpaces == NULL)\n-        return;\n+        if (style->stripSpaces == NULL)\n+            style->stripSpaces = xmlHashCreate(10);\n+        if (style->stripSpaces == NULL) {\n+            xmlFree(elements);\n+            return;\n+        }\n@@ -3678,12 +3639,12 @@\n-    element = elements;\n-    while (*element != 0) {\n-        while (IS_BLANK_CH(*element))\n-        element++;\n-        if (*element == 0)\n-        break;\n-        end = element;\n-        while ((*end != 0) && (!IS_BLANK_CH(*end)))\n-        end++;\n-        element = xmlStrndup(element, end - element);\n-        if (element) {\n-        const xmlChar *URI;\n+        element = elements;\n+        while (*element != 0) {\n+            while (IS_BLANK_CH(*element))\n+                element++;\n+            if (*element == 0)\n+                break;\n+            end = element;\n+            while ((*end != 0) && (!IS_BLANK_CH(*end)))\n+                end++;\n+            element = xmlStrndup(element, end - element);\n+            if (element) {\n+                const xmlChar *URI;\n@@ -3692,3 +3653,3 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-                 \"add cdata section output element %s\\n\",\n-                 element);\n+                xsltGenericDebug(xsltGenericDebugContext,\n+                                 \"add cdata section output element %s\\n\",\n+                                 element);\n@@ -3698,3 +3659,5 @@\n-        xmlHashAddEntry2(style->stripSpaces, element, URI,\n-                    (xmlChar *) \"cdata\");\n-        xmlFree(element);\n+                xmlHashAddEntry2(style->stripSpaces, element, URI,\n+                                (xmlChar *) \"cdata\");\n+                xmlFree(element);\n+            }\n+            element = end;\n@@ -3702,3 +3665,1 @@\n-        element = end;\n-    }\n-    xmlFree(elements);\n+        xmlFree(elements);\n@@ -3717,7 +3678,7 @@\n-    (!xmlStrEqual(method, (const xmlChar *) \"xml\"))) {\n-    if (xmlStrEqual(method, (const xmlChar *) \"html\")) {\n-        ctxt->type = XSLT_OUTPUT_HTML;\n-        if (((doctypePublic != NULL) || (doctypeSystem != NULL)))\n-        res = htmlNewDoc(doctypeSystem, doctypePublic);\n-        else {\n-        if (version != NULL) {\n+        (!xmlStrEqual(method, (const xmlChar *) \"xml\"))) {\n+        if (xmlStrEqual(method, (const xmlChar *) \"html\")) {\n+            ctxt->type = XSLT_OUTPUT_HTML;\n+            if (((doctypePublic != NULL) || (doctypeSystem != NULL)))\n+                res = htmlNewDoc(doctypeSystem, doctypePublic);\n+            else {\n+                if (version != NULL) {\n@@ -3725,1 +3686,1 @@\n-            xsltGetHTMLIDs(version, &doctypePublic, &doctypeSystem);\n+                    xsltGetHTMLIDs(version, &doctypePublic, &doctypeSystem);\n@@ -3728,1 +3689,31 @@\n-        res = htmlNewDocNoDtD(doctypeSystem, doctypePublic);\n+                res = htmlNewDocNoDtD(doctypeSystem, doctypePublic);\n+            }\n+            if (res == NULL)\n+                goto error;\n+            res->dict = ctxt->dict;\n+            xmlDictReference(res->dict);\n+        } else if (xmlStrEqual(method, (const xmlChar *) \"xhtml\")) {\n+            xsltTransformError(ctxt, NULL, inst,\n+             \"xsltDocumentElem: unsupported method xhtml\\n\");\n+            ctxt->type = XSLT_OUTPUT_HTML;\n+            res = htmlNewDocNoDtD(doctypeSystem, doctypePublic);\n+            if (res == NULL)\n+                goto error;\n+            res->dict = ctxt->dict;\n+            xmlDictReference(res->dict);\n+        } else if (xmlStrEqual(method, (const xmlChar *) \"text\")) {\n+            ctxt->type = XSLT_OUTPUT_TEXT;\n+            res = xmlNewDoc(style->version);\n+            if (res == NULL)\n+                goto error;\n+            res->dict = ctxt->dict;\n+            xmlDictReference(res->dict);\n+#ifdef WITH_XSLT_DEBUG\n+            xsltGenericDebug(xsltGenericDebugContext,\n+                     \"reusing transformation dict for output\\n\");\n+#endif\n+        } else {\n+            xsltTransformError(ctxt, NULL, inst,\n+                             \"xsltDocumentElem: unsupported method (%s)\\n\",\n+                             method);\n+            goto error;\n@@ -3730,15 +3721,2 @@\n-        if (res == NULL)\n-        goto error;\n-        res->dict = ctxt->dict;\n-        xmlDictReference(res->dict);\n-    } else if (xmlStrEqual(method, (const xmlChar *) \"xhtml\")) {\n-        xsltTransformError(ctxt, NULL, inst,\n-         \"xsltDocumentElem: unsupported method xhtml\\n\");\n-        ctxt->type = XSLT_OUTPUT_HTML;\n-        res = htmlNewDocNoDtD(doctypeSystem, doctypePublic);\n-        if (res == NULL)\n-        goto error;\n-        res->dict = ctxt->dict;\n-        xmlDictReference(res->dict);\n-    } else if (xmlStrEqual(method, (const xmlChar *) \"text\")) {\n-        ctxt->type = XSLT_OUTPUT_TEXT;\n+    } else {\n+        ctxt->type = XSLT_OUTPUT_XML;\n@@ -3747,1 +3725,1 @@\n-        goto error;\n+            goto error;\n@@ -3753,17 +3731,0 @@\n-#endif\n-    } else {\n-        xsltTransformError(ctxt, NULL, inst,\n-                 \"xsltDocumentElem: unsupported method (%s)\\n\",\n-                     method);\n-        goto error;\n-    }\n-    } else {\n-    ctxt->type = XSLT_OUTPUT_XML;\n-    res = xmlNewDoc(style->version);\n-    if (res == NULL)\n-        goto error;\n-    res->dict = ctxt->dict;\n-    xmlDictReference(res->dict);\n-#ifdef WITH_XSLT_DEBUG\n-    xsltGenericDebug(xsltGenericDebugContext,\n-                     \"reusing transformation dict for output\\n\");\n@@ -3774,1 +3735,1 @@\n-    res->encoding = xmlStrdup(encoding);\n+        res->encoding = xmlStrdup(encoding);\n@@ -3787,3 +3748,3 @@\n-        doctype = xmlDictQLookup(ctxt->dict, root->ns->prefix, root->name);\n-    if (doctype == NULL)\n-        doctype = root->name;\n+            doctype = xmlDictQLookup(ctxt->dict, root->ns->prefix, root->name);\n+        if (doctype == NULL)\n+            doctype = root->name;\n@@ -3805,1 +3766,1 @@\n-        tmp = tmp->next;\n+                tmp = tmp->next;\n@@ -3815,1 +3776,1 @@\n-        } else if (version != NULL) {\n+                } else if (version != NULL) {\n@@ -3847,1 +3808,1 @@\n-                     NULL);\n+                                     NULL);\n@@ -3849,7 +3810,7 @@\n-    if (xmlStrEqual(prop, (const xmlChar *) \"true\") ||\n-        xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n-        style->omitXmlDeclaration = 1;\n-        redirect_write_append = 1;\n-    } else\n-        style->omitXmlDeclaration = 0;\n-    xmlFree(prop);\n+        if (xmlStrEqual(prop, (const xmlChar *) \"true\") ||\n+            xmlStrEqual(prop, (const xmlChar *) \"yes\")) {\n+            style->omitXmlDeclaration = 1;\n+            redirect_write_append = 1;\n+        } else\n+            style->omitXmlDeclaration = 0;\n+        xmlFree(prop);\n@@ -3861,7 +3822,7 @@\n-    f = fopen((const char *) filename, \"ab\");\n-    if (f == NULL) {\n-        ret = -1;\n-    } else {\n-        ret = xsltSaveResultToFile(f, res, style);\n-        fclose(f);\n-    }\n+        f = fopen((const char *) filename, \"ab\");\n+        if (f == NULL) {\n+            ret = -1;\n+        } else {\n+            ret = xsltSaveResultToFile(f, res, style);\n+            fclose(f);\n+        }\n@@ -3869,1 +3830,1 @@\n-    ret = xsltSaveResultToFilename((const char *) filename, res, style, 0);\n+        ret = xsltSaveResultToFilename((const char *) filename, res, style, 0);\n@@ -3872,1 +3833,1 @@\n-    xsltTransformError(ctxt, NULL, inst,\n+        xsltTransformError(ctxt, NULL, inst,\n@@ -3898,3 +3859,3 @@\n- *                                  *\n- *      Most of the XSLT-1.0 transformations            *\n- *                                  *\n+ *                                                                      *\n+ *              Most of the XSLT-1.0 transformations                    *\n+ *                                                                      *\n@@ -3915,2 +3876,2 @@\n-    xmlNodePtr node ATTRIBUTE_UNUSED, xmlNodePtr inst,\n-    xsltElemPreCompPtr comp) {\n+        xmlNodePtr node ATTRIBUTE_UNUSED, xmlNodePtr inst,\n+        xsltElemPreCompPtr comp) {\n@@ -3918,3 +3879,3 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-         \"xsl:sort : compilation failed\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+             \"xsl:sort : compilation failed\\n\");\n+        return;\n@@ -3923,1 +3884,1 @@\n-     \"xsl:sort : improper use this should not be reached\\n\");\n+         \"xsl:sort : improper use this should not be reached\\n\");\n@@ -3937,1 +3898,1 @@\n-     xmlNodePtr inst, xsltElemPreCompPtr castedComp)\n+         xmlNodePtr inst, xsltElemPreCompPtr castedComp)\n@@ -3948,8 +3909,8 @@\n-    switch (node->type) {\n-        case XML_TEXT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        \/*\n-         * This text comes from the stylesheet\n-         * For stylesheets, the set of whitespace-preserving\n-         * element names consists of just xsl:text.\n-         *\/\n+        switch (node->type) {\n+            case XML_TEXT_NODE:\n+            case XML_CDATA_SECTION_NODE:\n+                \/*\n+                 * This text comes from the stylesheet\n+                 * For stylesheets, the set of whitespace-preserving\n+                 * element names consists of just xsl:text.\n+                 *\/\n@@ -3957,6 +3918,6 @@\n-        if (node->type == XML_CDATA_SECTION_NODE) {\n-            XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltCopy: CDATA text %s\\n\", node->content));\n-        } else {\n-            XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltCopy: text %s\\n\", node->content));\n+                if (node->type == XML_CDATA_SECTION_NODE) {\n+                    XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,\n+                         \"xsltCopy: CDATA text %s\\n\", node->content));\n+                } else {\n+                    XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,\n+                         \"xsltCopy: text %s\\n\", node->content));\n@@ -3965,12 +3926,12 @@\n-        xsltCopyText(ctxt, ctxt->insert, node, 0);\n-        break;\n-        case XML_DOCUMENT_NODE:\n-        case XML_HTML_DOCUMENT_NODE:\n-        break;\n-        case XML_ELEMENT_NODE:\n-        \/*\n-        * REVISIT NOTE: The \"fake\" is a doc-node, not an element node.\n-        * REMOVED:\n-        *   if (xmlStrEqual(node->name, BAD_CAST \" fake node libxslt\"))\n-        *    return;\n-        *\/\n+                xsltCopyText(ctxt, ctxt->insert, node, 0);\n+                break;\n+            case XML_DOCUMENT_NODE:\n+            case XML_HTML_DOCUMENT_NODE:\n+                break;\n+            case XML_ELEMENT_NODE:\n+                \/*\n+                * REVISIT NOTE: The \"fake\" is a doc-node, not an element node.\n+                * REMOVED:\n+                *   if (xmlStrEqual(node->name, BAD_CAST \" fake node libxslt\"))\n+                *    return;\n+                *\/\n@@ -3979,2 +3940,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,\n-                 \"xsltCopy: node %s\\n\", node->name));\n+                XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,\n+                                 \"xsltCopy: node %s\\n\", node->name));\n@@ -3982,7 +3943,7 @@\n-        copy = xsltShallowCopyElem(ctxt, node, ctxt->insert, 0);\n-        ctxt->insert = copy;\n-        if (comp->use != NULL) {\n-            xsltApplyAttributeSet(ctxt, node, inst, comp->use);\n-        }\n-        break;\n-        case XML_ATTRIBUTE_NODE: {\n+                copy = xsltShallowCopyElem(ctxt, node, ctxt->insert, 0);\n+                ctxt->insert = copy;\n+                if (comp->use != NULL) {\n+                    xsltApplyAttributeSet(ctxt, node, inst, comp->use);\n+                }\n+                break;\n+            case XML_ATTRIBUTE_NODE: {\n@@ -3990,2 +3951,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,\n-                 \"xsltCopy: attribute %s\\n\", node->name));\n+                XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,\n+                                 \"xsltCopy: attribute %s\\n\", node->name));\n@@ -3993,10 +3954,10 @@\n-        \/*\n-        * REVISIT: We could also raise an error if the parent is not\n-        * an element node.\n-        * OPTIMIZE TODO: Can we set the value\/children of the\n-        * attribute without an intermediate copy of the string value?\n-        *\/\n-        xsltShallowCopyAttr(ctxt, inst, ctxt->insert, (xmlAttrPtr) node);\n-        break;\n-        }\n-        case XML_PI_NODE:\n+                \/*\n+                * REVISIT: We could also raise an error if the parent is not\n+                * an element node.\n+                * OPTIMIZE TODO: Can we set the value\/children of the\n+                * attribute without an intermediate copy of the string value?\n+                *\/\n+                xsltShallowCopyAttr(ctxt, inst, ctxt->insert, (xmlAttrPtr) node);\n+                break;\n+            }\n+            case XML_PI_NODE:\n@@ -4004,2 +3965,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,\n-                 \"xsltCopy: PI %s\\n\", node->name));\n+                XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,\n+                                 \"xsltCopy: PI %s\\n\", node->name));\n@@ -4007,5 +3968,5 @@\n-        copy = xmlNewDocPI(ctxt->insert->doc, node->name,\n-                           node->content);\n-        copy = xsltAddChild(ctxt->insert, copy);\n-        break;\n-        case XML_COMMENT_NODE:\n+                copy = xmlNewDocPI(ctxt->insert->doc, node->name,\n+                                   node->content);\n+                copy = xsltAddChild(ctxt->insert, copy);\n+                break;\n+            case XML_COMMENT_NODE:\n@@ -4013,2 +3974,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,\n-                 \"xsltCopy: comment\\n\"));\n+                XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,\n+                                 \"xsltCopy: comment\\n\"));\n@@ -4016,4 +3977,4 @@\n-        copy = xmlNewComment(node->content);\n-        copy = xsltAddChild(ctxt->insert, copy);\n-        break;\n-        case XML_NAMESPACE_DECL:\n+                copy = xmlNewComment(node->content);\n+                copy = xsltAddChild(ctxt->insert, copy);\n+                break;\n+            case XML_NAMESPACE_DECL:\n@@ -4021,2 +3982,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,\n-                 \"xsltCopy: namespace declaration\\n\"));\n+                XSLT_TRACE(ctxt,XSLT_TRACE_COPY,xsltGenericDebug(xsltGenericDebugContext,\n+                                 \"xsltCopy: namespace declaration\\n\"));\n@@ -4024,4 +3985,4 @@\n-        xsltShallowCopyNsNode(ctxt, inst, ctxt->insert, (xmlNsPtr)node);\n-        break;\n-        default:\n-        break;\n+                xsltShallowCopyNsNode(ctxt, inst, ctxt->insert, (xmlNsPtr)node);\n+                break;\n+            default:\n+                break;\n@@ -4029,1 +3990,1 @@\n-    }\n+        }\n@@ -4033,8 +3994,8 @@\n-    case XML_DOCUMENT_NODE:\n-    case XML_HTML_DOCUMENT_NODE:\n-    case XML_ELEMENT_NODE:\n-        xsltApplySequenceConstructor(ctxt, ctxt->node, inst->children,\n-        NULL);\n-        break;\n-    default:\n-        break;\n+        case XML_DOCUMENT_NODE:\n+        case XML_HTML_DOCUMENT_NODE:\n+        case XML_ELEMENT_NODE:\n+            xsltApplySequenceConstructor(ctxt, ctxt->node, inst->children,\n+                NULL);\n+            break;\n+        default:\n+            break;\n@@ -4056,1 +4017,1 @@\n-        xmlNodePtr inst, xsltElemPreCompPtr comp ATTRIBUTE_UNUSED) {\n+            xmlNodePtr inst, xsltElemPreCompPtr comp ATTRIBUTE_UNUSED) {\n@@ -4058,2 +4019,2 @@\n-    xmlNodePtr text = inst->children;\n-    xmlNodePtr copy;\n+        xmlNodePtr text = inst->children;\n+        xmlNodePtr copy;\n@@ -4061,9 +4022,9 @@\n-    while (text != NULL) {\n-        if ((text->type != XML_TEXT_NODE) &&\n-             (text->type != XML_CDATA_SECTION_NODE)) {\n-        xsltTransformError(ctxt, NULL, inst,\n-                 \"xsl:text content problem\\n\");\n-        break;\n-        }\n-        copy = xmlNewDocText(ctxt->output, text->content);\n-        if (text->type != XML_CDATA_SECTION_NODE) {\n+        while (text != NULL) {\n+            if ((text->type != XML_TEXT_NODE) &&\n+                 (text->type != XML_CDATA_SECTION_NODE)) {\n+                xsltTransformError(ctxt, NULL, inst,\n+                                 \"xsl:text content problem\\n\");\n+                break;\n+            }\n+            copy = xmlNewDocText(ctxt->output, text->content);\n+            if (text->type != XML_CDATA_SECTION_NODE) {\n@@ -4071,2 +4032,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-             \"Disable escaping: %s\\n\", text->content);\n+                xsltGenericDebug(xsltGenericDebugContext,\n+                     \"Disable escaping: %s\\n\", text->content);\n@@ -4074,1 +4035,4 @@\n-        copy->name = xmlStringTextNoenc;\n+                copy->name = xmlStringTextNoenc;\n+            }\n+            copy = xsltAddChild(ctxt->insert, copy);\n+            text = text->next;\n@@ -4076,3 +4040,0 @@\n-        copy = xsltAddChild(ctxt->insert, copy);\n-        text = text->next;\n-    }\n@@ -4093,1 +4054,1 @@\n-        xmlNodePtr inst, xsltElemPreCompPtr castedComp) {\n+            xmlNodePtr inst, xsltElemPreCompPtr castedComp) {\n@@ -4105,1 +4066,1 @@\n-    return;\n+        return;\n@@ -4120,1 +4081,1 @@\n-    \/* TODO: fix attr acquisition wrt to the XSLT namespace *\/\n+        \/* TODO: fix attr acquisition wrt to the XSLT namespace *\/\n@@ -4122,1 +4083,1 @@\n-        (const xmlChar *) \"name\", XSLT_NAMESPACE);\n+            (const xmlChar *) \"name\", XSLT_NAMESPACE);\n@@ -4125,1 +4086,1 @@\n-        \"xsl:element: The attribute 'name' is missing.\\n\");\n+                \"xsl:element: The attribute 'name' is missing.\\n\");\n@@ -4128,8 +4089,8 @@\n-    if (xmlValidateQName(prop, 0)) {\n-        xsltTransformError(ctxt, NULL, inst,\n-        \"xsl:element: The effective name '%s' is not a \"\n-        \"valid QName.\\n\", prop);\n-        \/* we fall through to catch any further errors, if possible *\/\n-    }\n-    name = xsltSplitQName(ctxt->dict, prop, &prefix);\n-    xmlFree(prop);\n+        if (xmlValidateQName(prop, 0)) {\n+            xsltTransformError(ctxt, NULL, inst,\n+                \"xsl:element: The effective name '%s' is not a \"\n+                \"valid QName.\\n\", prop);\n+            \/* we fall through to catch any further errors, if possible *\/\n+        }\n+        name = xsltSplitQName(ctxt->dict, prop, &prefix);\n+        xmlFree(prop);\n@@ -4137,3 +4098,3 @@\n-    \/*\n-    * The \"name\" value was static.\n-    *\/\n+        \/*\n+        * The \"name\" value was static.\n+        *\/\n@@ -4141,2 +4102,2 @@\n-    prefix = comp->nsPrefix;\n-    name = comp->name;\n+        prefix = comp->nsPrefix;\n+        name = comp->name;\n@@ -4144,1 +4105,1 @@\n-    name = xsltSplitQName(ctxt->dict, comp->name, &prefix);\n+        name = xsltSplitQName(ctxt->dict, comp->name, &prefix);\n@@ -4152,1 +4113,1 @@\n-    copy = xmlNewDocNodeEatName(ctxt->output, NULL, (xmlChar *)name, NULL);\n+        copy = xmlNewDocNodeEatName(ctxt->output, NULL, (xmlChar *)name, NULL);\n@@ -4154,1 +4115,1 @@\n-    copy = xmlNewDocNode(ctxt->output, NULL, (xmlChar *)name, NULL);\n+        copy = xmlNewDocNode(ctxt->output, NULL, (xmlChar *)name, NULL);\n@@ -4157,3 +4118,3 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-        \"xsl:element : creation of %s failed\\n\", name);\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+            \"xsl:element : creation of %s failed\\n\", name);\n+        return;\n@@ -4173,31 +4134,31 @@\n-    if (comp->ns != NULL) {\n-        \/*\n-        * No AVT; just plain text for the namespace name.\n-        *\/\n-        if (comp->ns[0] != 0)\n-        nsName = comp->ns;\n-    } else {\n-        xmlChar *tmpNsName;\n-        \/*\n-        * Eval the AVT.\n-        *\/\n-        \/* TODO: check attr acquisition wrt to the XSLT namespace *\/\n-        tmpNsName = xsltEvalAttrValueTemplate(ctxt, inst,\n-        (const xmlChar *) \"namespace\", XSLT_NAMESPACE);\n-        \/*\n-        * SPEC XSLT 1.0:\n-        *  \"If the string is empty, then the expanded-name of the\n-        *  attribute has a null namespace URI.\"\n-        *\/\n-        if ((tmpNsName != NULL) && (tmpNsName[0] != 0))\n-        nsName = xmlDictLookup(ctxt->dict, BAD_CAST tmpNsName, -1);\n-        xmlFree(tmpNsName);\n-    }\n-\n-        if (xmlStrEqual(nsName, BAD_CAST \"http:\/\/www.w3.org\/2000\/xmlns\/\")) {\n-            xsltTransformError(ctxt, NULL, inst,\n-                \"xsl:attribute: Namespace http:\/\/www.w3.org\/2000\/xmlns\/ \"\n-                \"forbidden.\\n\");\n-            goto error;\n-        }\n-        if (xmlStrEqual(nsName, XML_XML_NAMESPACE)) {\n+        if (comp->ns != NULL) {\n+            \/*\n+            * No AVT; just plain text for the namespace name.\n+            *\/\n+            if (comp->ns[0] != 0)\n+                nsName = comp->ns;\n+        } else {\n+            xmlChar *tmpNsName;\n+            \/*\n+            * Eval the AVT.\n+            *\/\n+            \/* TODO: check attr acquisition wrt to the XSLT namespace *\/\n+            tmpNsName = xsltEvalAttrValueTemplate(ctxt, inst,\n+                (const xmlChar *) \"namespace\", XSLT_NAMESPACE);\n+            \/*\n+            * SPEC XSLT 1.0:\n+            *  \"If the string is empty, then the expanded-name of the\n+            *  attribute has a null namespace URI.\"\n+            *\/\n+            if ((tmpNsName != NULL) && (tmpNsName[0] != 0))\n+                nsName = xmlDictLookup(ctxt->dict, BAD_CAST tmpNsName, -1);\n+            xmlFree(tmpNsName);\n+        }\n+\n+        if (xmlStrEqual(nsName, BAD_CAST \"http:\/\/www.w3.org\/2000\/xmlns\/\")) {\n+            xsltTransformError(ctxt, NULL, inst,\n+                \"xsl:attribute: Namespace http:\/\/www.w3.org\/2000\/xmlns\/ \"\n+                \"forbidden.\\n\");\n+            goto error;\n+        }\n+        if (xmlStrEqual(nsName, XML_XML_NAMESPACE)) {\n@@ -4209,10 +4170,1 @@\n-    xmlNsPtr ns;\n-    \/*\n-    * SPEC XSLT 1.0:\n-    *  \"If the namespace attribute is not present, then the QName is\n-    *  expanded into an expanded-name using the namespace declarations\n-    *  in effect for the xsl:element element, including any default\n-    *  namespace declaration.\n-    *\/\n-    ns = xmlSearchNs(inst->doc, inst, prefix);\n-    if (ns == NULL) {\n+        xmlNsPtr ns;\n@@ -4220,2 +4172,5 @@\n-        * TODO: Check this in the compilation layer in case it's a\n-        * static value.\n+        * SPEC XSLT 1.0:\n+        *  \"If the namespace attribute is not present, then the QName is\n+        *  expanded into an expanded-name using the namespace declarations\n+        *  in effect for the xsl:element element, including any default\n+        *  namespace declaration.\n@@ -4223,0 +4178,6 @@\n+        ns = xmlSearchNs(inst->doc, inst, prefix);\n+        if (ns == NULL) {\n+            \/*\n+            * TODO: Check this in the compilation layer in case it's a\n+            * static value.\n+            *\/\n@@ -4230,2 +4191,2 @@\n-    } else\n-        nsName = ns->href;\n+        } else\n+            nsName = ns->href;\n@@ -4237,1 +4198,1 @@\n-    if (xmlStrEqual(prefix, BAD_CAST \"xmlns\")) {\n+        if (xmlStrEqual(prefix, BAD_CAST \"xmlns\")) {\n@@ -4239,1 +4200,1 @@\n-        xmlChar *pref = xmlStrdup(BAD_CAST \"ns_1\");\n+            xmlChar *pref = xmlStrdup(BAD_CAST \"ns_1\");\n@@ -4241,1 +4202,1 @@\n-        copy->ns = xsltGetSpecialNamespace(ctxt, inst, nsName, pref, copy);\n+            copy->ns = xsltGetSpecialNamespace(ctxt, inst, nsName, pref, copy);\n@@ -4243,5 +4204,5 @@\n-        xmlFree(pref);\n-    } else {\n-        copy->ns = xsltGetSpecialNamespace(ctxt, inst, nsName, prefix,\n-        copy);\n-    }\n+            xmlFree(pref);\n+        } else {\n+            copy->ns = xsltGetSpecialNamespace(ctxt, inst, nsName, prefix,\n+                copy);\n+        }\n@@ -4249,2 +4210,2 @@\n-    (copy->parent->type == XML_ELEMENT_NODE) &&\n-    (copy->parent->ns != NULL))\n+        (copy->parent->type == XML_ELEMENT_NODE) &&\n+        (copy->parent->ns != NULL))\n@@ -4252,4 +4213,4 @@\n-    \/*\n-    * \"Undeclare\" the default namespace.\n-    *\/\n-    xsltGetSpecialNamespace(ctxt, inst, NULL, NULL, copy);\n+        \/*\n+        * \"Undeclare\" the default namespace.\n+        *\/\n+        xsltGetSpecialNamespace(ctxt, inst, NULL, NULL, copy);\n@@ -4261,13 +4222,14 @@\n-    if (comp->use != NULL) {\n-        xsltApplyAttributeSet(ctxt, node, inst, comp->use);\n-    } else {\n-        xmlChar *attrSets = NULL;\n-        \/*\n-        * BUG TODO: use-attribute-sets is not a value template.\n-        *  use-attribute-sets = qnames\n-        *\/\n-        attrSets = xsltEvalAttrValueTemplate(ctxt, inst,\n-        (const xmlChar *)\"use-attribute-sets\", NULL);\n-        if (attrSets != NULL) {\n-        xsltApplyAttributeSet(ctxt, node, inst, attrSets);\n-        xmlFree(attrSets);\n+        if (comp->use != NULL) {\n+            xsltApplyAttributeSet(ctxt, node, inst, comp->use);\n+        } else {\n+            xmlChar *attrSets = NULL;\n+            \/*\n+            * BUG TODO: use-attribute-sets is not a value template.\n+            *  use-attribute-sets = qnames\n+            *\/\n+            attrSets = xsltEvalAttrValueTemplate(ctxt, inst,\n+                (const xmlChar *)\"use-attribute-sets\", NULL);\n+            if (attrSets != NULL) {\n+                xsltApplyAttributeSet(ctxt, node, inst, attrSets);\n+                xmlFree(attrSets);\n+            }\n@@ -4276,1 +4238,0 @@\n-    }\n@@ -4281,2 +4242,2 @@\n-    xsltApplySequenceConstructor(ctxt, ctxt->node, inst->children,\n-        NULL);\n+        xsltApplySequenceConstructor(ctxt, ctxt->node, inst->children,\n+            NULL);\n@@ -4301,1 +4262,1 @@\n-               xmlNodePtr inst, xsltElemPreCompPtr comp ATTRIBUTE_UNUSED) {\n+                   xmlNodePtr inst, xsltElemPreCompPtr comp ATTRIBUTE_UNUSED) {\n@@ -4311,5 +4272,5 @@\n-        (xmlStrstr(value, BAD_CAST \"--\"))) {\n-        xsltTransformError(ctxt, NULL, inst,\n-            \"xsl:comment : '--' or ending '-' not allowed in comment\\n\");\n-        \/* fall through to try to catch further errors *\/\n-    }\n+            (xmlStrstr(value, BAD_CAST \"--\"))) {\n+            xsltTransformError(ctxt, NULL, inst,\n+                    \"xsl:comment : '--' or ending '-' not allowed in comment\\n\");\n+            \/* fall through to try to catch further errors *\/\n+        }\n@@ -4319,2 +4280,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_COMMENT,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltComment: empty\\n\"));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_COMMENT,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltComment: empty\\n\"));\n@@ -4322,2 +4283,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_COMMENT,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltComment: content %s\\n\", value));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_COMMENT,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltComment: content %s\\n\", value));\n@@ -4331,1 +4292,1 @@\n-    xmlFree(value);\n+        xmlFree(value);\n@@ -4345,1 +4306,1 @@\n-               xmlNodePtr inst, xsltElemPreCompPtr castedComp) {\n+                   xmlNodePtr inst, xsltElemPreCompPtr castedComp) {\n@@ -4357,1 +4318,1 @@\n-    return;\n+        return;\n@@ -4359,1 +4320,1 @@\n-    return;\n+        return;\n@@ -4361,7 +4322,7 @@\n-    name = xsltEvalAttrValueTemplate(ctxt, inst,\n-                (const xmlChar *)\"name\", NULL);\n-    if (name == NULL) {\n-        xsltTransformError(ctxt, NULL, inst,\n-         \"xsl:processing-instruction : name is missing\\n\");\n-        goto error;\n-    }\n+        name = xsltEvalAttrValueTemplate(ctxt, inst,\n+                            (const xmlChar *)\"name\", NULL);\n+        if (name == NULL) {\n+            xsltTransformError(ctxt, NULL, inst,\n+                 \"xsl:processing-instruction : name is missing\\n\");\n+            goto error;\n+        }\n@@ -4369,1 +4330,1 @@\n-    name = comp->name;\n+        name = comp->name;\n@@ -4376,3 +4337,3 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-         \"xsl:processing-instruction: '?>' not allowed within PI content\\n\");\n-    goto error;\n+        xsltTransformError(ctxt, NULL, inst,\n+             \"xsl:processing-instruction: '?>' not allowed within PI content\\n\");\n+        goto error;\n@@ -4382,2 +4343,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_PI,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltProcessingInstruction: %s empty\\n\", name));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_PI,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltProcessingInstruction: %s empty\\n\", name));\n@@ -4385,2 +4346,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_PI,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltProcessingInstruction: %s content %s\\n\", name, value));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_PI,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltProcessingInstruction: %s content %s\\n\", name, value));\n@@ -4397,1 +4358,1 @@\n-    xmlFree(value);\n+        xmlFree(value);\n@@ -4411,1 +4372,1 @@\n-               xmlNodePtr inst, xsltElemPreCompPtr castedComp) {\n+                   xmlNodePtr inst, xsltElemPreCompPtr castedComp) {\n@@ -4422,1 +4383,1 @@\n-    return;\n+        return;\n@@ -4424,3 +4385,3 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-         \"xsl:copy-of : compilation failed\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+             \"xsl:copy-of : compilation failed\\n\");\n+        return;\n@@ -4449,1 +4410,1 @@\n-     \"xsltCopyOf: select %s\\n\", comp->select));\n+         \"xsltCopyOf: select %s\\n\", comp->select));\n@@ -4458,5 +4419,5 @@\n-    if (res->type == XPATH_NODESET) {\n-        \/*\n-        * Node-set\n-        * --------\n-        *\/\n+        if (res->type == XPATH_NODESET) {\n+            \/*\n+            * Node-set\n+            * --------\n+            *\/\n@@ -4464,2 +4425,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltCopyOf: result is a node set\\n\"));\n+            XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,\n+                 \"xsltCopyOf: result is a node set\\n\"));\n@@ -4467,21 +4428,23 @@\n-        list = res->nodesetval;\n-        if (list != NULL) {\n-        xmlNodePtr cur;\n-        \/*\n-        * The list is already sorted in document order by XPath.\n-        * Append everything in this order under ctxt->insert.\n-        *\/\n-        for (i = 0;i < list->nodeNr;i++) {\n-            cur = list->nodeTab[i];\n-            if (cur == NULL)\n-            continue;\n-            if ((cur->type == XML_DOCUMENT_NODE) ||\n-            (cur->type == XML_HTML_DOCUMENT_NODE))\n-            {\n-            xsltCopyTreeList(ctxt, inst,\n-                cur->children, ctxt->insert, 0, 0);\n-            } else if (cur->type == XML_ATTRIBUTE_NODE) {\n-            xsltShallowCopyAttr(ctxt, inst,\n-                ctxt->insert, (xmlAttrPtr) cur);\n-            } else {\n-            xsltCopyTree(ctxt, inst, cur, ctxt->insert, 0, 0);\n+            list = res->nodesetval;\n+            if (list != NULL) {\n+                xmlNodePtr cur;\n+                \/*\n+                * The list is already sorted in document order by XPath.\n+                * Append everything in this order under ctxt->insert.\n+                *\/\n+                for (i = 0;i < list->nodeNr;i++) {\n+                    cur = list->nodeTab[i];\n+                    if (cur == NULL)\n+                        continue;\n+                    if ((cur->type == XML_DOCUMENT_NODE) ||\n+                        (cur->type == XML_HTML_DOCUMENT_NODE))\n+                    {\n+                        xsltCopyTreeList(ctxt, inst,\n+                            cur->children, ctxt->insert, 0, 0);\n+                    } else if (cur->type == XML_ATTRIBUTE_NODE) {\n+                        xsltShallowCopyAttr(ctxt, inst,\n+                            ctxt->insert, (xmlAttrPtr) cur);\n+                    } else {\n+                        xsltCopyTree(ctxt, inst, cur, ctxt->insert, 0, 0);\n+                    }\n+                }\n@@ -4489,9 +4452,7 @@\n-        }\n-        }\n-    } else if (res->type == XPATH_XSLT_TREE) {\n-        \/*\n-        * Result tree fragment\n-        * --------------------\n-        * E.g. via <xsl:variable ...><foo\/><\/xsl:variable>\n-        * Note that the root node of such trees is an xmlDocPtr in Libxslt.\n-        *\/\n+        } else if (res->type == XPATH_XSLT_TREE) {\n+            \/*\n+            * Result tree fragment\n+            * --------------------\n+            * E.g. via <xsl:variable ...><foo\/><\/xsl:variable>\n+            * Note that the root node of such trees is an xmlDocPtr in Libxslt.\n+            *\/\n@@ -4499,2 +4460,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltCopyOf: result is a result tree fragment\\n\"));\n+            XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,\n+                 \"xsltCopyOf: result is a result tree fragment\\n\"));\n@@ -4502,19 +4463,8 @@\n-        list = res->nodesetval;\n-        if ((list != NULL) && (list->nodeTab != NULL) &&\n-        (list->nodeTab[0] != NULL) &&\n-        (IS_XSLT_REAL_NODE(list->nodeTab[0])))\n-        {\n-        xsltCopyTreeList(ctxt, inst,\n-            list->nodeTab[0]->children, ctxt->insert, 0, 0);\n-        }\n-    } else {\n-        xmlChar *value = NULL;\n-        \/*\n-        * Convert to a string.\n-        *\/\n-        value = xmlXPathCastToString(res);\n-        if (value == NULL) {\n-        xsltTransformError(ctxt, NULL, inst,\n-            \"Internal error in xsltCopyOf(): \"\n-            \"failed to cast an XPath object to string.\\n\");\n-        ctxt->state = XSLT_STATE_STOPPED;\n+            list = res->nodesetval;\n+            if ((list != NULL) && (list->nodeTab != NULL) &&\n+                (list->nodeTab[0] != NULL) &&\n+                (IS_XSLT_REAL_NODE(list->nodeTab[0])))\n+            {\n+                xsltCopyTreeList(ctxt, inst,\n+                    list->nodeTab[0]->children, ctxt->insert, 0, 0);\n+            }\n@@ -4522,1 +4472,1 @@\n-        if (value[0] != 0) {\n+            xmlChar *value = NULL;\n@@ -4524,1 +4474,1 @@\n-            * Append content as text node.\n+            * Convert to a string.\n@@ -4526,3 +4476,14 @@\n-            xsltCopyTextString(ctxt, ctxt->insert, value, 0);\n-        }\n-        xmlFree(value);\n+            value = xmlXPathCastToString(res);\n+            if (value == NULL) {\n+                xsltTransformError(ctxt, NULL, inst,\n+                    \"Internal error in xsltCopyOf(): \"\n+                    \"failed to cast an XPath object to string.\\n\");\n+                ctxt->state = XSLT_STATE_STOPPED;\n+            } else {\n+                if (value[0] != 0) {\n+                    \/*\n+                    * Append content as text node.\n+                    *\/\n+                    xsltCopyTextString(ctxt, ctxt->insert, value, 0);\n+                }\n+                xmlFree(value);\n@@ -4531,2 +4492,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltCopyOf: result %s\\n\", res->stringval));\n+                XSLT_TRACE(ctxt,XSLT_TRACE_COPY_OF,xsltGenericDebug(xsltGenericDebugContext,\n+                    \"xsltCopyOf: result %s\\n\", res->stringval));\n@@ -4534,0 +4495,1 @@\n+            }\n@@ -4535,1 +4497,0 @@\n-    }\n@@ -4537,1 +4498,1 @@\n-    ctxt->state = XSLT_STATE_STOPPED;\n+        ctxt->state = XSLT_STATE_STOPPED;\n@@ -4541,1 +4502,1 @@\n-    xmlXPathFreeObject(res);\n+        xmlXPathFreeObject(res);\n@@ -4555,1 +4516,1 @@\n-               xmlNodePtr inst, xsltElemPreCompPtr castedComp)\n+                   xmlNodePtr inst, xsltElemPreCompPtr castedComp)\n@@ -4566,1 +4527,1 @@\n-    return;\n+        return;\n@@ -4569,4 +4530,4 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-        \"Internal error in xsltValueOf(): \"\n-        \"The XSLT 'value-of' instruction was not compiled.\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+            \"Internal error in xsltValueOf(): \"\n+            \"The XSLT 'value-of' instruction was not compiled.\\n\");\n+        return;\n@@ -4577,1 +4538,1 @@\n-     \"xsltValueOf: select %s\\n\", comp->select));\n+         \"xsltValueOf: select %s\\n\", comp->select));\n@@ -4586,2 +4547,12 @@\n-    value = xmlXPathCastToString(res);\n-    if (value == NULL) {\n+        value = xmlXPathCastToString(res);\n+        if (value == NULL) {\n+            xsltTransformError(ctxt, NULL, inst,\n+                \"Internal error in xsltValueOf(): \"\n+                \"failed to cast an XPath object to string.\\n\");\n+            ctxt->state = XSLT_STATE_STOPPED;\n+            goto error;\n+        }\n+        if (value[0] != 0) {\n+            xsltCopyTextString(ctxt, ctxt->insert, value, comp->noescape);\n+        }\n+    } else {\n@@ -4589,2 +4560,1 @@\n-        \"Internal error in xsltValueOf(): \"\n-        \"failed to cast an XPath object to string.\\n\");\n+            \"XPath evaluation returned no result.\\n\");\n@@ -4594,9 +4564,0 @@\n-    if (value[0] != 0) {\n-        xsltCopyTextString(ctxt, ctxt->insert, value, comp->noescape);\n-    }\n-    } else {\n-    xsltTransformError(ctxt, NULL, inst,\n-        \"XPath evaluation returned no result.\\n\");\n-    ctxt->state = XSLT_STATE_STOPPED;\n-    goto error;\n-    }\n@@ -4606,2 +4567,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_VALUE_OF,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltValueOf: result '%s'\\n\", value));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_VALUE_OF,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltValueOf: result '%s'\\n\", value));\n@@ -4613,1 +4574,1 @@\n-    xmlFree(value);\n+        xmlFree(value);\n@@ -4615,1 +4576,1 @@\n-    xmlXPathFreeObject(res);\n+        xmlXPathFreeObject(res);\n@@ -4629,1 +4590,1 @@\n-       xmlNodePtr inst, xsltElemPreCompPtr castedComp)\n+           xmlNodePtr inst, xsltElemPreCompPtr castedComp)\n@@ -4641,3 +4602,3 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-         \"xsl:number : compilation failed\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+             \"xsl:number : compilation failed\\n\");\n+        return;\n@@ -4647,1 +4608,1 @@\n-    return;\n+        return;\n@@ -4686,2 +4647,2 @@\n-             xmlNodePtr inst,\n-         xsltElemPreCompPtr comp ATTRIBUTE_UNUSED)\n+                 xmlNodePtr inst,\n+                 xsltElemPreCompPtr comp ATTRIBUTE_UNUSED)\n@@ -4692,1 +4653,1 @@\n-    return;\n+        return;\n@@ -4695,4 +4656,4 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-        \"Internal error in xsltApplyImports(): \"\n-        \"The XSLT 'apply-imports' instruction was not compiled.\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+            \"Internal error in xsltApplyImports(): \"\n+            \"The XSLT 'apply-imports' instruction was not compiled.\\n\");\n+        return;\n@@ -4707,10 +4668,10 @@\n-    \/*\n-    * SPEC XSLT 2.0:\n-    * \"[ERR XTDE0560] It is a non-recoverable dynamic error if\n-    *  xsl:apply-imports or xsl:next-match is evaluated when the\n-    *  current template rule is null.\"\n-    *\/\n-    xsltTransformError(ctxt, NULL, inst,\n-         \"It is an error to call 'apply-imports' \"\n-         \"when there's no current template rule.\\n\");\n-    return;\n+        \/*\n+        * SPEC XSLT 2.0:\n+        * \"[ERR XTDE0560] It is a non-recoverable dynamic error if\n+        *  xsl:apply-imports or xsl:next-match is evaluated when the\n+        *  current template rule is null.\"\n+        *\/\n+        xsltTransformError(ctxt, NULL, inst,\n+             \"It is an error to call 'apply-imports' \"\n+             \"when there's no current template rule.\\n\");\n+        return;\n@@ -4722,1 +4683,1 @@\n-    ctxt->currentTemplateRule->style);\n+        ctxt->currentTemplateRule->style);\n@@ -4725,10 +4686,10 @@\n-    xsltTemplatePtr oldCurTemplRule = ctxt->currentTemplateRule;\n-    \/*\n-    * Set the current template rule.\n-    *\/\n-    ctxt->currentTemplateRule = templ;\n-    \/*\n-    * URGENT TODO: Need xsl:with-param be handled somehow here?\n-    *\/\n-    xsltApplyXSLTTemplate(ctxt, contextNode, templ->content,\n-        templ, NULL);\n+        xsltTemplatePtr oldCurTemplRule = ctxt->currentTemplateRule;\n+        \/*\n+        * Set the current template rule.\n+        *\/\n+        ctxt->currentTemplateRule = templ;\n+        \/*\n+        * URGENT TODO: Need xsl:with-param be handled somehow here?\n+        *\/\n+        xsltApplyXSLTTemplate(ctxt, contextNode, templ->content,\n+            templ, NULL);\n@@ -4736,1 +4697,1 @@\n-    ctxt->currentTemplateRule = oldCurTemplRule;\n+        ctxt->currentTemplateRule = oldCurTemplRule;\n@@ -4755,1 +4716,1 @@\n-               xmlNodePtr inst, xsltElemPreCompPtr castedComp)\n+                   xmlNodePtr inst, xsltElemPreCompPtr castedComp)\n@@ -4759,1 +4720,1 @@\n-    (xsltStyleItemCallTemplatePtr) castedComp;\n+        (xsltStyleItemCallTemplatePtr) castedComp;\n@@ -4766,1 +4727,1 @@\n-    return;\n+        return;\n@@ -4768,3 +4729,3 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-         \"The XSLT 'call-template' instruction was not compiled.\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+             \"The XSLT 'call-template' instruction was not compiled.\\n\");\n+        return;\n@@ -4777,10 +4738,12 @@\n-    comp->templ = xsltFindTemplate(ctxt, comp->name, comp->ns);\n-    if (comp->templ == NULL) {\n-        if (comp->ns != NULL) {\n-            xsltTransformError(ctxt, NULL, inst,\n-            \"The called template '{%s}%s' was not found.\\n\",\n-            comp->ns, comp->name);\n-        } else {\n-            xsltTransformError(ctxt, NULL, inst,\n-            \"The called template '%s' was not found.\\n\",\n-            comp->name);\n+        comp->templ = xsltFindTemplate(ctxt, comp->name, comp->ns);\n+        if (comp->templ == NULL) {\n+            if (comp->ns != NULL) {\n+                xsltTransformError(ctxt, NULL, inst,\n+                        \"The called template '{%s}%s' was not found.\\n\",\n+                        comp->ns, comp->name);\n+            } else {\n+                xsltTransformError(ctxt, NULL, inst,\n+                        \"The called template '%s' was not found.\\n\",\n+                        comp->name);\n+            }\n+            return;\n@@ -4788,2 +4751,0 @@\n-        return;\n-    }\n@@ -4794,2 +4755,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_CALL_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,\n-             \"call-template: name %s\\n\", comp->name));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_CALL_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,\n+                         \"call-template: name %s\\n\", comp->name));\n@@ -4799,2 +4760,2 @@\n-    xmlNodePtr cur;\n-    xsltStackElemPtr param;\n+        xmlNodePtr cur;\n+        xsltStackElemPtr param;\n@@ -4802,2 +4763,2 @@\n-    cur = inst->children;\n-    while (cur != NULL) {\n+        cur = inst->children;\n+        while (cur != NULL) {\n@@ -4805,2 +4766,2 @@\n-        if (ctxt->debugStatus != XSLT_DEBUG_NONE)\n-        xslHandleDebugger(cur, node, comp->templ, ctxt);\n+            if (ctxt->debugStatus != XSLT_DEBUG_NONE)\n+                xslHandleDebugger(cur, node, comp->templ, ctxt);\n@@ -4808,12 +4769,20 @@\n-        if (ctxt->state == XSLT_STATE_STOPPED) break;\n-        \/*\n-        * TODO: The \"with-param\"s could be part of the \"call-template\"\n-        *   structure. Avoid to \"search\" for params dynamically\n-        *   in the XML tree every time.\n-        *\/\n-        if (IS_XSLT_ELEM(cur)) {\n-        if (IS_XSLT_NAME(cur, \"with-param\")) {\n-            param = xsltParseStylesheetCallerParam(ctxt, cur);\n-            if (param != NULL) {\n-            param->next = withParams;\n-            withParams = param;\n+            if (ctxt->state == XSLT_STATE_STOPPED) break;\n+            \/*\n+            * TODO: The \"with-param\"s could be part of the \"call-template\"\n+            *   structure. Avoid to \"search\" for params dynamically\n+            *   in the XML tree every time.\n+            *\/\n+            if (IS_XSLT_ELEM(cur)) {\n+                if (IS_XSLT_NAME(cur, \"with-param\")) {\n+                    param = xsltParseStylesheetCallerParam(ctxt, cur);\n+                    if (param != NULL) {\n+                        param->next = withParams;\n+                        withParams = param;\n+                    }\n+                } else {\n+                    xsltGenericError(xsltGenericErrorContext,\n+                        \"xsl:call-template: misplaced xsl:%s\\n\", cur->name);\n+                }\n+            } else {\n+                xsltGenericError(xsltGenericErrorContext,\n+                    \"xsl:call-template: misplaced %s element\\n\", cur->name);\n@@ -4821,7 +4790,1 @@\n-        } else {\n-            xsltGenericError(xsltGenericErrorContext,\n-            \"xsl:call-template: misplaced xsl:%s\\n\", cur->name);\n-        }\n-        } else {\n-        xsltGenericError(xsltGenericErrorContext,\n-            \"xsl:call-template: misplaced %s element\\n\", cur->name);\n+            cur = cur->next;\n@@ -4829,2 +4792,0 @@\n-        cur = cur->next;\n-    }\n@@ -4836,1 +4797,1 @@\n-    withParams);\n+        withParams);\n@@ -4838,1 +4799,1 @@\n-    xsltFreeStackElemList(withParams);\n+        xsltFreeStackElemList(withParams);\n@@ -4842,2 +4803,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_CALL_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,\n-             \"call-template returned: name %s\\n\", comp->name));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_CALL_TEMPLATE,xsltGenericDebug(xsltGenericDebugContext,\n+                         \"call-template returned: name %s\\n\", comp->name));\n@@ -4858,1 +4819,1 @@\n-               xmlNodePtr inst, xsltElemPreCompPtr castedComp)\n+                   xmlNodePtr inst, xsltElemPreCompPtr castedComp)\n@@ -4862,1 +4823,1 @@\n-    (xsltStyleItemApplyTemplatesPtr) castedComp;\n+        (xsltStyleItemApplyTemplatesPtr) castedComp;\n@@ -4867,1 +4828,1 @@\n-    xmlNodePtr cur, delNode = NULL, oldContextNode;\n+    xmlNodePtr cur, oldContextNode;\n@@ -4877,3 +4838,3 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-         \"xsl:apply-templates : compilation failed\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+             \"xsl:apply-templates : compilation failed\\n\");\n+        return;\n@@ -4882,1 +4843,1 @@\n-    return;\n+        return;\n@@ -4886,2 +4847,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltApplyTemplates: node: '%s'\\n\", node->name));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltApplyTemplates: node: '%s'\\n\", node->name));\n@@ -4916,1 +4877,1 @@\n-    xmlXPathObjectPtr res = NULL;\n+        xmlXPathObjectPtr res = NULL;\n@@ -4918,5 +4879,5 @@\n-    if (comp->comp == NULL) {\n-        xsltTransformError(ctxt, NULL, inst,\n-         \"xsl:apply-templates : compilation failed\\n\");\n-        goto error;\n-    }\n+        if (comp->comp == NULL) {\n+            xsltTransformError(ctxt, NULL, inst,\n+                 \"xsl:apply-templates : compilation failed\\n\");\n+            goto error;\n+        }\n@@ -4924,2 +4885,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltApplyTemplates: select %s\\n\", comp->select));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltApplyTemplates: select %s\\n\", comp->select));\n@@ -4928,1 +4889,1 @@\n-    res = xsltPreCompEval(ctxt, node, comp);\n+        res = xsltPreCompEval(ctxt, node, comp);\n@@ -4930,4 +4891,17 @@\n-    if (res != NULL) {\n-        if (res->type == XPATH_NODESET) {\n-        list = res->nodesetval; \/* consume the node set *\/\n-        res->nodesetval = NULL;\n+        if (res != NULL) {\n+            if (res->type == XPATH_NODESET) {\n+                list = res->nodesetval; \/* consume the node set *\/\n+                res->nodesetval = NULL;\n+            } else {\n+                xsltTransformError(ctxt, NULL, inst,\n+                    \"The 'select' expression did not evaluate to a \"\n+                    \"node set.\\n\");\n+                ctxt->state = XSLT_STATE_STOPPED;\n+                xmlXPathFreeObject(res);\n+                goto error;\n+            }\n+            xmlXPathFreeObject(res);\n+            \/*\n+            * Note: An xsl:apply-templates with a 'select' attribute,\n+            * can change the current source doc.\n+            *\/\n@@ -4935,6 +4909,4 @@\n-        xsltTransformError(ctxt, NULL, inst,\n-            \"The 'select' expression did not evaluate to a \"\n-            \"node set.\\n\");\n-        ctxt->state = XSLT_STATE_STOPPED;\n-        xmlXPathFreeObject(res);\n-        goto error;\n+            xsltTransformError(ctxt, NULL, inst,\n+                \"Failed to evaluate the 'select' expression.\\n\");\n+            ctxt->state = XSLT_STATE_STOPPED;\n+            goto error;\n@@ -4942,12 +4914,1 @@\n-        xmlXPathFreeObject(res);\n-        \/*\n-        * Note: An xsl:apply-templates with a 'select' attribute,\n-        * can change the current source doc.\n-        *\/\n-    } else {\n-        xsltTransformError(ctxt, NULL, inst,\n-        \"Failed to evaluate the 'select' expression.\\n\");\n-        ctxt->state = XSLT_STATE_STOPPED;\n-        goto error;\n-    }\n-    if (list == NULL) {\n+        if (list == NULL) {\n@@ -4955,2 +4916,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n-        \"xsltApplyTemplates: select didn't evaluate to a node list\\n\"));\n+            XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n+                \"xsltApplyTemplates: select didn't evaluate to a node list\\n\"));\n@@ -4958,23 +4919,2 @@\n-        goto exit;\n-    }\n-    \/*\n-    *\n-    * NOTE: Previously a document info (xsltDocument) was\n-    * created and attached to the Result Tree Fragment.\n-    * But such a document info is created on demand in\n-    * xsltKeyFunction() (functions.c), so we need to create\n-    * it here beforehand.\n-    * In order to take care of potential keys we need to\n-    * do some extra work for the case when a Result Tree Fragment\n-    * is converted into a nodeset (e.g. exslt:node-set()) :\n-    * We attach a \"pseudo-doc\" (xsltDocument) to _private.\n-    * This xsltDocument, together with the keyset, will be freed\n-    * when the Result Tree Fragment is freed.\n-    *\n-    *\/\n-#if 0\n-    if ((ctxt->nbKeys > 0) &&\n-        (list->nodeNr != 0) &&\n-        (list->nodeTab[0]->doc != NULL) &&\n-        XSLT_IS_RES_TREE_FRAG(list->nodeTab[0]->doc))\n-    {\n+            goto exit;\n+        }\n@@ -4982,2 +4922,13 @@\n-        * NOTE that it's also OK if @effectiveDocInfo will be\n-        * set to NULL.\n+        *\n+        * NOTE: Previously a document info (xsltDocument) was\n+        * created and attached to the Result Tree Fragment.\n+        * But such a document info is created on demand in\n+        * xsltKeyFunction() (functions.c), so we need to create\n+        * it here beforehand.\n+        * In order to take care of potential keys we need to\n+        * do some extra work for the case when a Result Tree Fragment\n+        * is converted into a nodeset (e.g. exslt:node-set()) :\n+        * We attach a \"pseudo-doc\" (xsltDocument) to _private.\n+        * This xsltDocument, together with the keyset, will be freed\n+        * when the Result Tree Fragment is freed.\n+        *\n@@ -4985,72 +4936,12 @@\n-        isRTF = 1;\n-        effectiveDocInfo = list->nodeTab[0]->doc->_private;\n-    }\n-#endif\n-    } else {\n-    \/*\n-     * Build an XPath node set with the children\n-     *\/\n-    list = xmlXPathNodeSetCreate(NULL);\n-    if (list == NULL)\n-        goto error;\n-    if (node->type != XML_NAMESPACE_DECL)\n-        cur = node->children;\n-    else\n-        cur = NULL;\n-    while (cur != NULL) {\n-        switch (cur->type) {\n-        case XML_TEXT_NODE:\n-            if ((IS_BLANK_NODE(cur)) &&\n-            (cur->parent != NULL) &&\n-            (cur->parent->type == XML_ELEMENT_NODE) &&\n-            (ctxt->style->stripSpaces != NULL)) {\n-            const xmlChar *val;\n-\n-            if (cur->parent->ns != NULL) {\n-                val = (const xmlChar *)\n-                  xmlHashLookup2(ctxt->style->stripSpaces,\n-                         cur->parent->name,\n-                         cur->parent->ns->href);\n-                if (val == NULL) {\n-                val = (const xmlChar *)\n-                  xmlHashLookup2(ctxt->style->stripSpaces,\n-                         BAD_CAST \"*\",\n-                         cur->parent->ns->href);\n-                }\n-            } else {\n-                val = (const xmlChar *)\n-                  xmlHashLookup2(ctxt->style->stripSpaces,\n-                         cur->parent->name, NULL);\n-            }\n-            if ((val != NULL) &&\n-                (xmlStrEqual(val, (xmlChar *) \"strip\"))) {\n-                delNode = cur;\n-                break;\n-            }\n-            }\n-            \/* Intentional fall-through *\/\n-        case XML_ELEMENT_NODE:\n-        case XML_DOCUMENT_NODE:\n-        case XML_HTML_DOCUMENT_NODE:\n-        case XML_CDATA_SECTION_NODE:\n-        case XML_PI_NODE:\n-        case XML_COMMENT_NODE:\n-            xmlXPathNodeSetAddUnique(list, cur);\n-            break;\n-        case XML_DTD_NODE:\n-            \/* Unlink the DTD, it's still reachable\n-             * using doc->intSubset *\/\n-            if (cur->next != NULL)\n-            cur->next->prev = cur->prev;\n-            if (cur->prev != NULL)\n-            cur->prev->next = cur->next;\n-            break;\n-        case XML_NAMESPACE_DECL:\n-            break;\n-        default:\n-#ifdef WITH_XSLT_DEBUG_PROCESS\n-            XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltApplyTemplates: skipping cur type %d\\n\",\n-                     cur->type));\n-#endif\n-            delNode = cur;\n+#if 0\n+        if ((ctxt->nbKeys > 0) &&\n+            (list->nodeNr != 0) &&\n+            (list->nodeTab[0]->doc != NULL) &&\n+            XSLT_IS_RES_TREE_FRAG(list->nodeTab[0]->doc))\n+        {\n+            \/*\n+            * NOTE that it's also OK if @effectiveDocInfo will be\n+            * set to NULL.\n+            *\/\n+            isRTF = 1;\n+            effectiveDocInfo = list->nodeTab[0]->doc->_private;\n@@ -5058,5 +4949,0 @@\n-        cur = cur->next;\n-        if (delNode != NULL) {\n-#ifdef WITH_XSLT_DEBUG_PROCESS\n-        XSLT_TRACE(ctxt,XSLT_TRACE_APPLY_TEMPLATES,xsltGenericDebug(xsltGenericDebugContext,\n-             \"xsltApplyTemplates: removing ignorable blank cur\\n\"));\n@@ -5064,3 +4950,15 @@\n-        xmlUnlinkNode(delNode);\n-        xmlFreeNode(delNode);\n-        delNode = NULL;\n+    } else {\n+        \/*\n+         * Build an XPath node set with the children\n+         *\/\n+        list = xmlXPathNodeSetCreate(NULL);\n+        if (list == NULL)\n+            goto error;\n+        if (node->type != XML_NAMESPACE_DECL)\n+            cur = node->children;\n+        else\n+            cur = NULL;\n+        while (cur != NULL) {\n+            if (IS_XSLT_REAL_NODE(cur))\n+                xmlXPathNodeSetAddUnique(list, cur);\n+            cur = cur->next;\n@@ -5069,1 +4967,0 @@\n-    }\n@@ -5074,1 +4971,1 @@\n-    \"xsltApplyTemplates: list of %d nodes\\n\", list->nodeNr));\n+        \"xsltApplyTemplates: list of %d nodes\\n\", list->nodeNr));\n@@ -5078,1 +4975,1 @@\n-    goto exit;\n+        goto exit;\n@@ -5093,31 +4990,1 @@\n-    xsltStackElemPtr param;\n-\n-    cur = inst->children;\n-    while (cur) {\n-\n-#ifdef WITH_DEBUGGER\n-        if (ctxt->debugStatus != XSLT_DEBUG_NONE)\n-        xslHandleDebugger(cur, node, NULL, ctxt);\n-#endif\n-        if (ctxt->state == XSLT_STATE_STOPPED)\n-        break;\n-        if (cur->type == XML_TEXT_NODE) {\n-        cur = cur->next;\n-        continue;\n-        }\n-        if (! IS_XSLT_ELEM(cur))\n-        break;\n-        if (IS_XSLT_NAME(cur, \"with-param\")) {\n-        param = xsltParseStylesheetCallerParam(ctxt, cur);\n-        if (param != NULL) {\n-            param->next = withParams;\n-            withParams = param;\n-        }\n-        }\n-        if (IS_XSLT_NAME(cur, \"sort\")) {\n-        xsltTemplatePtr oldCurTempRule =\n-            ctxt->currentTemplateRule;\n-        int nbsorts = 0;\n-        xmlNodePtr sorts[XSLT_MAX_SORT];\n-\n-        sorts[nbsorts++] = cur;\n+        xsltStackElemPtr param;\n@@ -5125,0 +4992,1 @@\n+        cur = inst->children;\n@@ -5129,1 +4997,1 @@\n-            xslHandleDebugger(cur, node, NULL, ctxt);\n+                xslHandleDebugger(cur, node, NULL, ctxt);\n@@ -5132,2 +5000,1 @@\n-            break;\n-\n+                break;\n@@ -5135,2 +5002,2 @@\n-            cur = cur->next;\n-            continue;\n+                cur = cur->next;\n+                continue;\n@@ -5138,1 +5005,0 @@\n-\n@@ -5140,1 +5006,1 @@\n-            break;\n+                break;\n@@ -5142,5 +5008,5 @@\n-            param = xsltParseStylesheetCallerParam(ctxt, cur);\n-            if (param != NULL) {\n-                param->next = withParams;\n-                withParams = param;\n-            }\n+                param = xsltParseStylesheetCallerParam(ctxt, cur);\n+                if (param != NULL) {\n+                    param->next = withParams;\n+                    withParams = param;\n+                }\n@@ -5149,8 +5015,5 @@\n-            if (nbsorts >= XSLT_MAX_SORT) {\n-                xsltTransformError(ctxt, NULL, cur,\n-                \"The number (%d) of xsl:sort instructions exceeds the \"\n-                \"maximum allowed by this processor's settings.\\n\",\n-                nbsorts);\n-                ctxt->state = XSLT_STATE_STOPPED;\n-                break;\n-            } else {\n+                xsltTemplatePtr oldCurTempRule =\n+                    ctxt->currentTemplateRule;\n+                int nbsorts = 0;\n+                xmlNodePtr sorts[XSLT_MAX_SORT];\n+\n@@ -5158,1 +5021,49 @@\n-            }\n+                cur = cur->next;\n+\n+                while (cur) {\n+\n+#ifdef WITH_DEBUGGER\n+                    if (ctxt->debugStatus != XSLT_DEBUG_NONE)\n+                        xslHandleDebugger(cur, node, NULL, ctxt);\n+#endif\n+                    if (ctxt->state == XSLT_STATE_STOPPED)\n+                        break;\n+\n+                    if (cur->type == XML_TEXT_NODE) {\n+                        cur = cur->next;\n+                        continue;\n+                    }\n+\n+                    if (! IS_XSLT_ELEM(cur))\n+                        break;\n+                    if (IS_XSLT_NAME(cur, \"with-param\")) {\n+                        param = xsltParseStylesheetCallerParam(ctxt, cur);\n+                        if (param != NULL) {\n+                            param->next = withParams;\n+                            withParams = param;\n+                        }\n+                    }\n+                    if (IS_XSLT_NAME(cur, \"sort\")) {\n+                        if (nbsorts >= XSLT_MAX_SORT) {\n+                            xsltTransformError(ctxt, NULL, cur,\n+                                \"The number (%d) of xsl:sort instructions exceeds the \"\n+                                \"maximum allowed by this processor's settings.\\n\",\n+                                nbsorts);\n+                            ctxt->state = XSLT_STATE_STOPPED;\n+                            break;\n+                        } else {\n+                            sorts[nbsorts++] = cur;\n+                        }\n+                    }\n+                    cur = cur->next;\n+                }\n+                \/*\n+                * The \"current template rule\" is cleared for xsl:sort.\n+                *\/\n+                ctxt->currentTemplateRule = NULL;\n+                \/*\n+                * Sort.\n+                *\/\n+                xsltDoSortFunction(ctxt, sorts, nbsorts);\n+                ctxt->currentTemplateRule = oldCurTempRule;\n+                break;\n@@ -5162,13 +5073,0 @@\n-        \/*\n-        * The \"current template rule\" is cleared for xsl:sort.\n-        *\/\n-        ctxt->currentTemplateRule = NULL;\n-        \/*\n-        * Sort.\n-        *\/\n-        xsltDoSortFunction(ctxt, sorts, nbsorts);\n-        ctxt->currentTemplateRule = oldCurTempRule;\n-        break;\n-        }\n-        cur = cur->next;\n-    }\n@@ -5181,11 +5079,11 @@\n-    cur = list->nodeTab[i];\n-    \/*\n-    * The node becomes the \"current node\".\n-    *\/\n-    ctxt->node = cur;\n-    \/*\n-    * An xsl:apply-templates can change the current context doc.\n-    * OPTIMIZE TODO: Get rid of the need to set the context doc.\n-    *\/\n-    if ((cur->type != XML_NAMESPACE_DECL) && (cur->doc != NULL))\n-        xpctxt->doc = cur->doc;\n+        cur = list->nodeTab[i];\n+        \/*\n+        * The node becomes the \"current node\".\n+        *\/\n+        ctxt->node = cur;\n+        \/*\n+        * An xsl:apply-templates can change the current context doc.\n+        * OPTIMIZE TODO: Get rid of the need to set the context doc.\n+        *\/\n+        if ((cur->type != XML_NAMESPACE_DECL) && (cur->doc != NULL))\n+            xpctxt->doc = cur->doc;\n@@ -5193,5 +5091,5 @@\n-    xpctxt->proximityPosition = i + 1;\n-    \/*\n-    * Find and apply a template for this node.\n-    *\/\n-    xsltProcessOneNode(ctxt, cur, withParams);\n+        xpctxt->proximityPosition = i + 1;\n+        \/*\n+        * Find and apply a template for this node.\n+        *\/\n+        xsltProcessOneNode(ctxt, cur, withParams);\n@@ -5206,1 +5104,1 @@\n-    xsltFreeStackElemList(withParams);\n+        xsltFreeStackElemList(withParams);\n@@ -5208,1 +5106,1 @@\n-    xmlXPathFreeNodeSet(list);\n+        xmlXPathFreeNodeSet(list);\n@@ -5235,1 +5133,1 @@\n-       xmlNodePtr inst, xsltElemPreCompPtr comp ATTRIBUTE_UNUSED)\n+           xmlNodePtr inst, xsltElemPreCompPtr comp ATTRIBUTE_UNUSED)\n@@ -5240,1 +5138,1 @@\n-    return;\n+        return;\n@@ -5248,3 +5146,3 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-        \"xsl:choose: The instruction has no content.\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+            \"xsl:choose: The instruction has no content.\\n\");\n+        return;\n@@ -5259,3 +5157,3 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-         \"xsl:choose: xsl:when expected first\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+             \"xsl:choose: xsl:when expected first\\n\");\n+        return;\n@@ -5266,1 +5164,1 @@\n-    int testRes = 0, res = 0;\n+        int testRes = 0, res = 0;\n@@ -5269,1 +5167,1 @@\n-    xsltStyleItemWhenPtr wcomp = NULL;\n+        xsltStyleItemWhenPtr wcomp = NULL;\n@@ -5271,1 +5169,1 @@\n-    xsltStylePreCompPtr wcomp = NULL;\n+        xsltStylePreCompPtr wcomp = NULL;\n@@ -5274,5 +5172,5 @@\n-    \/*\n-    * Process xsl:when ---------------------------------------------------\n-    *\/\n-    while (IS_XSLT_ELEM(cur) && IS_XSLT_NAME(cur, \"when\")) {\n-        wcomp = cur->psvi;\n+        \/*\n+        * Process xsl:when ---------------------------------------------------\n+        *\/\n+        while (IS_XSLT_ELEM(cur) && IS_XSLT_NAME(cur, \"when\")) {\n+            wcomp = cur->psvi;\n@@ -5280,8 +5178,8 @@\n-        if ((wcomp == NULL) || (wcomp->test == NULL) ||\n-        (wcomp->comp == NULL))\n-        {\n-        xsltTransformError(ctxt, NULL, cur,\n-            \"Internal error in xsltChoose(): \"\n-            \"The XSLT 'when' instruction was not compiled.\\n\");\n-        goto error;\n-        }\n+            if ((wcomp == NULL) || (wcomp->test == NULL) ||\n+                (wcomp->comp == NULL))\n+            {\n+                xsltTransformError(ctxt, NULL, cur,\n+                    \"Internal error in xsltChoose(): \"\n+                    \"The XSLT 'when' instruction was not compiled.\\n\");\n+                goto error;\n+            }\n@@ -5291,6 +5189,6 @@\n-        if (xslDebugStatus != XSLT_DEBUG_NONE) {\n-        \/*\n-        * TODO: Isn't comp->templ always NULL for xsl:choose?\n-        *\/\n-        xslHandleDebugger(cur, contextNode, NULL, ctxt);\n-        }\n+            if (xslDebugStatus != XSLT_DEBUG_NONE) {\n+                \/*\n+                * TODO: Isn't comp->templ always NULL for xsl:choose?\n+                *\/\n+                xslHandleDebugger(cur, contextNode, NULL, ctxt);\n+            }\n@@ -5299,2 +5197,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,\n-        \"xsltChoose: test %s\\n\", wcomp->test));\n+            XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,\n+                \"xsltChoose: test %s\\n\", wcomp->test));\n@@ -5304,1 +5202,1 @@\n-        res = xsltPreCompEvalToBoolean(ctxt, contextNode, wcomp);\n+            res = xsltPreCompEvalToBoolean(ctxt, contextNode, wcomp);\n@@ -5306,5 +5204,5 @@\n-        if (res == -1) {\n-        ctxt->state = XSLT_STATE_STOPPED;\n-        goto error;\n-        }\n-        testRes = (res == 1) ? 1 : 0;\n+            if (res == -1) {\n+                ctxt->state = XSLT_STATE_STOPPED;\n+                goto error;\n+            }\n+            testRes = (res == 1) ? 1 : 0;\n@@ -5314,1 +5212,1 @@\n-        res = xsltPreCompEval(ctxt, cotextNode, wcomp);\n+            res = xsltPreCompEval(ctxt, cotextNode, wcomp);\n@@ -5316,6 +5214,6 @@\n-        if (res != NULL) {\n-        if (res->type != XPATH_BOOLEAN)\n-            res = xmlXPathConvertBoolean(res);\n-        if (res->type == XPATH_BOOLEAN)\n-            testRes = res->boolval;\n-        else {\n+            if (res != NULL) {\n+                if (res->type != XPATH_BOOLEAN)\n+                    res = xmlXPathConvertBoolean(res);\n+                if (res->type == XPATH_BOOLEAN)\n+                    testRes = res->boolval;\n+                else {\n@@ -5323,2 +5221,2 @@\n-            XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltChoose: test didn't evaluate to a boolean\\n\"));\n+                    XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,\n+                        \"xsltChoose: test didn't evaluate to a boolean\\n\"));\n@@ -5326,8 +5224,8 @@\n-            goto error;\n-        }\n-        xmlXPathFreeObject(res);\n-        res = NULL;\n-        } else {\n-        ctxt->state = XSLT_STATE_STOPPED;\n-        goto error;\n-        }\n+                    goto error;\n+                }\n+                xmlXPathFreeObject(res);\n+                res = NULL;\n+            } else {\n+                ctxt->state = XSLT_STATE_STOPPED;\n+                goto error;\n+            }\n@@ -5338,2 +5236,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,\n-        \"xsltChoose: test evaluate to %d\\n\", testRes));\n+            XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,\n+                \"xsltChoose: test evaluate to %d\\n\", testRes));\n@@ -5341,2 +5239,2 @@\n-        if (testRes)\n-        goto test_is_true;\n+            if (testRes)\n+                goto test_is_true;\n@@ -5344,2 +5242,2 @@\n-        cur = cur->next;\n-    }\n+            cur = cur->next;\n+        }\n@@ -5347,4 +5245,4 @@\n-    \/*\n-    * Process xsl:otherwise ----------------------------------------------\n-    *\/\n-    if (IS_XSLT_ELEM(cur) && IS_XSLT_NAME(cur, \"otherwise\")) {\n+        \/*\n+        * Process xsl:otherwise ----------------------------------------------\n+        *\/\n+        if (IS_XSLT_ELEM(cur) && IS_XSLT_NAME(cur, \"otherwise\")) {\n@@ -5353,2 +5251,2 @@\n-        if (xslDebugStatus != XSLT_DEBUG_NONE)\n-        xslHandleDebugger(cur, contextNode, NULL, ctxt);\n+            if (xslDebugStatus != XSLT_DEBUG_NONE)\n+                xslHandleDebugger(cur, contextNode, NULL, ctxt);\n@@ -5358,2 +5256,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,\n-        \"evaluating xsl:otherwise\\n\"));\n+            XSLT_TRACE(ctxt,XSLT_TRACE_CHOOSE,xsltGenericDebug(xsltGenericDebugContext,\n+                \"evaluating xsl:otherwise\\n\"));\n@@ -5361,3 +5259,3 @@\n-        goto test_is_true;\n-    }\n-    goto exit;\n+            goto test_is_true;\n+        }\n+        goto exit;\n@@ -5367,1 +5265,1 @@\n-    goto process_sequence;\n+        goto process_sequence;\n@@ -5376,1 +5274,1 @@\n-    NULL);\n+        NULL);\n@@ -5394,1 +5292,1 @@\n-               xmlNodePtr inst, xsltElemPreCompPtr castedComp)\n+                   xmlNodePtr inst, xsltElemPreCompPtr castedComp)\n@@ -5405,1 +5303,1 @@\n-    return;\n+        return;\n@@ -5407,4 +5305,4 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-        \"Internal error in xsltIf(): \"\n-        \"The XSLT 'if' instruction was not compiled.\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+            \"Internal error in xsltIf(): \"\n+            \"The XSLT 'if' instruction was not compiled.\\n\");\n+        return;\n@@ -5415,1 +5313,1 @@\n-     \"xsltIf: test %s\\n\", comp->test));\n+         \"xsltIf: test %s\\n\", comp->test));\n@@ -5420,1 +5318,1 @@\n-    xmlDocPtr oldLocalFragmentTop = ctxt->localRVT;\n+        xmlDocPtr oldLocalFragmentTop = ctxt->localRVT;\n@@ -5422,1 +5320,1 @@\n-    res = xsltPreCompEvalToBoolean(ctxt, contextNode, comp);\n+        res = xsltPreCompEvalToBoolean(ctxt, contextNode, comp);\n@@ -5424,6 +5322,6 @@\n-    \/*\n-    * Cleanup fragments created during evaluation of the\n-    * \"select\" expression.\n-    *\/\n-    if (oldLocalFragmentTop != ctxt->localRVT)\n-        xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);\n+        \/*\n+        * Cleanup fragments created during evaluation of the\n+        * \"select\" expression.\n+        *\/\n+        if (oldLocalFragmentTop != ctxt->localRVT)\n+            xsltReleaseLocalRVTs(ctxt, oldLocalFragmentTop);\n@@ -5434,1 +5332,1 @@\n-    \"xsltIf: test evaluate to %d\\n\", res));\n+        \"xsltIf: test evaluate to %d\\n\", res));\n@@ -5438,2 +5336,2 @@\n-    ctxt->state = XSLT_STATE_STOPPED;\n-    goto error;\n+        ctxt->state = XSLT_STATE_STOPPED;\n+        goto error;\n@@ -5442,5 +5340,5 @@\n-    \/*\n-    * Instantiate the sequence constructor of xsl:if.\n-    *\/\n-    xsltApplySequenceConstructor(ctxt,\n-        contextNode, inst->children, NULL);\n+        \/*\n+        * Instantiate the sequence constructor of xsl:if.\n+        *\/\n+        xsltApplySequenceConstructor(ctxt,\n+            contextNode, inst->children, NULL);\n@@ -5451,9 +5349,9 @@\n-    \/*\n-    * OLD CODE:\n-    *\/\n-    xmlXPathObjectPtr xpobj = xsltPreCompEval(ctxt, contextNode, comp);\n-    if (xpobj != NULL) {\n-        if (xpobj->type != XPATH_BOOLEAN)\n-        xpobj = xmlXPathConvertBoolean(xpobj);\n-        if (xpobj->type == XPATH_BOOLEAN) {\n-        res = xpobj->boolval;\n+        \/*\n+        * OLD CODE:\n+        *\/\n+        xmlXPathObjectPtr xpobj = xsltPreCompEval(ctxt, contextNode, comp);\n+        if (xpobj != NULL) {\n+            if (xpobj->type != XPATH_BOOLEAN)\n+                xpobj = xmlXPathConvertBoolean(xpobj);\n+            if (xpobj->type == XPATH_BOOLEAN) {\n+                res = xpobj->boolval;\n@@ -5462,2 +5360,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_IF,xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltIf: test evaluate to %d\\n\", res));\n+                XSLT_TRACE(ctxt,XSLT_TRACE_IF,xsltGenericDebug(xsltGenericDebugContext,\n+                    \"xsltIf: test evaluate to %d\\n\", res));\n@@ -5465,5 +5363,5 @@\n-        if (res) {\n-            xsltApplySequenceConstructor(ctxt,\n-            contextNode, inst->children, NULL);\n-        }\n-        } else {\n+                if (res) {\n+                    xsltApplySequenceConstructor(ctxt,\n+                        contextNode, inst->children, NULL);\n+                }\n+            } else {\n@@ -5472,3 +5370,3 @@\n-        XSLT_TRACE(ctxt, XSLT_TRACE_IF,\n-            xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltIf: test didn't evaluate to a boolean\\n\"));\n+                XSLT_TRACE(ctxt, XSLT_TRACE_IF,\n+                    xsltGenericDebug(xsltGenericDebugContext,\n+                    \"xsltIf: test didn't evaluate to a boolean\\n\"));\n@@ -5476,1 +5374,5 @@\n-        ctxt->state = XSLT_STATE_STOPPED;\n+                ctxt->state = XSLT_STATE_STOPPED;\n+            }\n+            xmlXPathFreeObject(xpobj);\n+        } else {\n+            ctxt->state = XSLT_STATE_STOPPED;\n@@ -5478,4 +5380,0 @@\n-        xmlXPathFreeObject(xpobj);\n-    } else {\n-        ctxt->state = XSLT_STATE_STOPPED;\n-    }\n@@ -5500,1 +5398,1 @@\n-        xmlNodePtr inst, xsltElemPreCompPtr castedComp)\n+            xmlNodePtr inst, xsltElemPreCompPtr castedComp)\n@@ -5520,3 +5418,3 @@\n-    xsltGenericError(xsltGenericErrorContext,\n-        \"xsltForEach(): Bad arguments.\\n\");\n-    return;\n+        xsltGenericError(xsltGenericErrorContext,\n+            \"xsltForEach(): Bad arguments.\\n\");\n+        return;\n@@ -5527,2 +5425,2 @@\n-        \"Internal error in xsltForEach(): \"\n-        \"The XSLT 'for-each' instruction was not compiled.\\n\");\n+            \"Internal error in xsltForEach(): \"\n+            \"The XSLT 'for-each' instruction was not compiled.\\n\");\n@@ -5532,5 +5430,5 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-        \"Internal error in xsltForEach(): \"\n-        \"The selecting expression of the XSLT 'for-each' \"\n-        \"instruction was not compiled correctly.\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+            \"Internal error in xsltForEach(): \"\n+            \"The selecting expression of the XSLT 'for-each' \"\n+            \"instruction was not compiled correctly.\\n\");\n+        return;\n@@ -5542,1 +5440,1 @@\n-     \"xsltForEach: select %s\\n\", comp->select));\n+         \"xsltForEach: select %s\\n\", comp->select));\n@@ -5568,5 +5466,5 @@\n-    if (res->type == XPATH_NODESET)\n-        list = res->nodesetval;\n-    else {\n-        xsltTransformError(ctxt, NULL, inst,\n-        \"The 'select' expression does not evaluate to a node set.\\n\");\n+        if (res->type == XPATH_NODESET)\n+            list = res->nodesetval;\n+        else {\n+            xsltTransformError(ctxt, NULL, inst,\n+                \"The 'select' expression does not evaluate to a node set.\\n\");\n@@ -5575,2 +5473,2 @@\n-        XSLT_TRACE(ctxt,XSLT_TRACE_FOR_EACH,xsltGenericDebug(xsltGenericDebugContext,\n-        \"xsltForEach: select didn't evaluate to a node list\\n\"));\n+            XSLT_TRACE(ctxt,XSLT_TRACE_FOR_EACH,xsltGenericDebug(xsltGenericDebugContext,\n+                \"xsltForEach: select didn't evaluate to a node list\\n\"));\n@@ -5578,2 +5476,2 @@\n-        goto error;\n-    }\n+            goto error;\n+        }\n@@ -5581,4 +5479,4 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-        \"Failed to evaluate the 'select' expression.\\n\");\n-    ctxt->state = XSLT_STATE_STOPPED;\n-    goto error;\n+        xsltTransformError(ctxt, NULL, inst,\n+            \"Failed to evaluate the 'select' expression.\\n\");\n+        ctxt->state = XSLT_STATE_STOPPED;\n+        goto error;\n@@ -5588,1 +5486,1 @@\n-    goto exit;\n+        goto exit;\n@@ -5592,1 +5490,1 @@\n-    \"xsltForEach: select evaluates to %d nodes\\n\", list->nodeNr));\n+        \"xsltForEach: select evaluates to %d nodes\\n\", list->nodeNr));\n@@ -5606,2 +5504,2 @@\n-    int nbsorts = 0;\n-    xmlNodePtr sorts[XSLT_MAX_SORT];\n+        int nbsorts = 0;\n+        xmlNodePtr sorts[XSLT_MAX_SORT];\n@@ -5609,1 +5507,1 @@\n-    sorts[nbsorts++] = curInst;\n+        sorts[nbsorts++] = curInst;\n@@ -5612,2 +5510,2 @@\n-    if (xslDebugStatus != XSLT_DEBUG_NONE)\n-        xslHandleDebugger(curInst, contextNode, NULL, ctxt);\n+        if (xslDebugStatus != XSLT_DEBUG_NONE)\n+            xslHandleDebugger(curInst, contextNode, NULL, ctxt);\n@@ -5616,11 +5514,11 @@\n-    curInst = curInst->next;\n-    while (IS_XSLT_ELEM(curInst) && IS_XSLT_NAME(curInst, \"sort\")) {\n-        if (nbsorts >= XSLT_MAX_SORT) {\n-        xsltTransformError(ctxt, NULL, curInst,\n-            \"The number of xsl:sort instructions exceeds the \"\n-            \"maximum (%d) allowed by this processor.\\n\",\n-            XSLT_MAX_SORT);\n-        goto error;\n-        } else {\n-        sorts[nbsorts++] = curInst;\n-        }\n+        curInst = curInst->next;\n+        while (IS_XSLT_ELEM(curInst) && IS_XSLT_NAME(curInst, \"sort\")) {\n+            if (nbsorts >= XSLT_MAX_SORT) {\n+                xsltTransformError(ctxt, NULL, curInst,\n+                    \"The number of xsl:sort instructions exceeds the \"\n+                    \"maximum (%d) allowed by this processor.\\n\",\n+                    XSLT_MAX_SORT);\n+                goto error;\n+            } else {\n+                sorts[nbsorts++] = curInst;\n+            }\n@@ -5629,2 +5527,2 @@\n-        if (xslDebugStatus != XSLT_DEBUG_NONE)\n-        xslHandleDebugger(curInst, contextNode, NULL, ctxt);\n+            if (xslDebugStatus != XSLT_DEBUG_NONE)\n+                xslHandleDebugger(curInst, contextNode, NULL, ctxt);\n@@ -5632,3 +5530,3 @@\n-        curInst = curInst->next;\n-    }\n-    xsltDoSortFunction(ctxt, sorts, nbsorts);\n+            curInst = curInst->next;\n+        }\n+        xsltDoSortFunction(ctxt, sorts, nbsorts);\n@@ -5641,11 +5539,11 @@\n-    cur = list->nodeTab[i];\n-    \/*\n-    * The selected node becomes the \"current node\".\n-    *\/\n-    ctxt->node = cur;\n-    \/*\n-    * An xsl:for-each can change the current context doc.\n-    * OPTIMIZE TODO: Get rid of the need to set the context doc.\n-    *\/\n-    if ((cur->type != XML_NAMESPACE_DECL) && (cur->doc != NULL))\n-        xpctxt->doc = cur->doc;\n+        cur = list->nodeTab[i];\n+        \/*\n+        * The selected node becomes the \"current node\".\n+        *\/\n+        ctxt->node = cur;\n+        \/*\n+        * An xsl:for-each can change the current context doc.\n+        * OPTIMIZE TODO: Get rid of the need to set the context doc.\n+        *\/\n+        if ((cur->type != XML_NAMESPACE_DECL) && (cur->doc != NULL))\n+            xpctxt->doc = cur->doc;\n@@ -5653,1 +5551,1 @@\n-    xpctxt->proximityPosition = i + 1;\n+        xpctxt->proximityPosition = i + 1;\n@@ -5655,1 +5553,1 @@\n-    xsltApplySequenceConstructor(ctxt, cur, curInst, NULL);\n+        xsltApplySequenceConstructor(ctxt, cur, curInst, NULL);\n@@ -5661,1 +5559,1 @@\n-    xmlXPathFreeObject(res);\n+        xmlXPathFreeObject(res);\n@@ -5676,3 +5574,3 @@\n- *                                  *\n- *          Generic interface               *\n- *                                  *\n+ *                                                                      *\n+ *                      Generic interface                               *\n+ *                                                                      *\n@@ -5720,1 +5618,1 @@\n-                const xmlChar **systemID) {\n+                    const xmlChar **systemID) {\n@@ -5723,1 +5621,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5725,9 +5623,9 @@\n-     i++) {\n-    if (!xmlStrcasecmp(version,\n-                   (const xmlChar *) xsltHTMLVersions[i].version)) {\n-        if (publicID != NULL)\n-        *publicID = (const xmlChar *) xsltHTMLVersions[i].public;\n-        if (systemID != NULL)\n-        *systemID = (const xmlChar *) xsltHTMLVersions[i].system;\n-        return(0);\n-    }\n+         i++) {\n+        if (!xmlStrcasecmp(version,\n+                           (const xmlChar *) xsltHTMLVersions[i].version)) {\n+            if (publicID != NULL)\n+                *publicID = (const xmlChar *) xsltHTMLVersions[i].public;\n+            if (systemID != NULL)\n+                *systemID = (const xmlChar *) xsltHTMLVersions[i].system;\n+            return(0);\n+        }\n@@ -5756,7 +5654,7 @@\n-    \/*\n-     * Cleanup children empty nodes if asked for\n-     *\/\n-    if ((IS_XSLT_REAL_NODE(current)) &&\n-        (current->children != NULL) &&\n-        (xsltFindElemSpaceHandling(ctxt, current))) {\n-        xmlNodePtr delete = NULL, cur = current->children;\n+        \/*\n+         * Cleanup children empty nodes if asked for\n+         *\/\n+        if ((IS_XSLT_REAL_NODE(current)) &&\n+            (current->children != NULL) &&\n+            (xsltFindElemSpaceHandling(ctxt, current))) {\n+            xmlNodePtr delete = NULL, cur = current->children;\n@@ -5764,3 +5662,3 @@\n-        while (cur != NULL) {\n-        if (IS_BLANK_NODE(cur))\n-            delete = cur;\n+            while (cur != NULL) {\n+                if (IS_BLANK_NODE(cur))\n+                    delete = cur;\n@@ -5768,5 +5666,5 @@\n-        cur = cur->next;\n-        if (delete != NULL) {\n-            xmlUnlinkNode(delete);\n-            xmlFreeNode(delete);\n-            delete = NULL;\n+                cur = cur->next;\n+                if (delete != NULL) {\n+                    xmlUnlinkNode(delete);\n+                    xmlFreeNode(delete);\n+                    delete = NULL;\n@@ -5774,1 +5672,1 @@\n-            nb++;\n+                    nb++;\n@@ -5776,0 +5674,2 @@\n+                }\n+            }\n@@ -5777,2 +5677,0 @@\n-        }\n-    }\n@@ -5780,8 +5678,8 @@\n-    \/*\n-     * Skip to next node in document order.\n-     *\/\n-    if (node->type == XML_ENTITY_REF_NODE) {\n-        \/* process deep in entities *\/\n-        xsltApplyStripSpaces(ctxt, node->children);\n-    }\n-    if ((current->children != NULL) &&\n+        \/*\n+         * Skip to next node in document order.\n+         *\/\n+        if (node->type == XML_ENTITY_REF_NODE) {\n+            \/* process deep in entities *\/\n+            xsltApplyStripSpaces(ctxt, node->children);\n+        }\n+        if ((current->children != NULL) &&\n@@ -5789,11 +5687,2 @@\n-        current = current->children;\n-    } else if (current->next != NULL) {\n-        current = current->next;\n-    } else {\n-        do {\n-        current = current->parent;\n-        if (current == NULL)\n-            break;\n-        if (current == node)\n-            goto done;\n-        if (current->next != NULL) {\n+            current = current->children;\n+        } else if (current->next != NULL) {\n@@ -5801,1 +5690,12 @@\n-            break;\n+        } else {\n+            do {\n+                current = current->parent;\n+                if (current == NULL)\n+                    break;\n+                if (current == node)\n+                    goto done;\n+                if (current->next != NULL) {\n+                    current = current->next;\n+                    break;\n+                }\n+            } while (current != NULL);\n@@ -5803,2 +5703,0 @@\n-        } while (current != NULL);\n-    }\n@@ -5810,1 +5708,1 @@\n-         \"xsltApplyStripSpaces: removed %d ignorable blank node\\n\", nb));\n+             \"xsltApplyStripSpaces: removed %d ignorable blank node\\n\", nb));\n@@ -5822,1 +5720,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5830,5 +5728,5 @@\n-    if (style->keyMatch != NULL) {\n-        ctxt->hasTemplKeyPatterns = 1;\n-        break;\n-    }\n-    style = xsltNextImport(style);\n+        if (style->keyMatch != NULL) {\n+            ctxt->hasTemplKeyPatterns = 1;\n+            break;\n+        }\n+        style = xsltNextImport(style);\n@@ -5842,6 +5740,6 @@\n-    keyd = style->keys;\n-    while (keyd) {\n-        ctxt->nbKeys++;\n-        keyd = keyd->next;\n-    }\n-    style = xsltNextImport(style);\n+        keyd = style->keys;\n+        while (keyd) {\n+            ctxt->nbKeys++;\n+            keyd = keyd->next;\n+        }\n+        style = xsltNextImport(style);\n@@ -5889,2 +5787,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"Stylesheet was not fully internalized !\\n\");\n+        xsltGenericDebug(xsltGenericDebugContext,\n+                         \"Stylesheet was not fully internalized !\\n\");\n@@ -5894,14 +5792,14 @@\n-    \/*\n-     * Avoid hitting the DTD when scanning nodes\n-     * but keep it linked as doc->intSubset\n-     *\/\n-    xmlNodePtr cur = (xmlNodePtr) doc->intSubset;\n-    if (cur->next != NULL)\n-        cur->next->prev = cur->prev;\n-    if (cur->prev != NULL)\n-        cur->prev->next = cur->next;\n-    if (doc->children == cur)\n-        doc->children = cur->next;\n-    if (doc->last == cur)\n-        doc->last = cur->prev;\n-    cur->prev = cur->next = NULL;\n+        \/*\n+         * Avoid hitting the DTD when scanning nodes\n+         * but keep it linked as doc->intSubset\n+         *\/\n+        xmlNodePtr cur = (xmlNodePtr) doc->intSubset;\n+        if (cur->next != NULL)\n+            cur->next->prev = cur->prev;\n+        if (cur->prev != NULL)\n+            cur->prev->next = cur->next;\n+        if (doc->children == cur)\n+            doc->children = cur->next;\n+        if (doc->last == cur)\n+            doc->last = cur->prev;\n+        cur->prev = cur->next = NULL;\n@@ -5915,1 +5813,1 @@\n-    if (((ptrdiff_t) root->content >= 0) &&\n+        if (((ptrdiff_t) root->content >= 0) &&\n@@ -5917,1 +5815,1 @@\n-        xmlXPathOrderDocElems(doc);\n+            xmlXPathOrderDocElems(doc);\n@@ -5921,1 +5819,1 @@\n-    ctxt = userCtxt;\n+        ctxt = userCtxt;\n@@ -5923,1 +5821,1 @@\n-    ctxt = xsltNewTransformContext(style, doc);\n+        ctxt = xsltNewTransformContext(style, doc);\n@@ -5952,1 +5850,1 @@\n-        ctxt->mode = xmlDictLookup(ctxt->dict, ctxt->mode, -1);\n+            ctxt->mode = xmlDictLookup(ctxt->dict, ctxt->mode, -1);\n@@ -5954,1 +5852,1 @@\n-        ctxt->modeURI = xmlDictLookup(ctxt->dict, ctxt->modeURI, -1);\n+            ctxt->modeURI = xmlDictLookup(ctxt->dict, ctxt->modeURI, -1);\n@@ -5964,1 +5862,1 @@\n-    (!xmlStrEqual(method, (const xmlChar *) \"xml\")))\n+        (!xmlStrEqual(method, (const xmlChar *) \"xml\")))\n@@ -5970,1 +5868,1 @@\n-        } else {\n+            } else {\n@@ -5972,1 +5870,1 @@\n-            xmlDtdPtr dtd;\n+                    xmlDtdPtr dtd;\n@@ -5974,14 +5872,14 @@\n-            res = htmlNewDoc(NULL, NULL);\n-            \/*\n-            * Make sure no DTD node is generated in this case\n-            *\/\n-            if (res != NULL) {\n-            dtd = xmlGetIntSubset(res);\n-            if (dtd != NULL) {\n-                xmlUnlinkNode((xmlNodePtr) dtd);\n-                xmlFreeDtd(dtd);\n-            }\n-            res->intSubset = NULL;\n-            res->extSubset = NULL;\n-            }\n-        } else {\n+                    res = htmlNewDoc(NULL, NULL);\n+                    \/*\n+                    * Make sure no DTD node is generated in this case\n+                    *\/\n+                    if (res != NULL) {\n+                        dtd = xmlGetIntSubset(res);\n+                        if (dtd != NULL) {\n+                            xmlUnlinkNode((xmlNodePtr) dtd);\n+                            xmlFreeDtd(dtd);\n+                        }\n+                        res->intSubset = NULL;\n+                        res->extSubset = NULL;\n+                    }\n+                } else {\n@@ -5990,1 +5888,1 @@\n-            xsltGetHTMLIDs(version, &doctypePublic, &doctypeSystem);\n+                    xsltGetHTMLIDs(version, &doctypePublic, &doctypeSystem);\n@@ -5992,2 +5890,2 @@\n-            res = htmlNewDoc(doctypeSystem, doctypePublic);\n-        }\n+                    res = htmlNewDoc(doctypeSystem, doctypePublic);\n+                }\n@@ -5997,2 +5895,2 @@\n-        res->dict = ctxt->dict;\n-        xmlDictReference(res->dict);\n+            res->dict = ctxt->dict;\n+            xmlDictReference(res->dict);\n@@ -6001,2 +5899,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-        \"reusing transformation dict for output\\n\");\n+            xsltGenericDebug(xsltGenericDebugContext,\n+                \"reusing transformation dict for output\\n\");\n@@ -6005,2 +5903,2 @@\n-        xsltTransformError(ctxt, NULL, (xmlNodePtr) doc,\n-        \"xsltApplyStylesheetInternal: unsupported method xhtml, using html\\n\");\n+            xsltTransformError(ctxt, NULL, (xmlNodePtr) doc,\n+                \"xsltApplyStylesheetInternal: unsupported method xhtml, using html\\n\");\n@@ -6011,2 +5909,2 @@\n-        res->dict = ctxt->dict;\n-        xmlDictReference(res->dict);\n+            res->dict = ctxt->dict;\n+            xmlDictReference(res->dict);\n@@ -6015,2 +5913,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-        \"reusing transformation dict for output\\n\");\n+            xsltGenericDebug(xsltGenericDebugContext,\n+                \"reusing transformation dict for output\\n\");\n@@ -6023,2 +5921,2 @@\n-        res->dict = ctxt->dict;\n-        xmlDictReference(res->dict);\n+            res->dict = ctxt->dict;\n+            xmlDictReference(res->dict);\n@@ -6027,2 +5925,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-        \"reusing transformation dict for output\\n\");\n+            xsltGenericDebug(xsltGenericDebugContext,\n+                \"reusing transformation dict for output\\n\");\n@@ -6031,3 +5929,3 @@\n-        xsltTransformError(ctxt, NULL, (xmlNodePtr) doc,\n-        \"xsltApplyStylesheetInternal: unsupported method (%s)\\n\",\n-        method);\n+            xsltTransformError(ctxt, NULL, (xmlNodePtr) doc,\n+                \"xsltApplyStylesheetInternal: unsupported method (%s)\\n\",\n+                method);\n@@ -6041,2 +5939,2 @@\n-    res->dict = ctxt->dict;\n-    xmlDictReference(ctxt->dict);\n+        res->dict = ctxt->dict;\n+        xmlDictReference(ctxt->dict);\n@@ -6044,2 +5942,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"reusing transformation dict for output\\n\");\n+        xsltGenericDebug(xsltGenericDebugContext,\n+                         \"reusing transformation dict for output\\n\");\n@@ -6065,1 +5963,1 @@\n-    xsltApplyStripSpaces(ctxt, xmlDocGetRootElement(doc));\n+        xsltApplyStripSpaces(ctxt, xmlDocGetRootElement(doc));\n@@ -6070,1 +5968,1 @@\n-    ctxt->globalVars = xmlHashCreate(20);\n+        ctxt->globalVars = xmlHashCreate(20);\n@@ -6144,3 +6042,3 @@\n-        doctype = xmlDictQLookup(ctxt->dict, root->ns->prefix, root->name);\n-    if (doctype == NULL)\n-        doctype = root->name;\n+            doctype = xmlDictQLookup(ctxt->dict, root->ns->prefix, root->name);\n+        if (doctype == NULL)\n+            doctype = root->name;\n@@ -6162,1 +6060,1 @@\n-        tmp = tmp->next;\n+                tmp = tmp->next;\n@@ -6166,4 +6064,4 @@\n-        \/*\n-        * REVISIT TODO: XML_HTML_DOCUMENT_NODE is set after the\n-        *  transformation on the doc, but functions like\n-        *\/\n+                \/*\n+                * REVISIT TODO: XML_HTML_DOCUMENT_NODE is set after the\n+                *  transformation on the doc, but functions like\n+                *\/\n@@ -6176,1 +6074,1 @@\n-        } else if (version != NULL) {\n+                } else if (version != NULL) {\n@@ -6193,7 +6091,7 @@\n-            xmlNodePtr last;\n-        \/* Need a small \"hack\" here to assure DTD comes before\n-           possible comment nodes *\/\n-        node = res->children;\n-        last = res->last;\n-        res->children = NULL;\n-        res->last = NULL;\n+                xmlNodePtr last;\n+                \/* Need a small \"hack\" here to assure DTD comes before\n+                   possible comment nodes *\/\n+                node = res->children;\n+                last = res->last;\n+                res->children = NULL;\n+                res->last = NULL;\n@@ -6203,9 +6101,9 @@\n-        if (res->children != NULL) {\n-            res->children->next = node;\n-            node->prev = res->children;\n-            res->last = last;\n-        } else {\n-            res->children = node;\n-            res->last = last;\n-        }\n-        }\n+                if (res->children != NULL) {\n+                    res->children->next = node;\n+                    node->prev = res->children;\n+                    res->last = last;\n+                } else {\n+                    res->children = node;\n+                    res->last = last;\n+                }\n+            }\n@@ -6226,2 +6124,2 @@\n-    xmlFreeDoc(res);\n-    res = NULL;\n+        xmlFreeDoc(res);\n+        res = NULL;\n@@ -6230,12 +6128,12 @@\n-    int ret;\n-\n-    ret = xsltCheckWrite(ctxt->sec, ctxt, (const xmlChar *) output);\n-    if (ret == 0) {\n-        xsltTransformError(ctxt, NULL, NULL,\n-             \"xsltApplyStylesheet: forbidden to save to %s\\n\",\n-                   output);\n-    } else if (ret < 0) {\n-        xsltTransformError(ctxt, NULL, NULL,\n-             \"xsltApplyStylesheet: saving to %s may not be possible\\n\",\n-                   output);\n-    }\n+        int ret;\n+\n+        ret = xsltCheckWrite(ctxt->sec, ctxt, (const xmlChar *) output);\n+        if (ret == 0) {\n+            xsltTransformError(ctxt, NULL, NULL,\n+                     \"xsltApplyStylesheet: forbidden to save to %s\\n\",\n+                               output);\n+        } else if (ret < 0) {\n+            xsltTransformError(ctxt, NULL, NULL,\n+                     \"xsltApplyStylesheet: saving to %s may not be possible\\n\",\n+                               output);\n+        }\n@@ -6251,1 +6149,1 @@\n-    xsltFreeTransformContext(ctxt);\n+        xsltFreeTransformContext(ctxt);\n@@ -6332,1 +6230,1 @@\n-                                  profile, userCtxt);\n+                                      profile, userCtxt);\n@@ -6366,1 +6264,1 @@\n-          FILE * profile, xsltTransformContextPtr userCtxt)\n+                  FILE * profile, xsltTransformContextPtr userCtxt)\n@@ -6379,1 +6277,1 @@\n-    return (-1);\n+        return (-1);\n@@ -6383,1 +6281,1 @@\n-                                  userCtxt);\n+                                      userCtxt);\n@@ -6385,1 +6283,1 @@\n-    xsltTransformError(NULL, NULL, (xmlNodePtr) doc,\n+        xsltTransformError(NULL, NULL, (xmlNodePtr) doc,\n@@ -6429,1 +6327,1 @@\n-                         NULL, NULL));\n+                                 NULL, NULL));\n@@ -6449,1 +6347,1 @@\n-               xsltApplyTemplates);\n+                           xsltApplyTemplates);\n@@ -6452,1 +6350,1 @@\n-               xsltApplyImports);\n+                           xsltApplyImports);\n@@ -6455,1 +6353,1 @@\n-               xsltCallTemplate);\n+                           xsltCallTemplate);\n@@ -6458,1 +6356,1 @@\n-               xsltElement);\n+                           xsltElement);\n@@ -6461,1 +6359,1 @@\n-               xsltAttribute);\n+                           xsltAttribute);\n@@ -6464,1 +6362,1 @@\n-               xsltText);\n+                           xsltText);\n@@ -6467,1 +6365,1 @@\n-               xsltProcessingInstruction);\n+                           xsltProcessingInstruction);\n@@ -6470,1 +6368,1 @@\n-               xsltComment);\n+                           xsltComment);\n@@ -6473,1 +6371,1 @@\n-               xsltCopy);\n+                           xsltCopy);\n@@ -6476,1 +6374,1 @@\n-               xsltValueOf);\n+                           xsltValueOf);\n@@ -6479,1 +6377,1 @@\n-               xsltNumber);\n+                           xsltNumber);\n@@ -6482,1 +6380,1 @@\n-               xsltForEach);\n+                           xsltForEach);\n@@ -6485,1 +6383,1 @@\n-               xsltIf);\n+                           xsltIf);\n@@ -6488,1 +6386,1 @@\n-               xsltChoose);\n+                           xsltChoose);\n@@ -6491,1 +6389,1 @@\n-               xsltSort);\n+                           xsltSort);\n@@ -6494,1 +6392,1 @@\n-               xsltCopyOf);\n+                           xsltCopyOf);\n@@ -6497,1 +6395,1 @@\n-               xsltMessageWrapper);\n+                           xsltMessageWrapper);\n@@ -6504,1 +6402,1 @@\n-               xsltDebug);\n+                           xsltDebug);\n@@ -6507,1 +6405,1 @@\n-               xsltDebug);\n+                           xsltDebug);\n@@ -6510,1 +6408,1 @@\n-               xsltDebug);\n+                           xsltDebug);\n@@ -6513,1 +6411,1 @@\n-               xsltDebug);\n+                           xsltDebug);\n@@ -6516,1 +6414,1 @@\n-               xsltDebug);\n+                           xsltDebug);\n@@ -6519,1 +6417,1 @@\n-               xsltDebug);\n+                           xsltDebug);\n@@ -6522,1 +6420,1 @@\n-               xsltDebug);\n+                           xsltDebug);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/transform.c","additions":2545,"deletions":2647,"binary":false,"changes":5192,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-        xsltSetXIncludeDefault  (int xinclude);\n+                xsltSetXIncludeDefault  (int xinclude);\n@@ -30,1 +30,1 @@\n-        xsltGetXIncludeDefault  (void);\n+                xsltGetXIncludeDefault  (void);\n@@ -36,2 +36,2 @@\n-        xsltNewTransformContext (xsltStylesheetPtr style,\n-                     xmlDocPtr doc);\n+                xsltNewTransformContext (xsltStylesheetPtr style,\n+                                         xmlDocPtr doc);\n@@ -40,1 +40,1 @@\n-        xsltFreeTransformContext(xsltTransformContextPtr ctxt);\n+                xsltFreeTransformContext(xsltTransformContextPtr ctxt);\n@@ -43,6 +43,6 @@\n-        xsltApplyStylesheetUser (xsltStylesheetPtr style,\n-                     xmlDocPtr doc,\n-                     const char **params,\n-                     const char *output,\n-                     FILE * profile,\n-                     xsltTransformContextPtr userCtxt);\n+                xsltApplyStylesheetUser (xsltStylesheetPtr style,\n+                                         xmlDocPtr doc,\n+                                         const char **params,\n+                                         const char *output,\n+                                         FILE * profile,\n+                                         xsltTransformContextPtr userCtxt);\n@@ -57,2 +57,2 @@\n-        xsltApplyStripSpaces    (xsltTransformContextPtr ctxt,\n-                     xmlNodePtr node);\n+                xsltApplyStripSpaces    (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node);\n@@ -60,3 +60,3 @@\n-        xsltApplyStylesheet (xsltStylesheetPtr style,\n-                     xmlDocPtr doc,\n-                     const char **params);\n+                xsltApplyStylesheet     (xsltStylesheetPtr style,\n+                                         xmlDocPtr doc,\n+                                         const char **params);\n@@ -64,4 +64,4 @@\n-        xsltProfileStylesheet   (xsltStylesheetPtr style,\n-                     xmlDocPtr doc,\n-                     const char **params,\n-                     FILE * output);\n+                xsltProfileStylesheet   (xsltStylesheetPtr style,\n+                                         xmlDocPtr doc,\n+                                         const char **params,\n+                                         FILE * output);\n@@ -69,6 +69,6 @@\n-        xsltRunStylesheet   (xsltStylesheetPtr style,\n-                     xmlDocPtr doc,\n-                     const char **params,\n-                     const char *output,\n-                     xmlSAXHandlerPtr SAX,\n-                     xmlOutputBufferPtr IObuf);\n+                xsltRunStylesheet       (xsltStylesheetPtr style,\n+                                         xmlDocPtr doc,\n+                                         const char **params,\n+                                         const char *output,\n+                                         xmlSAXHandlerPtr SAX,\n+                                         xmlOutputBufferPtr IObuf);\n@@ -76,101 +76,101 @@\n-        xsltRunStylesheetUser   (xsltStylesheetPtr style,\n-                     xmlDocPtr doc,\n-                     const char **params,\n-                     const char *output,\n-                     xmlSAXHandlerPtr SAX,\n-                     xmlOutputBufferPtr IObuf,\n-                     FILE * profile,\n-                     xsltTransformContextPtr userCtxt);\n-XSLTPUBFUN void XSLTCALL\n-        xsltApplyOneTemplate    (xsltTransformContextPtr ctxt,\n-                     xmlNodePtr node,\n-                     xmlNodePtr list,\n-                     xsltTemplatePtr templ,\n-                     xsltStackElemPtr params);\n-XSLTPUBFUN void XSLTCALL\n-        xsltDocumentElem    (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltSort        (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltCopy        (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltText        (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltElement     (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltComment     (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltAttribute       (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltProcessingInstruction(xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltCopyOf      (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltValueOf     (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltNumber      (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltApplyImports    (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltCallTemplate    (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltApplyTemplates  (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltChoose      (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltIf          (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltForEach     (xsltTransformContextPtr ctxt,\n-                                     xmlNodePtr node,\n-                     xmlNodePtr inst,\n-                     xsltElemPreCompPtr comp);\n-XSLTPUBFUN void XSLTCALL\n-        xsltRegisterAllElement  (xsltTransformContextPtr ctxt);\n+                xsltRunStylesheetUser   (xsltStylesheetPtr style,\n+                                         xmlDocPtr doc,\n+                                         const char **params,\n+                                         const char *output,\n+                                         xmlSAXHandlerPtr SAX,\n+                                         xmlOutputBufferPtr IObuf,\n+                                         FILE * profile,\n+                                         xsltTransformContextPtr userCtxt);\n+XSLTPUBFUN void XSLTCALL\n+                xsltApplyOneTemplate    (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr list,\n+                                         xsltTemplatePtr templ,\n+                                         xsltStackElemPtr params);\n+XSLTPUBFUN void XSLTCALL\n+                xsltDocumentElem        (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltSort                (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltCopy                (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltText                (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltElement             (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltComment             (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltAttribute           (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltProcessingInstruction(xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltCopyOf              (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltValueOf             (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltNumber              (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltApplyImports        (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltCallTemplate        (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltApplyTemplates      (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltChoose              (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltIf                  (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltForEach             (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr node,\n+                                         xmlNodePtr inst,\n+                                         xsltElemPreCompPtr comp);\n+XSLTPUBFUN void XSLTCALL\n+                xsltRegisterAllElement  (xsltTransformContextPtr ctxt);\n@@ -179,4 +179,4 @@\n-        xsltCopyTextString  (xsltTransformContextPtr ctxt,\n-                     xmlNodePtr target,\n-                     const xmlChar *string,\n-                     int noescape);\n+                xsltCopyTextString      (xsltTransformContextPtr ctxt,\n+                                         xmlNodePtr target,\n+                                         const xmlChar *string,\n+                                         int noescape);\n@@ -186,3 +186,3 @@\n-        xsltLocalVariablePop    (xsltTransformContextPtr ctxt,\n-                     int limitNr,\n-                     int level);\n+                xsltLocalVariablePop    (xsltTransformContextPtr ctxt,\n+                                         int limitNr,\n+                                         int level);\n@@ -190,3 +190,3 @@\n-        xsltLocalVariablePush   (xsltTransformContextPtr ctxt,\n-                     xsltStackElemPtr variable,\n-                     int level);\n+                xsltLocalVariablePush   (xsltTransformContextPtr ctxt,\n+                                         xsltStackElemPtr variable,\n+                                         int level);\n@@ -197,4 +197,4 @@\n-        xslHandleDebugger   (xmlNodePtr cur,\n-                     xmlNodePtr node,\n-                     xsltTemplatePtr templ,\n-                     xsltTransformContextPtr ctxt);\n+                xslHandleDebugger       (xmlNodePtr cur,\n+                                         xmlNodePtr node,\n+                                         xsltTemplatePtr templ,\n+                                         xsltTransformContextPtr ctxt);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/transform.h","additions":141,"deletions":141,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-                 TRIO_CONST char *format, ...));\n+                             TRIO_CONST char *format, ...));\n@@ -95,1 +95,1 @@\n-                  TRIO_CONST char *format, va_list args));\n+                              TRIO_CONST char *format, va_list args));\n@@ -97,1 +97,1 @@\n-                  TRIO_CONST char *format, void **args));\n+                              TRIO_CONST char *format, void **args));\n@@ -105,1 +105,1 @@\n-           va_list args));\n+                   va_list args));\n@@ -107,1 +107,1 @@\n-           void **args));\n+                   void **args));\n@@ -135,1 +135,1 @@\n-                TRIO_CONST char *format, ...));\n+                            TRIO_CONST char *format, ...));\n@@ -137,1 +137,1 @@\n-                 TRIO_CONST char *format, va_list args));\n+                             TRIO_CONST char *format, va_list args));\n@@ -139,1 +139,1 @@\n-                 TRIO_CONST char *format, void **args));\n+                             TRIO_CONST char *format, void **args));\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/trio.h","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,3 +51,3 @@\n- *                                  *\n- *  Result Value Tree (Result Tree Fragment) interfaces         *\n- *                                  *\n+ *                                                                      *\n+ *  Result Value Tree (Result Tree Fragment) interfaces                 *\n+ *                                                                      *\n@@ -74,1 +74,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -80,7 +80,7 @@\n-    container = ctxt->cache->RVT;\n-    ctxt->cache->RVT = (xmlDocPtr) container->next;\n-    \/* clear the internal pointers *\/\n-    container->next = NULL;\n-    container->prev = NULL;\n-    if (ctxt->cache->nbRVT > 0)\n-        ctxt->cache->nbRVT--;\n+        container = ctxt->cache->RVT;\n+        ctxt->cache->RVT = (xmlDocPtr) container->next;\n+        \/* clear the internal pointers *\/\n+        container->next = NULL;\n+        container->prev = NULL;\n+        if (ctxt->cache->nbRVT > 0)\n+            ctxt->cache->nbRVT--;\n@@ -88,1 +88,1 @@\n-    ctxt->cache->dbgReusedRVTs++;\n+        ctxt->cache->dbgReusedRVTs++;\n@@ -90,1 +90,1 @@\n-    return(container);\n+        return(container);\n@@ -95,1 +95,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -123,1 +123,1 @@\n-    return(-1);\n+        return(-1);\n@@ -134,3 +134,3 @@\n-    RVT->next = (xmlNodePtr) XSLT_TCTXT_VARIABLE(ctxt)->fragment;\n-    XSLT_TCTXT_VARIABLE(ctxt)->fragment = RVT;\n-    return(0);\n+        RVT->next = (xmlNodePtr) XSLT_TCTXT_VARIABLE(ctxt)->fragment;\n+        XSLT_TCTXT_VARIABLE(ctxt)->fragment = RVT;\n+        return(0);\n@@ -141,1 +141,1 @@\n-    ctxt->tmpRVT->prev = (xmlNodePtr) RVT;\n+        ctxt->tmpRVT->prev = (xmlNodePtr) RVT;\n@@ -160,1 +160,1 @@\n-             xmlDocPtr RVT)\n+                     xmlDocPtr RVT)\n@@ -163,1 +163,1 @@\n-    return(-1);\n+        return(-1);\n@@ -175,1 +175,1 @@\n-    (XSLT_TCTXT_VARIABLE(ctxt)->flags & XSLT_VAR_IN_SELECT))\n+        (XSLT_TCTXT_VARIABLE(ctxt)->flags & XSLT_VAR_IN_SELECT))\n@@ -177,3 +177,3 @@\n-    RVT->next = (xmlNodePtr) XSLT_TCTXT_VARIABLE(ctxt)->fragment;\n-    XSLT_TCTXT_VARIABLE(ctxt)->fragment = RVT;\n-    return(0);\n+        RVT->next = (xmlNodePtr) XSLT_TCTXT_VARIABLE(ctxt)->fragment;\n+        XSLT_TCTXT_VARIABLE(ctxt)->fragment = RVT;\n+        return(0);\n@@ -188,1 +188,1 @@\n-    ctxt->localRVT->prev = (xmlNodePtr) RVT;\n+        ctxt->localRVT->prev = (xmlNodePtr) RVT;\n@@ -236,1 +236,1 @@\n-    xmlXPathObjectPtr obj ATTRIBUTE_UNUSED)\n+        xmlXPathObjectPtr obj ATTRIBUTE_UNUSED)\n@@ -264,1 +264,1 @@\n-    return(-1);\n+        return(-1);\n@@ -273,1 +273,1 @@\n-    return(0);\n+        return(0);\n@@ -275,1 +275,1 @@\n-    return(0);\n+        return(0);\n@@ -278,11 +278,17 @@\n-    cur = obj->nodesetval->nodeTab[i];\n-    if (cur->type == XML_NAMESPACE_DECL) {\n-        \/*\n-        * The XPath module sets the owner element of a ns-node on\n-        * the ns->next field.\n-        *\/\n-        if ((((xmlNsPtr) cur)->next != NULL) &&\n-        (((xmlNsPtr) cur)->next->type == XML_ELEMENT_NODE))\n-        {\n-        cur = (xmlNodePtr) ((xmlNsPtr) cur)->next;\n-        doc = cur->doc;\n+        cur = obj->nodesetval->nodeTab[i];\n+        if (cur->type == XML_NAMESPACE_DECL) {\n+            \/*\n+            * The XPath module sets the owner element of a ns-node on\n+            * the ns->next field.\n+            *\/\n+            if ((((xmlNsPtr) cur)->next != NULL) &&\n+                (((xmlNsPtr) cur)->next->type == XML_ELEMENT_NODE))\n+            {\n+                cur = (xmlNodePtr) ((xmlNsPtr) cur)->next;\n+                doc = cur->doc;\n+            } else {\n+                xsltTransformError(ctxt, NULL, ctxt->inst,\n+                    \"Internal error in xsltFlagRVTs(): \"\n+                    \"Cannot retrieve the doc of a namespace node.\\n\");\n+                return(-1);\n+            }\n@@ -290,4 +296,1 @@\n-        xsltTransformError(ctxt, NULL, ctxt->inst,\n-            \"Internal error in xsltFlagRVTs(): \"\n-            \"Cannot retrieve the doc of a namespace node.\\n\");\n-        return(-1);\n+            doc = cur->doc;\n@@ -295,10 +298,7 @@\n-    } else {\n-        doc = cur->doc;\n-    }\n-    if (doc == NULL) {\n-        xsltTransformError(ctxt, NULL, ctxt->inst,\n-        \"Internal error in xsltFlagRVTs(): \"\n-        \"Cannot retrieve the doc of a node.\\n\");\n-        return(-1);\n-    }\n-    if (doc->name && (doc->name[0] == ' ') &&\n+        if (doc == NULL) {\n+            xsltTransformError(ctxt, NULL, ctxt->inst,\n+                \"Internal error in xsltFlagRVTs(): \"\n+                \"Cannot retrieve the doc of a node.\\n\");\n+            return(-1);\n+        }\n+        if (doc->name && (doc->name[0] == ' ') &&\n@@ -306,6 +306,6 @@\n-        \/*\n-        * This is a result tree fragment.\n-        * We store ownership information in the @psvi field.\n-        * TODO: How do we know if this is a doc acquired via the\n-        *  document() function?\n-        *\/\n+            \/*\n+            * This is a result tree fragment.\n+            * We store ownership information in the @psvi field.\n+            * TODO: How do we know if this is a doc acquired via the\n+            *  document() function?\n+            *\/\n@@ -322,1 +322,1 @@\n-            xmlGenericError(xmlGenericErrorContext,\n+                    xmlGenericError(xmlGenericErrorContext,\n@@ -332,1 +332,1 @@\n-            doc->psvi = val;\n+                doc->psvi = val;\n@@ -334,1 +334,1 @@\n-    }\n+        }\n@@ -352,1 +352,1 @@\n-    return;\n+        return;\n@@ -355,26 +355,26 @@\n-    \/*\n-    * Store the Result Tree Fragment.\n-    * Free the document info.\n-    *\/\n-    if (RVT->_private != NULL) {\n-        xsltFreeDocumentKeys((xsltDocumentPtr) RVT->_private);\n-        xmlFree(RVT->_private);\n-        RVT->_private = NULL;\n-    }\n-    \/*\n-    * Clear the document tree.\n-    * REVISIT TODO: Do we expect ID\/IDREF tables to be existent?\n-    *\/\n-    if (RVT->children != NULL) {\n-        xmlFreeNodeList(RVT->children);\n-        RVT->children = NULL;\n-        RVT->last = NULL;\n-    }\n-    if (RVT->ids != NULL) {\n-        xmlFreeIDTable((xmlIDTablePtr) RVT->ids);\n-        RVT->ids = NULL;\n-    }\n-    if (RVT->refs != NULL) {\n-        xmlFreeRefTable((xmlRefTablePtr) RVT->refs);\n-        RVT->refs = NULL;\n-    }\n+        \/*\n+        * Store the Result Tree Fragment.\n+        * Free the document info.\n+        *\/\n+        if (RVT->_private != NULL) {\n+            xsltFreeDocumentKeys((xsltDocumentPtr) RVT->_private);\n+            xmlFree(RVT->_private);\n+            RVT->_private = NULL;\n+        }\n+        \/*\n+        * Clear the document tree.\n+        * REVISIT TODO: Do we expect ID\/IDREF tables to be existent?\n+        *\/\n+        if (RVT->children != NULL) {\n+            xmlFreeNodeList(RVT->children);\n+            RVT->children = NULL;\n+            RVT->last = NULL;\n+        }\n+        if (RVT->ids != NULL) {\n+            xmlFreeIDTable((xmlIDTablePtr) RVT->ids);\n+            RVT->ids = NULL;\n+        }\n+        if (RVT->refs != NULL) {\n+            xmlFreeRefTable((xmlRefTablePtr) RVT->refs);\n+            RVT->refs = NULL;\n+        }\n@@ -382,4 +382,4 @@\n-    \/*\n-    * Reset the ownership information.\n-    *\/\n-    RVT->psvi = NULL;\n+        \/*\n+        * Reset the ownership information.\n+        *\/\n+        RVT->psvi = NULL;\n@@ -387,2 +387,2 @@\n-    RVT->next = (xmlNodePtr) ctxt->cache->RVT;\n-    ctxt->cache->RVT = RVT;\n+        RVT->next = (xmlNodePtr) ctxt->cache->RVT;\n+        ctxt->cache->RVT = RVT;\n@@ -390,1 +390,1 @@\n-    ctxt->cache->nbRVT++;\n+        ctxt->cache->nbRVT++;\n@@ -393,1 +393,1 @@\n-    ctxt->cache->dbgCachedRVTs++;\n+        ctxt->cache->dbgCachedRVTs++;\n@@ -395,1 +395,1 @@\n-    return;\n+        return;\n@@ -401,2 +401,2 @@\n-    xsltFreeDocumentKeys((xsltDocumentPtr) RVT->_private);\n-    xmlFree(RVT->_private);\n+        xsltFreeDocumentKeys((xsltDocumentPtr) RVT->_private);\n+        xmlFree(RVT->_private);\n@@ -428,1 +428,1 @@\n-    ctxt->persistRVT->prev = (xmlNodePtr) RVT;\n+        ctxt->persistRVT->prev = (xmlNodePtr) RVT;\n@@ -447,1 +447,1 @@\n-    return;\n+        return;\n@@ -454,6 +454,6 @@\n-    if (cur->_private != NULL) {\n-        xsltFreeDocumentKeys(cur->_private);\n-        xmlFree(cur->_private);\n-    }\n-    xmlFreeDoc(cur);\n-    cur = next;\n+        if (cur->_private != NULL) {\n+            xsltFreeDocumentKeys(cur->_private);\n+            xmlFree(cur->_private);\n+        }\n+        xmlFreeDoc(cur);\n+        cur = next;\n@@ -468,6 +468,6 @@\n-    if (cur->_private != NULL) {\n-        xsltFreeDocumentKeys(cur->_private);\n-        xmlFree(cur->_private);\n-    }\n-    xmlFreeDoc(cur);\n-    cur = next;\n+        if (cur->_private != NULL) {\n+            xsltFreeDocumentKeys(cur->_private);\n+            xmlFree(cur->_private);\n+        }\n+        xmlFreeDoc(cur);\n+        cur = next;\n@@ -482,6 +482,6 @@\n-    if (cur->_private != NULL) {\n-        xsltFreeDocumentKeys(cur->_private);\n-        xmlFree(cur->_private);\n-    }\n-    xmlFreeDoc(cur);\n-    cur = next;\n+        if (cur->_private != NULL) {\n+            xsltFreeDocumentKeys(cur->_private);\n+            xmlFree(cur->_private);\n+        }\n+        xmlFreeDoc(cur);\n+        cur = next;\n@@ -493,3 +493,3 @@\n- *                                  *\n- *          Module interfaces               *\n- *                                  *\n+ *                                                                      *\n+ *                      Module interfaces                               *\n+ *                                                                      *\n@@ -513,4 +513,4 @@\n-    ret = ctxt->cache->stackItems;\n-    ctxt->cache->stackItems = ret->next;\n-    ret->next = NULL;\n-    ctxt->cache->nbStackItems--;\n+        ret = ctxt->cache->stackItems;\n+        ctxt->cache->stackItems = ret->next;\n+        ret->next = NULL;\n+        ctxt->cache->nbStackItems--;\n@@ -518,1 +518,1 @@\n-    ctxt->cache->dbgReusedVars++;\n+        ctxt->cache->dbgReusedVars++;\n@@ -520,1 +520,1 @@\n-    return(ret);\n+        return(ret);\n@@ -524,3 +524,3 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltNewStackElem : malloc failed\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, NULL,\n+                \"xsltNewStackElem : malloc failed\\n\");\n+        return(NULL);\n@@ -547,3 +547,3 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltCopyStackElem : malloc failed\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, NULL,\n+                \"xsltCopyStackElem : malloc failed\\n\");\n+        return(NULL);\n@@ -570,1 +570,1 @@\n-    return;\n+        return;\n@@ -572,1 +572,1 @@\n-    xmlXPathFreeObject(elem->value);\n+        xmlXPathFreeObject(elem->value);\n@@ -577,1 +577,1 @@\n-    xmlDocPtr cur;\n+        xmlDocPtr cur;\n@@ -579,3 +579,3 @@\n-    while (elem->fragment != NULL) {\n-        cur = elem->fragment;\n-        elem->fragment = (xmlDocPtr) cur->next;\n+        while (elem->fragment != NULL) {\n+            cur = elem->fragment;\n+            elem->fragment = (xmlDocPtr) cur->next;\n@@ -584,1 +584,1 @@\n-        xsltReleaseRVT(elem->context, cur);\n+                xsltReleaseRVT(elem->context, cur);\n@@ -593,1 +593,1 @@\n-    }\n+        }\n@@ -599,9 +599,9 @@\n-    \/*\n-    * Store the item in the cache.\n-    *\/\n-    xsltTransformContextPtr ctxt = elem->context;\n-    memset(elem, 0, sizeof(xsltStackElem));\n-    elem->context = ctxt;\n-    elem->next = ctxt->cache->stackItems;\n-    ctxt->cache->stackItems = elem;\n-    ctxt->cache->nbStackItems++;\n+        \/*\n+        * Store the item in the cache.\n+        *\/\n+        xsltTransformContextPtr ctxt = elem->context;\n+        memset(elem, 0, sizeof(xsltStackElem));\n+        elem->context = ctxt;\n+        elem->next = ctxt->cache->stackItems;\n+        ctxt->cache->stackItems = elem;\n+        ctxt->cache->nbStackItems++;\n@@ -609,1 +609,1 @@\n-    ctxt->cache->dbgCachedVars++;\n+        ctxt->cache->dbgCachedVars++;\n@@ -611,1 +611,1 @@\n-    return;\n+        return;\n@@ -633,3 +633,3 @@\n-    next = elem->next;\n-    xsltFreeStackElem(elem);\n-    elem = next;\n+        next = elem->next;\n+        xsltFreeStackElem(elem);\n+        elem = next;\n@@ -654,1 +654,1 @@\n-            const xmlChar *nameURI) {\n+                const xmlChar *nameURI) {\n@@ -659,1 +659,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -668,3 +668,3 @@\n-    cur = ctxt->varsTab[i-1];\n-    while (cur != NULL) {\n-        if ((cur->name == name) && (cur->nameURI == nameURI)) {\n+        cur = ctxt->varsTab[i-1];\n+        while (cur != NULL) {\n+            if ((cur->name == name) && (cur->nameURI == nameURI)) {\n@@ -672,1 +672,1 @@\n-        stack_addr++;\n+                stack_addr++;\n@@ -674,1 +674,3 @@\n-        return(cur);\n+                return(cur);\n+            }\n+            cur = cur->next;\n@@ -676,2 +678,0 @@\n-        cur = cur->next;\n-    }\n@@ -689,3 +689,3 @@\n-    cur = ctxt->varsTab[i-1];\n-    while (cur != NULL) {\n-        if ((cur->name == name) && (cur->nameURI == nameURI)) {\n+        cur = ctxt->varsTab[i-1];\n+        while (cur != NULL) {\n+            if ((cur->name == name) && (cur->nameURI == nameURI)) {\n@@ -693,1 +693,1 @@\n-        stack_cmp++;\n+                stack_cmp++;\n@@ -695,1 +695,3 @@\n-        return(cur);\n+                return(cur);\n+            }\n+            cur = cur->next;\n@@ -697,2 +699,0 @@\n-        cur = cur->next;\n-    }\n@@ -723,1 +723,1 @@\n-               const xmlChar *nameURI) {\n+                   const xmlChar *nameURI) {\n@@ -727,1 +727,1 @@\n-    return(-1);\n+        return(-1);\n@@ -734,3 +734,3 @@\n-        return(3);\n-    else if (cur->comp->type == XSLT_FUNC_PARAM)\n-        return(2);\n+            return(3);\n+        else if (cur->comp->type == XSLT_FUNC_PARAM)\n+            return(2);\n@@ -760,1 +760,1 @@\n-    return(-1);\n+        return(-1);\n@@ -763,8 +763,9 @@\n-    if (ctxt->varsMax == 0) {\n-        ctxt->varsMax = 10;\n-        ctxt->varsTab =\n-        (xsltStackElemPtr *) xmlMalloc(ctxt->varsMax *\n-        sizeof(ctxt->varsTab[0]));\n-        if (ctxt->varsTab == NULL) {\n-        xmlGenericError(xmlGenericErrorContext, \"malloc failed !\\n\");\n-        return (-1);\n+        if (ctxt->varsMax == 0) {\n+            ctxt->varsMax = 10;\n+            ctxt->varsTab =\n+                (xsltStackElemPtr *) xmlMalloc(ctxt->varsMax *\n+                sizeof(ctxt->varsTab[0]));\n+            if (ctxt->varsTab == NULL) {\n+                xmlGenericError(xmlGenericErrorContext, \"malloc failed !\\n\");\n+                return (-1);\n+            }\n@@ -772,10 +773,10 @@\n-    }\n-    if (ctxt->varsNr >= ctxt->varsMax) {\n-        ctxt->varsMax *= 2;\n-        ctxt->varsTab =\n-        (xsltStackElemPtr *) xmlRealloc(ctxt->varsTab,\n-        ctxt->varsMax *\n-        sizeof(ctxt->varsTab[0]));\n-        if (ctxt->varsTab == NULL) {\n-        xmlGenericError(xmlGenericErrorContext, \"realloc failed !\\n\");\n-        return (-1);\n+        if (ctxt->varsNr >= ctxt->varsMax) {\n+            ctxt->varsMax *= 2;\n+            ctxt->varsTab =\n+                (xsltStackElemPtr *) xmlRealloc(ctxt->varsTab,\n+                ctxt->varsMax *\n+                sizeof(ctxt->varsTab[0]));\n+            if (ctxt->varsTab == NULL) {\n+                xmlGenericError(xmlGenericErrorContext, \"realloc failed !\\n\");\n+                return (-1);\n+            }\n@@ -783,3 +784,2 @@\n-    }\n-    ctxt->varsTab[ctxt->varsNr++] = elem;\n-    ctxt->vars = elem;\n+        ctxt->varsTab[ctxt->varsNr++] = elem;\n+        ctxt->vars = elem;\n@@ -787,1 +787,1 @@\n-    elem = elem->next;\n+        elem = elem->next;\n@@ -809,3 +809,3 @@\n- *                                  *\n- *          Module interfaces               *\n- *                                  *\n+ *                                                                      *\n+ *                      Module interfaces                               *\n+ *                                                                      *\n@@ -826,1 +826,1 @@\n-             xsltStylePreCompPtr castedComp)\n+                 xsltStylePreCompPtr castedComp)\n@@ -830,1 +830,1 @@\n-    (xsltStyleItemVariablePtr) castedComp;\n+        (xsltStyleItemVariablePtr) castedComp;\n@@ -838,1 +838,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -849,1 +849,1 @@\n-    \"Evaluating variable '%s'\\n\", variable->name));\n+        \"Evaluating variable '%s'\\n\", variable->name));\n@@ -852,49 +852,7 @@\n-    xmlXPathCompExprPtr xpExpr = NULL;\n-    xmlDocPtr oldXPDoc;\n-    xmlNodePtr oldXPContextNode;\n-    int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;\n-    xmlNsPtr *oldXPNamespaces;\n-    xmlXPathContextPtr xpctxt = ctxt->xpathCtxt;\n-    xsltStackElemPtr oldVar = ctxt->contextVariable;\n-\n-    if ((comp != NULL) && (comp->comp != NULL)) {\n-        xpExpr = comp->comp;\n-    } else {\n-        xpExpr = xmlXPathCtxtCompile(ctxt->xpathCtxt, variable->select);\n-    }\n-    if (xpExpr == NULL)\n-        return(NULL);\n-    \/*\n-    * Save context states.\n-    *\/\n-    oldXPDoc = xpctxt->doc;\n-    oldXPContextNode = xpctxt->node;\n-    oldXPProximityPosition = xpctxt->proximityPosition;\n-    oldXPContextSize = xpctxt->contextSize;\n-    oldXPNamespaces = xpctxt->namespaces;\n-    oldXPNsNr = xpctxt->nsNr;\n-\n-    xpctxt->node = ctxt->node;\n-    \/*\n-    * OPTIMIZE TODO: Lame try to set the context doc.\n-    *   Get rid of this somehow in xpath.c.\n-    *\/\n-    if ((ctxt->node->type != XML_NAMESPACE_DECL) &&\n-        ctxt->node->doc)\n-        xpctxt->doc = ctxt->node->doc;\n-    \/*\n-    * BUG TODO: The proximity position and the context size will\n-    *  potentially be wrong.\n-    *  Example:\n-    *  <xsl:template select=\"foo\">\n-    *    <xsl:variable name=\"pos\" select=\"position()\"\/>\n-    *    <xsl:for-each select=\"bar\">\n-    *      <xsl:value-of select=\"$pos\"\/>\n-    *    <\/xsl:for-each>\n-    *  <\/xsl:template>\n-    *  Here the proximity position and context size are changed\n-    *  to the context of <xsl:for-each select=\"bar\">, but\n-    *  the variable needs to be evaluated in the context of\n-    *  <xsl:template select=\"foo\">.\n-    *\/\n-    if (comp != NULL) {\n+        xmlXPathCompExprPtr xpExpr = NULL;\n+        xmlDocPtr oldXPDoc;\n+        xmlNodePtr oldXPContextNode;\n+        int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;\n+        xmlNsPtr *oldXPNamespaces;\n+        xmlXPathContextPtr xpctxt = ctxt->xpathCtxt;\n+        xsltStackElemPtr oldVar = ctxt->contextVariable;\n@@ -902,4 +860,2 @@\n-#ifdef XSLT_REFACTORED\n-        if (comp->inScopeNs != NULL) {\n-        xpctxt->namespaces = comp->inScopeNs->list;\n-        xpctxt->nsNr = comp->inScopeNs->xpathNumber;\n+        if ((comp != NULL) && (comp->comp != NULL)) {\n+            xpExpr = comp->comp;\n@@ -907,2 +863,1 @@\n-        xpctxt->namespaces = NULL;\n-        xpctxt->nsNr = 0;\n+            xpExpr = xmlXPathCtxtCompile(ctxt->xpathCtxt, variable->select);\n@@ -910,63 +865,2 @@\n-#else\n-        xpctxt->namespaces = comp->nsList;\n-        xpctxt->nsNr = comp->nsNr;\n-#endif\n-    } else {\n-        xpctxt->namespaces = NULL;\n-        xpctxt->nsNr = 0;\n-    }\n-\n-    \/*\n-    * We need to mark that we are \"selecting\" a var's value;\n-    * if any tree fragments are created inside the expression,\n-    * then those need to be stored inside the variable; otherwise\n-    * we'll eventually free still referenced fragments, before\n-    * we leave the scope of the variable.\n-    *\/\n-    ctxt->contextVariable = variable;\n-    variable->flags |= XSLT_VAR_IN_SELECT;\n-\n-    result = xmlXPathCompiledEval(xpExpr, xpctxt);\n-\n-    variable->flags ^= XSLT_VAR_IN_SELECT;\n-    \/*\n-    * Restore Context states.\n-    *\/\n-    ctxt->contextVariable = oldVar;\n-\n-    xpctxt->doc = oldXPDoc;\n-    xpctxt->node = oldXPContextNode;\n-    xpctxt->contextSize = oldXPContextSize;\n-    xpctxt->proximityPosition = oldXPProximityPosition;\n-    xpctxt->namespaces = oldXPNamespaces;\n-    xpctxt->nsNr = oldXPNsNr;\n-\n-    if ((comp == NULL) || (comp->comp == NULL))\n-        xmlXPathFreeCompExpr(xpExpr);\n-    if (result == NULL) {\n-        xsltTransformError(ctxt, NULL,\n-        (comp != NULL) ? comp->inst : NULL,\n-        \"Failed to evaluate the expression of variable '%s'.\\n\",\n-        variable->name);\n-        ctxt->state = XSLT_STATE_STOPPED;\n-\n-#ifdef WITH_XSLT_DEBUG_VARIABLE\n-#ifdef LIBXML_DEBUG_ENABLED\n-    } else {\n-        if ((xsltGenericDebugContext == stdout) ||\n-        (xsltGenericDebugContext == stderr))\n-        xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,\n-                    result, 0);\n-#endif\n-#endif\n-    }\n-    } else {\n-    if (variable->tree == NULL) {\n-        result = xmlXPathNewCString(\"\");\n-    } else {\n-        if (variable->tree) {\n-        xmlDocPtr container;\n-        xmlNodePtr oldInsert;\n-        xmlDocPtr  oldOutput;\n-        xsltStackElemPtr oldVar = ctxt->contextVariable;\n-\n+        if (xpExpr == NULL)\n+            return(NULL);\n@@ -974,1 +868,1 @@\n-        * Generate a result tree fragment.\n+        * Save context states.\n@@ -976,3 +870,8 @@\n-        container = xsltCreateRVT(ctxt);\n-        if (container == NULL)\n-            goto error;\n+        oldXPDoc = xpctxt->doc;\n+        oldXPContextNode = xpctxt->node;\n+        oldXPProximityPosition = xpctxt->proximityPosition;\n+        oldXPContextSize = xpctxt->contextSize;\n+        oldXPNamespaces = xpctxt->namespaces;\n+        oldXPNsNr = xpctxt->nsNr;\n+\n+        xpctxt->node = ctxt->node;\n@@ -980,5 +879,2 @@\n-        * NOTE: Local Result Tree Fragments of params\/variables\n-        * are not registered globally anymore; the life-time\n-        * is not directly dependant of the param\/variable itself.\n-        *\n-        * OLD: xsltRegisterTmpRVT(ctxt, container);\n+        * OPTIMIZE TODO: Lame try to set the context doc.\n+        *   Get rid of this somehow in xpath.c.\n@@ -986,0 +882,3 @@\n+        if ((ctxt->node->type != XML_NAMESPACE_DECL) &&\n+            ctxt->node->doc)\n+            xpctxt->doc = ctxt->node->doc;\n@@ -987,3 +886,13 @@\n-        * Attach the Result Tree Fragment to the variable;\n-        * when the variable is freed, it will also free\n-        * the Result Tree Fragment.\n+        * BUG TODO: The proximity position and the context size will\n+        *  potentially be wrong.\n+        *  Example:\n+        *  <xsl:template select=\"foo\">\n+        *    <xsl:variable name=\"pos\" select=\"position()\"\/>\n+        *    <xsl:for-each select=\"bar\">\n+        *      <xsl:value-of select=\"$pos\"\/>\n+        *    <\/xsl:for-each>\n+        *  <\/xsl:template>\n+        *  Here the proximity position and context size are changed\n+        *  to the context of <xsl:for-each select=\"bar\">, but\n+        *  the variable needs to be evaluated in the context of\n+        *  <xsl:template select=\"foo\">.\n@@ -991,2 +900,1 @@\n-        variable->fragment = container;\n-                container->psvi = XSLT_RVT_LOCAL;\n+        if (comp != NULL) {\n@@ -994,2 +902,16 @@\n-        oldOutput = ctxt->output;\n-        oldInsert = ctxt->insert;\n+#ifdef XSLT_REFACTORED\n+            if (comp->inScopeNs != NULL) {\n+                xpctxt->namespaces = comp->inScopeNs->list;\n+                xpctxt->nsNr = comp->inScopeNs->xpathNumber;\n+            } else {\n+                xpctxt->namespaces = NULL;\n+                xpctxt->nsNr = 0;\n+            }\n+#else\n+            xpctxt->namespaces = comp->nsList;\n+            xpctxt->nsNr = comp->nsNr;\n+#endif\n+        } else {\n+            xpctxt->namespaces = NULL;\n+            xpctxt->nsNr = 0;\n+        }\n@@ -997,3 +919,0 @@\n-        ctxt->output = container;\n-        ctxt->insert = (xmlNodePtr) container;\n-        ctxt->contextVariable = variable;\n@@ -1001,2 +920,5 @@\n-        * Process the sequence constructor (variable->tree).\n-        * The resulting tree will be held by @container.\n+        * We need to mark that we are \"selecting\" a var's value;\n+        * if any tree fragments are created inside the expression,\n+        * then those need to be stored inside the variable; otherwise\n+        * we'll eventually free still referenced fragments, before\n+        * we leave the scope of the variable.\n@@ -1004,2 +926,2 @@\n-        xsltApplyOneTemplate(ctxt, ctxt->node, variable->tree,\n-            NULL, NULL);\n+        ctxt->contextVariable = variable;\n+        variable->flags |= XSLT_VAR_IN_SELECT;\n@@ -1007,0 +929,6 @@\n+        result = xmlXPathCompiledEval(xpExpr, xpctxt);\n+\n+        variable->flags ^= XSLT_VAR_IN_SELECT;\n+        \/*\n+        * Restore Context states.\n+        *\/\n@@ -1008,2 +936,0 @@\n-        ctxt->insert = oldInsert;\n-        ctxt->output = oldOutput;\n@@ -1011,2 +937,9 @@\n-        result = xmlXPathNewValueTree((xmlNodePtr) container);\n-        }\n+        xpctxt->doc = oldXPDoc;\n+        xpctxt->node = oldXPContextNode;\n+        xpctxt->contextSize = oldXPContextSize;\n+        xpctxt->proximityPosition = oldXPProximityPosition;\n+        xpctxt->namespaces = oldXPNamespaces;\n+        xpctxt->nsNr = oldXPNsNr;\n+\n+        if ((comp == NULL) || (comp->comp == NULL))\n+            xmlXPathFreeCompExpr(xpExpr);\n@@ -1014,1 +947,8 @@\n-        result = xmlXPathNewCString(\"\");\n+            xsltTransformError(ctxt, NULL,\n+                (comp != NULL) ? comp->inst : NULL,\n+                \"Failed to evaluate the expression of variable '%s'.\\n\",\n+                variable->name);\n+            ctxt->state = XSLT_STATE_STOPPED;\n+\n+#ifdef WITH_XSLT_DEBUG_VARIABLE\n+#ifdef LIBXML_DEBUG_ENABLED\n@@ -1016,5 +956,6 @@\n-        \/*\n-        * Freeing is not handled there anymore.\n-        * QUESTION TODO: What does the above comment mean?\n-        *\/\n-            result->boolval = 0;\n+            if ((xsltGenericDebugContext == stdout) ||\n+                (xsltGenericDebugContext == stderr))\n+                xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,\n+                                        result, 0);\n+#endif\n+#endif\n@@ -1022,0 +963,59 @@\n+    } else {\n+        if (variable->tree == NULL) {\n+            result = xmlXPathNewCString(\"\");\n+        } else {\n+            if (variable->tree) {\n+                xmlDocPtr container;\n+                xmlNodePtr oldInsert;\n+                xmlDocPtr  oldOutput;\n+                xsltStackElemPtr oldVar = ctxt->contextVariable;\n+\n+                \/*\n+                * Generate a result tree fragment.\n+                *\/\n+                container = xsltCreateRVT(ctxt);\n+                if (container == NULL)\n+                    goto error;\n+                \/*\n+                * NOTE: Local Result Tree Fragments of params\/variables\n+                * are not registered globally anymore; the life-time\n+                * is not directly dependant of the param\/variable itself.\n+                *\n+                * OLD: xsltRegisterTmpRVT(ctxt, container);\n+                *\/\n+                \/*\n+                * Attach the Result Tree Fragment to the variable;\n+                * when the variable is freed, it will also free\n+                * the Result Tree Fragment.\n+                *\/\n+                variable->fragment = container;\n+                container->psvi = XSLT_RVT_LOCAL;\n+\n+                oldOutput = ctxt->output;\n+                oldInsert = ctxt->insert;\n+\n+                ctxt->output = container;\n+                ctxt->insert = (xmlNodePtr) container;\n+                ctxt->contextVariable = variable;\n+                \/*\n+                * Process the sequence constructor (variable->tree).\n+                * The resulting tree will be held by @container.\n+                *\/\n+                xsltApplyOneTemplate(ctxt, ctxt->node, variable->tree,\n+                    NULL, NULL);\n+\n+                ctxt->contextVariable = oldVar;\n+                ctxt->insert = oldInsert;\n+                ctxt->output = oldOutput;\n+\n+                result = xmlXPathNewValueTree((xmlNodePtr) container);\n+            }\n+            if (result == NULL) {\n+                result = xmlXPathNewCString(\"\");\n+            } else {\n+                \/*\n+                * Freeing is not handled there anymore.\n+                * QUESTION TODO: What does the above comment mean?\n+                *\/\n+                result->boolval = 0;\n+            }\n@@ -1025,4 +1025,4 @@\n-        if ((xsltGenericDebugContext == stdout) ||\n-        (xsltGenericDebugContext == stderr))\n-        xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,\n-                    result, 0);\n+            if ((xsltGenericDebugContext == stdout) ||\n+                (xsltGenericDebugContext == stderr))\n+                xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,\n+                                        result, 0);\n@@ -1031,1 +1031,1 @@\n-    }\n+        }\n@@ -1063,1 +1063,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1065,1 +1065,1 @@\n-    return(elem->value);\n+        return(elem->value);\n@@ -1070,1 +1070,1 @@\n-    \"Evaluating global variable %s\\n\", elem->name));\n+        \"Evaluating global variable %s\\n\", elem->name));\n@@ -1094,14 +1094,6 @@\n-    xmlXPathCompExprPtr xpExpr = NULL;\n-    xmlDocPtr oldXPDoc;\n-    xmlNodePtr oldXPContextNode;\n-    int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;\n-    xmlNsPtr *oldXPNamespaces;\n-    xmlXPathContextPtr xpctxt = ctxt->xpathCtxt;\n-\n-    if ((comp != NULL) && (comp->comp != NULL)) {\n-        xpExpr = comp->comp;\n-    } else {\n-        xpExpr = xmlXPathCtxtCompile(ctxt->xpathCtxt, elem->select);\n-    }\n-    if (xpExpr == NULL)\n-        goto error;\n+        xmlXPathCompExprPtr xpExpr = NULL;\n+        xmlDocPtr oldXPDoc;\n+        xmlNodePtr oldXPContextNode;\n+        int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;\n+        xmlNsPtr *oldXPNamespaces;\n+        xmlXPathContextPtr xpctxt = ctxt->xpathCtxt;\n@@ -1109,0 +1101,7 @@\n+        if ((comp != NULL) && (comp->comp != NULL)) {\n+            xpExpr = comp->comp;\n+        } else {\n+            xpExpr = xmlXPathCtxtCompile(ctxt->xpathCtxt, elem->select);\n+        }\n+        if (xpExpr == NULL)\n+            goto error;\n@@ -1110,22 +1109,0 @@\n-    if (comp != NULL)\n-        ctxt->inst = comp->inst;\n-    else\n-        ctxt->inst = NULL;\n-    \/*\n-    * SPEC XSLT 1.0:\n-    * \"At top-level, the expression or template specifying the\n-    *  variable value is evaluated with the same context as that used\n-    *  to process the root node of the source document: the current\n-    *  node is the root node of the source document and the current\n-    *  node list is a list containing just the root node of the source\n-    *  document.\"\n-    *\/\n-    \/*\n-    * Save context states.\n-    *\/\n-    oldXPDoc = xpctxt->doc;\n-    oldXPContextNode = xpctxt->node;\n-    oldXPProximityPosition = xpctxt->proximityPosition;\n-    oldXPContextSize = xpctxt->contextSize;\n-    oldXPNamespaces = xpctxt->namespaces;\n-    oldXPNsNr = xpctxt->nsNr;\n@@ -1133,4 +1110,27 @@\n-    xpctxt->node = ctxt->initialContextNode;\n-    xpctxt->doc = ctxt->initialContextDoc;\n-    xpctxt->contextSize = 1;\n-    xpctxt->proximityPosition = 1;\n+        if (comp != NULL)\n+            ctxt->inst = comp->inst;\n+        else\n+            ctxt->inst = NULL;\n+        \/*\n+        * SPEC XSLT 1.0:\n+        * \"At top-level, the expression or template specifying the\n+        *  variable value is evaluated with the same context as that used\n+        *  to process the root node of the source document: the current\n+        *  node is the root node of the source document and the current\n+        *  node list is a list containing just the root node of the source\n+        *  document.\"\n+        *\/\n+        \/*\n+        * Save context states.\n+        *\/\n+        oldXPDoc = xpctxt->doc;\n+        oldXPContextNode = xpctxt->node;\n+        oldXPProximityPosition = xpctxt->proximityPosition;\n+        oldXPContextSize = xpctxt->contextSize;\n+        oldXPNamespaces = xpctxt->namespaces;\n+        oldXPNsNr = xpctxt->nsNr;\n+\n+        xpctxt->node = ctxt->initialContextNode;\n+        xpctxt->doc = ctxt->initialContextDoc;\n+        xpctxt->contextSize = 1;\n+        xpctxt->proximityPosition = 1;\n@@ -1138,1 +1138,1 @@\n-    if (comp != NULL) {\n+        if (comp != NULL) {\n@@ -1141,7 +1141,7 @@\n-        if (comp->inScopeNs != NULL) {\n-        xpctxt->namespaces = comp->inScopeNs->list;\n-        xpctxt->nsNr = comp->inScopeNs->xpathNumber;\n-        } else {\n-        xpctxt->namespaces = NULL;\n-        xpctxt->nsNr = 0;\n-        }\n+            if (comp->inScopeNs != NULL) {\n+                xpctxt->namespaces = comp->inScopeNs->list;\n+                xpctxt->nsNr = comp->inScopeNs->xpathNumber;\n+            } else {\n+                xpctxt->namespaces = NULL;\n+                xpctxt->nsNr = 0;\n+            }\n@@ -1149,2 +1149,2 @@\n-        xpctxt->namespaces = comp->nsList;\n-        xpctxt->nsNr = comp->nsNr;\n+            xpctxt->namespaces = comp->nsList;\n+            xpctxt->nsNr = comp->nsNr;\n@@ -1152,4 +1152,4 @@\n-    } else {\n-        xpctxt->namespaces = NULL;\n-        xpctxt->nsNr = 0;\n-    }\n+        } else {\n+            xpctxt->namespaces = NULL;\n+            xpctxt->nsNr = 0;\n+        }\n@@ -1157,1 +1157,1 @@\n-    result = xmlXPathCompiledEval(xpExpr, xpctxt);\n+        result = xmlXPathCompiledEval(xpExpr, xpctxt);\n@@ -1159,20 +1159,20 @@\n-    \/*\n-    * Restore Context states.\n-    *\/\n-    xpctxt->doc = oldXPDoc;\n-    xpctxt->node = oldXPContextNode;\n-    xpctxt->contextSize = oldXPContextSize;\n-    xpctxt->proximityPosition = oldXPProximityPosition;\n-    xpctxt->namespaces = oldXPNamespaces;\n-    xpctxt->nsNr = oldXPNsNr;\n-\n-    if ((comp == NULL) || (comp->comp == NULL))\n-        xmlXPathFreeCompExpr(xpExpr);\n-    if (result == NULL) {\n-        if (comp == NULL)\n-        xsltTransformError(ctxt, NULL, NULL,\n-            \"Evaluating global variable %s failed\\n\", elem->name);\n-        else\n-        xsltTransformError(ctxt, NULL, comp->inst,\n-            \"Evaluating global variable %s failed\\n\", elem->name);\n-        ctxt->state = XSLT_STATE_STOPPED;\n+        \/*\n+        * Restore Context states.\n+        *\/\n+        xpctxt->doc = oldXPDoc;\n+        xpctxt->node = oldXPContextNode;\n+        xpctxt->contextSize = oldXPContextSize;\n+        xpctxt->proximityPosition = oldXPProximityPosition;\n+        xpctxt->namespaces = oldXPNamespaces;\n+        xpctxt->nsNr = oldXPNsNr;\n+\n+        if ((comp == NULL) || (comp->comp == NULL))\n+            xmlXPathFreeCompExpr(xpExpr);\n+        if (result == NULL) {\n+            if (comp == NULL)\n+                xsltTransformError(ctxt, NULL, NULL,\n+                    \"Evaluating global variable %s failed\\n\", elem->name);\n+            else\n+                xsltTransformError(ctxt, NULL, comp->inst,\n+                    \"Evaluating global variable %s failed\\n\", elem->name);\n+            ctxt->state = XSLT_STATE_STOPPED;\n@@ -1190,4 +1190,4 @@\n-    if ((xsltGenericDebugContext == stdout) ||\n-        (xsltGenericDebugContext == stderr))\n-        xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,\n-                    result, 0);\n+        if ((xsltGenericDebugContext == stdout) ||\n+            (xsltGenericDebugContext == stderr))\n+            xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,\n+                                    result, 0);\n@@ -1197,40 +1197,2 @@\n-    if (elem->tree == NULL) {\n-        result = xmlXPathNewCString(\"\");\n-    } else {\n-        xmlDocPtr container;\n-        xmlNodePtr oldInsert;\n-        xmlDocPtr  oldOutput, oldXPDoc;\n-        \/*\n-        * Generate a result tree fragment.\n-        *\/\n-        container = xsltCreateRVT(ctxt);\n-        if (container == NULL)\n-        goto error;\n-        \/*\n-        * Let the lifetime of the tree fragment be handled by\n-        * the Libxslt's garbage collector.\n-        *\/\n-        xsltRegisterPersistRVT(ctxt, container);\n-\n-        oldOutput = ctxt->output;\n-        oldInsert = ctxt->insert;\n-\n-        oldXPDoc = ctxt->xpathCtxt->doc;\n-\n-        ctxt->output = container;\n-        ctxt->insert = (xmlNodePtr) container;\n-\n-        ctxt->xpathCtxt->doc = ctxt->initialContextDoc;\n-        \/*\n-        * Process the sequence constructor.\n-        *\/\n-        xsltApplyOneTemplate(ctxt, ctxt->node, elem->tree, NULL, NULL);\n-\n-        ctxt->xpathCtxt->doc = oldXPDoc;\n-\n-        ctxt->insert = oldInsert;\n-        ctxt->output = oldOutput;\n-\n-        result = xmlXPathNewValueTree((xmlNodePtr) container);\n-        if (result == NULL) {\n-        result = xmlXPathNewCString(\"\");\n+        if (elem->tree == NULL) {\n+            result = xmlXPathNewCString(\"\");\n@@ -1238,2 +1200,40 @@\n-            result->boolval = 0; \/* Freeing is not handled there anymore *\/\n-        }\n+            xmlDocPtr container;\n+            xmlNodePtr oldInsert;\n+            xmlDocPtr  oldOutput, oldXPDoc;\n+            \/*\n+            * Generate a result tree fragment.\n+            *\/\n+            container = xsltCreateRVT(ctxt);\n+            if (container == NULL)\n+                goto error;\n+            \/*\n+            * Let the lifetime of the tree fragment be handled by\n+            * the Libxslt's garbage collector.\n+            *\/\n+            xsltRegisterPersistRVT(ctxt, container);\n+\n+            oldOutput = ctxt->output;\n+            oldInsert = ctxt->insert;\n+\n+            oldXPDoc = ctxt->xpathCtxt->doc;\n+\n+            ctxt->output = container;\n+            ctxt->insert = (xmlNodePtr) container;\n+\n+            ctxt->xpathCtxt->doc = ctxt->initialContextDoc;\n+            \/*\n+            * Process the sequence constructor.\n+            *\/\n+            xsltApplyOneTemplate(ctxt, ctxt->node, elem->tree, NULL, NULL);\n+\n+            ctxt->xpathCtxt->doc = oldXPDoc;\n+\n+            ctxt->insert = oldInsert;\n+            ctxt->output = oldOutput;\n+\n+            result = xmlXPathNewValueTree((xmlNodePtr) container);\n+            if (result == NULL) {\n+                result = xmlXPathNewCString(\"\");\n+            } else {\n+                result->boolval = 0; \/* Freeing is not handled there anymore *\/\n+            }\n@@ -1242,4 +1242,4 @@\n-        if ((xsltGenericDebugContext == stdout) ||\n-        (xsltGenericDebugContext == stderr))\n-        xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,\n-                    result, 0);\n+            if ((xsltGenericDebugContext == stdout) ||\n+                (xsltGenericDebugContext == stderr))\n+                xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,\n+                                        result, 0);\n@@ -1248,1 +1248,1 @@\n-    }\n+        }\n@@ -1255,2 +1255,2 @@\n-    elem->value = result;\n-    elem->computed = 1;\n+        elem->value = result;\n+        elem->computed = 1;\n@@ -1283,1 +1283,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1287,1 +1287,1 @@\n-    \"Registering global variables\\n\"));\n+        \"Registering global variables\\n\"));\n@@ -1294,1 +1294,1 @@\n-    elem = style->variables;\n+        elem = style->variables;\n@@ -1297,5 +1297,5 @@\n-    if ((style->doc != NULL) && (style->doc->URL != NULL)) {\n-        XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n-                 \"Registering global variables from %s\\n\",\n-                     style->doc->URL));\n-    }\n+        if ((style->doc != NULL) && (style->doc->URL != NULL)) {\n+            XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n+                             \"Registering global variables from %s\\n\",\n+                             style->doc->URL));\n+        }\n@@ -1304,28 +1304,30 @@\n-    while (elem != NULL) {\n-        xsltStackElemPtr def;\n-\n-        \/*\n-         * Global variables are stored in the variables pool.\n-         *\/\n-        def = (xsltStackElemPtr)\n-            xmlHashLookup2(ctxt->globalVars,\n-                         elem->name, elem->nameURI);\n-        if (def == NULL) {\n-\n-        def = xsltCopyStackElem(elem);\n-        xmlHashAddEntry2(ctxt->globalVars,\n-                 elem->name, elem->nameURI, def);\n-        } else if ((elem->comp != NULL) &&\n-               (elem->comp->type == XSLT_FUNC_VARIABLE)) {\n-        \/*\n-         * Redefinition of variables from a different stylesheet\n-         * should not generate a message.\n-         *\/\n-        if ((elem->comp->inst != NULL) &&\n-            (def->comp != NULL) && (def->comp->inst != NULL) &&\n-            (elem->comp->inst->doc == def->comp->inst->doc))\n-        {\n-            xsltTransformError(ctxt, style, elem->comp->inst,\n-            \"Global variable %s already defined\\n\", elem->name);\n-            if (style != NULL) style->errors++;\n-        }\n+        while (elem != NULL) {\n+            xsltStackElemPtr def;\n+\n+            \/*\n+             * Global variables are stored in the variables pool.\n+             *\/\n+            def = (xsltStackElemPtr)\n+                    xmlHashLookup2(ctxt->globalVars,\n+                                 elem->name, elem->nameURI);\n+            if (def == NULL) {\n+\n+                def = xsltCopyStackElem(elem);\n+                xmlHashAddEntry2(ctxt->globalVars,\n+                                 elem->name, elem->nameURI, def);\n+            } else if ((elem->comp != NULL) &&\n+                       (elem->comp->type == XSLT_FUNC_VARIABLE)) {\n+                \/*\n+                 * Redefinition of variables from a different stylesheet\n+                 * should not generate a message.\n+                 *\/\n+                if ((elem->comp->inst != NULL) &&\n+                    (def->comp != NULL) && (def->comp->inst != NULL) &&\n+                    (elem->comp->inst->doc == def->comp->inst->doc))\n+                {\n+                    xsltTransformError(ctxt, style, elem->comp->inst,\n+                        \"Global variable %s already defined\\n\", elem->name);\n+                    if (style != NULL) style->errors++;\n+                }\n+            }\n+            elem = elem->next;\n@@ -1333,2 +1335,0 @@\n-        elem = elem->next;\n-    }\n@@ -1336,1 +1336,1 @@\n-    style = xsltNextImport(style);\n+        style = xsltNextImport(style);\n@@ -1364,3 +1364,3 @@\n-             const xmlChar *ns_uri, const xmlChar *sel,\n-             xmlNodePtr tree, xsltStylePreCompPtr comp,\n-             const xmlChar *value) {\n+                     const xmlChar *ns_uri, const xmlChar *sel,\n+                     xmlNodePtr tree, xsltStylePreCompPtr comp,\n+                     const xmlChar *value) {\n@@ -1369,1 +1369,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1371,1 +1371,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1373,1 +1373,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1377,2 +1377,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"Defining global param %s\\n\", name);\n+        xsltGenericDebug(xsltGenericDebugContext,\n+                         \"Defining global param %s\\n\", name);\n@@ -1380,2 +1380,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-             \"Defining global variable %s\\n\", name);\n+        xsltGenericDebug(xsltGenericDebugContext,\n+                         \"Defining global variable %s\\n\", name);\n@@ -1386,1 +1386,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1391,1 +1391,1 @@\n-    elem->nameURI = xmlDictLookup(style->dict, ns_uri, -1);\n+        elem->nameURI = xmlDictLookup(style->dict, ns_uri, -1);\n@@ -1395,2 +1395,2 @@\n-    elem->next = NULL;\n-    style->variables = elem;\n+        elem->next = NULL;\n+        style->variables = elem;\n@@ -1398,10 +1398,14 @@\n-    while (tmp != NULL) {\n-        if ((elem->comp->type == XSLT_FUNC_VARIABLE) &&\n-        (tmp->comp->type == XSLT_FUNC_VARIABLE) &&\n-        (xmlStrEqual(elem->name, tmp->name)) &&\n-        ((elem->nameURI == tmp->nameURI) ||\n-         (xmlStrEqual(elem->nameURI, tmp->nameURI))))\n-        {\n-        xsltTransformError(NULL, style, comp->inst,\n-        \"redefinition of global variable %s\\n\", elem->name);\n-        style->errors++;\n+        while (tmp != NULL) {\n+            if ((elem->comp->type == XSLT_FUNC_VARIABLE) &&\n+                (tmp->comp->type == XSLT_FUNC_VARIABLE) &&\n+                (xmlStrEqual(elem->name, tmp->name)) &&\n+                ((elem->nameURI == tmp->nameURI) ||\n+                 (xmlStrEqual(elem->nameURI, tmp->nameURI))))\n+            {\n+                xsltTransformError(NULL, style, comp->inst,\n+                \"redefinition of global variable %s\\n\", elem->name);\n+                style->errors++;\n+            }\n+            if (tmp->next == NULL)\n+                break;\n+            tmp = tmp->next;\n@@ -1409,6 +1413,2 @@\n-        if (tmp->next == NULL)\n-            break;\n-        tmp = tmp->next;\n-    }\n-    elem->next = NULL;\n-    tmp->next = elem;\n+        elem->next = NULL;\n+        tmp->next = elem;\n@@ -1417,2 +1417,2 @@\n-    elem->computed = 1;\n-    elem->value = xmlXPathNewString(value);\n+        elem->computed = 1;\n+        elem->value = xmlXPathNewString(value);\n@@ -1457,3 +1457,3 @@\n-                     const xmlChar * name,\n-                 const xmlChar * value,\n-                 int eval) {\n+                             const xmlChar * name,\n+                             const xmlChar * value,\n+                             int eval) {\n@@ -1472,1 +1472,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1474,1 +1474,1 @@\n-    return(0);\n+        return(0);\n@@ -1476,1 +1476,1 @@\n-    return(0);\n+        return(0);\n@@ -1482,1 +1482,1 @@\n-        \"Evaluating user parameter %s=%s\\n\", name, value));\n+            \"Evaluating user parameter %s=%s\\n\", name, value));\n@@ -1520,1 +1520,1 @@\n-    return (-1);\n+        return (-1);\n@@ -1524,2 +1524,2 @@\n-    xsltTransformError(ctxt, style, NULL,\n-        \"Global parameter %s already defined\\n\", name);\n+        xsltTransformError(ctxt, style, NULL,\n+            \"Global parameter %s already defined\\n\", name);\n@@ -1528,1 +1528,1 @@\n-    ctxt->globalVars = xmlHashCreate(20);\n+        ctxt->globalVars = xmlHashCreate(20);\n@@ -1535,7 +1535,7 @@\n-    while (elem != NULL) {\n-        if ((elem->comp != NULL) &&\n-            (elem->comp->type == XSLT_FUNC_VARIABLE) &&\n-        (xmlStrEqual(elem->name, name)) &&\n-        (xmlStrEqual(elem->nameURI, href))) {\n-        return(0);\n-        }\n+        while (elem != NULL) {\n+            if ((elem->comp != NULL) &&\n+                (elem->comp->type == XSLT_FUNC_VARIABLE) &&\n+                (xmlStrEqual(elem->name, name)) &&\n+                (xmlStrEqual(elem->nameURI, href))) {\n+                return(0);\n+            }\n@@ -1543,1 +1543,1 @@\n-    }\n+        }\n@@ -1556,57 +1556,57 @@\n-    if (xpExpr != NULL) {\n-        xmlDocPtr oldXPDoc;\n-        xmlNodePtr oldXPContextNode;\n-        int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;\n-        xmlNsPtr *oldXPNamespaces;\n-        xmlXPathContextPtr xpctxt = ctxt->xpathCtxt;\n-\n-        \/*\n-        * Save context states.\n-        *\/\n-        oldXPDoc = xpctxt->doc;\n-        oldXPContextNode = xpctxt->node;\n-        oldXPProximityPosition = xpctxt->proximityPosition;\n-        oldXPContextSize = xpctxt->contextSize;\n-        oldXPNamespaces = xpctxt->namespaces;\n-        oldXPNsNr = xpctxt->nsNr;\n-\n-        \/*\n-        * SPEC XSLT 1.0:\n-        * \"At top-level, the expression or template specifying the\n-        *  variable value is evaluated with the same context as that used\n-        *  to process the root node of the source document: the current\n-        *  node is the root node of the source document and the current\n-        *  node list is a list containing just the root node of the source\n-        *  document.\"\n-        *\/\n-        xpctxt->doc = ctxt->initialContextDoc;\n-        xpctxt->node = ctxt->initialContextNode;\n-        xpctxt->contextSize = 1;\n-        xpctxt->proximityPosition = 1;\n-        \/*\n-        * There is really no in scope namespace for parameters on the\n-        * command line.\n-        *\/\n-        xpctxt->namespaces = NULL;\n-        xpctxt->nsNr = 0;\n-\n-        result = xmlXPathCompiledEval(xpExpr, xpctxt);\n-\n-        \/*\n-        * Restore Context states.\n-        *\/\n-        xpctxt->doc = oldXPDoc;\n-        xpctxt->node = oldXPContextNode;\n-        xpctxt->contextSize = oldXPContextSize;\n-        xpctxt->proximityPosition = oldXPProximityPosition;\n-        xpctxt->namespaces = oldXPNamespaces;\n-        xpctxt->nsNr = oldXPNsNr;\n-\n-        xmlXPathFreeCompExpr(xpExpr);\n-    }\n-    if (result == NULL) {\n-        xsltTransformError(ctxt, style, NULL,\n-        \"Evaluating user parameter %s failed\\n\", name);\n-        ctxt->state = XSLT_STATE_STOPPED;\n-        return(-1);\n-    }\n+        if (xpExpr != NULL) {\n+            xmlDocPtr oldXPDoc;\n+            xmlNodePtr oldXPContextNode;\n+            int oldXPProximityPosition, oldXPContextSize, oldXPNsNr;\n+            xmlNsPtr *oldXPNamespaces;\n+            xmlXPathContextPtr xpctxt = ctxt->xpathCtxt;\n+\n+            \/*\n+            * Save context states.\n+            *\/\n+            oldXPDoc = xpctxt->doc;\n+            oldXPContextNode = xpctxt->node;\n+            oldXPProximityPosition = xpctxt->proximityPosition;\n+            oldXPContextSize = xpctxt->contextSize;\n+            oldXPNamespaces = xpctxt->namespaces;\n+            oldXPNsNr = xpctxt->nsNr;\n+\n+            \/*\n+            * SPEC XSLT 1.0:\n+            * \"At top-level, the expression or template specifying the\n+            *  variable value is evaluated with the same context as that used\n+            *  to process the root node of the source document: the current\n+            *  node is the root node of the source document and the current\n+            *  node list is a list containing just the root node of the source\n+            *  document.\"\n+            *\/\n+            xpctxt->doc = ctxt->initialContextDoc;\n+            xpctxt->node = ctxt->initialContextNode;\n+            xpctxt->contextSize = 1;\n+            xpctxt->proximityPosition = 1;\n+            \/*\n+            * There is really no in scope namespace for parameters on the\n+            * command line.\n+            *\/\n+            xpctxt->namespaces = NULL;\n+            xpctxt->nsNr = 0;\n+\n+            result = xmlXPathCompiledEval(xpExpr, xpctxt);\n+\n+            \/*\n+            * Restore Context states.\n+            *\/\n+            xpctxt->doc = oldXPDoc;\n+            xpctxt->node = oldXPContextNode;\n+            xpctxt->contextSize = oldXPContextSize;\n+            xpctxt->proximityPosition = oldXPProximityPosition;\n+            xpctxt->namespaces = oldXPNamespaces;\n+            xpctxt->nsNr = oldXPNsNr;\n+\n+            xmlXPathFreeCompExpr(xpExpr);\n+        }\n+        if (result == NULL) {\n+            xsltTransformError(ctxt, style, NULL,\n+                \"Evaluating user parameter %s failed\\n\", name);\n+            ctxt->state = XSLT_STATE_STOPPED;\n+            return(-1);\n+        }\n@@ -1630,2 +1630,2 @@\n-        xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,\n-                    result, 0);\n+            xmlXPathDebugDumpObject((FILE *)xsltGenericDebugContext,\n+                                    result, 0);\n@@ -1637,12 +1637,12 @@\n-    elem->name = name;\n-    elem->select = xmlDictLookup(ctxt->dict, value, -1);\n-    if (href != NULL)\n-        elem->nameURI = xmlDictLookup(ctxt->dict, href, -1);\n-    elem->tree = NULL;\n-    elem->computed = 1;\n-    if (eval == 0) {\n-        elem->value = xmlXPathNewString(value);\n-    }\n-    else {\n-        elem->value = result;\n-    }\n+        elem->name = name;\n+        elem->select = xmlDictLookup(ctxt->dict, value, -1);\n+        if (href != NULL)\n+            elem->nameURI = xmlDictLookup(ctxt->dict, href, -1);\n+        elem->tree = NULL;\n+        elem->computed = 1;\n+        if (eval == 0) {\n+            elem->value = xmlXPathNewString(value);\n+        }\n+        else {\n+            elem->value = result;\n+        }\n@@ -1657,3 +1657,3 @@\n-    xsltFreeStackElem(elem);\n-    xsltTransformError(ctxt, style, NULL,\n-        \"Global parameter %s already defined\\n\", name);\n+        xsltFreeStackElem(elem);\n+        xsltTransformError(ctxt, style, NULL,\n+            \"Global parameter %s already defined\\n\", name);\n@@ -1686,1 +1686,1 @@\n-    return(0);\n+        return(0);\n@@ -1688,4 +1688,4 @@\n-    name = (const xmlChar *) params[indx++];\n-    value = (const xmlChar *) params[indx++];\n-    if (xsltEvalOneUserParam(ctxt, name, value) != 0)\n-        return(-1);\n+        name = (const xmlChar *) params[indx++];\n+        value = (const xmlChar *) params[indx++];\n+        if (xsltEvalOneUserParam(ctxt, name, value) != 0)\n+            return(-1);\n@@ -1716,1 +1716,1 @@\n-    return(0);\n+        return(0);\n@@ -1718,4 +1718,4 @@\n-    name = (const xmlChar *) params[indx++];\n-    value = (const xmlChar *) params[indx++];\n-    if (xsltQuoteOneUserParam(ctxt, name, value) != 0)\n-        return(-1);\n+        name = (const xmlChar *) params[indx++];\n+        value = (const xmlChar *) params[indx++];\n+        if (xsltQuoteOneUserParam(ctxt, name, value) != 0)\n+            return(-1);\n@@ -1746,2 +1746,2 @@\n-             const xmlChar * name,\n-             const xmlChar * value) {\n+                     const xmlChar * name,\n+                     const xmlChar * value) {\n@@ -1749,1 +1749,1 @@\n-                                1 \/* xpath eval ? *\/);\n+                                        1 \/* xpath eval ? *\/);\n@@ -1767,2 +1767,2 @@\n-             const xmlChar * name,\n-             const xmlChar * value) {\n+                         const xmlChar * name,\n+                         const xmlChar * value) {\n@@ -1770,1 +1770,1 @@\n-                    0 \/* xpath eval ? *\/);\n+                                        0 \/* xpath eval ? *\/);\n@@ -1785,2 +1785,2 @@\n-          xsltStylePreCompPtr castedComp,\n-          xmlNodePtr tree)\n+                  xsltStylePreCompPtr castedComp,\n+                  xmlNodePtr tree)\n@@ -1790,1 +1790,1 @@\n-    (xsltStyleBasicItemVariablePtr) castedComp;\n+        (xsltStyleBasicItemVariablePtr) castedComp;\n@@ -1798,1 +1798,1 @@\n-             \"Building variable %s\", comp->name));\n+                     \"Building variable %s\", comp->name));\n@@ -1800,2 +1800,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n-             \" select %s\", comp->select));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n+                         \" select %s\", comp->select));\n@@ -1807,1 +1807,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1814,1 +1814,1 @@\n-    (xsltStylePreCompPtr) comp);\n+        (xsltStylePreCompPtr) comp);\n@@ -1832,2 +1832,2 @@\n-             xsltStylePreCompPtr castedComp,\n-             xmlNodePtr tree, int isParam)\n+                     xsltStylePreCompPtr castedComp,\n+                     xmlNodePtr tree, int isParam)\n@@ -1837,1 +1837,1 @@\n-    (xsltStyleBasicItemVariablePtr) castedComp;\n+        (xsltStyleBasicItemVariablePtr) castedComp;\n@@ -1853,6 +1853,6 @@\n-    if ((present != 0) && (present != 3)) {\n-        \/* TODO: report QName. *\/\n-        xsltTransformError(ctxt, NULL, comp->inst,\n-        \"XSLT-variable: Redefinition of variable '%s'.\\n\", comp->name);\n-        return(0);\n-    }\n+        if ((present != 0) && (present != 3)) {\n+            \/* TODO: report QName. *\/\n+            xsltTransformError(ctxt, NULL, comp->inst,\n+                \"XSLT-variable: Redefinition of variable '%s'.\\n\", comp->name);\n+            return(0);\n+        }\n@@ -1860,6 +1860,6 @@\n-    if ((present == 1) || (present == 2)) {\n-        \/* TODO: report QName. *\/\n-        xsltTransformError(ctxt, NULL, comp->inst,\n-        \"XSLT-param: Redefinition of parameter '%s'.\\n\", comp->name);\n-        return(0);\n-    }\n+        if ((present == 1) || (present == 2)) {\n+            \/* TODO: report QName. *\/\n+            xsltTransformError(ctxt, NULL, comp->inst,\n+                \"XSLT-param: Redefinition of parameter '%s'.\\n\", comp->name);\n+            return(0);\n+        }\n@@ -1867,2 +1867,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n-         \"param %s defined by caller\\n\", comp->name));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n+                 \"param %s defined by caller\\n\", comp->name));\n@@ -1870,1 +1870,1 @@\n-    return(0);\n+        return(0);\n@@ -1892,1 +1892,1 @@\n-                 const xmlChar *ns_uri) {\n+                         const xmlChar *ns_uri) {\n@@ -1900,1 +1900,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1902,1 +1902,1 @@\n-        xmlHashLookup2(ctxt->globalVars, name, ns_uri);\n+            xmlHashLookup2(ctxt->globalVars, name, ns_uri);\n@@ -1905,2 +1905,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n-             \"global variable not found %s\\n\", name));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n+                         \"global variable not found %s\\n\", name));\n@@ -1908,1 +1908,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1915,6 +1915,6 @@\n-    if (elem->name == xsltComputingGlobalVarMarker) {\n-        xsltTransformError(ctxt, NULL, elem->comp->inst,\n-        \"Recursive definition of %s\\n\", name);\n-        return(NULL);\n-    }\n-    ret = xsltEvalGlobalVariable(elem, ctxt);\n+        if (elem->name == xsltComputingGlobalVarMarker) {\n+            xsltTransformError(ctxt, NULL, elem->comp->inst,\n+                \"Recursive definition of %s\\n\", name);\n+            return(NULL);\n+        }\n+        ret = xsltEvalGlobalVariable(elem, ctxt);\n@@ -1922,1 +1922,1 @@\n-    ret = elem->value;\n+        ret = elem->value;\n@@ -1939,1 +1939,1 @@\n-           const xmlChar *ns_uri) {\n+                   const xmlChar *ns_uri) {\n@@ -1943,1 +1943,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1947,1 +1947,1 @@\n-    return(xsltGlobalVariableLookup(ctxt, name, ns_uri));\n+        return(xsltGlobalVariableLookup(ctxt, name, ns_uri));\n@@ -1951,2 +1951,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n-                 \"uncomputed variable %s\\n\", name));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n+                         \"uncomputed variable %s\\n\", name));\n@@ -1955,1 +1955,1 @@\n-    elem->computed = 1;\n+        elem->computed = 1;\n@@ -1958,1 +1958,1 @@\n-    return(xmlXPathObjectCopy(elem->value));\n+        return(xmlXPathObjectCopy(elem->value));\n@@ -1961,1 +1961,1 @@\n-             \"variable not found %s\\n\", name));\n+                     \"variable not found %s\\n\", name));\n@@ -1992,1 +1992,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2002,2 +2002,2 @@\n-        \"Internal error in xsltParseStylesheetCallerParam(): \"\n-        \"The XSLT 'with-param' instruction was not compiled.\\n\");\n+            \"Internal error in xsltParseStylesheetCallerParam(): \"\n+            \"The XSLT 'with-param' instruction was not compiled.\\n\");\n@@ -2007,4 +2007,4 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-        \"Internal error in xsltParseStylesheetCallerParam(): \"\n-        \"XSLT 'with-param': The attribute 'name' was not compiled.\\n\");\n-    return(NULL);\n+        xsltTransformError(ctxt, NULL, inst,\n+            \"Internal error in xsltParseStylesheetCallerParam(): \"\n+            \"XSLT 'with-param': The attribute 'name' was not compiled.\\n\");\n+        return(NULL);\n@@ -2015,1 +2015,1 @@\n-        \"Handling xsl:with-param %s\\n\", comp->name));\n+            \"Handling xsl:with-param %s\\n\", comp->name));\n@@ -2019,1 +2019,1 @@\n-    tree = inst->children;\n+        tree = inst->children;\n@@ -2022,2 +2022,2 @@\n-    XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n-        \"        select %s\\n\", comp->select));\n+        XSLT_TRACE(ctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n+            \"        select %s\\n\", comp->select));\n@@ -2025,1 +2025,1 @@\n-    tree = inst;\n+        tree = inst;\n@@ -2051,1 +2051,1 @@\n-    return;\n+        return;\n@@ -2064,3 +2064,3 @@\n-    xsltTransformError(NULL, style, cur,\n-         \"xsl:variable : compilation failed\\n\");\n-    return;\n+        xsltTransformError(NULL, style, cur,\n+             \"xsl:variable : compilation failed\\n\");\n+        return;\n@@ -2070,3 +2070,3 @@\n-    xsltTransformError(NULL, style, cur,\n-        \"xsl:variable : missing name attribute\\n\");\n-    return;\n+        xsltTransformError(NULL, style, cur,\n+            \"xsl:variable : missing name attribute\\n\");\n+        return;\n@@ -2087,1 +2087,1 @@\n-    \"Registering global variable %s\\n\", comp->name);\n+        \"Registering global variable %s\\n\", comp->name);\n@@ -2091,2 +2091,2 @@\n-    comp->select, cur->children, (xsltStylePreCompPtr) comp,\n-    NULL);\n+        comp->select, cur->children, (xsltStylePreCompPtr) comp,\n+        NULL);\n@@ -2113,1 +2113,1 @@\n-    return;\n+        return;\n@@ -2126,3 +2126,3 @@\n-    xsltTransformError(NULL, style, cur,\n-         \"xsl:param : compilation failed\\n\");\n-    return;\n+        xsltTransformError(NULL, style, cur,\n+             \"xsl:param : compilation failed\\n\");\n+        return;\n@@ -2132,3 +2132,3 @@\n-    xsltTransformError(NULL, style, cur,\n-        \"xsl:param : missing name attribute\\n\");\n-    return;\n+        xsltTransformError(NULL, style, cur,\n+            \"xsl:param : missing name attribute\\n\");\n+        return;\n@@ -2150,1 +2150,1 @@\n-    \"Registering global param %s\\n\", comp->name);\n+        \"Registering global param %s\\n\", comp->name);\n@@ -2154,2 +2154,2 @@\n-    comp->select, cur->children, (xsltStylePreCompPtr) comp,\n-    NULL);\n+        comp->select, cur->children, (xsltStylePreCompPtr) comp,\n+        NULL);\n@@ -2176,1 +2176,1 @@\n-    return;\n+        return;\n@@ -2181,2 +2181,2 @@\n-        \"Internal error in xsltParseStylesheetVariable(): \"\n-        \"The XSLT 'variable' instruction was not compiled.\\n\");\n+            \"Internal error in xsltParseStylesheetVariable(): \"\n+            \"The XSLT 'variable' instruction was not compiled.\\n\");\n@@ -2186,4 +2186,4 @@\n-    xsltTransformError(ctxt, NULL, inst,\n-        \"Internal error in xsltParseStylesheetVariable(): \"\n-        \"The attribute 'name' was not compiled.\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, inst,\n+            \"Internal error in xsltParseStylesheetVariable(): \"\n+            \"The attribute 'name' was not compiled.\\n\");\n+        return;\n@@ -2194,1 +2194,1 @@\n-    \"Registering variable '%s'\\n\", comp->name));\n+        \"Registering variable '%s'\\n\", comp->name));\n@@ -2218,1 +2218,1 @@\n-    return;\n+        return;\n@@ -2222,4 +2222,4 @@\n-    xsltTransformError(ctxt, NULL, cur,\n-        \"Internal error in xsltParseStylesheetParam(): \"\n-        \"The XSLT 'param' declaration was not compiled correctly.\\n\");\n-    return;\n+        xsltTransformError(ctxt, NULL, cur,\n+            \"Internal error in xsltParseStylesheetParam(): \"\n+            \"The XSLT 'param' declaration was not compiled correctly.\\n\");\n+        return;\n@@ -2230,1 +2230,1 @@\n-    \"Registering param %s\\n\", comp->name));\n+        \"Registering param %s\\n\", comp->name));\n@@ -2262,1 +2262,1 @@\n-                    const xmlChar *ns_uri) {\n+                        const xmlChar *ns_uri) {\n@@ -2267,1 +2267,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2271,1 +2271,1 @@\n-        \"Lookup variable '%s'\\n\", name));\n+            \"Lookup variable '%s'\\n\", name));\n@@ -2284,2 +2284,2 @@\n-    int i;\n-    xsltStackElemPtr variable = NULL, cur;\n+        int i;\n+        xsltStackElemPtr variable = NULL, cur;\n@@ -2287,24 +2287,0 @@\n-    for (i = tctxt->varsNr; i > tctxt->varsBase; i--) {\n-        cur = tctxt->varsTab[i-1];\n-        if ((cur->name == name) && (cur->nameURI == ns_uri)) {\n-#if 0\n-        stack_addr++;\n-#endif\n-        variable = cur;\n-        goto local_variable_found;\n-        }\n-        cur = cur->next;\n-    }\n-    \/*\n-    * Redo the lookup with interned strings to avoid string comparison.\n-    *\n-    * OPTIMIZE TODO: The problem here is, that if we request a\n-    *  global variable, then this will be also executed.\n-    *\/\n-    {\n-        const xmlChar *tmpName = name, *tmpNsName = ns_uri;\n-\n-        name = xmlDictLookup(tctxt->dict, name, -1);\n-        if (ns_uri)\n-        ns_uri = xmlDictLookup(tctxt->dict, ns_uri, -1);\n-        if ((tmpName != name) || (tmpNsName != ns_uri)) {\n@@ -2315,1 +2291,1 @@\n-            stack_cmp++;\n+                stack_addr++;\n@@ -2317,2 +2293,2 @@\n-            variable = cur;\n-            goto local_variable_found;\n+                variable = cur;\n+                goto local_variable_found;\n@@ -2320,0 +2296,1 @@\n+            cur = cur->next;\n@@ -2321,0 +2298,24 @@\n+        \/*\n+        * Redo the lookup with interned strings to avoid string comparison.\n+        *\n+        * OPTIMIZE TODO: The problem here is, that if we request a\n+        *  global variable, then this will be also executed.\n+        *\/\n+        {\n+            const xmlChar *tmpName = name, *tmpNsName = ns_uri;\n+\n+            name = xmlDictLookup(tctxt->dict, name, -1);\n+            if (ns_uri)\n+                ns_uri = xmlDictLookup(tctxt->dict, ns_uri, -1);\n+            if ((tmpName != name) || (tmpNsName != ns_uri)) {\n+                for (i = tctxt->varsNr; i > tctxt->varsBase; i--) {\n+                    cur = tctxt->varsTab[i-1];\n+                    if ((cur->name == name) && (cur->nameURI == ns_uri)) {\n+#if 0\n+                        stack_cmp++;\n+#endif\n+                        variable = cur;\n+                        goto local_variable_found;\n+                    }\n+                }\n+            }\n@@ -2322,1 +2323,0 @@\n-    }\n@@ -2326,2 +2326,2 @@\n-    if (variable) {\n-        if (variable->computed == 0) {\n+        if (variable) {\n+            if (variable->computed == 0) {\n@@ -2330,2 +2330,2 @@\n-        XSLT_TRACE(tctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n-            \"uncomputed variable '%s'\\n\", name));\n+                XSLT_TRACE(tctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n+                    \"uncomputed variable '%s'\\n\", name));\n@@ -2333,5 +2333,7 @@\n-        variable->value = xsltEvalVariable(tctxt, variable, NULL);\n-        variable->computed = 1;\n-        }\n-        if (variable->value != NULL) {\n-        valueObj = xmlXPathObjectCopy(variable->value);\n+                variable->value = xsltEvalVariable(tctxt, variable, NULL);\n+                variable->computed = 1;\n+            }\n+            if (variable->value != NULL) {\n+                valueObj = xmlXPathObjectCopy(variable->value);\n+            }\n+            return(valueObj);\n@@ -2339,2 +2341,0 @@\n-        return(valueObj);\n-    }\n@@ -2346,1 +2346,1 @@\n-    valueObj = xsltGlobalVariableLookup(tctxt, name, ns_uri);\n+        valueObj = xsltGlobalVariableLookup(tctxt, name, ns_uri);\n@@ -2353,1 +2353,1 @@\n-             \"variable not found '%s'\\n\", name));\n+                     \"variable not found '%s'\\n\", name));\n@@ -2356,7 +2356,7 @@\n-    if (ns_uri) {\n-        xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"Variable '{%s}%s' has not been declared.\\n\", ns_uri, name);\n-    } else {\n-        xsltTransformError(tctxt, NULL, tctxt->inst,\n-        \"Variable '%s' has not been declared.\\n\", name);\n-    }\n+        if (ns_uri) {\n+            xsltTransformError(tctxt, NULL, tctxt->inst,\n+                \"Variable '{%s}%s' has not been declared.\\n\", ns_uri, name);\n+        } else {\n+            xsltTransformError(tctxt, NULL, tctxt->inst,\n+                \"Variable '%s' has not been declared.\\n\", name);\n+        }\n@@ -2366,2 +2366,2 @@\n-    XSLT_TRACE(tctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n-        \"found variable '%s'\\n\", name));\n+        XSLT_TRACE(tctxt,XSLT_TRACE_VARIABLES,xsltGenericDebug(xsltGenericDebugContext,\n+            \"found variable '%s'\\n\", name));\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/variables.c","additions":825,"deletions":825,"binary":false,"changes":1650,"status":"modified"},{"patch":"@@ -30,5 +30,5 @@\n-#define XSLT_REGISTER_VARIABLE_LOOKUP(ctxt)         \\\n-    xmlXPathRegisterVariableLookup((ctxt)->xpathCtxt,       \\\n-           xsltXPathVariableLookup, (void *)(ctxt));    \\\n-    xsltRegisterAllFunctions((ctxt)->xpathCtxt);        \\\n-    xsltRegisterAllElement(ctxt);               \\\n+#define XSLT_REGISTER_VARIABLE_LOOKUP(ctxt)                     \\\n+    xmlXPathRegisterVariableLookup((ctxt)->xpathCtxt,           \\\n+               xsltXPathVariableLookup, (void *)(ctxt));        \\\n+    xsltRegisterAllFunctions((ctxt)->xpathCtxt);                \\\n+    xsltRegisterAllElement(ctxt);                               \\\n@@ -69,1 +69,1 @@\n-        xsltEvalGlobalVariables     (xsltTransformContextPtr ctxt);\n+                xsltEvalGlobalVariables         (xsltTransformContextPtr ctxt);\n@@ -71,2 +71,2 @@\n-        xsltEvalUserParams      (xsltTransformContextPtr ctxt,\n-                         const char **params);\n+                xsltEvalUserParams              (xsltTransformContextPtr ctxt,\n+                                                 const char **params);\n@@ -74,2 +74,2 @@\n-        xsltQuoteUserParams     (xsltTransformContextPtr ctxt,\n-                         const char **params);\n+                xsltQuoteUserParams             (xsltTransformContextPtr ctxt,\n+                                                 const char **params);\n@@ -77,3 +77,3 @@\n-        xsltEvalOneUserParam        (xsltTransformContextPtr ctxt,\n-                         const xmlChar * name,\n-                         const xmlChar * value);\n+                xsltEvalOneUserParam            (xsltTransformContextPtr ctxt,\n+                                                 const xmlChar * name,\n+                                                 const xmlChar * value);\n@@ -81,3 +81,3 @@\n-        xsltQuoteOneUserParam       (xsltTransformContextPtr ctxt,\n-                         const xmlChar * name,\n-                         const xmlChar * value);\n+                xsltQuoteOneUserParam           (xsltTransformContextPtr ctxt,\n+                                                 const xmlChar * name,\n+                                                 const xmlChar * value);\n@@ -86,2 +86,2 @@\n-        xsltParseGlobalVariable     (xsltStylesheetPtr style,\n-                         xmlNodePtr cur);\n+                xsltParseGlobalVariable         (xsltStylesheetPtr style,\n+                                                 xmlNodePtr cur);\n@@ -89,2 +89,2 @@\n-        xsltParseGlobalParam        (xsltStylesheetPtr style,\n-                         xmlNodePtr cur);\n+                xsltParseGlobalParam            (xsltStylesheetPtr style,\n+                                                 xmlNodePtr cur);\n@@ -92,2 +92,2 @@\n-        xsltParseStylesheetVariable (xsltTransformContextPtr ctxt,\n-                         xmlNodePtr cur);\n+                xsltParseStylesheetVariable     (xsltTransformContextPtr ctxt,\n+                                                 xmlNodePtr cur);\n@@ -95,2 +95,2 @@\n-        xsltParseStylesheetParam    (xsltTransformContextPtr ctxt,\n-                         xmlNodePtr cur);\n+                xsltParseStylesheetParam        (xsltTransformContextPtr ctxt,\n+                                                 xmlNodePtr cur);\n@@ -98,2 +98,2 @@\n-        xsltParseStylesheetCallerParam  (xsltTransformContextPtr ctxt,\n-                         xmlNodePtr cur);\n+                xsltParseStylesheetCallerParam  (xsltTransformContextPtr ctxt,\n+                                                 xmlNodePtr cur);\n@@ -101,2 +101,2 @@\n-        xsltAddStackElemList        (xsltTransformContextPtr ctxt,\n-                         xsltStackElemPtr elems);\n+                xsltAddStackElemList            (xsltTransformContextPtr ctxt,\n+                                                 xsltStackElemPtr elems);\n@@ -104,1 +104,1 @@\n-        xsltFreeGlobalVariables     (xsltTransformContextPtr ctxt);\n+                xsltFreeGlobalVariables         (xsltTransformContextPtr ctxt);\n@@ -106,3 +106,3 @@\n-        xsltVariableLookup      (xsltTransformContextPtr ctxt,\n-                         const xmlChar *name,\n-                         const xmlChar *ns_uri);\n+                xsltVariableLookup              (xsltTransformContextPtr ctxt,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns_uri);\n@@ -110,3 +110,3 @@\n-        xsltXPathVariableLookup     (void *ctxt,\n-                         const xmlChar *name,\n-                         const xmlChar *ns_uri);\n+                xsltXPathVariableLookup         (void *ctxt,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar *ns_uri);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/variables.h","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    : ((_fpclass(d) == _FPCLASS_NINF) ? -1 : 0))\n+        : ((_fpclass(d) == _FPCLASS_NINF) ? -1 : 0))\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/win32config.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-#define IS_BLANK_NODE(n)                        \\\n+#define IS_BLANK_NODE(n)                                                \\\n@@ -127,1 +127,1 @@\n-               xmlNodePtr node)\n+                       xmlNodePtr node)\n@@ -130,1 +130,1 @@\n-    return;\n+        return;\n@@ -133,3 +133,3 @@\n-    xsltTransformError(NULL, style, node,\n-        \"The XSLT-element '%s' is not allowed at this position.\\n\",\n-        node->name);\n+        xsltTransformError(NULL, style, node,\n+            \"The XSLT-element '%s' is not allowed at this position.\\n\",\n+            node->name);\n@@ -137,3 +137,3 @@\n-    xsltTransformError(NULL, style, node,\n-        \"The element '%s' is not allowed at this position.\\n\",\n-        node->name);\n+        xsltTransformError(NULL, style, node,\n+            \"The element '%s' is not allowed at this position.\\n\",\n+            node->name);\n@@ -173,1 +173,1 @@\n-        return(-1);\n+            return(-1);\n@@ -217,3 +217,3 @@\n- *                                  *\n- *          Helper functions                *\n- *                                  *\n+ *                                                                      *\n+ *                      Helper functions                                *\n+ *                                                                      *\n@@ -232,1 +232,1 @@\n-    initialized = 1;\n+        initialized = 1;\n@@ -234,1 +234,1 @@\n-    xsltLocaleMutex = xmlNewRMutex();\n+        xsltLocaleMutex = xmlNewRMutex();\n@@ -265,1 +265,1 @@\n-    return(1);\n+        return(1);\n@@ -267,2 +267,2 @@\n-    if (!(IS_BLANK(*str))) return(0);\n-    str++;\n+        if (!(IS_BLANK(*str))) return(0);\n+        str++;\n@@ -274,3 +274,3 @@\n- *                                  *\n- *      Routines to handle XSLT data structures         *\n- *                                  *\n+ *                                                                      *\n+ *              Routines to handle XSLT data structures                 *\n+ *                                                                      *\n@@ -287,1 +287,1 @@\n-    self->next = NULL;\n+        self->next = NULL;\n@@ -289,13 +289,13 @@\n-    self->name = name;\n-\n-    \/* Default values *\/\n-    self->digit = xmlStrdup(BAD_CAST(\"#\"));\n-    self->patternSeparator = xmlStrdup(BAD_CAST(\";\"));\n-    self->decimalPoint = xmlStrdup(BAD_CAST(\".\"));\n-    self->grouping = xmlStrdup(BAD_CAST(\",\"));\n-    self->percent = xmlStrdup(BAD_CAST(\"%\"));\n-    self->permille = xmlStrdup(BAD_CAST(permille));\n-    self->zeroDigit = xmlStrdup(BAD_CAST(\"0\"));\n-    self->minusSign = xmlStrdup(BAD_CAST(\"-\"));\n-    self->infinity = xmlStrdup(BAD_CAST(\"Infinity\"));\n-    self->noNumber = xmlStrdup(BAD_CAST(\"NaN\"));\n+        self->name = name;\n+\n+        \/* Default values *\/\n+        self->digit = xmlStrdup(BAD_CAST(\"#\"));\n+        self->patternSeparator = xmlStrdup(BAD_CAST(\";\"));\n+        self->decimalPoint = xmlStrdup(BAD_CAST(\".\"));\n+        self->grouping = xmlStrdup(BAD_CAST(\",\"));\n+        self->percent = xmlStrdup(BAD_CAST(\"%\"));\n+        self->permille = xmlStrdup(BAD_CAST(permille));\n+        self->zeroDigit = xmlStrdup(BAD_CAST(\"0\"));\n+        self->minusSign = xmlStrdup(BAD_CAST(\"-\"));\n+        self->infinity = xmlStrdup(BAD_CAST(\"Infinity\"));\n+        self->noNumber = xmlStrdup(BAD_CAST(\"NaN\"));\n@@ -310,23 +310,23 @@\n-    if (self->digit)\n-        xmlFree(self->digit);\n-    if (self->patternSeparator)\n-        xmlFree(self->patternSeparator);\n-    if (self->decimalPoint)\n-        xmlFree(self->decimalPoint);\n-    if (self->grouping)\n-        xmlFree(self->grouping);\n-    if (self->percent)\n-        xmlFree(self->percent);\n-    if (self->permille)\n-        xmlFree(self->permille);\n-    if (self->zeroDigit)\n-        xmlFree(self->zeroDigit);\n-    if (self->minusSign)\n-        xmlFree(self->minusSign);\n-    if (self->infinity)\n-        xmlFree(self->infinity);\n-    if (self->noNumber)\n-        xmlFree(self->noNumber);\n-    if (self->name)\n-        xmlFree(self->name);\n-    xmlFree(self);\n+        if (self->digit)\n+            xmlFree(self->digit);\n+        if (self->patternSeparator)\n+            xmlFree(self->patternSeparator);\n+        if (self->decimalPoint)\n+            xmlFree(self->decimalPoint);\n+        if (self->grouping)\n+            xmlFree(self->grouping);\n+        if (self->percent)\n+            xmlFree(self->percent);\n+        if (self->permille)\n+            xmlFree(self->permille);\n+        if (self->zeroDigit)\n+            xmlFree(self->zeroDigit);\n+        if (self->minusSign)\n+            xmlFree(self->minusSign);\n+        if (self->infinity)\n+            xmlFree(self->infinity);\n+        if (self->noNumber)\n+            xmlFree(self->noNumber);\n+        if (self->name)\n+            xmlFree(self->name);\n+        xmlFree(self);\n@@ -343,1 +343,1 @@\n-    return;\n+        return;\n@@ -347,3 +347,3 @@\n-    tmp = iter->next;\n-    xsltFreeDecimalFormat(iter);\n-    iter = tmp;\n+        tmp = iter->next;\n+        xsltFreeDecimalFormat(iter);\n+        iter = tmp;\n@@ -368,1 +368,1 @@\n-    return style->decimalFormat;\n+        return style->decimalFormat;\n@@ -371,7 +371,7 @@\n-    for (result = style->decimalFormat->next;\n-         result != NULL;\n-         result = result->next) {\n-        if ((result->nsUri == NULL) && xmlStrEqual(name, result->name))\n-        return result;\n-    }\n-    style = xsltNextImport(style);\n+        for (result = style->decimalFormat->next;\n+             result != NULL;\n+             result = result->next) {\n+            if ((result->nsUri == NULL) && xmlStrEqual(name, result->name))\n+                return result;\n+        }\n+        style = xsltNextImport(style);\n@@ -399,1 +399,1 @@\n-    return style->decimalFormat;\n+        return style->decimalFormat;\n@@ -402,4 +402,4 @@\n-    for (result = style->decimalFormat->next;\n-         result != NULL;\n-         result = result->next) {\n-        if (xmlStrEqual(nsUri, result->nsUri) &&\n+        for (result = style->decimalFormat->next;\n+             result != NULL;\n+             result = result->next) {\n+            if (xmlStrEqual(nsUri, result->nsUri) &&\n@@ -407,3 +407,3 @@\n-        return result;\n-    }\n-    style = xsltNextImport(style);\n+                return result;\n+        }\n+        style = xsltNextImport(style);\n@@ -428,3 +428,3 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltNewTemplate : malloc failed\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, NULL,\n+                \"xsltNewTemplate : malloc failed\\n\");\n+        return(NULL);\n@@ -446,1 +446,1 @@\n-    return;\n+        return;\n@@ -478,3 +478,3 @@\n-    cur = template;\n-    template = template->next;\n-    xsltFreeTemplate(cur);\n+        cur = template;\n+        template = template->next;\n+        xsltFreeTemplate(cur);\n@@ -492,3 +492,3 @@\n-    tmp = item;\n-    item = item->next;\n-    xmlFree(tmp);\n+        tmp = item;\n+        item = item->next;\n+        xmlFree(tmp);\n@@ -506,3 +506,3 @@\n-    tmp = item;\n-    item = item->next;\n-    xmlFree(tmp);\n+        tmp = item;\n+        item = item->next;\n+        xmlFree(tmp);\n@@ -515,3 +515,3 @@\n-            xmlDocPtr doc,\n-            xmlNsPtr ns,\n-            xmlNodePtr elem)\n+                        xmlDocPtr doc,\n+                        xmlNsPtr ns,\n+                        xmlNodePtr elem)\n@@ -522,1 +522,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -526,4 +526,4 @@\n-    xsltTransformError(NULL, cctxt->style, elem,\n-        \"Internal error: (xsltNewNamespaceMapItem) \"\n-        \"memory allocation failed.\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, cctxt->style, elem,\n+            \"Internal error: (xsltNewNamespaceMapItem) \"\n+            \"memory allocation failed.\\n\");\n+        return(NULL);\n@@ -539,1 +539,1 @@\n-    ret->next = cctxt->psData->nsMap;\n+        ret->next = cctxt->psData->nsMap;\n@@ -558,3 +558,3 @@\n-    ivartmp = ivar;\n-    ivar = ivar->next;\n-    xmlFree(ivartmp);\n+        ivartmp = ivar;\n+        ivar = ivar->next;\n+        xmlFree(ivartmp);\n@@ -573,1 +573,1 @@\n-    return;\n+        return;\n@@ -576,1 +576,1 @@\n-    \"Freeing compilation context\\n\");\n+        \"Freeing compilation context\\n\");\n@@ -578,1 +578,1 @@\n-    \"### Max inodes: %d\\n\", cctxt->maxNodeInfos);\n+        \"### Max inodes: %d\\n\", cctxt->maxNodeInfos);\n@@ -580,1 +580,1 @@\n-    \"### Max LREs  : %d\\n\", cctxt->maxLREs);\n+        \"### Max LREs  : %d\\n\", cctxt->maxLREs);\n@@ -586,6 +586,6 @@\n-    xsltCompilerNodeInfoPtr tmp, cur = cctxt->inodeList;\n-    while (cur != NULL) {\n-        tmp = cur;\n-        cur = cur->next;\n-        xmlFree(tmp);\n-    }\n+        xsltCompilerNodeInfoPtr tmp, cur = cctxt->inodeList;\n+        while (cur != NULL) {\n+            tmp = cur;\n+            cur = cur->next;\n+            xmlFree(tmp);\n+        }\n@@ -594,1 +594,1 @@\n-    xsltPointerListFree(cctxt->tmpList);\n+        xsltPointerListFree(cctxt->tmpList);\n@@ -596,1 +596,1 @@\n-    xsltFreeNsAliasList(cctxt->nsAliases);\n+        xsltFreeNsAliasList(cctxt->nsAliases);\n@@ -599,1 +599,1 @@\n-    xsltCompilerVarInfoFree(cctxt);\n+        xsltCompilerVarInfoFree(cctxt);\n@@ -618,4 +618,4 @@\n-    xsltTransformError(NULL, style, NULL,\n-        \"xsltCompilerCreate: allocation of compiler \"\n-        \"context failed.\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, style, NULL,\n+            \"xsltCompilerCreate: allocation of compiler \"\n+            \"context failed.\\n\");\n+        return(NULL);\n@@ -628,1 +628,1 @@\n-    goto internal_err;\n+        goto internal_err;\n@@ -644,3 +644,3 @@\n-    tmp = first;\n-    first = first->nextInStore;\n-    xmlFree(tmp);\n+        tmp = first;\n+        first = first->nextInStore;\n+        xmlFree(tmp);\n@@ -654,1 +654,1 @@\n-    return;\n+        return;\n@@ -657,4 +657,4 @@\n-    int i;\n-    xsltNsListContainerPtr nsi;\n-    xsltPointerListPtr list =\n-        (xsltPointerListPtr) data->inScopeNamespaces;\n+        int i;\n+        xsltNsListContainerPtr nsi;\n+        xsltPointerListPtr list =\n+            (xsltPointerListPtr) data->inScopeNamespaces;\n@@ -662,11 +662,11 @@\n-    for (i = 0; i < list->number; i++) {\n-        \/*\n-        * REVISIT TODO: Free info of in-scope namespaces.\n-        *\/\n-        nsi = (xsltNsListContainerPtr) list->items[i];\n-        if (nsi->list != NULL)\n-        xmlFree(nsi->list);\n-        xmlFree(nsi);\n-    }\n-    xsltPointerListFree(list);\n-    data->inScopeNamespaces = NULL;\n+        for (i = 0; i < list->number; i++) {\n+            \/*\n+            * REVISIT TODO: Free info of in-scope namespaces.\n+            *\/\n+            nsi = (xsltNsListContainerPtr) list->items[i];\n+            if (nsi->list != NULL)\n+                xmlFree(nsi->list);\n+            xmlFree(nsi);\n+        }\n+        xsltPointerListFree(list);\n+        data->inScopeNamespaces = NULL;\n@@ -676,3 +676,3 @@\n-    int i;\n-    xsltPointerListPtr list = (xsltPointerListPtr)\n-        data->exclResultNamespaces;\n+        int i;\n+        xsltPointerListPtr list = (xsltPointerListPtr)\n+            data->exclResultNamespaces;\n@@ -680,2 +680,2 @@\n-    for (i = 0; i < list->number; i++)\n-        xsltPointerListFree((xsltPointerListPtr) list->items[i]);\n+        for (i = 0; i < list->number; i++)\n+            xsltPointerListFree((xsltPointerListPtr) list->items[i]);\n@@ -683,2 +683,2 @@\n-    xsltPointerListFree(list);\n-    data->exclResultNamespaces = NULL;\n+        xsltPointerListFree(list);\n+        data->exclResultNamespaces = NULL;\n@@ -688,3 +688,3 @@\n-    xsltPointerListPtr list = (xsltPointerListPtr)\n-        data->extElemNamespaces;\n-    int i;\n+        xsltPointerListPtr list = (xsltPointerListPtr)\n+            data->extElemNamespaces;\n+        int i;\n@@ -692,2 +692,2 @@\n-    for (i = 0; i < list->number; i++)\n-        xsltPointerListFree((xsltPointerListPtr) list->items[i]);\n+        for (i = 0; i < list->number; i++)\n+            xsltPointerListFree((xsltPointerListPtr) list->items[i]);\n@@ -695,2 +695,2 @@\n-    xsltPointerListFree(list);\n-    data->extElemNamespaces = NULL;\n+        xsltPointerListFree(list);\n+        data->extElemNamespaces = NULL;\n@@ -699,2 +699,2 @@\n-    xsltLREEffectiveNsNodesFree(data->effectiveNs);\n-    data->effectiveNs = NULL;\n+        xsltLREEffectiveNsNodesFree(data->effectiveNs);\n+        data->effectiveNs = NULL;\n@@ -714,1 +714,1 @@\n-    xmlMalloc(sizeof(xsltPrincipalStylesheetData));\n+        xmlMalloc(sizeof(xsltPrincipalStylesheetData));\n@@ -716,3 +716,3 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltNewPrincipalStylesheetData: memory allocation failed.\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, NULL,\n+            \"xsltNewPrincipalStylesheetData: memory allocation failed.\\n\");\n+        return(NULL);\n@@ -727,1 +727,1 @@\n-    goto internal_err;\n+        goto internal_err;\n@@ -733,1 +733,1 @@\n-    goto internal_err;\n+        goto internal_err;\n@@ -739,1 +739,1 @@\n-    goto internal_err;\n+        goto internal_err;\n@@ -764,3 +764,3 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltNewStylesheet : malloc failed\\n\");\n-    goto internal_err;\n+        xsltTransformError(NULL, NULL, NULL,\n+                \"xsltNewStylesheet : malloc failed\\n\");\n+        goto internal_err;\n@@ -788,1 +788,1 @@\n-    \"creating dictionary for stylesheet\\n\");\n+        \"creating dictionary for stylesheet\\n\");\n@@ -812,1 +812,1 @@\n-    xsltFreeStylesheet(ret);\n+        xsltFreeStylesheet(ret);\n@@ -857,15 +857,15 @@\n-    int i;\n-    if (ctxt->extrasNr == 0) {\n-        ctxt->extrasMax = 20;\n-        ctxt->extras = (xsltRuntimeExtraPtr)\n-        xmlMalloc(ctxt->extrasMax * sizeof(xsltRuntimeExtra));\n-        if (ctxt->extras == NULL) {\n-        xsltTransformError(ctxt, NULL, NULL,\n-            \"xsltAllocateExtraCtxt: out of memory\\n\");\n-        return(0);\n-        }\n-        for (i = 0;i < ctxt->extrasMax;i++) {\n-        ctxt->extras[i].info = NULL;\n-        ctxt->extras[i].deallocate = NULL;\n-        ctxt->extras[i].val.ptr = NULL;\n-        }\n+        int i;\n+        if (ctxt->extrasNr == 0) {\n+            ctxt->extrasMax = 20;\n+            ctxt->extras = (xsltRuntimeExtraPtr)\n+                xmlMalloc(ctxt->extrasMax * sizeof(xsltRuntimeExtra));\n+            if (ctxt->extras == NULL) {\n+                xsltTransformError(ctxt, NULL, NULL,\n+                        \"xsltAllocateExtraCtxt: out of memory\\n\");\n+                return(0);\n+            }\n+            for (i = 0;i < ctxt->extrasMax;i++) {\n+                ctxt->extras[i].info = NULL;\n+                ctxt->extras[i].deallocate = NULL;\n+                ctxt->extras[i].val.ptr = NULL;\n+            }\n@@ -873,16 +873,17 @@\n-    } else {\n-        xsltRuntimeExtraPtr tmp;\n-\n-        ctxt->extrasMax += 100;\n-        tmp = (xsltRuntimeExtraPtr) xmlRealloc(ctxt->extras,\n-                    ctxt->extrasMax * sizeof(xsltRuntimeExtra));\n-        if (tmp == NULL) {\n-        xsltTransformError(ctxt, NULL, NULL,\n-            \"xsltAllocateExtraCtxt: out of memory\\n\");\n-        return(0);\n-        }\n-        ctxt->extras = tmp;\n-        for (i = ctxt->extrasNr;i < ctxt->extrasMax;i++) {\n-        ctxt->extras[i].info = NULL;\n-        ctxt->extras[i].deallocate = NULL;\n-        ctxt->extras[i].val.ptr = NULL;\n+        } else {\n+            xsltRuntimeExtraPtr tmp;\n+\n+            ctxt->extrasMax += 100;\n+            tmp = (xsltRuntimeExtraPtr) xmlRealloc(ctxt->extras,\n+                            ctxt->extrasMax * sizeof(xsltRuntimeExtra));\n+            if (tmp == NULL) {\n+                xsltTransformError(ctxt, NULL, NULL,\n+                        \"xsltAllocateExtraCtxt: out of memory\\n\");\n+                return(0);\n+            }\n+            ctxt->extras = tmp;\n+            for (i = ctxt->extrasNr;i < ctxt->extrasMax;i++) {\n+                ctxt->extras[i].info = NULL;\n+                ctxt->extras[i].deallocate = NULL;\n+                ctxt->extras[i].val.ptr = NULL;\n+            }\n@@ -891,1 +892,0 @@\n-    }\n@@ -906,3 +906,3 @@\n-    next = style->next;\n-    xsltFreeStylesheet(style);\n-    style = next;\n+        next = style->next;\n+        xsltFreeStylesheet(style);\n+        style = next;\n@@ -925,1 +925,1 @@\n-              xmlNodePtr rootElem ATTRIBUTE_UNUSED)\n+                          xmlNodePtr rootElem ATTRIBUTE_UNUSED)\n@@ -931,3 +931,3 @@\n-    (rootElem->type != XML_ELEMENT_NODE) ||\n-    (doc != rootElem->doc))\n-    return(-1);\n+        (rootElem->type != XML_ELEMENT_NODE) ||\n+        (doc != rootElem->doc))\n+        return(-1);\n@@ -945,8 +945,9 @@\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        \/*\n-        * Clear the PSVI field.\n-        *\/\n-        cur->psvi = NULL;\n-        if (cur->children) {\n-        cur = cur->children;\n-        continue;\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            \/*\n+            * Clear the PSVI field.\n+            *\/\n+            cur->psvi = NULL;\n+            if (cur->children) {\n+                cur = cur->children;\n+                continue;\n+            }\n@@ -954,1 +955,0 @@\n-    }\n@@ -957,10 +957,10 @@\n-    if (cur == rootElem)\n-        break;\n-    if (cur->next != NULL)\n-        cur = cur->next;\n-    else {\n-        cur = cur->parent;\n-        if (cur == NULL)\n-        break;\n-        goto leave_node;\n-    }\n+        if (cur == rootElem)\n+            break;\n+        if (cur->next != NULL)\n+            cur = cur->next;\n+        else {\n+            cur = cur->parent;\n+            if (cur == NULL)\n+                break;\n+            goto leave_node;\n+        }\n@@ -989,2 +989,2 @@\n-    xsltCleanupStylesheetTree(style->doc,\n-        xmlDocGetRootElement(style->doc));\n+        xsltCleanupStylesheetTree(style->doc,\n+            xmlDocGetRootElement(style->doc));\n@@ -996,1 +996,1 @@\n-    XSLT_HAS_INTERNAL_NSMAP(style))\n+        XSLT_HAS_INTERNAL_NSMAP(style))\n@@ -998,2 +998,2 @@\n-    xsltRestoreDocumentNamespaces(XSLT_GET_INTERNAL_NSMAP(style),\n-        style->doc);\n+        xsltRestoreDocumentNamespaces(XSLT_GET_INTERNAL_NSMAP(style),\n+            style->doc);\n@@ -1007,2 +1007,2 @@\n-    xsltCleanupStylesheetTree(style->doc,\n-        xmlDocGetRootElement(style->doc));\n+        xsltCleanupStylesheetTree(style->doc,\n+            xmlDocGetRootElement(style->doc));\n@@ -1064,4 +1064,4 @@\n-    if (style->principalData) {\n-        xsltFreePrincipalStylesheetData(style->principalData);\n-        style->principalData = NULL;\n-    }\n+        if (style->principalData) {\n+            xsltFreePrincipalStylesheetData(style->principalData);\n+            style->principalData = NULL;\n+        }\n@@ -1085,1 +1085,1 @@\n-    xmlXPathFreeContext(style->xpathCtxt);\n+        xmlXPathFreeContext(style->xpathCtxt);\n@@ -1092,3 +1092,3 @@\n- *                                  *\n- *      Parsing of an XSLT Stylesheet               *\n- *                                  *\n+ *                                                                      *\n+ *              Parsing of an XSLT Stylesheet                           *\n+ *                                                                      *\n@@ -1116,2 +1116,2 @@\n-                   xsltTemplatePtr template,\n-                   xmlNodePtr node)\n+                       xsltTemplatePtr template,\n+                       xmlNodePtr node)\n@@ -1126,2 +1126,2 @@\n-    (template->inheritedNsNr != 0) || (template->inheritedNs != NULL))\n-    return(0);\n+        (template->inheritedNsNr != 0) || (template->inheritedNs != NULL))\n+        return(0);\n@@ -1132,2 +1132,2 @@\n-        if (xmlStrEqual(cur->href, XSLT_NAMESPACE))\n-            goto skip_ns;\n+                if (xmlStrEqual(cur->href, XSLT_NAMESPACE))\n+                    goto skip_ns;\n@@ -1135,12 +1135,12 @@\n-        if ((cur->prefix != NULL) &&\n-            (xsltCheckExtPrefix(style, cur->prefix)))\n-            goto skip_ns;\n-        \/*\n-        * Check if this namespace was excluded.\n-        * Note that at this point only the exclusions defined\n-        * on the topmost stylesheet element are in the exclusion-list.\n-        *\/\n-        for (i = 0;i < style->exclPrefixNr;i++) {\n-            if (xmlStrEqual(cur->href, style->exclPrefixTab[i]))\n-            goto skip_ns;\n-        }\n+                if ((cur->prefix != NULL) &&\n+                    (xsltCheckExtPrefix(style, cur->prefix)))\n+                    goto skip_ns;\n+                \/*\n+                * Check if this namespace was excluded.\n+                * Note that at this point only the exclusions defined\n+                * on the topmost stylesheet element are in the exclusion-list.\n+                *\/\n+                for (i = 0;i < style->exclPrefixNr;i++) {\n+                    if (xmlStrEqual(cur->href, style->exclPrefixTab[i]))\n+                        goto skip_ns;\n+                }\n@@ -1158,3 +1158,3 @@\n-        \/*\n-        * Skip shadowed namespace bindings.\n-        *\/\n+                \/*\n+                * Skip shadowed namespace bindings.\n+                *\/\n@@ -1193,2 +1193,2 @@\n-    template->inheritedNsNr = nbns;\n-    template->inheritedNs = ret;\n+        template->inheritedNsNr = nbns;\n+        template->inheritedNs = ret;\n@@ -1248,7 +1248,7 @@\n-    \/*\n-    * TODO: Don't use xsltGetQNameURI().\n-    *\/\n-    URI = xsltGetQNameURI(cur, &prop);\n-    if (prop == NULL) {\n-        if (style != NULL) style->errors++;\n-    } else if (URI == NULL) {\n+        \/*\n+        * TODO: Don't use xsltGetQNameURI().\n+        *\/\n+        URI = xsltGetQNameURI(cur, &prop);\n+        if (prop == NULL) {\n+            if (style != NULL) style->errors++;\n+        } else if (URI == NULL) {\n@@ -1260,1 +1260,1 @@\n-        xsltTransformError(NULL, style, cur,\n+                xsltTransformError(NULL, style, cur,\n@@ -1265,4 +1265,4 @@\n-    } else {\n-        style->method = prop;\n-        style->methodURI = xmlStrdup(URI);\n-    }\n+        } else {\n+            style->method = prop;\n+            style->methodURI = xmlStrdup(URI);\n+        }\n@@ -1292,1 +1292,1 @@\n-        xsltTransformError(NULL, style, cur,\n+            xsltTransformError(NULL, style, cur,\n@@ -1306,1 +1306,1 @@\n-        xsltTransformError(NULL, style, cur,\n+            xsltTransformError(NULL, style, cur,\n@@ -1320,1 +1320,1 @@\n-        xsltTransformError(NULL, style, cur,\n+            xsltTransformError(NULL, style, cur,\n@@ -1329,1 +1329,1 @@\n-    NULL);\n+        NULL);\n@@ -1352,24 +1352,8 @@\n-        if (xmlValidateQName(BAD_CAST element, 0) != 0) {\n-            xsltTransformError(NULL, style, cur,\n-            \"Attribute 'cdata-section-elements': The value \"\n-            \"'%s' is not a valid QName.\\n\", element);\n-            xmlFree(element);\n-            style->errors++;\n-        } else {\n-            const xmlChar *URI;\n-\n-            \/*\n-            * TODO: Don't use xsltGetQNameURI().\n-            *\/\n-            URI = xsltGetQNameURI(cur, &element);\n-            if (element == NULL) {\n-            \/*\n-            * TODO: We'll report additionally an error\n-            *  via the stylesheet's error handling.\n-            *\/\n-            xsltTransformError(NULL, style, cur,\n-                \"Attribute 'cdata-section-elements': \"\n-                \"Not a valid QName.\\n\");\n-            style->errors++;\n-            } else {\n-            xmlNsPtr ns;\n+                if (xmlValidateQName(BAD_CAST element, 0) != 0) {\n+                    xsltTransformError(NULL, style, cur,\n+                        \"Attribute 'cdata-section-elements': The value \"\n+                        \"'%s' is not a valid QName.\\n\", element);\n+                    xmlFree(element);\n+                    style->errors++;\n+                } else {\n+                    const xmlChar *URI;\n@@ -1377,18 +1361,34 @@\n-            \/*\n-            * XSLT-1.0 \"Each QName is expanded into an\n-            *  expanded-name using the namespace declarations in\n-            *  effect on the xsl:output element in which the QName\n-            *  occurs; if there is a default namespace, it is used\n-            *  for QNames that do not have a prefix\"\n-            * NOTE: Fix of bug #339570.\n-            *\/\n-            if (URI == NULL) {\n-                ns = xmlSearchNs(style->doc, cur, NULL);\n-                if (ns != NULL)\n-                URI = ns->href;\n-            }\n-            xmlHashAddEntry2(style->cdataSection, element, URI,\n-                (void *) \"cdata\");\n-            xmlFree(element);\n-            }\n-        }\n+                    \/*\n+                    * TODO: Don't use xsltGetQNameURI().\n+                    *\/\n+                    URI = xsltGetQNameURI(cur, &element);\n+                    if (element == NULL) {\n+                        \/*\n+                        * TODO: We'll report additionally an error\n+                        *  via the stylesheet's error handling.\n+                        *\/\n+                        xsltTransformError(NULL, style, cur,\n+                            \"Attribute 'cdata-section-elements': \"\n+                            \"Not a valid QName.\\n\");\n+                        style->errors++;\n+                    } else {\n+                        xmlNsPtr ns;\n+\n+                        \/*\n+                        * XSLT-1.0 \"Each QName is expanded into an\n+                        *  expanded-name using the namespace declarations in\n+                        *  effect on the xsl:output element in which the QName\n+                        *  occurs; if there is a default namespace, it is used\n+                        *  for QNames that do not have a prefix\"\n+                        * NOTE: Fix of bug #339570.\n+                        *\/\n+                        if (URI == NULL) {\n+                            ns = xmlSearchNs(style->doc, cur, NULL);\n+                            if (ns != NULL)\n+                                URI = ns->href;\n+                        }\n+                        xmlHashAddEntry2(style->cdataSection, element, URI,\n+                            (void *) \"cdata\");\n+                        xmlFree(element);\n+                    }\n+                }\n@@ -1403,3 +1403,3 @@\n-    if (style->mediaType)\n-        xmlFree(style->mediaType);\n-    style->mediaType = prop;\n+        if (style->mediaType)\n+            xmlFree(style->mediaType);\n+        style->mediaType = prop;\n@@ -1408,1 +1408,1 @@\n-    xsltParseContentError(style, cur->children);\n+        xsltParseContentError(style, cur->children);\n@@ -1435,1 +1435,1 @@\n-    return;\n+        return;\n@@ -1446,1 +1446,1 @@\n-        style->warnings++;\n+            style->warnings++;\n@@ -1455,1 +1455,1 @@\n-        style->warnings++;\n+            style->warnings++;\n@@ -1458,5 +1458,5 @@\n-    format = xsltDecimalFormatGetByQName(style, nsUri, prop);\n-    if (format != NULL) {\n-        xsltTransformError(NULL, style, cur,\n-     \"xsltParseStylestyleDecimalFormat: %s already exists\\n\", prop);\n-        style->warnings++;\n+        format = xsltDecimalFormatGetByQName(style, nsUri, prop);\n+        if (format != NULL) {\n+            xsltTransformError(NULL, style, cur,\n+         \"xsltParseStylestyleDecimalFormat: %s already exists\\n\", prop);\n+            style->warnings++;\n@@ -1464,5 +1464,5 @@\n-        return;\n-    }\n-    format = xsltNewDecimalFormat(nsUri, prop);\n-    if (format == NULL) {\n-        xsltTransformError(NULL, style, cur,\n+            return;\n+        }\n+        format = xsltNewDecimalFormat(nsUri, prop);\n+        if (format == NULL) {\n+            xsltTransformError(NULL, style, cur,\n@@ -1470,1 +1470,1 @@\n-        style->errors++;\n+            style->errors++;\n@@ -1472,7 +1472,7 @@\n-        return;\n-    }\n-    \/* Append new decimal-format structure *\/\n-    for (iter = style->decimalFormat; iter->next; iter = iter->next)\n-        ;\n-    if (iter)\n-        iter->next = format;\n+            return;\n+        }\n+        \/* Append new decimal-format structure *\/\n+        for (iter = style->decimalFormat; iter->next; iter = iter->next)\n+            ;\n+        if (iter)\n+            iter->next = format;\n@@ -1483,2 +1483,2 @@\n-    if (format->decimalPoint != NULL) xmlFree(format->decimalPoint);\n-    format->decimalPoint  = prop;\n+        if (format->decimalPoint != NULL) xmlFree(format->decimalPoint);\n+        format->decimalPoint  = prop;\n@@ -1489,2 +1489,2 @@\n-    if (format->grouping != NULL) xmlFree(format->grouping);\n-    format->grouping  = prop;\n+        if (format->grouping != NULL) xmlFree(format->grouping);\n+        format->grouping  = prop;\n@@ -1495,2 +1495,2 @@\n-    if (format->infinity != NULL) xmlFree(format->infinity);\n-    format->infinity  = prop;\n+        if (format->infinity != NULL) xmlFree(format->infinity);\n+        format->infinity  = prop;\n@@ -1501,2 +1501,2 @@\n-    if (format->minusSign != NULL) xmlFree(format->minusSign);\n-    format->minusSign  = prop;\n+        if (format->minusSign != NULL) xmlFree(format->minusSign);\n+        format->minusSign  = prop;\n@@ -1507,2 +1507,2 @@\n-    if (format->noNumber != NULL) xmlFree(format->noNumber);\n-    format->noNumber  = prop;\n+        if (format->noNumber != NULL) xmlFree(format->noNumber);\n+        format->noNumber  = prop;\n@@ -1513,2 +1513,2 @@\n-    if (format->percent != NULL) xmlFree(format->percent);\n-    format->percent  = prop;\n+        if (format->percent != NULL) xmlFree(format->percent);\n+        format->percent  = prop;\n@@ -1519,2 +1519,2 @@\n-    if (format->permille != NULL) xmlFree(format->permille);\n-    format->permille  = prop;\n+        if (format->permille != NULL) xmlFree(format->permille);\n+        format->permille  = prop;\n@@ -1525,2 +1525,2 @@\n-    if (format->zeroDigit != NULL) xmlFree(format->zeroDigit);\n-    format->zeroDigit  = prop;\n+        if (format->zeroDigit != NULL) xmlFree(format->zeroDigit);\n+        format->zeroDigit  = prop;\n@@ -1531,2 +1531,2 @@\n-    if (format->digit != NULL) xmlFree(format->digit);\n-    format->digit  = prop;\n+        if (format->digit != NULL) xmlFree(format->digit);\n+        format->digit  = prop;\n@@ -1537,2 +1537,2 @@\n-    if (format->patternSeparator != NULL) xmlFree(format->patternSeparator);\n-    format->patternSeparator  = prop;\n+        if (format->patternSeparator != NULL) xmlFree(format->patternSeparator);\n+        format->patternSeparator  = prop;\n@@ -1541,1 +1541,1 @@\n-    xsltParseContentError(style, cur->children);\n+        xsltParseContentError(style, cur->children);\n@@ -1560,1 +1560,1 @@\n-    return;\n+        return;\n@@ -1564,4 +1564,4 @@\n-    xsltTransformError(NULL, style, cur,\n-        \"xsltParseStylesheetPreserveSpace: missing elements attribute\\n\");\n-    if (style != NULL) style->warnings++;\n-    return;\n+        xsltTransformError(NULL, style, cur,\n+            \"xsltParseStylesheetPreserveSpace: missing elements attribute\\n\");\n+        if (style != NULL) style->warnings++;\n+        return;\n@@ -1571,1 +1571,1 @@\n-    style->stripSpaces = xmlHashCreate(10);\n+        style->stripSpaces = xmlHashCreate(10);\n@@ -1573,1 +1573,1 @@\n-    return;\n+        return;\n@@ -1577,3 +1577,3 @@\n-    while (IS_BLANK(*element)) element++;\n-    if (*element == 0)\n-        break;\n+        while (IS_BLANK(*element)) element++;\n+        if (*element == 0)\n+            break;\n@@ -1581,3 +1581,3 @@\n-    while ((*end != 0) && (!IS_BLANK(*end))) end++;\n-    element = xmlStrndup(element, end - element);\n-    if (element) {\n+        while ((*end != 0) && (!IS_BLANK(*end))) end++;\n+        element = xmlStrndup(element, end - element);\n+        if (element) {\n@@ -1585,2 +1585,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-        \"add preserved space element %s\\n\", element);\n+            xsltGenericDebug(xsltGenericDebugContext,\n+                \"add preserved space element %s\\n\", element);\n@@ -1588,4 +1588,4 @@\n-        if (xmlStrEqual(element, (const xmlChar *)\"*\")) {\n-        style->stripAll = -1;\n-        } else {\n-        const xmlChar *URI;\n+            if (xmlStrEqual(element, (const xmlChar *)\"*\")) {\n+                style->stripAll = -1;\n+            } else {\n+                const xmlChar *URI;\n@@ -1593,3 +1593,3 @@\n-        \/*\n-        * TODO: Don't use xsltGetQNameURI().\n-        *\/\n+                \/*\n+                * TODO: Don't use xsltGetQNameURI().\n+                *\/\n@@ -1598,2 +1598,4 @@\n-        xmlHashAddEntry2(style->stripSpaces, element, URI,\n-                (xmlChar *) \"preserve\");\n+                xmlHashAddEntry2(style->stripSpaces, element, URI,\n+                                (xmlChar *) \"preserve\");\n+            }\n+            xmlFree(element);\n@@ -1601,3 +1603,1 @@\n-        xmlFree(element);\n-    }\n-    element = end;\n+        element = end;\n@@ -1607,1 +1607,1 @@\n-    xsltParseContentError(style, cur->children);\n+        xsltParseContentError(style, cur->children);\n@@ -1629,1 +1629,1 @@\n-                 int isXsltElem) {\n+                             int isXsltElem) {\n@@ -1634,1 +1634,1 @@\n-    return;\n+        return;\n@@ -1637,3 +1637,3 @@\n-    \/* For xsl:stylesheet\/xsl:transform. *\/\n-    prefixes = xmlGetNsProp(cur,\n-        (const xmlChar *)\"extension-element-prefixes\", NULL);\n+        \/* For xsl:stylesheet\/xsl:transform. *\/\n+        prefixes = xmlGetNsProp(cur,\n+            (const xmlChar *)\"extension-element-prefixes\", NULL);\n@@ -1641,3 +1641,3 @@\n-    \/* For literal result elements and extension instructions. *\/\n-    prefixes = xmlGetNsProp(cur,\n-        (const xmlChar *)\"extension-element-prefixes\", XSLT_NAMESPACE);\n+        \/* For literal result elements and extension instructions. *\/\n+        prefixes = xmlGetNsProp(cur,\n+            (const xmlChar *)\"extension-element-prefixes\", XSLT_NAMESPACE);\n@@ -1646,1 +1646,1 @@\n-    return;\n+        return;\n@@ -1651,3 +1651,3 @@\n-    while (IS_BLANK(*prefix)) prefix++;\n-    if (*prefix == 0)\n-        break;\n+        while (IS_BLANK(*prefix)) prefix++;\n+        if (*prefix == 0)\n+            break;\n@@ -1655,4 +1655,4 @@\n-    while ((*end != 0) && (!IS_BLANK(*end))) end++;\n-    prefix = xmlStrndup(prefix, end - prefix);\n-    if (prefix) {\n-        xmlNsPtr ns;\n+        while ((*end != 0) && (!IS_BLANK(*end))) end++;\n+        prefix = xmlStrndup(prefix, end - prefix);\n+        if (prefix) {\n+            xmlNsPtr ns;\n@@ -1660,10 +1660,10 @@\n-        if (xmlStrEqual(prefix, (const xmlChar *)\"#default\"))\n-        ns = xmlSearchNs(style->doc, cur, NULL);\n-        else\n-        ns = xmlSearchNs(style->doc, cur, prefix);\n-        if (ns == NULL) {\n-        xsltTransformError(NULL, style, cur,\n-        \"xsl:extension-element-prefix : undefined namespace %s\\n\",\n-                             prefix);\n-        if (style != NULL) style->warnings++;\n-        } else {\n+            if (xmlStrEqual(prefix, (const xmlChar *)\"#default\"))\n+                ns = xmlSearchNs(style->doc, cur, NULL);\n+            else\n+                ns = xmlSearchNs(style->doc, cur, prefix);\n+            if (ns == NULL) {\n+                xsltTransformError(NULL, style, cur,\n+            \"xsl:extension-element-prefix : undefined namespace %s\\n\",\n+                                 prefix);\n+                if (style != NULL) style->warnings++;\n+            } else {\n@@ -1671,2 +1671,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-            \"add extension prefix %s\\n\", prefix);\n+                xsltGenericDebug(xsltGenericDebugContext,\n+                    \"add extension prefix %s\\n\", prefix);\n@@ -1674,1 +1674,3 @@\n-        xsltRegisterExtPrefix(style, prefix, ns->href);\n+                xsltRegisterExtPrefix(style, prefix, ns->href);\n+            }\n+            xmlFree(prefix);\n@@ -1676,3 +1678,1 @@\n-        xmlFree(prefix);\n-    }\n-    prefix = end;\n+        prefix = end;\n@@ -1699,1 +1699,1 @@\n-    return;\n+        return;\n@@ -1703,4 +1703,4 @@\n-    xsltTransformError(NULL, style, cur,\n-        \"xsltParseStylesheetStripSpace: missing elements attribute\\n\");\n-    if (style != NULL) style->warnings++;\n-    return;\n+        xsltTransformError(NULL, style, cur,\n+            \"xsltParseStylesheetStripSpace: missing elements attribute\\n\");\n+        if (style != NULL) style->warnings++;\n+        return;\n@@ -1710,1 +1710,1 @@\n-    style->stripSpaces = xmlHashCreate(10);\n+        style->stripSpaces = xmlHashCreate(10);\n@@ -1712,1 +1712,1 @@\n-    return;\n+        return;\n@@ -1716,3 +1716,3 @@\n-    while (IS_BLANK(*element)) element++;\n-    if (*element == 0)\n-        break;\n+        while (IS_BLANK(*element)) element++;\n+        if (*element == 0)\n+            break;\n@@ -1720,3 +1720,3 @@\n-    while ((*end != 0) && (!IS_BLANK(*end))) end++;\n-    element = xmlStrndup(element, end - element);\n-    if (element) {\n+        while ((*end != 0) && (!IS_BLANK(*end))) end++;\n+        element = xmlStrndup(element, end - element);\n+        if (element) {\n@@ -1724,2 +1724,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-        \"add stripped space element %s\\n\", element);\n+            xsltGenericDebug(xsltGenericDebugContext,\n+                \"add stripped space element %s\\n\", element);\n@@ -1727,4 +1727,4 @@\n-        if (xmlStrEqual(element, (const xmlChar *)\"*\")) {\n-        style->stripAll = 1;\n-        } else {\n-        const xmlChar *URI;\n+            if (xmlStrEqual(element, (const xmlChar *)\"*\")) {\n+                style->stripAll = 1;\n+            } else {\n+                const xmlChar *URI;\n@@ -1732,3 +1732,3 @@\n-        \/*\n-        * TODO: Don't use xsltGetQNameURI().\n-        *\/\n+                \/*\n+                * TODO: Don't use xsltGetQNameURI().\n+                *\/\n@@ -1737,2 +1737,4 @@\n-        xmlHashAddEntry2(style->stripSpaces, element, URI,\n-                    (xmlChar *) \"strip\");\n+                xmlHashAddEntry2(style->stripSpaces, element, URI,\n+                                (xmlChar *) \"strip\");\n+            }\n+            xmlFree(element);\n@@ -1740,3 +1742,1 @@\n-        xmlFree(element);\n-    }\n-    element = end;\n+        element = end;\n@@ -1746,1 +1746,1 @@\n-    xsltParseContentError(style, cur->children);\n+        xsltParseContentError(style, cur->children);\n@@ -1765,1 +1765,1 @@\n-                 int isXsltElem)\n+                                 int isXsltElem)\n@@ -1772,1 +1772,1 @@\n-    return(0);\n+        return(0);\n@@ -1775,2 +1775,2 @@\n-    prefixes = xmlGetNsProp(cur,\n-        (const xmlChar *)\"exclude-result-prefixes\", NULL);\n+        prefixes = xmlGetNsProp(cur,\n+            (const xmlChar *)\"exclude-result-prefixes\", NULL);\n@@ -1778,2 +1778,2 @@\n-    prefixes = xmlGetNsProp(cur,\n-        (const xmlChar *)\"exclude-result-prefixes\", XSLT_NAMESPACE);\n+        prefixes = xmlGetNsProp(cur,\n+            (const xmlChar *)\"exclude-result-prefixes\", XSLT_NAMESPACE);\n@@ -1782,1 +1782,1 @@\n-    return(0);\n+        return(0);\n@@ -1787,3 +1787,3 @@\n-    while (IS_BLANK(*prefix)) prefix++;\n-    if (*prefix == 0)\n-        break;\n+        while (IS_BLANK(*prefix)) prefix++;\n+        if (*prefix == 0)\n+            break;\n@@ -1791,4 +1791,4 @@\n-    while ((*end != 0) && (!IS_BLANK(*end))) end++;\n-    prefix = xmlStrndup(prefix, end - prefix);\n-    if (prefix) {\n-        xmlNsPtr ns;\n+        while ((*end != 0) && (!IS_BLANK(*end))) end++;\n+        prefix = xmlStrndup(prefix, end - prefix);\n+        if (prefix) {\n+            xmlNsPtr ns;\n@@ -1796,11 +1796,11 @@\n-        if (xmlStrEqual(prefix, (const xmlChar *)\"#default\"))\n-        ns = xmlSearchNs(style->doc, cur, NULL);\n-        else\n-        ns = xmlSearchNs(style->doc, cur, prefix);\n-        if (ns == NULL) {\n-        xsltTransformError(NULL, style, cur,\n-        \"xsl:exclude-result-prefixes : undefined namespace %s\\n\",\n-                             prefix);\n-        if (style != NULL) style->warnings++;\n-        } else {\n-        if (exclPrefixPush(style, (xmlChar *) ns->href) >= 0) {\n+            if (xmlStrEqual(prefix, (const xmlChar *)\"#default\"))\n+                ns = xmlSearchNs(style->doc, cur, NULL);\n+            else\n+                ns = xmlSearchNs(style->doc, cur, prefix);\n+            if (ns == NULL) {\n+                xsltTransformError(NULL, style, cur,\n+            \"xsl:exclude-result-prefixes : undefined namespace %s\\n\",\n+                                 prefix);\n+                if (style != NULL) style->warnings++;\n+            } else {\n+                if (exclPrefixPush(style, (xmlChar *) ns->href) >= 0) {\n@@ -1808,2 +1808,2 @@\n-            xsltGenericDebug(xsltGenericDebugContext,\n-            \"exclude result prefix %s\\n\", prefix);\n+                    xsltGenericDebug(xsltGenericDebugContext,\n+                        \"exclude result prefix %s\\n\", prefix);\n@@ -1811,2 +1811,4 @@\n-            nb++;\n-        }\n+                    nb++;\n+                }\n+            }\n+            xmlFree(prefix);\n@@ -1814,3 +1816,1 @@\n-        xmlFree(prefix);\n-    }\n-    prefix = end;\n+        prefix = end;\n@@ -1839,1 +1839,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -1841,1 +1841,1 @@\n-    return (doc->oldNs);\n+        return (doc->oldNs);\n@@ -1843,13 +1843,13 @@\n-    xmlNsPtr ns;\n-    ns = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));\n-    if (ns == NULL) {\n-        xmlGenericError(xmlGenericErrorContext,\n-        \"xsltTreeEnsureXMLDecl: Failed to allocate \"\n-        \"the XML namespace.\\n\");\n-        return (NULL);\n-    }\n-    memset(ns, 0, sizeof(xmlNs));\n-    ns->type = XML_LOCAL_NAMESPACE;\n-    \/*\n-    * URGENT TODO: revisit this.\n-    *\/\n+        xmlNsPtr ns;\n+        ns = (xmlNsPtr) xmlMalloc(sizeof(xmlNs));\n+        if (ns == NULL) {\n+            xmlGenericError(xmlGenericErrorContext,\n+                \"xsltTreeEnsureXMLDecl: Failed to allocate \"\n+                \"the XML namespace.\\n\");\n+            return (NULL);\n+        }\n+        memset(ns, 0, sizeof(xmlNs));\n+        ns->type = XML_LOCAL_NAMESPACE;\n+        \/*\n+        * URGENT TODO: revisit this.\n+        *\/\n@@ -1857,4 +1857,4 @@\n-    if (doc->dict)\n-        ns->href = xmlDictLookup(doc->dict, XML_XML_NAMESPACE, -1);\n-    else\n-        ns->href = xmlStrdup(XML_XML_NAMESPACE);\n+        if (doc->dict)\n+            ns->href = xmlDictLookup(doc->dict, XML_XML_NAMESPACE, -1);\n+        else\n+            ns->href = xmlStrdup(XML_XML_NAMESPACE);\n@@ -1862,1 +1862,1 @@\n-    ns->href = xmlStrdup(XML_XML_NAMESPACE);\n+        ns->href = xmlStrdup(XML_XML_NAMESPACE);\n@@ -1864,3 +1864,3 @@\n-    ns->prefix = xmlStrdup((const xmlChar *)\"xml\");\n-    doc->oldNs = ns;\n-    return (ns);\n+        ns->prefix = xmlStrdup((const xmlChar *)\"xml\");\n+        doc->oldNs = ns;\n+        return (ns);\n@@ -1886,2 +1886,2 @@\n-            const xmlChar *nsName,\n-            const xmlChar *prefix)\n+                        const xmlChar *nsName,\n+                        const xmlChar *prefix)\n@@ -1892,1 +1892,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -1894,1 +1894,1 @@\n-    ns = doc->oldNs;\n+        ns = doc->oldNs;\n@@ -1896,1 +1896,1 @@\n-    ns = xsltTreeEnsureXMLDecl(doc);\n+        ns = xsltTreeEnsureXMLDecl(doc);\n@@ -1898,1 +1898,1 @@\n-    return (NULL);\n+        return (NULL);\n@@ -1900,13 +1900,13 @@\n-    \/* Reuse. *\/\n-    ns = ns->next;\n-    while (ns != NULL) {\n-        if ((ns->prefix == NULL) != (prefix == NULL)) {\n-        \/* NOP *\/\n-        } else if (prefix == NULL) {\n-        if (xmlStrEqual(ns->href, nsName))\n-            return (ns);\n-        } else {\n-        if ((ns->prefix[0] == prefix[0]) &&\n-             xmlStrEqual(ns->prefix, prefix) &&\n-             xmlStrEqual(ns->href, nsName))\n-            return (ns);\n+        \/* Reuse. *\/\n+        ns = ns->next;\n+        while (ns != NULL) {\n+            if ((ns->prefix == NULL) != (prefix == NULL)) {\n+                \/* NOP *\/\n+            } else if (prefix == NULL) {\n+                if (xmlStrEqual(ns->href, nsName))\n+                    return (ns);\n+            } else {\n+                if ((ns->prefix[0] == prefix[0]) &&\n+                     xmlStrEqual(ns->prefix, prefix) &&\n+                     xmlStrEqual(ns->href, nsName))\n+                    return (ns);\n@@ -1914,0 +1914,4 @@\n+            }\n+            if (ns->next == NULL)\n+                break;\n+            ns = ns->next;\n@@ -1915,4 +1919,0 @@\n-        if (ns->next == NULL)\n-        break;\n-        ns = ns->next;\n-    }\n@@ -1933,1 +1933,1 @@\n-            xmlNodePtr elem)\n+                        xmlNodePtr elem)\n@@ -1939,1 +1939,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1941,1 +1941,1 @@\n-    return(0);\n+        return(0);\n@@ -1945,90 +1945,0 @@\n-    if ( \/* If both namespaces are NULL... *\/\n-        ( (elem->ns == NULL) &&\n-        ((alias->literalNs == NULL) ||\n-        (alias->literalNs->href == NULL)) ) ||\n-        \/* ... or both namespace are equal *\/\n-        ( (elem->ns != NULL) &&\n-        (alias->literalNs != NULL) &&\n-        xmlStrEqual(elem->ns->href, alias->literalNs->href) ) )\n-    {\n-        if ((alias->targetNs != NULL) &&\n-        (alias->targetNs->href != NULL))\n-        {\n-        \/*\n-        * Convert namespace.\n-        *\/\n-        if (elem->doc == alias->docOfTargetNs) {\n-            \/*\n-            * This is the nice case: same docs.\n-            * This will eventually assign a ns-decl which\n-            * is shadowed, but this has no negative effect on\n-            * the generation of the result tree.\n-            *\/\n-            elem->ns = alias->targetNs;\n-        } else {\n-            \/*\n-            * This target xmlNs originates from a different\n-            * stylesheet tree. Try to locate it in the\n-            * in-scope namespaces.\n-            * OPTIMIZE TODO: Use the compiler-node-info inScopeNs.\n-            *\/\n-            ns = xmlSearchNs(elem->doc, elem,\n-            alias->targetNs->prefix);\n-            \/*\n-            * If no matching ns-decl found, then assign a\n-            * ns-decl stored in xmlDoc.\n-            *\/\n-            if ((ns == NULL) ||\n-            (! xmlStrEqual(ns->href, alias->targetNs->href)))\n-            {\n-            \/*\n-            * BIG NOTE: The use of xsltTreeAcquireStoredNs()\n-            *  is not very efficient, but currently I don't\n-            *  see an other way of *safely* changing a node's\n-            *  namespace, since the xmlNs struct in\n-            *  alias->targetNs might come from an other\n-            *  stylesheet tree. So we need to anchor it in the\n-            *  current document, without adding it to the tree,\n-            *  which would otherwise change the in-scope-ns\n-            *  semantic of the tree.\n-            *\/\n-            ns = xsltTreeAcquireStoredNs(elem->doc,\n-                alias->targetNs->href,\n-                alias->targetNs->prefix);\n-\n-            if (ns == NULL) {\n-                xsltTransformError(NULL, cctxt->style, elem,\n-                \"Internal error in \"\n-                \"xsltLREBuildEffectiveNs(): \"\n-                \"failed to acquire a stored \"\n-                \"ns-declaration.\\n\");\n-                cctxt->style->errors++;\n-                return(-1);\n-\n-            }\n-            }\n-            elem->ns = ns;\n-        }\n-        } else {\n-        \/*\n-        * Move into or leave in the NULL namespace.\n-        *\/\n-        elem->ns = NULL;\n-        }\n-        break;\n-    }\n-    alias = alias->next;\n-    }\n-    \/*\n-    * Same with attributes of literal result elements.\n-    *\/\n-    if (elem->properties != NULL) {\n-    xmlAttrPtr attr = elem->properties;\n-\n-    while (attr != NULL) {\n-        if (attr->ns == NULL) {\n-        attr = attr->next;\n-        continue;\n-        }\n-        alias = cctxt->nsAliases;\n-        while (alias != NULL) {\n@@ -2045,1 +1955,1 @@\n-            (alias->targetNs->href != NULL))\n+                (alias->targetNs->href != NULL))\n@@ -2047,20 +1957,50 @@\n-            if (elem->doc == alias->docOfTargetNs) {\n-                elem->ns = alias->targetNs;\n-            } else {\n-                ns = xmlSearchNs(elem->doc, elem,\n-                alias->targetNs->prefix);\n-                if ((ns == NULL) ||\n-                (! xmlStrEqual(ns->href, alias->targetNs->href)))\n-                {\n-                ns = xsltTreeAcquireStoredNs(elem->doc,\n-                    alias->targetNs->href,\n-                    alias->targetNs->prefix);\n-\n-                if (ns == NULL) {\n-                    xsltTransformError(NULL, cctxt->style, elem,\n-                    \"Internal error in \"\n-                    \"xsltLREBuildEffectiveNs(): \"\n-                    \"failed to acquire a stored \"\n-                    \"ns-declaration.\\n\");\n-                    cctxt->style->errors++;\n-                    return(-1);\n+                \/*\n+                * Convert namespace.\n+                *\/\n+                if (elem->doc == alias->docOfTargetNs) {\n+                    \/*\n+                    * This is the nice case: same docs.\n+                    * This will eventually assign a ns-decl which\n+                    * is shadowed, but this has no negative effect on\n+                    * the generation of the result tree.\n+                    *\/\n+                    elem->ns = alias->targetNs;\n+                } else {\n+                    \/*\n+                    * This target xmlNs originates from a different\n+                    * stylesheet tree. Try to locate it in the\n+                    * in-scope namespaces.\n+                    * OPTIMIZE TODO: Use the compiler-node-info inScopeNs.\n+                    *\/\n+                    ns = xmlSearchNs(elem->doc, elem,\n+                        alias->targetNs->prefix);\n+                    \/*\n+                    * If no matching ns-decl found, then assign a\n+                    * ns-decl stored in xmlDoc.\n+                    *\/\n+                    if ((ns == NULL) ||\n+                        (! xmlStrEqual(ns->href, alias->targetNs->href)))\n+                    {\n+                        \/*\n+                        * BIG NOTE: The use of xsltTreeAcquireStoredNs()\n+                        *  is not very efficient, but currently I don't\n+                        *  see an other way of *safely* changing a node's\n+                        *  namespace, since the xmlNs struct in\n+                        *  alias->targetNs might come from an other\n+                        *  stylesheet tree. So we need to anchor it in the\n+                        *  current document, without adding it to the tree,\n+                        *  which would otherwise change the in-scope-ns\n+                        *  semantic of the tree.\n+                        *\/\n+                        ns = xsltTreeAcquireStoredNs(elem->doc,\n+                            alias->targetNs->href,\n+                            alias->targetNs->prefix);\n+\n+                        if (ns == NULL) {\n+                            xsltTransformError(NULL, cctxt->style, elem,\n+                                \"Internal error in \"\n+                                \"xsltLREBuildEffectiveNs(): \"\n+                                \"failed to acquire a stored \"\n+                                \"ns-declaration.\\n\");\n+                            cctxt->style->errors++;\n+                            return(-1);\n@@ -2068,0 +2008,3 @@\n+                        }\n+                    }\n+                    elem->ns = ns;\n@@ -2069,3 +2012,0 @@\n-                }\n-                elem->ns = ns;\n-            }\n@@ -2073,4 +2013,4 @@\n-            \/*\n-            * Move into or leave in the NULL namespace.\n-            *\/\n-            elem->ns = NULL;\n+                \/*\n+                * Move into or leave in the NULL namespace.\n+                *\/\n+                elem->ns = NULL;\n@@ -2081,3 +2021,0 @@\n-        }\n-\n-        attr = attr->next;\n@@ -2085,0 +2022,63 @@\n+    \/*\n+    * Same with attributes of literal result elements.\n+    *\/\n+    if (elem->properties != NULL) {\n+        xmlAttrPtr attr = elem->properties;\n+\n+        while (attr != NULL) {\n+            if (attr->ns == NULL) {\n+                attr = attr->next;\n+                continue;\n+            }\n+            alias = cctxt->nsAliases;\n+            while (alias != NULL) {\n+                if ( \/* If both namespaces are NULL... *\/\n+                    ( (elem->ns == NULL) &&\n+                    ((alias->literalNs == NULL) ||\n+                    (alias->literalNs->href == NULL)) ) ||\n+                    \/* ... or both namespace are equal *\/\n+                    ( (elem->ns != NULL) &&\n+                    (alias->literalNs != NULL) &&\n+                    xmlStrEqual(elem->ns->href, alias->literalNs->href) ) )\n+                {\n+                    if ((alias->targetNs != NULL) &&\n+                        (alias->targetNs->href != NULL))\n+                    {\n+                        if (elem->doc == alias->docOfTargetNs) {\n+                            elem->ns = alias->targetNs;\n+                        } else {\n+                            ns = xmlSearchNs(elem->doc, elem,\n+                                alias->targetNs->prefix);\n+                            if ((ns == NULL) ||\n+                                (! xmlStrEqual(ns->href, alias->targetNs->href)))\n+                            {\n+                                ns = xsltTreeAcquireStoredNs(elem->doc,\n+                                    alias->targetNs->href,\n+                                    alias->targetNs->prefix);\n+\n+                                if (ns == NULL) {\n+                                    xsltTransformError(NULL, cctxt->style, elem,\n+                                        \"Internal error in \"\n+                                        \"xsltLREBuildEffectiveNs(): \"\n+                                        \"failed to acquire a stored \"\n+                                        \"ns-declaration.\\n\");\n+                                    cctxt->style->errors++;\n+                                    return(-1);\n+\n+                                }\n+                            }\n+                            elem->ns = ns;\n+                        }\n+                    } else {\n+                    \/*\n+                    * Move into or leave in the NULL namespace.\n+                        *\/\n+                        elem->ns = NULL;\n+                    }\n+                    break;\n+                }\n+                alias = alias->next;\n+            }\n+\n+            attr = attr->next;\n+        }\n@@ -2104,3 +2104,3 @@\n-                 xsltStyleItemLRElementInfoPtr item,\n-                 xmlNodePtr elem,\n-                 int isLRE)\n+                             xsltStyleItemLRElementInfoPtr item,\n+                             xmlNodePtr elem,\n+                             int isLRE)\n@@ -2115,2 +2115,2 @@\n-    (item == NULL) || (item->effectiveNs != NULL))\n-    return(-1);\n+        (item == NULL) || (item->effectiveNs != NULL))\n+        return(-1);\n@@ -2119,1 +2119,1 @@\n-    return(0);\n+        return(0);\n@@ -2125,34 +2125,1 @@\n-    ns = item->inScopeNs->list[i];\n-    \/*\n-    * Skip namespaces designated as excluded namespaces\n-    * -------------------------------------------------\n-    *\n-    * XSLT-20 TODO: In XSLT 2.0 we need to keep namespaces\n-    *  which are target namespaces of namespace-aliases\n-    *  regardless if designated as excluded.\n-    *\n-    * Exclude the XSLT namespace.\n-    *\/\n-    if (xmlStrEqual(ns->href, XSLT_NAMESPACE))\n-        goto skip_ns;\n-\n-    \/*\n-    * Apply namespace aliasing\n-    * ------------------------\n-    *\n-    * SPEC XSLT 2.0\n-    *  \"- A namespace node whose string value is a literal namespace\n-    *     URI is not copied to the result tree.\n-    *   - A namespace node whose string value is a target namespace URI\n-    *     is copied to the result tree, whether or not the URI\n-    *     identifies an excluded namespace.\"\n-    *\n-    * NOTE: The ns-aliasing machanism is non-cascading.\n-    *  (checked with Saxon, Xalan and MSXML .NET).\n-    * URGENT TODO: is style->nsAliases the effective list of\n-    *  ns-aliases, or do we need to lookup the whole\n-    *  import-tree?\n-    * TODO: Get rid of import-tree lookup.\n-    *\/\n-    if (cctxt->hasNsAliases) {\n-        xsltNsAliasPtr alias;\n+        ns = item->inScopeNs->list[i];\n@@ -2160,1 +2127,8 @@\n-        * First check for being a target namespace.\n+        * Skip namespaces designated as excluded namespaces\n+        * -------------------------------------------------\n+        *\n+        * XSLT-20 TODO: In XSLT 2.0 we need to keep namespaces\n+        *  which are target namespaces of namespace-aliases\n+        *  regardless if designated as excluded.\n+        *\n+        * Exclude the XSLT namespace.\n@@ -2162,2 +2136,3 @@\n-        alias = cctxt->nsAliases;\n-        do {\n+        if (xmlStrEqual(ns->href, XSLT_NAMESPACE))\n+            goto skip_ns;\n+\n@@ -2165,1 +2140,16 @@\n-        * TODO: Is xmlns=\"\" handled already?\n+        * Apply namespace aliasing\n+        * ------------------------\n+        *\n+        * SPEC XSLT 2.0\n+        *  \"- A namespace node whose string value is a literal namespace\n+        *     URI is not copied to the result tree.\n+        *   - A namespace node whose string value is a target namespace URI\n+        *     is copied to the result tree, whether or not the URI\n+        *     identifies an excluded namespace.\"\n+        *\n+        * NOTE: The ns-aliasing machanism is non-cascading.\n+        *  (checked with Saxon, Xalan and MSXML .NET).\n+        * URGENT TODO: is style->nsAliases the effective list of\n+        *  ns-aliases, or do we need to lookup the whole\n+        *  import-tree?\n+        * TODO: Get rid of import-tree lookup.\n@@ -2167,3 +2157,2 @@\n-        if ((alias->targetNs != NULL) &&\n-            (xmlStrEqual(alias->targetNs->href, ns->href)))\n-        {\n+        if (cctxt->hasNsAliases) {\n+            xsltNsAliasPtr alias;\n@@ -2171,2 +2160,1 @@\n-            * Recognized as a target namespace; use it regardless\n-            * if excluded otherwise.\n+            * First check for being a target namespace.\n@@ -2174,1 +2162,32 @@\n-            goto add_effective_ns;\n+            alias = cctxt->nsAliases;\n+            do {\n+                \/*\n+                * TODO: Is xmlns=\"\" handled already?\n+                *\/\n+                if ((alias->targetNs != NULL) &&\n+                    (xmlStrEqual(alias->targetNs->href, ns->href)))\n+                {\n+                    \/*\n+                    * Recognized as a target namespace; use it regardless\n+                    * if excluded otherwise.\n+                    *\/\n+                    goto add_effective_ns;\n+                }\n+                alias = alias->next;\n+            } while (alias != NULL);\n+\n+            alias = cctxt->nsAliases;\n+            do {\n+                \/*\n+                * TODO: Is xmlns=\"\" handled already?\n+                *\/\n+                if ((alias->literalNs != NULL) &&\n+                    (xmlStrEqual(alias->literalNs->href, ns->href)))\n+                {\n+                    \/*\n+                    * Recognized as an namespace alias; do not use it.\n+                    *\/\n+                    goto skip_ns;\n+                }\n+                alias = alias->next;\n+            } while (alias != NULL);\n@@ -2176,2 +2195,0 @@\n-        alias = alias->next;\n-        } while (alias != NULL);\n@@ -2179,2 +2196,0 @@\n-        alias = cctxt->nsAliases;\n-        do {\n@@ -2182,1 +2197,1 @@\n-        * TODO: Is xmlns=\"\" handled already?\n+        * Exclude excluded result namespaces.\n@@ -2184,7 +2199,12 @@\n-        if ((alias->literalNs != NULL) &&\n-            (xmlStrEqual(alias->literalNs->href, ns->href)))\n-        {\n-            \/*\n-            * Recognized as an namespace alias; do not use it.\n-            *\/\n-            goto skip_ns;\n+        if (exclResultNs) {\n+            for (j = 0; j < exclResultNs->number; j++)\n+                if (xmlStrEqual(ns->href, BAD_CAST exclResultNs->items[j]))\n+                    goto skip_ns;\n+        }\n+        \/*\n+        * Exclude extension-element namespaces.\n+        *\/\n+        if (extElemNs) {\n+            for (j = 0; j < extElemNs->number; j++)\n+                if (xmlStrEqual(ns->href, BAD_CAST extElemNs->items[j]))\n+                    goto skip_ns;\n@@ -2192,20 +2212,0 @@\n-        alias = alias->next;\n-        } while (alias != NULL);\n-    }\n-\n-    \/*\n-    * Exclude excluded result namespaces.\n-    *\/\n-    if (exclResultNs) {\n-        for (j = 0; j < exclResultNs->number; j++)\n-        if (xmlStrEqual(ns->href, BAD_CAST exclResultNs->items[j]))\n-            goto skip_ns;\n-    }\n-    \/*\n-    * Exclude extension-element namespaces.\n-    *\/\n-    if (extElemNs) {\n-        for (j = 0; j < extElemNs->number; j++)\n-        if (xmlStrEqual(ns->href, BAD_CAST extElemNs->items[j]))\n-            goto skip_ns;\n-    }\n@@ -2214,15 +2214,15 @@\n-    \/*\n-    * OPTIMIZE TODO: This information may not be needed.\n-    *\/\n-    if (isLRE && (elem->nsDef != NULL)) {\n-        holdByElem = 0;\n-        tmpns = elem->nsDef;\n-        do {\n-        if (tmpns == ns) {\n-            holdByElem = 1;\n-            break;\n-        }\n-        tmpns = tmpns->next;\n-        } while (tmpns != NULL);\n-    } else\n-        holdByElem = 0;\n+        \/*\n+        * OPTIMIZE TODO: This information may not be needed.\n+        *\/\n+        if (isLRE && (elem->nsDef != NULL)) {\n+            holdByElem = 0;\n+            tmpns = elem->nsDef;\n+            do {\n+                if (tmpns == ns) {\n+                    holdByElem = 1;\n+                    break;\n+                }\n+                tmpns = tmpns->next;\n+            } while (tmpns != NULL);\n+        } else\n+            holdByElem = 0;\n@@ -2231,18 +2231,18 @@\n-    \/*\n-    * Add the effective namespace declaration.\n-    *\/\n-    effNs = (xsltEffectiveNsPtr) xmlMalloc(sizeof(xsltEffectiveNs));\n-    if (effNs == NULL) {\n-        xsltTransformError(NULL, cctxt->style, elem,\n-        \"Internal error in xsltLREBuildEffectiveNs(): \"\n-        \"failed to allocate memory.\\n\");\n-        cctxt->style->errors++;\n-        return(-1);\n-    }\n-    if (cctxt->psData->effectiveNs == NULL) {\n-        cctxt->psData->effectiveNs = effNs;\n-        effNs->nextInStore = NULL;\n-    } else {\n-        effNs->nextInStore = cctxt->psData->effectiveNs;\n-        cctxt->psData->effectiveNs = effNs;\n-    }\n+        \/*\n+        * Add the effective namespace declaration.\n+        *\/\n+        effNs = (xsltEffectiveNsPtr) xmlMalloc(sizeof(xsltEffectiveNs));\n+        if (effNs == NULL) {\n+            xsltTransformError(NULL, cctxt->style, elem,\n+                \"Internal error in xsltLREBuildEffectiveNs(): \"\n+                \"failed to allocate memory.\\n\");\n+            cctxt->style->errors++;\n+            return(-1);\n+        }\n+        if (cctxt->psData->effectiveNs == NULL) {\n+            cctxt->psData->effectiveNs = effNs;\n+            effNs->nextInStore = NULL;\n+        } else {\n+            effNs->nextInStore = cctxt->psData->effectiveNs;\n+            cctxt->psData->effectiveNs = effNs;\n+        }\n@@ -2250,4 +2250,4 @@\n-    effNs->next = NULL;\n-    effNs->prefix = ns->prefix;\n-    effNs->nsName = ns->href;\n-    effNs->holdByElem = holdByElem;\n+        effNs->next = NULL;\n+        effNs->prefix = ns->prefix;\n+        effNs->nsName = ns->href;\n+        effNs->holdByElem = holdByElem;\n@@ -2255,5 +2255,5 @@\n-    if (lastEffNs == NULL)\n-        item->effectiveNs = effNs;\n-    else\n-        lastEffNs->next = effNs;\n-    lastEffNs = effNs;\n+        if (lastEffNs == NULL)\n+            item->effectiveNs = effNs;\n+        else\n+            lastEffNs->next = effNs;\n+        lastEffNs = effNs;\n@@ -2262,1 +2262,1 @@\n-    {}\n+        {}\n@@ -2277,2 +2277,2 @@\n-          xmlNodePtr elem,\n-          int isLRE)\n+                  xmlNodePtr elem,\n+                  int isLRE)\n@@ -2283,1 +2283,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2286,1 +2286,1 @@\n-    xmlMalloc(sizeof(xsltStyleItemLRElementInfo));\n+        xmlMalloc(sizeof(xsltStyleItemLRElementInfo));\n@@ -2288,5 +2288,5 @@\n-    xsltTransformError(NULL, cctxt->style, NULL,\n-        \"Internal error in xsltLREInfoCreate(): \"\n-        \"memory allocation failed.\\n\");\n-    cctxt->style->errors++;\n-    return(-1);\n+        xsltTransformError(NULL, cctxt->style, NULL,\n+            \"Internal error in xsltLREInfoCreate(): \"\n+            \"memory allocation failed.\\n\");\n+        cctxt->style->errors++;\n+        return(-1);\n@@ -2308,1 +2308,1 @@\n-    xsltLREBuildEffectiveNsNodes(cctxt, item, elem, isLRE);\n+        xsltLREBuildEffectiveNsNodes(cctxt, item, elem, isLRE);\n@@ -2326,3 +2326,3 @@\n-                  xmlNodePtr inst,\n-                  const xmlChar *name,\n-                  const xmlChar *nsName)\n+                                  xmlNodePtr inst,\n+                                  const xmlChar *name,\n+                                  const xmlChar *nsName)\n@@ -2333,1 +2333,1 @@\n-    ivar = cctxt->ivar->next;\n+        ivar = cctxt->ivar->next;\n@@ -2335,13 +2335,1 @@\n-    ivar = cctxt->ivars;\n-    } else {\n-    ivar = (xsltVarInfoPtr) xmlMalloc(sizeof(xsltVarInfo));\n-    if (ivar == NULL) {\n-        xsltTransformError(NULL, cctxt->style, inst,\n-        \"xsltParseInScopeVarPush: xmlMalloc() failed!\\n\");\n-        cctxt->style->errors++;\n-        return(NULL);\n-    }\n-    \/* memset(retVar, 0, sizeof(xsltInScopeVar)); *\/\n-    if (cctxt->ivars == NULL) {\n-        cctxt->ivars = ivar;\n-        ivar->prev = NULL;\n+        ivar = cctxt->ivars;\n@@ -2349,5 +2337,17 @@\n-        cctxt->ivar->next = ivar;\n-        ivar->prev = cctxt->ivar;\n-    }\n-    cctxt->ivar = ivar;\n-    ivar->next = NULL;\n+        ivar = (xsltVarInfoPtr) xmlMalloc(sizeof(xsltVarInfo));\n+        if (ivar == NULL) {\n+            xsltTransformError(NULL, cctxt->style, inst,\n+                \"xsltParseInScopeVarPush: xmlMalloc() failed!\\n\");\n+            cctxt->style->errors++;\n+            return(NULL);\n+        }\n+        \/* memset(retVar, 0, sizeof(xsltInScopeVar)); *\/\n+        if (cctxt->ivars == NULL) {\n+            cctxt->ivars = ivar;\n+            ivar->prev = NULL;\n+        } else {\n+            cctxt->ivar->next = ivar;\n+            ivar->prev = cctxt->ivar;\n+        }\n+        cctxt->ivar = ivar;\n+        ivar->next = NULL;\n@@ -2373,1 +2373,1 @@\n-    (cctxt->ivar->depth > cctxt->depth))\n+        (cctxt->ivar->depth > cctxt->depth))\n@@ -2375,1 +2375,1 @@\n-    cctxt->ivar = cctxt->ivar->prev;\n+        cctxt->ivar = cctxt->ivar->prev;\n@@ -2396,1 +2396,1 @@\n-    inode = cctxt->inode->next;\n+        inode = cctxt->inode->next;\n@@ -2398,1 +2398,1 @@\n-    inode = cctxt->inodeList;\n+        inode = cctxt->inodeList;\n@@ -2400,21 +2400,0 @@\n-    \/*\n-    * Create a new node-info.\n-    *\/\n-    inode = (xsltCompilerNodeInfoPtr)\n-        xmlMalloc(sizeof(xsltCompilerNodeInfo));\n-    if (inode == NULL) {\n-        xsltTransformError(NULL, cctxt->style, NULL,\n-        \"xsltCompilerNodePush: malloc failed.\\n\");\n-        return(NULL);\n-    }\n-    memset(inode, 0, sizeof(xsltCompilerNodeInfo));\n-    if (cctxt->inodeList == NULL)\n-        cctxt->inodeList = inode;\n-    else {\n-        cctxt->inodeLast->next = inode;\n-        inode->prev = cctxt->inodeLast;\n-    }\n-    cctxt->inodeLast = inode;\n-    cctxt->maxNodeInfos++;\n-    if (cctxt->inode == NULL) {\n-        cctxt->inode = inode;\n@@ -2422,2 +2401,1 @@\n-        * Create an initial literal result element info for\n-        * the root of the stylesheet.\n+        * Create a new node-info.\n@@ -2425,2 +2403,24 @@\n-        xsltLREInfoCreate(cctxt, NULL, 0);\n-    }\n+        inode = (xsltCompilerNodeInfoPtr)\n+            xmlMalloc(sizeof(xsltCompilerNodeInfo));\n+        if (inode == NULL) {\n+            xsltTransformError(NULL, cctxt->style, NULL,\n+                \"xsltCompilerNodePush: malloc failed.\\n\");\n+            return(NULL);\n+        }\n+        memset(inode, 0, sizeof(xsltCompilerNodeInfo));\n+        if (cctxt->inodeList == NULL)\n+            cctxt->inodeList = inode;\n+        else {\n+            cctxt->inodeLast->next = inode;\n+            inode->prev = cctxt->inodeLast;\n+        }\n+        cctxt->inodeLast = inode;\n+        cctxt->maxNodeInfos++;\n+        if (cctxt->inode == NULL) {\n+            cctxt->inode = inode;\n+            \/*\n+            * Create an initial literal result element info for\n+            * the root of the stylesheet.\n+            *\/\n+            xsltLREInfoCreate(cctxt, NULL, 0);\n+        }\n@@ -2446,29 +2446,29 @@\n-    iprev = inode->prev;\n-    \/*\n-    * Inherit the following information:\n-    * ---------------------------------\n-    *\n-    * In-scope namespaces\n-    *\/\n-    inode->inScopeNs = iprev->inScopeNs;\n-    \/*\n-    * Info for literal result elements\n-    *\/\n-    inode->litResElemInfo = iprev->litResElemInfo;\n-    inode->nsChanged = iprev->nsChanged;\n-    \/*\n-    * Excluded result namespaces\n-    *\/\n-    inode->exclResultNs = iprev->exclResultNs;\n-    \/*\n-    * Extension instruction namespaces\n-    *\/\n-    inode->extElemNs = iprev->extElemNs;\n-    \/*\n-    * Whitespace preservation\n-    *\/\n-    inode->preserveWhitespace = iprev->preserveWhitespace;\n-    \/*\n-    * Forwards-compatible mode\n-    *\/\n-    inode->forwardsCompat = iprev->forwardsCompat;\n+        iprev = inode->prev;\n+        \/*\n+        * Inherit the following information:\n+        * ---------------------------------\n+        *\n+        * In-scope namespaces\n+        *\/\n+        inode->inScopeNs = iprev->inScopeNs;\n+        \/*\n+        * Info for literal result elements\n+        *\/\n+        inode->litResElemInfo = iprev->litResElemInfo;\n+        inode->nsChanged = iprev->nsChanged;\n+        \/*\n+        * Excluded result namespaces\n+        *\/\n+        inode->exclResultNs = iprev->exclResultNs;\n+        \/*\n+        * Extension instruction namespaces\n+        *\/\n+        inode->extElemNs = iprev->extElemNs;\n+        \/*\n+        * Whitespace preservation\n+        *\/\n+        inode->preserveWhitespace = iprev->preserveWhitespace;\n+        \/*\n+        * Forwards-compatible mode\n+        *\/\n+        inode->forwardsCompat = iprev->forwardsCompat;\n@@ -2476,5 +2476,5 @@\n-    inode->inScopeNs = NULL;\n-    inode->exclResultNs = NULL;\n-    inode->extElemNs = NULL;\n-    inode->preserveWhitespace = 0;\n-    inode->forwardsCompat = 0;\n+        inode->inScopeNs = NULL;\n+        inode->exclResultNs = NULL;\n+        inode->extElemNs = NULL;\n+        inode->preserveWhitespace = 0;\n+        inode->forwardsCompat = 0;\n@@ -2498,3 +2498,3 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"xsltCompilerNodePop: Top-node mismatch.\\n\");\n-    return;\n+        xmlGenericError(xmlGenericErrorContext,\n+            \"xsltCompilerNodePop: Top-node mismatch.\\n\");\n+        return;\n@@ -2507,3 +2507,3 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-    \"xsltCompilerNodePop: Node mismatch.\\n\");\n-    goto mismatch;\n+        xmlGenericError(xmlGenericErrorContext,\n+        \"xsltCompilerNodePop: Node mismatch.\\n\");\n+        goto mismatch;\n@@ -2512,3 +2512,3 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-    \"xsltCompilerNodePop: Depth mismatch.\\n\");\n-    goto mismatch;\n+        xmlGenericError(xmlGenericErrorContext,\n+        \"xsltCompilerNodePop: Depth mismatch.\\n\");\n+        goto mismatch;\n@@ -2521,1 +2521,1 @@\n-    xsltCompilerVarInfoPop(cctxt);\n+        xsltCompilerVarInfoPop(cctxt);\n@@ -2525,1 +2525,1 @@\n-    cctxt->inode->curChildType = 0;\n+        cctxt->inode->curChildType = 0;\n@@ -2530,30 +2530,30 @@\n-    const xmlChar *nsName = NULL, *name = NULL;\n-    const xmlChar *infnsName = NULL, *infname = NULL;\n-\n-    if (node) {\n-        if (node->type == XML_ELEMENT_NODE) {\n-        name = node->name;\n-        if (node->ns != NULL)\n-            nsName = node->ns->href;\n-        else\n-            nsName = BAD_CAST \"\";\n-        } else {\n-        name = BAD_CAST \"#document\";\n-        nsName = BAD_CAST \"\";\n-        }\n-    } else\n-        name = BAD_CAST \"Not given\";\n-\n-    if (cctxt->inode->node) {\n-        if (node->type == XML_ELEMENT_NODE) {\n-        infname = cctxt->inode->node->name;\n-        if (cctxt->inode->node->ns != NULL)\n-            infnsName = cctxt->inode->node->ns->href;\n-        else\n-            infnsName = BAD_CAST \"\";\n-        } else {\n-        infname = BAD_CAST \"#document\";\n-        infnsName = BAD_CAST \"\";\n-        }\n-    } else\n-        infname = BAD_CAST \"Not given\";\n+        const xmlChar *nsName = NULL, *name = NULL;\n+        const xmlChar *infnsName = NULL, *infname = NULL;\n+\n+        if (node) {\n+            if (node->type == XML_ELEMENT_NODE) {\n+                name = node->name;\n+                if (node->ns != NULL)\n+                    nsName = node->ns->href;\n+                else\n+                    nsName = BAD_CAST \"\";\n+            } else {\n+                name = BAD_CAST \"#document\";\n+                nsName = BAD_CAST \"\";\n+            }\n+        } else\n+            name = BAD_CAST \"Not given\";\n+\n+        if (cctxt->inode->node) {\n+            if (node->type == XML_ELEMENT_NODE) {\n+                infname = cctxt->inode->node->name;\n+                if (cctxt->inode->node->ns != NULL)\n+                    infnsName = cctxt->inode->node->ns->href;\n+                else\n+                    infnsName = BAD_CAST \"\";\n+            } else {\n+                infname = BAD_CAST \"#document\";\n+                infnsName = BAD_CAST \"\";\n+            }\n+        } else\n+            infname = BAD_CAST \"Not given\";\n@@ -2562,6 +2562,6 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"xsltCompilerNodePop: Given   : '%s' URI '%s'\\n\",\n-        name, nsName);\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"xsltCompilerNodePop: Expected: '%s' URI '%s'\\n\",\n-        infname, infnsName);\n+        xmlGenericError(xmlGenericErrorContext,\n+            \"xsltCompilerNodePop: Given   : '%s' URI '%s'\\n\",\n+            name, nsName);\n+        xmlGenericError(xmlGenericErrorContext,\n+            \"xsltCompilerNodePop: Expected: '%s' URI '%s'\\n\",\n+            infname, infnsName);\n@@ -2599,9 +2599,9 @@\n-            nsi = (xsltNsListContainerPtr)\n-            xmlMalloc(sizeof(xsltNsListContainer));\n-            if (nsi == NULL) {\n-            xsltTransformError(NULL, cctxt->style, NULL,\n-                \"xsltCompilerBuildInScopeNsList: \"\n-                \"malloc failed!\\n\");\n-            goto internal_err;\n-            }\n-            memset(nsi, 0, sizeof(xsltNsListContainer));\n+                    nsi = (xsltNsListContainerPtr)\n+                        xmlMalloc(sizeof(xsltNsListContainer));\n+                    if (nsi == NULL) {\n+                        xsltTransformError(NULL, cctxt->style, NULL,\n+                            \"xsltCompilerBuildInScopeNsList: \"\n+                            \"malloc failed!\\n\");\n+                        goto internal_err;\n+                    }\n+                    memset(nsi, 0, sizeof(xsltNsListContainer));\n@@ -2611,4 +2611,4 @@\n-            xsltTransformError(NULL, cctxt->style, NULL,\n-                \"xsltCompilerBuildInScopeNsList: \"\n-                \"malloc failed!\\n\");\n-            goto internal_err;\n+                        xsltTransformError(NULL, cctxt->style, NULL,\n+                            \"xsltCompilerBuildInScopeNsList: \"\n+                            \"malloc failed!\\n\");\n+                        goto internal_err;\n@@ -2618,3 +2618,3 @@\n-        \/*\n-        * Skip shadowed namespace bindings.\n-        *\/\n+                \/*\n+                * Skip shadowed namespace bindings.\n+                *\/\n@@ -2624,1 +2624,1 @@\n-            break;\n+                    break;\n@@ -2629,3 +2629,3 @@\n-            nsi->list =\n-                (xmlNsPtr *) xmlRealloc(nsi->list,\n-                maxns * sizeof(xmlNsPtr));\n+                        nsi->list =\n+                            (xmlNsPtr *) xmlRealloc(nsi->list,\n+                                maxns * sizeof(xmlNsPtr));\n@@ -2634,3 +2634,3 @@\n-                \"xsltCompilerBuildInScopeNsList: \"\n-                \"realloc failed!\\n\");\n-                goto internal_err;\n+                                \"xsltCompilerBuildInScopeNsList: \"\n+                                \"realloc failed!\\n\");\n+                                goto internal_err;\n@@ -2649,1 +2649,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2655,7 +2655,7 @@\n-    if (nsi->list[i]->prefix == NULL) {\n-        ns = nsi->list[i];\n-        nsi->list[i] = nsi->list[nsi->totalNumber-1];\n-        nsi->list[nsi->totalNumber-1] = ns;\n-        nsi->xpathNumber--;\n-        break;\n-    }\n+        if (nsi->list[i]->prefix == NULL) {\n+            ns = nsi->list[i];\n+            nsi->list[i] = nsi->list[nsi->totalNumber-1];\n+            nsi->list[nsi->totalNumber-1] = ns;\n+            nsi->xpathNumber--;\n+            break;\n+        }\n@@ -2667,2 +2667,2 @@\n-    (xsltPointerListPtr)cctxt->psData->inScopeNamespaces,\n-    (void *) nsi, 5) == -1)\n+        (xsltPointerListPtr)cctxt->psData->inScopeNamespaces,\n+        (void *) nsi, 5) == -1)\n@@ -2670,5 +2670,5 @@\n-    xmlFree(nsi);\n-    nsi = NULL;\n-    xsltTransformError(NULL, cctxt->style, NULL,\n-        \"xsltCompilerBuildInScopeNsList: failed to add ns-info.\\n\");\n-    goto internal_err;\n+        xmlFree(nsi);\n+        nsi = NULL;\n+        xsltTransformError(NULL, cctxt->style, NULL,\n+            \"xsltCompilerBuildInScopeNsList: failed to add ns-info.\\n\");\n+        goto internal_err;\n@@ -2680,1 +2680,1 @@\n-    cctxt->inode->nsChanged = 1;\n+        cctxt->inode->nsChanged = 1;\n@@ -2686,1 +2686,1 @@\n-    xmlFree(list);\n+        xmlFree(list);\n@@ -2693,3 +2693,3 @@\n-              xsltPointerListPtr list,\n-              xmlNodePtr node,\n-              const xmlChar *value)\n+                      xsltPointerListPtr list,\n+                      xmlNodePtr node,\n+                      const xmlChar *value)\n@@ -2701,1 +2701,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2707,30 +2707,10 @@\n-    while (IS_BLANK(*cur)) cur++;\n-    if (*cur == 0)\n-        break;\n-    end = cur;\n-    while ((*end != 0) && (!IS_BLANK(*end))) end++;\n-    cur = xmlStrndup(cur, end - cur);\n-    if (cur == NULL) {\n-        cur = end;\n-        continue;\n-    }\n-    \/*\n-    * TODO: Export and use xmlSearchNsByPrefixStrict()\n-    *   in Libxml2, tree.c, since xmlSearchNs() is in most\n-    *   cases not efficient and in some cases not correct.\n-    *\n-    * XSLT-2 TODO: XSLT 2.0 allows an additional \"#all\" value.\n-    *\/\n-    if ((cur[0] == '#') &&\n-        xmlStrEqual(cur, (const xmlChar *)\"#default\"))\n-        ns = xmlSearchNs(cctxt->style->doc, node, NULL);\n-    else\n-        ns = xmlSearchNs(cctxt->style->doc, node, cur);\n-\n-    if (ns == NULL) {\n-        \/*\n-        * TODO: Better to report the attr-node, otherwise\n-        *  the user won't know which attribute was invalid.\n-        *\/\n-        xsltTransformError(NULL, cctxt->style, node,\n-        \"No namespace binding in scope for prefix '%s'.\\n\", cur);\n+        while (IS_BLANK(*cur)) cur++;\n+        if (*cur == 0)\n+            break;\n+        end = cur;\n+        while ((*end != 0) && (!IS_BLANK(*end))) end++;\n+        cur = xmlStrndup(cur, end - cur);\n+        if (cur == NULL) {\n+            cur = end;\n+            continue;\n+        }\n@@ -2738,4 +2718,5 @@\n-        * XSLT-1.0: \"It is an error if there is no namespace\n-        *  bound to the prefix on the element bearing the\n-        *  exclude-result-prefixes or xsl:exclude-result-prefixes\n-        *  attribute.\"\n+        * TODO: Export and use xmlSearchNsByPrefixStrict()\n+        *   in Libxml2, tree.c, since xmlSearchNs() is in most\n+        *   cases not efficient and in some cases not correct.\n+        *\n+        * XSLT-2 TODO: XSLT 2.0 allows an additional \"#all\" value.\n@@ -2743,2 +2724,21 @@\n-        cctxt->style->errors++;\n-    } else {\n+        if ((cur[0] == '#') &&\n+            xmlStrEqual(cur, (const xmlChar *)\"#default\"))\n+            ns = xmlSearchNs(cctxt->style->doc, node, NULL);\n+        else\n+            ns = xmlSearchNs(cctxt->style->doc, node, cur);\n+\n+        if (ns == NULL) {\n+            \/*\n+            * TODO: Better to report the attr-node, otherwise\n+            *  the user won't know which attribute was invalid.\n+            *\/\n+            xsltTransformError(NULL, cctxt->style, node,\n+                \"No namespace binding in scope for prefix '%s'.\\n\", cur);\n+            \/*\n+            * XSLT-1.0: \"It is an error if there is no namespace\n+            *  bound to the prefix on the element bearing the\n+            *  exclude-result-prefixes or xsl:exclude-result-prefixes\n+            *  attribute.\"\n+            *\/\n+            cctxt->style->errors++;\n+        } else {\n@@ -2746,2 +2746,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-        \"resolved prefix '%s'\\n\", cur);\n+            xsltGenericDebug(xsltGenericDebugContext,\n+                \"resolved prefix '%s'\\n\", cur);\n@@ -2749,9 +2749,10 @@\n-        \/*\n-        * Note that we put the namespace name into the dict.\n-        *\/\n-        if (xsltPointerListAddSize(list,\n-        (void *) xmlDictLookup(cctxt->style->dict,\n-        ns->href, -1), 5) == -1)\n-        {\n-        xmlFree(cur);\n-        goto internal_err;\n+            \/*\n+            * Note that we put the namespace name into the dict.\n+            *\/\n+            if (xsltPointerListAddSize(list,\n+                (void *) xmlDictLookup(cctxt->style->dict,\n+                ns->href, -1), 5) == -1)\n+            {\n+                xmlFree(cur);\n+                goto internal_err;\n+            }\n@@ -2759,2 +2760,1 @@\n-    }\n-    xmlFree(cur);\n+        xmlFree(cur);\n@@ -2762,1 +2762,1 @@\n-    cur = end;\n+        cur = end;\n@@ -2784,1 +2784,1 @@\n-                xsltPointerListPtr second)\n+                            xsltPointerListPtr second)\n@@ -2790,1 +2790,1 @@\n-    num = first->number;\n+        num = first->number;\n@@ -2792,1 +2792,1 @@\n-    num = 0;\n+        num = 0;\n@@ -2794,1 +2794,1 @@\n-    num += second->number;\n+        num += second->number;\n@@ -2796,1 +2796,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2799,1 +2799,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2804,5 +2804,5 @@\n-    memcpy(ret->items, first->items,\n-        first->number * sizeof(void *));\n-    if ((second != NULL) && (second->number != 0))\n-        memcpy(ret->items + first->number, second->items,\n-        second->number * sizeof(void *));\n+        memcpy(ret->items, first->items,\n+            first->number * sizeof(void *));\n+        if ((second != NULL) && (second->number != 0))\n+            memcpy(ret->items + first->number, second->items,\n+                second->number * sizeof(void *));\n@@ -2810,2 +2810,2 @@\n-    memcpy(ret->items, (void *) second->items,\n-        second->number * sizeof(void *));\n+        memcpy(ret->items, (void *) second->items,\n+            second->number * sizeof(void *));\n@@ -2828,2 +2828,2 @@\n-                xsltPointerListPtr def,\n-                int instrCategory)\n+                            xsltPointerListPtr def,\n+                            int instrCategory)\n@@ -2836,1 +2836,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2839,1 +2839,1 @@\n-    attr = xmlHasNsProp(node, BAD_CAST \"exclude-result-prefixes\", NULL);\n+        attr = xmlHasNsProp(node, BAD_CAST \"exclude-result-prefixes\", NULL);\n@@ -2841,2 +2841,2 @@\n-    attr = xmlHasNsProp(node, BAD_CAST \"exclude-result-prefixes\",\n-        XSLT_NAMESPACE);\n+        attr = xmlHasNsProp(node, BAD_CAST \"exclude-result-prefixes\",\n+            XSLT_NAMESPACE);\n@@ -2844,1 +2844,1 @@\n-    return(def);\n+        return(def);\n@@ -2847,4 +2847,4 @@\n-    \/*\n-    * Mark the XSLT attr.\n-    *\/\n-    attr->psvi = (void *) xsltXSLTAttrMarker;\n+        \/*\n+        * Mark the XSLT attr.\n+        *\/\n+        attr->psvi = (void *) xsltXSLTAttrMarker;\n@@ -2854,2 +2854,2 @@\n-    (attr->children->content != NULL))\n-    value = attr->children->content;\n+        (attr->children->content != NULL))\n+        value = attr->children->content;\n@@ -2857,4 +2857,4 @@\n-    xsltTransformError(NULL, cctxt->style, node,\n-        \"Attribute 'exclude-result-prefixes': Invalid value.\\n\");\n-    cctxt->style->errors++;\n-    return(def);\n+        xsltTransformError(NULL, cctxt->style, node,\n+            \"Attribute 'exclude-result-prefixes': Invalid value.\\n\");\n+        cctxt->style->errors++;\n+        return(def);\n@@ -2864,2 +2864,2 @@\n-    BAD_CAST value) != 0)\n-    goto exit;\n+        BAD_CAST value) != 0)\n+        goto exit;\n@@ -2867,1 +2867,1 @@\n-    goto exit;\n+        goto exit;\n@@ -2873,1 +2873,1 @@\n-    goto exit;\n+        goto exit;\n@@ -2878,1 +2878,1 @@\n-    cctxt->psData->exclResultNamespaces, list, 5) == -1)\n+        cctxt->psData->exclResultNamespaces, list, 5) == -1)\n@@ -2880,3 +2880,3 @@\n-    xsltPointerListFree(list);\n-    list = NULL;\n-    goto exit;\n+        xsltPointerListFree(list);\n+        list = NULL;\n+        goto exit;\n@@ -2888,1 +2888,1 @@\n-    cctxt->inode->nsChanged = 1;\n+        cctxt->inode->nsChanged = 1;\n@@ -2892,1 +2892,1 @@\n-    return(list);\n+        return(list);\n@@ -2894,1 +2894,1 @@\n-    return(def);\n+        return(def);\n@@ -2909,2 +2909,2 @@\n-             xsltPointerListPtr def,\n-             int instrCategory)\n+                         xsltPointerListPtr def,\n+                         int instrCategory)\n@@ -2918,1 +2918,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -2921,1 +2921,1 @@\n-    attr = xmlHasNsProp(node, BAD_CAST \"extension-element-prefixes\", NULL);\n+        attr = xmlHasNsProp(node, BAD_CAST \"extension-element-prefixes\", NULL);\n@@ -2923,2 +2923,2 @@\n-    attr = xmlHasNsProp(node, BAD_CAST \"extension-element-prefixes\",\n-        XSLT_NAMESPACE);\n+        attr = xmlHasNsProp(node, BAD_CAST \"extension-element-prefixes\",\n+            XSLT_NAMESPACE);\n@@ -2926,1 +2926,1 @@\n-    return(def);\n+        return(def);\n@@ -2929,4 +2929,4 @@\n-    \/*\n-    * Mark the XSLT attr.\n-    *\/\n-    attr->psvi = (void *) xsltXSLTAttrMarker;\n+        \/*\n+        * Mark the XSLT attr.\n+        *\/\n+        attr->psvi = (void *) xsltXSLTAttrMarker;\n@@ -2936,2 +2936,2 @@\n-    (attr->children->content != NULL))\n-    value = attr->children->content;\n+        (attr->children->content != NULL))\n+        value = attr->children->content;\n@@ -2939,4 +2939,4 @@\n-    xsltTransformError(NULL, cctxt->style, node,\n-        \"Attribute 'extension-element-prefixes': Invalid value.\\n\");\n-    cctxt->style->errors++;\n-    return(def);\n+        xsltTransformError(NULL, cctxt->style, node,\n+            \"Attribute 'extension-element-prefixes': Invalid value.\\n\");\n+        cctxt->style->errors++;\n+        return(def);\n@@ -2947,2 +2947,2 @@\n-    BAD_CAST value) != 0)\n-    goto exit;\n+        BAD_CAST value) != 0)\n+        goto exit;\n@@ -2951,1 +2951,1 @@\n-    goto exit;\n+        goto exit;\n@@ -2956,2 +2956,2 @@\n-    xsltRegisterExtPrefix(cctxt->style, NULL,\n-    BAD_CAST cctxt->tmpList->items[i]);\n+        xsltRegisterExtPrefix(cctxt->style, NULL,\n+        BAD_CAST cctxt->tmpList->items[i]);\n@@ -2963,1 +2963,1 @@\n-    goto exit;\n+        goto exit;\n@@ -2968,1 +2968,1 @@\n-    cctxt->psData->extElemNamespaces, list, 5) == -1)\n+        cctxt->psData->extElemNamespaces, list, 5) == -1)\n@@ -2970,3 +2970,3 @@\n-    xsltPointerListFree(list);\n-    list = NULL;\n-    goto exit;\n+        xsltPointerListFree(list);\n+        list = NULL;\n+        goto exit;\n@@ -2978,1 +2978,1 @@\n-    cctxt->inode->nsChanged = 1;\n+        cctxt->inode->nsChanged = 1;\n@@ -2982,1 +2982,1 @@\n-    return(list);\n+        return(list);\n@@ -2984,1 +2984,1 @@\n-    return(def);\n+        return(def);\n@@ -3001,1 +3001,1 @@\n-             int instrCategory)\n+                         int instrCategory)\n@@ -3007,1 +3007,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3010,1 +3010,1 @@\n-    attr = xmlHasNsProp(node, BAD_CAST \"version\", NULL);\n+        attr = xmlHasNsProp(node, BAD_CAST \"version\", NULL);\n@@ -3012,1 +3012,1 @@\n-    attr = xmlHasNsProp(node, BAD_CAST \"version\", XSLT_NAMESPACE);\n+        attr = xmlHasNsProp(node, BAD_CAST \"version\", XSLT_NAMESPACE);\n@@ -3015,1 +3015,1 @@\n-    return(0);\n+        return(0);\n@@ -3020,2 +3020,2 @@\n-    (attr->children->content != NULL))\n-    value = attr->children->content;\n+        (attr->children->content != NULL))\n+        value = attr->children->content;\n@@ -3023,4 +3023,4 @@\n-    xsltTransformError(NULL, cctxt->style, node,\n-        \"Attribute 'version': Invalid value.\\n\");\n-    cctxt->style->errors++;\n-    return(1);\n+        xsltTransformError(NULL, cctxt->style, node,\n+            \"Attribute 'version': Invalid value.\\n\");\n+        cctxt->style->errors++;\n+        return(1);\n@@ -3030,19 +3030,19 @@\n-    cctxt->inode->forwardsCompat = 1;\n-    \/*\n-    * TODO: To what extent do we support the\n-    *  forwards-compatible mode?\n-    *\/\n-    \/*\n-    * Report this only once per compilation episode.\n-    *\/\n-    if (! cctxt->hasForwardsCompat) {\n-        cctxt->hasForwardsCompat = 1;\n-        cctxt->errSeverity = XSLT_ERROR_SEVERITY_WARNING;\n-        xsltTransformError(NULL, cctxt->style, node,\n-        \"Warning: the attribute xsl:version specifies a value \"\n-        \"different from '1.0'. Switching to forwards-compatible \"\n-        \"mode. Only features of XSLT 1.0 are supported by this \"\n-        \"processor.\\n\");\n-        cctxt->style->warnings++;\n-        cctxt->errSeverity = XSLT_ERROR_SEVERITY_ERROR;\n-    }\n+        cctxt->inode->forwardsCompat = 1;\n+        \/*\n+        * TODO: To what extent do we support the\n+        *  forwards-compatible mode?\n+        *\/\n+        \/*\n+        * Report this only once per compilation episode.\n+        *\/\n+        if (! cctxt->hasForwardsCompat) {\n+            cctxt->hasForwardsCompat = 1;\n+            cctxt->errSeverity = XSLT_ERROR_SEVERITY_WARNING;\n+            xsltTransformError(NULL, cctxt->style, node,\n+                \"Warning: the attribute xsl:version specifies a value \"\n+                \"different from '1.0'. Switching to forwards-compatible \"\n+                \"mode. Only features of XSLT 1.0 are supported by this \"\n+                \"processor.\\n\");\n+            cctxt->style->warnings++;\n+            cctxt->errSeverity = XSLT_ERROR_SEVERITY_ERROR;\n+        }\n@@ -3050,1 +3050,1 @@\n-    cctxt->inode->forwardsCompat = 0;\n+        cctxt->inode->forwardsCompat = 0;\n@@ -3054,4 +3054,4 @@\n-    \/*\n-    * Set a marker on XSLT attributes.\n-    *\/\n-    attr->psvi = (void *) xsltXSLTAttrMarker;\n+        \/*\n+        * Set a marker on XSLT attributes.\n+        *\/\n+        attr->psvi = (void *) xsltXSLTAttrMarker;\n@@ -3079,1 +3079,1 @@\n-    (node == NULL) || (node->type != XML_ELEMENT_NODE))\n+        (node == NULL) || (node->type != XML_ELEMENT_NODE))\n@@ -3084,1 +3084,1 @@\n-    goto internal_err;\n+        goto internal_err;\n@@ -3088,1 +3088,1 @@\n-    internalize = 1;\n+        internalize = 1;\n@@ -3099,1 +3099,1 @@\n-    xsltStylesheetElemDepth = cctxt->depth +1;\n+        xsltStylesheetElemDepth = cctxt->depth +1;\n@@ -3101,1 +3101,1 @@\n-    xsltStylesheetElemDepth = 0;\n+        xsltStylesheetElemDepth = 0;\n@@ -3104,1 +3104,1 @@\n-    cctxt->inode->preserveWhitespace = 0;\n+        cctxt->inode->preserveWhitespace = 0;\n@@ -3106,1 +3106,1 @@\n-    cctxt->inode->preserveWhitespace = 1;\n+        cctxt->inode->preserveWhitespace = 1;\n@@ -3118,1 +3118,1 @@\n-    if (deleteNode != NULL) {\n+        if (deleteNode != NULL) {\n@@ -3121,2 +3121,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltParsePreprocessStylesheetTree: removing node\\n\");\n+            xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltParsePreprocessStylesheetTree: removing node\\n\");\n@@ -3124,5 +3124,5 @@\n-        xmlUnlinkNode(deleteNode);\n-        xmlFreeNode(deleteNode);\n-        deleteNode = NULL;\n-    }\n-    if (cur->type == XML_ELEMENT_NODE) {\n+            xmlUnlinkNode(deleteNode);\n+            xmlFreeNode(deleteNode);\n+            deleteNode = NULL;\n+        }\n+        if (cur->type == XML_ELEMENT_NODE) {\n@@ -3130,4 +3130,4 @@\n-        \/*\n-        * Clear the PSVI field.\n-        *\/\n-        cur->psvi = NULL;\n+            \/*\n+            * Clear the PSVI field.\n+            *\/\n+            cur->psvi = NULL;\n@@ -3135,1 +3135,1 @@\n-        xsltCompilerNodePush(cctxt, cur);\n+            xsltCompilerNodePush(cctxt, cur);\n@@ -3137,8 +3137,8 @@\n-        inXSLText = 0;\n-        textNode = NULL;\n-        findSpaceAttr = 1;\n-        cctxt->inode->stripWhitespace = 0;\n-        \/*\n-        * TODO: I'd love to use a string pointer comparison here :-\/\n-        *\/\n-        if (IS_XSLT_ELEM(cur)) {\n+            inXSLText = 0;\n+            textNode = NULL;\n+            findSpaceAttr = 1;\n+            cctxt->inode->stripWhitespace = 0;\n+            \/*\n+            * TODO: I'd love to use a string pointer comparison here :-\/\n+            *\/\n+            if (IS_XSLT_ELEM(cur)) {\n@@ -3146,7 +3146,7 @@\n-        if (cur->ns->href != nsNameXSLT) {\n-            nsMapItem = xsltNewNamespaceMapItem(cctxt,\n-            doc, cur->ns, cur);\n-            if (nsMapItem == NULL)\n-            goto internal_err;\n-            cur->ns->href = nsNameXSLT;\n-        }\n+                if (cur->ns->href != nsNameXSLT) {\n+                    nsMapItem = xsltNewNamespaceMapItem(cctxt,\n+                        doc, cur->ns, cur);\n+                    if (nsMapItem == NULL)\n+                        goto internal_err;\n+                    cur->ns->href = nsNameXSLT;\n+                }\n@@ -3155,40 +3155,2 @@\n-        if (cur->name == NULL)\n-            goto process_attributes;\n-        \/*\n-        * Mark the XSLT element for later recognition.\n-        * TODO: Using the marker is still too dangerous, since if\n-        *   the parsing mechanism leaves out an XSLT element, then\n-        *   this might hit the transformation-mechanism, which\n-        *   will break if it doesn't expect such a marker.\n-        *\/\n-        \/* cur->psvi = (void *) xsltXSLTElemMarker; *\/\n-\n-        \/*\n-        * XSLT 2.0: \"Any whitespace text node whose parent is\n-        * one of the following elements is removed from the \"\n-        * tree, regardless of any xml:space attributes:...\"\n-        * xsl:apply-imports,\n-        * xsl:apply-templates,\n-        * xsl:attribute-set,\n-        * xsl:call-template,\n-        * xsl:choose,\n-        * xsl:stylesheet, xsl:transform.\n-        * XSLT 2.0: xsl:analyze-string,\n-        *           xsl:character-map,\n-        *           xsl:next-match\n-        *\n-        * TODO: I'd love to use a string pointer comparison here :-\/\n-        *\/\n-        name = cur->name;\n-        switch (*name) {\n-            case 't':\n-            if ((name[0] == 't') && (name[1] == 'e') &&\n-                (name[2] == 'x') && (name[3] == 't') &&\n-                (name[4] == 0))\n-            {\n-                \/*\n-                * Process the xsl:text element.\n-                * ----------------------------\n-                * Mark it for later recognition.\n-                *\/\n-                cur->psvi = (void *) xsltXSLTTextMarker;\n+                if (cur->name == NULL)\n+                    goto process_attributes;\n@@ -3196,3 +3158,5 @@\n-                * For stylesheets, the set of\n-                * whitespace-preserving element names\n-                * consists of just xsl:text.\n+                * Mark the XSLT element for later recognition.\n+                * TODO: Using the marker is still too dangerous, since if\n+                *   the parsing mechanism leaves out an XSLT element, then\n+                *   this might hit the transformation-mechanism, which\n+                *   will break if it doesn't expect such a marker.\n@@ -3200,14 +3164,1 @@\n-                findSpaceAttr = 0;\n-                cctxt->inode->preserveWhitespace = 1;\n-                inXSLText = 1;\n-            }\n-            break;\n-            case 'c':\n-            if (xmlStrEqual(name, BAD_CAST \"choose\") ||\n-                xmlStrEqual(name, BAD_CAST \"call-template\"))\n-                cctxt->inode->stripWhitespace = 1;\n-            break;\n-            case 'a':\n-            if (xmlStrEqual(name, BAD_CAST \"apply-templates\") ||\n-                xmlStrEqual(name, BAD_CAST \"apply-imports\") ||\n-                xmlStrEqual(name, BAD_CAST \"attribute-set\"))\n+                \/* cur->psvi = (void *) xsltXSLTElemMarker; *\/\n@@ -3215,4 +3166,0 @@\n-                cctxt->inode->stripWhitespace = 1;\n-            break;\n-            default:\n-            if (xsltStylesheetElemDepth == cctxt->depth) {\n@@ -3220,1 +3167,14 @@\n-                * This is a xsl:stylesheet\/xsl:transform.\n+                * XSLT 2.0: \"Any whitespace text node whose parent is\n+                * one of the following elements is removed from the \"\n+                * tree, regardless of any xml:space attributes:...\"\n+                * xsl:apply-imports,\n+                * xsl:apply-templates,\n+                * xsl:attribute-set,\n+                * xsl:call-template,\n+                * xsl:choose,\n+                * xsl:stylesheet, xsl:transform.\n+                * XSLT 2.0: xsl:analyze-string,\n+                *           xsl:character-map,\n+                *           xsl:next-match\n+                *\n+                * TODO: I'd love to use a string pointer comparison here :-\/\n@@ -3222,2 +3182,75 @@\n-                cctxt->inode->stripWhitespace = 1;\n-                break;\n+                name = cur->name;\n+                switch (*name) {\n+                    case 't':\n+                        if ((name[0] == 't') && (name[1] == 'e') &&\n+                            (name[2] == 'x') && (name[3] == 't') &&\n+                            (name[4] == 0))\n+                        {\n+                            \/*\n+                            * Process the xsl:text element.\n+                            * ----------------------------\n+                            * Mark it for later recognition.\n+                            *\/\n+                            cur->psvi = (void *) xsltXSLTTextMarker;\n+                            \/*\n+                            * For stylesheets, the set of\n+                            * whitespace-preserving element names\n+                            * consists of just xsl:text.\n+                            *\/\n+                            findSpaceAttr = 0;\n+                            cctxt->inode->preserveWhitespace = 1;\n+                            inXSLText = 1;\n+                        }\n+                        break;\n+                    case 'c':\n+                        if (xmlStrEqual(name, BAD_CAST \"choose\") ||\n+                            xmlStrEqual(name, BAD_CAST \"call-template\"))\n+                            cctxt->inode->stripWhitespace = 1;\n+                        break;\n+                    case 'a':\n+                        if (xmlStrEqual(name, BAD_CAST \"apply-templates\") ||\n+                            xmlStrEqual(name, BAD_CAST \"apply-imports\") ||\n+                            xmlStrEqual(name, BAD_CAST \"attribute-set\"))\n+\n+                            cctxt->inode->stripWhitespace = 1;\n+                        break;\n+                    default:\n+                        if (xsltStylesheetElemDepth == cctxt->depth) {\n+                            \/*\n+                            * This is a xsl:stylesheet\/xsl:transform.\n+                            *\/\n+                            cctxt->inode->stripWhitespace = 1;\n+                            break;\n+                        }\n+\n+                        if ((cur->prev != NULL) &&\n+                            (cur->prev->type == XML_TEXT_NODE))\n+                        {\n+                            \/*\n+                            * XSLT 2.0 : \"Any whitespace text node whose\n+                            *  following-sibling node is an xsl:param or\n+                            *  xsl:sort element is removed from the tree,\n+                            *  regardless of any xml:space attributes.\"\n+                            *\/\n+                            if (((*name == 'p') || (*name == 's')) &&\n+                                (xmlStrEqual(name, BAD_CAST \"param\") ||\n+                                 xmlStrEqual(name, BAD_CAST \"sort\")))\n+                            {\n+                                do {\n+                                    if (IS_BLANK_NODE(cur->prev)) {\n+                                        txt = cur->prev;\n+                                        xmlUnlinkNode(txt);\n+                                        xmlFreeNode(txt);\n+                                    } else {\n+                                        \/*\n+                                        * This will result in a content\n+                                        * error, when hitting the parsing\n+                                        * functions.\n+                                        *\/\n+                                        break;\n+                                    }\n+                                } while (cur->prev);\n+                            }\n+                        }\n+                        break;\n+                }\n@@ -3226,13 +3259,9 @@\n-            if ((cur->prev != NULL) &&\n-                (cur->prev->type == XML_TEXT_NODE))\n-            {\n-                \/*\n-                * XSLT 2.0 : \"Any whitespace text node whose\n-                *  following-sibling node is an xsl:param or\n-                *  xsl:sort element is removed from the tree,\n-                *  regardless of any xml:space attributes.\"\n-                *\/\n-                if (((*name == 'p') || (*name == 's')) &&\n-                (xmlStrEqual(name, BAD_CAST \"param\") ||\n-                 xmlStrEqual(name, BAD_CAST \"sort\")))\n-                {\n+process_attributes:\n+            \/*\n+            * Process attributes.\n+            * ------------------\n+            *\/\n+            if (cur->properties != NULL) {\n+                if (cur->children == NULL)\n+                    findSpaceAttr = 0;\n+                attr = cur->properties;\n@@ -3240,5 +3269,31 @@\n-                    if (IS_BLANK_NODE(cur->prev)) {\n-                    txt = cur->prev;\n-                    xmlUnlinkNode(txt);\n-                    xmlFreeNode(txt);\n-                    } else {\n+#ifdef XSLT_REFACTORED_XSLT_NSCOMP\n+                    if ((attr->ns) && (attr->ns->href != nsNameXSLT) &&\n+                        xmlStrEqual(attr->ns->href, nsNameXSLT))\n+                    {\n+                        nsMapItem = xsltNewNamespaceMapItem(cctxt,\n+                            doc, attr->ns, cur);\n+                        if (nsMapItem == NULL)\n+                            goto internal_err;\n+                        attr->ns->href = nsNameXSLT;\n+                    }\n+#endif\n+                    if (internalize) {\n+                        \/*\n+                        * Internalize the attribute's value; the goal is to\n+                        * speed up operations and minimize used space by\n+                        * compiled stylesheets.\n+                        *\/\n+                        txt = attr->children;\n+                        \/*\n+                        * NOTE that this assumes only one\n+                        *  text-node in the attribute's content.\n+                        *\/\n+                        if ((txt != NULL) && (txt->content != NULL) &&\n+                            (!xmlDictOwns(style->dict, txt->content)))\n+                        {\n+                            value = (xmlChar *) xmlDictLookup(style->dict,\n+                                txt->content, -1);\n+                            xmlNodeSetContent(txt, NULL);\n+                            txt->content = value;\n+                        }\n+                    }\n@@ -3246,3 +3301,2 @@\n-                    * This will result in a content\n-                    * error, when hitting the parsing\n-                    * functions.\n+                    * Process xml:space attributes.\n+                    * ----------------------------\n@@ -3250,1 +3304,27 @@\n-                    break;\n+                    if ((findSpaceAttr != 0) &&\n+                        (attr->ns != NULL) &&\n+                        (attr->name != NULL) &&\n+                        (attr->name[0] == 's') &&\n+                        (attr->ns->prefix != NULL) &&\n+                        (attr->ns->prefix[0] == 'x') &&\n+                        (attr->ns->prefix[1] == 'm') &&\n+                        (attr->ns->prefix[2] == 'l') &&\n+                        (attr->ns->prefix[3] == 0))\n+                    {\n+                        value = xmlGetNsProp(cur, BAD_CAST \"space\",\n+                            XML_XML_NAMESPACE);\n+                        if (value != NULL) {\n+                            if (xmlStrEqual(value, BAD_CAST \"preserve\")) {\n+                                cctxt->inode->preserveWhitespace = 1;\n+                            } else if (xmlStrEqual(value, BAD_CAST \"default\")) {\n+                                cctxt->inode->preserveWhitespace = 0;\n+                            } else {\n+                                \/* Invalid value for xml:space. *\/\n+                                xsltTransformError(NULL, style, cur,\n+                                    \"Attribute xml:space: Invalid value.\\n\");\n+                                cctxt->style->warnings++;\n+                            }\n+                            findSpaceAttr = 0;\n+                            xmlFree(value);\n+                        }\n+\n@@ -3252,1 +3332,44 @@\n-                } while (cur->prev);\n+                    attr = attr->next;\n+                } while (attr != NULL);\n+            }\n+            \/*\n+            * We'll descend into the children of element nodes only.\n+            *\/\n+            if (cur->children != NULL) {\n+                cur = cur->children;\n+                continue;\n+            }\n+        } else if ((cur->type == XML_TEXT_NODE) ||\n+                (cur->type == XML_CDATA_SECTION_NODE))\n+        {\n+            \/*\n+            * Merge adjacent text\/CDATA-section-nodes\n+            * ---------------------------------------\n+            * In order to avoid breaking of existing stylesheets,\n+            * if the old behaviour is wanted (strictWhitespace == 0),\n+            * then we *won't* merge adjacent text-nodes\n+            * (except in xsl:text); this will ensure that whitespace-only\n+            * text nodes are (incorrectly) not stripped in some cases.\n+            *\n+            * Example:               : <foo>  <!-- bar -->zoo<\/foo>\n+            * Corrent (strict) result: <foo>  zoo<\/foo>\n+            * Incorrect (old) result : <foo>zoo<\/foo>\n+            *\n+            * NOTE that we *will* merge adjacent text-nodes if\n+            * they are in xsl:text.\n+            * Example, the following:\n+            * <xsl:text>  <!-- bar -->zoo<xsl:text>\n+            * will result in both cases in:\n+            * <xsl:text>  zoo<xsl:text>\n+            *\/\n+            cur->type = XML_TEXT_NODE;\n+            if ((strictWhitespace != 0) || (inXSLText != 0)) {\n+                \/*\n+                * New behaviour; merge nodes.\n+                *\/\n+                if (textNode == NULL)\n+                    textNode = cur;\n+                else {\n+                    if (cur->content != NULL)\n+                        xmlNodeAddContent(textNode, cur->content);\n+                    deleteNode = cur;\n@@ -3254,0 +3377,12 @@\n+                if ((cur->next == NULL) ||\n+                    (cur->next->type == XML_ELEMENT_NODE))\n+                    goto end_of_text;\n+                else\n+                    goto next_sibling;\n+            } else {\n+                \/*\n+                * Old behaviour.\n+                *\/\n+                if (textNode == NULL)\n+                    textNode = cur;\n+                goto end_of_text;\n@@ -3255,2 +3390,21 @@\n-            break;\n-        }\n+        } else if ((cur->type == XML_COMMENT_NODE) ||\n+            (cur->type == XML_PI_NODE))\n+        {\n+            \/*\n+            * Remove processing instructions and comments.\n+            *\/\n+            deleteNode = cur;\n+            if ((cur->next == NULL) ||\n+                (cur->next->type == XML_ELEMENT_NODE))\n+                goto end_of_text;\n+            else\n+                goto next_sibling;\n+        } else {\n+            textNode = NULL;\n+            \/*\n+            * Invalid node-type for this data-model.\n+            *\/\n+            xsltTransformError(NULL, style, cur,\n+                \"Invalid type of node for the XSLT data model.\\n\");\n+            cctxt->style->errors++;\n+            goto next_sibling;\n@@ -3259,22 +3413,3 @@\n-process_attributes:\n-        \/*\n-        * Process attributes.\n-        * ------------------\n-        *\/\n-        if (cur->properties != NULL) {\n-        if (cur->children == NULL)\n-            findSpaceAttr = 0;\n-        attr = cur->properties;\n-        do {\n-#ifdef XSLT_REFACTORED_XSLT_NSCOMP\n-            if ((attr->ns) && (attr->ns->href != nsNameXSLT) &&\n-            xmlStrEqual(attr->ns->href, nsNameXSLT))\n-            {\n-            nsMapItem = xsltNewNamespaceMapItem(cctxt,\n-                doc, attr->ns, cur);\n-            if (nsMapItem == NULL)\n-                goto internal_err;\n-            attr->ns->href = nsNameXSLT;\n-            }\n-#endif\n-            if (internalize) {\n+end_of_text:\n+        if (textNode) {\n+            value = textNode->content;\n@@ -3282,3 +3417,5 @@\n-            * Internalize the attribute's value; the goal is to\n-            * speed up operations and minimize used space by\n-            * compiled stylesheets.\n+            * At this point all adjacent text\/CDATA-section nodes\n+            * have been merged.\n+            *\n+            * Strip whitespace-only text-nodes.\n+            * (cctxt->inode->stripWhitespace)\n@@ -3286,1 +3423,14 @@\n-            txt = attr->children;\n+            if ((value == NULL) || (*value == 0) ||\n+                (((cctxt->inode->stripWhitespace) ||\n+                  (! cctxt->inode->preserveWhitespace)) &&\n+                 IS_BLANK(*value) &&\n+                 xsltIsBlank(value)))\n+            {\n+                if (textNode != cur) {\n+                    xmlUnlinkNode(textNode);\n+                    xmlFreeNode(textNode);\n+                } else\n+                    deleteNode = textNode;\n+                textNode = NULL;\n+                goto next_sibling;\n+            }\n@@ -3288,2 +3438,2 @@\n-            * NOTE that this assumes only one\n-            *  text-node in the attribute's content.\n+            * Convert CDATA-section nodes to text-nodes.\n+            * TODO: Can this produce problems?\n@@ -3291,2 +3441,7 @@\n-            if ((txt != NULL) && (txt->content != NULL) &&\n-                (!xmlDictOwns(style->dict, txt->content)))\n+            if (textNode->type != XML_TEXT_NODE) {\n+                textNode->type = XML_TEXT_NODE;\n+                textNode->name = xmlStringText;\n+            }\n+            if (internalize &&\n+                (textNode->content != NULL) &&\n+                (!xmlDictOwns(style->dict, textNode->content)))\n@@ -3294,0 +3449,3 @@\n+                \/*\n+                * Internalize the string.\n+                *\/\n@@ -3295,4 +3453,3 @@\n-                txt->content, -1);\n-                xmlNodeSetContent(txt, NULL);\n-                txt->content = value;\n-            }\n+                    textNode->content, -1);\n+                xmlNodeSetContent(textNode, NULL);\n+                textNode->content = value;\n@@ -3300,0 +3457,1 @@\n+            textNode = NULL;\n@@ -3301,2 +3459,3 @@\n-            * Process xml:space attributes.\n-            * ----------------------------\n+            * Note that \"disable-output-escaping\" of the xsl:text\n+            * element will be applied at a later level, when\n+            * XSLT elements are processed.\n@@ -3304,26 +3463,1 @@\n-            if ((findSpaceAttr != 0) &&\n-            (attr->ns != NULL) &&\n-            (attr->name != NULL) &&\n-            (attr->name[0] == 's') &&\n-            (attr->ns->prefix != NULL) &&\n-            (attr->ns->prefix[0] == 'x') &&\n-            (attr->ns->prefix[1] == 'm') &&\n-            (attr->ns->prefix[2] == 'l') &&\n-            (attr->ns->prefix[3] == 0))\n-            {\n-            value = xmlGetNsProp(cur, BAD_CAST \"space\",\n-                XML_XML_NAMESPACE);\n-            if (value != NULL) {\n-                if (xmlStrEqual(value, BAD_CAST \"preserve\")) {\n-                cctxt->inode->preserveWhitespace = 1;\n-                } else if (xmlStrEqual(value, BAD_CAST \"default\")) {\n-                cctxt->inode->preserveWhitespace = 0;\n-                } else {\n-                \/* Invalid value for xml:space. *\/\n-                xsltTransformError(NULL, style, cur,\n-                    \"Attribute xml:space: Invalid value.\\n\");\n-                cctxt->style->warnings++;\n-                }\n-                findSpaceAttr = 0;\n-                xmlFree(value);\n-            }\n+        }\n@@ -3331,3 +3465,3 @@\n-            }\n-            attr = attr->next;\n-        } while (attr != NULL);\n+next_sibling:\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            xsltCompilerNodePop(cctxt, cur);\n@@ -3335,47 +3469,4 @@\n-        \/*\n-        * We'll descend into the children of element nodes only.\n-        *\/\n-        if (cur->children != NULL) {\n-        cur = cur->children;\n-        continue;\n-        }\n-    } else if ((cur->type == XML_TEXT_NODE) ||\n-        (cur->type == XML_CDATA_SECTION_NODE))\n-    {\n-        \/*\n-        * Merge adjacent text\/CDATA-section-nodes\n-        * ---------------------------------------\n-        * In order to avoid breaking of existing stylesheets,\n-        * if the old behaviour is wanted (strictWhitespace == 0),\n-        * then we *won't* merge adjacent text-nodes\n-        * (except in xsl:text); this will ensure that whitespace-only\n-        * text nodes are (incorrectly) not stripped in some cases.\n-        *\n-        * Example:               : <foo>  <!-- bar -->zoo<\/foo>\n-        * Corrent (strict) result: <foo>  zoo<\/foo>\n-        * Incorrect (old) result : <foo>zoo<\/foo>\n-        *\n-        * NOTE that we *will* merge adjacent text-nodes if\n-        * they are in xsl:text.\n-        * Example, the following:\n-        * <xsl:text>  <!-- bar -->zoo<xsl:text>\n-        * will result in both cases in:\n-        * <xsl:text>  zoo<xsl:text>\n-        *\/\n-        cur->type = XML_TEXT_NODE;\n-        if ((strictWhitespace != 0) || (inXSLText != 0)) {\n-        \/*\n-        * New behaviour; merge nodes.\n-        *\/\n-        if (textNode == NULL)\n-            textNode = cur;\n-        else {\n-            if (cur->content != NULL)\n-            xmlNodeAddContent(textNode, cur->content);\n-            deleteNode = cur;\n-        }\n-        if ((cur->next == NULL) ||\n-            (cur->next->type == XML_ELEMENT_NODE))\n-            goto end_of_text;\n-        else\n-            goto next_sibling;\n+        if (cur == node)\n+            break;\n+        if (cur->next != NULL) {\n+            cur = cur->next;\n@@ -3383,95 +3474,4 @@\n-        \/*\n-        * Old behaviour.\n-        *\/\n-        if (textNode == NULL)\n-            textNode = cur;\n-        goto end_of_text;\n-        }\n-    } else if ((cur->type == XML_COMMENT_NODE) ||\n-        (cur->type == XML_PI_NODE))\n-    {\n-        \/*\n-        * Remove processing instructions and comments.\n-        *\/\n-        deleteNode = cur;\n-        if ((cur->next == NULL) ||\n-        (cur->next->type == XML_ELEMENT_NODE))\n-        goto end_of_text;\n-        else\n-        goto next_sibling;\n-    } else {\n-        textNode = NULL;\n-        \/*\n-        * Invalid node-type for this data-model.\n-        *\/\n-        xsltTransformError(NULL, style, cur,\n-        \"Invalid type of node for the XSLT data model.\\n\");\n-        cctxt->style->errors++;\n-        goto next_sibling;\n-    }\n-\n-end_of_text:\n-    if (textNode) {\n-        value = textNode->content;\n-        \/*\n-        * At this point all adjacent text\/CDATA-section nodes\n-        * have been merged.\n-        *\n-        * Strip whitespace-only text-nodes.\n-        * (cctxt->inode->stripWhitespace)\n-        *\/\n-        if ((value == NULL) || (*value == 0) ||\n-        (((cctxt->inode->stripWhitespace) ||\n-          (! cctxt->inode->preserveWhitespace)) &&\n-         IS_BLANK(*value) &&\n-         xsltIsBlank(value)))\n-        {\n-        if (textNode != cur) {\n-            xmlUnlinkNode(textNode);\n-            xmlFreeNode(textNode);\n-        } else\n-            deleteNode = textNode;\n-        textNode = NULL;\n-        goto next_sibling;\n-        }\n-        \/*\n-        * Convert CDATA-section nodes to text-nodes.\n-        * TODO: Can this produce problems?\n-        *\/\n-        if (textNode->type != XML_TEXT_NODE) {\n-        textNode->type = XML_TEXT_NODE;\n-        textNode->name = xmlStringText;\n-        }\n-        if (internalize &&\n-        (textNode->content != NULL) &&\n-        (!xmlDictOwns(style->dict, textNode->content)))\n-        {\n-        \/*\n-        * Internalize the string.\n-        *\/\n-        value = (xmlChar *) xmlDictLookup(style->dict,\n-            textNode->content, -1);\n-        xmlNodeSetContent(textNode, NULL);\n-        textNode->content = value;\n-        }\n-        textNode = NULL;\n-        \/*\n-        * Note that \"disable-output-escaping\" of the xsl:text\n-        * element will be applied at a later level, when\n-        * XSLT elements are processed.\n-        *\/\n-    }\n-\n-next_sibling:\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        xsltCompilerNodePop(cctxt, cur);\n-    }\n-    if (cur == node)\n-        break;\n-    if (cur->next != NULL) {\n-        cur = cur->next;\n-    } else {\n-        cur = cur->parent;\n-        inXSLText = 0;\n-        goto next_sibling;\n-    };\n+            cur = cur->parent;\n+            inXSLText = 0;\n+            goto next_sibling;\n+        };\n@@ -3481,2 +3481,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-     \"xsltParsePreprocessStylesheetTree: removing node\\n\");\n+        xsltGenericDebug(xsltGenericDebugContext,\n+         \"xsltParsePreprocessStylesheetTree: removing node\\n\");\n@@ -3484,2 +3484,2 @@\n-    xmlUnlinkNode(deleteNode);\n-    xmlFreeNode(deleteNode);\n+        xmlUnlinkNode(deleteNode);\n+        xmlFreeNode(deleteNode);\n@@ -3508,1 +3508,1 @@\n-    internalize = 1;\n+        internalize = 1;\n@@ -3514,1 +3514,1 @@\n-    styleelem = cur;\n+        styleelem = cur;\n@@ -3526,1 +3526,1 @@\n-    if (deleteNode != NULL) {\n+        if (deleteNode != NULL) {\n@@ -3528,2 +3528,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltPreprocessStylesheet: removing ignorable blank node\\n\");\n+            xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltPreprocessStylesheet: removing ignorable blank node\\n\");\n@@ -3531,21 +3531,6 @@\n-        xmlUnlinkNode(deleteNode);\n-        xmlFreeNode(deleteNode);\n-        deleteNode = NULL;\n-    }\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        int exclPrefixes;\n-        \/*\n-         * Internalize attributes values.\n-         *\/\n-        if ((internalize) && (cur->properties != NULL)) {\n-            xmlAttrPtr attr = cur->properties;\n-        xmlNodePtr txt;\n-\n-        while (attr != NULL) {\n-            txt = attr->children;\n-            if ((txt != NULL) && (txt->type == XML_TEXT_NODE) &&\n-                (txt->content != NULL) &&\n-            (!xmlDictOwns(style->dict, txt->content)))\n-            {\n-            xmlChar *tmp;\n-\n+            xmlUnlinkNode(deleteNode);\n+            xmlFreeNode(deleteNode);\n+            deleteNode = NULL;\n+        }\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            int exclPrefixes;\n@@ -3553,3 +3538,1 @@\n-             * internalize the text string, goal is to speed\n-             * up operations and minimize used space by compiled\n-             * stylesheets.\n+             * Internalize attributes values.\n@@ -3557,5 +3540,26 @@\n-            tmp = (xmlChar *) xmlDictLookup(style->dict,\n-                                            txt->content, -1);\n-            if (tmp != txt->content) {\n-                xmlNodeSetContent(txt, NULL);\n-                txt->content = tmp;\n+            if ((internalize) && (cur->properties != NULL)) {\n+                xmlAttrPtr attr = cur->properties;\n+                xmlNodePtr txt;\n+\n+                while (attr != NULL) {\n+                    txt = attr->children;\n+                    if ((txt != NULL) && (txt->type == XML_TEXT_NODE) &&\n+                        (txt->content != NULL) &&\n+                        (!xmlDictOwns(style->dict, txt->content)))\n+                    {\n+                        xmlChar *tmp;\n+\n+                        \/*\n+                         * internalize the text string, goal is to speed\n+                         * up operations and minimize used space by compiled\n+                         * stylesheets.\n+                         *\/\n+                        tmp = (xmlChar *) xmlDictLookup(style->dict,\n+                                                        txt->content, -1);\n+                        if (tmp != txt->content) {\n+                            xmlNodeSetContent(txt, NULL);\n+                            txt->content = tmp;\n+                        }\n+                    }\n+                    attr = attr->next;\n+                }\n@@ -3563,0 +3567,9 @@\n+            if (IS_XSLT_ELEM(cur)) {\n+                exclPrefixes = 0;\n+                if (IS_XSLT_NAME(cur, \"text\")) {\n+                    for (;exclPrefixes > 0;exclPrefixes--)\n+                        exclPrefixPop(style);\n+                    goto skip_children;\n+                }\n+            } else {\n+                exclPrefixes = xsltParseStylesheetExcludePrefix(style, cur, 0);\n@@ -3564,13 +3577,0 @@\n-            attr = attr->next;\n-        }\n-        }\n-        if (IS_XSLT_ELEM(cur)) {\n-        exclPrefixes = 0;\n-        if (IS_XSLT_NAME(cur, \"text\")) {\n-            for (;exclPrefixes > 0;exclPrefixes--)\n-            exclPrefixPop(style);\n-            goto skip_children;\n-        }\n-        } else {\n-        exclPrefixes = xsltParseStylesheetExcludePrefix(style, cur, 0);\n-        }\n@@ -3578,4 +3578,54 @@\n-        if ((cur->nsDef != NULL) && (style->exclPrefixNr > 0)) {\n-        xmlNsPtr ns = cur->nsDef, prev = NULL, next;\n-        xmlNodePtr root = NULL;\n-        int i, moved;\n+            if ((cur->nsDef != NULL) && (style->exclPrefixNr > 0)) {\n+                xmlNsPtr ns = cur->nsDef, prev = NULL, next;\n+                xmlNodePtr root = NULL;\n+                int i, moved;\n+\n+                root = xmlDocGetRootElement(cur->doc);\n+                if ((root != NULL) && (root != cur)) {\n+                    while (ns != NULL) {\n+                        moved = 0;\n+                        next = ns->next;\n+                        for (i = 0;i < style->exclPrefixNr;i++) {\n+                            if ((ns->prefix != NULL) &&\n+                                (xmlStrEqual(ns->href,\n+                                             style->exclPrefixTab[i]))) {\n+                                \/*\n+                                 * Move the namespace definition on the root\n+                                 * element to avoid duplicating it without\n+                                 * loosing it.\n+                                 *\/\n+                                if (prev == NULL) {\n+                                    cur->nsDef = ns->next;\n+                                } else {\n+                                    prev->next = ns->next;\n+                                }\n+                                ns->next = root->nsDef;\n+                                root->nsDef = ns;\n+                                moved = 1;\n+                                break;\n+                            }\n+                        }\n+                        if (moved == 0)\n+                            prev = ns;\n+                        ns = next;\n+                    }\n+                }\n+            }\n+            \/*\n+             * If we have prefixes locally, recurse and pop them up when\n+             * going back\n+             *\/\n+            if (exclPrefixes > 0) {\n+                xsltPreprocessStylesheet(style, cur->children);\n+                for (;exclPrefixes > 0;exclPrefixes--)\n+                    exclPrefixPop(style);\n+                goto skip_children;\n+            }\n+        } else if (cur->type == XML_TEXT_NODE) {\n+            if (IS_BLANK_NODE(cur)) {\n+                if (xmlNodeGetSpacePreserve(cur->parent) != 1) {\n+                    deleteNode = cur;\n+                }\n+            } else if ((cur->content != NULL) && (internalize) &&\n+                       (!xmlDictOwns(style->dict, cur->content))) {\n+                xmlChar *tmp;\n@@ -3583,9 +3633,0 @@\n-        root = xmlDocGetRootElement(cur->doc);\n-        if ((root != NULL) && (root != cur)) {\n-            while (ns != NULL) {\n-            moved = 0;\n-            next = ns->next;\n-            for (i = 0;i < style->exclPrefixNr;i++) {\n-                if ((ns->prefix != NULL) &&\n-                    (xmlStrEqual(ns->href,\n-                         style->exclPrefixTab[i]))) {\n@@ -3593,3 +3634,3 @@\n-                 * Move the namespace definition on the root\n-                 * element to avoid duplicating it without\n-                 * loosing it.\n+                 * internalize the text string, goal is to speed\n+                 * up operations and minimize used space by compiled\n+                 * stylesheets.\n@@ -3597,10 +3638,3 @@\n-                if (prev == NULL) {\n-                    cur->nsDef = ns->next;\n-                } else {\n-                    prev->next = ns->next;\n-                }\n-                ns->next = root->nsDef;\n-                root->nsDef = ns;\n-                moved = 1;\n-                break;\n-                }\n+                tmp = (xmlChar *) xmlDictLookup(style->dict, cur->content, -1);\n+                xmlNodeSetContent(cur, NULL);\n+                cur->content = tmp;\n@@ -3608,19 +3642,2 @@\n-            if (moved == 0)\n-                prev = ns;\n-            ns = next;\n-            }\n-        }\n-        }\n-        \/*\n-         * If we have prefixes locally, recurse and pop them up when\n-         * going back\n-         *\/\n-        if (exclPrefixes > 0) {\n-        xsltPreprocessStylesheet(style, cur->children);\n-        for (;exclPrefixes > 0;exclPrefixes--)\n-            exclPrefixPop(style);\n-        goto skip_children;\n-        }\n-    } else if (cur->type == XML_TEXT_NODE) {\n-        if (IS_BLANK_NODE(cur)) {\n-        if (xmlNodeGetSpacePreserve(cur->parent) != 1) {\n+        } else if ((cur->type != XML_ELEMENT_NODE) &&\n+                   (cur->type != XML_CDATA_SECTION_NODE)) {\n@@ -3628,0 +3645,1 @@\n+            goto skip_children;\n@@ -3629,3 +3647,0 @@\n-        } else if ((cur->content != NULL) && (internalize) &&\n-                   (!xmlDictOwns(style->dict, cur->content))) {\n-        xmlChar *tmp;\n@@ -3634,3 +3649,3 @@\n-         * internalize the text string, goal is to speed\n-         * up operations and minimize used space by compiled\n-         * stylesheets.\n+         * Skip to next node. In case of a namespaced element children of\n+         * the stylesheet and not in the XSLT namespace and not an extension\n+         * element, ignore its content.\n@@ -3638,26 +3653,8 @@\n-        tmp = (xmlChar *) xmlDictLookup(style->dict, cur->content, -1);\n-        xmlNodeSetContent(cur, NULL);\n-        cur->content = tmp;\n-        }\n-    } else if ((cur->type != XML_ELEMENT_NODE) &&\n-           (cur->type != XML_CDATA_SECTION_NODE)) {\n-        deleteNode = cur;\n-        goto skip_children;\n-    }\n-\n-    \/*\n-     * Skip to next node. In case of a namespaced element children of\n-     * the stylesheet and not in the XSLT namespace and not an extension\n-     * element, ignore its content.\n-     *\/\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->ns != NULL) &&\n-        (styleelem != NULL) && (cur->parent == styleelem) &&\n-        (!xmlStrEqual(cur->ns->href, XSLT_NAMESPACE)) &&\n-        (!xsltCheckExtURI(style, cur->ns->href))) {\n-        goto skip_children;\n-    } else if (cur->children != NULL) {\n-        if ((cur->children->type != XML_ENTITY_DECL) &&\n-        (cur->children->type != XML_ENTITY_REF_NODE) &&\n-        (cur->children->type != XML_ENTITY_NODE)) {\n-        cur = cur->children;\n-        continue;\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->ns != NULL) &&\n+            (styleelem != NULL) && (cur->parent == styleelem) &&\n+            (!xmlStrEqual(cur->ns->href, XSLT_NAMESPACE)) &&\n+            (!xsltCheckExtURI(style, cur->ns->href))) {\n+            goto skip_children;\n+        } else if (cur->children != NULL) {\n+            cur = cur->children;\n+            continue;\n@@ -3665,1 +3662,0 @@\n-    }\n@@ -3668,13 +3664,0 @@\n-    if (cur->next != NULL) {\n-        cur = cur->next;\n-        continue;\n-    }\n-    do {\n-\n-        cur = cur->parent;\n-        if (cur == NULL)\n-        break;\n-        if (cur == (xmlNodePtr) style->doc) {\n-        cur = NULL;\n-        break;\n-        }\n@@ -3682,2 +3665,2 @@\n-        cur = cur->next;\n-        break;\n+            cur = cur->next;\n+            continue;\n@@ -3685,1 +3668,14 @@\n-    } while (cur != NULL);\n+        do {\n+\n+            cur = cur->parent;\n+            if (cur == NULL)\n+                break;\n+            if (cur == (xmlNodePtr) style->doc) {\n+                cur = NULL;\n+                break;\n+            }\n+            if (cur->next != NULL) {\n+                cur = cur->next;\n+                break;\n+            }\n+        } while (cur != NULL);\n@@ -3689,2 +3685,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-     \"xsltPreprocessStylesheet: removing ignorable blank node\\n\");\n+        xsltGenericDebug(xsltGenericDebugContext,\n+         \"xsltPreprocessStylesheet: removing ignorable blank node\\n\");\n@@ -3692,2 +3688,2 @@\n-    xmlUnlinkNode(deleteNode);\n-    xmlFreeNode(deleteNode);\n+        xmlUnlinkNode(deleteNode);\n+        xmlFreeNode(deleteNode);\n@@ -3727,21 +3723,21 @@\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        xmlNsPtr ns = cur->nsDef;\n-        while (ns != NULL) {\n-        if (ns->prefix != NULL) {\n-            if (style->nsHash == NULL) {\n-            style->nsHash = xmlHashCreate(10);\n-            if (style->nsHash == NULL) {\n-                xsltTransformError(NULL, style, cur,\n-         \"xsltGatherNamespaces: failed to create hash table\\n\");\n-                style->errors++;\n-                return;\n-            }\n-            }\n-            URI = xmlHashLookup(style->nsHash, ns->prefix);\n-            if ((URI != NULL) && (!xmlStrEqual(URI, ns->href))) {\n-            xsltTransformError(NULL, style, cur,\n-         \"Namespaces prefix %s used for multiple namespaces\\n\",ns->prefix);\n-            style->warnings++;\n-            } else if (URI == NULL) {\n-            xmlHashUpdateEntry(style->nsHash, ns->prefix,\n-                (void *) ns->href, NULL);\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            xmlNsPtr ns = cur->nsDef;\n+            while (ns != NULL) {\n+                if (ns->prefix != NULL) {\n+                    if (style->nsHash == NULL) {\n+                        style->nsHash = xmlHashCreate(10);\n+                        if (style->nsHash == NULL) {\n+                            xsltTransformError(NULL, style, cur,\n+                 \"xsltGatherNamespaces: failed to create hash table\\n\");\n+                            style->errors++;\n+                            return;\n+                        }\n+                    }\n+                    URI = xmlHashLookup(style->nsHash, ns->prefix);\n+                    if ((URI != NULL) && (!xmlStrEqual(URI, ns->href))) {\n+                        xsltTransformError(NULL, style, cur,\n+             \"Namespaces prefix %s used for multiple namespaces\\n\",ns->prefix);\n+                        style->warnings++;\n+                    } else if (URI == NULL) {\n+                        xmlHashUpdateEntry(style->nsHash, ns->prefix,\n+                            (void *) ns->href, NULL);\n@@ -3750,2 +3746,2 @@\n-            xsltGenericDebug(xsltGenericDebugContext,\n-         \"Added namespace: %s mapped to %s\\n\", ns->prefix, ns->href);\n+                        xsltGenericDebug(xsltGenericDebugContext,\n+                 \"Added namespace: %s mapped to %s\\n\", ns->prefix, ns->href);\n@@ -3753,0 +3749,3 @@\n+                    }\n+                }\n+                ns = ns->next;\n@@ -3755,17 +3754,0 @@\n-        ns = ns->next;\n-        }\n-    }\n-\n-    \/*\n-     * Skip to next node\n-     *\/\n-    if (cur->children != NULL) {\n-        if (cur->children->type != XML_ENTITY_DECL) {\n-        cur = cur->children;\n-        continue;\n-        }\n-    }\n-    if (cur->next != NULL) {\n-        cur = cur->next;\n-        continue;\n-    }\n@@ -3773,7 +3755,8 @@\n-    do {\n-        cur = cur->parent;\n-        if (cur == NULL)\n-        break;\n-        if (cur == (xmlNodePtr) style->doc) {\n-        cur = NULL;\n-        break;\n+        \/*\n+         * Skip to next node\n+         *\/\n+        if (cur->children != NULL) {\n+            if (cur->children->type != XML_ENTITY_DECL) {\n+                cur = cur->children;\n+                continue;\n+            }\n@@ -3782,2 +3765,2 @@\n-        cur = cur->next;\n-        break;\n+            cur = cur->next;\n+            continue;\n@@ -3785,1 +3768,14 @@\n-    } while (cur != NULL);\n+\n+        do {\n+            cur = cur->parent;\n+            if (cur == NULL)\n+                break;\n+            if (cur == (xmlNodePtr) style->doc) {\n+                cur = NULL;\n+                break;\n+            }\n+            if (cur->next != NULL) {\n+                cur = cur->next;\n+                break;\n+            }\n+        } while (cur != NULL);\n@@ -3793,1 +3789,1 @@\n-                 xmlNodePtr node)\n+                             xmlNodePtr node)\n@@ -3796,2 +3792,2 @@\n-    (node->name == NULL))\n-    return(0);\n+        (node->name == NULL))\n+        return(0);\n@@ -3800,8 +3796,8 @@\n-    if (IS_XSLT_NAME(node, \"apply-templates\"))\n-        return(XSLT_FUNC_APPLYTEMPLATES);\n-    else if (IS_XSLT_NAME(node, \"attribute\"))\n-        return(XSLT_FUNC_ATTRIBUTE);\n-    else if (IS_XSLT_NAME(node, \"apply-imports\"))\n-        return(XSLT_FUNC_APPLYIMPORTS);\n-    else if (IS_XSLT_NAME(node, \"attribute-set\"))\n-        return(0);\n+        if (IS_XSLT_NAME(node, \"apply-templates\"))\n+            return(XSLT_FUNC_APPLYTEMPLATES);\n+        else if (IS_XSLT_NAME(node, \"attribute\"))\n+            return(XSLT_FUNC_ATTRIBUTE);\n+        else if (IS_XSLT_NAME(node, \"apply-imports\"))\n+            return(XSLT_FUNC_APPLYIMPORTS);\n+        else if (IS_XSLT_NAME(node, \"attribute-set\"))\n+            return(0);\n@@ -3810,10 +3806,10 @@\n-    if (IS_XSLT_NAME(node, \"choose\"))\n-        return(XSLT_FUNC_CHOOSE);\n-    else if (IS_XSLT_NAME(node, \"copy\"))\n-        return(XSLT_FUNC_COPY);\n-    else if (IS_XSLT_NAME(node, \"copy-of\"))\n-        return(XSLT_FUNC_COPYOF);\n-    else if (IS_XSLT_NAME(node, \"call-template\"))\n-        return(XSLT_FUNC_CALLTEMPLATE);\n-    else if (IS_XSLT_NAME(node, \"comment\"))\n-        return(XSLT_FUNC_COMMENT);\n+        if (IS_XSLT_NAME(node, \"choose\"))\n+            return(XSLT_FUNC_CHOOSE);\n+        else if (IS_XSLT_NAME(node, \"copy\"))\n+            return(XSLT_FUNC_COPY);\n+        else if (IS_XSLT_NAME(node, \"copy-of\"))\n+            return(XSLT_FUNC_COPYOF);\n+        else if (IS_XSLT_NAME(node, \"call-template\"))\n+            return(XSLT_FUNC_CALLTEMPLATE);\n+        else if (IS_XSLT_NAME(node, \"comment\"))\n+            return(XSLT_FUNC_COMMENT);\n@@ -3822,4 +3818,4 @@\n-    if (IS_XSLT_NAME(node, \"document\"))\n-        return(XSLT_FUNC_DOCUMENT);\n-    else if (IS_XSLT_NAME(node, \"decimal-format\"))\n-        return(0);\n+        if (IS_XSLT_NAME(node, \"document\"))\n+            return(XSLT_FUNC_DOCUMENT);\n+        else if (IS_XSLT_NAME(node, \"decimal-format\"))\n+            return(0);\n@@ -3828,2 +3824,2 @@\n-    if (IS_XSLT_NAME(node, \"element\"))\n-        return(XSLT_FUNC_ELEMENT);\n+        if (IS_XSLT_NAME(node, \"element\"))\n+            return(XSLT_FUNC_ELEMENT);\n@@ -3832,4 +3828,4 @@\n-    if (IS_XSLT_NAME(node, \"for-each\"))\n-        return(XSLT_FUNC_FOREACH);\n-    else if (IS_XSLT_NAME(node, \"fallback\"))\n-        return(XSLT_FUNC_FALLBACK);\n+        if (IS_XSLT_NAME(node, \"for-each\"))\n+            return(XSLT_FUNC_FOREACH);\n+        else if (IS_XSLT_NAME(node, \"fallback\"))\n+            return(XSLT_FUNC_FALLBACK);\n@@ -3838,6 +3834,6 @@\n-    if (IS_XSLT_NAME(node, \"if\"))\n-        return(XSLT_FUNC_IF);\n-    else if (IS_XSLT_NAME(node, \"include\"))\n-        return(0);\n-    else if (IS_XSLT_NAME(node, \"import\"))\n-        return(0);\n+        if (IS_XSLT_NAME(node, \"if\"))\n+            return(XSLT_FUNC_IF);\n+        else if (IS_XSLT_NAME(node, \"include\"))\n+            return(0);\n+        else if (IS_XSLT_NAME(node, \"import\"))\n+            return(0);\n@@ -3846,2 +3842,2 @@\n-    if (IS_XSLT_NAME(node, \"key\"))\n-        return(0);\n+        if (IS_XSLT_NAME(node, \"key\"))\n+            return(0);\n@@ -3850,2 +3846,2 @@\n-    if (IS_XSLT_NAME(node, \"message\"))\n-        return(XSLT_FUNC_MESSAGE);\n+        if (IS_XSLT_NAME(node, \"message\"))\n+            return(XSLT_FUNC_MESSAGE);\n@@ -3854,4 +3850,4 @@\n-    if (IS_XSLT_NAME(node, \"number\"))\n-        return(XSLT_FUNC_NUMBER);\n-    else if (IS_XSLT_NAME(node, \"namespace-alias\"))\n-        return(0);\n+        if (IS_XSLT_NAME(node, \"number\"))\n+            return(XSLT_FUNC_NUMBER);\n+        else if (IS_XSLT_NAME(node, \"namespace-alias\"))\n+            return(0);\n@@ -3860,4 +3856,4 @@\n-    if (IS_XSLT_NAME(node, \"otherwise\"))\n-        return(XSLT_FUNC_OTHERWISE);\n-    else if (IS_XSLT_NAME(node, \"output\"))\n-        return(0);\n+        if (IS_XSLT_NAME(node, \"otherwise\"))\n+            return(XSLT_FUNC_OTHERWISE);\n+        else if (IS_XSLT_NAME(node, \"output\"))\n+            return(0);\n@@ -3866,6 +3862,6 @@\n-    if (IS_XSLT_NAME(node, \"param\"))\n-        return(XSLT_FUNC_PARAM);\n-    else if (IS_XSLT_NAME(node, \"processing-instruction\"))\n-        return(XSLT_FUNC_PI);\n-    else if (IS_XSLT_NAME(node, \"preserve-space\"))\n-        return(0);\n+        if (IS_XSLT_NAME(node, \"param\"))\n+            return(XSLT_FUNC_PARAM);\n+        else if (IS_XSLT_NAME(node, \"processing-instruction\"))\n+            return(XSLT_FUNC_PI);\n+        else if (IS_XSLT_NAME(node, \"preserve-space\"))\n+            return(0);\n@@ -3874,6 +3870,6 @@\n-    if (IS_XSLT_NAME(node, \"sort\"))\n-        return(XSLT_FUNC_SORT);\n-    else if (IS_XSLT_NAME(node, \"strip-space\"))\n-        return(0);\n-    else if (IS_XSLT_NAME(node, \"stylesheet\"))\n-        return(0);\n+        if (IS_XSLT_NAME(node, \"sort\"))\n+            return(XSLT_FUNC_SORT);\n+        else if (IS_XSLT_NAME(node, \"strip-space\"))\n+            return(0);\n+        else if (IS_XSLT_NAME(node, \"stylesheet\"))\n+            return(0);\n@@ -3882,6 +3878,6 @@\n-    if (IS_XSLT_NAME(node, \"text\"))\n-        return(XSLT_FUNC_TEXT);\n-    else if (IS_XSLT_NAME(node, \"template\"))\n-        return(0);\n-    else if (IS_XSLT_NAME(node, \"transform\"))\n-        return(0);\n+        if (IS_XSLT_NAME(node, \"text\"))\n+            return(XSLT_FUNC_TEXT);\n+        else if (IS_XSLT_NAME(node, \"template\"))\n+            return(0);\n+        else if (IS_XSLT_NAME(node, \"transform\"))\n+            return(0);\n@@ -3890,4 +3886,4 @@\n-    if (IS_XSLT_NAME(node, \"value-of\"))\n-        return(XSLT_FUNC_VALUEOF);\n-    else if (IS_XSLT_NAME(node, \"variable\"))\n-        return(XSLT_FUNC_VARIABLE);\n+        if (IS_XSLT_NAME(node, \"value-of\"))\n+            return(XSLT_FUNC_VALUEOF);\n+        else if (IS_XSLT_NAME(node, \"variable\"))\n+            return(XSLT_FUNC_VARIABLE);\n@@ -3896,4 +3892,4 @@\n-    if (IS_XSLT_NAME(node, \"when\"))\n-        return(XSLT_FUNC_WHEN);\n-    if (IS_XSLT_NAME(node, \"with-param\"))\n-        return(XSLT_FUNC_WITHPARAM);\n+        if (IS_XSLT_NAME(node, \"when\"))\n+            return(XSLT_FUNC_WHEN);\n+        if (IS_XSLT_NAME(node, \"with-param\"))\n+            return(XSLT_FUNC_WITHPARAM);\n@@ -3919,2 +3915,2 @@\n-    (elem->type != XML_ELEMENT_NODE))\n-    return(-1);\n+        (elem->type != XML_ELEMENT_NODE))\n+        return(-1);\n@@ -3925,1 +3921,1 @@\n-    return(-1);\n+        return(-1);\n@@ -3930,1 +3926,1 @@\n-    cctxt->inode->extContentHandled = 1;\n+        cctxt->inode->extContentHandled = 1;\n@@ -3939,1 +3935,1 @@\n-    cctxt->inode->type = cctxt->inode->prev->curChildType;\n+        cctxt->inode->type = cctxt->inode->prev->curChildType;\n@@ -3941,1 +3937,1 @@\n-    cctxt->inode->type = xsltGetXSLTElementTypeByNode(cctxt, elem);\n+        cctxt->inode->type = xsltGetXSLTElementTypeByNode(cctxt, elem);\n@@ -3946,2 +3942,2 @@\n-    cctxt->inode->inScopeNs =\n-        xsltCompilerBuildInScopeNsList(cctxt, elem);\n+        cctxt->inode->inScopeNs =\n+            xsltCompilerBuildInScopeNsList(cctxt, elem);\n@@ -3963,54 +3959,54 @@\n-    case XSLT_FUNC_APPLYIMPORTS:\n-        \/* EMPTY *\/\n-        goto empty_content;\n-    case XSLT_FUNC_APPLYTEMPLATES:\n-        \/* <!-- Content: (xsl:sort | xsl:with-param)* --> *\/\n-        goto apply_templates;\n-    case XSLT_FUNC_ATTRIBUTE:\n-        \/* <!-- Content: template --> *\/\n-        goto sequence_constructor;\n-    case XSLT_FUNC_CALLTEMPLATE:\n-        \/* <!-- Content: xsl:with-param* --> *\/\n-        goto call_template;\n-    case XSLT_FUNC_CHOOSE:\n-        \/* <!-- Content: (xsl:when+, xsl:otherwise?) --> *\/\n-        goto choose;\n-    case XSLT_FUNC_COMMENT:\n-        \/* <!-- Content: template --> *\/\n-        goto sequence_constructor;\n-    case XSLT_FUNC_COPY:\n-        \/* <!-- Content: template --> *\/\n-        goto sequence_constructor;\n-    case XSLT_FUNC_COPYOF:\n-        \/* EMPTY *\/\n-        goto empty_content;\n-    case XSLT_FUNC_DOCUMENT: \/* Extra one *\/\n-        \/* ?? template ?? *\/\n-        goto sequence_constructor;\n-    case XSLT_FUNC_ELEMENT:\n-        \/* <!-- Content: template --> *\/\n-        goto sequence_constructor;\n-    case XSLT_FUNC_FALLBACK:\n-        \/* <!-- Content: template --> *\/\n-        goto sequence_constructor;\n-    case XSLT_FUNC_FOREACH:\n-        \/* <!-- Content: (xsl:sort*, template) --> *\/\n-        goto for_each;\n-    case XSLT_FUNC_IF:\n-        \/* <!-- Content: template --> *\/\n-        goto sequence_constructor;\n-    case XSLT_FUNC_OTHERWISE:\n-        \/* <!-- Content: template --> *\/\n-        goto sequence_constructor;\n-    case XSLT_FUNC_MESSAGE:\n-        \/* <!-- Content: template --> *\/\n-        goto sequence_constructor;\n-    case XSLT_FUNC_NUMBER:\n-        \/* EMPTY *\/\n-        goto empty_content;\n-    case XSLT_FUNC_PARAM:\n-        \/*\n-        * Check for redefinition.\n-        *\/\n-        if ((elem->psvi != NULL) && (cctxt->ivar != NULL)) {\n-        xsltVarInfoPtr ivar = cctxt->ivar;\n+        case XSLT_FUNC_APPLYIMPORTS:\n+            \/* EMPTY *\/\n+            goto empty_content;\n+        case XSLT_FUNC_APPLYTEMPLATES:\n+            \/* <!-- Content: (xsl:sort | xsl:with-param)* --> *\/\n+            goto apply_templates;\n+        case XSLT_FUNC_ATTRIBUTE:\n+            \/* <!-- Content: template --> *\/\n+            goto sequence_constructor;\n+        case XSLT_FUNC_CALLTEMPLATE:\n+            \/* <!-- Content: xsl:with-param* --> *\/\n+            goto call_template;\n+        case XSLT_FUNC_CHOOSE:\n+            \/* <!-- Content: (xsl:when+, xsl:otherwise?) --> *\/\n+            goto choose;\n+        case XSLT_FUNC_COMMENT:\n+            \/* <!-- Content: template --> *\/\n+            goto sequence_constructor;\n+        case XSLT_FUNC_COPY:\n+            \/* <!-- Content: template --> *\/\n+            goto sequence_constructor;\n+        case XSLT_FUNC_COPYOF:\n+            \/* EMPTY *\/\n+            goto empty_content;\n+        case XSLT_FUNC_DOCUMENT: \/* Extra one *\/\n+            \/* ?? template ?? *\/\n+            goto sequence_constructor;\n+        case XSLT_FUNC_ELEMENT:\n+            \/* <!-- Content: template --> *\/\n+            goto sequence_constructor;\n+        case XSLT_FUNC_FALLBACK:\n+            \/* <!-- Content: template --> *\/\n+            goto sequence_constructor;\n+        case XSLT_FUNC_FOREACH:\n+            \/* <!-- Content: (xsl:sort*, template) --> *\/\n+            goto for_each;\n+        case XSLT_FUNC_IF:\n+            \/* <!-- Content: template --> *\/\n+            goto sequence_constructor;\n+        case XSLT_FUNC_OTHERWISE:\n+            \/* <!-- Content: template --> *\/\n+            goto sequence_constructor;\n+        case XSLT_FUNC_MESSAGE:\n+            \/* <!-- Content: template --> *\/\n+            goto sequence_constructor;\n+        case XSLT_FUNC_NUMBER:\n+            \/* EMPTY *\/\n+            goto empty_content;\n+        case XSLT_FUNC_PARAM:\n+            \/*\n+            * Check for redefinition.\n+            *\/\n+            if ((elem->psvi != NULL) && (cctxt->ivar != NULL)) {\n+                xsltVarInfoPtr ivar = cctxt->ivar;\n@@ -4018,12 +4014,15 @@\n-        do {\n-            if ((ivar->name ==\n-             ((xsltStyleItemParamPtr) elem->psvi)->name) &&\n-            (ivar->nsName ==\n-             ((xsltStyleItemParamPtr) elem->psvi)->ns))\n-            {\n-            elem->psvi = NULL;\n-            xsltTransformError(NULL, cctxt->style, elem,\n-                \"Redefinition of variable or parameter '%s'.\\n\",\n-                ivar->name);\n-            cctxt->style->errors++;\n-            goto error;\n+                do {\n+                    if ((ivar->name ==\n+                         ((xsltStyleItemParamPtr) elem->psvi)->name) &&\n+                        (ivar->nsName ==\n+                         ((xsltStyleItemParamPtr) elem->psvi)->ns))\n+                    {\n+                        elem->psvi = NULL;\n+                        xsltTransformError(NULL, cctxt->style, elem,\n+                            \"Redefinition of variable or parameter '%s'.\\n\",\n+                            ivar->name);\n+                        cctxt->style->errors++;\n+                        goto error;\n+                    }\n+                    ivar = ivar->prev;\n+                } while (ivar != NULL);\n@@ -4031,23 +4030,20 @@\n-            ivar = ivar->prev;\n-        } while (ivar != NULL);\n-        }\n-        \/*  <!-- Content: template --> *\/\n-        goto sequence_constructor;\n-    case XSLT_FUNC_PI:\n-        \/*  <!-- Content: template --> *\/\n-        goto sequence_constructor;\n-    case XSLT_FUNC_SORT:\n-        \/* EMPTY *\/\n-        goto empty_content;\n-    case XSLT_FUNC_TEXT:\n-        \/* <!-- Content: #PCDATA --> *\/\n-        goto text;\n-    case XSLT_FUNC_VALUEOF:\n-        \/* EMPTY *\/\n-        goto empty_content;\n-    case XSLT_FUNC_VARIABLE:\n-        \/*\n-        * Check for redefinition.\n-        *\/\n-        if ((elem->psvi != NULL) && (cctxt->ivar != NULL)) {\n-        xsltVarInfoPtr ivar = cctxt->ivar;\n+            \/*  <!-- Content: template --> *\/\n+            goto sequence_constructor;\n+        case XSLT_FUNC_PI:\n+            \/*  <!-- Content: template --> *\/\n+            goto sequence_constructor;\n+        case XSLT_FUNC_SORT:\n+            \/* EMPTY *\/\n+            goto empty_content;\n+        case XSLT_FUNC_TEXT:\n+            \/* <!-- Content: #PCDATA --> *\/\n+            goto text;\n+        case XSLT_FUNC_VALUEOF:\n+            \/* EMPTY *\/\n+            goto empty_content;\n+        case XSLT_FUNC_VARIABLE:\n+            \/*\n+            * Check for redefinition.\n+            *\/\n+            if ((elem->psvi != NULL) && (cctxt->ivar != NULL)) {\n+                xsltVarInfoPtr ivar = cctxt->ivar;\n@@ -4055,12 +4051,15 @@\n-        do {\n-            if ((ivar->name ==\n-             ((xsltStyleItemVariablePtr) elem->psvi)->name) &&\n-            (ivar->nsName ==\n-             ((xsltStyleItemVariablePtr) elem->psvi)->ns))\n-            {\n-            elem->psvi = NULL;\n-            xsltTransformError(NULL, cctxt->style, elem,\n-                \"Redefinition of variable or parameter '%s'.\\n\",\n-                ivar->name);\n-            cctxt->style->errors++;\n-            goto error;\n+                do {\n+                    if ((ivar->name ==\n+                         ((xsltStyleItemVariablePtr) elem->psvi)->name) &&\n+                        (ivar->nsName ==\n+                         ((xsltStyleItemVariablePtr) elem->psvi)->ns))\n+                    {\n+                        elem->psvi = NULL;\n+                        xsltTransformError(NULL, cctxt->style, elem,\n+                            \"Redefinition of variable or parameter '%s'.\\n\",\n+                            ivar->name);\n+                        cctxt->style->errors++;\n+                        goto error;\n+                    }\n+                    ivar = ivar->prev;\n+                } while (ivar != NULL);\n@@ -4068,12 +4067,9 @@\n-            ivar = ivar->prev;\n-        } while (ivar != NULL);\n-        }\n-        \/* <!-- Content: template --> *\/\n-        goto sequence_constructor;\n-    case XSLT_FUNC_WHEN:\n-        \/* <!-- Content: template --> *\/\n-        goto sequence_constructor;\n-    case XSLT_FUNC_WITHPARAM:\n-        \/* <!-- Content: template --> *\/\n-        goto sequence_constructor;\n-    default:\n+            \/* <!-- Content: template --> *\/\n+            goto sequence_constructor;\n+        case XSLT_FUNC_WHEN:\n+            \/* <!-- Content: template --> *\/\n+            goto sequence_constructor;\n+        case XSLT_FUNC_WITHPARAM:\n+            \/* <!-- Content: template --> *\/\n+            goto sequence_constructor;\n+        default:\n@@ -4081,3 +4077,3 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-        \"xsltParseXSLTNode: Unhandled XSLT element '%s'.\\n\",\n-        elem->name);\n+            xsltGenericDebug(xsltGenericDebugContext,\n+                \"xsltParseXSLTNode: Unhandled XSLT element '%s'.\\n\",\n+                elem->name);\n@@ -4085,5 +4081,5 @@\n-        xsltTransformError(NULL, cctxt->style, elem,\n-        \"xsltParseXSLTNode: Internal error; \"\n-        \"unhandled XSLT element '%s'.\\n\", elem->name);\n-        cctxt->style->errors++;\n-        goto internal_err;\n+            xsltTransformError(NULL, cctxt->style, elem,\n+                \"xsltParseXSLTNode: Internal error; \"\n+                \"unhandled XSLT element '%s'.\\n\", elem->name);\n+            cctxt->style->errors++;\n+            goto internal_err;\n@@ -4095,17 +4091,17 @@\n-    xmlNodePtr child = elem->children;\n-    do {\n-        if (child->type == XML_ELEMENT_NODE) {\n-        if (IS_XSLT_ELEM_FAST(child)) {\n-            if (xmlStrEqual(child->name, BAD_CAST \"with-param\")) {\n-            cctxt->inode->curChildType = XSLT_FUNC_WITHPARAM;\n-            xsltParseAnyXSLTElem(cctxt, child);\n-            } else if (xmlStrEqual(child->name, BAD_CAST \"sort\")) {\n-            cctxt->inode->curChildType = XSLT_FUNC_SORT;\n-            xsltParseAnyXSLTElem(cctxt, child);\n-            } else\n-            xsltParseContentError(cctxt->style, child);\n-        } else\n-            xsltParseContentError(cctxt->style, child);\n-        }\n-        child = child->next;\n-    } while (child != NULL);\n+        xmlNodePtr child = elem->children;\n+        do {\n+            if (child->type == XML_ELEMENT_NODE) {\n+                if (IS_XSLT_ELEM_FAST(child)) {\n+                    if (xmlStrEqual(child->name, BAD_CAST \"with-param\")) {\n+                        cctxt->inode->curChildType = XSLT_FUNC_WITHPARAM;\n+                        xsltParseAnyXSLTElem(cctxt, child);\n+                    } else if (xmlStrEqual(child->name, BAD_CAST \"sort\")) {\n+                        cctxt->inode->curChildType = XSLT_FUNC_SORT;\n+                        xsltParseAnyXSLTElem(cctxt, child);\n+                    } else\n+                        xsltParseContentError(cctxt->style, child);\n+                } else\n+                    xsltParseContentError(cctxt->style, child);\n+            }\n+            child = child->next;\n+        } while (child != NULL);\n@@ -4118,12 +4114,15 @@\n-    xmlNodePtr child = elem->children;\n-    do {\n-        if (child->type == XML_ELEMENT_NODE) {\n-        if (IS_XSLT_ELEM_FAST(child)) {\n-            xsltStyleType type;\n-\n-            type = xsltGetXSLTElementTypeByNode(cctxt, child);\n-            if (type == XSLT_FUNC_WITHPARAM) {\n-            cctxt->inode->curChildType = XSLT_FUNC_WITHPARAM;\n-            xsltParseAnyXSLTElem(cctxt, child);\n-            } else {\n-            xsltParseContentError(cctxt->style, child);\n+        xmlNodePtr child = elem->children;\n+        do {\n+            if (child->type == XML_ELEMENT_NODE) {\n+                if (IS_XSLT_ELEM_FAST(child)) {\n+                    xsltStyleType type;\n+\n+                    type = xsltGetXSLTElementTypeByNode(cctxt, child);\n+                    if (type == XSLT_FUNC_WITHPARAM) {\n+                        cctxt->inode->curChildType = XSLT_FUNC_WITHPARAM;\n+                        xsltParseAnyXSLTElem(cctxt, child);\n+                    } else {\n+                        xsltParseContentError(cctxt->style, child);\n+                    }\n+                } else\n+                    xsltParseContentError(cctxt->style, child);\n@@ -4131,5 +4130,2 @@\n-        } else\n-            xsltParseContentError(cctxt->style, child);\n-        }\n-        child = child->next;\n-    } while (child != NULL);\n+            child = child->next;\n+        } while (child != NULL);\n@@ -4141,11 +4137,11 @@\n-    xmlNodePtr child = elem->children;\n-    do {\n-        if ((child->type != XML_TEXT_NODE) &&\n-        (child->type != XML_CDATA_SECTION_NODE))\n-        {\n-        xsltTransformError(NULL, cctxt->style, elem,\n-            \"The XSLT 'text' element must have only character \"\n-            \"data as content.\\n\");\n-        }\n-        child = child->next;\n-    } while (child != NULL);\n+        xmlNodePtr child = elem->children;\n+        do {\n+            if ((child->type != XML_TEXT_NODE) &&\n+                (child->type != XML_CDATA_SECTION_NODE))\n+            {\n+                xsltTransformError(NULL, cctxt->style, elem,\n+                    \"The XSLT 'text' element must have only character \"\n+                    \"data as content.\\n\");\n+            }\n+            child = child->next;\n+        } while (child != NULL);\n@@ -4157,16 +4153,16 @@\n-    xmlNodePtr child = elem->children;\n-    \/*\n-    * Relaxed behaviour: we will allow whitespace-only text-nodes.\n-    *\/\n-    do {\n-        if (((child->type != XML_TEXT_NODE) &&\n-         (child->type != XML_CDATA_SECTION_NODE)) ||\n-        (! IS_BLANK_NODE(child)))\n-        {\n-        xsltTransformError(NULL, cctxt->style, elem,\n-            \"This XSLT element must have no content.\\n\");\n-        cctxt->style->errors++;\n-        break;\n-        }\n-        child = child->next;\n-    } while (child != NULL);\n+        xmlNodePtr child = elem->children;\n+        \/*\n+        * Relaxed behaviour: we will allow whitespace-only text-nodes.\n+        *\/\n+        do {\n+            if (((child->type != XML_TEXT_NODE) &&\n+                 (child->type != XML_CDATA_SECTION_NODE)) ||\n+                (! IS_BLANK_NODE(child)))\n+            {\n+                xsltTransformError(NULL, cctxt->style, elem,\n+                    \"This XSLT element must have no content.\\n\");\n+                cctxt->style->errors++;\n+                break;\n+            }\n+            child = child->next;\n+        } while (child != NULL);\n@@ -4185,22 +4181,38 @@\n-    xmlNodePtr child = elem->children;\n-    int nbWhen = 0, nbOtherwise = 0, err = 0;\n-    do {\n-        if (child->type == XML_ELEMENT_NODE) {\n-        if (IS_XSLT_ELEM_FAST(child)) {\n-            xsltStyleType type;\n-\n-            type = xsltGetXSLTElementTypeByNode(cctxt, child);\n-            if (type == XSLT_FUNC_WHEN) {\n-            nbWhen++;\n-            if (nbOtherwise) {\n-                xsltParseContentError(cctxt->style, child);\n-                err = 1;\n-                break;\n-            }\n-            cctxt->inode->curChildType = XSLT_FUNC_WHEN;\n-            xsltParseAnyXSLTElem(cctxt, child);\n-            } else if (type == XSLT_FUNC_OTHERWISE) {\n-            if (! nbWhen) {\n-                xsltParseContentError(cctxt->style, child);\n-                err = 1;\n-                break;\n+        xmlNodePtr child = elem->children;\n+        int nbWhen = 0, nbOtherwise = 0, err = 0;\n+        do {\n+            if (child->type == XML_ELEMENT_NODE) {\n+                if (IS_XSLT_ELEM_FAST(child)) {\n+                    xsltStyleType type;\n+\n+                    type = xsltGetXSLTElementTypeByNode(cctxt, child);\n+                    if (type == XSLT_FUNC_WHEN) {\n+                        nbWhen++;\n+                        if (nbOtherwise) {\n+                            xsltParseContentError(cctxt->style, child);\n+                            err = 1;\n+                            break;\n+                        }\n+                        cctxt->inode->curChildType = XSLT_FUNC_WHEN;\n+                        xsltParseAnyXSLTElem(cctxt, child);\n+                    } else if (type == XSLT_FUNC_OTHERWISE) {\n+                        if (! nbWhen) {\n+                            xsltParseContentError(cctxt->style, child);\n+                            err = 1;\n+                            break;\n+                        }\n+                        if (nbOtherwise) {\n+                            xsltTransformError(NULL, cctxt->style, elem,\n+                                \"The XSLT 'choose' element must not contain \"\n+                                \"more than one XSLT 'otherwise' element.\\n\");\n+                            cctxt->style->errors++;\n+                            err = 1;\n+                            break;\n+                        }\n+                        nbOtherwise++;\n+                        cctxt->inode->curChildType = XSLT_FUNC_OTHERWISE;\n+                        xsltParseAnyXSLTElem(cctxt, child);\n+                    } else\n+                        xsltParseContentError(cctxt->style, child);\n+                } else\n+                    xsltParseContentError(cctxt->style, child);\n@@ -4208,4 +4220,10 @@\n-            if (nbOtherwise) {\n-                xsltTransformError(NULL, cctxt->style, elem,\n-                \"The XSLT 'choose' element must not contain \"\n-                \"more than one XSLT 'otherwise' element.\\n\");\n+            \/*\n+                else\n+                    xsltParseContentError(cctxt, child);\n+            *\/\n+            child = child->next;\n+        } while (child != NULL);\n+        if ((! err) && (! nbWhen)) {\n+            xsltTransformError(NULL, cctxt->style, elem,\n+                \"The XSLT element 'choose' must contain at least one \"\n+                \"XSLT element 'when'.\\n\");\n@@ -4213,10 +4231,0 @@\n-                err = 1;\n-                break;\n-            }\n-            nbOtherwise++;\n-            cctxt->inode->curChildType = XSLT_FUNC_OTHERWISE;\n-            xsltParseAnyXSLTElem(cctxt, child);\n-            } else\n-            xsltParseContentError(cctxt->style, child);\n-        } else\n-            xsltParseContentError(cctxt->style, child);\n@@ -4224,12 +4232,0 @@\n-        \/*\n-        else\n-            xsltParseContentError(cctxt, child);\n-        *\/\n-        child = child->next;\n-    } while (child != NULL);\n-    if ((! err) && (! nbWhen)) {\n-        xsltTransformError(NULL, cctxt->style, elem,\n-        \"The XSLT element 'choose' must contain at least one \"\n-        \"XSLT element 'when'.\\n\");\n-        cctxt->style->errors++;\n-    }\n@@ -4249,24 +4245,24 @@\n-    xmlNodePtr child = elem->children;\n-    \/*\n-    * Parse xsl:sort first.\n-    *\/\n-    do {\n-        if ((child->type == XML_ELEMENT_NODE) &&\n-        IS_XSLT_ELEM_FAST(child))\n-        {\n-        if (xsltGetXSLTElementTypeByNode(cctxt, child) ==\n-            XSLT_FUNC_SORT)\n-        {\n-            cctxt->inode->curChildType = XSLT_FUNC_SORT;\n-            xsltParseAnyXSLTElem(cctxt, child);\n-        } else\n-            break;\n-        } else\n-        break;\n-        child = child->next;\n-    } while (child != NULL);\n-    \/*\n-    * Parse the sequece constructor.\n-    *\/\n-    if (child != NULL)\n-        xsltParseSequenceConstructor(cctxt, child);\n+        xmlNodePtr child = elem->children;\n+        \/*\n+        * Parse xsl:sort first.\n+        *\/\n+        do {\n+            if ((child->type == XML_ELEMENT_NODE) &&\n+                IS_XSLT_ELEM_FAST(child))\n+            {\n+                if (xsltGetXSLTElementTypeByNode(cctxt, child) ==\n+                    XSLT_FUNC_SORT)\n+                {\n+                    cctxt->inode->curChildType = XSLT_FUNC_SORT;\n+                    xsltParseAnyXSLTElem(cctxt, child);\n+                } else\n+                    break;\n+            } else\n+                break;\n+            child = child->next;\n+        } while (child != NULL);\n+        \/*\n+        * Parse the sequece constructor.\n+        *\/\n+        if (child != NULL)\n+            xsltParseSequenceConstructor(cctxt, child);\n@@ -4281,1 +4277,1 @@\n-    xsltParseSequenceConstructor(cctxt, elem->children);\n+        xsltParseSequenceConstructor(cctxt, elem->children);\n@@ -4288,2 +4284,2 @@\n-    ((cctxt->inode->type == XSLT_FUNC_VARIABLE) ||\n-     (cctxt->inode->type == XSLT_FUNC_PARAM)))\n+        ((cctxt->inode->type == XSLT_FUNC_VARIABLE) ||\n+         (cctxt->inode->type == XSLT_FUNC_PARAM)))\n@@ -4291,7 +4287,7 @@\n-    if ((elem->psvi != NULL) &&\n-        (((xsltStyleBasicItemVariablePtr) elem->psvi)->name))\n-    {\n-        xsltCompilerVarInfoPush(cctxt, elem,\n-        ((xsltStyleBasicItemVariablePtr) elem->psvi)->name,\n-        ((xsltStyleBasicItemVariablePtr) elem->psvi)->ns);\n-    }\n+        if ((elem->psvi != NULL) &&\n+            (((xsltStyleBasicItemVariablePtr) elem->psvi)->name))\n+        {\n+            xsltCompilerVarInfoPush(cctxt, elem,\n+                ((xsltStyleBasicItemVariablePtr) elem->psvi)->name,\n+                ((xsltStyleBasicItemVariablePtr) elem->psvi)->ns);\n+        }\n@@ -4327,5 +4323,5 @@\n-    xsltTransformError(NULL, cctxt->style, NULL,\n-        \"Internal error in xsltForwardsCompatUnkownItemCreate(): \"\n-        \"Failed to allocate memory.\\n\");\n-    cctxt->style->errors++;\n-    return(NULL);\n+        xsltTransformError(NULL, cctxt->style, NULL,\n+            \"Internal error in xsltForwardsCompatUnkownItemCreate(): \"\n+            \"Failed to allocate memory.\\n\");\n+        cctxt->style->errors++;\n+        return(NULL);\n@@ -4359,1 +4355,1 @@\n-                xmlNodePtr node)\n+                            xmlNodePtr node)\n@@ -4362,1 +4358,1 @@\n-    return(-1);\n+        return(-1);\n@@ -4368,1 +4364,1 @@\n-    cctxt->inode->extContentHandled = 1;\n+        cctxt->inode->extContentHandled = 1;\n@@ -4371,7 +4367,7 @@\n-    \/*\n-    * We are not in forwards-compatible mode, so raise an error.\n-    *\/\n-    xsltTransformError(NULL, cctxt->style, node,\n-        \"Unknown XSLT element '%s'.\\n\", node->name);\n-    cctxt->style->errors++;\n-    return(1);\n+        \/*\n+        * We are not in forwards-compatible mode, so raise an error.\n+        *\/\n+        xsltTransformError(NULL, cctxt->style, node,\n+            \"Unknown XSLT element '%s'.\\n\", node->name);\n+        cctxt->style->errors++;\n+        return(1);\n@@ -4390,8 +4386,8 @@\n-    \/*\n-    * Create a singleton for all unknown XSLT instructions.\n-    *\/\n-    cctxt->unknownItem = xsltForwardsCompatUnkownItemCreate(cctxt);\n-    if (cctxt->unknownItem == NULL) {\n-        node->psvi = NULL;\n-        return(-1);\n-    }\n+        \/*\n+        * Create a singleton for all unknown XSLT instructions.\n+        *\/\n+        cctxt->unknownItem = xsltForwardsCompatUnkownItemCreate(cctxt);\n+        if (cctxt->unknownItem == NULL) {\n+            node->psvi = NULL;\n+            return(-1);\n+        }\n@@ -4401,1 +4397,1 @@\n-    return(0);\n+        return(0);\n@@ -4403,1 +4399,1 @@\n-    xmlNodePtr child = node->children;\n+        xmlNodePtr child = node->children;\n@@ -4405,20 +4401,20 @@\n-    xsltCompilerNodePush(cctxt, node);\n-    \/*\n-    * Update the in-scope namespaces if needed.\n-    *\/\n-    if (node->nsDef != NULL)\n-        cctxt->inode->inScopeNs =\n-        xsltCompilerBuildInScopeNsList(cctxt, node);\n-    \/*\n-    * Parse all xsl:fallback children.\n-    *\/\n-    do {\n-        if ((child->type == XML_ELEMENT_NODE) &&\n-        IS_XSLT_ELEM_FAST(child) &&\n-        IS_XSLT_NAME(child, \"fallback\"))\n-        {\n-        cctxt->inode->curChildType = XSLT_FUNC_FALLBACK;\n-        xsltParseAnyXSLTElem(cctxt, child);\n-        }\n-        child = child->next;\n-    } while (child != NULL);\n+        xsltCompilerNodePush(cctxt, node);\n+        \/*\n+        * Update the in-scope namespaces if needed.\n+        *\/\n+        if (node->nsDef != NULL)\n+            cctxt->inode->inScopeNs =\n+                xsltCompilerBuildInScopeNsList(cctxt, node);\n+        \/*\n+        * Parse all xsl:fallback children.\n+        *\/\n+        do {\n+            if ((child->type == XML_ELEMENT_NODE) &&\n+                IS_XSLT_ELEM_FAST(child) &&\n+                IS_XSLT_NAME(child, \"fallback\"))\n+            {\n+                cctxt->inode->curChildType = XSLT_FUNC_FALLBACK;\n+                xsltParseAnyXSLTElem(cctxt, child);\n+            }\n+            child = child->next;\n+        } while (child != NULL);\n@@ -4426,1 +4422,1 @@\n-    xsltCompilerNodePop(cctxt, node);\n+        xsltCompilerNodePop(cctxt, node);\n@@ -4447,4 +4443,4 @@\n-    xmlGenericError(xmlGenericErrorContext,\n-        \"xsltParseSequenceConstructor: Bad arguments\\n\");\n-    cctxt->style->errors++;\n-    return;\n+        xmlGenericError(xmlGenericErrorContext,\n+            \"xsltParseSequenceConstructor: Bad arguments\\n\");\n+        cctxt->style->errors++;\n+        return;\n@@ -4456,1 +4452,1 @@\n-    cctxt->inode->extContentHandled = 1;\n+        cctxt->inode->extContentHandled = 1;\n@@ -4459,1 +4455,1 @@\n-    return;\n+        return;\n@@ -4488,1 +4484,1 @@\n-    if (deleteNode != NULL) {\n+        if (deleteNode != NULL) {\n@@ -4490,2 +4486,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltParseSequenceConstructor: removing xsl:text element\\n\");\n+            xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltParseSequenceConstructor: removing xsl:text element\\n\");\n@@ -4493,5 +4489,5 @@\n-        xmlUnlinkNode(deleteNode);\n-        xmlFreeNode(deleteNode);\n-        deleteNode = NULL;\n-    }\n-    if (cur->type == XML_ELEMENT_NODE) {\n+            xmlUnlinkNode(deleteNode);\n+            xmlFreeNode(deleteNode);\n+            deleteNode = NULL;\n+        }\n+        if (cur->type == XML_ELEMENT_NODE) {\n@@ -4499,6 +4495,6 @@\n-        if (cur->psvi == xsltXSLTTextMarker) {\n-        \/*\n-        * xsl:text elements\n-        * --------------------------------------------------------\n-        *\/\n-        xmlNodePtr tmp;\n+            if (cur->psvi == xsltXSLTTextMarker) {\n+                \/*\n+                * xsl:text elements\n+                * --------------------------------------------------------\n+                *\/\n+                xmlNodePtr tmp;\n@@ -4506,45 +4502,1 @@\n-        cur->psvi = NULL;\n-        \/*\n-        * Mark the xsl:text element for later deletion.\n-        *\/\n-        deleteNode = cur;\n-        \/*\n-        * Validate content.\n-        *\/\n-        tmp = cur->children;\n-        if (tmp) {\n-            \/*\n-            * We don't expect more than one text-node in the\n-            * content, since we already merged adjacent\n-            * text\/CDATA-nodes and eliminated PI\/comment-nodes.\n-            *\/\n-            if ((tmp->type == XML_TEXT_NODE) ||\n-            (tmp->next == NULL))\n-            {\n-            \/*\n-            * Leave the contained text-node in the tree.\n-            *\/\n-            xmlUnlinkNode(tmp);\n-            xmlAddPrevSibling(cur, tmp);\n-            } else {\n-            tmp = NULL;\n-            xsltTransformError(NULL, cctxt->style, cur,\n-                \"Element 'xsl:text': Invalid type \"\n-                \"of node found in content.\\n\");\n-            cctxt->style->errors++;\n-            }\n-        }\n-        if (cur->properties) {\n-            xmlAttrPtr attr;\n-            \/*\n-            * TODO: We need to report errors for\n-            *  invalid attrs.\n-            *\/\n-            attr = cur->properties;\n-            do {\n-            if ((attr->ns == NULL) &&\n-                (attr->name != NULL) &&\n-                (attr->name[0] == 'd') &&\n-                xmlStrEqual(attr->name,\n-                BAD_CAST \"disable-output-escaping\"))\n-            {\n+                cur->psvi = NULL;\n@@ -4552,2 +4504,1 @@\n-                * Attr \"disable-output-escaping\".\n-                * XSLT-2: This attribute is deprecated.\n+                * Mark the xsl:text element for later deletion.\n@@ -4555,4 +4506,1 @@\n-                if ((attr->children != NULL) &&\n-                xmlStrEqual(attr->children->content,\n-                BAD_CAST \"yes\"))\n-                {\n+                deleteNode = cur;\n@@ -4560,2 +4508,1 @@\n-                * Disable output escaping for this\n-                * text node.\n+                * Validate content.\n@@ -4563,13 +4510,22 @@\n-                if (tmp)\n-                    tmp->name = xmlStringTextNoenc;\n-                } else if ((attr->children == NULL) ||\n-                (attr->children->content == NULL) ||\n-                (!xmlStrEqual(attr->children->content,\n-                BAD_CAST \"no\")))\n-                {\n-                xsltTransformError(NULL, cctxt->style,\n-                    cur,\n-                    \"Attribute 'disable-output-escaping': \"\n-                    \"Invalid value. Expected is \"\n-                    \"'yes' or 'no'.\\n\");\n-                cctxt->style->errors++;\n+                tmp = cur->children;\n+                if (tmp) {\n+                    \/*\n+                    * We don't expect more than one text-node in the\n+                    * content, since we already merged adjacent\n+                    * text\/CDATA-nodes and eliminated PI\/comment-nodes.\n+                    *\/\n+                    if ((tmp->type == XML_TEXT_NODE) ||\n+                        (tmp->next == NULL))\n+                    {\n+                        \/*\n+                        * Leave the contained text-node in the tree.\n+                        *\/\n+                        xmlUnlinkNode(tmp);\n+                        xmlAddPrevSibling(cur, tmp);\n+                    } else {\n+                        tmp = NULL;\n+                        xsltTransformError(NULL, cctxt->style, cur,\n+                            \"Element 'xsl:text': Invalid type \"\n+                            \"of node found in content.\\n\");\n+                        cctxt->style->errors++;\n+                    }\n@@ -4577,212 +4533,2 @@\n-                break;\n-            }\n-            attr = attr->next;\n-            } while (attr != NULL);\n-        }\n-        } else if (IS_XSLT_ELEM_FAST(cur)) {\n-        \/*\n-        * TODO: Using the XSLT-marker is still not stable yet.\n-        *\/\n-        \/* if (cur->psvi == xsltXSLTElemMarker) { *\/\n-        \/*\n-        * XSLT instructions\n-        * --------------------------------------------------------\n-        *\/\n-        cur->psvi = NULL;\n-        type = xsltGetXSLTElementTypeByNode(cctxt, cur);\n-        switch (type) {\n-            case XSLT_FUNC_APPLYIMPORTS:\n-            case XSLT_FUNC_APPLYTEMPLATES:\n-            case XSLT_FUNC_ATTRIBUTE:\n-            case XSLT_FUNC_CALLTEMPLATE:\n-            case XSLT_FUNC_CHOOSE:\n-            case XSLT_FUNC_COMMENT:\n-            case XSLT_FUNC_COPY:\n-            case XSLT_FUNC_COPYOF:\n-            case XSLT_FUNC_DOCUMENT: \/* Extra one *\/\n-            case XSLT_FUNC_ELEMENT:\n-            case XSLT_FUNC_FALLBACK:\n-            case XSLT_FUNC_FOREACH:\n-            case XSLT_FUNC_IF:\n-            case XSLT_FUNC_MESSAGE:\n-            case XSLT_FUNC_NUMBER:\n-            case XSLT_FUNC_PI:\n-            case XSLT_FUNC_TEXT:\n-            case XSLT_FUNC_VALUEOF:\n-            case XSLT_FUNC_VARIABLE:\n-            \/*\n-            * Parse the XSLT element.\n-            *\/\n-            cctxt->inode->curChildType = type;\n-            xsltParseAnyXSLTElem(cctxt, cur);\n-            break;\n-            default:\n-            xsltParseUnknownXSLTElem(cctxt, cur);\n-            cur = cur->next;\n-            continue;\n-        }\n-        } else {\n-        \/*\n-        * Non-XSLT elements\n-        * -----------------\n-        *\/\n-        xsltCompilerNodePush(cctxt, cur);\n-        \/*\n-        * Update the in-scope namespaces if needed.\n-        *\/\n-        if (cur->nsDef != NULL)\n-            cctxt->inode->inScopeNs =\n-            xsltCompilerBuildInScopeNsList(cctxt, cur);\n-        \/*\n-        * The current element is either a literal result element\n-        * or an extension instruction.\n-        *\n-        * Process attr \"xsl:extension-element-prefixes\".\n-        * FUTURE TODO: IIRC in XSLT 2.0 this attribute must be\n-        * processed by the implementor of the extension function;\n-        * i.e., it won't be handled by the XSLT processor.\n-        *\/\n-        \/* SPEC 1.0:\n-        *   \"exclude-result-prefixes\" is only allowed on literal\n-        *   result elements and \"xsl:exclude-result-prefixes\"\n-        *   on xsl:stylesheet\/xsl:transform.\n-        * SPEC 2.0:\n-        *   \"There are a number of standard attributes\n-        *   that may appear on any XSLT element: specifically\n-        *   version, exclude-result-prefixes,\n-        *   extension-element-prefixes, xpath-default-namespace,\n-        *   default-collation, and use-when.\"\n-        *\n-        * SPEC 2.0:\n-        *   For literal result elements:\n-        *   \"xsl:version, xsl:exclude-result-prefixes,\n-        *    xsl:extension-element-prefixes,\n-        *    xsl:xpath-default-namespace,\n-        *    xsl:default-collation, or xsl:use-when.\"\n-        *\/\n-        if (cur->properties)\n-            cctxt->inode->extElemNs =\n-            xsltParseExtElemPrefixes(cctxt,\n-                cur, cctxt->inode->extElemNs,\n-                XSLT_ELEMENT_CATEGORY_LRE);\n-        \/*\n-        * Eval if we have an extension instruction here.\n-        *\/\n-        if ((cur->ns != NULL) &&\n-            (cctxt->inode->extElemNs != NULL) &&\n-            (xsltCheckExtPrefix(cctxt->style, cur->ns->href) == 1))\n-        {\n-            \/*\n-            * Extension instructions\n-            * ----------------------------------------------------\n-            * Mark the node information.\n-            *\/\n-            cctxt->inode->category = XSLT_ELEMENT_CATEGORY_EXTENSION;\n-            cctxt->inode->extContentHandled = 0;\n-            if (cur->psvi != NULL) {\n-            cur->psvi = NULL;\n-            \/*\n-            * TODO: Temporary sanity check.\n-            *\/\n-            xsltTransformError(NULL, cctxt->style, cur,\n-                \"Internal error in xsltParseSequenceConstructor(): \"\n-                \"Occupied PSVI field.\\n\");\n-            cctxt->style->errors++;\n-            cur = cur->next;\n-            continue;\n-            }\n-            cur->psvi = (void *)\n-            xsltPreComputeExtModuleElement(cctxt->style, cur);\n-\n-            if (cur->psvi == NULL) {\n-            \/*\n-            * OLD COMMENT: \"Unknown element, maybe registered\n-            *  at the context level. Mark it for later\n-            *  recognition.\"\n-            * QUESTION: What does the xsltExtMarker mean?\n-            *  ANSWER: It is used in\n-            *   xsltApplySequenceConstructor() at\n-            *   transformation-time to look out for extension\n-            *   registered in the transformation context.\n-            *\/\n-            cur->psvi = (void *) xsltExtMarker;\n-            }\n-            \/*\n-            * BIG NOTE: Now the ugly part. In previous versions\n-            *  of Libxslt (until 1.1.16), all the content of an\n-            *  extension instruction was processed and compiled without\n-            *  the need of the extension-author to explicitely call\n-            *  such a processing;.We now need to mimic this old\n-            *  behaviour in order to avoid breaking old code\n-            *  on the extension-author's side.\n-            * The mechanism:\n-            *  1) If the author does *not* set the\n-            *    compile-time-flag @extContentHandled, then we'll\n-            *    parse the content assuming that it's a \"template\"\n-            *    (or \"sequence constructor in XSLT 2.0 terms).\n-            *    NOTE: If the extension is registered at\n-            *    transformation-time only, then there's no way of\n-            *    knowing that content shall be valid, and we'll\n-            *    process the content the same way.\n-            *  2) If the author *does* set the flag, then we'll assume\n-            *   that the author has handled the parsing him\/herself\n-            *   (e.g. called xsltParseSequenceConstructor(), etc.\n-            *   explicitely in his\/her code).\n-            *\/\n-            if ((cur->children != NULL) &&\n-            (cctxt->inode->extContentHandled == 0))\n-            {\n-            \/*\n-            * Default parsing of the content using the\n-            * sequence-constructor model.\n-            *\/\n-            xsltParseSequenceConstructor(cctxt, cur->children);\n-            }\n-        } else {\n-            \/*\n-            * Literal result element\n-            * ----------------------------------------------------\n-            * Allowed XSLT attributes:\n-            *  xsl:extension-element-prefixes CDATA #IMPLIED\n-            *  xsl:exclude-result-prefixes CDATA #IMPLIED\n-            *  TODO: xsl:use-attribute-sets %qnames; #IMPLIED\n-            *  xsl:version NMTOKEN #IMPLIED\n-            *\/\n-            cur->psvi = NULL;\n-            cctxt->inode->category = XSLT_ELEMENT_CATEGORY_LRE;\n-            if (cur->properties != NULL) {\n-            xmlAttrPtr attr = cur->properties;\n-            \/*\n-            * Attribute \"xsl:exclude-result-prefixes\".\n-            *\/\n-            cctxt->inode->exclResultNs =\n-                xsltParseExclResultPrefixes(cctxt, cur,\n-                cctxt->inode->exclResultNs,\n-                XSLT_ELEMENT_CATEGORY_LRE);\n-            \/*\n-            * Attribute \"xsl:version\".\n-            *\/\n-            xsltParseAttrXSLTVersion(cctxt, cur,\n-                XSLT_ELEMENT_CATEGORY_LRE);\n-            \/*\n-            * Report invalid XSLT attributes.\n-            * For XSLT 1.0 only xsl:use-attribute-sets is allowed\n-            * next to xsl:version, xsl:exclude-result-prefixes and\n-            * xsl:extension-element-prefixes.\n-            *\n-            * Mark all XSLT attributes, in order to skip such\n-            * attributes when instantiating the LRE.\n-            *\/\n-            do {\n-                if ((attr->psvi != xsltXSLTAttrMarker) &&\n-                IS_XSLT_ATTR_FAST(attr))\n-                {\n-                if (! xmlStrEqual(attr->name,\n-                    BAD_CAST \"use-attribute-sets\"))\n-                {\n-                    xsltTransformError(NULL, cctxt->style,\n-                    cur,\n-                    \"Unknown XSLT attribute '%s'.\\n\",\n-                    attr->name);\n-                    cctxt->style->errors++;\n-                } else {\n+                if (cur->properties) {\n+                    xmlAttrPtr attr;\n@@ -4790,1 +4536,2 @@\n-                    * XSLT attr marker.\n+                    * TODO: We need to report errors for\n+                    *  invalid attrs.\n@@ -4792,1 +4539,38 @@\n-                    attr->psvi = (void *) xsltXSLTAttrMarker;\n+                    attr = cur->properties;\n+                    do {\n+                        if ((attr->ns == NULL) &&\n+                            (attr->name != NULL) &&\n+                            (attr->name[0] == 'd') &&\n+                            xmlStrEqual(attr->name,\n+                            BAD_CAST \"disable-output-escaping\"))\n+                        {\n+                            \/*\n+                            * Attr \"disable-output-escaping\".\n+                            * XSLT-2: This attribute is deprecated.\n+                            *\/\n+                            if ((attr->children != NULL) &&\n+                                xmlStrEqual(attr->children->content,\n+                                BAD_CAST \"yes\"))\n+                            {\n+                                \/*\n+                                * Disable output escaping for this\n+                                * text node.\n+                                *\/\n+                                if (tmp)\n+                                    tmp->name = xmlStringTextNoenc;\n+                            } else if ((attr->children == NULL) ||\n+                                (attr->children->content == NULL) ||\n+                                (!xmlStrEqual(attr->children->content,\n+                                BAD_CAST \"no\")))\n+                            {\n+                                xsltTransformError(NULL, cctxt->style,\n+                                    cur,\n+                                    \"Attribute 'disable-output-escaping': \"\n+                                    \"Invalid value. Expected is \"\n+                                    \"'yes' or 'no'.\\n\");\n+                                cctxt->style->errors++;\n+                            }\n+                            break;\n+                        }\n+                        attr = attr->next;\n+                    } while (attr != NULL);\n@@ -4794,0 +4578,41 @@\n+            } else if (IS_XSLT_ELEM_FAST(cur)) {\n+                \/*\n+                * TODO: Using the XSLT-marker is still not stable yet.\n+                *\/\n+                \/* if (cur->psvi == xsltXSLTElemMarker) { *\/\n+                \/*\n+                * XSLT instructions\n+                * --------------------------------------------------------\n+                *\/\n+                cur->psvi = NULL;\n+                type = xsltGetXSLTElementTypeByNode(cctxt, cur);\n+                switch (type) {\n+                    case XSLT_FUNC_APPLYIMPORTS:\n+                    case XSLT_FUNC_APPLYTEMPLATES:\n+                    case XSLT_FUNC_ATTRIBUTE:\n+                    case XSLT_FUNC_CALLTEMPLATE:\n+                    case XSLT_FUNC_CHOOSE:\n+                    case XSLT_FUNC_COMMENT:\n+                    case XSLT_FUNC_COPY:\n+                    case XSLT_FUNC_COPYOF:\n+                    case XSLT_FUNC_DOCUMENT: \/* Extra one *\/\n+                    case XSLT_FUNC_ELEMENT:\n+                    case XSLT_FUNC_FALLBACK:\n+                    case XSLT_FUNC_FOREACH:\n+                    case XSLT_FUNC_IF:\n+                    case XSLT_FUNC_MESSAGE:\n+                    case XSLT_FUNC_NUMBER:\n+                    case XSLT_FUNC_PI:\n+                    case XSLT_FUNC_TEXT:\n+                    case XSLT_FUNC_VALUEOF:\n+                    case XSLT_FUNC_VARIABLE:\n+                        \/*\n+                        * Parse the XSLT element.\n+                        *\/\n+                        cctxt->inode->curChildType = type;\n+                        xsltParseAnyXSLTElem(cctxt, cur);\n+                        break;\n+                    default:\n+                        xsltParseUnknownXSLTElem(cctxt, cur);\n+                        cur = cur->next;\n+                        continue;\n@@ -4795,19 +4620,190 @@\n-                attr = attr->next;\n-            } while (attr != NULL);\n-            }\n-            \/*\n-            * Create\/reuse info for the literal result element.\n-            *\/\n-            if (cctxt->inode->nsChanged)\n-            xsltLREInfoCreate(cctxt, cur, 1);\n-            cur->psvi = cctxt->inode->litResElemInfo;\n-            \/*\n-            * Apply ns-aliasing on the element and on its attributes.\n-            *\/\n-            if (cctxt->hasNsAliases)\n-            xsltLREBuildEffectiveNs(cctxt, cur);\n-            \/*\n-            * Compile attribute value templates (AVT).\n-            *\/\n-            if (cur->properties) {\n-            xmlAttrPtr attr = cur->properties;\n+            } else {\n+                \/*\n+                * Non-XSLT elements\n+                * -----------------\n+                *\/\n+                xsltCompilerNodePush(cctxt, cur);\n+                \/*\n+                * Update the in-scope namespaces if needed.\n+                *\/\n+                if (cur->nsDef != NULL)\n+                    cctxt->inode->inScopeNs =\n+                        xsltCompilerBuildInScopeNsList(cctxt, cur);\n+                \/*\n+                * The current element is either a literal result element\n+                * or an extension instruction.\n+                *\n+                * Process attr \"xsl:extension-element-prefixes\".\n+                * FUTURE TODO: IIRC in XSLT 2.0 this attribute must be\n+                * processed by the implementor of the extension function;\n+                * i.e., it won't be handled by the XSLT processor.\n+                *\/\n+                \/* SPEC 1.0:\n+                *   \"exclude-result-prefixes\" is only allowed on literal\n+                *   result elements and \"xsl:exclude-result-prefixes\"\n+                *   on xsl:stylesheet\/xsl:transform.\n+                * SPEC 2.0:\n+                *   \"There are a number of standard attributes\n+                *   that may appear on any XSLT element: specifically\n+                *   version, exclude-result-prefixes,\n+                *   extension-element-prefixes, xpath-default-namespace,\n+                *   default-collation, and use-when.\"\n+                *\n+                * SPEC 2.0:\n+                *   For literal result elements:\n+                *   \"xsl:version, xsl:exclude-result-prefixes,\n+                *    xsl:extension-element-prefixes,\n+                *    xsl:xpath-default-namespace,\n+                *    xsl:default-collation, or xsl:use-when.\"\n+                *\/\n+                if (cur->properties)\n+                    cctxt->inode->extElemNs =\n+                        xsltParseExtElemPrefixes(cctxt,\n+                            cur, cctxt->inode->extElemNs,\n+                            XSLT_ELEMENT_CATEGORY_LRE);\n+                \/*\n+                * Eval if we have an extension instruction here.\n+                *\/\n+                if ((cur->ns != NULL) &&\n+                    (cctxt->inode->extElemNs != NULL) &&\n+                    (xsltCheckExtPrefix(cctxt->style, cur->ns->href) == 1))\n+                {\n+                    \/*\n+                    * Extension instructions\n+                    * ----------------------------------------------------\n+                    * Mark the node information.\n+                    *\/\n+                    cctxt->inode->category = XSLT_ELEMENT_CATEGORY_EXTENSION;\n+                    cctxt->inode->extContentHandled = 0;\n+                    if (cur->psvi != NULL) {\n+                        cur->psvi = NULL;\n+                        \/*\n+                        * TODO: Temporary sanity check.\n+                        *\/\n+                        xsltTransformError(NULL, cctxt->style, cur,\n+                            \"Internal error in xsltParseSequenceConstructor(): \"\n+                            \"Occupied PSVI field.\\n\");\n+                        cctxt->style->errors++;\n+                        cur = cur->next;\n+                        continue;\n+                    }\n+                    cur->psvi = (void *)\n+                        xsltPreComputeExtModuleElement(cctxt->style, cur);\n+\n+                    if (cur->psvi == NULL) {\n+                        \/*\n+                        * OLD COMMENT: \"Unknown element, maybe registered\n+                        *  at the context level. Mark it for later\n+                        *  recognition.\"\n+                        * QUESTION: What does the xsltExtMarker mean?\n+                        *  ANSWER: It is used in\n+                        *   xsltApplySequenceConstructor() at\n+                        *   transformation-time to look out for extension\n+                        *   registered in the transformation context.\n+                        *\/\n+                        cur->psvi = (void *) xsltExtMarker;\n+                    }\n+                    \/*\n+                    * BIG NOTE: Now the ugly part. In previous versions\n+                    *  of Libxslt (until 1.1.16), all the content of an\n+                    *  extension instruction was processed and compiled without\n+                    *  the need of the extension-author to explicitely call\n+                    *  such a processing;.We now need to mimic this old\n+                    *  behaviour in order to avoid breaking old code\n+                    *  on the extension-author's side.\n+                    * The mechanism:\n+                    *  1) If the author does *not* set the\n+                    *    compile-time-flag @extContentHandled, then we'll\n+                    *    parse the content assuming that it's a \"template\"\n+                    *    (or \"sequence constructor in XSLT 2.0 terms).\n+                    *    NOTE: If the extension is registered at\n+                    *    transformation-time only, then there's no way of\n+                    *    knowing that content shall be valid, and we'll\n+                    *    process the content the same way.\n+                    *  2) If the author *does* set the flag, then we'll assume\n+                    *   that the author has handled the parsing him\/herself\n+                    *   (e.g. called xsltParseSequenceConstructor(), etc.\n+                    *   explicitely in his\/her code).\n+                    *\/\n+                    if ((cur->children != NULL) &&\n+                        (cctxt->inode->extContentHandled == 0))\n+                    {\n+                        \/*\n+                        * Default parsing of the content using the\n+                        * sequence-constructor model.\n+                        *\/\n+                        xsltParseSequenceConstructor(cctxt, cur->children);\n+                    }\n+                } else {\n+                    \/*\n+                    * Literal result element\n+                    * ----------------------------------------------------\n+                    * Allowed XSLT attributes:\n+                    *  xsl:extension-element-prefixes CDATA #IMPLIED\n+                    *  xsl:exclude-result-prefixes CDATA #IMPLIED\n+                    *  TODO: xsl:use-attribute-sets %qnames; #IMPLIED\n+                    *  xsl:version NMTOKEN #IMPLIED\n+                    *\/\n+                    cur->psvi = NULL;\n+                    cctxt->inode->category = XSLT_ELEMENT_CATEGORY_LRE;\n+                    if (cur->properties != NULL) {\n+                        xmlAttrPtr attr = cur->properties;\n+                        \/*\n+                        * Attribute \"xsl:exclude-result-prefixes\".\n+                        *\/\n+                        cctxt->inode->exclResultNs =\n+                            xsltParseExclResultPrefixes(cctxt, cur,\n+                                cctxt->inode->exclResultNs,\n+                                XSLT_ELEMENT_CATEGORY_LRE);\n+                        \/*\n+                        * Attribute \"xsl:version\".\n+                        *\/\n+                        xsltParseAttrXSLTVersion(cctxt, cur,\n+                            XSLT_ELEMENT_CATEGORY_LRE);\n+                        \/*\n+                        * Report invalid XSLT attributes.\n+                        * For XSLT 1.0 only xsl:use-attribute-sets is allowed\n+                        * next to xsl:version, xsl:exclude-result-prefixes and\n+                        * xsl:extension-element-prefixes.\n+                        *\n+                        * Mark all XSLT attributes, in order to skip such\n+                        * attributes when instantiating the LRE.\n+                        *\/\n+                        do {\n+                            if ((attr->psvi != xsltXSLTAttrMarker) &&\n+                                IS_XSLT_ATTR_FAST(attr))\n+                            {\n+                                if (! xmlStrEqual(attr->name,\n+                                    BAD_CAST \"use-attribute-sets\"))\n+                                {\n+                                    xsltTransformError(NULL, cctxt->style,\n+                                        cur,\n+                                        \"Unknown XSLT attribute '%s'.\\n\",\n+                                        attr->name);\n+                                    cctxt->style->errors++;\n+                                } else {\n+                                    \/*\n+                                    * XSLT attr marker.\n+                                    *\/\n+                                    attr->psvi = (void *) xsltXSLTAttrMarker;\n+                                }\n+                            }\n+                            attr = attr->next;\n+                        } while (attr != NULL);\n+                    }\n+                    \/*\n+                    * Create\/reuse info for the literal result element.\n+                    *\/\n+                    if (cctxt->inode->nsChanged)\n+                        xsltLREInfoCreate(cctxt, cur, 1);\n+                    cur->psvi = cctxt->inode->litResElemInfo;\n+                    \/*\n+                    * Apply ns-aliasing on the element and on its attributes.\n+                    *\/\n+                    if (cctxt->hasNsAliases)\n+                        xsltLREBuildEffectiveNs(cctxt, cur);\n+                    \/*\n+                    * Compile attribute value templates (AVT).\n+                    *\/\n+                    if (cur->properties) {\n+                        xmlAttrPtr attr = cur->properties;\n@@ -4815,11 +4811,17 @@\n-            while (attr != NULL) {\n-                xsltCompileAttr(cctxt->style, attr);\n-                attr = attr->next;\n-            }\n-            }\n-            \/*\n-            * Parse the content, which is defined to be a \"template\"\n-            * (or \"sequence constructor\" in XSLT 2.0 terms).\n-            *\/\n-            if (cur->children != NULL) {\n-            xsltParseSequenceConstructor(cctxt, cur->children);\n+                        while (attr != NULL) {\n+                            xsltCompileAttr(cctxt->style, attr);\n+                            attr = attr->next;\n+                        }\n+                    }\n+                    \/*\n+                    * Parse the content, which is defined to be a \"template\"\n+                    * (or \"sequence constructor\" in XSLT 2.0 terms).\n+                    *\/\n+                    if (cur->children != NULL) {\n+                        xsltParseSequenceConstructor(cctxt, cur->children);\n+                    }\n+                }\n+                \/*\n+                * Leave the non-XSLT element.\n+                *\/\n+                xsltCompilerNodePop(cctxt, cur);\n@@ -4828,7 +4830,1 @@\n-        \/*\n-        * Leave the non-XSLT element.\n-        *\/\n-        xsltCompilerNodePop(cctxt, cur);\n-        }\n-    }\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -4838,2 +4834,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-        \"xsltParseSequenceConstructor: removing xsl:text element\\n\");\n+        xsltGenericDebug(xsltGenericDebugContext,\n+            \"xsltParseSequenceConstructor: removing xsl:text element\\n\");\n@@ -4841,3 +4837,3 @@\n-    xmlUnlinkNode(deleteNode);\n-    xmlFreeNode(deleteNode);\n-    deleteNode = NULL;\n+        xmlUnlinkNode(deleteNode);\n+        xmlFreeNode(deleteNode);\n+        deleteNode = NULL;\n@@ -4865,1 +4861,1 @@\n-    return;\n+        return;\n@@ -4871,1 +4867,1 @@\n-    XSLT_CCTXT(style)->inode->extContentHandled = 1;\n+        XSLT_CCTXT(style)->inode->extContentHandled = 1;\n@@ -4875,21 +4871,21 @@\n-    xmlNodePtr child = templ->children;\n-    \/*\n-    * Process xsl:param elements, which can only occur as the\n-    * immediate children of xsl:template (well, and of any\n-    * user-defined extension instruction if needed).\n-    *\/\n-    do {\n-        if ((child->type == XML_ELEMENT_NODE) &&\n-        IS_XSLT_ELEM_FAST(child) &&\n-        IS_XSLT_NAME(child, \"param\"))\n-        {\n-        XSLT_CCTXT(style)->inode->curChildType = XSLT_FUNC_PARAM;\n-        xsltParseAnyXSLTElem(XSLT_CCTXT(style), child);\n-        } else\n-        break;\n-        child = child->next;\n-    } while (child != NULL);\n-    \/*\n-    * Parse the content and register the pattern.\n-    *\/\n-    xsltParseSequenceConstructor(XSLT_CCTXT(style), child);\n+        xmlNodePtr child = templ->children;\n+        \/*\n+        * Process xsl:param elements, which can only occur as the\n+        * immediate children of xsl:template (well, and of any\n+        * user-defined extension instruction if needed).\n+        *\/\n+        do {\n+            if ((child->type == XML_ELEMENT_NODE) &&\n+                IS_XSLT_ELEM_FAST(child) &&\n+                IS_XSLT_NAME(child, \"param\"))\n+            {\n+                XSLT_CCTXT(style)->inode->curChildType = XSLT_FUNC_PARAM;\n+                xsltParseAnyXSLTElem(XSLT_CCTXT(style), child);\n+            } else\n+                break;\n+            child = child->next;\n+        } while (child != NULL);\n+        \/*\n+        * Parse the content and register the pattern.\n+        *\/\n+        xsltParseSequenceConstructor(XSLT_CCTXT(style), child);\n@@ -4925,1 +4921,1 @@\n-    if (delete != NULL) {\n+        if (delete != NULL) {\n@@ -4927,2 +4923,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltParseTemplateContent: removing text\\n\");\n+            xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltParseTemplateContent: removing text\\n\");\n@@ -4930,5 +4926,5 @@\n-        xmlUnlinkNode(delete);\n-        xmlFreeNode(delete);\n-        delete = NULL;\n-    }\n-    if (IS_XSLT_ELEM(cur)) {\n+            xmlUnlinkNode(delete);\n+            xmlFreeNode(delete);\n+            delete = NULL;\n+        }\n+        if (IS_XSLT_ELEM(cur)) {\n@@ -4937,17 +4933,17 @@\n-        if (IS_XSLT_NAME(cur, \"text\")) {\n-        \/*\n-        * TODO: Processing of xsl:text should be moved to\n-        *   xsltPreprocessStylesheet(), since otherwise this\n-        *   will be performed for every multiply included\n-        *   stylesheet; i.e. this here is not skipped with\n-        *   the use of the style->nopreproc flag.\n-        *\/\n-        if (cur->children != NULL) {\n-            xmlChar *prop;\n-            xmlNodePtr text = cur->children, next;\n-            int noesc = 0;\n-\n-            prop = xmlGetNsProp(cur,\n-            (const xmlChar *)\"disable-output-escaping\",\n-            NULL);\n-            if (prop != NULL) {\n+            if (IS_XSLT_NAME(cur, \"text\")) {\n+                \/*\n+                * TODO: Processing of xsl:text should be moved to\n+                *   xsltPreprocessStylesheet(), since otherwise this\n+                *   will be performed for every multiply included\n+                *   stylesheet; i.e. this here is not skipped with\n+                *   the use of the style->nopreproc flag.\n+                *\/\n+                if (cur->children != NULL) {\n+                    xmlChar *prop;\n+                    xmlNodePtr text = cur->children, next;\n+                    int noesc = 0;\n+\n+                    prop = xmlGetNsProp(cur,\n+                        (const xmlChar *)\"disable-output-escaping\",\n+                        NULL);\n+                    if (prop != NULL) {\n@@ -4955,2 +4951,2 @@\n-            xsltGenericDebug(xsltGenericDebugContext,\n-                 \"Disable escaping: %s\\n\", text->content);\n+                        xsltGenericDebug(xsltGenericDebugContext,\n+                             \"Disable escaping: %s\\n\", text->content);\n@@ -4958,7 +4954,7 @@\n-            if (xmlStrEqual(prop, (const xmlChar *)\"yes\")) {\n-                noesc = 1;\n-            } else if (!xmlStrEqual(prop,\n-                        (const xmlChar *)\"no\")){\n-                xsltTransformError(NULL, style, cur,\n-         \"xsl:text: disable-output-escaping allows only yes or no\\n\");\n-                style->warnings++;\n+                        if (xmlStrEqual(prop, (const xmlChar *)\"yes\")) {\n+                            noesc = 1;\n+                        } else if (!xmlStrEqual(prop,\n+                                                (const xmlChar *)\"no\")){\n+                            xsltTransformError(NULL, style, cur,\n+             \"xsl:text: disable-output-escaping allows only yes or no\\n\");\n+                            style->warnings++;\n@@ -4966,3 +4962,3 @@\n-            }\n-            xmlFree(prop);\n-            }\n+                        }\n+                        xmlFree(prop);\n+                    }\n@@ -4970,16 +4966,16 @@\n-            while (text != NULL) {\n-            if (text->type == XML_COMMENT_NODE) {\n-                text = text->next;\n-                continue;\n-            }\n-            if ((text->type != XML_TEXT_NODE) &&\n-                 (text->type != XML_CDATA_SECTION_NODE)) {\n-                xsltTransformError(NULL, style, cur,\n-         \"xsltParseTemplateContent: xslt:text content problem\\n\");\n-                style->errors++;\n-                break;\n-            }\n-            if ((noesc) && (text->type != XML_CDATA_SECTION_NODE))\n-                text->name = xmlStringTextNoenc;\n-            text = text->next;\n-            }\n+                    while (text != NULL) {\n+                        if (text->type == XML_COMMENT_NODE) {\n+                            text = text->next;\n+                            continue;\n+                        }\n+                        if ((text->type != XML_TEXT_NODE) &&\n+                             (text->type != XML_CDATA_SECTION_NODE)) {\n+                            xsltTransformError(NULL, style, cur,\n+                 \"xsltParseTemplateContent: xslt:text content problem\\n\");\n+                            style->errors++;\n+                            break;\n+                        }\n+                        if ((noesc) && (text->type != XML_CDATA_SECTION_NODE))\n+                            text->name = xmlStringTextNoenc;\n+                        text = text->next;\n+                    }\n@@ -4987,0 +4983,39 @@\n+                    \/*\n+                     * replace xsl:text by the list of childs\n+                     *\/\n+                    if (text == NULL) {\n+                        text = cur->children;\n+                        while (text != NULL) {\n+                            if ((style->internalized) &&\n+                                (text->content != NULL) &&\n+                                (!xmlDictOwns(style->dict, text->content))) {\n+\n+                                \/*\n+                                 * internalize the text string\n+                                 *\/\n+                                if (text->doc->dict != NULL) {\n+                                    const xmlChar *tmp;\n+\n+                                    tmp = xmlDictLookup(text->doc->dict,\n+                                                        text->content, -1);\n+                                    if (tmp != text->content) {\n+                                        xmlNodeSetContent(text, NULL);\n+                                        text->content = (xmlChar *) tmp;\n+                                    }\n+                                }\n+                            }\n+\n+                            next = text->next;\n+                            xmlUnlinkNode(text);\n+                            xmlAddPrevSibling(cur, text);\n+                            text = next;\n+                        }\n+                    }\n+                }\n+                delete = cur;\n+                goto skip_children;\n+            }\n+        }\n+        else if ((cur->ns != NULL) && (style->nsDefs != NULL) &&\n+            (xsltCheckExtPrefix(style, cur->ns->prefix)))\n+        {\n@@ -4988,1 +5023,1 @@\n-             * replace xsl:text by the list of childs\n+             * okay this is an extension element compile it too\n@@ -4990,6 +5025,14 @@\n-            if (text == NULL) {\n-            text = cur->children;\n-            while (text != NULL) {\n-                if ((style->internalized) &&\n-                    (text->content != NULL) &&\n-                    (!xmlDictOwns(style->dict, text->content))) {\n+            xsltStylePreCompute(style, cur);\n+        }\n+        else if (cur->type == XML_ELEMENT_NODE)\n+        {\n+            \/*\n+             * This is an element which will be output as part of the\n+             * template exectution, precompile AVT if found.\n+             *\/\n+            if ((cur->ns == NULL) && (style->defaultAlias != NULL)) {\n+                cur->ns = xmlSearchNsByHref(cur->doc, cur,\n+                        style->defaultAlias);\n+            }\n+            if (cur->properties != NULL) {\n+                xmlAttrPtr attr = cur->properties;\n@@ -4997,13 +5040,3 @@\n-                \/*\n-                 * internalize the text string\n-                 *\/\n-                if (text->doc->dict != NULL) {\n-                    const xmlChar *tmp;\n-\n-                    tmp = xmlDictLookup(text->doc->dict,\n-                                        text->content, -1);\n-                    if (tmp != text->content) {\n-                        xmlNodeSetContent(text, NULL);\n-                    text->content = (xmlChar *) tmp;\n-                    }\n-                }\n+                while (attr != NULL) {\n+                    xsltCompileAttr(style, attr);\n+                    attr = attr->next;\n@@ -5011,6 +5044,0 @@\n-\n-                next = text->next;\n-                xmlUnlinkNode(text);\n-                xmlAddPrevSibling(cur, text);\n-                text = next;\n-            }\n@@ -5019,7 +5046,0 @@\n-        delete = cur;\n-        goto skip_children;\n-        }\n-    }\n-    else if ((cur->ns != NULL) && (style->nsDefs != NULL) &&\n-        (xsltCheckExtPrefix(style, cur->ns->prefix)))\n-    {\n@@ -5027,1 +5047,1 @@\n-         * okay this is an extension element compile it too\n+         * Skip to next node\n@@ -5029,28 +5049,5 @@\n-        xsltStylePreCompute(style, cur);\n-    }\n-    else if (cur->type == XML_ELEMENT_NODE)\n-    {\n-        \/*\n-         * This is an element which will be output as part of the\n-         * template exectution, precompile AVT if found.\n-         *\/\n-        if ((cur->ns == NULL) && (style->defaultAlias != NULL)) {\n-        cur->ns = xmlSearchNsByHref(cur->doc, cur,\n-            style->defaultAlias);\n-        }\n-        if (cur->properties != NULL) {\n-            xmlAttrPtr attr = cur->properties;\n-\n-        while (attr != NULL) {\n-            xsltCompileAttr(style, attr);\n-            attr = attr->next;\n-        }\n-        }\n-    }\n-    \/*\n-     * Skip to next node\n-     *\/\n-    if (cur->children != NULL) {\n-        if (cur->children->type != XML_ENTITY_DECL) {\n-        cur = cur->children;\n-        continue;\n+        if (cur->children != NULL) {\n+            if (cur->children->type != XML_ENTITY_DECL) {\n+                cur = cur->children;\n+                continue;\n+            }\n@@ -5058,1 +5055,0 @@\n-    }\n@@ -5060,13 +5056,0 @@\n-    if (cur->next != NULL) {\n-        cur = cur->next;\n-        continue;\n-    }\n-\n-    do {\n-        cur = cur->parent;\n-        if (cur == NULL)\n-        break;\n-        if (cur == templ) {\n-        cur = NULL;\n-        break;\n-        }\n@@ -5074,2 +5057,2 @@\n-        cur = cur->next;\n-        break;\n+            cur = cur->next;\n+            continue;\n@@ -5077,1 +5060,14 @@\n-    } while (cur != NULL);\n+\n+        do {\n+            cur = cur->parent;\n+            if (cur == NULL)\n+                break;\n+            if (cur == templ) {\n+                cur = NULL;\n+                break;\n+            }\n+            if (cur->next != NULL) {\n+                cur = cur->next;\n+                break;\n+            }\n+        } while (cur != NULL);\n@@ -5081,2 +5077,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-     \"xsltParseTemplateContent: removing text\\n\");\n+        xsltGenericDebug(xsltGenericDebugContext,\n+         \"xsltParseTemplateContent: removing text\\n\");\n@@ -5084,3 +5080,3 @@\n-    xmlUnlinkNode(delete);\n-    xmlFreeNode(delete);\n-    delete = NULL;\n+        xmlUnlinkNode(delete);\n+        xmlFreeNode(delete);\n+        delete = NULL;\n@@ -5094,3 +5090,3 @@\n-    if ((IS_XSLT_ELEM(cur)) && (!(IS_XSLT_NAME(cur, \"param\"))))\n-        break;\n-    cur = cur->next;\n+        if ((IS_XSLT_ELEM(cur)) && (!(IS_XSLT_NAME(cur, \"param\"))))\n+            break;\n+        cur = cur->next;\n@@ -5103,2 +5099,2 @@\n-    if ((IS_XSLT_ELEM(cur)) && (IS_XSLT_NAME(cur, \"param\"))) {\n-        xmlNodePtr param = cur;\n+        if ((IS_XSLT_ELEM(cur)) && (IS_XSLT_NAME(cur, \"param\"))) {\n+            xmlNodePtr param = cur;\n@@ -5106,3 +5102,3 @@\n-        xsltTransformError(NULL, style, cur,\n-        \"xsltParseTemplateContent: ignoring misplaced param element\\n\");\n-        if (style != NULL) style->warnings++;\n+            xsltTransformError(NULL, style, cur,\n+                \"xsltParseTemplateContent: ignoring misplaced param element\\n\");\n+            if (style != NULL) style->warnings++;\n@@ -5110,4 +5106,4 @@\n-        xmlUnlinkNode(param);\n-        xmlFreeNode(param);\n-    } else\n-        break;\n+            xmlUnlinkNode(param);\n+            xmlFreeNode(param);\n+        } else\n+            break;\n@@ -5139,1 +5135,1 @@\n-    return;\n+        return;\n@@ -5148,12 +5144,12 @@\n-    \/*\n-    * TODO: Don't use xsltGetQNameURI().\n-    *\/\n-    URI = xsltGetQNameURI(key, &prop);\n-    if (prop == NULL) {\n-        if (style != NULL) style->errors++;\n-        goto error;\n-    } else {\n-        name = prop;\n-        if (URI != NULL)\n-        nameURI = xmlStrdup(URI);\n-    }\n+        \/*\n+        * TODO: Don't use xsltGetQNameURI().\n+        *\/\n+        URI = xsltGetQNameURI(key, &prop);\n+        if (prop == NULL) {\n+            if (style != NULL) style->errors++;\n+            goto error;\n+        } else {\n+            name = prop;\n+            if (URI != NULL)\n+                nameURI = xmlStrdup(URI);\n+        }\n@@ -5161,2 +5157,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltParseStylesheetKey: name %s\\n\", name);\n+        xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltParseStylesheetKey: name %s\\n\", name);\n@@ -5165,4 +5161,4 @@\n-    xsltTransformError(NULL, style, key,\n-        \"xsl:key : error missing name\\n\");\n-    if (style != NULL) style->errors++;\n-    goto error;\n+        xsltTransformError(NULL, style, key,\n+            \"xsl:key : error missing name\\n\");\n+        if (style != NULL) style->errors++;\n+        goto error;\n@@ -5173,4 +5169,4 @@\n-    xsltTransformError(NULL, style, key,\n-        \"xsl:key : error missing match\\n\");\n-    if (style != NULL) style->errors++;\n-    goto error;\n+        xsltTransformError(NULL, style, key,\n+            \"xsl:key : error missing match\\n\");\n+        if (style != NULL) style->errors++;\n+        goto error;\n@@ -5181,4 +5177,4 @@\n-    xsltTransformError(NULL, style, key,\n-        \"xsl:key : error missing use\\n\");\n-    if (style != NULL) style->errors++;\n-    goto error;\n+        xsltTransformError(NULL, style, key,\n+            \"xsl:key : error missing use\\n\");\n+        if (style != NULL) style->errors++;\n+        goto error;\n@@ -5195,1 +5191,1 @@\n-    xmlFree(use);\n+        xmlFree(use);\n@@ -5197,1 +5193,1 @@\n-    xmlFree(match);\n+        xmlFree(match);\n@@ -5199,1 +5195,1 @@\n-    xmlFree(name);\n+        xmlFree(name);\n@@ -5201,1 +5197,1 @@\n-    xmlFree(nameURI);\n+        xmlFree(nameURI);\n@@ -5204,1 +5200,1 @@\n-    xsltParseContentError(style, key->children);\n+        xsltParseContentError(style, key->children);\n@@ -5230,1 +5226,1 @@\n-    return;\n+        return;\n@@ -5237,1 +5233,1 @@\n-    return;\n+        return;\n@@ -5241,2 +5237,2 @@\n-    cctxt->inode->inScopeNs =\n-        xsltCompilerBuildInScopeNsList(cctxt, templNode);\n+        cctxt->inode->inScopeNs =\n+            xsltCompilerBuildInScopeNsList(cctxt, templNode);\n@@ -5255,23 +5251,23 @@\n-    \/*\n-    * TODO: We need a standardized function for extraction\n-    *  of namespace names and local names from QNames.\n-    *  Don't use xsltGetQNameURI() as it cannot channe\n-    *  reports through the context.\n-    *\/\n-    modeURI = xsltGetQNameURI(templNode, &prop);\n-    if (prop == NULL) {\n-        cctxt->style->errors++;\n-        goto error;\n-    }\n-    templ->mode = xmlDictLookup(cctxt->style->dict, prop, -1);\n-    xmlFree(prop);\n-    prop = NULL;\n-    if (xmlValidateNCName(templ->mode, 0)) {\n-        xsltTransformError(NULL, cctxt->style, templNode,\n-        \"xsl:template: Attribute 'mode': The local part '%s' \"\n-        \"of the value is not a valid NCName.\\n\", templ->name);\n-        cctxt->style->errors++;\n-        goto error;\n-    }\n-    if (modeURI != NULL)\n-        templ->modeURI = xmlDictLookup(cctxt->style->dict, modeURI, -1);\n+        \/*\n+        * TODO: We need a standardized function for extraction\n+        *  of namespace names and local names from QNames.\n+        *  Don't use xsltGetQNameURI() as it cannot channe\n+        *  reports through the context.\n+        *\/\n+        modeURI = xsltGetQNameURI(templNode, &prop);\n+        if (prop == NULL) {\n+            cctxt->style->errors++;\n+            goto error;\n+        }\n+        templ->mode = xmlDictLookup(cctxt->style->dict, prop, -1);\n+        xmlFree(prop);\n+        prop = NULL;\n+        if (xmlValidateNCName(templ->mode, 0)) {\n+            xsltTransformError(NULL, cctxt->style, templNode,\n+                \"xsl:template: Attribute 'mode': The local part '%s' \"\n+                \"of the value is not a valid NCName.\\n\", templ->name);\n+            cctxt->style->errors++;\n+            goto error;\n+        }\n+        if (modeURI != NULL)\n+            templ->modeURI = xmlDictLookup(cctxt->style->dict, modeURI, -1);\n@@ -5279,2 +5275,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltParseXSLTTemplate: mode %s\\n\", templ->mode);\n+        xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltParseXSLTTemplate: mode %s\\n\", templ->mode);\n@@ -5288,2 +5284,2 @@\n-    templ->match  = prop;\n-    prop = NULL;\n+        templ->match  = prop;\n+        prop = NULL;\n@@ -5296,47 +5292,4 @@\n-    priority = xmlXPathStringEvalNumber(prop);\n-    templ->priority = (float) priority;\n-    xmlFree(prop);\n-    prop = NULL;\n-    }\n-    \/*\n-    * Attribute \"name\".\n-    *\/\n-    prop = xmlGetNsProp(templNode, (const xmlChar *)\"name\", NULL);\n-    if (prop != NULL) {\n-        const xmlChar *nameURI;\n-    xsltTemplatePtr curTempl;\n-\n-    \/*\n-    * TODO: Don't use xsltGetQNameURI().\n-    *\/\n-    nameURI = xsltGetQNameURI(templNode, &prop);\n-    if (prop == NULL) {\n-        cctxt->style->errors++;\n-        goto error;\n-    }\n-    templ->name = xmlDictLookup(cctxt->style->dict, prop, -1);\n-    xmlFree(prop);\n-    prop = NULL;\n-    if (xmlValidateNCName(templ->name, 0)) {\n-        xsltTransformError(NULL, cctxt->style, templNode,\n-        \"xsl:template: Attribute 'name': The local part '%s' of \"\n-        \"the value is not a valid NCName.\\n\", templ->name);\n-        cctxt->style->errors++;\n-        goto error;\n-    }\n-    if (nameURI != NULL)\n-        templ->nameURI = xmlDictLookup(cctxt->style->dict, nameURI, -1);\n-    curTempl = templ->next;\n-    while (curTempl != NULL) {\n-        if ((nameURI != NULL && xmlStrEqual(curTempl->name, templ->name) &&\n-        xmlStrEqual(curTempl->nameURI, nameURI) ) ||\n-        (nameURI == NULL && curTempl->nameURI == NULL &&\n-        xmlStrEqual(curTempl->name, templ->name)))\n-        {\n-        xsltTransformError(NULL, cctxt->style, templNode,\n-            \"xsl:template: error duplicate name '%s'\\n\", templ->name);\n-        cctxt->style->errors++;\n-        goto error;\n-        }\n-        curTempl = curTempl->next;\n-    }\n+        priority = xmlXPathStringEvalNumber(prop);\n+        templ->priority = (float) priority;\n+        xmlFree(prop);\n+        prop = NULL;\n@@ -5344,2 +5297,0 @@\n-    if (templNode->children != NULL) {\n-    xsltParseTemplateContent(cctxt->style, templNode);\n@@ -5347,13 +5298,1 @@\n-    * MAYBE TODO: Custom behaviour: In order to stay compatible with\n-    * Xalan and MSXML(.NET), we could allow whitespace\n-    * to appear before an xml:param element; this whitespace\n-    * will additionally become part of the \"template\".\n-    * NOTE that this is totally deviates from the spec, but\n-    * is the de facto behaviour of Xalan and MSXML(.NET).\n-    * Personally I wouldn't allow this, since if we have:\n-    * <xsl:template ...xml:space=\"preserve\">\n-    *   <xsl:param name=\"foo\"\/>\n-    *   <xsl:param name=\"bar\"\/>\n-    *   <xsl:param name=\"zoo\"\/>\n-    * ... the whitespace between every xsl:param would be\n-    * added to the result tree.\n+    * Attribute \"name\".\n@@ -5361,0 +5300,57 @@\n+    prop = xmlGetNsProp(templNode, (const xmlChar *)\"name\", NULL);\n+    if (prop != NULL) {\n+        const xmlChar *nameURI;\n+        xsltTemplatePtr curTempl;\n+\n+        \/*\n+        * TODO: Don't use xsltGetQNameURI().\n+        *\/\n+        nameURI = xsltGetQNameURI(templNode, &prop);\n+        if (prop == NULL) {\n+            cctxt->style->errors++;\n+            goto error;\n+        }\n+        templ->name = xmlDictLookup(cctxt->style->dict, prop, -1);\n+        xmlFree(prop);\n+        prop = NULL;\n+        if (xmlValidateNCName(templ->name, 0)) {\n+            xsltTransformError(NULL, cctxt->style, templNode,\n+                \"xsl:template: Attribute 'name': The local part '%s' of \"\n+                \"the value is not a valid NCName.\\n\", templ->name);\n+            cctxt->style->errors++;\n+            goto error;\n+        }\n+        if (nameURI != NULL)\n+            templ->nameURI = xmlDictLookup(cctxt->style->dict, nameURI, -1);\n+        curTempl = templ->next;\n+        while (curTempl != NULL) {\n+            if ((nameURI != NULL && xmlStrEqual(curTempl->name, templ->name) &&\n+                xmlStrEqual(curTempl->nameURI, nameURI) ) ||\n+                (nameURI == NULL && curTempl->nameURI == NULL &&\n+                xmlStrEqual(curTempl->name, templ->name)))\n+            {\n+                xsltTransformError(NULL, cctxt->style, templNode,\n+                    \"xsl:template: error duplicate name '%s'\\n\", templ->name);\n+                cctxt->style->errors++;\n+                goto error;\n+            }\n+            curTempl = curTempl->next;\n+        }\n+    }\n+    if (templNode->children != NULL) {\n+        xsltParseTemplateContent(cctxt->style, templNode);\n+        \/*\n+        * MAYBE TODO: Custom behaviour: In order to stay compatible with\n+        * Xalan and MSXML(.NET), we could allow whitespace\n+        * to appear before an xml:param element; this whitespace\n+        * will additionally become part of the \"template\".\n+        * NOTE that this is totally deviates from the spec, but\n+        * is the de facto behaviour of Xalan and MSXML(.NET).\n+        * Personally I wouldn't allow this, since if we have:\n+        * <xsl:template ...xml:space=\"preserve\">\n+        *   <xsl:param name=\"foo\"\/>\n+        *   <xsl:param name=\"bar\"\/>\n+        *   <xsl:param name=\"zoo\"\/>\n+        * ... the whitespace between every xsl:param would be\n+        * added to the result tree.\n+        *\/\n@@ -5392,1 +5388,1 @@\n-    return;\n+        return;\n@@ -5399,1 +5395,1 @@\n-    return;\n+        return;\n@@ -5420,14 +5416,14 @@\n-    \/*\n-    * TODO: Don't use xsltGetQNameURI().\n-    *\/\n-    URI = xsltGetQNameURI(template, &prop);\n-    if (prop == NULL) {\n-        if (style != NULL) style->errors++;\n-        goto error;\n-    } else {\n-        mode = prop;\n-        if (URI != NULL)\n-        modeURI = xmlStrdup(URI);\n-    }\n-    ret->mode = xmlDictLookup(style->dict, mode, -1);\n-    ret->modeURI = xmlDictLookup(style->dict, modeURI, -1);\n+        \/*\n+        * TODO: Don't use xsltGetQNameURI().\n+        *\/\n+        URI = xsltGetQNameURI(template, &prop);\n+        if (prop == NULL) {\n+            if (style != NULL) style->errors++;\n+            goto error;\n+        } else {\n+            mode = prop;\n+            if (URI != NULL)\n+                modeURI = xmlStrdup(URI);\n+        }\n+        ret->mode = xmlDictLookup(style->dict, mode, -1);\n+        ret->modeURI = xmlDictLookup(style->dict, modeURI, -1);\n@@ -5435,2 +5431,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-         \"xsltParseStylesheetTemplate: mode %s\\n\", mode);\n+        xsltGenericDebug(xsltGenericDebugContext,\n+             \"xsltParseStylesheetTemplate: mode %s\\n\", mode);\n@@ -5439,1 +5435,1 @@\n-    if (modeURI != NULL) xmlFree(modeURI);\n+        if (modeURI != NULL) xmlFree(modeURI);\n@@ -5443,2 +5439,2 @@\n-    if (ret->match != NULL) xmlFree(ret->match);\n-    ret->match  = prop;\n+        if (ret->match != NULL) xmlFree(ret->match);\n+        ret->match  = prop;\n@@ -5449,3 +5445,3 @@\n-    priority = xmlXPathStringEvalNumber(prop);\n-    ret->priority = (float) priority;\n-    xmlFree(prop);\n+        priority = xmlXPathStringEvalNumber(prop);\n+        ret->priority = (float) priority;\n+        xmlFree(prop);\n@@ -5458,12 +5454,12 @@\n-    \/*\n-    * TODO: Don't use xsltGetQNameURI().\n-    *\/\n-    URI = xsltGetQNameURI(template, &prop);\n-    if (prop == NULL) {\n-        if (style != NULL) style->errors++;\n-        goto error;\n-    } else {\n-        if (xmlValidateNCName(prop,0)) {\n-            xsltTransformError(NULL, style, template,\n-                \"xsl:template : error invalid name '%s'\\n\", prop);\n-        if (style != NULL) style->errors++;\n+        \/*\n+        * TODO: Don't use xsltGetQNameURI().\n+        *\/\n+        URI = xsltGetQNameURI(template, &prop);\n+        if (prop == NULL) {\n+            if (style != NULL) style->errors++;\n+            goto error;\n+        } else {\n+            if (xmlValidateNCName(prop,0)) {\n+                xsltTransformError(NULL, style, template,\n+                    \"xsl:template : error invalid name '%s'\\n\", prop);\n+                if (style != NULL) style->errors++;\n@@ -5471,1 +5467,9 @@\n-        goto error;\n+                goto error;\n+            }\n+            ret->name = xmlDictLookup(style->dict, BAD_CAST prop, -1);\n+            xmlFree(prop);\n+            prop = NULL;\n+            if (URI != NULL)\n+                ret->nameURI = xmlDictLookup(style->dict, BAD_CAST URI, -1);\n+            else\n+                ret->nameURI = NULL;\n@@ -5473,8 +5477,0 @@\n-        ret->name = xmlDictLookup(style->dict, BAD_CAST prop, -1);\n-        xmlFree(prop);\n-        prop = NULL;\n-        if (URI != NULL)\n-        ret->nameURI = xmlDictLookup(style->dict, BAD_CAST URI, -1);\n-        else\n-        ret->nameURI = NULL;\n-    }\n@@ -5511,1 +5507,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -5516,4 +5512,4 @@\n-    xsltTransformError(NULL, cctxt->style, node,\n-        \"xsltIncludeComp : malloc failed\\n\");\n-    cctxt->style->errors++;\n-    return(NULL);\n+        xsltTransformError(NULL, cctxt->style, node,\n+                \"xsltIncludeComp : malloc failed\\n\");\n+        cctxt->style->errors++;\n+        return(NULL);\n@@ -5538,5 +5534,5 @@\n-                  xmlNodePtr cur,\n-                  const xmlChar *name,\n-                  const xmlChar *namespaceURI,\n-                  int breakOnOtherElem,\n-                  xmlNodePtr *resultNode)\n+                              xmlNodePtr cur,\n+                              const xmlChar *name,\n+                              const xmlChar *namespaceURI,\n+                              int breakOnOtherElem,\n+                              xmlNodePtr *resultNode)\n@@ -5545,1 +5541,1 @@\n-    return(-1);\n+        return(-1);\n@@ -5549,9 +5545,12 @@\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        if ((cur->ns != NULL) && (cur->name != NULL)) {\n-        if ((*(cur->name) == *name) &&\n-            xmlStrEqual(cur->name, name) &&\n-            xmlStrEqual(cur->ns->href, namespaceURI))\n-        {\n-            *resultNode = cur;\n-            return(1);\n-        }\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            if ((cur->ns != NULL) && (cur->name != NULL)) {\n+                if ((*(cur->name) == *name) &&\n+                    xmlStrEqual(cur->name, name) &&\n+                    xmlStrEqual(cur->ns->href, namespaceURI))\n+                {\n+                    *resultNode = cur;\n+                    return(1);\n+                }\n+            }\n+            if (breakOnOtherElem)\n+                break;\n@@ -5559,4 +5558,1 @@\n-        if (breakOnOtherElem)\n-        break;\n-    }\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -5570,2 +5566,2 @@\n-              xmlNodePtr node,\n-              xsltStyleType type)\n+                          xmlNodePtr node,\n+                          xsltStyleType type)\n@@ -5586,2 +5582,2 @@\n-    cctxt->inode->inScopeNs =\n-        xsltCompilerBuildInScopeNsList(cctxt, node);\n+        cctxt->inode->inScopeNs =\n+            xsltCompilerBuildInScopeNsList(cctxt, node);\n@@ -5591,3 +5587,3 @@\n-    case XSLT_FUNC_INCLUDE:\n-        {\n-        int oldIsInclude;\n+        case XSLT_FUNC_INCLUDE:\n+            {\n+                int oldIsInclude;\n@@ -5595,7 +5591,7 @@\n-        if (xsltCompileXSLTIncludeElem(cctxt, node) == NULL)\n-            goto exit;\n-        \/*\n-        * Mark this stylesheet tree as being currently included.\n-        *\/\n-        oldIsInclude = cctxt->isInclude;\n-        cctxt->isInclude = 1;\n+                if (xsltCompileXSLTIncludeElem(cctxt, node) == NULL)\n+                    goto exit;\n+                \/*\n+                * Mark this stylesheet tree as being currently included.\n+                *\/\n+                oldIsInclude = cctxt->isInclude;\n+                cctxt->isInclude = 1;\n@@ -5603,1 +5599,21 @@\n-        if (xsltParseStylesheetInclude(cctxt->style, node) != 0) {\n+                if (xsltParseStylesheetInclude(cctxt->style, node) != 0) {\n+                    cctxt->style->errors++;\n+                }\n+                cctxt->isInclude = oldIsInclude;\n+            }\n+            break;\n+        case XSLT_FUNC_PARAM:\n+            xsltStylePreCompute(cctxt->style, node);\n+            xsltParseGlobalParam(cctxt->style, node);\n+            break;\n+        case XSLT_FUNC_VARIABLE:\n+            xsltStylePreCompute(cctxt->style, node);\n+            xsltParseGlobalVariable(cctxt->style, node);\n+            break;\n+        case XSLT_FUNC_ATTRSET:\n+            xsltParseStylesheetAttributeSet(cctxt->style, node);\n+            break;\n+        default:\n+            xsltTransformError(NULL, cctxt->style, node,\n+                \"Internal error: (xsltParseTopLevelXSLTElem) \"\n+                \"Cannot handle this top-level declaration.\\n\");\n@@ -5605,21 +5621,1 @@\n-        }\n-        cctxt->isInclude = oldIsInclude;\n-        }\n-        break;\n-    case XSLT_FUNC_PARAM:\n-        xsltStylePreCompute(cctxt->style, node);\n-        xsltParseGlobalParam(cctxt->style, node);\n-        break;\n-    case XSLT_FUNC_VARIABLE:\n-        xsltStylePreCompute(cctxt->style, node);\n-        xsltParseGlobalVariable(cctxt->style, node);\n-        break;\n-    case XSLT_FUNC_ATTRSET:\n-        xsltParseStylesheetAttributeSet(cctxt->style, node);\n-        break;\n-    default:\n-        xsltTransformError(NULL, cctxt->style, node,\n-        \"Internal error: (xsltParseTopLevelXSLTElem) \"\n-        \"Cannot handle this top-level declaration.\\n\");\n-        cctxt->style->errors++;\n-        ret = -1;\n+            ret = -1;\n@@ -5639,1 +5635,1 @@\n-    return(0);\n+        return(0);\n@@ -5641,1 +5637,1 @@\n-    xmlNodePtr delNode = NULL, child = node->children;\n+        xmlNodePtr delNode = NULL, child = node->children;\n@@ -5643,1 +5639,12 @@\n-    do {\n+        do {\n+            if (delNode) {\n+                xmlUnlinkNode(delNode);\n+                xmlFreeNode(delNode);\n+                delNode = NULL;\n+            }\n+            if (((child->type == XML_TEXT_NODE) ||\n+                 (child->type == XML_CDATA_SECTION_NODE)) &&\n+                (IS_BLANK_NODE(child)))\n+                delNode = child;\n+            child = child->next;\n+        } while (child != NULL);\n@@ -5645,3 +5652,3 @@\n-        xmlUnlinkNode(delNode);\n-        xmlFreeNode(delNode);\n-        delNode = NULL;\n+            xmlUnlinkNode(delNode);\n+            xmlFreeNode(delNode);\n+            delNode = NULL;\n@@ -5649,11 +5656,0 @@\n-        if (((child->type == XML_TEXT_NODE) ||\n-         (child->type == XML_CDATA_SECTION_NODE)) &&\n-        (IS_BLANK_NODE(child)))\n-        delNode = child;\n-        child = child->next;\n-    } while (child != NULL);\n-    if (delNode) {\n-        xmlUnlinkNode(delNode);\n-        xmlFreeNode(delNode);\n-        delNode = NULL;\n-    }\n@@ -5675,2 +5671,2 @@\n-    (node->type != XML_ELEMENT_NODE))\n-    return(-1);\n+        (node->type != XML_ELEMENT_NODE))\n+        return(-1);\n@@ -5686,23 +5682,23 @@\n-    xsltDocumentPtr include;\n-    \/*\n-    * URGENT TODO: Make this work with simplified stylesheets!\n-    *   I.e., when we won't find an xsl:stylesheet element.\n-    *\/\n-    \/*\n-    * This is as include declaration.\n-    *\/\n-    include = ((xsltStyleItemIncludePtr) node->psvi)->include;\n-    if (include == NULL) {\n-        \/* TODO: raise error? *\/\n-        return(-1);\n-    }\n-    \/*\n-    * TODO: Actually an xsl:include should locate an embedded\n-    *  stylesheet as well; so the document-element won't always\n-    *  be the element where the actual stylesheet is rooted at.\n-    *  But such embedded stylesheets are not supported by Libxslt yet.\n-    *\/\n-    node = xmlDocGetRootElement(include->doc);\n-    if (node == NULL) {\n-        return(-1);\n-    }\n+        xsltDocumentPtr include;\n+        \/*\n+        * URGENT TODO: Make this work with simplified stylesheets!\n+        *   I.e., when we won't find an xsl:stylesheet element.\n+        *\/\n+        \/*\n+        * This is as include declaration.\n+        *\/\n+        include = ((xsltStyleItemIncludePtr) node->psvi)->include;\n+        if (include == NULL) {\n+            \/* TODO: raise error? *\/\n+            return(-1);\n+        }\n+        \/*\n+        * TODO: Actually an xsl:include should locate an embedded\n+        *  stylesheet as well; so the document-element won't always\n+        *  be the element where the actual stylesheet is rooted at.\n+        *  But such embedded stylesheets are not supported by Libxslt yet.\n+        *\/\n+        node = xmlDocGetRootElement(include->doc);\n+        if (node == NULL) {\n+            return(-1);\n+        }\n@@ -5712,1 +5708,1 @@\n-    return(0);\n+        return(0);\n@@ -5732,1 +5728,1 @@\n-    xsltCompilerBuildInScopeNsList(cctxt, node);\n+        xsltCompilerBuildInScopeNsList(cctxt, node);\n@@ -5744,1 +5740,1 @@\n-    XSLT_ELEMENT_CATEGORY_XSLT) == 0)\n+        XSLT_ELEMENT_CATEGORY_XSLT) == 0)\n@@ -5746,8 +5742,8 @@\n-    \/*\n-    * Attribute \"version\".\n-    * XSLT 1.0: \"An xsl:stylesheet element *must* have a version\n-    *  attribute, indicating the version of XSLT that the\n-    *  stylesheet requires\".\n-    * The root element of a simplified stylesheet must also have\n-    * this attribute.\n-    *\/\n+        \/*\n+        * Attribute \"version\".\n+        * XSLT 1.0: \"An xsl:stylesheet element *must* have a version\n+        *  attribute, indicating the version of XSLT that the\n+        *  stylesheet requires\".\n+        * The root element of a simplified stylesheet must also have\n+        * this attribute.\n+        *\/\n@@ -5755,4 +5751,4 @@\n-    if (isXsltElem)\n-        xsltTransformError(NULL, cctxt->style, node,\n-        \"The attribute 'version' is missing.\\n\");\n-    cctxt->style->errors++;\n+        if (isXsltElem)\n+            xsltTransformError(NULL, cctxt->style, node,\n+                \"The attribute 'version' is missing.\\n\");\n+        cctxt->style->errors++;\n@@ -5760,4 +5756,4 @@\n-    \/* OLD behaviour. *\/\n-    xsltTransformError(NULL, cctxt->style, node,\n-        \"xsl:version is missing: document may not be a stylesheet\\n\");\n-    cctxt->style->warnings++;\n+        \/* OLD behaviour. *\/\n+        xsltTransformError(NULL, cctxt->style, node,\n+            \"xsl:version is missing: document may not be a stylesheet\\n\");\n+        cctxt->style->warnings++;\n@@ -5776,2 +5772,2 @@\n-    xsltParseExtElemPrefixes(cctxt, node, NULL,\n-        XSLT_ELEMENT_CATEGORY_XSLT);\n+        xsltParseExtElemPrefixes(cctxt, node, NULL,\n+            XSLT_ELEMENT_CATEGORY_XSLT);\n@@ -5782,2 +5778,2 @@\n-    xsltParseExclResultPrefixes(cctxt, node, NULL,\n-        XSLT_ELEMENT_CATEGORY_XSLT);\n+        xsltParseExclResultPrefixes(cctxt, node, NULL,\n+            XSLT_ELEMENT_CATEGORY_XSLT);\n@@ -5788,1 +5784,1 @@\n-    xsltLREInfoCreate(cctxt, node, 0);\n+        xsltLREInfoCreate(cctxt, node, 0);\n@@ -5813,10 +5809,10 @@\n-    if (cur->type == XML_TEXT_NODE) {\n-        xsltTransformError(NULL, style, cur,\n-        \"Misplaced text node (content: '%s').\\n\",\n-        (cur->content != NULL) ? cur->content : BAD_CAST \"\");\n-        style->errors++;\n-    } else if (cur->type != XML_ELEMENT_NODE) {\n-        xsltTransformError(NULL, style, cur, \"Misplaced node.\\n\");\n-        style->errors++;\n-    }\n-    cur = cur->next;\n+        if (cur->type == XML_TEXT_NODE) {\n+            xsltTransformError(NULL, style, cur,\n+                \"Misplaced text node (content: '%s').\\n\",\n+                (cur->content != NULL) ? cur->content : BAD_CAST \"\");\n+            style->errors++;\n+        } else if (cur->type != XML_ELEMENT_NODE) {\n+            xsltTransformError(NULL, style, cur, \"Misplaced node.\\n\");\n+            style->errors++;\n+        }\n+        cur = cur->next;\n@@ -5830,2 +5826,2 @@\n-        BAD_CAST \"import\", XSLT_NAMESPACE, 1, &cur) == 1)\n-    cur = cur->next;\n+            BAD_CAST \"import\", XSLT_NAMESPACE, 1, &cur) == 1)\n+        cur = cur->next;\n@@ -5833,1 +5829,1 @@\n-    goto exit;\n+        goto exit;\n@@ -5840,2 +5836,2 @@\n-    xsltParseFindTopLevelElem(cctxt, cur,\n-    BAD_CAST \"param\", XSLT_NAMESPACE, 0, &cur) == 1)\n+        xsltParseFindTopLevelElem(cctxt, cur,\n+        BAD_CAST \"param\", XSLT_NAMESPACE, 0, &cur) == 1)\n@@ -5843,2 +5839,2 @@\n-    xsltParseTopLevelXSLTElem(cctxt, cur, XSLT_FUNC_PARAM);\n-    cur = cur->next;\n+        xsltParseTopLevelXSLTElem(cctxt, cur, XSLT_FUNC_PARAM);\n+        cur = cur->next;\n@@ -5851,2 +5847,2 @@\n-    xsltParseFindTopLevelElem(cctxt, cur,\n-    BAD_CAST \"variable\", XSLT_NAMESPACE, 0, &cur) == 1)\n+        xsltParseFindTopLevelElem(cctxt, cur,\n+        BAD_CAST \"variable\", XSLT_NAMESPACE, 0, &cur) == 1)\n@@ -5854,2 +5850,2 @@\n-    xsltParseTopLevelXSLTElem(cctxt, cur, XSLT_FUNC_VARIABLE);\n-    cur = cur->next;\n+        xsltParseTopLevelXSLTElem(cctxt, cur, XSLT_FUNC_VARIABLE);\n+        cur = cur->next;\n@@ -5862,25 +5858,0 @@\n-    \/*\n-    * Process element nodes.\n-    *\/\n-    if (cur->type == XML_ELEMENT_NODE) {\n-        if (cur->ns == NULL) {\n-        xsltTransformError(NULL, style, cur,\n-            \"Unexpected top-level element in no namespace.\\n\");\n-        style->errors++;\n-        cur = cur->next;\n-        continue;\n-        }\n-        \/*\n-        * Process all XSLT elements.\n-        *\/\n-        if (IS_XSLT_ELEM_FAST(cur)) {\n-        \/*\n-        * xsl:import is only allowed at the beginning.\n-        *\/\n-        if (IS_XSLT_NAME(cur, \"import\")) {\n-            xsltTransformError(NULL, style, cur,\n-            \"Misplaced xsl:import element.\\n\");\n-            style->errors++;\n-            cur = cur->next;\n-            continue;\n-        }\n@@ -5888,2 +5859,1 @@\n-        * TODO: Change the return type of the parsing functions\n-        *  to int.\n+        * Process element nodes.\n@@ -5891,23 +5861,7 @@\n-        if (IS_XSLT_NAME(cur, \"template\")) {\n-#ifdef WITH_XSLT_DEBUG_PARSING\n-            templates++;\n-#endif\n-            \/*\n-            * TODO: Is the position of xsl:template in the\n-            *  tree significant? If not it would be easier to\n-            *  parse them at a later stage.\n-            *\/\n-            xsltParseXSLTTemplate(cctxt, cur);\n-        } else if (IS_XSLT_NAME(cur, \"variable\")) {\n-            \/* NOP; done already *\/\n-        } else if (IS_XSLT_NAME(cur, \"param\")) {\n-            \/* NOP; done already *\/\n-        } else if (IS_XSLT_NAME(cur, \"include\")) {\n-            if (cur->psvi != NULL)\n-            xsltParseXSLTStylesheetElemCore(cctxt, cur);\n-            else {\n-            xsltTransformError(NULL, style, cur,\n-                \"Internal error: \"\n-                \"(xsltParseXSLTStylesheetElemCore) \"\n-                \"The xsl:include element was not compiled.\\n\");\n-            style->errors++;\n+        if (cur->type == XML_ELEMENT_NODE) {\n+            if (cur->ns == NULL) {\n+                xsltTransformError(NULL, style, cur,\n+                    \"Unexpected top-level element in no namespace.\\n\");\n+                style->errors++;\n+                cur = cur->next;\n+                continue;\n@@ -5915,22 +5869,0 @@\n-        } else if (IS_XSLT_NAME(cur, \"strip-space\")) {\n-            \/* No node info needed. *\/\n-            xsltParseStylesheetStripSpace(style, cur);\n-        } else if (IS_XSLT_NAME(cur, \"preserve-space\")) {\n-            \/* No node info needed. *\/\n-            xsltParseStylesheetPreserveSpace(style, cur);\n-        } else if (IS_XSLT_NAME(cur, \"output\")) {\n-            \/* No node-info needed. *\/\n-            xsltParseStylesheetOutput(style, cur);\n-        } else if (IS_XSLT_NAME(cur, \"key\")) {\n-            \/* TODO: node-info needed for expressions ? *\/\n-            xsltParseStylesheetKey(style, cur);\n-        } else if (IS_XSLT_NAME(cur, \"decimal-format\")) {\n-            \/* No node-info needed. *\/\n-            xsltParseStylesheetDecimalFormat(style, cur);\n-        } else if (IS_XSLT_NAME(cur, \"attribute-set\")) {\n-            xsltParseTopLevelXSLTElem(cctxt, cur,\n-            XSLT_FUNC_ATTRSET);\n-        } else if (IS_XSLT_NAME(cur, \"namespace-alias\")) {\n-            \/* NOP; done already *\/\n-        } else {\n-            if (cctxt->inode->forwardsCompat) {\n@@ -5938,9 +5870,1 @@\n-            * Forwards-compatible mode:\n-            *\n-            * XSLT-1: \"if it is a top-level element and\n-            *  XSLT 1.0 does not allow such elements as top-level\n-            *  elements, then the element must be ignored along\n-            *  with its content;\"\n-            *\/\n-            \/*\n-            * TODO: I don't think we should generate a warning.\n+            * Process all XSLT elements.\n@@ -5948,4 +5872,82 @@\n-            xsltTransformError(NULL, style, cur,\n-                \"Forwards-compatible mode: Ignoring unknown XSLT \"\n-                \"element '%s'.\\n\", cur->name);\n-            style->warnings++;\n+            if (IS_XSLT_ELEM_FAST(cur)) {\n+                \/*\n+                * xsl:import is only allowed at the beginning.\n+                *\/\n+                if (IS_XSLT_NAME(cur, \"import\")) {\n+                    xsltTransformError(NULL, style, cur,\n+                        \"Misplaced xsl:import element.\\n\");\n+                    style->errors++;\n+                    cur = cur->next;\n+                    continue;\n+                }\n+                \/*\n+                * TODO: Change the return type of the parsing functions\n+                *  to int.\n+                *\/\n+                if (IS_XSLT_NAME(cur, \"template\")) {\n+#ifdef WITH_XSLT_DEBUG_PARSING\n+                    templates++;\n+#endif\n+                    \/*\n+                    * TODO: Is the position of xsl:template in the\n+                    *  tree significant? If not it would be easier to\n+                    *  parse them at a later stage.\n+                    *\/\n+                    xsltParseXSLTTemplate(cctxt, cur);\n+                } else if (IS_XSLT_NAME(cur, \"variable\")) {\n+                    \/* NOP; done already *\/\n+                } else if (IS_XSLT_NAME(cur, \"param\")) {\n+                    \/* NOP; done already *\/\n+                } else if (IS_XSLT_NAME(cur, \"include\")) {\n+                    if (cur->psvi != NULL)\n+                        xsltParseXSLTStylesheetElemCore(cctxt, cur);\n+                    else {\n+                        xsltTransformError(NULL, style, cur,\n+                            \"Internal error: \"\n+                            \"(xsltParseXSLTStylesheetElemCore) \"\n+                            \"The xsl:include element was not compiled.\\n\");\n+                        style->errors++;\n+                    }\n+                } else if (IS_XSLT_NAME(cur, \"strip-space\")) {\n+                    \/* No node info needed. *\/\n+                    xsltParseStylesheetStripSpace(style, cur);\n+                } else if (IS_XSLT_NAME(cur, \"preserve-space\")) {\n+                    \/* No node info needed. *\/\n+                    xsltParseStylesheetPreserveSpace(style, cur);\n+                } else if (IS_XSLT_NAME(cur, \"output\")) {\n+                    \/* No node-info needed. *\/\n+                    xsltParseStylesheetOutput(style, cur);\n+                } else if (IS_XSLT_NAME(cur, \"key\")) {\n+                    \/* TODO: node-info needed for expressions ? *\/\n+                    xsltParseStylesheetKey(style, cur);\n+                } else if (IS_XSLT_NAME(cur, \"decimal-format\")) {\n+                    \/* No node-info needed. *\/\n+                    xsltParseStylesheetDecimalFormat(style, cur);\n+                } else if (IS_XSLT_NAME(cur, \"attribute-set\")) {\n+                    xsltParseTopLevelXSLTElem(cctxt, cur,\n+                        XSLT_FUNC_ATTRSET);\n+                } else if (IS_XSLT_NAME(cur, \"namespace-alias\")) {\n+                    \/* NOP; done already *\/\n+                } else {\n+                    if (cctxt->inode->forwardsCompat) {\n+                        \/*\n+                        * Forwards-compatible mode:\n+                        *\n+                        * XSLT-1: \"if it is a top-level element and\n+                        *  XSLT 1.0 does not allow such elements as top-level\n+                        *  elements, then the element must be ignored along\n+                        *  with its content;\"\n+                        *\/\n+                        \/*\n+                        * TODO: I don't think we should generate a warning.\n+                        *\/\n+                        xsltTransformError(NULL, style, cur,\n+                            \"Forwards-compatible mode: Ignoring unknown XSLT \"\n+                            \"element '%s'.\\n\", cur->name);\n+                        style->warnings++;\n+                    } else {\n+                        xsltTransformError(NULL, style, cur,\n+                            \"Unknown XSLT element '%s'.\\n\", cur->name);\n+                        style->errors++;\n+                    }\n+                }\n@@ -5953,7 +5955,1 @@\n-            xsltTransformError(NULL, style, cur,\n-                \"Unknown XSLT element '%s'.\\n\", cur->name);\n-            style->errors++;\n-            }\n-        }\n-        } else {\n-        xsltTopLevelFunction function;\n+                xsltTopLevelFunction function;\n@@ -5961,12 +5957,12 @@\n-        \/*\n-        * Process non-XSLT elements, which are in a\n-        *  non-NULL namespace.\n-        *\/\n-        \/*\n-        * QUESTION: What does xsltExtModuleTopLevelLookup()\n-        *  do exactly?\n-        *\/\n-        function = xsltExtModuleTopLevelLookup(cur->name,\n-            cur->ns->href);\n-        if (function != NULL)\n-            function(style, cur);\n+                \/*\n+                * Process non-XSLT elements, which are in a\n+                *  non-NULL namespace.\n+                *\/\n+                \/*\n+                * QUESTION: What does xsltExtModuleTopLevelLookup()\n+                *  do exactly?\n+                *\/\n+                function = xsltExtModuleTopLevelLookup(cur->name,\n+                    cur->ns->href);\n+                if (function != NULL)\n+                    function(style, cur);\n@@ -5974,3 +5970,3 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltParseXSLTStylesheetElemCore : User-defined \"\n-            \"data element '%s'.\\n\", cur->name);\n+                xsltGenericDebug(xsltGenericDebugContext,\n+                    \"xsltParseXSLTStylesheetElemCore : User-defined \"\n+                    \"data element '%s'.\\n\", cur->name);\n@@ -5978,0 +5974,1 @@\n+            }\n@@ -5979,2 +5976,1 @@\n-    }\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -5987,2 +5983,2 @@\n-    \"### END of parsing top-level elements of doc '%s'.\\n\",\n-    node->doc->URL);\n+        \"### END of parsing top-level elements of doc '%s'.\\n\",\n+        node->doc->URL);\n@@ -5990,1 +5986,1 @@\n-    \"### Templates: %d\\n\", templates);\n+        \"### Templates: %d\\n\", templates);\n@@ -5993,1 +5989,1 @@\n-    \"### Max inodes: %d\\n\", cctxt->maxNodeInfos);\n+        \"### Max inodes: %d\\n\", cctxt->maxNodeInfos);\n@@ -5995,1 +5991,1 @@\n-    \"### Max LREs  : %d\\n\", cctxt->maxLREs);\n+        \"### Max LREs  : %d\\n\", cctxt->maxLREs);\n@@ -6031,1 +6027,1 @@\n-    return(-1);\n+        return(-1);\n@@ -6034,1 +6030,1 @@\n-    goto exit;\n+        goto exit;\n@@ -6049,2 +6045,2 @@\n-    xsltParseFindTopLevelElem(cctxt, cur,\n-        BAD_CAST \"import\", XSLT_NAMESPACE, 1, &cur) == 1)\n+        xsltParseFindTopLevelElem(cctxt, cur,\n+            BAD_CAST \"import\", XSLT_NAMESPACE, 1, &cur) == 1)\n@@ -6052,4 +6048,4 @@\n-    if (xsltParseStylesheetImport(cctxt->style, cur) != 0) {\n-        cctxt->style->errors++;\n-    }\n-    cur = cur->next;\n+        if (xsltParseStylesheetImport(cctxt->style, cur) != 0) {\n+            cctxt->style->errors++;\n+        }\n+        cur = cur->next;\n@@ -6058,1 +6054,1 @@\n-    goto exit;\n+        goto exit;\n@@ -6065,2 +6061,2 @@\n-    xsltParseFindTopLevelElem(cctxt, cur,\n-        BAD_CAST \"include\", XSLT_NAMESPACE, 0, &cur) == 1)\n+        xsltParseFindTopLevelElem(cctxt, cur,\n+            BAD_CAST \"include\", XSLT_NAMESPACE, 0, &cur) == 1)\n@@ -6068,2 +6064,2 @@\n-    xsltParseTopLevelXSLTElem(cctxt, cur, XSLT_FUNC_INCLUDE);\n-    cur = cur->next;\n+        xsltParseTopLevelXSLTElem(cctxt, cur, XSLT_FUNC_INCLUDE);\n+        cur = cur->next;\n@@ -6078,2 +6074,2 @@\n-    xsltParseFindTopLevelElem(cctxt, cur,\n-        BAD_CAST \"namespace-alias\", XSLT_NAMESPACE, 0, &cur) == 1)\n+        xsltParseFindTopLevelElem(cctxt, cur,\n+            BAD_CAST \"namespace-alias\", XSLT_NAMESPACE, 0, &cur) == 1)\n@@ -6081,2 +6077,2 @@\n-    xsltNamespaceAlias(cctxt->style, cur);\n-    cur = cur->next;\n+        xsltNamespaceAlias(cctxt->style, cur);\n+        cur = cur->next;\n@@ -6086,5 +6082,5 @@\n-    \/*\n-    * If this stylesheet is intended for inclusion, then\n-    * we will process only imports and includes.\n-    *\/\n-    goto exit;\n+        \/*\n+        * If this stylesheet is intended for inclusion, then\n+        * we will process only imports and includes.\n+        *\/\n+        goto exit;\n@@ -6119,1 +6115,1 @@\n-    return;\n+        return;\n@@ -6123,3 +6119,3 @@\n-    xsltTransformError(NULL, style, top,\n-        \"xsl:version is missing: document may not be a stylesheet\\n\");\n-    if (style != NULL) style->warnings++;\n+        xsltTransformError(NULL, style, top,\n+            \"xsl:version is missing: document may not be a stylesheet\\n\");\n+        if (style != NULL) style->warnings++;\n@@ -6127,1 +6123,1 @@\n-    if ((!xmlStrEqual(prop, (const xmlChar *)\"1.0\")) &&\n+        if ((!xmlStrEqual(prop, (const xmlChar *)\"1.0\")) &&\n@@ -6129,3 +6125,3 @@\n-        xsltTransformError(NULL, style, top,\n-        \"xsl:version: only 1.1 features are supported\\n\");\n-        if (style != NULL) {\n+            xsltTransformError(NULL, style, top,\n+                \"xsl:version: only 1.1 features are supported\\n\");\n+            if (style != NULL) {\n@@ -6135,2 +6131,2 @@\n-    }\n-    xmlFree(prop);\n+        }\n+        xmlFree(prop);\n@@ -6144,1 +6140,9 @@\n-        if (IS_BLANK_NODE(cur)) {\n+            if (IS_BLANK_NODE(cur)) {\n+                    cur = cur->next;\n+                    continue;\n+            }\n+            if (IS_XSLT_ELEM(cur) && IS_XSLT_NAME(cur, \"import\")) {\n+                    if (xsltParseStylesheetImport(style, cur) != 0)\n+                            if (style != NULL) style->errors++;\n+            } else\n+                    break;\n@@ -6146,8 +6150,0 @@\n-            continue;\n-        }\n-        if (IS_XSLT_ELEM(cur) && IS_XSLT_NAME(cur, \"import\")) {\n-            if (xsltParseStylesheetImport(style, cur) != 0)\n-                if (style != NULL) style->errors++;\n-        } else\n-            break;\n-        cur = cur->next;\n@@ -6160,8 +6156,3 @@\n-    if (IS_BLANK_NODE(cur)) {\n-        cur = cur->next;\n-        continue;\n-    }\n-    if (cur->type == XML_TEXT_NODE) {\n-        if (cur->content != NULL) {\n-        xsltTransformError(NULL, style, cur,\n-            \"misplaced text node: '%s'\\n\", cur->content);\n+        if (IS_BLANK_NODE(cur)) {\n+            cur = cur->next;\n+            continue;\n@@ -6169,1 +6160,6 @@\n-        if (style != NULL) style->errors++;\n+        if (cur->type == XML_TEXT_NODE) {\n+            if (cur->content != NULL) {\n+                xsltTransformError(NULL, style, cur,\n+                    \"misplaced text node: '%s'\\n\", cur->content);\n+            }\n+            if (style != NULL) style->errors++;\n@@ -6171,12 +6167,12 @@\n-        continue;\n-    }\n-    if ((cur->type == XML_ELEMENT_NODE) && (cur->ns == NULL)) {\n-        xsltGenericError(xsltGenericErrorContext,\n-             \"Found a top-level element %s with null namespace URI\\n\",\n-             cur->name);\n-        if (style != NULL) style->errors++;\n-        cur = cur->next;\n-        continue;\n-    }\n-    if ((cur->type == XML_ELEMENT_NODE) && (!(IS_XSLT_ELEM(cur)))) {\n-        xsltTopLevelFunction function;\n+            continue;\n+        }\n+        if ((cur->type == XML_ELEMENT_NODE) && (cur->ns == NULL)) {\n+            xsltGenericError(xsltGenericErrorContext,\n+                     \"Found a top-level element %s with null namespace URI\\n\",\n+                     cur->name);\n+            if (style != NULL) style->errors++;\n+            cur = cur->next;\n+            continue;\n+        }\n+        if ((cur->type == XML_ELEMENT_NODE) && (!(IS_XSLT_ELEM(cur)))) {\n+            xsltTopLevelFunction function;\n@@ -6184,4 +6180,4 @@\n-        function = xsltExtModuleTopLevelLookup(cur->name,\n-                           cur->ns->href);\n-        if (function != NULL)\n-        function(style, cur);\n+            function = xsltExtModuleTopLevelLookup(cur->name,\n+                                                   cur->ns->href);\n+            if (function != NULL)\n+                function(style, cur);\n@@ -6190,3 +6186,3 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltParseStylesheetTop : found foreign element %s\\n\",\n-            cur->name);\n+            xsltGenericDebug(xsltGenericDebugContext,\n+                    \"xsltParseStylesheetTop : found foreign element %s\\n\",\n+                    cur->name);\n@@ -6195,6 +6191,6 @@\n-        continue;\n-    }\n-    if (IS_XSLT_NAME(cur, \"import\")) {\n-        xsltTransformError(NULL, style, cur,\n-            \"xsltParseStylesheetTop: ignoring misplaced import element\\n\");\n-        if (style != NULL) style->errors++;\n+            continue;\n+        }\n+        if (IS_XSLT_NAME(cur, \"import\")) {\n+            xsltTransformError(NULL, style, cur,\n+                        \"xsltParseStylesheetTop: ignoring misplaced import element\\n\");\n+            if (style != NULL) style->errors++;\n@@ -6202,2 +6198,2 @@\n-        if (xsltParseStylesheetInclude(style, cur) != 0)\n-        if (style != NULL) style->errors++;\n+            if (xsltParseStylesheetInclude(style, cur) != 0)\n+                if (style != NULL) style->errors++;\n@@ -6205,1 +6201,1 @@\n-        xsltParseStylesheetStripSpace(style, cur);\n+            xsltParseStylesheetStripSpace(style, cur);\n@@ -6207,1 +6203,1 @@\n-        xsltParseStylesheetPreserveSpace(style, cur);\n+            xsltParseStylesheetPreserveSpace(style, cur);\n@@ -6209,1 +6205,1 @@\n-        xsltParseStylesheetOutput(style, cur);\n+            xsltParseStylesheetOutput(style, cur);\n@@ -6211,1 +6207,1 @@\n-        xsltParseStylesheetKey(style, cur);\n+            xsltParseStylesheetKey(style, cur);\n@@ -6213,1 +6209,1 @@\n-        xsltParseStylesheetDecimalFormat(style, cur);\n+            xsltParseStylesheetDecimalFormat(style, cur);\n@@ -6215,1 +6211,1 @@\n-        xsltParseStylesheetAttributeSet(style, cur);\n+            xsltParseStylesheetAttributeSet(style, cur);\n@@ -6217,1 +6213,1 @@\n-        xsltParseGlobalVariable(style, cur);\n+            xsltParseGlobalVariable(style, cur);\n@@ -6219,1 +6215,1 @@\n-        xsltParseGlobalParam(style, cur);\n+            xsltParseGlobalParam(style, cur);\n@@ -6222,1 +6218,1 @@\n-        templates++;\n+            templates++;\n@@ -6224,1 +6220,1 @@\n-        xsltParseStylesheetTemplate(style, cur);\n+            xsltParseStylesheetTemplate(style, cur);\n@@ -6226,2 +6222,2 @@\n-        xsltNamespaceAlias(style, cur);\n-    } else {\n+            xsltNamespaceAlias(style, cur);\n+        } else {\n@@ -6229,4 +6225,5 @@\n-            xsltTransformError(NULL, style, cur,\n-            \"xsltParseStylesheetTop: unknown %s element\\n\",\n-            cur->name);\n-            if (style != NULL) style->errors++;\n+                xsltTransformError(NULL, style, cur,\n+                        \"xsltParseStylesheetTop: unknown %s element\\n\",\n+                        cur->name);\n+                if (style != NULL) style->errors++;\n+            }\n@@ -6234,2 +6231,1 @@\n-    }\n-    cur = cur->next;\n+        cur = cur->next;\n@@ -6239,1 +6235,1 @@\n-            \"parsed %d templates\\n\", templates);\n+                    \"parsed %d templates\\n\", templates);\n@@ -6258,2 +6254,2 @@\n-                  xmlDocPtr doc,\n-                  xmlNodePtr node)\n+                                  xmlDocPtr doc,\n+                                  xmlNodePtr node)\n@@ -6264,1 +6260,1 @@\n-    return(-1);\n+        return(-1);\n@@ -6268,9 +6264,9 @@\n-    \/*\n-    * TODO: Adjust report, since this might be an\n-    * embedded stylesheet.\n-    *\/\n-    xsltTransformError(NULL, cctxt->style, node,\n-        \"The attribute 'xsl:version' is missing; cannot identify \"\n-        \"this document as an XSLT stylesheet document.\\n\");\n-    cctxt->style->errors++;\n-    return(1);\n+        \/*\n+        * TODO: Adjust report, since this might be an\n+        * embedded stylesheet.\n+        *\/\n+        xsltTransformError(NULL, cctxt->style, node,\n+            \"The attribute 'xsl:version' is missing; cannot identify \"\n+            \"this document as an XSLT stylesheet document.\\n\");\n+        cctxt->style->errors++;\n+        return(1);\n@@ -6281,1 +6277,1 @@\n-    \"xsltParseSimplifiedStylesheetTree: document is stylesheet\\n\");\n+        \"xsltParseSimplifiedStylesheetTree: document is stylesheet\\n\");\n@@ -6289,1 +6285,1 @@\n-    return(-1);\n+        return(-1);\n@@ -6307,1 +6303,1 @@\n-    xsltCompilerBuildInScopeNsList(cctxt, node);\n+        xsltCompilerBuildInScopeNsList(cctxt, node);\n@@ -6335,1 +6331,1 @@\n-    return(-1);\n+        return(-1);\n@@ -6341,6 +6337,6 @@\n-    if ((ns->doc == doc) && (ns->ns != NULL)) {\n-        ns->ns->href = ns->origNsName;\n-        ns->origNsName = NULL;\n-        ns->ns = NULL;\n-    }\n-    ns = ns->next;\n+        if ((ns->doc == doc) && (ns->ns != NULL)) {\n+            ns->ns->href = ns->origNsName;\n+            ns->origNsName = NULL;\n+            ns->ns = NULL;\n+        }\n+        ns = ns->next;\n@@ -6375,1 +6371,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6381,3 +6377,3 @@\n-    xsltTransformError(NULL, style, (xmlNodePtr) doc,\n-        \"xsltParseStylesheetProcess : empty stylesheet\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, style, (xmlNodePtr) doc,\n+                \"xsltParseStylesheetProcess : empty stylesheet\\n\");\n+        return(NULL);\n@@ -6388,2 +6384,2 @@\n-    ((IS_XSLT_NAME(cur, \"stylesheet\")) ||\n-     (IS_XSLT_NAME(cur, \"transform\")))) {\n+        ((IS_XSLT_NAME(cur, \"stylesheet\")) ||\n+         (IS_XSLT_NAME(cur, \"transform\")))) {\n@@ -6391,2 +6387,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-        \"xsltParseStylesheetProcess : found stylesheet\\n\");\n+        xsltGenericDebug(xsltGenericDebugContext,\n+                \"xsltParseStylesheetProcess : found stylesheet\\n\");\n@@ -6394,2 +6390,2 @@\n-    cctxt->simplified = 0;\n-    style->literal_result = 0;\n+        cctxt->simplified = 0;\n+        style->literal_result = 0;\n@@ -6397,2 +6393,2 @@\n-    cctxt->simplified = 1;\n-    style->literal_result = 1;\n+        cctxt->simplified = 1;\n+        style->literal_result = 1;\n@@ -6406,1 +6402,1 @@\n-    xsltParsePreprocessStylesheetTree(cctxt, cur);\n+        xsltParsePreprocessStylesheetTree(cctxt, cur);\n@@ -6411,2 +6407,2 @@\n-    if (xsltParseXSLTStylesheetElem(cctxt, cur) != 0)\n-        return(NULL);\n+        if (xsltParseXSLTStylesheetElem(cctxt, cur) != 0)\n+            return(NULL);\n@@ -6414,2 +6410,2 @@\n-    if (xsltParseSimplifiedStylesheetTree(cctxt, doc, cur) != 0)\n-        return(NULL);\n+        if (xsltParseSimplifiedStylesheetTree(cctxt, doc, cur) != 0)\n+            return(NULL);\n@@ -6445,1 +6441,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6447,1 +6443,1 @@\n-    return(ret);\n+        return(ret);\n@@ -6456,3 +6452,3 @@\n-    xsltTransformError(NULL, ret, (xmlNodePtr) doc,\n-        \"xsltParseStylesheetProcess : empty stylesheet\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, ret, (xmlNodePtr) doc,\n+                \"xsltParseStylesheetProcess : empty stylesheet\\n\");\n+        return(NULL);\n@@ -6462,2 +6458,2 @@\n-    ((IS_XSLT_NAME(cur, \"stylesheet\")) ||\n-     (IS_XSLT_NAME(cur, \"transform\")))) {\n+        ((IS_XSLT_NAME(cur, \"stylesheet\")) ||\n+         (IS_XSLT_NAME(cur, \"transform\")))) {\n@@ -6465,2 +6461,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-        \"xsltParseStylesheetProcess : found stylesheet\\n\");\n+        xsltGenericDebug(xsltGenericDebugContext,\n+                \"xsltParseStylesheetProcess : found stylesheet\\n\");\n@@ -6468,3 +6464,3 @@\n-    ret->literal_result = 0;\n-    xsltParseStylesheetExcludePrefix(ret, cur, 1);\n-    xsltParseStylesheetExtPrefix(ret, cur, 1);\n+        ret->literal_result = 0;\n+        xsltParseStylesheetExcludePrefix(ret, cur, 1);\n+        xsltParseStylesheetExtPrefix(ret, cur, 1);\n@@ -6472,3 +6468,3 @@\n-    xsltParseStylesheetExcludePrefix(ret, cur, 0);\n-    xsltParseStylesheetExtPrefix(ret, cur, 0);\n-    ret->literal_result = 1;\n+        xsltParseStylesheetExcludePrefix(ret, cur, 0);\n+        xsltParseStylesheetExtPrefix(ret, cur, 0);\n+        ret->literal_result = 1;\n@@ -6477,1 +6473,1 @@\n-    xsltPreprocessStylesheet(ret, cur);\n+        xsltPreprocessStylesheet(ret, cur);\n@@ -6480,1 +6476,1 @@\n-    xsltParseStylesheetTop(ret, cur);\n+        xsltParseStylesheetTop(ret, cur);\n@@ -6482,2 +6478,2 @@\n-    xmlChar *prop;\n-    xsltTemplatePtr template;\n+        xmlChar *prop;\n+        xsltTemplatePtr template;\n@@ -6485,9 +6481,9 @@\n-    \/*\n-     * the document itself might be the template, check xsl:version\n-     *\/\n-    prop = xmlGetNsProp(cur, (const xmlChar *)\"version\", XSLT_NAMESPACE);\n-    if (prop == NULL) {\n-        xsltTransformError(NULL, ret, cur,\n-        \"xsltParseStylesheetProcess : document is not a stylesheet\\n\");\n-        return(NULL);\n-    }\n+        \/*\n+         * the document itself might be the template, check xsl:version\n+         *\/\n+        prop = xmlGetNsProp(cur, (const xmlChar *)\"version\", XSLT_NAMESPACE);\n+        if (prop == NULL) {\n+            xsltTransformError(NULL, ret, cur,\n+                \"xsltParseStylesheetProcess : document is not a stylesheet\\n\");\n+            return(NULL);\n+        }\n@@ -6497,1 +6493,1 @@\n-        \"xsltParseStylesheetProcess : document is stylesheet\\n\");\n+                \"xsltParseStylesheetProcess : document is stylesheet\\n\");\n@@ -6500,1 +6496,1 @@\n-    if ((!xmlStrEqual(prop, (const xmlChar *)\"1.0\")) &&\n+        if ((!xmlStrEqual(prop, (const xmlChar *)\"1.0\")) &&\n@@ -6502,2 +6498,2 @@\n-        xsltTransformError(NULL, ret, cur,\n-        \"xsl:version: only 1.1 features are supported\\n\");\n+            xsltTransformError(NULL, ret, cur,\n+                \"xsl:version: only 1.1 features are supported\\n\");\n@@ -6505,3 +6501,3 @@\n-        ret->warnings++;\n-    }\n-    xmlFree(prop);\n+            ret->warnings++;\n+        }\n+        xmlFree(prop);\n@@ -6509,10 +6505,10 @@\n-    \/*\n-     * Create and link the template\n-     *\/\n-    template = xsltNewTemplate();\n-    if (template == NULL) {\n-        return(NULL);\n-    }\n-    template->next = ret->templates;\n-    ret->templates = template;\n-    template->match = xmlStrdup((const xmlChar *)\"\/\");\n+        \/*\n+         * Create and link the template\n+         *\/\n+        template = xsltNewTemplate();\n+        if (template == NULL) {\n+            return(NULL);\n+        }\n+        template->next = ret->templates;\n+        ret->templates = template;\n+        template->match = xmlStrdup((const xmlChar *)\"\/\");\n@@ -6520,8 +6516,8 @@\n-    \/*\n-     * parse the content and register the pattern\n-     *\/\n-    xsltParseTemplateContent(ret, (xmlNodePtr) doc);\n-    template->elem = (xmlNodePtr) doc;\n-    template->content = doc->children;\n-    xsltAddTemplate(ret, template, NULL, NULL);\n-    ret->literal_result = 1;\n+        \/*\n+         * parse the content and register the pattern\n+         *\/\n+        xsltParseTemplateContent(ret, (xmlNodePtr) doc);\n+        template->elem = (xmlNodePtr) doc;\n+        template->content = doc->children;\n+        xsltAddTemplate(ret, template, NULL, NULL);\n+        ret->literal_result = 1;\n@@ -6548,1 +6544,1 @@\n-                   xsltStylesheetPtr parentStyle) {\n+                               xsltStylesheetPtr parentStyle) {\n@@ -6552,1 +6548,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6556,1 +6552,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6578,1 +6574,1 @@\n-    return(-1);\n+        return(-1);\n@@ -6585,1 +6581,1 @@\n-    style->dict = doc->dict;\n+        style->dict = doc->dict;\n@@ -6588,2 +6584,2 @@\n-        \"reusing dictionary from %s for stylesheet\\n\",\n-        doc->URL);\n+            \"reusing dictionary from %s for stylesheet\\n\",\n+            doc->URL);\n@@ -6591,1 +6587,1 @@\n-    xmlDictReference(style->dict);\n+        xmlDictReference(style->dict);\n@@ -6602,2 +6598,2 @@\n-    xsltCompilerCtxtPtr cctxt;\n-    xsltStylesheetPtr oldCurSheet;\n+        xsltCompilerCtxtPtr cctxt;\n+        xsltStylesheetPtr oldCurSheet;\n@@ -6605,8 +6601,36 @@\n-    if (style->parent == NULL) {\n-        xsltPrincipalStylesheetDataPtr principalData;\n-        \/*\n-        * Create extra data for the principal stylesheet.\n-        *\/\n-        principalData = xsltNewPrincipalStylesheetData();\n-        if (principalData == NULL) {\n-        return(-1);\n+        if (style->parent == NULL) {\n+            xsltPrincipalStylesheetDataPtr principalData;\n+            \/*\n+            * Create extra data for the principal stylesheet.\n+            *\/\n+            principalData = xsltNewPrincipalStylesheetData();\n+            if (principalData == NULL) {\n+                return(-1);\n+            }\n+            style->principalData = principalData;\n+            \/*\n+            * Create the compilation context\n+            * ------------------------------\n+            * (only once; for the principal stylesheet).\n+            * This is currently the only function where the\n+            * compilation context is created.\n+            *\/\n+            cctxt = xsltCompilationCtxtCreate(style);\n+            if (cctxt == NULL) {\n+                return(-1);\n+            }\n+            style->compCtxt = (void *) cctxt;\n+            cctxt->style = style;\n+            cctxt->dict = style->dict;\n+            cctxt->psData = principalData;\n+            \/*\n+            * Push initial dummy node info.\n+            *\/\n+            cctxt->depth = -1;\n+            xsltCompilerNodePush(cctxt, (xmlNodePtr) doc);\n+        } else {\n+            \/*\n+            * Imported stylesheet.\n+            *\/\n+            cctxt = style->parent->compCtxt;\n+            style->compCtxt = cctxt;\n@@ -6614,1 +6638,0 @@\n-        style->principalData = principalData;\n@@ -6616,5 +6639,2 @@\n-        * Create the compilation context\n-        * ------------------------------\n-        * (only once; for the principal stylesheet).\n-        * This is currently the only function where the\n-        * compilation context is created.\n+        * Save the old and set the current stylesheet structure in the\n+        * compilation context.\n@@ -6622,5 +6642,1 @@\n-        cctxt = xsltCompilationCtxtCreate(style);\n-        if (cctxt == NULL) {\n-        return(-1);\n-        }\n-        style->compCtxt = (void *) cctxt;\n+        oldCurSheet = cctxt->style;\n@@ -6628,20 +6644,0 @@\n-        cctxt->dict = style->dict;\n-        cctxt->psData = principalData;\n-        \/*\n-        * Push initial dummy node info.\n-        *\/\n-        cctxt->depth = -1;\n-        xsltCompilerNodePush(cctxt, (xmlNodePtr) doc);\n-    } else {\n-        \/*\n-        * Imported stylesheet.\n-        *\/\n-        cctxt = style->parent->compCtxt;\n-        style->compCtxt = cctxt;\n-    }\n-    \/*\n-    * Save the old and set the current stylesheet structure in the\n-    * compilation context.\n-    *\/\n-    oldCurSheet = cctxt->style;\n-    cctxt->style = style;\n@@ -6649,2 +6645,2 @@\n-    style->doc = doc;\n-    xsltParseStylesheetProcess(style, doc);\n+        style->doc = doc;\n+        xsltParseStylesheetProcess(style, doc);\n@@ -6652,14 +6648,14 @@\n-    cctxt->style = oldCurSheet;\n-    if (style->parent == NULL) {\n-        \/*\n-        * Pop the initial dummy node info.\n-        *\/\n-        xsltCompilerNodePop(cctxt, (xmlNodePtr) doc);\n-    } else {\n-        \/*\n-        * Clear the compilation context of imported\n-        * stylesheets.\n-        * TODO: really?\n-        *\/\n-        \/* style->compCtxt = NULL; *\/\n-    }\n+        cctxt->style = oldCurSheet;\n+        if (style->parent == NULL) {\n+            \/*\n+            * Pop the initial dummy node info.\n+            *\/\n+            xsltCompilerNodePop(cctxt, (xmlNodePtr) doc);\n+        } else {\n+            \/*\n+            * Clear the compilation context of imported\n+            * stylesheets.\n+            * TODO: really?\n+            *\/\n+            \/* style->compCtxt = NULL; *\/\n+        }\n@@ -6752,1 +6748,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6756,1 +6752,1 @@\n-        \"xsltParseStylesheetFile : parse %s\\n\", filename);\n+            \"xsltParseStylesheetFile : parse %s\\n\", filename);\n@@ -6764,1 +6760,1 @@\n-    int res;\n+        int res;\n@@ -6766,2 +6762,2 @@\n-    res = xsltCheckRead(sec, NULL, filename);\n-    if (res <= 0) {\n+        res = xsltCheckRead(sec, NULL, filename);\n+        if (res <= 0) {\n@@ -6772,2 +6768,2 @@\n-        return(NULL);\n-    }\n+            return(NULL);\n+        }\n@@ -6779,3 +6775,3 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltParseStylesheetFile : cannot parse %s\\n\", filename);\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, NULL,\n+                \"xsltParseStylesheetFile : cannot parse %s\\n\", filename);\n+        return(NULL);\n@@ -6785,2 +6781,2 @@\n-    xmlFreeDoc(doc);\n-    return(NULL);\n+        xmlFreeDoc(doc);\n+        return(NULL);\n@@ -6793,3 +6789,3 @@\n- *                                  *\n- *          Handling of Stylesheet PI           *\n- *                                  *\n+ *                                                                      *\n+ *                      Handling of Stylesheet PI                       *\n+ *                                                                      *\n@@ -6801,1 +6797,1 @@\n-#define SKIP_BLANKS                     \\\n+#define SKIP_BLANKS                                             \\\n@@ -6825,1 +6821,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6829,4 +6825,0 @@\n-    SKIP_BLANKS;\n-    if ((CUR == 't') && (NXT(1) == 'y') && (NXT(2) == 'p') &&\n-        (NXT(3) == 'e')) {\n-        SKIP(4);\n@@ -6834,18 +6826,22 @@\n-        if (CUR != '=')\n-        continue;\n-        NEXT;\n-        if ((CUR != '\\'') && (CUR != '\"'))\n-        continue;\n-        tmp = CUR;\n-        NEXT;\n-        start = cur;\n-        while ((CUR != 0) && (CUR != tmp))\n-        NEXT;\n-        if (CUR != tmp)\n-        continue;\n-        val = xmlStrndup(start, cur - start);\n-        NEXT;\n-        if (val == NULL)\n-        return(NULL);\n-        if ((xmlStrcasecmp(val, BAD_CAST \"text\/xml\")) &&\n-        (xmlStrcasecmp(val, BAD_CAST \"text\/xsl\"))) {\n+        if ((CUR == 't') && (NXT(1) == 'y') && (NXT(2) == 'p') &&\n+            (NXT(3) == 'e')) {\n+            SKIP(4);\n+            SKIP_BLANKS;\n+            if (CUR != '=')\n+                continue;\n+            NEXT;\n+            if ((CUR != '\\'') && (CUR != '\"'))\n+                continue;\n+            tmp = CUR;\n+            NEXT;\n+            start = cur;\n+            while ((CUR != 0) && (CUR != tmp))\n+                NEXT;\n+            if (CUR != tmp)\n+                continue;\n+            val = xmlStrndup(start, cur - start);\n+            NEXT;\n+            if (val == NULL)\n+                return(NULL);\n+            if ((xmlStrcasecmp(val, BAD_CAST \"text\/xml\")) &&\n+                (xmlStrcasecmp(val, BAD_CAST \"text\/xsl\"))) {\n@@ -6853,1 +6849,26 @@\n-        break;\n+                break;\n+            }\n+            isXml = 1;\n+            xmlFree(val);\n+        } else if ((CUR == 'h') && (NXT(1) == 'r') && (NXT(2) == 'e') &&\n+            (NXT(3) == 'f')) {\n+            SKIP(4);\n+            SKIP_BLANKS;\n+            if (CUR != '=')\n+                continue;\n+            NEXT;\n+            if ((CUR != '\\'') && (CUR != '\"'))\n+                continue;\n+            tmp = CUR;\n+            NEXT;\n+            start = cur;\n+            while ((CUR != 0) && (CUR != tmp))\n+                NEXT;\n+            if (CUR != tmp)\n+                continue;\n+            if (href == NULL)\n+                href = xmlStrndup(start, cur - start);\n+            NEXT;\n+        } else {\n+            while ((CUR != 0) && (!IS_BLANK(CUR)))\n+                NEXT;\n@@ -6855,25 +6876,0 @@\n-        isXml = 1;\n-        xmlFree(val);\n-    } else if ((CUR == 'h') && (NXT(1) == 'r') && (NXT(2) == 'e') &&\n-        (NXT(3) == 'f')) {\n-        SKIP(4);\n-        SKIP_BLANKS;\n-        if (CUR != '=')\n-        continue;\n-        NEXT;\n-        if ((CUR != '\\'') && (CUR != '\"'))\n-        continue;\n-        tmp = CUR;\n-        NEXT;\n-        start = cur;\n-        while ((CUR != 0) && (CUR != tmp))\n-        NEXT;\n-        if (CUR != tmp)\n-        continue;\n-        if (href == NULL)\n-        href = xmlStrndup(start, cur - start);\n-        NEXT;\n-    } else {\n-        while ((CUR != 0) && (!IS_BLANK(CUR)))\n-        NEXT;\n-    }\n@@ -6884,3 +6880,3 @@\n-    if (href != NULL)\n-        xmlFree(href);\n-    href = NULL;\n+        if (href != NULL)\n+            xmlFree(href);\n+        href = NULL;\n@@ -6915,1 +6911,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -6922,7 +6918,7 @@\n-    if ((child->type == XML_PI_NODE) &&\n-        (xmlStrEqual(child->name, BAD_CAST \"xml-stylesheet\"))) {\n-        href = xsltParseStylesheetPI(child->content);\n-        if (href != NULL)\n-        break;\n-    }\n-    child = child->next;\n+        if ((child->type == XML_PI_NODE) &&\n+            (xmlStrEqual(child->name, BAD_CAST \"xml-stylesheet\"))) {\n+            href = xsltParseStylesheetPI(child->content);\n+            if (href != NULL)\n+                break;\n+        }\n+        child = child->next;\n@@ -6936,2 +6932,2 @@\n-    xsltGenericDebug(xsltGenericDebugContext,\n-        \"xsltLoadStylesheetPI : found PI href=%s\\n\", href);\n+        xsltGenericDebug(xsltGenericDebugContext,\n+                \"xsltLoadStylesheetPI : found PI href=%s\\n\", href);\n@@ -6939,8 +6935,8 @@\n-    URI = xmlParseURI((const char *) href);\n-    if (URI == NULL) {\n-        xsltTransformError(NULL, NULL, child,\n-            \"xml-stylesheet : href %s is not valid\\n\", href);\n-        xmlFree(href);\n-        return(NULL);\n-    }\n-    if ((URI->fragment != NULL) && (URI->scheme == NULL) &&\n+        URI = xmlParseURI((const char *) href);\n+        if (URI == NULL) {\n+            xsltTransformError(NULL, NULL, child,\n+                    \"xml-stylesheet : href %s is not valid\\n\", href);\n+            xmlFree(href);\n+            return(NULL);\n+        }\n+        if ((URI->fragment != NULL) && (URI->scheme == NULL) &&\n@@ -6950,1 +6946,1 @@\n-        xmlAttrPtr ID;\n+            xmlAttrPtr ID;\n@@ -6953,2 +6949,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltLoadStylesheetPI : Reference to ID %s\\n\", href);\n+            xsltGenericDebug(xsltGenericDebugContext,\n+                    \"xsltLoadStylesheetPI : Reference to ID %s\\n\", href);\n@@ -6956,11 +6952,11 @@\n-        if (URI->fragment[0] == '#')\n-        ID = xmlGetID(doc, (const xmlChar *) &(URI->fragment[1]));\n-        else\n-        ID = xmlGetID(doc, (const xmlChar *) URI->fragment);\n-        if (ID == NULL) {\n-        xsltTransformError(NULL, NULL, child,\n-            \"xml-stylesheet : no ID %s found\\n\", URI->fragment);\n-        } else {\n-        xmlDocPtr fake;\n-        xmlNodePtr subtree, newtree;\n-        xmlNsPtr ns;\n+            if (URI->fragment[0] == '#')\n+                ID = xmlGetID(doc, (const xmlChar *) &(URI->fragment[1]));\n+            else\n+                ID = xmlGetID(doc, (const xmlChar *) URI->fragment);\n+            if (ID == NULL) {\n+                xsltTransformError(NULL, NULL, child,\n+                    \"xml-stylesheet : no ID %s found\\n\", URI->fragment);\n+            } else {\n+                xmlDocPtr fake;\n+                xmlNodePtr subtree, newtree;\n+                xmlNsPtr ns;\n@@ -6969,3 +6965,3 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-            \"creating new document from %s for embedded stylesheet\\n\",\n-            doc->URL);\n+                xsltGenericDebug(xsltGenericDebugContext,\n+                    \"creating new document from %s for embedded stylesheet\\n\",\n+                    doc->URL);\n@@ -6973,13 +6969,13 @@\n-        \/*\n-         * move the subtree in a new document passed to\n-         * the stylesheet analyzer\n-         *\/\n-        subtree = ID->parent;\n-        fake = xmlNewDoc(NULL);\n-        if (fake != NULL) {\n-            \/*\n-            * Should the dictionary still be shared even though\n-            * the nodes are being copied rather than moved?\n-            *\/\n-            fake->dict = doc->dict;\n-            xmlDictReference(doc->dict);\n+                \/*\n+                 * move the subtree in a new document passed to\n+                 * the stylesheet analyzer\n+                 *\/\n+                subtree = ID->parent;\n+                fake = xmlNewDoc(NULL);\n+                if (fake != NULL) {\n+                    \/*\n+                    * Should the dictionary still be shared even though\n+                    * the nodes are being copied rather than moved?\n+                    *\/\n+                    fake->dict = doc->dict;\n+                    xmlDictReference(doc->dict);\n@@ -6987,3 +6983,3 @@\n-            xsltGenericDebug(xsltGenericDebugContext,\n-            \"reusing dictionary from %s for embedded stylesheet\\n\",\n-            doc->URL);\n+                    xsltGenericDebug(xsltGenericDebugContext,\n+                        \"reusing dictionary from %s for embedded stylesheet\\n\",\n+                        doc->URL);\n@@ -6992,1 +6988,1 @@\n-            newtree = xmlDocCopyNode(subtree, fake, 1);\n+                    newtree = xmlDocCopyNode(subtree, fake, 1);\n@@ -6994,1 +6990,1 @@\n-            fake->URL = xmlNodeGetBase(doc, subtree->parent);\n+                    fake->URL = xmlNodeGetBase(doc, subtree->parent);\n@@ -6996,3 +6992,3 @@\n-            xsltGenericDebug(xsltGenericDebugContext,\n-            \"set base URI for embedded stylesheet as %s\\n\",\n-            fake->URL);\n+                    xsltGenericDebug(xsltGenericDebugContext,\n+                        \"set base URI for embedded stylesheet as %s\\n\",\n+                        fake->URL);\n@@ -7001,9 +6997,9 @@\n-            \/*\n-            * Add all namespaces in scope of embedded stylesheet to\n-            * root element of newly created stylesheet document\n-            *\/\n-            while ((subtree = subtree->parent) != (xmlNodePtr)doc) {\n-            for (ns = subtree->ns; ns; ns = ns->next) {\n-                xmlNewNs(newtree,  ns->href, ns->prefix);\n-            }\n-            }\n+                    \/*\n+                    * Add all namespaces in scope of embedded stylesheet to\n+                    * root element of newly created stylesheet document\n+                    *\/\n+                    while ((subtree = subtree->parent) != (xmlNodePtr)doc) {\n+                        for (ns = subtree->ns; ns; ns = ns->next) {\n+                            xmlNewNs(newtree,  ns->href, ns->prefix);\n+                        }\n+                    }\n@@ -7011,8 +7007,8 @@\n-            xmlAddChild((xmlNodePtr)fake, newtree);\n-            ret = xsltParseStylesheetDoc(fake);\n-            if (ret == NULL)\n-            xmlFreeDoc(fake);\n-        }\n-        }\n-    } else {\n-        xmlChar *URL, *base;\n+                    xmlAddChild((xmlNodePtr)fake, newtree);\n+                    ret = xsltParseStylesheetDoc(fake);\n+                    if (ret == NULL)\n+                        xmlFreeDoc(fake);\n+                }\n+            }\n+        } else {\n+            xmlChar *URL, *base;\n@@ -7020,3 +7016,3 @@\n-        \/*\n-         * Reference to an external stylesheet\n-         *\/\n+            \/*\n+             * Reference to an external stylesheet\n+             *\/\n@@ -7024,3 +7020,3 @@\n-        base = xmlNodeGetBase(doc, (xmlNodePtr) doc);\n-        URL = xmlBuildURI(href, base);\n-        if (URL != NULL) {\n+            base = xmlNodeGetBase(doc, (xmlNodePtr) doc);\n+            URL = xmlBuildURI(href, base);\n+            if (URL != NULL) {\n@@ -7028,2 +7024,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltLoadStylesheetPI : fetching %s\\n\", URL);\n+                xsltGenericDebug(xsltGenericDebugContext,\n+                        \"xsltLoadStylesheetPI : fetching %s\\n\", URL);\n@@ -7031,3 +7027,3 @@\n-        ret = xsltParseStylesheetFile(URL);\n-        xmlFree(URL);\n-        } else {\n+                ret = xsltParseStylesheetFile(URL);\n+                xmlFree(URL);\n+            } else {\n@@ -7035,2 +7031,2 @@\n-        xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltLoadStylesheetPI : fetching %s\\n\", href);\n+                xsltGenericDebug(xsltGenericDebugContext,\n+                        \"xsltLoadStylesheetPI : fetching %s\\n\", href);\n@@ -7038,1 +7034,4 @@\n-        ret = xsltParseStylesheetFile(href);\n+                ret = xsltParseStylesheetFile(href);\n+            }\n+            if (base != NULL)\n+                xmlFree(base);\n@@ -7040,5 +7039,2 @@\n-        if (base != NULL)\n-        xmlFree(base);\n-    }\n-    xmlFreeURI(URI);\n-    xmlFree(href);\n+        xmlFreeURI(URI);\n+        xmlFree(href);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/xslt.c","additions":3402,"deletions":3406,"binary":false,"changes":6808,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-        xsltInit        (void);\n+                xsltInit                (void);\n@@ -103,1 +103,1 @@\n-        xsltCleanupGlobals  (void);\n+                xsltCleanupGlobals      (void);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/xslt.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -226,5 +226,5 @@\n-    void       *info;       \/* pointer to the extra data *\/\n-    xmlFreeFunc deallocate; \/* pointer to the deallocation routine *\/\n-    union {         \/* dual-purpose field *\/\n-        void   *ptr;        \/* data not needing deallocation *\/\n-    int    ival;        \/* integer value storage *\/\n+    void       *info;           \/* pointer to the extra data *\/\n+    xmlFreeFunc deallocate;     \/* pointer to the deallocation routine *\/\n+    union {                     \/* dual-purpose field *\/\n+        void   *ptr;            \/* data not needing deallocation *\/\n+        int    ival;            \/* integer value storage *\/\n@@ -269,2 +269,2 @@\n-    xmlChar *match; \/* the matching string *\/\n-    float priority; \/* as given from the stylesheet, not computed *\/\n+    xmlChar *match;     \/* the matching string *\/\n+    float priority;     \/* as given from the stylesheet, not computed *\/\n@@ -290,2 +290,2 @@\n-    int              templNr;       \/* Nb of templates in the stack *\/\n-    int              templMax;      \/* Size of the templtes stack *\/\n+    int              templNr;           \/* Nb of templates in the stack *\/\n+    int              templMax;          \/* Size of the templtes stack *\/\n@@ -294,0 +294,3 @@\n+\n+    \/* Conflict resolution *\/\n+    int position;\n@@ -331,3 +334,3 @@\n-    int main;           \/* is this the main document *\/\n-    xmlDocPtr doc;      \/* the parsed document *\/\n-    void *keys;         \/* key tables storage *\/\n+    int main;                   \/* is this the main document *\/\n+    xmlDocPtr doc;              \/* the parsed document *\/\n+    void *keys;                 \/* key tables storage *\/\n@@ -335,1 +338,1 @@\n-    int preproc;        \/* pre-processing already done *\/\n+    int preproc;                \/* pre-processing already done *\/\n@@ -405,3 +408,3 @@\n-                                   xmlNodePtr node,\n-                       xmlNodePtr inst,\n-                           xsltElemPreCompPtr comp);\n+                                       xmlNodePtr node,\n+                                       xmlNodePtr inst,\n+                                       xsltElemPreCompPtr comp);\n@@ -418,1 +421,1 @@\n-                  int nbsorts);\n+                              int nbsorts);\n@@ -472,3 +475,3 @@\n-    xsltElemPreCompPtr next;        \/* next item in the global chained\n-                       list held by xsltStylesheet. *\/\n-    xsltStyleType type;     \/* type of the element *\/\n+    xsltElemPreCompPtr next;            \/* next item in the global chained\n+                                           list held by xsltStylesheet. *\/\n+    xsltStyleType type;         \/* type of the element *\/\n@@ -476,2 +479,2 @@\n-    xmlNodePtr inst;            \/* the node in the stylesheet's tree\n-                       corresponding to this item *\/\n+    xmlNodePtr inst;                    \/* the node in the stylesheet's tree\n+                                           corresponding to this item *\/\n@@ -501,1 +504,1 @@\n-        xsltPointerListCreate       (int initialSize);\n+                xsltPointerListCreate           (int initialSize);\n@@ -503,1 +506,1 @@\n-        xsltPointerListFree     (xsltPointerListPtr list);\n+                xsltPointerListFree             (xsltPointerListPtr list);\n@@ -505,1 +508,1 @@\n-        xsltPointerListClear        (xsltPointerListPtr list);\n+                xsltPointerListClear            (xsltPointerListPtr list);\n@@ -507,3 +510,3 @@\n-        xsltPointerListAddSize      (xsltPointerListPtr list,\n-                         void *item,\n-                         int initialSize);\n+                xsltPointerListAddSize          (xsltPointerListPtr list,\n+                                                 void *item,\n+                                                 int initialSize);\n@@ -512,1 +515,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -514,1 +517,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -585,1 +588,1 @@\n-                   list held by xsltStylesheet *\/\n+                                   list held by xsltStylesheet *\/\n@@ -588,2 +591,2 @@\n-    xmlNodePtr inst;        \/* the node in the stylesheet's tree\n-                   corresponding to this item. *\/\n+    xmlNodePtr inst;            \/* the node in the stylesheet's tree\n+                                   corresponding to this item. *\/\n@@ -626,1 +629,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -628,1 +631,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -693,1 +696,1 @@\n-    int      noescape;      \/* text *\/\n+    int      noescape;          \/* text *\/\n@@ -750,3 +753,3 @@\n-    const xmlChar *mode;    \/* apply-templates *\/\n-    const xmlChar *modeURI; \/* apply-templates *\/\n-    const xmlChar *select;  \/* sort, copy-of, value-of, apply-templates *\/\n+    const xmlChar *mode;        \/* apply-templates *\/\n+    const xmlChar *modeURI;     \/* apply-templates *\/\n+    const xmlChar *select;      \/* sort, copy-of, value-of, apply-templates *\/\n@@ -772,5 +775,5 @@\n-    xsltTemplatePtr templ;  \/* call-template *\/\n-    const xmlChar *name;    \/* element, attribute, pi *\/\n-    int      has_name;      \/* element, attribute, pi *\/\n-    const xmlChar *ns;      \/* element *\/\n-    int      has_ns;        \/* element *\/\n+    xsltTemplatePtr templ;      \/* call-template *\/\n+    const xmlChar *name;        \/* element, attribute, pi *\/\n+    int      has_name;          \/* element, attribute, pi *\/\n+    const xmlChar *ns;          \/* element *\/\n+    int      has_ns;            \/* element *\/\n@@ -794,2 +797,2 @@\n-    const xmlChar *use;     \/* copy, element *\/\n-    int      has_use;       \/* copy, element *\/\n+    const xmlChar *use;         \/* copy, element *\/\n+    int      has_use;           \/* copy, element *\/\n@@ -813,1 +816,1 @@\n-    const xmlChar *test;    \/* if *\/\n+    const xmlChar *test;        \/* if *\/\n@@ -867,1 +870,1 @@\n-    xsltNumberData numdata; \/* number *\/\n+    xsltNumberData numdata;     \/* number *\/\n@@ -931,1 +934,1 @@\n-    int      ver11;     \/* assigned: in xsltDocumentComp;\n+    int      ver11;             \/* assigned: in xsltDocumentComp;\n@@ -939,1 +942,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -941,1 +944,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -1040,8 +1043,8 @@\n-    int      has_stype;     \/* sort *\/\n-    int      number;        \/* sort *\/\n-    const xmlChar *order;   \/* sort *\/\n-    int      has_order;     \/* sort *\/\n-    int      descending;    \/* sort *\/\n-    const xmlChar *lang;    \/* sort *\/\n-    int      has_lang;      \/* sort *\/\n-    xsltLocale locale;      \/* sort *\/\n+    int      has_stype;         \/* sort *\/\n+    int      number;            \/* sort *\/\n+    const xmlChar *order;       \/* sort *\/\n+    int      has_order;         \/* sort *\/\n+    int      descending;        \/* sort *\/\n+    const xmlChar *lang;        \/* sort *\/\n+    int      has_lang;          \/* sort *\/\n+    xsltLocale locale;          \/* sort *\/\n@@ -1049,1 +1052,1 @@\n-    int      lower_first;   \/* sort *\/\n+    int      lower_first;       \/* sort *\/\n@@ -1054,1 +1057,1 @@\n-    const xmlChar *select;  \/* sort, copy-of, value-of, apply-templates *\/\n+    const xmlChar *select;      \/* sort, copy-of, value-of, apply-templates *\/\n@@ -1103,1 +1106,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -1105,1 +1108,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -1116,1 +1119,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -1118,1 +1121,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -1149,1 +1152,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -1151,1 +1154,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -1219,1 +1222,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -1221,1 +1224,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -1262,1 +1265,1 @@\n-    int category;        \/* XSLT element, LR-element or\n+    int category;            \/* XSLT element, LR-element or\n@@ -1312,1 +1315,1 @@\n-    int warnings;       \/* TODO: number of warnings found at\n+    int warnings;               \/* TODO: number of warnings found at\n@@ -1314,1 +1317,1 @@\n-    int errors;         \/* TODO: number of errors found at\n+    int errors;                 \/* TODO: number of errors found at\n@@ -1331,1 +1334,1 @@\n-                 in a parsing episode *\/\n+                             in a parsing episode *\/\n@@ -1361,1 +1364,1 @@\n-    xsltStyleType type;     \/* type of the element *\/\n+    xsltStyleType type;         \/* type of the element *\/\n@@ -1363,1 +1366,1 @@\n-    xmlNodePtr inst;        \/* the instruction *\/\n+    xmlNodePtr inst;            \/* the instruction *\/\n@@ -1370,8 +1373,8 @@\n-    int      has_stype;     \/* sort *\/\n-    int      number;        \/* sort *\/\n-    const xmlChar *order;   \/* sort *\/\n-    int      has_order;     \/* sort *\/\n-    int      descending;    \/* sort *\/\n-    const xmlChar *lang;    \/* sort *\/\n-    int      has_lang;      \/* sort *\/\n-    xsltLocale locale;      \/* sort *\/\n+    int      has_stype;         \/* sort *\/\n+    int      number;            \/* sort *\/\n+    const xmlChar *order;       \/* sort *\/\n+    int      has_order;         \/* sort *\/\n+    int      descending;        \/* sort *\/\n+    const xmlChar *lang;        \/* sort *\/\n+    int      has_lang;          \/* sort *\/\n+    xsltLocale locale;          \/* sort *\/\n@@ -1379,1 +1382,1 @@\n-    int      lower_first;   \/* sort *\/\n+    int      lower_first;       \/* sort *\/\n@@ -1381,2 +1384,2 @@\n-    const xmlChar *use;     \/* copy, element *\/\n-    int      has_use;       \/* copy, element *\/\n+    const xmlChar *use;         \/* copy, element *\/\n+    int      has_use;           \/* copy, element *\/\n@@ -1384,1 +1387,1 @@\n-    int      noescape;      \/* text *\/\n+    int      noescape;          \/* text *\/\n@@ -1386,4 +1389,4 @@\n-    const xmlChar *name;    \/* element, attribute, pi *\/\n-    int      has_name;      \/* element, attribute, pi *\/\n-    const xmlChar *ns;      \/* element *\/\n-    int      has_ns;        \/* element *\/\n+    const xmlChar *name;        \/* element, attribute, pi *\/\n+    int      has_name;          \/* element, attribute, pi *\/\n+    const xmlChar *ns;          \/* element *\/\n+    int      has_ns;            \/* element *\/\n@@ -1391,2 +1394,2 @@\n-    const xmlChar *mode;    \/* apply-templates *\/\n-    const xmlChar *modeURI; \/* apply-templates *\/\n+    const xmlChar *mode;        \/* apply-templates *\/\n+    const xmlChar *modeURI;     \/* apply-templates *\/\n@@ -1394,1 +1397,1 @@\n-    const xmlChar *test;    \/* if *\/\n+    const xmlChar *test;        \/* if *\/\n@@ -1396,1 +1399,1 @@\n-    xsltTemplatePtr templ;  \/* call-template *\/\n+    xsltTemplatePtr templ;      \/* call-template *\/\n@@ -1398,1 +1401,1 @@\n-    const xmlChar *select;  \/* sort, copy-of, value-of, apply-templates *\/\n+    const xmlChar *select;      \/* sort, copy-of, value-of, apply-templates *\/\n@@ -1400,1 +1403,1 @@\n-    int      ver11;     \/* document *\/\n+    int      ver11;             \/* document *\/\n@@ -1402,1 +1405,1 @@\n-    int      has_filename;  \/* document *\/\n+    int      has_filename;      \/* document *\/\n@@ -1404,1 +1407,1 @@\n-    xsltNumberData numdata; \/* number *\/\n+    xsltNumberData numdata;     \/* number *\/\n@@ -1407,2 +1410,2 @@\n-    xmlNsPtr *nsList;       \/* the namespaces in scope *\/\n-    int nsNr;           \/* the number of namespaces in scope *\/\n+    xmlNsPtr *nsList;           \/* the namespaces in scope *\/\n+    int nsNr;                   \/* the number of namespaces in scope *\/\n@@ -1423,6 +1426,6 @@\n-    int computed;       \/* was the evaluation done *\/\n-    const xmlChar *name;    \/* the local part of the name QName *\/\n-    const xmlChar *nameURI; \/* the URI part of the name QName *\/\n-    const xmlChar *select;  \/* the eval string *\/\n-    xmlNodePtr tree;        \/* the sequence constructor if no eval\n-                    string or the location *\/\n+    int computed;               \/* was the evaluation done *\/\n+    const xmlChar *name;        \/* the local part of the name QName *\/\n+    const xmlChar *nameURI;     \/* the URI part of the name QName *\/\n+    const xmlChar *select;      \/* the eval string *\/\n+    xmlNodePtr tree;            \/* the sequence constructor if no eval\n+                                    string or the location *\/\n@@ -1430,2 +1433,2 @@\n-    xmlDocPtr fragment;     \/* The Result Tree Fragments (needed for XSLT 1.0)\n-                   which are bound to the variable's lifetime. *\/\n+    xmlDocPtr fragment;         \/* The Result Tree Fragments (needed for XSLT 1.0)\n+                                   which are bound to the variable's lifetime. *\/\n@@ -1484,1 +1487,1 @@\n-    xsltDocumentPtr docList;        \/* the include document list *\/\n+    xsltDocumentPtr docList;            \/* the include document list *\/\n@@ -1489,1 +1492,1 @@\n-    xmlDocPtr doc;      \/* the parsed XML stylesheet *\/\n+    xmlDocPtr doc;              \/* the parsed XML stylesheet *\/\n@@ -1491,1 +1494,1 @@\n-                   preserve space elements *\/\n+                                   preserve space elements *\/\n@@ -1503,11 +1506,12 @@\n-    xsltTemplatePtr templates;  \/* the ordered list of templates *\/\n-    void *templatesHash;    \/* hash table or wherever compiled templates\n-                   information is stored *\/\n-    void *rootMatch;        \/* template based on \/ *\/\n-    void *keyMatch;     \/* template based on key() *\/\n-    void *elemMatch;        \/* template based on * *\/\n-    void *attrMatch;        \/* template based on @* *\/\n-    void *parentMatch;      \/* template based on .. *\/\n-    void *textMatch;        \/* template based on text() *\/\n-    void *piMatch;      \/* template based on processing-instruction() *\/\n-    void *commentMatch;     \/* template based on comment() *\/\n+    xsltTemplatePtr templates;           \/* the ordered list of templates *\/\n+    xmlHashTablePtr templatesHash;       \/* hash table or wherever compiled\n+                                            templates information is stored *\/\n+    struct _xsltCompMatch *rootMatch;    \/* template based on \/ *\/\n+    struct _xsltCompMatch *keyMatch;     \/* template based on key() *\/\n+    struct _xsltCompMatch *elemMatch;    \/* template based on * *\/\n+    struct _xsltCompMatch *attrMatch;    \/* template based on @* *\/\n+    struct _xsltCompMatch *parentMatch;  \/* template based on .. *\/\n+    struct _xsltCompMatch *textMatch;    \/* template based on text() *\/\n+    struct _xsltCompMatch *piMatch;      \/* template based on\n+                                            processing-instruction() *\/\n+    struct _xsltCompMatch *commentMatch; \/* template based on comment() *\/\n@@ -1535,2 +1539,2 @@\n-                   TODO: We need to get rid of this.\n-                 *\/\n+                                   TODO: We need to get rid of this.\n+                                 *\/\n@@ -1538,1 +1542,1 @@\n-                   xsltExtDefPtr (in extensions.c) and\n+                                   xsltExtDefPtr (in extensions.c) and\n@@ -1540,1 +1544,1 @@\n-                 *\/\n+                                 *\/\n@@ -1545,1 +1549,1 @@\n-    void *keys;         \/* key definitions *\/\n+    void *keys;                 \/* key definitions *\/\n@@ -1550,4 +1554,4 @@\n-    xmlChar *method;        \/* the output method *\/\n-    xmlChar *methodURI;     \/* associated namespace if any *\/\n-    xmlChar *version;       \/* version string *\/\n-    xmlChar *encoding;      \/* encoding string *\/\n+    xmlChar *method;            \/* the output method *\/\n+    xmlChar *methodURI;         \/* associated namespace if any *\/\n+    xmlChar *version;           \/* version string *\/\n+    xmlChar *encoding;          \/* encoding string *\/\n@@ -1563,2 +1567,2 @@\n-    int indent;         \/* should output being indented *\/\n-    xmlChar *mediaType;     \/* media-type string *\/\n+    int indent;                 \/* should output being indented *\/\n+    xmlChar *mediaType;         \/* media-type string *\/\n@@ -1570,2 +1574,2 @@\n-    int warnings;       \/* number of warnings found at compilation *\/\n-    int errors;         \/* number of errors found at compilation *\/\n+    int warnings;               \/* number of warnings found at compilation *\/\n+    int errors;                 \/* number of errors found at compilation *\/\n@@ -1573,1 +1577,1 @@\n-    xmlChar  *exclPrefix;   \/* last excluded prefixes *\/\n+    xmlChar  *exclPrefix;       \/* last excluded prefixes *\/\n@@ -1575,1 +1579,1 @@\n-    int       exclPrefixNr; \/* number of excluded prefixes in scope *\/\n+    int       exclPrefixNr;     \/* number of excluded prefixes in scope *\/\n@@ -1578,1 +1582,1 @@\n-    void     *_private;     \/* user defined data *\/\n+    void     *_private;         \/* user defined data *\/\n@@ -1584,1 +1588,1 @@\n-    int         extrasNr;   \/* the number of extras required *\/\n+    int             extrasNr;   \/* the number of extras required *\/\n@@ -1669,2 +1673,2 @@\n-    xsltStylesheetPtr style;        \/* the stylesheet used *\/\n-    xsltOutputType type;        \/* the type of output *\/\n+    xsltStylesheetPtr style;            \/* the stylesheet used *\/\n+    xsltOutputType type;                \/* the type of output *\/\n@@ -1672,4 +1676,4 @@\n-    xsltTemplatePtr  templ;     \/* the current template *\/\n-    int              templNr;       \/* Nb of templates in the stack *\/\n-    int              templMax;      \/* Size of the templtes stack *\/\n-    xsltTemplatePtr *templTab;      \/* the template stack *\/\n+    xsltTemplatePtr  templ;             \/* the current template *\/\n+    int              templNr;           \/* Nb of templates in the stack *\/\n+    int              templMax;          \/* Size of the templtes stack *\/\n+    xsltTemplatePtr *templTab;          \/* the template stack *\/\n@@ -1677,5 +1681,5 @@\n-    xsltStackElemPtr  vars;     \/* the current variable list *\/\n-    int               varsNr;       \/* Nb of variable list in the stack *\/\n-    int               varsMax;      \/* Size of the variable list stack *\/\n-    xsltStackElemPtr *varsTab;      \/* the variable list stack *\/\n-    int               varsBase;     \/* the var base for current templ *\/\n+    xsltStackElemPtr  vars;             \/* the current variable list *\/\n+    int               varsNr;           \/* Nb of variable list in the stack *\/\n+    int               varsMax;          \/* Size of the variable list stack *\/\n+    xsltStackElemPtr *varsTab;          \/* the variable list stack *\/\n+    int               varsBase;         \/* the var base for current templ *\/\n@@ -1686,3 +1690,3 @@\n-    xmlHashTablePtr   extFunctions; \/* the extension functions *\/\n-    xmlHashTablePtr   extElements;  \/* the extension elements *\/\n-    xmlHashTablePtr   extInfos;     \/* the extension data *\/\n+    xmlHashTablePtr   extFunctions;     \/* the extension functions *\/\n+    xmlHashTablePtr   extElements;      \/* the extension elements *\/\n+    xmlHashTablePtr   extInfos;         \/* the extension data *\/\n@@ -1690,2 +1694,2 @@\n-    const xmlChar *mode;        \/* the current mode *\/\n-    const xmlChar *modeURI;     \/* the current mode URI *\/\n+    const xmlChar *mode;                \/* the current mode *\/\n+    const xmlChar *modeURI;             \/* the current mode URI *\/\n@@ -1693,1 +1697,1 @@\n-    xsltDocumentPtr docList;        \/* the document list *\/\n+    xsltDocumentPtr docList;            \/* the document list *\/\n@@ -1695,4 +1699,4 @@\n-    xsltDocumentPtr document;       \/* the current source document; can be NULL if an RTF *\/\n-    xmlNodePtr node;            \/* the current node being processed *\/\n-    xmlNodeSetPtr nodeList;     \/* the current node list *\/\n-    \/* xmlNodePtr current;          the node *\/\n+    xsltDocumentPtr document;           \/* the current source document; can be NULL if an RTF *\/\n+    xmlNodePtr node;                    \/* the current node being processed *\/\n+    xmlNodeSetPtr nodeList;             \/* the current node list *\/\n+    \/* xmlNodePtr current;                      the node *\/\n@@ -1700,2 +1704,2 @@\n-    xmlDocPtr output;           \/* the resulting document *\/\n-    xmlNodePtr insert;          \/* the insertion node *\/\n+    xmlDocPtr output;                   \/* the resulting document *\/\n+    xmlNodePtr insert;                  \/* the insertion node *\/\n@@ -1703,2 +1707,2 @@\n-    xmlXPathContextPtr xpathCtxt;   \/* the XPath context *\/\n-    xsltTransformState state;       \/* the current state *\/\n+    xmlXPathContextPtr xpathCtxt;       \/* the XPath context *\/\n+    xsltTransformState state;           \/* the current state *\/\n@@ -1709,1 +1713,1 @@\n-    xmlHashTablePtr   globalVars;   \/* the global variables and params *\/\n+    xmlHashTablePtr   globalVars;       \/* the global variables and params *\/\n@@ -1711,1 +1715,1 @@\n-    xmlNodePtr inst;            \/* the instruction in the stylesheet *\/\n+    xmlNodePtr inst;                    \/* the instruction in the stylesheet *\/\n@@ -1713,1 +1717,1 @@\n-    int xinclude;           \/* should XInclude be processed *\/\n+    int xinclude;                       \/* should XInclude be processed *\/\n@@ -1715,1 +1719,1 @@\n-    const char *      outputFile;   \/* the output URI if known *\/\n+    const char *      outputFile;       \/* the output URI if known *\/\n@@ -1718,4 +1722,4 @@\n-    long             prof;      \/* the current profiled value *\/\n-    int              profNr;        \/* Nb of templates in the stack *\/\n-    int              profMax;       \/* Size of the templtaes stack *\/\n-    long            *profTab;       \/* the profile template stack *\/\n+    long             prof;              \/* the current profiled value *\/\n+    int              profNr;            \/* Nb of templates in the stack *\/\n+    int              profMax;           \/* Size of the templtaes stack *\/\n+    long            *profTab;           \/* the profile template stack *\/\n@@ -1723,1 +1727,1 @@\n-    void            *_private;      \/* user defined data *\/\n+    void            *_private;          \/* user defined data *\/\n@@ -1725,3 +1729,3 @@\n-    int              extrasNr;      \/* the number of extras used *\/\n-    int              extrasMax;     \/* the number of extras allocated *\/\n-    xsltRuntimeExtraPtr extras;     \/* extra per runtime information *\/\n+    int              extrasNr;          \/* the number of extras used *\/\n+    int              extrasMax;         \/* the number of extras allocated *\/\n+    xsltRuntimeExtraPtr extras;         \/* extra per runtime information *\/\n@@ -1729,2 +1733,2 @@\n-    xsltDocumentPtr  styleList;     \/* the stylesheet docs list *\/\n-    void                 * sec;     \/* the security preferences if any *\/\n+    xsltDocumentPtr  styleList;         \/* the stylesheet docs list *\/\n+    void                 * sec;         \/* the security preferences if any *\/\n@@ -1732,2 +1736,2 @@\n-    xmlGenericErrorFunc  error;     \/* a specific error handler *\/\n-    void              * errctx;     \/* context for the error handler *\/\n+    xmlGenericErrorFunc  error;         \/* a specific error handler *\/\n+    void              * errctx;         \/* context for the error handler *\/\n@@ -1735,1 +1739,1 @@\n-    xsltSortFunc      sortfunc;     \/* a ctxt specific sort routine *\/\n+    xsltSortFunc      sortfunc;         \/* a ctxt specific sort routine *\/\n@@ -1741,2 +1745,2 @@\n-    xmlDocPtr       tmpRVT;     \/* list of RVT without persistance *\/\n-    xmlDocPtr       persistRVT;     \/* list of persistant RVTs *\/\n+    xmlDocPtr       tmpRVT;             \/* list of RVT without persistance *\/\n+    xmlDocPtr       persistRVT;         \/* list of persistant RVTs *\/\n@@ -1748,3 +1752,3 @@\n-    const xmlChar  *lasttext;       \/* last text node content *\/\n-    int             lasttsize;      \/* last text node size *\/\n-    int             lasttuse;       \/* last text node use *\/\n+    const xmlChar  *lasttext;           \/* last text node content *\/\n+    int             lasttsize;          \/* last text node size *\/\n+    int             lasttuse;           \/* last text node use *\/\n@@ -1754,2 +1758,2 @@\n-    int debugStatus;            \/* the context level debug status *\/\n-    unsigned long* traceCode;       \/* pointer to the variable holding the mask *\/\n+    int debugStatus;                    \/* the context level debug status *\/\n+    unsigned long* traceCode;           \/* pointer to the variable holding the mask *\/\n@@ -1757,1 +1761,1 @@\n-    int parserOptions;          \/* parser options xmlParserOption *\/\n+    int parserOptions;                  \/* parser options xmlParserOption *\/\n@@ -1763,1 +1767,1 @@\n-    xmlDocPtr       tmpDoc; \/* Obsolete; not used in the library. *\/\n+    xmlDocPtr           tmpDoc; \/* Obsolete; not used in the library. *\/\n@@ -1776,1 +1780,1 @@\n-               the instruction which created the fragment\n+                           the instruction which created the fragment\n@@ -1836,1 +1840,1 @@\n-                           xmlChar *name);\n+                                                   xmlChar *name);\n@@ -1839,1 +1843,1 @@\n-            xsltNewStylesheet   (void);\n+                        xsltNewStylesheet       (void);\n@@ -1841,1 +1845,1 @@\n-            xsltParseStylesheetFile (const xmlChar* filename);\n+                        xsltParseStylesheetFile (const xmlChar* filename);\n@@ -1843,1 +1847,1 @@\n-            xsltFreeStylesheet  (xsltStylesheetPtr style);\n+                        xsltFreeStylesheet      (xsltStylesheetPtr style);\n@@ -1845,1 +1849,1 @@\n-            xsltIsBlank     (xmlChar *str);\n+                        xsltIsBlank             (xmlChar *str);\n@@ -1847,1 +1851,1 @@\n-            xsltFreeStackElemList   (xsltStackElemPtr elem);\n+                        xsltFreeStackElemList   (xsltStackElemPtr elem);\n@@ -1849,2 +1853,2 @@\n-            xsltDecimalFormatGetByName(xsltStylesheetPtr style,\n-                         xmlChar *name);\n+                        xsltDecimalFormatGetByName(xsltStylesheetPtr style,\n+                                                 xmlChar *name);\n@@ -1852,2 +1856,2 @@\n-            xsltDecimalFormatGetByQName(xsltStylesheetPtr style,\n-                         const xmlChar *nsUri,\n+                        xsltDecimalFormatGetByQName(xsltStylesheetPtr style,\n+                                                 const xmlChar *nsUri,\n@@ -1857,2 +1861,2 @@\n-            xsltParseStylesheetProcess(xsltStylesheetPtr ret,\n-                         xmlDocPtr doc);\n+                        xsltParseStylesheetProcess(xsltStylesheetPtr ret,\n+                                                 xmlDocPtr doc);\n@@ -1860,2 +1864,2 @@\n-            xsltParseStylesheetOutput(xsltStylesheetPtr style,\n-                         xmlNodePtr cur);\n+                        xsltParseStylesheetOutput(xsltStylesheetPtr style,\n+                                                 xmlNodePtr cur);\n@@ -1863,1 +1867,1 @@\n-            xsltParseStylesheetDoc  (xmlDocPtr doc);\n+                        xsltParseStylesheetDoc  (xmlDocPtr doc);\n@@ -1865,2 +1869,2 @@\n-            xsltParseStylesheetImportedDoc(xmlDocPtr doc,\n-                        xsltStylesheetPtr style);\n+                        xsltParseStylesheetImportedDoc(xmlDocPtr doc,\n+                                                xsltStylesheetPtr style);\n@@ -1868,2 +1872,2 @@\n-            xsltParseStylesheetUser(xsltStylesheetPtr style,\n-                        xmlDocPtr doc);\n+                        xsltParseStylesheetUser(xsltStylesheetPtr style,\n+                                                xmlDocPtr doc);\n@@ -1871,1 +1875,1 @@\n-            xsltLoadStylesheetPI    (xmlDocPtr doc);\n+                        xsltLoadStylesheetPI    (xmlDocPtr doc);\n@@ -1873,3 +1877,3 @@\n-            xsltNumberFormat    (xsltTransformContextPtr ctxt,\n-                         xsltNumberDataPtr data,\n-                         xmlNodePtr node);\n+                        xsltNumberFormat        (xsltTransformContextPtr ctxt,\n+                                                 xsltNumberDataPtr data,\n+                                                 xmlNodePtr node);\n@@ -1877,4 +1881,4 @@\n-            xsltFormatNumberConversion(xsltDecimalFormatPtr self,\n-                         xmlChar *format,\n-                         double number,\n-                         xmlChar **result);\n+                        xsltFormatNumberConversion(xsltDecimalFormatPtr self,\n+                                                 xmlChar *format,\n+                                                 double number,\n+                                                 xmlChar **result);\n@@ -1883,2 +1887,2 @@\n-            xsltParseTemplateContent(xsltStylesheetPtr style,\n-                         xmlNodePtr templ);\n+                        xsltParseTemplateContent(xsltStylesheetPtr style,\n+                                                 xmlNodePtr templ);\n@@ -1886,1 +1890,1 @@\n-            xsltAllocateExtra   (xsltStylesheetPtr style);\n+                        xsltAllocateExtra       (xsltStylesheetPtr style);\n@@ -1888,1 +1892,1 @@\n-            xsltAllocateExtraCtxt   (xsltTransformContextPtr ctxt);\n+                        xsltAllocateExtraCtxt   (xsltTransformContextPtr ctxt);\n@@ -1893,1 +1897,1 @@\n-            xsltCreateRVT       (xsltTransformContextPtr ctxt);\n+                        xsltCreateRVT           (xsltTransformContextPtr ctxt);\n@@ -1895,2 +1899,2 @@\n-            xsltRegisterTmpRVT  (xsltTransformContextPtr ctxt,\n-                         xmlDocPtr RVT);\n+                        xsltRegisterTmpRVT      (xsltTransformContextPtr ctxt,\n+                                                 xmlDocPtr RVT);\n@@ -1898,2 +1902,2 @@\n-            xsltRegisterLocalRVT    (xsltTransformContextPtr ctxt,\n-                         xmlDocPtr RVT);\n+                        xsltRegisterLocalRVT    (xsltTransformContextPtr ctxt,\n+                                                 xmlDocPtr RVT);\n@@ -1901,2 +1905,2 @@\n-            xsltRegisterPersistRVT  (xsltTransformContextPtr ctxt,\n-                         xmlDocPtr RVT);\n+                        xsltRegisterPersistRVT  (xsltTransformContextPtr ctxt,\n+                                                 xmlDocPtr RVT);\n@@ -1904,3 +1908,3 @@\n-            xsltExtensionInstructionResultRegister(\n-                         xsltTransformContextPtr ctxt,\n-                         xmlXPathObjectPtr obj);\n+                        xsltExtensionInstructionResultRegister(\n+                                                 xsltTransformContextPtr ctxt,\n+                                                 xmlXPathObjectPtr obj);\n@@ -1908,2 +1912,2 @@\n-            xsltExtensionInstructionResultFinalize(\n-                         xsltTransformContextPtr ctxt);\n+                        xsltExtensionInstructionResultFinalize(\n+                                                 xsltTransformContextPtr ctxt);\n@@ -1911,4 +1915,4 @@\n-            xsltFlagRVTs(\n-                         xsltTransformContextPtr ctxt,\n-                         xmlXPathObjectPtr obj,\n-                         void *val);\n+                        xsltFlagRVTs(\n+                                                 xsltTransformContextPtr ctxt,\n+                                                 xmlXPathObjectPtr obj,\n+                                                 void *val);\n@@ -1916,1 +1920,1 @@\n-            xsltFreeRVTs        (xsltTransformContextPtr ctxt);\n+                        xsltFreeRVTs            (xsltTransformContextPtr ctxt);\n@@ -1918,2 +1922,2 @@\n-            xsltReleaseRVT      (xsltTransformContextPtr ctxt,\n-                         xmlDocPtr RVT);\n+                        xsltReleaseRVT          (xsltTransformContextPtr ctxt,\n+                                                 xmlDocPtr RVT);\n@@ -1924,2 +1928,2 @@\n-            xsltCompileAttr     (xsltStylesheetPtr style,\n-                         xmlAttrPtr attr);\n+                        xsltCompileAttr         (xsltStylesheetPtr style,\n+                                                 xmlAttrPtr attr);\n@@ -1927,3 +1931,3 @@\n-            xsltEvalAVT     (xsltTransformContextPtr ctxt,\n-                         void *avt,\n-                         xmlNodePtr node);\n+                        xsltEvalAVT             (xsltTransformContextPtr ctxt,\n+                                                 void *avt,\n+                                                 xmlNodePtr node);\n@@ -1931,1 +1935,1 @@\n-            xsltFreeAVTList     (void *avt);\n+                        xsltFreeAVTList         (void *avt);\n@@ -1938,1 +1942,1 @@\n-            xsltUninit      (void);\n+                        xsltUninit              (void);\n@@ -1941,1 +1945,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -1943,1 +1947,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -1948,3 +1952,3 @@\n-            xsltParseSequenceConstructor(\n-                         xsltCompilerCtxtPtr cctxt,\n-                         xmlNodePtr start);\n+                        xsltParseSequenceConstructor(\n+                                                 xsltCompilerCtxtPtr cctxt,\n+                                                 xmlNodePtr start);\n@@ -1952,2 +1956,2 @@\n-            xsltParseAnyXSLTElem    (xsltCompilerCtxtPtr cctxt,\n-                         xmlNodePtr elem);\n+                        xsltParseAnyXSLTElem    (xsltCompilerCtxtPtr cctxt,\n+                                                 xmlNodePtr elem);\n@@ -1956,3 +1960,3 @@\n-            xsltRestoreDocumentNamespaces(\n-                         xsltNsMapPtr ns,\n-                         xmlDocPtr doc);\n+                        xsltRestoreDocumentNamespaces(\n+                                                 xsltNsMapPtr ns,\n+                                                 xmlDocPtr doc);\n@@ -1963,1 +1967,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -1965,1 +1969,1 @@\n- *                                  *\n+ *                                                                      *\n@@ -1968,3 +1972,3 @@\n-            xsltInitCtxtKey     (xsltTransformContextPtr ctxt,\n-                         xsltDocumentPtr doc,\n-                         xsltKeyDefPtr keyd);\n+                        xsltInitCtxtKey         (xsltTransformContextPtr ctxt,\n+                                                 xsltDocumentPtr doc,\n+                                                 xsltKeyDefPtr keyd);\n@@ -1972,1 +1976,1 @@\n-            xsltInitAllDocKeys  (xsltTransformContextPtr ctxt);\n+                        xsltInitAllDocKeys      (xsltTransformContextPtr ctxt);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/xsltInternals.h","additions":269,"deletions":265,"binary":false,"changes":534,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-#define LIBXSLT_DOTTED_VERSION \"1.1.34\"\n+#define LIBXSLT_DOTTED_VERSION \"1.1.35\"\n@@ -30,1 +30,1 @@\n-#define LIBXSLT_VERSION 10134\n+#define LIBXSLT_VERSION 10135\n@@ -37,1 +37,1 @@\n-#define LIBXSLT_VERSION_STRING \"10134\"\n+#define LIBXSLT_VERSION_STRING \"10135\"\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/xsltconfig.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,4 +27,4 @@\n-#define XSLTMAX_ISO639LANGLEN       8\n-#define XSLTMAX_ISO3166CNTRYLEN     8\n-                    \/* <lang>-<cntry> *\/\n-#define XSLTMAX_LANGTAGLEN      (XSLTMAX_ISO639LANGLEN+1+XSLTMAX_ISO3166CNTRYLEN)\n+#define XSLTMAX_ISO639LANGLEN           8\n+#define XSLTMAX_ISO3166CNTRYLEN         8\n+                                        \/* <lang>-<cntry> *\/\n+#define XSLTMAX_LANGTAGLEN              (XSLTMAX_ISO639LANGLEN+1+XSLTMAX_ISO3166CNTRYLEN)\n@@ -55,1 +55,1 @@\n-    if (xmlStrcmp(p->tag, languageTag) == 0) return p->lcid;\n+        if (xmlStrcmp(p->tag, languageTag) == 0) return p->lcid;\n@@ -99,1 +99,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -102,1 +102,1 @@\n-    *q++ = TOLOWER(*p++);\n+        *q++ = TOLOWER(*p++);\n@@ -105,1 +105,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -110,2 +110,2 @@\n-    if (*p++ != '-')\n-        return(NULL);\n+        if (*p++ != '-')\n+            return(NULL);\n@@ -114,2 +114,2 @@\n-    for (i=0; i<XSLTMAX_ISO3166CNTRYLEN && ISALPHA(*p); ++i)\n-        *q++ = TOUPPER(*p++);\n+        for (i=0; i<XSLTMAX_ISO3166CNTRYLEN && ISALPHA(*p); ++i)\n+            *q++ = TOUPPER(*p++);\n@@ -117,2 +117,2 @@\n-    if (i == 0 || *p)\n-        return(NULL);\n+        if (i == 0 || *p)\n+            return(NULL);\n@@ -170,1 +170,1 @@\n-    *q++ = TOLOWER(*p++);\n+        *q++ = TOLOWER(*p++);\n@@ -176,1 +176,1 @@\n-    if (*p++ != '-') goto end;\n+        if (*p++ != '-') goto end;\n@@ -178,3 +178,3 @@\n-    for (i=0; i<XSLTMAX_ISO3166CNTRYLEN && ISALPHA(*p); ++i)\n-        *q++ = TOUPPER(*p++);\n-    if (i == 0 || *p) goto end;\n+        for (i=0; i<XSLTMAX_ISO3166CNTRYLEN && ISALPHA(*p); ++i)\n+            *q++ = TOUPPER(*p++);\n+        if (i == 0 || *p) goto end;\n@@ -182,3 +182,3 @@\n-    *q = '\\0';\n-    locale = xslt_locale_WINAPI(localeName);\n-    if (locale != (xsltLocale)0) goto end;\n+        *q = '\\0';\n+        locale = xslt_locale_WINAPI(localeName);\n+        if (locale != (xsltLocale)0) goto end;\n@@ -349,1 +349,2 @@\n-    freelocale(locale);\n+    if (locale != NULL)\n+        freelocale(locale);\n@@ -376,3 +377,3 @@\n-    xsltTransformError(NULL, NULL, NULL,\n-        \"xsltStrxfrm : out of memory error\\n\");\n-    return(NULL);\n+        xsltTransformError(NULL, NULL, NULL,\n+            \"xsltStrxfrm : out of memory error\\n\");\n+        return(NULL);\n@@ -405,1 +406,1 @@\n-    xsltTransformError(NULL, NULL, NULL, \"xsltStrxfrm : strxfrm failed\\n\");\n+        xsltTransformError(NULL, NULL, NULL, \"xsltStrxfrm : strxfrm failed\\n\");\n@@ -490,7 +491,7 @@\n-    xmlChar    *q = p->tag;\n-    memcpy(q, iso639lang, k);\n-    q += k;\n-    *q++ = '-';\n-    memcpy(q, iso3136ctry, l);\n-    q += l;\n-    *q = '\\0';\n+        xmlChar    *q = p->tag;\n+        memcpy(q, iso639lang, k);\n+        q += k;\n+        *q++ = '-';\n+        memcpy(q, iso3136ctry, l);\n+        q += l;\n+        *q = '\\0';\n@@ -508,1 +509,1 @@\n-    size_t len;\n+        size_t len;\n@@ -510,1 +511,1 @@\n-    EnumSystemLocalesA(xsltCountSupportedLocales, LCID_SUPPORTED);\n+        EnumSystemLocalesA(xsltCountSupportedLocales, LCID_SUPPORTED);\n@@ -512,4 +513,4 @@\n-    len = xsltLocaleListSize * sizeof(xsltRFC1766Info);\n-    xsltLocaleList = xmlMalloc(len);\n-    memset(xsltLocaleList, 0, len);\n-    EnumSystemLocalesA(xsltIterateSupportedLocales, LCID_SUPPORTED);\n+        len = xsltLocaleListSize * sizeof(xsltRFC1766Info);\n+        xsltLocaleList = xmlMalloc(len);\n+        memset(xsltLocaleList, 0, len);\n+        EnumSystemLocalesA(xsltIterateSupportedLocales, LCID_SUPPORTED);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/xsltlocale.c","additions":41,"deletions":40,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    xsltNewLocale           (const xmlChar *langName);\n+        xsltNewLocale                   (const xmlChar *langName);\n@@ -65,1 +65,1 @@\n-    xsltFreeLocale          (xsltLocale locale);\n+        xsltFreeLocale                  (xsltLocale locale);\n@@ -67,2 +67,2 @@\n-    xsltStrxfrm         (xsltLocale locale,\n-                     const xmlChar *string);\n+        xsltStrxfrm                     (xsltLocale locale,\n+                                         const xmlChar *string);\n@@ -70,3 +70,3 @@\n-    xsltLocaleStrcmp        (xsltLocale locale,\n-                     const xsltLocaleChar *str1,\n-                     const xsltLocaleChar *str2);\n+        xsltLocaleStrcmp                (xsltLocale locale,\n+                                         const xsltLocaleChar *str1,\n+                                         const xsltLocaleChar *str2);\n@@ -74,1 +74,1 @@\n-    xsltFreeLocales         (void);\n+        xsltFreeLocales                 (void);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/xsltlocale.h","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -50,3 +50,3 @@\n- *                                  *\n- *          Convenience function                *\n- *                                  *\n+ *                                                                      *\n+ *                      Convenience function                            *\n+ *                                                                      *\n@@ -85,1 +85,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -93,1 +93,1 @@\n-    prop = node->properties;\n+        prop = node->properties;\n@@ -95,1 +95,1 @@\n-    prop = NULL;\n+        prop = NULL;\n@@ -97,5 +97,5 @@\n-    \/*\n-     * One need to have\n-     *   - same attribute names\n-     *   - and the attribute carrying that namespace\n-     *\/\n+        \/*\n+         * One need to have\n+         *   - same attribute names\n+         *   - and the attribute carrying that namespace\n+         *\/\n@@ -103,13 +103,13 @@\n-        (((prop->ns == NULL) && (node->ns != NULL) &&\n-          (xmlStrEqual(node->ns->href, nameSpace))) ||\n-         ((prop->ns != NULL) &&\n-          (xmlStrEqual(prop->ns->href, nameSpace))))) {\n-\n-        tmp = xmlNodeListGetString(node->doc, prop->children, 1);\n-        if (tmp == NULL)\n-            ret = xmlDictLookup(style->dict, BAD_CAST \"\", 0);\n-        else {\n-            ret = xmlDictLookup(style->dict, tmp, -1);\n-        xmlFree(tmp);\n-        }\n-        return ret;\n+            (((prop->ns == NULL) && (node->ns != NULL) &&\n+              (xmlStrEqual(node->ns->href, nameSpace))) ||\n+             ((prop->ns != NULL) &&\n+              (xmlStrEqual(prop->ns->href, nameSpace))))) {\n+\n+            tmp = xmlNodeListGetString(node->doc, prop->children, 1);\n+            if (tmp == NULL)\n+                ret = xmlDictLookup(style->dict, BAD_CAST \"\", 0);\n+            else {\n+                ret = xmlDictLookup(style->dict, tmp, -1);\n+                xmlFree(tmp);\n+            }\n+            return ret;\n@@ -117,1 +117,1 @@\n-    prop = prop->next;\n+        prop = prop->next;\n@@ -127,14 +127,15 @@\n-        xmlAttributePtr attrDecl;\n-\n-        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, node->name, name);\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdAttrDesc(doc->extSubset, node->name, name);\n-\n-        if ((attrDecl != NULL) && (attrDecl->prefix != NULL)) {\n-            \/*\n-         * The DTD declaration only allows a prefix search\n-         *\/\n-        ns = xmlSearchNs(doc, node, attrDecl->prefix);\n-        if ((ns != NULL) && (xmlStrEqual(ns->href, nameSpace)))\n-            return(xmlDictLookup(style->dict,\n-                                 attrDecl->defaultValue, -1));\n+            xmlAttributePtr attrDecl;\n+\n+            attrDecl = xmlGetDtdAttrDesc(doc->intSubset, node->name, name);\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdAttrDesc(doc->extSubset, node->name, name);\n+\n+            if ((attrDecl != NULL) && (attrDecl->prefix != NULL)) {\n+                \/*\n+                 * The DTD declaration only allows a prefix search\n+                 *\/\n+                ns = xmlSearchNs(doc, node, attrDecl->prefix);\n+                if ((ns != NULL) && (xmlStrEqual(ns->href, nameSpace)))\n+                    return(xmlDictLookup(style->dict,\n+                                         attrDecl->defaultValue, -1));\n+            }\n@@ -143,1 +144,0 @@\n-    }\n@@ -172,1 +172,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -180,1 +180,1 @@\n-    prop = node->properties;\n+        prop = node->properties;\n@@ -182,1 +182,1 @@\n-    prop = NULL;\n+        prop = NULL;\n@@ -193,5 +193,5 @@\n-    \/*\n-     * One need to have\n-     *   - same attribute names\n-     *   - and the attribute carrying that namespace\n-     *\/\n+        \/*\n+         * One need to have\n+         *   - same attribute names\n+         *   - and the attribute carrying that namespace\n+         *\/\n@@ -199,9 +199,9 @@\n-        (((prop->ns == NULL) && (node->ns != NULL) &&\n-          (xmlStrEqual(node->ns->href, nameSpace))) ||\n-         ((prop->ns != NULL) &&\n-          (xmlStrEqual(prop->ns->href, nameSpace))))) {\n-        xmlChar *ret;\n-\n-        ret = xmlNodeListGetString(node->doc, prop->children, 1);\n-        if (ret == NULL) return(xmlStrdup((xmlChar *)\"\"));\n-        return(ret);\n+            (((prop->ns == NULL) && (node->ns != NULL) &&\n+              (xmlStrEqual(node->ns->href, nameSpace))) ||\n+             ((prop->ns != NULL) &&\n+              (xmlStrEqual(prop->ns->href, nameSpace))))) {\n+            xmlChar *ret;\n+\n+            ret = xmlNodeListGetString(node->doc, prop->children, 1);\n+            if (ret == NULL) return(xmlStrdup((xmlChar *)\"\"));\n+            return(ret);\n@@ -209,1 +209,1 @@\n-    prop = prop->next;\n+        prop = prop->next;\n@@ -219,13 +219,14 @@\n-        xmlAttributePtr attrDecl;\n-\n-        attrDecl = xmlGetDtdAttrDesc(doc->intSubset, node->name, name);\n-        if ((attrDecl == NULL) && (doc->extSubset != NULL))\n-        attrDecl = xmlGetDtdAttrDesc(doc->extSubset, node->name, name);\n-\n-        if ((attrDecl != NULL) && (attrDecl->prefix != NULL)) {\n-            \/*\n-         * The DTD declaration only allows a prefix search\n-         *\/\n-        ns = xmlSearchNs(doc, node, attrDecl->prefix);\n-        if ((ns != NULL) && (xmlStrEqual(ns->href, nameSpace)))\n-            return(xmlStrdup(attrDecl->defaultValue));\n+            xmlAttributePtr attrDecl;\n+\n+            attrDecl = xmlGetDtdAttrDesc(doc->intSubset, node->name, name);\n+            if ((attrDecl == NULL) && (doc->extSubset != NULL))\n+                attrDecl = xmlGetDtdAttrDesc(doc->extSubset, node->name, name);\n+\n+            if ((attrDecl != NULL) && (attrDecl->prefix != NULL)) {\n+                \/*\n+                 * The DTD declaration only allows a prefix search\n+                 *\/\n+                ns = xmlSearchNs(doc, node, attrDecl->prefix);\n+                if ((ns != NULL) && (xmlStrEqual(ns->href, nameSpace)))\n+                    return(xmlStrdup(attrDecl->defaultValue));\n+            }\n@@ -234,1 +235,0 @@\n-    }\n@@ -255,1 +255,1 @@\n-    goto error;\n+        goto error;\n@@ -257,1 +257,1 @@\n-    goto error;\n+        goto error;\n@@ -259,1 +259,1 @@\n-    goto error;\n+        goto error;\n@@ -263,11 +263,1 @@\n-    if (*len < 2)\n-        goto error;\n-    if ((utf[1] & 0xc0) != 0x80)\n-        goto error;\n-    if ((c & 0xe0) == 0xe0) {\n-        if (*len < 3)\n-        goto error;\n-        if ((utf[2] & 0xc0) != 0x80)\n-        goto error;\n-        if ((c & 0xf0) == 0xf0) {\n-        if (*len < 4)\n+        if (*len < 2)\n@@ -275,1 +265,1 @@\n-        if ((c & 0xf8) != 0xf0 || (utf[3] & 0xc0) != 0x80)\n+        if ((utf[1] & 0xc0) != 0x80)\n@@ -277,6 +267,23 @@\n-        *len = 4;\n-        \/* 4-byte code *\/\n-        c = (utf[0] & 0x7) << 18;\n-        c |= (utf[1] & 0x3f) << 12;\n-        c |= (utf[2] & 0x3f) << 6;\n-        c |= utf[3] & 0x3f;\n+        if ((c & 0xe0) == 0xe0) {\n+            if (*len < 3)\n+                goto error;\n+            if ((utf[2] & 0xc0) != 0x80)\n+                goto error;\n+            if ((c & 0xf0) == 0xf0) {\n+                if (*len < 4)\n+                    goto error;\n+                if ((c & 0xf8) != 0xf0 || (utf[3] & 0xc0) != 0x80)\n+                    goto error;\n+                *len = 4;\n+                \/* 4-byte code *\/\n+                c = (utf[0] & 0x7) << 18;\n+                c |= (utf[1] & 0x3f) << 12;\n+                c |= (utf[2] & 0x3f) << 6;\n+                c |= utf[3] & 0x3f;\n+            } else {\n+              \/* 3-byte code *\/\n+                *len = 3;\n+                c = (utf[0] & 0xf) << 12;\n+                c |= (utf[1] & 0x3f) << 6;\n+                c |= utf[2] & 0x3f;\n+            }\n@@ -284,5 +291,4 @@\n-          \/* 3-byte code *\/\n-        *len = 3;\n-        c = (utf[0] & 0xf) << 12;\n-        c |= (utf[1] & 0x3f) << 6;\n-        c |= utf[2] & 0x3f;\n+          \/* 2-byte code *\/\n+            *len = 2;\n+            c = (utf[0] & 0x1f) << 6;\n+            c |= utf[1] & 0x3f;\n@@ -291,8 +297,2 @@\n-      \/* 2-byte code *\/\n-        *len = 2;\n-        c = (utf[0] & 0x1f) << 6;\n-        c |= utf[1] & 0x3f;\n-    }\n-    } else {\n-    \/* 1-byte code *\/\n-    *len = 1;\n+        \/* 1-byte code *\/\n+        *len = 1;\n@@ -304,1 +304,1 @@\n-    *len = 0;\n+        *len = 0;\n@@ -323,2 +323,2 @@\n-               void *item,\n-               int initialSize)\n+                       void *item,\n+                       int initialSize)\n@@ -327,11 +327,11 @@\n-    if (initialSize <= 0)\n-        initialSize = 1;\n-    list->items = (void **) xmlMalloc(\n-        initialSize * sizeof(void *));\n-    if (list->items == NULL) {\n-        xsltGenericError(xsltGenericErrorContext,\n-         \"xsltPointerListAddSize: memory allocation failure.\\n\");\n-        return(-1);\n-    }\n-    list->number = 0;\n-    list->size = initialSize;\n+        if (initialSize <= 0)\n+            initialSize = 1;\n+        list->items = (void **) xmlMalloc(\n+            initialSize * sizeof(void *));\n+        if (list->items == NULL) {\n+            xsltGenericError(xsltGenericErrorContext,\n+             \"xsltPointerListAddSize: memory allocation failure.\\n\");\n+            return(-1);\n+        }\n+        list->number = 0;\n+        list->size = initialSize;\n@@ -339,9 +339,9 @@\n-    list->size *= 2;\n-    list->items = (void **) xmlRealloc(list->items,\n-        list->size * sizeof(void *));\n-    if (list->items == NULL) {\n-        xsltGenericError(xsltGenericErrorContext,\n-         \"xsltPointerListAddSize: memory re-allocation failure.\\n\");\n-        list->size = 0;\n-        return(-1);\n-    }\n+        list->size *= 2;\n+        list->items = (void **) xmlRealloc(list->items,\n+            list->size * sizeof(void *));\n+        if (list->items == NULL) {\n+            xsltGenericError(xsltGenericErrorContext,\n+             \"xsltPointerListAddSize: memory re-allocation failure.\\n\");\n+            list->size = 0;\n+            return(-1);\n+        }\n@@ -368,3 +368,3 @@\n-    xsltGenericError(xsltGenericErrorContext,\n-         \"xsltPointerListCreate: memory allocation failure.\\n\");\n-    return (NULL);\n+        xsltGenericError(xsltGenericErrorContext,\n+             \"xsltPointerListCreate: memory allocation failure.\\n\");\n+        return (NULL);\n@@ -374,2 +374,2 @@\n-    xsltPointerListAddSize(ret, NULL, initialSize);\n-    ret->number = 0;\n+        xsltPointerListAddSize(ret, NULL, initialSize);\n+        ret->number = 0;\n@@ -391,1 +391,1 @@\n-    return;\n+        return;\n@@ -393,1 +393,1 @@\n-    xmlFree(list->items);\n+        xmlFree(list->items);\n@@ -408,2 +408,2 @@\n-    xmlFree(list->items);\n-    list->items = NULL;\n+        xmlFree(list->items);\n+        list->items = NULL;\n@@ -418,3 +418,3 @@\n- *                                  *\n- *      Handling of XSLT stylesheets messages           *\n- *                                  *\n+ *                                                                      *\n+ *              Handling of XSLT stylesheets messages                   *\n+ *                                                                      *\n@@ -439,1 +439,1 @@\n-    return;\n+        return;\n@@ -442,2 +442,2 @@\n-    error = ctxt->error;\n-    errctx = ctxt->errctx;\n+        error = ctxt->error;\n+        errctx = ctxt->errctx;\n@@ -448,9 +448,9 @@\n-    if (xmlStrEqual(prop, (const xmlChar *)\"yes\")) {\n-        terminate = 1;\n-    } else if (xmlStrEqual(prop, (const xmlChar *)\"no\")) {\n-        terminate = 0;\n-    } else {\n-        xsltTransformError(ctxt, NULL, inst,\n-        \"xsl:message : terminate expecting 'yes' or 'no'\\n\");\n-    }\n-    xmlFree(prop);\n+        if (xmlStrEqual(prop, (const xmlChar *)\"yes\")) {\n+            terminate = 1;\n+        } else if (xmlStrEqual(prop, (const xmlChar *)\"no\")) {\n+            terminate = 0;\n+        } else {\n+            xsltTransformError(ctxt, NULL, inst,\n+                \"xsl:message : terminate expecting 'yes' or 'no'\\n\");\n+        }\n+        xmlFree(prop);\n@@ -460,1 +460,1 @@\n-    int len = xmlStrlen(message);\n+        int len = xmlStrlen(message);\n@@ -462,4 +462,4 @@\n-    error(errctx, \"%s\", (const char *)message);\n-    if ((len > 0) && (message[len - 1] != '\\n'))\n-        error(errctx, \"\\n\");\n-    xmlFree(message);\n+        error(errctx, \"%s\", (const char *)message);\n+        if ((len > 0) && (message[len - 1] != '\\n'))\n+            error(errctx, \"\\n\");\n+        xmlFree(message);\n@@ -468,1 +468,1 @@\n-    ctxt->state = XSLT_STATE_STOPPED;\n+        ctxt->state = XSLT_STATE_STOPPED;\n@@ -472,3 +472,3 @@\n- *                                  *\n- *      Handling of out of context errors           *\n- *                                  *\n+ *                                                                      *\n+ *              Handling of out of context errors                       *\n+ *                                                                      *\n@@ -477,28 +477,28 @@\n-#define XSLT_GET_VAR_STR(msg, str) {                \\\n-    int       size;                     \\\n-    int       chars;                        \\\n-    char      *larger;                      \\\n-    va_list   ap;                       \\\n-                                \\\n-    str = (char *) xmlMalloc(150);              \\\n-    if (str == NULL)                        \\\n-    return;                         \\\n-                                \\\n-    size = 150;                         \\\n-                                \\\n-    while (size < 64000) {                  \\\n-    va_start(ap, msg);                  \\\n-    chars = vsnprintf(str, size, msg, ap);          \\\n-    va_end(ap);                     \\\n-    if ((chars > -1) && (chars < size))         \\\n-        break;                      \\\n-    if (chars > -1)                     \\\n-        size += chars + 1;                  \\\n-    else                            \\\n-        size += 100;                    \\\n-    if ((larger = (char *) xmlRealloc(str, size)) == NULL) {\\\n-        xmlFree(str);                   \\\n-        return;                     \\\n-    }                           \\\n-    str = larger;                       \\\n-    }                               \\\n+#define XSLT_GET_VAR_STR(msg, str) {                            \\\n+    int       size;                                             \\\n+    int       chars;                                            \\\n+    char      *larger;                                          \\\n+    va_list   ap;                                               \\\n+                                                                \\\n+    str = (char *) xmlMalloc(150);                              \\\n+    if (str == NULL)                                            \\\n+        return;                                                 \\\n+                                                                \\\n+    size = 150;                                                 \\\n+                                                                \\\n+    while (size < 64000) {                                      \\\n+        va_start(ap, msg);                                      \\\n+        chars = vsnprintf(str, size, msg, ap);                  \\\n+        va_end(ap);                                             \\\n+        if ((chars > -1) && (chars < size))                     \\\n+            break;                                              \\\n+        if (chars > -1)                                         \\\n+            size += chars + 1;                                  \\\n+        else                                                    \\\n+            size += 100;                                        \\\n+        if ((larger = (char *) xmlRealloc(str, size)) == NULL) {\\\n+            xmlFree(str);                                       \\\n+            return;                                             \\\n+        }                                                       \\\n+        str = larger;                                           \\\n+    }                                                           \\\n@@ -519,1 +519,1 @@\n-    xsltGenericErrorContext = (void *) stderr;\n+        xsltGenericErrorContext = (void *) stderr;\n@@ -547,1 +547,1 @@\n-    xsltGenericError = handler;\n+        xsltGenericError = handler;\n@@ -549,1 +549,1 @@\n-    xsltGenericError = xsltGenericErrorDefaultFunc;\n+        xsltGenericError = xsltGenericErrorDefaultFunc;\n@@ -565,1 +565,1 @@\n-    return;\n+        return;\n@@ -593,1 +593,1 @@\n-    xsltGenericDebug = handler;\n+        xsltGenericDebug = handler;\n@@ -595,1 +595,1 @@\n-    xsltGenericDebug = xsltGenericDebugDefaultFunc;\n+        xsltGenericDebug = xsltGenericDebugDefaultFunc;\n@@ -608,1 +608,1 @@\n-                  xsltStylesheetPtr style, xmlNodePtr node) {\n+                      xsltStylesheetPtr style, xmlNodePtr node) {\n@@ -618,5 +618,5 @@\n-        ctxt->state = XSLT_STATE_ERROR;\n-    if (ctxt->error != NULL) {\n-        error = ctxt->error;\n-        errctx = ctxt->errctx;\n-    }\n+            ctxt->state = XSLT_STATE_ERROR;\n+        if (ctxt->error != NULL) {\n+            error = ctxt->error;\n+            errctx = ctxt->errctx;\n+        }\n@@ -625,1 +625,1 @@\n-    node = ctxt->inst;\n+        node = ctxt->inst;\n@@ -628,3 +628,3 @@\n-    if ((node->type == XML_DOCUMENT_NODE) ||\n-        (node->type == XML_HTML_DOCUMENT_NODE)) {\n-        xmlDocPtr doc = (xmlDocPtr) node;\n+        if ((node->type == XML_DOCUMENT_NODE) ||\n+            (node->type == XML_HTML_DOCUMENT_NODE)) {\n+            xmlDocPtr doc = (xmlDocPtr) node;\n@@ -632,8 +632,8 @@\n-        file = doc->URL;\n-    } else {\n-        line = xmlGetLineNo(node);\n-        if ((node->doc != NULL) && (node->doc->URL != NULL))\n-        file = node->doc->URL;\n-        if (node->name != NULL)\n-        name = node->name;\n-    }\n+            file = doc->URL;\n+        } else {\n+            line = xmlGetLineNo(node);\n+            if ((node->doc != NULL) && (node->doc->URL != NULL))\n+                file = node->doc->URL;\n+            if (node->name != NULL)\n+                name = node->name;\n+        }\n@@ -643,1 +643,1 @@\n-    type = \"runtime error\";\n+        type = \"runtime error\";\n@@ -646,4 +646,4 @@\n-    if (XSLT_CCTXT(style)->errSeverity == XSLT_ERROR_SEVERITY_WARNING)\n-        type = \"compilation warning\";\n-    else\n-        type = \"compilation error\";\n+        if (XSLT_CCTXT(style)->errSeverity == XSLT_ERROR_SEVERITY_WARNING)\n+            type = \"compilation warning\";\n+        else\n+            type = \"compilation error\";\n@@ -651,1 +651,1 @@\n-    type = \"compilation error\";\n+        type = \"compilation error\";\n@@ -656,2 +656,2 @@\n-    error(errctx, \"%s: file %s line %d element %s\\n\",\n-          type, file, line, name);\n+        error(errctx, \"%s: file %s line %d element %s\\n\",\n+              type, file, line, name);\n@@ -659,1 +659,1 @@\n-    error(errctx, \"%s: file %s element %s\\n\", type, file, name);\n+        error(errctx, \"%s: file %s element %s\\n\", type, file, name);\n@@ -661,1 +661,1 @@\n-    error(errctx, \"%s: file %s line %d\\n\", type, file, line);\n+        error(errctx, \"%s: file %s line %d\\n\", type, file, line);\n@@ -663,1 +663,1 @@\n-    error(errctx, \"%s: file %s\\n\", type, file);\n+        error(errctx, \"%s: file %s\\n\", type, file);\n@@ -665,1 +665,1 @@\n-    error(errctx, \"%s: element %s\\n\", type, name);\n+        error(errctx, \"%s: element %s\\n\", type, name);\n@@ -667,1 +667,1 @@\n-    error(errctx, \"%s\\n\", type);\n+        error(errctx, \"%s\\n\", type);\n@@ -703,3 +703,3 @@\n-           xsltStylesheetPtr style,\n-           xmlNodePtr node,\n-           const char *msg, ...) {\n+                   xsltStylesheetPtr style,\n+                   xmlNodePtr node,\n+                   const char *msg, ...) {\n@@ -712,5 +712,5 @@\n-        ctxt->state = XSLT_STATE_ERROR;\n-    if (ctxt->error != NULL) {\n-        error = ctxt->error;\n-        errctx = ctxt->errctx;\n-    }\n+            ctxt->state = XSLT_STATE_ERROR;\n+        if (ctxt->error != NULL) {\n+            error = ctxt->error;\n+            errctx = ctxt->errctx;\n+        }\n@@ -719,1 +719,1 @@\n-    node = ctxt->inst;\n+        node = ctxt->inst;\n@@ -724,1 +724,1 @@\n-    xmlFree(str);\n+        xmlFree(str);\n@@ -728,3 +728,3 @@\n- *                                  *\n- *              QNames                  *\n- *                                  *\n+ *                                                                      *\n+ *                              QNames                                  *\n+ *                                                                      *\n@@ -784,1 +784,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -787,1 +787,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -789,6 +789,6 @@\n-    xsltGenericError(xsltGenericErrorContext,\n-                 \"QName: no element for namespace lookup %s\\n\",\n-             qname);\n-    xmlFree(qname);\n-    *name = NULL;\n-    return(NULL);\n+        xsltGenericError(xsltGenericErrorContext,\n+                         \"QName: no element for namespace lookup %s\\n\",\n+                         qname);\n+        xmlFree(qname);\n+        *name = NULL;\n+        return(NULL);\n@@ -799,1 +799,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -806,1 +806,1 @@\n-    len++;\n+        len++;\n@@ -809,1 +809,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -816,2 +816,2 @@\n-    if (qname[4] == 0)\n-        return(NULL);\n+        if (qname[4] == 0)\n+            return(NULL);\n@@ -819,2 +819,2 @@\n-    xmlFree(qname);\n-    return(XML_XML_NAMESPACE);\n+        xmlFree(qname);\n+        return(XML_XML_NAMESPACE);\n@@ -826,6 +826,6 @@\n-    xsltGenericError(xsltGenericErrorContext,\n-        \"%s:%s : no namespace bound to prefix %s\\n\",\n-                 qname, &qname[len + 1], qname);\n-    *name = NULL;\n-    xmlFree(qname);\n-    return(NULL);\n+        xsltGenericError(xsltGenericErrorContext,\n+                \"%s:%s : no namespace bound to prefix %s\\n\",\n+                         qname, &qname[len + 1], qname);\n+        *name = NULL;\n+        xmlFree(qname);\n+        return(NULL);\n@@ -852,1 +852,1 @@\n-         const xmlChar **name) {\n+                 const xmlChar **name) {\n@@ -866,2 +866,2 @@\n-    *name = NULL;\n-    return(NULL);\n+        *name = NULL;\n+        return(NULL);\n@@ -894,7 +894,7 @@\n-    if (style) {\n-        xsltTransformError(NULL, style, node,\n-        \"No namespace bound to prefix '%s'.\\n\",\n-        qname);\n-        style->errors++;\n-    } else {\n-        xsltGenericError(xsltGenericErrorContext,\n+        if (style) {\n+            xsltTransformError(NULL, style, node,\n+                \"No namespace bound to prefix '%s'.\\n\",\n+                qname);\n+            style->errors++;\n+        } else {\n+            xsltGenericError(xsltGenericErrorContext,\n@@ -902,2 +902,2 @@\n-        *name, qname);\n-    }\n+                *name, qname);\n+        }\n@@ -914,3 +914,3 @@\n- *                                  *\n- *              Sorting                 *\n- *                                  *\n+ *                                                                      *\n+ *                              Sorting                                 *\n+ *                                                                      *\n@@ -933,1 +933,1 @@\n-    return;\n+        return;\n@@ -936,1 +936,1 @@\n-    return;\n+        return;\n@@ -939,6 +939,7 @@\n-    for (j = i + 1; j < len; j++) {\n-        tst = xmlXPathCmpNodes(list->nodeTab[i], list->nodeTab[j]);\n-        if (tst == -1) {\n-        node = list->nodeTab[i];\n-        list->nodeTab[i] = list->nodeTab[j];\n-        list->nodeTab[j] = node;\n+        for (j = i + 1; j < len; j++) {\n+            tst = xmlXPathCmpNodes(list->nodeTab[i], list->nodeTab[j]);\n+            if (tst == -1) {\n+                node = list->nodeTab[i];\n+                list->nodeTab[i] = list->nodeTab[j];\n+                list->nodeTab[j] = node;\n+            }\n@@ -947,1 +948,0 @@\n-    }\n@@ -951,1 +951,1 @@\n- * xsltComputeSortResult:\n+ * xsltComputeSortResultiInternal:\n@@ -954,0 +954,1 @@\n+ * @xfrm:  Transform strings according to locale\n@@ -960,2 +961,3 @@\n-xmlXPathObjectPtr *\n-xsltComputeSortResult(xsltTransformContextPtr ctxt, xmlNodePtr sort) {\n+static xmlXPathObjectPtr *\n+xsltComputeSortResultInternal(xsltTransformContextPtr ctxt, xmlNodePtr sort,\n+                              int xfrm) {\n@@ -980,3 +982,3 @@\n-    xsltGenericError(xsltGenericErrorContext,\n-         \"xsl:sort : compilation failed\\n\");\n-    return(NULL);\n+        xsltGenericError(xsltGenericErrorContext,\n+             \"xsl:sort : compilation failed\\n\");\n+        return(NULL);\n@@ -986,1 +988,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -990,1 +992,1 @@\n-    return(NULL);\n+        return(NULL);\n@@ -1000,3 +1002,3 @@\n-    xsltGenericError(xsltGenericErrorContext,\n-         \"xsltComputeSortResult: memory allocation failure\\n\");\n-    return(NULL);\n+        xsltGenericError(xsltGenericErrorContext,\n+             \"xsltComputeSortResult: memory allocation failure\\n\");\n+        return(NULL);\n@@ -1012,5 +1014,5 @@\n-    ctxt->inst = sort;\n-    ctxt->xpathCtxt->contextSize = len;\n-    ctxt->xpathCtxt->proximityPosition = i + 1;\n-    ctxt->node = list->nodeTab[i];\n-    ctxt->xpathCtxt->node = ctxt->node;\n+        ctxt->inst = sort;\n+        ctxt->xpathCtxt->contextSize = len;\n+        ctxt->xpathCtxt->proximityPosition = i + 1;\n+        ctxt->node = list->nodeTab[i];\n+        ctxt->xpathCtxt->node = ctxt->node;\n@@ -1018,7 +1020,7 @@\n-    if (comp->inScopeNs != NULL) {\n-        ctxt->xpathCtxt->namespaces = comp->inScopeNs->list;\n-        ctxt->xpathCtxt->nsNr = comp->inScopeNs->xpathNumber;\n-    } else {\n-        ctxt->xpathCtxt->namespaces = NULL;\n-        ctxt->xpathCtxt->nsNr = 0;\n-    }\n+        if (comp->inScopeNs != NULL) {\n+            ctxt->xpathCtxt->namespaces = comp->inScopeNs->list;\n+            ctxt->xpathCtxt->nsNr = comp->inScopeNs->xpathNumber;\n+        } else {\n+            ctxt->xpathCtxt->namespaces = NULL;\n+            ctxt->xpathCtxt->nsNr = 0;\n+        }\n@@ -1026,2 +1028,2 @@\n-    ctxt->xpathCtxt->namespaces = comp->nsList;\n-    ctxt->xpathCtxt->nsNr = comp->nsNr;\n+        ctxt->xpathCtxt->namespaces = comp->nsList;\n+        ctxt->xpathCtxt->nsNr = comp->nsNr;\n@@ -1029,11 +1031,11 @@\n-    res = xmlXPathCompiledEval(comp->comp, ctxt->xpathCtxt);\n-    if (res != NULL) {\n-        if (res->type != XPATH_STRING)\n-        res = xmlXPathConvertString(res);\n-        if (comp->number)\n-        res = xmlXPathConvertNumber(res);\n-        res->index = i; \/* Save original pos for dupl resolv *\/\n-        if (comp->number) {\n-        if (res->type == XPATH_NUMBER) {\n-            results[i] = res;\n-        } else {\n+        res = xmlXPathCompiledEval(comp->comp, ctxt->xpathCtxt);\n+        if (res != NULL) {\n+            if (res->type != XPATH_STRING)\n+                res = xmlXPathConvertString(res);\n+            if (comp->number)\n+                res = xmlXPathConvertNumber(res);\n+            res->index = i;     \/* Save original pos for dupl resolv *\/\n+            if (comp->number) {\n+                if (res->type == XPATH_NUMBER) {\n+                    results[i] = res;\n+                } else {\n@@ -1041,2 +1043,2 @@\n-            xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltComputeSortResult: select didn't evaluate to a number\\n\");\n+                    xsltGenericDebug(xsltGenericDebugContext,\n+                        \"xsltComputeSortResult: select didn't evaluate to a number\\n\");\n@@ -1044,12 +1046,12 @@\n-            results[i] = NULL;\n-        }\n-        } else {\n-        if (res->type == XPATH_STRING) {\n-            if (comp->locale != (xsltLocale)0) {\n-            xmlChar *str = res->stringval;\n-            res->stringval = (xmlChar *) xsltStrxfrm(comp->locale, str);\n-            xmlFree(str);\n-            }\n-\n-            results[i] = res;\n-        } else {\n+                    results[i] = NULL;\n+                }\n+            } else {\n+                if (res->type == XPATH_STRING) {\n+                    if ((xfrm) && (comp->locale != (xsltLocale)0)) {\n+                        xmlChar *str = res->stringval;\n+                        res->stringval = (xmlChar *) xsltStrxfrm(comp->locale, str);\n+                        xmlFree(str);\n+                    }\n+\n+                    results[i] = res;\n+                } else {\n@@ -1057,2 +1059,2 @@\n-            xsltGenericDebug(xsltGenericDebugContext,\n-            \"xsltComputeSortResult: select didn't evaluate to a string\\n\");\n+                    xsltGenericDebug(xsltGenericDebugContext,\n+                        \"xsltComputeSortResult: select didn't evaluate to a string\\n\");\n@@ -1060,0 +1062,5 @@\n+                    results[i] = NULL;\n+                }\n+            }\n+        } else {\n+            ctxt->state = XSLT_STATE_STOPPED;\n@@ -1062,5 +1069,0 @@\n-        }\n-    } else {\n-        ctxt->state = XSLT_STATE_STOPPED;\n-        results[i] = NULL;\n-    }\n@@ -1078,0 +1080,15 @@\n+\/**\n+ * xsltComputeSortResult:\n+ * @ctxt:  a XSLT process context\n+ * @sort:  node list\n+ *\n+ * reorder the current node list accordingly to the set of sorting\n+ * requirement provided by the array of nodes.\n+ *\n+ * Returns a ordered XPath nodeset or NULL in case of error.\n+ *\/\n+xmlXPathObjectPtr *\n+xsltComputeSortResult(xsltTransformContextPtr ctxt, xmlNodePtr sort) {\n+    return xsltComputeSortResultInternal(ctxt, sort, \/* xfrm *\/ 0);\n+}\n+\n@@ -1089,1 +1106,1 @@\n-               int nbsorts) {\n+                   int nbsorts) {\n@@ -1105,1 +1122,2 @@\n-    int tempstype[XSLT_MAX_SORT], temporder[XSLT_MAX_SORT];\n+    int tempstype[XSLT_MAX_SORT], temporder[XSLT_MAX_SORT],\n+        templang[XSLT_MAX_SORT];\n@@ -1108,2 +1126,2 @@\n-    (nbsorts >= XSLT_MAX_SORT))\n-    return;\n+        (nbsorts >= XSLT_MAX_SORT))\n+        return;\n@@ -1111,1 +1129,1 @@\n-    return;\n+        return;\n@@ -1114,1 +1132,1 @@\n-    return;\n+        return;\n@@ -1118,1 +1136,1 @@\n-    return; \/* nothing to do *\/\n+        return; \/* nothing to do *\/\n@@ -1121,19 +1139,20 @@\n-    comp = sorts[j]->psvi;\n-    tempstype[j] = 0;\n-    if ((comp->stype == NULL) && (comp->has_stype != 0)) {\n-        comp->stype =\n-        xsltEvalAttrValueTemplate(ctxt, sorts[j],\n-                      (const xmlChar *) \"data-type\",\n-                      XSLT_NAMESPACE);\n-        if (comp->stype != NULL) {\n-        tempstype[j] = 1;\n-        if (xmlStrEqual(comp->stype, (const xmlChar *) \"text\"))\n-            comp->number = 0;\n-        else if (xmlStrEqual(comp->stype, (const xmlChar *) \"number\"))\n-            comp->number = 1;\n-        else {\n-            xsltTransformError(ctxt, NULL, sorts[j],\n-              \"xsltDoSortFunction: no support for data-type = %s\\n\",\n-                     comp->stype);\n-            comp->number = 0; \/* use default *\/\n-        }\n+        comp = sorts[j]->psvi;\n+        tempstype[j] = 0;\n+        if ((comp->stype == NULL) && (comp->has_stype != 0)) {\n+            comp->stype =\n+                xsltEvalAttrValueTemplate(ctxt, sorts[j],\n+                                          (const xmlChar *) \"data-type\",\n+                                          NULL);\n+            if (comp->stype != NULL) {\n+                tempstype[j] = 1;\n+                if (xmlStrEqual(comp->stype, (const xmlChar *) \"text\"))\n+                    comp->number = 0;\n+                else if (xmlStrEqual(comp->stype, (const xmlChar *) \"number\"))\n+                    comp->number = 1;\n+                else {\n+                    xsltTransformError(ctxt, NULL, sorts[j],\n+                          \"xsltDoSortFunction: no support for data-type = %s\\n\",\n+                                     comp->stype);\n+                    comp->number = 0; \/* use default *\/\n+                }\n+            }\n@@ -1141,18 +1160,19 @@\n-    }\n-    temporder[j] = 0;\n-    if ((comp->order == NULL) && (comp->has_order != 0)) {\n-        comp->order = xsltEvalAttrValueTemplate(ctxt, sorts[j],\n-                            (const xmlChar *) \"order\",\n-                            XSLT_NAMESPACE);\n-        if (comp->order != NULL) {\n-        temporder[j] = 1;\n-        if (xmlStrEqual(comp->order, (const xmlChar *) \"ascending\"))\n-            comp->descending = 0;\n-        else if (xmlStrEqual(comp->order,\n-                     (const xmlChar *) \"descending\"))\n-            comp->descending = 1;\n-        else {\n-            xsltTransformError(ctxt, NULL, sorts[j],\n-                 \"xsltDoSortFunction: invalid value %s for order\\n\",\n-                     comp->order);\n-            comp->descending = 0; \/* use default *\/\n+        temporder[j] = 0;\n+        if ((comp->order == NULL) && (comp->has_order != 0)) {\n+            comp->order = xsltEvalAttrValueTemplate(ctxt, sorts[j],\n+                                                    (const xmlChar *) \"order\",\n+                                                    NULL);\n+            if (comp->order != NULL) {\n+                temporder[j] = 1;\n+                if (xmlStrEqual(comp->order, (const xmlChar *) \"ascending\"))\n+                    comp->descending = 0;\n+                else if (xmlStrEqual(comp->order,\n+                                     (const xmlChar *) \"descending\"))\n+                    comp->descending = 1;\n+                else {\n+                    xsltTransformError(ctxt, NULL, sorts[j],\n+                             \"xsltDoSortFunction: invalid value %s for order\\n\",\n+                                     comp->order);\n+                    comp->descending = 0; \/* use default *\/\n+                }\n+            }\n@@ -1160,0 +1180,10 @@\n+        templang[j] = 0;\n+        if ((comp->lang == NULL) && (comp->has_lang != 0)) {\n+            xmlChar *lang = xsltEvalAttrValueTemplate(ctxt, sorts[j],\n+                                                      (xmlChar *) \"lang\",\n+                                                      NULL);\n+            if (lang != NULL) {\n+                templang[j] = 1;\n+                comp->locale = xsltNewLocale(lang);\n+                xmlFree(lang);\n+            }\n@@ -1162,1 +1192,0 @@\n-    }\n@@ -1166,1 +1195,2 @@\n-    resultsTab[0] = xsltComputeSortResult(ctxt, sorts[0]);\n+    resultsTab[0] = xsltComputeSortResultInternal(ctxt, sorts[0],\n+                                                  \/* xfrm *\/ 1);\n@@ -1168,1 +1198,1 @@\n-    resultsTab[i] = NULL;\n+        resultsTab[i] = NULL;\n@@ -1176,1 +1206,1 @@\n-    return;\n+        goto cleanup;\n@@ -1180,51 +1210,4 @@\n-    for (i = incr; i < len; i++) {\n-        j = i - incr;\n-        if (results[i] == NULL)\n-        continue;\n-\n-        while (j >= 0) {\n-        if (results[j] == NULL)\n-            tst = 1;\n-        else {\n-            if (number) {\n-            \/* We make NaN smaller than number in accordance\n-               with XSLT spec *\/\n-            if (xmlXPathIsNaN(results[j]->floatval)) {\n-                if (xmlXPathIsNaN(results[j + incr]->floatval))\n-                tst = 0;\n-                else\n-                tst = -1;\n-            } else if (xmlXPathIsNaN(results[j + incr]->floatval))\n-                tst = 1;\n-            else if (results[j]->floatval ==\n-                results[j + incr]->floatval)\n-                tst = 0;\n-            else if (results[j]->floatval >\n-                results[j + incr]->floatval)\n-                tst = 1;\n-            else tst = -1;\n-            } else if(comp->locale != (xsltLocale)0) {\n-            tst = xsltLocaleStrcmp(\n-                comp->locale,\n-                (xsltLocaleChar *) results[j]->stringval,\n-                (xsltLocaleChar *) results[j + incr]->stringval);\n-            } else {\n-            tst = xmlStrcmp(results[j]->stringval,\n-                     results[j + incr]->stringval);\n-            }\n-            if (descending)\n-            tst = -tst;\n-        }\n-        if (tst == 0) {\n-            \/*\n-             * Okay we need to use multi level sorts\n-             *\/\n-            depth = 1;\n-            while (depth < nbsorts) {\n-            if (sorts[depth] == NULL)\n-                break;\n-            comp = sorts[depth]->psvi;\n-            if (comp == NULL)\n-                break;\n-            desc = comp->descending;\n-            numb = comp->number;\n+        for (i = incr; i < len; i++) {\n+            j = i - incr;\n+            if (results[i] == NULL)\n+                continue;\n@@ -1232,33 +1215,2 @@\n-            \/*\n-             * Compute the result of the next level for the\n-             * full set, this might be optimized ... or not\n-             *\/\n-            if (resultsTab[depth] == NULL)\n-                resultsTab[depth] = xsltComputeSortResult(ctxt,\n-                                        sorts[depth]);\n-            res = resultsTab[depth];\n-            if (res == NULL)\n-                break;\n-            if (res[j] == NULL) {\n-                if (res[j+incr] != NULL)\n-                tst = 1;\n-            } else if (res[j+incr] == NULL) {\n-                tst = -1;\n-            } else {\n-                if (numb) {\n-                \/* We make NaN smaller than number in\n-                   accordance with XSLT spec *\/\n-                if (xmlXPathIsNaN(res[j]->floatval)) {\n-                    if (xmlXPathIsNaN(res[j +\n-                        incr]->floatval))\n-                    tst = 0;\n-                    else\n-                        tst = -1;\n-                } else if (xmlXPathIsNaN(res[j + incr]->\n-                        floatval))\n-                    tst = 1;\n-                else if (res[j]->floatval == res[j + incr]->\n-                        floatval)\n-                    tst = 0;\n-                else if (res[j]->floatval >\n-                    res[j + incr]->floatval)\n+            while (j >= 0) {\n+                if (results[j] == NULL)\n@@ -1266,9 +1218,29 @@\n-                else tst = -1;\n-                } else if(comp->locale != (xsltLocale)0) {\n-                tst = xsltLocaleStrcmp(\n-                    comp->locale,\n-                    (xsltLocaleChar *) res[j]->stringval,\n-                    (xsltLocaleChar *) res[j + incr]->stringval);\n-                } else {\n-                tst = xmlStrcmp(res[j]->stringval,\n-                         res[j + incr]->stringval);\n+                else {\n+                    if (number) {\n+                        \/* We make NaN smaller than number in accordance\n+                           with XSLT spec *\/\n+                        if (xmlXPathIsNaN(results[j]->floatval)) {\n+                            if (xmlXPathIsNaN(results[j + incr]->floatval))\n+                                tst = 0;\n+                            else\n+                                tst = -1;\n+                        } else if (xmlXPathIsNaN(results[j + incr]->floatval))\n+                            tst = 1;\n+                        else if (results[j]->floatval ==\n+                                results[j + incr]->floatval)\n+                            tst = 0;\n+                        else if (results[j]->floatval >\n+                                results[j + incr]->floatval)\n+                            tst = 1;\n+                        else tst = -1;\n+                    } else if(comp->locale != (xsltLocale)0) {\n+                        tst = xsltLocaleStrcmp(\n+                            comp->locale,\n+                            (xsltLocaleChar *) results[j]->stringval,\n+                            (xsltLocaleChar *) results[j + incr]->stringval);\n+                    } else {\n+                        tst = xmlStrcmp(results[j]->stringval,\n+                                     results[j + incr]->stringval);\n+                    }\n+                    if (descending)\n+                        tst = -tst;\n@@ -1276,34 +1248,98 @@\n-                if (desc)\n-                tst = -tst;\n-            }\n-\n-            \/*\n-             * if we still can't differenciate at this level\n-             * try one level deeper.\n-             *\/\n-            if (tst != 0)\n-                break;\n-            depth++;\n-            }\n-        }\n-        if (tst == 0) {\n-            tst = results[j]->index > results[j + incr]->index;\n-        }\n-        if (tst > 0) {\n-            tmp = results[j];\n-            results[j] = results[j + incr];\n-            results[j + incr] = tmp;\n-            node = list->nodeTab[j];\n-            list->nodeTab[j] = list->nodeTab[j + incr];\n-            list->nodeTab[j + incr] = node;\n-            depth = 1;\n-            while (depth < nbsorts) {\n-            if (sorts[depth] == NULL)\n-                break;\n-            if (resultsTab[depth] == NULL)\n-                break;\n-            res = resultsTab[depth];\n-            tmp = res[j];\n-            res[j] = res[j + incr];\n-            res[j + incr] = tmp;\n-            depth++;\n+                if (tst == 0) {\n+                    \/*\n+                     * Okay we need to use multi level sorts\n+                     *\/\n+                    depth = 1;\n+                    while (depth < nbsorts) {\n+                        if (sorts[depth] == NULL)\n+                            break;\n+                        comp = sorts[depth]->psvi;\n+                        if (comp == NULL)\n+                            break;\n+                        desc = comp->descending;\n+                        numb = comp->number;\n+\n+                        \/*\n+                         * Compute the result of the next level for the\n+                         * full set, this might be optimized ... or not\n+                         *\/\n+                        if (resultsTab[depth] == NULL)\n+                            resultsTab[depth] =\n+                                xsltComputeSortResultInternal(ctxt,\n+                                                              sorts[depth],\n+                                                              \/* xfrm *\/ 1);\n+                        res = resultsTab[depth];\n+                        if (res == NULL)\n+                            break;\n+                        if (res[j] == NULL) {\n+                            if (res[j+incr] != NULL)\n+                                tst = 1;\n+                        } else if (res[j+incr] == NULL) {\n+                            tst = -1;\n+                        } else {\n+                            if (numb) {\n+                                \/* We make NaN smaller than number in\n+                                   accordance with XSLT spec *\/\n+                                if (xmlXPathIsNaN(res[j]->floatval)) {\n+                                    if (xmlXPathIsNaN(res[j +\n+                                                incr]->floatval))\n+                                        tst = 0;\n+                                    else\n+                                        tst = -1;\n+                                } else if (xmlXPathIsNaN(res[j + incr]->\n+                                                floatval))\n+                                    tst = 1;\n+                                else if (res[j]->floatval == res[j + incr]->\n+                                                floatval)\n+                                    tst = 0;\n+                                else if (res[j]->floatval >\n+                                        res[j + incr]->floatval)\n+                                    tst = 1;\n+                                else tst = -1;\n+                            } else if(comp->locale != (xsltLocale)0) {\n+                                tst = xsltLocaleStrcmp(\n+                                    comp->locale,\n+                                    (xsltLocaleChar *) res[j]->stringval,\n+                                    (xsltLocaleChar *) res[j + incr]->stringval);\n+                            } else {\n+                                tst = xmlStrcmp(res[j]->stringval,\n+                                             res[j + incr]->stringval);\n+                            }\n+                            if (desc)\n+                                tst = -tst;\n+                        }\n+\n+                        \/*\n+                         * if we still can't differenciate at this level\n+                         * try one level deeper.\n+                         *\/\n+                        if (tst != 0)\n+                            break;\n+                        depth++;\n+                    }\n+                }\n+                if (tst == 0) {\n+                    tst = results[j]->index > results[j + incr]->index;\n+                }\n+                if (tst > 0) {\n+                    tmp = results[j];\n+                    results[j] = results[j + incr];\n+                    results[j + incr] = tmp;\n+                    node = list->nodeTab[j];\n+                    list->nodeTab[j] = list->nodeTab[j + incr];\n+                    list->nodeTab[j + incr] = node;\n+                    depth = 1;\n+                    while (depth < nbsorts) {\n+                        if (sorts[depth] == NULL)\n+                            break;\n+                        if (resultsTab[depth] == NULL)\n+                            break;\n+                        res = resultsTab[depth];\n+                        tmp = res[j];\n+                        res[j] = res[j + incr];\n+                        res[j + incr] = tmp;\n+                        depth++;\n+                    }\n+                    j -= incr;\n+                } else\n+                    break;\n@@ -1311,3 +1347,0 @@\n-            j -= incr;\n-        } else\n-            break;\n@@ -1316,1 +1349,0 @@\n-    }\n@@ -1318,0 +1350,1 @@\n+cleanup:\n@@ -1319,16 +1352,20 @@\n-    comp = sorts[j]->psvi;\n-    if (tempstype[j] == 1) {\n-        \/* The data-type needs to be recomputed each time *\/\n-        xmlFree((void *)(comp->stype));\n-        comp->stype = NULL;\n-    }\n-    if (temporder[j] == 1) {\n-        \/* The order needs to be recomputed each time *\/\n-        xmlFree((void *)(comp->order));\n-        comp->order = NULL;\n-    }\n-    if (resultsTab[j] != NULL) {\n-        for (i = 0;i < len;i++)\n-        xmlXPathFreeObject(resultsTab[j][i]);\n-        xmlFree(resultsTab[j]);\n-    }\n+        comp = sorts[j]->psvi;\n+        if (tempstype[j] == 1) {\n+            \/* The data-type needs to be recomputed each time *\/\n+            xmlFree((void *)(comp->stype));\n+            comp->stype = NULL;\n+        }\n+        if (temporder[j] == 1) {\n+            \/* The order needs to be recomputed each time *\/\n+            xmlFree((void *)(comp->order));\n+            comp->order = NULL;\n+        }\n+        if (templang[j] == 1) {\n+            xsltFreeLocale(comp->locale);\n+            comp->locale = (xsltLocale)0;\n+        }\n+        if (resultsTab[j] != NULL) {\n+            for (i = 0;i < len;i++)\n+                xmlXPathFreeObject(resultsTab[j][i]);\n+            xmlFree(resultsTab[j]);\n+        }\n@@ -1360,1 +1397,1 @@\n-    (ctxt->sortfunc)(ctxt, sorts, nbsorts);\n+        (ctxt->sortfunc)(ctxt, sorts, nbsorts);\n@@ -1375,1 +1412,1 @@\n-    xsltSortFunction = handler;\n+        xsltSortFunction = handler;\n@@ -1377,1 +1414,1 @@\n-    xsltSortFunction = xsltDefaultSortFunction;\n+        xsltSortFunction = xsltDefaultSortFunction;\n@@ -1396,3 +1433,3 @@\n- *                                  *\n- *              Parsing options             *\n- *                                  *\n+ *                                                                      *\n+ *                              Parsing options                         *\n+ *                                                                      *\n@@ -1430,3 +1467,3 @@\n- *                                  *\n- *              Output                  *\n- *                                  *\n+ *                                                                      *\n+ *                              Output                                  *\n+ *                                                                      *\n@@ -1448,1 +1485,1 @@\n-           xsltStylesheetPtr style) {\n+               xsltStylesheetPtr style) {\n@@ -1455,1 +1492,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1457,3 +1494,3 @@\n-    ((result->children->type == XML_DTD_NODE) &&\n-     (result->children->next == NULL)))\n-    return(0);\n+        ((result->children->type == XML_DTD_NODE) &&\n+         (result->children->next == NULL)))\n+        return(0);\n@@ -1462,2 +1499,2 @@\n-    ((style->method == NULL) ||\n-     (!xmlStrEqual(style->method, (const xmlChar *) \"xhtml\")))) {\n+        ((style->method == NULL) ||\n+         (!xmlStrEqual(style->method, (const xmlChar *) \"xhtml\")))) {\n@@ -1465,1 +1502,1 @@\n-        \"xsltSaveResultTo : unknown output method\\n\");\n+                \"xsltSaveResultTo : unknown output method\\n\");\n@@ -1476,1 +1513,1 @@\n-    method = (const xmlChar *) \"html\";\n+        method = (const xmlChar *) \"html\";\n@@ -1479,11 +1516,11 @@\n-    (xmlStrEqual(method, (const xmlChar *) \"html\"))) {\n-    if (encoding != NULL) {\n-        htmlSetMetaEncoding(result, (const xmlChar *) encoding);\n-    } else {\n-        htmlSetMetaEncoding(result, (const xmlChar *) \"UTF-8\");\n-    }\n-    if (indent == -1)\n-        indent = 1;\n-    htmlDocContentDumpFormatOutput(buf, result, (const char *) encoding,\n-                               indent);\n-    xmlOutputBufferFlush(buf);\n+        (xmlStrEqual(method, (const xmlChar *) \"html\"))) {\n+        if (encoding != NULL) {\n+            htmlSetMetaEncoding(result, (const xmlChar *) encoding);\n+        } else {\n+            htmlSetMetaEncoding(result, (const xmlChar *) \"UTF-8\");\n+        }\n+        if (indent == -1)\n+            indent = 1;\n+        htmlDocContentDumpFormatOutput(buf, result, (const char *) encoding,\n+                                       indent);\n+        xmlOutputBufferFlush(buf);\n@@ -1491,8 +1528,8 @@\n-    (xmlStrEqual(method, (const xmlChar *) \"xhtml\"))) {\n-    if (encoding != NULL) {\n-        htmlSetMetaEncoding(result, (const xmlChar *) encoding);\n-    } else {\n-        htmlSetMetaEncoding(result, (const xmlChar *) \"UTF-8\");\n-    }\n-    htmlDocContentDumpOutput(buf, result, (const char *) encoding);\n-    xmlOutputBufferFlush(buf);\n+        (xmlStrEqual(method, (const xmlChar *) \"xhtml\"))) {\n+        if (encoding != NULL) {\n+            htmlSetMetaEncoding(result, (const xmlChar *) encoding);\n+        } else {\n+            htmlSetMetaEncoding(result, (const xmlChar *) \"UTF-8\");\n+        }\n+        htmlDocContentDumpOutput(buf, result, (const char *) encoding);\n+        xmlOutputBufferFlush(buf);\n@@ -1500,2 +1537,2 @@\n-           (xmlStrEqual(method, (const xmlChar *) \"text\"))) {\n-    xmlNodePtr cur;\n+               (xmlStrEqual(method, (const xmlChar *) \"text\"))) {\n+        xmlNodePtr cur;\n@@ -1503,4 +1540,4 @@\n-    cur = result->children;\n-    while (cur != NULL) {\n-        if (cur->type == XML_TEXT_NODE)\n-        xmlOutputBufferWriteString(buf, (const char *) cur->content);\n+        cur = result->children;\n+        while (cur != NULL) {\n+            if (cur->type == XML_TEXT_NODE)\n+                xmlOutputBufferWriteString(buf, (const char *) cur->content);\n@@ -1508,15 +1545,15 @@\n-        \/*\n-         * Skip to next node\n-         *\/\n-        if (cur->children != NULL) {\n-        if ((cur->children->type != XML_ENTITY_DECL) &&\n-            (cur->children->type != XML_ENTITY_REF_NODE) &&\n-            (cur->children->type != XML_ENTITY_NODE)) {\n-            cur = cur->children;\n-            continue;\n-        }\n-        }\n-        if (cur->next != NULL) {\n-        cur = cur->next;\n-        continue;\n-        }\n+            \/*\n+             * Skip to next node\n+             *\/\n+            if (cur->children != NULL) {\n+                if ((cur->children->type != XML_ENTITY_DECL) &&\n+                    (cur->children->type != XML_ENTITY_REF_NODE) &&\n+                    (cur->children->type != XML_ENTITY_NODE)) {\n+                    cur = cur->children;\n+                    continue;\n+                }\n+            }\n+            if (cur->next != NULL) {\n+                cur = cur->next;\n+                continue;\n+            }\n@@ -1524,11 +1561,13 @@\n-        do {\n-        cur = cur->parent;\n-        if (cur == NULL)\n-            break;\n-        if (cur == (xmlNodePtr) style->doc) {\n-            cur = NULL;\n-            break;\n-        }\n-        if (cur->next != NULL) {\n-            cur = cur->next;\n-            break;\n+            do {\n+                cur = cur->parent;\n+                if (cur == NULL)\n+                    break;\n+                if (cur == (xmlNodePtr) style->doc) {\n+                    cur = NULL;\n+                    break;\n+                }\n+                if (cur->next != NULL) {\n+                    cur = cur->next;\n+                    break;\n+                }\n+            } while (cur != NULL);\n@@ -1536,3 +1575,1 @@\n-        } while (cur != NULL);\n-    }\n-    xmlOutputBufferFlush(buf);\n+        xmlOutputBufferFlush(buf);\n@@ -1540,37 +1577,39 @@\n-    int omitXmlDecl;\n-    int standalone;\n-\n-    XSLT_GET_IMPORT_INT(omitXmlDecl, style, omitXmlDeclaration);\n-    XSLT_GET_IMPORT_INT(standalone, style, standalone);\n-\n-    if (omitXmlDecl != 1) {\n-        xmlOutputBufferWriteString(buf, \"<?xml version=\");\n-        if (result->version != NULL) {\n-        xmlOutputBufferWriteString(buf, \"\\\"\");\n-        xmlOutputBufferWriteString(buf, (const char *)result->version);\n-        xmlOutputBufferWriteString(buf, \"\\\"\");\n-        } else\n-        xmlOutputBufferWriteString(buf, \"\\\"1.0\\\"\");\n-        if (encoding == NULL) {\n-        if (result->encoding != NULL)\n-            encoding = result->encoding;\n-        else if (result->charset != XML_CHAR_ENCODING_UTF8)\n-            encoding = (const xmlChar *)\n-                   xmlGetCharEncodingName((xmlCharEncoding)\n-                                          result->charset);\n-        }\n-        if (encoding != NULL) {\n-        xmlOutputBufferWriteString(buf, \" encoding=\");\n-        xmlOutputBufferWriteString(buf, \"\\\"\");\n-        xmlOutputBufferWriteString(buf, (const char *) encoding);\n-        xmlOutputBufferWriteString(buf, \"\\\"\");\n-        }\n-        switch (standalone) {\n-        case 0:\n-            xmlOutputBufferWriteString(buf, \" standalone=\\\"no\\\"\");\n-            break;\n-        case 1:\n-            xmlOutputBufferWriteString(buf, \" standalone=\\\"yes\\\"\");\n-            break;\n-        default:\n-            break;\n+        int omitXmlDecl;\n+        int standalone;\n+\n+        XSLT_GET_IMPORT_INT(omitXmlDecl, style, omitXmlDeclaration);\n+        XSLT_GET_IMPORT_INT(standalone, style, standalone);\n+\n+        if (omitXmlDecl != 1) {\n+            xmlOutputBufferWriteString(buf, \"<?xml version=\");\n+            if (result->version != NULL) {\n+                xmlOutputBufferWriteString(buf, \"\\\"\");\n+                xmlOutputBufferWriteString(buf, (const char *)result->version);\n+                xmlOutputBufferWriteString(buf, \"\\\"\");\n+            } else\n+                xmlOutputBufferWriteString(buf, \"\\\"1.0\\\"\");\n+            if (encoding == NULL) {\n+                if (result->encoding != NULL)\n+                    encoding = result->encoding;\n+                else if (result->charset != XML_CHAR_ENCODING_UTF8)\n+                    encoding = (const xmlChar *)\n+                               xmlGetCharEncodingName((xmlCharEncoding)\n+                                                      result->charset);\n+            }\n+            if (encoding != NULL) {\n+                xmlOutputBufferWriteString(buf, \" encoding=\");\n+                xmlOutputBufferWriteString(buf, \"\\\"\");\n+                xmlOutputBufferWriteString(buf, (const char *) encoding);\n+                xmlOutputBufferWriteString(buf, \"\\\"\");\n+            }\n+            switch (standalone) {\n+                case 0:\n+                    xmlOutputBufferWriteString(buf, \" standalone=\\\"no\\\"\");\n+                    break;\n+                case 1:\n+                    xmlOutputBufferWriteString(buf, \" standalone=\\\"yes\\\"\");\n+                    break;\n+                default:\n+                    break;\n+            }\n+            xmlOutputBufferWriteString(buf, \"?>\\n\");\n@@ -1578,3 +1617,1 @@\n-        xmlOutputBufferWriteString(buf, \"?>\\n\");\n-    }\n-    if (result->children != NULL) {\n+        if (result->children != NULL) {\n@@ -1582,1 +1619,1 @@\n-        xmlNodePtr child = children;\n+            xmlNodePtr child = children;\n@@ -1591,11 +1628,11 @@\n-        while (child != NULL) {\n-        xmlNodeDumpOutput(buf, result, child, 0, (indent == 1),\n-                      (const char *) encoding);\n-        if (indent && ((child->type == XML_DTD_NODE) ||\n-            ((child->type == XML_COMMENT_NODE) &&\n-             (child->next != NULL))))\n-            xmlOutputBufferWriteString(buf, \"\\n\");\n-        child = child->next;\n-        }\n-        if (indent)\n-            xmlOutputBufferWriteString(buf, \"\\n\");\n+            while (child != NULL) {\n+                xmlNodeDumpOutput(buf, result, child, 0, (indent == 1),\n+                                  (const char *) encoding);\n+                if (indent && ((child->type == XML_DTD_NODE) ||\n+                    ((child->type == XML_COMMENT_NODE) &&\n+                     (child->next != NULL))))\n+                    xmlOutputBufferWriteString(buf, \"\\n\");\n+                child = child->next;\n+            }\n+            if (indent)\n+                        xmlOutputBufferWriteString(buf, \"\\n\");\n@@ -1604,2 +1641,2 @@\n-    }\n-    xmlOutputBufferFlush(buf);\n+        }\n+        xmlOutputBufferFlush(buf);\n@@ -1624,1 +1661,1 @@\n-             xsltStylesheetPtr style, int compression) {\n+                         xsltStylesheetPtr style, int compression) {\n@@ -1630,1 +1667,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1632,1 +1669,1 @@\n-    return(0);\n+        return(0);\n@@ -1636,8 +1673,8 @@\n-    xmlCharEncodingHandlerPtr encoder;\n-\n-    encoder = xmlFindCharEncodingHandler((char *)encoding);\n-    if ((encoder != NULL) &&\n-        (xmlStrEqual((const xmlChar *)encoder->name,\n-             (const xmlChar *) \"UTF-8\")))\n-        encoder = NULL;\n-    buf = xmlOutputBufferCreateFilename(URL, encoder, compression);\n+        xmlCharEncodingHandlerPtr encoder;\n+\n+        encoder = xmlFindCharEncodingHandler((char *)encoding);\n+        if ((encoder != NULL) &&\n+            (xmlStrEqual((const xmlChar *)encoder->name,\n+                         (const xmlChar *) \"UTF-8\")))\n+            encoder = NULL;\n+        buf = xmlOutputBufferCreateFilename(URL, encoder, compression);\n@@ -1645,1 +1682,1 @@\n-    buf = xmlOutputBufferCreateFilename(URL, NULL, compression);\n+        buf = xmlOutputBufferCreateFilename(URL, NULL, compression);\n@@ -1648,1 +1685,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1673,1 +1710,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1675,1 +1712,1 @@\n-    return(0);\n+        return(0);\n@@ -1679,8 +1716,8 @@\n-    xmlCharEncodingHandlerPtr encoder;\n-\n-    encoder = xmlFindCharEncodingHandler((char *)encoding);\n-    if ((encoder != NULL) &&\n-        (xmlStrEqual((const xmlChar *)encoder->name,\n-             (const xmlChar *) \"UTF-8\")))\n-        encoder = NULL;\n-    buf = xmlOutputBufferCreateFile(file, encoder);\n+        xmlCharEncodingHandlerPtr encoder;\n+\n+        encoder = xmlFindCharEncodingHandler((char *)encoding);\n+        if ((encoder != NULL) &&\n+            (xmlStrEqual((const xmlChar *)encoder->name,\n+                         (const xmlChar *) \"UTF-8\")))\n+            encoder = NULL;\n+        buf = xmlOutputBufferCreateFile(file, encoder);\n@@ -1688,1 +1725,1 @@\n-    buf = xmlOutputBufferCreateFile(file, NULL);\n+        buf = xmlOutputBufferCreateFile(file, NULL);\n@@ -1692,1 +1729,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1717,1 +1754,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1719,1 +1756,1 @@\n-    return(0);\n+        return(0);\n@@ -1723,8 +1760,8 @@\n-    xmlCharEncodingHandlerPtr encoder;\n-\n-    encoder = xmlFindCharEncodingHandler((char *)encoding);\n-    if ((encoder != NULL) &&\n-        (xmlStrEqual((const xmlChar *)encoder->name,\n-             (const xmlChar *) \"UTF-8\")))\n-        encoder = NULL;\n-    buf = xmlOutputBufferCreateFd(fd, encoder);\n+        xmlCharEncodingHandlerPtr encoder;\n+\n+        encoder = xmlFindCharEncodingHandler((char *)encoding);\n+        if ((encoder != NULL) &&\n+            (xmlStrEqual((const xmlChar *)encoder->name,\n+                         (const xmlChar *) \"UTF-8\")))\n+            encoder = NULL;\n+        buf = xmlOutputBufferCreateFd(fd, encoder);\n@@ -1732,1 +1769,1 @@\n-    buf = xmlOutputBufferCreateFd(fd, NULL);\n+        buf = xmlOutputBufferCreateFd(fd, NULL);\n@@ -1735,1 +1772,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1755,1 +1792,1 @@\n-               xmlDocPtr result, xsltStylesheetPtr style) {\n+                       xmlDocPtr result, xsltStylesheetPtr style) {\n@@ -1762,1 +1799,1 @@\n-    return(0);\n+        return(0);\n@@ -1766,8 +1803,8 @@\n-    xmlCharEncodingHandlerPtr encoder;\n-\n-    encoder = xmlFindCharEncodingHandler((char *)encoding);\n-    if ((encoder != NULL) &&\n-        (xmlStrEqual((const xmlChar *)encoder->name,\n-             (const xmlChar *) \"UTF-8\")))\n-        encoder = NULL;\n-    buf = xmlAllocOutputBuffer(encoder);\n+        xmlCharEncodingHandlerPtr encoder;\n+\n+        encoder = xmlFindCharEncodingHandler((char *)encoding);\n+        if ((encoder != NULL) &&\n+            (xmlStrEqual((const xmlChar *)encoder->name,\n+                         (const xmlChar *) \"UTF-8\")))\n+            encoder = NULL;\n+        buf = xmlAllocOutputBuffer(encoder);\n@@ -1775,1 +1812,1 @@\n-    buf = xmlAllocOutputBuffer(NULL);\n+        buf = xmlAllocOutputBuffer(NULL);\n@@ -1778,1 +1815,1 @@\n-    return(-1);\n+        return(-1);\n@@ -1782,2 +1819,2 @@\n-    *doc_txt_len = xmlBufUse(buf->conv);\n-    *doc_txt_ptr = xmlStrndup(xmlBufContent(buf->conv), *doc_txt_len);\n+        *doc_txt_len = xmlBufUse(buf->conv);\n+        *doc_txt_ptr = xmlStrndup(xmlBufContent(buf->conv), *doc_txt_len);\n@@ -1785,2 +1822,2 @@\n-    *doc_txt_len = xmlBufUse(buf->buffer);\n-    *doc_txt_ptr = xmlStrndup(xmlBufContent(buf->buffer), *doc_txt_len);\n+        *doc_txt_len = xmlBufUse(buf->buffer);\n+        *doc_txt_ptr = xmlStrndup(xmlBufContent(buf->buffer), *doc_txt_len);\n@@ -1790,2 +1827,2 @@\n-    *doc_txt_len = buf->conv->use;\n-    *doc_txt_ptr = xmlStrndup(buf->conv->content, *doc_txt_len);\n+        *doc_txt_len = buf->conv->use;\n+        *doc_txt_ptr = xmlStrndup(buf->conv->content, *doc_txt_len);\n@@ -1793,2 +1830,2 @@\n-    *doc_txt_len = buf->buffer->use;\n-    *doc_txt_ptr = xmlStrndup(buf->buffer->content, *doc_txt_len);\n+        *doc_txt_len = buf->buffer->use;\n+        *doc_txt_ptr = xmlStrndup(buf->buffer->content, *doc_txt_len);\n@@ -1804,3 +1841,3 @@\n- *                                  *\n- *      Generating profiling information            *\n- *                                  *\n+ *                                                                      *\n+ *              Generating profiling information                        *\n+ *                                                                      *\n@@ -1826,1 +1863,1 @@\n-    xsltTimestamp();\n+        xsltTimestamp();\n@@ -1984,1 +2021,1 @@\n-    return;\n+        return;\n@@ -1986,1 +2023,1 @@\n-    return;\n+        return;\n@@ -1992,1 +2029,1 @@\n-    return;\n+        return;\n@@ -1996,9 +2033,9 @@\n-    templ1 = style->templates;\n-    while (templ1 != NULL) {\n-        if (nb >= max)\n-        break;\n-\n-        if (templ1->nbCalls > 0)\n-        templates[nb++] = templ1;\n-        templ1 = templ1->next;\n-    }\n+        templ1 = style->templates;\n+        while (templ1 != NULL) {\n+            if (nb >= max)\n+                break;\n+\n+            if (templ1->nbCalls > 0)\n+                templates[nb++] = templ1;\n+            templ1 = templ1->next;\n+        }\n@@ -2006,1 +2043,1 @@\n-    style = xsltNextImport(style);\n+        style = xsltNextImport(style);\n@@ -2010,7 +2047,8 @@\n-    for (j = i + 1; j < nb; j++) {\n-        if ((templates[i]->time <= templates[j]->time) ||\n-        ((templates[i]->time == templates[j]->time) &&\n-             (templates[i]->nbCalls <= templates[j]->nbCalls))) {\n-        templ1 = templates[j];\n-        templates[j] = templates[i];\n-        templates[i] = templ1;\n+        for (j = i + 1; j < nb; j++) {\n+            if ((templates[i]->time <= templates[j]->time) ||\n+                ((templates[i]->time == templates[j]->time) &&\n+                 (templates[i]->nbCalls <= templates[j]->nbCalls))) {\n+                templ1 = templates[j];\n+                templates[j] = templates[i];\n+                templates[i] = templ1;\n+            }\n@@ -2019,1 +2057,0 @@\n-    }\n@@ -2025,1 +2062,1 @@\n-        \"number\", \"match\", \"name\", \"mode\");\n+            \"number\", \"match\", \"name\", \"mode\");\n@@ -2030,30 +2067,30 @@\n-    fprintf(output, \"%5d \", i);\n-    if (templ1->match != NULL) {\n-        if (xmlStrlen(templ1->match) > 20)\n-        fprintf(output, \"%s\\n%26s\", templ1->match, \"\");\n-        else\n-        fprintf(output, \"%20s\", templ1->match);\n-    } else {\n-        fprintf(output, \"%20s\", \"\");\n-    }\n-    if (templ1->name != NULL) {\n-        if (xmlStrlen(templ1->name) > 20)\n-        fprintf(output, \"%s\\n%46s\", templ1->name, \"\");\n-        else\n-        fprintf(output, \"%20s\", templ1->name);\n-    } else {\n-        fprintf(output, \"%20s\", \"\");\n-    }\n-    if (templ1->mode != NULL) {\n-        if (xmlStrlen(templ1->mode) > 10)\n-        fprintf(output, \"%s\\n%56s\", templ1->mode, \"\");\n-        else\n-        fprintf(output, \"%10s\", templ1->mode);\n-    } else {\n-        fprintf(output, \"%10s\", \"\");\n-    }\n-    fprintf(output, \" %6d\", templ1->nbCalls);\n-    fprintf(output, \" %6ld %6ld\\n\", templ1->time,\n-        templ1->time \/ templ1->nbCalls);\n-    total += templ1->nbCalls;\n-    totalt += templ1->time;\n+        fprintf(output, \"%5d \", i);\n+        if (templ1->match != NULL) {\n+            if (xmlStrlen(templ1->match) > 20)\n+                fprintf(output, \"%s\\n%26s\", templ1->match, \"\");\n+            else\n+                fprintf(output, \"%20s\", templ1->match);\n+        } else {\n+            fprintf(output, \"%20s\", \"\");\n+        }\n+        if (templ1->name != NULL) {\n+            if (xmlStrlen(templ1->name) > 20)\n+                fprintf(output, \"%s\\n%46s\", templ1->name, \"\");\n+            else\n+                fprintf(output, \"%20s\", templ1->name);\n+        } else {\n+            fprintf(output, \"%20s\", \"\");\n+        }\n+        if (templ1->mode != NULL) {\n+            if (xmlStrlen(templ1->mode) > 10)\n+                fprintf(output, \"%s\\n%56s\", templ1->mode, \"\");\n+            else\n+                fprintf(output, \"%10s\", templ1->mode);\n+        } else {\n+            fprintf(output, \"%10s\", \"\");\n+        }\n+        fprintf(output, \" %6d\", templ1->nbCalls);\n+        fprintf(output, \" %6ld %6ld\\n\", templ1->time,\n+                templ1->time \/ templ1->nbCalls);\n+        total += templ1->nbCalls;\n+        totalt += templ1->time;\n@@ -2068,1 +2105,1 @@\n-    return;\n+        return;\n@@ -2166,3 +2203,3 @@\n- *                                  *\n- *      Fetching profiling information              *\n- *                                  *\n+ *                                                                      *\n+ *              Fetching profiling information                          *\n+ *                                                                      *\n@@ -2283,3 +2320,3 @@\n- *                                  *\n- *      Hooks for libxml2 XPath                 *\n- *                                  *\n+ *                                                                      *\n+ *              Hooks for libxml2 XPath                                 *\n+ *                                                                      *\n@@ -2306,3 +2343,3 @@\n-    if (xpathCtxt == NULL)\n-        return NULL;\n-    xpathCtxt->dict = style->dict;\n+        if (xpathCtxt == NULL)\n+            return NULL;\n+        xpathCtxt->dict = style->dict;\n@@ -2310,3 +2347,3 @@\n-    xpathCtxt = xmlXPathNewContext(NULL);\n-    if (xpathCtxt == NULL)\n-        return NULL;\n+        xpathCtxt = xmlXPathNewContext(NULL);\n+        if (xpathCtxt == NULL)\n+            return NULL;\n@@ -2322,1 +2359,1 @@\n-    xmlXPathFreeContext(xpathCtxt);\n+        xmlXPathFreeContext(xpathCtxt);\n@@ -2348,3 +2385,3 @@\n- *                                  *\n- *      Hooks for the debugger                  *\n- *                                  *\n+ *                                                                      *\n+ *              Hooks for the debugger                                  *\n+ *                                                                      *\n@@ -2419,1 +2456,1 @@\n-    return(-1);\n+        return(-1);\n@@ -2441,1 +2478,1 @@\n-              xsltTransformContextPtr ctxt)\n+                  xsltTransformContextPtr ctxt)\n@@ -2444,1 +2481,1 @@\n-    xsltDebuggerCurrentCallbacks.handler(cur, node, templ, ctxt);\n+        xsltDebuggerCurrentCallbacks.handler(cur, node, templ, ctxt);\n@@ -2460,1 +2497,1 @@\n-    return(xsltDebuggerCurrentCallbacks.add(templ, source));\n+        return(xsltDebuggerCurrentCallbacks.add(templ, source));\n@@ -2473,1 +2510,1 @@\n-    xsltDebuggerCurrentCallbacks.drop();\n+        xsltDebuggerCurrentCallbacks.drop();\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/xsltutils.c","additions":835,"deletions":798,"binary":false,"changes":1633,"status":"modified"},{"patch":"@@ -34,3 +34,3 @@\n-#define XSLT_TODO                           \\\n-    xsltGenericError(xsltGenericErrorContext,               \\\n-        \"Unimplemented block at %s:%d\\n\",               \\\n+#define XSLT_TODO                                                       \\\n+    xsltGenericError(xsltGenericErrorContext,                           \\\n+            \"Unimplemented block at %s:%d\\n\",                           \\\n@@ -44,3 +44,3 @@\n-#define XSLT_STRANGE                            \\\n-    xsltGenericError(xsltGenericErrorContext,               \\\n-        \"Internal error at %s:%d\\n\",                \\\n+#define XSLT_STRANGE                                                    \\\n+    xsltGenericError(xsltGenericErrorContext,                           \\\n+            \"Internal error at %s:%d\\n\",                                \\\n@@ -54,1 +54,1 @@\n-#define IS_XSLT_ELEM(n)                         \\\n+#define IS_XSLT_ELEM(n)                                                 \\\n@@ -63,1 +63,1 @@\n-#define IS_XSLT_NAME(n, val)                        \\\n+#define IS_XSLT_NAME(n, val)                                            \\\n@@ -71,9 +71,9 @@\n-#define IS_XSLT_REAL_NODE(n)                        \\\n-    (((n) != NULL) &&                           \\\n-     (((n)->type == XML_ELEMENT_NODE) ||                \\\n-      ((n)->type == XML_TEXT_NODE) ||                   \\\n-      ((n)->type == XML_CDATA_SECTION_NODE) ||              \\\n-      ((n)->type == XML_ATTRIBUTE_NODE) ||              \\\n-      ((n)->type == XML_DOCUMENT_NODE) ||               \\\n-      ((n)->type == XML_HTML_DOCUMENT_NODE) ||              \\\n-      ((n)->type == XML_COMMENT_NODE) ||                \\\n+#define IS_XSLT_REAL_NODE(n)                                            \\\n+    (((n) != NULL) &&                                                   \\\n+     (((n)->type == XML_ELEMENT_NODE) ||                                \\\n+      ((n)->type == XML_TEXT_NODE) ||                                   \\\n+      ((n)->type == XML_CDATA_SECTION_NODE) ||                          \\\n+      ((n)->type == XML_ATTRIBUTE_NODE) ||                              \\\n+      ((n)->type == XML_DOCUMENT_NODE) ||                               \\\n+      ((n)->type == XML_HTML_DOCUMENT_NODE) ||                          \\\n+      ((n)->type == XML_COMMENT_NODE) ||                                \\\n@@ -86,3 +86,3 @@\n-        xsltGetNsProp   (xmlNodePtr node,\n-                 const xmlChar *name,\n-                 const xmlChar *nameSpace);\n+                xsltGetNsProp   (xmlNodePtr node,\n+                                 const xmlChar *name,\n+                                 const xmlChar *nameSpace);\n@@ -90,4 +90,4 @@\n-        xsltGetCNsProp  (xsltStylesheetPtr style,\n-                 xmlNodePtr node,\n-                 const xmlChar *name,\n-                 const xmlChar *nameSpace);\n+                xsltGetCNsProp  (xsltStylesheetPtr style,\n+                                 xmlNodePtr node,\n+                                 const xmlChar *name,\n+                                 const xmlChar *nameSpace);\n@@ -95,2 +95,2 @@\n-        xsltGetUTF8Char (const unsigned char *utf,\n-                 int *len);\n+                xsltGetUTF8Char (const unsigned char *utf,\n+                                 int *len);\n@@ -102,19 +102,19 @@\n-    XSLT_TRACE_ALL =        -1,\n-    XSLT_TRACE_NONE =       0,\n-    XSLT_TRACE_COPY_TEXT =      1<<0,\n-    XSLT_TRACE_PROCESS_NODE =   1<<1,\n-    XSLT_TRACE_APPLY_TEMPLATE = 1<<2,\n-    XSLT_TRACE_COPY =       1<<3,\n-    XSLT_TRACE_COMMENT =        1<<4,\n-    XSLT_TRACE_PI =         1<<5,\n-    XSLT_TRACE_COPY_OF =        1<<6,\n-    XSLT_TRACE_VALUE_OF =       1<<7,\n-    XSLT_TRACE_CALL_TEMPLATE =  1<<8,\n-    XSLT_TRACE_APPLY_TEMPLATES =    1<<9,\n-    XSLT_TRACE_CHOOSE =     1<<10,\n-    XSLT_TRACE_IF =         1<<11,\n-    XSLT_TRACE_FOR_EACH =       1<<12,\n-    XSLT_TRACE_STRIP_SPACES =   1<<13,\n-    XSLT_TRACE_TEMPLATES =      1<<14,\n-    XSLT_TRACE_KEYS =       1<<15,\n-    XSLT_TRACE_VARIABLES =      1<<16\n+        XSLT_TRACE_ALL =                -1,\n+        XSLT_TRACE_NONE =               0,\n+        XSLT_TRACE_COPY_TEXT =          1<<0,\n+        XSLT_TRACE_PROCESS_NODE =       1<<1,\n+        XSLT_TRACE_APPLY_TEMPLATE =     1<<2,\n+        XSLT_TRACE_COPY =               1<<3,\n+        XSLT_TRACE_COMMENT =            1<<4,\n+        XSLT_TRACE_PI =                 1<<5,\n+        XSLT_TRACE_COPY_OF =            1<<6,\n+        XSLT_TRACE_VALUE_OF =           1<<7,\n+        XSLT_TRACE_CALL_TEMPLATE =      1<<8,\n+        XSLT_TRACE_APPLY_TEMPLATES =    1<<9,\n+        XSLT_TRACE_CHOOSE =             1<<10,\n+        XSLT_TRACE_IF =                 1<<11,\n+        XSLT_TRACE_FOR_EACH =           1<<12,\n+        XSLT_TRACE_STRIP_SPACES =       1<<13,\n+        XSLT_TRACE_TEMPLATES =          1<<14,\n+        XSLT_TRACE_KEYS =               1<<15,\n+        XSLT_TRACE_VARIABLES =          1<<16\n@@ -128,3 +128,3 @@\n-#define XSLT_TRACE(ctxt,code,call)  \\\n-    if (ctxt->traceCode && (*(ctxt->traceCode) & code)) \\\n-        call\n+#define XSLT_TRACE(ctxt,code,call)      \\\n+        if (ctxt->traceCode && (*(ctxt->traceCode) & code)) \\\n+            call\n@@ -133,1 +133,1 @@\n-        xsltDebugSetDefaultTrace(xsltDebugTraceCodes val);\n+                xsltDebugSetDefaultTrace(xsltDebugTraceCodes val);\n@@ -135,1 +135,1 @@\n-        xsltDebugGetDefaultTrace(void);\n+                xsltDebugGetDefaultTrace(void);\n@@ -146,3 +146,3 @@\n-        xsltPrintErrorContext       (xsltTransformContextPtr ctxt,\n-                                             xsltStylesheetPtr style,\n-                         xmlNodePtr node);\n+                xsltPrintErrorContext           (xsltTransformContextPtr ctxt,\n+                                                 xsltStylesheetPtr style,\n+                                                 xmlNodePtr node);\n@@ -150,3 +150,3 @@\n-        xsltMessage         (xsltTransformContextPtr ctxt,\n-                         xmlNodePtr node,\n-                         xmlNodePtr inst);\n+                xsltMessage                     (xsltTransformContextPtr ctxt,\n+                                                 xmlNodePtr node,\n+                                                 xmlNodePtr inst);\n@@ -154,2 +154,2 @@\n-        xsltSetGenericErrorFunc     (void *ctx,\n-                         xmlGenericErrorFunc handler);\n+                xsltSetGenericErrorFunc         (void *ctx,\n+                                                 xmlGenericErrorFunc handler);\n@@ -157,2 +157,2 @@\n-        xsltSetGenericDebugFunc     (void *ctx,\n-                         xmlGenericErrorFunc handler);\n+                xsltSetGenericDebugFunc         (void *ctx,\n+                                                 xmlGenericErrorFunc handler);\n@@ -160,3 +160,3 @@\n-        xsltSetTransformErrorFunc   (xsltTransformContextPtr ctxt,\n-                         void *ctx,\n-                         xmlGenericErrorFunc handler);\n+                xsltSetTransformErrorFunc       (xsltTransformContextPtr ctxt,\n+                                                 void *ctx,\n+                                                 xmlGenericErrorFunc handler);\n@@ -164,5 +164,5 @@\n-        xsltTransformError      (xsltTransformContextPtr ctxt,\n-                         xsltStylesheetPtr style,\n-                         xmlNodePtr node,\n-                         const char *msg,\n-                         ...) LIBXSLT_ATTR_FORMAT(4,5);\n+                xsltTransformError              (xsltTransformContextPtr ctxt,\n+                                                 xsltStylesheetPtr style,\n+                                                 xmlNodePtr node,\n+                                                 const char *msg,\n+                                                 ...) LIBXSLT_ATTR_FORMAT(4,5);\n@@ -171,2 +171,2 @@\n-        xsltSetCtxtParseOptions     (xsltTransformContextPtr ctxt,\n-                         int options);\n+                xsltSetCtxtParseOptions         (xsltTransformContextPtr ctxt,\n+                                                 int options);\n@@ -178,1 +178,1 @@\n-        xsltDocumentSortFunction    (xmlNodeSetPtr list);\n+                xsltDocumentSortFunction        (xmlNodeSetPtr list);\n@@ -180,1 +180,1 @@\n-        xsltSetSortFunc         (xsltSortFunc handler);\n+                xsltSetSortFunc                 (xsltSortFunc handler);\n@@ -182,2 +182,2 @@\n-        xsltSetCtxtSortFunc     (xsltTransformContextPtr ctxt,\n-                         xsltSortFunc handler);\n+                xsltSetCtxtSortFunc             (xsltTransformContextPtr ctxt,\n+                                                 xsltSortFunc handler);\n@@ -185,3 +185,3 @@\n-        xsltDefaultSortFunction     (xsltTransformContextPtr ctxt,\n-                         xmlNodePtr *sorts,\n-                         int nbsorts);\n+                xsltDefaultSortFunction         (xsltTransformContextPtr ctxt,\n+                                                 xmlNodePtr *sorts,\n+                                                 int nbsorts);\n@@ -189,3 +189,3 @@\n-        xsltDoSortFunction      (xsltTransformContextPtr ctxt,\n-                         xmlNodePtr * sorts,\n-                         int nbsorts);\n+                xsltDoSortFunction              (xsltTransformContextPtr ctxt,\n+                                                 xmlNodePtr * sorts,\n+                                                 int nbsorts);\n@@ -193,2 +193,2 @@\n-        xsltComputeSortResult       (xsltTransformContextPtr ctxt,\n-                         xmlNodePtr sort);\n+                xsltComputeSortResult           (xsltTransformContextPtr ctxt,\n+                                                 xmlNodePtr sort);\n@@ -201,3 +201,3 @@\n-        xsltSplitQName          (xmlDictPtr dict,\n-                         const xmlChar *name,\n-                         const xmlChar **prefix);\n+                xsltSplitQName                  (xmlDictPtr dict,\n+                                                 const xmlChar *name,\n+                                                 const xmlChar **prefix);\n@@ -205,2 +205,2 @@\n-        xsltGetQNameURI         (xmlNodePtr node,\n-                         xmlChar **name);\n+                xsltGetQNameURI                 (xmlNodePtr node,\n+                                                 xmlChar **name);\n@@ -209,3 +209,3 @@\n-        xsltGetQNameURI2        (xsltStylesheetPtr style,\n-                         xmlNodePtr node,\n-                         const xmlChar **name);\n+                xsltGetQNameURI2                (xsltStylesheetPtr style,\n+                                                 xmlNodePtr node,\n+                                                 const xmlChar **name);\n@@ -217,3 +217,3 @@\n-        xsltSaveResultTo        (xmlOutputBufferPtr buf,\n-                         xmlDocPtr result,\n-                         xsltStylesheetPtr style);\n+                xsltSaveResultTo                (xmlOutputBufferPtr buf,\n+                                                 xmlDocPtr result,\n+                                                 xsltStylesheetPtr style);\n@@ -221,4 +221,4 @@\n-        xsltSaveResultToFilename    (const char *URI,\n-                         xmlDocPtr result,\n-                         xsltStylesheetPtr style,\n-                         int compression);\n+                xsltSaveResultToFilename        (const char *URI,\n+                                                 xmlDocPtr result,\n+                                                 xsltStylesheetPtr style,\n+                                                 int compression);\n@@ -226,3 +226,3 @@\n-        xsltSaveResultToFile        (FILE *file,\n-                         xmlDocPtr result,\n-                         xsltStylesheetPtr style);\n+                xsltSaveResultToFile            (FILE *file,\n+                                                 xmlDocPtr result,\n+                                                 xsltStylesheetPtr style);\n@@ -230,3 +230,3 @@\n-        xsltSaveResultToFd      (int fd,\n-                         xmlDocPtr result,\n-                         xsltStylesheetPtr style);\n+                xsltSaveResultToFd              (int fd,\n+                                                 xmlDocPtr result,\n+                                                 xsltStylesheetPtr style);\n@@ -234,1 +234,1 @@\n-        xsltSaveResultToString          (xmlChar **doc_txt_ptr,\n+                xsltSaveResultToString          (xmlChar **doc_txt_ptr,\n@@ -243,2 +243,2 @@\n-        xsltXPathCompile        (xsltStylesheetPtr style,\n-                         const xmlChar *str);\n+                xsltXPathCompile                (xsltStylesheetPtr style,\n+                                                 const xmlChar *str);\n@@ -246,3 +246,3 @@\n-        xsltXPathCompileFlags       (xsltStylesheetPtr style,\n-                         const xmlChar *str,\n-                         int flags);\n+                xsltXPathCompileFlags           (xsltStylesheetPtr style,\n+                                                 const xmlChar *str,\n+                                                 int flags);\n@@ -254,2 +254,2 @@\n-        xsltSaveProfiling       (xsltTransformContextPtr ctxt,\n-                         FILE *output);\n+                xsltSaveProfiling               (xsltTransformContextPtr ctxt,\n+                                                 FILE *output);\n@@ -257,1 +257,1 @@\n-        xsltGetProfileInformation   (xsltTransformContextPtr ctxt);\n+                xsltGetProfileInformation       (xsltTransformContextPtr ctxt);\n@@ -260,1 +260,1 @@\n-        xsltTimestamp           (void);\n+                xsltTimestamp                   (void);\n@@ -262,1 +262,1 @@\n-        xsltCalibrateAdjust     (long delta);\n+                xsltCalibrateAdjust             (long delta);\n@@ -291,1 +291,1 @@\n-            xsltTemplatePtr templ, xsltTransformContextPtr ctxt);\n+                        xsltTemplatePtr templ, xsltTransformContextPtr ctxt);\n@@ -296,1 +296,1 @@\n-        xsltSetDebuggerStatus       (int value);\n+                xsltSetDebuggerStatus           (int value);\n@@ -298,1 +298,1 @@\n-        xsltGetDebuggerStatus       (void);\n+                xsltGetDebuggerStatus           (void);\n@@ -300,1 +300,1 @@\n-        xsltSetDebuggerCallbacks    (int no, void *block);\n+                xsltSetDebuggerCallbacks        (int no, void *block);\n@@ -302,2 +302,2 @@\n-        xslAddCall          (xsltTemplatePtr templ,\n-                         xmlNodePtr source);\n+                xslAddCall                      (xsltTemplatePtr templ,\n+                                                 xmlNodePtr source);\n@@ -305,1 +305,1 @@\n-        xslDropCall         (void);\n+                xslDropCall                     (void);\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/libxslt\/xsltutils.h","additions":121,"deletions":121,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -76,0 +76,5 @@\n+# append CFLAGS etc. passed on command line\n+CPPFLAGS = $(CPPFLAGS) $(EXTRA_CPPFLAGS)\n+CFLAGS = $(CFLAGS) $(EXTRA_CFLAGS)\n+LDFLAGS = $(LDFLAGS) $(EXTRA_LDFLAGS)\n+\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/win32\/Makefile.msvc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+var withProfiler = true;\n@@ -109,0 +110,1 @@\n+\ttxt += \"  profiler:   Enable Profiler support (\" + (withProfiler? \"yes\" : \"no\") + \")\\n\";\n@@ -137,1 +139,1 @@\n-\tvar fso, cf, vf, ln, s;\n+\tvar fso, cf, vf, ln, s, m;\n@@ -146,2 +148,2 @@\n-\t\t\t\tiDot = s.indexOf(\".\");\n-\t\t\t\tiSlash = s.indexOf(\"\/\", iDot);\n+\t\t\t\tvar iDot = s.indexOf(\".\");\n+\t\t\t\tvar iSlash = s.indexOf(\"\/\", iDot);\n@@ -177,1 +179,1 @@\n-\t\t\tverMajorExslt = s.substring(s.indexOf(\"=\") + 1, s.length)\n+\t\t\tverMajorExslt = s.substring(s.indexOf(\"=\") + 1, s.length);\n@@ -180,1 +182,1 @@\n-\t\t\tverMinorExslt = s.substring(s.indexOf(\"=\") + 1, s.length)\n+\t\t\tverMinorExslt = s.substring(s.indexOf(\"=\") + 1, s.length);\n@@ -183,1 +185,1 @@\n-\t\t\tverMicroExslt = s.substring(s.indexOf(\"=\") + 1, s.length)\n+\t\t\tverMicroExslt = s.substring(s.indexOf(\"=\") + 1, s.length);\n@@ -195,0 +197,1 @@\n+\tvf.WriteLine(\"WITH_PROFILER=\" + (withProfiler? \"1\" : \"0\"));\n@@ -243,0 +246,2 @@\n+\t\t} else if (s.search(\/\\@WITH_PROFILER\\@\/) != -1) {\n+\t\t\tof.WriteLine(s.replace(\/\\@WITH_PROFILER\\@\/, withProfiler? \"1\" : \"0\"));\n@@ -346,0 +351,2 @@\n+\t\telse if (opt == \"profiler\")\n+\t\t\twithProfiler = strToBool(arg.substring(opt.length + 1, arg.length));\n@@ -356,2 +363,0 @@\n-\t\telse if (opt == \"incdir\")\n-\t\t\tbuildIncPrefix = arg.substring(opt.length + 1, arg.length);\n@@ -480,0 +485,1 @@\n+txtOut += \"          Profiler: \" + boolToStr(withProfiler) + \"\\n\";\n@@ -486,1 +492,1 @@\n-\ttxtOut += \"    Embed Manifest: \" + boolToStr(vcmanifest) + \"\\n\";\n+txtOut += \"    Embed Manifest: \" + boolToStr(vcmanifest) + \"\\n\";\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/libxslt\/src\/win32\/configure.js","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"}]}