{"files":[{"patch":"@@ -1,1 +1,1 @@\n-3.39.4\n+3.45.3\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/VERSION.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-** version 3.39.4.  By combining all the individual C code files into this\n+** version 3.45.3.  By combining all the individual C code files into this\n@@ -19,0 +19,3 @@\n+**\n+** The content in this amalgamation comes from Fossil check-in\n+** 8653b758870e6ef0c98d46b3ace27849054a.\n@@ -53,1 +56,1 @@\n-**    OPTIMIZATION-IF-TRUE        - This branch is allowed to alway be false\n+**    OPTIMIZATION-IF-TRUE        - This branch is allowed to always be false\n@@ -57,1 +60,1 @@\n-**    OPTIMIZATION-IF-FALSE       - This branch is allowed to alway be true\n+**    OPTIMIZATION-IF-FALSE       - This branch is allowed to always be true\n@@ -126,0 +129,4 @@\n+#if !defined(HAVE_LOG2) && defined(_MSC_VER) && _MSC_VER<1800\n+#define HAVE_LOG2 0\n+#endif \/* !defined(HAVE_LOG2) && defined(_MSC_VER) && _MSC_VER<1800 *\/\n+\n@@ -455,3 +462,3 @@\n-#define SQLITE_VERSION        \"3.39.4\"\n-#define SQLITE_VERSION_NUMBER 3039004\n-#define SQLITE_SOURCE_ID      \"2022-09-29 15:55:41 a29f9949895322123f7c38fbe94c649a9d6e6c9cd0c3b41c96d694552f26b309\"\n+#define SQLITE_VERSION        \"3.45.3\"\n+#define SQLITE_VERSION_NUMBER 3045003\n+#define SQLITE_SOURCE_ID      \"2024-04-15 13:34:05 8653b758870e6ef0c98d46b3ace27849054af85da891eb121e9aaa537f1e8355\"\n@@ -729,0 +736,2 @@\n+** <li> The application must not dereference the arrays or string pointers\n+**       passed as the 3rd and 4th callback parameters after it returns.\n@@ -837,0 +846,1 @@\n+#define SQLITE_IOERR_IN_PAGE           (SQLITE_IOERR | (34<<8))\n@@ -872,0 +882,1 @@\n+#define SQLITE_NOTICE_RBU              (SQLITE_NOTICE | (3<<8))\n@@ -979,1 +990,5 @@\n-** of an [sqlite3_io_methods] object.\n+** of an [sqlite3_io_methods] object.  These values are ordered from\n+** lest restrictive to most restrictive.\n+**\n+** The argument to xLock() is always SHARED or higher.  The argument to\n+** xUnlock is either SHARED or NONE.\n@@ -981,5 +996,5 @@\n-#define SQLITE_LOCK_NONE          0\n-#define SQLITE_LOCK_SHARED        1\n-#define SQLITE_LOCK_RESERVED      2\n-#define SQLITE_LOCK_PENDING       3\n-#define SQLITE_LOCK_EXCLUSIVE     4\n+#define SQLITE_LOCK_NONE          0       \/* xUnlock() only *\/\n+#define SQLITE_LOCK_SHARED        1       \/* xLock() or xUnlock() *\/\n+#define SQLITE_LOCK_RESERVED      2       \/* xLock() only *\/\n+#define SQLITE_LOCK_PENDING       3       \/* xLock() only *\/\n+#define SQLITE_LOCK_EXCLUSIVE     4       \/* xLock() only *\/\n@@ -1063,1 +1078,8 @@\n-** xLock() increases the lock. xUnlock() decreases the lock.\n+** xLock() upgrades the database file lock.  In other words, xLock() moves the\n+** database file lock in the direction NONE toward EXCLUSIVE. The argument to\n+** xLock() is always on of SHARED, RESERVED, PENDING, or EXCLUSIVE, never\n+** SQLITE_LOCK_NONE.  If the database file lock is already at or above the\n+** requested lock, then the call to xLock() is a no-op.\n+** xUnlock() downgrades the database file lock to either SHARED or NONE.\n+*  If the lock is already at or below the requested lock state, then the call\n+** to xUnlock() is a no-op.\n@@ -1168,3 +1190,2 @@\n-** into an integer that the pArg argument points to. This capability\n-** is used during testing and is only available when the SQLITE_TEST\n-** compile-time option is used.\n+** into an integer that the pArg argument points to.\n+** This capability is only available if SQLite is compiled with [SQLITE_DEBUG].\n@@ -1474,1 +1495,0 @@\n-** <\/ul>\n@@ -1487,1 +1507,0 @@\n-** <\/ul>\n@@ -1490,1 +1509,8 @@\n-** Used by the cksmvfs VFS module only.\n+** The [SQLITE_FCNTL_CKSM_FILE] opcode is for use internally by the\n+** [checksum VFS shim] only.\n+**\n+** <li>[[SQLITE_FCNTL_RESET_CACHE]]\n+** If there is currently no transaction open on the database, and the\n+** database is not a temp db, then the [SQLITE_FCNTL_RESET_CACHE] file-control\n+** purges the contents of the in-memory page cache. If there is an open\n+** transaction, or if the db is a temp-db, this opcode is a no-op, not an error.\n@@ -1533,0 +1559,1 @@\n+#define SQLITE_FCNTL_RESET_CACHE            42\n@@ -1562,0 +1589,20 @@\n+\/*\n+** CAPI3REF: File Name\n+**\n+** Type [sqlite3_filename] is used by SQLite to pass filenames to the\n+** xOpen method of a [VFS]. It may be cast to (const char*) and treated\n+** as a normal, nul-terminated, UTF-8 buffer containing the filename, but\n+** may also be passed to special APIs such as:\n+**\n+** <ul>\n+** <li>  sqlite3_filename_database()\n+** <li>  sqlite3_filename_journal()\n+** <li>  sqlite3_filename_wal()\n+** <li>  sqlite3_uri_parameter()\n+** <li>  sqlite3_uri_boolean()\n+** <li>  sqlite3_uri_int64()\n+** <li>  sqlite3_uri_key()\n+** <\/ul>\n+*\/\n+typedef const char *sqlite3_filename;\n+\n@@ -1740,1 +1787,1 @@\n-  int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,\n+  int (*xOpen)(sqlite3_vfs*, sqlite3_filename zName, sqlite3_file*,\n@@ -1927,8 +1974,0 @@\n-** The sqlite3_config() interface\n-** may only be invoked prior to library initialization using\n-** [sqlite3_initialize()] or after shutdown by [sqlite3_shutdown()].\n-** ^If sqlite3_config() is called after [sqlite3_initialize()] and before\n-** [sqlite3_shutdown()] then it will return SQLITE_MISUSE.\n-** Note, however, that ^sqlite3_config() can be called as part of the\n-** implementation of an application-defined [sqlite3_os_init()].\n-**\n@@ -1941,0 +1980,11 @@\n+** For most configuration options, the sqlite3_config() interface\n+** may only be invoked prior to library initialization using\n+** [sqlite3_initialize()] or after shutdown by [sqlite3_shutdown()].\n+** The exceptional configuration options that may be invoked at any time\n+** are called \"anytime configuration options\".\n+** ^If sqlite3_config() is called after [sqlite3_initialize()] and before\n+** [sqlite3_shutdown()] with a first argument that is not an anytime\n+** configuration option, then the sqlite3_config() call will return SQLITE_MISUSE.\n+** Note, however, that ^sqlite3_config() can be called as part of the\n+** implementation of an application-defined [sqlite3_os_init()].\n+**\n@@ -2048,0 +2098,17 @@\n+** Most of the configuration options for sqlite3_config()\n+** will only work if invoked prior to [sqlite3_initialize()] or after\n+** [sqlite3_shutdown()].  The few exceptions to this rule are called\n+** \"anytime configuration options\".\n+** ^Calling [sqlite3_config()] with a first argument that is not an\n+** anytime configuration option in between calls to [sqlite3_initialize()] and\n+** [sqlite3_shutdown()] is a no-op that returns SQLITE_MISUSE.\n+**\n+** The set of anytime configuration options can change (by insertions\n+** and\/or deletions) from one release of SQLite to the next.\n+** As of SQLite version 3.42.0, the complete set of anytime configuration\n+** options is:\n+** <ul>\n+** <li> SQLITE_CONFIG_LOG\n+** <li> SQLITE_CONFIG_PCACHE_HDRSZ\n+** <\/ul>\n+**\n@@ -2378,1 +2445,1 @@\n-** negative value for this option restores the default behaviour.\n+** negative value for this option restores the default behavior.\n@@ -2392,0 +2459,16 @@\n+**\n+** [[SQLITE_CONFIG_ROWID_IN_VIEW]]\n+** <dt>SQLITE_CONFIG_ROWID_IN_VIEW\n+** <dd>The SQLITE_CONFIG_ROWID_IN_VIEW option enables or disables the ability\n+** for VIEWs to have a ROWID.  The capability can only be enabled if SQLite is\n+** compiled with -DSQLITE_ALLOW_ROWID_IN_VIEW, in which case the capability\n+** defaults to on.  This configuration option queries the current setting or\n+** changes the setting to off or on.  The argument is a pointer to an integer.\n+** If that integer initially holds a value of 1, then the ability for VIEWs to\n+** have ROWIDs is activated.  If the integer initially holds zero, then the\n+** ability is deactivated.  Any other initial value for the integer leaves the\n+** setting unchanged.  After changes, if any, the integer is written with\n+** a 1 or 0, if the ability for VIEWs to have ROWIDs is on or off.  If SQLite\n+** is compiled without -DSQLITE_ALLOW_ROWID_IN_VIEW (which is the usual and\n+** recommended case) then the integer is always filled with zero, regardless\n+** if its initial value.\n@@ -2394,19 +2477,19 @@\n-#define SQLITE_CONFIG_SINGLETHREAD  1  \/* nil *\/\n-#define SQLITE_CONFIG_MULTITHREAD   2  \/* nil *\/\n-#define SQLITE_CONFIG_SERIALIZED    3  \/* nil *\/\n-#define SQLITE_CONFIG_MALLOC        4  \/* sqlite3_mem_methods* *\/\n-#define SQLITE_CONFIG_GETMALLOC     5  \/* sqlite3_mem_methods* *\/\n-#define SQLITE_CONFIG_SCRATCH       6  \/* No longer used *\/\n-#define SQLITE_CONFIG_PAGECACHE     7  \/* void*, int sz, int N *\/\n-#define SQLITE_CONFIG_HEAP          8  \/* void*, int nByte, int min *\/\n-#define SQLITE_CONFIG_MEMSTATUS     9  \/* boolean *\/\n-#define SQLITE_CONFIG_MUTEX        10  \/* sqlite3_mutex_methods* *\/\n-#define SQLITE_CONFIG_GETMUTEX     11  \/* sqlite3_mutex_methods* *\/\n-\/* previously SQLITE_CONFIG_CHUNKALLOC 12 which is now unused. *\/\n-#define SQLITE_CONFIG_LOOKASIDE    13  \/* int int *\/\n-#define SQLITE_CONFIG_PCACHE       14  \/* no-op *\/\n-#define SQLITE_CONFIG_GETPCACHE    15  \/* no-op *\/\n-#define SQLITE_CONFIG_LOG          16  \/* xFunc, void* *\/\n-#define SQLITE_CONFIG_URI          17  \/* int *\/\n-#define SQLITE_CONFIG_PCACHE2      18  \/* sqlite3_pcache_methods2* *\/\n-#define SQLITE_CONFIG_GETPCACHE2   19  \/* sqlite3_pcache_methods2* *\/\n+#define SQLITE_CONFIG_SINGLETHREAD         1  \/* nil *\/\n+#define SQLITE_CONFIG_MULTITHREAD          2  \/* nil *\/\n+#define SQLITE_CONFIG_SERIALIZED           3  \/* nil *\/\n+#define SQLITE_CONFIG_MALLOC               4  \/* sqlite3_mem_methods* *\/\n+#define SQLITE_CONFIG_GETMALLOC            5  \/* sqlite3_mem_methods* *\/\n+#define SQLITE_CONFIG_SCRATCH              6  \/* No longer used *\/\n+#define SQLITE_CONFIG_PAGECACHE            7  \/* void*, int sz, int N *\/\n+#define SQLITE_CONFIG_HEAP                 8  \/* void*, int nByte, int min *\/\n+#define SQLITE_CONFIG_MEMSTATUS            9  \/* boolean *\/\n+#define SQLITE_CONFIG_MUTEX               10  \/* sqlite3_mutex_methods* *\/\n+#define SQLITE_CONFIG_GETMUTEX            11  \/* sqlite3_mutex_methods* *\/\n+\/* previously SQLITE_CONFIG_CHUNKALLOC    12 which is now unused. *\/\n+#define SQLITE_CONFIG_LOOKASIDE           13  \/* int int *\/\n+#define SQLITE_CONFIG_PCACHE              14  \/* no-op *\/\n+#define SQLITE_CONFIG_GETPCACHE           15  \/* no-op *\/\n+#define SQLITE_CONFIG_LOG                 16  \/* xFunc, void* *\/\n+#define SQLITE_CONFIG_URI                 17  \/* int *\/\n+#define SQLITE_CONFIG_PCACHE2             18  \/* sqlite3_pcache_methods2* *\/\n+#define SQLITE_CONFIG_GETPCACHE2          19  \/* sqlite3_pcache_methods2* *\/\n@@ -2414,2 +2497,2 @@\n-#define SQLITE_CONFIG_SQLLOG       21  \/* xSqllog, void* *\/\n-#define SQLITE_CONFIG_MMAP_SIZE    22  \/* sqlite3_int64, sqlite3_int64 *\/\n+#define SQLITE_CONFIG_SQLLOG              21  \/* xSqllog, void* *\/\n+#define SQLITE_CONFIG_MMAP_SIZE           22  \/* sqlite3_int64, sqlite3_int64 *\/\n@@ -2423,0 +2506,1 @@\n+#define SQLITE_CONFIG_ROWID_IN_VIEW       30  \/* int* *\/\n@@ -2456,1 +2540,1 @@\n-** [sqlite3_db_status](D,[SQLITE_CONFIG_LOOKASIDE],...) is zero.\n+** [sqlite3_db_status](D,[SQLITE_DBSTATUS_LOOKASIDE_USED],...) is zero.\n@@ -2553,1 +2637,1 @@\n-** override this behaviour. The first parameter passed to this operation\n+** override this behavior. The first parameter passed to this operation\n@@ -2606,2 +2690,6 @@\n-** process requires the use of this obscure API and multiple steps to help\n-** ensure that it does not happen by accident.\n+** process requires the use of this obscure API and multiple steps to\n+** help ensure that it does not happen by accident. Because this\n+** feature must be capable of resetting corrupt databases, and\n+** shutting down virtual tables may require access to that corrupt\n+** storage, the library must abandon any installed virtual tables\n+** without calling their xDestroy() methods.\n@@ -2618,0 +2706,1 @@\n+** <li> The [PRAGMA schema_version=N] statement.\n@@ -2645,1 +2734,1 @@\n-** <dt>SQLITE_DBCONFIG_DQS_DML<\/td>\n+** <dt>SQLITE_DBCONFIG_DQS_DML<\/dt>\n@@ -2654,1 +2743,1 @@\n-** <dt>SQLITE_DBCONFIG_DQS_DDL<\/td>\n+** <dt>SQLITE_DBCONFIG_DQS_DDL<\/dt>\n@@ -2663,1 +2752,1 @@\n-** <dt>SQLITE_DBCONFIG_TRUSTED_SCHEMA<\/td>\n+** <dt>SQLITE_DBCONFIG_TRUSTED_SCHEMA<\/dt>\n@@ -2683,1 +2772,1 @@\n-** <dt>SQLITE_DBCONFIG_LEGACY_FILE_FORMAT<\/td>\n+** <dt>SQLITE_DBCONFIG_LEGACY_FILE_FORMAT<\/dt>\n@@ -2692,1 +2781,1 @@\n-** is now scarcely any need to generated database files that are compatible\n+** is now scarcely any need to generate database files that are compatible\n@@ -2701,1 +2790,32 @@\n-** either generated columns or decending indexes.\n+** either generated columns or descending indexes.\n+** <\/dd>\n+**\n+** [[SQLITE_DBCONFIG_STMT_SCANSTATUS]]\n+** <dt>SQLITE_DBCONFIG_STMT_SCANSTATUS<\/dt>\n+** <dd>The SQLITE_DBCONFIG_STMT_SCANSTATUS option is only useful in\n+** SQLITE_ENABLE_STMT_SCANSTATUS builds. In this case, it sets or clears\n+** a flag that enables collection of the sqlite3_stmt_scanstatus_v2()\n+** statistics. For statistics to be collected, the flag must be set on\n+** the database handle both when the SQL statement is prepared and when it\n+** is stepped. The flag is set (collection of statistics is enabled)\n+** by default.  This option takes two arguments: an integer and a pointer to\n+** an integer..  The first argument is 1, 0, or -1 to enable, disable, or\n+** leave unchanged the statement scanstatus option.  If the second argument\n+** is not NULL, then the value of the statement scanstatus setting after\n+** processing the first argument is written into the integer that the second\n+** argument points to.\n+** <\/dd>\n+**\n+** [[SQLITE_DBCONFIG_REVERSE_SCANORDER]]\n+** <dt>SQLITE_DBCONFIG_REVERSE_SCANORDER<\/dt>\n+** <dd>The SQLITE_DBCONFIG_REVERSE_SCANORDER option changes the default order\n+** in which tables and indexes are scanned so that the scans start at the end\n+** and work toward the beginning rather than starting at the beginning and\n+** working toward the end. Setting SQLITE_DBCONFIG_REVERSE_SCANORDER is the\n+** same as setting [PRAGMA reverse_unordered_selects].  This option takes\n+** two arguments which are an integer and a pointer to an integer.  The first\n+** argument is 1, 0, or -1 to enable, disable, or leave unchanged the\n+** reverse scan order flag, respectively.  If the second argument is not NULL,\n+** then 0 or 1 is written into the integer that the second argument points to\n+** depending on if the reverse scan order flag is set after processing the\n+** first argument.\n@@ -2703,0 +2823,1 @@\n+**\n@@ -2723,1 +2844,3 @@\n-#define SQLITE_DBCONFIG_MAX                   1017 \/* Largest DBCONFIG *\/\n+#define SQLITE_DBCONFIG_STMT_SCANSTATUS       1018 \/* int int* *\/\n+#define SQLITE_DBCONFIG_REVERSE_SCANORDER     1019 \/* int int* *\/\n+#define SQLITE_DBCONFIG_MAX                   1019 \/* Largest DBCONFIG *\/\n@@ -2945,0 +3068,4 @@\n+**\n+** ^The [sqlite3_is_interrupted(D)] interface can be used to determine whether\n+** or not an interrupt is currently in effect for [database connection] D.\n+** It returns 1 if an interrupt is currently in effect, or 0 otherwise.\n@@ -2947,0 +3074,1 @@\n+SQLITE_API int sqlite3_is_interrupted(sqlite3*);\n@@ -3564,2 +3692,2 @@\n-** X argument points to a 64-bit integer which is the estimated of\n-** the number of nanosecond that the prepared statement took to run.\n+** X argument points to a 64-bit integer which is approximately\n+** the number of nanoseconds that the prepared statement took to run.\n@@ -3597,2 +3725,4 @@\n-** ^Each call to either sqlite3_trace() or sqlite3_trace_v2() overrides\n-** (cancels) any prior calls to sqlite3_trace() or sqlite3_trace_v2().\n+** ^Each call to either sqlite3_trace(D,X,P) or sqlite3_trace_v2(D,M,X,P)\n+** overrides (cancels) all prior calls to sqlite3_trace(D,X,P) or\n+** sqlite3_trace_v2(D,M,X,P) for the [database connection] D.  Each\n+** database connection may have at most one trace callback.\n@@ -3628,1 +3758,1 @@\n-** [sqlite3_exec()], [sqlite3_step()] and [sqlite3_get_table()] for\n+** [sqlite3_step()] and [sqlite3_prepare()] and similar for\n@@ -3653,0 +3783,7 @@\n+** The progress handler callback would originally only be invoked from the\n+** bytecode engine.  It still might be invoked during [sqlite3_prepare()]\n+** and similar because those routines might force a reparse of the schema\n+** which involves running the bytecode engine.  However, beginning with\n+** SQLite version 3.41.0, the progress handler callback might also be\n+** invoked directly from [sqlite3_prepare()] while analyzing and generating\n+** code for complex queries.\n@@ -3689,2 +3826,2 @@\n-** <dd>The database is opened in read-only mode.  If the database does not\n-** already exist, an error is returned.<\/dd>)^\n+** <dd>The database is opened in read-only mode.  If the database does\n+** not already exist, an error is returned.<\/dd>)^\n@@ -3693,3 +3830,8 @@\n-** <dd>The database is opened for reading and writing if possible, or reading\n-** only if the file is write protected by the operating system.  In either\n-** case the database must already exist, otherwise an error is returned.<\/dd>)^\n+** <dd>The database is opened for reading and writing if possible, or\n+** reading only if the file is write protected by the operating\n+** system.  In either case the database must already exist, otherwise\n+** an error is returned.  For historical reasons, if opening in\n+** read-write mode fails due to OS-level permissions, an attempt is\n+** made to open it in read-only mode. [sqlite3_db_readonly()] can be\n+** used to determine whether the database is actually\n+** read-write.<\/dd>)^\n@@ -3733,0 +3875,3 @@\n+** The [use of shared cache mode is discouraged] and hence shared cache\n+** capabilities may be omitted from many builds of SQLite.  In such cases,\n+** this option is a no-op.\n@@ -3748,1 +3893,1 @@\n-** <dd>The database filename is not allowed to be a symbolic link<\/dd>\n+** <dd>The database filename is not allowed to contain a symbolic link<\/dd>\n@@ -3952,1 +4097,1 @@\n-** passed into the xOpen() method of a VFS implemention, or\n+** passed into the xOpen() method of a VFS implementation, or\n@@ -4007,4 +4152,4 @@\n-SQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam);\n-SQLITE_API int sqlite3_uri_boolean(const char *zFile, const char *zParam, int bDefault);\n-SQLITE_API sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int64);\n-SQLITE_API const char *sqlite3_uri_key(const char *zFilename, int N);\n+SQLITE_API const char *sqlite3_uri_parameter(sqlite3_filename z, const char *zParam);\n+SQLITE_API int sqlite3_uri_boolean(sqlite3_filename z, const char *zParam, int bDefault);\n+SQLITE_API sqlite3_int64 sqlite3_uri_int64(sqlite3_filename, const char*, sqlite3_int64);\n+SQLITE_API const char *sqlite3_uri_key(sqlite3_filename z, int N);\n@@ -4039,3 +4184,3 @@\n-SQLITE_API const char *sqlite3_filename_database(const char*);\n-SQLITE_API const char *sqlite3_filename_journal(const char*);\n-SQLITE_API const char *sqlite3_filename_wal(const char*);\n+SQLITE_API const char *sqlite3_filename_database(sqlite3_filename);\n+SQLITE_API const char *sqlite3_filename_journal(sqlite3_filename);\n+SQLITE_API const char *sqlite3_filename_wal(sqlite3_filename);\n@@ -4065,1 +4210,1 @@\n-** These interfces are provided for use by [VFS shim] implementations and\n+** These interfaces are provided for use by [VFS shim] implementations and\n@@ -4107,1 +4252,1 @@\n-SQLITE_API char *sqlite3_create_filename(\n+SQLITE_API sqlite3_filename sqlite3_create_filename(\n@@ -4114,1 +4259,1 @@\n-SQLITE_API void sqlite3_free_filename(char*);\n+SQLITE_API void sqlite3_free_filename(sqlite3_filename);\n@@ -4144,1 +4289,3 @@\n-** text that describes the error, as either UTF-8 or UTF-16 respectively.\n+** text that describes the error, as either UTF-8 or UTF-16 respectively,\n+** or NULL if no error message is available.\n+** (See how SQLite handles [invalid UTF] for exceptions to this rule.)\n@@ -4150,2 +4297,3 @@\n-** ^The sqlite3_errstr() interface returns the English-language text\n-** that describes the [result code], as UTF-8.\n+** ^The sqlite3_errstr(E) interface returns the English-language text\n+** that describes the [result code] E, as UTF-8, or NULL if E is not an\n+** result code for which a text error message is available.\n@@ -4612,0 +4760,35 @@\n+\/*\n+** CAPI3REF: Change The EXPLAIN Setting For A Prepared Statement\n+** METHOD: sqlite3_stmt\n+**\n+** The sqlite3_stmt_explain(S,E) interface changes the EXPLAIN\n+** setting for [prepared statement] S.  If E is zero, then S becomes\n+** a normal prepared statement.  If E is 1, then S behaves as if\n+** its SQL text began with \"[EXPLAIN]\".  If E is 2, then S behaves as if\n+** its SQL text began with \"[EXPLAIN QUERY PLAN]\".\n+**\n+** Calling sqlite3_stmt_explain(S,E) might cause S to be reprepared.\n+** SQLite tries to avoid a reprepare, but a reprepare might be necessary\n+** on the first transition into EXPLAIN or EXPLAIN QUERY PLAN mode.\n+**\n+** Because of the potential need to reprepare, a call to\n+** sqlite3_stmt_explain(S,E) will fail with SQLITE_ERROR if S cannot be\n+** reprepared because it was created using [sqlite3_prepare()] instead of\n+** the newer [sqlite3_prepare_v2()] or [sqlite3_prepare_v3()] interfaces and\n+** hence has no saved SQL text with which to reprepare.\n+**\n+** Changing the explain setting for a prepared statement does not change\n+** the original SQL text for the statement.  Hence, if the SQL text originally\n+** began with EXPLAIN or EXPLAIN QUERY PLAN, but sqlite3_stmt_explain(S,0)\n+** is called to convert the statement into an ordinary statement, the EXPLAIN\n+** or EXPLAIN QUERY PLAN keywords will still appear in the sqlite3_sql(S)\n+** output, even though the statement now acts like a normal SQL statement.\n+**\n+** This routine returns SQLITE_OK if the explain mode is successfully\n+** changed, or an error code if the explain mode could not be changed.\n+** The explain mode cannot be changed while a statement is active.\n+** Hence, it is good practice to call [sqlite3_reset(S)]\n+** immediately prior to calling sqlite3_stmt_explain(S,E).\n+*\/\n+SQLITE_API int sqlite3_stmt_explain(sqlite3_stmt *pStmt, int eMode);\n+\n@@ -4775,1 +4958,1 @@\n-** ^ (2) The special constant, [SQLITE_STATIC], may be passsed to indicate that\n+** ^ (2) The special constant, [SQLITE_STATIC], may be passed to indicate that\n@@ -5454,4 +5637,6 @@\n-** ^If the most recent call to [sqlite3_step(S)] for the\n-** [prepared statement] S returned [SQLITE_ROW] or [SQLITE_DONE],\n-** or if [sqlite3_step(S)] has never before been called on S,\n-** then [sqlite3_reset(S)] returns [SQLITE_OK].\n+** ^The return code from [sqlite3_reset(S)] indicates whether or not\n+** the previous evaluation of prepared statement S completed successfully.\n+** ^If [sqlite3_step(S)] has never before been called on S or if\n+** [sqlite3_step(S)] has not been called since the previous call\n+** to [sqlite3_reset(S)], then [sqlite3_reset(S)] will return\n+** [SQLITE_OK].\n@@ -5462,0 +5647,10 @@\n+** ^The [sqlite3_reset(S)] interface might also return an [error code]\n+** if there were no prior errors but the process of resetting\n+** the prepared statement caused a new error. ^For example, if an\n+** [INSERT] statement with a [RETURNING] clause is only stepped one time,\n+** that one call to [sqlite3_step(S)] might return SQLITE_ROW but\n+** the overall statement might still fail and the [sqlite3_reset(S)] call\n+** might return SQLITE_BUSY if locking constraints prevent the\n+** database change from committing.  Therefore, it is important that\n+** applications check the return code from [sqlite3_reset(S)] even if\n+** no prior call to [sqlite3_step(S)] indicated a problem.\n@@ -5468,0 +5663,1 @@\n+\n@@ -5673,4 +5869,15 @@\n-** The SQLITE_DIRECTONLY flags is a security feature which is recommended\n-** for all [application-defined SQL functions], and especially for functions\n-** that have side-effects or that could potentially leak sensitive\n-** information.\n+** <p>\n+** The SQLITE_DIRECTONLY flag is recommended for any\n+** [application-defined SQL function]\n+** that has side-effects or that could potentially leak sensitive information.\n+** This will prevent attacks in which an application is tricked\n+** into using a database file that has had its schema surreptitiously\n+** modified to invoke the application-defined function in ways that are\n+** harmful.\n+** <p>\n+** Some people say it is good practice to set SQLITE_DIRECTONLY on all\n+** [application-defined SQL functions], regardless of whether or not they\n+** are security sensitive, as doing so prevents those functions from being used\n+** inside of the database schema, and thus ensures that the database\n+** can be inspected and modified using generic tools (such as the [CLI])\n+** that do not have access to the application-defined functions.\n@@ -5703,1 +5910,1 @@\n-** The SQLITE_SUBTYPE flag indicates to SQLite that a function may call\n+** The SQLITE_SUBTYPE flag indicates to SQLite that a function might call\n@@ -5705,5 +5912,19 @@\n-** Specifying this flag makes no difference for scalar or aggregate user\n-** functions. However, if it is not specified for a user-defined window\n-** function, then any sub-types belonging to arguments passed to the window\n-** function may be discarded before the window function is called (i.e.\n-** sqlite3_value_subtype() will always return 0).\n+** This flag instructs SQLite to omit some corner-case optimizations that\n+** might disrupt the operation of the [sqlite3_value_subtype()] function,\n+** causing it to return zero rather than the correct subtype().\n+** SQL functions that invokes [sqlite3_value_subtype()] should have this\n+** property.  If the SQLITE_SUBTYPE property is omitted, then the return\n+** value from [sqlite3_value_subtype()] might sometimes be zero even though\n+** a non-zero subtype was specified by the function argument expression.\n+**\n+** [[SQLITE_RESULT_SUBTYPE]] <dt>SQLITE_RESULT_SUBTYPE<\/dt><dd>\n+** The SQLITE_RESULT_SUBTYPE flag indicates to SQLite that a function might call\n+** [sqlite3_result_subtype()] to cause a sub-type to be associated with its\n+** result.\n+** Every function that invokes [sqlite3_result_subtype()] should have this\n+** property.  If it does not, then the call to [sqlite3_result_subtype()]\n+** might become a no-op if the function is used as term in an\n+** [expression index].  On the other hand, SQL functions that never invoke\n+** [sqlite3_result_subtype()] should avoid setting this property, as the\n+** purpose of this property is to disable certain optimizations that are\n+** incompatible with subtypes.\n@@ -5717,0 +5938,1 @@\n+#define SQLITE_RESULT_SUBTYPE   0x001000000\n@@ -5882,0 +6104,22 @@\n+\/*\n+** CAPI3REF: Report the internal text encoding state of an sqlite3_value object\n+** METHOD: sqlite3_value\n+**\n+** ^(The sqlite3_value_encoding(X) interface returns one of [SQLITE_UTF8],\n+** [SQLITE_UTF16BE], or [SQLITE_UTF16LE] according to the current text encoding\n+** of the value X, assuming that X has type TEXT.)^  If sqlite3_value_type(X)\n+** returns something other than SQLITE_TEXT, then the return value from\n+** sqlite3_value_encoding(X) is meaningless.  ^Calls to\n+** [sqlite3_value_text(X)], [sqlite3_value_text16(X)], [sqlite3_value_text16be(X)],\n+** [sqlite3_value_text16le(X)], [sqlite3_value_bytes(X)], or\n+** [sqlite3_value_bytes16(X)] might change the encoding of the value X and\n+** thus change the return from subsequent calls to sqlite3_value_encoding(X).\n+**\n+** This routine is intended for used by applications that test and validate\n+** the SQLite implementation.  This routine is inquiring about the opaque\n+** internal state of an [sqlite3_value] object.  Ordinary applications should\n+** not need to know what the internal state of an sqlite3_value object is and\n+** hence should not need to use this interface.\n+*\/\n+SQLITE_API int sqlite3_value_encoding(sqlite3_value*);\n+\n@@ -5891,0 +6135,6 @@\n+**\n+** Every [application-defined SQL function] that invoke this interface\n+** should include the [SQLITE_SUBTYPE] property in the text\n+** encoding argument when the function is [sqlite3_create_function|registered].\n+** If the [SQLITE_SUBTYPE] property is omitted, then sqlite3_value_subtype()\n+** might return zero instead of the upstream subtype in some corner cases.\n@@ -5934,1 +6184,1 @@\n-** allocate error occurs.\n+** allocation error occurs.\n@@ -5989,6 +6239,6 @@\n-** associate metadata with argument values. If the same value is passed to\n-** multiple invocations of the same SQL function during query execution, under\n-** some circumstances the associated metadata may be preserved.  An example\n-** of where this might be useful is in a regular-expression matching\n-** function. The compiled version of the regular expression can be stored as\n-** metadata associated with the pattern string.\n+** associate auxiliary data with argument values. If the same argument\n+** value is passed to multiple invocations of the same SQL function during\n+** query execution, under some circumstances the associated auxiliary data\n+** might be preserved.  An example of where this might be useful is in a\n+** regular-expression matching function. The compiled version of the regular\n+** expression can be stored as auxiliary data associated with the pattern string.\n@@ -5999,1 +6249,1 @@\n-** ^The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadata\n+** ^The sqlite3_get_auxdata(C,N) interface returns a pointer to the auxiliary data\n@@ -6002,1 +6252,1 @@\n-** function argument.  ^If there is no metadata\n+** function argument.  ^If there is no auxiliary data\n@@ -6006,2 +6256,2 @@\n-** ^The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-th\n-** argument of the application-defined function.  ^Subsequent\n+** ^The sqlite3_set_auxdata(C,N,P,X) interface saves P as auxiliary data for the\n+** N-th argument of the application-defined function.  ^Subsequent\n@@ -6009,2 +6259,2 @@\n-** sqlite3_set_auxdata(C,N,P,X) call if the metadata is still valid or\n-** NULL if the metadata has been discarded.\n+** sqlite3_set_auxdata(C,N,P,X) call if the auxiliary data is still valid or\n+** NULL if the auxiliary data has been discarded.\n@@ -6013,2 +6263,2 @@\n-** once, when the metadata is discarded.\n-** SQLite is free to discard the metadata at any time, including: <ul>\n+** once, when the auxiliary data is discarded.\n+** SQLite is free to discard the auxiliary data at any time, including: <ul>\n@@ -6021,1 +6271,4 @@\n-**      allocation error occurs.)^ <\/ul>\n+**      allocation error occurs.)^\n+** <li> ^(during the original sqlite3_set_auxdata() call if the function\n+**      is evaluated during query planning instead of during query execution,\n+**      as sometimes happens with [SQLITE_ENABLE_STAT4].)^ <\/ul>\n@@ -6023,1 +6276,1 @@\n-** Note the last bullet in particular.  The destructor X in\n+** Note the last two bullets in particular.  The destructor X in\n@@ -6028,3 +6281,8 @@\n-** sqlite3_set_auxdata() has been called.\n-**\n-** ^(In practice, metadata is preserved between function calls for\n+** sqlite3_set_auxdata() has been called.  Furthermore, a call to\n+** sqlite3_get_auxdata() that occurs immediately after a corresponding call\n+** to sqlite3_set_auxdata() might still return NULL if an out-of-memory\n+** condition occurred during the sqlite3_set_auxdata() call or if the\n+** function is being evaluated during query planning rather than during\n+** query execution.\n+**\n+** ^(In practice, auxiliary data is preserved between function calls for\n@@ -6040,0 +6298,2 @@\n+**\n+** See also: [sqlite3_get_clientdata()] and [sqlite3_set_clientdata()].\n@@ -6044,0 +6304,55 @@\n+\/*\n+** CAPI3REF: Database Connection Client Data\n+** METHOD: sqlite3\n+**\n+** These functions are used to associate one or more named pointers\n+** with a [database connection].\n+** A call to sqlite3_set_clientdata(D,N,P,X) causes the pointer P\n+** to be attached to [database connection] D using name N.  Subsequent\n+** calls to sqlite3_get_clientdata(D,N) will return a copy of pointer P\n+** or a NULL pointer if there were no prior calls to\n+** sqlite3_set_clientdata() with the same values of D and N.\n+** Names are compared using strcmp() and are thus case sensitive.\n+**\n+** If P and X are both non-NULL, then the destructor X is invoked with\n+** argument P on the first of the following occurrences:\n+** <ul>\n+** <li> An out-of-memory error occurs during the call to\n+**      sqlite3_set_clientdata() which attempts to register pointer P.\n+** <li> A subsequent call to sqlite3_set_clientdata(D,N,P,X) is made\n+**      with the same D and N parameters.\n+** <li> The database connection closes.  SQLite does not make any guarantees\n+**      about the order in which destructors are called, only that all\n+**      destructors will be called exactly once at some point during the\n+**      database connection closing process.\n+** <\/ul>\n+**\n+** SQLite does not do anything with client data other than invoke\n+** destructors on the client data at the appropriate time.  The intended\n+** use for client data is to provide a mechanism for wrapper libraries\n+** to store additional information about an SQLite database connection.\n+**\n+** There is no limit (other than available memory) on the number of different\n+** client data pointers (with different names) that can be attached to a\n+** single database connection.  However, the implementation is optimized\n+** for the case of having only one or two different client data names.\n+** Applications and wrapper libraries are discouraged from using more than\n+** one client data name each.\n+**\n+** There is no way to enumerate the client data pointers\n+** associated with a database connection.  The N parameter can be thought\n+** of as a secret key such that only code that knows the secret key is able\n+** to access the associated data.\n+**\n+** Security Warning:  These interfaces should not be exposed in scripting\n+** languages or in other circumstances where it might be possible for an\n+** an attacker to invoke them.  Any agent that can invoke these interfaces\n+** can probably also take control of the process.\n+**\n+** Database connection client data is only available for SQLite\n+** version 3.44.0 ([dateof:3.44.0]) and later.\n+**\n+** See also: [sqlite3_set_auxdata()] and [sqlite3_get_auxdata()].\n+*\/\n+SQLITE_API void *sqlite3_get_clientdata(sqlite3*,const char*);\n+SQLITE_API int sqlite3_set_clientdata(sqlite3*, const char*, void*, void(*)(void*));\n@@ -6139,3 +6454,4 @@\n-** ^If the 3rd parameter to the sqlite3_result_text* interfaces\n-** is negative, then SQLite takes result text from the 2nd parameter\n-** through the first zero character.\n+** ^If the 3rd parameter to any of the sqlite3_result_text* interfaces\n+** other than sqlite3_result_text64() is negative, then SQLite computes\n+** the string length itself by searching the 2nd parameter for the first\n+** zero character.\n@@ -6244,0 +6560,14 @@\n+**\n+** Every [application-defined SQL function] that invokes this interface\n+** should include the [SQLITE_RESULT_SUBTYPE] property in its\n+** text encoding argument when the SQL function is\n+** [sqlite3_create_function|registered].  If the [SQLITE_RESULT_SUBTYPE]\n+** property is omitted from the function that invokes sqlite3_result_subtype(),\n+** then in some cases the sqlite3_result_subtype() might fail to set\n+** the result subtype.\n+**\n+** If SQLite is compiled with -DSQLITE_STRICT_SUBTYPE=1, then any\n+** SQL function that invokes the sqlite3_result_subtype() interface\n+** and that does not have the SQLITE_RESULT_SUBTYPE property will raise\n+** an error.  Future versions of SQLite might enable -DSQLITE_STRICT_SUBTYPE=1\n+** by default.\n@@ -6415,0 +6745,7 @@\n+**\n+** If a negative argument is passed to sqlite3_sleep() the results vary by\n+** VFS and operating system.  Some system treat a negative argument as an\n+** instruction to sleep forever.  Others understand it to mean do not sleep\n+** at all. ^In SQLite version 3.42.0 and later, a negative\n+** argument passed into sqlite3_sleep() is changed to zero before it is relayed\n+** down into the xSleep method of the VFS.\n@@ -6637,1 +6974,1 @@\n-SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName);\n+SQLITE_API sqlite3_filename sqlite3_db_filename(sqlite3 *db, const char *zDbName);\n@@ -6668,1 +7005,1 @@\n-** CAPI3REF: Allowed return values from [sqlite3_txn_state()]\n+** CAPI3REF: Allowed return values from sqlite3_txn_state()\n@@ -6774,1 +7111,1 @@\n-** the the size of the database file in pages, the number of free pages,\n+** the size of the database file in pages, the number of free pages,\n@@ -6800,1 +7137,1 @@\n-** then the autovacuum steps callback is cancelled.  The return value\n+** then the autovacuum steps callback is canceled.  The return value\n@@ -6895,0 +7232,5 @@\n+** This interface is omitted if SQLite is compiled with\n+** [-DSQLITE_OMIT_SHARED_CACHE].  The [-DSQLITE_OMIT_SHARED_CACHE]\n+** compile-time option is recommended because the\n+** [use of shared cache mode is discouraged].\n+**\n@@ -6993,1 +7335,1 @@\n-** the the soft heap limit is set to the value of the hard heap limit.\n+** the soft heap limit is set to the value of the hard heap limit.\n@@ -7254,9 +7596,0 @@\n-\/*\n-** The interface to the virtual-table mechanism is currently considered\n-** to be experimental.  The interface might change in incompatible ways.\n-** If this is a problem for you, do not use the interface at this time.\n-**\n-** When the virtual-table mechanism stabilizes, we will declare the\n-** interface fixed, support it indefinitely, and remove this comment.\n-*\/\n-\n@@ -7323,0 +7656,4 @@\n+  \/* The methods above are in versions 1 through 3 of the sqlite_module object.\n+  ** Those below are for version 4 and greater. *\/\n+  int (*xIntegrity)(sqlite3_vtab *pVTab, const char *zSchema,\n+                    const char *zTabName, int mFlags, char **pzErr);\n@@ -7381,1 +7718,1 @@\n-** ^The idxNum and idxPtr values are recorded and passed into the\n+** ^The idxNum and idxStr values are recorded and passed into the\n@@ -7383,2 +7720,2 @@\n-** ^[sqlite3_free()] is used to free idxPtr if and only if\n-** needToFreeIdxPtr is true.\n+** ^[sqlite3_free()] is used to free idxStr if and only if\n+** needToFreeIdxStr is true.\n@@ -7504,1 +7841,1 @@\n-** interface is no commonly needed.\n+** interface is not commonly needed.\n@@ -7663,10 +8000,0 @@\n-\/*\n-** The interface to the virtual-table mechanism defined above (back up\n-** to a comment remarkably similar to this one) is currently considered\n-** to be experimental.  The interface might change in incompatible ways.\n-** If this is a problem for you, do not use the interface at this time.\n-**\n-** When the virtual-table mechanism stabilizes, we will declare the\n-** interface fixed, support it indefinitely, and remove this comment.\n-*\/\n-\n@@ -7820,1 +8147,1 @@\n-** open blob handle results in undefined behaviour. ^Calling this routine\n+** open blob handle results in undefined behavior. ^Calling this routine\n@@ -8047,3 +8374,5 @@\n-** will always return SQLITE_BUSY. The SQLite core only ever uses\n-** sqlite3_mutex_try() as an optimization so this is acceptable\n-** behavior.)^\n+** will always return SQLITE_BUSY. In most cases the SQLite core only uses\n+** sqlite3_mutex_try() as an optimization, so this is acceptable\n+** behavior. The exceptions are unix builds that set the\n+** SQLITE_ENABLE_SETLK_TIMEOUT build option. In that case a working\n+** sqlite3_mutex_try() is required.)^\n@@ -8056,3 +8385,3 @@\n-** ^If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), or\n-** sqlite3_mutex_leave() is a NULL pointer, then all three routines\n-** behave as no-ops.\n+** ^If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(),\n+** sqlite3_mutex_leave(), or sqlite3_mutex_free() is a NULL pointer,\n+** then any of the four routines behaves as a no-op.\n@@ -8300,0 +8629,1 @@\n+#define SQLITE_TESTCTRL_FK_NO_ACTION             7\n@@ -8307,0 +8637,1 @@\n+#define SQLITE_TESTCTRL_JSON_SELFCHECK          14\n@@ -8328,1 +8659,2 @@\n-#define SQLITE_TESTCTRL_LAST                    33  \/* Largest TESTCTRL *\/\n+#define SQLITE_TESTCTRL_USELONGDOUBLE           34\n+#define SQLITE_TESTCTRL_LAST                    34  \/* Largest TESTCTRL *\/\n@@ -9288,1 +9620,1 @@\n-** backup is in progress might also also cause a mutex deadlock.\n+** backup is in progress might also cause a mutex deadlock.\n@@ -9716,1 +10048,1 @@\n-#define SQLITE_CHECKPOINT_RESTART  2  \/* Like FULL but wait for for readers *\/\n+#define SQLITE_CHECKPOINT_RESTART  2  \/* Like FULL but wait for readers *\/\n@@ -9784,1 +10116,1 @@\n-** the [xConnect] or [xCreate] methods of a [virtual table] implmentation\n+** the [xConnect] or [xCreate] methods of a [virtual table] implementation\n@@ -9792,1 +10124,1 @@\n-** the [xConnect] or [xCreate] methods of a [virtual table] implmentation\n+** the [xConnect] or [xCreate] methods of a [virtual table] implementation\n@@ -9799,0 +10131,9 @@\n+**\n+** [[SQLITE_VTAB_USES_ALL_SCHEMAS]]<dt>SQLITE_VTAB_USES_ALL_SCHEMAS<\/dt>\n+** <dd>Calls of the form\n+** [sqlite3_vtab_config](db,SQLITE_VTAB_USES_ALL_SCHEMA) from within the\n+** the [xConnect] or [xCreate] methods of a [virtual table] implementation\n+** instruct the query planner to begin at least a read transaction on\n+** all schemas (\"main\", \"temp\", and any ATTACH-ed databases) whenever the\n+** virtual table is used.\n+** <\/dd>\n@@ -9804,0 +10145,1 @@\n+#define SQLITE_VTAB_USES_ALL_SCHEMAS   4\n@@ -9876,1 +10218,1 @@\n-SQLITE_API SQLITE_EXPERIMENTAL const char *sqlite3_vtab_collation(sqlite3_index_info*,int);\n+SQLITE_API const char *sqlite3_vtab_collation(sqlite3_index_info*,int);\n@@ -9964,1 +10306,1 @@\n-** aConstraintUsage[].argvIndex to a postive integer.  ^(Then, under\n+** aConstraintUsage[].argvIndex to a positive integer.  ^(Then, under\n@@ -10033,1 +10375,1 @@\n-** sqlite3_vtab_in_next(X,P) must be one of the parameters to the\n+** sqlite3_vtab_in_next(X,P) should be one of the parameters to the\n@@ -10039,2 +10381,1 @@\n-** processing, then these routines return [SQLITE_MISUSE])^ or perhaps\n-** exhibit some other undefined or harmful behavior.\n+** processing, then these routines return [SQLITE_ERROR].)^\n@@ -10047,1 +10388,1 @@\n-** &nbsp;      rc==SQLITE_OK && pVal\n+** &nbsp;      rc==SQLITE_OK && pVal;\n@@ -10145,0 +10486,4 @@\n+** Not all values are available for all query elements. When a value is\n+** not available, the output variable is set to -1 if the value is numeric,\n+** or to NULL if it is a string (SQLITE_SCANSTAT_NAME).\n+**\n@@ -10172,1 +10517,1 @@\n-** [[SQLITE_SCANSTAT_SELECTID]] <dt>SQLITE_SCANSTAT_SELECT<\/dt>\n+** [[SQLITE_SCANSTAT_SELECTID]] <dt>SQLITE_SCANSTAT_SELECTID<\/dt>\n@@ -10174,4 +10519,16 @@\n-** \"select-id\" for the X-th loop.  The select-id identifies which query or\n-** subquery the loop is part of.  The main query has a select-id of zero.\n-** The select-id is the same value as is output in the first column\n-** of an [EXPLAIN QUERY PLAN] query.\n+** id for the X-th query plan element. The id value is unique within the\n+** statement. The select-id is the same value as is output in the first\n+** column of an [EXPLAIN QUERY PLAN] query.\n+**\n+** [[SQLITE_SCANSTAT_PARENTID]] <dt>SQLITE_SCANSTAT_PARENTID<\/dt>\n+** <dd>The \"int\" variable pointed to by the V parameter will be set to the\n+** the id of the parent of the current query element, if applicable, or\n+** to zero if the query element has no parent. This is the same value as\n+** returned in the second column of an [EXPLAIN QUERY PLAN] query.\n+**\n+** [[SQLITE_SCANSTAT_NCYCLE]] <dt>SQLITE_SCANSTAT_NCYCLE<\/dt>\n+** <dd>The sqlite3_int64 output value is set to the number of cycles,\n+** according to the processor time-stamp counter, that elapsed while the\n+** query element was being processed. This value is not available for\n+** all query elements - if it is unavailable the output variable is\n+** set to -1.\n@@ -10186,0 +10543,2 @@\n+#define SQLITE_SCANSTAT_PARENTID 6\n+#define SQLITE_SCANSTAT_NCYCLE   7\n@@ -10191,1 +10550,1 @@\n-** This interface returns information about the predicted and measured\n+** These interfaces return information about the predicted and measured\n@@ -10202,13 +10561,19 @@\n-** of this interface is undefined.\n-** ^The requested measurement is written into a variable pointed to by\n-** the \"pOut\" parameter.\n-** Parameter \"idx\" identifies the specific loop to retrieve statistics for.\n-** Loops are numbered starting from zero. ^If idx is out of range - less than\n-** zero or greater than or equal to the total number of loops used to implement\n-** the statement - a non-zero value is returned and the variable that pOut\n-** points to is unchanged.\n-**\n-** ^Statistics might not be available for all loops in all statements. ^In cases\n-** where there exist loops with no available statistics, this function behaves\n-** as if the loop did not exist - it returns non-zero and leave the variable\n-** that pOut points to unchanged.\n+** of this interface is undefined. ^The requested measurement is written into\n+** a variable pointed to by the \"pOut\" parameter.\n+**\n+** The \"flags\" parameter must be passed a mask of flags. At present only\n+** one flag is defined - SQLITE_SCANSTAT_COMPLEX. If SQLITE_SCANSTAT_COMPLEX\n+** is specified, then status information is available for all elements\n+** of a query plan that are reported by \"EXPLAIN QUERY PLAN\" output. If\n+** SQLITE_SCANSTAT_COMPLEX is not specified, then only query plan elements\n+** that correspond to query loops (the \"SCAN...\" and \"SEARCH...\" elements of\n+** the EXPLAIN QUERY PLAN output) are available. Invoking API\n+** sqlite3_stmt_scanstatus() is equivalent to calling\n+** sqlite3_stmt_scanstatus_v2() with a zeroed flags parameter.\n+**\n+** Parameter \"idx\" identifies the specific query element to retrieve statistics\n+** for. Query elements are numbered starting from zero. A value of -1 may be\n+** to query for statistics regarding the entire query. ^If idx is out of range\n+** - less than -1 or greater than or equal to the total number of query\n+** elements used to implement the statement - a non-zero value is returned and\n+** the variable that pOut points to is unchanged.\n@@ -10224,0 +10589,13 @@\n+SQLITE_API int sqlite3_stmt_scanstatus_v2(\n+  sqlite3_stmt *pStmt,      \/* Prepared statement for which info desired *\/\n+  int idx,                  \/* Index of loop to report on *\/\n+  int iScanStatusOp,        \/* Information desired.  SQLITE_SCANSTAT_* *\/\n+  int flags,                \/* Mask of flags defined below *\/\n+  void *pOut                \/* Result written here *\/\n+);\n+\n+\/*\n+** CAPI3REF: Prepared Statement Scan Status\n+** KEYWORDS: {scan status flags}\n+*\/\n+#define SQLITE_SCANSTAT_COMPLEX 0x0001\n@@ -10314,0 +10692,4 @@\n+** ^The sqlite3_preupdate_hook(D,C,P) function returns the P argument from\n+** the previous call on the same [database connection] D, or NULL for\n+** the first call on D.\n+**\n@@ -10353,1 +10735,1 @@\n-** callback made with op==SQLITE_DELETE is actuall a write using the\n+** callback made with op==SQLITE_DELETE is actually a write using the\n@@ -10614,0 +10996,7 @@\n+** After the call, if the SQLITE_SERIALIZE_NOCOPY bit had been set,\n+** the returned buffer content will remain accessible and unchanged\n+** until either the next write operation on the connection or when\n+** the connection is closed, and applications must not modify the\n+** buffer. If the bit had been clear, the returned buffer will not\n+** be accessed by SQLite after the call.\n+**\n@@ -10662,0 +11051,3 @@\n+** Applications must not modify the buffer P or invalidate it before\n+** the database connection D is closed.\n+**\n@@ -10670,0 +11062,7 @@\n+** The deserialized database should not be in [WAL mode].  If the database\n+** is in WAL mode, then any attempt to use the database file will result\n+** in an [SQLITE_CANTOPEN] error.  The application can set the\n+** [file format version numbers] (bytes 18 and 19) of the input database P\n+** to 0x01 prior to invoking sqlite3_deserialize(D,S,P,N,M,F) to force the\n+** database file into rollback mode and work around this limitation.\n+**\n@@ -10719,0 +11118,13 @@\n+#if defined(__wasi__)\n+# undef SQLITE_WASI\n+# define SQLITE_WASI 1\n+# undef SQLITE_OMIT_WAL\n+# define SQLITE_OMIT_WAL 1\/* because it requires shared memory APIs *\/\n+# ifndef SQLITE_OMIT_LOAD_EXTENSION\n+#  define SQLITE_OMIT_LOAD_EXTENSION\n+# endif\n+# ifndef SQLITE_THREADSAFE\n+#  define SQLITE_THREADSAFE 0\n+# endif\n+#endif\n+\n@@ -10925,1 +11337,1 @@\n-** CAPIREF: Conigure a Session Object\n+** CAPI3REF: Configure a Session Object\n@@ -10929,2 +11341,2 @@\n-** created. At present the only valid value for the second parameter is\n-** [SQLITE_SESSION_OBJCONFIG_SIZE].\n+** created. At present the only valid values for the second parameter are\n+** [SQLITE_SESSION_OBJCONFIG_SIZE] and [SQLITE_SESSION_OBJCONFIG_ROWID].\n@@ -10932,1 +11344,5 @@\n-** Arguments for sqlite3session_object_config()\n+*\/\n+SQLITE_API int sqlite3session_object_config(sqlite3_session*, int op, void *pArg);\n+\n+\/*\n+** CAPI3REF: Options for sqlite3session_object_config\n@@ -10934,1 +11350,1 @@\n-** The following values may passed as the the 4th parameter to\n+** The following values may passed as the the 2nd parameter to\n@@ -10950,0 +11366,12 @@\n+**\n+** <dt>SQLITE_SESSION_OBJCONFIG_ROWID <dd>\n+**   This option is used to set, clear or query the flag that enables\n+**   collection of data for tables with no explicit PRIMARY KEY.\n+**\n+**   Normally, tables with no explicit PRIMARY KEY are simply ignored\n+**   by the sessions module. However, if this flag is set, it behaves\n+**   as if such tables have a column \"_rowid_ INTEGER PRIMARY KEY\" inserted\n+**   as their leftmost columns.\n+**\n+**   It is an error (SQLITE_MISUSE) to attempt to modify this setting after\n+**   the first table has been attached to the session object.\n@@ -10951,5 +11379,2 @@\n-SQLITE_API int sqlite3session_object_config(sqlite3_session*, int op, void *pArg);\n-\n-\/*\n-*\/\n-#define SQLITE_SESSION_OBJCONFIG_SIZE 1\n+#define SQLITE_SESSION_OBJCONFIG_SIZE  1\n+#define SQLITE_SESSION_OBJCONFIG_ROWID 2\n@@ -11716,0 +12141,12 @@\n+\/*\n+** CAPI3REF: Upgrade the Schema of a Changeset\/Patchset\n+*\/\n+SQLITE_API int sqlite3changeset_upgrade(\n+  sqlite3 *db,\n+  const char *zDb,\n+  int nIn, const void *pIn,       \/* Input changeset *\/\n+  int *pnOut, void **ppOut        \/* OUT: Inverse of input *\/\n+);\n+\n+\n+\n@@ -11762,0 +12199,32 @@\n+\/*\n+** CAPI3REF: Add a Schema to a Changegroup\n+** METHOD: sqlite3_changegroup_schema\n+**\n+** This method may be used to optionally enforce the rule that the changesets\n+** added to the changegroup handle must match the schema of database zDb\n+** (\"main\", \"temp\", or the name of an attached database). If\n+** sqlite3changegroup_add() is called to add a changeset that is not compatible\n+** with the configured schema, SQLITE_SCHEMA is returned and the changegroup\n+** object is left in an undefined state.\n+**\n+** A changeset schema is considered compatible with the database schema in\n+** the same way as for sqlite3changeset_apply(). Specifically, for each\n+** table in the changeset, there exists a database table with:\n+**\n+** <ul>\n+**   <li> The name identified by the changeset, and\n+**   <li> at least as many columns as recorded in the changeset, and\n+**   <li> the primary key columns in the same position as recorded in\n+**        the changeset.\n+** <\/ul>\n+**\n+** The output of the changegroup object always has the same schema as the\n+** database nominated using this function. In cases where changesets passed\n+** to sqlite3changegroup_add() have fewer columns than the corresponding table\n+** in the database schema, these are filled in using the default column\n+** values from the database schema. This makes it possible to combined\n+** changesets that have different numbers of columns for a single table\n+** within a changegroup, provided that they are otherwise compatible.\n+*\/\n+SQLITE_API int sqlite3changegroup_schema(sqlite3_changegroup*, sqlite3*, const char *zDb);\n+\n@@ -11830,5 +12299,9 @@\n-** case, this function fails with SQLITE_SCHEMA. If the input changeset\n-** appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is\n-** returned. Or, if an out-of-memory condition occurs during processing, this\n-** function returns SQLITE_NOMEM. In all cases, if an error occurs the state\n-** of the final contents of the changegroup is undefined.\n+** case, this function fails with SQLITE_SCHEMA. Except, if the changegroup\n+** object has been configured with a database schema using the\n+** sqlite3changegroup_schema() API, then it is possible to combine changesets\n+** with different numbers of columns for a single table, provided that\n+** they are otherwise compatible.\n+**\n+** If the input changeset appears to be corrupt and the corruption is\n+** detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition\n+** occurs during processing, this function returns SQLITE_NOMEM.\n@@ -11836,1 +12309,2 @@\n-** If no error occurs, SQLITE_OK is returned.\n+** In all cases, if an error occurs the state of the final contents of the\n+** changegroup is undefined. If no error occurs, SQLITE_OK is returned.\n@@ -12088,0 +12562,19 @@\n+**\n+** <dt>SQLITE_CHANGESETAPPLY_IGNORENOOP <dd>\n+**   Do not invoke the conflict handler callback for any changes that\n+**   would not actually modify the database even if they were applied.\n+**   Specifically, this means that the conflict handler is not invoked\n+**   for:\n+**    <ul>\n+**    <li>a delete change if the row being deleted cannot be found,\n+**    <li>an update change if the modified fields are already set to\n+**        their new values in the conflicting row, or\n+**    <li>an insert change if all fields of the conflicting row match\n+**        the row being inserted.\n+**    <\/ul>\n+**\n+** <dt>SQLITE_CHANGESETAPPLY_FKNOACTION <dd>\n+**   If this flag it set, then all foreign key constraints in the target\n+**   database behave as if they were declared with \"ON UPDATE NO ACTION ON\n+**   DELETE NO ACTION\", even if they are actually CASCADE, RESTRICT, SET NULL\n+**   or SET DEFAULT.\n@@ -12091,0 +12584,2 @@\n+#define SQLITE_CHANGESETAPPLY_IGNORENOOP    0x0004\n+#define SQLITE_CHANGESETAPPLY_FKNOACTION    0x0008\n@@ -12656,2 +13151,5 @@\n-**   This function attempts to retrieve the text of column iCol of the\n-**   current document. If successful, (*pz) is set to point to a buffer\n+**   If parameter iCol is less than zero, or greater than or equal to the\n+**   number of columns in the table, SQLITE_RANGE is returned.\n+**\n+**   Otherwise, this function attempts to retrieve the text of column iCol of\n+**   the current document. If successful, (*pz) is set to point to a buffer\n@@ -12667,2 +13165,4 @@\n-**   Returns the number of tokens in phrase iPhrase of the query. Phrases\n-**   are numbered starting from zero.\n+**   If parameter iCol is less than zero, or greater than or equal to the\n+**   number of phrases in the current query, as returned by xPhraseCount,\n+**   0 is returned. Otherwise, this function returns the number of tokens in\n+**   phrase iPhrase of the query. Phrases are numbered starting from zero.\n@@ -12684,1 +13184,2 @@\n-**   output by xInstCount().\n+**   output by xInstCount(). If iIdx is less than zero or greater than\n+**   or equal to the value returned by xInstCount(), SQLITE_RANGE is returned.\n@@ -12686,1 +13187,1 @@\n-**   Usually, output parameter *piPhrase is set to the phrase number, *piCol\n+**   Otherwise, output parameter *piPhrase is set to the phrase number, *piCol\n@@ -12688,2 +13189,2 @@\n-**   first token of the phrase. Returns SQLITE_OK if successful, or an error\n-**   code (i.e. SQLITE_NOMEM) if an error occurs.\n+**   first token of the phrase. SQLITE_OK is returned if successful, or an\n+**   error code (i.e. SQLITE_NOMEM) if an error occurs.\n@@ -12715,0 +13216,4 @@\n+**   If parameter iPhrase is less than zero, or greater than or equal to\n+**   the number of phrases in the query, as returned by xPhraseCount(),\n+**   this function returns SQLITE_RANGE.\n+**\n@@ -12829,0 +13334,33 @@\n+**\n+** xQueryToken(pFts5, iPhrase, iToken, ppToken, pnToken)\n+**   This is used to access token iToken of phrase iPhrase of the current\n+**   query. Before returning, output parameter *ppToken is set to point\n+**   to a buffer containing the requested token, and *pnToken to the\n+**   size of this buffer in bytes.\n+**\n+**   If iPhrase or iToken are less than zero, or if iPhrase is greater than\n+**   or equal to the number of phrases in the query as reported by\n+**   xPhraseCount(), or if iToken is equal to or greater than the number of\n+**   tokens in the phrase, SQLITE_RANGE is returned and *ppToken and *pnToken\n+     are both zeroed.\n+**\n+**   The output text is not a copy of the query text that specified the\n+**   token. It is the output of the tokenizer module. For tokendata=1\n+**   tables, this includes any embedded 0x00 and trailing data.\n+**\n+** xInstToken(pFts5, iIdx, iToken, ppToken, pnToken)\n+**   This is used to access token iToken of phrase hit iIdx within the\n+**   current row. If iIdx is less than zero or greater than or equal to the\n+**   value returned by xInstCount(), SQLITE_RANGE is returned.  Otherwise,\n+**   output variable (*ppToken) is set to point to a buffer containing the\n+**   matching document token, and (*pnToken) to the size of that buffer in\n+**   bytes. This API is not available if the specified token matches a\n+**   prefix query term. In that case both output variables are always set\n+**   to 0.\n+**\n+**   The output text is not a copy of the document text that was tokenized.\n+**   It is the output of the tokenizer module. For tokendata=1 tables, this\n+**   includes any embedded 0x00 and trailing data.\n+**\n+**   This API can be quite slow if used with an FTS5 table created with the\n+**   \"detail=none\" or \"detail=column\" option.\n@@ -12866,0 +13404,7 @@\n+\n+  \/* Below this point are iVersion>=3 only *\/\n+  int (*xQueryToken)(Fts5Context*,\n+      int iPhrase, int iToken,\n+      const char **ppToken, int *pnToken\n+  );\n+  int (*xInstToken)(Fts5Context*, int iIdx, int iToken, const char**, int*);\n@@ -13060,2 +13605,2 @@\n-**   provide synonyms when tokenizing document text (method (2)) or query\n-**   text (method (3)), not both. Doing so will not cause any errors, but is\n+**   provide synonyms when tokenizing document text (method (3)) or query\n+**   text (method (2)), not both. Doing so will not cause any errors, but is\n@@ -13109,1 +13654,1 @@\n-    void *pContext,\n+    void *pUserData,\n@@ -13118,1 +13663,1 @@\n-    void **ppContext,\n+    void **ppUserData,\n@@ -13126,1 +13671,1 @@\n-    void *pContext,\n+    void *pUserData,\n@@ -13157,1 +13702,1 @@\n-#include \"config.h\"\n+#include \"sqlite_cfg.h\"\n@@ -13237,1 +13782,1 @@\n-** any limit on the number of terms in a compount SELECT.\n+** any limit on the number of terms in a compound SELECT.\n@@ -13352,1 +13897,1 @@\n-# define SQLITE_MAX_PAGE_COUNT 1073741823\n+# define SQLITE_MAX_PAGE_COUNT 0xfffffffe \/* 4294967294 *\/\n@@ -13387,2 +13932,2 @@\n-** WAL mode depends on atomic aligned 32-bit loads and stores in a few\n-** places.  The following macros try to make this explicit.\n+** A few places in the code require atomic load\/store of aligned\n+** integer values.\n@@ -13444,1 +13989,1 @@\n-** A macro to hint to the compiler that a function should not be\n+** Macros to hint to the compiler that a function should or should not be\n@@ -13449,0 +13994,1 @@\n+#  define SQLITE_INLINE    __attribute__((always_inline)) inline\n@@ -13451,0 +13997,1 @@\n+#  define SQLITE_INLINE    __forceinline\n@@ -13453,0 +14000,5 @@\n+#  define SQLITE_INLINE\n+#endif\n+#if defined(SQLITE_COVERAGE_TEST) || defined(__STRICT_ANSI__)\n+# undef SQLITE_INLINE\n+# define SQLITE_INLINE\n@@ -13474,0 +14026,23 @@\n+\/*\n+** Enable SQLITE_USE_SEH by default on MSVC builds.  Only omit\n+** SEH support if the -DSQLITE_OMIT_SEH option is given.\n+*\/\n+#if defined(_MSC_VER) && !defined(SQLITE_OMIT_SEH)\n+# define SQLITE_USE_SEH 1\n+#else\n+# undef SQLITE_USE_SEH\n+#endif\n+\n+\/*\n+** Enable SQLITE_DIRECT_OVERFLOW_READ, unless the build explicitly\n+** disables it using -DSQLITE_DIRECT_OVERFLOW_READ=0\n+*\/\n+#if defined(SQLITE_DIRECT_OVERFLOW_READ) && SQLITE_DIRECT_OVERFLOW_READ+1==1\n+  \/* Disable if -DSQLITE_DIRECT_OVERFLOW_READ=0 *\/\n+# undef SQLITE_DIRECT_OVERFLOW_READ\n+#else\n+  \/* In all other cases, enable *\/\n+# define SQLITE_DIRECT_OVERFLOW_READ 1\n+#endif\n+\n+\n@@ -14270,3 +14845,1 @@\n-** table or index.  This is an unsigned integer type.  For 99.9% of\n-** the world, a 32-bit integer is sufficient.  But a 64-bit integer\n-** can be used at compile-time if desired.\n+** table or index.\n@@ -14274,5 +14847,1 @@\n-#ifdef SQLITE_64BIT_STATS\n- typedef u64 tRowcnt;    \/* 64-bit only if requested at compile-time *\/\n-#else\n- typedef u32 tRowcnt;    \/* 32-bit is the default *\/\n-#endif\n+typedef u64 tRowcnt;\n@@ -14339,1 +14908,1 @@\n-#define SQLITE_WITHIN(P,S,E) (((uptr)(P)>=(uptr)(S))&&((uptr)(P)<(uptr)(E)))\n+#define SQLITE_WITHIN(P,S,E)   (((uptr)(P)>=(uptr)(S))&&((uptr)(P)<(uptr)(E)))\n@@ -14341,0 +14910,23 @@\n+\/*\n+** P is one byte past the end of a large buffer. Return true if a span of bytes\n+** between S..E crosses the end of that buffer.  In other words, return true\n+** if the sub-buffer S..E-1 overflows the buffer whose last byte is P-1.\n+**\n+** S is the start of the span.  E is one byte past the end of end of span.\n+**\n+**                        P\n+**     |-----------------|                FALSE\n+**               |-------|\n+**               S        E\n+**\n+**                        P\n+**     |-----------------|\n+**                    |-------|           TRUE\n+**                    S        E\n+**\n+**                        P\n+**     |-----------------|\n+**                        |-------|       FALSE\n+**                        S        E\n+*\/\n+#define SQLITE_OVERFLOW(P,S,E) (((uptr)(S)<(uptr)(P))&&((uptr)(E)>(uptr)(P)))\n@@ -14350,0 +14942,12 @@\n+**\n+** If you are building SQLite on some obscure platform for which the\n+** following ifdef magic does not work, you can always include either:\n+**\n+**    -DSQLITE_BYTEORDER=1234\n+**\n+** or\n+**\n+**    -DSQLITE_BYTEORDER=4321\n+**\n+** to cause the build to work for little-endian or big-endian processors,\n+** respectively.\n@@ -14351,2 +14955,8 @@\n-#ifndef SQLITE_BYTEORDER\n-# if defined(i386)      || defined(__i386__)      || defined(_M_IX86) ||    \\\n+#ifndef SQLITE_BYTEORDER  \/* Replicate changes at tag-20230904a *\/\n+# if defined(__BYTE_ORDER__) && __BYTE_ORDER__==__ORDER_BIG_ENDIAN__\n+#   define SQLITE_BYTEORDER 4321\n+# elif defined(__BYTE_ORDER__) && __BYTE_ORDER__==__ORDER_LITTLE_ENDIAN__\n+#   define SQLITE_BYTEORDER 1234\n+# elif defined(__BIG_ENDIAN__) && __BIG_ENDIAN__==1\n+#   define SQLITE_BYTEORDER 4321\n+# elif defined(i386)    || defined(__i386__)      || defined(_M_IX86) ||    \\\n@@ -14356,4 +14966,3 @@\n-#   define SQLITE_BYTEORDER    1234\n-# elif defined(sparc)     || defined(__ppc__) || \\\n-       defined(__ARMEB__) || defined(__AARCH64EB__)\n-#   define SQLITE_BYTEORDER    4321\n+#   define SQLITE_BYTEORDER 1234\n+# elif defined(sparc)   || defined(__ARMEB__)     || defined(__AARCH64EB__)\n+#   define SQLITE_BYTEORDER 4321\n@@ -14424,1 +15033,1 @@\n-# define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&3)==0)\n+# define EIGHT_BYTE_ALIGNMENT(X)   ((((uptr)(X) - (uptr)0)&3)==0)\n@@ -14426,1 +15035,1 @@\n-# define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&7)==0)\n+# define EIGHT_BYTE_ALIGNMENT(X)   ((((uptr)(X) - (uptr)0)&7)==0)\n@@ -14480,1 +15089,1 @@\n-# define SELECTTRACE(K,P,S,X)  \\\n+# define TREETRACE(K,P,S,X)  \\\n@@ -14485,1 +15094,1 @@\n-# define SELECTTRACE(K,P,S,X)\n+# define TREETRACE(K,P,S,X)\n@@ -14489,0 +15098,24 @@\n+\/* TREETRACE flag meanings:\n+**\n+**   0x00000001     Beginning and end of SELECT processing\n+**   0x00000002     WHERE clause processing\n+**   0x00000004     Query flattener\n+**   0x00000008     Result-set wildcard expansion\n+**   0x00000010     Query name resolution\n+**   0x00000020     Aggregate analysis\n+**   0x00000040     Window functions\n+**   0x00000080     Generated column names\n+**   0x00000100     Move HAVING terms into WHERE\n+**   0x00000200     Count-of-view optimization\n+**   0x00000400     Compound SELECT processing\n+**   0x00000800     Drop superfluous ORDER BY\n+**   0x00001000     LEFT JOIN simplifies to JOIN\n+**   0x00002000     Constant propagation\n+**   0x00004000     Push-down optimization\n+**   0x00008000     After all FROM-clause analysis\n+**   0x00010000     Beginning of DELETE\/INSERT\/UPDATE processing\n+**   0x00020000     Transform DISTINCT into GROUP BY\n+**   0x00040000     SELECT tree dump after all code has been generated\n+**   0x00080000     NOT NULL strength reduction\n+*\/\n+\n@@ -14501,0 +15134,30 @@\n+\/*\n+** Bits for the sqlite3WhereTrace mask:\n+**\n+** (---any--)   Top-level block structure\n+** 0x-------F   High-level debug messages\n+** 0x----FFF-   More detail\n+** 0xFFFF----   Low-level debug messages\n+**\n+** 0x00000001   Code generation\n+** 0x00000002   Solver\n+** 0x00000004   Solver costs\n+** 0x00000008   WhereLoop inserts\n+**\n+** 0x00000010   Display sqlite3_index_info xBestIndex calls\n+** 0x00000020   Range an equality scan metrics\n+** 0x00000040   IN operator decisions\n+** 0x00000080   WhereLoop cost adjustements\n+** 0x00000100\n+** 0x00000200   Covering index decisions\n+** 0x00000400   OR optimization\n+** 0x00000800   Index scanner\n+** 0x00001000   More details associated with code generation\n+** 0x00002000\n+** 0x00004000   Show all WHERE terms at key points\n+** 0x00008000   Show the full SELECT statement at key places\n+**\n+** 0x00010000   Show more detail when printing WHERE terms\n+** 0x00020000   Show WHERE terms returned from whereScanNext()\n+*\/\n+\n@@ -14521,1 +15184,1 @@\n-** The PREFERRED names are used whereever possible.  But LEGACY is also\n+** The PREFERRED names are used wherever possible.  But LEGACY is also\n@@ -14630,0 +15293,1 @@\n+typedef struct DbClientData DbClientData;\n@@ -14635,0 +15299,1 @@\n+typedef struct FpDecode FpDecode;\n@@ -14640,0 +15305,1 @@\n+typedef struct IndexedExpr IndexedExpr;\n@@ -14652,0 +15318,1 @@\n+typedef struct RCStr RCStr;\n@@ -14705,0 +15372,1 @@\n+#define TOPBIT        (((Bitmask)1)<<(BMS-1))\n@@ -14719,0 +15387,325 @@\n+\/************** Include os.h in the middle of sqliteInt.h ********************\/\n+\/************** Begin file os.h **********************************************\/\n+\/*\n+** 2001 September 16\n+**\n+** The author disclaims copyright to this source code.  In place of\n+** a legal notice, here is a blessing:\n+**\n+**    May you do good and not evil.\n+**    May you find forgiveness for yourself and forgive others.\n+**    May you share freely, never taking more than you give.\n+**\n+******************************************************************************\n+**\n+** This header file (together with is companion C source-code file\n+** \"os.c\") attempt to abstract the underlying operating system so that\n+** the SQLite library will work on both POSIX and windows systems.\n+**\n+** This header file is #include-ed by sqliteInt.h and thus ends up\n+** being included by every source file.\n+*\/\n+#ifndef _SQLITE_OS_H_\n+#define _SQLITE_OS_H_\n+\n+\/*\n+** Attempt to automatically detect the operating system and setup the\n+** necessary pre-processor macros for it.\n+*\/\n+\/************** Include os_setup.h in the middle of os.h *********************\/\n+\/************** Begin file os_setup.h ****************************************\/\n+\/*\n+** 2013 November 25\n+**\n+** The author disclaims copyright to this source code.  In place of\n+** a legal notice, here is a blessing:\n+**\n+**    May you do good and not evil.\n+**    May you find forgiveness for yourself and forgive others.\n+**    May you share freely, never taking more than you give.\n+**\n+******************************************************************************\n+**\n+** This file contains pre-processor directives related to operating system\n+** detection and\/or setup.\n+*\/\n+#ifndef SQLITE_OS_SETUP_H\n+#define SQLITE_OS_SETUP_H\n+\n+\/*\n+** Figure out if we are dealing with Unix, Windows, or some other operating\n+** system.\n+**\n+** After the following block of preprocess macros, all of\n+**\n+**    SQLITE_OS_KV\n+**    SQLITE_OS_OTHER\n+**    SQLITE_OS_UNIX\n+**    SQLITE_OS_WIN\n+**\n+** will defined to either 1 or 0. One of them will be 1. The others will be 0.\n+** If none of the macros are initially defined, then select either\n+** SQLITE_OS_UNIX or SQLITE_OS_WIN depending on the target platform.\n+**\n+** If SQLITE_OS_OTHER=1 is specified at compile-time, then the application\n+** must provide its own VFS implementation together with sqlite3_os_init()\n+** and sqlite3_os_end() routines.\n+*\/\n+#if !defined(SQLITE_OS_KV) && !defined(SQLITE_OS_OTHER) && \\\n+       !defined(SQLITE_OS_UNIX) && !defined(SQLITE_OS_WIN)\n+#  if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || \\\n+          defined(__MINGW32__) || defined(__BORLANDC__)\n+#    define SQLITE_OS_WIN 1\n+#    define SQLITE_OS_UNIX 0\n+#  else\n+#    define SQLITE_OS_WIN 0\n+#    define SQLITE_OS_UNIX 1\n+#  endif\n+#endif\n+#if SQLITE_OS_OTHER+1>1\n+#  undef SQLITE_OS_KV\n+#  define SQLITE_OS_KV 0\n+#  undef SQLITE_OS_UNIX\n+#  define SQLITE_OS_UNIX 0\n+#  undef SQLITE_OS_WIN\n+#  define SQLITE_OS_WIN 0\n+#endif\n+#if SQLITE_OS_KV+1>1\n+#  undef SQLITE_OS_OTHER\n+#  define SQLITE_OS_OTHER 0\n+#  undef SQLITE_OS_UNIX\n+#  define SQLITE_OS_UNIX 0\n+#  undef SQLITE_OS_WIN\n+#  define SQLITE_OS_WIN 0\n+#  define SQLITE_OMIT_LOAD_EXTENSION 1\n+#  define SQLITE_OMIT_WAL 1\n+#  define SQLITE_OMIT_DEPRECATED 1\n+#  undef SQLITE_TEMP_STORE\n+#  define SQLITE_TEMP_STORE 3  \/* Always use memory for temporary storage *\/\n+#  define SQLITE_DQS 0\n+#  define SQLITE_OMIT_SHARED_CACHE 1\n+#  define SQLITE_OMIT_AUTOINIT 1\n+#endif\n+#if SQLITE_OS_UNIX+1>1\n+#  undef SQLITE_OS_KV\n+#  define SQLITE_OS_KV 0\n+#  undef SQLITE_OS_OTHER\n+#  define SQLITE_OS_OTHER 0\n+#  undef SQLITE_OS_WIN\n+#  define SQLITE_OS_WIN 0\n+#endif\n+#if SQLITE_OS_WIN+1>1\n+#  undef SQLITE_OS_KV\n+#  define SQLITE_OS_KV 0\n+#  undef SQLITE_OS_OTHER\n+#  define SQLITE_OS_OTHER 0\n+#  undef SQLITE_OS_UNIX\n+#  define SQLITE_OS_UNIX 0\n+#endif\n+\n+\n+#endif \/* SQLITE_OS_SETUP_H *\/\n+\n+\/************** End of os_setup.h ********************************************\/\n+\/************** Continuing where we left off in os.h *************************\/\n+\n+\/* If the SET_FULLSYNC macro is not defined above, then make it\n+** a no-op\n+*\/\n+#ifndef SET_FULLSYNC\n+# define SET_FULLSYNC(x,y)\n+#endif\n+\n+\/* Maximum pathname length.  Note: FILENAME_MAX defined by stdio.h\n+*\/\n+#ifndef SQLITE_MAX_PATHLEN\n+# define SQLITE_MAX_PATHLEN FILENAME_MAX\n+#endif\n+\n+\/* Maximum number of symlinks that will be resolved while trying to\n+** expand a filename in xFullPathname() in the VFS.\n+*\/\n+#ifndef SQLITE_MAX_SYMLINK\n+# define SQLITE_MAX_SYMLINK 200\n+#endif\n+\n+\/*\n+** The default size of a disk sector\n+*\/\n+#ifndef SQLITE_DEFAULT_SECTOR_SIZE\n+# define SQLITE_DEFAULT_SECTOR_SIZE 4096\n+#endif\n+\n+\/*\n+** Temporary files are named starting with this prefix followed by 16 random\n+** alphanumeric characters, and no file extension. They are stored in the\n+** OS's standard temporary file directory, and are deleted prior to exit.\n+** If sqlite is being embedded in another program, you may wish to change the\n+** prefix to reflect your program's name, so that if your program exits\n+** prematurely, old temporary files can be easily identified. This can be done\n+** using -DSQLITE_TEMP_FILE_PREFIX=myprefix_ on the compiler command line.\n+**\n+** 2006-10-31:  The default prefix used to be \"sqlite_\".  But then\n+** Mcafee started using SQLite in their anti-virus product and it\n+** started putting files with the \"sqlite\" name in the c:\/temp folder.\n+** This annoyed many windows users.  Those users would then do a\n+** Google search for \"sqlite\", find the telephone numbers of the\n+** developers and call to wake them up at night and complain.\n+** For this reason, the default name prefix is changed to be \"sqlite\"\n+** spelled backwards.  So the temp files are still identified, but\n+** anybody smart enough to figure out the code is also likely smart\n+** enough to know that calling the developer will not help get rid\n+** of the file.\n+*\/\n+#ifndef SQLITE_TEMP_FILE_PREFIX\n+# define SQLITE_TEMP_FILE_PREFIX \"etilqs_\"\n+#endif\n+\n+\/*\n+** The following values may be passed as the second argument to\n+** sqlite3OsLock(). The various locks exhibit the following semantics:\n+**\n+** SHARED:    Any number of processes may hold a SHARED lock simultaneously.\n+** RESERVED:  A single process may hold a RESERVED lock on a file at\n+**            any time. Other processes may hold and obtain new SHARED locks.\n+** PENDING:   A single process may hold a PENDING lock on a file at\n+**            any one time. Existing SHARED locks may persist, but no new\n+**            SHARED locks may be obtained by other processes.\n+** EXCLUSIVE: An EXCLUSIVE lock precludes all other locks.\n+**\n+** PENDING_LOCK may not be passed directly to sqlite3OsLock(). Instead, a\n+** process that requests an EXCLUSIVE lock may actually obtain a PENDING\n+** lock. This can be upgraded to an EXCLUSIVE lock by a subsequent call to\n+** sqlite3OsLock().\n+*\/\n+#define NO_LOCK         0\n+#define SHARED_LOCK     1\n+#define RESERVED_LOCK   2\n+#define PENDING_LOCK    3\n+#define EXCLUSIVE_LOCK  4\n+\n+\/*\n+** File Locking Notes:  (Mostly about windows but also some info for Unix)\n+**\n+** We cannot use LockFileEx() or UnlockFileEx() on Win95\/98\/ME because\n+** those functions are not available.  So we use only LockFile() and\n+** UnlockFile().\n+**\n+** LockFile() prevents not just writing but also reading by other processes.\n+** A SHARED_LOCK is obtained by locking a single randomly-chosen\n+** byte out of a specific range of bytes. The lock byte is obtained at\n+** random so two separate readers can probably access the file at the\n+** same time, unless they are unlucky and choose the same lock byte.\n+** An EXCLUSIVE_LOCK is obtained by locking all bytes in the range.\n+** There can only be one writer.  A RESERVED_LOCK is obtained by locking\n+** a single byte of the file that is designated as the reserved lock byte.\n+** A PENDING_LOCK is obtained by locking a designated byte different from\n+** the RESERVED_LOCK byte.\n+**\n+** On WinNT\/2K\/XP systems, LockFileEx() and UnlockFileEx() are available,\n+** which means we can use reader\/writer locks.  When reader\/writer locks\n+** are used, the lock is placed on the same range of bytes that is used\n+** for probabilistic locking in Win95\/98\/ME.  Hence, the locking scheme\n+** will support two or more Win95 readers or two or more WinNT readers.\n+** But a single Win95 reader will lock out all WinNT readers and a single\n+** WinNT reader will lock out all other Win95 readers.\n+**\n+** The following #defines specify the range of bytes used for locking.\n+** SHARED_SIZE is the number of bytes available in the pool from which\n+** a random byte is selected for a shared lock.  The pool of bytes for\n+** shared locks begins at SHARED_FIRST.\n+**\n+** The same locking strategy and\n+** byte ranges are used for Unix.  This leaves open the possibility of having\n+** clients on win95, winNT, and unix all talking to the same shared file\n+** and all locking correctly.  To do so would require that samba (or whatever\n+** tool is being used for file sharing) implements locks correctly between\n+** windows and unix.  I'm guessing that isn't likely to happen, but by\n+** using the same locking range we are at least open to the possibility.\n+**\n+** Locking in windows is manditory.  For this reason, we cannot store\n+** actual data in the bytes used for locking.  The pager never allocates\n+** the pages involved in locking therefore.  SHARED_SIZE is selected so\n+** that all locks will fit on a single page even at the minimum page size.\n+** PENDING_BYTE defines the beginning of the locks.  By default PENDING_BYTE\n+** is set high so that we don't have to allocate an unused page except\n+** for very large databases.  But one should test the page skipping logic\n+** by setting PENDING_BYTE low and running the entire regression suite.\n+**\n+** Changing the value of PENDING_BYTE results in a subtly incompatible\n+** file format.  Depending on how it is changed, you might not notice\n+** the incompatibility right away, even running a full regression test.\n+** The default location of PENDING_BYTE is the first byte past the\n+** 1GB boundary.\n+**\n+*\/\n+#ifdef SQLITE_OMIT_WSD\n+# define PENDING_BYTE     (0x40000000)\n+#else\n+# define PENDING_BYTE      sqlite3PendingByte\n+#endif\n+#define RESERVED_BYTE     (PENDING_BYTE+1)\n+#define SHARED_FIRST      (PENDING_BYTE+2)\n+#define SHARED_SIZE       510\n+\n+\/*\n+** Wrapper around OS specific sqlite3_os_init() function.\n+*\/\n+SQLITE_PRIVATE int sqlite3OsInit(void);\n+\n+\/*\n+** Functions for accessing sqlite3_file methods\n+*\/\n+SQLITE_PRIVATE void sqlite3OsClose(sqlite3_file*);\n+SQLITE_PRIVATE int sqlite3OsRead(sqlite3_file*, void*, int amt, i64 offset);\n+SQLITE_PRIVATE int sqlite3OsWrite(sqlite3_file*, const void*, int amt, i64 offset);\n+SQLITE_PRIVATE int sqlite3OsTruncate(sqlite3_file*, i64 size);\n+SQLITE_PRIVATE int sqlite3OsSync(sqlite3_file*, int);\n+SQLITE_PRIVATE int sqlite3OsFileSize(sqlite3_file*, i64 *pSize);\n+SQLITE_PRIVATE int sqlite3OsLock(sqlite3_file*, int);\n+SQLITE_PRIVATE int sqlite3OsUnlock(sqlite3_file*, int);\n+SQLITE_PRIVATE int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut);\n+SQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file*,int,void*);\n+SQLITE_PRIVATE void sqlite3OsFileControlHint(sqlite3_file*,int,void*);\n+#define SQLITE_FCNTL_DB_UNCHANGED 0xca093fa0\n+SQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id);\n+SQLITE_PRIVATE int sqlite3OsDeviceCharacteristics(sqlite3_file *id);\n+#ifndef SQLITE_OMIT_WAL\n+SQLITE_PRIVATE int sqlite3OsShmMap(sqlite3_file *,int,int,int,void volatile **);\n+SQLITE_PRIVATE int sqlite3OsShmLock(sqlite3_file *id, int, int, int);\n+SQLITE_PRIVATE void sqlite3OsShmBarrier(sqlite3_file *id);\n+SQLITE_PRIVATE int sqlite3OsShmUnmap(sqlite3_file *id, int);\n+#endif \/* SQLITE_OMIT_WAL *\/\n+SQLITE_PRIVATE int sqlite3OsFetch(sqlite3_file *id, i64, int, void **);\n+SQLITE_PRIVATE int sqlite3OsUnfetch(sqlite3_file *, i64, void *);\n+\n+\n+\/*\n+** Functions for accessing sqlite3_vfs methods\n+*\/\n+SQLITE_PRIVATE int sqlite3OsOpen(sqlite3_vfs *, const char *, sqlite3_file*, int, int *);\n+SQLITE_PRIVATE int sqlite3OsDelete(sqlite3_vfs *, const char *, int);\n+SQLITE_PRIVATE int sqlite3OsAccess(sqlite3_vfs *, const char *, int, int *pResOut);\n+SQLITE_PRIVATE int sqlite3OsFullPathname(sqlite3_vfs *, const char *, int, char *);\n+#ifndef SQLITE_OMIT_LOAD_EXTENSION\n+SQLITE_PRIVATE void *sqlite3OsDlOpen(sqlite3_vfs *, const char *);\n+SQLITE_PRIVATE void sqlite3OsDlError(sqlite3_vfs *, int, char *);\n+SQLITE_PRIVATE void (*sqlite3OsDlSym(sqlite3_vfs *, void *, const char *))(void);\n+SQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *, void *);\n+#endif \/* SQLITE_OMIT_LOAD_EXTENSION *\/\n+SQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *, int, char *);\n+SQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *, int);\n+SQLITE_PRIVATE int sqlite3OsGetLastError(sqlite3_vfs*);\n+SQLITE_PRIVATE int sqlite3OsCurrentTimeInt64(sqlite3_vfs *, sqlite3_int64*);\n+\n+\/*\n+** Convenience functions for opening and closing files using\n+** sqlite3_malloc() to obtain space for the file-handle structure.\n+*\/\n+SQLITE_PRIVATE int sqlite3OsOpenMalloc(sqlite3_vfs *, const char *, sqlite3_file **, int,int*);\n+SQLITE_PRIVATE void sqlite3OsCloseFree(sqlite3_file *);\n+\n+#endif \/* _SQLITE_OS_H_ *\/\n+\n+\/************** End of os.h **************************************************\/\n+\/************** Continuing where we left off in sqliteInt.h ******************\/\n@@ -14939,1 +15932,1 @@\n-SQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *, int, int, int *);\n+SQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *, int, int, u64*);\n@@ -14963,0 +15956,4 @@\n+#if defined(SQLITE_USE_SEH) && !defined(SQLITE_OMIT_WAL)\n+SQLITE_PRIVATE int sqlite3PagerWalSystemErrno(Pager*);\n+#endif\n+\n@@ -15154,1 +16151,1 @@\n-** standard SQLite.  The other hints are provided for extentions that use\n+** standard SQLite.  The other hints are provided for extensions that use\n@@ -15292,1 +16289,0 @@\n-#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC\n@@ -15294,1 +16290,0 @@\n-#endif\n@@ -15300,1 +16295,9 @@\n-SQLITE_PRIVATE char *sqlite3BtreeIntegrityCheck(sqlite3*,Btree*,Pgno*aRoot,int nRoot,int,int*);\n+SQLITE_PRIVATE int sqlite3BtreeIntegrityCheck(\n+  sqlite3 *db,  \/* Database connection that is running the check *\/\n+  Btree *p,     \/* The btree to be checked *\/\n+  Pgno *aRoot,  \/* An array of root pages numbers for individual trees *\/\n+  int nRoot,    \/* Number of entries in aRoot[] *\/\n+  int mxErr,    \/* Stop reporting errors after this many *\/\n+  int *pnErr,   \/* OUT: Write number of errors seen to this variable *\/\n+  char **pzOut  \/* OUT: Write the error message string here *\/\n+);\n@@ -15339,0 +16342,2 @@\n+SQLITE_PRIVATE void sqlite3BtreeClearCache(Btree*);\n+\n@@ -15455,4 +16460,0 @@\n-#ifdef VDBE_PROFILE\n-  u32 cnt;                 \/* Number of times this instruction was executed *\/\n-  u64 cycles;              \/* Total time spent executing this instruction *\/\n-#endif\n@@ -15463,0 +16464,4 @@\n+#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || defined(VDBE_PROFILE)\n+  u64 nExec;\n+  u64 nCycle;\n+#endif\n@@ -15514,0 +16519,1 @@\n+#define P4_TABLEREF   (-16) \/* Like P4_TABLE, but reference counted *\/\n@@ -15563,11 +16569,11 @@\n-#define OP_Goto            8 \/* jump                                       *\/\n-#define OP_Gosub           9 \/* jump                                       *\/\n-#define OP_InitCoroutine  10 \/* jump                                       *\/\n-#define OP_Yield          11 \/* jump                                       *\/\n-#define OP_MustBeInt      12 \/* jump                                       *\/\n-#define OP_Jump           13 \/* jump                                       *\/\n-#define OP_Once           14 \/* jump                                       *\/\n-#define OP_If             15 \/* jump                                       *\/\n-#define OP_IfNot          16 \/* jump                                       *\/\n-#define OP_IsNullOrType   17 \/* jump, synopsis: if typeof(r[P1]) IN (P3,5) goto P2 *\/\n-#define OP_IfNullRow      18 \/* jump, synopsis: if P1.nullRow then r[P3]=NULL, goto P2 *\/\n+#define OP_Init            8 \/* jump, synopsis: Start at P2                *\/\n+#define OP_Goto            9 \/* jump                                       *\/\n+#define OP_Gosub          10 \/* jump                                       *\/\n+#define OP_InitCoroutine  11 \/* jump                                       *\/\n+#define OP_Yield          12 \/* jump                                       *\/\n+#define OP_MustBeInt      13 \/* jump                                       *\/\n+#define OP_Jump           14 \/* jump                                       *\/\n+#define OP_Once           15 \/* jump                                       *\/\n+#define OP_If             16 \/* jump                                       *\/\n+#define OP_IfNot          17 \/* jump                                       *\/\n+#define OP_IsType         18 \/* jump, synopsis: if typeof(P1.P3) in P5 goto P2 *\/\n@@ -15575,23 +16581,23 @@\n-#define OP_SeekLT         20 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_SeekLE         21 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_SeekGE         22 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_SeekGT         23 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_IfNotOpen      24 \/* jump, synopsis: if( !csr[P1] ) goto P2     *\/\n-#define OP_IfNoHope       25 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_NoConflict     26 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_NotFound       27 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_Found          28 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_SeekRowid      29 \/* jump, synopsis: intkey=r[P3]               *\/\n-#define OP_NotExists      30 \/* jump, synopsis: intkey=r[P3]               *\/\n-#define OP_Last           31 \/* jump                                       *\/\n-#define OP_IfSmaller      32 \/* jump                                       *\/\n-#define OP_SorterSort     33 \/* jump                                       *\/\n-#define OP_Sort           34 \/* jump                                       *\/\n-#define OP_Rewind         35 \/* jump                                       *\/\n-#define OP_SorterNext     36 \/* jump                                       *\/\n-#define OP_Prev           37 \/* jump                                       *\/\n-#define OP_Next           38 \/* jump                                       *\/\n-#define OP_IdxLE          39 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_IdxGT          40 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_IdxLT          41 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_IdxGE          42 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_IfNullRow      20 \/* jump, synopsis: if P1.nullRow then r[P3]=NULL, goto P2 *\/\n+#define OP_SeekLT         21 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_SeekLE         22 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_SeekGE         23 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_SeekGT         24 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_IfNotOpen      25 \/* jump, synopsis: if( !csr[P1] ) goto P2     *\/\n+#define OP_IfNoHope       26 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_NoConflict     27 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_NotFound       28 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_Found          29 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_SeekRowid      30 \/* jump, synopsis: intkey=r[P3]               *\/\n+#define OP_NotExists      31 \/* jump, synopsis: intkey=r[P3]               *\/\n+#define OP_Last           32 \/* jump                                       *\/\n+#define OP_IfSmaller      33 \/* jump                                       *\/\n+#define OP_SorterSort     34 \/* jump                                       *\/\n+#define OP_Sort           35 \/* jump                                       *\/\n+#define OP_Rewind         36 \/* jump                                       *\/\n+#define OP_SorterNext     37 \/* jump                                       *\/\n+#define OP_Prev           38 \/* jump                                       *\/\n+#define OP_Next           39 \/* jump                                       *\/\n+#define OP_IdxLE          40 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_IdxGT          41 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_IdxLT          42 \/* jump, synopsis: key=r[P3@P4]               *\/\n@@ -15600,5 +16606,5 @@\n-#define OP_RowSetRead     45 \/* jump, synopsis: r[P3]=rowset(P1)           *\/\n-#define OP_RowSetTest     46 \/* jump, synopsis: if r[P3] in rowset(P1) goto P2 *\/\n-#define OP_Program        47 \/* jump                                       *\/\n-#define OP_FkIfZero       48 \/* jump, synopsis: if fkctr[P1]==0 goto P2    *\/\n-#define OP_IfPos          49 \/* jump, synopsis: if r[P1]>0 then r[P1]-=P3, goto P2 *\/\n+#define OP_IdxGE          45 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_RowSetRead     46 \/* jump, synopsis: r[P3]=rowset(P1)           *\/\n+#define OP_RowSetTest     47 \/* jump, synopsis: if r[P3] in rowset(P1) goto P2 *\/\n+#define OP_Program        48 \/* jump                                       *\/\n+#define OP_FkIfZero       49 \/* jump, synopsis: if fkctr[P1]==0 goto P2    *\/\n@@ -15614,6 +16620,6 @@\n-#define OP_IfNotZero      59 \/* jump, synopsis: if r[P1]!=0 then r[P1]--, goto P2 *\/\n-#define OP_DecrJumpZero   60 \/* jump, synopsis: if (--r[P1])==0 goto P2    *\/\n-#define OP_IncrVacuum     61 \/* jump                                       *\/\n-#define OP_VNext          62 \/* jump                                       *\/\n-#define OP_Filter         63 \/* jump, synopsis: if key(P3@P4) not in filter(P1) goto P2 *\/\n-#define OP_Init           64 \/* jump, synopsis: Start at P2                *\/\n+#define OP_IfPos          59 \/* jump, synopsis: if r[P1]>0 then r[P1]-=P3, goto P2 *\/\n+#define OP_IfNotZero      60 \/* jump, synopsis: if r[P1]!=0 then r[P1]--, goto P2 *\/\n+#define OP_DecrJumpZero   61 \/* jump, synopsis: if (--r[P1])==0 goto P2    *\/\n+#define OP_IncrVacuum     62 \/* jump                                       *\/\n+#define OP_VNext          63 \/* jump                                       *\/\n+#define OP_Filter         64 \/* jump, synopsis: if key(P3@P4) not in filter(P1) goto P2 *\/\n@@ -15729,13 +16735,16 @@\n-#define OP_VInitIn       174 \/* synopsis: r[P2]=ValueList(P1,P3)           *\/\n-#define OP_VColumn       175 \/* synopsis: r[P3]=vcolumn(P2)                *\/\n-#define OP_VRename       176\n-#define OP_Pagecount     177\n-#define OP_MaxPgcnt      178\n-#define OP_ClrSubtype    179 \/* synopsis: r[P1].subtype = 0                *\/\n-#define OP_FilterAdd     180 \/* synopsis: filter(P1) += key(P3@P4)         *\/\n-#define OP_Trace         181\n-#define OP_CursorHint    182\n-#define OP_ReleaseReg    183 \/* synopsis: release r[P1@P2] mask P3         *\/\n-#define OP_Noop          184\n-#define OP_Explain       185\n-#define OP_Abortable     186\n+#define OP_VCheck        174\n+#define OP_VInitIn       175 \/* synopsis: r[P2]=ValueList(P1,P3)           *\/\n+#define OP_VColumn       176 \/* synopsis: r[P3]=vcolumn(P2)                *\/\n+#define OP_VRename       177\n+#define OP_Pagecount     178\n+#define OP_MaxPgcnt      179\n+#define OP_ClrSubtype    180 \/* synopsis: r[P1].subtype = 0                *\/\n+#define OP_GetSubtype    181 \/* synopsis: r[P2] = r[P1].subtype            *\/\n+#define OP_SetSubtype    182 \/* synopsis: r[P2].subtype = r[P1]            *\/\n+#define OP_FilterAdd     183 \/* synopsis: filter(P1) += key(P3@P4)         *\/\n+#define OP_Trace         184\n+#define OP_CursorHint    185\n+#define OP_ReleaseReg    186 \/* synopsis: release r[P1@P2] mask P3         *\/\n+#define OP_Noop          187\n+#define OP_Explain       188\n+#define OP_Abortable     189\n@@ -15753,0 +16762,1 @@\n+#define OPFLG_NCYCLE      0x40  \/* ncycle:Cycles count against P1 *\/\n@@ -15754,8 +16764,8 @@\n-\/*   0 *\/ 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x01, 0x00,\\\n-\/*   8 *\/ 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x03,\\\n-\/*  16 *\/ 0x03, 0x03, 0x01, 0x12, 0x09, 0x09, 0x09, 0x09,\\\n-\/*  24 *\/ 0x01, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x01,\\\n-\/*  32 *\/ 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\\\n-\/*  40 *\/ 0x01, 0x01, 0x01, 0x26, 0x26, 0x23, 0x0b, 0x01,\\\n-\/*  48 *\/ 0x01, 0x03, 0x03, 0x03, 0x0b, 0x0b, 0x0b, 0x0b,\\\n-\/*  56 *\/ 0x0b, 0x0b, 0x01, 0x03, 0x03, 0x01, 0x01, 0x01,\\\n+\/*   0 *\/ 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x41, 0x00,\\\n+\/*   8 *\/ 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01,\\\n+\/*  16 *\/ 0x03, 0x03, 0x01, 0x12, 0x01, 0x49, 0x49, 0x49,\\\n+\/*  24 *\/ 0x49, 0x01, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,\\\n+\/*  32 *\/ 0x41, 0x01, 0x41, 0x41, 0x41, 0x01, 0x41, 0x41,\\\n+\/*  40 *\/ 0x41, 0x41, 0x41, 0x26, 0x26, 0x41, 0x23, 0x0b,\\\n+\/*  48 *\/ 0x01, 0x01, 0x03, 0x03, 0x0b, 0x0b, 0x0b, 0x0b,\\\n+\/*  56 *\/ 0x0b, 0x0b, 0x01, 0x03, 0x03, 0x03, 0x01, 0x41,\\\n@@ -15765,2 +16775,2 @@\n-\/*  88 *\/ 0x02, 0x00, 0x00, 0x12, 0x1e, 0x20, 0x00, 0x00,\\\n-\/*  96 *\/ 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x26, 0x26,\\\n+\/*  88 *\/ 0x02, 0x00, 0x00, 0x12, 0x1e, 0x20, 0x40, 0x00,\\\n+\/*  96 *\/ 0x00, 0x00, 0x10, 0x10, 0x00, 0x40, 0x26, 0x26,\\\n@@ -15768,4 +16778,4 @@\n-\/* 112 *\/ 0x00, 0x00, 0x12, 0x00, 0x00, 0x10, 0x00, 0x00,\\\n-\/* 120 *\/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10,\\\n-\/* 128 *\/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,\\\n-\/* 136 *\/ 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x10, 0x00,\\\n+\/* 112 *\/ 0x40, 0x00, 0x12, 0x40, 0x40, 0x10, 0x40, 0x00,\\\n+\/* 120 *\/ 0x00, 0x00, 0x40, 0x00, 0x40, 0x40, 0x10, 0x10,\\\n+\/* 128 *\/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x50,\\\n+\/* 136 *\/ 0x00, 0x40, 0x04, 0x04, 0x00, 0x40, 0x50, 0x40,\\\n@@ -15775,3 +16785,3 @@\n-\/* 168 *\/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,\\\n-\/* 176 *\/ 0x00, 0x10, 0x10, 0x02, 0x00, 0x00, 0x00, 0x00,\\\n-\/* 184 *\/ 0x00, 0x00, 0x00,}\n+\/* 168 *\/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x10, 0x50,\\\n+\/* 176 *\/ 0x40, 0x00, 0x10, 0x10, 0x02, 0x12, 0x12, 0x00,\\\n+\/* 184 *\/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,}\n@@ -15830,1 +16840,1 @@\n-SQLITE_PRIVATE   void sqlite3VdbeExplain(Parse*,u8,const char*,...);\n+SQLITE_PRIVATE   int sqlite3VdbeExplain(Parse*,u8,const char*,...);\n@@ -15834,0 +16844,5 @@\n+# ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n+#  define ExplainQueryPlan2(V,P)     (V = sqlite3VdbeExplain P)\n+# else\n+#  define ExplainQueryPlan2(V,P)     ExplainQueryPlan(P)\n+# endif\n@@ -15838,0 +16853,1 @@\n+# define ExplainQueryPlan2(V,P)\n@@ -15853,0 +16869,1 @@\n+SQLITE_PRIVATE void sqlite3VdbeTypeofColumn(Vdbe*, int);\n@@ -15867,0 +16884,1 @@\n+SQLITE_PRIVATE VdbeOp *sqlite3VdbeGetLastOp(Vdbe*);\n@@ -15944,1 +16962,1 @@\n-** only works with an amalagmation build.  That's ok since a VDBE branch\n+** only works with an amalgamation build.  That's ok since a VDBE branch\n@@ -15962,1 +16980,1 @@\n-**                                     \/\/ in distingishing equal and not-equal.\n+**                                     \/\/ in distinguishing equal and not-equal.\n@@ -15972,1 +16990,1 @@\n-** contains the sqlite3.c source line number ov the VdbeCoverage macro and\n+** contains the sqlite3.c source line number of the VdbeCoverage macro and\n@@ -16008,0 +17026,2 @@\n+SQLITE_PRIVATE void sqlite3VdbeScanStatusRange(Vdbe*, int, int, int);\n+SQLITE_PRIVATE void sqlite3VdbeScanStatusCounters(Vdbe*, int, int, int);\n@@ -16009,1 +17029,3 @@\n-# define sqlite3VdbeScanStatus(a,b,c,d,e)\n+# define sqlite3VdbeScanStatus(a,b,c,d,e,f)\n+# define sqlite3VdbeScanStatusRange(a,b,c,d)\n+# define sqlite3VdbeScanStatusCounters(a,b,c,d)\n@@ -16016,0 +17038,4 @@\n+#if defined(SQLITE_ENABLE_CURSOR_HINTS) && defined(SQLITE_DEBUG)\n+SQLITE_PRIVATE int sqlite3CursorRangeHintExprCheck(Walker *pWalker, Expr *pExpr);\n+#endif\n+\n@@ -16064,1 +17090,1 @@\n-  i16 nRef;                      \/* Number of users of this page *\/\n+  i64 nRef;                      \/* Number of users of this page *\/\n@@ -16145,1 +17171,1 @@\n-SQLITE_PRIVATE int sqlite3PcacheRefCount(PCache*);\n+SQLITE_PRIVATE i64 sqlite3PcacheRefCount(PCache*);\n@@ -16150,1 +17176,1 @@\n-SQLITE_PRIVATE int sqlite3PcachePageRefcount(PgHdr*);\n+SQLITE_PRIVATE i64 sqlite3PcachePageRefcount(PgHdr*);\n@@ -16215,291 +17241,0 @@\n-\/************** Include os.h in the middle of sqliteInt.h ********************\/\n-\/************** Begin file os.h **********************************************\/\n-\/*\n-** 2001 September 16\n-**\n-** The author disclaims copyright to this source code.  In place of\n-** a legal notice, here is a blessing:\n-**\n-**    May you do good and not evil.\n-**    May you find forgiveness for yourself and forgive others.\n-**    May you share freely, never taking more than you give.\n-**\n-******************************************************************************\n-**\n-** This header file (together with is companion C source-code file\n-** \"os.c\") attempt to abstract the underlying operating system so that\n-** the SQLite library will work on both POSIX and windows systems.\n-**\n-** This header file is #include-ed by sqliteInt.h and thus ends up\n-** being included by every source file.\n-*\/\n-#ifndef _SQLITE_OS_H_\n-#define _SQLITE_OS_H_\n-\n-\/*\n-** Attempt to automatically detect the operating system and setup the\n-** necessary pre-processor macros for it.\n-*\/\n-\/************** Include os_setup.h in the middle of os.h *********************\/\n-\/************** Begin file os_setup.h ****************************************\/\n-\/*\n-** 2013 November 25\n-**\n-** The author disclaims copyright to this source code.  In place of\n-** a legal notice, here is a blessing:\n-**\n-**    May you do good and not evil.\n-**    May you find forgiveness for yourself and forgive others.\n-**    May you share freely, never taking more than you give.\n-**\n-******************************************************************************\n-**\n-** This file contains pre-processor directives related to operating system\n-** detection and\/or setup.\n-*\/\n-#ifndef SQLITE_OS_SETUP_H\n-#define SQLITE_OS_SETUP_H\n-\n-\/*\n-** Figure out if we are dealing with Unix, Windows, or some other operating\n-** system.\n-**\n-** After the following block of preprocess macros, all of SQLITE_OS_UNIX,\n-** SQLITE_OS_WIN, and SQLITE_OS_OTHER will defined to either 1 or 0.  One of\n-** the three will be 1.  The other two will be 0.\n-*\/\n-#if defined(SQLITE_OS_OTHER)\n-#  if SQLITE_OS_OTHER==1\n-#    undef SQLITE_OS_UNIX\n-#    define SQLITE_OS_UNIX 0\n-#    undef SQLITE_OS_WIN\n-#    define SQLITE_OS_WIN 0\n-#  else\n-#    undef SQLITE_OS_OTHER\n-#  endif\n-#endif\n-#if !defined(SQLITE_OS_UNIX) && !defined(SQLITE_OS_OTHER)\n-#  define SQLITE_OS_OTHER 0\n-#  ifndef SQLITE_OS_WIN\n-#    if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || \\\n-        defined(__MINGW32__) || defined(__BORLANDC__)\n-#      define SQLITE_OS_WIN 1\n-#      define SQLITE_OS_UNIX 0\n-#    else\n-#      define SQLITE_OS_WIN 0\n-#      define SQLITE_OS_UNIX 1\n-#    endif\n-#  else\n-#    define SQLITE_OS_UNIX 0\n-#  endif\n-#else\n-#  ifndef SQLITE_OS_WIN\n-#    define SQLITE_OS_WIN 0\n-#  endif\n-#endif\n-\n-#endif \/* SQLITE_OS_SETUP_H *\/\n-\n-\/************** End of os_setup.h ********************************************\/\n-\/************** Continuing where we left off in os.h *************************\/\n-\n-\/* If the SET_FULLSYNC macro is not defined above, then make it\n-** a no-op\n-*\/\n-#ifndef SET_FULLSYNC\n-# define SET_FULLSYNC(x,y)\n-#endif\n-\n-\/* Maximum pathname length.  Note: FILENAME_MAX defined by stdio.h\n-*\/\n-#ifndef SQLITE_MAX_PATHLEN\n-# define SQLITE_MAX_PATHLEN FILENAME_MAX\n-#endif\n-\n-\/* Maximum number of symlinks that will be resolved while trying to\n-** expand a filename in xFullPathname() in the VFS.\n-*\/\n-#ifndef SQLITE_MAX_SYMLINK\n-# define SQLITE_MAX_SYMLINK 200\n-#endif\n-\n-\/*\n-** The default size of a disk sector\n-*\/\n-#ifndef SQLITE_DEFAULT_SECTOR_SIZE\n-# define SQLITE_DEFAULT_SECTOR_SIZE 4096\n-#endif\n-\n-\/*\n-** Temporary files are named starting with this prefix followed by 16 random\n-** alphanumeric characters, and no file extension. They are stored in the\n-** OS's standard temporary file directory, and are deleted prior to exit.\n-** If sqlite is being embedded in another program, you may wish to change the\n-** prefix to reflect your program's name, so that if your program exits\n-** prematurely, old temporary files can be easily identified. This can be done\n-** using -DSQLITE_TEMP_FILE_PREFIX=myprefix_ on the compiler command line.\n-**\n-** 2006-10-31:  The default prefix used to be \"sqlite_\".  But then\n-** Mcafee started using SQLite in their anti-virus product and it\n-** started putting files with the \"sqlite\" name in the c:\/temp folder.\n-** This annoyed many windows users.  Those users would then do a\n-** Google search for \"sqlite\", find the telephone numbers of the\n-** developers and call to wake them up at night and complain.\n-** For this reason, the default name prefix is changed to be \"sqlite\"\n-** spelled backwards.  So the temp files are still identified, but\n-** anybody smart enough to figure out the code is also likely smart\n-** enough to know that calling the developer will not help get rid\n-** of the file.\n-*\/\n-#ifndef SQLITE_TEMP_FILE_PREFIX\n-# define SQLITE_TEMP_FILE_PREFIX \"etilqs_\"\n-#endif\n-\n-\/*\n-** The following values may be passed as the second argument to\n-** sqlite3OsLock(). The various locks exhibit the following semantics:\n-**\n-** SHARED:    Any number of processes may hold a SHARED lock simultaneously.\n-** RESERVED:  A single process may hold a RESERVED lock on a file at\n-**            any time. Other processes may hold and obtain new SHARED locks.\n-** PENDING:   A single process may hold a PENDING lock on a file at\n-**            any one time. Existing SHARED locks may persist, but no new\n-**            SHARED locks may be obtained by other processes.\n-** EXCLUSIVE: An EXCLUSIVE lock precludes all other locks.\n-**\n-** PENDING_LOCK may not be passed directly to sqlite3OsLock(). Instead, a\n-** process that requests an EXCLUSIVE lock may actually obtain a PENDING\n-** lock. This can be upgraded to an EXCLUSIVE lock by a subsequent call to\n-** sqlite3OsLock().\n-*\/\n-#define NO_LOCK         0\n-#define SHARED_LOCK     1\n-#define RESERVED_LOCK   2\n-#define PENDING_LOCK    3\n-#define EXCLUSIVE_LOCK  4\n-\n-\/*\n-** File Locking Notes:  (Mostly about windows but also some info for Unix)\n-**\n-** We cannot use LockFileEx() or UnlockFileEx() on Win95\/98\/ME because\n-** those functions are not available.  So we use only LockFile() and\n-** UnlockFile().\n-**\n-** LockFile() prevents not just writing but also reading by other processes.\n-** A SHARED_LOCK is obtained by locking a single randomly-chosen\n-** byte out of a specific range of bytes. The lock byte is obtained at\n-** random so two separate readers can probably access the file at the\n-** same time, unless they are unlucky and choose the same lock byte.\n-** An EXCLUSIVE_LOCK is obtained by locking all bytes in the range.\n-** There can only be one writer.  A RESERVED_LOCK is obtained by locking\n-** a single byte of the file that is designated as the reserved lock byte.\n-** A PENDING_LOCK is obtained by locking a designated byte different from\n-** the RESERVED_LOCK byte.\n-**\n-** On WinNT\/2K\/XP systems, LockFileEx() and UnlockFileEx() are available,\n-** which means we can use reader\/writer locks.  When reader\/writer locks\n-** are used, the lock is placed on the same range of bytes that is used\n-** for probabilistic locking in Win95\/98\/ME.  Hence, the locking scheme\n-** will support two or more Win95 readers or two or more WinNT readers.\n-** But a single Win95 reader will lock out all WinNT readers and a single\n-** WinNT reader will lock out all other Win95 readers.\n-**\n-** The following #defines specify the range of bytes used for locking.\n-** SHARED_SIZE is the number of bytes available in the pool from which\n-** a random byte is selected for a shared lock.  The pool of bytes for\n-** shared locks begins at SHARED_FIRST.\n-**\n-** The same locking strategy and\n-** byte ranges are used for Unix.  This leaves open the possibility of having\n-** clients on win95, winNT, and unix all talking to the same shared file\n-** and all locking correctly.  To do so would require that samba (or whatever\n-** tool is being used for file sharing) implements locks correctly between\n-** windows and unix.  I'm guessing that isn't likely to happen, but by\n-** using the same locking range we are at least open to the possibility.\n-**\n-** Locking in windows is manditory.  For this reason, we cannot store\n-** actual data in the bytes used for locking.  The pager never allocates\n-** the pages involved in locking therefore.  SHARED_SIZE is selected so\n-** that all locks will fit on a single page even at the minimum page size.\n-** PENDING_BYTE defines the beginning of the locks.  By default PENDING_BYTE\n-** is set high so that we don't have to allocate an unused page except\n-** for very large databases.  But one should test the page skipping logic\n-** by setting PENDING_BYTE low and running the entire regression suite.\n-**\n-** Changing the value of PENDING_BYTE results in a subtly incompatible\n-** file format.  Depending on how it is changed, you might not notice\n-** the incompatibility right away, even running a full regression test.\n-** The default location of PENDING_BYTE is the first byte past the\n-** 1GB boundary.\n-**\n-*\/\n-#ifdef SQLITE_OMIT_WSD\n-# define PENDING_BYTE     (0x40000000)\n-#else\n-# define PENDING_BYTE      sqlite3PendingByte\n-#endif\n-#define RESERVED_BYTE     (PENDING_BYTE+1)\n-#define SHARED_FIRST      (PENDING_BYTE+2)\n-#define SHARED_SIZE       510\n-\n-\/*\n-** Wrapper around OS specific sqlite3_os_init() function.\n-*\/\n-SQLITE_PRIVATE int sqlite3OsInit(void);\n-\n-\/*\n-** Functions for accessing sqlite3_file methods\n-*\/\n-SQLITE_PRIVATE void sqlite3OsClose(sqlite3_file*);\n-SQLITE_PRIVATE int sqlite3OsRead(sqlite3_file*, void*, int amt, i64 offset);\n-SQLITE_PRIVATE int sqlite3OsWrite(sqlite3_file*, const void*, int amt, i64 offset);\n-SQLITE_PRIVATE int sqlite3OsTruncate(sqlite3_file*, i64 size);\n-SQLITE_PRIVATE int sqlite3OsSync(sqlite3_file*, int);\n-SQLITE_PRIVATE int sqlite3OsFileSize(sqlite3_file*, i64 *pSize);\n-SQLITE_PRIVATE int sqlite3OsLock(sqlite3_file*, int);\n-SQLITE_PRIVATE int sqlite3OsUnlock(sqlite3_file*, int);\n-SQLITE_PRIVATE int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut);\n-SQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file*,int,void*);\n-SQLITE_PRIVATE void sqlite3OsFileControlHint(sqlite3_file*,int,void*);\n-#define SQLITE_FCNTL_DB_UNCHANGED 0xca093fa0\n-SQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id);\n-SQLITE_PRIVATE int sqlite3OsDeviceCharacteristics(sqlite3_file *id);\n-#ifndef SQLITE_OMIT_WAL\n-SQLITE_PRIVATE int sqlite3OsShmMap(sqlite3_file *,int,int,int,void volatile **);\n-SQLITE_PRIVATE int sqlite3OsShmLock(sqlite3_file *id, int, int, int);\n-SQLITE_PRIVATE void sqlite3OsShmBarrier(sqlite3_file *id);\n-SQLITE_PRIVATE int sqlite3OsShmUnmap(sqlite3_file *id, int);\n-#endif \/* SQLITE_OMIT_WAL *\/\n-SQLITE_PRIVATE int sqlite3OsFetch(sqlite3_file *id, i64, int, void **);\n-SQLITE_PRIVATE int sqlite3OsUnfetch(sqlite3_file *, i64, void *);\n-\n-\n-\/*\n-** Functions for accessing sqlite3_vfs methods\n-*\/\n-SQLITE_PRIVATE int sqlite3OsOpen(sqlite3_vfs *, const char *, sqlite3_file*, int, int *);\n-SQLITE_PRIVATE int sqlite3OsDelete(sqlite3_vfs *, const char *, int);\n-SQLITE_PRIVATE int sqlite3OsAccess(sqlite3_vfs *, const char *, int, int *pResOut);\n-SQLITE_PRIVATE int sqlite3OsFullPathname(sqlite3_vfs *, const char *, int, char *);\n-#ifndef SQLITE_OMIT_LOAD_EXTENSION\n-SQLITE_PRIVATE void *sqlite3OsDlOpen(sqlite3_vfs *, const char *);\n-SQLITE_PRIVATE void sqlite3OsDlError(sqlite3_vfs *, int, char *);\n-SQLITE_PRIVATE void (*sqlite3OsDlSym(sqlite3_vfs *, void *, const char *))(void);\n-SQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *, void *);\n-#endif \/* SQLITE_OMIT_LOAD_EXTENSION *\/\n-SQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *, int, char *);\n-SQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *, int);\n-SQLITE_PRIVATE int sqlite3OsGetLastError(sqlite3_vfs*);\n-SQLITE_PRIVATE int sqlite3OsCurrentTimeInt64(sqlite3_vfs *, sqlite3_int64*);\n-\n-\/*\n-** Convenience functions for opening and closing files using\n-** sqlite3_malloc() to obtain space for the file-handle structure.\n-*\/\n-SQLITE_PRIVATE int sqlite3OsOpenMalloc(sqlite3_vfs *, const char *, sqlite3_file **, int,int*);\n-SQLITE_PRIVATE void sqlite3OsCloseFree(sqlite3_file *);\n-\n-#endif \/* _SQLITE_OS_H_ *\/\n-\n-\/************** End of os.h **************************************************\/\n-\/************** Continuing where we left off in sqliteInt.h ******************\/\n@@ -16594,1 +17329,1 @@\n-** Note that (for historcal reasons) the PAGER_SYNCHRONOUS_* macros differ\n+** Note that (for historical reasons) the PAGER_SYNCHRONOUS_* macros differ\n@@ -16633,1 +17368,1 @@\n-** the Schema for the TEMP databaes (sqlite3.aDb[1]) which is free-standing.\n+** the Schema for the TEMP database (sqlite3.aDb[1]) which is free-standing.\n@@ -16744,1 +17479,1 @@\n-  LookasideSlot *pSmallInit; \/* List of small buffers not prediously used *\/\n+  LookasideSlot *pSmallInit; \/* List of small buffers not previously used *\/\n@@ -16751,0 +17486,1 @@\n+  void *pTrueEnd;         \/* True value of pEnd, when db->pnBytesFreed!=0 *\/\n@@ -16760,1 +17496,1 @@\n-\/* Size of the smaller allocations in two-size lookside *\/\n+\/* Size of the smaller allocations in two-size lookaside *\/\n@@ -16960,0 +17696,1 @@\n+  DbClientData *pDbData;        \/* sqlite3_set_clientdata() content *\/\n@@ -17015,1 +17752,1 @@\n-#define SQLITE_ReadUncommit   0x00000400  \/* READ UNCOMMITTED in shared-cache *\/\n+#define SQLITE_StmtScanStatus 0x00000400  \/* Enable stmt_scanstats() counters *\/\n@@ -17041,0 +17778,2 @@\n+#define SQLITE_ReadUncommit   HI(0x00004) \/* READ UNCOMMITTED in shared-cache *\/\n+#define SQLITE_FkNoAction     HI(0x00008) \/* Treat all FK as NO ACTION *\/\n@@ -17095,0 +17834,4 @@\n+#define SQLITE_IndexedExpr    0x01000000 \/* Pull exprs from index when able *\/\n+#define SQLITE_Coroutines     0x02000000 \/* Co-routines for subqueries *\/\n+#define SQLITE_NullUnusedCols 0x04000000 \/* NULL unused columns in subqueries *\/\n+#define SQLITE_OnePass        0x08000000 \/* Single-pass DELETE and UPDATE *\/\n@@ -17177,0 +17920,1 @@\n+**     SQLITE_FUNC_BYTELEN     ==  OPFLAG_BYTELENARG\n@@ -17179,1 +17923,1 @@\n-**     SQLITE_FUNC_UNSAFE      ==  SQLITE_INNOCUOUS\n+**     SQLITE_FUNC_UNSAFE      ==  SQLITE_INNOCUOUS  -- opposite meanings!!!\n@@ -17181,0 +17925,6 @@\n+**\n+** Note that even though SQLITE_FUNC_UNSAFE and SQLITE_INNOCUOUS have the\n+** same bit value, their meanings are inverted.  SQLITE_FUNC_UNSAFE is\n+** used internally and if set means that the function has side effects.\n+** SQLITE_INNOCUOUS is used by application code and means \"not unsafe\".\n+** See multiple instances of tag-20230109-1.\n@@ -17189,0 +17939,1 @@\n+#define SQLITE_FUNC_BYTELEN  0x00c0 \/* Built-in octet_length() function *\/\n@@ -17197,1 +17948,1 @@\n-\/*                           0x8000 -- available for reuse *\/\n+#define SQLITE_FUNC_RUNONLY  0x8000 \/* Cannot be used by valueFromFunction *\/\n@@ -17201,1 +17952,1 @@\n-#define SQLITE_FUNC_SUBTYPE  0x00100000 \/* Result likely to have sub-type *\/\n+\/* SQLITE_SUBTYPE            0x00100000 \/\/ Consumer of subtypes *\/\n@@ -17205,0 +17956,1 @@\n+\/*  SQLITE_RESULT_SUBTYPE    0x01000000 \/\/ Generator of subtypes *\/\n@@ -17296,4 +18048,5 @@\n-#define JFUNCTION(zName, nArg, iArg, xFunc) \\\n-  {nArg, SQLITE_FUNC_BUILTIN|SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS|\\\n-   SQLITE_FUNC_CONSTANT|SQLITE_UTF8, \\\n-   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, 0, #zName, {0} }\n+#define JFUNCTION(zName, nArg, bUseCache, bWS, bRS, bJsonB, iArg, xFunc) \\\n+  {nArg, SQLITE_FUNC_BUILTIN|SQLITE_DETERMINISTIC|SQLITE_FUNC_CONSTANT|\\\n+   SQLITE_UTF8|((bUseCache)*SQLITE_FUNC_RUNONLY)|\\\n+   ((bRS)*SQLITE_SUBTYPE)|((bWS)*SQLITE_RESULT_SUBTYPE), \\\n+   SQLITE_INT_TO_PTR(iArg|((bJsonB)*JSON_BLOB)),0,xFunc,0, 0, 0, #zName, {0} }\n@@ -17489,0 +18242,1 @@\n+#define SQLITE_AFF_FLEXNUM  0x46  \/* 'F' *\/\n@@ -17559,0 +18313,1 @@\n+  u8 bAllSchemas;           \/* True if might use any attached schema *\/\n@@ -17667,1 +18422,1 @@\n-    ((X)->op==TK_COLUMN && (X)->y.pTab!=0 && (X)->y.pTab->eTabType==TABTYP_VTAB)\n+   ((X)->op==TK_COLUMN && (X)->y.pTab->eTabType==TABTYP_VTAB)\n@@ -17695,0 +18450,9 @@\n+\/* Macro is true if the SQLITE_ALLOW_ROWID_IN_VIEW (mis-)feature is\n+** available.  By default, this macro is false\n+*\/\n+#ifndef SQLITE_ALLOW_ROWID_IN_VIEW\n+# define ViewCanHaveRowid     0\n+#else\n+# define ViewCanHaveRowid     (sqlite3Config.mNoVisibleRowid==0)\n+#endif\n+\n@@ -17766,1 +18530,1 @@\n-** conflict resolution algorthm is required from context.\n+** conflict resolution algorithm is required from context.\n@@ -17884,2 +18648,2 @@\n-** and the value of Index.onError indicate the which conflict resolution\n-** algorithm to employ whenever an attempt is made to insert a non-unique\n+** and the value of Index.onError indicates which conflict resolution\n+** algorithm to employ when an attempt is made to insert a non-unique\n@@ -17888,0 +18652,12 @@\n+** The colNotIdxed bitmask is used in combination with SrcItem.colUsed\n+** for a fast test to see if an index can serve as a covering index.\n+** colNotIdxed has a 1 bit for every column of the original table that\n+** is *not* available in the index.  Thus the expression\n+** \"colUsed & colNotIdxed\" will be non-zero if the index is not a\n+** covering index.  The most significant bit of of colNotIdxed will always\n+** be true (note-20221022-a).  If a column beyond the 63rd column of the\n+** table is used, the \"colUsed & colNotIdxed\" test will always be non-zero\n+** and we have to assume either that the index is not covering, or use\n+** an alternative (slower) algorithm to determine whether or not\n+** the index is covering.\n+**\n@@ -17920,0 +18696,1 @@\n+  unsigned bLowQual:1;     \/* sqlite_stat1 says this is a low-quality index *\/\n@@ -17923,0 +18700,2 @@\n+  unsigned bHasExpr:1;     \/* Index contains an expression, either a literal\n+                           ** expression, or a reference to a VIRTUAL column *\/\n@@ -17925,0 +18704,1 @@\n+  int mxSample;            \/* Number of slots allocated to aSample[] *\/\n@@ -17931,1 +18711,1 @@\n-  Bitmask colNotIdxed;     \/* 0 for unindexed columns in pTab *\/\n+  Bitmask colNotIdxed;     \/* Unindexed columns in pTab *\/\n@@ -18006,0 +18786,1 @@\n+  u16 nSortingColumn;     \/* Number of columns in the sorting index *\/\n@@ -18008,2 +18789,1 @@\n-  int nSortingColumn;     \/* Number of columns in the sorting index *\/\n-  int mnReg, mxReg;       \/* Range of registers allocated for aCol and aFunc *\/\n+  int iFirstReg;          \/* First register in range for aCol[] and aFunc[] *\/\n@@ -18015,1 +18795,0 @@\n-    int iMem;                \/* Memory location that acts as accumulator *\/\n@@ -18026,1 +18805,0 @@\n-    int iMem;                \/* Memory location that acts as accumulator *\/\n@@ -18029,0 +18807,4 @@\n+    int iOBTab;              \/* Ephemeral table to implement ORDER BY *\/\n+    u8 bOBPayload;           \/* iOBTab has payload columns separate from key *\/\n+    u8 bOBUnique;            \/* Enforce uniqueness on iOBTab keys *\/\n+    u8 bUseSubtype;          \/* Transfer subtype info through sorter *\/\n@@ -18032,0 +18814,3 @@\n+#ifdef SQLITE_DEBUG\n+  Select *pSelect;        \/* SELECT statement that this AggInfo supports *\/\n+#endif\n@@ -18034,0 +18819,11 @@\n+\/*\n+** Macros to compute aCol[] and aFunc[] register numbers.\n+**\n+** These macros should not be used prior to the call to\n+** assignAggregateRegisters() that computes the value of pAggInfo->iFirstReg.\n+** The assert()s that are part of this macro verify that constraint.\n+*\/\n+#define AggInfoColumnReg(A,I)  (assert((A)->iFirstReg),(A)->iFirstReg+(I))\n+#define AggInfoFuncReg(A,I)    \\\n+                      (assert((A)->iFirstReg),(A)->iFirstReg+(A)->nColumn+(I))\n+\n@@ -18153,1 +18949,1 @@\n-                         ** TK_IN: ephemerial table holding RHS\n+                         ** TK_IN: ephemeral table holding RHS\n@@ -18199,1 +18995,1 @@\n-#define EP_MemToken   0x020000 \/* Need to sqlite3DbFree() Expr.zToken *\/\n+#define EP_FullSize   0x020000 \/* Expr structure must remain full sized *\/\n@@ -18229,0 +19025,1 @@\n+#define ExprIsFullSize(E)   (((E)->flags&(EP_Reduced|EP_TokenOnly))==0)\n@@ -18235,0 +19032,2 @@\n+#define ExprUseWOfst(E)     (((E)->flags&(EP_InnerON|EP_OuterON))==0)\n+#define ExprUseWJoin(E)     (((E)->flags&(EP_InnerON|EP_OuterON))!=0)\n@@ -18344,0 +19143,1 @@\n+#define ENAME_ROWID 3       \/* \"DB.TABLE._rowid_\" for * expansion of rowid *\/\n@@ -18384,0 +19184,8 @@\n+** The jointype starts out showing the join type between the current table\n+** and the next table on the list.  The parser builds the list this way.\n+** But sqlite3SrcListShiftJoinType() later shifts the jointypes so that each\n+** jointype expresses the join between the table and the previous table.\n+**\n+** In the colUsed field, the high-order bit (bit 63) is set if the table\n+** contains more than 63 columns and the 64-th or later column is used.\n+**\n@@ -18415,1 +19223,1 @@\n-    unsigned isSynthUsing :1;  \/* u3.pUsing is synthensized from NATURAL *\/\n+    unsigned isSynthUsing :1;  \/* u3.pUsing is synthesized from NATURAL *\/\n@@ -18423,1 +19231,1 @@\n-  Bitmask colUsed;  \/* Bit N (1<<N) set if column N of pTab is used *\/\n+  Bitmask colUsed;  \/* Bit N set if column N used. Details above for N>62 *\/\n@@ -18430,1 +19238,1 @@\n-    CteUse *pCteUse;  \/* CTE Usage info info fg.isCte is true *\/\n+    CteUse *pCteUse;  \/* CTE Usage info when fg.isCte is true *\/\n@@ -18444,14 +19252,4 @@\n-** The following structure describes the FROM clause of a SELECT statement.\n-** Each table or subquery in the FROM clause is a separate element of\n-** the SrcList.a[] array.\n-**\n-** With the addition of multiple database support, the following structure\n-** can also be used to describe a particular table such as the table that\n-** is modified by an INSERT, DELETE, or UPDATE statement.  In standard SQL,\n-** such a table must be a simple name: ID.  But in SQLite, the table can\n-** now be identified by a database name, a dot, then the table name: ID.ID.\n-**\n-** The jointype starts out showing the join type between the current table\n-** and the next table on the list.  The parser builds the list this way.\n-** But sqlite3SrcListShiftJoinType() later shifts the jointypes so that each\n-** jointype expresses the join between the table and the previous table.\n+** This object represents one or more tables that are the source of\n+** content for an SQL statement.  For example, a single SrcList object\n+** is used to hold the FROM clause of a SELECT statement.  SrcList also\n+** represents the target tables for DELETE, INSERT, and UPDATE statements.\n@@ -18459,2 +19257,0 @@\n-** In the colUsed field, the high-order bit (bit 63) is set if the table\n-** contains more than 63 columns and the 64-th or later column is used.\n@@ -18548,0 +19344,1 @@\n+  u32 nNestedSelect;   \/* Number of nested selects using this NC *\/\n@@ -18568,1 +19365,1 @@\n-#define NC_VarSelect 0x000040 \/* A correlated subquery has been seen *\/\n+#define NC_Subquery  0x000040 \/* A subquery has been seen *\/\n@@ -18581,0 +19378,1 @@\n+#define NC_Where     0x100000 \/* Processing WHERE clause of a SELECT *\/\n@@ -18604,0 +19402,1 @@\n+  u8 isDup;                 \/* True if 2nd or later with same pUpsertIdx *\/\n@@ -18697,0 +19496,1 @@\n+#define SF_UpdateFrom   0x10000000 \/* Query originates with UPDATE FROM *\/\n@@ -18805,1 +19605,1 @@\n-  char *zAffSdst;      \/* Affinity used when eDest==SRT_Set *\/\n+  char *zAffSdst;      \/* Affinity used for SRT_Set *\/\n@@ -18864,4 +19664,26 @@\n-# define DbMaskZero(M)      (M)=0\n-# define DbMaskSet(M,I)     (M)|=(((yDbMask)1)<<(I))\n-# define DbMaskAllZero(M)   (M)==0\n-# define DbMaskNonZero(M)   (M)!=0\n+# define DbMaskZero(M)      ((M)=0)\n+# define DbMaskSet(M,I)     ((M)|=(((yDbMask)1)<<(I)))\n+# define DbMaskAllZero(M)   ((M)==0)\n+# define DbMaskNonZero(M)   ((M)!=0)\n+#endif\n+\n+\/*\n+** For each index X that has as one of its arguments either an expression\n+** or the name of a virtual generated column, and if X is in scope such that\n+** the value of the expression can simply be read from the index, then\n+** there is an instance of this object on the Parse.pIdxExpr list.\n+**\n+** During code generation, while generating code to evaluate expressions,\n+** this list is consulted and if a matching expression is found, the value\n+** is read from the index rather than being recomputed.\n+*\/\n+struct IndexedExpr {\n+  Expr *pExpr;            \/* The expression contained in the index *\/\n+  int iDataCur;           \/* The data cursor associated with the index *\/\n+  int iIdxCur;            \/* The index cursor *\/\n+  int iIdxCol;            \/* The index column that contains value of pExpr *\/\n+  u8 bMaybeNullRow;       \/* True if we need an OP_IfNullRow check *\/\n+  u8 aff;                 \/* Affinity of the pExpr expression *\/\n+  IndexedExpr *pIENext;   \/* Next in a list of all indexed expressions *\/\n+#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n+  const char *zIdxName;   \/* Name of index, used only for bytecode comments *\/\n@@ -18869,0 +19691,1 @@\n+};\n@@ -18911,1 +19734,1 @@\n-  u8 disableVtab;      \/* Disable all virtual tables for this parse *\/\n+  u8 prepFlags;        \/* SQLITE_PREPARE_* flags *\/\n@@ -18915,0 +19738,3 @@\n+#endif\n+#ifdef SQLITE_DEBUG\n+  u8 ifNotExists;      \/* Might be true if IF NOT EXISTS.  Assert()s only *\/\n@@ -18928,0 +19754,2 @@\n+  IndexedExpr *pIdxEpr;\/* List of expressions used by active indexes *\/\n+  IndexedExpr *pIdxPartExpr; \/* Exprs constrained by index WHERE clauses *\/\n@@ -18935,0 +19763,3 @@\n+#ifndef SQLITE_OMIT_PROGRESS_CALLBACK\n+  u32 nProgressSteps;  \/* xProgress steps taken during sqlite3_prepare() *\/\n+#endif\n@@ -18948,1 +19779,0 @@\n-  u32 nQueryLoop;      \/* Est number of iterations of a query (10*log2(N)) *\/\n@@ -18951,0 +19781,1 @@\n+  LogEst nQueryLoop;   \/* Est number of iterations of a query (10*log2(N)) *\/\n@@ -19074,0 +19905,1 @@\n+#define OPFLAG_BYTELENARG    0xc0    \/* OP_Column only for octet_length() *\/\n@@ -19195,0 +20027,1 @@\n+  char zName[40];       \/* Name of trigger: \"sqlite_returning_%p\" *\/\n@@ -19216,0 +20049,22 @@\n+\/*\n+** The following object is the header for an \"RCStr\" or \"reference-counted\n+** string\".  An RCStr is passed around and used like any other char*\n+** that has been dynamically allocated.  The important interface\n+** differences:\n+**\n+**   1.  RCStr strings are reference counted.  They are deallocated\n+**       when the reference count reaches zero.\n+**\n+**   2.  Use sqlite3RCStrUnref() to free an RCStr string rather than\n+**       sqlite3_free()\n+**\n+**   3.  Make a (read-only) copy of a read-only RCStr string using\n+**       sqlite3RCStrRef().\n+**\n+** \"String\" is in the name, but an RCStr object can also be used to hold\n+** binary data.\n+*\/\n+struct RCStr {\n+  u64 nRCRef;            \/* Number of references *\/\n+  \/* Total structure size should be a multiple of 8 bytes for alignment *\/\n+};\n@@ -19242,1 +20097,1 @@\n-** optimial values for parameters in the query planner.  The should not\n+** optimal values for parameters in the query planner.  The should not\n@@ -19268,0 +20123,4 @@\n+  u8 bUseLongDouble;                \/* Make use of long double *\/\n+#ifdef SQLITE_DEBUG\n+  u8 bJsonSelfcheck;                \/* Double-check JSON parsing *\/\n+#endif\n@@ -19314,0 +20173,5 @@\n+#endif\n+#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n+  u32 mNoVisibleRowid;              \/* TF_NoVisibleRowid if the ROWID_IN_VIEW\n+                                    ** feature is disabled.  0 if rowids can\n+                                    ** occur in views. *\/\n@@ -19354,0 +20218,1 @@\n+  u16 mWFlags;                              \/* Use-dependent flags *\/\n@@ -19363,1 +20228,0 @@\n-    struct IdxExprTrans *pIdxTrans;           \/* Convert idxed expr to column *\/\n@@ -19370,0 +20234,1 @@\n+    struct CoveringIndexCheck *pCovIdxCk;     \/* Check for covering index *\/\n@@ -19371,1 +20236,2 @@\n-    DbFixer *pFix;\n+    DbFixer *pFix;                            \/* See sqlite3FixSelect() *\/\n+    Mem *aMem;                                \/* See sqlite3BtreeCursorHint() *\/\n@@ -19392,0 +20258,1 @@\n+SQLITE_PRIVATE int sqlite3WalkExprNN(Walker*, Expr*);\n@@ -19472,0 +20339,10 @@\n+\/* Client data associated with sqlite3_set_clientdata() and\n+** sqlite3_get_clientdata().\n+*\/\n+struct DbClientData {\n+  DbClientData *pNext;        \/* Next in a linked list *\/\n+  void *pData;                \/* The data *\/\n+  void (*xDestructor)(void*); \/* Destructor.  Might be NULL *\/\n+  char zName[1];              \/* Name of this client data. MUST BE LAST *\/\n+};\n+\n@@ -19641,0 +20518,2 @@\n+# define sqlite3JsonId1(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x42)\n+# define sqlite3JsonId2(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x46)\n@@ -19650,0 +20529,2 @@\n+# define sqlite3JsonId1(x)   (sqlite3IsIdChar(x)&&(x)<'0')\n+# define sqlite3JsonId2(x)   sqlite3IsIdChar(x)\n@@ -19677,0 +20558,1 @@\n+SQLITE_PRIVATE void sqlite3DbNNFreeNN(sqlite3*, void*);\n@@ -19697,1 +20579,1 @@\n-# define sqlite3StackAllocZero(D,N)  memset(alloca(N), 0, N)\n+# define sqlite3StackAllocRawNN(D,N) alloca(N)\n@@ -19699,0 +20581,1 @@\n+# define sqlite3StackFreeNN(D,P)\n@@ -19701,1 +20584,1 @@\n-# define sqlite3StackAllocZero(D,N)  sqlite3DbMallocZero(D,N)\n+# define sqlite3StackAllocRawNN(D,N) sqlite3DbMallocRawNN(D,N)\n@@ -19703,0 +20586,1 @@\n+# define sqlite3StackFreeNN(D,P)     sqlite3DbFreeNN(D,P)\n@@ -19750,0 +20634,1 @@\n+# define IsOvfl(X) (((X)&EXP754)==EXP754)\n@@ -19751,0 +20636,1 @@\n+SQLITE_PRIVATE   int sqlite3IsOverflow(double);\n@@ -19752,2 +20638,3 @@\n-# define IsNaN(X)         0\n-# define sqlite3IsNaN(X)  0\n+# define IsNaN(X)             0\n+# define sqlite3IsNaN(X)      0\n+# define sqlite3IsOVerflow(X) 0\n@@ -19766,0 +20653,14 @@\n+\/*\n+** An instance of this object receives the decoding of a floating point\n+** value into an approximate decimal representation.\n+*\/\n+struct FpDecode {\n+  char sign;           \/* '+' or '-' *\/\n+  char isSpecial;      \/* 1: Infinity  2: NaN *\/\n+  int n;               \/* Significant digits in the decode *\/\n+  int iDP;             \/* Location of the decimal point *\/\n+  char *z;             \/* Start of significant digits *\/\n+  char zBuf[24];       \/* Storage for significant digits *\/\n+};\n+\n+SQLITE_PRIVATE void sqlite3FpDecode(FpDecode*,double,int,int);\n@@ -19825,0 +20726,1 @@\n+SQLITE_PRIVATE void sqlite3ProgressCheck(Parse*);\n@@ -19839,0 +20741,4 @@\n+SQLITE_PRIVATE void sqlite3TouchRegister(Parse*,int);\n+#if defined(SQLITE_ENABLE_STAT4) || defined(SQLITE_DEBUG)\n+SQLITE_PRIVATE int sqlite3FirstAvailableRegister(Parse*,int);\n+#endif\n@@ -19850,0 +20756,2 @@\n+SQLITE_PRIVATE void sqlite3ExprAddFunctionOrderBy(Parse*,Expr*,ExprList*);\n+SQLITE_PRIVATE void sqlite3ExprOrderByAggregateError(Parse*,Expr*);\n@@ -19853,0 +20761,1 @@\n+SQLITE_PRIVATE void sqlite3ExprDeleteGeneric(sqlite3*,void*);\n@@ -19862,0 +20771,1 @@\n+SQLITE_PRIVATE void sqlite3ExprListDeleteGeneric(sqlite3*,void*);\n@@ -19882,1 +20792,1 @@\n-SQLITE_PRIVATE void sqlite3SelectAddColumnTypeAndCollation(Parse*,Table*,Select*,char);\n+SQLITE_PRIVATE void sqlite3SubqueryColumnTypes(Parse*,Table*,Select*,char);\n@@ -19952,0 +20862,1 @@\n+SQLITE_PRIVATE void sqlite3DeleteTableGeneric(sqlite3*, void*);\n@@ -19988,0 +20899,1 @@\n+SQLITE_PRIVATE void sqlite3SelectDeleteGeneric(sqlite3*,void*);\n@@ -19989,1 +20901,1 @@\n-SQLITE_PRIVATE int sqlite3IsReadOnly(Parse*, Table*, int);\n+SQLITE_PRIVATE int sqlite3IsReadOnly(Parse*, Table*, Trigger*);\n@@ -20051,1 +20963,1 @@\n-SQLITE_PRIVATE int sqlite3ExprImpliesNonNullRow(Expr*,int);\n+SQLITE_PRIVATE int sqlite3ExprImpliesNonNullRow(Expr*,int,int);\n@@ -20078,1 +20990,1 @@\n-SQLITE_PRIVATE int sqlite3ExprIsTableConstraint(Expr*,const SrcItem*);\n+SQLITE_PRIVATE int sqlite3ExprIsSingleTableConstraint(Expr*,const SrcList*,int);\n@@ -20086,0 +20998,1 @@\n+SQLITE_PRIVATE const char *sqlite3RowidAlias(Table *pTab);\n@@ -20200,0 +21113,1 @@\n+\n@@ -20201,1 +21115,2 @@\n-SQLITE_PRIVATE void sqlite3Int64ToText(i64,char*);\n+SQLITE_PRIVATE i64 sqlite3RealToI64(double);\n+SQLITE_PRIVATE int sqlite3Int64ToText(i64,char*);\n@@ -20211,0 +21126,1 @@\n+SQLITE_PRIVATE int sqlite3Utf8ReadLimited(const u8*, int, u32*);\n@@ -20246,0 +21162,1 @@\n+SQLITE_PRIVATE char *sqlite3TableAffinityStr(sqlite3*,const Table*);\n@@ -20251,0 +21168,1 @@\n+SQLITE_PRIVATE int sqlite3ExprDataType(const Expr *pExpr);\n@@ -20267,0 +21185,3 @@\n+SQLITE_PRIVATE int sqlite3IsMemdb(const sqlite3_vfs*);\n+#else\n+# define sqlite3IsMemdb(X) 0\n@@ -20298,0 +21219,1 @@\n+SQLITE_PRIVATE int sqlite3ValueIsOfClass(const sqlite3_value*, void(*)(void*));\n@@ -20317,1 +21239,0 @@\n-SQLITE_PRIVATE const char sqlite3StdTypeMap[];\n@@ -20350,1 +21271,2 @@\n-  const char*\n+  const char*,\n+  int*\n@@ -20406,0 +21328,5 @@\n+SQLITE_PRIVATE char *sqlite3RCStrRef(char*);\n+SQLITE_PRIVATE void sqlite3RCStrUnref(void*);\n+SQLITE_PRIVATE char *sqlite3RCStrNew(u64);\n+SQLITE_PRIVATE char *sqlite3RCStrResize(char*,u64);\n+\n@@ -20407,1 +21334,1 @@\n-SQLITE_PRIVATE int sqlite3StrAccumEnlarge(StrAccum*, int);\n+SQLITE_PRIVATE int sqlite3StrAccumEnlarge(StrAccum*, i64);\n@@ -20521,4 +21448,1 @@\n-#if (defined(SQLITE_ENABLE_DBPAGE_VTAB) || defined(SQLITE_TEST)) \\\n-    && !defined(SQLITE_OMIT_VIRTUALTABLE)\n-SQLITE_PRIVATE   void sqlite3VtabUsesAllSchemas(sqlite3_index_info*);\n-#endif\n+SQLITE_PRIVATE void sqlite3VtabUsesAllSchemas(Parse*);\n@@ -20549,0 +21473,1 @@\n+SQLITE_PRIVATE   void sqlite3WithDeleteGeneric(sqlite3*,void*);\n@@ -20561,1 +21486,1 @@\n-SQLITE_PRIVATE   int sqlite3UpsertAnalyzeTarget(Parse*,SrcList*,Upsert*);\n+SQLITE_PRIVATE   int sqlite3UpsertAnalyzeTarget(Parse*,SrcList*,Upsert*,Upsert*);\n@@ -20660,0 +21585,1 @@\n+SQLITE_PRIVATE void sqlite3ExprSetErrorOffset(Expr*,int);\n@@ -20761,0 +21687,16 @@\n+#if SQLITE_OS_UNIX && defined(SQLITE_OS_KV_OPTIONAL)\n+SQLITE_PRIVATE int sqlite3KvvfsInit(void);\n+#endif\n+\n+#if defined(VDBE_PROFILE) \\\n+ || defined(SQLITE_PERFORMANCE_TRACE) \\\n+ || defined(SQLITE_ENABLE_STMT_SCANSTATUS)\n+SQLITE_PRIVATE sqlite3_uint64 sqlite3Hwtime(void);\n+#endif\n+\n+#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n+# define IS_STMT_SCANSTATUS(db) (db->flags & SQLITE_StmtScanStatus)\n+#else\n+# define IS_STMT_SCANSTATUS(db) 0\n+#endif\n+\n@@ -20802,95 +21744,0 @@\n-\/*\n-** hwtime.h contains inline assembler code for implementing\n-** high-performance timing routines.\n-*\/\n-\/************** Include hwtime.h in the middle of os_common.h ****************\/\n-\/************** Begin file hwtime.h ******************************************\/\n-\/*\n-** 2008 May 27\n-**\n-** The author disclaims copyright to this source code.  In place of\n-** a legal notice, here is a blessing:\n-**\n-**    May you do good and not evil.\n-**    May you find forgiveness for yourself and forgive others.\n-**    May you share freely, never taking more than you give.\n-**\n-******************************************************************************\n-**\n-** This file contains inline asm code for retrieving \"high-performance\"\n-** counters for x86 and x86_64 class CPUs.\n-*\/\n-#ifndef SQLITE_HWTIME_H\n-#define SQLITE_HWTIME_H\n-\n-\/*\n-** The following routine only works on pentium-class (or newer) processors.\n-** It uses the RDTSC opcode to read the cycle count value out of the\n-** processor and returns that value.  This can be used for high-res\n-** profiling.\n-*\/\n-#if !defined(__STRICT_ANSI__) && \\\n-    (defined(__GNUC__) || defined(_MSC_VER)) && \\\n-    (defined(i386) || defined(__i386__) || defined(_M_IX86))\n-\n-  #if defined(__GNUC__)\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-     unsigned int lo, hi;\n-     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n-     return (sqlite_uint64)hi << 32 | lo;\n-  }\n-\n-  #elif defined(_MSC_VER)\n-\n-  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){\n-     __asm {\n-        rdtsc\n-        ret       ; return value at EDX:EAX\n-     }\n-  }\n-\n-  #endif\n-\n-#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__x86_64__))\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-      unsigned long val;\n-      __asm__ __volatile__ (\"rdtsc\" : \"=A\" (val));\n-      return val;\n-  }\n-\n-#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__ppc__))\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-      unsigned long long retval;\n-      unsigned long junk;\n-      __asm__ __volatile__ (\"\\n\\\n-          1:      mftbu   %1\\n\\\n-                  mftb    %L0\\n\\\n-                  mftbu   %0\\n\\\n-                  cmpw    %0,%1\\n\\\n-                  bne     1b\"\n-                  : \"=r\" (retval), \"=r\" (junk));\n-      return retval;\n-  }\n-\n-#else\n-\n-  \/*\n-  ** asm() is needed for hardware timing support.  Without asm(),\n-  ** disable the sqlite3Hwtime() routine.\n-  **\n-  ** sqlite3Hwtime() is only used for some obscure debugging\n-  ** and analysis configurations, not in any deliverable, so this\n-  ** should not be a great loss.\n-  *\/\n-SQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }\n-\n-#endif\n-\n-#endif \/* !defined(SQLITE_HWTIME_H) *\/\n-\n-\/************** End of hwtime.h **********************************************\/\n-\/************** Continuing where we left off in os_common.h ******************\/\n-\n@@ -20992,1 +21839,1 @@\n-\/* #include \"config.h\" *\/\n+\/* #include \"sqlite_cfg.h\" *\/\n@@ -21024,3 +21871,0 @@\n-#ifdef SQLITE_64BIT_STATS\n-  \"64BIT_STATS\",\n-#endif\n@@ -21032,0 +21876,3 @@\n+#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n+  \"ALLOW_ROWID_IN_VIEW\",\n+#endif\n@@ -21157,0 +22004,3 @@\n+#ifdef SQLITE_DQS\n+  \"DQS=\" CTIMEOPT_VAL(SQLITE_DQS),\n+#endif\n@@ -21319,0 +22169,3 @@\n+#ifdef SQLITE_EXTRA_AUTOEXT\n+  \"EXTRA_AUTOEXT=\" CTIMEOPT_VAL(SQLITE_EXTRA_AUTOEXT),\n+#endif\n@@ -21360,0 +22213,3 @@\n+#ifdef SQLITE_LEGACY_JSON_VALID\n+  \"LEGACY_JSON_VALID\",\n+#endif\n@@ -21597,0 +22453,3 @@\n+#ifdef SQLITE_OMIT_SEH\n+  \"OMIT_SEH\",\n+#endif\n@@ -21647,3 +22506,0 @@\n-#ifdef SQLITE_PCACHE_SEPARATE_HEADER\n-  \"PCACHE_SEPARATE_HEADER\",\n-#endif\n@@ -21851,1 +22707,1 @@\n-**   SQLite identifier character      0x40\n+**   SQLite identifier character      0x40   $, _, or non-ascii\n@@ -21997,0 +22853,4 @@\n+   sizeof(LONGDOUBLE_TYPE)>8, \/* bUseLongDouble *\/\n+#ifdef SQLITE_DEBUG\n+   0,                         \/* bJsonSelfcheck *\/\n+#endif\n@@ -22038,0 +22898,3 @@\n+#endif\n+#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n+   0,                         \/* mNoVisibleRowid.  0 == allow rowid-in-view *\/\n@@ -22045,1 +22908,1 @@\n-   {0,0,0,0,0,0}              \/* aTune *\/\n+   {0,0,0,0,0,0},             \/* aTune *\/\n@@ -22129,4 +22992,0 @@\n-**\n-**    sqlite3StdTypeMap[]         The type value (as returned from\n-**                                sqlite3_column_type() or sqlite3_value_type())\n-**                                for each entry in sqlite3StdType[].\n@@ -22143,8 +23002,0 @@\n-SQLITE_PRIVATE const char sqlite3StdTypeMap[] = {\n-  0,\n-  SQLITE_BLOB,\n-  SQLITE_INTEGER,\n-  SQLITE_INTEGER,\n-  SQLITE_FLOAT,\n-  SQLITE_TEXT\n-};\n@@ -22238,0 +23089,3 @@\n+\/* A cache of large TEXT or BLOB values in a VdbeCursor *\/\n+typedef struct VdbeTxtBlbCache VdbeTxtBlbCache;\n+\n@@ -22269,0 +23123,1 @@\n+  Bool colCache:1;        \/* pCache pointer is initialized and non-NULL *\/\n@@ -22309,0 +23164,1 @@\n+  VdbeTxtBlbCache *pCache; \/* Cache of large TEXT or BLOB values *\/\n@@ -22321,1 +23177,0 @@\n-\n@@ -22327,0 +23182,14 @@\n+\/*\n+** Large TEXT or BLOB values can be slow to load, so we want to avoid\n+** loading them more than once.  For that reason, large TEXT and BLOB values\n+** can be stored in a cache defined by this object, and attached to the\n+** VdbeCursor using the pCache field.\n+*\/\n+struct VdbeTxtBlbCache {\n+  char *pCValue;        \/* A RCStr buffer to hold the value *\/\n+  i64 iOffset;          \/* File offset of the row being cached *\/\n+  int iCol;             \/* Column for which the cache is valid *\/\n+  u32 cacheStatus;      \/* Vdbe.cacheCtr value *\/\n+  u32 colCacheCtr;      \/* Column cache counter *\/\n+};\n+\n@@ -22353,1 +23222,0 @@\n-  i64 *anExec;            \/* Event counters from parent frame *\/\n@@ -22569,0 +23437,8 @@\n+**\n+** aAddrRange[]:\n+**   This array is used by ScanStatus elements associated with EQP\n+**   notes that make an SQLITE_SCANSTAT_NCYCLE value available. It is\n+**   an array of up to 3 ranges of VM addresses for which the Vdbe.anCycle[]\n+**   values should be summed to calculate the NCYCLE value. Each pair of\n+**   integer addresses is a start and end address (both inclusive) for a range\n+**   instructions. A start value of 0 indicates an empty range.\n@@ -22573,0 +23449,1 @@\n+  int aAddrRange[6];\n@@ -22602,1 +23479,1 @@\n-  Vdbe *pPrev,*pNext;     \/* Linked list of VDBEs with the same Vdbe.db *\/\n+  Vdbe **ppVPrev,*pVNext; \/* Linked list of VDBEs with the same Vdbe.db *\/\n@@ -22628,1 +23505,1 @@\n-  Mem *pResultSet;        \/* Pointer to an array of results *\/\n+  Mem *pResultRow;        \/* Current output row *\/\n@@ -22639,0 +23516,1 @@\n+  u16 nResAlloc;          \/* Column slots allocated to aColName[] *\/\n@@ -22644,1 +23522,1 @@\n-  bft explain:2;          \/* True if EXPLAIN present on SQL command *\/\n+  bft explain:2;          \/* 0: normal, 1: EXPLAIN, 2: EXPLAIN QUERY PLAN *\/\n@@ -22649,0 +23527,1 @@\n+  bft haveEqpOps:1;       \/* Bytecode supports EXPLAIN QUERY PLAN *\/\n@@ -22665,1 +23544,0 @@\n-  i64 *anExec;            \/* Number of times each op has been executed *\/\n@@ -22696,1 +23574,1 @@\n-  Table *pTab;                    \/* Schema object being upated *\/\n+  Table *pTab;                    \/* Schema object being updated *\/\n@@ -22786,0 +23664,1 @@\n+SQLITE_PRIVATE void sqlite3VdbeMemZeroTerminateIfAble(Mem*);\n@@ -22832,0 +23711,2 @@\n+SQLITE_PRIVATE void sqlite3VdbeValueListFree(void*);\n+\n@@ -23160,0 +24041,2 @@\n+      assert( db->lookaside.pEnd==db->lookaside.pTrueEnd );\n+      db->lookaside.pEnd = db->lookaside.pStart;\n@@ -23185,0 +24068,1 @@\n+      db->lookaside.pEnd = db->lookaside.pTrueEnd;\n@@ -23202,1 +24086,3 @@\n-      for(pVdbe=db->pVdbe; pVdbe; pVdbe=pVdbe->pNext){\n+      assert( db->lookaside.pEnd==db->lookaside.pTrueEnd );\n+      db->lookaside.pEnd = db->lookaside.pStart;\n+      for(pVdbe=db->pVdbe; pVdbe; pVdbe=pVdbe->pVNext){\n@@ -23205,0 +24091,1 @@\n+      db->lookaside.pEnd = db->lookaside.pTrueEnd;\n@@ -23225,1 +24112,1 @@\n-      int nRet = 0;\n+      u64 nRet = 0;\n@@ -23238,1 +24125,1 @@\n-      *pCurrent = nRet;\n+      *pCurrent = (int)nRet & 0x7fffffff;\n@@ -23341,0 +24228,1 @@\n+  char useSubsec;     \/* Display subsecond precision *\/\n@@ -23373,2 +24261,2 @@\n-  ** spec into a max size:    a   b   c   d   e     f *\/\n-  static const u16 aMx[] = { 12, 14, 24, 31, 59, 9999 };\n+  ** spec into a max size:    a   b   c   d   e      f *\/\n+  static const u16 aMx[] = { 12, 14, 24, 31, 59, 14712 };\n@@ -23540,1 +24428,1 @@\n-    p->iJD += p->h*3600000 + p->m*60000 + (sqlite3_int64)(p->s*1000);\n+    p->iJD += p->h*3600000 + p->m*60000 + (sqlite3_int64)(p->s*1000 + 0.5);\n@@ -23655,0 +24543,5 @@\n+  }else if( (sqlite3StrICmp(zDate,\"subsec\")==0\n+             || sqlite3StrICmp(zDate,\"subsecond\")==0)\n+           && sqlite3NotPureFunc(context) ){\n+    p->useSubsec = 1;\n+    return setDateTimeToCurrent(context, p);\n@@ -23710,1 +24603,1 @@\n-  int s;\n+  int day_ms, day_min; \/* milliseconds, minutes into the day *\/\n@@ -23713,8 +24606,5 @@\n-  s = (int)((p->iJD + 43200000) % 86400000);\n-  p->s = s\/1000.0;\n-  s = (int)p->s;\n-  p->s -= s;\n-  p->h = s\/3600;\n-  s -= p->h*3600;\n-  p->m = s\/60;\n-  p->s += s - p->m*60;\n+  day_ms = (int)((p->iJD + 43200000) % 86400000);\n+  p->s = (day_ms % 60000)\/1000.0;\n+  day_min = day_ms\/60000;\n+  p->m = day_min % 60;\n+  p->h = day_min \/ 60;\n@@ -23899,0 +24789,19 @@\n+\/*\n+** If the DateTime p is raw number, try to figure out if it is\n+** a julian day number of a unix timestamp.  Set the p value\n+** appropriately.\n+*\/\n+static void autoAdjustDate(DateTime *p){\n+  if( !p->rawS || p->validJD ){\n+    p->rawS = 0;\n+  }else if( p->s>=-21086676*(i64)10000        \/* -4713-11-24 12:00:00 *\/\n+         && p->s<=(25340230*(i64)10000)+799   \/*  9999-12-31 23:59:59 *\/\n+  ){\n+    double r = p->s*1000.0 + 210866760000000.0;\n+    clearYMD_HMS_TZ(p);\n+    p->iJD = (sqlite3_int64)(r + 0.5);\n+    p->validJD = 1;\n+    p->rawS = 0;\n+  }\n+}\n+\n@@ -23942,13 +24851,2 @@\n-        if( !p->rawS || p->validJD ){\n-          rc = 0;\n-          p->rawS = 0;\n-        }else if( p->s>=-21086676*(i64)10000        \/* -4713-11-24 12:00:00 *\/\n-               && p->s<=(25340230*(i64)10000)+799   \/*  9999-12-31 23:59:59 *\/\n-        ){\n-          r = p->s*1000.0 + 210866760000000.0;\n-          clearYMD_HMS_TZ(p);\n-          p->iJD = (sqlite3_int64)(r + 0.5);\n-          p->validJD = 1;\n-          p->rawS = 0;\n-          rc = 0;\n-        }\n+        autoAdjustDate(p);\n+        rc = 0;\n@@ -24013,1 +24911,1 @@\n-          int iErr;                 \/* Guess is off by this much *\/\n+          i64 iErr;                 \/* Guess is off by this much *\/\n@@ -24049,1 +24947,1 @@\n-               && (n=(int)r)==r && n>=0 && r<7 ){\n+               && r>=0.0 && r<7.0 && (n=(int)r)==r ){\n@@ -24069,0 +24967,6 @@\n+      **\n+      **    subsecond\n+      **    subsec\n+      **\n+      ** Show subsecond precision in the output of datetime() and\n+      ** unixepoch() and strftime('%s').\n@@ -24070,1 +24974,9 @@\n-      if( sqlite3_strnicmp(z, \"start of \", 9)!=0 ) break;\n+      if( sqlite3_strnicmp(z, \"start of \", 9)!=0 ){\n+        if( sqlite3_stricmp(z, \"subsec\")==0\n+         || sqlite3_stricmp(z, \"subsecond\")==0\n+        ){\n+          p->useSubsec = 1;\n+          rc = 0;\n+        }\n+        break;\n+      }\n@@ -24106,1 +25018,11 @@\n-      for(n=1; z[n] && z[n]!=':' && !sqlite3Isspace(z[n]); n++){}\n+      int Y,M,D,h,m,x;\n+      const char *z2 = z;\n+      char z0 = z[0];\n+      for(n=1; z[n]; n++){\n+        if( z[n]==':' ) break;\n+        if( sqlite3Isspace(z[n]) ) break;\n+        if( z[n]=='-' ){\n+          if( n==5 && getDigits(&z[1], \"40f\", &Y)==1 ) break;\n+          if( n==6 && getDigits(&z[1], \"50f\", &Y)==1 ) break;\n+        }\n+      }\n@@ -24108,1 +25030,1 @@\n-        rc = 1;\n+        assert( rc==1 );\n@@ -24111,1 +25033,46 @@\n-      if( z[n]==':' ){\n+      if( z[n]=='-' ){\n+        \/* A modifier of the form (+|-)YYYY-MM-DD adds or subtracts the\n+        ** specified number of years, months, and days.  MM is limited to\n+        ** the range 0-11 and DD is limited to 0-30.\n+        *\/\n+        if( z0!='+' && z0!='-' ) break;  \/* Must start with +\/- *\/\n+        if( n==5 ){\n+          if( getDigits(&z[1], \"40f-20a-20d\", &Y, &M, &D)!=3 ) break;\n+        }else{\n+          assert( n==6 );\n+          if( getDigits(&z[1], \"50f-20a-20d\", &Y, &M, &D)!=3 ) break;\n+          z++;\n+        }\n+        if( M>=12 ) break;                   \/* M range 0..11 *\/\n+        if( D>=31 ) break;                   \/* D range 0..30 *\/\n+        computeYMD_HMS(p);\n+        p->validJD = 0;\n+        if( z0=='-' ){\n+          p->Y -= Y;\n+          p->M -= M;\n+          D = -D;\n+        }else{\n+          p->Y += Y;\n+          p->M += M;\n+        }\n+        x = p->M>0 ? (p->M-1)\/12 : (p->M-12)\/12;\n+        p->Y += x;\n+        p->M -= x*12;\n+        computeJD(p);\n+        p->validHMS = 0;\n+        p->validYMD = 0;\n+        p->iJD += (i64)D*86400000;\n+        if( z[11]==0 ){\n+          rc = 0;\n+          break;\n+        }\n+        if( sqlite3Isspace(z[11])\n+         && getDigits(&z[12], \"20c:20e\", &h, &m)==2\n+        ){\n+          z2 = &z[12];\n+          n = 2;\n+        }else{\n+          break;\n+        }\n+      }\n+      if( z2[n]==':' ){\n@@ -24117,1 +25084,1 @@\n-        const char *z2 = z;\n+\n@@ -24127,1 +25094,1 @@\n-        if( z[0]=='-' ) tx.iJD = -tx.iJD;\n+        if( z0=='-' ) tx.iJD = -tx.iJD;\n@@ -24143,1 +25110,1 @@\n-      rc = 1;\n+      assert( rc==1 );\n@@ -24152,1 +25119,0 @@\n-              int x;\n@@ -24228,0 +25194,6 @@\n+  if( argc==1 && p->validYMD && p->D>28 ){\n+    \/* Make sure a YYYY-MM-DD is normalized.\n+    ** Example: 2023-02-31 -> 2023-03-03 *\/\n+    assert( p->validJD );\n+    p->validYMD = 0;\n+  }\n@@ -24268,1 +25240,5 @@\n-    sqlite3_result_int64(context, x.iJD\/1000 - 21086676*(i64)10000);\n+    if( x.useSubsec ){\n+      sqlite3_result_double(context, (x.iJD - 21086676*(i64)10000000)\/1000.0);\n+    }else{\n+      sqlite3_result_int64(context, x.iJD\/1000 - 21086676*(i64)10000);\n+    }\n@@ -24284,2 +25260,2 @@\n-    int Y, s;\n-    char zBuf[24];\n+    int Y, s, n;\n+    char zBuf[32];\n@@ -24306,4 +25282,17 @@\n-    s = (int)x.s;\n-    zBuf[18] = '0' + (s\/10)%10;\n-    zBuf[19] = '0' + (s)%10;\n-    zBuf[20] = 0;\n+    if( x.useSubsec ){\n+      s = (int)(1000.0*x.s + 0.5);\n+      zBuf[18] = '0' + (s\/10000)%10;\n+      zBuf[19] = '0' + (s\/1000)%10;\n+      zBuf[20] = '.';\n+      zBuf[21] = '0' + (s\/100)%10;\n+      zBuf[22] = '0' + (s\/10)%10;\n+      zBuf[23] = '0' + (s)%10;\n+      zBuf[24] = 0;\n+      n = 24;\n+    }else{\n+      s = (int)x.s;\n+      zBuf[18] = '0' + (s\/10)%10;\n+      zBuf[19] = '0' + (s)%10;\n+      zBuf[20] = 0;\n+      n = 20;\n+    }\n@@ -24312,1 +25301,1 @@\n-      sqlite3_result_text(context, zBuf, 20, SQLITE_TRANSIENT);\n+      sqlite3_result_text(context, zBuf, n, SQLITE_TRANSIENT);\n@@ -24314,1 +25303,1 @@\n-      sqlite3_result_text(context, &zBuf[1], 19, SQLITE_TRANSIENT);\n+      sqlite3_result_text(context, &zBuf[1], n-1, SQLITE_TRANSIENT);\n@@ -24331,1 +25320,1 @@\n-    int s;\n+    int s, n;\n@@ -24340,5 +25329,18 @@\n-    s = (int)x.s;\n-    zBuf[6] = '0' + (s\/10)%10;\n-    zBuf[7] = '0' + (s)%10;\n-    zBuf[8] = 0;\n-    sqlite3_result_text(context, zBuf, 8, SQLITE_TRANSIENT);\n+    if( x.useSubsec ){\n+      s = (int)(1000.0*x.s + 0.5);\n+      zBuf[6] = '0' + (s\/10000)%10;\n+      zBuf[7] = '0' + (s\/1000)%10;\n+      zBuf[8] = '.';\n+      zBuf[9] = '0' + (s\/100)%10;\n+      zBuf[10] = '0' + (s\/10)%10;\n+      zBuf[11] = '0' + (s)%10;\n+      zBuf[12] = 0;\n+      n = 12;\n+    }else{\n+      s = (int)x.s;\n+      zBuf[6] = '0' + (s\/10)%10;\n+      zBuf[7] = '0' + (s)%10;\n+      zBuf[8] = 0;\n+      n = 8;\n+    }\n+    sqlite3_result_text(context, zBuf, n, SQLITE_TRANSIENT);\n@@ -24399,1 +25401,1 @@\n-**   %w  day of week 0-6  sunday==0\n+**   %w  day of week 0-6  Sunday==0\n@@ -24425,0 +25427,1 @@\n+    char cf;\n@@ -24429,3 +25432,5 @@\n-    switch( zFmt[i] ){\n-      case 'd': {\n-        sqlite3_str_appendf(&sRes, \"%02d\", x.D);\n+    cf = zFmt[i];\n+    switch( cf ){\n+      case 'd':  \/* Fall thru *\/\n+      case 'e': {\n+        sqlite3_str_appendf(&sRes, cf=='d' ? \"%02d\" : \"%2d\", x.D);\n@@ -24440,2 +25445,15 @@\n-      case 'H': {\n-        sqlite3_str_appendf(&sRes, \"%02d\", x.h);\n+      case 'F': {\n+        sqlite3_str_appendf(&sRes, \"%04d-%02d-%02d\", x.Y, x.M, x.D);\n+        break;\n+      }\n+      case 'H':\n+      case 'k': {\n+        sqlite3_str_appendf(&sRes, cf=='H' ? \"%02d\" : \"%2d\", x.h);\n+        break;\n+      }\n+      case 'I': \/* Fall thru *\/\n+      case 'l': {\n+        int h = x.h;\n+        if( h>12 ) h -= 12;\n+        if( h==0 ) h = 12;\n+        sqlite3_str_appendf(&sRes, cf=='I' ? \"%02d\" : \"%2d\", h);\n@@ -24453,1 +25471,1 @@\n-        if( zFmt[i]=='W' ){\n+        if( cf=='W' ){\n@@ -24474,0 +25492,13 @@\n+      case 'p': \/* Fall thru *\/\n+      case 'P': {\n+        if( x.h>=12 ){\n+          sqlite3_str_append(&sRes, cf=='p' ? \"PM\" : \"pm\", 2);\n+        }else{\n+          sqlite3_str_append(&sRes, cf=='p' ? \"AM\" : \"am\", 2);\n+        }\n+        break;\n+      }\n+      case 'R': {\n+        sqlite3_str_appendf(&sRes, \"%02d:%02d\", x.h, x.m);\n+        break;\n+      }\n@@ -24475,2 +25506,7 @@\n-        i64 iS = (i64)(x.iJD\/1000 - 21086676*(i64)10000);\n-        sqlite3_str_appendf(&sRes,\"%lld\",iS);\n+        if( x.useSubsec ){\n+          sqlite3_str_appendf(&sRes,\"%.3f\",\n+                (x.iJD - 21086676*(i64)10000000)\/1000.0);\n+        }else{\n+          i64 iS = (i64)(x.iJD\/1000 - 21086676*(i64)10000);\n+          sqlite3_str_appendf(&sRes,\"%lld\",iS);\n+        }\n@@ -24483,0 +25519,5 @@\n+      case 'T': {\n+        sqlite3_str_appendf(&sRes,\"%02d:%02d:%02d\", x.h, x.m, (int)x.s);\n+        break;\n+      }\n+      case 'u': \/* Fall thru *\/\n@@ -24484,2 +25525,3 @@\n-        sqlite3_str_appendchar(&sRes, 1,\n-                       (char)(((x.iJD+129600000)\/86400000) % 7) + '0');\n+        char c = (char)(((x.iJD+129600000)\/86400000) % 7) + '0';\n+        if( c=='0' && cf=='u' ) c = '7';\n+        sqlite3_str_appendchar(&sRes, 1, c);\n@@ -24534,0 +25576,111 @@\n+\/*\n+** timediff(DATE1, DATE2)\n+**\n+** Return the amount of time that must be added to DATE2 in order to\n+** convert it into DATE2.  The time difference format is:\n+**\n+**     +YYYY-MM-DD HH:MM:SS.SSS\n+**\n+** The initial \"+\" becomes \"-\" if DATE1 occurs before DATE2.  For\n+** date\/time values A and B, the following invariant should hold:\n+**\n+**     datetime(A) == (datetime(B, timediff(A,B))\n+**\n+** Both DATE arguments must be either a julian day number, or an\n+** ISO-8601 string.  The unix timestamps are not supported by this\n+** routine.\n+*\/\n+static void timediffFunc(\n+  sqlite3_context *context,\n+  int NotUsed1,\n+  sqlite3_value **argv\n+){\n+  char sign;\n+  int Y, M;\n+  DateTime d1, d2;\n+  sqlite3_str sRes;\n+  UNUSED_PARAMETER(NotUsed1);\n+  if( isDate(context, 1, &argv[0], &d1) ) return;\n+  if( isDate(context, 1, &argv[1], &d2) ) return;\n+  computeYMD_HMS(&d1);\n+  computeYMD_HMS(&d2);\n+  if( d1.iJD>=d2.iJD ){\n+    sign = '+';\n+    Y = d1.Y - d2.Y;\n+    if( Y ){\n+      d2.Y = d1.Y;\n+      d2.validJD = 0;\n+      computeJD(&d2);\n+    }\n+    M = d1.M - d2.M;\n+    if( M<0 ){\n+      Y--;\n+      M += 12;\n+    }\n+    if( M!=0 ){\n+      d2.M = d1.M;\n+      d2.validJD = 0;\n+      computeJD(&d2);\n+    }\n+    while( d1.iJD<d2.iJD ){\n+      M--;\n+      if( M<0 ){\n+        M = 11;\n+        Y--;\n+      }\n+      d2.M--;\n+      if( d2.M<1 ){\n+        d2.M = 12;\n+        d2.Y--;\n+      }\n+      d2.validJD = 0;\n+      computeJD(&d2);\n+    }\n+    d1.iJD -= d2.iJD;\n+    d1.iJD += (u64)1486995408 * (u64)100000;\n+  }else \/* d1<d2 *\/{\n+    sign = '-';\n+    Y = d2.Y - d1.Y;\n+    if( Y ){\n+      d2.Y = d1.Y;\n+      d2.validJD = 0;\n+      computeJD(&d2);\n+    }\n+    M = d2.M - d1.M;\n+    if( M<0 ){\n+      Y--;\n+      M += 12;\n+    }\n+    if( M!=0 ){\n+      d2.M = d1.M;\n+      d2.validJD = 0;\n+      computeJD(&d2);\n+    }\n+    while( d1.iJD>d2.iJD ){\n+      M--;\n+      if( M<0 ){\n+        M = 11;\n+        Y--;\n+      }\n+      d2.M++;\n+      if( d2.M>12 ){\n+        d2.M = 1;\n+        d2.Y++;\n+      }\n+      d2.validJD = 0;\n+      computeJD(&d2);\n+    }\n+    d1.iJD = d2.iJD - d1.iJD;\n+    d1.iJD += (u64)1486995408 * (u64)100000;\n+  }\n+  d1.validYMD = 0;\n+  d1.validHMS = 0;\n+  d1.validTZ = 0;\n+  computeYMD_HMS(&d1);\n+  sqlite3StrAccumInit(&sRes, 0, 0, 0, 100);\n+  sqlite3_str_appendf(&sRes, \"%c%04d-%02d-%02d %02d:%02d:%06.3f\",\n+       sign, Y, M, d1.D-1, d1.h, d1.m, d1.s);\n+  sqlite3ResultStrAccum(context, &sRes);\n+}\n+\n+\n@@ -24608,0 +25761,1 @@\n+    PURE_DATE(timediff,          2, 0, 0, timediffFunc  ),\n@@ -24730,0 +25884,1 @@\n+  assert( lockType>=SQLITE_LOCK_SHARED && lockType<=SQLITE_LOCK_EXCLUSIVE );\n@@ -24733,0 +25888,1 @@\n+  assert( lockType==SQLITE_LOCK_NONE || lockType==SQLITE_LOCK_SHARED );\n@@ -24759,1 +25915,1 @@\n-    ** confuses the test scripts - the COMMIT comand returns SQLITE_NOMEM\n+    ** confuses the test scripts - the COMMIT command returns SQLITE_NOMEM\n@@ -24847,0 +26003,1 @@\n+  assert( zPath || (flags & SQLITE_OPEN_EXCLUSIVE) );\n@@ -25379,1 +26536,1 @@\n-** cases where pPrior==0 will have been intecepted and dealt with\n+** cases where pPrior==0 will have been intercepted and dealt with\n@@ -25467,1 +26624,1 @@\n-  \/* One usually wants to use hw.acctivecpu for MT decisions, but not here *\/\n+  \/* One usually wants to use hw.activecpu for MT decisions, but not here *\/\n@@ -27162,1 +28319,5 @@\n-  if( n>0x40000000 ) return 0;\n+  if( n>0x10000000 ){\n+    if( n>0x40000000 ) return 0;\n+    if( n>0x20000000 ) return 0x40000000;\n+    return 0x20000000;\n+  }\n@@ -27164,1 +28325,1 @@\n-  if( (iFullSz\/2)>=n ) return iFullSz\/2;\n+  if( (iFullSz\/2)>=(i64)n ) return iFullSz\/2;\n@@ -27455,1 +28616,1 @@\n-#if SQLITE_ENABLE_API_ARMOR\n+#ifdef SQLITE_ENABLE_API_ARMOR\n@@ -27930,1 +29091,1 @@\n-** are necessary under two condidtions:  (1) Debug builds and (2) using\n+** are necessary under two conditions:  (1) Debug builds and (2) using\n@@ -28127,1 +29288,1 @@\n-#if SQLITE_ENABLE_API_ARMOR\n+#ifdef SQLITE_ENABLE_API_ARMOR\n@@ -28431,1 +29592,1 @@\n-  volatile int nRef;         \/* Number of enterances *\/\n+  volatile int nRef;         \/* Number of entrances *\/\n@@ -28480,1 +29641,1 @@\n-#elif MSVC_VERSION>=1300\n+#elif MSVC_VERSION>=1400\n@@ -29065,0 +30226,21 @@\n+\/*\n+** Maximum size of any single memory allocation.\n+**\n+** This is not a limit on the total amount of memory used.  This is\n+** a limit on the size parameter to sqlite3_malloc() and sqlite3_realloc().\n+**\n+** The upper bound is slightly less than 2GiB:  0x7ffffeff == 2,147,483,391\n+** This provides a 256-byte safety margin for defense against 32-bit\n+** signed integer overflow bugs when computing memory allocation sizes.\n+** Paranoid applications might want to reduce the maximum allocation size\n+** further for an even larger safety margin.  0x3fffffff or 0x0fffffff\n+** or even smaller would be reasonable upper bounds on the size of a memory\n+** allocations for most applications.\n+*\/\n+#ifndef SQLITE_MAX_ALLOCATION_SIZE\n+# define SQLITE_MAX_ALLOCATION_SIZE  2147483391\n+#endif\n+#if SQLITE_MAX_ALLOCATION_SIZE>2147483391\n+# error Maximum size for SQLITE_MAX_ALLOCATION_SIZE is 2147483391\n+#endif\n+\n@@ -29071,6 +30253,1 @@\n-  if( n==0 || n>=0x7fffff00 ){\n-    \/* A memory allocation of a number of bytes which is near the maximum\n-    ** signed integer value might cause an integer overflow inside of the\n-    ** xMalloc().  Hence we limit the maximum size to 0x7fffff00, giving\n-    ** 255 bytes of overhead.  SQLite itself will never use anything near\n-    ** this amount.  The only way to reach the limit is with sqlite3_malloc() *\/\n+  if( n==0 || n>SQLITE_MAX_ALLOCATION_SIZE ){\n@@ -29112,1 +30289,1 @@\n-  return SQLITE_WITHIN(p, db->lookaside.pStart, db->lookaside.pEnd);\n+  return SQLITE_WITHIN(p, db->lookaside.pStart, db->lookaside.pTrueEnd);\n@@ -29136,8 +30313,6 @@\n-  if( db==0 || !isLookaside(db,p) ){\n-    if( db==0 ){\n-      assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );\n-      assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );\n-    }else{\n-      assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );\n-      assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );\n-    }\n+  if( db==0 ){\n+    assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );\n+    assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );\n+  }else if( !isLookaside(db,p) ){\n+    assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );\n+    assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );\n@@ -29147,1 +30322,1 @@\n-    if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){\n+    if( ((uptr)p)<(uptr)(db->lookaside.pTrueEnd) ){\n@@ -29203,4 +30378,0 @@\n-    if( db->pnBytesFreed ){\n-      measureAllocationSize(db, p);\n-      return;\n-    }\n@@ -29211,0 +30382,1 @@\n+        assert( db->pnBytesFreed==0 );\n@@ -29221,0 +30393,1 @@\n+        assert( db->pnBytesFreed==0 );\n@@ -29229,0 +30402,4 @@\n+    if( db->pnBytesFreed ){\n+      measureAllocationSize(db, p);\n+      return;\n+    }\n@@ -29236,0 +30413,37 @@\n+SQLITE_PRIVATE void sqlite3DbNNFreeNN(sqlite3 *db, void *p){\n+  assert( db!=0 );\n+  assert( sqlite3_mutex_held(db->mutex) );\n+  assert( p!=0 );\n+  if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){\n+#ifndef SQLITE_OMIT_TWOSIZE_LOOKASIDE\n+    if( ((uptr)p)>=(uptr)(db->lookaside.pMiddle) ){\n+      LookasideSlot *pBuf = (LookasideSlot*)p;\n+      assert( db->pnBytesFreed==0 );\n+#ifdef SQLITE_DEBUG\n+      memset(p, 0xaa, LOOKASIDE_SMALL);  \/* Trash freed content *\/\n+#endif\n+      pBuf->pNext = db->lookaside.pSmallFree;\n+      db->lookaside.pSmallFree = pBuf;\n+      return;\n+    }\n+#endif \/* SQLITE_OMIT_TWOSIZE_LOOKASIDE *\/\n+    if( ((uptr)p)>=(uptr)(db->lookaside.pStart) ){\n+      LookasideSlot *pBuf = (LookasideSlot*)p;\n+      assert( db->pnBytesFreed==0 );\n+#ifdef SQLITE_DEBUG\n+      memset(p, 0xaa, db->lookaside.szTrue);  \/* Trash freed content *\/\n+#endif\n+      pBuf->pNext = db->lookaside.pFree;\n+      db->lookaside.pFree = pBuf;\n+      return;\n+    }\n+  }\n+  if( db->pnBytesFreed ){\n+    measureAllocationSize(db, p);\n+    return;\n+  }\n+  assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );\n+  assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );\n+  sqlite3MemdebugSetType(p, MEMTYPE_HEAP);\n+  sqlite3_free(p);\n+}\n@@ -29535,0 +30749,5 @@\n+#ifdef SQLITE_DEBUG\n+  \/* Because of the way the parser works, the span is guaranteed to contain\n+  ** at least one non-space character *\/\n+  for(n=0; sqlite3Isspace(zStart[n]); n++){ assert( &zStart[n]<zEnd ); }\n+#endif\n@@ -29537,1 +30756,1 @@\n-  while( ALWAYS(n>0) && sqlite3Isspace(zStart[n-1]) ) n--;\n+  while( sqlite3Isspace(zStart[n-1]) ) n--;\n@@ -29633,1 +30852,1 @@\n-  return rc & db->errMask;\n+  return 0;\n@@ -29745,37 +30964,0 @@\n-\/* Floating point constants used for rounding *\/\n-static const double arRound[] = {\n-  5.0e-01, 5.0e-02, 5.0e-03, 5.0e-04, 5.0e-05,\n-  5.0e-06, 5.0e-07, 5.0e-08, 5.0e-09, 5.0e-10,\n-};\n-\n-\/*\n-** If SQLITE_OMIT_FLOATING_POINT is defined, then none of the floating point\n-** conversions will work.\n-*\/\n-#ifndef SQLITE_OMIT_FLOATING_POINT\n-\/*\n-** \"*val\" is a double such that 0.1 <= *val < 10.0\n-** Return the ascii code for the leading digit of *val, then\n-** multiply \"*val\" by 10.0 to renormalize.\n-**\n-** Example:\n-**     input:     *val = 3.14159\n-**     output:    *val = 1.4159    function return = '3'\n-**\n-** The counter *cnt is incremented each time.  After counter exceeds\n-** 16 (the number of significant digits in a 64-bit float) '0' is\n-** always returned.\n-*\/\n-static char et_getdigit(LONGDOUBLE_TYPE *val, int *cnt){\n-  int digit;\n-  LONGDOUBLE_TYPE d;\n-  if( (*cnt)<=0 ) return '0';\n-  (*cnt)--;\n-  digit = (int)*val;\n-  d = digit;\n-  digit += '0';\n-  *val = (*val - d)*10.0;\n-  return (char)digit;\n-}\n-#endif \/* SQLITE_OMIT_FLOATING_POINT *\/\n-\n@@ -29873,1 +31055,1 @@\n-  LONGDOUBLE_TYPE realvalue; \/* Value for real types *\/\n+  double realvalue;          \/* Value for real types *\/\n@@ -29878,4 +31060,1 @@\n-#ifndef SQLITE_OMIT_FLOATING_POINT\n-  int  exp, e2;              \/* exponent of real numbers *\/\n-  int nsd;                   \/* Number of significant digits returned *\/\n-  double rounder;            \/* Used for rounding floating point values *\/\n+  int exp, e2;               \/* exponent of real numbers *\/\n@@ -29884,1 +31063,1 @@\n-#endif\n+\n@@ -30159,1 +31338,5 @@\n-      case etGENERIC:\n+      case etGENERIC: {\n+        FpDecode s;\n+        int iRound;\n+        int j;\n+\n@@ -30165,3 +31348,0 @@\n-#ifdef SQLITE_OMIT_FLOATING_POINT\n-        length = 0;\n-#else\n@@ -30174,11 +31354,0 @@\n-        if( realvalue<0.0 ){\n-          realvalue = -realvalue;\n-          prefix = '-';\n-        }else{\n-          prefix = flag_prefix;\n-        }\n-        if( xtype==etGENERIC && precision>0 ) precision--;\n-        testcase( precision>0xfff );\n-        idx = precision & 0xfff;\n-        rounder = arRound[idx%10];\n-        while( idx>=10 ){ rounder *= 1.0e-10; idx -= 10; }\n@@ -30186,14 +31355,6 @@\n-          double rx = (double)realvalue;\n-          sqlite3_uint64 u;\n-          int ex;\n-          memcpy(&u, &rx, sizeof(u));\n-          ex = -1023 + (int)((u>>52)&0x7ff);\n-          if( precision+(ex\/3) < 15 ) rounder += realvalue*3e-16;\n-          realvalue += rounder;\n-        }\n-        \/* Normalize realvalue to within 10.0 > realvalue >= 1.0 *\/\n-        exp = 0;\n-        if( sqlite3IsNaN((double)realvalue) ){\n-          bufpt = \"NaN\";\n-          length = 3;\n-          break;\n+          iRound = -precision;\n+        }else if( xtype==etGENERIC ){\n+          if( precision==0 ) precision = 1;\n+          iRound = precision;\n+        }else{\n+          iRound = precision+1;\n@@ -30201,9 +31362,12 @@\n-        if( realvalue>0.0 ){\n-          LONGDOUBLE_TYPE scale = 1.0;\n-          while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}\n-          while( realvalue>=1e10*scale && exp<=350 ){ scale *= 1e10; exp+=10; }\n-          while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }\n-          realvalue \/= scale;\n-          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }\n-          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }\n-          if( exp>350 ){\n+        sqlite3FpDecode(&s, realvalue, iRound, flag_altform2 ? 26 : 16);\n+        if( s.isSpecial ){\n+          if( s.isSpecial==2 ){\n+            bufpt = flag_zeropad ? \"null\" : \"NaN\";\n+            length = sqlite3Strlen30(bufpt);\n+            break;\n+          }else if( flag_zeropad ){\n+            s.z[0] = '9';\n+            s.iDP = 1000;\n+            s.n = 1;\n+          }else{\n+            memcpy(buf, \"-Inf\", 5);\n@@ -30211,3 +31375,8 @@\n-            buf[0] = prefix;\n-            memcpy(buf+(prefix!=0),\"Inf\",4);\n-            length = 3+(prefix!=0);\n+            if( s.sign=='-' ){\n+              \/* no-op *\/\n+            }else if( flag_prefix ){\n+              buf[0] = flag_prefix;\n+            }else{\n+              bufpt++;\n+            }\n+            length = sqlite3Strlen30(bufpt);\n@@ -30217,1 +31386,9 @@\n-        bufpt = buf;\n+        if( s.sign=='-' ){\n+          prefix = '-';\n+        }else{\n+          prefix = flag_prefix;\n+        }\n+\n+        exp = s.iDP-1;\n+        if( xtype==etGENERIC && precision>0 ) precision--;\n+\n@@ -30222,4 +31399,0 @@\n-        if( xtype!=etFLOAT ){\n-          realvalue += rounder;\n-          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }\n-        }\n@@ -30240,1 +31413,1 @@\n-          e2 = exp;\n+          e2 = s.iDP - 1;\n@@ -30242,0 +31415,1 @@\n+        bufpt = buf;\n@@ -30245,0 +31419,1 @@\n+          if( cThousand && e2>0 ) szBufNeeded += (e2+2)\/3;\n@@ -30251,1 +31426,0 @@\n-        nsd = 16 + flag_altform2*10;\n@@ -30258,0 +31432,1 @@\n+        j = 0;\n@@ -30262,1 +31437,2 @@\n-            *(bufpt++) = et_getdigit(&realvalue,&nsd);\n+            *(bufpt++) = j<s.n ? s.z[j++] : '0';\n+            if( cThousand && (e2%3)==0 && e2>1 ) *(bufpt++) = ',';\n@@ -30271,2 +31447,1 @@\n-        for(e2++; e2<0; precision--, e2++){\n-          assert( precision>0 );\n+        for(e2++; e2<0 && precision>0; precision--, e2++){\n@@ -30277,1 +31452,1 @@\n-          *(bufpt++) = et_getdigit(&realvalue,&nsd);\n+          *(bufpt++) = j<s.n ? s.z[j++] : '0';\n@@ -30293,0 +31468,1 @@\n+          exp = s.iDP - 1;\n@@ -30326,1 +31502,0 @@\n-#endif \/* !defined(SQLITE_OMIT_FLOATING_POINT) *\/\n@@ -30328,0 +31503,1 @@\n+      }\n@@ -30376,0 +31552,1 @@\n+          i64 nPrior = 1;\n@@ -30381,2 +31558,14 @@\n-          while( precision-- > 1 ){\n-            sqlite3_str_append(pAccum, buf, length);\n+          sqlite3_str_append(pAccum, buf, length);\n+          precision--;\n+          while( precision > 1 ){\n+            i64 nCopyBytes;\n+            if( nPrior > precision-1 ) nPrior = precision - 1;\n+            nCopyBytes = length*nPrior;\n+            if( nCopyBytes + pAccum->nChar >= pAccum->nAlloc ){\n+              sqlite3StrAccumEnlarge(pAccum, nCopyBytes);\n+            }\n+            if( pAccum->accError ) break;\n+            sqlite3_str_append(pAccum,\n+                 &pAccum->zText[pAccum->nChar-nCopyBytes], nCopyBytes);\n+            precision -= nPrior;\n+            nPrior *= 2;\n@@ -30610,1 +31799,1 @@\n-SQLITE_PRIVATE int sqlite3StrAccumEnlarge(StrAccum *p, int N){\n+SQLITE_PRIVATE int sqlite3StrAccumEnlarge(StrAccum *p, i64 N){\n@@ -30612,1 +31801,1 @@\n-  assert( p->nChar+(i64)N >= p->nAlloc ); \/* Only called if really needed *\/\n+  assert( p->nChar+N >= p->nAlloc ); \/* Only called if really needed *\/\n@@ -30623,2 +31812,1 @@\n-    i64 szNew = p->nChar;\n-    szNew += (sqlite3_int64)N + 1;\n+    i64 szNew = p->nChar + N + 1;\n@@ -30654,1 +31842,2 @@\n-  return N;\n+  assert( N>=0 && N<=0x7fffffff );\n+  return (int)N;\n@@ -30945,1 +32134,1 @@\n-  char *z;\n+  StrAccum acc;\n@@ -30947,0 +32136,9 @@\n+  if( n<=0 ) return zBuf;\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( zBuf==0 || zFormat==0 ) {\n+    (void)SQLITE_MISUSE_BKPT;\n+    if( zBuf ) zBuf[0] = 0;\n+    return zBuf;\n+  }\n+#endif\n+  sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);\n@@ -30948,1 +32146,1 @@\n-  z = sqlite3_vsnprintf(n, zBuf, zFormat, ap);\n+  sqlite3_str_vappendf(&acc, zFormat, ap);\n@@ -30950,1 +32148,2 @@\n-  return z;\n+  zBuf[acc.nChar] = 0;\n+  return zBuf;\n@@ -31028,0 +32227,69 @@\n+\n+\/*****************************************************************************\n+** Reference counted string\/blob storage\n+*****************************************************************************\/\n+\n+\/*\n+** Increase the reference count of the string by one.\n+**\n+** The input parameter is returned.\n+*\/\n+SQLITE_PRIVATE char *sqlite3RCStrRef(char *z){\n+  RCStr *p = (RCStr*)z;\n+  assert( p!=0 );\n+  p--;\n+  p->nRCRef++;\n+  return z;\n+}\n+\n+\/*\n+** Decrease the reference count by one.  Free the string when the\n+** reference count reaches zero.\n+*\/\n+SQLITE_PRIVATE void sqlite3RCStrUnref(void *z){\n+  RCStr *p = (RCStr*)z;\n+  assert( p!=0 );\n+  p--;\n+  assert( p->nRCRef>0 );\n+  if( p->nRCRef>=2 ){\n+    p->nRCRef--;\n+  }else{\n+    sqlite3_free(p);\n+  }\n+}\n+\n+\/*\n+** Create a new string that is capable of holding N bytes of text, not counting\n+** the zero byte at the end.  The string is uninitialized.\n+**\n+** The reference count is initially 1.  Call sqlite3RCStrUnref() to free the\n+** newly allocated string.\n+**\n+** This routine returns 0 on an OOM.\n+*\/\n+SQLITE_PRIVATE char *sqlite3RCStrNew(u64 N){\n+  RCStr *p = sqlite3_malloc64( N + sizeof(*p) + 1 );\n+  if( p==0 ) return 0;\n+  p->nRCRef = 1;\n+  return (char*)&p[1];\n+}\n+\n+\/*\n+** Change the size of the string so that it is able to hold N bytes.\n+** The string might be reallocated, so return the new allocation.\n+*\/\n+SQLITE_PRIVATE char *sqlite3RCStrResize(char *z, u64 N){\n+  RCStr *p = (RCStr*)z;\n+  RCStr *pNew;\n+  assert( p!=0 );\n+  p--;\n+  assert( p->nRCRef==1 );\n+  pNew = sqlite3_realloc64(p, N+sizeof(RCStr)+1);\n+  if( pNew==0 ){\n+    sqlite3_free(p);\n+    return 0;\n+  }else{\n+    return (char*)&pNew[1];\n+  }\n+}\n+\n@@ -31250,0 +32518,7 @@\n+    if( pItem->fg.isTabFunc )      sqlite3_str_appendf(&x, \" isTabFunc\");\n+    if( pItem->fg.isCorrelated )   sqlite3_str_appendf(&x, \" isCorrelated\");\n+    if( pItem->fg.isMaterialized ) sqlite3_str_appendf(&x, \" isMaterialized\");\n+    if( pItem->fg.viaCoroutine )   sqlite3_str_appendf(&x, \" viaCoroutine\");\n+    if( pItem->fg.notCte )         sqlite3_str_appendf(&x, \" notCte\");\n+    if( pItem->fg.isNestedFrom )   sqlite3_str_appendf(&x, \" isNestedFrom\");\n+\n@@ -31437,0 +32712,1 @@\n+    if( pWin->eFrmType==TK_FILTER ) return;\n@@ -31446,1 +32722,1 @@\n-  if( pWin->eFrmType ) nElement++;\n+  if( pWin->eFrmType!=0 && pWin->eFrmType!=TK_FILTER ) nElement++;\n@@ -31459,1 +32735,1 @@\n-  if( pWin->eFrmType ){\n+  if( pWin->eFrmType!=0 && pWin->eFrmType!=TK_FILTER ){\n@@ -31519,1 +32795,1 @@\n-  if( pExpr->flags || pExpr->affExpr || pExpr->vvaFlags ){\n+  if( pExpr->flags || pExpr->affExpr || pExpr->vvaFlags || pExpr->pAggInfo ){\n@@ -31536,0 +32812,3 @@\n+    if( pExpr->pAggInfo!=0 ){\n+      sqlite3_str_appendf(&x, \" agg-column[%d]\", pExpr->iAgg);\n+    }\n@@ -31665,1 +32944,2 @@\n-      assert( sqlite3ExprSkipCollate(pExpr->pRight)->op==TK_TRUEFALSE );\n+      assert( sqlite3ExprSkipCollateAndLikely(pExpr->pRight)->op\n+                  == TK_TRUEFALSE );\n@@ -31703,1 +32983,1 @@\n-        pWin = ExprHasProperty(pExpr, EP_WinFunc) ? pExpr->y.pWin : 0;\n+        pWin = IsWindowFunc(pExpr) ? pExpr->y.pWin : 0;\n@@ -31729,1 +33009,7 @@\n-        sqlite3TreeViewExprList(pView, pFarg, pWin!=0, 0);\n+        sqlite3TreeViewExprList(pView, pFarg, pWin!=0 || pExpr->pLeft, 0);\n+        if( pExpr->pLeft ){\n+          Expr *pOB = pExpr->pLeft;\n+          assert( pOB->op==TK_ORDER );\n+          assert( ExprUseXList(pOB) );\n+          sqlite3TreeViewExprList(pView, pOB->x.pList, pWin!=0, \"ORDERBY\");\n+        }\n@@ -31738,0 +33024,4 @@\n+    case TK_ORDER: {\n+      sqlite3TreeViewExprList(pView, pExpr->x.pList, 0, \"ORDERBY\");\n+      break;\n+    }\n@@ -31791,1 +33081,1 @@\n-      sqlite3TreeViewLine(pView, \"BETWEEN\");\n+      sqlite3TreeViewLine(pView, \"BETWEEN%s\", zFlgs);\n@@ -32347,3 +33637,3 @@\n-  unsigned char isInit;          \/* True if initialized *\/\n-  unsigned char i, j;            \/* State variables *\/\n-  unsigned char s[256];          \/* State variables *\/\n+  u32 s[16];                 \/* 64 bytes of chacha20 state *\/\n+  u8 out[64];                \/* Output bytes *\/\n+  u8 n;                      \/* Output bytes remaining *\/\n@@ -32352,0 +33642,26 @@\n+\n+\/* The RFC-7539 ChaCha20 block function\n+*\/\n+#define ROTL(a,b) (((a) << (b)) | ((a) >> (32 - (b))))\n+#define QR(a, b, c, d) ( \\\n+    a += b, d ^= a, d = ROTL(d,16), \\\n+    c += d, b ^= c, b = ROTL(b,12), \\\n+    a += b, d ^= a, d = ROTL(d, 8), \\\n+    c += d, b ^= c, b = ROTL(b, 7))\n+static void chacha_block(u32 *out, const u32 *in){\n+  int i;\n+  u32 x[16];\n+  memcpy(x, in, 64);\n+  for(i=0; i<10; i++){\n+    QR(x[0], x[4], x[ 8], x[12]);\n+    QR(x[1], x[5], x[ 9], x[13]);\n+    QR(x[2], x[6], x[10], x[14]);\n+    QR(x[3], x[7], x[11], x[15]);\n+    QR(x[0], x[5], x[10], x[15]);\n+    QR(x[1], x[6], x[11], x[12]);\n+    QR(x[2], x[7], x[ 8], x[13]);\n+    QR(x[3], x[4], x[ 9], x[14]);\n+  }\n+  for(i=0; i<16; i++) out[i] = x[i]+in[i];\n+}\n+\n@@ -32356,1 +33672,0 @@\n-  unsigned char t;\n@@ -32386,1 +33701,1 @@\n-    wsdPrng.isInit = 0;\n+    wsdPrng.s[0] = 0;\n@@ -32392,7 +33707,1 @@\n-  ** the first time this routine is called.  The seed value does\n-  ** not need to contain a lot of randomness since we are not\n-  ** trying to do secure encryption or anything like that...\n-  **\n-  ** Nothing in this file or anywhere else in SQLite does any kind of\n-  ** encryption.  The RC4 algorithm is being used as a PRNG (pseudo-random\n-  ** number generator) not as an encryption device.\n+  ** the first time this routine is called.\n@@ -32400,1 +33709,1 @@\n-  if( !wsdPrng.isInit ){\n+  if( wsdPrng.s[0]==0 ){\n@@ -32402,4 +33711,4 @@\n-    int i;\n-    char k[256];\n-    wsdPrng.j = 0;\n-    wsdPrng.i = 0;\n+    static const u32 chacha20_init[] = {\n+      0x61707865, 0x3320646e, 0x79622d32, 0x6b206574\n+    };\n+    memcpy(&wsdPrng.s[0], chacha20_init, 16);\n@@ -32407,1 +33716,1 @@\n-      memset(k, 0, sizeof(k));\n+      memset(&wsdPrng.s[4], 0, 44);\n@@ -32409,10 +33718,1 @@\n-      sqlite3OsRandomness(pVfs, 256, k);\n-    }\n-    for(i=0; i<256; i++){\n-      wsdPrng.s[i] = (u8)i;\n-    }\n-    for(i=0; i<256; i++){\n-      wsdPrng.j += wsdPrng.s[i] + k[i];\n-      t = wsdPrng.s[wsdPrng.j];\n-      wsdPrng.s[wsdPrng.j] = wsdPrng.s[i];\n-      wsdPrng.s[i] = t;\n+      sqlite3OsRandomness(pVfs, 44, (char*)&wsdPrng.s[4]);\n@@ -32420,1 +33720,3 @@\n-    wsdPrng.isInit = 1;\n+    wsdPrng.s[15] = wsdPrng.s[12];\n+    wsdPrng.s[12] = 0;\n+    wsdPrng.n = 0;\n@@ -32424,9 +33726,15 @@\n-  do{\n-    wsdPrng.i++;\n-    t = wsdPrng.s[wsdPrng.i];\n-    wsdPrng.j += t;\n-    wsdPrng.s[wsdPrng.i] = wsdPrng.s[wsdPrng.j];\n-    wsdPrng.s[wsdPrng.j] = t;\n-    t += wsdPrng.s[wsdPrng.i];\n-    *(zBuf++) = wsdPrng.s[t];\n-  }while( --N );\n+  while( 1 \/* exit by break *\/ ){\n+    if( N<=wsdPrng.n ){\n+      memcpy(zBuf, &wsdPrng.out[wsdPrng.n-N], N);\n+      wsdPrng.n -= N;\n+      break;\n+    }\n+    if( wsdPrng.n>0 ){\n+      memcpy(zBuf, wsdPrng.out, wsdPrng.n);\n+      N -= wsdPrng.n;\n+      zBuf += wsdPrng.n;\n+    }\n+    wsdPrng.s[12]++;\n+    chacha_block((u32*)wsdPrng.out, wsdPrng.s);\n+    wsdPrng.n = 64;\n+  }\n@@ -32908,1 +34216,32 @@\n-\n+\/*\n+** Read a single UTF8 character out of buffer z[], but reading no\n+** more than n characters from the buffer.  z[] is not zero-terminated.\n+**\n+** Return the number of bytes used to construct the character.\n+**\n+** Invalid UTF8 might generate a strange result.  No effort is made\n+** to detect invalid UTF8.\n+**\n+** At most 4 bytes will be read out of z[].  The return value will always\n+** be between 1 and 4.\n+*\/\n+SQLITE_PRIVATE int sqlite3Utf8ReadLimited(\n+  const u8 *z,\n+  int n,\n+  u32 *piOut\n+){\n+  u32 c;\n+  int i = 1;\n+  assert( n>0 );\n+  c = z[0];\n+  if( c>=0xc0 ){\n+    c = sqlite3Utf8Trans1[c-0xc0];\n+    if( n>4 ) n = 4;\n+    while( i<n && (z[i] & 0xc0)==0x80 ){\n+      c = (c<<6) + (0x3f & z[i]);\n+      i++;\n+    }\n+  }\n+  *piOut = c;\n+  return i;\n+}\n@@ -33306,1 +34645,1 @@\n-** execute proceed futher downstream.\n+** execute proceed further downstream.\n@@ -33350,0 +34689,13 @@\n+#ifndef SQLITE_OMIT_FLOATING_POINT\n+\/*\n+** Return true if the floating point value is NaN or +Inf or -Inf.\n+*\/\n+SQLITE_PRIVATE int sqlite3IsOverflow(double x){\n+  int rc;   \/* The value return *\/\n+  u64 y;\n+  memcpy(&y,&x,sizeof(y));\n+  rc = IsOvfl(y);\n+  return rc;\n+}\n+#endif \/* SQLITE_OMIT_FLOATING_POINT *\/\n+\n@@ -33423,0 +34775,17 @@\n+#if defined(SQLITE_USE_SEH) && !defined(SQLITE_OMIT_WAL)\n+  if( rc==SQLITE_IOERR_IN_PAGE ){\n+    int ii;\n+    int iErr;\n+    sqlite3BtreeEnterAll(db);\n+    for(ii=0; ii<db->nDb; ii++){\n+      if( db->aDb[ii].pBt ){\n+        iErr = sqlite3PagerWalSystemErrno(sqlite3BtreePager(db->aDb[ii].pBt));\n+        if( iErr ){\n+          db->iSysErrno = iErr;\n+        }\n+      }\n+    }\n+    sqlite3BtreeLeaveAll(db);\n+    return;\n+  }\n+#endif\n@@ -33457,0 +34826,24 @@\n+\/*\n+** Check for interrupts and invoke progress callback.\n+*\/\n+SQLITE_PRIVATE void sqlite3ProgressCheck(Parse *p){\n+  sqlite3 *db = p->db;\n+  if( AtomicLoad(&db->u1.isInterrupted) ){\n+    p->nErr++;\n+    p->rc = SQLITE_INTERRUPT;\n+  }\n+#ifndef SQLITE_OMIT_PROGRESS_CALLBACK\n+  if( db->xProgress ){\n+    if( p->rc==SQLITE_INTERRUPT ){\n+      p->nProgressSteps = 0;\n+    }else if( (++p->nProgressSteps)>=db->nProgressOps ){\n+      if( db->xProgress(db->pProgressArg) ){\n+        p->nErr++;\n+        p->rc = SQLITE_INTERRUPT;\n+      }\n+      p->nProgressSteps = 0;\n+    }\n+  }\n+#endif\n+}\n+\n@@ -33648,3 +35041,1 @@\n-\/*\n-** Compute 10 to the E-th power.  Examples:  E==1 results in 10.\n-** E==2 results in 100.  E==50 results in 1.0e50.\n+\/* Double-Double multiplication.  (x[0],x[1]) *= (y,yy)\n@@ -33652,1 +35043,3 @@\n-** This routine only works for values of E between 1 and 341.\n+** Reference:\n+**   T. J. Dekker, \"A Floating-Point Technique for Extending the\n+**   Available Precision\".  1971-07-26.\n@@ -33654,31 +35047,28 @@\n-static LONGDOUBLE_TYPE sqlite3Pow10(int E){\n-#if defined(_MSC_VER)\n-  static const LONGDOUBLE_TYPE x[] = {\n-    1.0e+001L,\n-    1.0e+002L,\n-    1.0e+004L,\n-    1.0e+008L,\n-    1.0e+016L,\n-    1.0e+032L,\n-    1.0e+064L,\n-    1.0e+128L,\n-    1.0e+256L\n-  };\n-  LONGDOUBLE_TYPE r = 1.0;\n-  int i;\n-  assert( E>=0 && E<=307 );\n-  for(i=0; E!=0; i++, E >>=1){\n-    if( E & 1 ) r *= x[i];\n-  }\n-  return r;\n-#else\n-  LONGDOUBLE_TYPE x = 10.0;\n-  LONGDOUBLE_TYPE r = 1.0;\n-  while(1){\n-    if( E & 1 ) r *= x;\n-    E >>= 1;\n-    if( E==0 ) break;\n-    x *= x;\n-  }\n-  return r;\n-#endif\n+static void dekkerMul2(volatile double *x, double y, double yy){\n+  \/*\n+  ** The \"volatile\" keywords on parameter x[] and on local variables\n+  ** below are needed force intermediate results to be truncated to\n+  ** binary64 rather than be carried around in an extended-precision\n+  ** format.  The truncation is necessary for the Dekker algorithm to\n+  ** work.  Intel x86 floating point might omit the truncation without\n+  ** the use of volatile.\n+  *\/\n+  volatile double tx, ty, p, q, c, cc;\n+  double hx, hy;\n+  u64 m;\n+  memcpy(&m, (void*)&x[0], 8);\n+  m &= 0xfffffffffc000000LL;\n+  memcpy(&hx, &m, 8);\n+  tx = x[0] - hx;\n+  memcpy(&m, &y, 8);\n+  m &= 0xfffffffffc000000LL;\n+  memcpy(&hy, &m, 8);\n+  ty = y - hy;\n+  p = hx*hy;\n+  q = hx*ty + tx*hy;\n+  c = p+q;\n+  cc = p - c + q + tx*ty;\n+  cc = x[0]*yy + x[1]*y + cc;\n+  x[0] = c + cc;\n+  x[1] = c - x[0];\n+  x[1] += cc;\n@@ -33725,1 +35115,1 @@\n-  i64 s = 0;       \/* significand *\/\n+  u64 s = 0;       \/* significand *\/\n@@ -33730,1 +35120,0 @@\n-  double result;\n@@ -33770,1 +35159,1 @@\n-    if( s>=((LARGEST_INT64-9)\/10) ){\n+    if( s>=((LARGEST_UINT64-9)\/10) ){\n@@ -33785,1 +35174,1 @@\n-      if( s<((LARGEST_INT64-9)\/10) ){\n+      if( s<((LARGEST_UINT64-9)\/10) ){\n@@ -33825,7 +35214,4 @@\n-  \/* adjust exponent by d, and update sign *\/\n-  e = (e*esign) + d;\n-  if( e<0 ) {\n-    esign = -1;\n-    e *= -1;\n-  } else {\n-    esign = 1;\n+  \/* Zero is a special case *\/\n+  if( s==0 ){\n+    *pResult = sign<0 ? -0.0 : +0.0;\n+    goto atof_return;\n@@ -33834,20 +35220,2 @@\n-  if( s==0 ) {\n-    \/* In the IEEE 754 standard, zero is signed. *\/\n-    result = sign<0 ? -(double)0 : (double)0;\n-  } else {\n-    \/* Attempt to reduce exponent.\n-    **\n-    ** Branches that are not required for the correct answer but which only\n-    ** help to obtain the correct answer faster are marked with special\n-    ** comments, as a hint to the mutation tester.\n-    *\/\n-    while( e>0 ){                                       \/*OPTIMIZATION-IF-TRUE*\/\n-      if( esign>0 ){\n-        if( s>=(LARGEST_INT64\/10) ) break;             \/*OPTIMIZATION-IF-FALSE*\/\n-        s *= 10;\n-      }else{\n-        if( s%10!=0 ) break;                           \/*OPTIMIZATION-IF-FALSE*\/\n-        s \/= 10;\n-      }\n-      e--;\n-    }\n+  \/* adjust exponent by d, and update sign *\/\n+  e = (e*esign) + d;\n@@ -33855,2 +35223,9 @@\n-    \/* adjust the sign of significand *\/\n-    s = sign<0 ? -s : s;\n+  \/* Try to adjust the exponent to make it smaller *\/\n+  while( e>0 && s<(LARGEST_UINT64\/10) ){\n+    s *= 10;\n+    e--;\n+  }\n+  while( e<0 && (s%10)==0 ){\n+    s \/= 10;\n+    e++;\n+  }\n@@ -33858,2 +35233,8 @@\n-    if( e==0 ){                                         \/*OPTIMIZATION-IF-TRUE*\/\n-      result = (double)s;\n+  if( e==0 ){\n+    *pResult = s;\n+  }else if( sqlite3Config.bUseLongDouble ){\n+    LONGDOUBLE_TYPE r = (LONGDOUBLE_TYPE)s;\n+    if( e>0 ){\n+      while( e>=100  ){ e-=100; r *= 1.0e+100L; }\n+      while( e>=10   ){ e-=10;  r *= 1.0e+10L;  }\n+      while( e>=1    ){ e-=1;   r *= 1.0e+01L;  }\n@@ -33861,15 +35242,6 @@\n-      \/* attempt to handle extremely small\/large numbers better *\/\n-      if( e>307 ){                                      \/*OPTIMIZATION-IF-TRUE*\/\n-        if( e<342 ){                                    \/*OPTIMIZATION-IF-TRUE*\/\n-          LONGDOUBLE_TYPE scale = sqlite3Pow10(e-308);\n-          if( esign<0 ){\n-            result = s \/ scale;\n-            result \/= 1.0e+308;\n-          }else{\n-            result = s * scale;\n-            result *= 1.0e+308;\n-          }\n-        }else{ assert( e>=342 );\n-          if( esign<0 ){\n-            result = 0.0*s;\n-          }else{\n+      while( e<=-100 ){ e+=100; r *= 1.0e-100L; }\n+      while( e<=-10  ){ e+=10;  r *= 1.0e-10L;  }\n+      while( e<=-1   ){ e+=1;   r *= 1.0e-01L;  }\n+    }\n+    assert( r>=0.0 );\n+    if( r>+1.7976931348623157081452742373e+308L ){\n@@ -33877,1 +35249,1 @@\n-            result = INFINITY*s;\n+      *pResult = +INFINITY;\n@@ -33879,1 +35251,1 @@\n-            result = 1e308*1e308*s;  \/* Infinity *\/\n+      *pResult = 1.0e308*10.0;\n@@ -33881,9 +35253,37 @@\n-          }\n-        }\n-      }else{\n-        LONGDOUBLE_TYPE scale = sqlite3Pow10(e);\n-        if( esign<0 ){\n-          result = s \/ scale;\n-        }else{\n-          result = s * scale;\n-        }\n+    }else{\n+      *pResult = (double)r;\n+    }\n+  }else{\n+    double rr[2];\n+    u64 s2;\n+    rr[0] = (double)s;\n+    s2 = (u64)rr[0];\n+#if defined(_MSC_VER) && _MSC_VER<1700\n+    if( s2==0x8000000000000000LL ){ s2 = 2*(u64)(0.5*rr[0]); }\n+#endif\n+    rr[1] = s>=s2 ? (double)(s - s2) : -(double)(s2 - s);\n+    if( e>0 ){\n+      while( e>=100  ){\n+        e -= 100;\n+        dekkerMul2(rr, 1.0e+100, -1.5902891109759918046e+83);\n+      }\n+      while( e>=10   ){\n+        e -= 10;\n+        dekkerMul2(rr, 1.0e+10, 0.0);\n+      }\n+      while( e>=1    ){\n+        e -= 1;\n+        dekkerMul2(rr, 1.0e+01, 0.0);\n+      }\n+    }else{\n+      while( e<=-100 ){\n+        e += 100;\n+        dekkerMul2(rr, 1.0e-100, -1.99918998026028836196e-117);\n+      }\n+      while( e<=-10  ){\n+        e += 10;\n+        dekkerMul2(rr, 1.0e-10, -3.6432197315497741579e-27);\n+      }\n+      while( e<=-1   ){\n+        e += 1;\n+        dekkerMul2(rr, 1.0e-01, -5.5511151231257827021e-18);\n@@ -33892,0 +35292,2 @@\n+    *pResult = rr[0]+rr[1];\n+    if( sqlite3IsNaN(*pResult) ) *pResult = 1e300*1e300;\n@@ -33893,0 +35295,2 @@\n+  if( sign<0 ) *pResult = -*pResult;\n+  assert( !sqlite3IsNaN(*pResult) );\n@@ -33894,4 +35298,2 @@\n-  \/* store the result *\/\n-  *pResult = result;\n-\n-  \/* return true if number and no extra non-whitespace chracters after *\/\n+atof_return:\n+  \/* return true if number and no extra non-whitespace characters after *\/\n@@ -33914,1 +35316,4 @@\n-** Render an signed 64-bit integer as text.  Store the result in zOut[].\n+** Render an signed 64-bit integer as text.  Store the result in zOut[] and\n+** return the length of the string that was stored, in bytes.  The value\n+** returned does not include the zero terminator at the end of the output\n+** string.\n@@ -33918,1 +35323,1 @@\n-SQLITE_PRIVATE void sqlite3Int64ToText(i64 v, char *zOut){\n+SQLITE_PRIVATE int sqlite3Int64ToText(i64 v, char *zOut){\n@@ -33929,2 +35334,2 @@\n-  do{\n-    zTemp[i--] = (x%10) + '0';\n+  while( 1 \/*exit-by-break*\/ ){\n+    zTemp[i] = (x%10) + '0';\n@@ -33932,3 +35337,6 @@\n-  }while( x );\n-  if( v<0 ) zTemp[i--] = '-';\n-  memcpy(zOut, &zTemp[i+1], sizeof(zTemp)-1-i);\n+    if( x==0 ) break;\n+    i--;\n+  };\n+  if( v<0 ) zTemp[--i] = '-';\n+  memcpy(zOut, &zTemp[i], sizeof(zTemp)-i);\n+  return sizeof(zTemp)-1-i;\n@@ -34027,1 +35435,1 @@\n-    ** them, but we must appaise the undefined-behavior pharisees. *\/\n+    ** them, but we must appease the undefined-behavior pharisees. *\/\n@@ -34099,1 +35507,3 @@\n-    return (z[k]==0 && k-i<=16) ? 0 : 2;\n+    if( k-i>16 ) return 2;\n+    if( z[k]!=0 ) return 1;\n+    return 0;\n@@ -34103,1 +35513,3 @@\n-    return sqlite3Atoi64(z, pOut, sqlite3Strlen30(z), SQLITE_UTF8);\n+    int n = (int)(0x3fffffff&strspn(z,\"+- \\n\\t0123456789\"));\n+    if( z[n] ) n++;\n+    return sqlite3Atoi64(z, pOut, n, SQLITE_UTF8);\n@@ -34135,1 +35547,1 @@\n-    for(i=0; sqlite3Isxdigit(zNum[i]) && i<8; i++){\n+    for(i=0; i<8 && sqlite3Isxdigit(zNum[i]); i++){\n@@ -34182,0 +35594,147 @@\n+\/*\n+** Decode a floating-point value into an approximate decimal\n+** representation.\n+**\n+** Round the decimal representation to n significant digits if\n+** n is positive.  Or round to -n signficant digits after the\n+** decimal point if n is negative.  No rounding is performed if\n+** n is zero.\n+**\n+** The significant digits of the decimal representation are\n+** stored in p->z[] which is a often (but not always) a pointer\n+** into the middle of p->zBuf[].  There are p->n significant digits.\n+** The p->z[] array is *not* zero-terminated.\n+*\/\n+SQLITE_PRIVATE void sqlite3FpDecode(FpDecode *p, double r, int iRound, int mxRound){\n+  int i;\n+  u64 v;\n+  int e, exp = 0;\n+  p->isSpecial = 0;\n+  p->z = p->zBuf;\n+\n+  \/* Convert negative numbers to positive.  Deal with Infinity, 0.0, and\n+  ** NaN. *\/\n+  if( r<0.0 ){\n+    p->sign = '-';\n+    r = -r;\n+  }else if( r==0.0 ){\n+    p->sign = '+';\n+    p->n = 1;\n+    p->iDP = 1;\n+    p->z = \"0\";\n+    return;\n+  }else{\n+    p->sign = '+';\n+  }\n+  memcpy(&v,&r,8);\n+  e = v>>52;\n+  if( (e&0x7ff)==0x7ff ){\n+    p->isSpecial = 1 + (v!=0x7ff0000000000000LL);\n+    p->n = 0;\n+    p->iDP = 0;\n+    return;\n+  }\n+\n+  \/* Multiply r by powers of ten until it lands somewhere in between\n+  ** 1.0e+19 and 1.0e+17.\n+  *\/\n+  if( sqlite3Config.bUseLongDouble ){\n+    LONGDOUBLE_TYPE rr = r;\n+    if( rr>=1.0e+19 ){\n+      while( rr>=1.0e+119L ){ exp+=100; rr *= 1.0e-100L; }\n+      while( rr>=1.0e+29L  ){ exp+=10;  rr *= 1.0e-10L;  }\n+      while( rr>=1.0e+19L  ){ exp++;    rr *= 1.0e-1L;   }\n+    }else{\n+      while( rr<1.0e-97L   ){ exp-=100; rr *= 1.0e+100L; }\n+      while( rr<1.0e+07L   ){ exp-=10;  rr *= 1.0e+10L;  }\n+      while( rr<1.0e+17L   ){ exp--;    rr *= 1.0e+1L;   }\n+    }\n+    v = (u64)rr;\n+  }else{\n+    \/* If high-precision floating point is not available using \"long double\",\n+    ** then use Dekker-style double-double computation to increase the\n+    ** precision.\n+    **\n+    ** The error terms on constants like 1.0e+100 computed using the\n+    ** decimal extension, for example as follows:\n+    **\n+    **   SELECT decimal_exp(decimal_sub('1.0e+100',decimal(1.0e+100)));\n+    *\/\n+    double rr[2];\n+    rr[0] = r;\n+    rr[1] = 0.0;\n+    if( rr[0]>9.223372036854774784e+18 ){\n+      while( rr[0]>9.223372036854774784e+118 ){\n+        exp += 100;\n+        dekkerMul2(rr, 1.0e-100, -1.99918998026028836196e-117);\n+      }\n+      while( rr[0]>9.223372036854774784e+28 ){\n+        exp += 10;\n+        dekkerMul2(rr, 1.0e-10, -3.6432197315497741579e-27);\n+      }\n+      while( rr[0]>9.223372036854774784e+18 ){\n+        exp += 1;\n+        dekkerMul2(rr, 1.0e-01, -5.5511151231257827021e-18);\n+      }\n+    }else{\n+      while( rr[0]<9.223372036854774784e-83  ){\n+        exp -= 100;\n+        dekkerMul2(rr, 1.0e+100, -1.5902891109759918046e+83);\n+      }\n+      while( rr[0]<9.223372036854774784e+07  ){\n+        exp -= 10;\n+        dekkerMul2(rr, 1.0e+10, 0.0);\n+      }\n+      while( rr[0]<9.22337203685477478e+17  ){\n+        exp -= 1;\n+        dekkerMul2(rr, 1.0e+01, 0.0);\n+      }\n+    }\n+    v = rr[1]<0.0 ? (u64)rr[0]-(u64)(-rr[1]) : (u64)rr[0]+(u64)rr[1];\n+  }\n+\n+\n+  \/* Extract significant digits. *\/\n+  i = sizeof(p->zBuf)-1;\n+  assert( v>0 );\n+  while( v ){  p->zBuf[i--] = (v%10) + '0'; v \/= 10; }\n+  assert( i>=0 && i<sizeof(p->zBuf)-1 );\n+  p->n = sizeof(p->zBuf) - 1 - i;\n+  assert( p->n>0 );\n+  assert( p->n<sizeof(p->zBuf) );\n+  p->iDP = p->n + exp;\n+  if( iRound<=0 ){\n+    iRound = p->iDP - iRound;\n+    if( iRound==0 && p->zBuf[i+1]>='5' ){\n+      iRound = 1;\n+      p->zBuf[i--] = '0';\n+      p->n++;\n+      p->iDP++;\n+    }\n+  }\n+  if( iRound>0 && (iRound<p->n || p->n>mxRound) ){\n+    char *z = &p->zBuf[i+1];\n+    if( iRound>mxRound ) iRound = mxRound;\n+    p->n = iRound;\n+    if( z[iRound]>='5' ){\n+      int j = iRound-1;\n+      while( 1 \/*exit-by-break*\/ ){\n+        z[j]++;\n+        if( z[j]<='9' ) break;\n+        z[j] = '0';\n+        if( j==0 ){\n+          p->z[i--] = '1';\n+          p->n++;\n+          p->iDP++;\n+          break;\n+        }else{\n+          j--;\n+        }\n+      }\n+    }\n+  }\n+  p->z = &p->zBuf[i+1];\n+  assert( i+p->n < sizeof(p->zBuf) );\n+  while( ALWAYS(p->n>0) && p->z[p->n-1]=='0' ){ p->n--; }\n+}\n+\n@@ -34445,1 +36004,2 @@\n-  u32 a,b;\n+  u64 v64;\n+  u8 n;\n@@ -34447,12 +36007,3 @@\n-  \/* The 1-byte case.  Overwhelmingly the most common.  Handled inline\n-  ** by the getVarin32() macro *\/\n-  a = *p;\n-  \/* a: p0 (unmasked) *\/\n-#ifndef getVarint32\n-  if (!(a&0x80))\n-  {\n-    \/* Values between 0 and 127 *\/\n-    *v = a;\n-    return 1;\n-  }\n-#endif\n+  \/* Assume that the single-byte case has already been handled by\n+  ** the getVarint32() macro *\/\n+  assert( (p[0] & 0x80)!=0 );\n@@ -34460,10 +36011,3 @@\n-  \/* The 2-byte case *\/\n-  p++;\n-  b = *p;\n-  \/* b: p1 (unmasked) *\/\n-  if (!(b&0x80))\n-  {\n-    \/* Values between 128 and 16383 *\/\n-    a &= 0x7f;\n-    a = a<<7;\n-    *v = a | b;\n+  if( (p[1] & 0x80)==0 ){\n+    \/* This is the two-byte case *\/\n+    *v = ((p[0]&0x7f)<<7) | p[1];\n@@ -34472,13 +36016,3 @@\n-\n-  \/* The 3-byte case *\/\n-  p++;\n-  a = a<<14;\n-  a |= *p;\n-  \/* a: p0<<14 | p2 (unmasked) *\/\n-  if (!(a&0x80))\n-  {\n-    \/* Values between 16384 and 2097151 *\/\n-    a &= (0x7f<<14)|(0x7f);\n-    b &= 0x7f;\n-    b = b<<7;\n-    *v = a | b;\n+  if( (p[2] & 0x80)==0 ){\n+    \/* This is the three-byte case *\/\n+    *v = ((p[0]&0x7f)<<14) | ((p[1]&0x7f)<<7) | p[2];\n@@ -34487,69 +36021,6 @@\n-\n-  \/* A 32-bit varint is used to store size information in btrees.\n-  ** Objects are rarely larger than 2MiB limit of a 3-byte varint.\n-  ** A 3-byte varint is sufficient, for example, to record the size\n-  ** of a 1048569-byte BLOB or string.\n-  **\n-  ** We only unroll the first 1-, 2-, and 3- byte cases.  The very\n-  ** rare larger cases can be handled by the slower 64-bit varint\n-  ** routine.\n-  *\/\n-#if 1\n-  {\n-    u64 v64;\n-    u8 n;\n-\n-    n = sqlite3GetVarint(p-2, &v64);\n-    assert( n>3 && n<=9 );\n-    if( (v64 & SQLITE_MAX_U32)!=v64 ){\n-      *v = 0xffffffff;\n-    }else{\n-      *v = (u32)v64;\n-    }\n-    return n;\n-  }\n-\n-#else\n-  \/* For following code (kept for historical record only) shows an\n-  ** unrolling for the 3- and 4-byte varint cases.  This code is\n-  ** slightly faster, but it is also larger and much harder to test.\n-  *\/\n-  p++;\n-  b = b<<14;\n-  b |= *p;\n-  \/* b: p1<<14 | p3 (unmasked) *\/\n-  if (!(b&0x80))\n-  {\n-    \/* Values between 2097152 and 268435455 *\/\n-    b &= (0x7f<<14)|(0x7f);\n-    a &= (0x7f<<14)|(0x7f);\n-    a = a<<7;\n-    *v = a | b;\n-    return 4;\n-  }\n-\n-  p++;\n-  a = a<<14;\n-  a |= *p;\n-  \/* a: p0<<28 | p2<<14 | p4 (unmasked) *\/\n-  if (!(a&0x80))\n-  {\n-    \/* Values  between 268435456 and 34359738367 *\/\n-    a &= SLOT_4_2_0;\n-    b &= SLOT_4_2_0;\n-    b = b<<7;\n-    *v = a | b;\n-    return 5;\n-  }\n-\n-  \/* We can only reach this point when reading a corrupt database\n-  ** file.  In that case we are not in any hurry.  Use the (relatively\n-  ** slow) general-purpose sqlite3GetVarint() routine to extract the\n-  ** value. *\/\n-  {\n-    u64 v64;\n-    u8 n;\n-\n-    p -= 4;\n-    n = sqlite3GetVarint(p, &v64);\n-    assert( n>5 && n<=9 );\n+  \/* four or more bytes *\/\n+  n = sqlite3GetVarint(p, &v64);\n+  assert( n>3 && n<=9 );\n+  if( (v64 & SQLITE_MAX_U32)!=v64 ){\n+    *v = 0xffffffff;\n+  }else{\n@@ -34557,1 +36028,0 @@\n-    return n;\n@@ -34559,1 +36029,1 @@\n-#endif\n+  return n;\n@@ -34710,1 +36180,1 @@\n-** Attempt to add, substract, or multiply the 64-bit signed value iB against\n+** Attempt to add, subtract, or multiply the 64-bit signed value iB against\n@@ -34996,0 +36466,98 @@\n+\/*\n+** High-resolution hardware timer used for debugging and testing only.\n+*\/\n+#if defined(VDBE_PROFILE)  \\\n+ || defined(SQLITE_PERFORMANCE_TRACE) \\\n+ || defined(SQLITE_ENABLE_STMT_SCANSTATUS)\n+\/************** Include hwtime.h in the middle of util.c *********************\/\n+\/************** Begin file hwtime.h ******************************************\/\n+\/*\n+** 2008 May 27\n+**\n+** The author disclaims copyright to this source code.  In place of\n+** a legal notice, here is a blessing:\n+**\n+**    May you do good and not evil.\n+**    May you find forgiveness for yourself and forgive others.\n+**    May you share freely, never taking more than you give.\n+**\n+******************************************************************************\n+**\n+** This file contains inline asm code for retrieving \"high-performance\"\n+** counters for x86 and x86_64 class CPUs.\n+*\/\n+#ifndef SQLITE_HWTIME_H\n+#define SQLITE_HWTIME_H\n+\n+\/*\n+** The following routine only works on Pentium-class (or newer) processors.\n+** It uses the RDTSC opcode to read the cycle count value out of the\n+** processor and returns that value.  This can be used for high-res\n+** profiling.\n+*\/\n+#if !defined(__STRICT_ANSI__) && \\\n+    (defined(__GNUC__) || defined(_MSC_VER)) && \\\n+    (defined(i386) || defined(__i386__) || defined(_M_IX86))\n+\n+  #if defined(__GNUC__)\n+\n+  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n+     unsigned int lo, hi;\n+     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n+     return (sqlite_uint64)hi << 32 | lo;\n+  }\n+\n+  #elif defined(_MSC_VER)\n+\n+  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){\n+     __asm {\n+        rdtsc\n+        ret       ; return value at EDX:EAX\n+     }\n+  }\n+\n+  #endif\n+\n+#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__x86_64__))\n+\n+  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n+     unsigned int lo, hi;\n+     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n+     return (sqlite_uint64)hi << 32 | lo;\n+  }\n+\n+#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__ppc__))\n+\n+  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n+      unsigned long long retval;\n+      unsigned long junk;\n+      __asm__ __volatile__ (\"\\n\\\n+          1:      mftbu   %1\\n\\\n+                  mftb    %L0\\n\\\n+                  mftbu   %0\\n\\\n+                  cmpw    %0,%1\\n\\\n+                  bne     1b\"\n+                  : \"=r\" (retval), \"=r\" (junk));\n+      return retval;\n+  }\n+\n+#else\n+\n+  \/*\n+  ** asm() is needed for hardware timing support.  Without asm(),\n+  ** disable the sqlite3Hwtime() routine.\n+  **\n+  ** sqlite3Hwtime() is only used for some obscure debugging\n+  ** and analysis configurations, not in any deliverable, so this\n+  ** should not be a great loss.\n+  *\/\n+SQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }\n+\n+#endif\n+\n+#endif \/* !defined(SQLITE_HWTIME_H) *\/\n+\n+\/************** End of hwtime.h **********************************************\/\n+\/************** Continuing where we left off in util.c ***********************\/\n+#endif\n+\n@@ -35097,1 +36665,1 @@\n-\/* Resize the hash table so that it cantains \"new_size\" buckets.\n+\/* Resize the hash table so that it contains \"new_size\" buckets.\n@@ -35166,1 +36734,1 @@\n-  while( count-- ){\n+  while( count ){\n@@ -35172,0 +36740,1 @@\n+    count--;\n@@ -35290,11 +36859,11 @@\n-    \/*   8 *\/ \"Goto\"             OpHelp(\"\"),\n-    \/*   9 *\/ \"Gosub\"            OpHelp(\"\"),\n-    \/*  10 *\/ \"InitCoroutine\"    OpHelp(\"\"),\n-    \/*  11 *\/ \"Yield\"            OpHelp(\"\"),\n-    \/*  12 *\/ \"MustBeInt\"        OpHelp(\"\"),\n-    \/*  13 *\/ \"Jump\"             OpHelp(\"\"),\n-    \/*  14 *\/ \"Once\"             OpHelp(\"\"),\n-    \/*  15 *\/ \"If\"               OpHelp(\"\"),\n-    \/*  16 *\/ \"IfNot\"            OpHelp(\"\"),\n-    \/*  17 *\/ \"IsNullOrType\"     OpHelp(\"if typeof(r[P1]) IN (P3,5) goto P2\"),\n-    \/*  18 *\/ \"IfNullRow\"        OpHelp(\"if P1.nullRow then r[P3]=NULL, goto P2\"),\n+    \/*   8 *\/ \"Init\"             OpHelp(\"Start at P2\"),\n+    \/*   9 *\/ \"Goto\"             OpHelp(\"\"),\n+    \/*  10 *\/ \"Gosub\"            OpHelp(\"\"),\n+    \/*  11 *\/ \"InitCoroutine\"    OpHelp(\"\"),\n+    \/*  12 *\/ \"Yield\"            OpHelp(\"\"),\n+    \/*  13 *\/ \"MustBeInt\"        OpHelp(\"\"),\n+    \/*  14 *\/ \"Jump\"             OpHelp(\"\"),\n+    \/*  15 *\/ \"Once\"             OpHelp(\"\"),\n+    \/*  16 *\/ \"If\"               OpHelp(\"\"),\n+    \/*  17 *\/ \"IfNot\"            OpHelp(\"\"),\n+    \/*  18 *\/ \"IsType\"           OpHelp(\"if typeof(P1.P3) in P5 goto P2\"),\n@@ -35302,23 +36871,23 @@\n-    \/*  20 *\/ \"SeekLT\"           OpHelp(\"key=r[P3@P4]\"),\n-    \/*  21 *\/ \"SeekLE\"           OpHelp(\"key=r[P3@P4]\"),\n-    \/*  22 *\/ \"SeekGE\"           OpHelp(\"key=r[P3@P4]\"),\n-    \/*  23 *\/ \"SeekGT\"           OpHelp(\"key=r[P3@P4]\"),\n-    \/*  24 *\/ \"IfNotOpen\"        OpHelp(\"if( !csr[P1] ) goto P2\"),\n-    \/*  25 *\/ \"IfNoHope\"         OpHelp(\"key=r[P3@P4]\"),\n-    \/*  26 *\/ \"NoConflict\"       OpHelp(\"key=r[P3@P4]\"),\n-    \/*  27 *\/ \"NotFound\"         OpHelp(\"key=r[P3@P4]\"),\n-    \/*  28 *\/ \"Found\"            OpHelp(\"key=r[P3@P4]\"),\n-    \/*  29 *\/ \"SeekRowid\"        OpHelp(\"intkey=r[P3]\"),\n-    \/*  30 *\/ \"NotExists\"        OpHelp(\"intkey=r[P3]\"),\n-    \/*  31 *\/ \"Last\"             OpHelp(\"\"),\n-    \/*  32 *\/ \"IfSmaller\"        OpHelp(\"\"),\n-    \/*  33 *\/ \"SorterSort\"       OpHelp(\"\"),\n-    \/*  34 *\/ \"Sort\"             OpHelp(\"\"),\n-    \/*  35 *\/ \"Rewind\"           OpHelp(\"\"),\n-    \/*  36 *\/ \"SorterNext\"       OpHelp(\"\"),\n-    \/*  37 *\/ \"Prev\"             OpHelp(\"\"),\n-    \/*  38 *\/ \"Next\"             OpHelp(\"\"),\n-    \/*  39 *\/ \"IdxLE\"            OpHelp(\"key=r[P3@P4]\"),\n-    \/*  40 *\/ \"IdxGT\"            OpHelp(\"key=r[P3@P4]\"),\n-    \/*  41 *\/ \"IdxLT\"            OpHelp(\"key=r[P3@P4]\"),\n-    \/*  42 *\/ \"IdxGE\"            OpHelp(\"key=r[P3@P4]\"),\n+    \/*  20 *\/ \"IfNullRow\"        OpHelp(\"if P1.nullRow then r[P3]=NULL, goto P2\"),\n+    \/*  21 *\/ \"SeekLT\"           OpHelp(\"key=r[P3@P4]\"),\n+    \/*  22 *\/ \"SeekLE\"           OpHelp(\"key=r[P3@P4]\"),\n+    \/*  23 *\/ \"SeekGE\"           OpHelp(\"key=r[P3@P4]\"),\n+    \/*  24 *\/ \"SeekGT\"           OpHelp(\"key=r[P3@P4]\"),\n+    \/*  25 *\/ \"IfNotOpen\"        OpHelp(\"if( !csr[P1] ) goto P2\"),\n+    \/*  26 *\/ \"IfNoHope\"         OpHelp(\"key=r[P3@P4]\"),\n+    \/*  27 *\/ \"NoConflict\"       OpHelp(\"key=r[P3@P4]\"),\n+    \/*  28 *\/ \"NotFound\"         OpHelp(\"key=r[P3@P4]\"),\n+    \/*  29 *\/ \"Found\"            OpHelp(\"key=r[P3@P4]\"),\n+    \/*  30 *\/ \"SeekRowid\"        OpHelp(\"intkey=r[P3]\"),\n+    \/*  31 *\/ \"NotExists\"        OpHelp(\"intkey=r[P3]\"),\n+    \/*  32 *\/ \"Last\"             OpHelp(\"\"),\n+    \/*  33 *\/ \"IfSmaller\"        OpHelp(\"\"),\n+    \/*  34 *\/ \"SorterSort\"       OpHelp(\"\"),\n+    \/*  35 *\/ \"Sort\"             OpHelp(\"\"),\n+    \/*  36 *\/ \"Rewind\"           OpHelp(\"\"),\n+    \/*  37 *\/ \"SorterNext\"       OpHelp(\"\"),\n+    \/*  38 *\/ \"Prev\"             OpHelp(\"\"),\n+    \/*  39 *\/ \"Next\"             OpHelp(\"\"),\n+    \/*  40 *\/ \"IdxLE\"            OpHelp(\"key=r[P3@P4]\"),\n+    \/*  41 *\/ \"IdxGT\"            OpHelp(\"key=r[P3@P4]\"),\n+    \/*  42 *\/ \"IdxLT\"            OpHelp(\"key=r[P3@P4]\"),\n@@ -35327,5 +36896,5 @@\n-    \/*  45 *\/ \"RowSetRead\"       OpHelp(\"r[P3]=rowset(P1)\"),\n-    \/*  46 *\/ \"RowSetTest\"       OpHelp(\"if r[P3] in rowset(P1) goto P2\"),\n-    \/*  47 *\/ \"Program\"          OpHelp(\"\"),\n-    \/*  48 *\/ \"FkIfZero\"         OpHelp(\"if fkctr[P1]==0 goto P2\"),\n-    \/*  49 *\/ \"IfPos\"            OpHelp(\"if r[P1]>0 then r[P1]-=P3, goto P2\"),\n+    \/*  45 *\/ \"IdxGE\"            OpHelp(\"key=r[P3@P4]\"),\n+    \/*  46 *\/ \"RowSetRead\"       OpHelp(\"r[P3]=rowset(P1)\"),\n+    \/*  47 *\/ \"RowSetTest\"       OpHelp(\"if r[P3] in rowset(P1) goto P2\"),\n+    \/*  48 *\/ \"Program\"          OpHelp(\"\"),\n+    \/*  49 *\/ \"FkIfZero\"         OpHelp(\"if fkctr[P1]==0 goto P2\"),\n@@ -35341,6 +36910,6 @@\n-    \/*  59 *\/ \"IfNotZero\"        OpHelp(\"if r[P1]!=0 then r[P1]--, goto P2\"),\n-    \/*  60 *\/ \"DecrJumpZero\"     OpHelp(\"if (--r[P1])==0 goto P2\"),\n-    \/*  61 *\/ \"IncrVacuum\"       OpHelp(\"\"),\n-    \/*  62 *\/ \"VNext\"            OpHelp(\"\"),\n-    \/*  63 *\/ \"Filter\"           OpHelp(\"if key(P3@P4) not in filter(P1) goto P2\"),\n-    \/*  64 *\/ \"Init\"             OpHelp(\"Start at P2\"),\n+    \/*  59 *\/ \"IfPos\"            OpHelp(\"if r[P1]>0 then r[P1]-=P3, goto P2\"),\n+    \/*  60 *\/ \"IfNotZero\"        OpHelp(\"if r[P1]!=0 then r[P1]--, goto P2\"),\n+    \/*  61 *\/ \"DecrJumpZero\"     OpHelp(\"if (--r[P1])==0 goto P2\"),\n+    \/*  62 *\/ \"IncrVacuum\"       OpHelp(\"\"),\n+    \/*  63 *\/ \"VNext\"            OpHelp(\"\"),\n+    \/*  64 *\/ \"Filter\"           OpHelp(\"if key(P3@P4) not in filter(P1) goto P2\"),\n@@ -35456,13 +37025,16 @@\n-    \/* 174 *\/ \"VInitIn\"          OpHelp(\"r[P2]=ValueList(P1,P3)\"),\n-    \/* 175 *\/ \"VColumn\"          OpHelp(\"r[P3]=vcolumn(P2)\"),\n-    \/* 176 *\/ \"VRename\"          OpHelp(\"\"),\n-    \/* 177 *\/ \"Pagecount\"        OpHelp(\"\"),\n-    \/* 178 *\/ \"MaxPgcnt\"         OpHelp(\"\"),\n-    \/* 179 *\/ \"ClrSubtype\"       OpHelp(\"r[P1].subtype = 0\"),\n-    \/* 180 *\/ \"FilterAdd\"        OpHelp(\"filter(P1) += key(P3@P4)\"),\n-    \/* 181 *\/ \"Trace\"            OpHelp(\"\"),\n-    \/* 182 *\/ \"CursorHint\"       OpHelp(\"\"),\n-    \/* 183 *\/ \"ReleaseReg\"       OpHelp(\"release r[P1@P2] mask P3\"),\n-    \/* 184 *\/ \"Noop\"             OpHelp(\"\"),\n-    \/* 185 *\/ \"Explain\"          OpHelp(\"\"),\n-    \/* 186 *\/ \"Abortable\"        OpHelp(\"\"),\n+    \/* 174 *\/ \"VCheck\"           OpHelp(\"\"),\n+    \/* 175 *\/ \"VInitIn\"          OpHelp(\"r[P2]=ValueList(P1,P3)\"),\n+    \/* 176 *\/ \"VColumn\"          OpHelp(\"r[P3]=vcolumn(P2)\"),\n+    \/* 177 *\/ \"VRename\"          OpHelp(\"\"),\n+    \/* 178 *\/ \"Pagecount\"        OpHelp(\"\"),\n+    \/* 179 *\/ \"MaxPgcnt\"         OpHelp(\"\"),\n+    \/* 180 *\/ \"ClrSubtype\"       OpHelp(\"r[P1].subtype = 0\"),\n+    \/* 181 *\/ \"GetSubtype\"       OpHelp(\"r[P2] = r[P1].subtype\"),\n+    \/* 182 *\/ \"SetSubtype\"       OpHelp(\"r[P2].subtype = r[P1]\"),\n+    \/* 183 *\/ \"FilterAdd\"        OpHelp(\"filter(P1) += key(P3@P4)\"),\n+    \/* 184 *\/ \"Trace\"            OpHelp(\"\"),\n+    \/* 185 *\/ \"CursorHint\"       OpHelp(\"\"),\n+    \/* 186 *\/ \"ReleaseReg\"       OpHelp(\"release r[P1@P2] mask P3\"),\n+    \/* 187 *\/ \"Noop\"             OpHelp(\"\"),\n+    \/* 188 *\/ \"Explain\"          OpHelp(\"\"),\n+    \/* 189 *\/ \"Abortable\"        OpHelp(\"\"),\n@@ -35475,0 +37047,982 @@\n+\/************** Begin file os_kv.c *******************************************\/\n+\/*\n+** 2022-09-06\n+**\n+** The author disclaims copyright to this source code.  In place of\n+** a legal notice, here is a blessing:\n+**\n+**    May you do good and not evil.\n+**    May you find forgiveness for yourself and forgive others.\n+**    May you share freely, never taking more than you give.\n+**\n+******************************************************************************\n+**\n+** This file contains an experimental VFS layer that operates on a\n+** Key\/Value storage engine where both keys and values must be pure\n+** text.\n+*\/\n+\/* #include <sqliteInt.h> *\/\n+#if SQLITE_OS_KV || (SQLITE_OS_UNIX && defined(SQLITE_OS_KV_OPTIONAL))\n+\n+\/*****************************************************************************\n+** Debugging logic\n+*\/\n+\n+\/* SQLITE_KV_TRACE() is used for tracing calls to kvstorage routines. *\/\n+#if 0\n+#define SQLITE_KV_TRACE(X)  printf X\n+#else\n+#define SQLITE_KV_TRACE(X)\n+#endif\n+\n+\/* SQLITE_KV_LOG() is used for tracing calls to the VFS interface *\/\n+#if 0\n+#define SQLITE_KV_LOG(X)  printf X\n+#else\n+#define SQLITE_KV_LOG(X)\n+#endif\n+\n+\n+\/*\n+** Forward declaration of objects used by this VFS implementation\n+*\/\n+typedef struct KVVfsFile KVVfsFile;\n+\n+\/* A single open file.  There are only two files represented by this\n+** VFS - the database and the rollback journal.\n+*\/\n+struct KVVfsFile {\n+  sqlite3_file base;              \/* IO methods *\/\n+  const char *zClass;             \/* Storage class *\/\n+  int isJournal;                  \/* True if this is a journal file *\/\n+  unsigned int nJrnl;             \/* Space allocated for aJrnl[] *\/\n+  char *aJrnl;                    \/* Journal content *\/\n+  int szPage;                     \/* Last known page size *\/\n+  sqlite3_int64 szDb;             \/* Database file size.  -1 means unknown *\/\n+  char *aData;                    \/* Buffer to hold page data *\/\n+};\n+#define SQLITE_KVOS_SZ 133073\n+\n+\/*\n+** Methods for KVVfsFile\n+*\/\n+static int kvvfsClose(sqlite3_file*);\n+static int kvvfsReadDb(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);\n+static int kvvfsReadJrnl(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);\n+static int kvvfsWriteDb(sqlite3_file*,const void*,int iAmt, sqlite3_int64);\n+static int kvvfsWriteJrnl(sqlite3_file*,const void*,int iAmt, sqlite3_int64);\n+static int kvvfsTruncateDb(sqlite3_file*, sqlite3_int64 size);\n+static int kvvfsTruncateJrnl(sqlite3_file*, sqlite3_int64 size);\n+static int kvvfsSyncDb(sqlite3_file*, int flags);\n+static int kvvfsSyncJrnl(sqlite3_file*, int flags);\n+static int kvvfsFileSizeDb(sqlite3_file*, sqlite3_int64 *pSize);\n+static int kvvfsFileSizeJrnl(sqlite3_file*, sqlite3_int64 *pSize);\n+static int kvvfsLock(sqlite3_file*, int);\n+static int kvvfsUnlock(sqlite3_file*, int);\n+static int kvvfsCheckReservedLock(sqlite3_file*, int *pResOut);\n+static int kvvfsFileControlDb(sqlite3_file*, int op, void *pArg);\n+static int kvvfsFileControlJrnl(sqlite3_file*, int op, void *pArg);\n+static int kvvfsSectorSize(sqlite3_file*);\n+static int kvvfsDeviceCharacteristics(sqlite3_file*);\n+\n+\/*\n+** Methods for sqlite3_vfs\n+*\/\n+static int kvvfsOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);\n+static int kvvfsDelete(sqlite3_vfs*, const char *zName, int syncDir);\n+static int kvvfsAccess(sqlite3_vfs*, const char *zName, int flags, int *);\n+static int kvvfsFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);\n+static void *kvvfsDlOpen(sqlite3_vfs*, const char *zFilename);\n+static int kvvfsRandomness(sqlite3_vfs*, int nByte, char *zOut);\n+static int kvvfsSleep(sqlite3_vfs*, int microseconds);\n+static int kvvfsCurrentTime(sqlite3_vfs*, double*);\n+static int kvvfsCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*);\n+\n+static sqlite3_vfs sqlite3OsKvvfsObject = {\n+  1,                              \/* iVersion *\/\n+  sizeof(KVVfsFile),              \/* szOsFile *\/\n+  1024,                           \/* mxPathname *\/\n+  0,                              \/* pNext *\/\n+  \"kvvfs\",                        \/* zName *\/\n+  0,                              \/* pAppData *\/\n+  kvvfsOpen,                      \/* xOpen *\/\n+  kvvfsDelete,                    \/* xDelete *\/\n+  kvvfsAccess,                    \/* xAccess *\/\n+  kvvfsFullPathname,              \/* xFullPathname *\/\n+  kvvfsDlOpen,                    \/* xDlOpen *\/\n+  0,                              \/* xDlError *\/\n+  0,                              \/* xDlSym *\/\n+  0,                              \/* xDlClose *\/\n+  kvvfsRandomness,                \/* xRandomness *\/\n+  kvvfsSleep,                     \/* xSleep *\/\n+  kvvfsCurrentTime,               \/* xCurrentTime *\/\n+  0,                              \/* xGetLastError *\/\n+  kvvfsCurrentTimeInt64           \/* xCurrentTimeInt64 *\/\n+};\n+\n+\/* Methods for sqlite3_file objects referencing a database file\n+*\/\n+static sqlite3_io_methods kvvfs_db_io_methods = {\n+  1,                              \/* iVersion *\/\n+  kvvfsClose,                     \/* xClose *\/\n+  kvvfsReadDb,                    \/* xRead *\/\n+  kvvfsWriteDb,                   \/* xWrite *\/\n+  kvvfsTruncateDb,                \/* xTruncate *\/\n+  kvvfsSyncDb,                    \/* xSync *\/\n+  kvvfsFileSizeDb,                \/* xFileSize *\/\n+  kvvfsLock,                      \/* xLock *\/\n+  kvvfsUnlock,                    \/* xUnlock *\/\n+  kvvfsCheckReservedLock,         \/* xCheckReservedLock *\/\n+  kvvfsFileControlDb,             \/* xFileControl *\/\n+  kvvfsSectorSize,                \/* xSectorSize *\/\n+  kvvfsDeviceCharacteristics,     \/* xDeviceCharacteristics *\/\n+  0,                              \/* xShmMap *\/\n+  0,                              \/* xShmLock *\/\n+  0,                              \/* xShmBarrier *\/\n+  0,                              \/* xShmUnmap *\/\n+  0,                              \/* xFetch *\/\n+  0                               \/* xUnfetch *\/\n+};\n+\n+\/* Methods for sqlite3_file objects referencing a rollback journal\n+*\/\n+static sqlite3_io_methods kvvfs_jrnl_io_methods = {\n+  1,                              \/* iVersion *\/\n+  kvvfsClose,                     \/* xClose *\/\n+  kvvfsReadJrnl,                  \/* xRead *\/\n+  kvvfsWriteJrnl,                 \/* xWrite *\/\n+  kvvfsTruncateJrnl,              \/* xTruncate *\/\n+  kvvfsSyncJrnl,                  \/* xSync *\/\n+  kvvfsFileSizeJrnl,              \/* xFileSize *\/\n+  kvvfsLock,                      \/* xLock *\/\n+  kvvfsUnlock,                    \/* xUnlock *\/\n+  kvvfsCheckReservedLock,         \/* xCheckReservedLock *\/\n+  kvvfsFileControlJrnl,           \/* xFileControl *\/\n+  kvvfsSectorSize,                \/* xSectorSize *\/\n+  kvvfsDeviceCharacteristics,     \/* xDeviceCharacteristics *\/\n+  0,                              \/* xShmMap *\/\n+  0,                              \/* xShmLock *\/\n+  0,                              \/* xShmBarrier *\/\n+  0,                              \/* xShmUnmap *\/\n+  0,                              \/* xFetch *\/\n+  0                               \/* xUnfetch *\/\n+};\n+\n+\/****** Storage subsystem **************************************************\/\n+#include <sys\/types.h>\n+#include <sys\/stat.h>\n+#include <unistd.h>\n+\n+\/* Forward declarations for the low-level storage engine\n+*\/\n+static int kvstorageWrite(const char*, const char *zKey, const char *zData);\n+static int kvstorageDelete(const char*, const char *zKey);\n+static int kvstorageRead(const char*, const char *zKey, char *zBuf, int nBuf);\n+#define KVSTORAGE_KEY_SZ  32\n+\n+\/* Expand the key name with an appropriate prefix and put the result\n+** zKeyOut[].  The zKeyOut[] buffer is assumed to hold at least\n+** KVSTORAGE_KEY_SZ bytes.\n+*\/\n+static void kvstorageMakeKey(\n+  const char *zClass,\n+  const char *zKeyIn,\n+  char *zKeyOut\n+){\n+  sqlite3_snprintf(KVSTORAGE_KEY_SZ, zKeyOut, \"kvvfs-%s-%s\", zClass, zKeyIn);\n+}\n+\n+\/* Write content into a key.  zClass is the particular namespace of the\n+** underlying key\/value store to use - either \"local\" or \"session\".\n+**\n+** Both zKey and zData are zero-terminated pure text strings.\n+**\n+** Return the number of errors.\n+*\/\n+static int kvstorageWrite(\n+  const char *zClass,\n+  const char *zKey,\n+  const char *zData\n+){\n+  FILE *fd;\n+  char zXKey[KVSTORAGE_KEY_SZ];\n+  kvstorageMakeKey(zClass, zKey, zXKey);\n+  fd = fopen(zXKey, \"wb\");\n+  if( fd ){\n+    SQLITE_KV_TRACE((\"KVVFS-WRITE  %-15s (%d) %.50s%s\\n\", zXKey,\n+                 (int)strlen(zData), zData,\n+                 strlen(zData)>50 ? \"...\" : \"\"));\n+    fputs(zData, fd);\n+    fclose(fd);\n+    return 0;\n+  }else{\n+    return 1;\n+  }\n+}\n+\n+\/* Delete a key (with its corresponding data) from the key\/value\n+** namespace given by zClass.  If the key does not previously exist,\n+** this routine is a no-op.\n+*\/\n+static int kvstorageDelete(const char *zClass, const char *zKey){\n+  char zXKey[KVSTORAGE_KEY_SZ];\n+  kvstorageMakeKey(zClass, zKey, zXKey);\n+  unlink(zXKey);\n+  SQLITE_KV_TRACE((\"KVVFS-DELETE %-15s\\n\", zXKey));\n+  return 0;\n+}\n+\n+\/* Read the value associated with a zKey from the key\/value namespace given\n+** by zClass and put the text data associated with that key in the first\n+** nBuf bytes of zBuf[].  The value might be truncated if zBuf is not large\n+** enough to hold it all.  The value put into zBuf must always be zero\n+** terminated, even if it gets truncated because nBuf is not large enough.\n+**\n+** Return the total number of bytes in the data, without truncation, and\n+** not counting the final zero terminator.   Return -1 if the key does\n+** not exist.\n+**\n+** If nBuf<=0 then this routine simply returns the size of the data without\n+** actually reading it.\n+*\/\n+static int kvstorageRead(\n+  const char *zClass,\n+  const char *zKey,\n+  char *zBuf,\n+  int nBuf\n+){\n+  FILE *fd;\n+  struct stat buf;\n+  char zXKey[KVSTORAGE_KEY_SZ];\n+  kvstorageMakeKey(zClass, zKey, zXKey);\n+  if( access(zXKey, R_OK)!=0\n+   || stat(zXKey, &buf)!=0\n+   || !S_ISREG(buf.st_mode)\n+  ){\n+    SQLITE_KV_TRACE((\"KVVFS-READ   %-15s (-1)\\n\", zXKey));\n+    return -1;\n+  }\n+  if( nBuf<=0 ){\n+    return (int)buf.st_size;\n+  }else if( nBuf==1 ){\n+    zBuf[0] = 0;\n+    SQLITE_KV_TRACE((\"KVVFS-READ   %-15s (%d)\\n\", zXKey,\n+                 (int)buf.st_size));\n+    return (int)buf.st_size;\n+  }\n+  if( nBuf > buf.st_size + 1 ){\n+    nBuf = buf.st_size + 1;\n+  }\n+  fd = fopen(zXKey, \"rb\");\n+  if( fd==0 ){\n+    SQLITE_KV_TRACE((\"KVVFS-READ   %-15s (-1)\\n\", zXKey));\n+    return -1;\n+  }else{\n+    sqlite3_int64 n = fread(zBuf, 1, nBuf-1, fd);\n+    fclose(fd);\n+    zBuf[n] = 0;\n+    SQLITE_KV_TRACE((\"KVVFS-READ   %-15s (%lld) %.50s%s\\n\", zXKey,\n+                 n, zBuf, n>50 ? \"...\" : \"\"));\n+    return (int)n;\n+  }\n+}\n+\n+\/*\n+** An internal level of indirection which enables us to replace the\n+** kvvfs i\/o methods with JavaScript implementations in WASM builds.\n+** Maintenance reminder: if this struct changes in any way, the JSON\n+** rendering of its structure must be updated in\n+** sqlite3_wasm_enum_json(). There are no binary compatibility\n+** concerns, so it does not need an iVersion member. This file is\n+** necessarily always compiled together with sqlite3_wasm_enum_json(),\n+** and JS code dynamically creates the mapping of members based on\n+** that JSON description.\n+*\/\n+typedef struct sqlite3_kvvfs_methods sqlite3_kvvfs_methods;\n+struct sqlite3_kvvfs_methods {\n+  int (*xRead)(const char *zClass, const char *zKey, char *zBuf, int nBuf);\n+  int (*xWrite)(const char *zClass, const char *zKey, const char *zData);\n+  int (*xDelete)(const char *zClass, const char *zKey);\n+  const int nKeySize;\n+};\n+\n+\/*\n+** This object holds the kvvfs I\/O methods which may be swapped out\n+** for JavaScript-side implementations in WASM builds. In such builds\n+** it cannot be const, but in native builds it should be so that\n+** the compiler can hopefully optimize this level of indirection out.\n+** That said, kvvfs is intended primarily for use in WASM builds.\n+**\n+** Note that this is not explicitly flagged as static because the\n+** amalgamation build will tag it with SQLITE_PRIVATE.\n+*\/\n+#ifndef SQLITE_WASM\n+const\n+#endif\n+SQLITE_PRIVATE sqlite3_kvvfs_methods sqlite3KvvfsMethods = {\n+kvstorageRead,\n+kvstorageWrite,\n+kvstorageDelete,\n+KVSTORAGE_KEY_SZ\n+};\n+\n+\/****** Utility subroutines ************************************************\/\n+\n+\/*\n+** Encode binary into the text encoded used to persist on disk.\n+** The output text is stored in aOut[], which must be at least\n+** nData+1 bytes in length.\n+**\n+** Return the actual length of the encoded text, not counting the\n+** zero terminator at the end.\n+**\n+** Encoding format\n+** ---------------\n+**\n+**   *  Non-zero bytes are encoded as upper-case hexadecimal\n+**\n+**   *  A sequence of one or more zero-bytes that are not at the\n+**      beginning of the buffer are encoded as a little-endian\n+**      base-26 number using a..z.  \"a\" means 0.  \"b\" means 1,\n+**      \"z\" means 25.  \"ab\" means 26.  \"ac\" means 52.  And so forth.\n+**\n+**   *  Because there is no overlap between the encoding characters\n+**      of hexadecimal and base-26 numbers, it is always clear where\n+**      one stops and the next begins.\n+*\/\n+static int kvvfsEncode(const char *aData, int nData, char *aOut){\n+  int i, j;\n+  const unsigned char *a = (const unsigned char*)aData;\n+  for(i=j=0; i<nData; i++){\n+    unsigned char c = a[i];\n+    if( c!=0 ){\n+      aOut[j++] = \"0123456789ABCDEF\"[c>>4];\n+      aOut[j++] = \"0123456789ABCDEF\"[c&0xf];\n+    }else{\n+      \/* A sequence of 1 or more zeros is stored as a little-endian\n+      ** base-26 number using a..z as the digits. So one zero is \"b\".\n+      ** Two zeros is \"c\". 25 zeros is \"z\", 26 zeros is \"ab\", 27 is \"bb\",\n+      ** and so forth.\n+      *\/\n+      int k;\n+      for(k=1; i+k<nData && a[i+k]==0; k++){}\n+      i += k-1;\n+      while( k>0 ){\n+        aOut[j++] = 'a'+(k%26);\n+        k \/= 26;\n+      }\n+    }\n+  }\n+  aOut[j] = 0;\n+  return j;\n+}\n+\n+static const signed char kvvfsHexValue[256] = {\n+  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n+  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n+  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n+   0,  1,  2,  3,  4,  5,  6,  7,    8,  9, -1, -1, -1, -1, -1, -1,\n+  -1, 10, 11, 12, 13, 14, 15, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n+  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n+  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n+  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n+\n+  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n+  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n+  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n+  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n+  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n+  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n+  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1,\n+  -1, -1, -1, -1, -1, -1, -1, -1,   -1, -1, -1, -1, -1, -1, -1, -1\n+};\n+\n+\/*\n+** Decode the text encoding back to binary.  The binary content is\n+** written into pOut, which must be at least nOut bytes in length.\n+**\n+** The return value is the number of bytes actually written into aOut[].\n+*\/\n+static int kvvfsDecode(const char *a, char *aOut, int nOut){\n+  int i, j;\n+  int c;\n+  const unsigned char *aIn = (const unsigned char*)a;\n+  i = 0;\n+  j = 0;\n+  while( 1 ){\n+    c = kvvfsHexValue[aIn[i]];\n+    if( c<0 ){\n+      int n = 0;\n+      int mult = 1;\n+      c = aIn[i];\n+      if( c==0 ) break;\n+      while( c>='a' && c<='z' ){\n+        n += (c - 'a')*mult;\n+        mult *= 26;\n+        c = aIn[++i];\n+      }\n+      if( j+n>nOut ) return -1;\n+      memset(&aOut[j], 0, n);\n+      j += n;\n+      if( c==0 || mult==1 ) break; \/* progress stalled if mult==1 *\/\n+    }else{\n+      aOut[j] = c<<4;\n+      c = kvvfsHexValue[aIn[++i]];\n+      if( c<0 ) break;\n+      aOut[j++] += c;\n+      i++;\n+    }\n+  }\n+  return j;\n+}\n+\n+\/*\n+** Decode a complete journal file.  Allocate space in pFile->aJrnl\n+** and store the decoding there.  Or leave pFile->aJrnl set to NULL\n+** if an error is encountered.\n+**\n+** The first few characters of the text encoding will be a little-endian\n+** base-26 number (digits a..z) that is the total number of bytes\n+** in the decoded journal file image.  This base-26 number is followed\n+** by a single space, then the encoding of the journal.  The space\n+** separator is required to act as a terminator for the base-26 number.\n+*\/\n+static void kvvfsDecodeJournal(\n+  KVVfsFile *pFile,      \/* Store decoding in pFile->aJrnl *\/\n+  const char *zTxt,      \/* Text encoding.  Zero-terminated *\/\n+  int nTxt               \/* Bytes in zTxt, excluding zero terminator *\/\n+){\n+  unsigned int n = 0;\n+  int c, i, mult;\n+  i = 0;\n+  mult = 1;\n+  while( (c = zTxt[i++])>='a' && c<='z' ){\n+    n += (zTxt[i] - 'a')*mult;\n+    mult *= 26;\n+  }\n+  sqlite3_free(pFile->aJrnl);\n+  pFile->aJrnl = sqlite3_malloc64( n );\n+  if( pFile->aJrnl==0 ){\n+    pFile->nJrnl = 0;\n+    return;\n+  }\n+  pFile->nJrnl = n;\n+  n = kvvfsDecode(zTxt+i, pFile->aJrnl, pFile->nJrnl);\n+  if( n<pFile->nJrnl ){\n+    sqlite3_free(pFile->aJrnl);\n+    pFile->aJrnl = 0;\n+    pFile->nJrnl = 0;\n+  }\n+}\n+\n+\/*\n+** Read or write the \"sz\" element, containing the database file size.\n+*\/\n+static sqlite3_int64 kvvfsReadFileSize(KVVfsFile *pFile){\n+  char zData[50];\n+  zData[0] = 0;\n+  sqlite3KvvfsMethods.xRead(pFile->zClass, \"sz\", zData, sizeof(zData)-1);\n+  return strtoll(zData, 0, 0);\n+}\n+static int kvvfsWriteFileSize(KVVfsFile *pFile, sqlite3_int64 sz){\n+  char zData[50];\n+  sqlite3_snprintf(sizeof(zData), zData, \"%lld\", sz);\n+  return sqlite3KvvfsMethods.xWrite(pFile->zClass, \"sz\", zData);\n+}\n+\n+\/****** sqlite3_io_methods methods ******************************************\/\n+\n+\/*\n+** Close an kvvfs-file.\n+*\/\n+static int kvvfsClose(sqlite3_file *pProtoFile){\n+  KVVfsFile *pFile = (KVVfsFile *)pProtoFile;\n+\n+  SQLITE_KV_LOG((\"xClose %s %s\\n\", pFile->zClass,\n+             pFile->isJournal ? \"journal\" : \"db\"));\n+  sqlite3_free(pFile->aJrnl);\n+  sqlite3_free(pFile->aData);\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Read from the -journal file.\n+*\/\n+static int kvvfsReadJrnl(\n+  sqlite3_file *pProtoFile,\n+  void *zBuf,\n+  int iAmt,\n+  sqlite_int64 iOfst\n+){\n+  KVVfsFile *pFile = (KVVfsFile*)pProtoFile;\n+  assert( pFile->isJournal );\n+  SQLITE_KV_LOG((\"xRead('%s-journal',%d,%lld)\\n\", pFile->zClass, iAmt, iOfst));\n+  if( pFile->aJrnl==0 ){\n+    int szTxt = kvstorageRead(pFile->zClass, \"jrnl\", 0, 0);\n+    char *aTxt;\n+    if( szTxt<=4 ){\n+      return SQLITE_IOERR;\n+    }\n+    aTxt = sqlite3_malloc64( szTxt+1 );\n+    if( aTxt==0 ) return SQLITE_NOMEM;\n+    kvstorageRead(pFile->zClass, \"jrnl\", aTxt, szTxt+1);\n+    kvvfsDecodeJournal(pFile, aTxt, szTxt);\n+    sqlite3_free(aTxt);\n+    if( pFile->aJrnl==0 ) return SQLITE_IOERR;\n+  }\n+  if( iOfst+iAmt>pFile->nJrnl ){\n+    return SQLITE_IOERR_SHORT_READ;\n+  }\n+  memcpy(zBuf, pFile->aJrnl+iOfst, iAmt);\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Read from the database file.\n+*\/\n+static int kvvfsReadDb(\n+  sqlite3_file *pProtoFile,\n+  void *zBuf,\n+  int iAmt,\n+  sqlite_int64 iOfst\n+){\n+  KVVfsFile *pFile = (KVVfsFile*)pProtoFile;\n+  unsigned int pgno;\n+  int got, n;\n+  char zKey[30];\n+  char *aData = pFile->aData;\n+  assert( iOfst>=0 );\n+  assert( iAmt>=0 );\n+  SQLITE_KV_LOG((\"xRead('%s-db',%d,%lld)\\n\", pFile->zClass, iAmt, iOfst));\n+  if( iOfst+iAmt>=512 ){\n+    if( (iOfst % iAmt)!=0 ){\n+      return SQLITE_IOERR_READ;\n+    }\n+    if( (iAmt & (iAmt-1))!=0 || iAmt<512 || iAmt>65536 ){\n+      return SQLITE_IOERR_READ;\n+    }\n+    pFile->szPage = iAmt;\n+    pgno = 1 + iOfst\/iAmt;\n+  }else{\n+    pgno = 1;\n+  }\n+  sqlite3_snprintf(sizeof(zKey), zKey, \"%u\", pgno);\n+  got = sqlite3KvvfsMethods.xRead(pFile->zClass, zKey,\n+                                  aData, SQLITE_KVOS_SZ-1);\n+  if( got<0 ){\n+    n = 0;\n+  }else{\n+    aData[got] = 0;\n+    if( iOfst+iAmt<512 ){\n+      int k = iOfst+iAmt;\n+      aData[k*2] = 0;\n+      n = kvvfsDecode(aData, &aData[2000], SQLITE_KVOS_SZ-2000);\n+      if( n>=iOfst+iAmt ){\n+        memcpy(zBuf, &aData[2000+iOfst], iAmt);\n+        n = iAmt;\n+      }else{\n+        n = 0;\n+      }\n+    }else{\n+      n = kvvfsDecode(aData, zBuf, iAmt);\n+    }\n+  }\n+  if( n<iAmt ){\n+    memset(zBuf+n, 0, iAmt-n);\n+    return SQLITE_IOERR_SHORT_READ;\n+  }\n+  return SQLITE_OK;\n+}\n+\n+\n+\/*\n+** Write into the -journal file.\n+*\/\n+static int kvvfsWriteJrnl(\n+  sqlite3_file *pProtoFile,\n+  const void *zBuf,\n+  int iAmt,\n+  sqlite_int64 iOfst\n+){\n+  KVVfsFile *pFile = (KVVfsFile*)pProtoFile;\n+  sqlite3_int64 iEnd = iOfst+iAmt;\n+  SQLITE_KV_LOG((\"xWrite('%s-journal',%d,%lld)\\n\", pFile->zClass, iAmt, iOfst));\n+  if( iEnd>=0x10000000 ) return SQLITE_FULL;\n+  if( pFile->aJrnl==0 || pFile->nJrnl<iEnd ){\n+    char *aNew = sqlite3_realloc(pFile->aJrnl, iEnd);\n+    if( aNew==0 ){\n+      return SQLITE_IOERR_NOMEM;\n+    }\n+    pFile->aJrnl = aNew;\n+    if( pFile->nJrnl<iOfst ){\n+      memset(pFile->aJrnl+pFile->nJrnl, 0, iOfst-pFile->nJrnl);\n+    }\n+    pFile->nJrnl = iEnd;\n+  }\n+  memcpy(pFile->aJrnl+iOfst, zBuf, iAmt);\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Write into the database file.\n+*\/\n+static int kvvfsWriteDb(\n+  sqlite3_file *pProtoFile,\n+  const void *zBuf,\n+  int iAmt,\n+  sqlite_int64 iOfst\n+){\n+  KVVfsFile *pFile = (KVVfsFile*)pProtoFile;\n+  unsigned int pgno;\n+  char zKey[30];\n+  char *aData = pFile->aData;\n+  SQLITE_KV_LOG((\"xWrite('%s-db',%d,%lld)\\n\", pFile->zClass, iAmt, iOfst));\n+  assert( iAmt>=512 && iAmt<=65536 );\n+  assert( (iAmt & (iAmt-1))==0 );\n+  assert( pFile->szPage<0 || pFile->szPage==iAmt );\n+  pFile->szPage = iAmt;\n+  pgno = 1 + iOfst\/iAmt;\n+  sqlite3_snprintf(sizeof(zKey), zKey, \"%u\", pgno);\n+  kvvfsEncode(zBuf, iAmt, aData);\n+  if( sqlite3KvvfsMethods.xWrite(pFile->zClass, zKey, aData) ){\n+    return SQLITE_IOERR;\n+  }\n+  if( iOfst+iAmt > pFile->szDb ){\n+    pFile->szDb = iOfst + iAmt;\n+  }\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Truncate an kvvfs-file.\n+*\/\n+static int kvvfsTruncateJrnl(sqlite3_file *pProtoFile, sqlite_int64 size){\n+  KVVfsFile *pFile = (KVVfsFile *)pProtoFile;\n+  SQLITE_KV_LOG((\"xTruncate('%s-journal',%lld)\\n\", pFile->zClass, size));\n+  assert( size==0 );\n+  sqlite3KvvfsMethods.xDelete(pFile->zClass, \"jrnl\");\n+  sqlite3_free(pFile->aJrnl);\n+  pFile->aJrnl = 0;\n+  pFile->nJrnl = 0;\n+  return SQLITE_OK;\n+}\n+static int kvvfsTruncateDb(sqlite3_file *pProtoFile, sqlite_int64 size){\n+  KVVfsFile *pFile = (KVVfsFile *)pProtoFile;\n+  if( pFile->szDb>size\n+   && pFile->szPage>0\n+   && (size % pFile->szPage)==0\n+  ){\n+    char zKey[50];\n+    unsigned int pgno, pgnoMax;\n+    SQLITE_KV_LOG((\"xTruncate('%s-db',%lld)\\n\", pFile->zClass, size));\n+    pgno = 1 + size\/pFile->szPage;\n+    pgnoMax = 2 + pFile->szDb\/pFile->szPage;\n+    while( pgno<=pgnoMax ){\n+      sqlite3_snprintf(sizeof(zKey), zKey, \"%u\", pgno);\n+      sqlite3KvvfsMethods.xDelete(pFile->zClass, zKey);\n+      pgno++;\n+    }\n+    pFile->szDb = size;\n+    return kvvfsWriteFileSize(pFile, size) ? SQLITE_IOERR : SQLITE_OK;\n+  }\n+  return SQLITE_IOERR;\n+}\n+\n+\/*\n+** Sync an kvvfs-file.\n+*\/\n+static int kvvfsSyncJrnl(sqlite3_file *pProtoFile, int flags){\n+  int i, n;\n+  KVVfsFile *pFile = (KVVfsFile *)pProtoFile;\n+  char *zOut;\n+  SQLITE_KV_LOG((\"xSync('%s-journal')\\n\", pFile->zClass));\n+  if( pFile->nJrnl<=0 ){\n+    return kvvfsTruncateJrnl(pProtoFile, 0);\n+  }\n+  zOut = sqlite3_malloc64( pFile->nJrnl*2 + 50 );\n+  if( zOut==0 ){\n+    return SQLITE_IOERR_NOMEM;\n+  }\n+  n = pFile->nJrnl;\n+  i = 0;\n+  do{\n+    zOut[i++] = 'a' + (n%26);\n+    n \/= 26;\n+  }while( n>0 );\n+  zOut[i++] = ' ';\n+  kvvfsEncode(pFile->aJrnl, pFile->nJrnl, &zOut[i]);\n+  i = sqlite3KvvfsMethods.xWrite(pFile->zClass, \"jrnl\", zOut);\n+  sqlite3_free(zOut);\n+  return i ? SQLITE_IOERR : SQLITE_OK;\n+}\n+static int kvvfsSyncDb(sqlite3_file *pProtoFile, int flags){\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Return the current file-size of an kvvfs-file.\n+*\/\n+static int kvvfsFileSizeJrnl(sqlite3_file *pProtoFile, sqlite_int64 *pSize){\n+  KVVfsFile *pFile = (KVVfsFile *)pProtoFile;\n+  SQLITE_KV_LOG((\"xFileSize('%s-journal')\\n\", pFile->zClass));\n+  *pSize = pFile->nJrnl;\n+  return SQLITE_OK;\n+}\n+static int kvvfsFileSizeDb(sqlite3_file *pProtoFile, sqlite_int64 *pSize){\n+  KVVfsFile *pFile = (KVVfsFile *)pProtoFile;\n+  SQLITE_KV_LOG((\"xFileSize('%s-db')\\n\", pFile->zClass));\n+  if( pFile->szDb>=0 ){\n+    *pSize = pFile->szDb;\n+  }else{\n+    *pSize = kvvfsReadFileSize(pFile);\n+  }\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Lock an kvvfs-file.\n+*\/\n+static int kvvfsLock(sqlite3_file *pProtoFile, int eLock){\n+  KVVfsFile *pFile = (KVVfsFile *)pProtoFile;\n+  assert( !pFile->isJournal );\n+  SQLITE_KV_LOG((\"xLock(%s,%d)\\n\", pFile->zClass, eLock));\n+\n+  if( eLock!=SQLITE_LOCK_NONE ){\n+    pFile->szDb = kvvfsReadFileSize(pFile);\n+  }\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Unlock an kvvfs-file.\n+*\/\n+static int kvvfsUnlock(sqlite3_file *pProtoFile, int eLock){\n+  KVVfsFile *pFile = (KVVfsFile *)pProtoFile;\n+  assert( !pFile->isJournal );\n+  SQLITE_KV_LOG((\"xUnlock(%s,%d)\\n\", pFile->zClass, eLock));\n+  if( eLock==SQLITE_LOCK_NONE ){\n+    pFile->szDb = -1;\n+  }\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Check if another file-handle holds a RESERVED lock on an kvvfs-file.\n+*\/\n+static int kvvfsCheckReservedLock(sqlite3_file *pProtoFile, int *pResOut){\n+  SQLITE_KV_LOG((\"xCheckReservedLock\\n\"));\n+  *pResOut = 0;\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** File control method. For custom operations on an kvvfs-file.\n+*\/\n+static int kvvfsFileControlJrnl(sqlite3_file *pProtoFile, int op, void *pArg){\n+  SQLITE_KV_LOG((\"xFileControl(%d) on journal\\n\", op));\n+  return SQLITE_NOTFOUND;\n+}\n+static int kvvfsFileControlDb(sqlite3_file *pProtoFile, int op, void *pArg){\n+  SQLITE_KV_LOG((\"xFileControl(%d) on database\\n\", op));\n+  if( op==SQLITE_FCNTL_SYNC ){\n+    KVVfsFile *pFile = (KVVfsFile *)pProtoFile;\n+    int rc = SQLITE_OK;\n+    SQLITE_KV_LOG((\"xSync('%s-db')\\n\", pFile->zClass));\n+    if( pFile->szDb>0 && 0!=kvvfsWriteFileSize(pFile, pFile->szDb) ){\n+      rc = SQLITE_IOERR;\n+    }\n+    return rc;\n+  }\n+  return SQLITE_NOTFOUND;\n+}\n+\n+\/*\n+** Return the sector-size in bytes for an kvvfs-file.\n+*\/\n+static int kvvfsSectorSize(sqlite3_file *pFile){\n+  return 512;\n+}\n+\n+\/*\n+** Return the device characteristic flags supported by an kvvfs-file.\n+*\/\n+static int kvvfsDeviceCharacteristics(sqlite3_file *pProtoFile){\n+  return 0;\n+}\n+\n+\/****** sqlite3_vfs methods *************************************************\/\n+\n+\/*\n+** Open an kvvfs file handle.\n+*\/\n+static int kvvfsOpen(\n+  sqlite3_vfs *pProtoVfs,\n+  const char *zName,\n+  sqlite3_file *pProtoFile,\n+  int flags,\n+  int *pOutFlags\n+){\n+  KVVfsFile *pFile = (KVVfsFile*)pProtoFile;\n+  if( zName==0 ) zName = \"\";\n+  SQLITE_KV_LOG((\"xOpen(\\\"%s\\\")\\n\", zName));\n+  if( strcmp(zName, \"local\")==0\n+   || strcmp(zName, \"session\")==0\n+  ){\n+    pFile->isJournal = 0;\n+    pFile->base.pMethods = &kvvfs_db_io_methods;\n+  }else\n+  if( strcmp(zName, \"local-journal\")==0\n+   || strcmp(zName, \"session-journal\")==0\n+  ){\n+    pFile->isJournal = 1;\n+    pFile->base.pMethods = &kvvfs_jrnl_io_methods;\n+  }else{\n+    return SQLITE_CANTOPEN;\n+  }\n+  if( zName[0]=='s' ){\n+    pFile->zClass = \"session\";\n+  }else{\n+    pFile->zClass = \"local\";\n+  }\n+  pFile->aData = sqlite3_malloc64(SQLITE_KVOS_SZ);\n+  if( pFile->aData==0 ){\n+    return SQLITE_NOMEM;\n+  }\n+  pFile->aJrnl = 0;\n+  pFile->nJrnl = 0;\n+  pFile->szPage = -1;\n+  pFile->szDb = -1;\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Delete the file located at zPath. If the dirSync argument is true,\n+** ensure the file-system modifications are synced to disk before\n+** returning.\n+*\/\n+static int kvvfsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){\n+  if( strcmp(zPath, \"local-journal\")==0 ){\n+    sqlite3KvvfsMethods.xDelete(\"local\", \"jrnl\");\n+  }else\n+  if( strcmp(zPath, \"session-journal\")==0 ){\n+    sqlite3KvvfsMethods.xDelete(\"session\", \"jrnl\");\n+  }\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Test for access permissions. Return true if the requested permission\n+** is available, or false otherwise.\n+*\/\n+static int kvvfsAccess(\n+  sqlite3_vfs *pProtoVfs,\n+  const char *zPath,\n+  int flags,\n+  int *pResOut\n+){\n+  SQLITE_KV_LOG((\"xAccess(\\\"%s\\\")\\n\", zPath));\n+  if( strcmp(zPath, \"local-journal\")==0 ){\n+    *pResOut = sqlite3KvvfsMethods.xRead(\"local\", \"jrnl\", 0, 0)>0;\n+  }else\n+  if( strcmp(zPath, \"session-journal\")==0 ){\n+    *pResOut = sqlite3KvvfsMethods.xRead(\"session\", \"jrnl\", 0, 0)>0;\n+  }else\n+  if( strcmp(zPath, \"local\")==0 ){\n+    *pResOut = sqlite3KvvfsMethods.xRead(\"local\", \"sz\", 0, 0)>0;\n+  }else\n+  if( strcmp(zPath, \"session\")==0 ){\n+    *pResOut = sqlite3KvvfsMethods.xRead(\"session\", \"sz\", 0, 0)>0;\n+  }else\n+  {\n+    *pResOut = 0;\n+  }\n+  SQLITE_KV_LOG((\"xAccess returns %d\\n\",*pResOut));\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Populate buffer zOut with the full canonical pathname corresponding\n+** to the pathname in zPath. zOut is guaranteed to point to a buffer\n+** of at least (INST_MAX_PATHNAME+1) bytes.\n+*\/\n+static int kvvfsFullPathname(\n+  sqlite3_vfs *pVfs,\n+  const char *zPath,\n+  int nOut,\n+  char *zOut\n+){\n+  size_t nPath;\n+#ifdef SQLITE_OS_KV_ALWAYS_LOCAL\n+  zPath = \"local\";\n+#endif\n+  nPath = strlen(zPath);\n+  SQLITE_KV_LOG((\"xFullPathname(\\\"%s\\\")\\n\", zPath));\n+  if( nOut<nPath+1 ) nPath = nOut - 1;\n+  memcpy(zOut, zPath, nPath);\n+  zOut[nPath] = 0;\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Open the dynamic library located at zPath and return a handle.\n+*\/\n+static void *kvvfsDlOpen(sqlite3_vfs *pVfs, const char *zPath){\n+  return 0;\n+}\n+\n+\/*\n+** Populate the buffer pointed to by zBufOut with nByte bytes of\n+** random data.\n+*\/\n+static int kvvfsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){\n+  memset(zBufOut, 0, nByte);\n+  return nByte;\n+}\n+\n+\/*\n+** Sleep for nMicro microseconds. Return the number of microseconds\n+** actually slept.\n+*\/\n+static int kvvfsSleep(sqlite3_vfs *pVfs, int nMicro){\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Return the current time as a Julian Day number in *pTimeOut.\n+*\/\n+static int kvvfsCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){\n+  sqlite3_int64 i = 0;\n+  int rc;\n+  rc = kvvfsCurrentTimeInt64(0, &i);\n+  *pTimeOut = i\/86400000.0;\n+  return rc;\n+}\n+#include <sys\/time.h>\n+static int kvvfsCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *pTimeOut){\n+  static const sqlite3_int64 unixEpoch = 24405875*(sqlite3_int64)8640000;\n+  struct timeval sNow;\n+  (void)gettimeofday(&sNow, 0);  \/* Cannot fail given valid arguments *\/\n+  *pTimeOut = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_usec\/1000;\n+  return SQLITE_OK;\n+}\n+#endif \/* SQLITE_OS_KV || SQLITE_OS_UNIX *\/\n+\n+#if SQLITE_OS_KV\n+\/*\n+** This routine is called initialize the KV-vfs as the default VFS.\n+*\/\n+SQLITE_API int sqlite3_os_init(void){\n+  return sqlite3_vfs_register(&sqlite3OsKvvfsObject, 1);\n+}\n+SQLITE_API int sqlite3_os_end(void){\n+  return SQLITE_OK;\n+}\n+#endif \/* SQLITE_OS_KV *\/\n+\n+#if SQLITE_OS_UNIX && defined(SQLITE_OS_KV_OPTIONAL)\n+SQLITE_PRIVATE int sqlite3KvvfsInit(void){\n+  return sqlite3_vfs_register(&sqlite3OsKvvfsObject, 0);\n+}\n+#endif\n+\n+\/************** End of os_kv.c ***********************************************\/\n@@ -35500,1 +38054,1 @@\n-** in the correct division and should be clearly labeled.\n+** in the correct division and should be clearly labelled.\n@@ -35550,1 +38104,1 @@\n-#if defined(__APPLE__)\n+#if defined(__APPLE__) || defined(__linux__)\n@@ -35565,2 +38119,2 @@\n-#include <sys\/types.h>\n-#include <sys\/stat.h>\n+#include <sys\/types.h>   \/* amalgamator: keep *\/\n+#include <sys\/stat.h>    \/* amalgamator: keep *\/\n@@ -35569,1 +38123,1 @@\n-#include <unistd.h>\n+#include <unistd.h>      \/* amalgamator: keep *\/\n@@ -35571,1 +38125,1 @@\n-#include <sys\/time.h>\n+#include <sys\/time.h>    \/* amalgamator: keep *\/\n@@ -35573,1 +38127,2 @@\n-#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0\n+#if (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0) \\\n+  && !defined(SQLITE_WASI)\n@@ -35661,0 +38216,36 @@\n+\/*\n+** Remove and stub certain info for WASI (WebAssembly System\n+** Interface) builds.\n+*\/\n+#ifdef SQLITE_WASI\n+# undef HAVE_FCHMOD\n+# undef HAVE_FCHOWN\n+# undef HAVE_MREMAP\n+# define HAVE_MREMAP 0\n+# ifndef SQLITE_DEFAULT_UNIX_VFS\n+#  define SQLITE_DEFAULT_UNIX_VFS \"unix-dotfile\"\n+   \/* ^^^ should SQLITE_DEFAULT_UNIX_VFS be \"unix-none\"? *\/\n+# endif\n+# ifndef F_RDLCK\n+#  define F_RDLCK 0\n+#  define F_WRLCK 1\n+#  define F_UNLCK 2\n+#  if __LONG_MAX == 0x7fffffffL\n+#   define F_GETLK 12\n+#   define F_SETLK 13\n+#   define F_SETLKW 14\n+#  else\n+#   define F_GETLK 5\n+#   define F_SETLK 6\n+#   define F_SETLKW 7\n+#  endif\n+# endif\n+#else \/* !SQLITE_WASI *\/\n+# ifndef HAVE_FCHMOD\n+#  define HAVE_FCHMOD\n+# endif\n+#endif \/* SQLITE_WASI *\/\n+\n+#ifdef SQLITE_WASI\n+# define osGetpid(X) (pid_t)1\n+#else\n@@ -35663,1 +38254,2 @@\n-#define osGetpid(X) (pid_t)getpid()\n+# define osGetpid(X) (pid_t)getpid()\n+#endif\n@@ -35935,0 +38527,1 @@\n+#if defined(HAVE_FCHMOD)\n@@ -35936,0 +38529,3 @@\n+#else\n+  { \"fchmod\",       (sqlite3_syscall_ptr)0,               0  },\n+#endif\n@@ -35971,1 +38567,2 @@\n-#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0\n+#if (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0) \\\n+  && !defined(SQLITE_WASI)\n@@ -35978,1 +38575,2 @@\n-#if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0\n+#if (!defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0) \\\n+  && !defined(SQLITE_WASI)\n@@ -36043,1 +38641,1 @@\n-** \"unix\" VFSes.  Return SQLITE_OK opon successfully updating the\n+** \"unix\" VFSes.  Return SQLITE_OK upon successfully updating the\n@@ -36164,0 +38762,3 @@\n+    if( (f & (O_EXCL|O_CREAT))==(O_EXCL|O_CREAT) ){\n+      (void)osUnlink(z);\n+    }\n@@ -36562,1 +39163,1 @@\n-** maintains a count of the number of pending locks on tha inode.\n+** maintains a count of the number of pending locks on the inode.\n@@ -36576,1 +39177,1 @@\n-** if the appliation uses the newer Native Posix Thread Library (NPTL)\n+** if the application uses the newer Native Posix Thread Library (NPTL)\n@@ -36778,1 +39379,1 @@\n-** Close all file descriptors accumuated in the unixInodeInfo->pUnused list.\n+** Close all file descriptors accumulated in the unixInodeInfo->pUnused list.\n@@ -37126,1 +39727,1 @@\n-**    SHARED -> (PENDING) -> EXCLUSIVE\n+**    SHARED -> EXCLUSIVE\n@@ -37141,1 +39742,1 @@\n-  ** Symbols defined in os.h indentify the 'pending byte' and the 'reserved\n+  ** Symbols defined in os.h identify the 'pending byte' and the 'reserved\n@@ -37149,1 +39750,1 @@\n-  ** and Widnows95 lacks a shared-lock capability.  So on Windows95, a\n+  ** and Windows95 lacks a shared-lock capability.  So on Windows95, a\n@@ -37159,7 +39760,5 @@\n-  ** A process may only obtain a PENDING lock after it has obtained a\n-  ** SHARED lock. A PENDING lock is implemented by obtaining a write-lock\n-  ** on the 'pending byte'. This ensures that no new SHARED locks can be\n-  ** obtained, but existing SHARED locks are allowed to persist. A process\n-  ** does not have to obtain a RESERVED lock on the way to a PENDING lock.\n-  ** This property is used by the algorithm for rolling back a journal file\n-  ** after a crash.\n+  ** An EXCLUSIVE lock may only be requested after either a SHARED or\n+  ** RESERVED lock is held. An EXCLUSIVE lock is implemented by obtaining\n+  ** a write-lock on the entire 'shared byte range'. Since all other locks\n+  ** require a read-lock on one of the bytes within this range, this ensures\n+  ** that no other locks are held on the database.\n@@ -37167,5 +39766,8 @@\n-  ** An EXCLUSIVE lock, obtained after a PENDING lock is held, is\n-  ** implemented by obtaining a write-lock on the entire 'shared byte\n-  ** range'. Since all other locks require a read-lock on one of the bytes\n-  ** within this range, this ensures that no other locks are held on the\n-  ** database.\n+  ** If a process that holds a RESERVED lock requests an EXCLUSIVE, then\n+  ** a PENDING lock is obtained first. A PENDING lock is implemented by\n+  ** obtaining a write-lock on the 'pending byte'. This ensures that no new\n+  ** SHARED locks can be obtained, but existing SHARED locks are allowed to\n+  ** persist. If the call to this function fails to obtain the EXCLUSIVE\n+  ** lock in this case, it holds the PENDING lock instead. The client may\n+  ** then re-attempt the EXCLUSIVE lock later on, after existing SHARED\n+  ** locks have cleared.\n@@ -37197,1 +39799,1 @@\n-  **  (2) SQLite never explicitly requests a pendig lock.\n+  **  (2) SQLite never explicitly requests a pending lock.\n@@ -37242,1 +39844,1 @@\n-      || (eFileLock==EXCLUSIVE_LOCK && pFile->eFileLock<PENDING_LOCK)\n+   || (eFileLock==EXCLUSIVE_LOCK && pFile->eFileLock==RESERVED_LOCK)\n@@ -37253,0 +39855,3 @@\n+    }else if( eFileLock==EXCLUSIVE_LOCK ){\n+      pFile->eFileLock = PENDING_LOCK;\n+      pInode->eFileLock = PENDING_LOCK;\n@@ -37340,1 +39945,0 @@\n-\n@@ -37344,3 +39948,0 @@\n-  }else if( eFileLock==EXCLUSIVE_LOCK ){\n-    pFile->eFileLock = PENDING_LOCK;\n-    pInode->eFileLock = PENDING_LOCK;\n@@ -38416,1 +41017,1 @@\n-  **  (2) SQLite never explicitly requests a pendig lock.\n+  **  (2) SQLite never explicitly requests a pending lock.\n@@ -38532,1 +41133,1 @@\n-        \/* now attemmpt to get the exclusive lock range *\/\n+        \/* now attempt to get the exclusive lock range *\/\n@@ -38581,3 +41182,0 @@\n-#ifdef SQLITE_TEST\n-  int h = pFile->h;\n-#endif\n@@ -38599,3 +41197,0 @@\n-    SimulateIOErrorBenign(1);\n-    SimulateIOError( h=(-1) )\n-    SimulateIOErrorBenign(0);\n@@ -38650,3 +41245,0 @@\n-      SimulateIOErrorBenign(1);\n-      SimulateIOError( h=(-1) )\n-      SimulateIOErrorBenign(0);\n@@ -38753,6 +41345,0 @@\n-** NB:  If you define USE_PREAD or USE_PREAD64, then it might also\n-** be necessary to define _XOPEN_SOURCE to be 500.  This varies from\n-** one system to another.  Since SQLite does not define USE_PREAD\n-** in any form by default, we will not attempt to define _XOPEN_SOURCE.\n-** See tickets #2741 and #2681.\n-**\n@@ -38833,1 +41419,1 @@\n-  \/* Deal with as much of this read request as possible by transfering\n+  \/* Deal with as much of this read request as possible by transferring\n@@ -38985,1 +41571,1 @@\n-  \/* Deal with as much of this write request as possible by transfering\n+  \/* Deal with as much of this write request as possible by transferring\n@@ -39107,1 +41693,1 @@\n-  ** coverate testing.\n+  ** coverage testing.\n@@ -39500,0 +42086,1 @@\n+#if SQLITE_ENABLE_SETLK_TIMEOUT==1\n@@ -39501,0 +42088,5 @@\n+#elif SQLITE_ENABLE_SETLK_TIMEOUT==2\n+      pFile->iBusyTimeout = !!(*(int*)pArg);\n+#else\n+# error \"SQLITE_ENABLE_SETLK_TIMEOUT must be set to 1 or 2\"\n+#endif\n@@ -39753,0 +42345,19 @@\n+**\n+** aLock[SQLITE_SHM_NLOCK]:\n+**   This array records the various locks held by clients on each of the\n+**   SQLITE_SHM_NLOCK slots. If the aLock[] entry is set to 0, then no\n+**   locks are held by the process on this slot. If it is set to -1, then\n+**   some client holds an EXCLUSIVE lock on the locking slot. If the aLock[]\n+**   value is set to a positive value, then it is the number of shared\n+**   locks currently held on the slot.\n+**\n+** aMutex[SQLITE_SHM_NLOCK]:\n+**   Normally, when SQLITE_ENABLE_SETLK_TIMEOUT is not defined, mutex\n+**   pShmMutex is used to protect the aLock[] array and the right to\n+**   call fcntl() on unixShmNode.hShm to obtain or release locks.\n+**\n+**   If SQLITE_ENABLE_SETLK_TIMEOUT is defined though, we use an array\n+**   of mutexes - one for each locking slot. To read or write locking\n+**   slot aLock[iSlot], the caller must hold the corresponding mutex\n+**   aMutex[iSlot]. Similarly, to call fcntl() to obtain or release a\n+**   lock corresponding to slot iSlot, mutex aMutex[iSlot] must be held.\n@@ -39766,0 +42377,3 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+  sqlite3_mutex *aMutex[SQLITE_SHM_NLOCK];\n+#endif\n@@ -39768,2 +42382,0 @@\n-  u8 exclMask;               \/* Mask of exclusive locks held *\/\n-  u8 sharedMask;             \/* Mask of shared locks held *\/\n@@ -39852,1 +42464,0 @@\n-  \/* Access to the unixShmNode object is serialized by the caller *\/\n@@ -39854,2 +42465,21 @@\n-  assert( pShmNode->nRef==0 || sqlite3_mutex_held(pShmNode->pShmMutex) );\n-  assert( pShmNode->nRef>0 || unixMutexHeld() );\n+\n+  \/* Assert that the parameters are within expected range and that the\n+  ** correct mutex or mutexes are held. *\/\n+  assert( pShmNode->nRef>=0 );\n+  assert( (ofst==UNIX_SHM_DMS && n==1)\n+       || (ofst>=UNIX_SHM_BASE && ofst+n<=(UNIX_SHM_BASE+SQLITE_SHM_NLOCK))\n+  );\n+  if( ofst==UNIX_SHM_DMS ){\n+    assert( pShmNode->nRef>0 || unixMutexHeld() );\n+    assert( pShmNode->nRef==0 || sqlite3_mutex_held(pShmNode->pShmMutex) );\n+  }else{\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+    int ii;\n+    for(ii=ofst-UNIX_SHM_BASE; ii<ofst-UNIX_SHM_BASE+n; ii++){\n+      assert( sqlite3_mutex_held(pShmNode->aMutex[ii]) );\n+    }\n+#else\n+    assert( sqlite3_mutex_held(pShmNode->pShmMutex) );\n+    assert( pShmNode->nRef>0 );\n+#endif\n+  }\n@@ -39862,0 +42492,1 @@\n+  assert( ofst>=UNIX_SHM_BASE && ofst<=(UNIX_SHM_DMS+SQLITE_SHM_NLOCK) );\n@@ -39872,1 +42503,1 @@\n-#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+#if defined(SQLITE_ENABLE_SETLK_TIMEOUT) && SQLITE_ENABLE_SETLK_TIMEOUT==1\n@@ -39880,1 +42511,1 @@\n-  \/* Update the global lock state and do debug tracing *\/\n+  \/* Do debug tracing *\/\n@@ -39882,1 +42513,0 @@\n-  { u16 mask;\n@@ -39884,1 +42514,0 @@\n-  mask = ofst>31 ? 0xffff : (1<<(ofst+n)) - (1<<ofst);\n@@ -39887,3 +42516,1 @@\n-      OSTRACE((\"unlock %d ok\", ofst));\n-      pShmNode->exclMask &= ~mask;\n-      pShmNode->sharedMask &= ~mask;\n+      OSTRACE((\"unlock %d..%d ok\\n\", ofst, ofst+n-1));\n@@ -39891,3 +42518,1 @@\n-      OSTRACE((\"read-lock %d ok\", ofst));\n-      pShmNode->exclMask &= ~mask;\n-      pShmNode->sharedMask |= mask;\n+      OSTRACE((\"read-lock %d..%d ok\\n\", ofst, ofst+n-1));\n@@ -39896,3 +42521,1 @@\n-      OSTRACE((\"write-lock %d ok\", ofst));\n-      pShmNode->exclMask |= mask;\n-      pShmNode->sharedMask &= ~mask;\n+      OSTRACE((\"write-lock %d..%d ok\\n\", ofst, ofst+n-1));\n@@ -39902,1 +42525,1 @@\n-      OSTRACE((\"unlock %d failed\", ofst));\n+      OSTRACE((\"unlock %d..%d failed\\n\", ofst, ofst+n-1));\n@@ -39904,1 +42527,1 @@\n-      OSTRACE((\"read-lock failed\"));\n+      OSTRACE((\"read-lock %d..%d failed\\n\", ofst, ofst+n-1));\n@@ -39907,1 +42530,1 @@\n-      OSTRACE((\"write-lock %d failed\", ofst));\n+      OSTRACE((\"write-lock %d..%d failed\\n\", ofst, ofst+n-1));\n@@ -39910,3 +42533,0 @@\n-  OSTRACE((\" - afterwards %03x,%03x\\n\",\n-           pShmNode->sharedMask, pShmNode->exclMask));\n-  }\n@@ -39949,0 +42569,5 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+    for(i=0; i<SQLITE_SHM_NLOCK; i++){\n+      sqlite3_mutex_free(p->aMutex[i]);\n+    }\n+#endif\n@@ -40008,0 +42633,10 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+      \/* Do not use a blocking lock here. If the lock cannot be obtained\n+      ** immediately, it means some other connection is truncating the\n+      ** *-shm file. And after it has done so, it will not release its\n+      ** lock, but only downgrade it to a shared lock. So no point in\n+      ** blocking here. The call below to obtain the shared DMS lock may\n+      ** use a blocking lock. *\/\n+      int iSaveTimeout = pDbFd->iBusyTimeout;\n+      pDbFd->iBusyTimeout = 0;\n+#endif\n@@ -40009,0 +42644,3 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+      pDbFd->iBusyTimeout = iSaveTimeout;\n+#endif\n@@ -40129,0 +42767,12 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+      {\n+        int ii;\n+        for(ii=0; ii<SQLITE_SHM_NLOCK; ii++){\n+          pShmNode->aMutex[ii] = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);\n+          if( pShmNode->aMutex[ii]==0 ){\n+            rc = SQLITE_NOMEM_BKPT;\n+            goto shm_open_err;\n+          }\n+        }\n+      }\n+#endif\n@@ -40350,0 +43000,3 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+  return 1;\n+#else\n@@ -40352,1 +43005,0 @@\n-  assert( sqlite3_mutex_held(pShmNode->pShmMutex) );\n@@ -40370,0 +43022,1 @@\n+#endif\n@@ -40376,1 +43029,1 @@\n-** Note that the relationship between SHAREd and EXCLUSIVE locks is a little\n+** Note that the relationship between SHARED and EXCLUSIVE locks is a little\n@@ -40391,1 +43044,1 @@\n-  u16 mask;                             \/* Mask of locks to take or release *\/\n+  u16 mask = (1<<(ofst+n)) - (1<<ofst); \/* Mask of locks to take or release *\/\n@@ -40426,6 +43079,9 @@\n-  assert( (flags & SQLITE_SHM_UNLOCK) || pDbFd->iBusyTimeout==0 || (\n-         (ofst!=2)                                   \/* not RECOVER *\/\n-      && (ofst!=1 || (p->exclMask|p->sharedMask)==0)\n-      && (ofst!=0 || (p->exclMask|p->sharedMask)<3)\n-      && (ofst<3  || (p->exclMask|p->sharedMask)<(1<<ofst))\n-  ));\n+  {\n+    u16 lockMask = (p->exclMask|p->sharedMask);\n+    assert( (flags & SQLITE_SHM_UNLOCK) || pDbFd->iBusyTimeout==0 || (\n+          (ofst!=2)                                   \/* not RECOVER *\/\n+       && (ofst!=1 || lockMask==0 || lockMask==2)\n+       && (ofst!=0 || lockMask<3)\n+       && (ofst<3  || lockMask<(1<<ofst))\n+    ));\n+  }\n@@ -40434,8 +43090,16 @@\n-  mask = (1<<(ofst+n)) - (1<<ofst);\n-  assert( n>1 || mask==(1<<ofst) );\n-  sqlite3_mutex_enter(pShmNode->pShmMutex);\n-  assert( assertLockingArrayOk(pShmNode) );\n-  if( flags & SQLITE_SHM_UNLOCK ){\n-    if( (p->exclMask|p->sharedMask) & mask ){\n-      int ii;\n-      int bUnlock = 1;\n+  \/* Check if there is any work to do. There are three cases:\n+  **\n+  **    a) An unlock operation where there are locks to unlock,\n+  **    b) An shared lock where the requested lock is not already held\n+  **    c) An exclusive lock where the requested lock is not already held\n+  **\n+  ** The SQLite core never requests an exclusive lock that it already holds.\n+  ** This is assert()ed below.\n+  *\/\n+  assert( flags!=(SQLITE_SHM_EXCLUSIVE|SQLITE_SHM_LOCK)\n+       || 0==(p->exclMask & mask)\n+  );\n+  if( ((flags & SQLITE_SHM_UNLOCK) && ((p->exclMask|p->sharedMask) & mask))\n+   || (flags==(SQLITE_SHM_SHARED|SQLITE_SHM_LOCK) && 0==(p->sharedMask & mask))\n+   || (flags==(SQLITE_SHM_EXCLUSIVE|SQLITE_SHM_LOCK))\n+  ){\n@@ -40443,4 +43107,23 @@\n-      for(ii=ofst; ii<ofst+n; ii++){\n-        if( aLock[ii]>((p->sharedMask & (1<<ii)) ? 1 : 0) ){\n-          bUnlock = 0;\n-        }\n+    \/* Take the required mutexes. In SETLK_TIMEOUT mode (blocking locks), if\n+    ** this is an attempt on an exclusive lock use sqlite3_mutex_try(). If any\n+    ** other thread is holding this mutex, then it is either holding or about\n+    ** to hold a lock exclusive to the one being requested, and we may\n+    ** therefore return SQLITE_BUSY to the caller.\n+    **\n+    ** Doing this prevents some deadlock scenarios. For example, thread 1 may\n+    ** be a checkpointer blocked waiting on the WRITER lock. And thread 2\n+    ** may be a normal SQL client upgrading to a write transaction. In this\n+    ** case thread 2 does a non-blocking request for the WRITER lock. But -\n+    ** if it were to use sqlite3_mutex_enter() then it would effectively\n+    ** become a (doomed) blocking request, as thread 2 would block until thread\n+    ** 1 obtained WRITER and released the mutex. Since thread 2 already holds\n+    ** a lock on a read-locking slot at this point, this breaks the\n+    ** anti-deadlock rules (see above).  *\/\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+    int iMutex;\n+    for(iMutex=ofst; iMutex<ofst+n; iMutex++){\n+      if( flags==(SQLITE_SHM_LOCK|SQLITE_SHM_EXCLUSIVE) ){\n+        rc = sqlite3_mutex_try(pShmNode->aMutex[iMutex]);\n+        if( rc!=SQLITE_OK ) goto leave_shmnode_mutexes;\n+      }else{\n+        sqlite3_mutex_enter(pShmNode->aMutex[iMutex]);\n@@ -40448,0 +43131,4 @@\n+    }\n+#else\n+    sqlite3_mutex_enter(pShmNode->pShmMutex);\n+#endif\n@@ -40449,4 +43136,20 @@\n-      if( bUnlock ){\n-        rc = unixShmSystemLock(pDbFd, F_UNLCK, ofst+UNIX_SHM_BASE, n);\n-        if( rc==SQLITE_OK ){\n-          memset(&aLock[ofst], 0, sizeof(int)*n);\n+    if( ALWAYS(rc==SQLITE_OK) ){\n+      if( flags & SQLITE_SHM_UNLOCK ){\n+        \/* Case (a) - unlock.  *\/\n+        int bUnlock = 1;\n+        assert( (p->exclMask & p->sharedMask)==0 );\n+        assert( !(flags & SQLITE_SHM_EXCLUSIVE) || (p->exclMask & mask)==mask );\n+        assert( !(flags & SQLITE_SHM_SHARED) || (p->sharedMask & mask)==mask );\n+\n+        \/* If this is a SHARED lock being unlocked, it is possible that other\n+        ** clients within this process are holding the same SHARED lock. In\n+        ** this case, set bUnlock to 0 so that the posix lock is not removed\n+        ** from the file-descriptor below.  *\/\n+        if( flags & SQLITE_SHM_SHARED ){\n+          assert( n==1 );\n+          assert( aLock[ofst]>=1 );\n+          if( aLock[ofst]>1 ){\n+            bUnlock = 0;\n+            aLock[ofst]--;\n+            p->sharedMask &= ~mask;\n+          }\n@@ -40454,4 +43157,0 @@\n-      }else if( ALWAYS(p->sharedMask & (1<<ofst)) ){\n-        assert( n==1 && aLock[ofst]>1 );\n-        aLock[ofst]--;\n-      }\n@@ -40459,15 +43158,10 @@\n-      \/* Undo the local locks *\/\n-      if( rc==SQLITE_OK ){\n-        p->exclMask &= ~mask;\n-        p->sharedMask &= ~mask;\n-      }\n-    }\n-  }else if( flags & SQLITE_SHM_SHARED ){\n-    assert( n==1 );\n-    assert( (p->exclMask & (1<<ofst))==0 );\n-    if( (p->sharedMask & mask)==0 ){\n-      if( aLock[ofst]<0 ){\n-        rc = SQLITE_BUSY;\n-      }else if( aLock[ofst]==0 ){\n-        rc = unixShmSystemLock(pDbFd, F_RDLCK, ofst+UNIX_SHM_BASE, n);\n-      }\n+        if( bUnlock ){\n+          rc = unixShmSystemLock(pDbFd, F_UNLCK, ofst+UNIX_SHM_BASE, n);\n+          if( rc==SQLITE_OK ){\n+            memset(&aLock[ofst], 0, sizeof(int)*n);\n+            p->sharedMask &= ~mask;\n+            p->exclMask &= ~mask;\n+          }\n+        }\n+      }else if( flags & SQLITE_SHM_SHARED ){\n+        \/* Case (b) - a shared lock.  *\/\n@@ -40475,17 +43169,6 @@\n-      \/* Get the local shared locks *\/\n-      if( rc==SQLITE_OK ){\n-        p->sharedMask |= mask;\n-        aLock[ofst]++;\n-      }\n-    }\n-  }else{\n-    \/* Make sure no sibling connections hold locks that will block this\n-    ** lock.  If any do, return SQLITE_BUSY right away.  *\/\n-    int ii;\n-    for(ii=ofst; ii<ofst+n; ii++){\n-      assert( (p->sharedMask & mask)==0 );\n-      if( ALWAYS((p->exclMask & (1<<ii))==0) && aLock[ii] ){\n-        rc = SQLITE_BUSY;\n-        break;\n-      }\n-    }\n+        if( aLock[ofst]<0 ){\n+          \/* An exclusive lock is held by some other connection. BUSY. *\/\n+          rc = SQLITE_BUSY;\n+        }else if( aLock[ofst]==0 ){\n+          rc = unixShmSystemLock(pDbFd, F_RDLCK, ofst+UNIX_SHM_BASE, n);\n+        }\n@@ -40493,5 +43176,10 @@\n-    \/* Get the exclusive locks at the system level. Then if successful\n-    ** also update the in-memory values. *\/\n-    if( rc==SQLITE_OK ){\n-      rc = unixShmSystemLock(pDbFd, F_WRLCK, ofst+UNIX_SHM_BASE, n);\n-      if( rc==SQLITE_OK ){\n+        \/* Get the local shared locks *\/\n+        if( rc==SQLITE_OK ){\n+          p->sharedMask |= mask;\n+          aLock[ofst]++;\n+        }\n+      }else{\n+        \/* Case (c) - an exclusive lock.  *\/\n+        int ii;\n+\n+        assert( flags==(SQLITE_SHM_LOCK|SQLITE_SHM_EXCLUSIVE) );\n@@ -40499,1 +43187,4 @@\n-        p->exclMask |= mask;\n+        assert( (p->exclMask & mask)==0 );\n+\n+        \/* Make sure no sibling connections hold locks that will block this\n+        ** lock.  If any do, return SQLITE_BUSY right away.  *\/\n@@ -40501,1 +43192,16 @@\n-          aLock[ii] = -1;\n+          if( aLock[ii] ){\n+            rc = SQLITE_BUSY;\n+            break;\n+          }\n+        }\n+\n+        \/* Get the exclusive locks at the system level. Then if successful\n+        ** also update the in-memory values. *\/\n+        if( rc==SQLITE_OK ){\n+          rc = unixShmSystemLock(pDbFd, F_WRLCK, ofst+UNIX_SHM_BASE, n);\n+          if( rc==SQLITE_OK ){\n+            p->exclMask |= mask;\n+            for(ii=ofst; ii<ofst+n; ii++){\n+              aLock[ii] = -1;\n+            }\n+          }\n@@ -40504,0 +43210,8 @@\n+      assert( assertLockingArrayOk(pShmNode) );\n+    }\n+\n+    \/* Drop the mutexes acquired above. *\/\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+  leave_shmnode_mutexes:\n+    for(iMutex--; iMutex>=ofst; iMutex--){\n+      sqlite3_mutex_leave(pShmNode->aMutex[iMutex]);\n@@ -40505,0 +43219,3 @@\n+#else\n+    sqlite3_mutex_leave(pShmNode->pShmMutex);\n+#endif\n@@ -40506,2 +43223,1 @@\n-  assert( assertLockingArrayOk(pShmNode) );\n-  sqlite3_mutex_leave(pShmNode->pShmMutex);\n+\n@@ -40757,0 +43473,5 @@\n+    \/* Ensure that there is always at least a 256 byte buffer of addressable\n+    ** memory following the returned page. If the database is corrupt,\n+    ** SQLite may overread the page slightly (in practice only a few bytes,\n+    ** but 256 is safe, round, number).  *\/\n+    const int nEofBuffer = 256;\n@@ -40761,1 +43482,1 @@\n-    if( pFd->mmapSize >= iOff+nAmt ){\n+    if( pFd->mmapSize >= (iOff+nAmt+nEofBuffer) ){\n@@ -41937,3 +44658,3 @@\n-      if( pPath->nUsed<=1 ){\n-        pPath->rc = SQLITE_ERROR;\n-        return;\n+      if( pPath->nUsed>1 ){\n+        assert( pPath->zOut[0]=='\/' );\n+        while( pPath->zOut[--pPath->nUsed]!='\/' ){}\n@@ -41941,2 +44662,0 @@\n-      assert( pPath->zOut[0]=='\/' );\n-      while( pPath->zOut[--pPath->nUsed]!='\/' ){}\n@@ -42154,1 +44873,1 @@\n-#if OS_VXWORKS\n+#if !defined(HAVE_NANOSLEEP) || HAVE_NANOSLEEP+0\n@@ -42156,1 +44875,0 @@\n-\n@@ -42159,0 +44877,5 @@\n+\n+  \/* Almost all modern unix systems support nanosleep().  But if you are\n+  ** compiling for one of the rare exceptions, you can use\n+  ** -DHAVE_NANOSLEEP=0 (perhaps in conjuction with -DHAVE_USLEEP if\n+  ** usleep() is available) in order to bypass the use of nanosleep() *\/\n@@ -42160,0 +44883,1 @@\n+\n@@ -43536,0 +46260,4 @@\n+#ifdef SQLITE_DEFAULT_UNIX_VFS\n+    sqlite3_vfs_register(&aVfs[i],\n+           0==strcmp(aVfs[i].zName,SQLITE_DEFAULT_UNIX_VFS));\n+#else\n@@ -43537,0 +46265,1 @@\n+#endif\n@@ -43538,0 +46267,3 @@\n+#ifdef SQLITE_OS_KV_OPTIONAL\n+  sqlite3KvvfsInit();\n+#endif\n@@ -44741,1 +47473,1 @@\n-** \"win32\" VFSes.  Return SQLITE_OK opon successfully updating the\n+** \"win32\" VFSes.  Return SQLITE_OK upon successfully updating the\n@@ -46321,1 +49053,1 @@\n-  \/* Deal with as much of this read request as possible by transfering\n+  \/* Deal with as much of this read request as possible by transferring\n@@ -46399,1 +49131,1 @@\n-  \/* Deal with as much of this write request as possible by transfering\n+  \/* Deal with as much of this write request as possible by transferring\n@@ -46509,1 +49241,1 @@\n-    ** now to simply make trancations a no-op if there are pending reads.  We\n+    ** now to simply make transactions a no-op if there are pending reads.  We\n@@ -46568,1 +49300,1 @@\n-** that syncs and fullsyncs are occuring at the right times.\n+** that syncs and fullsyncs are occurring at the right times.\n@@ -46925,1 +49657,1 @@\n-    res = winUnlockReadLock(pFile);\n+    (void)winUnlockReadLock(pFile);\n@@ -48103,0 +50835,5 @@\n+    \/* Ensure that there is always at least a 256 byte buffer of addressable\n+    ** memory following the returned page. If the database is corrupt,\n+    ** SQLite may overread the page slightly (in practice only a few bytes,\n+    ** but 256 is safe, round, number).  *\/\n+    const int nEofBuffer = 256;\n@@ -48111,1 +50848,1 @@\n-    if( pFd->mmapSize >= iOff+nAmt ){\n+    if( pFd->mmapSize >= (iOff+nAmt+nEofBuffer) ){\n@@ -48307,1 +51044,1 @@\n-** If sqlite3_temp_directory is not, take the mutex and return true.\n+** If sqlite3_temp_directory is defined, take the mutex and return true.\n@@ -48309,1 +51046,2 @@\n-** If sqlite3_temp_directory is NULL, omit the mutex and return false.\n+** If sqlite3_temp_directory is NULL (undefined), omit the mutex and\n+** return false.\n@@ -48328,0 +51066,1 @@\n+  DWORD pid;\n@@ -48540,0 +51279,1 @@\n+  pid = osGetCurrentProcessId();\n@@ -48541,0 +51281,2 @@\n+    zBuf[j] += pid & 0xff;\n+    pid >>= 8;\n@@ -48778,1 +51520,1 @@\n-        rc2 = winAccess(pVfs, zName, SQLITE_ACCESS_READ, &isRO);\n+        rc2 = winAccess(pVfs, zUtf8Name, SQLITE_ACCESS_READ, &isRO);\n@@ -48795,1 +51537,1 @@\n-        rc2 = winAccess(pVfs, zName, SQLITE_ACCESS_READ, &isRO);\n+        rc2 = winAccess(pVfs, zUtf8Name, SQLITE_ACCESS_READ, &isRO);\n@@ -48815,1 +51557,1 @@\n-        rc2 = winAccess(pVfs, zName, SQLITE_ACCESS_READ, &isRO);\n+        rc2 = winAccess(pVfs, zUtf8Name, SQLITE_ACCESS_READ, &isRO);\n@@ -49038,0 +51780,7 @@\n+  if( zFilename==0 ){\n+    *pResOut = 0;\n+    OSTRACE((\"ACCESS name=%s, pResOut=%p, *pResOut=%d, rc=SQLITE_OK\\n\",\n+             zFilename, pResOut, *pResOut));\n+    return SQLITE_OK;\n+  }\n+\n@@ -49345,1 +52094,2 @@\n-  sqlite3_mutex *pMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_TEMPDIR);\n+  MUTEX_LOGIC( sqlite3_mutex *pMutex; )\n+  MUTEX_LOGIC( pMutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_TEMPDIR); )\n@@ -49887,0 +52637,1 @@\n+static int memdbUnlock(sqlite3_file*, int);\n@@ -49945,1 +52696,1 @@\n-  memdbLock,                       \/* xUnlock - same as xLock in this case *\/\n+  memdbUnlock,                     \/* xUnlock *\/\n@@ -50146,1 +52897,1 @@\n-  if( eLock==pThis->eLock ) return SQLITE_OK;\n+  if( eLock<=pThis->eLock ) return SQLITE_OK;\n@@ -50148,8 +52899,41 @@\n-  if( eLock>SQLITE_LOCK_SHARED ){\n-    if( p->mFlags & SQLITE_DESERIALIZE_READONLY ){\n-      rc = SQLITE_READONLY;\n-    }else if( pThis->eLock<=SQLITE_LOCK_SHARED ){\n-      if( p->nWrLock ){\n-        rc = SQLITE_BUSY;\n-      }else{\n-        p->nWrLock = 1;\n+\n+  assert( p->nWrLock==0 || p->nWrLock==1 );\n+  assert( pThis->eLock<=SQLITE_LOCK_SHARED || p->nWrLock==1 );\n+  assert( pThis->eLock==SQLITE_LOCK_NONE || p->nRdLock>=1 );\n+\n+  if( eLock>SQLITE_LOCK_SHARED && (p->mFlags & SQLITE_DESERIALIZE_READONLY) ){\n+    rc = SQLITE_READONLY;\n+  }else{\n+    switch( eLock ){\n+      case SQLITE_LOCK_SHARED: {\n+        assert( pThis->eLock==SQLITE_LOCK_NONE );\n+        if( p->nWrLock>0 ){\n+          rc = SQLITE_BUSY;\n+        }else{\n+          p->nRdLock++;\n+        }\n+        break;\n+      };\n+\n+      case SQLITE_LOCK_RESERVED:\n+      case SQLITE_LOCK_PENDING: {\n+        assert( pThis->eLock>=SQLITE_LOCK_SHARED );\n+        if( ALWAYS(pThis->eLock==SQLITE_LOCK_SHARED) ){\n+          if( p->nWrLock>0 ){\n+            rc = SQLITE_BUSY;\n+          }else{\n+            p->nWrLock = 1;\n+          }\n+        }\n+        break;\n+      }\n+\n+      default: {\n+        assert(  eLock==SQLITE_LOCK_EXCLUSIVE );\n+        assert( pThis->eLock>=SQLITE_LOCK_SHARED );\n+        if( p->nRdLock>1 ){\n+          rc = SQLITE_BUSY;\n+        }else if( pThis->eLock==SQLITE_LOCK_SHARED ){\n+          p->nWrLock = 1;\n+        }\n+        break;\n@@ -50158,8 +52942,19 @@\n-  }else if( eLock==SQLITE_LOCK_SHARED ){\n-    if( pThis->eLock > SQLITE_LOCK_SHARED ){\n-      assert( p->nWrLock==1 );\n-      p->nWrLock = 0;\n-    }else if( p->nWrLock ){\n-      rc = SQLITE_BUSY;\n-    }else{\n-      p->nRdLock++;\n+  }\n+  if( rc==SQLITE_OK ) pThis->eLock = eLock;\n+  memdbLeave(p);\n+  return rc;\n+}\n+\n+\/*\n+** Unlock an memdb-file.\n+*\/\n+static int memdbUnlock(sqlite3_file *pFile, int eLock){\n+  MemFile *pThis = (MemFile*)pFile;\n+  MemStore *p = pThis->pStore;\n+  if( eLock>=pThis->eLock ) return SQLITE_OK;\n+  memdbEnter(p);\n+\n+  assert( eLock==SQLITE_LOCK_SHARED || eLock==SQLITE_LOCK_NONE );\n+  if( eLock==SQLITE_LOCK_SHARED ){\n+    if( ALWAYS(pThis->eLock>SQLITE_LOCK_SHARED) ){\n+      p->nWrLock--;\n@@ -50168,1 +52963,0 @@\n-    assert( eLock==SQLITE_LOCK_NONE );\n@@ -50170,2 +52964,1 @@\n-      assert( p->nWrLock==1 );\n-      p->nWrLock = 0;\n+      p->nWrLock--;\n@@ -50173,1 +52966,0 @@\n-    assert( p->nRdLock>0 );\n@@ -50176,1 +52968,2 @@\n-  if( rc==SQLITE_OK ) pThis->eLock = eLock;\n+\n+  pThis->eLock = eLock;\n@@ -50178,1 +52971,1 @@\n-  return rc;\n+  return SQLITE_OK;\n@@ -50288,1 +53081,1 @@\n-  if( szName>1 && zName[0]=='\/' ){\n+  if( szName>1 && (zName[0]=='\/' || zName[0]=='\\\\') ){\n@@ -50534,0 +53327,8 @@\n+    if( sz==0 ){\n+      sqlite3_reset(pStmt);\n+      sqlite3_exec(db, \"BEGIN IMMEDIATE; COMMIT;\", 0, 0, 0);\n+      rc = sqlite3_step(pStmt);\n+      if( rc==SQLITE_ROW ){\n+        sz = sqlite3_column_int64(pStmt, 0)*szPage;\n+      }\n+    }\n@@ -50635,0 +53436,7 @@\n+\/*\n+** Return true if the VFS is the memvfs.\n+*\/\n+SQLITE_PRIVATE int sqlite3IsMemdb(const sqlite3_vfs *pVfs){\n+  return pVfs==&memdb_vfs;\n+}\n+\n@@ -50847,1 +53655,1 @@\n-  \/* worring about sub-dividing and re-hashing. *\/\n+  \/* worrying about sub-dividing and re-hashing. *\/\n@@ -51114,1 +53922,1 @@\n-  int nRefSum;                        \/* Sum of ref counts over all pages *\/\n+  i64 nRefSum;                        \/* Sum of ref counts over all pages *\/\n@@ -51139,4 +53947,1 @@\n-  void pcacheDump(PCache *pCache){\n-    int N;\n-    int i, j;\n-    sqlite3_pcache_page *pLower;\n+  static void pcachePageTrace(int i, sqlite3_pcache_page *pLower){\n@@ -51145,0 +53950,15 @@\n+    int j;\n+    if( pLower==0 ){\n+      printf(\"%3d: NULL\\n\", i);\n+    }else{\n+      pPg = (PgHdr*)pLower->pExtra;\n+      printf(\"%3d: nRef %2lld flgs %02x data \", i, pPg->nRef, pPg->flags);\n+      a = (unsigned char *)pLower->pBuf;\n+      for(j=0; j<12; j++) printf(\"%02x\", a[j]);\n+      printf(\" ptr %p\\n\", pPg);\n+    }\n+  }\n+  static void pcacheDump(PCache *pCache){\n+    int N;\n+    int i;\n+    sqlite3_pcache_page *pLower;\n@@ -51152,7 +53972,2 @@\n-       if( pLower==0 ) continue;\n-       pPg = (PgHdr*)pLower->pExtra;\n-       printf(\"%3d: nRef %2d flgs %02x data \", i, pPg->nRef, pPg->flags);\n-       a = (unsigned char *)pLower->pBuf;\n-       for(j=0; j<12; j++) printf(\"%02x\", a[j]);\n-       printf(\"\\n\");\n-       if( pPg->pPage==0 ){\n+       pcachePageTrace(i, pLower);\n+       if( pLower && ((PgHdr*)pLower)->pPage==0 ){\n@@ -51163,1 +53978,1 @@\n-  #else\n+#else\n@@ -51165,0 +53980,1 @@\n+# define pcachePageTrace(PGNO, X)\n@@ -51168,0 +53984,24 @@\n+\/*\n+** Return 1 if pPg is on the dirty list for pCache.  Return 0 if not.\n+** This routine runs inside of assert() statements only.\n+*\/\n+#if defined(SQLITE_ENABLE_EXPENSIVE_ASSERT)\n+static int pageOnDirtyList(PCache *pCache, PgHdr *pPg){\n+  PgHdr *p;\n+  for(p=pCache->pDirty; p; p=p->pDirtyNext){\n+    if( p==pPg ) return 1;\n+  }\n+  return 0;\n+}\n+static int pageNotOnDirtyList(PCache *pCache, PgHdr *pPg){\n+  PgHdr *p;\n+  for(p=pCache->pDirty; p; p=p->pDirtyNext){\n+    if( p==pPg ) return 0;\n+  }\n+  return 1;\n+}\n+#else\n+# define pageOnDirtyList(A,B)    1\n+# define pageNotOnDirtyList(A,B) 1\n+#endif\n+\n@@ -51186,2 +54026,7 @@\n-    assert( pCache->pDirty!=pPg );          \/* CLEAN pages not on dirty list *\/\n-    assert( pCache->pDirtyTail!=pPg );\n+    assert( pageNotOnDirtyList(pCache, pPg) );\/* CLEAN pages not on dirtylist *\/\n+  }else{\n+    assert( (pPg->flags & PGHDR_DIRTY)!=0 );\/* If not CLEAN must be DIRTY *\/\n+    assert( pPg->pDirtyNext==0 || pPg->pDirtyNext->pDirtyPrev==pPg );\n+    assert( pPg->pDirtyPrev==0 || pPg->pDirtyPrev->pDirtyNext==pPg );\n+    assert( pPg->pDirtyPrev!=0 || pCache->pDirty==pPg );\n+    assert( pageOnDirtyList(pCache, pPg) );\n@@ -51317,1 +54162,1 @@\n-    \/* IMPLEMANTATION-OF: R-59858-46238 If the argument N is negative, then the\n+    \/* IMPLEMENTATION-OF: R-59858-46238 If the argument N is negative, then the\n@@ -51461,1 +54306,1 @@\n-  pcacheTrace((\"%p.FETCH %d%s (result: %p)\\n\",pCache,pgno,\n+  pcacheTrace((\"%p.FETCH %d%s (result: %p) \",pCache,pgno,\n@@ -51463,0 +54308,1 @@\n+  pcachePageTrace(pgno, pRes);\n@@ -51590,0 +54436,1 @@\n+      assert( sqlite3PcachePageSanity(p) );\n@@ -51633,0 +54480,1 @@\n+      assert( sqlite3PcachePageSanity(p) );\n@@ -51802,1 +54650,1 @@\n-** Sort the list of pages in accending order by pgno.  Pages are\n+** Sort the list of pages in ascending order by pgno.  Pages are\n@@ -51861,1 +54709,1 @@\n-SQLITE_PRIVATE int sqlite3PcacheRefCount(PCache *pCache){\n+SQLITE_PRIVATE i64 sqlite3PcacheRefCount(PCache *pCache){\n@@ -51868,1 +54716,1 @@\n-SQLITE_PRIVATE int sqlite3PcachePageRefcount(PgHdr *p){\n+SQLITE_PRIVATE i64 sqlite3PcachePageRefcount(PgHdr *p){\n@@ -52010,6 +54858,7 @@\n-** If SQLITE_PCACHE_SEPARATE_HEADER is defined, then the extension is obtained\n-** using a separate memory allocation from the database page content.  This\n-** seeks to overcome the \"clownshoe\" problem (also called \"internal\n-** fragmentation\" in academic literature) of allocating a few bytes more\n-** than a power of two with the memory allocator rounding up to the next\n-** power of two, and leaving the rounded-up space unused.\n+** Historical note:  It used to be that if the SQLITE_PCACHE_SEPARATE_HEADER\n+** was defined, then the page content would be held in a separate memory\n+** allocation from the PgHdr1.  This was intended to avoid clownshoe memory\n+** allocations.  However, the btree layer needs a small (16-byte) overrun\n+** area after the page content buffer.  The header serves as that overrun\n+** area.  Therefore SQLITE_PCACHE_SEPARATE_HEADER was discontinued to avoid\n+** any possibility of a memory error.\n@@ -52041,1 +54890,1 @@\n-** for as many pages as can be accomodated.\n+** for as many pages as can be accommodated.\n@@ -52060,3 +54909,2 @@\n-** structure. Unless SQLITE_PCACHE_SEPARATE_HEADER is defined, a buffer of\n-** PgHdr1.pCache->szPage bytes is allocated directly before this structure\n-** in memory.\n+** structure. A buffer of PgHdr1.pCache->szPage bytes is allocated\n+** directly before this structure and is used to cache the page content.\n@@ -52064,1 +54912,7 @@\n-** Note: Variables isBulkLocal and isAnchor were once type \"u8\". That works,\n+** When reading a corrupt database file, it is possible that SQLite might\n+** read a few bytes (no more than 16 bytes) past the end of the page buffer.\n+** It will only read past the end of the page buffer, never write.  This\n+** object is positioned immediately after the page buffer to serve as an\n+** overrun area, so that overreads are harmless.\n+**\n+** Variables isBulkLocal and isAnchor were once type \"u8\". That works,\n@@ -52070,3 +54924,8 @@\n-** can cause a valgrind error if the unitialized gap is accessed. Using u16\n-** ensures there is no such gap, and therefore no bytes of unitialized memory\n-** in the structure.\n+** can cause a valgrind error if the uninitialized gap is accessed. Using u16\n+** ensures there is no such gap, and therefore no bytes of uninitialized\n+** memory in the structure.\n+**\n+** The pLruNext and pLruPrev pointers form a double-linked circular list\n+** of all pages that are unpinned.  The PGroup.lru element (which should be\n+** the only element on the list with PgHdr1.isAnchor set to 1) forms the\n+** beginning and the end of the list.\n@@ -52075,9 +54934,9 @@\n-  sqlite3_pcache_page page;      \/* Base class. Must be first. pBuf & pExtra *\/\n-  unsigned int iKey;             \/* Key value (page number) *\/\n-  u16 isBulkLocal;               \/* This page from bulk local storage *\/\n-  u16 isAnchor;                  \/* This is the PGroup.lru element *\/\n-  PgHdr1 *pNext;                 \/* Next in hash table chain *\/\n-  PCache1 *pCache;               \/* Cache that currently owns this page *\/\n-  PgHdr1 *pLruNext;              \/* Next in LRU list of unpinned pages *\/\n-  PgHdr1 *pLruPrev;              \/* Previous in LRU list of unpinned pages *\/\n-                                 \/* NB: pLruPrev is only valid if pLruNext!=0 *\/\n+  sqlite3_pcache_page page; \/* Base class. Must be first. pBuf & pExtra *\/\n+  unsigned int iKey;        \/* Key value (page number) *\/\n+  u16 isBulkLocal;          \/* This page from bulk local storage *\/\n+  u16 isAnchor;             \/* This is the PGroup.lru element *\/\n+  PgHdr1 *pNext;            \/* Next in hash table chain *\/\n+  PCache1 *pCache;          \/* Cache that currently owns this page *\/\n+  PgHdr1 *pLruNext;         \/* Next in circular LRU list of unpinned pages *\/\n+  PgHdr1 *pLruPrev;         \/* Previous in LRU list of unpinned pages *\/\n+                            \/* NB: pLruPrev is only valid if pLruNext!=0 *\/\n@@ -52409,9 +55268,0 @@\n-#ifdef SQLITE_PCACHE_SEPARATE_HEADER\n-    pPg = pcache1Alloc(pCache->szPage);\n-    p = sqlite3Malloc(sizeof(PgHdr1) + pCache->szExtra);\n-    if( !pPg || !p ){\n-      pcache1Free(pPg);\n-      sqlite3_free(p);\n-      pPg = 0;\n-    }\n-#else\n@@ -52419,1 +55269,0 @@\n-#endif\n@@ -52425,1 +55274,0 @@\n-#ifndef SQLITE_PCACHE_SEPARATE_HEADER\n@@ -52427,1 +55275,0 @@\n-#endif\n@@ -52451,3 +55298,0 @@\n-#ifdef SQLITE_PCACHE_SEPARATE_HEADER\n-    sqlite3_free(p);\n-#endif\n@@ -53220,3 +56064,0 @@\n-#ifdef SQLITE_PCACHE_SEPARATE_HEADER\n-      nFree += sqlite3MemSize(p);\n-#endif\n@@ -53303,1 +56144,1 @@\n-** two TESTs where the TESTs have the same batch nubmer, then the\n+** two TESTs where the TESTs have the same batch number, then the\n@@ -53835,0 +56676,1 @@\n+# undef SQLITE_USE_SEH\n@@ -53941,0 +56783,4 @@\n+#ifdef SQLITE_USE_SEH\n+SQLITE_PRIVATE int sqlite3WalSystemErrno(Wal*);\n+#endif\n+\n@@ -54226,1 +57072,1 @@\n-**    is reloaded from disk (and, if necessary, hot-journal rollback peformed)\n+**    is reloaded from disk (and, if necessary, hot-journal rollback performed)\n@@ -54613,1 +57459,1 @@\n-  int aStat[4];               \/* Total cache hits, misses, writes, spills *\/\n+  u32 aStat[4];               \/* Total cache hits, misses, writes, spills *\/\n@@ -54743,3 +57589,2 @@\n-    int rc;\n-    rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iRead);\n-    return (rc==SQLITE_OK && iRead==0);\n+    (void)sqlite3WalFindFrame(pPager->pWal, pgno, &iRead);\n+    return iRead==0;\n@@ -55417,0 +58262,2 @@\n+\n+\n@@ -55418,1 +58265,21 @@\n-  sqlite3_randomness(sizeof(pPager->cksumInit), &pPager->cksumInit);\n+  if( pPager->journalMode!=PAGER_JOURNALMODE_MEMORY ){\n+    sqlite3_randomness(sizeof(pPager->cksumInit), &pPager->cksumInit);\n+  }\n+#ifdef SQLITE_DEBUG\n+  else{\n+    \/* The Pager.cksumInit variable is usually randomized above to protect\n+    ** against there being existing records in the journal file. This is\n+    ** dangerous, as following a crash they may be mistaken for records\n+    ** written by the current transaction and rolled back into the database\n+    ** file, causing corruption. The following assert statements verify\n+    ** that this is not required in \"journal_mode=memory\" mode, as in that\n+    ** case the journal file is always 0 bytes in size at this point.\n+    ** It is advantageous to avoid the sqlite3_randomness() call if possible\n+    ** as it takes the global PRNG mutex.  *\/\n+    i64 sz = 0;\n+    sqlite3OsFileSize(pPager->jfd, &sz);\n+    assert( sz==0 );\n+    assert( pPager->journalOff==journalHdrOffset(pPager) );\n+    assert( sqlite3JournalIsInMemory(pPager->jfd) );\n+  }\n+#endif\n@@ -55420,0 +58287,1 @@\n+\n@@ -55599,1 +58467,1 @@\n-** The super-journal page checksum is the sum of the bytes in thesuper-journal\n+** The super-journal page checksum is the sum of the bytes in the super-journal\n@@ -55652,1 +58520,1 @@\n-  \/* If the pager is in peristent-journal mode, then the physical\n+  \/* If the pager is in persistent-journal mode, then the physical\n@@ -55822,1 +58690,1 @@\n-** the pager to transition into the ERROR state may ahve occurred.\n+** the pager to transition into the ERROR state may have occurred.\n@@ -56063,0 +58931,3 @@\n+\/* Forward reference *\/\n+static int pager_playback(Pager *pPager, int isHot);\n+\n@@ -56091,0 +58962,15 @@\n+  }else if( pPager->eState==PAGER_ERROR\n+         && pPager->journalMode==PAGER_JOURNALMODE_MEMORY\n+         && isOpen(pPager->jfd)\n+  ){\n+    \/* Special case for a ROLLBACK due to I\/O error with an in-memory\n+    ** journal:  We have to rollback immediately, before the journal is\n+    ** closed, because once it is closed, all content is forgotten. *\/\n+    int errCode = pPager->errCode;\n+    u8 eLock = pPager->eLock;\n+    pPager->eState = PAGER_OPEN;\n+    pPager->errCode = SQLITE_OK;\n+    pPager->eLock = EXCLUSIVE_LOCK;\n+    pager_playback(pPager, 1);\n+    pPager->errCode = errCode;\n+    pPager->eLock = eLock;\n@@ -56097,1 +58983,1 @@\n-** of data. Compute and return a checksum based ont the contents of the\n+** of data. Compute and return a checksum based on the contents of the\n@@ -56530,0 +59416,2 @@\n+  PAGERTRACE((\"Truncate %d npage %u\\n\", PAGERID(pPager), nPage));\n+\n@@ -56860,1 +59748,1 @@\n-    memset(&zSuper[-4], 0, 4);\n+    memset(pPager->pTmpSpace, 0, 4);\n@@ -57061,1 +59949,1 @@\n-  \/* Verify that the page list is in accending order *\/\n+  \/* Verify that the page list is in ascending order *\/\n@@ -57192,1 +60080,1 @@\n-** exists if the database is not empy, or verify that the *-wal file does\n+** exists if the database is not empty, or verify that the *-wal file does\n@@ -57481,1 +60369,0 @@\n-#ifndef SQLITE_OMIT_PAGER_PRAGMAS\n@@ -57516,1 +60403,0 @@\n-#endif\n@@ -58604,1 +61490,0 @@\n-#ifndef SQLITE_OMIT_DESERIALIZE\n@@ -58606,3 +61491,0 @@\n-#else\n-# define memJM 0\n-#endif\n@@ -58618,1 +61500,0 @@\n-  int nUri = 0;            \/* Number of URI parameters *\/\n@@ -58666,1 +61547,0 @@\n-      nUri++;\n@@ -58729,0 +61609,1 @@\n+  assert( SQLITE_PTRSIZE==sizeof(Pager*) );\n@@ -58734,1 +61615,1 @@\n-    sizeof(pPager) +                     \/* Space to hold a pointer *\/\n+    SQLITE_PTRSIZE +                     \/* Space to hold a pointer *\/\n@@ -58755,1 +61636,1 @@\n-  memcpy(pPtr, &pPager, sizeof(pPager));  pPtr += sizeof(pPager);\n+  memcpy(pPtr, &pPager, SQLITE_PTRSIZE);  pPtr += SQLITE_PTRSIZE;\n@@ -58809,1 +61690,0 @@\n-#ifndef SQLITE_OMIT_DESERIALIZE\n@@ -58811,1 +61691,0 @@\n-#endif\n@@ -58922,12 +61801,1 @@\n-  pPager->noSync = pPager->tempFile;\n-  if( pPager->noSync ){\n-    assert( pPager->fullSync==0 );\n-    assert( pPager->extraSync==0 );\n-    assert( pPager->syncFlags==0 );\n-    assert( pPager->walSyncFlags==0 );\n-  }else{\n-    pPager->fullSync = 1;\n-    pPager->extraSync = 0;\n-    pPager->syncFlags = SQLITE_SYNC_NORMAL;\n-    pPager->walSyncFlags = SQLITE_SYNC_NORMAL | (SQLITE_SYNC_NORMAL<<2);\n-  }\n+  sqlite3PagerSetFlags(pPager, (SQLITE_DEFAULT_SYNCHRONOUS+1)|PAGER_CACHESPILL);\n@@ -58959,1 +61827,1 @@\n-** of the corresonding WAL or Journal name as passed into\n+** of the corresponding WAL or Journal name as passed into\n@@ -58964,0 +61832,1 @@\n+  const char *p;\n@@ -58967,1 +61836,3 @@\n-  pPager = *(Pager**)(zName - 4 - sizeof(Pager*));\n+  p = zName - 4 - sizeof(Pager*);\n+  assert( EIGHT_BYTE_ALIGNMENT(p) );\n+  pPager = *(Pager**)p;\n@@ -59462,0 +62333,4 @@\n+        if( pgno<=pPager->dbSize ){\n+          sqlite3PcacheRelease(pPg);\n+          pPg = 0;\n+        }\n@@ -59597,1 +62472,12 @@\n-  \/* printf(\"PAGE %u\\n\", pgno); fflush(stdout); *\/\n+#if 0   \/* Trace page fetch by setting to 1 *\/\n+  int rc;\n+  printf(\"PAGE %u\\n\", pgno);\n+  fflush(stdout);\n+  rc = pPager->xGet(pPager, pgno, ppPage, flags);\n+  if( rc ){\n+    printf(\"PAGE %u failed with 0x%02x\\n\", pgno, rc);\n+    fflush(stdout);\n+  }\n+  return rc;\n+#else\n+  \/* Normal, high-speed version of sqlite3PagerGet() *\/\n@@ -59599,0 +62485,1 @@\n+#endif\n@@ -59626,2 +62513,2 @@\n-** The sqlite3PagerUnref() and sqlite3PagerUnrefNotNull() may only be\n-** used if we know that the page being released is not the last page.\n+** The sqlite3PagerUnref() and sqlite3PagerUnrefNotNull() may only be used\n+** if we know that the page being released is not the last reference to page1.\n@@ -59629,1 +62516,3 @@\n-** to routines can be used to release any page other than BtShared.pPage1.\n+** two routines can be used to release any page other than BtShared.pPage1.\n+** The assert() at tag-20230419-2 proves that this constraint is always\n+** honored.\n@@ -59645,1 +62534,1 @@\n-  assert( sqlite3PcacheRefCount(pPager->pPCache)>0 );\n+  assert( sqlite3PcacheRefCount(pPager->pPCache)>0 ); \/* tag-20230419-2 *\/\n@@ -59711,0 +62600,1 @@\n+          flags |= SQLITE_OPEN_EXCLUSIVE;\n@@ -60193,1 +63083,1 @@\n-  if( !pPager->changeCountDone && ALWAYS(pPager->dbSize>0) ){\n+  if( !pPager->changeCountDone && pPager->dbSize>0 ){\n@@ -60471,0 +63361,7 @@\n+          if( rc==SQLITE_OK && pPager->dbSize>pPager->dbFileSize ){\n+            char *pTmp = pPager->pTmpSpace;\n+            int szPage = (int)pPager->pageSize;\n+            memset(pTmp, 0, szPage);\n+            rc = sqlite3OsWrite(pPager->fd, pTmp, szPage,\n+                      ((i64)pPager->dbSize*pPager->pageSize)-szPage);\n+          }\n@@ -60705,2 +63602,2 @@\n-  a[6] = pPager->aStat[PAGER_STAT_HIT];\n-  a[7] = pPager->aStat[PAGER_STAT_MISS];\n+  a[6] = (int)pPager->aStat[PAGER_STAT_HIT] & 0x7fffffff;\n+  a[7] = (int)pPager->aStat[PAGER_STAT_MISS] & 0x7fffffff;\n@@ -60709,1 +63606,1 @@\n-  a[10] = pPager->aStat[PAGER_STAT_WRITE];\n+  a[10] = (int)pPager->aStat[PAGER_STAT_WRITE] & 0x7fffffff;\n@@ -60725,1 +63622,1 @@\n-SQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *pPager, int eStat, int reset, int *pnVal){\n+SQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *pPager, int eStat, int reset, u64 *pnVal){\n@@ -60933,1 +63830,5 @@\n-  return (nullIfMemDb && pPager->memDb) ? &zFake[4] : pPager->zFilename;\n+  if( nullIfMemDb && (pPager->memDb || sqlite3IsMemdb(pPager->pVfs)) ){\n+    return &zFake[4];\n+  }else{\n+    return pPager->zFilename;\n+  }\n@@ -60957,1 +63858,1 @@\n-#if SQLITE_OMIT_WAL\n+#ifdef SQLITE_OMIT_WAL\n@@ -61233,1 +64134,1 @@\n-    \/* When transistioning from TRUNCATE or PERSIST to any other journal\n+    \/* When transitioning from TRUNCATE or PERSIST to any other journal\n@@ -61278,1 +64179,1 @@\n-    }else if( eMode==PAGER_JOURNALMODE_OFF ){\n+    }else if( eMode==PAGER_JOURNALMODE_OFF || eMode==PAGER_JOURNALMODE_MEMORY ){\n@@ -61302,1 +64203,1 @@\n-  if( isOpen(pPager->jfd) && pPager->journalOff>0 ) return 0;\n+  if( NEVER(isOpen(pPager->jfd) && pPager->journalOff>0) ) return 0;\n@@ -61400,0 +64301,1 @@\n+  u8 eOrigLock;                   \/* Original lock *\/\n@@ -61401,1 +64303,2 @@\n-  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK );\n+  assert( pPager->eLock>=SHARED_LOCK );\n+  eOrigLock = pPager->eLock;\n@@ -61406,1 +64309,1 @@\n-    pagerUnlockDb(pPager, SHARED_LOCK);\n+    pagerUnlockDb(pPager, eOrigLock);\n@@ -61659,0 +64562,6 @@\n+#if defined(SQLITE_USE_SEH) && !defined(SQLITE_OMIT_WAL)\n+SQLITE_PRIVATE int sqlite3PagerWalSystemErrno(Pager *pPager){\n+  return sqlite3WalSystemErrno(pPager->pWal);\n+}\n+#endif\n+\n@@ -61949,1 +64858,1 @@\n-** interoperate.  The standard implemention used on both unix and windows\n+** interoperate.  The standard implementation used on both unix and windows\n@@ -62025,1 +64934,1 @@\n-** to avoid having to offset aReadMark[] indexs by one.  Readers holding\n+** to avoid having to offset aReadMark[] indexes by one.  Readers holding\n@@ -62193,0 +65102,7 @@\n+#ifdef SQLITE_USE_SEH\n+  u32 lockMask;              \/* Mask of locks held *\/\n+  void *pFree;               \/* Pointer to sqlite3_free() if exception thrown *\/\n+  u32 *pWiValue;             \/* Value to write into apWiData[iWiPg] *\/\n+  int iWiPg;                 \/* Write pWiValue into apWiData[iWiPg] *\/\n+  int iSysErrno;             \/* System error code following exception *\/\n+#endif\n@@ -62194,0 +65110,1 @@\n+  int nSehTry;               \/* Number of nested SEH_TRY{} blocks *\/\n@@ -62275,0 +65192,107 @@\n+\/*\n+** Structured Exception Handling (SEH) is a Windows-specific technique\n+** for catching exceptions raised while accessing memory-mapped files.\n+**\n+** The -DSQLITE_USE_SEH compile-time option means to use SEH to catch and\n+** deal with system-level errors that arise during WAL -shm file processing.\n+** Without this compile-time option, any system-level faults that appear\n+** while accessing the memory-mapped -shm file will cause a process-wide\n+** signal to be deliver, which will more than likely cause the entire\n+** process to exit.\n+*\/\n+#ifdef SQLITE_USE_SEH\n+#include <Windows.h>\n+\n+\/* Beginning of a block of code in which an exception might occur *\/\n+# define SEH_TRY    __try { \\\n+   assert( walAssertLockmask(pWal) && pWal->nSehTry==0 ); \\\n+   VVA_ONLY(pWal->nSehTry++);\n+\n+\/* The end of a block of code in which an exception might occur *\/\n+# define SEH_EXCEPT(X) \\\n+   VVA_ONLY(pWal->nSehTry--); \\\n+   assert( pWal->nSehTry==0 ); \\\n+   } __except( sehExceptionFilter(pWal, GetExceptionCode(), GetExceptionInformation() ) ){ X }\n+\n+\/* Simulate a memory-mapping fault in the -shm file for testing purposes *\/\n+# define SEH_INJECT_FAULT sehInjectFault(pWal)\n+\n+\/*\n+** The second argument is the return value of GetExceptionCode() for the\n+** current exception. Return EXCEPTION_EXECUTE_HANDLER if the exception code\n+** indicates that the exception may have been caused by accessing the *-shm\n+** file mapping. Or EXCEPTION_CONTINUE_SEARCH otherwise.\n+*\/\n+static int sehExceptionFilter(Wal *pWal, int eCode, EXCEPTION_POINTERS *p){\n+  VVA_ONLY(pWal->nSehTry--);\n+  if( eCode==EXCEPTION_IN_PAGE_ERROR ){\n+    if( p && p->ExceptionRecord && p->ExceptionRecord->NumberParameters>=3 ){\n+      \/* From MSDN: For this type of exception, the first element of the\n+      ** ExceptionInformation[] array is a read-write flag - 0 if the exception\n+      ** was thrown while reading, 1 if while writing. The second element is\n+      ** the virtual address being accessed. The \"third array element specifies\n+      ** the underlying NTSTATUS code that resulted in the exception\". *\/\n+      pWal->iSysErrno = (int)p->ExceptionRecord->ExceptionInformation[2];\n+    }\n+    return EXCEPTION_EXECUTE_HANDLER;\n+  }\n+  return EXCEPTION_CONTINUE_SEARCH;\n+}\n+\n+\/*\n+** If one is configured, invoke the xTestCallback callback with 650 as\n+** the argument. If it returns true, throw the same exception that is\n+** thrown by the system if the *-shm file mapping is accessed after it\n+** has been invalidated.\n+*\/\n+static void sehInjectFault(Wal *pWal){\n+  int res;\n+  assert( pWal->nSehTry>0 );\n+\n+  res = sqlite3FaultSim(650);\n+  if( res!=0 ){\n+    ULONG_PTR aArg[3];\n+    aArg[0] = 0;\n+    aArg[1] = 0;\n+    aArg[2] = (ULONG_PTR)res;\n+    RaiseException(EXCEPTION_IN_PAGE_ERROR, 0, 3, (const ULONG_PTR*)aArg);\n+  }\n+}\n+\n+\/*\n+** There are two ways to use this macro. To set a pointer to be freed\n+** if an exception is thrown:\n+**\n+**   SEH_FREE_ON_ERROR(0, pPtr);\n+**\n+** and to cancel the same:\n+**\n+**   SEH_FREE_ON_ERROR(pPtr, 0);\n+**\n+** In the first case, there must not already be a pointer registered to\n+** be freed. In the second case, pPtr must be the registered pointer.\n+*\/\n+#define SEH_FREE_ON_ERROR(X,Y) \\\n+  assert( (X==0 || Y==0) && pWal->pFree==X ); pWal->pFree = Y\n+\n+\/*\n+** There are two ways to use this macro. To arrange for pWal->apWiData[iPg]\n+** to be set to pValue if an exception is thrown:\n+**\n+**   SEH_SET_ON_ERROR(iPg, pValue);\n+**\n+** and to cancel the same:\n+**\n+**   SEH_SET_ON_ERROR(0, 0);\n+*\/\n+#define SEH_SET_ON_ERROR(X,Y)  pWal->iWiPg = X; pWal->pWiValue = Y\n+\n+#else\n+# define SEH_TRY          VVA_ONLY(pWal->nSehTry++);\n+# define SEH_EXCEPT(X)    VVA_ONLY(pWal->nSehTry--); assert( pWal->nSehTry==0 );\n+# define SEH_INJECT_FAULT assert( pWal->nSehTry>0 );\n+# define SEH_FREE_ON_ERROR(X,Y)\n+# define SEH_SET_ON_ERROR(X,Y)\n+#endif \/* ifdef SQLITE_USE_SEH *\/\n+\n+\n@@ -62347,0 +65371,1 @@\n+  SEH_INJECT_FAULT;\n@@ -62358,0 +65383,1 @@\n+  SEH_INJECT_FAULT;\n@@ -62366,0 +65392,1 @@\n+  SEH_INJECT_FAULT;\n@@ -62411,0 +65438,1 @@\n+  assert( nByte%4==0 );\n@@ -62412,1 +65440,1 @@\n-  if( nativeCksum ){\n+  if( !nativeCksum ){\n@@ -62414,0 +65442,20 @@\n+      s1 += BYTESWAP32(aData[0]) + s2;\n+      s2 += BYTESWAP32(aData[1]) + s1;\n+      aData += 2;\n+    }while( aData<aEnd );\n+  }else if( nByte%64==0 ){\n+    do {\n+      s1 += *aData++ + s2;\n+      s2 += *aData++ + s1;\n+      s1 += *aData++ + s2;\n+      s2 += *aData++ + s1;\n+      s1 += *aData++ + s2;\n+      s2 += *aData++ + s1;\n+      s1 += *aData++ + s2;\n+      s2 += *aData++ + s1;\n+      s1 += *aData++ + s2;\n+      s2 += *aData++ + s1;\n+      s1 += *aData++ + s2;\n+      s2 += *aData++ + s1;\n+      s1 += *aData++ + s2;\n+      s2 += *aData++ + s1;\n@@ -62419,3 +65467,2 @@\n-      s1 += BYTESWAP32(aData[0]) + s2;\n-      s2 += BYTESWAP32(aData[1]) + s1;\n-      aData += 2;\n+      s1 += *aData++ + s2;\n+      s2 += *aData++ + s1;\n@@ -62424,0 +65471,1 @@\n+  assert( aData==aEnd );\n@@ -62534,1 +65582,1 @@\n-  \/* A frame is only valid if the page number is creater than zero.\n+  \/* A frame is only valid if the page number is greater than zero.\n@@ -62542,1 +65590,1 @@\n-  ** all prior frams, the first 16 bytes of this frame-header,\n+  ** all prior frames, the first 16 bytes of this frame-header,\n@@ -62602,0 +65650,3 @@\n+#ifdef SQLITE_USE_SEH\n+  if( rc==SQLITE_OK ) pWal->lockMask |= (1 << lockIdx);\n+#endif\n@@ -62608,0 +65659,3 @@\n+#ifdef SQLITE_USE_SEH\n+  pWal->lockMask &= ~(1 << lockIdx);\n+#endif\n@@ -62618,0 +65672,5 @@\n+#ifdef SQLITE_USE_SEH\n+  if( rc==SQLITE_OK ){\n+    pWal->lockMask |= (((1<<n)-1) << (SQLITE_SHM_NLOCK+lockIdx));\n+  }\n+#endif\n@@ -62624,0 +65683,3 @@\n+#ifdef SQLITE_USE_SEH\n+  pWal->lockMask &= ~(((1<<n)-1) << (SQLITE_SHM_NLOCK+lockIdx));\n+#endif\n@@ -62715,0 +65777,1 @@\n+  SEH_INJECT_FAULT;\n@@ -62974,0 +66037,1 @@\n+    SEH_FREE_ON_ERROR(0, aFrame);\n@@ -62992,0 +66056,1 @@\n+      SEH_SET_ON_ERROR(iPg, aShare);\n@@ -63019,0 +66084,1 @@\n+      SEH_SET_ON_ERROR(0,0);\n@@ -63049,0 +66115,1 @@\n+      SEH_INJECT_FAULT;\n@@ -63052,0 +66119,1 @@\n+    SEH_FREE_ON_ERROR(aFrame, 0);\n@@ -63079,0 +66147,1 @@\n+        SEH_INJECT_FAULT;\n@@ -63236,1 +66305,1 @@\n-** Change the size to which the WAL file is trucated on each reset.\n+** Change the size to which the WAL file is truncated on each reset.\n@@ -63462,1 +66531,3 @@\n-  p = (WalIterator *)sqlite3_malloc64(nByte);\n+  p = (WalIterator *)sqlite3_malloc64(nByte\n+      + sizeof(ht_slot) * (iLast>HASHTABLE_NPAGE?HASHTABLE_NPAGE:iLast)\n+  );\n@@ -63468,11 +66539,2 @@\n-\n-  \/* Allocate temporary space used by the merge-sort routine. This block\n-  ** of memory will be freed before this function returns.\n-  *\/\n-  aTmp = (ht_slot *)sqlite3_malloc64(\n-      sizeof(ht_slot) * (iLast>HASHTABLE_NPAGE?HASHTABLE_NPAGE:iLast)\n-  );\n-  if( !aTmp ){\n-    rc = SQLITE_NOMEM_BKPT;\n-  }\n-\n+  aTmp = (ht_slot*)&(((u8*)p)[nByte]);\n+  SEH_FREE_ON_ERROR(0, p);\n@@ -63506,2 +66568,0 @@\n-  sqlite3_free(aTmp);\n-\n@@ -63509,0 +66569,1 @@\n+    SEH_FREE_ON_ERROR(p, 0);\n@@ -63517,0 +66578,13 @@\n+\n+\n+\/*\n+** Attempt to enable blocking locks that block for nMs ms. Return 1 if\n+** blocking locks are successfully enabled, or 0 otherwise.\n+*\/\n+static int walEnableBlockingMs(Wal *pWal, int nMs){\n+  int rc = sqlite3OsFileControl(\n+      pWal->pDbFd, SQLITE_FCNTL_LOCK_TIMEOUT, (void*)&nMs\n+  );\n+  return (rc==SQLITE_OK);\n+}\n+\n@@ -63528,5 +66602,1 @@\n-      int rc;\n-      rc = sqlite3OsFileControl(\n-          pWal->pDbFd, SQLITE_FCNTL_LOCK_TIMEOUT, (void*)&tmout\n-      );\n-      res = (rc==SQLITE_OK);\n+      res = walEnableBlockingMs(pWal, tmout);\n@@ -63581,10 +66651,0 @@\n-\/*\n-** Take an exclusive WRITE lock. Blocking if so configured.\n-*\/\n-static int walLockWriter(Wal *pWal){\n-  int rc;\n-  walEnableBlocking(pWal);\n-  rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);\n-  walDisableBlocking(pWal);\n-  return rc;\n-}\n@@ -63594,1 +66654,1 @@\n-# define walLockWriter(pWal) walLockExclusive((pWal), WAL_WRITE_LOCK, 1)\n+# define walEnableBlockingMs(pWal, ms) 0\n@@ -63734,1 +66794,1 @@\n-      u32 y = AtomicLoad(pInfo->aReadMark+i);\n+      u32 y = AtomicLoad(pInfo->aReadMark+i); SEH_INJECT_FAULT;\n@@ -63740,1 +66800,1 @@\n-          AtomicStore(pInfo->aReadMark+i, iMark);\n+          AtomicStore(pInfo->aReadMark+i, iMark); SEH_INJECT_FAULT;\n@@ -63761,2 +66821,1 @@\n-\n-      pInfo->nBackfillAttempted = mxSafeFrame;\n+      pInfo->nBackfillAttempted = mxSafeFrame; SEH_INJECT_FAULT;\n@@ -63793,0 +66852,1 @@\n+        SEH_INJECT_FAULT;\n@@ -63822,1 +66882,1 @@\n-          AtomicStore(&pInfo->nBackfill, mxSafeFrame);\n+          AtomicStore(&pInfo->nBackfill, mxSafeFrame); SEH_INJECT_FAULT;\n@@ -63844,0 +66904,1 @@\n+    SEH_INJECT_FAULT;\n@@ -63875,0 +66936,1 @@\n+  SEH_FREE_ON_ERROR(pIter, 0);\n@@ -63897,0 +66959,87 @@\n+#ifdef SQLITE_USE_SEH\n+\/*\n+** This is the \"standard\" exception handler used in a few places to handle\n+** an exception thrown by reading from the *-shm mapping after it has become\n+** invalid in SQLITE_USE_SEH builds. It is used as follows:\n+**\n+**   SEH_TRY { ... }\n+**   SEH_EXCEPT( rc = walHandleException(pWal); )\n+**\n+** This function does three things:\n+**\n+**   1) Determines the locks that should be held, based on the contents of\n+**      the Wal.readLock, Wal.writeLock and Wal.ckptLock variables. All other\n+**      held locks are assumed to be transient locks that would have been\n+**      released had the exception not been thrown and are dropped.\n+**\n+**   2) Frees the pointer at Wal.pFree, if any, using sqlite3_free().\n+**\n+**   3) Set pWal->apWiData[pWal->iWiPg] to pWal->pWiValue if not NULL\n+**\n+**   4) Returns SQLITE_IOERR.\n+*\/\n+static int walHandleException(Wal *pWal){\n+  if( pWal->exclusiveMode==0 ){\n+    static const int S = 1;\n+    static const int E = (1<<SQLITE_SHM_NLOCK);\n+    int ii;\n+    u32 mUnlock = pWal->lockMask & ~(\n+        (pWal->readLock<0 ? 0 : (S << WAL_READ_LOCK(pWal->readLock)))\n+        | (pWal->writeLock ? (E << WAL_WRITE_LOCK) : 0)\n+        | (pWal->ckptLock ? (E << WAL_CKPT_LOCK) : 0)\n+        );\n+    for(ii=0; ii<SQLITE_SHM_NLOCK; ii++){\n+      if( (S<<ii) & mUnlock ) walUnlockShared(pWal, ii);\n+      if( (E<<ii) & mUnlock ) walUnlockExclusive(pWal, ii, 1);\n+    }\n+  }\n+  sqlite3_free(pWal->pFree);\n+  pWal->pFree = 0;\n+  if( pWal->pWiValue ){\n+    pWal->apWiData[pWal->iWiPg] = pWal->pWiValue;\n+    pWal->pWiValue = 0;\n+  }\n+  return SQLITE_IOERR_IN_PAGE;\n+}\n+\n+\/*\n+** Assert that the Wal.lockMask mask, which indicates the locks held\n+** by the connenction, is consistent with the Wal.readLock, Wal.writeLock\n+** and Wal.ckptLock variables. To be used as:\n+**\n+**   assert( walAssertLockmask(pWal) );\n+*\/\n+static int walAssertLockmask(Wal *pWal){\n+  if( pWal->exclusiveMode==0 ){\n+    static const int S = 1;\n+    static const int E = (1<<SQLITE_SHM_NLOCK);\n+    u32 mExpect = (\n+        (pWal->readLock<0 ? 0 : (S << WAL_READ_LOCK(pWal->readLock)))\n+      | (pWal->writeLock ? (E << WAL_WRITE_LOCK) : 0)\n+      | (pWal->ckptLock ? (E << WAL_CKPT_LOCK) : 0)\n+#ifdef SQLITE_ENABLE_SNAPSHOT\n+      | (pWal->pSnapshot ? (pWal->lockMask & (1 << WAL_CKPT_LOCK)) : 0)\n+#endif\n+    );\n+    assert( mExpect==pWal->lockMask );\n+  }\n+  return 1;\n+}\n+\n+\/*\n+** Return and zero the \"system error\" field set when an\n+** EXCEPTION_IN_PAGE_ERROR exception is caught.\n+*\/\n+SQLITE_PRIVATE int sqlite3WalSystemErrno(Wal *pWal){\n+  int iRet = 0;\n+  if( pWal ){\n+    iRet = pWal->iSysErrno;\n+    pWal->iSysErrno = 0;\n+  }\n+  return iRet;\n+}\n+\n+#else\n+# define walAssertLockmask(x) 1\n+#endif \/* ifdef SQLITE_USE_SEH *\/\n+\n@@ -63911,0 +67060,2 @@\n+    assert( walAssertLockmask(pWal) );\n+\n@@ -63935,1 +67086,1 @@\n-          ** fsyned (rc==SQLITE_OK) and if we are not in persistent-wal\n+          ** fsynced (rc==SQLITE_OK) and if we are not in persistent-wal\n@@ -64002,1 +67153,1 @@\n-  ** shared among multiple processes and not all mutex implementions work\n+  ** shared among multiple processes and not all mutex implementations work\n@@ -64104,1 +67255,3 @@\n-      if( bWriteLock || SQLITE_OK==(rc = walLockWriter(pWal)) ){\n+      if( bWriteLock\n+       || SQLITE_OK==(rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1))\n+      ){\n@@ -64112,1 +67265,2 @@\n-            *\/\n+            ** Disable blocking locks first.  *\/\n+            walDisableBlocking(pWal);\n@@ -64322,0 +67476,31 @@\n+\/*\n+** The final argument passed to walTryBeginRead() is of type (int*). The\n+** caller should invoke walTryBeginRead as follows:\n+**\n+**   int cnt = 0;\n+**   do {\n+**     rc = walTryBeginRead(..., &cnt);\n+**   }while( rc==WAL_RETRY );\n+**\n+** The final value of \"cnt\" is of no use to the caller. It is used by\n+** the implementation of walTryBeginRead() as follows:\n+**\n+**   + Each time walTryBeginRead() is called, it is incremented. Once\n+**     it reaches WAL_RETRY_PROTOCOL_LIMIT - indicating that walTryBeginRead()\n+**     has many times been invoked and failed with WAL_RETRY - walTryBeginRead()\n+**     returns SQLITE_PROTOCOL.\n+**\n+**   + If SQLITE_ENABLE_SETLK_TIMEOUT is defined and walTryBeginRead() failed\n+**     because a blocking lock timed out (SQLITE_BUSY_TIMEOUT from the OS\n+**     layer), the WAL_RETRY_BLOCKED_MASK bit is set in \"cnt\". In this case\n+**     the next invocation of walTryBeginRead() may omit an expected call to\n+**     sqlite3OsSleep(). There has already been a delay when the previous call\n+**     waited on a lock.\n+*\/\n+#define WAL_RETRY_PROTOCOL_LIMIT 100\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+# define WAL_RETRY_BLOCKED_MASK    0x10000000\n+#else\n+# define WAL_RETRY_BLOCKED_MASK    0\n+#endif\n+\n@@ -64372,1 +67557,1 @@\n-static int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int cnt){\n+static int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int *pCnt){\n@@ -64379,0 +67564,3 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+  int nBlockTmout = 0;\n+#endif\n@@ -64402,1 +67590,2 @@\n-  if( cnt>5 ){\n+  (*pCnt)++;\n+  if( *pCnt>5 ){\n@@ -64404,1 +67593,2 @@\n-    if( cnt>100 ){\n+    int cnt = (*pCnt & ~WAL_RETRY_BLOCKED_MASK);\n+    if( cnt>WAL_RETRY_PROTOCOL_LIMIT ){\n@@ -64408,1 +67598,18 @@\n-    if( cnt>=10 ) nDelay = (cnt-9)*(cnt-9)*39;\n+    if( *pCnt>=10 ) nDelay = (cnt-9)*(cnt-9)*39;\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+    \/* In SQLITE_ENABLE_SETLK_TIMEOUT builds, configure the file-descriptor\n+    ** to block for locks for approximately nDelay us. This affects three\n+    ** locks: (a) the shared lock taken on the DMS slot in os_unix.c (if\n+    ** using os_unix.c), (b) the WRITER lock taken in walIndexReadHdr() if the\n+    ** first attempted read fails, and (c) the shared lock taken on the\n+    ** read-mark.\n+    **\n+    ** If the previous call failed due to an SQLITE_BUSY_TIMEOUT error,\n+    ** then sleep for the minimum of 1us. The previous call already provided\n+    ** an extra delay while it was blocking on the lock.\n+    *\/\n+    nBlockTmout = (nDelay+998) \/ 1000;\n+    if( !useWal && walEnableBlockingMs(pWal, nBlockTmout) ){\n+      if( *pCnt & WAL_RETRY_BLOCKED_MASK ) nDelay = 1;\n+    }\n+#endif\n@@ -64410,0 +67617,1 @@\n+    *pCnt &= ~WAL_RETRY_BLOCKED_MASK;\n@@ -64417,0 +67625,7 @@\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+    walDisableBlocking(pWal);\n+    if( rc==SQLITE_BUSY_TIMEOUT ){\n+      rc = SQLITE_BUSY;\n+      *pCnt |= WAL_RETRY_BLOCKED_MASK;\n+    }\n+#endif\n@@ -64453,0 +67668,1 @@\n+  SEH_INJECT_FAULT;\n@@ -64502,1 +67718,1 @@\n-    u32 thisMark = AtomicLoad(pInfo->aReadMark+i);\n+    u32 thisMark = AtomicLoad(pInfo->aReadMark+i); SEH_INJECT_FAULT;\n@@ -64530,0 +67746,1 @@\n+  (void)walEnableBlockingMs(pWal, nBlockTmout);\n@@ -64531,0 +67748,1 @@\n+  walDisableBlocking(pWal);\n@@ -64532,1 +67750,9 @@\n-    return rc==SQLITE_BUSY ? WAL_RETRY : rc;\n+#ifdef SQLITE_ENABLE_SETLK_TIMEOUT\n+    if( rc==SQLITE_BUSY_TIMEOUT ){\n+      *pCnt |= WAL_RETRY_BLOCKED_MASK;\n+    }\n+#else\n+    assert( rc!=SQLITE_BUSY_TIMEOUT );\n+#endif\n+    assert( (rc&0xFF)!=SQLITE_BUSY||rc==SQLITE_BUSY||rc==SQLITE_BUSY_TIMEOUT );\n+    return (rc&0xFF)==SQLITE_BUSY ? WAL_RETRY : rc;\n@@ -64568,1 +67794,1 @@\n-  pWal->minFrame = AtomicLoad(&pInfo->nBackfill)+1;\n+  pWal->minFrame = AtomicLoad(&pInfo->nBackfill)+1; SEH_INJECT_FAULT;\n@@ -64583,0 +67809,48 @@\n+\/*\n+** This function does the work of sqlite3WalSnapshotRecover().\n+*\/\n+static int walSnapshotRecover(\n+  Wal *pWal,                      \/* WAL handle *\/\n+  void *pBuf1,                    \/* Temp buffer pWal->szPage bytes in size *\/\n+  void *pBuf2                     \/* Temp buffer pWal->szPage bytes in size *\/\n+){\n+  int szPage = (int)pWal->szPage;\n+  int rc;\n+  i64 szDb;                       \/* Size of db file in bytes *\/\n+\n+  rc = sqlite3OsFileSize(pWal->pDbFd, &szDb);\n+  if( rc==SQLITE_OK ){\n+    volatile WalCkptInfo *pInfo = walCkptInfo(pWal);\n+    u32 i = pInfo->nBackfillAttempted;\n+    for(i=pInfo->nBackfillAttempted; i>AtomicLoad(&pInfo->nBackfill); i--){\n+      WalHashLoc sLoc;          \/* Hash table location *\/\n+      u32 pgno;                 \/* Page number in db file *\/\n+      i64 iDbOff;               \/* Offset of db file entry *\/\n+      i64 iWalOff;              \/* Offset of wal file entry *\/\n+\n+      rc = walHashGet(pWal, walFramePage(i), &sLoc);\n+      if( rc!=SQLITE_OK ) break;\n+      assert( i - sLoc.iZero - 1 >=0 );\n+      pgno = sLoc.aPgno[i-sLoc.iZero-1];\n+      iDbOff = (i64)(pgno-1) * szPage;\n+\n+      if( iDbOff+szPage<=szDb ){\n+        iWalOff = walFrameOffset(i, szPage) + WAL_FRAME_HDRSIZE;\n+        rc = sqlite3OsRead(pWal->pWalFd, pBuf1, szPage, iWalOff);\n+\n+        if( rc==SQLITE_OK ){\n+          rc = sqlite3OsRead(pWal->pDbFd, pBuf2, szPage, iDbOff);\n+        }\n+\n+        if( rc!=SQLITE_OK || 0==memcmp(pBuf1, pBuf2, szPage) ){\n+          break;\n+        }\n+      }\n+\n+      pInfo->nBackfillAttempted = i-1;\n+    }\n+  }\n+\n+  return rc;\n+}\n+\n@@ -64608,39 +67882,8 @@\n-    volatile WalCkptInfo *pInfo = walCkptInfo(pWal);\n-    int szPage = (int)pWal->szPage;\n-    i64 szDb;                   \/* Size of db file in bytes *\/\n-\n-    rc = sqlite3OsFileSize(pWal->pDbFd, &szDb);\n-    if( rc==SQLITE_OK ){\n-      void *pBuf1 = sqlite3_malloc(szPage);\n-      void *pBuf2 = sqlite3_malloc(szPage);\n-      if( pBuf1==0 || pBuf2==0 ){\n-        rc = SQLITE_NOMEM;\n-      }else{\n-        u32 i = pInfo->nBackfillAttempted;\n-        for(i=pInfo->nBackfillAttempted; i>AtomicLoad(&pInfo->nBackfill); i--){\n-          WalHashLoc sLoc;          \/* Hash table location *\/\n-          u32 pgno;                 \/* Page number in db file *\/\n-          i64 iDbOff;               \/* Offset of db file entry *\/\n-          i64 iWalOff;              \/* Offset of wal file entry *\/\n-\n-          rc = walHashGet(pWal, walFramePage(i), &sLoc);\n-          if( rc!=SQLITE_OK ) break;\n-          assert( i - sLoc.iZero - 1 >=0 );\n-          pgno = sLoc.aPgno[i-sLoc.iZero-1];\n-          iDbOff = (i64)(pgno-1) * szPage;\n-\n-          if( iDbOff+szPage<=szDb ){\n-            iWalOff = walFrameOffset(i, szPage) + WAL_FRAME_HDRSIZE;\n-            rc = sqlite3OsRead(pWal->pWalFd, pBuf1, szPage, iWalOff);\n-\n-            if( rc==SQLITE_OK ){\n-              rc = sqlite3OsRead(pWal->pDbFd, pBuf2, szPage, iDbOff);\n-            }\n-\n-            if( rc!=SQLITE_OK || 0==memcmp(pBuf1, pBuf2, szPage) ){\n-              break;\n-            }\n-          }\n-\n-          pInfo->nBackfillAttempted = i-1;\n-        }\n+    void *pBuf1 = sqlite3_malloc(pWal->szPage);\n+    void *pBuf2 = sqlite3_malloc(pWal->szPage);\n+    if( pBuf1==0 || pBuf2==0 ){\n+      rc = SQLITE_NOMEM;\n+    }else{\n+      pWal->ckptLock = 1;\n+      SEH_TRY {\n+        rc = walSnapshotRecover(pWal, pBuf1, pBuf2);\n@@ -64648,3 +67891,2 @@\n-\n-      sqlite3_free(pBuf1);\n-      sqlite3_free(pBuf2);\n+      SEH_EXCEPT( rc = SQLITE_IOERR_IN_PAGE; )\n+      pWal->ckptLock = 0;\n@@ -64652,0 +67894,3 @@\n+\n+    sqlite3_free(pBuf1);\n+    sqlite3_free(pBuf2);\n@@ -64660,12 +67905,2 @@\n-** Begin a read transaction on the database.\n-**\n-** This routine used to be called sqlite3OpenSnapshot() and with good reason:\n-** it takes a snapshot of the state of the WAL and wal-index for the current\n-** instant in time.  The current thread will continue to use this snapshot.\n-** Other threads might append new content to the WAL and wal-index but\n-** that extra content is ignored by the current thread.\n-**\n-** If the database contents have changes since the previous read\n-** transaction, then *pChanged is set to 1 before returning.  The\n-** Pager layer will use this to know that its cache is stale and\n-** needs to be flushed.\n+** This function does the work of sqlite3WalBeginReadTransaction() (see\n+** below). That function simply calls this one inside an SEH_TRY{...} block.\n@@ -64673,1 +67908,1 @@\n-SQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){\n+static int walBeginReadTransaction(Wal *pWal, int *pChanged){\n@@ -64677,0 +67912,1 @@\n+  int ckptLock = 0;\n@@ -64682,0 +67918,1 @@\n+  assert( pWal->nSehTry>0 );\n@@ -64704,1 +67941,1 @@\n-    pWal->ckptLock = 1;\n+    ckptLock = 1;\n@@ -64709,1 +67946,1 @@\n-    rc = walTryBeginRead(pWal, pChanged, 0, ++cnt);\n+    rc = walTryBeginRead(pWal, pChanged, 0, &cnt);\n@@ -64768,1 +68005,1 @@\n-  if( pWal->ckptLock ){\n+  if( ckptLock ){\n@@ -64771,1 +68008,0 @@\n-    pWal->ckptLock = 0;\n@@ -64777,0 +68013,23 @@\n+\/*\n+** Begin a read transaction on the database.\n+**\n+** This routine used to be called sqlite3OpenSnapshot() and with good reason:\n+** it takes a snapshot of the state of the WAL and wal-index for the current\n+** instant in time.  The current thread will continue to use this snapshot.\n+** Other threads might append new content to the WAL and wal-index but\n+** that extra content is ignored by the current thread.\n+**\n+** If the database contents have changes since the previous read\n+** transaction, then *pChanged is set to 1 before returning.  The\n+** Pager layer will use this to know that its cache is stale and\n+** needs to be flushed.\n+*\/\n+SQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){\n+  int rc;\n+  SEH_TRY {\n+    rc = walBeginReadTransaction(pWal, pChanged);\n+  }\n+  SEH_EXCEPT( rc = walHandleException(pWal); )\n+  return rc;\n+}\n+\n@@ -64797,1 +68056,1 @@\n-SQLITE_PRIVATE int sqlite3WalFindFrame(\n+static int walFindFrame(\n@@ -64860,0 +68119,1 @@\n+    SEH_INJECT_FAULT;\n@@ -64867,0 +68127,1 @@\n+        *piRead = 0;\n@@ -64896,0 +68157,24 @@\n+\/*\n+** Search the wal file for page pgno. If found, set *piRead to the frame that\n+** contains the page. Otherwise, if pgno is not in the wal file, set *piRead\n+** to zero.\n+**\n+** Return SQLITE_OK if successful, or an error code if an error occurs. If an\n+** error does occur, the final value of *piRead is undefined.\n+**\n+** The difference between this function and walFindFrame() is that this\n+** function wraps walFindFrame() in an SEH_TRY{...} block.\n+*\/\n+SQLITE_PRIVATE int sqlite3WalFindFrame(\n+  Wal *pWal,                      \/* WAL handle *\/\n+  Pgno pgno,                      \/* Database page number to read data for *\/\n+  u32 *piRead                     \/* OUT: Frame number (or zero) *\/\n+){\n+  int rc;\n+  SEH_TRY {\n+    rc = walFindFrame(pWal, pgno, piRead);\n+  }\n+  SEH_EXCEPT( rc = SQLITE_IOERR_IN_PAGE; )\n+  return rc;\n+}\n+\n@@ -64977,1 +68262,8 @@\n-  if( memcmp(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr))!=0 ){\n+  SEH_TRY {\n+    if( memcmp(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr))!=0 ){\n+      rc = SQLITE_BUSY_SNAPSHOT;\n+    }\n+  }\n+  SEH_EXCEPT( rc = SQLITE_IOERR_IN_PAGE; )\n+\n+  if( rc!=SQLITE_OK ){\n@@ -64980,1 +68272,0 @@\n-    rc = SQLITE_BUSY_SNAPSHOT;\n@@ -64982,1 +68273,0 @@\n-\n@@ -65018,19 +68308,3 @@\n-    \/* Restore the clients cache of the wal-index header to the state it\n-    ** was in before the client began writing to the database.\n-    *\/\n-    memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));\n-\n-    for(iFrame=pWal->hdr.mxFrame+1;\n-        ALWAYS(rc==SQLITE_OK) && iFrame<=iMax;\n-        iFrame++\n-    ){\n-      \/* This call cannot fail. Unless the page for which the page number\n-      ** is passed as the second argument is (a) in the cache and\n-      ** (b) has an outstanding reference, then xUndo is either a no-op\n-      ** (if (a) is false) or simply expels the page from the cache (if (b)\n-      ** is false).\n-      **\n-      ** If the upper layer is doing a rollback, it is guaranteed that there\n-      ** are no outstanding references to any page other than page 1. And\n-      ** page 1 is never written to the log until the transaction is\n-      ** committed. As a result, the call to xUndo may not fail.\n+    SEH_TRY {\n+      \/* Restore the clients cache of the wal-index header to the state it\n+      ** was in before the client began writing to the database.\n@@ -65038,2 +68312,21 @@\n-      assert( walFramePgno(pWal, iFrame)!=1 );\n-      rc = xUndo(pUndoCtx, walFramePgno(pWal, iFrame));\n+      memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));\n+\n+      for(iFrame=pWal->hdr.mxFrame+1;\n+          ALWAYS(rc==SQLITE_OK) && iFrame<=iMax;\n+          iFrame++\n+      ){\n+        \/* This call cannot fail. Unless the page for which the page number\n+        ** is passed as the second argument is (a) in the cache and\n+        ** (b) has an outstanding reference, then xUndo is either a no-op\n+        ** (if (a) is false) or simply expels the page from the cache (if (b)\n+        ** is false).\n+        **\n+        ** If the upper layer is doing a rollback, it is guaranteed that there\n+        ** are no outstanding references to any page other than page 1. And\n+        ** page 1 is never written to the log until the transaction is\n+        ** committed. As a result, the call to xUndo may not fail.\n+        *\/\n+        assert( walFramePgno(pWal, iFrame)!=1 );\n+        rc = xUndo(pUndoCtx, walFramePgno(pWal, iFrame));\n+      }\n+      if( iMax!=pWal->hdr.mxFrame ) walCleanupHash(pWal);\n@@ -65041,1 +68334,1 @@\n-    if( iMax!=pWal->hdr.mxFrame ) walCleanupHash(pWal);\n+    SEH_EXCEPT( rc = SQLITE_IOERR_IN_PAGE; )\n@@ -65085,1 +68378,4 @@\n-    walCleanupHash(pWal);\n+    SEH_TRY {\n+      walCleanupHash(pWal);\n+    }\n+    SEH_EXCEPT( rc = SQLITE_IOERR_IN_PAGE; )\n@@ -65135,1 +68431,1 @@\n-      rc = walTryBeginRead(pWal, &notUsed, 1, ++cnt);\n+      rc = walTryBeginRead(pWal, &notUsed, 1, &cnt);\n@@ -65266,1 +68562,1 @@\n-SQLITE_PRIVATE int sqlite3WalFrames(\n+static int walFrames(\n@@ -65354,1 +68650,3 @@\n-  assert( (int)pWal->szPage==szPage );\n+  if( (int)pWal->szPage!=szPage ){\n+    return SQLITE_CORRUPT_BKPT;  \/* TH3 test case: cov1\/corrupt155.test *\/\n+  }\n@@ -65375,1 +68673,1 @@\n-      VVA_ONLY(rc =) sqlite3WalFindFrame(pWal, p->pgno, &iWrite);\n+      VVA_ONLY(rc =) walFindFrame(pWal, p->pgno, &iWrite);\n@@ -65494,0 +68792,23 @@\n+\/*\n+** Write a set of frames to the log. The caller must hold the write-lock\n+** on the log file (obtained using sqlite3WalBeginWriteTransaction()).\n+**\n+** The difference between this function and walFrames() is that this\n+** function wraps walFrames() in an SEH_TRY{...} block.\n+*\/\n+SQLITE_PRIVATE int sqlite3WalFrames(\n+  Wal *pWal,                      \/* Wal handle to write to *\/\n+  int szPage,                     \/* Database page-size in bytes *\/\n+  PgHdr *pList,                   \/* List of dirty pages to write *\/\n+  Pgno nTruncate,                 \/* Database size after this commit *\/\n+  int isCommit,                   \/* True if this is a commit *\/\n+  int sync_flags                  \/* Flags to pass to OsSync() (or 0) *\/\n+){\n+  int rc;\n+  SEH_TRY {\n+    rc = walFrames(pWal, szPage, pList, nTruncate, isCommit, sync_flags);\n+  }\n+  SEH_EXCEPT( rc = walHandleException(pWal); )\n+  return rc;\n+}\n+\n@@ -65531,2 +68852,1 @@\n-  \/* Enable blocking locks, if possible. If blocking locks are successfully\n-  ** enabled, set xBusy2=0 so that the busy-handler is never invoked. *\/\n+  \/* Enable blocking locks, if possible. *\/\n@@ -65534,1 +68854,1 @@\n-  (void)walEnableBlocking(pWal);\n+  if( xBusy2 ) (void)walEnableBlocking(pWal);\n@@ -65573,6 +68893,13 @@\n-  if( rc==SQLITE_OK ){\n-    walDisableBlocking(pWal);\n-    rc = walIndexReadHdr(pWal, &isChanged);\n-    (void)walEnableBlocking(pWal);\n-    if( isChanged && pWal->pDbFd->pMethods->iVersion>=3 ){\n-      sqlite3OsUnfetch(pWal->pDbFd, 0, 0);\n+  SEH_TRY {\n+    if( rc==SQLITE_OK ){\n+      \/* For a passive checkpoint, do not re-enable blocking locks after\n+      ** reading the wal-index header. A passive checkpoint should not block\n+      ** or invoke the busy handler. The only lock such a checkpoint may\n+      ** attempt to obtain is a lock on a read-slot, and it should give up\n+      ** immediately and do a partial checkpoint if it cannot obtain it. *\/\n+      walDisableBlocking(pWal);\n+      rc = walIndexReadHdr(pWal, &isChanged);\n+      if( eMode2!=SQLITE_CHECKPOINT_PASSIVE ) (void)walEnableBlocking(pWal);\n+      if( isChanged && pWal->pDbFd->pMethods->iVersion>=3 ){\n+        sqlite3OsUnfetch(pWal->pDbFd, 0, 0);\n+      }\n@@ -65580,1 +68907,0 @@\n-  }\n@@ -65582,8 +68908,7 @@\n-  \/* Copy data from the log to the database file. *\/\n-  if( rc==SQLITE_OK ){\n-\n-    if( pWal->hdr.mxFrame && walPagesize(pWal)!=nBuf ){\n-      rc = SQLITE_CORRUPT_BKPT;\n-    }else{\n-      rc = walCheckpoint(pWal, db, eMode2, xBusy2, pBusyArg, sync_flags, zBuf);\n-    }\n+    \/* Copy data from the log to the database file. *\/\n+    if( rc==SQLITE_OK ){\n+      if( pWal->hdr.mxFrame && walPagesize(pWal)!=nBuf ){\n+        rc = SQLITE_CORRUPT_BKPT;\n+      }else{\n+        rc = walCheckpoint(pWal, db, eMode2, xBusy2, pBusyArg, sync_flags,zBuf);\n+      }\n@@ -65591,4 +68916,6 @@\n-    \/* If no error occurred, set the output variables. *\/\n-    if( rc==SQLITE_OK || rc==SQLITE_BUSY ){\n-      if( pnLog ) *pnLog = (int)pWal->hdr.mxFrame;\n-      if( pnCkpt ) *pnCkpt = (int)(walCkptInfo(pWal)->nBackfill);\n+      \/* If no error occurred, set the output variables. *\/\n+      if( rc==SQLITE_OK || rc==SQLITE_BUSY ){\n+        if( pnLog ) *pnLog = (int)pWal->hdr.mxFrame;\n+        SEH_INJECT_FAULT;\n+        if( pnCkpt ) *pnCkpt = (int)(walCkptInfo(pWal)->nBackfill);\n+      }\n@@ -65597,0 +68924,1 @@\n+  SEH_EXCEPT( rc = walHandleException(pWal); )\n@@ -65673,0 +69001,1 @@\n+#ifndef SQLITE_USE_SEH\n@@ -65674,0 +69003,1 @@\n+#endif\n@@ -65774,8 +69104,10 @@\n-  rc = walLockShared(pWal, WAL_CKPT_LOCK);\n-  if( rc==SQLITE_OK ){\n-    WalIndexHdr *pNew = (WalIndexHdr*)pSnapshot;\n-    if( memcmp(pNew->aSalt, pWal->hdr.aSalt, sizeof(pWal->hdr.aSalt))\n-     || pNew->mxFrame<walCkptInfo(pWal)->nBackfillAttempted\n-    ){\n-      rc = SQLITE_ERROR_SNAPSHOT;\n-      walUnlockShared(pWal, WAL_CKPT_LOCK);\n+  SEH_TRY {\n+    rc = walLockShared(pWal, WAL_CKPT_LOCK);\n+    if( rc==SQLITE_OK ){\n+      WalIndexHdr *pNew = (WalIndexHdr*)pSnapshot;\n+      if( memcmp(pNew->aSalt, pWal->hdr.aSalt, sizeof(pWal->hdr.aSalt))\n+       || pNew->mxFrame<walCkptInfo(pWal)->nBackfillAttempted\n+      ){\n+        rc = SQLITE_ERROR_SNAPSHOT;\n+        walUnlockShared(pWal, WAL_CKPT_LOCK);\n+      }\n@@ -65784,0 +69116,1 @@\n+  SEH_EXCEPT( rc = walHandleException(pWal); )\n@@ -65906,1 +69239,1 @@\n-**     28       4     Reserved for future use\n+**     28       4     The size of the database in pages\n@@ -66014,1 +69347,1 @@\n-** As a special case, all 8 bytes of the 9th byte are used as data.  This\n+** As a special case, all 8 bits of the 9th byte are used as data.  This\n@@ -66022,1 +69355,1 @@\n-**    0x8a 0x91 0xd1 0xac 0x78  becomes  0x12345678\n+**    0x81 0x91 0xd1 0xac 0x78  becomes  0x12345678\n@@ -66105,1 +69438,1 @@\n-** As each database page is loaded into memory, the pager allocats an\n+** As each database page is loaded into memory, the pager allocates an\n@@ -66398,1 +69731,1 @@\n-#define BTCF_AtLast       0x08   \/* Cursor is pointing ot the last entry *\/\n+#define BTCF_AtLast       0x08   \/* Cursor is pointing to the last entry *\/\n@@ -66516,1 +69849,1 @@\n-#define ISAUTOVACUUM (pBt->autoVacuum)\n+#define ISAUTOVACUUM(pBt) (pBt->autoVacuum)\n@@ -66518,1 +69851,1 @@\n-#define ISAUTOVACUUM 0\n+#define ISAUTOVACUUM(pBt) 0\n@@ -66523,2 +69856,2 @@\n-** This structure is passed around through all the sanity checking routines\n-** in order to keep track of some global state information.\n+** This structure is passed around through all the PRAGMA integrity_check\n+** checking routines in order to keep track of some global state information.\n@@ -66537,1 +69870,1 @@\n-  Pgno nPage;       \/* Number of pages in the database *\/\n+  Pgno nCkPage;     \/* Pages in the database.  0 for partial check *\/\n@@ -66540,1 +69873,2 @@\n-  int bOomFault;    \/* A memory allocation error has occurred *\/\n+  int rc;           \/* SQLITE_OK, SQLITE_NOMEM, or SQLITE_INTERRUPT *\/\n+  u32 nStep;        \/* Number of steps into the integrity_check process *\/\n@@ -66542,2 +69876,3 @@\n-  Pgno v1;          \/* Value for first %u substitution in zPfx *\/\n-  int v2;           \/* Value for second %d substitution in zPfx *\/\n+  Pgno v0;          \/* Value for first %u substitution in zPfx (root page) *\/\n+  Pgno v1;          \/* Value for second %u substitution in zPfx (current pg) *\/\n+  int v2;           \/* Value for third %d substitution in zPfx *\/\n@@ -66559,1 +69894,1 @@\n-** two-byte aligned address.  get2bytea() is only used for accessing the\n+** two-byte aligned address.  get2byteAligned() is only used for accessing the\n@@ -66736,1 +70071,1 @@\n-** Enter the mutexes in accending order by BtShared pointer address\n+** Enter the mutexes in ascending order by BtShared pointer address\n@@ -66810,0 +70145,1 @@\n+  if( db->pVfs==0 && db->nDb==0 ) return 1;\n@@ -67005,2 +70341,2 @@\n-  zMsg = sqlite3_mprintf(\"database corruption page %d of %s\",\n-      (int)p->pgno, sqlite3PagerFilename(p->pBt->pPager, 0)\n+  zMsg = sqlite3_mprintf(\"database corruption page %u of %s\",\n+             p->pgno, sqlite3PagerFilename(p->pBt->pPager, 0)\n@@ -67815,0 +71151,16 @@\n+#ifdef SQLITE_DEBUG\n+  if( ALWAYS(eHintType==BTREE_HINT_RANGE) ){\n+    va_list ap;\n+    Expr *pExpr;\n+    Walker w;\n+    memset(&w, 0, sizeof(w));\n+    w.xExprCallback = sqlite3CursorRangeHintExprCheck;\n+    va_start(ap, eHintType);\n+    pExpr = va_arg(ap, Expr*);\n+    w.u.aMem = va_arg(ap, Mem*);\n+    va_end(ap);\n+    assert( pExpr!=0 );\n+    assert( w.u.aMem!=0 );\n+    sqlite3WalkExpr(&w, pExpr);\n+  }\n+#endif \/* SQLITE_DEBUG *\/\n@@ -67816,1 +71168,2 @@\n-#endif\n+#endif \/* SQLITE_ENABLE_CURSOR_HINTS *\/\n+\n@@ -67901,1 +71254,1 @@\n-    TRACE((\"PTRMAP_UPDATE: %d->(%d,%d)\\n\", key, eType, parent));\n+    TRACE((\"PTRMAP_UPDATE: %u->(%u,%u)\\n\", key, eType, parent));\n@@ -68100,1 +71453,1 @@\n-    iKey = ((iKey&0x7f)<<7) | ((x = *++pIter) & 0x7f);\n+    iKey = (iKey<<7) ^ (x = *++pIter);\n@@ -68102,1 +71455,1 @@\n-      iKey = (iKey<<7) | ((x =*++pIter) & 0x7f);\n+      iKey = (iKey<<7) ^ (x = *++pIter);\n@@ -68104,1 +71457,1 @@\n-        iKey = (iKey<<7) | ((x = *++pIter) & 0x7f);\n+        iKey = (iKey<<7) ^ 0x10204000 ^ (x = *++pIter);\n@@ -68106,1 +71459,1 @@\n-          iKey = (iKey<<7) | ((x = *++pIter) & 0x7f);\n+          iKey = (iKey<<7) ^ 0x4000 ^ (x = *++pIter);\n@@ -68108,1 +71461,1 @@\n-            iKey = (iKey<<7) | ((x = *++pIter) & 0x7f);\n+            iKey = (iKey<<7) ^ 0x4000 ^ (x = *++pIter);\n@@ -68110,1 +71463,1 @@\n-              iKey = (iKey<<7) | ((x = *++pIter) & 0x7f);\n+              iKey = (iKey<<7) ^ 0x4000 ^ (x = *++pIter);\n@@ -68112,1 +71465,1 @@\n-                iKey = (iKey<<7) | ((x = *++pIter) & 0x7f);\n+                iKey = (iKey<<7) ^ 0x4000 ^ (x = *++pIter);\n@@ -68114,1 +71467,1 @@\n-                  iKey = (iKey<<8) | (*++pIter);\n+                  iKey = (iKey<<8) ^ 0x8000 ^ (*++pIter);\n@@ -68120,0 +71473,2 @@\n+      }else{\n+        iKey ^= 0x204000;\n@@ -68121,0 +71476,2 @@\n+    }else{\n+      iKey ^= 0x4000;\n@@ -68197,1 +71554,2 @@\n-** cellSizePtr()             =>   all index nodes & table leaf nodes\n+** cellSizePtr()             =>   index internal nodes\n+** cellSizeIdxLeaf()         =>   index leaf nodes\n@@ -68200,1 +71558,1 @@\n-  u8 *pIter = pCell + pPage->childPtrSize; \/* For looping over bytes of pCell *\/\n+  u8 *pIter = pCell + 4;                   \/* For looping over bytes of pCell *\/\n@@ -68213,0 +71571,43 @@\n+  assert( pPage->childPtrSize==4 );\n+  nSize = *pIter;\n+  if( nSize>=0x80 ){\n+    pEnd = &pIter[8];\n+    nSize &= 0x7f;\n+    do{\n+      nSize = (nSize<<7) | (*++pIter & 0x7f);\n+    }while( *(pIter)>=0x80 && pIter<pEnd );\n+  }\n+  pIter++;\n+  testcase( nSize==pPage->maxLocal );\n+  testcase( nSize==(u32)pPage->maxLocal+1 );\n+  if( nSize<=pPage->maxLocal ){\n+    nSize += (u32)(pIter - pCell);\n+    assert( nSize>4 );\n+  }else{\n+    int minLocal = pPage->minLocal;\n+    nSize = minLocal + (nSize - minLocal) % (pPage->pBt->usableSize - 4);\n+    testcase( nSize==pPage->maxLocal );\n+    testcase( nSize==(u32)pPage->maxLocal+1 );\n+    if( nSize>pPage->maxLocal ){\n+      nSize = minLocal;\n+    }\n+    nSize += 4 + (u16)(pIter - pCell);\n+  }\n+  assert( nSize==debuginfo.nSize || CORRUPT_DB );\n+  return (u16)nSize;\n+}\n+static u16 cellSizePtrIdxLeaf(MemPage *pPage, u8 *pCell){\n+  u8 *pIter = pCell;                       \/* For looping over bytes of pCell *\/\n+  u8 *pEnd;                                \/* End mark for a varint *\/\n+  u32 nSize;                               \/* Size value to return *\/\n+\n+#ifdef SQLITE_DEBUG\n+  \/* The value returned by this function should always be the same as\n+  ** the (CellInfo.nSize) value found by doing a full parse of the\n+  ** cell. If SQLITE_DEBUG is defined, an assert() at the bottom of\n+  ** this function verifies that this invariant is not violated. *\/\n+  CellInfo debuginfo;\n+  pPage->xParseCell(pPage, pCell, &debuginfo);\n+#endif\n+\n+  assert( pPage->childPtrSize==0 );\n@@ -68337,1 +71738,1 @@\n-    if( SQLITE_WITHIN(pSrc->aDataEnd, pCell, pCell+info.nLocal) ){\n+    if( SQLITE_OVERFLOW(pSrc->aDataEnd, pCell, pCell+info.nLocal) ){\n@@ -68382,2 +71783,1 @@\n-  temp = 0;\n-  src = data = pPage->aData;\n+  data = pPage->aData;\n@@ -68437,27 +71837,27 @@\n-  for(i=0; i<nCell; i++){\n-    u8 *pAddr;     \/* The i-th cell pointer *\/\n-    pAddr = &data[cellOffset + i*2];\n-    pc = get2byte(pAddr);\n-    testcase( pc==iCellFirst );\n-    testcase( pc==iCellLast );\n-    \/* These conditions have already been verified in btreeInitPage()\n-    ** if PRAGMA cell_size_check=ON.\n-    *\/\n-    if( pc<iCellStart || pc>iCellLast ){\n-      return SQLITE_CORRUPT_PAGE(pPage);\n-    }\n-    assert( pc>=iCellStart && pc<=iCellLast );\n-    size = pPage->xCellSize(pPage, &src[pc]);\n-    cbrk -= size;\n-    if( cbrk<iCellStart || pc+size>usableSize ){\n-      return SQLITE_CORRUPT_PAGE(pPage);\n-    }\n-    assert( cbrk+size<=usableSize && cbrk>=iCellStart );\n-    testcase( cbrk+size==usableSize );\n-    testcase( pc+size==usableSize );\n-    put2byte(pAddr, cbrk);\n-    if( temp==0 ){\n-      if( cbrk==pc ) continue;\n-      temp = sqlite3PagerTempSpace(pPage->pBt->pPager);\n-      memcpy(&temp[iCellStart], &data[iCellStart], usableSize - iCellStart);\n-      src = temp;\n+  if( nCell>0 ){\n+    temp = sqlite3PagerTempSpace(pPage->pBt->pPager);\n+    memcpy(temp, data, usableSize);\n+    src = temp;\n+    for(i=0; i<nCell; i++){\n+      u8 *pAddr;     \/* The i-th cell pointer *\/\n+      pAddr = &data[cellOffset + i*2];\n+      pc = get2byte(pAddr);\n+      testcase( pc==iCellFirst );\n+      testcase( pc==iCellLast );\n+      \/* These conditions have already been verified in btreeInitPage()\n+      ** if PRAGMA cell_size_check=ON.\n+      *\/\n+      if( pc>iCellLast ){\n+        return SQLITE_CORRUPT_PAGE(pPage);\n+      }\n+      assert( pc>=0 && pc<=iCellLast );\n+      size = pPage->xCellSize(pPage, &src[pc]);\n+      cbrk -= size;\n+      if( cbrk<iCellStart || pc+size>usableSize ){\n+        return SQLITE_CORRUPT_PAGE(pPage);\n+      }\n+      assert( cbrk+size<=usableSize && cbrk>=iCellStart );\n+      testcase( cbrk+size==usableSize );\n+      testcase( pc+size==usableSize );\n+      put2byte(pAddr, cbrk);\n+      memcpy(&data[cbrk], &src[pc], size);\n@@ -68465,1 +71865,0 @@\n-    memcpy(&data[cbrk], &src[pc], size);\n@@ -68469,1 +71868,1 @@\n- defragment_out:\n+defragment_out:\n@@ -68526,1 +71925,0 @@\n-        testcase( pc+x>maxPC );\n@@ -68542,1 +71940,1 @@\n-    if( pc<=iAddr+size ){\n+    if( pc<=iAddr ){\n@@ -68544,1 +71942,1 @@\n-        \/* The next slot in the chain is not past the end of the current slot *\/\n+        \/* The next slot in the chain comes before the current slot *\/\n@@ -68570,1 +71968,1 @@\n-static int allocateSpace(MemPage *pPage, int nByte, int *pIdx){\n+static SQLITE_INLINE int allocateSpace(MemPage *pPage, int nByte, int *pIdx){\n@@ -68596,1 +71994,0 @@\n-  assert( top<=(int)pPage->pBt->usableSize ); \/* by btreeComputeFreeSpace() *\/\n@@ -68603,0 +72000,2 @@\n+  }else if( top>(int)pPage->pBt->usableSize ){\n+    return SQLITE_CORRUPT_PAGE(pPage);\n@@ -68664,1 +72063,1 @@\n-** does it detect cells or freeblocks that encrouch into the reserved bytes\n+** does it detect cells or freeblocks that encroach into the reserved bytes\n@@ -68685,1 +72084,1 @@\n-  assert( iStart<=pPage->pBt->usableSize-4 );\n+  assert( CORRUPT_DB || iStart<=pPage->pBt->usableSize-4 );\n@@ -68696,1 +72095,1 @@\n-      if( iFreeBlk<iPtr+4 ){\n+      if( iFreeBlk<=iPtr ){\n@@ -68742,0 +72141,5 @@\n+  if( pPage->pBt->btsFlags & BTS_FAST_SECURE ){\n+    \/* Overwrite deleted information with zeros when the secure_delete\n+    ** option is enabled *\/\n+    memset(&data[iStart], 0, iSize);\n+  }\n@@ -68753,0 +72157,2 @@\n+    put2byte(&data[iStart], iFreeBlk);\n+    put2byte(&data[iStart+2], iSize);\n@@ -68754,7 +72160,0 @@\n-  if( pPage->pBt->btsFlags & BTS_FAST_SECURE ){\n-    \/* Overwrite deleted information with zeros when the secure_delete\n-    ** option is enabled *\/\n-    memset(&data[iStart], 0, iSize);\n-  }\n-  put2byte(&data[iStart], iFreeBlk);\n-  put2byte(&data[iStart+2], iSize);\n@@ -68772,4 +72171,4 @@\n-**         PTF_ZERODATA\n-**         PTF_ZERODATA | PTF_LEAF\n-**         PTF_LEAFDATA | PTF_INTKEY\n-**         PTF_LEAFDATA | PTF_INTKEY | PTF_LEAF\n+**         PTF_ZERODATA                             (0x02,  2)\n+**         PTF_LEAFDATA | PTF_INTKEY                (0x05,  5)\n+**         PTF_ZERODATA | PTF_LEAF                  (0x0a, 10)\n+**         PTF_LEAFDATA | PTF_INTKEY | PTF_LEAF     (0x0d, 13)\n@@ -68782,3 +72181,0 @@\n-  pPage->leaf = (u8)(flagByte>>3);  assert( PTF_LEAF == 1<<3 );\n-  flagByte &= ~PTF_LEAF;\n-  pPage->childPtrSize = 4-4*pPage->leaf;\n@@ -68786,9 +72182,5 @@\n-  if( flagByte==(PTF_LEAFDATA | PTF_INTKEY) ){\n-    \/* EVIDENCE-OF: R-07291-35328 A value of 5 (0x05) means the page is an\n-    ** interior table b-tree page. *\/\n-    assert( (PTF_LEAFDATA|PTF_INTKEY)==5 );\n-    \/* EVIDENCE-OF: R-26900-09176 A value of 13 (0x0d) means the page is a\n-    ** leaf table b-tree page. *\/\n-    assert( (PTF_LEAFDATA|PTF_INTKEY|PTF_LEAF)==13 );\n-    pPage->intKey = 1;\n-    if( pPage->leaf ){\n+  pPage->max1bytePayload = pBt->max1bytePayload;\n+  if( flagByte>=(PTF_ZERODATA | PTF_LEAF) ){\n+    pPage->childPtrSize = 0;\n+    pPage->leaf = 1;\n+    if( flagByte==(PTF_LEAFDATA | PTF_INTKEY | PTF_LEAF) ){\n@@ -68798,0 +72190,10 @@\n+      pPage->intKey = 1;\n+      pPage->maxLocal = pBt->maxLeaf;\n+      pPage->minLocal = pBt->minLeaf;\n+    }else if( flagByte==(PTF_ZERODATA | PTF_LEAF) ){\n+      pPage->intKey = 0;\n+      pPage->intKeyLeaf = 0;\n+      pPage->xCellSize = cellSizePtrIdxLeaf;\n+      pPage->xParseCell = btreeParseCellPtrIndex;\n+      pPage->maxLocal = pBt->maxLocal;\n+      pPage->minLocal = pBt->minLocal;\n@@ -68799,0 +72201,17 @@\n+      pPage->intKey = 0;\n+      pPage->intKeyLeaf = 0;\n+      pPage->xCellSize = cellSizePtrIdxLeaf;\n+      pPage->xParseCell = btreeParseCellPtrIndex;\n+      return SQLITE_CORRUPT_PAGE(pPage);\n+    }\n+  }else{\n+    pPage->childPtrSize = 4;\n+    pPage->leaf = 0;\n+    if( flagByte==(PTF_ZERODATA) ){\n+      pPage->intKey = 0;\n+      pPage->intKeyLeaf = 0;\n+      pPage->xCellSize = cellSizePtr;\n+      pPage->xParseCell = btreeParseCellPtrIndex;\n+      pPage->maxLocal = pBt->maxLocal;\n+      pPage->minLocal = pBt->minLocal;\n+    }else if( flagByte==(PTF_LEAFDATA | PTF_INTKEY) ){\n@@ -68802,0 +72221,9 @@\n+      pPage->intKey = 1;\n+      pPage->maxLocal = pBt->maxLeaf;\n+      pPage->minLocal = pBt->minLeaf;\n+    }else{\n+      pPage->intKey = 0;\n+      pPage->intKeyLeaf = 0;\n+      pPage->xCellSize = cellSizePtr;\n+      pPage->xParseCell = btreeParseCellPtrIndex;\n+      return SQLITE_CORRUPT_PAGE(pPage);\n@@ -68803,23 +72231,0 @@\n-    pPage->maxLocal = pBt->maxLeaf;\n-    pPage->minLocal = pBt->minLeaf;\n-  }else if( flagByte==PTF_ZERODATA ){\n-    \/* EVIDENCE-OF: R-43316-37308 A value of 2 (0x02) means the page is an\n-    ** interior index b-tree page. *\/\n-    assert( (PTF_ZERODATA)==2 );\n-    \/* EVIDENCE-OF: R-59615-42828 A value of 10 (0x0a) means the page is a\n-    ** leaf index b-tree page. *\/\n-    assert( (PTF_ZERODATA|PTF_LEAF)==10 );\n-    pPage->intKey = 0;\n-    pPage->intKeyLeaf = 0;\n-    pPage->xCellSize = cellSizePtr;\n-    pPage->xParseCell = btreeParseCellPtrIndex;\n-    pPage->maxLocal = pBt->maxLocal;\n-    pPage->minLocal = pBt->minLocal;\n-  }else{\n-    \/* EVIDENCE-OF: R-47608-56469 Any other value for the b-tree page type is\n-    ** an error. *\/\n-    pPage->intKey = 0;\n-    pPage->intKeyLeaf = 0;\n-    pPage->xCellSize = cellSizePtr;\n-    pPage->xParseCell = btreeParseCellPtrIndex;\n-    return SQLITE_CORRUPT_PAGE(pPage);\n@@ -68827,1 +72232,0 @@\n-  pPage->max1bytePayload = pBt->max1bytePayload;\n@@ -69118,10 +72522,0 @@\n-**\n-** If pCur!=0 then the page is being fetched as part of a moveToChild()\n-** call.  Do additional sanity checking on the page in this case.\n-** And if the fetch fails, this routine must decrement pCur->iPage.\n-**\n-** The page is fetched as read-write unless pCur is not NULL and is\n-** a read-only cursor.\n-**\n-** If an error occurs, then *ppPage is undefined. It\n-** may remain unchanged, or it may be set to an invalid value.\n@@ -69133,1 +72527,0 @@\n-  BtCursor *pCur,                 \/* Cursor to receive the page, or NULL *\/\n@@ -69138,0 +72531,1 @@\n+  MemPage *pPage;\n@@ -69139,3 +72533,0 @@\n-  assert( pCur==0 || ppPage==&pCur->pPage );\n-  assert( pCur==0 || bReadOnly==pCur->curPagerFlags );\n-  assert( pCur==0 || pCur->iPage>0 );\n@@ -69144,2 +72535,2 @@\n-    rc = SQLITE_CORRUPT_BKPT;\n-    goto getAndInitPage_error1;\n+    *ppPage = 0;\n+    return SQLITE_CORRUPT_BKPT;\n@@ -69149,1 +72540,2 @@\n-    goto getAndInitPage_error1;\n+    *ppPage = 0;\n+    return rc;\n@@ -69151,2 +72543,2 @@\n-  *ppPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);\n-  if( (*ppPage)->isInit==0 ){\n+  pPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);\n+  if( pPage->isInit==0 ){\n@@ -69154,1 +72546,1 @@\n-    rc = btreeInitPage(*ppPage);\n+    rc = btreeInitPage(pPage);\n@@ -69156,1 +72548,3 @@\n-      goto getAndInitPage_error2;\n+      releasePage(pPage);\n+      *ppPage = 0;\n+      return rc;\n@@ -69159,9 +72553,3 @@\n-  assert( (*ppPage)->pgno==pgno || CORRUPT_DB );\n-  assert( (*ppPage)->aData==sqlite3PagerGetData(pDbPage) );\n-\n-  \/* If obtaining a child page for a cursor, we must verify that the page is\n-  ** compatible with the root page. *\/\n-  if( pCur && ((*ppPage)->nCell<1 || (*ppPage)->intKey!=pCur->curIntKey) ){\n-    rc = SQLITE_CORRUPT_PGNO(pgno);\n-    goto getAndInitPage_error2;\n-  }\n+  assert( pPage->pgno==pgno || CORRUPT_DB );\n+  assert( pPage->aData==sqlite3PagerGetData(pDbPage) );\n+  *ppPage = pPage;\n@@ -69169,13 +72557,0 @@\n-\n-getAndInitPage_error2:\n-  releasePage(*ppPage);\n-getAndInitPage_error1:\n-  if( pCur ){\n-    pCur->iPage--;\n-    pCur->pPage = pCur->apPage[pCur->iPage];\n-  }\n-  testcase( pgno==0 );\n-  assert( pgno!=0 || rc==SQLITE_CORRUPT\n-                  || rc==SQLITE_IOERR_NOMEM\n-                  || rc==SQLITE_NOMEM );\n-  return rc;\n@@ -69264,1 +72639,1 @@\n-      ** the call for every page that comes in for re-initing. *\/\n+      ** the call for every page that comes in for re-initializing. *\/\n@@ -69443,0 +72818,3 @@\n+    \/* Suppress false-positive compiler warning from PVS-Studio *\/\n+    memset(&zDbHeader[16], 0, 8);\n+\n@@ -69659,1 +73037,1 @@\n-  ** does cause a valgrind error when the 1 or 2 bytes of unitialized\n+  ** does cause a valgrind error when the 1 or 2 bytes of uninitialized\n@@ -69894,1 +73272,1 @@\n-** are intentually left unused.  This is the \"reserved\" space that is\n+** are intentionally left unused.  This is the \"reserved\" space that is\n@@ -70141,1 +73519,0 @@\n-    pBt->btsFlags |= BTS_PAGESIZE_FIXED;\n@@ -70161,0 +73538,1 @@\n+      pBt->btsFlags |= BTS_PAGESIZE_FIXED;\n@@ -70180,0 +73558,1 @@\n+    pBt->btsFlags |= BTS_PAGESIZE_FIXED;\n@@ -70358,1 +73737,5 @@\n-SQLITE_PRIVATE int sqlite3BtreeBeginTrans(Btree *p, int wrflag, int *pSchemaVersion){\n+static SQLITE_NOINLINE int btreeBeginTrans(\n+  Btree *p,                 \/* The btree in which to start the transaction *\/\n+  int wrflag,               \/* True to start a write transaction *\/\n+  int *pSchemaVersion       \/* Put schema version number here, if not NULL *\/\n+){\n@@ -70530,0 +73913,22 @@\n+SQLITE_PRIVATE int sqlite3BtreeBeginTrans(Btree *p, int wrflag, int *pSchemaVersion){\n+  BtShared *pBt;\n+  if( p->sharable\n+   || p->inTrans==TRANS_NONE\n+   || (p->inTrans==TRANS_READ && wrflag!=0)\n+  ){\n+    return btreeBeginTrans(p,wrflag,pSchemaVersion);\n+  }\n+  pBt = p->pBt;\n+  if( pSchemaVersion ){\n+    *pSchemaVersion = get4byte(&pBt->pPage1->aData[40]);\n+  }\n+  if( wrflag ){\n+    \/* This call makes sure that the pager has the correct number of\n+    ** open savepoints. If the second parameter is greater than 0 and\n+    ** the sub-journal is not already open, then it will be opened here.\n+    *\/\n+    return sqlite3PagerOpenSavepoint(pBt->pPager, p->db->nSavepoint);\n+  }else{\n+    return SQLITE_OK;\n+  }\n+}\n@@ -70616,0 +74021,3 @@\n+        if( pCell+4 > pPage->aData+pPage->pBt->usableSize ){\n+          return SQLITE_CORRUPT_PAGE(pPage);\n+        }\n@@ -70664,1 +74072,1 @@\n-  TRACE((\"AUTOVACUUM: Moving %d to free page %d (ptr page %d type %d)\\n\",\n+  TRACE((\"AUTOVACUUM: Moving %u to free page %u (ptr page %u type %u)\\n\",\n@@ -71622,1 +75030,0 @@\n-#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC\n@@ -71634,1 +75041,0 @@\n-#endif \/* SQLITE_ENABLE_OFFSET_SQL_FUNC *\/\n@@ -71660,1 +75066,1 @@\n-** corrupt datrabase.\n+** corrupt database.\n@@ -71960,1 +75366,0 @@\n-          if( rc && nextPage>pBt->nPage ) rc = SQLITE_CORRUPT_BKPT;\n@@ -72122,2 +75527,1 @@\n-  BtShared *pBt = pCur->pBt;\n-\n+  int rc;\n@@ -72137,1 +75541,12 @@\n-  return getAndInitPage(pBt, newPgno, &pCur->pPage, pCur, pCur->curPagerFlags);\n+  rc = getAndInitPage(pCur->pBt, newPgno, &pCur->pPage, pCur->curPagerFlags);\n+  assert( pCur->pPage!=0 || rc!=SQLITE_OK );\n+  if( rc==SQLITE_OK\n+   && (pCur->pPage->nCell<1 || pCur->pPage->intKey!=pCur->curIntKey)\n+  ){\n+    releasePage(pCur->pPage);\n+    rc = SQLITE_CORRUPT_PGNO(newPgno);\n+  }\n+  if( rc ){\n+    pCur->pPage = pCur->apPage[--pCur->iPage];\n+  }\n+  return rc;\n@@ -72243,2 +75658,2 @@\n-    rc = getAndInitPage(pCur->pBtree->pBt, pCur->pgnoRoot, &pCur->pPage,\n-                        0, pCur->curPagerFlags);\n+    rc = getAndInitPage(pCur->pBt, pCur->pgnoRoot, &pCur->pPage,\n+                        pCur->curPagerFlags);\n@@ -72356,1 +75771,1 @@\n-    assert( pCur->pgnoRoot==0 || pCur->pPage->nCell==0 );\n+    assert( pCur->pgnoRoot==0 || (pCur->pPage!=0 && pCur->pPage->nCell==0) );\n@@ -72367,0 +75782,18 @@\n+static SQLITE_NOINLINE int btreeLast(BtCursor *pCur, int *pRes){\n+  int rc = moveToRoot(pCur);\n+  if( rc==SQLITE_OK ){\n+    assert( pCur->eState==CURSOR_VALID );\n+    *pRes = 0;\n+    rc = moveToRightmost(pCur);\n+    if( rc==SQLITE_OK ){\n+      pCur->curFlags |= BTCF_AtLast;\n+    }else{\n+      pCur->curFlags &= ~BTCF_AtLast;\n+    }\n+  }else if( rc==SQLITE_EMPTY ){\n+    assert( pCur->pgnoRoot==0 || pCur->pPage->nCell==0 );\n+    *pRes = 1;\n+    rc = SQLITE_OK;\n+  }\n+  return rc;\n+}\n@@ -72368,2 +75801,0 @@\n-  int rc;\n-\n@@ -72390,17 +75821,1 @@\n-\n-  rc = moveToRoot(pCur);\n-  if( rc==SQLITE_OK ){\n-    assert( pCur->eState==CURSOR_VALID );\n-    *pRes = 0;\n-    rc = moveToRightmost(pCur);\n-    if( rc==SQLITE_OK ){\n-      pCur->curFlags |= BTCF_AtLast;\n-    }else{\n-      pCur->curFlags &= ~BTCF_AtLast;\n-    }\n-  }else if( rc==SQLITE_EMPTY ){\n-    assert( pCur->pgnoRoot==0 || pCur->pPage->nCell==0 );\n-    *pRes = 1;\n-    rc = SQLITE_OK;\n-  }\n-  return rc;\n+  return btreeLast(pCur, pRes);\n@@ -72461,1 +75876,1 @@\n-      ** is still obtained without this case, only a little more slowely *\/\n+      ** is still obtained without this case, only a little more slowly. *\/\n@@ -72857,4 +76272,30 @@\n-    pCur->ix = (u16)lwr;\n-    rc = moveToChild(pCur, chldPg);\n-    if( rc ) break;\n-  }\n+\n+    \/* This block is similar to an in-lined version of:\n+    **\n+    **    pCur->ix = (u16)lwr;\n+    **    rc = moveToChild(pCur, chldPg);\n+    **    if( rc ) break;\n+    *\/\n+    pCur->info.nSize = 0;\n+    pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);\n+    if( pCur->iPage>=(BTCURSOR_MAX_DEPTH-1) ){\n+      return SQLITE_CORRUPT_BKPT;\n+    }\n+    pCur->aiIdx[pCur->iPage] = (u16)lwr;\n+    pCur->apPage[pCur->iPage] = pCur->pPage;\n+    pCur->ix = 0;\n+    pCur->iPage++;\n+    rc = getAndInitPage(pCur->pBt, chldPg, &pCur->pPage, pCur->curPagerFlags);\n+    if( rc==SQLITE_OK\n+     && (pCur->pPage->nCell<1 || pCur->pPage->intKey!=pCur->curIntKey)\n+    ){\n+      releasePage(pCur->pPage);\n+      rc = SQLITE_CORRUPT_PGNO(chldPg);\n+    }\n+    if( rc ){\n+      pCur->pPage = pCur->apPage[--pCur->iPage];\n+      break;\n+    }\n+    \/*\n+    ***** End of in-lined moveToChild() call *\/\n+ }\n@@ -72951,8 +76392,2 @@\n-  if( !pPage->isInit || sqlite3FaultSim(412) ){\n-    \/* The only known way for this to happen is for there to be a\n-    ** recursive SQL function that does a DELETE operation as part of a\n-    ** SELECT which deletes content out from under an active cursor\n-    ** in a corrupt database file where the table being DELETE-ed from\n-    ** has pages in common with the table being queried.  See TH3\n-    ** module cov1\/btree78.test testcase 220 (2018-06-08) for an\n-    ** example. *\/\n+  if( sqlite3FaultSim(412) ) pPage->isInit = 0;\n+  if( !pPage->isInit ){\n@@ -73050,1 +76485,4 @@\n-  assert( pPage->isInit );\n+  if( sqlite3FaultSim(412) ) pPage->isInit = 0;\n+  if( !pPage->isInit ){\n+    return SQLITE_CORRUPT_BKPT;\n+  }\n@@ -73134,2 +76572,2 @@\n-  \/* EVIDENCE-OF: R-05119-02637 The 4-byte big-endian integer at offset 36\n-  ** stores stores the total number of pages on the freelist. *\/\n+  \/* EVIDENCE-OF: R-21003-45125 The 4-byte big-endian integer at offset 36\n+  ** stores the total number of pages on the freelist. *\/\n@@ -73221,1 +76659,1 @@\n-        TRACE((\"ALLOCATE: %d trunk - %d free pages left\\n\", *pPgno, n-1));\n+        TRACE((\"ALLOCATE: %u trunk - %u free pages left\\n\", *pPgno, n-1));\n@@ -73287,1 +76725,1 @@\n-        TRACE((\"ALLOCATE: %d trunk - %d free pages left\\n\", *pPgno, n-1));\n+        TRACE((\"ALLOCATE: %u trunk - %u free pages left\\n\", *pPgno, n-1));\n@@ -73332,2 +76770,2 @@\n-          TRACE((\"ALLOCATE: %d was leaf %d of %d on trunk %d\"\n-                 \": %d more free pages\\n\",\n+          TRACE((\"ALLOCATE: %u was leaf %u of %u on trunk %u\"\n+                 \": %u more free pages\\n\",\n@@ -73389,1 +76827,1 @@\n-      TRACE((\"ALLOCATE: %d from end of file (pointer-map page)\\n\", pBt->nPage));\n+      TRACE((\"ALLOCATE: %u from end of file (pointer-map page)\\n\", pBt->nPage));\n@@ -73412,1 +76850,1 @@\n-    TRACE((\"ALLOCATE: %d from end of file\\n\", *pPgno));\n+    TRACE((\"ALLOCATE: %u from end of file\\n\", *pPgno));\n@@ -73480,1 +76918,1 @@\n-  if( ISAUTOVACUUM ){\n+  if( ISAUTOVACUUM(pBt) ){\n@@ -73540,1 +76978,1 @@\n-      TRACE((\"FREE-PAGE: %d leaf on trunk page %d\\n\",pPage->pgno,pTrunk->pgno));\n+      TRACE((\"FREE-PAGE: %u leaf on trunk page %u\\n\",pPage->pgno,pTrunk->pgno));\n@@ -73561,1 +76999,1 @@\n-  TRACE((\"FREE-PAGE: %d new trunk page replacing %d\\n\", pPage->pgno, iTrunk));\n+  TRACE((\"FREE-PAGE: %u new trunk page replacing %u\\n\", pPage->pgno, iTrunk));\n@@ -73650,1 +77088,1 @@\n-** STore the result code (SQLITE_OK or some error code) in rc.\n+** Store the result code (SQLITE_OK or some error code) in rc.\n@@ -73723,1 +77161,4 @@\n-    if( n<4 ) n = 4;\n+    if( n<4 ){\n+      n = 4;\n+      pPayload[nPayload] = 0;\n+    }\n@@ -73884,6 +77325,0 @@\n-#if 0  \/* Not required.  Omit for efficiency *\/\n-  if( pc<hdr+pPage->nCell*2 ){\n-    *pRC = SQLITE_CORRUPT_BKPT;\n-    return;\n-  }\n-#endif\n@@ -73927,1 +77362,7 @@\n-** *pRC must be SQLITE_OK when this routine is called.\n+** The insertCellFast() routine below works exactly the same as\n+** insertCell() except that it lacks the pTemp and iChild parameters\n+** which are assumed zero.  Other than that, the two routines are the\n+** same.\n+**\n+** Fixes or enhancements to this routine should be reflected in\n+** insertCellFast()!\n@@ -73929,1 +77370,1 @@\n-static void insertCell(\n+static int insertCell(\n@@ -73935,2 +77376,1 @@\n-  Pgno iChild,      \/* If non-zero, replace first 4 bytes with this value *\/\n-  int *pRC          \/* Read and write return code from here *\/\n+  Pgno iChild       \/* If non-zero, replace first 4 bytes with this value *\/\n@@ -73943,1 +77383,0 @@\n-  assert( *pRC==SQLITE_OK );\n@@ -73952,0 +77391,1 @@\n+  assert( iChild>0 );\n@@ -73957,2 +77397,54 @@\n-    if( iChild ){\n-      put4byte(pCell, iChild);\n+    put4byte(pCell, iChild);\n+    j = pPage->nOverflow++;\n+    \/* Comparison against ArraySize-1 since we hold back one extra slot\n+    ** as a contingency.  In other words, never need more than 3 overflow\n+    ** slots but 4 are allocated, just to be safe. *\/\n+    assert( j < ArraySize(pPage->apOvfl)-1 );\n+    pPage->apOvfl[j] = pCell;\n+    pPage->aiOvfl[j] = (u16)i;\n+\n+    \/* When multiple overflows occur, they are always sequential and in\n+    ** sorted order.  This invariants arise because multiple overflows can\n+    ** only occur when inserting divider cells into the parent page during\n+    ** balancing, and the dividers are adjacent and sorted.\n+    *\/\n+    assert( j==0 || pPage->aiOvfl[j-1]<(u16)i ); \/* Overflows in sorted order *\/\n+    assert( j==0 || i==pPage->aiOvfl[j-1]+1 );   \/* Overflows are sequential *\/\n+  }else{\n+    int rc = sqlite3PagerWrite(pPage->pDbPage);\n+    if( NEVER(rc!=SQLITE_OK) ){\n+      return rc;\n+    }\n+    assert( sqlite3PagerIswriteable(pPage->pDbPage) );\n+    data = pPage->aData;\n+    assert( &data[pPage->cellOffset]==pPage->aCellIdx );\n+    rc = allocateSpace(pPage, sz, &idx);\n+    if( rc ){ return rc; }\n+    \/* The allocateSpace() routine guarantees the following properties\n+    ** if it returns successfully *\/\n+    assert( idx >= 0 );\n+    assert( idx >= pPage->cellOffset+2*pPage->nCell+2 || CORRUPT_DB );\n+    assert( idx+sz <= (int)pPage->pBt->usableSize );\n+    pPage->nFree -= (u16)(2 + sz);\n+    \/* In a corrupt database where an entry in the cell index section of\n+    ** a btree page has a value of 3 or less, the pCell value might point\n+    ** as many as 4 bytes in front of the start of the aData buffer for\n+    ** the source page.  Make sure this does not cause problems by not\n+    ** reading the first 4 bytes *\/\n+    memcpy(&data[idx+4], pCell+4, sz-4);\n+    put4byte(&data[idx], iChild);\n+    pIns = pPage->aCellIdx + i*2;\n+    memmove(pIns+2, pIns, 2*(pPage->nCell - i));\n+    put2byte(pIns, idx);\n+    pPage->nCell++;\n+    \/* increment the cell count *\/\n+    if( (++data[pPage->hdrOffset+4])==0 ) data[pPage->hdrOffset+3]++;\n+    assert( get2byte(&data[pPage->hdrOffset+3])==pPage->nCell || CORRUPT_DB );\n+#ifndef SQLITE_OMIT_AUTOVACUUM\n+    if( pPage->pBt->autoVacuum ){\n+      int rc2 = SQLITE_OK;\n+      \/* The cell may contain a pointer to an overflow page. If so, write\n+      ** the entry for the overflow page into the pointer map.\n+      *\/\n+      ptrmapPutOvflPtr(pPage, pPage, pCell, &rc2);\n+      if( rc2 ) return rc2;\n@@ -73960,0 +77452,36 @@\n+#endif\n+  }\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** This variant of insertCell() assumes that the pTemp and iChild\n+** parameters are both zero.  Use this variant in sqlite3BtreeInsert()\n+** for performance improvement, and also so that this variant is only\n+** called from that one place, and is thus inlined, and thus runs must\n+** faster.\n+**\n+** Fixes or enhancements to this routine should be reflected into\n+** the insertCell() routine.\n+*\/\n+static int insertCellFast(\n+  MemPage *pPage,   \/* Page into which we are copying *\/\n+  int i,            \/* New cell becomes the i-th cell of the page *\/\n+  u8 *pCell,        \/* Content of the new cell *\/\n+  int sz            \/* Bytes of content in pCell *\/\n+){\n+  int idx = 0;      \/* Where to write new cell content in data[] *\/\n+  int j;            \/* Loop counter *\/\n+  u8 *data;         \/* The content of the whole page *\/\n+  u8 *pIns;         \/* The point in pPage->aCellIdx[] where no cell inserted *\/\n+\n+  assert( i>=0 && i<=pPage->nCell+pPage->nOverflow );\n+  assert( MX_CELL(pPage->pBt)<=10921 );\n+  assert( pPage->nCell<=MX_CELL(pPage->pBt) || CORRUPT_DB );\n+  assert( pPage->nOverflow<=ArraySize(pPage->apOvfl) );\n+  assert( ArraySize(pPage->apOvfl)==ArraySize(pPage->aiOvfl) );\n+  assert( sqlite3_mutex_held(pPage->pBt->mutex) );\n+  assert( sz==pPage->xCellSize(pPage, pCell) || CORRUPT_DB );\n+  assert( pPage->nFree>=0 );\n+  assert( pPage->nOverflow==0 );\n+  if( sz+2>pPage->nFree ){\n@@ -73978,2 +77506,1 @@\n-      *pRC = rc;\n-      return;\n+      return rc;\n@@ -73985,1 +77512,1 @@\n-    if( rc ){ *pRC = rc; return; }\n+    if( rc ){ return rc; }\n@@ -73992,11 +77519,1 @@\n-    if( iChild ){\n-      \/* In a corrupt database where an entry in the cell index section of\n-      ** a btree page has a value of 3 or less, the pCell value might point\n-      ** as many as 4 bytes in front of the start of the aData buffer for\n-      ** the source page.  Make sure this does not cause problems by not\n-      ** reading the first 4 bytes *\/\n-      memcpy(&data[idx+4], pCell+4, sz-4);\n-      put4byte(&data[idx], iChild);\n-    }else{\n-      memcpy(&data[idx], pCell, sz);\n-    }\n+    memcpy(&data[idx], pCell, sz);\n@@ -74012,0 +77529,1 @@\n+      int rc2 = SQLITE_OK;\n@@ -74015,1 +77533,2 @@\n-      ptrmapPutOvflPtr(pPage, pPage, pCell, pRC);\n+      ptrmapPutOvflPtr(pPage, pPage, pCell, &rc2);\n+      if( rc2 ) return rc2;\n@@ -74019,0 +77538,1 @@\n+  return SQLITE_OK;\n@@ -74119,0 +77639,2 @@\n+  MemPage *pRef = p->pRef;\n+  u16 *szCell = p->szCell;\n@@ -74122,2 +77644,2 @@\n-    if( p->szCell[idx]==0 ){\n-      p->szCell[idx] = p->pRef->xCellSize(p->pRef, p->apCell[idx]);\n+    if( szCell[idx]==0 ){\n+      szCell[idx] = pRef->xCellSize(pRef, p->apCell[idx]);\n@@ -74126,1 +77648,1 @@\n-              p->szCell[idx]==p->pRef->xCellSize(p->pRef, p->apCell[idx]) );\n+              szCell[idx]==pRef->xCellSize(pRef, p->apCell[idx]) );\n@@ -74180,0 +77702,1 @@\n+  assert( nCell>0 );\n@@ -74185,1 +77708,1 @@\n-  for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}\n+  for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i; k++){}\n@@ -74248,1 +77771,1 @@\n-** area must be extended to before this point in order to accomodate all\n+** area must be extended to before this point in order to accommodate all\n@@ -74268,1 +77791,1 @@\n-  for(k=0; pCArray->ixNx[k]<=i && ALWAYS(k<NB*2); k++){}\n+  for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i ; k++){}\n@@ -74326,1 +77849,1 @@\n-  int i;\n+  int i, j;\n@@ -74328,2 +77851,3 @@\n-  u8 *pFree = 0;\n-  int szFree = 0;\n+  int nFree = 0;\n+  int aOfst[10];\n+  int aAfter[10];\n@@ -74335,0 +77859,2 @@\n+      int iAfter;\n+      int iOfst;\n@@ -74339,9 +77865,9 @@\n-      if( pFree!=(pCell + sz) ){\n-        if( pFree ){\n-          assert( pFree>aData && (pFree - aData)<65536 );\n-          freeSpace(pPg, (u16)(pFree - aData), szFree);\n-        }\n-        pFree = pCell;\n-        szFree = sz;\n-        if( pFree+sz>pEnd ){\n-          return 0;\n+      iOfst = (u16)(pCell - aData);\n+      iAfter = iOfst+sz;\n+      for(j=0; j<nFree; j++){\n+        if( aOfst[j]==iAfter ){\n+          aOfst[j] = iOfst;\n+          break;\n+        }else if( aAfter[j]==iOfst ){\n+          aAfter[j] = iAfter;\n+          break;\n@@ -74349,3 +77875,12 @@\n-      }else{\n-        pFree = pCell;\n-        szFree += sz;\n+      }\n+      if( j>=nFree ){\n+        if( nFree>=(int)(sizeof(aOfst)\/sizeof(aOfst[0])) ){\n+          for(j=0; j<nFree; j++){\n+            freeSpace(pPg, aOfst[j], aAfter[j]-aOfst[j]);\n+          }\n+          nFree = 0;\n+        }\n+        aOfst[nFree] = iOfst;\n+        aAfter[nFree] = iAfter;\n+        if( &aData[iAfter]>pEnd ) return 0;\n+        nFree++;\n@@ -74356,3 +77891,2 @@\n-  if( pFree ){\n-    assert( pFree>aData && (pFree - aData)<65536 );\n-    freeSpace(pPg, (u16)(pFree - aData), szFree);\n+  for(j=0; j<nFree; j++){\n+    freeSpace(pPg, aOfst[j], aAfter[j]-aOfst[j]);\n@@ -74411,1 +77945,1 @@\n-  pData = &aData[get2byteNotZero(&aData[hdr+5])];\n+  pData = &aData[get2byte(&aData[hdr+5])];\n@@ -74413,1 +77947,1 @@\n-  if( pData>pPg->aDataEnd ) goto editpage_fail;\n+  if( NEVER(pData>pPg->aDataEnd) ) goto editpage_fail;\n@@ -74475,0 +78009,1 @@\n+  if( nNew<1 ) return SQLITE_CORRUPT_BKPT;\n@@ -74552,1 +78087,1 @@\n-    ** of the parent page are still manipulated by thh code below.\n+    ** of the parent page are still manipulated by the code below.\n@@ -74557,1 +78092,1 @@\n-    if( ISAUTOVACUUM ){\n+    if( ISAUTOVACUUM(pBt) ){\n@@ -74585,2 +78120,2 @@\n-      insertCell(pParent, pParent->nCell, pSpace, (int)(pOut-pSpace),\n-                   0, pPage->pgno, &rc);\n+      rc = insertCell(pParent, pParent->nCell, pSpace, (int)(pOut-pSpace),\n+                      0, pPage->pgno);\n@@ -74695,1 +78230,1 @@\n-    if( ISAUTOVACUUM ){\n+    if( ISAUTOVACUUM(pBt) ){\n@@ -74828,1 +78363,1 @@\n-      rc = getAndInitPage(pBt, pgno, &apOld[i], 0, 0);\n+      rc = getAndInitPage(pBt, pgno, &apOld[i], 0);\n@@ -75119,0 +78654,1 @@\n+      int szR, szD;\n@@ -75121,1 +78657,2 @@\n-      (void)cachedCellSize(&b, r);\n+      szR = cachedCellSize(&b, r);\n+      szD = b.szCell[d];\n@@ -75123,1 +78660,1 @@\n-       && (bBulk || szRight+b.szCell[d]+2 > szLeft-(b.szCell[r]+(i==k-1?0:2)))){\n+       && (bBulk || szRight+szD+2 > szLeft-(szR+(i==k-1?0:2)))){\n@@ -75126,2 +78663,2 @@\n-      szRight += b.szCell[d] + 2;\n-      szLeft -= b.szCell[r] + 2;\n+      szRight += szD + 2;\n+      szLeft -= szR + 2;\n@@ -75140,1 +78677,1 @@\n-  \/* Sanity check:  For a non-corrupt database file one of the follwing\n+  \/* Sanity check:  For a non-corrupt database file one of the following\n@@ -75148,1 +78685,1 @@\n-  TRACE((\"BALANCE: old: %d(nc=%d) %d(nc=%d) %d(nc=%d)\\n\",\n+  TRACE((\"BALANCE: old: %u(nc=%u) %u(nc=%u) %u(nc=%u)\\n\",\n@@ -75181,1 +78718,1 @@\n-      if( ISAUTOVACUUM ){\n+      if( ISAUTOVACUUM(pBt) ){\n@@ -75232,2 +78769,2 @@\n-  TRACE((\"BALANCE: new: %d(%d nc=%d) %d(%d nc=%d) %d(%d nc=%d) \"\n-         \"%d(%d nc=%d) %d(%d nc=%d)\\n\",\n+  TRACE((\"BALANCE: new: %u(%u nc=%u) %u(%u nc=%u) %u(%u nc=%u) \"\n+         \"%u(%u nc=%u) %u(%u nc=%u)\\n\",\n@@ -75274,1 +78811,1 @@\n-  if( ISAUTOVACUUM ){\n+  if( ISAUTOVACUUM(pBt) ){\n@@ -75365,1 +78902,1 @@\n-    for(k=0; b.ixNx[k]<=j && ALWAYS(k<NB*2); k++){}\n+    for(k=0; ALWAYS(k<NB*2) && b.ixNx[k]<=j; k++){}\n@@ -75367,1 +78904,1 @@\n-    if( SQLITE_WITHIN(pSrcEnd, pCell, pCell+sz) ){\n+    if( SQLITE_OVERFLOW(pSrcEnd, pCell, pCell+sz) ){\n@@ -75371,1 +78908,1 @@\n-    insertCell(pParent, nxDiv+i, pCell, sz, pTemp, pNew->pgno, &rc);\n+    rc = insertCell(pParent, nxDiv+i, pCell, sz, pTemp, pNew->pgno);\n@@ -75401,0 +78938,2 @@\n+    assert( iPg>=1 || i>=0 );\n+    assert( iPg<ArraySize(cntOld) );\n@@ -75467,1 +79006,1 @@\n-  }else if( ISAUTOVACUUM && !leafCorrection ){\n+  }else if( ISAUTOVACUUM(pBt) && !leafCorrection ){\n@@ -75478,1 +79017,1 @@\n-  TRACE((\"BALANCE: finished: old=%d new=%d cells=%d\\n\",\n+  TRACE((\"BALANCE: finished: old=%u new=%u cells=%u\\n\",\n@@ -75488,1 +79027,1 @@\n-  if( ISAUTOVACUUM && rc==SQLITE_OK && apNew[0]->isInit ){\n+  if( ISAUTOVACUUM(pBt) && rc==SQLITE_OK && apNew[0]->isInit ){\n@@ -75550,1 +79089,1 @@\n-    if( ISAUTOVACUUM ){\n+    if( ISAUTOVACUUM(pBt) ){\n@@ -75563,1 +79102,1 @@\n-  TRACE((\"BALANCE: copy root %d into %d\\n\", pRoot->pgno, pChild->pgno));\n+  TRACE((\"BALANCE: copy root %u into %u\\n\", pRoot->pgno, pChild->pgno));\n@@ -75654,0 +79193,5 @@\n+    }else if( sqlite3PagerPageRefcount(pPage->pDbPage)>1 ){\n+      \/* The page being written is not a root page, and there is currently\n+      ** more than one reference to it. This only happens if the page is one\n+      ** of its own ancestor pages. Corruption. *\/\n+      rc = SQLITE_CORRUPT_BKPT;\n@@ -75752,1 +79296,1 @@\n-    \/* Overwritting with zeros *\/\n+    \/* Overwriting with zeros *\/\n@@ -75784,1 +79328,2 @@\n-** contained in pX.\n+** contained in pX.  In this variant, pCur is pointing to an overflow\n+** cell.\n@@ -75786,1 +79331,4 @@\n-static int btreeOverwriteCell(BtCursor *pCur, const BtreePayload *pX){\n+static SQLITE_NOINLINE int btreeOverwriteOverflowCell(\n+  BtCursor *pCur,                     \/* Cursor pointing to cell to overwrite *\/\n+  const BtreePayload *pX              \/* Content to write into the cell *\/\n+){\n@@ -75795,5 +79343,2 @@\n-  if( pCur->info.pPayload + pCur->info.nLocal > pPage->aDataEnd\n-   || pCur->info.pPayload < pPage->aData + pPage->cellOffset\n-  ){\n-    return SQLITE_CORRUPT_BKPT;\n-  }\n+  assert( pCur->info.nLocal<nTotal );  \/* pCur is an overflow cell *\/\n+\n@@ -75804,1 +79349,0 @@\n-  if( pCur->info.nLocal==nTotal ) return SQLITE_OK;\n@@ -75834,0 +79378,23 @@\n+\/*\n+** Overwrite the cell that cursor pCur is pointing to with fresh content\n+** contained in pX.\n+*\/\n+static int btreeOverwriteCell(BtCursor *pCur, const BtreePayload *pX){\n+  int nTotal = pX->nData + pX->nZero; \/* Total bytes of to write *\/\n+  MemPage *pPage = pCur->pPage;       \/* Page being written *\/\n+\n+  if( pCur->info.pPayload + pCur->info.nLocal > pPage->aDataEnd\n+   || pCur->info.pPayload < pPage->aData + pPage->cellOffset\n+  ){\n+    return SQLITE_CORRUPT_BKPT;\n+  }\n+  if( pCur->info.nLocal==nTotal ){\n+    \/* The entire cell is local *\/\n+    return btreeOverwriteContent(pPage, pCur->info.pPayload, pX,\n+                                 0, pCur->info.nLocal);\n+  }else{\n+    \/* The cell contains overflow content *\/\n+    return btreeOverwriteOverflowCell(pCur, pX);\n+  }\n+}\n+\n@@ -75877,1 +79444,0 @@\n-  BtShared *pBt = p->pBt;\n@@ -75896,1 +79462,1 @@\n-    rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);\n+    rc = saveAllCursors(p->pBt, pCur->pgnoRoot, pCur);\n@@ -75920,2 +79486,2 @@\n-              && pBt->inTransaction==TRANS_WRITE\n-              && (pBt->btsFlags & BTS_READ_ONLY)==0 );\n+              && p->pBt->inTransaction==TRANS_WRITE\n+              && (p->pBt->btsFlags & BTS_READ_ONLY)==0 );\n@@ -76019,1 +79585,1 @@\n-       || (pCur->eState==CURSOR_INVALID && loc) );\n+       || (pCur->eState==CURSOR_INVALID && loc) || CORRUPT_DB );\n@@ -76034,1 +79600,1 @@\n-  TRACE((\"INSERT: table=%d nkey=%lld ndata=%d page=%d %s\\n\",\n+  TRACE((\"INSERT: table=%u nkey=%lld ndata=%u page=%u %s\\n\",\n@@ -76038,1 +79604,1 @@\n-  newCell = pBt->pTmpSpace;\n+  newCell = p->pBt->pTmpSpace;\n@@ -76040,0 +79606,1 @@\n+  assert( BTREE_PREFORMAT==OPFLAG_PREFORMAT );\n@@ -76042,3 +79609,6 @@\n-    szNew = pBt->nPreformatSize;\n-    if( szNew<4 ) szNew = 4;\n-    if( ISAUTOVACUUM && szNew>pPage->maxLocal ){\n+    szNew = p->pBt->nPreformatSize;\n+    if( szNew<4 ){\n+      szNew = 4;\n+      newCell[3] = 0;\n+    }\n+    if( ISAUTOVACUUM(p->pBt) && szNew>pPage->maxLocal ){\n@@ -76049,1 +79619,2 @@\n-        ptrmapPut(pBt, ovfl, PTRMAP_OVERFLOW1, pPage->pgno, &rc);\n+        ptrmapPut(p->pBt, ovfl, PTRMAP_OVERFLOW1, pPage->pgno, &rc);\n+        if( NEVER(rc) ) goto end_insert;\n@@ -76054,0 +79625,1 @@\n+    if( rc ) goto end_insert;\n@@ -76055,1 +79627,0 @@\n-  if( rc ) goto end_insert;\n@@ -76057,1 +79628,1 @@\n-  assert( szNew <= MX_CELL_SIZE(pBt) );\n+  assert( szNew <= MX_CELL_SIZE(p->pBt) );\n@@ -76059,0 +79630,1 @@\n+  pCur->info.nSize = 0;\n@@ -76077,1 +79649,1 @@\n-     && (!ISAUTOVACUUM || szNew<pPage->minLocal)\n+     && (!ISAUTOVACUUM(p->pBt) || szNew<pPage->minLocal)\n@@ -76103,1 +79675,1 @@\n-    pCur->curFlags &= ~BTCF_ValidNKey;\n+    pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);\n@@ -76107,1 +79679,1 @@\n-  insertCell(pPage, idx, newCell, szNew, 0, 0, &rc);\n+  rc = insertCellFast(pPage, idx, newCell, szNew);\n@@ -76131,1 +79703,0 @@\n-  pCur->info.nSize = 0;\n@@ -76134,1 +79705,1 @@\n-    pCur->curFlags &= ~(BTCF_ValidNKey);\n+    pCur->curFlags &= ~(BTCF_ValidNKey|BTCF_ValidOvfl);\n@@ -76180,1 +79751,0 @@\n-  int rc = SQLITE_OK;\n@@ -76203,0 +79773,1 @@\n+    return SQLITE_OK;\n@@ -76204,0 +79775,1 @@\n+    int rc = SQLITE_OK;\n@@ -76255,1 +79827,1 @@\n-        if( ISAUTOVACUUM && pPageOut ){\n+        if( ISAUTOVACUUM(pBt) && pPageOut ){\n@@ -76271,0 +79843,1 @@\n+    return rc;\n@@ -76272,2 +79845,0 @@\n-\n-  return rc;\n@@ -76332,0 +79903,3 @@\n+  if( pCell<&pPage->aCellIdx[pPage->nCell] ){\n+    return SQLITE_CORRUPT_BKPT;\n+  }\n@@ -76428,1 +80002,1 @@\n-      insertCell(pPage, iCellIdx, pCell-4, nCell+4, pTmp, n, &rc);\n+      rc = insertCell(pPage, iCellIdx, pCell-4, nCell+4, pTmp, n);\n@@ -76508,1 +80082,1 @@\n-  int ptfFlags;          \/* Page-type flage for the root page of new table *\/\n+  int ptfFlags;          \/* Page-type flags for the root page of new table *\/\n@@ -76677,1 +80251,1 @@\n-  rc = getAndInitPage(pBt, pgno, &pPage, 0, 0);\n+  rc = getAndInitPage(pBt, pgno, &pPage, 0);\n@@ -77027,0 +80601,35 @@\n+\/*\n+** Record an OOM error during integrity_check\n+*\/\n+static void checkOom(IntegrityCk *pCheck){\n+  pCheck->rc = SQLITE_NOMEM;\n+  pCheck->mxErr = 0;  \/* Causes integrity_check processing to stop *\/\n+  if( pCheck->nErr==0 ) pCheck->nErr++;\n+}\n+\n+\/*\n+** Invoke the progress handler, if appropriate.  Also check for an\n+** interrupt.\n+*\/\n+static void checkProgress(IntegrityCk *pCheck){\n+  sqlite3 *db = pCheck->db;\n+  if( AtomicLoad(&db->u1.isInterrupted) ){\n+    pCheck->rc = SQLITE_INTERRUPT;\n+    pCheck->nErr++;\n+    pCheck->mxErr = 0;\n+  }\n+#ifndef SQLITE_OMIT_PROGRESS_CALLBACK\n+  if( db->xProgress ){\n+    assert( db->nProgressOps>0 );\n+    pCheck->nStep++;\n+    if( (pCheck->nStep % db->nProgressOps)==0\n+     && db->xProgress(db->pProgressArg)\n+    ){\n+      pCheck->rc = SQLITE_INTERRUPT;\n+      pCheck->nErr++;\n+      pCheck->mxErr = 0;\n+    }\n+  }\n+#endif\n+}\n+\n@@ -77036,0 +80645,1 @@\n+  checkProgress(pCheck);\n@@ -77044,1 +80654,2 @@\n-    sqlite3_str_appendf(&pCheck->errMsg, pCheck->zPfx, pCheck->v1, pCheck->v2);\n+    sqlite3_str_appendf(&pCheck->errMsg, pCheck->zPfx,\n+                        pCheck->v0, pCheck->v1, pCheck->v2);\n@@ -77049,1 +80660,1 @@\n-    pCheck->bOomFault = 1;\n+    checkOom(pCheck);\n@@ -77061,1 +80672,2 @@\n-  assert( iPg<=pCheck->nPage && sizeof(pCheck->aPgRef[0])==1 );\n+  assert( pCheck->aPgRef!=0 );\n+  assert( iPg<=pCheck->nCkPage && sizeof(pCheck->aPgRef[0])==1 );\n@@ -77069,1 +80681,2 @@\n-  assert( iPg<=pCheck->nPage && sizeof(pCheck->aPgRef[0])==1 );\n+  assert( pCheck->aPgRef!=0 );\n+  assert( iPg<=pCheck->nCkPage && sizeof(pCheck->aPgRef[0])==1 );\n@@ -77083,2 +80696,2 @@\n-  if( iPage>pCheck->nPage || iPage==0 ){\n-    checkAppendMsg(pCheck, \"invalid page number %d\", iPage);\n+  if( iPage>pCheck->nCkPage || iPage==0 ){\n+    checkAppendMsg(pCheck, \"invalid page number %u\", iPage);\n@@ -77088,1 +80701,1 @@\n-    checkAppendMsg(pCheck, \"2nd reference to page %d\", iPage);\n+    checkAppendMsg(pCheck, \"2nd reference to page %u\", iPage);\n@@ -77091,1 +80704,0 @@\n-  if( AtomicLoad(&pCheck->db->u1.isInterrupted) ) return 1;\n@@ -77114,2 +80726,2 @@\n-    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->bOomFault = 1;\n-    checkAppendMsg(pCheck, \"Failed to read ptrmap key=%d\", iChild);\n+    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) checkOom(pCheck);\n+    checkAppendMsg(pCheck, \"Failed to read ptrmap key=%u\", iChild);\n@@ -77121,1 +80733,1 @@\n-      \"Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)\",\n+      \"Bad ptr map entry key=%u expected=(%u,%u) got=(%u,%u)\",\n@@ -77146,1 +80758,1 @@\n-      checkAppendMsg(pCheck, \"failed to get page %d\", iPage);\n+      checkAppendMsg(pCheck, \"failed to get page %u\", iPage);\n@@ -77159,1 +80771,1 @@\n-           \"freelist leaf count too big on page %d\", iPage);\n+           \"freelist leaf count too big on page %u\", iPage);\n@@ -77191,1 +80803,1 @@\n-      \"%s is %d but should be %d\",\n+      \"%s is %u but should be %u\",\n@@ -77221,1 +80833,3 @@\n-  u32 j, i = ++aHeap[0];\n+  u32 j, i;\n+  assert( aHeap!=0 );\n+  i = ++aHeap[0];\n@@ -77298,0 +80912,2 @@\n+  checkProgress(pCheck);\n+  if( pCheck->mxErr==0 ) goto end_of_check;\n@@ -77302,1 +80918,1 @@\n-  pCheck->zPfx = \"Page %u: \";\n+  pCheck->zPfx = \"Tree %u page %u: \";\n@@ -77307,0 +80923,1 @@\n+    if( rc==SQLITE_IOERR_NOMEM ) pCheck->rc = SQLITE_NOMEM;\n@@ -77329,1 +80946,1 @@\n-  pCheck->zPfx = \"On tree page %u cell %d: \";\n+  pCheck->zPfx = \"Tree %u page %u cell %u: \";\n@@ -77349,1 +80966,1 @@\n-      pCheck->zPfx = \"On page %u at right child: \";\n+      pCheck->zPfx = \"Tree %u page %u right child: \";\n@@ -77373,1 +80990,1 @@\n-      checkAppendMsg(pCheck, \"Offset %d out of range %d..%d\",\n+      checkAppendMsg(pCheck, \"Offset %u out of range %u..%u\",\n@@ -77505,1 +81122,1 @@\n-          \"Fragmentation of %d bytes reported as %d on page %u\",\n+          \"Fragmentation of %u bytes reported as %u on page %u\",\n@@ -77543,1 +81160,1 @@\n-SQLITE_PRIVATE char *sqlite3BtreeIntegrityCheck(\n+SQLITE_PRIVATE int sqlite3BtreeIntegrityCheck(\n@@ -77549,1 +81166,2 @@\n-  int *pnErr    \/* Write number of errors seen to this variable *\/\n+  int *pnErr,   \/* OUT: Write number of errors seen to this variable *\/\n+  char **pzOut  \/* OUT: Write the error message string here *\/\n@@ -77572,0 +81190,1 @@\n+  memset(&sCheck, 0, sizeof(sCheck));\n@@ -77575,1 +81194,1 @@\n-  sCheck.nPage = btreePagecount(sCheck.pBt);\n+  sCheck.nCkPage = btreePagecount(sCheck.pBt);\n@@ -77577,7 +81196,0 @@\n-  sCheck.nErr = 0;\n-  sCheck.bOomFault = 0;\n-  sCheck.zPfx = 0;\n-  sCheck.v1 = 0;\n-  sCheck.v2 = 0;\n-  sCheck.aPgRef = 0;\n-  sCheck.heap = 0;\n@@ -77586,1 +81198,1 @@\n-  if( sCheck.nPage==0 ){\n+  if( sCheck.nCkPage==0 ){\n@@ -77590,1 +81202,1 @@\n-  sCheck.aPgRef = sqlite3MallocZero((sCheck.nPage \/ 8)+ 1);\n+  sCheck.aPgRef = sqlite3MallocZero((sCheck.nCkPage \/ 8)+ 1);\n@@ -77592,1 +81204,1 @@\n-    sCheck.bOomFault = 1;\n+    checkOom(&sCheck);\n@@ -77597,1 +81209,1 @@\n-    sCheck.bOomFault = 1;\n+    checkOom(&sCheck);\n@@ -77602,1 +81214,1 @@\n-  if( i<=sCheck.nPage ) setPageReferenced(&sCheck, i);\n+  if( i<=sCheck.nCkPage ) setPageReferenced(&sCheck, i);\n@@ -77607,1 +81219,1 @@\n-    sCheck.zPfx = \"Main freelist: \";\n+    sCheck.zPfx = \"Freelist: \";\n@@ -77624,1 +81236,1 @@\n-          \"max rootpage (%d) disagrees with header (%d)\",\n+          \"max rootpage (%u) disagrees with header (%u)\",\n@@ -77645,0 +81257,1 @@\n+    sCheck.v0 = aRoot[i];\n@@ -77652,1 +81265,1 @@\n-    for(i=1; i<=sCheck.nPage && sCheck.mxErr; i++){\n+    for(i=1; i<=sCheck.nCkPage && sCheck.mxErr; i++){\n@@ -77655,1 +81268,1 @@\n-        checkAppendMsg(&sCheck, \"Page %d is never used\", i);\n+        checkAppendMsg(&sCheck, \"Page %u: never used\", i);\n@@ -77663,1 +81276,1 @@\n-        checkAppendMsg(&sCheck, \"Page %d is never used\", i);\n+        checkAppendMsg(&sCheck, \"Page %u: never used\", i);\n@@ -77667,1 +81280,1 @@\n-        checkAppendMsg(&sCheck, \"Pointer map page %d is referenced\", i);\n+        checkAppendMsg(&sCheck, \"Page %u: pointer map referenced\", i);\n@@ -77678,1 +81291,2 @@\n-  if( sCheck.bOomFault ){\n+  *pnErr = sCheck.nErr;\n+  if( sCheck.nErr==0 ){\n@@ -77680,1 +81294,3 @@\n-    sCheck.nErr++;\n+    *pzOut = 0;\n+  }else{\n+    *pzOut = sqlite3StrAccumFinish(&sCheck.errMsg);\n@@ -77682,2 +81298,0 @@\n-  *pnErr = sCheck.nErr;\n-  if( sCheck.nErr==0 ) sqlite3_str_reset(&sCheck.errMsg);\n@@ -77687,1 +81301,1 @@\n-  return sqlite3StrAccumFinish(&sCheck.errMsg);\n+  return sCheck.rc;\n@@ -77952,0 +81566,11 @@\n+\/*\n+** If no transaction is active and the database is not a temp-db, clear\n+** the in-memory pager cache.\n+*\/\n+SQLITE_PRIVATE void sqlite3BtreeClearCache(Btree *p){\n+  BtShared *pBt = p->pBt;\n+  if( pBt->inTransaction==TRANS_NONE ){\n+    sqlite3PagerClearCache(pBt->pPager);\n+  }\n+}\n+\n@@ -78217,7 +81842,1 @@\n-\n-  \/* Catch the case where the destination is an in-memory database and the\n-  ** page sizes of the source and destination differ.\n-  *\/\n-  if( nSrcPgsz!=nDestPgsz && sqlite3PagerIsMemdb(pDestPager) ){\n-    rc = SQLITE_READONLY;\n-  }\n+  assert( nSrcPgsz==nDestPgsz || sqlite3PagerIsMemdb(pDestPager)==0 );\n@@ -78356,1 +81975,4 @@\n-    if( SQLITE_OK==rc && destMode==PAGER_JOURNALMODE_WAL && pgszSrc!=pgszDest ){\n+    if( SQLITE_OK==rc\n+     && (destMode==PAGER_JOURNALMODE_WAL || sqlite3PagerIsMemdb(pDestPager))\n+     && pgszSrc!=pgszDest\n+    ){\n@@ -78862,1 +82484,1 @@\n-    sqlite3Int64ToText(x, zBuf);\n+    p->n = sqlite3Int64ToText(x, zBuf);\n@@ -78864,1 +82486,1 @@\n-    sqlite3Int64ToText(p->u.i, zBuf);\n+    p->n = sqlite3Int64ToText(p->u.i, zBuf);\n@@ -78872,0 +82494,1 @@\n+    p->n = acc.nChar;\n@@ -78899,0 +82522,1 @@\n+  Mem tmp;\n@@ -78903,0 +82527,1 @@\n+  if( p->db && p->db->mallocFailed ) return 1;\n@@ -78915,1 +82540,2 @@\n-  vdbeMemRenderNum(sizeof(zBuf), zBuf, p);\n+  memcpy(&tmp, p, sizeof(tmp));\n+  vdbeMemRenderNum(sizeof(zBuf), zBuf, &tmp);\n@@ -79058,0 +82684,34 @@\n+\/*\n+** If pMem is already a string, detect if it is a zero-terminated\n+** string, or make it into one if possible, and mark it as such.\n+**\n+** This is an optimization.  Correct operation continues even if\n+** this routine is a no-op.\n+*\/\n+SQLITE_PRIVATE void sqlite3VdbeMemZeroTerminateIfAble(Mem *pMem){\n+  if( (pMem->flags & (MEM_Str|MEM_Term|MEM_Ephem|MEM_Static))!=MEM_Str ){\n+    \/* pMem must be a string, and it cannot be an ephemeral or static string *\/\n+    return;\n+  }\n+  if( pMem->enc!=SQLITE_UTF8 ) return;\n+  if( NEVER(pMem->z==0) ) return;\n+  if( pMem->flags & MEM_Dyn ){\n+    if( pMem->xDel==sqlite3_free\n+     && sqlite3_msize(pMem->z) >= (u64)(pMem->n+1)\n+    ){\n+      pMem->z[pMem->n] = 0;\n+      pMem->flags |= MEM_Term;\n+      return;\n+    }\n+    if( pMem->xDel==sqlite3RCStrUnref ){\n+      \/* Blindly assume that all RCStr objects are zero-terminated *\/\n+      pMem->flags |= MEM_Term;\n+      return;\n+    }\n+  }else if( pMem->szMalloc >= pMem->n+1 ){\n+    pMem->z[pMem->n] = 0;\n+    pMem->flags |= MEM_Term;\n+    return;\n+  }\n+}\n+\n@@ -79184,1 +82844,1 @@\n-  pMem->n = sqlite3Strlen30NN(pMem->z);\n+  assert( pMem->n==(int)sqlite3Strlen30NN(pMem->z) );\n@@ -79319,30 +82979,0 @@\n-\/*\n-** Convert a 64-bit IEEE double into a 64-bit signed integer.\n-** If the double is out of range of a 64-bit signed integer then\n-** return the closest available 64-bit signed integer.\n-*\/\n-static SQLITE_NOINLINE i64 doubleToInt64(double r){\n-#ifdef SQLITE_OMIT_FLOATING_POINT\n-  \/* When floating-point is omitted, double and int64 are the same thing *\/\n-  return r;\n-#else\n-  \/*\n-  ** Many compilers we encounter do not define constants for the\n-  ** minimum and maximum 64-bit integers, or they define them\n-  ** inconsistently.  And many do not understand the \"LL\" notation.\n-  ** So we define our own static constants here using nothing\n-  ** larger than a 32-bit integer constant.\n-  *\/\n-  static const i64 maxInt = LARGEST_INT64;\n-  static const i64 minInt = SMALLEST_INT64;\n-\n-  if( r<=(double)minInt ){\n-    return minInt;\n-  }else if( r>=(double)maxInt ){\n-    return maxInt;\n-  }else{\n-    return (i64)r;\n-  }\n-#endif\n-}\n-\n@@ -79375,1 +83005,1 @@\n-    return doubleToInt64(pMem->u.r);\n+    return sqlite3RealToI64(pMem->u.r);\n@@ -79424,2 +83054,2 @@\n-** The MEM structure is already a MEM_Real.  Try to also make it a\n-** MEM_Int if we can.\n+** The MEM structure is already a MEM_Real or MEM_IntReal. Try to\n+** make it a MEM_Int if we can.\n@@ -79428,1 +83058,0 @@\n-  i64 ix;\n@@ -79430,1 +83059,1 @@\n-  assert( pMem->flags & MEM_Real );\n+  assert( pMem->flags & (MEM_Real|MEM_IntReal) );\n@@ -79435,14 +83064,1 @@\n-  ix = doubleToInt64(pMem->u.r);\n-\n-  \/* Only mark the value as an integer if\n-  **\n-  **    (1) the round-trip conversion real->int->real is a no-op, and\n-  **    (2) The integer is neither the largest nor the smallest\n-  **        possible integer (ticket #3922)\n-  **\n-  ** The second and third terms in the following conditional enforces\n-  ** the second condition under the assumption that addition overflow causes\n-  ** values to wrap around.\n-  *\/\n-  if( pMem->u.r==ix && ix>SMALLEST_INT64 && ix<LARGEST_INT64 ){\n-    pMem->u.i = ix;\n+  if( pMem->flags & MEM_IntReal ){\n@@ -79450,0 +83066,17 @@\n+  }else{\n+    i64 ix = sqlite3RealToI64(pMem->u.r);\n+\n+    \/* Only mark the value as an integer if\n+    **\n+    **    (1) the round-trip conversion real->int->real is a no-op, and\n+    **    (2) The integer is neither the largest nor the smallest\n+    **        possible integer (ticket #3922)\n+    **\n+    ** The second and third terms in the following conditional enforces\n+    ** the second condition under the assumption that addition overflow causes\n+    ** values to wrap around.\n+    *\/\n+    if( pMem->u.r==ix && ix>SMALLEST_INT64 && ix<LARGEST_INT64 ){\n+      pMem->u.i = ix;\n+      MemSetTypeFlag(pMem, MEM_Int);\n+    }\n@@ -79497,0 +83130,10 @@\n+\/* Convert a floating point value to its closest integer.  Do so in\n+** a way that avoids 'outside the range of representable values' warnings\n+** from UBSAN.\n+*\/\n+SQLITE_PRIVATE i64 sqlite3RealToI64(double r){\n+  if( r<-9223372036854774784.0 ) return SMALLEST_INT64;\n+  if( r>+9223372036854774784.0 ) return LARGEST_INT64;\n+  return (i64)r;\n+}\n+\n@@ -79518,1 +83161,1 @@\n-     || sqlite3RealSameAsInt(pMem->u.r, (ix = (i64)pMem->u.r))\n+     || sqlite3RealSameAsInt(pMem->u.r, (ix = sqlite3RealToI64(pMem->u.r)))\n@@ -79564,0 +83207,1 @@\n+      int rc;\n@@ -79570,1 +83214,4 @@\n-      return sqlite3VdbeChangeEncoding(pMem, encoding);\n+      if( encoding!=SQLITE_UTF8 ) pMem->n &= ~1;\n+      rc = sqlite3VdbeChangeEncoding(pMem, encoding);\n+      if( rc ) return rc;\n+      sqlite3VdbeMemZeroTerminateIfAble(pMem);\n@@ -80094,0 +83741,18 @@\n+\/* Return true if sqlit3_value object pVal is a string or blob value\n+** that uses the destructor specified in the second argument.\n+**\n+** TODO:  Maybe someday promote this interface into a published API so\n+** that third-party extensions can get access to it?\n+*\/\n+SQLITE_PRIVATE int sqlite3ValueIsOfClass(const sqlite3_value *pVal, void(*xFree)(void*)){\n+  if( ALWAYS(pVal!=0)\n+   && ALWAYS((pVal->flags & (MEM_Str|MEM_Blob))!=0)\n+   && (pVal->flags & MEM_Dyn)!=0\n+   && pVal->xDel==xFree\n+  ){\n+    return 1;\n+  }else{\n+    return 0;\n+  }\n+}\n+\n@@ -80161,0 +83826,1 @@\n+    sqlite3VdbeMemSetNull(&pRec->aMem[p->iVal]);\n@@ -80214,0 +83880,3 @@\n+#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION\n+  if( pFunc==0 ) return SQLITE_OK;\n+#endif\n@@ -80216,1 +83885,1 @@\n-   || (pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL)\n+   || (pFunc->funcFlags & (SQLITE_FUNC_NEEDCOLL|SQLITE_FUNC_RUNONLY))!=0\n@@ -80239,2 +83908,0 @@\n-  testcase( pCtx->pParse->rc==SQLITE_ERROR );\n-  testcase( pCtx->pParse->rc==SQLITE_OK );\n@@ -80253,1 +83920,1 @@\n-    if( rc==SQLITE_OK && sqlite3VdbeMemTooBig(pVal) ){\n+    if( NEVER(rc==SQLITE_OK && sqlite3VdbeMemTooBig(pVal)) ){\n@@ -80258,1 +83925,0 @@\n-  pCtx->pParse->rc = rc;\n@@ -80263,0 +83929,1 @@\n+    pCtx->pParse->rc = rc;\n@@ -80320,0 +83987,7 @@\n+#ifdef SQLITE_ENABLE_STAT4\n+      rc = ExpandBlob(*ppVal);\n+#else\n+      \/* zero-blobs only come from functions, not literal values.  And\n+      ** functions are only processed under STAT4 *\/\n+      assert( (ppVal[0][0].flags & MEM_Zero)==0 );\n+#endif\n@@ -80412,0 +84086,1 @@\n+      sqlite3ValueApplyAffinity(pVal, affinity, enc);\n@@ -80705,0 +84380,3 @@\n+  if( (p->flags & MEM_Str)!=0 && enc!=SQLITE_UTF8 && pVal->enc!=SQLITE_UTF8 ){\n+    return p->n;\n+  }\n@@ -80750,1 +84428,1 @@\n-    db->pVdbe->pPrev = p;\n+    db->pVdbe->ppVPrev = &p->pVNext;\n@@ -80752,2 +84430,2 @@\n-  p->pNext = db->pVdbe;\n-  p->pPrev = 0;\n+  p->pVNext = db->pVdbe;\n+  p->ppVPrev = &db->pVdbe;\n@@ -80835,1 +84513,8 @@\n-** Swap all content between two VDBE structures.\n+** Swap byte-code between two VDBE structures.\n+**\n+** This happens after pB was previously run and returned\n+** SQLITE_SCHEMA.  The statement was then reprepared in pA.\n+** This routine transfers the new bytecode in pA over to pB\n+** so that pB can be run again.  The old pB byte code is\n+** moved back to pA so that it will be cleaned up when pA is\n+** finalized.\n@@ -80838,1 +84523,1 @@\n-  Vdbe tmp, *pTmp;\n+  Vdbe tmp, *pTmp, **ppTmp;\n@@ -80844,6 +84529,6 @@\n-  pTmp = pA->pNext;\n-  pA->pNext = pB->pNext;\n-  pB->pNext = pTmp;\n-  pTmp = pA->pPrev;\n-  pA->pPrev = pB->pPrev;\n-  pB->pPrev = pTmp;\n+  pTmp = pA->pVNext;\n+  pA->pVNext = pB->pVNext;\n+  pB->pVNext = pTmp;\n+  ppTmp = pA->ppVPrev;\n+  pA->ppVPrev = pB->ppVPrev;\n+  pB->ppVPrev = ppTmp;\n@@ -80924,1 +84609,3 @@\n-  static int n = 0;\n+  static u64 n = 0;\n+  (void)pc;\n+  (void)pOp;\n@@ -80926,0 +84613,1 @@\n+  if( n==LARGEST_UINT64 ) abort(); \/* so that n is used, preventing a warning *\/\n@@ -80929,0 +84617,29 @@\n+\/*\n+** Slow paths for sqlite3VdbeAddOp3() and sqlite3VdbeAddOp4Int() for the\n+** unusual case when we need to increase the size of the Vdbe.aOp[] array\n+** before adding the new opcode.\n+*\/\n+static SQLITE_NOINLINE int growOp3(Vdbe *p, int op, int p1, int p2, int p3){\n+  assert( p->nOpAlloc<=p->nOp );\n+  if( growOpArray(p, 1) ) return 1;\n+  assert( p->nOpAlloc>p->nOp );\n+  return sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n+}\n+static SQLITE_NOINLINE int addOp4IntSlow(\n+  Vdbe *p,            \/* Add the opcode to this VM *\/\n+  int op,             \/* The new opcode *\/\n+  int p1,             \/* The P1 operand *\/\n+  int p2,             \/* The P2 operand *\/\n+  int p3,             \/* The P3 operand *\/\n+  int p4              \/* The P4 operand as an integer *\/\n+){\n+  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n+  if( p->db->mallocFailed==0 ){\n+    VdbeOp *pOp = &p->aOp[addr];\n+    pOp->p4type = P4_INT32;\n+    pOp->p4.i = p4;\n+  }\n+  return addr;\n+}\n+\n+\n@@ -80939,5 +84656,1 @@\n-**    p1, p2, p3      Operands\n-**\n-** Use the sqlite3VdbeResolveLabel() function to fix an address and\n-** the sqlite3VdbeChangeP4() function to change the value of the P4\n-** operand.\n+**    p1, p2, p3, p4  Operands\n@@ -80945,5 +84658,8 @@\n-static SQLITE_NOINLINE int growOp3(Vdbe *p, int op, int p1, int p2, int p3){\n-  assert( p->nOpAlloc<=p->nOp );\n-  if( growOpArray(p, 1) ) return 1;\n-  assert( p->nOpAlloc>p->nOp );\n-  return sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n+SQLITE_PRIVATE int sqlite3VdbeAddOp0(Vdbe *p, int op){\n+  return sqlite3VdbeAddOp3(p, op, 0, 0, 0);\n+}\n+SQLITE_PRIVATE int sqlite3VdbeAddOp1(Vdbe *p, int op, int p1){\n+  return sqlite3VdbeAddOp3(p, op, p1, 0, 0);\n+}\n+SQLITE_PRIVATE int sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){\n+  return sqlite3VdbeAddOp3(p, op, p1, p2, 0);\n@@ -80972,0 +84688,3 @@\n+\n+  \/* Replicate this logic in sqlite3VdbeAddOp4Int()\n+  ** vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv   *\/\n@@ -80975,0 +84694,4 @@\n+#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || defined(VDBE_PROFILE)\n+  pOp->nExec = 0;\n+  pOp->nCycle = 0;\n+#endif\n@@ -80981,4 +84704,0 @@\n-#ifdef VDBE_PROFILE\n-  pOp->cycles = 0;\n-  pOp->cnt = 0;\n-#endif\n@@ -80988,0 +84707,3 @@\n+  \/* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  ** Replicate in sqlite3VdbeAddOp4Int() *\/\n+\n@@ -80990,8 +84712,48 @@\n-SQLITE_PRIVATE int sqlite3VdbeAddOp0(Vdbe *p, int op){\n-  return sqlite3VdbeAddOp3(p, op, 0, 0, 0);\n-}\n-SQLITE_PRIVATE int sqlite3VdbeAddOp1(Vdbe *p, int op, int p1){\n-  return sqlite3VdbeAddOp3(p, op, p1, 0, 0);\n-}\n-SQLITE_PRIVATE int sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){\n-  return sqlite3VdbeAddOp3(p, op, p1, p2, 0);\n+SQLITE_PRIVATE int sqlite3VdbeAddOp4Int(\n+  Vdbe *p,            \/* Add the opcode to this VM *\/\n+  int op,             \/* The new opcode *\/\n+  int p1,             \/* The P1 operand *\/\n+  int p2,             \/* The P2 operand *\/\n+  int p3,             \/* The P3 operand *\/\n+  int p4              \/* The P4 operand as an integer *\/\n+){\n+  int i;\n+  VdbeOp *pOp;\n+\n+  i = p->nOp;\n+  if( p->nOpAlloc<=i ){\n+    return addOp4IntSlow(p, op, p1, p2, p3, p4);\n+  }\n+  p->nOp++;\n+  pOp = &p->aOp[i];\n+  assert( pOp!=0 );\n+  pOp->opcode = (u8)op;\n+  pOp->p5 = 0;\n+  pOp->p1 = p1;\n+  pOp->p2 = p2;\n+  pOp->p3 = p3;\n+  pOp->p4.i = p4;\n+  pOp->p4type = P4_INT32;\n+\n+  \/* Replicate this logic in sqlite3VdbeAddOp3()\n+  ** vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv   *\/\n+#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n+  pOp->zComment = 0;\n+#endif\n+#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || defined(VDBE_PROFILE)\n+  pOp->nExec = 0;\n+  pOp->nCycle = 0;\n+#endif\n+#ifdef SQLITE_DEBUG\n+  if( p->db->flags & SQLITE_VdbeAddopTrace ){\n+    sqlite3VdbePrintOp(0, i, &p->aOp[i]);\n+    test_addop_breakpoint(i, &p->aOp[i]);\n+  }\n+#endif\n+#ifdef SQLITE_VDBE_COVERAGE\n+  pOp->iSrcLine = 0;\n+#endif\n+  \/* ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+  ** Replicate in sqlite3VdbeAddOp3() *\/\n+\n+  return i;\n@@ -81152,2 +84914,3 @@\n-SQLITE_PRIVATE void sqlite3VdbeExplain(Parse *pParse, u8 bPush, const char *zFmt, ...){\n-#ifndef SQLITE_DEBUG\n+SQLITE_PRIVATE int sqlite3VdbeExplain(Parse *pParse, u8 bPush, const char *zFmt, ...){\n+  int addr = 0;\n+#if !defined(SQLITE_DEBUG)\n@@ -81156,1 +84919,1 @@\n-  if( pParse->explain==2 )\n+  if( pParse->explain==2 || IS_STMT_SCANSTATUS(pParse->db) )\n@@ -81168,1 +84931,1 @@\n-    sqlite3VdbeAddOp4(v, OP_Explain, iThis, pParse->addrExplain, 0,\n+    addr = sqlite3VdbeAddOp4(v, OP_Explain, iThis, pParse->addrExplain, 0,\n@@ -81170,1 +84933,1 @@\n-    sqlite3ExplainBreakpoint(bPush?\"PUSH\":\"\", sqlite3VdbeGetOp(v,-1)->p4.z);\n+    sqlite3ExplainBreakpoint(bPush?\"PUSH\":\"\", sqlite3VdbeGetLastOp(v)->p4.z);\n@@ -81174,0 +84937,1 @@\n+    sqlite3VdbeScanStatus(v, iThis, -1, -1, 0, 0);\n@@ -81175,0 +84939,1 @@\n+  return addr;\n@@ -81202,20 +84967,0 @@\n-\/*\n-** Add an opcode that includes the p4 value as an integer.\n-*\/\n-SQLITE_PRIVATE int sqlite3VdbeAddOp4Int(\n-  Vdbe *p,            \/* Add the opcode to this VM *\/\n-  int op,             \/* The new opcode *\/\n-  int p1,             \/* The P1 operand *\/\n-  int p2,             \/* The P2 operand *\/\n-  int p3,             \/* The P3 operand *\/\n-  int p4              \/* The P4 operand as an integer *\/\n-){\n-  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n-  if( p->db->mallocFailed==0 ){\n-    VdbeOp *pOp = &p->aOp[addr];\n-    pOp->p4type = P4_INT32;\n-    pOp->p4.i = p4;\n-  }\n-  return addr;\n-}\n-\n@@ -81282,0 +85027,3 @@\n+    if( nNewSize>=100 && (nNewSize\/100)>(p->nLabelAlloc\/100) ){\n+      sqlite3ProgressCheck(p);\n+    }\n@@ -81525,0 +85273,2 @@\n+\n+  assert( pParse->db->mallocFailed==0 ); \/* tag-20230419-1 *\/\n@@ -81528,2 +85278,2 @@\n-  while(1){\n-\n+  assert( p->aOp[0].opcode==OP_Init );\n+  while( 1 \/* Loop terminates when it reaches the OP_Init opcode *\/ ){\n@@ -81558,0 +85308,4 @@\n+        case OP_Init: {\n+          assert( pOp->p2>=0 );\n+          goto resolve_p2_values_loop_exit;\n+        }\n@@ -81580,0 +85334,1 @@\n+            assert( aLabel!=0 );  \/* True because of tag-20230419-1 *\/\n@@ -81590,1 +85345,1 @@\n-    if( pOp==p->aOp ) break;\n+    assert( pOp>p->aOp );\n@@ -81593,0 +85348,1 @@\n+resolve_p2_values_loop_exit:\n@@ -81594,1 +85350,1 @@\n-    sqlite3DbFreeNN(p->db, pParse->aLabel);\n+    sqlite3DbNNFreeNN(p->db, pParse->aLabel);\n@@ -81645,0 +85401,4 @@\n+      if( pOp->p3==20230325 && pOp->opcode==OP_NotNull ){\n+        \/* This is a deliberately taken illegal branch.  tag-20230325-2 *\/\n+        continue;\n+      }\n@@ -81822,11 +85582,14 @@\n-  sqlite3_int64 nByte = (p->nScan+1) * sizeof(ScanStatus);\n-  ScanStatus *aNew;\n-  aNew = (ScanStatus*)sqlite3DbRealloc(p->db, p->aScan, nByte);\n-  if( aNew ){\n-    ScanStatus *pNew = &aNew[p->nScan++];\n-    pNew->addrExplain = addrExplain;\n-    pNew->addrLoop = addrLoop;\n-    pNew->addrVisit = addrVisit;\n-    pNew->nEst = nEst;\n-    pNew->zName = sqlite3DbStrDup(p->db, zName);\n-    p->aScan = aNew;\n+  if( IS_STMT_SCANSTATUS(p->db) ){\n+    sqlite3_int64 nByte = (p->nScan+1) * sizeof(ScanStatus);\n+    ScanStatus *aNew;\n+    aNew = (ScanStatus*)sqlite3DbRealloc(p->db, p->aScan, nByte);\n+    if( aNew ){\n+      ScanStatus *pNew = &aNew[p->nScan++];\n+      memset(pNew, 0, sizeof(ScanStatus));\n+      pNew->addrExplain = addrExplain;\n+      pNew->addrLoop = addrLoop;\n+      pNew->addrVisit = addrVisit;\n+      pNew->nEst = nEst;\n+      pNew->zName = sqlite3DbStrDup(p->db, zName);\n+      p->aScan = aNew;\n+    }\n@@ -81835,1 +85598,61 @@\n-#endif\n+\n+\/*\n+** Add the range of instructions from addrStart to addrEnd (inclusive) to\n+** the set of those corresponding to the sqlite3_stmt_scanstatus() counters\n+** associated with the OP_Explain instruction at addrExplain. The\n+** sum of the sqlite3Hwtime() values for each of these instructions\n+** will be returned for SQLITE_SCANSTAT_NCYCLE requests.\n+*\/\n+SQLITE_PRIVATE void sqlite3VdbeScanStatusRange(\n+  Vdbe *p,\n+  int addrExplain,\n+  int addrStart,\n+  int addrEnd\n+){\n+  if( IS_STMT_SCANSTATUS(p->db) ){\n+    ScanStatus *pScan = 0;\n+    int ii;\n+    for(ii=p->nScan-1; ii>=0; ii--){\n+      pScan = &p->aScan[ii];\n+      if( pScan->addrExplain==addrExplain ) break;\n+      pScan = 0;\n+    }\n+    if( pScan ){\n+      if( addrEnd<0 ) addrEnd = sqlite3VdbeCurrentAddr(p)-1;\n+      for(ii=0; ii<ArraySize(pScan->aAddrRange); ii+=2){\n+        if( pScan->aAddrRange[ii]==0 ){\n+          pScan->aAddrRange[ii] = addrStart;\n+          pScan->aAddrRange[ii+1] = addrEnd;\n+          break;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+\/*\n+** Set the addresses for the SQLITE_SCANSTAT_NLOOP and SQLITE_SCANSTAT_NROW\n+** counters for the query element associated with the OP_Explain at\n+** addrExplain.\n+*\/\n+SQLITE_PRIVATE void sqlite3VdbeScanStatusCounters(\n+  Vdbe *p,\n+  int addrExplain,\n+  int addrLoop,\n+  int addrVisit\n+){\n+  if( IS_STMT_SCANSTATUS(p->db) ){\n+    ScanStatus *pScan = 0;\n+    int ii;\n+    for(ii=p->nScan-1; ii>=0; ii--){\n+      pScan = &p->aScan[ii];\n+      if( pScan->addrExplain==addrExplain ) break;\n+      pScan = 0;\n+    }\n+    if( pScan ){\n+      if( addrLoop>0 ) pScan->addrLoop = addrLoop;\n+      if( addrVisit>0 ) pScan->addrVisit = addrVisit;\n+    }\n+  }\n+}\n+#endif \/* defined(SQLITE_ENABLE_STMT_SCANSTATUS) *\/\n@@ -81843,0 +85666,1 @@\n+  assert( addr>=0 );\n@@ -81846,0 +85670,1 @@\n+  assert( addr>=0 );\n@@ -81849,0 +85674,1 @@\n+  assert( addr>=0 || p->db->mallocFailed );\n@@ -81852,0 +85678,1 @@\n+  assert( addr>=0 );\n@@ -81859,0 +85686,12 @@\n+\/*\n+** If the previous opcode is an OP_Column that delivers results\n+** into register iDest, then add the OPFLAG_TYPEOFARG flag to that\n+** opcode.\n+*\/\n+SQLITE_PRIVATE void sqlite3VdbeTypeofColumn(Vdbe *p, int iDest){\n+  VdbeOp *pOp = sqlite3VdbeGetLastOp(p);\n+  if( pOp->p3==iDest && pOp->opcode==OP_Column ){\n+    pOp->p5 |= OPFLAG_TYPEOFARG;\n+  }\n+}\n+\n@@ -81887,1 +85726,1 @@\n-    sqlite3VdbeGetOp(p,-1)->iSrcLine = 0;  \/* Erase VdbeCoverage() macros *\/\n+    sqlite3VdbeGetLastOp(p)->iSrcLine = 0;  \/* Erase VdbeCoverage() macros *\/\n@@ -81898,1 +85737,1 @@\n-** the FuncDef is not ephermal, then do nothing.\n+** the FuncDef is not ephemeral, then do nothing.\n@@ -81901,0 +85740,1 @@\n+  assert( db!=0 );\n@@ -81902,1 +85742,1 @@\n-    sqlite3DbFreeNN(db, pDef);\n+    sqlite3DbNNFreeNN(db, pDef);\n@@ -81911,1 +85751,1 @@\n-  sqlite3DbFreeNN(db, p);\n+  sqlite3DbNNFreeNN(db, p);\n@@ -81914,0 +85754,1 @@\n+  assert( db!=0 );\n@@ -81915,1 +85756,1 @@\n-  sqlite3DbFreeNN(db, p);\n+  sqlite3DbNNFreeNN(db, p);\n@@ -81928,1 +85769,1 @@\n-      sqlite3DbFree(db, p4);\n+      if( p4 ) sqlite3DbNNFreeNN(db, p4);\n@@ -81957,0 +85798,4 @@\n+    case P4_TABLEREF: {\n+      if( db->pnBytesFreed==0 ) sqlite3DeleteTable(db, (Table*)p4);\n+      break;\n+    }\n@@ -81967,0 +85812,1 @@\n+  assert( db!=0 );\n@@ -81977,1 +85823,1 @@\n-    sqlite3DbFreeNN(db, aOp);\n+    sqlite3DbNNFreeNN(db, aOp);\n@@ -82059,1 +85905,0 @@\n-\n@@ -82084,1 +85929,1 @@\n-    freeP4(p->db, pOp->p4type, pOp->p4.p);\n+    assert( pOp->p4type > P4_FREE_IF_LE );\n@@ -82146,1 +85991,1 @@\n-    assert( pP4!=0 );\n+    assert( pP4!=0 || n==P4_DYNAMIC );\n@@ -82208,1 +86053,1 @@\n-  sqlite3VdbeGetOp(v,-1)->iSrcLine = iLine;\n+  sqlite3VdbeGetLastOp(v)->iSrcLine = iLine;\n@@ -82213,2 +86058,2 @@\n-** Return the opcode for a given address.  If the address is -1, then\n-** return the most recently inserted opcode.\n+** Return the opcode for a given address.  The address must be non-negative.\n+** See sqlite3VdbeGetLastOp() to get the most recently added opcode.\n@@ -82230,3 +86075,0 @@\n-  if( addr<0 ){\n-    addr = p->nOp - 1;\n-  }\n@@ -82241,0 +86083,6 @@\n+\/* Return the most recently added opcode\n+*\/\n+SQLITE_PRIVATE VdbeOp *sqlite3VdbeGetLastOp(Vdbe *p){\n+  return sqlite3VdbeGetOp(p, p->nOp - 1);\n+}\n+\n@@ -82728,1 +86576,1 @@\n-        sqlite3DbFreeNN(db, p->zMalloc);\n+        sqlite3DbNNFreeNN(db, p->zMalloc);\n@@ -82942,1 +86790,0 @@\n-  p->pResultSet = 0;\n@@ -82978,1 +86825,1 @@\n-        p->nResColumn = 4;\n+        assert( p->nResColumn==4 );\n@@ -82997,1 +86844,1 @@\n-        p->nResColumn = 8;\n+        assert( p->nResColumn==8 );\n@@ -82999,1 +86846,1 @@\n-      p->pResultSet = pMem;\n+      p->pResultRow = pMem;\n@@ -83110,1 +86957,1 @@\n-#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)\n+#if defined(SQLITE_DEBUG)\n@@ -83139,2 +86986,2 @@\n-    p->aOp[i].cnt = 0;\n-    p->aOp[i].cycles = 0;\n+    p->aOp[i].nExec = 0;\n+    p->aOp[i].nCycle = 0;\n@@ -83211,5 +87058,0 @@\n-    static const char * const azColName[] = {\n-       \"addr\", \"opcode\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"comment\",\n-       \"id\", \"parent\", \"notused\", \"detail\"\n-    };\n-    int iFirst, mx, i;\n@@ -83218,13 +87060,1 @@\n-    if( pParse->explain==2 ){\n-      sqlite3VdbeSetNumCols(p, 4);\n-      iFirst = 8;\n-      mx = 12;\n-    }else{\n-      sqlite3VdbeSetNumCols(p, 8);\n-      iFirst = 0;\n-      mx = 8;\n-    }\n-    for(i=iFirst; i<mx; i++){\n-      sqlite3VdbeSetColName(p, i-iFirst, COLNAME_NAME,\n-                            azColName[i], SQLITE_STATIC);\n-    }\n+    p->nResColumn = 12 - 4*p->explain;\n@@ -83249,3 +87079,0 @@\n-#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n-  p->anExec = allocSpace(&x, 0, p->nOp*sizeof(i64));\n-#endif\n@@ -83260,3 +87087,0 @@\n-#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n-      p->anExec = allocSpace(&x, p->anExec, p->nOp*sizeof(i64));\n-#endif\n@@ -83277,3 +87101,0 @@\n-#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n-    memset(p->anExec, 0, p->nOp*sizeof(i64));\n-#endif\n@@ -83291,0 +87112,12 @@\n+static SQLITE_NOINLINE void freeCursorWithCache(Vdbe *p, VdbeCursor *pCx){\n+  VdbeTxtBlbCache *pCache = pCx->pCache;\n+  assert( pCx->colCache );\n+  pCx->colCache = 0;\n+  pCx->pCache = 0;\n+  if( pCache->pCValue ){\n+    sqlite3RCStrUnref(pCache->pCValue);\n+    pCache->pCValue = 0;\n+  }\n+  sqlite3DbFree(p->db, pCache);\n+  sqlite3VdbeFreeCursorNN(p, pCx);\n+}\n@@ -83292,0 +87125,4 @@\n+  if( pCx->colCache ){\n+    freeCursorWithCache(p, pCx);\n+    return;\n+  }\n@@ -83337,3 +87174,0 @@\n-#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n-  v->anExec = pFrame->anExec;\n-#endif\n@@ -83395,2 +87229,2 @@\n-  if( p->nResColumn ){\n-    releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);\n+  if( p->nResAlloc ){\n+    releaseMemArray(p->aColName, p->nResAlloc*COLNAME_N);\n@@ -83400,1 +87234,1 @@\n-  p->nResColumn = (u16)nResColumn;\n+  p->nResColumn = p->nResAlloc = (u16)nResColumn;\n@@ -83425,1 +87259,1 @@\n-  assert( idx<p->nResColumn );\n+  assert( idx<p->nResAlloc );\n@@ -83432,1 +87266,1 @@\n-  pColName = &(p->aColName[idx+var*p->nResColumn]);\n+  pColName = &(p->aColName[idx+var*p->nResAlloc]);\n@@ -83720,1 +87554,1 @@\n-    p = p->pNext;\n+    p = p->pVNext;\n@@ -83945,0 +87779,1 @@\n+          sqlite3SystemError(db, rc);\n@@ -83954,0 +87789,2 @@\n+      }else if( p->rc==SQLITE_SCHEMA && db->nVdbeActive>1 ){\n+        p->nChange = 0;\n@@ -84143,1 +87980,1 @@\n-  p->pResultSet = 0;\n+  p->pResultRow = 0;\n@@ -84171,0 +88008,2 @@\n+        i64 cnt = p->aOp[i].nExec;\n+        i64 cycles = p->aOp[i].nCycle;\n@@ -84172,3 +88011,3 @@\n-           p->aOp[i].cnt,\n-           p->aOp[i].cycles,\n-           p->aOp[i].cnt>0 ? p->aOp[i].cycles\/p->aOp[i].cnt : 0\n+           cnt,\n+           cycles,\n+           cnt>0 ? cycles\/cnt : 0\n@@ -84249,0 +88088,1 @@\n+  assert( db!=0 );\n@@ -84251,2 +88091,2 @@\n-    releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);\n-    sqlite3DbFreeNN(db, p->aColName);\n+    releaseMemArray(p->aColName, p->nResAlloc*COLNAME_N);\n+    sqlite3DbNNFreeNN(db, p->aColName);\n@@ -84261,2 +88101,2 @@\n-    if( p->pVList ) sqlite3DbFreeNN(db, p->pVList);\n-    if( p->pFree ) sqlite3DbFreeNN(db, p->pFree);\n+    if( p->pVList ) sqlite3DbNNFreeNN(db, p->pVList);\n+    if( p->pFree ) sqlite3DbNNFreeNN(db, p->pFree);\n@@ -84265,1 +88105,1 @@\n-  sqlite3DbFree(db, p->zSql);\n+  if( p->zSql ) sqlite3DbNNFreeNN(db, p->zSql);\n@@ -84269,3 +88109,3 @@\n-    DblquoteStr *pThis, *pNext;\n-    for(pThis=p->pDblStr; pThis; pThis=pNext){\n-      pNext = pThis->pNextStr;\n+    DblquoteStr *pThis, *pNxt;\n+    for(pThis=p->pDblStr; pThis; pThis=pNxt){\n+      pNxt = pThis->pNextStr;\n@@ -84295,0 +88135,1 @@\n+  assert( db!=0 );\n@@ -84298,8 +88139,4 @@\n-    if( p->pPrev ){\n-      p->pPrev->pNext = p->pNext;\n-    }else{\n-      assert( db->pVdbe==p );\n-      db->pVdbe = p->pNext;\n-    }\n-    if( p->pNext ){\n-      p->pNext->pPrev = p->pPrev;\n+    assert( p->ppVPrev!=0 );\n+    *p->ppVPrev = p->pVNext;\n+    if( p->pVNext ){\n+      p->pVNext->ppVPrev = p->ppVPrev;\n@@ -84308,1 +88145,1 @@\n-  sqlite3DbFreeNN(db, p);\n+  sqlite3DbNNFreeNN(db, p);\n@@ -84621,0 +88458,17 @@\n+static int serialGet7(\n+  const unsigned char *buf,     \/* Buffer to deserialize from *\/\n+  Mem *pMem                     \/* Memory cell to write value into *\/\n+){\n+  u64 x = FOUR_BYTE_UINT(buf);\n+  u32 y = FOUR_BYTE_UINT(buf+4);\n+  x = (x<<32) + y;\n+  assert( sizeof(x)==8 && sizeof(pMem->u.r)==8 );\n+  swapMixedEndianFloat(x);\n+  memcpy(&pMem->u.r, &x, sizeof(x));\n+  if( IsNaN(x) ){\n+    pMem->flags = MEM_Null;\n+    return 1;\n+  }\n+  pMem->flags = MEM_Real;\n+  return 0;\n+}\n@@ -84854,0 +88708,9 @@\n+      if( serial_type1>=1\n+       && serial_type1<=7\n+       && d1+(u64)sqlite3VdbeSerialTypeLen(serial_type1)<=(u64)nKey1+8\n+       && CORRUPT_DB\n+      ){\n+        return 1;  \/* corrupt record not detected by\n+                   ** sqlite3VdbeRecordCompareWithSkip().  Return true\n+                   ** to avoid firing the assert() *\/\n+      }\n@@ -85022,0 +88885,10 @@\n+\/* The following two functions are used only within testcase() to prove\n+** test coverage.  These functions do no exist for production builds.\n+** We must use separate SQLITE_NOINLINE functions here, since otherwise\n+** optimizer code movement causes gcov to become very confused.\n+*\/\n+#if  defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_DEBUG)\n+static int SQLITE_NOINLINE doubleLt(double a, double b){ return a<b; }\n+static int SQLITE_NOINLINE doubleEq(double a, double b){ return a==b; }\n+#endif\n+\n@@ -85028,1 +88901,6 @@\n-  if( sizeof(LONGDOUBLE_TYPE)>8 ){\n+  if( sqlite3IsNaN(r) ){\n+    \/* SQLite considers NaN to be a NULL. And all integer values are greater\n+    ** than NULL *\/\n+    return 1;\n+  }\n+  if( sqlite3Config.bUseLongDouble ){\n@@ -85033,3 +88911,1 @@\n-    if( x<r ) return -1;\n-    if( x>r ) return +1;  \/*NO_TEST*\/ \/* work around bugs in gcov *\/\n-    return 0;             \/*NO_TEST*\/ \/* work around bugs in gcov *\/\n+    return (x<r) ? -1 : (x>r);\n@@ -85045,3 +88921,4 @@\n-    if( s<r ) return -1;\n-    if( s>r ) return +1;\n-    return 0;\n+    testcase( doubleLt(s,r) );\n+    testcase( doubleLt(r,s) );\n+    testcase( doubleEq(r,s) );\n+    return (s<r) ? -1 : (s>r);\n@@ -85263,1 +89140,1 @@\n-  do{\n+  while( 1 \/*exit-by-break*\/ ){\n@@ -85273,1 +89150,1 @@\n-        rc = +1;\n+        rc = serial_type==10 ? -1 : +1;\n@@ -85277,1 +89154,1 @@\n-        sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);\n+        serialGet7(&aKey1[d1], &mem1);\n@@ -85297,2 +89174,2 @@\n-        ** them to numberic values are.  *\/\n-        rc = +1;\n+        ** them to numeric values are.  *\/\n+        rc = serial_type==10 ? -1 : +1;\n@@ -85302,1 +89179,0 @@\n-        sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);\n@@ -85304,1 +89180,3 @@\n-          if( mem1.u.r<pRhs->u.r ){\n+          if( serialGet7(&aKey1[d1], &mem1) ){\n+            rc = -1;  \/* mem1 is a NaN *\/\n+          }else if( mem1.u.r<pRhs->u.r ){\n@@ -85308,0 +89186,2 @@\n+          }else{\n+            assert( rc==0 );\n@@ -85310,0 +89190,1 @@\n+          sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);\n@@ -85379,1 +89260,8 @@\n-      rc = (serial_type!=0);\n+      if( serial_type==0\n+       || serial_type==10\n+       || (serial_type==7 && serialGet7(&aKey1[d1], &mem1)!=0)\n+      ){\n+        assert( rc==0 );\n+      }else{\n+        rc = 1;\n+      }\n@@ -85401,0 +89289,1 @@\n+    if( d1>(unsigned)nKey1 ) break;\n@@ -85402,1 +89291,5 @@\n-  }while( idx1<(unsigned)szHdr1 && d1<=(unsigned)nKey1 );\n+    if( idx1>=(unsigned)szHdr1 ){\n+      pPKey2->errCode = (u8)SQLITE_CORRUPT_BKPT;\n+      return 0;  \/* Corrupt index *\/\n+    }\n+  }\n@@ -85803,1 +89696,1 @@\n-  for(p = db->pVdbe; p; p=p->pNext){\n+  for(p = db->pVdbe; p; p=p->pVNext){\n@@ -85896,0 +89789,14 @@\n+#if defined(SQLITE_ENABLE_CURSOR_HINTS) && defined(SQLITE_DEBUG)\n+\/*\n+** This Walker callback is used to help verify that calls to\n+** sqlite3BtreeCursorHint() with opcode BTREE_HINT_RANGE have\n+** byte-code register values correctly initialized.\n+*\/\n+SQLITE_PRIVATE int sqlite3CursorRangeHintExprCheck(Walker *pWalker, Expr *pExpr){\n+  if( pExpr->op==TK_REGISTER ){\n+    assert( (pWalker->u.aMem[pExpr->iTable].flags & MEM_Undefined)==0 );\n+  }\n+  return WRC_Continue;\n+}\n+#endif \/* SQLITE_ENABLE_CURSOR_HINTS && SQLITE_DEBUG *\/\n+\n@@ -85924,0 +89831,1 @@\n+  assert( db!=0 );\n@@ -85930,1 +89838,1 @@\n-    sqlite3DbFreeNN(db, p);\n+    sqlite3DbNNFreeNN(db, p);\n@@ -85957,0 +89865,10 @@\n+#ifdef SQLITE_DEBUG\n+  int nRealCol;\n+  if( pTab->tabFlags & TF_WithoutRowid ){\n+    nRealCol = sqlite3PrimaryKeyIndex(pTab)->nColumn;\n+  }else if( pTab->tabFlags & TF_HasVirtual ){\n+    nRealCol = pTab->nNVCol;\n+  }else{\n+    nRealCol = pTab->nCol;\n+  }\n+#endif\n@@ -85973,2 +89891,2 @@\n-  assert( pCsr->nField==pTab->nCol\n-       || (pCsr->nField==pTab->nCol+1 && op==SQLITE_DELETE && iReg==-1)\n+  assert( pCsr->nField==nRealCol\n+       || (pCsr->nField==nRealCol+1 && op==SQLITE_DELETE && iReg==-1)\n@@ -86001,1 +89919,1 @@\n-    sqlite3DbFreeNN(db, preupdate.aNew);\n+    sqlite3DbNNFreeNN(db, preupdate.aNew);\n@@ -86025,0 +89943,1 @@\n+\/* #include \"opcodes.h\" *\/\n@@ -86118,1 +90037,3 @@\n-    rc = sqlite3VdbeFinalize(v);\n+    assert( v->eVdbeState>=VDBE_READY_STATE );\n+    rc = sqlite3VdbeReset(v);\n+    sqlite3VdbeDelete(v);\n@@ -86159,1 +90080,9 @@\n-  sqlite3_mutex *mutex = ((Vdbe*)pStmt)->db->mutex;\n+  sqlite3_mutex *mutex;\n+#endif\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pStmt==0 ){\n+    return SQLITE_MISUSE_BKPT;\n+  }\n+#endif\n+#if SQLITE_THREADSAFE\n+  mutex = p->db->mutex;\n@@ -86278,1 +90207,1 @@\n-     SQLITE_TEXT,     \/* 0x22 INTREAL + TEXT *\/\n+     SQLITE_FLOAT,    \/* 0x22 INTREAL + TEXT *\/\n@@ -86326,0 +90255,3 @@\n+SQLITE_API int sqlite3_value_encoding(sqlite3_value *pVal){\n+  return pVal->enc;\n+}\n@@ -86379,1 +90311,1 @@\n-** on value P is not going to be used and need to be destroyed.\n+** on value P if P is not going to be used and need to be destroyed.\n@@ -86409,1 +90341,1 @@\n-  sqlite3_context *pCtx      \/* Set a SQLITE_TOOBIG error if no NULL *\/\n+  sqlite3_context *pCtx      \/* Set a SQLITE_TOOBIG error if not NULL *\/\n@@ -86419,0 +90351,6 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx!=0 ){\n+    sqlite3_result_error_toobig(pCtx);\n+  }\n+#else\n+  assert( pCtx!=0 );\n@@ -86420,0 +90358,1 @@\n+#endif\n@@ -86428,0 +90367,6 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 || n<0 ){\n+    invokeValueDestructor(z, xDel, pCtx);\n+    return;\n+  }\n+#endif\n@@ -86438,1 +90383,0 @@\n-  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n@@ -86440,0 +90384,7 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ){\n+    invokeValueDestructor(z, xDel, 0);\n+    return;\n+  }\n+#endif\n+  assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );\n@@ -86447,0 +90398,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ) return;\n+#endif\n@@ -86451,0 +90405,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ) return;\n+#endif\n@@ -86457,0 +90414,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ) return;\n+#endif\n@@ -86463,0 +90423,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ) return;\n+#endif\n@@ -86467,0 +90430,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ) return;\n+#endif\n@@ -86471,0 +90437,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ) return;\n+#endif\n@@ -86480,1 +90449,8 @@\n-  Mem *pOut = pCtx->pOut;\n+  Mem *pOut;\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ){\n+    invokeValueDestructor(pPtr, xDestructor, 0);\n+    return;\n+  }\n+#endif\n+  pOut = pCtx->pOut;\n@@ -86487,1 +90463,17 @@\n-  Mem *pOut = pCtx->pOut;\n+  Mem *pOut;\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ) return;\n+#endif\n+#if defined(SQLITE_STRICT_SUBTYPE) && SQLITE_STRICT_SUBTYPE+0!=0\n+  if( pCtx->pFunc!=0\n+   && (pCtx->pFunc->funcFlags & SQLITE_RESULT_SUBTYPE)==0\n+  ){\n+    char zErr[200];\n+    sqlite3_snprintf(sizeof(zErr), zErr,\n+                     \"misuse of sqlite3_result_subtype() by %s()\",\n+                     pCtx->pFunc->zName);\n+    sqlite3_result_error(pCtx, zErr, -1);\n+    return;\n+  }\n+#endif \/* SQLITE_STRICT_SUBTYPE *\/\n+  pOut = pCtx->pOut;\n@@ -86498,0 +90490,6 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ){\n+    invokeValueDestructor(z, xDel, 0);\n+    return;\n+  }\n+#endif\n@@ -86508,0 +90506,6 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ){\n+    invokeValueDestructor(z, xDel, 0);\n+    return;\n+  }\n+#endif\n@@ -86510,1 +90514,4 @@\n-  if( enc==SQLITE_UTF16 ) enc = SQLITE_UTF16NATIVE;\n+  if( enc!=SQLITE_UTF8 ){\n+    if( enc==SQLITE_UTF16 ) enc = SQLITE_UTF16NATIVE;\n+    n &= ~(u64)1;\n+  }\n@@ -86515,0 +90522,1 @@\n+    sqlite3VdbeMemZeroTerminateIfAble(pCtx->pOut);\n@@ -86525,1 +90533,1 @@\n-  setResultStrOrError(pCtx, z, n, SQLITE_UTF16NATIVE, xDel);\n+  setResultStrOrError(pCtx, z, n & ~(u64)1, SQLITE_UTF16NATIVE, xDel);\n@@ -86534,1 +90542,1 @@\n-  setResultStrOrError(pCtx, z, n, SQLITE_UTF16BE, xDel);\n+  setResultStrOrError(pCtx, z, n & ~(u64)1, SQLITE_UTF16BE, xDel);\n@@ -86543,1 +90551,1 @@\n-  setResultStrOrError(pCtx, z, n, SQLITE_UTF16LE, xDel);\n+  setResultStrOrError(pCtx, z, n & ~(u64)1, SQLITE_UTF16LE, xDel);\n@@ -86547,1 +90555,10 @@\n-  Mem *pOut = pCtx->pOut;\n+  Mem *pOut;\n+\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ) return;\n+  if( pValue==0 ){\n+    sqlite3_result_null(pCtx);\n+    return;\n+  }\n+#endif\n+  pOut = pCtx->pOut;\n@@ -86559,1 +90576,6 @@\n-  Mem *pOut = pCtx->pOut;\n+  Mem *pOut;\n+\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ) return SQLITE_MISUSE_BKPT;\n+#endif\n+  pOut = pCtx->pOut;\n@@ -86573,0 +90595,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ) return;\n+#endif\n@@ -86585,0 +90610,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ) return;\n+#endif\n@@ -86593,0 +90621,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ) return;\n+#endif\n@@ -86754,1 +90785,1 @@\n-\n+    p->pResultRow = 0;\n@@ -86845,0 +90876,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( p==0 ) return 0;\n+#endif\n@@ -86860,0 +90894,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( p==0 ) return 0;\n+#else\n@@ -86861,0 +90898,1 @@\n+#endif\n@@ -86879,0 +90917,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( p==0 ) return 0;\n+#else\n@@ -86880,0 +90921,1 @@\n+#endif\n@@ -86883,0 +90925,11 @@\n+\/*\n+** The destructor function for a ValueList object.  This needs to be\n+** a separate function, unknowable to the application, to ensure that\n+** calls to sqlite3_vtab_in_first()\/sqlite3_vtab_in_next() that are not\n+** preceded by activation of IN processing via sqlite3_vtab_int() do not\n+** try to access a fake ValueList object inserted by a hostile extension.\n+*\/\n+SQLITE_PRIVATE void sqlite3VdbeValueListFree(void *pToDelete){\n+  sqlite3_free(pToDelete);\n+}\n+\n@@ -86896,3 +90949,10 @@\n-  if( pVal==0 ) return SQLITE_MISUSE;\n-  pRhs = (ValueList*)sqlite3_value_pointer(pVal, \"ValueList\");\n-  if( pRhs==0 ) return SQLITE_MISUSE;\n+  if( pVal==0 ) return SQLITE_MISUSE_BKPT;\n+  if( (pVal->flags & MEM_Dyn)==0 || pVal->xDel!=sqlite3VdbeValueListFree ){\n+    return SQLITE_ERROR;\n+  }else{\n+    assert( (pVal->flags&(MEM_TypeMask|MEM_Term|MEM_Subtype)) ==\n+                 (MEM_Null|MEM_Term|MEM_Subtype) );\n+    assert( pVal->eSubtype=='p' );\n+    assert( pVal->u.zPType!=0 && strcmp(pVal->u.zPType,\"ValueList\")==0 );\n+    pRhs = (ValueList*)pVal->z;\n+  }\n@@ -87020,0 +91080,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ) return 0;\n+#endif\n@@ -87052,1 +91115,1 @@\n-  Vdbe *pVdbe = pCtx->pVdbe;\n+  Vdbe *pVdbe;\n@@ -87054,0 +91117,4 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pCtx==0 ) return;\n+#endif\n+  pVdbe= pCtx->pVdbe;\n@@ -87109,1 +91176,2 @@\n-  return pVm ? pVm->nResColumn : 0;\n+  if( pVm==0 ) return 0;\n+  return pVm->nResColumn;\n@@ -87118,1 +91186,1 @@\n-  if( pVm==0 || pVm->pResultSet==0 ) return 0;\n+  if( pVm==0 || pVm->pResultRow==0 ) return 0;\n@@ -87173,2 +91241,2 @@\n-  if( pVm->pResultSet!=0 && i<pVm->nResColumn && i>=0 ){\n-    pOut = &pVm->pResultSet[i];\n+  if( pVm->pResultRow!=0 && i<pVm->nResColumn && i>=0 ){\n+    pOut = &pVm->pResultRow[i];\n@@ -87198,1 +91266,1 @@\n-**     sqiite3_column_blob()\n+**     sqlite3_column_blob()\n@@ -87282,0 +91350,26 @@\n+\/*\n+** Column names appropriate for EXPLAIN or EXPLAIN QUERY PLAN.\n+*\/\n+static const char * const azExplainColNames8[] = {\n+   \"addr\", \"opcode\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"comment\",  \/* EXPLAIN *\/\n+   \"id\", \"parent\", \"notused\", \"detail\"                         \/* EQP *\/\n+};\n+static const u16 azExplainColNames16data[] = {\n+  \/*   0 *\/  'a', 'd', 'd', 'r',                0,\n+  \/*   5 *\/  'o', 'p', 'c', 'o', 'd', 'e',      0,\n+  \/*  12 *\/  'p', '1',                          0,\n+  \/*  15 *\/  'p', '2',                          0,\n+  \/*  18 *\/  'p', '3',                          0,\n+  \/*  21 *\/  'p', '4',                          0,\n+  \/*  24 *\/  'p', '5',                          0,\n+  \/*  27 *\/  'c', 'o', 'm', 'm', 'e', 'n', 't', 0,\n+  \/*  35 *\/  'i', 'd',                          0,\n+  \/*  38 *\/  'p', 'a', 'r', 'e', 'n', 't',      0,\n+  \/*  45 *\/  'n', 'o', 't', 'u', 's', 'e', 'd', 0,\n+  \/*  53 *\/  'd', 'e', 't', 'a', 'i', 'l',      0\n+};\n+static const u8 iExplainColNames16[] = {\n+  0, 5, 12, 15, 18, 21, 24, 27,\n+  35, 38, 45, 53\n+};\n+\n@@ -87314,0 +91408,1 @@\n+  if( N<0 ) return 0;\n@@ -87318,2 +91413,17 @@\n-  n = sqlite3_column_count(pStmt);\n-  if( N<n && N>=0 ){\n+  sqlite3_mutex_enter(db->mutex);\n+\n+  if( p->explain ){\n+    if( useType>0 ) goto columnName_end;\n+    n = p->explain==1 ? 8 : 4;\n+    if( N>=n ) goto columnName_end;\n+    if( useUtf16 ){\n+      int i = iExplainColNames16[N + 8*p->explain - 8];\n+      ret = (void*)&azExplainColNames16data[i];\n+    }else{\n+      ret = (void*)azExplainColNames8[N + 8*p->explain - 8];\n+    }\n+    goto columnName_end;\n+  }\n+  n = p->nResColumn;\n+  if( N<n ){\n+    u8 prior_mallocFailed = db->mallocFailed;\n@@ -87321,2 +91431,0 @@\n-    sqlite3_mutex_enter(db->mutex);\n-    assert( db->mallocFailed==0 );\n@@ -87334,1 +91442,2 @@\n-    if( db->mallocFailed ){\n+    assert( db->mallocFailed==0 || db->mallocFailed==1 );\n+    if( db->mallocFailed > prior_mallocFailed ){\n@@ -87338,1 +91447,0 @@\n-    sqlite3_mutex_leave(db->mutex);\n@@ -87340,0 +91448,2 @@\n+columnName_end:\n+  sqlite3_mutex_leave(db->mutex);\n@@ -87432,1 +91542,1 @@\n-** out of range, then SQLITE_RANGE is returned. Othewise SQLITE_OK.\n+** out of range, then SQLITE_RANGE is returned. Otherwise SQLITE_OK.\n@@ -87440,1 +91550,1 @@\n-static int vdbeUnbind(Vdbe *p, int i){\n+static int vdbeUnbind(Vdbe *p, unsigned int i){\n@@ -87447,1 +91557,1 @@\n-    sqlite3Error(p->db, SQLITE_MISUSE);\n+    sqlite3Error(p->db, SQLITE_MISUSE_BKPT);\n@@ -87453,1 +91563,1 @@\n-  if( i<1 || i>p->nVar ){\n+  if( i>=(unsigned int)p->nVar ){\n@@ -87458,1 +91568,0 @@\n-  i--;\n@@ -87495,1 +91604,1 @@\n-  rc = vdbeUnbind(p, i);\n+  rc = vdbeUnbind(p, (u32)(i-1));\n@@ -87544,1 +91653,1 @@\n-  rc = vdbeUnbind(p, i);\n+  rc = vdbeUnbind(p, (u32)(i-1));\n@@ -87557,1 +91666,1 @@\n-  rc = vdbeUnbind(p, i);\n+  rc = vdbeUnbind(p, (u32)(i-1));\n@@ -87567,1 +91676,1 @@\n-  rc = vdbeUnbind(p, i);\n+  rc = vdbeUnbind(p, (u32)(i-1));\n@@ -87582,1 +91691,1 @@\n-  rc = vdbeUnbind(p, i);\n+  rc = vdbeUnbind(p, (u32)(i-1));\n@@ -87609,1 +91718,4 @@\n-  if( enc==SQLITE_UTF16 ) enc = SQLITE_UTF16NATIVE;\n+  if( enc!=SQLITE_UTF8 ){\n+    if( enc==SQLITE_UTF16 ) enc = SQLITE_UTF16NATIVE;\n+    nData &= ~(u16)1;\n+  }\n@@ -87617,1 +91729,1 @@\n-  int nData,\n+  int n,\n@@ -87620,1 +91732,1 @@\n-  return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF16NATIVE);\n+  return bindText(pStmt, i, zData, n & ~(u64)1, xDel, SQLITE_UTF16NATIVE);\n@@ -87660,1 +91772,1 @@\n-  rc = vdbeUnbind(p, i);\n+  rc = vdbeUnbind(p, (u32)(i-1));\n@@ -87674,0 +91786,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( p==0 ) return SQLITE_MISUSE_BKPT;\n+#endif\n@@ -87794,0 +91909,36 @@\n+\/*\n+** Set the explain mode for a statement.\n+*\/\n+SQLITE_API int sqlite3_stmt_explain(sqlite3_stmt *pStmt, int eMode){\n+  Vdbe *v = (Vdbe*)pStmt;\n+  int rc;\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( pStmt==0 ) return SQLITE_MISUSE_BKPT;\n+#endif\n+  sqlite3_mutex_enter(v->db->mutex);\n+  if( ((int)v->explain)==eMode ){\n+    rc = SQLITE_OK;\n+  }else if( eMode<0 || eMode>2 ){\n+    rc = SQLITE_ERROR;\n+  }else if( (v->prepFlags & SQLITE_PREPARE_SAVESQL)==0 ){\n+    rc = SQLITE_ERROR;\n+  }else if( v->eVdbeState!=VDBE_READY_STATE ){\n+    rc = SQLITE_BUSY;\n+  }else if( v->nMem>=10 && (eMode!=2 || v->haveEqpOps) ){\n+    \/* No reprepare necessary *\/\n+    v->explain = eMode;\n+    rc = SQLITE_OK;\n+  }else{\n+    v->explain = eMode;\n+    rc = sqlite3Reprepare(v);\n+    v->haveEqpOps = eMode==2;\n+  }\n+  if( v->explain ){\n+    v->nResColumn = 12 - 4*v->explain;\n+  }else{\n+    v->nResColumn = v->nResAlloc;\n+  }\n+  sqlite3_mutex_leave(v->db->mutex);\n+  return rc;\n+}\n+\n@@ -87820,1 +91971,1 @@\n-    pNext = (sqlite3_stmt*)((Vdbe*)pStmt)->pNext;\n+    pNext = (sqlite3_stmt*)((Vdbe*)pStmt)->pVNext;\n@@ -87845,0 +91996,2 @@\n+    assert( db->lookaside.pEnd==db->lookaside.pTrueEnd );\n+    db->lookaside.pEnd = db->lookaside.pStart;\n@@ -87847,0 +92000,1 @@\n+    db->lookaside.pEnd = db->lookaside.pTrueEnd;\n@@ -87930,1 +92084,1 @@\n-  PreUpdate *p = db->pPreUpdate;\n+  PreUpdate *p;\n@@ -87934,0 +92088,6 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( db==0 || ppValue==0 ){\n+    return SQLITE_MISUSE_BKPT;\n+  }\n+#endif\n+  p = db->pPreUpdate;\n@@ -87994,1 +92154,6 @@\n-  PreUpdate *p = db->pPreUpdate;\n+  PreUpdate *p;\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  p = db!=0 ? db->pPreUpdate : 0;\n+#else\n+  p = db->pPreUpdate;\n+#endif\n@@ -88012,1 +92177,6 @@\n-  PreUpdate *p = db->pPreUpdate;\n+  PreUpdate *p;\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  p = db!=0 ? db->pPreUpdate : 0;\n+#else\n+  p = db->pPreUpdate;\n+#endif\n@@ -88023,1 +92193,6 @@\n-  PreUpdate *p = db->pPreUpdate;\n+  PreUpdate *p;\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  p = db!=0 ? db->pPreUpdate : 0;\n+#else\n+  p = db->pPreUpdate;\n+#endif\n@@ -88034,1 +92209,1 @@\n-  PreUpdate *p = db->pPreUpdate;\n+  PreUpdate *p;\n@@ -88038,0 +92213,6 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( db==0 || ppValue==0 ){\n+    return SQLITE_MISUSE_BKPT;\n+  }\n+#endif\n+  p = db->pPreUpdate;\n@@ -88108,1 +92289,1 @@\n-SQLITE_API int sqlite3_stmt_scanstatus(\n+SQLITE_API int sqlite3_stmt_scanstatus_v2(\n@@ -88110,1 +92291,1 @@\n-  int idx,                        \/* Index of loop to report on *\/\n+  int iScan,                      \/* Index of loop to report on *\/\n@@ -88112,0 +92293,1 @@\n+  int flags,\n@@ -88115,3 +92297,49 @@\n-  ScanStatus *pScan;\n-  if( idx<0 || idx>=p->nScan ) return 1;\n-  pScan = &p->aScan[idx];\n+  VdbeOp *aOp;\n+  int nOp;\n+  ScanStatus *pScan = 0;\n+  int idx;\n+\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( p==0 || pOut==0\n+      || iScanStatusOp<SQLITE_SCANSTAT_NLOOP\n+      || iScanStatusOp>SQLITE_SCANSTAT_NCYCLE ){\n+    return 1;\n+  }\n+#endif\n+  aOp = p->aOp;\n+  nOp = p->nOp;\n+  if( p->pFrame ){\n+    VdbeFrame *pFrame;\n+    for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);\n+    aOp = pFrame->aOp;\n+    nOp = pFrame->nOp;\n+  }\n+\n+  if( iScan<0 ){\n+    int ii;\n+    if( iScanStatusOp==SQLITE_SCANSTAT_NCYCLE ){\n+      i64 res = 0;\n+      for(ii=0; ii<nOp; ii++){\n+        res += aOp[ii].nCycle;\n+      }\n+      *(i64*)pOut = res;\n+      return 0;\n+    }\n+    return 1;\n+  }\n+  if( flags & SQLITE_SCANSTAT_COMPLEX ){\n+    idx = iScan;\n+    pScan = &p->aScan[idx];\n+  }else{\n+    \/* If the COMPLEX flag is clear, then this function must ignore any\n+    ** ScanStatus structures with ScanStatus.addrLoop set to 0. *\/\n+    for(idx=0; idx<p->nScan; idx++){\n+      pScan = &p->aScan[idx];\n+      if( pScan->zName ){\n+        iScan--;\n+        if( iScan<0 ) break;\n+      }\n+    }\n+  }\n+  if( idx>=p->nScan ) return 1;\n+\n@@ -88120,1 +92348,5 @@\n-      *(sqlite3_int64*)pOut = p->anExec[pScan->addrLoop];\n+      if( pScan->addrLoop>0 ){\n+        *(sqlite3_int64*)pOut = aOp[pScan->addrLoop].nExec;\n+      }else{\n+        *(sqlite3_int64*)pOut = -1;\n+      }\n@@ -88124,1 +92356,5 @@\n-      *(sqlite3_int64*)pOut = p->anExec[pScan->addrVisit];\n+      if( pScan->addrVisit>0 ){\n+        *(sqlite3_int64*)pOut = aOp[pScan->addrVisit].nExec;\n+      }else{\n+        *(sqlite3_int64*)pOut = -1;\n+      }\n@@ -88143,1 +92379,1 @@\n-        *(const char**)pOut = p->aOp[ pScan->addrExplain ].p4.z;\n+        *(const char**)pOut = aOp[ pScan->addrExplain ].p4.z;\n@@ -88151,1 +92387,9 @@\n-        *(int*)pOut = p->aOp[ pScan->addrExplain ].p1;\n+        *(int*)pOut = aOp[ pScan->addrExplain ].p1;\n+      }else{\n+        *(int*)pOut = -1;\n+      }\n+      break;\n+    }\n+    case SQLITE_SCANSTAT_PARENTID: {\n+      if( pScan->addrExplain ){\n+        *(int*)pOut = aOp[ pScan->addrExplain ].p2;\n@@ -88157,0 +92401,31 @@\n+    case SQLITE_SCANSTAT_NCYCLE: {\n+      i64 res = 0;\n+      if( pScan->aAddrRange[0]==0 ){\n+        res = -1;\n+      }else{\n+        int ii;\n+        for(ii=0; ii<ArraySize(pScan->aAddrRange); ii+=2){\n+          int iIns = pScan->aAddrRange[ii];\n+          int iEnd = pScan->aAddrRange[ii+1];\n+          if( iIns==0 ) break;\n+          if( iIns>0 ){\n+            while( iIns<=iEnd ){\n+              res += aOp[iIns].nCycle;\n+              iIns++;\n+            }\n+          }else{\n+            int iOp;\n+            for(iOp=0; iOp<nOp; iOp++){\n+              Op *pOp = &aOp[iOp];\n+              if( pOp->p1!=iEnd ) continue;\n+              if( (sqlite3OpcodeProperty[pOp->opcode] & OPFLG_NCYCLE)==0 ){\n+                continue;\n+              }\n+              res += aOp[iOp].nCycle;\n+            }\n+          }\n+        }\n+      }\n+      *(i64*)pOut = res;\n+      break;\n+    }\n@@ -88164,0 +92439,12 @@\n+\/*\n+** Return status data for a single loop within query pStmt.\n+*\/\n+SQLITE_API int sqlite3_stmt_scanstatus(\n+  sqlite3_stmt *pStmt,            \/* Prepared statement being queried *\/\n+  int iScan,                      \/* Index of loop to report on *\/\n+  int iScanStatusOp,              \/* Which metric to return *\/\n+  void *pOut                      \/* OUT: Write the answer here *\/\n+){\n+  return sqlite3_stmt_scanstatus_v2(pStmt, iScan, iScanStatusOp, 0, pOut);\n+}\n+\n@@ -88169,1 +92456,6 @@\n-  memset(p->anExec, 0, p->nOp * sizeof(i64));\n+  int ii;\n+  for(ii=0; p!=0 && ii<p->nOp; ii++){\n+    Op *pOp = &p->aOp[ii];\n+    pOp->nExec = 0;\n+    pOp->nCycle = 0;\n+  }\n@@ -88504,1 +92796,4 @@\n-  static int n = 0;\n+  static u64 n = 0;\n+  (void)pc;\n+  (void)pOp;\n+  (void)v;\n@@ -88506,0 +92801,1 @@\n+  if( n==LARGEST_UINT64 ) abort(); \/* So that n is used, preventing a warning *\/\n@@ -88686,1 +92982,2 @@\n-  i64 iValue = (double)rValue;\n+  i64 iValue;\n+  iValue = sqlite3RealToI64(rValue);\n@@ -88742,0 +93039,4 @@\n+** SQLITE_AFF_FLEXNUM:\n+**    If the value is text, then try to convert it into a number of\n+**    some kind (integer or real) but do not make any other changes.\n+**\n@@ -88756,1 +93057,1 @@\n-             || affinity==SQLITE_AFF_NUMERIC );\n+             || affinity==SQLITE_AFF_NUMERIC || affinity==SQLITE_AFF_FLEXNUM );\n@@ -88758,1 +93059,1 @@\n-      if( (pRec->flags & MEM_Real)==0 ){\n+      if( (pRec->flags & (MEM_Real|MEM_IntReal))==0 ){\n@@ -88760,1 +93061,1 @@\n-      }else{\n+      }else if( affinity<=SQLITE_AFF_REAL ){\n@@ -88848,1 +93149,3 @@\n-  if( pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal) ){\n+  assert( (pMem->flags & MEM_Null)==0\n+       || pMem->db==0 || pMem->db->mallocFailed );\n+  if( pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Null) ){\n@@ -88852,6 +93155,1 @@\n-    return pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal);\n-  }\n-  if( pMem->flags & (MEM_Str|MEM_Blob) ){\n-    testcase( pMem->flags & MEM_Str );\n-    testcase( pMem->flags & MEM_Blob );\n-    return computeNumericType(pMem);\n+    return pMem->flags & (MEM_Int|MEM_Real|MEM_IntReal|MEM_Null);\n@@ -88859,0 +93157,4 @@\n+  assert( pMem->flags & (MEM_Str|MEM_Blob) );\n+  testcase( pMem->flags & MEM_Str );\n+  testcase( pMem->flags & MEM_Blob );\n+  return computeNumericType(pMem);\n@@ -88919,0 +93221,3 @@\n+    if( f & MEM_Term ){\n+      sqlite3_str_appendf(pStr, \"(0-term)\");\n+    }\n@@ -88987,11 +93292,0 @@\n-\n-#ifdef VDBE_PROFILE\n-\n-\/*\n-** hwtime.h contains inline assembler code for implementing\n-** high-performance timing routines.\n-*\/\n-\/* #include \"hwtime.h\" *\/\n-\n-#endif\n-\n@@ -89057,2 +93351,4 @@\n-      h += p->n;\n-      if( p->flags & MEM_Zero ) h += p->u.nZero;\n+      \/* All strings have the same hash and all blobs have the same hash,\n+      ** though, at least, those hashes are different from each other and\n+      ** from NULL. *\/\n+      h += 4093 + (p->flags & (MEM_Str|MEM_Blob));\n@@ -89064,0 +93360,87 @@\n+\n+\/*\n+** For OP_Column, factor out the case where content is loaded from\n+** overflow pages, so that the code to implement this case is separate\n+** the common case where all content fits on the page.  Factoring out\n+** the code reduces register pressure and helps the common case\n+** to run faster.\n+*\/\n+static SQLITE_NOINLINE int vdbeColumnFromOverflow(\n+  VdbeCursor *pC,       \/* The BTree cursor from which we are reading *\/\n+  int iCol,             \/* The column to read *\/\n+  int t,                \/* The serial-type code for the column value *\/\n+  i64 iOffset,          \/* Offset to the start of the content value *\/\n+  u32 cacheStatus,      \/* Current Vdbe.cacheCtr value *\/\n+  u32 colCacheCtr,      \/* Current value of the column cache counter *\/\n+  Mem *pDest            \/* Store the value into this register. *\/\n+){\n+  int rc;\n+  sqlite3 *db = pDest->db;\n+  int encoding = pDest->enc;\n+  int len = sqlite3VdbeSerialTypeLen(t);\n+  assert( pC->eCurType==CURTYPE_BTREE );\n+  if( len>db->aLimit[SQLITE_LIMIT_LENGTH] ) return SQLITE_TOOBIG;\n+  if( len > 4000 && pC->pKeyInfo==0 ){\n+    \/* Cache large column values that are on overflow pages using\n+    ** an RCStr (reference counted string) so that if they are reloaded,\n+    ** that do not have to be copied a second time.  The overhead of\n+    ** creating and managing the cache is such that this is only\n+    ** profitable for larger TEXT and BLOB values.\n+    **\n+    ** Only do this on table-btrees so that writes to index-btrees do not\n+    ** need to clear the cache.  This buys performance in the common case\n+    ** in exchange for generality.\n+    *\/\n+    VdbeTxtBlbCache *pCache;\n+    char *pBuf;\n+    if( pC->colCache==0 ){\n+      pC->pCache = sqlite3DbMallocZero(db, sizeof(VdbeTxtBlbCache) );\n+      if( pC->pCache==0 ) return SQLITE_NOMEM;\n+      pC->colCache = 1;\n+    }\n+    pCache = pC->pCache;\n+    if( pCache->pCValue==0\n+     || pCache->iCol!=iCol\n+     || pCache->cacheStatus!=cacheStatus\n+     || pCache->colCacheCtr!=colCacheCtr\n+     || pCache->iOffset!=sqlite3BtreeOffset(pC->uc.pCursor)\n+    ){\n+      if( pCache->pCValue ) sqlite3RCStrUnref(pCache->pCValue);\n+      pBuf = pCache->pCValue = sqlite3RCStrNew( len+3 );\n+      if( pBuf==0 ) return SQLITE_NOMEM;\n+      rc = sqlite3BtreePayload(pC->uc.pCursor, iOffset, len, pBuf);\n+      if( rc ) return rc;\n+      pBuf[len] = 0;\n+      pBuf[len+1] = 0;\n+      pBuf[len+2] = 0;\n+      pCache->iCol = iCol;\n+      pCache->cacheStatus = cacheStatus;\n+      pCache->colCacheCtr = colCacheCtr;\n+      pCache->iOffset = sqlite3BtreeOffset(pC->uc.pCursor);\n+    }else{\n+      pBuf = pCache->pCValue;\n+    }\n+    assert( t>=12 );\n+    sqlite3RCStrRef(pBuf);\n+    if( t&1 ){\n+      rc = sqlite3VdbeMemSetStr(pDest, pBuf, len, encoding,\n+                                sqlite3RCStrUnref);\n+      pDest->flags |= MEM_Term;\n+    }else{\n+      rc = sqlite3VdbeMemSetStr(pDest, pBuf, len, 0,\n+                                sqlite3RCStrUnref);\n+    }\n+  }else{\n+    rc = sqlite3VdbeMemFromBtree(pC->uc.pCursor, iOffset, len, pDest);\n+    if( rc ) return rc;\n+    sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest);\n+    if( (t&1)!=0 && encoding==SQLITE_UTF8 ){\n+      pDest->z[len] = 0;\n+      pDest->flags |= MEM_Term;\n+    }\n+  }\n+  pDest->flags &= ~MEM_Ephem;\n+  return rc;\n+}\n+\n+\n@@ -89087,3 +93470,0 @@\n-#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)\n-  Op *pOrigOp;               \/* Value of pOp at the top of the loop *\/\n-#endif\n@@ -89091,0 +93471,1 @@\n+  Op *pOrigOp;               \/* Value of pOp at the top of the loop *\/\n@@ -89092,0 +93473,1 @@\n+  u8 iCompareIsInit = 0;     \/* iCompare is initialized *\/\n@@ -89107,2 +93489,4 @@\n-#ifdef VDBE_PROFILE\n-  u64 start;                 \/* CPU clock count at start of opcode *\/\n+  u32 colCacheCtr = 0;       \/* Column cache counter *\/\n+#if defined(SQLITE_ENABLE_STMT_SCANSTATUS) || defined(VDBE_PROFILE)\n+  u64 *pnCycle = 0;\n+  int bStmtScanStatus = IS_STMT_SCANSTATUS(db)!=0;\n@@ -89113,1 +93497,3 @@\n-  sqlite3VdbeEnter(p);\n+  if( DbMaskNonZero(p->lockMask) ){\n+    sqlite3VdbeEnter(p);\n+  }\n@@ -89134,1 +93520,0 @@\n-  p->pResultSet = 0;\n@@ -89171,3 +93556,0 @@\n-#ifdef VDBE_PROFILE\n-    start = sqlite3NProfileCnt ? sqlite3NProfileCnt : sqlite3Hwtime();\n-#endif\n@@ -89175,2 +93557,11 @@\n-#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n-    if( p->anExec ) p->anExec[(int)(pOp-aOp)]++;\n+\n+#if defined(VDBE_PROFILE)\n+    pOp->nExec++;\n+    pnCycle = &pOp->nCycle;\n+    if( sqlite3NProfileCnt==0 ) *pnCycle -= sqlite3Hwtime();\n+#elif defined(SQLITE_ENABLE_STMT_SCANSTATUS)\n+    if( bStmtScanStatus ){\n+      pOp->nExec++;\n+      pnCycle = &pOp->nCycle;\n+      *pnCycle -= sqlite3Hwtime();\n+    }\n@@ -89238,1 +93629,1 @@\n-#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)\n+#ifdef SQLITE_DEBUG\n@@ -89294,2 +93685,2 @@\n-  \/* In debuggging mode, when the p5 flags is set on an OP_Goto, that\n-  ** means we should really jump back to the preceeding OP_ReleaseReg\n+  \/* In debugging mode, when the p5 flags is set on an OP_Goto, that\n+  ** means we should really jump back to the preceding OP_ReleaseReg\n@@ -89503,1 +93894,1 @@\n-**    1:  NOT NULL contraint failed: P4\n+**    1:  NOT NULL constraint failed: P4\n@@ -89522,0 +93913,6 @@\n+\n+  \/* A deliberately coded \"OP_Halt SQLITE_INTERNAL * * * *\" opcode indicates\n+  ** something is wrong with the code generator.  Raise an assertion in order\n+  ** to bring this to the attention of fuzzers and other testing tools. *\/\n+  assert( pOp->p1!=SQLITE_INTERNAL );\n+\n@@ -89963,1 +94360,1 @@\n-  p->pResultSet = &aMem[pOp->p1];\n+  p->pResultRow = &aMem[pOp->p1];\n@@ -89966,1 +94363,1 @@\n-    Mem *pMem = p->pResultSet;\n+    Mem *pMem = p->pResultRow;\n@@ -90103,1 +94500,0 @@\n-  u16 flags;      \/* Combined MEM_* flags from both inputs *\/\n@@ -90112,1 +94508,1 @@\n-  type1 = numericType(pIn1);\n+  type1 = pIn1->flags;\n@@ -90114,1 +94510,1 @@\n-  type2 = numericType(pIn2);\n+  type2 = pIn2->flags;\n@@ -90116,1 +94512,0 @@\n-  flags = pIn1->flags | pIn2->flags;\n@@ -90118,0 +94513,1 @@\n+int_math:\n@@ -90139,1 +94535,1 @@\n-  }else if( (flags & MEM_Null)!=0 ){\n+  }else if( ((type1 | type2) & MEM_Null)!=0 ){\n@@ -90142,0 +94538,3 @@\n+    type1 = numericType(pIn1);\n+    type2 = numericType(pIn2);\n+    if( (type1 & type2 & MEM_Int)!=0 ) goto int_math;\n@@ -90299,1 +94698,1 @@\n-  pIn1->u.i += pOp->p2;\n+  *(u64*)&pIn1->u.i += (u64)pOp->p2;\n@@ -90494,1 +94893,0 @@\n-    assert( (pOp->p5 & SQLITE_AFF_MASK)!=SQLITE_AFF_TEXT || CORRUPT_DB );\n@@ -90502,0 +94900,1 @@\n+      VVA_ONLY( iCompareIsInit = 1; )\n@@ -90508,0 +94907,1 @@\n+      VVA_ONLY( iCompareIsInit = 1; )\n@@ -90514,0 +94914,1 @@\n+      VVA_ONLY( iCompareIsInit = 1; )\n@@ -90545,0 +94946,1 @@\n+      VVA_ONLY( iCompareIsInit = 1; )\n@@ -90555,1 +94957,1 @@\n-          testcase( flags3==pIn3->flags );\n+          assert( flags3==pIn3->flags || CORRUPT_DB );\n@@ -90562,2 +94964,4 @@\n-    }else if( affinity==SQLITE_AFF_TEXT ){\n-      if( (flags1 & MEM_Str)==0 && (flags1&(MEM_Int|MEM_Real|MEM_IntReal))!=0 ){\n+    }else if( affinity==SQLITE_AFF_TEXT && ((flags1 | flags3) & MEM_Str)!=0 ){\n+      if( (flags1 & MEM_Str)!=0 ){\n+        pIn1->flags &= ~(MEM_Int|MEM_Real|MEM_IntReal);\n+      }else if( (flags1&(MEM_Int|MEM_Real|MEM_IntReal))!=0 ){\n@@ -90570,1 +94974,1 @@\n-        if( pIn1==pIn3 ) flags3 = flags1 | MEM_Str;\n+        if( NEVER(pIn1==pIn3) ) flags3 = flags1 | MEM_Str;\n@@ -90572,1 +94976,3 @@\n-      if( (flags3 & MEM_Str)==0 && (flags3&(MEM_Int|MEM_Real|MEM_IntReal))!=0 ){\n+      if( (flags3 & MEM_Str)!=0 ){\n+        pIn3->flags &= ~(MEM_Int|MEM_Real|MEM_IntReal);\n+      }else if( (flags3&(MEM_Int|MEM_Real|MEM_IntReal))!=0 ){\n@@ -90601,0 +95007,1 @@\n+  VVA_ONLY( iCompareIsInit = 1; )\n@@ -90622,4 +95029,4 @@\n-** If result of an OP_Eq comparison on the same two operands as the\n-** prior OP_Lt or OP_Gt would have been true, then jump to P2.\n-** If the result of an OP_Eq comparison on the two previous\n-** operands would have been false or NULL, then fall through.\n+** If the result of an OP_Eq comparison on the same two operands as\n+** the prior OP_Lt or OP_Gt would have been true, then jump to P2.  If\n+** the result of an OP_Eq comparison on the two previous operands\n+** would have been false or NULL, then fall through.\n@@ -90639,0 +95046,1 @@\n+  assert( iCompareIsInit );\n@@ -90733,0 +95141,1 @@\n+    VVA_ONLY( iCompareIsInit = 1; )\n@@ -90750,1 +95159,1 @@\n-** in the most recent OP_Compare instruction the P1 vector was less than\n+** in the most recent OP_Compare instruction the P1 vector was less than,\n@@ -90757,0 +95166,1 @@\n+  assert( iCompareIsInit );\n@@ -90956,2 +95366,29 @@\n-\/* Opcode: IsNullOrType P1 P2 P3 * *\n-** Synopsis: if typeof(r[P1]) IN (P3,5) goto P2\n+\/* Opcode: IsType P1 P2 P3 P4 P5\n+** Synopsis: if typeof(P1.P3) in P5 goto P2\n+**\n+** Jump to P2 if the type of a column in a btree is one of the types specified\n+** by the P5 bitmask.\n+**\n+** P1 is normally a cursor on a btree for which the row decode cache is\n+** valid through at least column P3.  In other words, there should have been\n+** a prior OP_Column for column P3 or greater.  If the cursor is not valid,\n+** then this opcode might give spurious results.\n+** The the btree row has fewer than P3 columns, then use P4 as the\n+** datatype.\n+**\n+** If P1 is -1, then P3 is a register number and the datatype is taken\n+** from the value in that register.\n+**\n+** P5 is a bitmask of data types.  SQLITE_INTEGER is the least significant\n+** (0x01) bit. SQLITE_FLOAT is the 0x02 bit. SQLITE_TEXT is 0x04.\n+** SQLITE_BLOB is 0x08.  SQLITE_NULL is 0x10.\n+**\n+** WARNING: This opcode does not reliably distinguish between NULL and REAL\n+** when P1>=0.  If the database contains a NaN value, this opcode will think\n+** that the datatype is REAL when it should be NULL.  When P1<0 and the value\n+** is already stored in register P3, then this opcode does reliably\n+** distinguish between NULL and REAL.  The problem only arises then P1>=0.\n+**\n+** Take the jump to address P2 if and only if the datatype of the\n+** value determined by P1 and P3 corresponds to one of the bits in the\n+** P5 bitmask.\n@@ -90959,3 +95396,0 @@\n-** Jump to P2 if the value in register P1 is NULL or has a datatype P3.\n-** P3 is an integer which should be one of SQLITE_INTEGER, SQLITE_FLOAT,\n-** SQLITE_BLOB, SQLITE_NULL, or SQLITE_TEXT.\n@@ -90963,6 +95397,59 @@\n-case OP_IsNullOrType: {      \/* jump, in1 *\/\n-  int doTheJump;\n-  pIn1 = &aMem[pOp->p1];\n-  doTheJump = (pIn1->flags & MEM_Null)!=0 || sqlite3_value_type(pIn1)==pOp->p3;\n-  VdbeBranchTaken( doTheJump, 2);\n-  if( doTheJump ) goto jump_to_p2;\n+case OP_IsType: {        \/* jump *\/\n+  VdbeCursor *pC;\n+  u16 typeMask;\n+  u32 serialType;\n+\n+  assert( pOp->p1>=(-1) && pOp->p1<p->nCursor );\n+  assert( pOp->p1>=0 || (pOp->p3>=0 && pOp->p3<=(p->nMem+1 - p->nCursor)) );\n+  if( pOp->p1>=0 ){\n+    pC = p->apCsr[pOp->p1];\n+    assert( pC!=0 );\n+    assert( pOp->p3>=0 );\n+    if( pOp->p3<pC->nHdrParsed ){\n+      serialType = pC->aType[pOp->p3];\n+      if( serialType>=12 ){\n+        if( serialType&1 ){\n+          typeMask = 0x04;   \/* SQLITE_TEXT *\/\n+        }else{\n+          typeMask = 0x08;   \/* SQLITE_BLOB *\/\n+        }\n+      }else{\n+        static const unsigned char aMask[] = {\n+           0x10, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x2,\n+           0x01, 0x01, 0x10, 0x10\n+        };\n+        testcase( serialType==0 );\n+        testcase( serialType==1 );\n+        testcase( serialType==2 );\n+        testcase( serialType==3 );\n+        testcase( serialType==4 );\n+        testcase( serialType==5 );\n+        testcase( serialType==6 );\n+        testcase( serialType==7 );\n+        testcase( serialType==8 );\n+        testcase( serialType==9 );\n+        testcase( serialType==10 );\n+        testcase( serialType==11 );\n+        typeMask = aMask[serialType];\n+      }\n+    }else{\n+      typeMask = 1 << (pOp->p4.i - 1);\n+      testcase( typeMask==0x01 );\n+      testcase( typeMask==0x02 );\n+      testcase( typeMask==0x04 );\n+      testcase( typeMask==0x08 );\n+      testcase( typeMask==0x10 );\n+    }\n+  }else{\n+    assert( memIsValid(&aMem[pOp->p3]) );\n+    typeMask = 1 << (sqlite3_value_type((sqlite3_value*)&aMem[pOp->p3])-1);\n+    testcase( typeMask==0x01 );\n+    testcase( typeMask==0x02 );\n+    testcase( typeMask==0x04 );\n+    testcase( typeMask==0x08 );\n+    testcase( typeMask==0x10 );\n+  }\n+  VdbeBranchTaken( (typeMask & pOp->p5)!=0, 2);\n+  if( typeMask & pOp->p5 ){\n+    goto jump_to_p2;\n+  }\n@@ -90975,1 +95462,1 @@\n-** If all both registers P1 and P3 are NOT NULL, then store a zero in\n+** If both registers P1 and P3 are NOT NULL, then store a zero in\n@@ -91011,0 +95498,2 @@\n+**\n+** If P1 is not an open cursor, then this opcode is a no-op.\n@@ -91013,0 +95502,1 @@\n+  VdbeCursor *pC;\n@@ -91014,2 +95504,2 @@\n-  assert( p->apCsr[pOp->p1]!=0 );\n-  if( p->apCsr[pOp->p1]->nullRow ){\n+  pC = p->apCsr[pOp->p1];\n+  if( pC && pC->nullRow ){\n@@ -91066,1 +95556,1 @@\n-** from this record.  If there are less that (P2+1)\n+** from this record.  If there are less than (P2+1)\n@@ -91075,4 +95565,6 @@\n-** If the OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG bits are set on P5 then\n-** the result is guaranteed to only be used as the argument of a length()\n-** or typeof() function, respectively.  The loading of large blobs can be\n-** skipped for length() and all content loading can be skipped for typeof().\n+** If the OPFLAG_LENGTHARG bit is set in P5 then the result is guaranteed\n+** to only be used by the length() function or the equivalent.  The content\n+** of large blobs is not loaded, thus saving CPU cycles.  If the\n+** OPFLAG_TYPEOFARG bit is set then the result will only be used by the\n+** typeof() function or the IS NULL or IS NOT NULL operators or the\n+** equivalent.  In this case, all content loading can be omitted.\n@@ -91080,1 +95572,1 @@\n-case OP_Column: {\n+case OP_Column: {            \/* ncycle *\/\n@@ -91324,0 +95816,1 @@\n+    u8 p5;\n@@ -91325,0 +95818,1 @@\n+    assert( pDest->db==db );\n@@ -91326,3 +95820,6 @@\n-    if( ((pOp->p5 & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG))!=0\n-          && ((t>=12 && (t&1)==0) || (pOp->p5 & OPFLAG_TYPEOFARG)!=0))\n-     || (len = sqlite3VdbeSerialTypeLen(t))==0\n+    if( ((p5 = (pOp->p5 & OPFLAG_BYTELENARG))!=0\n+          && (p5==OPFLAG_TYPEOFARG\n+              || (t>=12 && ((t&1)==0 || p5==OPFLAG_BYTELENARG))\n+             )\n+        )\n+     || sqlite3VdbeSerialTypeLen(t)==0\n@@ -91345,5 +95842,7 @@\n-      if( len>db->aLimit[SQLITE_LIMIT_LENGTH] ) goto too_big;\n-      rc = sqlite3VdbeMemFromBtree(pC->uc.pCursor, aOffset[p2], len, pDest);\n-      if( rc!=SQLITE_OK ) goto abort_due_to_error;\n-      sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest);\n-      pDest->flags &= ~MEM_Ephem;\n+      rc = vdbeColumnFromOverflow(pC, p2, t, aOffset[p2],\n+                p->cacheCtr, colCacheCtr, pDest);\n+      if( rc ){\n+        if( rc==SQLITE_NOMEM ) goto no_mem;\n+        if( rc==SQLITE_TOOBIG ) goto too_big;\n+        goto abort_due_to_error;\n+      }\n@@ -91429,1 +95928,1 @@\n-          testcase( (pIn1->flags & (MEM_Real|MEM_IntReal))==MEM_IntReal );\n+          assert( (pIn1->flags & MEM_IntReal)==0 );\n@@ -91508,1 +96007,1 @@\n-        pIn1->flags &= ~MEM_Int;\n+        pIn1->flags &= ~(MEM_Int|MEM_Str);\n@@ -91811,1 +96310,0 @@\n-        u32 i;\n@@ -91819,6 +96317,11 @@\n-        len = i = sqlite3SmallTypeSizes[serial_type];\n-        assert( i>0 );\n-        while( 1 \/*exit-by-break*\/ ){\n-          zPayload[--i] = (u8)(v&0xFF);\n-          if( i==0 ) break;\n-          v >>= 8;\n+        len = sqlite3SmallTypeSizes[serial_type];\n+        assert( len>=1 && len<=8 && len!=5 && len!=7 );\n+        switch( len ){\n+          default: zPayload[7] = (u8)(v&0xff); v >>= 8;\n+                   zPayload[6] = (u8)(v&0xff); v >>= 8;\n+          case 6:  zPayload[5] = (u8)(v&0xff); v >>= 8;\n+                   zPayload[4] = (u8)(v&0xff); v >>= 8;\n+          case 4:  zPayload[3] = (u8)(v&0xff); v >>= 8;\n+          case 3:  zPayload[2] = (u8)(v&0xff); v >>= 8;\n+          case 2:  zPayload[1] = (u8)(v&0xff); v >>= 8;\n+          case 1:  zPayload[0] = (u8)(v&0xff);\n@@ -92432,1 +96935,1 @@\n-case OP_ReopenIdx: {\n+case OP_ReopenIdx: {         \/* ncycle *\/\n@@ -92453,1 +96956,1 @@\n-case OP_OpenRead:\n+case OP_OpenRead:            \/* ncycle *\/\n@@ -92547,1 +97050,1 @@\n-case OP_OpenDup: {\n+case OP_OpenDup: {           \/* ncycle *\/\n@@ -92609,2 +97112,2 @@\n-case OP_OpenAutoindex:\n-case OP_OpenEphemeral: {\n+case OP_OpenAutoindex:       \/* ncycle *\/\n+case OP_OpenEphemeral: {     \/* ncycle *\/\n@@ -92633,1 +97136,1 @@\n-    \/* If the ephermeral table is already open and has no duplicates from\n+    \/* If the ephemeral table is already open and has no duplicates from\n@@ -92768,1 +97271,1 @@\n-case OP_Close: {\n+case OP_Close: {             \/* ncycle *\/\n@@ -92885,4 +97388,4 @@\n-case OP_SeekLT:         \/* jump, in3, group *\/\n-case OP_SeekLE:         \/* jump, in3, group *\/\n-case OP_SeekGE:         \/* jump, in3, group *\/\n-case OP_SeekGT: {       \/* jump, in3, group *\/\n+case OP_SeekLT:         \/* jump, in3, group, ncycle *\/\n+case OP_SeekLE:         \/* jump, in3, group, ncycle *\/\n+case OP_SeekGE:         \/* jump, in3, group, ncycle *\/\n+case OP_SeekGT: {       \/* jump, in3, group, ncycle *\/\n@@ -93017,1 +97520,7 @@\n-    { int i; for(i=0; i<r.nField; i++) assert( memIsValid(&r.aMem[i]) ); }\n+    {\n+      int i;\n+      for(i=0; i<r.nField; i++){\n+        assert( memIsValid(&r.aMem[i]) );\n+        if( i>0 ) REGISTER_TRACE(pOp->p3+i, &r.aMem[i]);\n+      }\n+    }\n@@ -93080,1 +97589,1 @@\n-\/* Opcode: SeekScan  P1 P2 * * *\n+\/* Opcode: SeekScan  P1 P2 * * P5\n@@ -93090,2 +97599,2 @@\n-** the P1 and P2 operands of this opcode are also used, and  are called\n-** This.P1 and This.P2.\n+** the P1, P2 and P5 operands of this opcode are also used, and  are called\n+** This.P1, This.P2 and This.P5.\n@@ -93101,1 +97610,1 @@\n-** to.  Call this SeekGE.P4\/P5 row the \"target\".\n+** to.  Call this SeekGE.P3\/P4 row the \"target\".\n@@ -93108,16 +97617,38 @@\n-** target row.  This opcode attempts to position the cursor on the target\n-** row by, perhaps by invoking sqlite3BtreeStep() on the cursor\n-** between 0 and This.P1 times.\n-**\n-** There are three possible outcomes from this opcode:<ol>\n-**\n-** <li> If after This.P1 steps, the cursor is still pointing to a place that\n-**      is earlier in the btree than the target row, then fall through\n-**      into the subsquence OP_SeekGE opcode.\n-**\n-** <li> If the cursor is successfully moved to the target row by 0 or more\n-**      sqlite3BtreeNext() calls, then jump to This.P2, which will land just\n-**      past the OP_IdxGT or OP_IdxGE opcode that follows the OP_SeekGE.\n-**\n-** <li> If the cursor ends up past the target row (indicating the the target\n-**      row does not exist in the btree) then jump to SeekOP.P2.\n+** target row, or it might be after the target row.  If the cursor is\n+** currently before the target row, then this opcode attempts to position\n+** the cursor on or after the target row by invoking sqlite3BtreeStep()\n+** on the cursor between 1 and This.P1 times.\n+**\n+** The This.P5 parameter is a flag that indicates what to do if the\n+** cursor ends up pointing at a valid row that is past the target\n+** row.  If This.P5 is false (0) then a jump is made to SeekGE.P2.  If\n+** This.P5 is true (non-zero) then a jump is made to This.P2.  The P5==0\n+** case occurs when there are no inequality constraints to the right of\n+** the IN constraint.  The jump to SeekGE.P2 ends the loop.  The P5!=0 case\n+** occurs when there are inequality constraints to the right of the IN\n+** operator.  In that case, the This.P2 will point either directly to or\n+** to setup code prior to the OP_IdxGT or OP_IdxGE opcode that checks for\n+** loop terminate.\n+**\n+** Possible outcomes from this opcode:<ol>\n+**\n+** <li> If the cursor is initially not pointed to any valid row, then\n+**      fall through into the subsequent OP_SeekGE opcode.\n+**\n+** <li> If the cursor is left pointing to a row that is before the target\n+**      row, even after making as many as This.P1 calls to\n+**      sqlite3BtreeNext(), then also fall through into OP_SeekGE.\n+**\n+** <li> If the cursor is left pointing at the target row, either because it\n+**      was at the target row to begin with or because one or more\n+**      sqlite3BtreeNext() calls moved the cursor to the target row,\n+**      then jump to This.P2..,\n+**\n+** <li> If the cursor started out before the target row and a call to\n+**      to sqlite3BtreeNext() moved the cursor off the end of the index\n+**      (indicating that the target row definitely does not exist in the\n+**      btree) then jump to SeekGE.P2, ending the loop.\n+**\n+** <li> If the cursor ends up on a valid row that is past the target row\n+**      (indicating that the target row does not exist in the btree) then\n+**      jump to SeekOP.P2 if This.P5==0 or to This.P2 if This.P5>0.\n@@ -93126,1 +97657,1 @@\n-case OP_SeekScan: {\n+case OP_SeekScan: {          \/* ncycle *\/\n@@ -93134,2 +97665,3 @@\n-  \/* pOp->p2 points to the first instruction past the OP_IdxGT that\n-  ** follows the OP_SeekGE.  *\/\n+  \/* If pOp->p5 is clear, then pOp->p2 points to the first instruction past the\n+  ** OP_IdxGT that follows the OP_SeekGE. Otherwise, it points to the first\n+  ** opcode past the OP_SeekGE itself.  *\/\n@@ -93137,5 +97669,15 @@\n-  assert( aOp[pOp->p2-1].opcode==OP_IdxGT || aOp[pOp->p2-1].opcode==OP_IdxGE );\n-  testcase( aOp[pOp->p2-1].opcode==OP_IdxGE );\n-  assert( pOp[1].p1==aOp[pOp->p2-1].p1 );\n-  assert( pOp[1].p2==aOp[pOp->p2-1].p2 );\n-  assert( pOp[1].p3==aOp[pOp->p2-1].p3 );\n+#ifdef SQLITE_DEBUG\n+  if( pOp->p5==0 ){\n+    \/* There are no inequality constraints following the IN constraint. *\/\n+    assert( pOp[1].p1==aOp[pOp->p2-1].p1 );\n+    assert( pOp[1].p2==aOp[pOp->p2-1].p2 );\n+    assert( pOp[1].p3==aOp[pOp->p2-1].p3 );\n+    assert( aOp[pOp->p2-1].opcode==OP_IdxGT\n+         || aOp[pOp->p2-1].opcode==OP_IdxGE );\n+    testcase( aOp[pOp->p2-1].opcode==OP_IdxGE );\n+  }else{\n+    \/* There are inequality constraints.  *\/\n+    assert( pOp->p2==(int)(pOp-aOp)+2 );\n+    assert( aOp[pOp->p2-1].opcode==OP_SeekGE );\n+  }\n+#endif\n@@ -93175,1 +97717,1 @@\n-    if( res>0 ){\n+    if( res>0 && pOp->p5==0 ){\n@@ -93177,0 +97719,1 @@\n+      \/* Jump to SeekGE.P2, ending the loop *\/\n@@ -93186,1 +97729,2 @@\n-    if( res==0 ){\n+    if( res>=0 ){\n+      \/* Jump to This.P2, bypassing the OP_SeekGE opcode *\/\n@@ -93206,0 +97750,1 @@\n+    pC->cacheStatus = CACHE_STALE;\n@@ -93235,1 +97780,1 @@\n-case OP_SeekHit: {\n+case OP_SeekHit: {           \/* ncycle *\/\n@@ -93262,1 +97807,2 @@\n-** If cursor P1 is not open, jump to instruction P2. Otherwise, fall through.\n+** If cursor P1 is not open or if P1 is set to a NULL row using the\n+** OP_NullRow opcode, then jump to instruction P2. Otherwise, fall through.\n@@ -93265,0 +97811,2 @@\n+  VdbeCursor *pCur;\n+\n@@ -93266,2 +97814,3 @@\n-  VdbeBranchTaken(p->apCsr[pOp->p1]==0, 2);\n-  if( !p->apCsr[pOp->p1] ){\n+  pCur = p->apCsr[pOp->p1];\n+  VdbeBranchTaken(pCur==0 || pCur->nullRow, 2);\n+  if( pCur==0 || pCur->nullRow ){\n@@ -93318,1 +97867,1 @@\n-** falls through, the correct answer is still obtained, but extra works\n+** falls through, the correct answer is still obtained, but extra work\n@@ -93324,1 +97873,1 @@\n-** index.  If it is not possible, we can skips some work.  So if seekHit\n+** index.  If it is not possible, we can skip some work.  So if seekHit\n@@ -93363,1 +97912,1 @@\n-case OP_IfNoHope: {     \/* jump, in3 *\/\n+case OP_IfNoHope: {     \/* jump, in3, ncycle *\/\n@@ -93377,3 +97926,3 @@\n-case OP_NoConflict:     \/* jump, in3 *\/\n-case OP_NotFound:       \/* jump, in3 *\/\n-case OP_Found: {        \/* jump, in3 *\/\n+case OP_NoConflict:     \/* jump, in3, ncycle *\/\n+case OP_NotFound:       \/* jump, in3, ncycle *\/\n+case OP_Found: {        \/* jump, in3, ncycle *\/\n@@ -93509,1 +98058,1 @@\n-case OP_SeekRowid: {        \/* jump, in3 *\/\n+case OP_SeekRowid: {        \/* jump, in3, ncycle *\/\n@@ -93534,1 +98083,1 @@\n-case OP_NotExists:          \/* jump, in3 *\/\n+case OP_NotExists:          \/* jump, in3, ncycle *\/\n@@ -93814,2 +98363,5 @@\n-  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;\n-  if( pOp->p5 & OPFLAG_LASTROWID ) db->lastRowid = x.nKey;\n+  assert( (pOp->p5 & OPFLAG_LASTROWID)==0 || (pOp->p5 & OPFLAG_NCHANGE)!=0 );\n+  if( pOp->p5 & OPFLAG_NCHANGE ){\n+    p->nChange++;\n+    if( pOp->p5 & OPFLAG_LASTROWID ) db->lastRowid = x.nKey;\n+  }\n@@ -93826,0 +98378,1 @@\n+  assert( BTREE_PREFORMAT==OPFLAG_PREFORMAT );\n@@ -93832,0 +98385,1 @@\n+  colCacheCtr++;\n@@ -93885,4 +98439,4 @@\n-** delete one of several associated with deleting a table row and all its\n-** associated index entries.  Exactly one of those deletes is the \"primary\"\n-** delete.  The others are all on OPFLAG_FORDELETE cursors or else are\n-** marked with the AUXDELETE flag.\n+** delete is one of several associated with deleting a table row and\n+** all its associated index entries.  Exactly one of those deletes is\n+** the \"primary\" delete.  The others are all on OPFLAG_FORDELETE\n+** cursors or else are marked with the AUXDELETE flag.\n@@ -93890,2 +98444,7 @@\n-** If the OPFLAG_NCHANGE flag of P2 (NB: P2 not P5) is set, then the row\n-** change count is incremented (otherwise not).\n+** If the OPFLAG_NCHANGE (0x01) flag of P2 (NB: P2 not P5) is set, then\n+** the row change count is incremented (otherwise not).\n+**\n+** If the OPFLAG_ISNOOP (0x40) flag of P2 (not P5!) is set, then the\n+** pre-update-hook for deletes is run, but the btree is otherwise unchanged.\n+** This happens when the OP_Delete is to be shortly followed by an OP_Insert\n+** with the same key, causing the btree entry to be overwritten.\n@@ -93992,0 +98551,1 @@\n+  colCacheCtr++;\n@@ -94059,1 +98619,1 @@\n-** This opcode is normally use to move a record out of the sorter and into\n+** This opcode is normally used to move a record out of the sorter and into\n@@ -94065,1 +98625,1 @@\n-case OP_SorterData: {\n+case OP_SorterData: {       \/* ncycle *\/\n@@ -94157,1 +98717,1 @@\n-case OP_Rowid: {                 \/* out2 *\/\n+case OP_Rowid: {                 \/* out2, ncycle *\/\n@@ -94256,2 +98816,2 @@\n-case OP_SeekEnd:\n-case OP_Last: {        \/* jump *\/\n+case OP_SeekEnd:             \/* ncycle *\/\n+case OP_Last: {              \/* jump, ncycle *\/\n@@ -94340,2 +98900,2 @@\n-case OP_SorterSort:    \/* jump *\/\n-case OP_Sort: {        \/* jump *\/\n+case OP_SorterSort:    \/* jump ncycle *\/\n+case OP_Sort: {        \/* jump ncycle *\/\n@@ -94358,0 +98918,3 @@\n+** If P2 is zero, that is an assertion that the P1 table is never\n+** empty and hence the jump will never be taken.\n+**\n@@ -94362,1 +98925,1 @@\n-case OP_Rewind: {        \/* jump *\/\n+case OP_Rewind: {        \/* jump, ncycle *\/\n@@ -94369,0 +98932,2 @@\n+  assert( pOp->p2>=0 && pOp->p2<p->nOp );\n+\n@@ -94388,3 +98953,4 @@\n-  assert( pOp->p2>0 && pOp->p2<p->nOp );\n-  VdbeBranchTaken(res!=0,2);\n-  if( res ) goto jump_to_p2;\n+  if( pOp->p2>0 ){\n+    VdbeBranchTaken(res!=0,2);\n+    if( res ) goto jump_to_p2;\n+  }\n@@ -94456,1 +99022,1 @@\n-case OP_Prev:          \/* jump *\/\n+case OP_Prev:          \/* jump, ncycle *\/\n@@ -94458,1 +99024,3 @@\n-  assert( pOp->p5<ArraySize(p->aCounter) );\n+  assert( pOp->p5==0\n+       || pOp->p5==SQLITE_STMTSTATUS_FULLSCAN_STEP\n+       || pOp->p5==SQLITE_STMTSTATUS_AUTOINDEX);\n@@ -94469,1 +99037,1 @@\n-case OP_Next:          \/* jump *\/\n+case OP_Next:          \/* jump, ncycle *\/\n@@ -94471,1 +99039,3 @@\n-  assert( pOp->p5<ArraySize(p->aCounter) );\n+  assert( pOp->p5==0\n+       || pOp->p5==SQLITE_STMTSTATUS_FULLSCAN_STEP\n+       || pOp->p5==SQLITE_STMTSTATUS_AUTOINDEX);\n@@ -94659,2 +99229,2 @@\n-case OP_DeferredSeek:\n-case OP_IdxRowid: {           \/* out2 *\/\n+case OP_DeferredSeek:         \/* ncycle *\/\n+case OP_IdxRowid: {           \/* out2, ncycle *\/\n@@ -94678,4 +99248,4 @@\n-  \/* sqlite3VbeCursorRestore() can only fail if the record has been deleted\n-  ** out from under the cursor.  That will never happens for an IdxRowid\n-  ** or Seek opcode *\/\n-  if( NEVER(rc!=SQLITE_OK) ) goto abort_due_to_error;\n+  \/* sqlite3VdbeCursorRestore() may fail if the cursor has been disturbed\n+  ** since it was last positioned and an error (e.g. OOM or an IO error)\n+  ** occurs while trying to reposition it. *\/\n+  if( rc!=SQLITE_OK ) goto abort_due_to_error;\n@@ -94722,2 +99292,2 @@\n-case OP_FinishSeek: {\n-  VdbeCursor *pC;             \/* The P1 index cursor *\/\n+case OP_FinishSeek: {        \/* ncycle *\/\n+  VdbeCursor *pC;            \/* The P1 index cursor *\/\n@@ -94778,4 +99348,4 @@\n-case OP_IdxLE:          \/* jump *\/\n-case OP_IdxGT:          \/* jump *\/\n-case OP_IdxLT:          \/* jump *\/\n-case OP_IdxGE:  {       \/* jump *\/\n+case OP_IdxLE:          \/* jump, ncycle *\/\n+case OP_IdxGT:          \/* jump, ncycle *\/\n+case OP_IdxLT:          \/* jump, ncycle *\/\n+case OP_IdxGE:  {       \/* jump, ncycle *\/\n@@ -94858,1 +99428,1 @@\n-** P3==1 then the table to be clear is in the auxiliary database file\n+** P3==1 then the table to be destroyed is in the auxiliary database file\n@@ -94918,2 +99488,2 @@\n-** The table being clear is in the main database file if P2==0.  If\n-** P2==1 then the table to be clear is in the auxiliary database file\n+** The table being cleared is in the main database file if P2==0.  If\n+** P2==1 then the table to be cleared is in the auxiliary database file\n@@ -95005,0 +99575,2 @@\n+** Disable Auth and Trace callbacks while those statements are running if\n+** P1 is true.\n@@ -95007,0 +99579,6 @@\n+  char *zErr;\n+#ifndef SQLITE_OMIT_AUTHORIZATION\n+  sqlite3_xauth xAuth;\n+#endif\n+  u8 mTrace;\n+\n@@ -95009,1 +99587,12 @@\n-  rc = sqlite3_exec(db, pOp->p4.z, 0, 0, 0);\n+  zErr = 0;\n+#ifndef SQLITE_OMIT_AUTHORIZATION\n+  xAuth = db->xAuth;\n+#endif\n+  mTrace = db->mTrace;\n+  if( pOp->p1 ){\n+#ifndef SQLITE_OMIT_AUTHORIZATION\n+    db->xAuth = 0;\n+#endif\n+    db->mTrace = 0;\n+  }\n+  rc = sqlite3_exec(db, pOp->p4.z, 0, 0, &zErr);\n@@ -95011,1 +99600,10 @@\n-  if( rc ) goto abort_due_to_error;\n+#ifndef SQLITE_OMIT_AUTHORIZATION\n+  db->xAuth = xAuth;\n+#endif\n+  db->mTrace = mTrace;\n+  if( zErr || rc ){\n+    sqlite3VdbeError(p, \"%s\", zErr);\n+    sqlite3_free(zErr);\n+    if( rc==SQLITE_NOMEM ) goto no_mem;\n+    goto abort_due_to_error;\n+  }\n@@ -95192,2 +99790,2 @@\n-  z = sqlite3BtreeIntegrityCheck(db, db->aDb[pOp->p5].pBt, &aRoot[1], nRoot,\n-                                 (int)pnErr->u.i+1, &nErr);\n+  rc = sqlite3BtreeIntegrityCheck(db, db->aDb[pOp->p5].pBt, &aRoot[1], nRoot,\n+                                 (int)pnErr->u.i+1, &nErr, &z);\n@@ -95197,2 +99795,3 @@\n-  }else if( z==0 ){\n-    goto no_mem;\n+  }else if( rc ){\n+    sqlite3_free(z);\n+    goto abort_due_to_error;\n@@ -95402,3 +100001,0 @@\n-#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n-    pFrame->anExec = p->anExec;\n-#endif\n@@ -95441,3 +100037,0 @@\n-#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n-  p->anExec = 0;\n-#endif\n@@ -95583,1 +100176,1 @@\n-** LIMIT and OFFSET process.  r[P1] holds the limit counter.  r[P3]\n+** LIMIT and OFFSET processing.  r[P1] holds the limit counter.  r[P3]\n@@ -95750,1 +100343,1 @@\n-  ** reinitializes the relavant parts of the sqlite3_context object *\/\n+  ** reinitializes the relevant parts of the sqlite3_context object *\/\n@@ -95845,0 +100438,1 @@\n+  REGISTER_TRACE((int)(pMem-aMem), pMem);\n@@ -96200,1 +100794,1 @@\n-case OP_VOpen: {\n+case OP_VOpen: {             \/* ncycle *\/\n@@ -96236,0 +100830,46 @@\n+#ifndef SQLITE_OMIT_VIRTUALTABLE\n+\/* Opcode: VCheck P1 P2 P3 P4 *\n+**\n+** P4 is a pointer to a Table object that is a virtual table in schema P1\n+** that supports the xIntegrity() method.  This opcode runs the xIntegrity()\n+** method for that virtual table, using P3 as the integer argument.  If\n+** an error is reported back, the table name is prepended to the error\n+** message and that message is stored in P2.  If no errors are seen,\n+** register P2 is set to NULL.\n+*\/\n+case OP_VCheck: {             \/* out2 *\/\n+  Table *pTab;\n+  sqlite3_vtab *pVtab;\n+  const sqlite3_module *pModule;\n+  char *zErr = 0;\n+\n+  pOut = &aMem[pOp->p2];\n+  sqlite3VdbeMemSetNull(pOut);  \/* Innocent until proven guilty *\/\n+  assert( pOp->p4type==P4_TABLEREF );\n+  pTab = pOp->p4.pTab;\n+  assert( pTab!=0 );\n+  assert( pTab->nTabRef>0 );\n+  assert( IsVirtual(pTab) );\n+  if( pTab->u.vtab.p==0 ) break;\n+  pVtab = pTab->u.vtab.p->pVtab;\n+  assert( pVtab!=0 );\n+  pModule = pVtab->pModule;\n+  assert( pModule!=0 );\n+  assert( pModule->iVersion>=4 );\n+  assert( pModule->xIntegrity!=0 );\n+  sqlite3VtabLock(pTab->u.vtab.p);\n+  assert( pOp->p1>=0 && pOp->p1<db->nDb );\n+  rc = pModule->xIntegrity(pVtab, db->aDb[pOp->p1].zDbSName, pTab->zName,\n+                           pOp->p3, &zErr);\n+  sqlite3VtabUnlock(pTab->u.vtab.p);\n+  if( rc ){\n+    sqlite3_free(zErr);\n+    goto abort_due_to_error;\n+  }\n+  if( zErr ){\n+    sqlite3VdbeMemSetStr(pOut, zErr, -1, SQLITE_UTF8, sqlite3_free);\n+  }\n+  break;\n+}\n+#endif \/* SQLITE_OMIT_VIRTUALTABLE *\/\n+\n@@ -96247,1 +100887,1 @@\n-case OP_VInitIn: {        \/* out2 *\/\n+case OP_VInitIn: {        \/* out2, ncycle *\/\n@@ -96258,1 +100898,1 @@\n-  sqlite3VdbeMemSetPointer(pOut, pRhs, \"ValueList\", sqlite3_free);\n+  sqlite3VdbeMemSetPointer(pOut, pRhs, \"ValueList\", sqlite3VdbeValueListFree);\n@@ -96284,1 +100924,1 @@\n-case OP_VFilter: {   \/* jump *\/\n+case OP_VFilter: {   \/* jump, ncycle *\/\n@@ -96344,1 +100984,1 @@\n-case OP_VColumn: {\n+case OP_VColumn: {           \/* ncycle *\/\n@@ -96349,0 +100989,1 @@\n+  FuncDef nullFunc;\n@@ -96366,0 +101007,3 @@\n+  nullFunc.pUserData = 0;\n+  nullFunc.funcFlags = SQLITE_RESULT_SUBTYPE;\n+  sContext.pFunc = &nullFunc;\n@@ -96396,1 +101040,1 @@\n-case OP_VNext: {   \/* jump *\/\n+case OP_VNext: {   \/* jump, ncycle *\/\n@@ -96627,1 +101271,1 @@\n-** either determinitic of non-deterministic, depending on their arguments.\n+** either deterministic of non-deterministic, depending on their arguments.\n@@ -96645,1 +101289,1 @@\n-  ** reinitializes the relavant parts of the sqlite3_context object *\/\n+  ** reinitializes the relevant parts of the sqlite3_context object *\/\n@@ -96698,0 +101342,36 @@\n+\/* Opcode: GetSubtype P1 P2 * * *\n+** Synopsis:  r[P2] = r[P1].subtype\n+**\n+** Extract the subtype value from register P1 and write that subtype\n+** into register P2.  If P1 has no subtype, then P1 gets a NULL.\n+*\/\n+case OP_GetSubtype: {   \/* in1 out2 *\/\n+  pIn1 = &aMem[pOp->p1];\n+  pOut = &aMem[pOp->p2];\n+  if( pIn1->flags & MEM_Subtype ){\n+    sqlite3VdbeMemSetInt64(pOut, pIn1->eSubtype);\n+  }else{\n+    sqlite3VdbeMemSetNull(pOut);\n+  }\n+  break;\n+}\n+\n+\/* Opcode: SetSubtype P1 P2 * * *\n+** Synopsis:  r[P2].subtype = r[P1]\n+**\n+** Set the subtype value of register P2 to the integer from register P1.\n+** If P1 is NULL, clear the subtype from p2.\n+*\/\n+case OP_SetSubtype: {   \/* in1 out2 *\/\n+  pIn1 = &aMem[pOp->p1];\n+  pOut = &aMem[pOp->p2];\n+  if( pIn1->flags & MEM_Null ){\n+    pOut->flags &= ~MEM_Subtype;\n+  }else{\n+    assert( pIn1->flags & MEM_Int );\n+    pOut->flags |= MEM_Subtype;\n+    pOut->eSubtype = (u8)(pIn1->u.i & 0xff);\n+  }\n+  break;\n+}\n+\n@@ -96721,1 +101401,1 @@\n-  h %= pIn1->n;\n+  h %= (pIn1->n*8);\n@@ -96757,1 +101437,1 @@\n-  h %= pIn1->n;\n+  h %= (pIn1->n*8);\n@@ -96979,5 +101659,7 @@\n-#ifdef VDBE_PROFILE\n-    {\n-      u64 endTime = sqlite3NProfileCnt ? sqlite3NProfileCnt : sqlite3Hwtime();\n-      if( endTime>start ) pOrigOp->cycles += endTime - start;\n-      pOrigOp->cnt++;\n+#if defined(VDBE_PROFILE)\n+    *pnCycle += sqlite3NProfileCnt ? sqlite3NProfileCnt : sqlite3Hwtime();\n+    pnCycle = 0;\n+#elif defined(SQLITE_ENABLE_STMT_SCANSTATUS)\n+    if( pnCycle ){\n+      *pnCycle += sqlite3Hwtime();\n+      pnCycle = 0;\n@@ -97007,1 +101689,1 @@\n-        ** warning aboud sqlite3VdbeRegisterDump() being defined but not\n+        ** warning about sqlite3VdbeRegisterDump() being defined but not\n@@ -97060,0 +101742,12 @@\n+#if defined(VDBE_PROFILE)\n+  if( pnCycle ){\n+    *pnCycle += sqlite3NProfileCnt ? sqlite3NProfileCnt : sqlite3Hwtime();\n+    pnCycle = 0;\n+  }\n+#elif defined(SQLITE_ENABLE_STMT_SCANSTATUS)\n+  if( pnCycle ){\n+    *pnCycle += sqlite3Hwtime();\n+    pnCycle = 0;\n+  }\n+#endif\n+\n@@ -97071,1 +101765,3 @@\n-  sqlite3VdbeLeave(p);\n+  if( DbMaskNonZero(p->lockMask) ){\n+    sqlite3VdbeLeave(p);\n+  }\n@@ -97166,2 +101862,1 @@\n-  v->aMem[1].flags = MEM_Int;\n-  v->aMem[1].u.i = iRow;\n+  sqlite3VdbeMemSetInt64(&v->aMem[1], iRow);\n@@ -97250,1 +101945,1 @@\n-  if( !sqlite3SafetyCheckOk(db) || zTable==0 ){\n+  if( !sqlite3SafetyCheckOk(db) || zTable==0 || zColumn==0 ){\n@@ -97449,1 +102144,1 @@\n-  sqlite3ErrorWithMsg(db, rc, (zErr ? \"%s\" : 0), zErr);\n+  sqlite3ErrorWithMsg(db, rc, (zErr ? \"%s\" : (char*)0), zErr);\n@@ -97608,1 +102303,1 @@\n-      sqlite3ErrorWithMsg(db, rc, (zErr ? \"%s\" : 0), zErr);\n+      sqlite3ErrorWithMsg(db, rc, (zErr ? \"%s\" : (char*)0), zErr);\n@@ -97711,1 +102406,1 @@\n-** the value returned by \"PRAGMA main.page_size\" multipled by\n+** the value returned by \"PRAGMA main.page_size\" multiplied by\n@@ -97734,1 +102429,1 @@\n-** incrementally as keys are retreived from the sorter by the VDBE.  The\n+** incrementally as keys are retrieved from the sorter by the VDBE.  The\n@@ -97812,1 +102507,1 @@\n-  int szPMA;                      \/* Size of pList as PMA in bytes *\/\n+  i64 szPMA;                      \/* Size of pList as PMA in bytes *\/\n@@ -97897,1 +102592,1 @@\n-** each thread requries its own UnpackedRecord object to unpack records in\n+** each thread requeries its own UnpackedRecord object to unpack records in\n@@ -97921,0 +102616,1 @@\n+  int nPMA;                       \/* Number of PMAs currently in file *\/\n@@ -97924,1 +102620,0 @@\n-  int nPMA;                       \/* Number of PMAs currently in file *\/\n@@ -97969,1 +102664,1 @@\n-** and the key is copied into aAlloc and aKey is made to poitn to aAlloc.\n+** and the key is copied into aAlloc and aKey is made to point to aAlloc.\n@@ -99340,1 +104035,1 @@\n-  ** sub-tasks are prefered as they use background threads - the final\n+  ** sub-tasks are preferred as they use background threads - the final\n@@ -99398,2 +104093,2 @@\n-  int nReq;                       \/* Bytes of memory required *\/\n-  int nPMA;                       \/* Bytes of PMA space required *\/\n+  i64 nReq;                       \/* Bytes of memory required *\/\n+  i64 nPMA;                       \/* Bytes of PMA space required *\/\n@@ -99824,1 +104519,1 @@\n-  \/* Set up the required files for pIncr. A multi-theaded IncrMerge object\n+  \/* Set up the required files for pIncr. A multi-threaded IncrMerge object\n@@ -100464,0 +105159,2 @@\n+      \"nexec INT,\"\n+      \"ncycle INT,\"\n@@ -100478,0 +105175,3 @@\n+  (void)argc;\n+  (void)argv;\n+  (void)pzErr;\n@@ -100623,1 +105323,1 @@\n-      i += 10;\n+      i += 20;\n@@ -100673,1 +105373,16 @@\n-    case 10:  \/* tables_used.type *\/\n+\n+#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n+    case 9:     \/* nexec *\/\n+      sqlite3_result_int(ctx, pOp->nExec);\n+      break;\n+    case 10:    \/* ncycle *\/\n+      sqlite3_result_int(ctx, pOp->nCycle);\n+      break;\n+#else\n+    case 9:     \/* nexec *\/\n+    case 10:    \/* ncycle *\/\n+      sqlite3_result_int(ctx, 0);\n+      break;\n+#endif\n+\n+    case 20:  \/* tables_used.type *\/\n@@ -100676,1 +105391,1 @@\n-    case 11:  \/* tables_used.schema *\/\n+    case 21:  \/* tables_used.schema *\/\n@@ -100679,1 +105394,1 @@\n-    case 12:  \/* tables_used.name *\/\n+    case 22:  \/* tables_used.name *\/\n@@ -100682,1 +105397,1 @@\n-    case 13:  \/* tables_used.wr *\/\n+    case 23:  \/* tables_used.wr *\/\n@@ -100713,0 +105428,1 @@\n+  (void)idxStr;\n@@ -100755,1 +105471,1 @@\n-  int iBaseCol = pVTab->bTablesUsed ? 4 : 8;\n+  int iBaseCol = pVTab->bTablesUsed ? 4 : 10;\n@@ -100802,1 +105518,2 @@\n-  \/* xShadowName *\/ 0\n+  \/* xShadowName *\/ 0,\n+  \/* xIntegrity  *\/ 0\n@@ -101181,0 +105898,2 @@\n+  assert( zName || nSpill<0 || (flags & SQLITE_OPEN_EXCLUSIVE) );\n+\n@@ -101324,1 +106043,1 @@\n-static SQLITE_NOINLINE int walkExpr(Walker *pWalker, Expr *pExpr){\n+SQLITE_PRIVATE SQLITE_NOINLINE int sqlite3WalkExprNN(Walker *pWalker, Expr *pExpr){\n@@ -101333,1 +106052,3 @@\n-      if( pExpr->pLeft && walkExpr(pWalker, pExpr->pLeft) ) return WRC_Abort;\n+      if( pExpr->pLeft && sqlite3WalkExprNN(pWalker, pExpr->pLeft) ){\n+        return WRC_Abort;\n+      }\n@@ -101357,1 +106078,1 @@\n-  return pExpr ? walkExpr(pWalker,pExpr) : WRC_Continue;\n+  return pExpr ? sqlite3WalkExprNN(pWalker,pExpr) : WRC_Continue;\n@@ -101483,1 +106204,1 @@\n-** descrease when leaving the subquery.\n+** decrease when leaving the subquery.\n@@ -101602,0 +106323,2 @@\n+  assert( !ExprHasProperty(pExpr, EP_Reduced|EP_TokenOnly) );\n+  if( pExpr->pAggInfo ) return;\n@@ -101622,3 +106345,1 @@\n-    sqlite3ParserAddCleanup(pParse,\n-      (void(*)(sqlite3*,void*))sqlite3ExprDelete,\n-      pDup);\n+    sqlite3ExprDeferredDelete(pParse, pDup);\n@@ -101629,5 +106350,15 @@\n-** Subqueries stores the original database, table and column names for their\n-** result sets in ExprList.a[].zSpan, in the form \"DATABASE.TABLE.COLUMN\".\n-** Check to see if the zSpan given to this routine matches the zDb, zTab,\n-** and zCol.  If any of zDb, zTab, and zCol are NULL then those fields will\n-** match anything.\n+** Subqueries store the original database, table and column names for their\n+** result sets in ExprList.a[].zSpan, in the form \"DATABASE.TABLE.COLUMN\",\n+** and mark the expression-list item by setting ExprList.a[].fg.eEName\n+** to ENAME_TAB.\n+**\n+** Check to see if the zSpan\/eEName of the expression-list item passed to this\n+** routine matches the zDb, zTab, and zCol.  If any of zDb, zTab, and zCol are\n+** NULL then those fields will match anything. Return true if there is a match,\n+** or false otherwise.\n+**\n+** SF_NestedFrom subqueries also store an entry for the implicit rowid (or\n+** _rowid_, or oid) column by setting ExprList.a[].fg.eEName to ENAME_ROWID,\n+** and setting zSpan to \"DATABASE.TABLE.<rowid-alias>\". This type of pItem\n+** argument matches if zCol is a rowid alias. If it is not NULL, (*pbRowid)\n+** is set to 1 if there is this kind of match.\n@@ -101639,1 +106370,2 @@\n-  const char *zDb\n+  const char *zDb,\n+  int *pbRowid\n@@ -101643,1 +106375,5 @@\n-  if( pItem->fg.eEName!=ENAME_TAB ) return 0;\n+  int eEName = pItem->fg.eEName;\n+  if( eEName!=ENAME_TAB && (eEName!=ENAME_ROWID || NEVER(pbRowid==0)) ){\n+    return 0;\n+  }\n+  assert( pbRowid==0 || *pbRowid==0 );\n@@ -101655,2 +106391,3 @@\n-  if( zCol && sqlite3StrICmp(zSpan, zCol)!=0 ){\n-    return 0;\n+  if( zCol ){\n+    if( eEName==ENAME_TAB && sqlite3StrICmp(zSpan, zCol)!=0 ) return 0;\n+    if( eEName==ENAME_ROWID && sqlite3IsRowid(zCol)==0 ) return 0;\n@@ -101658,0 +106395,1 @@\n+  if( eEName==ENAME_ROWID ) *pbRowid = 1;\n@@ -101690,0 +106428,1 @@\n+  assert( n < pExTab->nCol );\n@@ -101727,0 +106466,26 @@\n+\/*\n+** Return TRUE (non-zero) if zTab is a valid name for the schema table pTab.\n+*\/\n+static SQLITE_NOINLINE int isValidSchemaTableName(\n+  const char *zTab,         \/* Name as it appears in the SQL *\/\n+  Table *pTab,              \/* The schema table we are trying to match *\/\n+  Schema *pSchema           \/* non-NULL if a database qualifier is present *\/\n+){\n+  const char *zLegacy;\n+  assert( pTab!=0 );\n+  assert( pTab->tnum==1 );\n+  if( sqlite3StrNICmp(zTab, \"sqlite_\", 7)!=0 ) return 0;\n+  zLegacy = pTab->zName;\n+  if( strcmp(zLegacy+7, &LEGACY_TEMP_SCHEMA_TABLE[7])==0 ){\n+    if( sqlite3StrICmp(zTab+7, &PREFERRED_TEMP_SCHEMA_TABLE[7])==0 ){\n+      return 1;\n+    }\n+    if( pSchema==0 ) return 0;\n+    if( sqlite3StrICmp(zTab+7, &LEGACY_SCHEMA_TABLE[7])==0 ) return 1;\n+    if( sqlite3StrICmp(zTab+7, &PREFERRED_SCHEMA_TABLE[7])==0 ) return 1;\n+  }else{\n+    if( sqlite3StrICmp(zTab+7, &PREFERRED_SCHEMA_TABLE[7])==0 ) return 1;\n+  }\n+  return 0;\n+}\n+\n@@ -101764,1 +106529,1 @@\n-  int cntTab = 0;                   \/* Number of matching table names *\/\n+  int cntTab = 0;                   \/* Number of potential \"rowid\" matches *\/\n@@ -101841,1 +106606,2 @@\n-            if( !sqlite3MatchEName(&pEList->a[j], zCol, zTab, zDb) ){\n+            int bRowid = 0;       \/* True if possible rowid match *\/\n+            if( !sqlite3MatchEName(&pEList->a[j], zCol, zTab, zDb, &bRowid) ){\n@@ -101844,22 +106610,24 @@\n-            if( cnt>0 ){\n-              if( pItem->fg.isUsing==0\n-               || sqlite3IdListIndex(pItem->u3.pUsing, zCol)<0\n-              ){\n-                \/* Two or more tables have the same column name which is\n-                ** not joined by USING.  This is an error.  Signal as much\n-                ** by clearing pFJMatch and letting cnt go above 1. *\/\n-                sqlite3ExprListDelete(db, pFJMatch);\n-                pFJMatch = 0;\n-              }else\n-              if( (pItem->fg.jointype & JT_RIGHT)==0 ){\n-                \/* An INNER or LEFT JOIN.  Use the left-most table *\/\n-                continue;\n-              }else\n-              if( (pItem->fg.jointype & JT_LEFT)==0 ){\n-                \/* A RIGHT JOIN.  Use the right-most table *\/\n-                cnt = 0;\n-                sqlite3ExprListDelete(db, pFJMatch);\n-                pFJMatch = 0;\n-              }else{\n-                \/* For a FULL JOIN, we must construct a coalesce() func *\/\n-                extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n+            if( bRowid==0 ){\n+              if( cnt>0 ){\n+                if( pItem->fg.isUsing==0\n+                 || sqlite3IdListIndex(pItem->u3.pUsing, zCol)<0\n+                ){\n+                  \/* Two or more tables have the same column name which is\n+                  ** not joined by USING.  This is an error.  Signal as much\n+                  ** by clearing pFJMatch and letting cnt go above 1. *\/\n+                  sqlite3ExprListDelete(db, pFJMatch);\n+                  pFJMatch = 0;\n+                }else\n+                if( (pItem->fg.jointype & JT_RIGHT)==0 ){\n+                  \/* An INNER or LEFT JOIN.  Use the left-most table *\/\n+                  continue;\n+                }else\n+                if( (pItem->fg.jointype & JT_LEFT)==0 ){\n+                  \/* A RIGHT JOIN.  Use the right-most table *\/\n+                  cnt = 0;\n+                  sqlite3ExprListDelete(db, pFJMatch);\n+                  pFJMatch = 0;\n+                }else{\n+                  \/* For a FULL JOIN, we must construct a coalesce() func *\/\n+                  extendFJMatch(pParse, &pFJMatch, pMatch, pExpr->iColumn);\n+                }\n@@ -101867,0 +106635,6 @@\n+              cnt++;\n+              hit = 1;\n+            }else if( cnt>0 ){\n+              \/* This is a potential rowid match, but there has already been\n+              ** a real match found. So this can be ignored.  *\/\n+              continue;\n@@ -101868,2 +106642,1 @@\n-            cnt++;\n-            cntTab = 2;\n+            cntTab++;\n@@ -101873,1 +106646,3 @@\n-            hit = 1;\n+\n+            \/* rowid cannot be part of a USING clause - assert() this. *\/\n+            assert( bRowid==0 || pEList->a[j].fg.bUsingTerm==0 );\n@@ -101880,1 +106655,0 @@\n-          const char *zTabName;\n@@ -101885,4 +106659,7 @@\n-          zTabName = pItem->zAlias ? pItem->zAlias : pTab->zName;\n-          assert( zTabName!=0 );\n-          if( sqlite3StrICmp(zTabName, zTab)!=0 ){\n-            continue;\n+          if( pItem->zAlias!=0 ){\n+            if( sqlite3StrICmp(zTab, pItem->zAlias)!=0 ){\n+              continue;\n+            }\n+          }else if( sqlite3StrICmp(zTab, pTab->zName)!=0 ){\n+            if( pTab->tnum!=1 ) continue;\n+            if( !isValidSchemaTableName(zTab, pTab, pSchema) ) continue;\n@@ -101935,0 +106712,28 @@\n+          \/* pTab is a potential ROWID match.  Keep track of it and match\n+          ** the ROWID later if that seems appropriate.  (Search for \"cntTab\"\n+          ** to find related code.)  Only allow a ROWID match if there is\n+          ** a single ROWID match candidate.\n+          *\/\n+#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n+          \/* In SQLITE_ALLOW_ROWID_IN_VIEW mode, allow a ROWID match\n+          ** if there is a single VIEW candidate or if there is a single\n+          ** non-VIEW candidate plus multiple VIEW candidates.  In other\n+          ** words non-VIEW candidate terms take precedence over VIEWs.\n+          *\/\n+          if( cntTab==0\n+           || (cntTab==1\n+               && ALWAYS(pMatch!=0)\n+               && ALWAYS(pMatch->pTab!=0)\n+               && (pMatch->pTab->tabFlags & TF_Ephemeral)!=0\n+               && (pTab->tabFlags & TF_Ephemeral)==0)\n+          ){\n+            cntTab = 1;\n+            pMatch = pItem;\n+          }else{\n+            cntTab++;\n+          }\n+#else\n+          \/* The (much more common) non-SQLITE_ALLOW_ROWID_IN_VIEW case is\n+          ** simpler since we require exactly one candidate, which will\n+          ** always be a non-VIEW\n+          *\/\n@@ -101937,0 +106742,1 @@\n+#endif\n@@ -101964,1 +106770,2 @@\n-           && (zTab==0 || sqlite3StrICmp(zTab,pParse->pTriggerTab->zName)==0)\n+           && ALWAYS(zTab==0\n+                     || sqlite3StrICmp(zTab,pParse->pTriggerTab->zName)==0)\n@@ -102031,0 +106838,1 @@\n+              pExpr->iColumn = iCol;\n@@ -102060,1 +106868,1 @@\n-     && cntTab==1\n+     && cntTab>=1\n@@ -102064,1 +106872,1 @@\n-     && ALWAYS(VisibleRowid(pMatch->pTab))\n+     && ALWAYS(VisibleRowid(pMatch->pTab) || pMatch->fg.isNestedFrom)\n@@ -102066,2 +106874,2 @@\n-      cnt = 1;\n-      pExpr->iColumn = -1;\n+      cnt = cntTab;\n+      if( pMatch->fg.isNestedFrom==0 ) pExpr->iColumn = -1;\n@@ -102226,0 +107034,1 @@\n+    eNewExprOp = TK_NULL;\n@@ -102252,1 +107061,1 @@\n-  if( pExpr->iColumn>=0 && pMatch!=0 ){\n+  if( pExpr->iColumn>=0 && cnt==1 && pMatch!=0 ){\n@@ -102430,0 +107239,13 @@\n+    **\n+    ** 2024-03-28: Beware of aggregates.  A bare column of aggregated table\n+    ** can still evaluate to NULL even though it is marked as NOT NULL.\n+    ** Example:\n+    **\n+    **       CREATE TABLE t1(a INT NOT NULL);\n+    **       SELECT a, a IS NULL, a IS NOT NULL, count(*) FROM t1;\n+    **\n+    ** The \"a IS NULL\" and \"a IS NOT NULL\" expressions cannot be optimized\n+    ** here because at the time this case is hit, we do not yet know whether\n+    ** or not t1 is being aggregated.  We have to assume the worst and omit\n+    ** the optimization.  The only time it is safe to apply this optimization\n+    ** is within the WHERE clause.\n@@ -102440,13 +107262,9 @@\n-      if( 0==sqlite3ExprCanBeNull(pExpr->pLeft) && !IN_RENAME_OBJECT ){\n-        testcase( ExprHasProperty(pExpr, EP_OuterON) );\n-        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n-        if( pExpr->op==TK_NOTNULL ){\n-          pExpr->u.zToken = \"true\";\n-          ExprSetProperty(pExpr, EP_IsTrue);\n-        }else{\n-          pExpr->u.zToken = \"false\";\n-          ExprSetProperty(pExpr, EP_IsFalse);\n-        }\n-        pExpr->op = TK_TRUEFALSE;\n-        for(i=0, p=pNC; p && i<ArraySize(anRef); p=p->pNext, i++){\n-          p->nRef = anRef[i];\n+      if( IN_RENAME_OBJECT ) return WRC_Prune;\n+      if( sqlite3ExprCanBeNull(pExpr->pLeft) ){\n+        \/* The expression can be NULL.  So the optimization does not apply *\/\n+        return WRC_Prune;\n+      }\n+\n+      for(i=0, p=pNC; p; p=p->pNext, i++){\n+        if( (p->ncFlags & NC_Where)==0 ){\n+          return WRC_Prune;  \/* Not in a WHERE clause.  Unsafe to optimize. *\/\n@@ -102454,2 +107272,0 @@\n-        sqlite3ExprDelete(pParse->db, pExpr->pLeft);\n-        pExpr->pLeft = 0;\n@@ -102457,0 +107273,19 @@\n+      testcase( ExprHasProperty(pExpr, EP_OuterON) );\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n+#if TREETRACE_ENABLED\n+      if( sqlite3TreeTrace & 0x80000 ){\n+        sqlite3DebugPrintf(\n+           \"NOT NULL strength reduction converts the following to %d:\\n\",\n+           pExpr->op==TK_NOTNULL\n+        );\n+        sqlite3ShowExpr(pExpr);\n+      }\n+#endif \/* TREETRACE_ENABLED *\/\n+      pExpr->u.iValue = (pExpr->op==TK_NOTNULL);\n+      pExpr->flags |= EP_IntValue;\n+      pExpr->op = TK_INTEGER;\n+      for(i=0, p=pNC; p && i<ArraySize(anRef); p=p->pNext, i++){\n+        p->nRef = anRef[i];\n+      }\n+      sqlite3ExprDelete(pParse->db, pExpr->pLeft);\n+      pExpr->pLeft = 0;\n@@ -102524,0 +107359,1 @@\n+      assert( pExpr->pLeft==0 || pExpr->pLeft->op==TK_ORDER );\n@@ -102665,0 +107501,4 @@\n+        else if( is_agg==0 && pExpr->pLeft ){\n+          sqlite3ExprOrderByAggregateError(pParse, pExpr);\n+          pNC->nNcErr++;\n+        }\n@@ -102683,0 +107523,5 @@\n+        if( pExpr->pLeft ){\n+          assert( pExpr->pLeft->op==TK_ORDER );\n+          assert( ExprUseXList(pExpr->pLeft) );\n+          sqlite3WalkExprList(pWalker, pExpr->pLeft->x.pList);\n+        }\n@@ -102711,1 +107556,1 @@\n-            pExpr->op2++;\n+            pExpr->op2 += (1 + pNC2->nNestedSelect);\n@@ -102716,0 +107561,1 @@\n+            pExpr->op2 += pNC2->nNestedSelect;\n@@ -102752,1 +107598,0 @@\n-          pNC->ncFlags |= NC_VarSelect;\n@@ -102754,0 +107599,1 @@\n+        pNC->ncFlags |= NC_Subquery;\n@@ -103193,1 +108039,1 @@\n-        \/* Since this expresion is being changed into a reference\n+        \/* Since this expression is being changed into a reference\n@@ -103246,1 +108092,0 @@\n-    assert( db->suppressErr==0 ); \/* SF_Resolved not set if errors suppressed *\/\n@@ -103249,1 +108094,0 @@\n-\n@@ -103276,0 +108120,1 @@\n+    if( pOuterNC ) pOuterNC->nNestedSelect++;\n@@ -103300,0 +108145,3 @@\n+    if( pOuterNC && ALWAYS(pOuterNC->nNestedSelect>0) ){\n+      pOuterNC->nNestedSelect--;\n+    }\n@@ -103343,0 +108191,1 @@\n+    sNC.ncFlags |= NC_Where;\n@@ -103344,0 +108193,1 @@\n+    sNC.ncFlags &= ~NC_Where;\n@@ -103516,1 +108366,2 @@\n-  sqlite3WalkExpr(&w, pExpr);\n+  assert( pExpr!=0 );\n+  sqlite3WalkExprNN(&w, pExpr);\n@@ -103558,1 +108409,1 @@\n-    sqlite3WalkExpr(&w, pExpr);\n+    sqlite3WalkExprNN(&w, pExpr);\n@@ -103580,1 +108431,1 @@\n-** decendents of the SELECT, including compounds off of p->pPrior,\n+** descendants of the SELECT, including compounds off of p->pPrior,\n@@ -103707,7 +108558,0 @@\n-  while( ExprHasProperty(pExpr, EP_Skip|EP_IfNullRow) ){\n-    assert( pExpr->op==TK_COLLATE\n-         || pExpr->op==TK_IF_NULL_ROW\n-         || (pExpr->op==TK_REGISTER && pExpr->op2==TK_IF_NULL_ROW) );\n-    pExpr = pExpr->pLeft;\n-    assert( pExpr!=0 );\n-  }\n@@ -103715,4 +108559,4 @@\n-  if( op==TK_REGISTER ) op = pExpr->op2;\n-  if( op==TK_COLUMN || op==TK_AGG_COLUMN ){\n-    assert( ExprUseYTab(pExpr) );\n-    if( pExpr->y.pTab ){\n+  while( 1 \/* exit-by-break *\/ ){\n+    if( op==TK_COLUMN || (op==TK_AGG_COLUMN && pExpr->y.pTab!=0) ){\n+      assert( ExprUseYTab(pExpr) );\n+      assert( pExpr->y.pTab!=0 );\n@@ -103721,8 +108565,7 @@\n-  }\n-  if( op==TK_SELECT ){\n-    assert( ExprUseXSelect(pExpr) );\n-    assert( pExpr->x.pSelect!=0 );\n-    assert( pExpr->x.pSelect->pEList!=0 );\n-    assert( pExpr->x.pSelect->pEList->a[0].pExpr!=0 );\n-    return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);\n-  }\n+    if( op==TK_SELECT ){\n+      assert( ExprUseXSelect(pExpr) );\n+      assert( pExpr->x.pSelect!=0 );\n+      assert( pExpr->x.pSelect->pEList!=0 );\n+      assert( pExpr->x.pSelect->pEList->a[0].pExpr!=0 );\n+      return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);\n+    }\n@@ -103730,4 +108573,4 @@\n-  if( op==TK_CAST ){\n-    assert( !ExprHasProperty(pExpr, EP_IntValue) );\n-    return sqlite3AffinityType(pExpr->u.zToken, 0);\n-  }\n+    if( op==TK_CAST ){\n+      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n+      return sqlite3AffinityType(pExpr->u.zToken, 0);\n+    }\n@@ -103735,11 +108578,22 @@\n-  if( op==TK_SELECT_COLUMN ){\n-    assert( pExpr->pLeft!=0 && ExprUseXSelect(pExpr->pLeft) );\n-    assert( pExpr->iColumn < pExpr->iTable );\n-    assert( pExpr->iTable==pExpr->pLeft->x.pSelect->pEList->nExpr );\n-    return sqlite3ExprAffinity(\n-        pExpr->pLeft->x.pSelect->pEList->a[pExpr->iColumn].pExpr\n-    );\n-  }\n-  if( op==TK_VECTOR ){\n-    assert( ExprUseXList(pExpr) );\n-    return sqlite3ExprAffinity(pExpr->x.pList->a[0].pExpr);\n+    if( op==TK_SELECT_COLUMN ){\n+      assert( pExpr->pLeft!=0 && ExprUseXSelect(pExpr->pLeft) );\n+      assert( pExpr->iColumn < pExpr->iTable );\n+      assert( pExpr->iColumn >= 0 );\n+      assert( pExpr->iTable==pExpr->pLeft->x.pSelect->pEList->nExpr );\n+      return sqlite3ExprAffinity(\n+          pExpr->pLeft->x.pSelect->pEList->a[pExpr->iColumn].pExpr\n+      );\n+    }\n+    if( op==TK_VECTOR ){\n+      assert( ExprUseXList(pExpr) );\n+      return sqlite3ExprAffinity(pExpr->x.pList->a[0].pExpr);\n+    }\n+    if( ExprHasProperty(pExpr, EP_Skip|EP_IfNullRow) ){\n+      assert( pExpr->op==TK_COLLATE\n+           || pExpr->op==TK_IF_NULL_ROW\n+           || (pExpr->op==TK_REGISTER && pExpr->op2==TK_IF_NULL_ROW) );\n+      pExpr = pExpr->pLeft;\n+      op = pExpr->op;\n+      continue;\n+    }\n+    if( op!=TK_REGISTER || (op = pExpr->op2)==TK_REGISTER ) break;\n@@ -103750,0 +108604,70 @@\n+\/*\n+** Make a guess at all the possible datatypes of the result that could\n+** be returned by an expression.  Return a bitmask indicating the answer:\n+**\n+**     0x01         Numeric\n+**     0x02         Text\n+**     0x04         Blob\n+**\n+** If the expression must return NULL, then 0x00 is returned.\n+*\/\n+SQLITE_PRIVATE int sqlite3ExprDataType(const Expr *pExpr){\n+  while( pExpr ){\n+    switch( pExpr->op ){\n+      case TK_COLLATE:\n+      case TK_IF_NULL_ROW:\n+      case TK_UPLUS:  {\n+        pExpr = pExpr->pLeft;\n+        break;\n+      }\n+      case TK_NULL: {\n+        pExpr = 0;\n+        break;\n+      }\n+      case TK_STRING: {\n+        return 0x02;\n+      }\n+      case TK_BLOB: {\n+        return 0x04;\n+      }\n+      case TK_CONCAT: {\n+        return 0x06;\n+      }\n+      case TK_VARIABLE:\n+      case TK_AGG_FUNCTION:\n+      case TK_FUNCTION: {\n+        return 0x07;\n+      }\n+      case TK_COLUMN:\n+      case TK_AGG_COLUMN:\n+      case TK_SELECT:\n+      case TK_CAST:\n+      case TK_SELECT_COLUMN:\n+      case TK_VECTOR:  {\n+        int aff = sqlite3ExprAffinity(pExpr);\n+        if( aff>=SQLITE_AFF_NUMERIC ) return 0x05;\n+        if( aff==SQLITE_AFF_TEXT )    return 0x06;\n+        return 0x07;\n+      }\n+      case TK_CASE: {\n+        int res = 0;\n+        int ii;\n+        ExprList *pList = pExpr->x.pList;\n+        assert( ExprUseXList(pExpr) && pList!=0 );\n+        assert( pList->nExpr > 0);\n+        for(ii=1; ii<pList->nExpr; ii+=2){\n+          res |= sqlite3ExprDataType(pList->a[ii].pExpr);\n+        }\n+        if( pList->nExpr % 2 ){\n+          res |= sqlite3ExprDataType(pList->a[pList->nExpr-1].pExpr);\n+        }\n+        return res;\n+      }\n+      default: {\n+        return 0x01;\n+      }\n+    } \/* End of switch(op) *\/\n+  } \/* End of while(pExpr) *\/\n+  return 0x00;\n+}\n+\n@@ -103808,2 +108732,1 @@\n-    }else{\n-      assert( pExpr->op==TK_COLLATE );\n+    }else if( pExpr->op==TK_COLLATE ){\n@@ -103811,0 +108734,2 @@\n+    }else{\n+      break;\n@@ -103837,1 +108762,4 @@\n-    if( op==TK_AGG_COLUMN || op==TK_COLUMN || op==TK_TRIGGER ){\n+    if( (op==TK_AGG_COLUMN && p->y.pTab!=0)\n+     || op==TK_COLUMN || op==TK_TRIGGER\n+    ){\n+      int j;\n@@ -103839,9 +108767,4 @@\n-      if( p->y.pTab!=0 ){\n-        \/* op==TK_REGISTER && p->y.pTab!=0 happens when pExpr was originally\n-        ** a TK_COLUMN but was previously evaluated and cached in a register *\/\n-        int j = p->iColumn;\n-        if( j>=0 ){\n-          const char *zColl = sqlite3ColumnColl(&p->y.pTab->aCol[j]);\n-          pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);\n-        }\n-        break;\n+      assert( p->y.pTab!=0 );\n+      if( (j = p->iColumn)>=0 ){\n+        const char *zColl = sqlite3ColumnColl(&p->y.pTab->aCol[j]);\n+        pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);\n@@ -103849,0 +108772,1 @@\n+      break;\n@@ -103870,3 +108794,2 @@\n-        assert( ExprUseXList(p) );\n-        assert( p->x.pList==0 || p->pRight==0 );\n-        if( p->x.pList!=0 && !db->mallocFailed ){\n+        assert( !ExprUseXList(p) || p->x.pList==0 || p->pRight==0 );\n+        if( ExprUseXList(p) && p->x.pList!=0 && !db->mallocFailed ){\n@@ -103874,1 +108797,1 @@\n-          for(i=0; ALWAYS(i<p->x.pList->nExpr); i++){\n+          for(i=0; i<p->x.pList->nExpr; i++){\n@@ -103896,1 +108819,1 @@\n-** defautl collation sequence.\n+** default collation sequence.\n@@ -104026,1 +108949,1 @@\n-\/* Expresssion p is a comparison operator.  Return a collation sequence\n+\/* Expression p is a comparison operator.  Return a collation sequence\n@@ -104183,0 +109106,1 @@\n+      ExprSetProperty(pRet, EP_FullSize);\n@@ -104433,1 +109357,3 @@\n-  if( p->pRight && p->pRight->nHeight>nHeight ) nHeight = p->pRight->nHeight;\n+  if( NEVER(p->pRight) && p->pRight->nHeight>nHeight ){\n+    nHeight = p->pRight->nHeight;\n+  }\n@@ -104480,0 +109406,9 @@\n+\/*\n+** Set the error offset for an Expr node, if possible.\n+*\/\n+SQLITE_PRIVATE void sqlite3ExprSetErrorOffset(Expr *pExpr, int iOfst){\n+  if( pExpr==0 ) return;\n+  if( NEVER(ExprUseWJoin(pExpr)) ) return;\n+  pExpr->w.iOfst = iOfst;\n+}\n+\n@@ -104576,0 +109511,2 @@\n+    assert( ExprUseXList(pRoot) );\n+    assert( pRoot->x.pSelect==0 );\n@@ -104579,0 +109516,5 @@\n+#if SQLITE_MAX_EXPR_DEPTH>0\n+      pRoot->nHeight = pRight->nHeight+1;\n+    }else{\n+      pRoot->nHeight = 1;\n+#endif\n@@ -104583,0 +109525,5 @@\n+#if SQLITE_MAX_EXPR_DEPTH>0\n+      if( pLeft->nHeight>=pRoot->nHeight ){\n+        pRoot->nHeight = pLeft->nHeight+1;\n+      }\n+#endif\n@@ -104584,1 +109531,0 @@\n-    exprSetHeight(pRoot);\n@@ -104693,3 +109639,3 @@\n-** If one side or the other of the AND is known to be false, then instead\n-** of returning an AND expression, just return a constant expression with\n-** a value of false.\n+** If one side or the other of the AND is known to be false, and neither side\n+** is part of an ON clause, then instead of returning an AND expression,\n+** just return a constant expression with a value of false.\n@@ -104703,6 +109649,0 @@\n-  }else if( (ExprAlwaysFalse(pLeft) || ExprAlwaysFalse(pRight))\n-         && !IN_RENAME_OBJECT\n-  ){\n-    sqlite3ExprDeferredDelete(pParse, pLeft);\n-    sqlite3ExprDeferredDelete(pParse, pRight);\n-    return sqlite3Expr(db, TK_INTEGER, \"0\");\n@@ -104710,1 +109650,10 @@\n-    return sqlite3PExpr(pParse, TK_AND, pLeft, pRight);\n+    u32 f = pLeft->flags | pRight->flags;\n+    if( (f&(EP_OuterON|EP_InnerON|EP_IsFalse))==EP_IsFalse\n+     && !IN_RENAME_OBJECT\n+    ){\n+      sqlite3ExprDeferredDelete(pParse, pLeft);\n+      sqlite3ExprDeferredDelete(pParse, pRight);\n+      return sqlite3Expr(db, TK_INTEGER, \"0\");\n+    }else{\n+      return sqlite3PExpr(pParse, TK_AND, pLeft, pRight);\n+    }\n@@ -104748,0 +109697,61 @@\n+\/*\n+** Report an error when attempting to use an ORDER BY clause within\n+** the arguments of a non-aggregate function.\n+*\/\n+SQLITE_PRIVATE void sqlite3ExprOrderByAggregateError(Parse *pParse, Expr *p){\n+  sqlite3ErrorMsg(pParse,\n+     \"ORDER BY may not be used with non-aggregate %#T()\", p\n+  );\n+}\n+\n+\/*\n+** Attach an ORDER BY clause to a function call.\n+**\n+**     functionname( arguments ORDER BY sortlist )\n+**     \\_____________________\/          \\______\/\n+**             pExpr                    pOrderBy\n+**\n+** The ORDER BY clause is inserted into a new Expr node of type TK_ORDER\n+** and added to the Expr.pLeft field of the parent TK_FUNCTION node.\n+*\/\n+SQLITE_PRIVATE void sqlite3ExprAddFunctionOrderBy(\n+  Parse *pParse,        \/* Parsing context *\/\n+  Expr *pExpr,          \/* The function call to which ORDER BY is to be added *\/\n+  ExprList *pOrderBy    \/* The ORDER BY clause to add *\/\n+){\n+  Expr *pOB;\n+  sqlite3 *db = pParse->db;\n+  if( NEVER(pOrderBy==0) ){\n+    assert( db->mallocFailed );\n+    return;\n+  }\n+  if( pExpr==0 ){\n+    assert( db->mallocFailed );\n+    sqlite3ExprListDelete(db, pOrderBy);\n+    return;\n+  }\n+  assert( pExpr->op==TK_FUNCTION );\n+  assert( pExpr->pLeft==0 );\n+  assert( ExprUseXList(pExpr) );\n+  if( pExpr->x.pList==0 || NEVER(pExpr->x.pList->nExpr==0) ){\n+    \/* Ignore ORDER BY on zero-argument aggregates *\/\n+    sqlite3ParserAddCleanup(pParse, sqlite3ExprListDeleteGeneric, pOrderBy);\n+    return;\n+  }\n+  if( IsWindowFunc(pExpr) ){\n+    sqlite3ExprOrderByAggregateError(pParse, pExpr);\n+    sqlite3ExprListDelete(db, pOrderBy);\n+    return;\n+  }\n+\n+  pOB = sqlite3ExprAlloc(db, TK_ORDER, 0, 0);\n+  if( pOB==0 ){\n+    sqlite3ExprListDelete(db, pOrderBy);\n+    return;\n+  }\n+  pOB->x.pList = pOrderBy;\n+  assert( ExprUseXList(pOB) );\n+  pExpr->pLeft = pOB;\n+  ExprSetProperty(pOB, EP_FullSize);\n+}\n+\n@@ -104870,0 +109880,1 @@\n+  assert( db!=0 );\n@@ -104901,4 +109912,0 @@\n-  if( ExprHasProperty(p, EP_MemToken) ){\n-    assert( !ExprHasProperty(p, EP_IntValue) );\n-    sqlite3DbFree(db, p->u.zToken);\n-  }\n@@ -104906,1 +109913,1 @@\n-    sqlite3DbFreeNN(db, p);\n+    sqlite3DbNNFreeNN(db, p);\n@@ -104912,0 +109919,3 @@\n+SQLITE_PRIVATE void sqlite3ExprDeleteGeneric(sqlite3 *db, void *p){\n+  if( ALWAYS(p) ) sqlite3ExprDeleteNN(db, (Expr*)p);\n+}\n@@ -104929,1 +109939,1 @@\n-** deferred untilthe pParse is deleted.\n+** deferred until the pParse is deleted.\n@@ -104937,2 +109947,1 @@\n-  pParse->pConstExpr =\n-      sqlite3ExprListAppend(pParse, pParse->pConstExpr, pExpr);\n+  sqlite3ParserAddCleanup(pParse, sqlite3ExprDeleteGeneric, pExpr);\n@@ -105003,5 +110012,1 @@\n-  if( 0==flags || p->op==TK_SELECT_COLUMN\n-#ifndef SQLITE_OMIT_WINDOWFUNC\n-   || ExprHasProperty(p, EP_WinFunc)\n-#endif\n-  ){\n+  if( 0==flags || ExprHasProperty(p, EP_FullSize) ){\n@@ -105012,1 +110017,0 @@\n-    assert( !ExprHasProperty(p, EP_MemToken) );\n@@ -105039,2 +110043,1 @@\n-** expression passed as the first argument. The second argument is a\n-** mask containing EXPRDUP_XXX flags.\n+** expression passed as the first argument.\n@@ -105045,4 +110048,3 @@\n-** If the EXPRDUP_REDUCE flag is set, then the return value includes\n-** space to duplicate all Expr nodes in the tree formed by Expr.pLeft\n-** and Expr.pRight variables (but not for any structures pointed to or\n-** descended from the Expr.x.pList or Expr.x.pSelect variables).\n+** The return value includes space to duplicate all Expr nodes in the\n+** tree formed by Expr.pLeft and Expr.pRight, but not any other\n+** substructure such as Expr.x.pList, Expr.x.pSelect, and Expr.y.pWin.\n@@ -105050,8 +110052,7 @@\n-static int dupedExprSize(const Expr *p, int flags){\n-  int nByte = 0;\n-  if( p ){\n-    nByte = dupedExprNodeSize(p, flags);\n-    if( flags&EXPRDUP_REDUCE ){\n-      nByte += dupedExprSize(p->pLeft, flags) + dupedExprSize(p->pRight, flags);\n-    }\n-  }\n+static int dupedExprSize(const Expr *p){\n+  int nByte;\n+  assert( p!=0 );\n+  nByte = dupedExprNodeSize(p, EXPRDUP_REDUCE);\n+  if( p->pLeft ) nByte += dupedExprSize(p->pLeft);\n+  if( p->pRight ) nByte += dupedExprSize(p->pRight);\n+  assert( nByte==ROUND8(nByte) );\n@@ -105062,6 +110063,6 @@\n-** This function is similar to sqlite3ExprDup(), except that if pzBuffer\n-** is not NULL then *pzBuffer is assumed to point to a buffer large enough\n-** to store the copy of expression p, the copies of p->u.zToken\n-** (if applicable), and the copies of the p->pLeft and p->pRight expressions,\n-** if any. Before returning, *pzBuffer is set to the first byte past the\n-** portion of the buffer copied into by this function.\n+** An EdupBuf is a memory allocation used to stored multiple Expr objects\n+** together with their Expr.zToken content.  This is used to help implement\n+** compression while doing sqlite3ExprDup().  The top-level Expr does the\n+** allocation for itself and many of its decendents, then passes an instance\n+** of the structure down into exprDup() so that they decendents can have\n+** access to that memory.\n@@ -105069,1 +110070,20 @@\n-static Expr *exprDup(sqlite3 *db, const Expr *p, int dupFlags, u8 **pzBuffer){\n+typedef struct EdupBuf EdupBuf;\n+struct EdupBuf {\n+  u8 *zAlloc;          \/* Memory space available for storage *\/\n+#ifdef SQLITE_DEBUG\n+  u8 *zEnd;            \/* First byte past the end of memory *\/\n+#endif\n+};\n+\n+\/*\n+** This function is similar to sqlite3ExprDup(), except that if pEdupBuf\n+** is not NULL then it points to memory that can be used to store a copy\n+** of the input Expr p together with its p->u.zToken (if any).  pEdupBuf\n+** is updated with the new buffer tail prior to returning.\n+*\/\n+static Expr *exprDup(\n+  sqlite3 *db,          \/* Database connection (for memory allocation) *\/\n+  const Expr *p,        \/* Expr tree to be duplicated *\/\n+  int dupFlags,         \/* EXPRDUP_REDUCE for compression.  0 if not *\/\n+  EdupBuf *pEdupBuf     \/* Preallocated storage space, or NULL *\/\n+){\n@@ -105071,1 +110091,1 @@\n-  u8 *zAlloc;           \/* Memory space from which to build Expr object *\/\n+  EdupBuf sEdupBuf;     \/* Memory space from which to build Expr object *\/\n@@ -105073,0 +110093,1 @@\n+  int nToken = -1;       \/* Space needed for p->u.zToken.  -1 means unknown *\/\n@@ -105077,1 +110098,1 @@\n-  assert( pzBuffer==0 || dupFlags==EXPRDUP_REDUCE );\n+  assert( pEdupBuf==0 || dupFlags==EXPRDUP_REDUCE );\n@@ -105080,2 +110101,5 @@\n-  if( pzBuffer ){\n-    zAlloc = *pzBuffer;\n+  if( pEdupBuf ){\n+    sEdupBuf.zAlloc = pEdupBuf->zAlloc;\n+#ifdef SQLITE_DEBUG\n+    sEdupBuf.zEnd = pEdupBuf->zEnd;\n+#endif\n@@ -105083,1 +110107,2 @@\n-    assert( zAlloc!=0 );\n+    assert( sEdupBuf.zAlloc!=0 );\n+    assert( dupFlags==EXPRDUP_REDUCE );\n@@ -105085,1 +110110,16 @@\n-    zAlloc = sqlite3DbMallocRawNN(db, dupedExprSize(p, dupFlags));\n+    int nAlloc;\n+    if( dupFlags ){\n+      nAlloc = dupedExprSize(p);\n+    }else if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){\n+      nToken = sqlite3Strlen30NN(p->u.zToken)+1;\n+      nAlloc = ROUND8(EXPR_FULLSIZE + nToken);\n+    }else{\n+      nToken = 0;\n+      nAlloc = ROUND8(EXPR_FULLSIZE);\n+    }\n+    assert( nAlloc==ROUND8(nAlloc) );\n+    sEdupBuf.zAlloc = sqlite3DbMallocRawNN(db, nAlloc);\n+#ifdef SQLITE_DEBUG\n+    sEdupBuf.zEnd = sEdupBuf.zAlloc ? sEdupBuf.zAlloc+nAlloc : 0;\n+#endif\n+\n@@ -105088,1 +110128,2 @@\n-  pNew = (Expr *)zAlloc;\n+  pNew = (Expr *)sEdupBuf.zAlloc;\n+  assert( EIGHT_BYTE_ALIGNMENT(pNew) );\n@@ -105097,6 +110138,7 @@\n-    const int nNewSize = nStructSize & 0xfff;\n-    int nToken;\n-    if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){\n-      nToken = sqlite3Strlen30(p->u.zToken) + 1;\n-    }else{\n-      nToken = 0;\n+    int nNewSize = nStructSize & 0xfff;\n+    if( nToken<0 ){\n+      if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){\n+        nToken = sqlite3Strlen30(p->u.zToken) + 1;\n+      }else{\n+        nToken = 0;\n+      }\n@@ -105105,0 +110147,1 @@\n+      assert( (int)(sEdupBuf.zEnd - sEdupBuf.zAlloc) >= nNewSize+nToken );\n@@ -105106,1 +110149,1 @@\n-      memcpy(zAlloc, p, nNewSize);\n+      memcpy(sEdupBuf.zAlloc, p, nNewSize);\n@@ -105109,1 +110152,3 @@\n-      memcpy(zAlloc, p, nSize);\n+      assert( (int)(sEdupBuf.zEnd - sEdupBuf.zAlloc) >=\n+                                                   (int)EXPR_FULLSIZE+nToken );\n+      memcpy(sEdupBuf.zAlloc, p, nSize);\n@@ -105111,1 +110156,1 @@\n-        memset(&zAlloc[nSize], 0, EXPR_FULLSIZE-nSize);\n+        memset(&sEdupBuf.zAlloc[nSize], 0, EXPR_FULLSIZE-nSize);\n@@ -105113,0 +110158,1 @@\n+      nNewSize = EXPR_FULLSIZE;\n@@ -105116,1 +110162,1 @@\n-    pNew->flags &= ~(EP_Reduced|EP_TokenOnly|EP_Static|EP_MemToken);\n+    pNew->flags &= ~(EP_Reduced|EP_TokenOnly|EP_Static);\n@@ -105125,2 +110171,3 @@\n-    if( nToken ){\n-      char *zToken = pNew->u.zToken = (char*)&zAlloc[nNewSize];\n+    assert( nToken>=0 );\n+    if( nToken>0 ){\n+      char *zToken = pNew->u.zToken = (char*)&sEdupBuf.zAlloc[nNewSize];\n@@ -105128,0 +110175,1 @@\n+      nNewSize += nToken;\n@@ -105129,0 +110177,3 @@\n+    sEdupBuf.zAlloc += ROUND8(nNewSize);\n+\n+    if( ((p->flags|pNew->flags)&(EP_TokenOnly|EP_Leaf))==0 ){\n@@ -105130,1 +110181,0 @@\n-    if( 0==((p->flags|pNew->flags) & (EP_TokenOnly|EP_Leaf)) ){\n@@ -105135,1 +110185,2 @@\n-        pNew->x.pList = sqlite3ExprListDup(db, p->x.pList, dupFlags);\n+        pNew->x.pList = sqlite3ExprListDup(db, p->x.pList,\n+                           p->op!=TK_ORDER ? dupFlags : 0);\n@@ -105137,1 +110188,0 @@\n-    }\n@@ -105139,9 +110189,0 @@\n-    \/* Fill in pNew->pLeft and pNew->pRight. *\/\n-    if( ExprHasProperty(pNew, EP_Reduced|EP_TokenOnly|EP_WinFunc) ){\n-      zAlloc += dupedExprNodeSize(p, dupFlags);\n-      if( !ExprHasProperty(pNew, EP_TokenOnly|EP_Leaf) ){\n-        pNew->pLeft = p->pLeft ?\n-                      exprDup(db, p->pLeft, EXPRDUP_REDUCE, &zAlloc) : 0;\n-        pNew->pRight = p->pRight ?\n-                       exprDup(db, p->pRight, EXPRDUP_REDUCE, &zAlloc) : 0;\n-      }\n@@ -105154,6 +110195,16 @@\n-      if( pzBuffer ){\n-        *pzBuffer = zAlloc;\n-      }\n-    }else{\n-      if( !ExprHasProperty(p, EP_TokenOnly|EP_Leaf) ){\n-        if( pNew->op==TK_SELECT_COLUMN ){\n+\n+      \/* Fill in pNew->pLeft and pNew->pRight. *\/\n+      if( dupFlags ){\n+        if( p->op==TK_SELECT_COLUMN ){\n+          pNew->pLeft = p->pLeft;\n+          assert( p->pRight==0\n+               || p->pRight==p->pLeft\n+               || ExprHasProperty(p->pLeft, EP_Subquery) );\n+        }else{\n+          pNew->pLeft = p->pLeft ?\n+                      exprDup(db, p->pLeft, EXPRDUP_REDUCE, &sEdupBuf) : 0;\n+        }\n+        pNew->pRight = p->pRight ?\n+                       exprDup(db, p->pRight, EXPRDUP_REDUCE, &sEdupBuf) : 0;\n+      }else{\n+        if( p->op==TK_SELECT_COLUMN ){\n@@ -105161,2 +110212,3 @@\n-          assert( p->pRight==0  || p->pRight==p->pLeft\n-                                || ExprHasProperty(p->pLeft, EP_Subquery) );\n+          assert( p->pRight==0\n+               || p->pRight==p->pLeft\n+               || ExprHasProperty(p->pLeft, EP_Subquery) );\n@@ -105170,0 +110222,2 @@\n+  if( pEdupBuf ) memcpy(pEdupBuf, &sEdupBuf, sizeof(sEdupBuf));\n+  assert( sEdupBuf.zAlloc <= sEdupBuf.zEnd );\n@@ -105434,5 +110488,1 @@\n-** obtained from a prior call to sqlite3ExprListAppend().  This routine\n-** may not be used with an ExprList obtained from sqlite3ExprListDup().\n-** Reason:  This routine assumes that the number of slots in pList->a[]\n-** is a power of two.  That is true for sqlite3ExprListAppend() returns\n-** but is not necessarily true from the return value of sqlite3ExprListDup().\n+** obtained from a prior call to sqlite3ExprListAppend().\n@@ -105692,0 +110742,1 @@\n+  assert( db!=0 );\n@@ -105694,1 +110745,1 @@\n-    sqlite3DbFree(db, pItem->zEName);\n+    if( pItem->zEName ) sqlite3DbNNFreeNN(db, pItem->zEName);\n@@ -105697,1 +110748,1 @@\n-  sqlite3DbFreeNN(db, pList);\n+  sqlite3DbNNFreeNN(db, pList);\n@@ -105702,0 +110753,3 @@\n+SQLITE_PRIVATE void sqlite3ExprListDeleteGeneric(sqlite3 *db, void *pList){\n+  if( ALWAYS(pList) ) exprListDeleteNN(db, (ExprList*)pList);\n+}\n@@ -105770,1 +110824,1 @@\n-  pExpr = sqlite3ExprSkipCollate((Expr*)pExpr);\n+  pExpr = sqlite3ExprSkipCollateAndLikely((Expr*)pExpr);\n@@ -105957,1 +111011,6 @@\n-** Check pExpr to see if it is an invariant constraint on data source pSrc.\n+** Check pExpr to see if it is an constraint on the single data source\n+** pSrc = &pSrcList->a[iSrc].  In other words, check to see if pExpr\n+** constrains pSrc but does not depend on any other tables or data\n+** sources anywhere else in the query.  Return true (non-zero) if pExpr\n+** is a constraint on pSrc only.\n+**\n@@ -105962,1 +111021,1 @@\n-** To be an invariant constraint, the following must be true:\n+** To be an single-source constraint, the following must be true:\n@@ -105973,1 +111032,1 @@\n-           (4b)  and specifically the ON clause associated with the LEFT JOIN.\n+**         (4b)  and specifically the ON clause associated with the LEFT JOIN.\n@@ -105978,0 +111037,13 @@\n+**\n+**   (6) Either:\n+**\n+**       (6a) pExpr does not originate in an ON or USING clause, or\n+**\n+**       (6b) The ON or USING clause from which pExpr is derived is\n+**            not to the left of a RIGHT JOIN (or FULL JOIN).\n+**\n+**       Without this restriction, accepting pExpr as a single-table\n+**       constraint might move the the ON\/USING filter expression\n+**       from the left side of a RIGHT JOIN over to the right side,\n+**       which leads to incorrect answers.  See also restriction (9)\n+**       on push-down.\n@@ -105979,1 +111051,6 @@\n-SQLITE_PRIVATE int sqlite3ExprIsTableConstraint(Expr *pExpr, const SrcItem *pSrc){\n+SQLITE_PRIVATE int sqlite3ExprIsSingleTableConstraint(\n+  Expr *pExpr,                 \/* The constraint *\/\n+  const SrcList *pSrcList,     \/* Complete FROM clause *\/\n+  int iSrc                     \/* Which element of pSrcList to use *\/\n+){\n+  const SrcItem *pSrc = &pSrcList->a[iSrc];\n@@ -105989,0 +111066,13 @@\n+  if( ExprHasProperty(pExpr, EP_OuterON|EP_InnerON)  \/* (6a) *\/\n+   && (pSrcList->a[0].fg.jointype & JT_LTORJ)!=0     \/* Fast pre-test of (6b) *\/\n+  ){\n+    int jj;\n+    for(jj=0; jj<iSrc; jj++){\n+      if( pExpr->w.iJoin==pSrcList->a[jj].iCursor ){\n+        if( (pSrcList->a[jj].fg.jointype & JT_LTORJ)!=0 ){\n+          return 0;  \/* restriction (6) *\/\n+        }\n+        break;\n+      }\n+    }\n+  }\n@@ -106164,3 +111254,6 @@\n-      return ExprHasProperty(p, EP_CanBeNull) ||\n-             p->y.pTab==0 ||  \/* Reference to column of index on expression *\/\n-             (p->iColumn>=0\n+      return ExprHasProperty(p, EP_CanBeNull)\n+          || NEVER(p->y.pTab==0) \/* Reference to column of index on expr *\/\n+#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n+          || (p->iColumn==XN_ROWID && IsView(p->y.pTab))\n+#endif\n+          || (p->iColumn>=0\n@@ -106168,0 +111261,1 @@\n+              && ALWAYS(p->iColumn<p->y.pTab->nCol)\n@@ -106227,0 +111321,21 @@\n+\/*\n+** Return a pointer to a buffer containing a usable rowid alias for table\n+** pTab. An alias is usable if there is not an explicit user-defined column\n+** of the same name.\n+*\/\n+SQLITE_PRIVATE const char *sqlite3RowidAlias(Table *pTab){\n+  const char *azOpt[] = {\"_ROWID_\", \"ROWID\", \"OID\"};\n+  int ii;\n+  assert( VisibleRowid(pTab) );\n+  for(ii=0; ii<ArraySize(azOpt); ii++){\n+    int iCol;\n+    for(iCol=0; iCol<pTab->nCol; iCol++){\n+      if( sqlite3_stricmp(azOpt[ii], pTab->aCol[iCol].zCnName)==0 ) break;\n+    }\n+    if( iCol==pTab->nCol ){\n+      return azOpt[ii];\n+    }\n+  }\n+  return 0;\n+}\n+\n@@ -106231,1 +111346,1 @@\n-** or if the SELECT statement needs to be manifested into a transient\n+** or if the SELECT statement needs to be materialized into a transient\n@@ -106327,1 +111442,1 @@\n-**                         populated epheremal table.\n+**                         populated ephemeral table.\n@@ -106340,1 +111455,1 @@\n-** ephmeral table might be put inside of a subroutine, the EP_Subrtn flag\n+** ephemeral table might be put inside of a subroutine, the EP_Subrtn flag\n@@ -106352,1 +111467,1 @@\n-** An epheremal table will be created unless the selected columns are guaranteed\n+** An ephemeral table will be created unless the selected columns are guaranteed\n@@ -106357,1 +111472,1 @@\n-** for fast set membership tests) then an epheremal table must\n+** for fast set membership tests) then an ephemeral table must\n@@ -106517,1 +111632,0 @@\n-            assert( pReq!=0 || pRhs->iColumn==XN_ROWID || pParse->nErr );\n@@ -106691,1 +111805,1 @@\n-** constructed ephermeral table is returned.  The first time the ephemeral\n+** constructed ephemeral table is returned.  The first time the ephemeral\n@@ -106875,0 +111989,1 @@\n+    sqlite3VdbeAddOp1(v, OP_NullRow, iTab);\n@@ -106910,0 +112025,3 @@\n+#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n+  int addrExplain;            \/* Address of OP_Explain instruction *\/\n+#endif\n@@ -106962,1 +112080,1 @@\n-  ExplainQueryPlan((pParse, 1, \"%sSCALAR SUBQUERY %d\",\n+  ExplainQueryPlan2(addrExplain, (pParse, 1, \"%sSCALAR SUBQUERY %d\",\n@@ -106964,0 +112082,1 @@\n+  sqlite3VdbeScanStatusCounters(v, addrExplain, addrExplain, -1);\n@@ -106988,1 +112107,1 @@\n-    sqlite3ExprDelete(db, pSel->pLimit->pLeft);\n+    sqlite3ExprDeferredDelete(pParse, pSel->pLimit->pLeft);\n@@ -107006,0 +112125,1 @@\n+  sqlite3VdbeScanStatusRange(v, addrExplain, addrExplain, -1);\n@@ -107414,0 +112534,1 @@\n+  int nErr = pParse->nErr;\n@@ -107426,0 +112547,1 @@\n+  if( pParse->nErr>nErr ) pParse->db->errByteOffset = -1;\n@@ -107441,4 +112563,2 @@\n-  if( pTab==0 ){\n-    sqlite3VdbeAddOp3(v, OP_Column, iTabCur, iCol, regOut);\n-    return;\n-  }\n+  assert( pTab!=0 );\n+  assert( iCol!=XN_EXPR );\n@@ -107500,0 +112620,2 @@\n+  assert( (p5 & (OPFLAG_NOCHNG|OPFLAG_TYPEOFARG|OPFLAG_LENGTHARG))==p5 );\n+  assert( IsVirtual(pTab) || (p5 & OPFLAG_NOCHNG)==0 );\n@@ -107502,1 +112624,1 @@\n-    VdbeOp *pOp = sqlite3VdbeGetOp(pParse->pVdbe,-1);\n+    VdbeOp *pOp = sqlite3VdbeGetLastOp(pParse->pVdbe);\n@@ -107504,0 +112626,1 @@\n+    if( pOp->opcode==OP_VColumn ) pOp->p5 = (p5 & OPFLAG_NOCHNG);\n@@ -107532,1 +112655,1 @@\n-** the result in continguous temporary registers.  Return the index of\n+** the result in contiguous temporary registers.  Return the index of\n@@ -107571,2 +112694,2 @@\n-  if( sqlite3VdbeGetOp(v, -1)->opcode==OP_Copy ){\n-    sqlite3VdbeChangeP5(v, 1);  \/* Tag trailing OP_Copy as not mergable *\/\n+  if( sqlite3VdbeGetLastOp(v)->opcode==OP_Copy ){\n+    sqlite3VdbeChangeP5(v, 1);  \/* Tag trailing OP_Copy as not mergeable *\/\n@@ -107662,1 +112785,1 @@\n-      \/* REsult of sqlite3ExprImpliesNonNullRow() *\/\n+      \/* Result of sqlite3ExprImpliesNonNullRow() *\/\n@@ -107668,1 +112791,1 @@\n-           sqlite3ExprImpliesNonNullRow(pFarg->a[0].pExpr,pA1->iTable),\n+           sqlite3ExprImpliesNonNullRow(pFarg->a[0].pExpr,pA1->iTable,1),\n@@ -107681,1 +112804,2 @@\n-      const char *azAff[] = { \"blob\", \"text\", \"numeric\", \"integer\", \"real\" };\n+      const char *azAff[] = { \"blob\", \"text\", \"numeric\", \"integer\",\n+                              \"real\", \"flexnum\" };\n@@ -107685,0 +112809,2 @@\n+      assert( aff<=SQLITE_AFF_NONE\n+           || (aff>=SQLITE_AFF_BLOB && aff<=SQLITE_AFF_FLEXNUM) );\n@@ -107694,0 +112820,93 @@\n+\/*\n+** Check to see if pExpr is one of the indexed expressions on pParse->pIdxEpr.\n+** If it is, then resolve the expression by reading from the index and\n+** return the register into which the value has been read.  If pExpr is\n+** not an indexed expression, then return negative.\n+*\/\n+static SQLITE_NOINLINE int sqlite3IndexedExprLookup(\n+  Parse *pParse,   \/* The parsing context *\/\n+  Expr *pExpr,     \/* The expression to potentially bypass *\/\n+  int target       \/* Where to store the result of the expression *\/\n+){\n+  IndexedExpr *p;\n+  Vdbe *v;\n+  for(p=pParse->pIdxEpr; p; p=p->pIENext){\n+    u8 exprAff;\n+    int iDataCur = p->iDataCur;\n+    if( iDataCur<0 ) continue;\n+    if( pParse->iSelfTab ){\n+      if( p->iDataCur!=pParse->iSelfTab-1 ) continue;\n+      iDataCur = -1;\n+    }\n+    if( sqlite3ExprCompare(0, pExpr, p->pExpr, iDataCur)!=0 ) continue;\n+    assert( p->aff>=SQLITE_AFF_BLOB && p->aff<=SQLITE_AFF_NUMERIC );\n+    exprAff = sqlite3ExprAffinity(pExpr);\n+    if( (exprAff<=SQLITE_AFF_BLOB && p->aff!=SQLITE_AFF_BLOB)\n+     || (exprAff==SQLITE_AFF_TEXT && p->aff!=SQLITE_AFF_TEXT)\n+     || (exprAff>=SQLITE_AFF_NUMERIC && p->aff!=SQLITE_AFF_NUMERIC)\n+    ){\n+      \/* Affinity mismatch on a generated column *\/\n+      continue;\n+    }\n+\n+    v = pParse->pVdbe;\n+    assert( v!=0 );\n+    if( p->bMaybeNullRow ){\n+      \/* If the index is on a NULL row due to an outer join, then we\n+      ** cannot extract the value from the index.  The value must be\n+      ** computed using the original expression. *\/\n+      int addr = sqlite3VdbeCurrentAddr(v);\n+      sqlite3VdbeAddOp3(v, OP_IfNullRow, p->iIdxCur, addr+3, target);\n+      VdbeCoverage(v);\n+      sqlite3VdbeAddOp3(v, OP_Column, p->iIdxCur, p->iIdxCol, target);\n+      VdbeComment((v, \"%s expr-column %d\", p->zIdxName, p->iIdxCol));\n+      sqlite3VdbeGoto(v, 0);\n+      p = pParse->pIdxEpr;\n+      pParse->pIdxEpr = 0;\n+      sqlite3ExprCode(pParse, pExpr, target);\n+      pParse->pIdxEpr = p;\n+      sqlite3VdbeJumpHere(v, addr+2);\n+    }else{\n+      sqlite3VdbeAddOp3(v, OP_Column, p->iIdxCur, p->iIdxCol, target);\n+      VdbeComment((v, \"%s expr-column %d\", p->zIdxName, p->iIdxCol));\n+    }\n+    return target;\n+  }\n+  return -1;  \/* Not found *\/\n+}\n+\n+\n+\/*\n+** Expresion pExpr is guaranteed to be a TK_COLUMN or equivalent. This\n+** function checks the Parse.pIdxPartExpr list to see if this column\n+** can be replaced with a constant value. If so, it generates code to\n+** put the constant value in a register (ideally, but not necessarily,\n+** register iTarget) and returns the register number.\n+**\n+** Or, if the TK_COLUMN cannot be replaced by a constant, zero is\n+** returned.\n+*\/\n+static int exprPartidxExprLookup(Parse *pParse, Expr *pExpr, int iTarget){\n+  IndexedExpr *p;\n+  for(p=pParse->pIdxPartExpr; p; p=p->pIENext){\n+    if( pExpr->iColumn==p->iIdxCol && pExpr->iTable==p->iDataCur ){\n+      Vdbe *v = pParse->pVdbe;\n+      int addr = 0;\n+      int ret;\n+\n+      if( p->bMaybeNullRow ){\n+        addr = sqlite3VdbeAddOp1(v, OP_IfNullRow, p->iIdxCur);\n+      }\n+      ret = sqlite3ExprCodeTarget(pParse, p->pExpr, iTarget);\n+      sqlite3VdbeAddOp4(pParse->pVdbe, OP_Affinity, ret, 1, 0,\n+                        (const char*)&p->aff, 1);\n+      if( addr ){\n+        sqlite3VdbeJumpHere(v, addr);\n+        sqlite3VdbeChangeP3(v, addr, ret);\n+      }\n+      return ret;\n+    }\n+  }\n+  return 0;\n+}\n+\n@@ -107722,0 +112941,5 @@\n+  }else if( pParse->pIdxEpr!=0\n+   && !ExprHasProperty(pExpr, EP_Leaf)\n+   && (r1 = sqlite3IndexedExprLookup(pParse, pExpr, target))>=0\n+  ){\n+    return r1;\n@@ -107726,0 +112950,1 @@\n+  assert( op!=TK_ORDER );\n@@ -107731,1 +112956,13 @@\n-      assert( pExpr->iAgg>=0 && pExpr->iAgg<pAggInfo->nColumn );\n+      assert( pExpr->iAgg>=0 );\n+      if( pExpr->iAgg>=pAggInfo->nColumn ){\n+        \/* Happens when the left table of a RIGHT JOIN is null and\n+        ** is using an expression index *\/\n+        sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n+#ifdef SQLITE_VDBE_COVERAGE\n+        \/* Verify that the OP_Null above is exercised by tests\n+        ** tag-20230325-2 *\/\n+        sqlite3VdbeAddOp3(v, OP_NotNull, target, 1, 20230325);\n+        VdbeCoverageNeverTaken(v);\n+#endif\n+        break;\n+      }\n@@ -107734,2 +112971,1 @@\n-        assert( pCol->iMem>0 );\n-        return pCol->iMem;\n+        return AggInfoColumnReg(pAggInfo, pExpr->iAgg);\n@@ -107740,1 +112976,3 @@\n-        if( pCol->iColumn<0 ){\n+        if( pTab==0 ){\n+          \/* No comment added *\/\n+        }else if( pCol->iColumn<0 ){\n@@ -107750,0 +112988,5 @@\n+      }else if( pExpr->y.pTab==0 ){\n+        \/* This case happens when the argument to an aggregate function\n+        ** is rewritten by aggregateConvertIndexedExprRefToColumn() *\/\n+        sqlite3VdbeAddOp3(v, OP_Column, pExpr->iTable, pExpr->iColumn, target);\n+        return target;\n@@ -107760,1 +113003,1 @@\n-        ** expresssion.  However, make sure the constant has the correct\n+        ** expression.  However, make sure the constant has the correct\n@@ -107767,5 +113010,2 @@\n-        if( pExpr->y.pTab ){\n-          aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n-        }else{\n-          aff = pExpr->affExpr;\n-        }\n+        assert( pExpr->y.pTab!=0 );\n+        aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);\n@@ -107773,1 +113013,1 @@\n-          static const char zAff[] = \"B\\000C\\000D\\000E\";\n+          static const char zAff[] = \"B\\000C\\000D\\000E\\000F\";\n@@ -107832,0 +113072,5 @@\n+      else if( pParse->pIdxPartExpr\n+       && 0!=(r1 = exprPartidxExprLookup(pParse, pExpr, target))\n+      ){\n+        return r1;\n+      }\n@@ -107833,0 +113078,1 @@\n+      assert( pExpr->y.pTab!=0 );\n@@ -107836,3 +113082,0 @@\n-      if( pExpr->y.pTab==0 && pExpr->affExpr==SQLITE_AFF_REAL ){\n-        sqlite3VdbeAddOp1(v, OP_RealAffinity, iReg);\n-      }\n@@ -107905,5 +113148,2 @@\n-      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n-      if( inReg!=target ){\n-        sqlite3VdbeAddOp2(v, OP_SCopy, inReg, target);\n-        inReg = target;\n-      }\n+      sqlite3ExprCode(pParse, pExpr->pLeft, target);\n+      assert( inReg==target );\n@@ -108052,1 +113292,1 @@\n-        return pInfo->aFunc[pExpr->iAgg].iMem;\n+        return AggInfoFuncReg(pInfo, pExpr->iAgg);\n@@ -108094,1 +113334,1 @@\n-      if( pDef->funcFlags & SQLITE_FUNC_INLINE ){\n+      if( (pDef->funcFlags & SQLITE_FUNC_INLINE)!=0 && ALWAYS(pFarg!=0) ){\n@@ -108120,1 +113360,1 @@\n-        \/* For length() and typeof() functions with a column argument,\n+        \/* For length() and typeof() and octet_length() functions,\n@@ -108122,2 +113362,2 @@\n-        ** or OPFLAG_TYPEOFARG respectively, to avoid unnecessary data\n-        ** loading.\n+        ** or OPFLAG_TYPEOFARG or OPFLAG_BYTELENARG respectively, to avoid\n+        ** unnecessary data loading.\n@@ -108133,3 +113373,6 @@\n-            testcase( pDef->funcFlags & OPFLAG_LENGTHARG );\n-            pFarg->a[0].pExpr->op2 =\n-                  pDef->funcFlags & (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG);\n+            assert( SQLITE_FUNC_BYTELEN==OPFLAG_BYTELENARG );\n+            assert( (OPFLAG_LENGTHARG|OPFLAG_TYPEOFARG)==OPFLAG_BYTELENARG );\n+            testcase( (pDef->funcFlags & OPFLAG_BYTELENARG)==OPFLAG_LENGTHARG );\n+            testcase( (pDef->funcFlags & OPFLAG_BYTELENARG)==OPFLAG_TYPEOFARG );\n+            testcase( (pDef->funcFlags & OPFLAG_BYTELENARG)==OPFLAG_BYTELENARG);\n+            pFarg->a[0].pExpr->op2 = pDef->funcFlags & OPFLAG_BYTELENARG;\n@@ -108139,2 +113382,1 @@\n-        sqlite3ExprCodeExprList(pParse, pFarg, r1, 0,\n-                                SQLITE_ECEL_DUP|SQLITE_ECEL_FACTOR);\n+        sqlite3ExprCodeExprList(pParse, pFarg, r1, 0, SQLITE_ECEL_FACTOR);\n@@ -108241,11 +113483,10 @@\n-      if( !ExprHasProperty(pExpr, EP_Collate)\n-       && ALWAYS(pExpr->pLeft)\n-       && pExpr->pLeft->op==TK_FUNCTION\n-      ){\n-        inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n-        if( inReg!=target ){\n-          sqlite3VdbeAddOp2(v, OP_SCopy, inReg, target);\n-          inReg = target;\n-        }\n-        sqlite3VdbeAddOp1(v, OP_ClrSubtype, inReg);\n-        return inReg;\n+      if( !ExprHasProperty(pExpr, EP_Collate) ){\n+        \/* A TK_COLLATE Expr node without the EP_Collate tag is a so-called\n+        ** \"SOFT-COLLATE\" that is added to constraints that are pushed down\n+        ** from outer queries into sub-queries by the push-down optimization.\n+        ** Clear subtypes as subtypes may not cross a subquery boundary.\n+        *\/\n+        assert( pExpr->pLeft );\n+        sqlite3ExprCode(pParse, pExpr->pLeft, target);\n+        sqlite3VdbeAddOp1(v, OP_ClrSubtype, target);\n+        return target;\n@@ -108337,7 +113578,26 @@\n-      addrINR = sqlite3VdbeAddOp1(v, OP_IfNullRow, pExpr->iTable);\n-      \/* Temporarily disable factoring of constant expressions, since\n-      ** even though expressions may appear to be constant, they are not\n-      ** really constant because they originate from the right-hand side\n-      ** of a LEFT JOIN. *\/\n-      pParse->okConstFactor = 0;\n-      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n+      AggInfo *pAggInfo = pExpr->pAggInfo;\n+      if( pAggInfo ){\n+        assert( pExpr->iAgg>=0 && pExpr->iAgg<pAggInfo->nColumn );\n+        if( !pAggInfo->directMode ){\n+          inReg = AggInfoColumnReg(pAggInfo, pExpr->iAgg);\n+          break;\n+        }\n+        if( pExpr->pAggInfo->useSortingIdx ){\n+          sqlite3VdbeAddOp3(v, OP_Column, pAggInfo->sortingIdxPTab,\n+                            pAggInfo->aCol[pExpr->iAgg].iSorterColumn,\n+                            target);\n+          inReg = target;\n+          break;\n+        }\n+      }\n+      addrINR = sqlite3VdbeAddOp3(v, OP_IfNullRow, pExpr->iTable, 0, target);\n+      \/* The OP_IfNullRow opcode above can overwrite the result register with\n+      ** NULL.  So we have to ensure that the result register is not a value\n+      ** that is suppose to be a constant.  Two defenses are needed:\n+      **   (1)  Temporarily disable factoring of constant expressions\n+      **   (2)  Make sure the computed value really is stored in register\n+      **        \"target\" and not someplace else.\n+      *\/\n+      pParse->okConstFactor = 0;   \/* note (1) above *\/\n+      sqlite3ExprCode(pParse, pExpr->pLeft, target);\n+      assert( target==inReg );\n@@ -108346,1 +113606,0 @@\n-      sqlite3VdbeChangeP3(v, addrINR, inReg);\n@@ -108478,1 +113737,1 @@\n-** If regDest>=0 then the result is always stored in that register and the\n+** If regDest>0 then the result is always stored in that register and the\n@@ -108480,1 +113739,1 @@\n-** store the value whereever it wants.  The register where the expression\n+** store the value wherever it wants.  The register where the expression\n@@ -108493,0 +113752,1 @@\n+  assert( regDest!=0 );\n@@ -108583,1 +113843,5 @@\n-    if( ALWAYS(pExpr) && ExprHasProperty(pExpr,EP_Subquery) ){\n+    Expr *pX = sqlite3ExprSkipCollateAndLikely(pExpr);\n+    testcase( pX!=pExpr );\n+    if( ALWAYS(pX)\n+     && (ExprHasProperty(pX,EP_Subquery) || pX->op==TK_REGISTER)\n+    ){\n@@ -108678,1 +113942,1 @@\n-         && (pOp=sqlite3VdbeGetOp(v, -1))->opcode==OP_Copy\n+         && (pOp=sqlite3VdbeGetLastOp(v))->opcode==OP_Copy\n@@ -108877,0 +114141,1 @@\n+      sqlite3VdbeTypeofColumn(v, r1);\n@@ -109051,0 +114316,1 @@\n+      sqlite3VdbeTypeofColumn(v, r1);\n@@ -109204,1 +114470,7 @@\n-    return 2;\n+    if( pA->op==TK_AGG_COLUMN && pB->op==TK_COLUMN\n+     && pB->iTable<0 && pA->iTable==iTab\n+    ){\n+      \/* fall through *\/\n+    }else{\n+      return 2;\n+    }\n@@ -109294,2 +114566,2 @@\n-             sqlite3ExprSkipCollateAndLikely(pA),\n-             sqlite3ExprSkipCollateAndLikely(pB),\n+             sqlite3ExprSkipCollate(pA),\n+             sqlite3ExprSkipCollate(pB),\n@@ -109388,1 +114660,1 @@\n-**     pE1: x IS ?2    pE2: x IS NOT NULL    Reuslt: false\n+**     pE1: x IS ?2    pE2: x IS NOT NULL    Result: false\n@@ -109425,0 +114697,14 @@\n+\/* This is a helper function to impliesNotNullRow().  In this routine,\n+** set pWalker->eCode to one only if *both* of the input expressions\n+** separately have the implies-not-null-row property.\n+*\/\n+static void bothImplyNotNullRow(Walker *pWalker, Expr *pE1, Expr *pE2){\n+  if( pWalker->eCode==0 ){\n+    sqlite3WalkExpr(pWalker, pE1);\n+    if( pWalker->eCode ){\n+      pWalker->eCode = 0;\n+      sqlite3WalkExpr(pWalker, pE2);\n+    }\n+  }\n+}\n+\n@@ -109430,0 +114716,4 @@\n+** pWalker->mWFlags is non-zero if this inquiry is being undertaking on\n+** behalf of a RIGHT JOIN (or FULL JOIN).  That makes a difference when\n+** evaluating terms in the ON clause of an inner join.\n+**\n@@ -109438,0 +114728,8 @@\n+  if( ExprHasProperty(pExpr, EP_InnerON) && pWalker->mWFlags ){\n+    \/* If iCur is used in an inner-join ON clause to the left of a\n+    ** RIGHT JOIN, that does *not* mean that the table must be non-null.\n+    ** But it is difficult to check for that condition precisely.\n+    ** To keep things simple, any use of iCur from any inner-join is\n+    ** ignored while attempting to simplify a RIGHT JOIN. *\/\n+    return WRC_Prune;\n+  }\n@@ -109443,1 +114741,0 @@\n-    case TK_OR:\n@@ -109445,2 +114742,0 @@\n-    case TK_CASE:\n-    case TK_IN:\n@@ -109449,0 +114744,1 @@\n+    case TK_CASE:\n@@ -109453,1 +114749,0 @@\n-      testcase( pExpr->op==TK_OR );\n@@ -109455,2 +114750,0 @@\n-      testcase( pExpr->op==TK_CASE );\n-      testcase( pExpr->op==TK_IN );\n@@ -109459,0 +114752,1 @@\n+      testcase( pExpr->op==TK_CASE );\n@@ -109460,0 +114754,1 @@\n+\n@@ -109467,0 +114762,1 @@\n+    case TK_OR:\n@@ -109468,1 +114764,18 @@\n-      if( pWalker->eCode==0 ){\n+      \/* Both sides of an AND or OR must separately imply non-null-row.\n+      ** Consider these cases:\n+      **    1.  NOT (x AND y)\n+      **    2.  x OR y\n+      ** If only one of x or y is non-null-row, then the overall expression\n+      ** can be true if the other arm is false (case 1) or true (case 2).\n+      *\/\n+      testcase( pExpr->op==TK_OR );\n+      testcase( pExpr->op==TK_AND );\n+      bothImplyNotNullRow(pWalker, pExpr->pLeft, pExpr->pRight);\n+      return WRC_Prune;\n+\n+    case TK_IN:\n+      \/* Beware of \"x NOT IN ()\" and \"x NOT IN (SELECT 1 WHERE false)\",\n+      ** both of which can be true.  But apart from these cases, if\n+      ** the left-hand side of the IN is NULL then the IN itself will be\n+      ** NULL. *\/\n+      if( ExprUseXList(pExpr) && ALWAYS(pExpr->x.pList->nExpr>0) ){\n@@ -109470,4 +114783,0 @@\n-        if( pWalker->eCode ){\n-          pWalker->eCode = 0;\n-          sqlite3WalkExpr(pWalker, pExpr->pRight);\n-        }\n@@ -109478,4 +114787,7 @@\n-      if( sqlite3WalkExpr(pWalker, pExpr->pLeft)==WRC_Abort ){\n-        assert( pWalker->eCode );\n-        return WRC_Abort;\n-      }\n+      \/* In \"x NOT BETWEEN y AND z\" either x must be non-null-row or else\n+      ** both y and z must be non-null row *\/\n+      assert( ExprUseXList(pExpr) );\n+      assert( pExpr->x.pList->nExpr==2 );\n+      sqlite3WalkExpr(pWalker, pExpr->pLeft);\n+      bothImplyNotNullRow(pWalker, pExpr->x.pList->a[0].pExpr,\n+                                   pExpr->x.pList->a[1].pExpr);\n@@ -109506,1 +114818,1 @@\n-           && pLeft->y.pTab!=0\n+           && ALWAYS(pLeft->y.pTab!=0)\n@@ -109509,1 +114821,1 @@\n-           && pRight->y.pTab!=0\n+           && ALWAYS(pRight->y.pTab!=0)\n@@ -109543,1 +114855,1 @@\n-SQLITE_PRIVATE int sqlite3ExprImpliesNonNullRow(Expr *p, int iTab){\n+SQLITE_PRIVATE int sqlite3ExprImpliesNonNullRow(Expr *p, int iTab, int isRJ){\n@@ -109551,1 +114863,1 @@\n-      if( sqlite3ExprImpliesNonNullRow(p->pLeft, iTab) ) return 1;\n+      if( sqlite3ExprImpliesNonNullRow(p->pLeft, iTab, isRJ) ) return 1;\n@@ -109559,0 +114871,1 @@\n+  w.mWFlags = isRJ!=0;\n@@ -109619,1 +114932,1 @@\n-\/* Structure used to pass information throught the Walker in order to\n+\/* Structure used to pass information throughout the Walker in order to\n@@ -109714,0 +115027,1 @@\n+  assert( pParse->db!=0 );\n@@ -109725,0 +115039,6 @@\n+  if( pExpr->pLeft ){\n+    assert( pExpr->pLeft->op==TK_ORDER );\n+    assert( ExprUseXList(pExpr->pLeft) );\n+    assert( pExpr->pLeft->x.pList!=0 );\n+    sqlite3WalkExprList(&w, pExpr->pLeft->x.pList);\n+  }\n@@ -109730,1 +115050,1 @@\n-  sqlite3DbFree(pParse->db, x.aiExclude);\n+  if( x.aiExclude ) sqlite3DbNNFreeNN(pParse->db, x.aiExclude);\n@@ -109748,4 +115068,2 @@\n-** The copy is stored on pParse->pConstExpr with a register number of 0.\n-** This will cause the expression to be deleted automatically when the\n-** Parse object is destroyed, but the zero register number means that it\n-** will not generate any code in the preamble.\n+** The copy is scheduled for deletion using the sqlite3ExprDeferredDelete()\n+** which builds on the sqlite3ParserAddCleanup() mechanism.\n@@ -109761,4 +115079,5 @@\n-    assert( pExpr->op==TK_AGG_COLUMN || pExpr->op==TK_AGG_FUNCTION );\n-    if( pExpr->op==TK_AGG_COLUMN ){\n-      assert( iAgg>=0 && iAgg<pAggInfo->nColumn );\n-      if( pAggInfo->aCol[iAgg].pCExpr==pExpr ){\n+    assert( iAgg>=0 );\n+    if( pExpr->op!=TK_AGG_FUNCTION ){\n+      if( iAgg<pAggInfo->nColumn\n+       && pAggInfo->aCol[iAgg].pCExpr==pExpr\n+      ){\n@@ -109772,2 +115091,4 @@\n-      assert( iAgg>=0 && iAgg<pAggInfo->nFunc );\n-      if( pAggInfo->aFunc[iAgg].pFExpr==pExpr ){\n+      assert( pExpr->op==TK_AGG_FUNCTION );\n+      if( ALWAYS(iAgg<pAggInfo->nFunc)\n+       && pAggInfo->aFunc[iAgg].pFExpr==pExpr\n+      ){\n@@ -109828,0 +115149,68 @@\n+\/*\n+** Search the AggInfo object for an aCol[] entry that has iTable and iColumn.\n+** Return the index in aCol[] of the entry that describes that column.\n+**\n+** If no prior entry is found, create a new one and return -1.  The\n+** new column will have an index of pAggInfo->nColumn-1.\n+*\/\n+static void findOrCreateAggInfoColumn(\n+  Parse *pParse,       \/* Parsing context *\/\n+  AggInfo *pAggInfo,   \/* The AggInfo object to search and\/or modify *\/\n+  Expr *pExpr          \/* Expr describing the column to find or insert *\/\n+){\n+  struct AggInfo_col *pCol;\n+  int k;\n+\n+  assert( pAggInfo->iFirstReg==0 );\n+  pCol = pAggInfo->aCol;\n+  for(k=0; k<pAggInfo->nColumn; k++, pCol++){\n+    if( pCol->pCExpr==pExpr ) return;\n+    if( pCol->iTable==pExpr->iTable\n+     && pCol->iColumn==pExpr->iColumn\n+     && pExpr->op!=TK_IF_NULL_ROW\n+    ){\n+      goto fix_up_expr;\n+    }\n+  }\n+  k = addAggInfoColumn(pParse->db, pAggInfo);\n+  if( k<0 ){\n+    \/* OOM on resize *\/\n+    assert( pParse->db->mallocFailed );\n+    return;\n+  }\n+  pCol = &pAggInfo->aCol[k];\n+  assert( ExprUseYTab(pExpr) );\n+  pCol->pTab = pExpr->y.pTab;\n+  pCol->iTable = pExpr->iTable;\n+  pCol->iColumn = pExpr->iColumn;\n+  pCol->iSorterColumn = -1;\n+  pCol->pCExpr = pExpr;\n+  if( pAggInfo->pGroupBy && pExpr->op!=TK_IF_NULL_ROW ){\n+    int j, n;\n+    ExprList *pGB = pAggInfo->pGroupBy;\n+    struct ExprList_item *pTerm = pGB->a;\n+    n = pGB->nExpr;\n+    for(j=0; j<n; j++, pTerm++){\n+      Expr *pE = pTerm->pExpr;\n+      if( pE->op==TK_COLUMN\n+       && pE->iTable==pExpr->iTable\n+       && pE->iColumn==pExpr->iColumn\n+      ){\n+        pCol->iSorterColumn = j;\n+        break;\n+      }\n+    }\n+  }\n+  if( pCol->iSorterColumn<0 ){\n+    pCol->iSorterColumn = pAggInfo->nSortingColumn++;\n+  }\n+fix_up_expr:\n+  ExprSetVVAProperty(pExpr, EP_NoReduce);\n+  assert( pExpr->pAggInfo==0 || pExpr->pAggInfo==pAggInfo );\n+  pExpr->pAggInfo = pAggInfo;\n+  if( pExpr->op==TK_COLUMN ){\n+    pExpr->op = TK_AGG_COLUMN;\n+  }\n+  pExpr->iAgg = (i16)k;\n+}\n+\n@@ -109841,0 +115230,1 @@\n+  assert( pAggInfo->iFirstReg==0 );\n@@ -109842,0 +115232,38 @@\n+    default: {\n+      IndexedExpr *pIEpr;\n+      Expr tmp;\n+      assert( pParse->iSelfTab==0 );\n+      if( (pNC->ncFlags & NC_InAggFunc)==0 ) break;\n+      if( pParse->pIdxEpr==0 ) break;\n+      for(pIEpr=pParse->pIdxEpr; pIEpr; pIEpr=pIEpr->pIENext){\n+        int iDataCur = pIEpr->iDataCur;\n+        if( iDataCur<0 ) continue;\n+        if( sqlite3ExprCompare(0, pExpr, pIEpr->pExpr, iDataCur)==0 ) break;\n+      }\n+      if( pIEpr==0 ) break;\n+      if( NEVER(!ExprUseYTab(pExpr)) ) break;\n+      for(i=0; i<pSrcList->nSrc; i++){\n+         if( pSrcList->a[0].iCursor==pIEpr->iDataCur ) break;\n+      }\n+      if( i>=pSrcList->nSrc ) break;\n+      if( NEVER(pExpr->pAggInfo!=0) ) break; \/* Resolved by outer context *\/\n+      if( pParse->nErr ){ return WRC_Abort; }\n+\n+      \/* If we reach this point, it means that expression pExpr can be\n+      ** translated into a reference to an index column as described by\n+      ** pIEpr.\n+      *\/\n+      memset(&tmp, 0, sizeof(tmp));\n+      tmp.op = TK_AGG_COLUMN;\n+      tmp.iTable = pIEpr->iIdxCur;\n+      tmp.iColumn = pIEpr->iIdxCol;\n+      findOrCreateAggInfoColumn(pParse, pAggInfo, &tmp);\n+      if( pParse->nErr ){ return WRC_Abort; }\n+      assert( pAggInfo->aCol!=0 );\n+      assert( tmp.iAgg<pAggInfo->nColumn );\n+      pAggInfo->aCol[tmp.iAgg].pCExpr = pExpr;\n+      pExpr->pAggInfo = pAggInfo;\n+      pExpr->iAgg = tmp.iAgg;\n+      return WRC_Prune;\n+    }\n+    case TK_IF_NULL_ROW:\n@@ -109846,0 +115274,1 @@\n+      testcase( pExpr->op==TK_IF_NULL_ROW );\n@@ -109851,1 +115280,0 @@\n-          struct AggInfo_col *pCol;\n@@ -109854,52 +115282,1 @@\n-            \/* If we reach this point, it means that pExpr refers to a table\n-            ** that is in the FROM clause of the aggregate query.\n-            **\n-            ** Make an entry for the column in pAggInfo->aCol[] if there\n-            ** is not an entry there already.\n-            *\/\n-            int k;\n-            pCol = pAggInfo->aCol;\n-            for(k=0; k<pAggInfo->nColumn; k++, pCol++){\n-              if( pCol->iTable==pExpr->iTable &&\n-                  pCol->iColumn==pExpr->iColumn ){\n-                break;\n-              }\n-            }\n-            if( (k>=pAggInfo->nColumn)\n-             && (k = addAggInfoColumn(pParse->db, pAggInfo))>=0\n-            ){\n-              pCol = &pAggInfo->aCol[k];\n-              assert( ExprUseYTab(pExpr) );\n-              pCol->pTab = pExpr->y.pTab;\n-              pCol->iTable = pExpr->iTable;\n-              pCol->iColumn = pExpr->iColumn;\n-              pCol->iMem = ++pParse->nMem;\n-              pCol->iSorterColumn = -1;\n-              pCol->pCExpr = pExpr;\n-              if( pAggInfo->pGroupBy ){\n-                int j, n;\n-                ExprList *pGB = pAggInfo->pGroupBy;\n-                struct ExprList_item *pTerm = pGB->a;\n-                n = pGB->nExpr;\n-                for(j=0; j<n; j++, pTerm++){\n-                  Expr *pE = pTerm->pExpr;\n-                  if( pE->op==TK_COLUMN && pE->iTable==pExpr->iTable &&\n-                      pE->iColumn==pExpr->iColumn ){\n-                    pCol->iSorterColumn = j;\n-                    break;\n-                  }\n-                }\n-              }\n-              if( pCol->iSorterColumn<0 ){\n-                pCol->iSorterColumn = pAggInfo->nSortingColumn++;\n-              }\n-            }\n-            \/* There is now an entry for pExpr in pAggInfo->aCol[] (either\n-            ** because it was there before or because we just created it).\n-            ** Convert the pExpr to be a TK_AGG_COLUMN referring to that\n-            ** pAggInfo->aCol[] entry.\n-            *\/\n-            ExprSetVVAProperty(pExpr, EP_NoReduce);\n-            pExpr->pAggInfo = pAggInfo;\n-            pExpr->op = TK_AGG_COLUMN;\n-            pExpr->iAgg = (i16)k;\n+            findOrCreateAggInfoColumn(pParse, pAggInfo, pExpr);\n@@ -109910,1 +115287,1 @@\n-      return WRC_Prune;\n+      return WRC_Continue;\n@@ -109915,0 +115292,1 @@\n+       && pExpr->pAggInfo==0\n@@ -109921,1 +115299,1 @@\n-          if( pItem->pFExpr==pExpr ) break;\n+          if( NEVER(pItem->pFExpr==pExpr) ) break;\n@@ -109932,0 +115310,1 @@\n+            int nArg;\n@@ -109935,1 +115314,0 @@\n-            pItem->iMem = ++pParse->nMem;\n@@ -109937,0 +115315,1 @@\n+            nArg = pExpr->x.pList ? pExpr->x.pList->nExpr : 0;\n@@ -109938,3 +115317,31 @@\n-                   pExpr->u.zToken,\n-                   pExpr->x.pList ? pExpr->x.pList->nExpr : 0, enc, 0);\n-            if( pExpr->flags & EP_Distinct ){\n+                                         pExpr->u.zToken, nArg, enc, 0);\n+            assert( pItem->bOBUnique==0 );\n+            if( pExpr->pLeft\n+             && (pItem->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL)==0\n+            ){\n+              \/* The NEEDCOLL test above causes any ORDER BY clause on\n+              ** aggregate min() or max() to be ignored. *\/\n+              ExprList *pOBList;\n+              assert( nArg>0 );\n+              assert( pExpr->pLeft->op==TK_ORDER );\n+              assert( ExprUseXList(pExpr->pLeft) );\n+              pItem->iOBTab = pParse->nTab++;\n+              pOBList = pExpr->pLeft->x.pList;\n+              assert( pOBList->nExpr>0 );\n+              assert( pItem->bOBUnique==0 );\n+              if( pOBList->nExpr==1\n+               && nArg==1\n+               && sqlite3ExprCompare(0,pOBList->a[0].pExpr,\n+                               pExpr->x.pList->a[0].pExpr,0)==0\n+              ){\n+                pItem->bOBPayload = 0;\n+                pItem->bOBUnique = ExprHasProperty(pExpr, EP_Distinct);\n+              }else{\n+                pItem->bOBPayload = 1;\n+              }\n+              pItem->bUseSubtype =\n+                    (pItem->pFunc->funcFlags & SQLITE_SUBTYPE)!=0;\n+            }else{\n+              pItem->iOBTab = -1;\n+            }\n+            if( ExprHasProperty(pExpr, EP_Distinct) && !pItem->bOBUnique ){\n@@ -110064,0 +115471,31 @@\n+\/*\n+** Make sure sufficient registers have been allocated so that\n+** iReg is a valid register number.\n+*\/\n+SQLITE_PRIVATE void sqlite3TouchRegister(Parse *pParse, int iReg){\n+  if( pParse->nMem<iReg ) pParse->nMem = iReg;\n+}\n+\n+#if defined(SQLITE_ENABLE_STAT4) || defined(SQLITE_DEBUG)\n+\/*\n+** Return the latest reusable register in the set of all registers.\n+** The value returned is no less than iMin.  If any register iMin or\n+** greater is in permanent use, then return one more than that last\n+** permanent register.\n+*\/\n+SQLITE_PRIVATE int sqlite3FirstAvailableRegister(Parse *pParse, int iMin){\n+  const ExprList *pList = pParse->pConstExpr;\n+  if( pList ){\n+    int i;\n+    for(i=0; i<pList->nExpr; i++){\n+      if( pList->a[i].u.iConstExprReg>=iMin ){\n+        iMin = pList->a[i].u.iConstExprReg + 1;\n+      }\n+    }\n+  }\n+  pParse->nTempReg = 0;\n+  pParse->nRangeReg = 0;\n+  return iMin;\n+}\n+#endif \/* SQLITE_ENABLE_STAT4 || SQLITE_DEBUG *\/\n+\n@@ -110083,0 +115521,8 @@\n+  if( pParse->pConstExpr ){\n+    ExprList *pList = pParse->pConstExpr;\n+    for(i=0; i<pList->nExpr; i++){\n+      int iReg = pList->a[i].u.iConstExprReg;\n+      if( iReg==0 ) continue;\n+      if( iReg>=iFirst && iReg<=iLast ) return 0;\n+    }\n+  }\n@@ -110537,0 +115983,1 @@\n+     || (pTab->tabFlags & TF_Strict)!=0\n@@ -110541,0 +115988,2 @@\n+        \" WHEN quick_check GLOB 'non-* value in*'\"\n+        \" THEN raise(ABORT,'type mismatch on DEFAULT')\"\n@@ -110544,1 +115993,3 @@\n-        \" WHERE quick_check GLOB 'CHECK*' OR quick_check GLOB 'NULL*'\",\n+        \" WHERE quick_check GLOB 'CHECK*'\"\n+        \" OR quick_check GLOB 'NULL*'\"\n+        \" OR quick_check GLOB 'non-* value in*'\",\n@@ -110633,1 +116084,1 @@\n-  pNew->nTabRef = 1;\n+  assert( pNew->nTabRef==1 );\n@@ -110832,1 +116283,1 @@\n-    u8 i = 0;\n+    u32 i = 1;\n@@ -110836,1 +116287,1 @@\n-        i += *(u8*)(p->p);\n+        i += *(u8*)(p->p) | 1;\n@@ -110839,0 +116290,1 @@\n+    assert( i>0 );\n@@ -111137,1 +116589,1 @@\n-** An error occured while parsing or otherwise processing a database\n+** An error occurred while parsing or otherwise processing a database\n@@ -111369,0 +116821,13 @@\n+\/*\n+** Set all pEList->a[].fg.eEName fields in the expression-list to val.\n+*\/\n+static void renameSetENames(ExprList *pEList, int val){\n+  if( pEList ){\n+    int i;\n+    for(i=0; i<pEList->nExpr; i++){\n+      assert( val==ENAME_NAME || pEList->a[i].fg.eEName==ENAME_NAME );\n+      pEList->a[i].fg.eEName = val;\n+    }\n+  }\n+}\n+\n@@ -111416,0 +116881,9 @@\n+          \/* pStep->pExprList contains an expression-list used for an UPDATE\n+          ** statement. So the a[].zEName values are the RHS of the\n+          ** \"<col> = <expr>\" clauses of the UPDATE statement. So, before\n+          ** running SelectPrep(), change all the eEName values in\n+          ** pStep->pExprList to ENAME_SPAN (from their current value of\n+          ** ENAME_NAME). This is to prevent any ids in ON() clauses that are\n+          ** part of pSrc from being incorrectly resolved against the\n+          ** a[].zEName values as if they were column aliases.  *\/\n+          renameSetENames(pStep->pExprList, ENAME_SPAN);\n@@ -111417,0 +116891,1 @@\n+          renameSetENames(pStep->pExprList, ENAME_NAME);\n@@ -112635,1 +118110,0 @@\n-  tRowcnt *anEq;                  \/* sqlite_stat4.nEq *\/\n@@ -112638,0 +118112,1 @@\n+  tRowcnt *anEq;                  \/* sqlite_stat4.nEq *\/\n@@ -112795,2 +118270,1 @@\n-    + sizeof(tRowcnt)*nColUp                  \/* StatAccum.anEq *\/\n-    + sizeof(tRowcnt)*nColUp;                 \/* StatAccum.anDLt *\/\n+    + sizeof(tRowcnt)*nColUp;                    \/* StatAccum.anDLt *\/\n@@ -112798,0 +118272,1 @@\n+  n += sizeof(tRowcnt)*nColUp;                   \/* StatAccum.anEq *\/\n@@ -112818,1 +118293,0 @@\n-  p->current.anEq = &p->current.anDLt[nColUp];\n@@ -112821,0 +118295,1 @@\n+  p->current.anEq = &p->current.anDLt[nColUp];\n@@ -113087,0 +118562,1 @@\n+#ifdef SQLITE_ENABLE_STAT4\n@@ -113088,0 +118564,1 @@\n+#endif\n@@ -113096,0 +118573,1 @@\n+#ifdef SQLITE_ENABLE_STAT4\n@@ -113099,0 +118577,1 @@\n+#endif\n@@ -113103,1 +118582,0 @@\n-#endif\n@@ -113105,0 +118583,1 @@\n+#endif\n@@ -113238,0 +118717,1 @@\n+#ifdef SQLITE_ENABLE_STAT4\n@@ -113239,0 +118719,1 @@\n+#endif\n@@ -113324,0 +118805,1 @@\n+    assert( pIdx->bHasExpr );\n@@ -113364,0 +118846,3 @@\n+#ifdef SQLITE_ENABLE_STAT4\n+  int doOnce = 1;              \/* Flag for a one-time computation *\/\n+#endif\n@@ -113368,1 +118853,2 @@\n-  pParse->nMem = MAX(pParse->nMem, iMem);\n+  sqlite3TouchRegister(pParse, iMem);\n+  assert( sqlite3NoTempsInRange(pParse, regNewRowid, iMem) );\n@@ -113474,1 +118960,1 @@\n-    pParse->nMem = MAX(pParse->nMem, regPrev+nColTest);\n+    sqlite3TouchRegister(pParse, regPrev+nColTest);\n@@ -113646,1 +119132,29 @@\n-      pParse->nMem = MAX(pParse->nMem, regCol+nCol);\n+      if( doOnce ){\n+        int mxCol = nCol;\n+        Index *pX;\n+\n+        \/* Compute the maximum number of columns in any index *\/\n+        for(pX=pTab->pIndex; pX; pX=pX->pNext){\n+          int nColX;                     \/* Number of columns in pX *\/\n+          if( !HasRowid(pTab) && IsPrimaryKeyIndex(pX) ){\n+            nColX = pX->nKeyCol;\n+          }else{\n+            nColX = pX->nColumn;\n+          }\n+          if( nColX>mxCol ) mxCol = nColX;\n+        }\n+\n+        \/* Allocate space to compute results for the largest index *\/\n+        sqlite3TouchRegister(pParse, regCol+mxCol);\n+        doOnce = 0;\n+#ifdef SQLITE_DEBUG\n+        \/* Verify that the call to sqlite3ClearTempRegCache() below\n+        ** really is needed.\n+        ** https:\/\/sqlite.org\/forum\/forumpost\/83cb4a95a0 (2023-03-25)\n+        *\/\n+        testcase( !sqlite3NoTempsInRange(pParse, regEq, regCol+mxCol) );\n+#endif\n+        sqlite3ClearTempRegCache(pParse);  \/* tag-20230325-1 *\/\n+        assert( sqlite3NoTempsInRange(pParse, regEq, regCol+mxCol) );\n+      }\n+      assert( sqlite3NoTempsInRange(pParse, regEq, regCol+nCol) );\n@@ -113727,0 +119241,5 @@\n+#ifdef SQLITE_ENABLE_STAT4\n+    iMem = sqlite3FirstAvailableRegister(pParse, iMem);\n+#else\n+    assert( iMem==sqlite3FirstAvailableRegister(pParse,iMem) );\n+#endif\n@@ -113889,0 +119408,10 @@\n+\n+    \/* Set the bLowQual flag if the peak number of rows obtained\n+    ** from a full equality match is so large that a full table scan\n+    ** seems likely to be faster than using the index.\n+    *\/\n+    if( aLog[0] > 66              \/* Index has more than 100 rows *\/\n+     && aLog[0] <= aLog[nOut-1]   \/* And only a single value seen *\/\n+    ){\n+      pIndex->bLowQual = 1;\n+    }\n@@ -113967,0 +119496,2 @@\n+  assert( db!=0 );\n+  assert( pIdx!=0 );\n@@ -113976,1 +119507,1 @@\n-  if( db && db->pnBytesFreed==0 ){\n+  if( db->pnBytesFreed==0 ){\n@@ -114112,0 +119643,4 @@\n+    if( pIdx->aSample!=0 ){\n+      \/* The same index appears in sqlite_stat4 under multiple names *\/\n+      continue;\n+    }\n@@ -114119,0 +119654,1 @@\n+    pIdx->mxSample = nSample;\n@@ -114158,0 +119694,5 @@\n+    if( pIdx->nSample>=pIdx->mxSample ){\n+      \/* Too many slots used because the same index appears in\n+      ** sqlite_stat4 using multiple names *\/\n+      continue;\n+    }\n@@ -114170,1 +119711,1 @@\n-    \/* Take a copy of the sample. Add two 0x00 bytes the end of the buffer.\n+    \/* Take a copy of the sample. Add 8 extra 0x00 bytes the end of the buffer.\n@@ -114174,1 +119715,2 @@\n-    ** a corrupt record. Adding the two 0x00 bytes prevents this from causing\n+    ** a corrupt record.  Or it might try to read a large integer from the\n+    ** buffer.  In any case, eight 0x00 bytes prevents this from causing\n@@ -114177,1 +119719,1 @@\n-    pSample->p = sqlite3DbMallocZero(db, pSample->n + 2);\n+    pSample->p = sqlite3DbMallocZero(db, pSample->n + 8);\n@@ -114201,1 +119743,2 @@\n-  if( (pStat4 = sqlite3FindTable(db, \"sqlite_stat4\", zDb))!=0\n+  if( OptimizationEnabled(db, SQLITE_Stat4)\n+   && (pStat4 = sqlite3FindTable(db, \"sqlite_stat4\", zDb))!=0\n@@ -114205,1 +119748,1 @@\n-      \"SELECT idx,count(*) FROM %Q.sqlite_stat4 GROUP BY idx\",\n+      \"SELECT idx,count(*) FROM %Q.sqlite_stat4 GROUP BY idx COLLATE nocase\",\n@@ -114395,1 +119938,1 @@\n-  Db *pNew;                 \/* Db object for the newly attached database *\/\n+  Db *pNew = 0;             \/* Db object for the newly attached database *\/\n@@ -114415,0 +119958,1 @@\n+    Btree *pNewBt = 0;\n@@ -114417,5 +119961,17 @@\n-    pNew = &db->aDb[db->init.iDb];\n-    if( pNew->pBt ) sqlite3BtreeClose(pNew->pBt);\n-    pNew->pBt = 0;\n-    pNew->pSchema = 0;\n-    rc = sqlite3BtreeOpen(pVfs, \"x\\0\", db, &pNew->pBt, 0, SQLITE_OPEN_MAIN_DB);\n+    rc = sqlite3BtreeOpen(pVfs, \"x\\0\", db, &pNewBt, 0, SQLITE_OPEN_MAIN_DB);\n+    if( rc==SQLITE_OK ){\n+      Schema *pNewSchema = sqlite3SchemaGet(db, pNewBt);\n+      if( pNewSchema ){\n+        \/* Both the Btree and the new Schema were allocated successfully.\n+        ** Close the old db and update the aDb[] slot with the new memdb\n+        ** values.  *\/\n+        pNew = &db->aDb[db->init.iDb];\n+        if( ALWAYS(pNew->pBt) ) sqlite3BtreeClose(pNew->pBt);\n+        pNew->pBt = pNewBt;\n+        pNew->pSchema = pNewSchema;\n+      }else{\n+        sqlite3BtreeClose(pNewBt);\n+        rc = SQLITE_NOMEM;\n+      }\n+    }\n+    if( rc ) goto attach_error;\n@@ -114534,1 +120090,1 @@\n-    if( !REOPEN_AS_MEMDB(db) ){\n+    if( ALWAYS(!REOPEN_AS_MEMDB(db)) ){\n@@ -114651,0 +120207,2 @@\n+  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ) goto attach_end;\n+\n@@ -115119,1 +120677,1 @@\n-  \/* Don't do any authorization checks if the database is initialising\n+  \/* Don't do any authorization checks if the database is initializing\n@@ -115326,0 +120884,1 @@\n+  int iDb, i;\n@@ -115355,1 +120914,0 @@\n-      int i;\n@@ -115392,24 +120950,20 @@\n-    if( db->mallocFailed==0\n-     && (DbMaskNonZero(pParse->cookieMask) || pParse->pConstExpr)\n-    ){\n-      int iDb, i;\n-      assert( sqlite3VdbeGetOp(v, 0)->opcode==OP_Init );\n-      sqlite3VdbeJumpHere(v, 0);\n-      assert( db->nDb>0 );\n-      iDb = 0;\n-      do{\n-        Schema *pSchema;\n-        if( DbMaskTest(pParse->cookieMask, iDb)==0 ) continue;\n-        sqlite3VdbeUsesBtree(v, iDb);\n-        pSchema = db->aDb[iDb].pSchema;\n-        sqlite3VdbeAddOp4Int(v,\n-          OP_Transaction,                    \/* Opcode *\/\n-          iDb,                               \/* P1 *\/\n-          DbMaskTest(pParse->writeMask,iDb), \/* P2 *\/\n-          pSchema->schema_cookie,            \/* P3 *\/\n-          pSchema->iGeneration               \/* P4 *\/\n-        );\n-        if( db->init.busy==0 ) sqlite3VdbeChangeP5(v, 1);\n-        VdbeComment((v,\n-              \"usesStmtJournal=%d\", pParse->mayAbort && pParse->isMultiWrite));\n-      }while( ++iDb<db->nDb );\n+    assert( pParse->nErr>0 || sqlite3VdbeGetOp(v, 0)->opcode==OP_Init );\n+    sqlite3VdbeJumpHere(v, 0);\n+    assert( db->nDb>0 );\n+    iDb = 0;\n+    do{\n+      Schema *pSchema;\n+      if( DbMaskTest(pParse->cookieMask, iDb)==0 ) continue;\n+      sqlite3VdbeUsesBtree(v, iDb);\n+      pSchema = db->aDb[iDb].pSchema;\n+      sqlite3VdbeAddOp4Int(v,\n+        OP_Transaction,                    \/* Opcode *\/\n+        iDb,                               \/* P1 *\/\n+        DbMaskTest(pParse->writeMask,iDb), \/* P2 *\/\n+        pSchema->schema_cookie,            \/* P3 *\/\n+        pSchema->iGeneration               \/* P4 *\/\n+      );\n+      if( db->init.busy==0 ) sqlite3VdbeChangeP5(v, 1);\n+      VdbeComment((v,\n+            \"usesStmtJournal=%d\", pParse->mayAbort && pParse->isMultiWrite));\n+    }while( ++iDb<db->nDb );\n@@ -115417,5 +120971,5 @@\n-      for(i=0; i<pParse->nVtabLock; i++){\n-        char *vtab = (char *)sqlite3GetVTable(db, pParse->apVtabLock[i]);\n-        sqlite3VdbeAddOp4(v, OP_VBegin, 0, 0, 0, vtab, P4_VTAB);\n-      }\n-      pParse->nVtabLock = 0;\n+    for(i=0; i<pParse->nVtabLock; i++){\n+      char *vtab = (char *)sqlite3GetVTable(db, pParse->apVtabLock[i]);\n+      sqlite3VdbeAddOp4(v, OP_VBegin, 0, 0, 0, vtab, P4_VTAB);\n+    }\n+    pParse->nVtabLock = 0;\n@@ -115424,5 +120978,7 @@\n-      \/* Once all the cookies have been verified and transactions opened,\n-      ** obtain the required table-locks. This is a no-op unless the\n-      ** shared-cache feature is enabled.\n-      *\/\n-      codeTableLocks(pParse);\n+#ifndef SQLITE_OMIT_SHARED_CACHE\n+    \/* Once all the cookies have been verified and transactions opened,\n+    ** obtain the required table-locks. This is a no-op unless the\n+    ** shared-cache feature is enabled.\n+    *\/\n+    if( pParse->nTableLock ) codeTableLocks(pParse);\n+#endif\n@@ -115430,3 +120986,3 @@\n-      \/* Initialize any AUTOINCREMENT data structures required.\n-      *\/\n-      sqlite3AutoincrementBegin(pParse);\n+    \/* Initialize any AUTOINCREMENT data structures required.\n+    *\/\n+    if( pParse->pAinc ) sqlite3AutoincrementBegin(pParse);\n@@ -115434,16 +120990,8 @@\n-      \/* Code constant expressions that where factored out of inner loops.\n-      **\n-      ** The pConstExpr list might also contain expressions that we simply\n-      ** want to keep around until the Parse object is deleted.  Such\n-      ** expressions have iConstExprReg==0.  Do not generate code for\n-      ** those expressions, of course.\n-      *\/\n-      if( pParse->pConstExpr ){\n-        ExprList *pEL = pParse->pConstExpr;\n-        pParse->okConstFactor = 0;\n-        for(i=0; i<pEL->nExpr; i++){\n-          int iReg = pEL->a[i].u.iConstExprReg;\n-          if( iReg>0 ){\n-            sqlite3ExprCode(pParse, pEL->a[i].pExpr, iReg);\n-          }\n-        }\n+    \/* Code constant expressions that were factored out of inner loops.\n+    *\/\n+    if( pParse->pConstExpr ){\n+      ExprList *pEL = pParse->pConstExpr;\n+      pParse->okConstFactor = 0;\n+      for(i=0; i<pEL->nExpr; i++){\n+        assert( pEL->a[i].u.iConstExprReg>0 );\n+        sqlite3ExprCode(pParse, pEL->a[i].pExpr, pEL->a[i].u.iConstExprReg);\n@@ -115451,0 +120999,1 @@\n+    }\n@@ -115452,5 +121001,4 @@\n-      if( pParse->bReturning ){\n-        Returning *pRet = pParse->u1.pReturning;\n-        if( pRet->nRetCol ){\n-          sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pRet->iRetCur, pRet->nRetCol);\n-        }\n+    if( pParse->bReturning ){\n+      Returning *pRet = pParse->u1.pReturning;\n+      if( pRet->nRetCol ){\n+        sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pRet->iRetCur, pRet->nRetCol);\n@@ -115458,3 +121006,0 @@\n-\n-      \/* Finally, jump back to the beginning of the executable code. *\/\n-      sqlite3VdbeGoto(v, 1);\n@@ -115462,0 +121007,3 @@\n+\n+    \/* Finally, jump back to the beginning of the executable code. *\/\n+    sqlite3VdbeGoto(v, 1);\n@@ -115500,0 +121048,1 @@\n+  if( pParse->eParseMode ) return;\n@@ -115646,1 +121195,1 @@\n-    if( pParse->disableVtab==0 && db->init.busy==0 ){\n+    if( (pParse->prepFlags & SQLITE_PREPARE_NO_VTAB)==0 && db->init.busy==0 ){\n@@ -115659,1 +121208,1 @@\n-  }else if( IsVirtual(p) && pParse->disableVtab ){\n+  }else if( IsVirtual(p) && (pParse->prepFlags & SQLITE_PREPARE_NO_VTAB)!=0 ){\n@@ -115915,1 +121464,1 @@\n-  if( NEVER(!IsOrdinaryTable(pTab)) ) return 0;\n+  if( !IsOrdinaryTable(pTab) ) return 0;\n@@ -115947,1 +121496,1 @@\n-** Return the collating squence name for a column\n+** Return the collating sequence name for a column\n@@ -115968,0 +121517,1 @@\n+  assert( db!=0 );\n@@ -115973,1 +121523,1 @@\n-    sqlite3DbFree(db, pTable->aCol);\n+    sqlite3DbNNFreeNN(db, pTable->aCol);\n@@ -115977,1 +121527,1 @@\n-    if( db==0 || db->pnBytesFreed==0 ){\n+    if( db->pnBytesFreed==0 ){\n@@ -116014,1 +121564,2 @@\n-  if( db && !db->mallocFailed && (pTable->tabFlags & TF_Ephemeral)==0 ){\n+  assert( db!=0 );\n+  if( !db->mallocFailed && (pTable->tabFlags & TF_Ephemeral)==0 ){\n@@ -116024,1 +121575,1 @@\n-    if( (db==0 || db->pnBytesFreed==0) && !IsVirtual(pTable) ){\n+    if( db->pnBytesFreed==0 && !IsVirtual(pTable) ){\n@@ -116038,1 +121589,1 @@\n-#ifndef SQLITE_OMIT_VIRTUAL_TABLE\n+#ifndef SQLITE_OMIT_VIRTUALTABLE\n@@ -116061,0 +121612,1 @@\n+  assert( db!=0 );\n@@ -116062,1 +121614,1 @@\n-  if( ((!db || db->pnBytesFreed==0) && (--pTable->nTabRef)>0) ) return;\n+  if( db->pnBytesFreed==0 && (--pTable->nTabRef)>0 ) return;\n@@ -116065,0 +121617,3 @@\n+SQLITE_PRIVATE void sqlite3DeleteTableGeneric(sqlite3 *db, void *pTable){\n+  sqlite3DeleteTable(db, (Table*)pTable);\n+}\n@@ -116599,7 +122154,0 @@\n-\/*\n-** Name of the special TEMP trigger used to implement RETURNING.  The\n-** name begins with \"sqlite_\" so that it is guaranteed not to collide\n-** with any application-generated triggers.\n-*\/\n-#define RETURNING_TRIGGER_NAME  \"sqlite_returning\"\n-\n@@ -116609,1 +122157,2 @@\n-static void sqlite3DeleteReturning(sqlite3 *db, Returning *pRet){\n+static void sqlite3DeleteReturning(sqlite3 *db, void *pArg){\n+  Returning *pRet = (Returning*)pArg;\n@@ -116612,1 +122161,1 @@\n-  sqlite3HashInsert(pHash, RETURNING_TRIGGER_NAME, 0);\n+  sqlite3HashInsert(pHash, pRet->zName, 0);\n@@ -116640,1 +122189,1 @@\n-    assert( pParse->bReturning==0 );\n+    assert( pParse->bReturning==0 || pParse->ifNotExists );\n@@ -116651,2 +122200,1 @@\n-  sqlite3ParserAddCleanup(pParse,\n-     (void(*)(sqlite3*,void*))sqlite3DeleteReturning, pRet);\n+  sqlite3ParserAddCleanup(pParse, sqlite3DeleteReturning, pRet);\n@@ -116655,1 +122203,3 @@\n-  pRet->retTrig.zName = RETURNING_TRIGGER_NAME;\n+  sqlite3_snprintf(sizeof(pRet->zName), pRet->zName,\n+                   \"sqlite_returning_%p\", pParse);\n+  pRet->retTrig.zName = pRet->zName;\n@@ -116666,2 +122216,3 @@\n-  assert( sqlite3HashFind(pHash, RETURNING_TRIGGER_NAME)==0 || pParse->nErr );\n-  if( sqlite3HashInsert(pHash, RETURNING_TRIGGER_NAME, &pRet->retTrig)\n+  assert( sqlite3HashFind(pHash, pRet->zName)==0\n+          || pParse->nErr  || pParse->ifNotExists );\n+  if( sqlite3HashInsert(pHash, pRet->zName, &pRet->retTrig)\n@@ -116701,1 +122252,1 @@\n-  \/* Because keywords GENERATE ALWAYS can be converted into indentifiers\n+  \/* Because keywords GENERATE ALWAYS can be converted into identifiers\n@@ -116848,1 +122399,2 @@\n-    h = (h<<8) + sqlite3UpperToLower[(*zIn)&0xff];\n+    u8 x = *(u8*)zIn;\n+    h = (h<<8) + sqlite3UpperToLower[x];\n@@ -116922,1 +122474,1 @@\n-  const char *zEnd         \/* First character past end of defaut value text *\/\n+  const char *zEnd         \/* First character past end of default value text *\/\n@@ -117194,0 +122746,8 @@\n+  if( ALWAYS(pExpr) && pExpr->op==TK_ID ){\n+    \/* The value of a generated column needs to be a real expression, not\n+    ** just a reference to another column, in order for covering index\n+    ** optimizations to work correctly.  So if the value is not an expression,\n+    ** turn it into one by adding a unary \"+\" operator. *\/\n+    pExpr = sqlite3PExpr(pParse, TK_UPLUS, pExpr, 0);\n+  }\n+  if( pExpr && pExpr->op!=TK_RAISE ) pExpr->affExpr = pCol->affinity;\n@@ -117262,1 +122822,1 @@\n-** If the string zSignedIdent consists entirely of alpha-numeric\n+** If the string zSignedIdent consists entirely of alphanumeric\n@@ -117330,1 +122890,2 @@\n-        \/* SQLITE_AFF_REAL    *\/ \" REAL\"\n+        \/* SQLITE_AFF_REAL    *\/ \" REAL\",\n+        \/* SQLITE_AFF_FLEXNUM *\/ \" NUM\",\n@@ -117346,0 +122907,1 @@\n+    testcase( pCol->affinity==SQLITE_AFF_FLEXNUM );\n@@ -117350,0 +122912,1 @@\n+            || pCol->affinity==SQLITE_AFF_FLEXNUM\n@@ -117411,1 +122974,1 @@\n-    wIndex += x<0 ? 1 : aCol[pIdx->aiColumn[i]].szEst;\n+    wIndex += x<0 ? 1 : aCol[x].szEst;\n@@ -117466,1 +123029,2 @@\n-** columns that are within the first 63 columns of the table.  The\n+** columns that are within the first 63 columns of the table and a 1 for\n+** all other bits (all columns that are not in the index).  The\n@@ -117494,1 +123058,1 @@\n-  assert( (pIdx->colNotIdxed>>63)==1 );\n+  assert( (pIdx->colNotIdxed>>63)==1 );  \/* See note-20221022-a *\/\n@@ -117763,0 +123327,1 @@\n+  (void)pWalker;\n@@ -118098,0 +123663,11 @@\n+\n+    \/* Test for cycles in generated columns and illegal expressions\n+    ** in CHECK constraints and in DEFAULT clauses. *\/\n+    if( p->tabFlags & TF_HasGenerated ){\n+      sqlite3VdbeAddOp4(v, OP_SqlExec, 1, 0, 0,\n+             sqlite3MPrintf(db, \"SELECT*FROM\\\"%w\\\".\\\"%w\\\"\",\n+                   db->aDb[iDb].zDbSName, p->zName), P4_DYNAMIC);\n+    }\n+    sqlite3VdbeAddOp4(v, OP_SqlExec, 1, 0, 0,\n+           sqlite3MPrintf(db, \"PRAGMA \\\"%w\\\".integrity_check(%Q)\",\n+                 db->aDb[iDb].zDbSName, p->zName), P4_DYNAMIC);\n@@ -118174,3 +123750,6 @@\n-  ** depend upon the old buggy behavior. *\/\n-#ifndef SQLITE_ALLOW_ROWID_IN_VIEW\n-  p->tabFlags |= TF_NoVisibleRowid;\n+  ** depend upon the old buggy behavior.  The ability can also be toggled\n+  ** using sqlite3_config(SQLITE_CONFIG_ROWID_IN_VIEW,...) *\/\n+#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n+  p->tabFlags |= sqlite3Config.mNoVisibleRowid; \/* Optional. Allow by default *\/\n+#else\n+  p->tabFlags |= TF_NoVisibleRowid;             \/* Never allow rowid in view *\/\n@@ -118235,1 +123814,1 @@\n-SQLITE_PRIVATE int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){\n+static SQLITE_NOINLINE int viewGetColumnNames(Parse *pParse, Table *pTable){\n@@ -118260,1 +123839,2 @@\n-  ** already known.\n+  ** already known.  This routine is not called unless either the\n+  ** table is virtual or nCol is zero.\n@@ -118262,1 +123842,1 @@\n-  if( pTable->nCol>0 ) return 0;\n+  assert( pTable->nCol<=0 );\n@@ -118328,2 +123908,1 @@\n-        sqlite3SelectAddColumnTypeAndCollation(pParse, pTable, pSel,\n-                                               SQLITE_AFF_NONE);\n+        sqlite3SubqueryColumnTypes(pParse, pTable, pSel, SQLITE_AFF_NONE);\n@@ -118358,0 +123937,5 @@\n+SQLITE_PRIVATE int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){\n+  assert( pTable!=0 );\n+  if( !IsVirtual(pTable) && pTable->nCol>0 ) return 0;\n+  return viewGetColumnNames(pParse, pTable);\n+}\n@@ -119142,1 +124726,1 @@\n-    ** if initialising a database schema.\n+    ** if initializing a database schema.\n@@ -119223,1 +124807,1 @@\n-        if( sqlite3FindTable(db, zName, 0)!=0 ){\n+        if( sqlite3FindTable(db, zName, pDb->zDbSName)!=0 ){\n@@ -119376,0 +124960,1 @@\n+      pIndex->bHasExpr = 1;\n@@ -119387,0 +124972,1 @@\n+          pIndex->bHasExpr = 1;\n@@ -119876,0 +125462,1 @@\n+  assert( db!=0 );\n@@ -119881,1 +125468,1 @@\n-  sqlite3DbFreeNN(db, pList);\n+  sqlite3DbNNFreeNN(db, pList);\n@@ -120084,0 +125671,1 @@\n+  assert( db!=0 );\n@@ -120086,3 +125674,3 @@\n-    if( pItem->zDatabase ) sqlite3DbFreeNN(db, pItem->zDatabase);\n-    sqlite3DbFree(db, pItem->zName);\n-    if( pItem->zAlias ) sqlite3DbFreeNN(db, pItem->zAlias);\n+    if( pItem->zDatabase ) sqlite3DbNNFreeNN(db, pItem->zDatabase);\n+    if( pItem->zName ) sqlite3DbNNFreeNN(db, pItem->zName);\n+    if( pItem->zAlias ) sqlite3DbNNFreeNN(db, pItem->zAlias);\n@@ -120099,1 +125687,1 @@\n-  sqlite3DbFreeNN(db, pList);\n+  sqlite3DbNNFreeNN(db, pList);\n@@ -120680,1 +126268,1 @@\n-  zDb = db->aDb[iDb].zDbSName;\n+  zDb = pName2->n ? db->aDb[iDb].zDbSName : 0;\n@@ -120690,0 +126278,1 @@\n+    iDb = sqlite3SchemaToIndex(db, pIndex->pTable->pSchema);\n@@ -120795,1 +126384,1 @@\n-** WITH clause.  The CTE described by teh third argument is added to\n+** WITH clause.  The CTE described by the third argument is added to\n@@ -120855,0 +126444,3 @@\n+SQLITE_PRIVATE void sqlite3WithDeleteGeneric(sqlite3 *db, void *pWith){\n+  sqlite3WithDelete(db, (With*)pWith);\n+}\n@@ -121046,0 +126638,1 @@\n+  sqlite3ExpirePreparedStatements(db, 1);\n@@ -121351,0 +126944,1 @@\n+  sqlite3 xdb;\n@@ -121352,0 +126946,1 @@\n+  memset(&xdb, 0, sizeof(xdb));\n@@ -121357,1 +126952,1 @@\n-    sqlite3DeleteTrigger(0, (Trigger*)sqliteHashData(pElem));\n+    sqlite3DeleteTrigger(&xdb, (Trigger*)sqliteHashData(pElem));\n@@ -121363,1 +126958,1 @@\n-    sqlite3DeleteTable(0, pTab);\n+    sqlite3DeleteTable(&xdb, pTab);\n@@ -121434,1 +127029,1 @@\n-  sqlite3DeleteTable(pParse->db, pItem->pTab);\n+  if( pItem->pTab ) sqlite3DeleteTable(pParse->db, pItem->pTab);\n@@ -121436,0 +127031,1 @@\n+  pItem->fg.notCte = 1;\n@@ -121462,1 +127058,5 @@\n-**   2) It is a system table (i.e. sqlite_schema), this call is not\n+**   2) A trigger is currently being coded and the table is a virtual table\n+**      that is SQLITE_VTAB_DIRECTONLY or if PRAGMA trusted_schema=OFF and\n+**      the table is not SQLITE_VTAB_INNOCUOUS.\n+**\n+**   3) It is a system table (i.e. sqlite_schema), this call is not\n@@ -121466,1 +127066,1 @@\n-**   3) The table is a shadow table, the database connection is in\n+**   4) The table is a shadow table, the database connection is in\n@@ -121470,0 +127070,20 @@\n+static int vtabIsReadOnly(Parse *pParse, Table *pTab){\n+  if( sqlite3GetVTable(pParse->db, pTab)->pMod->pModule->xUpdate==0 ){\n+    return 1;\n+  }\n+\n+  \/* Within triggers:\n+  **   *  Do not allow DELETE, INSERT, or UPDATE of SQLITE_VTAB_DIRECTONLY\n+  **      virtual tables\n+  **   *  Only allow DELETE, INSERT, or UPDATE of non-SQLITE_VTAB_INNOCUOUS\n+  **      virtual tables if PRAGMA trusted_schema=ON.\n+  *\/\n+  if( pParse->pToplevel!=0\n+   && pTab->u.vtab.p->eVtabRisk >\n+           ((pParse->db->flags & SQLITE_TrustedSchema)!=0)\n+  ){\n+    sqlite3ErrorMsg(pParse, \"unsafe use of virtual table \\\"%s\\\"\",\n+      pTab->zName);\n+  }\n+  return 0;\n+}\n@@ -121473,1 +127093,1 @@\n-    return sqlite3GetVTable(pParse->db, pTab)->pMod->pModule->xUpdate==0;\n+    return vtabIsReadOnly(pParse, pTab);\n@@ -121485,3 +127105,5 @@\n-** Check to make sure the given table is writable.  If it is not\n-** writable, generate an error message and return 1.  If it is\n-** writable return 0;\n+** Check to make sure the given table is writable.\n+**\n+** If pTab is not writable  ->  generate an error message and return 1.\n+** If pTab is writable but other errors have occurred -> return 1.\n+** If pTab is writable and no prior errors -> return 0;\n@@ -121489,1 +127111,1 @@\n-SQLITE_PRIVATE int sqlite3IsReadOnly(Parse *pParse, Table *pTab, int viewOk){\n+SQLITE_PRIVATE int sqlite3IsReadOnly(Parse *pParse, Table *pTab, Trigger *pTrigger){\n@@ -121495,1 +127117,3 @@\n-  if( !viewOk && IsView(pTab) ){\n+  if( IsView(pTab)\n+   && (pTrigger==0 || (pTrigger->bReturning && pTrigger->pNext==0))\n+  ){\n@@ -121560,1 +127184,1 @@\n-  ExprList *pEList = NULL;     \/* Expression list contaning only pSelectRowid *\/\n+  ExprList *pEList = NULL;     \/* Expression list containing only pSelectRowid*\/\n@@ -121598,0 +127222,2 @@\n+    assert( pPk!=0 );\n+    assert( pPk->nKeyCol>=1 );\n@@ -121599,1 +127225,3 @@\n-      const char *zName = pTab->aCol[pPk->aiColumn[0]].zCnName;\n+      const char *zName;\n+      assert( pPk->aiColumn[0]>=0 && pPk->aiColumn[0]<pTab->nCol );\n+      zName = pTab->aCol[pPk->aiColumn[0]].zCnName;\n@@ -121605,1 +127233,3 @@\n-        Expr *p = sqlite3Expr(db, TK_ID, pTab->aCol[pPk->aiColumn[i]].zCnName);\n+        Expr *p;\n+        assert( pPk->aiColumn[i]>=0 && pPk->aiColumn[i]<pTab->nCol );\n+        p = sqlite3Expr(db, TK_ID, pTab->aCol[pPk->aiColumn[i]].zCnName);\n@@ -121634,1 +127264,1 @@\n-  \/* now generate the new WHERE rowid IN clause for the DELETE\/UDPATE *\/\n+  \/* now generate the new WHERE rowid IN clause for the DELETE\/UPDATE *\/\n@@ -121749,1 +127379,1 @@\n-  if( sqlite3IsReadOnly(pParse, pTab, (pTrigger?1:0)) ){\n+  if( sqlite3IsReadOnly(pParse, pTab, pTrigger) ){\n@@ -121848,1 +127478,0 @@\n-      sqlite3VdbeAddOp2(v, OP_Clear, pIdx->tnum, iDb);\n@@ -121850,1 +127479,3 @@\n-        sqlite3VdbeChangeP3(v, -1, memCnt ? memCnt : -1);\n+        sqlite3VdbeAddOp3(v, OP_Clear, pIdx->tnum, iDb, memCnt ? memCnt : -1);\n+      }else{\n+        sqlite3VdbeAddOp2(v, OP_Clear, pIdx->tnum, iDb);\n@@ -121857,1 +127488,1 @@\n-    if( sNC.ncFlags & NC_VarSelect ) bComplex = 1;\n+    if( sNC.ncFlags & NC_Subquery ) bComplex = 1;\n@@ -121862,1 +127493,1 @@\n-      nPk = 1;\n+      assert( nPk==1 );\n@@ -121890,1 +127521,2 @@\n-    assert( IsVirtual(pTab) || bComplex || eOnePass!=ONEPASS_OFF );\n+    assert( IsVirtual(pTab) || bComplex || eOnePass!=ONEPASS_OFF\n+            || OptimizationDisabled(db, SQLITE_OnePass) );\n@@ -122050,1 +127682,1 @@\n-  sqlite3DbFree(db, aToOpen);\n+  if( aToOpen ) sqlite3DbNNFreeNN(db, aToOpen);\n@@ -122227,3 +127859,5 @@\n-  sqlite3CodeRowTrigger(pParse, pTrigger,\n-      TK_DELETE, 0, TRIGGER_AFTER, pTab, iOld, onconf, iLabel\n-  );\n+  if( pTrigger ){\n+    sqlite3CodeRowTrigger(pParse, pTrigger,\n+        TK_DELETE, 0, TRIGGER_AFTER, pTab, iOld, onconf, iLabel\n+    );\n+  }\n@@ -122542,0 +128176,36 @@\n+\/*\n+** Implementation of the octet_length() function\n+*\/\n+static void bytelengthFunc(\n+  sqlite3_context *context,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  assert( argc==1 );\n+  UNUSED_PARAMETER(argc);\n+  switch( sqlite3_value_type(argv[0]) ){\n+    case SQLITE_BLOB: {\n+      sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));\n+      break;\n+    }\n+    case SQLITE_INTEGER:\n+    case SQLITE_FLOAT: {\n+      i64 m = sqlite3_context_db_handle(context)->enc<=SQLITE_UTF8 ? 1 : 2;\n+      sqlite3_result_int64(context, sqlite3_value_bytes(argv[0])*m);\n+      break;\n+    }\n+    case SQLITE_TEXT: {\n+      if( sqlite3_value_encoding(argv[0])<=SQLITE_UTF8 ){\n+        sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));\n+      }else{\n+        sqlite3_result_int(context, sqlite3_value_bytes16(argv[0]));\n+      }\n+      break;\n+    }\n+    default: {\n+      sqlite3_result_null(context);\n+      break;\n+    }\n+  }\n+}\n+\n@@ -122818,1 +128488,1 @@\n-    zBuf = sqlite3_mprintf(\"%.*f\",n,r);\n+    zBuf = sqlite3_mprintf(\"%!.*f\",n,r);\n@@ -123018,1 +128688,1 @@\n-** character is exactly one byte in size.  Also, provde the Utf8Read()\n+** character is exactly one byte in size.  Also, provide the Utf8Read()\n@@ -123133,1 +128803,1 @@\n-      if( c<=0x80 ){\n+      if( c<0x80 ){\n@@ -123216,1 +128886,7 @@\n-  return patternCompare((u8*)zGlobPattern, (u8*)zString, &globInfo, '[');\n+  if( zString==0 ){\n+    return zGlobPattern!=0;\n+  }else if( zGlobPattern==0 ){\n+    return 1;\n+  }else {\n+    return patternCompare((u8*)zGlobPattern, (u8*)zString, &globInfo, '[');\n+  }\n@@ -123224,1 +128900,7 @@\n-  return patternCompare((u8*)zPattern, (u8*)zStr, &likeInfoNorm, esc);\n+  if( zStr==0 ){\n+    return zPattern!=0;\n+  }else if( zPattern==0 ){\n+    return 1;\n+  }else{\n+    return patternCompare((u8*)zPattern, (u8*)zStr, &likeInfoNorm, esc);\n+  }\n@@ -123239,1 +128921,1 @@\n-** the build-in LIKE operator.  The first argument to the function is the\n+** the built-in LIKE operator.  The first argument to the function is the\n@@ -123446,1 +129128,1 @@\n-      sqlite3_str_appendf(pStr, \"%!.15g\", r1);\n+      sqlite3_str_appendf(pStr, \"%!0.15g\", r1);\n@@ -123452,1 +129134,1 @@\n-          sqlite3_str_appendf(pStr, \"%!.20e\", r1);\n+          sqlite3_str_appendf(pStr, \"%!0.20e\", r1);\n@@ -123463,1 +129145,1 @@\n-      int nBlob = sqlite3_value_bytes(pValue);\n+      i64 nBlob = sqlite3_value_bytes(pValue);\n@@ -123572,0 +129254,1 @@\n+  *zOut = 0;\n@@ -123600,1 +129283,2 @@\n-    sqlite3_result_text(context, zHex, n*2, sqlite3_free);\n+    sqlite3_result_text64(context, zHex, (u64)(z-zHex),\n+                          sqlite3_free, SQLITE_UTF8);\n@@ -123604,0 +129288,90 @@\n+\/*\n+** Buffer zStr contains nStr bytes of utf-8 encoded text. Return 1 if zStr\n+** contains character ch, or 0 if it does not.\n+*\/\n+static int strContainsChar(const u8 *zStr, int nStr, u32 ch){\n+  const u8 *zEnd = &zStr[nStr];\n+  const u8 *z = zStr;\n+  while( z<zEnd ){\n+    u32 tst = Utf8Read(z);\n+    if( tst==ch ) return 1;\n+  }\n+  return 0;\n+}\n+\n+\/*\n+** The unhex() function. This function may be invoked with either one or\n+** two arguments. In both cases the first argument is interpreted as text\n+** a text value containing a set of pairs of hexadecimal digits which are\n+** decoded and returned as a blob.\n+**\n+** If there is only a single argument, then it must consist only of an\n+** even number of hexadecimal digits. Otherwise, return NULL.\n+**\n+** Or, if there is a second argument, then any character that appears in\n+** the second argument is also allowed to appear between pairs of hexadecimal\n+** digits in the first argument. If any other character appears in the\n+** first argument, or if one of the allowed characters appears between\n+** two hexadecimal digits that make up a single byte, NULL is returned.\n+**\n+** The following expressions are all true:\n+**\n+**     unhex('ABCD')       IS x'ABCD'\n+**     unhex('AB CD')      IS NULL\n+**     unhex('AB CD', ' ') IS x'ABCD'\n+**     unhex('A BCD', ' ') IS NULL\n+*\/\n+static void unhexFunc(\n+  sqlite3_context *pCtx,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  const u8 *zPass = (const u8*)\"\";\n+  int nPass = 0;\n+  const u8 *zHex = sqlite3_value_text(argv[0]);\n+  int nHex = sqlite3_value_bytes(argv[0]);\n+#ifdef SQLITE_DEBUG\n+  const u8 *zEnd = zHex ? &zHex[nHex] : 0;\n+#endif\n+  u8 *pBlob = 0;\n+  u8 *p = 0;\n+\n+  assert( argc==1 || argc==2 );\n+  if( argc==2 ){\n+    zPass = sqlite3_value_text(argv[1]);\n+    nPass = sqlite3_value_bytes(argv[1]);\n+  }\n+  if( !zHex || !zPass ) return;\n+\n+  p = pBlob = contextMalloc(pCtx, (nHex\/2)+1);\n+  if( pBlob ){\n+    u8 c;                         \/* Most significant digit of next byte *\/\n+    u8 d;                         \/* Least significant digit of next byte *\/\n+\n+    while( (c = *zHex)!=0x00 ){\n+      while( !sqlite3Isxdigit(c) ){\n+        u32 ch = Utf8Read(zHex);\n+        assert( zHex<=zEnd );\n+        if( !strContainsChar(zPass, nPass, ch) ) goto unhex_null;\n+        c = *zHex;\n+        if( c==0x00 ) goto unhex_done;\n+      }\n+      zHex++;\n+      assert( *zEnd==0x00 );\n+      assert( zHex<=zEnd );\n+      d = *(zHex++);\n+      if( !sqlite3Isxdigit(d) ) goto unhex_null;\n+      *(p++) = (sqlite3HexToInt(c)<<4) | sqlite3HexToInt(d);\n+    }\n+  }\n+\n+ unhex_done:\n+  sqlite3_result_blob(pCtx, pBlob, (p - pBlob), sqlite3_free);\n+  return;\n+\n+ unhex_null:\n+  sqlite3_free(pBlob);\n+  return;\n+}\n+\n+\n@@ -123662,1 +129436,1 @@\n-    sqlite3_result_value(context, argv[0]);\n+    sqlite3_result_text(context, (const char*)zStr, nStr, SQLITE_TRANSIENT);\n@@ -123804,0 +129578,75 @@\n+\/* The core implementation of the CONCAT(...) and CONCAT_WS(SEP,...)\n+** functions.\n+**\n+** Return a string value that is the concatenation of all non-null\n+** entries in argv[].  Use zSep as the separator.\n+*\/\n+static void concatFuncCore(\n+  sqlite3_context *context,\n+  int argc,\n+  sqlite3_value **argv,\n+  int nSep,\n+  const char *zSep\n+){\n+  i64 j, k, n = 0;\n+  int i;\n+  char *z;\n+  for(i=0; i<argc; i++){\n+    n += sqlite3_value_bytes(argv[i]);\n+  }\n+  n += (argc-1)*nSep;\n+  z = sqlite3_malloc64(n+1);\n+  if( z==0 ){\n+    sqlite3_result_error_nomem(context);\n+    return;\n+  }\n+  j = 0;\n+  for(i=0; i<argc; i++){\n+    k = sqlite3_value_bytes(argv[i]);\n+    if( k>0 ){\n+      const char *v = (const char*)sqlite3_value_text(argv[i]);\n+      if( v!=0 ){\n+        if( j>0 && nSep>0 ){\n+          memcpy(&z[j], zSep, nSep);\n+          j += nSep;\n+        }\n+        memcpy(&z[j], v, k);\n+        j += k;\n+      }\n+    }\n+  }\n+  z[j] = 0;\n+  assert( j<=n );\n+  sqlite3_result_text64(context, z, j, sqlite3_free, SQLITE_UTF8);\n+}\n+\n+\/*\n+** The CONCAT(...) function.  Generate a string result that is the\n+** concatentation of all non-null arguments.\n+*\/\n+static void concatFunc(\n+  sqlite3_context *context,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  concatFuncCore(context, argc, argv, 0, \"\");\n+}\n+\n+\/*\n+** The CONCAT_WS(separator, ...) function.\n+**\n+** Generate a string that is the concatenation of 2nd through the Nth\n+** argument.  Use the first argument (which must be non-NULL) as the\n+** separator.\n+*\/\n+static void concatwsFunc(\n+  sqlite3_context *context,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  int nSep = sqlite3_value_bytes(argv[0]);\n+  const char *zSep = (const char*)sqlite3_value_text(argv[0]);\n+  if( zSep==0 ) return;\n+  concatFuncCore(context, argc-1, argv+1, nSep, zSep);\n+}\n+\n@@ -123809,1 +129658,1 @@\n-** when the SQLITE_ENABLE_UNKNOWN_FUNCTION compile-time option is used.\n+** when the SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION compile-time option is used.\n@@ -123821,0 +129670,3 @@\n+  (void)context;\n+  (void)argc;\n+  (void)argv;\n@@ -123922,2 +129774,3 @@\n-  double rSum;      \/* Floating point sum *\/\n-  i64 iSum;         \/* Integer sum *\/\n+  double rSum;      \/* Running sum as as a double *\/\n+  double rErr;      \/* Error term for Kahan-Babushka-Neumaier summation *\/\n+  i64 iSum;         \/* Running sum as a signed integer *\/\n@@ -123925,2 +129778,2 @@\n-  u8 overflow;      \/* True if integer overflow seen *\/\n-  u8 approx;        \/* True if non-integer value was input to the sum *\/\n+  u8 approx;        \/* True if any non-integer value was input to the sum *\/\n+  u8 ovrfl;         \/* Integer overflow seen *\/\n@@ -123929,0 +129782,54 @@\n+\/*\n+** Do one step of the Kahan-Babushka-Neumaier summation.\n+**\n+** https:\/\/en.wikipedia.org\/wiki\/Kahan_summation_algorithm\n+**\n+** Variables are marked \"volatile\" to defeat c89 x86 floating point\n+** optimizations can mess up this algorithm.\n+*\/\n+static void kahanBabuskaNeumaierStep(\n+  volatile SumCtx *pSum,\n+  volatile double r\n+){\n+  volatile double s = pSum->rSum;\n+  volatile double t = s + r;\n+  if( fabs(s) > fabs(r) ){\n+    pSum->rErr += (s - t) + r;\n+  }else{\n+    pSum->rErr += (r - t) + s;\n+  }\n+  pSum->rSum = t;\n+}\n+\n+\/*\n+** Add a (possibly large) integer to the running sum.\n+*\/\n+static void kahanBabuskaNeumaierStepInt64(volatile SumCtx *pSum, i64 iVal){\n+  if( iVal<=-4503599627370496LL || iVal>=+4503599627370496LL ){\n+    i64 iBig, iSm;\n+    iSm = iVal % 16384;\n+    iBig = iVal - iSm;\n+    kahanBabuskaNeumaierStep(pSum, iBig);\n+    kahanBabuskaNeumaierStep(pSum, iSm);\n+  }else{\n+    kahanBabuskaNeumaierStep(pSum, (double)iVal);\n+  }\n+}\n+\n+\/*\n+** Initialize the Kahan-Babaska-Neumaier sum from a 64-bit integer\n+*\/\n+static void kahanBabuskaNeumaierInit(\n+  volatile SumCtx *p,\n+  i64 iVal\n+){\n+  if( iVal<=-4503599627370496LL || iVal>=+4503599627370496LL ){\n+    i64 iSm = iVal % 16384;\n+    p->rSum = (double)(iVal - iSm);\n+    p->rErr = (double)iSm;\n+  }else{\n+    p->rSum = (double)iVal;\n+    p->rErr = 0.0;\n+  }\n+}\n+\n@@ -123948,5 +129855,15 @@\n-    if( type==SQLITE_INTEGER ){\n-      i64 v = sqlite3_value_int64(argv[0]);\n-      p->rSum += v;\n-      if( (p->approx|p->overflow)==0 && sqlite3AddInt64(&p->iSum, v) ){\n-        p->approx = p->overflow = 1;\n+    if( p->approx==0 ){\n+      if( type!=SQLITE_INTEGER ){\n+        kahanBabuskaNeumaierInit(p, p->iSum);\n+        p->approx = 1;\n+        kahanBabuskaNeumaierStep(p, sqlite3_value_double(argv[0]));\n+      }else{\n+        i64 x = p->iSum;\n+        if( sqlite3AddInt64(&x, sqlite3_value_int64(argv[0]))==0 ){\n+          p->iSum = x;\n+        }else{\n+          p->ovrfl = 1;\n+          kahanBabuskaNeumaierInit(p, p->iSum);\n+          p->approx = 1;\n+          kahanBabuskaNeumaierStepInt64(p, sqlite3_value_int64(argv[0]));\n+        }\n@@ -123955,2 +129872,6 @@\n-      p->rSum += sqlite3_value_double(argv[0]);\n-      p->approx = 1;\n+      if( type==SQLITE_INTEGER ){\n+        kahanBabuskaNeumaierStepInt64(p, sqlite3_value_int64(argv[0]));\n+      }else{\n+        p->ovrfl = 0;\n+        kahanBabuskaNeumaierStep(p, sqlite3_value_double(argv[0]));\n+      }\n@@ -123973,5 +129894,10 @@\n-    assert( type==SQLITE_INTEGER || p->approx );\n-    if( type==SQLITE_INTEGER && p->approx==0 ){\n-      i64 v = sqlite3_value_int64(argv[0]);\n-      p->rSum -= v;\n-      p->iSum -= v;\n+    if( !p->approx ){\n+      p->iSum -= sqlite3_value_int64(argv[0]);\n+    }else if( type==SQLITE_INTEGER ){\n+      i64 iVal = sqlite3_value_int64(argv[0]);\n+      if( iVal!=SMALLEST_INT64 ){\n+        kahanBabuskaNeumaierStepInt64(p, -iVal);\n+      }else{\n+        kahanBabuskaNeumaierStepInt64(p, LARGEST_INT64);\n+        kahanBabuskaNeumaierStepInt64(p, 1);\n+      }\n@@ -123979,1 +129905,1 @@\n-      p->rSum -= sqlite3_value_double(argv[0]);\n+      kahanBabuskaNeumaierStep(p, -sqlite3_value_double(argv[0]));\n@@ -123990,4 +129916,8 @@\n-    if( p->overflow ){\n-      sqlite3_result_error(context,\"integer overflow\",-1);\n-    }else if( p->approx ){\n-      sqlite3_result_double(context, p->rSum);\n+    if( p->approx ){\n+      if( p->ovrfl ){\n+        sqlite3_result_error(context,\"integer overflow\",-1);\n+      }else if( !sqlite3IsOverflow(p->rErr) ){\n+        sqlite3_result_double(context, p->rSum+p->rErr);\n+      }else{\n+        sqlite3_result_double(context, p->rSum);\n+      }\n@@ -124003,1 +129933,8 @@\n-    sqlite3_result_double(context, p->rSum\/(double)p->cnt);\n+    double r;\n+    if( p->approx ){\n+      r = p->rSum;\n+      if( !sqlite3IsOverflow(p->rErr) ) r += p->rErr;\n+    }else{\n+      r = (double)(p->iSum);\n+    }\n+    sqlite3_result_double(context, r\/(double)p->cnt);\n@@ -124008,0 +129945,1 @@\n+  double r = 0.0;\n@@ -124009,2 +129947,9 @@\n-  \/* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... *\/\n-  sqlite3_result_double(context, p ? p->rSum : (double)0);\n+  if( p ){\n+    if( p->approx ){\n+      r = p->rSum;\n+      if( !sqlite3IsOverflow(p->rErr) ) r += p->rErr;\n+    }else{\n+      r = (double)(p->iSum);\n+    }\n+  }\n+  sqlite3_result_double(context, r);\n@@ -124129,0 +130074,1 @@\n+** string_agg(EXPR, SEPARATOR)\n@@ -124232,1 +130178,1 @@\n-  ** run frist to initialize it *\/\n+  ** run first to initialize it *\/\n@@ -124316,0 +130262,1 @@\n+  FuncDef *pDef;\n@@ -124318,0 +130265,1 @@\n+  int nArg;\n@@ -124325,4 +130273,7 @@\n-  sqlite3CreateFunc(db, \"like\", 2, SQLITE_UTF8, pInfo, likeFunc, 0, 0, 0, 0, 0);\n-  sqlite3CreateFunc(db, \"like\", 3, SQLITE_UTF8, pInfo, likeFunc, 0, 0, 0, 0, 0);\n-  sqlite3FindFunction(db, \"like\", 2, SQLITE_UTF8, 0)->funcFlags |= flags;\n-  sqlite3FindFunction(db, \"like\", 3, SQLITE_UTF8, 0)->funcFlags |= flags;\n+  for(nArg=2; nArg<=3; nArg++){\n+    sqlite3CreateFunc(db, \"like\", nArg, SQLITE_UTF8, pInfo, likeFunc,\n+                      0, 0, 0, 0, 0);\n+    pDef = sqlite3FindFunction(db, \"like\", nArg, SQLITE_UTF8, 0);\n+    pDef->funcFlags |= flags;\n+    pDef->funcFlags &= ~SQLITE_FUNC_UNSAFE;\n+  }\n@@ -124449,0 +130400,12 @@\n+\/*\n+** Some systems do not have log2() and log10() in their standard math\n+** libraries.\n+*\/\n+#if defined(HAVE_LOG10) && HAVE_LOG10==0\n+# define log10(X) (0.4342944819032517867*log(X))\n+#endif\n+#if defined(HAVE_LOG2) && HAVE_LOG2==0\n+# define log2(X) (1.442695040888963456*log(X))\n+#endif\n+\n+\n@@ -124487,1 +130450,0 @@\n-    ans = log(x);\n@@ -124490,2 +130452,1 @@\n-        \/* Convert from natural logarithm to log base 10 *\/\n-        ans \/= M_LN10;\n+        ans = log10(x);\n@@ -124494,2 +130455,1 @@\n-        \/* Convert from natural logarithm to log base 2 *\/\n-        ans \/= M_LN2;\n+        ans = log2(x);\n@@ -124498,0 +130458,1 @@\n+        ans = log(x);\n@@ -124566,0 +130527,1 @@\n+  (void)argv;\n@@ -124589,0 +130551,31 @@\n+#ifdef SQLITE_DEBUG\n+\/*\n+** Implementation of fpdecode(x,y,z) function.\n+**\n+** x is a real number that is to be decoded.  y is the precision.\n+** z is the maximum real precision.\n+*\/\n+static void fpdecodeFunc(\n+  sqlite3_context *context,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  FpDecode s;\n+  double x;\n+  int y, z;\n+  char zBuf[100];\n+  UNUSED_PARAMETER(argc);\n+  assert( argc==3 );\n+  x = sqlite3_value_double(argv[0]);\n+  y = sqlite3_value_int(argv[1]);\n+  z = sqlite3_value_int(argv[2]);\n+  sqlite3FpDecode(&s, x, y, z);\n+  if( s.isSpecial==2 ){\n+    sqlite3_snprintf(sizeof(zBuf), zBuf, \"NaN\");\n+  }else{\n+    sqlite3_snprintf(sizeof(zBuf), zBuf, \"%c%.*s\/%d\", s.sign, s.n, s.z, s.iDP);\n+  }\n+  sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);\n+}\n+#endif \/* SQLITE_DEBUG *\/\n+\n@@ -124653,0 +130646,1 @@\n+    FUNCTION2(octet_length,      1, 0, 0, bytelengthFunc,SQLITE_FUNC_BYTELEN),\n@@ -124659,0 +130653,3 @@\n+#ifdef SQLITE_DEBUG\n+    FUNCTION(fpdecode,           3, 0, 0, fpdecodeFunc     ),\n+#endif\n@@ -124666,0 +130663,7 @@\n+    FUNCTION(unhex,              1, 0, 0, unhexFunc        ),\n+    FUNCTION(unhex,              2, 0, 0, unhexFunc        ),\n+    FUNCTION(concat,            -1, 0, 0, concatFunc       ),\n+    FUNCTION(concat,             0, 0, 0, 0                ),\n+    FUNCTION(concat_ws,         -1, 0, 0, concatwsFunc     ),\n+    FUNCTION(concat_ws,          0, 0, 0, 0                ),\n+    FUNCTION(concat_ws,          1, 0, 0, 0                ),\n@@ -124695,0 +130699,2 @@\n+    WAGGREGATE(string_agg,   2, 0, 0, groupConcatStep,\n+        groupConcatFinalize, groupConcatValue, groupConcatInverse, 0),\n@@ -125637,0 +131643,1 @@\n+      assert( (pTop->db->flags & SQLITE_FkNoAction)==0 );\n@@ -125831,0 +131838,2 @@\n+        if( (db->flags & SQLITE_FkNoAction) ) eAction = OE_None;\n+\n@@ -125946,1 +131955,5 @@\n-          if( p->aAction[1]!=OE_None ) return 2;\n+          if( (pParse->db->flags & SQLITE_FkNoAction)==0\n+           && p->aAction[1]!=OE_None\n+          ){\n+            return 2;\n+          }\n@@ -125996,0 +132009,1 @@\n+  if( (db->flags & SQLITE_FkNoAction) ) action = OE_None;\n@@ -126096,2 +132110,1 @@\n-      Token tFrom;\n-      Token tDb;\n+      SrcList *pSrc;\n@@ -126100,5 +132113,0 @@\n-      tFrom.z = zFrom;\n-      tFrom.n = nFrom;\n-      tDb.z = db->aDb[iDb].zDbSName;\n-      tDb.n = sqlite3Strlen30(tDb.z);\n-\n@@ -126109,0 +132117,6 @@\n+      pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);\n+      if( pSrc ){\n+        assert( pSrc->nSrc==1 );\n+        pSrc->a[0].zName = sqlite3DbStrDup(db, zFrom);\n+        pSrc->a[0].zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zDbSName);\n+      }\n@@ -126111,1 +132125,1 @@\n-          sqlite3SrcListAppend(pParse, 0, &tDb, &tFrom),\n+          pSrc,\n@@ -126218,0 +132232,1 @@\n+  assert( db!=0 );\n@@ -126222,1 +132237,1 @@\n-    if( !db || db->pnBytesFreed==0 ){\n+    if( db->pnBytesFreed==0 ){\n@@ -126226,3 +132241,2 @@\n-        void *p = (void *)pFKey->pNextTo;\n-        const char *z = (p ? pFKey->pNextTo->zTo : pFKey->zTo);\n-        sqlite3HashInsert(&pTab->pSchema->fkeyHash, z, p);\n+        const char *z = (pFKey->pNextTo ? pFKey->pNextTo->zTo : pFKey->zTo);\n+        sqlite3HashInsert(&pTab->pSchema->fkeyHash, z, pFKey->pNextTo);\n@@ -126291,2 +132305,4 @@\n-  sqlite3TableLock(pParse, iDb, pTab->tnum,\n-                   (opcode==OP_OpenWrite)?1:0, pTab->zName);\n+  if( !pParse->db->noSharedCache ){\n+    sqlite3TableLock(pParse, iDb, pTab->tnum,\n+                     (opcode==OP_OpenWrite)?1:0, pTab->zName);\n+  }\n@@ -126326,1 +132342,12 @@\n-SQLITE_PRIVATE const char *sqlite3IndexAffinityStr(sqlite3 *db, Index *pIdx){\n+static SQLITE_NOINLINE const char *computeIndexAffStr(sqlite3 *db, Index *pIdx){\n+  \/* The first time a column affinity string for a particular index is\n+  ** required, it is allocated and populated here. It is then stored as\n+  ** a member of the Index structure for subsequent use.\n+  **\n+  ** The column affinity string will eventually be deleted by\n+  ** sqliteDeleteIndex() when the Index structure itself is cleaned\n+  ** up.\n+  *\/\n+  int n;\n+  Table *pTab = pIdx->pTable;\n+  pIdx->zColAff = (char *)sqlite3DbMallocRaw(0, pIdx->nColumn+1);\n@@ -126328,14 +132355,15 @@\n-    \/* The first time a column affinity string for a particular index is\n-    ** required, it is allocated and populated here. It is then stored as\n-    ** a member of the Index structure for subsequent use.\n-    **\n-    ** The column affinity string will eventually be deleted by\n-    ** sqliteDeleteIndex() when the Index structure itself is cleaned\n-    ** up.\n-    *\/\n-    int n;\n-    Table *pTab = pIdx->pTable;\n-    pIdx->zColAff = (char *)sqlite3DbMallocRaw(0, pIdx->nColumn+1);\n-    if( !pIdx->zColAff ){\n-      sqlite3OomFault(db);\n-      return 0;\n+    sqlite3OomFault(db);\n+    return 0;\n+  }\n+  for(n=0; n<pIdx->nColumn; n++){\n+    i16 x = pIdx->aiColumn[n];\n+    char aff;\n+    if( x>=0 ){\n+      aff = pTab->aCol[x].affinity;\n+    }else if( x==XN_ROWID ){\n+      aff = SQLITE_AFF_INTEGER;\n+    }else{\n+      assert( x==XN_EXPR );\n+      assert( pIdx->bHasExpr );\n+      assert( pIdx->aColExpr!=0 );\n+      aff = sqlite3ExprAffinity(pIdx->aColExpr->a[n].pExpr);\n@@ -126343,11 +132371,26 @@\n-    for(n=0; n<pIdx->nColumn; n++){\n-      i16 x = pIdx->aiColumn[n];\n-      char aff;\n-      if( x>=0 ){\n-        aff = pTab->aCol[x].affinity;\n-      }else if( x==XN_ROWID ){\n-        aff = SQLITE_AFF_INTEGER;\n-      }else{\n-        assert( x==XN_EXPR );\n-        assert( pIdx->aColExpr!=0 );\n-        aff = sqlite3ExprAffinity(pIdx->aColExpr->a[n].pExpr);\n+    if( aff<SQLITE_AFF_BLOB ) aff = SQLITE_AFF_BLOB;\n+    if( aff>SQLITE_AFF_NUMERIC) aff = SQLITE_AFF_NUMERIC;\n+    pIdx->zColAff[n] = aff;\n+  }\n+  pIdx->zColAff[n] = 0;\n+  return pIdx->zColAff;\n+}\n+SQLITE_PRIVATE const char *sqlite3IndexAffinityStr(sqlite3 *db, Index *pIdx){\n+  if( !pIdx->zColAff ) return computeIndexAffStr(db, pIdx);\n+  return pIdx->zColAff;\n+}\n+\n+\n+\/*\n+** Compute an affinity string for a table.   Space is obtained\n+** from sqlite3DbMalloc().  The caller is responsible for freeing\n+** the space when done.\n+*\/\n+SQLITE_PRIVATE char *sqlite3TableAffinityStr(sqlite3 *db, const Table *pTab){\n+  char *zColAff;\n+  zColAff = (char *)sqlite3DbMallocRaw(db, pTab->nCol+1);\n+  if( zColAff ){\n+    int i, j;\n+    for(i=j=0; i<pTab->nCol; i++){\n+      if( (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ){\n+        zColAff[j++] = pTab->aCol[i].affinity;\n@@ -126355,3 +132398,0 @@\n-      if( aff<SQLITE_AFF_BLOB ) aff = SQLITE_AFF_BLOB;\n-      if( aff>SQLITE_AFF_NUMERIC) aff = SQLITE_AFF_NUMERIC;\n-      pIdx->zColAff[n] = aff;\n@@ -126359,1 +132399,3 @@\n-    pIdx->zColAff[n] = 0;\n+    do{\n+      zColAff[j--] = 0;\n+    }while( j>=0 && zColAff[j]<=SQLITE_AFF_BLOB );\n@@ -126361,2 +132403,1 @@\n-\n-  return pIdx->zColAff;\n+  return zColAff;\n@@ -126396,1 +132437,1 @@\n-** Generate an appropropriate OP_TypeCheck opcode that will verify the\n+** Generate an appropriate OP_TypeCheck opcode that will verify the\n@@ -126406,1 +132447,1 @@\n-  int i, j;\n+  int i;\n@@ -126415,1 +132456,1 @@\n-      pPrev = sqlite3VdbeGetOp(v, -1);\n+      pPrev = sqlite3VdbeGetLastOp(v);\n@@ -126429,2 +132470,1 @@\n-    sqlite3 *db = sqlite3VdbeDb(v);\n-    zColAff = (char *)sqlite3DbMallocRaw(0, pTab->nCol+1);\n+    zColAff = sqlite3TableAffinityStr(0, pTab);\n@@ -126432,1 +132472,1 @@\n-      sqlite3OomFault(db);\n+      sqlite3OomFault(sqlite3VdbeDb(v));\n@@ -126435,10 +132475,0 @@\n-\n-    for(i=j=0; i<pTab->nCol; i++){\n-      assert( pTab->aCol[i].affinity!=0 || sqlite3VdbeParser(v)->nErr>0 );\n-      if( (pTab->aCol[i].colFlags & COLFLAG_VIRTUAL)==0 ){\n-        zColAff[j++] = pTab->aCol[i].affinity;\n-      }\n-    }\n-    do{\n-      zColAff[j--] = 0;\n-    }while( j>=0 && zColAff[j]<=SQLITE_AFF_BLOB );\n@@ -126453,1 +132483,1 @@\n-      assert( sqlite3VdbeGetOp(v, -1)->opcode==OP_MakeRecord\n+      assert( sqlite3VdbeGetLastOp(v)->opcode==OP_MakeRecord\n@@ -126539,1 +132569,1 @@\n-    pOp = sqlite3VdbeGetOp(pParse->pVdbe,-1);\n+    pOp = sqlite3VdbeGetLastOp(pParse->pVdbe);\n@@ -127038,1 +133068,1 @@\n-  if( sqlite3IsReadOnly(pParse, pTab, tmask) ){\n+  if( sqlite3IsReadOnly(pParse, pTab, pTrigger) ){\n@@ -127326,1 +133356,1 @@\n-        if( sqlite3UpsertAnalyzeTarget(pParse, pTabList, pNx) ){\n+        if( sqlite3UpsertAnalyzeTarget(pParse, pTabList, pNx, pUpsert) ){\n@@ -127445,1 +133475,6 @@\n-      sqlite3ExprCode(pParse, pList->a[k].pExpr, iRegStore);\n+      Expr *pX = pList->a[k].pExpr;\n+      int y = sqlite3ExprCodeTarget(pParse, pX, iRegStore);\n+      if( y!=iRegStore ){\n+        sqlite3VdbeAddOp2(v,\n+          ExprHasProperty(pX, EP_Subquery) ? OP_Copy : OP_SCopy, y, iRegStore);\n+      }\n@@ -127480,1 +133515,1 @@\n-    assert( pTab->nNVCol>0 );\n+    assert( pTab->nNVCol>0 || pParse->nErr>0 );\n@@ -127582,1 +133617,3 @@\n-      sqlite3FkCheck(pParse, pTab, 0, regIns, 0, 0);\n+      if( db->flags & SQLITE_ForeignKeys ){\n+        sqlite3FkCheck(pParse, pTab, 0, regIns, 0, 0);\n+      }\n@@ -127666,1 +133703,1 @@\n-  sqlite3DbFree(db, aRegIdx);\n+  if( aRegIdx ) sqlite3DbNNFreeNN(db, aRegIdx);\n@@ -127692,1 +133729,1 @@\n-** columns that are being modifed by an UPDATE statement.\n+** columns that are being modified by an UPDATE statement.\n@@ -127915,1 +133952,1 @@\n-  Vdbe *v;             \/* VDBE under constrution *\/\n+  Vdbe *v;             \/* VDBE under construction *\/\n@@ -128030,0 +134067,1 @@\n+            testcase( zMsg==0 && db->mallocFailed==0 );\n@@ -128397,1 +134435,1 @@\n-    int regIdx;          \/* Range of registers hold conent for pIdx *\/\n+    int regIdx;          \/* Range of registers holding content for pIdx *\/\n@@ -128892,0 +134930,2 @@\n+  assert( piDataCur!=0 );\n+  assert( piIdxCur!=0 );\n@@ -128904,1 +134944,1 @@\n-  if( piDataCur ) *piDataCur = iDataCur;\n+  *piDataCur = iDataCur;\n@@ -128907,1 +134947,1 @@\n-  }else{\n+  }else if( pParse->db->noSharedCache==0 ){\n@@ -128910,1 +134950,1 @@\n-  if( piIdxCur ) *piIdxCur = iBase;\n+  *piIdxCur = iBase;\n@@ -128915,1 +134955,1 @@\n-      if( piDataCur ) *piDataCur = iIdxCur;\n+      *piDataCur = iIdxCur;\n@@ -129208,1 +135248,4 @@\n-  if( pDest->pCheck && sqlite3ExprListCompare(pSrc->pCheck,pDest->pCheck,-1) ){\n+  if( pDest->pCheck\n+   && (db->mDbFlags & DBFLAG_Vacuum)==0\n+   && sqlite3ExprListCompare(pSrc->pCheck,pDest->pCheck,-1)\n+  ){\n@@ -129213,1 +135256,1 @@\n-  \/* Disallow the transfer optimization if the destination table constains\n+  \/* Disallow the transfer optimization if the destination table contains\n@@ -129893,1 +135936,1 @@\n-  char *(*create_filename)(const char*,const char*,const char*,\n+  const char *(*create_filename)(const char*,const char*,const char*,\n@@ -129895,1 +135938,1 @@\n-  void (*free_filename)(char*);\n+  void (*free_filename)(const char*);\n@@ -129919,0 +135962,9 @@\n+  \/* Version 3.40.0 and later *\/\n+  int (*value_encoding)(sqlite3_value*);\n+  \/* Version 3.41.0 and later *\/\n+  int (*is_interrupted)(sqlite3*);\n+  \/* Version 3.43.0 and later *\/\n+  int (*stmt_explain)(sqlite3_stmt*,int);\n+  \/* Version 3.44.0 and later *\/\n+  void *(*get_clientdata)(sqlite3*,const char*);\n+  int (*set_clientdata)(sqlite3*, const char*, void*, void(*)(void*));\n@@ -130243,0 +136295,9 @@\n+\/* Version 3.40.0 and later *\/\n+#define sqlite3_value_encoding         sqlite3_api->value_encoding\n+\/* Version 3.41.0 and later *\/\n+#define sqlite3_is_interrupted         sqlite3_api->is_interrupted\n+\/* Version 3.43.0 and later *\/\n+#define sqlite3_stmt_explain           sqlite3_api->stmt_explain\n+\/* Version 3.44.0 and later *\/\n+#define sqlite3_get_clientdata         sqlite3_api->get_clientdata\n+#define sqlite3_set_clientdata         sqlite3_api->set_clientdata\n@@ -130755,1 +136816,10 @@\n-  sqlite3_db_name\n+  sqlite3_db_name,\n+  \/* Version 3.40.0 and later *\/\n+  sqlite3_value_encoding,\n+  \/* Version 3.41.0 and later *\/\n+  sqlite3_is_interrupted,\n+  \/* Version 3.43.0 and later *\/\n+  sqlite3_stmt_explain,\n+  \/* Version 3.44.0 and later *\/\n+  sqlite3_get_clientdata,\n+  sqlite3_set_clientdata\n@@ -130828,1 +136898,5 @@\n-  ** https:\/\/sqlite.org\/forum\/forumpost\/08a0d6d9bf *\/\n+  ** https:\/\/sqlite.org\/forum\/forumpost\/08a0d6d9bf\n+  **\n+  ** Later (2023-03-25): Save an extra 6 bytes for the filename suffix.\n+  ** See https:\/\/sqlite.org\/forum\/forumpost\/24083b579d.\n+  *\/\n@@ -130831,0 +136905,4 @@\n+  \/* Do not allow sqlite3_load_extension() to link to a copy of the\n+  ** running application, by passing in an empty filename. *\/\n+  if( nMsg==0 ) goto extension_not_found;\n+\n@@ -130836,1 +136914,3 @@\n-    handle = sqlite3OsDlOpen(pVfs, zAltFile);\n+    if( nMsg+strlen(azEndings[ii])+1<=SQLITE_MAX_PATHLEN ){\n+      handle = sqlite3OsDlOpen(pVfs, zAltFile);\n+    }\n@@ -130961,0 +137041,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n+#endif\n@@ -131010,0 +137093,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( xInit==0 ) return SQLITE_MISUSE_BKPT;\n+#endif\n@@ -131062,0 +137148,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( xInit==0 ) return 0;\n+#endif\n@@ -132661,1 +138750,1 @@\n-  ** or off.  When turnning cache spill on, the size is set to the\n+  ** or off.  When turning cache spill on, the size is set to the\n@@ -132931,1 +139020,5 @@\n-        db->flags |= mask;\n+        if( (mask & SQLITE_WriteSchema)==0\n+         || (db->flags & SQLITE_Defensive)==0\n+        ){\n+          db->flags |= mask;\n+        }\n@@ -133331,1 +139424,1 @@\n-      if( pTab->nCol+regRow>pParse->nMem ) pParse->nMem = pTab->nCol + regRow;\n+      sqlite3TouchRegister(pParse, pTab->nCol+regRow);\n@@ -133372,1 +139465,1 @@\n-        if( regRow+pFK->nCol>pParse->nMem ) pParse->nMem = regRow+pFK->nCol;\n+        sqlite3TouchRegister(pParse, regRow + pFK->nCol);\n@@ -133439,1 +139532,1 @@\n-  ** is linear time wherease integrity_check is O(NlogN).\n+  ** is linear time whereas integrity_check is O(NlogN).\n@@ -133441,1 +139534,1 @@\n-  ** The maximum nubmer of errors is 100 by default.  A different default\n+  ** The maximum number of errors is 100 by default.  A different default\n@@ -133501,0 +139594,1 @@\n+      pParse->okConstFactor = 0;  \/* tag-20230327-1 *\/\n@@ -133536,1 +139630,1 @@\n-      pParse->nMem = MAX( pParse->nMem, 8+mxIdx );\n+      sqlite3TouchRegister(pParse, 8+mxIdx);\n@@ -133555,1 +139649,1 @@\n-        Index *pPrior = 0;\n+        Index *pPrior = 0;      \/* Previous index *\/\n@@ -133559,1 +139653,3 @@\n-        int bStrict;\n+        int bStrict;            \/* True for a STRICT table *\/\n+        int r2;                 \/* Previous key for WITHOUT ROWID tables *\/\n+        int mxCol;              \/* Maximum non-virtual column number *\/\n@@ -133561,1 +139657,0 @@\n-        if( !IsOrdinaryTable(pTab) ) continue;\n@@ -133563,1 +139658,9 @@\n-        pPk = HasRowid(pTab) ? 0 : sqlite3PrimaryKeyIndex(pTab);\n+        if( !IsOrdinaryTable(pTab) ) continue;\n+        if( isQuick || HasRowid(pTab) ){\n+          pPk = 0;\n+          r2 = 0;\n+        }else{\n+          pPk = sqlite3PrimaryKeyIndex(pTab);\n+          r2 = sqlite3GetTempRange(pParse, pPk->nKeyCol);\n+          sqlite3VdbeAddOp3(v, OP_Null, 1, r2, r2+pPk->nKeyCol-1);\n+        }\n@@ -133577,0 +139680,24 @@\n+\n+        \/* Fetch the right-most column from the table.  This will cause\n+        ** the entire record header to be parsed and sanity checked.  It\n+        ** will also prepopulate the cursor column cache that is used\n+        ** by the OP_IsType code, so it is a required step.\n+        *\/\n+        assert( !IsVirtual(pTab) );\n+        if( HasRowid(pTab) ){\n+          mxCol = -1;\n+          for(j=0; j<pTab->nCol; j++){\n+            if( (pTab->aCol[j].colFlags & COLFLAG_VIRTUAL)==0 ) mxCol++;\n+          }\n+          if( mxCol==pTab->iPKey ) mxCol--;\n+        }else{\n+          \/* COLFLAG_VIRTUAL columns are not included in the WITHOUT ROWID\n+          ** PK index column-count, so there is no need to account for them\n+          ** in this case. *\/\n+          mxCol = sqlite3PrimaryKeyIndex(pTab)->nColumn-1;\n+        }\n+        if( mxCol>=0 ){\n+          sqlite3VdbeAddOp3(v, OP_Column, iDataCur, mxCol, 3);\n+          sqlite3VdbeTypeofColumn(v, 3);\n+        }\n+\n@@ -133578,4 +139705,18 @@\n-          \/* Sanity check on record header decoding *\/\n-          sqlite3VdbeAddOp3(v, OP_Column, iDataCur, pTab->nNVCol-1,3);\n-          sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n-          VdbeComment((v, \"(right-most column)\"));\n+          if( pPk ){\n+            \/* Verify WITHOUT ROWID keys are in ascending order *\/\n+            int a1;\n+            char *zErr;\n+            a1 = sqlite3VdbeAddOp4Int(v, OP_IdxGT, iDataCur, 0,r2,pPk->nKeyCol);\n+            VdbeCoverage(v);\n+            sqlite3VdbeAddOp1(v, OP_IsNull, r2); VdbeCoverage(v);\n+            zErr = sqlite3MPrintf(db,\n+                   \"row not in PRIMARY KEY order for %s\",\n+                    pTab->zName);\n+            sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n+            integrityCheckResultRow(v);\n+            sqlite3VdbeJumpHere(v, a1);\n+            sqlite3VdbeJumpHere(v, a1+1);\n+            for(j=0; j<pPk->nKeyCol; j++){\n+              sqlite3ExprCodeLoadIndexColumn(pParse, pPk, iDataCur, j, r2+j);\n+            }\n+          }\n@@ -133583,2 +139724,9 @@\n-        \/* Verify that all NOT NULL columns really are NOT NULL.  At the\n-        ** same time verify the type of the content of STRICT tables *\/\n+        \/* Verify datatypes for all columns:\n+        **\n+        **   (1) NOT NULL columns may not contain a NULL\n+        **   (2) Datatype must be exact for non-ANY columns in STRICT tables\n+        **   (3) Datatype for TEXT columns in non-STRICT tables must be\n+        **       NULL, TEXT, or BLOB.\n+        **   (4) Datatype for numeric columns in non-STRICT tables must not\n+        **       be a TEXT value that can be losslessly converted to numeric.\n+        *\/\n@@ -133588,2 +139736,6 @@\n-          Column *pCol = pTab->aCol + j;\n-          int doError, jmp2;\n+          Column *pCol = pTab->aCol + j;  \/* The column to be checked *\/\n+          int labelError;               \/* Jump here to report an error *\/\n+          int labelOk;                  \/* Jump here if all looks ok *\/\n+          int p1, p3, p4;               \/* Operands to the OP_IsType opcode *\/\n+          int doTypeCheck;              \/* Check datatypes (besides NOT NULL) *\/\n+\n@@ -133591,5 +139743,31 @@\n-          if( pCol->notNull==0 && !bStrict ) continue;\n-          doError = bStrict ? sqlite3VdbeMakeLabel(pParse) : 0;\n-          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n-          if( sqlite3VdbeGetOp(v,-1)->opcode==OP_Column ){\n-            sqlite3VdbeChangeP5(v, OPFLAG_TYPEOFARG);\n+          if( bStrict ){\n+            doTypeCheck = pCol->eCType>COLTYPE_ANY;\n+          }else{\n+            doTypeCheck = pCol->affinity>SQLITE_AFF_BLOB;\n+          }\n+          if( pCol->notNull==0 && !doTypeCheck ) continue;\n+\n+          \/* Compute the operands that will be needed for OP_IsType *\/\n+          p4 = SQLITE_NULL;\n+          if( pCol->colFlags & COLFLAG_VIRTUAL ){\n+            sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n+            p1 = -1;\n+            p3 = 3;\n+          }else{\n+            if( pCol->iDflt ){\n+              sqlite3_value *pDfltValue = 0;\n+              sqlite3ValueFromExpr(db, sqlite3ColumnExpr(pTab,pCol), ENC(db),\n+                                   pCol->affinity, &pDfltValue);\n+              if( pDfltValue ){\n+                p4 = sqlite3_value_type(pDfltValue);\n+                sqlite3ValueFree(pDfltValue);\n+              }\n+            }\n+            p1 = iDataCur;\n+            if( !HasRowid(pTab) ){\n+              testcase( j!=sqlite3TableColumnToStorage(pTab, j) );\n+              p3 = sqlite3TableColumnToIndex(sqlite3PrimaryKeyIndex(pTab), j);\n+            }else{\n+              p3 = sqlite3TableColumnToStorage(pTab,j);\n+              testcase( p3!=j);\n+            }\n@@ -133597,0 +139775,3 @@\n+\n+          labelError = sqlite3VdbeMakeLabel(pParse);\n+          labelOk = sqlite3VdbeMakeLabel(pParse);\n@@ -133598,1 +139779,18 @@\n-            jmp2 = sqlite3VdbeAddOp1(v, OP_NotNull, 3); VdbeCoverage(v);\n+            \/* (1) NOT NULL columns may not contain a NULL *\/\n+            int jmp3;\n+            int jmp2 = sqlite3VdbeAddOp4Int(v, OP_IsType, p1, labelOk, p3, p4);\n+            VdbeCoverage(v);\n+            if( p1<0 ){\n+              sqlite3VdbeChangeP5(v, 0x0f); \/* INT, REAL, TEXT, or BLOB *\/\n+              jmp3 = jmp2;\n+            }else{\n+              sqlite3VdbeChangeP5(v, 0x0d); \/* INT, TEXT, or BLOB *\/\n+              \/* OP_IsType does not detect NaN values in the database file\n+              ** which should be treated as a NULL.  So if the header type\n+              ** is REAL, we have to load the actual data using OP_Column\n+              ** to reliably determine if the value is a NULL. *\/\n+              sqlite3VdbeAddOp3(v, OP_Column, p1, p3, 3);\n+              sqlite3ColumnDefault(v, pTab, j, 3);\n+              jmp3 = sqlite3VdbeAddOp2(v, OP_NotNull, 3, labelOk);\n+              VdbeCoverage(v);\n+            }\n@@ -133602,2 +139800,4 @@\n-            if( bStrict && pCol->eCType!=COLTYPE_ANY ){\n-              sqlite3VdbeGoto(v, doError);\n+            if( doTypeCheck ){\n+              sqlite3VdbeGoto(v, labelError);\n+              sqlite3VdbeJumpHere(v, jmp2);\n+              sqlite3VdbeJumpHere(v, jmp3);\n@@ -133605,1 +139805,1 @@\n-              integrityCheckResultRow(v);\n+              \/* VDBE byte code will fall thru *\/\n@@ -133607,1 +139807,0 @@\n-            sqlite3VdbeJumpHere(v, jmp2);\n@@ -133609,5 +139808,13 @@\n-          if( (pTab->tabFlags & TF_Strict)!=0\n-           && pCol->eCType!=COLTYPE_ANY\n-          ){\n-            jmp2 = sqlite3VdbeAddOp3(v, OP_IsNullOrType, 3, 0,\n-                                     sqlite3StdTypeMap[pCol->eCType-1]);\n+          if( bStrict && doTypeCheck ){\n+            \/* (2) Datatype must be exact for non-ANY columns in STRICT tables*\/\n+            static unsigned char aStdTypeMask[] = {\n+               0x1f,    \/* ANY *\/\n+               0x18,    \/* BLOB *\/\n+               0x11,    \/* INT *\/\n+               0x11,    \/* INTEGER *\/\n+               0x13,    \/* REAL *\/\n+               0x14     \/* TEXT *\/\n+            };\n+            sqlite3VdbeAddOp4Int(v, OP_IsType, p1, labelOk, p3, p4);\n+            assert( pCol->eCType>=1 && pCol->eCType<=sizeof(aStdTypeMask) );\n+            sqlite3VdbeChangeP5(v, aStdTypeMask[pCol->eCType-1]);\n@@ -133619,3 +139826,25 @@\n-            sqlite3VdbeResolveLabel(v, doError);\n-            integrityCheckResultRow(v);\n-            sqlite3VdbeJumpHere(v, jmp2);\n+          }else if( !bStrict && pCol->affinity==SQLITE_AFF_TEXT ){\n+            \/* (3) Datatype for TEXT columns in non-STRICT tables must be\n+            **     NULL, TEXT, or BLOB. *\/\n+            sqlite3VdbeAddOp4Int(v, OP_IsType, p1, labelOk, p3, p4);\n+            sqlite3VdbeChangeP5(v, 0x1c); \/* NULL, TEXT, or BLOB *\/\n+            VdbeCoverage(v);\n+            zErr = sqlite3MPrintf(db, \"NUMERIC value in %s.%s\",\n+                                  pTab->zName, pTab->aCol[j].zCnName);\n+            sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n+          }else if( !bStrict && pCol->affinity>=SQLITE_AFF_NUMERIC ){\n+            \/* (4) Datatype for numeric columns in non-STRICT tables must not\n+            **     be a TEXT value that can be converted to numeric. *\/\n+            sqlite3VdbeAddOp4Int(v, OP_IsType, p1, labelOk, p3, p4);\n+            sqlite3VdbeChangeP5(v, 0x1b); \/* NULL, INT, FLOAT, or BLOB *\/\n+            VdbeCoverage(v);\n+            if( p1>=0 ){\n+              sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);\n+            }\n+            sqlite3VdbeAddOp4(v, OP_Affinity, 3, 1, 0, \"C\", P4_STATIC);\n+            sqlite3VdbeAddOp4Int(v, OP_IsType, -1, labelOk, 3, p4);\n+            sqlite3VdbeChangeP5(v, 0x1c); \/* NULL, TEXT, or BLOB *\/\n+            VdbeCoverage(v);\n+            zErr = sqlite3MPrintf(db, \"TEXT value in %s.%s\",\n+                                  pTab->zName, pTab->aCol[j].zCnName);\n+            sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, zErr, P4_DYNAMIC);\n@@ -133623,0 +139852,3 @@\n+          sqlite3VdbeResolveLabel(v, labelError);\n+          integrityCheckResultRow(v);\n+          sqlite3VdbeResolveLabel(v, labelOk);\n@@ -133651,1 +139883,2 @@\n-            int jmp2, jmp3, jmp4, jmp5;\n+            int jmp2, jmp3, jmp4, jmp5, label6;\n+            int kk;\n@@ -133669,0 +139902,37 @@\n+\n+            \/* The OP_IdxRowid opcode is an optimized version of OP_Column\n+            ** that extracts the rowid off the end of the index record.\n+            ** But it only works correctly if index record does not have\n+            ** any extra bytes at the end.  Verify that this is the case. *\/\n+            if( HasRowid(pTab) ){\n+              int jmp7;\n+              sqlite3VdbeAddOp2(v, OP_IdxRowid, iIdxCur+j, 3);\n+              jmp7 = sqlite3VdbeAddOp3(v, OP_Eq, 3, 0, r1+pIdx->nColumn-1);\n+              VdbeCoverageNeverNull(v);\n+              sqlite3VdbeLoadString(v, 3,\n+                 \"rowid not at end-of-record for row \");\n+              sqlite3VdbeAddOp3(v, OP_Concat, 7, 3, 3);\n+              sqlite3VdbeLoadString(v, 4, \" of index \");\n+              sqlite3VdbeGoto(v, jmp5-1);\n+              sqlite3VdbeJumpHere(v, jmp7);\n+            }\n+\n+            \/* Any indexed columns with non-BINARY collations must still hold\n+            ** the exact same text value as the table. *\/\n+            label6 = 0;\n+            for(kk=0; kk<pIdx->nKeyCol; kk++){\n+              if( pIdx->azColl[kk]==sqlite3StrBINARY ) continue;\n+              if( label6==0 ) label6 = sqlite3VdbeMakeLabel(pParse);\n+              sqlite3VdbeAddOp3(v, OP_Column, iIdxCur+j, kk, 3);\n+              sqlite3VdbeAddOp3(v, OP_Ne, 3, label6, r1+kk); VdbeCoverage(v);\n+            }\n+            if( label6 ){\n+              int jmp6 = sqlite3VdbeAddOp0(v, OP_Goto);\n+              sqlite3VdbeResolveLabel(v, label6);\n+              sqlite3VdbeLoadString(v, 3, \"row \");\n+              sqlite3VdbeAddOp3(v, OP_Concat, 7, 3, 3);\n+              sqlite3VdbeLoadString(v, 4, \" values differ from index \");\n+              sqlite3VdbeGoto(v, jmp5-1);\n+              sqlite3VdbeJumpHere(v, jmp6);\n+            }\n+\n@@ -133675,1 +139945,0 @@\n-              int kk;\n@@ -133710,0 +139979,3 @@\n+          if( pPk ){\n+            sqlite3ReleaseTempRange(pParse, r2, pPk->nKeyCol);\n+          }\n@@ -133712,0 +139984,32 @@\n+\n+#ifndef SQLITE_OMIT_VIRTUALTABLE\n+      \/* Second pass to invoke the xIntegrity method on all virtual\n+      ** tables.\n+      *\/\n+      for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n+        Table *pTab = sqliteHashData(x);\n+        sqlite3_vtab *pVTab;\n+        int a1;\n+        if( pObjTab && pObjTab!=pTab ) continue;\n+        if( IsOrdinaryTable(pTab) ) continue;\n+        if( !IsVirtual(pTab) ) continue;\n+        if( pTab->nCol<=0 ){\n+          const char *zMod = pTab->u.vtab.azArg[0];\n+          if( sqlite3HashFind(&db->aModule, zMod)==0 ) continue;\n+        }\n+        sqlite3ViewGetColumnNames(pParse, pTab);\n+        if( pTab->u.vtab.p==0 ) continue;\n+        pVTab = pTab->u.vtab.p->pVtab;\n+        if( NEVER(pVTab==0) ) continue;\n+        if( NEVER(pVTab->pModule==0) ) continue;\n+        if( pVTab->pModule->iVersion<4 ) continue;\n+        if( pVTab->pModule->xIntegrity==0 ) continue;\n+        sqlite3VdbeAddOp3(v, OP_VCheck, i, 3, isQuick);\n+        pTab->nTabRef++;\n+        sqlite3VdbeAppendP4(v, pTab, P4_TABLEREF);\n+        a1 = sqlite3VdbeAddOp1(v, OP_IsNull, 3); VdbeCoverage(v);\n+        integrityCheckResultRow(v);\n+        sqlite3VdbeJumpHere(v, a1);\n+        continue;\n+      }\n+#endif\n@@ -133860,0 +140164,5 @@\n+      if( iCookie==BTREE_SCHEMA_VERSION && (db->flags & SQLITE_Defensive)!=0 ){\n+        \/* Do not allow the use of PRAGMA schema_version=VALUE in defensive\n+        ** mode.  Change the OP_SetCookie opcode into a no-op.  *\/\n+        aOp[1].opcode = OP_Noop;\n+      }\n@@ -134016,1 +140325,1 @@\n-    LogEst szThreshold;    \/* Size threshold above which reanalysis is needd *\/\n+    LogEst szThreshold;    \/* Size threshold above which reanalysis needed *\/\n@@ -134343,1 +140652,5 @@\n-  if( seen[1]==0 ) return SQLITE_OK;\n+  if( seen[1]==0 ){\n+    pIdxInfo->estimatedCost = (double)1000;\n+    pIdxInfo->estimatedRows = 1000;\n+    return SQLITE_OK;\n+  }\n@@ -134508,1 +140821,2 @@\n-  0                            \/* xShadowName *\/\n+  0,                           \/* xShadowName *\/\n+  0                            \/* xIntegrity *\/\n@@ -134840,1 +141154,8 @@\n-      sqlite3SetTextEncoding(db, encoding);\n+      if( db->nVdbeActive>0 && encoding!=ENC(db)\n+       && (db->mDbFlags & DBFLAG_Vacuum)==0\n+      ){\n+        rc = SQLITE_LOCKED;\n+        goto initone_error_out;\n+      }else{\n+        sqlite3SetTextEncoding(db, encoding);\n+      }\n@@ -135054,0 +141375,1 @@\n+      if( DbHasProperty(db, iDb, DB_SchemaLoaded) ) pParse->rc = SQLITE_SCHEMA;\n@@ -135055,1 +141377,0 @@\n-      pParse->rc = SQLITE_SCHEMA;\n@@ -135108,1 +141429,1 @@\n-  sqlite3DbFree(db, pParse->aTableLock);\n+  if( pParse->aTableLock ) sqlite3DbNNFreeNN(db, pParse->aTableLock);\n@@ -135114,1 +141435,1 @@\n-    sqlite3DbFreeNN(db, pCleanup);\n+    sqlite3DbNNFreeNN(db, pCleanup);\n@@ -135116,1 +141437,1 @@\n-  sqlite3DbFree(db, pParse->aLabel);\n+  if( pParse->aLabel ) sqlite3DbNNFreeNN(db, pParse->aLabel);\n@@ -135125,2 +141446,0 @@\n-  pParse->db = 0;\n-  pParse->disableLookaside = 0;\n@@ -135135,1 +141454,1 @@\n-** cost for this mechansim (an extra malloc), so it should not be used\n+** cost for this mechanism (an extra malloc), so it should not be used\n@@ -135227,1 +141546,6 @@\n-  sParse.pReprepare = pReprepare;\n+  if( pReprepare ){\n+    sParse.pReprepare = pReprepare;\n+    sParse.explain = sqlite3_stmt_isexplain((sqlite3_stmt*)pReprepare);\n+  }else{\n+    assert( sParse.pReprepare==0 );\n+  }\n@@ -135229,1 +141553,5 @@\n-  if( db->mallocFailed ) sqlite3ErrorMsg(&sParse, \"out of memory\");\n+  if( db->mallocFailed ){\n+    sqlite3ErrorMsg(&sParse, \"out of memory\");\n+    db->errCode = rc = SQLITE_NOMEM;\n+    goto end_prepare;\n+  }\n@@ -135239,1 +141567,1 @@\n-  sParse.disableVtab = (prepFlags & SQLITE_PREPARE_NO_VTAB)!=0;\n+  sParse.prepFlags = prepFlags & 0xff;\n@@ -135280,1 +141608,3 @@\n-  sqlite3VtabUnlockList(db);\n+#ifndef SQLITE_OMIT_VIRTUALTABLE\n+  if( db->pDisconnect ) sqlite3VtabUnlockList(db);\n+#endif\n@@ -135386,0 +141716,1 @@\n+  assert( rc==SQLITE_OK || (*ppStmt)==0 );\n@@ -135664,0 +141995,4 @@\n+#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n+  int addrPush;         \/* First instruction to push data into sorter *\/\n+  int addrPushEnd;      \/* Last instruction that pushes data into sorter *\/\n+#endif\n@@ -135675,0 +142010,1 @@\n+  assert( db!=0 );\n@@ -135694,1 +142030,1 @@\n-    if( bFree ) sqlite3DbFreeNN(db, p);\n+    if( bFree ) sqlite3DbNNFreeNN(db, p);\n@@ -135778,0 +142114,3 @@\n+SQLITE_PRIVATE void sqlite3SelectDeleteGeneric(sqlite3 *db, void *p){\n+  if( ALWAYS(p) ) clearSelect(db, (Select*)p, 1);\n+}\n@@ -135826,1 +142165,1 @@\n-** of other non-standard and in many cases non-sensical join types.\n+** of other non-standard and in many cases nonsensical join types.\n@@ -136048,0 +142387,1 @@\n+      assert( p->pLeft==0 );\n@@ -136097,1 +142437,1 @@\n-    \/* If this is a NATURAL join, synthesize an approprate USING clause\n+    \/* If this is a NATURAL join, synthesize an appropriate USING clause\n@@ -136311,1 +142651,1 @@\n-  **       the SQLITE_ENABLE_SORTER_REFERENCE optimization, or due to the\n+  **       the SQLITE_ENABLE_SORTER_REFERENCES optimization, or due to the\n@@ -136313,1 +142653,1 @@\n-  **       SortCtx.pDeferredRowLoad optimiation.  In any of these cases\n+  **       SortCtx.pDeferredRowLoad optimization.  In any of these cases\n@@ -136319,0 +142659,4 @@\n+#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n+  pSort->addrPush = sqlite3VdbeCurrentAddr(v);\n+#endif\n+\n@@ -136365,1 +142709,1 @@\n-    pOp = 0; \/* Ensure pOp not used after sqltie3VdbeAddOp3() *\/\n+    pOp = 0; \/* Ensure pOp not used after sqlite3VdbeAddOp3() *\/\n@@ -136419,0 +142763,3 @@\n+#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n+  pSort->addrPushEnd = sqlite3VdbeCurrentAddr(v)-1;\n+#endif\n@@ -136456,1 +142803,1 @@\n-**     In this case rows are being delivered sorted order. The ephermal\n+**     In this case rows are being delivered sorted order. The ephemeral\n@@ -136885,0 +143232,10 @@\n+#if !defined(SQLITE_ENABLE_NULL_TRIM) && defined(SQLITE_DEBUG)\n+      \/* A destination of SRT_Table and a non-zero iSDParm2 parameter means\n+      ** that this is an \"UPDATE ... FROM\" on a virtual table or view. In this\n+      ** case set the p5 parameter of the OP_MakeRecord to OPFLAG_NOCHNG_MAGIC.\n+      ** This does not affect operation in any way - it just allows MakeRecord\n+      ** to process OPFLAG_NOCHANGE values without an assert() failing. *\/\n+      if( eDest==SRT_Table && pDest->iSDParm2 ){\n+        sqlite3VdbeChangeP5(v, OPFLAG_NOCHNG_MAGIC);\n+      }\n+#endif\n@@ -137100,0 +143457,1 @@\n+    assert( p->db!=0 );\n@@ -137102,1 +143460,1 @@\n-    if( p->nRef==0 ) sqlite3DbFreeNN(p->db, p);\n+    if( p->nRef==0 ) sqlite3DbNNFreeNN(p->db, p);\n@@ -137241,0 +143599,10 @@\n+#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n+  int addrExplain;                \/* Address of OP_Explain instruction *\/\n+#endif\n+\n+  ExplainQueryPlan2(addrExplain, (pParse, 0,\n+        \"USE TEMP B-TREE FOR %sORDER BY\", pSort->nOBSat>0?\"RIGHT PART OF \":\"\")\n+  );\n+  sqlite3VdbeScanStatusRange(v, addrExplain,pSort->addrPush,pSort->addrPushEnd);\n+  sqlite3VdbeScanStatusCounters(v, addrExplain, addrExplain, pSort->addrPush);\n+\n@@ -137353,0 +143721,1 @@\n+  sqlite3VdbeScanStatusRange(v, addrExplain, addrExplain, -1);\n@@ -137414,0 +143783,1 @@\n+  sqlite3VdbeScanStatusRange(v, addrExplain, sqlite3VdbeCurrentAddr(v)-1, -1);\n@@ -137422,3 +143792,0 @@\n-** Also try to estimate the size of the returned value and return that\n-** result in *pEstWidth.\n-**\n@@ -137516,5 +143883,1 @@\n-#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n-         && iCol>=0\n-#else\n-         && ALWAYS(iCol>=0)\n-#endif\n+         && (!ViewCanHaveRowid || iCol>=0)\n@@ -137678,7 +144041,0 @@\n-#ifndef SQLITE_OMIT_EXPLAIN\n-  \/* If this is an EXPLAIN, skip this step *\/\n-  if( pParse->explain ){\n-    return;\n-  }\n-#endif\n-\n@@ -137688,1 +144044,1 @@\n-  SELECTTRACE(1,pParse,pSelect,(\"generating column names\\n\"));\n+  TREETRACE(0x80,pParse,pSelect,(\"generating column names\\n\"));\n@@ -137788,1 +144144,1 @@\n-  for(i=0, pCol=aCol; i<nCol && !db->mallocFailed; i++, pCol++){\n+  for(i=0, pCol=aCol; i<nCol && !pParse->nErr; i++, pCol++){\n@@ -137838,1 +144194,4 @@\n-      if( cnt>3 ) sqlite3_randomness(sizeof(cnt), &cnt);\n+      sqlite3ProgressCheck(pParse);\n+      if( cnt>3 ){\n+        sqlite3_randomness(sizeof(cnt), &cnt);\n+      }\n@@ -137851,1 +144210,1 @@\n-  if( db->mallocFailed ){\n+  if( pParse->nErr ){\n@@ -137858,1 +144217,1 @@\n-    return SQLITE_NOMEM_BKPT;\n+    return pParse->rc;\n@@ -137864,2 +144223,5 @@\n-** Add type and collation information to a column list based on\n-** a SELECT statement.\n+** pTab is a transient Table object that represents a subquery of some\n+** kind (maybe a parenthesized subquery in the FROM clause of a larger\n+** query, or a VIEW, or a CTE).  This routine computes type information\n+** for that Table object based on the Select object that implements the\n+** subquery.  For the purposes of this routine, \"type information\" means:\n@@ -137867,6 +144229,3 @@\n-** The column list presumably came from selectColumnNamesFromExprList().\n-** The column list has only names, not types or collations.  This\n-** routine goes through and adds the types and collations.\n-**\n-** This routine requires that all identifiers in the SELECT\n-** statement be resolved.\n+**    *   The datatype name, as it might appear in a CREATE TABLE statement\n+**    *   Which collating sequence to use for the column\n+**    *   The affinity of the column\n@@ -137874,5 +144233,5 @@\n-SQLITE_PRIVATE void sqlite3SelectAddColumnTypeAndCollation(\n-  Parse *pParse,        \/* Parsing contexts *\/\n-  Table *pTab,          \/* Add column type information to this table *\/\n-  Select *pSelect,      \/* SELECT used to determine types and collations *\/\n-  char aff              \/* Default affinity for columns *\/\n+SQLITE_PRIVATE void sqlite3SubqueryColumnTypes(\n+  Parse *pParse,      \/* Parsing contexts *\/\n+  Table *pTab,        \/* Add column type information to this table *\/\n+  Select *pSelect,    \/* SELECT used to determine types and collations *\/\n+  char aff            \/* Default affinity. *\/\n@@ -137881,1 +144240,0 @@\n-  NameContext sNC;\n@@ -137884,1 +144242,1 @@\n-  int i;\n+  int i,j;\n@@ -137887,0 +144245,1 @@\n+  NameContext sNC;\n@@ -137889,3 +144248,7 @@\n-  assert( (pSelect->selFlags & SF_Resolved)!=0 );\n-  assert( pTab->nCol==pSelect->pEList->nExpr || db->mallocFailed );\n-  if( db->mallocFailed ) return;\n+  testcase( (pSelect->selFlags & SF_Resolved)==0 );\n+  assert( (pSelect->selFlags & SF_Resolved)!=0 || IN_RENAME_OBJECT );\n+  assert( pTab->nCol==pSelect->pEList->nExpr || pParse->nErr>0 );\n+  assert( aff==SQLITE_AFF_NONE || aff==SQLITE_AFF_BLOB );\n+  if( db->mallocFailed || IN_RENAME_OBJECT ) return;\n+  while( pSelect->pPrior ) pSelect = pSelect->pPrior;\n+  a = pSelect->pEList->a;\n@@ -137894,1 +144257,0 @@\n-  a = pSelect->pEList->a;\n@@ -137897,1 +144259,1 @@\n-    i64 n, m;\n+    i64 n;\n@@ -137900,1 +144262,0 @@\n-    zType = columnType(&sNC, p, 0, 0, 0);\n@@ -137903,0 +144264,35 @@\n+    if( pCol->affinity<=SQLITE_AFF_NONE ){\n+      pCol->affinity = aff;\n+    }\n+    if( pCol->affinity>=SQLITE_AFF_TEXT && pSelect->pNext ){\n+      int m = 0;\n+      Select *pS2;\n+      for(m=0, pS2=pSelect->pNext; pS2; pS2=pS2->pNext){\n+        m |= sqlite3ExprDataType(pS2->pEList->a[i].pExpr);\n+      }\n+      if( pCol->affinity==SQLITE_AFF_TEXT && (m&0x01)!=0 ){\n+        pCol->affinity = SQLITE_AFF_BLOB;\n+      }else\n+      if( pCol->affinity>=SQLITE_AFF_NUMERIC && (m&0x02)!=0 ){\n+        pCol->affinity = SQLITE_AFF_BLOB;\n+      }\n+      if( pCol->affinity>=SQLITE_AFF_NUMERIC && p->op==TK_CAST ){\n+        pCol->affinity = SQLITE_AFF_FLEXNUM;\n+      }\n+    }\n+    zType = columnType(&sNC, p, 0, 0, 0);\n+    if( zType==0 || pCol->affinity!=sqlite3AffinityType(zType, 0) ){\n+      if( pCol->affinity==SQLITE_AFF_NUMERIC\n+       || pCol->affinity==SQLITE_AFF_FLEXNUM\n+      ){\n+        zType = \"NUM\";\n+      }else{\n+        zType = 0;\n+        for(j=1; j<SQLITE_N_STDTYPE; j++){\n+          if( sqlite3StdTypeAffinity[j]==pCol->affinity ){\n+            zType = sqlite3StdType[j];\n+            break;\n+          }\n+        }\n+      }\n+    }\n@@ -137904,1 +144300,1 @@\n-      m = sqlite3Strlen30(zType);\n+      i64 m = sqlite3Strlen30(zType);\n@@ -137907,0 +144303,1 @@\n+      pCol->colFlags &= ~(COLFLAG_HASTYPE|COLFLAG_HASCOLL);\n@@ -137910,3 +144307,0 @@\n-      }else{\n-        testcase( pCol->colFlags & COLFLAG_HASTYPE );\n-        pCol->colFlags &= ~(COLFLAG_HASTYPE|COLFLAG_HASCOLL);\n@@ -137915,1 +144309,0 @@\n-    if( pCol->affinity<=SQLITE_AFF_NONE ) pCol->affinity = aff;\n@@ -137949,1 +144342,1 @@\n-  sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSelect, aff);\n+  sqlite3SubqueryColumnTypes(pParse, pTab, pSelect, aff);\n@@ -138164,1 +144557,1 @@\n-  SelectDest destQueue;         \/* SelectDest targetting the Queue table *\/\n+  SelectDest destQueue;         \/* SelectDest targeting the Queue table *\/\n@@ -138474,1 +144867,1 @@\n-        SELECTTRACE(1, pParse, p, (\"multiSelect UNION ALL left...\\n\"));\n+        TREETRACE(0x200, pParse, p, (\"multiSelect UNION ALL left...\\n\"));\n@@ -138492,1 +144885,1 @@\n-        SELECTTRACE(1, pParse, p, (\"multiSelect UNION ALL right...\\n\"));\n+        TREETRACE(0x200, pParse, p, (\"multiSelect UNION ALL right...\\n\"));\n@@ -138545,1 +144938,1 @@\n-        SELECTTRACE(1, pParse, p, (\"multiSelect EXCEPT\/UNION left...\\n\"));\n+        TREETRACE(0x200, pParse, p, (\"multiSelect EXCEPT\/UNION left...\\n\"));\n@@ -138565,1 +144958,1 @@\n-        SELECTTRACE(1, pParse, p, (\"multiSelect EXCEPT\/UNION right...\\n\"));\n+        TREETRACE(0x200, pParse, p, (\"multiSelect EXCEPT\/UNION right...\\n\"));\n@@ -138626,1 +145019,1 @@\n-        SELECTTRACE(1, pParse, p, (\"multiSelect INTERSECT left...\\n\"));\n+        TREETRACE(0x400, pParse, p, (\"multiSelect INTERSECT left...\\n\"));\n@@ -138643,1 +145036,1 @@\n-        SELECTTRACE(1, pParse, p, (\"multiSelect INTERSECT right...\\n\"));\n+        TREETRACE(0x400, pParse, p, (\"multiSelect INTERSECT right...\\n\"));\n@@ -138740,3 +145133,1 @@\n-    sqlite3ParserAddCleanup(pParse,\n-        (void(*)(sqlite3*,void*))sqlite3SelectDelete,\n-        pDelete);\n+    sqlite3ParserAddCleanup(pParse, sqlite3SelectDeleteGeneric, pDelete);\n@@ -138764,1 +145155,1 @@\n-** SELECT statment.\n+** SELECT statement.\n@@ -138986,1 +145377,1 @@\n-** until all data is exhausted then jump to the \"end\" labe.  AltB, AeqB,\n+** until all data is exhausted then jump to the \"end\" label.  AltB, AeqB,\n@@ -139023,1 +145414,1 @@\n-  int addr1;            \/* Jump instructions that get retargetted *\/\n+  int addr1;            \/* Jump instructions that get retargeted *\/\n@@ -139290,2 +145681,2 @@\n-  \/* Reassemble the compound query so that it will be freed correctly\n-  ** by the calling function *\/\n+  \/* Make arrangements to free the 2nd and subsequent arms of the compound\n+  ** after the parse has finished *\/\n@@ -139293,2 +145684,1 @@\n-    sqlite3ParserAddCleanup(pParse,\n-       (void(*)(sqlite3*,void*))sqlite3SelectDelete, pSplit->pPrior);\n+    sqlite3ParserAddCleanup(pParse, sqlite3SelectDeleteGeneric, pSplit->pPrior);\n@@ -139324,1 +145714,1 @@\n-** Suppose the original expression integer constant.  Even though the table\n+** Suppose the original expression is an integer constant. Even though the table\n@@ -139350,0 +145740,1 @@\n+  ExprList *pCList;         \/* Collation sequences for replacement expr *\/\n@@ -139391,1 +145782,2 @@\n-      Expr *pCopy = pSubst->pEList->a[pExpr->iColumn].pExpr;\n+      int iColumn;\n+      Expr *pCopy;\n@@ -139393,1 +145785,3 @@\n-      assert( pSubst->pEList!=0 && pExpr->iColumn<pSubst->pEList->nExpr );\n+      iColumn = pExpr->iColumn;\n+      assert( iColumn>=0 );\n+      assert( pSubst->pEList!=0 && iColumn<pSubst->pEList->nExpr );\n@@ -139395,0 +145789,1 @@\n+      pCopy = pSubst->pEList->a[iColumn].pExpr;\n@@ -139399,1 +145794,3 @@\n-        if( pSubst->isOuterJoin && pCopy->op!=TK_COLUMN ){\n+        if( pSubst->isOuterJoin\n+         && (pCopy->op!=TK_COLUMN || pCopy->iTable!=pSubst->iNewTable)\n+        ){\n@@ -139404,0 +145801,1 @@\n+          ifNullRow.iColumn = -99;\n@@ -139430,4 +145828,4 @@\n-        if( pExpr->op!=TK_COLUMN && pExpr->op!=TK_COLLATE ){\n-          CollSeq *pColl = sqlite3ExprCollSeq(pSubst->pParse, pExpr);\n-          pExpr = sqlite3ExprAddCollateString(pSubst->pParse, pExpr,\n-              (pColl ? pColl->zName : \"BINARY\")\n+        {\n+          CollSeq *pNat = sqlite3ExprCollSeq(pSubst->pParse, pExpr);\n+          CollSeq *pColl = sqlite3ExprCollSeq(pSubst->pParse,\n+                pSubst->pCList->a[iColumn].pExpr\n@@ -139435,0 +145833,5 @@\n+          if( pNat!=pColl || (pExpr->op!=TK_COLUMN && pExpr->op!=TK_COLLATE) ){\n+            pExpr = sqlite3ExprAddCollateString(pSubst->pParse, pExpr,\n+                (pColl ? pColl->zName : \"BINARY\")\n+            );\n+          }\n@@ -139627,0 +146030,40 @@\n+\/*\n+** If pSel is not part of a compound SELECT, return a pointer to its\n+** expression list. Otherwise, return a pointer to the expression list\n+** of the leftmost SELECT in the compound.\n+*\/\n+static ExprList *findLeftmostExprlist(Select *pSel){\n+  while( pSel->pPrior ){\n+    pSel = pSel->pPrior;\n+  }\n+  return pSel->pEList;\n+}\n+\n+\/*\n+** Return true if any of the result-set columns in the compound query\n+** have incompatible affinities on one or more arms of the compound.\n+*\/\n+static int compoundHasDifferentAffinities(Select *p){\n+  int ii;\n+  ExprList *pList;\n+  assert( p!=0 );\n+  assert( p->pEList!=0 );\n+  assert( p->pPrior!=0 );\n+  pList = p->pEList;\n+  for(ii=0; ii<pList->nExpr; ii++){\n+    char aff;\n+    Select *pSub1;\n+    assert( pList->a[ii].pExpr!=0 );\n+    aff = sqlite3ExprAffinity(pList->a[ii].pExpr);\n+    for(pSub1=p->pPrior; pSub1; pSub1=pSub1->pPrior){\n+      assert( pSub1->pEList!=0 );\n+      assert( pSub1->pEList->nExpr>ii );\n+      assert( pSub1->pEList->a[ii].pExpr!=0 );\n+      if( sqlite3ExprAffinity(pSub1->pEList->a[ii].pExpr)!=aff ){\n+        return 1;\n+      }\n+    }\n+  }\n+  return 0;\n+}\n+\n@@ -139671,1 +146114,2 @@\n-**        (3c) the outer query may not be an aggregate.\n+**        (**) Was: \"The outer query may not have a GROUP BY.\" This case\n+**             is now managed correctly\n@@ -139694,1 +146138,1 @@\n-**        accidently carried the comment forward until 2014-09-15.  Original\n+**        accidentally carried the comment forward until 2014-09-15.  Original\n@@ -139728,0 +146172,2 @@\n+**        (17h) The corresponding result set expressions in all arms of the\n+**              compound must have the same affinity.\n@@ -139779,3 +146225,2 @@\n-**        is the first element of the parent query.  This must be the\n-**        the case if:\n-**        (27a) the subquery is not compound query, and\n+**        is the first element of the parent query.  Two subcases:\n+**        (27a) the subquery is not a compound query.\n@@ -139785,6 +146230,2 @@\n-**  (28)  The subquery is not a MATERIALIZED CTE.\n-**\n-**  (29)  Either the subquery is not the right-hand operand of a join with an\n-**        ON or USING clause nor the right-hand operand of a NATURAL JOIN, or\n-**        the right-most table within the FROM clause of the subquery\n-**        is not part of an outer join.\n+**  (28)  The subquery is not a MATERIALIZED CTE.  (This is handled\n+**        in the caller before ever reaching this routine.)\n@@ -139883,5 +146324,0 @@\n-  ** If the subquery is the right operand of a LEFT JOIN, then the outer\n-  ** query cannot be an aggregate. (3c)  This is an artifact of the way\n-  ** aggregates are processed - there is no mechanism to determine if\n-  ** the LEFT JOIN table should be all-NULL.\n-  **\n@@ -139892,1 +146328,0 @@\n-     || isAgg                                  \/* (3c) *\/\n@@ -139901,9 +146336,0 @@\n-#ifdef SQLITE_EXTRA_IFNULLROW\n-  else if( iFrom>0 && !isAgg ){\n-    \/* Setting isOuterJoin to -1 causes OP_IfNullRow opcodes to be generated for\n-    ** every reference to any result column from subquery in a join, even\n-    ** though they are not necessary.  This will stress-test the OP_IfNullRow\n-    ** opcode. *\/\n-    isOuterJoin = -1;\n-  }\n-#endif\n@@ -139915,3 +146341,0 @@\n-  if( pSubitem->fg.isCte && pSubitem->u2.pCteUse->eM10d==M10d_Yes ){\n-    return 0;       \/* (28) *\/\n-  }\n@@ -139919,28 +146342,2 @@\n-  \/* Restriction (29):\n-  **\n-  ** We do not want two constraints on the same term of the flattened\n-  ** query where one constraint has EP_InnerON and the other is EP_OuterON.\n-  ** To prevent this, one or the other of the following conditions must be\n-  ** false:\n-  **\n-  **   (29a)  The right-most entry in the FROM clause of the subquery\n-  **          must not be part of an outer join.\n-  **\n-  **   (29b)  The subquery itself must not be the right operand of a\n-  **          NATURAL join or a join that as an ON or USING clause.\n-  **\n-  ** These conditions are sufficient to keep an EP_OuterON from being\n-  ** flattened into an EP_InnerON.  Restrictions (3a) and (27a) prevent\n-  ** an EP_InnerON from being flattened into an EP_OuterON.\n-  *\/\n-  if( pSubSrc->nSrc>=2\n-   && (pSubSrc->a[pSubSrc->nSrc-1].fg.jointype & JT_OUTER)!=0\n-  ){\n-    if( (pSubitem->fg.jointype & JT_NATURAL)!=0\n-     || pSubitem->fg.isUsing\n-     || NEVER(pSubitem->u3.pOn!=0) \/* ON clause already shifted into WHERE *\/\n-     || pSubitem->fg.isOn\n-    ){\n-      return 0;\n-    }\n-  }\n+  \/* Condition (28) is blocked by the caller *\/\n+  assert( !pSubitem->fg.isCte || pSubitem->u2.pCteUse->eM10d!=M10d_Yes );\n@@ -139954,0 +146351,1 @@\n+    int ii;\n@@ -139986,1 +146384,0 @@\n-      int ii;\n@@ -139995,0 +146392,3 @@\n+    \/* Restriction (17h) *\/\n+    if( compoundHasDifferentAffinities(pSub) ) return 0;\n+\n@@ -140004,1 +146404,1 @@\n-  SELECTTRACE(1,pParse,p,(\"flatten %u.%p from term %d\\n\",\n+  TREETRACE(0x4,pParse,p,(\"flatten %u.%p from term %d\\n\",\n@@ -140013,1 +146413,1 @@\n-  \/* Delete the transient structures associated with thesubquery *\/\n+  \/* Delete the transient structures associated with the subquery *\/\n@@ -140083,1 +146483,1 @@\n-      SELECTTRACE(2,pParse,p,(\"compound-subquery flattener\"\n+      TREETRACE(0x4,pParse,p,(\"compound-subquery flattener\"\n@@ -140105,3 +146505,1 @@\n-      sqlite3ParserAddCleanup(pToplevel,\n-         (void(*)(sqlite3*,void*))sqlite3DeleteTable,\n-         pTabToDel);\n+      sqlite3ParserAddCleanup(pToplevel, sqlite3DeleteTableGeneric, pTabToDel);\n@@ -140195,1 +146593,1 @@\n-      ** zero them before transfering the ORDER BY clause.\n+      ** zero them before transferring the ORDER BY clause.\n@@ -140228,0 +146626,1 @@\n+      x.pCList = findLeftmostExprlist(pSub);\n@@ -140247,1 +146646,1 @@\n-    \/* Recompute the SrcList_item.colUsed masks for the flattened\n+    \/* Recompute the SrcItem.colUsed masks for the flattened\n@@ -140254,2 +146653,1 @@\n-  \/* Finially, delete what is left of the subquery and return\n-  ** success.\n+  \/* Finally, delete what is left of the subquery and return success.\n@@ -140262,2 +146660,2 @@\n-  if( sqlite3TreeTrace & 0x100 ){\n-    SELECTTRACE(0x100,pParse,p,(\"After flattening:\\n\"));\n+  if( sqlite3TreeTrace & 0x4 ){\n+    TREETRACE(0x4,pParse,p,(\"After flattening:\\n\"));\n@@ -140290,1 +146688,1 @@\n-** pColumn entires.  Also, do not add if doing so would not be appropriate.\n+** pColumn entries.  Also, do not add if doing so would not be appropriate.\n@@ -140476,1 +146874,1 @@\n-** is alway true because the comparison uses numeric affinity, but b=123\n+** is always true because the comparison uses numeric affinity, but b=123\n@@ -140560,1 +146958,1 @@\n-**   * that the window frame has a PARTITION BY clase.\n+**   * that the window frame has a PARTITION BY clause.\n@@ -140637,0 +147035,27 @@\n+**   (8) If the subquery is a compound that uses UNION, INTERSECT,\n+**       or EXCEPT, then all of the result set columns for all arms of\n+**       the compound must use the BINARY collating sequence.\n+**\n+**   (9) All three of the following are true:\n+**\n+**       (9a) The WHERE clause expression originates in the ON or USING clause\n+**            of a join (either an INNER or an OUTER join), and\n+**\n+**       (9b) The subquery is to the right of the ON\/USING clause\n+**\n+**       (9c) There is a RIGHT JOIN (or FULL JOIN) in between the ON\/USING\n+**            clause and the subquery.\n+**\n+**       Without this restriction, the push-down optimization might move\n+**       the ON\/USING filter expression from the left side of a RIGHT JOIN\n+**       over to the right side, which leads to incorrect answers.  See\n+**       also restriction (6) in sqlite3ExprIsSingleTableConstraint().\n+**\n+**  (10) The inner query is not the right-hand table of a RIGHT JOIN.\n+**\n+**  (11) The subquery is not a VALUES clause\n+**\n+**  (12) The WHERE clause is not \"rowid ISNULL\" or the equivalent.  This\n+**       case only comes up if SQLite is compiled using\n+**       SQLITE_ALLOW_ROWID_IN_VIEW.\n+**\n@@ -140644,1 +147069,2 @@\n-  SrcItem *pSrc         \/* The subquery term of the outer FROM clause *\/\n+  SrcList *pSrcList,    \/* The complete from clause of the outer query *\/\n+  int iSrc              \/* Which FROM clause term to try to push into  *\/\n@@ -140647,0 +147073,1 @@\n+  SrcItem *pSrc;        \/* The subquery FROM term into which WHERE is pushed *\/\n@@ -140648,0 +147075,1 @@\n+  pSrc = &pSrcList->a[iSrc];\n@@ -140649,2 +147077,6 @@\n-  if( pSubq->selFlags & (SF_Recursive|SF_MultiPart) ) return 0;\n-  if( pSrc->fg.jointype & (JT_LTORJ|JT_RIGHT) ) return 0;\n+  if( pSubq->selFlags & (SF_Recursive|SF_MultiPart) ){\n+    return 0;           \/* restrictions (2) and (11) *\/\n+  }\n+  if( pSrc->fg.jointype & (JT_LTORJ|JT_RIGHT) ){\n+    return 0;           \/* restrictions (10) *\/\n+  }\n@@ -140652,1 +147084,0 @@\n-#ifndef SQLITE_OMIT_WINDOWFUNC\n@@ -140655,0 +147086,1 @@\n+    int notUnionAll = 0;\n@@ -140656,0 +147088,7 @@\n+      u8 op = pSel->op;\n+      assert( op==TK_ALL || op==TK_SELECT\n+           || op==TK_UNION || op==TK_INTERSECT || op==TK_EXCEPT );\n+      if( op!=TK_ALL && op!=TK_SELECT ){\n+        notUnionAll = 1;\n+      }\n+#ifndef SQLITE_OMIT_WINDOWFUNC\n@@ -140657,0 +147096,17 @@\n+#endif\n+    }\n+    if( notUnionAll ){\n+      \/* If any of the compound arms are connected using UNION, INTERSECT,\n+      ** or EXCEPT, then we must ensure that none of the columns use a\n+      ** non-BINARY collating sequence. *\/\n+      for(pSel=pSubq; pSel; pSel=pSel->pPrior){\n+        int ii;\n+        const ExprList *pList = pSel->pEList;\n+        assert( pList!=0 );\n+        for(ii=0; ii<pList->nExpr; ii++){\n+          CollSeq *pColl = sqlite3ExprCollSeq(pParse, pList->a[ii].pExpr);\n+          if( !sqlite3IsBinary(pColl) ){\n+            return 0;  \/* Restriction (8) *\/\n+          }\n+        }\n+      }\n@@ -140659,0 +147115,1 @@\n+#ifndef SQLITE_OMIT_WINDOWFUNC\n@@ -140660,1 +147117,0 @@\n-  }\n@@ -140662,0 +147118,1 @@\n+  }\n@@ -140680,1 +147137,1 @@\n-    nChng += pushDownWhereTerms(pParse, pSubq, pWhere->pRight, pSrc);\n+    nChng += pushDownWhereTerms(pParse, pSubq, pWhere->pRight, pSrcList, iSrc);\n@@ -140684,1 +147141,18 @@\n-#if 0  \/* Legacy code. Checks now done by sqlite3ExprIsTableConstraint() *\/\n+#if 0 \/* These checks now done by sqlite3ExprIsSingleTableConstraint() *\/\n+  if( ExprHasProperty(pWhere, EP_OuterON|EP_InnerON) \/* (9a) *\/\n+   && (pSrcList->a[0].fg.jointype & JT_LTORJ)!=0     \/* Fast pre-test of (9c) *\/\n+  ){\n+    int jj;\n+    for(jj=0; jj<iSrc; jj++){\n+      if( pWhere->w.iJoin==pSrcList->a[jj].iCursor ){\n+        \/* If we reach this point, both (9a) and (9b) are satisfied.\n+        ** The following loop checks (9c):\n+        *\/\n+        for(jj++; jj<iSrc; jj++){\n+          if( (pSrcList->a[jj].fg.jointype & JT_RIGHT)!=0 ){\n+            return 0;  \/* restriction (9) *\/\n+          }\n+        }\n+      }\n+    }\n+  }\n@@ -140698,1 +147172,13 @@\n-  if( sqlite3ExprIsTableConstraint(pWhere, pSrc) ){\n+#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n+  if( ViewCanHaveRowid && (pWhere->op==TK_ISNULL || pWhere->op==TK_NOTNULL) ){\n+    Expr *pLeft = pWhere->pLeft;\n+    if( ALWAYS(pLeft)\n+     && pLeft->op==TK_COLUMN\n+     && pLeft->iColumn < 0\n+    ){\n+      return 0;  \/* Restriction (12) *\/\n+    }\n+  }\n+#endif\n+\n+  if( sqlite3ExprIsSingleTableConstraint(pWhere, pSrcList, iSrc) ){\n@@ -140710,0 +147196,1 @@\n+      x.pCList = findLeftmostExprlist(pSubq);\n@@ -140731,0 +147218,72 @@\n+\/*\n+** Check to see if a subquery contains result-set columns that are\n+** never used.  If it does, change the value of those result-set columns\n+** to NULL so that they do not cause unnecessary work to compute.\n+**\n+** Return the number of column that were changed to NULL.\n+*\/\n+static int disableUnusedSubqueryResultColumns(SrcItem *pItem){\n+  int nCol;\n+  Select *pSub;      \/* The subquery to be simplified *\/\n+  Select *pX;        \/* For looping over compound elements of pSub *\/\n+  Table *pTab;       \/* The table that describes the subquery *\/\n+  int j;             \/* Column number *\/\n+  int nChng = 0;     \/* Number of columns converted to NULL *\/\n+  Bitmask colUsed;   \/* Columns that may not be NULLed out *\/\n+\n+  assert( pItem!=0 );\n+  if( pItem->fg.isCorrelated || pItem->fg.isCte ){\n+    return 0;\n+  }\n+  assert( pItem->pTab!=0 );\n+  pTab = pItem->pTab;\n+  assert( pItem->pSelect!=0 );\n+  pSub = pItem->pSelect;\n+  assert( pSub->pEList->nExpr==pTab->nCol );\n+  for(pX=pSub; pX; pX=pX->pPrior){\n+    if( (pX->selFlags & (SF_Distinct|SF_Aggregate))!=0 ){\n+      testcase( pX->selFlags & SF_Distinct );\n+      testcase( pX->selFlags & SF_Aggregate );\n+      return 0;\n+    }\n+    if( pX->pPrior && pX->op!=TK_ALL ){\n+      \/* This optimization does not work for compound subqueries that\n+      ** use UNION, INTERSECT, or EXCEPT.  Only UNION ALL is allowed. *\/\n+      return 0;\n+    }\n+#ifndef SQLITE_OMIT_WINDOWFUNC\n+    if( pX->pWin ){\n+      \/* This optimization does not work for subqueries that use window\n+      ** functions. *\/\n+      return 0;\n+    }\n+#endif\n+  }\n+  colUsed = pItem->colUsed;\n+  if( pSub->pOrderBy ){\n+    ExprList *pList = pSub->pOrderBy;\n+    for(j=0; j<pList->nExpr; j++){\n+      u16 iCol = pList->a[j].u.x.iOrderByCol;\n+      if( iCol>0 ){\n+        iCol--;\n+        colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);\n+      }\n+    }\n+  }\n+  nCol = pTab->nCol;\n+  for(j=0; j<nCol; j++){\n+    Bitmask m = j<BMS-1 ? MASKBIT(j) : TOPBIT;\n+    if( (m & colUsed)!=0 ) continue;\n+    for(pX=pSub; pX; pX=pX->pPrior) {\n+      Expr *pY = pX->pEList->a[j].pExpr;\n+      if( pY->op==TK_NULL ) continue;\n+      pY->op = TK_NULL;\n+      ExprClearProperty(pY, EP_Skip|EP_Unlikely);\n+      pX->selFlags |= SF_PushDown;\n+      nChng++;\n+    }\n+  }\n+  return nChng;\n+}\n+\n+\n@@ -141009,2 +147568,1 @@\n-      pWith = (With*)sqlite3ParserAddCleanup(pParse,\n-                      (void(*)(sqlite3*,void*))sqlite3WithDelete,\n+      pWith = (With*)sqlite3ParserAddCleanup(pParse, sqlite3WithDeleteGeneric,\n@@ -141122,3 +147680,0 @@\n-    if( pCteUse->nUse>=2 && pCteUse->eM10d==M10d_Any ){\n-      pCteUse->eM10d = M10d_Yes;\n-    }\n@@ -141234,1 +147789,1 @@\n-** The SrcList_item structure passed as the second argument represents a\n+** The SrcItem structure passed as the second argument represents a\n@@ -141236,1 +147791,1 @@\n-** allocates and populates the SrcList_item.pTab object. If successful,\n+** allocates and populates the SrcItem.pTab object. If successful,\n@@ -141256,0 +147811,1 @@\n+  pTab->eTabType = TABTYP_VIEW;\n@@ -141261,1 +147817,2 @@\n-  pTab->tabFlags |= TF_Ephemeral;  \/* Legacy compatibility mode *\/\n+  \/* Legacy compatibility mode *\/\n+  pTab->tabFlags |= TF_Ephemeral | sqlite3Config.mNoVisibleRowid;\n@@ -141498,0 +148055,1 @@\n+        int iErrOfst;\n@@ -141499,0 +148057,1 @@\n+          assert( (selFlags & SF_NestedFrom)==0 );\n@@ -141502,0 +148061,5 @@\n+          assert( ExprUseWOfst(pE->pLeft) );\n+          iErrOfst = pE->pRight->w.iOfst;\n+        }else{\n+          assert( ExprUseWOfst(pE) );\n+          iErrOfst = pE->w.iOfst;\n@@ -141504,0 +148068,1 @@\n+          int nAdd;                    \/* Number of cols including rowid *\/\n@@ -141521,0 +148086,1 @@\n+            assert( VisibleRowid(pTab)==0 || ViewCanHaveRowid );\n@@ -141538,0 +148104,1 @@\n+              sqlite3ExprSetErrorOffset(pRight, iErrOfst);\n@@ -141550,2 +148117,5 @@\n-          for(j=0; j<pTab->nCol; j++){\n-            char *zName = pTab->aCol[j].zCnName;\n+\n+          nAdd = pTab->nCol;\n+          if( VisibleRowid(pTab) && (selFlags & SF_NestedFrom)!=0 ) nAdd++;\n+          for(j=0; j<nAdd; j++){\n+            const char *zName;\n@@ -141554,7 +148124,5 @@\n-            assert( zName );\n-            if( zTName\n-             && pNestedFrom\n-             && sqlite3MatchEName(&pNestedFrom->a[j], 0, zTName, 0)==0\n-            ){\n-              continue;\n-            }\n+            if( j==pTab->nCol ){\n+              zName = sqlite3RowidAlias(pTab);\n+              if( zName==0 ) continue;\n+            }else{\n+              zName = pTab->aCol[j].zCnName;\n@@ -141562,14 +148130,28 @@\n-            \/* If a column is marked as 'hidden', omit it from the expanded\n-            ** result-set list unless the SELECT has the SF_IncludeHidden\n-            ** bit set.\n-            *\/\n-            if( (p->selFlags & SF_IncludeHidden)==0\n-             && IsHiddenColumn(&pTab->aCol[j])\n-            ){\n-              continue;\n-            }\n-            if( (pTab->aCol[j].colFlags & COLFLAG_NOEXPAND)!=0\n-             && zTName==0\n-             && (selFlags & (SF_NestedFrom))==0\n-            ){\n-              continue;\n+              \/* If pTab is actually an SF_NestedFrom sub-select, do not\n+              ** expand any ENAME_ROWID columns.  *\/\n+              if( pNestedFrom && pNestedFrom->a[j].fg.eEName==ENAME_ROWID ){\n+                continue;\n+              }\n+\n+              if( zTName\n+               && pNestedFrom\n+               && sqlite3MatchEName(&pNestedFrom->a[j], 0, zTName, 0, 0)==0\n+              ){\n+                continue;\n+              }\n+\n+              \/* If a column is marked as 'hidden', omit it from the expanded\n+              ** result-set list unless the SELECT has the SF_IncludeHidden\n+              ** bit set.\n+              *\/\n+              if( (p->selFlags & SF_IncludeHidden)==0\n+                && IsHiddenColumn(&pTab->aCol[j])\n+              ){\n+                continue;\n+              }\n+              if( (pTab->aCol[j].colFlags & COLFLAG_NOEXPAND)!=0\n+               && zTName==0\n+               && (selFlags & (SF_NestedFrom))==0\n+              ){\n+                continue;\n+              }\n@@ -141577,0 +148159,1 @@\n+            assert( zName );\n@@ -141610,0 +148193,1 @@\n+            sqlite3ExprSetErrorOffset(pExpr, iErrOfst);\n@@ -141617,1 +148201,2 @@\n-              if( pNestedFrom ){\n+              if( pNestedFrom && (!ViewCanHaveRowid || j<pNestedFrom->nExpr) ){\n+                assert( j<pNestedFrom->nExpr );\n@@ -141625,1 +148210,1 @@\n-              pX->fg.eEName = ENAME_TAB;\n+              pX->fg.eEName = (j==pTab->nCol ? ENAME_ROWID : ENAME_TAB);\n@@ -141629,1 +148214,1 @@\n-               || (pTab->aCol[j].colFlags & COLFLAG_NOEXPAND)!=0\n+               || (j<pTab->nCol && (pTab->aCol[j].colFlags & COLFLAG_NOEXPAND))\n@@ -141664,2 +148249,2 @@\n-  if( sqlite3TreeTrace & 0x100 ){\n-    SELECTTRACE(0x100,pParse,p,(\"After result-set wildcard expansion:\\n\"));\n+  if( sqlite3TreeTrace & 0x8 ){\n+    TREETRACE(0x8,pParse,p,(\"After result-set wildcard expansion:\\n\"));\n@@ -141716,3 +148301,3 @@\n-** For each FROM-clause subquery, add Column.zType and Column.zColl\n-** information to the Table structure that represents the result set\n-** of that subquery.\n+** For each FROM-clause subquery, add Column.zType, Column.zColl, and\n+** Column.affinity information to the Table structure that represents\n+** the result set of that subquery.\n@@ -141721,3 +148306,3 @@\n-** by selectExpander() but the type and collation information was omitted\n-** at that point because identifiers had not yet been resolved.  This\n-** routine is called after identifier resolution.\n+** by selectExpander() but the type and collation and affinity information\n+** was omitted at that point because identifiers had not yet been resolved.\n+** This routine is called after identifier resolution.\n@@ -141731,1 +148316,0 @@\n-  assert( p->selFlags & SF_Resolved );\n@@ -141735,0 +148319,2 @@\n+  testcase( (p->selFlags & SF_Resolved)==0 );\n+  assert( (p->selFlags & SF_Resolved) || IN_RENAME_OBJECT );\n@@ -141743,3 +148329,1 @@\n-        while( pSel->pPrior ) pSel = pSel->pPrior;\n-        sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel,\n-                                               SQLITE_AFF_NONE);\n+        sqlite3SubqueryColumnTypes(pParse, pTab, pSel, SQLITE_AFF_NONE);\n@@ -141800,0 +148384,178 @@\n+#if TREETRACE_ENABLED\n+\/*\n+** Display all information about an AggInfo object\n+*\/\n+static void printAggInfo(AggInfo *pAggInfo){\n+  int ii;\n+  for(ii=0; ii<pAggInfo->nColumn; ii++){\n+    struct AggInfo_col *pCol = &pAggInfo->aCol[ii];\n+    sqlite3DebugPrintf(\n+       \"agg-column[%d] pTab=%s iTable=%d iColumn=%d iMem=%d\"\n+       \" iSorterColumn=%d %s\\n\",\n+       ii, pCol->pTab ? pCol->pTab->zName : \"NULL\",\n+       pCol->iTable, pCol->iColumn, pAggInfo->iFirstReg+ii,\n+       pCol->iSorterColumn,\n+       ii>=pAggInfo->nAccumulator ? \"\" : \" Accumulator\");\n+    sqlite3TreeViewExpr(0, pAggInfo->aCol[ii].pCExpr, 0);\n+  }\n+  for(ii=0; ii<pAggInfo->nFunc; ii++){\n+    sqlite3DebugPrintf(\"agg-func[%d]: iMem=%d\\n\",\n+        ii, pAggInfo->iFirstReg+pAggInfo->nColumn+ii);\n+    sqlite3TreeViewExpr(0, pAggInfo->aFunc[ii].pFExpr, 0);\n+  }\n+}\n+#endif \/* TREETRACE_ENABLED *\/\n+\n+\/*\n+** Analyze the arguments to aggregate functions.  Create new pAggInfo->aCol[]\n+** entries for columns that are arguments to aggregate functions but which\n+** are not otherwise used.\n+**\n+** The aCol[] entries in AggInfo prior to nAccumulator are columns that\n+** are referenced outside of aggregate functions.  These might be columns\n+** that are part of the GROUP by clause, for example.  Other database engines\n+** would throw an error if there is a column reference that is not in the\n+** GROUP BY clause and that is not part of an aggregate function argument.\n+** But SQLite allows this.\n+**\n+** The aCol[] entries beginning with the aCol[nAccumulator] and following\n+** are column references that are used exclusively as arguments to\n+** aggregate functions.  This routine is responsible for computing\n+** (or recomputing) those aCol[] entries.\n+*\/\n+static void analyzeAggFuncArgs(\n+  AggInfo *pAggInfo,\n+  NameContext *pNC\n+){\n+  int i;\n+  assert( pAggInfo!=0 );\n+  assert( pAggInfo->iFirstReg==0 );\n+  pNC->ncFlags |= NC_InAggFunc;\n+  for(i=0; i<pAggInfo->nFunc; i++){\n+    Expr *pExpr = pAggInfo->aFunc[i].pFExpr;\n+    assert( pExpr->op==TK_FUNCTION || pExpr->op==TK_AGG_FUNCTION );\n+    assert( ExprUseXList(pExpr) );\n+    sqlite3ExprAnalyzeAggList(pNC, pExpr->x.pList);\n+    if( pExpr->pLeft ){\n+      assert( pExpr->pLeft->op==TK_ORDER );\n+      assert( ExprUseXList(pExpr->pLeft) );\n+      sqlite3ExprAnalyzeAggList(pNC, pExpr->pLeft->x.pList);\n+    }\n+#ifndef SQLITE_OMIT_WINDOWFUNC\n+    assert( !IsWindowFunc(pExpr) );\n+    if( ExprHasProperty(pExpr, EP_WinFunc) ){\n+      sqlite3ExprAnalyzeAggregates(pNC, pExpr->y.pWin->pFilter);\n+    }\n+#endif\n+  }\n+  pNC->ncFlags &= ~NC_InAggFunc;\n+}\n+\n+\/*\n+** An index on expressions is being used in the inner loop of an\n+** aggregate query with a GROUP BY clause.  This routine attempts\n+** to adjust the AggInfo object to take advantage of index and to\n+** perhaps use the index as a covering index.\n+**\n+*\/\n+static void optimizeAggregateUseOfIndexedExpr(\n+  Parse *pParse,          \/* Parsing context *\/\n+  Select *pSelect,        \/* The SELECT statement being processed *\/\n+  AggInfo *pAggInfo,      \/* The aggregate info *\/\n+  NameContext *pNC        \/* Name context used to resolve agg-func args *\/\n+){\n+  assert( pAggInfo->iFirstReg==0 );\n+  assert( pSelect!=0 );\n+  assert( pSelect->pGroupBy!=0 );\n+  pAggInfo->nColumn = pAggInfo->nAccumulator;\n+  if( ALWAYS(pAggInfo->nSortingColumn>0) ){\n+    int mx = pSelect->pGroupBy->nExpr - 1;\n+    int j, k;\n+    for(j=0; j<pAggInfo->nColumn; j++){\n+      k = pAggInfo->aCol[j].iSorterColumn;\n+      if( k>mx ) mx = k;\n+    }\n+    pAggInfo->nSortingColumn = mx+1;\n+  }\n+  analyzeAggFuncArgs(pAggInfo, pNC);\n+#if TREETRACE_ENABLED\n+  if( sqlite3TreeTrace & 0x20 ){\n+    IndexedExpr *pIEpr;\n+    TREETRACE(0x20, pParse, pSelect,\n+        (\"AggInfo (possibly) adjusted for Indexed Exprs\\n\"));\n+    sqlite3TreeViewSelect(0, pSelect, 0);\n+    for(pIEpr=pParse->pIdxEpr; pIEpr; pIEpr=pIEpr->pIENext){\n+      printf(\"data-cursor=%d index={%d,%d}\\n\",\n+          pIEpr->iDataCur, pIEpr->iIdxCur, pIEpr->iIdxCol);\n+      sqlite3TreeViewExpr(0, pIEpr->pExpr, 0);\n+    }\n+    printAggInfo(pAggInfo);\n+  }\n+#else\n+  UNUSED_PARAMETER(pSelect);\n+  UNUSED_PARAMETER(pParse);\n+#endif\n+}\n+\n+\/*\n+** Walker callback for aggregateConvertIndexedExprRefToColumn().\n+*\/\n+static int aggregateIdxEprRefToColCallback(Walker *pWalker, Expr *pExpr){\n+  AggInfo *pAggInfo;\n+  struct AggInfo_col *pCol;\n+  UNUSED_PARAMETER(pWalker);\n+  if( pExpr->pAggInfo==0 ) return WRC_Continue;\n+  if( pExpr->op==TK_AGG_COLUMN ) return WRC_Continue;\n+  if( pExpr->op==TK_AGG_FUNCTION ) return WRC_Continue;\n+  if( pExpr->op==TK_IF_NULL_ROW ) return WRC_Continue;\n+  pAggInfo = pExpr->pAggInfo;\n+  if( NEVER(pExpr->iAgg>=pAggInfo->nColumn) ) return WRC_Continue;\n+  assert( pExpr->iAgg>=0 );\n+  pCol = &pAggInfo->aCol[pExpr->iAgg];\n+  pExpr->op = TK_AGG_COLUMN;\n+  pExpr->iTable = pCol->iTable;\n+  pExpr->iColumn = pCol->iColumn;\n+  ExprClearProperty(pExpr, EP_Skip|EP_Collate|EP_Unlikely);\n+  return WRC_Prune;\n+}\n+\n+\/*\n+** Convert every pAggInfo->aFunc[].pExpr such that any node within\n+** those expressions that has pAppInfo set is changed into a TK_AGG_COLUMN\n+** opcode.\n+*\/\n+static void aggregateConvertIndexedExprRefToColumn(AggInfo *pAggInfo){\n+  int i;\n+  Walker w;\n+  memset(&w, 0, sizeof(w));\n+  w.xExprCallback = aggregateIdxEprRefToColCallback;\n+  for(i=0; i<pAggInfo->nFunc; i++){\n+    sqlite3WalkExpr(&w, pAggInfo->aFunc[i].pFExpr);\n+  }\n+}\n+\n+\n+\/*\n+** Allocate a block of registers so that there is one register for each\n+** pAggInfo->aCol[] and pAggInfo->aFunc[] entry in pAggInfo.  The first\n+** register in this block is stored in pAggInfo->iFirstReg.\n+**\n+** This routine may only be called once for each AggInfo object.  Prior\n+** to calling this routine:\n+**\n+**     *  The aCol[] and aFunc[] arrays may be modified\n+**     *  The AggInfoColumnReg() and AggInfoFuncReg() macros may not be used\n+**\n+** After calling this routine:\n+**\n+**     *  The aCol[] and aFunc[] arrays are fixed\n+**     *  The AggInfoColumnReg() and AggInfoFuncReg() macros may be used\n+**\n+*\/\n+static void assignAggregateRegisters(Parse *pParse, AggInfo *pAggInfo){\n+  assert( pAggInfo!=0 );\n+  assert( pAggInfo->iFirstReg==0 );\n+  pAggInfo->iFirstReg = pParse->nMem + 1;\n+  pParse->nMem += pAggInfo->nColumn + pAggInfo->nFunc;\n+}\n+\n@@ -141813,0 +148575,1 @@\n+  assert( pAggInfo->iFirstReg>0 );\n@@ -141817,14 +148580,2 @@\n-#ifdef SQLITE_DEBUG\n-  \/* Verify that all AggInfo registers are within the range specified by\n-  ** AggInfo.mnReg..AggInfo.mxReg *\/\n-  assert( nReg==pAggInfo->mxReg-pAggInfo->mnReg+1 );\n-  for(i=0; i<pAggInfo->nColumn; i++){\n-    assert( pAggInfo->aCol[i].iMem>=pAggInfo->mnReg\n-         && pAggInfo->aCol[i].iMem<=pAggInfo->mxReg );\n-  }\n-  for(i=0; i<pAggInfo->nFunc; i++){\n-    assert( pAggInfo->aFunc[i].iMem>=pAggInfo->mnReg\n-         && pAggInfo->aFunc[i].iMem<=pAggInfo->mxReg );\n-  }\n-#endif\n-  sqlite3VdbeAddOp3(v, OP_Null, 0, pAggInfo->mnReg, pAggInfo->mxReg);\n+  sqlite3VdbeAddOp3(v, OP_Null, 0, pAggInfo->iFirstReg,\n+                    pAggInfo->iFirstReg+nReg-1);\n@@ -141847,0 +148598,30 @@\n+    if( pFunc->iOBTab>=0 ){\n+      ExprList *pOBList;\n+      KeyInfo *pKeyInfo;\n+      int nExtra = 0;\n+      assert( pFunc->pFExpr->pLeft!=0 );\n+      assert( pFunc->pFExpr->pLeft->op==TK_ORDER );\n+      assert( ExprUseXList(pFunc->pFExpr->pLeft) );\n+      assert( pFunc->pFunc!=0 );\n+      pOBList = pFunc->pFExpr->pLeft->x.pList;\n+      if( !pFunc->bOBUnique ){\n+        nExtra++;  \/* One extra column for the OP_Sequence *\/\n+      }\n+      if( pFunc->bOBPayload ){\n+        \/* extra columns for the function arguments *\/\n+        assert( ExprUseXList(pFunc->pFExpr) );\n+        nExtra += pFunc->pFExpr->x.pList->nExpr;\n+      }\n+      if( pFunc->bUseSubtype ){\n+        nExtra += pFunc->pFExpr->x.pList->nExpr;\n+      }\n+      pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pOBList, 0, nExtra);\n+      if( !pFunc->bOBUnique && pParse->nErr==0 ){\n+        pKeyInfo->nKeyField++;\n+      }\n+      sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n+            pFunc->iOBTab, pOBList->nExpr+nExtra, 0,\n+            (char*)pKeyInfo, P4_KEYINFO);\n+      ExplainQueryPlan((pParse, 0, \"USE TEMP B-TREE FOR %s(ORDER BY)\",\n+                          pFunc->pFunc->zName));\n+    }\n@@ -141862,1 +148643,46 @@\n-    sqlite3VdbeAddOp2(v, OP_AggFinal, pF->iMem, pList ? pList->nExpr : 0);\n+    if( pF->iOBTab>=0 ){\n+      \/* For an ORDER BY aggregate, calls to OP_AggStep were deferred.  Inputs\n+      ** were stored in emphermal table pF->iOBTab.  Here, we extract those\n+      ** inputs (in ORDER BY order) and make all calls to OP_AggStep\n+      ** before doing the OP_AggFinal call. *\/\n+      int iTop;        \/* Start of loop for extracting columns *\/\n+      int nArg;        \/* Number of columns to extract *\/\n+      int nKey;        \/* Key columns to be skipped *\/\n+      int regAgg;      \/* Extract into this array *\/\n+      int j;           \/* Loop counter *\/\n+\n+      assert( pF->pFunc!=0 );\n+      nArg = pList->nExpr;\n+      regAgg = sqlite3GetTempRange(pParse, nArg);\n+\n+      if( pF->bOBPayload==0 ){\n+        nKey = 0;\n+      }else{\n+        assert( pF->pFExpr->pLeft!=0 );\n+        assert( ExprUseXList(pF->pFExpr->pLeft) );\n+        assert( pF->pFExpr->pLeft->x.pList!=0 );\n+        nKey = pF->pFExpr->pLeft->x.pList->nExpr;\n+        if( ALWAYS(!pF->bOBUnique) ) nKey++;\n+      }\n+      iTop = sqlite3VdbeAddOp1(v, OP_Rewind, pF->iOBTab); VdbeCoverage(v);\n+      for(j=nArg-1; j>=0; j--){\n+        sqlite3VdbeAddOp3(v, OP_Column, pF->iOBTab, nKey+j, regAgg+j);\n+      }\n+      if( pF->bUseSubtype ){\n+        int regSubtype = sqlite3GetTempReg(pParse);\n+        int iBaseCol = nKey + nArg + (pF->bOBPayload==0 && pF->bOBUnique==0);\n+        for(j=nArg-1; j>=0; j--){\n+          sqlite3VdbeAddOp3(v, OP_Column, pF->iOBTab, iBaseCol+j, regSubtype);\n+          sqlite3VdbeAddOp2(v, OP_SetSubtype, regSubtype, regAgg+j);\n+        }\n+        sqlite3ReleaseTempReg(pParse, regSubtype);\n+      }\n+      sqlite3VdbeAddOp3(v, OP_AggStep, 0, regAgg, AggInfoFuncReg(pAggInfo,i));\n+      sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);\n+      sqlite3VdbeChangeP5(v, (u8)nArg);\n+      sqlite3VdbeAddOp2(v, OP_Next, pF->iOBTab, iTop+1); VdbeCoverage(v);\n+      sqlite3VdbeJumpHere(v, iTop);\n+      sqlite3ReleaseTempRange(pParse, regAgg, nArg);\n+    }\n+    sqlite3VdbeAddOp2(v, OP_AggFinal, AggInfoFuncReg(pAggInfo,i),\n+                      pList ? pList->nExpr : 0);\n@@ -141867,1 +148693,0 @@\n-\n@@ -141869,2 +148694,2 @@\n-** Update the accumulator memory cells for an aggregate based on\n-** the current cursor position.\n+** Generate code that will update the accumulator memory cells for an\n+** aggregate based on the current cursor position.\n@@ -141876,0 +148701,7 @@\n+**\n+** For an ORDER BY aggregate, the actual accumulator memory cell update\n+** is deferred until after all input rows have been received, so that they\n+** can be run in the requested order.  In that case, instead of invoking\n+** OP_AggStep to update the accumulator, just add the arguments that would\n+** have been passed into OP_AggStep into the sorting ephemeral table\n+** (along with the appropriate sort key).\n@@ -141890,0 +148722,2 @@\n+  assert( pAggInfo->iFirstReg>0 );\n+  if( pParse->nErr ) return;\n@@ -141895,0 +148729,2 @@\n+    int regAggSz = 0;\n+    int regDistinct = 0;\n@@ -141898,0 +148734,1 @@\n+    assert( pF->pFunc!=0 );\n@@ -141921,1 +148758,46 @@\n-    if( pList ){\n+    if( pF->iOBTab>=0 ){\n+      \/* Instead of invoking AggStep, we must push the arguments that would\n+      ** have been passed to AggStep onto the sorting table. *\/\n+      int jj;                \/* Registered used so far in building the record *\/\n+      ExprList *pOBList;     \/* The ORDER BY clause *\/\n+      assert( pList!=0 );\n+      nArg = pList->nExpr;\n+      assert( nArg>0 );\n+      assert( pF->pFExpr->pLeft!=0 );\n+      assert( pF->pFExpr->pLeft->op==TK_ORDER );\n+      assert( ExprUseXList(pF->pFExpr->pLeft) );\n+      pOBList = pF->pFExpr->pLeft->x.pList;\n+      assert( pOBList!=0 );\n+      assert( pOBList->nExpr>0 );\n+      regAggSz = pOBList->nExpr;\n+      if( !pF->bOBUnique ){\n+        regAggSz++;   \/* One register for OP_Sequence *\/\n+      }\n+      if( pF->bOBPayload ){\n+        regAggSz += nArg;\n+      }\n+      if( pF->bUseSubtype ){\n+        regAggSz += nArg;\n+      }\n+      regAggSz++;  \/* One extra register to hold result of MakeRecord *\/\n+      regAgg = sqlite3GetTempRange(pParse, regAggSz);\n+      regDistinct = regAgg;\n+      sqlite3ExprCodeExprList(pParse, pOBList, regAgg, 0, SQLITE_ECEL_DUP);\n+      jj = pOBList->nExpr;\n+      if( !pF->bOBUnique ){\n+        sqlite3VdbeAddOp2(v, OP_Sequence, pF->iOBTab, regAgg+jj);\n+        jj++;\n+      }\n+      if( pF->bOBPayload ){\n+        regDistinct = regAgg+jj;\n+        sqlite3ExprCodeExprList(pParse, pList, regDistinct, 0, SQLITE_ECEL_DUP);\n+        jj += nArg;\n+      }\n+      if( pF->bUseSubtype ){\n+        int kk;\n+        int regBase = pF->bOBPayload ? regDistinct : regAgg;\n+        for(kk=0; kk<nArg; kk++, jj++){\n+          sqlite3VdbeAddOp2(v, OP_GetSubtype, regBase+kk, regAgg+jj);\n+        }\n+      }\n+    }else if( pList ){\n@@ -141924,0 +148806,1 @@\n+      regDistinct = regAgg;\n@@ -141934,12 +148817,25 @@\n-          pF->iDistinct, addrNext, pList, regAgg);\n-    }\n-    if( pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){\n-      CollSeq *pColl = 0;\n-      struct ExprList_item *pItem;\n-      int j;\n-      assert( pList!=0 );  \/* pList!=0 if pF->pFunc has NEEDCOLL *\/\n-      for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++){\n-        pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);\n-      }\n-      if( !pColl ){\n-        pColl = pParse->db->pDfltColl;\n+          pF->iDistinct, addrNext, pList, regDistinct);\n+    }\n+    if( pF->iOBTab>=0 ){\n+      \/* Insert a new record into the ORDER BY table *\/\n+      sqlite3VdbeAddOp3(v, OP_MakeRecord, regAgg, regAggSz-1,\n+                        regAgg+regAggSz-1);\n+      sqlite3VdbeAddOp4Int(v, OP_IdxInsert, pF->iOBTab, regAgg+regAggSz-1,\n+                           regAgg, regAggSz-1);\n+      sqlite3ReleaseTempRange(pParse, regAgg, regAggSz);\n+    }else{\n+      \/* Invoke the AggStep function *\/\n+      if( pF->pFunc->funcFlags & SQLITE_FUNC_NEEDCOLL ){\n+        CollSeq *pColl = 0;\n+        struct ExprList_item *pItem;\n+        int j;\n+        assert( pList!=0 );  \/* pList!=0 if pF->pFunc has NEEDCOLL *\/\n+        for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++){\n+          pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);\n+        }\n+        if( !pColl ){\n+          pColl = pParse->db->pDfltColl;\n+        }\n+        if( regHit==0 && pAggInfo->nAccumulator ) regHit = ++pParse->nMem;\n+        sqlite3VdbeAddOp4(v, OP_CollSeq, regHit, 0, 0,\n+                         (char *)pColl, P4_COLLSEQ);\n@@ -141947,2 +148843,4 @@\n-      if( regHit==0 && pAggInfo->nAccumulator ) regHit = ++pParse->nMem;\n-      sqlite3VdbeAddOp4(v, OP_CollSeq, regHit, 0, 0, (char *)pColl, P4_COLLSEQ);\n+      sqlite3VdbeAddOp3(v, OP_AggStep, 0, regAgg, AggInfoFuncReg(pAggInfo,i));\n+      sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);\n+      sqlite3VdbeChangeP5(v, (u8)nArg);\n+      sqlite3ReleaseTempRange(pParse, regAgg, nArg);\n@@ -141950,4 +148848,0 @@\n-    sqlite3VdbeAddOp3(v, OP_AggStep, 0, regAgg, pF->iMem);\n-    sqlite3VdbeAppendP4(v, pF->pFunc, P4_FUNCDEF);\n-    sqlite3VdbeChangeP5(v, (u8)nArg);\n-    sqlite3ReleaseTempRange(pParse, regAgg, nArg);\n@@ -141965,1 +148859,1 @@\n-    sqlite3ExprCode(pParse, pC->pCExpr, pC->iMem);\n+    sqlite3ExprCode(pParse, pC->pCExpr, AggInfoColumnReg(pAggInfo,i));\n@@ -142061,1 +148955,1 @@\n-    SELECTTRACE(0x100,pParse,p,(\"Move HAVING terms into WHERE:\\n\"));\n+    TREETRACE(0x100,pParse,p,(\"Move HAVING terms into WHERE:\\n\"));\n@@ -142068,3 +148962,6 @@\n-** Check to see if the pThis entry of pTabList is a self-join of a prior view.\n-** If it is, then return the SrcList_item for the prior view.  If it is not,\n-** then return 0.\n+** Check to see if the pThis entry of pTabList is a self-join of another view.\n+** Search FROM-clause entries in the range of iFirst..iEnd, including iFirst\n+** but stopping before iEnd.\n+**\n+** If pThis is a self-join, then return the SrcItem for the first other\n+** instance of that view found.  If pThis is not a self-join then return 0.\n@@ -142074,1 +148971,2 @@\n-  SrcItem *pThis               \/* Search for prior reference to this subquery *\/\n+  SrcItem *pThis,              \/* Search for prior reference to this subquery *\/\n+  int iFirst, int iEnd        \/* Range of FROM-clause entries to search. *\/\n@@ -142079,1 +148977,1 @@\n-  for(pItem = pTabList->a; pItem<pThis; pItem++){\n+  while( iFirst<iEnd ){\n@@ -142081,0 +148979,1 @@\n+    pItem = &pTabList->a[iFirst++];\n@@ -142107,1 +149006,2 @@\n-static void agginfoFree(sqlite3 *db, AggInfo *p){\n+static void agginfoFree(sqlite3 *db, void *pArg){\n+  AggInfo *p = (AggInfo*)pArg;\n@@ -142113,1 +149013,0 @@\n-#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION\n@@ -142141,0 +149040,1 @@\n+  if( p->pHaving ) return 0;\n@@ -142142,0 +149042,1 @@\n+  if( p->pOrderBy ) return 0;\n@@ -142149,0 +149050,1 @@\n+  if( ExprHasProperty(pExpr, EP_WinFunc) ) return 0;\/* Not a window function *\/\n@@ -142151,1 +149053,2 @@\n-  if( pSub->pPrior==0 ) return 0;                   \/* Must be a compound ry *\/\n+  if( pSub->pPrior==0 ) return 0;                   \/* Must be a compound *\/\n+  if( pSub->selFlags & SF_CopyCte ) return 0;       \/* Not a CTE *\/\n@@ -142157,1 +149060,2 @@\n-    pSub = pSub->pPrior;                              \/* Repeat over compound *\/\n+    assert( pSub->pHaving==0 );  \/* Due to the previous *\/\n+   pSub = pSub->pPrior;                              \/* Repeat over compound *\/\n@@ -142177,1 +149081,1 @@\n-    sqlite3ExprListDelete(db, pSub->pEList);\n+    sqlite3ParserAddCleanup(pParse, sqlite3ExprListDeleteGeneric, pSub->pEList);\n@@ -142193,2 +149097,2 @@\n-  if( sqlite3TreeTrace & 0x400 ){\n-    SELECTTRACE(0x400,pParse,p,(\"After count-of-view optimization:\\n\"));\n+  if( sqlite3TreeTrace & 0x200 ){\n+    TREETRACE(0x200,pParse,p,(\"After count-of-view optimization:\\n\"));\n@@ -142200,1 +149104,0 @@\n-#endif \/* SQLITE_COUNTOFVIEW_OPTIMIZATION *\/\n@@ -142225,0 +149128,62 @@\n+\/*\n+** Return TRUE (non-zero) if the i-th entry in the pTabList SrcList can\n+** be implemented as a co-routine.  The i-th entry is guaranteed to be\n+** a subquery.\n+**\n+** The subquery is implemented as a co-routine if all of the following are\n+** true:\n+**\n+**    (1)  The subquery will likely be implemented in the outer loop of\n+**         the query.  This will be the case if any one of the following\n+**         conditions hold:\n+**         (a)  The subquery is the only term in the FROM clause\n+**         (b)  The subquery is the left-most term and a CROSS JOIN or similar\n+**              requires it to be the outer loop\n+**         (c)  All of the following are true:\n+**                (i) The subquery is the left-most subquery in the FROM clause\n+**               (ii) There is nothing that would prevent the subquery from\n+**                    being used as the outer loop if the sqlite3WhereBegin()\n+**                    routine nominates it to that position.\n+**              (iii) The query is not a UPDATE ... FROM\n+**    (2)  The subquery is not a CTE that should be materialized because\n+**         (a) the AS MATERIALIZED keyword is used, or\n+**         (b) the CTE is used multiple times and does not have the\n+**             NOT MATERIALIZED keyword\n+**    (3)  The subquery is not part of a left operand for a RIGHT JOIN\n+**    (4)  The SQLITE_Coroutine optimization disable flag is not set\n+**    (5)  The subquery is not self-joined\n+*\/\n+static int fromClauseTermCanBeCoroutine(\n+  Parse *pParse,          \/* Parsing context *\/\n+  SrcList *pTabList,      \/* FROM clause *\/\n+  int i,                  \/* Which term of the FROM clause holds the subquery *\/\n+  int selFlags            \/* Flags on the SELECT statement *\/\n+){\n+  SrcItem *pItem = &pTabList->a[i];\n+  if( pItem->fg.isCte ){\n+    const CteUse *pCteUse = pItem->u2.pCteUse;\n+    if( pCteUse->eM10d==M10d_Yes ) return 0;                          \/* (2a) *\/\n+    if( pCteUse->nUse>=2 && pCteUse->eM10d!=M10d_No ) return 0;       \/* (2b) *\/\n+  }\n+  if( pTabList->a[0].fg.jointype & JT_LTORJ ) return 0;               \/* (3)  *\/\n+  if( OptimizationDisabled(pParse->db, SQLITE_Coroutines) ) return 0; \/* (4)  *\/\n+  if( isSelfJoinView(pTabList, pItem, i+1, pTabList->nSrc)!=0 ){\n+    return 0;                                                          \/* (5) *\/\n+  }\n+  if( i==0 ){\n+    if( pTabList->nSrc==1 ) return 1;                             \/* (1a) *\/\n+    if( pTabList->a[1].fg.jointype & JT_CROSS ) return 1;         \/* (1b) *\/\n+    if( selFlags & SF_UpdateFrom )              return 0;         \/* (1c-iii) *\/\n+    return 1;\n+  }\n+  if( selFlags & SF_UpdateFrom ) return 0;                        \/* (1c-iii) *\/\n+  while( 1 \/*exit-by-break*\/ ){\n+    if( pItem->fg.jointype & (JT_OUTER|JT_CROSS)  ) return 0;     \/* (1c-ii) *\/\n+    if( i==0 ) break;\n+    i--;\n+    pItem--;\n+    if( pItem->pSelect!=0 ) return 0;                             \/* (1c-i) *\/\n+  }\n+  return 1;\n+}\n+\n@@ -142270,2 +149235,2 @@\n-  SELECTTRACE(1,pParse,p, (\"begin processing:\\n\", pParse->addrExplain));\n-  if( sqlite3TreeTrace & 0x10100 ){\n+  TREETRACE(0x1,pParse,p, (\"begin processing:\\n\", pParse->addrExplain));\n+  if( sqlite3TreeTrace & 0x10000 ){\n@@ -142291,2 +149256,2 @@\n-      SELECTTRACE(1,pParse,p, (\"dropping superfluous ORDER BY:\\n\"));\n-      if( sqlite3TreeTrace & 0x100 ){\n+      TREETRACE(0x800,pParse,p, (\"dropping superfluous ORDER BY:\\n\"));\n+      if( sqlite3TreeTrace & 0x800 ){\n@@ -142296,3 +149261,2 @@\n-      sqlite3ParserAddCleanup(pParse,\n-        (void(*)(sqlite3*,void*))sqlite3ExprListDelete,\n-        p->pOrderBy);\n+      sqlite3ParserAddCleanup(pParse, sqlite3ExprListDeleteGeneric,\n+                              p->pOrderBy);\n@@ -142312,2 +149276,2 @@\n-  if( sqlite3TreeTrace & 0x104 ){\n-    SELECTTRACE(0x104,pParse,p, (\"after name resolution:\\n\"));\n+  if( sqlite3TreeTrace & 0x10 ){\n+    TREETRACE(0x10,pParse,p, (\"after name resolution:\\n\"));\n@@ -142354,2 +149318,2 @@\n-  if( p->pWin && (sqlite3TreeTrace & 0x108)!=0 ){\n-    SELECTTRACE(0x104,pParse,p, (\"after window rewrite:\\n\"));\n+  if( p->pWin && (sqlite3TreeTrace & 0x40)!=0 ){\n+    TREETRACE(0x40,pParse,p, (\"after window rewrite:\\n\"));\n@@ -142379,2 +149343,10 @@\n-    \/* Convert LEFT JOIN into JOIN if there are terms of the right table\n-    ** of the LEFT JOIN used in the WHERE clause.\n+    \/* Try to simplify joins:\n+    **\n+    **      LEFT JOIN  ->  JOIN\n+    **     RIGHT JOIN  ->  JOIN\n+    **      FULL JOIN  ->  RIGHT JOIN\n+    **\n+    ** If terms of the i-th table are used in the WHERE clause in such a\n+    ** way that the i-th table cannot be the NULL row of a join, then\n+    ** perform the appropriate simplification. This is called\n+    ** \"OUTER JOIN strength reduction\" in the SQLite documentation.\n@@ -142382,2 +149354,3 @@\n-    if( (pItem->fg.jointype & (JT_LEFT|JT_RIGHT))==JT_LEFT\n-     && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor)\n+    if( (pItem->fg.jointype & (JT_LEFT|JT_LTORJ))!=0\n+     && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor,\n+                                     pItem->fg.jointype & JT_LTORJ)\n@@ -142386,6 +149359,33 @@\n-      SELECTTRACE(0x100,pParse,p,\n-                (\"LEFT-JOIN simplifies to JOIN on term %d\\n\",i));\n-      pItem->fg.jointype &= ~(JT_LEFT|JT_OUTER);\n-      assert( pItem->iCursor>=0 );\n-      unsetJoinExpr(p->pWhere, pItem->iCursor,\n-                    pTabList->a[0].fg.jointype & JT_LTORJ);\n+      if( pItem->fg.jointype & JT_LEFT ){\n+        if( pItem->fg.jointype & JT_RIGHT ){\n+          TREETRACE(0x1000,pParse,p,\n+                    (\"FULL-JOIN simplifies to RIGHT-JOIN on term %d\\n\",i));\n+          pItem->fg.jointype &= ~JT_LEFT;\n+        }else{\n+          TREETRACE(0x1000,pParse,p,\n+                    (\"LEFT-JOIN simplifies to JOIN on term %d\\n\",i));\n+          pItem->fg.jointype &= ~(JT_LEFT|JT_OUTER);\n+          unsetJoinExpr(p->pWhere, pItem->iCursor, 0);\n+        }\n+      }\n+      if( pItem->fg.jointype & JT_LTORJ ){\n+        for(j=i+1; j<pTabList->nSrc; j++){\n+          SrcItem *pI2 = &pTabList->a[j];\n+          if( pI2->fg.jointype & JT_RIGHT ){\n+            if( pI2->fg.jointype & JT_LEFT ){\n+              TREETRACE(0x1000,pParse,p,\n+                        (\"FULL-JOIN simplifies to LEFT-JOIN on term %d\\n\",j));\n+              pI2->fg.jointype &= ~JT_RIGHT;\n+            }else{\n+              TREETRACE(0x1000,pParse,p,\n+                        (\"RIGHT-JOIN simplifies to JOIN on term %d\\n\",j));\n+              pI2->fg.jointype &= ~(JT_RIGHT|JT_OUTER);\n+              unsetJoinExpr(p->pWhere, pI2->iCursor, 1);\n+            }\n+          }\n+        }\n+        for(j=pTabList->nSrc-1; j>=0; j--){\n+          pTabList->a[j].fg.jointype &= ~JT_LTORJ;\n+          if( pTabList->a[j].fg.jointype & JT_RIGHT ) break;\n+        }\n+      }\n@@ -142394,1 +149394,1 @@\n-    \/* No futher action if this term of the FROM clause is no a subquery *\/\n+    \/* No further action if this term of the FROM clause is not a subquery *\/\n@@ -142405,0 +149405,8 @@\n+    \/* Do not attempt the usual optimizations (flattening and ORDER BY\n+    ** elimination) on a MATERIALIZED common table expression because\n+    ** a MATERIALIZED common table expression is an optimization fence.\n+    *\/\n+    if( pItem->fg.isCte && pItem->u2.pCteUse->eM10d==M10d_Yes ){\n+      continue;\n+    }\n+\n@@ -142434,0 +149442,2 @@\n+    **\n+    ** Also retain the ORDER BY if the OmitOrderBy optimization is disabled.\n@@ -142442,1 +149452,1 @@\n-      SELECTTRACE(0x100,pParse,p,\n+      TREETRACE(0x800,pParse,p,\n@@ -142444,3 +149454,2 @@\n-      sqlite3ParserAddCleanup(pParse,\n-         (void(*)(sqlite3*,void*))sqlite3ExprListDelete,\n-         pSub->pOrderBy);\n+      sqlite3ParserAddCleanup(pParse, sqlite3ExprListDeleteGeneric,\n+                              pSub->pOrderBy);\n@@ -142497,2 +149506,2 @@\n-    SELECTTRACE(0x1,pParse,p,(\"end compound-select processing\\n\"));\n-    if( (sqlite3TreeTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n+    TREETRACE(0x400,pParse,p,(\"end compound-select processing\\n\"));\n+    if( (sqlite3TreeTrace & 0x400)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n@@ -142518,2 +149527,2 @@\n-    if( sqlite3TreeTrace & 0x100 ){\n-      SELECTTRACE(0x100,pParse,p,(\"After constant propagation:\\n\"));\n+    if( sqlite3TreeTrace & 0x2000 ){\n+      TREETRACE(0x2000,pParse,p,(\"After constant propagation:\\n\"));\n@@ -142524,1 +149533,1 @@\n-    SELECTTRACE(0x100,pParse,p,(\"Constant propagation not helpful\\n\"));\n+    TREETRACE(0x2000,pParse,p,(\"Constant propagation not helpful\\n\"));\n@@ -142527,1 +149536,0 @@\n-#ifdef SQLITE_COUNTOFVIEW_OPTIMIZATION\n@@ -142532,1 +149540,0 @@\n-    pEList = p->pEList;\n@@ -142535,1 +149542,0 @@\n-#endif\n@@ -142594,1 +149600,1 @@\n-     && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem)\n+     && pushDownWhereTerms(pParse, pSub, p->pWhere, pTabList, i)\n@@ -142597,2 +149603,2 @@\n-      if( sqlite3TreeTrace & 0x100 ){\n-        SELECTTRACE(0x100,pParse,p,\n+      if( sqlite3TreeTrace & 0x4000 ){\n+        TREETRACE(0x4000,pParse,p,\n@@ -142605,1 +149611,17 @@\n-      SELECTTRACE(0x100,pParse,p,(\"Push-down not possible\\n\"));\n+      TREETRACE(0x4000,pParse,p,(\"Push-down not possible\\n\"));\n+    }\n+\n+    \/* Convert unused result columns of the subquery into simple NULL\n+    ** expressions, to avoid unneeded searching and computation.\n+    *\/\n+    if( OptimizationEnabled(db, SQLITE_NullUnusedCols)\n+     && disableUnusedSubqueryResultColumns(pItem)\n+    ){\n+#if TREETRACE_ENABLED\n+      if( sqlite3TreeTrace & 0x4000 ){\n+        TREETRACE(0x4000,pParse,p,\n+            (\"Change unused result columns to NULL for subquery %d:\\n\",\n+             pSub->selId));\n+        sqlite3TreeViewSelect(0, p, 0);\n+      }\n+#endif\n@@ -142612,8 +149634,0 @@\n-    **\n-    ** The subquery is implemented as a co-routine if all of the following are\n-    ** true:\n-    **\n-    **    (1)  the subquery is guaranteed to be the outer loop (so that\n-    **         it does not need to be computed more than once), and\n-    **    (2)  the subquery is not a CTE that should be materialized\n-    **    (3)  the subquery is not part of a left operand for a RIGHT JOIN\n@@ -142621,6 +149635,1 @@\n-    if( i==0\n-     && (pTabList->nSrc==1\n-            || (pTabList->a[1].fg.jointype&(JT_OUTER|JT_CROSS))!=0)  \/* (1) *\/\n-     && (pItem->fg.isCte==0 || pItem->u2.pCteUse->eM10d!=M10d_Yes)   \/* (2) *\/\n-     && (pTabList->a[0].fg.jointype & JT_LTORJ)==0                   \/* (3) *\/\n-    ){\n+    if( fromClauseTermCanBeCoroutine(pParse, pTabList, i, p->selFlags) ){\n@@ -142648,1 +149657,1 @@\n-      ** the make the pItem->iCursor be a copy of the ephemerial table that\n+      ** the make the pItem->iCursor be a copy of the ephemeral table that\n@@ -142657,1 +149666,1 @@\n-    }else if( (pPrior = isSelfJoinView(pTabList, pItem))!=0 ){\n+    }else if( (pPrior = isSelfJoinView(pTabList, pItem, 0, i))!=0 ){\n@@ -142671,0 +149680,3 @@\n+#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n+      int addrExplain;\n+#endif\n@@ -142686,1 +149698,2 @@\n-      ExplainQueryPlan((pParse, 1, \"MATERIALIZE %!S\", pItem));\n+\n+      ExplainQueryPlan2(addrExplain, (pParse, 1, \"MATERIALIZE %!S\", pItem));\n@@ -142692,0 +149705,1 @@\n+      sqlite3VdbeScanStatusRange(v, addrExplain, addrExplain, -1);\n@@ -142717,2 +149731,2 @@\n-  if( sqlite3TreeTrace & 0x400 ){\n-    SELECTTRACE(0x400,pParse,p,(\"After all FROM-clause analysis:\\n\"));\n+  if( sqlite3TreeTrace & 0x8000 ){\n+    TREETRACE(0x8000,pParse,p,(\"After all FROM-clause analysis:\\n\"));\n@@ -142754,2 +149768,2 @@\n-    if( sqlite3TreeTrace & 0x400 ){\n-      SELECTTRACE(0x400,pParse,p,(\"Transform DISTINCT into GROUP BY:\\n\"));\n+    if( sqlite3TreeTrace & 0x20000 ){\n+      TREETRACE(0x20000,pParse,p,(\"Transform DISTINCT into GROUP BY:\\n\"));\n@@ -142807,1 +149821,1 @@\n-  computeLimitRegisters(pParse, p, iEnd);\n+  if( p->pLimit ) computeLimitRegisters(pParse, p, iEnd);\n@@ -142841,1 +149855,1 @@\n-    SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n+    TREETRACE(0x2,pParse,p,(\"WhereBegin\\n\"));\n@@ -142858,1 +149872,1 @@\n-    SELECTTRACE(1,pParse,p,(\"WhereBegin returns\\n\"));\n+    TREETRACE(0x2,pParse,p,(\"WhereBegin returns\\n\"));\n@@ -142897,1 +149911,1 @@\n-      SELECTTRACE(1,pParse,p,(\"WhereEnd\\n\"));\n+      TREETRACE(0x2,pParse,p,(\"WhereEnd\\n\"));\n@@ -142970,2 +149984,1 @@\n-      sqlite3ParserAddCleanup(pParse,\n-          (void(*)(sqlite3*,void*))agginfoFree, pAggInfo);\n+      sqlite3ParserAddCleanup(pParse, agginfoFree, pAggInfo);\n@@ -142978,0 +149991,3 @@\n+#ifdef SQLITE_DEBUG\n+    pAggInfo->pSelect = p;\n+#endif\n@@ -142983,1 +149999,0 @@\n-    pAggInfo->mnReg = pParse->nMem+1;\n@@ -143004,14 +150019,1 @@\n-    for(i=0; i<pAggInfo->nFunc; i++){\n-      Expr *pExpr = pAggInfo->aFunc[i].pFExpr;\n-      assert( ExprUseXList(pExpr) );\n-      sNC.ncFlags |= NC_InAggFunc;\n-      sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);\n-#ifndef SQLITE_OMIT_WINDOWFUNC\n-      assert( !IsWindowFunc(pExpr) );\n-      if( ExprHasProperty(pExpr, EP_WinFunc) ){\n-        sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);\n-      }\n-#endif\n-      sNC.ncFlags &= ~NC_InAggFunc;\n-    }\n-    pAggInfo->mxReg = pParse->nMem;\n+    analyzeAggFuncArgs(pAggInfo, &sNC);\n@@ -143020,3 +150022,2 @@\n-    if( sqlite3TreeTrace & 0x400 ){\n-      int ii;\n-      SELECTTRACE(0x400,pParse,p,(\"After aggregate analysis %p:\\n\", pAggInfo));\n+    if( sqlite3TreeTrace & 0x20 ){\n+      TREETRACE(0x20,pParse,p,(\"After aggregate analysis %p:\\n\", pAggInfo));\n@@ -143028,10 +150029,1 @@\n-      for(ii=0; ii<pAggInfo->nColumn; ii++){\n-        sqlite3DebugPrintf(\"agg-column[%d] iMem=%d\\n\",\n-            ii, pAggInfo->aCol[ii].iMem);\n-        sqlite3TreeViewExpr(0, pAggInfo->aCol[ii].pCExpr, 0);\n-      }\n-      for(ii=0; ii<pAggInfo->nFunc; ii++){\n-        sqlite3DebugPrintf(\"agg-func[%d]: iMem=%d\\n\",\n-            ii, pAggInfo->aFunc[ii].iMem);\n-        sqlite3TreeViewExpr(0, pAggInfo->aFunc[ii].pFExpr, 0);\n-      }\n+      printAggInfo(pAggInfo);\n@@ -143047,1 +150039,1 @@\n-      int addr1;          \/* A-vs-B comparision jump *\/\n+      int addr1;          \/* A-vs-B comparison jump *\/\n@@ -143106,1 +150098,1 @@\n-      SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n+      TREETRACE(0x2,pParse,p,(\"WhereBegin\\n\"));\n@@ -143108,1 +150100,1 @@\n-          0, (sDistinct.isTnct==2 ? WHERE_DISTINCTBY : WHERE_GROUPBY)\n+          p, (sDistinct.isTnct==2 ? WHERE_DISTINCTBY : WHERE_GROUPBY)\n@@ -143115,0 +150107,4 @@\n+      if( pParse->pIdxEpr ){\n+        optimizeAggregateUseOfIndexedExpr(pParse, p, pAggInfo, &sNC);\n+      }\n+      assignAggregateRegisters(pParse, pAggInfo);\n@@ -143116,1 +150112,1 @@\n-      SELECTTRACE(1,pParse,p,(\"WhereBegin returns\\n\"));\n+      TREETRACE(0x2,pParse,p,(\"WhereBegin returns\\n\"));\n@@ -143134,1 +150130,4 @@\n-        explainTempTable(pParse,\n+#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n+        int addrExp;              \/* Address of OP_Explain instruction *\/\n+#endif\n+        ExplainQueryPlan2(addrExp, (pParse, 0, \"USE TEMP B-TREE FOR %s\",\n@@ -143136,1 +150135,2 @@\n-                    \"DISTINCT\" : \"GROUP BY\");\n+                    \"DISTINCT\" : \"GROUP BY\"\n+        ));\n@@ -143151,0 +150151,1 @@\n+        pAggInfo->directMode = 1;\n@@ -143154,3 +150155,1 @@\n-            int r1 = j + regBase;\n-            sqlite3ExprCodeGetColumnOfTable(v,\n-                               pCol->pTab, pCol->iTable, pCol->iColumn, r1);\n+            sqlite3ExprCode(pParse, pCol->pCExpr, j + regBase);\n@@ -143160,0 +150159,1 @@\n+        pAggInfo->directMode = 0;\n@@ -143161,0 +150161,1 @@\n+        sqlite3VdbeScanStatusCounters(v, addrExp, 0, sqlite3VdbeCurrentAddr(v));\n@@ -143163,0 +150164,1 @@\n+        sqlite3VdbeScanStatusRange(v, addrExp, sqlite3VdbeCurrentAddr(v)-2, -1);\n@@ -143165,1 +150167,1 @@\n-        SELECTTRACE(1,pParse,p,(\"WhereEnd\\n\"));\n+        TREETRACE(0x2,pParse,p,(\"WhereEnd\\n\"));\n@@ -143169,0 +150171,1 @@\n+        sqlite3VdbeScanStatusCounters(v, addrExp, sqlite3VdbeCurrentAddr(v), 0);\n@@ -143173,0 +150176,19 @@\n+        sqlite3VdbeScanStatusRange(v, addrExp, -1, sortPTab);\n+        sqlite3VdbeScanStatusRange(v, addrExp, -1, pAggInfo->sortingIdx);\n+      }\n+\n+      \/* If there are entries in pAgggInfo->aFunc[] that contain subexpressions\n+      ** that are indexed (and that were previously identified and tagged\n+      ** in optimizeAggregateUseOfIndexedExpr()) then those subexpressions\n+      ** must now be converted into a TK_AGG_COLUMN node so that the value\n+      ** is correctly pulled from the index rather than being recomputed. *\/\n+      if( pParse->pIdxEpr ){\n+        aggregateConvertIndexedExprRefToColumn(pAggInfo);\n+#if TREETRACE_ENABLED\n+        if( sqlite3TreeTrace & 0x20 ){\n+          TREETRACE(0x20, pParse, p,\n+             (\"AggInfo function expressions converted to reference index\\n\"));\n+          sqlite3TreeViewSelect(0, p, 0);\n+          printAggInfo(pAggInfo);\n+        }\n+#endif\n@@ -143243,1 +150265,1 @@\n-        SELECTTRACE(1,pParse,p,(\"WhereEnd\\n\"));\n+        TREETRACE(0x2,pParse,p,(\"WhereEnd\\n\"));\n@@ -143353,1 +150375,2 @@\n-        sqlite3VdbeAddOp2(v, OP_Count, iCsr, pAggInfo->aFunc[0].iMem);\n+        assignAggregateRegisters(pParse, pAggInfo);\n+        sqlite3VdbeAddOp2(v, OP_Count, iCsr, AggInfoFuncReg(pAggInfo,0));\n@@ -143389,0 +150412,1 @@\n+        assignAggregateRegisters(pParse, pAggInfo);\n@@ -143405,1 +150429,1 @@\n-        SELECTTRACE(1,pParse,p,(\"WhereBegin\\n\"));\n+        TREETRACE(0x2,pParse,p,(\"WhereBegin\\n\"));\n@@ -143407,1 +150431,1 @@\n-                                   pDistinct, 0, minMaxFlag|distFlag, 0);\n+                                   pDistinct, p, minMaxFlag|distFlag, 0);\n@@ -143411,1 +150435,1 @@\n-        SELECTTRACE(1,pParse,p,(\"WhereBegin returns\\n\"));\n+        TREETRACE(0x2,pParse,p,(\"WhereBegin returns\\n\"));\n@@ -143425,1 +150449,1 @@\n-        SELECTTRACE(1,pParse,p,(\"WhereEnd\\n\"));\n+        TREETRACE(0x2,pParse,p,(\"WhereEnd\\n\"));\n@@ -143447,2 +150471,0 @@\n-    explainTempTable(pParse,\n-                     sSort.nOBSat>0 ? \"RIGHT PART OF ORDER BY\":\"ORDER BY\");\n@@ -143472,1 +150494,1 @@\n-      assert( pExpr!=0 );\n+      if( pExpr==0 ) continue;\n@@ -143486,2 +150508,2 @@\n-  SELECTTRACE(0x1,pParse,p,(\"end processing\\n\"));\n-  if( (sqlite3TreeTrace & 0x2000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n+  TREETRACE(0x1,pParse,p,(\"end processing\\n\"));\n+  if( (sqlite3TreeTrace & 0x40000)!=0 && ExplainQueryPlanParent(pParse)==0 ){\n@@ -143761,1 +150783,1 @@\n-     && pTrig->pTabSchema!=pTmpSchema\n+     && (pTrig->pTabSchema!=pTmpSchema || pTrig->bReturning)\n@@ -143883,0 +150905,4 @@\n+  if( (pTab->tabFlags & TF_Shadow)!=0 && sqlite3ReadOnlyShadowTables(db) ){\n+    sqlite3ErrorMsg(pParse, \"cannot create triggers on shadow tables\");\n+    goto trigger_orphan_error;\n+  }\n@@ -143902,0 +150928,1 @@\n+        VVA_ONLY( pParse->ifNotExists = 1; )\n@@ -144665,1 +151692,5 @@\n-  assert( pParse->bReturning );\n+  if( !pParse->bReturning ){\n+    \/* This RETURNING trigger must be for a different statement as\n+    ** this statement lacks a RETURNING clause. *\/\n+    return;\n+  }\n@@ -144668,1 +151699,4 @@\n-  assert( pTrigger == &(pReturning->retTrig) );\n+  if( pTrigger != &(pReturning->retTrig) ){\n+    \/* This RETURNING trigger is for a different statement *\/\n+    return;\n+  }\n@@ -144683,1 +151717,1 @@\n-  if( !db->mallocFailed ){\n+  if( pParse->nErr==0 ){\n@@ -144891,1 +151925,1 @@\n-  sSubParse.disableVtab = pParse->disableVtab;\n+  sSubParse.prepFlags = pParse->prepFlags;\n@@ -145152,0 +152186,3 @@\n+  if( IsView(pTab) ){\n+    return 0xffffffff;\n+  }\n@@ -145237,0 +152274,1 @@\n+  Column *pCol;\n@@ -145238,1 +152276,3 @@\n-  if( !IsView(pTab) ){\n+  assert( pTab->nCol>i );\n+  pCol = &pTab->aCol[i];\n+  if( pCol->iDflt ){\n@@ -145241,1 +152281,1 @@\n-    Column *pCol = &pTab->aCol[i];\n+    assert( !IsView(pTab) );\n@@ -145252,1 +152292,1 @@\n-  if( pTab->aCol[i].affinity==SQLITE_AFF_REAL && !IsVirtual(pTab) ){\n+  if( pCol->affinity==SQLITE_AFF_REAL && !IsVirtual(pTab) ){\n@@ -145399,1 +152439,1 @@\n-    pSrc->a[0].fg.notCte = 1;\n+    assert( pSrc->a[0].fg.notCte );\n@@ -145438,1 +152478,2 @@\n-      pSrc, pWhere2, pGrp, 0, pOrderBy2, SF_UFSrcCheck|SF_IncludeHidden, pLimit2\n+      pSrc, pWhere2, pGrp, 0, pOrderBy2,\n+      SF_UFSrcCheck|SF_IncludeHidden|SF_UpdateFrom, pLimit2\n@@ -145582,1 +152623,1 @@\n-  if( sqlite3IsReadOnly(pParse, pTab, tmask) ){\n+  if( sqlite3IsReadOnly(pParse, pTab, pTrigger) ){\n@@ -145901,4 +152942,8 @@\n-      ** there are any triggers or foreign keys to process, or rows may\n-      ** be deleted as a result of REPLACE conflict handling. Any of these\n-      ** things might disturb a cursor being used to scan through the table\n-      ** or index, causing a single-pass approach to malfunction.  *\/\n+      ** there is anything that might disrupt the cursor being used to do\n+      ** the UPDATE:\n+      **   (1) This is a nested UPDATE\n+      **   (2) There are triggers\n+      **   (3) There are FOREIGN KEY constraints\n+      **   (4) There are REPLACE conflict handlers\n+      **   (5) There are subqueries in the WHERE clause\n+      *\/\n@@ -145906,1 +152951,7 @@\n-      if( !pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace ){\n+      if( !pParse->nested\n+       && !pTrigger\n+       && !hasFK\n+       && !chngKey\n+       && !bReplace\n+       && (pWhere==0 || !ExprHasProperty(pWhere, EP_Subquery))\n+      ){\n@@ -145977,0 +153028,2 @@\n+      int iNotUsed1 = 0;\n+      int iNotUsed2 = 0;\n@@ -145988,1 +153041,1 @@\n-                                 aToOpen, 0, 0);\n+                                 aToOpen, &iNotUsed1, &iNotUsed2);\n@@ -146083,0 +153136,3 @@\n+#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n+      if( isView ) sqlite3VdbeAddOp2(v, OP_Null, 0, regOldRowid);\n+#endif\n@@ -146279,2 +153335,4 @@\n-  sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges,\n-      TRIGGER_AFTER, pTab, regOldRowid, onError, labelContinue);\n+  if( pTrigger ){\n+    sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges,\n+        TRIGGER_AFTER, pTab, regOldRowid, onError, labelContinue);\n+  }\n@@ -146375,1 +153433,1 @@\n-  int regRowid;                   \/* Register for ephem table rowid *\/\n+  int regRowid;                   \/* Register for ephemeral table rowid *\/\n@@ -146419,1 +153477,3 @@\n-        pList = sqlite3ExprListAppend(pParse, pList, exprRowColumn(pParse, i));\n+        Expr *pRowExpr = exprRowColumn(pParse, i);\n+        if( pRowExpr ) pRowExpr->op2 = OPFLAG_NOCHNG;\n+        pList = sqlite3ExprListAppend(pParse, pList, pRowExpr);\n@@ -146496,1 +153556,1 @@\n-    \/* Begin scannning through the ephemeral table. *\/\n+    \/* Begin scanning through the ephemeral table. *\/\n@@ -146616,1 +153676,2 @@\n-  Upsert *pUpsert    \/* The ON CONFLICT clauses *\/\n+  Upsert *pUpsert,   \/* The ON CONFLICT clauses *\/\n+  Upsert *pAll       \/* Complete list of all ON CONFLICT clauses *\/\n@@ -146692,0 +153753,1 @@\n+          assert( pIdx->bHasExpr );\n@@ -146703,1 +153765,1 @@\n-          if( sqlite3ExprCompare(pParse,pTarget->a[jj].pExpr,pExpr,iCursor)<2 ){\n+          if( sqlite3ExprCompare(0,pTarget->a[jj].pExpr,pExpr,iCursor)<2 ){\n@@ -146718,0 +153780,8 @@\n+      if( sqlite3UpsertOfIndex(pAll,pIdx)!=pUpsert ){\n+        \/* Really this should be an error.  The isDup ON CONFLICT clause will\n+        ** never fire.  But this problem was not discovered until three years\n+        ** after multi-CONFLICT upsert was added, and so we silently ignore\n+        ** the problem to prevent breaking applications that might actually\n+        ** have redundant ON CONFLICT clauses. *\/\n+        pUpsert->isDup = 1;\n+      }\n@@ -146744,3 +153814,7 @@\n-  if( pNext==0 ) return 1;\n-  if( pNext->pUpsertTarget==0 ) return 1;\n-  if( pNext->pUpsertIdx==0 ) return 1;\n+  while( 1 \/*exit-by-return*\/ ){\n+    if( pNext==0 ) return 1;\n+    if( pNext->pUpsertTarget==0 ) return 1;\n+    if( pNext->pUpsertIdx==0 ) return 1;\n+    if( !pNext->isDup ) return 0;\n+    pNext = pNext->pNextUpsert;\n+  }\n@@ -147005,0 +154079,1 @@\n+  u32 pgflags = PAGER_SYNCHRONOUS_OFF; \/* sync flags for output db *\/\n@@ -147051,1 +154126,1 @@\n-  ** An optimisation would be to use a non-journaled pager.\n+  ** An optimization would be to use a non-journaled pager.\n@@ -147076,0 +154151,5 @@\n+\n+    \/* For a VACUUM INTO, the pager-flags are set to the same values as\n+    ** they are for the database being vacuumed, except that PAGER_CACHESPILL\n+    ** is always set. *\/\n+    pgflags = db->aDb[iDb].safety_level | (db->flags & PAGER_FLAGS_MASK);\n@@ -147081,1 +154161,1 @@\n-  sqlite3BtreeSetPagerFlags(pTemp, PAGER_SYNCHRONOUS_OFF|PAGER_CACHESPILL);\n+  sqlite3BtreeSetPagerFlags(pTemp, pgflags|PAGER_CACHESPILL);\n@@ -147465,1 +154545,0 @@\n-    sqlite3VtabModuleUnref(pVTab->db, pVTab->pMod);\n@@ -147469,0 +154548,1 @@\n+    sqlite3VtabModuleUnref(pVTab->db, pVTab->pMod);\n@@ -147569,1 +154649,0 @@\n-    sqlite3ExpirePreparedStatements(db, 0);\n@@ -147594,1 +154673,2 @@\n-  if( !db || db->pnBytesFreed==0 ) vtabDisconnectAll(0, p);\n+  assert( db!=0 );\n+  if( db->pnBytesFreed==0 ) vtabDisconnectAll(0, p);\n@@ -147734,1 +154814,1 @@\n-    ** entry in the sqlite_schema table tht was created for this vtab\n+    ** entry in the sqlite_schema table that was created for this vtab\n@@ -147863,0 +154943,1 @@\n+  pTab->nTabRef++;\n@@ -147864,0 +154945,1 @@\n+  sqlite3DeleteTable(db, pTab);\n@@ -148072,1 +155154,1 @@\n-    sqlite3Error(db, SQLITE_MISUSE);\n+    sqlite3Error(db, SQLITE_MISUSE_BKPT);\n@@ -148353,0 +155435,2 @@\n+          u64 savedFlags = (db->flags & SQLITE_Defensive);\n+          db->flags &= ~(u64)SQLITE_Defensive;\n@@ -148354,0 +155438,1 @@\n+          db->flags |= savedFlags;\n@@ -148394,1 +155479,1 @@\n-  if( pTab==0 ) return pDef;\n+  if( NEVER(pTab==0) ) return pDef;\n@@ -148473,1 +155558,1 @@\n-** statement in order to come into existance.  Eponymous virtual table\n+** statement in order to come into existence.  Eponymous virtual table\n@@ -148582,0 +155667,4 @@\n+      case SQLITE_VTAB_USES_ALL_SCHEMAS: {\n+        p->pVTable->bAllSchemas = 1;\n+        break;\n+      }\n@@ -148660,1 +155749,1 @@\n-** automatically freed when its WInfo oject is destructed.\n+** automatically freed when its WInfo object is destructed.\n@@ -148721,1 +155810,1 @@\n-        int nPrefix;           \/* Number of prior entires in the key *\/\n+        int nPrefix;           \/* Number of prior entries in the key *\/\n@@ -148971,1 +156060,1 @@\n-  WhereTerm *a;            \/* Each a[] describes a term of the WHERE cluase *\/\n+  WhereTerm *a;            \/* Each a[] describes a term of the WHERE clause *\/\n@@ -149001,1 +156090,1 @@\n-** SrcList_item.iCursor and Expr.iTable fields.  For any given WHERE\n+** SrcItem.iCursor and Expr.iTable fields.  For any given WHERE\n@@ -149072,14 +156161,0 @@\n-\/*\n-** Each instance of this object records a change to a single node\n-** in an expression tree to cause that node to point to a column\n-** of an index rather than an expression or a virtual column.  All\n-** such transformations need to be undone at the end of WHERE clause\n-** processing.\n-*\/\n-typedef struct WhereExprMod WhereExprMod;\n-struct WhereExprMod {\n-  WhereExprMod *pNext;  \/* Next translation on a list of them all *\/\n-  Expr *pExpr;          \/* The Expr node that was transformed *\/\n-  Expr orig;            \/* Original value of the Expr node *\/\n-};\n-\n@@ -149101,0 +156176,1 @@\n+#if WHERETRACE_ENABLED\n@@ -149102,2 +156178,0 @@\n-#ifndef SQLITE_OMIT_VIRTUALTABLE\n-  Select *pLimit;           \/* Used to access LIMIT expr\/registers for vtabs *\/\n@@ -149105,0 +156179,1 @@\n+  Select *pSelect;          \/* The entire SELECT statement containing WHERE *\/\n@@ -149123,1 +156198,0 @@\n-  WhereExprMod *pExprMods;  \/* Expression modifications *\/\n@@ -149140,1 +156214,1 @@\n-SQLITE_PRIVATE void sqlite3WhereLoopPrint(WhereLoop *p, WhereClause *pWC);\n+SQLITE_PRIVATE void sqlite3WhereLoopPrint(const WhereLoop *p, const WhereClause *pWC);\n@@ -149271,0 +156345,2 @@\n+                      \/*   0x02000000  -- available for reuse *\/\n+#define WHERE_EXPRIDX      0x04000000  \/* Uses an index-on-expressions *\/\n@@ -149368,3 +156444,3 @@\n-** command, or if either SQLITE_DEBUG or SQLITE_ENABLE_STMT_SCANSTATUS was\n-** defined at compile-time. If it is not a no-op, a single OP_Explain opcode\n-** is added to the output to describe the table scan strategy in pLevel.\n+** command, or if stmt_scanstatus_v2() stats are enabled, or if SQLITE_DEBUG\n+** was defined at compile-time. If it is not a no-op, a single OP_Explain\n+** opcode is added to the output to describe the table scan strategy in pLevel.\n@@ -149382,2 +156458,2 @@\n-#if !defined(SQLITE_DEBUG) && !defined(SQLITE_ENABLE_STMT_SCANSTATUS)\n-  if( sqlite3ParseToplevel(pParse)->explain==2 )\n+#if !defined(SQLITE_DEBUG)\n+  if( sqlite3ParseToplevel(pParse)->explain==2 || IS_STMT_SCANSTATUS(pParse->db) )\n@@ -149527,0 +156603,2 @@\n+\n+  sqlite3VdbeScanStatus(v, sqlite3VdbeCurrentAddr(v)-1, 0, 0, 0, 0);\n@@ -149547,6 +156625,30 @@\n-  const char *zObj = 0;\n-  WhereLoop *pLoop = pLvl->pWLoop;\n-  if( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0  &&  pLoop->u.btree.pIndex!=0 ){\n-    zObj = pLoop->u.btree.pIndex->zName;\n-  }else{\n-    zObj = pSrclist->a[pLvl->iFrom].zName;\n+  if( IS_STMT_SCANSTATUS( sqlite3VdbeDb(v) ) ){\n+    const char *zObj = 0;\n+    WhereLoop *pLoop = pLvl->pWLoop;\n+    int wsFlags = pLoop->wsFlags;\n+    int viaCoroutine = 0;\n+\n+    if( (wsFlags & WHERE_VIRTUALTABLE)==0  &&  pLoop->u.btree.pIndex!=0 ){\n+      zObj = pLoop->u.btree.pIndex->zName;\n+    }else{\n+      zObj = pSrclist->a[pLvl->iFrom].zName;\n+      viaCoroutine = pSrclist->a[pLvl->iFrom].fg.viaCoroutine;\n+    }\n+    sqlite3VdbeScanStatus(\n+        v, addrExplain, pLvl->addrBody, pLvl->addrVisit, pLoop->nOut, zObj\n+    );\n+\n+    if( viaCoroutine==0 ){\n+      if( (wsFlags & (WHERE_MULTI_OR|WHERE_AUTO_INDEX))==0 ){\n+        sqlite3VdbeScanStatusRange(v, addrExplain, -1, pLvl->iTabCur);\n+      }\n+      if( wsFlags & WHERE_INDEXED ){\n+        sqlite3VdbeScanStatusRange(v, addrExplain, -1, pLvl->iIdxCur);\n+      }\n+    }else{\n+      int addr = pSrclist->a[pLvl->iFrom].addrFillSub;\n+      VdbeOp *pOp = sqlite3VdbeGetOp(v, addr-1);\n+      assert( sqlite3VdbeDb(v)->mallocFailed || pOp->opcode==OP_InitCoroutine );\n+      assert( sqlite3VdbeDb(v)->mallocFailed || pOp->p2>addr );\n+      sqlite3VdbeScanStatusRange(v, addrExplain, addr, pOp->p2-1);\n+    }\n@@ -149554,3 +156656,0 @@\n-  sqlite3VdbeScanStatus(\n-      v, addrExplain, pLvl->addrBody, pLvl->addrVisit, pLoop->nOut, zObj\n-  );\n@@ -149616,1 +156715,1 @@\n-    if( sqlite3WhereTrace & 0x20000 ){\n+    if( (sqlite3WhereTrace & 0x4001)==0x4001 ){\n@@ -149731,0 +156830,1 @@\n+  Select *pSelect;            \/* Pointer to the SELECT on the RHS *\/\n@@ -149734,50 +156834,56 @@\n-    ExprList *pOrigRhs;         \/* Original unmodified RHS *\/\n-    ExprList *pOrigLhs;         \/* Original unmodified LHS *\/\n-    ExprList *pRhs = 0;         \/* New RHS after modifications *\/\n-    ExprList *pLhs = 0;         \/* New LHS after mods *\/\n-    int i;                      \/* Loop counter *\/\n-    Select *pSelect;            \/* Pointer to the SELECT on the RHS *\/\n-\n-    assert( ExprUseXSelect(pNew) );\n-    pOrigRhs = pNew->x.pSelect->pEList;\n-    assert( pNew->pLeft!=0 );\n-    assert( ExprUseXList(pNew->pLeft) );\n-    pOrigLhs = pNew->pLeft->x.pList;\n-    for(i=iEq; i<pLoop->nLTerm; i++){\n-      if( pLoop->aLTerm[i]->pExpr==pX ){\n-        int iField;\n-        assert( (pLoop->aLTerm[i]->eOperator & (WO_OR|WO_AND))==0 );\n-        iField = pLoop->aLTerm[i]->u.x.iField - 1;\n-        if( pOrigRhs->a[iField].pExpr==0 ) continue; \/* Duplicate PK column *\/\n-        pRhs = sqlite3ExprListAppend(pParse, pRhs, pOrigRhs->a[iField].pExpr);\n-        pOrigRhs->a[iField].pExpr = 0;\n-        assert( pOrigLhs->a[iField].pExpr!=0 );\n-        pLhs = sqlite3ExprListAppend(pParse, pLhs, pOrigLhs->a[iField].pExpr);\n-        pOrigLhs->a[iField].pExpr = 0;\n-      }\n-    }\n-    sqlite3ExprListDelete(db, pOrigRhs);\n-    sqlite3ExprListDelete(db, pOrigLhs);\n-    pNew->pLeft->x.pList = pLhs;\n-    pNew->x.pSelect->pEList = pRhs;\n-    if( pLhs && pLhs->nExpr==1 ){\n-      \/* Take care here not to generate a TK_VECTOR containing only a\n-      ** single value. Since the parser never creates such a vector, some\n-      ** of the subroutines do not handle this case.  *\/\n-      Expr *p = pLhs->a[0].pExpr;\n-      pLhs->a[0].pExpr = 0;\n-      sqlite3ExprDelete(db, pNew->pLeft);\n-      pNew->pLeft = p;\n-    }\n-    pSelect = pNew->x.pSelect;\n-    if( pSelect->pOrderBy ){\n-      \/* If the SELECT statement has an ORDER BY clause, zero the\n-      ** iOrderByCol variables. These are set to non-zero when an\n-      ** ORDER BY term exactly matches one of the terms of the\n-      ** result-set. Since the result-set of the SELECT statement may\n-      ** have been modified or reordered, these variables are no longer\n-      ** set correctly.  Since setting them is just an optimization,\n-      ** it's easiest just to zero them here.  *\/\n-      ExprList *pOrderBy = pSelect->pOrderBy;\n-      for(i=0; i<pOrderBy->nExpr; i++){\n-        pOrderBy->a[i].u.x.iOrderByCol = 0;\n+    for(pSelect=pNew->x.pSelect; pSelect; pSelect=pSelect->pPrior){\n+      ExprList *pOrigRhs;         \/* Original unmodified RHS *\/\n+      ExprList *pOrigLhs = 0;     \/* Original unmodified LHS *\/\n+      ExprList *pRhs = 0;         \/* New RHS after modifications *\/\n+      ExprList *pLhs = 0;         \/* New LHS after mods *\/\n+      int i;                      \/* Loop counter *\/\n+\n+      assert( ExprUseXSelect(pNew) );\n+      pOrigRhs = pSelect->pEList;\n+      assert( pNew->pLeft!=0 );\n+      assert( ExprUseXList(pNew->pLeft) );\n+      if( pSelect==pNew->x.pSelect ){\n+        pOrigLhs = pNew->pLeft->x.pList;\n+      }\n+      for(i=iEq; i<pLoop->nLTerm; i++){\n+        if( pLoop->aLTerm[i]->pExpr==pX ){\n+          int iField;\n+          assert( (pLoop->aLTerm[i]->eOperator & (WO_OR|WO_AND))==0 );\n+          iField = pLoop->aLTerm[i]->u.x.iField - 1;\n+          if( pOrigRhs->a[iField].pExpr==0 ) continue; \/* Duplicate PK column *\/\n+          pRhs = sqlite3ExprListAppend(pParse, pRhs, pOrigRhs->a[iField].pExpr);\n+          pOrigRhs->a[iField].pExpr = 0;\n+          if( pOrigLhs ){\n+            assert( pOrigLhs->a[iField].pExpr!=0 );\n+            pLhs = sqlite3ExprListAppend(pParse,pLhs,pOrigLhs->a[iField].pExpr);\n+            pOrigLhs->a[iField].pExpr = 0;\n+          }\n+        }\n+      }\n+      sqlite3ExprListDelete(db, pOrigRhs);\n+      if( pOrigLhs ){\n+        sqlite3ExprListDelete(db, pOrigLhs);\n+        pNew->pLeft->x.pList = pLhs;\n+      }\n+      pSelect->pEList = pRhs;\n+      if( pLhs && pLhs->nExpr==1 ){\n+        \/* Take care here not to generate a TK_VECTOR containing only a\n+        ** single value. Since the parser never creates such a vector, some\n+        ** of the subroutines do not handle this case.  *\/\n+        Expr *p = pLhs->a[0].pExpr;\n+        pLhs->a[0].pExpr = 0;\n+        sqlite3ExprDelete(db, pNew->pLeft);\n+        pNew->pLeft = p;\n+      }\n+      if( pSelect->pOrderBy ){\n+        \/* If the SELECT statement has an ORDER BY clause, zero the\n+        ** iOrderByCol variables. These are set to non-zero when an\n+        ** ORDER BY term exactly matches one of the terms of the\n+        ** result-set. Since the result-set of the SELECT statement may\n+        ** have been modified or reordered, these variables are no longer\n+        ** set correctly.  Since setting them is just an optimization,\n+        ** it's easiest just to zero them here.  *\/\n+        ExprList *pOrderBy = pSelect->pOrderBy;\n+        for(i=0; i<pOrderBy->nExpr; i++){\n+          pOrderBy->a[i].u.x.iOrderByCol = 0;\n+        }\n@@ -149785,1 +156891,0 @@\n-    }\n@@ -149788,4 +156893,4 @@\n-    printf(\"For indexing, change the IN expr:\\n\");\n-    sqlite3TreeViewExpr(0, pX, 0);\n-    printf(\"Into:\\n\");\n-    sqlite3TreeViewExpr(0, pNew, 0);\n+      printf(\"For indexing, change the IN expr:\\n\");\n+      sqlite3TreeViewExpr(0, pX, 0);\n+      printf(\"Into:\\n\");\n+      sqlite3TreeViewExpr(0, pNew, 0);\n@@ -149793,0 +156898,1 @@\n+    }\n@@ -150045,1 +157151,1 @@\n-  nReg = pLoop->u.btree.nEq + nExtraReg;\n+  nReg = nEq + nExtraReg;\n@@ -150092,3 +157198,0 @@\n-  }\n-  for(j=nSkip; j<nEq; j++){\n-    pTerm = pLoop->aLTerm[j];\n@@ -150150,1 +157253,1 @@\n-    pOp = sqlite3VdbeGetOp(v, -1);\n+    pOp = sqlite3VdbeGetLastOp(v);\n@@ -150237,1 +157340,1 @@\n-** Also, if the node is a TK_COLUMN that does access the table idenified\n+** Also, if the node is a TK_COLUMN that does access the table identified\n@@ -150244,0 +157347,1 @@\n+  int reg;\n@@ -150247,2 +157351,2 @@\n-      int reg = ++pWalker->pParse->nMem;   \/* Register for column value *\/\n-      sqlite3ExprCode(pWalker->pParse, pExpr, reg);\n+      reg = ++pWalker->pParse->nMem;   \/* Register for column value *\/\n+      reg = sqlite3ExprCodeTarget(pWalker->pParse, pExpr, reg);\n@@ -150256,8 +157360,1 @@\n-  }else if( pExpr->op==TK_AGG_FUNCTION ){\n-    \/* An aggregate function in the WHERE clause of a query means this must\n-    ** be a correlated sub-query, and expression pExpr is an aggregate from\n-    ** the parent context. Do not walk the function arguments in this case.\n-    **\n-    ** todo: It should be possible to replace this node with a TK_REGISTER\n-    ** expression, as the result of the expression must be stored in a\n-    ** register at this point. The same holds for TK_AGG_COLUMN nodes. *\/\n+  }else if( pExpr->pAggInfo ){\n@@ -150265,0 +157362,7 @@\n+    reg = ++pWalker->pParse->nMem;   \/* Register for column value *\/\n+    reg = sqlite3ExprCodeTarget(pWalker->pParse, pExpr, reg);\n+    pExpr->op = TK_REGISTER;\n+    pExpr->iTable = reg;\n+  }else if( pExpr->op==TK_TRUEFALSE ){\n+    \/* Do not walk disabled expressions.  tag-20230504-1 *\/\n+    return WRC_Prune;\n@@ -150366,1 +157470,1 @@\n-    sqlite3WalkExpr(&sWalker, pExpr);\n+    if( pParse->nErr==0 ) sqlite3WalkExpr(&sWalker, pExpr);\n@@ -150474,137 +157578,0 @@\n-\/* An instance of the IdxExprTrans object carries information about a\n-** mapping from an expression on table columns into a column in an index\n-** down through the Walker.\n-*\/\n-typedef struct IdxExprTrans {\n-  Expr *pIdxExpr;    \/* The index expression *\/\n-  int iTabCur;       \/* The cursor of the corresponding table *\/\n-  int iIdxCur;       \/* The cursor for the index *\/\n-  int iIdxCol;       \/* The column for the index *\/\n-  int iTabCol;       \/* The column for the table *\/\n-  WhereInfo *pWInfo; \/* Complete WHERE clause information *\/\n-  sqlite3 *db;       \/* Database connection (for malloc()) *\/\n-} IdxExprTrans;\n-\n-\/*\n-** Preserve pExpr on the WhereETrans list of the WhereInfo.\n-*\/\n-static void preserveExpr(IdxExprTrans *pTrans, Expr *pExpr){\n-  WhereExprMod *pNew;\n-  pNew = sqlite3DbMallocRaw(pTrans->db, sizeof(*pNew));\n-  if( pNew==0 ) return;\n-  pNew->pNext = pTrans->pWInfo->pExprMods;\n-  pTrans->pWInfo->pExprMods = pNew;\n-  pNew->pExpr = pExpr;\n-  memcpy(&pNew->orig, pExpr, sizeof(*pExpr));\n-}\n-\n-\/* The walker node callback used to transform matching expressions into\n-** a reference to an index column for an index on an expression.\n-**\n-** If pExpr matches, then transform it into a reference to the index column\n-** that contains the value of pExpr.\n-*\/\n-static int whereIndexExprTransNode(Walker *p, Expr *pExpr){\n-  IdxExprTrans *pX = p->u.pIdxTrans;\n-  if( sqlite3ExprCompare(0, pExpr, pX->pIdxExpr, pX->iTabCur)==0 ){\n-    pExpr = sqlite3ExprSkipCollate(pExpr);\n-    preserveExpr(pX, pExpr);\n-    pExpr->affExpr = sqlite3ExprAffinity(pExpr);\n-    pExpr->op = TK_COLUMN;\n-    pExpr->iTable = pX->iIdxCur;\n-    pExpr->iColumn = pX->iIdxCol;\n-    testcase( ExprHasProperty(pExpr, EP_Unlikely) );\n-    ExprClearProperty(pExpr, EP_Skip|EP_Unlikely|EP_WinFunc|EP_Subrtn);\n-    pExpr->y.pTab = 0;\n-    return WRC_Prune;\n-  }else{\n-    return WRC_Continue;\n-  }\n-}\n-\n-#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n-\/* A walker node callback that translates a column reference to a table\n-** into a corresponding column reference of an index.\n-*\/\n-static int whereIndexExprTransColumn(Walker *p, Expr *pExpr){\n-  if( pExpr->op==TK_COLUMN ){\n-    IdxExprTrans *pX = p->u.pIdxTrans;\n-    if( pExpr->iTable==pX->iTabCur && pExpr->iColumn==pX->iTabCol ){\n-      assert( ExprUseYTab(pExpr) && pExpr->y.pTab!=0 );\n-      preserveExpr(pX, pExpr);\n-      pExpr->affExpr = sqlite3TableColumnAffinity(pExpr->y.pTab,pExpr->iColumn);\n-      pExpr->iTable = pX->iIdxCur;\n-      pExpr->iColumn = pX->iIdxCol;\n-      pExpr->y.pTab = 0;\n-    }\n-  }\n-  return WRC_Continue;\n-}\n-#endif \/* SQLITE_OMIT_GENERATED_COLUMNS *\/\n-\n-\/*\n-** For an indexes on expression X, locate every instance of expression X\n-** in pExpr and change that subexpression into a reference to the appropriate\n-** column of the index.\n-**\n-** 2019-10-24: Updated to also translate references to a VIRTUAL column in\n-** the table into references to the corresponding (stored) column of the\n-** index.\n-*\/\n-static void whereIndexExprTrans(\n-  Index *pIdx,      \/* The Index *\/\n-  int iTabCur,      \/* Cursor of the table that is being indexed *\/\n-  int iIdxCur,      \/* Cursor of the index itself *\/\n-  WhereInfo *pWInfo \/* Transform expressions in this WHERE clause *\/\n-){\n-  int iIdxCol;               \/* Column number of the index *\/\n-  ExprList *aColExpr;        \/* Expressions that are indexed *\/\n-  Table *pTab;\n-  Walker w;\n-  IdxExprTrans x;\n-  aColExpr = pIdx->aColExpr;\n-  if( aColExpr==0 && !pIdx->bHasVCol ){\n-    \/* The index does not reference any expressions or virtual columns\n-    ** so no translations are needed. *\/\n-    return;\n-  }\n-  pTab = pIdx->pTable;\n-  memset(&w, 0, sizeof(w));\n-  w.u.pIdxTrans = &x;\n-  x.iTabCur = iTabCur;\n-  x.iIdxCur = iIdxCur;\n-  x.pWInfo = pWInfo;\n-  x.db = pWInfo->pParse->db;\n-  for(iIdxCol=0; iIdxCol<pIdx->nColumn; iIdxCol++){\n-    i16 iRef = pIdx->aiColumn[iIdxCol];\n-    if( iRef==XN_EXPR ){\n-      assert( aColExpr!=0 && aColExpr->a[iIdxCol].pExpr!=0 );\n-      x.pIdxExpr = aColExpr->a[iIdxCol].pExpr;\n-      if( sqlite3ExprIsConstant(x.pIdxExpr) ) continue;\n-      w.xExprCallback = whereIndexExprTransNode;\n-#ifndef SQLITE_OMIT_GENERATED_COLUMNS\n-    }else if( iRef>=0\n-       && (pTab->aCol[iRef].colFlags & COLFLAG_VIRTUAL)!=0\n-       && ((pTab->aCol[iRef].colFlags & COLFLAG_HASCOLL)==0\n-           || sqlite3StrICmp(sqlite3ColumnColl(&pTab->aCol[iRef]),\n-                                               sqlite3StrBINARY)==0)\n-    ){\n-      \/* Check to see if there are direct references to generated columns\n-      ** that are contained in the index.  Pulling the generated column\n-      ** out of the index is an optimization only - the main table is always\n-      ** available if the index cannot be used.  To avoid unnecessary\n-      ** complication, omit this optimization if the collating sequence for\n-      ** the column is non-standard *\/\n-      x.iTabCol = iRef;\n-      w.xExprCallback = whereIndexExprTransColumn;\n-#endif \/* SQLITE_OMIT_GENERATED_COLUMNS *\/\n-    }else{\n-      continue;\n-    }\n-    x.iIdxCol = iIdxCol;\n-    sqlite3WalkExpr(&w, pWInfo->pWhere);\n-    sqlite3WalkExprList(&w, pWInfo->pOrderBy);\n-    sqlite3WalkExprList(&w, pWInfo->pResultSet);\n-  }\n-}\n-\n@@ -150679,0 +157646,2 @@\n+      sqlite3VdbeAddOp2(pParse->pVdbe, OP_MustBeInt, regRowid, addrNxt);\n+      VdbeCoverage(pParse->pVdbe);\n@@ -150738,2 +157707,2 @@\n-#if WHERETRACE_ENABLED \/* 0x20800 *\/\n-  if( sqlite3WhereTrace & 0x800 ){\n+#if WHERETRACE_ENABLED \/* 0x4001 *\/\n+  if( sqlite3WhereTrace & 0x1 ){\n@@ -150742,1 +157711,3 @@\n-    sqlite3WhereLoopPrint(pLoop, pWC);\n+    if( sqlite3WhereTrace & 0x1000 ){\n+      sqlite3WhereLoopPrint(pLoop, pWC);\n+    }\n@@ -150744,1 +157715,1 @@\n-  if( sqlite3WhereTrace & 0x20000 ){\n+  if( (sqlite3WhereTrace & 0x4001)==0x4001 ){\n@@ -150830,3 +157801,3 @@\n-          assert( pWInfo->pLimit!=0 );\n-          assert( pWInfo->pLimit->iOffset>0 );\n-          sqlite3VdbeAddOp2(v, OP_Integer, 0, pWInfo->pLimit->iOffset);\n+          assert( pWInfo->pSelect!=0 );\n+          assert( pWInfo->pSelect->iOffset>0 );\n+          sqlite3VdbeAddOp2(v, OP_Integer, 0, pWInfo->pSelect->iOffset);\n@@ -150940,0 +157911,2 @@\n+      sqlite3VdbeAddOp2(v, OP_MustBeInt, iRowidReg, addrNxt);\n+      VdbeCoverage(v);\n@@ -150985,1 +157958,1 @@\n-      assert( TK_GE==TK_GT+3 );      \/*  ... is correcct. *\/\n+      assert( TK_GE==TK_GT+3 );      \/*  ... is correct. *\/\n@@ -151291,0 +158264,5 @@\n+        if( pRangeStart || pRangeEnd ){\n+          sqlite3VdbeChangeP5(v, 1);\n+          sqlite3VdbeChangeP2(v, addrSeekScan, sqlite3VdbeCurrentAddr(v)+1);\n+          addrSeekScan = 0;\n+        }\n@@ -151327,10 +158305,1 @@\n-      if( addrSeekScan ){\n-        \/* For a seek-scan that has a range on the lowest term of the index,\n-        ** we have to make the top of the loop be code that sets the end\n-        ** condition of the range.  Otherwise, the OP_SeekScan might jump\n-        ** over that initialization, leaving the range-end value set to the\n-        ** range-start value, resulting in a wrong answer.\n-        ** See ticket 5981a8c041a3c2f3 (2021-11-02).\n-        *\/\n-        pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n-      }\n+      assert( addrSeekScan==0 );\n@@ -151366,2 +158335,2 @@\n-    sqlite3DbFree(db, zStartAff);\n-    sqlite3DbFree(db, zEndAff);\n+    if( zStartAff ) sqlite3DbNNFreeNN(db, zStartAff);\n+    if( zEndAff ) sqlite3DbNNFreeNN(db, zEndAff);\n@@ -151370,1 +158339,1 @@\n-    if( pLevel->p2==0 ) pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n+    pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n@@ -151429,21 +158398,0 @@\n-      \/* If pIdx is an index on one or more expressions, then look through\n-      ** all the expressions in pWInfo and try to transform matching expressions\n-      ** into reference to index columns.  Also attempt to translate references\n-      ** to virtual columns in the table into references to (stored) columns\n-      ** of the index.\n-      **\n-      ** Do not do this for the RHS of a LEFT JOIN. This is because the\n-      ** expression may be evaluated after OP_NullRow has been executed on\n-      ** the cursor. In this case it is important to do the full evaluation,\n-      ** as the result of the expression may not be NULL, even if all table\n-      ** column values are.  https:\/\/www.sqlite.org\/src\/info\/7fa8049685b50b5a\n-      **\n-      ** Also, do not do this when processing one index an a multi-index\n-      ** OR clause, since the transformation will become invalid once we\n-      ** move forward to the next index.\n-      ** https:\/\/sqlite.org\/src\/info\/4e8e4857d32d401f\n-      *\/\n-      if( (pWInfo->wctrlFlags & (WHERE_OR_SUBCLAUSE|WHERE_RIGHT_JOIN))==0 ){\n-        whereIndexExprTrans(pIdx, iCur, iIdxCur, pWInfo);\n-      }\n-\n@@ -151562,1 +158510,1 @@\n-      pOrTab = sqlite3StackAllocRaw(db,\n+      pOrTab = sqlite3DbMallocRawNN(db,\n@@ -151682,1 +158630,1 @@\n-        WHERETRACE(0xffff, (\"Subplan for OR-clause:\\n\"));\n+        WHERETRACE(0xffffffff, (\"Subplan for OR-clause:\\n\"));\n@@ -151815,1 +158763,1 @@\n-    if( pWInfo->nLevel>1 ){ sqlite3StackFree(db, pOrTab); }\n+    if( pWInfo->nLevel>1 ){ sqlite3DbFreeNN(db, pOrTab); }\n@@ -151919,1 +158867,1 @@\n-#ifdef WHERETRACE_ENABLED \/* 0xffff *\/\n+#ifdef WHERETRACE_ENABLED \/* 0xffffffff *\/\n@@ -151924,1 +158872,1 @@\n-      if( sqlite3WhereTrace & 0x800 ){\n+      if( sqlite3WhereTrace & 0x4000 ){\n@@ -151953,2 +158901,2 @@\n-#ifdef WHERETRACE_ENABLED \/* 0x800 *\/\n-    if( sqlite3WhereTrace & 0x800 ){\n+#ifdef WHERETRACE_ENABLED \/* 0x4001 *\/\n+    if( (sqlite3WhereTrace & 0x4001)==0x4001 ){\n@@ -152069,2 +159017,2 @@\n-#if WHERETRACE_ENABLED \/* 0x20800 *\/\n-  if( sqlite3WhereTrace & 0x20000 ){\n+#if WHERETRACE_ENABLED \/* 0x4001 *\/\n+  if( sqlite3WhereTrace & 0x4000 ){\n@@ -152075,1 +159023,1 @@\n-  if( sqlite3WhereTrace & 0x800 ){\n+  if( sqlite3WhereTrace & 0x1 ){\n@@ -152190,1 +159138,1 @@\n-** readability and editabiliity.  This file contains utility routines for\n+** readability and editability.  This file contains utility routines for\n@@ -152406,1 +159354,1 @@\n-    if( cnt!=0 && 255!=(u8)z[cnt-1] && (cnt>1 || z[0]!=wc[3]) ){\n+    if( (cnt>1 || (cnt>0 && z[0]!=wc[3])) && 255!=(u8)z[cnt-1] ){\n@@ -152443,1 +159391,1 @@\n-             && pLeft->y.pTab\n+             && ALWAYS(pLeft->y.pTab)\n@@ -152560,2 +159508,1 @@\n-    assert( pCol->op!=TK_COLUMN || ExprUseYTab(pCol) );\n-    testcase( pCol->op==TK_COLUMN && pCol->y.pTab==0 );\n+    assert( pCol->op!=TK_COLUMN || (ExprUseYTab(pCol) && pCol->y.pTab!=0) );\n@@ -152586,1 +159533,1 @@\n-    testcase( pCol->op==TK_COLUMN && pCol->y.pTab==0 );\n+    assert( pCol->op!=TK_COLUMN || (ExprUseYTab(pCol) && pCol->y.pTab!=0) );\n@@ -152611,2 +159558,1 @@\n-    assert( pLeft->op!=TK_COLUMN || ExprUseYTab(pLeft) );\n-    testcase( pLeft->op==TK_COLUMN && pLeft->y.pTab==0 );\n+    assert( pLeft->op!=TK_COLUMN || (ExprUseYTab(pLeft) && pLeft->y.pTab!=0) );\n@@ -152616,2 +159562,2 @@\n-    assert( pRight==0 || pRight->op!=TK_COLUMN || ExprUseYTab(pRight) );\n-    testcase( pRight && pRight->op==TK_COLUMN && pRight->y.pTab==0 );\n+    assert( pRight==0 || pRight->op!=TK_COLUMN\n+            || (ExprUseYTab(pRight) && pRight->y.pTab!=0) );\n@@ -152981,1 +159927,1 @@\n-          ** or follwed by an inverted copy (t2.b==t1.a).  Skip this term\n+          ** or followed by an inverted copy (t2.b==t1.a).  Skip this term\n@@ -153153,1 +160099,0 @@\n-  Bitmask mPrereq,       \/* Bitmask of FROM clause terms referenced by pExpr *\/\n@@ -153155,1 +160100,2 @@\n-  Expr *pExpr            \/* An operand of a comparison operator *\/\n+  Expr *pExpr,           \/* An operand of a comparison operator *\/\n+  int j                  \/* Start looking with the j-th pFrom entry *\/\n@@ -153160,10 +160106,14 @@\n-  for(i=0; mPrereq>1; i++, mPrereq>>=1){}\n-  iCur = pFrom->a[i].iCursor;\n-  for(pIdx=pFrom->a[i].pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n-    if( pIdx->aColExpr==0 ) continue;\n-    for(i=0; i<pIdx->nKeyCol; i++){\n-      if( pIdx->aiColumn[i]!=XN_EXPR ) continue;\n-      if( sqlite3ExprCompareSkip(pExpr, pIdx->aColExpr->a[i].pExpr, iCur)==0 ){\n-        aiCurCol[0] = iCur;\n-        aiCurCol[1] = XN_EXPR;\n-        return 1;\n+  do{\n+    iCur = pFrom->a[j].iCursor;\n+    for(pIdx=pFrom->a[j].pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n+      if( pIdx->aColExpr==0 ) continue;\n+      for(i=0; i<pIdx->nKeyCol; i++){\n+        if( pIdx->aiColumn[i]!=XN_EXPR ) continue;\n+        assert( pIdx->bHasExpr );\n+        if( sqlite3ExprCompareSkip(pExpr,pIdx->aColExpr->a[i].pExpr,iCur)==0\n+          && pExpr->op!=TK_STRING\n+        ){\n+          aiCurCol[0] = iCur;\n+          aiCurCol[1] = XN_EXPR;\n+          return 1;\n+        }\n@@ -153172,1 +160122,1 @@\n-  }\n+  }while( ++j < pFrom->nSrc );\n@@ -153177,1 +160127,0 @@\n-  Bitmask mPrereq,       \/* Bitmask of FROM clause terms referenced by pExpr *\/\n@@ -153182,0 +160131,2 @@\n+  int i;\n+\n@@ -153191,1 +160142,0 @@\n-\n@@ -153199,3 +160149,10 @@\n-  if( mPrereq==0 ) return 0;                 \/* No table references *\/\n-  if( (mPrereq&(mPrereq-1))!=0 ) return 0;   \/* Refs more than one table *\/\n-  return exprMightBeIndexed2(pFrom,mPrereq,aiCurCol,pExpr);\n+\n+  for(i=0; i<pFrom->nSrc; i++){\n+    Index *pIdx;\n+    for(pIdx=pFrom->a[i].pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n+      if( pIdx->aColExpr ){\n+        return exprMightBeIndexed2(pFrom,aiCurCol,pExpr,i);\n+      }\n+    }\n+  }\n+  return 0;\n@@ -153232,2 +160189,2 @@\n-  Bitmask prereqLeft;              \/* Prerequesites of the pExpr->pLeft *\/\n-  Bitmask prereqAll;               \/* Prerequesites of pExpr *\/\n+  Bitmask prereqLeft;              \/* Prerequisites of the pExpr->pLeft *\/\n+  Bitmask prereqAll;               \/* Prerequisites of pExpr *\/\n@@ -153327,1 +160284,1 @@\n-    if( exprMightBeIndexed(pSrc, prereqLeft, aiCurCol, pLeft, op) ){\n+    if( exprMightBeIndexed(pSrc, aiCurCol, pLeft, op) ){\n@@ -153335,1 +160292,1 @@\n-     && exprMightBeIndexed(pSrc, pTerm->prereqRight, aiCurCol, pRight, op)\n+     && exprMightBeIndexed(pSrc, aiCurCol, pRight, op)\n@@ -153379,1 +160336,1 @@\n-      pExpr->op = TK_TRUEFALSE;\n+      pExpr->op = TK_TRUEFALSE;  \/* See tag-20230504-1 *\/\n@@ -153546,1 +160503,0 @@\n-    exprAnalyze(pSrc, pWC, idxNew1);\n@@ -153554,0 +160510,1 @@\n+    exprAnalyze(pSrc, pWC, idxNew1);\n@@ -153610,1 +160567,1 @@\n-   && pExpr->x.pSelect->pPrior==0\n+   && (pExpr->x.pSelect->pPrior==0 || (pExpr->x.pSelect->selFlags & SF_Values))\n@@ -153779,3 +160736,3 @@\n-SQLITE_PRIVATE void sqlite3WhereAddLimit(WhereClause *pWC, Select *p){\n-  assert( p==0 || (p->pGroupBy==0 && (p->selFlags & SF_Aggregate)==0) );\n-  if( (p && p->pLimit)                                          \/* 1 *\/\n+SQLITE_PRIVATE void SQLITE_NOINLINE sqlite3WhereAddLimit(WhereClause *pWC, Select *p){\n+  assert( p!=0 && p->pLimit!=0 );                 \/* 1 -- checked by caller *\/\n+  if( p->pGroupBy==0\n@@ -153798,0 +160755,7 @@\n+      if( pWC->a[ii].nChild ){\n+        \/* If this term has child terms, then they are also part of the\n+        ** pWC->a[] array. So this term can be ignored, as a LIMIT clause\n+        ** will only be added if each of the child terms passes the\n+        ** (leftCursor==iCsr) test below.  *\/\n+        continue;\n+      }\n@@ -154017,1 +160981,3 @@\n-    if( pItem->fg.jointype & (JT_LEFT|JT_LTORJ) ){\n+    if( pItem->fg.jointype & (JT_LEFT|JT_RIGHT) ){\n+      testcase( pItem->fg.jointype & JT_LEFT );  \/* testtag-20230227a *\/\n+      testcase( pItem->fg.jointype & JT_RIGHT ); \/* testtag-20230227b *\/\n@@ -154020,0 +160986,1 @@\n+      testcase( pItem->fg.jointype & JT_LTORJ ); \/* testtag-20230227c *\/\n@@ -154098,1 +161065,1 @@\n-  return pWInfo->nOBSat;\n+  return pWInfo->nOBSat<0 ? 0 : pWInfo->nOBSat;\n@@ -154709,0 +161676,5 @@\n+#ifdef SQLITE_DEBUG\n+      if( pParse->db->flags & SQLITE_VdbeAddopTrace ){\n+        printf(\"TRANSLATE OP_Column to OP_Copy at %d\\n\", iStart);\n+      }\n+#endif\n@@ -154715,0 +161687,5 @@\n+#ifdef SQLITE_DEBUG\n+      if( pParse->db->flags & SQLITE_VdbeAddopTrace ){\n+        printf(\"TRANSLATE OP_Rowid to OP_Sequence at %d\\n\", iStart);\n+      }\n+#endif\n@@ -154736,1 +161713,1 @@\n-  if( !sqlite3WhereTrace ) return;\n+  if( (sqlite3WhereTrace & 0x10)==0 ) return;\n@@ -154756,1 +161733,1 @@\n-  if( !sqlite3WhereTrace ) return;\n+  if( (sqlite3WhereTrace & 0x10)==0 ) return;\n@@ -154774,0 +161751,37 @@\n+\/*\n+** We know that pSrc is an operand of an outer join.  Return true if\n+** pTerm is a constraint that is compatible with that join.\n+**\n+** pTerm must be EP_OuterON if pSrc is the right operand of an\n+** outer join.  pTerm can be either EP_OuterON or EP_InnerON if pSrc\n+** is the left operand of a RIGHT join.\n+**\n+** See https:\/\/sqlite.org\/forum\/forumpost\/206d99a16dd9212f\n+** for an example of a WHERE clause constraints that may not be used on\n+** the right table of a RIGHT JOIN because the constraint implies a\n+** not-NULL condition on the left table of the RIGHT JOIN.\n+*\/\n+static int constraintCompatibleWithOuterJoin(\n+  const WhereTerm *pTerm,       \/* WHERE clause term to check *\/\n+  const SrcItem *pSrc           \/* Table we are trying to access *\/\n+){\n+  assert( (pSrc->fg.jointype&(JT_LEFT|JT_LTORJ|JT_RIGHT))!=0 ); \/* By caller *\/\n+  testcase( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))==JT_LEFT );\n+  testcase( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))==JT_LTORJ );\n+  testcase( ExprHasProperty(pTerm->pExpr, EP_OuterON) )\n+  testcase( ExprHasProperty(pTerm->pExpr, EP_InnerON) );\n+  if( !ExprHasProperty(pTerm->pExpr, EP_OuterON|EP_InnerON)\n+   || pTerm->pExpr->w.iJoin != pSrc->iCursor\n+  ){\n+    return 0;\n+  }\n+  if( (pSrc->fg.jointype & (JT_LEFT|JT_RIGHT))!=0\n+   && ExprHasProperty(pTerm->pExpr, EP_InnerON)\n+  ){\n+    return 0;\n+  }\n+  return 1;\n+}\n+\n+\n+\n@@ -154789,10 +161803,4 @@\n-  if( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))!=0 ){\n-    testcase( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))==JT_LEFT );\n-    testcase( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))==JT_LTORJ );\n-    testcase( ExprHasProperty(pTerm->pExpr, EP_OuterON) )\n-    testcase( ExprHasProperty(pTerm->pExpr, EP_InnerON) );\n-    if( !ExprHasProperty(pTerm->pExpr, EP_OuterON|EP_InnerON)\n-     || pTerm->pExpr->w.iJoin != pSrc->iCursor\n-    ){\n-      return 0;  \/* See tag-20191211-001 *\/\n-    }\n+  if( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))!=0\n+   && !constraintCompatibleWithOuterJoin(pTerm,pSrc)\n+  ){\n+    return 0;  \/* See https:\/\/sqlite.org\/forum\/forumpost\/51e6959f61 *\/\n@@ -154812,0 +161820,51 @@\n+\n+#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n+\/*\n+** Argument pIdx represents an automatic index that the current statement\n+** will create and populate. Add an OP_Explain with text of the form:\n+**\n+**     CREATE AUTOMATIC INDEX ON <table>(<cols>) [WHERE <expr>]\n+**\n+** This is only required if sqlite3_stmt_scanstatus() is enabled, to\n+** associate an SQLITE_SCANSTAT_NCYCLE and SQLITE_SCANSTAT_NLOOP\n+** values with. In order to avoid breaking legacy code and test cases,\n+** the OP_Explain is not added if this is an EXPLAIN QUERY PLAN command.\n+*\/\n+static void explainAutomaticIndex(\n+  Parse *pParse,\n+  Index *pIdx,                    \/* Automatic index to explain *\/\n+  int bPartial,                   \/* True if pIdx is a partial index *\/\n+  int *pAddrExplain               \/* OUT: Address of OP_Explain *\/\n+){\n+  if( IS_STMT_SCANSTATUS(pParse->db) && pParse->explain!=2 ){\n+    Table *pTab = pIdx->pTable;\n+    const char *zSep = \"\";\n+    char *zText = 0;\n+    int ii = 0;\n+    sqlite3_str *pStr = sqlite3_str_new(pParse->db);\n+    sqlite3_str_appendf(pStr,\"CREATE AUTOMATIC INDEX ON %s(\", pTab->zName);\n+    assert( pIdx->nColumn>1 );\n+    assert( pIdx->aiColumn[pIdx->nColumn-1]==XN_ROWID );\n+    for(ii=0; ii<(pIdx->nColumn-1); ii++){\n+      const char *zName = 0;\n+      int iCol = pIdx->aiColumn[ii];\n+\n+      zName = pTab->aCol[iCol].zCnName;\n+      sqlite3_str_appendf(pStr, \"%s%s\", zSep, zName);\n+      zSep = \", \";\n+    }\n+    zText = sqlite3_str_finish(pStr);\n+    if( zText==0 ){\n+      sqlite3OomFault(pParse->db);\n+    }else{\n+      *pAddrExplain = sqlite3VdbeExplain(\n+          pParse, 0, \"%s)%s\", zText, (bPartial ? \" WHERE <expr>\" : \"\")\n+      );\n+      sqlite3_free(zText);\n+    }\n+  }\n+}\n+#else\n+# define explainAutomaticIndex(a,b,c,d)\n+#endif\n+\n@@ -154819,2 +161878,1 @@\n-  const WhereClause *pWC,     \/* The WHERE clause *\/\n-  const SrcItem *pSrc,        \/* The FROM clause term to get the next index *\/\n+  WhereClause *pWC,           \/* The WHERE clause *\/\n@@ -154841,1 +161899,2 @@\n-  u8 sentWarning = 0;         \/* True if a warnning has been issued *\/\n+  u8 sentWarning = 0;         \/* True if a warning has been issued *\/\n+  u8 useBloomFilter = 0;      \/* True to also add a Bloom filter *\/\n@@ -154844,1 +161903,2 @@\n-  SrcItem *pTabItem;          \/* FROM clause term being indexed *\/\n+  SrcList *pTabList;          \/* The complete FROM clause *\/\n+  SrcItem *pSrc;              \/* The FROM clause term to get the next index *\/\n@@ -154847,0 +161907,3 @@\n+#ifdef SQLITE_ENABLE_STMT_SCANSTATUS\n+  int addrExp = 0;            \/* Address of OP_Explain *\/\n+#endif\n@@ -154857,0 +161920,2 @@\n+  pTabList = pWC->pWInfo->pTabList;\n+  pSrc = &pTabList->a[pLevel->iFrom];\n@@ -154867,1 +161932,1 @@\n-     && sqlite3ExprIsTableConstraint(pExpr, pSrc)\n+     && sqlite3ExprIsSingleTableConstraint(pExpr, pTabList, pLevel->iFrom)\n@@ -154908,1 +161973,5 @@\n-  extraCols = pSrc->colUsed & (~idxCols | MASKBIT(BMS-1));\n+  if( IsView(pTable) ){\n+    extraCols = ALLBITS;\n+  }else{\n+    extraCols = pSrc->colUsed & (~idxCols | MASKBIT(BMS-1));\n+  }\n@@ -154944,0 +162013,10 @@\n+        if( ALWAYS(pX->pLeft!=0)\n+         && sqlite3ExprAffinity(pX->pLeft)!=SQLITE_AFF_TEXT\n+        ){\n+          \/* TUNING: only use a Bloom filter on an automatic index\n+          ** if one or more key columns has the ability to hold numeric\n+          ** values, since strings all have the same hash in the Bloom\n+          ** filter implementation and hence a Bloom filter on a text column\n+          ** is not usually helpful. *\/\n+          useBloomFilter = 1;\n+        }\n@@ -154970,0 +162049,1 @@\n+  explainAutomaticIndex(pParse, pIdx, pPartial!=0, &addrExp);\n@@ -154975,1 +162055,2 @@\n-  if( OptimizationEnabled(pParse->db, SQLITE_BloomFilter) ){\n+  if( OptimizationEnabled(pParse->db, SQLITE_BloomFilter) && useBloomFilter ){\n+    sqlite3WhereExplainBloomFilter(pParse, pWC->pWInfo, pLevel);\n@@ -154981,3 +162062,3 @@\n-  pTabItem = &pWC->pWInfo->pTabList->a[pLevel->iFrom];\n-  if( pTabItem->fg.viaCoroutine ){\n-    int regYield = pTabItem->regReturn;\n+  assert( pSrc == &pWC->pWInfo->pTabList->a[pLevel->iFrom] );\n+  if( pSrc->fg.viaCoroutine ){\n+    int regYield = pSrc->regReturn;\n@@ -154985,1 +162066,1 @@\n-    sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, pTabItem->addrFillSub);\n+    sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, pSrc->addrFillSub);\n@@ -154988,1 +162069,1 @@\n-    VdbeComment((v, \"next row of %s\", pTabItem->pTab->zName));\n+    VdbeComment((v, \"next row of %s\", pSrc->pTab->zName));\n@@ -155005,0 +162086,1 @@\n+  sqlite3VdbeScanStatusCounters(v, addrExp, addrExp, sqlite3VdbeCurrentAddr(v));\n@@ -155008,1 +162090,1 @@\n-  if( pTabItem->fg.viaCoroutine ){\n+  if( pSrc->fg.viaCoroutine ){\n@@ -155013,1 +162095,1 @@\n-                          pTabItem->regResult, pLevel->iIdxCur);\n+                          pSrc->regResult, pLevel->iIdxCur);\n@@ -155015,1 +162097,1 @@\n-    pTabItem->fg.viaCoroutine = 0;\n+    pSrc->fg.viaCoroutine = 0;\n@@ -155025,0 +162107,1 @@\n+  sqlite3VdbeScanStatusRange(v, addrExp, addrExp, -1);\n@@ -155066,0 +162149,7 @@\n+  IndexedExpr *saved_pIdxEpr;          \/* saved copy of Parse.pIdxEpr *\/\n+  IndexedExpr *saved_pIdxPartExpr;     \/* saved copy of Parse.pIdxPartExpr *\/\n+\n+  saved_pIdxEpr = pParse->pIdxEpr;\n+  saved_pIdxPartExpr = pParse->pIdxPartExpr;\n+  pParse->pIdxEpr = 0;\n+  pParse->pIdxPartExpr = 0;\n@@ -155070,0 +162160,1 @@\n+  assert( (pLoop->wsFlags & WHERE_IDX_ONLY)==0 );\n@@ -155073,0 +162164,1 @@\n+    const SrcList *pTabList;\n@@ -155076,0 +162168,1 @@\n+    int iSrc;\n@@ -155089,1 +162182,3 @@\n-    pItem = &pWInfo->pTabList->a[pLevel->iFrom];\n+    pTabList = pWInfo->pTabList;\n+    iSrc = pLevel->iFrom;\n+    pItem = &pTabList->a[iSrc];\n@@ -155106,1 +162201,1 @@\n-       && sqlite3ExprIsTableConstraint(pExpr, pItem)\n+       && sqlite3ExprIsSingleTableConstraint(pExpr, pTabList, iSrc)\n@@ -155122,1 +162217,0 @@\n-        int iCol = pIdx->aiColumn[jj];\n@@ -155124,1 +162218,1 @@\n-        sqlite3ExprCodeGetColumnOfTable(v, pIdx->pTable, iCur, iCol,r1+jj);\n+        sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iCur, jj, r1+jj);\n@@ -155155,0 +162249,2 @@\n+  pParse->pIdxEpr = saved_pIdxEpr;\n+  pParse->pIdxPartExpr = saved_pIdxPartExpr;\n@@ -155210,16 +162306,4 @@\n-\n-    \/* tag-20191211-002: WHERE-clause constraints are not useful to the\n-    ** right-hand table of a LEFT JOIN nor to the either table of a\n-    ** RIGHT JOIN.  See tag-20191211-001 for the\n-    ** equivalent restriction for ordinary tables. *\/\n-    if( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))!=0 ){\n-      testcase( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))==JT_LEFT );\n-      testcase( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))==JT_RIGHT );\n-      testcase( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))==JT_LTORJ );\n-      testcase( ExprHasProperty(pTerm->pExpr, EP_OuterON) );\n-      testcase( ExprHasProperty(pTerm->pExpr, EP_InnerON) );\n-      if( !ExprHasProperty(pTerm->pExpr, EP_OuterON|EP_InnerON)\n-       || pTerm->pExpr->w.iJoin != pSrc->iCursor\n-      ){\n-        continue;\n-      }\n+    if( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))!=0\n+     && !constraintCompatibleWithOuterJoin(pTerm,pSrc)\n+    ){\n+      continue;\n@@ -155422,0 +162506,3 @@\n+  if( pTab->u.vtab.p->bAllSchemas ){\n+    sqlite3VtabUsesAllSchemas(pParse);\n+  }\n@@ -155466,0 +162553,1 @@\n+\n@@ -155510,1 +162598,6 @@\n-  nField = MIN(pRec->nField, pIdx->nSample);\n+  if( !HasRowid(pIdx->pTable) && IsPrimaryKeyIndex(pIdx) ){\n+    nField = pIdx->nKeyCol;\n+  }else{\n+    nField = pIdx->nColumn;\n+  }\n+  nField = MIN(pRec->nField, nField);\n@@ -155576,1 +162669,1 @@\n-             || pParse->db->mallocFailed );\n+             || pParse->db->mallocFailed || CORRUPT_DB );\n@@ -155581,1 +162674,1 @@\n-             || pParse->db->mallocFailed );\n+             || pParse->db->mallocFailed || CORRUPT_DB );\n@@ -155598,1 +162691,1 @@\n-      iUpper = sqlite3LogEstToInt(pIdx->aiRowLogEst[0]);\n+      iUpper = pIdx->nRowEst0;\n@@ -155673,1 +162766,1 @@\n-** on the stat4 data for the index. this scan will be peformed multiple\n+** on the stat4 data for the index. this scan will be performed multiple\n@@ -155754,1 +162847,1 @@\n-      WHERETRACE(0x10, (\"range skip-scan regions: %u..%u  adjust=%d est=%d\\n\",\n+      WHERETRACE(0x20, (\"range skip-scan regions: %u..%u  adjust=%d est=%d\\n\",\n@@ -155925,1 +163018,2 @@\n-          if( iLwrIdx==iUprIdx ) nNew -= 20;  assert( 20==sqlite3LogEst(4) );\n+          if( iLwrIdx==iUprIdx ){ nNew -= 20; }\n+          assert( 20==sqlite3LogEst(4) );\n@@ -155932,1 +163026,1 @@\n-        WHERETRACE(0x10, (\"STAT4 range scan: %u..%u  est=%d\\n\",\n+        WHERETRACE(0x20, (\"STAT4 range scan: %u..%u  est=%d\\n\",\n@@ -155946,1 +163040,1 @@\n-  assert( pUpper==0 || (pUpper->wtFlags & TERM_VNULL)==0 );\n+  assert( pUpper==0 || (pUpper->wtFlags & TERM_VNULL)==0 || pParse->nErr>0 );\n@@ -155965,1 +163059,1 @@\n-    WHERETRACE(0x10,(\"Range scan lowers nOut from %d to %d\\n\",\n+    WHERETRACE(0x20,(\"Range scan lowers nOut from %d to %d\\n\",\n@@ -156030,1 +163124,1 @@\n-  WHERETRACE(0x10,(\"equality scan regions %s(%d): %d\\n\",\n+  WHERETRACE(0x20,(\"equality scan regions %s(%d): %d\\n\",\n@@ -156078,1 +163172,1 @@\n-    if( nRowEst > nRow0 ) nRowEst = nRow0;\n+    if( nRowEst > (tRowcnt)nRow0 ) nRowEst = nRow0;\n@@ -156080,1 +163174,1 @@\n-    WHERETRACE(0x10,(\"IN row estimate: est=%d\\n\", nRowEst));\n+    WHERETRACE(0x20,(\"IN row estimate: est=%d\\n\", nRowEst));\n@@ -156149,11 +163243,28 @@\n-*\/\n-SQLITE_PRIVATE void sqlite3WhereLoopPrint(WhereLoop *p, WhereClause *pWC){\n-  WhereInfo *pWInfo = pWC->pWInfo;\n-  int nb = 1+(pWInfo->pTabList->nSrc+3)\/4;\n-  SrcItem *pItem = pWInfo->pTabList->a + p->iTab;\n-  Table *pTab = pItem->pTab;\n-  Bitmask mAll = (((Bitmask)1)<<(nb*4)) - 1;\n-  sqlite3DebugPrintf(\"%c%2d.%0*llx.%0*llx\", p->cId,\n-                     p->iTab, nb, p->maskSelf, nb, p->prereq & mAll);\n-  sqlite3DebugPrintf(\" %12s\",\n-                     pItem->zAlias ? pItem->zAlias : pTab->zName);\n+**\n+** Format example:\n+**\n+**     .--- Position in WHERE clause           rSetup, rRun, nOut ---.\n+**     |                                                             |\n+**     |  .--- selfMask                       nTerm ------.          |\n+**     |  |                                               |          |\n+**     |  |   .-- prereq    Idx          wsFlags----.     |          |\n+**     |  |   |             Name                    |     |          |\n+**     |  |   |           __|__        nEq ---.  ___|__   |        __|__\n+**     | \/ \\ \/ \\         \/     \\              | \/      \\ \/ \\      \/     \\\n+**     1.002.001         t2.t2xy              2 f 010241 N 2 cost 0,56,31\n+*\/\n+SQLITE_PRIVATE void sqlite3WhereLoopPrint(const WhereLoop *p, const WhereClause *pWC){\n+  if( pWC ){\n+    WhereInfo *pWInfo = pWC->pWInfo;\n+    int nb = 1+(pWInfo->pTabList->nSrc+3)\/4;\n+    SrcItem *pItem = pWInfo->pTabList->a + p->iTab;\n+    Table *pTab = pItem->pTab;\n+    Bitmask mAll = (((Bitmask)1)<<(nb*4)) - 1;\n+    sqlite3DebugPrintf(\"%c%2d.%0*llx.%0*llx\", p->cId,\n+                       p->iTab, nb, p->maskSelf, nb, p->prereq & mAll);\n+    sqlite3DebugPrintf(\" %12s\",\n+                       pItem->zAlias ? pItem->zAlias : pTab->zName);\n+  }else{\n+    sqlite3DebugPrintf(\"%c%2d.%03llx.%03llx %c%d\",\n+         p->cId, p->iTab, p->maskSelf, p->prereq & 0xfff, p->cId, p->iTab);\n+  }\n@@ -156189,1 +163300,1 @@\n-  if( p->nLTerm && (sqlite3WhereTrace & 0x100)!=0 ){\n+  if( p->nLTerm && (sqlite3WhereTrace & 0x4000)!=0 ){\n@@ -156196,0 +163307,9 @@\n+SQLITE_PRIVATE void sqlite3ShowWhereLoop(const WhereLoop *p){\n+  if( p ) sqlite3WhereLoopPrint(p, 0);\n+}\n+SQLITE_PRIVATE void sqlite3ShowWhereLoopList(const WhereLoop *p){\n+  while( p ){\n+    sqlite3ShowWhereLoop(p);\n+    p = p->pNextLoop;\n+  }\n+}\n@@ -156227,1 +163347,2 @@\n-** Deallocate internal memory used by a WhereLoop object\n+** Deallocate internal memory used by a WhereLoop object.  Leave the\n+** object in an initialized state, as if it had been newly allocated.\n@@ -156230,1 +163351,5 @@\n-  if( p->aLTerm!=p->aLTermSpace ) sqlite3DbFreeNN(db, p->aLTerm);\n+  if( p->aLTerm!=p->aLTermSpace ){\n+    sqlite3DbFreeNN(db, p->aLTerm);\n+    p->aLTerm = p->aLTermSpace;\n+    p->nLSlot = ArraySize(p->aLTermSpace);\n+  }\n@@ -156232,1 +163357,2 @@\n-  whereLoopInit(p);\n+  p->nLTerm = 0;\n+  p->wsFlags = 0;\n@@ -156256,1 +163382,3 @@\n-  if( whereLoopResize(db, pTo, pFrom->nLTerm) ){\n+  if( pFrom->nLTerm > pTo->nLSlot\n+   && whereLoopResize(db, pTo, pFrom->nLTerm)\n+  ){\n@@ -156274,0 +163402,1 @@\n+  assert( db!=0 );\n@@ -156275,1 +163404,1 @@\n-  sqlite3DbFreeNN(db, p);\n+  sqlite3DbNNFreeNN(db, p);\n@@ -156283,0 +163412,1 @@\n+  assert( db!=0 );\n@@ -156289,1 +163419,0 @@\n-  assert( pWInfo->pExprMods==0 );\n@@ -156292,1 +163421,1 @@\n-    sqlite3DbFreeNN(db, pWInfo->pMemToFree);\n+    sqlite3DbNNFreeNN(db, pWInfo->pMemToFree);\n@@ -156295,12 +163424,1 @@\n-  sqlite3DbFreeNN(db, pWInfo);\n-}\n-\n-\/* Undo all Expr node modifications\n-*\/\n-static void whereUndoExprMods(WhereInfo *pWInfo){\n-  while( pWInfo->pExprMods ){\n-    WhereExprMod *p = pWInfo->pExprMods;\n-    pWInfo->pExprMods = p->pNext;\n-    memcpy(p->pExpr, &p->orig, sizeof(p->orig));\n-    sqlite3DbFree(pWInfo->pParse->db, p);\n-  }\n+  sqlite3DbNNFreeNN(db, pWInfo);\n@@ -156310,1 +163428,9 @@\n-** Return TRUE if all of the following are true:\n+** Return TRUE if X is a proper subset of Y but is of equal or less cost.\n+** In other words, return true if all constraints of X are also part of Y\n+** and Y has additional constraints that might speed the search that X lacks\n+** but the cost of running X is not more than the cost of running Y.\n+**\n+** In other words, return true if the cost relationwship between X and Y\n+** is inverted and needs to be adjusted.\n+**\n+** Case 1:\n@@ -156312,6 +163438,4 @@\n-**   (1)  X has the same or lower cost, or returns the same or fewer rows,\n-**        than Y.\n-**   (2)  X uses fewer WHERE clause terms than Y\n-**   (3)  Every WHERE clause term used by X is also used by Y\n-**   (4)  X skips at least as many columns as Y\n-**   (5)  If X is a covering index, than Y is too\n+**   (1a)  X and Y use the same index.\n+**   (1b)  X has fewer == terms than Y\n+**   (1c)  Neither X nor Y use skip-scan\n+**   (1d)  X does not have a a greater cost than Y\n@@ -156319,8 +163443,8 @@\n-** Conditions (2) and (3) mean that X is a \"proper subset\" of Y.\n-** If X is a proper subset of Y then Y is a better choice and ought\n-** to have a lower cost.  This routine returns TRUE when that cost\n-** relationship is inverted and needs to be adjusted.  Constraint (4)\n-** was added because if X uses skip-scan less than Y it still might\n-** deserve a lower cost even if it is a proper subset of Y.  Constraint (5)\n-** was added because a covering index probably deserves to have a lower cost\n-** than a non-covering index even if it is a proper subset.\n+** Case 2:\n+**\n+**   (2a)  X has the same or lower cost, or returns the same or fewer rows,\n+**         than Y.\n+**   (2b)  X uses fewer WHERE clause terms than Y\n+**   (2c)  Every WHERE clause term used by X is also used by Y\n+**   (2d)  X skips at least as many columns as Y\n+**   (2e)  If X is a covering index, than Y is too\n@@ -156333,0 +163457,9 @@\n+  if( pX->rRun>pY->rRun && pX->nOut>pY->nOut ) return 0; \/* (1d) and (2a) *\/\n+  assert( (pX->wsFlags & WHERE_VIRTUALTABLE)==0 );\n+  assert( (pY->wsFlags & WHERE_VIRTUALTABLE)==0 );\n+  if( pX->u.btree.nEq < pY->u.btree.nEq                  \/* (1b) *\/\n+   && pX->u.btree.pIndex==pY->u.btree.pIndex             \/* (1a) *\/\n+   && pX->nSkip==0 && pY->nSkip==0                       \/* (1c) *\/\n+  ){\n+    return 1;  \/* Case 1 is true *\/\n+  }\n@@ -156334,1 +163467,1 @@\n-    return 0; \/* X is not a subset of Y *\/\n+    return 0;                                            \/* (2b) *\/\n@@ -156336,2 +163469,1 @@\n-  if( pX->rRun>pY->rRun && pX->nOut>pY->nOut ) return 0;\n-  if( pY->nSkip > pX->nSkip ) return 0;\n+  if( pY->nSkip > pX->nSkip ) return 0;                  \/* (2d) *\/\n@@ -156343,1 +163475,1 @@\n-    if( j<0 ) return 0;  \/* X not a subset of Y since term X[i] not used by Y *\/\n+    if( j<0 ) return 0;                                  \/* (2c) *\/\n@@ -156347,1 +163479,1 @@\n-    return 0;  \/* Constraint (5) *\/\n+    return 0;                                            \/* (2e) *\/\n@@ -156349,1 +163481,1 @@\n-  return 1;  \/* All conditions meet *\/\n+  return 1;  \/* Case 2 is true *\/\n@@ -156430,1 +163562,1 @@\n-    \/* Any loop using an appliation-defined index (or PRIMARY KEY or\n+    \/* Any loop using an application-defined index (or PRIMARY KEY or\n@@ -156457,1 +163589,1 @@\n-    **   (1)  pTemplate has no more dependences than p, and\n+    **   (1)  pTemplate has no more dependencies than p, and\n@@ -156575,1 +163707,1 @@\n-    ** p[] that are also supplated by pTemplate *\/\n+    ** p[] that are also supplanted by pTemplate *\/\n@@ -156655,0 +163787,1 @@\n+      sqlite3ProgressCheck(pWC->pWInfo->pParse);\n@@ -156774,1 +163907,1 @@\n-** Adjust the cost C by the costMult facter T.  This only occurs if\n+** Adjust the cost C by the costMult factor T.  This only occurs if\n@@ -156801,1 +163934,1 @@\n-  WhereInfo *pWInfo = pBuilder->pWInfo;  \/* WHERE analyse context *\/\n+  WhereInfo *pWInfo = pBuilder->pWInfo;  \/* WHERE analyze context *\/\n@@ -156822,1 +163955,4 @@\n-  if( db->mallocFailed ) return SQLITE_NOMEM_BKPT;\n+  assert( db->mallocFailed==0 || pParse->nErr>0 );\n+  if( pParse->nErr ){\n+    return pParse->rc;\n+  }\n@@ -156835,1 +163971,4 @@\n-  if( pProbe->bUnordered ) opMask &= ~(WO_GT|WO_GE|WO_LT|WO_LE);\n+  if( pProbe->bUnordered || pProbe->bLowQual ){\n+    if( pProbe->bUnordered ) opMask &= ~(WO_GT|WO_GE|WO_LT|WO_LE);\n+    if( pProbe->bLowQual )   opMask &= ~(WO_EQ|WO_IN|WO_IS);\n+  }\n@@ -156873,24 +164012,4 @@\n-    \/* tag-20191211-001:  Do not allow constraints from the WHERE clause to\n-    ** be used by the right table of a LEFT JOIN nor by the left table of a\n-    ** RIGHT JOIN.  Only constraints in the ON clause are allowed.\n-    ** See tag-20191211-002 for the vtab equivalent.\n-    **\n-    ** 2022-06-06: See https:\/\/sqlite.org\/forum\/forumpost\/206d99a16dd9212f\n-    ** for an example of a WHERE clause constraints that may not be used on\n-    ** the right table of a RIGHT JOIN because the constraint implies a\n-    ** not-NULL condition on the left table of the RIGHT JOIN.\n-    **\n-    ** 2022-06-10: The same condition applies to termCanDriveIndex() above.\n-    ** https:\/\/sqlite.org\/forum\/forumpost\/51e6959f61\n-    *\/\n-    if( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))!=0 ){\n-      testcase( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))==JT_LEFT );\n-      testcase( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))==JT_RIGHT );\n-      testcase( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))==JT_LTORJ );\n-      testcase( ExprHasProperty(pTerm->pExpr, EP_OuterON) )\n-      testcase( ExprHasProperty(pTerm->pExpr, EP_InnerON) );\n-      if( !ExprHasProperty(pTerm->pExpr, EP_OuterON|EP_InnerON)\n-       || pTerm->pExpr->w.iJoin != pSrc->iCursor\n-      ){\n-        continue;\n-      }\n+    if( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))!=0\n+     && !constraintCompatibleWithOuterJoin(pTerm,pSrc)\n+    ){\n+      continue;\n@@ -156898,1 +164017,0 @@\n-\n@@ -156909,1 +164027,5 @@\n-    if( whereLoopResize(db, pNew, pNew->nLTerm+1) ) break; \/* OOM *\/\n+    if( pNew->nLTerm>=pNew->nLSlot\n+     && whereLoopResize(db, pNew, pNew->nLTerm+1)\n+    ){\n+       break; \/* OOM while trying to enlarge the pNew->aLTerm array *\/\n+    }\n@@ -157002,27 +164124,2 @@\n-    }else if( eOp & (WO_GT|WO_GE) ){\n-      testcase( eOp & WO_GT );\n-      testcase( eOp & WO_GE );\n-      pNew->wsFlags |= WHERE_COLUMN_RANGE|WHERE_BTM_LIMIT;\n-      pNew->u.btree.nBtm = whereRangeVectorLen(\n-          pParse, pSrc->iCursor, pProbe, saved_nEq, pTerm\n-      );\n-      pBtm = pTerm;\n-      pTop = 0;\n-      if( pTerm->wtFlags & TERM_LIKEOPT ){\n-        \/* Range constraints that come from the LIKE optimization are\n-        ** always used in pairs. *\/\n-        pTop = &pTerm[1];\n-        assert( (pTop-(pTerm->pWC->a))<pTerm->pWC->nTerm );\n-        assert( pTop->wtFlags & TERM_LIKEOPT );\n-        assert( pTop->eOperator==WO_LT );\n-        if( whereLoopResize(db, pNew, pNew->nLTerm+1) ) break; \/* OOM *\/\n-        pNew->aLTerm[pNew->nLTerm++] = pTop;\n-        pNew->wsFlags |= WHERE_TOP_LIMIT;\n-        pNew->u.btree.nTop = 1;\n-      }\n-    }else{\n-      assert( eOp & (WO_LT|WO_LE) );\n-      testcase( eOp & WO_LT );\n-      testcase( eOp & WO_LE );\n-      pNew->wsFlags |= WHERE_COLUMN_RANGE|WHERE_TOP_LIMIT;\n-      pNew->u.btree.nTop = whereRangeVectorLen(\n+    }else{\n+      int nVecLen = whereRangeVectorLen(\n@@ -157031,3 +164128,29 @@\n-      pTop = pTerm;\n-      pBtm = (pNew->wsFlags & WHERE_BTM_LIMIT)!=0 ?\n-                     pNew->aLTerm[pNew->nLTerm-2] : 0;\n+      if( eOp & (WO_GT|WO_GE) ){\n+        testcase( eOp & WO_GT );\n+        testcase( eOp & WO_GE );\n+        pNew->wsFlags |= WHERE_COLUMN_RANGE|WHERE_BTM_LIMIT;\n+        pNew->u.btree.nBtm = nVecLen;\n+        pBtm = pTerm;\n+        pTop = 0;\n+        if( pTerm->wtFlags & TERM_LIKEOPT ){\n+          \/* Range constraints that come from the LIKE optimization are\n+          ** always used in pairs. *\/\n+          pTop = &pTerm[1];\n+          assert( (pTop-(pTerm->pWC->a))<pTerm->pWC->nTerm );\n+          assert( pTop->wtFlags & TERM_LIKEOPT );\n+          assert( pTop->eOperator==WO_LT );\n+          if( whereLoopResize(db, pNew, pNew->nLTerm+1) ) break; \/* OOM *\/\n+          pNew->aLTerm[pNew->nLTerm++] = pTop;\n+          pNew->wsFlags |= WHERE_TOP_LIMIT;\n+          pNew->u.btree.nTop = 1;\n+        }\n+      }else{\n+        assert( eOp & (WO_LT|WO_LE) );\n+        testcase( eOp & WO_LT );\n+        testcase( eOp & WO_LE );\n+        pNew->wsFlags |= WHERE_COLUMN_RANGE|WHERE_TOP_LIMIT;\n+        pNew->u.btree.nTop = nVecLen;\n+        pTop = pTerm;\n+        pBtm = (pNew->wsFlags & WHERE_BTM_LIMIT)!=0 ?\n+                       pNew->aLTerm[pNew->nLTerm-2] : 0;\n+      }\n@@ -157085,1 +164208,1 @@\n-              if( sqlite3WhereTrace & 0x01 ){\n+              if( sqlite3WhereTrace & 0x20 ){\n@@ -157122,1 +164245,9 @@\n-    rCostIdx = pNew->nOut + 1 + (15*pProbe->szIdxRow)\/pSrc->pTab->szTabRow;\n+    if( pProbe->idxType==SQLITE_IDXTYPE_IPK ){\n+      \/* The pProbe->szIdxRow is low for an IPK table since the interior\n+      ** pages are small.  Thus szIdxRow gives a good estimate of seek cost.\n+      ** But the leaf pages are full-size, so pProbe->szIdxRow would badly\n+      ** under-estimate the scanning cost. *\/\n+      rCostIdx = pNew->nOut + 16;\n+    }else{\n+      rCostIdx = pNew->nOut + 1 + (15*pProbe->szIdxRow)\/pSrc->pTab->szTabRow;\n+    }\n@@ -157124,1 +164255,1 @@\n-    if( (pNew->wsFlags & (WHERE_IDX_ONLY|WHERE_IPK))==0 ){\n+    if( (pNew->wsFlags & (WHERE_IDX_ONLY|WHERE_IPK|WHERE_EXPRIDX))==0 ){\n@@ -157146,0 +164277,3 @@\n+      if( pNew->u.btree.nEq>3 ){\n+        sqlite3ProgressCheck(pParse);\n+      }\n@@ -157277,0 +164411,237 @@\n+\/*\n+** pIdx is an index containing expressions.  Check it see if any of the\n+** expressions in the index match the pExpr expression.\n+*\/\n+static int exprIsCoveredByIndex(\n+  const Expr *pExpr,\n+  const Index *pIdx,\n+  int iTabCur\n+){\n+  int i;\n+  for(i=0; i<pIdx->nColumn; i++){\n+    if( pIdx->aiColumn[i]==XN_EXPR\n+     && sqlite3ExprCompare(0, pExpr, pIdx->aColExpr->a[i].pExpr, iTabCur)==0\n+    ){\n+      return 1;\n+    }\n+  }\n+  return 0;\n+}\n+\n+\/*\n+** Structure passed to the whereIsCoveringIndex Walker callback.\n+*\/\n+typedef struct CoveringIndexCheck CoveringIndexCheck;\n+struct CoveringIndexCheck {\n+  Index *pIdx;       \/* The index *\/\n+  int iTabCur;       \/* Cursor number for the corresponding table *\/\n+  u8 bExpr;          \/* Uses an indexed expression *\/\n+  u8 bUnidx;         \/* Uses an unindexed column not within an indexed expr *\/\n+};\n+\n+\/*\n+** Information passed in is pWalk->u.pCovIdxCk.  Call it pCk.\n+**\n+** If the Expr node references the table with cursor pCk->iTabCur, then\n+** make sure that column is covered by the index pCk->pIdx.  We know that\n+** all columns less than 63 (really BMS-1) are covered, so we don't need\n+** to check them.  But we do need to check any column at 63 or greater.\n+**\n+** If the index does not cover the column, then set pWalk->eCode to\n+** non-zero and return WRC_Abort to stop the search.\n+**\n+** If this node does not disprove that the index can be a covering index,\n+** then just return WRC_Continue, to continue the search.\n+**\n+** If pCk->pIdx contains indexed expressions and one of those expressions\n+** matches pExpr, then prune the search.\n+*\/\n+static int whereIsCoveringIndexWalkCallback(Walker *pWalk, Expr *pExpr){\n+  int i;                    \/* Loop counter *\/\n+  const Index *pIdx;        \/* The index of interest *\/\n+  const i16 *aiColumn;      \/* Columns contained in the index *\/\n+  u16 nColumn;              \/* Number of columns in the index *\/\n+  CoveringIndexCheck *pCk;  \/* Info about this search *\/\n+\n+  pCk = pWalk->u.pCovIdxCk;\n+  pIdx = pCk->pIdx;\n+  if( (pExpr->op==TK_COLUMN || pExpr->op==TK_AGG_COLUMN) ){\n+    \/* if( pExpr->iColumn<(BMS-1) && pIdx->bHasExpr==0 ) return WRC_Continue;*\/\n+    if( pExpr->iTable!=pCk->iTabCur ) return WRC_Continue;\n+    pIdx = pWalk->u.pCovIdxCk->pIdx;\n+    aiColumn = pIdx->aiColumn;\n+    nColumn = pIdx->nColumn;\n+    for(i=0; i<nColumn; i++){\n+      if( aiColumn[i]==pExpr->iColumn ) return WRC_Continue;\n+    }\n+    pCk->bUnidx = 1;\n+    return WRC_Abort;\n+  }else if( pIdx->bHasExpr\n+         && exprIsCoveredByIndex(pExpr, pIdx, pWalk->u.pCovIdxCk->iTabCur) ){\n+    pCk->bExpr = 1;\n+    return WRC_Prune;\n+  }\n+  return WRC_Continue;\n+}\n+\n+\n+\/*\n+** pIdx is an index that covers all of the low-number columns used by\n+** pWInfo->pSelect (columns from 0 through 62) or an index that has\n+** expressions terms.  Hence, we cannot determine whether or not it is\n+** a covering index by using the colUsed bitmasks.  We have to do a search\n+** to see if the index is covering.  This routine does that search.\n+**\n+** The return value is one of these:\n+**\n+**      0                The index is definitely not a covering index\n+**\n+**      WHERE_IDX_ONLY   The index is definitely a covering index\n+**\n+**      WHERE_EXPRIDX    The index is likely a covering index, but it is\n+**                       difficult to determine precisely because of the\n+**                       expressions that are indexed.  Score it as a\n+**                       covering index, but still keep the main table open\n+**                       just in case we need it.\n+**\n+** This routine is an optimization.  It is always safe to return zero.\n+** But returning one of the other two values when zero should have been\n+** returned can lead to incorrect bytecode and assertion faults.\n+*\/\n+static SQLITE_NOINLINE u32 whereIsCoveringIndex(\n+  WhereInfo *pWInfo,     \/* The WHERE clause context *\/\n+  Index *pIdx,           \/* Index that is being tested *\/\n+  int iTabCur            \/* Cursor for the table being indexed *\/\n+){\n+  int i, rc;\n+  struct CoveringIndexCheck ck;\n+  Walker w;\n+  if( pWInfo->pSelect==0 ){\n+    \/* We don't have access to the full query, so we cannot check to see\n+    ** if pIdx is covering.  Assume it is not. *\/\n+    return 0;\n+  }\n+  if( pIdx->bHasExpr==0 ){\n+    for(i=0; i<pIdx->nColumn; i++){\n+      if( pIdx->aiColumn[i]>=BMS-1 ) break;\n+    }\n+    if( i>=pIdx->nColumn ){\n+      \/* pIdx does not index any columns greater than 62, but we know from\n+      ** colMask that columns greater than 62 are used, so this is not a\n+      ** covering index *\/\n+      return 0;\n+    }\n+  }\n+  ck.pIdx = pIdx;\n+  ck.iTabCur = iTabCur;\n+  ck.bExpr = 0;\n+  ck.bUnidx = 0;\n+  memset(&w, 0, sizeof(w));\n+  w.xExprCallback = whereIsCoveringIndexWalkCallback;\n+  w.xSelectCallback = sqlite3SelectWalkNoop;\n+  w.u.pCovIdxCk = &ck;\n+  sqlite3WalkSelect(&w, pWInfo->pSelect);\n+  if( ck.bUnidx ){\n+    rc = 0;\n+  }else if( ck.bExpr ){\n+    rc = WHERE_EXPRIDX;\n+  }else{\n+    rc = WHERE_IDX_ONLY;\n+  }\n+  return rc;\n+}\n+\n+\/*\n+** This is an sqlite3ParserAddCleanup() callback that is invoked to\n+** free the Parse->pIdxEpr list when the Parse object is destroyed.\n+*\/\n+static void whereIndexedExprCleanup(sqlite3 *db, void *pObject){\n+  IndexedExpr **pp = (IndexedExpr**)pObject;\n+  while( *pp!=0 ){\n+    IndexedExpr *p = *pp;\n+    *pp = p->pIENext;\n+    sqlite3ExprDelete(db, p->pExpr);\n+    sqlite3DbFreeNN(db, p);\n+  }\n+}\n+\n+\/*\n+** This function is called for a partial index - one with a WHERE clause - in\n+** two scenarios. In both cases, it determines whether or not the WHERE\n+** clause on the index implies that a column of the table may be safely\n+** replaced by a constant expression. For example, in the following\n+** SELECT:\n+**\n+**   CREATE INDEX i1 ON t1(b, c) WHERE a=<expr>;\n+**   SELECT a, b, c FROM t1 WHERE a=<expr> AND b=?;\n+**\n+** The \"a\" in the select-list may be replaced by <expr>, iff:\n+**\n+**    (a) <expr> is a constant expression, and\n+**    (b) The (a=<expr>) comparison uses the BINARY collation sequence, and\n+**    (c) Column \"a\" has an affinity other than NONE or BLOB.\n+**\n+** If argument pItem is NULL, then pMask must not be NULL. In this case this\n+** function is being called as part of determining whether or not pIdx\n+** is a covering index. This function clears any bits in (*pMask)\n+** corresponding to columns that may be replaced by constants as described\n+** above.\n+**\n+** Otherwise, if pItem is not NULL, then this function is being called\n+** as part of coding a loop that uses index pIdx. In this case, add entries\n+** to the Parse.pIdxPartExpr list for each column that can be replaced\n+** by a constant.\n+*\/\n+static void wherePartIdxExpr(\n+  Parse *pParse,                  \/* Parse context *\/\n+  Index *pIdx,                    \/* Partial index being processed *\/\n+  Expr *pPart,                    \/* WHERE clause being processed *\/\n+  Bitmask *pMask,                 \/* Mask to clear bits in *\/\n+  int iIdxCur,                    \/* Cursor number for index *\/\n+  SrcItem *pItem                  \/* The FROM clause entry for the table *\/\n+){\n+  assert( pItem==0 || (pItem->fg.jointype & JT_RIGHT)==0 );\n+  assert( (pItem==0 || pMask==0) && (pMask!=0 || pItem!=0) );\n+\n+  if( pPart->op==TK_AND ){\n+    wherePartIdxExpr(pParse, pIdx, pPart->pRight, pMask, iIdxCur, pItem);\n+    pPart = pPart->pLeft;\n+  }\n+\n+  if( (pPart->op==TK_EQ || pPart->op==TK_IS) ){\n+    Expr *pLeft = pPart->pLeft;\n+    Expr *pRight = pPart->pRight;\n+    u8 aff;\n+\n+    if( pLeft->op!=TK_COLUMN ) return;\n+    if( !sqlite3ExprIsConstant(pRight) ) return;\n+    if( !sqlite3IsBinary(sqlite3ExprCompareCollSeq(pParse, pPart)) ) return;\n+    if( pLeft->iColumn<0 ) return;\n+    aff = pIdx->pTable->aCol[pLeft->iColumn].affinity;\n+    if( aff>=SQLITE_AFF_TEXT ){\n+      if( pItem ){\n+        sqlite3 *db = pParse->db;\n+        IndexedExpr *p = (IndexedExpr*)sqlite3DbMallocRaw(db, sizeof(*p));\n+        if( p ){\n+          int bNullRow = (pItem->fg.jointype&(JT_LEFT|JT_LTORJ))!=0;\n+          p->pExpr = sqlite3ExprDup(db, pRight, 0);\n+          p->iDataCur = pItem->iCursor;\n+          p->iIdxCur = iIdxCur;\n+          p->iIdxCol = pLeft->iColumn;\n+          p->bMaybeNullRow = bNullRow;\n+          p->pIENext = pParse->pIdxPartExpr;\n+          p->aff = aff;\n+          pParse->pIdxPartExpr = p;\n+          if( p->pIENext==0 ){\n+            void *pArg = (void*)&pParse->pIdxPartExpr;\n+            sqlite3ParserAddCleanup(pParse, whereIndexedExprCleanup, pArg);\n+          }\n+        }\n+      }else if( pLeft->iColumn<(BMS-1) ){\n+        *pMask &= ~((Bitmask)1 << pLeft->iColumn);\n+      }\n+    }\n+  }\n+}\n+\n+\n@@ -157315,1 +164686,1 @@\n-  Bitmask mPrereq             \/* Extra prerequesites for using this table *\/\n+  Bitmask mPrereq             \/* Extra prerequisites for using this table *\/\n@@ -157359,1 +164730,1 @@\n-    sPk.szIdxRow = pTab->szTabRow;\n+    sPk.szIdxRow = 3;  \/* TUNING: Interior rows of IPK table are very small *\/\n@@ -157410,1 +164781,2 @@\n-          pNew->rSetup -= 10;\n+          pNew->rSetup -= 25;  \/* Greatly reduced setup cost for auto indexes\n+                               ** on ephemeral materializations of views *\/\n@@ -157487,1 +164859,0 @@\n-        pNew->wsFlags = WHERE_IDX_ONLY | WHERE_INDEXED;\n@@ -157489,0 +164860,1 @@\n+        pNew->wsFlags = WHERE_IDX_ONLY | WHERE_INDEXED;\n@@ -157491,1 +164863,33 @@\n-        pNew->wsFlags = (m==0) ? (WHERE_IDX_ONLY|WHERE_INDEXED) : WHERE_INDEXED;\n+        if( pProbe->pPartIdxWhere ){\n+          wherePartIdxExpr(\n+              pWInfo->pParse, pProbe, pProbe->pPartIdxWhere, &m, 0, 0\n+          );\n+        }\n+        pNew->wsFlags = WHERE_INDEXED;\n+        if( m==TOPBIT || (pProbe->bHasExpr && !pProbe->bHasVCol && m!=0) ){\n+          u32 isCov = whereIsCoveringIndex(pWInfo, pProbe, pSrc->iCursor);\n+          if( isCov==0 ){\n+            WHERETRACE(0x200,\n+               (\"-> %s is not a covering index\"\n+                \" according to whereIsCoveringIndex()\\n\", pProbe->zName));\n+            assert( m!=0 );\n+          }else{\n+            m = 0;\n+            pNew->wsFlags |= isCov;\n+            if( isCov & WHERE_IDX_ONLY ){\n+              WHERETRACE(0x200,\n+                 (\"-> %s is a covering expression index\"\n+                  \" according to whereIsCoveringIndex()\\n\", pProbe->zName));\n+            }else{\n+              assert( isCov==WHERE_EXPRIDX );\n+              WHERETRACE(0x200,\n+                 (\"-> %s might be a covering expression index\"\n+                  \" according to whereIsCoveringIndex()\\n\", pProbe->zName));\n+            }\n+          }\n+        }else if( m==0 ){\n+          WHERETRACE(0x200,\n+             (\"-> %s a covering index according to bitmasks\\n\",\n+             pProbe->zName, m==0 ? \"is\" : \"is not\"));\n+          pNew->wsFlags = WHERE_IDX_ONLY | WHERE_INDEXED;\n+        }\n@@ -157664,1 +165068,1 @@\n-      WHERETRACE(0xffff, (\"  ^^^^--- non-viable plan rejected!\\n\"));\n+      WHERETRACE(0xffffffff, (\"  ^^^^--- non-viable plan rejected!\\n\"));\n@@ -157775,1 +165179,1 @@\n-  WHERETRACE(0xffff, (\"  bIn=%d prereqIn=%04llx prereqOut=%04llx\\n\",\n+  WHERETRACE(0xffffffff, (\"  bIn=%d prereqIn=%04llx prereqOut=%04llx\\n\",\n@@ -157791,1 +165195,1 @@\n-**    1. If there is an explicit COLLATE operator on the constaint, return it.\n+**    1. If there is an explicit COLLATE operator on the constraint, return it.\n@@ -157846,1 +165250,1 @@\n-    rc = SQLITE_MISUSE; \/* EV: R-30545-25046 *\/\n+    rc = SQLITE_MISUSE_BKPT; \/* EV: R-30545-25046 *\/\n@@ -157876,2 +165280,0 @@\n-#if (defined(SQLITE_ENABLE_DBPAGE_VTAB) || defined(SQLITE_TEST)) \\\n-    && !defined(SQLITE_OMIT_VIRTUALTABLE)\n@@ -157880,1 +165282,1 @@\n-** xBestIndex to potentiall use all schemas.  If the statement being\n+** xBestIndex to potentially use all schemas.  If the statement being\n@@ -157887,3 +165289,1 @@\n-SQLITE_PRIVATE void sqlite3VtabUsesAllSchemas(sqlite3_index_info *pIdxInfo){\n-  HiddenIndexInfo *pHidden = (HiddenIndexInfo*)&pIdxInfo[1];\n-  Parse *pParse = pHidden->pParse;\n+SQLITE_PRIVATE void sqlite3VtabUsesAllSchemas(Parse *pParse){\n@@ -157895,1 +165295,1 @@\n-  if( pParse->writeMask ){\n+  if( DbMaskNonZero(pParse->writeMask) ){\n@@ -157901,1 +165301,0 @@\n-#endif\n@@ -157967,1 +165366,1 @@\n-  WHERETRACE(0x40, (\"  VirtualOne: all usable\\n\"));\n+  WHERETRACE(0x800, (\"  VirtualOne: all usable\\n\"));\n@@ -157992,1 +165391,1 @@\n-      WHERETRACE(0x40, (\"  VirtualOne: all usable w\/o IN\\n\"));\n+      WHERETRACE(0x800, (\"  VirtualOne: all usable w\/o IN\\n\"));\n@@ -158018,1 +165417,1 @@\n-      WHERETRACE(0x40, (\"  VirtualOne: mPrev=%04llx mNext=%04llx\\n\",\n+      WHERETRACE(0x800, (\"  VirtualOne: mPrev=%04llx mNext=%04llx\\n\",\n@@ -158032,1 +165431,1 @@\n-      WHERETRACE(0x40, (\"  VirtualOne: all disabled\\n\"));\n+      WHERETRACE(0x800, (\"  VirtualOne: all disabled\\n\"));\n@@ -158042,1 +165441,1 @@\n-      WHERETRACE(0x40, (\"  VirtualOne: all disabled and w\/o IN\\n\"));\n+      WHERETRACE(0x800, (\"  VirtualOne: all disabled and w\/o IN\\n\"));\n@@ -158098,1 +165497,1 @@\n-      WHERETRACE(0x200, (\"Begin processing OR-clause %p\\n\", pTerm));\n+      WHERETRACE(0x400, (\"Begin processing OR-clause %p\\n\", pTerm));\n@@ -158115,1 +165514,1 @@\n-        WHERETRACE(0x200, (\"OR-term %d of %p has %d subterms:\\n\",\n+        WHERETRACE(0x400, (\"OR-term %d of %p has %d subterms:\\n\",\n@@ -158117,1 +165516,1 @@\n-        if( sqlite3WhereTrace & 0x400 ){\n+        if( sqlite3WhereTrace & 0x20000 ){\n@@ -158132,2 +165531,0 @@\n-        assert( rc==SQLITE_OK || rc==SQLITE_DONE || sCur.n==0\n-                || rc==SQLITE_NOMEM );\n@@ -158179,1 +165576,1 @@\n-      WHERETRACE(0x200, (\"End processing OR-clause %p\\n\", pTerm));\n+      WHERETRACE(0x400, (\"End processing OR-clause %p\\n\", pTerm));\n@@ -158205,1 +165602,7 @@\n-  whereLoopInit(pNew);\n+\n+  \/* Verify that pNew has already been initialized *\/\n+  assert( pNew->nLTerm==0 );\n+  assert( pNew->wsFlags==0 );\n+  assert( pNew->nLSlot>=ArraySize(pNew->aLTermSpace) );\n+  assert( pNew->aLTerm!=0 );\n+\n@@ -158521,2 +165924,2 @@\n-            Expr *pIdxExpr = pIndex->aColExpr->a[j].pExpr;\n-            if( sqlite3ExprCompareSkip(pOBExpr, pIdxExpr, iCur) ){\n+            Expr *pIxExpr = pIndex->aColExpr->a[j].pExpr;\n+            if( sqlite3ExprCompareSkip(pOBExpr, pIxExpr, iCur) ){\n@@ -158654,4 +166057,4 @@\n-  WhereInfo *pWInfo,\n-  LogEst nRow,\n-  int nOrderBy,\n-  int nSorted\n+  WhereInfo *pWInfo, \/* Query planning context *\/\n+  LogEst nRow,       \/* Estimated number of rows to sort *\/\n+  int nOrderBy,      \/* Number of ORDER BY clause terms *\/\n+  int nSorted        \/* Number of initial ORDER BY terms naturally in order *\/\n@@ -158659,1 +166062,1 @@\n-  \/* TUNING: Estimated cost of a full external sort, where N is\n+  \/* Estimated cost of a full external sort, where N is\n@@ -158662,1 +166065,1 @@\n-  **   cost = (3.0 * N * log(N)).\n+  **   cost = (K * N * log(N)).\n@@ -158668,1 +166071,8 @@\n-  **   cost = (3.0 * N * log(N)) * (Y\/X)\n+  **   cost = (K * N * log(N)) * (Y\/X)\n+  **\n+  ** The constant K is at least 2.0 but will be larger if there are a\n+  ** large number of columns to be sorted, as the sorting time is\n+  ** proportional to the amount of content to be sorted.  The algorithm\n+  ** does not currently distinguish between fat columns (BLOBs and TEXTs)\n+  ** and skinny columns (INTs).  It just uses the number of columns as\n+  ** an approximation for the row width.\n@@ -158670,2 +166080,2 @@\n-  ** The (Y\/X) term is implemented using stack variable rScale\n-  ** below.\n+  ** And extra factor of 2.0 or 3.0 is added to the sorting cost if the sort\n+  ** is built using OP_IdxInsert and OP_Sort rather than with OP_SorterInsert.\n@@ -158673,4 +166083,10 @@\n-  LogEst rScale, rSortCost;\n-  assert( nOrderBy>0 && 66==sqlite3LogEst(100) );\n-  rScale = sqlite3LogEst((nOrderBy-nSorted)*100\/nOrderBy) - 66;\n-  rSortCost = nRow + rScale + 16;\n+  LogEst rSortCost, nCol;\n+  assert( pWInfo->pSelect!=0 );\n+  assert( pWInfo->pSelect->pEList!=0 );\n+  \/* TUNING: sorting cost proportional to the number of output columns: *\/\n+  nCol = sqlite3LogEst((pWInfo->pSelect->pEList->nExpr+59)\/30);\n+  rSortCost = nRow + nCol;\n+  if( nSorted>0 ){\n+    \/* Scale the result by (Y\/X) *\/\n+    rSortCost += sqlite3LogEst((nOrderBy-nSorted)*100\/nOrderBy) - 66;\n+  }\n@@ -158683,2 +166099,8 @@\n-  if( (pWInfo->wctrlFlags & WHERE_USE_LIMIT)!=0 && pWInfo->iLimit<nRow ){\n-    nRow = pWInfo->iLimit;\n+  if( (pWInfo->wctrlFlags & WHERE_USE_LIMIT)!=0 ){\n+    rSortCost += 10;       \/* TUNING: Extra 2.0x if using LIMIT *\/\n+    if( nSorted!=0 ){\n+      rSortCost += 6;      \/* TUNING: Extra 1.5x if also using partial sort *\/\n+    }\n+    if( pWInfo->iLimit<nRow ){\n+      nRow = pWInfo->iLimit;\n+    }\n@@ -158710,1 +166132,0 @@\n-  sqlite3 *db;              \/* The database connection *\/\n@@ -158729,1 +166150,0 @@\n-  db = pParse->db;\n@@ -158736,1 +166156,2 @@\n-  WHERETRACE(0x002, (\"---- begin solver.  (nRowEst=%d)\\n\", nRowEst));\n+  WHERETRACE(0x002, (\"---- begin solver.  (nRowEst=%d, nQueryLoop=%d)\\n\",\n+                     nRowEst, pParse->nQueryLoop));\n@@ -158752,1 +166173,1 @@\n-  pSpace = sqlite3DbMallocRawNN(db, nSpace);\n+  pSpace = sqlite3StackAllocRawNN(pParse->db, nSpace);\n@@ -158802,1 +166223,1 @@\n-        i8 isOrdered = pFrom->isOrdered;  \/* isOrdered for (pFrom+pWLoop) *\/\n+        i8 isOrdered;                     \/* isOrdered for (pFrom+pWLoop) *\/\n@@ -158804,1 +166225,1 @@\n-        Bitmask revMask = 0;              \/* Mask of rev-order loops for (..) *\/\n+        Bitmask revMask;                  \/* Mask of rev-order loops for (..) *\/\n@@ -158823,0 +166244,1 @@\n+        isOrdered = pFrom->isOrdered;\n@@ -158824,0 +166246,1 @@\n+          revMask = 0;\n@@ -158836,2 +166259,2 @@\n-          \/* TUNING:  Add a small extra penalty (5) to sorting as an\n-          ** extra encouragment to the query planner to select a plan\n+          \/* TUNING:  Add a small extra penalty (3) to sorting as an\n+          ** extra encouragement to the query planner to select a plan\n@@ -158840,1 +166263,1 @@\n-          rCost = sqlite3LogEstAdd(rUnsorted, aSortCost[isOrdered]) + 5;\n+          rCost = sqlite3LogEstAdd(rUnsorted, aSortCost[isOrdered]) + 3;\n@@ -159001,1 +166424,1 @@\n-    sqlite3DbFreeNN(db, pSpace);\n+    sqlite3StackFreeNN(pParse->db, pSpace);\n@@ -159037,0 +166460,4 @@\n+      if( pWInfo->pSelect->pOrderBy\n+       && pWInfo->nOBSat > pWInfo->pSelect->pOrderBy->nExpr ){\n+        pWInfo->nOBSat = pWInfo->pSelect->pOrderBy->nExpr;\n+      }\n@@ -159083,1 +166510,1 @@\n-  sqlite3DbFreeNN(db, pSpace);\n+  sqlite3StackFreeNN(pParse->db, pSpace);\n@@ -159181,1 +166608,1 @@\n-    if( sqlite3WhereTrace ){\n+    if( sqlite3WhereTrace & 0x02 ){\n@@ -159248,0 +166675,7 @@\n+**   5) The table must not have an inner-join ON or USING clause if there is\n+**      a RIGHT JOIN anywhere in the query.  Otherwise the ON\/USING clause\n+**      might move from the right side to the left side of the RIGHT JOIN.\n+**      Note: Due to (2), this condition can only arise if the table is\n+**      the right-most table of a subquery that was flattened into the\n+**      main query and that subquery was the right-hand operand of an\n+**      inner join that held an ON or USING clause.\n@@ -159273,0 +166707,1 @@\n+  int hasRightJoin;\n@@ -159287,0 +166722,1 @@\n+  hasRightJoin = (pWInfo->pTabList->a[0].fg.jointype & JT_LTORJ)!=0;\n@@ -159309,0 +166745,6 @@\n+      if( hasRightJoin\n+       && ExprHasProperty(pTerm->pExpr, EP_InnerON)\n+       && pTerm->pExpr->w.iJoin==pItem->iCursor\n+      ){\n+        break;  \/* restriction (5) *\/\n+      }\n@@ -159311,1 +166753,1 @@\n-    WHERETRACE(0xffff, (\"-> drop loop %c not used\\n\", pLoop->cId));\n+    WHERETRACE(0xffffffff, (\"-> drop loop %c not used\\n\", pLoop->cId));\n@@ -159350,1 +166792,1 @@\n-  LogEst nSearch;\n+  LogEst nSearch = 0;\n@@ -159354,2 +166796,1 @@\n-  nSearch = pWInfo->a[0].pWLoop->nOut;\n-  for(i=1; i<pWInfo->nLevel; i++){\n+  for(i=0; i<pWInfo->nLevel; i++){\n@@ -159358,1 +166799,6 @@\n-    if( (pLoop->wsFlags & reqFlags)==reqFlags\n+    SrcItem *pItem = &pWInfo->pTabList->a[pLoop->iTab];\n+    Table *pTab = pItem->pTab;\n+    if( (pTab->tabFlags & TF_HasStat1)==0 ) break;\n+    pTab->tabFlags |= TF_StatsUsed;\n+    if( i>=1\n+     && (pLoop->wsFlags & reqFlags)==reqFlags\n@@ -159362,6 +166808,1 @@\n-      SrcItem *pItem = &pWInfo->pTabList->a[pLoop->iTab];\n-      Table *pTab = pItem->pTab;\n-      pTab->tabFlags |= TF_StatsUsed;\n-      if( nSearch > pTab->nRowLogEst\n-       && (pTab->tabFlags & TF_HasStat1)!=0\n-      ){\n+      if( nSearch > pTab->nRowLogEst ){\n@@ -159371,1 +166812,1 @@\n-        WHERETRACE(0xffff, (\n+        WHERETRACE(0xffffffff, (\n@@ -159382,0 +166823,97 @@\n+\/*\n+** The index pIdx is used by a query and contains one or more expressions.\n+** In other words pIdx is an index on an expression.  iIdxCur is the cursor\n+** number for the index and iDataCur is the cursor number for the corresponding\n+** table.\n+**\n+** This routine adds IndexedExpr entries to the Parse->pIdxEpr field for\n+** each of the expressions in the index so that the expression code generator\n+** will know to replace occurrences of the indexed expression with\n+** references to the corresponding column of the index.\n+*\/\n+static SQLITE_NOINLINE void whereAddIndexedExpr(\n+  Parse *pParse,     \/* Add IndexedExpr entries to pParse->pIdxEpr *\/\n+  Index *pIdx,       \/* The index-on-expression that contains the expressions *\/\n+  int iIdxCur,       \/* Cursor number for pIdx *\/\n+  SrcItem *pTabItem  \/* The FROM clause entry for the table *\/\n+){\n+  int i;\n+  IndexedExpr *p;\n+  Table *pTab;\n+  assert( pIdx->bHasExpr );\n+  pTab = pIdx->pTable;\n+  for(i=0; i<pIdx->nColumn; i++){\n+    Expr *pExpr;\n+    int j = pIdx->aiColumn[i];\n+    if( j==XN_EXPR ){\n+      pExpr = pIdx->aColExpr->a[i].pExpr;\n+    }else if( j>=0 && (pTab->aCol[j].colFlags & COLFLAG_VIRTUAL)!=0 ){\n+      pExpr = sqlite3ColumnExpr(pTab, &pTab->aCol[j]);\n+    }else{\n+      continue;\n+    }\n+    if( sqlite3ExprIsConstant(pExpr) ) continue;\n+    if( pExpr->op==TK_FUNCTION ){\n+      \/* Functions that might set a subtype should not be replaced by the\n+      ** value taken from an expression index since the index omits the\n+      ** subtype.  https:\/\/sqlite.org\/forum\/forumpost\/68d284c86b082c3e *\/\n+      int n;\n+      FuncDef *pDef;\n+      sqlite3 *db = pParse->db;\n+      assert( ExprUseXList(pExpr) );\n+      n = pExpr->x.pList ? pExpr->x.pList->nExpr : 0;\n+      pDef = sqlite3FindFunction(db, pExpr->u.zToken, n, ENC(db), 0);\n+      if( pDef==0 || (pDef->funcFlags & SQLITE_RESULT_SUBTYPE)!=0 ){\n+        continue;\n+      }\n+    }\n+    p = sqlite3DbMallocRaw(pParse->db,  sizeof(IndexedExpr));\n+    if( p==0 ) break;\n+    p->pIENext = pParse->pIdxEpr;\n+#ifdef WHERETRACE_ENABLED\n+    if( sqlite3WhereTrace & 0x200 ){\n+      sqlite3DebugPrintf(\"New pParse->pIdxEpr term {%d,%d}\\n\", iIdxCur, i);\n+      if( sqlite3WhereTrace & 0x5000 ) sqlite3ShowExpr(pExpr);\n+    }\n+#endif\n+    p->pExpr = sqlite3ExprDup(pParse->db, pExpr, 0);\n+    p->iDataCur = pTabItem->iCursor;\n+    p->iIdxCur = iIdxCur;\n+    p->iIdxCol = i;\n+    p->bMaybeNullRow = (pTabItem->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))!=0;\n+    if( sqlite3IndexAffinityStr(pParse->db, pIdx) ){\n+      p->aff = pIdx->zColAff[i];\n+    }\n+#ifdef SQLITE_ENABLE_EXPLAIN_COMMENTS\n+    p->zIdxName = pIdx->zName;\n+#endif\n+    pParse->pIdxEpr = p;\n+    if( p->pIENext==0 ){\n+      void *pArg = (void*)&pParse->pIdxEpr;\n+      sqlite3ParserAddCleanup(pParse, whereIndexedExprCleanup, pArg);\n+    }\n+  }\n+}\n+\n+\/*\n+** Set the reverse-scan order mask to one for all tables in the query\n+** with the exception of MATERIALIZED common table expressions that have\n+** their own internal ORDER BY clauses.\n+**\n+** This implements the PRAGMA reverse_unordered_selects=ON setting.\n+** (Also SQLITE_DBCONFIG_REVERSE_SCANORDER).\n+*\/\n+static SQLITE_NOINLINE void whereReverseScanOrder(WhereInfo *pWInfo){\n+  int ii;\n+  for(ii=0; ii<pWInfo->pTabList->nSrc; ii++){\n+    SrcItem *pItem = &pWInfo->pTabList->a[ii];\n+    if( !pItem->fg.isCte\n+     || pItem->u2.pCteUse->eM10d!=M10d_Yes\n+     || NEVER(pItem->pSelect==0)\n+     || pItem->pSelect->pOrderBy==0\n+    ){\n+      pWInfo->revMask |= MASKBIT(ii);\n+    }\n+  }\n+}\n+\n@@ -159440,1 +166978,1 @@\n-** An outer join of tables t1 and t2 is conceptally coded as follows:\n+** An outer join of tables t1 and t2 is conceptually coded as follows:\n@@ -159476,1 +167014,1 @@\n-  Select *pLimit,         \/* Use this LIMIT\/OFFSET clause, if any *\/\n+  Select *pSelect,        \/* The entire SELECT statement *\/\n@@ -159510,1 +167048,4 @@\n-  if( pOrderBy && pOrderBy->nExpr>=BMS ) pOrderBy = 0;\n+  if( pOrderBy && pOrderBy->nExpr>=BMS ){\n+    pOrderBy = 0;\n+    wctrlFlags &= ~WHERE_WANT_DISTINCT;\n+  }\n@@ -159535,1 +167076,4 @@\n-  nByteWInfo = ROUND8P(sizeof(WhereInfo)+(nTabList-1)*sizeof(WhereLevel));\n+  nByteWInfo = ROUND8P(sizeof(WhereInfo));\n+  if( nTabList>1 ){\n+    nByteWInfo = ROUND8P(nByteWInfo + (nTabList-1)*sizeof(WhereLevel));\n+  }\n@@ -159545,0 +167089,1 @@\n+#if WHERETRACE_ENABLED\n@@ -159546,0 +167091,1 @@\n+#endif\n@@ -159553,3 +167099,1 @@\n-#ifndef SQLITE_OMIT_VIRTUALTABLE\n-  pWInfo->pLimit = pLimit;\n-#endif\n+  pWInfo->pSelect = pSelect;\n@@ -159595,1 +167139,1 @@\n-    ** The rule of the previous sentence ensures thta if X is the bitmask for\n+    ** The rule of the previous sentence ensures that if X is the bitmask for\n@@ -159624,1 +167168,3 @@\n-  sqlite3WhereAddLimit(&pWInfo->sWC, pLimit);\n+  if( pSelect && pSelect->pLimit ){\n+    sqlite3WhereAddLimit(&pWInfo->sWC, pSelect);\n+  }\n@@ -159627,3 +167173,1 @@\n-  \/* Special case: WHERE terms that do not refer to any tables in the join\n-  ** (constant expressions). Evaluate each such term, and jump over all the\n-  ** generated code if the result is not true.\n+  \/* The False-WHERE-Term-Bypass optimization:\n@@ -159631,3 +167175,2 @@\n-  ** Do not do this if the expression contains non-deterministic functions\n-  ** that are not within a sub-select. This is not strictly required, but\n-  ** preserves SQLite's legacy behaviour in the following two cases:\n+  ** If there are WHERE terms that are false, then no rows will be output,\n+  ** so skip over all of the code generated here.\n@@ -159635,2 +167178,20 @@\n-  **   FROM ... WHERE random()>0;           -- eval random() once per row\n-  **   FROM ... WHERE (SELECT random())>0;  -- eval random() once overall\n+  ** Conditions:\n+  **\n+  **   (1)  The WHERE term must not refer to any tables in the join.\n+  **   (2)  The term must not come from an ON clause on the\n+  **        right-hand side of a LEFT or FULL JOIN.\n+  **   (3)  The term must not come from an ON clause, or there must be\n+  **        no RIGHT or FULL OUTER joins in pTabList.\n+  **   (4)  If the expression contains non-deterministic functions\n+  **        that are not within a sub-select. This is not required\n+  **        for correctness but rather to preserves SQLite's legacy\n+  **        behaviour in the following two cases:\n+  **\n+  **          WHERE random()>0;           -- eval random() once per row\n+  **          WHERE (SELECT random())>0;  -- eval random() just once overall\n+  **\n+  ** Note that the Where term need not be a constant in order for this\n+  ** optimization to apply, though it does need to be constant relative to\n+  ** the current subquery (condition 1).  The term might include variables\n+  ** from outer queries so that the value of the term changes from one\n+  ** invocation of the current subquery to the next.\n@@ -159639,1 +167200,2 @@\n-    WhereTerm *pT = &sWLB.pWC->a[ii];\n+    WhereTerm *pT = &sWLB.pWC->a[ii];  \/* A term of the WHERE clause *\/\n+    Expr *pX;                          \/* The expression of pT *\/\n@@ -159641,2 +167203,9 @@\n-    if( pT->prereqAll==0 && (nTabList==0 || exprIsDeterministic(pT->pExpr)) ){\n-      sqlite3ExprIfFalse(pParse, pT->pExpr, pWInfo->iBreak, SQLITE_JUMPIFNULL);\n+    pX = pT->pExpr;\n+    assert( pX!=0 );\n+    assert( pT->prereqAll!=0 || !ExprHasProperty(pX, EP_OuterON) );\n+    if( pT->prereqAll==0                           \/* Conditions (1) and (2) *\/\n+     && (nTabList==0 || exprIsDeterministic(pX))   \/* Condition (4) *\/\n+     && !(ExprHasProperty(pX, EP_InnerON)          \/* Condition (3) *\/\n+          && (pTabList->a[0].fg.jointype & JT_LTORJ)!=0 )\n+    ){\n+      sqlite3ExprIfFalse(pParse, pX, pWInfo->iBreak, SQLITE_JUMPIFNULL);\n@@ -159665,1 +167234,1 @@\n-  if( sqlite3WhereTrace & 0xffff ){\n+  if( sqlite3WhereTrace & 0xffffffff ){\n@@ -159671,1 +167240,1 @@\n-    if( sqlite3WhereTrace & 0x100 ){\n+    if( sqlite3WhereTrace & 0x8000 ){\n@@ -159681,4 +167250,4 @@\n-  }\n-  if( sqlite3WhereTrace & 0x100 ){ \/* Display all terms of the WHERE clause *\/\n-    sqlite3DebugPrintf(\"---- WHERE clause at start of analysis:\\n\");\n-    sqlite3WhereClausePrint(sWLB.pWC);\n+    if( sqlite3WhereTrace & 0x4000 ){ \/* Display all WHERE clause terms *\/\n+      sqlite3DebugPrintf(\"---- WHERE clause at start of analysis:\\n\");\n+      sqlite3WhereClausePrint(sWLB.pWC);\n+    }\n@@ -159700,1 +167269,1 @@\n-      WHERETRACE(0xffff,\n+      WHERETRACE(0xffffffff,\n@@ -159720,0 +167289,10 @@\n+\n+    \/* TUNING:  Assume that a DISTINCT clause on a subquery reduces\n+    ** the output size by a factor of 8 (LogEst -30).\n+    *\/\n+    if( (pWInfo->wctrlFlags & WHERE_WANT_DISTINCT)!=0 ){\n+      WHERETRACE(0x0080,(\"nRowOut reduced from %d to %d due to DISTINCT\\n\",\n+                         pWInfo->nRowOut, pWInfo->nRowOut-30));\n+      pWInfo->nRowOut -= 30;\n+    }\n+\n@@ -159721,0 +167300,1 @@\n+  assert( pWInfo->pTabList!=0 );\n@@ -159722,1 +167302,1 @@\n-     pWInfo->revMask = ALLBITS;\n+    whereReverseScanOrder(pWInfo);\n@@ -159786,1 +167366,1 @@\n-  if( sqlite3WhereTrace & 0x100 ){ \/* Display all terms of the WHERE clause *\/\n+  if( sqlite3WhereTrace & 0x4000 ){ \/* Display all terms of the WHERE clause *\/\n@@ -159790,1 +167370,1 @@\n-  WHERETRACE(0xffff,(\"*** Optimizer Finished ***\\n\"));\n+  WHERETRACE(0xffffffff,(\"*** Optimizer Finished ***\\n\"));\n@@ -159822,0 +167402,1 @@\n+     && OptimizationEnabled(db, SQLITE_OnePass)\n@@ -159885,1 +167466,1 @@\n-      if( pLoop->u.btree.pIndex!=0 ){\n+      if( pLoop->u.btree.pIndex!=0 && (pTab->tabFlags & TF_WithoutRowid)==0 ){\n@@ -159927,0 +167508,8 @@\n+        if( pIx->bHasExpr && OptimizationEnabled(db, SQLITE_IndexedExpr) ){\n+          whereAddIndexedExpr(pParse, pIx, iIndexCur, pTabItem);\n+        }\n+        if( pIx->pPartIdxWhere && (pTabItem->fg.jointype & JT_RIGHT)==0 ){\n+          wherePartIdxExpr(\n+              pParse, pIx, pIx->pPartIdxWhere, 0, iIndexCur, pTabItem\n+          );\n+        }\n@@ -160019,0 +167608,1 @@\n+    assert( pTabList == pWInfo->pTabList );\n@@ -160022,2 +167612,1 @@\n-        constructAutomaticIndex(pParse, &pWInfo->sWC,\n-                  &pTabList->a[pLevel->iFrom], notReady, pLevel);\n+        constructAutomaticIndex(pParse, &pWInfo->sWC, notReady, pLevel);\n@@ -160049,2 +167638,0 @@\n-    testcase( pWInfo->pExprMods!=0 );\n-    whereUndoExprMods(pWInfo);\n@@ -160054,0 +167641,5 @@\n+#ifdef WHERETRACE_ENABLED\n+  \/* Prevent harmless compiler warnings about debugging routines\n+  ** being declared but never used *\/\n+  sqlite3ShowWhereLoopList(0);\n+#endif \/* WHERETRACE_ENABLED *\/\n@@ -160269,1 +167861,0 @@\n-  if( pWInfo->pExprMods ) whereUndoExprMods(pWInfo);\n@@ -160323,0 +167914,17 @@\n+      if( pIdx->bHasExpr ){\n+        IndexedExpr *p = pParse->pIdxEpr;\n+        while( p ){\n+          if( p->iIdxCur==pLevel->iIdxCur ){\n+#ifdef WHERETRACE_ENABLED\n+            if( sqlite3WhereTrace & 0x200 ){\n+              sqlite3DebugPrintf(\"Disable pParse->pIdxEpr term {%d,%d}\\n\",\n+                                  p->iIdxCur, p->iIdxCol);\n+              if( sqlite3WhereTrace & 0x5000 ) sqlite3ShowExpr(p->pExpr);\n+            }\n+#endif\n+            p->iDataCur = -1;\n+            p->iIdxCur = -1;\n+          }\n+          p = p->pIENext;\n+        }\n+      }\n@@ -160326,1 +167934,2 @@\n-        printf(\"TRANSLATE opcodes in range %d..%d\\n\", k, last-1);\n+        printf(\"TRANSLATE cursor %d->%d in opcode range %d..%d\\n\",\n+                pLevel->iTabCur, pLevel->iIdxCur, k, last-1);\n@@ -160533,1 +168142,1 @@\n-**   can be used as either aggregates or window funtions) allows them to\n+**   can be used as either aggregates or window functions) allows them to\n@@ -161063,1 +168672,1 @@\n-**   * If the OVER clause refered to a named window (as in \"max(x) OVER win\"),\n+**   * If the OVER clause referred to a named window (as in \"max(x) OVER win\"),\n@@ -161201,0 +168810,1 @@\n+    case TK_IF_NULL_ROW:\n@@ -161316,1 +168926,0 @@\n-      assert( pDup==0 || !ExprHasProperty(pDup, EP_MemToken) );\n@@ -161454,1 +169063,1 @@\n-      if( pWin->pWFunc->funcFlags & SQLITE_FUNC_SUBTYPE ){\n+      if( pWin->pWFunc->funcFlags & SQLITE_SUBTYPE ){\n@@ -161486,1 +169095,1 @@\n-    SELECTTRACE(1,pParse,pSub,\n+    TREETRACE(0x40,pParse,pSub,\n@@ -161496,0 +169105,1 @@\n+      p->pSrc->a[0].fg.isCorrelated = 1;\n@@ -161683,1 +169293,1 @@\n-** Window *pWin has just been created from a WINDOW clause. Tokne pBase\n+** Window *pWin has just been created from a WINDOW clause. Token pBase\n@@ -161727,0 +169337,1 @@\n+    assert( ExprIsFullSize(p) );\n@@ -161728,1 +169339,1 @@\n-    ExprSetProperty(p, EP_WinFunc);\n+    ExprSetProperty(p, EP_WinFunc|EP_FullSize);\n@@ -161989,1 +169600,1 @@\n-**   The windows functions implmentation caches the input rows in a temp\n+**   The windows functions implementation caches the input rows in a temp\n@@ -162587,4 +170198,3 @@\n-    sqlite3VdbeAddOp2(v, OP_IsNull, reg2, lbl); VdbeCoverage(v);\n-    if( op==OP_Gt || op==OP_Ge ){\n-      sqlite3VdbeChangeP2(v, -1, addrDone);\n-    }\n+    sqlite3VdbeAddOp2(v, OP_IsNull, reg2,\n+                      (op==OP_Gt || op==OP_Ge) ? addrDone : lbl);\n+    VdbeCoverage(v);\n@@ -162999,1 +170609,1 @@\n-** CURRENT ROW by assuming that it is equivilent to \"0 PRECEDING\/FOLLOWING\".\n+** CURRENT ROW by assuming that it is equivalent to \"0 PRECEDING\/FOLLOWING\".\n@@ -163278,1 +170888,1 @@\n-  ** samve values in record form, and the rowid used to insert said record\n+  ** same values in record form, and the rowid used to insert said record\n@@ -163362,2 +170972,1 @@\n-    sqlite3VdbeAddOp2(v, OP_Rewind, s.current.csr, 1);\n-    VdbeCoverageNeverTaken(v);\n+    sqlite3VdbeAddOp1(v, OP_Rewind, s.current.csr);\n@@ -163375,2 +170984,1 @@\n-    sqlite3VdbeAddOp2(v, OP_Rewind, s.start.csr, 1);\n-    VdbeCoverageNeverTaken(v);\n+    sqlite3VdbeAddOp1(v, OP_Rewind, s.start.csr);\n@@ -163378,4 +170986,2 @@\n-  sqlite3VdbeAddOp2(v, OP_Rewind, s.current.csr, 1);\n-  VdbeCoverageNeverTaken(v);\n-  sqlite3VdbeAddOp2(v, OP_Rewind, s.end.csr, 1);\n-  VdbeCoverageNeverTaken(v);\n+  sqlite3VdbeAddOp1(v, OP_Rewind, s.current.csr);\n+  sqlite3VdbeAddOp1(v, OP_Rewind, s.end.csr);\n@@ -163523,1 +171129,2 @@\n-** source file \"parse.y\". *\/\n+** source file \"parse.y\".\n+*\/\n@@ -163540,1 +171147,1 @@\n-** implementation of a parser for the given grammer.  You might be reading\n+** implementation of a parser for the given grammar.  You might be reading\n@@ -164034,1 +171641,1 @@\n-#define YYNSTATE             576\n+#define YYNSTATE             579\n@@ -164036,1 +171643,1 @@\n-#define YYNRULE_WITH_ACTION  342\n+#define YYNRULE_WITH_ACTION  340\n@@ -164038,8 +171645,8 @@\n-#define YY_MAX_SHIFT         575\n-#define YY_MIN_SHIFTREDUCE   835\n-#define YY_MAX_SHIFTREDUCE   1239\n-#define YY_ERROR_ACTION      1240\n-#define YY_ACCEPT_ACTION     1241\n-#define YY_NO_ACTION         1242\n-#define YY_MIN_REDUCE        1243\n-#define YY_MAX_REDUCE        1647\n+#define YY_MAX_SHIFT         578\n+#define YY_MIN_SHIFTREDUCE   838\n+#define YY_MAX_SHIFTREDUCE   1242\n+#define YY_ERROR_ACTION      1243\n+#define YY_ACCEPT_ACTION     1244\n+#define YY_NO_ACTION         1245\n+#define YY_MIN_REDUCE        1246\n+#define YY_MAX_REDUCE        1650\n@@ -164112,1 +171719,1 @@\n-#define YY_ACTTAB_COUNT (2098)\n+#define YY_ACTTAB_COUNT (2100)\n@@ -164114,210 +171721,210 @@\n- \/*     0 *\/   568,  208,  568,  118,  115,  229,  568,  118,  115,  229,\n- \/*    10 *\/   568, 1314,  377, 1293,  408,  562,  562,  562,  568,  409,\n- \/*    20 *\/   378, 1314, 1276,   41,   41,   41,   41,  208, 1526,   71,\n- \/*    30 *\/    71,  971,  419,   41,   41,  491,  303,  279,  303,  972,\n- \/*    40 *\/   397,   71,   71,  125,  126,   80, 1217, 1217, 1050, 1053,\n- \/*    50 *\/  1040, 1040,  123,  123,  124,  124,  124,  124,  476,  409,\n- \/*    60 *\/  1241,    1,    1,  575,    2, 1245,  550,  118,  115,  229,\n- \/*    70 *\/   317,  480,  146,  480,  524,  118,  115,  229,  529, 1327,\n- \/*    80 *\/   417,  523,  142,  125,  126,   80, 1217, 1217, 1050, 1053,\n- \/*    90 *\/  1040, 1040,  123,  123,  124,  124,  124,  124,  118,  115,\n- \/*   100 *\/   229,  327,  122,  122,  122,  122,  121,  121,  120,  120,\n- \/*   110 *\/   120,  119,  116,  444,  284,  284,  284,  284,  442,  442,\n- \/*   120 *\/   442, 1567,  376, 1569, 1192,  375, 1163,  565, 1163,  565,\n- \/*   130 *\/   409, 1567,  537,  259,  226,  444,  101,  145,  449,  316,\n- \/*   140 *\/   559,  240,  122,  122,  122,  122,  121,  121,  120,  120,\n- \/*   150 *\/   120,  119,  116,  444,  125,  126,   80, 1217, 1217, 1050,\n- \/*   160 *\/  1053, 1040, 1040,  123,  123,  124,  124,  124,  124,  142,\n- \/*   170 *\/   294, 1192,  339,  448,  120,  120,  120,  119,  116,  444,\n- \/*   180 *\/   127, 1192, 1193, 1194,  148,  441,  440,  568,  119,  116,\n- \/*   190 *\/   444,  124,  124,  124,  124,  117,  122,  122,  122,  122,\n- \/*   200 *\/   121,  121,  120,  120,  120,  119,  116,  444,  454,  113,\n- \/*   210 *\/    13,   13,  546,  122,  122,  122,  122,  121,  121,  120,\n- \/*   220 *\/   120,  120,  119,  116,  444,  422,  316,  559, 1192, 1193,\n- \/*   230 *\/  1194,  149, 1224,  409, 1224,  124,  124,  124,  124,  122,\n- \/*   240 *\/   122,  122,  122,  121,  121,  120,  120,  120,  119,  116,\n- \/*   250 *\/   444,  465,  342, 1037, 1037, 1051, 1054,  125,  126,   80,\n- \/*   260 *\/  1217, 1217, 1050, 1053, 1040, 1040,  123,  123,  124,  124,\n- \/*   270 *\/   124,  124, 1279,  522,  222, 1192,  568,  409,  224,  514,\n- \/*   280 *\/   175,   82,   83,  122,  122,  122,  122,  121,  121,  120,\n- \/*   290 *\/   120,  120,  119,  116,  444, 1007,   16,   16, 1192,  133,\n- \/*   300 *\/   133,  125,  126,   80, 1217, 1217, 1050, 1053, 1040, 1040,\n- \/*   310 *\/   123,  123,  124,  124,  124,  124,  122,  122,  122,  122,\n- \/*   320 *\/   121,  121,  120,  120,  120,  119,  116,  444, 1041,  546,\n- \/*   330 *\/  1192,  373, 1192, 1193, 1194,  252, 1434,  399,  504,  501,\n- \/*   340 *\/   500,  111,  560,  566,    4,  926,  926,  433,  499,  340,\n- \/*   350 *\/   460,  328,  360,  394, 1237, 1192, 1193, 1194,  563,  568,\n- \/*   360 *\/   122,  122,  122,  122,  121,  121,  120,  120,  120,  119,\n- \/*   370 *\/   116,  444,  284,  284,  369, 1580, 1607,  441,  440,  154,\n- \/*   380 *\/   409,  445,   71,   71, 1286,  565, 1221, 1192, 1193, 1194,\n- \/*   390 *\/    85, 1223,  271,  557,  543,  515, 1561,  568,   98, 1222,\n- \/*   400 *\/     6, 1278,  472,  142,  125,  126,   80, 1217, 1217, 1050,\n- \/*   410 *\/  1053, 1040, 1040,  123,  123,  124,  124,  124,  124,  550,\n- \/*   420 *\/    13,   13, 1027,  507, 1224, 1192, 1224,  549,  109,  109,\n- \/*   430 *\/   222,  568, 1238,  175,  568,  427,  110,  197,  445,  570,\n- \/*   440 *\/   569,  430, 1552, 1017,  325,  551, 1192,  270,  287,  368,\n- \/*   450 *\/   510,  363,  509,  257,   71,   71,  543,   71,   71,  359,\n- \/*   460 *\/   316,  559, 1613,  122,  122,  122,  122,  121,  121,  120,\n- \/*   470 *\/   120,  120,  119,  116,  444, 1017, 1017, 1019, 1020,   27,\n- \/*   480 *\/   284,  284, 1192, 1193, 1194, 1158,  568, 1612,  409,  901,\n- \/*   490 *\/   190,  550,  356,  565,  550,  937,  533,  517, 1158,  516,\n- \/*   500 *\/   413, 1158,  552, 1192, 1193, 1194,  568,  544, 1554,   51,\n- \/*   510 *\/    51,  214,  125,  126,   80, 1217, 1217, 1050, 1053, 1040,\n- \/*   520 *\/  1040,  123,  123,  124,  124,  124,  124, 1192,  474,  135,\n- \/*   530 *\/   135,  409,  284,  284, 1490,  505,  121,  121,  120,  120,\n- \/*   540 *\/   120,  119,  116,  444, 1007,  565,  518,  217,  541, 1561,\n- \/*   550 *\/   316,  559,  142,    6,  532,  125,  126,   80, 1217, 1217,\n- \/*   560 *\/  1050, 1053, 1040, 1040,  123,  123,  124,  124,  124,  124,\n- \/*   570 *\/  1555,  122,  122,  122,  122,  121,  121,  120,  120,  120,\n- \/*   580 *\/   119,  116,  444,  485, 1192, 1193, 1194,  482,  281, 1267,\n- \/*   590 *\/   957,  252, 1192,  373,  504,  501,  500, 1192,  340,  571,\n- \/*   600 *\/  1192,  571,  409,  292,  499,  957,  876,  191,  480,  316,\n- \/*   610 *\/   559,  384,  290,  380,  122,  122,  122,  122,  121,  121,\n- \/*   620 *\/   120,  120,  120,  119,  116,  444,  125,  126,   80, 1217,\n- \/*   630 *\/  1217, 1050, 1053, 1040, 1040,  123,  123,  124,  124,  124,\n- \/*   640 *\/   124,  409,  394, 1136, 1192,  869,  100,  284,  284, 1192,\n- \/*   650 *\/  1193, 1194,  373, 1093, 1192, 1193, 1194, 1192, 1193, 1194,\n- \/*   660 *\/   565,  455,   32,  373,  233,  125,  126,   80, 1217, 1217,\n- \/*   670 *\/  1050, 1053, 1040, 1040,  123,  123,  124,  124,  124,  124,\n- \/*   680 *\/  1433,  959,  568,  228,  958,  122,  122,  122,  122,  121,\n- \/*   690 *\/   121,  120,  120,  120,  119,  116,  444, 1158,  228, 1192,\n- \/*   700 *\/   157, 1192, 1193, 1194, 1553,   13,   13,  301,  957, 1232,\n- \/*   710 *\/  1158,  153,  409, 1158,  373, 1583, 1176,    5,  369, 1580,\n- \/*   720 *\/   429, 1238,    3,  957,  122,  122,  122,  122,  121,  121,\n- \/*   730 *\/   120,  120,  120,  119,  116,  444,  125,  126,   80, 1217,\n- \/*   740 *\/  1217, 1050, 1053, 1040, 1040,  123,  123,  124,  124,  124,\n- \/*   750 *\/   124,  409,  208,  567, 1192, 1028, 1192, 1193, 1194, 1192,\n- \/*   760 *\/   388,  852,  155, 1552,  286,  402, 1098, 1098,  488,  568,\n- \/*   770 *\/   465,  342, 1319, 1319, 1552,  125,  126,   80, 1217, 1217,\n- \/*   780 *\/  1050, 1053, 1040, 1040,  123,  123,  124,  124,  124,  124,\n- \/*   790 *\/   129,  568,   13,   13,  374,  122,  122,  122,  122,  121,\n- \/*   800 *\/   121,  120,  120,  120,  119,  116,  444,  302,  568,  453,\n- \/*   810 *\/   528, 1192, 1193, 1194,   13,   13, 1192, 1193, 1194, 1297,\n- \/*   820 *\/   463, 1267,  409, 1317, 1317, 1552, 1012,  453,  452,  200,\n- \/*   830 *\/   299,   71,   71, 1265,  122,  122,  122,  122,  121,  121,\n- \/*   840 *\/   120,  120,  120,  119,  116,  444,  125,  126,   80, 1217,\n- \/*   850 *\/  1217, 1050, 1053, 1040, 1040,  123,  123,  124,  124,  124,\n- \/*   860 *\/   124,  409,  227, 1073, 1158,  284,  284,  419,  312,  278,\n- \/*   870 *\/   278,  285,  285, 1419,  406,  405,  382, 1158,  565,  568,\n- \/*   880 *\/  1158, 1196,  565, 1600,  565,  125,  126,   80, 1217, 1217,\n- \/*   890 *\/  1050, 1053, 1040, 1040,  123,  123,  124,  124,  124,  124,\n- \/*   900 *\/   453, 1482,   13,   13, 1536,  122,  122,  122,  122,  121,\n- \/*   910 *\/   121,  120,  120,  120,  119,  116,  444,  201,  568,  354,\n- \/*   920 *\/  1586,  575,    2, 1245,  840,  841,  842, 1562,  317, 1212,\n- \/*   930 *\/   146,    6,  409,  255,  254,  253,  206, 1327,    9, 1196,\n- \/*   940 *\/   262,   71,   71,  424,  122,  122,  122,  122,  121,  121,\n- \/*   950 *\/   120,  120,  120,  119,  116,  444,  125,  126,   80, 1217,\n- \/*   960 *\/  1217, 1050, 1053, 1040, 1040,  123,  123,  124,  124,  124,\n- \/*   970 *\/   124,  568,  284,  284,  568, 1213,  409,  574,  313, 1245,\n- \/*   980 *\/   349, 1296,  352,  419,  317,  565,  146,  491,  525, 1643,\n- \/*   990 *\/   395,  371,  491, 1327,   70,   70, 1295,   71,   71,  240,\n- \/*  1000 *\/  1325,  104,   80, 1217, 1217, 1050, 1053, 1040, 1040,  123,\n- \/*  1010 *\/   123,  124,  124,  124,  124,  122,  122,  122,  122,  121,\n- \/*  1020 *\/   121,  120,  120,  120,  119,  116,  444, 1114,  284,  284,\n- \/*  1030 *\/   428,  448, 1525, 1213,  439,  284,  284, 1489, 1352,  311,\n- \/*  1040 *\/   474,  565, 1115,  971,  491,  491,  217, 1263,  565, 1538,\n- \/*  1050 *\/   568,  972,  207,  568, 1027,  240,  383, 1116,  519,  122,\n- \/*  1060 *\/   122,  122,  122,  121,  121,  120,  120,  120,  119,  116,\n- \/*  1070 *\/   444, 1018,  107,   71,   71, 1017,   13,   13,  912,  568,\n- \/*  1080 *\/  1495,  568,  284,  284,   97,  526,  491,  448,  913, 1326,\n- \/*  1090 *\/  1322,  545,  409,  284,  284,  565,  151,  209, 1495, 1497,\n- \/*  1100 *\/   262,  450,   55,   55,   56,   56,  565, 1017, 1017, 1019,\n- \/*  1110 *\/   443,  332,  409,  527,   12,  295,  125,  126,   80, 1217,\n- \/*  1120 *\/  1217, 1050, 1053, 1040, 1040,  123,  123,  124,  124,  124,\n- \/*  1130 *\/   124,  347,  409,  864, 1534, 1213,  125,  126,   80, 1217,\n- \/*  1140 *\/  1217, 1050, 1053, 1040, 1040,  123,  123,  124,  124,  124,\n- \/*  1150 *\/   124, 1137, 1641,  474, 1641,  371,  125,  114,   80, 1217,\n- \/*  1160 *\/  1217, 1050, 1053, 1040, 1040,  123,  123,  124,  124,  124,\n- \/*  1170 *\/   124, 1495,  329,  474,  331,  122,  122,  122,  122,  121,\n- \/*  1180 *\/   121,  120,  120,  120,  119,  116,  444,  203, 1419,  568,\n- \/*  1190 *\/  1294,  864,  464, 1213,  436,  122,  122,  122,  122,  121,\n- \/*  1200 *\/   121,  120,  120,  120,  119,  116,  444,  553, 1137, 1642,\n- \/*  1210 *\/   539, 1642,   15,   15,  892,  122,  122,  122,  122,  121,\n- \/*  1220 *\/   121,  120,  120,  120,  119,  116,  444,  568,  298,  538,\n- \/*  1230 *\/  1135, 1419, 1559, 1560, 1331,  409,    6,    6, 1169, 1268,\n- \/*  1240 *\/   415,  320,  284,  284, 1419,  508,  565,  525,  300,  457,\n- \/*  1250 *\/    43,   43,  568,  893,   12,  565,  330,  478,  425,  407,\n- \/*  1260 *\/   126,   80, 1217, 1217, 1050, 1053, 1040, 1040,  123,  123,\n- \/*  1270 *\/   124,  124,  124,  124,  568,   57,   57,  288, 1192, 1419,\n- \/*  1280 *\/   496,  458,  392,  392,  391,  273,  389, 1135, 1558,  849,\n- \/*  1290 *\/  1169,  407,    6,  568,  321, 1158,  470,   44,   44, 1557,\n- \/*  1300 *\/  1114,  426,  234,    6,  323,  256,  540,  256, 1158,  431,\n- \/*  1310 *\/   568, 1158,  322,   17,  487, 1115,   58,   58,  122,  122,\n- \/*  1320 *\/   122,  122,  121,  121,  120,  120,  120,  119,  116,  444,\n- \/*  1330 *\/  1116,  216,  481,   59,   59, 1192, 1193, 1194,  111,  560,\n- \/*  1340 *\/   324,    4,  236,  456,  526,  568,  237,  456,  568,  437,\n- \/*  1350 *\/   168,  556,  420,  141,  479,  563,  568,  293,  568, 1095,\n- \/*  1360 *\/   568,  293,  568, 1095,  531,  568,  872,    8,   60,   60,\n- \/*  1370 *\/   235,   61,   61,  568,  414,  568,  414,  568,  445,   62,\n- \/*  1380 *\/    62,   45,   45,   46,   46,   47,   47,  199,   49,   49,\n- \/*  1390 *\/   557,  568,  359,  568,  100,  486,   50,   50,   63,   63,\n- \/*  1400 *\/    64,   64,  561,  415,  535,  410,  568, 1027,  568,  534,\n- \/*  1410 *\/   316,  559,  316,  559,   65,   65,   14,   14,  568, 1027,\n- \/*  1420 *\/   568,  512,  932,  872, 1018,  109,  109,  931, 1017,   66,\n- \/*  1430 *\/    66,  131,  131,  110,  451,  445,  570,  569,  416,  177,\n- \/*  1440 *\/  1017,  132,  132,   67,   67,  568,  467,  568,  932,  471,\n- \/*  1450 *\/  1364,  283,  226,  931,  315, 1363,  407,  568,  459,  407,\n- \/*  1460 *\/  1017, 1017, 1019,  239,  407,   86,  213, 1350,   52,   52,\n- \/*  1470 *\/    68,   68, 1017, 1017, 1019, 1020,   27, 1585, 1180,  447,\n- \/*  1480 *\/    69,   69,  288,   97,  108, 1541,  106,  392,  392,  391,\n- \/*  1490 *\/   273,  389,  568,  879,  849,  883,  568,  111,  560,  466,\n- \/*  1500 *\/     4,  568,  152,   30,   38,  568, 1132,  234,  396,  323,\n- \/*  1510 *\/   111,  560,  527,    4,  563,   53,   53,  322,  568,  163,\n- \/*  1520 *\/   163,  568,  337,  468,  164,  164,  333,  563,   76,   76,\n- \/*  1530 *\/   568,  289, 1514,  568,   31, 1513,  568,  445,  338,  483,\n- \/*  1540 *\/   100,   54,   54,  344,   72,   72,  296,  236, 1080,  557,\n- \/*  1550 *\/   445,  879, 1360,  134,  134,  168,   73,   73,  141,  161,\n- \/*  1560 *\/   161, 1574,  557,  535,  568,  319,  568,  348,  536, 1009,\n- \/*  1570 *\/   473,  261,  261,  891,  890,  235,  535,  568, 1027,  568,\n- \/*  1580 *\/   475,  534,  261,  367,  109,  109,  521,  136,  136,  130,\n- \/*  1590 *\/   130, 1027,  110,  366,  445,  570,  569,  109,  109, 1017,\n- \/*  1600 *\/   162,  162,  156,  156,  568,  110, 1080,  445,  570,  569,\n- \/*  1610 *\/   410,  351, 1017,  568,  353,  316,  559,  568,  343,  568,\n- \/*  1620 *\/   100,  497,  357,  258,  100,  898,  899,  140,  140,  355,\n- \/*  1630 *\/  1310, 1017, 1017, 1019, 1020,   27,  139,  139,  362,  451,\n- \/*  1640 *\/   137,  137,  138,  138, 1017, 1017, 1019, 1020,   27, 1180,\n- \/*  1650 *\/   447,  568,  372,  288,  111,  560, 1021,    4,  392,  392,\n- \/*  1660 *\/   391,  273,  389,  568, 1141,  849,  568, 1076,  568,  258,\n- \/*  1670 *\/   492,  563,  568,  211,   75,   75,  555,  962,  234,  261,\n- \/*  1680 *\/   323,  111,  560,  929,    4,  113,   77,   77,  322,   74,\n- \/*  1690 *\/    74,   42,   42, 1373,  445,   48,   48, 1418,  563,  974,\n- \/*  1700 *\/   975, 1092, 1091, 1092, 1091,  862,  557,  150,  930, 1346,\n- \/*  1710 *\/   113, 1358,  554, 1424, 1021, 1275, 1266, 1254,  236, 1253,\n- \/*  1720 *\/  1255,  445, 1593, 1343,  308,  276,  168,  309,   11,  141,\n- \/*  1730 *\/   393,  310,  232,  557, 1405, 1027,  335,  291, 1400,  219,\n- \/*  1740 *\/   336,  109,  109,  936,  297, 1410,  235,  341,  477,  110,\n- \/*  1750 *\/   502,  445,  570,  569, 1393, 1409, 1017,  400, 1293,  365,\n- \/*  1760 *\/   223, 1486, 1027, 1485, 1355, 1356, 1354, 1353,  109,  109,\n- \/*  1770 *\/   204, 1596, 1232,  558,  265,  218,  110,  205,  445,  570,\n- \/*  1780 *\/   569,  410,  387, 1017, 1533,  179,  316,  559, 1017, 1017,\n- \/*  1790 *\/  1019, 1020,   27,  230, 1531, 1229,   79,  560,   85,    4,\n- \/*  1800 *\/   418,  215,  548,   81,   84,  188, 1406,  173,  181,  461,\n- \/*  1810 *\/   451,   35,  462,  563,  183, 1017, 1017, 1019, 1020,   27,\n- \/*  1820 *\/   184, 1491,  185,  186,  495,  242,   98,  398, 1412,   36,\n- \/*  1830 *\/  1411,  484,   91,  469,  401, 1414,  445,  192, 1480,  246,\n- \/*  1840 *\/  1502,  490,  346,  277,  248,  196,  493,  511,  557,  350,\n- \/*  1850 *\/  1256,  249,  250,  403, 1313, 1312,  111,  560,  432,    4,\n- \/*  1860 *\/  1311, 1304,   93, 1611,  883, 1610,  224,  404,  434,  520,\n- \/*  1870 *\/   263,  435, 1579,  563, 1283, 1282,  364, 1027,  306, 1281,\n- \/*  1880 *\/   264, 1609, 1565,  109,  109,  370, 1303,  307, 1564,  438,\n- \/*  1890 *\/   128,  110, 1378,  445,  570,  569,  445,  546, 1017,   10,\n- \/*  1900 *\/  1466,  105,  381, 1377,   34,  572,   99, 1336,  557,  314,\n- \/*  1910 *\/  1186,  530,  272,  274,  379,  210, 1335,  547,  385,  386,\n- \/*  1920 *\/   275,  573, 1251, 1246,  411,  412, 1518,  165,  178, 1519,\n- \/*  1930 *\/  1017, 1017, 1019, 1020,   27, 1517, 1516, 1027,   78,  147,\n- \/*  1940 *\/   166,  220,  221,  109,  109,  836,  304,  167,  446,  212,\n- \/*  1950 *\/   318,  110,  231,  445,  570,  569,  144, 1090, 1017, 1088,\n- \/*  1960 *\/   326,  180,  169, 1212,  182,  334,  238,  915,  241, 1104,\n- \/*  1970 *\/   187,  170,  171,  421,   87,   88,  423,  189,   89,   90,\n- \/*  1980 *\/   172, 1107,  243, 1103,  244,  158,   18,  245,  345,  247,\n- \/*  1990 *\/  1017, 1017, 1019, 1020,   27,  261, 1096,  193, 1226,  489,\n- \/*  2000 *\/   194,   37,  366,  851,  494,  251,  195,  506,   92,   19,\n- \/*  2010 *\/   498,  358,   20,  503,  881,  361,   94,  894,  305,  159,\n- \/*  2020 *\/   513,   39,   95, 1174,  160, 1056,  966, 1143,   96,  174,\n- \/*  2030 *\/  1142,  225,  280,  282,  198,  960,  113, 1164, 1160,  260,\n- \/*  2040 *\/    21,   22,   23, 1162, 1168, 1167, 1148,   24,   33,   25,\n- \/*  2050 *\/   202,  542,   26,  100, 1071,  102, 1057,  103,    7, 1055,\n- \/*  2060 *\/  1059, 1113, 1060, 1112,  266,  267,   28,   40,  390, 1022,\n- \/*  2070 *\/   863,  112,   29,  564, 1182, 1181,  268,  176,  143,  925,\n- \/*  2080 *\/  1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242,\n- \/*  2090 *\/  1242, 1242, 1242, 1242,  269, 1602, 1242, 1601,\n+ \/*     0 *\/   572,  210,  572,  119,  116,  231,  572,  119,  116,  231,\n+ \/*    10 *\/   572, 1317,  379, 1296,  410,  566,  566,  566,  572,  411,\n+ \/*    20 *\/   380, 1317, 1279,   42,   42,   42,   42,  210, 1529,   72,\n+ \/*    30 *\/    72,  974,  421,   42,   42,  495,  305,  281,  305,  975,\n+ \/*    40 *\/   399,   72,   72,  126,  127,   81, 1217, 1217, 1054, 1057,\n+ \/*    50 *\/  1044, 1044,  124,  124,  125,  125,  125,  125,  480,  411,\n+ \/*    60 *\/  1244,    1,    1,  578,    2, 1248,  554,  119,  116,  231,\n+ \/*    70 *\/   319,  484,  147,  484,  528,  119,  116,  231,  533, 1330,\n+ \/*    80 *\/   419,  527,  143,  126,  127,   81, 1217, 1217, 1054, 1057,\n+ \/*    90 *\/  1044, 1044,  124,  124,  125,  125,  125,  125,  119,  116,\n+ \/*   100 *\/   231,  329,  123,  123,  123,  123,  122,  122,  121,  121,\n+ \/*   110 *\/   121,  120,  117,  448,  286,  286,  286,  286,  446,  446,\n+ \/*   120 *\/   446, 1568,  378, 1570, 1193,  377, 1164,  569, 1164,  569,\n+ \/*   130 *\/   411, 1568,  541,  261,  228,  448,  102,  146,  453,  318,\n+ \/*   140 *\/   563,  242,  123,  123,  123,  123,  122,  122,  121,  121,\n+ \/*   150 *\/   121,  120,  117,  448,  126,  127,   81, 1217, 1217, 1054,\n+ \/*   160 *\/  1057, 1044, 1044,  124,  124,  125,  125,  125,  125,  143,\n+ \/*   170 *\/   296, 1193,  341,  452,  121,  121,  121,  120,  117,  448,\n+ \/*   180 *\/   128, 1193, 1194, 1193,  149,  445,  444,  572,  120,  117,\n+ \/*   190 *\/   448,  125,  125,  125,  125,  118,  123,  123,  123,  123,\n+ \/*   200 *\/   122,  122,  121,  121,  121,  120,  117,  448,  458,  114,\n+ \/*   210 *\/    13,   13,  550,  123,  123,  123,  123,  122,  122,  121,\n+ \/*   220 *\/   121,  121,  120,  117,  448,  424,  318,  563, 1193, 1194,\n+ \/*   230 *\/  1193,  150, 1225,  411, 1225,  125,  125,  125,  125,  123,\n+ \/*   240 *\/   123,  123,  123,  122,  122,  121,  121,  121,  120,  117,\n+ \/*   250 *\/   448,  469,  344, 1041, 1041, 1055, 1058,  126,  127,   81,\n+ \/*   260 *\/  1217, 1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,\n+ \/*   270 *\/   125,  125, 1282,  526,  224, 1193,  572,  411,  226,  519,\n+ \/*   280 *\/   177,   83,   84,  123,  123,  123,  123,  122,  122,  121,\n+ \/*   290 *\/   121,  121,  120,  117,  448, 1010,   16,   16, 1193,  134,\n+ \/*   300 *\/   134,  126,  127,   81, 1217, 1217, 1054, 1057, 1044, 1044,\n+ \/*   310 *\/   124,  124,  125,  125,  125,  125,  123,  123,  123,  123,\n+ \/*   320 *\/   122,  122,  121,  121,  121,  120,  117,  448, 1045,  550,\n+ \/*   330 *\/  1193,  375, 1193, 1194, 1193,  254, 1438,  401,  508,  505,\n+ \/*   340 *\/   504,  112,  564,  570,    4,  929,  929,  435,  503,  342,\n+ \/*   350 *\/   464,  330,  362,  396, 1238, 1193, 1194, 1193,  567,  572,\n+ \/*   360 *\/   123,  123,  123,  123,  122,  122,  121,  121,  121,  120,\n+ \/*   370 *\/   117,  448,  286,  286,  371, 1581, 1607,  445,  444,  155,\n+ \/*   380 *\/   411,  449,   72,   72, 1289,  569, 1222, 1193, 1194, 1193,\n+ \/*   390 *\/    86, 1224,  273,  561,  547,  520,  520,  572,   99, 1223,\n+ \/*   400 *\/     6, 1281,  476,  143,  126,  127,   81, 1217, 1217, 1054,\n+ \/*   410 *\/  1057, 1044, 1044,  124,  124,  125,  125,  125,  125,  554,\n+ \/*   420 *\/    13,   13, 1031,  511, 1225, 1193, 1225,  553,  110,  110,\n+ \/*   430 *\/   224,  572, 1239,  177,  572,  429,  111,  199,  449,  573,\n+ \/*   440 *\/   449,  432, 1555, 1019,  327,  555, 1193,  272,  289,  370,\n+ \/*   450 *\/   514,  365,  513,  259,   72,   72,  547,   72,   72,  361,\n+ \/*   460 *\/   318,  563, 1613,  123,  123,  123,  123,  122,  122,  121,\n+ \/*   470 *\/   121,  121,  120,  117,  448, 1019, 1019, 1021, 1022,   28,\n+ \/*   480 *\/   286,  286, 1193, 1194, 1193, 1159,  572, 1612,  411,  904,\n+ \/*   490 *\/   192,  554,  358,  569,  554,  940,  537,  521, 1159,  437,\n+ \/*   500 *\/   415, 1159,  556, 1193, 1194, 1193,  572,  548,  548,   52,\n+ \/*   510 *\/    52,  216,  126,  127,   81, 1217, 1217, 1054, 1057, 1044,\n+ \/*   520 *\/  1044,  124,  124,  125,  125,  125,  125, 1193,  478,  136,\n+ \/*   530 *\/   136,  411,  286,  286, 1493,  509,  122,  122,  121,  121,\n+ \/*   540 *\/   121,  120,  117,  448, 1010,  569,  522,  219,  545,  545,\n+ \/*   550 *\/   318,  563,  143,    6,  536,  126,  127,   81, 1217, 1217,\n+ \/*   560 *\/  1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,  125,\n+ \/*   570 *\/  1557,  123,  123,  123,  123,  122,  122,  121,  121,  121,\n+ \/*   580 *\/   120,  117,  448,  489, 1193, 1194, 1193,  486,  283, 1270,\n+ \/*   590 *\/   960,  254, 1193,  375,  508,  505,  504, 1193,  342,  574,\n+ \/*   600 *\/  1193,  574,  411,  294,  503,  960,  879,  193,  484,  318,\n+ \/*   610 *\/   563,  386,  292,  382,  123,  123,  123,  123,  122,  122,\n+ \/*   620 *\/   121,  121,  121,  120,  117,  448,  126,  127,   81, 1217,\n+ \/*   630 *\/  1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,\n+ \/*   640 *\/   125,  411,  396, 1139, 1193,  872,  101,  286,  286, 1193,\n+ \/*   650 *\/  1194, 1193,  375, 1096, 1193, 1194, 1193, 1193, 1194, 1193,\n+ \/*   660 *\/   569,  459,   33,  375,  235,  126,  127,   81, 1217, 1217,\n+ \/*   670 *\/  1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,  125,\n+ \/*   680 *\/  1437,  962,  572,  230,  961,  123,  123,  123,  123,  122,\n+ \/*   690 *\/   122,  121,  121,  121,  120,  117,  448, 1159,  230, 1193,\n+ \/*   700 *\/   158, 1193, 1194, 1193, 1556,   13,   13,  303,  960, 1233,\n+ \/*   710 *\/  1159,  154,  411, 1159,  375, 1584, 1177,    5,  371, 1581,\n+ \/*   720 *\/   431, 1239,    3,  960,  123,  123,  123,  123,  122,  122,\n+ \/*   730 *\/   121,  121,  121,  120,  117,  448,  126,  127,   81, 1217,\n+ \/*   740 *\/  1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,\n+ \/*   750 *\/   125,  411,  210,  571, 1193, 1032, 1193, 1194, 1193, 1193,\n+ \/*   760 *\/   390,  855,  156, 1555,  376,  404, 1101, 1101,  492,  572,\n+ \/*   770 *\/   469,  344, 1322, 1322, 1555,  126,  127,   81, 1217, 1217,\n+ \/*   780 *\/  1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,  125,\n+ \/*   790 *\/   130,  572,   13,   13,  532,  123,  123,  123,  123,  122,\n+ \/*   800 *\/   122,  121,  121,  121,  120,  117,  448,  304,  572,  457,\n+ \/*   810 *\/   229, 1193, 1194, 1193,   13,   13, 1193, 1194, 1193, 1300,\n+ \/*   820 *\/   467, 1270,  411, 1320, 1320, 1555, 1015,  457,  456,  436,\n+ \/*   830 *\/   301,   72,   72, 1268,  123,  123,  123,  123,  122,  122,\n+ \/*   840 *\/   121,  121,  121,  120,  117,  448,  126,  127,   81, 1217,\n+ \/*   850 *\/  1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,\n+ \/*   860 *\/   125,  411,  384, 1076, 1159,  286,  286,  421,  314,  280,\n+ \/*   870 *\/   280,  287,  287,  461,  408,  407, 1539, 1159,  569,  572,\n+ \/*   880 *\/  1159, 1196,  569,  409,  569,  126,  127,   81, 1217, 1217,\n+ \/*   890 *\/  1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,  125,\n+ \/*   900 *\/   457, 1485,   13,   13, 1541,  123,  123,  123,  123,  122,\n+ \/*   910 *\/   122,  121,  121,  121,  120,  117,  448,  202,  572,  462,\n+ \/*   920 *\/  1587,  578,    2, 1248,  843,  844,  845, 1563,  319,  409,\n+ \/*   930 *\/   147,    6,  411,  257,  256,  255,  208, 1330,    9, 1196,\n+ \/*   940 *\/   264,   72,   72, 1436,  123,  123,  123,  123,  122,  122,\n+ \/*   950 *\/   121,  121,  121,  120,  117,  448,  126,  127,   81, 1217,\n+ \/*   960 *\/  1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,\n+ \/*   970 *\/   125,  572,  286,  286,  572, 1213,  411,  577,  315, 1248,\n+ \/*   980 *\/   421,  371, 1581,  356,  319,  569,  147,  495,  529, 1644,\n+ \/*   990 *\/   397,  935,  495, 1330,   71,   71,  934,   72,   72,  242,\n+ \/*  1000 *\/  1328,  105,   81, 1217, 1217, 1054, 1057, 1044, 1044,  124,\n+ \/*  1010 *\/   124,  125,  125,  125,  125,  123,  123,  123,  123,  122,\n+ \/*  1020 *\/   122,  121,  121,  121,  120,  117,  448, 1117,  286,  286,\n+ \/*  1030 *\/  1422,  452, 1528, 1213,  443,  286,  286, 1492, 1355,  313,\n+ \/*  1040 *\/   478,  569, 1118,  454,  351,  495,  354, 1266,  569,  209,\n+ \/*  1050 *\/   572,  418,  179,  572, 1031,  242,  385, 1119,  523,  123,\n+ \/*  1060 *\/   123,  123,  123,  122,  122,  121,  121,  121,  120,  117,\n+ \/*  1070 *\/   448, 1020,  108,   72,   72, 1019,   13,   13,  915,  572,\n+ \/*  1080 *\/  1498,  572,  286,  286,   98,  530, 1537,  452,  916, 1334,\n+ \/*  1090 *\/  1329,  203,  411,  286,  286,  569,  152,  211, 1498, 1500,\n+ \/*  1100 *\/   426,  569,   56,   56,   57,   57,  569, 1019, 1019, 1021,\n+ \/*  1110 *\/   447,  572,  411,  531,   12,  297,  126,  127,   81, 1217,\n+ \/*  1120 *\/  1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,\n+ \/*  1130 *\/   125,  572,  411,  867,   15,   15,  126,  127,   81, 1217,\n+ \/*  1140 *\/  1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,\n+ \/*  1150 *\/   125,  373,  529,  264,   44,   44,  126,  115,   81, 1217,\n+ \/*  1160 *\/  1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,\n+ \/*  1170 *\/   125, 1498,  478, 1271,  417,  123,  123,  123,  123,  122,\n+ \/*  1180 *\/   122,  121,  121,  121,  120,  117,  448,  205, 1213,  495,\n+ \/*  1190 *\/   430,  867,  468,  322,  495,  123,  123,  123,  123,  122,\n+ \/*  1200 *\/   122,  121,  121,  121,  120,  117,  448,  572,  557, 1140,\n+ \/*  1210 *\/  1642, 1422, 1642,  543,  572,  123,  123,  123,  123,  122,\n+ \/*  1220 *\/   122,  121,  121,  121,  120,  117,  448,  572, 1422,  572,\n+ \/*  1230 *\/    13,   13,  542,  323, 1325,  411,  334,   58,   58,  349,\n+ \/*  1240 *\/  1422, 1170,  326,  286,  286,  549, 1213,  300,  895,  530,\n+ \/*  1250 *\/    45,   45,   59,   59, 1140, 1643,  569, 1643,  565,  417,\n+ \/*  1260 *\/   127,   81, 1217, 1217, 1054, 1057, 1044, 1044,  124,  124,\n+ \/*  1270 *\/   125,  125,  125,  125, 1367,  373,  500,  290, 1193,  512,\n+ \/*  1280 *\/  1366,  427,  394,  394,  393,  275,  391,  896, 1138,  852,\n+ \/*  1290 *\/   478,  258, 1422, 1170,  463, 1159,   12,  331,  428,  333,\n+ \/*  1300 *\/  1117,  460,  236,  258,  325,  460,  544, 1544, 1159, 1098,\n+ \/*  1310 *\/   491, 1159,  324, 1098,  440, 1118,  335,  516,  123,  123,\n+ \/*  1320 *\/   123,  123,  122,  122,  121,  121,  121,  120,  117,  448,\n+ \/*  1330 *\/  1119,  318,  563, 1138,  572, 1193, 1194, 1193,  112,  564,\n+ \/*  1340 *\/   201,    4,  238,  433,  935,  490,  285,  228, 1517,  934,\n+ \/*  1350 *\/   170,  560,  572,  142, 1516,  567,  572,   60,   60,  572,\n+ \/*  1360 *\/   416,  572,  441,  572,  535,  302,  875,    8,  487,  572,\n+ \/*  1370 *\/   237,  572,  416,  572,  485,   61,   61,  572,  449,   62,\n+ \/*  1380 *\/    62,  332,   63,   63,   46,   46,   47,   47,  361,  572,\n+ \/*  1390 *\/   561,  572,   48,   48,   50,   50,   51,   51,  572,  295,\n+ \/*  1400 *\/    64,   64,  482,  295,  539,  412,  471, 1031,  572,  538,\n+ \/*  1410 *\/   318,  563,   65,   65,   66,   66,  409,  475,  572, 1031,\n+ \/*  1420 *\/   572,   14,   14,  875, 1020,  110,  110,  409, 1019,  572,\n+ \/*  1430 *\/   474,   67,   67,  111,  455,  449,  573,  449,   98,  317,\n+ \/*  1440 *\/  1019,  132,  132,  133,  133,  572, 1561,  572,  974,  409,\n+ \/*  1450 *\/     6, 1562,   68,   68, 1560,    6,  975,  572,    6, 1559,\n+ \/*  1460 *\/  1019, 1019, 1021,    6,  346,  218,  101,  531,   53,   53,\n+ \/*  1470 *\/    69,   69, 1019, 1019, 1021, 1022,   28, 1586, 1181,  451,\n+ \/*  1480 *\/    70,   70,  290,   87,  215,   31, 1363,  394,  394,  393,\n+ \/*  1490 *\/   275,  391,  350,  109,  852,  107,  572,  112,  564,  483,\n+ \/*  1500 *\/     4, 1212,  572,  239,  153,  572,   39,  236, 1299,  325,\n+ \/*  1510 *\/   112,  564, 1298,    4,  567,  572,   32,  324,  572,   54,\n+ \/*  1520 *\/    54,  572, 1135,  353,  398,  165,  165,  567,  166,  166,\n+ \/*  1530 *\/   572,  291,  355,  572,   17,  357,  572,  449,   77,   77,\n+ \/*  1540 *\/  1313,   55,   55, 1297,   73,   73,  572,  238,  470,  561,\n+ \/*  1550 *\/   449,  472,  364,  135,  135,  170,   74,   74,  142,  163,\n+ \/*  1560 *\/   163,  374,  561,  539,  572,  321,  572,  886,  540,  137,\n+ \/*  1570 *\/   137,  339, 1353,  422,  298,  237,  539,  572, 1031,  572,\n+ \/*  1580 *\/   340,  538,  101,  369,  110,  110,  162,  131,  131,  164,\n+ \/*  1590 *\/   164, 1031,  111,  368,  449,  573,  449,  110,  110, 1019,\n+ \/*  1600 *\/   157,  157,  141,  141,  572,  111,  572,  449,  573,  449,\n+ \/*  1610 *\/   412,  288, 1019,  572,  882,  318,  563,  572,  219,  572,\n+ \/*  1620 *\/   241, 1012,  477,  263,  263,  894,  893,  140,  140,  138,\n+ \/*  1630 *\/   138, 1019, 1019, 1021, 1022,   28,  139,  139,  525,  455,\n+ \/*  1640 *\/    76,   76,   78,   78, 1019, 1019, 1021, 1022,   28, 1181,\n+ \/*  1650 *\/   451,  572, 1083,  290,  112,  564, 1575,    4,  394,  394,\n+ \/*  1660 *\/   393,  275,  391,  572, 1023,  852,  572,  479,  345,  263,\n+ \/*  1670 *\/   101,  567,  882, 1376,   75,   75, 1421,  501,  236,  260,\n+ \/*  1680 *\/   325,  112,  564,  359,    4,  101,   43,   43,  324,   49,\n+ \/*  1690 *\/    49,  901,  902,  161,  449,  101,  977,  978,  567, 1079,\n+ \/*  1700 *\/  1349,  260,  965,  932,  263,  114,  561, 1095,  517, 1095,\n+ \/*  1710 *\/  1083, 1094,  865, 1094,  151,  933, 1144,  114,  238, 1361,\n+ \/*  1720 *\/   558,  449, 1023,  559, 1426, 1278,  170, 1269, 1257,  142,\n+ \/*  1730 *\/  1601, 1256, 1258,  561, 1594, 1031,  496,  278,  213, 1346,\n+ \/*  1740 *\/   310,  110,  110,  939,  311,  312,  237,   11,  234,  111,\n+ \/*  1750 *\/   221,  449,  573,  449,  293,  395, 1019, 1408,  337, 1403,\n+ \/*  1760 *\/  1396,  338, 1031,  299,  343, 1413, 1412,  481,  110,  110,\n+ \/*  1770 *\/   506,  402,  225, 1296,  206,  367,  111, 1358,  449,  573,\n+ \/*  1780 *\/   449,  412, 1359, 1019, 1489, 1488,  318,  563, 1019, 1019,\n+ \/*  1790 *\/  1021, 1022,   28,  562,  207,  220,   80,  564,  389,    4,\n+ \/*  1800 *\/  1597, 1357,  552, 1356, 1233,  181,  267,  232, 1536, 1534,\n+ \/*  1810 *\/   455, 1230,  420,  567,   82, 1019, 1019, 1021, 1022,   28,\n+ \/*  1820 *\/    86,  217,   85, 1494,  190,  175,  183,  465,  185,  466,\n+ \/*  1830 *\/    36, 1409,  186,  187,  188,  499,  449,  244,   37,   99,\n+ \/*  1840 *\/   400, 1415, 1414,  488, 1417,  194,  473,  403,  561, 1483,\n+ \/*  1850 *\/   248,   92, 1505,  494,  198,  279,  112,  564,  250,    4,\n+ \/*  1860 *\/   348,  497,  405,  352, 1259,  251,  252,  515, 1316,  434,\n+ \/*  1870 *\/  1315, 1314,   94,  567, 1307,  886, 1306, 1031,  226,  406,\n+ \/*  1880 *\/  1611, 1610,  438,  110,  110, 1580, 1286,  524,  439,  308,\n+ \/*  1890 *\/   266,  111, 1285,  449,  573,  449,  449,  309, 1019,  366,\n+ \/*  1900 *\/  1284, 1609,  265, 1566, 1565,  442,  372, 1381,  561,  129,\n+ \/*  1910 *\/   550, 1380,   10, 1470,  383,  106,  316,  551,  100,   35,\n+ \/*  1920 *\/   534,  575,  212, 1339,  381,  387, 1187, 1338,  274,  276,\n+ \/*  1930 *\/  1019, 1019, 1021, 1022,   28,  277,  413, 1031,  576, 1254,\n+ \/*  1940 *\/   388, 1521, 1249,  110,  110,  167, 1522,  168,  148, 1520,\n+ \/*  1950 *\/  1519,  111,  306,  449,  573,  449,  222,  223, 1019,  839,\n+ \/*  1960 *\/   169,   79,  450,  214,  414,  233,  320,  145, 1093, 1091,\n+ \/*  1970 *\/   328,  182,  171, 1212,  918,  184,  240,  336,  243, 1107,\n+ \/*  1980 *\/   189,  172,  173,  423,  425,   88,  180,  191,   89,   90,\n+ \/*  1990 *\/  1019, 1019, 1021, 1022,   28,   91,  174, 1110,  245, 1106,\n+ \/*  2000 *\/   246,  159,   18,  247,  347, 1099,  263,  195, 1227,  493,\n+ \/*  2010 *\/   249,  196,   38,  854,  498,  368,  253,  360,  897,  197,\n+ \/*  2020 *\/   502,   93,   19,   20,  507,  884,  363,  510,   95,  307,\n+ \/*  2030 *\/   160,   96,  518,   97, 1175, 1060, 1146,   40,   21,  227,\n+ \/*  2040 *\/   176, 1145,  282,  284,  969,  200,  963,  114,  262, 1165,\n+ \/*  2050 *\/    22,   23,   24, 1161, 1169,   25, 1163, 1150,   34,   26,\n+ \/*  2060 *\/  1168,  546,   27,  204,  101,  103,  104, 1074,    7, 1061,\n+ \/*  2070 *\/  1059, 1063, 1116, 1064, 1115,  268,  269,   29,   41,  270,\n+ \/*  2080 *\/  1024,  866,  113,   30,  568,  392, 1183,  144,  178, 1182,\n+ \/*  2090 *\/   271,  928, 1245, 1245, 1245, 1245, 1245, 1245, 1245, 1602,\n@@ -164402,1 +172009,1 @@\n- \/*   760 *\/   201,   21,  241,  304,   22,  206,  127,  128,  129,  193,\n+ \/*   760 *\/   201,   21,  241,  304,  193,  206,  127,  128,  129,  193,\n@@ -164413,2 +172020,2 @@\n- \/*   870 *\/   240,  239,  240,  193,  106,  107,  193,   89,  252,  193,\n- \/*   880 *\/    92,   59,  252,  141,  252,   43,   44,   45,   46,   47,\n+ \/*   870 *\/   240,  239,  240,  244,  106,  107,  193,   89,  252,  193,\n+ \/*   880 *\/    92,   59,  252,  254,  252,   43,   44,   45,   46,   47,\n@@ -164417,2 +172024,2 @@\n- \/*   910 *\/   107,  108,  109,  110,  111,  112,  113,  231,  193,   16,\n- \/*   920 *\/   187,  188,  189,  190,    7,    8,    9,  309,  195,   25,\n+ \/*   910 *\/   107,  108,  109,  110,  111,  112,  113,  231,  193,  244,\n+ \/*   920 *\/   187,  188,  189,  190,    7,    8,    9,  309,  195,  254,\n@@ -164420,1 +172027,1 @@\n- \/*   940 *\/    24,  216,  217,  263,  102,  103,  104,  105,  106,  107,\n+ \/*   940 *\/    24,  216,  217,  273,  102,  103,  104,  105,  106,  107,\n@@ -164424,2 +172031,2 @@\n- \/*   980 *\/    77,  226,   79,  193,  195,  252,  197,  193,   19,  301,\n- \/*   990 *\/   302,  193,  193,  204,  216,  217,  226,  216,  217,  266,\n+ \/*   980 *\/   193,  311,  312,   16,  195,  252,  197,  193,   19,  301,\n+ \/*   990 *\/   302,  135,  193,  204,  216,  217,  140,  216,  217,  266,\n@@ -164429,3 +172036,3 @@\n- \/*  1030 *\/   232,  298,  238,  117,  253,  239,  240,  238,  259,  260,\n- \/*  1040 *\/   193,  252,   27,   31,  193,  193,  142,  204,  252,  193,\n- \/*  1050 *\/   193,   39,  262,  193,  100,  266,  278,   42,  204,  102,\n+ \/*  1030 *\/   193,  298,  238,  117,  253,  239,  240,  238,  259,  260,\n+ \/*  1040 *\/   193,  252,   27,  193,   77,  193,   79,  204,  252,  262,\n+ \/*  1050 *\/   193,  299,  300,  193,  100,  266,  278,   42,  204,  102,\n@@ -164434,1 +172041,1 @@\n- \/*  1080 *\/   193,  193,  239,  240,  115,  116,  193,  298,   73,  238,\n+ \/*  1080 *\/   193,  193,  239,  240,  115,  116,  193,  298,   73,  240,\n@@ -164436,2 +172043,2 @@\n- \/*  1100 *\/    24,  193,  216,  217,  216,  217,  252,  153,  154,  155,\n- \/*  1110 *\/   253,   16,   19,  144,  213,  268,   43,   44,   45,   46,\n+ \/*  1100 *\/   263,  252,  216,  217,  216,  217,  252,  153,  154,  155,\n+ \/*  1110 *\/   253,  193,   19,  144,  213,  268,   43,   44,   45,   46,\n@@ -164439,1 +172046,1 @@\n- \/*  1130 *\/    57,  238,   19,   59,  193,   59,   43,   44,   45,   46,\n+ \/*  1130 *\/    57,  193,   19,   59,  216,  217,   43,   44,   45,   46,\n@@ -164441,1 +172048,1 @@\n- \/*  1150 *\/    57,   22,   23,  193,   25,  193,   43,   44,   45,   46,\n+ \/*  1150 *\/    57,  193,   19,   24,  216,  217,   43,   44,   45,   46,\n@@ -164443,9 +172050,9 @@\n- \/*  1170 *\/    57,  284,   77,  193,   79,  102,  103,  104,  105,  106,\n- \/*  1180 *\/   107,  108,  109,  110,  111,  112,  113,  286,  193,  193,\n- \/*  1190 *\/   193,  117,  291,  117,  232,  102,  103,  104,  105,  106,\n- \/*  1200 *\/   107,  108,  109,  110,  111,  112,  113,  204,   22,   23,\n- \/*  1210 *\/    66,   25,  216,  217,   35,  102,  103,  104,  105,  106,\n- \/*  1220 *\/   107,  108,  109,  110,  111,  112,  113,  193,  268,   85,\n- \/*  1230 *\/   101,  193,  309,  309,  240,   19,  313,  313,   94,  208,\n- \/*  1240 *\/   209,  193,  239,  240,  193,   66,  252,   19,  268,  244,\n- \/*  1250 *\/   216,  217,  193,   74,  213,  252,  161,   19,  263,  254,\n+ \/*  1170 *\/    57,  284,  193,  208,  209,  102,  103,  104,  105,  106,\n+ \/*  1180 *\/   107,  108,  109,  110,  111,  112,  113,  286,   59,  193,\n+ \/*  1190 *\/   232,  117,  291,  193,  193,  102,  103,  104,  105,  106,\n+ \/*  1200 *\/   107,  108,  109,  110,  111,  112,  113,  193,  204,   22,\n+ \/*  1210 *\/    23,  193,   25,   66,  193,  102,  103,  104,  105,  106,\n+ \/*  1220 *\/   107,  108,  109,  110,  111,  112,  113,  193,  193,  193,\n+ \/*  1230 *\/   216,  217,   85,  193,  238,   19,   16,  216,  217,  238,\n+ \/*  1240 *\/   193,   94,  193,  239,  240,  231,  117,  268,   35,  116,\n+ \/*  1250 *\/   216,  217,  216,  217,   22,   23,  252,   25,  208,  209,\n@@ -164453,5 +172060,5 @@\n- \/*  1270 *\/    54,   55,   56,   57,  193,  216,  217,    5,   59,  193,\n- \/*  1280 *\/    19,  244,   10,   11,   12,   13,   14,  101,  309,   17,\n- \/*  1290 *\/   146,  254,  313,  193,  193,   76,  115,  216,  217,  309,\n- \/*  1300 *\/    12,  263,   30,  313,   32,   46,   87,   46,   89,  130,\n- \/*  1310 *\/   193,   92,   40,   22,  263,   27,  216,  217,  102,  103,\n+ \/*  1270 *\/    54,   55,   56,   57,  193,  193,   19,    5,   59,   66,\n+ \/*  1280 *\/   193,  263,   10,   11,   12,   13,   14,   74,  101,   17,\n+ \/*  1290 *\/   193,   46,  193,  146,  193,   76,  213,   77,  263,   79,\n+ \/*  1300 *\/    12,  260,   30,   46,   32,  264,   87,  193,   89,   29,\n+ \/*  1310 *\/   263,   92,   40,   33,  232,   27,  193,  108,  102,  103,\n@@ -164459,14 +172066,14 @@\n- \/*  1330 *\/    42,  150,  291,  216,  217,  116,  117,  118,   19,   20,\n- \/*  1340 *\/   193,   22,   70,  260,  116,  193,   24,  264,  193,  263,\n- \/*  1350 *\/    78,   63,   61,   81,  116,   36,  193,  260,  193,   29,\n- \/*  1360 *\/   193,  264,  193,   33,  145,  193,   59,   48,  216,  217,\n- \/*  1370 *\/    98,  216,  217,  193,  115,  193,  115,  193,   59,  216,\n- \/*  1380 *\/   217,  216,  217,  216,  217,  216,  217,  255,  216,  217,\n- \/*  1390 *\/    71,  193,  131,  193,   25,   65,  216,  217,  216,  217,\n- \/*  1400 *\/   216,  217,  208,  209,   85,  133,  193,  100,  193,   90,\n- \/*  1410 *\/   138,  139,  138,  139,  216,  217,  216,  217,  193,  100,\n- \/*  1420 *\/   193,  108,  135,  116,  117,  106,  107,  140,  121,  216,\n- \/*  1430 *\/   217,  216,  217,  114,  162,  116,  117,  118,  299,  300,\n- \/*  1440 *\/   121,  216,  217,  216,  217,  193,  244,  193,  135,  244,\n- \/*  1450 *\/   193,  256,  257,  140,  244,  193,  254,  193,  193,  254,\n- \/*  1460 *\/   153,  154,  155,  141,  254,  149,  150,  258,  216,  217,\n+ \/*  1330 *\/    42,  138,  139,  101,  193,  116,  117,  118,   19,   20,\n+ \/*  1340 *\/   255,   22,   70,  130,  135,   65,  256,  257,  193,  140,\n+ \/*  1350 *\/    78,   63,  193,   81,  193,   36,  193,  216,  217,  193,\n+ \/*  1360 *\/   115,  193,  263,  193,  145,  268,   59,   48,  193,  193,\n+ \/*  1370 *\/    98,  193,  115,  193,  291,  216,  217,  193,   59,  216,\n+ \/*  1380 *\/   217,  161,  216,  217,  216,  217,  216,  217,  131,  193,\n+ \/*  1390 *\/    71,  193,  216,  217,  216,  217,  216,  217,  193,  260,\n+ \/*  1400 *\/   216,  217,   19,  264,   85,  133,  244,  100,  193,   90,\n+ \/*  1410 *\/   138,  139,  216,  217,  216,  217,  254,  244,  193,  100,\n+ \/*  1420 *\/   193,  216,  217,  116,  117,  106,  107,  254,  121,  193,\n+ \/*  1430 *\/   115,  216,  217,  114,  162,  116,  117,  118,  115,  244,\n+ \/*  1440 *\/   121,  216,  217,  216,  217,  193,  309,  193,   31,  254,\n+ \/*  1450 *\/   313,  309,  216,  217,  309,  313,   39,  193,  313,  309,\n+ \/*  1460 *\/   153,  154,  155,  313,  193,  150,   25,  144,  216,  217,\n@@ -164474,11 +172081,11 @@\n- \/*  1480 *\/   216,  217,    5,  115,  158,  193,  160,   10,   11,   12,\n- \/*  1490 *\/    13,   14,  193,   59,   17,  126,  193,   19,   20,  129,\n- \/*  1500 *\/    22,  193,   22,   22,   24,  193,   23,   30,   25,   32,\n- \/*  1510 *\/    19,   20,  144,   22,   36,  216,  217,   40,  193,  216,\n- \/*  1520 *\/   217,  193,  152,  129,  216,  217,  193,   36,  216,  217,\n- \/*  1530 *\/   193,   99,  193,  193,   53,  193,  193,   59,   23,  193,\n- \/*  1540 *\/    25,  216,  217,  193,  216,  217,  152,   70,   59,   71,\n- \/*  1550 *\/    59,  117,  193,  216,  217,   78,  216,  217,   81,  216,\n- \/*  1560 *\/   217,  318,   71,   85,  193,  133,  193,  193,   90,   23,\n- \/*  1570 *\/    23,   25,   25,  120,  121,   98,   85,  193,  100,  193,\n- \/*  1580 *\/    23,   90,   25,  121,  106,  107,   19,  216,  217,  216,\n+ \/*  1480 *\/   216,  217,    5,  149,  150,   22,  193,   10,   11,   12,\n+ \/*  1490 *\/    13,   14,  193,  158,   17,  160,  193,   19,   20,  116,\n+ \/*  1500 *\/    22,   25,  193,   24,   22,  193,   24,   30,  226,   32,\n+ \/*  1510 *\/    19,   20,  226,   22,   36,  193,   53,   40,  193,  216,\n+ \/*  1520 *\/   217,  193,   23,  193,   25,  216,  217,   36,  216,  217,\n+ \/*  1530 *\/   193,   99,  193,  193,   22,  193,  193,   59,  216,  217,\n+ \/*  1540 *\/   193,  216,  217,  193,  216,  217,  193,   70,  129,   71,\n+ \/*  1550 *\/    59,  129,  193,  216,  217,   78,  216,  217,   81,  216,\n+ \/*  1560 *\/   217,  193,   71,   85,  193,  133,  193,  126,   90,  216,\n+ \/*  1570 *\/   217,  152,  258,   61,  152,   98,   85,  193,  100,  193,\n+ \/*  1580 *\/    23,   90,   25,  121,  106,  107,   23,  216,  217,  216,\n@@ -164486,4 +172093,4 @@\n- \/*  1600 *\/   216,  217,  216,  217,  193,  114,  117,  116,  117,  118,\n- \/*  1610 *\/   133,  193,  121,  193,  193,  138,  139,  193,   23,  193,\n- \/*  1620 *\/    25,   23,   23,   25,   25,    7,    8,  216,  217,  193,\n- \/*  1630 *\/   193,  153,  154,  155,  156,  157,  216,  217,  193,  162,\n+ \/*  1600 *\/   216,  217,  216,  217,  193,  114,  193,  116,  117,  118,\n+ \/*  1610 *\/   133,   22,  121,  193,   59,  138,  139,  193,  142,  193,\n+ \/*  1620 *\/   141,   23,   23,   25,   25,  120,  121,  216,  217,  216,\n+ \/*  1630 *\/   217,  153,  154,  155,  156,  157,  216,  217,   19,  162,\n@@ -164491,3 +172098,3 @@\n- \/*  1650 *\/     2,  193,  193,    5,   19,   20,   59,   22,   10,   11,\n- \/*  1660 *\/    12,   13,   14,  193,   97,   17,  193,   23,  193,   25,\n- \/*  1670 *\/   288,   36,  193,  242,  216,  217,  236,   23,   30,   25,\n+ \/*  1650 *\/     2,  193,   59,    5,   19,   20,  318,   22,   10,   11,\n+ \/*  1660 *\/    12,   13,   14,  193,   59,   17,  193,   23,   23,   25,\n+ \/*  1670 *\/    25,   36,  117,  193,  216,  217,  193,   23,   30,   25,\n@@ -164495,41 +172102,41 @@\n- \/*  1690 *\/   217,  216,  217,  193,   59,  216,  217,  193,   36,   83,\n- \/*  1700 *\/    84,  153,  153,  155,  155,   23,   71,   25,   23,  193,\n- \/*  1710 *\/    25,  193,  193,  193,  117,  193,  193,  193,   70,  193,\n- \/*  1720 *\/   193,   59,  193,  255,  255,  287,   78,  255,  243,   81,\n- \/*  1730 *\/   191,  255,  297,   71,  271,  100,  293,  245,  267,  214,\n- \/*  1740 *\/   246,  106,  107,  108,  246,  271,   98,  245,  293,  114,\n- \/*  1750 *\/   220,  116,  117,  118,  267,  271,  121,  271,  225,  219,\n- \/*  1760 *\/   229,  219,  100,  219,  259,  259,  259,  259,  106,  107,\n- \/*  1770 *\/   249,  196,   60,  280,  141,  243,  114,  249,  116,  117,\n- \/*  1780 *\/   118,  133,  245,  121,  200,  297,  138,  139,  153,  154,\n- \/*  1790 *\/   155,  156,  157,  297,  200,   38,   19,   20,  151,   22,\n- \/*  1800 *\/   200,  150,  140,  294,  294,   22,  272,   43,  234,   18,\n- \/*  1810 *\/   162,  270,  200,   36,  237,  153,  154,  155,  156,  157,\n- \/*  1820 *\/   237,  283,  237,  237,   18,  199,  149,  246,  272,  270,\n- \/*  1830 *\/   272,  200,  158,  246,  246,  234,   59,  234,  246,  199,\n- \/*  1840 *\/   290,   62,  289,  200,  199,   22,  221,  115,   71,  200,\n- \/*  1850 *\/   200,  199,  199,  221,  218,  218,   19,   20,   64,   22,\n- \/*  1860 *\/   218,  227,   22,  224,  126,  224,  165,  221,   24,  305,\n- \/*  1870 *\/   200,  113,  312,   36,  218,  220,  218,  100,  282,  218,\n- \/*  1880 *\/    91,  218,  317,  106,  107,  221,  227,  282,  317,   82,\n- \/*  1890 *\/   148,  114,  265,  116,  117,  118,   59,  145,  121,   22,\n- \/*  1900 *\/   277,  158,  200,  265,   25,  202,  147,  250,   71,  279,\n- \/*  1910 *\/    13,  146,  194,  194,  249,  248,  250,  140,  247,  246,\n- \/*  1920 *\/     6,  192,  192,  192,  303,  303,  213,  207,  300,  213,\n- \/*  1930 *\/   153,  154,  155,  156,  157,  213,  213,  100,  213,  222,\n- \/*  1940 *\/   207,  214,  214,  106,  107,    4,  222,  207,    3,   22,\n- \/*  1950 *\/   163,  114,   15,  116,  117,  118,   16,   23,  121,   23,\n- \/*  1960 *\/   139,  151,  130,   25,  142,   16,   24,   20,  144,    1,\n- \/*  1970 *\/   142,  130,  130,   61,   53,   53,   37,  151,   53,   53,\n- \/*  1980 *\/   130,  116,   34,    1,  141,    5,   22,  115,  161,  141,\n- \/*  1990 *\/   153,  154,  155,  156,  157,   25,   68,   68,   75,   41,\n- \/*  2000 *\/   115,   24,  131,   20,   19,  125,   22,   96,   22,   22,\n- \/*  2010 *\/    67,   23,   22,   67,   59,   24,   22,   28,   67,   23,\n- \/*  2020 *\/    22,   22,  149,   23,   23,   23,  116,   23,   25,   37,\n- \/*  2030 *\/    97,  141,   23,   23,   22,  143,   25,   75,   88,   34,\n- \/*  2040 *\/    34,   34,   34,   86,   75,   93,   23,   34,   22,   34,\n- \/*  2050 *\/    25,   24,   34,   25,   23,  142,   23,  142,   44,   23,\n- \/*  2060 *\/    23,   23,   11,   23,   25,   22,   22,   22,   15,   23,\n- \/*  2070 *\/    23,   22,   22,   25,    1,    1,  141,   25,   23,  135,\n- \/*  2080 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2090 *\/   319,  319,  319,  319,  141,  141,  319,  141,  319,  319,\n+ \/*  1690 *\/   217,    7,    8,   23,   59,   25,   83,   84,   36,   23,\n+ \/*  1700 *\/   193,   25,   23,   23,   25,   25,   71,  153,  145,  155,\n+ \/*  1710 *\/   117,  153,   23,  155,   25,   23,   97,   25,   70,  193,\n+ \/*  1720 *\/   193,   59,  117,  236,  193,  193,   78,  193,  193,   81,\n+ \/*  1730 *\/   141,  193,  193,   71,  193,  100,  288,  287,  242,  255,\n+ \/*  1740 *\/   255,  106,  107,  108,  255,  255,   98,  243,  297,  114,\n+ \/*  1750 *\/   214,  116,  117,  118,  245,  191,  121,  271,  293,  267,\n+ \/*  1760 *\/   267,  246,  100,  246,  245,  271,  271,  293,  106,  107,\n+ \/*  1770 *\/   220,  271,  229,  225,  249,  219,  114,  259,  116,  117,\n+ \/*  1780 *\/   118,  133,  259,  121,  219,  219,  138,  139,  153,  154,\n+ \/*  1790 *\/   155,  156,  157,  280,  249,  243,   19,   20,  245,   22,\n+ \/*  1800 *\/   196,  259,  140,  259,   60,  297,  141,  297,  200,  200,\n+ \/*  1810 *\/   162,   38,  200,   36,  294,  153,  154,  155,  156,  157,\n+ \/*  1820 *\/   151,  150,  294,  283,   22,   43,  234,   18,  237,  200,\n+ \/*  1830 *\/   270,  272,  237,  237,  237,   18,   59,  199,  270,  149,\n+ \/*  1840 *\/   246,  272,  272,  200,  234,  234,  246,  246,   71,  246,\n+ \/*  1850 *\/   199,  158,  290,   62,   22,  200,   19,   20,  199,   22,\n+ \/*  1860 *\/   289,  221,  221,  200,  200,  199,  199,  115,  218,   64,\n+ \/*  1870 *\/   218,  218,   22,   36,  227,  126,  227,  100,  165,  221,\n+ \/*  1880 *\/   224,  224,   24,  106,  107,  312,  218,  305,  113,  282,\n+ \/*  1890 *\/    91,  114,  220,  116,  117,  118,   59,  282,  121,  218,\n+ \/*  1900 *\/   218,  218,  200,  317,  317,   82,  221,  265,   71,  148,\n+ \/*  1910 *\/   145,  265,   22,  277,  200,  158,  279,  140,  147,   25,\n+ \/*  1920 *\/   146,  202,  248,  250,  249,  247,   13,  250,  194,  194,\n+ \/*  1930 *\/   153,  154,  155,  156,  157,    6,  303,  100,  192,  192,\n+ \/*  1940 *\/   246,  213,  192,  106,  107,  207,  213,  207,  222,  213,\n+ \/*  1950 *\/   213,  114,  222,  116,  117,  118,  214,  214,  121,    4,\n+ \/*  1960 *\/   207,  213,    3,   22,  303,   15,  163,   16,   23,   23,\n+ \/*  1970 *\/   139,  151,  130,   25,   20,  142,   24,   16,  144,    1,\n+ \/*  1980 *\/   142,  130,  130,   61,   37,   53,  300,  151,   53,   53,\n+ \/*  1990 *\/   153,  154,  155,  156,  157,   53,  130,  116,   34,    1,\n+ \/*  2000 *\/   141,    5,   22,  115,  161,   68,   25,   68,   75,   41,\n+ \/*  2010 *\/   141,  115,   24,   20,   19,  131,  125,   23,   28,   22,\n+ \/*  2020 *\/    67,   22,   22,   22,   67,   59,   24,   96,   22,   67,\n+ \/*  2030 *\/    23,  149,   22,   25,   23,   23,   23,   22,   34,  141,\n+ \/*  2040 *\/    37,   97,   23,   23,  116,   22,  143,   25,   34,   75,\n+ \/*  2050 *\/    34,   34,   34,   88,   75,   34,   86,   23,   22,   34,\n+ \/*  2060 *\/    93,   24,   34,   25,   25,  142,  142,   23,   44,   23,\n+ \/*  2070 *\/    23,   23,   23,   11,   23,   25,   22,   22,   22,  141,\n+ \/*  2080 *\/    23,   23,   22,   22,   25,   15,    1,   23,   25,    1,\n+ \/*  2090 *\/   141,  135,  319,  319,  319,  319,  319,  319,  319,  141,\n@@ -164554,1 +172161,1 @@\n- \/*  2280 *\/   319,  319,  319,\n+ \/*  2280 *\/   319,  319,  319,  319,  319,\n@@ -164556,1 +172163,1 @@\n-#define YY_SHIFT_COUNT    (575)\n+#define YY_SHIFT_COUNT    (578)\n@@ -164558,1 +172165,1 @@\n-#define YY_SHIFT_MAX      (2074)\n+#define YY_SHIFT_MAX      (2088)\n@@ -164563,3 +172170,3 @@\n- \/*    30 *\/   271,  271, 1219, 1219,  216,   88,    1,    1,    1,    1,\n- \/*    40 *\/     1,   40,  111,  258,  361,  469,  512,  583,  622,  693,\n- \/*    50 *\/   732,  803,  842,  913, 1073, 1093, 1093, 1093, 1093, 1093,\n+ \/*    30 *\/  1837,  271,  271, 1219, 1219,  216,   88,    1,    1,    1,\n+ \/*    40 *\/     1,    1,   40,  111,  258,  361,  469,  512,  583,  622,\n+ \/*    50 *\/   693,  732,  803,  842,  913, 1073, 1093, 1093, 1093, 1093,\n@@ -164567,2 +172174,2 @@\n- \/*    70 *\/  1093, 1093, 1093, 1113, 1093, 1216,  957,  957, 1635, 1662,\n- \/*    80 *\/  1777, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837,\n+ \/*    70 *\/  1093, 1093, 1093, 1093, 1113, 1093, 1216,  957,  957, 1635,\n+ \/*    80 *\/  1662, 1777, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837,\n@@ -164573,45 +172180,45 @@\n- \/*   130 *\/   137,  181,  181,  181,  181,  181,  181,  181,   94,  430,\n- \/*   140 *\/    66,   65,  112,  366,  533,  533,  740, 1261,  533,  533,\n- \/*   150 *\/    79,   79,  533,  412,  412,  412,   77,  412,  123,  113,\n- \/*   160 *\/   113,   22,   22, 2098, 2098,  328,  328,  328,  239,  468,\n- \/*   170 *\/   468,  468,  468, 1015, 1015,  409,  366, 1129, 1186,  533,\n- \/*   180 *\/   533,  533,  533,  533,  533,  533,  533,  533,  533,  533,\n- \/*   190 *\/   533,  533,  533,  533,  533,  533,  533,  533,  533,  969,\n- \/*   200 *\/   621,  621,  533,  642,  788,  788, 1228, 1228,  822,  822,\n- \/*   210 *\/    67, 1274, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 1307,\n- \/*   220 *\/   954,  954,  585,  472,  640,  387,  695,  538,  541,  700,\n- \/*   230 *\/   533,  533,  533,  533,  533,  533,  533,  533,  533,  533,\n- \/*   240 *\/   222,  533,  533,  533,  533,  533,  533,  533,  533,  533,\n- \/*   250 *\/   533,  533,  533, 1179, 1179, 1179,  533,  533,  533,  565,\n- \/*   260 *\/   533,  533,  533,  916, 1144,  533,  533, 1288,  533,  533,\n- \/*   270 *\/   533,  533,  533,  533,  533,  533,  639, 1330,  209, 1076,\n- \/*   280 *\/  1076, 1076, 1076,  580,  209,  209, 1313,  768,  917,  649,\n- \/*   290 *\/  1181, 1316,  405, 1316, 1238,  249, 1181, 1181,  249, 1181,\n- \/*   300 *\/   405, 1238, 1369,  464, 1259, 1012, 1012, 1012, 1368, 1368,\n- \/*   310 *\/  1368, 1368,  184,  184, 1326,  904, 1287, 1480, 1712, 1712,\n- \/*   320 *\/  1633, 1633, 1757, 1757, 1633, 1647, 1651, 1783, 1764, 1791,\n- \/*   330 *\/  1791, 1791, 1791, 1633, 1806, 1677, 1651, 1651, 1677, 1783,\n- \/*   340 *\/  1764, 1677, 1764, 1677, 1633, 1806, 1674, 1779, 1633, 1806,\n- \/*   350 *\/  1823, 1633, 1806, 1633, 1806, 1823, 1732, 1732, 1732, 1794,\n- \/*   360 *\/  1840, 1840, 1823, 1732, 1738, 1732, 1794, 1732, 1732, 1701,\n- \/*   370 *\/  1844, 1758, 1758, 1823, 1633, 1789, 1789, 1807, 1807, 1742,\n- \/*   380 *\/  1752, 1877, 1633, 1743, 1742, 1759, 1765, 1677, 1879, 1897,\n- \/*   390 *\/  1897, 1914, 1914, 1914, 2098, 2098, 2098, 2098, 2098, 2098,\n- \/*   400 *\/  2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098, 2098,  207,\n- \/*   410 *\/  1095,  331,  620,  903,  806, 1074, 1483, 1432, 1481, 1322,\n- \/*   420 *\/  1370, 1394, 1515, 1291, 1546, 1547, 1557, 1595, 1598, 1599,\n- \/*   430 *\/  1434, 1453, 1618, 1462, 1567, 1489, 1644, 1654, 1616, 1660,\n- \/*   440 *\/  1548, 1549, 1682, 1685, 1597,  742, 1941, 1945, 1927, 1787,\n- \/*   450 *\/  1937, 1940, 1934, 1936, 1821, 1810, 1832, 1938, 1938, 1942,\n- \/*   460 *\/  1822, 1947, 1824, 1949, 1968, 1828, 1841, 1938, 1842, 1912,\n- \/*   470 *\/  1939, 1938, 1826, 1921, 1922, 1925, 1926, 1850, 1865, 1948,\n- \/*   480 *\/  1843, 1982, 1980, 1964, 1872, 1827, 1928, 1970, 1929, 1923,\n- \/*   490 *\/  1958, 1848, 1885, 1977, 1983, 1985, 1871, 1880, 1984, 1943,\n- \/*   500 *\/  1986, 1987, 1988, 1990, 1946, 1955, 1991, 1911, 1989, 1994,\n- \/*   510 *\/  1951, 1992, 1996, 1873, 1998, 2000, 2001, 2002, 2003, 2004,\n- \/*   520 *\/  1999, 1933, 1890, 2009, 2010, 1910, 2005, 2012, 1892, 2011,\n- \/*   530 *\/  2006, 2007, 2008, 2013, 1950, 1962, 1957, 2014, 1969, 1952,\n- \/*   540 *\/  2015, 2023, 2026, 2027, 2025, 2028, 2018, 1913, 1915, 2031,\n- \/*   550 *\/  2011, 2033, 2036, 2037, 2038, 2039, 2040, 2043, 2051, 2044,\n- \/*   560 *\/  2045, 2046, 2047, 2049, 2050, 2048, 1944, 1935, 1953, 1954,\n- \/*   570 *\/  1956, 2052, 2055, 2053, 2073, 2074,\n+ \/*   130 *\/  1837,  137,  181,  181,  181,  181,  181,  181,  181,   94,\n+ \/*   140 *\/   430,   66,   65,  112,  366,  533,  533,  740, 1257,  533,\n+ \/*   150 *\/   533,   79,   79,  533,  412,  412,  412,   77,  412,  123,\n+ \/*   160 *\/   113,  113,  113,   22,   22, 2100, 2100,  328,  328,  328,\n+ \/*   170 *\/   239,  468,  468,  468,  468, 1015, 1015,  409,  366, 1187,\n+ \/*   180 *\/  1232,  533,  533,  533,  533,  533,  533,  533,  533,  533,\n+ \/*   190 *\/   533,  533,  533,  533,  533,  533,  533,  533,  533,  533,\n+ \/*   200 *\/   533,  969,  621,  621,  533,  642,  788,  788, 1133, 1133,\n+ \/*   210 *\/   822,  822,   67, 1193, 2100, 2100, 2100, 2100, 2100, 2100,\n+ \/*   220 *\/  2100, 1307,  954,  954,  585,  472,  640,  387,  695,  538,\n+ \/*   230 *\/   541,  700,  533,  533,  533,  533,  533,  533,  533,  533,\n+ \/*   240 *\/   533,  533,  222,  533,  533,  533,  533,  533,  533,  533,\n+ \/*   250 *\/   533,  533,  533,  533,  533, 1213, 1213, 1213,  533,  533,\n+ \/*   260 *\/   533,  565,  533,  533,  533,  916, 1147,  533,  533, 1288,\n+ \/*   270 *\/   533,  533,  533,  533,  533,  533,  533,  533,  639, 1280,\n+ \/*   280 *\/   209, 1129, 1129, 1129, 1129,  580,  209,  209, 1209,  768,\n+ \/*   290 *\/   917,  649, 1315, 1334,  405, 1334, 1383,  249, 1315, 1315,\n+ \/*   300 *\/   249, 1315,  405, 1383, 1441,  464, 1245, 1417, 1417, 1417,\n+ \/*   310 *\/  1323, 1323, 1323, 1323,  184,  184, 1335, 1476,  856, 1482,\n+ \/*   320 *\/  1744, 1744, 1665, 1665, 1773, 1773, 1665, 1669, 1671, 1802,\n+ \/*   330 *\/  1782, 1809, 1809, 1809, 1809, 1665, 1817, 1690, 1671, 1671,\n+ \/*   340 *\/  1690, 1802, 1782, 1690, 1782, 1690, 1665, 1817, 1693, 1791,\n+ \/*   350 *\/  1665, 1817, 1832, 1665, 1817, 1665, 1817, 1832, 1752, 1752,\n+ \/*   360 *\/  1752, 1805, 1850, 1850, 1832, 1752, 1749, 1752, 1805, 1752,\n+ \/*   370 *\/  1752, 1713, 1858, 1775, 1775, 1832, 1665, 1799, 1799, 1823,\n+ \/*   380 *\/  1823, 1761, 1765, 1890, 1665, 1757, 1761, 1771, 1774, 1690,\n+ \/*   390 *\/  1894, 1913, 1913, 1929, 1929, 1929, 2100, 2100, 2100, 2100,\n+ \/*   400 *\/  2100, 2100, 2100, 2100, 2100, 2100, 2100, 2100, 2100, 2100,\n+ \/*   410 *\/  2100,  207, 1220,  331,  620,  967,  806, 1074, 1499, 1432,\n+ \/*   420 *\/  1463, 1479, 1419, 1422, 1557, 1512, 1598, 1599, 1644, 1645,\n+ \/*   430 *\/  1654, 1660, 1555, 1505, 1684, 1462, 1670, 1563, 1619, 1593,\n+ \/*   440 *\/  1676, 1679, 1613, 1680, 1554, 1558, 1689, 1692, 1605, 1589,\n+ \/*   450 *\/  1955, 1959, 1941, 1803, 1950, 1951, 1945, 1946, 1831, 1820,\n+ \/*   460 *\/  1842, 1948, 1948, 1952, 1833, 1954, 1834, 1961, 1978, 1838,\n+ \/*   470 *\/  1851, 1948, 1852, 1922, 1947, 1948, 1836, 1932, 1935, 1936,\n+ \/*   480 *\/  1942, 1866, 1881, 1964, 1859, 1998, 1996, 1980, 1888, 1843,\n+ \/*   490 *\/  1937, 1981, 1939, 1933, 1968, 1869, 1896, 1988, 1993, 1995,\n+ \/*   500 *\/  1884, 1891, 1997, 1953, 1999, 2000, 1994, 2001, 1957, 1966,\n+ \/*   510 *\/  2002, 1931, 1990, 2006, 1962, 2003, 2007, 2004, 1882, 2010,\n+ \/*   520 *\/  2011, 2012, 2008, 2013, 2015, 1944, 1898, 2019, 2020, 1928,\n+ \/*   530 *\/  2014, 2023, 1903, 2022, 2016, 2017, 2018, 2021, 1965, 1974,\n+ \/*   540 *\/  1970, 2024, 1979, 1967, 2025, 2034, 2036, 2037, 2038, 2039,\n+ \/*   550 *\/  2028, 1923, 1924, 2044, 2022, 2046, 2047, 2048, 2049, 2050,\n+ \/*   560 *\/  2051, 2054, 2062, 2055, 2056, 2057, 2058, 2060, 2061, 2059,\n+ \/*   570 *\/  1956, 1938, 1949, 1958, 2063, 2064, 2070, 2085, 2088,\n@@ -164619,1 +172226,1 @@\n-#define YY_REDUCE_COUNT (408)\n+#define YY_REDUCE_COUNT (410)\n@@ -164621,1 +172228,1 @@\n-#define YY_REDUCE_MAX   (1740)\n+#define YY_REDUCE_MAX   (1753)\n@@ -164625,3 +172232,3 @@\n- \/*    20 *\/   576, -175,  598,  686,  615,  725,  860,  778,  781,  857,\n- \/*    30 *\/   616,  887,   87,  240, -192,  408,  626,  796,  843,  854,\n- \/*    40 *\/  1003, -271, -271, -271, -271, -271, -271, -271, -271, -271,\n+ \/*    20 *\/   576,  598, -175,  686,  860,  615,  725, 1014,  778,  781,\n+ \/*    30 *\/   857,  616,  887,   87,  240, -192,  408,  626,  796,  843,\n+ \/*    40 *\/   854, 1004, -271, -271, -271, -271, -271, -271, -271, -271,\n@@ -164630,34 +172237,35 @@\n- \/*    70 *\/  -271, -271, -271, -271, -271, -271, -271, -271,   80,   83,\n- \/*    80 *\/   313,  886,  888,  996, 1034, 1059, 1081, 1100, 1117, 1152,\n- \/*    90 *\/  1155, 1163, 1165, 1167, 1169, 1172, 1180, 1182, 1184, 1198,\n- \/*   100 *\/  1200, 1213, 1215, 1225, 1227, 1252, 1254, 1264, 1299, 1303,\n- \/*   110 *\/  1308, 1312, 1325, 1328, 1337, 1340, 1343, 1371, 1373, 1384,\n- \/*   120 *\/  1386, 1411, 1420, 1424, 1426, 1458, 1470, 1473, 1475, 1479,\n- \/*   130 *\/  -271, -271, -271, -271, -271, -271, -271, -271, -271, -271,\n- \/*   140 *\/  -271,  138,  459,  396, -158,  470,  302, -212,  521,  201,\n- \/*   150 *\/  -195,  -92,  559,  630,  632,  630, -271,  632,  901,   63,\n- \/*   160 *\/   407, -271, -271, -271, -271,  161,  161,  161,  251,  335,\n- \/*   170 *\/   847,  960,  980,  537,  588,  618,  628,  688,  688, -166,\n- \/*   180 *\/  -161,  674,  790,  794,  799,  851,  852, -122,  680, -120,\n- \/*   190 *\/   995, 1038,  415, 1051,  893,  798,  962,  400, 1086,  779,\n- \/*   200 *\/   923,  924,  263, 1041,  979,  990, 1083, 1097, 1031, 1194,\n- \/*   210 *\/   362,  994, 1139, 1005, 1037, 1202, 1205, 1195, 1210, -194,\n- \/*   220 *\/    56,  185, -135,  232,  522,  560,  601,  617,  669,  683,\n- \/*   230 *\/   711,  856,  908,  941, 1048, 1101, 1147, 1257, 1262, 1265,\n- \/*   240 *\/   392, 1292, 1333, 1339, 1342, 1346, 1350, 1359, 1374, 1418,\n- \/*   250 *\/  1421, 1436, 1437,  593,  755,  770,  997, 1445, 1459, 1209,\n- \/*   260 *\/  1500, 1504, 1516, 1132, 1243, 1518, 1519, 1440, 1520,  560,\n- \/*   270 *\/  1522, 1523, 1524, 1526, 1527, 1529, 1382, 1438, 1431, 1468,\n- \/*   280 *\/  1469, 1472, 1476, 1209, 1431, 1431, 1485, 1525, 1539, 1435,\n- \/*   290 *\/  1463, 1471, 1492, 1487, 1443, 1494, 1474, 1484, 1498, 1486,\n- \/*   300 *\/  1502, 1455, 1530, 1531, 1533, 1540, 1542, 1544, 1505, 1506,\n- \/*   310 *\/  1507, 1508, 1521, 1528, 1493, 1537, 1532, 1575, 1488, 1496,\n- \/*   320 *\/  1584, 1594, 1509, 1510, 1600, 1538, 1534, 1541, 1574, 1577,\n- \/*   330 *\/  1583, 1585, 1586, 1612, 1626, 1581, 1556, 1558, 1587, 1559,\n- \/*   340 *\/  1601, 1588, 1603, 1592, 1631, 1640, 1550, 1553, 1643, 1645,\n- \/*   350 *\/  1625, 1649, 1652, 1650, 1653, 1632, 1636, 1637, 1642, 1634,\n- \/*   360 *\/  1639, 1641, 1646, 1656, 1655, 1658, 1659, 1661, 1663, 1560,\n- \/*   370 *\/  1564, 1596, 1605, 1664, 1670, 1565, 1571, 1627, 1638, 1657,\n- \/*   380 *\/  1665, 1623, 1702, 1630, 1666, 1667, 1671, 1673, 1703, 1718,\n- \/*   390 *\/  1719, 1729, 1730, 1731, 1621, 1622, 1628, 1720, 1713, 1716,\n- \/*   400 *\/  1722, 1723, 1733, 1717, 1724, 1727, 1728, 1725, 1740,\n+ \/*    70 *\/  -271, -271, -271, -271, -271, -271, -271, -271, -271,   80,\n+ \/*    80 *\/    83,  313,  886,  888,  918,  938, 1021, 1034, 1036, 1141,\n+ \/*    90 *\/  1159, 1163, 1166, 1168, 1170, 1176, 1178, 1180, 1184, 1196,\n+ \/*   100 *\/  1198, 1205, 1215, 1225, 1227, 1236, 1252, 1254, 1264, 1303,\n+ \/*   110 *\/  1309, 1312, 1322, 1325, 1328, 1337, 1340, 1343, 1353, 1371,\n+ \/*   120 *\/  1373, 1384, 1386, 1411, 1413, 1420, 1424, 1426, 1458, 1470,\n+ \/*   130 *\/  1473, -271, -271, -271, -271, -271, -271, -271, -271, -271,\n+ \/*   140 *\/  -271, -271,  138,  459,  396, -158,  470,  302, -212,  521,\n+ \/*   150 *\/   201, -195,  -92,  559,  630,  632,  630, -271,  632,  901,\n+ \/*   160 *\/    63,  407,  670, -271, -271, -271, -271,  161,  161,  161,\n+ \/*   170 *\/   251,  335,  847,  979, 1097,  537,  588,  618,  628,  688,\n+ \/*   180 *\/   688, -166, -161,  674,  787,  794,  799,  852,  996, -122,\n+ \/*   190 *\/   837, -120, 1018, 1035,  415, 1047, 1001,  958, 1082,  400,\n+ \/*   200 *\/  1099,  779, 1137, 1142,  263, 1083, 1145, 1150, 1041, 1139,\n+ \/*   210 *\/   965, 1050,  362,  849,  752,  629,  675, 1162, 1173, 1090,\n+ \/*   220 *\/  1195, -194,   56,  185, -135,  232,  522,  560,  571,  601,\n+ \/*   230 *\/   617,  669,  683,  711,  850,  893, 1000, 1040, 1049, 1081,\n+ \/*   240 *\/  1087, 1101,  392, 1114, 1123, 1155, 1161, 1175, 1271, 1293,\n+ \/*   250 *\/  1299, 1330, 1339, 1342, 1347,  593, 1282, 1286, 1350, 1359,\n+ \/*   260 *\/  1368, 1314, 1480, 1483, 1507, 1085, 1338, 1526, 1527, 1487,\n+ \/*   270 *\/  1531,  560, 1532, 1534, 1535, 1538, 1539, 1541, 1448, 1450,\n+ \/*   280 *\/  1496, 1484, 1485, 1489, 1490, 1314, 1496, 1496, 1504, 1536,\n+ \/*   290 *\/  1564, 1451, 1486, 1492, 1509, 1493, 1465, 1515, 1494, 1495,\n+ \/*   300 *\/  1517, 1500, 1519, 1474, 1550, 1543, 1548, 1556, 1565, 1566,\n+ \/*   310 *\/  1518, 1523, 1542, 1544, 1525, 1545, 1513, 1553, 1552, 1604,\n+ \/*   320 *\/  1508, 1510, 1608, 1609, 1520, 1528, 1612, 1540, 1559, 1560,\n+ \/*   330 *\/  1592, 1591, 1595, 1596, 1597, 1629, 1638, 1594, 1569, 1570,\n+ \/*   340 *\/  1600, 1568, 1610, 1601, 1611, 1603, 1643, 1651, 1562, 1571,\n+ \/*   350 *\/  1655, 1659, 1640, 1663, 1666, 1664, 1667, 1641, 1650, 1652,\n+ \/*   360 *\/  1653, 1647, 1656, 1657, 1658, 1668, 1672, 1681, 1649, 1682,\n+ \/*   370 *\/  1683, 1573, 1582, 1607, 1615, 1685, 1702, 1586, 1587, 1642,\n+ \/*   380 *\/  1646, 1673, 1675, 1636, 1714, 1637, 1677, 1674, 1678, 1694,\n+ \/*   390 *\/  1719, 1734, 1735, 1746, 1747, 1750, 1633, 1661, 1686, 1738,\n+ \/*   400 *\/  1728, 1733, 1736, 1737, 1740, 1726, 1730, 1742, 1743, 1748,\n+ \/*   410 *\/  1753,\n@@ -164666,58 +172274,58 @@\n- \/*     0 *\/  1647, 1647, 1647, 1475, 1240, 1351, 1240, 1240, 1240, 1475,\n- \/*    10 *\/  1475, 1475, 1240, 1381, 1381, 1528, 1273, 1240, 1240, 1240,\n- \/*    20 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1474, 1240, 1240,\n- \/*    30 *\/  1240, 1240, 1563, 1563, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*    40 *\/  1240, 1240, 1390, 1240, 1397, 1240, 1240, 1240, 1240, 1240,\n- \/*    50 *\/  1476, 1477, 1240, 1240, 1240, 1527, 1529, 1492, 1404, 1403,\n- \/*    60 *\/  1402, 1401, 1510, 1369, 1395, 1388, 1392, 1470, 1471, 1469,\n- \/*    70 *\/  1473, 1477, 1476, 1240, 1391, 1438, 1454, 1437, 1240, 1240,\n- \/*    80 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*    90 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   100 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   110 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   120 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   130 *\/  1446, 1453, 1452, 1451, 1460, 1450, 1447, 1440, 1439, 1441,\n- \/*   140 *\/  1442, 1240, 1240, 1264, 1240, 1240, 1261, 1315, 1240, 1240,\n- \/*   150 *\/  1240, 1240, 1240, 1547, 1546, 1240, 1443, 1240, 1273, 1432,\n- \/*   160 *\/  1431, 1457, 1444, 1456, 1455, 1535, 1599, 1598, 1493, 1240,\n- \/*   170 *\/  1240, 1240, 1240, 1240, 1240, 1563, 1240, 1240, 1240, 1240,\n- \/*   180 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   190 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1371,\n- \/*   200 *\/  1563, 1563, 1240, 1273, 1563, 1563, 1372, 1372, 1269, 1269,\n- \/*   210 *\/  1375, 1240, 1542, 1342, 1342, 1342, 1342, 1351, 1342, 1240,\n- \/*   220 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   230 *\/  1240, 1240, 1240, 1240, 1532, 1530, 1240, 1240, 1240, 1240,\n- \/*   240 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   250 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   260 *\/  1240, 1240, 1240, 1347, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   270 *\/  1240, 1240, 1240, 1240, 1240, 1592, 1240, 1505, 1329, 1347,\n- \/*   280 *\/  1347, 1347, 1347, 1349, 1330, 1328, 1341, 1274, 1247, 1639,\n- \/*   290 *\/  1407, 1396, 1348, 1396, 1636, 1394, 1407, 1407, 1394, 1407,\n- \/*   300 *\/  1348, 1636, 1290, 1615, 1285, 1381, 1381, 1381, 1371, 1371,\n- \/*   310 *\/  1371, 1371, 1375, 1375, 1472, 1348, 1341, 1240, 1639, 1639,\n- \/*   320 *\/  1357, 1357, 1638, 1638, 1357, 1493, 1623, 1416, 1318, 1324,\n- \/*   330 *\/  1324, 1324, 1324, 1357, 1258, 1394, 1623, 1623, 1394, 1416,\n- \/*   340 *\/  1318, 1394, 1318, 1394, 1357, 1258, 1509, 1633, 1357, 1258,\n- \/*   350 *\/  1483, 1357, 1258, 1357, 1258, 1483, 1316, 1316, 1316, 1305,\n- \/*   360 *\/  1240, 1240, 1483, 1316, 1290, 1316, 1305, 1316, 1316, 1581,\n- \/*   370 *\/  1240, 1487, 1487, 1483, 1357, 1573, 1573, 1384, 1384, 1389,\n- \/*   380 *\/  1375, 1478, 1357, 1240, 1389, 1387, 1385, 1394, 1308, 1595,\n- \/*   390 *\/  1595, 1591, 1591, 1591, 1644, 1644, 1542, 1608, 1273, 1273,\n- \/*   400 *\/  1273, 1273, 1608, 1292, 1292, 1274, 1274, 1273, 1608, 1240,\n- \/*   410 *\/  1240, 1240, 1240, 1240, 1240, 1603, 1240, 1537, 1494, 1361,\n- \/*   420 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   430 *\/  1240, 1240, 1240, 1240, 1548, 1240, 1240, 1240, 1240, 1240,\n- \/*   440 *\/  1240, 1240, 1240, 1240, 1240, 1421, 1240, 1243, 1539, 1240,\n- \/*   450 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1398, 1399, 1362,\n- \/*   460 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1413, 1240, 1240,\n- \/*   470 *\/  1240, 1408, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   480 *\/  1635, 1240, 1240, 1240, 1240, 1240, 1240, 1508, 1507, 1240,\n- \/*   490 *\/  1240, 1359, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   500 *\/  1240, 1240, 1240, 1240, 1240, 1288, 1240, 1240, 1240, 1240,\n- \/*   510 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   520 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1386,\n- \/*   530 *\/  1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   540 *\/  1240, 1240, 1240, 1240, 1578, 1376, 1240, 1240, 1240, 1240,\n- \/*   550 *\/  1626, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240, 1240,\n- \/*   560 *\/  1240, 1240, 1240, 1240, 1240, 1619, 1332, 1423, 1240, 1422,\n- \/*   570 *\/  1426, 1262, 1240, 1252, 1240, 1240,\n+ \/*     0 *\/  1648, 1648, 1648, 1478, 1243, 1354, 1243, 1243, 1243, 1478,\n+ \/*    10 *\/  1478, 1478, 1243, 1384, 1384, 1531, 1276, 1243, 1243, 1243,\n+ \/*    20 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1477, 1243,\n+ \/*    30 *\/  1243, 1243, 1243, 1564, 1564, 1243, 1243, 1243, 1243, 1243,\n+ \/*    40 *\/  1243, 1243, 1243, 1393, 1243, 1400, 1243, 1243, 1243, 1243,\n+ \/*    50 *\/  1243, 1479, 1480, 1243, 1243, 1243, 1530, 1532, 1495, 1407,\n+ \/*    60 *\/  1406, 1405, 1404, 1513, 1372, 1398, 1391, 1395, 1474, 1475,\n+ \/*    70 *\/  1473, 1626, 1480, 1479, 1243, 1394, 1442, 1458, 1441, 1243,\n+ \/*    80 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*    90 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   100 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   110 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   120 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   130 *\/  1243, 1450, 1457, 1456, 1455, 1464, 1454, 1451, 1444, 1443,\n+ \/*   140 *\/  1445, 1446, 1243, 1243, 1267, 1243, 1243, 1264, 1318, 1243,\n+ \/*   150 *\/  1243, 1243, 1243, 1243, 1550, 1549, 1243, 1447, 1243, 1276,\n+ \/*   160 *\/  1435, 1434, 1433, 1461, 1448, 1460, 1459, 1538, 1600, 1599,\n+ \/*   170 *\/  1496, 1243, 1243, 1243, 1243, 1243, 1243, 1564, 1243, 1243,\n+ \/*   180 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   190 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   200 *\/  1243, 1374, 1564, 1564, 1243, 1276, 1564, 1564, 1375, 1375,\n+ \/*   210 *\/  1272, 1272, 1378, 1243, 1545, 1345, 1345, 1345, 1345, 1354,\n+ \/*   220 *\/  1345, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   230 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1535, 1533, 1243, 1243,\n+ \/*   240 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   250 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   260 *\/  1243, 1243, 1243, 1243, 1243, 1350, 1243, 1243, 1243, 1243,\n+ \/*   270 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1593, 1243, 1508,\n+ \/*   280 *\/  1332, 1350, 1350, 1350, 1350, 1352, 1333, 1331, 1344, 1277,\n+ \/*   290 *\/  1250, 1640, 1410, 1399, 1351, 1399, 1637, 1397, 1410, 1410,\n+ \/*   300 *\/  1397, 1410, 1351, 1637, 1293, 1615, 1288, 1384, 1384, 1384,\n+ \/*   310 *\/  1374, 1374, 1374, 1374, 1378, 1378, 1476, 1351, 1344, 1243,\n+ \/*   320 *\/  1640, 1640, 1360, 1360, 1639, 1639, 1360, 1496, 1623, 1419,\n+ \/*   330 *\/  1321, 1327, 1327, 1327, 1327, 1360, 1261, 1397, 1623, 1623,\n+ \/*   340 *\/  1397, 1419, 1321, 1397, 1321, 1397, 1360, 1261, 1512, 1634,\n+ \/*   350 *\/  1360, 1261, 1486, 1360, 1261, 1360, 1261, 1486, 1319, 1319,\n+ \/*   360 *\/  1319, 1308, 1243, 1243, 1486, 1319, 1293, 1319, 1308, 1319,\n+ \/*   370 *\/  1319, 1582, 1243, 1490, 1490, 1486, 1360, 1574, 1574, 1387,\n+ \/*   380 *\/  1387, 1392, 1378, 1481, 1360, 1243, 1392, 1390, 1388, 1397,\n+ \/*   390 *\/  1311, 1596, 1596, 1592, 1592, 1592, 1645, 1645, 1545, 1608,\n+ \/*   400 *\/  1276, 1276, 1276, 1276, 1608, 1295, 1295, 1277, 1277, 1276,\n+ \/*   410 *\/  1608, 1243, 1243, 1243, 1243, 1243, 1243, 1603, 1243, 1540,\n+ \/*   420 *\/  1497, 1364, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   430 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1551, 1243,\n+ \/*   440 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1424,\n+ \/*   450 *\/  1243, 1246, 1542, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   460 *\/  1243, 1401, 1402, 1365, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   470 *\/  1243, 1416, 1243, 1243, 1243, 1411, 1243, 1243, 1243, 1243,\n+ \/*   480 *\/  1243, 1243, 1243, 1243, 1636, 1243, 1243, 1243, 1243, 1243,\n+ \/*   490 *\/  1243, 1511, 1510, 1243, 1243, 1362, 1243, 1243, 1243, 1243,\n+ \/*   500 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1291,\n+ \/*   510 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   520 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   530 *\/  1243, 1243, 1243, 1389, 1243, 1243, 1243, 1243, 1243, 1243,\n+ \/*   540 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1579, 1379,\n+ \/*   550 *\/  1243, 1243, 1243, 1243, 1627, 1243, 1243, 1243, 1243, 1243,\n+ \/*   560 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1619,\n+ \/*   570 *\/  1335, 1425, 1243, 1428, 1265, 1243, 1255, 1243, 1243,\n@@ -165520,53 +173128,53 @@\n- \/* 178 *\/ \"expr ::= ID|INDEXED\",\n- \/* 179 *\/ \"expr ::= JOIN_KW\",\n- \/* 180 *\/ \"expr ::= nm DOT nm\",\n- \/* 181 *\/ \"expr ::= nm DOT nm DOT nm\",\n- \/* 182 *\/ \"term ::= NULL|FLOAT|BLOB\",\n- \/* 183 *\/ \"term ::= STRING\",\n- \/* 184 *\/ \"term ::= INTEGER\",\n- \/* 185 *\/ \"expr ::= VARIABLE\",\n- \/* 186 *\/ \"expr ::= expr COLLATE ID|STRING\",\n- \/* 187 *\/ \"expr ::= CAST LP expr AS typetoken RP\",\n- \/* 188 *\/ \"expr ::= ID|INDEXED LP distinct exprlist RP\",\n- \/* 189 *\/ \"expr ::= ID|INDEXED LP STAR RP\",\n- \/* 190 *\/ \"expr ::= ID|INDEXED LP distinct exprlist RP filter_over\",\n- \/* 191 *\/ \"expr ::= ID|INDEXED LP STAR RP filter_over\",\n- \/* 192 *\/ \"term ::= CTIME_KW\",\n- \/* 193 *\/ \"expr ::= LP nexprlist COMMA expr RP\",\n- \/* 194 *\/ \"expr ::= expr AND expr\",\n- \/* 195 *\/ \"expr ::= expr OR expr\",\n- \/* 196 *\/ \"expr ::= expr LT|GT|GE|LE expr\",\n- \/* 197 *\/ \"expr ::= expr EQ|NE expr\",\n- \/* 198 *\/ \"expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr\",\n- \/* 199 *\/ \"expr ::= expr PLUS|MINUS expr\",\n- \/* 200 *\/ \"expr ::= expr STAR|SLASH|REM expr\",\n- \/* 201 *\/ \"expr ::= expr CONCAT expr\",\n- \/* 202 *\/ \"likeop ::= NOT LIKE_KW|MATCH\",\n- \/* 203 *\/ \"expr ::= expr likeop expr\",\n- \/* 204 *\/ \"expr ::= expr likeop expr ESCAPE expr\",\n- \/* 205 *\/ \"expr ::= expr ISNULL|NOTNULL\",\n- \/* 206 *\/ \"expr ::= expr NOT NULL\",\n- \/* 207 *\/ \"expr ::= expr IS expr\",\n- \/* 208 *\/ \"expr ::= expr IS NOT expr\",\n- \/* 209 *\/ \"expr ::= expr IS NOT DISTINCT FROM expr\",\n- \/* 210 *\/ \"expr ::= expr IS DISTINCT FROM expr\",\n- \/* 211 *\/ \"expr ::= NOT expr\",\n- \/* 212 *\/ \"expr ::= BITNOT expr\",\n- \/* 213 *\/ \"expr ::= PLUS|MINUS expr\",\n- \/* 214 *\/ \"expr ::= expr PTR expr\",\n- \/* 215 *\/ \"between_op ::= BETWEEN\",\n- \/* 216 *\/ \"between_op ::= NOT BETWEEN\",\n- \/* 217 *\/ \"expr ::= expr between_op expr AND expr\",\n- \/* 218 *\/ \"in_op ::= IN\",\n- \/* 219 *\/ \"in_op ::= NOT IN\",\n- \/* 220 *\/ \"expr ::= expr in_op LP exprlist RP\",\n- \/* 221 *\/ \"expr ::= LP select RP\",\n- \/* 222 *\/ \"expr ::= expr in_op LP select RP\",\n- \/* 223 *\/ \"expr ::= expr in_op nm dbnm paren_exprlist\",\n- \/* 224 *\/ \"expr ::= EXISTS LP select RP\",\n- \/* 225 *\/ \"expr ::= CASE case_operand case_exprlist case_else END\",\n- \/* 226 *\/ \"case_exprlist ::= case_exprlist WHEN expr THEN expr\",\n- \/* 227 *\/ \"case_exprlist ::= WHEN expr THEN expr\",\n- \/* 228 *\/ \"case_else ::= ELSE expr\",\n- \/* 229 *\/ \"case_else ::=\",\n- \/* 230 *\/ \"case_operand ::= expr\",\n+ \/* 178 *\/ \"expr ::= ID|INDEXED|JOIN_KW\",\n+ \/* 179 *\/ \"expr ::= nm DOT nm\",\n+ \/* 180 *\/ \"expr ::= nm DOT nm DOT nm\",\n+ \/* 181 *\/ \"term ::= NULL|FLOAT|BLOB\",\n+ \/* 182 *\/ \"term ::= STRING\",\n+ \/* 183 *\/ \"term ::= INTEGER\",\n+ \/* 184 *\/ \"expr ::= VARIABLE\",\n+ \/* 185 *\/ \"expr ::= expr COLLATE ID|STRING\",\n+ \/* 186 *\/ \"expr ::= CAST LP expr AS typetoken RP\",\n+ \/* 187 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP\",\n+ \/* 188 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP\",\n+ \/* 189 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP STAR RP\",\n+ \/* 190 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP filter_over\",\n+ \/* 191 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP filter_over\",\n+ \/* 192 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP STAR RP filter_over\",\n+ \/* 193 *\/ \"term ::= CTIME_KW\",\n+ \/* 194 *\/ \"expr ::= LP nexprlist COMMA expr RP\",\n+ \/* 195 *\/ \"expr ::= expr AND expr\",\n+ \/* 196 *\/ \"expr ::= expr OR expr\",\n+ \/* 197 *\/ \"expr ::= expr LT|GT|GE|LE expr\",\n+ \/* 198 *\/ \"expr ::= expr EQ|NE expr\",\n+ \/* 199 *\/ \"expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr\",\n+ \/* 200 *\/ \"expr ::= expr PLUS|MINUS expr\",\n+ \/* 201 *\/ \"expr ::= expr STAR|SLASH|REM expr\",\n+ \/* 202 *\/ \"expr ::= expr CONCAT expr\",\n+ \/* 203 *\/ \"likeop ::= NOT LIKE_KW|MATCH\",\n+ \/* 204 *\/ \"expr ::= expr likeop expr\",\n+ \/* 205 *\/ \"expr ::= expr likeop expr ESCAPE expr\",\n+ \/* 206 *\/ \"expr ::= expr ISNULL|NOTNULL\",\n+ \/* 207 *\/ \"expr ::= expr NOT NULL\",\n+ \/* 208 *\/ \"expr ::= expr IS expr\",\n+ \/* 209 *\/ \"expr ::= expr IS NOT expr\",\n+ \/* 210 *\/ \"expr ::= expr IS NOT DISTINCT FROM expr\",\n+ \/* 211 *\/ \"expr ::= expr IS DISTINCT FROM expr\",\n+ \/* 212 *\/ \"expr ::= NOT expr\",\n+ \/* 213 *\/ \"expr ::= BITNOT expr\",\n+ \/* 214 *\/ \"expr ::= PLUS|MINUS expr\",\n+ \/* 215 *\/ \"expr ::= expr PTR expr\",\n+ \/* 216 *\/ \"between_op ::= BETWEEN\",\n+ \/* 217 *\/ \"between_op ::= NOT BETWEEN\",\n+ \/* 218 *\/ \"expr ::= expr between_op expr AND expr\",\n+ \/* 219 *\/ \"in_op ::= IN\",\n+ \/* 220 *\/ \"in_op ::= NOT IN\",\n+ \/* 221 *\/ \"expr ::= expr in_op LP exprlist RP\",\n+ \/* 222 *\/ \"expr ::= LP select RP\",\n+ \/* 223 *\/ \"expr ::= expr in_op LP select RP\",\n+ \/* 224 *\/ \"expr ::= expr in_op nm dbnm paren_exprlist\",\n+ \/* 225 *\/ \"expr ::= EXISTS LP select RP\",\n+ \/* 226 *\/ \"expr ::= CASE case_operand case_exprlist case_else END\",\n+ \/* 227 *\/ \"case_exprlist ::= case_exprlist WHEN expr THEN expr\",\n+ \/* 228 *\/ \"case_exprlist ::= WHEN expr THEN expr\",\n+ \/* 229 *\/ \"case_else ::= ELSE expr\",\n+ \/* 230 *\/ \"case_else ::=\",\n@@ -165653,94 +173261,94 @@\n- \/* 311 *\/ \"windowdefn_list ::= windowdefn\",\n- \/* 312 *\/ \"windowdefn_list ::= windowdefn_list COMMA windowdefn\",\n- \/* 313 *\/ \"windowdefn ::= nm AS LP window RP\",\n- \/* 314 *\/ \"window ::= PARTITION BY nexprlist orderby_opt frame_opt\",\n- \/* 315 *\/ \"window ::= nm PARTITION BY nexprlist orderby_opt frame_opt\",\n- \/* 316 *\/ \"window ::= ORDER BY sortlist frame_opt\",\n- \/* 317 *\/ \"window ::= nm ORDER BY sortlist frame_opt\",\n- \/* 318 *\/ \"window ::= frame_opt\",\n- \/* 319 *\/ \"window ::= nm frame_opt\",\n- \/* 320 *\/ \"frame_opt ::=\",\n- \/* 321 *\/ \"frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt\",\n- \/* 322 *\/ \"frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt\",\n- \/* 323 *\/ \"range_or_rows ::= RANGE|ROWS|GROUPS\",\n- \/* 324 *\/ \"frame_bound_s ::= frame_bound\",\n- \/* 325 *\/ \"frame_bound_s ::= UNBOUNDED PRECEDING\",\n- \/* 326 *\/ \"frame_bound_e ::= frame_bound\",\n- \/* 327 *\/ \"frame_bound_e ::= UNBOUNDED FOLLOWING\",\n- \/* 328 *\/ \"frame_bound ::= expr PRECEDING|FOLLOWING\",\n- \/* 329 *\/ \"frame_bound ::= CURRENT ROW\",\n- \/* 330 *\/ \"frame_exclude_opt ::=\",\n- \/* 331 *\/ \"frame_exclude_opt ::= EXCLUDE frame_exclude\",\n- \/* 332 *\/ \"frame_exclude ::= NO OTHERS\",\n- \/* 333 *\/ \"frame_exclude ::= CURRENT ROW\",\n- \/* 334 *\/ \"frame_exclude ::= GROUP|TIES\",\n- \/* 335 *\/ \"window_clause ::= WINDOW windowdefn_list\",\n- \/* 336 *\/ \"filter_over ::= filter_clause over_clause\",\n- \/* 337 *\/ \"filter_over ::= over_clause\",\n- \/* 338 *\/ \"filter_over ::= filter_clause\",\n- \/* 339 *\/ \"over_clause ::= OVER LP window RP\",\n- \/* 340 *\/ \"over_clause ::= OVER nm\",\n- \/* 341 *\/ \"filter_clause ::= FILTER LP WHERE expr RP\",\n- \/* 342 *\/ \"input ::= cmdlist\",\n- \/* 343 *\/ \"cmdlist ::= cmdlist ecmd\",\n- \/* 344 *\/ \"cmdlist ::= ecmd\",\n- \/* 345 *\/ \"ecmd ::= SEMI\",\n- \/* 346 *\/ \"ecmd ::= cmdx SEMI\",\n- \/* 347 *\/ \"ecmd ::= explain cmdx SEMI\",\n- \/* 348 *\/ \"trans_opt ::=\",\n- \/* 349 *\/ \"trans_opt ::= TRANSACTION\",\n- \/* 350 *\/ \"trans_opt ::= TRANSACTION nm\",\n- \/* 351 *\/ \"savepoint_opt ::= SAVEPOINT\",\n- \/* 352 *\/ \"savepoint_opt ::=\",\n- \/* 353 *\/ \"cmd ::= create_table create_table_args\",\n- \/* 354 *\/ \"table_option_set ::= table_option\",\n- \/* 355 *\/ \"columnlist ::= columnlist COMMA columnname carglist\",\n- \/* 356 *\/ \"columnlist ::= columnname carglist\",\n- \/* 357 *\/ \"nm ::= ID|INDEXED\",\n- \/* 358 *\/ \"nm ::= STRING\",\n- \/* 359 *\/ \"nm ::= JOIN_KW\",\n- \/* 360 *\/ \"typetoken ::= typename\",\n- \/* 361 *\/ \"typename ::= ID|STRING\",\n- \/* 362 *\/ \"signed ::= plus_num\",\n- \/* 363 *\/ \"signed ::= minus_num\",\n- \/* 364 *\/ \"carglist ::= carglist ccons\",\n- \/* 365 *\/ \"carglist ::=\",\n- \/* 366 *\/ \"ccons ::= NULL onconf\",\n- \/* 367 *\/ \"ccons ::= GENERATED ALWAYS AS generated\",\n- \/* 368 *\/ \"ccons ::= AS generated\",\n- \/* 369 *\/ \"conslist_opt ::= COMMA conslist\",\n- \/* 370 *\/ \"conslist ::= conslist tconscomma tcons\",\n- \/* 371 *\/ \"conslist ::= tcons\",\n- \/* 372 *\/ \"tconscomma ::=\",\n- \/* 373 *\/ \"defer_subclause_opt ::= defer_subclause\",\n- \/* 374 *\/ \"resolvetype ::= raisetype\",\n- \/* 375 *\/ \"selectnowith ::= oneselect\",\n- \/* 376 *\/ \"oneselect ::= values\",\n- \/* 377 *\/ \"sclp ::= selcollist COMMA\",\n- \/* 378 *\/ \"as ::= ID|STRING\",\n- \/* 379 *\/ \"indexed_opt ::= indexed_by\",\n- \/* 380 *\/ \"returning ::=\",\n- \/* 381 *\/ \"expr ::= term\",\n- \/* 382 *\/ \"likeop ::= LIKE_KW|MATCH\",\n- \/* 383 *\/ \"exprlist ::= nexprlist\",\n- \/* 384 *\/ \"nmnum ::= plus_num\",\n- \/* 385 *\/ \"nmnum ::= nm\",\n- \/* 386 *\/ \"nmnum ::= ON\",\n- \/* 387 *\/ \"nmnum ::= DELETE\",\n- \/* 388 *\/ \"nmnum ::= DEFAULT\",\n- \/* 389 *\/ \"plus_num ::= INTEGER|FLOAT\",\n- \/* 390 *\/ \"foreach_clause ::=\",\n- \/* 391 *\/ \"foreach_clause ::= FOR EACH ROW\",\n- \/* 392 *\/ \"trnm ::= nm\",\n- \/* 393 *\/ \"tridxby ::=\",\n- \/* 394 *\/ \"database_kw_opt ::= DATABASE\",\n- \/* 395 *\/ \"database_kw_opt ::=\",\n- \/* 396 *\/ \"kwcolumn_opt ::=\",\n- \/* 397 *\/ \"kwcolumn_opt ::= COLUMNKW\",\n- \/* 398 *\/ \"vtabarglist ::= vtabarg\",\n- \/* 399 *\/ \"vtabarglist ::= vtabarglist COMMA vtabarg\",\n- \/* 400 *\/ \"vtabarg ::= vtabarg vtabargtoken\",\n- \/* 401 *\/ \"anylist ::=\",\n- \/* 402 *\/ \"anylist ::= anylist LP anylist RP\",\n- \/* 403 *\/ \"anylist ::= anylist ANY\",\n- \/* 404 *\/ \"with ::=\",\n+ \/* 311 *\/ \"windowdefn_list ::= windowdefn_list COMMA windowdefn\",\n+ \/* 312 *\/ \"windowdefn ::= nm AS LP window RP\",\n+ \/* 313 *\/ \"window ::= PARTITION BY nexprlist orderby_opt frame_opt\",\n+ \/* 314 *\/ \"window ::= nm PARTITION BY nexprlist orderby_opt frame_opt\",\n+ \/* 315 *\/ \"window ::= ORDER BY sortlist frame_opt\",\n+ \/* 316 *\/ \"window ::= nm ORDER BY sortlist frame_opt\",\n+ \/* 317 *\/ \"window ::= nm frame_opt\",\n+ \/* 318 *\/ \"frame_opt ::=\",\n+ \/* 319 *\/ \"frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt\",\n+ \/* 320 *\/ \"frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt\",\n+ \/* 321 *\/ \"range_or_rows ::= RANGE|ROWS|GROUPS\",\n+ \/* 322 *\/ \"frame_bound_s ::= frame_bound\",\n+ \/* 323 *\/ \"frame_bound_s ::= UNBOUNDED PRECEDING\",\n+ \/* 324 *\/ \"frame_bound_e ::= frame_bound\",\n+ \/* 325 *\/ \"frame_bound_e ::= UNBOUNDED FOLLOWING\",\n+ \/* 326 *\/ \"frame_bound ::= expr PRECEDING|FOLLOWING\",\n+ \/* 327 *\/ \"frame_bound ::= CURRENT ROW\",\n+ \/* 328 *\/ \"frame_exclude_opt ::=\",\n+ \/* 329 *\/ \"frame_exclude_opt ::= EXCLUDE frame_exclude\",\n+ \/* 330 *\/ \"frame_exclude ::= NO OTHERS\",\n+ \/* 331 *\/ \"frame_exclude ::= CURRENT ROW\",\n+ \/* 332 *\/ \"frame_exclude ::= GROUP|TIES\",\n+ \/* 333 *\/ \"window_clause ::= WINDOW windowdefn_list\",\n+ \/* 334 *\/ \"filter_over ::= filter_clause over_clause\",\n+ \/* 335 *\/ \"filter_over ::= over_clause\",\n+ \/* 336 *\/ \"filter_over ::= filter_clause\",\n+ \/* 337 *\/ \"over_clause ::= OVER LP window RP\",\n+ \/* 338 *\/ \"over_clause ::= OVER nm\",\n+ \/* 339 *\/ \"filter_clause ::= FILTER LP WHERE expr RP\",\n+ \/* 340 *\/ \"input ::= cmdlist\",\n+ \/* 341 *\/ \"cmdlist ::= cmdlist ecmd\",\n+ \/* 342 *\/ \"cmdlist ::= ecmd\",\n+ \/* 343 *\/ \"ecmd ::= SEMI\",\n+ \/* 344 *\/ \"ecmd ::= cmdx SEMI\",\n+ \/* 345 *\/ \"ecmd ::= explain cmdx SEMI\",\n+ \/* 346 *\/ \"trans_opt ::=\",\n+ \/* 347 *\/ \"trans_opt ::= TRANSACTION\",\n+ \/* 348 *\/ \"trans_opt ::= TRANSACTION nm\",\n+ \/* 349 *\/ \"savepoint_opt ::= SAVEPOINT\",\n+ \/* 350 *\/ \"savepoint_opt ::=\",\n+ \/* 351 *\/ \"cmd ::= create_table create_table_args\",\n+ \/* 352 *\/ \"table_option_set ::= table_option\",\n+ \/* 353 *\/ \"columnlist ::= columnlist COMMA columnname carglist\",\n+ \/* 354 *\/ \"columnlist ::= columnname carglist\",\n+ \/* 355 *\/ \"nm ::= ID|INDEXED|JOIN_KW\",\n+ \/* 356 *\/ \"nm ::= STRING\",\n+ \/* 357 *\/ \"typetoken ::= typename\",\n+ \/* 358 *\/ \"typename ::= ID|STRING\",\n+ \/* 359 *\/ \"signed ::= plus_num\",\n+ \/* 360 *\/ \"signed ::= minus_num\",\n+ \/* 361 *\/ \"carglist ::= carglist ccons\",\n+ \/* 362 *\/ \"carglist ::=\",\n+ \/* 363 *\/ \"ccons ::= NULL onconf\",\n+ \/* 364 *\/ \"ccons ::= GENERATED ALWAYS AS generated\",\n+ \/* 365 *\/ \"ccons ::= AS generated\",\n+ \/* 366 *\/ \"conslist_opt ::= COMMA conslist\",\n+ \/* 367 *\/ \"conslist ::= conslist tconscomma tcons\",\n+ \/* 368 *\/ \"conslist ::= tcons\",\n+ \/* 369 *\/ \"tconscomma ::=\",\n+ \/* 370 *\/ \"defer_subclause_opt ::= defer_subclause\",\n+ \/* 371 *\/ \"resolvetype ::= raisetype\",\n+ \/* 372 *\/ \"selectnowith ::= oneselect\",\n+ \/* 373 *\/ \"oneselect ::= values\",\n+ \/* 374 *\/ \"sclp ::= selcollist COMMA\",\n+ \/* 375 *\/ \"as ::= ID|STRING\",\n+ \/* 376 *\/ \"indexed_opt ::= indexed_by\",\n+ \/* 377 *\/ \"returning ::=\",\n+ \/* 378 *\/ \"expr ::= term\",\n+ \/* 379 *\/ \"likeop ::= LIKE_KW|MATCH\",\n+ \/* 380 *\/ \"case_operand ::= expr\",\n+ \/* 381 *\/ \"exprlist ::= nexprlist\",\n+ \/* 382 *\/ \"nmnum ::= plus_num\",\n+ \/* 383 *\/ \"nmnum ::= nm\",\n+ \/* 384 *\/ \"nmnum ::= ON\",\n+ \/* 385 *\/ \"nmnum ::= DELETE\",\n+ \/* 386 *\/ \"nmnum ::= DEFAULT\",\n+ \/* 387 *\/ \"plus_num ::= INTEGER|FLOAT\",\n+ \/* 388 *\/ \"foreach_clause ::=\",\n+ \/* 389 *\/ \"foreach_clause ::= FOR EACH ROW\",\n+ \/* 390 *\/ \"trnm ::= nm\",\n+ \/* 391 *\/ \"tridxby ::=\",\n+ \/* 392 *\/ \"database_kw_opt ::= DATABASE\",\n+ \/* 393 *\/ \"database_kw_opt ::=\",\n+ \/* 394 *\/ \"kwcolumn_opt ::=\",\n+ \/* 395 *\/ \"kwcolumn_opt ::= COLUMNKW\",\n+ \/* 396 *\/ \"vtabarglist ::= vtabarg\",\n+ \/* 397 *\/ \"vtabarglist ::= vtabarglist COMMA vtabarg\",\n+ \/* 398 *\/ \"vtabarg ::= vtabarg vtabargtoken\",\n+ \/* 399 *\/ \"anylist ::=\",\n+ \/* 400 *\/ \"anylist ::= anylist LP anylist RP\",\n+ \/* 401 *\/ \"anylist ::= anylist ANY\",\n+ \/* 402 *\/ \"with ::=\",\n+ \/* 403 *\/ \"windowdefn_list ::= windowdefn\",\n+ \/* 404 *\/ \"window ::= frame_opt\",\n@@ -166431,53 +174039,53 @@\n-   217,  \/* (178) expr ::= ID|INDEXED *\/\n-   217,  \/* (179) expr ::= JOIN_KW *\/\n-   217,  \/* (180) expr ::= nm DOT nm *\/\n-   217,  \/* (181) expr ::= nm DOT nm DOT nm *\/\n-   216,  \/* (182) term ::= NULL|FLOAT|BLOB *\/\n-   216,  \/* (183) term ::= STRING *\/\n-   216,  \/* (184) term ::= INTEGER *\/\n-   217,  \/* (185) expr ::= VARIABLE *\/\n-   217,  \/* (186) expr ::= expr COLLATE ID|STRING *\/\n-   217,  \/* (187) expr ::= CAST LP expr AS typetoken RP *\/\n-   217,  \/* (188) expr ::= ID|INDEXED LP distinct exprlist RP *\/\n-   217,  \/* (189) expr ::= ID|INDEXED LP STAR RP *\/\n-   217,  \/* (190) expr ::= ID|INDEXED LP distinct exprlist RP filter_over *\/\n-   217,  \/* (191) expr ::= ID|INDEXED LP STAR RP filter_over *\/\n-   216,  \/* (192) term ::= CTIME_KW *\/\n-   217,  \/* (193) expr ::= LP nexprlist COMMA expr RP *\/\n-   217,  \/* (194) expr ::= expr AND expr *\/\n-   217,  \/* (195) expr ::= expr OR expr *\/\n-   217,  \/* (196) expr ::= expr LT|GT|GE|LE expr *\/\n-   217,  \/* (197) expr ::= expr EQ|NE expr *\/\n-   217,  \/* (198) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/\n-   217,  \/* (199) expr ::= expr PLUS|MINUS expr *\/\n-   217,  \/* (200) expr ::= expr STAR|SLASH|REM expr *\/\n-   217,  \/* (201) expr ::= expr CONCAT expr *\/\n-   274,  \/* (202) likeop ::= NOT LIKE_KW|MATCH *\/\n-   217,  \/* (203) expr ::= expr likeop expr *\/\n-   217,  \/* (204) expr ::= expr likeop expr ESCAPE expr *\/\n-   217,  \/* (205) expr ::= expr ISNULL|NOTNULL *\/\n-   217,  \/* (206) expr ::= expr NOT NULL *\/\n-   217,  \/* (207) expr ::= expr IS expr *\/\n-   217,  \/* (208) expr ::= expr IS NOT expr *\/\n-   217,  \/* (209) expr ::= expr IS NOT DISTINCT FROM expr *\/\n-   217,  \/* (210) expr ::= expr IS DISTINCT FROM expr *\/\n-   217,  \/* (211) expr ::= NOT expr *\/\n-   217,  \/* (212) expr ::= BITNOT expr *\/\n-   217,  \/* (213) expr ::= PLUS|MINUS expr *\/\n-   217,  \/* (214) expr ::= expr PTR expr *\/\n-   275,  \/* (215) between_op ::= BETWEEN *\/\n-   275,  \/* (216) between_op ::= NOT BETWEEN *\/\n-   217,  \/* (217) expr ::= expr between_op expr AND expr *\/\n-   276,  \/* (218) in_op ::= IN *\/\n-   276,  \/* (219) in_op ::= NOT IN *\/\n-   217,  \/* (220) expr ::= expr in_op LP exprlist RP *\/\n-   217,  \/* (221) expr ::= LP select RP *\/\n-   217,  \/* (222) expr ::= expr in_op LP select RP *\/\n-   217,  \/* (223) expr ::= expr in_op nm dbnm paren_exprlist *\/\n-   217,  \/* (224) expr ::= EXISTS LP select RP *\/\n-   217,  \/* (225) expr ::= CASE case_operand case_exprlist case_else END *\/\n-   279,  \/* (226) case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n-   279,  \/* (227) case_exprlist ::= WHEN expr THEN expr *\/\n-   280,  \/* (228) case_else ::= ELSE expr *\/\n-   280,  \/* (229) case_else ::= *\/\n-   278,  \/* (230) case_operand ::= expr *\/\n+   217,  \/* (178) expr ::= ID|INDEXED|JOIN_KW *\/\n+   217,  \/* (179) expr ::= nm DOT nm *\/\n+   217,  \/* (180) expr ::= nm DOT nm DOT nm *\/\n+   216,  \/* (181) term ::= NULL|FLOAT|BLOB *\/\n+   216,  \/* (182) term ::= STRING *\/\n+   216,  \/* (183) term ::= INTEGER *\/\n+   217,  \/* (184) expr ::= VARIABLE *\/\n+   217,  \/* (185) expr ::= expr COLLATE ID|STRING *\/\n+   217,  \/* (186) expr ::= CAST LP expr AS typetoken RP *\/\n+   217,  \/* (187) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP *\/\n+   217,  \/* (188) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP *\/\n+   217,  \/* (189) expr ::= ID|INDEXED|JOIN_KW LP STAR RP *\/\n+   217,  \/* (190) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP filter_over *\/\n+   217,  \/* (191) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP filter_over *\/\n+   217,  \/* (192) expr ::= ID|INDEXED|JOIN_KW LP STAR RP filter_over *\/\n+   216,  \/* (193) term ::= CTIME_KW *\/\n+   217,  \/* (194) expr ::= LP nexprlist COMMA expr RP *\/\n+   217,  \/* (195) expr ::= expr AND expr *\/\n+   217,  \/* (196) expr ::= expr OR expr *\/\n+   217,  \/* (197) expr ::= expr LT|GT|GE|LE expr *\/\n+   217,  \/* (198) expr ::= expr EQ|NE expr *\/\n+   217,  \/* (199) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/\n+   217,  \/* (200) expr ::= expr PLUS|MINUS expr *\/\n+   217,  \/* (201) expr ::= expr STAR|SLASH|REM expr *\/\n+   217,  \/* (202) expr ::= expr CONCAT expr *\/\n+   274,  \/* (203) likeop ::= NOT LIKE_KW|MATCH *\/\n+   217,  \/* (204) expr ::= expr likeop expr *\/\n+   217,  \/* (205) expr ::= expr likeop expr ESCAPE expr *\/\n+   217,  \/* (206) expr ::= expr ISNULL|NOTNULL *\/\n+   217,  \/* (207) expr ::= expr NOT NULL *\/\n+   217,  \/* (208) expr ::= expr IS expr *\/\n+   217,  \/* (209) expr ::= expr IS NOT expr *\/\n+   217,  \/* (210) expr ::= expr IS NOT DISTINCT FROM expr *\/\n+   217,  \/* (211) expr ::= expr IS DISTINCT FROM expr *\/\n+   217,  \/* (212) expr ::= NOT expr *\/\n+   217,  \/* (213) expr ::= BITNOT expr *\/\n+   217,  \/* (214) expr ::= PLUS|MINUS expr *\/\n+   217,  \/* (215) expr ::= expr PTR expr *\/\n+   275,  \/* (216) between_op ::= BETWEEN *\/\n+   275,  \/* (217) between_op ::= NOT BETWEEN *\/\n+   217,  \/* (218) expr ::= expr between_op expr AND expr *\/\n+   276,  \/* (219) in_op ::= IN *\/\n+   276,  \/* (220) in_op ::= NOT IN *\/\n+   217,  \/* (221) expr ::= expr in_op LP exprlist RP *\/\n+   217,  \/* (222) expr ::= LP select RP *\/\n+   217,  \/* (223) expr ::= expr in_op LP select RP *\/\n+   217,  \/* (224) expr ::= expr in_op nm dbnm paren_exprlist *\/\n+   217,  \/* (225) expr ::= EXISTS LP select RP *\/\n+   217,  \/* (226) expr ::= CASE case_operand case_exprlist case_else END *\/\n+   279,  \/* (227) case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n+   279,  \/* (228) case_exprlist ::= WHEN expr THEN expr *\/\n+   280,  \/* (229) case_else ::= ELSE expr *\/\n+   280,  \/* (230) case_else ::= *\/\n@@ -166564,94 +174172,94 @@\n-   306,  \/* (311) windowdefn_list ::= windowdefn *\/\n-   306,  \/* (312) windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n-   307,  \/* (313) windowdefn ::= nm AS LP window RP *\/\n-   308,  \/* (314) window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n-   308,  \/* (315) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n-   308,  \/* (316) window ::= ORDER BY sortlist frame_opt *\/\n-   308,  \/* (317) window ::= nm ORDER BY sortlist frame_opt *\/\n-   308,  \/* (318) window ::= frame_opt *\/\n-   308,  \/* (319) window ::= nm frame_opt *\/\n-   309,  \/* (320) frame_opt ::= *\/\n-   309,  \/* (321) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n-   309,  \/* (322) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n-   313,  \/* (323) range_or_rows ::= RANGE|ROWS|GROUPS *\/\n-   315,  \/* (324) frame_bound_s ::= frame_bound *\/\n-   315,  \/* (325) frame_bound_s ::= UNBOUNDED PRECEDING *\/\n-   316,  \/* (326) frame_bound_e ::= frame_bound *\/\n-   316,  \/* (327) frame_bound_e ::= UNBOUNDED FOLLOWING *\/\n-   314,  \/* (328) frame_bound ::= expr PRECEDING|FOLLOWING *\/\n-   314,  \/* (329) frame_bound ::= CURRENT ROW *\/\n-   317,  \/* (330) frame_exclude_opt ::= *\/\n-   317,  \/* (331) frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n-   318,  \/* (332) frame_exclude ::= NO OTHERS *\/\n-   318,  \/* (333) frame_exclude ::= CURRENT ROW *\/\n-   318,  \/* (334) frame_exclude ::= GROUP|TIES *\/\n-   251,  \/* (335) window_clause ::= WINDOW windowdefn_list *\/\n-   273,  \/* (336) filter_over ::= filter_clause over_clause *\/\n-   273,  \/* (337) filter_over ::= over_clause *\/\n-   273,  \/* (338) filter_over ::= filter_clause *\/\n-   312,  \/* (339) over_clause ::= OVER LP window RP *\/\n-   312,  \/* (340) over_clause ::= OVER nm *\/\n-   311,  \/* (341) filter_clause ::= FILTER LP WHERE expr RP *\/\n-   185,  \/* (342) input ::= cmdlist *\/\n-   186,  \/* (343) cmdlist ::= cmdlist ecmd *\/\n-   186,  \/* (344) cmdlist ::= ecmd *\/\n-   187,  \/* (345) ecmd ::= SEMI *\/\n-   187,  \/* (346) ecmd ::= cmdx SEMI *\/\n-   187,  \/* (347) ecmd ::= explain cmdx SEMI *\/\n-   192,  \/* (348) trans_opt ::= *\/\n-   192,  \/* (349) trans_opt ::= TRANSACTION *\/\n-   192,  \/* (350) trans_opt ::= TRANSACTION nm *\/\n-   194,  \/* (351) savepoint_opt ::= SAVEPOINT *\/\n-   194,  \/* (352) savepoint_opt ::= *\/\n-   190,  \/* (353) cmd ::= create_table create_table_args *\/\n-   203,  \/* (354) table_option_set ::= table_option *\/\n-   201,  \/* (355) columnlist ::= columnlist COMMA columnname carglist *\/\n-   201,  \/* (356) columnlist ::= columnname carglist *\/\n-   193,  \/* (357) nm ::= ID|INDEXED *\/\n-   193,  \/* (358) nm ::= STRING *\/\n-   193,  \/* (359) nm ::= JOIN_KW *\/\n-   208,  \/* (360) typetoken ::= typename *\/\n-   209,  \/* (361) typename ::= ID|STRING *\/\n-   210,  \/* (362) signed ::= plus_num *\/\n-   210,  \/* (363) signed ::= minus_num *\/\n-   207,  \/* (364) carglist ::= carglist ccons *\/\n-   207,  \/* (365) carglist ::= *\/\n-   215,  \/* (366) ccons ::= NULL onconf *\/\n-   215,  \/* (367) ccons ::= GENERATED ALWAYS AS generated *\/\n-   215,  \/* (368) ccons ::= AS generated *\/\n-   202,  \/* (369) conslist_opt ::= COMMA conslist *\/\n-   228,  \/* (370) conslist ::= conslist tconscomma tcons *\/\n-   228,  \/* (371) conslist ::= tcons *\/\n-   229,  \/* (372) tconscomma ::= *\/\n-   233,  \/* (373) defer_subclause_opt ::= defer_subclause *\/\n-   235,  \/* (374) resolvetype ::= raisetype *\/\n-   239,  \/* (375) selectnowith ::= oneselect *\/\n-   240,  \/* (376) oneselect ::= values *\/\n-   254,  \/* (377) sclp ::= selcollist COMMA *\/\n-   255,  \/* (378) as ::= ID|STRING *\/\n-   264,  \/* (379) indexed_opt ::= indexed_by *\/\n-   272,  \/* (380) returning ::= *\/\n-   217,  \/* (381) expr ::= term *\/\n-   274,  \/* (382) likeop ::= LIKE_KW|MATCH *\/\n-   261,  \/* (383) exprlist ::= nexprlist *\/\n-   284,  \/* (384) nmnum ::= plus_num *\/\n-   284,  \/* (385) nmnum ::= nm *\/\n-   284,  \/* (386) nmnum ::= ON *\/\n-   284,  \/* (387) nmnum ::= DELETE *\/\n-   284,  \/* (388) nmnum ::= DEFAULT *\/\n-   211,  \/* (389) plus_num ::= INTEGER|FLOAT *\/\n-   289,  \/* (390) foreach_clause ::= *\/\n-   289,  \/* (391) foreach_clause ::= FOR EACH ROW *\/\n-   292,  \/* (392) trnm ::= nm *\/\n-   293,  \/* (393) tridxby ::= *\/\n-   294,  \/* (394) database_kw_opt ::= DATABASE *\/\n-   294,  \/* (395) database_kw_opt ::= *\/\n-   297,  \/* (396) kwcolumn_opt ::= *\/\n-   297,  \/* (397) kwcolumn_opt ::= COLUMNKW *\/\n-   299,  \/* (398) vtabarglist ::= vtabarg *\/\n-   299,  \/* (399) vtabarglist ::= vtabarglist COMMA vtabarg *\/\n-   300,  \/* (400) vtabarg ::= vtabarg vtabargtoken *\/\n-   303,  \/* (401) anylist ::= *\/\n-   303,  \/* (402) anylist ::= anylist LP anylist RP *\/\n-   303,  \/* (403) anylist ::= anylist ANY *\/\n-   266,  \/* (404) with ::= *\/\n+   306,  \/* (311) windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n+   307,  \/* (312) windowdefn ::= nm AS LP window RP *\/\n+   308,  \/* (313) window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n+   308,  \/* (314) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n+   308,  \/* (315) window ::= ORDER BY sortlist frame_opt *\/\n+   308,  \/* (316) window ::= nm ORDER BY sortlist frame_opt *\/\n+   308,  \/* (317) window ::= nm frame_opt *\/\n+   309,  \/* (318) frame_opt ::= *\/\n+   309,  \/* (319) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n+   309,  \/* (320) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n+   313,  \/* (321) range_or_rows ::= RANGE|ROWS|GROUPS *\/\n+   315,  \/* (322) frame_bound_s ::= frame_bound *\/\n+   315,  \/* (323) frame_bound_s ::= UNBOUNDED PRECEDING *\/\n+   316,  \/* (324) frame_bound_e ::= frame_bound *\/\n+   316,  \/* (325) frame_bound_e ::= UNBOUNDED FOLLOWING *\/\n+   314,  \/* (326) frame_bound ::= expr PRECEDING|FOLLOWING *\/\n+   314,  \/* (327) frame_bound ::= CURRENT ROW *\/\n+   317,  \/* (328) frame_exclude_opt ::= *\/\n+   317,  \/* (329) frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n+   318,  \/* (330) frame_exclude ::= NO OTHERS *\/\n+   318,  \/* (331) frame_exclude ::= CURRENT ROW *\/\n+   318,  \/* (332) frame_exclude ::= GROUP|TIES *\/\n+   251,  \/* (333) window_clause ::= WINDOW windowdefn_list *\/\n+   273,  \/* (334) filter_over ::= filter_clause over_clause *\/\n+   273,  \/* (335) filter_over ::= over_clause *\/\n+   273,  \/* (336) filter_over ::= filter_clause *\/\n+   312,  \/* (337) over_clause ::= OVER LP window RP *\/\n+   312,  \/* (338) over_clause ::= OVER nm *\/\n+   311,  \/* (339) filter_clause ::= FILTER LP WHERE expr RP *\/\n+   185,  \/* (340) input ::= cmdlist *\/\n+   186,  \/* (341) cmdlist ::= cmdlist ecmd *\/\n+   186,  \/* (342) cmdlist ::= ecmd *\/\n+   187,  \/* (343) ecmd ::= SEMI *\/\n+   187,  \/* (344) ecmd ::= cmdx SEMI *\/\n+   187,  \/* (345) ecmd ::= explain cmdx SEMI *\/\n+   192,  \/* (346) trans_opt ::= *\/\n+   192,  \/* (347) trans_opt ::= TRANSACTION *\/\n+   192,  \/* (348) trans_opt ::= TRANSACTION nm *\/\n+   194,  \/* (349) savepoint_opt ::= SAVEPOINT *\/\n+   194,  \/* (350) savepoint_opt ::= *\/\n+   190,  \/* (351) cmd ::= create_table create_table_args *\/\n+   203,  \/* (352) table_option_set ::= table_option *\/\n+   201,  \/* (353) columnlist ::= columnlist COMMA columnname carglist *\/\n+   201,  \/* (354) columnlist ::= columnname carglist *\/\n+   193,  \/* (355) nm ::= ID|INDEXED|JOIN_KW *\/\n+   193,  \/* (356) nm ::= STRING *\/\n+   208,  \/* (357) typetoken ::= typename *\/\n+   209,  \/* (358) typename ::= ID|STRING *\/\n+   210,  \/* (359) signed ::= plus_num *\/\n+   210,  \/* (360) signed ::= minus_num *\/\n+   207,  \/* (361) carglist ::= carglist ccons *\/\n+   207,  \/* (362) carglist ::= *\/\n+   215,  \/* (363) ccons ::= NULL onconf *\/\n+   215,  \/* (364) ccons ::= GENERATED ALWAYS AS generated *\/\n+   215,  \/* (365) ccons ::= AS generated *\/\n+   202,  \/* (366) conslist_opt ::= COMMA conslist *\/\n+   228,  \/* (367) conslist ::= conslist tconscomma tcons *\/\n+   228,  \/* (368) conslist ::= tcons *\/\n+   229,  \/* (369) tconscomma ::= *\/\n+   233,  \/* (370) defer_subclause_opt ::= defer_subclause *\/\n+   235,  \/* (371) resolvetype ::= raisetype *\/\n+   239,  \/* (372) selectnowith ::= oneselect *\/\n+   240,  \/* (373) oneselect ::= values *\/\n+   254,  \/* (374) sclp ::= selcollist COMMA *\/\n+   255,  \/* (375) as ::= ID|STRING *\/\n+   264,  \/* (376) indexed_opt ::= indexed_by *\/\n+   272,  \/* (377) returning ::= *\/\n+   217,  \/* (378) expr ::= term *\/\n+   274,  \/* (379) likeop ::= LIKE_KW|MATCH *\/\n+   278,  \/* (380) case_operand ::= expr *\/\n+   261,  \/* (381) exprlist ::= nexprlist *\/\n+   284,  \/* (382) nmnum ::= plus_num *\/\n+   284,  \/* (383) nmnum ::= nm *\/\n+   284,  \/* (384) nmnum ::= ON *\/\n+   284,  \/* (385) nmnum ::= DELETE *\/\n+   284,  \/* (386) nmnum ::= DEFAULT *\/\n+   211,  \/* (387) plus_num ::= INTEGER|FLOAT *\/\n+   289,  \/* (388) foreach_clause ::= *\/\n+   289,  \/* (389) foreach_clause ::= FOR EACH ROW *\/\n+   292,  \/* (390) trnm ::= nm *\/\n+   293,  \/* (391) tridxby ::= *\/\n+   294,  \/* (392) database_kw_opt ::= DATABASE *\/\n+   294,  \/* (393) database_kw_opt ::= *\/\n+   297,  \/* (394) kwcolumn_opt ::= *\/\n+   297,  \/* (395) kwcolumn_opt ::= COLUMNKW *\/\n+   299,  \/* (396) vtabarglist ::= vtabarg *\/\n+   299,  \/* (397) vtabarglist ::= vtabarglist COMMA vtabarg *\/\n+   300,  \/* (398) vtabarg ::= vtabarg vtabargtoken *\/\n+   303,  \/* (399) anylist ::= *\/\n+   303,  \/* (400) anylist ::= anylist LP anylist RP *\/\n+   303,  \/* (401) anylist ::= anylist ANY *\/\n+   266,  \/* (402) with ::= *\/\n+   306,  \/* (403) windowdefn_list ::= windowdefn *\/\n+   308,  \/* (404) window ::= frame_opt *\/\n@@ -166841,53 +174449,53 @@\n-   -1,  \/* (178) expr ::= ID|INDEXED *\/\n-   -1,  \/* (179) expr ::= JOIN_KW *\/\n-   -3,  \/* (180) expr ::= nm DOT nm *\/\n-   -5,  \/* (181) expr ::= nm DOT nm DOT nm *\/\n-   -1,  \/* (182) term ::= NULL|FLOAT|BLOB *\/\n-   -1,  \/* (183) term ::= STRING *\/\n-   -1,  \/* (184) term ::= INTEGER *\/\n-   -1,  \/* (185) expr ::= VARIABLE *\/\n-   -3,  \/* (186) expr ::= expr COLLATE ID|STRING *\/\n-   -6,  \/* (187) expr ::= CAST LP expr AS typetoken RP *\/\n-   -5,  \/* (188) expr ::= ID|INDEXED LP distinct exprlist RP *\/\n-   -4,  \/* (189) expr ::= ID|INDEXED LP STAR RP *\/\n-   -6,  \/* (190) expr ::= ID|INDEXED LP distinct exprlist RP filter_over *\/\n-   -5,  \/* (191) expr ::= ID|INDEXED LP STAR RP filter_over *\/\n-   -1,  \/* (192) term ::= CTIME_KW *\/\n-   -5,  \/* (193) expr ::= LP nexprlist COMMA expr RP *\/\n-   -3,  \/* (194) expr ::= expr AND expr *\/\n-   -3,  \/* (195) expr ::= expr OR expr *\/\n-   -3,  \/* (196) expr ::= expr LT|GT|GE|LE expr *\/\n-   -3,  \/* (197) expr ::= expr EQ|NE expr *\/\n-   -3,  \/* (198) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/\n-   -3,  \/* (199) expr ::= expr PLUS|MINUS expr *\/\n-   -3,  \/* (200) expr ::= expr STAR|SLASH|REM expr *\/\n-   -3,  \/* (201) expr ::= expr CONCAT expr *\/\n-   -2,  \/* (202) likeop ::= NOT LIKE_KW|MATCH *\/\n-   -3,  \/* (203) expr ::= expr likeop expr *\/\n-   -5,  \/* (204) expr ::= expr likeop expr ESCAPE expr *\/\n-   -2,  \/* (205) expr ::= expr ISNULL|NOTNULL *\/\n-   -3,  \/* (206) expr ::= expr NOT NULL *\/\n-   -3,  \/* (207) expr ::= expr IS expr *\/\n-   -4,  \/* (208) expr ::= expr IS NOT expr *\/\n-   -6,  \/* (209) expr ::= expr IS NOT DISTINCT FROM expr *\/\n-   -5,  \/* (210) expr ::= expr IS DISTINCT FROM expr *\/\n-   -2,  \/* (211) expr ::= NOT expr *\/\n-   -2,  \/* (212) expr ::= BITNOT expr *\/\n-   -2,  \/* (213) expr ::= PLUS|MINUS expr *\/\n-   -3,  \/* (214) expr ::= expr PTR expr *\/\n-   -1,  \/* (215) between_op ::= BETWEEN *\/\n-   -2,  \/* (216) between_op ::= NOT BETWEEN *\/\n-   -5,  \/* (217) expr ::= expr between_op expr AND expr *\/\n-   -1,  \/* (218) in_op ::= IN *\/\n-   -2,  \/* (219) in_op ::= NOT IN *\/\n-   -5,  \/* (220) expr ::= expr in_op LP exprlist RP *\/\n-   -3,  \/* (221) expr ::= LP select RP *\/\n-   -5,  \/* (222) expr ::= expr in_op LP select RP *\/\n-   -5,  \/* (223) expr ::= expr in_op nm dbnm paren_exprlist *\/\n-   -4,  \/* (224) expr ::= EXISTS LP select RP *\/\n-   -5,  \/* (225) expr ::= CASE case_operand case_exprlist case_else END *\/\n-   -5,  \/* (226) case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n-   -4,  \/* (227) case_exprlist ::= WHEN expr THEN expr *\/\n-   -2,  \/* (228) case_else ::= ELSE expr *\/\n-    0,  \/* (229) case_else ::= *\/\n-   -1,  \/* (230) case_operand ::= expr *\/\n+   -1,  \/* (178) expr ::= ID|INDEXED|JOIN_KW *\/\n+   -3,  \/* (179) expr ::= nm DOT nm *\/\n+   -5,  \/* (180) expr ::= nm DOT nm DOT nm *\/\n+   -1,  \/* (181) term ::= NULL|FLOAT|BLOB *\/\n+   -1,  \/* (182) term ::= STRING *\/\n+   -1,  \/* (183) term ::= INTEGER *\/\n+   -1,  \/* (184) expr ::= VARIABLE *\/\n+   -3,  \/* (185) expr ::= expr COLLATE ID|STRING *\/\n+   -6,  \/* (186) expr ::= CAST LP expr AS typetoken RP *\/\n+   -5,  \/* (187) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP *\/\n+   -8,  \/* (188) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP *\/\n+   -4,  \/* (189) expr ::= ID|INDEXED|JOIN_KW LP STAR RP *\/\n+   -6,  \/* (190) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP filter_over *\/\n+   -9,  \/* (191) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP filter_over *\/\n+   -5,  \/* (192) expr ::= ID|INDEXED|JOIN_KW LP STAR RP filter_over *\/\n+   -1,  \/* (193) term ::= CTIME_KW *\/\n+   -5,  \/* (194) expr ::= LP nexprlist COMMA expr RP *\/\n+   -3,  \/* (195) expr ::= expr AND expr *\/\n+   -3,  \/* (196) expr ::= expr OR expr *\/\n+   -3,  \/* (197) expr ::= expr LT|GT|GE|LE expr *\/\n+   -3,  \/* (198) expr ::= expr EQ|NE expr *\/\n+   -3,  \/* (199) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/\n+   -3,  \/* (200) expr ::= expr PLUS|MINUS expr *\/\n+   -3,  \/* (201) expr ::= expr STAR|SLASH|REM expr *\/\n+   -3,  \/* (202) expr ::= expr CONCAT expr *\/\n+   -2,  \/* (203) likeop ::= NOT LIKE_KW|MATCH *\/\n+   -3,  \/* (204) expr ::= expr likeop expr *\/\n+   -5,  \/* (205) expr ::= expr likeop expr ESCAPE expr *\/\n+   -2,  \/* (206) expr ::= expr ISNULL|NOTNULL *\/\n+   -3,  \/* (207) expr ::= expr NOT NULL *\/\n+   -3,  \/* (208) expr ::= expr IS expr *\/\n+   -4,  \/* (209) expr ::= expr IS NOT expr *\/\n+   -6,  \/* (210) expr ::= expr IS NOT DISTINCT FROM expr *\/\n+   -5,  \/* (211) expr ::= expr IS DISTINCT FROM expr *\/\n+   -2,  \/* (212) expr ::= NOT expr *\/\n+   -2,  \/* (213) expr ::= BITNOT expr *\/\n+   -2,  \/* (214) expr ::= PLUS|MINUS expr *\/\n+   -3,  \/* (215) expr ::= expr PTR expr *\/\n+   -1,  \/* (216) between_op ::= BETWEEN *\/\n+   -2,  \/* (217) between_op ::= NOT BETWEEN *\/\n+   -5,  \/* (218) expr ::= expr between_op expr AND expr *\/\n+   -1,  \/* (219) in_op ::= IN *\/\n+   -2,  \/* (220) in_op ::= NOT IN *\/\n+   -5,  \/* (221) expr ::= expr in_op LP exprlist RP *\/\n+   -3,  \/* (222) expr ::= LP select RP *\/\n+   -5,  \/* (223) expr ::= expr in_op LP select RP *\/\n+   -5,  \/* (224) expr ::= expr in_op nm dbnm paren_exprlist *\/\n+   -4,  \/* (225) expr ::= EXISTS LP select RP *\/\n+   -5,  \/* (226) expr ::= CASE case_operand case_exprlist case_else END *\/\n+   -5,  \/* (227) case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n+   -4,  \/* (228) case_exprlist ::= WHEN expr THEN expr *\/\n+   -2,  \/* (229) case_else ::= ELSE expr *\/\n+    0,  \/* (230) case_else ::= *\/\n@@ -166974,94 +174582,94 @@\n-   -1,  \/* (311) windowdefn_list ::= windowdefn *\/\n-   -3,  \/* (312) windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n-   -5,  \/* (313) windowdefn ::= nm AS LP window RP *\/\n-   -5,  \/* (314) window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n-   -6,  \/* (315) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n-   -4,  \/* (316) window ::= ORDER BY sortlist frame_opt *\/\n-   -5,  \/* (317) window ::= nm ORDER BY sortlist frame_opt *\/\n-   -1,  \/* (318) window ::= frame_opt *\/\n-   -2,  \/* (319) window ::= nm frame_opt *\/\n-    0,  \/* (320) frame_opt ::= *\/\n-   -3,  \/* (321) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n-   -6,  \/* (322) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n-   -1,  \/* (323) range_or_rows ::= RANGE|ROWS|GROUPS *\/\n-   -1,  \/* (324) frame_bound_s ::= frame_bound *\/\n-   -2,  \/* (325) frame_bound_s ::= UNBOUNDED PRECEDING *\/\n-   -1,  \/* (326) frame_bound_e ::= frame_bound *\/\n-   -2,  \/* (327) frame_bound_e ::= UNBOUNDED FOLLOWING *\/\n-   -2,  \/* (328) frame_bound ::= expr PRECEDING|FOLLOWING *\/\n-   -2,  \/* (329) frame_bound ::= CURRENT ROW *\/\n-    0,  \/* (330) frame_exclude_opt ::= *\/\n-   -2,  \/* (331) frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n-   -2,  \/* (332) frame_exclude ::= NO OTHERS *\/\n-   -2,  \/* (333) frame_exclude ::= CURRENT ROW *\/\n-   -1,  \/* (334) frame_exclude ::= GROUP|TIES *\/\n-   -2,  \/* (335) window_clause ::= WINDOW windowdefn_list *\/\n-   -2,  \/* (336) filter_over ::= filter_clause over_clause *\/\n-   -1,  \/* (337) filter_over ::= over_clause *\/\n-   -1,  \/* (338) filter_over ::= filter_clause *\/\n-   -4,  \/* (339) over_clause ::= OVER LP window RP *\/\n-   -2,  \/* (340) over_clause ::= OVER nm *\/\n-   -5,  \/* (341) filter_clause ::= FILTER LP WHERE expr RP *\/\n-   -1,  \/* (342) input ::= cmdlist *\/\n-   -2,  \/* (343) cmdlist ::= cmdlist ecmd *\/\n-   -1,  \/* (344) cmdlist ::= ecmd *\/\n-   -1,  \/* (345) ecmd ::= SEMI *\/\n-   -2,  \/* (346) ecmd ::= cmdx SEMI *\/\n-   -3,  \/* (347) ecmd ::= explain cmdx SEMI *\/\n-    0,  \/* (348) trans_opt ::= *\/\n-   -1,  \/* (349) trans_opt ::= TRANSACTION *\/\n-   -2,  \/* (350) trans_opt ::= TRANSACTION nm *\/\n-   -1,  \/* (351) savepoint_opt ::= SAVEPOINT *\/\n-    0,  \/* (352) savepoint_opt ::= *\/\n-   -2,  \/* (353) cmd ::= create_table create_table_args *\/\n-   -1,  \/* (354) table_option_set ::= table_option *\/\n-   -4,  \/* (355) columnlist ::= columnlist COMMA columnname carglist *\/\n-   -2,  \/* (356) columnlist ::= columnname carglist *\/\n-   -1,  \/* (357) nm ::= ID|INDEXED *\/\n-   -1,  \/* (358) nm ::= STRING *\/\n-   -1,  \/* (359) nm ::= JOIN_KW *\/\n-   -1,  \/* (360) typetoken ::= typename *\/\n-   -1,  \/* (361) typename ::= ID|STRING *\/\n-   -1,  \/* (362) signed ::= plus_num *\/\n-   -1,  \/* (363) signed ::= minus_num *\/\n-   -2,  \/* (364) carglist ::= carglist ccons *\/\n-    0,  \/* (365) carglist ::= *\/\n-   -2,  \/* (366) ccons ::= NULL onconf *\/\n-   -4,  \/* (367) ccons ::= GENERATED ALWAYS AS generated *\/\n-   -2,  \/* (368) ccons ::= AS generated *\/\n-   -2,  \/* (369) conslist_opt ::= COMMA conslist *\/\n-   -3,  \/* (370) conslist ::= conslist tconscomma tcons *\/\n-   -1,  \/* (371) conslist ::= tcons *\/\n-    0,  \/* (372) tconscomma ::= *\/\n-   -1,  \/* (373) defer_subclause_opt ::= defer_subclause *\/\n-   -1,  \/* (374) resolvetype ::= raisetype *\/\n-   -1,  \/* (375) selectnowith ::= oneselect *\/\n-   -1,  \/* (376) oneselect ::= values *\/\n-   -2,  \/* (377) sclp ::= selcollist COMMA *\/\n-   -1,  \/* (378) as ::= ID|STRING *\/\n-   -1,  \/* (379) indexed_opt ::= indexed_by *\/\n-    0,  \/* (380) returning ::= *\/\n-   -1,  \/* (381) expr ::= term *\/\n-   -1,  \/* (382) likeop ::= LIKE_KW|MATCH *\/\n-   -1,  \/* (383) exprlist ::= nexprlist *\/\n-   -1,  \/* (384) nmnum ::= plus_num *\/\n-   -1,  \/* (385) nmnum ::= nm *\/\n-   -1,  \/* (386) nmnum ::= ON *\/\n-   -1,  \/* (387) nmnum ::= DELETE *\/\n-   -1,  \/* (388) nmnum ::= DEFAULT *\/\n-   -1,  \/* (389) plus_num ::= INTEGER|FLOAT *\/\n-    0,  \/* (390) foreach_clause ::= *\/\n-   -3,  \/* (391) foreach_clause ::= FOR EACH ROW *\/\n-   -1,  \/* (392) trnm ::= nm *\/\n-    0,  \/* (393) tridxby ::= *\/\n-   -1,  \/* (394) database_kw_opt ::= DATABASE *\/\n-    0,  \/* (395) database_kw_opt ::= *\/\n-    0,  \/* (396) kwcolumn_opt ::= *\/\n-   -1,  \/* (397) kwcolumn_opt ::= COLUMNKW *\/\n-   -1,  \/* (398) vtabarglist ::= vtabarg *\/\n-   -3,  \/* (399) vtabarglist ::= vtabarglist COMMA vtabarg *\/\n-   -2,  \/* (400) vtabarg ::= vtabarg vtabargtoken *\/\n-    0,  \/* (401) anylist ::= *\/\n-   -4,  \/* (402) anylist ::= anylist LP anylist RP *\/\n-   -2,  \/* (403) anylist ::= anylist ANY *\/\n-    0,  \/* (404) with ::= *\/\n+   -3,  \/* (311) windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n+   -5,  \/* (312) windowdefn ::= nm AS LP window RP *\/\n+   -5,  \/* (313) window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n+   -6,  \/* (314) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n+   -4,  \/* (315) window ::= ORDER BY sortlist frame_opt *\/\n+   -5,  \/* (316) window ::= nm ORDER BY sortlist frame_opt *\/\n+   -2,  \/* (317) window ::= nm frame_opt *\/\n+    0,  \/* (318) frame_opt ::= *\/\n+   -3,  \/* (319) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n+   -6,  \/* (320) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n+   -1,  \/* (321) range_or_rows ::= RANGE|ROWS|GROUPS *\/\n+   -1,  \/* (322) frame_bound_s ::= frame_bound *\/\n+   -2,  \/* (323) frame_bound_s ::= UNBOUNDED PRECEDING *\/\n+   -1,  \/* (324) frame_bound_e ::= frame_bound *\/\n+   -2,  \/* (325) frame_bound_e ::= UNBOUNDED FOLLOWING *\/\n+   -2,  \/* (326) frame_bound ::= expr PRECEDING|FOLLOWING *\/\n+   -2,  \/* (327) frame_bound ::= CURRENT ROW *\/\n+    0,  \/* (328) frame_exclude_opt ::= *\/\n+   -2,  \/* (329) frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n+   -2,  \/* (330) frame_exclude ::= NO OTHERS *\/\n+   -2,  \/* (331) frame_exclude ::= CURRENT ROW *\/\n+   -1,  \/* (332) frame_exclude ::= GROUP|TIES *\/\n+   -2,  \/* (333) window_clause ::= WINDOW windowdefn_list *\/\n+   -2,  \/* (334) filter_over ::= filter_clause over_clause *\/\n+   -1,  \/* (335) filter_over ::= over_clause *\/\n+   -1,  \/* (336) filter_over ::= filter_clause *\/\n+   -4,  \/* (337) over_clause ::= OVER LP window RP *\/\n+   -2,  \/* (338) over_clause ::= OVER nm *\/\n+   -5,  \/* (339) filter_clause ::= FILTER LP WHERE expr RP *\/\n+   -1,  \/* (340) input ::= cmdlist *\/\n+   -2,  \/* (341) cmdlist ::= cmdlist ecmd *\/\n+   -1,  \/* (342) cmdlist ::= ecmd *\/\n+   -1,  \/* (343) ecmd ::= SEMI *\/\n+   -2,  \/* (344) ecmd ::= cmdx SEMI *\/\n+   -3,  \/* (345) ecmd ::= explain cmdx SEMI *\/\n+    0,  \/* (346) trans_opt ::= *\/\n+   -1,  \/* (347) trans_opt ::= TRANSACTION *\/\n+   -2,  \/* (348) trans_opt ::= TRANSACTION nm *\/\n+   -1,  \/* (349) savepoint_opt ::= SAVEPOINT *\/\n+    0,  \/* (350) savepoint_opt ::= *\/\n+   -2,  \/* (351) cmd ::= create_table create_table_args *\/\n+   -1,  \/* (352) table_option_set ::= table_option *\/\n+   -4,  \/* (353) columnlist ::= columnlist COMMA columnname carglist *\/\n+   -2,  \/* (354) columnlist ::= columnname carglist *\/\n+   -1,  \/* (355) nm ::= ID|INDEXED|JOIN_KW *\/\n+   -1,  \/* (356) nm ::= STRING *\/\n+   -1,  \/* (357) typetoken ::= typename *\/\n+   -1,  \/* (358) typename ::= ID|STRING *\/\n+   -1,  \/* (359) signed ::= plus_num *\/\n+   -1,  \/* (360) signed ::= minus_num *\/\n+   -2,  \/* (361) carglist ::= carglist ccons *\/\n+    0,  \/* (362) carglist ::= *\/\n+   -2,  \/* (363) ccons ::= NULL onconf *\/\n+   -4,  \/* (364) ccons ::= GENERATED ALWAYS AS generated *\/\n+   -2,  \/* (365) ccons ::= AS generated *\/\n+   -2,  \/* (366) conslist_opt ::= COMMA conslist *\/\n+   -3,  \/* (367) conslist ::= conslist tconscomma tcons *\/\n+   -1,  \/* (368) conslist ::= tcons *\/\n+    0,  \/* (369) tconscomma ::= *\/\n+   -1,  \/* (370) defer_subclause_opt ::= defer_subclause *\/\n+   -1,  \/* (371) resolvetype ::= raisetype *\/\n+   -1,  \/* (372) selectnowith ::= oneselect *\/\n+   -1,  \/* (373) oneselect ::= values *\/\n+   -2,  \/* (374) sclp ::= selcollist COMMA *\/\n+   -1,  \/* (375) as ::= ID|STRING *\/\n+   -1,  \/* (376) indexed_opt ::= indexed_by *\/\n+    0,  \/* (377) returning ::= *\/\n+   -1,  \/* (378) expr ::= term *\/\n+   -1,  \/* (379) likeop ::= LIKE_KW|MATCH *\/\n+   -1,  \/* (380) case_operand ::= expr *\/\n+   -1,  \/* (381) exprlist ::= nexprlist *\/\n+   -1,  \/* (382) nmnum ::= plus_num *\/\n+   -1,  \/* (383) nmnum ::= nm *\/\n+   -1,  \/* (384) nmnum ::= ON *\/\n+   -1,  \/* (385) nmnum ::= DELETE *\/\n+   -1,  \/* (386) nmnum ::= DEFAULT *\/\n+   -1,  \/* (387) plus_num ::= INTEGER|FLOAT *\/\n+    0,  \/* (388) foreach_clause ::= *\/\n+   -3,  \/* (389) foreach_clause ::= FOR EACH ROW *\/\n+   -1,  \/* (390) trnm ::= nm *\/\n+    0,  \/* (391) tridxby ::= *\/\n+   -1,  \/* (392) database_kw_opt ::= DATABASE *\/\n+    0,  \/* (393) database_kw_opt ::= *\/\n+    0,  \/* (394) kwcolumn_opt ::= *\/\n+   -1,  \/* (395) kwcolumn_opt ::= COLUMNKW *\/\n+   -1,  \/* (396) vtabarglist ::= vtabarg *\/\n+   -3,  \/* (397) vtabarglist ::= vtabarglist COMMA vtabarg *\/\n+   -2,  \/* (398) vtabarg ::= vtabarg vtabargtoken *\/\n+    0,  \/* (399) anylist ::= *\/\n+   -4,  \/* (400) anylist ::= anylist LP anylist RP *\/\n+   -2,  \/* (401) anylist ::= anylist ANY *\/\n+    0,  \/* (402) with ::= *\/\n+   -1,  \/* (403) windowdefn_list ::= windowdefn *\/\n+   -1,  \/* (404) window ::= frame_opt *\/\n@@ -167110,1 +174718,1 @@\n-{ pParse->explain = 1; }\n+{ if( pParse->pReprepare==0 ) pParse->explain = 1; }\n@@ -167113,1 +174721,1 @@\n-{ pParse->explain = 2; }\n+{ if( pParse->pReprepare==0 ) pParse->explain = 2; }\n@@ -167127,1 +174735,1 @@\n-      case 323: \/* range_or_rows ::= RANGE|ROWS|GROUPS *\/ yytestcase(yyruleno==323);\n+      case 321: \/* range_or_rows ::= RANGE|ROWS|GROUPS *\/ yytestcase(yyruleno==321);\n@@ -167348,2 +174956,2 @@\n-      case 216: \/* between_op ::= NOT BETWEEN *\/ yytestcase(yyruleno==216);\n-      case 219: \/* in_op ::= NOT IN *\/ yytestcase(yyruleno==219);\n+      case 217: \/* between_op ::= NOT BETWEEN *\/ yytestcase(yyruleno==217);\n+      case 220: \/* in_op ::= NOT IN *\/ yytestcase(yyruleno==220);\n@@ -167423,1 +175031,0 @@\n-  yymsp[0].minor.yy47 = p; \/*A-overwrites-X*\/\n@@ -167515,0 +175122,1 @@\n+  sqlite3ExprSetErrorOffset(p, (int)(yymsp[0].minor.yy0.z - pParse->zTail));\n@@ -167520,3 +175128,5 @@\n-  Expr *pRight = sqlite3PExpr(pParse, TK_ASTERISK, 0, 0);\n-  Expr *pLeft = tokenExpr(pParse, TK_ID, yymsp[-2].minor.yy0);\n-  Expr *pDot = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);\n+  Expr *pRight, *pLeft, *pDot;\n+  pRight = sqlite3PExpr(pParse, TK_ASTERISK, 0, 0);\n+  sqlite3ExprSetErrorOffset(pRight, (int)(yymsp[0].minor.yy0.z - pParse->zTail));\n+  pLeft = tokenExpr(pParse, TK_ID, yymsp[-2].minor.yy0);\n+  pDot = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight);\n@@ -167573,1 +175183,1 @@\n-    }else if( yymsp[-3].minor.yy131->nSrc==1 ){\n+    }else if( ALWAYS(yymsp[-3].minor.yy131!=0) && yymsp[-3].minor.yy131->nSrc==1 ){\n@@ -167701,1 +175311,1 @@\n-      case 229: \/* case_else ::= *\/ yytestcase(yyruleno==229);\n+      case 230: \/* case_else ::= *\/ yytestcase(yyruleno==230);\n@@ -167709,1 +175319,1 @@\n-      case 228: \/* case_else ::= ELSE expr *\/ yytestcase(yyruleno==228);\n+      case 229: \/* case_else ::= ELSE expr *\/ yytestcase(yyruleno==229);\n@@ -167822,2 +175432,1 @@\n-      case 178: \/* expr ::= ID|INDEXED *\/\n-      case 179: \/* expr ::= JOIN_KW *\/ yytestcase(yyruleno==179);\n+      case 178: \/* expr ::= ID|INDEXED|JOIN_KW *\/\n@@ -167826,1 +175435,1 @@\n-      case 180: \/* expr ::= nm DOT nm *\/\n+      case 179: \/* expr ::= nm DOT nm *\/\n@@ -167834,1 +175443,1 @@\n-      case 181: \/* expr ::= nm DOT nm DOT nm *\/\n+      case 180: \/* expr ::= nm DOT nm DOT nm *\/\n@@ -167847,2 +175456,2 @@\n-      case 182: \/* term ::= NULL|FLOAT|BLOB *\/\n-      case 183: \/* term ::= STRING *\/ yytestcase(yyruleno==183);\n+      case 181: \/* term ::= NULL|FLOAT|BLOB *\/\n+      case 182: \/* term ::= STRING *\/ yytestcase(yyruleno==182);\n@@ -167851,1 +175460,1 @@\n-      case 184: \/* term ::= INTEGER *\/\n+      case 183: \/* term ::= INTEGER *\/\n@@ -167858,1 +175467,1 @@\n-      case 185: \/* expr ::= VARIABLE *\/\n+      case 184: \/* expr ::= VARIABLE *\/\n@@ -167880,1 +175489,1 @@\n-      case 186: \/* expr ::= expr COLLATE ID|STRING *\/\n+      case 185: \/* expr ::= expr COLLATE ID|STRING *\/\n@@ -167885,1 +175494,1 @@\n-      case 187: \/* expr ::= CAST LP expr AS typetoken RP *\/\n+      case 186: \/* expr ::= CAST LP expr AS typetoken RP *\/\n@@ -167891,1 +175500,1 @@\n-      case 188: \/* expr ::= ID|INDEXED LP distinct exprlist RP *\/\n+      case 187: \/* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP *\/\n@@ -167897,1 +175506,8 @@\n-      case 189: \/* expr ::= ID|INDEXED LP STAR RP *\/\n+      case 188: \/* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP *\/\n+{\n+  yylhsminor.yy528 = sqlite3ExprFunction(pParse, yymsp[-4].minor.yy322, &yymsp[-7].minor.yy0, yymsp[-5].minor.yy394);\n+  sqlite3ExprAddFunctionOrderBy(pParse, yylhsminor.yy528, yymsp[-1].minor.yy322);\n+}\n+  yymsp[-7].minor.yy528 = yylhsminor.yy528;\n+        break;\n+      case 189: \/* expr ::= ID|INDEXED|JOIN_KW LP STAR RP *\/\n@@ -167903,1 +175519,1 @@\n-      case 190: \/* expr ::= ID|INDEXED LP distinct exprlist RP filter_over *\/\n+      case 190: \/* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP filter_over *\/\n@@ -167910,1 +175526,9 @@\n-      case 191: \/* expr ::= ID|INDEXED LP STAR RP filter_over *\/\n+      case 191: \/* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP filter_over *\/\n+{\n+  yylhsminor.yy528 = sqlite3ExprFunction(pParse, yymsp[-5].minor.yy322, &yymsp[-8].minor.yy0, yymsp[-6].minor.yy394);\n+  sqlite3WindowAttach(pParse, yylhsminor.yy528, yymsp[0].minor.yy41);\n+  sqlite3ExprAddFunctionOrderBy(pParse, yylhsminor.yy528, yymsp[-2].minor.yy322);\n+}\n+  yymsp[-8].minor.yy528 = yylhsminor.yy528;\n+        break;\n+      case 192: \/* expr ::= ID|INDEXED|JOIN_KW LP STAR RP filter_over *\/\n@@ -167917,1 +175541,1 @@\n-      case 192: \/* term ::= CTIME_KW *\/\n+      case 193: \/* term ::= CTIME_KW *\/\n@@ -167923,1 +175547,1 @@\n-      case 193: \/* expr ::= LP nexprlist COMMA expr RP *\/\n+      case 194: \/* expr ::= LP nexprlist COMMA expr RP *\/\n@@ -167937,1 +175561,1 @@\n-      case 194: \/* expr ::= expr AND expr *\/\n+      case 195: \/* expr ::= expr AND expr *\/\n@@ -167940,7 +175564,7 @@\n-      case 195: \/* expr ::= expr OR expr *\/\n-      case 196: \/* expr ::= expr LT|GT|GE|LE expr *\/ yytestcase(yyruleno==196);\n-      case 197: \/* expr ::= expr EQ|NE expr *\/ yytestcase(yyruleno==197);\n-      case 198: \/* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/ yytestcase(yyruleno==198);\n-      case 199: \/* expr ::= expr PLUS|MINUS expr *\/ yytestcase(yyruleno==199);\n-      case 200: \/* expr ::= expr STAR|SLASH|REM expr *\/ yytestcase(yyruleno==200);\n-      case 201: \/* expr ::= expr CONCAT expr *\/ yytestcase(yyruleno==201);\n+      case 196: \/* expr ::= expr OR expr *\/\n+      case 197: \/* expr ::= expr LT|GT|GE|LE expr *\/ yytestcase(yyruleno==197);\n+      case 198: \/* expr ::= expr EQ|NE expr *\/ yytestcase(yyruleno==198);\n+      case 199: \/* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/ yytestcase(yyruleno==199);\n+      case 200: \/* expr ::= expr PLUS|MINUS expr *\/ yytestcase(yyruleno==200);\n+      case 201: \/* expr ::= expr STAR|SLASH|REM expr *\/ yytestcase(yyruleno==201);\n+      case 202: \/* expr ::= expr CONCAT expr *\/ yytestcase(yyruleno==202);\n@@ -167949,1 +175573,1 @@\n-      case 202: \/* likeop ::= NOT LIKE_KW|MATCH *\/\n+      case 203: \/* likeop ::= NOT LIKE_KW|MATCH *\/\n@@ -167952,1 +175576,1 @@\n-      case 203: \/* expr ::= expr likeop expr *\/\n+      case 204: \/* expr ::= expr likeop expr *\/\n@@ -167964,1 +175588,1 @@\n-      case 204: \/* expr ::= expr likeop expr ESCAPE expr *\/\n+      case 205: \/* expr ::= expr likeop expr ESCAPE expr *\/\n@@ -167977,1 +175601,1 @@\n-      case 205: \/* expr ::= expr ISNULL|NOTNULL *\/\n+      case 206: \/* expr ::= expr ISNULL|NOTNULL *\/\n@@ -167980,1 +175604,1 @@\n-      case 206: \/* expr ::= expr NOT NULL *\/\n+      case 207: \/* expr ::= expr NOT NULL *\/\n@@ -167983,1 +175607,1 @@\n-      case 207: \/* expr ::= expr IS expr *\/\n+      case 208: \/* expr ::= expr IS expr *\/\n@@ -167989,1 +175613,1 @@\n-      case 208: \/* expr ::= expr IS NOT expr *\/\n+      case 209: \/* expr ::= expr IS NOT expr *\/\n@@ -167995,1 +175619,1 @@\n-      case 209: \/* expr ::= expr IS NOT DISTINCT FROM expr *\/\n+      case 210: \/* expr ::= expr IS NOT DISTINCT FROM expr *\/\n@@ -168001,1 +175625,1 @@\n-      case 210: \/* expr ::= expr IS DISTINCT FROM expr *\/\n+      case 211: \/* expr ::= expr IS DISTINCT FROM expr *\/\n@@ -168007,2 +175631,2 @@\n-      case 211: \/* expr ::= NOT expr *\/\n-      case 212: \/* expr ::= BITNOT expr *\/ yytestcase(yyruleno==212);\n+      case 212: \/* expr ::= NOT expr *\/\n+      case 213: \/* expr ::= BITNOT expr *\/ yytestcase(yyruleno==213);\n@@ -168011,1 +175635,1 @@\n-      case 213: \/* expr ::= PLUS|MINUS expr *\/\n+      case 214: \/* expr ::= PLUS|MINUS expr *\/\n@@ -168017,1 +175641,1 @@\n-      case 214: \/* expr ::= expr PTR expr *\/\n+      case 215: \/* expr ::= expr PTR expr *\/\n@@ -168025,2 +175649,2 @@\n-      case 215: \/* between_op ::= BETWEEN *\/\n-      case 218: \/* in_op ::= IN *\/ yytestcase(yyruleno==218);\n+      case 216: \/* between_op ::= BETWEEN *\/\n+      case 219: \/* in_op ::= IN *\/ yytestcase(yyruleno==219);\n@@ -168029,1 +175653,1 @@\n-      case 217: \/* expr ::= expr between_op expr AND expr *\/\n+      case 218: \/* expr ::= expr between_op expr AND expr *\/\n@@ -168042,1 +175666,1 @@\n-      case 220: \/* expr ::= expr in_op LP exprlist RP *\/\n+      case 221: \/* expr ::= expr in_op LP exprlist RP *\/\n@@ -168063,0 +175687,5 @@\n+      }else if( yymsp[-1].minor.yy322->nExpr==1 && pRHS->op==TK_SELECT ){\n+        yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy528, 0);\n+        sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy528, pRHS->x.pSelect);\n+        pRHS->x.pSelect = 0;\n+        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy322);\n@@ -168083,1 +175712,1 @@\n-      case 221: \/* expr ::= LP select RP *\/\n+      case 222: \/* expr ::= LP select RP *\/\n@@ -168089,1 +175718,1 @@\n-      case 222: \/* expr ::= expr in_op LP select RP *\/\n+      case 223: \/* expr ::= expr in_op LP select RP *\/\n@@ -168096,1 +175725,1 @@\n-      case 223: \/* expr ::= expr in_op nm dbnm paren_exprlist *\/\n+      case 224: \/* expr ::= expr in_op nm dbnm paren_exprlist *\/\n@@ -168106,1 +175735,1 @@\n-      case 224: \/* expr ::= EXISTS LP select RP *\/\n+      case 225: \/* expr ::= EXISTS LP select RP *\/\n@@ -168113,1 +175742,1 @@\n-      case 225: \/* expr ::= CASE case_operand case_exprlist case_else END *\/\n+      case 226: \/* expr ::= CASE case_operand case_exprlist case_else END *\/\n@@ -168125,1 +175754,1 @@\n-      case 226: \/* case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n+      case 227: \/* case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n@@ -168131,1 +175760,1 @@\n-      case 227: \/* case_exprlist ::= WHEN expr THEN expr *\/\n+      case 228: \/* case_exprlist ::= WHEN expr THEN expr *\/\n@@ -168137,3 +175766,0 @@\n-      case 230: \/* case_operand ::= expr *\/\n-{yymsp[0].minor.yy528 = yymsp[0].minor.yy528; \/*A-overwrites-X*\/}\n-        break;\n@@ -168415,5 +176041,1 @@\n-      case 311: \/* windowdefn_list ::= windowdefn *\/\n-{ yylhsminor.yy41 = yymsp[0].minor.yy41; }\n-  yymsp[0].minor.yy41 = yylhsminor.yy41;\n-        break;\n-      case 312: \/* windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n+      case 311: \/* windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n@@ -168428,1 +176050,1 @@\n-      case 313: \/* windowdefn ::= nm AS LP window RP *\/\n+      case 312: \/* windowdefn ::= nm AS LP window RP *\/\n@@ -168437,1 +176059,1 @@\n-      case 314: \/* window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n+      case 313: \/* window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n@@ -168442,1 +176064,1 @@\n-      case 315: \/* window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n+      case 314: \/* window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n@@ -168448,1 +176070,1 @@\n-      case 316: \/* window ::= ORDER BY sortlist frame_opt *\/\n+      case 315: \/* window ::= ORDER BY sortlist frame_opt *\/\n@@ -168453,1 +176075,1 @@\n-      case 317: \/* window ::= nm ORDER BY sortlist frame_opt *\/\n+      case 316: \/* window ::= nm ORDER BY sortlist frame_opt *\/\n@@ -168459,8 +176081,1 @@\n-      case 318: \/* window ::= frame_opt *\/\n-      case 337: \/* filter_over ::= over_clause *\/ yytestcase(yyruleno==337);\n-{\n-  yylhsminor.yy41 = yymsp[0].minor.yy41;\n-}\n-  yymsp[0].minor.yy41 = yylhsminor.yy41;\n-        break;\n-      case 319: \/* window ::= nm frame_opt *\/\n+      case 317: \/* window ::= nm frame_opt *\/\n@@ -168472,1 +176087,1 @@\n-      case 320: \/* frame_opt ::= *\/\n+      case 318: \/* frame_opt ::= *\/\n@@ -168477,1 +176092,1 @@\n-      case 321: \/* frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n+      case 319: \/* frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n@@ -168483,1 +176098,1 @@\n-      case 322: \/* frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n+      case 320: \/* frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n@@ -168489,2 +176104,2 @@\n-      case 324: \/* frame_bound_s ::= frame_bound *\/\n-      case 326: \/* frame_bound_e ::= frame_bound *\/ yytestcase(yyruleno==326);\n+      case 322: \/* frame_bound_s ::= frame_bound *\/\n+      case 324: \/* frame_bound_e ::= frame_bound *\/ yytestcase(yyruleno==324);\n@@ -168494,3 +176109,3 @@\n-      case 325: \/* frame_bound_s ::= UNBOUNDED PRECEDING *\/\n-      case 327: \/* frame_bound_e ::= UNBOUNDED FOLLOWING *\/ yytestcase(yyruleno==327);\n-      case 329: \/* frame_bound ::= CURRENT ROW *\/ yytestcase(yyruleno==329);\n+      case 323: \/* frame_bound_s ::= UNBOUNDED PRECEDING *\/\n+      case 325: \/* frame_bound_e ::= UNBOUNDED FOLLOWING *\/ yytestcase(yyruleno==325);\n+      case 327: \/* frame_bound ::= CURRENT ROW *\/ yytestcase(yyruleno==327);\n@@ -168500,1 +176115,1 @@\n-      case 328: \/* frame_bound ::= expr PRECEDING|FOLLOWING *\/\n+      case 326: \/* frame_bound ::= expr PRECEDING|FOLLOWING *\/\n@@ -168504,1 +176119,1 @@\n-      case 330: \/* frame_exclude_opt ::= *\/\n+      case 328: \/* frame_exclude_opt ::= *\/\n@@ -168507,1 +176122,1 @@\n-      case 331: \/* frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n+      case 329: \/* frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n@@ -168510,2 +176125,2 @@\n-      case 332: \/* frame_exclude ::= NO OTHERS *\/\n-      case 333: \/* frame_exclude ::= CURRENT ROW *\/ yytestcase(yyruleno==333);\n+      case 330: \/* frame_exclude ::= NO OTHERS *\/\n+      case 331: \/* frame_exclude ::= CURRENT ROW *\/ yytestcase(yyruleno==331);\n@@ -168514,1 +176129,1 @@\n-      case 334: \/* frame_exclude ::= GROUP|TIES *\/\n+      case 332: \/* frame_exclude ::= GROUP|TIES *\/\n@@ -168517,1 +176132,1 @@\n-      case 335: \/* window_clause ::= WINDOW windowdefn_list *\/\n+      case 333: \/* window_clause ::= WINDOW windowdefn_list *\/\n@@ -168520,1 +176135,1 @@\n-      case 336: \/* filter_over ::= filter_clause over_clause *\/\n+      case 334: \/* filter_over ::= filter_clause over_clause *\/\n@@ -168531,1 +176146,7 @@\n-      case 338: \/* filter_over ::= filter_clause *\/\n+      case 335: \/* filter_over ::= over_clause *\/\n+{\n+  yylhsminor.yy41 = yymsp[0].minor.yy41;\n+}\n+  yymsp[0].minor.yy41 = yylhsminor.yy41;\n+        break;\n+      case 336: \/* filter_over ::= filter_clause *\/\n@@ -168543,1 +176164,1 @@\n-      case 339: \/* over_clause ::= OVER LP window RP *\/\n+      case 337: \/* over_clause ::= OVER LP window RP *\/\n@@ -168549,1 +176170,1 @@\n-      case 340: \/* over_clause ::= OVER nm *\/\n+      case 338: \/* over_clause ::= OVER nm *\/\n@@ -168557,1 +176178,1 @@\n-      case 341: \/* filter_clause ::= FILTER LP WHERE expr RP *\/\n+      case 339: \/* filter_clause ::= FILTER LP WHERE expr RP *\/\n@@ -168561,63 +176182,65 @@\n-      \/* (342) input ::= cmdlist *\/ yytestcase(yyruleno==342);\n-      \/* (343) cmdlist ::= cmdlist ecmd *\/ yytestcase(yyruleno==343);\n-      \/* (344) cmdlist ::= ecmd (OPTIMIZED OUT) *\/ assert(yyruleno!=344);\n-      \/* (345) ecmd ::= SEMI *\/ yytestcase(yyruleno==345);\n-      \/* (346) ecmd ::= cmdx SEMI *\/ yytestcase(yyruleno==346);\n-      \/* (347) ecmd ::= explain cmdx SEMI (NEVER REDUCES) *\/ assert(yyruleno!=347);\n-      \/* (348) trans_opt ::= *\/ yytestcase(yyruleno==348);\n-      \/* (349) trans_opt ::= TRANSACTION *\/ yytestcase(yyruleno==349);\n-      \/* (350) trans_opt ::= TRANSACTION nm *\/ yytestcase(yyruleno==350);\n-      \/* (351) savepoint_opt ::= SAVEPOINT *\/ yytestcase(yyruleno==351);\n-      \/* (352) savepoint_opt ::= *\/ yytestcase(yyruleno==352);\n-      \/* (353) cmd ::= create_table create_table_args *\/ yytestcase(yyruleno==353);\n-      \/* (354) table_option_set ::= table_option (OPTIMIZED OUT) *\/ assert(yyruleno!=354);\n-      \/* (355) columnlist ::= columnlist COMMA columnname carglist *\/ yytestcase(yyruleno==355);\n-      \/* (356) columnlist ::= columnname carglist *\/ yytestcase(yyruleno==356);\n-      \/* (357) nm ::= ID|INDEXED *\/ yytestcase(yyruleno==357);\n-      \/* (358) nm ::= STRING *\/ yytestcase(yyruleno==358);\n-      \/* (359) nm ::= JOIN_KW *\/ yytestcase(yyruleno==359);\n-      \/* (360) typetoken ::= typename *\/ yytestcase(yyruleno==360);\n-      \/* (361) typename ::= ID|STRING *\/ yytestcase(yyruleno==361);\n-      \/* (362) signed ::= plus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=362);\n-      \/* (363) signed ::= minus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=363);\n-      \/* (364) carglist ::= carglist ccons *\/ yytestcase(yyruleno==364);\n-      \/* (365) carglist ::= *\/ yytestcase(yyruleno==365);\n-      \/* (366) ccons ::= NULL onconf *\/ yytestcase(yyruleno==366);\n-      \/* (367) ccons ::= GENERATED ALWAYS AS generated *\/ yytestcase(yyruleno==367);\n-      \/* (368) ccons ::= AS generated *\/ yytestcase(yyruleno==368);\n-      \/* (369) conslist_opt ::= COMMA conslist *\/ yytestcase(yyruleno==369);\n-      \/* (370) conslist ::= conslist tconscomma tcons *\/ yytestcase(yyruleno==370);\n-      \/* (371) conslist ::= tcons (OPTIMIZED OUT) *\/ assert(yyruleno!=371);\n-      \/* (372) tconscomma ::= *\/ yytestcase(yyruleno==372);\n-      \/* (373) defer_subclause_opt ::= defer_subclause (OPTIMIZED OUT) *\/ assert(yyruleno!=373);\n-      \/* (374) resolvetype ::= raisetype (OPTIMIZED OUT) *\/ assert(yyruleno!=374);\n-      \/* (375) selectnowith ::= oneselect (OPTIMIZED OUT) *\/ assert(yyruleno!=375);\n-      \/* (376) oneselect ::= values *\/ yytestcase(yyruleno==376);\n-      \/* (377) sclp ::= selcollist COMMA *\/ yytestcase(yyruleno==377);\n-      \/* (378) as ::= ID|STRING *\/ yytestcase(yyruleno==378);\n-      \/* (379) indexed_opt ::= indexed_by (OPTIMIZED OUT) *\/ assert(yyruleno!=379);\n-      \/* (380) returning ::= *\/ yytestcase(yyruleno==380);\n-      \/* (381) expr ::= term (OPTIMIZED OUT) *\/ assert(yyruleno!=381);\n-      \/* (382) likeop ::= LIKE_KW|MATCH *\/ yytestcase(yyruleno==382);\n-      \/* (383) exprlist ::= nexprlist *\/ yytestcase(yyruleno==383);\n-      \/* (384) nmnum ::= plus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=384);\n-      \/* (385) nmnum ::= nm (OPTIMIZED OUT) *\/ assert(yyruleno!=385);\n-      \/* (386) nmnum ::= ON *\/ yytestcase(yyruleno==386);\n-      \/* (387) nmnum ::= DELETE *\/ yytestcase(yyruleno==387);\n-      \/* (388) nmnum ::= DEFAULT *\/ yytestcase(yyruleno==388);\n-      \/* (389) plus_num ::= INTEGER|FLOAT *\/ yytestcase(yyruleno==389);\n-      \/* (390) foreach_clause ::= *\/ yytestcase(yyruleno==390);\n-      \/* (391) foreach_clause ::= FOR EACH ROW *\/ yytestcase(yyruleno==391);\n-      \/* (392) trnm ::= nm *\/ yytestcase(yyruleno==392);\n-      \/* (393) tridxby ::= *\/ yytestcase(yyruleno==393);\n-      \/* (394) database_kw_opt ::= DATABASE *\/ yytestcase(yyruleno==394);\n-      \/* (395) database_kw_opt ::= *\/ yytestcase(yyruleno==395);\n-      \/* (396) kwcolumn_opt ::= *\/ yytestcase(yyruleno==396);\n-      \/* (397) kwcolumn_opt ::= COLUMNKW *\/ yytestcase(yyruleno==397);\n-      \/* (398) vtabarglist ::= vtabarg *\/ yytestcase(yyruleno==398);\n-      \/* (399) vtabarglist ::= vtabarglist COMMA vtabarg *\/ yytestcase(yyruleno==399);\n-      \/* (400) vtabarg ::= vtabarg vtabargtoken *\/ yytestcase(yyruleno==400);\n-      \/* (401) anylist ::= *\/ yytestcase(yyruleno==401);\n-      \/* (402) anylist ::= anylist LP anylist RP *\/ yytestcase(yyruleno==402);\n-      \/* (403) anylist ::= anylist ANY *\/ yytestcase(yyruleno==403);\n-      \/* (404) with ::= *\/ yytestcase(yyruleno==404);\n+      \/* (340) input ::= cmdlist *\/ yytestcase(yyruleno==340);\n+      \/* (341) cmdlist ::= cmdlist ecmd *\/ yytestcase(yyruleno==341);\n+      \/* (342) cmdlist ::= ecmd (OPTIMIZED OUT) *\/ assert(yyruleno!=342);\n+      \/* (343) ecmd ::= SEMI *\/ yytestcase(yyruleno==343);\n+      \/* (344) ecmd ::= cmdx SEMI *\/ yytestcase(yyruleno==344);\n+      \/* (345) ecmd ::= explain cmdx SEMI (NEVER REDUCES) *\/ assert(yyruleno!=345);\n+      \/* (346) trans_opt ::= *\/ yytestcase(yyruleno==346);\n+      \/* (347) trans_opt ::= TRANSACTION *\/ yytestcase(yyruleno==347);\n+      \/* (348) trans_opt ::= TRANSACTION nm *\/ yytestcase(yyruleno==348);\n+      \/* (349) savepoint_opt ::= SAVEPOINT *\/ yytestcase(yyruleno==349);\n+      \/* (350) savepoint_opt ::= *\/ yytestcase(yyruleno==350);\n+      \/* (351) cmd ::= create_table create_table_args *\/ yytestcase(yyruleno==351);\n+      \/* (352) table_option_set ::= table_option (OPTIMIZED OUT) *\/ assert(yyruleno!=352);\n+      \/* (353) columnlist ::= columnlist COMMA columnname carglist *\/ yytestcase(yyruleno==353);\n+      \/* (354) columnlist ::= columnname carglist *\/ yytestcase(yyruleno==354);\n+      \/* (355) nm ::= ID|INDEXED|JOIN_KW *\/ yytestcase(yyruleno==355);\n+      \/* (356) nm ::= STRING *\/ yytestcase(yyruleno==356);\n+      \/* (357) typetoken ::= typename *\/ yytestcase(yyruleno==357);\n+      \/* (358) typename ::= ID|STRING *\/ yytestcase(yyruleno==358);\n+      \/* (359) signed ::= plus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=359);\n+      \/* (360) signed ::= minus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=360);\n+      \/* (361) carglist ::= carglist ccons *\/ yytestcase(yyruleno==361);\n+      \/* (362) carglist ::= *\/ yytestcase(yyruleno==362);\n+      \/* (363) ccons ::= NULL onconf *\/ yytestcase(yyruleno==363);\n+      \/* (364) ccons ::= GENERATED ALWAYS AS generated *\/ yytestcase(yyruleno==364);\n+      \/* (365) ccons ::= AS generated *\/ yytestcase(yyruleno==365);\n+      \/* (366) conslist_opt ::= COMMA conslist *\/ yytestcase(yyruleno==366);\n+      \/* (367) conslist ::= conslist tconscomma tcons *\/ yytestcase(yyruleno==367);\n+      \/* (368) conslist ::= tcons (OPTIMIZED OUT) *\/ assert(yyruleno!=368);\n+      \/* (369) tconscomma ::= *\/ yytestcase(yyruleno==369);\n+      \/* (370) defer_subclause_opt ::= defer_subclause (OPTIMIZED OUT) *\/ assert(yyruleno!=370);\n+      \/* (371) resolvetype ::= raisetype (OPTIMIZED OUT) *\/ assert(yyruleno!=371);\n+      \/* (372) selectnowith ::= oneselect (OPTIMIZED OUT) *\/ assert(yyruleno!=372);\n+      \/* (373) oneselect ::= values *\/ yytestcase(yyruleno==373);\n+      \/* (374) sclp ::= selcollist COMMA *\/ yytestcase(yyruleno==374);\n+      \/* (375) as ::= ID|STRING *\/ yytestcase(yyruleno==375);\n+      \/* (376) indexed_opt ::= indexed_by (OPTIMIZED OUT) *\/ assert(yyruleno!=376);\n+      \/* (377) returning ::= *\/ yytestcase(yyruleno==377);\n+      \/* (378) expr ::= term (OPTIMIZED OUT) *\/ assert(yyruleno!=378);\n+      \/* (379) likeop ::= LIKE_KW|MATCH *\/ yytestcase(yyruleno==379);\n+      \/* (380) case_operand ::= expr *\/ yytestcase(yyruleno==380);\n+      \/* (381) exprlist ::= nexprlist *\/ yytestcase(yyruleno==381);\n+      \/* (382) nmnum ::= plus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=382);\n+      \/* (383) nmnum ::= nm (OPTIMIZED OUT) *\/ assert(yyruleno!=383);\n+      \/* (384) nmnum ::= ON *\/ yytestcase(yyruleno==384);\n+      \/* (385) nmnum ::= DELETE *\/ yytestcase(yyruleno==385);\n+      \/* (386) nmnum ::= DEFAULT *\/ yytestcase(yyruleno==386);\n+      \/* (387) plus_num ::= INTEGER|FLOAT *\/ yytestcase(yyruleno==387);\n+      \/* (388) foreach_clause ::= *\/ yytestcase(yyruleno==388);\n+      \/* (389) foreach_clause ::= FOR EACH ROW *\/ yytestcase(yyruleno==389);\n+      \/* (390) trnm ::= nm *\/ yytestcase(yyruleno==390);\n+      \/* (391) tridxby ::= *\/ yytestcase(yyruleno==391);\n+      \/* (392) database_kw_opt ::= DATABASE *\/ yytestcase(yyruleno==392);\n+      \/* (393) database_kw_opt ::= *\/ yytestcase(yyruleno==393);\n+      \/* (394) kwcolumn_opt ::= *\/ yytestcase(yyruleno==394);\n+      \/* (395) kwcolumn_opt ::= COLUMNKW *\/ yytestcase(yyruleno==395);\n+      \/* (396) vtabarglist ::= vtabarg *\/ yytestcase(yyruleno==396);\n+      \/* (397) vtabarglist ::= vtabarglist COMMA vtabarg *\/ yytestcase(yyruleno==397);\n+      \/* (398) vtabarg ::= vtabarg vtabargtoken *\/ yytestcase(yyruleno==398);\n+      \/* (399) anylist ::= *\/ yytestcase(yyruleno==399);\n+      \/* (400) anylist ::= anylist LP anylist RP *\/ yytestcase(yyruleno==400);\n+      \/* (401) anylist ::= anylist ANY *\/ yytestcase(yyruleno==401);\n+      \/* (402) with ::= *\/ yytestcase(yyruleno==402);\n+      \/* (403) windowdefn_list ::= windowdefn (OPTIMIZED OUT) *\/ assert(yyruleno!=403);\n+      \/* (404) window ::= frame_opt (OPTIMIZED OUT) *\/ assert(yyruleno!=404);\n@@ -169199,1 +176822,1 @@\n-static const unsigned char aKWNext[147] = {\n+static const unsigned char aKWNext[148] = {0,\n@@ -169214,1 +176837,1 @@\n-static const unsigned char aKWLen[147] = {\n+static const unsigned char aKWLen[148] = {0,\n@@ -169230,1 +176853,1 @@\n-static const unsigned short int aKWOffset[147] = {\n+static const unsigned short int aKWOffset[148] = {0,\n@@ -169245,1 +176868,1 @@\n-static const unsigned char aKWCode[147] = {\n+static const unsigned char aKWCode[148] = {0,\n@@ -169412,5 +177035,5 @@\n-  if( n>=2 ){\n-    i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n*1) % 127;\n-    for(i=((int)aKWHash[i])-1; i>=0; i=((int)aKWNext[i])-1){\n-      if( aKWLen[i]!=n ) continue;\n-      zKW = &zKWText[aKWOffset[i]];\n+  assert( n>=2 );\n+  i = ((charMap(z[0])*4) ^ (charMap(z[n-1])*3) ^ n*1) % 127;\n+  for(i=(int)aKWHash[i]; i>0; i=aKWNext[i]){\n+    if( aKWLen[i]!=n ) continue;\n+    zKW = &zKWText[aKWOffset[i]];\n@@ -169418,4 +177041,4 @@\n-      if( (z[0]&~0x20)!=zKW[0] ) continue;\n-      if( (z[1]&~0x20)!=zKW[1] ) continue;\n-      j = 2;\n-      while( j<n && (z[j]&~0x20)==zKW[j] ){ j++; }\n+    if( (z[0]&~0x20)!=zKW[0] ) continue;\n+    if( (z[1]&~0x20)!=zKW[1] ) continue;\n+    j = 2;\n+    while( j<n && (z[j]&~0x20)==zKW[j] ){ j++; }\n@@ -169424,156 +177047,155 @@\n-      if( toupper(z[0])!=zKW[0] ) continue;\n-      if( toupper(z[1])!=zKW[1] ) continue;\n-      j = 2;\n-      while( j<n && toupper(z[j])==zKW[j] ){ j++; }\n-#endif\n-      if( j<n ) continue;\n-      testcase( i==0 ); \/* REINDEX *\/\n-      testcase( i==1 ); \/* INDEXED *\/\n-      testcase( i==2 ); \/* INDEX *\/\n-      testcase( i==3 ); \/* DESC *\/\n-      testcase( i==4 ); \/* ESCAPE *\/\n-      testcase( i==5 ); \/* EACH *\/\n-      testcase( i==6 ); \/* CHECK *\/\n-      testcase( i==7 ); \/* KEY *\/\n-      testcase( i==8 ); \/* BEFORE *\/\n-      testcase( i==9 ); \/* FOREIGN *\/\n-      testcase( i==10 ); \/* FOR *\/\n-      testcase( i==11 ); \/* IGNORE *\/\n-      testcase( i==12 ); \/* REGEXP *\/\n-      testcase( i==13 ); \/* EXPLAIN *\/\n-      testcase( i==14 ); \/* INSTEAD *\/\n-      testcase( i==15 ); \/* ADD *\/\n-      testcase( i==16 ); \/* DATABASE *\/\n-      testcase( i==17 ); \/* AS *\/\n-      testcase( i==18 ); \/* SELECT *\/\n-      testcase( i==19 ); \/* TABLE *\/\n-      testcase( i==20 ); \/* LEFT *\/\n-      testcase( i==21 ); \/* THEN *\/\n-      testcase( i==22 ); \/* END *\/\n-      testcase( i==23 ); \/* DEFERRABLE *\/\n-      testcase( i==24 ); \/* ELSE *\/\n-      testcase( i==25 ); \/* EXCLUDE *\/\n-      testcase( i==26 ); \/* DELETE *\/\n-      testcase( i==27 ); \/* TEMPORARY *\/\n-      testcase( i==28 ); \/* TEMP *\/\n-      testcase( i==29 ); \/* OR *\/\n-      testcase( i==30 ); \/* ISNULL *\/\n-      testcase( i==31 ); \/* NULLS *\/\n-      testcase( i==32 ); \/* SAVEPOINT *\/\n-      testcase( i==33 ); \/* INTERSECT *\/\n-      testcase( i==34 ); \/* TIES *\/\n-      testcase( i==35 ); \/* NOTNULL *\/\n-      testcase( i==36 ); \/* NOT *\/\n-      testcase( i==37 ); \/* NO *\/\n-      testcase( i==38 ); \/* NULL *\/\n-      testcase( i==39 ); \/* LIKE *\/\n-      testcase( i==40 ); \/* EXCEPT *\/\n-      testcase( i==41 ); \/* TRANSACTION *\/\n-      testcase( i==42 ); \/* ACTION *\/\n-      testcase( i==43 ); \/* ON *\/\n-      testcase( i==44 ); \/* NATURAL *\/\n-      testcase( i==45 ); \/* ALTER *\/\n-      testcase( i==46 ); \/* RAISE *\/\n-      testcase( i==47 ); \/* EXCLUSIVE *\/\n-      testcase( i==48 ); \/* EXISTS *\/\n-      testcase( i==49 ); \/* CONSTRAINT *\/\n-      testcase( i==50 ); \/* INTO *\/\n-      testcase( i==51 ); \/* OFFSET *\/\n-      testcase( i==52 ); \/* OF *\/\n-      testcase( i==53 ); \/* SET *\/\n-      testcase( i==54 ); \/* TRIGGER *\/\n-      testcase( i==55 ); \/* RANGE *\/\n-      testcase( i==56 ); \/* GENERATED *\/\n-      testcase( i==57 ); \/* DETACH *\/\n-      testcase( i==58 ); \/* HAVING *\/\n-      testcase( i==59 ); \/* GLOB *\/\n-      testcase( i==60 ); \/* BEGIN *\/\n-      testcase( i==61 ); \/* INNER *\/\n-      testcase( i==62 ); \/* REFERENCES *\/\n-      testcase( i==63 ); \/* UNIQUE *\/\n-      testcase( i==64 ); \/* QUERY *\/\n-      testcase( i==65 ); \/* WITHOUT *\/\n-      testcase( i==66 ); \/* WITH *\/\n-      testcase( i==67 ); \/* OUTER *\/\n-      testcase( i==68 ); \/* RELEASE *\/\n-      testcase( i==69 ); \/* ATTACH *\/\n-      testcase( i==70 ); \/* BETWEEN *\/\n-      testcase( i==71 ); \/* NOTHING *\/\n-      testcase( i==72 ); \/* GROUPS *\/\n-      testcase( i==73 ); \/* GROUP *\/\n-      testcase( i==74 ); \/* CASCADE *\/\n-      testcase( i==75 ); \/* ASC *\/\n-      testcase( i==76 ); \/* DEFAULT *\/\n-      testcase( i==77 ); \/* CASE *\/\n-      testcase( i==78 ); \/* COLLATE *\/\n-      testcase( i==79 ); \/* CREATE *\/\n-      testcase( i==80 ); \/* CURRENT_DATE *\/\n-      testcase( i==81 ); \/* IMMEDIATE *\/\n-      testcase( i==82 ); \/* JOIN *\/\n-      testcase( i==83 ); \/* INSERT *\/\n-      testcase( i==84 ); \/* MATCH *\/\n-      testcase( i==85 ); \/* PLAN *\/\n-      testcase( i==86 ); \/* ANALYZE *\/\n-      testcase( i==87 ); \/* PRAGMA *\/\n-      testcase( i==88 ); \/* MATERIALIZED *\/\n-      testcase( i==89 ); \/* DEFERRED *\/\n-      testcase( i==90 ); \/* DISTINCT *\/\n-      testcase( i==91 ); \/* IS *\/\n-      testcase( i==92 ); \/* UPDATE *\/\n-      testcase( i==93 ); \/* VALUES *\/\n-      testcase( i==94 ); \/* VIRTUAL *\/\n-      testcase( i==95 ); \/* ALWAYS *\/\n-      testcase( i==96 ); \/* WHEN *\/\n-      testcase( i==97 ); \/* WHERE *\/\n-      testcase( i==98 ); \/* RECURSIVE *\/\n-      testcase( i==99 ); \/* ABORT *\/\n-      testcase( i==100 ); \/* AFTER *\/\n-      testcase( i==101 ); \/* RENAME *\/\n-      testcase( i==102 ); \/* AND *\/\n-      testcase( i==103 ); \/* DROP *\/\n-      testcase( i==104 ); \/* PARTITION *\/\n-      testcase( i==105 ); \/* AUTOINCREMENT *\/\n-      testcase( i==106 ); \/* TO *\/\n-      testcase( i==107 ); \/* IN *\/\n-      testcase( i==108 ); \/* CAST *\/\n-      testcase( i==109 ); \/* COLUMN *\/\n-      testcase( i==110 ); \/* COMMIT *\/\n-      testcase( i==111 ); \/* CONFLICT *\/\n-      testcase( i==112 ); \/* CROSS *\/\n-      testcase( i==113 ); \/* CURRENT_TIMESTAMP *\/\n-      testcase( i==114 ); \/* CURRENT_TIME *\/\n-      testcase( i==115 ); \/* CURRENT *\/\n-      testcase( i==116 ); \/* PRECEDING *\/\n-      testcase( i==117 ); \/* FAIL *\/\n-      testcase( i==118 ); \/* LAST *\/\n-      testcase( i==119 ); \/* FILTER *\/\n-      testcase( i==120 ); \/* REPLACE *\/\n-      testcase( i==121 ); \/* FIRST *\/\n-      testcase( i==122 ); \/* FOLLOWING *\/\n-      testcase( i==123 ); \/* FROM *\/\n-      testcase( i==124 ); \/* FULL *\/\n-      testcase( i==125 ); \/* LIMIT *\/\n-      testcase( i==126 ); \/* IF *\/\n-      testcase( i==127 ); \/* ORDER *\/\n-      testcase( i==128 ); \/* RESTRICT *\/\n-      testcase( i==129 ); \/* OTHERS *\/\n-      testcase( i==130 ); \/* OVER *\/\n-      testcase( i==131 ); \/* RETURNING *\/\n-      testcase( i==132 ); \/* RIGHT *\/\n-      testcase( i==133 ); \/* ROLLBACK *\/\n-      testcase( i==134 ); \/* ROWS *\/\n-      testcase( i==135 ); \/* ROW *\/\n-      testcase( i==136 ); \/* UNBOUNDED *\/\n-      testcase( i==137 ); \/* UNION *\/\n-      testcase( i==138 ); \/* USING *\/\n-      testcase( i==139 ); \/* VACUUM *\/\n-      testcase( i==140 ); \/* VIEW *\/\n-      testcase( i==141 ); \/* WINDOW *\/\n-      testcase( i==142 ); \/* DO *\/\n-      testcase( i==143 ); \/* BY *\/\n-      testcase( i==144 ); \/* INITIALLY *\/\n-      testcase( i==145 ); \/* ALL *\/\n-      testcase( i==146 ); \/* PRIMARY *\/\n-      *pType = aKWCode[i];\n-      break;\n-    }\n+    if( toupper(z[0])!=zKW[0] ) continue;\n+    if( toupper(z[1])!=zKW[1] ) continue;\n+    j = 2;\n+    while( j<n && toupper(z[j])==zKW[j] ){ j++; }\n+#endif\n+    if( j<n ) continue;\n+    testcase( i==1 ); \/* REINDEX *\/\n+    testcase( i==2 ); \/* INDEXED *\/\n+    testcase( i==3 ); \/* INDEX *\/\n+    testcase( i==4 ); \/* DESC *\/\n+    testcase( i==5 ); \/* ESCAPE *\/\n+    testcase( i==6 ); \/* EACH *\/\n+    testcase( i==7 ); \/* CHECK *\/\n+    testcase( i==8 ); \/* KEY *\/\n+    testcase( i==9 ); \/* BEFORE *\/\n+    testcase( i==10 ); \/* FOREIGN *\/\n+    testcase( i==11 ); \/* FOR *\/\n+    testcase( i==12 ); \/* IGNORE *\/\n+    testcase( i==13 ); \/* REGEXP *\/\n+    testcase( i==14 ); \/* EXPLAIN *\/\n+    testcase( i==15 ); \/* INSTEAD *\/\n+    testcase( i==16 ); \/* ADD *\/\n+    testcase( i==17 ); \/* DATABASE *\/\n+    testcase( i==18 ); \/* AS *\/\n+    testcase( i==19 ); \/* SELECT *\/\n+    testcase( i==20 ); \/* TABLE *\/\n+    testcase( i==21 ); \/* LEFT *\/\n+    testcase( i==22 ); \/* THEN *\/\n+    testcase( i==23 ); \/* END *\/\n+    testcase( i==24 ); \/* DEFERRABLE *\/\n+    testcase( i==25 ); \/* ELSE *\/\n+    testcase( i==26 ); \/* EXCLUDE *\/\n+    testcase( i==27 ); \/* DELETE *\/\n+    testcase( i==28 ); \/* TEMPORARY *\/\n+    testcase( i==29 ); \/* TEMP *\/\n+    testcase( i==30 ); \/* OR *\/\n+    testcase( i==31 ); \/* ISNULL *\/\n+    testcase( i==32 ); \/* NULLS *\/\n+    testcase( i==33 ); \/* SAVEPOINT *\/\n+    testcase( i==34 ); \/* INTERSECT *\/\n+    testcase( i==35 ); \/* TIES *\/\n+    testcase( i==36 ); \/* NOTNULL *\/\n+    testcase( i==37 ); \/* NOT *\/\n+    testcase( i==38 ); \/* NO *\/\n+    testcase( i==39 ); \/* NULL *\/\n+    testcase( i==40 ); \/* LIKE *\/\n+    testcase( i==41 ); \/* EXCEPT *\/\n+    testcase( i==42 ); \/* TRANSACTION *\/\n+    testcase( i==43 ); \/* ACTION *\/\n+    testcase( i==44 ); \/* ON *\/\n+    testcase( i==45 ); \/* NATURAL *\/\n+    testcase( i==46 ); \/* ALTER *\/\n+    testcase( i==47 ); \/* RAISE *\/\n+    testcase( i==48 ); \/* EXCLUSIVE *\/\n+    testcase( i==49 ); \/* EXISTS *\/\n+    testcase( i==50 ); \/* CONSTRAINT *\/\n+    testcase( i==51 ); \/* INTO *\/\n+    testcase( i==52 ); \/* OFFSET *\/\n+    testcase( i==53 ); \/* OF *\/\n+    testcase( i==54 ); \/* SET *\/\n+    testcase( i==55 ); \/* TRIGGER *\/\n+    testcase( i==56 ); \/* RANGE *\/\n+    testcase( i==57 ); \/* GENERATED *\/\n+    testcase( i==58 ); \/* DETACH *\/\n+    testcase( i==59 ); \/* HAVING *\/\n+    testcase( i==60 ); \/* GLOB *\/\n+    testcase( i==61 ); \/* BEGIN *\/\n+    testcase( i==62 ); \/* INNER *\/\n+    testcase( i==63 ); \/* REFERENCES *\/\n+    testcase( i==64 ); \/* UNIQUE *\/\n+    testcase( i==65 ); \/* QUERY *\/\n+    testcase( i==66 ); \/* WITHOUT *\/\n+    testcase( i==67 ); \/* WITH *\/\n+    testcase( i==68 ); \/* OUTER *\/\n+    testcase( i==69 ); \/* RELEASE *\/\n+    testcase( i==70 ); \/* ATTACH *\/\n+    testcase( i==71 ); \/* BETWEEN *\/\n+    testcase( i==72 ); \/* NOTHING *\/\n+    testcase( i==73 ); \/* GROUPS *\/\n+    testcase( i==74 ); \/* GROUP *\/\n+    testcase( i==75 ); \/* CASCADE *\/\n+    testcase( i==76 ); \/* ASC *\/\n+    testcase( i==77 ); \/* DEFAULT *\/\n+    testcase( i==78 ); \/* CASE *\/\n+    testcase( i==79 ); \/* COLLATE *\/\n+    testcase( i==80 ); \/* CREATE *\/\n+    testcase( i==81 ); \/* CURRENT_DATE *\/\n+    testcase( i==82 ); \/* IMMEDIATE *\/\n+    testcase( i==83 ); \/* JOIN *\/\n+    testcase( i==84 ); \/* INSERT *\/\n+    testcase( i==85 ); \/* MATCH *\/\n+    testcase( i==86 ); \/* PLAN *\/\n+    testcase( i==87 ); \/* ANALYZE *\/\n+    testcase( i==88 ); \/* PRAGMA *\/\n+    testcase( i==89 ); \/* MATERIALIZED *\/\n+    testcase( i==90 ); \/* DEFERRED *\/\n+    testcase( i==91 ); \/* DISTINCT *\/\n+    testcase( i==92 ); \/* IS *\/\n+    testcase( i==93 ); \/* UPDATE *\/\n+    testcase( i==94 ); \/* VALUES *\/\n+    testcase( i==95 ); \/* VIRTUAL *\/\n+    testcase( i==96 ); \/* ALWAYS *\/\n+    testcase( i==97 ); \/* WHEN *\/\n+    testcase( i==98 ); \/* WHERE *\/\n+    testcase( i==99 ); \/* RECURSIVE *\/\n+    testcase( i==100 ); \/* ABORT *\/\n+    testcase( i==101 ); \/* AFTER *\/\n+    testcase( i==102 ); \/* RENAME *\/\n+    testcase( i==103 ); \/* AND *\/\n+    testcase( i==104 ); \/* DROP *\/\n+    testcase( i==105 ); \/* PARTITION *\/\n+    testcase( i==106 ); \/* AUTOINCREMENT *\/\n+    testcase( i==107 ); \/* TO *\/\n+    testcase( i==108 ); \/* IN *\/\n+    testcase( i==109 ); \/* CAST *\/\n+    testcase( i==110 ); \/* COLUMN *\/\n+    testcase( i==111 ); \/* COMMIT *\/\n+    testcase( i==112 ); \/* CONFLICT *\/\n+    testcase( i==113 ); \/* CROSS *\/\n+    testcase( i==114 ); \/* CURRENT_TIMESTAMP *\/\n+    testcase( i==115 ); \/* CURRENT_TIME *\/\n+    testcase( i==116 ); \/* CURRENT *\/\n+    testcase( i==117 ); \/* PRECEDING *\/\n+    testcase( i==118 ); \/* FAIL *\/\n+    testcase( i==119 ); \/* LAST *\/\n+    testcase( i==120 ); \/* FILTER *\/\n+    testcase( i==121 ); \/* REPLACE *\/\n+    testcase( i==122 ); \/* FIRST *\/\n+    testcase( i==123 ); \/* FOLLOWING *\/\n+    testcase( i==124 ); \/* FROM *\/\n+    testcase( i==125 ); \/* FULL *\/\n+    testcase( i==126 ); \/* LIMIT *\/\n+    testcase( i==127 ); \/* IF *\/\n+    testcase( i==128 ); \/* ORDER *\/\n+    testcase( i==129 ); \/* RESTRICT *\/\n+    testcase( i==130 ); \/* OTHERS *\/\n+    testcase( i==131 ); \/* OVER *\/\n+    testcase( i==132 ); \/* RETURNING *\/\n+    testcase( i==133 ); \/* RIGHT *\/\n+    testcase( i==134 ); \/* ROLLBACK *\/\n+    testcase( i==135 ); \/* ROWS *\/\n+    testcase( i==136 ); \/* ROW *\/\n+    testcase( i==137 ); \/* UNBOUNDED *\/\n+    testcase( i==138 ); \/* UNION *\/\n+    testcase( i==139 ); \/* USING *\/\n+    testcase( i==140 ); \/* VACUUM *\/\n+    testcase( i==141 ); \/* VIEW *\/\n+    testcase( i==142 ); \/* WINDOW *\/\n+    testcase( i==143 ); \/* DO *\/\n+    testcase( i==144 ); \/* BY *\/\n+    testcase( i==145 ); \/* INITIALLY *\/\n+    testcase( i==146 ); \/* ALL *\/\n+    testcase( i==147 ); \/* PRIMARY *\/\n+    *pType = aKWCode[i];\n+    break;\n@@ -169585,1 +177207,1 @@\n-  keywordCode((char*)z, n, &id);\n+  if( n>=2 ) keywordCode((char*)z, n, &id);\n@@ -169591,0 +177213,1 @@\n+  i++;\n@@ -169889,1 +177512,1 @@\n-      testcase( z[0]=='9' );\n+      testcase( z[0]=='9' );  testcase( z[0]=='.' );\n@@ -169961,1 +177584,2 @@\n-      for(i=1; aiClass[z[i]]<=CC_KYWD; i++){}\n+      if( aiClass[z[1]]>CC_KYWD ){ i = 1;  break; }\n+      for(i=2; aiClass[z[i]]<=CC_KYWD; i++){}\n@@ -170167,1 +177791,1 @@\n-  if( pParse->pVList ) sqlite3DbFreeNN(db, pParse->pVList);\n+  if( pParse->pVList ) sqlite3DbNNFreeNN(db, pParse->pVList);\n@@ -170740,6 +178364,0 @@\n-#ifdef SQLITE_ENABLE_FTS1\n-SQLITE_PRIVATE int sqlite3Fts1Init(sqlite3*);\n-#endif\n-#ifdef SQLITE_ENABLE_FTS2\n-SQLITE_PRIVATE int sqlite3Fts2Init(sqlite3*);\n-#endif\n@@ -170752,1 +178370,3 @@\n-\n+#ifdef SQLITE_EXTRA_AUTOEXT\n+int SQLITE_EXTRA_AUTOEXT(sqlite3*);\n+#endif\n@@ -170758,6 +178378,0 @@\n-#ifdef SQLITE_ENABLE_FTS1\n-  sqlite3Fts1Init,\n-#endif\n-#ifdef SQLITE_ENABLE_FTS2\n-  sqlite3Fts2Init,\n-#endif\n@@ -170792,0 +178406,3 @@\n+#ifdef SQLITE_EXTRA_AUTOEXT\n+  SQLITE_EXTRA_AUTOEXT,\n+#endif\n@@ -170865,0 +178482,26 @@\n+\/*\n+** Determine whether or not high-precision (long double) floating point\n+** math works correctly on CPU currently running.\n+*\/\n+static SQLITE_NOINLINE int hasHighPrecisionDouble(int rc){\n+  if( sizeof(LONGDOUBLE_TYPE)<=8 ){\n+    \/* If the size of \"long double\" is not more than 8, then\n+    ** high-precision math is not possible. *\/\n+    return 0;\n+  }else{\n+    \/* Just because sizeof(long double)>8 does not mean that the underlying\n+    ** hardware actually supports high-precision floating point.  For example,\n+    ** clearing the 0x100 bit in the floating-point control word on Intel\n+    ** processors will make long double work like double, even though long\n+    ** double takes up more space.  The only way to determine if long double\n+    ** actually works is to run an experiment. *\/\n+    LONGDOUBLE_TYPE a, b, c;\n+    rc++;\n+    a = 1.0+rc*0.1;\n+    b = 1.0e+18+rc*25.0;\n+    c = a+b;\n+    return b!=c;\n+  }\n+}\n+\n+\n@@ -171060,0 +178703,6 @@\n+  \/* Experimentally determine if high-precision floating point is\n+  ** available. *\/\n+#ifndef SQLITE_OMIT_WSD\n+  sqlite3Config.bUseLongDouble = hasHighPrecisionDouble(rc);\n+#endif\n+\n@@ -171129,3 +178778,15 @@\n-  \/* sqlite3_config() shall return SQLITE_MISUSE if it is invoked while\n-  ** the SQLite library is in use. *\/\n-  if( sqlite3GlobalConfig.isInit ) return SQLITE_MISUSE_BKPT;\n+  \/* sqlite3_config() normally returns SQLITE_MISUSE if it is invoked while\n+  ** the SQLite library is in use.  Except, a few selected opcodes\n+  ** are allowed.\n+  *\/\n+  if( sqlite3GlobalConfig.isInit ){\n+    static const u64 mAnytimeConfigOption = 0\n+       | MASKBIT64( SQLITE_CONFIG_LOG )\n+       | MASKBIT64( SQLITE_CONFIG_PCACHE_HDRSZ )\n+    ;\n+    if( op<0 || op>63 || (MASKBIT64(op) & mAnytimeConfigOption)==0 ){\n+      return SQLITE_MISUSE_BKPT;\n+    }\n+    testcase( op==SQLITE_CONFIG_LOG );\n+    testcase( op==SQLITE_CONFIG_PCACHE_HDRSZ );\n+  }\n@@ -171200,0 +178861,1 @@\n+      assert( !sqlite3GlobalConfig.isInit );  \/* Cannot change at runtime *\/\n@@ -171323,2 +178985,4 @@\n-      sqlite3GlobalConfig.xLog = va_arg(ap, LOGFUNC_t);\n-      sqlite3GlobalConfig.pLogArg = va_arg(ap, void*);\n+      LOGFUNC_t xLog = va_arg(ap, LOGFUNC_t);\n+      void *pLogArg = va_arg(ap, void*);\n+      AtomicStore(&sqlite3GlobalConfig.xLog, xLog);\n+      AtomicStore(&sqlite3GlobalConfig.pLogArg, pLogArg);\n@@ -171338,1 +179002,2 @@\n-      sqlite3GlobalConfig.bOpenUri = va_arg(ap, int);\n+      int bOpenUri = va_arg(ap, int);\n+      AtomicStore(&sqlite3GlobalConfig.bOpenUri, bOpenUri);\n@@ -171423,0 +179088,12 @@\n+    case SQLITE_CONFIG_ROWID_IN_VIEW: {\n+      int *pVal = va_arg(ap,int*);\n+#ifdef SQLITE_ALLOW_ROWID_IN_VIEW\n+      if( 0==*pVal ) sqlite3GlobalConfig.mNoVisibleRowid = TF_NoVisibleRowid;\n+      if( 1==*pVal ) sqlite3GlobalConfig.mNoVisibleRowid = 0;\n+      *pVal = (sqlite3GlobalConfig.mNoVisibleRowid==0);\n+#else\n+      *pVal = 0;\n+#endif\n+      break;\n+    }\n+\n@@ -171523,1 +179200,1 @@\n-    db->lookaside.pStart = db;\n+    db->lookaside.pStart = 0;\n@@ -171527,1 +179204,1 @@\n-    db->lookaside.pMiddle = db;\n+    db->lookaside.pMiddle = 0;\n@@ -171529,1 +179206,1 @@\n-    db->lookaside.pEnd = db;\n+    db->lookaside.pEnd = 0;\n@@ -171535,0 +179212,1 @@\n+  db->lookaside.pTrueEnd = db->lookaside.pEnd;\n@@ -171613,0 +179291,5 @@\n+\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n+#endif\n+  sqlite3_mutex_enter(db->mutex);\n@@ -171651,0 +179334,2 @@\n+        { SQLITE_DBCONFIG_STMT_SCANSTATUS,       SQLITE_StmtScanStatus },\n+        { SQLITE_DBCONFIG_REVERSE_SCANORDER,     SQLITE_ReverseOrder   },\n@@ -171678,0 +179363,1 @@\n+  sqlite3_mutex_leave(db->mutex);\n@@ -171938,0 +179624,8 @@\n+  while( db->pDbData ){\n+    DbClientData *p = db->pDbData;\n+    db->pDbData = p->pNext;\n+    assert( p->pData!=0 );\n+    if( p->xDestructor ) p->xDestructor(p->pData);\n+    sqlite3_free(p);\n+  }\n+\n@@ -172262,0 +179956,1 @@\n+      case SQLITE_NOTICE_RBU:         zName = \"SQLITE_NOTICE_RBU\"; break;\n@@ -172354,1 +180049,1 @@\n-#if SQLITE_OS_WIN || HAVE_USLEEP\n+#if SQLITE_OS_WIN || !defined(HAVE_NANOSLEEP) || HAVE_NANOSLEEP\n@@ -172356,1 +180051,1 @@\n-  ** a second.  Examples:  All windows systems, unix systems with usleep() *\/\n+  ** a second.  Examples:  All windows systems, unix systems with nanosleep() *\/\n@@ -172491,1 +180186,3 @@\n-  if( !sqlite3SafetyCheckOk(db) && (db==0 || db->eOpenState!=SQLITE_STATE_ZOMBIE) ){\n+  if( !sqlite3SafetyCheckOk(db)\n+   && (db==0 || db->eOpenState!=SQLITE_STATE_ZOMBIE)\n+  ){\n@@ -172499,0 +180196,15 @@\n+\/*\n+** Return true or false depending on whether or not an interrupt is\n+** pending on connection db.\n+*\/\n+SQLITE_API int sqlite3_is_interrupted(sqlite3 *db){\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( !sqlite3SafetyCheckOk(db)\n+   && (db==0 || db->eOpenState!=SQLITE_STATE_ZOMBIE)\n+  ){\n+    (void)SQLITE_MISUSE_BKPT;\n+    return 0;\n+  }\n+#endif\n+  return AtomicLoad(&db->u1.isInterrupted)!=0;\n+}\n@@ -172537,1 +180249,1 @@\n-                       SQLITE_SUBTYPE|SQLITE_INNOCUOUS);\n+                       SQLITE_SUBTYPE|SQLITE_INNOCUOUS|SQLITE_RESULT_SUBTYPE);\n@@ -172543,1 +180255,1 @@\n-  extraFlags ^= SQLITE_FUNC_UNSAFE;\n+  extraFlags ^= SQLITE_FUNC_UNSAFE;  \/* tag-20230109-1 *\/\n@@ -172561,1 +180273,1 @@\n-           (SQLITE_UTF8|extraFlags)^SQLITE_FUNC_UNSAFE,\n+           (SQLITE_UTF8|extraFlags)^SQLITE_FUNC_UNSAFE, \/* tag-20230109-1 *\/\n@@ -172565,1 +180277,1 @@\n-             (SQLITE_UTF16LE|extraFlags)^SQLITE_FUNC_UNSAFE,\n+             (SQLITE_UTF16LE|extraFlags)^SQLITE_FUNC_UNSAFE, \/* tag-20230109-1*\/\n@@ -172814,1 +180526,1 @@\n-  zCopy = sqlite3_mprintf(zName);\n+  zCopy = sqlite3_mprintf(\"%s\", zName);\n@@ -172994,0 +180706,6 @@\n+\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( db==0 ){\n+    return 0;\n+  }\n+#endif\n@@ -173140,1 +180858,1 @@\n-    return SQLITE_MISUSE;\n+    return SQLITE_MISUSE_BKPT;\n@@ -173617,3 +181335,3 @@\n-  if( ((flags & SQLITE_OPEN_URI)             \/* IMP: R-48725-32206 *\/\n-            || sqlite3GlobalConfig.bOpenUri) \/* IMP: R-51689-46548 *\/\n-   && nUri>=5 && memcmp(zUri, \"file:\", 5)==0 \/* IMP: R-57884-37496 *\/\n+  if( ((flags & SQLITE_OPEN_URI)                     \/* IMP: R-48725-32206 *\/\n+       || AtomicLoad(&sqlite3GlobalConfig.bOpenUri)) \/* IMP: R-51689-46548 *\/\n+   && nUri>=5 && memcmp(zUri, \"file:\", 5)==0         \/* IMP: R-57884-37496 *\/\n@@ -173977,1 +181695,1 @@\n-** and so that is the default.  But developers are encouranged to use\n+** and so that is the default.  But developers are encouraged to use\n@@ -174025,0 +181743,3 @@\n+#endif\n+#if defined(SQLITE_ENABLE_STMT_SCANSTATUS)\n+                 | SQLITE_StmtScanStatus\n@@ -174048,0 +181769,13 @@\n+#if SQLITE_OS_UNIX && defined(SQLITE_OS_KV_OPTIONAL)\n+  \/* Process magic filenames \":localStorage:\" and \":sessionStorage:\" *\/\n+  if( zFilename && zFilename[0]==':' ){\n+    if( strcmp(zFilename, \":localStorage:\")==0 ){\n+      zFilename = \"file:local?vfs=kvvfs\";\n+      flags |= SQLITE_OPEN_URI;\n+    }else if( strcmp(zFilename, \":sessionStorage:\")==0 ){\n+      zFilename = \"file:session?vfs=kvvfs\";\n+      flags |= SQLITE_OPEN_URI;\n+    }\n+  }\n+#endif \/* SQLITE_OS_UNIX && defined(SQLITE_OS_KV_OPTIONAL) *\/\n+\n@@ -174078,0 +181812,6 @@\n+  assert( db->pVfs!=0 );\n+#if SQLITE_OS_KV || defined(SQLITE_OS_KV_OPTIONAL)\n+  if( sqlite3_stricmp(db->pVfs->zName, \"kvvfs\")==0 ){\n+    db->temp_store = 2;\n+  }\n+#endif\n@@ -174355,0 +182095,63 @@\n+\/*\n+** Find existing client data.\n+*\/\n+SQLITE_API void *sqlite3_get_clientdata(sqlite3 *db, const char *zName){\n+  DbClientData *p;\n+  sqlite3_mutex_enter(db->mutex);\n+  for(p=db->pDbData; p; p=p->pNext){\n+    if( strcmp(p->zName, zName)==0 ){\n+      void *pResult = p->pData;\n+      sqlite3_mutex_leave(db->mutex);\n+      return pResult;\n+    }\n+  }\n+  sqlite3_mutex_leave(db->mutex);\n+  return 0;\n+}\n+\n+\/*\n+** Add new client data to a database connection.\n+*\/\n+SQLITE_API int sqlite3_set_clientdata(\n+  sqlite3 *db,                   \/* Attach client data to this connection *\/\n+  const char *zName,             \/* Name of the client data *\/\n+  void *pData,                   \/* The client data itself *\/\n+  void (*xDestructor)(void*)     \/* Destructor *\/\n+){\n+  DbClientData *p, **pp;\n+  sqlite3_mutex_enter(db->mutex);\n+  pp = &db->pDbData;\n+  for(p=db->pDbData; p && strcmp(p->zName,zName); p=p->pNext){\n+    pp = &p->pNext;\n+  }\n+  if( p ){\n+    assert( p->pData!=0 );\n+    if( p->xDestructor ) p->xDestructor(p->pData);\n+    if( pData==0 ){\n+      *pp = p->pNext;\n+      sqlite3_free(p);\n+      sqlite3_mutex_leave(db->mutex);\n+      return SQLITE_OK;\n+    }\n+  }else if( pData==0 ){\n+    sqlite3_mutex_leave(db->mutex);\n+    return SQLITE_OK;\n+  }else{\n+    size_t n = strlen(zName);\n+    p = sqlite3_malloc64( sizeof(DbClientData)+n+1 );\n+    if( p==0 ){\n+      if( xDestructor ) xDestructor(pData);\n+      sqlite3_mutex_leave(db->mutex);\n+      return SQLITE_NOMEM;\n+    }\n+    memcpy(p->zName, zName, n+1);\n+    p->pNext = db->pDbData;\n+    db->pDbData = p;\n+  }\n+  p->pData = pData;\n+  p->xDestructor = xDestructor;\n+  sqlite3_mutex_leave(db->mutex);\n+  return SQLITE_OK;\n+}\n+\n+\n@@ -174490,1 +182293,1 @@\n-    \/* Query for existance of table only *\/\n+    \/* Query for existence of table only *\/\n@@ -174571,1 +182374,1 @@\n-  rc = (sqlite3OsSleep(pVfs, 1000*ms)\/1000);\n+  rc = (sqlite3OsSleep(pVfs, ms<0 ? 0 : 1000*ms)\/1000);\n@@ -174627,0 +182430,3 @@\n+    }else if( op==SQLITE_FCNTL_RESET_CACHE ){\n+      sqlite3BtreeClearCache(pBtree);\n+      rc = SQLITE_OK;\n@@ -174701,0 +182507,22 @@\n+    \/*  sqlite3_test_control(SQLITE_TESTCTRL_FK_NO_ACTION, sqlite3 *db, int b);\n+    **\n+    ** If b is true, then activate the SQLITE_FkNoAction setting.  If b is\n+    ** false then clearn that setting.  If the SQLITE_FkNoAction setting is\n+    ** abled, all foreign key ON DELETE and ON UPDATE actions behave as if\n+    ** they were NO ACTION, regardless of how they are defined.\n+    **\n+    ** NB:  One must usually run \"PRAGMA writable_schema=RESET\" after\n+    ** using this test-control, before it will take full effect.  failing\n+    ** to reset the schema can result in some unexpected behavior.\n+    *\/\n+    case SQLITE_TESTCTRL_FK_NO_ACTION: {\n+      sqlite3 *db = va_arg(ap, sqlite3*);\n+      int b = va_arg(ap, int);\n+      if( b ){\n+        db->flags |= SQLITE_FkNoAction;\n+      }else{\n+        db->flags &= ~SQLITE_FkNoAction;\n+      }\n+      break;\n+    }\n+\n@@ -174807,0 +182635,1 @@\n+#ifndef SQLITE_OMIT_TRIGGER\n@@ -174811,0 +182640,1 @@\n+#endif\n@@ -174927,1 +182757,1 @@\n-    ** that demonstrat invariants on well-formed database files.\n+    ** that demonstrate invariants on well-formed database files.\n@@ -175081,1 +182911,1 @@\n-    **   op==3       Store the current sqlite3WhereTrace in *ptr\n+    **   op==2       Store the current sqlite3WhereTrace in *ptr\n@@ -175117,0 +182947,17 @@\n+#if !defined(SQLITE_OMIT_WSD)\n+    \/* sqlite3_test_control(SQLITE_TESTCTRL_USELONGDOUBLE, int X);\n+    **\n+    **   X<0     Make no changes to the bUseLongDouble.  Just report value.\n+    **   X==0    Disable bUseLongDouble\n+    **   X==1    Enable bUseLongDouble\n+    **   X>=2    Set bUseLongDouble to its default value for this platform\n+    *\/\n+    case SQLITE_TESTCTRL_USELONGDOUBLE: {\n+      int b = va_arg(ap, int);\n+      if( b>=2 ) b = hasHighPrecisionDouble(b);\n+      if( b>=0 ) sqlite3Config.bUseLongDouble = b>0;\n+      rc = sqlite3Config.bUseLongDouble!=0;\n+      break;\n+    }\n+#endif\n+\n@@ -175147,0 +182994,22 @@\n+\n+    \/* sqlite3_test_control(SQLITE_TESTCTRL_JSON_SELFCHECK, &onOff);\n+    **\n+    ** Activate or deactivate validation of JSONB that is generated from\n+    ** text.  Off by default, as the validation is slow.  Validation is\n+    ** only available if compiled using SQLITE_DEBUG.\n+    **\n+    ** If onOff is initially 1, then turn it on.  If onOff is initially\n+    ** off, turn it off.  If onOff is initially -1, then change onOff\n+    ** to be the current setting.\n+    *\/\n+    case SQLITE_TESTCTRL_JSON_SELFCHECK: {\n+#if defined(SQLITE_DEBUG) && !defined(SQLITE_OMIT_WSD)\n+      int *pOnOff = va_arg(ap, int*);\n+      if( *pOnOff<0 ){\n+        *pOnOff = sqlite3Config.bJsonSelfcheck;\n+      }else{\n+        sqlite3Config.bJsonSelfcheck = (u8)((*pOnOff)&0xff);\n+      }\n+#endif\n+      break;\n+    }\n@@ -175187,1 +183056,1 @@\n-SQLITE_API char *sqlite3_create_filename(\n+SQLITE_API const char *sqlite3_create_filename(\n@@ -175223,1 +183092,1 @@\n-SQLITE_API void sqlite3_free_filename(char *p){\n+SQLITE_API void sqlite3_free_filename(const char *p){\n@@ -175225,2 +183094,2 @@\n-  p = (char*)databaseName(p);\n-  sqlite3_free(p - 4);\n+  p = databaseName(p);\n+  sqlite3_free((char*)p - 4);\n@@ -175417,1 +183286,1 @@\n-** Open a read-transaction on the snapshot idendified by pSnapshot.\n+** Open a read-transaction on the snapshot identified by pSnapshot.\n@@ -175477,1 +183346,0 @@\n-  int iDb;\n@@ -175479,0 +183347,1 @@\n+  int iDb;\n@@ -175524,1 +183393,1 @@\n-#if SQLITE_ENABLE_API_ARMOR\n+#ifdef SQLITE_ENABLE_API_ARMOR\n@@ -175719,0 +183588,3 @@\n+#ifdef SQLITE_ENABLE_API_ARMOR\n+  if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n+#endif\n@@ -176740,0 +184612,1 @@\n+  int iSavepoint;\n@@ -177125,0 +184998,4 @@\n+SQLITE_PRIVATE int sqlite3Fts3ExprIterate(Fts3Expr*, int (*x)(Fts3Expr*,int,void*), void*);\n+\n+SQLITE_PRIVATE int sqlite3Fts3IntegrityCheck(Fts3Table *p, int *pbOk);\n+\n@@ -177481,0 +185358,1 @@\n+    sqlite3_vtab_config(p->db, SQLITE_VTAB_INNOCUOUS);\n@@ -180730,0 +188608,2 @@\n+  p->bIgnoreSavepoint = 1;\n+\n@@ -180757,0 +188637,2 @@\n+\n+  p->bIgnoreSavepoint = 0;\n@@ -180767,6 +188649,22 @@\n-  UNUSED_PARAMETER(iSavepoint);\n-  assert( ((Fts3Table *)pVtab)->inTransaction );\n-  assert( ((Fts3Table *)pVtab)->mxSavepoint <= iSavepoint );\n-  TESTONLY( ((Fts3Table *)pVtab)->mxSavepoint = iSavepoint );\n-  if( ((Fts3Table *)pVtab)->bIgnoreSavepoint==0 ){\n-    rc = fts3SyncMethod(pVtab);\n+  Fts3Table *pTab = (Fts3Table*)pVtab;\n+  assert( pTab->inTransaction );\n+  assert( pTab->mxSavepoint<=iSavepoint );\n+  TESTONLY( pTab->mxSavepoint = iSavepoint );\n+\n+  if( pTab->bIgnoreSavepoint==0 ){\n+    if( fts3HashCount(&pTab->aIndex[0].hPending)>0 ){\n+      char *zSql = sqlite3_mprintf(\"INSERT INTO %Q.%Q(%Q) VALUES('flush')\",\n+          pTab->zDb, pTab->zName, pTab->zName\n+          );\n+      if( zSql ){\n+        pTab->bIgnoreSavepoint = 1;\n+        rc = sqlite3_exec(pTab->db, zSql, 0, 0, 0);\n+        pTab->bIgnoreSavepoint = 0;\n+        sqlite3_free(zSql);\n+      }else{\n+        rc = SQLITE_NOMEM;\n+      }\n+    }\n+    if( rc==SQLITE_OK ){\n+      pTab->iSavepoint = iSavepoint+1;\n+    }\n@@ -180783,6 +188681,5 @@\n-  TESTONLY( Fts3Table *p = (Fts3Table*)pVtab );\n-  UNUSED_PARAMETER(iSavepoint);\n-  UNUSED_PARAMETER(pVtab);\n-  assert( p->inTransaction );\n-  assert( p->mxSavepoint >= iSavepoint );\n-  TESTONLY( p->mxSavepoint = iSavepoint-1 );\n+  Fts3Table *pTab = (Fts3Table*)pVtab;\n+  assert( pTab->inTransaction );\n+  assert( pTab->mxSavepoint >= iSavepoint );\n+  TESTONLY( pTab->mxSavepoint = iSavepoint-1 );\n+  pTab->iSavepoint = iSavepoint;\n@@ -180798,1 +188695,1 @@\n-  Fts3Table *p = (Fts3Table*)pVtab;\n+  Fts3Table *pTab = (Fts3Table*)pVtab;\n@@ -180800,3 +188697,5 @@\n-  assert( p->inTransaction );\n-  TESTONLY( p->mxSavepoint = iSavepoint );\n-  sqlite3Fts3PendingTermsClear(p);\n+  assert( pTab->inTransaction );\n+  TESTONLY( pTab->mxSavepoint = iSavepoint );\n+  if( (iSavepoint+1)<=pTab->iSavepoint ){\n+    sqlite3Fts3PendingTermsClear(pTab);\n+  }\n@@ -180821,0 +188720,32 @@\n+\/*\n+** Implementation of the xIntegrity() method on the FTS3\/FTS4 virtual\n+** table.\n+*\/\n+static int fts3IntegrityMethod(\n+  sqlite3_vtab *pVtab,      \/* The virtual table to be checked *\/\n+  const char *zSchema,      \/* Name of schema in which pVtab lives *\/\n+  const char *zTabname,     \/* Name of the pVTab table *\/\n+  int isQuick,              \/* True if this is a quick_check *\/\n+  char **pzErr              \/* Write error message here *\/\n+){\n+  Fts3Table *p = (Fts3Table*)pVtab;\n+  int rc;\n+  int bOk = 0;\n+\n+  UNUSED_PARAMETER(isQuick);\n+  rc = sqlite3Fts3IntegrityCheck(p, &bOk);\n+  assert( rc!=SQLITE_CORRUPT_VTAB || bOk==0 );\n+  if( rc!=SQLITE_OK && rc!=SQLITE_CORRUPT_VTAB ){\n+    *pzErr = sqlite3_mprintf(\"unable to validate the inverted index for\"\n+                             \" FTS%d table %s.%s: %s\",\n+                p->bFts4 ? 4 : 3, zSchema, zTabname, sqlite3_errstr(rc));\n+  }else if( bOk==0 ){\n+    *pzErr = sqlite3_mprintf(\"malformed inverted index for FTS%d table %s.%s\",\n+                p->bFts4 ? 4 : 3, zSchema, zTabname);\n+  }\n+  sqlite3Fts3SegmentsClose(p);\n+  return SQLITE_OK;\n+}\n+\n+\n+\n@@ -180822,1 +188753,1 @@\n-  \/* iVersion      *\/ 3,\n+  \/* iVersion      *\/ 4,\n@@ -180846,0 +188777,1 @@\n+  \/* xIntegrity    *\/ fts3IntegrityMethod,\n@@ -182128,1 +190060,1 @@\n-  if( *pRc==SQLITE_OK ){\n+  if( *pRc==SQLITE_OK && pExpr->bEof==0 ){\n@@ -182130,1 +190062,0 @@\n-    assert( pExpr->bEof==0 );\n@@ -182606,0 +190537,16 @@\n+\/*\n+** This is an sqlite3Fts3ExprIterate() callback. If the Fts3Expr.aMI[] array\n+** has not yet been allocated, allocate and zero it. Otherwise, just zero\n+** it.\n+*\/\n+static int fts3AllocateMSI(Fts3Expr *pExpr, int iPhrase, void *pCtx){\n+  Fts3Table *pTab = (Fts3Table*)pCtx;\n+  UNUSED_PARAMETER(iPhrase);\n+  if( pExpr->aMI==0 ){\n+    pExpr->aMI = (u32 *)sqlite3_malloc64(pTab->nColumn * 3 * sizeof(u32));\n+    if( pExpr->aMI==0 ) return SQLITE_NOMEM;\n+  }\n+  memset(pExpr->aMI, 0, pTab->nColumn * 3 * sizeof(u32));\n+  return SQLITE_OK;\n+}\n+\n@@ -182627,1 +190574,0 @@\n-    Fts3Expr *p;                    \/* Iterator used for several purposes *\/\n@@ -182635,1 +190581,3 @@\n-    while( pRoot->pParent && pRoot->pParent->eType==FTSQUERY_NEAR ){\n+    while( pRoot->pParent\n+        && (pRoot->pParent->eType==FTSQUERY_NEAR || pRoot->bDeferred)\n+    ){\n@@ -182643,8 +190591,2 @@\n-    for(p=pRoot; p; p=p->pLeft){\n-      Fts3Expr *pE = (p->eType==FTSQUERY_PHRASE?p:p->pRight);\n-      assert( pE->aMI==0 );\n-      pE->aMI = (u32 *)sqlite3_malloc64(pTab->nColumn * 3 * sizeof(u32));\n-      if( !pE->aMI ) return SQLITE_NOMEM;\n-      memset(pE->aMI, 0, pTab->nColumn * 3 * sizeof(u32));\n-    }\n-\n+    rc = sqlite3Fts3ExprIterate(pRoot, fts3AllocateMSI, (void*)pTab);\n+    if( rc!=SQLITE_OK ) return rc;\n@@ -182806,0 +190748,1 @@\n+    Fts3Expr *pRun;               \/* Closest non-deferred ancestor of pNear *\/\n@@ -182820,0 +190763,5 @@\n+    pRun = pNear;\n+    while( pRun->bDeferred ){\n+      assert( pRun->pParent );\n+      pRun = pRun->pParent;\n+    }\n@@ -182825,5 +190773,5 @@\n-      int bEofSave = pNear->bEof;\n-      fts3EvalRestart(pCsr, pNear, &rc);\n-      while( rc==SQLITE_OK && !pNear->bEof ){\n-        fts3EvalNextRow(pCsr, pNear, &rc);\n-        if( bEofSave==0 && pNear->iDocid==iDocid ) break;\n+      int bEofSave = pRun->bEof;\n+      fts3EvalRestart(pCsr, pRun, &rc);\n+      while( rc==SQLITE_OK && !pRun->bEof ){\n+        fts3EvalNextRow(pCsr, pRun, &rc);\n+        if( bEofSave==0 && pRun->iDocid==iDocid ) break;\n@@ -182832,1 +190780,1 @@\n-      if( rc==SQLITE_OK && pNear->bEof!=bEofSave ){\n+      if( rc==SQLITE_OK && pRun->bEof!=bEofSave ){\n@@ -182837,2 +190785,2 @@\n-      while( rc==SQLITE_OK && !pNear->bEof ){\n-        fts3EvalNextRow(pCsr, pNear, &rc);\n+      while( rc==SQLITE_OK && !pRun->bEof ){\n+        fts3EvalNextRow(pCsr, pRun, &rc);\n@@ -183505,1 +191453,2 @@\n-     0                            \/* xShadowName   *\/\n+     0,                           \/* xShadowName   *\/\n+     0                            \/* xIntegrity    *\/\n@@ -187071,1 +195020,2 @@\n-     0                            \/* xShadowName   *\/\n+     0,                           \/* xShadowName   *\/\n+     0                            \/* xIntegrity    *\/\n@@ -189754,1 +197704,1 @@\n-  if( nList>pMsr->nBuffer ){\n+  if( (nList+FTS3_NODE_PADDING)>pMsr->nBuffer ){\n@@ -189756,2 +197706,2 @@\n-    pMsr->nBuffer = nList*2;\n-    pNew = (char *)sqlite3_realloc64(pMsr->aBuffer, pMsr->nBuffer);\n+    int nNew = nList*2 + FTS3_NODE_PADDING;\n+    pNew = (char *)sqlite3_realloc64(pMsr->aBuffer, nNew);\n@@ -189760,0 +197710,1 @@\n+    pMsr->nBuffer = nNew;\n@@ -189764,0 +197715,1 @@\n+  memset(&pMsr->aBuffer[nList], 0, FTS3_NODE_PADDING);\n@@ -190410,1 +198362,0 @@\n-  sqlite3Fts3PendingTermsClear(p);\n@@ -190432,0 +198383,4 @@\n+\n+  if( rc==SQLITE_OK ){\n+    sqlite3Fts3PendingTermsClear(p);\n+  }\n@@ -191063,0 +199018,2 @@\n+  assert( pPrev!=0 );\n+  assert( pPrev->a!=0 );\n@@ -191119,3 +199076,7 @@\n-  ** to the current block would make it larger than Fts3Table.nNodeSize\n-  ** bytes, write this block out to the database. *\/\n-  if( pLeaf->block.n>0 && (pLeaf->block.n + nSpace)>p->nNodeSize ){\n+  ** to the current block would make it larger than Fts3Table.nNodeSize bytes,\n+  ** and if there is still room for another leaf page, write this block out to\n+  ** the database. *\/\n+  if( pLeaf->block.n>0\n+   && (pLeaf->block.n + nSpace)>p->nNodeSize\n+   && pLeaf->iBlock < (pWriter->iStart + pWriter->nLeafEst)\n+  ){\n@@ -191432,0 +199393,1 @@\n+        memset(&reader, 0, sizeof(reader));\n@@ -191452,1 +199414,1 @@\n-                  );\n+              );\n@@ -192302,1 +200264,1 @@\n-  assert( *pRc==SQLITE_OK );\n+  if( *pRc ) return 0;\n@@ -192369,1 +200331,1 @@\n-static int fts3IntegrityCheck(Fts3Table *p, int *pbOk){\n+SQLITE_PRIVATE int sqlite3Fts3IntegrityCheck(Fts3Table *p, int *pbOk){\n@@ -192447,1 +200409,1 @@\n-  *pbOk = (cksum1==cksum2);\n+  *pbOk = (rc==SQLITE_OK && cksum1==cksum2);\n@@ -192487,1 +200449,1 @@\n-  rc = fts3IntegrityCheck(p, &bOk);\n+  rc = sqlite3Fts3IntegrityCheck(p, &bOk);\n@@ -192517,0 +200479,3 @@\n+  }else if( nVal==5 && 0==sqlite3_strnicmp(zVal, \"flush\", 5) ){\n+    rc = sqlite3Fts3PendingTermsFlush(p);\n+  }\n@@ -192518,1 +200483,1 @@\n-  }else{\n+  else{\n@@ -192536,1 +200501,0 @@\n-#endif\n@@ -192538,0 +200502,1 @@\n+#endif\n@@ -192945,1 +200910,1 @@\n-** Used as an fts3ExprIterate() context when loading phrase doclists to\n+** Used as an sqlite3Fts3ExprIterate() context when loading phrase doclists to\n@@ -192989,1 +200954,1 @@\n-** This type is used as an fts3ExprIterate() context object while\n+** This type is used as an sqlite3Fts3ExprIterate() context object while\n@@ -193148,1 +201113,1 @@\n-** Helper function for fts3ExprIterate() (see below).\n+** Helper function for sqlite3Fts3ExprIterate() (see below).\n@@ -193182,1 +201147,1 @@\n-static int fts3ExprIterate(\n+SQLITE_PRIVATE int sqlite3Fts3ExprIterate(\n@@ -193191,1 +201156,0 @@\n-\n@@ -193193,2 +201157,2 @@\n-** This is an fts3ExprIterate() callback used while loading the doclists\n-** for each phrase into Fts3Expr.aDoclist[]\/nDoclist. See also\n+** This is an sqlite3Fts3ExprIterate() callback used while loading the\n+** doclists for each phrase into Fts3Expr.aDoclist[]\/nDoclist. See also\n@@ -193226,1 +201190,1 @@\n-  LoadDoclistCtx sCtx = {0,0,0};  \/* Context for fts3ExprIterate() *\/\n+  LoadDoclistCtx sCtx = {0,0,0};  \/* Context for sqlite3Fts3ExprIterate() *\/\n@@ -193228,1 +201192,1 @@\n-  rc = fts3ExprIterate(pCsr->pExpr, fts3ExprLoadDoclistsCb, (void *)&sCtx);\n+  rc = sqlite3Fts3ExprIterate(pCsr->pExpr,fts3ExprLoadDoclistsCb,(void*)&sCtx);\n@@ -193241,1 +201205,1 @@\n-  (void)fts3ExprIterate(pExpr, fts3ExprPhraseCountCb, (void *)&nPhrase);\n+  (void)sqlite3Fts3ExprIterate(pExpr, fts3ExprPhraseCountCb, (void *)&nPhrase);\n@@ -193369,2 +201333,3 @@\n-** This function is an fts3ExprIterate() callback used by fts3BestSnippet().\n-** Each invocation populates an element of the SnippetIter.aPhrase[] array.\n+** This function is an sqlite3Fts3ExprIterate() callback used by\n+** fts3BestSnippet().  Each invocation populates an element of the\n+** SnippetIter.aPhrase[] array.\n@@ -193460,1 +201425,3 @@\n-  rc = fts3ExprIterate(pCsr->pExpr, fts3SnippetFindPositions, (void*)&sIter);\n+  rc = sqlite3Fts3ExprIterate(\n+      pCsr->pExpr, fts3SnippetFindPositions, (void*)&sIter\n+  );\n@@ -193821,2 +201788,2 @@\n-** fts3ExprIterate() callback used to collect the \"global\" matchinfo stats\n-** for a single query.\n+** sqlite3Fts3ExprIterate() callback used to collect the \"global\" matchinfo\n+** stats for a single query.\n@@ -193824,1 +201791,1 @@\n-** fts3ExprIterate() callback to load the 'global' elements of a\n+** sqlite3Fts3ExprIterate() callback to load the 'global' elements of a\n@@ -193859,1 +201826,1 @@\n-** fts3ExprIterate() callback used to collect the \"local\" part of the\n+** sqlite3Fts3ExprIterate() callback used to collect the \"local\" part of the\n@@ -194055,1 +202022,1 @@\n-  (void)fts3ExprIterate(pCsr->pExpr, fts3MatchinfoLcsCb, (void*)aIter);\n+  (void)sqlite3Fts3ExprIterate(pCsr->pExpr, fts3MatchinfoLcsCb, (void*)aIter);\n@@ -194232,1 +202199,1 @@\n-          rc = fts3ExprIterate(pExpr, fts3ExprGlobalHitsCb,(void*)pInfo);\n+          rc = sqlite3Fts3ExprIterate(pExpr, fts3ExprGlobalHitsCb,(void*)pInfo);\n@@ -194236,1 +202203,1 @@\n-        (void)fts3ExprIterate(pExpr, fts3ExprLocalHitsCb,(void*)pInfo);\n+        (void)sqlite3Fts3ExprIterate(pExpr, fts3ExprLocalHitsCb,(void*)pInfo);\n@@ -194459,1 +202426,1 @@\n-** This function is an fts3ExprIterate() callback used by sqlite3Fts3Offsets().\n+** This function is an sqlite3Fts3ExprIterate() callback used by sqlite3Fts3Offsets().\n@@ -194541,1 +202508,3 @@\n-    rc = fts3ExprIterate(pCsr->pExpr, fts3ExprTermOffsetInit, (void*)&sCtx);\n+    rc = sqlite3Fts3ExprIterate(\n+        pCsr->pExpr, fts3ExprTermOffsetInit, (void*)&sCtx\n+    );\n@@ -195454,1 +203423,1 @@\n-** This SQLite JSON functions.\n+** SQLite JSON functions.\n@@ -195459,5 +203428,101 @@\n-** For the time being, all JSON is stored as pure text.  (We might add\n-** a JSONB type in the future which stores a binary encoding of JSON in\n-** a BLOB, but there is no support for JSONB in the current implementation.\n-** This implementation parses JSON text at 250 MB\/s, so it is hard to see\n-** how JSONB might improve on that.)\n+** The original design stored all JSON as pure text, canonical RFC-8259.\n+** Support for JSON-5 extensions was added with version 3.42.0 (2023-05-16).\n+** All generated JSON text still conforms strictly to RFC-8259, but text\n+** with JSON-5 extensions is accepted as input.\n+**\n+** Beginning with version 3.45.0 (circa 2024-01-01), these routines also\n+** accept BLOB values that have JSON encoded using a binary representation\n+** called \"JSONB\".  The name JSONB comes from PostgreSQL, however the on-disk\n+** format SQLite JSONB is completely different and incompatible with\n+** PostgreSQL JSONB.\n+**\n+** Decoding and interpreting JSONB is still O(N) where N is the size of\n+** the input, the same as text JSON.  However, the constant of proportionality\n+** for JSONB is much smaller due to faster parsing.  The size of each\n+** element in JSONB is encoded in its header, so there is no need to search\n+** for delimiters using persnickety syntax rules.  JSONB seems to be about\n+** 3x faster than text JSON as a result.  JSONB is also tends to be slightly\n+** smaller than text JSON, by 5% or 10%, but there are corner cases where\n+** JSONB can be slightly larger.  So you are not far mistaken to say that\n+** a JSONB blob is the same size as the equivalent RFC-8259 text.\n+**\n+**\n+** THE JSONB ENCODING:\n+**\n+** Every JSON element is encoded in JSONB as a header and a payload.\n+** The header is between 1 and 9 bytes in size.  The payload is zero\n+** or more bytes.\n+**\n+** The lower 4 bits of the first byte of the header determines the\n+** element type:\n+**\n+**    0:   NULL\n+**    1:   TRUE\n+**    2:   FALSE\n+**    3:   INT        -- RFC-8259 integer literal\n+**    4:   INT5       -- JSON5 integer literal\n+**    5:   FLOAT      -- RFC-8259 floating point literal\n+**    6:   FLOAT5     -- JSON5 floating point literal\n+**    7:   TEXT       -- Text literal acceptable to both SQL and JSON\n+**    8:   TEXTJ      -- Text containing RFC-8259 escapes\n+**    9:   TEXT5      -- Text containing JSON5 and\/or RFC-8259 escapes\n+**   10:   TEXTRAW    -- Text containing unescaped syntax characters\n+**   11:   ARRAY\n+**   12:   OBJECT\n+**\n+** The other three possible values (13-15) are reserved for future\n+** enhancements.\n+**\n+** The upper 4 bits of the first byte determine the size of the header\n+** and sometimes also the size of the payload.  If X is the first byte\n+** of the element and if X>>4 is between 0 and 11, then the payload\n+** will be that many bytes in size and the header is exactly one byte\n+** in size.  Other four values for X>>4 (12-15) indicate that the header\n+** is more than one byte in size and that the payload size is determined\n+** by the remainder of the header, interpreted as a unsigned big-endian\n+** integer.\n+**\n+**   Value of X>>4         Size integer        Total header size\n+**   -------------     --------------------    -----------------\n+**        12           1 byte (0-255)                2\n+**        13           2 byte (0-65535)              3\n+**        14           4 byte (0-4294967295)         5\n+**        15           8 byte (0-1.8e19)             9\n+**\n+** The payload size need not be expressed in its minimal form.  For example,\n+** if the payload size is 10, the size can be expressed in any of 5 different\n+** ways: (1) (X>>4)==10, (2) (X>>4)==12 following by on 0x0a byte,\n+** (3) (X>>4)==13 followed by 0x00 and 0x0a, (4) (X>>4)==14 followed by\n+** 0x00 0x00 0x00 0x0a, or (5) (X>>4)==15 followed by 7 bytes of 0x00 and\n+** a single byte of 0x0a.  The shorter forms are preferred, of course, but\n+** sometimes when generating JSONB, the payload size is not known in advance\n+** and it is convenient to reserve sufficient header space to cover the\n+** largest possible payload size and then come back later and patch up\n+** the size when it becomes known, resulting in a non-minimal encoding.\n+**\n+** The value (X>>4)==15 is not actually used in the current implementation\n+** (as SQLite is currently unable handle BLOBs larger than about 2GB)\n+** but is included in the design to allow for future enhancements.\n+**\n+** The payload follows the header.  NULL, TRUE, and FALSE have no payload and\n+** their payload size must always be zero.  The payload for INT, INT5,\n+** FLOAT, FLOAT5, TEXT, TEXTJ, TEXT5, and TEXTROW is text.  Note that the\n+** \"...\" or '...' delimiters are omitted from the various text encodings.\n+** The payload for ARRAY and OBJECT is a list of additional elements that\n+** are the content for the array or object.  The payload for an OBJECT\n+** must be an even number of elements.  The first element of each pair is\n+** the label and must be of type TEXT, TEXTJ, TEXT5, or TEXTRAW.\n+**\n+** A valid JSONB blob consists of a single element, as described above.\n+** Usually this will be an ARRAY or OBJECT element which has many more\n+** elements as its content.  But the overall blob is just a single element.\n+**\n+** Input validation for JSONB blobs simply checks that the element type\n+** code is between 0 and 12 and that the total size of the element\n+** (header plus payload) is the same as the size of the BLOB.  If those\n+** checks are true, the BLOB is assumed to be JSONB and processing continues.\n+** Errors are only raised if some other miscoding is discovered during\n+** processing.\n+**\n+** Additional information can be found in the doc\/jsonb.md file of the\n+** canonical SQLite source tree.\n@@ -195468,0 +203533,25 @@\n+\/* JSONB element types\n+*\/\n+#define JSONB_NULL     0   \/* \"null\" *\/\n+#define JSONB_TRUE     1   \/* \"true\" *\/\n+#define JSONB_FALSE    2   \/* \"false\" *\/\n+#define JSONB_INT      3   \/* integer acceptable to JSON and SQL *\/\n+#define JSONB_INT5     4   \/* integer in 0x000 notation *\/\n+#define JSONB_FLOAT    5   \/* float acceptable to JSON and SQL *\/\n+#define JSONB_FLOAT5   6   \/* float with JSON5 extensions *\/\n+#define JSONB_TEXT     7   \/* Text compatible with both JSON and SQL *\/\n+#define JSONB_TEXTJ    8   \/* Text with JSON escapes *\/\n+#define JSONB_TEXT5    9   \/* Text with JSON-5 escape *\/\n+#define JSONB_TEXTRAW 10   \/* SQL text that needs escaping for JSON *\/\n+#define JSONB_ARRAY   11   \/* An array *\/\n+#define JSONB_OBJECT  12   \/* An object *\/\n+\n+\/* Human-readable names for the JSONB values.  The index for each\n+** string must correspond to the JSONB_* integer above.\n+*\/\n+static const char * const jsonbType[] = {\n+  \"null\", \"true\", \"false\", \"integer\", \"integer\",\n+  \"real\", \"real\", \"text\",  \"text\",    \"text\",\n+  \"text\", \"array\", \"object\", \"\", \"\", \"\", \"\"\n+};\n+\n@@ -195471,1 +203561,1 @@\n-** increase for the parser.  (Ubuntu14.10 gcc 4.8.4 x64 with -Os).\n+** increase for the text-JSON parser.  (Ubuntu14.10 gcc 4.8.4 x64 with -Os).\n@@ -195474,16 +203564,50 @@\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 1, 1, 0, 0, 1, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n-  1, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n-  0, 0, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 1, 1, 0, 0, 1, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  1, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+};\n+#define jsonIsspace(x) (jsonIsSpace[(unsigned char)x])\n+\n+\/*\n+** The set of all space characters recognized by jsonIsspace().\n+** Useful as the second argument to strspn().\n+*\/\n+static const char jsonSpaces[] = \"\\011\\012\\015\\040\";\n+\n+\/*\n+** Characters that are special to JSON.  Control characters,\n+** '\"' and '\\\\' and '\\''.  Actually, '\\'' is not special to\n+** canonical JSON, but it is special in JSON-5, so we include\n+** it in the set of special characters.\n+*\/\n+static const char jsonIsOk[256] = {\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n+  1, 1, 0, 1, 1, 1, 1, 0,  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 0, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n+\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1,\n+  1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1\n@@ -195491,7 +203615,0 @@\n-#define fast_isspace(x) (jsonIsSpace[(unsigned char)x])\n-\n-#if !defined(SQLITE_DEBUG) && !defined(SQLITE_COVERAGE_TEST)\n-#  define VVA(X)\n-#else\n-#  define VVA(X) X\n-#endif\n@@ -195500,0 +203617,1 @@\n+typedef struct JsonCache JsonCache;\n@@ -195501,1 +203619,0 @@\n-typedef struct JsonNode JsonNode;\n@@ -195504,0 +203621,31 @@\n+\/*\n+** Magic number used for the JSON parse cache in sqlite3_get_auxdata()\n+*\/\n+#define JSON_CACHE_ID    (-429938)  \/* Cache entry *\/\n+#define JSON_CACHE_SIZE  4          \/* Max number of cache entries *\/\n+\n+\/*\n+** jsonUnescapeOneChar() returns this invalid code point if it encounters\n+** a syntax error.\n+*\/\n+#define JSON_INVALID_CHAR 0x99999\n+\n+\/* A cache mapping JSON text into JSONB blobs.\n+**\n+** Each cache entry is a JsonParse object with the following restrictions:\n+**\n+**    *   The bReadOnly flag must be set\n+**\n+**    *   The aBlob[] array must be owned by the JsonParse object.  In other\n+**        words, nBlobAlloc must be non-zero.\n+**\n+**    *   eEdit and delta must be zero.\n+**\n+**    *   zJson must be an RCStr.  In other words bJsonIsRCStr must be true.\n+*\/\n+struct JsonCache {\n+  sqlite3 *db;                    \/* Database connection *\/\n+  int nUsed;                      \/* Number of active entries in the cache *\/\n+  JsonParse *a[JSON_CACHE_SIZE];  \/* One line for each cache entry *\/\n+};\n+\n@@ -195507,0 +203655,4 @@\n+**\n+** If the generated string is longer than will fit into the zSpace[] buffer,\n+** then it will be an RCStr string.  This aids with caching of large\n+** JSON strings.\n@@ -195514,1 +203666,1 @@\n-  u8 bErr;                 \/* True if an error has been encountered *\/\n+  u8 eErr;                 \/* True if an error has been encountered *\/\n@@ -195518,10 +203670,4 @@\n-\/* JSON type values\n-*\/\n-#define JSON_NULL     0\n-#define JSON_TRUE     1\n-#define JSON_FALSE    2\n-#define JSON_INT      3\n-#define JSON_REAL     4\n-#define JSON_STRING   5\n-#define JSON_ARRAY    6\n-#define JSON_OBJECT   7\n+\/* Allowed values for JsonString.eErr *\/\n+#define JSTRING_OOM         0x01   \/* Out of memory *\/\n+#define JSTRING_MALFORMED   0x02   \/* Malformed JSONB *\/\n+#define JSTRING_ERR         0x04   \/* Error already sent to sqlite3_result *\/\n@@ -195529,1 +203675,3 @@\n-\/* The \"subtype\" set for JSON values *\/\n+\/* The \"subtype\" set for text JSON values passed through using\n+** sqlite3_result_subtype() and sqlite3_value_subtype().\n+*\/\n@@ -195533,1 +203681,2 @@\n-** Names of the various JSON types:\n+** Bit values for the flags passed into various SQL function implementations\n+** via the sqlite3_user_data() value.\n@@ -195535,14 +203684,5 @@\n-static const char * const jsonType[] = {\n-  \"null\", \"true\", \"false\", \"integer\", \"real\", \"text\", \"array\", \"object\"\n-};\n-\n-\/* Bit values for the JsonNode.jnFlag field\n-*\/\n-#define JNODE_RAW     0x01         \/* Content is raw, not JSON encoded *\/\n-#define JNODE_ESCAPE  0x02         \/* Content is text with \\ escapes *\/\n-#define JNODE_REMOVE  0x04         \/* Do not output *\/\n-#define JNODE_REPLACE 0x08         \/* Replace with JsonNode.u.iReplace *\/\n-#define JNODE_PATCH   0x10         \/* Patch with JsonNode.u.pPatch *\/\n-#define JNODE_APPEND  0x20         \/* More ARRAY\/OBJECT entries at u.iAppend *\/\n-#define JNODE_LABEL   0x40         \/* Is a label of an object *\/\n-\n+#define JSON_JSON      0x01        \/* Result is always JSON *\/\n+#define JSON_SQL       0x02        \/* Result is always SQL *\/\n+#define JSON_ABPATH    0x03        \/* Allow abbreviated JSON path specs *\/\n+#define JSON_ISSET     0x04        \/* json_set(), not json_insert() *\/\n+#define JSON_BLOB      0x08        \/* Use the BLOB output format *\/\n@@ -195550,15 +203690,0 @@\n-\/* A single node of parsed JSON\n-*\/\n-struct JsonNode {\n-  u8 eType;              \/* One of the JSON_ type values *\/\n-  u8 jnFlags;            \/* JNODE flags *\/\n-  u8 eU;                 \/* Which union element to use *\/\n-  u32 n;                 \/* Bytes of content, or number of sub-nodes *\/\n-  union {\n-    const char *zJContent; \/* 1: Content for INT, REAL, and STRING *\/\n-    u32 iAppend;           \/* 2: More terms for ARRAY and OBJECT *\/\n-    u32 iKey;              \/* 3: Key for ARRAY objects in json_tree() *\/\n-    u32 iReplace;          \/* 4: Replacement content for JNODE_REPLACE *\/\n-    JsonNode *pPatch;      \/* 5: Node chain of patch for JNODE_PATCH *\/\n-  } u;\n-};\n@@ -195566,1 +203691,14 @@\n-\/* A completely parsed JSON string\n+\/* A parsed JSON value.  Lifecycle:\n+**\n+**   1.  JSON comes in and is parsed into a JSONB value in aBlob.  The\n+**       original text is stored in zJson.  This step is skipped if the\n+**       input is JSONB instead of text JSON.\n+**\n+**   2.  The aBlob[] array is searched using the JSON path notation, if needed.\n+**\n+**   3.  Zero or more changes are made to aBlob[] (via json_remove() or\n+**       json_replace() or json_patch() or similar).\n+**\n+**   4.  New JSON text is generated from the aBlob[] for output.  This step\n+**       is skipped if the function is one of the jsonb_* functions that\n+**       returns JSONB instead of text JSON.\n@@ -195569,8 +203707,5 @@\n-  u32 nNode;         \/* Number of slots of aNode[] used *\/\n-  u32 nAlloc;        \/* Number of slots of aNode[] allocated *\/\n-  JsonNode *aNode;   \/* Array of nodes containing the parse *\/\n-  const char *zJson; \/* Original JSON string *\/\n-  u32 *aUp;          \/* Index of parent of each node *\/\n-  u8 oom;            \/* Set to true if out of memory *\/\n-  u8 nErr;           \/* Number of errors seen *\/\n-  u16 iDepth;        \/* Nesting depth *\/\n+  u8 *aBlob;         \/* JSONB representation of JSON value *\/\n+  u32 nBlob;         \/* Bytes of aBlob[] actually used *\/\n+  u32 nBlobAlloc;    \/* Bytes allocated to aBlob[].  0 if aBlob is external *\/\n+  char *zJson;       \/* Json text used for parsing *\/\n+  sqlite3 *db;       \/* The database connection to which this object belongs *\/\n@@ -195578,1 +203713,14 @@\n-  u32 iHold;         \/* Replace cache line with the lowest iHold value *\/\n+  u32 nJPRef;        \/* Number of references to this object *\/\n+  u32 iErr;          \/* Error location in zJson[] *\/\n+  u16 iDepth;        \/* Nesting depth *\/\n+  u8 nErr;           \/* Number of errors seen *\/\n+  u8 oom;            \/* Set to true if out of memory *\/\n+  u8 bJsonIsRCStr;   \/* True if zJson is an RCStr *\/\n+  u8 hasNonstd;      \/* True if input uses non-standard features like JSON5 *\/\n+  u8 bReadOnly;      \/* Do not modify. *\/\n+  \/* Search and edit information.  See jsonLookupStep() *\/\n+  u8 eEdit;          \/* Edit operation to apply *\/\n+  int delta;         \/* Size change due to the edit *\/\n+  u32 nIns;          \/* Number of bytes to insert *\/\n+  u32 iLabel;        \/* Location of label if search landed on an object value *\/\n+  u8 *aIns;          \/* Content to be inserted *\/\n@@ -195581,0 +203729,6 @@\n+\/* Allowed values for JsonParse.eEdit *\/\n+#define JEDIT_DEL   1   \/* Delete if exists *\/\n+#define JEDIT_REPL  2   \/* Overwrite if exists *\/\n+#define JEDIT_INS   3   \/* Insert if not exists *\/\n+#define JEDIT_SET   4   \/* Insert or overwrite *\/\n+\n@@ -195585,2 +203739,95 @@\n-** descent parser.  A depth of 2000 is far deeper than any sane JSON\n-** should go.\n+** descent parser.  A depth of 1000 is far deeper than any sane JSON\n+** should go.  Historical note: This limit was 2000 prior to version 3.42.0\n+*\/\n+#ifndef SQLITE_JSON_MAX_DEPTH\n+# define JSON_MAX_DEPTH  1000\n+#else\n+# define JSON_MAX_DEPTH SQLITE_JSON_MAX_DEPTH\n+#endif\n+\n+\/*\n+** Allowed values for the flgs argument to jsonParseFuncArg();\n+*\/\n+#define JSON_EDITABLE  0x01   \/* Generate a writable JsonParse object *\/\n+#define JSON_KEEPERROR 0x02   \/* Return non-NULL even if there is an error *\/\n+\n+\/**************************************************************************\n+** Forward references\n+**************************************************************************\/\n+static void jsonReturnStringAsBlob(JsonString*);\n+static int jsonFuncArgMightBeBinary(sqlite3_value *pJson);\n+static u32 jsonTranslateBlobToText(const JsonParse*,u32,JsonString*);\n+static void jsonReturnParse(sqlite3_context*,JsonParse*);\n+static JsonParse *jsonParseFuncArg(sqlite3_context*,sqlite3_value*,u32);\n+static void jsonParseFree(JsonParse*);\n+static u32 jsonbPayloadSize(const JsonParse*, u32, u32*);\n+static u32 jsonUnescapeOneChar(const char*, u32, u32*);\n+\n+\/**************************************************************************\n+** Utility routines for dealing with JsonCache objects\n+**************************************************************************\/\n+\n+\/*\n+** Free a JsonCache object.\n+*\/\n+static void jsonCacheDelete(JsonCache *p){\n+  int i;\n+  for(i=0; i<p->nUsed; i++){\n+    jsonParseFree(p->a[i]);\n+  }\n+  sqlite3DbFree(p->db, p);\n+}\n+static void jsonCacheDeleteGeneric(void *p){\n+  jsonCacheDelete((JsonCache*)p);\n+}\n+\n+\/*\n+** Insert a new entry into the cache.  If the cache is full, expel\n+** the least recently used entry.  Return SQLITE_OK on success or a\n+** result code otherwise.\n+**\n+** Cache entries are stored in age order, oldest first.\n+*\/\n+static int jsonCacheInsert(\n+  sqlite3_context *ctx,   \/* The SQL statement context holding the cache *\/\n+  JsonParse *pParse       \/* The parse object to be added to the cache *\/\n+){\n+  JsonCache *p;\n+\n+  assert( pParse->zJson!=0 );\n+  assert( pParse->bJsonIsRCStr );\n+  assert( pParse->delta==0 );\n+  p = sqlite3_get_auxdata(ctx, JSON_CACHE_ID);\n+  if( p==0 ){\n+    sqlite3 *db = sqlite3_context_db_handle(ctx);\n+    p = sqlite3DbMallocZero(db, sizeof(*p));\n+    if( p==0 ) return SQLITE_NOMEM;\n+    p->db = db;\n+    sqlite3_set_auxdata(ctx, JSON_CACHE_ID, p, jsonCacheDeleteGeneric);\n+    p = sqlite3_get_auxdata(ctx, JSON_CACHE_ID);\n+    if( p==0 ) return SQLITE_NOMEM;\n+  }\n+  if( p->nUsed >= JSON_CACHE_SIZE ){\n+    jsonParseFree(p->a[0]);\n+    memmove(p->a, &p->a[1], (JSON_CACHE_SIZE-1)*sizeof(p->a[0]));\n+    p->nUsed = JSON_CACHE_SIZE-1;\n+  }\n+  assert( pParse->nBlobAlloc>0 );\n+  pParse->eEdit = 0;\n+  pParse->nJPRef++;\n+  pParse->bReadOnly = 1;\n+  p->a[p->nUsed] = pParse;\n+  p->nUsed++;\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Search for a cached translation the json text supplied by pArg.  Return\n+** the JsonParse object if found.  Return NULL if not found.\n+**\n+** When a match if found, the matching entry is moved to become the\n+** most-recently used entry if it isn't so already.\n+**\n+** The JsonParse object returned still belongs to the Cache and might\n+** be deleted at any moment.  If the caller whants the JsonParse to\n+** linger, it needs to increment the nPJRef reference counter.\n@@ -195588,1 +203835,43 @@\n-#define JSON_MAX_DEPTH  2000\n+static JsonParse *jsonCacheSearch(\n+  sqlite3_context *ctx,    \/* The SQL statement context holding the cache *\/\n+  sqlite3_value *pArg      \/* Function argument containing SQL text *\/\n+){\n+  JsonCache *p;\n+  int i;\n+  const char *zJson;\n+  int nJson;\n+\n+  if( sqlite3_value_type(pArg)!=SQLITE_TEXT ){\n+    return 0;\n+  }\n+  zJson = (const char*)sqlite3_value_text(pArg);\n+  if( zJson==0 ) return 0;\n+  nJson = sqlite3_value_bytes(pArg);\n+\n+  p = sqlite3_get_auxdata(ctx, JSON_CACHE_ID);\n+  if( p==0 ){\n+    return 0;\n+  }\n+  for(i=0; i<p->nUsed; i++){\n+    if( p->a[i]->zJson==zJson ) break;\n+  }\n+  if( i>=p->nUsed ){\n+    for(i=0; i<p->nUsed; i++){\n+      if( p->a[i]->nJson!=nJson ) continue;\n+      if( memcmp(p->a[i]->zJson, zJson, nJson)==0 ) break;\n+    }\n+  }\n+  if( i<p->nUsed ){\n+    if( i<p->nUsed-1 ){\n+      \/* Make the matching entry the most recently used entry *\/\n+      JsonParse *tmp = p->a[i];\n+      memmove(&p->a[i], &p->a[i+1], (p->nUsed-i-1)*sizeof(tmp));\n+      p->a[p->nUsed-1] = tmp;\n+      i = p->nUsed - 1;\n+    }\n+    assert( p->a[i]->delta==0 );\n+    return p->a[i];\n+  }else{\n+    return 0;\n+  }\n+}\n@@ -195594,1 +203883,2 @@\n-\/* Set the JsonString object to an empty string\n+\/* Turn uninitialized bulk memory into a valid JsonString object\n+** holding a zero-length string.\n@@ -195596,1 +203886,1 @@\n-static void jsonZero(JsonString *p){\n+static void jsonStringZero(JsonString *p){\n@@ -195605,1 +203895,1 @@\n-static void jsonInit(JsonString *p, sqlite3_context *pCtx){\n+static void jsonStringInit(JsonString *p, sqlite3_context *pCtx){\n@@ -195607,2 +203897,2 @@\n-  p->bErr = 0;\n-  jsonZero(p);\n+  p->eErr = 0;\n+  jsonStringZero(p);\n@@ -195611,1 +203901,0 @@\n-\n@@ -195615,3 +203904,3 @@\n-static void jsonReset(JsonString *p){\n-  if( !p->bStatic ) sqlite3_free(p->zBuf);\n-  jsonZero(p);\n+static void jsonStringReset(JsonString *p){\n+  if( !p->bStatic ) sqlite3RCStrUnref(p->zBuf);\n+  jsonStringZero(p);\n@@ -195620,1 +203909,0 @@\n-\n@@ -195623,4 +203911,4 @@\n-static void jsonOom(JsonString *p){\n-  p->bErr = 1;\n-  sqlite3_result_error_nomem(p->pCtx);\n-  jsonReset(p);\n+static void jsonStringOom(JsonString *p){\n+  p->eErr |= JSTRING_OOM;\n+  if( p->pCtx ) sqlite3_result_error_nomem(p->pCtx);\n+  jsonStringReset(p);\n@@ -195632,1 +203920,1 @@\n-static int jsonGrow(JsonString *p, u32 N){\n+static int jsonStringGrow(JsonString *p, u32 N){\n@@ -195636,2 +203924,2 @@\n-    if( p->bErr ) return 1;\n-    zNew = sqlite3_malloc64(nTotal);\n+    if( p->eErr ) return 1;\n+    zNew = sqlite3RCStrNew(nTotal);\n@@ -195639,1 +203927,1 @@\n-      jsonOom(p);\n+      jsonStringOom(p);\n@@ -195646,3 +203934,4 @@\n-    zNew = sqlite3_realloc64(p->zBuf, nTotal);\n-    if( zNew==0 ){\n-      jsonOom(p);\n+    p->zBuf = sqlite3RCStrResize(p->zBuf, nTotal);\n+    if( p->zBuf==0 ){\n+      p->eErr |= JSTRING_OOM;\n+      jsonStringZero(p);\n@@ -195651,1 +203940,0 @@\n-    p->zBuf = zNew;\n@@ -195659,3 +203947,7 @@\n-static void jsonAppendRaw(JsonString *p, const char *zIn, u32 N){\n-  if( N==0 ) return;\n-  if( (N+p->nUsed >= p->nAlloc) && jsonGrow(p,N)!=0 ) return;\n+static SQLITE_NOINLINE void jsonStringExpandAndAppend(\n+  JsonString *p,\n+  const char *zIn,\n+  u32 N\n+){\n+  assert( N>0 );\n+  if( jsonStringGrow(p,N) ) return;\n@@ -195665,0 +203957,19 @@\n+static void jsonAppendRaw(JsonString *p, const char *zIn, u32 N){\n+  if( N==0 ) return;\n+  if( N+p->nUsed >= p->nAlloc ){\n+    jsonStringExpandAndAppend(p,zIn,N);\n+  }else{\n+    memcpy(p->zBuf+p->nUsed, zIn, N);\n+    p->nUsed += N;\n+  }\n+}\n+static void jsonAppendRawNZ(JsonString *p, const char *zIn, u32 N){\n+  assert( N>0 );\n+  if( N+p->nUsed >= p->nAlloc ){\n+    jsonStringExpandAndAppend(p,zIn,N);\n+  }else{\n+    memcpy(p->zBuf+p->nUsed, zIn, N);\n+    p->nUsed += N;\n+  }\n+}\n+\n@@ -195670,1 +203981,1 @@\n-  if( (p->nUsed + N >= p->nAlloc) && jsonGrow(p, N) ) return;\n+  if( (p->nUsed + N >= p->nAlloc) && jsonStringGrow(p, N) ) return;\n@@ -195679,2 +203990,2 @@\n-static void jsonAppendChar(JsonString *p, char c){\n-  if( p->nUsed>=p->nAlloc && jsonGrow(p,1)!=0 ) return;\n+static SQLITE_NOINLINE void jsonAppendCharExpand(JsonString *p, char c){\n+  if( jsonStringGrow(p,1) ) return;\n@@ -195683,0 +203994,28 @@\n+static void jsonAppendChar(JsonString *p, char c){\n+  if( p->nUsed>=p->nAlloc ){\n+    jsonAppendCharExpand(p,c);\n+  }else{\n+    p->zBuf[p->nUsed++] = c;\n+  }\n+}\n+\n+\/* Remove a single character from the end of the string\n+*\/\n+static void jsonStringTrimOneChar(JsonString *p){\n+  if( p->eErr==0 ){\n+    assert( p->nUsed>0 );\n+    p->nUsed--;\n+  }\n+}\n+\n+\n+\/* Make sure there is a zero terminator on p->zBuf[]\n+**\n+** Return true on success.  Return false if an OOM prevents this\n+** from happening.\n+*\/\n+static int jsonStringTerminate(JsonString *p){\n+  jsonAppendChar(p, 0);\n+  jsonStringTrimOneChar(p);\n+  return p->eErr==0;\n+}\n@@ -195691,1 +204030,2 @@\n-  if( c!='[' && c!='{' ) jsonAppendChar(p, ',');\n+  if( c=='[' || c=='{' ) return;\n+  jsonAppendChar(p, ',');\n@@ -195695,2 +204035,2 @@\n-** under construction.  Enclose the string in \"...\" and escape\n-** any double-quotes or backslash characters contained within the\n+** under construction.  Enclose the string in double-quotes (\"...\") and\n+** escape any double-quotes or backslash characters contained within the\n@@ -195698,0 +204038,3 @@\n+**\n+** This routine is a high-runner.  There is a measurable performance\n+** increase associated with unwinding the jsonIsOk[] loop.\n@@ -195700,2 +204043,5 @@\n-  u32 i;\n-  if( zIn==0 || ((N+p->nUsed+2 >= p->nAlloc) && jsonGrow(p,N+2)!=0) ) return;\n+  u32 k;\n+  u8 c;\n+  const u8 *z = (const u8*)zIn;\n+  if( z==0 ) return;\n+  if( (N+p->nUsed+2 >= p->nAlloc) && jsonStringGrow(p,N+2)!=0 ) return;\n@@ -195703,2 +204049,43 @@\n-  for(i=0; i<N; i++){\n-    unsigned char c = ((unsigned const char*)zIn)[i];\n+  while( 1 \/*exit-by-break*\/ ){\n+    k = 0;\n+    \/* The following while() is the 4-way unwound equivalent of\n+    **\n+    **     while( k<N && jsonIsOk[z[k]] ){ k++; }\n+    *\/\n+    while( 1 \/* Exit by break *\/ ){\n+      if( k+3>=N ){\n+        while( k<N && jsonIsOk[z[k]] ){ k++; }\n+        break;\n+      }\n+      if( !jsonIsOk[z[k]] ){\n+        break;\n+      }\n+      if( !jsonIsOk[z[k+1]] ){\n+        k += 1;\n+        break;\n+      }\n+      if( !jsonIsOk[z[k+2]] ){\n+        k += 2;\n+        break;\n+      }\n+      if( !jsonIsOk[z[k+3]] ){\n+        k += 3;\n+        break;\n+      }else{\n+        k += 4;\n+      }\n+    }\n+    if( k>=N ){\n+      if( k>0 ){\n+        memcpy(&p->zBuf[p->nUsed], z, k);\n+        p->nUsed += k;\n+      }\n+      break;\n+    }\n+    if( k>0 ){\n+      memcpy(&p->zBuf[p->nUsed], z, k);\n+      p->nUsed += k;\n+      z += k;\n+      N -= k;\n+    }\n+    c = z[0];\n@@ -195707,1 +204094,1 @@\n-      if( (p->nUsed+N+3-i > p->nAlloc) && jsonGrow(p,N+3-i)!=0 ) return;\n+      if( (p->nUsed+N+3 > p->nAlloc) && jsonStringGrow(p,N+3)!=0 ) return;\n@@ -195709,1 +204096,4 @@\n-    }else if( c<=0x1f ){\n+      p->zBuf[p->nUsed++] = c;\n+    }else if( c=='\\'' ){\n+      p->zBuf[p->nUsed++] = c;\n+    }else{\n@@ -195720,0 +204110,1 @@\n+      assert( c>=0 && c<sizeof(aSpecial) );\n@@ -195724,1 +204115,1 @@\n-      if( (p->nUsed+N+7+i > p->nAlloc) && jsonGrow(p,N+7-i)!=0 ) return;\n+      if( (p->nUsed+N+7 > p->nAlloc) && jsonStringGrow(p,N+7)!=0 ) return;\n@@ -195729,2 +204120,2 @@\n-      p->zBuf[p->nUsed++] = '0' + (c>>4);\n-      c = \"0123456789abcdef\"[c&0xf];\n+      p->zBuf[p->nUsed++] = \"0123456789abcdef\"[c>>4];\n+      p->zBuf[p->nUsed++] = \"0123456789abcdef\"[c&0xf];\n@@ -195732,1 +204123,2 @@\n-    p->zBuf[p->nUsed++] = c;\n+    z++;\n+    N--;\n@@ -195739,2 +204131,2 @@\n-** Append a function parameter value to the JSON string under\n-** construction.\n+** Append an sqlite3_value (such as a function parameter) to the JSON\n+** string under construction in p.\n@@ -195742,1 +204134,1 @@\n-static void jsonAppendValue(\n+static void jsonAppendSqlValue(\n@@ -195748,1 +204140,1 @@\n-      jsonAppendRaw(p, \"null\", 4);\n+      jsonAppendRawNZ(p, \"null\", 4);\n@@ -195751,1 +204143,0 @@\n-    case SQLITE_INTEGER:\n@@ -195753,0 +204144,4 @@\n+      jsonPrintf(100, p, \"%!0.15g\", sqlite3_value_double(pValue));\n+      break;\n+    }\n+    case SQLITE_INTEGER: {\n@@ -195769,1 +204164,7 @@\n-      if( p->bErr==0 ){\n+      if( jsonFuncArgMightBeBinary(pValue) ){\n+        JsonParse px;\n+        memset(&px, 0, sizeof(px));\n+        px.aBlob = (u8*)sqlite3_value_blob(pValue);\n+        px.nBlob = sqlite3_value_bytes(pValue);\n+        jsonTranslateBlobToText(&px, 0, p);\n+      }else if( p->eErr==0 ){\n@@ -195771,2 +204172,2 @@\n-        p->bErr = 2;\n-        jsonReset(p);\n+        p->eErr = JSTRING_ERR;\n+        jsonStringReset(p);\n@@ -195779,2 +204180,8 @@\n-\n-\/* Make the JSON in p the result of the SQL function.\n+\/* Make the text in p (which is probably a generated JSON text string)\n+** the result of the SQL function.\n+**\n+** The JsonString is reset.\n+**\n+** If pParse and ctx are both non-NULL, then the SQL string in p is\n+** loaded into the zJson field of the pParse object as a RCStr and the\n+** pParse is added to the cache.\n@@ -195782,6 +204189,37 @@\n-static void jsonResult(JsonString *p){\n-  if( p->bErr==0 ){\n-    sqlite3_result_text64(p->pCtx, p->zBuf, p->nUsed,\n-                          p->bStatic ? SQLITE_TRANSIENT : sqlite3_free,\n-                          SQLITE_UTF8);\n-    jsonZero(p);\n+static void jsonReturnString(\n+  JsonString *p,            \/* String to return *\/\n+  JsonParse *pParse,        \/* JSONB source or NULL *\/\n+  sqlite3_context *ctx      \/* Where to cache *\/\n+){\n+  assert( (pParse!=0)==(ctx!=0) );\n+  assert( ctx==0 || ctx==p->pCtx );\n+  if( p->eErr==0 ){\n+    int flags = SQLITE_PTR_TO_INT(sqlite3_user_data(p->pCtx));\n+    if( flags & JSON_BLOB ){\n+      jsonReturnStringAsBlob(p);\n+    }else if( p->bStatic ){\n+      sqlite3_result_text64(p->pCtx, p->zBuf, p->nUsed,\n+                            SQLITE_TRANSIENT, SQLITE_UTF8);\n+    }else if( jsonStringTerminate(p) ){\n+      if( pParse && pParse->bJsonIsRCStr==0 && pParse->nBlobAlloc>0 ){\n+        int rc;\n+        pParse->zJson = sqlite3RCStrRef(p->zBuf);\n+        pParse->nJson = p->nUsed;\n+        pParse->bJsonIsRCStr = 1;\n+        rc = jsonCacheInsert(ctx, pParse);\n+        if( rc==SQLITE_NOMEM ){\n+          sqlite3_result_error_nomem(ctx);\n+          jsonStringReset(p);\n+          return;\n+        }\n+      }\n+      sqlite3_result_text64(p->pCtx, sqlite3RCStrRef(p->zBuf), p->nUsed,\n+                            sqlite3RCStrUnref,\n+                            SQLITE_UTF8);\n+    }else{\n+      sqlite3_result_error_nomem(p->pCtx);\n+    }\n+  }else if( p->eErr & JSTRING_OOM ){\n+    sqlite3_result_error_nomem(p->pCtx);\n+  }else if( p->eErr & JSTRING_MALFORMED ){\n+    sqlite3_result_error(p->pCtx, \"malformed JSON\", -1);\n@@ -195789,1 +204227,1 @@\n-  assert( p->bStatic );\n+  jsonStringReset(p);\n@@ -195793,1 +204231,1 @@\n-** Utility routines for dealing with JsonNode and JsonParse objects\n+** Utility routines for dealing with JsonParse objects\n@@ -195796,13 +204234,0 @@\n-\/*\n-** Return the number of consecutive JsonNode slots need to represent\n-** the parsed JSON at pNode.  The minimum answer is 1.  For ARRAY and\n-** OBJECT types, the number might be larger.\n-**\n-** Appended elements are not counted.  The value returned is the number\n-** by which the JsonNode counter should increment in order to go to the\n-** next peer value.\n-*\/\n-static u32 jsonNodeSize(JsonNode *pNode){\n-  return pNode->eType>=JSON_ARRAY ? pNode->n+1 : 1;\n-}\n-\n@@ -195814,6 +204239,13 @@\n-  sqlite3_free(pParse->aNode);\n-  pParse->aNode = 0;\n-  pParse->nNode = 0;\n-  pParse->nAlloc = 0;\n-  sqlite3_free(pParse->aUp);\n-  pParse->aUp = 0;\n+  assert( pParse->nJPRef<=1 );\n+  if( pParse->bJsonIsRCStr ){\n+    sqlite3RCStrUnref(pParse->zJson);\n+    pParse->zJson = 0;\n+    pParse->nJson = 0;\n+    pParse->bJsonIsRCStr = 0;\n+  }\n+  if( pParse->nBlobAlloc ){\n+    sqlite3DbFree(pParse->db, pParse->aBlob);\n+    pParse->aBlob = 0;\n+    pParse->nBlob = 0;\n+    pParse->nBlobAlloc = 0;\n+  }\n@@ -195823,1 +204255,2 @@\n-** Free a JsonParse object that was obtained from sqlite3_malloc().\n+** Decrement the reference count on the JsonParse object.  When the\n+** count reaches zero, free the object.\n@@ -195826,91 +204259,6 @@\n-  jsonParseReset(pParse);\n-  sqlite3_free(pParse);\n-}\n-\n-\/*\n-** Convert the JsonNode pNode into a pure JSON string and\n-** append to pOut.  Subsubstructure is also included.  Return\n-** the number of JsonNode objects that are encoded.\n-*\/\n-static void jsonRenderNode(\n-  JsonNode *pNode,               \/* The node to render *\/\n-  JsonString *pOut,              \/* Write JSON here *\/\n-  sqlite3_value **aReplace       \/* Replacement values *\/\n-){\n-  assert( pNode!=0 );\n-  if( pNode->jnFlags & (JNODE_REPLACE|JNODE_PATCH) ){\n-    if( (pNode->jnFlags & JNODE_REPLACE)!=0 && ALWAYS(aReplace!=0) ){\n-      assert( pNode->eU==4 );\n-      jsonAppendValue(pOut, aReplace[pNode->u.iReplace]);\n-      return;\n-    }\n-    assert( pNode->eU==5 );\n-    pNode = pNode->u.pPatch;\n-  }\n-  switch( pNode->eType ){\n-    default: {\n-      assert( pNode->eType==JSON_NULL );\n-      jsonAppendRaw(pOut, \"null\", 4);\n-      break;\n-    }\n-    case JSON_TRUE: {\n-      jsonAppendRaw(pOut, \"true\", 4);\n-      break;\n-    }\n-    case JSON_FALSE: {\n-      jsonAppendRaw(pOut, \"false\", 5);\n-      break;\n-    }\n-    case JSON_STRING: {\n-      if( pNode->jnFlags & JNODE_RAW ){\n-        assert( pNode->eU==1 );\n-        jsonAppendString(pOut, pNode->u.zJContent, pNode->n);\n-        break;\n-      }\n-      \/* no break *\/ deliberate_fall_through\n-    }\n-    case JSON_REAL:\n-    case JSON_INT: {\n-      assert( pNode->eU==1 );\n-      jsonAppendRaw(pOut, pNode->u.zJContent, pNode->n);\n-      break;\n-    }\n-    case JSON_ARRAY: {\n-      u32 j = 1;\n-      jsonAppendChar(pOut, '[');\n-      for(;;){\n-        while( j<=pNode->n ){\n-          if( (pNode[j].jnFlags & JNODE_REMOVE)==0 ){\n-            jsonAppendSeparator(pOut);\n-            jsonRenderNode(&pNode[j], pOut, aReplace);\n-          }\n-          j += jsonNodeSize(&pNode[j]);\n-        }\n-        if( (pNode->jnFlags & JNODE_APPEND)==0 ) break;\n-        assert( pNode->eU==2 );\n-        pNode = &pNode[pNode->u.iAppend];\n-        j = 1;\n-      }\n-      jsonAppendChar(pOut, ']');\n-      break;\n-    }\n-    case JSON_OBJECT: {\n-      u32 j = 1;\n-      jsonAppendChar(pOut, '{');\n-      for(;;){\n-        while( j<=pNode->n ){\n-          if( (pNode[j+1].jnFlags & JNODE_REMOVE)==0 ){\n-            jsonAppendSeparator(pOut);\n-            jsonRenderNode(&pNode[j], pOut, aReplace);\n-            jsonAppendChar(pOut, ':');\n-            jsonRenderNode(&pNode[j+1], pOut, aReplace);\n-          }\n-          j += 1 + jsonNodeSize(&pNode[j+1]);\n-        }\n-        if( (pNode->jnFlags & JNODE_APPEND)==0 ) break;\n-        assert( pNode->eU==2 );\n-        pNode = &pNode[pNode->u.iAppend];\n-        j = 1;\n-      }\n-      jsonAppendChar(pOut, '}');\n-      break;\n+  if( pParse ){\n+    if( pParse->nJPRef>1 ){\n+      pParse->nJPRef--;\n+    }else{\n+      jsonParseReset(pParse);\n+      sqlite3DbFree(pParse->db, pParse);\n@@ -195921,14 +204269,3 @@\n-\/*\n-** Return a JsonNode and all its descendents as a JSON string.\n-*\/\n-static void jsonReturnJson(\n-  JsonNode *pNode,            \/* Node to return *\/\n-  sqlite3_context *pCtx,      \/* Return value for this function *\/\n-  sqlite3_value **aReplace    \/* Array of replacement values *\/\n-){\n-  JsonString s;\n-  jsonInit(&s, pCtx);\n-  jsonRenderNode(pNode, &s, aReplace);\n-  jsonResult(&s);\n-  sqlite3_result_subtype(pCtx, JSON_SUBTYPE);\n-}\n+\/**************************************************************************\n+** Utility routines for the JSON text parser\n+**************************************************************************\/\n@@ -195938,2 +204275,3 @@\n-** This routine only works if h really is a valid hexadecimal\n-** character:  0..9a..fA..F\n+** This routine only gives a correct answer if h really is a valid hexadecimal\n+** character:  0..9a..fA..F.  But unlike sqlite3HexToInt(), it does not\n+** assert() if the digit is not hex.\n@@ -195942,1 +204280,3 @@\n-  assert( (h>='0' && h<='9') ||  (h>='a' && h<='f') ||  (h>='A' && h<='F') );\n+#ifdef SQLITE_ASCII\n+  h += 9*(1&(h>>6));\n+#endif\n@@ -195945,2 +204285,0 @@\n-#else\n-  h += 9*(1&(h>>6));\n@@ -195956,4 +204294,0 @@\n-  assert( sqlite3Isxdigit(z[0]) );\n-  assert( sqlite3Isxdigit(z[1]) );\n-  assert( sqlite3Isxdigit(z[2]) );\n-  assert( sqlite3Isxdigit(z[3]) );\n@@ -195968,1 +204302,1 @@\n-** Make the JsonNode the return value of the function.\n+** Return true if z[] begins with 2 (or more) hexadecimal digits\n@@ -195970,37 +204304,79 @@\n-static void jsonReturn(\n-  JsonNode *pNode,            \/* Node to return *\/\n-  sqlite3_context *pCtx,      \/* Return value for this function *\/\n-  sqlite3_value **aReplace    \/* Array of replacement values *\/\n-){\n-  switch( pNode->eType ){\n-    default: {\n-      assert( pNode->eType==JSON_NULL );\n-      sqlite3_result_null(pCtx);\n-      break;\n-    }\n-    case JSON_TRUE: {\n-      sqlite3_result_int(pCtx, 1);\n-      break;\n-    }\n-    case JSON_FALSE: {\n-      sqlite3_result_int(pCtx, 0);\n-      break;\n-    }\n-    case JSON_INT: {\n-      sqlite3_int64 i = 0;\n-      const char *z;\n-      assert( pNode->eU==1 );\n-      z = pNode->u.zJContent;\n-      if( z[0]=='-' ){ z++; }\n-      while( z[0]>='0' && z[0]<='9' ){\n-        unsigned v = *(z++) - '0';\n-        if( i>=LARGEST_INT64\/10 ){\n-          if( i>LARGEST_INT64\/10 ) goto int_as_real;\n-          if( z[0]>='0' && z[0]<='9' ) goto int_as_real;\n-          if( v==9 ) goto int_as_real;\n-          if( v==8 ){\n-            if( pNode->u.zJContent[0]=='-' ){\n-              sqlite3_result_int64(pCtx, SMALLEST_INT64);\n-              goto int_done;\n-            }else{\n-              goto int_as_real;\n+static int jsonIs2Hex(const char *z){\n+  return sqlite3Isxdigit(z[0]) && sqlite3Isxdigit(z[1]);\n+}\n+\n+\/*\n+** Return true if z[] begins with 4 (or more) hexadecimal digits\n+*\/\n+static int jsonIs4Hex(const char *z){\n+  return jsonIs2Hex(z) && jsonIs2Hex(&z[2]);\n+}\n+\n+\/*\n+** Return the number of bytes of JSON5 whitespace at the beginning of\n+** the input string z[].\n+**\n+** JSON5 whitespace consists of any of the following characters:\n+**\n+**    Unicode  UTF-8         Name\n+**    U+0009   09            horizontal tab\n+**    U+000a   0a            line feed\n+**    U+000b   0b            vertical tab\n+**    U+000c   0c            form feed\n+**    U+000d   0d            carriage return\n+**    U+0020   20            space\n+**    U+00a0   c2 a0         non-breaking space\n+**    U+1680   e1 9a 80      ogham space mark\n+**    U+2000   e2 80 80      en quad\n+**    U+2001   e2 80 81      em quad\n+**    U+2002   e2 80 82      en space\n+**    U+2003   e2 80 83      em space\n+**    U+2004   e2 80 84      three-per-em space\n+**    U+2005   e2 80 85      four-per-em space\n+**    U+2006   e2 80 86      six-per-em space\n+**    U+2007   e2 80 87      figure space\n+**    U+2008   e2 80 88      punctuation space\n+**    U+2009   e2 80 89      thin space\n+**    U+200a   e2 80 8a      hair space\n+**    U+2028   e2 80 a8      line separator\n+**    U+2029   e2 80 a9      paragraph separator\n+**    U+202f   e2 80 af      narrow no-break space (NNBSP)\n+**    U+205f   e2 81 9f      medium mathematical space (MMSP)\n+**    U+3000   e3 80 80      ideographical space\n+**    U+FEFF   ef bb bf      byte order mark\n+**\n+** In addition, comments between '\/', '*' and '*', '\/' and\n+** from '\/', '\/' to end-of-line are also considered to be whitespace.\n+*\/\n+static int json5Whitespace(const char *zIn){\n+  int n = 0;\n+  const u8 *z = (u8*)zIn;\n+  while( 1 \/*exit by \"goto whitespace_done\"*\/ ){\n+    switch( z[n] ){\n+      case 0x09:\n+      case 0x0a:\n+      case 0x0b:\n+      case 0x0c:\n+      case 0x0d:\n+      case 0x20: {\n+        n++;\n+        break;\n+      }\n+      case '\/': {\n+        if( z[n+1]=='*' && z[n+2]!=0 ){\n+          int j;\n+          for(j=n+3; z[j]!='\/' || z[j-1]!='*'; j++){\n+            if( z[j]==0 ) goto whitespace_done;\n+          }\n+          n = j+1;\n+          break;\n+        }else if( z[n+1]=='\/' ){\n+          int j;\n+          char c;\n+          for(j=n+2; (c = z[j])!=0; j++){\n+            if( c=='\\n' || c=='\\r' ) break;\n+            if( 0xe2==(u8)c && 0x80==(u8)z[j+1]\n+             && (0xa8==(u8)z[j+2] || 0xa9==(u8)z[j+2])\n+            ){\n+              j += 2;\n+              break;\n@@ -196009,0 +204385,3 @@\n+          n = j;\n+          if( z[n] ) n++;\n+          break;\n@@ -196010,1 +204389,1 @@\n-        i = i*10 + v;\n+        goto whitespace_done;\n@@ -196012,48 +204391,3 @@\n-      if( pNode->u.zJContent[0]=='-' ){ i = -i; }\n-      sqlite3_result_int64(pCtx, i);\n-      int_done:\n-      break;\n-      int_as_real: ; \/* no break *\/ deliberate_fall_through\n-    }\n-    case JSON_REAL: {\n-      double r;\n-#ifdef SQLITE_AMALGAMATION\n-      const char *z;\n-      assert( pNode->eU==1 );\n-      z = pNode->u.zJContent;\n-      sqlite3AtoF(z, &r, sqlite3Strlen30(z), SQLITE_UTF8);\n-#else\n-      assert( pNode->eU==1 );\n-      r = strtod(pNode->u.zJContent, 0);\n-#endif\n-      sqlite3_result_double(pCtx, r);\n-      break;\n-    }\n-    case JSON_STRING: {\n-#if 0 \/* Never happens because JNODE_RAW is only set by json_set(),\n-      ** json_insert() and json_replace() and those routines do not\n-      ** call jsonReturn() *\/\n-      if( pNode->jnFlags & JNODE_RAW ){\n-        assert( pNode->eU==1 );\n-        sqlite3_result_text(pCtx, pNode->u.zJContent, pNode->n,\n-                            SQLITE_TRANSIENT);\n-      }else\n-#endif\n-      assert( (pNode->jnFlags & JNODE_RAW)==0 );\n-      if( (pNode->jnFlags & JNODE_ESCAPE)==0 ){\n-        \/* JSON formatted without any backslash-escapes *\/\n-        assert( pNode->eU==1 );\n-        sqlite3_result_text(pCtx, pNode->u.zJContent+1, pNode->n-2,\n-                            SQLITE_TRANSIENT);\n-      }else{\n-        \/* Translate JSON formatted string into raw text *\/\n-        u32 i;\n-        u32 n = pNode->n;\n-        const char *z;\n-        char *zOut;\n-        u32 j;\n-        assert( pNode->eU==1 );\n-        z = pNode->u.zJContent;\n-        zOut = sqlite3_malloc( n+1 );\n-        if( zOut==0 ){\n-          sqlite3_result_error_nomem(pCtx);\n+      case 0xc2: {\n+        if( z[n+1]==0xa0 ){\n+          n += 2;\n@@ -196062,50 +204396,16 @@\n-        for(i=1, j=0; i<n-1; i++){\n-          char c = z[i];\n-          if( c!='\\\\' ){\n-            zOut[j++] = c;\n-          }else{\n-            c = z[++i];\n-            if( c=='u' ){\n-              u32 v = jsonHexToInt4(z+i+1);\n-              i += 4;\n-              if( v==0 ) break;\n-              if( v<=0x7f ){\n-                zOut[j++] = (char)v;\n-              }else if( v<=0x7ff ){\n-                zOut[j++] = (char)(0xc0 | (v>>6));\n-                zOut[j++] = 0x80 | (v&0x3f);\n-              }else{\n-                u32 vlo;\n-                if( (v&0xfc00)==0xd800\n-                  && i<n-6\n-                  && z[i+1]=='\\\\'\n-                  && z[i+2]=='u'\n-                  && ((vlo = jsonHexToInt4(z+i+3))&0xfc00)==0xdc00\n-                ){\n-                  \/* We have a surrogate pair *\/\n-                  v = ((v&0x3ff)<<10) + (vlo&0x3ff) + 0x10000;\n-                  i += 6;\n-                  zOut[j++] = 0xf0 | (v>>18);\n-                  zOut[j++] = 0x80 | ((v>>12)&0x3f);\n-                  zOut[j++] = 0x80 | ((v>>6)&0x3f);\n-                  zOut[j++] = 0x80 | (v&0x3f);\n-                }else{\n-                  zOut[j++] = 0xe0 | (v>>12);\n-                  zOut[j++] = 0x80 | ((v>>6)&0x3f);\n-                  zOut[j++] = 0x80 | (v&0x3f);\n-                }\n-              }\n-            }else{\n-              if( c=='b' ){\n-                c = '\\b';\n-              }else if( c=='f' ){\n-                c = '\\f';\n-              }else if( c=='n' ){\n-                c = '\\n';\n-              }else if( c=='r' ){\n-                c = '\\r';\n-              }else if( c=='t' ){\n-                c = '\\t';\n-              }\n-              zOut[j++] = c;\n-            }\n+        goto whitespace_done;\n+      }\n+      case 0xe1: {\n+        if( z[n+1]==0x9a && z[n+2]==0x80 ){\n+          n += 3;\n+          break;\n+        }\n+        goto whitespace_done;\n+      }\n+      case 0xe2: {\n+        if( z[n+1]==0x80 ){\n+          u8 c = z[n+2];\n+          if( c<0x80 ) goto whitespace_done;\n+          if( c<=0x8a || c==0xa8 || c==0xa9 || c==0xaf ){\n+            n += 3;\n+            break;\n@@ -196113,0 +204413,3 @@\n+        }else if( z[n+1]==0x81 && z[n+2]==0x9f ){\n+          n += 3;\n+          break;\n@@ -196114,2 +204417,18 @@\n-        zOut[j] = 0;\n-        sqlite3_result_text(pCtx, zOut, j, sqlite3_free);\n+        goto whitespace_done;\n+      }\n+      case 0xe3: {\n+        if( z[n+1]==0x80 && z[n+2]==0x80 ){\n+          n += 3;\n+          break;\n+        }\n+        goto whitespace_done;\n+      }\n+      case 0xef: {\n+        if( z[n+1]==0xbb && z[n+2]==0xbf ){\n+          n += 3;\n+          break;\n+        }\n+        goto whitespace_done;\n+      }\n+      default: {\n+        goto whitespace_done;\n@@ -196117,6 +204436,0 @@\n-      break;\n-    }\n-    case JSON_ARRAY:\n-    case JSON_OBJECT: {\n-      jsonReturnJson(pNode, pCtx, aReplace);\n-      break;\n@@ -196125,0 +204438,2 @@\n+  whitespace_done:\n+  return n;\n@@ -196127,3 +204442,0 @@\n-\/* Forward reference *\/\n-static int jsonParseAddNode(JsonParse*,u32,u32,const char*);\n-\n@@ -196131,2 +204443,1 @@\n-** A macro to hint to the compiler that a function should not be\n-** inlined.\n+** Extra floating-point literals to allow in JSON.\n@@ -196134,7 +204445,15 @@\n-#if defined(__GNUC__)\n-#  define JSON_NOINLINE  __attribute__((noinline))\n-#elif defined(_MSC_VER) && _MSC_VER>=1310\n-#  define JSON_NOINLINE  __declspec(noinline)\n-#else\n-#  define JSON_NOINLINE\n-#endif\n+static const struct NanInfName {\n+  char c1;\n+  char c2;\n+  char n;\n+  char eType;\n+  char nRepl;\n+  char *zMatch;\n+  char *zRepl;\n+} aNanInfName[] = {\n+  { 'i', 'I', 3, JSONB_FLOAT, 7, \"inf\", \"9.0e999\" },\n+  { 'i', 'I', 8, JSONB_FLOAT, 7, \"infinity\", \"9.0e999\" },\n+  { 'n', 'N', 3, JSONB_NULL, 4, \"NaN\", \"null\" },\n+  { 'q', 'Q', 4, JSONB_NULL, 4, \"QNaN\", \"null\" },\n+  { 's', 'S', 4, JSONB_NULL, 4, \"SNaN\", \"null\" },\n+};\n@@ -196143,5 +204462,7 @@\n-static JSON_NOINLINE int jsonParseAddNodeExpand(\n-  JsonParse *pParse,        \/* Append the node to this object *\/\n-  u32 eType,                \/* Node type *\/\n-  u32 n,                    \/* Content size or sub-node count *\/\n-  const char *zContent      \/* Content *\/\n+\/*\n+** Report the wrong number of arguments for json_insert(), json_replace()\n+** or json_set().\n+*\/\n+static void jsonWrongNumArgs(\n+  sqlite3_context *pCtx,\n+  const char *zFuncName\n@@ -196149,9 +204470,23 @@\n-  u32 nNew;\n-  JsonNode *pNew;\n-  assert( pParse->nNode>=pParse->nAlloc );\n-  if( pParse->oom ) return -1;\n-  nNew = pParse->nAlloc*2 + 10;\n-  pNew = sqlite3_realloc64(pParse->aNode, sizeof(JsonNode)*nNew);\n-  if( pNew==0 ){\n-    pParse->oom = 1;\n-    return -1;\n+  char *zMsg = sqlite3_mprintf(\"json_%s() needs an odd number of arguments\",\n+                               zFuncName);\n+  sqlite3_result_error(pCtx, zMsg, -1);\n+  sqlite3_free(zMsg);\n+}\n+\n+\/****************************************************************************\n+** Utility routines for dealing with the binary BLOB representation of JSON\n+****************************************************************************\/\n+\n+\/*\n+** Expand pParse->aBlob so that it holds at least N bytes.\n+**\n+** Return the number of errors.\n+*\/\n+static int jsonBlobExpand(JsonParse *pParse, u32 N){\n+  u8 *aNew;\n+  u32 t;\n+  assert( N>pParse->nBlobAlloc );\n+  if( pParse->nBlobAlloc==0 ){\n+    t = 100;\n+  }else{\n+    t = pParse->nBlobAlloc*2;\n@@ -196159,4 +204494,6 @@\n-  pParse->nAlloc = nNew;\n-  pParse->aNode = pNew;\n-  assert( pParse->nNode<pParse->nAlloc );\n-  return jsonParseAddNode(pParse, eType, n, zContent);\n+  if( t<N ) t = N+100;\n+  aNew = sqlite3DbRealloc(pParse->db, pParse->aBlob, t);\n+  if( aNew==0 ){ pParse->oom = 1; return 1; }\n+  pParse->aBlob = aNew;\n+  pParse->nBlobAlloc = t;\n+  return 0;\n@@ -196166,3 +204503,6 @@\n-** Create a new JsonNode instance based on the arguments and append that\n-** instance to the JsonParse.  Return the index in pParse->aNode[] of the\n-** new node, or -1 if a memory allocation fails.\n+** If pParse->aBlob is not previously editable (because it is taken\n+** from sqlite3_value_blob(), as indicated by the fact that\n+** pParse->nBlobAlloc==0 and pParse->nBlob>0) then make it editable\n+** by making a copy into space obtained from malloc.\n+**\n+** Return true on success.  Return false on OOM.\n@@ -196170,5 +204510,22 @@\n-static int jsonParseAddNode(\n-  JsonParse *pParse,        \/* Append the node to this object *\/\n-  u32 eType,                \/* Node type *\/\n-  u32 n,                    \/* Content size or sub-node count *\/\n-  const char *zContent      \/* Content *\/\n+static int jsonBlobMakeEditable(JsonParse *pParse, u32 nExtra){\n+  u8 *aOld;\n+  u32 nSize;\n+  assert( !pParse->bReadOnly );\n+  if( pParse->oom ) return 0;\n+  if( pParse->nBlobAlloc>0 ) return 1;\n+  aOld = pParse->aBlob;\n+  nSize = pParse->nBlob + nExtra;\n+  pParse->aBlob = 0;\n+  if( jsonBlobExpand(pParse, nSize) ){\n+    return 0;\n+  }\n+  assert( pParse->nBlobAlloc >= pParse->nBlob + nExtra );\n+  memcpy(pParse->aBlob, aOld, pParse->nBlob);\n+  return 1;\n+}\n+\n+\/* Expand pParse->aBlob and append one bytes.\n+*\/\n+static SQLITE_NOINLINE void jsonBlobExpandAndAppendOneByte(\n+  JsonParse *pParse,\n+  u8 c\n@@ -196176,3 +204533,4 @@\n-  JsonNode *p;\n-  if( pParse->aNode==0 || pParse->nNode>=pParse->nAlloc ){\n-    return jsonParseAddNodeExpand(pParse, eType, n, zContent);\n+  jsonBlobExpand(pParse, pParse->nBlob+1);\n+  if( pParse->oom==0 ){\n+    assert( pParse->nBlob+1<=pParse->nBlobAlloc );\n+    pParse->aBlob[pParse->nBlob++] = c;\n@@ -196180,7 +204538,0 @@\n-  p = &pParse->aNode[pParse->nNode];\n-  p->eType = (u8)eType;\n-  p->jnFlags = 0;\n-  VVA( p->eU = zContent ? 1 : 0 );\n-  p->n = n;\n-  p->u.zJContent = zContent;\n-  return pParse->nNode++;\n@@ -196189,2 +204540,1 @@\n-\/*\n-** Return true if z[] begins with 4 (or more) hexadecimal digits\n+\/* Append a single character.\n@@ -196192,3 +204542,146 @@\n-static int jsonIs4Hex(const char *z){\n-  int i;\n-  for(i=0; i<4; i++) if( !sqlite3Isxdigit(z[i]) ) return 0;\n+static void jsonBlobAppendOneByte(JsonParse *pParse, u8 c){\n+  if( pParse->nBlob >= pParse->nBlobAlloc ){\n+    jsonBlobExpandAndAppendOneByte(pParse, c);\n+  }else{\n+    pParse->aBlob[pParse->nBlob++] = c;\n+  }\n+}\n+\n+\/* Slow version of jsonBlobAppendNode() that first resizes the\n+** pParse->aBlob structure.\n+*\/\n+static void jsonBlobAppendNode(JsonParse*,u8,u32,const void*);\n+static SQLITE_NOINLINE void jsonBlobExpandAndAppendNode(\n+  JsonParse *pParse,\n+  u8 eType,\n+  u32 szPayload,\n+  const void *aPayload\n+){\n+  if( jsonBlobExpand(pParse, pParse->nBlob+szPayload+9) ) return;\n+  jsonBlobAppendNode(pParse, eType, szPayload, aPayload);\n+}\n+\n+\n+\/* Append an node type byte together with the payload size and\n+** possibly also the payload.\n+**\n+** If aPayload is not NULL, then it is a pointer to the payload which\n+** is also appended.  If aPayload is NULL, the pParse->aBlob[] array\n+** is resized (if necessary) so that it is big enough to hold the\n+** payload, but the payload is not appended and pParse->nBlob is left\n+** pointing to where the first byte of payload will eventually be.\n+*\/\n+static void jsonBlobAppendNode(\n+  JsonParse *pParse,          \/* The JsonParse object under construction *\/\n+  u8 eType,                   \/* Node type.  One of JSONB_* *\/\n+  u32 szPayload,              \/* Number of bytes of payload *\/\n+  const void *aPayload        \/* The payload.  Might be NULL *\/\n+){\n+  u8 *a;\n+  if( pParse->nBlob+szPayload+9 > pParse->nBlobAlloc ){\n+    jsonBlobExpandAndAppendNode(pParse,eType,szPayload,aPayload);\n+    return;\n+  }\n+  assert( pParse->aBlob!=0 );\n+  a = &pParse->aBlob[pParse->nBlob];\n+  if( szPayload<=11 ){\n+    a[0] = eType | (szPayload<<4);\n+    pParse->nBlob += 1;\n+  }else if( szPayload<=0xff ){\n+    a[0] = eType | 0xc0;\n+    a[1] = szPayload & 0xff;\n+    pParse->nBlob += 2;\n+  }else if( szPayload<=0xffff ){\n+    a[0] = eType | 0xd0;\n+    a[1] = (szPayload >> 8) & 0xff;\n+    a[2] = szPayload & 0xff;\n+    pParse->nBlob += 3;\n+  }else{\n+    a[0] = eType | 0xe0;\n+    a[1] = (szPayload >> 24) & 0xff;\n+    a[2] = (szPayload >> 16) & 0xff;\n+    a[3] = (szPayload >> 8) & 0xff;\n+    a[4] = szPayload & 0xff;\n+    pParse->nBlob += 5;\n+  }\n+  if( aPayload ){\n+    pParse->nBlob += szPayload;\n+    memcpy(&pParse->aBlob[pParse->nBlob-szPayload], aPayload, szPayload);\n+  }\n+}\n+\n+\/* Change the payload size for the node at index i to be szPayload.\n+*\/\n+static int jsonBlobChangePayloadSize(\n+  JsonParse *pParse,\n+  u32 i,\n+  u32 szPayload\n+){\n+  u8 *a;\n+  u8 szType;\n+  u8 nExtra;\n+  u8 nNeeded;\n+  int delta;\n+  if( pParse->oom ) return 0;\n+  a = &pParse->aBlob[i];\n+  szType = a[0]>>4;\n+  if( szType<=11 ){\n+    nExtra = 0;\n+  }else if( szType==12 ){\n+    nExtra = 1;\n+  }else if( szType==13 ){\n+    nExtra = 2;\n+  }else{\n+    nExtra = 4;\n+  }\n+  if( szPayload<=11 ){\n+    nNeeded = 0;\n+  }else if( szPayload<=0xff ){\n+    nNeeded = 1;\n+  }else if( szPayload<=0xffff ){\n+    nNeeded = 2;\n+  }else{\n+    nNeeded = 4;\n+  }\n+  delta = nNeeded - nExtra;\n+  if( delta ){\n+    u32 newSize = pParse->nBlob + delta;\n+    if( delta>0 ){\n+      if( newSize>pParse->nBlobAlloc && jsonBlobExpand(pParse, newSize) ){\n+        return 0;  \/* OOM error.  Error state recorded in pParse->oom. *\/\n+      }\n+      a = &pParse->aBlob[i];\n+      memmove(&a[1+delta], &a[1], pParse->nBlob - (i+1));\n+    }else{\n+      memmove(&a[1], &a[1-delta], pParse->nBlob - (i+1-delta));\n+    }\n+    pParse->nBlob = newSize;\n+  }\n+  if( nNeeded==0 ){\n+    a[0] = (a[0] & 0x0f) | (szPayload<<4);\n+  }else if( nNeeded==1 ){\n+    a[0] = (a[0] & 0x0f) | 0xc0;\n+    a[1] = szPayload & 0xff;\n+  }else if( nNeeded==2 ){\n+    a[0] = (a[0] & 0x0f) | 0xd0;\n+    a[1] = (szPayload >> 8) & 0xff;\n+    a[2] = szPayload & 0xff;\n+  }else{\n+    a[0] = (a[0] & 0x0f) | 0xe0;\n+    a[1] = (szPayload >> 24) & 0xff;\n+    a[2] = (szPayload >> 16) & 0xff;\n+    a[3] = (szPayload >> 8) & 0xff;\n+    a[4] = szPayload & 0xff;\n+  }\n+  return delta;\n+}\n+\n+\/*\n+** If z[0] is 'u' and is followed by exactly 4 hexadecimal character,\n+** then set *pOp to JSONB_TEXTJ and return true.  If not, do not make\n+** any changes to *pOp and return false.\n+*\/\n+static int jsonIs4HexB(const char *z, int *pOp){\n+  if( z[0]!='u' ) return 0;\n+  if( !jsonIs4Hex(&z[1]) ) return 0;\n+  *pOp = JSONB_TEXTJ;\n@@ -196199,2 +204692,207 @@\n-** Parse a single JSON value which begins at pParse->zJson[i].  Return the\n-** index of the first character past the end of the value parsed.\n+** Check a single element of the JSONB in pParse for validity.\n+**\n+** The element to be checked starts at offset i and must end at on the\n+** last byte before iEnd.\n+**\n+** Return 0 if everything is correct.  Return the 1-based byte offset of the\n+** error if a problem is detected.  (In other words, if the error is at offset\n+** 0, return 1).\n+*\/\n+static u32 jsonbValidityCheck(\n+  const JsonParse *pParse,    \/* Input JSONB.  Only aBlob and nBlob are used *\/\n+  u32 i,                      \/* Start of element as pParse->aBlob[i] *\/\n+  u32 iEnd,                   \/* One more than the last byte of the element *\/\n+  u32 iDepth                  \/* Current nesting depth *\/\n+){\n+  u32 n, sz, j, k;\n+  const u8 *z;\n+  u8 x;\n+  if( iDepth>JSON_MAX_DEPTH ) return i+1;\n+  sz = 0;\n+  n = jsonbPayloadSize(pParse, i, &sz);\n+  if( NEVER(n==0) ) return i+1;          \/* Checked by caller *\/\n+  if( NEVER(i+n+sz!=iEnd) ) return i+1;  \/* Checked by caller *\/\n+  z = pParse->aBlob;\n+  x = z[i] & 0x0f;\n+  switch( x ){\n+    case JSONB_NULL:\n+    case JSONB_TRUE:\n+    case JSONB_FALSE: {\n+      return n+sz==1 ? 0 : i+1;\n+    }\n+    case JSONB_INT: {\n+      if( sz<1 ) return i+1;\n+      j = i+n;\n+      if( z[j]=='-' ){\n+        j++;\n+        if( sz<2 ) return i+1;\n+      }\n+      k = i+n+sz;\n+      while( j<k ){\n+        if( sqlite3Isdigit(z[j]) ){\n+          j++;\n+        }else{\n+          return j+1;\n+        }\n+      }\n+      return 0;\n+    }\n+    case JSONB_INT5: {\n+      if( sz<3 ) return i+1;\n+      j = i+n;\n+      if( z[j]=='-' ){\n+        if( sz<4 ) return i+1;\n+        j++;\n+      }\n+      if( z[j]!='0' ) return i+1;\n+      if( z[j+1]!='x' && z[j+1]!='X' ) return j+2;\n+      j += 2;\n+      k = i+n+sz;\n+      while( j<k ){\n+        if( sqlite3Isxdigit(z[j]) ){\n+          j++;\n+        }else{\n+          return j+1;\n+        }\n+      }\n+      return 0;\n+    }\n+    case JSONB_FLOAT:\n+    case JSONB_FLOAT5: {\n+      u8 seen = 0;   \/* 0: initial.  1: '.' seen  2: 'e' seen *\/\n+      if( sz<2 ) return i+1;\n+      j = i+n;\n+      k = j+sz;\n+      if( z[j]=='-' ){\n+        j++;\n+        if( sz<3 ) return i+1;\n+      }\n+      if( z[j]=='.' ){\n+        if( x==JSONB_FLOAT ) return j+1;\n+        if( !sqlite3Isdigit(z[j+1]) ) return j+1;\n+        j += 2;\n+        seen = 1;\n+      }else if( z[j]=='0' && x==JSONB_FLOAT ){\n+        if( j+3>k ) return j+1;\n+        if( z[j+1]!='.' && z[j+1]!='e' && z[j+1]!='E' ) return j+1;\n+        j++;\n+      }\n+      for(; j<k; j++){\n+        if( sqlite3Isdigit(z[j]) ) continue;\n+        if( z[j]=='.' ){\n+          if( seen>0 ) return j+1;\n+          if( x==JSONB_FLOAT && (j==k-1 || !sqlite3Isdigit(z[j+1])) ){\n+            return j+1;\n+          }\n+          seen = 1;\n+          continue;\n+        }\n+        if( z[j]=='e' || z[j]=='E' ){\n+          if( seen==2 ) return j+1;\n+          if( j==k-1 ) return j+1;\n+          if( z[j+1]=='+' || z[j+1]=='-' ){\n+            j++;\n+            if( j==k-1 ) return j+1;\n+          }\n+          seen = 2;\n+          continue;\n+        }\n+        return j+1;\n+      }\n+      if( seen==0 ) return i+1;\n+      return 0;\n+    }\n+    case JSONB_TEXT: {\n+      j = i+n;\n+      k = j+sz;\n+      while( j<k ){\n+        if( !jsonIsOk[z[j]] && z[j]!='\\'' ) return j+1;\n+        j++;\n+      }\n+      return 0;\n+    }\n+    case JSONB_TEXTJ:\n+    case JSONB_TEXT5: {\n+      j = i+n;\n+      k = j+sz;\n+      while( j<k ){\n+        if( !jsonIsOk[z[j]] && z[j]!='\\'' ){\n+          if( z[j]=='\"' ){\n+            if( x==JSONB_TEXTJ ) return j+1;\n+          }else if( z[j]!='\\\\' || j+1>=k ){\n+            return j+1;\n+          }else if( strchr(\"\\\"\\\\\/bfnrt\",z[j+1])!=0 ){\n+            j++;\n+          }else if( z[j+1]=='u' ){\n+            if( j+5>=k ) return j+1;\n+            if( !jsonIs4Hex((const char*)&z[j+2]) ) return j+1;\n+            j++;\n+          }else if( x!=JSONB_TEXT5 ){\n+            return j+1;\n+          }else{\n+            u32 c = 0;\n+            u32 szC = jsonUnescapeOneChar((const char*)&z[j], k-j, &c);\n+            if( c==JSON_INVALID_CHAR ) return j+1;\n+            j += szC - 1;\n+          }\n+        }\n+        j++;\n+      }\n+      return 0;\n+    }\n+    case JSONB_TEXTRAW: {\n+      return 0;\n+    }\n+    case JSONB_ARRAY: {\n+      u32 sub;\n+      j = i+n;\n+      k = j+sz;\n+      while( j<k ){\n+        sz = 0;\n+        n = jsonbPayloadSize(pParse, j, &sz);\n+        if( n==0 ) return j+1;\n+        if( j+n+sz>k ) return j+1;\n+        sub = jsonbValidityCheck(pParse, j, j+n+sz, iDepth+1);\n+        if( sub ) return sub;\n+        j += n + sz;\n+      }\n+      assert( j==k );\n+      return 0;\n+    }\n+    case JSONB_OBJECT: {\n+      u32 cnt = 0;\n+      u32 sub;\n+      j = i+n;\n+      k = j+sz;\n+      while( j<k ){\n+        sz = 0;\n+        n = jsonbPayloadSize(pParse, j, &sz);\n+        if( n==0 ) return j+1;\n+        if( j+n+sz>k ) return j+1;\n+        if( (cnt & 1)==0 ){\n+          x = z[j] & 0x0f;\n+          if( x<JSONB_TEXT || x>JSONB_TEXTRAW ) return j+1;\n+        }\n+        sub = jsonbValidityCheck(pParse, j, j+n+sz, iDepth+1);\n+        if( sub ) return sub;\n+        cnt++;\n+        j += n + sz;\n+      }\n+      assert( j==k );\n+      if( (cnt & 1)!=0 ) return j+1;\n+      return 0;\n+    }\n+    default: {\n+      return i+1;\n+    }\n+  }\n+}\n+\n+\/*\n+** Translate a single element of JSON text at pParse->zJson[i] into\n+** its equivalent binary JSONB representation.  Append the translation into\n+** pParse->aBlob[] beginning at pParse->nBlob.  The size of\n+** pParse->aBlob[] is increased as necessary.\n+**\n+** Return the index of the first character past the end of the element parsed,\n+** or one of the following special result codes:\n@@ -196202,3 +204900,6 @@\n-** Return negative for a syntax error.  Special cases:  return -2 if the\n-** first non-whitespace character is '}' and return -3 if the first\n-** non-whitespace character is ']'.\n+**      0    End of input\n+**     -1    Syntax error or OOM\n+**     -2    '}' seen   \\\n+**     -3    ']' seen    \\___  For these returns, pParse->iErr is set to\n+**     -4    ',' seen    \/     the index in zJson[] of the seen character\n+**     -5    ':' seen   \/\n@@ -196206,1 +204907,1 @@\n-static int jsonParseValue(JsonParse *pParse, u32 i){\n+static int jsonTranslateTextToBlob(JsonParse *pParse, u32 i){\n@@ -196209,1 +204910,1 @@\n-  int iThis;\n+  u32 iThis, iStart;\n@@ -196211,1 +204912,1 @@\n-  JsonNode *pNode;\n+  u8 t;\n@@ -196213,2 +204914,3 @@\n-  while( fast_isspace(z[i]) ){ i++; }\n-  if( (c = z[i])=='{' ){\n+json_parse_restart:\n+  switch( (u8)z[i] ){\n+  case '{': {\n@@ -196216,2 +204918,7 @@\n-    iThis = jsonParseAddNode(pParse, JSON_OBJECT, 0, 0);\n-    if( iThis<0 ) return -1;\n+    iThis = pParse->nBlob;\n+    jsonBlobAppendNode(pParse, JSONB_OBJECT, pParse->nJson-i, 0);\n+    if( ++pParse->iDepth > JSON_MAX_DEPTH ){\n+      pParse->iErr = i;\n+      return -1;\n+    }\n+    iStart = pParse->nBlob;\n@@ -196219,7 +204926,28 @@\n-      while( fast_isspace(z[j]) ){ j++; }\n-      if( ++pParse->iDepth > JSON_MAX_DEPTH ) return -1;\n-      x = jsonParseValue(pParse, j);\n-      if( x<0 ){\n-        pParse->iDepth--;\n-        if( x==(-2) && pParse->nNode==(u32)iThis+1 ) return j+1;\n-        return -1;\n+      u32 iBlob = pParse->nBlob;\n+      x = jsonTranslateTextToBlob(pParse, j);\n+      if( x<=0 ){\n+        int op;\n+        if( x==(-2) ){\n+          j = pParse->iErr;\n+          if( pParse->nBlob!=(u32)iStart ) pParse->hasNonstd = 1;\n+          break;\n+        }\n+        j += json5Whitespace(&z[j]);\n+        op = JSONB_TEXT;\n+        if( sqlite3JsonId1(z[j])\n+         || (z[j]=='\\\\' && jsonIs4HexB(&z[j+1], &op))\n+        ){\n+          int k = j+1;\n+          while( (sqlite3JsonId2(z[k]) && json5Whitespace(&z[k])==0)\n+            || (z[k]=='\\\\' && jsonIs4HexB(&z[k+1], &op))\n+          ){\n+            k++;\n+          }\n+          assert( iBlob==pParse->nBlob );\n+          jsonBlobAppendNode(pParse, op, k-j, &z[j]);\n+          pParse->hasNonstd = 1;\n+          x = k;\n+        }else{\n+          if( x!=-1 ) pParse->iErr = j;\n+          return -1;\n+        }\n@@ -196228,3 +204956,5 @@\n-      pNode = &pParse->aNode[pParse->nNode-1];\n-      if( pNode->eType!=JSON_STRING ) return -1;\n-      pNode->jnFlags |= JNODE_LABEL;\n+      t = pParse->aBlob[iBlob] & 0x0f;\n+      if( t<JSONB_TEXT || t>JSONB_TEXTRAW ){\n+        pParse->iErr = j;\n+        return -1;\n+      }\n@@ -196232,6 +204962,24 @@\n-      while( fast_isspace(z[j]) ){ j++; }\n-      if( z[j]!=':' ) return -1;\n-      j++;\n-      x = jsonParseValue(pParse, j);\n-      pParse->iDepth--;\n-      if( x<0 ) return -1;\n+      if( z[j]==':' ){\n+        j++;\n+      }else{\n+        if( jsonIsspace(z[j]) ){\n+          \/* strspn() is not helpful here *\/\n+          do{ j++; }while( jsonIsspace(z[j]) );\n+          if( z[j]==':' ){\n+            j++;\n+            goto parse_object_value;\n+          }\n+        }\n+        x = jsonTranslateTextToBlob(pParse, j);\n+        if( x!=(-5) ){\n+          if( x!=(-1) ) pParse->iErr = j;\n+          return -1;\n+        }\n+        j = pParse->iErr+1;\n+      }\n+    parse_object_value:\n+      x = jsonTranslateTextToBlob(pParse, j);\n+      if( x<=0 ){\n+        if( x!=(-1) ) pParse->iErr = j;\n+        return -1;\n+      }\n@@ -196239,5 +204987,25 @@\n-      while( fast_isspace(z[j]) ){ j++; }\n-      c = z[j];\n-      if( c==',' ) continue;\n-      if( c!='}' ) return -1;\n-      break;\n+      if( z[j]==',' ){\n+        continue;\n+      }else if( z[j]=='}' ){\n+        break;\n+      }else{\n+        if( jsonIsspace(z[j]) ){\n+          j += 1 + (u32)strspn(&z[j+1], jsonSpaces);\n+          if( z[j]==',' ){\n+            continue;\n+          }else if( z[j]=='}' ){\n+            break;\n+          }\n+        }\n+        x = jsonTranslateTextToBlob(pParse, j);\n+        if( x==(-4) ){\n+          j = pParse->iErr;\n+          continue;\n+        }\n+        if( x==(-2) ){\n+          j = pParse->iErr;\n+          break;\n+        }\n+      }\n+      pParse->iErr = j;\n+      return -1;\n@@ -196245,1 +205013,2 @@\n-    pParse->aNode[iThis].n = pParse->nNode - (u32)iThis - 1;\n+    jsonBlobChangePayloadSize(pParse, iThis, pParse->nBlob - iStart);\n+    pParse->iDepth--;\n@@ -196247,1 +205016,2 @@\n-  }else if( c=='[' ){\n+  }\n+  case '[': {\n@@ -196249,3 +205019,9 @@\n-    iThis = jsonParseAddNode(pParse, JSON_ARRAY, 0, 0);\n-    if( iThis<0 ) return -1;\n-    memset(&pParse->aNode[iThis].u, 0, sizeof(pParse->aNode[iThis].u));\n+    iThis = pParse->nBlob;\n+    assert( i<=(u32)pParse->nJson );\n+    jsonBlobAppendNode(pParse, JSONB_ARRAY, pParse->nJson - i, 0);\n+    iStart = pParse->nBlob;\n+    if( pParse->oom ) return -1;\n+    if( ++pParse->iDepth > JSON_MAX_DEPTH ){\n+      pParse->iErr = i;\n+      return -1;\n+    }\n@@ -196253,6 +205029,8 @@\n-      while( fast_isspace(z[j]) ){ j++; }\n-      if( ++pParse->iDepth > JSON_MAX_DEPTH ) return -1;\n-      x = jsonParseValue(pParse, j);\n-      pParse->iDepth--;\n-      if( x<0 ){\n-        if( x==(-3) && pParse->nNode==(u32)iThis+1 ) return j+1;\n+      x = jsonTranslateTextToBlob(pParse, j);\n+      if( x<=0 ){\n+        if( x==(-3) ){\n+          j = pParse->iErr;\n+          if( pParse->nBlob!=iStart ) pParse->hasNonstd = 1;\n+          break;\n+        }\n+        if( x!=(-1) ) pParse->iErr = j;\n@@ -196262,5 +205040,25 @@\n-      while( fast_isspace(z[j]) ){ j++; }\n-      c = z[j];\n-      if( c==',' ) continue;\n-      if( c!=']' ) return -1;\n-      break;\n+      if( z[j]==',' ){\n+        continue;\n+      }else if( z[j]==']' ){\n+        break;\n+      }else{\n+        if( jsonIsspace(z[j]) ){\n+          j += 1 + (u32)strspn(&z[j+1], jsonSpaces);\n+          if( z[j]==',' ){\n+            continue;\n+          }else if( z[j]==']' ){\n+            break;\n+          }\n+        }\n+        x = jsonTranslateTextToBlob(pParse, j);\n+        if( x==(-4) ){\n+          j = pParse->iErr;\n+          continue;\n+        }\n+        if( x==(-3) ){\n+          j = pParse->iErr;\n+          break;\n+        }\n+      }\n+      pParse->iErr = j;\n+      return -1;\n@@ -196268,1 +205066,2 @@\n-    pParse->aNode[iThis].n = pParse->nNode - (u32)iThis - 1;\n+    jsonBlobChangePayloadSize(pParse, iThis, pParse->nBlob - iStart);\n+    pParse->iDepth--;\n@@ -196270,1 +205069,8 @@\n-  }else if( c=='\"' ){\n+  }\n+  case '\\'': {\n+    u8 opcode;\n+    char cDelim;\n+    pParse->hasNonstd = 1;\n+    opcode = JSONB_TEXT;\n+    goto parse_string;\n+  case '\"':\n@@ -196272,1 +205078,3 @@\n-    u8 jnFlags = 0;\n+    opcode = JSONB_TEXT;\n+  parse_string:\n+    cDelim = z[i];\n@@ -196274,5 +205082,10 @@\n-    for(;;){\n-      c = z[j];\n-      if( (c & ~0x1f)==0 ){\n-        \/* Control characters are not allowed in strings *\/\n-        return -1;\n+    while( 1 \/*exit-by-break*\/ ){\n+      if( jsonIsOk[(u8)z[j]] ){\n+        if( !jsonIsOk[(u8)z[j+1]] ){\n+          j += 1;\n+        }else if( !jsonIsOk[(u8)z[j+2]] ){\n+          j += 2;\n+        }else{\n+          j += 3;\n+          continue;\n+        }\n@@ -196280,1 +205093,4 @@\n-      if( c=='\\\\' ){\n+      c = z[j];\n+      if( c==cDelim ){\n+        break;\n+      }else if( c=='\\\\' ){\n@@ -196284,2 +205100,12 @@\n-           || (c=='u' && jsonIs4Hex(z+j+1)) ){\n-          jnFlags = JNODE_ESCAPE;\n+           || (c=='u' && jsonIs4Hex(&z[j+1])) ){\n+          if( opcode==JSONB_TEXT ) opcode = JSONB_TEXTJ;\n+        }else if( c=='\\'' || c=='0' || c=='v' || c=='\\n'\n+           || (0xe2==(u8)c && 0x80==(u8)z[j+1]\n+                && (0xa8==(u8)z[j+2] || 0xa9==(u8)z[j+2]))\n+           || (c=='x' && jsonIs2Hex(&z[j+1])) ){\n+          opcode = JSONB_TEXT5;\n+          pParse->hasNonstd = 1;\n+        }else if( c=='\\r' ){\n+          if( z[j+1]=='\\n' ) j++;\n+          opcode = JSONB_TEXT5;\n+          pParse->hasNonstd = 1;\n@@ -196287,0 +205113,1 @@\n+          pParse->iErr = j;\n@@ -196289,0 +205116,4 @@\n+      }else if( c<=0x1f ){\n+        \/* Control characters are not allowed in strings *\/\n+        pParse->iErr = j;\n+        return -1;\n@@ -196290,1 +205121,1 @@\n-        break;\n+        opcode = JSONB_TEXT5;\n@@ -196294,2 +205125,1 @@\n-    jsonParseAddNode(pParse, JSON_STRING, j+1-i, &z[i]);\n-    if( !pParse->oom ) pParse->aNode[pParse->nNode-1].jnFlags = jnFlags;\n+    jsonBlobAppendNode(pParse, opcode, j-1-i, &z[i+1]);\n@@ -196297,16 +205127,42 @@\n-  }else if( c=='n'\n-         && strncmp(z+i,\"null\",4)==0\n-         && !sqlite3Isalnum(z[i+4]) ){\n-    jsonParseAddNode(pParse, JSON_NULL, 0, 0);\n-    return i+4;\n-  }else if( c=='t'\n-         && strncmp(z+i,\"true\",4)==0\n-         && !sqlite3Isalnum(z[i+4]) ){\n-    jsonParseAddNode(pParse, JSON_TRUE, 0, 0);\n-    return i+4;\n-  }else if( c=='f'\n-         && strncmp(z+i,\"false\",5)==0\n-         && !sqlite3Isalnum(z[i+5]) ){\n-    jsonParseAddNode(pParse, JSON_FALSE, 0, 0);\n-    return i+5;\n-  }else if( c=='-' || (c>='0' && c<='9') ){\n+  }\n+  case 't': {\n+    if( strncmp(z+i,\"true\",4)==0 && !sqlite3Isalnum(z[i+4]) ){\n+      jsonBlobAppendOneByte(pParse, JSONB_TRUE);\n+      return i+4;\n+    }\n+    pParse->iErr = i;\n+    return -1;\n+  }\n+  case 'f': {\n+    if( strncmp(z+i,\"false\",5)==0 && !sqlite3Isalnum(z[i+5]) ){\n+      jsonBlobAppendOneByte(pParse, JSONB_FALSE);\n+      return i+5;\n+    }\n+    pParse->iErr = i;\n+    return -1;\n+  }\n+  case '+': {\n+    u8 seenE;\n+    pParse->hasNonstd = 1;\n+    t = 0x00;            \/* Bit 0x01:  JSON5.   Bit 0x02:  FLOAT *\/\n+    goto parse_number;\n+  case '.':\n+    if( sqlite3Isdigit(z[i+1]) ){\n+      pParse->hasNonstd = 1;\n+      t = 0x03;          \/* Bit 0x01:  JSON5.   Bit 0x02:  FLOAT *\/\n+      seenE = 0;\n+      goto parse_number_2;\n+    }\n+    pParse->iErr = i;\n+    return -1;\n+  case '-':\n+  case '0':\n+  case '1':\n+  case '2':\n+  case '3':\n+  case '4':\n+  case '5':\n+  case '6':\n+  case '7':\n+  case '8':\n+  case '9':\n@@ -196314,2 +205170,3 @@\n-    u8 seenDP = 0;\n-    u8 seenE = 0;\n+    t = 0x00;            \/* Bit 0x01:  JSON5.   Bit 0x02:  FLOAT *\/\n+  parse_number:\n+    seenE = 0;\n@@ -196317,0 +205174,4 @@\n+    assert( '+' < '0' );\n+    assert( '.' < '0' );\n+    c = z[i];\n+\n@@ -196318,2 +205179,47 @@\n-      j = c=='-' ? i+1 : i;\n-      if( z[j]=='0' && z[j+1]>='0' && z[j+1]<='9' ) return -1;\n+      if( c=='0' ){\n+        if( (z[i+1]=='x' || z[i+1]=='X') && sqlite3Isxdigit(z[i+2]) ){\n+          assert( t==0x00 );\n+          pParse->hasNonstd = 1;\n+          t = 0x01;\n+          for(j=i+3; sqlite3Isxdigit(z[j]); j++){}\n+          goto parse_number_finish;\n+        }else if( sqlite3Isdigit(z[i+1]) ){\n+          pParse->iErr = i+1;\n+          return -1;\n+        }\n+      }else{\n+        if( !sqlite3Isdigit(z[i+1]) ){\n+          \/* JSON5 allows for \"+Infinity\" and \"-Infinity\" using exactly\n+          ** that case.  SQLite also allows these in any case and it allows\n+          ** \"+inf\" and \"-inf\". *\/\n+          if( (z[i+1]=='I' || z[i+1]=='i')\n+           && sqlite3StrNICmp(&z[i+1], \"inf\",3)==0\n+          ){\n+            pParse->hasNonstd = 1;\n+            if( z[i]=='-' ){\n+              jsonBlobAppendNode(pParse, JSONB_FLOAT, 6, \"-9e999\");\n+            }else{\n+              jsonBlobAppendNode(pParse, JSONB_FLOAT, 5, \"9e999\");\n+            }\n+            return i + (sqlite3StrNICmp(&z[i+4],\"inity\",5)==0 ? 9 : 4);\n+          }\n+          if( z[i+1]=='.' ){\n+            pParse->hasNonstd = 1;\n+            t |= 0x01;\n+            goto parse_number_2;\n+          }\n+          pParse->iErr = i;\n+          return -1;\n+        }\n+        if( z[i+1]=='0' ){\n+          if( sqlite3Isdigit(z[i+2]) ){\n+            pParse->iErr = i+1;\n+            return -1;\n+          }else if( (z[i+2]=='x' || z[i+2]=='X') && sqlite3Isxdigit(z[i+3]) ){\n+            pParse->hasNonstd = 1;\n+            t |= 0x01;\n+            for(j=i+4; sqlite3Isxdigit(z[j]); j++){}\n+            goto parse_number_finish;\n+          }\n+        }\n+      }\n@@ -196321,2 +205227,3 @@\n-    j = i+1;\n-    for(;; j++){\n+\n+  parse_number_2:\n+    for(j=i+1;; j++){\n@@ -196324,1 +205231,1 @@\n-      if( c>='0' && c<='9' ) continue;\n+      if( sqlite3Isdigit(c) ) continue;\n@@ -196326,3 +205233,5 @@\n-        if( z[j-1]=='-' ) return -1;\n-        if( seenDP ) return -1;\n-        seenDP = 1;\n+        if( (t & 0x02)!=0 ){\n+          pParse->iErr = j;\n+          return -1;\n+        }\n+        t |= 0x02;\n@@ -196332,3 +205241,15 @@\n-        if( z[j-1]<'0' ) return -1;\n-        if( seenE ) return -1;\n-        seenDP = seenE = 1;\n+        if( z[j-1]<'0' ){\n+          if( ALWAYS(z[j-1]=='.') && ALWAYS(j-2>=i) && sqlite3Isdigit(z[j-2]) ){\n+            pParse->hasNonstd = 1;\n+            t |= 0x01;\n+          }else{\n+            pParse->iErr = j;\n+            return -1;\n+          }\n+        }\n+        if( seenE ){\n+          pParse->iErr = j;\n+          return -1;\n+        }\n+        t |= 0x02;\n+        seenE = 1;\n@@ -196340,1 +205261,4 @@\n-        if( c<'0' || c>'9' ) return -1;\n+        if( c<'0' || c>'9' ){\n+          pParse->iErr = j;\n+          return -1;\n+        }\n@@ -196345,3 +205269,15 @@\n-    if( z[j-1]<'0' ) return -1;\n-    jsonParseAddNode(pParse, seenDP ? JSON_REAL : JSON_INT,\n-                        j - i, &z[i]);\n+    if( z[j-1]<'0' ){\n+      if( ALWAYS(z[j-1]=='.') && ALWAYS(j-2>=i) && sqlite3Isdigit(z[j-2]) ){\n+        pParse->hasNonstd = 1;\n+        t |= 0x01;\n+      }else{\n+        pParse->iErr = j;\n+        return -1;\n+      }\n+    }\n+  parse_number_finish:\n+    assert( JSONB_INT+0x01==JSONB_INT5 );\n+    assert( JSONB_FLOAT+0x01==JSONB_FLOAT5 );\n+    assert( JSONB_INT+0x02==JSONB_FLOAT );\n+    if( z[i]=='+' ) i++;\n+    jsonBlobAppendNode(pParse, JSONB_INT+t, j-i, &z[i]);\n@@ -196349,1 +205285,3 @@\n-  }else if( c=='}' ){\n+  }\n+  case '}': {\n+    pParse->iErr = i;\n@@ -196351,1 +205289,3 @@\n-  }else if( c==']' ){\n+  }\n+  case ']': {\n+    pParse->iErr = i;\n@@ -196353,1 +205293,10 @@\n-  }else if( c==0 ){\n+  }\n+  case ',': {\n+    pParse->iErr = i;\n+    return -4;  \/* List separator *\/\n+  }\n+  case ':': {\n+    pParse->iErr = i;\n+    return -5;  \/* Object label\/value separator *\/\n+  }\n+  case 0: {\n@@ -196355,1 +205304,52 @@\n-  }else{\n+  }\n+  case 0x09:\n+  case 0x0a:\n+  case 0x0d:\n+  case 0x20: {\n+    i += 1 + (u32)strspn(&z[i+1], jsonSpaces);\n+    goto json_parse_restart;\n+  }\n+  case 0x0b:\n+  case 0x0c:\n+  case '\/':\n+  case 0xc2:\n+  case 0xe1:\n+  case 0xe2:\n+  case 0xe3:\n+  case 0xef: {\n+    j = json5Whitespace(&z[i]);\n+    if( j>0 ){\n+      i += j;\n+      pParse->hasNonstd = 1;\n+      goto json_parse_restart;\n+    }\n+    pParse->iErr = i;\n+    return -1;\n+  }\n+  case 'n': {\n+    if( strncmp(z+i,\"null\",4)==0 && !sqlite3Isalnum(z[i+4]) ){\n+      jsonBlobAppendOneByte(pParse, JSONB_NULL);\n+      return i+4;\n+    }\n+    \/* fall-through into the default case that checks for NaN *\/\n+  }\n+  default: {\n+    u32 k;\n+    int nn;\n+    c = z[i];\n+    for(k=0; k<sizeof(aNanInfName)\/sizeof(aNanInfName[0]); k++){\n+      if( c!=aNanInfName[k].c1 && c!=aNanInfName[k].c2 ) continue;\n+      nn = aNanInfName[k].n;\n+      if( sqlite3StrNICmp(&z[i], aNanInfName[k].zMatch, nn)!=0 ){\n+        continue;\n+      }\n+      if( sqlite3Isalnum(z[i+nn]) ) continue;\n+      if( aNanInfName[k].eType==JSONB_FLOAT ){\n+        jsonBlobAppendNode(pParse, JSONB_FLOAT, 5, \"9e999\");\n+      }else{\n+        jsonBlobAppendOneByte(pParse, JSONB_NULL);\n+      }\n+      pParse->hasNonstd = 1;\n+      return i + nn;\n+    }\n+    pParse->iErr = i;\n@@ -196358,0 +205358,1 @@\n+  } \/* End switch(z[i]) *\/\n@@ -196360,0 +205361,1 @@\n+\n@@ -196362,2 +205364,2 @@\n-** are any errors.  If an error occurs, free all memory associated with\n-** pParse.\n+** are any errors.  If an error occurs, free all memory held by pParse,\n+** but not pParse itself.\n@@ -196365,1 +205367,2 @@\n-** pParse is uninitialized when this routine is called.\n+** pParse must be initialized to an empty parse object prior to calling\n+** this routine.\n@@ -196367,1 +205370,1 @@\n-static int jsonParse(\n+static int jsonConvertTextToBlob(\n@@ -196369,2 +205372,1 @@\n-  sqlite3_context *pCtx,       \/* Report errors here *\/\n-  const char *zJson            \/* Input JSON text to be parsed *\/\n+  sqlite3_context *pCtx        \/* Report errors here *\/\n@@ -196373,4 +205375,2 @@\n-  memset(pParse, 0, sizeof(*pParse));\n-  if( zJson==0 ) return 1;\n-  pParse->zJson = zJson;\n-  i = jsonParseValue(pParse, 0);\n+  const char *zJson = pParse->zJson;\n+  i = jsonTranslateTextToBlob(pParse, 0);\n@@ -196379,0 +205379,1 @@\n+#ifdef SQLITE_DEBUG\n@@ -196380,2 +205381,14 @@\n-    while( fast_isspace(zJson[i]) ) i++;\n-    if( zJson[i] ) i = -1;\n+    if( sqlite3Config.bJsonSelfcheck ){\n+      assert( jsonbValidityCheck(pParse, 0, pParse->nBlob, 0)==0 );\n+    }\n+#endif\n+    while( jsonIsspace(zJson[i]) ) i++;\n+    if( zJson[i] ){\n+      i += json5Whitespace(&zJson[i]);\n+      if( zJson[i] ){\n+        if( pCtx ) sqlite3_result_error(pCtx, \"malformed JSON\", -1);\n+        jsonParseReset(pParse);\n+        return 1;\n+      }\n+      pParse->hasNonstd = 1;\n+    }\n@@ -196397,2 +205410,4 @@\n-\/* Mark node i of pParse as being a child of iParent.  Call recursively\n-** to fill in all the descendants of node i.\n+\/*\n+** The input string pStr is a well-formed JSON text string.  Convert\n+** this into the JSONB format and make it the return value of the\n+** SQL function.\n@@ -196400,8 +205415,151 @@\n-static void jsonParseFillInParentage(JsonParse *pParse, u32 i, u32 iParent){\n-  JsonNode *pNode = &pParse->aNode[i];\n-  u32 j;\n-  pParse->aUp[i] = iParent;\n-  switch( pNode->eType ){\n-    case JSON_ARRAY: {\n-      for(j=1; j<=pNode->n; j += jsonNodeSize(pNode+j)){\n-        jsonParseFillInParentage(pParse, i+j, i);\n+static void jsonReturnStringAsBlob(JsonString *pStr){\n+  JsonParse px;\n+  memset(&px, 0, sizeof(px));\n+  jsonStringTerminate(pStr);\n+  if( pStr->eErr ){\n+    sqlite3_result_error_nomem(pStr->pCtx);\n+    return;\n+  }\n+  px.zJson = pStr->zBuf;\n+  px.nJson = pStr->nUsed;\n+  px.db = sqlite3_context_db_handle(pStr->pCtx);\n+  (void)jsonTranslateTextToBlob(&px, 0);\n+  if( px.oom ){\n+    sqlite3DbFree(px.db, px.aBlob);\n+    sqlite3_result_error_nomem(pStr->pCtx);\n+  }else{\n+    assert( px.nBlobAlloc>0 );\n+    assert( !px.bReadOnly );\n+    sqlite3_result_blob(pStr->pCtx, px.aBlob, px.nBlob, SQLITE_DYNAMIC);\n+  }\n+}\n+\n+\/* The byte at index i is a node type-code.  This routine\n+** determines the payload size for that node and writes that\n+** payload size in to *pSz.  It returns the offset from i to the\n+** beginning of the payload.  Return 0 on error.\n+*\/\n+static u32 jsonbPayloadSize(const JsonParse *pParse, u32 i, u32 *pSz){\n+  u8 x;\n+  u32 sz;\n+  u32 n;\n+  if( NEVER(i>pParse->nBlob) ){\n+    *pSz = 0;\n+    return 0;\n+  }\n+  x = pParse->aBlob[i]>>4;\n+  if( x<=11 ){\n+    sz = x;\n+    n = 1;\n+  }else if( x==12 ){\n+    if( i+1>=pParse->nBlob ){\n+      *pSz = 0;\n+      return 0;\n+    }\n+    sz = pParse->aBlob[i+1];\n+    n = 2;\n+  }else if( x==13 ){\n+    if( i+2>=pParse->nBlob ){\n+      *pSz = 0;\n+      return 0;\n+    }\n+    sz = (pParse->aBlob[i+1]<<8) + pParse->aBlob[i+2];\n+    n = 3;\n+  }else if( x==14 ){\n+    if( i+4>=pParse->nBlob ){\n+      *pSz = 0;\n+      return 0;\n+    }\n+    sz = ((u32)pParse->aBlob[i+1]<<24) + (pParse->aBlob[i+2]<<16) +\n+         (pParse->aBlob[i+3]<<8) + pParse->aBlob[i+4];\n+    n = 5;\n+  }else{\n+    if( i+8>=pParse->nBlob\n+     || pParse->aBlob[i+1]!=0\n+     || pParse->aBlob[i+2]!=0\n+     || pParse->aBlob[i+3]!=0\n+     || pParse->aBlob[i+4]!=0\n+    ){\n+      *pSz = 0;\n+      return 0;\n+    }\n+    sz = (pParse->aBlob[i+5]<<24) + (pParse->aBlob[i+6]<<16) +\n+         (pParse->aBlob[i+7]<<8) + pParse->aBlob[i+8];\n+    n = 9;\n+  }\n+  if( (i64)i+sz+n > pParse->nBlob\n+   && (i64)i+sz+n > pParse->nBlob-pParse->delta\n+  ){\n+    sz = 0;\n+    n = 0;\n+  }\n+  *pSz = sz;\n+  return n;\n+}\n+\n+\n+\/*\n+** Translate the binary JSONB representation of JSON beginning at\n+** pParse->aBlob[i] into a JSON text string.  Append the JSON\n+** text onto the end of pOut.  Return the index in pParse->aBlob[]\n+** of the first byte past the end of the element that is translated.\n+**\n+** If an error is detected in the BLOB input, the pOut->eErr flag\n+** might get set to JSTRING_MALFORMED.  But not all BLOB input errors\n+** are detected.  So a malformed JSONB input might either result\n+** in an error, or in incorrect JSON.\n+**\n+** The pOut->eErr JSTRING_OOM flag is set on a OOM.\n+*\/\n+static u32 jsonTranslateBlobToText(\n+  const JsonParse *pParse,       \/* the complete parse of the JSON *\/\n+  u32 i,                         \/* Start rendering at this index *\/\n+  JsonString *pOut               \/* Write JSON here *\/\n+){\n+  u32 sz, n, j, iEnd;\n+\n+  n = jsonbPayloadSize(pParse, i, &sz);\n+  if( n==0 ){\n+    pOut->eErr |= JSTRING_MALFORMED;\n+    return pParse->nBlob+1;\n+  }\n+  switch( pParse->aBlob[i] & 0x0f ){\n+    case JSONB_NULL: {\n+      jsonAppendRawNZ(pOut, \"null\", 4);\n+      return i+1;\n+    }\n+    case JSONB_TRUE: {\n+      jsonAppendRawNZ(pOut, \"true\", 4);\n+      return i+1;\n+    }\n+    case JSONB_FALSE: {\n+      jsonAppendRawNZ(pOut, \"false\", 5);\n+      return i+1;\n+    }\n+    case JSONB_INT:\n+    case JSONB_FLOAT: {\n+      if( sz==0 ) goto malformed_jsonb;\n+      jsonAppendRaw(pOut, (const char*)&pParse->aBlob[i+n], sz);\n+      break;\n+    }\n+    case JSONB_INT5: {  \/* Integer literal in hexadecimal notation *\/\n+      u32 k = 2;\n+      sqlite3_uint64 u = 0;\n+      const char *zIn = (const char*)&pParse->aBlob[i+n];\n+      int bOverflow = 0;\n+      if( sz==0 ) goto malformed_jsonb;\n+      if( zIn[0]=='-' ){\n+        jsonAppendChar(pOut, '-');\n+        k++;\n+      }else if( zIn[0]=='+' ){\n+        k++;\n+      }\n+      for(; k<sz; k++){\n+        if( !sqlite3Isxdigit(zIn[k]) ){\n+          pOut->eErr |= JSTRING_MALFORMED;\n+          break;\n+        }else if( (u>>60)!=0 ){\n+          bOverflow = 1;\n+        }else{\n+          u = u*16 + sqlite3HexToInt(zIn[k]);\n+        }\n@@ -196409,0 +205567,1 @@\n+      jsonPrintf(100,pOut,bOverflow?\"9.0e999\":\"%llu\", u);\n@@ -196411,4 +205570,10 @@\n-    case JSON_OBJECT: {\n-      for(j=1; j<=pNode->n; j += jsonNodeSize(pNode+j+1)+1){\n-        pParse->aUp[i+j] = i;\n-        jsonParseFillInParentage(pParse, i+j+1, i);\n+    case JSONB_FLOAT5: { \/* Float literal missing digits beside \".\" *\/\n+      u32 k = 0;\n+      const char *zIn = (const char*)&pParse->aBlob[i+n];\n+      if( sz==0 ) goto malformed_jsonb;\n+      if( zIn[0]=='-' ){\n+        jsonAppendChar(pOut, '-');\n+        k++;\n+      }\n+      if( zIn[k]=='.' ){\n+        jsonAppendChar(pOut, '0');\n@@ -196416,0 +205581,13 @@\n+      for(; k<sz; k++){\n+        jsonAppendChar(pOut, zIn[k]);\n+        if( zIn[k]=='.' && (k+1==sz || !sqlite3Isdigit(zIn[k+1])) ){\n+          jsonAppendChar(pOut, '0');\n+        }\n+      }\n+      break;\n+    }\n+    case JSONB_TEXT:\n+    case JSONB_TEXTJ: {\n+      jsonAppendChar(pOut, '\"');\n+      jsonAppendRaw(pOut, (const char*)&pParse->aBlob[i+n], sz);\n+      jsonAppendChar(pOut, '\"');\n@@ -196418,0 +205596,115 @@\n+    case JSONB_TEXT5: {\n+      const char *zIn;\n+      u32 k;\n+      u32 sz2 = sz;\n+      zIn = (const char*)&pParse->aBlob[i+n];\n+      jsonAppendChar(pOut, '\"');\n+      while( sz2>0 ){\n+        for(k=0; k<sz2 && zIn[k]!='\\\\' && zIn[k]!='\"'; k++){}\n+        if( k>0 ){\n+          jsonAppendRawNZ(pOut, zIn, k);\n+          if( k>=sz2 ){\n+            break;\n+          }\n+          zIn += k;\n+          sz2 -= k;\n+        }\n+        if( zIn[0]=='\"' ){\n+          jsonAppendRawNZ(pOut, \"\\\\\\\"\", 2);\n+          zIn++;\n+          sz2--;\n+          continue;\n+        }\n+        assert( zIn[0]=='\\\\' );\n+        assert( sz2>=1 );\n+        if( sz2<2 ){\n+          pOut->eErr |= JSTRING_MALFORMED;\n+          break;\n+        }\n+        switch( (u8)zIn[1] ){\n+          case '\\'':\n+            jsonAppendChar(pOut, '\\'');\n+            break;\n+          case 'v':\n+            jsonAppendRawNZ(pOut, \"\\\\u0009\", 6);\n+            break;\n+          case 'x':\n+            if( sz2<4 ){\n+              pOut->eErr |= JSTRING_MALFORMED;\n+              sz2 = 2;\n+              break;\n+            }\n+            jsonAppendRawNZ(pOut, \"\\\\u00\", 4);\n+            jsonAppendRawNZ(pOut, &zIn[2], 2);\n+            zIn += 2;\n+            sz2 -= 2;\n+            break;\n+          case '0':\n+            jsonAppendRawNZ(pOut, \"\\\\u0000\", 6);\n+            break;\n+          case '\\r':\n+            if( sz2>2 && zIn[2]=='\\n' ){\n+              zIn++;\n+              sz2--;\n+            }\n+            break;\n+          case '\\n':\n+            break;\n+          case 0xe2:\n+            \/* '\\' followed by either U+2028 or U+2029 is ignored as\n+            ** whitespace.  Not that in UTF8, U+2028 is 0xe2 0x80 0x29.\n+            ** U+2029 is the same except for the last byte *\/\n+            if( sz2<4\n+             || 0x80!=(u8)zIn[2]\n+             || (0xa8!=(u8)zIn[3] && 0xa9!=(u8)zIn[3])\n+            ){\n+              pOut->eErr |= JSTRING_MALFORMED;\n+              sz2 = 2;\n+              break;\n+            }\n+            zIn += 2;\n+            sz2 -= 2;\n+            break;\n+          default:\n+            jsonAppendRawNZ(pOut, zIn, 2);\n+            break;\n+        }\n+        assert( sz2>=2 );\n+        zIn += 2;\n+        sz2 -= 2;\n+      }\n+      jsonAppendChar(pOut, '\"');\n+      break;\n+    }\n+    case JSONB_TEXTRAW: {\n+      jsonAppendString(pOut, (const char*)&pParse->aBlob[i+n], sz);\n+      break;\n+    }\n+    case JSONB_ARRAY: {\n+      jsonAppendChar(pOut, '[');\n+      j = i+n;\n+      iEnd = j+sz;\n+      while( j<iEnd && pOut->eErr==0 ){\n+        j = jsonTranslateBlobToText(pParse, j, pOut);\n+        jsonAppendChar(pOut, ',');\n+      }\n+      if( j>iEnd ) pOut->eErr |= JSTRING_MALFORMED;\n+      if( sz>0 ) jsonStringTrimOneChar(pOut);\n+      jsonAppendChar(pOut, ']');\n+      break;\n+    }\n+    case JSONB_OBJECT: {\n+      int x = 0;\n+      jsonAppendChar(pOut, '{');\n+      j = i+n;\n+      iEnd = j+sz;\n+      while( j<iEnd && pOut->eErr==0 ){\n+        j = jsonTranslateBlobToText(pParse, j, pOut);\n+        jsonAppendChar(pOut, (x++ & 1) ? ',' : ':');\n+      }\n+      if( (x & 1)!=0 || j>iEnd ) pOut->eErr |= JSTRING_MALFORMED;\n+      if( sz>0 ) jsonStringTrimOneChar(pOut);\n+      jsonAppendChar(pOut, '}');\n+      break;\n+    }\n+\n@@ -196419,0 +205712,2 @@\n+      malformed_jsonb:\n+      pOut->eErr |= JSTRING_MALFORMED;\n@@ -196422,0 +205717,27 @@\n+  return i+n+sz;\n+}\n+\n+\/* Return true if the input pJson\n+**\n+** For performance reasons, this routine does not do a detailed check of the\n+** input BLOB to ensure that it is well-formed.  Hence, false positives are\n+** possible.  False negatives should never occur, however.\n+*\/\n+static int jsonFuncArgMightBeBinary(sqlite3_value *pJson){\n+  u32 sz, n;\n+  const u8 *aBlob;\n+  int nBlob;\n+  JsonParse s;\n+  if( sqlite3_value_type(pJson)!=SQLITE_BLOB ) return 0;\n+  aBlob = sqlite3_value_blob(pJson);\n+  nBlob = sqlite3_value_bytes(pJson);\n+  if( nBlob<1 ) return 0;\n+  if( NEVER(aBlob==0) || (aBlob[0] & 0x0f)>JSONB_OBJECT ) return 0;\n+  memset(&s, 0, sizeof(s));\n+  s.aBlob = (u8*)aBlob;\n+  s.nBlob = nBlob;\n+  n = jsonbPayloadSize(&s, 0, &sz);\n+  if( n==0 ) return 0;\n+  if( sz+n!=(u32)nBlob ) return 0;\n+  if( (aBlob[0] & 0x0f)<=JSONB_FALSE && sz>0 ) return 0;\n+  return sz+n==(u32)nBlob;\n@@ -196425,1 +205747,2 @@\n-** Compute the parentage of all nodes in a completed parse.\n+** Given that a JSONB_ARRAY object starts at offset i, return\n+** the number of entries in that array.\n@@ -196427,7 +205750,7 @@\n-static int jsonParseFindParents(JsonParse *pParse){\n-  u32 *aUp;\n-  assert( pParse->aUp==0 );\n-  aUp = pParse->aUp = sqlite3_malloc64( sizeof(u32)*pParse->nNode );\n-  if( aUp==0 ){\n-    pParse->oom = 1;\n-    return SQLITE_NOMEM;\n+static u32 jsonbArrayCount(JsonParse *pParse, u32 iRoot){\n+  u32 n, sz, i, iEnd;\n+  u32 k = 0;\n+  n = jsonbPayloadSize(pParse, iRoot, &sz);\n+  iEnd = iRoot+n+sz;\n+  for(i=iRoot+n; n>0 && i<iEnd; i+=sz+n, k++){\n+    n = jsonbPayloadSize(pParse, i, &sz);\n@@ -196435,2 +205758,1 @@\n-  jsonParseFillInParentage(pParse, 0, 0);\n-  return SQLITE_OK;\n+  return k;\n@@ -196440,1 +205762,2 @@\n-** Magic number used for the JSON parse cache in sqlite3_get_auxdata()\n+** Edit the payload size of the element at iRoot by the amount in\n+** pParse->delta.\n@@ -196442,2 +205765,12 @@\n-#define JSON_CACHE_ID  (-429938)  \/* First cache entry *\/\n-#define JSON_CACHE_SZ  4          \/* Max number of cache entries *\/\n+static void jsonAfterEditSizeAdjust(JsonParse *pParse, u32 iRoot){\n+  u32 sz = 0;\n+  u32 nBlob;\n+  assert( pParse->delta!=0 );\n+  assert( pParse->nBlobAlloc >= pParse->nBlob );\n+  nBlob = pParse->nBlob;\n+  pParse->nBlob = pParse->nBlobAlloc;\n+  (void)jsonbPayloadSize(pParse, iRoot, &sz);\n+  pParse->nBlob = nBlob;\n+  sz += pParse->delta;\n+  pParse->delta += jsonBlobChangePayloadSize(pParse, iRoot, sz);\n+}\n@@ -196446,6 +205779,11 @@\n-** Obtain a complete parse of the JSON found in the first argument\n-** of the argv array.  Use the sqlite3_get_auxdata() cache for this\n-** parse if it is available.  If the cache is not available or if it\n-** is no longer valid, parse the JSON again and return the new parse,\n-** and also register the new parse so that it will be available for\n-** future sqlite3_get_auxdata() calls.\n+** Modify the JSONB blob at pParse->aBlob by removing nDel bytes of\n+** content beginning at iDel, and replacing them with nIns bytes of\n+** content given by aIns.\n+**\n+** nDel may be zero, in which case no bytes are removed.  But iDel is\n+** still important as new bytes will be insert beginning at iDel.\n+**\n+** aIns may be zero, in which case space is created to hold nIns bytes\n+** beginning at iDel, but that space is uninitialized.\n+**\n+** Set pParse->oom if an OOM occurs.\n@@ -196453,4 +205791,6 @@\n-static JsonParse *jsonParseCached(\n-  sqlite3_context *pCtx,\n-  sqlite3_value **argv,\n-  sqlite3_context *pErrCtx\n+static void jsonBlobEdit(\n+  JsonParse *pParse,     \/* The JSONB to be modified is in pParse->aBlob *\/\n+  u32 iDel,              \/* First byte to be removed *\/\n+  u32 nDel,              \/* Number of bytes to remove *\/\n+  const u8 *aIns,        \/* Content to insert *\/\n+  u32 nIns               \/* Bytes of content to insert *\/\n@@ -196458,14 +205798,5 @@\n-  const char *zJson = (const char*)sqlite3_value_text(argv[0]);\n-  int nJson = sqlite3_value_bytes(argv[0]);\n-  JsonParse *p;\n-  JsonParse *pMatch = 0;\n-  int iKey;\n-  int iMinKey = 0;\n-  u32 iMinHold = 0xffffffff;\n-  u32 iMaxHold = 0;\n-  if( zJson==0 ) return 0;\n-  for(iKey=0; iKey<JSON_CACHE_SZ; iKey++){\n-    p = (JsonParse*)sqlite3_get_auxdata(pCtx, JSON_CACHE_ID+iKey);\n-    if( p==0 ){\n-      iMinKey = iKey;\n-      break;\n+  i64 d = (i64)nIns - (i64)nDel;\n+  if( d!=0 ){\n+    if( pParse->nBlob + d > pParse->nBlobAlloc ){\n+      jsonBlobExpand(pParse, pParse->nBlob+d);\n+      if( pParse->oom ) return;\n@@ -196473,9 +205804,34 @@\n-    if( pMatch==0\n-     && p->nJson==nJson\n-     && memcmp(p->zJson,zJson,nJson)==0\n-    ){\n-      p->nErr = 0;\n-      pMatch = p;\n-    }else if( p->iHold<iMinHold ){\n-      iMinHold = p->iHold;\n-      iMinKey = iKey;\n+    memmove(&pParse->aBlob[iDel+nIns],\n+            &pParse->aBlob[iDel+nDel],\n+            pParse->nBlob - (iDel+nDel));\n+    pParse->nBlob += d;\n+    pParse->delta += d;\n+  }\n+  if( nIns && aIns ) memcpy(&pParse->aBlob[iDel], aIns, nIns);\n+}\n+\n+\/*\n+** Return the number of escaped newlines to be ignored.\n+** An escaped newline is a one of the following byte sequences:\n+**\n+**    0x5c 0x0a\n+**    0x5c 0x0d\n+**    0x5c 0x0d 0x0a\n+**    0x5c 0xe2 0x80 0xa8\n+**    0x5c 0xe2 0x80 0xa9\n+*\/\n+static u32 jsonBytesToBypass(const char *z, u32 n){\n+  u32 i = 0;\n+  while( i+1<n ){\n+    if( z[i]!='\\\\' ) return i;\n+    if( z[i+1]=='\\n' ){\n+      i += 2;\n+      continue;\n+    }\n+    if( z[i+1]=='\\r' ){\n+      if( i+2<n && z[i+2]=='\\n' ){\n+        i += 3;\n+      }else{\n+        i += 2;\n+      }\n+      continue;\n@@ -196483,2 +205839,7 @@\n-    if( p->iHold>iMaxHold ){\n-      iMaxHold = p->iHold;\n+    if( 0xe2==(u8)z[i+1]\n+     && i+3<n\n+     && 0x80==(u8)z[i+2]\n+     && (0xa8==(u8)z[i+3] || 0xa9==(u8)z[i+3])\n+    ){\n+      i += 4;\n+      continue;\n@@ -196486,0 +205847,1 @@\n+    break;\n@@ -196487,4 +205849,18 @@\n-  if( pMatch ){\n-    pMatch->nErr = 0;\n-    pMatch->iHold = iMaxHold+1;\n-    return pMatch;\n+  return i;\n+}\n+\n+\/*\n+** Input z[0..n] defines JSON escape sequence including the leading '\\\\'.\n+** Decode that escape sequence into a single character.  Write that\n+** character into *piOut.  Return the number of bytes in the escape sequence.\n+**\n+** If there is a syntax error of some kind (for example too few characters\n+** after the '\\\\' to complete the encoding) then *piOut is set to\n+** JSON_INVALID_CHAR.\n+*\/\n+static u32 jsonUnescapeOneChar(const char *z, u32 n, u32 *piOut){\n+  assert( n>0 );\n+  assert( z[0]=='\\\\' );\n+  if( n<2 ){\n+    *piOut = JSON_INVALID_CHAR;\n+    return n;\n@@ -196492,4 +205868,61 @@\n-  p = sqlite3_malloc64( sizeof(*p) + nJson + 1 );\n-  if( p==0 ){\n-    sqlite3_result_error_nomem(pCtx);\n-    return 0;\n+  switch( (u8)z[1] ){\n+    case 'u': {\n+      u32 v, vlo;\n+      if( n<6 ){\n+        *piOut = JSON_INVALID_CHAR;\n+        return n;\n+      }\n+      v = jsonHexToInt4(&z[2]);\n+      if( (v & 0xfc00)==0xd800\n+       && n>=12\n+       && z[6]=='\\\\'\n+       && z[7]=='u'\n+       && ((vlo = jsonHexToInt4(&z[8]))&0xfc00)==0xdc00\n+      ){\n+        *piOut = ((v&0x3ff)<<10) + (vlo&0x3ff) + 0x10000;\n+        return 12;\n+      }else{\n+        *piOut = v;\n+        return 6;\n+      }\n+    }\n+    case 'b': {   *piOut = '\\b';  return 2; }\n+    case 'f': {   *piOut = '\\f';  return 2; }\n+    case 'n': {   *piOut = '\\n';  return 2; }\n+    case 'r': {   *piOut = '\\r';  return 2; }\n+    case 't': {   *piOut = '\\t';  return 2; }\n+    case 'v': {   *piOut = '\\v';  return 2; }\n+    case '0': {   *piOut = 0;     return 2; }\n+    case '\\'':\n+    case '\"':\n+    case '\/':\n+    case '\\\\':{   *piOut = z[1];  return 2; }\n+    case 'x': {\n+      if( n<4 ){\n+        *piOut = JSON_INVALID_CHAR;\n+        return n;\n+      }\n+      *piOut = (jsonHexToInt(z[2])<<4) | jsonHexToInt(z[3]);\n+      return 4;\n+    }\n+    case 0xe2:\n+    case '\\r':\n+    case '\\n': {\n+      u32 nSkip = jsonBytesToBypass(z, n);\n+      if( nSkip==0 ){\n+        *piOut = JSON_INVALID_CHAR;\n+        return n;\n+      }else if( nSkip==n ){\n+        *piOut = 0;\n+        return n;\n+      }else if( z[nSkip]=='\\\\' ){\n+        return nSkip + jsonUnescapeOneChar(&z[nSkip], n-nSkip, piOut);\n+      }else{\n+        int sz = sqlite3Utf8ReadLimited((u8*)&z[nSkip], n-nSkip, piOut);\n+        return nSkip + sz;\n+      }\n+    }\n+    default: {\n+      *piOut = JSON_INVALID_CHAR;\n+      return 2;\n+    }\n@@ -196497,6 +205930,59 @@\n-  memset(p, 0, sizeof(*p));\n-  p->zJson = (char*)&p[1];\n-  memcpy((char*)p->zJson, zJson, nJson+1);\n-  if( jsonParse(p, pErrCtx, p->zJson) ){\n-    sqlite3_free(p);\n-    return 0;\n+}\n+\n+\n+\/*\n+** Compare two object labels.  Return 1 if they are equal and\n+** 0 if they differ.\n+**\n+** In this version, we know that one or the other or both of the\n+** two comparands contains an escape sequence.\n+*\/\n+static SQLITE_NOINLINE int jsonLabelCompareEscaped(\n+  const char *zLeft,          \/* The left label *\/\n+  u32 nLeft,                  \/* Size of the left label in bytes *\/\n+  int rawLeft,                \/* True if zLeft contains no escapes *\/\n+  const char *zRight,         \/* The right label *\/\n+  u32 nRight,                 \/* Size of the right label in bytes *\/\n+  int rawRight                \/* True if zRight is escape-free *\/\n+){\n+  u32 cLeft, cRight;\n+  assert( rawLeft==0 || rawRight==0 );\n+  while( 1 \/*exit-by-return*\/ ){\n+    if( nLeft==0 ){\n+      cLeft = 0;\n+    }else if( rawLeft || zLeft[0]!='\\\\' ){\n+      cLeft = ((u8*)zLeft)[0];\n+      if( cLeft>=0xc0 ){\n+        int sz = sqlite3Utf8ReadLimited((u8*)zLeft, nLeft, &cLeft);\n+        zLeft += sz;\n+        nLeft -= sz;\n+      }else{\n+        zLeft++;\n+        nLeft--;\n+      }\n+    }else{\n+      u32 n = jsonUnescapeOneChar(zLeft, nLeft, &cLeft);\n+      zLeft += n;\n+      assert( n<=nLeft );\n+      nLeft -= n;\n+    }\n+    if( nRight==0 ){\n+      cRight = 0;\n+    }else if( rawRight || zRight[0]!='\\\\' ){\n+      cRight = ((u8*)zRight)[0];\n+      if( cRight>=0xc0 ){\n+        int sz = sqlite3Utf8ReadLimited((u8*)zRight, nRight, &cRight);\n+        zRight += sz;\n+        nRight -= sz;\n+      }else{\n+        zRight++;\n+        nRight--;\n+      }\n+    }else{\n+      u32 n = jsonUnescapeOneChar(zRight, nRight, &cRight);\n+      zRight += n;\n+      assert( n<=nRight );\n+      nRight -= n;\n+    }\n+    if( cLeft!=cRight ) return 0;\n+    if( cLeft==0 ) return 1;\n@@ -196504,5 +205990,0 @@\n-  p->nJson = nJson;\n-  p->iHold = iMaxHold+1;\n-  sqlite3_set_auxdata(pCtx, JSON_CACHE_ID+iMinKey, p,\n-                      (void(*)(void*))jsonParseFree);\n-  return (JsonParse*)sqlite3_get_auxdata(pCtx, JSON_CACHE_ID+iMinKey);\n@@ -196512,2 +205993,2 @@\n-** Compare the OBJECT label at pNode against zKey,nKey.  Return true on\n-** a match.\n+** Compare two object labels.  Return 1 if they are equal and\n+** 0 if they differ.  Return -1 if an OOM occurs.\n@@ -196515,5 +205996,13 @@\n-static int jsonLabelCompare(JsonNode *pNode, const char *zKey, u32 nKey){\n-  assert( pNode->eU==1 );\n-  if( pNode->jnFlags & JNODE_RAW ){\n-    if( pNode->n!=nKey ) return 0;\n-    return strncmp(pNode->u.zJContent, zKey, nKey)==0;\n+static int jsonLabelCompare(\n+  const char *zLeft,          \/* The left label *\/\n+  u32 nLeft,                  \/* Size of the left label in bytes *\/\n+  int rawLeft,                \/* True if zLeft contains no escapes *\/\n+  const char *zRight,         \/* The right label *\/\n+  u32 nRight,                 \/* Size of the right label in bytes *\/\n+  int rawRight                \/* True if zRight is escape-free *\/\n+){\n+  if( rawLeft && rawRight ){\n+    \/* Simpliest case:  Neither label contains escapes.  A simple\n+    ** memcmp() is sufficient. *\/\n+    if( nLeft!=nRight ) return 0;\n+    return memcmp(zLeft, zRight, nLeft)==0;\n@@ -196521,2 +206010,2 @@\n-    if( pNode->n!=nKey+2 ) return 0;\n-    return strncmp(pNode->u.zJContent+1, zKey, nKey)==0;\n+    return jsonLabelCompareEscaped(zLeft, nLeft, rawLeft,\n+                                   zRight, nRight, rawRight);\n@@ -196526,2 +206015,57 @@\n-\/* forward declaration *\/\n-static JsonNode *jsonLookupAppend(JsonParse*,const char*,int*,const char**);\n+\/*\n+** Error returns from jsonLookupStep()\n+*\/\n+#define JSON_LOOKUP_ERROR      0xffffffff\n+#define JSON_LOOKUP_NOTFOUND   0xfffffffe\n+#define JSON_LOOKUP_PATHERROR  0xfffffffd\n+#define JSON_LOOKUP_ISERROR(x) ((x)>=JSON_LOOKUP_PATHERROR)\n+\n+\/* Forward declaration *\/\n+static u32 jsonLookupStep(JsonParse*,u32,const char*,u32);\n+\n+\n+\/* This helper routine for jsonLookupStep() populates pIns with\n+** binary data that is to be inserted into pParse.\n+**\n+** In the common case, pIns just points to pParse->aIns and pParse->nIns.\n+** But if the zPath of the original edit operation includes path elements\n+** that go deeper, additional substructure must be created.\n+**\n+** For example:\n+**\n+**     json_insert('{}', '$.a.b.c', 123);\n+**\n+** The search stops at '$.a'  But additional substructure must be\n+** created for the \".b.c\" part of the patch so that the final result\n+** is:  {\"a\":{\"b\":{\"c\"::123}}}.  This routine populates pIns with\n+** the binary equivalent of {\"b\":{\"c\":123}} so that it can be inserted.\n+**\n+** The caller is responsible for resetting pIns when it has finished\n+** using the substructure.\n+*\/\n+static u32 jsonCreateEditSubstructure(\n+  JsonParse *pParse,  \/* The original JSONB that is being edited *\/\n+  JsonParse *pIns,    \/* Populate this with the blob data to insert *\/\n+  const char *zTail   \/* Tail of the path that determins substructure *\/\n+){\n+  static const u8 emptyObject[] = { JSONB_ARRAY, JSONB_OBJECT };\n+  int rc;\n+  memset(pIns, 0, sizeof(*pIns));\n+  pIns->db = pParse->db;\n+  if( zTail[0]==0 ){\n+    \/* No substructure.  Just insert what is given in pParse. *\/\n+    pIns->aBlob = pParse->aIns;\n+    pIns->nBlob = pParse->nIns;\n+    rc = 0;\n+  }else{\n+    \/* Construct the binary substructure *\/\n+    pIns->nBlob = 1;\n+    pIns->aBlob = (u8*)&emptyObject[zTail[0]=='.'];\n+    pIns->eEdit = pParse->eEdit;\n+    pIns->nIns = pParse->nIns;\n+    pIns->aIns = pParse->aIns;\n+    rc = jsonLookupStep(pIns, 0, zTail, 0);\n+    pParse->oom |= pIns->oom;\n+  }\n+  return rc;  \/* Error code only *\/\n+}\n@@ -196530,3 +206074,6 @@\n-** Search along zPath to find the node specified.  Return a pointer\n-** to that node, or NULL if zPath is malformed or if there is no such\n-** node.\n+** Search along zPath to find the Json element specified.  Return an\n+** index into pParse->aBlob[] for the start of that element's value.\n+**\n+** If the value found by this routine is the value half of label\/value pair\n+** within an object, then set pPath->iLabel to the start of the corresponding\n+** label, before returning.\n@@ -196534,3 +206081,8 @@\n-** If pApnd!=0, then try to append new nodes to complete zPath if it is\n-** possible to do so and if no existing node corresponds to zPath.  If\n-** new nodes are appended *pApnd is set to 1.\n+** Return one of the JSON_LOOKUP error codes if problems are seen.\n+**\n+** This routine will also modify the blob.  If pParse->eEdit is one of\n+** JEDIT_DEL, JEDIT_REPL, JEDIT_INS, or JEDIT_SET, then changes might be\n+** made to the selected value.  If an edit is performed, then the return\n+** value does not necessarily point to the select element.  If an edit\n+** is performed, the return value is only useful for detecting error\n+** conditions.\n@@ -196538,1 +206090,1 @@\n-static JsonNode *jsonLookupStep(\n+static u32 jsonLookupStep(\n@@ -196540,1 +206092,1 @@\n-  u32 iRoot,              \/* Begin the search at this node *\/\n+  u32 iRoot,              \/* Begin the search at this element of aBlob[] *\/\n@@ -196542,2 +206094,1 @@\n-  int *pApnd,             \/* Append nodes to complete path if not NULL *\/\n-  const char **pzErr      \/* Make *pzErr point to any syntax error in zPath *\/\n+  u32 iLabel              \/* Label if iRoot is a value of in an object *\/\n@@ -196545,1 +206096,1 @@\n-  u32 i, j, nKey;\n+  u32 i, j, k, nKey, sz, n, iEnd, rc;\n@@ -196547,3 +206098,22 @@\n-  JsonNode *pRoot = &pParse->aNode[iRoot];\n-  if( zPath[0]==0 ) return pRoot;\n-  if( pRoot->jnFlags & JNODE_REPLACE ) return 0;\n+  u8 x;\n+\n+  if( zPath[0]==0 ){\n+    if( pParse->eEdit && jsonBlobMakeEditable(pParse, pParse->nIns) ){\n+      n = jsonbPayloadSize(pParse, iRoot, &sz);\n+      sz += n;\n+      if( pParse->eEdit==JEDIT_DEL ){\n+        if( iLabel>0 ){\n+          sz += iRoot - iLabel;\n+          iRoot = iLabel;\n+        }\n+        jsonBlobEdit(pParse, iRoot, sz, 0, 0);\n+      }else if( pParse->eEdit==JEDIT_INS ){\n+        \/* Already exists, so json_insert() is a no-op *\/\n+      }else{\n+        \/* json_set() or json_replace() *\/\n+        jsonBlobEdit(pParse, iRoot, sz, pParse->aIns, pParse->nIns);\n+      }\n+    }\n+    pParse->iLabel = iLabel;\n+    return iRoot;\n+  }\n@@ -196551,1 +206121,2 @@\n-    if( pRoot->eType!=JSON_OBJECT ) return 0;\n+    int rawKey = 1;\n+    x = pParse->aBlob[iRoot];\n@@ -196560,2 +206131,1 @@\n-        *pzErr = zPath;\n-        return 0;\n+        return JSON_LOOKUP_PATHERROR;\n@@ -196564,0 +206134,1 @@\n+      rawKey = memchr(zKey, '\\\\', nKey)==0;\n@@ -196569,12 +206140,27 @@\n-        *pzErr = zPath;\n-        return 0;\n-      }\n-    }\n-    j = 1;\n-    for(;;){\n-      while( j<=pRoot->n ){\n-        if( jsonLabelCompare(pRoot+j, zKey, nKey) ){\n-          return jsonLookupStep(pParse, iRoot+j+1, &zPath[i], pApnd, pzErr);\n-        }\n-        j++;\n-        j += jsonNodeSize(&pRoot[j]);\n+        return JSON_LOOKUP_PATHERROR;\n+      }\n+    }\n+    if( (x & 0x0f)!=JSONB_OBJECT ) return JSON_LOOKUP_NOTFOUND;\n+    n = jsonbPayloadSize(pParse, iRoot, &sz);\n+    j = iRoot + n;  \/* j is the index of a label *\/\n+    iEnd = j+sz;\n+    while( j<iEnd ){\n+      int rawLabel;\n+      const char *zLabel;\n+      x = pParse->aBlob[j] & 0x0f;\n+      if( x<JSONB_TEXT || x>JSONB_TEXTRAW ) return JSON_LOOKUP_ERROR;\n+      n = jsonbPayloadSize(pParse, j, &sz);\n+      if( n==0 ) return JSON_LOOKUP_ERROR;\n+      k = j+n;  \/* k is the index of the label text *\/\n+      if( k+sz>=iEnd ) return JSON_LOOKUP_ERROR;\n+      zLabel = (const char*)&pParse->aBlob[k];\n+      rawLabel = x==JSONB_TEXT || x==JSONB_TEXTRAW;\n+      if( jsonLabelCompare(zKey, nKey, rawKey, zLabel, sz, rawLabel) ){\n+        u32 v = k+sz;  \/* v is the index of the value *\/\n+        if( ((pParse->aBlob[v])&0x0f)>JSONB_OBJECT ) return JSON_LOOKUP_ERROR;\n+        n = jsonbPayloadSize(pParse, v, &sz);\n+        if( n==0 || v+n+sz>iEnd ) return JSON_LOOKUP_ERROR;\n+        assert( j>0 );\n+        rc = jsonLookupStep(pParse, v, &zPath[i], j);\n+        if( pParse->delta ) jsonAfterEditSizeAdjust(pParse, iRoot);\n+        return rc;\n@@ -196582,23 +206168,38 @@\n-      if( (pRoot->jnFlags & JNODE_APPEND)==0 ) break;\n-      assert( pRoot->eU==2 );\n-      iRoot += pRoot->u.iAppend;\n-      pRoot = &pParse->aNode[iRoot];\n-      j = 1;\n-    }\n-    if( pApnd ){\n-      u32 iStart, iLabel;\n-      JsonNode *pNode;\n-      iStart = jsonParseAddNode(pParse, JSON_OBJECT, 2, 0);\n-      iLabel = jsonParseAddNode(pParse, JSON_STRING, nKey, zKey);\n-      zPath += i;\n-      pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);\n-      if( pParse->oom ) return 0;\n-      if( pNode ){\n-        pRoot = &pParse->aNode[iRoot];\n-        assert( pRoot->eU==0 );\n-        pRoot->u.iAppend = iStart - iRoot;\n-        pRoot->jnFlags |= JNODE_APPEND;\n-        VVA( pRoot->eU = 2 );\n-        pParse->aNode[iLabel].jnFlags |= JNODE_RAW;\n-      }\n-      return pNode;\n+      j = k+sz;\n+      if( ((pParse->aBlob[j])&0x0f)>JSONB_OBJECT ) return JSON_LOOKUP_ERROR;\n+      n = jsonbPayloadSize(pParse, j, &sz);\n+      if( n==0 ) return JSON_LOOKUP_ERROR;\n+      j += n+sz;\n+    }\n+    if( j>iEnd ) return JSON_LOOKUP_ERROR;\n+    if( pParse->eEdit>=JEDIT_INS ){\n+      u32 nIns;          \/* Total bytes to insert (label+value) *\/\n+      JsonParse v;       \/* BLOB encoding of the value to be inserted *\/\n+      JsonParse ix;      \/* Header of the label to be inserted *\/\n+      testcase( pParse->eEdit==JEDIT_INS );\n+      testcase( pParse->eEdit==JEDIT_SET );\n+      memset(&ix, 0, sizeof(ix));\n+      ix.db = pParse->db;\n+      jsonBlobAppendNode(&ix, rawKey?JSONB_TEXTRAW:JSONB_TEXT5, nKey, 0);\n+      pParse->oom |= ix.oom;\n+      rc = jsonCreateEditSubstructure(pParse, &v, &zPath[i]);\n+      if( !JSON_LOOKUP_ISERROR(rc)\n+       && jsonBlobMakeEditable(pParse, ix.nBlob+nKey+v.nBlob)\n+      ){\n+        assert( !pParse->oom );\n+        nIns = ix.nBlob + nKey + v.nBlob;\n+        jsonBlobEdit(pParse, j, 0, 0, nIns);\n+        if( !pParse->oom ){\n+          assert( pParse->aBlob!=0 ); \/* Because pParse->oom!=0 *\/\n+          assert( ix.aBlob!=0 );      \/* Because pPasre->oom!=0 *\/\n+          memcpy(&pParse->aBlob[j], ix.aBlob, ix.nBlob);\n+          k = j + ix.nBlob;\n+          memcpy(&pParse->aBlob[k], zKey, nKey);\n+          k += nKey;\n+          memcpy(&pParse->aBlob[k], v.aBlob, v.nBlob);\n+          if( ALWAYS(pParse->delta) ) jsonAfterEditSizeAdjust(pParse, iRoot);\n+        }\n+      }\n+      jsonParseReset(&v);\n+      jsonParseReset(&ix);\n+      return rc;\n@@ -196607,5 +206208,8 @@\n-    i = 0;\n-    j = 1;\n-    while( sqlite3Isdigit(zPath[j]) ){\n-      i = i*10 + zPath[j] - '0';\n-      j++;\n+    x = pParse->aBlob[iRoot] & 0x0f;\n+    if( x!=JSONB_ARRAY )  return JSON_LOOKUP_NOTFOUND;\n+    n = jsonbPayloadSize(pParse, iRoot, &sz);\n+    k = 0;\n+    i = 1;\n+    while( sqlite3Isdigit(zPath[i]) ){\n+      k = k*10 + zPath[i] - '0';\n+      i++;\n@@ -196613,1 +206217,1 @@\n-    if( j<2 || zPath[j]!=']' ){\n+    if( i<2 || zPath[i]!=']' ){\n@@ -196615,15 +206219,2 @@\n-        JsonNode *pBase = pRoot;\n-        int iBase = iRoot;\n-        if( pRoot->eType!=JSON_ARRAY ) return 0;\n-        for(;;){\n-          while( j<=pBase->n ){\n-            if( (pBase[j].jnFlags & JNODE_REMOVE)==0 ) i++;\n-            j += jsonNodeSize(&pBase[j]);\n-          }\n-          if( (pBase->jnFlags & JNODE_APPEND)==0 ) break;\n-          assert( pBase->eU==2 );\n-          iBase += pBase->u.iAppend;\n-          pBase = &pParse->aNode[iBase];\n-          j = 1;\n-        }\n-        j = 2;\n+        k = jsonbArrayCount(pParse, iRoot);\n+        i = 2;\n@@ -196631,2 +206222,2 @@\n-          unsigned int x = 0;\n-          j = 3;\n+          unsigned int nn = 0;\n+          i = 3;\n@@ -196634,5 +206225,5 @@\n-            x = x*10 + zPath[j] - '0';\n-            j++;\n-          }while( sqlite3Isdigit(zPath[j]) );\n-          if( x>i ) return 0;\n-          i -= x;\n+            nn = nn*10 + zPath[i] - '0';\n+            i++;\n+          }while( sqlite3Isdigit(zPath[i]) );\n+          if( nn>k ) return JSON_LOOKUP_NOTFOUND;\n+          k -= nn;\n@@ -196640,3 +206231,2 @@\n-        if( zPath[j]!=']' ){\n-          *pzErr = zPath;\n-          return 0;\n+        if( zPath[i]!=']' ){\n+          return JSON_LOOKUP_PATHERROR;\n@@ -196645,2 +206235,1 @@\n-        *pzErr = zPath;\n-        return 0;\n+        return JSON_LOOKUP_PATHERROR;\n@@ -196649,29 +206238,7 @@\n-    if( pRoot->eType!=JSON_ARRAY ) return 0;\n-    zPath += j + 1;\n-    j = 1;\n-    for(;;){\n-      while( j<=pRoot->n && (i>0 || (pRoot[j].jnFlags & JNODE_REMOVE)!=0) ){\n-        if( (pRoot[j].jnFlags & JNODE_REMOVE)==0 ) i--;\n-        j += jsonNodeSize(&pRoot[j]);\n-      }\n-      if( (pRoot->jnFlags & JNODE_APPEND)==0 ) break;\n-      assert( pRoot->eU==2 );\n-      iRoot += pRoot->u.iAppend;\n-      pRoot = &pParse->aNode[iRoot];\n-      j = 1;\n-    }\n-    if( j<=pRoot->n ){\n-      return jsonLookupStep(pParse, iRoot+j, zPath, pApnd, pzErr);\n-    }\n-    if( i==0 && pApnd ){\n-      u32 iStart;\n-      JsonNode *pNode;\n-      iStart = jsonParseAddNode(pParse, JSON_ARRAY, 1, 0);\n-      pNode = jsonLookupAppend(pParse, zPath, pApnd, pzErr);\n-      if( pParse->oom ) return 0;\n-      if( pNode ){\n-        pRoot = &pParse->aNode[iRoot];\n-        assert( pRoot->eU==0 );\n-        pRoot->u.iAppend = iStart - iRoot;\n-        pRoot->jnFlags |= JNODE_APPEND;\n-        VVA( pRoot->eU = 2 );\n+    j = iRoot+n;\n+    iEnd = j+sz;\n+    while( j<iEnd ){\n+      if( k==0 ){\n+        rc = jsonLookupStep(pParse, j, &zPath[i+1], 0);\n+        if( pParse->delta ) jsonAfterEditSizeAdjust(pParse, iRoot);\n+        return rc;\n@@ -196679,1 +206246,21 @@\n-      return pNode;\n+      k--;\n+      n = jsonbPayloadSize(pParse, j, &sz);\n+      if( n==0 ) return JSON_LOOKUP_ERROR;\n+      j += n+sz;\n+    }\n+    if( j>iEnd ) return JSON_LOOKUP_ERROR;\n+    if( k>0 ) return JSON_LOOKUP_NOTFOUND;\n+    if( pParse->eEdit>=JEDIT_INS ){\n+      JsonParse v;\n+      testcase( pParse->eEdit==JEDIT_INS );\n+      testcase( pParse->eEdit==JEDIT_SET );\n+      rc = jsonCreateEditSubstructure(pParse, &v, &zPath[i+1]);\n+      if( !JSON_LOOKUP_ISERROR(rc)\n+       && jsonBlobMakeEditable(pParse, v.nBlob)\n+      ){\n+        assert( !pParse->oom );\n+        jsonBlobEdit(pParse, j, 0, v.aBlob, v.nBlob);\n+      }\n+      jsonParseReset(&v);\n+      if( pParse->delta ) jsonAfterEditSizeAdjust(pParse, iRoot);\n+      return rc;\n@@ -196682,1 +206269,1 @@\n-    *pzErr = zPath;\n+    return JSON_LOOKUP_PATHERROR;\n@@ -196684,1 +206271,1 @@\n-  return 0;\n+  return JSON_LOOKUP_NOTFOUND;\n@@ -196688,2 +206275,2 @@\n-** Append content to pParse that will complete zPath.  Return a pointer\n-** to the inserted node, or return NULL if the append fails.\n+** Convert a JSON BLOB into text and make that text the return value\n+** of an SQL function.\n@@ -196691,5 +206278,4 @@\n-static JsonNode *jsonLookupAppend(\n-  JsonParse *pParse,     \/* Append content to the JSON parse *\/\n-  const char *zPath,     \/* Description of content to append *\/\n-  int *pApnd,            \/* Set this flag to 1 *\/\n-  const char **pzErr     \/* Make this point to any syntax error *\/\n+static void jsonReturnTextJsonFromBlob(\n+  sqlite3_context *ctx,\n+  const u8 *aBlob,\n+  u32 nBlob\n@@ -196697,14 +206283,10 @@\n-  *pApnd = 1;\n-  if( zPath[0]==0 ){\n-    jsonParseAddNode(pParse, JSON_NULL, 0, 0);\n-    return pParse->oom ? 0 : &pParse->aNode[pParse->nNode-1];\n-  }\n-  if( zPath[0]=='.' ){\n-    jsonParseAddNode(pParse, JSON_OBJECT, 0, 0);\n-  }else if( strncmp(zPath,\"[0]\",3)==0 ){\n-    jsonParseAddNode(pParse, JSON_ARRAY, 0, 0);\n-  }else{\n-    return 0;\n-  }\n-  if( pParse->oom ) return 0;\n-  return jsonLookupStep(pParse, pParse->nNode-1, zPath, pApnd, pzErr);\n+  JsonParse x;\n+  JsonString s;\n+\n+  if( NEVER(aBlob==0) ) return;\n+  memset(&x, 0, sizeof(x));\n+  x.aBlob = (u8*)aBlob;\n+  x.nBlob = nBlob;\n+  jsonStringInit(&s, ctx);\n+  jsonTranslateBlobToText(&x, 0, &s);\n+  jsonReturnString(&s, 0, 0);\n@@ -196713,0 +206295,1 @@\n+\n@@ -196714,2 +206297,6 @@\n-** Return the text of a syntax error message on a JSON path.  Space is\n-** obtained from sqlite3_malloc().\n+** Return the value of the BLOB node at index i.\n+**\n+** If the value is a primitive, return it as an SQL value.\n+** If the value is an array or object, return it as either\n+** JSON text or the BLOB encoding, depending on the JSON_B flag\n+** on the userdata.\n@@ -196717,2 +206304,149 @@\n-static char *jsonPathSyntaxError(const char *zErr){\n-  return sqlite3_mprintf(\"JSON path error near '%q'\", zErr);\n+static void jsonReturnFromBlob(\n+  JsonParse *pParse,          \/* Complete JSON parse tree *\/\n+  u32 i,                      \/* Index of the node *\/\n+  sqlite3_context *pCtx,      \/* Return value for this function *\/\n+  int textOnly                \/* return text JSON.  Disregard user-data *\/\n+){\n+  u32 n, sz;\n+  int rc;\n+  sqlite3 *db = sqlite3_context_db_handle(pCtx);\n+\n+  n = jsonbPayloadSize(pParse, i, &sz);\n+  if( n==0 ){\n+    sqlite3_result_error(pCtx, \"malformed JSON\", -1);\n+    return;\n+  }\n+  switch( pParse->aBlob[i] & 0x0f ){\n+    case JSONB_NULL: {\n+      if( sz ) goto returnfromblob_malformed;\n+      sqlite3_result_null(pCtx);\n+      break;\n+    }\n+    case JSONB_TRUE: {\n+      if( sz ) goto returnfromblob_malformed;\n+      sqlite3_result_int(pCtx, 1);\n+      break;\n+    }\n+    case JSONB_FALSE: {\n+      if( sz ) goto returnfromblob_malformed;\n+      sqlite3_result_int(pCtx, 0);\n+      break;\n+    }\n+    case JSONB_INT5:\n+    case JSONB_INT: {\n+      sqlite3_int64 iRes = 0;\n+      char *z;\n+      int bNeg = 0;\n+      char x;\n+      if( sz==0 ) goto returnfromblob_malformed;\n+      x = (char)pParse->aBlob[i+n];\n+      if( x=='-' ){\n+        if( sz<2 ) goto returnfromblob_malformed;\n+        n++;\n+        sz--;\n+        bNeg = 1;\n+      }\n+      z = sqlite3DbStrNDup(db, (const char*)&pParse->aBlob[i+n], (int)sz);\n+      if( z==0 ) goto returnfromblob_oom;\n+      rc = sqlite3DecOrHexToI64(z, &iRes);\n+      sqlite3DbFree(db, z);\n+      if( rc==0 ){\n+        sqlite3_result_int64(pCtx, bNeg ? -iRes : iRes);\n+      }else if( rc==3 && bNeg ){\n+        sqlite3_result_int64(pCtx, SMALLEST_INT64);\n+      }else if( rc==1 ){\n+        goto returnfromblob_malformed;\n+      }else{\n+        if( bNeg ){ n--; sz++; }\n+        goto to_double;\n+      }\n+      break;\n+    }\n+    case JSONB_FLOAT5:\n+    case JSONB_FLOAT: {\n+      double r;\n+      char *z;\n+      if( sz==0 ) goto returnfromblob_malformed;\n+    to_double:\n+      z = sqlite3DbStrNDup(db, (const char*)&pParse->aBlob[i+n], (int)sz);\n+      if( z==0 ) goto returnfromblob_oom;\n+      rc = sqlite3AtoF(z, &r, sqlite3Strlen30(z), SQLITE_UTF8);\n+      sqlite3DbFree(db, z);\n+      if( rc<=0 ) goto returnfromblob_malformed;\n+      sqlite3_result_double(pCtx, r);\n+      break;\n+    }\n+    case JSONB_TEXTRAW:\n+    case JSONB_TEXT: {\n+      sqlite3_result_text(pCtx, (char*)&pParse->aBlob[i+n], sz,\n+                          SQLITE_TRANSIENT);\n+      break;\n+    }\n+    case JSONB_TEXT5:\n+    case JSONB_TEXTJ: {\n+      \/* Translate JSON formatted string into raw text *\/\n+      u32 iIn, iOut;\n+      const char *z;\n+      char *zOut;\n+      u32 nOut = sz;\n+      z = (const char*)&pParse->aBlob[i+n];\n+      zOut = sqlite3DbMallocRaw(db, nOut+1);\n+      if( zOut==0 ) goto returnfromblob_oom;\n+      for(iIn=iOut=0; iIn<sz; iIn++){\n+        char c = z[iIn];\n+        if( c=='\\\\' ){\n+          u32 v;\n+          u32 szEscape = jsonUnescapeOneChar(&z[iIn], sz-iIn, &v);\n+          if( v<=0x7f ){\n+            zOut[iOut++] = (char)v;\n+          }else if( v<=0x7ff ){\n+            assert( szEscape>=2 );\n+            zOut[iOut++] = (char)(0xc0 | (v>>6));\n+            zOut[iOut++] = 0x80 | (v&0x3f);\n+          }else if( v<0x10000 ){\n+            assert( szEscape>=3 );\n+            zOut[iOut++] = 0xe0 | (v>>12);\n+            zOut[iOut++] = 0x80 | ((v>>6)&0x3f);\n+            zOut[iOut++] = 0x80 | (v&0x3f);\n+          }else if( v==JSON_INVALID_CHAR ){\n+            \/* Silently ignore illegal unicode *\/\n+          }else{\n+            assert( szEscape>=4 );\n+            zOut[iOut++] = 0xf0 | (v>>18);\n+            zOut[iOut++] = 0x80 | ((v>>12)&0x3f);\n+            zOut[iOut++] = 0x80 | ((v>>6)&0x3f);\n+            zOut[iOut++] = 0x80 | (v&0x3f);\n+          }\n+          iIn += szEscape - 1;\n+        }else{\n+          zOut[iOut++] = c;\n+        }\n+      } \/* end for() *\/\n+      assert( iOut<=nOut );\n+      zOut[iOut] = 0;\n+      sqlite3_result_text(pCtx, zOut, iOut, SQLITE_DYNAMIC);\n+      break;\n+    }\n+    case JSONB_ARRAY:\n+    case JSONB_OBJECT: {\n+      int flags = textOnly ? 0 : SQLITE_PTR_TO_INT(sqlite3_user_data(pCtx));\n+      if( flags & JSON_BLOB ){\n+        sqlite3_result_blob(pCtx, &pParse->aBlob[i], sz+n, SQLITE_TRANSIENT);\n+      }else{\n+        jsonReturnTextJsonFromBlob(pCtx, &pParse->aBlob[i], sz+n);\n+      }\n+      break;\n+    }\n+    default: {\n+      goto returnfromblob_malformed;\n+    }\n+  }\n+  return;\n+\n+returnfromblob_oom:\n+  sqlite3_result_error_nomem(pCtx);\n+  return;\n+\n+returnfromblob_malformed:\n+  sqlite3_result_error(pCtx, \"malformed JSON\", -1);\n+  return;\n@@ -196722,2 +206456,3 @@\n-** Do a node lookup using zPath.  Return a pointer to the node on success.\n-** Return NULL if not found or if there is an error.\n+** pArg is a function argument that might be an SQL value or a JSON\n+** value.  Figure out what it is and encode it as a JSONB blob.\n+** Return the results in pParse.\n@@ -196725,2 +206460,7 @@\n-** On an error, write an error message into pCtx and increment the\n-** pParse->nErr counter.\n+** pParse is uninitialized upon entry.  This routine will handle the\n+** initialization of pParse.  The result will be contained in\n+** pParse->aBlob and pParse->nBlob.  pParse->aBlob might be dynamically\n+** allocated (if pParse->nBlobAlloc is greater than zero) in which case\n+** the caller is responsible for freeing the space allocated to pParse->aBlob\n+** when it has finished with it.  Or pParse->aBlob might be a static string\n+** or a value obtained from sqlite3_value_blob(pArg).\n@@ -196728,2 +206468,3 @@\n-** If pApnd!=NULL then try to append missing nodes and set *pApnd = 1 if\n-** nodes are appended.\n+** If the argument is a BLOB that is clearly not a JSONB, then this\n+** function might set an error message in ctx and return non-zero.\n+** It might also set an error message and return non-zero on an OOM error.\n@@ -196731,14 +206472,74 @@\n-static JsonNode *jsonLookup(\n-  JsonParse *pParse,      \/* The JSON to search *\/\n-  const char *zPath,      \/* The path to search *\/\n-  int *pApnd,             \/* Append nodes to complete path if not NULL *\/\n-  sqlite3_context *pCtx   \/* Report errors here, if not NULL *\/\n-){\n-  const char *zErr = 0;\n-  JsonNode *pNode = 0;\n-  char *zMsg;\n-\n-  if( zPath==0 ) return 0;\n-  if( zPath[0]!='$' ){\n-    zErr = zPath;\n-    goto lookup_err;\n+static int jsonFunctionArgToBlob(\n+  sqlite3_context *ctx,\n+  sqlite3_value *pArg,\n+  JsonParse *pParse\n+){\n+  int eType = sqlite3_value_type(pArg);\n+  static u8 aNull[] = { 0x00 };\n+  memset(pParse, 0, sizeof(pParse[0]));\n+  pParse->db = sqlite3_context_db_handle(ctx);\n+  switch( eType ){\n+    default: {\n+      pParse->aBlob = aNull;\n+      pParse->nBlob = 1;\n+      return 0;\n+    }\n+    case SQLITE_BLOB: {\n+      if( jsonFuncArgMightBeBinary(pArg) ){\n+        pParse->aBlob = (u8*)sqlite3_value_blob(pArg);\n+        pParse->nBlob = sqlite3_value_bytes(pArg);\n+      }else{\n+        sqlite3_result_error(ctx, \"JSON cannot hold BLOB values\", -1);\n+        return 1;\n+      }\n+      break;\n+    }\n+    case SQLITE_TEXT: {\n+      const char *zJson = (const char*)sqlite3_value_text(pArg);\n+      int nJson = sqlite3_value_bytes(pArg);\n+      if( zJson==0 ) return 1;\n+      if( sqlite3_value_subtype(pArg)==JSON_SUBTYPE ){\n+        pParse->zJson = (char*)zJson;\n+        pParse->nJson = nJson;\n+        if( jsonConvertTextToBlob(pParse, ctx) ){\n+          sqlite3_result_error(ctx, \"malformed JSON\", -1);\n+          sqlite3DbFree(pParse->db, pParse->aBlob);\n+          memset(pParse, 0, sizeof(pParse[0]));\n+          return 1;\n+        }\n+      }else{\n+        jsonBlobAppendNode(pParse, JSONB_TEXTRAW, nJson, zJson);\n+      }\n+      break;\n+    }\n+    case SQLITE_FLOAT: {\n+      double r = sqlite3_value_double(pArg);\n+      if( NEVER(sqlite3IsNaN(r)) ){\n+        jsonBlobAppendNode(pParse, JSONB_NULL, 0, 0);\n+      }else{\n+        int n = sqlite3_value_bytes(pArg);\n+        const char *z = (const char*)sqlite3_value_text(pArg);\n+        if( z==0 ) return 1;\n+        if( z[0]=='I' ){\n+          jsonBlobAppendNode(pParse, JSONB_FLOAT, 5, \"9e999\");\n+        }else if( z[0]=='-' && z[1]=='I' ){\n+          jsonBlobAppendNode(pParse, JSONB_FLOAT, 6, \"-9e999\");\n+        }else{\n+          jsonBlobAppendNode(pParse, JSONB_FLOAT, n, z);\n+        }\n+      }\n+      break;\n+    }\n+    case SQLITE_INTEGER: {\n+      int n = sqlite3_value_bytes(pArg);\n+      const char *z = (const char*)sqlite3_value_text(pArg);\n+      if( z==0 ) return 1;\n+      jsonBlobAppendNode(pParse, JSONB_INT, n, z);\n+      break;\n+    }\n+  }\n+  if( pParse->oom ){\n+    sqlite3_result_error_nomem(ctx);\n+    return 1;\n+  }else{\n+    return 0;\n@@ -196746,3 +206547,1 @@\n-  zPath++;\n-  pNode = jsonLookupStep(pParse, 0, zPath, pApnd, &zErr);\n-  if( zErr==0 ) return pNode;\n+}\n@@ -196750,4 +206549,12 @@\n-lookup_err:\n-  pParse->nErr++;\n-  assert( zErr!=0 && pCtx!=0 );\n-  zMsg = jsonPathSyntaxError(zErr);\n+\/*\n+** Generate a bad path error.\n+**\n+** If ctx is not NULL then push the error message into ctx and return NULL.\n+** If ctx is NULL, then return the text of the error message.\n+*\/\n+static char *jsonBadPathError(\n+  sqlite3_context *ctx,     \/* The function call containing the error *\/\n+  const char *zPath         \/* The path with the problem *\/\n+){\n+  char *zMsg = sqlite3_mprintf(\"bad JSON path: %Q\", zPath);\n+  if( ctx==0 ) return zMsg;\n@@ -196755,1 +206562,1 @@\n-    sqlite3_result_error(pCtx, zMsg, -1);\n+    sqlite3_result_error(ctx, zMsg, -1);\n@@ -196758,1 +206565,1 @@\n-    sqlite3_result_error_nomem(pCtx);\n+    sqlite3_result_error_nomem(ctx);\n@@ -196763,0 +206570,68 @@\n+\/* argv[0] is a BLOB that seems likely to be a JSONB.  Subsequent\n+** arguments come in parse where each pair contains a JSON path and\n+** content to insert or set at that patch.  Do the updates\n+** and return the result.\n+**\n+** The specific operation is determined by eEdit, which can be one\n+** of JEDIT_INS, JEDIT_REPL, or JEDIT_SET.\n+*\/\n+static void jsonInsertIntoBlob(\n+  sqlite3_context *ctx,\n+  int argc,\n+  sqlite3_value **argv,\n+  int eEdit                \/* JEDIT_INS, JEDIT_REPL, or JEDIT_SET *\/\n+){\n+  int i;\n+  u32 rc = 0;\n+  const char *zPath = 0;\n+  int flgs;\n+  JsonParse *p;\n+  JsonParse ax;\n+\n+  assert( (argc&1)==1 );\n+  flgs = argc==1 ? 0 : JSON_EDITABLE;\n+  p = jsonParseFuncArg(ctx, argv[0], flgs);\n+  if( p==0 ) return;\n+  for(i=1; i<argc-1; i+=2){\n+    if( sqlite3_value_type(argv[i])==SQLITE_NULL ) continue;\n+    zPath = (const char*)sqlite3_value_text(argv[i]);\n+    if( zPath==0 ){\n+      sqlite3_result_error_nomem(ctx);\n+      jsonParseFree(p);\n+      return;\n+    }\n+    if( zPath[0]!='$' ) goto jsonInsertIntoBlob_patherror;\n+    if( jsonFunctionArgToBlob(ctx, argv[i+1], &ax) ){\n+      jsonParseReset(&ax);\n+      jsonParseFree(p);\n+      return;\n+    }\n+    if( zPath[1]==0 ){\n+      if( eEdit==JEDIT_REPL || eEdit==JEDIT_SET ){\n+        jsonBlobEdit(p, 0, p->nBlob, ax.aBlob, ax.nBlob);\n+      }\n+      rc = 0;\n+   }else{\n+      p->eEdit = eEdit;\n+      p->nIns = ax.nBlob;\n+      p->aIns = ax.aBlob;\n+      p->delta = 0;\n+      rc = jsonLookupStep(p, 0, zPath+1, 0);\n+    }\n+    jsonParseReset(&ax);\n+    if( rc==JSON_LOOKUP_NOTFOUND ) continue;\n+    if( JSON_LOOKUP_ISERROR(rc) ) goto jsonInsertIntoBlob_patherror;\n+  }\n+  jsonReturnParse(ctx, p);\n+  jsonParseFree(p);\n+  return;\n+\n+jsonInsertIntoBlob_patherror:\n+  jsonParseFree(p);\n+  if( rc==JSON_LOOKUP_ERROR ){\n+    sqlite3_result_error(ctx, \"malformed JSON\", -1);\n+  }else{\n+    jsonBadPathError(ctx, zPath);\n+  }\n+  return;\n+}\n@@ -196765,2 +206640,7 @@\n-** Report the wrong number of arguments for json_insert(), json_replace()\n-** or json_set().\n+** If pArg is a blob that seems like a JSONB blob, then initialize\n+** p to point to that JSONB and return TRUE.  If pArg does not seem like\n+** a JSONB blob, then return FALSE;\n+**\n+** This routine is only called if it is already known that pArg is a\n+** blob.  The only open question is whether or not the blob appears\n+** to be a JSONB blob.\n@@ -196768,8 +206648,21 @@\n-static void jsonWrongNumArgs(\n-  sqlite3_context *pCtx,\n-  const char *zFuncName\n-){\n-  char *zMsg = sqlite3_mprintf(\"json_%s() needs an odd number of arguments\",\n-                               zFuncName);\n-  sqlite3_result_error(pCtx, zMsg, -1);\n-  sqlite3_free(zMsg);\n+static int jsonArgIsJsonb(sqlite3_value *pArg, JsonParse *p){\n+  u32 n, sz = 0;\n+  p->aBlob = (u8*)sqlite3_value_blob(pArg);\n+  p->nBlob = (u32)sqlite3_value_bytes(pArg);\n+  if( p->nBlob==0 ){\n+    p->aBlob = 0;\n+    return 0;\n+  }\n+  if( NEVER(p->aBlob==0) ){\n+    return 0;\n+  }\n+  if( (p->aBlob[0] & 0x0f)<=JSONB_OBJECT\n+   && (n = jsonbPayloadSize(p, 0, &sz))>0\n+   && sz+n==p->nBlob\n+   && ((p->aBlob[0] & 0x0f)>JSONB_FALSE || sz==0)\n+  ){\n+    return 1;\n+  }\n+  p->aBlob = 0;\n+  p->nBlob = 0;\n+  return 0;\n@@ -196779,1 +206672,14 @@\n-** Mark all NULL entries in the Object passed in as JNODE_REMOVE.\n+** Generate a JsonParse object, containing valid JSONB in aBlob and nBlob,\n+** from the SQL function argument pArg.  Return a pointer to the new\n+** JsonParse object.\n+**\n+** Ownership of the new JsonParse object is passed to the caller.  The\n+** caller should invoke jsonParseFree() on the return value when it\n+** has finished using it.\n+**\n+** If any errors are detected, an appropriate error messages is set\n+** using sqlite3_result_error() or the equivalent and this routine\n+** returns NULL.  This routine also returns NULL if the pArg argument\n+** is an SQL NULL value, but no error message is set in that case.  This\n+** is so that SQL functions that are given NULL arguments will return\n+** a NULL value.\n@@ -196781,12 +206687,20 @@\n-static void jsonRemoveAllNulls(JsonNode *pNode){\n-  int i, n;\n-  assert( pNode->eType==JSON_OBJECT );\n-  n = pNode->n;\n-  for(i=2; i<=n; i += jsonNodeSize(&pNode[i])+1){\n-    switch( pNode[i].eType ){\n-      case JSON_NULL:\n-        pNode[i].jnFlags |= JNODE_REMOVE;\n-        break;\n-      case JSON_OBJECT:\n-        jsonRemoveAllNulls(&pNode[i]);\n-        break;\n+static JsonParse *jsonParseFuncArg(\n+  sqlite3_context *ctx,\n+  sqlite3_value *pArg,\n+  u32 flgs\n+){\n+  int eType;                   \/* Datatype of pArg *\/\n+  JsonParse *p = 0;            \/* Value to be returned *\/\n+  JsonParse *pFromCache = 0;   \/* Value taken from cache *\/\n+  sqlite3 *db;                 \/* The database connection *\/\n+\n+  assert( ctx!=0 );\n+  eType = sqlite3_value_type(pArg);\n+  if( eType==SQLITE_NULL ){\n+    return 0;\n+  }\n+  pFromCache = jsonCacheSearch(ctx, pArg);\n+  if( pFromCache ){\n+    pFromCache->nJPRef++;\n+    if( (flgs & JSON_EDITABLE)==0 ){\n+      return pFromCache;\n@@ -196795,1 +206709,72 @@\n-}\n+  db = sqlite3_context_db_handle(ctx);\n+rebuild_from_cache:\n+  p = sqlite3DbMallocZero(db, sizeof(*p));\n+  if( p==0 ) goto json_pfa_oom;\n+  memset(p, 0, sizeof(*p));\n+  p->db = db;\n+  p->nJPRef = 1;\n+  if( pFromCache!=0 ){\n+    u32 nBlob = pFromCache->nBlob;\n+    p->aBlob = sqlite3DbMallocRaw(db, nBlob);\n+    if( p->aBlob==0 ) goto json_pfa_oom;\n+    memcpy(p->aBlob, pFromCache->aBlob, nBlob);\n+    p->nBlobAlloc = p->nBlob = nBlob;\n+    p->hasNonstd = pFromCache->hasNonstd;\n+    jsonParseFree(pFromCache);\n+    return p;\n+  }\n+  if( eType==SQLITE_BLOB ){\n+    if( jsonArgIsJsonb(pArg,p) ){\n+      if( (flgs & JSON_EDITABLE)!=0 && jsonBlobMakeEditable(p, 0)==0 ){\n+        goto json_pfa_oom;\n+      }\n+      return p;\n+    }\n+    \/* If the blob is not valid JSONB, fall through into trying to cast\n+    ** the blob into text which is then interpreted as JSON.  (tag-20240123-a)\n+    **\n+    ** This goes against all historical documentation about how the SQLite\n+    ** JSON functions were suppose to work.  From the beginning, blob was\n+    ** reserved for expansion and a blob value should have raised an error.\n+    ** But it did not, due to a bug.  And many applications came to depend\n+    ** upon this buggy behavior, espeically when using the CLI and reading\n+    ** JSON text using readfile(), which returns a blob.  For this reason\n+    ** we will continue to support the bug moving forward.\n+    ** See for example https:\/\/sqlite.org\/forum\/forumpost\/012136abd5292b8d\n+    *\/\n+  }\n+  p->zJson = (char*)sqlite3_value_text(pArg);\n+  p->nJson = sqlite3_value_bytes(pArg);\n+  if( db->mallocFailed ) goto json_pfa_oom;\n+  if( p->nJson==0 ) goto json_pfa_malformed;\n+  assert( p->zJson!=0 );\n+  if( jsonConvertTextToBlob(p, (flgs & JSON_KEEPERROR) ? 0 : ctx) ){\n+    if( flgs & JSON_KEEPERROR ){\n+      p->nErr = 1;\n+      return p;\n+    }else{\n+      jsonParseFree(p);\n+      return 0;\n+    }\n+  }else{\n+    int isRCStr = sqlite3ValueIsOfClass(pArg, sqlite3RCStrUnref);\n+    int rc;\n+    if( !isRCStr ){\n+      char *zNew = sqlite3RCStrNew( p->nJson );\n+      if( zNew==0 ) goto json_pfa_oom;\n+      memcpy(zNew, p->zJson, p->nJson);\n+      p->zJson = zNew;\n+      p->zJson[p->nJson] = 0;\n+    }else{\n+      sqlite3RCStrRef(p->zJson);\n+    }\n+    p->bJsonIsRCStr = 1;\n+    rc = jsonCacheInsert(ctx, p);\n+    if( rc==SQLITE_NOMEM ) goto json_pfa_oom;\n+    if( flgs & JSON_EDITABLE ){\n+      pFromCache = p;\n+      p = 0;\n+      goto rebuild_from_cache;\n+    }\n+  }\n+  return p;\n@@ -196797,0 +206782,9 @@\n+json_pfa_malformed:\n+  if( flgs & JSON_KEEPERROR ){\n+    p->nErr = 1;\n+    return p;\n+  }else{\n+    jsonParseFree(p);\n+    sqlite3_result_error(ctx, \"malformed JSON\", -1);\n+    return 0;\n+  }\n@@ -196798,3 +206792,6 @@\n-\/****************************************************************************\n-** SQL functions used for testing and debugging\n-****************************************************************************\/\n+json_pfa_oom:\n+  jsonParseFree(pFromCache);\n+  jsonParseFree(p);\n+  sqlite3_result_error_nomem(ctx);\n+  return 0;\n+}\n@@ -196802,1 +206799,0 @@\n-#ifdef SQLITE_DEBUG\n@@ -196804,3 +206800,3 @@\n-** The json_parse(JSON) function returns a string which describes\n-** a parse of the JSON provided.  Or it returns NULL if JSON is not\n-** well-formed.\n+** Make the return value of a JSON function either the raw JSONB blob\n+** or make it JSON text, depending on whether the JSON_BLOB flag is\n+** set on the function.\n@@ -196808,1 +206804,1 @@\n-static void jsonParseFunc(\n+static void jsonReturnParse(\n@@ -196810,2 +206806,1 @@\n-  int argc,\n-  sqlite3_value **argv\n+  JsonParse *p\n@@ -196813,13 +206808,10 @@\n-  JsonString s;       \/* Output string - not real JSON *\/\n-  JsonParse x;        \/* The parse *\/\n-  u32 i;\n-\n-  assert( argc==1 );\n-  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;\n-  jsonParseFindParents(&x);\n-  jsonInit(&s, ctx);\n-  for(i=0; i<x.nNode; i++){\n-    const char *zType;\n-    if( x.aNode[i].jnFlags & JNODE_LABEL ){\n-      assert( x.aNode[i].eType==JSON_STRING );\n-      zType = \"label\";\n+  int flgs;\n+  if( p->oom ){\n+    sqlite3_result_error_nomem(ctx);\n+    return;\n+  }\n+  flgs = SQLITE_PTR_TO_INT(sqlite3_user_data(ctx));\n+  if( flgs & JSON_BLOB ){\n+    if( p->nBlobAlloc>0 && !p->bReadOnly ){\n+      sqlite3_result_blob(ctx, p->aBlob, p->nBlob, SQLITE_DYNAMIC);\n+      p->nBlobAlloc = 0;\n@@ -196827,1 +206819,1 @@\n-      zType = jsonType[x.aNode[i].eType];\n+      sqlite3_result_blob(ctx, p->aBlob, p->nBlob, SQLITE_TRANSIENT);\n@@ -196829,9 +206821,59 @@\n-    jsonPrintf(100, &s,\"node %3u: %7s n=%-4d up=%-4d\",\n-               i, zType, x.aNode[i].n, x.aUp[i]);\n-    assert( x.aNode[i].eU==0 || x.aNode[i].eU==1 );\n-    if( x.aNode[i].u.zJContent!=0 ){\n-      assert( x.aNode[i].eU==1 );\n-      jsonAppendRaw(&s, \" \", 1);\n-      jsonAppendRaw(&s, x.aNode[i].u.zJContent, x.aNode[i].n);\n-    }else{\n-      assert( x.aNode[i].eU==0 );\n+  }else{\n+    JsonString s;\n+    jsonStringInit(&s, ctx);\n+    p->delta = 0;\n+    jsonTranslateBlobToText(p, 0, &s);\n+    jsonReturnString(&s, p, ctx);\n+    sqlite3_result_subtype(ctx, JSON_SUBTYPE);\n+  }\n+}\n+\n+\/****************************************************************************\n+** SQL functions used for testing and debugging\n+****************************************************************************\/\n+\n+#if SQLITE_DEBUG\n+\/*\n+** Decode JSONB bytes in aBlob[] starting at iStart through but not\n+** including iEnd.  Indent the\n+** content by nIndent spaces.\n+*\/\n+static void jsonDebugPrintBlob(\n+  JsonParse *pParse, \/* JSON content *\/\n+  u32 iStart,        \/* Start rendering here *\/\n+  u32 iEnd,          \/* Do not render this byte or any byte after this one *\/\n+  int nIndent,       \/* Indent by this many spaces *\/\n+  sqlite3_str *pOut  \/* Generate output into this sqlite3_str object *\/\n+){\n+  while( iStart<iEnd ){\n+    u32 i, n, nn, sz = 0;\n+    int showContent = 1;\n+    u8 x = pParse->aBlob[iStart] & 0x0f;\n+    u32 savedNBlob = pParse->nBlob;\n+    sqlite3_str_appendf(pOut, \"%5d:%*s\", iStart, nIndent, \"\");\n+    if( pParse->nBlobAlloc>pParse->nBlob ){\n+      pParse->nBlob = pParse->nBlobAlloc;\n+    }\n+    nn = n = jsonbPayloadSize(pParse, iStart, &sz);\n+    if( nn==0 ) nn = 1;\n+    if( sz>0 && x<JSONB_ARRAY ){\n+      nn += sz;\n+    }\n+    for(i=0; i<nn; i++){\n+      sqlite3_str_appendf(pOut, \" %02x\", pParse->aBlob[iStart+i]);\n+    }\n+    if( n==0 ){\n+      sqlite3_str_appendf(pOut, \"   ERROR invalid node size\\n\");\n+      iStart = n==0 ? iStart+1 : iEnd;\n+      continue;\n+    }\n+    pParse->nBlob = savedNBlob;\n+    if( iStart+n+sz>iEnd ){\n+      iEnd = iStart+n+sz;\n+      if( iEnd>pParse->nBlob ){\n+        if( pParse->nBlobAlloc>0 && iEnd>pParse->nBlobAlloc ){\n+          iEnd = pParse->nBlobAlloc;\n+        }else{\n+          iEnd = pParse->nBlob;\n+        }\n+      }\n@@ -196839,1 +206881,46 @@\n-    jsonAppendRaw(&s, \"\\n\", 1);\n+    sqlite3_str_appendall(pOut,\"  <-- \");\n+    switch( x ){\n+      case JSONB_NULL:     sqlite3_str_appendall(pOut,\"null\"); break;\n+      case JSONB_TRUE:     sqlite3_str_appendall(pOut,\"true\"); break;\n+      case JSONB_FALSE:    sqlite3_str_appendall(pOut,\"false\"); break;\n+      case JSONB_INT:      sqlite3_str_appendall(pOut,\"int\"); break;\n+      case JSONB_INT5:     sqlite3_str_appendall(pOut,\"int5\"); break;\n+      case JSONB_FLOAT:    sqlite3_str_appendall(pOut,\"float\"); break;\n+      case JSONB_FLOAT5:   sqlite3_str_appendall(pOut,\"float5\"); break;\n+      case JSONB_TEXT:     sqlite3_str_appendall(pOut,\"text\"); break;\n+      case JSONB_TEXTJ:    sqlite3_str_appendall(pOut,\"textj\"); break;\n+      case JSONB_TEXT5:    sqlite3_str_appendall(pOut,\"text5\"); break;\n+      case JSONB_TEXTRAW:  sqlite3_str_appendall(pOut,\"textraw\"); break;\n+      case JSONB_ARRAY: {\n+        sqlite3_str_appendf(pOut,\"array, %u bytes\\n\", sz);\n+        jsonDebugPrintBlob(pParse, iStart+n, iStart+n+sz, nIndent+2, pOut);\n+        showContent = 0;\n+        break;\n+      }\n+      case JSONB_OBJECT: {\n+        sqlite3_str_appendf(pOut, \"object, %u bytes\\n\", sz);\n+        jsonDebugPrintBlob(pParse, iStart+n, iStart+n+sz, nIndent+2, pOut);\n+        showContent = 0;\n+        break;\n+      }\n+      default: {\n+        sqlite3_str_appendall(pOut, \"ERROR: unknown node type\\n\");\n+        showContent = 0;\n+        break;\n+      }\n+    }\n+    if( showContent ){\n+      if( sz==0 && x<=JSONB_FALSE ){\n+        sqlite3_str_append(pOut, \"\\n\", 1);\n+      }else{\n+        u32 j;\n+        sqlite3_str_appendall(pOut, \": \\\"\");\n+        for(j=iStart+n; j<iStart+n+sz; j++){\n+          u8 c = pParse->aBlob[j];\n+          if( c<0x20 || c>=0x7f ) c = '.';\n+          sqlite3_str_append(pOut, (char*)&c, 1);\n+        }\n+        sqlite3_str_append(pOut, \"\\\"\\n\", 2);\n+      }\n+    }\n+    iStart += n + sz;\n@@ -196841,2 +206928,0 @@\n-  jsonParseReset(&x);\n-  jsonResult(&s);\n@@ -196844,0 +206929,19 @@\n+static void jsonShowParse(JsonParse *pParse){\n+  sqlite3_str out;\n+  char zBuf[1000];\n+  if( pParse==0 ){\n+    printf(\"NULL pointer\\n\");\n+    return;\n+  }else{\n+    printf(\"nBlobAlloc = %u\\n\", pParse->nBlobAlloc);\n+    printf(\"nBlob = %u\\n\", pParse->nBlob);\n+    printf(\"delta = %d\\n\", pParse->delta);\n+    if( pParse->nBlob==0 ) return;\n+    printf(\"content (bytes 0..%u):\\n\", pParse->nBlob-1);\n+  }\n+  sqlite3StrAccumInit(&out, 0, zBuf, sizeof(zBuf), 1000000);\n+  jsonDebugPrintBlob(pParse, 0, pParse->nBlob, 0, &out);\n+  printf(\"%s\", sqlite3_str_value(&out));\n+  sqlite3_str_reset(&out);\n+}\n+#endif \/* SQLITE_DEBUG *\/\n@@ -196845,0 +206949,1 @@\n+#ifdef SQLITE_DEBUG\n@@ -196846,3 +206951,4 @@\n-** The json_test1(JSON) function return true (1) if the input is JSON\n-** text generated by another json function.  It returns (0) if the input\n-** is not known to be JSON.\n+** SQL function:   json_parse(JSON)\n+**\n+** Parse JSON using jsonParseFuncArg().  Return text that is a\n+** human-readable dump of the binary JSONB for the input parameter.\n@@ -196850,1 +206956,1 @@\n-static void jsonTest1Func(\n+static void jsonParseFunc(\n@@ -196855,2 +206961,14 @@\n-  UNUSED_PARAMETER(argc);\n-  sqlite3_result_int(ctx, sqlite3_value_subtype(argv[0])==JSON_SUBTYPE);\n+  JsonParse *p;        \/* The parse *\/\n+  sqlite3_str out;\n+\n+  assert( argc>=1 );\n+  sqlite3StrAccumInit(&out, 0, 0, 0, 1000000);\n+  p = jsonParseFuncArg(ctx, argv[0], 0);\n+  if( p==0 ) return;\n+  if( argc==1 ){\n+    jsonDebugPrintBlob(p, 0, p->nBlob, 0, &out);\n+    sqlite3_result_text64(ctx, out.zText, out.nChar, SQLITE_DYNAMIC, SQLITE_UTF8);\n+  }else{\n+    jsonShowParse(p);\n+  }\n+  jsonParseFree(p);\n@@ -196865,1 +206983,1 @@\n-** Implementation of the json_QUOTE(VALUE) function.  Return a JSON value\n+** Implementation of the json_quote(VALUE) function.  Return a JSON value\n@@ -196878,3 +206996,3 @@\n-  jsonInit(&jx, ctx);\n-  jsonAppendValue(&jx, argv[0]);\n-  jsonResult(&jx);\n+  jsonStringInit(&jx, ctx);\n+  jsonAppendSqlValue(&jx, argv[0]);\n+  jsonReturnString(&jx, 0, 0);\n@@ -196897,1 +207015,1 @@\n-  jsonInit(&jx, ctx);\n+  jsonStringInit(&jx, ctx);\n@@ -196901,1 +207019,1 @@\n-    jsonAppendValue(&jx, argv[i]);\n+    jsonAppendSqlValue(&jx, argv[i]);\n@@ -196904,1 +207022,1 @@\n-  jsonResult(&jx);\n+  jsonReturnString(&jx, 0, 0);\n@@ -196908,1 +207026,0 @@\n-\n@@ -196922,1 +207039,1 @@\n-  sqlite3_int64 n = 0;\n+  sqlite3_int64 cnt = 0;\n@@ -196924,1 +207041,1 @@\n-  JsonNode *pNode;\n+  u8 eErr = 0;\n@@ -196926,1 +207043,1 @@\n-  p = jsonParseCached(ctx, argv, ctx);\n+  p = jsonParseFuncArg(ctx, argv[0], 0);\n@@ -196928,1 +207045,0 @@\n-  assert( p->nNode );\n@@ -196931,1 +207047,16 @@\n-    pNode = jsonLookup(p, zPath, 0, ctx);\n+    if( zPath==0 ){\n+      jsonParseFree(p);\n+      return;\n+    }\n+    i = jsonLookupStep(p, 0, zPath[0]=='$' ? zPath+1 : \"@\", 0);\n+    if( JSON_LOOKUP_ISERROR(i) ){\n+      if( i==JSON_LOOKUP_NOTFOUND ){\n+        \/* no-op *\/\n+      }else if( i==JSON_LOOKUP_PATHERROR ){\n+        jsonBadPathError(ctx, zPath);\n+      }else{\n+        sqlite3_result_error(ctx, \"malformed JSON\", -1);\n+      }\n+      eErr = 1;\n+      i = 0;\n+    }\n@@ -196933,4 +207064,1 @@\n-    pNode = p->aNode;\n-  }\n-  if( pNode==0 ){\n-    return;\n+    i = 0;\n@@ -196938,5 +207066,2 @@\n-  if( pNode->eType==JSON_ARRAY ){\n-    assert( (pNode->jnFlags & JNODE_APPEND)==0 );\n-    for(i=1; i<=pNode->n; n++){\n-      i += jsonNodeSize(&pNode[i]);\n-    }\n+  if( (p->aBlob[i] & 0x0f)==JSONB_ARRAY ){\n+    cnt = jsonbArrayCount(p, i);\n@@ -196944,1 +207069,2 @@\n-  sqlite3_result_int64(ctx, n);\n+  if( !eErr ) sqlite3_result_int64(ctx, cnt);\n+  jsonParseFree(p);\n@@ -196947,8 +207073,13 @@\n-\/*\n-** Bit values for the flags passed into jsonExtractFunc() or\n-** jsonSetFunc() via the user-data value.\n-*\/\n-#define JSON_JSON      0x01        \/* Result is always JSON *\/\n-#define JSON_SQL       0x02        \/* Result is always SQL *\/\n-#define JSON_ABPATH    0x03        \/* Allow abbreviated JSON path specs *\/\n-#define JSON_ISSET     0x04        \/* json_set(), not json_insert() *\/\n+\/* True if the string is all digits *\/\n+static int jsonAllDigits(const char *z, int n){\n+  int i;\n+  for(i=0; i<n && sqlite3Isdigit(z[i]); i++){}\n+  return i==n;\n+}\n+\n+\/* True if the string is all alphanumerics and underscores *\/\n+static int jsonAllAlphanum(const char *z, int n){\n+  int i;\n+  for(i=0; i<n && (sqlite3Isalnum(z[i]) || z[i]=='_'); i++){}\n+  return i==n;\n+}\n@@ -196981,5 +207112,4 @@\n-  JsonParse *p;          \/* The parse *\/\n-  JsonNode *pNode;\n-  const char *zPath;\n-  int flags = SQLITE_PTR_TO_INT(sqlite3_user_data(ctx));\n-  JsonString jx;\n+  JsonParse *p = 0;      \/* The parse *\/\n+  int flags;             \/* Flags associated with the function *\/\n+  int i;                 \/* Loop counter *\/\n+  JsonString jx;         \/* String for array result *\/\n@@ -196988,1 +207118,1 @@\n-  p = jsonParseCached(ctx, argv, ctx);\n+  p = jsonParseFuncArg(ctx, argv[0], 0);\n@@ -196990,1 +207120,6 @@\n-  if( argc==2 ){\n+  flags = SQLITE_PTR_TO_INT(sqlite3_user_data(ctx));\n+  jsonStringInit(&jx, ctx);\n+  if( argc>2 ){\n+    jsonAppendChar(&jx, '[');\n+  }\n+  for(i=1; i<argc; i++){\n@@ -196992,24 +207127,26 @@\n-    zPath = (const char*)sqlite3_value_text(argv[1]);\n-    if( zPath==0 ) return;\n-    if( flags & JSON_ABPATH ){\n-      if( zPath[0]!='$' ){\n-        \/* The -> and ->> operators accept abbreviated PATH arguments.  This\n-        ** is mostly for compatibility with PostgreSQL, but also for\n-        ** convenience.\n-        **\n-        **     NUMBER   ==>  $[NUMBER]     \/\/ PG compatible\n-        **     LABEL    ==>  $.LABEL       \/\/ PG compatible\n-        **     [NUMBER] ==>  $[NUMBER]     \/\/ Not PG.  Purely for convenience\n-        *\/\n-        jsonInit(&jx, ctx);\n-        if( sqlite3Isdigit(zPath[0]) ){\n-          jsonAppendRaw(&jx, \"$[\", 2);\n-          jsonAppendRaw(&jx, zPath, (int)strlen(zPath));\n-          jsonAppendRaw(&jx, \"]\", 2);\n-        }else{\n-          jsonAppendRaw(&jx, \"$.\", 1 + (zPath[0]!='['));\n-          jsonAppendRaw(&jx, zPath, (int)strlen(zPath));\n-          jsonAppendChar(&jx, 0);\n-        }\n-        pNode = jx.bErr ? 0 : jsonLookup(p, jx.zBuf, 0, ctx);\n-        jsonReset(&jx);\n+    const char *zPath = (const char*)sqlite3_value_text(argv[i]);\n+    int nPath;\n+    u32 j;\n+    if( zPath==0 ) goto json_extract_error;\n+    nPath = sqlite3Strlen30(zPath);\n+    if( zPath[0]=='$' ){\n+      j = jsonLookupStep(p, 0, zPath+1, 0);\n+    }else if( (flags & JSON_ABPATH) ){\n+      \/* The -> and ->> operators accept abbreviated PATH arguments.  This\n+      ** is mostly for compatibility with PostgreSQL, but also for\n+      ** convenience.\n+      **\n+      **     NUMBER   ==>  $[NUMBER]     \/\/ PG compatible\n+      **     LABEL    ==>  $.LABEL       \/\/ PG compatible\n+      **     [NUMBER] ==>  $[NUMBER]     \/\/ Not PG.  Purely for convenience\n+      *\/\n+      jsonStringInit(&jx, ctx);\n+      if( jsonAllDigits(zPath, nPath) ){\n+        jsonAppendRawNZ(&jx, \"[\", 1);\n+        jsonAppendRaw(&jx, zPath, nPath);\n+        jsonAppendRawNZ(&jx, \"]\", 2);\n+      }else if( jsonAllAlphanum(zPath, nPath) ){\n+        jsonAppendRawNZ(&jx, \".\", 1);\n+        jsonAppendRaw(&jx, zPath, nPath);\n+      }else if( zPath[0]=='[' && nPath>=3 && zPath[nPath-1]==']' ){\n+        jsonAppendRaw(&jx, zPath, nPath);\n@@ -197017,1 +207154,3 @@\n-        pNode = jsonLookup(p, zPath, 0, ctx);\n+        jsonAppendRawNZ(&jx, \".\\\"\", 2);\n+        jsonAppendRaw(&jx, zPath, nPath);\n+        jsonAppendRawNZ(&jx, \"\\\"\", 1);\n@@ -197019,1 +207158,9 @@\n-      if( pNode ){\n+      jsonStringTerminate(&jx);\n+      j = jsonLookupStep(p, 0, jx.zBuf, 0);\n+      jsonStringReset(&jx);\n+    }else{\n+      jsonBadPathError(ctx, zPath);\n+      goto json_extract_error;\n+    }\n+    if( j<p->nBlob ){\n+      if( argc==2 ){\n@@ -197021,1 +207168,6 @@\n-          jsonReturnJson(pNode, ctx, 0);\n+          jsonStringInit(&jx, ctx);\n+          jsonTranslateBlobToText(p, j, &jx);\n+          jsonReturnString(&jx, 0, 0);\n+          jsonStringReset(&jx);\n+          assert( (flags & JSON_BLOB)==0 );\n+          sqlite3_result_subtype(ctx, JSON_SUBTYPE);\n@@ -197023,2 +207175,6 @@\n-          jsonReturn(pNode, ctx, 0);\n-          sqlite3_result_subtype(ctx, 0);\n+          jsonReturnFromBlob(p, j, ctx, 0);\n+          if( (flags & (JSON_SQL|JSON_BLOB))==0\n+           && (p->aBlob[j]&0x0f)>=JSONB_ARRAY\n+          ){\n+            sqlite3_result_subtype(ctx, JSON_SUBTYPE);\n+          }\n@@ -197026,0 +207182,3 @@\n+      }else{\n+        jsonAppendSeparator(&jx);\n+        jsonTranslateBlobToText(p, j, &jx);\n@@ -197027,17 +207186,3 @@\n-    }else{\n-      pNode = jsonLookup(p, zPath, 0, ctx);\n-      if( p->nErr==0 && pNode ) jsonReturn(pNode, ctx, 0);\n-    }\n-  }else{\n-    \/* Two or more PATH arguments results in a JSON array with each\n-    ** element of the array being the value selected by one of the PATHs *\/\n-    int i;\n-    jsonInit(&jx, ctx);\n-    jsonAppendChar(&jx, '[');\n-    for(i=1; i<argc; i++){\n-      zPath = (const char*)sqlite3_value_text(argv[i]);\n-      pNode = jsonLookup(p, zPath, 0, ctx);\n-      if( p->nErr ) break;\n-      jsonAppendSeparator(&jx);\n-      if( pNode ){\n-        jsonRenderNode(pNode, &jx, 0);\n+    }else if( j==JSON_LOOKUP_NOTFOUND ){\n+      if( argc==2 ){\n+        goto json_extract_error;  \/* Return NULL if not found *\/\n@@ -197045,1 +207190,2 @@\n-        jsonAppendRaw(&jx, \"null\", 4);\n+        jsonAppendSeparator(&jx);\n+        jsonAppendRawNZ(&jx, \"null\", 4);\n@@ -197047,0 +207193,6 @@\n+    }else if( j==JSON_LOOKUP_ERROR ){\n+      sqlite3_result_error(ctx, \"malformed JSON\", -1);\n+      goto json_extract_error;\n+    }else{\n+      jsonBadPathError(ctx, zPath);\n+      goto json_extract_error;\n@@ -197048,3 +207200,5 @@\n-    if( i==argc ){\n-      jsonAppendChar(&jx, ']');\n-      jsonResult(&jx);\n+  }\n+  if( argc>2 ){\n+    jsonAppendChar(&jx, ']');\n+    jsonReturnString(&jx, 0, 0);\n+    if( (flags & JSON_BLOB)==0 ){\n@@ -197053,1 +207207,0 @@\n-    jsonReset(&jx);\n@@ -197055,0 +207208,4 @@\n+json_extract_error:\n+  jsonStringReset(&jx);\n+  jsonParseFree(p);\n+  return;\n@@ -197057,54 +207214,191 @@\n-\/* This is the RFC 7396 MergePatch algorithm.\n-*\/\n-static JsonNode *jsonMergePatch(\n-  JsonParse *pParse,   \/* The JSON parser that contains the TARGET *\/\n-  u32 iTarget,         \/* Node of the TARGET in pParse *\/\n-  JsonNode *pPatch     \/* The PATCH *\/\n-){\n-  u32 i, j;\n-  u32 iRoot;\n-  JsonNode *pTarget;\n-  if( pPatch->eType!=JSON_OBJECT ){\n-    return pPatch;\n-  }\n-  assert( iTarget<pParse->nNode );\n-  pTarget = &pParse->aNode[iTarget];\n-  assert( (pPatch->jnFlags & JNODE_APPEND)==0 );\n-  if( pTarget->eType!=JSON_OBJECT ){\n-    jsonRemoveAllNulls(pPatch);\n-    return pPatch;\n-  }\n-  iRoot = iTarget;\n-  for(i=1; i<pPatch->n; i += jsonNodeSize(&pPatch[i+1])+1){\n-    u32 nKey;\n-    const char *zKey;\n-    assert( pPatch[i].eType==JSON_STRING );\n-    assert( pPatch[i].jnFlags & JNODE_LABEL );\n-    assert( pPatch[i].eU==1 );\n-    nKey = pPatch[i].n;\n-    zKey = pPatch[i].u.zJContent;\n-    assert( (pPatch[i].jnFlags & JNODE_RAW)==0 );\n-    for(j=1; j<pTarget->n; j += jsonNodeSize(&pTarget[j+1])+1 ){\n-      assert( pTarget[j].eType==JSON_STRING );\n-      assert( pTarget[j].jnFlags & JNODE_LABEL );\n-      assert( (pPatch[i].jnFlags & JNODE_RAW)==0 );\n-      if( pTarget[j].n==nKey && strncmp(pTarget[j].u.zJContent,zKey,nKey)==0 ){\n-        if( pTarget[j+1].jnFlags & (JNODE_REMOVE|JNODE_PATCH) ) break;\n-        if( pPatch[i+1].eType==JSON_NULL ){\n-          pTarget[j+1].jnFlags |= JNODE_REMOVE;\n-        }else{\n-          JsonNode *pNew = jsonMergePatch(pParse, iTarget+j+1, &pPatch[i+1]);\n-          if( pNew==0 ) return 0;\n-          pTarget = &pParse->aNode[iTarget];\n-          if( pNew!=&pTarget[j+1] ){\n-            assert( pTarget[j+1].eU==0\n-                 || pTarget[j+1].eU==1\n-                 || pTarget[j+1].eU==2 );\n-            testcase( pTarget[j+1].eU==1 );\n-            testcase( pTarget[j+1].eU==2 );\n-            VVA( pTarget[j+1].eU = 5 );\n-            pTarget[j+1].u.pPatch = pNew;\n-            pTarget[j+1].jnFlags |= JNODE_PATCH;\n-          }\n-        }\n-        break;\n+\/*\n+** Return codes for jsonMergePatch()\n+*\/\n+#define JSON_MERGE_OK          0     \/* Success *\/\n+#define JSON_MERGE_BADTARGET   1     \/* Malformed TARGET blob *\/\n+#define JSON_MERGE_BADPATCH    2     \/* Malformed PATCH blob *\/\n+#define JSON_MERGE_OOM         3     \/* Out-of-memory condition *\/\n+\n+\/*\n+** RFC-7396 MergePatch for two JSONB blobs.\n+**\n+** pTarget is the target. pPatch is the patch.  The target is updated\n+** in place.  The patch is read-only.\n+**\n+** The original RFC-7396 algorithm is this:\n+**\n+**   define MergePatch(Target, Patch):\n+**     if Patch is an Object:\n+**       if Target is not an Object:\n+**         Target = {} # Ignore the contents and set it to an empty Object\n+**     for each Name\/Value pair in Patch:\n+**         if Value is null:\n+**           if Name exists in Target:\n+**             remove the Name\/Value pair from Target\n+**         else:\n+**           Target[Name] = MergePatch(Target[Name], Value)\n+**       return Target\n+**     else:\n+**       return Patch\n+**\n+** Here is an equivalent algorithm restructured to show the actual\n+** implementation:\n+**\n+** 01   define MergePatch(Target, Patch):\n+** 02      if Patch is not an Object:\n+** 03         return Patch\n+** 04      else: \/\/ if Patch is an Object\n+** 05         if Target is not an Object:\n+** 06            Target = {}\n+** 07      for each Name\/Value pair in Patch:\n+** 08         if Name exists in Target:\n+** 09            if Value is null:\n+** 10               remove the Name\/Value pair from Target\n+** 11            else\n+** 12               Target[name] = MergePatch(Target[Name], Value)\n+** 13         else if Value is not NULL:\n+** 14            if Value is not an Object:\n+** 15               Target[name] = Value\n+** 16            else:\n+** 17               Target[name] = MergePatch('{}',value)\n+** 18      return Target\n+**  |\n+**  ^---- Line numbers referenced in comments in the implementation\n+*\/\n+static int jsonMergePatch(\n+  JsonParse *pTarget,      \/* The JSON parser that contains the TARGET *\/\n+  u32 iTarget,             \/* Index of TARGET in pTarget->aBlob[] *\/\n+  const JsonParse *pPatch, \/* The PATCH *\/\n+  u32 iPatch               \/* Index of PATCH in pPatch->aBlob[] *\/\n+){\n+  u8 x;             \/* Type of a single node *\/\n+  u32 n, sz=0;      \/* Return values from jsonbPayloadSize() *\/\n+  u32 iTCursor;     \/* Cursor position while scanning the target object *\/\n+  u32 iTStart;      \/* First label in the target object *\/\n+  u32 iTEndBE;      \/* Original first byte past end of target, before edit *\/\n+  u32 iTEnd;        \/* Current first byte past end of target *\/\n+  u8 eTLabel;       \/* Node type of the target label *\/\n+  u32 iTLabel = 0;  \/* Index of the label *\/\n+  u32 nTLabel = 0;  \/* Header size in bytes for the target label *\/\n+  u32 szTLabel = 0; \/* Size of the target label payload *\/\n+  u32 iTValue = 0;  \/* Index of the target value *\/\n+  u32 nTValue = 0;  \/* Header size of the target value *\/\n+  u32 szTValue = 0; \/* Payload size for the target value *\/\n+\n+  u32 iPCursor;     \/* Cursor position while scanning the patch *\/\n+  u32 iPEnd;        \/* First byte past the end of the patch *\/\n+  u8 ePLabel;       \/* Node type of the patch label *\/\n+  u32 iPLabel;      \/* Start of patch label *\/\n+  u32 nPLabel;      \/* Size of header on the patch label *\/\n+  u32 szPLabel;     \/* Payload size of the patch label *\/\n+  u32 iPValue;      \/* Start of patch value *\/\n+  u32 nPValue;      \/* Header size for the patch value *\/\n+  u32 szPValue;     \/* Payload size of the patch value *\/\n+\n+  assert( iTarget>=0 && iTarget<pTarget->nBlob );\n+  assert( iPatch>=0 && iPatch<pPatch->nBlob );\n+  x = pPatch->aBlob[iPatch] & 0x0f;\n+  if( x!=JSONB_OBJECT ){  \/* Algorithm line 02 *\/\n+    u32 szPatch;        \/* Total size of the patch, header+payload *\/\n+    u32 szTarget;       \/* Total size of the target, header+payload *\/\n+    n = jsonbPayloadSize(pPatch, iPatch, &sz);\n+    szPatch = n+sz;\n+    sz = 0;\n+    n = jsonbPayloadSize(pTarget, iTarget, &sz);\n+    szTarget = n+sz;\n+    jsonBlobEdit(pTarget, iTarget, szTarget, pPatch->aBlob+iPatch, szPatch);\n+    return pTarget->oom ? JSON_MERGE_OOM : JSON_MERGE_OK;  \/* Line 03 *\/\n+  }\n+  x = pTarget->aBlob[iTarget] & 0x0f;\n+  if( x!=JSONB_OBJECT ){  \/* Algorithm line 05 *\/\n+    n = jsonbPayloadSize(pTarget, iTarget, &sz);\n+    jsonBlobEdit(pTarget, iTarget+n, sz, 0, 0);\n+    x = pTarget->aBlob[iTarget];\n+    pTarget->aBlob[iTarget] = (x & 0xf0) | JSONB_OBJECT;\n+  }\n+  n = jsonbPayloadSize(pPatch, iPatch, &sz);\n+  if( NEVER(n==0) ) return JSON_MERGE_BADPATCH;\n+  iPCursor = iPatch+n;\n+  iPEnd = iPCursor+sz;\n+  n = jsonbPayloadSize(pTarget, iTarget, &sz);\n+  if( NEVER(n==0) ) return JSON_MERGE_BADTARGET;\n+  iTStart = iTarget+n;\n+  iTEndBE = iTStart+sz;\n+\n+  while( iPCursor<iPEnd ){  \/* Algorithm line 07 *\/\n+    iPLabel = iPCursor;\n+    ePLabel = pPatch->aBlob[iPCursor] & 0x0f;\n+    if( ePLabel<JSONB_TEXT || ePLabel>JSONB_TEXTRAW ){\n+      return JSON_MERGE_BADPATCH;\n+    }\n+    nPLabel = jsonbPayloadSize(pPatch, iPCursor, &szPLabel);\n+    if( nPLabel==0 ) return JSON_MERGE_BADPATCH;\n+    iPValue = iPCursor + nPLabel + szPLabel;\n+    if( iPValue>=iPEnd ) return JSON_MERGE_BADPATCH;\n+    nPValue = jsonbPayloadSize(pPatch, iPValue, &szPValue);\n+    if( nPValue==0 ) return JSON_MERGE_BADPATCH;\n+    iPCursor = iPValue + nPValue + szPValue;\n+    if( iPCursor>iPEnd ) return JSON_MERGE_BADPATCH;\n+\n+    iTCursor = iTStart;\n+    iTEnd = iTEndBE + pTarget->delta;\n+    while( iTCursor<iTEnd ){\n+      int isEqual;   \/* true if the patch and target labels match *\/\n+      iTLabel = iTCursor;\n+      eTLabel = pTarget->aBlob[iTCursor] & 0x0f;\n+      if( eTLabel<JSONB_TEXT || eTLabel>JSONB_TEXTRAW ){\n+        return JSON_MERGE_BADTARGET;\n+      }\n+      nTLabel = jsonbPayloadSize(pTarget, iTCursor, &szTLabel);\n+      if( nTLabel==0 ) return JSON_MERGE_BADTARGET;\n+      iTValue = iTLabel + nTLabel + szTLabel;\n+      if( iTValue>=iTEnd ) return JSON_MERGE_BADTARGET;\n+      nTValue = jsonbPayloadSize(pTarget, iTValue, &szTValue);\n+      if( nTValue==0 ) return JSON_MERGE_BADTARGET;\n+      if( iTValue + nTValue + szTValue > iTEnd ) return JSON_MERGE_BADTARGET;\n+      isEqual = jsonLabelCompare(\n+                   (const char*)&pPatch->aBlob[iPLabel+nPLabel],\n+                   szPLabel,\n+                   (ePLabel==JSONB_TEXT || ePLabel==JSONB_TEXTRAW),\n+                   (const char*)&pTarget->aBlob[iTLabel+nTLabel],\n+                   szTLabel,\n+                   (eTLabel==JSONB_TEXT || eTLabel==JSONB_TEXTRAW));\n+      if( isEqual ) break;\n+      iTCursor = iTValue + nTValue + szTValue;\n+    }\n+    x = pPatch->aBlob[iPValue] & 0x0f;\n+    if( iTCursor<iTEnd ){\n+      \/* A match was found.  Algorithm line 08 *\/\n+      if( x==0 ){\n+        \/* Patch value is NULL.  Algorithm line 09 *\/\n+        jsonBlobEdit(pTarget, iTLabel, nTLabel+szTLabel+nTValue+szTValue, 0,0);\n+        \/*  vvvvvv----- No OOM on a delete-only edit *\/\n+        if( NEVER(pTarget->oom) ) return JSON_MERGE_OOM;\n+      }else{\n+        \/* Algorithm line 12 *\/\n+        int rc, savedDelta = pTarget->delta;\n+        pTarget->delta = 0;\n+        rc = jsonMergePatch(pTarget, iTValue, pPatch, iPValue);\n+        if( rc ) return rc;\n+        pTarget->delta += savedDelta;\n+      }\n+    }else if( x>0 ){  \/* Algorithm line 13 *\/\n+      \/* No match and patch value is not NULL *\/\n+      u32 szNew = szPLabel+nPLabel;\n+      if( (pPatch->aBlob[iPValue] & 0x0f)!=JSONB_OBJECT ){  \/* Line 14 *\/\n+        jsonBlobEdit(pTarget, iTEnd, 0, 0, szPValue+nPValue+szNew);\n+        if( pTarget->oom ) return JSON_MERGE_OOM;\n+        memcpy(&pTarget->aBlob[iTEnd], &pPatch->aBlob[iPLabel], szNew);\n+        memcpy(&pTarget->aBlob[iTEnd+szNew],\n+               &pPatch->aBlob[iPValue], szPValue+nPValue);\n+      }else{\n+        int rc, savedDelta;\n+        jsonBlobEdit(pTarget, iTEnd, 0, 0, szNew+1);\n+        if( pTarget->oom ) return JSON_MERGE_OOM;\n+        memcpy(&pTarget->aBlob[iTEnd], &pPatch->aBlob[iPLabel], szNew);\n+        pTarget->aBlob[iTEnd+szNew] = 0x00;\n+        savedDelta = pTarget->delta;\n+        pTarget->delta = 0;\n+        rc = jsonMergePatch(pTarget, iTEnd+szNew,pPatch,iPValue);\n+        if( rc ) return rc;\n+        pTarget->delta += savedDelta;\n@@ -197113,19 +207407,0 @@\n-    if( j>=pTarget->n && pPatch[i+1].eType!=JSON_NULL ){\n-      int iStart, iPatch;\n-      iStart = jsonParseAddNode(pParse, JSON_OBJECT, 2, 0);\n-      jsonParseAddNode(pParse, JSON_STRING, nKey, zKey);\n-      iPatch = jsonParseAddNode(pParse, JSON_TRUE, 0, 0);\n-      if( pParse->oom ) return 0;\n-      jsonRemoveAllNulls(pPatch);\n-      pTarget = &pParse->aNode[iTarget];\n-      assert( pParse->aNode[iRoot].eU==0 || pParse->aNode[iRoot].eU==2 );\n-      testcase( pParse->aNode[iRoot].eU==2 );\n-      pParse->aNode[iRoot].jnFlags |= JNODE_APPEND;\n-      VVA( pParse->aNode[iRoot].eU = 2 );\n-      pParse->aNode[iRoot].u.iAppend = iStart - iRoot;\n-      iRoot = iStart;\n-      assert( pParse->aNode[iPatch].eU==0 );\n-      VVA( pParse->aNode[iPatch].eU = 5 );\n-      pParse->aNode[iPatch].jnFlags |= JNODE_PATCH;\n-      pParse->aNode[iPatch].u.pPatch = &pPatch[i+1];\n-    }\n@@ -197133,1 +207408,2 @@\n-  return pTarget;\n+  if( pTarget->delta ) jsonAfterEditSizeAdjust(pTarget, iTarget);\n+  return pTarget->oom ? JSON_MERGE_OOM : JSON_MERGE_OK;\n@@ -197136,0 +207412,1 @@\n+\n@@ -197146,3 +207423,3 @@\n-  JsonParse x;     \/* The JSON that is being patched *\/\n-  JsonParse y;     \/* The patch *\/\n-  JsonNode *pResult;   \/* The result of the merge *\/\n+  JsonParse *pTarget;    \/* The TARGET *\/\n+  JsonParse *pPatch;     \/* The PATCH *\/\n+  int rc;                \/* Result code *\/\n@@ -197151,11 +207428,14 @@\n-  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;\n-  if( jsonParse(&y, ctx, (const char*)sqlite3_value_text(argv[1])) ){\n-    jsonParseReset(&x);\n-    return;\n-  }\n-  pResult = jsonMergePatch(&x, 0, y.aNode);\n-  assert( pResult!=0 || x.oom );\n-  if( pResult ){\n-    jsonReturnJson(pResult, ctx, 0);\n-  }else{\n-    sqlite3_result_error_nomem(ctx);\n+  assert( argc==2 );\n+  pTarget = jsonParseFuncArg(ctx, argv[0], JSON_EDITABLE);\n+  if( pTarget==0 ) return;\n+  pPatch = jsonParseFuncArg(ctx, argv[1], 0);\n+  if( pPatch ){\n+    rc = jsonMergePatch(pTarget, 0, pPatch, 0);\n+    if( rc==JSON_MERGE_OK ){\n+      jsonReturnParse(ctx, pTarget);\n+    }else if( rc==JSON_MERGE_OOM ){\n+      sqlite3_result_error_nomem(ctx);\n+    }else{\n+      sqlite3_result_error(ctx, \"malformed JSON\", -1);\n+    }\n+    jsonParseFree(pPatch);\n@@ -197163,2 +207443,1 @@\n-  jsonParseReset(&x);\n-  jsonParseReset(&y);\n+  jsonParseFree(pTarget);\n@@ -197188,1 +207467,1 @@\n-  jsonInit(&jx, ctx);\n+  jsonStringInit(&jx, ctx);\n@@ -197193,1 +207472,1 @@\n-      jsonReset(&jx);\n+      jsonStringReset(&jx);\n@@ -197198,1 +207477,1 @@\n-    n = (u32)sqlite3_value_bytes(argv[i]);\n+    n = sqlite3_value_bytes(argv[i]);\n@@ -197201,1 +207480,1 @@\n-    jsonAppendValue(&jx, argv[i+1]);\n+    jsonAppendSqlValue(&jx, argv[i+1]);\n@@ -197204,1 +207483,1 @@\n-  jsonResult(&jx);\n+  jsonReturnString(&jx, 0, 0);\n@@ -197220,4 +207499,4 @@\n-  JsonParse x;          \/* The parse *\/\n-  JsonNode *pNode;\n-  const char *zPath;\n-  u32 i;\n+  JsonParse *p;          \/* The parse *\/\n+  const char *zPath = 0; \/* Path of element to be removed *\/\n+  int i;                 \/* Loop counter *\/\n+  u32 rc;                \/* Subroutine return code *\/\n@@ -197226,3 +207505,3 @@\n-  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;\n-  assert( x.nNode );\n-  for(i=1; i<(u32)argc; i++){\n+  p = jsonParseFuncArg(ctx, argv[0], argc>1 ? JSON_EDITABLE : 0);\n+  if( p==0 ) return;\n+  for(i=1; i<argc; i++){\n@@ -197230,7 +207509,23 @@\n-    if( zPath==0 ) goto remove_done;\n-    pNode = jsonLookup(&x, zPath, 0, ctx);\n-    if( x.nErr ) goto remove_done;\n-    if( pNode ) pNode->jnFlags |= JNODE_REMOVE;\n-  }\n-  if( (x.aNode[0].jnFlags & JNODE_REMOVE)==0 ){\n-    jsonReturnJson(x.aNode, ctx, 0);\n+    if( zPath==0 ){\n+      goto json_remove_done;\n+    }\n+    if( zPath[0]!='$' ){\n+      goto json_remove_patherror;\n+    }\n+    if( zPath[1]==0 ){\n+      \/* json_remove(j,'$') returns NULL *\/\n+      goto json_remove_done;\n+    }\n+    p->eEdit = JEDIT_DEL;\n+    p->delta = 0;\n+    rc = jsonLookupStep(p, 0, zPath+1, 0);\n+    if( JSON_LOOKUP_ISERROR(rc) ){\n+      if( rc==JSON_LOOKUP_NOTFOUND ){\n+        continue;  \/* No-op *\/\n+      }else if( rc==JSON_LOOKUP_PATHERROR ){\n+        jsonBadPathError(ctx, zPath);\n+      }else{\n+        sqlite3_result_error(ctx, \"malformed JSON\", -1);\n+      }\n+      goto json_remove_done;\n+    }\n@@ -197238,2 +207533,10 @@\n-remove_done:\n-  jsonParseReset(&x);\n+  jsonReturnParse(ctx, p);\n+  jsonParseFree(p);\n+  return;\n+\n+json_remove_patherror:\n+  jsonBadPathError(ctx, zPath);\n+\n+json_remove_done:\n+  jsonParseFree(p);\n+  return;\n@@ -197253,5 +207556,0 @@\n-  JsonParse x;          \/* The parse *\/\n-  JsonNode *pNode;\n-  const char *zPath;\n-  u32 i;\n-\n@@ -197263,22 +207561,1 @@\n-  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;\n-  assert( x.nNode );\n-  for(i=1; i<(u32)argc; i+=2){\n-    zPath = (const char*)sqlite3_value_text(argv[i]);\n-    pNode = jsonLookup(&x, zPath, 0, ctx);\n-    if( x.nErr ) goto replace_err;\n-    if( pNode ){\n-      assert( pNode->eU==0 || pNode->eU==1 || pNode->eU==4 );\n-      testcase( pNode->eU!=0 && pNode->eU!=1 );\n-      pNode->jnFlags |= (u8)JNODE_REPLACE;\n-      VVA( pNode->eU =  4 );\n-      pNode->u.iReplace = i + 1;\n-    }\n-  }\n-  if( x.aNode[0].jnFlags & JNODE_REPLACE ){\n-    assert( x.aNode[0].eU==4 );\n-    sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);\n-  }else{\n-    jsonReturnJson(x.aNode, ctx, argv);\n-  }\n-replace_err:\n-  jsonParseReset(&x);\n+  jsonInsertIntoBlob(ctx, argc, argv, JEDIT_REPL);\n@@ -197305,6 +207582,3 @@\n-  JsonParse x;          \/* The parse *\/\n-  JsonNode *pNode;\n-  const char *zPath;\n-  u32 i;\n-  int bApnd;\n-  int bIsSet = sqlite3_user_data(ctx)!=0;\n+\n+  int flags = SQLITE_PTR_TO_INT(sqlite3_user_data(ctx));\n+  int bIsSet = (flags&JSON_ISSET)!=0;\n@@ -197317,27 +207591,1 @@\n-  if( jsonParse(&x, ctx, (const char*)sqlite3_value_text(argv[0])) ) return;\n-  assert( x.nNode );\n-  for(i=1; i<(u32)argc; i+=2){\n-    zPath = (const char*)sqlite3_value_text(argv[i]);\n-    bApnd = 0;\n-    pNode = jsonLookup(&x, zPath, &bApnd, ctx);\n-    if( x.oom ){\n-      sqlite3_result_error_nomem(ctx);\n-      goto jsonSetDone;\n-    }else if( x.nErr ){\n-      goto jsonSetDone;\n-    }else if( pNode && (bApnd || bIsSet) ){\n-      testcase( pNode->eU!=0 && pNode->eU!=1 );\n-      assert( pNode->eU!=3 && pNode->eU!=5 );\n-      VVA( pNode->eU = 4 );\n-      pNode->jnFlags |= (u8)JNODE_REPLACE;\n-      pNode->u.iReplace = i + 1;\n-    }\n-  }\n-  if( x.aNode[0].jnFlags & JNODE_REPLACE ){\n-    assert( x.aNode[0].eU==4 );\n-    sqlite3_result_value(ctx, argv[x.aNode[0].u.iReplace]);\n-  }else{\n-    jsonReturnJson(x.aNode, ctx, argv);\n-  }\n-jsonSetDone:\n-  jsonParseReset(&x);\n+  jsonInsertIntoBlob(ctx, argc, argv, bIsSet ? JEDIT_SET : JEDIT_INS);\n@@ -197359,2 +207607,2 @@\n-  const char *zPath;\n-  JsonNode *pNode;\n+  const char *zPath = 0;\n+  u32 i;\n@@ -197362,1 +207610,1 @@\n-  p = jsonParseCached(ctx, argv, ctx);\n+  p = jsonParseFuncArg(ctx, argv[0], 0);\n@@ -197366,1 +207614,16 @@\n-    pNode = jsonLookup(p, zPath, 0, ctx);\n+    if( zPath==0 ) goto json_type_done;\n+    if( zPath[0]!='$' ){\n+      jsonBadPathError(ctx, zPath);\n+      goto json_type_done;\n+    }\n+    i = jsonLookupStep(p, 0, zPath+1, 0);\n+    if( JSON_LOOKUP_ISERROR(i) ){\n+      if( i==JSON_LOOKUP_NOTFOUND ){\n+        \/* no-op *\/\n+      }else if( i==JSON_LOOKUP_PATHERROR ){\n+        jsonBadPathError(ctx, zPath);\n+      }else{\n+        sqlite3_result_error(ctx, \"malformed JSON\", -1);\n+      }\n+      goto json_type_done;\n+    }\n@@ -197368,4 +207631,1 @@\n-    pNode = p->aNode;\n-  }\n-  if( pNode ){\n-    sqlite3_result_text(ctx, jsonType[pNode->eType], -1, SQLITE_STATIC);\n+    i = 0;\n@@ -197373,0 +207633,3 @@\n+  sqlite3_result_text(ctx, jsonbType[p->aBlob[i]&0x0f], -1, SQLITE_STATIC);\n+json_type_done:\n+  jsonParseFree(p);\n@@ -197377,3 +207640,54 @@\n-**\n-** Return 1 if JSON is a well-formed JSON string according to RFC-7159.\n-** Return 0 otherwise.\n+** json_valid(JSON, FLAGS)\n+**\n+** Check the JSON argument to see if it is well-formed.  The FLAGS argument\n+** encodes the various constraints on what is meant by \"well-formed\":\n+**\n+**     0x01      Canonical RFC-8259 JSON text\n+**     0x02      JSON text with optional JSON-5 extensions\n+**     0x04      Superficially appears to be JSONB\n+**     0x08      Strictly well-formed JSONB\n+**\n+** If the FLAGS argument is omitted, it defaults to 1.  Useful values for\n+** FLAGS include:\n+**\n+**    1          Strict canonical JSON text\n+**    2          JSON text perhaps with JSON-5 extensions\n+**    4          Superficially appears to be JSONB\n+**    5          Canonical JSON text or superficial JSONB\n+**    6          JSON-5 text or superficial JSONB\n+**    8          Strict JSONB\n+**    9          Canonical JSON text or strict JSONB\n+**    10         JSON-5 text or strict JSONB\n+**\n+** Other flag combinations are redundant.  For example, every canonical\n+** JSON text is also well-formed JSON-5 text, so FLAG values 2 and 3\n+** are the same.  Similarly, any input that passes a strict JSONB validation\n+** will also pass the superficial validation so 12 through 15 are the same\n+** as 8 through 11 respectively.\n+**\n+** This routine runs in linear time to validate text and when doing strict\n+** JSONB validation.  Superficial JSONB validation is constant time,\n+** assuming the BLOB is already in memory.  The performance advantage\n+** of superficial JSONB validation is why that option is provided.\n+** Application developers can choose to do fast superficial validation or\n+** slower strict validation, according to their specific needs.\n+**\n+** Only the lower four bits of the FLAGS argument are currently used.\n+** Higher bits are reserved for future expansion.   To facilitate\n+** compatibility, the current implementation raises an error if any bit\n+** in FLAGS is set other than the lower four bits.\n+**\n+** The original circa 2015 implementation of the JSON routines in\n+** SQLite only supported canonical RFC-8259 JSON text and the json_valid()\n+** function only accepted one argument.  That is why the default value\n+** for the FLAGS argument is 1, since FLAGS=1 causes this routine to only\n+** recognize canonical RFC-8259 JSON text as valid.  The extra FLAGS\n+** argument was added when the JSON routines were extended to support\n+** JSON5-like extensions and binary JSONB stored in BLOBs.\n+**\n+** Return Values:\n+**\n+**   *   Raise an error if FLAGS is outside the range of 1 to 15.\n+**   *   Return NULL if the input is NULL\n+**   *   Return 1 if the input is well-formed.\n+**   *   Return 0 if the input is not well-formed.\n@@ -197387,3 +207701,64 @@\n-  UNUSED_PARAMETER(argc);\n-  p = jsonParseCached(ctx, argv, 0);\n-  sqlite3_result_int(ctx, p!=0);\n+  u8 flags = 1;\n+  u8 res = 0;\n+  if( argc==2 ){\n+    i64 f = sqlite3_value_int64(argv[1]);\n+    if( f<1 || f>15 ){\n+      sqlite3_result_error(ctx, \"FLAGS parameter to json_valid() must be\"\n+                                \" between 1 and 15\", -1);\n+      return;\n+    }\n+    flags = f & 0x0f;\n+  }\n+  switch( sqlite3_value_type(argv[0]) ){\n+    case SQLITE_NULL: {\n+#ifdef SQLITE_LEGACY_JSON_VALID\n+      \/* Incorrect legacy behavior was to return FALSE for a NULL input *\/\n+      sqlite3_result_int(ctx, 0);\n+#endif\n+      return;\n+    }\n+    case SQLITE_BLOB: {\n+      if( jsonFuncArgMightBeBinary(argv[0]) ){\n+        if( flags & 0x04 ){\n+          \/* Superficial checking only - accomplished by the\n+          ** jsonFuncArgMightBeBinary() call above. *\/\n+          res = 1;\n+        }else if( flags & 0x08 ){\n+          \/* Strict checking.  Check by translating BLOB->TEXT->BLOB.  If\n+          ** no errors occur, call that a \"strict check\". *\/\n+          JsonParse px;\n+          u32 iErr;\n+          memset(&px, 0, sizeof(px));\n+          px.aBlob = (u8*)sqlite3_value_blob(argv[0]);\n+          px.nBlob = sqlite3_value_bytes(argv[0]);\n+          iErr = jsonbValidityCheck(&px, 0, px.nBlob, 1);\n+          res = iErr==0;\n+        }\n+        break;\n+      }\n+      \/* Fall through into interpreting the input as text.  See note\n+      ** above at tag-20240123-a. *\/\n+      \/* no break *\/ deliberate_fall_through\n+    }\n+    default: {\n+      JsonParse px;\n+      if( (flags & 0x3)==0 ) break;\n+      memset(&px, 0, sizeof(px));\n+\n+      p = jsonParseFuncArg(ctx, argv[0], JSON_KEEPERROR);\n+      if( p ){\n+        if( p->oom ){\n+          sqlite3_result_error_nomem(ctx);\n+        }else if( p->nErr ){\n+          \/* no-op *\/\n+        }else if( (flags & 0x02)!=0 || p->hasNonstd==0 ){\n+          res = 1;\n+        }\n+        jsonParseFree(p);\n+      }else{\n+        sqlite3_result_error_nomem(ctx);\n+      }\n+      break;\n+    }\n+  }\n+  sqlite3_result_int(ctx, res);\n@@ -197392,0 +207767,55 @@\n+\/*\n+** json_error_position(JSON)\n+**\n+** If the argument is NULL, return NULL\n+**\n+** If the argument is BLOB, do a full validity check and return non-zero\n+** if the check fails.  The return value is the approximate 1-based offset\n+** to the byte of the element that contains the first error.\n+**\n+** Otherwise interpret the argument is TEXT (even if it is numeric) and\n+** return the 1-based character position for where the parser first recognized\n+** that the input was not valid JSON, or return 0 if the input text looks\n+** ok.  JSON-5 extensions are accepted.\n+*\/\n+static void jsonErrorFunc(\n+  sqlite3_context *ctx,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  i64 iErrPos = 0;       \/* Error position to be returned *\/\n+  JsonParse s;\n+\n+  assert( argc==1 );\n+  UNUSED_PARAMETER(argc);\n+  memset(&s, 0, sizeof(s));\n+  s.db = sqlite3_context_db_handle(ctx);\n+  if( jsonFuncArgMightBeBinary(argv[0]) ){\n+    s.aBlob = (u8*)sqlite3_value_blob(argv[0]);\n+    s.nBlob = sqlite3_value_bytes(argv[0]);\n+    iErrPos = (i64)jsonbValidityCheck(&s, 0, s.nBlob, 1);\n+  }else{\n+    s.zJson = (char*)sqlite3_value_text(argv[0]);\n+    if( s.zJson==0 ) return;  \/* NULL input or OOM *\/\n+    s.nJson = sqlite3_value_bytes(argv[0]);\n+    if( jsonConvertTextToBlob(&s,0) ){\n+      if( s.oom ){\n+        iErrPos = -1;\n+      }else{\n+        \/* Convert byte-offset s.iErr into a character offset *\/\n+        u32 k;\n+        assert( s.zJson!=0 );  \/* Because s.oom is false *\/\n+        for(k=0; k<s.iErr && ALWAYS(s.zJson[k]); k++){\n+          if( (s.zJson[k] & 0xc0)!=0x80 ) iErrPos++;\n+        }\n+        iErrPos++;\n+      }\n+    }\n+  }\n+  jsonParseReset(&s);\n+  if( iErrPos<0 ){\n+    sqlite3_result_error_nomem(ctx);\n+  }else{\n+    sqlite3_result_int64(ctx, iErrPos);\n+  }\n+}\n@@ -197411,1 +207841,1 @@\n-      jsonInit(pStr, ctx);\n+      jsonStringInit(pStr, ctx);\n@@ -197417,1 +207847,1 @@\n-    jsonAppendValue(pStr, argv[0]);\n+    jsonAppendSqlValue(pStr, argv[0]);\n@@ -197424,0 +207854,1 @@\n+    int flags;\n@@ -197426,3 +207857,12 @@\n-    if( pStr->bErr ){\n-      if( pStr->bErr==1 ) sqlite3_result_error_nomem(ctx);\n-      assert( pStr->bStatic );\n+    flags = SQLITE_PTR_TO_INT(sqlite3_user_data(ctx));\n+    if( pStr->eErr ){\n+      jsonReturnString(pStr, 0, 0);\n+      return;\n+    }else if( flags & JSON_BLOB ){\n+      jsonReturnStringAsBlob(pStr);\n+      if( isFinal ){\n+        if( !pStr->bStatic ) sqlite3RCStrUnref(pStr->zBuf);\n+      }else{\n+        jsonStringTrimOneChar(pStr);\n+      }\n+      return;\n@@ -197431,1 +207871,2 @@\n-                          pStr->bStatic ? SQLITE_TRANSIENT : sqlite3_free);\n+                          pStr->bStatic ? SQLITE_TRANSIENT :\n+                              sqlite3RCStrUnref);\n@@ -197435,1 +207876,1 @@\n-      pStr->nUsed--;\n+      jsonStringTrimOneChar(pStr);\n@@ -197472,1 +207913,1 @@\n-  ** always have been called to initalize it *\/\n+  ** always have been called to initialize it *\/\n@@ -197516,1 +207957,1 @@\n-      jsonInit(pStr, ctx);\n+      jsonStringInit(pStr, ctx);\n@@ -197523,1 +207964,1 @@\n-    n = (u32)sqlite3_value_bytes(argv[0]);\n+    n = sqlite3Strlen30(z);\n@@ -197526,1 +207967,1 @@\n-    jsonAppendValue(pStr, argv[1]);\n+    jsonAppendSqlValue(pStr, argv[1]);\n@@ -197533,0 +207974,1 @@\n+    int flags;\n@@ -197534,3 +207976,13 @@\n-    if( pStr->bErr ){\n-      if( pStr->bErr==1 ) sqlite3_result_error_nomem(ctx);\n-      assert( pStr->bStatic );\n+    pStr->pCtx = ctx;\n+    flags = SQLITE_PTR_TO_INT(sqlite3_user_data(ctx));\n+    if( pStr->eErr ){\n+      jsonReturnString(pStr, 0, 0);\n+      return;\n+    }else if( flags & JSON_BLOB ){\n+      jsonReturnStringAsBlob(pStr);\n+      if( isFinal ){\n+        if( !pStr->bStatic ) sqlite3RCStrUnref(pStr->zBuf);\n+      }else{\n+        jsonStringTrimOneChar(pStr);\n+      }\n+      return;\n@@ -197539,1 +207991,2 @@\n-                          pStr->bStatic ? SQLITE_TRANSIENT : sqlite3_free);\n+                          pStr->bStatic ? SQLITE_TRANSIENT :\n+                          sqlite3RCStrUnref);\n@@ -197543,1 +207996,1 @@\n-      pStr->nUsed--;\n+      jsonStringTrimOneChar(pStr);\n@@ -197563,0 +208016,9 @@\n+typedef struct JsonParent JsonParent;\n+struct JsonParent {\n+  u32 iHead;                 \/* Start of object or array *\/\n+  u32 iValue;                \/* Start of the value *\/\n+  u32 iEnd;                  \/* First byte past the end *\/\n+  u32 nPath;                 \/* Length of path *\/\n+  i64 iKey;                  \/* Key for JSONB_ARRAY *\/\n+};\n+\n@@ -197567,2 +208029,1 @@\n-  u32 iBegin;                \/* The first node of the scan *\/\n-  u32 i;                     \/* Index in sParse.aNode[] of current row *\/\n+  u32 i;                     \/* Index in sParse.aBlob[] of current row *\/\n@@ -197570,1 +208031,2 @@\n-  u8 eType;                  \/* Type of top-level element *\/\n+  u32 nRoot;                 \/* Size of the root path in bytes *\/\n+  u8 eType;                  \/* Type of the container for element i *\/\n@@ -197572,2 +208034,5 @@\n-  char *zJson;               \/* Input JSON *\/\n-  char *zRoot;               \/* Path by which to filter zJson *\/\n+  u32 nParent;               \/* Current nesting depth *\/\n+  u32 nParentAlloc;          \/* Space allocated for aParent[] *\/\n+  JsonParent *aParent;       \/* Parent elements of i *\/\n+  sqlite3 *db;               \/* Database connection *\/\n+  JsonString path;           \/* Current path *\/\n@@ -197576,0 +208041,6 @@\n+typedef struct JsonEachConnection JsonEachConnection;\n+struct JsonEachConnection {\n+  sqlite3_vtab base;         \/* Base class - must be first *\/\n+  sqlite3 *db;               \/* Database connection *\/\n+};\n+\n@@ -197585,1 +208056,1 @@\n-  sqlite3_vtab *pNew;\n+  JsonEachConnection *pNew;\n@@ -197611,1 +208082,2 @@\n-    pNew = *ppVtab = sqlite3_malloc( sizeof(*pNew) );\n+    pNew = (JsonEachConnection*)sqlite3DbMallocZero(db, sizeof(*pNew));\n+    *ppVtab = (sqlite3_vtab*)pNew;\n@@ -197613,1 +208085,0 @@\n-    memset(pNew, 0, sizeof(*pNew));\n@@ -197615,0 +208086,1 @@\n+    pNew->db = db;\n@@ -197621,1 +208093,2 @@\n-  sqlite3_free(pVtab);\n+  JsonEachConnection *p = (JsonEachConnection*)pVtab;\n+  sqlite3DbFree(p->db, pVtab);\n@@ -197627,0 +208100,1 @@\n+  JsonEachConnection *pVtab = (JsonEachConnection*)p;\n@@ -197630,1 +208104,1 @@\n-  pCur = sqlite3_malloc( sizeof(*pCur) );\n+  pCur = sqlite3DbMallocZero(pVtab->db, sizeof(*pCur));\n@@ -197632,1 +208106,2 @@\n-  memset(pCur, 0, sizeof(*pCur));\n+  pCur->db = pVtab->db;\n+  jsonStringZero(&pCur->path);\n@@ -197650,2 +208125,0 @@\n-  sqlite3_free(p->zJson);\n-  sqlite3_free(p->zRoot);\n@@ -197653,0 +208126,2 @@\n+  jsonStringReset(&p->path);\n+  sqlite3DbFree(p->db, p->aParent);\n@@ -197655,0 +208130,3 @@\n+  p->aParent = 0;\n+  p->nParent = 0;\n+  p->nParentAlloc = 0;\n@@ -197657,2 +208135,0 @@\n-  p->zJson = 0;\n-  p->zRoot = 0;\n@@ -197665,1 +208141,2 @@\n-  sqlite3_free(cur);\n+\n+  sqlite3DbFree(p->db, cur);\n@@ -197676,19 +208153,37 @@\n-\/* Advance the cursor to the next element for json_tree() *\/\n-static int jsonEachNext(sqlite3_vtab_cursor *cur){\n-  JsonEachCursor *p = (JsonEachCursor*)cur;\n-  if( p->bRecursive ){\n-    if( p->sParse.aNode[p->i].jnFlags & JNODE_LABEL ) p->i++;\n-    p->i++;\n-    p->iRowid++;\n-    if( p->i<p->iEnd ){\n-      u32 iUp = p->sParse.aUp[p->i];\n-      JsonNode *pUp = &p->sParse.aNode[iUp];\n-      p->eType = pUp->eType;\n-      if( pUp->eType==JSON_ARRAY ){\n-        assert( pUp->eU==0 || pUp->eU==3 );\n-        testcase( pUp->eU==3 );\n-        VVA( pUp->eU = 3 );\n-        if( iUp==p->i-1 ){\n-          pUp->u.iKey = 0;\n-        }else{\n-          pUp->u.iKey++;\n+\/*\n+** If the cursor is currently pointing at the label of a object entry,\n+** then return the index of the value.  For all other cases, return the\n+** current pointer position, which is the value.\n+*\/\n+static int jsonSkipLabel(JsonEachCursor *p){\n+  if( p->eType==JSONB_OBJECT ){\n+    u32 sz = 0;\n+    u32 n = jsonbPayloadSize(&p->sParse, p->i, &sz);\n+    return p->i + n + sz;\n+  }else{\n+    return p->i;\n+  }\n+}\n+\n+\/*\n+** Append the path name for the current element.\n+*\/\n+static void jsonAppendPathName(JsonEachCursor *p){\n+  assert( p->nParent>0 );\n+  assert( p->eType==JSONB_ARRAY || p->eType==JSONB_OBJECT );\n+  if( p->eType==JSONB_ARRAY ){\n+    jsonPrintf(30, &p->path, \"[%lld]\", p->aParent[p->nParent-1].iKey);\n+  }else{\n+    u32 n, sz = 0, k, i;\n+    const char *z;\n+    int needQuote = 0;\n+    n = jsonbPayloadSize(&p->sParse, p->i, &sz);\n+    k = p->i + n;\n+    z = (const char*)&p->sParse.aBlob[k];\n+    if( sz==0 || !sqlite3Isalpha(z[0]) ){\n+      needQuote = 1;\n+    }else{\n+      for(i=0; i<sz; i++){\n+        if( !sqlite3Isalnum(z[i]) ){\n+          needQuote = 1;\n+          break;\n@@ -197698,16 +208193,4 @@\n-  }else{\n-    switch( p->eType ){\n-      case JSON_ARRAY: {\n-        p->i += jsonNodeSize(&p->sParse.aNode[p->i]);\n-        p->iRowid++;\n-        break;\n-      }\n-      case JSON_OBJECT: {\n-        p->i += 1 + jsonNodeSize(&p->sParse.aNode[p->i+1]);\n-        p->iRowid++;\n-        break;\n-      }\n-      default: {\n-        p->i = p->iEnd;\n-        break;\n-      }\n+    if( needQuote ){\n+      jsonPrintf(sz+4,&p->path,\".\\\"%.*s\\\"\", sz, z);\n+    }else{\n+      jsonPrintf(sz+2,&p->path,\".%.*s\", sz, z);\n@@ -197716,1 +208199,0 @@\n-  return SQLITE_OK;\n@@ -197719,22 +208201,51 @@\n-\/* Append an object label to the JSON Path being constructed\n-** in pStr.\n-*\/\n-static void jsonAppendObjectPathElement(\n-  JsonString *pStr,\n-  JsonNode *pNode\n-){\n-  int jj, nn;\n-  const char *z;\n-  assert( pNode->eType==JSON_STRING );\n-  assert( pNode->jnFlags & JNODE_LABEL );\n-  assert( pNode->eU==1 );\n-  z = pNode->u.zJContent;\n-  nn = pNode->n;\n-  assert( nn>=2 );\n-  assert( z[0]=='\"' );\n-  assert( z[nn-1]=='\"' );\n-  if( nn>2 && sqlite3Isalpha(z[1]) ){\n-    for(jj=2; jj<nn-1 && sqlite3Isalnum(z[jj]); jj++){}\n-    if( jj==nn-1 ){\n-      z++;\n-      nn -= 2;\n+\/* Advance the cursor to the next element for json_tree() *\/\n+static int jsonEachNext(sqlite3_vtab_cursor *cur){\n+  JsonEachCursor *p = (JsonEachCursor*)cur;\n+  int rc = SQLITE_OK;\n+  if( p->bRecursive ){\n+    u8 x;\n+    u8 levelChange = 0;\n+    u32 n, sz = 0;\n+    u32 i = jsonSkipLabel(p);\n+    x = p->sParse.aBlob[i] & 0x0f;\n+    n = jsonbPayloadSize(&p->sParse, i, &sz);\n+    if( x==JSONB_OBJECT || x==JSONB_ARRAY ){\n+      JsonParent *pParent;\n+      if( p->nParent>=p->nParentAlloc ){\n+        JsonParent *pNew;\n+        u64 nNew;\n+        nNew = p->nParentAlloc*2 + 3;\n+        pNew = sqlite3DbRealloc(p->db, p->aParent, sizeof(JsonParent)*nNew);\n+        if( pNew==0 ) return SQLITE_NOMEM;\n+        p->nParentAlloc = (u32)nNew;\n+        p->aParent = pNew;\n+      }\n+      levelChange = 1;\n+      pParent = &p->aParent[p->nParent];\n+      pParent->iHead = p->i;\n+      pParent->iValue = i;\n+      pParent->iEnd = i + n + sz;\n+      pParent->iKey = -1;\n+      pParent->nPath = (u32)p->path.nUsed;\n+      if( p->eType && p->nParent ){\n+        jsonAppendPathName(p);\n+        if( p->path.eErr ) rc = SQLITE_NOMEM;\n+      }\n+      p->nParent++;\n+      p->i = i + n;\n+    }else{\n+      p->i = i + n + sz;\n+    }\n+    while( p->nParent>0 && p->i >= p->aParent[p->nParent-1].iEnd ){\n+      p->nParent--;\n+      p->path.nUsed = p->aParent[p->nParent].nPath;\n+      levelChange = 1;\n+    }\n+    if( levelChange ){\n+      if( p->nParent>0 ){\n+        JsonParent *pParent = &p->aParent[p->nParent-1];\n+        u32 iVal = pParent->iValue;\n+        p->eType = p->sParse.aBlob[iVal] & 0x0f;\n+      }else{\n+        p->eType = 0;\n+      }\n@@ -197742,0 +208253,8 @@\n+  }else{\n+    u32 n, sz = 0;\n+    u32 i = jsonSkipLabel(p);\n+    n = jsonbPayloadSize(&p->sParse, i, &sz);\n+    p->i = i + n + sz;\n+  }\n+  if( p->eType==JSONB_ARRAY && p->nParent ){\n+    p->aParent[p->nParent-1].iKey++;\n@@ -197743,1 +208262,2 @@\n-  jsonPrintf(nn+2, pStr, \".%.*s\", nn, z);\n+  p->iRowid++;\n+  return rc;\n@@ -197746,1 +208266,1 @@\n-\/* Append the name of the path for element i to pStr\n+\/* Length of the path for rowid==0 in bRecursive mode.\n@@ -197748,23 +208268,17 @@\n-static void jsonEachComputePath(\n-  JsonEachCursor *p,       \/* The cursor *\/\n-  JsonString *pStr,        \/* Write the path here *\/\n-  u32 i                    \/* Path to this element *\/\n-){\n-  JsonNode *pNode, *pUp;\n-  u32 iUp;\n-  if( i==0 ){\n-    jsonAppendChar(pStr, '$');\n-    return;\n-  }\n-  iUp = p->sParse.aUp[i];\n-  jsonEachComputePath(p, pStr, iUp);\n-  pNode = &p->sParse.aNode[i];\n-  pUp = &p->sParse.aNode[iUp];\n-  if( pUp->eType==JSON_ARRAY ){\n-    assert( pUp->eU==3 || (pUp->eU==0 && pUp->u.iKey==0) );\n-    testcase( pUp->eU==0 );\n-    jsonPrintf(30, pStr, \"[%d]\", pUp->u.iKey);\n-  }else{\n-    assert( pUp->eType==JSON_OBJECT );\n-    if( (pNode->jnFlags & JNODE_LABEL)==0 ) pNode--;\n-    jsonAppendObjectPathElement(pStr, pNode);\n+static int jsonEachPathLength(JsonEachCursor *p){\n+  u32 n = p->path.nUsed;\n+  char *z = p->path.zBuf;\n+  if( p->iRowid==0 && p->bRecursive && n>=2 ){\n+    while( n>1 ){\n+      n--;\n+      if( z[n]=='[' || z[n]=='.' ){\n+        u32 x, sz = 0;\n+        char cSaved = z[n];\n+        z[n] = 0;\n+        assert( p->sParse.eEdit==0 );\n+        x = jsonLookupStep(&p->sParse, 0, z+1, 0);\n+        z[n] = cSaved;\n+        if( JSON_LOOKUP_ISERROR(x) ) continue;\n+        if( x + jsonbPayloadSize(&p->sParse, x, &sz) == p->i ) break;\n+      }\n+    }\n@@ -197772,0 +208286,1 @@\n+  return n;\n@@ -197778,1 +208293,1 @@\n-  int i                       \/* Which column to return *\/\n+  int iColumn                 \/* Which column to return *\/\n@@ -197781,2 +208296,1 @@\n-  JsonNode *pThis = &p->sParse.aNode[p->i];\n-  switch( i ){\n+  switch( iColumn ){\n@@ -197784,9 +208298,13 @@\n-      if( p->i==0 ) break;\n-      if( p->eType==JSON_OBJECT ){\n-        jsonReturn(pThis, ctx, 0);\n-      }else if( p->eType==JSON_ARRAY ){\n-        u32 iKey;\n-        if( p->bRecursive ){\n-          if( p->iRowid==0 ) break;\n-          assert( p->sParse.aNode[p->sParse.aUp[p->i]].eU==3 );\n-          iKey = p->sParse.aNode[p->sParse.aUp[p->i]].u.iKey;\n+      if( p->nParent==0 ){\n+        u32 n, j;\n+        if( p->nRoot==1 ) break;\n+        j = jsonEachPathLength(p);\n+        n = p->nRoot - j;\n+        if( n==0 ){\n+          break;\n+        }else if( p->path.zBuf[j]=='[' ){\n+          i64 x;\n+          sqlite3Atoi64(&p->path.zBuf[j+1], &x, n-1, SQLITE_UTF8);\n+          sqlite3_result_int64(ctx, x);\n+        }else if( p->path.zBuf[j+1]=='\"' ){\n+          sqlite3_result_text(ctx, &p->path.zBuf[j+2], n-3, SQLITE_TRANSIENT);\n@@ -197794,1 +208312,1 @@\n-          iKey = p->iRowid;\n+          sqlite3_result_text(ctx, &p->path.zBuf[j+1], n-1, SQLITE_TRANSIENT);\n@@ -197796,1 +208314,7 @@\n-        sqlite3_result_int64(ctx, (sqlite3_int64)iKey);\n+        break;\n+      }\n+      if( p->eType==JSONB_OBJECT ){\n+        jsonReturnFromBlob(&p->sParse, p->i, ctx, 1);\n+      }else{\n+        assert( p->eType==JSONB_ARRAY );\n+        sqlite3_result_int64(ctx, p->aParent[p->nParent-1].iKey);\n@@ -197801,2 +208325,5 @@\n-      if( pThis->jnFlags & JNODE_LABEL ) pThis++;\n-      jsonReturn(pThis, ctx, 0);\n+      u32 i = jsonSkipLabel(p);\n+      jsonReturnFromBlob(&p->sParse, i, ctx, 1);\n+      if( (p->sParse.aBlob[i] & 0x0f)>=JSONB_ARRAY ){\n+        sqlite3_result_subtype(ctx, JSON_SUBTYPE);\n+      }\n@@ -197806,2 +208333,3 @@\n-      if( pThis->jnFlags & JNODE_LABEL ) pThis++;\n-      sqlite3_result_text(ctx, jsonType[pThis->eType], -1, SQLITE_STATIC);\n+      u32 i = jsonSkipLabel(p);\n+      u8 eType = p->sParse.aBlob[i] & 0x0f;\n+      sqlite3_result_text(ctx, jsonbType[eType], -1, SQLITE_STATIC);\n@@ -197811,3 +208339,4 @@\n-      if( pThis->jnFlags & JNODE_LABEL ) pThis++;\n-      if( pThis->eType>=JSON_ARRAY ) break;\n-      jsonReturn(pThis, ctx, 0);\n+      u32 i = jsonSkipLabel(p);\n+      if( (p->sParse.aBlob[i] & 0x0f)<JSONB_ARRAY ){\n+        jsonReturnFromBlob(&p->sParse, i, ctx, 1);\n+      }\n@@ -197817,2 +208346,1 @@\n-      sqlite3_result_int64(ctx,\n-         (sqlite3_int64)p->i + ((pThis->jnFlags & JNODE_LABEL)!=0));\n+      sqlite3_result_int64(ctx, (sqlite3_int64)p->i);\n@@ -197822,2 +208350,2 @@\n-      if( p->i>p->iBegin && p->bRecursive ){\n-        sqlite3_result_int64(ctx, (sqlite3_int64)p->sParse.aUp[p->i]);\n+      if( p->nParent>0 && p->bRecursive ){\n+        sqlite3_result_int64(ctx, p->aParent[p->nParent-1].iHead);\n@@ -197828,17 +208356,5 @@\n-      JsonString x;\n-      jsonInit(&x, ctx);\n-      if( p->bRecursive ){\n-        jsonEachComputePath(p, &x, p->i);\n-      }else{\n-        if( p->zRoot ){\n-          jsonAppendRaw(&x, p->zRoot, (int)strlen(p->zRoot));\n-        }else{\n-          jsonAppendChar(&x, '$');\n-        }\n-        if( p->eType==JSON_ARRAY ){\n-          jsonPrintf(30, &x, \"[%d]\", p->iRowid);\n-        }else if( p->eType==JSON_OBJECT ){\n-          jsonAppendObjectPathElement(&x, pThis);\n-        }\n-      }\n-      jsonResult(&x);\n+      u64 nBase = p->path.nUsed;\n+      if( p->nParent ) jsonAppendPathName(p);\n+      sqlite3_result_text64(ctx, p->path.zBuf, p->path.nUsed,\n+                            SQLITE_TRANSIENT, SQLITE_UTF8);\n+      p->path.nUsed = nBase;\n@@ -197848,10 +208364,4 @@\n-      if( p->bRecursive ){\n-        JsonString x;\n-        jsonInit(&x, ctx);\n-        jsonEachComputePath(p, &x, p->sParse.aUp[p->i]);\n-        jsonResult(&x);\n-        break;\n-      }\n-      \/* For json_each() path and root are the same so fall through\n-      ** into the root case *\/\n-      \/* no break *\/ deliberate_fall_through\n+      u32 n = jsonEachPathLength(p);\n+      sqlite3_result_text64(ctx, p->path.zBuf, n,\n+                            SQLITE_TRANSIENT, SQLITE_UTF8);\n+      break;\n@@ -197860,3 +208370,1 @@\n-      const char *zRoot = p->zRoot;\n-      if( zRoot==0 ) zRoot = \"$\";\n-      sqlite3_result_text(ctx, zRoot, -1, SQLITE_STATIC);\n+      sqlite3_result_text(ctx, p->path.zBuf, p->nRoot, SQLITE_STATIC);\n@@ -197866,2 +208374,6 @@\n-      assert( i==JEACH_JSON );\n-      sqlite3_result_text(ctx, p->sParse.zJson, -1, SQLITE_STATIC);\n+      if( p->sParse.zJson==0 ){\n+        sqlite3_result_blob(ctx, p->sParse.aBlob, p->sParse.nBlob,\n+                            SQLITE_TRANSIENT);\n+      }else{\n+        sqlite3_result_text(ctx, p->sParse.zJson, -1, SQLITE_TRANSIENT);\n+      }\n@@ -197917,0 +208429,7 @@\n+  if( pIdxInfo->nOrderBy>0\n+   && pIdxInfo->aOrderBy[0].iColumn<0\n+   && pIdxInfo->aOrderBy[0].desc==0\n+  ){\n+    pIdxInfo->orderByConsumed = 1;\n+  }\n+\n@@ -197951,1 +208470,0 @@\n-  const char *z;\n@@ -197953,1 +208471,1 @@\n-  sqlite3_int64 n;\n+  u32 i, n, sz;\n@@ -197959,12 +208477,12 @@\n-  z = (const char*)sqlite3_value_text(argv[0]);\n-  if( z==0 ) return SQLITE_OK;\n-  n = sqlite3_value_bytes(argv[0]);\n-  p->zJson = sqlite3_malloc64( n+1 );\n-  if( p->zJson==0 ) return SQLITE_NOMEM;\n-  memcpy(p->zJson, z, (size_t)n+1);\n-  if( jsonParse(&p->sParse, 0, p->zJson) ){\n-    int rc = SQLITE_NOMEM;\n-    if( p->sParse.oom==0 ){\n-      sqlite3_free(cur->pVtab->zErrMsg);\n-      cur->pVtab->zErrMsg = sqlite3_mprintf(\"malformed JSON\");\n-      if( cur->pVtab->zErrMsg ) rc = SQLITE_ERROR;\n+  memset(&p->sParse, 0, sizeof(p->sParse));\n+  p->sParse.nJPRef = 1;\n+  p->sParse.db = p->db;\n+  if( jsonFuncArgMightBeBinary(argv[0]) ){\n+    p->sParse.nBlob = sqlite3_value_bytes(argv[0]);\n+    p->sParse.aBlob = (u8*)sqlite3_value_blob(argv[0]);\n+  }else{\n+    p->sParse.zJson = (char*)sqlite3_value_text(argv[0]);\n+    p->sParse.nJson = sqlite3_value_bytes(argv[0]);\n+    if( p->sParse.zJson==0 ){\n+      p->i = p->iEnd = 0;\n+      return SQLITE_OK;\n@@ -197972,19 +208490,3 @@\n-    jsonEachCursorReset(p);\n-    return rc;\n-  }else if( p->bRecursive && jsonParseFindParents(&p->sParse) ){\n-    jsonEachCursorReset(p);\n-    return SQLITE_NOMEM;\n-  }else{\n-    JsonNode *pNode = 0;\n-    if( idxNum==3 ){\n-      const char *zErr = 0;\n-      zRoot = (const char*)sqlite3_value_text(argv[1]);\n-      if( zRoot==0 ) return SQLITE_OK;\n-      n = sqlite3_value_bytes(argv[1]);\n-      p->zRoot = sqlite3_malloc64( n+1 );\n-      if( p->zRoot==0 ) return SQLITE_NOMEM;\n-      memcpy(p->zRoot, zRoot, (size_t)n+1);\n-      if( zRoot[0]!='$' ){\n-        zErr = zRoot;\n-      }else{\n-        pNode = jsonLookupStep(&p->sParse, 0, p->zRoot+1, 0, &zErr);\n+    if( jsonConvertTextToBlob(&p->sParse, 0) ){\n+      if( p->sParse.oom ){\n+        return SQLITE_NOMEM;\n@@ -197992,1 +208494,25 @@\n-      if( zErr ){\n+      goto json_each_malformed_input;\n+    }\n+  }\n+  if( idxNum==3 ){\n+    zRoot = (const char*)sqlite3_value_text(argv[1]);\n+    if( zRoot==0 ) return SQLITE_OK;\n+    if( zRoot[0]!='$' ){\n+      sqlite3_free(cur->pVtab->zErrMsg);\n+      cur->pVtab->zErrMsg = jsonBadPathError(0, zRoot);\n+      jsonEachCursorReset(p);\n+      return cur->pVtab->zErrMsg ? SQLITE_ERROR : SQLITE_NOMEM;\n+    }\n+    p->nRoot = sqlite3Strlen30(zRoot);\n+    if( zRoot[1]==0 ){\n+      i = p->i = 0;\n+      p->eType = 0;\n+    }else{\n+      i = jsonLookupStep(&p->sParse, 0, zRoot+1, 0);\n+      if( JSON_LOOKUP_ISERROR(i) ){\n+        if( i==JSON_LOOKUP_NOTFOUND ){\n+          p->i = 0;\n+          p->eType = 0;\n+          p->iEnd = 0;\n+          return SQLITE_OK;\n+        }\n@@ -197994,1 +208520,1 @@\n-        cur->pVtab->zErrMsg = jsonPathSyntaxError(zErr);\n+        cur->pVtab->zErrMsg = jsonBadPathError(0, zRoot);\n@@ -197997,2 +208523,0 @@\n-      }else if( pNode==0 ){\n-        return SQLITE_OK;\n@@ -198000,15 +208524,3 @@\n-    }else{\n-      pNode = p->sParse.aNode;\n-    }\n-    p->iBegin = p->i = (int)(pNode - p->sParse.aNode);\n-    p->eType = pNode->eType;\n-    if( p->eType>=JSON_ARRAY ){\n-      assert( pNode->eU==0 );\n-      VVA( pNode->eU = 3 );\n-      pNode->u.iKey = 0;\n-      p->iEnd = p->i + pNode->n + 1;\n-      if( p->bRecursive ){\n-        p->eType = p->sParse.aNode[p->sParse.aUp[p->i]].eType;\n-        if( p->i>0 && (p->sParse.aNode[p->i-1].jnFlags & JNODE_LABEL)!=0 ){\n-          p->i--;\n-        }\n+      if( p->sParse.iLabel ){\n+        p->i = p->sParse.iLabel;\n+        p->eType = JSONB_OBJECT;\n@@ -198016,5 +208528,25 @@\n-        p->i++;\n-      }\n-    }else{\n-      p->iEnd = p->i+1;\n-    }\n+        p->i = i;\n+        p->eType = JSONB_ARRAY;\n+      }\n+    }\n+    jsonAppendRaw(&p->path, zRoot, p->nRoot);\n+  }else{\n+    i = p->i = 0;\n+    p->eType = 0;\n+    p->nRoot = 1;\n+    jsonAppendRaw(&p->path, \"$\", 1);\n+  }\n+  p->nParent = 0;\n+  n = jsonbPayloadSize(&p->sParse, i, &sz);\n+  p->iEnd = i+n+sz;\n+  if( (p->sParse.aBlob[i] & 0x0f)>=JSONB_ARRAY && !p->bRecursive ){\n+    p->i = i + n;\n+    p->eType = p->sParse.aBlob[i] & 0x0f;\n+    p->aParent = sqlite3DbMallocZero(p->db, sizeof(JsonParent));\n+    if( p->aParent==0 ) return SQLITE_NOMEM;\n+    p->nParent = 1;\n+    p->nParentAlloc = 1;\n+    p->aParent[0].iKey = 0;\n+    p->aParent[0].iEnd = p->iEnd;\n+    p->aParent[0].iHead = p->i;\n+    p->aParent[0].iValue = i;\n@@ -198023,0 +208555,6 @@\n+\n+json_each_malformed_input:\n+  sqlite3_free(cur->pVtab->zErrMsg);\n+  cur->pVtab->zErrMsg = sqlite3_mprintf(\"malformed JSON\");\n+  jsonEachCursorReset(p);\n+  return cur->pVtab->zErrMsg ? SQLITE_ERROR : SQLITE_NOMEM;\n@@ -198050,1 +208588,2 @@\n-  0                          \/* xShadowName *\/\n+  0,                         \/* xShadowName *\/\n+  0                          \/* xIntegrity *\/\n@@ -198078,1 +208617,2 @@\n-  0                          \/* xShadowName *\/\n+  0,                         \/* xShadowName *\/\n+  0                          \/* xIntegrity *\/\n@@ -198089,17 +208629,34 @@\n-    JFUNCTION(json,               1, 0,  jsonRemoveFunc),\n-    JFUNCTION(json_array,        -1, 0,  jsonArrayFunc),\n-    JFUNCTION(json_array_length,  1, 0,  jsonArrayLengthFunc),\n-    JFUNCTION(json_array_length,  2, 0,  jsonArrayLengthFunc),\n-    JFUNCTION(json_extract,      -1, 0,  jsonExtractFunc),\n-    JFUNCTION(->,                 2, JSON_JSON, jsonExtractFunc),\n-    JFUNCTION(->>,                2, JSON_SQL, jsonExtractFunc),\n-    JFUNCTION(json_insert,       -1, 0,  jsonSetFunc),\n-    JFUNCTION(json_object,       -1, 0,  jsonObjectFunc),\n-    JFUNCTION(json_patch,         2, 0,  jsonPatchFunc),\n-    JFUNCTION(json_quote,         1, 0,  jsonQuoteFunc),\n-    JFUNCTION(json_remove,       -1, 0,  jsonRemoveFunc),\n-    JFUNCTION(json_replace,      -1, 0,  jsonReplaceFunc),\n-    JFUNCTION(json_set,          -1, JSON_ISSET,  jsonSetFunc),\n-    JFUNCTION(json_type,          1, 0,  jsonTypeFunc),\n-    JFUNCTION(json_type,          2, 0,  jsonTypeFunc),\n-    JFUNCTION(json_valid,         1, 0,  jsonValidFunc),\n+    \/*   sqlite3_result_subtype() ----,  ,--- sqlite3_value_subtype()       *\/\n+    \/*                                |  |                                  *\/\n+    \/*             Uses cache ------, |  | ,---- Returns JSONB              *\/\n+    \/*                              | |  | |                                *\/\n+    \/*     Number of arguments ---, | |  | | ,--- Flags                     *\/\n+    \/*                            | | |  | | |                              *\/\n+    JFUNCTION(json,               1,1,1, 0,0,0,          jsonRemoveFunc),\n+    JFUNCTION(jsonb,              1,1,0, 0,1,0,          jsonRemoveFunc),\n+    JFUNCTION(json_array,        -1,0,1, 1,0,0,          jsonArrayFunc),\n+    JFUNCTION(jsonb_array,       -1,0,1, 1,1,0,          jsonArrayFunc),\n+    JFUNCTION(json_array_length,  1,1,0, 0,0,0,          jsonArrayLengthFunc),\n+    JFUNCTION(json_array_length,  2,1,0, 0,0,0,          jsonArrayLengthFunc),\n+    JFUNCTION(json_error_position,1,1,0, 0,0,0,          jsonErrorFunc),\n+    JFUNCTION(json_extract,      -1,1,1, 0,0,0,          jsonExtractFunc),\n+    JFUNCTION(jsonb_extract,     -1,1,0, 0,1,0,          jsonExtractFunc),\n+    JFUNCTION(->,                 2,1,1, 0,0,JSON_JSON,  jsonExtractFunc),\n+    JFUNCTION(->>,                2,1,0, 0,0,JSON_SQL,   jsonExtractFunc),\n+    JFUNCTION(json_insert,       -1,1,1, 1,0,0,          jsonSetFunc),\n+    JFUNCTION(jsonb_insert,      -1,1,0, 1,1,0,          jsonSetFunc),\n+    JFUNCTION(json_object,       -1,0,1, 1,0,0,          jsonObjectFunc),\n+    JFUNCTION(jsonb_object,      -1,0,1, 1,1,0,          jsonObjectFunc),\n+    JFUNCTION(json_patch,         2,1,1, 0,0,0,          jsonPatchFunc),\n+    JFUNCTION(jsonb_patch,        2,1,0, 0,1,0,          jsonPatchFunc),\n+    JFUNCTION(json_quote,         1,0,1, 1,0,0,          jsonQuoteFunc),\n+    JFUNCTION(json_remove,       -1,1,1, 0,0,0,          jsonRemoveFunc),\n+    JFUNCTION(jsonb_remove,      -1,1,0, 0,1,0,          jsonRemoveFunc),\n+    JFUNCTION(json_replace,      -1,1,1, 1,0,0,          jsonReplaceFunc),\n+    JFUNCTION(jsonb_replace,     -1,1,0, 1,1,0,          jsonReplaceFunc),\n+    JFUNCTION(json_set,          -1,1,1, 1,0,JSON_ISSET, jsonSetFunc),\n+    JFUNCTION(jsonb_set,         -1,1,0, 1,1,JSON_ISSET, jsonSetFunc),\n+    JFUNCTION(json_type,          1,1,0, 0,0,0,          jsonTypeFunc),\n+    JFUNCTION(json_type,          2,1,0, 0,0,0,          jsonTypeFunc),\n+    JFUNCTION(json_valid,         1,1,0, 0,0,0,          jsonValidFunc),\n+    JFUNCTION(json_valid,         2,1,0, 0,0,0,          jsonValidFunc),\n@@ -198107,2 +208664,1 @@\n-    JFUNCTION(json_parse,         1, 0,  jsonParseFunc),\n-    JFUNCTION(json_test1,         1, 0,  jsonTest1Func),\n+    JFUNCTION(json_parse,         1,1,0, 0,0,0,          jsonParseFunc),\n@@ -198112,1 +208668,5 @@\n-       SQLITE_SUBTYPE|SQLITE_UTF8|SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS),\n+       SQLITE_SUBTYPE|SQLITE_RESULT_SUBTYPE|SQLITE_UTF8|\n+       SQLITE_DETERMINISTIC),\n+    WAGGREGATE(jsonb_group_array, 1, JSON_BLOB, 0,\n+       jsonArrayStep, jsonArrayFinal, jsonArrayValue, jsonGroupInverse,\n+       SQLITE_SUBTYPE|SQLITE_RESULT_SUBTYPE|SQLITE_UTF8|SQLITE_DETERMINISTIC),\n@@ -198115,1 +208675,5 @@\n-       SQLITE_SUBTYPE|SQLITE_UTF8|SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS)\n+       SQLITE_SUBTYPE|SQLITE_RESULT_SUBTYPE|SQLITE_UTF8|SQLITE_DETERMINISTIC),\n+    WAGGREGATE(jsonb_group_object,2, JSON_BLOB, 0,\n+       jsonObjectStep, jsonObjectFinal, jsonObjectValue, jsonGroupInverse,\n+       SQLITE_SUBTYPE|SQLITE_RESULT_SUBTYPE|SQLITE_UTF8|\n+       SQLITE_DETERMINISTIC)\n@@ -198242,0 +208806,5 @@\n+\/* Macro to check for 4-byte alignment.  Only used inside of assert() *\/\n+#ifdef SQLITE_DEBUG\n+# define FOUR_BYTE_ALIGNED(X)  ((((char*)(X) - (char*)0) & 3)==0)\n+#endif\n+\n@@ -198307,0 +208876,1 @@\n+  char *zNodeName;            \/* Name of the %_node table *\/\n@@ -198319,1 +208889,0 @@\n-  int iReinsertHeight;        \/* Height of sub-trees Reinsert() has run on *\/\n@@ -198616,11 +209185,17 @@\n-#ifndef SQLITE_BYTEORDER\n-#if defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \\\n-    defined(__x86_64) || defined(__x86_64__) || defined(_M_X64)  ||    \\\n-    defined(_M_AMD64) || defined(_M_ARM)     || defined(__x86)   ||    \\\n-    defined(__arm__)\n-# define SQLITE_BYTEORDER    1234\n-#elif defined(sparc)    || defined(__ppc__)\n-# define SQLITE_BYTEORDER    4321\n-#else\n-# define SQLITE_BYTEORDER    0     \/* 0 means \"unknown at compile-time\" *\/\n-#endif\n+#ifndef SQLITE_BYTEORDER \/* Replicate changes at tag-20230904a *\/\n+# if defined(__BYTE_ORDER__) && __BYTE_ORDER__==__ORDER_BIG_ENDIAN__\n+#   define SQLITE_BYTEORDER 4321\n+# elif defined(__BYTE_ORDER__) && __BYTE_ORDER__==__ORDER_LITTLE_ENDIAN__\n+#   define SQLITE_BYTEORDER 1234\n+# elif defined(__BIG_ENDIAN__) && __BIG_ENDIAN__==1\n+#   define SQLITE_BYTEORDER 4321\n+# elif defined(i386)    || defined(__i386__)      || defined(_M_IX86) ||    \\\n+     defined(__x86_64)  || defined(__x86_64__)    || defined(_M_X64)  ||    \\\n+     defined(_M_AMD64)  || defined(_M_ARM)        || defined(__x86)   ||    \\\n+     defined(__ARMEL__) || defined(__AARCH64EL__) || defined(_M_ARM64)\n+#   define SQLITE_BYTEORDER 1234\n+# elif defined(sparc)   || defined(__ARMEB__)     || defined(__AARCH64EB__)\n+#   define SQLITE_BYTEORDER 4321\n+# else\n+#   define SQLITE_BYTEORDER 0\n+# endif\n@@ -198647,1 +209222,1 @@\n-  assert( ((((char*)p) - (char*)0)&3)==0 );  \/* p is always 4-byte aligned *\/\n+  assert( FOUR_BYTE_ALIGNED(p) );\n@@ -198701,1 +209276,1 @@\n-  assert( ((((char*)p) - (char*)0)&3)==0 );  \/* p is always 4-byte aligned *\/\n+  assert( FOUR_BYTE_ALIGNED(p) );\n@@ -198829,5 +209404,3 @@\n-  if( pRtree->pNodeBlob && pRtree->inWrTrans==0 && pRtree->nCursor==0 ){\n-    sqlite3_blob *pBlob = pRtree->pNodeBlob;\n-    pRtree->pNodeBlob = 0;\n-    sqlite3_blob_close(pBlob);\n-  }\n+  sqlite3_blob *pBlob = pRtree->pNodeBlob;\n+  pRtree->pNodeBlob = 0;\n+  sqlite3_blob_close(pBlob);\n@@ -198852,1 +209425,1 @@\n-    if( pParent && pParent!=pNode->pParent ){\n+    if( pParent && ALWAYS(pParent!=pNode->pParent) ){\n@@ -198872,3 +209445,2 @@\n-    char *zTab = sqlite3_mprintf(\"%s_node\", pRtree->zName);\n-    if( zTab==0 ) return SQLITE_NOMEM;\n-    rc = sqlite3_blob_open(pRtree->db, pRtree->zDb, zTab, \"data\", iNode, 0,\n+    rc = sqlite3_blob_open(pRtree->db, pRtree->zDb, pRtree->zNodeName,\n+                           \"data\", iNode, 0,\n@@ -198876,1 +209448,0 @@\n-    sqlite3_free(zTab);\n@@ -198879,1 +209450,0 @@\n-    nodeBlobReset(pRtree);\n@@ -198939,0 +209509,1 @@\n+    nodeBlobReset(pRtree);\n@@ -199083,0 +209654,1 @@\n+  assert( iCell<NCELL(pNode) );\n@@ -199272,1 +209844,3 @@\n-  nodeBlobReset(pRtree);\n+  if( pRtree->nCursor==0 && pRtree->inWrTrans==0 ){\n+    nodeBlobReset(pRtree);\n+  }\n@@ -199429,1 +210003,1 @@\n-  assert( ((((char*)pCellData) - (char*)0)&3)==0 );  \/* 4-byte aligned *\/\n+  assert( FOUR_BYTE_ALIGNED(pCellData) );\n@@ -199482,1 +210056,1 @@\n-  assert( ((((char*)pCellData) - (char*)0)&3)==0 );  \/* 4-byte aligned *\/\n+  assert( FOUR_BYTE_ALIGNED(pCellData) );\n@@ -199857,1 +210431,5 @@\n-    *pRowid = nodeGetRowid(RTREE_OF_CURSOR(pCsr), pNode, p->iCell);\n+    if( p->iCell>=NCELL(pNode) ){\n+      rc = SQLITE_ABORT;\n+    }else{\n+      *pRowid = nodeGetRowid(RTREE_OF_CURSOR(pCsr), pNode, p->iCell);\n+    }\n@@ -199875,0 +210453,1 @@\n+  if( p->iCell>=NCELL(pNode) ) return SQLITE_ABORT;\n@@ -200052,1 +210631,14 @@\n-          }else if( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){\n+          }else if( eType==SQLITE_INTEGER ){\n+            sqlite3_int64 iVal = sqlite3_value_int64(argv[ii]);\n+#ifdef SQLITE_RTREE_INT_ONLY\n+            p->u.rValue = iVal;\n+#else\n+            p->u.rValue = (double)iVal;\n+            if( iVal>=((sqlite3_int64)1)<<48\n+             || iVal<=-(((sqlite3_int64)1)<<48)\n+            ){\n+              if( p->op==RTREE_LT ) p->op = RTREE_LE;\n+              if( p->op==RTREE_GT ) p->op = RTREE_GE;\n+            }\n+#endif\n+          }else if( eType==SQLITE_FLOAT ){\n@@ -200183,0 +210775,1 @@\n+      u8 doOmit = 1;\n@@ -200184,2 +210777,2 @@\n-        case SQLITE_INDEX_CONSTRAINT_EQ:    op = RTREE_EQ;    break;\n-        case SQLITE_INDEX_CONSTRAINT_GT:    op = RTREE_GT;    break;\n+        case SQLITE_INDEX_CONSTRAINT_EQ:    op = RTREE_EQ;    doOmit = 0; break;\n+        case SQLITE_INDEX_CONSTRAINT_GT:    op = RTREE_GT;    doOmit = 0; break;\n@@ -200187,1 +210780,1 @@\n-        case SQLITE_INDEX_CONSTRAINT_LT:    op = RTREE_LT;    break;\n+        case SQLITE_INDEX_CONSTRAINT_LT:    op = RTREE_LT;    doOmit = 0; break;\n@@ -200196,1 +210789,1 @@\n-        pIdxInfo->aConstraintUsage[ii].omit = 1;\n+        pIdxInfo->aConstraintUsage[ii].omit = doOmit;\n@@ -200203,2 +210796,6 @@\n-  if( iIdx>0 && 0==(pIdxInfo->idxStr = sqlite3_mprintf(\"%s\", zIdxStr)) ){\n-    return SQLITE_NOMEM;\n+  if( iIdx>0 ){\n+    pIdxInfo->idxStr = sqlite3_malloc( iIdx+1 );\n+    if( pIdxInfo->idxStr==0 ){\n+      return SQLITE_NOMEM;\n+    }\n+    memcpy(pIdxInfo->idxStr, zIdxStr, iIdx+1);\n@@ -200283,8 +210880,11 @@\n-  int isInt = (pRtree->eCoordType==RTREE_COORD_INT32);\n-  for(ii=0; ii<pRtree->nDim2; ii+=2){\n-    RtreeCoord *a1 = &p1->aCoord[ii];\n-    RtreeCoord *a2 = &p2->aCoord[ii];\n-    if( (!isInt && (a2[0].f<a1[0].f || a2[1].f>a1[1].f))\n-     || ( isInt && (a2[0].i<a1[0].i || a2[1].i>a1[1].i))\n-    ){\n-      return 0;\n+  if( pRtree->eCoordType==RTREE_COORD_INT32 ){\n+    for(ii=0; ii<pRtree->nDim2; ii+=2){\n+      RtreeCoord *a1 = &p1->aCoord[ii];\n+      RtreeCoord *a2 = &p2->aCoord[ii];\n+      if( a2[0].i<a1[0].i || a2[1].i>a1[1].i ) return 0;\n+    }\n+  }else{\n+    for(ii=0; ii<pRtree->nDim2; ii+=2){\n+      RtreeCoord *a1 = &p1->aCoord[ii];\n+      RtreeCoord *a2 = &p2->aCoord[ii];\n+      if( a2[0].f<a1[0].f || a2[1].f>a1[1].f ) return 0;\n@@ -200296,12 +210896,0 @@\n-\/*\n-** Return the amount cell p would grow by if it were unioned with pCell.\n-*\/\n-static RtreeDValue cellGrowth(Rtree *pRtree, RtreeCell *p, RtreeCell *pCell){\n-  RtreeDValue area;\n-  RtreeCell cell;\n-  memcpy(&cell, p, sizeof(RtreeCell));\n-  area = cellArea(pRtree, &cell);\n-  cellUnion(pRtree, &cell, pCell);\n-  return (cellArea(pRtree, &cell)-area);\n-}\n-\n@@ -200354,1 +210942,1 @@\n-\n+    int bFound = 0;\n@@ -200357,1 +210945,0 @@\n-\n@@ -200359,1 +210946,0 @@\n-    RtreeCell cell;\n@@ -200362,5 +210948,3 @@\n-    RtreeCell *aCell = 0;\n-\n-    \/* Select the child node which will be enlarged the least if pCell\n-    ** is inserted into it. Resolve ties by choosing the entry with\n-    ** the smallest area.\n+    \/* First check to see if there is are any cells in pNode that completely\n+    ** contains pCell.  If two or more cells in pNode completely contain pCell\n+    ** then pick the smallest.\n@@ -200369,3 +210953,1 @@\n-      int bBest = 0;\n-      RtreeDValue growth;\n-      RtreeDValue area;\n+      RtreeCell cell;\n@@ -200373,4 +210955,7 @@\n-      growth = cellGrowth(pRtree, &cell, pCell);\n-      area = cellArea(pRtree, &cell);\n-      if( iCell==0||growth<fMinGrowth||(growth==fMinGrowth && area<fMinArea) ){\n-        bBest = 1;\n+      if( cellContains(pRtree, &cell, pCell) ){\n+        RtreeDValue area = cellArea(pRtree, &cell);\n+        if( bFound==0 || area<fMinArea ){\n+          iBest = cell.iRowid;\n+          fMinArea = area;\n+          bFound = 1;\n+        }\n@@ -200378,4 +210963,22 @@\n-      if( bBest ){\n-        fMinGrowth = growth;\n-        fMinArea = area;\n-        iBest = cell.iRowid;\n+    }\n+    if( !bFound ){\n+      \/* No cells of pNode will completely contain pCell.  So pick the\n+      ** cell of pNode that grows by the least amount when pCell is added.\n+      ** Break ties by selecting the smaller cell.\n+      *\/\n+      for(iCell=0; iCell<nCell; iCell++){\n+        RtreeCell cell;\n+        RtreeDValue growth;\n+        RtreeDValue area;\n+        nodeGetCell(pRtree, pNode, iCell, &cell);\n+        area = cellArea(pRtree, &cell);\n+        cellUnion(pRtree, &cell, pCell);\n+        growth = cellArea(pRtree, &cell)-area;\n+        if( iCell==0\n+         || growth<fMinGrowth\n+         || (growth==fMinGrowth && area<fMinArea)\n+        ){\n+          fMinGrowth = growth;\n+          fMinArea = area;\n+          iBest = cell.iRowid;\n+        }\n@@ -200385,1 +210988,0 @@\n-    sqlite3_free(aCell);\n@@ -200458,71 +211060,0 @@\n-\/*\n-** Arguments aIdx, aDistance and aSpare all point to arrays of size\n-** nIdx. The aIdx array contains the set of integers from 0 to\n-** (nIdx-1) in no particular order. This function sorts the values\n-** in aIdx according to the indexed values in aDistance. For\n-** example, assuming the inputs:\n-**\n-**   aIdx      = { 0,   1,   2,   3 }\n-**   aDistance = { 5.0, 2.0, 7.0, 6.0 }\n-**\n-** this function sets the aIdx array to contain:\n-**\n-**   aIdx      = { 0,   1,   2,   3 }\n-**\n-** The aSpare array is used as temporary working space by the\n-** sorting algorithm.\n-*\/\n-static void SortByDistance(\n-  int *aIdx,\n-  int nIdx,\n-  RtreeDValue *aDistance,\n-  int *aSpare\n-){\n-  if( nIdx>1 ){\n-    int iLeft = 0;\n-    int iRight = 0;\n-\n-    int nLeft = nIdx\/2;\n-    int nRight = nIdx-nLeft;\n-    int *aLeft = aIdx;\n-    int *aRight = &aIdx[nLeft];\n-\n-    SortByDistance(aLeft, nLeft, aDistance, aSpare);\n-    SortByDistance(aRight, nRight, aDistance, aSpare);\n-\n-    memcpy(aSpare, aLeft, sizeof(int)*nLeft);\n-    aLeft = aSpare;\n-\n-    while( iLeft<nLeft || iRight<nRight ){\n-      if( iLeft==nLeft ){\n-        aIdx[iLeft+iRight] = aRight[iRight];\n-        iRight++;\n-      }else if( iRight==nRight ){\n-        aIdx[iLeft+iRight] = aLeft[iLeft];\n-        iLeft++;\n-      }else{\n-        RtreeDValue fLeft = aDistance[aLeft[iLeft]];\n-        RtreeDValue fRight = aDistance[aRight[iRight]];\n-        if( fLeft<fRight ){\n-          aIdx[iLeft+iRight] = aLeft[iLeft];\n-          iLeft++;\n-        }else{\n-          aIdx[iLeft+iRight] = aRight[iRight];\n-          iRight++;\n-        }\n-      }\n-    }\n-\n-#if 0\n-    \/* Check that the sort worked *\/\n-    {\n-      int jj;\n-      for(jj=1; jj<nIdx; jj++){\n-        RtreeDValue left = aDistance[aIdx[jj-1]];\n-        RtreeDValue right = aDistance[aIdx[jj]];\n-        assert( left<=right );\n-      }\n-    }\n-#endif\n-  }\n-}\n@@ -201013,101 +211544,0 @@\n-static int Reinsert(\n-  Rtree *pRtree,\n-  RtreeNode *pNode,\n-  RtreeCell *pCell,\n-  int iHeight\n-){\n-  int *aOrder;\n-  int *aSpare;\n-  RtreeCell *aCell;\n-  RtreeDValue *aDistance;\n-  int nCell;\n-  RtreeDValue aCenterCoord[RTREE_MAX_DIMENSIONS];\n-  int iDim;\n-  int ii;\n-  int rc = SQLITE_OK;\n-  int n;\n-\n-  memset(aCenterCoord, 0, sizeof(RtreeDValue)*RTREE_MAX_DIMENSIONS);\n-\n-  nCell = NCELL(pNode)+1;\n-  n = (nCell+1)&(~1);\n-\n-  \/* Allocate the buffers used by this operation. The allocation is\n-  ** relinquished before this function returns.\n-  *\/\n-  aCell = (RtreeCell *)sqlite3_malloc64(n * (\n-    sizeof(RtreeCell)     +         \/* aCell array *\/\n-    sizeof(int)           +         \/* aOrder array *\/\n-    sizeof(int)           +         \/* aSpare array *\/\n-    sizeof(RtreeDValue)             \/* aDistance array *\/\n-  ));\n-  if( !aCell ){\n-    return SQLITE_NOMEM;\n-  }\n-  aOrder    = (int *)&aCell[n];\n-  aSpare    = (int *)&aOrder[n];\n-  aDistance = (RtreeDValue *)&aSpare[n];\n-\n-  for(ii=0; ii<nCell; ii++){\n-    if( ii==(nCell-1) ){\n-      memcpy(&aCell[ii], pCell, sizeof(RtreeCell));\n-    }else{\n-      nodeGetCell(pRtree, pNode, ii, &aCell[ii]);\n-    }\n-    aOrder[ii] = ii;\n-    for(iDim=0; iDim<pRtree->nDim; iDim++){\n-      aCenterCoord[iDim] += DCOORD(aCell[ii].aCoord[iDim*2]);\n-      aCenterCoord[iDim] += DCOORD(aCell[ii].aCoord[iDim*2+1]);\n-    }\n-  }\n-  for(iDim=0; iDim<pRtree->nDim; iDim++){\n-    aCenterCoord[iDim] = (aCenterCoord[iDim]\/(nCell*(RtreeDValue)2));\n-  }\n-\n-  for(ii=0; ii<nCell; ii++){\n-    aDistance[ii] = RTREE_ZERO;\n-    for(iDim=0; iDim<pRtree->nDim; iDim++){\n-      RtreeDValue coord = (DCOORD(aCell[ii].aCoord[iDim*2+1]) -\n-                               DCOORD(aCell[ii].aCoord[iDim*2]));\n-      aDistance[ii] += (coord-aCenterCoord[iDim])*(coord-aCenterCoord[iDim]);\n-    }\n-  }\n-\n-  SortByDistance(aOrder, nCell, aDistance, aSpare);\n-  nodeZero(pRtree, pNode);\n-\n-  for(ii=0; rc==SQLITE_OK && ii<(nCell-(RTREE_MINCELLS(pRtree)+1)); ii++){\n-    RtreeCell *p = &aCell[aOrder[ii]];\n-    nodeInsertCell(pRtree, pNode, p);\n-    if( p->iRowid==pCell->iRowid ){\n-      if( iHeight==0 ){\n-        rc = rowidWrite(pRtree, p->iRowid, pNode->iNode);\n-      }else{\n-        rc = parentWrite(pRtree, p->iRowid, pNode->iNode);\n-      }\n-    }\n-  }\n-  if( rc==SQLITE_OK ){\n-    rc = fixBoundingBox(pRtree, pNode);\n-  }\n-  for(; rc==SQLITE_OK && ii<nCell; ii++){\n-    \/* Find a node to store this cell in. pNode->iNode currently contains\n-    ** the height of the sub-tree headed by the cell.\n-    *\/\n-    RtreeNode *pInsert;\n-    RtreeCell *p = &aCell[aOrder[ii]];\n-    rc = ChooseLeaf(pRtree, p, iHeight, &pInsert);\n-    if( rc==SQLITE_OK ){\n-      int rc2;\n-      rc = rtreeInsertCell(pRtree, pInsert, p, iHeight);\n-      rc2 = nodeRelease(pRtree, pInsert);\n-      if( rc==SQLITE_OK ){\n-        rc = rc2;\n-      }\n-    }\n-  }\n-\n-  sqlite3_free(aCell);\n-  return rc;\n-}\n-\n@@ -201134,6 +211564,1 @@\n-    if( iHeight<=pRtree->iReinsertHeight || pNode->iNode==1){\n-      rc = SplitNode(pRtree, pNode, pCell, iHeight);\n-    }else{\n-      pRtree->iReinsertHeight = iHeight;\n-      rc = Reinsert(pRtree, pNode, pCell, iHeight);\n-    }\n+    rc = SplitNode(pRtree, pNode, pCell, iHeight);\n@@ -201381,1 +211806,1 @@\n-  cell.iRowid = 0;  \/* Used only to suppress a compiler warning *\/\n+  memset(&cell, 0, sizeof(cell));\n@@ -201482,1 +211907,0 @@\n-      pRtree->iReinsertHeight = -1;\n@@ -201511,2 +211935,1 @@\n-  assert( pRtree->inWrTrans==0 );\n-  pRtree->inWrTrans++;\n+  pRtree->inWrTrans = 1;\n@@ -201526,0 +211949,3 @@\n+static int rtreeRollback(sqlite3_vtab *pVtab){\n+  return rtreeEndTransaction(pVtab);\n+}\n@@ -201623,0 +212049,3 @@\n+\/* Forward declaration *\/\n+static int rtreeIntegrity(sqlite3_vtab*, const char*, const char*, int, char**);\n+\n@@ -201624,1 +212053,1 @@\n-  3,                          \/* iVersion *\/\n+  4,                          \/* iVersion *\/\n@@ -201641,1 +212070,1 @@\n-  rtreeEndTransaction,        \/* xRollback - rollback transaction *\/\n+  rtreeRollback,              \/* xRollback - rollback transaction *\/\n@@ -201647,1 +212076,2 @@\n-  rtreeShadowName             \/* xShadowName *\/\n+  rtreeShadowName,            \/* xShadowName *\/\n+  rtreeIntegrity              \/* xIntegrity *\/\n@@ -201740,1 +212170,1 @@\n-  if( pRtree->nAux ){\n+  if( pRtree->nAux && rc!=SQLITE_NOMEM ){\n@@ -201903,0 +212333,2 @@\n+  sqlite3_vtab_config(db, SQLITE_VTAB_INNOCUOUS);\n+\n@@ -201907,1 +212339,1 @@\n-  pRtree = (Rtree *)sqlite3_malloc64(sizeof(Rtree)+nDb+nName+2);\n+  pRtree = (Rtree *)sqlite3_malloc64(sizeof(Rtree)+nDb+nName*2+8);\n@@ -201911,1 +212343,1 @@\n-  memset(pRtree, 0, sizeof(Rtree)+nDb+nName+2);\n+  memset(pRtree, 0, sizeof(Rtree)+nDb+nName*2+8);\n@@ -201916,0 +212348,1 @@\n+  pRtree->zNodeName = &pRtree->zName[nName+1];\n@@ -201919,0 +212352,2 @@\n+  memcpy(pRtree->zNodeName, argv[2], nName);\n+  memcpy(&pRtree->zNodeName[nName], \"_node\", 6);\n@@ -202415,1 +212850,0 @@\n-  int bEnd = 0;                   \/* True if transaction should be closed *\/\n@@ -202424,8 +212858,0 @@\n-  \/* If there is not already an open transaction, open one now. This is\n-  ** to ensure that the queries run as part of this integrity-check operate\n-  ** on a consistent snapshot.  *\/\n-  if( sqlite3_get_autocommit(db) ){\n-    check.rc = sqlite3_exec(db, \"BEGIN\", 0, 0, 0);\n-    bEnd = 1;\n-  }\n-\n@@ -202433,9 +212859,7 @@\n-  if( check.rc==SQLITE_OK ){\n-    pStmt = rtreeCheckPrepare(&check, \"SELECT * FROM %Q.'%q_rowid'\", zDb, zTab);\n-    if( pStmt ){\n-      nAux = sqlite3_column_count(pStmt) - 2;\n-      sqlite3_finalize(pStmt);\n-    }else\n-    if( check.rc!=SQLITE_NOMEM ){\n-      check.rc = SQLITE_OK;\n-    }\n+  pStmt = rtreeCheckPrepare(&check, \"SELECT * FROM %Q.'%q_rowid'\", zDb, zTab);\n+  if( pStmt ){\n+    nAux = sqlite3_column_count(pStmt) - 2;\n+    sqlite3_finalize(pStmt);\n+  }else\n+  if( check.rc!=SQLITE_NOMEM ){\n+    check.rc = SQLITE_OK;\n@@ -202472,5 +212896,0 @@\n-  \/* If one was opened, close the transaction *\/\n-  if( bEnd ){\n-    int rc = sqlite3_exec(db, \"END\", 0, 0, 0);\n-    if( check.rc==SQLITE_OK ) check.rc = rc;\n-  }\n@@ -202481,0 +212900,25 @@\n+\/*\n+** Implementation of the xIntegrity method for Rtree.\n+*\/\n+static int rtreeIntegrity(\n+  sqlite3_vtab *pVtab,   \/* The virtual table to check *\/\n+  const char *zSchema,   \/* Schema in which the virtual table lives *\/\n+  const char *zName,     \/* Name of the virtual table *\/\n+  int isQuick,           \/* True for a quick_check *\/\n+  char **pzErr           \/* Write results here *\/\n+){\n+  Rtree *pRtree = (Rtree*)pVtab;\n+  int rc;\n+  assert( pzErr!=0 && *pzErr==0 );\n+  UNUSED_PARAMETER(zSchema);\n+  UNUSED_PARAMETER(zName);\n+  UNUSED_PARAMETER(isQuick);\n+  rc = rtreeCheckTable(pRtree->db, pRtree->zDb, pRtree->zName, pzErr);\n+  if( rc==SQLITE_OK && *pzErr ){\n+    *pzErr = sqlite3_mprintf(\"In RTree %s.%s:\\n%z\",\n+                 pRtree->zDb, pRtree->zName, *pzErr);\n+    if( (*pzErr)==0 ) rc = SQLITE_NOMEM;\n+  }\n+  return rc;\n+}\n+\n@@ -202854,1 +213298,1 @@\n-   && (nByte = sqlite3_value_bytes(pVal))>=(4+6*sizeof(GeoCoord))\n+   && (nByte = sqlite3_value_bytes(pVal))>=(int)(4+6*sizeof(GeoCoord))\n@@ -202912,0 +213356,1 @@\n+  (void)argc;\n@@ -202931,0 +213376,1 @@\n+  (void)argc;\n@@ -203012,0 +213458,1 @@\n+  (void)argc;\n@@ -203062,0 +213509,1 @@\n+  (void)argc;\n@@ -203087,0 +213535,1 @@\n+  (void)argc;\n@@ -203141,0 +213590,1 @@\n+  (void)argc;\n@@ -203250,0 +213700,1 @@\n+  (void)argc;\n@@ -203277,0 +213728,1 @@\n+  (void)argc;\n@@ -203365,0 +213817,2 @@\n+  (void)argc;\n+\n@@ -203404,0 +213858,1 @@\n+  (void)argc;\n@@ -203734,0 +214189,1 @@\n+  (void)argc;\n@@ -203754,0 +214210,2 @@\n+  (void)context;\n+  (void)argc;\n@@ -203756,0 +214214,2 @@\n+#else\n+  (void)argv;\n@@ -203783,0 +214243,1 @@\n+  (void)pAux;\n@@ -203785,0 +214246,1 @@\n+  sqlite3_vtab_config(db, SQLITE_VTAB_INNOCUOUS);\n@@ -203789,1 +214251,1 @@\n-  pRtree = (Rtree *)sqlite3_malloc64(sizeof(Rtree)+nDb+nName+2);\n+  pRtree = (Rtree *)sqlite3_malloc64(sizeof(Rtree)+nDb+nName*2+8);\n@@ -203793,1 +214255,1 @@\n-  memset(pRtree, 0, sizeof(Rtree)+nDb+nName+2);\n+  memset(pRtree, 0, sizeof(Rtree)+nDb+nName*2+8);\n@@ -203798,0 +214260,1 @@\n+  pRtree->zNodeName = &pRtree->zName[nName+1];\n@@ -203803,0 +214266,2 @@\n+  memcpy(pRtree->zNodeName, argv[2], nName);\n+  memcpy(&pRtree->zNodeName[nName], \"_node\", 6);\n@@ -203899,0 +214364,1 @@\n+  (void)idxStr;\n@@ -204025,0 +214491,1 @@\n+  (void)tab;\n@@ -204214,1 +214681,0 @@\n-      pRtree->iReinsertHeight = -1;\n@@ -204271,0 +214737,2 @@\n+  (void)pVtab;\n+  (void)nArg;\n@@ -204309,1 +214777,2 @@\n-  rtreeShadowName             \/* xShadowName *\/\n+  rtreeShadowName,            \/* xShadowName *\/\n+  rtreeIntegrity              \/* xIntegrity *\/\n@@ -204340,1 +214809,1 @@\n-  int i;\n+  unsigned int i;\n@@ -205561,1 +216030,1 @@\n-** tables or view named using the data_<target> naming scheme.\n+** tables or views named using the data_<target> naming scheme.\n@@ -205574,1 +216043,1 @@\n-** named \"rbu_rowid\". This column is mapped to the tables implicit primary\n+** named \"rbu_rowid\". This column is mapped to the table's implicit primary\n@@ -206007,0 +216476,28 @@\n+\/*\n+** As part of applying an RBU update or performing an RBU vacuum operation,\n+** the system must at one point move the *-oal file to the equivalent *-wal\n+** path. Normally, it does this by invoking POSIX function rename(2) directly.\n+** Except on WINCE platforms, where it uses win32 API MoveFileW(). This\n+** function may be used to register a callback that the RBU module will invoke\n+** instead of one of these APIs.\n+**\n+** If a callback is registered with an RBU handle, it invokes it instead\n+** of rename(2) when it needs to move a file within the file-system. The\n+** first argument passed to the xRename() callback is a copy of the second\n+** argument (pArg) passed to this function. The second is the full path\n+** to the file to move and the third the full path to which it should be\n+** moved. The callback function should return SQLITE_OK to indicate\n+** success. If an error occurs, it should return an SQLite error code.\n+** In this case the RBU operation will be abandoned and the error returned\n+** to the RBU user.\n+**\n+** Passing a NULL pointer in place of the xRename argument to this function\n+** restores the default behaviour.\n+*\/\n+SQLITE_API void sqlite3rbu_rename_handler(\n+  sqlite3rbu *pRbu,\n+  void *pArg,\n+  int (*xRename)(void *pArg, const char *zOld, const char *zNew)\n+);\n+\n+\n@@ -206374,0 +216871,2 @@\n+  void *pRenameArg;\n+  int (*xRename)(void*, const char*, const char*);\n@@ -208762,1 +219261,1 @@\n-      p->zState = rbuMPrintf(p, \"file:\/\/%s-vacuum?modeof=%s\", zFile, zFile);\n+      p->zState = rbuMPrintf(p, \"file:\/\/\/%s-vacuum?modeof=%s\", zFile, zFile);\n@@ -209010,1 +219509,1 @@\n-  **   * Attempting to xSync() the database file causes an SQLITE_INTERNAL\n+  **   * Attempting to xSync() the database file causes an SQLITE_NOTICE\n@@ -209014,1 +219513,1 @@\n-  ** checkpoint below fails with SQLITE_INTERNAL, and leaves the aFrame[]\n+  ** checkpoint below fails with SQLITE_NOTICE, and leaves the aFrame[]\n@@ -209024,1 +219523,1 @@\n-    if( rc2!=SQLITE_INTERNAL ) p->rc = rc2;\n+    if( rc2!=SQLITE_NOTICE ) p->rc = rc2;\n@@ -209070,1 +219569,1 @@\n-    return SQLITE_INTERNAL;\n+    return SQLITE_NOTICE_RBU;\n@@ -209120,0 +219619,5 @@\n+\/*\n+** This value is copied from the definition of ZIPVFS_CTRL_FILE_POINTER\n+** in zipvfs.h.\n+*\/\n+#define RBU_ZIPVFS_CTRL_FILE_POINTER 230439\n@@ -209128,1 +219632,0 @@\n-  sqlite3_file_control(db, \"main\", SQLITE_FCNTL_FILE_POINTER, &fd);\n@@ -209130,1 +219633,13 @@\n-  if( fd->pMethods ){\n+  sqlite3_file_control(db, \"main\", RBU_ZIPVFS_CTRL_FILE_POINTER, &fd);\n+  if( fd ){\n+    sqlite3_file_control(db, \"main\", SQLITE_FCNTL_FILE_POINTER, &fd);\n+    rc = fd->pMethods->xLock(fd, SQLITE_LOCK_SHARED);\n+    if( rc==SQLITE_OK ){\n+      rc = fd->pMethods->xUnlock(fd, SQLITE_LOCK_NONE);\n+    }\n+    sqlite3_file_control(db, \"main\", RBU_ZIPVFS_CTRL_FILE_POINTER, &fd);\n+  }else{\n+    sqlite3_file_control(db, \"main\", SQLITE_FCNTL_FILE_POINTER, &fd);\n+  }\n+\n+  if( rc==SQLITE_OK && fd->pMethods ){\n@@ -209222,26 +219737,1 @@\n-#if defined(_WIN32_WCE)\n-      {\n-        LPWSTR zWideOal;\n-        LPWSTR zWideWal;\n-\n-        zWideOal = rbuWinUtf8ToUnicode(zOal);\n-        if( zWideOal ){\n-          zWideWal = rbuWinUtf8ToUnicode(zWal);\n-          if( zWideWal ){\n-            if( MoveFileW(zWideOal, zWideWal) ){\n-              p->rc = SQLITE_OK;\n-            }else{\n-              p->rc = SQLITE_IOERR;\n-            }\n-            sqlite3_free(zWideWal);\n-          }else{\n-            p->rc = SQLITE_IOERR_NOMEM;\n-          }\n-          sqlite3_free(zWideOal);\n-        }else{\n-          p->rc = SQLITE_IOERR_NOMEM;\n-        }\n-      }\n-#else\n-      p->rc = rename(zOal, zWal) ? SQLITE_IOERR : SQLITE_OK;\n-#endif\n+      p->rc = p->xRename(p->pRenameArg, zOal, zWal);\n@@ -209834,1 +220324,2 @@\n-    sqlite3_vfs *pVfs = sqlite3_vfs_find(0);\n+    sqlite3_vfs *pVfs = 0;\n+    sqlite3_file_control(p->dbMain, \"main\", SQLITE_FCNTL_VFS_POINTER, &pVfs);\n@@ -209986,0 +220477,1 @@\n+    sqlite3rbu_rename_handler(p, 0, 0);\n@@ -210377,0 +220869,48 @@\n+\/*\n+** Default xRename callback for RBU.\n+*\/\n+static int xDefaultRename(void *pArg, const char *zOld, const char *zNew){\n+  int rc = SQLITE_OK;\n+#if defined(_WIN32_WCE)\n+  {\n+    LPWSTR zWideOld;\n+    LPWSTR zWideNew;\n+\n+    zWideOld = rbuWinUtf8ToUnicode(zOld);\n+    if( zWideOld ){\n+      zWideNew = rbuWinUtf8ToUnicode(zNew);\n+      if( zWideNew ){\n+        if( MoveFileW(zWideOld, zWideNew) ){\n+          rc = SQLITE_OK;\n+        }else{\n+          rc = SQLITE_IOERR;\n+        }\n+        sqlite3_free(zWideNew);\n+      }else{\n+        rc = SQLITE_IOERR_NOMEM;\n+      }\n+      sqlite3_free(zWideOld);\n+    }else{\n+      rc = SQLITE_IOERR_NOMEM;\n+    }\n+  }\n+#else\n+  rc = rename(zOld, zNew) ? SQLITE_IOERR : SQLITE_OK;\n+#endif\n+  return rc;\n+}\n+\n+SQLITE_API void sqlite3rbu_rename_handler(\n+  sqlite3rbu *pRbu,\n+  void *pArg,\n+  int (*xRename)(void *pArg, const char *zOld, const char *zNew)\n+){\n+  if( xRename ){\n+    pRbu->xRename = xRename;\n+    pRbu->pRenameArg = pArg;\n+  }else{\n+    pRbu->xRename = xDefaultRename;\n+    pRbu->pRenameArg = 0;\n+  }\n+}\n+\n@@ -210433,1 +220973,1 @@\n-**     file fail with SQLITE_INTERNAL errors.\n+**     file fail with SQLITE_NOTICE errors.\n@@ -210542,0 +221082,1 @@\n+    const sqlite3_io_methods *pMeth = p->pReal->pMethods;\n@@ -210544,1 +221085,3 @@\n-    p->pReal->pMethods->xShmUnmap(p->pReal, 0);\n+    if( pMeth->iVersion>1 && pMeth->xShmUnmap ){\n+      pMeth->xShmUnmap(p->pReal, 0);\n+    }\n@@ -210712,1 +221255,1 @@\n-      return SQLITE_INTERNAL;\n+      return SQLITE_NOTICE_RBU;\n@@ -211003,0 +221546,19 @@\n+  static sqlite3_io_methods rbuvfs_io_methods1 = {\n+    1,                            \/* iVersion *\/\n+    rbuVfsClose,                  \/* xClose *\/\n+    rbuVfsRead,                   \/* xRead *\/\n+    rbuVfsWrite,                  \/* xWrite *\/\n+    rbuVfsTruncate,               \/* xTruncate *\/\n+    rbuVfsSync,                   \/* xSync *\/\n+    rbuVfsFileSize,               \/* xFileSize *\/\n+    rbuVfsLock,                   \/* xLock *\/\n+    rbuVfsUnlock,                 \/* xUnlock *\/\n+    rbuVfsCheckReservedLock,      \/* xCheckReservedLock *\/\n+    rbuVfsFileControl,            \/* xFileControl *\/\n+    rbuVfsSectorSize,             \/* xSectorSize *\/\n+    rbuVfsDeviceCharacteristics,  \/* xDeviceCharacteristics *\/\n+    0, 0, 0, 0, 0, 0\n+  };\n+\n+\n+\n@@ -211057,0 +221619,1 @@\n+    const sqlite3_io_methods *pMeth = pFd->pReal->pMethods;\n@@ -211060,1 +221623,5 @@\n-    pFile->pMethods = &rbuvfs_io_methods;\n+    if( pMeth->iVersion<2 || pMeth->xShmLock==0 ){\n+      pFile->pMethods = &rbuvfs_io_methods1;\n+    }else{\n+      pFile->pMethods = &rbuvfs_io_methods;\n+    }\n@@ -211493,0 +222060,1 @@\n+  (void)pAux;\n@@ -211546,0 +222114,1 @@\n+  (void)tab;\n@@ -212071,0 +222640,2 @@\n+  (void)argc;\n+  (void)idxStr;\n@@ -212154,1 +222725,1 @@\n-      sqlite3_result_int(ctx, pCsr->nCell);\n+      sqlite3_result_int64(ctx, pCsr->nCell);\n@@ -212157,1 +222728,1 @@\n-      sqlite3_result_int(ctx, pCsr->nPayload);\n+      sqlite3_result_int64(ctx, pCsr->nPayload);\n@@ -212160,1 +222731,1 @@\n-      sqlite3_result_int(ctx, pCsr->nUnused);\n+      sqlite3_result_int64(ctx, pCsr->nUnused);\n@@ -212163,1 +222734,1 @@\n-      sqlite3_result_int(ctx, pCsr->nMxPayload);\n+      sqlite3_result_int64(ctx, pCsr->nMxPayload);\n@@ -212171,1 +222742,1 @@\n-      sqlite3_result_int(ctx, pCsr->szPage);\n+      sqlite3_result_int64(ctx, pCsr->szPage);\n@@ -212221,1 +222792,2 @@\n-    0                             \/* xShadowName *\/\n+    0,                            \/* xShadowName *\/\n+    0                             \/* xIntegrity *\/\n@@ -212305,0 +222877,4 @@\n+  (void)pAux;\n+  (void)argc;\n+  (void)argv;\n+  (void)pzErr;\n@@ -212307,0 +222883,1 @@\n+  sqlite3_vtab_config(db, SQLITE_VTAB_USES_ALL_SCHEMAS);\n@@ -212343,0 +222920,1 @@\n+  (void)tab;\n@@ -212389,1 +222967,0 @@\n-  sqlite3VtabUsesAllSchemas(pIdxInfo);\n@@ -212458,0 +223035,2 @@\n+  (void)idxStr;\n+\n@@ -212472,1 +223051,1 @@\n-  if( pBt==0 ) return SQLITE_OK;\n+  if( NEVER(pBt==0) ) return SQLITE_OK;\n@@ -212507,4 +223086,11 @@\n-      rc = sqlite3PagerGet(pCsr->pPager, pCsr->pgno, (DbPage**)&pDbPage, 0);\n-      if( rc==SQLITE_OK ){\n-        sqlite3_result_blob(ctx, sqlite3PagerGetData(pDbPage), pCsr->szPage,\n-                            SQLITE_TRANSIENT);\n+      if( pCsr->pgno==((PENDING_BYTE\/pCsr->szPage)+1) ){\n+        \/* The pending byte page. Assume it is zeroed out. Attempting to\n+        ** request this page from the page is an SQLITE_CORRUPT error. *\/\n+        sqlite3_result_zeroblob(ctx, pCsr->szPage);\n+      }else{\n+        rc = sqlite3PagerGet(pCsr->pPager, pCsr->pgno, (DbPage**)&pDbPage, 0);\n+        if( rc==SQLITE_OK ){\n+          sqlite3_result_blob(ctx, sqlite3PagerGetData(pDbPage), pCsr->szPage,\n+              SQLITE_TRANSIENT);\n+        }\n+        sqlite3PagerUnref(pDbPage);\n@@ -212512,1 +223098,0 @@\n-      sqlite3PagerUnref(pDbPage);\n@@ -212521,1 +223106,1 @@\n-  return SQLITE_OK;\n+  return rc;\n@@ -212547,0 +223132,1 @@\n+  (void)pRowid;\n@@ -212556,1 +223142,3 @@\n-  if( (Pgno)sqlite3_value_int(argv[1])!=pgno ){\n+  if( sqlite3_value_type(argv[0])==SQLITE_NULL\n+   || (Pgno)sqlite3_value_int(argv[1])!=pgno\n+  ){\n@@ -212561,2 +223149,2 @@\n-  iDb = zSchema ? sqlite3FindDbName(pTab->db, zSchema) : -1;\n-  if( iDb<0 ){\n+  iDb = ALWAYS(zSchema) ? sqlite3FindDbName(pTab->db, zSchema) : -1;\n+  if( NEVER(iDb<0) ){\n@@ -212567,1 +223155,1 @@\n-  if( pgno<1 || pBt==0 || pgno>sqlite3BtreeLastPage(pBt) ){\n+  if( NEVER(pgno<1) || NEVER(pBt==0) || NEVER(pgno>sqlite3BtreeLastPage(pBt)) ){\n@@ -212581,5 +223169,6 @@\n-    rc = sqlite3PagerWrite(pDbPage);\n-    if( rc==SQLITE_OK ){\n-      memcpy(sqlite3PagerGetData(pDbPage),\n-             sqlite3_value_blob(argv[3]),\n-             szPage);\n+    const void *pData = sqlite3_value_blob(argv[3]);\n+    assert( pData!=0 || pTab->db->mallocFailed );\n+    if( pData\n+     && (rc = sqlite3PagerWrite(pDbPage))==SQLITE_OK\n+    ){\n+      memcpy(sqlite3PagerGetData(pDbPage), pData, szPage);\n@@ -212607,1 +223196,1 @@\n-    if( pBt ) sqlite3BtreeBeginTrans(pBt, 1, 0);\n+    if( pBt ) (void)sqlite3BtreeBeginTrans(pBt, 1, 0);\n@@ -212641,1 +223230,2 @@\n-    0                             \/* xShadowName *\/\n+    0,                            \/* xShadowName *\/\n+    0                             \/* xIntegrity *\/\n@@ -212678,0 +223268,2 @@\n+#define SESSIONS_ROWID \"_rowid_\"\n+\n@@ -212699,0 +223291,1 @@\n+  int bImplicitPK;                \/* True to handle tables with implicit PK *\/\n@@ -212769,0 +223362,12 @@\n+**\n+** pDfltStmt:\n+**   This is only used by the sqlite3changegroup_xxx() APIs, not by\n+**   regular sqlite3_session objects. It is a SELECT statement that\n+**   selects the default value for each table column. For example,\n+**   if the table is\n+**\n+**      CREATE TABLE xx(a DEFAULT 1, b, c DEFAULT 'abc')\n+**\n+**   then this variable is the compiled version of:\n+**\n+**      SELECT 1, NULL, 'abc'\n@@ -212775,0 +223380,1 @@\n+  int bRowid;                     \/* True if this table uses rowid for PK *\/\n@@ -212776,0 +223382,1 @@\n+  const char **azDflt;            \/* Default value expressions *\/\n@@ -212780,0 +223387,1 @@\n+  sqlite3_stmt *pDfltStmt;\n@@ -212948,0 +223556,1 @@\n+  u16 nRecordField;               \/* Number of fields in aRecord[] *\/\n@@ -212973,1 +223582,1 @@\n-static int sessionVarintGet(u8 *aBuf, int *piVal){\n+static int sessionVarintGet(const u8 *aBuf, int *piVal){\n@@ -213167,0 +223776,1 @@\n+  i64 iRowid,\n@@ -213175,14 +223785,11 @@\n-  assert( *pbNullPK==0 );\n-  assert( pTab->nCol==pSession->hook.xCount(pSession->hook.pCtx) );\n-  for(i=0; i<pTab->nCol; i++){\n-    if( pTab->abPK[i] ){\n-      int rc;\n-      int eType;\n-      sqlite3_value *pVal;\n-\n-      if( bNew ){\n-        rc = pSession->hook.xNew(pSession->hook.pCtx, i, &pVal);\n-      }else{\n-        rc = pSession->hook.xOld(pSession->hook.pCtx, i, &pVal);\n-      }\n-      if( rc!=SQLITE_OK ) return rc;\n+  if( pTab->bRowid ){\n+    assert( pTab->nCol-1==pSession->hook.xCount(pSession->hook.pCtx) );\n+    h = sessionHashAppendI64(h, iRowid);\n+  }else{\n+    assert( *pbNullPK==0 );\n+    assert( pTab->nCol==pSession->hook.xCount(pSession->hook.pCtx) );\n+    for(i=0; i<pTab->nCol; i++){\n+      if( pTab->abPK[i] ){\n+        int rc;\n+        int eType;\n+        sqlite3_value *pVal;\n@@ -213190,6 +223797,2 @@\n-      eType = sqlite3_value_type(pVal);\n-      h = sessionHashAppendType(h, eType);\n-      if( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){\n-        i64 iVal;\n-        if( eType==SQLITE_INTEGER ){\n-          iVal = sqlite3_value_int64(pVal);\n+        if( bNew ){\n+          rc = pSession->hook.xNew(pSession->hook.pCtx, i, &pVal);\n@@ -213197,3 +223800,1 @@\n-          double rVal = sqlite3_value_double(pVal);\n-          assert( sizeof(iVal)==8 && sizeof(rVal)==8 );\n-          memcpy(&iVal, &rVal, 8);\n+          rc = pSession->hook.xOld(pSession->hook.pCtx, i, &pVal);\n@@ -213201,6 +223802,25 @@\n-        h = sessionHashAppendI64(h, iVal);\n-      }else if( eType==SQLITE_TEXT || eType==SQLITE_BLOB ){\n-        const u8 *z;\n-        int n;\n-        if( eType==SQLITE_TEXT ){\n-          z = (const u8 *)sqlite3_value_text(pVal);\n+        if( rc!=SQLITE_OK ) return rc;\n+\n+        eType = sqlite3_value_type(pVal);\n+        h = sessionHashAppendType(h, eType);\n+        if( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){\n+          i64 iVal;\n+          if( eType==SQLITE_INTEGER ){\n+            iVal = sqlite3_value_int64(pVal);\n+          }else{\n+            double rVal = sqlite3_value_double(pVal);\n+            assert( sizeof(iVal)==8 && sizeof(rVal)==8 );\n+            memcpy(&iVal, &rVal, 8);\n+          }\n+          h = sessionHashAppendI64(h, iVal);\n+        }else if( eType==SQLITE_TEXT || eType==SQLITE_BLOB ){\n+          const u8 *z;\n+          int n;\n+          if( eType==SQLITE_TEXT ){\n+            z = (const u8 *)sqlite3_value_text(pVal);\n+          }else{\n+            z = (const u8 *)sqlite3_value_blob(pVal);\n+          }\n+          n = sqlite3_value_bytes(pVal);\n+          if( !z && (eType!=SQLITE_BLOB || n>0) ) return SQLITE_NOMEM;\n+          h = sessionHashAppendBlob(h, n, z);\n@@ -213208,1 +223828,3 @@\n-          z = (const u8 *)sqlite3_value_blob(pVal);\n+          assert( eType==SQLITE_NULL );\n+          assert( pTab->bStat1==0 || i!=1 );\n+          *pbNullPK = 1;\n@@ -213210,7 +223832,0 @@\n-        n = sqlite3_value_bytes(pVal);\n-        if( !z && (eType!=SQLITE_BLOB || n>0) ) return SQLITE_NOMEM;\n-        h = sessionHashAppendBlob(h, n, z);\n-      }else{\n-        assert( eType==SQLITE_NULL );\n-        assert( pTab->bStat1==0 || i!=1 );\n-        *pbNullPK = 1;\n@@ -213230,2 +223845,2 @@\n-static int sessionSerialLen(u8 *a){\n-  int e = *a;\n+static int sessionSerialLen(const u8 *a){\n+  int e;\n@@ -213233,0 +223848,2 @@\n+  assert( a!=0 );\n+  e = *a;\n@@ -213499,0 +224116,1 @@\n+  i64 iRowid,                     \/* Rowid value if pTab->bRowid *\/\n@@ -213506,0 +224124,5 @@\n+  if( pTab->bRowid ){\n+    if( a[0]!=SQLITE_INTEGER ) return 0;\n+    return sessionGetI64(&a[1])==iRowid;\n+  }\n+\n@@ -213528,0 +224151,1 @@\n+      (void)rc;                   \/* Suppress warning about unused variable *\/\n@@ -213630,1 +224254,1 @@\n-**     CREATE TABLE tbl1(w, x, y, z, PRIMARY KEY(w, z));\n+**     CREATE TABLE tbl1(w, x DEFAULT 'abc', y, z, PRIMARY KEY(w, z));\n@@ -213632,1 +224256,1 @@\n-** Then the four output variables are populated as follows:\n+** Then the five output variables are populated as follows:\n@@ -213637,0 +224261,1 @@\n+**     *pazDflt = {NULL, 'abc', NULL, NULL}\n@@ -213650,1 +224275,3 @@\n-  u8 **pabPK                      \/* OUT: Array of booleans - true for PK col *\/\n+  const char ***pazDflt,          \/* OUT: Array of default value expressions *\/\n+  u8 **pabPK,                     \/* OUT: Array of booleans - true for PK col *\/\n+  int *pbRowid                    \/* OUT: True if only PK is a rowid *\/\n@@ -213661,0 +224288,1 @@\n+  char **azDflt = 0;\n@@ -213662,0 +224290,1 @@\n+  int bRowid = 0;                 \/* Set to true to use rowid as PK *\/\n@@ -213665,0 +224294,6 @@\n+  *pazCol = 0;\n+  *pabPK = 0;\n+  *pnCol = 0;\n+  if( pzTab ) *pzTab = 0;\n+  if( pazDflt ) *pazDflt = 0;\n+\n@@ -213678,4 +224313,0 @@\n-      *pazCol = 0;\n-      *pabPK = 0;\n-      *pnCol = 0;\n-      if( pzTab ) *pzTab = 0;\n@@ -213688,4 +224319,0 @@\n-    *pazCol = 0;\n-    *pabPK = 0;\n-    *pnCol = 0;\n-    if( pzTab ) *pzTab = 0;\n@@ -213698,4 +224325,0 @@\n-    *pazCol = 0;\n-    *pabPK = 0;\n-    *pnCol = 0;\n-    if( pzTab ) *pzTab = 0;\n@@ -213706,0 +224329,1 @@\n+  bRowid = (pbRowid!=0);\n@@ -213707,1 +224331,2 @@\n-    nByte += sqlite3_column_bytes(pStmt, 1);\n+    nByte += sqlite3_column_bytes(pStmt, 1);          \/* name *\/\n+    nByte += sqlite3_column_bytes(pStmt, 4);          \/* dflt_value *\/\n@@ -213709,0 +224334,1 @@\n+    if( sqlite3_column_int(pStmt, 5) ) bRowid = 0;    \/* pk *\/\n@@ -213710,0 +224336,3 @@\n+  if( nDbCol==0 ) bRowid = 0;\n+  nDbCol += bRowid;\n+  nByte += strlen(SESSIONS_ROWID);\n@@ -213713,1 +224342,1 @@\n-    nByte += nDbCol * (sizeof(const char *) + sizeof(u8) + 1);\n+    nByte += nDbCol * (sizeof(const char *)*2 + sizeof(u8) + 1 + 1);\n@@ -213717,0 +224346,2 @@\n+    }else{\n+      memset(pAlloc, 0, nByte);\n@@ -213721,1 +224352,2 @@\n-    pAlloc = (u8 *)&azCol[nDbCol];\n+    azDflt = (char**)&azCol[nDbCol];\n+    pAlloc = (u8 *)&azDflt[nDbCol];\n@@ -213731,0 +224363,8 @@\n+    if( bRowid ){\n+      size_t nName = strlen(SESSIONS_ROWID);\n+      memcpy(pAlloc, SESSIONS_ROWID, nName+1);\n+      azCol[i] = (char*)pAlloc;\n+      pAlloc += nName+1;\n+      abPK[i] = 1;\n+      i++;\n+    }\n@@ -213733,0 +224373,1 @@\n+      int nDflt = sqlite3_column_bytes(pStmt, 4);\n@@ -213734,0 +224375,2 @@\n+      const unsigned char *zDflt = sqlite3_column_text(pStmt, 4);\n+\n@@ -213738,0 +224381,7 @@\n+      if( zDflt ){\n+        memcpy(pAlloc, zDflt, nDflt+1);\n+        azDflt[i] = (char *)pAlloc;\n+        pAlloc += nDflt+1;\n+      }else{\n+        azDflt[i] = 0;\n+      }\n@@ -213742,1 +224392,0 @@\n-\n@@ -213749,1 +224398,2 @@\n-    *pazCol = (const char **)azCol;\n+    *pazCol = (const char**)azCol;\n+    if( pazDflt ) *pazDflt = (const char**)azDflt;\n@@ -213753,4 +224403,0 @@\n-    *pazCol = 0;\n-    *pabPK = 0;\n-    *pnCol = 0;\n-    if( pzTab ) *pzTab = 0;\n@@ -213759,0 +224405,1 @@\n+  if( pbRowid ) *pbRowid = bRowid;\n@@ -213764,4 +224411,3 @@\n-** This function is only called from within a pre-update handler for a\n-** write to table pTab, part of session pSession. If this is the first\n-** write to this table, initalize the SessionTable.nCol, azCol[] and\n-** abPK[] arrays accordingly.\n+** This function is called to initialize the SessionTable.nCol, azCol[]\n+** abPK[] and azDflt[] members of SessionTable object pTab. If these\n+** fields are already initilialized, this function is a no-op.\n@@ -213775,1 +224421,8 @@\n-static int sessionInitTable(sqlite3_session *pSession, SessionTable *pTab){\n+static int sessionInitTable(\n+  sqlite3_session *pSession,      \/* Optional session handle *\/\n+  SessionTable *pTab,             \/* Table object to initialize *\/\n+  sqlite3 *db,                    \/* Database handle to read schema from *\/\n+  const char *zDb                 \/* Name of db - \"main\", \"temp\" etc. *\/\n+){\n+  int rc = SQLITE_OK;\n+\n@@ -213779,2 +224432,3 @@\n-    pSession->rc = sessionTableInfo(pSession, pSession->db, pSession->zDb,\n-        pTab->zName, &pTab->nCol, 0, &pTab->azCol, &abPK\n+    rc = sessionTableInfo(pSession, db, zDb,\n+        pTab->zName, &pTab->nCol, 0, &pTab->azCol, &pTab->azDflt, &abPK,\n+        ((pSession==0 || pSession->bImplicitPK) ? &pTab->bRowid : 0)\n@@ -213782,1 +224436,1 @@\n-    if( pSession->rc==SQLITE_OK ){\n+    if( rc==SQLITE_OK ){\n@@ -213794,1 +224448,1 @@\n-      if( pSession->bEnableSize ){\n+      if( pSession && pSession->bEnableSize ){\n@@ -213801,1 +224455,308 @@\n-  return (pSession->rc || pTab->abPK==0);\n+\n+  if( pSession ){\n+    pSession->rc = rc;\n+    return (rc || pTab->abPK==0);\n+  }\n+  return rc;\n+}\n+\n+\/*\n+** Re-initialize table object pTab.\n+*\/\n+static int sessionReinitTable(sqlite3_session *pSession, SessionTable *pTab){\n+  int nCol = 0;\n+  const char **azCol = 0;\n+  const char **azDflt = 0;\n+  u8 *abPK = 0;\n+  int bRowid = 0;\n+\n+  assert( pSession->rc==SQLITE_OK );\n+\n+  pSession->rc = sessionTableInfo(pSession, pSession->db, pSession->zDb,\n+      pTab->zName, &nCol, 0, &azCol, &azDflt, &abPK,\n+      (pSession->bImplicitPK ? &bRowid : 0)\n+  );\n+  if( pSession->rc==SQLITE_OK ){\n+    if( pTab->nCol>nCol || pTab->bRowid!=bRowid ){\n+      pSession->rc = SQLITE_SCHEMA;\n+    }else{\n+      int ii;\n+      int nOldCol = pTab->nCol;\n+      for(ii=0; ii<nCol; ii++){\n+        if( ii<pTab->nCol ){\n+          if( pTab->abPK[ii]!=abPK[ii] ){\n+            pSession->rc = SQLITE_SCHEMA;\n+          }\n+        }else if( abPK[ii] ){\n+          pSession->rc = SQLITE_SCHEMA;\n+        }\n+      }\n+\n+      if( pSession->rc==SQLITE_OK ){\n+        const char **a = pTab->azCol;\n+        pTab->azCol = azCol;\n+        pTab->nCol = nCol;\n+        pTab->azDflt = azDflt;\n+        pTab->abPK = abPK;\n+        azCol = a;\n+      }\n+      if( pSession->bEnableSize ){\n+        pSession->nMaxChangesetSize += (nCol - nOldCol);\n+        pSession->nMaxChangesetSize += sessionVarintLen(nCol);\n+        pSession->nMaxChangesetSize -= sessionVarintLen(nOldCol);\n+      }\n+    }\n+  }\n+\n+  sqlite3_free((char*)azCol);\n+  return pSession->rc;\n+}\n+\n+\/*\n+** Session-change object (*pp) contains an old.* record with fewer than\n+** nCol fields. This function updates it with the default values for\n+** the missing fields.\n+*\/\n+static void sessionUpdateOneChange(\n+  sqlite3_session *pSession,      \/* For memory accounting *\/\n+  int *pRc,                       \/* IN\/OUT: Error code *\/\n+  SessionChange **pp,             \/* IN\/OUT: Change object to update *\/\n+  int nCol,                       \/* Number of columns now in table *\/\n+  sqlite3_stmt *pDflt             \/* SELECT <default-values...> *\/\n+){\n+  SessionChange *pOld = *pp;\n+\n+  while( pOld->nRecordField<nCol ){\n+    SessionChange *pNew = 0;\n+    int nByte = 0;\n+    int nIncr = 0;\n+    int iField = pOld->nRecordField;\n+    int eType = sqlite3_column_type(pDflt, iField);\n+    switch( eType ){\n+      case SQLITE_NULL:\n+        nIncr = 1;\n+        break;\n+      case SQLITE_INTEGER:\n+      case SQLITE_FLOAT:\n+        nIncr = 9;\n+        break;\n+      default: {\n+        int n = sqlite3_column_bytes(pDflt, iField);\n+        nIncr = 1 + sessionVarintLen(n) + n;\n+        assert( eType==SQLITE_TEXT || eType==SQLITE_BLOB );\n+        break;\n+      }\n+    }\n+\n+    nByte = nIncr + (sizeof(SessionChange) + pOld->nRecord);\n+    pNew = sessionMalloc64(pSession, nByte);\n+    if( pNew==0 ){\n+      *pRc = SQLITE_NOMEM;\n+      return;\n+    }else{\n+      memcpy(pNew, pOld, sizeof(SessionChange));\n+      pNew->aRecord = (u8*)&pNew[1];\n+      memcpy(pNew->aRecord, pOld->aRecord, pOld->nRecord);\n+      pNew->aRecord[pNew->nRecord++] = (u8)eType;\n+      switch( eType ){\n+        case SQLITE_INTEGER: {\n+          i64 iVal = sqlite3_column_int64(pDflt, iField);\n+          sessionPutI64(&pNew->aRecord[pNew->nRecord], iVal);\n+          pNew->nRecord += 8;\n+          break;\n+        }\n+\n+        case SQLITE_FLOAT: {\n+          double rVal = sqlite3_column_double(pDflt, iField);\n+          i64 iVal = 0;\n+          memcpy(&iVal, &rVal, sizeof(rVal));\n+          sessionPutI64(&pNew->aRecord[pNew->nRecord], iVal);\n+          pNew->nRecord += 8;\n+          break;\n+        }\n+\n+        case SQLITE_TEXT: {\n+          int n = sqlite3_column_bytes(pDflt, iField);\n+          const char *z = (const char*)sqlite3_column_text(pDflt, iField);\n+          pNew->nRecord += sessionVarintPut(&pNew->aRecord[pNew->nRecord], n);\n+          memcpy(&pNew->aRecord[pNew->nRecord], z, n);\n+          pNew->nRecord += n;\n+          break;\n+        }\n+\n+        case SQLITE_BLOB: {\n+          int n = sqlite3_column_bytes(pDflt, iField);\n+          const u8 *z = (const u8*)sqlite3_column_blob(pDflt, iField);\n+          pNew->nRecord += sessionVarintPut(&pNew->aRecord[pNew->nRecord], n);\n+          memcpy(&pNew->aRecord[pNew->nRecord], z, n);\n+          pNew->nRecord += n;\n+          break;\n+        }\n+\n+        default:\n+          assert( eType==SQLITE_NULL );\n+          break;\n+      }\n+\n+      sessionFree(pSession, pOld);\n+      *pp = pOld = pNew;\n+      pNew->nRecordField++;\n+      pNew->nMaxSize += nIncr;\n+      if( pSession ){\n+        pSession->nMaxChangesetSize += nIncr;\n+      }\n+    }\n+  }\n+}\n+\n+\/*\n+** Ensure that there is room in the buffer to append nByte bytes of data.\n+** If not, use sqlite3_realloc() to grow the buffer so that there is.\n+**\n+** If successful, return zero. Otherwise, if an OOM condition is encountered,\n+** set *pRc to SQLITE_NOMEM and return non-zero.\n+*\/\n+static int sessionBufferGrow(SessionBuffer *p, i64 nByte, int *pRc){\n+#define SESSION_MAX_BUFFER_SZ (0x7FFFFF00 - 1)\n+  i64 nReq = p->nBuf + nByte;\n+  if( *pRc==SQLITE_OK && nReq>p->nAlloc ){\n+    u8 *aNew;\n+    i64 nNew = p->nAlloc ? p->nAlloc : 128;\n+\n+    do {\n+      nNew = nNew*2;\n+    }while( nNew<nReq );\n+\n+    \/* The value of SESSION_MAX_BUFFER_SZ is copied from the implementation\n+    ** of sqlite3_realloc64(). Allocations greater than this size in bytes\n+    ** always fail. It is used here to ensure that this routine can always\n+    ** allocate up to this limit - instead of up to the largest power of\n+    ** two smaller than the limit.  *\/\n+    if( nNew>SESSION_MAX_BUFFER_SZ ){\n+      nNew = SESSION_MAX_BUFFER_SZ;\n+      if( nNew<nReq ){\n+        *pRc = SQLITE_NOMEM;\n+        return 1;\n+      }\n+    }\n+\n+    aNew = (u8 *)sqlite3_realloc64(p->aBuf, nNew);\n+    if( 0==aNew ){\n+      *pRc = SQLITE_NOMEM;\n+    }else{\n+      p->aBuf = aNew;\n+      p->nAlloc = nNew;\n+    }\n+  }\n+  return (*pRc!=SQLITE_OK);\n+}\n+\n+\n+\/*\n+** This function is a no-op if *pRc is other than SQLITE_OK when it is\n+** called. Otherwise, append a string to the buffer. All bytes in the string\n+** up to (but not including) the nul-terminator are written to the buffer.\n+**\n+** If an OOM condition is encountered, set *pRc to SQLITE_NOMEM before\n+** returning.\n+*\/\n+static void sessionAppendStr(\n+  SessionBuffer *p,\n+  const char *zStr,\n+  int *pRc\n+){\n+  int nStr = sqlite3Strlen30(zStr);\n+  if( 0==sessionBufferGrow(p, nStr+1, pRc) ){\n+    memcpy(&p->aBuf[p->nBuf], zStr, nStr);\n+    p->nBuf += nStr;\n+    p->aBuf[p->nBuf] = 0x00;\n+  }\n+}\n+\n+\/*\n+** Format a string using printf() style formatting and then append it to the\n+** buffer using sessionAppendString().\n+*\/\n+static void sessionAppendPrintf(\n+  SessionBuffer *p,               \/* Buffer to append to *\/\n+  int *pRc,\n+  const char *zFmt,\n+  ...\n+){\n+  if( *pRc==SQLITE_OK ){\n+    char *zApp = 0;\n+    va_list ap;\n+    va_start(ap, zFmt);\n+    zApp = sqlite3_vmprintf(zFmt, ap);\n+    if( zApp==0 ){\n+      *pRc = SQLITE_NOMEM;\n+    }else{\n+      sessionAppendStr(p, zApp, pRc);\n+    }\n+    va_end(ap);\n+    sqlite3_free(zApp);\n+  }\n+}\n+\n+\/*\n+** Prepare a statement against database handle db that SELECTs a single\n+** row containing the default values for each column in table pTab. For\n+** example, if pTab is declared as:\n+**\n+**   CREATE TABLE pTab(a PRIMARY KEY, b DEFAULT 123, c DEFAULT 'abcd');\n+**\n+** Then this function prepares and returns the SQL statement:\n+**\n+**   SELECT NULL, 123, 'abcd';\n+*\/\n+static int sessionPrepareDfltStmt(\n+  sqlite3 *db,                    \/* Database handle *\/\n+  SessionTable *pTab,             \/* Table to prepare statement for *\/\n+  sqlite3_stmt **ppStmt           \/* OUT: Statement handle *\/\n+){\n+  SessionBuffer sql = {0,0,0};\n+  int rc = SQLITE_OK;\n+  const char *zSep = \" \";\n+  int ii = 0;\n+\n+  *ppStmt = 0;\n+  sessionAppendPrintf(&sql, &rc, \"SELECT\");\n+  for(ii=0; ii<pTab->nCol; ii++){\n+    const char *zDflt = pTab->azDflt[ii] ? pTab->azDflt[ii] : \"NULL\";\n+    sessionAppendPrintf(&sql, &rc, \"%s%s\", zSep, zDflt);\n+    zSep = \", \";\n+  }\n+  if( rc==SQLITE_OK ){\n+    rc = sqlite3_prepare_v2(db, (const char*)sql.aBuf, -1, ppStmt, 0);\n+  }\n+  sqlite3_free(sql.aBuf);\n+\n+  return rc;\n+}\n+\n+\/*\n+** Table pTab has one or more existing change-records with old.* records\n+** with fewer than pTab->nCol columns. This function updates all such\n+** change-records with the default values for the missing columns.\n+*\/\n+static int sessionUpdateChanges(sqlite3_session *pSession, SessionTable *pTab){\n+  sqlite3_stmt *pStmt = 0;\n+  int rc = pSession->rc;\n+\n+  rc = sessionPrepareDfltStmt(pSession->db, pTab, &pStmt);\n+  if( rc==SQLITE_OK && SQLITE_ROW==sqlite3_step(pStmt) ){\n+    int ii = 0;\n+    SessionChange **pp = 0;\n+    for(ii=0; ii<pTab->nChange; ii++){\n+      for(pp=&pTab->apChange[ii]; *pp; pp=&((*pp)->pNext)){\n+        if( (*pp)->nRecordField!=pTab->nCol ){\n+          sessionUpdateOneChange(pSession, &rc, pp, pTab->nCol, pStmt);\n+        }\n+      }\n+    }\n+  }\n+\n+  pSession->rc = rc;\n+  rc = sqlite3_finalize(pStmt);\n+  if( pSession->rc==SQLITE_OK ) pSession->rc = rc;\n+  return pSession->rc;\n@@ -213852,0 +224813,1 @@\n+    if( pTab->bRowid ) nNew += 9;\n@@ -213868,1 +224830,5 @@\n-    for(ii=0; ii<pTab->nCol; ii++){\n+    if( pTab->bRowid ){\n+      nNew += 9 + 1;\n+      pCsr += 9;\n+    }\n+    for(ii=pTab->bRowid; ii<pTab->nCol; ii++){\n@@ -213873,1 +224839,1 @@\n-      pSession->hook.xNew(pSession->hook.pCtx, ii, &p);\n+      pSession->hook.xNew(pSession->hook.pCtx, ii-pTab->bRowid, &p);\n@@ -213952,0 +224918,1 @@\n+  i64 iRowid,\n@@ -213958,0 +224925,1 @@\n+  int nExpect = 0;\n@@ -213963,1 +224931,1 @@\n-  if( sessionInitTable(pSession, pTab) ) return;\n+  if( sessionInitTable(pSession, pTab, pSession->db, pSession->zDb) ) return;\n@@ -213967,1 +224935,6 @@\n-  if( pTab->nCol!=pSession->hook.xCount(pSession->hook.pCtx) ){\n+  nExpect = pSession->hook.xCount(pSession->hook.pCtx);\n+  if( (pTab->nCol-pTab->bRowid)<nExpect ){\n+    if( sessionReinitTable(pSession, pTab) ) return;\n+    if( sessionUpdateChanges(pSession, pTab) ) return;\n+  }\n+  if( (pTab->nCol-pTab->bRowid)!=nExpect ){\n@@ -214000,1 +224973,3 @@\n-  rc = sessionPreupdateHash(pSession, pTab, op==SQLITE_INSERT, &iHash, &bNull);\n+  rc = sessionPreupdateHash(\n+      pSession, iRowid, pTab, op==SQLITE_INSERT, &iHash, &bNull\n+  );\n@@ -214007,1 +224982,1 @@\n-      if( sessionPreupdateEqual(pSession, pTab, pC, op) ) break;\n+      if( sessionPreupdateEqual(pSession, iRowid, pTab, pC, op) ) break;\n@@ -214022,1 +224997,1 @@\n-      for(i=0; i<pTab->nCol; i++){\n+      for(i=0; i<(pTab->nCol-pTab->bRowid); i++){\n@@ -214037,0 +225012,3 @@\n+      if( pTab->bRowid ){\n+        nByte += 9;               \/* Size of rowid field - an integer *\/\n+      }\n@@ -214039,1 +225017,1 @@\n-      pC = (SessionChange *)sessionMalloc64(pSession, nByte);\n+      pC = (SessionChange*)sessionMalloc64(pSession, nByte);\n@@ -214053,1 +225031,6 @@\n-      for(i=0; i<pTab->nCol; i++){\n+      if( pTab->bRowid ){\n+        pC->aRecord[0] = SQLITE_INTEGER;\n+        sessionPutI64(&pC->aRecord[1], iRowid);\n+        nByte = 9;\n+      }\n+      for(i=0; i<(pTab->nCol-pTab->bRowid); i++){\n@@ -214067,0 +225050,1 @@\n+      pC->nRecordField = pTab->nCol;\n@@ -214152,0 +225136,2 @@\n+  (void)iKey1;\n+  (void)iKey2;\n@@ -214166,1 +225152,2 @@\n-      sessionPreupdateOneChange(op, pSession, pTab);\n+      assert( op==SQLITE_UPDATE || iKey1==iKey2 );\n+      sessionPreupdateOneChange(op, iKey1, pSession, pTab);\n@@ -214168,1 +225155,1 @@\n-        sessionPreupdateOneChange(SQLITE_INSERT, pSession, pTab);\n+        sessionPreupdateOneChange(SQLITE_INSERT, iKey2, pSession, pTab);\n@@ -214207,0 +225194,1 @@\n+  int bRowid;\n@@ -214215,1 +225203,1 @@\n-  *ppVal = sqlite3_column_value(p->pStmt, iVal+p->nOldOff);\n+  *ppVal = sqlite3_column_value(p->pStmt, iVal+p->nOldOff+p->bRowid);\n@@ -214220,1 +225208,1 @@\n-  *ppVal = sqlite3_column_value(p->pStmt, iVal);\n+  *ppVal = sqlite3_column_value(p->pStmt, iVal+p->bRowid);\n@@ -214225,1 +225213,1 @@\n-  return p->nOldOff ? p->nOldOff : sqlite3_column_count(p->pStmt);\n+  return (p->nOldOff ? p->nOldOff : sqlite3_column_count(p->pStmt)) - p->bRowid;\n@@ -214228,0 +225216,1 @@\n+  (void)pCtx;\n@@ -214301,1 +225290,0 @@\n-  int nCol,\n@@ -214304,0 +225292,1 @@\n+  int bRowid,\n@@ -214307,0 +225296,1 @@\n+  const char *zSel = (bRowid ? SESSIONS_ROWID \", *\" : \"*\");\n@@ -214308,1 +225298,1 @@\n-      \"SELECT * FROM \\\"%w\\\".\\\"%w\\\" WHERE NOT EXISTS (\"\n+      \"SELECT %s FROM \\\"%w\\\".\\\"%w\\\" WHERE NOT EXISTS (\"\n@@ -214311,1 +225301,1 @@\n-      zDb1, zTbl, zDb2, zTbl, zExpr\n+      zSel, zDb1, zTbl, zDb2, zTbl, zExpr\n@@ -214325,1 +225315,3 @@\n-  char *zStmt = sessionSelectFindNew(pTab->nCol, zDb1, zDb2, pTab->zName,zExpr);\n+  char *zStmt = sessionSelectFindNew(\n+      zDb1, zDb2, pTab->bRowid, pTab->zName, zExpr\n+  );\n@@ -214336,0 +225328,1 @@\n+      pDiffCtx->bRowid = pTab->bRowid;\n@@ -214337,1 +225330,2 @@\n-        sessionPreupdateOneChange(op, pSession, pTab);\n+        i64 iRowid = (pTab->bRowid ? sqlite3_column_int64(pStmt, 0) : 0);\n+        sessionPreupdateOneChange(op, iRowid, pSession, pTab);\n@@ -214347,0 +225341,21 @@\n+\/*\n+** Return a comma-separated list of the fully-qualified (with both database\n+** and table name) column names from table pTab. e.g.\n+**\n+**    \"main\".\"t1\".\"a\", \"main\".\"t1\".\"b\", \"main\".\"t1\".\"c\"\n+*\/\n+static char *sessionAllCols(\n+  const char *zDb,\n+  SessionTable *pTab\n+){\n+  int ii;\n+  char *zRet = 0;\n+  for(ii=0; ii<pTab->nCol; ii++){\n+    zRet = sqlite3_mprintf(\"%z%s\\\"%w\\\".\\\"%w\\\".\\\"%w\\\"\",\n+        zRet, (zRet ? \", \" : \"\"), zDb, pTab->zName, pTab->azCol[ii]\n+    );\n+    if( !zRet ) break;\n+  }\n+  return zRet;\n+}\n+\n@@ -214361,0 +225376,2 @@\n+    char *z1 = sessionAllCols(pSession->zDb, pTab);\n+    char *z2 = sessionAllCols(zFrom, pTab);\n@@ -214362,2 +225379,2 @@\n-        \"SELECT * FROM \\\"%w\\\".\\\"%w\\\", \\\"%w\\\".\\\"%w\\\" WHERE %s AND (%z)\",\n-        pSession->zDb, pTab->zName, zFrom, pTab->zName, zExpr, zExpr2\n+        \"SELECT %s,%s FROM \\\"%w\\\".\\\"%w\\\", \\\"%w\\\".\\\"%w\\\" WHERE %s AND (%z)\",\n+        z1, z2, pSession->zDb, pTab->zName, zFrom, pTab->zName, zExpr, zExpr2\n@@ -214365,1 +225382,1 @@\n-    if( zStmt==0 ){\n+    if( zStmt==0 || z1==0 || z2==0 ){\n@@ -214376,1 +225393,2 @@\n-          sessionPreupdateOneChange(SQLITE_UPDATE, pSession, pTab);\n+          i64 iRowid = (pTab->bRowid ? sqlite3_column_int64(pStmt, 0) : 0);\n+          sessionPreupdateOneChange(SQLITE_UPDATE, iRowid, pSession, pTab);\n@@ -214380,1 +225398,0 @@\n-      sqlite3_free(zStmt);\n@@ -214382,0 +225399,3 @@\n+    sqlite3_free(zStmt);\n+    sqlite3_free(z1);\n+    sqlite3_free(z2);\n@@ -214410,1 +225430,1 @@\n-    if( sessionInitTable(pSession, pTo) ){\n+    if( sessionInitTable(pSession, pTo, pSession->db, pSession->zDb) ){\n@@ -214420,0 +225440,1 @@\n+      int bRowid = 0;\n@@ -214422,1 +225443,3 @@\n-      rc = sessionTableInfo(0, db, zFrom, zTbl, &nCol, 0, &azCol, &abPK);\n+      rc = sessionTableInfo(0, db, zFrom, zTbl, &nCol, 0, &azCol, 0, &abPK,\n+          pSession->bImplicitPK ? &bRowid : 0\n+      );\n@@ -214535,0 +225558,1 @@\n+    sqlite3_finalize(pTab->pDfltStmt);\n@@ -214567,3 +225591,1 @@\n-  \/* Assert that all allocations have been freed and then free the\n-  ** session object itself. *\/\n-  assert( pSession->nMalloc==0 );\n+  \/* Free the session object. *\/\n@@ -214640,42 +225662,0 @@\n-\/*\n-** Ensure that there is room in the buffer to append nByte bytes of data.\n-** If not, use sqlite3_realloc() to grow the buffer so that there is.\n-**\n-** If successful, return zero. Otherwise, if an OOM condition is encountered,\n-** set *pRc to SQLITE_NOMEM and return non-zero.\n-*\/\n-static int sessionBufferGrow(SessionBuffer *p, i64 nByte, int *pRc){\n-#define SESSION_MAX_BUFFER_SZ (0x7FFFFF00 - 1)\n-  i64 nReq = p->nBuf + nByte;\n-  if( *pRc==SQLITE_OK && nReq>p->nAlloc ){\n-    u8 *aNew;\n-    i64 nNew = p->nAlloc ? p->nAlloc : 128;\n-\n-    do {\n-      nNew = nNew*2;\n-    }while( nNew<nReq );\n-\n-    \/* The value of SESSION_MAX_BUFFER_SZ is copied from the implementation\n-    ** of sqlite3_realloc64(). Allocations greater than this size in bytes\n-    ** always fail. It is used here to ensure that this routine can always\n-    ** allocate up to this limit - instead of up to the largest power of\n-    ** two smaller than the limit.  *\/\n-    if( nNew>SESSION_MAX_BUFFER_SZ ){\n-      nNew = SESSION_MAX_BUFFER_SZ;\n-      if( nNew<nReq ){\n-        *pRc = SQLITE_NOMEM;\n-        return 1;\n-      }\n-    }\n-\n-    aNew = (u8 *)sqlite3_realloc64(p->aBuf, nNew);\n-    if( 0==aNew ){\n-      *pRc = SQLITE_NOMEM;\n-    }else{\n-      p->aBuf = aNew;\n-      p->nAlloc = nNew;\n-    }\n-  }\n-  return (*pRc!=SQLITE_OK);\n-}\n-\n@@ -214750,20 +225730,0 @@\n-\/*\n-** This function is a no-op if *pRc is other than SQLITE_OK when it is\n-** called. Otherwise, append a string to the buffer. All bytes in the string\n-** up to (but not including) the nul-terminator are written to the buffer.\n-**\n-** If an OOM condition is encountered, set *pRc to SQLITE_NOMEM before\n-** returning.\n-*\/\n-static void sessionAppendStr(\n-  SessionBuffer *p,\n-  const char *zStr,\n-  int *pRc\n-){\n-  int nStr = sqlite3Strlen30(zStr);\n-  if( 0==sessionBufferGrow(p, nStr, pRc) ){\n-    memcpy(&p->aBuf[p->nBuf], zStr, nStr);\n-    p->nBuf += nStr;\n-  }\n-}\n-\n@@ -214802,1 +225762,1 @@\n-  int nStr = sqlite3Strlen30(zStr)*2 + 2 + 1;\n+  int nStr = sqlite3Strlen30(zStr)*2 + 2 + 2;\n@@ -214813,0 +225773,1 @@\n+    p->aBuf[p->nBuf] = 0x00;\n@@ -214948,1 +225909,1 @@\n-    \/* Add a field to the old.* record. This is omitted if this modules is\n+    \/* Add a field to the old.* record. This is omitted if this module is\n@@ -215037,1 +225998,7 @@\n-**   SELECT * FROM zDb.zTab WHERE pk1 = ? AND pk2 = ? AND ...\n+**   SELECT *, <noop-test> FROM zDb.zTab WHERE (pk1, pk2,...) IS (?1, ?2,...)\n+**\n+** where <noop-test> is:\n+**\n+**   1 AND (?A OR ?1 IS <column>) AND ...\n+**\n+** for each non-pk <column>.\n@@ -215041,0 +226008,1 @@\n+  int bIgnoreNoop,\n@@ -215043,0 +226011,1 @@\n+  int bRowid,\n@@ -215050,0 +226019,2 @@\n+  const char *zSep = \"\";\n+  const char *zCols = bRowid ? SESSIONS_ROWID \", *\" : \"*\";\n@@ -215051,0 +226022,7 @@\n+  int i;\n+\n+  SessionBuffer nooptest = {0, 0, 0};\n+  SessionBuffer pkfield = {0, 0, 0};\n+  SessionBuffer pkvar = {0, 0, 0};\n+\n+  sessionAppendStr(&nooptest, \", 1\", &rc);\n@@ -215052,0 +226030,33 @@\n+  if( 0==sqlite3_stricmp(\"sqlite_stat1\", zTab) ){\n+    sessionAppendStr(&nooptest, \" AND (?6 OR ?3 IS stat)\", &rc);\n+    sessionAppendStr(&pkfield, \"tbl, idx\", &rc);\n+    sessionAppendStr(&pkvar,\n+        \"?1, (CASE WHEN ?2=X'' THEN NULL ELSE ?2 END)\", &rc\n+    );\n+    zCols = \"tbl, ?2, stat\";\n+  }else{\n+    for(i=0; i<nCol; i++){\n+      if( abPK[i] ){\n+        sessionAppendStr(&pkfield, zSep, &rc);\n+        sessionAppendStr(&pkvar, zSep, &rc);\n+        zSep = \", \";\n+        sessionAppendIdent(&pkfield, azCol[i], &rc);\n+        sessionAppendPrintf(&pkvar, &rc, \"?%d\", i+1);\n+      }else{\n+        sessionAppendPrintf(&nooptest, &rc,\n+            \" AND (?%d OR ?%d IS %w.%w)\", i+1+nCol, i+1, zTab, azCol[i]\n+        );\n+      }\n+    }\n+  }\n+\n+  if( rc==SQLITE_OK ){\n+    zSql = sqlite3_mprintf(\n+        \"SELECT %s%s FROM %Q.%Q WHERE (%s) IS (%s)\",\n+        zCols, (bIgnoreNoop ? (char*)nooptest.aBuf : \"\"),\n+        zDb, zTab, (char*)pkfield.aBuf, (char*)pkvar.aBuf\n+    );\n+    if( zSql==0 ) rc = SQLITE_NOMEM;\n+  }\n+\n+#if 0\n@@ -215059,1 +226070,0 @@\n-    int i;\n@@ -215080,0 +226090,1 @@\n+#endif\n@@ -215085,0 +226096,3 @@\n+  sqlite3_free(nooptest.aBuf);\n+  sqlite3_free(pkfield.aBuf);\n+  sqlite3_free(pkvar.aBuf);\n@@ -215224,3 +226238,0 @@\n-      int nCol = 0;               \/* Number of columns in table *\/\n-      u8 *abPK = 0;               \/* Primary key array *\/\n-      const char **azCol = 0;     \/* Table columns *\/\n@@ -215231,0 +226242,1 @@\n+      int nOldCol = pTab->nCol;\n@@ -215233,3 +226245,3 @@\n-      rc = sessionTableInfo(0, db, pSession->zDb, zName, &nCol, 0,&azCol,&abPK);\n-      if( !rc && (pTab->nCol!=nCol || memcmp(abPK, pTab->abPK, nCol)) ){\n-        rc = SQLITE_SCHEMA;\n+      rc = sessionReinitTable(pSession, pTab);\n+      if( rc==SQLITE_OK && pTab->nCol!=nOldCol ){\n+        rc = sessionUpdateChanges(pSession, pTab);\n@@ -215243,2 +226255,3 @@\n-        rc = sessionSelectStmt(\n-            db, pSession->zDb, zName, nCol, azCol, abPK, &pSel);\n+        rc = sessionSelectStmt(db, 0, pSession->zDb,\n+            zName, pTab->bRowid, pTab->nCol, pTab->azCol, pTab->abPK, &pSel\n+        );\n@@ -215252,1 +226265,1 @@\n-          rc = sessionSelectBind(pSel, nCol, abPK, p);\n+          rc = sessionSelectBind(pSel, pTab->nCol, pTab->abPK, p);\n@@ -215259,1 +226272,1 @@\n-              for(iCol=0; iCol<nCol; iCol++){\n+              for(iCol=0; iCol<pTab->nCol; iCol++){\n@@ -215263,2 +226276,2 @@\n-              assert( abPK!=0 );  \/* Because sessionSelectStmt() returned ok *\/\n-              rc = sessionAppendUpdate(&buf, bPatchset, pSel, p, abPK);\n+              assert( pTab->abPK!=0 );\n+              rc = sessionAppendUpdate(&buf, bPatchset, pSel, p, pTab->abPK);\n@@ -215267,1 +226280,1 @@\n-            rc = sessionAppendDelete(&buf, bPatchset, p, nCol, abPK);\n+            rc = sessionAppendDelete(&buf, bPatchset, p, pTab->nCol,pTab->abPK);\n@@ -215292,1 +226305,0 @@\n-      sqlite3_free((char*)azCol);  \/* cast works around VC++ bug *\/\n@@ -215327,1 +226339,1 @@\n-  rc = sessionGenerateChangeset(pSession, 0, 0, 0, pnChangeset,ppChangeset);\n+  rc = sessionGenerateChangeset(pSession, 0, 0, 0, pnChangeset, ppChangeset);\n@@ -215445,0 +226457,13 @@\n+    case SQLITE_SESSION_OBJCONFIG_ROWID: {\n+      int iArg = *(int*)pArg;\n+      if( iArg>=0 ){\n+        if( pSession->pTable ){\n+          rc = SQLITE_MISUSE;\n+        }else{\n+          pSession->bImplicitPK = (iArg!=0);\n+        }\n+      }\n+      *(int*)pArg = pSession->bImplicitPK;\n+      break;\n+    }\n+\n@@ -215703,3 +226728,2 @@\n-        sqlite3_int64 v = sessionGetI64(aVal);\n-        if( eType==SQLITE_INTEGER ){\n-          sqlite3VdbeMemSetInt64(apOut[i], v);\n+        if( (pIn->nData-pIn->iNext)<8 ){\n+          rc = SQLITE_CORRUPT_BKPT;\n@@ -215707,3 +226731,9 @@\n-          double d;\n-          memcpy(&d, &v, 8);\n-          sqlite3VdbeMemSetDouble(apOut[i], d);\n+          sqlite3_int64 v = sessionGetI64(aVal);\n+          if( eType==SQLITE_INTEGER ){\n+            sqlite3VdbeMemSetInt64(apOut[i], v);\n+          }else{\n+            double d;\n+            memcpy(&d, &v, 8);\n+            sqlite3VdbeMemSetDouble(apOut[i], d);\n+          }\n+          pIn->iNext += 8;\n@@ -215711,1 +226741,0 @@\n-        pIn->iNext += 8;\n@@ -215980,0 +227009,16 @@\n+\n+    \/* If this is an UPDATE that is part of a changeset, then check that\n+    ** there are no fields in the old.* record that are not (a) PK fields,\n+    ** or (b) also present in the new.* record.\n+    **\n+    ** Such records are technically corrupt, but the rebaser was at one\n+    ** point generating them. Under most circumstances this is benign, but\n+    ** can cause spurious SQLITE_RANGE errors when applying the changeset. *\/\n+    if( p->bPatchset==0 && p->op==SQLITE_UPDATE){\n+      for(i=0; i<p->nCol; i++){\n+        if( p->abPK[i]==0 && p->apValue[i+p->nCol]==0 ){\n+          sqlite3ValueFree(p->apValue[i]);\n+          p->apValue[i] = 0;\n+        }\n+      }\n+    }\n@@ -216417,0 +227462,2 @@\n+  u8 bIgnoreNoop;                 \/* True to ignore no-op conflicts *\/\n+  int bRowid;\n@@ -216667,2 +227714,4 @@\n-  return sessionSelectStmt(\n-      db, \"main\", zTab, p->nCol, p->azCol, p->abPK, &p->pSelect);\n+  \/* TODO *\/\n+  return sessionSelectStmt(db, p->bIgnoreNoop,\n+      \"main\", zTab, p->bRowid, p->nCol, p->azCol, p->abPK, &p->pSelect\n+  );\n@@ -216826,1 +227875,0 @@\n-  sqlite3 *db,                    \/* Database handle *\/\n@@ -216828,2 +227876,1 @@\n-  u8 *abPK,                       \/* Primary key flags array *\/\n-  sqlite3_stmt *pSelect           \/* SELECT statement from sessionSelectRow() *\/\n+  SessionApplyCtx *p\n@@ -216831,0 +227878,1 @@\n+  sqlite3_stmt *pSelect = p->pSelect;\n@@ -216836,0 +227884,1 @@\n+  sqlite3_clear_bindings(pSelect);\n@@ -216839,1 +227888,1 @@\n-      nCol, abPK, pSelect\n+      nCol, p->abPK, pSelect\n@@ -216842,0 +227891,12 @@\n+  if( op!=SQLITE_DELETE && p->bIgnoreNoop ){\n+    int ii;\n+    for(ii=0; rc==SQLITE_OK && ii<nCol; ii++){\n+      if( p->abPK[ii]==0 ){\n+        sqlite3_value *pVal = 0;\n+        sqlite3changeset_new(pIter, ii, &pVal);\n+        sqlite3_bind_int(pSelect, ii+1+nCol, (pVal==0));\n+        if( pVal ) rc = sessionBindValue(pSelect, ii+1, pVal);\n+      }\n+    }\n+  }\n+\n@@ -216956,1 +228017,1 @@\n-    rc = sessionSeekToRow(p->db, pIter, p->abPK, p->pSelect);\n+    rc = sessionSeekToRow(pIter, p);\n@@ -216963,3 +228024,9 @@\n-    pIter->pConflict = p->pSelect;\n-    res = xConflict(pCtx, eType, pIter);\n-    pIter->pConflict = 0;\n+    if( p->bIgnoreNoop\n+     && sqlite3_column_int(p->pSelect, sqlite3_column_count(p->pSelect)-1)\n+    ){\n+      res = SQLITE_CHANGESET_OMIT;\n+    }else{\n+      pIter->pConflict = p->pSelect;\n+      res = xConflict(pCtx, eType, pIter);\n+      pIter->pConflict = 0;\n+    }\n@@ -217073,1 +228140,1 @@\n-    if( rc==SQLITE_OK && sqlite3_changes(p->db)==0 ){\n+    if( rc==SQLITE_OK && sqlite3_changes(p->db)==0 && p->bIgnoreNoop==0 ){\n@@ -217130,1 +228197,1 @@\n-      rc = sessionSeekToRow(p->db, pIter, p->abPK, p->pSelect);\n+      rc = sessionSeekToRow(pIter, p);\n@@ -217307,0 +228374,1 @@\n+  sApply.bIgnoreNoop = !!(flags & SQLITE_CHANGESETAPPLY_IGNORENOOP);\n@@ -217344,0 +228412,1 @@\n+      sApply.bRowid = 0;\n@@ -217363,2 +228432,2 @@\n-        rc = sessionTableInfo(0,\n-            db, \"main\", zNew, &sApply.nCol, &zTab, &sApply.azCol, &sApply.abPK\n+        rc = sessionTableInfo(0, db, \"main\", zNew,\n+            &sApply.nCol, &zTab, &sApply.azCol, 0, &sApply.abPK, &sApply.bRowid\n@@ -217496,0 +228565,7 @@\n+  u64 savedFlag = db->flags & SQLITE_FkNoAction;\n+\n+  if( flags & SQLITE_CHANGESETAPPLY_FKNOACTION ){\n+    db->flags |= ((u64)SQLITE_FkNoAction);\n+    db->aDb[0].pSchema->schema_cookie -= 32;\n+  }\n+\n@@ -217501,0 +228577,6 @@\n+\n+  if( (flags & SQLITE_CHANGESETAPPLY_FKNOACTION) && savedFlag==0 ){\n+    assert( db->flags & SQLITE_FkNoAction );\n+    db->flags &= ~((u64)SQLITE_FkNoAction);\n+    db->aDb[0].pSchema->schema_cookie -= 32;\n+  }\n@@ -217588,0 +228670,3 @@\n+\n+  sqlite3 *db;                    \/* Configured by changegroup_schema() *\/\n+  char *zDb;                      \/* Configured by changegroup_schema() *\/\n@@ -217608,0 +228693,1 @@\n+  assert( aRec!=0 );\n@@ -217773,0 +228859,108 @@\n+\/*\n+** Check if a changeset entry with nCol columns and the PK array passed\n+** as the final argument to this function is compatible with SessionTable\n+** pTab. If so, return 1. Otherwise, if they are incompatible in some way,\n+** return 0.\n+*\/\n+static int sessionChangesetCheckCompat(\n+  SessionTable *pTab,\n+  int nCol,\n+  u8 *abPK\n+){\n+  if( pTab->azCol && nCol<pTab->nCol ){\n+    int ii;\n+    for(ii=0; ii<pTab->nCol; ii++){\n+      u8 bPK = (ii < nCol) ? abPK[ii] : 0;\n+      if( pTab->abPK[ii]!=bPK ) return 0;\n+    }\n+    return 1;\n+  }\n+  return (pTab->nCol==nCol && 0==memcmp(abPK, pTab->abPK, nCol));\n+}\n+\n+static int sessionChangesetExtendRecord(\n+  sqlite3_changegroup *pGrp,\n+  SessionTable *pTab,\n+  int nCol,\n+  int op,\n+  const u8 *aRec,\n+  int nRec,\n+  SessionBuffer *pOut\n+){\n+  int rc = SQLITE_OK;\n+  int ii = 0;\n+\n+  assert( pTab->azCol );\n+  assert( nCol<pTab->nCol );\n+\n+  pOut->nBuf = 0;\n+  if( op==SQLITE_INSERT || (op==SQLITE_DELETE && pGrp->bPatch==0) ){\n+    \/* Append the missing default column values to the record. *\/\n+    sessionAppendBlob(pOut, aRec, nRec, &rc);\n+    if( rc==SQLITE_OK && pTab->pDfltStmt==0 ){\n+      rc = sessionPrepareDfltStmt(pGrp->db, pTab, &pTab->pDfltStmt);\n+    }\n+    for(ii=nCol; rc==SQLITE_OK && ii<pTab->nCol; ii++){\n+      int eType = sqlite3_column_type(pTab->pDfltStmt, ii);\n+      sessionAppendByte(pOut, eType, &rc);\n+      switch( eType ){\n+        case SQLITE_FLOAT:\n+        case SQLITE_INTEGER: {\n+          i64 iVal;\n+          if( eType==SQLITE_INTEGER ){\n+            iVal = sqlite3_column_int64(pTab->pDfltStmt, ii);\n+          }else{\n+            double rVal = sqlite3_column_int64(pTab->pDfltStmt, ii);\n+            memcpy(&iVal, &rVal, sizeof(i64));\n+          }\n+          if( SQLITE_OK==sessionBufferGrow(pOut, 8, &rc) ){\n+            sessionPutI64(&pOut->aBuf[pOut->nBuf], iVal);\n+          }\n+          break;\n+        }\n+\n+        case SQLITE_BLOB:\n+        case SQLITE_TEXT: {\n+          int n = sqlite3_column_bytes(pTab->pDfltStmt, ii);\n+          sessionAppendVarint(pOut, n, &rc);\n+          if( eType==SQLITE_TEXT ){\n+            const u8 *z = (const u8*)sqlite3_column_text(pTab->pDfltStmt, ii);\n+            sessionAppendBlob(pOut, z, n, &rc);\n+          }else{\n+            const u8 *z = (const u8*)sqlite3_column_blob(pTab->pDfltStmt, ii);\n+            sessionAppendBlob(pOut, z, n, &rc);\n+          }\n+          break;\n+        }\n+\n+        default:\n+          assert( eType==SQLITE_NULL );\n+          break;\n+      }\n+    }\n+  }else if( op==SQLITE_UPDATE ){\n+    \/* Append missing \"undefined\" entries to the old.* record. And, if this\n+    ** is an UPDATE, to the new.* record as well.  *\/\n+    int iOff = 0;\n+    if( pGrp->bPatch==0 ){\n+      for(ii=0; ii<nCol; ii++){\n+        iOff += sessionSerialLen(&aRec[iOff]);\n+      }\n+      sessionAppendBlob(pOut, aRec, iOff, &rc);\n+      for(ii=0; ii<(pTab->nCol-nCol); ii++){\n+        sessionAppendByte(pOut, 0x00, &rc);\n+      }\n+    }\n+\n+    sessionAppendBlob(pOut, &aRec[iOff], nRec-iOff, &rc);\n+    for(ii=0; ii<(pTab->nCol-nCol); ii++){\n+      sessionAppendByte(pOut, 0x00, &rc);\n+    }\n+  }else{\n+    assert( op==SQLITE_DELETE && pGrp->bPatch );\n+    sessionAppendBlob(pOut, aRec, nRec, &rc);\n+  }\n+\n+  return rc;\n+}\n+\n@@ -217786,0 +228980,1 @@\n+  SessionBuffer rec = {0, 0, 0};\n@@ -217797,0 +228992,3 @@\n+    \/* Ensure that only changesets, or only patchsets, but not a mixture\n+    ** of both, are being combined. It is an error to try to combine a\n+    ** changeset and a patchset.  *\/\n@@ -217829,0 +229027,10 @@\n+        if( pGrp->db ){\n+          pTab->nCol = 0;\n+          rc = sessionInitTable(0, pTab, pGrp->db, pGrp->zDb);\n+          if( rc ){\n+            assert( pTab->azCol==0 );\n+            sqlite3_free(pTab);\n+            break;\n+          }\n+        }\n+\n@@ -217835,1 +229043,3 @@\n-      }else if( pTab->nCol!=nCol || memcmp(pTab->abPK, abPK, nCol) ){\n+      }\n+\n+      if( !sessionChangesetCheckCompat(pTab, nCol, abPK) ){\n@@ -217841,0 +229051,8 @@\n+    if( nCol<pTab->nCol ){\n+      assert( pGrp->db );\n+      rc = sessionChangesetExtendRecord(pGrp, pTab, nCol, op, aRec, nRec, &rec);\n+      if( rc ) break;\n+      aRec = rec.aBuf;\n+      nRec = rec.nBuf;\n+    }\n+\n@@ -217878,0 +229096,1 @@\n+  sqlite3_free(rec.aBuf);\n@@ -217964,0 +229183,25 @@\n+\/*\n+** Provide a database schema to the changegroup object.\n+*\/\n+SQLITE_API int sqlite3changegroup_schema(\n+  sqlite3_changegroup *pGrp,\n+  sqlite3 *db,\n+  const char *zDb\n+){\n+  int rc = SQLITE_OK;\n+\n+  if( pGrp->pList || pGrp->db ){\n+    \/* Cannot add a schema after one or more calls to sqlite3changegroup_add(),\n+    ** or after sqlite3changegroup_schema() has already been called. *\/\n+    rc = SQLITE_MISUSE;\n+  }else{\n+    pGrp->zDb = sqlite3_mprintf(\"%s\", zDb);\n+    if( pGrp->zDb==0 ){\n+      rc = SQLITE_NOMEM;\n+    }else{\n+      pGrp->db = db;\n+    }\n+  }\n+  return rc;\n+}\n+\n@@ -218027,0 +229271,1 @@\n+    sqlite3_free(pGrp->zDb);\n@@ -218176,1 +229421,1 @@\n-      }else if( a2[0]!=0xFF ){\n+      }else if( a2[0]!=0xFF && a1[0] ){\n@@ -218559,2 +229804,5 @@\n-**   This function attempts to retrieve the text of column iCol of the\n-**   current document. If successful, (*pz) is set to point to a buffer\n+**   If parameter iCol is less than zero, or greater than or equal to the\n+**   number of columns in the table, SQLITE_RANGE is returned.\n+**\n+**   Otherwise, this function attempts to retrieve the text of column iCol of\n+**   the current document. If successful, (*pz) is set to point to a buffer\n@@ -218570,2 +229818,4 @@\n-**   Returns the number of tokens in phrase iPhrase of the query. Phrases\n-**   are numbered starting from zero.\n+**   If parameter iCol is less than zero, or greater than or equal to the\n+**   number of phrases in the current query, as returned by xPhraseCount,\n+**   0 is returned. Otherwise, this function returns the number of tokens in\n+**   phrase iPhrase of the query. Phrases are numbered starting from zero.\n@@ -218587,1 +229837,2 @@\n-**   output by xInstCount().\n+**   output by xInstCount(). If iIdx is less than zero or greater than\n+**   or equal to the value returned by xInstCount(), SQLITE_RANGE is returned.\n@@ -218589,1 +229840,1 @@\n-**   Usually, output parameter *piPhrase is set to the phrase number, *piCol\n+**   Otherwise, output parameter *piPhrase is set to the phrase number, *piCol\n@@ -218591,2 +229842,2 @@\n-**   first token of the phrase. Returns SQLITE_OK if successful, or an error\n-**   code (i.e. SQLITE_NOMEM) if an error occurs.\n+**   first token of the phrase. SQLITE_OK is returned if successful, or an\n+**   error code (i.e. SQLITE_NOMEM) if an error occurs.\n@@ -218618,0 +229869,4 @@\n+**   If parameter iPhrase is less than zero, or greater than or equal to\n+**   the number of phrases in the query, as returned by xPhraseCount(),\n+**   this function returns SQLITE_RANGE.\n+**\n@@ -218732,0 +229987,33 @@\n+**\n+** xQueryToken(pFts5, iPhrase, iToken, ppToken, pnToken)\n+**   This is used to access token iToken of phrase iPhrase of the current\n+**   query. Before returning, output parameter *ppToken is set to point\n+**   to a buffer containing the requested token, and *pnToken to the\n+**   size of this buffer in bytes.\n+**\n+**   If iPhrase or iToken are less than zero, or if iPhrase is greater than\n+**   or equal to the number of phrases in the query as reported by\n+**   xPhraseCount(), or if iToken is equal to or greater than the number of\n+**   tokens in the phrase, SQLITE_RANGE is returned and *ppToken and *pnToken\n+     are both zeroed.\n+**\n+**   The output text is not a copy of the query text that specified the\n+**   token. It is the output of the tokenizer module. For tokendata=1\n+**   tables, this includes any embedded 0x00 and trailing data.\n+**\n+** xInstToken(pFts5, iIdx, iToken, ppToken, pnToken)\n+**   This is used to access token iToken of phrase hit iIdx within the\n+**   current row. If iIdx is less than zero or greater than or equal to the\n+**   value returned by xInstCount(), SQLITE_RANGE is returned.  Otherwise,\n+**   output variable (*ppToken) is set to point to a buffer containing the\n+**   matching document token, and (*pnToken) to the size of that buffer in\n+**   bytes. This API is not available if the specified token matches a\n+**   prefix query term. In that case both output variables are always set\n+**   to 0.\n+**\n+**   The output text is not a copy of the document text that was tokenized.\n+**   It is the output of the tokenizer module. For tokendata=1 tables, this\n+**   includes any embedded 0x00 and trailing data.\n+**\n+**   This API can be quite slow if used with an FTS5 table created with the\n+**   \"detail=none\" or \"detail=column\" option.\n@@ -218769,0 +230057,7 @@\n+\n+  \/* Below this point are iVersion>=3 only *\/\n+  int (*xQueryToken)(Fts5Context*,\n+      int iPhrase, int iToken,\n+      const char **ppToken, int *pnToken\n+  );\n+  int (*xInstToken)(Fts5Context*, int iIdx, int iToken, const char**, int*);\n@@ -218963,2 +230258,2 @@\n-**   provide synonyms when tokenizing document text (method (2)) or query\n-**   text (method (3)), not both. Doing so will not cause any errors, but is\n+**   provide synonyms when tokenizing document text (method (3)) or query\n+**   text (method (2)), not both. Doing so will not cause any errors, but is\n@@ -219012,1 +230307,1 @@\n-    void *pContext,\n+    void *pUserData,\n@@ -219021,1 +230316,1 @@\n-    void **ppContext,\n+    void **ppUserData,\n@@ -219029,1 +230324,1 @@\n-    void *pContext,\n+    void *pUserData,\n@@ -219201,0 +230496,4 @@\n+** bContentlessDelete:\n+**   True if the contentless_delete option was present in the CREATE\n+**   VIRTUAL TABLE statement.\n+**\n@@ -219235,0 +230534,1 @@\n+  int bContentlessDelete;         \/* \"contentless_delete=\" option (dflt==0) *\/\n@@ -219238,0 +230538,1 @@\n+  int bTokendata;                 \/* \"tokendata=\" option value (dflt==0) *\/\n@@ -219246,0 +230547,1 @@\n+  int iVersion;                   \/* fts5 file format 'version' *\/\n@@ -219254,0 +230556,2 @@\n+  int bSecureDelete;              \/* 'secure-delete' *\/\n+  int nDeleteMerge;           \/* 'deletemerge' *\/\n@@ -219263,2 +230567,5 @@\n-\/* Current expected value of %_config table 'version' field *\/\n-#define FTS5_CURRENT_VERSION  4\n+\/* Current expected value of %_config table 'version' field. And\n+** the expected version if the 'secure-delete' option has ever been\n+** set on the table.  *\/\n+#define FTS5_CURRENT_VERSION               4\n+#define FTS5_CURRENT_VERSION_SECUREDELETE  5\n@@ -219333,1 +230640,1 @@\n-#define fts5BufferAppendVarint(a,b,c) sqlite3Fts5BufferAppendVarint(a,b,c)\n+#define fts5BufferAppendVarint(a,b,c) sqlite3Fts5BufferAppendVarint(a,b,(i64)c)\n@@ -219420,4 +230727,4 @@\n-#define FTS5INDEX_QUERY_PREFIX     0x0001   \/* Prefix query *\/\n-#define FTS5INDEX_QUERY_DESC       0x0002   \/* Docs in descending rowid order *\/\n-#define FTS5INDEX_QUERY_TEST_NOIDX 0x0004   \/* Do not use prefix index *\/\n-#define FTS5INDEX_QUERY_SCAN       0x0008   \/* Scan query (fts5vocab) *\/\n+#define FTS5INDEX_QUERY_PREFIX      0x0001  \/* Prefix query *\/\n+#define FTS5INDEX_QUERY_DESC        0x0002  \/* Docs in descending rowid order *\/\n+#define FTS5INDEX_QUERY_TEST_NOIDX  0x0004  \/* Do not use prefix index *\/\n+#define FTS5INDEX_QUERY_SCAN        0x0008  \/* Scan query (fts5vocab) *\/\n@@ -219428,2 +230735,5 @@\n-#define FTS5INDEX_QUERY_SKIPEMPTY  0x0010\n-#define FTS5INDEX_QUERY_NOOUTPUT   0x0020\n+#define FTS5INDEX_QUERY_SKIPEMPTY   0x0010\n+#define FTS5INDEX_QUERY_NOOUTPUT    0x0020\n+#define FTS5INDEX_QUERY_SKIPHASH    0x0040\n+#define FTS5INDEX_QUERY_NOTOKENDATA 0x0080\n+#define FTS5INDEX_QUERY_SCANONETERM 0x0100\n@@ -219498,0 +230808,4 @@\n+\/*\n+** Used by xInstToken():\n+*\/\n+static int sqlite3Fts5IterToken(Fts5IndexIter*, i64, int, int, const char**, int*);\n@@ -219572,0 +230886,10 @@\n+static int sqlite3Fts5IndexGetOrigin(Fts5Index *p, i64 *piOrigin);\n+static int sqlite3Fts5IndexContentlessDelete(Fts5Index *p, i64 iOrigin, i64 iRowid);\n+\n+static void sqlite3Fts5IndexIterClearTokendata(Fts5IndexIter*);\n+\n+\/* Used to populate hash tables for xInstToken in detail=none\/column mode. *\/\n+static int sqlite3Fts5IndexIterWriteTokendata(\n+    Fts5IndexIter*, const char*, int, i64 iRowid, int iCol, int iOff\n+);\n+\n@@ -219584,1 +230908,1 @@\n-#define fts5GetVarint32(a,b) sqlite3Fts5GetVarint32(a,(u32*)&b)\n+#define fts5GetVarint32(a,b) sqlite3Fts5GetVarint32(a,(u32*)&(b))\n@@ -219656,0 +230980,5 @@\n+\/*\n+** Return true if the hash is empty, false otherwise.\n+*\/\n+static int sqlite3Fts5HashIsEmpty(Fts5Hash*);\n+\n@@ -219672,0 +231001,1 @@\n+  int *pnTerm,                    \/* OUT: Size of term in bytes *\/\n@@ -219677,0 +231007,1 @@\n+\n@@ -219797,0 +231128,4 @@\n+static int sqlite3Fts5ExprQueryToken(Fts5Expr*, int, int, const char**, int*);\n+static int sqlite3Fts5ExprInstToken(Fts5Expr*, i64, int, int, int, int, const char**, int*);\n+static void sqlite3Fts5ExprClearTokens(Fts5Expr*);\n+\n@@ -219920,1 +231255,2 @@\n-** source file \"fts5parse.y\". *\/\n+** source file \"fts5parse.y\".\n+*\/\n@@ -221510,2 +232846,1 @@\n-  CInstIter iter;                 \/* Coalesced Instance Iterator *\/\n-  int iPos;                       \/* Current token offset in zIn[] *\/\n+  \/* Constant parameters to fts5HighlightCb() *\/\n@@ -221518,1 +232853,6 @@\n-  int iOff;                       \/* Current offset within zIn[] *\/\n+\n+  \/* Variables modified by fts5HighlightCb() *\/\n+  CInstIter iter;                 \/* Coalesced Instance Iterator *\/\n+  int iPos;                       \/* Current token offset in zIn[] *\/\n+  int iOff;                       \/* Have copied up to this offset in zIn[] *\/\n+  int bOpen;                      \/* True if highlight is open *\/\n@@ -221551,2 +232891,2 @@\n-  int iStartOff,                  \/* Start offset of token *\/\n-  int iEndOff                     \/* End offset of token *\/\n+  int iStartOff,                  \/* Start byte offset of token *\/\n+  int iEndOff                     \/* End byte offset of token *\/\n@@ -221563,1 +232903,1 @@\n-  if( p->iRangeEnd>0 ){\n+  if( p->iRangeEnd>=0 ){\n@@ -221568,1 +232908,18 @@\n-  if( iPos==p->iter.iStart ){\n+  \/* If the parenthesis is open, and this token is not part of the current\n+  ** phrase, and the starting byte offset of this token is past the point\n+  ** that has currently been copied into the output buffer, close the\n+  ** parenthesis. *\/\n+  if( p->bOpen\n+   && (iPos<=p->iter.iStart || p->iter.iStart<0)\n+   && iStartOff>p->iOff\n+  ){\n+    fts5HighlightAppend(&rc, p, p->zClose, -1);\n+    p->bOpen = 0;\n+  }\n+\n+  \/* If this is the start of a new phrase, and the highlight is not open:\n+  **\n+  **   * copy text from the input up to the start of the phrase, and\n+  **   * open the highlight.\n+  *\/\n+  if( iPos==p->iter.iStart && p->bOpen==0 ){\n@@ -221572,0 +232929,1 @@\n+    p->bOpen = 1;\n@@ -221575,1 +232933,2 @@\n-    if( p->iRangeEnd && p->iter.iStart<p->iRangeStart ){\n+    if( p->bOpen==0 ){\n+      assert( p->iRangeEnd>=0 );\n@@ -221577,0 +232936,1 @@\n+      p->bOpen = 1;\n@@ -221579,1 +232939,0 @@\n-    fts5HighlightAppend(&rc, p, p->zClose, -1);\n@@ -221581,0 +232940,1 @@\n+\n@@ -221586,4 +232946,6 @@\n-  if( p->iRangeEnd>0 && iPos==p->iRangeEnd ){\n-    fts5HighlightAppend(&rc, p, &p->zIn[p->iOff], iEndOff - p->iOff);\n-    p->iOff = iEndOff;\n-    if( iPos>=p->iter.iStart && iPos<p->iter.iEnd ){\n+  if( iPos==p->iRangeEnd ){\n+    if( p->bOpen ){\n+      if( p->iter.iStart>=0 && iPos>=p->iter.iStart ){\n+        fts5HighlightAppend(&rc, p, &p->zIn[p->iOff], iEndOff - p->iOff);\n+        p->iOff = iEndOff;\n+      }\n@@ -221591,0 +232953,1 @@\n+      p->bOpen = 0;\n@@ -221592,0 +232955,2 @@\n+    fts5HighlightAppend(&rc, p, &p->zIn[p->iOff], iEndOff - p->iOff);\n+    p->iOff = iEndOff;\n@@ -221621,0 +232986,1 @@\n+  ctx.iRangeEnd = -1;\n@@ -221622,2 +232988,4 @@\n-\n-  if( ctx.zIn ){\n+  if( rc==SQLITE_RANGE ){\n+    sqlite3_result_text(pCtx, \"\", -1, SQLITE_STATIC);\n+    rc = SQLITE_OK;\n+  }else if( ctx.zIn ){\n@@ -221631,0 +232999,3 @@\n+    if( ctx.bOpen ){\n+      fts5HighlightAppend(&rc, &ctx, ctx.zClose, -1);\n+    }\n@@ -221806,0 +233177,1 @@\n+  ctx.iRangeEnd = -1;\n@@ -221908,0 +233280,3 @@\n+    if( ctx.bOpen ){\n+      fts5HighlightAppend(&rc, &ctx, ctx.zClose, -1);\n+    }\n@@ -222183,0 +233558,1 @@\n+    assert( pBuf->p!=0 );\n@@ -222284,0 +233660,1 @@\n+  assert( a!=0 || i==0 );\n@@ -222291,0 +233668,1 @@\n+    assert( a!=0 );\n@@ -222546,0 +233924,2 @@\n+#define FTS5_DEFAULT_DELETE_AUTOMERGE 10      \/* default 10% *\/\n+\n@@ -222876,0 +234256,10 @@\n+  if( sqlite3_strnicmp(\"contentless_delete\", zCmd, nCmd)==0 ){\n+    if( (zArg[0]!='0' && zArg[0]!='1') || zArg[1]!='\\0' ){\n+      *pzErr = sqlite3_mprintf(\"malformed contentless_delete=... directive\");\n+      rc = SQLITE_ERROR;\n+    }else{\n+      pConfig->bContentlessDelete = (zArg[0]=='1');\n+    }\n+    return rc;\n+  }\n+\n@@ -222910,0 +234300,10 @@\n+  if( sqlite3_strnicmp(\"tokendata\", zCmd, nCmd)==0 ){\n+    if( (zArg[0]!='0' && zArg[0]!='1') || zArg[1]!='\\0' ){\n+      *pzErr = sqlite3_mprintf(\"malformed tokendata=... directive\");\n+      rc = SQLITE_ERROR;\n+    }else{\n+      pConfig->bTokendata = (zArg[0]=='1');\n+    }\n+    return rc;\n+  }\n+\n@@ -223074,0 +234474,1 @@\n+  assert( (pRet->abUnindexed && pRet->azCol) || rc!=SQLITE_OK );\n@@ -223119,0 +234520,22 @@\n+  \/* We only allow contentless_delete=1 if the table is indeed contentless. *\/\n+  if( rc==SQLITE_OK\n+   && pRet->bContentlessDelete\n+   && pRet->eContent!=FTS5_CONTENT_NONE\n+  ){\n+    *pzErr = sqlite3_mprintf(\n+        \"contentless_delete=1 requires a contentless table\"\n+    );\n+    rc = SQLITE_ERROR;\n+  }\n+\n+  \/* We only allow contentless_delete=1 if columnsize=0 is not present.\n+  **\n+  ** This restriction may be removed at some point.\n+  *\/\n+  if( rc==SQLITE_OK && pRet->bContentlessDelete && pRet->bColumnsize==0 ){\n+    *pzErr = sqlite3_mprintf(\n+        \"contentless_delete=1 is incompatible with columnsize=0\"\n+    );\n+    rc = SQLITE_ERROR;\n+  }\n+\n@@ -223413,0 +234836,12 @@\n+  else if( 0==sqlite3_stricmp(zKey, \"deletemerge\") ){\n+    int nVal = -1;\n+    if( SQLITE_INTEGER==sqlite3_value_numeric_type(pVal) ){\n+      nVal = sqlite3_value_int(pVal);\n+    }else{\n+      *pbBadkey = 1;\n+    }\n+    if( nVal<0 ) nVal = FTS5_DEFAULT_DELETE_AUTOMERGE;\n+    if( nVal>100 ) nVal = 0;\n+    pConfig->nDeleteMerge = nVal;\n+  }\n+\n@@ -223427,0 +234862,12 @@\n+  }\n+\n+  else if( 0==sqlite3_stricmp(zKey, \"secure-delete\") ){\n+    int bVal = -1;\n+    if( SQLITE_INTEGER==sqlite3_value_numeric_type(pVal) ){\n+      bVal = sqlite3_value_int(pVal);\n+    }\n+    if( bVal<0 ){\n+      *pbBadkey = 1;\n+    }else{\n+      pConfig->bSecureDelete = (bVal ? 1 : 0);\n+    }\n@@ -223449,0 +234896,1 @@\n+  pConfig->nDeleteMerge = FTS5_DEFAULT_DELETE_AUTOMERGE;\n@@ -223471,1 +234919,4 @@\n-  if( rc==SQLITE_OK && iVersion!=FTS5_CURRENT_VERSION ){\n+  if( rc==SQLITE_OK\n+   && iVersion!=FTS5_CURRENT_VERSION\n+   && iVersion!=FTS5_CURRENT_VERSION_SECUREDELETE\n+  ){\n@@ -223475,3 +234926,3 @@\n-      *pConfig->pzErrmsg = sqlite3_mprintf(\n-          \"invalid fts5 file format (found %d, expected %d) - run 'rebuild'\",\n-          iVersion, FTS5_CURRENT_VERSION\n+      *pConfig->pzErrmsg = sqlite3_mprintf(\"invalid fts5 file format \"\n+          \"(found %d, expected %d or %d) - run 'rebuild'\",\n+          iVersion, FTS5_CURRENT_VERSION, FTS5_CURRENT_VERSION_SECUREDELETE\n@@ -223480,0 +234931,2 @@\n+  }else{\n+    pConfig->iVersion = iVersion;\n@@ -223507,0 +234960,4 @@\n+#ifndef SQLITE_FTS5_MAX_EXPR_DEPTH\n+# define SQLITE_FTS5_MAX_EXPR_DEPTH 256\n+#endif\n+\n@@ -223547,0 +235004,5 @@\n+**\n+** iHeight:\n+**   Distance from this node to furthest leaf. This is always 0 for nodes\n+**   of type FTS5_STRING and FTS5_TERM. For all other nodes it is one\n+**   greater than the largest child value.\n@@ -223552,0 +235014,1 @@\n+  int iHeight;                    \/* Distance to tree leaf nodes *\/\n@@ -223580,1 +235043,3 @@\n-  char *zTerm;                    \/* nul-terminated term *\/\n+  char *pTerm;                    \/* Term data *\/\n+  int nQueryTerm;                 \/* Effective size of term in bytes *\/\n+  int nFullTerm;                  \/* Size of term in bytes incl. tokendata *\/\n@@ -223621,0 +235086,25 @@\n+\/*\n+** Check that the Fts5ExprNode.iHeight variables are set correctly in\n+** the expression tree passed as the only argument.\n+*\/\n+#ifndef NDEBUG\n+static void assert_expr_depth_ok(int rc, Fts5ExprNode *p){\n+  if( rc==SQLITE_OK ){\n+    if( p->eType==FTS5_TERM || p->eType==FTS5_STRING || p->eType==0 ){\n+      assert( p->iHeight==0 );\n+    }else{\n+      int ii;\n+      int iMaxChild = 0;\n+      for(ii=0; ii<p->nChild; ii++){\n+        Fts5ExprNode *pChild = p->apChild[ii];\n+        iMaxChild = MAX(iMaxChild, pChild->iHeight);\n+        assert_expr_depth_ok(SQLITE_OK, pChild);\n+      }\n+      assert( p->iHeight==iMaxChild+1 );\n+    }\n+  }\n+}\n+#else\n+# define assert_expr_depth_ok(rc, p)\n+#endif\n+\n@@ -223735,0 +235225,2 @@\n+  assert_expr_depth_ok(sParse.rc, sParse.pExpr);\n+\n@@ -223779,0 +235271,13 @@\n+\/*\n+** Assuming that buffer z is at least nByte bytes in size and contains a\n+** valid utf-8 string, return the number of characters in the string.\n+*\/\n+static int fts5ExprCountChar(const char *z, int nByte){\n+  int nRet = 0;\n+  int ii;\n+  for(ii=0; ii<nByte; ii++){\n+    if( (z[ii] & 0xC0)!=0x80 ) nRet++;\n+  }\n+  return nRet;\n+}\n+\n@@ -223816,1 +235321,2 @@\n-        if( i-iFirst>=3 ){\n+\n+        if( fts5ExprCountChar(&zText[iFirst], i-iFirst)>=3 ){\n@@ -223883,1 +235389,1 @@\n-  if( *pp1 ){\n+  if( *pp1 && p2 ){\n@@ -223908,1 +235414,1 @@\n-  }else{\n+  }else if( p2 ){\n@@ -224406,1 +235912,1 @@\n-              pExpr->pIndex, p->zTerm, (int)strlen(p->zTerm),\n+              pExpr->pIndex, p->pTerm, p->nQueryTerm,\n@@ -225043,1 +236549,1 @@\n-      sqlite3_free(pTerm->zTerm);\n+      sqlite3_free(pTerm->pTerm);\n@@ -225141,0 +236647,1 @@\n+  Fts5Config *pConfig;\n@@ -225174,2 +236681,6 @@\n-      pSyn->zTerm = ((char*)pSyn) + sizeof(Fts5ExprTerm) + sizeof(Fts5Buffer);\n-      memcpy(pSyn->zTerm, pToken, nToken);\n+      pSyn->pTerm = ((char*)pSyn) + sizeof(Fts5ExprTerm) + sizeof(Fts5Buffer);\n+      pSyn->nFullTerm = pSyn->nQueryTerm = nToken;\n+      if( pCtx->pConfig->bTokendata ){\n+        pSyn->nQueryTerm = (int)strlen(pSyn->pTerm);\n+      }\n+      memcpy(pSyn->pTerm, pToken, nToken);\n@@ -225200,1 +236711,5 @@\n-      pTerm->zTerm = sqlite3Fts5Strndup(&rc, pToken, nToken);\n+      pTerm->pTerm = sqlite3Fts5Strndup(&rc, pToken, nToken);\n+      pTerm->nFullTerm = pTerm->nQueryTerm = nToken;\n+      if( pCtx->pConfig->bTokendata && rc==SQLITE_OK ){\n+        pTerm->nQueryTerm = (int)strlen(pTerm->pTerm);\n+      }\n@@ -225267,0 +236782,1 @@\n+  sCtx.pConfig = pConfig;\n@@ -225314,1 +236830,1 @@\n-  Fts5ExprPhrase *pOrig;          \/* The phrase extracted from pExpr *\/\n+  Fts5ExprPhrase *pOrig = 0;      \/* The phrase extracted from pExpr *\/\n@@ -225316,4 +236832,7 @@\n-  TokenCtx sCtx = {0,0};          \/* Context object for fts5ParseTokenize *\/\n-\n-  pOrig = pExpr->apExprPhrase[iPhrase];\n-  pNew = (Fts5Expr*)sqlite3Fts5MallocZero(&rc, sizeof(Fts5Expr));\n+  TokenCtx sCtx = {0,0,0};        \/* Context object for fts5ParseTokenize *\/\n+  if( iPhrase<0 || iPhrase>=pExpr->nPhrase ){\n+    rc = SQLITE_RANGE;\n+  }else{\n+    pOrig = pExpr->apExprPhrase[iPhrase];\n+    pNew = (Fts5Expr*)sqlite3Fts5MallocZero(&rc, sizeof(Fts5Expr));\n+  }\n@@ -225332,1 +236851,1 @@\n-  if( rc==SQLITE_OK ){\n+  if( rc==SQLITE_OK && ALWAYS(pOrig!=0) ){\n@@ -225346,14 +236865,15 @@\n-  if( pOrig->nTerm ){\n-    int i;                          \/* Used to iterate through phrase terms *\/\n-    for(i=0; rc==SQLITE_OK && i<pOrig->nTerm; i++){\n-      int tflags = 0;\n-      Fts5ExprTerm *p;\n-      for(p=&pOrig->aTerm[i]; p && rc==SQLITE_OK; p=p->pSynonym){\n-        const char *zTerm = p->zTerm;\n-        rc = fts5ParseTokenize((void*)&sCtx, tflags, zTerm, (int)strlen(zTerm),\n-            0, 0);\n-        tflags = FTS5_TOKEN_COLOCATED;\n-      }\n-      if( rc==SQLITE_OK ){\n-        sCtx.pPhrase->aTerm[i].bPrefix = pOrig->aTerm[i].bPrefix;\n-        sCtx.pPhrase->aTerm[i].bFirst = pOrig->aTerm[i].bFirst;\n+  if( rc==SQLITE_OK ){\n+    if( pOrig->nTerm ){\n+      int i;                          \/* Used to iterate through phrase terms *\/\n+      sCtx.pConfig = pExpr->pConfig;\n+      for(i=0; rc==SQLITE_OK && i<pOrig->nTerm; i++){\n+        int tflags = 0;\n+        Fts5ExprTerm *p;\n+        for(p=&pOrig->aTerm[i]; p && rc==SQLITE_OK; p=p->pSynonym){\n+          rc = fts5ParseTokenize((void*)&sCtx,tflags,p->pTerm,p->nFullTerm,0,0);\n+          tflags = FTS5_TOKEN_COLOCATED;\n+        }\n+        if( rc==SQLITE_OK ){\n+          sCtx.pPhrase->aTerm[i].bPrefix = pOrig->aTerm[i].bPrefix;\n+          sCtx.pPhrase->aTerm[i].bFirst = pOrig->aTerm[i].bFirst;\n+        }\n@@ -225361,0 +236881,4 @@\n+    }else{\n+      \/* This happens when parsing a token or quoted phrase that contains\n+      ** no token characters at all. (e.g ... MATCH '\"\"'). *\/\n+      sCtx.pPhrase = sqlite3Fts5MallocZero(&rc, sizeof(Fts5ExprPhrase));\n@@ -225362,4 +236886,0 @@\n-  }else{\n-    \/* This happens when parsing a token or quoted phrase that contains\n-    ** no token characters at all. (e.g ... MATCH '\"\"'). *\/\n-    sCtx.pPhrase = sqlite3Fts5MallocZero(&rc, sizeof(Fts5ExprPhrase));\n@@ -225682,0 +237202,1 @@\n+  int ii = p->nChild;\n@@ -225690,0 +237211,3 @@\n+  for( ; ii<p->nChild; ii++){\n+    p->iHeight = MAX(p->iHeight, p->apChild[ii]->iHeight + 1);\n+  }\n@@ -225720,0 +237244,1 @@\n+    pRet->iHeight = 1;\n@@ -225730,0 +237255,2 @@\n+          Fts5ExprTerm *p = &pNear->apPhrase[0]->aTerm[ii];\n+          Fts5ExprTerm *pTo = &pPhrase->aTerm[0];\n@@ -225732,3 +237259,3 @@\n-          pPhrase->aTerm[0].zTerm = sqlite3Fts5Strndup(\n-              &pParse->rc, pNear->apPhrase[0]->aTerm[ii].zTerm, -1\n-          );\n+          pTo->pTerm = sqlite3Fts5Strndup(&pParse->rc, p->pTerm, p->nFullTerm);\n+          pTo->nQueryTerm = p->nQueryTerm;\n+          pTo->nFullTerm = p->nFullTerm;\n@@ -225825,0 +237352,8 @@\n+          if( pRet->iHeight>SQLITE_FTS5_MAX_EXPR_DEPTH ){\n+            sqlite3Fts5ParseError(pParse,\n+                \"fts5 expression tree is too large (maximum depth %d)\",\n+                SQLITE_FTS5_MAX_EXPR_DEPTH\n+            );\n+            sqlite3_free(pRet);\n+            pRet = 0;\n+          }\n@@ -225903,1 +237438,1 @@\n-#ifdef SQLITE_TEST\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n@@ -225911,1 +237446,1 @@\n-    nByte += (int)strlen(pTerm->zTerm) * 2 + 3 + 2;\n+    nByte += pTerm->nQueryTerm * 2 + 3 + 2;\n@@ -225918,1 +237453,2 @@\n-      char *zIn = p->zTerm;\n+      char *zIn = p->pTerm;\n+      char *zEnd = &zIn[p->nQueryTerm];\n@@ -225920,1 +237456,1 @@\n-      while( *zIn ){\n+      while( zIn<zEnd ){\n@@ -225998,2 +237534,4 @@\n-        char *zTerm = pPhrase->aTerm[iTerm].zTerm;\n-        zRet = fts5PrintfAppend(zRet, \"%s%s\", iTerm==0?\"\":\" \", zTerm);\n+        Fts5ExprTerm *p = &pPhrase->aTerm[iTerm];\n+        zRet = fts5PrintfAppend(zRet, \"%s%.*s\", iTerm==0?\"\":\" \",\n+            p->nQueryTerm, p->pTerm\n+        );\n@@ -226009,0 +237547,2 @@\n+  }else if( pExpr->eType==0 ){\n+    zRet = sqlite3_mprintf(\"{}\");\n@@ -226270,1 +237810,1 @@\n-#endif \/* ifdef SQLITE_TEST *\/\n+#endif \/* if SQLITE_TEST || SQLITE_FTS5_DEBUG *\/\n@@ -226277,1 +237817,1 @@\n-#ifdef SQLITE_TEST\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n@@ -226398,0 +237938,11 @@\n+\/*\n+** pToken is a buffer nToken bytes in size that may or may not contain\n+** an embedded 0x00 byte. If it does, return the number of bytes in\n+** the buffer before the 0x00. If it does not, return nToken.\n+*\/\n+static int fts5QueryTerm(const char *pToken, int nToken){\n+  int ii;\n+  for(ii=0; ii<nToken && pToken[ii]; ii++){}\n+  return ii;\n+}\n+\n@@ -226409,0 +237960,2 @@\n+  int nQuery = nToken;\n+  i64 iRowid = pExpr->pRoot->iRowid;\n@@ -226412,1 +237965,4 @@\n-  if( nToken>FTS5_MAX_TOKEN_SIZE ) nToken = FTS5_MAX_TOKEN_SIZE;\n+  if( nQuery>FTS5_MAX_TOKEN_SIZE ) nQuery = FTS5_MAX_TOKEN_SIZE;\n+  if( pExpr->pConfig->bTokendata ){\n+    nQuery = fts5QueryTerm(pToken, nQuery);\n+  }\n@@ -226415,1 +237971,1 @@\n-    Fts5ExprTerm *pTerm;\n+    Fts5ExprTerm *pT;\n@@ -226417,4 +237973,3 @@\n-    for(pTerm=&pExpr->apExprPhrase[i]->aTerm[0]; pTerm; pTerm=pTerm->pSynonym){\n-      int nTerm = (int)strlen(pTerm->zTerm);\n-      if( (nTerm==nToken || (nTerm<nToken && pTerm->bPrefix))\n-       && memcmp(pTerm->zTerm, pToken, nTerm)==0\n+    for(pT=&pExpr->apExprPhrase[i]->aTerm[0]; pT; pT=pT->pSynonym){\n+      if( (pT->nQueryTerm==nQuery || (pT->nQueryTerm<nQuery && pT->bPrefix))\n+       && memcmp(pT->pTerm, pToken, pT->nQueryTerm)==0\n@@ -226425,0 +237980,7 @@\n+        if( rc==SQLITE_OK && pExpr->pConfig->bTokendata && !pT->bPrefix ){\n+          int iCol = p->iOff>>32;\n+          int iTokOff = p->iOff & 0x7FFFFFFF;\n+          rc = sqlite3Fts5IndexIterWriteTokendata(\n+              pT->pIter, pToken, nToken, iRowid, iCol, iTokOff\n+          );\n+        }\n@@ -226560,0 +238122,77 @@\n+\/*\n+** Does the work of the fts5_api.xQueryToken() API method.\n+*\/\n+static int sqlite3Fts5ExprQueryToken(\n+  Fts5Expr *pExpr,\n+  int iPhrase,\n+  int iToken,\n+  const char **ppOut,\n+  int *pnOut\n+){\n+  Fts5ExprPhrase *pPhrase = 0;\n+\n+  if( iPhrase<0 || iPhrase>=pExpr->nPhrase ){\n+    return SQLITE_RANGE;\n+  }\n+  pPhrase = pExpr->apExprPhrase[iPhrase];\n+  if( iToken<0 || iToken>=pPhrase->nTerm ){\n+    return SQLITE_RANGE;\n+  }\n+\n+  *ppOut = pPhrase->aTerm[iToken].pTerm;\n+  *pnOut = pPhrase->aTerm[iToken].nFullTerm;\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Does the work of the fts5_api.xInstToken() API method.\n+*\/\n+static int sqlite3Fts5ExprInstToken(\n+  Fts5Expr *pExpr,\n+  i64 iRowid,\n+  int iPhrase,\n+  int iCol,\n+  int iOff,\n+  int iToken,\n+  const char **ppOut,\n+  int *pnOut\n+){\n+  Fts5ExprPhrase *pPhrase = 0;\n+  Fts5ExprTerm *pTerm = 0;\n+  int rc = SQLITE_OK;\n+\n+  if( iPhrase<0 || iPhrase>=pExpr->nPhrase ){\n+    return SQLITE_RANGE;\n+  }\n+  pPhrase = pExpr->apExprPhrase[iPhrase];\n+  if( iToken<0 || iToken>=pPhrase->nTerm ){\n+    return SQLITE_RANGE;\n+  }\n+  pTerm = &pPhrase->aTerm[iToken];\n+  if( pTerm->bPrefix==0 ){\n+    if( pExpr->pConfig->bTokendata ){\n+      rc = sqlite3Fts5IterToken(\n+          pTerm->pIter, iRowid, iCol, iOff+iToken, ppOut, pnOut\n+      );\n+    }else{\n+      *ppOut = pTerm->pTerm;\n+      *pnOut = pTerm->nFullTerm;\n+    }\n+  }\n+  return rc;\n+}\n+\n+\/*\n+** Clear the token mappings for all Fts5IndexIter objects mannaged by\n+** the expression passed as the only argument.\n+*\/\n+static void sqlite3Fts5ExprClearTokens(Fts5Expr *pExpr){\n+  int ii;\n+  for(ii=0; ii<pExpr->nPhrase; ii++){\n+    Fts5ExprTerm *pT;\n+    for(pT=&pExpr->apExprPhrase[ii]->aTerm[0]; pT; pT=pT->pSynonym){\n+      sqlite3Fts5IndexIterClearTokendata(pT->pIter);\n+    }\n+  }\n+}\n+\n@@ -226598,4 +238237,9 @@\n-** following type. Each object, its key (a nul-terminated string) and\n-** its current data are stored in a single memory allocation. The\n-** key immediately follows the object in memory. The position list\n-** data immediately follows the key data in memory.\n+** following type. Each object, its key, and its current data are stored\n+** in a single memory allocation. The key immediately follows the object\n+** in memory. The position list data immediately follows the key data\n+** in memory.\n+**\n+** The key is Fts5HashEntry.nKey bytes in size. It consists of a single\n+** byte identifying the index (either the main term index or a prefix-index),\n+** followed by the term data. For example: \"0token\". There is no\n+** nul-terminator - in this case nKey=6.\n@@ -226736,2 +238380,1 @@\n-      iHash = fts5HashKey(nNew, (u8*)fts5EntryKey(p),\n-                          (int)strlen(fts5EntryKey(p)));\n+      iHash = fts5HashKey(nNew, (u8*)fts5EntryKey(p), p->nKey);\n@@ -226821,1 +238464,1 @@\n-     && p->nKey==nToken\n+     && p->nKey==nToken+1\n@@ -226851,1 +238494,1 @@\n-    p->nKey = nToken;\n+    p->nKey = nToken+1;\n@@ -226853,1 +238496,1 @@\n-    p->nData = nToken+1 + 1 + sizeof(Fts5HashEntry);\n+    p->nData = nToken+1 + sizeof(Fts5HashEntry);\n@@ -226970,1 +238613,0 @@\n-      int i = 0;\n@@ -226973,1 +238615,1 @@\n-      while( zKey1[i]==zKey2[i] ) i++;\n+      int nMin = MIN(p1->nKey, p2->nKey);\n@@ -226975,1 +238617,7 @@\n-      if( ((u8)zKey1[i])>((u8)zKey2[i]) ){\n+      int cmp = memcmp(zKey1, zKey2, nMin);\n+      if( cmp==0 ){\n+        cmp = p1->nKey - p2->nKey;\n+      }\n+      assert( cmp!=0 );\n+\n+      if( cmp>0 ){\n@@ -226994,4 +238642,2 @@\n-** Extract all tokens from hash table iHash and link them into a list\n-** in sorted order. The hash table is cleared before returning. It is\n-** the responsibility of the caller to free the elements of the returned\n-** list.\n+** Link all tokens from hash table iHash into a list in sorted order. The\n+** tokens are not removed from the hash table.\n@@ -227019,1 +238665,1 @@\n-       || (pIter->nKey+1>=nTerm && 0==memcmp(fts5EntryKey(pIter), pTerm, nTerm))\n+       || (pIter->nKey>=nTerm && 0==memcmp(fts5EntryKey(pIter), pTerm, nTerm))\n@@ -227037,1 +238683,0 @@\n-  pHash->nEntry = 0;\n@@ -227059,2 +238704,1 @@\n-    assert( p->nKey+1==(int)strlen(zKey) );\n-    if( nTerm==p->nKey+1 && memcmp(zKey, pTerm, nTerm)==0 ) break;\n+    if( nTerm==p->nKey && memcmp(zKey, pTerm, nTerm)==0 ) break;\n@@ -227064,1 +238708,1 @@\n-    int nHashPre = sizeof(Fts5HashEntry) + nTerm + 1;\n+    int nHashPre = sizeof(Fts5HashEntry) + nTerm;\n@@ -227091,0 +238735,22 @@\n+#ifdef SQLITE_DEBUG\n+static int fts5HashCount(Fts5Hash *pHash){\n+  int nEntry = 0;\n+  int ii;\n+  for(ii=0; ii<pHash->nSlot; ii++){\n+    Fts5HashEntry *p = 0;\n+    for(p=pHash->aSlot[ii]; p; p=p->pHashNext){\n+      nEntry++;\n+    }\n+  }\n+  return nEntry;\n+}\n+#endif\n+\n+\/*\n+** Return true if the hash table is empty, false otherwise.\n+*\/\n+static int sqlite3Fts5HashIsEmpty(Fts5Hash *pHash){\n+  assert( pHash->nEntry==fts5HashCount(pHash) );\n+  return pHash->nEntry==0;\n+}\n+\n@@ -227103,0 +238769,1 @@\n+  int *pnTerm,                    \/* OUT: Size of term in bytes *\/\n@@ -227109,1 +238776,1 @@\n-    int nTerm = (int)strlen(zKey);\n+    int nTerm = p->nKey;\n@@ -227112,2 +238779,3 @@\n-    *ppDoclist = (const u8*)&zKey[nTerm+1];\n-    *pnDoclist = p->nData - (sizeof(Fts5HashEntry) + nTerm + 1);\n+    *pnTerm = nTerm;\n+    *ppDoclist = (const u8*)&zKey[nTerm];\n+    *pnDoclist = p->nData - (sizeof(Fts5HashEntry) + nTerm);\n@@ -227116,0 +238784,1 @@\n+    *pnTerm = 0;\n@@ -227177,0 +238846,20 @@\n+#define FTS5_MAX_LEVEL 64\n+\n+\/*\n+** There are two versions of the format used for the structure record:\n+**\n+**   1. the legacy format, that may be read by all fts5 versions, and\n+**\n+**   2. the V2 format, which is used by contentless_delete=1 databases.\n+**\n+** Both begin with a 4-byte \"configuration cookie\" value. Then, a legacy\n+** format structure record contains a varint - the number of levels in\n+** the structure. Whereas a V2 structure record contains the constant\n+** 4 bytes [0xff 0x00 0x00 0x01]. This is unambiguous as the value of a\n+** varint has to be at least 16256 to begin with \"0xFF\". And the default\n+** maximum number of levels is 64.\n+**\n+** See below for more on structure record formats.\n+*\/\n+#define FTS5_STRUCTURE_V2 \"\\xFF\\x00\\x00\\x01\"\n+\n@@ -227184,1 +238873,1 @@\n-** , contains the following 5 types of records. See the comments surrounding\n+** , contains the following 6 types of records. See the comments surrounding\n@@ -227193,3 +238882,4 @@\n-**   SQLite varints. If the FTS table features more than one index (because\n-**   there are one or more prefix indexes), it is guaranteed that all share\n-**   the same cookie value.\n+**   SQLite varints.\n+**\n+**   If the structure record is a V2 record, the configuration cookie is\n+**   followed by the following 4 bytes: [0xFF 0x00 0x00 0x01].\n@@ -227197,2 +238887,1 @@\n-**   Immediately following the configuration cookie, the record begins with\n-**   three varints:\n+**   Next, the record continues with three varints:\n@@ -227213,0 +238902,6 @@\n+**      Then, for V2 structures only:\n+**\n+**         + lower origin counter value,\n+**         + upper origin counter value,\n+**         + the number of tombstone hash pages.\n+**\n@@ -227328,0 +239023,32 @@\n+** 6. Tombstone Hash Page\n+**\n+**   These records are only ever present in contentless_delete=1 tables.\n+**   There are zero or more of these associated with each segment. They\n+**   are used to store the tombstone rowids for rows contained in the\n+**   associated segments.\n+**\n+**   The set of nHashPg tombstone hash pages associated with a single\n+**   segment together form a single hash table containing tombstone rowids.\n+**   To find the page of the hash on which a key might be stored:\n+**\n+**       iPg = (rowid % nHashPg)\n+**\n+**   Then, within page iPg, which has nSlot slots:\n+**\n+**       iSlot = (rowid \/ nHashPg) % nSlot\n+**\n+**   Each tombstone hash page begins with an 8 byte header:\n+**\n+**     1-byte:  Key-size (the size in bytes of each slot). Either 4 or 8.\n+**     1-byte:  rowid-0-tombstone flag. This flag is only valid on the\n+**              first tombstone hash page for each segment (iPg=0). If set,\n+**              the hash table contains rowid 0. If clear, it does not.\n+**              Rowid 0 is handled specially.\n+**     2-bytes: unused.\n+**     4-bytes: Big-endian integer containing number of entries on page.\n+**\n+**   Following this are nSlot 4 or 8 byte slots (depending on the key-size\n+**   in the first byte of the page header). The number of slots may be\n+**   determined based on the size of the page record and the key-size:\n+**\n+**     nSlot = (nByte - 8) \/ key-size\n@@ -227361,0 +239088,1 @@\n+#define FTS5_TOMBSTONE_ROWID(segid,ipg)       fts5_dri(segid+(1<<16), 0, 0, ipg)\n@@ -227387,0 +239115,3 @@\n+typedef struct Fts5TokenDataIter Fts5TokenDataIter;\n+typedef struct Fts5TokenDataMap Fts5TokenDataMap;\n+typedef struct Fts5TombstoneArray Fts5TombstoneArray;\n@@ -227396,0 +239127,6 @@\n+**\n+** nContentlessDelete:\n+**   The number of contentless delete operations since the most recent\n+**   call to fts5IndexFlush() or fts5IndexDiscardData(). This is tracked\n+**   so that extra auto-merge work can be done by fts5IndexFlush() to\n+**   account for the delete operations.\n@@ -227410,0 +239147,2 @@\n+  int nContentlessDelete;         \/* Number of contentless delete ops *\/\n+  int nPendingRow;                \/* Number of INSERT in hash table *\/\n@@ -227413,0 +239152,1 @@\n+  int flushRc;\n@@ -227421,0 +239161,1 @@\n+  sqlite3_stmt *pIdxNextSelect;\n@@ -227423,0 +239164,2 @@\n+  sqlite3_stmt *pDeleteFromIdx;\n+\n@@ -227442,0 +239185,5 @@\n+**\n+** nOriginCntr:\n+**   This value is set to non-zero for structure records created for\n+**   contentlessdelete=1 tables only. In that case it represents the\n+**   origin value to apply to the next top-level segment created.\n@@ -227447,0 +239195,7 @@\n+\n+  \/* contentlessdelete=1 tables only: *\/\n+  u64 iOrigin1;\n+  u64 iOrigin2;\n+  int nPgTombstone;               \/* Number of tombstone hash table pages *\/\n+  u64 nEntryTombstone;            \/* Number of tombstone entries that \"count\" *\/\n+  u64 nEntry;                     \/* Number of rows in this segment *\/\n@@ -227456,0 +239211,1 @@\n+  u64 nOriginCntr;                \/* Origin value for next top-level segment *\/\n@@ -227515,3 +239271,0 @@\n-**   rowid field of the current entry. Usually this is the size field of the\n-**   position list data. The exception is if the rowid for the current entry\n-**   is the last thing on the leaf page.\n@@ -227547,0 +239300,7 @@\n+**\n+** apTombstone\/nTombstone:\n+**     These are used for contentless_delete=1 tables only. When the cursor\n+**     is first allocated, the apTombstone[] array is allocated so that it\n+**     is large enough for all tombstones hash pages associated with the\n+**     segment. The pages themselves are loaded lazily from the database as\n+**     they are required.\n@@ -227555,0 +239315,1 @@\n+  Fts5TombstoneArray *pTombArray; \/* Array of tombstone pages *\/\n@@ -227581,0 +239342,9 @@\n+\/*\n+** Array of tombstone pages. Reference counted.\n+*\/\n+struct Fts5TombstoneArray {\n+  int nRef;                       \/* Number of pointers to this object *\/\n+  int nTombstone;\n+  Fts5Data *apTombstone[1];       \/* Array of tombstone pages *\/\n+};\n+\n@@ -227625,0 +239395,6 @@\n+**\n+** pColset:\n+**   If not NULL, points to an object containing a set of column indices.\n+**   Only matches that occur in one of these columns will be returned.\n+**   The Fts5Iter does not own the Fts5Colset object, and so it is not\n+**   freed when the iterator is closed - it is owned by the upper layer.\n@@ -227628,0 +239404,1 @@\n+  Fts5TokenDataIter *pTokenDataIter;\n@@ -227645,1 +239422,0 @@\n-\n@@ -227684,0 +239460,54 @@\n+\/*\n+** The only argument points to a buffer at least 8 bytes in size. This\n+** function interprets the first 8 bytes of the buffer as a 64-bit big-endian\n+** unsigned integer and returns the result.\n+*\/\n+static u64 fts5GetU64(u8 *a){\n+  return ((u64)a[0] << 56)\n+       + ((u64)a[1] << 48)\n+       + ((u64)a[2] << 40)\n+       + ((u64)a[3] << 32)\n+       + ((u64)a[4] << 24)\n+       + ((u64)a[5] << 16)\n+       + ((u64)a[6] << 8)\n+       + ((u64)a[7] << 0);\n+}\n+\n+\/*\n+** The only argument points to a buffer at least 4 bytes in size. This\n+** function interprets the first 4 bytes of the buffer as a 32-bit big-endian\n+** unsigned integer and returns the result.\n+*\/\n+static u32 fts5GetU32(const u8 *a){\n+  return ((u32)a[0] << 24)\n+       + ((u32)a[1] << 16)\n+       + ((u32)a[2] << 8)\n+       + ((u32)a[3] << 0);\n+}\n+\n+\/*\n+** Write iVal, formated as a 64-bit big-endian unsigned integer, to the\n+** buffer indicated by the first argument.\n+*\/\n+static void fts5PutU64(u8 *a, u64 iVal){\n+  a[0] = ((iVal >> 56) & 0xFF);\n+  a[1] = ((iVal >> 48) & 0xFF);\n+  a[2] = ((iVal >> 40) & 0xFF);\n+  a[3] = ((iVal >> 32) & 0xFF);\n+  a[4] = ((iVal >> 24) & 0xFF);\n+  a[5] = ((iVal >> 16) & 0xFF);\n+  a[6] = ((iVal >>  8) & 0xFF);\n+  a[7] = ((iVal >>  0) & 0xFF);\n+}\n+\n+\/*\n+** Write iVal, formated as a 32-bit big-endian unsigned integer, to the\n+** buffer indicated by the first argument.\n+*\/\n+static void fts5PutU32(u8 *a, u32 iVal){\n+  a[0] = ((iVal >> 24) & 0xFF);\n+  a[1] = ((iVal >> 16) & 0xFF);\n+  a[2] = ((iVal >>  8) & 0xFF);\n+  a[3] = ((iVal >>  0) & 0xFF);\n+}\n+\n@@ -227911,1 +239741,2 @@\n-static void fts5DataRemoveSegment(Fts5Index *p, int iSegid){\n+static void fts5DataRemoveSegment(Fts5Index *p, Fts5StructureSegment *pSeg){\n+  int iSegid = pSeg->iSegid;\n@@ -227915,0 +239746,6 @@\n+\n+  if( pSeg->nPgTombstone ){\n+    i64 iTomb1 = FTS5_TOMBSTONE_ROWID(iSegid, 0);\n+    i64 iTomb2 = FTS5_TOMBSTONE_ROWID(iSegid, pSeg->nPgTombstone-1);\n+    fts5DataDelete(p, iTomb1, iTomb2);\n+  }\n@@ -228025,0 +239862,2 @@\n+  int bStructureV2 = 0;           \/* True for FTS5_STRUCTURE_V2 *\/\n+  u64 nOriginCntr = 0;            \/* Largest origin value seen so far *\/\n@@ -228030,0 +239869,6 @@\n+  \/* Check if this is a V2 structure record. Set bStructureV2 if it is. *\/\n+  if( 0==memcmp(&pData[i], FTS5_STRUCTURE_V2, 4) ){\n+    i += 4;\n+    bStructureV2 = 1;\n+  }\n+\n@@ -228076,0 +239921,1 @@\n+          assert( pSeg!=0 );\n@@ -228079,0 +239925,8 @@\n+          if( bStructureV2 ){\n+            i += fts5GetVarint(&pData[i], &pSeg->iOrigin1);\n+            i += fts5GetVarint(&pData[i], &pSeg->iOrigin2);\n+            i += fts5GetVarint32(&pData[i], pSeg->nPgTombstone);\n+            i += fts5GetVarint(&pData[i], &pSeg->nEntryTombstone);\n+            i += fts5GetVarint(&pData[i], &pSeg->nEntry);\n+            nOriginCntr = MAX(nOriginCntr, pSeg->iOrigin2);\n+          }\n@@ -228089,0 +239943,3 @@\n+    if( bStructureV2 ){\n+      pRet->nOriginCntr = nOriginCntr+1;\n+    }\n@@ -228106,0 +239963,1 @@\n+  assert( (ppStruct!=0 && (*ppStruct)!=0) || (*pRc)!=SQLITE_OK );\n@@ -228300,0 +240158,1 @@\n+    int nHdr = (pStruct->nOriginCntr>0 ? (4+4+9+9+9) : (4+9+9));\n@@ -228308,1 +240167,1 @@\n-    if( 0==sqlite3Fts5BufferSize(&p->rc, &buf, 4+9+9+9) ){\n+    if( 0==sqlite3Fts5BufferSize(&p->rc, &buf, nHdr) ){\n@@ -228311,0 +240170,3 @@\n+      if( pStruct->nOriginCntr>0 ){\n+        fts5BufferSafeAppendBlob(&buf, FTS5_STRUCTURE_V2, 4);\n+      }\n@@ -228324,3 +240186,11 @@\n-        fts5BufferAppendVarint(&p->rc, &buf, pLvl->aSeg[iSeg].iSegid);\n-        fts5BufferAppendVarint(&p->rc, &buf, pLvl->aSeg[iSeg].pgnoFirst);\n-        fts5BufferAppendVarint(&p->rc, &buf, pLvl->aSeg[iSeg].pgnoLast);\n+        Fts5StructureSegment *pSeg = &pLvl->aSeg[iSeg];\n+        fts5BufferAppendVarint(&p->rc, &buf, pSeg->iSegid);\n+        fts5BufferAppendVarint(&p->rc, &buf, pSeg->pgnoFirst);\n+        fts5BufferAppendVarint(&p->rc, &buf, pSeg->pgnoLast);\n+        if( pStruct->nOriginCntr>0 ){\n+          fts5BufferAppendVarint(&p->rc, &buf, pSeg->iOrigin1);\n+          fts5BufferAppendVarint(&p->rc, &buf, pSeg->iOrigin2);\n+          fts5BufferAppendVarint(&p->rc, &buf, pSeg->nPgTombstone);\n+          fts5BufferAppendVarint(&p->rc, &buf, pSeg->nEntryTombstone);\n+          fts5BufferAppendVarint(&p->rc, &buf, pSeg->nEntry);\n+        }\n@@ -228469,1 +240339,1 @@\n-      i64 iVal;\n+      u64 iVal;\n@@ -228471,1 +240341,1 @@\n-      iOff += fts5GetVarint(&pData->p[iOff], (u64*)&iVal);\n+      iOff += fts5GetVarint(&pData->p[iOff], &iVal);\n@@ -228564,31 +240434,11 @@\n-    i64 iVal;\n-    int iLimit;\n-    int ii;\n-    int nZero = 0;\n-\n-    \/* Currently iOff points to the first byte of a varint. This block\n-    ** decrements iOff until it points to the first byte of the previous\n-    ** varint. Taking care not to read any memory locations that occur\n-    ** before the buffer in memory.  *\/\n-    iLimit = (iOff>9 ? iOff-9 : 0);\n-    for(iOff--; iOff>iLimit; iOff--){\n-      if( (a[iOff-1] & 0x80)==0 ) break;\n-    }\n-\n-    fts5GetVarint(&a[iOff], (u64*)&iVal);\n-    pLvl->iRowid -= iVal;\n-    pLvl->iLeafPgno--;\n-\n-    \/* Skip backwards past any 0x00 varints. *\/\n-    for(ii=iOff-1; ii>=pLvl->iFirstOff && a[ii]==0x00; ii--){\n-      nZero++;\n-    }\n-    if( ii>=pLvl->iFirstOff && (a[ii] & 0x80) ){\n-      \/* The byte immediately before the last 0x00 byte has the 0x80 bit\n-      ** set. So the last 0x00 is only a varint 0 if there are 8 more 0x80\n-      ** bytes before a[ii]. *\/\n-      int bZero = 0;              \/* True if last 0x00 counts *\/\n-      if( (ii-8)>=pLvl->iFirstOff ){\n-        int j;\n-        for(j=1; j<=8 && (a[ii-j] & 0x80); j++);\n-        bZero = (j>8);\n+\n+    pLvl->iOff = 0;\n+    fts5DlidxLvlNext(pLvl);\n+    while( 1 ){\n+      int nZero = 0;\n+      int ii = pLvl->iOff;\n+      u64 delta = 0;\n+\n+      while( a[ii]==0 ){\n+        nZero++;\n+        ii++;\n@@ -228596,1 +240446,6 @@\n-      if( bZero==0 ) nZero--;\n+      ii += sqlite3Fts5GetVarint(&a[ii], &delta);\n+\n+      if( ii>=iOff ) break;\n+      pLvl->iLeafPgno += nZero+1;\n+      pLvl->iRowid += delta;\n+      pLvl->iOff = ii;\n@@ -228598,2 +240453,0 @@\n-    pLvl->iLeafPgno -= nZero;\n-    pLvl->iOff = iOff - nZero;\n@@ -228795,1 +240648,1 @@\n-  if( iOff>=pIter->pLeaf->szLeaf ){\n+  while( iOff>=pIter->pLeaf->szLeaf ){\n@@ -228866,0 +240719,19 @@\n+\/*\n+** Allocate a tombstone hash page array object (pIter->pTombArray) for\n+** the iterator passed as the second argument. If an OOM error occurs,\n+** leave an error in the Fts5Index object.\n+*\/\n+static void fts5SegIterAllocTombstone(Fts5Index *p, Fts5SegIter *pIter){\n+  const int nTomb = pIter->pSeg->nPgTombstone;\n+  if( nTomb>0 ){\n+    int nByte = nTomb * sizeof(Fts5Data*) + sizeof(Fts5TombstoneArray);\n+    Fts5TombstoneArray *pNew;\n+    pNew = (Fts5TombstoneArray*)sqlite3Fts5MallocZero(&p->rc, nByte);\n+    if( pNew ){\n+      pNew->nTombstone = nTomb;\n+      pNew->nRef = 1;\n+      pIter->pTombArray = pNew;\n+    }\n+  }\n+}\n+\n@@ -228894,1 +240766,3 @@\n-    fts5SegIterNextPage(p, pIter);\n+    do {\n+      fts5SegIterNextPage(p, pIter);\n+    }while( p->rc==SQLITE_OK && pIter->pLeaf && pIter->pLeaf->nn==4 );\n@@ -228897,1 +240771,1 @@\n-  if( p->rc==SQLITE_OK ){\n+  if( p->rc==SQLITE_OK && pIter->pLeaf ){\n@@ -228905,0 +240779,1 @@\n+    fts5SegIterAllocTombstone(p, pIter);\n@@ -229091,1 +240966,1 @@\n-  if( pIter->pSeg && iOff>=pIter->pLeaf->szLeaf ){\n+  while( pIter->pSeg && iOff>=pIter->pLeaf->szLeaf ){\n@@ -229115,0 +240990,1 @@\n+      int nTerm = 0;\n@@ -229117,1 +240993,1 @@\n-      sqlite3Fts5HashScanEntry(p->pHash, &zTerm, &pList, &nList);\n+      sqlite3Fts5HashScanEntry(p->pHash, &zTerm, &nTerm, &pList, &nList);\n@@ -229123,1 +240999,1 @@\n-      sqlite3Fts5BufferSet(&p->rc,&pIter->term, (int)strlen(zTerm), (u8*)zTerm);\n+      sqlite3Fts5BufferSet(&p->rc,&pIter->term, nTerm, (u8*)zTerm);\n@@ -229189,0 +241065,1 @@\n+    int nTerm = 0;\n@@ -229193,1 +241070,1 @@\n-      sqlite3Fts5HashScanEntry(p->pHash, &zTerm, &pList, &nList);\n+      sqlite3Fts5HashScanEntry(p->pHash, &zTerm, &nTerm, &pList, &nList);\n@@ -229203,2 +241080,1 @@\n-      sqlite3Fts5BufferSet(&p->rc, &pIter->term, (int)strlen(zTerm),\n-          (u8*)zTerm);\n+      sqlite3Fts5BufferSet(&p->rc, &pIter->term, nTerm, (u8*)zTerm);\n@@ -229284,1 +241160,1 @@\n-  if( pDlidx ){\n+  if( pDlidx && p->pConfig->iVersion==FTS5_CURRENT_VERSION ){\n@@ -229590,1 +241466,1 @@\n-  if( p->rc==SQLITE_OK && bGe==0 ){\n+  if( p->rc==SQLITE_OK && (bGe==0 || (flags & FTS5INDEX_QUERY_SCANONETERM)) ){\n@@ -229606,0 +241482,3 @@\n+  if( 0==(flags & FTS5INDEX_QUERY_SCANONETERM) ){\n+    fts5SegIterAllocTombstone(p, pIter);\n+  }\n@@ -229622,0 +241501,73 @@\n+\n+\/*\n+** SQL used by fts5SegIterNextInit() to find the page to open.\n+*\/\n+static sqlite3_stmt *fts5IdxNextStmt(Fts5Index *p){\n+  if( p->pIdxNextSelect==0 ){\n+    Fts5Config *pConfig = p->pConfig;\n+    fts5IndexPrepareStmt(p, &p->pIdxNextSelect, sqlite3_mprintf(\n+          \"SELECT pgno FROM '%q'.'%q_idx' WHERE \"\n+          \"segid=? AND term>? ORDER BY term ASC LIMIT 1\",\n+          pConfig->zDb, pConfig->zName\n+    ));\n+\n+  }\n+  return p->pIdxNextSelect;\n+}\n+\n+\/*\n+** This is similar to fts5SegIterSeekInit(), except that it initializes\n+** the segment iterator to point to the first term following the page\n+** with pToken\/nToken on it.\n+*\/\n+static void fts5SegIterNextInit(\n+  Fts5Index *p,\n+  const char *pTerm, int nTerm,\n+  Fts5StructureSegment *pSeg,     \/* Description of segment *\/\n+  Fts5SegIter *pIter              \/* Object to populate *\/\n+){\n+  int iPg = -1;                   \/* Page of segment to open *\/\n+  int bDlidx = 0;\n+  sqlite3_stmt *pSel = 0;         \/* SELECT to find iPg *\/\n+\n+  pSel = fts5IdxNextStmt(p);\n+  if( pSel ){\n+    assert( p->rc==SQLITE_OK );\n+    sqlite3_bind_int(pSel, 1, pSeg->iSegid);\n+    sqlite3_bind_blob(pSel, 2, pTerm, nTerm, SQLITE_STATIC);\n+\n+    if( sqlite3_step(pSel)==SQLITE_ROW ){\n+      i64 val = sqlite3_column_int64(pSel, 0);\n+      iPg = (int)(val>>1);\n+      bDlidx = (val & 0x0001);\n+    }\n+    p->rc = sqlite3_reset(pSel);\n+    sqlite3_bind_null(pSel, 2);\n+    if( p->rc ) return;\n+  }\n+\n+  memset(pIter, 0, sizeof(*pIter));\n+  pIter->pSeg = pSeg;\n+  pIter->flags |= FTS5_SEGITER_ONETERM;\n+  if( iPg>=0 ){\n+    pIter->iLeafPgno = iPg - 1;\n+    fts5SegIterNextPage(p, pIter);\n+    fts5SegIterSetNext(p, pIter);\n+  }\n+  if( pIter->pLeaf ){\n+    const u8 *a = pIter->pLeaf->p;\n+    int iTermOff = 0;\n+\n+    pIter->iPgidxOff = pIter->pLeaf->szLeaf;\n+    pIter->iPgidxOff += fts5GetVarint32(&a[pIter->iPgidxOff], iTermOff);\n+    pIter->iLeafOffset = iTermOff;\n+    fts5SegIterLoadTerm(p, pIter, 0);\n+    fts5SegIterLoadNPos(p, pIter);\n+    if( bDlidx ) fts5SegIterLoadDlidx(p, pIter);\n+\n+    assert( p->rc!=SQLITE_OK ||\n+        fts5BufferCompareBlob(&pIter->term, (const u8*)pTerm, nTerm)>0\n+    );\n+  }\n+}\n+\n@@ -229648,2 +241600,1 @@\n-    sqlite3Fts5HashScanEntry(p->pHash, (const char**)&z, &pList, &nList);\n-    n = (z ? (int)strlen((const char*)z) : 0);\n+    sqlite3Fts5HashScanEntry(p->pHash, (const char**)&z, &n, &pList, &nList);\n@@ -229656,0 +241607,8 @@\n+\n+    \/* The call to sqlite3Fts5HashScanInit() causes the hash table to\n+    ** fill the size field of all existing position lists. This means they\n+    ** can no longer be appended to. Since the only scenario in which they\n+    ** can be appended to is if the previous operation on this table was\n+    ** a DELETE, by clearing the Fts5Index.bDelete flag we can avoid this\n+    ** possibility altogether.  *\/\n+    p->bDelete = 0;\n@@ -229686,0 +241645,31 @@\n+\/*\n+** Array ap[] contains n elements. Release each of these elements using\n+** fts5DataRelease(). Then free the array itself using sqlite3_free().\n+*\/\n+static void fts5IndexFreeArray(Fts5Data **ap, int n){\n+  if( ap ){\n+    int ii;\n+    for(ii=0; ii<n; ii++){\n+      fts5DataRelease(ap[ii]);\n+    }\n+    sqlite3_free(ap);\n+  }\n+}\n+\n+\/*\n+** Decrement the ref-count of the object passed as the only argument. If it\n+** reaches 0, free it and its contents.\n+*\/\n+static void fts5TombstoneArrayDelete(Fts5TombstoneArray *p){\n+  if( p ){\n+    p->nRef--;\n+    if( p->nRef<=0 ){\n+      int ii;\n+      for(ii=0; ii<p->nTombstone; ii++){\n+        fts5DataRelease(p->apTombstone[ii]);\n+      }\n+      sqlite3_free(p);\n+    }\n+  }\n+}\n+\n@@ -229693,0 +241683,1 @@\n+  fts5TombstoneArrayDelete(pIter->pTombArray);\n@@ -229826,1 +241817,0 @@\n-        p1->bDel = p2->bDel;\n@@ -229845,1 +241835,2 @@\n-** It is an error if leaf iLeafPgno does not exist or contains no rowids.\n+** It is an error if leaf iLeafPgno does not exist. Unless the db is\n+** a 'secure-delete' db, if it contains no rowids then this is also an error.\n@@ -229860,2 +241851,0 @@\n-    fts5SegIterNextPage(p, pIter);\n-    assert( p->rc!=SQLITE_OK || pIter->iLeafPgno==iLeafPgno );\n@@ -229863,1 +241852,1 @@\n-    if( p->rc==SQLITE_OK && ALWAYS(pIter->pLeaf!=0) ){\n+    while( p->rc==SQLITE_OK ){\n@@ -229865,3 +241854,2 @@\n-      u8 *a = pIter->pLeaf->p;\n-      int n = pIter->pLeaf->szLeaf;\n-\n+      fts5SegIterNextPage(p, pIter);\n+      if( pIter->pLeaf==0 ) break;\n@@ -229869,6 +241857,11 @@\n-      if( iOff<4 || iOff>=n ){\n-        p->rc = FTS5_CORRUPT;\n-      }else{\n-        iOff += fts5GetVarint(&a[iOff], (u64*)&pIter->iRowid);\n-        pIter->iLeafOffset = iOff;\n-        fts5SegIterLoadNPos(p, pIter);\n+      if( iOff>0 ){\n+        u8 *a = pIter->pLeaf->p;\n+        int n = pIter->pLeaf->szLeaf;\n+        if( iOff<4 || iOff>=n ){\n+          p->rc = FTS5_CORRUPT;\n+        }else{\n+          iOff += fts5GetVarint(&a[iOff], (u64*)&pIter->iRowid);\n+          pIter->iLeafOffset = iOff;\n+          fts5SegIterLoadNPos(p, pIter);\n+        }\n+        break;\n@@ -229935,1 +241928,0 @@\n-\n@@ -230027,0 +242019,79 @@\n+\/*\n+** The argument to this macro must be an Fts5Data structure containing a\n+** tombstone hash page. This macro returns the key-size of the hash-page.\n+*\/\n+#define TOMBSTONE_KEYSIZE(pPg) (pPg->p[0]==4 ? 4 : 8)\n+\n+#define TOMBSTONE_NSLOT(pPg)   \\\n+  ((pPg->nn > 16) ? ((pPg->nn-8) \/ TOMBSTONE_KEYSIZE(pPg)) : 1)\n+\n+\/*\n+** Query a single tombstone hash table for rowid iRowid. Return true if\n+** it is found or false otherwise. The tombstone hash table is one of\n+** nHashTable tables.\n+*\/\n+static int fts5IndexTombstoneQuery(\n+  Fts5Data *pHash,                \/* Hash table page to query *\/\n+  int nHashTable,                 \/* Number of pages attached to segment *\/\n+  u64 iRowid                      \/* Rowid to query hash for *\/\n+){\n+  const int szKey = TOMBSTONE_KEYSIZE(pHash);\n+  const int nSlot = TOMBSTONE_NSLOT(pHash);\n+  int iSlot = (iRowid \/ nHashTable) % nSlot;\n+  int nCollide = nSlot;\n+\n+  if( iRowid==0 ){\n+    return pHash->p[1];\n+  }else if( szKey==4 ){\n+    u32 *aSlot = (u32*)&pHash->p[8];\n+    while( aSlot[iSlot] ){\n+      if( fts5GetU32((u8*)&aSlot[iSlot])==iRowid ) return 1;\n+      if( nCollide--==0 ) break;\n+      iSlot = (iSlot+1)%nSlot;\n+    }\n+  }else{\n+    u64 *aSlot = (u64*)&pHash->p[8];\n+    while( aSlot[iSlot] ){\n+      if( fts5GetU64((u8*)&aSlot[iSlot])==iRowid ) return 1;\n+      if( nCollide--==0 ) break;\n+      iSlot = (iSlot+1)%nSlot;\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n+\/*\n+** Return true if the iterator passed as the only argument points\n+** to an segment entry for which there is a tombstone. Return false\n+** if there is no tombstone or if the iterator is already at EOF.\n+*\/\n+static int fts5MultiIterIsDeleted(Fts5Iter *pIter){\n+  int iFirst = pIter->aFirst[1].iFirst;\n+  Fts5SegIter *pSeg = &pIter->aSeg[iFirst];\n+  Fts5TombstoneArray *pArray = pSeg->pTombArray;\n+\n+  if( pSeg->pLeaf && pArray ){\n+    \/* Figure out which page the rowid might be present on. *\/\n+    int iPg = ((u64)pSeg->iRowid) % pArray->nTombstone;\n+    assert( iPg>=0 );\n+\n+    \/* If tombstone hash page iPg has not yet been loaded from the\n+    ** database, load it now. *\/\n+    if( pArray->apTombstone[iPg]==0 ){\n+      pArray->apTombstone[iPg] = fts5DataRead(pIter->pIndex,\n+          FTS5_TOMBSTONE_ROWID(pSeg->pSeg->iSegid, iPg)\n+      );\n+      if( pArray->apTombstone[iPg]==0 ) return 0;\n+    }\n+\n+    return fts5IndexTombstoneQuery(\n+        pArray->apTombstone[iPg],\n+        pArray->nTombstone,\n+        pSeg->iRowid\n+    );\n+  }\n+\n+  return 0;\n+}\n+\n@@ -230064,1 +242135,3 @@\n-    if( pIter->bSkipEmpty==0 || pSeg->nPos ){\n+    if( (pIter->bSkipEmpty==0 || pSeg->nPos)\n+      && 0==fts5MultiIterIsDeleted(pIter)\n+    ){\n@@ -230096,1 +242169,3 @@\n-    }while( fts5MultiIterIsEmpty(p, pIter) );\n+    }while( (fts5MultiIterIsEmpty(p, pIter) || fts5MultiIterIsDeleted(pIter))\n+         && (p->rc==SQLITE_OK)\n+    );\n@@ -230109,1 +242184,1 @@\n-  int nSlot;                      \/* Power of two >= nSeg *\/\n+  i64 nSlot;                      \/* Power of two >= nSeg *\/\n@@ -230554,0 +242629,26 @@\n+\/*\n+** All the component segment-iterators of pIter have been set up. This\n+** functions finishes setup for iterator pIter itself.\n+*\/\n+static void fts5MultiIterFinishSetup(Fts5Index *p, Fts5Iter *pIter){\n+  int iIter;\n+  for(iIter=pIter->nSeg-1; iIter>0; iIter--){\n+    int iEq;\n+    if( (iEq = fts5MultiIterDoCompare(pIter, iIter)) ){\n+      Fts5SegIter *pSeg = &pIter->aSeg[iEq];\n+      if( p->rc==SQLITE_OK ) pSeg->xNext(p, pSeg, 0);\n+      fts5MultiIterAdvanced(p, pIter, iEq, iIter);\n+    }\n+  }\n+  fts5MultiIterSetEof(pIter);\n+  fts5AssertMultiIterSetup(p, pIter);\n+\n+  if( (pIter->bSkipEmpty && fts5MultiIterIsEmpty(p, pIter))\n+   || fts5MultiIterIsDeleted(pIter)\n+  ){\n+    fts5MultiIterNext(p, pIter, 0, 0);\n+  }else if( pIter->base.bEof==0 ){\n+    Fts5SegIter *pSeg = &pIter->aSeg[pIter->aFirst[1].iFirst];\n+    pIter->xSetOutputs(pIter, pSeg);\n+  }\n+}\n@@ -230589,1 +242690,1 @@\n-      nSeg += (p->pHash ? 1 : 0);\n+      nSeg += (p->pHash && 0==(flags & FTS5INDEX_QUERY_SKIPHASH));\n@@ -230610,1 +242711,1 @@\n-      if( p->pHash ){\n+      if( p->pHash && 0==(flags & FTS5INDEX_QUERY_SKIPHASH) ){\n@@ -230635,1 +242736,1 @@\n-  \/* If the above was successful, each component iterators now points\n+  \/* If the above was successful, each component iterator now points\n@@ -230640,18 +242741,1 @@\n-    for(iIter=pNew->nSeg-1; iIter>0; iIter--){\n-      int iEq;\n-      if( (iEq = fts5MultiIterDoCompare(pNew, iIter)) ){\n-        Fts5SegIter *pSeg = &pNew->aSeg[iEq];\n-        if( p->rc==SQLITE_OK ) pSeg->xNext(p, pSeg, 0);\n-        fts5MultiIterAdvanced(p, pNew, iEq, iIter);\n-      }\n-    }\n-    fts5MultiIterSetEof(pNew);\n-    fts5AssertMultiIterSetup(p, pNew);\n-\n-    if( pNew->bSkipEmpty && fts5MultiIterIsEmpty(p, pNew) ){\n-      fts5MultiIterNext(p, pNew, 0, 0);\n-    }else if( pNew->base.bEof==0 ){\n-      Fts5SegIter *pSeg = &pNew->aSeg[pNew->aFirst[1].iFirst];\n-      pNew->xSetOutputs(pNew, pSeg);\n-    }\n-\n+    fts5MultiIterFinishSetup(p, pNew);\n@@ -230682,1 +242766,0 @@\n-\n@@ -230829,0 +242912,2 @@\n+    p->nPendingRow = 0;\n+    p->flushRc = SQLITE_OK;\n@@ -230830,0 +242915,1 @@\n+  p->nContentlessDelete = 0;\n@@ -231043,1 +243129,1 @@\n-      iVal = iRowid - pDlidx->iPrev;\n+      iVal = (u64)iRowid - (u64)pDlidx->iPrev;\n@@ -231210,1 +243296,3 @@\n-      fts5BufferAppendVarint(&p->rc, &pPage->buf, iRowid - pWriter->iPrevRowid);\n+      fts5BufferAppendVarint(&p->rc, &pPage->buf,\n+          (u64)iRowid - (u64)pWriter->iPrevRowid\n+      );\n@@ -231228,1 +243316,1 @@\n-  assert( p->pConfig->pgsz>0 );\n+  assert( p->pConfig->pgsz>0 || p->rc!=SQLITE_OK );\n@@ -231363,1 +243451,1 @@\n-          fts5BufferAppendBlob(&p->rc, &buf, pData->szLeaf-iOff,&pData->p[iOff]);\n+          fts5BufferAppendBlob(&p->rc, &buf,pData->szLeaf-iOff,&pData->p[iOff]);\n@@ -231464,0 +243552,6 @@\n+\n+    \/* Set the range of origins that will go into the output segment. *\/\n+    if( pStruct->nOriginCntr>0 ){\n+      pSeg->iOrigin1 = pLvl->aSeg[0].iOrigin1;\n+      pSeg->iOrigin2 = pLvl->aSeg[pLvl->nSeg-1].iOrigin2;\n+    }\n@@ -231523,0 +243617,1 @@\n+    assert( pSeg->nEntry==0 );\n@@ -231524,1 +243619,3 @@\n-      fts5DataRemoveSegment(p, pLvl->aSeg[i].iSegid);\n+      Fts5StructureSegment *pOld = &pLvl->aSeg[i];\n+      pSeg->nEntry += (pOld->nEntry - pOld->nEntryTombstone);\n+      fts5DataRemoveSegment(p, pOld);\n@@ -231550,0 +243647,37 @@\n+\/*\n+** If this is not a contentless_delete=1 table, or if the 'deletemerge'\n+** configuration option is set to 0, then this function always returns -1.\n+** Otherwise, it searches the structure object passed as the second argument\n+** for a level suitable for merging due to having a large number of\n+** tombstones in the tombstone hash. If one is found, its index is returned.\n+** Otherwise, if there is no suitable level, -1.\n+*\/\n+static int fts5IndexFindDeleteMerge(Fts5Index *p, Fts5Structure *pStruct){\n+  Fts5Config *pConfig = p->pConfig;\n+  int iRet = -1;\n+  if( pConfig->bContentlessDelete && pConfig->nDeleteMerge>0 ){\n+    int ii;\n+    int nBest = 0;\n+\n+    for(ii=0; ii<pStruct->nLevel; ii++){\n+      Fts5StructureLevel *pLvl = &pStruct->aLevel[ii];\n+      i64 nEntry = 0;\n+      i64 nTomb = 0;\n+      int iSeg;\n+      for(iSeg=0; iSeg<pLvl->nSeg; iSeg++){\n+        nEntry += pLvl->aSeg[iSeg].nEntry;\n+        nTomb += pLvl->aSeg[iSeg].nEntryTombstone;\n+      }\n+      assert_nc( nEntry>0 || pLvl->nSeg==0 );\n+      if( nEntry>0 ){\n+        int nPercent = (nTomb * 100) \/ nEntry;\n+        if( nPercent>=pConfig->nDeleteMerge && nPercent>nBest ){\n+          iRet = ii;\n+          nBest = nPercent;\n+        }\n+      }\n+    }\n+  }\n+  return iRet;\n+}\n+\n@@ -231569,1 +243703,2 @@\n-    \/* Set iBestLvl to the level to read input segments from. *\/\n+    \/* Set iBestLvl to the level to read input segments from. Or to -1 if\n+    ** there is no level suitable to merge segments from.  *\/\n@@ -231576,1 +243711,1 @@\n-          nBest = pLvl->nMerge;\n+          nBest = nMin;\n@@ -231585,5 +243720,2 @@\n-\n-    \/* If nBest is still 0, then the index must be empty. *\/\n-#ifdef SQLITE_DEBUG\n-    for(iLvl=0; nBest==0 && iLvl<pStruct->nLevel; iLvl++){\n-      assert( pStruct->aLevel[iLvl].nSeg==0 );\n+    if( nBest<nMin ){\n+      iBestLvl = fts5IndexFindDeleteMerge(p, pStruct);\n@@ -231591,1 +243723,0 @@\n-#endif\n@@ -231593,3 +243724,1 @@\n-    if( nBest<nMin && pStruct->aLevel[iBestLvl].nMerge==0 ){\n-      break;\n-    }\n+    if( iBestLvl<0 ) break;\n@@ -231601,0 +243730,2 @@\n+\n+    if( nMin==1 ) nMin = 2;\n@@ -231641,8 +243772,9 @@\n-  int iLvl = 0;\n-\n-  assert( p->rc!=SQLITE_OK || pStruct->nLevel>0 );\n-  while( p->rc==SQLITE_OK && pStruct->aLevel[iLvl].nSeg>=nCrisis ){\n-    fts5IndexMergeLevel(p, &pStruct, iLvl, 0);\n-    assert( p->rc!=SQLITE_OK || pStruct->nLevel>(iLvl+1) );\n-    fts5StructurePromote(p, iLvl+1, pStruct);\n-    iLvl++;\n+  if( pStruct && pStruct->nLevel>0 ){\n+    int iLvl = 0;\n+    while( p->rc==SQLITE_OK && pStruct->aLevel[iLvl].nSeg>=nCrisis ){\n+      fts5IndexMergeLevel(p, &pStruct, iLvl, 0);\n+      assert( p->rc!=SQLITE_OK || pStruct->nLevel>(iLvl+1) );\n+      fts5StructurePromote(p, iLvl+1, pStruct);\n+      iLvl++;\n+    }\n+    *ppStruct = pStruct;\n@@ -231650,1 +243782,0 @@\n-  *ppStruct = pStruct;\n@@ -231684,0 +243815,463 @@\n+\/*\n+** Execute the SQL statement:\n+**\n+**    DELETE FROM %_idx WHERE (segid, (pgno\/2)) = ($iSegid, $iPgno);\n+**\n+** This is used when a secure-delete operation removes the last term\n+** from a segment leaf page. In that case the %_idx entry is removed\n+** too. This is done to ensure that if all instances of a token are\n+** removed from an fts5 database in secure-delete mode, no trace of\n+** the token itself remains in the database.\n+*\/\n+static void fts5SecureDeleteIdxEntry(\n+  Fts5Index *p,                   \/* FTS5 backend object *\/\n+  int iSegid,                     \/* Id of segment to delete entry for *\/\n+  int iPgno                       \/* Page number within segment *\/\n+){\n+  if( iPgno!=1 ){\n+    assert( p->pConfig->iVersion==FTS5_CURRENT_VERSION_SECUREDELETE );\n+    if( p->pDeleteFromIdx==0 ){\n+      fts5IndexPrepareStmt(p, &p->pDeleteFromIdx, sqlite3_mprintf(\n+          \"DELETE FROM '%q'.'%q_idx' WHERE (segid, (pgno\/2)) = (?1, ?2)\",\n+          p->pConfig->zDb, p->pConfig->zName\n+      ));\n+    }\n+    if( p->rc==SQLITE_OK ){\n+      sqlite3_bind_int(p->pDeleteFromIdx, 1, iSegid);\n+      sqlite3_bind_int(p->pDeleteFromIdx, 2, iPgno);\n+      sqlite3_step(p->pDeleteFromIdx);\n+      p->rc = sqlite3_reset(p->pDeleteFromIdx);\n+    }\n+  }\n+}\n+\n+\/*\n+** This is called when a secure-delete operation removes a position-list\n+** that overflows onto segment page iPgno of segment pSeg. This function\n+** rewrites node iPgno, and possibly one or more of its right-hand peers,\n+** to remove this portion of the position list.\n+**\n+** Output variable (*pbLastInDoclist) is set to true if the position-list\n+** removed is followed by a new term or the end-of-segment, or false if\n+** it is followed by another rowid\/position list.\n+*\/\n+static void fts5SecureDeleteOverflow(\n+  Fts5Index *p,\n+  Fts5StructureSegment *pSeg,\n+  int iPgno,\n+  int *pbLastInDoclist\n+){\n+  const int bDetailNone = (p->pConfig->eDetail==FTS5_DETAIL_NONE);\n+  int pgno;\n+  Fts5Data *pLeaf = 0;\n+  assert( iPgno!=1 );\n+\n+  *pbLastInDoclist = 1;\n+  for(pgno=iPgno; p->rc==SQLITE_OK && pgno<=pSeg->pgnoLast; pgno++){\n+    i64 iRowid = FTS5_SEGMENT_ROWID(pSeg->iSegid, pgno);\n+    int iNext = 0;\n+    u8 *aPg = 0;\n+\n+    pLeaf = fts5DataRead(p, iRowid);\n+    if( pLeaf==0 ) break;\n+    aPg = pLeaf->p;\n+\n+    iNext = fts5GetU16(&aPg[0]);\n+    if( iNext!=0 ){\n+      *pbLastInDoclist = 0;\n+    }\n+    if( iNext==0 && pLeaf->szLeaf!=pLeaf->nn ){\n+      fts5GetVarint32(&aPg[pLeaf->szLeaf], iNext);\n+    }\n+\n+    if( iNext==0 ){\n+      \/* The page contains no terms or rowids. Replace it with an empty\n+      ** page and move on to the right-hand peer.  *\/\n+      const u8 aEmpty[] = {0x00, 0x00, 0x00, 0x04};\n+      assert_nc( bDetailNone==0 || pLeaf->nn==4 );\n+      if( bDetailNone==0 ) fts5DataWrite(p, iRowid, aEmpty, sizeof(aEmpty));\n+      fts5DataRelease(pLeaf);\n+      pLeaf = 0;\n+    }else if( bDetailNone ){\n+      break;\n+    }else if( iNext>=pLeaf->szLeaf || pLeaf->nn<pLeaf->szLeaf || iNext<4 ){\n+      p->rc = FTS5_CORRUPT;\n+      break;\n+    }else{\n+      int nShift = iNext - 4;\n+      int nPg;\n+\n+      int nIdx = 0;\n+      u8 *aIdx = 0;\n+\n+      \/* Unless the current page footer is 0 bytes in size (in which case\n+      ** the new page footer will be as well), allocate and populate a\n+      ** buffer containing the new page footer. Set stack variables aIdx\n+      ** and nIdx accordingly.  *\/\n+      if( pLeaf->nn>pLeaf->szLeaf ){\n+        int iFirst = 0;\n+        int i1 = pLeaf->szLeaf;\n+        int i2 = 0;\n+\n+        i1 += fts5GetVarint32(&aPg[i1], iFirst);\n+        if( iFirst<iNext ){\n+          p->rc = FTS5_CORRUPT;\n+          break;\n+        }\n+        aIdx = sqlite3Fts5MallocZero(&p->rc, (pLeaf->nn-pLeaf->szLeaf)+2);\n+        if( aIdx==0 ) break;\n+        i2 = sqlite3Fts5PutVarint(aIdx, iFirst-nShift);\n+        if( i1<pLeaf->nn ){\n+          memcpy(&aIdx[i2], &aPg[i1], pLeaf->nn-i1);\n+          i2 += (pLeaf->nn-i1);\n+        }\n+        nIdx = i2;\n+      }\n+\n+      \/* Modify the contents of buffer aPg[]. Set nPg to the new size\n+      ** in bytes. The new page is always smaller than the old.  *\/\n+      nPg = pLeaf->szLeaf - nShift;\n+      memmove(&aPg[4], &aPg[4+nShift], nPg-4);\n+      fts5PutU16(&aPg[2], nPg);\n+      if( fts5GetU16(&aPg[0]) ) fts5PutU16(&aPg[0], 4);\n+      if( nIdx>0 ){\n+        memcpy(&aPg[nPg], aIdx, nIdx);\n+        nPg += nIdx;\n+      }\n+      sqlite3_free(aIdx);\n+\n+      \/* Write the new page to disk and exit the loop *\/\n+      assert( nPg>4 || fts5GetU16(aPg)==0 );\n+      fts5DataWrite(p, iRowid, aPg, nPg);\n+      break;\n+    }\n+  }\n+  fts5DataRelease(pLeaf);\n+}\n+\n+\/*\n+** Completely remove the entry that pSeg currently points to from\n+** the database.\n+*\/\n+static void fts5DoSecureDelete(\n+  Fts5Index *p,\n+  Fts5SegIter *pSeg\n+){\n+  const int bDetailNone = (p->pConfig->eDetail==FTS5_DETAIL_NONE);\n+  int iSegid = pSeg->pSeg->iSegid;\n+  u8 *aPg = pSeg->pLeaf->p;\n+  int nPg = pSeg->pLeaf->nn;\n+  int iPgIdx = pSeg->pLeaf->szLeaf;\n+\n+  u64 iDelta = 0;\n+  int iNextOff = 0;\n+  int iOff = 0;\n+  int nIdx = 0;\n+  u8 *aIdx = 0;\n+  int bLastInDoclist = 0;\n+  int iIdx = 0;\n+  int iStart = 0;\n+  int iDelKeyOff = 0;       \/* Offset of deleted key, if any *\/\n+\n+  nIdx = nPg-iPgIdx;\n+  aIdx = sqlite3Fts5MallocZero(&p->rc, nIdx+16);\n+  if( p->rc ) return;\n+  memcpy(aIdx, &aPg[iPgIdx], nIdx);\n+\n+  \/* At this point segment iterator pSeg points to the entry\n+  ** this function should remove from the b-tree segment.\n+  **\n+  ** In detail=full or detail=column mode, pSeg->iLeafOffset is the\n+  ** offset of the first byte in the position-list for the entry to\n+  ** remove. Immediately before this comes two varints that will also\n+  ** need to be removed:\n+  **\n+  **     + the rowid or delta rowid value for the entry, and\n+  **     + the size of the position list in bytes.\n+  **\n+  ** Or, in detail=none mode, there is a single varint prior to\n+  ** pSeg->iLeafOffset - the rowid or delta rowid value.\n+  **\n+  ** This block sets the following variables:\n+  **\n+  **   iStart:\n+  **     The offset of the first byte of the rowid or delta-rowid\n+  **     value for the doclist entry being removed.\n+  **\n+  **   iDelta:\n+  **     The value of the rowid or delta-rowid value for the doclist\n+  **     entry being removed.\n+  **\n+  **   iNextOff:\n+  **     The offset of the next entry following the position list\n+  **     for the one being removed. If the position list for this\n+  **     entry overflows onto the next leaf page, this value will be\n+  **     greater than pLeaf->szLeaf.\n+  *\/\n+  {\n+    int iSOP;                     \/* Start-Of-Position-list *\/\n+    if( pSeg->iLeafPgno==pSeg->iTermLeafPgno ){\n+      iStart = pSeg->iTermLeafOffset;\n+    }else{\n+      iStart = fts5GetU16(&aPg[0]);\n+    }\n+\n+    iSOP = iStart + fts5GetVarint(&aPg[iStart], &iDelta);\n+    assert_nc( iSOP<=pSeg->iLeafOffset );\n+\n+    if( bDetailNone ){\n+      while( iSOP<pSeg->iLeafOffset ){\n+        if( aPg[iSOP]==0x00 ) iSOP++;\n+        if( aPg[iSOP]==0x00 ) iSOP++;\n+        iStart = iSOP;\n+        iSOP = iStart + fts5GetVarint(&aPg[iStart], &iDelta);\n+      }\n+\n+      iNextOff = iSOP;\n+      if( iNextOff<pSeg->iEndofDoclist && aPg[iNextOff]==0x00 ) iNextOff++;\n+      if( iNextOff<pSeg->iEndofDoclist && aPg[iNextOff]==0x00 ) iNextOff++;\n+\n+    }else{\n+      int nPos = 0;\n+      iSOP += fts5GetVarint32(&aPg[iSOP], nPos);\n+      while( iSOP<pSeg->iLeafOffset ){\n+        iStart = iSOP + (nPos\/2);\n+        iSOP = iStart + fts5GetVarint(&aPg[iStart], &iDelta);\n+        iSOP += fts5GetVarint32(&aPg[iSOP], nPos);\n+      }\n+      assert_nc( iSOP==pSeg->iLeafOffset );\n+      iNextOff = pSeg->iLeafOffset + pSeg->nPos;\n+    }\n+  }\n+\n+  iOff = iStart;\n+\n+  \/* If the position-list for the entry being removed flows over past\n+  ** the end of this page, delete the portion of the position-list on the\n+  ** next page and beyond.\n+  **\n+  ** Set variable bLastInDoclist to true if this entry happens\n+  ** to be the last rowid in the doclist for its term.  *\/\n+  if( iNextOff>=iPgIdx ){\n+    int pgno = pSeg->iLeafPgno+1;\n+    fts5SecureDeleteOverflow(p, pSeg->pSeg, pgno, &bLastInDoclist);\n+    iNextOff = iPgIdx;\n+  }\n+\n+  if( pSeg->bDel==0 ){\n+    if( iNextOff!=iPgIdx ){\n+      \/* Loop through the page-footer. If iNextOff (offset of the\n+      ** entry following the one we are removing) is equal to the\n+      ** offset of a key on this page, then the entry is the last\n+      ** in its doclist. *\/\n+      int iKeyOff = 0;\n+      for(iIdx=0; iIdx<nIdx; \/* no-op *\/){\n+        u32 iVal = 0;\n+        iIdx += fts5GetVarint32(&aIdx[iIdx], iVal);\n+        iKeyOff += iVal;\n+        if( iKeyOff==iNextOff ){\n+          bLastInDoclist = 1;\n+        }\n+      }\n+    }\n+\n+    \/* If this is (a) the first rowid on a page and (b) is not followed by\n+    ** another position list on the same page, set the \"first-rowid\" field\n+    ** of the header to 0.  *\/\n+    if( fts5GetU16(&aPg[0])==iStart && (bLastInDoclist || iNextOff==iPgIdx) ){\n+      fts5PutU16(&aPg[0], 0);\n+    }\n+  }\n+\n+  if( pSeg->bDel ){\n+    iOff += sqlite3Fts5PutVarint(&aPg[iOff], iDelta);\n+    aPg[iOff++] = 0x01;\n+  }else if( bLastInDoclist==0 ){\n+    if( iNextOff!=iPgIdx ){\n+      u64 iNextDelta = 0;\n+      iNextOff += fts5GetVarint(&aPg[iNextOff], &iNextDelta);\n+      iOff += sqlite3Fts5PutVarint(&aPg[iOff], iDelta + iNextDelta);\n+    }\n+  }else if(\n+      pSeg->iLeafPgno==pSeg->iTermLeafPgno\n+   && iStart==pSeg->iTermLeafOffset\n+  ){\n+    \/* The entry being removed was the only position list in its\n+    ** doclist. Therefore the term needs to be removed as well. *\/\n+    int iKey = 0;\n+    int iKeyOff = 0;\n+\n+    \/* Set iKeyOff to the offset of the term that will be removed - the\n+    ** last offset in the footer that is not greater than iStart. *\/\n+    for(iIdx=0; iIdx<nIdx; iKey++){\n+      u32 iVal = 0;\n+      iIdx += fts5GetVarint32(&aIdx[iIdx], iVal);\n+      if( (iKeyOff+iVal)>(u32)iStart ) break;\n+      iKeyOff += iVal;\n+    }\n+    assert_nc( iKey>=1 );\n+\n+    \/* Set iDelKeyOff to the value of the footer entry to remove from\n+    ** the page. *\/\n+    iDelKeyOff = iOff = iKeyOff;\n+\n+    if( iNextOff!=iPgIdx ){\n+      \/* This is the only position-list associated with the term, and there\n+      ** is another term following it on this page. So the subsequent term\n+      ** needs to be moved to replace the term associated with the entry\n+      ** being removed. *\/\n+      int nPrefix = 0;\n+      int nSuffix = 0;\n+      int nPrefix2 = 0;\n+      int nSuffix2 = 0;\n+\n+      iDelKeyOff = iNextOff;\n+      iNextOff += fts5GetVarint32(&aPg[iNextOff], nPrefix2);\n+      iNextOff += fts5GetVarint32(&aPg[iNextOff], nSuffix2);\n+\n+      if( iKey!=1 ){\n+        iKeyOff += fts5GetVarint32(&aPg[iKeyOff], nPrefix);\n+      }\n+      iKeyOff += fts5GetVarint32(&aPg[iKeyOff], nSuffix);\n+\n+      nPrefix = MIN(nPrefix, nPrefix2);\n+      nSuffix = (nPrefix2 + nSuffix2) - nPrefix;\n+\n+      if( (iKeyOff+nSuffix)>iPgIdx || (iNextOff+nSuffix2)>iPgIdx ){\n+        p->rc = FTS5_CORRUPT;\n+      }else{\n+        if( iKey!=1 ){\n+          iOff += sqlite3Fts5PutVarint(&aPg[iOff], nPrefix);\n+        }\n+        iOff += sqlite3Fts5PutVarint(&aPg[iOff], nSuffix);\n+        if( nPrefix2>pSeg->term.n ){\n+          p->rc = FTS5_CORRUPT;\n+        }else if( nPrefix2>nPrefix ){\n+          memcpy(&aPg[iOff], &pSeg->term.p[nPrefix], nPrefix2-nPrefix);\n+          iOff += (nPrefix2-nPrefix);\n+        }\n+        memmove(&aPg[iOff], &aPg[iNextOff], nSuffix2);\n+        iOff += nSuffix2;\n+        iNextOff += nSuffix2;\n+      }\n+    }\n+  }else if( iStart==4 ){\n+    int iPgno;\n+\n+    assert_nc( pSeg->iLeafPgno>pSeg->iTermLeafPgno );\n+    \/* The entry being removed may be the only position list in\n+    ** its doclist. *\/\n+    for(iPgno=pSeg->iLeafPgno-1; iPgno>pSeg->iTermLeafPgno; iPgno-- ){\n+      Fts5Data *pPg = fts5DataRead(p, FTS5_SEGMENT_ROWID(iSegid, iPgno));\n+      int bEmpty = (pPg && pPg->nn==4);\n+      fts5DataRelease(pPg);\n+      if( bEmpty==0 ) break;\n+    }\n+\n+    if( iPgno==pSeg->iTermLeafPgno ){\n+      i64 iId = FTS5_SEGMENT_ROWID(iSegid, pSeg->iTermLeafPgno);\n+      Fts5Data *pTerm = fts5DataRead(p, iId);\n+      if( pTerm && pTerm->szLeaf==pSeg->iTermLeafOffset ){\n+        u8 *aTermIdx = &pTerm->p[pTerm->szLeaf];\n+        int nTermIdx = pTerm->nn - pTerm->szLeaf;\n+        int iTermIdx = 0;\n+        int iTermOff = 0;\n+\n+        while( 1 ){\n+          u32 iVal = 0;\n+          int nByte = fts5GetVarint32(&aTermIdx[iTermIdx], iVal);\n+          iTermOff += iVal;\n+          if( (iTermIdx+nByte)>=nTermIdx ) break;\n+          iTermIdx += nByte;\n+        }\n+        nTermIdx = iTermIdx;\n+\n+        memmove(&pTerm->p[iTermOff], &pTerm->p[pTerm->szLeaf], nTermIdx);\n+        fts5PutU16(&pTerm->p[2], iTermOff);\n+\n+        fts5DataWrite(p, iId, pTerm->p, iTermOff+nTermIdx);\n+        if( nTermIdx==0 ){\n+          fts5SecureDeleteIdxEntry(p, iSegid, pSeg->iTermLeafPgno);\n+        }\n+      }\n+      fts5DataRelease(pTerm);\n+    }\n+  }\n+\n+  \/* Assuming no error has occurred, this block does final edits to the\n+  ** leaf page before writing it back to disk. Input variables are:\n+  **\n+  **   nPg: Total initial size of leaf page.\n+  **   iPgIdx: Initial offset of page footer.\n+  **\n+  **   iOff: Offset to move data to\n+  **   iNextOff: Offset to move data from\n+  *\/\n+  if( p->rc==SQLITE_OK ){\n+    const int nMove = nPg - iNextOff;     \/* Number of bytes to move *\/\n+    int nShift = iNextOff - iOff;         \/* Distance to move them *\/\n+\n+    int iPrevKeyOut = 0;\n+    int iKeyIn = 0;\n+\n+    memmove(&aPg[iOff], &aPg[iNextOff], nMove);\n+    iPgIdx -= nShift;\n+    nPg = iPgIdx;\n+    fts5PutU16(&aPg[2], iPgIdx);\n+\n+    for(iIdx=0; iIdx<nIdx; \/* no-op *\/){\n+      u32 iVal = 0;\n+      iIdx += fts5GetVarint32(&aIdx[iIdx], iVal);\n+      iKeyIn += iVal;\n+      if( iKeyIn!=iDelKeyOff ){\n+        int iKeyOut = (iKeyIn - (iKeyIn>iOff ? nShift : 0));\n+        nPg += sqlite3Fts5PutVarint(&aPg[nPg], iKeyOut - iPrevKeyOut);\n+        iPrevKeyOut = iKeyOut;\n+      }\n+    }\n+\n+    if( iPgIdx==nPg && nIdx>0 && pSeg->iLeafPgno!=1 ){\n+      fts5SecureDeleteIdxEntry(p, iSegid, pSeg->iLeafPgno);\n+    }\n+\n+    assert_nc( nPg>4 || fts5GetU16(aPg)==0 );\n+    fts5DataWrite(p, FTS5_SEGMENT_ROWID(iSegid,pSeg->iLeafPgno), aPg, nPg);\n+  }\n+  sqlite3_free(aIdx);\n+}\n+\n+\/*\n+** This is called as part of flushing a delete to disk in 'secure-delete'\n+** mode. It edits the segments within the database described by argument\n+** pStruct to remove the entries for term zTerm, rowid iRowid.\n+*\/\n+static void fts5FlushSecureDelete(\n+  Fts5Index *p,\n+  Fts5Structure *pStruct,\n+  const char *zTerm,\n+  int nTerm,\n+  i64 iRowid\n+){\n+  const int f = FTS5INDEX_QUERY_SKIPHASH;\n+  Fts5Iter *pIter = 0;            \/* Used to find term instance *\/\n+\n+  fts5MultiIterNew(p, pStruct, f, 0, (const u8*)zTerm, nTerm, -1, 0, &pIter);\n+  if( fts5MultiIterEof(p, pIter)==0 ){\n+    i64 iThis = fts5MultiIterRowid(pIter);\n+    if( iThis<iRowid ){\n+      fts5MultiIterNextFrom(p, pIter, iRowid);\n+    }\n+\n+    if( p->rc==SQLITE_OK\n+     && fts5MultiIterEof(p, pIter)==0\n+     && iRowid==fts5MultiIterRowid(pIter)\n+    ){\n+      Fts5SegIter *pSeg = &pIter->aSeg[pIter->aFirst[1].iFirst];\n+      fts5DoSecureDelete(p, pSeg);\n+    }\n+  }\n+\n+  fts5MultiIterFree(pIter);\n+}\n+\n+\n@@ -231700,1 +244294,0 @@\n-  iSegid = fts5AllocateSegid(p, pStruct);\n@@ -231703,6 +244296,31 @@\n-  if( iSegid ){\n-    const int pgsz = p->pConfig->pgsz;\n-    int eDetail = p->pConfig->eDetail;\n-    Fts5StructureSegment *pSeg;   \/* New segment within pStruct *\/\n-    Fts5Buffer *pBuf;             \/* Buffer in which to assemble leaf page *\/\n-    Fts5Buffer *pPgidx;           \/* Buffer in which to assemble pgidx *\/\n+  if( sqlite3Fts5HashIsEmpty(pHash)==0 ){\n+    iSegid = fts5AllocateSegid(p, pStruct);\n+    if( iSegid ){\n+      const int pgsz = p->pConfig->pgsz;\n+      int eDetail = p->pConfig->eDetail;\n+      int bSecureDelete = p->pConfig->bSecureDelete;\n+      Fts5StructureSegment *pSeg; \/* New segment within pStruct *\/\n+      Fts5Buffer *pBuf;           \/* Buffer in which to assemble leaf page *\/\n+      Fts5Buffer *pPgidx;         \/* Buffer in which to assemble pgidx *\/\n+\n+      Fts5SegWriter writer;\n+      fts5WriteInit(p, &writer, iSegid);\n+\n+      pBuf = &writer.writer.buf;\n+      pPgidx = &writer.writer.pgidx;\n+\n+      \/* fts5WriteInit() should have initialized the buffers to (most likely)\n+      ** the maximum space required. *\/\n+      assert( p->rc || pBuf->nSpace>=(pgsz + FTS5_DATA_PADDING) );\n+      assert( p->rc || pPgidx->nSpace>=(pgsz + FTS5_DATA_PADDING) );\n+\n+      \/* Begin scanning through hash table entries. This loop runs once for each\n+      ** term\/doclist currently stored within the hash table. *\/\n+      if( p->rc==SQLITE_OK ){\n+        p->rc = sqlite3Fts5HashScanInit(pHash, 0, 0);\n+      }\n+      while( p->rc==SQLITE_OK && 0==sqlite3Fts5HashScanEof(pHash) ){\n+        const char *zTerm;        \/* Buffer containing term *\/\n+        int nTerm;                \/* Size of zTerm in bytes *\/\n+        const u8 *pDoclist;       \/* Pointer to doclist for this term *\/\n+        int nDoclist;             \/* Size of doclist in bytes *\/\n@@ -231710,2 +244328,7 @@\n-    Fts5SegWriter writer;\n-    fts5WriteInit(p, &writer, iSegid);\n+        \/* Get the term and doclist for this entry. *\/\n+        sqlite3Fts5HashScanEntry(pHash, &zTerm, &nTerm, &pDoclist, &nDoclist);\n+        if( bSecureDelete==0 ){\n+          fts5WriteAppendTerm(p, &writer, nTerm, (const u8*)zTerm);\n+          if( p->rc!=SQLITE_OK ) break;\n+          assert( writer.bFirstRowidInPage==0 );\n+        }\n@@ -231713,2 +244336,40 @@\n-    pBuf = &writer.writer.buf;\n-    pPgidx = &writer.writer.pgidx;\n+        if( !bSecureDelete && pgsz>=(pBuf->n + pPgidx->n + nDoclist + 1) ){\n+          \/* The entire doclist will fit on the current leaf. *\/\n+          fts5BufferSafeAppendBlob(pBuf, pDoclist, nDoclist);\n+        }else{\n+          int bTermWritten = !bSecureDelete;\n+          i64 iRowid = 0;\n+          i64 iPrev = 0;\n+          int iOff = 0;\n+\n+          \/* The entire doclist will not fit on this leaf. The following\n+          ** loop iterates through the poslists that make up the current\n+          ** doclist.  *\/\n+          while( p->rc==SQLITE_OK && iOff<nDoclist ){\n+            u64 iDelta = 0;\n+            iOff += fts5GetVarint(&pDoclist[iOff], &iDelta);\n+            iRowid += iDelta;\n+\n+            \/* If in secure delete mode, and if this entry in the poslist is\n+            ** in fact a delete, then edit the existing segments directly\n+            ** using fts5FlushSecureDelete().  *\/\n+            if( bSecureDelete ){\n+              if( eDetail==FTS5_DETAIL_NONE ){\n+                if( iOff<nDoclist && pDoclist[iOff]==0x00 ){\n+                  fts5FlushSecureDelete(p, pStruct, zTerm, nTerm, iRowid);\n+                  iOff++;\n+                  if( iOff<nDoclist && pDoclist[iOff]==0x00 ){\n+                    iOff++;\n+                    nDoclist = 0;\n+                  }else{\n+                    continue;\n+                  }\n+                }\n+              }else if( (pDoclist[iOff] & 0x01) ){\n+                fts5FlushSecureDelete(p, pStruct, zTerm, nTerm, iRowid);\n+                if( p->rc!=SQLITE_OK || pDoclist[iOff]==0x01 ){\n+                  iOff++;\n+                  continue;\n+                }\n+              }\n+            }\n@@ -231716,4 +244377,5 @@\n-    \/* fts5WriteInit() should have initialized the buffers to (most likely)\n-    ** the maximum space required. *\/\n-    assert( p->rc || pBuf->nSpace>=(pgsz + FTS5_DATA_PADDING) );\n-    assert( p->rc || pPgidx->nSpace>=(pgsz + FTS5_DATA_PADDING) );\n+            if( p->rc==SQLITE_OK && bTermWritten==0 ){\n+              fts5WriteAppendTerm(p, &writer, nTerm, (const u8*)zTerm);\n+              bTermWritten = 1;\n+              assert( p->rc!=SQLITE_OK || writer.bFirstRowidInPage==0 );\n+            }\n@@ -231721,36 +244383,9 @@\n-    \/* Begin scanning through hash table entries. This loop runs once for each\n-    ** term\/doclist currently stored within the hash table. *\/\n-    if( p->rc==SQLITE_OK ){\n-      p->rc = sqlite3Fts5HashScanInit(pHash, 0, 0);\n-    }\n-    while( p->rc==SQLITE_OK && 0==sqlite3Fts5HashScanEof(pHash) ){\n-      const char *zTerm;          \/* Buffer containing term *\/\n-      const u8 *pDoclist;         \/* Pointer to doclist for this term *\/\n-      int nDoclist;               \/* Size of doclist in bytes *\/\n-\n-      \/* Write the term for this entry to disk. *\/\n-      sqlite3Fts5HashScanEntry(pHash, &zTerm, &pDoclist, &nDoclist);\n-      fts5WriteAppendTerm(p, &writer, (int)strlen(zTerm), (const u8*)zTerm);\n-      if( p->rc!=SQLITE_OK ) break;\n-\n-      assert( writer.bFirstRowidInPage==0 );\n-      if( pgsz>=(pBuf->n + pPgidx->n + nDoclist + 1) ){\n-        \/* The entire doclist will fit on the current leaf. *\/\n-        fts5BufferSafeAppendBlob(pBuf, pDoclist, nDoclist);\n-      }else{\n-        i64 iRowid = 0;\n-        u64 iDelta = 0;\n-        int iOff = 0;\n-\n-        \/* The entire doclist will not fit on this leaf. The following\n-        ** loop iterates through the poslists that make up the current\n-        ** doclist.  *\/\n-        while( p->rc==SQLITE_OK && iOff<nDoclist ){\n-          iOff += fts5GetVarint(&pDoclist[iOff], &iDelta);\n-          iRowid += iDelta;\n-\n-          if( writer.bFirstRowidInPage ){\n-            fts5PutU16(&pBuf->p[0], (u16)pBuf->n);   \/* first rowid on page *\/\n-            pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], iRowid);\n-            writer.bFirstRowidInPage = 0;\n-            fts5WriteDlidxAppend(p, &writer, iRowid);\n+            if( writer.bFirstRowidInPage ){\n+              fts5PutU16(&pBuf->p[0], (u16)pBuf->n);   \/* first rowid on page *\/\n+              pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], iRowid);\n+              writer.bFirstRowidInPage = 0;\n+              fts5WriteDlidxAppend(p, &writer, iRowid);\n+            }else{\n+              u64 iRowidDelta = (u64)iRowid - (u64)iPrev;\n+              pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], iRowidDelta);\n+            }\n@@ -231758,4 +244393,2 @@\n-          }else{\n-            pBuf->n += sqlite3Fts5PutVarint(&pBuf->p[pBuf->n], iDelta);\n-          }\n-          assert( pBuf->n<=pBuf->nSpace );\n+            assert( pBuf->n<=pBuf->nSpace );\n+            iPrev = iRowid;\n@@ -231763,4 +244396,1 @@\n-          if( eDetail==FTS5_DETAIL_NONE ){\n-            if( iOff<nDoclist && pDoclist[iOff]==0 ){\n-              pBuf->p[pBuf->n++] = 0;\n-              iOff++;\n+            if( eDetail==FTS5_DETAIL_NONE ){\n@@ -231770,0 +244400,7 @@\n+                if( iOff<nDoclist && pDoclist[iOff]==0 ){\n+                  pBuf->p[pBuf->n++] = 0;\n+                  iOff++;\n+                }\n+              }\n+              if( (pBuf->n + pPgidx->n)>=pgsz ){\n+                fts5WriteFlushLeaf(p, &writer);\n@@ -231771,13 +244408,0 @@\n-            }\n-            if( (pBuf->n + pPgidx->n)>=pgsz ){\n-              fts5WriteFlushLeaf(p, &writer);\n-            }\n-          }else{\n-            int bDummy;\n-            int nPos;\n-            int nCopy = fts5GetPoslistSize(&pDoclist[iOff], &nPos, &bDummy);\n-            nCopy += nPos;\n-            if( (pBuf->n + pPgidx->n + nCopy) <= pgsz ){\n-              \/* The entire poslist will fit on the current leaf. So copy\n-              ** it in one go. *\/\n-              fts5BufferSafeAppendBlob(pBuf, &pDoclist[iOff], nCopy);\n@@ -231785,18 +244409,35 @@\n-              \/* The entire poslist will not fit on this leaf. So it needs\n-              ** to be broken into sections. The only qualification being\n-              ** that each varint must be stored contiguously.  *\/\n-              const u8 *pPoslist = &pDoclist[iOff];\n-              int iPos = 0;\n-              while( p->rc==SQLITE_OK ){\n-                int nSpace = pgsz - pBuf->n - pPgidx->n;\n-                int n = 0;\n-                if( (nCopy - iPos)<=nSpace ){\n-                  n = nCopy - iPos;\n-                }else{\n-                  n = fts5PoslistPrefix(&pPoslist[iPos], nSpace);\n-                }\n-                assert( n>0 );\n-                fts5BufferSafeAppendBlob(pBuf, &pPoslist[iPos], n);\n-                iPos += n;\n-                if( (pBuf->n + pPgidx->n)>=pgsz ){\n-                  fts5WriteFlushLeaf(p, &writer);\n+              int bDel = 0;\n+              int nPos = 0;\n+              int nCopy = fts5GetPoslistSize(&pDoclist[iOff], &nPos, &bDel);\n+              if( bDel && bSecureDelete ){\n+                fts5BufferAppendVarint(&p->rc, pBuf, nPos*2);\n+                iOff += nCopy;\n+                nCopy = nPos;\n+              }else{\n+                nCopy += nPos;\n+              }\n+              if( (pBuf->n + pPgidx->n + nCopy) <= pgsz ){\n+                \/* The entire poslist will fit on the current leaf. So copy\n+                ** it in one go. *\/\n+                fts5BufferSafeAppendBlob(pBuf, &pDoclist[iOff], nCopy);\n+              }else{\n+                \/* The entire poslist will not fit on this leaf. So it needs\n+                ** to be broken into sections. The only qualification being\n+                ** that each varint must be stored contiguously.  *\/\n+                const u8 *pPoslist = &pDoclist[iOff];\n+                int iPos = 0;\n+                while( p->rc==SQLITE_OK ){\n+                  int nSpace = pgsz - pBuf->n - pPgidx->n;\n+                  int n = 0;\n+                  if( (nCopy - iPos)<=nSpace ){\n+                    n = nCopy - iPos;\n+                  }else{\n+                    n = fts5PoslistPrefix(&pPoslist[iPos], nSpace);\n+                  }\n+                  assert( n>0 );\n+                  fts5BufferSafeAppendBlob(pBuf, &pPoslist[iPos], n);\n+                  iPos += n;\n+                  if( (pBuf->n + pPgidx->n)>=pgsz ){\n+                    fts5WriteFlushLeaf(p, &writer);\n+                  }\n+                  if( iPos>=nCopy ) break;\n@@ -231804,1 +244445,0 @@\n-                if( iPos>=nCopy ) break;\n@@ -231806,0 +244446,1 @@\n+              iOff += nCopy;\n@@ -231807,1 +244448,0 @@\n-            iOff += nCopy;\n@@ -231810,1 +244450,0 @@\n-      }\n@@ -231812,7 +244451,6 @@\n-      \/* TODO2: Doclist terminator written here. *\/\n-      \/* pBuf->p[pBuf->n++] = '\\0'; *\/\n-      assert( pBuf->n<=pBuf->nSpace );\n-      if( p->rc==SQLITE_OK ) sqlite3Fts5HashScanNext(pHash);\n-    }\n-    sqlite3Fts5HashClear(pHash);\n-    fts5WriteFinish(p, &writer, &pgnoLast);\n+        \/* TODO2: Doclist terminator written here. *\/\n+        \/* pBuf->p[pBuf->n++] = '\\0'; *\/\n+        assert( pBuf->n<=pBuf->nSpace );\n+        if( p->rc==SQLITE_OK ) sqlite3Fts5HashScanNext(pHash);\n+      }\n+      fts5WriteFinish(p, &writer, &pgnoLast);\n@@ -231820,12 +244458,23 @@\n-    \/* Update the Fts5Structure. It is written back to the database by the\n-    ** fts5StructureRelease() call below.  *\/\n-    if( pStruct->nLevel==0 ){\n-      fts5StructureAddLevel(&p->rc, &pStruct);\n-    }\n-    fts5StructureExtendLevel(&p->rc, pStruct, 0, 1, 0);\n-    if( p->rc==SQLITE_OK ){\n-      pSeg = &pStruct->aLevel[0].aSeg[ pStruct->aLevel[0].nSeg++ ];\n-      pSeg->iSegid = iSegid;\n-      pSeg->pgnoFirst = 1;\n-      pSeg->pgnoLast = pgnoLast;\n-      pStruct->nSegment++;\n+      assert( p->rc!=SQLITE_OK || bSecureDelete || pgnoLast>0 );\n+      if( pgnoLast>0 ){\n+        \/* Update the Fts5Structure. It is written back to the database by the\n+        ** fts5StructureRelease() call below.  *\/\n+        if( pStruct->nLevel==0 ){\n+          fts5StructureAddLevel(&p->rc, &pStruct);\n+        }\n+        fts5StructureExtendLevel(&p->rc, pStruct, 0, 1, 0);\n+        if( p->rc==SQLITE_OK ){\n+          pSeg = &pStruct->aLevel[0].aSeg[ pStruct->aLevel[0].nSeg++ ];\n+          pSeg->iSegid = iSegid;\n+          pSeg->pgnoFirst = 1;\n+          pSeg->pgnoLast = pgnoLast;\n+          if( pStruct->nOriginCntr>0 ){\n+            pSeg->iOrigin1 = pStruct->nOriginCntr;\n+            pSeg->iOrigin2 = pStruct->nOriginCntr;\n+            pSeg->nEntry = p->nPendingRow;\n+            pStruct->nOriginCntr++;\n+          }\n+          pStruct->nSegment++;\n+        }\n+        fts5StructurePromote(p, 0, pStruct);\n+      }\n@@ -231833,1 +244482,0 @@\n-    fts5StructurePromote(p, 0, pStruct);\n@@ -231836,1 +244484,1 @@\n-  fts5IndexAutomerge(p, &pStruct, pgnoLast);\n+  fts5IndexAutomerge(p, &pStruct, pgnoLast + p->nContentlessDelete);\n@@ -231847,1 +244495,5 @@\n-  if( p->nPendingData ){\n+  if( p->flushRc ){\n+    p->rc = p->flushRc;\n+    return;\n+  }\n+  if( p->nPendingData || p->nContentlessDelete ){\n@@ -231849,1 +244501,0 @@\n-    p->nPendingData = 0;\n@@ -231851,0 +244502,8 @@\n+    if( p->rc==SQLITE_OK ){\n+      sqlite3Fts5HashClear(p->pHash);\n+      p->nPendingData = 0;\n+      p->nPendingRow = 0;\n+      p->nContentlessDelete = 0;\n+    }else if( p->nPendingData || p->nContentlessDelete ){\n+      p->flushRc = p->rc;\n+    }\n@@ -231866,3 +244525,3 @@\n-  **  + it consists of fewer than two segments, or\n-  **  + all segments are on the same level, or\n-  **  + all segments except one are currently inputs to a merge operation.\n+  **  1. it consists of fewer than two segments, or\n+  **  2. all segments are on the same level, or\n+  **  3. all segments except one are currently inputs to a merge operation.\n@@ -231870,2 +244529,3 @@\n-  ** In the first case, return NULL. In the second, increment the ref-count\n-  ** on *pStruct and return a copy of the pointer to it.\n+  ** In the first case, if there are no tombstone hash pages, return NULL. In\n+  ** the second, increment the ref-count on *pStruct and return a copy of the\n+  ** pointer to it.\n@@ -231873,1 +244533,1 @@\n-  if( nSeg<2 ) return 0;\n+  if( nSeg==0 ) return 0;\n@@ -231876,1 +244536,5 @@\n-    if( nThis==nSeg || (nThis==nSeg-1 && pStruct->aLevel[i].nMerge==nThis) ){\n+    int nMerge = pStruct->aLevel[i].nMerge;\n+    if( nThis>0 && (nThis==nSeg || (nThis==nSeg-1 && nMerge==nThis)) ){\n+      if( nSeg==1 && nThis==1 && pStruct->aLevel[i].aSeg[0].nPgTombstone==0 ){\n+        return 0;\n+      }\n@@ -231889,1 +244553,1 @@\n-    pNew->nLevel = pStruct->nLevel+1;\n+    pNew->nLevel = MIN(pStruct->nLevel+1, FTS5_MAX_LEVEL);\n@@ -231892,1 +244556,2 @@\n-    pLvl = &pNew->aLevel[pStruct->nLevel];\n+    pNew->nOriginCntr = pStruct->nOriginCntr;\n+    pLvl = &pNew->aLevel[pNew->nLevel-1];\n@@ -231922,0 +244587,1 @@\n+  assert( p->rc!=SQLITE_OK || p->nContentlessDelete==0 );\n@@ -231923,0 +244589,1 @@\n+  assert( p->rc!=SQLITE_OK || pStruct!=0 );\n@@ -231951,1 +244618,4 @@\n-  Fts5Structure *pStruct = fts5StructureRead(p);\n+  Fts5Structure *pStruct = 0;\n+\n+  fts5IndexFlush(p);\n+  pStruct = fts5StructureRead(p);\n@@ -231959,1 +244629,1 @@\n-      nMin = 2;\n+      nMin = 1;\n@@ -231974,1 +244644,1 @@\n-  i64 iDelta,\n+  u64 iDelta,\n@@ -231984,1 +244654,1 @@\n-  i64 iDelta,\n+  u64 iDelta,\n@@ -232059,4 +244729,4 @@\n-#define fts5MergeAppendDocid(pBuf, iLastRowid, iRowid) {       \\\n-  assert( (pBuf)->n!=0 || (iLastRowid)==0 );                   \\\n-  fts5BufferSafeAppendVarint((pBuf), (iRowid) - (iLastRowid)); \\\n-  (iLastRowid) = (iRowid);                                     \\\n+#define fts5MergeAppendDocid(pBuf, iLastRowid, iRowid) {                 \\\n+  assert( (pBuf)->n!=0 || (iLastRowid)==0 );                             \\\n+  fts5BufferSafeAppendVarint((pBuf), (u64)(iRowid) - (u64)(iLastRowid)); \\\n+  (iLastRowid) = (iRowid);                                               \\\n@@ -232194,1 +244864,1 @@\n-  assert( nBuf+1<=sizeof(aMerger)\/sizeof(aMerger[0]) );\n+  assert( nBuf+1<=(int)(sizeof(aMerger)\/sizeof(aMerger[0])) );\n@@ -232325,1 +244995,1 @@\n-  Fts5Iter **ppIter          \/* OUT: New iterator *\/\n+  Fts5Iter **ppIter               \/* OUT: New iterator *\/\n@@ -232333,1 +245003,1 @@\n-  void (*xAppend)(Fts5Index*, i64, Fts5Iter*, Fts5Buffer*);\n+  void (*xAppend)(Fts5Index*, u64, Fts5Iter*, Fts5Buffer*);\n@@ -232346,0 +245016,1 @@\n+  assert( p->rc!=SQLITE_OK || (aBuf && pStruct) );\n@@ -232347,1 +245018,1 @@\n-  if( aBuf && pStruct ){\n+  if( p->rc==SQLITE_OK ){\n@@ -232359,0 +245030,6 @@\n+\n+    \/* If iIdx is non-zero, then it is the number of a prefix-index for\n+    ** prefixes 1 character longer than the prefix being queried for. That\n+    ** index contains all the doclists required, except for the one\n+    ** corresponding to the prefix itself. That one is extracted from the\n+    ** main term index here.  *\/\n@@ -232372,1 +245049,1 @@\n-          xAppend(p, p1->base.iRowid-iLastRowid, p1, &doclist);\n+          xAppend(p, (u64)p1->base.iRowid-(u64)iLastRowid, p1, &doclist);\n@@ -232382,0 +245059,1 @@\n+\n@@ -232397,1 +245075,0 @@\n-\n@@ -232420,1 +245097,1 @@\n-      xAppend(p, p1->base.iRowid-iLastRowid, p1, &doclist);\n+      xAppend(p, (u64)p1->base.iRowid-(u64)iLastRowid, p1, &doclist);\n@@ -232436,1 +245113,1 @@\n-    pData = fts5IdxMalloc(p, sizeof(Fts5Data)+doclist.n+FTS5_DATA_ZERO_PADDING);\n+    pData = fts5IdxMalloc(p, sizeof(*pData)+doclist.n+FTS5_DATA_ZERO_PADDING);\n@@ -232473,0 +245150,3 @@\n+  if( bDelete==0 ){\n+    p->nPendingRow++;\n+  }\n@@ -232510,0 +245190,3 @@\n+  if( p->pConfig->bContentlessDelete ){\n+    s.nOriginCntr = 1;\n+  }\n@@ -232573,0 +245256,1 @@\n+    sqlite3_finalize(p->pIdxNextSelect);\n@@ -232574,0 +245258,1 @@\n+    sqlite3_finalize(p->pDeleteFromIdx);\n@@ -232667,0 +245352,451 @@\n+\/*\n+** pToken points to a buffer of size nToken bytes containing a search\n+** term, including the index number at the start, used on a tokendata=1\n+** table. This function returns true if the term in buffer pBuf matches\n+** token pToken\/nToken.\n+*\/\n+static int fts5IsTokendataPrefix(\n+  Fts5Buffer *pBuf,\n+  const u8 *pToken,\n+  int nToken\n+){\n+  return (\n+      pBuf->n>=nToken\n+   && 0==memcmp(pBuf->p, pToken, nToken)\n+   && (pBuf->n==nToken || pBuf->p[nToken]==0x00)\n+  );\n+}\n+\n+\/*\n+** Ensure the segment-iterator passed as the only argument points to EOF.\n+*\/\n+static void fts5SegIterSetEOF(Fts5SegIter *pSeg){\n+  fts5DataRelease(pSeg->pLeaf);\n+  pSeg->pLeaf = 0;\n+}\n+\n+\/*\n+** Usually, a tokendata=1 iterator (struct Fts5TokenDataIter) accumulates an\n+** array of these for each row it visits. Or, for an iterator used by an\n+** \"ORDER BY rank\" query, it accumulates an array of these for the entire\n+** query.\n+**\n+** Each instance in the array indicates the iterator (and therefore term)\n+** associated with position iPos of rowid iRowid. This is used by the\n+** xInstToken() API.\n+*\/\n+struct Fts5TokenDataMap {\n+  i64 iRowid;                     \/* Row this token is located in *\/\n+  i64 iPos;                       \/* Position of token *\/\n+  int iIter;                      \/* Iterator token was read from *\/\n+};\n+\n+\/*\n+** An object used to supplement Fts5Iter for tokendata=1 iterators.\n+*\/\n+struct Fts5TokenDataIter {\n+  int nIter;\n+  int nIterAlloc;\n+\n+  int nMap;\n+  int nMapAlloc;\n+  Fts5TokenDataMap *aMap;\n+\n+  Fts5PoslistReader *aPoslistReader;\n+  int *aPoslistToIter;\n+  Fts5Iter *apIter[1];\n+};\n+\n+\/*\n+** This function appends iterator pAppend to Fts5TokenDataIter pIn and\n+** returns the result.\n+*\/\n+static Fts5TokenDataIter *fts5AppendTokendataIter(\n+  Fts5Index *p,                   \/* Index object (for error code) *\/\n+  Fts5TokenDataIter *pIn,         \/* Current Fts5TokenDataIter struct *\/\n+  Fts5Iter *pAppend               \/* Append this iterator *\/\n+){\n+  Fts5TokenDataIter *pRet = pIn;\n+\n+  if( p->rc==SQLITE_OK ){\n+    if( pIn==0 || pIn->nIter==pIn->nIterAlloc ){\n+      int nAlloc = pIn ? pIn->nIterAlloc*2 : 16;\n+      int nByte = nAlloc * sizeof(Fts5Iter*) + sizeof(Fts5TokenDataIter);\n+      Fts5TokenDataIter *pNew = (Fts5TokenDataIter*)sqlite3_realloc(pIn, nByte);\n+\n+      if( pNew==0 ){\n+        p->rc = SQLITE_NOMEM;\n+      }else{\n+        if( pIn==0 ) memset(pNew, 0, nByte);\n+        pRet = pNew;\n+        pNew->nIterAlloc = nAlloc;\n+      }\n+    }\n+  }\n+  if( p->rc ){\n+    sqlite3Fts5IterClose((Fts5IndexIter*)pAppend);\n+  }else{\n+    pRet->apIter[pRet->nIter++] = pAppend;\n+  }\n+  assert( pRet==0 || pRet->nIter<=pRet->nIterAlloc );\n+\n+  return pRet;\n+}\n+\n+\/*\n+** Delete an Fts5TokenDataIter structure and its contents.\n+*\/\n+static void fts5TokendataIterDelete(Fts5TokenDataIter *pSet){\n+  if( pSet ){\n+    int ii;\n+    for(ii=0; ii<pSet->nIter; ii++){\n+      fts5MultiIterFree(pSet->apIter[ii]);\n+    }\n+    sqlite3_free(pSet->aPoslistReader);\n+    sqlite3_free(pSet->aMap);\n+    sqlite3_free(pSet);\n+  }\n+}\n+\n+\/*\n+** Append a mapping to the token-map belonging to object pT.\n+*\/\n+static void fts5TokendataIterAppendMap(\n+  Fts5Index *p,\n+  Fts5TokenDataIter *pT,\n+  int iIter,\n+  i64 iRowid,\n+  i64 iPos\n+){\n+  if( p->rc==SQLITE_OK ){\n+    if( pT->nMap==pT->nMapAlloc ){\n+      int nNew = pT->nMapAlloc ? pT->nMapAlloc*2 : 64;\n+      int nByte = nNew * sizeof(Fts5TokenDataMap);\n+      Fts5TokenDataMap *aNew;\n+\n+      aNew = (Fts5TokenDataMap*)sqlite3_realloc(pT->aMap, nByte);\n+      if( aNew==0 ){\n+        p->rc = SQLITE_NOMEM;\n+        return;\n+      }\n+\n+      pT->aMap = aNew;\n+      pT->nMapAlloc = nNew;\n+    }\n+\n+    pT->aMap[pT->nMap].iRowid = iRowid;\n+    pT->aMap[pT->nMap].iPos = iPos;\n+    pT->aMap[pT->nMap].iIter = iIter;\n+    pT->nMap++;\n+  }\n+}\n+\n+\/*\n+** The iterator passed as the only argument must be a tokendata=1 iterator\n+** (pIter->pTokenDataIter!=0). This function sets the iterator output\n+** variables (pIter->base.*) according to the contents of the current\n+** row.\n+*\/\n+static void fts5IterSetOutputsTokendata(Fts5Iter *pIter){\n+  int ii;\n+  int nHit = 0;\n+  i64 iRowid = SMALLEST_INT64;\n+  int iMin = 0;\n+\n+  Fts5TokenDataIter *pT = pIter->pTokenDataIter;\n+\n+  pIter->base.nData = 0;\n+  pIter->base.pData = 0;\n+\n+  for(ii=0; ii<pT->nIter; ii++){\n+    Fts5Iter *p = pT->apIter[ii];\n+    if( p->base.bEof==0 ){\n+      if( nHit==0 || p->base.iRowid<iRowid ){\n+        iRowid = p->base.iRowid;\n+        nHit = 1;\n+        pIter->base.pData = p->base.pData;\n+        pIter->base.nData = p->base.nData;\n+        iMin = ii;\n+      }else if( p->base.iRowid==iRowid ){\n+        nHit++;\n+      }\n+    }\n+  }\n+\n+  if( nHit==0 ){\n+    pIter->base.bEof = 1;\n+  }else{\n+    int eDetail = pIter->pIndex->pConfig->eDetail;\n+    pIter->base.bEof = 0;\n+    pIter->base.iRowid = iRowid;\n+\n+    if( nHit==1 && eDetail==FTS5_DETAIL_FULL ){\n+      fts5TokendataIterAppendMap(pIter->pIndex, pT, iMin, iRowid, -1);\n+    }else\n+    if( nHit>1 && eDetail!=FTS5_DETAIL_NONE ){\n+      int nReader = 0;\n+      int nByte = 0;\n+      i64 iPrev = 0;\n+\n+      \/* Allocate array of iterators if they are not already allocated. *\/\n+      if( pT->aPoslistReader==0 ){\n+        pT->aPoslistReader = (Fts5PoslistReader*)sqlite3Fts5MallocZero(\n+            &pIter->pIndex->rc,\n+            pT->nIter * (sizeof(Fts5PoslistReader) + sizeof(int))\n+        );\n+        if( pT->aPoslistReader==0 ) return;\n+        pT->aPoslistToIter = (int*)&pT->aPoslistReader[pT->nIter];\n+      }\n+\n+      \/* Populate an iterator for each poslist that will be merged *\/\n+      for(ii=0; ii<pT->nIter; ii++){\n+        Fts5Iter *p = pT->apIter[ii];\n+        if( iRowid==p->base.iRowid ){\n+          pT->aPoslistToIter[nReader] = ii;\n+          sqlite3Fts5PoslistReaderInit(\n+              p->base.pData, p->base.nData, &pT->aPoslistReader[nReader++]\n+          );\n+          nByte += p->base.nData;\n+        }\n+      }\n+\n+      \/* Ensure the output buffer is large enough *\/\n+      if( fts5BufferGrow(&pIter->pIndex->rc, &pIter->poslist, nByte+nHit*10) ){\n+        return;\n+      }\n+\n+      \/* Ensure the token-mapping is large enough *\/\n+      if( eDetail==FTS5_DETAIL_FULL && pT->nMapAlloc<(pT->nMap + nByte) ){\n+        int nNew = (pT->nMapAlloc + nByte) * 2;\n+        Fts5TokenDataMap *aNew = (Fts5TokenDataMap*)sqlite3_realloc(\n+            pT->aMap, nNew*sizeof(Fts5TokenDataMap)\n+        );\n+        if( aNew==0 ){\n+          pIter->pIndex->rc = SQLITE_NOMEM;\n+          return;\n+        }\n+        pT->aMap = aNew;\n+        pT->nMapAlloc = nNew;\n+      }\n+\n+      pIter->poslist.n = 0;\n+\n+      while( 1 ){\n+        i64 iMinPos = LARGEST_INT64;\n+\n+        \/* Find smallest position *\/\n+        iMin = 0;\n+        for(ii=0; ii<nReader; ii++){\n+          Fts5PoslistReader *pReader = &pT->aPoslistReader[ii];\n+          if( pReader->bEof==0 ){\n+            if( pReader->iPos<iMinPos ){\n+              iMinPos = pReader->iPos;\n+              iMin = ii;\n+            }\n+          }\n+        }\n+\n+        \/* If all readers were at EOF, break out of the loop. *\/\n+        if( iMinPos==LARGEST_INT64 ) break;\n+\n+        sqlite3Fts5PoslistSafeAppend(&pIter->poslist, &iPrev, iMinPos);\n+        sqlite3Fts5PoslistReaderNext(&pT->aPoslistReader[iMin]);\n+\n+        if( eDetail==FTS5_DETAIL_FULL ){\n+          pT->aMap[pT->nMap].iPos = iMinPos;\n+          pT->aMap[pT->nMap].iIter = pT->aPoslistToIter[iMin];\n+          pT->aMap[pT->nMap].iRowid = iRowid;\n+          pT->nMap++;\n+        }\n+      }\n+\n+      pIter->base.pData = pIter->poslist.p;\n+      pIter->base.nData = pIter->poslist.n;\n+    }\n+  }\n+}\n+\n+\/*\n+** The iterator passed as the only argument must be a tokendata=1 iterator\n+** (pIter->pTokenDataIter!=0). This function advances the iterator. If\n+** argument bFrom is false, then the iterator is advanced to the next\n+** entry. Or, if bFrom is true, it is advanced to the first entry with\n+** a rowid of iFrom or greater.\n+*\/\n+static void fts5TokendataIterNext(Fts5Iter *pIter, int bFrom, i64 iFrom){\n+  int ii;\n+  Fts5TokenDataIter *pT = pIter->pTokenDataIter;\n+  Fts5Index *pIndex = pIter->pIndex;\n+\n+  for(ii=0; ii<pT->nIter; ii++){\n+    Fts5Iter *p = pT->apIter[ii];\n+    if( p->base.bEof==0\n+     && (p->base.iRowid==pIter->base.iRowid || (bFrom && p->base.iRowid<iFrom))\n+    ){\n+      fts5MultiIterNext(pIndex, p, bFrom, iFrom);\n+      while( bFrom && p->base.bEof==0\n+          && p->base.iRowid<iFrom\n+          && pIndex->rc==SQLITE_OK\n+      ){\n+        fts5MultiIterNext(pIndex, p, 0, 0);\n+      }\n+    }\n+  }\n+\n+  if( pIndex->rc==SQLITE_OK ){\n+    fts5IterSetOutputsTokendata(pIter);\n+  }\n+}\n+\n+\/*\n+** If the segment-iterator passed as the first argument is at EOF, then\n+** set pIter->term to a copy of buffer pTerm.\n+*\/\n+static void fts5TokendataSetTermIfEof(Fts5Iter *pIter, Fts5Buffer *pTerm){\n+  if( pIter && pIter->aSeg[0].pLeaf==0 ){\n+    fts5BufferSet(&pIter->pIndex->rc, &pIter->aSeg[0].term, pTerm->n, pTerm->p);\n+  }\n+}\n+\n+\/*\n+** This function sets up an iterator to use for a non-prefix query on a\n+** tokendata=1 table.\n+*\/\n+static Fts5Iter *fts5SetupTokendataIter(\n+  Fts5Index *p,                   \/* FTS index to query *\/\n+  const u8 *pToken,               \/* Buffer containing query term *\/\n+  int nToken,                     \/* Size of buffer pToken in bytes *\/\n+  Fts5Colset *pColset             \/* Colset to filter on *\/\n+){\n+  Fts5Iter *pRet = 0;\n+  Fts5TokenDataIter *pSet = 0;\n+  Fts5Structure *pStruct = 0;\n+  const int flags = FTS5INDEX_QUERY_SCANONETERM | FTS5INDEX_QUERY_SCAN;\n+\n+  Fts5Buffer bSeek = {0, 0, 0};\n+  Fts5Buffer *pSmall = 0;\n+\n+  fts5IndexFlush(p);\n+  pStruct = fts5StructureRead(p);\n+\n+  while( p->rc==SQLITE_OK ){\n+    Fts5Iter *pPrev = pSet ? pSet->apIter[pSet->nIter-1] : 0;\n+    Fts5Iter *pNew = 0;\n+    Fts5SegIter *pNewIter = 0;\n+    Fts5SegIter *pPrevIter = 0;\n+\n+    int iLvl, iSeg, ii;\n+\n+    pNew = fts5MultiIterAlloc(p, pStruct->nSegment);\n+    if( pSmall ){\n+      fts5BufferSet(&p->rc, &bSeek, pSmall->n, pSmall->p);\n+      fts5BufferAppendBlob(&p->rc, &bSeek, 1, (const u8*)\"\\0\");\n+    }else{\n+      fts5BufferSet(&p->rc, &bSeek, nToken, pToken);\n+    }\n+    if( p->rc ){\n+      sqlite3Fts5IterClose((Fts5IndexIter*)pNew);\n+      break;\n+    }\n+\n+    pNewIter = &pNew->aSeg[0];\n+    pPrevIter = (pPrev ? &pPrev->aSeg[0] : 0);\n+    for(iLvl=0; iLvl<pStruct->nLevel; iLvl++){\n+      for(iSeg=pStruct->aLevel[iLvl].nSeg-1; iSeg>=0; iSeg--){\n+        Fts5StructureSegment *pSeg = &pStruct->aLevel[iLvl].aSeg[iSeg];\n+        int bDone = 0;\n+\n+        if( pPrevIter ){\n+          if( fts5BufferCompare(pSmall, &pPrevIter->term) ){\n+            memcpy(pNewIter, pPrevIter, sizeof(Fts5SegIter));\n+            memset(pPrevIter, 0, sizeof(Fts5SegIter));\n+            bDone = 1;\n+          }else if( pPrevIter->iEndofDoclist>pPrevIter->pLeaf->szLeaf ){\n+            fts5SegIterNextInit(p,(const char*)bSeek.p,bSeek.n-1,pSeg,pNewIter);\n+            bDone = 1;\n+          }\n+        }\n+\n+        if( bDone==0 ){\n+          fts5SegIterSeekInit(p, bSeek.p, bSeek.n, flags, pSeg, pNewIter);\n+        }\n+\n+        if( pPrevIter ){\n+          if( pPrevIter->pTombArray ){\n+            pNewIter->pTombArray = pPrevIter->pTombArray;\n+            pNewIter->pTombArray->nRef++;\n+          }\n+        }else{\n+          fts5SegIterAllocTombstone(p, pNewIter);\n+        }\n+\n+        pNewIter++;\n+        if( pPrevIter ) pPrevIter++;\n+        if( p->rc ) break;\n+      }\n+    }\n+    fts5TokendataSetTermIfEof(pPrev, pSmall);\n+\n+    pNew->bSkipEmpty = 1;\n+    pNew->pColset = pColset;\n+    fts5IterSetOutputCb(&p->rc, pNew);\n+\n+    \/* Loop through all segments in the new iterator. Find the smallest\n+    ** term that any segment-iterator points to. Iterator pNew will be\n+    ** used for this term. Also, set any iterator that points to a term that\n+    ** does not match pToken\/nToken to point to EOF *\/\n+    pSmall = 0;\n+    for(ii=0; ii<pNew->nSeg; ii++){\n+      Fts5SegIter *pII = &pNew->aSeg[ii];\n+      if( 0==fts5IsTokendataPrefix(&pII->term, pToken, nToken) ){\n+        fts5SegIterSetEOF(pII);\n+      }\n+      if( pII->pLeaf && (!pSmall || fts5BufferCompare(pSmall, &pII->term)>0) ){\n+        pSmall = &pII->term;\n+      }\n+    }\n+\n+    \/* If pSmall is still NULL at this point, then the new iterator does\n+    ** not point to any terms that match the query. So delete it and break\n+    ** out of the loop - all required iterators have been collected.  *\/\n+    if( pSmall==0 ){\n+      sqlite3Fts5IterClose((Fts5IndexIter*)pNew);\n+      break;\n+    }\n+\n+    \/* Append this iterator to the set and continue. *\/\n+    pSet = fts5AppendTokendataIter(p, pSet, pNew);\n+  }\n+\n+  if( p->rc==SQLITE_OK && pSet ){\n+    int ii;\n+    for(ii=0; ii<pSet->nIter; ii++){\n+      Fts5Iter *pIter = pSet->apIter[ii];\n+      int iSeg;\n+      for(iSeg=0; iSeg<pIter->nSeg; iSeg++){\n+        pIter->aSeg[iSeg].flags |= FTS5_SEGITER_ONETERM;\n+      }\n+      fts5MultiIterFinishSetup(p, pIter);\n+    }\n+  }\n+\n+  if( p->rc==SQLITE_OK ){\n+    pRet = fts5MultiIterAlloc(p, 0);\n+  }\n+  if( pRet ){\n+    pRet->pTokenDataIter = pSet;\n+    if( pSet ){\n+      fts5IterSetOutputsTokendata(pRet);\n+    }else{\n+      pRet->base.bEof = 1;\n+    }\n+  }else{\n+    fts5TokendataIterDelete(pSet);\n+  }\n+\n+  fts5StructureRelease(pStruct);\n+  fts5BufferFree(&bSeek);\n+  return pRet;\n+}\n+\n+\n@@ -232688,0 +245824,1 @@\n+    int bTokendata = pConfig->bTokendata;\n@@ -232690,0 +245827,4 @@\n+    if( flags & (FTS5INDEX_QUERY_NOTOKENDATA|FTS5INDEX_QUERY_SCAN) ){\n+      bTokendata = 0;\n+    }\n+\n@@ -232715,1 +245856,4 @@\n-    if( iIdx<=pConfig->nPrefix ){\n+    if( bTokendata && iIdx==0 ){\n+      buf.p[0] = '0';\n+      pRet = fts5SetupTokendataIter(p, buf.p, nToken+1, pColset);\n+    }else if( iIdx<=pConfig->nPrefix ){\n@@ -232762,1 +245906,5 @@\n-  fts5MultiIterNext(pIter->pIndex, pIter, 0, 0);\n+  if( pIter->pTokenDataIter ){\n+    fts5TokendataIterNext(pIter, 0, 0);\n+  }else{\n+    fts5MultiIterNext(pIter->pIndex, pIter, 0, 0);\n+  }\n@@ -232795,1 +245943,5 @@\n-  fts5MultiIterNextFrom(pIter->pIndex, pIter, iMatch);\n+  if( pIter->pTokenDataIter ){\n+    fts5TokendataIterNext(pIter, 1, iMatch);\n+  }else{\n+    fts5MultiIterNextFrom(pIter->pIndex, pIter, iMatch);\n+  }\n@@ -232810,0 +245962,93 @@\n+\/*\n+** This is used by xInstToken() to access the token at offset iOff, column\n+** iCol of row iRowid. The token is returned via output variables *ppOut\n+** and *pnOut. The iterator passed as the first argument must be a tokendata=1\n+** iterator (pIter->pTokenDataIter!=0).\n+*\/\n+static int sqlite3Fts5IterToken(\n+  Fts5IndexIter *pIndexIter,\n+  i64 iRowid,\n+  int iCol,\n+  int iOff,\n+  const char **ppOut, int *pnOut\n+){\n+  Fts5Iter *pIter = (Fts5Iter*)pIndexIter;\n+  Fts5TokenDataIter *pT = pIter->pTokenDataIter;\n+  Fts5TokenDataMap *aMap = pT->aMap;\n+  i64 iPos = (((i64)iCol)<<32) + iOff;\n+\n+  int i1 = 0;\n+  int i2 = pT->nMap;\n+  int iTest = 0;\n+\n+  while( i2>i1 ){\n+    iTest = (i1 + i2) \/ 2;\n+\n+    if( aMap[iTest].iRowid<iRowid ){\n+      i1 = iTest+1;\n+    }else if( aMap[iTest].iRowid>iRowid ){\n+      i2 = iTest;\n+    }else{\n+      if( aMap[iTest].iPos<iPos ){\n+        if( aMap[iTest].iPos<0 ){\n+          break;\n+        }\n+        i1 = iTest+1;\n+      }else if( aMap[iTest].iPos>iPos ){\n+        i2 = iTest;\n+      }else{\n+        break;\n+      }\n+    }\n+  }\n+\n+  if( i2>i1 ){\n+    Fts5Iter *pMap = pT->apIter[aMap[iTest].iIter];\n+    *ppOut = (const char*)pMap->aSeg[0].term.p+1;\n+    *pnOut = pMap->aSeg[0].term.n-1;\n+  }\n+\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Clear any existing entries from the token-map associated with the\n+** iterator passed as the only argument.\n+*\/\n+static void sqlite3Fts5IndexIterClearTokendata(Fts5IndexIter *pIndexIter){\n+  Fts5Iter *pIter = (Fts5Iter*)pIndexIter;\n+  if( pIter && pIter->pTokenDataIter ){\n+    pIter->pTokenDataIter->nMap = 0;\n+  }\n+}\n+\n+\/*\n+** Set a token-mapping for the iterator passed as the first argument. This\n+** is used in detail=column or detail=none mode when a token is requested\n+** using the xInstToken() API. In this case the caller tokenizers the\n+** current row and configures the token-mapping via multiple calls to this\n+** function.\n+*\/\n+static int sqlite3Fts5IndexIterWriteTokendata(\n+  Fts5IndexIter *pIndexIter,\n+  const char *pToken, int nToken,\n+  i64 iRowid, int iCol, int iOff\n+){\n+  Fts5Iter *pIter = (Fts5Iter*)pIndexIter;\n+  Fts5TokenDataIter *pT = pIter->pTokenDataIter;\n+  Fts5Index *p = pIter->pIndex;\n+  int ii;\n+\n+  assert( p->pConfig->eDetail!=FTS5_DETAIL_FULL );\n+  assert( pIter->pTokenDataIter );\n+\n+  for(ii=0; ii<pT->nIter; ii++){\n+    Fts5Buffer *pTerm = &pT->apIter[ii]->aSeg[0].term;\n+    if( nToken==pTerm->n-1 && memcmp(pToken, pTerm->p+1, nToken)==0 ) break;\n+  }\n+  if( ii<pT->nIter ){\n+    fts5TokendataIterAppendMap(p, pT, ii, iRowid, (((i64)iCol)<<32) + iOff);\n+  }\n+  return fts5IndexReturn(p);\n+}\n+\n@@ -232817,0 +246062,1 @@\n+    fts5TokendataIterDelete(pIter->pTokenDataIter);\n@@ -232900,0 +246146,341 @@\n+\/*\n+** Retrieve the origin value that will be used for the segment currently\n+** being accumulated in the in-memory hash table when it is flushed to\n+** disk. If successful, SQLITE_OK is returned and (*piOrigin) set to\n+** the queried value. Or, if an error occurs, an error code is returned\n+** and the final value of (*piOrigin) is undefined.\n+*\/\n+static int sqlite3Fts5IndexGetOrigin(Fts5Index *p, i64 *piOrigin){\n+  Fts5Structure *pStruct;\n+  pStruct = fts5StructureRead(p);\n+  if( pStruct ){\n+    *piOrigin = pStruct->nOriginCntr;\n+    fts5StructureRelease(pStruct);\n+  }\n+  return fts5IndexReturn(p);\n+}\n+\n+\/*\n+** Buffer pPg contains a page of a tombstone hash table - one of nPg pages\n+** associated with the same segment. This function adds rowid iRowid to\n+** the hash table. The caller is required to guarantee that there is at\n+** least one free slot on the page.\n+**\n+** If parameter bForce is false and the hash table is deemed to be full\n+** (more than half of the slots are occupied), then non-zero is returned\n+** and iRowid not inserted. Or, if bForce is true or if the hash table page\n+** is not full, iRowid is inserted and zero returned.\n+*\/\n+static int fts5IndexTombstoneAddToPage(\n+  Fts5Data *pPg,\n+  int bForce,\n+  int nPg,\n+  u64 iRowid\n+){\n+  const int szKey = TOMBSTONE_KEYSIZE(pPg);\n+  const int nSlot = TOMBSTONE_NSLOT(pPg);\n+  const int nElem = fts5GetU32(&pPg->p[4]);\n+  int iSlot = (iRowid \/ nPg) % nSlot;\n+  int nCollide = nSlot;\n+\n+  if( szKey==4 && iRowid>0xFFFFFFFF ) return 2;\n+  if( iRowid==0 ){\n+    pPg->p[1] = 0x01;\n+    return 0;\n+  }\n+\n+  if( bForce==0 && nElem>=(nSlot\/2) ){\n+    return 1;\n+  }\n+\n+  fts5PutU32(&pPg->p[4], nElem+1);\n+  if( szKey==4 ){\n+    u32 *aSlot = (u32*)&pPg->p[8];\n+    while( aSlot[iSlot] ){\n+      iSlot = (iSlot + 1) % nSlot;\n+      if( nCollide--==0 ) return 0;\n+    }\n+    fts5PutU32((u8*)&aSlot[iSlot], (u32)iRowid);\n+  }else{\n+    u64 *aSlot = (u64*)&pPg->p[8];\n+    while( aSlot[iSlot] ){\n+      iSlot = (iSlot + 1) % nSlot;\n+      if( nCollide--==0 ) return 0;\n+    }\n+    fts5PutU64((u8*)&aSlot[iSlot], iRowid);\n+  }\n+\n+  return 0;\n+}\n+\n+\/*\n+** This function attempts to build a new hash containing all the keys\n+** currently in the tombstone hash table for segment pSeg. The new\n+** hash will be stored in the nOut buffers passed in array apOut[].\n+** All pages of the new hash use key-size szKey (4 or 8).\n+**\n+** Return 0 if the hash is successfully rebuilt into the nOut pages.\n+** Or non-zero if it is not (because one page became overfull). In this\n+** case the caller should retry with a larger nOut parameter.\n+**\n+** Parameter pData1 is page iPg1 of the hash table being rebuilt.\n+*\/\n+static int fts5IndexTombstoneRehash(\n+  Fts5Index *p,\n+  Fts5StructureSegment *pSeg,     \/* Segment to rebuild hash of *\/\n+  Fts5Data *pData1,               \/* One page of current hash - or NULL *\/\n+  int iPg1,                       \/* Which page of the current hash is pData1 *\/\n+  int szKey,                      \/* 4 or 8, the keysize *\/\n+  int nOut,                       \/* Number of output pages *\/\n+  Fts5Data **apOut                \/* Array of output hash pages *\/\n+){\n+  int ii;\n+  int res = 0;\n+\n+  \/* Initialize the headers of all the output pages *\/\n+  for(ii=0; ii<nOut; ii++){\n+    apOut[ii]->p[0] = szKey;\n+    fts5PutU32(&apOut[ii]->p[4], 0);\n+  }\n+\n+  \/* Loop through the current pages of the hash table. *\/\n+  for(ii=0; res==0 && ii<pSeg->nPgTombstone; ii++){\n+    Fts5Data *pData = 0;          \/* Page ii of the current hash table *\/\n+    Fts5Data *pFree = 0;          \/* Free this at the end of the loop *\/\n+\n+    if( iPg1==ii ){\n+      pData = pData1;\n+    }else{\n+      pFree = pData = fts5DataRead(p, FTS5_TOMBSTONE_ROWID(pSeg->iSegid, ii));\n+    }\n+\n+    if( pData ){\n+      int szKeyIn = TOMBSTONE_KEYSIZE(pData);\n+      int nSlotIn = (pData->nn - 8) \/ szKeyIn;\n+      int iIn;\n+      for(iIn=0; iIn<nSlotIn; iIn++){\n+        u64 iVal = 0;\n+\n+        \/* Read the value from slot iIn of the input page into iVal. *\/\n+        if( szKeyIn==4 ){\n+          u32 *aSlot = (u32*)&pData->p[8];\n+          if( aSlot[iIn] ) iVal = fts5GetU32((u8*)&aSlot[iIn]);\n+        }else{\n+          u64 *aSlot = (u64*)&pData->p[8];\n+          if( aSlot[iIn] ) iVal = fts5GetU64((u8*)&aSlot[iIn]);\n+        }\n+\n+        \/* If iVal is not 0 at this point, insert it into the new hash table *\/\n+        if( iVal ){\n+          Fts5Data *pPg = apOut[(iVal % nOut)];\n+          res = fts5IndexTombstoneAddToPage(pPg, 0, nOut, iVal);\n+          if( res ) break;\n+        }\n+      }\n+\n+      \/* If this is page 0 of the old hash, copy the rowid-0-flag from the\n+      ** old hash to the new.  *\/\n+      if( ii==0 ){\n+        apOut[0]->p[1] = pData->p[1];\n+      }\n+    }\n+    fts5DataRelease(pFree);\n+  }\n+\n+  return res;\n+}\n+\n+\/*\n+** This is called to rebuild the hash table belonging to segment pSeg.\n+** If parameter pData1 is not NULL, then one page of the existing hash table\n+** has already been loaded - pData1, which is page iPg1. The key-size for\n+** the new hash table is szKey (4 or 8).\n+**\n+** If successful, the new hash table is not written to disk. Instead,\n+** output parameter (*pnOut) is set to the number of pages in the new\n+** hash table, and (*papOut) to point to an array of buffers containing\n+** the new page data.\n+**\n+** If an error occurs, an error code is left in the Fts5Index object and\n+** both output parameters set to 0 before returning.\n+*\/\n+static void fts5IndexTombstoneRebuild(\n+  Fts5Index *p,\n+  Fts5StructureSegment *pSeg,     \/* Segment to rebuild hash of *\/\n+  Fts5Data *pData1,               \/* One page of current hash - or NULL *\/\n+  int iPg1,                       \/* Which page of the current hash is pData1 *\/\n+  int szKey,                      \/* 4 or 8, the keysize *\/\n+  int *pnOut,                     \/* OUT: Number of output pages *\/\n+  Fts5Data ***papOut              \/* OUT: Output hash pages *\/\n+){\n+  const int MINSLOT = 32;\n+  int nSlotPerPage = MAX(MINSLOT, (p->pConfig->pgsz - 8) \/ szKey);\n+  int nSlot = 0;                  \/* Number of slots in each output page *\/\n+  int nOut = 0;\n+\n+  \/* Figure out how many output pages (nOut) and how many slots per\n+  ** page (nSlot).  There are three possibilities:\n+  **\n+  **   1. The hash table does not yet exist. In this case the new hash\n+  **      table will consist of a single page with MINSLOT slots.\n+  **\n+  **   2. The hash table exists but is currently a single page. In this\n+  **      case an attempt is made to grow the page to accommodate the new\n+  **      entry. The page is allowed to grow up to nSlotPerPage (see above)\n+  **      slots.\n+  **\n+  **   3. The hash table already consists of more than one page, or of\n+  **      a single page already so large that it cannot be grown. In this\n+  **      case the new hash consists of (nPg*2+1) pages of nSlotPerPage\n+  **      slots each, where nPg is the current number of pages in the\n+  **      hash table.\n+  *\/\n+  if( pSeg->nPgTombstone==0 ){\n+    \/* Case 1. *\/\n+    nOut = 1;\n+    nSlot = MINSLOT;\n+  }else if( pSeg->nPgTombstone==1 ){\n+    \/* Case 2. *\/\n+    int nElem = (int)fts5GetU32(&pData1->p[4]);\n+    assert( pData1 && iPg1==0 );\n+    nOut = 1;\n+    nSlot = MAX(nElem*4, MINSLOT);\n+    if( nSlot>nSlotPerPage ) nOut = 0;\n+  }\n+  if( nOut==0 ){\n+    \/* Case 3. *\/\n+    nOut = (pSeg->nPgTombstone * 2 + 1);\n+    nSlot = nSlotPerPage;\n+  }\n+\n+  \/* Allocate the required array and output pages *\/\n+  while( 1 ){\n+    int res = 0;\n+    int ii = 0;\n+    int szPage = 0;\n+    Fts5Data **apOut = 0;\n+\n+    \/* Allocate space for the new hash table *\/\n+    assert( nSlot>=MINSLOT );\n+    apOut = (Fts5Data**)sqlite3Fts5MallocZero(&p->rc, sizeof(Fts5Data*) * nOut);\n+    szPage = 8 + nSlot*szKey;\n+    for(ii=0; ii<nOut; ii++){\n+      Fts5Data *pNew = (Fts5Data*)sqlite3Fts5MallocZero(&p->rc,\n+          sizeof(Fts5Data)+szPage\n+      );\n+      if( pNew ){\n+        pNew->nn = szPage;\n+        pNew->p = (u8*)&pNew[1];\n+        apOut[ii] = pNew;\n+      }\n+    }\n+\n+    \/* Rebuild the hash table. *\/\n+    if( p->rc==SQLITE_OK ){\n+      res = fts5IndexTombstoneRehash(p, pSeg, pData1, iPg1, szKey, nOut, apOut);\n+    }\n+    if( res==0 ){\n+      if( p->rc ){\n+        fts5IndexFreeArray(apOut, nOut);\n+        apOut = 0;\n+        nOut = 0;\n+      }\n+      *pnOut = nOut;\n+      *papOut = apOut;\n+      break;\n+    }\n+\n+    \/* If control flows to here, it was not possible to rebuild the hash\n+    ** table. Free all buffers and then try again with more pages. *\/\n+    assert( p->rc==SQLITE_OK );\n+    fts5IndexFreeArray(apOut, nOut);\n+    nSlot = nSlotPerPage;\n+    nOut = nOut*2 + 1;\n+  }\n+}\n+\n+\n+\/*\n+** Add a tombstone for rowid iRowid to segment pSeg.\n+*\/\n+static void fts5IndexTombstoneAdd(\n+  Fts5Index *p,\n+  Fts5StructureSegment *pSeg,\n+  u64 iRowid\n+){\n+  Fts5Data *pPg = 0;\n+  int iPg = -1;\n+  int szKey = 0;\n+  int nHash = 0;\n+  Fts5Data **apHash = 0;\n+\n+  p->nContentlessDelete++;\n+\n+  if( pSeg->nPgTombstone>0 ){\n+    iPg = iRowid % pSeg->nPgTombstone;\n+    pPg = fts5DataRead(p, FTS5_TOMBSTONE_ROWID(pSeg->iSegid,iPg));\n+    if( pPg==0 ){\n+      assert( p->rc!=SQLITE_OK );\n+      return;\n+    }\n+\n+    if( 0==fts5IndexTombstoneAddToPage(pPg, 0, pSeg->nPgTombstone, iRowid) ){\n+      fts5DataWrite(p, FTS5_TOMBSTONE_ROWID(pSeg->iSegid,iPg), pPg->p, pPg->nn);\n+      fts5DataRelease(pPg);\n+      return;\n+    }\n+  }\n+\n+  \/* Have to rebuild the hash table. First figure out the key-size (4 or 8). *\/\n+  szKey = pPg ? TOMBSTONE_KEYSIZE(pPg) : 4;\n+  if( iRowid>0xFFFFFFFF ) szKey = 8;\n+\n+  \/* Rebuild the hash table *\/\n+  fts5IndexTombstoneRebuild(p, pSeg, pPg, iPg, szKey, &nHash, &apHash);\n+  assert( p->rc==SQLITE_OK || (nHash==0 && apHash==0) );\n+\n+  \/* If all has succeeded, write the new rowid into one of the new hash\n+  ** table pages, then write them all out to disk. *\/\n+  if( nHash ){\n+    int ii = 0;\n+    fts5IndexTombstoneAddToPage(apHash[iRowid % nHash], 1, nHash, iRowid);\n+    for(ii=0; ii<nHash; ii++){\n+      i64 iTombstoneRowid = FTS5_TOMBSTONE_ROWID(pSeg->iSegid, ii);\n+      fts5DataWrite(p, iTombstoneRowid, apHash[ii]->p, apHash[ii]->nn);\n+    }\n+    pSeg->nPgTombstone = nHash;\n+    fts5StructureWrite(p, p->pStruct);\n+  }\n+\n+  fts5DataRelease(pPg);\n+  fts5IndexFreeArray(apHash, nHash);\n+}\n+\n+\/*\n+** Add iRowid to the tombstone list of the segment or segments that contain\n+** rows from origin iOrigin. Return SQLITE_OK if successful, or an SQLite\n+** error code otherwise.\n+*\/\n+static int sqlite3Fts5IndexContentlessDelete(Fts5Index *p, i64 iOrigin, i64 iRowid){\n+  Fts5Structure *pStruct;\n+  pStruct = fts5StructureRead(p);\n+  if( pStruct ){\n+    int bFound = 0;               \/* True after pSeg->nEntryTombstone incr. *\/\n+    int iLvl;\n+    for(iLvl=pStruct->nLevel-1; iLvl>=0; iLvl--){\n+      int iSeg;\n+      for(iSeg=pStruct->aLevel[iLvl].nSeg-1; iSeg>=0; iSeg--){\n+        Fts5StructureSegment *pSeg = &pStruct->aLevel[iLvl].aSeg[iSeg];\n+        if( pSeg->iOrigin1<=(u64)iOrigin && pSeg->iOrigin2>=(u64)iOrigin ){\n+          if( bFound==0 ){\n+            pSeg->nEntryTombstone++;\n+            bFound = 1;\n+          }\n+          fts5IndexTombstoneAdd(p, pSeg, iRowid);\n+        }\n+      }\n+    }\n+    fts5StructureRelease(pStruct);\n+  }\n+  return fts5IndexReturn(p);\n+}\n@@ -232983,1 +246570,3 @@\n-  int rc = sqlite3Fts5IndexQuery(p, z, n, flags, 0, &pIter);\n+  int rc = sqlite3Fts5IndexQuery(\n+      p, z, n, (flags | FTS5INDEX_QUERY_NOTOKENDATA), 0, &pIter\n+  );\n@@ -233150,1 +246739,1 @@\n-  int iTermOff = 0;\n+  i64 iTermOff = 0;\n@@ -233159,1 +246748,1 @@\n-    int iOff;\n+    i64 iOff;\n@@ -233204,0 +246793,1 @@\n+  int bSecureDelete = (pConfig->iVersion==FTS5_CURRENT_VERSION_SECUREDELETE);\n@@ -233239,1 +246829,13 @@\n-      p->rc = FTS5_CORRUPT;\n+\n+      if( nIdxTerm==0\n+       && pConfig->iVersion==FTS5_CURRENT_VERSION_SECUREDELETE\n+       && pLeaf->nn==pLeaf->szLeaf\n+       && pLeaf->nn==4\n+      ){\n+        \/* special case - the very first page in a segment keeps its %_idx\n+        ** entry even if all the terms are removed from it by secure-delete\n+        ** operations. *\/\n+      }else{\n+        p->rc = FTS5_CORRUPT;\n+      }\n+\n@@ -233303,1 +246905,2 @@\n-          }else{\n+          }else if( bSecureDelete==0 || iRowidOff>0 ){\n+            i64 iDlRowid = fts5DlidxIterRowid(pDlidx);\n@@ -233305,1 +246908,3 @@\n-            if( iRowid!=fts5DlidxIterRowid(pDlidx) ) p->rc = FTS5_CORRUPT;\n+            if( iRowid<iDlRowid || (bSecureDelete==0 && iRowid!=iDlRowid) ){\n+              p->rc = FTS5_CORRUPT;\n+            }\n@@ -233399,0 +247004,1 @@\n+    if( p->rc ) break;\n@@ -233434,1 +247040,1 @@\n-#ifdef SQLITE_TEST\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n@@ -233441,0 +247047,1 @@\n+  int *pbTombstone,               \/* OUT: Tombstone hash flag *\/\n@@ -233456,0 +247063,3 @@\n+  iRowid >>= FTS5_DATA_ID_B;\n+\n+  *pbTombstone = (int)(iRowid & 0x0001);\n@@ -233457,1 +247067,1 @@\n-#endif \/* SQLITE_TEST *\/\n+#endif \/* SQLITE_TEST || SQLITE_FTS5_DEBUG *\/\n@@ -233459,1 +247069,1 @@\n-#ifdef SQLITE_TEST\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n@@ -233461,2 +247071,2 @@\n-  int iSegid, iHeight, iPgno, bDlidx;       \/* Rowid compenents *\/\n-  fts5DecodeRowid(iKey, &iSegid, &bDlidx, &iHeight, &iPgno);\n+  int iSegid, iHeight, iPgno, bDlidx, bTomb;     \/* Rowid compenents *\/\n+  fts5DecodeRowid(iKey, &bTomb, &iSegid, &bDlidx, &iHeight, &iPgno);\n@@ -233472,2 +247082,4 @@\n-    sqlite3Fts5BufferAppendPrintf(pRc, pBuf, \"{%ssegid=%d h=%d pgno=%d}\",\n-        bDlidx ? \"dlidx \" : \"\", iSegid, iHeight, iPgno\n+    sqlite3Fts5BufferAppendPrintf(pRc, pBuf, \"{%s%ssegid=%d h=%d pgno=%d}\",\n+        bDlidx ? \"dlidx \" : \"\",\n+        bTomb ? \"tombstone \" : \"\",\n+        iSegid, iHeight, iPgno\n@@ -233477,1 +247089,1 @@\n-#endif \/* SQLITE_TEST *\/\n+#endif \/* SQLITE_TEST || SQLITE_FTS5_DEBUG *\/\n@@ -233479,1 +247091,1 @@\n-#ifdef SQLITE_TEST\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n@@ -233494,1 +247106,1 @@\n-      sqlite3Fts5BufferAppendPrintf(pRc, pBuf, \" {id=%d leaves=%d..%d}\",\n+      sqlite3Fts5BufferAppendPrintf(pRc, pBuf, \" {id=%d leaves=%d..%d\",\n@@ -233497,0 +247109,6 @@\n+      if( pSeg->iOrigin1>0 ){\n+        sqlite3Fts5BufferAppendPrintf(pRc, pBuf, \" origin=%lld..%lld\",\n+            pSeg->iOrigin1, pSeg->iOrigin2\n+        );\n+      }\n+      sqlite3Fts5BufferAppendPrintf(pRc, pBuf, \"}\");\n@@ -233501,1 +247119,1 @@\n-#endif \/* SQLITE_TEST *\/\n+#endif \/* SQLITE_TEST || SQLITE_FTS5_DEBUG *\/\n@@ -233503,1 +247121,1 @@\n-#ifdef SQLITE_TEST\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n@@ -233528,1 +247146,1 @@\n-#endif \/* SQLITE_TEST *\/\n+#endif \/* SQLITE_TEST || SQLITE_FTS5_DEBUG *\/\n@@ -233530,1 +247148,1 @@\n-#ifdef SQLITE_TEST\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n@@ -233553,1 +247171,1 @@\n-#endif \/* SQLITE_TEST *\/\n+#endif \/* SQLITE_TEST || SQLITE_FTS5_DEBUG *\/\n@@ -233555,1 +247173,1 @@\n-#ifdef SQLITE_TEST\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n@@ -233572,1 +247190,1 @@\n-#endif \/* SQLITE_TEST *\/\n+#endif \/* SQLITE_TEST || SQLITE_FTS5_DEBUG *\/\n@@ -233574,1 +247192,1 @@\n-#ifdef SQLITE_TEST\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n@@ -233607,1 +247225,1 @@\n-#endif \/* SQLITE_TEST *\/\n+#endif \/* SQLITE_TEST || SQLITE_FTS5_DEBUG *\/\n@@ -233609,1 +247227,1 @@\n-#ifdef SQLITE_TEST\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n@@ -233650,1 +247268,1 @@\n-#endif \/* SQLITE_TEST *\/\n+#endif \/* SQLITE_TEST || SQLITE_FTS5_DEBUG *\/\n@@ -233652,1 +247270,19 @@\n-#ifdef SQLITE_TEST\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n+static void fts5BufferAppendTerm(int *pRc, Fts5Buffer *pBuf, Fts5Buffer *pTerm){\n+  int ii;\n+  fts5BufferGrow(pRc, pBuf, pTerm->n*2 + 1);\n+  if( *pRc==SQLITE_OK ){\n+    for(ii=0; ii<pTerm->n; ii++){\n+      if( pTerm->p[ii]==0x00 ){\n+        pBuf->p[pBuf->n++] = '\\\\';\n+        pBuf->p[pBuf->n++] = '0';\n+      }else{\n+        pBuf->p[pBuf->n++] = pTerm->p[ii];\n+      }\n+    }\n+    pBuf->p[pBuf->n] = 0x00;\n+  }\n+}\n+#endif \/* SQLITE_TEST || SQLITE_FTS5_DEBUG *\/\n+\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n@@ -233663,0 +247299,1 @@\n+  int bTomb;\n@@ -233685,1 +247322,1 @@\n-  fts5DecodeRowid(iRowid, &iSegid, &bDlidx, &iHeight, &iPgno);\n+  fts5DecodeRowid(iRowid, &bTomb, &iSegid, &bDlidx, &iHeight, &iPgno);\n@@ -233704,0 +247341,22 @@\n+  }else if( bTomb ){\n+    u32 nElem  = fts5GetU32(&a[4]);\n+    int szKey = (aBlob[0]==4 || aBlob[0]==8) ? aBlob[0] : 8;\n+    int nSlot = (n - 8) \/ szKey;\n+    int ii;\n+    sqlite3Fts5BufferAppendPrintf(&rc, &s, \" nElem=%d\", (int)nElem);\n+    if( aBlob[1] ){\n+      sqlite3Fts5BufferAppendPrintf(&rc, &s, \" 0\");\n+    }\n+    for(ii=0; ii<nSlot; ii++){\n+      u64 iVal = 0;\n+      if( szKey==4 ){\n+        u32 *aSlot = (u32*)&aBlob[8];\n+        if( aSlot[ii] ) iVal = fts5GetU32((u8*)&aSlot[ii]);\n+      }else{\n+        u64 *aSlot = (u64*)&aBlob[8];\n+        if( aSlot[ii] ) iVal = fts5GetU64((u8*)&aSlot[ii]);\n+      }\n+      if( iVal!=0 ){\n+        sqlite3Fts5BufferAppendPrintf(&rc, &s, \" %lld\", (i64)iVal);\n+      }\n+    }\n@@ -233729,1 +247388,1 @@\n-    while( iOff<szLeaf ){\n+    while( iOff<szLeaf && rc==SQLITE_OK ){\n@@ -233736,3 +247395,2 @@\n-      sqlite3Fts5BufferAppendPrintf(\n-          &rc, &s, \" term=%.*s\", term.n, (const char*)term.p\n-      );\n+      sqlite3Fts5BufferAppendPrintf(&rc, &s, \" term=\");\n+      fts5BufferAppendTerm(&rc, &s, &term);\n@@ -233749,2 +247407,5 @@\n-\n-      fts5DecodeRowidList(&rc, &s, &a[iOff], iTermOff-iOff);\n+      if( iTermOff>szLeaf ){\n+        rc = FTS5_CORRUPT;\n+      }else{\n+        fts5DecodeRowidList(&rc, &s, &a[iOff], iTermOff-iOff);\n+      }\n@@ -233843,3 +247504,2 @@\n-      sqlite3Fts5BufferAppendPrintf(\n-          &rc, &s, \" term=%.*s\", term.n, (const char*)term.p\n-      );\n+      sqlite3Fts5BufferAppendPrintf(&rc, &s, \" term=\");\n+      fts5BufferAppendTerm(&rc, &s, &term);\n@@ -233861,1 +247521,1 @@\n-#endif \/* SQLITE_TEST *\/\n+#endif \/* SQLITE_TEST || SQLITE_FTS5_DEBUG *\/\n@@ -233863,1 +247523,1 @@\n-#ifdef SQLITE_TEST\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n@@ -233897,1 +247557,229 @@\n-#endif \/* SQLITE_TEST *\/\n+#endif \/* SQLITE_TEST || SQLITE_FTS5_DEBUG *\/\n+\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n+\n+typedef struct Fts5StructVtab Fts5StructVtab;\n+struct Fts5StructVtab {\n+  sqlite3_vtab base;\n+};\n+\n+typedef struct Fts5StructVcsr Fts5StructVcsr;\n+struct Fts5StructVcsr {\n+  sqlite3_vtab_cursor base;\n+  Fts5Structure *pStruct;\n+  int iLevel;\n+  int iSeg;\n+  int iRowid;\n+};\n+\n+\/*\n+** Create a new fts5_structure() table-valued function.\n+*\/\n+static int fts5structConnectMethod(\n+  sqlite3 *db,\n+  void *pAux,\n+  int argc, const char *const*argv,\n+  sqlite3_vtab **ppVtab,\n+  char **pzErr\n+){\n+  Fts5StructVtab *pNew = 0;\n+  int rc = SQLITE_OK;\n+\n+  rc = sqlite3_declare_vtab(db,\n+      \"CREATE TABLE xyz(\"\n+          \"level, segment, merge, segid, leaf1, leaf2, loc1, loc2, \"\n+          \"npgtombstone, nentrytombstone, nentry, struct HIDDEN);\"\n+  );\n+  if( rc==SQLITE_OK ){\n+    pNew = sqlite3Fts5MallocZero(&rc, sizeof(*pNew));\n+  }\n+\n+  *ppVtab = (sqlite3_vtab*)pNew;\n+  return rc;\n+}\n+\n+\/*\n+** We must have a single struct=? constraint that will be passed through\n+** into the xFilter method.  If there is no valid stmt=? constraint,\n+** then return an SQLITE_CONSTRAINT error.\n+*\/\n+static int fts5structBestIndexMethod(\n+  sqlite3_vtab *tab,\n+  sqlite3_index_info *pIdxInfo\n+){\n+  int i;\n+  int rc = SQLITE_CONSTRAINT;\n+  struct sqlite3_index_constraint *p;\n+  pIdxInfo->estimatedCost = (double)100;\n+  pIdxInfo->estimatedRows = 100;\n+  pIdxInfo->idxNum = 0;\n+  for(i=0, p=pIdxInfo->aConstraint; i<pIdxInfo->nConstraint; i++, p++){\n+    if( p->usable==0 ) continue;\n+    if( p->op==SQLITE_INDEX_CONSTRAINT_EQ && p->iColumn==11 ){\n+      rc = SQLITE_OK;\n+      pIdxInfo->aConstraintUsage[i].omit = 1;\n+      pIdxInfo->aConstraintUsage[i].argvIndex = 1;\n+      break;\n+    }\n+  }\n+  return rc;\n+}\n+\n+\/*\n+** This method is the destructor for bytecodevtab objects.\n+*\/\n+static int fts5structDisconnectMethod(sqlite3_vtab *pVtab){\n+  Fts5StructVtab *p = (Fts5StructVtab*)pVtab;\n+  sqlite3_free(p);\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Constructor for a new bytecodevtab_cursor object.\n+*\/\n+static int fts5structOpenMethod(sqlite3_vtab *p, sqlite3_vtab_cursor **ppCsr){\n+  int rc = SQLITE_OK;\n+  Fts5StructVcsr *pNew = 0;\n+\n+  pNew = sqlite3Fts5MallocZero(&rc, sizeof(*pNew));\n+  *ppCsr = (sqlite3_vtab_cursor*)pNew;\n+\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Destructor for a bytecodevtab_cursor.\n+*\/\n+static int fts5structCloseMethod(sqlite3_vtab_cursor *cur){\n+  Fts5StructVcsr *pCsr = (Fts5StructVcsr*)cur;\n+  fts5StructureRelease(pCsr->pStruct);\n+  sqlite3_free(pCsr);\n+  return SQLITE_OK;\n+}\n+\n+\n+\/*\n+** Advance a bytecodevtab_cursor to its next row of output.\n+*\/\n+static int fts5structNextMethod(sqlite3_vtab_cursor *cur){\n+  Fts5StructVcsr *pCsr = (Fts5StructVcsr*)cur;\n+  Fts5Structure *p = pCsr->pStruct;\n+\n+  assert( pCsr->pStruct );\n+  pCsr->iSeg++;\n+  pCsr->iRowid++;\n+  while( pCsr->iLevel<p->nLevel && pCsr->iSeg>=p->aLevel[pCsr->iLevel].nSeg ){\n+    pCsr->iLevel++;\n+    pCsr->iSeg = 0;\n+  }\n+  if( pCsr->iLevel>=p->nLevel ){\n+    fts5StructureRelease(pCsr->pStruct);\n+    pCsr->pStruct = 0;\n+  }\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Return TRUE if the cursor has been moved off of the last\n+** row of output.\n+*\/\n+static int fts5structEofMethod(sqlite3_vtab_cursor *cur){\n+  Fts5StructVcsr *pCsr = (Fts5StructVcsr*)cur;\n+  return pCsr->pStruct==0;\n+}\n+\n+static int fts5structRowidMethod(\n+  sqlite3_vtab_cursor *cur,\n+  sqlite_int64 *piRowid\n+){\n+  Fts5StructVcsr *pCsr = (Fts5StructVcsr*)cur;\n+  *piRowid = pCsr->iRowid;\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Return values of columns for the row at which the bytecodevtab_cursor\n+** is currently pointing.\n+*\/\n+static int fts5structColumnMethod(\n+  sqlite3_vtab_cursor *cur,   \/* The cursor *\/\n+  sqlite3_context *ctx,       \/* First argument to sqlite3_result_...() *\/\n+  int i                       \/* Which column to return *\/\n+){\n+  Fts5StructVcsr *pCsr = (Fts5StructVcsr*)cur;\n+  Fts5Structure *p = pCsr->pStruct;\n+  Fts5StructureSegment *pSeg = &p->aLevel[pCsr->iLevel].aSeg[pCsr->iSeg];\n+\n+  switch( i ){\n+    case 0: \/* level *\/\n+      sqlite3_result_int(ctx, pCsr->iLevel);\n+      break;\n+    case 1: \/* segment *\/\n+      sqlite3_result_int(ctx, pCsr->iSeg);\n+      break;\n+    case 2: \/* merge *\/\n+      sqlite3_result_int(ctx, pCsr->iSeg < p->aLevel[pCsr->iLevel].nMerge);\n+      break;\n+    case 3: \/* segid *\/\n+      sqlite3_result_int(ctx, pSeg->iSegid);\n+      break;\n+    case 4: \/* leaf1 *\/\n+      sqlite3_result_int(ctx, pSeg->pgnoFirst);\n+      break;\n+    case 5: \/* leaf2 *\/\n+      sqlite3_result_int(ctx, pSeg->pgnoLast);\n+      break;\n+    case 6: \/* origin1 *\/\n+      sqlite3_result_int64(ctx, pSeg->iOrigin1);\n+      break;\n+    case 7: \/* origin2 *\/\n+      sqlite3_result_int64(ctx, pSeg->iOrigin2);\n+      break;\n+    case 8: \/* npgtombstone *\/\n+      sqlite3_result_int(ctx, pSeg->nPgTombstone);\n+      break;\n+    case 9: \/* nentrytombstone *\/\n+      sqlite3_result_int64(ctx, pSeg->nEntryTombstone);\n+      break;\n+    case 10: \/* nentry *\/\n+      sqlite3_result_int64(ctx, pSeg->nEntry);\n+      break;\n+  }\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Initialize a cursor.\n+**\n+**    idxNum==0     means show all subprograms\n+**    idxNum==1     means show only the main bytecode and omit subprograms.\n+*\/\n+static int fts5structFilterMethod(\n+  sqlite3_vtab_cursor *pVtabCursor,\n+  int idxNum, const char *idxStr,\n+  int argc, sqlite3_value **argv\n+){\n+  Fts5StructVcsr *pCsr = (Fts5StructVcsr *)pVtabCursor;\n+  int rc = SQLITE_OK;\n+\n+  const u8 *aBlob = 0;\n+  int nBlob = 0;\n+\n+  assert( argc==1 );\n+  fts5StructureRelease(pCsr->pStruct);\n+  pCsr->pStruct = 0;\n+\n+  nBlob = sqlite3_value_bytes(argv[0]);\n+  aBlob = (const u8*)sqlite3_value_blob(argv[0]);\n+  rc = fts5StructureDecode(aBlob, nBlob, 0, &pCsr->pStruct);\n+  if( rc==SQLITE_OK ){\n+    pCsr->iLevel = 0;\n+    pCsr->iRowid = 0;\n+    pCsr->iSeg = -1;\n+    rc = fts5structNextMethod(pVtabCursor);\n+  }\n+\n+  return rc;\n+}\n+\n+#endif \/* SQLITE_TEST || SQLITE_FTS5_DEBUG *\/\n@@ -233908,1 +247796,1 @@\n-#ifdef SQLITE_TEST\n+#if defined(SQLITE_TEST) || defined(SQLITE_FTS5_DEBUG)\n@@ -233925,0 +247813,31 @@\n+\n+  if( rc==SQLITE_OK ){\n+    static const sqlite3_module fts5structure_module = {\n+      0,                           \/* iVersion      *\/\n+      0,                           \/* xCreate       *\/\n+      fts5structConnectMethod,     \/* xConnect      *\/\n+      fts5structBestIndexMethod,   \/* xBestIndex    *\/\n+      fts5structDisconnectMethod,  \/* xDisconnect   *\/\n+      0,                           \/* xDestroy      *\/\n+      fts5structOpenMethod,        \/* xOpen         *\/\n+      fts5structCloseMethod,       \/* xClose        *\/\n+      fts5structFilterMethod,      \/* xFilter       *\/\n+      fts5structNextMethod,        \/* xNext         *\/\n+      fts5structEofMethod,         \/* xEof          *\/\n+      fts5structColumnMethod,      \/* xColumn       *\/\n+      fts5structRowidMethod,       \/* xRowid        *\/\n+      0,                           \/* xUpdate       *\/\n+      0,                           \/* xBegin        *\/\n+      0,                           \/* xSync         *\/\n+      0,                           \/* xCommit       *\/\n+      0,                           \/* xRollback     *\/\n+      0,                           \/* xFindFunction *\/\n+      0,                           \/* xRename       *\/\n+      0,                           \/* xSavepoint    *\/\n+      0,                           \/* xRelease      *\/\n+      0,                           \/* xRollbackTo   *\/\n+      0,                           \/* xShadowName   *\/\n+      0                            \/* xIntegrity    *\/\n+    };\n+    rc = sqlite3_create_module(db, \"fts5_structure\", &fts5structure_module, 0);\n+  }\n@@ -234060,0 +247979,2 @@\n+  int iSavepoint;                 \/* Successful xSavepoint()+1 *\/\n+\n@@ -234203,1 +248124,1 @@\n-      assert( p->ts.eState==1 );\n+      assert( p->ts.eState==1 || p->ts.eState==2 );\n@@ -234218,1 +248139,1 @@\n-      assert( p->ts.eState==1 );\n+      assert( p->ts.eState>=1 );\n@@ -234225,1 +248146,1 @@\n-      assert( p->ts.eState==1 );\n+      assert( p->ts.eState>=1 );\n@@ -234232,1 +248153,1 @@\n-      assert( p->ts.eState==1 );\n+      assert( p->ts.eState>=1 );\n@@ -234348,0 +248269,7 @@\n+  if( rc==SQLITE_OK && pConfig->eContent==FTS5_CONTENT_NORMAL ){\n+    rc = sqlite3_vtab_config(db, SQLITE_VTAB_CONSTRAINT_SUPPORT, (int)1);\n+  }\n+  if( rc==SQLITE_OK ){\n+    rc = sqlite3_vtab_config(db, SQLITE_VTAB_INNOCUOUS);\n+  }\n+\n@@ -234590,1 +248518,4 @@\n-  \/* Set idxFlags flags for the ORDER BY clause *\/\n+  \/* Set idxFlags flags for the ORDER BY clause\n+  **\n+  ** Note that tokendata=1 tables cannot currently handle \"ORDER BY rowid DESC\".\n+  *\/\n@@ -234595,1 +248526,1 @@\n-    }else if( iSort==-1 ){\n+    }else if( iSort==-1 && (!pInfo->aOrderBy[0].desc || !pConfig->bTokendata) ){\n@@ -234847,0 +248778,10 @@\n+  \/* If this cursor uses FTS5_PLAN_MATCH and this is a tokendata=1 table,\n+  ** clear any token mappings accumulated at the fts5_index.c level. In\n+  ** other cases, specifically FTS5_PLAN_SOURCE and FTS5_PLAN_SORTED_MATCH,\n+  ** we need to retain the mappings for the entire query.  *\/\n+  if( pCsr->ePlan==FTS5_PLAN_MATCH\n+   && ((Fts5Table*)pCursor->pVtab)->pConfig->bTokendata\n+  ){\n+    sqlite3Fts5ExprClearTokens(pCsr->pExpr);\n+  }\n+\n@@ -235272,0 +249213,3 @@\n+  rc = sqlite3Fts5IndexLoadConfig(pTab->p.pIndex);\n+  if( rc!=SQLITE_OK ) goto filter_out;\n+\n@@ -235294,0 +249238,1 @@\n+    assert( rc==SQLITE_OK );\n@@ -235465,0 +249410,1 @@\n+  int bLoadConfig = 0;\n@@ -235476,0 +249422,1 @@\n+    bLoadConfig = 1;\n@@ -235485,0 +249432,1 @@\n+    bLoadConfig = 1;\n@@ -235497,0 +249445,2 @@\n+  }else if( 0==sqlite3_stricmp(\"flush\", zCmd) ){\n+    rc = sqlite3Fts5FlushToDisk(&pTab->p);\n@@ -235498,1 +249448,4 @@\n-    rc = sqlite3Fts5IndexLoadConfig(pTab->p.pIndex);\n+    rc = sqlite3Fts5FlushToDisk(&pTab->p);\n+    if( rc==SQLITE_OK ){\n+      rc = sqlite3Fts5IndexLoadConfig(pTab->p.pIndex);\n+    }\n@@ -235510,0 +249463,6 @@\n+\n+  if( rc==SQLITE_OK && bLoadConfig ){\n+    pTab->p.pConfig->iCookie--;\n+    rc = sqlite3Fts5IndexLoadConfig(pTab->p.pIndex);\n+  }\n+\n@@ -235566,0 +249525,1 @@\n+  int bUpdateOrDelete = 0;\n@@ -235568,1 +249528,1 @@\n-  assert( pTab->ts.eState==1 );\n+  assert( pTab->ts.eState==1 || pTab->ts.eState==2 );\n@@ -235576,0 +249536,5 @@\n+  if( pConfig->pgsz==0 ){\n+    rc = sqlite3Fts5IndexLoadConfig(pTab->p.pIndex);\n+    if( rc!=SQLITE_OK ) return rc;\n+  }\n+\n@@ -235590,1 +249555,8 @@\n-      rc = fts5SpecialDelete(pTab, apVal);\n+      if( pConfig->bContentlessDelete ){\n+        fts5SetVtabError(pTab,\n+            \"'delete' may not be used with a contentless_delete=1 table\"\n+        );\n+        rc = SQLITE_ERROR;\n+      }else{\n+        rc = fts5SpecialDelete(pTab, apVal);\n+      }\n@@ -235607,1 +249579,1 @@\n-    if( pConfig->eContent==FTS5_CONTENT_NORMAL ){\n+    if( pConfig->eContent==FTS5_CONTENT_NORMAL || pConfig->bContentlessDelete ){\n@@ -235615,2 +249587,6 @@\n-    ** This is not suported.  *\/\n-    if( eType0==SQLITE_INTEGER && fts5IsContentless(pTab) ){\n+    ** This is not suported. Except - they are both supported if the CREATE\n+    ** VIRTUAL TABLE statement contained \"contentless_delete=1\". *\/\n+    if( eType0==SQLITE_INTEGER\n+     && pConfig->eContent==FTS5_CONTENT_NONE\n+     && pConfig->bContentlessDelete==0\n+    ){\n@@ -235628,0 +249604,1 @@\n+      bUpdateOrDelete = 1;\n@@ -235639,1 +249616,2 @@\n-        \/* If this is a REPLACE, first remove the current entry (if any) *\/\n+        \/* An INSERT statement. If the conflict-mode is REPLACE, first remove\n+        ** the current entry (if any). *\/\n@@ -235643,0 +249621,1 @@\n+          bUpdateOrDelete = 1;\n@@ -235671,0 +249650,1 @@\n+        bUpdateOrDelete = 1;\n@@ -235675,0 +249655,13 @@\n+  if( rc==SQLITE_OK\n+   && bUpdateOrDelete\n+   && pConfig->bSecureDelete\n+   && pConfig->iVersion==FTS5_CURRENT_VERSION\n+  ){\n+    rc = sqlite3Fts5StorageConfigValue(\n+        pTab->pStorage, \"version\", 0, FTS5_CURRENT_VERSION_SECUREDELETE\n+    );\n+    if( rc==SQLITE_OK ){\n+      pConfig->iVersion = FTS5_CURRENT_VERSION_SECUREDELETE;\n+    }\n+  }\n+\n@@ -235687,2 +249680,1 @@\n-  fts5TripCursors(pTab);\n-  rc = sqlite3Fts5StorageSync(pTab->pStorage);\n+  rc = sqlite3Fts5FlushToDisk(&pTab->p);\n@@ -235784,1 +249776,4 @@\n-  if( fts5IsContentless((Fts5FullTable*)(pCsr->base.pVtab))\n+  Fts5Table *pTab = (Fts5Table*)(pCsr->base.pVtab);\n+  if( iCol<0 || iCol>=pTab->pConfig->nCol ){\n+    rc = SQLITE_RANGE;\n+  }else if( fts5IsContentless((Fts5FullTable*)(pCsr->base.pVtab))\n@@ -235809,2 +249804,3 @@\n-  if( CsrFlagTest(pCsr, FTS5CSR_REQUIRE_POSLIST) ){\n-\n+  if( iPhrase<0 || iPhrase>=sqlite3Fts5ExprPhraseCount(pCsr->pExpr) ){\n+    rc = SQLITE_RANGE;\n+  }else if( CsrFlagTest(pCsr, FTS5CSR_REQUIRE_POSLIST) ){\n@@ -235834,5 +249830,9 @@\n-  if( pCsr->pSorter && pConfig->eDetail==FTS5_DETAIL_FULL ){\n-    Fts5Sorter *pSorter = pCsr->pSorter;\n-    int i1 = (iPhrase==0 ? 0 : pSorter->aIdx[iPhrase-1]);\n-    *pn = pSorter->aIdx[iPhrase] - i1;\n-    *pa = &pSorter->aPoslist[i1];\n+  if( rc==SQLITE_OK ){\n+    if( pCsr->pSorter && pConfig->eDetail==FTS5_DETAIL_FULL ){\n+      Fts5Sorter *pSorter = pCsr->pSorter;\n+      int i1 = (iPhrase==0 ? 0 : pSorter->aIdx[iPhrase-1]);\n+      *pn = pSorter->aIdx[iPhrase] - i1;\n+      *pa = &pSorter->aPoslist[i1];\n+    }else{\n+      *pn = sqlite3Fts5ExprPoslist(pCsr->pExpr, iPhrase, pa);\n+    }\n@@ -235840,1 +249840,2 @@\n-    *pn = sqlite3Fts5ExprPoslist(pCsr->pExpr, iPhrase, pa);\n+    *pa = 0;\n+    *pn = 0;\n@@ -235843,0 +249844,1 @@\n+\n@@ -235949,6 +249951,0 @@\n-#if 0\n-    }else if( fts5IsOffsetless((Fts5Table*)pCsr->base.pVtab) ){\n-      *piPhrase = pCsr->aInst[iIdx*3];\n-      *piCol = pCsr->aInst[iIdx*3 + 2];\n-      *piOff = -1;\n-#endif\n@@ -236209,0 +250205,43 @@\n+\/*\n+** xQueryToken() API implemenetation.\n+*\/\n+static int fts5ApiQueryToken(\n+  Fts5Context* pCtx,\n+  int iPhrase,\n+  int iToken,\n+  const char **ppOut,\n+  int *pnOut\n+){\n+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;\n+  return sqlite3Fts5ExprQueryToken(pCsr->pExpr, iPhrase, iToken, ppOut, pnOut);\n+}\n+\n+\/*\n+** xInstToken() API implemenetation.\n+*\/\n+static int fts5ApiInstToken(\n+  Fts5Context *pCtx,\n+  int iIdx,\n+  int iToken,\n+  const char **ppOut, int *pnOut\n+){\n+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;\n+  int rc = SQLITE_OK;\n+  if( CsrFlagTest(pCsr, FTS5CSR_REQUIRE_INST)==0\n+   || SQLITE_OK==(rc = fts5CacheInstArray(pCsr))\n+  ){\n+    if( iIdx<0 || iIdx>=pCsr->nInstCount ){\n+      rc = SQLITE_RANGE;\n+    }else{\n+      int iPhrase = pCsr->aInst[iIdx*3];\n+      int iCol = pCsr->aInst[iIdx*3 + 1];\n+      int iOff = pCsr->aInst[iIdx*3 + 2];\n+      i64 iRowid = fts5CursorRowid(pCsr);\n+      rc = sqlite3Fts5ExprInstToken(\n+          pCsr->pExpr, iRowid, iPhrase, iCol, iOff, iToken, ppOut, pnOut\n+      );\n+    }\n+  }\n+  return rc;\n+}\n+\n@@ -236215,1 +250254,1 @@\n-  2,                            \/* iVersion *\/\n+  3,                            \/* iVersion *\/\n@@ -236235,0 +250274,2 @@\n+  fts5ApiQueryToken,\n+  fts5ApiInstToken\n@@ -236455,0 +250496,6 @@\n+  }else if( pConfig->bContentlessDelete && sqlite3_vtab_nochange(pCtx) ){\n+    char *zErr = sqlite3_mprintf(\"cannot UPDATE a subset of \"\n+        \"columns on fts5 contentless-delete table: %s\", pConfig->zName\n+    );\n+    sqlite3_result_error(pCtx, zErr, -1);\n+    sqlite3_free(zErr);\n@@ -236493,0 +250540,1 @@\n+  int rc;\n@@ -236494,1 +250542,2 @@\n-  return sqlite3Fts5StorageRename(pTab->pStorage, zName);\n+  rc = sqlite3Fts5StorageRename(pTab->pStorage, zName);\n+  return rc;\n@@ -236508,3 +250557,9 @@\n-  UNUSED_PARAM(iSavepoint);  \/* Call below is a no-op for NDEBUG builds *\/\n-  fts5CheckTransactionState((Fts5FullTable*)pVtab, FTS5_SAVEPOINT, iSavepoint);\n-  return sqlite3Fts5FlushToDisk((Fts5Table*)pVtab);\n+  Fts5FullTable *pTab = (Fts5FullTable*)pVtab;\n+  int rc = SQLITE_OK;\n+\n+  fts5CheckTransactionState(pTab, FTS5_SAVEPOINT, iSavepoint);\n+  rc = sqlite3Fts5FlushToDisk((Fts5Table*)pVtab);\n+  if( rc==SQLITE_OK ){\n+    pTab->iSavepoint = iSavepoint+1;\n+  }\n+  return rc;\n@@ -236519,3 +250574,10 @@\n-  UNUSED_PARAM(iSavepoint);  \/* Call below is a no-op for NDEBUG builds *\/\n-  fts5CheckTransactionState((Fts5FullTable*)pVtab, FTS5_RELEASE, iSavepoint);\n-  return sqlite3Fts5FlushToDisk((Fts5Table*)pVtab);\n+  Fts5FullTable *pTab = (Fts5FullTable*)pVtab;\n+  int rc = SQLITE_OK;\n+  fts5CheckTransactionState(pTab, FTS5_RELEASE, iSavepoint);\n+  if( (iSavepoint+1)<pTab->iSavepoint ){\n+    rc = sqlite3Fts5FlushToDisk(&pTab->p);\n+    if( rc==SQLITE_OK ){\n+      pTab->iSavepoint = iSavepoint;\n+    }\n+  }\n+  return rc;\n@@ -236531,1 +250593,1 @@\n-  UNUSED_PARAM(iSavepoint);  \/* Call below is a no-op for NDEBUG builds *\/\n+  int rc = SQLITE_OK;\n@@ -236534,1 +250596,5 @@\n-  return sqlite3Fts5StorageRollback(pTab->pStorage);\n+  if( (iSavepoint+1)<=pTab->iSavepoint ){\n+    pTab->p.pConfig->pgsz = 0;\n+    rc = sqlite3Fts5StorageRollback(pTab->pStorage);\n+  }\n+  return rc;\n@@ -236736,1 +250802,1 @@\n-  sqlite3_result_text(pCtx, \"fts5: 2022-09-29 15:55:41 a29f9949895322123f7c38fbe94c649a9d6e6c9cd0c3b41c96d694552f26b309\", -1, SQLITE_TRANSIENT);\n+  sqlite3_result_text(pCtx, \"fts5: 2024-04-15 13:34:05 8653b758870e6ef0c98d46b3ace27849054af85da891eb121e9aaa537f1e8355\", -1, SQLITE_TRANSIENT);\n@@ -236754,0 +250820,31 @@\n+\/*\n+** Run an integrity check on the FTS5 data structures.  Return a string\n+** if anything is found amiss.  Return a NULL pointer if everything is\n+** OK.\n+*\/\n+static int fts5IntegrityMethod(\n+  sqlite3_vtab *pVtab,    \/* the FTS5 virtual table to check *\/\n+  const char *zSchema,    \/* Name of schema in which this table lives *\/\n+  const char *zTabname,   \/* Name of the table itself *\/\n+  int isQuick,            \/* True if this is a quick-check *\/\n+  char **pzErr            \/* Write error message here *\/\n+){\n+  Fts5FullTable *pTab = (Fts5FullTable*)pVtab;\n+  int rc;\n+\n+  assert( pzErr!=0 && *pzErr==0 );\n+  UNUSED_PARAM(isQuick);\n+  rc = sqlite3Fts5StorageIntegrity(pTab->pStorage, 0);\n+  if( (rc&0xff)==SQLITE_CORRUPT ){\n+    *pzErr = sqlite3_mprintf(\"malformed inverted index for FTS5 table %s.%s\",\n+                zSchema, zTabname);\n+  }else if( rc!=SQLITE_OK ){\n+    *pzErr = sqlite3_mprintf(\"unable to validate the inverted index for\"\n+                             \" FTS5 table %s.%s: %s\",\n+                zSchema, zTabname, sqlite3_errstr(rc));\n+  }\n+  sqlite3Fts5IndexCloseReader(pTab->p.pIndex);\n+\n+  return SQLITE_OK;\n+}\n+\n@@ -236756,1 +250853,1 @@\n-    \/* iVersion      *\/ 3,\n+    \/* iVersion      *\/ 4,\n@@ -236779,1 +250876,2 @@\n-    \/* xShadowName   *\/ fts5ShadowName\n+    \/* xShadowName   *\/ fts5ShadowName,\n+    \/* xIntegrity    *\/ fts5IntegrityMethod\n@@ -236809,1 +250907,3 @@\n-          db, \"fts5_source_id\", 0, SQLITE_UTF8, p, fts5SourceIdFunc, 0, 0\n+          db, \"fts5_source_id\", 0,\n+          SQLITE_UTF8|SQLITE_DETERMINISTIC|SQLITE_INNOCUOUS,\n+          p, fts5SourceIdFunc, 0, 0\n@@ -236947,1 +251047,1 @@\n-      \"REPLACE INTO %Q.'%q_docsize' VALUES(?,?)\",       \/* REPLACE_DOCSIZE  *\/\n+      \"REPLACE INTO %Q.'%q_docsize' VALUES(?,?%s)\",     \/* REPLACE_DOCSIZE  *\/\n@@ -236950,1 +251050,1 @@\n-      \"SELECT sz FROM %Q.'%q_docsize' WHERE id=?\",      \/* LOOKUP_DOCSIZE  *\/\n+      \"SELECT sz%s FROM %Q.'%q_docsize' WHERE id=?\",    \/* LOOKUP_DOCSIZE  *\/\n@@ -236998,0 +251098,13 @@\n+      case FTS5_STMT_REPLACE_DOCSIZE:\n+        zSql = sqlite3_mprintf(azStmt[eStmt], pC->zDb, pC->zName,\n+          (pC->bContentlessDelete ? \",?\" : \"\")\n+        );\n+        break;\n+\n+      case FTS5_STMT_LOOKUP_DOCSIZE:\n+        zSql = sqlite3_mprintf(azStmt[eStmt],\n+            (pC->bContentlessDelete ? \",origin\" : \"\"),\n+            pC->zDb, pC->zName\n+        );\n+        break;\n+\n@@ -237187,3 +251300,5 @@\n-      rc = sqlite3Fts5CreateTable(\n-          pConfig, \"docsize\", \"id INTEGER PRIMARY KEY, sz BLOB\", 0, pzErr\n-      );\n+      const char *zCols = \"id INTEGER PRIMARY KEY, sz BLOB\";\n+      if( pConfig->bContentlessDelete ){\n+        zCols = \"id INTEGER PRIMARY KEY, sz BLOB, origin INTEGER\";\n+      }\n+      rc = sqlite3Fts5CreateTable(pConfig, \"docsize\", zCols, 0, pzErr);\n@@ -237266,1 +251381,1 @@\n-  int rc;                         \/* Return code *\/\n+  int rc = SQLITE_OK;             \/* Return code *\/\n@@ -237282,1 +251397,0 @@\n-  rc = sqlite3Fts5IndexBeginWrite(p->pIndex, 1, iDel);\n@@ -237319,0 +251433,31 @@\n+\/*\n+** This function is called to process a DELETE on a contentless_delete=1\n+** table. It adds the tombstone required to delete the entry with rowid\n+** iDel. If successful, SQLITE_OK is returned. Or, if an error occurs,\n+** an SQLite error code.\n+*\/\n+static int fts5StorageContentlessDelete(Fts5Storage *p, i64 iDel){\n+  i64 iOrigin = 0;\n+  sqlite3_stmt *pLookup = 0;\n+  int rc = SQLITE_OK;\n+\n+  assert( p->pConfig->bContentlessDelete );\n+  assert( p->pConfig->eContent==FTS5_CONTENT_NONE );\n+\n+  \/* Look up the origin of the document in the %_docsize table. Store\n+  ** this in stack variable iOrigin.  *\/\n+  rc = fts5StorageGetStmt(p, FTS5_STMT_LOOKUP_DOCSIZE, &pLookup, 0);\n+  if( rc==SQLITE_OK ){\n+    sqlite3_bind_int64(pLookup, 1, iDel);\n+    if( SQLITE_ROW==sqlite3_step(pLookup) ){\n+      iOrigin = sqlite3_column_int64(pLookup, 1);\n+    }\n+    rc = sqlite3_reset(pLookup);\n+  }\n+\n+  if( rc==SQLITE_OK && iOrigin!=0 ){\n+    rc = sqlite3Fts5IndexContentlessDelete(p->pIndex, iOrigin, iDel);\n+  }\n+\n+  return rc;\n+}\n@@ -237339,4 +251484,11 @@\n-      sqlite3_bind_blob(pReplace, 2, pBuf->p, pBuf->n, SQLITE_STATIC);\n-      sqlite3_step(pReplace);\n-      rc = sqlite3_reset(pReplace);\n-      sqlite3_bind_null(pReplace, 2);\n+      if( p->pConfig->bContentlessDelete ){\n+        i64 iOrigin = 0;\n+        rc = sqlite3Fts5IndexGetOrigin(p->pIndex, &iOrigin);\n+        sqlite3_bind_int64(pReplace, 3, iOrigin);\n+      }\n+      if( rc==SQLITE_OK ){\n+        sqlite3_bind_blob(pReplace, 2, pBuf->p, pBuf->n, SQLITE_STATIC);\n+        sqlite3_step(pReplace);\n+        rc = sqlite3_reset(pReplace);\n+        sqlite3_bind_null(pReplace, 2);\n+      }\n@@ -237406,1 +251558,9 @@\n-    rc = fts5StorageDeleteFromIndex(p, iDel, apVal);\n+    rc = sqlite3Fts5IndexBeginWrite(p->pIndex, 1, iDel);\n+  }\n+\n+  if( rc==SQLITE_OK ){\n+    if( p->pConfig->bContentlessDelete ){\n+      rc = fts5StorageContentlessDelete(p, iDel);\n+    }else{\n+      rc = fts5StorageDeleteFromIndex(p, iDel, apVal);\n+    }\n@@ -237483,1 +251643,1 @@\n-    rc = fts5StorageGetStmt(p, FTS5_STMT_SCAN, &pScan, 0);\n+    rc = fts5StorageGetStmt(p, FTS5_STMT_SCAN, &pScan, pConfig->pzErrmsg);\n@@ -237994,1 +252154,3 @@\n-    p->bTotalsValid = 0;\n+    if( rc==SQLITE_OK ){\n+      p->bTotalsValid = 0;\n+    }\n@@ -238268,0 +252430,6 @@\n+#define FTS5_SKIP_UTF8(zIn) {                               \\\n+  if( ((unsigned char)(*(zIn++)))>=0xc0 ){                              \\\n+    while( (((unsigned char)*zIn) & 0xc0)==0x80 ){ zIn++; }             \\\n+  }                                                    \\\n+}\n+\n@@ -239303,0 +253471,1 @@\n+  int iFoldParam;                 \/* Parameter to pass to Fts5UnicodeFold() *\/\n@@ -239329,0 +253498,1 @@\n+    pNew->iFoldParam = 0;\n@@ -239337,0 +253507,6 @@\n+      }else if( 0==sqlite3_stricmp(azArg[i], \"remove_diacritics\") ){\n+        if( (zArg[0]!='0' && zArg[0]!='1' && zArg[0]!='2') || zArg[1] ){\n+          rc = SQLITE_ERROR;\n+        }else{\n+          pNew->iFoldParam = (zArg[0]!='0') ? 2 : 0;\n+        }\n@@ -239341,0 +253517,5 @@\n+\n+    if( pNew->iFoldParam!=0 && pNew->bFold==0 ){\n+      rc = SQLITE_ERROR;\n+    }\n+\n@@ -239363,0 +253544,2 @@\n+  char *zOut = aBuf;\n+  int ii;\n@@ -239366,0 +253549,1 @@\n+  int aStart[3];                  \/* Input offset of each character in aBuf[] *\/\n@@ -239368,11 +253552,5 @@\n-  while( 1 ){\n-    char *zOut = aBuf;\n-    int iStart = zIn - (const unsigned char*)pText;\n-    const unsigned char *zNext;\n-\n-    READ_UTF8(zIn, zEof, iCode);\n-    if( iCode==0 ) break;\n-    zNext = zIn;\n-    if( zIn<zEof ){\n-      if( p->bFold ) iCode = sqlite3Fts5UnicodeFold(iCode, 0);\n-      WRITE_UTF8(zOut, iCode);\n+\n+  \/* Populate aBuf[] with the characters for the first trigram. *\/\n+  for(ii=0; ii<3; ii++){\n+    do {\n+      aStart[ii] = zIn - (const unsigned char*)pText;\n@@ -239380,7 +253558,21 @@\n-      if( iCode==0 ) break;\n-    }else{\n-      break;\n-    }\n-    if( zIn<zEof ){\n-      if( p->bFold ) iCode = sqlite3Fts5UnicodeFold(iCode, 0);\n-      WRITE_UTF8(zOut, iCode);\n+      if( iCode==0 ) return SQLITE_OK;\n+      if( p->bFold ) iCode = sqlite3Fts5UnicodeFold(iCode, p->iFoldParam);\n+    }while( iCode==0 );\n+    WRITE_UTF8(zOut, iCode);\n+  }\n+\n+  \/* At the start of each iteration of this loop:\n+  **\n+  **  aBuf:      Contains 3 characters. The 3 characters of the next trigram.\n+  **  zOut:      Points to the byte following the last character in aBuf.\n+  **  aStart[3]: Contains the byte offset in the input text corresponding\n+  **             to the start of each of the three characters in the buffer.\n+  *\/\n+  assert( zIn<=zEof );\n+  while( 1 ){\n+    int iNext;                    \/* Start of character following current tri *\/\n+    const char *z1;\n+\n+    \/* Read characters from the input up until the first non-diacritic *\/\n+    do {\n+      iNext = zIn - (const unsigned char*)pText;\n@@ -239389,8 +253581,19 @@\n-      if( p->bFold ) iCode = sqlite3Fts5UnicodeFold(iCode, 0);\n-      WRITE_UTF8(zOut, iCode);\n-    }else{\n-      break;\n-    }\n-    rc = xToken(pCtx, 0, aBuf, zOut-aBuf, iStart, iStart + zOut-aBuf);\n-    if( rc!=SQLITE_OK ) break;\n-    zIn = zNext;\n+      if( p->bFold ) iCode = sqlite3Fts5UnicodeFold(iCode, p->iFoldParam);\n+    }while( iCode==0 );\n+\n+    \/* Pass the current trigram back to fts5 *\/\n+    rc = xToken(pCtx, 0, aBuf, zOut-aBuf, aStart[0], iNext);\n+    if( iCode==0 || rc!=SQLITE_OK ) break;\n+\n+    \/* Remove the first character from buffer aBuf[]. Append the character\n+    ** with codepoint iCode.  *\/\n+    z1 = aBuf;\n+    FTS5_SKIP_UTF8(z1);\n+    memmove(aBuf, z1, zOut - z1);\n+    zOut -= (z1 - aBuf);\n+    WRITE_UTF8(zOut, iCode);\n+\n+    \/* Update the aStart[] array *\/\n+    aStart[0] = aStart[1];\n+    aStart[1] = aStart[2];\n+    aStart[2] = iNext;\n@@ -239419,1 +253622,3 @@\n-    return p->bFold ? FTS5_PATTERN_LIKE : FTS5_PATTERN_GLOB;\n+    if( p->iFoldParam==0 ){\n+      return p->bFold ? FTS5_PATTERN_LIKE : FTS5_PATTERN_GLOB;\n+    }\n@@ -241208,1 +255413,1 @@\n-    f = 0;\n+    f = FTS5INDEX_QUERY_NOTOKENDATA;\n@@ -241362,1 +255567,2 @@\n-    \/* xShadowName   *\/ 0\n+    \/* xShadowName   *\/ 0,\n+    \/* xIntegrity    *\/ 0\n@@ -241474,0 +255680,4 @@\n+  (void)pAux;\n+  (void)argc;\n+  (void)argv;\n+  (void)pzErr;\n@@ -241593,0 +255803,4 @@\n+  (void)idxNum;\n+  (void)idxStr;\n+  (void)argc;\n+  (void)argv;\n@@ -241648,0 +255862,1 @@\n+  (void)tab;\n@@ -241682,0 +255897,1 @@\n+  0                          \/* xIntegrity *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/sqlite3.c","additions":22683,"deletions":8467,"binary":false,"changes":31150,"status":"modified"},{"patch":"@@ -149,3 +149,3 @@\n-#define SQLITE_VERSION        \"3.39.4\"\n-#define SQLITE_VERSION_NUMBER 3039004\n-#define SQLITE_SOURCE_ID      \"2022-09-29 15:55:41 a29f9949895322123f7c38fbe94c649a9d6e6c9cd0c3b41c96d694552f26b309\"\n+#define SQLITE_VERSION        \"3.45.3\"\n+#define SQLITE_VERSION_NUMBER 3045003\n+#define SQLITE_SOURCE_ID      \"2024-04-15 13:34:05 8653b758870e6ef0c98d46b3ace27849054af85da891eb121e9aaa537f1e8355\"\n@@ -423,0 +423,2 @@\n+** <li> The application must not dereference the arrays or string pointers\n+**       passed as the 3rd and 4th callback parameters after it returns.\n@@ -531,0 +533,1 @@\n+#define SQLITE_IOERR_IN_PAGE           (SQLITE_IOERR | (34<<8))\n@@ -566,0 +569,1 @@\n+#define SQLITE_NOTICE_RBU              (SQLITE_NOTICE | (3<<8))\n@@ -673,1 +677,5 @@\n-** of an [sqlite3_io_methods] object.\n+** of an [sqlite3_io_methods] object.  These values are ordered from\n+** lest restrictive to most restrictive.\n+**\n+** The argument to xLock() is always SHARED or higher.  The argument to\n+** xUnlock is either SHARED or NONE.\n@@ -675,5 +683,5 @@\n-#define SQLITE_LOCK_NONE          0\n-#define SQLITE_LOCK_SHARED        1\n-#define SQLITE_LOCK_RESERVED      2\n-#define SQLITE_LOCK_PENDING       3\n-#define SQLITE_LOCK_EXCLUSIVE     4\n+#define SQLITE_LOCK_NONE          0       \/* xUnlock() only *\/\n+#define SQLITE_LOCK_SHARED        1       \/* xLock() or xUnlock() *\/\n+#define SQLITE_LOCK_RESERVED      2       \/* xLock() only *\/\n+#define SQLITE_LOCK_PENDING       3       \/* xLock() only *\/\n+#define SQLITE_LOCK_EXCLUSIVE     4       \/* xLock() only *\/\n@@ -757,1 +765,8 @@\n-** xLock() increases the lock. xUnlock() decreases the lock.\n+** xLock() upgrades the database file lock.  In other words, xLock() moves the\n+** database file lock in the direction NONE toward EXCLUSIVE. The argument to\n+** xLock() is always on of SHARED, RESERVED, PENDING, or EXCLUSIVE, never\n+** SQLITE_LOCK_NONE.  If the database file lock is already at or above the\n+** requested lock, then the call to xLock() is a no-op.\n+** xUnlock() downgrades the database file lock to either SHARED or NONE.\n+*  If the lock is already at or below the requested lock state, then the call\n+** to xUnlock() is a no-op.\n@@ -862,3 +877,2 @@\n-** into an integer that the pArg argument points to. This capability\n-** is used during testing and is only available when the SQLITE_TEST\n-** compile-time option is used.\n+** into an integer that the pArg argument points to.\n+** This capability is only available if SQLite is compiled with [SQLITE_DEBUG].\n@@ -1168,1 +1182,0 @@\n-** <\/ul>\n@@ -1181,1 +1194,0 @@\n-** <\/ul>\n@@ -1184,1 +1196,8 @@\n-** Used by the cksmvfs VFS module only.\n+** The [SQLITE_FCNTL_CKSM_FILE] opcode is for use internally by the\n+** [checksum VFS shim] only.\n+**\n+** <li>[[SQLITE_FCNTL_RESET_CACHE]]\n+** If there is currently no transaction open on the database, and the\n+** database is not a temp db, then the [SQLITE_FCNTL_RESET_CACHE] file-control\n+** purges the contents of the in-memory page cache. If there is an open\n+** transaction, or if the db is a temp-db, this opcode is a no-op, not an error.\n@@ -1227,0 +1246,1 @@\n+#define SQLITE_FCNTL_RESET_CACHE            42\n@@ -1256,0 +1276,20 @@\n+\/*\n+** CAPI3REF: File Name\n+**\n+** Type [sqlite3_filename] is used by SQLite to pass filenames to the\n+** xOpen method of a [VFS]. It may be cast to (const char*) and treated\n+** as a normal, nul-terminated, UTF-8 buffer containing the filename, but\n+** may also be passed to special APIs such as:\n+**\n+** <ul>\n+** <li>  sqlite3_filename_database()\n+** <li>  sqlite3_filename_journal()\n+** <li>  sqlite3_filename_wal()\n+** <li>  sqlite3_uri_parameter()\n+** <li>  sqlite3_uri_boolean()\n+** <li>  sqlite3_uri_int64()\n+** <li>  sqlite3_uri_key()\n+** <\/ul>\n+*\/\n+typedef const char *sqlite3_filename;\n+\n@@ -1434,1 +1474,1 @@\n-  int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,\n+  int (*xOpen)(sqlite3_vfs*, sqlite3_filename zName, sqlite3_file*,\n@@ -1621,8 +1661,0 @@\n-** The sqlite3_config() interface\n-** may only be invoked prior to library initialization using\n-** [sqlite3_initialize()] or after shutdown by [sqlite3_shutdown()].\n-** ^If sqlite3_config() is called after [sqlite3_initialize()] and before\n-** [sqlite3_shutdown()] then it will return SQLITE_MISUSE.\n-** Note, however, that ^sqlite3_config() can be called as part of the\n-** implementation of an application-defined [sqlite3_os_init()].\n-**\n@@ -1635,0 +1667,11 @@\n+** For most configuration options, the sqlite3_config() interface\n+** may only be invoked prior to library initialization using\n+** [sqlite3_initialize()] or after shutdown by [sqlite3_shutdown()].\n+** The exceptional configuration options that may be invoked at any time\n+** are called \"anytime configuration options\".\n+** ^If sqlite3_config() is called after [sqlite3_initialize()] and before\n+** [sqlite3_shutdown()] with a first argument that is not an anytime\n+** configuration option, then the sqlite3_config() call will return SQLITE_MISUSE.\n+** Note, however, that ^sqlite3_config() can be called as part of the\n+** implementation of an application-defined [sqlite3_os_init()].\n+**\n@@ -1742,0 +1785,17 @@\n+** Most of the configuration options for sqlite3_config()\n+** will only work if invoked prior to [sqlite3_initialize()] or after\n+** [sqlite3_shutdown()].  The few exceptions to this rule are called\n+** \"anytime configuration options\".\n+** ^Calling [sqlite3_config()] with a first argument that is not an\n+** anytime configuration option in between calls to [sqlite3_initialize()] and\n+** [sqlite3_shutdown()] is a no-op that returns SQLITE_MISUSE.\n+**\n+** The set of anytime configuration options can change (by insertions\n+** and\/or deletions) from one release of SQLite to the next.\n+** As of SQLite version 3.42.0, the complete set of anytime configuration\n+** options is:\n+** <ul>\n+** <li> SQLITE_CONFIG_LOG\n+** <li> SQLITE_CONFIG_PCACHE_HDRSZ\n+** <\/ul>\n+**\n@@ -2072,1 +2132,1 @@\n-** negative value for this option restores the default behaviour.\n+** negative value for this option restores the default behavior.\n@@ -2086,0 +2146,16 @@\n+**\n+** [[SQLITE_CONFIG_ROWID_IN_VIEW]]\n+** <dt>SQLITE_CONFIG_ROWID_IN_VIEW\n+** <dd>The SQLITE_CONFIG_ROWID_IN_VIEW option enables or disables the ability\n+** for VIEWs to have a ROWID.  The capability can only be enabled if SQLite is\n+** compiled with -DSQLITE_ALLOW_ROWID_IN_VIEW, in which case the capability\n+** defaults to on.  This configuration option queries the current setting or\n+** changes the setting to off or on.  The argument is a pointer to an integer.\n+** If that integer initially holds a value of 1, then the ability for VIEWs to\n+** have ROWIDs is activated.  If the integer initially holds zero, then the\n+** ability is deactivated.  Any other initial value for the integer leaves the\n+** setting unchanged.  After changes, if any, the integer is written with\n+** a 1 or 0, if the ability for VIEWs to have ROWIDs is on or off.  If SQLite\n+** is compiled without -DSQLITE_ALLOW_ROWID_IN_VIEW (which is the usual and\n+** recommended case) then the integer is always filled with zero, regardless\n+** if its initial value.\n@@ -2088,19 +2164,19 @@\n-#define SQLITE_CONFIG_SINGLETHREAD  1  \/* nil *\/\n-#define SQLITE_CONFIG_MULTITHREAD   2  \/* nil *\/\n-#define SQLITE_CONFIG_SERIALIZED    3  \/* nil *\/\n-#define SQLITE_CONFIG_MALLOC        4  \/* sqlite3_mem_methods* *\/\n-#define SQLITE_CONFIG_GETMALLOC     5  \/* sqlite3_mem_methods* *\/\n-#define SQLITE_CONFIG_SCRATCH       6  \/* No longer used *\/\n-#define SQLITE_CONFIG_PAGECACHE     7  \/* void*, int sz, int N *\/\n-#define SQLITE_CONFIG_HEAP          8  \/* void*, int nByte, int min *\/\n-#define SQLITE_CONFIG_MEMSTATUS     9  \/* boolean *\/\n-#define SQLITE_CONFIG_MUTEX        10  \/* sqlite3_mutex_methods* *\/\n-#define SQLITE_CONFIG_GETMUTEX     11  \/* sqlite3_mutex_methods* *\/\n-\/* previously SQLITE_CONFIG_CHUNKALLOC 12 which is now unused. *\/\n-#define SQLITE_CONFIG_LOOKASIDE    13  \/* int int *\/\n-#define SQLITE_CONFIG_PCACHE       14  \/* no-op *\/\n-#define SQLITE_CONFIG_GETPCACHE    15  \/* no-op *\/\n-#define SQLITE_CONFIG_LOG          16  \/* xFunc, void* *\/\n-#define SQLITE_CONFIG_URI          17  \/* int *\/\n-#define SQLITE_CONFIG_PCACHE2      18  \/* sqlite3_pcache_methods2* *\/\n-#define SQLITE_CONFIG_GETPCACHE2   19  \/* sqlite3_pcache_methods2* *\/\n+#define SQLITE_CONFIG_SINGLETHREAD         1  \/* nil *\/\n+#define SQLITE_CONFIG_MULTITHREAD          2  \/* nil *\/\n+#define SQLITE_CONFIG_SERIALIZED           3  \/* nil *\/\n+#define SQLITE_CONFIG_MALLOC               4  \/* sqlite3_mem_methods* *\/\n+#define SQLITE_CONFIG_GETMALLOC            5  \/* sqlite3_mem_methods* *\/\n+#define SQLITE_CONFIG_SCRATCH              6  \/* No longer used *\/\n+#define SQLITE_CONFIG_PAGECACHE            7  \/* void*, int sz, int N *\/\n+#define SQLITE_CONFIG_HEAP                 8  \/* void*, int nByte, int min *\/\n+#define SQLITE_CONFIG_MEMSTATUS            9  \/* boolean *\/\n+#define SQLITE_CONFIG_MUTEX               10  \/* sqlite3_mutex_methods* *\/\n+#define SQLITE_CONFIG_GETMUTEX            11  \/* sqlite3_mutex_methods* *\/\n+\/* previously SQLITE_CONFIG_CHUNKALLOC    12 which is now unused. *\/\n+#define SQLITE_CONFIG_LOOKASIDE           13  \/* int int *\/\n+#define SQLITE_CONFIG_PCACHE              14  \/* no-op *\/\n+#define SQLITE_CONFIG_GETPCACHE           15  \/* no-op *\/\n+#define SQLITE_CONFIG_LOG                 16  \/* xFunc, void* *\/\n+#define SQLITE_CONFIG_URI                 17  \/* int *\/\n+#define SQLITE_CONFIG_PCACHE2             18  \/* sqlite3_pcache_methods2* *\/\n+#define SQLITE_CONFIG_GETPCACHE2          19  \/* sqlite3_pcache_methods2* *\/\n@@ -2108,2 +2184,2 @@\n-#define SQLITE_CONFIG_SQLLOG       21  \/* xSqllog, void* *\/\n-#define SQLITE_CONFIG_MMAP_SIZE    22  \/* sqlite3_int64, sqlite3_int64 *\/\n+#define SQLITE_CONFIG_SQLLOG              21  \/* xSqllog, void* *\/\n+#define SQLITE_CONFIG_MMAP_SIZE           22  \/* sqlite3_int64, sqlite3_int64 *\/\n@@ -2117,0 +2193,1 @@\n+#define SQLITE_CONFIG_ROWID_IN_VIEW       30  \/* int* *\/\n@@ -2150,1 +2227,1 @@\n-** [sqlite3_db_status](D,[SQLITE_CONFIG_LOOKASIDE],...) is zero.\n+** [sqlite3_db_status](D,[SQLITE_DBSTATUS_LOOKASIDE_USED],...) is zero.\n@@ -2247,1 +2324,1 @@\n-** override this behaviour. The first parameter passed to this operation\n+** override this behavior. The first parameter passed to this operation\n@@ -2300,2 +2377,6 @@\n-** process requires the use of this obscure API and multiple steps to help\n-** ensure that it does not happen by accident.\n+** process requires the use of this obscure API and multiple steps to\n+** help ensure that it does not happen by accident. Because this\n+** feature must be capable of resetting corrupt databases, and\n+** shutting down virtual tables may require access to that corrupt\n+** storage, the library must abandon any installed virtual tables\n+** without calling their xDestroy() methods.\n@@ -2312,0 +2393,1 @@\n+** <li> The [PRAGMA schema_version=N] statement.\n@@ -2339,1 +2421,1 @@\n-** <dt>SQLITE_DBCONFIG_DQS_DML<\/td>\n+** <dt>SQLITE_DBCONFIG_DQS_DML<\/dt>\n@@ -2348,1 +2430,1 @@\n-** <dt>SQLITE_DBCONFIG_DQS_DDL<\/td>\n+** <dt>SQLITE_DBCONFIG_DQS_DDL<\/dt>\n@@ -2357,1 +2439,1 @@\n-** <dt>SQLITE_DBCONFIG_TRUSTED_SCHEMA<\/td>\n+** <dt>SQLITE_DBCONFIG_TRUSTED_SCHEMA<\/dt>\n@@ -2377,1 +2459,1 @@\n-** <dt>SQLITE_DBCONFIG_LEGACY_FILE_FORMAT<\/td>\n+** <dt>SQLITE_DBCONFIG_LEGACY_FILE_FORMAT<\/dt>\n@@ -2386,1 +2468,1 @@\n-** is now scarcely any need to generated database files that are compatible\n+** is now scarcely any need to generate database files that are compatible\n@@ -2395,1 +2477,32 @@\n-** either generated columns or decending indexes.\n+** either generated columns or descending indexes.\n+** <\/dd>\n+**\n+** [[SQLITE_DBCONFIG_STMT_SCANSTATUS]]\n+** <dt>SQLITE_DBCONFIG_STMT_SCANSTATUS<\/dt>\n+** <dd>The SQLITE_DBCONFIG_STMT_SCANSTATUS option is only useful in\n+** SQLITE_ENABLE_STMT_SCANSTATUS builds. In this case, it sets or clears\n+** a flag that enables collection of the sqlite3_stmt_scanstatus_v2()\n+** statistics. For statistics to be collected, the flag must be set on\n+** the database handle both when the SQL statement is prepared and when it\n+** is stepped. The flag is set (collection of statistics is enabled)\n+** by default.  This option takes two arguments: an integer and a pointer to\n+** an integer..  The first argument is 1, 0, or -1 to enable, disable, or\n+** leave unchanged the statement scanstatus option.  If the second argument\n+** is not NULL, then the value of the statement scanstatus setting after\n+** processing the first argument is written into the integer that the second\n+** argument points to.\n+** <\/dd>\n+**\n+** [[SQLITE_DBCONFIG_REVERSE_SCANORDER]]\n+** <dt>SQLITE_DBCONFIG_REVERSE_SCANORDER<\/dt>\n+** <dd>The SQLITE_DBCONFIG_REVERSE_SCANORDER option changes the default order\n+** in which tables and indexes are scanned so that the scans start at the end\n+** and work toward the beginning rather than starting at the beginning and\n+** working toward the end. Setting SQLITE_DBCONFIG_REVERSE_SCANORDER is the\n+** same as setting [PRAGMA reverse_unordered_selects].  This option takes\n+** two arguments which are an integer and a pointer to an integer.  The first\n+** argument is 1, 0, or -1 to enable, disable, or leave unchanged the\n+** reverse scan order flag, respectively.  If the second argument is not NULL,\n+** then 0 or 1 is written into the integer that the second argument points to\n+** depending on if the reverse scan order flag is set after processing the\n+** first argument.\n@@ -2397,0 +2510,1 @@\n+**\n@@ -2417,1 +2531,3 @@\n-#define SQLITE_DBCONFIG_MAX                   1017 \/* Largest DBCONFIG *\/\n+#define SQLITE_DBCONFIG_STMT_SCANSTATUS       1018 \/* int int* *\/\n+#define SQLITE_DBCONFIG_REVERSE_SCANORDER     1019 \/* int int* *\/\n+#define SQLITE_DBCONFIG_MAX                   1019 \/* Largest DBCONFIG *\/\n@@ -2639,0 +2755,4 @@\n+**\n+** ^The [sqlite3_is_interrupted(D)] interface can be used to determine whether\n+** or not an interrupt is currently in effect for [database connection] D.\n+** It returns 1 if an interrupt is currently in effect, or 0 otherwise.\n@@ -2641,0 +2761,1 @@\n+SQLITE_API int sqlite3_is_interrupted(sqlite3*);\n@@ -3258,2 +3379,2 @@\n-** X argument points to a 64-bit integer which is the estimated of\n-** the number of nanosecond that the prepared statement took to run.\n+** X argument points to a 64-bit integer which is approximately\n+** the number of nanoseconds that the prepared statement took to run.\n@@ -3291,2 +3412,4 @@\n-** ^Each call to either sqlite3_trace() or sqlite3_trace_v2() overrides\n-** (cancels) any prior calls to sqlite3_trace() or sqlite3_trace_v2().\n+** ^Each call to either sqlite3_trace(D,X,P) or sqlite3_trace_v2(D,M,X,P)\n+** overrides (cancels) all prior calls to sqlite3_trace(D,X,P) or\n+** sqlite3_trace_v2(D,M,X,P) for the [database connection] D.  Each\n+** database connection may have at most one trace callback.\n@@ -3322,1 +3445,1 @@\n-** [sqlite3_exec()], [sqlite3_step()] and [sqlite3_get_table()] for\n+** [sqlite3_step()] and [sqlite3_prepare()] and similar for\n@@ -3347,0 +3470,7 @@\n+** The progress handler callback would originally only be invoked from the\n+** bytecode engine.  It still might be invoked during [sqlite3_prepare()]\n+** and similar because those routines might force a reparse of the schema\n+** which involves running the bytecode engine.  However, beginning with\n+** SQLite version 3.41.0, the progress handler callback might also be\n+** invoked directly from [sqlite3_prepare()] while analyzing and generating\n+** code for complex queries.\n@@ -3383,2 +3513,2 @@\n-** <dd>The database is opened in read-only mode.  If the database does not\n-** already exist, an error is returned.<\/dd>)^\n+** <dd>The database is opened in read-only mode.  If the database does\n+** not already exist, an error is returned.<\/dd>)^\n@@ -3387,3 +3517,8 @@\n-** <dd>The database is opened for reading and writing if possible, or reading\n-** only if the file is write protected by the operating system.  In either\n-** case the database must already exist, otherwise an error is returned.<\/dd>)^\n+** <dd>The database is opened for reading and writing if possible, or\n+** reading only if the file is write protected by the operating\n+** system.  In either case the database must already exist, otherwise\n+** an error is returned.  For historical reasons, if opening in\n+** read-write mode fails due to OS-level permissions, an attempt is\n+** made to open it in read-only mode. [sqlite3_db_readonly()] can be\n+** used to determine whether the database is actually\n+** read-write.<\/dd>)^\n@@ -3427,0 +3562,3 @@\n+** The [use of shared cache mode is discouraged] and hence shared cache\n+** capabilities may be omitted from many builds of SQLite.  In such cases,\n+** this option is a no-op.\n@@ -3442,1 +3580,1 @@\n-** <dd>The database filename is not allowed to be a symbolic link<\/dd>\n+** <dd>The database filename is not allowed to contain a symbolic link<\/dd>\n@@ -3646,1 +3784,1 @@\n-** passed into the xOpen() method of a VFS implemention, or\n+** passed into the xOpen() method of a VFS implementation, or\n@@ -3701,4 +3839,4 @@\n-SQLITE_API const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam);\n-SQLITE_API int sqlite3_uri_boolean(const char *zFile, const char *zParam, int bDefault);\n-SQLITE_API sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int64);\n-SQLITE_API const char *sqlite3_uri_key(const char *zFilename, int N);\n+SQLITE_API const char *sqlite3_uri_parameter(sqlite3_filename z, const char *zParam);\n+SQLITE_API int sqlite3_uri_boolean(sqlite3_filename z, const char *zParam, int bDefault);\n+SQLITE_API sqlite3_int64 sqlite3_uri_int64(sqlite3_filename, const char*, sqlite3_int64);\n+SQLITE_API const char *sqlite3_uri_key(sqlite3_filename z, int N);\n@@ -3733,3 +3871,3 @@\n-SQLITE_API const char *sqlite3_filename_database(const char*);\n-SQLITE_API const char *sqlite3_filename_journal(const char*);\n-SQLITE_API const char *sqlite3_filename_wal(const char*);\n+SQLITE_API const char *sqlite3_filename_database(sqlite3_filename);\n+SQLITE_API const char *sqlite3_filename_journal(sqlite3_filename);\n+SQLITE_API const char *sqlite3_filename_wal(sqlite3_filename);\n@@ -3759,1 +3897,1 @@\n-** These interfces are provided for use by [VFS shim] implementations and\n+** These interfaces are provided for use by [VFS shim] implementations and\n@@ -3801,1 +3939,1 @@\n-SQLITE_API char *sqlite3_create_filename(\n+SQLITE_API sqlite3_filename sqlite3_create_filename(\n@@ -3808,1 +3946,1 @@\n-SQLITE_API void sqlite3_free_filename(char*);\n+SQLITE_API void sqlite3_free_filename(sqlite3_filename);\n@@ -3838,1 +3976,3 @@\n-** text that describes the error, as either UTF-8 or UTF-16 respectively.\n+** text that describes the error, as either UTF-8 or UTF-16 respectively,\n+** or NULL if no error message is available.\n+** (See how SQLite handles [invalid UTF] for exceptions to this rule.)\n@@ -3844,2 +3984,3 @@\n-** ^The sqlite3_errstr() interface returns the English-language text\n-** that describes the [result code], as UTF-8.\n+** ^The sqlite3_errstr(E) interface returns the English-language text\n+** that describes the [result code] E, as UTF-8, or NULL if E is not an\n+** result code for which a text error message is available.\n@@ -4306,0 +4447,35 @@\n+\/*\n+** CAPI3REF: Change The EXPLAIN Setting For A Prepared Statement\n+** METHOD: sqlite3_stmt\n+**\n+** The sqlite3_stmt_explain(S,E) interface changes the EXPLAIN\n+** setting for [prepared statement] S.  If E is zero, then S becomes\n+** a normal prepared statement.  If E is 1, then S behaves as if\n+** its SQL text began with \"[EXPLAIN]\".  If E is 2, then S behaves as if\n+** its SQL text began with \"[EXPLAIN QUERY PLAN]\".\n+**\n+** Calling sqlite3_stmt_explain(S,E) might cause S to be reprepared.\n+** SQLite tries to avoid a reprepare, but a reprepare might be necessary\n+** on the first transition into EXPLAIN or EXPLAIN QUERY PLAN mode.\n+**\n+** Because of the potential need to reprepare, a call to\n+** sqlite3_stmt_explain(S,E) will fail with SQLITE_ERROR if S cannot be\n+** reprepared because it was created using [sqlite3_prepare()] instead of\n+** the newer [sqlite3_prepare_v2()] or [sqlite3_prepare_v3()] interfaces and\n+** hence has no saved SQL text with which to reprepare.\n+**\n+** Changing the explain setting for a prepared statement does not change\n+** the original SQL text for the statement.  Hence, if the SQL text originally\n+** began with EXPLAIN or EXPLAIN QUERY PLAN, but sqlite3_stmt_explain(S,0)\n+** is called to convert the statement into an ordinary statement, the EXPLAIN\n+** or EXPLAIN QUERY PLAN keywords will still appear in the sqlite3_sql(S)\n+** output, even though the statement now acts like a normal SQL statement.\n+**\n+** This routine returns SQLITE_OK if the explain mode is successfully\n+** changed, or an error code if the explain mode could not be changed.\n+** The explain mode cannot be changed while a statement is active.\n+** Hence, it is good practice to call [sqlite3_reset(S)]\n+** immediately prior to calling sqlite3_stmt_explain(S,E).\n+*\/\n+SQLITE_API int sqlite3_stmt_explain(sqlite3_stmt *pStmt, int eMode);\n+\n@@ -4469,1 +4645,1 @@\n-** ^ (2) The special constant, [SQLITE_STATIC], may be passsed to indicate that\n+** ^ (2) The special constant, [SQLITE_STATIC], may be passed to indicate that\n@@ -5148,4 +5324,6 @@\n-** ^If the most recent call to [sqlite3_step(S)] for the\n-** [prepared statement] S returned [SQLITE_ROW] or [SQLITE_DONE],\n-** or if [sqlite3_step(S)] has never before been called on S,\n-** then [sqlite3_reset(S)] returns [SQLITE_OK].\n+** ^The return code from [sqlite3_reset(S)] indicates whether or not\n+** the previous evaluation of prepared statement S completed successfully.\n+** ^If [sqlite3_step(S)] has never before been called on S or if\n+** [sqlite3_step(S)] has not been called since the previous call\n+** to [sqlite3_reset(S)], then [sqlite3_reset(S)] will return\n+** [SQLITE_OK].\n@@ -5156,0 +5334,10 @@\n+** ^The [sqlite3_reset(S)] interface might also return an [error code]\n+** if there were no prior errors but the process of resetting\n+** the prepared statement caused a new error. ^For example, if an\n+** [INSERT] statement with a [RETURNING] clause is only stepped one time,\n+** that one call to [sqlite3_step(S)] might return SQLITE_ROW but\n+** the overall statement might still fail and the [sqlite3_reset(S)] call\n+** might return SQLITE_BUSY if locking constraints prevent the\n+** database change from committing.  Therefore, it is important that\n+** applications check the return code from [sqlite3_reset(S)] even if\n+** no prior call to [sqlite3_step(S)] indicated a problem.\n@@ -5162,0 +5350,1 @@\n+\n@@ -5367,4 +5556,15 @@\n-** The SQLITE_DIRECTONLY flags is a security feature which is recommended\n-** for all [application-defined SQL functions], and especially for functions\n-** that have side-effects or that could potentially leak sensitive\n-** information.\n+** <p>\n+** The SQLITE_DIRECTONLY flag is recommended for any\n+** [application-defined SQL function]\n+** that has side-effects or that could potentially leak sensitive information.\n+** This will prevent attacks in which an application is tricked\n+** into using a database file that has had its schema surreptitiously\n+** modified to invoke the application-defined function in ways that are\n+** harmful.\n+** <p>\n+** Some people say it is good practice to set SQLITE_DIRECTONLY on all\n+** [application-defined SQL functions], regardless of whether or not they\n+** are security sensitive, as doing so prevents those functions from being used\n+** inside of the database schema, and thus ensures that the database\n+** can be inspected and modified using generic tools (such as the [CLI])\n+** that do not have access to the application-defined functions.\n@@ -5397,1 +5597,1 @@\n-** The SQLITE_SUBTYPE flag indicates to SQLite that a function may call\n+** The SQLITE_SUBTYPE flag indicates to SQLite that a function might call\n@@ -5399,5 +5599,19 @@\n-** Specifying this flag makes no difference for scalar or aggregate user\n-** functions. However, if it is not specified for a user-defined window\n-** function, then any sub-types belonging to arguments passed to the window\n-** function may be discarded before the window function is called (i.e.\n-** sqlite3_value_subtype() will always return 0).\n+** This flag instructs SQLite to omit some corner-case optimizations that\n+** might disrupt the operation of the [sqlite3_value_subtype()] function,\n+** causing it to return zero rather than the correct subtype().\n+** SQL functions that invokes [sqlite3_value_subtype()] should have this\n+** property.  If the SQLITE_SUBTYPE property is omitted, then the return\n+** value from [sqlite3_value_subtype()] might sometimes be zero even though\n+** a non-zero subtype was specified by the function argument expression.\n+**\n+** [[SQLITE_RESULT_SUBTYPE]] <dt>SQLITE_RESULT_SUBTYPE<\/dt><dd>\n+** The SQLITE_RESULT_SUBTYPE flag indicates to SQLite that a function might call\n+** [sqlite3_result_subtype()] to cause a sub-type to be associated with its\n+** result.\n+** Every function that invokes [sqlite3_result_subtype()] should have this\n+** property.  If it does not, then the call to [sqlite3_result_subtype()]\n+** might become a no-op if the function is used as term in an\n+** [expression index].  On the other hand, SQL functions that never invoke\n+** [sqlite3_result_subtype()] should avoid setting this property, as the\n+** purpose of this property is to disable certain optimizations that are\n+** incompatible with subtypes.\n@@ -5411,0 +5625,1 @@\n+#define SQLITE_RESULT_SUBTYPE   0x001000000\n@@ -5576,0 +5791,22 @@\n+\/*\n+** CAPI3REF: Report the internal text encoding state of an sqlite3_value object\n+** METHOD: sqlite3_value\n+**\n+** ^(The sqlite3_value_encoding(X) interface returns one of [SQLITE_UTF8],\n+** [SQLITE_UTF16BE], or [SQLITE_UTF16LE] according to the current text encoding\n+** of the value X, assuming that X has type TEXT.)^  If sqlite3_value_type(X)\n+** returns something other than SQLITE_TEXT, then the return value from\n+** sqlite3_value_encoding(X) is meaningless.  ^Calls to\n+** [sqlite3_value_text(X)], [sqlite3_value_text16(X)], [sqlite3_value_text16be(X)],\n+** [sqlite3_value_text16le(X)], [sqlite3_value_bytes(X)], or\n+** [sqlite3_value_bytes16(X)] might change the encoding of the value X and\n+** thus change the return from subsequent calls to sqlite3_value_encoding(X).\n+**\n+** This routine is intended for used by applications that test and validate\n+** the SQLite implementation.  This routine is inquiring about the opaque\n+** internal state of an [sqlite3_value] object.  Ordinary applications should\n+** not need to know what the internal state of an sqlite3_value object is and\n+** hence should not need to use this interface.\n+*\/\n+SQLITE_API int sqlite3_value_encoding(sqlite3_value*);\n+\n@@ -5585,0 +5822,6 @@\n+**\n+** Every [application-defined SQL function] that invoke this interface\n+** should include the [SQLITE_SUBTYPE] property in the text\n+** encoding argument when the function is [sqlite3_create_function|registered].\n+** If the [SQLITE_SUBTYPE] property is omitted, then sqlite3_value_subtype()\n+** might return zero instead of the upstream subtype in some corner cases.\n@@ -5628,1 +5871,1 @@\n-** allocate error occurs.\n+** allocation error occurs.\n@@ -5683,6 +5926,6 @@\n-** associate metadata with argument values. If the same value is passed to\n-** multiple invocations of the same SQL function during query execution, under\n-** some circumstances the associated metadata may be preserved.  An example\n-** of where this might be useful is in a regular-expression matching\n-** function. The compiled version of the regular expression can be stored as\n-** metadata associated with the pattern string.\n+** associate auxiliary data with argument values. If the same argument\n+** value is passed to multiple invocations of the same SQL function during\n+** query execution, under some circumstances the associated auxiliary data\n+** might be preserved.  An example of where this might be useful is in a\n+** regular-expression matching function. The compiled version of the regular\n+** expression can be stored as auxiliary data associated with the pattern string.\n@@ -5693,1 +5936,1 @@\n-** ^The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadata\n+** ^The sqlite3_get_auxdata(C,N) interface returns a pointer to the auxiliary data\n@@ -5696,1 +5939,1 @@\n-** function argument.  ^If there is no metadata\n+** function argument.  ^If there is no auxiliary data\n@@ -5700,2 +5943,2 @@\n-** ^The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-th\n-** argument of the application-defined function.  ^Subsequent\n+** ^The sqlite3_set_auxdata(C,N,P,X) interface saves P as auxiliary data for the\n+** N-th argument of the application-defined function.  ^Subsequent\n@@ -5703,2 +5946,2 @@\n-** sqlite3_set_auxdata(C,N,P,X) call if the metadata is still valid or\n-** NULL if the metadata has been discarded.\n+** sqlite3_set_auxdata(C,N,P,X) call if the auxiliary data is still valid or\n+** NULL if the auxiliary data has been discarded.\n@@ -5707,2 +5950,2 @@\n-** once, when the metadata is discarded.\n-** SQLite is free to discard the metadata at any time, including: <ul>\n+** once, when the auxiliary data is discarded.\n+** SQLite is free to discard the auxiliary data at any time, including: <ul>\n@@ -5715,1 +5958,4 @@\n-**      allocation error occurs.)^ <\/ul>\n+**      allocation error occurs.)^\n+** <li> ^(during the original sqlite3_set_auxdata() call if the function\n+**      is evaluated during query planning instead of during query execution,\n+**      as sometimes happens with [SQLITE_ENABLE_STAT4].)^ <\/ul>\n@@ -5717,1 +5963,1 @@\n-** Note the last bullet in particular.  The destructor X in\n+** Note the last two bullets in particular.  The destructor X in\n@@ -5722,3 +5968,8 @@\n-** sqlite3_set_auxdata() has been called.\n-**\n-** ^(In practice, metadata is preserved between function calls for\n+** sqlite3_set_auxdata() has been called.  Furthermore, a call to\n+** sqlite3_get_auxdata() that occurs immediately after a corresponding call\n+** to sqlite3_set_auxdata() might still return NULL if an out-of-memory\n+** condition occurred during the sqlite3_set_auxdata() call or if the\n+** function is being evaluated during query planning rather than during\n+** query execution.\n+**\n+** ^(In practice, auxiliary data is preserved between function calls for\n@@ -5734,0 +5985,2 @@\n+**\n+** See also: [sqlite3_get_clientdata()] and [sqlite3_set_clientdata()].\n@@ -5738,0 +5991,55 @@\n+\/*\n+** CAPI3REF: Database Connection Client Data\n+** METHOD: sqlite3\n+**\n+** These functions are used to associate one or more named pointers\n+** with a [database connection].\n+** A call to sqlite3_set_clientdata(D,N,P,X) causes the pointer P\n+** to be attached to [database connection] D using name N.  Subsequent\n+** calls to sqlite3_get_clientdata(D,N) will return a copy of pointer P\n+** or a NULL pointer if there were no prior calls to\n+** sqlite3_set_clientdata() with the same values of D and N.\n+** Names are compared using strcmp() and are thus case sensitive.\n+**\n+** If P and X are both non-NULL, then the destructor X is invoked with\n+** argument P on the first of the following occurrences:\n+** <ul>\n+** <li> An out-of-memory error occurs during the call to\n+**      sqlite3_set_clientdata() which attempts to register pointer P.\n+** <li> A subsequent call to sqlite3_set_clientdata(D,N,P,X) is made\n+**      with the same D and N parameters.\n+** <li> The database connection closes.  SQLite does not make any guarantees\n+**      about the order in which destructors are called, only that all\n+**      destructors will be called exactly once at some point during the\n+**      database connection closing process.\n+** <\/ul>\n+**\n+** SQLite does not do anything with client data other than invoke\n+** destructors on the client data at the appropriate time.  The intended\n+** use for client data is to provide a mechanism for wrapper libraries\n+** to store additional information about an SQLite database connection.\n+**\n+** There is no limit (other than available memory) on the number of different\n+** client data pointers (with different names) that can be attached to a\n+** single database connection.  However, the implementation is optimized\n+** for the case of having only one or two different client data names.\n+** Applications and wrapper libraries are discouraged from using more than\n+** one client data name each.\n+**\n+** There is no way to enumerate the client data pointers\n+** associated with a database connection.  The N parameter can be thought\n+** of as a secret key such that only code that knows the secret key is able\n+** to access the associated data.\n+**\n+** Security Warning:  These interfaces should not be exposed in scripting\n+** languages or in other circumstances where it might be possible for an\n+** an attacker to invoke them.  Any agent that can invoke these interfaces\n+** can probably also take control of the process.\n+**\n+** Database connection client data is only available for SQLite\n+** version 3.44.0 ([dateof:3.44.0]) and later.\n+**\n+** See also: [sqlite3_set_auxdata()] and [sqlite3_get_auxdata()].\n+*\/\n+SQLITE_API void *sqlite3_get_clientdata(sqlite3*,const char*);\n+SQLITE_API int sqlite3_set_clientdata(sqlite3*, const char*, void*, void(*)(void*));\n@@ -5833,3 +6141,4 @@\n-** ^If the 3rd parameter to the sqlite3_result_text* interfaces\n-** is negative, then SQLite takes result text from the 2nd parameter\n-** through the first zero character.\n+** ^If the 3rd parameter to any of the sqlite3_result_text* interfaces\n+** other than sqlite3_result_text64() is negative, then SQLite computes\n+** the string length itself by searching the 2nd parameter for the first\n+** zero character.\n@@ -5938,0 +6247,14 @@\n+**\n+** Every [application-defined SQL function] that invokes this interface\n+** should include the [SQLITE_RESULT_SUBTYPE] property in its\n+** text encoding argument when the SQL function is\n+** [sqlite3_create_function|registered].  If the [SQLITE_RESULT_SUBTYPE]\n+** property is omitted from the function that invokes sqlite3_result_subtype(),\n+** then in some cases the sqlite3_result_subtype() might fail to set\n+** the result subtype.\n+**\n+** If SQLite is compiled with -DSQLITE_STRICT_SUBTYPE=1, then any\n+** SQL function that invokes the sqlite3_result_subtype() interface\n+** and that does not have the SQLITE_RESULT_SUBTYPE property will raise\n+** an error.  Future versions of SQLite might enable -DSQLITE_STRICT_SUBTYPE=1\n+** by default.\n@@ -6109,0 +6432,7 @@\n+**\n+** If a negative argument is passed to sqlite3_sleep() the results vary by\n+** VFS and operating system.  Some system treat a negative argument as an\n+** instruction to sleep forever.  Others understand it to mean do not sleep\n+** at all. ^In SQLite version 3.42.0 and later, a negative\n+** argument passed into sqlite3_sleep() is changed to zero before it is relayed\n+** down into the xSleep method of the VFS.\n@@ -6331,1 +6661,1 @@\n-SQLITE_API const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName);\n+SQLITE_API sqlite3_filename sqlite3_db_filename(sqlite3 *db, const char *zDbName);\n@@ -6362,1 +6692,1 @@\n-** CAPI3REF: Allowed return values from [sqlite3_txn_state()]\n+** CAPI3REF: Allowed return values from sqlite3_txn_state()\n@@ -6468,1 +6798,1 @@\n-** the the size of the database file in pages, the number of free pages,\n+** the size of the database file in pages, the number of free pages,\n@@ -6494,1 +6824,1 @@\n-** then the autovacuum steps callback is cancelled.  The return value\n+** then the autovacuum steps callback is canceled.  The return value\n@@ -6589,0 +6919,5 @@\n+** This interface is omitted if SQLite is compiled with\n+** [-DSQLITE_OMIT_SHARED_CACHE].  The [-DSQLITE_OMIT_SHARED_CACHE]\n+** compile-time option is recommended because the\n+** [use of shared cache mode is discouraged].\n+**\n@@ -6687,1 +7022,1 @@\n-** the the soft heap limit is set to the value of the hard heap limit.\n+** the soft heap limit is set to the value of the hard heap limit.\n@@ -6948,9 +7283,0 @@\n-\/*\n-** The interface to the virtual-table mechanism is currently considered\n-** to be experimental.  The interface might change in incompatible ways.\n-** If this is a problem for you, do not use the interface at this time.\n-**\n-** When the virtual-table mechanism stabilizes, we will declare the\n-** interface fixed, support it indefinitely, and remove this comment.\n-*\/\n-\n@@ -7017,0 +7343,4 @@\n+  \/* The methods above are in versions 1 through 3 of the sqlite_module object.\n+  ** Those below are for version 4 and greater. *\/\n+  int (*xIntegrity)(sqlite3_vtab *pVTab, const char *zSchema,\n+                    const char *zTabName, int mFlags, char **pzErr);\n@@ -7075,1 +7405,1 @@\n-** ^The idxNum and idxPtr values are recorded and passed into the\n+** ^The idxNum and idxStr values are recorded and passed into the\n@@ -7077,2 +7407,2 @@\n-** ^[sqlite3_free()] is used to free idxPtr if and only if\n-** needToFreeIdxPtr is true.\n+** ^[sqlite3_free()] is used to free idxStr if and only if\n+** needToFreeIdxStr is true.\n@@ -7198,1 +7528,1 @@\n-** interface is no commonly needed.\n+** interface is not commonly needed.\n@@ -7357,10 +7687,0 @@\n-\/*\n-** The interface to the virtual-table mechanism defined above (back up\n-** to a comment remarkably similar to this one) is currently considered\n-** to be experimental.  The interface might change in incompatible ways.\n-** If this is a problem for you, do not use the interface at this time.\n-**\n-** When the virtual-table mechanism stabilizes, we will declare the\n-** interface fixed, support it indefinitely, and remove this comment.\n-*\/\n-\n@@ -7514,1 +7834,1 @@\n-** open blob handle results in undefined behaviour. ^Calling this routine\n+** open blob handle results in undefined behavior. ^Calling this routine\n@@ -7741,3 +8061,5 @@\n-** will always return SQLITE_BUSY. The SQLite core only ever uses\n-** sqlite3_mutex_try() as an optimization so this is acceptable\n-** behavior.)^\n+** will always return SQLITE_BUSY. In most cases the SQLite core only uses\n+** sqlite3_mutex_try() as an optimization, so this is acceptable\n+** behavior. The exceptions are unix builds that set the\n+** SQLITE_ENABLE_SETLK_TIMEOUT build option. In that case a working\n+** sqlite3_mutex_try() is required.)^\n@@ -7750,3 +8072,3 @@\n-** ^If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), or\n-** sqlite3_mutex_leave() is a NULL pointer, then all three routines\n-** behave as no-ops.\n+** ^If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(),\n+** sqlite3_mutex_leave(), or sqlite3_mutex_free() is a NULL pointer,\n+** then any of the four routines behaves as a no-op.\n@@ -7994,0 +8316,1 @@\n+#define SQLITE_TESTCTRL_FK_NO_ACTION             7\n@@ -8001,0 +8324,1 @@\n+#define SQLITE_TESTCTRL_JSON_SELFCHECK          14\n@@ -8022,1 +8346,2 @@\n-#define SQLITE_TESTCTRL_LAST                    33  \/* Largest TESTCTRL *\/\n+#define SQLITE_TESTCTRL_USELONGDOUBLE           34\n+#define SQLITE_TESTCTRL_LAST                    34  \/* Largest TESTCTRL *\/\n@@ -8982,1 +9307,1 @@\n-** backup is in progress might also also cause a mutex deadlock.\n+** backup is in progress might also cause a mutex deadlock.\n@@ -9410,1 +9735,1 @@\n-#define SQLITE_CHECKPOINT_RESTART  2  \/* Like FULL but wait for for readers *\/\n+#define SQLITE_CHECKPOINT_RESTART  2  \/* Like FULL but wait for readers *\/\n@@ -9478,1 +9803,1 @@\n-** the [xConnect] or [xCreate] methods of a [virtual table] implmentation\n+** the [xConnect] or [xCreate] methods of a [virtual table] implementation\n@@ -9486,1 +9811,1 @@\n-** the [xConnect] or [xCreate] methods of a [virtual table] implmentation\n+** the [xConnect] or [xCreate] methods of a [virtual table] implementation\n@@ -9493,0 +9818,9 @@\n+**\n+** [[SQLITE_VTAB_USES_ALL_SCHEMAS]]<dt>SQLITE_VTAB_USES_ALL_SCHEMAS<\/dt>\n+** <dd>Calls of the form\n+** [sqlite3_vtab_config](db,SQLITE_VTAB_USES_ALL_SCHEMA) from within the\n+** the [xConnect] or [xCreate] methods of a [virtual table] implementation\n+** instruct the query planner to begin at least a read transaction on\n+** all schemas (\"main\", \"temp\", and any ATTACH-ed databases) whenever the\n+** virtual table is used.\n+** <\/dd>\n@@ -9498,0 +9832,1 @@\n+#define SQLITE_VTAB_USES_ALL_SCHEMAS   4\n@@ -9570,1 +9905,1 @@\n-SQLITE_API SQLITE_EXPERIMENTAL const char *sqlite3_vtab_collation(sqlite3_index_info*,int);\n+SQLITE_API const char *sqlite3_vtab_collation(sqlite3_index_info*,int);\n@@ -9658,1 +9993,1 @@\n-** aConstraintUsage[].argvIndex to a postive integer.  ^(Then, under\n+** aConstraintUsage[].argvIndex to a positive integer.  ^(Then, under\n@@ -9727,1 +10062,1 @@\n-** sqlite3_vtab_in_next(X,P) must be one of the parameters to the\n+** sqlite3_vtab_in_next(X,P) should be one of the parameters to the\n@@ -9733,2 +10068,1 @@\n-** processing, then these routines return [SQLITE_MISUSE])^ or perhaps\n-** exhibit some other undefined or harmful behavior.\n+** processing, then these routines return [SQLITE_ERROR].)^\n@@ -9741,1 +10075,1 @@\n-** &nbsp;      rc==SQLITE_OK && pVal\n+** &nbsp;      rc==SQLITE_OK && pVal;\n@@ -9839,0 +10173,4 @@\n+** Not all values are available for all query elements. When a value is\n+** not available, the output variable is set to -1 if the value is numeric,\n+** or to NULL if it is a string (SQLITE_SCANSTAT_NAME).\n+**\n@@ -9866,1 +10204,1 @@\n-** [[SQLITE_SCANSTAT_SELECTID]] <dt>SQLITE_SCANSTAT_SELECT<\/dt>\n+** [[SQLITE_SCANSTAT_SELECTID]] <dt>SQLITE_SCANSTAT_SELECTID<\/dt>\n@@ -9868,4 +10206,16 @@\n-** \"select-id\" for the X-th loop.  The select-id identifies which query or\n-** subquery the loop is part of.  The main query has a select-id of zero.\n-** The select-id is the same value as is output in the first column\n-** of an [EXPLAIN QUERY PLAN] query.\n+** id for the X-th query plan element. The id value is unique within the\n+** statement. The select-id is the same value as is output in the first\n+** column of an [EXPLAIN QUERY PLAN] query.\n+**\n+** [[SQLITE_SCANSTAT_PARENTID]] <dt>SQLITE_SCANSTAT_PARENTID<\/dt>\n+** <dd>The \"int\" variable pointed to by the V parameter will be set to the\n+** the id of the parent of the current query element, if applicable, or\n+** to zero if the query element has no parent. This is the same value as\n+** returned in the second column of an [EXPLAIN QUERY PLAN] query.\n+**\n+** [[SQLITE_SCANSTAT_NCYCLE]] <dt>SQLITE_SCANSTAT_NCYCLE<\/dt>\n+** <dd>The sqlite3_int64 output value is set to the number of cycles,\n+** according to the processor time-stamp counter, that elapsed while the\n+** query element was being processed. This value is not available for\n+** all query elements - if it is unavailable the output variable is\n+** set to -1.\n@@ -9880,0 +10230,2 @@\n+#define SQLITE_SCANSTAT_PARENTID 6\n+#define SQLITE_SCANSTAT_NCYCLE   7\n@@ -9885,1 +10237,1 @@\n-** This interface returns information about the predicted and measured\n+** These interfaces return information about the predicted and measured\n@@ -9896,13 +10248,19 @@\n-** of this interface is undefined.\n-** ^The requested measurement is written into a variable pointed to by\n-** the \"pOut\" parameter.\n-** Parameter \"idx\" identifies the specific loop to retrieve statistics for.\n-** Loops are numbered starting from zero. ^If idx is out of range - less than\n-** zero or greater than or equal to the total number of loops used to implement\n-** the statement - a non-zero value is returned and the variable that pOut\n-** points to is unchanged.\n-**\n-** ^Statistics might not be available for all loops in all statements. ^In cases\n-** where there exist loops with no available statistics, this function behaves\n-** as if the loop did not exist - it returns non-zero and leave the variable\n-** that pOut points to unchanged.\n+** of this interface is undefined. ^The requested measurement is written into\n+** a variable pointed to by the \"pOut\" parameter.\n+**\n+** The \"flags\" parameter must be passed a mask of flags. At present only\n+** one flag is defined - SQLITE_SCANSTAT_COMPLEX. If SQLITE_SCANSTAT_COMPLEX\n+** is specified, then status information is available for all elements\n+** of a query plan that are reported by \"EXPLAIN QUERY PLAN\" output. If\n+** SQLITE_SCANSTAT_COMPLEX is not specified, then only query plan elements\n+** that correspond to query loops (the \"SCAN...\" and \"SEARCH...\" elements of\n+** the EXPLAIN QUERY PLAN output) are available. Invoking API\n+** sqlite3_stmt_scanstatus() is equivalent to calling\n+** sqlite3_stmt_scanstatus_v2() with a zeroed flags parameter.\n+**\n+** Parameter \"idx\" identifies the specific query element to retrieve statistics\n+** for. Query elements are numbered starting from zero. A value of -1 may be\n+** to query for statistics regarding the entire query. ^If idx is out of range\n+** - less than -1 or greater than or equal to the total number of query\n+** elements used to implement the statement - a non-zero value is returned and\n+** the variable that pOut points to is unchanged.\n@@ -9918,0 +10276,13 @@\n+SQLITE_API int sqlite3_stmt_scanstatus_v2(\n+  sqlite3_stmt *pStmt,      \/* Prepared statement for which info desired *\/\n+  int idx,                  \/* Index of loop to report on *\/\n+  int iScanStatusOp,        \/* Information desired.  SQLITE_SCANSTAT_* *\/\n+  int flags,                \/* Mask of flags defined below *\/\n+  void *pOut                \/* Result written here *\/\n+);\n+\n+\/*\n+** CAPI3REF: Prepared Statement Scan Status\n+** KEYWORDS: {scan status flags}\n+*\/\n+#define SQLITE_SCANSTAT_COMPLEX 0x0001\n@@ -10008,0 +10379,4 @@\n+** ^The sqlite3_preupdate_hook(D,C,P) function returns the P argument from\n+** the previous call on the same [database connection] D, or NULL for\n+** the first call on D.\n+**\n@@ -10047,1 +10422,1 @@\n-** callback made with op==SQLITE_DELETE is actuall a write using the\n+** callback made with op==SQLITE_DELETE is actually a write using the\n@@ -10308,0 +10683,7 @@\n+** After the call, if the SQLITE_SERIALIZE_NOCOPY bit had been set,\n+** the returned buffer content will remain accessible and unchanged\n+** until either the next write operation on the connection or when\n+** the connection is closed, and applications must not modify the\n+** buffer. If the bit had been clear, the returned buffer will not\n+** be accessed by SQLite after the call.\n+**\n@@ -10356,0 +10738,3 @@\n+** Applications must not modify the buffer P or invalidate it before\n+** the database connection D is closed.\n+**\n@@ -10364,0 +10749,7 @@\n+** The deserialized database should not be in [WAL mode].  If the database\n+** is in WAL mode, then any attempt to use the database file will result\n+** in an [SQLITE_CANTOPEN] error.  The application can set the\n+** [file format version numbers] (bytes 18 and 19) of the input database P\n+** to 0x01 prior to invoking sqlite3_deserialize(D,S,P,N,M,F) to force the\n+** database file into rollback mode and work around this limitation.\n+**\n@@ -10413,0 +10805,13 @@\n+#if defined(__wasi__)\n+# undef SQLITE_WASI\n+# define SQLITE_WASI 1\n+# undef SQLITE_OMIT_WAL\n+# define SQLITE_OMIT_WAL 1\/* because it requires shared memory APIs *\/\n+# ifndef SQLITE_OMIT_LOAD_EXTENSION\n+#  define SQLITE_OMIT_LOAD_EXTENSION\n+# endif\n+# ifndef SQLITE_THREADSAFE\n+#  define SQLITE_THREADSAFE 0\n+# endif\n+#endif\n+\n@@ -10619,1 +11024,1 @@\n-** CAPIREF: Conigure a Session Object\n+** CAPI3REF: Configure a Session Object\n@@ -10623,2 +11028,2 @@\n-** created. At present the only valid value for the second parameter is\n-** [SQLITE_SESSION_OBJCONFIG_SIZE].\n+** created. At present the only valid values for the second parameter are\n+** [SQLITE_SESSION_OBJCONFIG_SIZE] and [SQLITE_SESSION_OBJCONFIG_ROWID].\n@@ -10626,1 +11031,5 @@\n-** Arguments for sqlite3session_object_config()\n+*\/\n+SQLITE_API int sqlite3session_object_config(sqlite3_session*, int op, void *pArg);\n+\n+\/*\n+** CAPI3REF: Options for sqlite3session_object_config\n@@ -10628,1 +11037,1 @@\n-** The following values may passed as the the 4th parameter to\n+** The following values may passed as the the 2nd parameter to\n@@ -10644,0 +11053,12 @@\n+**\n+** <dt>SQLITE_SESSION_OBJCONFIG_ROWID <dd>\n+**   This option is used to set, clear or query the flag that enables\n+**   collection of data for tables with no explicit PRIMARY KEY.\n+**\n+**   Normally, tables with no explicit PRIMARY KEY are simply ignored\n+**   by the sessions module. However, if this flag is set, it behaves\n+**   as if such tables have a column \"_rowid_ INTEGER PRIMARY KEY\" inserted\n+**   as their leftmost columns.\n+**\n+**   It is an error (SQLITE_MISUSE) to attempt to modify this setting after\n+**   the first table has been attached to the session object.\n@@ -10645,5 +11066,2 @@\n-SQLITE_API int sqlite3session_object_config(sqlite3_session*, int op, void *pArg);\n-\n-\/*\n-*\/\n-#define SQLITE_SESSION_OBJCONFIG_SIZE 1\n+#define SQLITE_SESSION_OBJCONFIG_SIZE  1\n+#define SQLITE_SESSION_OBJCONFIG_ROWID 2\n@@ -11410,0 +11828,12 @@\n+\/*\n+** CAPI3REF: Upgrade the Schema of a Changeset\/Patchset\n+*\/\n+SQLITE_API int sqlite3changeset_upgrade(\n+  sqlite3 *db,\n+  const char *zDb,\n+  int nIn, const void *pIn,       \/* Input changeset *\/\n+  int *pnOut, void **ppOut        \/* OUT: Inverse of input *\/\n+);\n+\n+\n+\n@@ -11456,0 +11886,32 @@\n+\/*\n+** CAPI3REF: Add a Schema to a Changegroup\n+** METHOD: sqlite3_changegroup_schema\n+**\n+** This method may be used to optionally enforce the rule that the changesets\n+** added to the changegroup handle must match the schema of database zDb\n+** (\"main\", \"temp\", or the name of an attached database). If\n+** sqlite3changegroup_add() is called to add a changeset that is not compatible\n+** with the configured schema, SQLITE_SCHEMA is returned and the changegroup\n+** object is left in an undefined state.\n+**\n+** A changeset schema is considered compatible with the database schema in\n+** the same way as for sqlite3changeset_apply(). Specifically, for each\n+** table in the changeset, there exists a database table with:\n+**\n+** <ul>\n+**   <li> The name identified by the changeset, and\n+**   <li> at least as many columns as recorded in the changeset, and\n+**   <li> the primary key columns in the same position as recorded in\n+**        the changeset.\n+** <\/ul>\n+**\n+** The output of the changegroup object always has the same schema as the\n+** database nominated using this function. In cases where changesets passed\n+** to sqlite3changegroup_add() have fewer columns than the corresponding table\n+** in the database schema, these are filled in using the default column\n+** values from the database schema. This makes it possible to combined\n+** changesets that have different numbers of columns for a single table\n+** within a changegroup, provided that they are otherwise compatible.\n+*\/\n+SQLITE_API int sqlite3changegroup_schema(sqlite3_changegroup*, sqlite3*, const char *zDb);\n+\n@@ -11524,5 +11986,9 @@\n-** case, this function fails with SQLITE_SCHEMA. If the input changeset\n-** appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is\n-** returned. Or, if an out-of-memory condition occurs during processing, this\n-** function returns SQLITE_NOMEM. In all cases, if an error occurs the state\n-** of the final contents of the changegroup is undefined.\n+** case, this function fails with SQLITE_SCHEMA. Except, if the changegroup\n+** object has been configured with a database schema using the\n+** sqlite3changegroup_schema() API, then it is possible to combine changesets\n+** with different numbers of columns for a single table, provided that\n+** they are otherwise compatible.\n+**\n+** If the input changeset appears to be corrupt and the corruption is\n+** detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition\n+** occurs during processing, this function returns SQLITE_NOMEM.\n@@ -11530,1 +11996,2 @@\n-** If no error occurs, SQLITE_OK is returned.\n+** In all cases, if an error occurs the state of the final contents of the\n+** changegroup is undefined. If no error occurs, SQLITE_OK is returned.\n@@ -11782,0 +12249,19 @@\n+**\n+** <dt>SQLITE_CHANGESETAPPLY_IGNORENOOP <dd>\n+**   Do not invoke the conflict handler callback for any changes that\n+**   would not actually modify the database even if they were applied.\n+**   Specifically, this means that the conflict handler is not invoked\n+**   for:\n+**    <ul>\n+**    <li>a delete change if the row being deleted cannot be found,\n+**    <li>an update change if the modified fields are already set to\n+**        their new values in the conflicting row, or\n+**    <li>an insert change if all fields of the conflicting row match\n+**        the row being inserted.\n+**    <\/ul>\n+**\n+** <dt>SQLITE_CHANGESETAPPLY_FKNOACTION <dd>\n+**   If this flag it set, then all foreign key constraints in the target\n+**   database behave as if they were declared with \"ON UPDATE NO ACTION ON\n+**   DELETE NO ACTION\", even if they are actually CASCADE, RESTRICT, SET NULL\n+**   or SET DEFAULT.\n@@ -11785,0 +12271,2 @@\n+#define SQLITE_CHANGESETAPPLY_IGNORENOOP    0x0004\n+#define SQLITE_CHANGESETAPPLY_FKNOACTION    0x0008\n@@ -12350,2 +12838,5 @@\n-**   This function attempts to retrieve the text of column iCol of the\n-**   current document. If successful, (*pz) is set to point to a buffer\n+**   If parameter iCol is less than zero, or greater than or equal to the\n+**   number of columns in the table, SQLITE_RANGE is returned.\n+**\n+**   Otherwise, this function attempts to retrieve the text of column iCol of\n+**   the current document. If successful, (*pz) is set to point to a buffer\n@@ -12361,2 +12852,4 @@\n-**   Returns the number of tokens in phrase iPhrase of the query. Phrases\n-**   are numbered starting from zero.\n+**   If parameter iCol is less than zero, or greater than or equal to the\n+**   number of phrases in the current query, as returned by xPhraseCount,\n+**   0 is returned. Otherwise, this function returns the number of tokens in\n+**   phrase iPhrase of the query. Phrases are numbered starting from zero.\n@@ -12378,1 +12871,2 @@\n-**   output by xInstCount().\n+**   output by xInstCount(). If iIdx is less than zero or greater than\n+**   or equal to the value returned by xInstCount(), SQLITE_RANGE is returned.\n@@ -12380,1 +12874,1 @@\n-**   Usually, output parameter *piPhrase is set to the phrase number, *piCol\n+**   Otherwise, output parameter *piPhrase is set to the phrase number, *piCol\n@@ -12382,2 +12876,2 @@\n-**   first token of the phrase. Returns SQLITE_OK if successful, or an error\n-**   code (i.e. SQLITE_NOMEM) if an error occurs.\n+**   first token of the phrase. SQLITE_OK is returned if successful, or an\n+**   error code (i.e. SQLITE_NOMEM) if an error occurs.\n@@ -12409,0 +12903,4 @@\n+**   If parameter iPhrase is less than zero, or greater than or equal to\n+**   the number of phrases in the query, as returned by xPhraseCount(),\n+**   this function returns SQLITE_RANGE.\n+**\n@@ -12523,0 +13021,33 @@\n+**\n+** xQueryToken(pFts5, iPhrase, iToken, ppToken, pnToken)\n+**   This is used to access token iToken of phrase iPhrase of the current\n+**   query. Before returning, output parameter *ppToken is set to point\n+**   to a buffer containing the requested token, and *pnToken to the\n+**   size of this buffer in bytes.\n+**\n+**   If iPhrase or iToken are less than zero, or if iPhrase is greater than\n+**   or equal to the number of phrases in the query as reported by\n+**   xPhraseCount(), or if iToken is equal to or greater than the number of\n+**   tokens in the phrase, SQLITE_RANGE is returned and *ppToken and *pnToken\n+     are both zeroed.\n+**\n+**   The output text is not a copy of the query text that specified the\n+**   token. It is the output of the tokenizer module. For tokendata=1\n+**   tables, this includes any embedded 0x00 and trailing data.\n+**\n+** xInstToken(pFts5, iIdx, iToken, ppToken, pnToken)\n+**   This is used to access token iToken of phrase hit iIdx within the\n+**   current row. If iIdx is less than zero or greater than or equal to the\n+**   value returned by xInstCount(), SQLITE_RANGE is returned.  Otherwise,\n+**   output variable (*ppToken) is set to point to a buffer containing the\n+**   matching document token, and (*pnToken) to the size of that buffer in\n+**   bytes. This API is not available if the specified token matches a\n+**   prefix query term. In that case both output variables are always set\n+**   to 0.\n+**\n+**   The output text is not a copy of the document text that was tokenized.\n+**   It is the output of the tokenizer module. For tokendata=1 tables, this\n+**   includes any embedded 0x00 and trailing data.\n+**\n+**   This API can be quite slow if used with an FTS5 table created with the\n+**   \"detail=none\" or \"detail=column\" option.\n@@ -12560,0 +13091,7 @@\n+\n+  \/* Below this point are iVersion>=3 only *\/\n+  int (*xQueryToken)(Fts5Context*,\n+      int iPhrase, int iToken,\n+      const char **ppToken, int *pnToken\n+  );\n+  int (*xInstToken)(Fts5Context*, int iIdx, int iToken, const char**, int*);\n@@ -12754,2 +13292,2 @@\n-**   provide synonyms when tokenizing document text (method (2)) or query\n-**   text (method (3)), not both. Doing so will not cause any errors, but is\n+**   provide synonyms when tokenizing document text (method (3)) or query\n+**   text (method (2)), not both. Doing so will not cause any errors, but is\n@@ -12803,1 +13341,1 @@\n-    void *pContext,\n+    void *pUserData,\n@@ -12812,1 +13350,1 @@\n-    void **ppContext,\n+    void **ppUserData,\n@@ -12820,1 +13358,1 @@\n-    void *pContext,\n+    void *pUserData,\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/sqlite3.h","additions":754,"deletions":216,"binary":false,"changes":970,"status":"modified"},{"patch":"@@ -334,1 +334,1 @@\n-  char *(*create_filename)(const char*,const char*,const char*,\n+  const char *(*create_filename)(const char*,const char*,const char*,\n@@ -336,1 +336,1 @@\n-  void (*free_filename)(char*);\n+  void (*free_filename)(const char*);\n@@ -360,0 +360,9 @@\n+  \/* Version 3.40.0 and later *\/\n+  int (*value_encoding)(sqlite3_value*);\n+  \/* Version 3.41.0 and later *\/\n+  int (*is_interrupted)(sqlite3*);\n+  \/* Version 3.43.0 and later *\/\n+  int (*stmt_explain)(sqlite3_stmt*,int);\n+  \/* Version 3.44.0 and later *\/\n+  void *(*get_clientdata)(sqlite3*,const char*);\n+  int (*set_clientdata)(sqlite3*, const char*, void*, void(*)(void*));\n@@ -684,0 +693,9 @@\n+\/* Version 3.40.0 and later *\/\n+#define sqlite3_value_encoding         sqlite3_api->value_encoding\n+\/* Version 3.41.0 and later *\/\n+#define sqlite3_is_interrupted         sqlite3_api->is_interrupted\n+\/* Version 3.43.0 and later *\/\n+#define sqlite3_stmt_explain           sqlite3_api->stmt_explain\n+\/* Version 3.44.0 and later *\/\n+#define sqlite3_get_clientdata         sqlite3_api->get_clientdata\n+#define sqlite3_set_clientdata         sqlite3_api->set_clientdata\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/sqlite3ext.h","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"}]}