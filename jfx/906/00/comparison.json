{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,0 +161,26 @@\n+    \/**\n+     * Executes a lambda if the property value is not null, otherwise adds a listener to the ObservableValue {@code p}\n+     * to wait until it is set and calls the lambda then, followed by removing the said listener.\n+     *\n+     * @param p Observable value\n+     * @param consumer lambda to invoke when the property value is not null\n+     *\/\n+    public <T> void executeOnceWhenPropertyIsNonNull(ObservableValue<T> p, Consumer<T> consumer) {\n+        if (p == null) {\n+            return;\n+        }\n+\n+        T value = p.getValue();\n+        if (value != null) {\n+            consumer.accept(value);\n+        } else {\n+            registerInvalidationListener(p, (x) -> {\n+                T v = p.getValue();\n+                if (v != null) {\n+                    unregisterInvalidationListeners(p);\n+                    consumer.accept(v);\n+                }\n+            });\n+        }\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/LambdaMultiplePropertyChangeListenerHandler.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -829,0 +829,1 @@\n+    @Deprecated \/\/ WARNING: creates a memory leak\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/skin\/Utils.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -283,0 +283,13 @@\n+    \/**\n+     * Executes a lambda if the property value is not null, otherwise adds a listener to the ObservableValue {@code p}\n+     * to wait until it is set and calls the lambda then, followed by removing the said listener.\n+     *\n+     * @param p Observable value\n+     * @param consumer lambda to invoke when the property value is not null\n+     *\/\n+    protected final <T> void executeOnceWhenPropertyIsNonNull(ObservableValue<T> p, Consumer<T> consumer) {\n+        if (lambdaChangeListenerHandler == null) {\n+            lambdaChangeListenerHandler = new LambdaMultiplePropertyChangeListenerHandler();\n+        }\n+        lambdaChangeListenerHandler.executeOnceWhenPropertyIsNonNull(p, consumer);\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/SkinBase.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,15 @@\n+import static javafx.scene.input.KeyCode.ALT;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.WeakHashMap;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n@@ -30,6 +45,0 @@\n-import com.sun.javafx.scene.traversal.Direction;\n-import javafx.css.converter.EnumConverter;\n-import javafx.css.converter.SizeConverter;\n-import com.sun.javafx.scene.control.MenuBarButton;\n-import com.sun.javafx.scene.control.skin.Utils;\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n@@ -51,0 +60,2 @@\n+import javafx.css.converter.EnumConverter;\n+import javafx.css.converter.SizeConverter;\n@@ -74,12 +85,2 @@\n-\n-import static javafx.scene.input.KeyCode.*;\n-\n-import java.lang.ref.Reference;\n-import java.lang.ref.WeakReference;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.WeakHashMap;\n+import javafx.stage.Window;\n+import javafx.util.Pair;\n@@ -91,0 +92,3 @@\n+import com.sun.javafx.scene.control.MenuBarButton;\n+import com.sun.javafx.scene.traversal.Direction;\n+import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n@@ -92,8 +96,0 @@\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-\n-import javafx.stage.Window;\n-import javafx.util.Pair;\n-\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -145,3 +141,3 @@\n-    private WeakEventHandler<KeyEvent> weakSceneKeyEventHandler;\n-    private WeakEventHandler<MouseEvent> weakSceneMouseEventHandler;\n-    private WeakEventHandler<KeyEvent> weakSceneAltKeyEventHandler;\n+    private final WeakEventHandler<KeyEvent> weakSceneKeyEventHandler;\n+    private final WeakEventHandler<MouseEvent> weakSceneMouseEventHandler;\n+    private final WeakEventHandler<KeyEvent> weakSceneAltKeyEventHandler;\n@@ -154,0 +150,1 @@\n+    private WeakChangeListener<Boolean> weakMenuBarFocusedPropertyListener;\n@@ -156,0 +153,3 @@\n+    private WeakChangeListener<Boolean> weakMenuVisibilityChangeListener;\n+    private ChangeListener<Scene> sceneChangeListener2;\n+    private WeakChangeListener<Scene> weakSceneChangeListener2;\n@@ -158,1 +158,0 @@\n-\n@@ -170,4 +169,7 @@\n-        if (t.getSource() instanceof CustomMenuItem) {\n-            \/\/ RT-29614 If CustomMenuItem hideOnClick is false, dont hide\n-            CustomMenuItem cmi = (CustomMenuItem)t.getSource();\n-            if (!cmi.isHideOnClick()) return;\n+        if (getSkinnable() != null) {\n+            if (t.getSource() instanceof CustomMenuItem) {\n+                \/\/ RT-29614 If CustomMenuItem hideOnClick is false, dont hide\n+                CustomMenuItem cmi = (CustomMenuItem)t.getSource();\n+                if (!cmi.isHideOnClick()) return;\n+            }\n+            unSelectMenus();\n@@ -175,1 +177,0 @@\n-        unSelectMenus();\n@@ -305,0 +306,1 @@\n+\n@@ -315,1 +317,3 @@\n-         };\n+        };\n+        weakMenuBarFocusedPropertyListener = new WeakChangeListener(menuBarFocusedPropertyListener);\n+\n@@ -317,1 +321,1 @@\n-        Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n+        executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n@@ -323,3 +327,5 @@\n-            Bounds containerScreenBounds = container.localToScreen(container.getLayoutBounds());\n-            if (containerScreenBounds == null || !containerScreenBounds.contains(t.getScreenX(), t.getScreenY())) {\n-                unSelectMenus();\n+            if (getSkinnable() != null) {\n+                Bounds containerScreenBounds = container.localToScreen(container.getLayoutBounds());\n+                if (containerScreenBounds == null || !containerScreenBounds.contains(t.getScreenX(), t.getScreenY())) {\n+                    unSelectMenus();\n+                }\n@@ -329,1 +335,1 @@\n-        Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n+        executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n@@ -334,2 +340,4 @@\n-            if (!t1) {\n-              unSelectMenus();\n+            if (getSkinnable() != null) {\n+                if (!t1) {\n+                  unSelectMenus();\n+                }\n@@ -339,1 +347,1 @@\n-        Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n+        executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n@@ -357,0 +365,1 @@\n+        weakMenuVisibilityChangeListener = new WeakChangeListener(menuVisibilityChangeListener);\n@@ -359,1 +368,1 @@\n-        control.getMenus().addListener((ListChangeListener<Menu>) c -> {\n+        registerListChangeListener(control.getMenus(), (ch) -> {\n@@ -364,1 +373,1 @@\n-            control.useSystemMenuBarProperty().addListener(valueModel -> {\n+            registerInvalidationListener(control.useSystemMenuBarProperty(), (p) -> {\n@@ -412,1 +421,1 @@\n-        Utils.executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n+        executeOnceWhenPropertyIsNonNull(control.sceneProperty(), (Scene scene) -> {\n@@ -424,1 +433,1 @@\n-        control.sceneProperty().addListener((ov, t, t1) -> {\n+        sceneChangeListener2 = (ov, t, t1) -> {\n@@ -427,9 +436,3 @@\n-                if (weakSceneKeyEventHandler != null) {\n-                    t.removeEventFilter(KeyEvent.KEY_PRESSED, weakSceneKeyEventHandler);\n-                }\n-                if (weakSceneMouseEventHandler != null) {\n-                    t.removeEventFilter(MouseEvent.MOUSE_CLICKED, weakSceneMouseEventHandler);\n-                }\n-                if (weakSceneAltKeyEventHandler != null) {\n-                    t.removeEventHandler(KeyEvent.ANY, weakSceneAltKeyEventHandler);\n-                }\n+                t.removeEventFilter(KeyEvent.KEY_PRESSED, weakSceneKeyEventHandler);\n+                t.removeEventFilter(MouseEvent.MOUSE_CLICKED, weakSceneMouseEventHandler);\n+                t.removeEventHandler(KeyEvent.ANY, weakSceneAltKeyEventHandler);\n@@ -448,1 +451,3 @@\n-        });\n+        };\n+        weakSceneChangeListener2 = new WeakChangeListener(sceneChangeListener2);\n+        control.sceneProperty().addListener(weakSceneChangeListener2);\n@@ -686,1 +691,7 @@\n-    @Override public void dispose() {\n+    @Override\n+    public void dispose() {\n+        if (getSkinnable() == null) {\n+            return;\n+        }\n+\n+        cleanUpListeners();\n@@ -688,0 +699,1 @@\n+        getChildren().remove(container);\n@@ -824,2 +836,3 @@\n-    private void rebuildUI() {\n-        getSkinnable().focusedProperty().removeListener(menuBarFocusedPropertyListener);\n+    private void cleanUpListeners() {\n+        getSkinnable().focusedProperty().removeListener(weakMenuBarFocusedPropertyListener);\n+\n@@ -830,1 +843,1 @@\n-            m.visibleProperty().removeListener(menuVisibilityChangeListener);\n+            m.visibleProperty().removeListener(weakMenuVisibilityChangeListener);\n@@ -832,0 +845,1 @@\n+\n@@ -852,0 +866,1 @@\n+\n@@ -853,0 +868,4 @@\n+    }\n+\n+    private void rebuildUI() {\n+        cleanUpListeners();\n@@ -930,1 +949,2 @@\n-        getSkinnable().focusedProperty().addListener(menuBarFocusedPropertyListener);\n+        getSkinnable().focusedProperty().addListener(weakMenuBarFocusedPropertyListener);\n+\n@@ -933,1 +953,1 @@\n-            menu.visibleProperty().addListener(menuVisibilityChangeListener);\n+            menu.visibleProperty().addListener(weakMenuVisibilityChangeListener);\n@@ -945,5 +965,7 @@\n-                if (menu.isShowing()) {\n-                    menuButton.show();\n-                    menuModeStart(container.getChildren().indexOf(menuButton));\n-                } else {\n-                    menuButton.hide();\n+                if (getSkinnable() != null) {\n+                    if (menu.isShowing()) {\n+                        menuButton.show();\n+                        menuModeStart(container.getChildren().indexOf(menuButton));\n+                    } else {\n+                        menuButton.hide();\n+                    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/MenuBarSkin.java","additions":91,"deletions":69,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -28,0 +28,13 @@\n+import static javafx.scene.control.ControlShim.installDefaultSkin;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertSame;\n+import static org.junit.Assert.assertTrue;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.asArrays;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.attemptGC;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.createControl;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.getControlClasses;\n+import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.replaceSkin;\n+\n@@ -32,12 +45,0 @@\n-import org.junit.After;\n-import org.junit.Before;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n-import org.junit.runners.Parameterized;\n-\n-import com.sun.javafx.tk.Toolkit;\n-\n-import static javafx.scene.control.ControlShim.*;\n-import static org.junit.Assert.*;\n-import static test.com.sun.javafx.scene.control.infrastructure.ControlSkinFactory.*;\n-\n@@ -51,1 +52,0 @@\n-import javafx.scene.control.MenuBar;\n@@ -67,0 +67,8 @@\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import com.sun.javafx.tk.Toolkit;\n+\n@@ -87,0 +95,2 @@\n+        WeakReference<?> weakRef = new WeakReference<>(skin);\n+\n@@ -89,0 +99,16 @@\n+        skin = null;\n+        Toolkit.getToolkit().firePulse();\n+\n+        attemptGC(weakRef);\n+        assertNull(\"Unused Skin must be gc'ed\", weakRef.get());\n+    }\n+\n+    \/**\n+     * default skin -> set another instance of default skin,\n+     * with scene property set.\n+     *\/\n+    @Test\n+    public void testMemoryLeakSameSkinClassWithScene() {\n+        showControl(control, true);\n+        installDefaultSkin(control);\n+        Skin<?> skin = control.getSkin();\n@@ -90,0 +116,3 @@\n+\n+        installDefaultSkin(control);\n+\n@@ -91,0 +120,2 @@\n+        Toolkit.getToolkit().firePulse();\n+\n@@ -120,2 +151,2 @@\n-        \/\/ FIXME: JDK-8265406 - fragile test pattern\n-        WeakReference<?> weakRef = new WeakReference<>(replaceSkin(control));\n+        Skin<?> replacedSkin = replaceSkin(control);\n+        WeakReference<?> weakRef = new WeakReference<>(replacedSkin);\n@@ -123,0 +154,25 @@\n+\n+        \/\/ beware: this is important - we might get false reds without!\n+        replacedSkin = null;\n+        Toolkit.getToolkit().firePulse();\n+\n+        attemptGC(weakRef);\n+        assertEquals(\"Skin must be gc'ed\", null, weakRef.get());\n+    }\n+\n+    \/**\n+     * default skin -> set alternative,\n+     * with scene property set\n+     *\/\n+    @Test\n+    public void testMemoryLeakAlternativeSkinWithScene() {\n+        showControl(control, true);\n+        installDefaultSkin(control);\n+        Skin<?> replacedSkin = replaceSkin(control);\n+        WeakReference<?> weakRef = new WeakReference<>(replacedSkin);\n+        assertNotNull(weakRef.get());\n+\n+        \/\/ beware: this is important - we might get false reds without!\n+        replacedSkin = null;\n+        Toolkit.getToolkit().firePulse();\n+\n@@ -136,0 +192,1 @@\n+\n@@ -137,1 +194,0 @@\n-        Toolkit.getToolkit().firePulse();\n@@ -139,0 +195,2 @@\n+        Toolkit.getToolkit().firePulse();\n+\n@@ -169,1 +227,0 @@\n-                MenuBar.class,\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/SkinMemoryLeakTest.java","additions":74,"deletions":17,"binary":false,"changes":91,"status":"modified"}]}