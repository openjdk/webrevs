{"files":[{"patch":"@@ -1024,1 +1024,1 @@\n-     * If this parent is either a layout root or unmanaged, then it will be\n+     * If this parent is either a scene root or unmanaged, then it will be\n@@ -1069,1 +1069,9 @@\n-                p.requestLayout();\n+\n+                \/*\n+                 * The forceParentLayout flag must be propagated to mark all ancestors\n+                 * as needing layout. Failure to do so while performingLayout is true\n+                 * would stop the propagation mid-tree. This leaves some nodes as needing\n+                 * layout, while its ancestors are clean, which is an inconsistent state.\n+                 *\/\n+\n+                p.requestLayout(forceParentLayout);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Parent.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.javafx.scene.LayoutFlags;\n+\n@@ -52,0 +54,4 @@\n+    public static LayoutFlags getLayoutFlag(Parent p) {\n+        return p.layoutFlag;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/javafx\/scene\/ParentShim.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.scene.LayoutFlags;\n@@ -46,0 +47,2 @@\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.VBox;\n@@ -559,0 +562,1 @@\n+    }\n@@ -560,0 +564,83 @@\n+    \/**\n+     * Checks if layout flags are always consistent, even when a 2nd layout\n+     * pass is requested due to a modification while layout was running.\n+     *\n+     * This test needs at least a layout tree of 4 levels deep due to\n+     * how the layout flags are propagated:\n+     * - Node will force another layout on the PARENT of sibling\n+     * - Parent code will then ask for another layout on its parent\n+     * - If forceParentLayout flag is not propagated, then this does\n+     *   not continue up to the root, leaving the root clean.\n+     *\/\n+    @Test\n+    public void layoutPositionModificationDuringLayoutPassShouldNotLeaveLayoutFlagsInInconsistentState() {\n+        AtomicBoolean modifySiblingDuringLayout = new AtomicBoolean();\n+        HBox sibling = new HBox();\n+        HBox leaf = new HBox() {\n+            @Override\n+            protected void layoutChildren() {\n+                super.layoutChildren();\n+\n+                \/*\n+                 * Sometimes layout code modifies a sibling's position,\n+                 * in which case Node will force its parent to do another\n+                 * layout in a next pass (see layoutX and layoutY properties).\n+                 *\n+                 * The layout flags should not become inconsistent\n+                 * when it does so.\n+                 *\/\n+\n+                if (modifySiblingDuringLayout.get()) {\n+                    sibling.setLayoutX(100);\n+                }\n+            }\n+        };\n+        VBox level2 = new VBox(leaf, sibling);\n+        HBox level1 = new HBox(level2);\n+        VBox root = new VBox(level1);\n+\n+        \/\/ Assert default state after controls are created:\n+        assertEquals(LayoutFlags.NEEDS_LAYOUT, ParentShim.getLayoutFlag(root));\n+        assertEquals(LayoutFlags.NEEDS_LAYOUT, ParentShim.getLayoutFlag(level1));\n+        assertEquals(LayoutFlags.NEEDS_LAYOUT, ParentShim.getLayoutFlag(level2));\n+        assertEquals(LayoutFlags.NEEDS_LAYOUT, ParentShim.getLayoutFlag(leaf));\n+        assertEquals(LayoutFlags.NEEDS_LAYOUT, ParentShim.getLayoutFlag(sibling));\n+\n+        root.layout();\n+\n+        \/\/ Assert that all is clean after a layout pass:\n+        assertEquals(LayoutFlags.CLEAN, ParentShim.getLayoutFlag(root));\n+        assertEquals(LayoutFlags.CLEAN, ParentShim.getLayoutFlag(level1));\n+        assertEquals(LayoutFlags.CLEAN, ParentShim.getLayoutFlag(level2));\n+        assertEquals(LayoutFlags.CLEAN, ParentShim.getLayoutFlag(leaf));\n+        assertEquals(LayoutFlags.CLEAN, ParentShim.getLayoutFlag(sibling));\n+\n+        leaf.requestLayout();\n+\n+        \/\/ Assert that all nodes between leaf and root are marked as needing layout:\n+        assertEquals(LayoutFlags.NEEDS_LAYOUT, ParentShim.getLayoutFlag(root));\n+        assertEquals(LayoutFlags.NEEDS_LAYOUT, ParentShim.getLayoutFlag(level1));\n+        assertEquals(LayoutFlags.NEEDS_LAYOUT, ParentShim.getLayoutFlag(level2));\n+        assertEquals(LayoutFlags.NEEDS_LAYOUT, ParentShim.getLayoutFlag(leaf));\n+        assertEquals(LayoutFlags.CLEAN, ParentShim.getLayoutFlag(sibling));\n+\n+        \/\/ Trigger a layout that does a modification that needs a 2nd pass:\n+        modifySiblingDuringLayout.set(true);\n+        root.layout();\n+\n+        \/\/ Assert that the parent of the sibling, all the way to the root are marked as needing another layout pass:\n+        assertEquals(LayoutFlags.NEEDS_LAYOUT, ParentShim.getLayoutFlag(root));\n+        assertEquals(LayoutFlags.NEEDS_LAYOUT, ParentShim.getLayoutFlag(level1));\n+        assertEquals(LayoutFlags.NEEDS_LAYOUT, ParentShim.getLayoutFlag(level2));\n+        assertEquals(LayoutFlags.CLEAN, ParentShim.getLayoutFlag(leaf));\n+        assertEquals(LayoutFlags.CLEAN, ParentShim.getLayoutFlag(sibling));\n+\n+        root.layout();\n+\n+        \/\/ Assert that after another layout pass all are clean again:\n+        \/\/ Note: we still modify the sibling, but since its layoutX is unchanged now, no further pass is triggered\n+        assertEquals(LayoutFlags.CLEAN, ParentShim.getLayoutFlag(root));\n+        assertEquals(LayoutFlags.CLEAN, ParentShim.getLayoutFlag(level1));\n+        assertEquals(LayoutFlags.CLEAN, ParentShim.getLayoutFlag(level2));\n+        assertEquals(LayoutFlags.CLEAN, ParentShim.getLayoutFlag(leaf));\n+        assertEquals(LayoutFlags.CLEAN, ParentShim.getLayoutFlag(sibling));\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/ParentTest.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"modified"}]}