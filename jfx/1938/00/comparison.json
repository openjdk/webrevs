{"files":[{"patch":"@@ -77,0 +77,3 @@\n+    \/** maximum length of the text to pass to IME subsystem *\/\n+    public static final int IME_MAX_TEXT_LENGTH = 4096;\n+\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/Params.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -327,8 +327,1 @@\n-        RichTextArea control = getControl();\n-        if (control.isEditable()) {\n-            StyledTextModel m = control.getModel();\n-            if (m != null) {\n-                return m.isWritable();\n-            }\n-        }\n-        return false;\n+        return RichUtils.canEdit(getControl());\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/RichTextAreaBehavior.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.jfx.incubator.scene.control.richtext;\n+\n+import com.sun.javafx.util.Utils;\n+import com.sun.jfx.incubator.scene.control.richtext.util.ListenerHelper;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.skin.RichTextAreaSkin;\n+\n+\/**\n+ * Manages RichTextArea Accessor.\n+ *\/\n+public class RichTextAreaHelper {\n+\n+    public interface Accessor {\n+        public boolean getText(RichTextArea t, TextPos start, TextPos end, StringBuilder sb, int limit, String lineSeparator);\n+    }\n+\n+    static {\n+        Utils.forceInit(RichTextArea.class);\n+    }\n+\n+    private static Accessor accessor;\n+\n+    public static void setAccessor(Accessor a) {\n+        if (accessor != null) {\n+            \/\/ this code might break when RTA is created outside of the fx application thread\n+            \/\/ I am not sure what this check does really\n+            throw new IllegalStateException();\n+        }\n+        accessor = a;\n+    }\n+\n+    public static boolean getText(RichTextArea t, TextPos start, TextPos end, StringBuilder sb, int limit, String lineSeparator) {\n+        return accessor.getText(t, start, end, sb, limit, lineSeparator);\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/RichTextAreaHelper.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,0 +215,32 @@\n+    \/**\n+     * Returns the {@code PathElement} array for the underline shape,\n+     * translated to the {@code target} frame of reference.\n+     *\n+     * @param target the Region that provides the target frame of reference\n+     * @param start the start offset\n+     * @param end the end offset\n+     * @return the array of path elements translated to the target coordinates\n+     *\/\n+    public PathElement[] getUnderlineShape(Region target, int start, int end) {\n+        PathElement[] p;\n+        double dx;\n+        double dy;\n+        if (content instanceof TextFlow f) {\n+            dx = f.snappedLeftInset(); \/\/ TODO RTL?\n+            dy = f.snappedTopInset();\n+\n+            p = f.getUnderlineShape(start, end);\n+        } else {\n+            dx = 0.0;\n+            dy = 0.0;\n+            double w = getWidth();\n+            double h = getHeight();\n+\n+            p = new PathElement[] {\n+                new MoveTo(0.0, h),\n+                new LineTo(w, h)\n+            };\n+        }\n+        return RichUtils.translatePath(target, content, p, dx, dy);\n+    }\n+\n@@ -232,1 +264,1 @@\n-            p = f.rangeShape(start, end);\n+            p = f.rangeShape(start, end); \/\/ TODO new api, no null\n@@ -368,1 +400,1 @@\n-            PathElement[] pe = f.rangeShape(0, len);\n+            PathElement[] pe = f.rangeShape(0, len); \/\/ TODO new api\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/TextCell.java","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.ArrayList;\n@@ -45,0 +46,1 @@\n+import javafx.geometry.Point2D;\n@@ -56,0 +58,1 @@\n+import javafx.scene.shape.Shape;\n@@ -537,1 +540,1 @@\n-    protected CaretInfo getCaretInfo(TextPos p) {\n+    public CaretInfo getCaretInfo(TextPos p) {\n@@ -1671,0 +1674,48 @@\n+\n+    interface ShapeGenerator {\n+        public PathElement[] generate(TextCell cell,  int beginOffset, int endOffset);\n+    }\n+\n+    private List<PathElement> getShapes(TextPos start, TextPos end, ShapeGenerator gen) {\n+        ArrayList<PathElement> ss = new ArrayList<>(16);\n+        int ix1 = start.index();\n+        int ix2 = end.index();\n+        for (int ix = ix1; ix <= ix2; ix++) {\n+            TextCell cell = arrangement().getVisibleCell(ix);\n+            if (cell == null) {\n+                break;\n+            }\n+            int beginOffset = (ix == ix1) ? start.offset() : 0;\n+            int endOffset = (ix == ix2) ? end.offset() : cell.getTextLength();\n+            PathElement[] es = gen.generate(cell, beginOffset, endOffset);\n+            for (PathElement em : es) {\n+                ss.add(em);\n+            }\n+        }\n+        return ss;\n+    }\n+\n+    public List<PathElement> getRangeShape(TextPos start, TextPos end) {\n+        return getShapes(start, end, (cell, beginOffset, endOffset) -> {\n+            return cell.getRangeShape(content, beginOffset, endOffset);\n+        });\n+    }\n+\n+    public List<PathElement> getUnderlineShape(TextPos start, TextPos end) {\n+        return getShapes(start, end, (cell, beginOffset, endOffset) -> {\n+            return cell.getUnderlineShape(content, beginOffset, endOffset);\n+        });\n+    }\n+\n+    public void addImeHighlights(List<Shape> shapes, TextPos start) {\n+        content.getChildren().addAll(shapes);\n+    }\n+\n+    public void removeImHighlight(List<Shape> shapes) {\n+        content.getChildren().removeAll(shapes);\n+    }\n+\n+    public Point2D getImeLocationOnScreen(TextPos pos) {\n+        CaretInfo ci = getCaretInfo(pos);\n+        return content.localToScreen(ci.getMinX(), ci.getMaxY());\n+    }\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/VFlow.java","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import javafx.application.ColorScheme;\n@@ -50,0 +51,1 @@\n+import javafx.scene.Scene;\n@@ -51,0 +53,2 @@\n+import javafx.scene.input.InputMethodEvent;\n+import javafx.scene.input.InputMethodTextRun;\n@@ -64,0 +68,2 @@\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.TextPos;\n@@ -65,0 +71,1 @@\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n@@ -698,0 +705,39 @@\n+\n+    \/** returns true if both control and model are editable *\/\n+    public static boolean canEdit(RichTextArea rta) {\n+        if (rta.isEditable()) {\n+            StyledTextModel m = rta.getModel();\n+            if (m != null) {\n+                return m.isWritable();\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/** Returns the text positions at a positive offset relative to the 'start' position. *\/\n+    public static TextPos advancePosition(TextPos start, int offset) {\n+        return TextPos.ofLeading(start.index(), start.offset() + offset);\n+    }\n+\n+    \/** Returns true if the color scheme is DARK, checking first the node's scene, then platform preferences. *\/\n+    public static boolean isDarkScheme(Node n) {\n+        Scene sc = n.getScene();\n+        if (sc != null) {\n+            return (sc.getPreferences().getColorScheme() == ColorScheme.DARK);\n+        }\n+        return (Platform.getPreferences().getColorScheme() == ColorScheme.DARK);\n+    }\n+\n+    \/** Returns composed or committed text. *\/\n+    public static String getImeText(InputMethodEvent ev) {\n+        \/\/ it's either composed or committed but not both\n+        if (ev.getComposed().size() > 0) {\n+            StringBuilder sb = new StringBuilder();\n+            for (InputMethodTextRun run : ev.getComposed()) {\n+                sb.append(run.getText());\n+            }\n+            return sb.toString();\n+        } else {\n+            return ev.getCommitted();\n+        }\n+    }\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/com\/sun\/jfx\/incubator\/scene\/control\/richtext\/util\/RichUtils.java","additions":47,"deletions":1,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import com.sun.jfx.incubator.scene.control.richtext.RichTextAreaHelper;\n@@ -314,0 +315,8 @@\n+    static {\n+        RichTextAreaHelper.setAccessor(new RichTextAreaHelper.Accessor() {\n+            @Override\n+            public boolean getText(RichTextArea t, TextPos start, TextPos end, StringBuilder sb, int limit, String lineSeparator) {\n+                return t.getText(start, end, sb, limit, lineSeparator);\n+            }\n+        });\n+    }\n@@ -1417,0 +1426,66 @@\n+    \/**\n+     * Copies the plain text between `start` and `end` positions to the provided buffer.\n+     * <p>\n+     * This method copies plain text into the provided StringBuilder, up to the specified number of characters.\n+     * When the amount of text between the two positions exceeds the specified limit,\n+     * the method returns {@code false}.\n+     * The method does nothing and returns {@code true} if the model is {@code null}.\n+     *\n+     * @param start the start position\n+     * @param end the end position\n+     * @param sb the buffer to copy to\n+     * @param limit the maximum number of characters to copy, must be >= 0\n+     * @param lineSeparator the newline separator sequence, or null to use the platform default\n+     * @return {@code true} if all the text fit in the buffer\n+     * @since 26\n+     *\/\n+    \/\/ TODO depends on JDK-8370140 (line separator property), private for now\n+    private final boolean getText(TextPos start, TextPos end, StringBuilder sb, int limit, String lineSeparator) {\n+        StyledTextModel m = getModel();\n+        if (m == null) {\n+            return true;\n+        }\n+\n+        if (start.compareTo(end) > 0) {\n+            TextPos tmp = start;\n+            start = end;\n+            end = tmp;\n+        }\n+\n+        if (lineSeparator == null) {\n+            lineSeparator = System.getProperty(\"line.separator\");\n+        }\n+\n+        int toCopy = limit;\n+        int index = start.index();\n+        boolean first = true;\n+        boolean all = true;\n+        while (toCopy > 0) {\n+            int beg;\n+            if (first) {\n+                first = false;\n+                beg = start.offset();\n+            } else {\n+                sb.append(lineSeparator);\n+                beg = 0;\n+            }\n+            String text = getPlainText(index);\n+            int len = Math.min(toCopy, text.length() - beg);\n+            sb.append(text, beg, beg + len);\n+            toCopy -= len;\n+            index++;\n+\n+            \/\/ did we copy all?\n+            if (toCopy == 0) {\n+                if (index < end.index()) {\n+                    all = false;\n+                } else if (index == end.index()) {\n+                    if (beg + len < end.offset()) {\n+                        all = false;\n+                    }\n+                }\n+            }\n+        }\n+        return all;\n+    }\n+\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/RichTextArea.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+import java.util.ArrayList;\n+import java.util.List;\n+import javafx.collections.ObservableList;\n@@ -40,0 +43,1 @@\n+import javafx.scene.input.InputMethodHighlight;\n@@ -41,0 +45,1 @@\n+import javafx.scene.input.InputMethodTextRun;\n@@ -42,0 +47,7 @@\n+import javafx.scene.paint.Color;\n+import javafx.scene.shape.ClosePath;\n+import javafx.scene.shape.HLineTo;\n+import javafx.scene.shape.Line;\n+import javafx.scene.shape.LineTo;\n+import javafx.scene.shape.MoveTo;\n+import javafx.scene.shape.Path;\n@@ -43,0 +55,2 @@\n+import javafx.scene.shape.Shape;\n+import javafx.scene.shape.VLineTo;\n@@ -47,0 +61,1 @@\n+import com.sun.jfx.incubator.scene.control.richtext.RichTextAreaHelper;\n@@ -53,0 +68,1 @@\n+import jfx.incubator.scene.control.richtext.SelectionSegment;\n@@ -80,0 +96,1 @@\n+    private Ime ime;\n@@ -139,0 +156,1 @@\n+        RichTextArea rta = getSkinnable();\n@@ -140,2 +158,2 @@\n-        InputMapHelper.setSkinInputMap(getSkinnable().getInputMap(), behavior.getSkinInputMap());\n-        \/\/getSkinnable().getInputMap().setSkinInputMap(behavior.getSkinInputMap());\n+        InputMapHelper.setSkinInputMap(rta.getInputMap(), behavior.getSkinInputMap());\n+        \/\/rta.getInputMap().setSkinInputMap(behavior.getSkinInputMap());\n@@ -144,2 +162,2 @@\n-        if (getSkinnable().getOnInputMethodTextChanged() == null) {\n-            getSkinnable().setOnInputMethodTextChanged(inputMethodTextChangedHandler);\n+        if (rta.getOnInputMethodTextChanged() == null) {\n+            rta.setOnInputMethodTextChanged(inputMethodTextChangedHandler);\n@@ -148,1 +166,1 @@\n-        if (getSkinnable().getInputMethodRequests() == null) {\n+        if (rta.getInputMethodRequests() == null) {\n@@ -150,0 +168,2 @@\n+                \/\/ returns the lower left corner of the character bounds\n+                \/\/ content is relative to the start of selection\n@@ -152,2 +172,7 @@\n-                    System.out.println(\"getTextLocation offset=\" + offset); \/\/ FIX\n-                    return null;\n+                    SelectionSegment sel = rta.getSelection();\n+                    if (sel != null) {\n+                        TextPos p = sel.getMin();\n+                        p = RichUtils.advancePosition(p, offset);\n+                        return vflow.getImeLocationOnScreen(p);\n+                    }\n+                    return new Point2D(0, 0);\n@@ -158,2 +183,10 @@\n-                    System.out.println(\"getSelectedText\"); \/\/ FIX\n-                    return null;\n+                    SelectionSegment sel = rta.getSelection();\n+                    if (sel != null) {\n+                        if (!sel.isCollapsed()) {\n+                            int limit = Params.IME_MAX_TEXT_LENGTH;\n+                            StringBuilder sb = new StringBuilder(limit);\n+                            RichTextAreaHelper.getText(rta, sel.getMin(), sel.getMax(), sb, limit, null);\n+                            return sb.toString();\n+                        }\n+                    }\n+                    return \"\";\n@@ -164,2 +197,11 @@\n-                    System.out.println(\"getLocationOffset x=\" + x + \" y=\" + y); \/\/ FIX\n-                    return 0;\n+                    \/\/ TODO this is weird: the caller CInputMethod.characterIndexForPoint() talks about screen coordinates,\n+                    \/\/ but the implementation in TextArea treats it as local coordinates (and simply returns 0 in TextField)\n+                    \/\/ which makes no sense!\n+                    \/\/ BTW, could never hit this breakpoint.\n+                    \/\/\n+                    \/\/ CInputMethod.characterIndexForPoint():\n+                    \/\/ Gets the offset within the composed text for the specified absolute x and y coordinates on the screen.\n+                    \/\/ This information is used, for example to handle mouse clicks and the mouse cursor.\n+                    \/\/ The offset is relative to the composed text, so offset 0 indicates the beginning of the composed text.\n+                    TextPos pos = vflow.getTextPosLocal(x, y);\n+                    return pos.offset() - ime.start.offset();\n@@ -170,1 +212,1 @@\n-                    System.out.println(\"cancelLatestCommittedText\"); \/\/ FIX\n+                    \/\/ no-op as in TextInputControlSkin\n@@ -173,1 +215,1 @@\n-            \/\/ TODO getSkinnable().setInputMethodRequests(inputMethodRequests);\n+            rta.setInputMethodRequests(inputMethodRequests);\n@@ -179,3 +221,4 @@\n-        if (getSkinnable() != null) {\n-            if (getSkinnable().getInputMethodRequests() == inputMethodRequests) {\n-                getSkinnable().setInputMethodRequests(null);\n+        RichTextArea rta = getSkinnable();\n+        if (rta != null) {\n+            if (rta.getInputMethodRequests() == inputMethodRequests) {\n+                rta.setInputMethodRequests(null);\n@@ -183,2 +226,2 @@\n-            if (getSkinnable().getOnInputMethodTextChanged() == inputMethodTextChangedHandler) {\n-                getSkinnable().setOnInputMethodTextChanged(null);\n+            if (rta.getOnInputMethodTextChanged() == inputMethodTextChangedHandler) {\n+                rta.setOnInputMethodTextChanged(null);\n@@ -195,0 +238,136 @@\n+    private void handleInputMethodEvent(InputMethodEvent ev) {\n+        RichTextArea rta = getSkinnable();\n+        if (RichUtils.canEdit(rta) && !rta.isDisabled()) {\n+            SelectionSegment sel = rta.getSelection();\n+            if (sel == null) {\n+                return; \/\/ should not happen\n+            }\n+\n+            \/\/ remove previous input method text (if any) or selected text\n+            TextPos rEnd = sel.getMax();\n+            if (ime != null) {\n+                if (ime.shapes != null) {\n+                    vflow.removeImHighlight(ime.shapes);\n+                    ime.shapes = null;\n+                }\n+                \/\/ imeStart is valid\n+                rEnd = RichUtils.advancePosition(ime.start, ime.length);\n+            } else {\n+                ime = new Ime();\n+                ime.start = sel.getMin();\n+            }\n+\n+            String text = RichUtils.getImeText(ev);\n+            ime.length = text.length();\n+\n+            \/\/ replace selection or previous ime text with composed or committed text\n+            rta.replaceText(ime.start, rEnd, text, false);\n+\n+            \/\/ add ime shapes\n+            TextPos end = ime.start;\n+            if (ev.getComposed().size() > 0) {\n+                ime.shapes = new ArrayList<>();\n+                TextPos pos = ime.start;\n+                for (InputMethodTextRun run : ev.getComposed()) {\n+                    end = RichUtils.advancePosition(pos, run.getText().length());\n+                    appendImeShapes(ime.shapes, run.getHighlight(), pos, end);\n+                    pos = end;\n+                }\n+                vflow.addImeHighlights(ime.shapes, ime.start);\n+            } else {\n+                ime.shapes = null;\n+                end = RichUtils.advancePosition(ime.start, text.length());\n+            }\n+            rta.select(end);\n+\n+            if ((ev.getCommitted().length() > 0) || (ime.length == 0)) {\n+                if (ime.shapes != null) {\n+                    vflow.removeImHighlight(ime.shapes);\n+                }\n+                ime = null;\n+            }\n+            ev.consume();\n+        }\n+    }\n+\n+    private void appendImeShapes(List<Shape> shapes, InputMethodHighlight highlight, TextPos start, TextPos end) {\n+        double minX = 0.0;\n+        double maxX = 0.0;\n+        double minY = 0.0;\n+        double maxY = 0.0;\n+\n+        List<PathElement> elements = vflow.getUnderlineShape(start, end);\n+        int sz = elements.size();\n+        for (int i = 0; i < sz; i++) {\n+            PathElement pe = elements.get(i);\n+            if (pe instanceof MoveTo em) {\n+                minX = maxX = em.getX();\n+                minY = maxY = em.getY();\n+            } else if (pe instanceof LineTo em) {\n+                minX = (minX < em.getX() ? minX : em.getX());\n+                maxX = (maxX > em.getX() ? maxX : em.getX());\n+                minY = (minY < em.getY() ? minY : em.getY());\n+                maxY = (maxY > em.getY() ? maxY : em.getY());\n+            } else if (pe instanceof HLineTo em) {\n+                minX = (minX < em.getX() ? minX : em.getX());\n+                maxX = (maxX > em.getX() ? maxX : em.getX());\n+            } else if (pe instanceof VLineTo em) {\n+                minY = (minY < em.getY() ? minY : em.getY());\n+                maxY = (maxY > em.getY() ? maxY : em.getY());\n+            }\n+            \/\/ don't assume that shapes are ended with ClosePath\n+            if (\n+                pe instanceof ClosePath ||\n+                i == sz - 1 ||\n+                (i < sz - 1 && elements.get(i + 1) instanceof MoveTo)\n+            )\n+            {\n+                \/\/ create the shape\n+                Shape sh = null;\n+                switch(highlight) {\n+                case SELECTED_RAW:\n+                    \/\/ blue background\n+                    sh = new Path(vflow.getRangeShape(start, end));\n+                    sh.setFill(imeSelectColor());\n+                    sh.setOpacity(0.3);\n+                    break;\n+                case UNSELECTED_RAW:\n+                    \/\/ dash underline\n+                    sh = new Line(minX + 2, maxY + 1, maxX - 2, maxY + 1);\n+                    sh.setStroke(imeColor());\n+                    sh.setStrokeWidth(maxY - minY);\n+                    ObservableList<Double> dashArray = sh.getStrokeDashArray();\n+                    dashArray.add(2.0);\n+                    dashArray.add(2.0);\n+                    break;\n+                case SELECTED_CONVERTED:\n+                    \/\/ thick underline\n+                    sh = new Line(minX + 2, maxY + 1, maxX - 2, maxY + 1);\n+                    sh.setStroke(imeColor());\n+                    sh.setStrokeWidth((maxY - minY) * 3);\n+                    break;\n+                case UNSELECTED_CONVERTED:\n+                    \/\/ single underline\n+                    sh = new Line(minX + 2, maxY + 1, maxX - 2, maxY + 1);\n+                    sh.setStroke(imeColor());\n+                    sh.setStrokeWidth(maxY - minY);\n+                    break;\n+                }\n+\n+                if (sh != null) {\n+                    sh.setManaged(false);\n+                    shapes.add(sh);\n+                }\n+            }\n+        }\n+    }\n+\n+    private Color imeColor() {\n+        return RichUtils.isDarkScheme(getSkinnable()) ? Color.WHITE : Color.BLACK;\n+    }\n+\n+    private Color imeSelectColor() {\n+        \/\/ TODO might depend on the color scheme\n+        return Color.BLUE;\n+    }\n+\n@@ -318,49 +497,0 @@\n-    \/**\n-     * Handles an input method event.\n-     * @param ev the {@code InputMethodEvent} to be handled\n-     *\/\n-    private void handleInputMethodEvent(InputMethodEvent ev) {\n-        RichTextArea textInput = getSkinnable();\n-        \/** TODO this is taken from TextInputControlSkin:763\n-        if (textInput.isEditable() && !textInput.textProperty().isBound() && !textInput.isDisabled()) {\n-\n-            \/\/ remove previous input method text (if any) or selected text\n-            if (imlength != 0) {\n-                removeHighlight(imattrs);\n-                imattrs.clear();\n-                textInput.selectRange(imstart, imstart + imlength);\n-            }\n-\n-            \/\/ Insert committed text\n-            if (ev.getCommitted().length() != 0) {\n-                String committed = ev.getCommitted();\n-                textInput.replaceText(textInput.getSelection(), committed);\n-            }\n-\n-            \/\/ Replace composed text\n-            imstart = textInput.getSelection().getStart();\n-            StringBuilder composed = new StringBuilder();\n-            for (InputMethodTextRun run : ev.getComposed()) {\n-                composed.append(run.getText());\n-            }\n-            textInput.replaceText(textInput.getSelection(), composed.toString());\n-            imlength = composed.length();\n-            if (imlength != 0) {\n-                int pos = imstart;\n-                for (InputMethodTextRun run : ev.getComposed()) {\n-                    int endPos = pos + run.getText().length();\n-                    createInputMethodAttributes(run.getHighlight(), pos, endPos);\n-                    pos = endPos;\n-                }\n-                addHighlight(imattrs, imstart);\n-\n-                \/\/ Set caret position in composed text\n-                int caretPos = ev.getCaretPosition();\n-                if (caretPos >= 0 && caretPos < imlength) {\n-                    textInput.selectRange(imstart + caretPos, imstart + caretPos);\n-                }\n-            }\n-        }\n-        *\/\n-    }\n-\n@@ -465,0 +595,7 @@\n+\n+    \/\/ while IME is active\n+    static class Ime {\n+        public TextPos start;\n+        public int length;\n+        public List<Shape> shapes;\n+    }\n","filename":"modules\/jfx.incubator.richtext\/src\/main\/java\/jfx\/incubator\/scene\/control\/richtext\/skin\/RichTextAreaSkin.java","additions":205,"deletions":68,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.ArrayList;\n@@ -39,0 +40,1 @@\n+import javafx.event.Event;\n@@ -45,0 +47,3 @@\n+import javafx.scene.input.InputMethodEvent;\n+import javafx.scene.input.InputMethodHighlight;\n+import javafx.scene.input.InputMethodTextRun;\n@@ -691,0 +696,37 @@\n+\n+    private void fireIME(int caret, String committed, Object... runs) {\n+        ArrayList<InputMethodTextRun> composed = new ArrayList<>();\n+        for (int i = 0; i < runs.length;) {\n+            String s = (String)runs[i++];\n+            InputMethodHighlight h = (InputMethodHighlight)runs[i++];\n+            composed.add(new InputMethodTextRun(s, h));\n+        }\n+        InputMethodEvent ev = new InputMethodEvent(InputMethodEvent.INPUT_METHOD_TEXT_CHANGED, composed, committed, caret);\n+        Event.fireEvent(control, ev);\n+    }\n+\n+    private static TextPos tp(int caret) {\n+        return new TextPos(0, caret, caret - 1, false);\n+    }\n+\n+    @Test\n+    public void testIME() {\n+        TextPos p = new TextPos(0, 0, 0, false);\n+        control.select(p);\n+        \/\/ compose \"a\" \"b\"\n+        fireIME(0, \"\", \"a\", InputMethodHighlight.UNSELECTED_RAW, \"b\", InputMethodHighlight.UNSELECTED_RAW);\n+        assertEquals(tp(2), control.getCaretPosition());\n+        assertEquals(\"ab\", text());\n+        \/\/ escape, cancel composition\n+        fireIME(0, \"\");\n+        assertEquals(TextPos.ofLeading(0, 0), control.getCaretPosition());\n+        assertEquals(\"\", text());\n+        \/\/ compose, \"c\" \"d\"\n+        fireIME(0, \"\", \"c\", InputMethodHighlight.UNSELECTED_RAW, \"d\", InputMethodHighlight.UNSELECTED_RAW);\n+        assertEquals(tp(2), control.getCaretPosition());\n+        assertEquals(\"cd\", text());\n+        \/\/ commit \"yoyo\"\n+        fireIME(0, \"yoyo\");\n+        assertEquals(tp(4), control.getCaretPosition());\n+        assertEquals(\"yoyo\", text());\n+    }\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/jfx\/incubator\/scene\/control\/richtext\/RichTextAreaTest.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"}]}