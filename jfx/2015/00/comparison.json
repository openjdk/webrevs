{"files":[{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.beans.property;\n+\n+\/**\n+ * Marker interface for attached properties.\n+ * <p>\n+ * An attached property is {@linkplain ReadOnlyProperty#getDeclaringClass() declared} on one class, but associated\n+ * with instances of another class (referred to as the <em>target<\/em> class). It is usually used to describe an\n+ * aspect about the target <em>as it relates to<\/em> the declaring class. Property implementations that represent\n+ * attached properties must implement this interface to expose the class of objects the property can be attached to.\n+ * <p>\n+ * Note that the {@code AttachedProperty} interface might not be visible in the static type of the property, so\n+ * a dynamic test via {@code instanceof AttachedProperty} might be required at runtime to detect its presence.\n+ *\n+ * @since 27\n+ *\/\n+public interface AttachedProperty {\n+\n+    \/**\n+     * Returns the class of objects to which this property can be attached.\n+     *\n+     * @return the target class\n+     *\/\n+    Class<?> getTargetClass();\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/AttachedProperty.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,25 @@\n+    \/**\n+     * The constructor of {@code ReadOnlyBooleanWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public ReadOnlyBooleanWrapper(Object bean, Class<?> declaringClass, String name) {\n+        super(bean, declaringClass, name);\n+    }\n+\n+    \/**\n+     * The constructor of {@code ReadOnlyBooleanWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public ReadOnlyBooleanWrapper(Object bean, Class<?> declaringClass, String name, boolean initialValue) {\n+        super(bean, declaringClass, name, initialValue);\n+    }\n+\n@@ -91,1 +116,3 @@\n-            readOnlyProperty = new ReadOnlyPropertyImpl();\n+            readOnlyProperty = this instanceof AttachedProperty\n+                ? new AttachedReadOnlyPropertyImpl()\n+                : new ReadOnlyPropertyImpl();\n@@ -123,0 +150,13 @@\n+\n+        @Override\n+        public Class<?> getDeclaringClass() {\n+            return ReadOnlyBooleanWrapper.this.getDeclaringClass();\n+        }\n+    }\n+\n+    private class AttachedReadOnlyPropertyImpl extends ReadOnlyPropertyImpl implements AttachedProperty {\n+\n+        @Override\n+        public Class<?> getTargetClass() {\n+            return ((AttachedProperty)ReadOnlyBooleanWrapper.this).getTargetClass();\n+        }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyBooleanWrapper.java","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,25 @@\n+    \/**\n+     * The constructor of {@code ReadOnlyDoubleWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public ReadOnlyDoubleWrapper(Object bean, Class<?> declaringClass, String name) {\n+        super(bean, declaringClass, name);\n+    }\n+\n+    \/**\n+     * The constructor of {@code ReadOnlyDoubleWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public ReadOnlyDoubleWrapper(Object bean, Class<?> declaringClass, String name, double initialValue) {\n+        super(bean, declaringClass, name, initialValue);\n+    }\n+\n@@ -91,1 +116,3 @@\n-            readOnlyProperty = new ReadOnlyPropertyImpl();\n+            readOnlyProperty = this instanceof AttachedProperty\n+                ? new AttachedReadOnlyPropertyImpl()\n+                : new ReadOnlyPropertyImpl();\n@@ -123,0 +150,13 @@\n+\n+        @Override\n+        public Class<?> getDeclaringClass() {\n+            return ReadOnlyDoubleWrapper.this.getDeclaringClass();\n+        }\n+    }\n+\n+    private class AttachedReadOnlyPropertyImpl extends ReadOnlyPropertyImpl implements AttachedProperty {\n+\n+        @Override\n+        public Class<?> getTargetClass() {\n+            return ((AttachedProperty)ReadOnlyDoubleWrapper.this).getTargetClass();\n+        }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyDoubleWrapper.java","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,0 +82,25 @@\n+    \/**\n+     * The constructor of {@code ReadOnlyFloatWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public ReadOnlyFloatWrapper(Object bean, Class<?> declaringClass, String name) {\n+        super(bean, declaringClass, name);\n+    }\n+\n+    \/**\n+     * The constructor of {@code ReadOnlyFloatWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public ReadOnlyFloatWrapper(Object bean, Class<?> declaringClass, String name, float initialValue) {\n+        super(bean, declaringClass, name, initialValue);\n+    }\n+\n@@ -90,1 +115,3 @@\n-            readOnlyProperty = new ReadOnlyPropertyImpl();\n+            readOnlyProperty = this instanceof AttachedProperty\n+                ? new AttachedReadOnlyPropertyImpl()\n+                : new ReadOnlyPropertyImpl();\n@@ -122,0 +149,13 @@\n+\n+        @Override\n+        public Class<?> getDeclaringClass() {\n+            return ReadOnlyFloatWrapper.this.getDeclaringClass();\n+        }\n+    }\n+\n+    private class AttachedReadOnlyPropertyImpl extends ReadOnlyPropertyImpl implements AttachedProperty {\n+\n+        @Override\n+        public Class<?> getTargetClass() {\n+            return ((AttachedProperty)ReadOnlyFloatWrapper.this).getTargetClass();\n+        }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyFloatWrapper.java","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,0 +82,25 @@\n+    \/**\n+     * The constructor of {@code ReadOnlyIntegerWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public ReadOnlyIntegerWrapper(Object bean, Class<?> declaringClass, String name) {\n+        super(bean, declaringClass, name);\n+    }\n+\n+    \/**\n+     * The constructor of {@code ReadOnlyIntegerWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public ReadOnlyIntegerWrapper(Object bean, Class<?> declaringClass, String name, int initialValue) {\n+        super(bean, declaringClass, name, initialValue);\n+    }\n+\n@@ -90,1 +115,3 @@\n-            readOnlyProperty = new ReadOnlyPropertyImpl();\n+            readOnlyProperty = this instanceof AttachedProperty\n+                ? new AttachedReadOnlyPropertyImpl()\n+                : new ReadOnlyPropertyImpl();\n@@ -122,0 +149,13 @@\n+\n+        @Override\n+        public Class<?> getDeclaringClass() {\n+            return ReadOnlyIntegerWrapper.this.getDeclaringClass();\n+        }\n+    }\n+\n+    private class AttachedReadOnlyPropertyImpl extends ReadOnlyPropertyImpl implements AttachedProperty {\n+\n+        @Override\n+        public Class<?> getTargetClass() {\n+            return ((AttachedProperty)ReadOnlyIntegerWrapper.this).getTargetClass();\n+        }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyIntegerWrapper.java","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,0 +87,25 @@\n+    \/**\n+     * The constructor of {@code ReadOnlyListWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public ReadOnlyListWrapper(Object bean, Class<?> declaringClass, String name) {\n+        super(bean, declaringClass, name);\n+    }\n+\n+    \/**\n+     * The constructor of {@code ReadOnlyListWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public ReadOnlyListWrapper(Object bean, Class<?> declaringClass, String name, ObservableList<E> initialValue) {\n+        super(bean, declaringClass, name, initialValue);\n+    }\n+\n@@ -95,1 +120,3 @@\n-            readOnlyProperty = new ReadOnlyPropertyImpl();\n+            readOnlyProperty = this instanceof AttachedProperty\n+                ? new AttachedReadOnlyPropertyImpl()\n+                : new ReadOnlyPropertyImpl();\n@@ -140,0 +167,5 @@\n+        @Override\n+        public Class<?> getDeclaringClass() {\n+            return ReadOnlyListWrapper.this.getDeclaringClass();\n+        }\n+\n@@ -150,0 +182,8 @@\n+\n+    private class AttachedReadOnlyPropertyImpl extends ReadOnlyPropertyImpl implements AttachedProperty {\n+\n+        @Override\n+        public Class<?> getTargetClass() {\n+            return ((AttachedProperty)ReadOnlyListWrapper.this).getTargetClass();\n+        }\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyListWrapper.java","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,0 +82,25 @@\n+    \/**\n+     * The constructor of {@code ReadOnlyLongWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public ReadOnlyLongWrapper(Object bean, Class<?> declaringClass, String name) {\n+        super(bean, declaringClass, name);\n+    }\n+\n+    \/**\n+     * The constructor of {@code ReadOnlyLongWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public ReadOnlyLongWrapper(Object bean, Class<?> declaringClass, String name, long initialValue) {\n+        super(bean, declaringClass, name, initialValue);\n+    }\n+\n@@ -90,1 +115,3 @@\n-            readOnlyProperty = new ReadOnlyPropertyImpl();\n+            readOnlyProperty = this instanceof AttachedProperty\n+                ? new AttachedReadOnlyPropertyImpl()\n+                : new ReadOnlyPropertyImpl();\n@@ -122,0 +149,13 @@\n+\n+        @Override\n+        public Class<?> getDeclaringClass() {\n+            return ReadOnlyLongWrapper.this.getDeclaringClass();\n+        }\n+    }\n+\n+    private class AttachedReadOnlyPropertyImpl extends ReadOnlyPropertyImpl implements AttachedProperty {\n+\n+        @Override\n+        public Class<?> getTargetClass() {\n+            return ((AttachedProperty)ReadOnlyLongWrapper.this).getTargetClass();\n+        }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyLongWrapper.java","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,25 @@\n+    \/**\n+     * The constructor of {@code ReadOnlyMapWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public ReadOnlyMapWrapper(Object bean, Class<?> declaringClass, String name) {\n+        super(bean, declaringClass, name);\n+    }\n+\n+    \/**\n+     * The constructor of {@code ReadOnlyMapWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public ReadOnlyMapWrapper(Object bean, Class<?> declaringClass, String name, ObservableMap<K, V> initialValue) {\n+        super(bean, declaringClass, name, initialValue);\n+    }\n+\n@@ -96,1 +121,3 @@\n-            readOnlyProperty = new ReadOnlyPropertyImpl();\n+            readOnlyProperty = this instanceof AttachedProperty\n+                ? new AttachedReadOnlyPropertyImpl()\n+                : new ReadOnlyPropertyImpl();\n@@ -140,0 +167,5 @@\n+        @Override\n+        public Class<?> getDeclaringClass() {\n+            return ReadOnlyMapWrapper.this.getDeclaringClass();\n+        }\n+\n@@ -150,0 +182,8 @@\n+\n+    private class AttachedReadOnlyPropertyImpl extends ReadOnlyPropertyImpl implements AttachedProperty {\n+\n+        @Override\n+        public Class<?> getTargetClass() {\n+            return ((AttachedProperty)ReadOnlyMapWrapper.this).getTargetClass();\n+        }\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyMapWrapper.java","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,25 @@\n+    \/**\n+     * The constructor of {@code ReadOnlyObjectWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public ReadOnlyObjectWrapper(Object bean, Class<?> declaringClass, String name) {\n+        super(bean, declaringClass, name);\n+    }\n+\n+    \/**\n+     * The constructor of {@code ReadOnlyObjectWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public ReadOnlyObjectWrapper(Object bean, Class<?> declaringClass, String name, T initialValue) {\n+        super(bean, declaringClass, name, initialValue);\n+    }\n+\n@@ -91,1 +116,3 @@\n-            readOnlyProperty = new ReadOnlyPropertyImpl();\n+            readOnlyProperty = this instanceof AttachedProperty\n+                ? new AttachedReadOnlyPropertyImpl()\n+                : new ReadOnlyPropertyImpl();\n@@ -123,0 +150,13 @@\n+\n+        @Override\n+        public Class<?> getDeclaringClass() {\n+            return ReadOnlyObjectWrapper.this.getDeclaringClass();\n+        }\n+    }\n+\n+    private class AttachedReadOnlyPropertyImpl extends ReadOnlyPropertyImpl implements AttachedProperty {\n+\n+        @Override\n+        public Class<?> getTargetClass() {\n+            return ((AttachedProperty)ReadOnlyObjectWrapper.this).getTargetClass();\n+        }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyObjectWrapper.java","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n@@ -57,0 +59,49 @@\n+    \/**\n+     * Returns the {@code Class} in which this property was declared.\n+     * If this property is not contained in an object, {@code null} is returned.\n+     *\n+     * @return   the declaring class of this property, or {@code null}\n+     * @implSpec Implementations of {@linkplain AttachedProperty attached properties} must override this method\n+     *           and return the declaring class of the attached property, as the default implementation will not\n+     *           be able to discover the declaring class at runtime.\n+     * @implNote For instance properties, the default implementation uses reflection to search for a method\n+     *           with a signature compatible with {@code ReadOnlyProperty<?> <name>Property()}, where\n+     *           {@code <name>} is the name of the property as returned by the {@link #getName()} method.\n+     *           The return type must be a subtype of {@code ReadOnlyProperty<?>}. The class that declares\n+     *           such a method is the declaring class of the property.\n+     *           However, implementations are advised to override this method and return the declaring class\n+     *           directly, instead of relying on the reflective auto-discovery mechanism. Attached properties\n+     *           must always override this method.\n+     * @since 27\n+     *\/\n+    default Class<?> getDeclaringClass() {\n+        Object bean = getBean();\n+        if (bean == null) {\n+            return null;\n+        }\n+\n+        String name = getName();\n+        if (name == null || name.isEmpty()) {\n+            return null;\n+        }\n+\n+        Class<?> beanClass = bean.getClass();\n+        String propertyName = name + \"Property\";\n+\n+        do {\n+            try {\n+                Method method = beanClass.getDeclaredMethod(propertyName);\n+\n+                if ((method.getModifiers() & Modifier.STATIC) == 0\n+                        && ReadOnlyProperty.class.isAssignableFrom(method.getReturnType())) {\n+                    return beanClass;\n+                }\n+            } catch (NoSuchMethodException ignored) {\n+                \/\/ fall through\n+            }\n+\n+            beanClass = beanClass.getSuperclass();\n+        } while (beanClass != null);\n+\n+        return null;\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyProperty.java","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,0 +87,25 @@\n+    \/**\n+     * The constructor of {@code ReadOnlySetWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public ReadOnlySetWrapper(Object bean, Class<?> declaringClass, String name) {\n+        super(bean, declaringClass, name);\n+    }\n+\n+    \/**\n+     * The constructor of {@code ReadOnlySetWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public ReadOnlySetWrapper(Object bean, Class<?> declaringClass, String name, ObservableSet<E> initialValue) {\n+        super(bean, declaringClass, name, initialValue);\n+    }\n+\n@@ -95,1 +120,3 @@\n-            readOnlyProperty = new ReadOnlyPropertyImpl();\n+            readOnlyProperty = this instanceof AttachedProperty\n+                ? new AttachedReadOnlyPropertyImpl()\n+                : new ReadOnlyPropertyImpl();\n@@ -139,0 +166,5 @@\n+        @Override\n+        public Class<?> getDeclaringClass() {\n+            return ReadOnlySetWrapper.this.getDeclaringClass();\n+        }\n+\n@@ -149,0 +181,8 @@\n+\n+    private class AttachedReadOnlyPropertyImpl extends ReadOnlyPropertyImpl implements AttachedProperty {\n+\n+        @Override\n+        public Class<?> getTargetClass() {\n+            return ((AttachedProperty)ReadOnlySetWrapper.this).getTargetClass();\n+        }\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlySetWrapper.java","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,0 +83,25 @@\n+    \/**\n+     * The constructor of {@code ReadOnlyStringWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public ReadOnlyStringWrapper(Object bean, Class<?> declaringClass, String name) {\n+        super(bean, declaringClass, name);\n+    }\n+\n+    \/**\n+     * The constructor of {@code ReadOnlyStringWrapper}\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public ReadOnlyStringWrapper(Object bean, Class<?> declaringClass, String name, String initialValue) {\n+        super(bean, declaringClass, name, initialValue);\n+    }\n+\n@@ -91,1 +116,3 @@\n-            readOnlyProperty = new ReadOnlyPropertyImpl();\n+            readOnlyProperty = this instanceof AttachedProperty\n+                ? new AttachedReadOnlyPropertyImpl()\n+                : new ReadOnlyPropertyImpl();\n@@ -123,0 +150,13 @@\n+\n+        @Override\n+        public Class<?> getDeclaringClass() {\n+            return ReadOnlyStringWrapper.this.getDeclaringClass();\n+        }\n+    }\n+\n+    private class AttachedReadOnlyPropertyImpl extends ReadOnlyPropertyImpl implements AttachedProperty {\n+\n+        @Override\n+        public Class<?> getTargetClass() {\n+            return ((AttachedProperty)ReadOnlyStringWrapper.this).getTargetClass();\n+        }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/ReadOnlyStringWrapper.java","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+    private Class<?> declaringClass;\n@@ -60,0 +61,14 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 27\n+     *\/\n+    @Override\n+    public Class<?> getDeclaringClass() {\n+        if (declaringClass != null) {\n+            return declaringClass;\n+        }\n+\n+        return declaringClass = super.getDeclaringClass();\n+    }\n+\n@@ -106,0 +121,29 @@\n+    \/**\n+     * The constructor of {@code SimpleBooleanProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public SimpleBooleanProperty(Object bean, Class<?> declaringClass, String name) {\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n+\n+    \/**\n+     * The constructor of {@code SimpleBooleanProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public SimpleBooleanProperty(Object bean, Class<?> declaringClass, String name, boolean initialValue) {\n+        super(initialValue);\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/SimpleBooleanProperty.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+    private Class<?> declaringClass;\n@@ -60,0 +61,14 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 27\n+     *\/\n+    @Override\n+    public Class<?> getDeclaringClass() {\n+        if (declaringClass != null) {\n+            return declaringClass;\n+        }\n+\n+        return declaringClass = super.getDeclaringClass();\n+    }\n+\n@@ -106,0 +121,29 @@\n+    \/**\n+     * The constructor of {@code SimpleDoubleProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public SimpleDoubleProperty(Object bean, Class<?> declaringClass, String name) {\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n+\n+    \/**\n+     * The constructor of {@code SimpleDoubleProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public SimpleDoubleProperty(Object bean, Class<?> declaringClass, String name, double initialValue) {\n+        super(initialValue);\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/SimpleDoubleProperty.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+    private Class<?> declaringClass;\n@@ -60,0 +61,14 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 27\n+     *\/\n+    @Override\n+    public Class<?> getDeclaringClass() {\n+        if (declaringClass != null) {\n+            return declaringClass;\n+        }\n+\n+        return declaringClass = super.getDeclaringClass();\n+    }\n+\n@@ -106,0 +121,29 @@\n+    \/**\n+     * The constructor of {@code SimpleFloatProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public SimpleFloatProperty(Object bean, Class<?> declaringClass, String name) {\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n+\n+    \/**\n+     * The constructor of {@code SimpleFloatProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public SimpleFloatProperty(Object bean, Class<?> declaringClass, String name, float initialValue) {\n+        super(initialValue);\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/SimpleFloatProperty.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+    private Class<?> declaringClass;\n@@ -60,0 +61,14 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 27\n+     *\/\n+    @Override\n+    public Class<?> getDeclaringClass() {\n+        if (declaringClass != null) {\n+            return declaringClass;\n+        }\n+\n+        return declaringClass = super.getDeclaringClass();\n+    }\n+\n@@ -106,0 +121,29 @@\n+    \/**\n+     * The constructor of {@code SimpleIntegerProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public SimpleIntegerProperty(Object bean, Class<?> declaringClass, String name) {\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n+\n+    \/**\n+     * The constructor of {@code SimpleIntegerProperty}.\n+     *\n+     * @param declaringClass the class in which this property is declared\n+     * @param bean the bean of this property\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public SimpleIntegerProperty(Object bean, Class<?> declaringClass, String name, int initialValue) {\n+        super(initialValue);\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/SimpleIntegerProperty.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+    private Class<?> declaringClass;\n@@ -63,0 +64,14 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 27\n+     *\/\n+    @Override\n+    public Class<?> getDeclaringClass() {\n+        if (declaringClass != null) {\n+            return declaringClass;\n+        }\n+\n+        return declaringClass = super.getDeclaringClass();\n+    }\n+\n@@ -109,0 +124,29 @@\n+    \/**\n+     * The constructor of {@code SimpleListProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public SimpleListProperty(Object bean, Class<?> declaringClass, String name) {\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n+\n+    \/**\n+     * The constructor of {@code SimpleListProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public SimpleListProperty(Object bean, Class<?> declaringClass, String name, ObservableList<E> initialValue) {\n+        super(initialValue);\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/SimpleListProperty.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+    private Class<?> declaringClass;\n@@ -60,0 +61,14 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 27\n+     *\/\n+    @Override\n+    public Class<?> getDeclaringClass() {\n+        if (declaringClass != null) {\n+            return declaringClass;\n+        }\n+\n+        return declaringClass = super.getDeclaringClass();\n+    }\n+\n@@ -106,0 +121,29 @@\n+    \/**\n+     * The constructor of {@code SimpleLongProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public SimpleLongProperty(Object bean, Class<?> declaringClass, String name) {\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n+\n+    \/**\n+     * The constructor of {@code SimpleLongProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public SimpleLongProperty(Object bean, Class<?> declaringClass, String name, long initialValue) {\n+        super(initialValue);\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/SimpleLongProperty.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+    private Class<?> declaringClass;\n@@ -64,0 +65,14 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 27\n+     *\/\n+    @Override\n+    public Class<?> getDeclaringClass() {\n+        if (declaringClass != null) {\n+            return declaringClass;\n+        }\n+\n+        return declaringClass = super.getDeclaringClass();\n+    }\n+\n@@ -110,0 +125,29 @@\n+    \/**\n+     * The constructor of {@code SimpleMapProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public SimpleMapProperty(Object bean, Class<?> declaringClass, String name) {\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n+\n+    \/**\n+     * The constructor of {@code SimpleMapProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public SimpleMapProperty(Object bean, Class<?> declaringClass, String name, ObservableMap<K, V> initialValue) {\n+        super(initialValue);\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/SimpleMapProperty.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+    private Class<?> declaringClass;\n@@ -63,0 +64,14 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 27\n+     *\/\n+    @Override\n+    public Class<?> getDeclaringClass() {\n+        if (declaringClass != null) {\n+            return declaringClass;\n+        }\n+\n+        return declaringClass = super.getDeclaringClass();\n+    }\n+\n@@ -109,0 +124,29 @@\n+    \/**\n+     * The constructor of {@code SimpleObjectProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public SimpleObjectProperty(Object bean, Class<?> declaringClass, String name) {\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n+\n+    \/**\n+     * The constructor of {@code SimpleObjectProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public SimpleObjectProperty(Object bean, Class<?> declaringClass, String name, T initialValue) {\n+        super(initialValue);\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/SimpleObjectProperty.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+    private Class<?> declaringClass;\n@@ -63,0 +64,14 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 27\n+     *\/\n+    @Override\n+    public Class<?> getDeclaringClass() {\n+        if (declaringClass != null) {\n+            return declaringClass;\n+        }\n+\n+        return declaringClass = super.getDeclaringClass();\n+    }\n+\n@@ -109,0 +124,29 @@\n+    \/**\n+     * The constructor of {@code SimpleSetProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public SimpleSetProperty(Object bean, Class<?> declaringClass, String name) {\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n+\n+    \/**\n+     * The constructor of {@code SimpleSetProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public SimpleSetProperty(Object bean, Class<?> declaringClass, String name, ObservableSet<E> initialValue) {\n+        super(initialValue);\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/SimpleSetProperty.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+    private Class<?> declaringClass;\n@@ -60,0 +61,14 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 27\n+     *\/\n+    @Override\n+    public Class<?> getDeclaringClass() {\n+        if (declaringClass != null) {\n+            return declaringClass;\n+        }\n+\n+        return declaringClass = super.getDeclaringClass();\n+    }\n+\n@@ -106,0 +121,29 @@\n+    \/**\n+     * The constructor of {@code SimpleStringProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @since 27\n+     *\/\n+    public SimpleStringProperty(Object bean, Class<?> declaringClass, String name) {\n+        this.bean = bean;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+        this.declaringClass = declaringClass;\n+    }\n+\n+    \/**\n+     * The constructor of {@code SimpleStringProperty}.\n+     *\n+     * @param bean the bean of this property\n+     * @param declaringClass the class in which this property is declared\n+     * @param name the name of this property\n+     * @param initialValue the initial value\n+     * @since 27\n+     *\/\n+    public SimpleStringProperty(Object bean, Class<?> declaringClass, String name, String initialValue) {\n+        super(initialValue);\n+        this.bean = bean;\n+        this.declaringClass = declaringClass;\n+        this.name = (name == null) ? DEFAULT_NAME : name;\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/property\/SimpleStringProperty.java","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-        final StringProperty v3 = new SimpleStringProperty(bean, null, VALUE_1);\n+        final StringProperty v3 = new SimpleStringProperty(bean, (String)null, VALUE_1);\n@@ -97,1 +97,1 @@\n-        final StringProperty v4 = new SimpleStringProperty(bean, null, DEFAULT_VALUE);\n+        final StringProperty v4 = new SimpleStringProperty(bean, (String)null, DEFAULT_VALUE);\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/property\/SimpleStringPropertyTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,332 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.util.property;\n+\n+import javafx.beans.property.AttachedProperty;\n+import javafx.beans.property.ReadOnlyProperty;\n+import test.javafx.util.ReflectionUtils;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public final class PropertyMetadataVerifier {\n+\n+    private PropertyMetadataVerifier() {}\n+\n+    \/**\n+     * Asserts that property implementations for all public or protected properties of the specified object\n+     * conform to the following rules:\n+     * <ul>\n+     *     <li>{@link ReadOnlyProperty#getBean()} returns the object instance of the enclosing class,\n+     *         or the target object instance if the property is an attached property\n+     *     <li>{@link ReadOnlyProperty#getName()} returns the name of the property, which must\n+     *         correspond to the name of the property getter (excluding the word \"Property\")\n+     *     <li>{@link ReadOnlyProperty#getDeclaringClass()} returns the enclosing class of the property getter\n+     *     <li>The declaring class of a {@code Simple<*>Property} or {@code ReadOnly<*>Wrapper} must be\n+     *         specified in the constructor, not resolved at runtime\n+     *     <li>{@code getBean()}, {@code getName()}, and {@code getDeclaringClass()} must not be overridden\n+     *         in subclasses of {@code Simple<*>Property} or {@code ReadOnly<*>Wrapper}\n+     *     <li>An instance property does not implement {@link AttachedProperty}\n+     *     <li>An instance property has a parameterless property getter\n+     *     <li>An attached property implements {@code AttachedProperty}\n+     *     <li>An attached property has a static single-argument property getter that accepts the target object\n+     *     <li>{@link AttachedProperty#getTargetClass()} returns the class of the single parameter of the\n+     *         static property getter\n+     *     <li>A property getter does not return an instance of {@code ReadOnly<*>Wrapper}, it returns\n+     *         the result of calling {@code ReadOnly<*>Wrapper.getReadOnlyProperty()}\n+     * <\/ul>\n+     *\n+     * @param bean an object of the specified class\n+     * @param declaringClass the class that declares the properties to be tested\n+     *\/\n+    public static <T> void assertPropertyMetadata(T bean, Class<T> declaringClass) {\n+        assertPropertyMetadata(bean, declaringClass, _ -> null);\n+    }\n+\n+    \/**\n+     * Asserts that property implementations for all public or protected properties of the specified object\n+     * conform to the rules as specified in {@link #assertPropertyMetadata(Object, Class)}.\n+     * <p>\n+     * This method must be used if the declaring class includes attached properties, and the specified\n+     * supplier must return target objects for all attached properties encountered in the class.\n+     *\n+     * @param bean an object of the specified class\n+     * @param declaringClass the class that declares the properties to be tested\n+     * @param targetObjectSupplier a function that supplies the target object for attached properties\n+     *\/\n+    public static <T> void assertPropertyMetadata(\n+            T bean, Class<T> declaringClass, Function<Class<?>, Object> targetObjectSupplier) {\n+        try {\n+            assertPropertyMetadataImpl(bean, declaringClass, targetObjectSupplier);\n+        } catch (ReflectiveOperationException e) {\n+            fail(e.getMessage(), e);\n+        }\n+    }\n+\n+    private static <T> void assertPropertyMetadataImpl(\n+            Object bean, Class<T> declaringClass, Function<Class<?>, Object> targetObjectSupplier)\n+                throws ReflectiveOperationException {\n+        assertTrue(declaringClass.isInstance(bean), \"Bean is not an instance of declaring class\");\n+\n+        for (var method : declaringClass.getDeclaredMethods()) {\n+            var propertyInfo = getPropertyInfo(method);\n+            if (propertyInfo == null) {\n+                continue;\n+            }\n+\n+            Object actualBean = propertyInfo.targetClass() != null\n+                ? Objects.requireNonNull(\n+                    targetObjectSupplier.apply(propertyInfo.targetClass()),\n+                    propertyInfo.displayName() + \" is an attached property, use \"\n+                        + \"PropertyMetadataVerifier.assertPropertyMetadata(T, Class<T>, Function<Class<?>, Object>) \"\n+                        + \"and specify a supplier that returns a non-null target object\")\n+                : bean;\n+\n+            ReadOnlyProperty<?> property = propertyInfo.targetClass() != null\n+                ? (ReadOnlyProperty<?>)method.invoke(null, actualBean)\n+                : (ReadOnlyProperty<?>)method.invoke(actualBean);\n+\n+            assertPropertyBean(property, propertyInfo, actualBean);\n+            assertPropertyName(property, propertyInfo);\n+            assertPropertyReadOnlyWrapper(property, propertyInfo);\n+            assertPropertyDeclaringClass(property, propertyInfo);\n+            assertPropertyTargetClass(property, propertyInfo);\n+        }\n+    }\n+\n+    private static void assertPropertyBean(ReadOnlyProperty<?> property, PropertyInfo propertyInfo, Object bean) {\n+        Object actualBean = property.getBean();\n+        if (bean != actualBean) {\n+            fail(\"%s#getBean() returns %s, expected %s\".formatted(propertyInfo.displayName(), actualBean, bean));\n+        }\n+\n+        assertSimplePropertyNoOverride(property, propertyInfo, \"getBean\");\n+    }\n+\n+    private static void assertPropertyName(ReadOnlyProperty<?> property, PropertyInfo propertyInfo) {\n+        String actualPropertyName = property.getName();\n+        if (!propertyInfo.name().equals(property.getName())) {\n+            fail(\"%s#getName() returns %s, but expected \\\"%s\\\"\".formatted(propertyInfo.displayName(),\n+                actualPropertyName != null ? \"\\\"\" + actualPropertyName + \"\\\"\" : \"null\", propertyInfo.name()));\n+        }\n+\n+        assertSimplePropertyNoOverride(property, propertyInfo, \"getName\");\n+    }\n+\n+    private static void assertPropertyReadOnlyWrapper(ReadOnlyProperty<?> property, PropertyInfo propertyInfo) {\n+        if (isReadOnlyWrapperOrDerivedClass(property.getClass())) {\n+            fail(\"%sProperty() must not return %s, expected %s#getReadOnlyProperty()\".formatted(\n+                propertyInfo.displayName(), property.getClass().getName(), property.getClass().getName()));\n+        }\n+    }\n+\n+    private static void assertPropertyDeclaringClass(ReadOnlyProperty<?> property, PropertyInfo propertyInfo) {\n+        Class<?> propertyClass = property.getClass();\n+        Class<?> originalPropertyClass = propertyClass;\n+\n+        if (isReadOnlyWrapperImplClass(propertyClass)) {\n+            property = ReflectionUtils.getFieldValue(property, \"this$0\");\n+            propertyClass = property.getClass();\n+            originalPropertyClass = propertyClass;\n+        }\n+\n+        do {\n+            try {\n+                propertyClass.getDeclaredMethod(\"getDeclaringClass\");\n+\n+                if (isSimplePropertyClass(propertyClass) || isReadOnlyWrapperClass(propertyClass)) {\n+                    if (ReflectionUtils.getFieldValue(property, \"declaringClass\") == null) {\n+                        fail(\"Declaring class of %s must be specified in the constructor of %s\".formatted(\n+                            propertyInfo.displayName(),\n+                            getSimplePropertyOrReadOnlyWrapperClass(originalPropertyClass).getName()));\n+                    }\n+                } else if (isSimplePropertyOrDerivedClass(propertyClass)) {\n+                    fail((\"%s#getDeclaringClass() must not be overridden in %s, pass %s \"\n+                        + \"to the constructor of %s\").formatted(\n+                            propertyInfo.displayName(), propertyClass.getName(),\n+                            propertyInfo.declaringClass().getName(),\n+                            getSimplePropertyOrReadOnlyWrapperClass(propertyClass).getName()));\n+                }\n+\n+                break;\n+            } catch (NoSuchMethodException ex) {\n+                propertyClass = propertyClass.getSuperclass();\n+            }\n+        } while (propertyClass != null);\n+\n+        if (propertyClass == null) {\n+            fail(\"%s#getDeclaringClass() must be overridden and return %s\".formatted(\n+                propertyInfo.displayName(), propertyInfo.declaringClass().getName()));\n+        }\n+\n+        Class<?> actualDeclaringClass = property.getDeclaringClass();\n+\n+        if (!propertyInfo.declaringClass().equals(actualDeclaringClass)) {\n+            fail(\"%s#getDeclaringClass() returns %s, but expected %s\".formatted(\n+                propertyInfo.displayName(),\n+                actualDeclaringClass != null ? actualDeclaringClass.getName() : \"null\",\n+                propertyInfo.declaringClass().getName()));\n+        }\n+    }\n+\n+    private static void assertPropertyTargetClass(ReadOnlyProperty<?> property, PropertyInfo propertyInfo) {\n+        if (propertyInfo.targetClass() != null) {\n+            if (!(property instanceof AttachedProperty)) {\n+                fail(propertyInfo.displayName() + \" has a static property getter, but does not implement AttachedProperty\");\n+            }\n+\n+            Class<?> actual = ((AttachedProperty)property).getTargetClass();\n+            Class<?> expected = propertyInfo.targetClass();\n+\n+            if (!expected.equals(actual)) {\n+                fail(\"%s#getTargetClass() returns %s, but expected %s\".formatted(\n+                    propertyInfo.displayName(),\n+                    actual != null ? actual.getName() : \"null\",\n+                    expected.getName()));\n+            }\n+        } else if (property instanceof AttachedProperty) {\n+            fail(propertyInfo.displayName() + \" implements AttachedProperty, but does not have a static property getter\");\n+        }\n+    }\n+\n+    private static void assertSimplePropertyNoOverride(\n+            ReadOnlyProperty<?> property, PropertyInfo propertyInfo, String methodName) {\n+        Class<?> propertyClass = property.getClass();\n+\n+        if (isReadOnlyWrapperImplClass(propertyClass)) {\n+            property = ReflectionUtils.getFieldValue(property, \"this$0\");\n+            propertyClass = property.getClass();\n+        }\n+\n+        if (isSimplePropertyOrDerivedClass(propertyClass)) {\n+            do {\n+                try {\n+                    propertyClass.getDeclaredMethod(methodName);\n+\n+                    if (isSimplePropertyClass(propertyClass)) {\n+                        return;\n+                    } else {\n+                        break;\n+                    }\n+                } catch (NoSuchMethodException ex) {\n+                    propertyClass = propertyClass.getSuperclass();\n+                }\n+            } while (propertyClass != null);\n+\n+            if (propertyClass != null) {\n+                fail(\"%s#%s() must not be overridden in %s, pass the %s to the constructor of %s\".formatted(\n+                    propertyInfo.displayName(), methodName, propertyClass.getName(),\n+                    methodName.substring(3).toLowerCase(Locale.ROOT), getSimplePropertyOrReadOnlyWrapperClass(propertyClass).getName()));\n+            }\n+        }\n+    }\n+\n+    private static boolean isSimplePropertyOrDerivedClass(Class<?> propertyClass) {\n+        do {\n+            if (isSimplePropertyClass(propertyClass)) {\n+                return true;\n+            }\n+\n+            propertyClass = propertyClass.getSuperclass();\n+        } while (propertyClass != null);\n+\n+        return false;\n+    }\n+\n+    private static boolean isSimplePropertyClass(Class<?> propertyClass) {\n+        String name = propertyClass.getName();\n+        return name.startsWith(\"javafx.beans.property.Simple\") && name.endsWith(\"Property\");\n+    }\n+\n+    private static boolean isReadOnlyWrapperOrDerivedClass(Class<?> propertyClass) {\n+        do {\n+            if (isReadOnlyWrapperClass(propertyClass)) {\n+                return true;\n+            }\n+\n+            propertyClass = propertyClass.getSuperclass();\n+        } while (propertyClass != null);\n+\n+        return false;\n+    }\n+\n+    private static boolean isReadOnlyWrapperClass(Class<?> propertyClass) {\n+        String name = propertyClass.getName();\n+        return name.startsWith(\"javafx.beans.property.ReadOnly\") && name.endsWith(\"Wrapper\");\n+    }\n+\n+    private static boolean isReadOnlyWrapperImplClass(Class<?> propertyClass) {\n+        return propertyClass.getEnclosingClass() instanceof Class<?> enclosingClass\n+            && isReadOnlyWrapperClass(enclosingClass);\n+    }\n+\n+    private static Class<?> getSimplePropertyOrReadOnlyWrapperClass(Class<?> propertyClass) {\n+        do {\n+            if (isSimplePropertyClass(propertyClass) || isReadOnlyWrapperClass(propertyClass)) {\n+                return propertyClass;\n+            }\n+\n+            propertyClass = propertyClass.getSuperclass();\n+        } while (propertyClass != null);\n+\n+        throw new AssertionError();\n+    }\n+\n+    private static PropertyInfo getPropertyInfo(Method method) {\n+        String methodName = method.getName();\n+        int modifiers = method.getModifiers();\n+        boolean isPublic = (modifiers & Modifier.PUBLIC) != 0 || (modifiers & Modifier.PROTECTED) != 0;\n+\n+        if (!isPublic\n+                || !methodName.endsWith(\"Property\")\n+                || !ReadOnlyProperty.class.isAssignableFrom(method.getReturnType())\n+                || method.getParameterCount() >= 2) {\n+            return null;\n+        }\n+\n+        Class<?> declaringClass = method.getDeclaringClass();\n+        String propertyName = methodName.substring(0, methodName.length() - \"Property\".length());\n+        String displayName = declaringClass.getName() + \".\" + propertyName;\n+\n+        return method.getParameterCount() == 1\n+            ? new PropertyInfo(propertyName, displayName, declaringClass,\n+                               method.getReturnType(), method.getParameterTypes()[0])\n+            : new PropertyInfo(propertyName, displayName, declaringClass,\n+                               method.getReturnType(), null);\n+    }\n+\n+    private record PropertyInfo(\n+        String name,\n+        String displayName,\n+        Class<?> declaringClass,\n+        Class<?> propertyClass,\n+        Class<?> targetClass) {}\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/util\/property\/PropertyMetadataVerifier.java","additions":332,"deletions":0,"binary":false,"changes":332,"status":"added"},{"patch":"@@ -0,0 +1,395 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.util.property;\n+\n+import javafx.beans.property.AttachedProperty;\n+import javafx.beans.property.ReadOnlyStringProperty;\n+import javafx.beans.property.ReadOnlyStringWrapper;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.beans.property.StringProperty;\n+import javafx.beans.property.StringPropertyBase;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+@SuppressWarnings(\"unused\")\n+public class PropertyMetadataVerifierTest {\n+\n+    @Test\n+    void readOnlyWrapperIsNotReturnedFromPropertyGetter() {\n+        class A {\n+            private final ReadOnlyStringWrapper prop = new ReadOnlyStringWrapper(this, A.class, \"prop\") {};\n+            public ReadOnlyStringProperty propProperty() { return prop; }\n+        }\n+\n+        assertError(\n+            new A(), A.class,\n+            error -> matches(\n+                error.getMessage(),\n+                \"?A.propProperty() must not return ?A$1, expected ?A$1#getReadOnlyProperty()\"));\n+    }\n+\n+    @Nested\n+    class BeanTest {\n+\n+        @Test\n+        void getBeanReturnsExpectedBean() {\n+            class A {\n+                private final StringProperty prop = new SimpleStringProperty(this, A.class, \"prop\");\n+                public StringProperty propProperty() { return prop; }\n+            }\n+\n+            assertNoError(new A(), A.class);\n+        }\n+\n+        @Test\n+        void getBeanReturnsUnexpectedBean() {\n+            class A {\n+                private final StringProperty prop = new SimpleStringProperty(null, A.class, \"prop\");\n+                public StringProperty propProperty() { return prop; }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"?A.prop#getBean() returns null, expected ?A@?\"));\n+        }\n+\n+        @Test\n+        void getBeanOverriddenInSimplePropertyClass() {\n+            class A {\n+                private final StringProperty prop = new SimpleStringProperty(this, A.class, \"prop\") {\n+                    @Override public Object getBean() { return A.this; }\n+                };\n+\n+                public StringProperty propProperty() { return prop; }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"?A.prop#getBean() must not be overridden in ?A$1, \"\n+                    + \"pass the bean to the constructor of javafx.beans.property.SimpleStringProperty\"));\n+        }\n+\n+        @Test\n+        void getBeanOverriddenInReadOnlyPropertyWrapper() {\n+            class A {\n+                private final ReadOnlyStringWrapper prop = new ReadOnlyStringWrapper(this, A.class, \"prop\") {\n+                    @Override public Object getBean() { return A.this; }\n+                };\n+\n+                public ReadOnlyStringProperty propProperty() { return prop.getReadOnlyProperty(); }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"?A.prop#getBean() must not be overridden in ?A$1, \"\n+                    + \"pass the bean to the constructor of javafx.beans.property.ReadOnlyStringWrapper\"));\n+        }\n+    }\n+\n+    @Nested\n+    class NameTest {\n+\n+        @Test\n+        void getNameReturnsUnexpectedName() {\n+            class A {\n+                private final StringProperty prop = new SimpleStringProperty(this, A.class, \"wrongName\");\n+                public StringProperty propProperty() { return prop; }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"?A.prop#getName() returns \\\"wrongName\\\", but expected \\\"prop\\\"\"));\n+        }\n+\n+        @Test\n+        void getNameOverriddenInSimplePropertyClass() {\n+            class A {\n+                private final StringProperty prop = new SimpleStringProperty(this, A.class, \"prop\") {\n+                    @Override public String getName() { return \"prop\"; }\n+                };\n+\n+                public StringProperty propProperty() { return prop; }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"?A.prop#getName() must not be overridden in ?A$1, \"\n+                    + \"pass the name to the constructor of javafx.beans.property.SimpleStringProperty\"));\n+        }\n+\n+        @Test\n+        void getNameOverriddenInReadOnlyPropertyWrapper() {\n+            class A {\n+                private final ReadOnlyStringWrapper prop = new ReadOnlyStringWrapper(this, A.class, \"prop\") {\n+                    @Override public String getName() { return \"prop\"; }\n+                };\n+\n+                public ReadOnlyStringProperty propProperty() { return prop.getReadOnlyProperty(); }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"?A.prop#getName() must not be overridden in ?A$1, \"\n+                    + \"pass the name to the constructor of javafx.beans.property.ReadOnlyStringWrapper\"));\n+        }\n+    }\n+\n+    @Nested\n+    class DeclaringClassTest {\n+\n+        @Test\n+        void getDeclaringClassMustBeOverridden() {\n+            class A {\n+                private final StringProperty prop = new StringPropertyBase() {\n+                    @Override public Object getBean() { return A.this; }\n+                    @Override public String getName() { return \"prop\"; }\n+                };\n+\n+                public StringProperty propProperty() { return prop; }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"?A.prop#getDeclaringClass() must be overridden and return ?A\"));\n+        }\n+\n+        @Test\n+        void getDeclaringClassReturnsUnexpectedClass() {\n+            class A {\n+                private final StringProperty prop = new StringPropertyBase() {\n+                    @Override public Object getBean() { return A.this; }\n+                    @Override public String getName() { return \"prop\"; }\n+                    @Override public Class<?> getDeclaringClass() { return String.class; }\n+                };\n+\n+                public StringProperty propProperty() { return prop; }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"?A.prop#getDeclaringClass() returns java.lang.String, but expected ?A\"));\n+        }\n+\n+        @Test\n+        void getDeclaringClassOverriddenInSimplePropertyClass() {\n+            class A {\n+                private final StringProperty prop = new SimpleStringProperty(this, \"prop\") {\n+                    @Override public Class<?> getDeclaringClass() { return A.class; }\n+                };\n+\n+                public StringProperty propProperty() { return prop; }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"?A.prop#getDeclaringClass() must not be overridden in ?A$1, \"\n+                    + \"pass ?A to the constructor of javafx.beans.property.SimpleStringProperty\"));\n+        }\n+\n+        @Test\n+        void getDeclaringClassOverriddenInReadOnlyPropertyWrapper() {\n+            class A {\n+                private final ReadOnlyStringWrapper prop = new ReadOnlyStringWrapper(this, \"prop\") {\n+                    @Override public Class<?> getDeclaringClass() { return A.class; }\n+                };\n+\n+                public ReadOnlyStringProperty propProperty() { return prop.getReadOnlyProperty(); }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"?A.prop#getDeclaringClass() must not be overridden in ?A$1, \"\n+                    + \"pass ?A to the constructor of javafx.beans.property.ReadOnlyStringWrapper\"));\n+        }\n+\n+        @Test\n+        void declaringClassMustBeSpecifiedInSimplePropertyClassConstructor() {\n+            class A {\n+                private final StringProperty prop = new SimpleStringProperty(this, \"prop\");\n+                public StringProperty propProperty() { return prop; }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"Declaring class of ?A.prop must be specified in the constructor of \"\n+                    + \"javafx.beans.property.SimpleStringProperty\"));\n+        }\n+\n+        @Test\n+        void declaringClassMustBeSpecifiedInReadOnlyWrapperClassConstructor() {\n+            class A {\n+                private final ReadOnlyStringWrapper prop = new ReadOnlyStringWrapper(this, \"prop\");\n+                public ReadOnlyStringProperty propProperty() { return prop.getReadOnlyProperty(); }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"Declaring class of ?A.prop must be specified in the constructor of \"\n+                    + \"javafx.beans.property.ReadOnlyStringWrapper\"));\n+        }\n+    }\n+\n+    @Nested\n+    class TargetClassTest {\n+\n+        @Test\n+        void attachedPropertyDoesNotImplementInterface() {\n+            class A {\n+                public static StringProperty propProperty(Integer target) {\n+                    return new SimpleStringProperty(target, A.class, \"prop\");\n+                }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                target -> 0,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"?A.prop has a static property getter, but does not implement AttachedProperty\"));\n+        }\n+\n+        @Test\n+        void attachedPropertyDoesNotHaveStaticPropertyGetter() {\n+            class A {\n+                static class P extends SimpleStringProperty implements AttachedProperty {\n+                    P(Object bean) {\n+                        super(bean, A.class, \"prop\");\n+                    }\n+\n+                    @Override\n+                    public Class<?> getTargetClass() {\n+                        return Integer.class;\n+                    }\n+                }\n+\n+                public P propProperty() { return new P(this); }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                target -> 0,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"?A.prop implements AttachedProperty, but does not have a static property getter\"));\n+        }\n+\n+        @Test\n+        void attachedPropertyReturnsUnexpectedTargetClass() {\n+            class A {\n+                static class P extends SimpleStringProperty implements AttachedProperty {\n+                    P(Object bean) {\n+                        super(bean, A.class, \"prop\");\n+                    }\n+\n+                    @Override\n+                    public Class<?> getTargetClass() {\n+                        return Double.class;\n+                    }\n+                }\n+\n+                public static P propProperty(Integer target) {\n+                    return new P(target);\n+                }\n+            }\n+\n+            assertError(\n+                new A(), A.class,\n+                target -> 0,\n+                error -> matches(\n+                    error.getMessage(),\n+                    \"?#getTargetClass() returns java.lang.Double, but expected java.lang.Integer\"));\n+        }\n+    }\n+\n+    private static <T> void assertNoError(T bean, Class<T> beanClass) {\n+        assertDoesNotThrow(() -> PropertyMetadataVerifier.assertPropertyMetadata(bean, beanClass));\n+    }\n+\n+    private static <T> void assertError(T bean, Class<T> beanClass, Predicate<AssertionError> predicate) {\n+        var error = assertThrows(\n+            AssertionError.class,\n+            () -> PropertyMetadataVerifier.assertPropertyMetadata(bean, beanClass));\n+\n+        if (!predicate.test(error)) {\n+            fail(error.getMessage());\n+        }\n+    }\n+\n+    private static <T> void assertError(T bean, Class<T> beanClass,\n+                                        Function<Class<?>, Object> targetObjectSupplier,\n+                                        Predicate<AssertionError> predicate) {\n+        var error = assertThrows(\n+            AssertionError.class,\n+            () -> PropertyMetadataVerifier.assertPropertyMetadata(bean, beanClass, targetObjectSupplier));\n+\n+        assertTrue(predicate.test(error), error::getMessage);\n+    }\n+\n+    private static boolean matches(String actual, String template) {\n+        String[] parts = template.split(Pattern.quote(\"?\"), -1);\n+        StringBuilder regex = new StringBuilder(\"^\");\n+\n+        for (int i = 0; i < parts.length; i++) {\n+            regex.append(Pattern.quote(parts[i]));\n+\n+            if (i < parts.length - 1) {\n+                regex.append(\"([^,]+)\");\n+            }\n+        }\n+\n+        return actual.matches(regex.append(\"$\").toString());\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/util\/property\/PropertyMetadataVerifierTest.java","additions":395,"deletions":0,"binary":false,"changes":395,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+import javafx.beans.property.AttachedProperty;\n@@ -233,1 +234,12 @@\n-        var property = new SimpleObjectProperty<HeaderDragType>(child, \"dragType\");\n+        class PropertyImpl extends SimpleObjectProperty<HeaderDragType> implements AttachedProperty {\n+            PropertyImpl(Node child) {\n+                super(child, HeaderBar.class, \"dragType\");\n+            }\n+\n+            @Override\n+            public Class<?> getTargetClass() {\n+                return Node.class;\n+            }\n+        }\n+\n+        var property = new PropertyImpl(child);\n@@ -285,1 +297,1 @@\n-        var property = new SimpleObjectProperty<HeaderButtonType>(child, \"buttonType\") {\n+        class PropertyImpl extends SimpleObjectProperty<HeaderButtonType> implements AttachedProperty {\n@@ -288,0 +300,9 @@\n+            PropertyImpl(Node child) {\n+                super(child, HeaderBar.class, \"buttonType\");\n+            }\n+\n+            @Override\n+            public Class<?> getTargetClass() {\n+                return Node.class;\n+            }\n+\n@@ -300,1 +321,1 @@\n-        };\n+        }\n@@ -302,0 +323,1 @@\n+        var property = new PropertyImpl(child);\n@@ -590,0 +612,5 @@\n+        @Override\n+        public Class<?> getDeclaringClass() {\n+            return HeaderBar.class;\n+        }\n+\n@@ -633,0 +660,5 @@\n+        @Override\n+        public Class<?> getDeclaringClass() {\n+            return HeaderBar.class;\n+        }\n+\n@@ -937,0 +969,5 @@\n+        @Override\n+        public Class<?> getDeclaringClass() {\n+            return HeaderBar.class;\n+        }\n+\n@@ -976,10 +1013,4 @@\n-            this.leftSystemInset = new ReadOnlyObjectWrapper<>(stage, \"leftSystemInset\", EMPTY);\n-            this.rightSystemInset = new ReadOnlyObjectWrapper<>(stage, \"rightSystemInset\", EMPTY);\n-            this.minSystemHeight = new ReadOnlyDoubleWrapper(stage, \"minSystemHeight\");\n-            this.prefButtonHeight = new SimpleDoubleProperty(\n-                    stage, \"prefButtonHeight\", StageHelper.getPrefHeaderButtonHeight(stage)) {\n-                @Override\n-                protected void invalidated() {\n-                    StageHelper.setPrefHeaderButtonHeight(stage, get());\n-                }\n-            };\n+            this.leftSystemInset = new AttachedReadOnlyObjectWrapperImpl<>(stage, \"leftSystemInset\", EMPTY);\n+            this.rightSystemInset = new AttachedReadOnlyObjectWrapperImpl<>(stage, \"rightSystemInset\", EMPTY);\n+            this.minSystemHeight = new AttachedReadOnlyDoubleWrapperImpl(stage, \"minSystemHeight\");\n+            this.prefButtonHeight = new AttachedPrefButtonHeightPropertyImpl(stage, StageHelper.getPrefHeaderButtonHeight(stage));\n@@ -1043,0 +1074,41 @@\n+\n+        private static final class AttachedReadOnlyObjectWrapperImpl<T> extends ReadOnlyObjectWrapper<T>\n+                                                                        implements AttachedProperty {\n+            AttachedReadOnlyObjectWrapperImpl(Stage stage, String name, T initialValue) {\n+                super(stage, HeaderBar.class, name, initialValue);\n+            }\n+\n+            @Override\n+            public Class<?> getTargetClass() {\n+                return Stage.class;\n+            }\n+        }\n+\n+        private static final class AttachedReadOnlyDoubleWrapperImpl extends ReadOnlyDoubleWrapper\n+                                                                     implements AttachedProperty {\n+            AttachedReadOnlyDoubleWrapperImpl(Stage stage, String name) {\n+                super(stage, HeaderBar.class, name);\n+            }\n+\n+            @Override\n+            public Class<?> getTargetClass() {\n+                return Stage.class;\n+            }\n+        }\n+\n+        private static final class AttachedPrefButtonHeightPropertyImpl extends SimpleDoubleProperty\n+                                                                        implements AttachedProperty {\n+            AttachedPrefButtonHeightPropertyImpl(Stage stage, double initialValue) {\n+                super(stage, HeaderBar.class, \"prefButtonHeight\", initialValue);\n+            }\n+\n+            @Override\n+            public Class<?> getTargetClass() {\n+                return Stage.class;\n+            }\n+\n+            @Override\n+            protected void invalidated() {\n+                StageHelper.setPrefHeaderButtonHeight((Stage)getBean(), get());\n+            }\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/HeaderBar.java","additions":85,"deletions":13,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+--add-opens javafx.base\/javafx.beans.property=ALL-UNNAMED\n","filename":"modules\/javafx.graphics\/src\/test\/addExports","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+import test.util.property.PropertyMetadataVerifier;\n+\n@@ -87,0 +89,9 @@\n+    @Test\n+    public void testPropertyMetadata() {\n+        PropertyMetadataVerifier.assertPropertyMetadata(new HeaderBar(), HeaderBar.class, targetClass -> {\n+            if (targetClass == Node.class) return new Rectangle();\n+            if (targetClass == Stage.class) return new Stage();\n+            return null;\n+        });\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/HeaderBarTest.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}