{"files":[{"patch":"@@ -1,1 +1,1 @@\n-## Independent JPEG Group (IJG) JPEG v9e\n+## Independent JPEG Group (IJG) JPEG version 9f\n@@ -5,0 +5,2 @@\n+Copyright (C) 1991-1998, Thomas G. Lane.\n+Copyright (C) 1991-2024, Thomas G. Lane, Guido Vollbeding.\n@@ -6,10 +8,0 @@\n-\/*\n- * jcapimin.c\n- *\n- * Copyright (C) 1994-1998, Thomas G. Lane.\n- * Modified 2003-2010 by Guido Vollbeding.\n- * This file is part of the Independent JPEG Group's software.\n- * For conditions of distribution and use, see the accompanying README file.\n- *\/\n-\n-[From the README file]\n@@ -21,1 +13,1 @@\n-This software is copyright (C) 1991-2022, Thomas G. Lane, Guido Vollbeding.\n+This software is copyright (C) 1991-2024, Thomas G. Lane, Guido Vollbeding.\n","filename":"modules\/javafx.graphics\/src\/main\/legal\/jpeg_fx.md","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-README for release 9e of 16-Jan-2022\n+README for release 9f of 14-Jan-2024\n@@ -119,1 +119,1 @@\n-This software is copyright (C) 1991-2022, Thomas G. Lane, Guido Vollbeding.\n+This software is copyright (C) 1991-2024, Thomas G. Lane, Guido Vollbeding.\n@@ -243,1 +243,1 @@\n-https:\/\/www.ijg.org\/files\/jpegsr9e.zip, and\n+https:\/\/www.ijg.org\/files\/jpegsr9f.zip, and\n@@ -245,1 +245,1 @@\n-https:\/\/www.ijg.org\/files\/jpegsrc.v9e.tar.gz.\n+https:\/\/www.ijg.org\/files\/jpegsrc.v9f.tar.gz.\n@@ -374,1 +374,1 @@\n-Please send bug reports, offers of help, etc. to jpeg-info@jpegclub.org.\n+Please send bug reports, offers of help, etc. to jpeg-info@ijg.org.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/README","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -12,1 +12,1 @@\n-Copy only the same 41 .c and 9 .h files as are already there.\n+Copy only the same 49 .c and 9 .h files as are already there.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/UPDATING.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2003-2020 by Guido Vollbeding.\n+ * Modified 2003-2022 by Guido Vollbeding.\n@@ -44,3 +44,3 @@\n-   * (although this may prove a bit slow in practice).  We append a\n-   * workspace of C_MAX_BLOCKS_IN_MCU coefficient blocks, and reuse it\n-   * for each MCU constructed and sent.\n+   * (although this may prove a bit slow in practice).\n+   * We append a workspace of C_MAX_BLOCKS_IN_MCU coefficient blocks,\n+   * and reuse it for each MCU constructed and sent.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jccoefct.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2011-2019 by Guido Vollbeding.\n+ * Modified 2011-2023 by Guido Vollbeding.\n@@ -43,2 +43,2 @@\n- *    Cb = 0.5 * (B - Y) \/ (1 - Kb)\n- *    Cr = 0.5 * (R - Y) \/ (1 - Kr)\n+ *    Cb = (B - Y) \/ (1 - Kb) \/ K\n+ *    Cr = (R - Y) \/ (1 - Kr) \/ K\n@@ -46,1 +46,1 @@\n- * from the 1953 FCC NTSC primaries and CIE Illuminant C),\n+ * from the 1953 FCC NTSC primaries and CIE Illuminant C), K = 2 for sYCC,\n@@ -65,2 +65,2 @@\n- * reasonable for 16-bit samples, but if you want lossless storage you\n- * shouldn't be changing colorspace anyway.\n+ * reasonable for 16-bit samples, but if you want lossless storage\n+ * you shouldn't be changing colorspace anyway.\n@@ -113,1 +113,1 @@\n-    rgb_ycc_tab[i+B_Y_OFF] = FIX(0.114) * i   + ONE_HALF;\n+    rgb_ycc_tab[i+B_Y_OFF] = FIX(0.114) * i + ONE_HALF;\n@@ -120,1 +120,1 @@\n-    rgb_ycc_tab[i+B_CB_OFF] = FIX(0.5) * i    + CBCR_OFFSET + ONE_HALF-1;\n+    rgb_ycc_tab[i+B_CB_OFF] = (i << (SCALEBITS-1)) + CBCR_OFFSET + ONE_HALF-1;\n@@ -122,1 +122,1 @@\n-    rgb_ycc_tab[i+R_CR_OFF] = FIX(0.5) * i    + CBCR_OFFSET + ONE_HALF-1;\n+    rgb_ycc_tab[i+R_CR_OFF] = (i << (SCALEBITS-1)) + CBCR_OFFSET + ONE_HALF-1;\n@@ -193,2 +193,2 @@\n- * This version handles RGB->grayscale conversion, which is the same\n- * as the RGB->Y portion of RGB->YCbCr.\n+ * This version handles RGB->grayscale conversion,\n+ * which is the same as the RGB->Y portion of RGB->YCbCr.\n@@ -204,1 +204,1 @@\n-  register int r, g, b;\n+  register INT32 y;\n@@ -215,3 +215,3 @@\n-      r = GETJSAMPLE(inptr[RGB_RED]);\n-      g = GETJSAMPLE(inptr[RGB_GREEN]);\n-      b = GETJSAMPLE(inptr[RGB_BLUE]);\n+      y  = ctab[R_Y_OFF + GETJSAMPLE(inptr[RGB_RED])];\n+      y += ctab[G_Y_OFF + GETJSAMPLE(inptr[RGB_GREEN])];\n+      y += ctab[B_Y_OFF + GETJSAMPLE(inptr[RGB_BLUE])];\n@@ -219,4 +219,1 @@\n-      \/* Y *\/\n-      outptr[col] = (JSAMPLE)\n-        ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])\n-         >> SCALEBITS);\n+      outptr[col] = (JSAMPLE) (y >> SCALEBITS);\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jccolor.c","additions":16,"deletions":19,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2006-2019 by Guido Vollbeding.\n+ * Modified 2006-2023 by Guido Vollbeding.\n@@ -29,3 +29,3 @@\n- *  -1024 .. +1023  for 8-bit data;\n- * -16384 .. +16383 for 12-bit data.\n- * Hence the magnitude should always fit in 10 or 14 bits respectively.\n+ *  -1024 .. +1023  for 8-bit sample data precision;\n+ * -16384 .. +16383 for 12-bit sample data precision.\n+ * Hence the magnitude should always fit in sample data precision + 2 bits.\n@@ -34,6 +34,0 @@\n-#if BITS_IN_JSAMPLE == 8\n-#define MAX_COEF_BITS 10\n-#else\n-#define MAX_COEF_BITS 14\n-#endif\n-\n@@ -552,0 +546,1 @@\n+  int max_coef_bits;\n@@ -563,0 +558,3 @@\n+  \/* Since we're encoding a difference, the range limit is twice as much. *\/\n+  max_coef_bits = cinfo->data_precision + 3;\n+\n@@ -574,1 +572,7 @@\n-    temp2 = temp - entropy->saved.last_dc_val[ci];\n+    if ((temp2 = temp - entropy->saved.last_dc_val[ci]) == 0) {\n+      \/* Count\/emit the Huffman-coded symbol for the number of bits *\/\n+      emit_dc_symbol(entropy, tbl, 0);\n+\n+      continue;\n+    }\n+\n@@ -578,3 +582,2 @@\n-    temp = temp2;\n-    if (temp < 0) {\n-      temp = -temp;        \/* temp is abs value of input *\/\n+    if ((temp = temp2) < 0) {\n+      temp = -temp;    \/* temp is abs value of input *\/\n@@ -588,8 +591,4 @@\n-    while (temp) {\n-      nbits++;\n-      temp >>= 1;\n-    }\n-    \/* Check for out-of-range coefficient values.\n-     * Since we're encoding a difference, the range limit is twice as much.\n-     *\/\n-    if (nbits > MAX_COEF_BITS+1)\n+    do nbits++;    \/* there must be at least one 1 bit *\/\n+    while ((temp >>= 1));\n+    \/* Check for out-of-range coefficient values *\/\n+    if (nbits > max_coef_bits)\n@@ -603,2 +602,1 @@\n-    if (nbits)            \/* emit_bits rejects calls with size 0 *\/\n-      emit_bits_e(entropy, (unsigned int) temp2, nbits);\n+    emit_bits_e(entropy, (unsigned int) temp2, nbits);\n@@ -638,1 +636,1 @@\n-  int Se, Al;\n+  int Se, Al, max_coef_bits;\n@@ -651,0 +649,1 @@\n+  max_coef_bits = cinfo->data_precision + 2;\n@@ -670,2 +669,7 @@\n-      temp = -temp;        \/* temp is abs value of input *\/\n-      temp >>= Al;        \/* apply the point transform *\/\n+      temp = -temp;    \/* temp is abs value of input *\/\n+      \/* Apply the point transform, and watch out for case *\/\n+      \/* that nonzero coef is zero after point transform. *\/\n+      if ((temp >>= Al) == 0) {\n+        r++;\n+        continue;\n+      }\n@@ -675,1 +679,6 @@\n-      temp >>= Al;        \/* apply the point transform *\/\n+      \/* Apply the point transform, and watch out for case *\/\n+      \/* that nonzero coef is zero after point transform. *\/\n+      if ((temp >>= Al) == 0) {\n+        r++;\n+        continue;\n+      }\n@@ -678,5 +687,0 @@\n-    \/* Watch out for case that nonzero coef is zero after point transform *\/\n-    if (temp == 0) {\n-      r++;\n-      continue;\n-    }\n@@ -694,3 +698,3 @@\n-    nbits = 1;            \/* there must be at least one 1 bit *\/\n-    while ((temp >>= 1))\n-      nbits++;\n+    nbits = 0;\n+    do nbits++;    \/* there must be at least one 1 bit *\/\n+    while ((temp >>= 1));\n@@ -698,1 +702,1 @@\n-    if (nbits > MAX_COEF_BITS)\n+    if (nbits > max_coef_bits)\n@@ -923,0 +927,1 @@\n+  int max_coef_bits = state->cinfo->data_precision + 3;\n@@ -927,8 +932,11 @@\n-  temp = temp2 = block[0] - last_dc_val;\n-\n-  if (temp < 0) {\n-    temp = -temp;        \/* temp is abs value of input *\/\n-    \/* For a negative input, want temp2 = bitwise complement of abs(input) *\/\n-    \/* This code assumes we are on a two's complement machine *\/\n-    temp2--;\n-  }\n+  if ((temp = block[0] - last_dc_val) == 0) {\n+    \/* Emit the Huffman-coded symbol for the number of bits *\/\n+    if (! emit_bits_s(state, dctbl->ehufco[0], dctbl->ehufsi[0]))\n+      return FALSE;\n+  } else {\n+    if ((temp2 = temp) < 0) {\n+      temp = -temp;    \/* temp is abs value of input *\/\n+      \/* For a negative input, want temp2 = bitwise complement of abs(input) *\/\n+      \/* This code assumes we are on a two's complement machine *\/\n+      temp2--;\n+    }\n@@ -936,11 +944,9 @@\n-  \/* Find the number of bits needed for the magnitude of the coefficient *\/\n-  nbits = 0;\n-  while (temp) {\n-    nbits++;\n-    temp >>= 1;\n-  }\n-  \/* Check for out-of-range coefficient values.\n-   * Since we're encoding a difference, the range limit is twice as much.\n-   *\/\n-  if (nbits > MAX_COEF_BITS+1)\n-    ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);\n+    \/* Find the number of bits needed for the magnitude of the coefficient *\/\n+    nbits = 0;\n+    do nbits++;    \/* there must be at least one 1 bit *\/\n+    while ((temp >>= 1));\n+    \/* Check for out-of-range coefficient values.\n+     * Since we're encoding a difference, the range limit is twice as much.\n+     *\/\n+    if (nbits > max_coef_bits)\n+      ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);\n@@ -948,3 +954,3 @@\n-  \/* Emit the Huffman-coded symbol for the number of bits *\/\n-  if (! emit_bits_s(state, dctbl->ehufco[nbits], dctbl->ehufsi[nbits]))\n-    return FALSE;\n+    \/* Emit the Huffman-coded symbol for the number of bits *\/\n+    if (! emit_bits_s(state, dctbl->ehufco[nbits], dctbl->ehufsi[nbits]))\n+      return FALSE;\n@@ -952,3 +958,2 @@\n-  \/* Emit that number of bits of the value, if positive, *\/\n-  \/* or the complement of its magnitude, if negative. *\/\n-  if (nbits)            \/* emit_bits rejects calls with size 0 *\/\n+    \/* Emit that number of bits of the value, if positive, *\/\n+    \/* or the complement of its magnitude, if negative. *\/\n@@ -957,0 +962,1 @@\n+  }\n@@ -963,1 +969,1 @@\n-    if ((temp2 = block[natural_order[k]]) == 0) {\n+    if ((temp = block[natural_order[k]]) == 0) {\n@@ -965,7 +971,2 @@\n-    } else {\n-      \/* if run length > 15, must emit special run-length-16 codes (0xF0) *\/\n-      while (r > 15) {\n-    if (! emit_bits_s(state, actbl->ehufco[0xF0], actbl->ehufsi[0xF0]))\n-      return FALSE;\n-    r -= 16;\n-      }\n+      continue;\n+    }\n@@ -973,6 +974,6 @@\n-      temp = temp2;\n-      if (temp < 0) {\n-    temp = -temp;        \/* temp is abs value of input *\/\n-    \/* This code assumes we are on a two's complement machine *\/\n-    temp2--;\n-      }\n+    \/* if run length > 15, must emit special run-length-16 codes (0xF0) *\/\n+    while (r > 15) {\n+      if (! emit_bits_s(state, actbl->ehufco[0xF0], actbl->ehufsi[0xF0]))\n+        return FALSE;\n+      r -= 16;\n+    }\n@@ -980,12 +981,6 @@\n-      \/* Find the number of bits needed for the magnitude of the coefficient *\/\n-      nbits = 1;        \/* there must be at least one 1 bit *\/\n-      while ((temp >>= 1))\n-    nbits++;\n-      \/* Check for out-of-range coefficient values *\/\n-      if (nbits > MAX_COEF_BITS)\n-    ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);\n-\n-      \/* Emit Huffman symbol for run length \/ number of bits *\/\n-      temp = (r << 4) + nbits;\n-      if (! emit_bits_s(state, actbl->ehufco[temp], actbl->ehufsi[temp]))\n-    return FALSE;\n+    if ((temp2 = temp) < 0) {\n+      temp = -temp;    \/* temp is abs value of input *\/\n+      \/* For a negative coef, want temp2 = bitwise complement of abs(coef) *\/\n+      \/* This code assumes we are on a two's complement machine *\/\n+      temp2--;\n+    }\n@@ -993,4 +988,10 @@\n-      \/* Emit that number of bits of the value, if positive, *\/\n-      \/* or the complement of its magnitude, if negative. *\/\n-      if (! emit_bits_s(state, (unsigned int) temp2, nbits))\n-    return FALSE;\n+    \/* Find the number of bits needed for the magnitude of the coefficient *\/\n+    nbits = 0;\n+    do nbits++;        \/* there must be at least one 1 bit *\/\n+    while ((temp >>= 1));\n+    \/* Check for out-of-range coefficient values.\n+     * Use \">=\" instead of \">\" so can use the\n+     * same one larger limit from DC check here.\n+     *\/\n+    if (nbits >= max_coef_bits)\n+      ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);\n@@ -998,2 +999,11 @@\n-      r = 0;\n-    }\n+    \/* Emit Huffman symbol for run length \/ number of bits *\/\n+    temp = (r << 4) + nbits;\n+    if (! emit_bits_s(state, actbl->ehufco[temp], actbl->ehufsi[temp]))\n+      return FALSE;\n+\n+    \/* Emit that number of bits of the value, if positive, *\/\n+    \/* or the complement of its magnitude, if negative. *\/\n+    if (! emit_bits_s(state, (unsigned int) temp2, nbits))\n+      return FALSE;\n+\n+    r = 0;            \/* reset zero run length *\/\n@@ -1129,0 +1139,1 @@\n+  int max_coef_bits = cinfo->data_precision + 3;\n@@ -1133,3 +1144,16 @@\n-  temp = block[0] - last_dc_val;\n-  if (temp < 0)\n-    temp = -temp;\n+  if ((temp = block[0] - last_dc_val) == 0) {\n+    \/* Count the Huffman symbol for the number of bits *\/\n+    dc_counts[0]++;\n+  } else {\n+    if (temp < 0)\n+      temp = -temp;    \/* temp is abs value of input *\/\n+\n+    \/* Find the number of bits needed for the magnitude of the coefficient *\/\n+    nbits = 0;\n+    do nbits++;        \/* there must be at least one 1 bit *\/\n+    while ((temp >>= 1));\n+    \/* Check for out-of-range coefficient values.\n+     * Since we're encoding a difference, the range limit is twice as much.\n+     *\/\n+    if (nbits > max_coef_bits)\n+      ERREXIT(cinfo, JERR_BAD_DCT_COEF);\n@@ -1137,5 +1161,2 @@\n-  \/* Find the number of bits needed for the magnitude of the coefficient *\/\n-  nbits = 0;\n-  while (temp) {\n-    nbits++;\n-    temp >>= 1;\n+    \/* Count the Huffman symbol for the number of bits *\/\n+    dc_counts[nbits]++;\n@@ -1143,8 +1164,0 @@\n-  \/* Check for out-of-range coefficient values.\n-   * Since we're encoding a difference, the range limit is twice as much.\n-   *\/\n-  if (nbits > MAX_COEF_BITS+1)\n-    ERREXIT(cinfo, JERR_BAD_DCT_COEF);\n-\n-  \/* Count the Huffman symbol for the number of bits *\/\n-  dc_counts[nbits]++;\n@@ -1159,6 +1172,2 @@\n-    } else {\n-      \/* if run length > 15, must emit special run-length-16 codes (0xF0) *\/\n-      while (r > 15) {\n-    ac_counts[0xF0]++;\n-    r -= 16;\n-      }\n+      continue;\n+    }\n@@ -1166,3 +1175,5 @@\n-      \/* Find the number of bits needed for the magnitude of the coefficient *\/\n-      if (temp < 0)\n-    temp = -temp;\n+    \/* if run length > 15, must emit special run-length-16 codes (0xF0) *\/\n+    while (r > 15) {\n+      ac_counts[0xF0]++;\n+      r -= 16;\n+    }\n@@ -1170,7 +1181,2 @@\n-      \/* Find the number of bits needed for the magnitude of the coefficient *\/\n-      nbits = 1;        \/* there must be at least one 1 bit *\/\n-      while ((temp >>= 1))\n-    nbits++;\n-      \/* Check for out-of-range coefficient values *\/\n-      if (nbits > MAX_COEF_BITS)\n-    ERREXIT(cinfo, JERR_BAD_DCT_COEF);\n+    if (temp < 0)\n+      temp = -temp;    \/* temp is abs value of input *\/\n@@ -1178,2 +1184,10 @@\n-      \/* Count Huffman symbol for run length \/ number of bits *\/\n-      ac_counts[(r << 4) + nbits]++;\n+    \/* Find the number of bits needed for the magnitude of the coefficient *\/\n+    nbits = 0;\n+    do nbits++;        \/* there must be at least one 1 bit *\/\n+    while ((temp >>= 1));\n+    \/* Check for out-of-range coefficient values.\n+     * Use \">=\" instead of \">\" so can use the\n+     * same one larger limit from DC check here.\n+     *\/\n+    if (nbits >= max_coef_bits)\n+      ERREXIT(cinfo, JERR_BAD_DCT_COEF);\n@@ -1181,2 +1195,4 @@\n-      r = 0;\n-    }\n+    \/* Count Huffman symbol for run length \/ number of bits *\/\n+    ac_counts[(r << 4) + nbits]++;\n+\n+    r = 0;            \/* reset zero run length *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jchuff.c","additions":146,"deletions":130,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2003-2019 by Guido Vollbeding.\n+ * Modified 2003-2020 by Guido Vollbeding.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jcmaster.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2003-2019 by Guido Vollbeding.\n+ * Modified 2003-2022 by Guido Vollbeding.\n@@ -65,2 +65,3 @@\n- * The spec says that the values given produce \"good\" quality, and\n- * when divided by 2, \"very good\" quality.\n+ * NOTE: chrominance DC value is changed from 17 to 16 for lossless support.\n+ * The spec says that the values given produce \"good\" quality,\n+ * and when divided by 2, \"very good\" quality.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jcparam.c","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+ * Modified 2003-2020 by Guido Vollbeding.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jcprepct.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+ * Modified 2003-2020 by Guido Vollbeding.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jcsample.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2000-2017 by Guido Vollbeding.\n+ * Modified 2000-2020 by Guido Vollbeding.\n@@ -396,1 +396,1 @@\n-  \/* Allocate and pre-zero space for dummy DCT blocks. *\/\n+  \/* Pre-zero space for dummy DCT blocks *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jctrans.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2009-2013 by Guido Vollbeding.\n+ * Modified 2009-2020 by Guido Vollbeding.\n@@ -132,1 +132,4 @@\n-    \/* First try to guess from the component IDs *\/\n+    \/* For robust detection of standard colorspaces\n+     * regardless of the presence of special markers,\n+     * check component IDs from SOF marker first.\n+     *\/\n@@ -168,0 +171,5 @@\n+\n+    \/* For robust detection of standard colorspaces\n+     * regardless of the presence of special markers,\n+     * check component IDs from SOF marker first.\n+     *\/\n@@ -185,1 +193,1 @@\n-      \/* No special markers, assume straight CMYK. *\/\n+      \/* Unknown IDs and no special markers, assume straight CMYK. *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdapimin.c","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2011-2019 by Guido Vollbeding.\n+ * Modified 2011-2023 by Guido Vollbeding.\n@@ -35,1 +35,3 @@\n-  INT32 * rgb_y_tab;        \/* => table for RGB to Y conversion *\/\n+  INT32 * R_y_tab;        \/* => table for R to Y conversion *\/\n+  INT32 * G_y_tab;        \/* => table for G to Y conversion *\/\n+  INT32 * B_y_tab;        \/* => table for B to Y conversion *\/\n@@ -90,5 +92,5 @@\n- * reasonable for 16-bit samples, but if you want lossless storage you\n- * shouldn't be changing colorspace anyway.\n- * The Cr=>R and Cb=>B values can be rounded to integers in advance; the\n- * values for the G calculation are left scaled up, since we must add them\n- * together before rounding.\n+ * reasonable for 16-bit samples, but if you want lossless storage\n+ * you shouldn't be changing colorspace anyway.\n+ * The Cr=>R and Cb=>B values can be rounded to integers in advance;\n+ * the values for the G calculation are left scaled up,\n+ * since we must add them together before rounding.\n@@ -101,12 +103,0 @@\n-\/* We allocate one big table for RGB->Y conversion and divide it up into\n- * three parts, instead of doing three alloc_small requests.  This lets us\n- * use a single table base address, which can be held in a register in the\n- * inner loops on many machines (more than can hold all three addresses,\n- * anyway).\n- *\/\n-\n-#define R_Y_OFF        0            \/* offset to R => Y section *\/\n-#define G_Y_OFF        (1*(MAXJSAMPLE+1))    \/* offset to G => Y section *\/\n-#define B_Y_OFF        (2*(MAXJSAMPLE+1))    \/* etc. *\/\n-#define TABLE_SIZE    (3*(MAXJSAMPLE+1))\n-\n@@ -252,1 +242,0 @@\n-  INT32 * rgb_y_tab;\n@@ -255,3 +244,6 @@\n-  \/* Allocate and fill in the conversion tables. *\/\n-  cconvert->rgb_y_tab = rgb_y_tab = (INT32 *) (*cinfo->mem->alloc_small)\n-    ((j_common_ptr) cinfo, JPOOL_IMAGE, TABLE_SIZE * SIZEOF(INT32));\n+  cconvert->R_y_tab = (INT32 *) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));\n+  cconvert->G_y_tab = (INT32 *) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));\n+  cconvert->B_y_tab = (INT32 *) (*cinfo->mem->alloc_small)\n+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE+1) * SIZEOF(INT32));\n@@ -260,3 +252,3 @@\n-    rgb_y_tab[i+R_Y_OFF] = FIX(0.299) * i;\n-    rgb_y_tab[i+G_Y_OFF] = FIX(0.587) * i;\n-    rgb_y_tab[i+B_Y_OFF] = FIX(0.114) * i + ONE_HALF;\n+    cconvert->R_y_tab[i] = FIX(0.299) * i;\n+    cconvert->G_y_tab[i] = FIX(0.587) * i;\n+    cconvert->B_y_tab[i] = FIX(0.114) * i + ONE_HALF;\n@@ -277,2 +269,4 @@\n-  register int r, g, b;\n-  register INT32 * ctab = cconvert->rgb_y_tab;\n+  register INT32 y;\n+  register INT32 * Rytab = cconvert->R_y_tab;\n+  register INT32 * Gytab = cconvert->G_y_tab;\n+  register INT32 * Bytab = cconvert->B_y_tab;\n@@ -291,7 +285,4 @@\n-      r = GETJSAMPLE(inptr0[col]);\n-      g = GETJSAMPLE(inptr1[col]);\n-      b = GETJSAMPLE(inptr2[col]);\n-      \/* Y *\/\n-      outptr[col] = (JSAMPLE)\n-        ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])\n-         >> SCALEBITS);\n+      y  = Rytab[GETJSAMPLE(inptr0[col])];\n+      y += Gytab[GETJSAMPLE(inptr1[col])];\n+      y += Bytab[GETJSAMPLE(inptr2[col])];\n+      outptr[col] = (JSAMPLE) (y >> SCALEBITS);\n@@ -357,1 +348,4 @@\n-  register INT32 * ctab = cconvert->rgb_y_tab;\n+  register INT32 y;\n+  register INT32 * Rytab = cconvert->R_y_tab;\n+  register INT32 * Gytab = cconvert->G_y_tab;\n+  register INT32 * Bytab = cconvert->B_y_tab;\n@@ -376,6 +370,4 @@\n-      r = (r + g - CENTERJSAMPLE) & MAXJSAMPLE;\n-      b = (b + g - CENTERJSAMPLE) & MAXJSAMPLE;\n-      \/* Y *\/\n-      outptr[col] = (JSAMPLE)\n-        ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])\n-         >> SCALEBITS);\n+      y  = Rytab[(r + g - CENTERJSAMPLE) & MAXJSAMPLE];\n+      y += Gytab[g];\n+      y += Bytab[(b + g - CENTERJSAMPLE) & MAXJSAMPLE];\n+      outptr[col] = (JSAMPLE) (y >> SCALEBITS);\n@@ -423,1 +415,1 @@\n- * We assume out_color_components == num_components.\n+ * Note: Omit uninteresting components in output buffer.\n@@ -680,2 +672,4 @@\n-  register int r, g, b;\n-  register INT32 * ctab = cconvert->rgb_y_tab;\n+  register INT32 y;\n+  register INT32 * Rytab = cconvert->R_y_tab;\n+  register INT32 * Gytab = cconvert->G_y_tab;\n+  register INT32 * Bytab = cconvert->B_y_tab;\n@@ -686,0 +680,1 @@\n+\n@@ -694,6 +689,5 @@\n-      r = MAXJSAMPLE - GETJSAMPLE(inptr0[col]);\n-      g = MAXJSAMPLE - GETJSAMPLE(inptr1[col]);\n-      b = MAXJSAMPLE - GETJSAMPLE(inptr2[col]);\n-      outptr[0] = (JSAMPLE)\n-        ((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])\n-         >> SCALEBITS);\n+      y  = Rytab[MAXJSAMPLE - GETJSAMPLE(inptr0[col])];\n+      y += Gytab[MAXJSAMPLE - GETJSAMPLE(inptr1[col])];\n+      y += Bytab[MAXJSAMPLE - GETJSAMPLE(inptr2[col])];\n+      outptr[0] = (JSAMPLE) (y >> SCALEBITS);\n+      \/* K passes through unchanged *\/\n@@ -766,1 +760,1 @@\n-   * Also clear the component_needed flags for any unused components,\n+   * Also adjust the component_needed flags for any unused components,\n@@ -858,3 +852,4 @@\n-      cconvert->pub.color_convert = ycck_cmyk_convert;\n-      build_ycc_rgb_table(cinfo);\n-      break;\n+    cconvert->pub.color_convert = ycck_cmyk_convert;\n+    build_ycc_rgb_table(cinfo);\n+    break;\n+\n@@ -863,0 +858,1 @@\n+    \/* Support only YK part of YCCK for colorless output *\/\n@@ -869,0 +865,1 @@\n+    \/* Need all components on input side *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdcolor.c","additions":52,"deletions":55,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2002-2019 by Guido Vollbeding.\n+ * Modified 2002-2023 by Guido Vollbeding.\n@@ -161,1 +161,1 @@\n-#define jpeg_idct_3x6        jRD3x8\n+#define jpeg_idct_3x6        jRD3x6\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdct.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2006-2019 by Guido Vollbeding.\n+ * Modified 2006-2020 by Guido Vollbeding.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdhuff.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2002-2013 by Guido Vollbeding.\n+ * Modified 2002-2020 by Guido Vollbeding.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdinput.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2002-2016 by Guido Vollbeding.\n+ * Modified 2002-2020 by Guido Vollbeding.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdmainct.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2002-2019 by Guido Vollbeding.\n+ * Modified 2002-2020 by Guido Vollbeding.\n@@ -167,1 +167,1 @@\n-  \/* Probably this should be in the color conversion module... *\/\n+  \/* This should correspond to the actual code in the color conversion module. *\/\n@@ -176,1 +176,1 @@\n-  default:            \/* else must be same colorspace as in file *\/\n+  default:    \/* YCCK <=> CMYK conversion or same colorspace as in file *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdmaster.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2013-2019 by Guido Vollbeding.\n+ * Modified 2013-2022 by Guido Vollbeding.\n@@ -23,2 +23,2 @@\n- * At typical sampling ratios, this eliminates half or three-quarters of the\n- * multiplications needed for color conversion.\n+ * At typical sampling ratios, this eliminates half or three-quarters\n+ * of the multiplications needed for color conversion.\n@@ -31,3 +31,3 @@\n- * Other special cases could be added, but in most applications these are\n- * the only common cases.  (For uncommon cases we fall back on the more\n- * general code in jdsample.c and jdcolor.c.)\n+ * Other special cases could be added, but in most applications these\n+ * are the only common cases.  (For uncommon cases we fall back on\n+ * the more general code in jdsample.c and jdcolor.c.)\n@@ -289,1 +289,0 @@\n-    cred   = Crrtab[cr];\n@@ -292,0 +291,1 @@\n+    cred   = Crrtab[cr];\n@@ -306,0 +306,1 @@\n+    y  = GETJSAMPLE(*inptr0);\n@@ -308,7 +309,5 @@\n-    cred   = Crrtab[cr];\n-    cgreen = (int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr], SCALEBITS);\n-    cblue  = Cbbtab[cb];\n-    y  = GETJSAMPLE(*inptr0);\n-    outptr[RGB_RED]   = range_limit[y + cred];\n-    outptr[RGB_GREEN] = range_limit[y + cgreen];\n-    outptr[RGB_BLUE]  = range_limit[y + cblue];\n+    outptr[RGB_RED]   = range_limit[y + Crrtab[cr]];\n+    outptr[RGB_GREEN] = range_limit[y +\n+                  ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],\n+                         SCALEBITS))];\n+    outptr[RGB_BLUE]  = range_limit[y + Cbbtab[cb]];\n@@ -353,1 +352,0 @@\n-    cred   = Crrtab[cr];\n@@ -356,0 +354,1 @@\n+    cred   = Crrtab[cr];\n@@ -382,1 +381,0 @@\n-    cred   = Crrtab[cr];\n@@ -385,0 +383,1 @@\n+    cred   = Crrtab[cr];\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdmerge.c","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2002-2015 by Guido Vollbeding.\n+ * Modified 2002-2020 by Guido Vollbeding.\n@@ -105,0 +105,1 @@\n+      \/* Don't bother to upsample an uninteresting component. *\/\n@@ -164,7 +165,0 @@\n-\n-\n-\/*\n- * This is a no-op version used for \"uninteresting\" components.\n- * These components will not be referenced by color conversion.\n- *\/\n-\n@@ -308,0 +302,1 @@\n+    \/* Don't bother to upsample an uninteresting component. *\/\n@@ -320,1 +315,0 @@\n-      \/* Don't bother to upsample an uninteresting component. *\/\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jdsample.c","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2017 by Guido Vollbeding.\n+ * Modified 2017-2022 by Guido Vollbeding.\n@@ -14,2 +14,2 @@\n- * NOTE: this file is NOT intended to be included by applications using the\n- * JPEG library.  Most applications need only include jpeglib.h.\n+ * NOTE: this file is NOT intended to be included by applications using\n+ * the JPEG library.  Most applications need only include jpeglib.h.\n@@ -90,0 +90,44 @@\n+ *\n+ * You can define your own custom file I\/O functions in jconfig.h and\n+ * #define JPEG_HAVE_FILE_IO_CUSTOM there to prevent redefinition here.\n+ *\n+ * You can #define JPEG_USE_FILE_IO_CUSTOM in jconfig.h to use custom file\n+ * I\/O functions implemented in Delphi VCL (Visual Component Library)\n+ * in Vcl.Imaging.jpeg.pas for the TJPEGImage component utilizing\n+ * the Delphi RTL (Run-Time Library) TMemoryStream component:\n+ *\n+ *   procedure jpeg_stdio_src(var cinfo: jpeg_decompress_struct;\n+ *     input_file: TStream); external;\n+ *\n+ *   procedure jpeg_stdio_dest(var cinfo: jpeg_compress_struct;\n+ *     output_file: TStream); external;\n+ *\n+ *   function jfread(var buf; recsize, reccount: Integer; S: TStream): Integer;\n+ *   begin\n+ *     Result := S.Read(buf, recsize * reccount);\n+ *   end;\n+ *\n+ *   function jfwrite(const buf; recsize, reccount: Integer; S: TStream): Integer;\n+ *   begin\n+ *     Result := S.Write(buf, recsize * reccount);\n+ *   end;\n+ *\n+ *   function jfflush(S: TStream): Integer;\n+ *   begin\n+ *     Result := 0;\n+ *   end;\n+ *\n+ *   function jferror(S: TStream): Integer;\n+ *   begin\n+ *     Result := 0;\n+ *   end;\n+ *\n+ * TMemoryStream of Delphi RTL has the distinctive feature to provide dynamic\n+ * memory buffer management with a file\/stream-based interface, particularly for\n+ * the write (output) operation, which is easier to apply compared with direct\n+ * implementations as given in jdatadst.c for memory destination.  Those direct\n+ * implementations of dynamic memory write tend to be more difficult to use,\n+ * so providing an option like TMemoryStream may be a useful alternative.\n+ *\n+ * The CFile\/CMemFile classes of the Microsoft Foundation Class (MFC) Library\n+ * may be used in a similar fashion.\n@@ -92,0 +136,14 @@\n+#ifndef JPEG_HAVE_FILE_IO_CUSTOM\n+#ifdef JPEG_USE_FILE_IO_CUSTOM\n+extern size_t jfread(void * __ptr, size_t __size, size_t __n, FILE * __stream);\n+extern size_t jfwrite(const void * __ptr, size_t __size, size_t __n, FILE * __stream);\n+extern int    jfflush(FILE * __stream);\n+extern int    jferror(FILE * __fp);\n+\n+#define JFREAD(file,buf,sizeofbuf)  \\\n+  ((size_t) jfread((void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))\n+#define JFWRITE(file,buf,sizeofbuf)  \\\n+  ((size_t) jfwrite((const void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))\n+#define JFFLUSH(file)    jfflush(file)\n+#define JFERROR(file)    jferror(file)\n+#else\n@@ -98,0 +156,2 @@\n+#endif\n+#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jinclude.h","additions":63,"deletions":3,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 1997-2013 by Guido Vollbeding.\n+ * Modified 1997-2022 by Guido Vollbeding.\n@@ -387,3 +387,6 @@\n- * change these macros.  You can also deal with formats such as R,G,B,X\n- * (one extra byte per pixel) by changing RGB_PIXELSIZE.  Note that changing\n- * the offsets will also change the order in which colormap data is organized.\n+ * #define JPEG_USE_RGB_CUSTOM in jconfig.h, or define your own custom\n+ * order in jconfig.h and #define JPEG_HAVE_RGB_CUSTOM.\n+ * You can also deal with formats such as R,G,B,X (one extra byte per pixel)\n+ * by changing RGB_PIXELSIZE.\n+ * Note that changing the offsets will also change\n+ * the order in which colormap data is organized.\n@@ -393,2 +396,2 @@\n- *    is not 3 (they don't understand about dummy color components!).  So you\n- *    can't use color quantization if you change that value.\n+ *    is not 3 (they don't understand about dummy color components!).\n+ *    So you can't use color quantization if you change that value.\n@@ -397,1 +400,7 @@\n-#define RGB_RED        0    \/* Offset of Red in an RGB scanline element *\/\n+#ifndef JPEG_HAVE_RGB_CUSTOM\n+#ifdef JPEG_USE_RGB_CUSTOM\n+#define RGB_RED    2    \/* Offset of Red in an RGB scanline element *\/\n+#define RGB_GREEN    1    \/* Offset of Green *\/\n+#define RGB_BLUE    0    \/* Offset of Blue *\/\n+#else\n+#define RGB_RED    0    \/* Offset of Red in an RGB scanline element *\/\n@@ -400,0 +409,1 @@\n+#endif\n@@ -401,0 +411,1 @@\n+#endif\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jmorecfg.h","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 1997-2019 by Guido Vollbeding.\n+ * Modified 1997-2020 by Guido Vollbeding.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jpegint.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2002-2019 by Guido Vollbeding.\n+ * Modified 2002-2022 by Guido Vollbeding.\n@@ -42,1 +42,1 @@\n-#define JPEG_LIB_VERSION_MINOR  5\n+#define JPEG_LIB_VERSION_MINOR  6\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jpeglib.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2011 by Guido Vollbeding.\n+ * Modified 2011-2020 by Guido Vollbeding.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jquant1.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2011 by Guido Vollbeding.\n+ * Modified 2011-2020 by Guido Vollbeding.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jquant2.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,1 +5,1 @@\n- * Modified 2009-2019 by Guido Vollbeding.\n+ * Modified 2009-2020 by Guido Vollbeding.\n@@ -181,2 +181,2 @@\n- * num_rows rows are copied from input_array[source_row++]\n- * to output_array[dest_row++]; these areas may overlap for duplication.\n+ * num_rows rows are copied from *input_array++ to *output_array++;\n+ * these areas may overlap for duplication.\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jutils.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (C) 1991-2020, Thomas G. Lane, Guido Vollbeding.\n+ * Copyright (C) 1991-2024, Thomas G. Lane, Guido Vollbeding.\n@@ -12,1 +12,1 @@\n-#define JVERSION    \"9e  16-Jan-2022\"\n+#define JVERSION    \"9f  14-Jan-2024\"\n@@ -14,1 +14,1 @@\n-#define JCOPYRIGHT    \"Copyright (C) 2022, Thomas G. Lane, Guido Vollbeding\"\n+#define JCOPYRIGHT    \"Copyright (C) 2024, Thomas G. Lane, Guido Vollbeding\"\n","filename":"modules\/javafx.graphics\/src\/main\/native-iio\/libjpeg\/jversion.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}