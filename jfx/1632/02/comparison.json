{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -29,1 +30,0 @@\n-\n@@ -42,0 +42,17 @@\n+        return fireEvent(eventTarget, null, event);\n+    }\n+\n+    \/**\n+     * Dispatches an event to the specified {@code eventTarget}, optionally extending the event\n+     * dispatch chain up to the {@code delegateTarget}. The delegate target must be a descendant\n+     * of the {@code eventTarget}.\n+     *\n+     * @param eventTarget    the event target, not {@code null}\n+     * @param delegateTarget the delegate event target, may be {@code null}\n+     * @param event          the event\n+     * @return the event after processing, or {@code null}\n+     *\/\n+    public static Event fireEvent(EventTarget eventTarget, EventTarget delegateTarget, Event event) {\n+        Objects.requireNonNull(eventTarget, \"Event target cannot be null\");\n+        Objects.requireNonNull(event, \"Event cannot be null\");\n+\n@@ -46,0 +63,2 @@\n+        EventTarget actualTarget = delegateTarget != null ? delegateTarget : eventTarget;\n+\n@@ -49,2 +68,1 @@\n-            return fireEventImpl(new EventDispatchChainImpl(),\n-                                 eventTarget, event);\n+            return fireEventImpl(new EventDispatchChainImpl(), actualTarget, event);\n@@ -54,1 +72,1 @@\n-            return fireEventImpl(eventDispatchChain, eventTarget, event);\n+            return fireEventImpl(eventDispatchChain, actualTarget, event);\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/event\/EventUtil.java","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.util.EventObject;\n-\n-import com.sun.javafx.event.EventUtil;\n@@ -32,0 +29,2 @@\n+import java.util.EventObject;\n+import java.util.Objects;\n@@ -191,7 +190,2 @@\n-        if (eventTarget == null) {\n-            throw new NullPointerException(\"Event target must not be null!\");\n-        }\n-\n-        if (event == null) {\n-            throw new NullPointerException(\"Event must not be null!\");\n-        }\n+        Objects.requireNonNull(eventTarget, \"Event target cannot be null\");\n+        Objects.requireNonNull(event, \"Event cannot be null\");\n@@ -199,1 +193,1 @@\n-        EventUtil.fireEvent(eventTarget, event);\n+        eventTarget.dispatchEvent(event);\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/event\/Event.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import com.sun.javafx.event.EventUtil;\n+\n@@ -52,0 +54,4 @@\n+     * <p>\n+     * While the event dispatch chain returned from this method could be used to dispatch an event,\n+     * doing so is strongly discouraged. Dispatching an event correctly may require cooperation of\n+     * the event target, which is only guaranteed when using the {@link #dispatchEvent(Event)} method.\n@@ -58,0 +64,18 @@\n+    \/**\n+     * Dispatches the specified event to this event target. The event travels through the event dispatch\n+     * chain that was constructed with {@link #buildEventDispatchChain(EventDispatchChain)}.\n+     * <p>\n+     * This method returns {@code null} to indicate that the event was consumed by an event handler in the\n+     * event dispatch chain. If a non-{@code null} value is returned, it represents the unconsumed event\n+     * after being processed by the event dispatch chain. The returned event object will most likely not be\n+     * the same instance as the event object that was passed into this method, as the event may be copied,\n+     * replaced, or transformed as it travels through the event dispatch chain.\n+     *\n+     * @param event the event to dispatch\n+     * @return the processed event, or {@code null} if the event was consumed\n+     * @since 26\n+     *\/\n+    default Event dispatchEvent(Event event) {\n+        return EventUtil.fireEvent(this, event);\n+    }\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/event\/EventTarget.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import com.sun.javafx.scene.control.ListenerHelper;\n+import com.sun.javafx.scene.control.inputmap.InputMap;\n@@ -33,1 +35,1 @@\n-import com.sun.javafx.scene.control.inputmap.InputMap;\n+import javafx.scene.input.KeyCode;\n@@ -36,1 +38,0 @@\n-\n@@ -39,3 +40,0 @@\n-import static javafx.scene.input.KeyCode.*;\n-import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;\n-\n@@ -51,0 +49,1 @@\n+    private final ListenerHelper listenerHelper = new ListenerHelper();\n@@ -72,2 +71,0 @@\n-\n-\n@@ -87,15 +84,14 @@\n-        \/\/ then spinner-specific mappings for key and mouse input\n-        addDefaultMapping(spinnerInputMap,\n-            new KeyMapping(UP, KeyEvent.KEY_PRESSED, e -> {\n-                if (arrowsAreVertical()) increment(1); else FocusTraversalInputMap.traverseUp(e);\n-            }),\n-            new KeyMapping(RIGHT, KeyEvent.KEY_PRESSED, e -> {\n-                if (! arrowsAreVertical()) increment(1); else FocusTraversalInputMap.traverseRight(e);\n-            }),\n-            new KeyMapping(LEFT, KeyEvent.KEY_PRESSED, e -> {\n-                if (! arrowsAreVertical()) decrement(1); else FocusTraversalInputMap.traverseLeft(e);\n-            }),\n-            new KeyMapping(DOWN, KeyEvent.KEY_PRESSED, e -> {\n-                if (arrowsAreVertical()) decrement(1); else FocusTraversalInputMap.traverseDown(e);\n-            })\n-        );\n+        listenerHelper.addEventFilter(spinner, KeyEvent.KEY_PRESSED, e -> {\n+            boolean arrowsAreVertical = arrowsAreVertical();\n+            KeyCode increment = arrowsAreVertical ? KeyCode.UP : KeyCode.RIGHT;\n+            KeyCode decrement = arrowsAreVertical ? KeyCode.DOWN : KeyCode.LEFT;\n+\n+            if (e.getCode() == increment) {\n+                increment(1);\n+                e.consume();\n+            }\n+            else if (e.getCode() == decrement) {\n+                decrement(1);\n+                e.consume();\n+            }\n+        });\n@@ -104,1 +100,5 @@\n-\n+    @Override\n+    public void dispose() {\n+        listenerHelper.disconnect();\n+        super.dispose();\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/SpinnerBehavior.java","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,4 +159,0 @@\n-        EventHandler<ActionEvent> onAction = textField.getOnAction();\n-        \/\/ use textField as target to prevent immediate copy in dispatch\n-        ActionEvent actionEvent = new ActionEvent(textField, textField);\n-\n@@ -164,4 +160,6 @@\n-        textField.fireEvent(actionEvent);\n-        \/\/ fix of JDK-8207759: reverted logic\n-        \/\/ mapping not auto-consume and consume if handled by action\n-        if (onAction != null || actionEvent.isConsumed()) {\n+\n+        \/\/ We consume the KeyEvent (ENTER) that caused the text field to fire the ActionEvent\n+        \/\/ only if the ActionEvent was consumed. This seems to be a strange behavior and should\n+        \/\/ be examined in the future.\n+        ActionEvent actionEvent = new ActionEvent(textField, textField);\n+        if (textField.dispatchEvent(actionEvent) == null) {\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TextFieldBehavior.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -598,0 +598,5 @@\n+    @Override\n+    protected boolean isFocusScope() {\n+        return true;\n+    }\n+\n@@ -637,0 +642,9 @@\n+    @Override\n+    protected Node getFocusDelegate(Node hoistingNode) {\n+        if (skinBase != null) {\n+            return skinBase.getFocusDelegate(hoistingNode);\n+        }\n+\n+        return null;\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/Control.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import javafx.scene.Parent;\n@@ -193,0 +194,12 @@\n+    \/**\n+     * Overriding this method allows skins to specify the {@link Parent#getFocusDelegate(Node)}.\n+     *\n+     * @param hoistingNode the descendant of this skin that hoisted the focus request\n+     *                     (not necessarily the focus delegate), or {@code null}\n+     * @return the focus delegate\n+     * @since 26\n+     *\/\n+    protected Node getFocusDelegate(Node hoistingNode) {\n+        return null;\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/SkinBase.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import com.sun.javafx.scene.control.FakeFocusTextField;\n@@ -40,1 +39,0 @@\n-import javafx.collections.MapChangeListener;\n@@ -156,11 +154,0 @@\n-        \/\/ Fix for JDK-8115009\n-        getProperties().addListener((MapChangeListener<Object, Object>) change -> {\n-            if (change.wasAdded()) {\n-                if (change.getKey() == \"FOCUSED\") {\n-                    setFocused((Boolean)change.getValueAdded());\n-                    getProperties().remove(\"FOCUSED\");\n-                }\n-            }\n-        });\n-        \/\/ End of fix for JDK-8115009\n-\n@@ -613,1 +600,1 @@\n-            textField = new FakeFocusTextField();\n+            textField = new TextField();\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/Spinner.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-import com.sun.javafx.scene.control.FakeFocusTextField;\n@@ -109,0 +108,1 @@\n+        textField.setHoistFocus(true);\n@@ -119,0 +119,1 @@\n+        incrementArrow.setHoistFocus(true);\n@@ -135,0 +136,1 @@\n+        incrementArrowButton.setHoistFocus(true);\n@@ -145,0 +147,1 @@\n+        decrementArrow.setHoistFocus(true);\n@@ -161,0 +164,1 @@\n+        decrementArrowButton.setHoistFocus(true);\n@@ -172,45 +176,0 @@\n-        \/\/ Fixes in the same vein as ComboBoxListViewSkin\n-\n-        \/\/ move fake focus in to the textfield if the spinner is editable\n-        lh.addChangeListener(control.focusedProperty(), (op) -> {\n-            \/\/ Fix for the regression noted in a comment in JDK-8115009.\n-            ((FakeFocusTextField)textField).setFakeFocus(control.isFocused());\n-        });\n-\n-        lh.addEventFilter(control, KeyEvent.ANY, (ke) -> {\n-            if (control.isEditable()) {\n-                \/\/ This prevents a stack overflow from our rebroadcasting of the\n-                \/\/ event to the textfield that occurs in the final else statement\n-                \/\/ of the conditions below.\n-                if (ke.getTarget().equals(textField)) return;\n-\n-                \/\/ Fix for JDK-8095537 which led to a stack overflow\n-                if (ke.getCode() == KeyCode.ESCAPE) return;\n-\n-                \/\/ This and the additional check of isIncDecKeyEvent in\n-                \/\/ textField's event filter fix JDK-8185937.\n-                if (isIncDecKeyEvent(ke)) return;\n-\n-                \/\/ Fix for the regression noted in a comment in JDK-8115009.\n-                \/\/ This forwards the event down into the TextField when\n-                \/\/ the key event is actually received by the Spinner.\n-                textField.fireEvent(ke.copyFor(textField, textField));\n-\n-                if (ke.getCode() == KeyCode.ENTER) return;\n-\n-                ke.consume();\n-            }\n-        });\n-\n-        \/\/ This event filter is to enable keyboard events being delivered to the\n-        \/\/ spinner when the user has mouse clicked into the TextField area of the\n-        \/\/ Spinner control. Without this the up\/down\/left\/right arrow keys don't\n-        \/\/ work when you click inside the TextField area (but they do in the case\n-        \/\/ of tabbing in).\n-        lh.addEventFilter(textField, KeyEvent.ANY, (ke) -> {\n-            if (! control.isEditable() || isIncDecKeyEvent(ke)) {\n-                control.fireEvent(ke.copyFor(control, control));\n-                ke.consume();\n-            }\n-        });\n-\n@@ -219,3 +178,0 @@\n-            \/\/ Fix for JDK-8115009\n-            control.getProperties().put(\"FOCUSED\", hasFocus);\n-            \/\/ --- end of JDK-8115009\n@@ -232,2 +188,0 @@\n-        \/\/ end of comboBox-esque fixes\n-\n@@ -295,0 +249,5 @@\n+    @Override\n+    protected Node getFocusDelegate(Node hoistingNode) {\n+        return textField;\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/SpinnerSkin.java","additions":11,"deletions":52,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene;\n+\n+import javafx.event.Event;\n+import javafx.event.EventDispatchChain;\n+import javafx.event.EventDispatcher;\n+import javafx.scene.Node;\n+\n+\/**\n+ * Special-purpose event dispatcher that is used by {@link Node} to retarget an event to its focus delegate.\n+ *\/\n+public final class DelegatingEventDispatcher implements EventDispatcher {\n+\n+    private final Node parent;\n+    private final Node delegate;\n+    private final EventDispatcher dispatcher;\n+\n+    public DelegatingEventDispatcher(Node parent, Node delegate, EventDispatcher dispatcher) {\n+        this.parent = parent;\n+        this.delegate = delegate;\n+        this.dispatcher = dispatcher;\n+    }\n+\n+    @Override\n+    public Event dispatchEvent(Event event, EventDispatchChain tail) {\n+        \/\/ Focus delegation is the only scenario in which the event target may be the parent node.\n+        \/\/ Since we are in the capturing phase, we need to retarget the event to the focus delegate.\n+        boolean retarget = event.getTarget() == parent;\n+        if (retarget) {\n+            event = event.copyFor(event.getSource(), delegate);\n+        }\n+\n+        \/\/ Dispatch the event to the node's event dispatcher, or if the node doesn't have one,\n+        \/\/ directly to the rest of the event dispatch chain.\n+        if (dispatcher != null) {\n+            event = dispatcher.dispatchEvent(event, tail);\n+        } else {\n+            event = tail.dispatchEvent(event);\n+        }\n+\n+        \/\/ The event was consumed, nothing left to do.\n+        if (event == null) {\n+            return null;\n+        }\n+\n+        \/\/ Now we are in the bubbling phase. If we retargeted the capturing event earlier,\n+        \/\/ we now need to retarget the bubbling event back to its original target.\n+        return retarget ? event.copyFor(event.getSource(), parent) : event;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/DelegatingEventDispatcher.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n-\n+import com.sun.javafx.event.EventUtil;\n@@ -30,0 +30,1 @@\n+import com.sun.javafx.scene.DelegatingEventDispatcher;\n@@ -110,0 +111,1 @@\n+import java.lang.ref.WeakReference;\n@@ -652,1 +654,1 @@\n-                node.requestFocusVisible();\n+                node.requestFocus(null, true);\n@@ -1038,1 +1040,1 @@\n-                    updateParentsFocusWithin(oldParent, newParent);\n+                    updateFocus(oldParent, newParent);\n@@ -6827,0 +6829,2 @@\n+        private WeakReference<Node> hoistingNode;\n+        private WeakReference<Node> delegateNode;\n@@ -7297,0 +7301,48 @@\n+\n+        public void setHoistingNode(Node hoistingNode) {\n+            this.hoistingNode = new WeakReference<>(hoistingNode);\n+        }\n+\n+        public Node getHoistingNode() {\n+            Node node = getDescendantNode(hoistingNode, true);\n+            if (node == null) {\n+                hoistingNode = null;\n+            }\n+\n+            return node;\n+        }\n+\n+        public void setDelegateNode(Node delegateNode) {\n+            this.delegateNode = new WeakReference<>(delegateNode);\n+        }\n+\n+        public Node getDelegateNode(boolean verifyParent) {\n+            Node node = getDescendantNode(delegateNode, verifyParent);\n+            if (node == null) {\n+                delegateNode = null;\n+            }\n+\n+            return node;\n+        }\n+\n+        private Node getDescendantNode(WeakReference<Node> nodeRef, boolean verifyParent) {\n+            Node node = nodeRef != null ? nodeRef.get() : null;\n+            if (node == null) {\n+                return null;\n+            }\n+\n+            if (!verifyParent) {\n+                return node;\n+            }\n+\n+            Node parent = node.getParent();\n+            while (parent != null) {\n+                if (parent == Node.this) {\n+                    return node;\n+                }\n+\n+                parent = parent.getParent();\n+            }\n+\n+            return null;\n+        }\n@@ -8266,0 +8318,14 @@\n+\n+        if (focused) {\n+            Node delegate = getFocusDelegate(getHoistingNode());\n+            setDelegateNode(delegate);\n+\n+            if (delegate != null) {\n+                delegate.setFocusQuietly(focused, focusVisible);\n+            }\n+        } else {\n+            Node delegate = getDelegateNode();\n+            if (delegate != null) {\n+                delegate.setFocusQuietly(false, false);\n+            }\n+        }\n@@ -8274,0 +8340,5 @@\n+        Node delegate = getDelegateNode();\n+        if (delegate != null) {\n+            delegate.notifyFocusListeners();\n+        }\n+\n@@ -8285,10 +8356,31 @@\n-     * Called when the current node was removed from or added to the scene graph.\n-     * If the current node has the focusWithin bit, we also need to clear and set the focusWithin bits of this\n-     * node's old and new parents. Note that a scene graph can have more than a single focused node, for example\n-     * when a PopupWindow is used to present a branch of the scene graph. Since we need to preserve multi-level\n-     * focus, we need to adjust the focus-within count on all parents of the node.\n-     *\/\n-    private void updateParentsFocusWithin(Node oldParent, Node newParent) {\n-        if (!focusWithin.get()) {\n-            return;\n-        }\n+     * Updates the focus state when the current node was removed from or added to the scene graph.\n+     * <p>\n+     * This is a complex operation that consists of four steps:\n+     * <ol>\n+     *     <li>Update the focus-within bits of the old and new parents:<br>\n+     *         If the current node has the focusWithin bit, we also need to clear and set the focusWithin bits of this\n+     *         node's old and new parents. Note that a scene graph can have more than a single focused node, for example\n+     *         when a PopupWindow is used to present a branch of the scene graph, or when a node acquires focus by\n+     *         delegation. Since we need to preserve multi-level focus, we need to adjust the focus-within count on all\n+     *         old and new parents of the node.\n+     *\n+     *     <li>Clear delegated focus bits:<br>\n+     *         Usually, the focus bits are not cleared when a node is removed from the scene graph. However, when this\n+     *         node or any of its descendants received focus by delegation, we clear all focus bits in the delegation\n+     *         chain from this node down.\n+     *\n+     *     <li>Re-evaluate the delegation chain and update delegated focus bits:<br>\n+     *         Since the parent of this node changed, the delegation chain must be re-evaluated from the last ascendant\n+     *         that delegated focus to this node or any of its descendants.\n+     *\n+     *     <li>Notify focus listeners:<br>\n+     *         We notify the focus listeners only after the focus states of all participating nodes were updated.\n+     *         This is the last step and ensures that listeners will not see inconsistent transient focus states.\n+     * <\/ol>\n+     *\/\n+    private void updateFocus(Node oldParent, Node newParent) {\n+        class UpdateFocusImpl {\n+            static void updateParentsFocusWithin(Node thisNode, Node oldParent, Node newParent) {\n+                if (!thisNode.focusWithin.get()) {\n+                    return;\n+                }\n@@ -8296,4 +8388,69 @@\n-        Node node = oldParent;\n-        while (node != null) {\n-            node.focusWithin.adjust(-focusWithin.count);\n-            node = node.getParent();\n+                Node parent = oldParent;\n+                while (parent != null) {\n+                    parent.focusWithin.adjust(-thisNode.focusWithin.count);\n+                    parent = parent.getParent();\n+                }\n+\n+                parent = newParent;\n+                while (parent != null) {\n+                    parent.focusWithin.adjust(thisNode.focusWithin.count);\n+                    parent = parent.getParent();\n+                };\n+            }\n+\n+            static Node clearDelegatedFocus(Node thisNode, Node oldParent) {\n+                Node principal = oldParent;\n+                Node delegate = null;\n+\n+                while (principal != null && delegate == null) {\n+                    delegate = principal.miscProperties != null\n+                        ? principal.miscProperties.getDelegateNode(false)\n+                        : null;\n+\n+                    principal = principal.getParent();\n+                }\n+\n+                if (delegate == thisNode) {\n+                    delegate.setFocusQuietly(false, false);\n+                    return delegate;\n+                }\n+\n+                if (delegate != null) {\n+                    Node parent = delegate.getParent();\n+\n+                    while (parent != thisNode && parent != null) {\n+                        parent = parent.getParent();\n+                    }\n+\n+                    if (parent == thisNode) {\n+                        delegate.setFocusQuietly(false, false);\n+                        return delegate;\n+                    }\n+                }\n+\n+                return null;\n+            }\n+\n+            static Node updateDelegatedFocus(Node newParent) {\n+                if (newParent == null) {\n+                    return null;\n+                }\n+\n+                Node focusedParent = newParent;\n+                while (focusedParent != null && !focusedParent.isFocused()) {\n+                    focusedParent = focusedParent.getParent();\n+                }\n+\n+                if (focusedParent != null) {\n+                    focusedParent.setFocusQuietly(true, focusedParent.isFocusVisible());\n+                    return focusedParent;\n+                }\n+\n+                return null;\n+            }\n+\n+            static void notifyFocusListeners(Node node) {\n+                if (node != null) {\n+                    node.notifyFocusListeners();\n+                }\n+            }\n@@ -8302,5 +8459,22 @@\n-        node = newParent;\n-        while (node != null) {\n-            node.focusWithin.adjust(focusWithin.count);\n-            node = node.getParent();\n-        };\n+        UpdateFocusImpl.updateParentsFocusWithin(this, oldParent, newParent);\n+        Node delegate = UpdateFocusImpl.clearDelegatedFocus(this, oldParent);\n+        Node focusedParent = UpdateFocusImpl.updateDelegatedFocus(newParent);\n+        UpdateFocusImpl.notifyFocusListeners(delegate);\n+        UpdateFocusImpl.notifyFocusListeners(focusedParent);\n+        UpdateFocusImpl.notifyFocusListeners(oldParent);\n+        UpdateFocusImpl.notifyFocusListeners(newParent);\n+    }\n+\n+    \/**\n+     * Gets the tracked hoisting node of this node, which is always a descendant of this node.\n+     * <p>\n+     * Note that the hoisting node is tracked as a snapshot in time, which means that when we are trying\n+     * to resolve it, it might already have been removed from the scene graph, or moved to a different\n+     * place so that is is no longer a descendant of this node.\n+     *\n+     * @return the hoisting node, or {@code null} if no hoisting node is tracked or if the tracked\n+     *         node is not a descendant of this node\n+     *\/\n+    private Node getHoistingNode() {\n+        return miscProperties != null ? miscProperties.getHoistingNode() : null;\n+    }\n@@ -8308,4 +8482,12 @@\n-        \/\/ Since focus changes are atomic, we only fire change notifications after\n-        \/\/ all changes are committed on all old and new parents.\n-        if (oldParent != null) {\n-            oldParent.notifyFocusListeners();\n+    \/**\n+     * Sets the hoisting node for this node.\n+     * <p>\n+     * Note that the hoisting node is tracked as a weak reference.\n+     *\n+     * @param node the hoisting node\n+     *\/\n+    private void setHoistingNode(Node node) {\n+        if (miscProperties != null) {\n+            miscProperties.setHoistingNode(node);\n+        } else if (node != null) {\n+            getMiscProperties().setHoistingNode(node);\n@@ -8313,0 +8495,1 @@\n+    }\n@@ -8314,2 +8497,26 @@\n-        if (newParent != null) {\n-            newParent.notifyFocusListeners();\n+    \/**\n+     * Gets the tracked delegate node of this node, which is always a descendant of this node.\n+     * <p>\n+     * Note that the delegate node is tracked as a snapshot in time, which means that when we are trying\n+     * to resolve it, it might already have been removed from the scene graph, or moved to a different\n+     * place so that is is no longer a descendant of this node.\n+     *\n+     * @return the delegate node, or {@code null} if no delegate node is tracked or if the tracked\n+     *         node is not a descendant of this node\n+     *\/\n+    private Node getDelegateNode() {\n+        return miscProperties != null ? miscProperties.getDelegateNode(true) : null;\n+    }\n+\n+    \/**\n+     * Sets the delegate node for this node.\n+     * <p>\n+     * Note that the delegate node is tracked as a weak reference.\n+     *\n+     * @param node the delegate node\n+     *\/\n+    private void setDelegateNode(Node node) {\n+        if (miscProperties != null) {\n+            miscProperties.setDelegateNode(node);\n+        } else if (node != null) {\n+            getMiscProperties().setDelegateNode(node);\n@@ -8320,4 +8527,11 @@\n-     * Indicates whether this {@code Node} currently has the input focus.\n-     * To have the input focus, a node must be the {@code Scene}'s focus\n-     * owner, and the scene must be in a {@code Stage} that is visible\n-     * and active. See {@link #requestFocus()} for more information.\n+     * Indicates whether this {@code Node} is currently focused. The node may be focused because it acquired\n+     * the input focus with {@link #requestFocus()}, mouse or touch interaction, focus traversal, or because\n+     * the input focus was {@link #getFocusDelegate(Node) delegated} to this node.\n+     * <p>\n+     * In addition, the focused flag can also be manually set with the {@link #setFocused(boolean)} method.\n+     * This is strongly discouraged, because it can break the expectation that a focused node has the input focus.\n+     * Note that a node can only have the input focus if it is shown in a {@link Window} and the window is\n+     * {@link Window#showingProperty() showing} and {@link Window#focusedProperty() focused}.\n+     * <p>\n+     * If this node has the input focus and is the primary focus principal, it is the\n+     * {@link Scene#focusOwnerProperty() focus owner} of its {@code Scene}.\n@@ -8325,1 +8539,0 @@\n-     * @see #requestFocus()\n@@ -8328,1 +8541,3 @@\n-    private final FocusPropertyBase focused = new FocusPropertyBase() {\n+    private final FocusedProperty focused = new FocusedProperty();\n+\n+    private final class FocusedProperty extends FocusPropertyBase {\n@@ -8351,0 +8566,4 @@\n+                if (!value) {\n+                    setHoistingNode(null);\n+                }\n+\n@@ -8407,2 +8626,2 @@\n-     * Indicates whether this {@code Node} or any of its descendants currently\n-     * has the input focus.\n+     * Indicates whether this {@code Node} or any of its descendants are currently\n+     * {@link #focusedProperty() focused}.\n@@ -8504,0 +8723,116 @@\n+    \/**\n+     * Specifies whether this {@code Node} should hoist focus requests to the root of its closest focus scope.\n+     * <p>\n+     * When this property is set to {@code true}, calling the {@link #requestFocus()} method has no effect on\n+     * this node, but is equivalent to requesting focus for the closest ancestor for which {@link #isFocusScope()}\n+     * returns {@code true}.\n+     *\n+     * @since 26\n+     *\/\n+    private BooleanProperty hoistFocus;\n+\n+    public final boolean isHoistFocus() {\n+        return hoistFocus == null ? false : hoistFocus.get();\n+    }\n+\n+    public final void setHoistFocus(boolean value) {\n+        if (value || hoistFocus != null) {\n+            hoistFocusProperty().set(value);\n+        }\n+    }\n+\n+    public final BooleanProperty hoistFocusProperty() {\n+        if (hoistFocus == null) {\n+            hoistFocus = new BooleanPropertyBase() {\n+                @Override\n+                public Object getBean() {\n+                    return Node.this;\n+                }\n+\n+                @Override\n+                public String getName() {\n+                    return \"hoistFocus\";\n+                }\n+            };\n+        }\n+\n+        return hoistFocus;\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Node} is the root of a focus scope, making it eligible to receive a focus request\n+     * that was {@link #hoistFocus hoisted} by a descendant node. A hoisted focus request bubbles up the scene graph\n+     * until it is consumed by the root of a focus scope as if by calling {@link #requestFocus()}. In this way, the\n+     * root of the focus scope will be the receiver of the focus request.\n+     * <p>\n+     * Focus scopes can be nested, and the root node of a focus scope can also hoist focus requests itself by setting\n+     * its {@code hoistFocus} flag. In this way, a focus request can potentially bubble up through several focus scopes.\n+     * <p>\n+     * Focus scoping is often combined with {@link #getFocusDelegate() focus delegation}.\n+     *\n+     * @return {@code true} if this {@code Node} is eligible to receive hoisted focus requests;\n+     *         {@code false} otherwise\n+     * @since 26\n+     *\/\n+    boolean isFocusScope() {\n+        return false;\n+    }\n+\n+    \/**\n+     * Gets the focus delegate for this {@code Node}, which must be a descendant of this {@code Node}.\n+     * <p>\n+     * Focus delegation allows nodes to delegate events targeted at them to one of their descendants instead.\n+     * This is a technique used by controls that need to isolate their internal structure from their external\n+     * representation, making the external representation appear as a monolithic entity (a \"black box\").\n+     * <p>\n+     * Consider a value spinner control, which consists of a numeric text field and a set of buttons to increase\n+     * or decrease its value. Users of this control should be able to treat the control as a monolithic entity\n+     * that can be focused as a whole (instead of its contituent parts) and be the source and target of events.\n+     * It would be surprising for users of the value spinner control to find out that, in order for it to receive\n+     * keyboard events, the internal text field must be focused, but the control as a whole would not be.\n+     * In particular, this would also imply that a listener installed on the control would not see input events\n+     * being targeted at the control, but at the internal text field instead.\n+     * <p>\n+     * Focus delegation solves this problem by having the node that represents the control as a whole be the\n+     * <em>focus principal<\/em>, which means that it is the primary receiver of input focus, and it is the source and\n+     * target of input events. The focus principal, being aware of its internal structure, delegates focus to one of\n+     * its descendants by returning the corresponding descendant node from this method. When the focus principal then\n+     * receives focus, the internal delegate is focused as well. Similarly, when an input event is received by the\n+     * focus principal, it is re-targeted at the internal delegate (unless the focus principal consumes the event).\n+     * A focus delegate might be a focus principal itself, forming a chain of focus delegation.\n+     * <p>\n+     * If an implementation returns a node from this method that is not a descendant, JavaFX ignores the returned\n+     * node and treats this node as having no focus delegate.\n+     * <p>\n+     * Focus delegation is often combined with {@link #isFocusScope() focus scoping}.\n+     *\n+     * @param hoistingNode the descendant of this {@code Node} that hoisted the focus request\n+     *                     (not necessarily the focus delegate), or {@code null}\n+     * @return the focus delegate, which is a descendant of this {@code Node}\n+     * @since 26\n+     *\/\n+    Node getFocusDelegate(Node hoistingNode) {\n+        return null;\n+    }\n+\n+    \/**\n+     * Resolves a chain of focus delegates and returns the final focus delegate.\n+     *\n+     * @return the final focus delegate, or {@code null} if this node has no focus delegate,\n+     *         or if the focus delegate is not a descendant of this node\n+     *\/\n+    Node resolveFocusDelegate() {\n+        Node delegate = getDelegateNode();\n+        if (delegate == null) {\n+            return null;\n+        }\n+\n+        Node node;\n+        do {\n+            node = delegate;\n+            delegate = node.getDelegateNode();\n+        } while (delegate != null);\n+\n+        return node;\n+    }\n+\n@@ -8522,10 +8857,13 @@\n-     * Requests that this {@code Node} get the input focus, and that this\n-     * {@code Node}'s top-level ancestor become the focused window. To be\n-     * eligible to receive the focus, the node must be part of a scene, it and\n-     * all of its ancestors must be visible, and it must not be disabled.\n-     * If this node is eligible, this function will cause it to become this\n-     * {@code Scene}'s \"focus owner\". Each scene has at most one focus owner\n-     * node. The focus owner will not actually have the input focus, however,\n-     * unless the scene belongs to a {@code Stage} that is both visible\n-     * and active.\n-     * <p>This method will clear the {@link #focusVisible} flag.\n+     * Requests that this {@code Node} receive the input focus, and that this node's window become the\n+     * {@link Window#focusedProperty() focused} window. A node is only eligible to receive the input focus if it is\n+     * part of a {@link Scene}, the node and all of its ancestors are {@link #visibleProperty() visible}, and it is\n+     * not {@link #disabledProperty() disabled}.\n+     * <p>\n+     * If this node {@link #hoistFocusProperty() hoists} the focus request, calling this method is equivalent to\n+     * calling {@code requestFocus()} on the root of the closest {@link #isFocusScope() focus scope}; if there is\n+     * no focus scope, the method call on this node proceeds as usual.\n+     * <p>\n+     * If this node doesn't hoist the focus request (or if there is no focus scope) and successfully receives the\n+     * input focus, it will also be the {@link Scene#focusOwnerProperty() focus owner} of its {@code Scene}.\n+     * <p>\n+     * This method will clear the {@link #focusVisible} flag.\n@@ -8534,3 +8872,1 @@\n-        if (getScene() != null) {\n-            getScene().requestFocus(this, false);\n-        }\n+        requestFocus(null, false);\n@@ -8539,7 +8875,4 @@\n-    \/**\n-     * Requests focus as if by calling {@link #requestFocus()}, and additionally\n-     * sets the {@link #focusVisible} flag.\n-     *\/\n-    private void requestFocusVisible() {\n-        if (getScene() != null) {\n-            getScene().requestFocus(this, true);\n+    private void requestFocus(Node hoistingNode, boolean focusVisible) {\n+        var scene = getScene();\n+        if (scene == null) {\n+            return;\n@@ -8547,0 +8880,13 @@\n+\n+        setHoistingNode(hoistingNode);\n+\n+        if (isHoistFocus()) {\n+            for (Node node = getParent(); node != null; node = node.getParent()) {\n+                if (node.isFocusScope()) {\n+                    node.requestFocus(this, focusVisible);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        scene.requestFocus(this, focusVisible);\n@@ -8964,7 +9310,17 @@\n-        Node curNode = this;\n-        do {\n-            if (curNode.eventDispatcher != null) {\n-                final EventDispatcher eventDispatcherValue =\n-                        curNode.eventDispatcher.get();\n-                if (eventDispatcherValue != null) {\n-                    tail = tail.prepend(eventDispatcherValue);\n+        for (Node curNode = this, curParent = getParent();\n+             curNode != null;\n+             curNode = curParent != null ? curParent : curNode.getSubScene(),\n+             curParent = curNode != null ? curNode.getParent() : null) {\n+\n+            \/\/ If our parent has a focus delegate, we need to use a special dispatcher that can retarget\n+            \/\/ the event to the focus delegate (even if this node doesn't have an event dispatcher itself).\n+            if (curParent != null && curParent.getDelegateNode() instanceof Node delegate) {\n+                EventDispatcher dispatcher = curNode.eventDispatcher != null ? curNode.eventDispatcher.get() : null;\n+                tail = tail.prepend(new DelegatingEventDispatcher(curParent, delegate, dispatcher));\n+            } else {\n+                EventDispatcher dispatcher = curNode.eventDispatcher != null\n+                    ? curNode.eventDispatcher.get()\n+                    : null;\n+\n+                if (dispatcher != null) {\n+                    tail = tail.prepend(dispatcher);\n@@ -8973,3 +9329,1 @@\n-            final Node curParent = curNode.getParent();\n-            curNode = curParent != null ? curParent : curNode.getSubScene();\n-        } while (curNode != null);\n+        }\n@@ -9000,0 +9354,2 @@\n+        dispatchEvent(event);\n+    }\n@@ -9001,0 +9357,2 @@\n+    @Override\n+    public final Event dispatchEvent(Event event) {\n@@ -9020,1 +9378,1 @@\n-        Event.fireEvent(this, event);\n+        return EventUtil.fireEvent(this, resolveFocusDelegate(), event);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":425,"deletions":67,"binary":false,"changes":492,"status":"modified"},{"patch":"@@ -1502,0 +1502,10 @@\n+    @Override\n+    protected boolean isFocusScope() { \/\/ Overridden to make the method protected\n+        return false;\n+    }\n+\n+    @Override\n+    protected Node getFocusDelegate(Node hoistingNode) { \/\/ Overridden to make the method protected\n+        return null;\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Parent.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1957,2 +1957,5 @@\n-                final Bounds bounds = sceneFocusOwner.localToScene(\n-                        sceneFocusOwner.getBoundsInLocal());\n+                Node delegate = sceneFocusOwner.resolveFocusDelegate();\n+                Bounds bounds = delegate != null\n+                        ? delegate.localToScene(delegate.getBoundsInLocal())\n+                        : sceneFocusOwner.localToScene(sceneFocusOwner.getBoundsInLocal());\n+\n@@ -1986,1 +1989,1 @@\n-            handled = EventUtil.fireEvent(eventTarget, context) == null;\n+            handled = eventTarget.dispatchEvent(context) == null;\n@@ -2254,1 +2257,1 @@\n-        return EventUtil.fireEvent(eventTarget, e) == null;\n+        return eventTarget.dispatchEvent(e) == null;\n@@ -2280,5 +2283,14 @@\n-      * The scene's current focus owner node. This node's \"focused\"\n-      * variable might be false if this scene has no window, or if the\n-      * window is inactive (window.focused == false).\n-      * @since JavaFX 2.2\n-      *\/\n+     * The focus owner of this {@code Scene} is the primary focus principal that receives the input focus when the\n+     * scene is shown in a {@link Window} and the window is {@link Window#focusedProperty() focused}.\n+     * <p>\n+     * The primary focus principal is usually the node for which input focus was {@link Node#requestFocus() requested}.\n+     * However, when a control uses {@link Parent#getFocusDelegate(Node) focus delegation}, the primary focus principal\n+     * is the outermost node that delegates focus to one of its descendants. Note that in a chain of delegation, all\n+     * nodes but the last node are focus principals (meaning that they delegate focus), but only the root node of the\n+     * chain is the focus owner.\n+     * <p>\n+     * The focus owner is retained even when the window loses focus, so that the input focus can be restored when the\n+     * window is focused again.\n+     *\n+     * @since JavaFX 2.2\n+     *\/\n@@ -2287,2 +2299,3 @@\n-    private class FocusOwnerProperty extends ReadOnlyObjectWrapper<Node> {\n-        Node oldFocusOwner;\n+    private final class FocusOwnerProperty extends ReadOnlyObjectPropertyBase<Node> {\n+        private Node currentValue;\n+        private int scope = 0;\n@@ -2308,3 +2321,7 @@\n-        protected void invalidated() {\n-            if (oldFocusOwner != null) {\n-                oldFocusOwner.setFocusQuietly(false, false);\n+        public Node get() {\n+            return currentValue;\n+        }\n+\n+        public void set(Node newValue) {\n+            if (currentValue != null && currentValue != newValue) {\n+                currentValue.setFocusQuietly(false, false);\n@@ -2312,5 +2329,6 @@\n-            Node value = get();\n-            if (value != null) {\n-                value.setFocusQuietly(windowFocused, focusVisible);\n-                if (value != oldFocusOwner) {\n-                    InputMethodStateManager manager = value.getScene().getInputMethodStateManager();\n+\n+            if (newValue != null) {\n+                newValue.setFocusQuietly(windowFocused, focusVisible);\n+\n+                if (currentValue != newValue) {\n+                    InputMethodStateManager manager = newValue.getScene().getInputMethodStateManager();\n@@ -2318,1 +2336,1 @@\n-                        manager.focusOwnerChanged(oldFocusOwner, value);\n+                        manager.focusOwnerChanged(currentValue, newValue);\n@@ -2322,1 +2340,2 @@\n-            \/\/ for the rest of the method we need to update the oldFocusOwner\n+\n+            \/\/ for the rest of the method we need to update the currentValue\n@@ -2325,17 +2344,25 @@\n-            Node localOldOwner = oldFocusOwner;\n-            oldFocusOwner = value;\n-            if (localOldOwner != null) {\n-                localOldOwner.notifyFocusListeners();\n-            }\n-            if (value != null) {\n-                value.notifyFocusListeners();\n-            }\n-            PlatformLogger logger = Logging.getFocusLogger();\n-            if (logger.isLoggable(Level.FINE)) {\n-                if (value == get()) {\n-                    logger.fine(\"Changed focus from \"\n-                            + localOldOwner + \" to \" + value);\n-                } else {\n-                    logger.fine(\"Changing focus from \"\n-                            + localOldOwner + \" to \" + value\n-                            + \" canceled by nested requestFocus\");\n+            Node oldValue = currentValue;\n+            currentValue = newValue;\n+\n+            try {\n+                scope++;\n+\n+                if (oldValue != null) {\n+                    oldValue.notifyFocusListeners();\n+                }\n+\n+                if (newValue != null) {\n+                    newValue.notifyFocusListeners();\n+                }\n+            } finally {\n+                if (--scope == 0 && currentValue != oldValue) {\n+                    if (accessible != null) {\n+                        accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);\n+                    }\n+\n+                    PlatformLogger logger = Logging.getFocusLogger();\n+                    if (logger.isLoggable(Level.FINE)) {\n+                        logger.fine(\"Changed focus from \" + oldValue + \" to \" + currentValue);\n+                    }\n+\n+                    fireValueChangedEvent();\n@@ -2343,3 +2370,0 @@\n-            }\n-            if (accessible != null) {\n-                accessible.sendNotification(AccessibleAttribute.FOCUS_NODE);\n@@ -2351,1 +2375,1 @@\n-        return focusOwner.getReadOnlyProperty();\n+        return focusOwner;\n@@ -2362,1 +2386,1 @@\n-        if (focusOwner.oldFocusOwner != null) {\n+        if (focusOwner.currentValue != null) {\n@@ -2369,12 +2393,1 @@\n-\n-        if (focusOwner.get() != node) {\n-            \/\/ If the focus owner has changed, FocusOwnerProperty::invalidated will update\n-            \/\/ the node's focusVisible flag.\n-            focusOwner.set(node);\n-        } else if (node != null) {\n-            \/\/ If the focus owner has not changed (i.e. only focusVisible has changed),\n-            \/\/ FocusOwnerProperty::invalidated will not be called, therefore we need to\n-            \/\/ update the node's focusVisible flag manually.\n-            node.focusVisible.set(focusVisible);\n-            node.focusVisible.notifyListeners();\n-        }\n+        focusOwner.set(node);\n@@ -2391,1 +2404,1 @@\n-            node.fireEvent(e);\n+            node.dispatchEvent(e);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":69,"deletions":56,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,0 +93,12 @@\n+    public static void setFocusQuietly(Node n, boolean focused, boolean focusVisible) {\n+        n.setFocusQuietly(focused, focusVisible);\n+    }\n+\n+    public static void notifyFocusListeners(Node n) {\n+        n.notifyFocusListeners();\n+    }\n+\n+    public static Node resolveFocusDelegate(Node n) {\n+        return n.resolveFocusDelegate();\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/javafx\/scene\/NodeShim.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import javafx.scene.input.KeyEvent;\n+\n@@ -30,0 +32,4 @@\n+    public static void processKeyEvent(Scene s, KeyEvent e) {\n+        s.processKeyEvent(e);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/javafx\/scene\/SceneShim.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.javafx.scene.NodeHelper;\n@@ -31,0 +32,1 @@\n+import javafx.scene.NodeShim;\n@@ -40,0 +42,1 @@\n+import java.util.stream.Stream;\n@@ -57,0 +60,1 @@\n+import org.junit.jupiter.api.Nested;\n@@ -58,6 +62,2 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertNull;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-import static org.junit.jupiter.api.Assertions.fail;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -124,0 +124,6 @@\n+    private void assertIsFocused(Node... ns) {\n+        for (Node n : ns) {\n+            assertIsFocused(n);\n+        }\n+    }\n+\n@@ -134,0 +140,6 @@\n+    private void assertNotFocused(Node... ns) {\n+        for (Node n : ns) {\n+            assertNotFocused(n);\n+        }\n+    }\n+\n@@ -1164,0 +1176,637 @@\n+    @Nested\n+    class FocusDelegateTest {\n+        static class N extends Group {\n+            final Node delegate;\n+            final String name;\n+\n+            N() {\n+                this(null, (Node)null, null);\n+            }\n+\n+            N(String name) {\n+                this(name, (Node)null, null);\n+            }\n+\n+            N(String name, Node child) {\n+                this(name, child, null);\n+            }\n+\n+            N(String name, Node child, Node delegate) {\n+                this(name, child == null ? new Node[0] : new Node[] { child }, delegate);\n+            }\n+\n+            N(Node child) {\n+                this(null, new Node[] { child }, null);\n+            }\n+\n+            N(Node[] children) {\n+                this(null, children, null);\n+            }\n+\n+            N(Node[] children, Node delegate) {\n+                this(null, children, delegate);\n+            }\n+\n+            N(Node child, Node delegate) {\n+                this(null, child, delegate);\n+            }\n+\n+            N(String name, Node[] children, Node delegate) {\n+                super(children);\n+                this.delegate = delegate;\n+                this.name = name;\n+            }\n+\n+            @Override\n+            protected Node getFocusDelegate(Node hoistingNode) {\n+                return delegate;\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return name;\n+            }\n+        }\n+\n+        static class Trace extends ArrayList<String> {\n+            Trace(Node... nodes) {\n+                for (Node node : nodes) {\n+                    node.addEventFilter(\n+                        Event.ANY,\n+                        e -> add(String.format(\"EventFilter[source=%s, target=%s]\", e.getSource(), e.getTarget())));\n+\n+                    node.addEventHandler(\n+                        Event.ANY,\n+                        e -> add(String.format(\"EventHandler[source=%s, target=%s]\", e.getSource(), e.getTarget())));\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Focusing a node that delegates focus to a descendant will focus both the original node\n+         * and its descendant. This test asserts that this also works in nested scenarios, when the\n+         * delegation target delegates focus further down the scene graph.\n+         *\/\n+        @Test\n+        void focusIsDelegatedToDescendants() {\n+            N node1, node2, node3, node4, node5;\n+\n+            \/\/ node1 . . . . . . . . . focusDelegate = node3\n+            \/\/ └── node2\n+            \/\/     └── node3 . . . . . focusDelegate = node5\n+            \/\/         └── node4\n+            \/\/             └── node5\n+            scene.setRoot(\n+                node1 = new N(\n+                    node2 = new N(\n+                        node3 = new N(\n+                            node4 = new N(\n+                                node5 = new N()\n+                            ), node5\n+                        )\n+                    ), node3\n+                ));\n+\n+            assertNotFocused(node1, node2, node3, node4, node5);\n+\n+            node1.requestFocus();\n+\n+            assertIsFocused(node1, node3, node5);\n+            assertIsFocused(scene, node1);\n+        }\n+\n+        \/**\n+         * This test is similar to {@link #focusIsDelegatedToDescendants()}, except that instead of\n+         * focusing the root node, the intermediate focus delegate is focused. This will result in\n+         * the root node being unfocused, while the intermediate focus delegate and its delegation\n+         * target are focused.\n+         *\/\n+        @Test\n+        void focusIsDelegatedToSubtreeDescendants() {\n+            N node1, node2, node3, node4, node5;\n+\n+            \/\/ node1 . . . . . . . . . focusDelegate = node3\n+            \/\/ └── node2\n+            \/\/     └── node3 . . . . . focusDelegate = node5\n+            \/\/         └── node4\n+            \/\/             └── node5\n+            scene.setRoot(\n+                node1 = new N(\n+                    node2 = new N(\n+                        node3 = new N(\n+                            node4 = new N(\n+                                node5 = new N()\n+                            ), node5\n+                        )\n+                    ), node3\n+                ));\n+\n+            assertNotFocused(node1, node2, node3, node4, node5);\n+\n+            node3.requestFocus();\n+\n+            assertIsFocused(node3, node5);\n+            assertIsFocused(scene, node3);\n+        }\n+\n+        \/**\n+         * When a scene sends a key event to the focus owner, it is delivered up to the final target\n+         * of delegation. The event target changes as the event travels through the scene graph:\n+         * First, the event is targeted at the focus owner. For each descendant node, the event is\n+         * targeted at the next focus delegate. When the capturing phase completes and the event starts\n+         * to bubble up, it is targeted back to its original targets as it crosses the boundary between\n+         * focus delegates.\n+         *\/\n+        @Test\n+        void keyEventIsDeliveredToFocusedDescendants() {\n+            N node1, node2, node3, node4, node5;\n+\n+            \/\/ node1 . . . . . . . . . focusDelegate = node3, focusOwner\n+            \/\/ └── node2\n+            \/\/     └── node3 . . . . . focusDelegate = node5\n+            \/\/         └── node4\n+            \/\/             └── node5\n+            scene.setRoot(\n+                node1 = new N(\"node1\",\n+                    node2 = new N(\"node2\",\n+                        node3 = new N(\"node3\",\n+                            node4 = new N(\"node4\",\n+                                node5 = new N(\"node5\")\n+                            ), node5\n+                        )\n+                    ), node3\n+                ));\n+\n+            node1.requestFocus();\n+\n+            var trace = new Trace(node1, node2, node3, node4, node5);\n+\n+            SceneShim.processKeyEvent(\n+                scene, new KeyEvent(KeyEvent.KEY_PRESSED, null, null, KeyCode.A, false, false, false, false));\n+\n+            assertEquals(\n+                List.of(\n+                    \"EventFilter[source=node1, target=node1]\", \/\/ <-- target is node1 (focusOwner)\n+                    \"EventFilter[source=node2, target=node3]\", \/\/ <-- change target to node3 (delegate)\n+                    \"EventFilter[source=node3, target=node3]\",\n+                    \"EventFilter[source=node4, target=node5]\", \/\/ <-- change target to node5 (delegate)\n+                    \"EventFilter[source=node5, target=node5]\",\n+                    \"EventHandler[source=node5, target=node5]\",\n+                    \"EventHandler[source=node4, target=node5]\",\n+                    \"EventHandler[source=node3, target=node3]\", \/\/ <-- change target back to node3\n+                    \"EventHandler[source=node2, target=node3]\",\n+                    \"EventHandler[source=node1, target=node1]\" \/\/ <-- change target back to node1\n+                ),\n+                trace\n+            );\n+        }\n+\n+        \/**\n+         * After {@link Node#requestFocus()} is called on a node that is already focused, the event dispatch\n+         * chain constructed when an event is dispatched reflects the new chain of focus delegates.\n+         *\/\n+        @Test\n+        void eventDispatchChainReflectsChangedFocusDelegatesAfterFocusRequest() {\n+            final N node1, node2, node3, node4a, node4b, node5a, node5b;\n+            final boolean[] switchDelegate = new boolean[1];\n+\n+            \/\/ node1 . . . . . . . . . focusDelegate = node3, focusOwner\n+            \/\/ └── node2\n+            \/\/     └── node3 . . . . . focusDelegate = node5a\/b\n+            \/\/         └── node4a\n+            \/\/         |   └── node5a\n+            \/\/         └── node4b\n+            \/\/             └── node5b\n+            scene.setRoot(\n+                node1 = new N(\"node1\",\n+                    node2 = new N(\"node2\",\n+                        node3 = new N(\"node3\",\n+                            new Node[] {\n+                                node4a = new N(\"node4a\",\n+                                    node5a = new N(\"node5a\")\n+                                ),\n+                                node4b = new N(\"node4b\",\n+                                    node5b = new N(\"node5b\")\n+                                )\n+                            }, node5a\n+                        ) {\n+                            @Override\n+                            protected Node getFocusDelegate(Node hoistingNode) {\n+                                return switchDelegate[0] ? node5b : node5a;\n+                            }\n+                        }\n+                    ), node3\n+                ));\n+\n+            var trace = new Trace(node1, node2, node3, node4a, node4b, node5a, node5b);\n+\n+            node1.requestFocus();\n+            SceneShim.processKeyEvent(\n+                scene, new KeyEvent(KeyEvent.KEY_PRESSED, null, null, KeyCode.A, false, false, false, false));\n+\n+            assertEquals(\n+                List.of(\n+                    \"EventFilter[source=node1, target=node1]\", \/\/ <-- target is node1 (focusOwner)\n+                    \"EventFilter[source=node2, target=node3]\", \/\/ <-- change target to node3 (delegate)\n+                    \"EventFilter[source=node3, target=node3]\",\n+                    \"EventFilter[source=node4a, target=node5a]\", \/\/ <-- change target to node5a (delegate)\n+                    \"EventFilter[source=node5a, target=node5a]\",\n+                    \"EventHandler[source=node5a, target=node5a]\",\n+                    \"EventHandler[source=node4a, target=node5a]\",\n+                    \"EventHandler[source=node3, target=node3]\", \/\/ <-- change target back to node3\n+                    \"EventHandler[source=node2, target=node3]\",\n+                    \"EventHandler[source=node1, target=node1]\" \/\/ <-- change target back to node1\n+                ),\n+                trace\n+            );\n+\n+            switchDelegate[0] = true;\n+            trace.clear();\n+\n+            node1.requestFocus();\n+            SceneShim.processKeyEvent(\n+                scene, new KeyEvent(KeyEvent.KEY_PRESSED, null, null, KeyCode.A, false, false, false, false));\n+\n+            assertEquals(\n+                List.of(\n+                    \"EventFilter[source=node1, target=node1]\", \/\/ <-- target is node1 (focusOwner)\n+                    \"EventFilter[source=node2, target=node3]\", \/\/ <-- change target to node3 (delegate)\n+                    \"EventFilter[source=node3, target=node3]\",\n+                    \"EventFilter[source=node4b, target=node5b]\", \/\/ <-- change target to node5b (delegate)\n+                    \"EventFilter[source=node5b, target=node5b]\",\n+                    \"EventHandler[source=node5b, target=node5b]\",\n+                    \"EventHandler[source=node4b, target=node5b]\",\n+                    \"EventHandler[source=node3, target=node3]\", \/\/ <-- change target back to node3\n+                    \"EventHandler[source=node2, target=node3]\",\n+                    \"EventHandler[source=node1, target=node1]\" \/\/ <-- change target back to node1\n+                ),\n+                trace\n+            );\n+        }\n+\n+        \/**\n+         * When {@link Node#requestFocus()} is called on a node that is already focused, focus delegates\n+         * and focused states are re-evaluated for the entire chain of focus delegation.\n+         *\/\n+        @Test\n+        void focusDelegatesAreReevaluatedWhenFocusIsRequestedAgain() {\n+            final N node1, node2, node3, node4a, node4b, node5a, node5b;\n+            final boolean[] switchDelegate = new boolean[1];\n+\n+            \/\/ node1 . . . . . . . . . focusDelegate = node3, focusOwner\n+            \/\/ └── node2\n+            \/\/     └── node3 . . . . . focusDelegate = node5a\/b\n+            \/\/         └── node4a\n+            \/\/         |   └── node5a\n+            \/\/         └── node4b\n+            \/\/             └── node5b\n+            scene.setRoot(\n+                node1 = new N(\n+                    node2 = new N(\n+                        node3 = new N(\n+                            new Node[] {\n+                                node4a = new N(\n+                                    node5a = new N()\n+                                ),\n+                                node4b = new N(\n+                                    node5b = new N()\n+                                )\n+                            }, node5a\n+                        ) {\n+                            @Override\n+                            protected Node getFocusDelegate(Node hoistingNode) {\n+                                return switchDelegate[0] ? node5b : node5a;\n+                            }\n+                        }\n+                    ), node3\n+                ));\n+\n+            node1.requestFocus();\n+            assertIsFocused(node1, node3, node5a);\n+            assertNotFocused(node2, node4a, node4b);\n+            assertSame(node5a, NodeShim.resolveFocusDelegate(node1));\n+\n+            switchDelegate[0] = true;\n+            node1.requestFocus();\n+            assertIsFocused(node1, node3, node5b);\n+            assertNotFocused(node2, node4a, node4b);\n+            assertSame(node5b, NodeShim.resolveFocusDelegate(node1));\n+        }\n+\n+        \/**\n+         * When a node that acquired focus by delegation is removed from the scene graph, its focus bits are\n+         * cleared (and those of its descendants). This ensures that a focus delegation chain is only valid\n+         * within a scene graph.\n+         *\/\n+        @Test\n+        void focusIsClearedOnDelegateNodeWhenRemovedFromSceneGraph() {\n+            N node1, node2, node3, node4, node5;\n+\n+            \/\/ node1 . . . . . . . . . focusDelegate = node3\n+            \/\/ └── node2\n+            \/\/     └── node3 . . . . . focusDelegate = node4\n+            \/\/         └── node4 . . . focusDelegate = node5\n+            \/\/             └── node5\n+            scene.setRoot(\n+                node1 = new N(\n+                    node2 = new N(\n+                        node3 = new N(\n+                            node4 = new N(\n+                                node5 = new N(), node5\n+                            ), node4\n+                        )\n+                    ), node3\n+                ));\n+\n+            node1.requestFocus();\n+            assertIsFocused(node3, node4, node5);\n+            assertIsFocused(scene, node1);\n+            assertNotFocused(node2);\n+\n+            node3.getChildren().clear();\n+            assertNotFocused(node4, node5);\n+        }\n+\n+        \/**\n+         * When a node that acquired focus by delegation is moved to a sibling branch of the scene graph,\n+         * the focus delegation chain is re-evaluated and focus bits are effectively retained. Note that\n+         * moving a node to a different branch in the scene graph removes the node before inserting it again.\n+         * Focus listeners will see a transient state where focus bits are cleared on the removed node.\n+         *\/\n+        @Test\n+        void focusIsRetainedWhenDelegateIsMovedToSiblingSubtree() {\n+            N node1, node2a, node2b, node3, node4, node5;\n+\n+            \/\/ node1 . . . . . . . . . focusDelegate = node4\n+            \/\/ └── node2a\n+            \/\/ |   └── node3\n+            \/\/ |       └── node4 . . . focusDelegate = node5\n+            \/\/ |           └── node5\n+            \/\/ └── node2b\n+            scene.setRoot(\n+                node1 = new N(\n+                    new Node[] {\n+                        node2a = new N(\n+                            node3 = new N(\n+                                node4 = new N(\n+                                    node5 = new N(), node5\n+                                )\n+                            )\n+                        ),\n+                        node2b = new N()\n+                    }, node4\n+                ));\n+\n+            List<Boolean> node4FocusedTrace = new ArrayList<>(),\n+                          node4FocusVisibleTrace = new ArrayList<>(),\n+                          node4FocusWithinTrace = new ArrayList<>();\n+            node4.focusedProperty().subscribe(node4FocusedTrace::addLast);\n+            node4.focusVisibleProperty().subscribe(node4FocusVisibleTrace::addLast);\n+            node4.focusWithinProperty().subscribe(node4FocusWithinTrace::addLast);\n+\n+            List<Boolean> node5FocusedTrace = new ArrayList<>(),\n+                          node5FocusVisibleTrace = new ArrayList<>(),\n+                          node5FocusWithinTrace = new ArrayList<>();\n+            node5.focusedProperty().subscribe(node5FocusedTrace::addLast);\n+            node5.focusVisibleProperty().subscribe(node5FocusVisibleTrace::addLast);\n+            node5.focusWithinProperty().subscribe(node5FocusWithinTrace::addLast);\n+\n+            node1.requestFocus();\n+\n+            assertIsFocused(node4, node5);\n+            assertIsFocused(scene, node1);\n+            assertNotFocused(node2a, node2b, node3);\n+            assertEquals(List.of(false, true), node4FocusedTrace);\n+            assertEquals(List.of(false), node4FocusVisibleTrace);\n+            assertEquals(List.of(false, true), node4FocusWithinTrace);\n+            assertEquals(List.of(false, true), node5FocusedTrace);\n+            assertEquals(List.of(false), node5FocusVisibleTrace);\n+            assertEquals(List.of(false, true), node5FocusWithinTrace);\n+\n+            node2b.getChildren().add(node3);\n+\n+            assertIsFocused(node4, node5);\n+            assertIsFocused(scene, node1);\n+            assertNotFocused(node2a, node2b, node3);\n+            assertEquals(List.of(false, true, false, true), node4FocusedTrace);\n+            assertEquals(List.of(false), node4FocusVisibleTrace);\n+            assertEquals(List.of(false, true, false, true), node4FocusWithinTrace);\n+            assertEquals(List.of(false, true, false, true), node5FocusedTrace);\n+            assertEquals(List.of(false), node5FocusVisibleTrace);\n+            assertEquals(List.of(false, true, false, true), node5FocusWithinTrace);\n+        }\n+    }\n+\n+    @Nested\n+    class FocusScopeTest {\n+        static class N extends Group {\n+            final boolean focusScope;\n+\n+            N(boolean focusScope, boolean hoistFocus, Node child) {\n+                super(child == null ? new Node[0] : new Node[] { child });\n+                this.focusScope = focusScope;\n+                setHoistFocus(hoistFocus);\n+            }\n+\n+            @Override\n+            protected boolean isFocusScope() {\n+                return focusScope;\n+            }\n+\n+            Node getHoistingNode() {\n+                try {\n+                    var method = Node.class.getDeclaredMethod(\"getHoistingNode\");\n+                    method.setAccessible(true);\n+                    return (Node)method.invoke(this, (Object[])null);\n+                } catch (ReflectiveOperationException e) {\n+                    throw new AssertionError(e);\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * A node with the {@link Node#hoistFocusProperty()} flag will hoist a focus request to the next\n+         * focus scope. The result is that the node that defines the focus scope is focused, and the node\n+         * that initially received the focus request is not.\n+         *\/\n+        @Test\n+        void hoistFocusRequestToNextScope() {\n+            N node1, node2, node3, node4, node5;\n+\n+            \/\/ node1 . . . . . . . . . . [hoistFocus]\n+            \/\/ └── node2 . . . . . . . . [hoistFocus]\n+            \/\/     └── node3 . . . . . . [focusScope, hoistFocus]\n+            \/\/         └── node4 . . . . [hoistFocus]\n+            \/\/             └── node5 . . [hoistFocus]\n+            scene.setRoot(\n+                node1 = new N(false, false,\n+                    node2 = new N(false, true,\n+                        node3 = new N(true, true,\n+                            node4 = new N(false, true,\n+                                node5 = new N(false, true, null)\n+                            )\n+                        )\n+                    )\n+                ));\n+\n+            node4.requestFocus();\n+            assertIsFocused(node3);\n+            assertNotFocused(node1, node2, node4, node5);\n+            assertTrue(Stream.of(node1, node2, node4, node5).allMatch(n -> n.getHoistingNode() == null));\n+            assertSame(node4, node3.getHoistingNode());\n+\n+            node5.requestFocus();\n+            assertIsFocused(node3);\n+            assertNotFocused(node1, node2, node4, node5);\n+            assertTrue(Stream.of(node1, node2, node4, node5).allMatch(n -> n.getHoistingNode() == null));\n+            assertSame(node5, node3.getHoistingNode());\n+        }\n+\n+        \/**\n+         * A node with the {@link Node#hoistFocusProperty()} flag will hoist a focus request to the next\n+         * focus scope. In this test, the result is that the node that defines the outermost focus scope\n+         * is focused, and all other nodes are not focused (this includes the intermediate focus scope).\n+         *\/\n+        @Test\n+        void hoistFocusRequestToOutermostScope() {\n+            N node1, node2, node3, node4, node5;\n+\n+            \/\/ node1 . . . . . . . . . . [focusScope]\n+            \/\/ └── node2 . . . . . . . . [hoistFocus]\n+            \/\/     └── node3 . . . . . . [focusScope, hoistFocus]\n+            \/\/         └── node4 . . . . [hoistFocus]\n+            \/\/             └── node5 . . [hoistFocus]\n+            scene.setRoot(\n+                node1 = new N(true, false,\n+                    node2 = new N(false, true,\n+                        node3 = new N(true, true,\n+                            node4 = new N(false, true,\n+                                node5 = new N(false, true, null)\n+                            )\n+                        )\n+                    )\n+                ));\n+\n+            node4.requestFocus();\n+            assertIsFocused(node1);\n+            assertNotFocused(node2, node3, node4, node5);\n+            assertTrue(Stream.of(node2, node4, node5).allMatch(n -> n.getHoistingNode() == null));\n+            assertSame(node4, node3.getHoistingNode());\n+            assertSame(node3, node1.getHoistingNode());\n+\n+            node5.requestFocus();\n+            assertIsFocused(node1);\n+            assertNotFocused(node2, node3, node4, node5);\n+            assertTrue(Stream.of(node2, node4, node5).allMatch(n -> n.getHoistingNode() == null));\n+            assertSame(node5, node3.getHoistingNode());\n+            assertSame(node3, node1.getHoistingNode());\n+        }\n+\n+        \/**\n+         * A node with the {@link Node#hoistFocusProperty()} flag will hoist a focus request to the next\n+         * focus scope. If the next focus scope does not have the {@link Node#hoistFocusProperty()} flag,\n+         * the focus request will not be hoisted again, even when an ancestor defines another focus scope.\n+         *\/\n+        @Test\n+        void hoistFocusRequestStopsWhenHoistFocusIsFalse() {\n+            N node1, node2, node3, node4, node5;\n+\n+            \/\/ node1 . . . . . . . . . . [focusScope]\n+            \/\/ └── node2 . . . . . . . . [hoistFocus]\n+            \/\/     └── node3 . . . . . . [focusScope]\n+            \/\/         └── node4 . . . . [hoistFocus]\n+            \/\/             └── node5 . . [hoistFocus]\n+            scene.setRoot(\n+                node1 = new N(true, false,\n+                    node2 = new N(false, true,\n+                        node3 = new N(true, false,\n+                            node4 = new N(false, true,\n+                                node5 = new N(false, true, null)\n+                            )\n+                        )\n+                    )\n+                ));\n+\n+            node4.requestFocus();\n+            assertIsFocused(node3);\n+            assertNotFocused(node1, node2, node4, node5);\n+            assertTrue(Stream.of(node1, node2, node4, node5).allMatch(n -> n.getHoistingNode() == null));\n+            assertSame(node4, node3.getHoistingNode());\n+\n+            node5.requestFocus();\n+            assertIsFocused(node3);\n+            assertNotFocused(node1, node2, node4, node5);\n+            assertTrue(Stream.of(node1, node2, node4, node5).allMatch(n -> n.getHoistingNode() == null));\n+            assertSame(node5, node3.getHoistingNode());\n+        }\n+\n+        \/**\n+         * When a node hoists a focus request to its focus scope, the receiving node will track the hoisting\n+         * node internally. Once the focus scope node loses focus, it will clear the reference to the node\n+         * that hoisted the focus request.\n+         *\/\n+        @Test\n+        void losingFocusClearsTrackedHoistingNode() {\n+            N node1, node2, node3;\n+\n+            \/\/ node1 . . . . . . . . . . [focusScope]\n+            \/\/ └── node2 . . . . . . . . [hoistFocus]\n+            \/\/     └── node3 . . . . . . [hoistFocus]\n+            scene.setRoot(\n+                node1 = new N(true, false,\n+                    node2 = new N(false, true,\n+                        node3 = new N(false, true, null)\n+                    )\n+                ));\n+\n+            node3.requestFocus();\n+            assertIsFocused(node1);\n+            assertNotFocused(node2, node3);\n+            assertTrue(Stream.of(node2, node3).allMatch(n -> n.getHoistingNode() == null));\n+            assertSame(node3, node1.getHoistingNode());\n+\n+            NodeShim.setFocusQuietly(node1, false, false);\n+            NodeShim.notifyFocusListeners(node1);\n+            assertNotFocused(node1, node2, node3);\n+            assertTrue(Stream.of(node1, node2, node3).allMatch(n -> n.getHoistingNode() == null));\n+        }\n+\n+        \/**\n+         * When a node hoists a focus request to its focus scope, the receiving node will track the hoisting\n+         * node internally. If the hoisting node is moved to a different place in the scene graph such that\n+         * it is no longer a descendant of the focus scope node, the tracking is cleared.\n+         *\/\n+        @Test\n+        void hoistingNodeIsNotResolvedWhenMovedOutOfDescendantSubtree() {\n+            N node1, node2, node3, node4;\n+\n+            \/\/ node1 . . . . . . . . . . []\n+            \/\/ └── node2 . . . . . . . . [focusScope]\n+            \/\/     └── node3 . . . . . . [hoistFocus]\n+            \/\/         └── node4 . . . . [hoistFocus]\n+            scene.setRoot(\n+                node1 = new N(false, false,\n+                    node2 = new N(true, false,\n+                        node3 = new N(false, true,\n+                            node4 = new N(false, true, null)\n+                        )\n+                    )\n+                ));\n+\n+            node4.requestFocus();\n+            assertIsFocused(node2);\n+            assertNotFocused(node1, node3, node4);\n+            assertTrue(Stream.of(node1, node3, node4).allMatch(n -> n.getHoistingNode() == null));\n+            assertSame(node4, node2.getHoistingNode());\n+\n+            \/\/ node1 . . . . . . . . . . []\n+            \/\/ └── node2 . . . . . . . . [focusScope]\n+            \/\/ |   └── node3 . . . . . . [hoistFocus]\n+            \/\/ └── node4 . . . . . . . . [hoistFocus]\n+            node3.getChildren().clear();\n+            node1.getChildren().add(node4);\n+            assertIsFocused(node2);\n+            assertNotFocused(node1, node3, node4);\n+            assertTrue(Stream.of(node1, node2, node3, node4).allMatch(n -> n.getHoistingNode() == null));\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/FocusTest.java","additions":656,"deletions":7,"binary":false,"changes":663,"status":"modified"}]}