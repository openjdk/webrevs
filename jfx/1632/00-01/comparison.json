{"files":[{"patch":"@@ -1040,1 +1040,1 @@\n-                    updateParentsFocusWithin(oldParent, newParent);\n+                    updateFocus(oldParent, newParent);\n@@ -6829,0 +6829,2 @@\n+        private WeakReference<Node> hoistingNode;\n+        private WeakReference<Node> delegateNode;\n@@ -7299,0 +7301,48 @@\n+\n+        public void setHoistingNode(Node hoistingNode) {\n+            this.hoistingNode = new WeakReference<>(hoistingNode);\n+        }\n+\n+        public Node getHoistingNode() {\n+            Node node = getDescendantNode(hoistingNode, true);\n+            if (node == null) {\n+                hoistingNode = null;\n+            }\n+\n+            return node;\n+        }\n+\n+        public void setDelegateNode(Node delegateNode) {\n+            this.delegateNode = new WeakReference<>(delegateNode);\n+        }\n+\n+        public Node getDelegateNode(boolean verifyParent) {\n+            Node node = getDescendantNode(delegateNode, verifyParent);\n+            if (node == null) {\n+                delegateNode = null;\n+            }\n+\n+            return node;\n+        }\n+\n+        private Node getDescendantNode(WeakReference<Node> nodeRef, boolean verifyParent) {\n+            Node node = nodeRef != null ? nodeRef.get() : null;\n+            if (node == null) {\n+                return null;\n+            }\n+\n+            if (!verifyParent) {\n+                return node;\n+            }\n+\n+            Node parent = node.getParent();\n+            while (parent != null) {\n+                if (parent == Node.this) {\n+                    return node;\n+                }\n+\n+                parent = parent.getParent();\n+            }\n+\n+            return null;\n+        }\n@@ -8269,3 +8319,12 @@\n-        Node delegate = getFocusDelegate(this.focused.getHoistingNode());\n-        if (delegate != null) {\n-            delegate.setFocusQuietly(focused, focusVisible);\n+        if (focused) {\n+            Node delegate = getFocusDelegate(getHoistingNode());\n+            setDelegateNode(delegate);\n+\n+            if (delegate != null) {\n+                delegate.setFocusQuietly(focused, focusVisible);\n+            }\n+        } else {\n+            Node delegate = getDelegateNode();\n+            if (delegate != null) {\n+                delegate.setFocusQuietly(false, false);\n+            }\n@@ -8281,1 +8340,1 @@\n-        Node delegate = getFocusDelegate(focused.getHoistingNode());\n+        Node delegate = getDelegateNode();\n@@ -8297,10 +8356,31 @@\n-     * Called when the current node was removed from or added to the scene graph.\n-     * If the current node has the focusWithin bit, we also need to clear and set the focusWithin bits of this\n-     * node's old and new parents. Note that a scene graph can have more than a single focused node, for example\n-     * when a PopupWindow is used to present a branch of the scene graph. Since we need to preserve multi-level\n-     * focus, we need to adjust the focus-within count on all parents of the node.\n-     *\/\n-    private void updateParentsFocusWithin(Node oldParent, Node newParent) {\n-        if (!focusWithin.get()) {\n-            return;\n-        }\n+     * Updates the focus state when the current node was removed from or added to the scene graph.\n+     * <p>\n+     * This is a complex operation that consists of four steps:\n+     * <ol>\n+     *     <li>Update the focus-within bits of the old and new parents:<br>\n+     *         If the current node has the focusWithin bit, we also need to clear and set the focusWithin bits of this\n+     *         node's old and new parents. Note that a scene graph can have more than a single focused node, for example\n+     *         when a PopupWindow is used to present a branch of the scene graph, or when a node acquires focus by\n+     *         delegation. Since we need to preserve multi-level focus, we need to adjust the focus-within count on all\n+     *         old and new parents of the node.\n+     *\n+     *     <li>Clear delegated focus bits:<br>\n+     *         Usually, the focus bits are not cleared when a node is removed from the scene graph. However, when this\n+     *         node or any of its descendants received focus by delegation, we clear all focus bits in the delegation\n+     *         chain from this node down.\n+     *\n+     *     <li>Re-evaluate the delegation chain and update delegated focus bits<br>\n+     *         Since the parent of this node changed, the delegation chain must be re-evaluated from the last ascendant\n+     *         that delegated focus to this node or any of its descendants.\n+     *\n+     *     <li>Notify focus listeners<br>\n+     *         We notify the focus listeners only after the focus states of all participating nodes were updated.\n+     *         This is the last step and ensures that listeners will not see inconsistent transient focus states.\n+     * <\/ol>\n+     *\/\n+    private void updateFocus(Node oldParent, Node newParent) {\n+        class UpdateFocusImpl {\n+            static void updateParentsFocusWithin(Node thisNode, Node oldParent, Node newParent) {\n+                if (!thisNode.focusWithin.get()) {\n+                    return;\n+                }\n@@ -8308,4 +8388,69 @@\n-        Node node = oldParent;\n-        while (node != null) {\n-            node.focusWithin.adjust(-focusWithin.count);\n-            node = node.getParent();\n+                Node parent = oldParent;\n+                while (parent != null) {\n+                    parent.focusWithin.adjust(-thisNode.focusWithin.count);\n+                    parent = parent.getParent();\n+                }\n+\n+                parent = newParent;\n+                while (parent != null) {\n+                    parent.focusWithin.adjust(thisNode.focusWithin.count);\n+                    parent = parent.getParent();\n+                };\n+            }\n+\n+            static Node clearDelegatedFocus(Node thisNode, Node oldParent) {\n+                Node principal = oldParent;\n+                Node delegate = null;\n+\n+                while (principal != null && delegate == null) {\n+                    delegate = principal.miscProperties != null\n+                        ? principal.miscProperties.getDelegateNode(false)\n+                        : null;\n+\n+                    principal = principal.getParent();\n+                }\n+\n+                if (delegate == thisNode) {\n+                    delegate.setFocusQuietly(false, false);\n+                    return delegate;\n+                }\n+\n+                if (delegate != null) {\n+                    Node parent = delegate.getParent();\n+\n+                    while (parent != thisNode && parent != null) {\n+                        parent = parent.getParent();\n+                    }\n+\n+                    if (parent == thisNode) {\n+                        delegate.setFocusQuietly(false, false);\n+                        return delegate;\n+                    }\n+                }\n+\n+                return null;\n+            }\n+\n+            static Node updateDelegatedFocus(Node newParent) {\n+                if (newParent == null) {\n+                    return null;\n+                }\n+\n+                Node focusedParent = newParent;\n+                while (focusedParent != null && !focusedParent.isFocused()) {\n+                    focusedParent = focusedParent.getParent();\n+                }\n+\n+                if (focusedParent != null) {\n+                    focusedParent.setFocusQuietly(true, focusedParent.isFocusVisible());\n+                    return focusedParent;\n+                }\n+\n+                return null;\n+            }\n+\n+            static void notifyFocusListeners(Node node) {\n+                if (node != null) {\n+                    node.notifyFocusListeners();\n+                }\n+            }\n@@ -8314,5 +8459,8 @@\n-        node = newParent;\n-        while (node != null) {\n-            node.focusWithin.adjust(focusWithin.count);\n-            node = node.getParent();\n-        };\n+        UpdateFocusImpl.updateParentsFocusWithin(this, oldParent, newParent);\n+        Node delegate = UpdateFocusImpl.clearDelegatedFocus(this, oldParent);\n+        Node focusedParent = UpdateFocusImpl.updateDelegatedFocus(newParent);\n+        UpdateFocusImpl.notifyFocusListeners(delegate);\n+        UpdateFocusImpl.notifyFocusListeners(focusedParent);\n+        UpdateFocusImpl.notifyFocusListeners(oldParent);\n+        UpdateFocusImpl.notifyFocusListeners(newParent);\n+    }\n@@ -8320,4 +8468,26 @@\n-        \/\/ Since focus changes are atomic, we only fire change notifications after\n-        \/\/ all changes are committed on all old and new parents.\n-        if (oldParent != null) {\n-            oldParent.notifyFocusListeners();\n+    \/**\n+     * Gets the tracked hoisting node of this node, which is always a descendant of this node.\n+     * <p>\n+     * Note that the hoisting node is tracked as a snapshot in time, which means that when we are trying\n+     * to resolve it, it might already have been removed from the scene graph, or moved to a different\n+     * place so that is is no longer a descendant of this node.\n+     *\n+     * @return the hoisting node, or {@code null} if no hoisting node is tracked or if the tracked\n+     *         node is not a descendant of this node\n+     *\/\n+    private Node getHoistingNode() {\n+        return miscProperties != null ? miscProperties.getHoistingNode() : null;\n+    }\n+\n+    \/**\n+     * Sets the hoisting node for this node.\n+     * <p>\n+     * Note that the hoisting node is tracked as a weak reference.\n+     *\n+     * @param node the hoisting node\n+     *\/\n+    private void setHoistingNode(Node node) {\n+        if (miscProperties != null) {\n+            miscProperties.setHoistingNode(node);\n+        } else if (node != null) {\n+            getMiscProperties().setHoistingNode(node);\n@@ -8325,0 +8495,15 @@\n+    }\n+\n+    \/**\n+     * Gets the tracked delegate node of this node, which is always a descendant of this node.\n+     * <p>\n+     * Note that the delegate node is tracked as a snapshot in time, which means that when we are trying\n+     * to resolve it, it might already have been removed from the scene graph, or moved to a different\n+     * place so that is is no longer a descendant of this node.\n+     *\n+     * @return the delegate node, or {@code null} if no delegate node is tracked or if the tracked\n+     *         node is not a descendant of this node\n+     *\/\n+    private Node getDelegateNode() {\n+        return miscProperties != null ? miscProperties.getDelegateNode(true) : null;\n+    }\n@@ -8326,2 +8511,12 @@\n-        if (newParent != null) {\n-            newParent.notifyFocusListeners();\n+    \/**\n+     * Sets the delegate node for this node.\n+     * <p>\n+     * Note that the delegate node is tracked as a weak reference.\n+     *\n+     * @param node the delegate node\n+     *\/\n+    private void setDelegateNode(Node node) {\n+        if (miscProperties != null) {\n+            miscProperties.setDelegateNode(node);\n+        } else if (node != null) {\n+            getMiscProperties().setDelegateNode(node);\n@@ -8349,2 +8544,0 @@\n-        private WeakReference<Node> hoistingNode;\n-\n@@ -8374,1 +8567,1 @@\n-                    hoistingNode = null;\n+                    setHoistingNode(null);\n@@ -8388,33 +8581,0 @@\n-\n-        private void setHoistingNode(Node hoistingNode) {\n-            this.hoistingNode = new WeakReference<>(hoistingNode);\n-        }\n-\n-        \/**\n-         * Resolves the hoisting node of this focused node, which is always a descendant of this node.\n-         *\n-         * @return the hoisting node, or {@code null} if no hoisting node is tracked or if the tracked\n-         *         node is not a descendant of this node\n-         *\/\n-        private Node getHoistingNode() {\n-            Node hoistingNode = this.hoistingNode != null ? this.hoistingNode.get() : null;\n-            if (hoistingNode == null) {\n-                return null;\n-            }\n-\n-            \/\/ Note that the hoisting node is tracked as a snapshot in time, which means that when we are trying\n-            \/\/ to resolve it, it might already have been removed from the scene graph, or moved to a different\n-            \/\/ place so that is is no longer a descendant of this node. We need to walk up the scene graph to\n-            \/\/ find out whether the hoisting node is still a descendant of this node.\n-            Node parent = hoistingNode.getParent();\n-            while (parent != null) {\n-                if (parent == Node.this) {\n-                    return hoistingNode;\n-                }\n-\n-                parent = parent.getParent();\n-            }\n-\n-            this.hoistingNode = null;\n-            return null;\n-        }\n@@ -8659,2 +8819,1 @@\n-     * Resolves a chain of focus delegates.\n-     * This method also verifies that a focus delegate is a descendant of this node.\n+     * Resolves a chain of focus delegates and returns the final focus delegate.\n@@ -8665,2 +8824,2 @@\n-    final Node resolveFocusDelegate() {\n-        Node delegate = getFocusDelegate(focused.getHoistingNode());\n+    Node resolveFocusDelegate() {\n+        Node delegate = getDelegateNode();\n@@ -8671,8 +8830,5 @@\n-        Node parent = delegate.getParent();\n-        while (parent != this && parent != null) {\n-            parent = parent.getParent();\n-        }\n-\n-        if (parent == null) {\n-            return null;\n-        }\n+        Node node;\n+        do {\n+            node = delegate;\n+            delegate = node.getDelegateNode();\n+        } while (delegate != null);\n@@ -8680,2 +8836,1 @@\n-        Node nextDelegate = delegate.resolveFocusDelegate();\n-        return nextDelegate != null ? nextDelegate : delegate;\n+        return node;\n@@ -8726,1 +8881,1 @@\n-        focused.setHoistingNode(hoistingNode);\n+        setHoistingNode(hoistingNode);\n@@ -9162,1 +9317,1 @@\n-            if (curParent != null && curParent.getFocusDelegate(focused.getHoistingNode()) instanceof Node delegate) {\n+            if (curParent != null && curParent.getDelegateNode() instanceof Node delegate) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":237,"deletions":82,"binary":false,"changes":319,"status":"modified"},{"patch":"@@ -101,0 +101,4 @@\n+    public static Node resolveFocusDelegate(Node n) {\n+        return n.resolveFocusDelegate();\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/javafx\/scene\/NodeShim.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.scene.NodeHelper;\n@@ -1181,0 +1182,12 @@\n+            N() {\n+                this(null, (Node)null, null);\n+            }\n+\n+            N(String name) {\n+                this(name, (Node)null, null);\n+            }\n+\n+            N(String name, Node child) {\n+                this(name, child, null);\n+            }\n+\n@@ -1182,3 +1195,13 @@\n-                super(child == null ? new Node[0] : new Node[] { child });\n-                this.delegate = delegate;\n-                this.name = name;\n+                this(name, child == null ? new Node[0] : new Node[] { child }, delegate);\n+            }\n+\n+            N(Node child) {\n+                this(null, new Node[] { child }, null);\n+            }\n+\n+            N(Node[] children) {\n+                this(null, children, null);\n+            }\n+\n+            N(Node[] children, Node delegate) {\n+                this(null, children, delegate);\n@@ -1191,0 +1214,6 @@\n+            N(String name, Node[] children, Node delegate) {\n+                super(children);\n+                this.delegate = delegate;\n+                this.name = name;\n+            }\n+\n@@ -1235,1 +1264,1 @@\n-                                node5 = new N(null, null), null\n+                                node5 = new N()\n@@ -1237,1 +1266,1 @@\n-                        ), null\n+                        )\n@@ -1269,1 +1298,1 @@\n-                                node5 = new N(null, null), null\n+                                node5 = new N()\n@@ -1271,1 +1300,1 @@\n-                        ), null\n+                        )\n@@ -1305,1 +1334,1 @@\n-                                node5 = new N(\"node5\",null, null), null\n+                                node5 = new N(\"node5\")\n@@ -1307,1 +1336,1 @@\n-                        ), null\n+                        )\n@@ -1334,0 +1363,235 @@\n+\n+        \/**\n+         * After {@link Node#requestFocus()} is called on a node that is already focused, the event dispatch\n+         * chain constructed when an event is dispatched reflects the new chain of focus delegates.\n+         *\/\n+        @Test\n+        void eventDispatchChainReflectsChangedFocusDelegatesAfterFocusRequest() {\n+            final N node1, node2, node3, node4a, node4b, node5a, node5b;\n+            final boolean[] switchDelegate = new boolean[1];\n+\n+            \/\/ node1 . . . . . . . . . focusDelegate = node3, focusOwner\n+            \/\/ └── node2\n+            \/\/     └── node3 . . . . . focusDelegate = node5a\/b\n+            \/\/         └── node4a\n+            \/\/         |   └── node5a\n+            \/\/         └── node4b\n+            \/\/             └── node5b\n+            scene.setRoot(\n+                node1 = new N(\"node1\",\n+                    node2 = new N(\"node2\",\n+                        node3 = new N(\"node3\",\n+                            new Node[] {\n+                                node4a = new N(\"node4a\",\n+                                    node5a = new N(\"node5a\")\n+                                ),\n+                                node4b = new N(\"node4b\",\n+                                    node5b = new N(\"node5b\")\n+                                )\n+                            }, node5a\n+                        ) {\n+                            @Override\n+                            protected Node getFocusDelegate(Node hoistingNode) {\n+                                return switchDelegate[0] ? node5b : node5a;\n+                            }\n+                        }\n+                    ), node3\n+                ));\n+\n+            var trace = new Trace(node1, node2, node3, node4a, node4b, node5a, node5b);\n+\n+            node1.requestFocus();\n+            SceneShim.processKeyEvent(\n+                scene, new KeyEvent(KeyEvent.KEY_PRESSED, null, null, KeyCode.A, false, false, false, false));\n+\n+            assertEquals(\n+                List.of(\n+                    \"EventFilter[source=node1, target=node1]\", \/\/ <-- target is node1 (focusOwner)\n+                    \"EventFilter[source=node2, target=node3]\", \/\/ <-- change target to node3 (delegate)\n+                    \"EventFilter[source=node3, target=node3]\",\n+                    \"EventFilter[source=node4a, target=node5a]\", \/\/ <-- change target to node5a (delegate)\n+                    \"EventFilter[source=node5a, target=node5a]\",\n+                    \"EventHandler[source=node5a, target=node5a]\",\n+                    \"EventHandler[source=node4a, target=node5a]\",\n+                    \"EventHandler[source=node3, target=node3]\", \/\/ <-- change target back to node3\n+                    \"EventHandler[source=node2, target=node3]\",\n+                    \"EventHandler[source=node1, target=node1]\" \/\/ <-- change target back to node1\n+                ),\n+                trace\n+            );\n+\n+            switchDelegate[0] = true;\n+            trace.clear();\n+\n+            node1.requestFocus();\n+            SceneShim.processKeyEvent(\n+                scene, new KeyEvent(KeyEvent.KEY_PRESSED, null, null, KeyCode.A, false, false, false, false));\n+\n+            assertEquals(\n+                List.of(\n+                    \"EventFilter[source=node1, target=node1]\", \/\/ <-- target is node1 (focusOwner)\n+                    \"EventFilter[source=node2, target=node3]\", \/\/ <-- change target to node3 (delegate)\n+                    \"EventFilter[source=node3, target=node3]\",\n+                    \"EventFilter[source=node4b, target=node5b]\", \/\/ <-- change target to node5b (delegate)\n+                    \"EventFilter[source=node5b, target=node5b]\",\n+                    \"EventHandler[source=node5b, target=node5b]\",\n+                    \"EventHandler[source=node4b, target=node5b]\",\n+                    \"EventHandler[source=node3, target=node3]\", \/\/ <-- change target back to node3\n+                    \"EventHandler[source=node2, target=node3]\",\n+                    \"EventHandler[source=node1, target=node1]\" \/\/ <-- change target back to node1\n+                ),\n+                trace\n+            );\n+        }\n+\n+        \/**\n+         * When {@link Node#requestFocus()} is called on a node that is already focused, focus delegates\n+         * and focused states are re-evaluated for the entire chain of focus delegation.\n+         *\/\n+        @Test\n+        void focusDelegatesAreReevaluatedWhenFocusIsRequestedAgain() {\n+            final N node1, node2, node3, node4a, node4b, node5a, node5b;\n+            final boolean[] switchDelegate = new boolean[1];\n+\n+            \/\/ node1 . . . . . . . . . focusDelegate = node3, focusOwner\n+            \/\/ └── node2\n+            \/\/     └── node3 . . . . . focusDelegate = node5a\/b\n+            \/\/         └── node4a\n+            \/\/         |   └── node5a\n+            \/\/         └── node4b\n+            \/\/             └── node5b\n+            scene.setRoot(\n+                node1 = new N(\n+                    node2 = new N(\n+                        node3 = new N(\n+                            new Node[] {\n+                                node4a = new N(\n+                                    node5a = new N()\n+                                ),\n+                                node4b = new N(\n+                                    node5b = new N()\n+                                )\n+                            }, node5a\n+                        ) {\n+                            @Override\n+                            protected Node getFocusDelegate(Node hoistingNode) {\n+                                return switchDelegate[0] ? node5b : node5a;\n+                            }\n+                        }\n+                    ), node3\n+                ));\n+\n+            node1.requestFocus();\n+            assertIsFocused(node1, node3, node5a);\n+            assertNotFocused(node2, node4a, node4b);\n+            assertSame(node5a, NodeShim.resolveFocusDelegate(node1));\n+\n+            switchDelegate[0] = true;\n+            node1.requestFocus();\n+            assertIsFocused(node1, node3, node5b);\n+            assertNotFocused(node2, node4a, node4b);\n+            assertSame(node5b, NodeShim.resolveFocusDelegate(node1));\n+        }\n+\n+        \/**\n+         * When a node that acquired focus by delegation is removed from the scene graph, its focus bits are\n+         * cleared (and those of its descendants). This ensures that a focus delegation chain is only valid\n+         * within a scene graph.\n+         *\/\n+        @Test\n+        void focusIsClearedOnDelegateNodeWhenRemovedFromSceneGraph() {\n+            N node1, node2, node3, node4, node5;\n+\n+            \/\/ node1 . . . . . . . . . focusDelegate = node3\n+            \/\/ └── node2\n+            \/\/     └── node3 . . . . . focusDelegate = node4\n+            \/\/         └── node4 . . . focusDelegate = node5\n+            \/\/             └── node5\n+            scene.setRoot(\n+                node1 = new N(\n+                    node2 = new N(\n+                        node3 = new N(\n+                            node4 = new N(\n+                                node5 = new N(), node5\n+                            ), node4\n+                        )\n+                    ), node3\n+                ));\n+\n+            node1.requestFocus();\n+            assertIsFocused(node3, node4, node5);\n+            assertIsFocused(scene, node1);\n+            assertNotFocused(node2);\n+\n+            node3.getChildren().clear();\n+            assertNotFocused(node4, node5);\n+        }\n+\n+        \/**\n+         * When a node that acquired focus by delegation is moved to a sibling branch of the scene graph,\n+         * the focus delegation chain is re-evaluated and focus bits are effectively retained. Note that\n+         * moving a node to a different branch in the scene graph removes the node before inserting it again.\n+         * Focus listeners will see a transient state where focus bits are cleared on the removed node.\n+         *\/\n+        @Test\n+        void focusIsRetainedWhenDelegateIsMovedToSiblingSubtree() {\n+            N node1, node2a, node2b, node3, node4, node5;\n+\n+            \/\/ node1 . . . . . . . . . focusDelegate = node4\n+            \/\/ └── node2a\n+            \/\/ |   └── node3\n+            \/\/ |       └── node4 . . . focusDelegate = node5\n+            \/\/ |           └── node5\n+            \/\/ └── node2b\n+            scene.setRoot(\n+                node1 = new N(\n+                    new Node[] {\n+                        node2a = new N(\n+                            node3 = new N(\n+                                node4 = new N(\n+                                    node5 = new N(), node5\n+                                )\n+                            )\n+                        ),\n+                        node2b = new N()\n+                    }, node4\n+                ));\n+\n+            List<Boolean> node4FocusedTrace = new ArrayList<>(),\n+                          node4FocusVisibleTrace = new ArrayList<>(),\n+                          node4FocusWithinTrace = new ArrayList<>();\n+            node4.focusedProperty().subscribe(node4FocusedTrace::addLast);\n+            node4.focusVisibleProperty().subscribe(node4FocusVisibleTrace::addLast);\n+            node4.focusWithinProperty().subscribe(node4FocusWithinTrace::addLast);\n+\n+            List<Boolean> node5FocusedTrace = new ArrayList<>(),\n+                          node5FocusVisibleTrace = new ArrayList<>(),\n+                          node5FocusWithinTrace = new ArrayList<>();\n+            node5.focusedProperty().subscribe(node5FocusedTrace::addLast);\n+            node5.focusVisibleProperty().subscribe(node5FocusVisibleTrace::addLast);\n+            node5.focusWithinProperty().subscribe(node5FocusWithinTrace::addLast);\n+\n+            node1.requestFocus();\n+\n+            assertIsFocused(node4, node5);\n+            assertIsFocused(scene, node1);\n+            assertNotFocused(node2a, node2b, node3);\n+            assertEquals(List.of(false, true), node4FocusedTrace);\n+            assertEquals(List.of(false), node4FocusVisibleTrace);\n+            assertEquals(List.of(false, true), node4FocusWithinTrace);\n+            assertEquals(List.of(false, true), node5FocusedTrace);\n+            assertEquals(List.of(false), node5FocusVisibleTrace);\n+            assertEquals(List.of(false, true), node5FocusWithinTrace);\n+\n+            node2b.getChildren().add(node3);\n+\n+            assertIsFocused(node4, node5);\n+            assertIsFocused(scene, node1);\n+            assertNotFocused(node2a, node2b, node3);\n+            assertEquals(List.of(false, true, false, true), node4FocusedTrace);\n+            assertEquals(List.of(false), node4FocusVisibleTrace);\n+            assertEquals(List.of(false, true, false, true), node4FocusWithinTrace);\n+            assertEquals(List.of(false, true, false, true), node5FocusedTrace);\n+            assertEquals(List.of(false), node5FocusVisibleTrace);\n+            assertEquals(List.of(false, true, false, true), node5FocusWithinTrace);\n+        }\n@@ -1354,1 +1618,1 @@\n-                    var method = focusedProperty().getClass().getDeclaredMethod(\"getHoistingNode\");\n+                    var method = Node.class.getDeclaredMethod(\"getHoistingNode\");\n@@ -1356,1 +1620,1 @@\n-                    return (Node)method.invoke(focusedProperty(), (Object[])null);\n+                    return (Node)method.invoke(this, (Object[])null);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/FocusTest.java","additions":275,"deletions":11,"binary":false,"changes":286,"status":"modified"}]}