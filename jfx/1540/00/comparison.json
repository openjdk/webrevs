{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.lang.ref.Reference;\n+\n@@ -151,7 +153,11 @@\n-        long fontRef = strike.getFontRef();\n-        if (fontRef == 0) return null;\n-        long pathRef = OS.CTFontCreatePathForGlyph(fontRef, (short)gc, tx);\n-        if (pathRef == 0) return null;\n-        CGRect rect = OS.CGPathGetPathBoundingBox(pathRef);\n-        OS.CGPathRelease(pathRef);\n-        return rect;\n+        try {\n+            long fontRef = strike.getFontRef();\n+            if (fontRef == 0) return null;\n+            long pathRef = OS.CTFontCreatePathForGlyph(fontRef, (short)gc, tx);\n+            if (pathRef == 0) return null;\n+            CGRect rect = OS.CGPathGetPathBoundingBox(pathRef);\n+            OS.CGPathRelease(pathRef);\n+            return rect;\n+      } finally {\n+          Reference.reachabilityFence(strike);\n+      }\n@@ -162,7 +168,11 @@\n-        long fontRef = strike.getFontRef();\n-        if (fontRef == 0) return null;\n-        long pathRef = OS.CTFontCreatePathForGlyph(fontRef, (short)gc, tx);\n-        if (pathRef == 0) return null;\n-        Path2D path = OS.CGPathApply(pathRef);\n-        OS.CGPathRelease(pathRef);\n-        return path;\n+        try {\n+            long fontRef = strike.getFontRef();\n+            if (fontRef == 0) return null;\n+            long pathRef = OS.CTFontCreatePathForGlyph(fontRef, (short)gc, tx);\n+            if (pathRef == 0) return null;\n+            Path2D path = OS.CGPathApply(pathRef);\n+            OS.CGPathRelease(pathRef);\n+            return path;\n+      } finally {\n+          Reference.reachabilityFence(strike);\n+      }\n@@ -174,4 +184,8 @@\n-      long fontRef = strike.getFontRef();\n-      int orientation = OS.kCTFontOrientationDefault;\n-      CGSize size = new CGSize();\n-      return (float)OS.CTFontGetAdvancesForGlyphs(fontRef, orientation, (short)glyphCode, size);\n+      try {\n+          long fontRef = strike.getFontRef();\n+          int orientation = OS.kCTFontOrientationDefault;\n+          CGSize size = new CGSize();\n+          return (float)OS.CTFontGetAdvancesForGlyphs(fontRef, orientation, (short)glyphCode, size);\n+      } finally {\n+          Reference.reachabilityFence(strike);\n+      }\n@@ -190,25 +204,22 @@\n-        long fontRef = strike.getFontRef();\n-        if (fontRef == 0) return null;\n-        int[] bb = new int[4];\n-\n-        \/* For some reason CTFontGetBoundingRectsForGlyphs has poor performance.\n-         * The fix is to use the 'loca' and the 'glyf' tables to determine\n-         * the glyph bounding box (same as T2K). This implementation\n-         * uses native code to read these tables since they can be large.\n-         * However for color (emoji) glyphs this returns the wrong bounds,\n-         * so use CTFontGetBoundingRectsForGlyphs anyway.\n-         * In case it fails, or the font doesn't have a glyph table\n-         * (CFF fonts), then the bounds of the glyph outline is used instead.\n-         *\/\n-        if (!isCFF()) {\n-            if (isColorGlyph(gc)) {\n-                CGRect rect = OS.CTFontGetBoundingRectForGlyphs(fontRef, (short)gc);\n-                float scale = getUnitsPerEm() \/ size;\n-                bb[0] = (int)(Math.round(rect.origin.x * scale));\n-                bb[1] = (int)(Math.round(rect.origin.y * scale));\n-                bb[2] = (int)(Math.round((rect.origin.x + rect.size.width) * scale));\n-                bb[3] = (int)(Math.round((rect.origin.y + rect.size.height) * scale));\n-                return bb;\n-            } else {\n-                short format = getIndexToLocFormat();\n-                if (OS.CTFontGetBoundingRectForGlyphUsingTables(fontRef, (short)gc, format, bb)) {\n+        try {\n+            long fontRef = strike.getFontRef();\n+            if (fontRef == 0) return null;\n+            int[] bb = new int[4];\n+\n+            \/* For some reason CTFontGetBoundingRectsForGlyphs has poor performance.\n+             * The fix is to use the 'loca' and the 'glyf' tables to determine\n+             * the glyph bounding box (same as T2K). This implementation\n+             * uses native code to read these tables since they can be large.\n+             * However for color (emoji) glyphs this returns the wrong bounds,\n+             * so use CTFontGetBoundingRectsForGlyphs anyway.\n+             * In case it fails, or the font doesn't have a glyph table\n+             * (CFF fonts), then the bounds of the glyph outline is used instead.\n+             *\/\n+            if (!isCFF()) {\n+                if (isColorGlyph(gc)) {\n+                    CGRect rect = OS.CTFontGetBoundingRectForGlyphs(fontRef, (short)gc);\n+                    float scale = getUnitsPerEm() \/ size;\n+                    bb[0] = (int)(Math.round(rect.origin.x * scale));\n+                    bb[1] = (int)(Math.round(rect.origin.y * scale));\n+                    bb[2] = (int)(Math.round((rect.origin.x + rect.size.width) * scale));\n+                    bb[3] = (int)(Math.round((rect.origin.y + rect.size.height) * scale));\n@@ -216,0 +227,5 @@\n+                } else {\n+                    short format = getIndexToLocFormat();\n+                    if (OS.CTFontGetBoundingRectForGlyphUsingTables(fontRef, (short)gc, format, bb)) {\n+                        return bb;\n+                    }\n@@ -218,0 +234,13 @@\n+            \/* Note: not using tx here as the bounds need to be y up *\/\n+            long pathRef = OS.CTFontCreatePathForGlyph(fontRef, (short)gc, null);\n+            if (pathRef == 0) return null;\n+            CGRect rect = OS.CGPathGetPathBoundingBox(pathRef);\n+            OS.CGPathRelease(pathRef);\n+            float scale = getUnitsPerEm() \/ size;\n+            bb[0] = (int)(Math.round(rect.origin.x * scale));\n+            bb[1] = (int)(Math.round(rect.origin.y * scale));\n+            bb[2] = (int)(Math.round((rect.origin.x + rect.size.width) * scale));\n+            bb[3] = (int)(Math.round((rect.origin.y + rect.size.height) * scale));\n+            return bb;\n+        } finally {\n+            Reference.reachabilityFence(strike);\n@@ -219,11 +248,0 @@\n-        \/* Note: not using tx here as the bounds need to be y up *\/\n-        long pathRef = OS.CTFontCreatePathForGlyph(fontRef, (short)gc, null);\n-        if (pathRef == 0) return null;\n-        CGRect rect = OS.CGPathGetPathBoundingBox(pathRef);\n-        OS.CGPathRelease(pathRef);\n-        float scale = getUnitsPerEm() \/ size;\n-        bb[0] = (int)(Math.round(rect.origin.x * scale));\n-        bb[1] = (int)(Math.round(rect.origin.y * scale));\n-        bb[2] = (int)(Math.round((rect.origin.x + rect.size.width) * scale));\n-        bb[3] = (int)(Math.round((rect.origin.y + rect.size.height) * scale));\n-        return bb;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/coretext\/CTFontFile.java","additions":73,"deletions":55,"binary":false,"changes":128,"status":"modified"}]}