{"files":[{"patch":"@@ -247,3 +247,3 @@\n-     * <li>{@code x, ymin, ymax} - corresponds to a single line from (x, ymin) tp (x, ymax)\n-     * <li>{@code x, ymin, y2, x2, ymax} - corresponds to a split caret drawn as two lines, the first line\n-     * drawn from (x,ymin) to (x, y2), the second line drawn from (x2, y2) to (x2, ymax).\n+     * <li>{@code [x, y, h]} - corresponds to a single line from (x, y) to (x, y + h)\n+     * <li>{@code [x, y, x2, h]} - corresponds to a split caret drawn as two lines, the first line\n+     * drawn from (x, y) to (x, y + h\/2), the second line drawn from (x2, y + h\/2) to (x2, y + h).\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/text\/TextLayout.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import javafx.geometry.Rectangle2D;\n@@ -33,1 +34,0 @@\n-    private final double[][] lines;\n@@ -35,2 +35,9 @@\n-    public PrismCaretInfo(double[][] lines) {\n-        this.lines = lines;\n+    private final Rectangle2D[] parts;\n+\n+    public PrismCaretInfo(Rectangle2D[] parts) {\n+        this.parts = parts;\n+    }\n+\n+    @Override\n+    public int getPartCount() {\n+        return parts.length;\n@@ -40,2 +47,2 @@\n-    public int getLineCount() {\n-        return lines.length;\n+    public Rectangle2D getPartAt(int index) {\n+        return parts[index];\n@@ -45,2 +52,11 @@\n-    public double[] getLineAt(int index) {\n-        return lines[index];\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"PrismCaretInfo{parts=[\");\n+        for (int i = 0; i < getPartCount(); i++) {\n+            if (i > 0) {\n+                sb.append(\",\");\n+            }\n+            sb.append(getPartAt(i));\n+        }\n+        sb.append(\"]}\");\n+        return sb.toString();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/PrismCaretInfo.java","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import javafx.geometry.Insets;\n@@ -34,0 +35,1 @@\n+import com.sun.javafx.geom.BaseBounds;\n@@ -40,1 +42,6 @@\n-public final class PrismLayoutInfo extends LayoutInfo {\n+public abstract class PrismLayoutInfo extends LayoutInfo {\n+\n+    protected abstract double lineSpacing();\n+\n+    protected abstract Insets insets();\n+\n@@ -48,2 +55,7 @@\n-    public Rectangle2D getBounds() {\n-        return TextUtils.toRectangle2D(layout.getBounds());\n+    public Rectangle2D getBounds(boolean includeLineSpacing) {\n+        BaseBounds b = layout.getBounds();\n+        Insets m = insets();\n+        double dx = m.getLeft(); \/\/ TODO rtl?\n+        double dy = m.getTop();\n+        double sp = includeLineSpacing ? lineSpacing() : 0.0;\n+        return TextUtils.toRectangle2D(b, dx, dy, sp);\n@@ -58,1 +70,1 @@\n-    public List<TextLineInfo> getTextLines() {\n+    public List<TextLineInfo> getTextLines(boolean includeLineSpacing) {\n@@ -60,0 +72,4 @@\n+        Insets m = insets();\n+        double dx = m.getLeft(); \/\/ TODO rtl?\n+        double dy = m.getTop();\n+        double sp = includeLineSpacing ? lineSpacing() : 0.0;\n@@ -61,0 +77,1 @@\n+\n@@ -63,1 +80,1 @@\n-            rv.add(TextUtils.toLineInfo(lines[i]));\n+            rv.add(TextUtils.toLineInfo(lines[i], dx, dy, sp));\n@@ -69,2 +86,6 @@\n-    public TextLineInfo getTextLine(int index) {\n-        return TextUtils.toLineInfo(layout.getLines()[index]);\n+    public TextLineInfo getTextLine(int index, boolean includeLineSpacing) {\n+        Insets m = insets();\n+        double dx = m.getLeft(); \/\/ TODO rtl?\n+        double dy = m.getTop();\n+        double sp = includeLineSpacing ? lineSpacing() : 0.0;\n+        return TextUtils.toLineInfo(layout.getLines()[index], dx, dy, sp);\n@@ -74,2 +95,3 @@\n-    public List<Rectangle2D> selectionShape(int start, int end) {\n-        return getGeometry(start, end, TextLayout.TYPE_TEXT);\n+    public List<Rectangle2D> selectionShape(int start, int end, boolean includeLineSpacing) {\n+        double sp = includeLineSpacing ? lineSpacing() : 0.0;\n+        return getGeometry(start, end, TextLayout.TYPE_TEXT, sp);\n@@ -80,1 +102,1 @@\n-        return getGeometry(start, end, TextLayout.TYPE_STRIKETHROUGH);\n+        return getGeometry(start, end, TextLayout.TYPE_STRIKETHROUGH, 0.0);\n@@ -85,1 +107,1 @@\n-        return getGeometry(start, end, TextLayout.TYPE_UNDERLINE);\n+        return getGeometry(start, end, TextLayout.TYPE_UNDERLINE, 0.0);\n@@ -88,1 +110,5 @@\n-    private List<Rectangle2D> getGeometry(int start, int end, int type) {\n+    private List<Rectangle2D> getGeometry(int start, int end, int type, double lineSpacing) {\n+        Insets m = insets();\n+        double dx = m.getLeft(); \/\/ TODO RTL?\n+        double dy = m.getTop();\n+\n@@ -90,1 +116,0 @@\n-        \/\/ TODO padding\/border JDK-8341438?\n@@ -93,1 +118,1 @@\n-                rv.add(new Rectangle2D(left, top, right - left, bottom - top));\n+                rv.add(new Rectangle2D(left + dx, top + dy, right - left, bottom - top + lineSpacing));\n@@ -95,1 +120,1 @@\n-                rv.add(new Rectangle2D(right, top, left - right, bottom - top));\n+                rv.add(new Rectangle2D(right + dx, top + dy, left - right, bottom - top + lineSpacing));\n@@ -107,0 +132,3 @@\n+        Insets m = insets();\n+        double dx = m.getLeft(); \/\/ TODO RTL?\n+        double dy = m.getTop();\n@@ -109,2 +137,1 @@\n-        \/\/ TODO padding\/border JDK-8341438?\n-        double[][] lines;\n+        Rectangle2D[] parts;\n@@ -112,5 +139,6 @@\n-            \/\/ {x, ymin, ymax} - corresponds to a single line from (x, ymin) tp (x, ymax)\n-            lines = new double[][] {\n-                new double[] {\n-                    c[0], c[1], c[2]\n-                }\n+            \/\/ [x, y, h] - corresponds to a single line from (x, y) to (x, y + h)\n+            double x = c[0] + dx;\n+            double y = c[1] + dy;\n+            double h = c[2];\n+            parts = new Rectangle2D[] {\n+                new Rectangle2D(x, y, 0.0, h)\n@@ -119,10 +147,9 @@\n-            \/\/ {x, y, y2, x2, ymax} - corresponds to a split caret drawn as two lines, the first line\n-            \/\/ drawn from (x,y) to (x, y2), the second line drawn from (x2, y2) to (x2, ymax).\n-            double y2 = c[2];\n-            lines = new double[][] {\n-                new double[] {\n-                    c[0], c[1], y2\n-                },\n-                new double[] {\n-                    c[3], y2, c[4]\n-                }\n+            \/\/ [x, y, x2, h] - corresponds to a split caret drawn as two lines, the first line\n+            \/\/ drawn from (x, y) to (x, y + h\/2), the second line drawn from (x2, y + h\/2) to (x2, y + h).\n+            double x = c[0] + dx;\n+            double y = c[1] + dy;\n+            double x2 = c[2] + dx;\n+            double h2 = c[3] \/ 2.0;\n+            parts = new Rectangle2D[] {\n+                new Rectangle2D(x, y, 0.0, h2),\n+                new Rectangle2D(x2, y + h2, 0.0, h2)\n@@ -131,1 +158,1 @@\n-        return new PrismCaretInfo(lines);\n+        return new PrismCaretInfo(parts);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/PrismLayoutInfo.java","additions":60,"deletions":33,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -400,0 +400,1 @@\n+                        \/\/ split caret\n@@ -403,1 +404,0 @@\n-                            lineY + lineHeight \/ 2,\n@@ -405,1 +405,1 @@\n-                            lineY + lineHeight\n+                            lineHeight\n@@ -411,0 +411,1 @@\n+        \/\/ regular caret\n@@ -414,1 +415,1 @@\n-            lineY + lineHeight\n+            lineHeight\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/PrismTextLayout.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import com.sun.javafx.geom.Point2D;\n+import com.sun.javafx.scene.text.GlyphList;\n@@ -74,1 +76,1 @@\n-    public static TextLineInfo toLineInfo(TextLine line) {\n+    public static TextLineInfo toLineInfo(TextLine line, double dx, double dy, double lineSpacing) {\n@@ -77,1 +79,10 @@\n-        Rectangle2D bounds = toRectangle2D(line.getBounds());\n+\n+        \/\/ all the runs on the same line have the same y coordinate\n+        for (GlyphList g : line.getRuns()) {\n+            Point2D p = g.getLocation();\n+            dx += p.x;\n+            dy += p.y;\n+            break;\n+        }\n+\n+        Rectangle2D bounds = toRectangle2D(line.getBounds(), dx, dy, lineSpacing);\n@@ -81,2 +92,4 @@\n-    public static Rectangle2D toRectangle2D(BaseBounds b) {\n-        return new Rectangle2D(b.getMinX(), b.getMinY(), b.getWidth(), b.getHeight());\n+    public static Rectangle2D toRectangle2D(BaseBounds b, double dx, double dy, double lineSpacing) {\n+        \/\/ you wouldn't believe it, but width can be negative in BaseBounds\n+        double w = Math.abs(b.getWidth());\n+        return new Rectangle2D(b.getMinX() + dx, dy, w, b.getHeight() + lineSpacing);\n@@ -89,1 +102,1 @@\n-            \/\/ [x, ymin, ymax] - corresponds to a single line from (x, ymin) tp (x, ymax)\n+            \/\/ [x, y, h] - corresponds to a single line from (x, y) to (x, y + h)\n@@ -91,2 +104,2 @@\n-            double ymin = c[1] + dy;\n-            double ymax = c[2] + dy;\n+            double y = c[1] + dy;\n+            double h = c[2];\n@@ -95,2 +108,2 @@\n-                new MoveTo(x, ymin),\n-                new LineTo(x, ymax)\n+                new MoveTo(x, y),\n+                new LineTo(x, y + h)\n@@ -99,7 +112,7 @@\n-            \/\/ [x, ymin, y2, x2, ymax] - corresponds to a split caret drawn as two lines, the first line\n-            \/\/ drawn from (x,ymin) to (x, y2), the second line drawn from (x2, y2) to (x2, ymax).\n-            double x = c[0];\n-            double ymin = c[1];\n-            double y2 = c[2];\n-            double x2 = c[3];\n-            double ymax = c[4];\n+            \/\/ [x, y, x2, h] - corresponds to a split caret drawn as two lines, the first line\n+            \/\/ drawn from (x, y) to (x, y + h\/2), the second line drawn from (x2, y + h\/2) to (x2, y + h).\n+            double x = c[0] + dx;\n+            double y = c[1] + dy;\n+            double x2 = c[2] + dx;\n+            double h = c[3];\n+            double y2 = y + h\/2.0;\n@@ -108,1 +121,1 @@\n-                new MoveTo(x, ymin),\n+                new MoveTo(x, y),\n@@ -111,1 +124,1 @@\n-                new LineTo(x2, ymax)\n+                new LineTo(x2, y + h)\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/TextUtils.java","additions":31,"deletions":18,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import javafx.geometry.Rectangle2D;\n@@ -46,1 +47,1 @@\n-    public abstract int getLineCount();\n+    public abstract int getPartCount();\n@@ -50,3 +51,0 @@\n-     * <p>\n-     * The geometry is encoded in an array of [x, ymin, ymax] values which\n-     * represent a line drawn from (x, ymin) to (x, ymax).\n@@ -55,1 +53,1 @@\n-     * @return the array of [x, ymin, ymax] values\n+     * @return the bounds of the caret part\n@@ -57,2 +55,2 @@\n-    \/\/ TODO or use Rectangle2D instead?\n-    public abstract double[] getLineAt(int index);\n+    public abstract Rectangle2D getPartAt(int index);\n+    \/\/ TODO variant: CaretLineInfo, with bounds and (character index + bias)\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/CaretInfo.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-public sealed abstract class LayoutInfo permits com.sun.javafx.text.PrismLayoutInfo {\n+public abstract class LayoutInfo {\n@@ -49,7 +49,3 @@\n-     * Returns the logical bounds of the layout:\n-     * <ul>\n-     * <li>{@code minX} is always zero\n-     * <li>{@code minY} is the ascent of the first line (negative)\n-     * <li>{@code width} the width of the widest line\n-     * <li>{@code height} the sum of all lines height\n-     * <\/ul>\n+     * Returns the logical bounds of the layout.\n+     * Depending on {@code includeLineSpacing}, the return value may include the line spacing after the\n+     * last line of text.\n@@ -57,0 +53,1 @@\n+     * @param includeLineSpacing determines whether the line spacing after last text line should be included\n@@ -59,3 +56,1 @@\n-    \/\/ TODO maybe add a boolean flag to control whether the last line's lineSpacing is included or not,\n-    \/\/ see JDK-8317120 and JDK-8317122\n-    public abstract Rectangle2D getBounds();\n+    public abstract Rectangle2D getBounds(boolean includeLineSpacing);\n@@ -72,0 +67,1 @@\n+     * @param includeLineSpacing determines whether the result includes the line spacing\n@@ -74,1 +70,1 @@\n-    public abstract List<TextLineInfo> getTextLines();\n+    public abstract List<TextLineInfo> getTextLines(boolean includeLineSpacing);\n@@ -81,0 +77,1 @@\n+     * @param includeLineSpacing determines whether the result includes the line spacing\n@@ -83,1 +80,1 @@\n-    public abstract TextLineInfo getTextLine(int index);\n+    public abstract TextLineInfo getTextLine(int index, boolean includeLineSpacing);\n@@ -91,0 +88,1 @@\n+     * @param includeLineSpacing determines whether the result includes the line spacing\n@@ -93,2 +91,1 @@\n-    \/\/ TODO this method should include last line spacing JDK-8317120\n-    public abstract List<Rectangle2D> selectionShape(int start, int end);\n+    public abstract List<Rectangle2D> selectionShape(int start, int end, boolean includeLineSpacing);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/LayoutInfo.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+import javafx.geometry.Insets;\n@@ -859,1 +860,2 @@\n-     * The shape of the selection in local coordinates.\n+     * The shape of the selection in coordinates\n+     * relative to the font base line.\n@@ -1076,1 +1078,0 @@\n-            \/\/ TODO padding JDK-8341438?\n@@ -1087,1 +1088,2 @@\n-     * Returns the shape for the range of the text in local coordinates.\n+     * Returns the shape for the range of the text in coordinates\n+     * relative to the font base line.\n@@ -1099,1 +1101,2 @@\n-     * Returns the shape for the underline in local coordinates.\n+     * Returns the shape for the underline in coordinates\n+     * relative to the font base line.\n@@ -1111,1 +1114,2 @@\n-     * Returns the shape for the strike-through in local coordinates.\n+     * Returns the shape for the strike-through in coordinates\n+     * relative to the font base line.\n@@ -2101,1 +2105,11 @@\n-        return new PrismLayoutInfo(getTextLayout());\n+        return new PrismLayoutInfo(getTextLayout()) {\n+            @Override\n+            public double lineSpacing() {\n+                return getLineSpacing();\n+            }\n+\n+            @Override\n+            public Insets insets() {\n+                return Insets.EMPTY;\n+            }\n+        };\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/Text.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -723,1 +723,11 @@\n-        return new PrismLayoutInfo(getTextLayout());\n+        return new PrismLayoutInfo(getTextLayout()) {\n+            @Override\n+            public double lineSpacing() {\n+                return getLineSpacing();\n+            }\n+\n+            @Override\n+            public Insets insets() {\n+                return getInsets();\n+            }\n+        };\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/TextFlow.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,367 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.robot.javafx.scene;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.function.Consumer;\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.robot.Robot;\n+import javafx.scene.text.CaretInfo;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.LayoutInfo;\n+import javafx.scene.text.Text;\n+import javafx.scene.text.TextFlow;\n+import javafx.scene.text.TextLineInfo;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import test.util.Util;\n+\n+\/*\n+ * Tests new LayoutInfo API in the TextFlow.\n+ *\/\n+public class TextFlow_TextLayout_Test {\n+    private static final int WIDTH = 500;\n+    private static final int HEIGHT = 500;\n+    private static final int FONT_SIZE = 24;\n+    private static final double LINE_SPACING = 33;\n+    private static final double EPS = 0.1;\n+    private static final CountDownLatch startupLatch = new CountDownLatch(1);\n+    private static Robot robot;\n+    private static TextFlow textFlow;\n+    private static volatile Stage stage;\n+    private static volatile Scene scene;\n+\n+    \/\/ testing caret info\n+    @Test\n+    public void testCaretInfo() {\n+        setText(\"__________\\n\", \"______\\n\", \"_\\n\");\n+        waitForIdle();\n+        LayoutInfo la = textFlow.getLayoutInfo();\n+\n+        CaretInfo ci = la.caretInfo(0, true);\n+\n+        \/\/ caret is one line\n+        assertEquals(ci.getPartCount(), 1);\n+\n+        \/\/ basic size checks\n+        Rectangle2D r = ci.getPartAt(0);\n+        assertTrue(r.getMinX() >= 0);\n+        assertTrue(r.getMinY() >= 0);\n+        assertTrue(r.getWidth() < 0.1);\n+        assertTrue(r.getHeight() >= FONT_SIZE);\n+\n+        \/\/ caret at the end\n+        int len = textLength();\n+        ci = la.caretInfo(len - 1, false);\n+        assertEquals(ci.getPartCount(), 1);\n+        Rectangle2D r2 = ci.getPartAt(0);\n+\n+        \/\/ basic checks\n+        assertTrue(r2.getMinY() > r.getMinY());\n+        assertTrue(r2.getMinX() > r.getMinX());\n+    }\n+\n+    \/\/ testing layout bounds\n+    @Test\n+    public void testBounds() {\n+        setText(\"__\\n\", \"____\\n\", \"______\");\n+        apply((f) -> {\n+            f.setLineSpacing(LINE_SPACING);\n+        });\n+        waitForIdle();\n+        LayoutInfo la = textFlow.getLayoutInfo();\n+\n+        Rectangle2D r0 = la.getBounds(false);\n+        Rectangle2D r1 = la.getBounds(true);\n+\n+        \/\/ non-empty\n+        assertTrue((r0.getWidth() > 0) && (r0.getHeight() > 0));\n+        assertTrue((r1.getWidth() > 0) && (r1.getHeight() > 0));\n+\n+        \/\/ same width\n+        assertEquals(r0.getWidth(), r1.getWidth(), EPS);\n+\n+        \/\/ one is taller by one line spacing\n+        assertEquals(r0.getHeight() + LINE_SPACING, r1.getHeight(), EPS);\n+    }\n+\n+    \/\/ testing text lines\n+    @Test\n+    public void testTextLines() {\n+        setText(\"__\\n\", \"____\\n\", \"______\");\n+        waitForIdle();\n+        LayoutInfo la = textFlow.getLayoutInfo();\n+\n+        \/\/ spacing = 0\n+\n+        assertEquals(la.getTextLineCount(), 3);\n+        List<TextLineInfo> ls = la.getTextLines(false);\n+        assertNotNull(ls);\n+        TextLineInfo l0 = la.getTextLine(0, false);\n+        TextLineInfo l1 = la.getTextLine(1, false);\n+        TextLineInfo l2 = la.getTextLine(2, false);\n+        assertEquals(l0, ls.get(0));\n+        assertEquals(l1, ls.get(1));\n+        assertEquals(l2, ls.get(2));\n+\n+        \/\/ position check\n+        assertEquals(0, l0.start());\n+        assertEquals(3, l0.end());\n+        assertEquals(3, l1.start());\n+        assertEquals(8, l1.end());\n+        assertEquals(8, l2.start());\n+        assertEquals(14, l2.end());\n+\n+        \/\/ geometry check\n+        assertEquals(0, l0.bounds().getMinX(), EPS);\n+        assertEquals(0, l0.bounds().getMinY(), EPS);\n+        assertTrue(l0.bounds().getWidth() < l1.bounds().getWidth());\n+        assertTrue(l1.bounds().getWidth() < l2.bounds().getWidth());\n+        assertTrue(l0.bounds().getMinY() < l1.bounds().getMinY());\n+        assertTrue(l1.bounds().getMinY() < l2.bounds().getMinY());\n+\n+        \/\/ line spacing\n+        apply((f) -> {\n+            f.setLineSpacing(LINE_SPACING);\n+        });\n+        waitForIdle();\n+\n+        List<TextLineInfo> LS = la.getTextLines(true);\n+        assertNotNull(LS);\n+        TextLineInfo L0 = la.getTextLine(0, true);\n+        TextLineInfo L1 = la.getTextLine(1, true);\n+        TextLineInfo L2 = la.getTextLine(2, true);\n+        assertEquals(L0, LS.get(0));\n+        assertEquals(L1, LS.get(1));\n+        assertEquals(L2, LS.get(2));\n+\n+        \/\/ widths should be same\n+        assertEquals(l0.bounds().getWidth(), L0.bounds().getWidth());\n+        assertEquals(l1.bounds().getWidth(), L1.bounds().getWidth());\n+        assertEquals(l2.bounds().getWidth(), L2.bounds().getWidth());\n+\n+        \/\/ heights should differ\n+        assertEquals(l0.bounds().getHeight() + LINE_SPACING, L0.bounds().getHeight(), EPS);\n+        assertEquals(l1.bounds().getHeight() + LINE_SPACING, L1.bounds().getHeight(), EPS);\n+        assertEquals(l2.bounds().getHeight() + LINE_SPACING, L2.bounds().getHeight(), EPS);\n+    }\n+\n+    \/\/ testing selection shape\n+    @Test\n+    public void testSelection() {\n+        setText(\"__\\n\", \"____\\n\", \"______\");\n+        waitForIdle();\n+        LayoutInfo la = textFlow.getLayoutInfo();\n+\n+        \/\/ spacing = 0\n+\n+        int len = textLength();\n+        List<Rectangle2D> ss = la.selectionShape(0, len, false);\n+        assertEquals(ss.size(), 3);\n+        Rectangle2D s0 = ss.get(0);\n+        Rectangle2D s1 = ss.get(1);\n+        Rectangle2D s2 = ss.get(2);\n+\n+        \/\/ geometry check\n+        assertEquals(0, s0.getMinX(), EPS);\n+        assertEquals(0, s0.getMinY(), EPS);\n+\n+        assertTrue(s0.getWidth() < s1.getWidth());\n+        assertTrue(s1.getWidth() < s2.getWidth());\n+\n+        assertTrue(s0.getMinY() < s1.getMinY());\n+        assertTrue(s1.getMinY() < s2.getMinY());\n+\n+        assertTrue(s0.getHeight() >= FONT_SIZE);\n+        assertEquals(s0.getHeight(), s1.getHeight(), EPS);\n+        assertEquals(s1.getHeight(), s2.getHeight(), EPS);\n+\n+        \/\/ line spacing\n+        apply((f) -> {\n+            f.setLineSpacing(LINE_SPACING);\n+        });\n+        waitForIdle();\n+\n+        List<Rectangle2D> SS = la.selectionShape(0, len, true);\n+        assertEquals(ss.size(), 3);\n+        Rectangle2D S0 = SS.get(0);\n+        Rectangle2D S1 = SS.get(1);\n+        Rectangle2D S2 = SS.get(2);\n+\n+        \/\/ geometry check\n+        assertEquals(0, S0.getMinX(), EPS);\n+        assertEquals(0, S0.getMinY(), EPS);\n+\n+        assertTrue(S0.getWidth() < S1.getWidth());\n+        assertTrue(S1.getWidth() < S2.getWidth());\n+\n+        assertTrue(S0.getMinY() < S1.getMinY());\n+        assertTrue(S1.getMinY() < S2.getMinY());\n+\n+        assertTrue(S0.getHeight() >= FONT_SIZE);\n+        assertEquals(S0.getHeight(), S1.getHeight(), EPS);\n+        assertEquals(S1.getHeight(), S2.getHeight(), EPS);\n+\n+        \/\/ includes line space\n+        assertEquals(s0.getHeight() + LINE_SPACING, S0.getHeight(), EPS);\n+    }\n+\n+    \/\/ testing strike-through shape\n+    @Test\n+    public void testStrikeThrough() {\n+        setText(\"__\\n\", \"____\\n\", \"______\");\n+        waitForIdle();\n+        LayoutInfo la = textFlow.getLayoutInfo();\n+\n+        int len = textLength();\n+        List<Rectangle2D> ss = la.strikeThroughShape(0, len);\n+        assertEquals(ss.size(), 3);\n+        Rectangle2D s0 = ss.get(0);\n+        Rectangle2D s1 = ss.get(1);\n+        Rectangle2D s2 = ss.get(2);\n+\n+        \/\/ geometry check\n+        assertEquals(0, s0.getMinX(), EPS);\n+\n+        assertTrue(s0.getWidth() < s1.getWidth());\n+        assertTrue(s1.getWidth() < s2.getWidth());\n+\n+        assertTrue(s0.getMinY() < s1.getMinY());\n+        assertTrue(s1.getMinY() < s2.getMinY());\n+\n+        assertTrue(s0.getHeight() > 0);\n+        assertEquals(s0.getHeight(), s1.getHeight(), EPS);\n+        assertEquals(s1.getHeight(), s2.getHeight(), EPS);\n+    }\n+\n+    \/\/ testing underline shape\n+    @Test\n+    public void testUnderline() {\n+        setText(\"__\\n\", \"____\\n\", \"______\");\n+        waitForIdle();\n+        LayoutInfo la = textFlow.getLayoutInfo();\n+\n+        int len = textLength();\n+        List<Rectangle2D> ss = la.underlineShape(0, len);\n+        assertEquals(ss.size(), 3);\n+        Rectangle2D s0 = ss.get(0);\n+        Rectangle2D s1 = ss.get(1);\n+        Rectangle2D s2 = ss.get(2);\n+\n+        \/\/ geometry check\n+        assertEquals(0, s0.getMinX(), EPS);\n+\n+        assertTrue(s0.getWidth() < s1.getWidth());\n+        assertTrue(s1.getWidth() < s2.getWidth());\n+\n+        assertTrue(s0.getMinY() < s1.getMinY());\n+        assertTrue(s1.getMinY() < s2.getMinY());\n+\n+        assertTrue(s0.getHeight() > 0);\n+        assertEquals(s0.getHeight(), s1.getHeight(), EPS);\n+        assertEquals(s1.getHeight(), s2.getHeight(), EPS);\n+    }\n+\n+    private void setText(String... segments) {\n+        Util.runAndWait(() -> {\n+            textFlow.getChildren().clear();\n+            for (String s : segments) {\n+                Text t = new Text(s);\n+                t.setFont(new Font(FONT_SIZE));\n+                textFlow.getChildren().add(t);\n+            }\n+        });\n+    }\n+\n+    private void waitForIdle() {\n+        Util.waitForIdle(scene);\n+    }\n+\n+    public static int textLength() {\n+        int len = 0;\n+        for (Node n : textFlow.getChildrenUnmodifiable()) {\n+            if (n instanceof Text t) {\n+                len += t.getText().length();\n+            } else {\n+                \/\/ treat non-Text nodes as having 1 character\n+                len++;\n+            }\n+        }\n+        return len;\n+    }\n+\n+    private void apply(Consumer<TextFlow> c) {\n+        Util.runAndWait(() -> {\n+            c.accept(textFlow);\n+        });\n+    }\n+\n+    @BeforeEach\n+    public void beforeEach() {\n+        apply((t) -> {\n+            t.setLineSpacing(0);\n+        });\n+    }\n+\n+    @BeforeAll\n+    public static void beforeAll() {\n+        Util.launch(startupLatch, TestApp.class);\n+    }\n+\n+    @AfterAll\n+    public static void exit() {\n+        Util.shutdown();\n+    }\n+\n+    public static class TestApp extends Application {\n+        @Override\n+        public void start(Stage st) {\n+            robot = new Robot();\n+            stage = st;\n+\n+            textFlow = new TextFlow();\n+            scene = new Scene(textFlow, WIDTH, HEIGHT);\n+            stage.setScene(scene);\n+            stage.initStyle(StageStyle.UNDECORATED);\n+            stage.setOnShown(event -> Platform.runLater(startupLatch::countDown));\n+            stage.setAlwaysOnTop(true);\n+            stage.show();\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/TextFlow_TextLayout_Test.java","additions":367,"deletions":0,"binary":false,"changes":367,"status":"added"},{"patch":"@@ -0,0 +1,349 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.robot.javafx.scene;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.function.Consumer;\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.Group;\n+import javafx.scene.Scene;\n+import javafx.scene.robot.Robot;\n+import javafx.scene.text.CaretInfo;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.LayoutInfo;\n+import javafx.scene.text.Text;\n+import javafx.scene.text.TextFlow;\n+import javafx.scene.text.TextLineInfo;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import test.util.Util;\n+\n+\/*\n+ * Tests new LayoutInfo API in the Text.\n+ *\/\n+public class Text_TextLayout_Test {\n+    private static final int WIDTH = 500;\n+    private static final int HEIGHT = 500;\n+    private static final int FONT_SIZE = 24;\n+    private static final double LINE_SPACING = 33;\n+    private static final double EPS = 0.1;\n+    private static final CountDownLatch startupLatch = new CountDownLatch(1);\n+    private static Robot robot;\n+    private static Text text;\n+    private static volatile Stage stage;\n+    private static volatile Scene scene;\n+    private static volatile Group root;\n+\n+    \/\/ testing caret info\n+    @Test\n+    public void testCaretInfo() {\n+        setText(\"__________\\n______\\n_\\n\");\n+        waitForIdle();\n+        LayoutInfo la = text.getLayoutInfo();\n+\n+        CaretInfo ci = la.caretInfo(0, true);\n+\n+        \/\/ caret is one line\n+        assertEquals(ci.getPartCount(), 1);\n+\n+        \/\/ basic size checks\n+        Rectangle2D r = ci.getPartAt(0);\n+        assertTrue(r.getMinX() >= 0);\n+        assertTrue(r.getMinY() >= 0);\n+        assertTrue(r.getWidth() < 0.1);\n+        assertTrue(r.getHeight() >= FONT_SIZE);\n+\n+        \/\/ caret at the end\n+        int len = textLength();\n+        ci = la.caretInfo(len - 1, false);\n+        assertEquals(ci.getPartCount(), 1);\n+        Rectangle2D r2 = ci.getPartAt(0);\n+\n+        \/\/ basic checks\n+        assertTrue(r2.getMinY() > r.getMinY());\n+        assertTrue(r2.getMinX() > r.getMinX());\n+    }\n+\n+    \/\/ testing layout bounds\n+    @Test\n+    public void testBounds() {\n+        setText(\"__\\n____\\n______\");\n+        apply((f) -> {\n+            f.setLineSpacing(LINE_SPACING);\n+        });\n+        waitForIdle();\n+        LayoutInfo la = text.getLayoutInfo();\n+\n+        Rectangle2D r0 = la.getBounds(false);\n+        Rectangle2D r1 = la.getBounds(true);\n+\n+        \/\/ non-empty\n+        assertTrue((r0.getWidth() > 0) && (r0.getHeight() > 0));\n+        assertTrue((r1.getWidth() > 0) && (r1.getHeight() > 0));\n+\n+        \/\/ same width\n+        assertEquals(r0.getWidth(), r1.getWidth(), EPS);\n+\n+        \/\/ one is taller by one line spacing\n+        assertEquals(r0.getHeight() + LINE_SPACING, r1.getHeight(), EPS);\n+    }\n+\n+    \/\/ testing text lines\n+    @Test\n+    public void testTextLines() {\n+        setText(\"__\\n____\\n______\");\n+        waitForIdle();\n+        LayoutInfo la = text.getLayoutInfo();\n+\n+        \/\/ spacing = 0\n+\n+        assertEquals(la.getTextLineCount(), 3);\n+        List<TextLineInfo> ls = la.getTextLines(false);\n+        assertNotNull(ls);\n+        TextLineInfo l0 = la.getTextLine(0, false);\n+        TextLineInfo l1 = la.getTextLine(1, false);\n+        TextLineInfo l2 = la.getTextLine(2, false);\n+        assertEquals(l0, ls.get(0));\n+        assertEquals(l1, ls.get(1));\n+        assertEquals(l2, ls.get(2));\n+\n+        \/\/ position check\n+        assertEquals(0, l0.start());\n+        assertEquals(3, l0.end());\n+        assertEquals(3, l1.start());\n+        assertEquals(8, l1.end());\n+        assertEquals(8, l2.start());\n+        assertEquals(14, l2.end());\n+\n+        \/\/ geometry check\n+        assertEquals(0, l0.bounds().getMinX(), EPS);\n+        assertEquals(0, l0.bounds().getMinY(), EPS);\n+        assertTrue(l0.bounds().getWidth() < l1.bounds().getWidth());\n+        assertTrue(l1.bounds().getWidth() < l2.bounds().getWidth());\n+        assertTrue(l0.bounds().getMinY() < l1.bounds().getMinY());\n+        assertTrue(l1.bounds().getMinY() < l2.bounds().getMinY());\n+\n+        \/\/ line spacing\n+        apply((f) -> {\n+            f.setLineSpacing(LINE_SPACING);\n+        });\n+        waitForIdle();\n+\n+        List<TextLineInfo> LS = la.getTextLines(true);\n+        assertNotNull(LS);\n+        TextLineInfo L0 = la.getTextLine(0, true);\n+        TextLineInfo L1 = la.getTextLine(1, true);\n+        TextLineInfo L2 = la.getTextLine(2, true);\n+        assertEquals(L0, LS.get(0));\n+        assertEquals(L1, LS.get(1));\n+        assertEquals(L2, LS.get(2));\n+\n+        \/\/ widths should be same\n+        assertEquals(l0.bounds().getWidth(), L0.bounds().getWidth());\n+        assertEquals(l1.bounds().getWidth(), L1.bounds().getWidth());\n+        assertEquals(l2.bounds().getWidth(), L2.bounds().getWidth());\n+\n+        \/\/ heights should differ\n+        assertEquals(l0.bounds().getHeight() + LINE_SPACING, L0.bounds().getHeight(), EPS);\n+        assertEquals(l1.bounds().getHeight() + LINE_SPACING, L1.bounds().getHeight(), EPS);\n+        assertEquals(l2.bounds().getHeight() + LINE_SPACING, L2.bounds().getHeight(), EPS);\n+    }\n+\n+    \/\/ testing selection shape\n+    @Test\n+    public void testSelection() {\n+        setText(\"__\\n____\\n______\");\n+        waitForIdle();\n+        LayoutInfo la = text.getLayoutInfo();\n+\n+        \/\/ spacing = 0\n+\n+        int len = textLength();\n+        List<Rectangle2D> ss = la.selectionShape(0, len, false);\n+        assertEquals(ss.size(), 3);\n+        Rectangle2D s0 = ss.get(0);\n+        Rectangle2D s1 = ss.get(1);\n+        Rectangle2D s2 = ss.get(2);\n+\n+        \/\/ geometry check\n+        assertEquals(0, s0.getMinX(), EPS);\n+        assertEquals(0, s0.getMinY(), EPS);\n+\n+        assertTrue(s0.getWidth() < s1.getWidth());\n+        assertTrue(s1.getWidth() < s2.getWidth());\n+\n+        assertTrue(s0.getMinY() < s1.getMinY());\n+        assertTrue(s1.getMinY() < s2.getMinY());\n+\n+        assertTrue(s0.getHeight() >= FONT_SIZE);\n+        assertEquals(s0.getHeight(), s1.getHeight(), EPS);\n+        assertEquals(s1.getHeight(), s2.getHeight(), EPS);\n+\n+        \/\/ line spacing\n+        apply((f) -> {\n+            f.setLineSpacing(LINE_SPACING);\n+        });\n+        waitForIdle();\n+\n+        List<Rectangle2D> SS = la.selectionShape(0, len, true);\n+        assertEquals(ss.size(), 3);\n+        Rectangle2D S0 = SS.get(0);\n+        Rectangle2D S1 = SS.get(1);\n+        Rectangle2D S2 = SS.get(2);\n+\n+        \/\/ geometry check\n+        assertEquals(0, S0.getMinX(), EPS);\n+        assertEquals(0, S0.getMinY(), EPS);\n+\n+        assertTrue(S0.getWidth() < S1.getWidth());\n+        assertTrue(S1.getWidth() < S2.getWidth());\n+\n+        assertTrue(S0.getMinY() < S1.getMinY());\n+        assertTrue(S1.getMinY() < S2.getMinY());\n+\n+        assertTrue(S0.getHeight() >= FONT_SIZE);\n+        assertEquals(S0.getHeight(), S1.getHeight(), EPS);\n+        assertEquals(S1.getHeight(), S2.getHeight(), EPS);\n+\n+        \/\/ includes line space\n+        assertEquals(s0.getHeight() + LINE_SPACING, S0.getHeight(), EPS);\n+    }\n+\n+    \/\/ testing strike-through shape\n+    @Test\n+    public void testStrikeThrough() {\n+        setText(\"__\\n____\\n______\");\n+        waitForIdle();\n+        LayoutInfo la = text.getLayoutInfo();\n+\n+        int len = textLength();\n+        List<Rectangle2D> ss = la.strikeThroughShape(0, len);\n+        assertEquals(ss.size(), 3);\n+        Rectangle2D s0 = ss.get(0);\n+        Rectangle2D s1 = ss.get(1);\n+        Rectangle2D s2 = ss.get(2);\n+\n+        \/\/ geometry check\n+        assertEquals(0, s0.getMinX(), EPS);\n+\n+        assertTrue(s0.getWidth() < s1.getWidth());\n+        assertTrue(s1.getWidth() < s2.getWidth());\n+\n+        assertTrue(s0.getMinY() < s1.getMinY());\n+        assertTrue(s1.getMinY() < s2.getMinY());\n+\n+        assertTrue(s0.getHeight() > 0);\n+        assertEquals(s0.getHeight(), s1.getHeight(), EPS);\n+        assertEquals(s1.getHeight(), s2.getHeight(), EPS);\n+    }\n+\n+    \/\/ testing underline shape\n+    @Test\n+    public void testUnderline() {\n+        setText(\"__\\n____\\n______\");\n+        waitForIdle();\n+        LayoutInfo la = text.getLayoutInfo();\n+\n+        int len = textLength();\n+        List<Rectangle2D> ss = la.underlineShape(0, len);\n+        assertEquals(ss.size(), 3);\n+        Rectangle2D s0 = ss.get(0);\n+        Rectangle2D s1 = ss.get(1);\n+        Rectangle2D s2 = ss.get(2);\n+\n+        \/\/ geometry check\n+        assertEquals(0, s0.getMinX(), EPS);\n+\n+        assertTrue(s0.getWidth() < s1.getWidth());\n+        assertTrue(s1.getWidth() < s2.getWidth());\n+\n+        assertTrue(s0.getMinY() < s1.getMinY());\n+        assertTrue(s1.getMinY() < s2.getMinY());\n+\n+        assertTrue(s0.getHeight() > 0);\n+        assertEquals(s0.getHeight(), s1.getHeight(), EPS);\n+        assertEquals(s1.getHeight(), s2.getHeight(), EPS);\n+    }\n+\n+    private void setText(String s) {\n+        Util.runAndWait(() -> {\n+            text = new Text(s);\n+            text.setFont(new Font(FONT_SIZE));\n+            root.getChildren().setAll(text);\n+        });\n+    }\n+\n+    private void waitForIdle() {\n+        Util.waitForIdle(scene);\n+    }\n+\n+    public static int textLength() {\n+        return text.getText().length();\n+    }\n+\n+    private void apply(Consumer<Text> c) {\n+        Util.runAndWait(() -> {\n+            c.accept(text);\n+        });\n+    }\n+\n+    @BeforeAll\n+    public static void beforeAll() {\n+        Util.launch(startupLatch, TestApp.class);\n+    }\n+\n+    @AfterAll\n+    public static void exit() {\n+        Util.shutdown();\n+    }\n+\n+    public static class TestApp extends Application {\n+        @Override\n+        public void start(Stage st) {\n+            robot = new Robot();\n+            stage = st;\n+\n+            root = new Group();\n+            scene = new Scene(root, WIDTH, HEIGHT);\n+            stage.setScene(scene);\n+            stage.initStyle(StageStyle.UNDECORATED);\n+            stage.setOnShown(event -> Platform.runLater(startupLatch::countDown));\n+            stage.setAlwaysOnTop(true);\n+            stage.show();\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/Text_TextLayout_Test.java","additions":349,"deletions":0,"binary":false,"changes":349,"status":"added"}]}