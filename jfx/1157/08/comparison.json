{"files":[{"patch":"@@ -202,1 +202,12 @@\n-    public Hit getHitInfo(float x, float y);\n+    \/**\n+     * Calculates character index and insertion index for the given coordinates\n+     * and maps to {@link Hit} class.\n+     *\n+     * @param x x coordinate value.\n+     * @param y y coordinate value.\n+     * @param text text for which HitInfo needs to be calculated.\n+     *             It is expected to be null in the case of {@link javafx.scene.text.TextFlow}\n+     *             and non-null in the case of {@link javafx.scene.text.Text}\n+     * @return returns a {@link Hit} object containing character index, insertion index and position of cursor on the character.\n+     *\/\n+    public Hit getHitInfo(float x, float y, String text, int textRunStart, int curRunStart);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/text\/TextLayout.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import com.sun.javafx.geom.BoxBounds;\n@@ -423,1 +424,1 @@\n-    public Hit getHitInfo(float x, float y) {\n+    public Hit getHitInfo(float x, float y, String text, int textRunStart, int curRunStart) {\n@@ -427,0 +428,2 @@\n+        int relIndex = 0;\n+        int textWidthPrevLine = 0;\n@@ -429,1 +432,1 @@\n-        int lineIndex = getLineIndex(y);\n+        int lineIndex = getLineIndex(y, text, curRunStart);\n@@ -443,6 +446,39 @@\n-            for (int i = 0; i < runs.length; i++) {\n-                run = runs[i];\n-                if (x < run.getWidth()) break;\n-                if (i + 1 < runs.length) {\n-                    if (runs[i + 1].isLinebreak()) break;\n-                    x -= run.getWidth();\n+            if (text == null || spans == null) {\n+                for (int i = 0; i < runs.length; i++) {\n+                    run = runs[i];\n+                    if (x < run.getWidth()) break;\n+                    if (i + 1 < runs.length) {\n+                        if (runs[i + 1].isLinebreak()) break;\n+                        x -= run.getWidth();\n+                    }\n+                }\n+            } else {\n+                for (int i = 0; i < lineIndex; i++) {\n+                    for (TextRun r: lines[i].runs) {\n+                        if (r.getTextSpan() != null && r.getTextSpan().getText().equals(text) && r.getStart() >= textRunStart) {\n+                            textWidthPrevLine += r.getLength();\n+                        }\n+                    }\n+                }\n+                int prevNodeLength = 0;\n+                boolean isPrevNodeExcluded = false;\n+                for (TextRun r: runs) {\n+                    if (!r.getTextSpan().getText().equals(text) || (r.getTextSpan().getText().equals(text) && r.getStart() < textRunStart)) {\n+                        prevNodeLength += r.getWidth();\n+                        continue;\n+                    }\n+                    if (r.getTextSpan() != null && r.getTextSpan().getText().equals(text)) {\n+                        BaseBounds textBounds = new BoxBounds();\n+                        getBounds(r.getTextSpan(), textBounds);\n+                        if (textBounds.getMinX() == 0 && !isPrevNodeExcluded) {\n+                            x -= prevNodeLength;\n+                            isPrevNodeExcluded = true;\n+                        }\n+                        if (x > r.getWidth()) {\n+                            x -= r.getWidth();\n+                            relIndex += r.getLength();\n+                            continue;\n+                        }\n+                        run = r;\n+                        break;\n+                    }\n@@ -451,0 +487,1 @@\n+\n@@ -453,1 +490,7 @@\n-                charIndex = run.getStart() + run.getOffsetAtX(x, trailing);\n+                if (text != null && spans != null) {\n+                    charIndex = run.getOffsetAtX(x, trailing);\n+                    charIndex += textWidthPrevLine;\n+                    charIndex += relIndex;\n+                } else {\n+                    charIndex = run.getStart() + run.getOffsetAtX(x, trailing);\n+                }\n@@ -460,1 +503,5 @@\n-                        charIterator.setText(new String(getText()));\n+                        if (text != null) {\n+                            charIterator.setText(text);\n+                        } else {\n+                            charIterator.setText(new String(getText()));\n+                        }\n@@ -705,1 +752,1 @@\n-    private int getLineIndex(float y) {\n+    private int getLineIndex(float y, String text, int runStart) {\n@@ -708,0 +755,4 @@\n+        \/* Initializing textFound as true when text is null\n+         * because when this function is called for TextFlow text parameter will be null *\/\n+        boolean textFound = (text == null);\n+\n@@ -710,0 +761,10 @@\n+            if (!textFound) {\n+                for (TextRun r : lines[index].runs) {\n+                    if (r.getTextSpan() == null || (r.getTextSpan().getText().equals(text) && r.getStart() == runStart)) {\n+                        \/* Span will present only for Rich Text.\n+                         * Hence making textFound as true *\/\n+                        textFound = true;\n+                        break;\n+                    }\n+                }\n+            }\n@@ -711,2 +772,6 @@\n-            if (index + 1 == lineCount) bottom -= lines[index].getLeading();\n-            if (bottom > y) break;\n+            if (index + 1 == lineCount) {\n+                bottom -= lines[index].getLeading();\n+            }\n+            if (bottom > y && textFound) {\n+                break;\n+            }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/PrismTextLayout.java","additions":78,"deletions":13,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -396,1 +396,1 @@\n-            if (runX + advance > x) {\n+            if (runX + advance >= x) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/TextRun.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import com.sun.javafx.text.TextRun;\n@@ -1025,1 +1026,15 @@\n-        TextLayout.Hit h = layout.getHitInfo((float)x, (float)y);\n+        GlyphList[] runs = getRuns();\n+        int runIndex = 0;\n+        if (runs.length != 0) {\n+            Point2D ptInParent = localToParent(x, y);\n+            while (runIndex < runs.length - 1) {\n+                if (ptInParent.getY() > runs[runIndex].getLocation().y\n+                        && ptInParent.getY() < runs[runIndex + 1].getLocation().y) {\n+                    break;\n+                }\n+                runIndex++;\n+            }\n+        }\n+        int textRunStart = runs.length == 0 ? 0 : ((TextRun) runs[0]).getStart();\n+        int curRunStart = runs.length == 0 ? 0 : ((TextRun) runs[runIndex]).getStart();\n+        TextLayout.Hit h = layout.getHitInfo((float)x, (float)y, getText(), textRunStart, curRunStart);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/Text.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-            TextLayout.Hit h = layout.getHitInfo((float)x, (float)y);\n+            TextLayout.Hit h = layout.getHitInfo((float)x, (float)y, null, 0, 0);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/TextFlow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-    public Hit getHitInfo(float x, float y) {\n+    public Hit getHitInfo(float x, float y, String text, int textRunStart, int curRunStart) {\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/pgstub\/StubTextLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,596 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.robot.javafx.scene;\n+\n+import java.util.Random;\n+import java.util.concurrent.CountDownLatch;\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.geometry.Point2D;\n+import javafx.scene.Scene;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.robot.Robot;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.HitInfo;\n+import javafx.scene.text.Text;\n+import javafx.scene.text.TextFlow;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+import javafx.stage.Window;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import test.util.Util;\n+\n+import javafx.scene.input.PickResult;\n+import javafx.scene.Node;\n+import javafx.geometry.Point3D;\n+\n+\/*\n+ * Test for verifying character index of Text nodes embedded in TextFlow.\n+ *\n+ * There are 7 tests in this file.\n+ * Steps for testTwoTextNodesCharIndexEmbeddedInTexFlow()\n+ * 1. Create a TextFlow. Add two Text nodes with only text.\n+ * 2. Move the cursor from first character to last character with a random\n+ *    incement generated in step() method.\n+ * 3. Character index should change as expected and it is relative\n+ *    to the Text node.\n+ *\n+ * Steps for testTextAndEmojiCharIndexEmbeddedInTexFlow()\n+ * 1. Create a TextFlow. Add two Text nodes, one with text and one with emojis.\n+ * 2. Move the cursor from first character to last character with a random\n+ *    incement generated in step() method.\n+ * 3. Character index should change as expected and it is relative\n+ *    to the Text node.\n+ *\n+ * Steps for testEmojiAndTextCharIndexEmbeddedInTexFlow()\n+ * 1. Create a TextFlow. Add two Text nodes, one with emojis and one with text.\n+ * 2. Move the cursor from first character to last character with a random\n+ *    incement generated in step() method.\n+ * 3. Character index should change as expected and it is relative\n+ *    to the Text node.\n+ *\n+ * Steps for testTwoEmojiNodesCharIndexEmbeddedInTexFlow()\n+ * 1. Create a TextFlow. Add two Text nodes containing only emojis.\n+ * 2. Move the cursor from first character to last character with a random\n+ *    incement generated in step() method.\n+ * 3. Character index should change as expected and it is relative\n+ *    to the Text node.\n+ *\n+ * Steps for testWrappedTextNodesCharIndexEmbeddedInTexFlow()\n+ * 1. Create a TextFlow. Add two Text nodes which gets wrapped.\n+ * 2. Move the cursor from first character to last character on both lines\n+ *    with a random incement generated in step() method.\n+ * 3. Character index should change as expected and it is relative\n+ *    to the Text node.\n+ *\n+ * Steps for testMultiLineTextNodesCharIndexEmbeddedInTexFlow()\n+ * 1. Create a TextFlow. Add two Text nodes with emojis where new line is explicitly added.\n+ * 2. Move the cursor from first character to last character on both lines\n+ *    with a random incement generated in step() method.\n+ * 3. Character index should change as expected and it is relative\n+ *    to the Text node.\n+ *\n+ * Steps for testMultiLineEmojisCharIndexEmbeddedInTexFlow()\n+ * 1. Create a TextFlow. Add two Text nodes with emojis where new line is explicitly added.\n+ * 2. Move the cursor from first character to last character on both lines\n+ *    with a random incement generated in step() method.\n+ * 3. Character index should change as expected and it is relative\n+ *    to the Text node.\n+ *\/\n+\n+public class TextCharacterIndexTest {\n+    static CountDownLatch startupLatch = new CountDownLatch(1);\n+    static Random random;\n+    static Robot robot;\n+    static TextFlow textFlow;\n+    static Text textOne;\n+    static Text textTwo;\n+    static Text textThree;\n+    static Text emoji;\n+\n+    static volatile Stage stage;\n+    static volatile Scene scene;\n+\n+    static final int WIDTH = 500;\n+    static final int HEIGHT = 150;\n+\n+    final int Y_OFFSET = 25;\n+    final int X_LEADING_OFFSET = 10;\n+    final int X_TRAILING_OFFSET = 40;\n+\n+    boolean isLeading;\n+    boolean isSurrogatePair;\n+    int charIndex;\n+    int insertionIndex;\n+    int textFlowCharIndex;\n+\n+    private void mouseClick(double x, double y) {\n+        Util.runAndWait(() -> {\n+            Window w = scene.getWindow();\n+            robot.mouseMove((int) (w.getX() + scene.getX() + x),\n+                    (int) (w.getY() + scene.getY() + y));\n+            robot.mouseClick(MouseButton.PRIMARY);\n+        });\n+    }\n+\n+    private void moveMouseOverTextFlow(double x, double y) throws Exception {\n+        mouseClick(textFlow.getLayoutX() + x,\n+                    textFlow.getLayoutY() + y);\n+    }\n+\n+    private void addTwoTextNodes() {\n+        Util.runAndWait(() -> {\n+            textOne = new Text(\"This is Text\");\n+            textOne.setFont(new Font(48));\n+            textTwo = new Text(\"This is Text\");\n+            textTwo.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo);\n+        });\n+    }\n+\n+    private void addTextAndEmojisNoes() {\n+        Util.runAndWait(() -> {\n+            textOne = new Text(\"Text: \");\n+            textOne.setFont(new Font(48));\n+            textTwo = new Text(\"üòäüòáüíôü¶ãüèÅüî•\");\n+            textTwo.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo);\n+        });\n+    }\n+\n+    private void addEmojisAndTextNode() {\n+        Util.runAndWait(() -> {\n+            textOne = new Text(\"üòäüòáüíôü¶ãüèÅüî•\");\n+            textOne.setFont(new Font(48));\n+            textTwo = new Text(\"Text\");\n+            textTwo.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo);\n+        });\n+    }\n+\n+    private void addTwoEmojiNodes() {\n+        Util.runAndWait(() -> {\n+            textOne = new Text(\"üòäüíôü¶ãüèÅüî•\");\n+            textOne.setFont(new Font(48));\n+            textTwo = new Text(\"üòäüíôü¶ãüèÅüî•\");\n+            textTwo.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo);\n+        });\n+    }\n+\n+    private void addWrappedTextNodes() {\n+        Util.runAndWait(() -> {\n+            textOne = new Text(\"This is Text This is Text This is Text\");\n+            textOne.setFont(new Font(48));\n+            textTwo = new Text(\"üòäüíôü¶ãüèÅüî•\");\n+            textTwo.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo);\n+        });\n+    }\n+\n+    private void addMultiLineTextNodes() {\n+        Util.runAndWait(() -> {\n+            textOne = new Text(\"This is Text This is Text\");\n+            textOne.setFont(new Font(48));\n+            textTwo = new Text(\"üòäüíôü¶ãüèÅüî•\");\n+            textTwo.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo);\n+        });\n+    }\n+\n+    private void addMultiLineEmojisInTextNodes() {\n+        Util.runAndWait(() -> {\n+            textOne = new Text(\"üòäüíôü¶ãüèÅüî•üòäüíôü¶ãüèÅüî•üòäüíôü¶ãüèÅüî•\");\n+            textOne.setFont(new Font(48));\n+            textTwo = new Text(\"This is Text\");\n+            textTwo.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo);\n+        });\n+    }\n+\n+    private void addMultipleTexNodeMultiLineRepeatedText() {\n+        Util.runAndWait(() -> {\n+            textOne = new Text(\"This is Text\");\n+            textOne.setFont(new Font(48));\n+            textTwo = new Text(\"This is Text This is Text\");\n+            textTwo.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo);\n+        });\n+    }\n+\n+    private void addMultipleTextNodeAlternativelyRepeatedText() {\n+        Util.runAndWait(() -> {\n+            textOne = new Text(\"Text\");\n+            textOne.setFont(new Font(48));\n+            textTwo = new Text(\"üòäüíôü¶ãüèÅüî•\");\n+            textTwo.setFont(new Font(48));\n+            textThree = new Text(\"Text\");\n+            textThree.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo, textThree);\n+        });\n+    }\n+\n+    private void addMultipleTexNodeMultiLineRepeatedEmojis() {\n+        Util.runAndWait(() -> {\n+            textOne = new Text(\"üòäüíôü¶ãüèÅüî•\");\n+            textOne.setFont(new Font(48));\n+            textTwo = new Text(\"üòäüíôü¶ãüèÅüî•üòäüíôü¶ãüèÅüî•\");\n+            textTwo.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo);\n+        });\n+    }\n+\n+    private void addMultipleTextNodeAlternativelyRepeatedEmoji() {\n+        Util.runAndWait(() -> {\n+            textOne = new Text(\"üòäüíôü¶ãüèÅüî•\");\n+            textOne.setFont(new Font(48));\n+            textTwo = new Text(\"Text\");\n+            textTwo.setFont(new Font(48));\n+            textThree = new Text(\"üòäüíôü¶ãüèÅüî•\");\n+            textThree.setFont(new Font(48));\n+            textFlow.getChildren().setAll(textOne, textTwo, textThree);\n+        });\n+    }\n+\n+    @Test\n+    public void testTwoTextNodesCharIndexEmbeddedInTextFlow() throws Exception {\n+        addTwoTextNodes();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+\n+        double x = 0.0;\n+        while (x < (WIDTH - X_LEADING_OFFSET)) {\n+            moveMouseOverTextFlow(x, Y_OFFSET);\n+            if (isLeading) {\n+                Assert.assertEquals(charIndex, insertionIndex);\n+            } else {\n+                Assert.assertEquals(charIndex, insertionIndex - 1);\n+            }\n+            Assert.assertTrue(charIndex < Math.max(textOneLength, textTwoLength));\n+            x += step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTextAndEmojiCharIndexEmbeddedInTextFlow() throws Exception {\n+        addTextAndEmojisNoes();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+\n+        double x = 0.0;\n+        while (x < (WIDTH - X_LEADING_OFFSET)) {\n+            moveMouseOverTextFlow(x, Y_OFFSET);\n+            if (isLeading) {\n+                Assert.assertEquals(charIndex, insertionIndex);\n+            } else if (isSurrogatePair) {\n+                Assert.assertEquals(charIndex, insertionIndex - 2);\n+            } else {\n+                Assert.assertEquals(charIndex, insertionIndex - 1);\n+            }\n+            Assert.assertTrue(charIndex < Math.max(textOneLength, textTwoLength));\n+            x += step();\n+        }\n+    }\n+\n+    @Test\n+    public void testEmojiAndTextCharIndexEmbeddedInTextFlow() throws Exception {\n+        addEmojisAndTextNode();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+\n+        double x = 0.0;\n+        while (x < (WIDTH - X_LEADING_OFFSET)) {\n+            moveMouseOverTextFlow(x, Y_OFFSET);\n+            if (isLeading) {\n+                Assert.assertEquals(charIndex, insertionIndex);\n+            } else if (isSurrogatePair) {\n+                Assert.assertEquals(charIndex, insertionIndex - 2);\n+            } else {\n+                Assert.assertEquals(charIndex, insertionIndex - 1);\n+            }\n+            Assert.assertTrue(charIndex < Math.max(textOneLength, textTwoLength));\n+            x += step();\n+        }\n+    }\n+\n+    @Test\n+    public void testTwoEmojiNodesCharIndexEmbeddedInTextFlow() throws Exception {\n+        addTwoEmojiNodes();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+\n+        double x = 0.0;\n+        while (x < (WIDTH - X_LEADING_OFFSET)) {\n+            moveMouseOverTextFlow(x, Y_OFFSET);\n+            if (isLeading) {\n+                Assert.assertEquals(charIndex, insertionIndex);\n+            } else if (isSurrogatePair) {\n+                Assert.assertEquals(charIndex, insertionIndex - 2);\n+            }\n+            else {\n+                Assert.assertEquals(charIndex, insertionIndex - 1);\n+            }\n+            Assert.assertTrue(charIndex < Math.max(textOneLength, textTwoLength));\n+            x += step();\n+        }\n+    }\n+\n+    @Test\n+    public void testWrappedTextNodesCharIndexEmbeddedInTextFlow() throws Exception {\n+        addWrappedTextNodes();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = 0.0;\n+            while (x < (WIDTH - X_LEADING_OFFSET)) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assert.assertEquals(charIndex, insertionIndex);\n+                } else if (isSurrogatePair) {\n+                    Assert.assertEquals(charIndex, insertionIndex - 2);\n+                } else {\n+                    Assert.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assert.assertTrue(charIndex < Math.max(textOneLength, textTwoLength));\n+                x += step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMultiLineTextNodesCharIndexEmbeddedInTextFlow() throws Exception {\n+        addMultiLineTextNodes();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = 0.0;\n+            while (x < (WIDTH - X_LEADING_OFFSET)) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assert.assertEquals(charIndex, insertionIndex);\n+                } else if (isSurrogatePair) {\n+                    Assert.assertEquals(charIndex, insertionIndex - 2);\n+                } else {\n+                    Assert.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assert.assertTrue(charIndex < Math.max(textOneLength, textTwoLength));\n+                x += step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMultiLineEmojisCharIndexEmbeddedInTextFlow() throws Exception {\n+        addMultiLineEmojisInTextNodes();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = 0.0;\n+            while (x < (WIDTH - X_LEADING_OFFSET)) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assert.assertEquals(charIndex, insertionIndex);\n+                } else if (isSurrogatePair) {\n+                    Assert.assertEquals(charIndex, insertionIndex - 2);\n+                } else {\n+                    Assert.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assert.assertTrue(charIndex < Math.max(textOneLength, textTwoLength));\n+                x += step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMultiTextNodesMultiLineRepeatedTextEmbeddedInTextFlow() throws Exception {\n+        addMultipleTexNodeMultiLineRepeatedText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = 0.0;\n+            while (x < (WIDTH - X_LEADING_OFFSET)) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assert.assertEquals(charIndex, insertionIndex);\n+                } else if (isSurrogatePair) {\n+                    Assert.assertEquals(charIndex, insertionIndex - 2);\n+                } else {\n+                    Assert.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assert.assertTrue(charIndex < Math.max(textOneLength, textTwoLength));\n+                x += step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMultiTextNodesAlternativelyRepeatedTextEmbeddedInTextFlow() throws Exception {\n+        addMultipleTextNodeAlternativelyRepeatedText();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+\n+        double x = 0.0;\n+            while (x < (WIDTH - X_LEADING_OFFSET)) {\n+                moveMouseOverTextFlow(x, Y_OFFSET);\n+                if (isLeading) {\n+                    Assert.assertEquals(charIndex, insertionIndex);\n+                } else if (isSurrogatePair) {\n+                    Assert.assertEquals(charIndex, insertionIndex - 2);\n+                } else {\n+                    Assert.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assert.assertTrue(charIndex < Math.max(textOneLength, textTwoLength));\n+                x += step();\n+            }\n+    }\n+\n+    @Test\n+    public void testMultiTextNodesMultiLineRepeatedTEmojiEmbeddedInTextFlow() throws Exception {\n+        addMultipleTexNodeMultiLineRepeatedEmojis();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = 0.0;\n+            while (x < (WIDTH - X_LEADING_OFFSET)) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assert.assertEquals(charIndex, insertionIndex);\n+                } else if (isSurrogatePair) {\n+                    Assert.assertEquals(charIndex, insertionIndex - 2);\n+                } else {\n+                    Assert.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assert.assertTrue(charIndex < Math.max(textOneLength, textTwoLength));\n+                x += step();\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMultiTextNodesAlternativelyRepeatedEmojisEmbeddedInTextFlow() throws Exception {\n+        addMultipleTextNodeAlternativelyRepeatedEmoji();\n+        Util.waitForIdle(scene);\n+\n+        int textOneLength = textOne.getText().length();\n+        int textTwoLength = textTwo.getText().length();\n+        int textThreeLength = textTwo.getText().length();\n+\n+        for (int y = 0; y < 2; y++) {\n+            double x = 0.0;\n+            while (x < (WIDTH - X_LEADING_OFFSET)) {\n+                moveMouseOverTextFlow(x, (Y_OFFSET + (Y_OFFSET * (y * 2))));\n+                if (isLeading) {\n+                    Assert.assertEquals(charIndex, insertionIndex);\n+                } else if (isSurrogatePair) {\n+                    Assert.assertEquals(charIndex, insertionIndex - 2);\n+                } else {\n+                    Assert.assertEquals(charIndex, insertionIndex - 1);\n+                }\n+                Assert.assertTrue(charIndex < Math.max(textThreeLength, Math.max(textOneLength, textTwoLength)));\n+                x += step();\n+            }\n+        }\n+    }\n+\n+    private void handleMouseEvent(MouseEvent event) {\n+        PickResult pick = event.getPickResult();\n+        Node n = pick.getIntersectedNode();\n+\n+        if (n != null && n instanceof Text t) {\n+            Point3D p3 = pick.getIntersectedPoint();\n+            Point2D p = new Point2D(p3.getX(), p3.getY());\n+            HitInfo hitInfo = t.hitTest(p);\n+\n+            isLeading = hitInfo.isLeading();\n+            charIndex = hitInfo.getCharIndex();\n+            insertionIndex = hitInfo.getInsertionIndex();\n+            isSurrogatePair = Character.isSurrogate(t.getText().charAt(charIndex));\n+        }\n+\n+        Point2D point = new Point2D(event.getX(), event.getY());\n+        HitInfo textFlowHitInfo = textFlow.hitTest(point);\n+        textFlowCharIndex = textFlowHitInfo.getCharIndex();\n+    }\n+\n+    private double step() {\n+        return 1.0 + random.nextDouble() * 8.0;\n+    }\n+\n+    @After\n+    public void resetUI() {\n+        Platform.runLater(() -> {\n+            textFlow.removeEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+        });\n+    }\n+\n+    @Before\n+    public void setupUI() {\n+        Platform.runLater(() -> {\n+            textFlow.addEventHandler(MouseEvent.MOUSE_PRESSED, this::handleMouseEvent);\n+        });\n+    }\n+\n+    @BeforeClass\n+    public static void initFX() {\n+        long seed = new Random().nextLong();\n+        System.out.println(\"seed=\" + seed);\n+        random = new Random(seed);\n+\n+        Util.launch(startupLatch, TestApp.class);\n+    }\n+\n+    @AfterClass\n+    public static void exit() {\n+        Util.shutdown(stage);\n+    }\n+\n+    public static class TestApp extends Application {\n+        @Override\n+        public void start(Stage primaryStage) {\n+            robot = new Robot();\n+            stage = primaryStage;\n+\n+            textFlow = new TextFlow();\n+            scene = new Scene(textFlow, WIDTH, HEIGHT);\n+            stage.setScene(scene);\n+            stage.initStyle(StageStyle.UNDECORATED);\n+            stage.setOnShown(event -> Platform.runLater(startupLatch::countDown));\n+            stage.setAlwaysOnTop(true);\n+            stage.show();\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/TextCharacterIndexTest.java","additions":596,"deletions":0,"binary":false,"changes":596,"status":"added"}]}