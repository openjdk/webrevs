{"files":[{"patch":"@@ -78,1 +78,1 @@\n-import com.sun.javafx.scene.traversal.Direction;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n@@ -543,1 +543,1 @@\n-                        move(Direction.NEXT);\n+                        move(TraversalDirectionInternal.NEXT);\n@@ -548,1 +548,1 @@\n-                        move(Direction.PREVIOUS);\n+                        move(TraversalDirectionInternal.PREVIOUS);\n@@ -710,1 +710,1 @@\n-    private void move(Direction dir) {\n+    private void move(TraversalDirectionInternal dir) {\n@@ -715,1 +715,1 @@\n-    private int findSibling(final Direction dir, final int startIndex) {\n+    private int findSibling(final TraversalDirectionInternal dir, final int startIndex) {\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/ContextMenuContent.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+import static com.sun.javafx.PlatformUtil.isMac;\n+import static java.time.temporal.ChronoField.DAY_OF_WEEK;\n+import static java.time.temporal.ChronoField.MONTH_OF_YEAR;\n+import static java.time.temporal.ChronoUnit.DAYS;\n+import static java.time.temporal.ChronoUnit.MONTHS;\n+import static java.time.temporal.ChronoUnit.WEEKS;\n+import static java.time.temporal.ChronoUnit.YEARS;\n@@ -30,0 +37,3 @@\n+import java.time.YearMonth;\n+import java.time.chrono.ChronoLocalDate;\n+import java.time.chrono.Chronology;\n@@ -32,2 +42,0 @@\n-import java.time.chrono.Chronology;\n-import java.time.chrono.ChronoLocalDate;\n@@ -37,1 +45,0 @@\n-import java.time.YearMonth;\n@@ -41,5 +48,0 @@\n-\n-import static java.time.temporal.ChronoField.*;\n-import static java.time.temporal.ChronoUnit.*;\n-\n-import com.sun.javafx.scene.control.skin.*;\n@@ -54,1 +56,0 @@\n-import javafx.scene.control.DatePicker;\n@@ -56,0 +57,1 @@\n+import javafx.scene.control.DatePicker;\n@@ -64,1 +66,0 @@\n-import javafx.scene.layout.VBox;\n@@ -66,1 +67,2 @@\n-\n+import javafx.scene.layout.VBox;\n+import com.sun.javafx.scene.control.skin.Utils;\n@@ -68,5 +70,2 @@\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n-\n-import static com.sun.javafx.PlatformUtil.*;\n-import com.sun.javafx.scene.NodeHelper;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -174,1 +173,1 @@\n-                        NodeHelper.traverse(gridPane, Direction.PREVIOUS, TraversalMethod.DEFAULT);\n+                        TraversalUtils.traverse(gridPane, TraversalDirectionInternal.PREVIOUS, false);\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/DatePickerContent.java","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,4 @@\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Control;\n+import javafx.scene.control.Skin;\n@@ -447,0 +451,56 @@\n+\n+    \/**\n+     * Adds a disonnectable machinery to listen to {@code control}'s Scene and Scene.focusOwner properties,\n+     * for the purpose of invoking the supplied callback when focused node is in the {@code control}'s hierarchy\n+     * or is the control itself.\n+     *\n+     * @param control the control\n+     * @param callback the callback\n+     *\/\n+    public void addSceneFocusOwnerListener(Control control, Consumer<Node> callback) {\n+        items.add(new ChLi<Scene>() {\n+            private ChangeListener<Node> focusListener = (s, p, n) -> {\n+                if (isParent(control, n)) {\n+                    callback.accept(n);\n+                }\n+            };\n+\n+            {\n+                control.sceneProperty().addListener(this);\n+                Scene scene = control.getScene();\n+                if (scene != null) {\n+                    scene.focusOwnerProperty().addListener(focusListener);\n+                }\n+            }\n+\n+            private static boolean isParent(Node parent, Node n) {\n+                while (n != null) {\n+                    if (parent == n) {\n+                        return true;\n+                    }\n+                    n = n.getParent();\n+                }\n+                return false;\n+            }\n+\n+            @Override\n+            public void disconnect() {\n+                control.sceneProperty().removeListener(this);\n+                Scene scene = control.getScene();\n+                if (scene != null) {\n+                    scene.focusOwnerProperty().removeListener(focusListener);\n+                }\n+                focusListener = null;\n+            }\n+\n+            @Override\n+            public void changed(ObservableValue<? extends Scene> p, Scene old, Scene scene) {\n+                if (old != null) {\n+                    old.focusOwnerProperty().removeListener(focusListener);\n+                }\n+                if (scene != null) {\n+                    scene.focusOwnerProperty().addListener(focusListener);\n+                }\n+            }\n+        });\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/ListenerHelper.java","additions":61,"deletions":1,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.javafx.scene.traversal.Direction;\n@@ -32,1 +31,0 @@\n-\n@@ -35,1 +33,1 @@\n-\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n@@ -60,4 +58,4 @@\n-            new InputMap.KeyMapping(UP,    e -> traverse(dateCell, Direction.UP)),\n-            new InputMap.KeyMapping(DOWN,  e -> traverse(dateCell, Direction.DOWN)),\n-            new InputMap.KeyMapping(LEFT,  e -> traverse(dateCell, Direction.LEFT)),\n-            new InputMap.KeyMapping(RIGHT, e -> traverse(dateCell, Direction.RIGHT)),\n+            new InputMap.KeyMapping(UP,    e -> traverse(dateCell, TraversalDirectionInternal.UP)),\n+            new InputMap.KeyMapping(DOWN,  e -> traverse(dateCell, TraversalDirectionInternal.DOWN)),\n+            new InputMap.KeyMapping(LEFT,  e -> traverse(dateCell, TraversalDirectionInternal.LEFT)),\n+            new InputMap.KeyMapping(RIGHT, e -> traverse(dateCell, TraversalDirectionInternal.RIGHT)),\n@@ -79,1 +77,1 @@\n-    public void traverse(final DateCell cell, final Direction dir) {\n+    public void traverse(final DateCell cell, final TraversalDirectionInternal dir) {\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/DateCellBehavior.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,12 +27,0 @@\n-import com.sun.javafx.scene.NodeHelper;\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n-import javafx.event.EventTarget;\n-import javafx.scene.Node;\n-import com.sun.javafx.scene.control.inputmap.InputMap;\n-import com.sun.javafx.scene.control.inputmap.KeyBinding;\n-import javafx.scene.input.KeyEvent;\n-\n-import java.util.List;\n-\n-import static com.sun.javafx.scene.control.inputmap.InputMap.*;\n@@ -44,0 +32,9 @@\n+import java.util.List;\n+import javafx.event.EventTarget;\n+import javafx.scene.Node;\n+import javafx.scene.input.KeyEvent;\n+import com.sun.javafx.scene.control.inputmap.InputMap;\n+import com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;\n+import com.sun.javafx.scene.control.inputmap.KeyBinding;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -90,1 +87,1 @@\n-     * @param method The focus traversal method\n+     * @param focusVisible whether the focused Node should visible indicate focus\n@@ -92,1 +89,1 @@\n-    public static void traverse(final Node node, final Direction dir, TraversalMethod method) {\n+    public static void traverse(final Node node, final TraversalDirectionInternal dir, boolean focusVisible) {\n@@ -97,1 +94,1 @@\n-        NodeHelper.traverse(node, dir, method);\n+        TraversalUtils.traverse(node, dir, focusVisible);\n@@ -105,1 +102,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n+        traverse(getNode(e), TraversalDirectionInternal.UP, true);\n@@ -113,1 +110,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n+        traverse(getNode(e), TraversalDirectionInternal.DOWN, true);\n@@ -121,1 +118,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n+        traverse(getNode(e), TraversalDirectionInternal.LEFT, true);\n@@ -129,1 +126,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n+        traverse(getNode(e), TraversalDirectionInternal.RIGHT, true);\n@@ -137,1 +134,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n+        traverse(getNode(e), TraversalDirectionInternal.NEXT, true);\n@@ -145,1 +142,1 @@\n-        traverse(getNode(e), com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n+        traverse(getNode(e), TraversalDirectionInternal.PREVIOUS, true);\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/FocusTraversalInputMap.java","additions":19,"deletions":22,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,4 @@\n-import com.sun.javafx.scene.control.skin.Utils;\n+import static javafx.scene.input.KeyCode.DOWN;\n+import static javafx.scene.input.KeyCode.LEFT;\n+import static javafx.scene.input.KeyCode.RIGHT;\n+import static javafx.scene.input.KeyCode.UP;\n@@ -36,1 +39,0 @@\n-import com.sun.javafx.scene.control.inputmap.InputMap;\n@@ -38,3 +40,5 @@\n-\n-import static com.sun.javafx.scene.control.inputmap.InputMap.*;\n-import static javafx.scene.input.KeyCode.*;\n+import com.sun.javafx.scene.control.inputmap.InputMap;\n+import com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;\n+import com.sun.javafx.scene.control.inputmap.InputMap.Mapping;\n+import com.sun.javafx.scene.control.skin.Utils;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n@@ -48,4 +52,4 @@\n-            new KeyMapping(RIGHT, e -> traverse(e, \"ToggleNext-Right\")),\n-            new KeyMapping(LEFT, e -> traverse(e, \"TogglePrevious-Left\")),\n-            new KeyMapping(DOWN, e -> traverse(e, \"ToggleNext-Down\")),\n-            new KeyMapping(UP, e -> traverse(e, \"TogglePrevious-Up\"))\n+            new KeyMapping(RIGHT, e -> traverse(e, TraversalDirectionInternal.RIGHT)),\n+            new KeyMapping(LEFT, e -> traverse(e, TraversalDirectionInternal.LEFT)),\n+            new KeyMapping(DOWN, e -> traverse(e, TraversalDirectionInternal.DOWN)),\n+            new KeyMapping(UP, e -> traverse(e, TraversalDirectionInternal.UP))\n@@ -94,1 +98,1 @@\n-    private void traverse(KeyEvent e, String name) {\n+    private final void traverse(KeyEvent e, TraversalDirectionInternal dir) {\n@@ -105,1 +109,1 @@\n-        boolean traversingToNext = traversingToNext(name, toggleButton.getEffectiveNodeOrientation());\n+        boolean traversingToNext = traversingToNext(dir, toggleButton.getEffectiveNodeOrientation());\n@@ -137,1 +141,1 @@\n-    private boolean traversingToNext(String name, NodeOrientation effectiveNodeOrientation) {\n+    private boolean traversingToNext(TraversalDirectionInternal dir, NodeOrientation effectiveNodeOrientation) {\n@@ -139,2 +143,2 @@\n-        switch (name) {\n-            case \"ToggleNext-Right\":\n+        switch (dir) {\n+            case RIGHT:\n@@ -142,1 +146,1 @@\n-            case \"ToggleNext-Down\":\n+            case DOWN:\n@@ -144,1 +148,1 @@\n-            case \"TogglePrevious-Left\":\n+            case LEFT:\n@@ -146,1 +150,1 @@\n-            case \"TogglePrevious-Up\":\n+            case UP:\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/ToggleButtonBehavior.java","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-import com.sun.javafx.scene.NodeHelper;\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n+import javafx.beans.value.ChangeListener;\n@@ -31,0 +30,3 @@\n+import javafx.event.Event;\n+import javafx.event.EventDispatcher;\n+import javafx.event.EventHandler;\n@@ -32,0 +34,1 @@\n+import javafx.scene.Scene;\n@@ -34,2 +37,0 @@\n-\n-import javafx.scene.Scene;\n@@ -37,5 +38,0 @@\n-\n-import javafx.beans.value.ChangeListener;\n-import javafx.event.Event;\n-import javafx.event.EventDispatcher;\n-import javafx.event.EventHandler;\n@@ -43,0 +39,2 @@\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -96,2 +94,6 @@\n-        if (event instanceof KeyEvent && event.getEventType() == KeyEvent.KEY_PRESSED) {\n-            if (!((KeyEvent)event).isMetaDown() && !((KeyEvent)event).isControlDown()  && !((KeyEvent)event).isAltDown()) {\n+        if (event instanceof KeyEvent ev && event.getEventType() == KeyEvent.KEY_PRESSED) {\n+            if (\n+                !ev.isMetaDown() &&\n+                !ev.isControlDown() &&\n+                !ev.isAltDown()\n+            ) {\n@@ -104,37 +106,35 @@\n-\n-                    switch (((KeyEvent)event).getCode()) {\n-                      case TAB :\n-                          if (((KeyEvent)event).isShiftDown()) {\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n-                          }\n-                          else {\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n-                          }\n-                          event.consume();\n-                          break;\n-                      case UP :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case DOWN :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case LEFT :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case RIGHT :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case ENTER :\n-                          setExternalFocus(false);\n-                          event.consume();\n-                          break;\n-                      default :\n-                          \/\/ this'll kill mnemonics.... unless!\n-                          Scene s = tlNode.getScene();\n-                          Event.fireEvent(s, event);\n-                          event.consume();\n-                          break;\n+                    switch (ev.getCode()) {\n+                    case TAB:\n+                        if (ev.isShiftDown()) {\n+                            traverse(obj, TraversalDirectionInternal.PREVIOUS);\n+                        } else {\n+                            traverse(obj, TraversalDirectionInternal.NEXT);\n+                        }\n+                        event.consume();\n+                        break;\n+                    case UP:\n+                        traverse(obj, TraversalDirectionInternal.UP);\n+                        event.consume();\n+                        break;\n+                    case DOWN:\n+                        traverse(obj, TraversalDirectionInternal.DOWN);\n+                        event.consume();\n+                        break;\n+                    case LEFT:\n+                        traverse(obj, TraversalDirectionInternal.LEFT);\n+                        event.consume();\n+                        break;\n+                    case RIGHT:\n+                        traverse(obj, TraversalDirectionInternal.RIGHT);\n+                        event.consume();\n+                        break;\n+                    case ENTER:\n+                        setExternalFocus(false);\n+                        event.consume();\n+                        break;\n+                    default:\n+                        \/\/ this'll kill mnemonics.... unless!\n+                        Scene s = tlNode.getScene();\n+                        Event.fireEvent(s, event);\n+                        event.consume();\n+                        break;\n@@ -236,0 +236,4 @@\n+\n+    protected static void traverse(Object from, TraversalDirectionInternal dir) {\n+        TraversalUtils.traverse((Node)from, dir, true);\n+    }\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TwoLevelFocusBehavior.java","additions":53,"deletions":49,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,7 +28,0 @@\n-import com.sun.javafx.scene.NodeHelper;\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n-import javafx.scene.Node;\n-\n-import javafx.scene.Scene;\n-import javafx.scene.input.KeyEvent;\n-\n@@ -39,0 +32,3 @@\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.input.KeyEvent;\n@@ -40,1 +36,1 @@\n-\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n@@ -77,2 +73,6 @@\n-        if (event instanceof KeyEvent && event.getEventType() == KeyEvent.KEY_PRESSED) {\n-            if (!((KeyEvent)event).isMetaDown() && !((KeyEvent)event).isControlDown()  && !((KeyEvent)event).isAltDown()) {\n+        if (event instanceof KeyEvent ev && event.getEventType() == KeyEvent.KEY_PRESSED) {\n+            if (\n+                !ev.isMetaDown() &&\n+                !ev.isControlDown() &&\n+                !ev.isAltDown())\n+            {\n@@ -85,37 +85,35 @@\n-\n-                    switch (((KeyEvent)event).getCode()) {\n-                      case TAB :\n-                          if (((KeyEvent)event).isShiftDown()) {\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n-                          }\n-                          else {\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n-                          }\n-                          event.consume();\n-                          break;\n-                      case UP :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case DOWN :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case LEFT :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case RIGHT :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case ENTER :\n-                          setExternalFocus(false);\n-                          origEventDispatcher.dispatchEvent(event, tail);\n-                          break;\n-                      default :\n-                          \/\/ this'll kill mnemonics.... unless!\n-                          Scene s = tlNode.getScene();\n-                          Event.fireEvent(s, event);\n-                          event.consume();\n-                          break;\n+                    switch (ev.getCode()) {\n+                    case TAB:\n+                        if (ev.isShiftDown()) {\n+                            traverse(obj, TraversalDirectionInternal.PREVIOUS);\n+                        } else {\n+                            traverse(obj, TraversalDirectionInternal.NEXT);\n+                        }\n+                        event.consume();\n+                        break;\n+                    case UP:\n+                        traverse(obj, TraversalDirectionInternal.UP);\n+                        event.consume();\n+                        break;\n+                    case DOWN:\n+                        traverse(obj, TraversalDirectionInternal.DOWN);\n+                        event.consume();\n+                        break;\n+                    case LEFT:\n+                        traverse(obj, TraversalDirectionInternal.LEFT);\n+                        event.consume();\n+                        break;\n+                    case RIGHT:\n+                        traverse(obj, TraversalDirectionInternal.RIGHT);\n+                        event.consume();\n+                        break;\n+                    case ENTER:\n+                        setExternalFocus(false);\n+                        origEventDispatcher.dispatchEvent(event, tail);\n+                        break;\n+                    default:\n+                        \/\/ this'll kill mnemonics.... unless!\n+                        Scene s = tlNode.getScene();\n+                        Event.fireEvent(s, event);\n+                        event.consume();\n+                        break;\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TwoLevelFocusComboBehavior.java","additions":46,"deletions":48,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,9 +28,0 @@\n-import com.sun.javafx.scene.NodeHelper;\n-import com.sun.javafx.scene.control.Properties;\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n-import javafx.scene.Node;\n-import javafx.scene.Parent;\n-\n-import javafx.scene.Scene;\n-import javafx.scene.input.KeyEvent;\n-\n@@ -41,0 +32,4 @@\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+import javafx.scene.Scene;\n+import javafx.scene.input.KeyEvent;\n@@ -42,0 +37,2 @@\n+import com.sun.javafx.scene.control.Properties;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n@@ -78,2 +75,6 @@\n-        if (event instanceof KeyEvent && event.getEventType() == KeyEvent.KEY_PRESSED) {\n-            if (!((KeyEvent)event).isMetaDown() && !((KeyEvent)event).isControlDown()  && !((KeyEvent)event).isAltDown()) {\n+        if (event instanceof KeyEvent ev && event.getEventType() == KeyEvent.KEY_PRESSED) {\n+            if (\n+                !ev.isMetaDown() &&\n+                !ev.isControlDown() &&\n+                !ev.isAltDown()\n+            ) {\n@@ -86,1 +87,0 @@\n-\n@@ -88,35 +88,34 @@\n-                      case TAB :\n-                          if (((KeyEvent)event).isShiftDown()) {\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n-                          }\n-                          else {\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n-                          }\n-                          event.consume();\n-                          break;\n-                      case UP :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case DOWN :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case LEFT :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case RIGHT :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case ENTER :\n-                          setExternalFocus(false);\n-                          event.consume();\n-                          break;\n-                      default :\n-                          \/\/ this'll kill mnemonics.... unless!\n-                          Scene s = tlNode.getScene();\n-                          Event.fireEvent(s, event);\n-                          event.consume();\n-                          break;\n+                    case TAB:\n+                        if (ev.isShiftDown()) {\n+                            traverse(obj, TraversalDirectionInternal.PREVIOUS);\n+                        } else {\n+                            traverse(obj, TraversalDirectionInternal.NEXT);\n+                        }\n+                        event.consume();\n+                        break;\n+                    case UP:\n+                        traverse(obj, TraversalDirectionInternal.UP);\n+                        event.consume();\n+                        break;\n+                    case DOWN:\n+                        traverse(obj, TraversalDirectionInternal.DOWN);\n+                        event.consume();\n+                        break;\n+                    case LEFT:\n+                        traverse(obj, TraversalDirectionInternal.LEFT);\n+                        event.consume();\n+                        break;\n+                    case RIGHT:\n+                        traverse(obj, TraversalDirectionInternal.RIGHT);\n+                        event.consume();\n+                        break;\n+                    case ENTER:\n+                        setExternalFocus(false);\n+                        event.consume();\n+                        break;\n+                    default:\n+                        \/\/ this'll kill mnemonics.... unless!\n+                        Scene s = tlNode.getScene();\n+                        Event.fireEvent(s, event);\n+                        event.consume();\n+                        break;\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TwoLevelFocusListBehavior.java","additions":47,"deletions":48,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,8 +28,0 @@\n-import com.sun.javafx.scene.NodeHelper;\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n-import javafx.scene.Node;\n-import javafx.scene.control.PopupControl;\n-\n-import javafx.scene.Scene;\n-import javafx.scene.input.KeyEvent;\n-\n@@ -40,0 +32,4 @@\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.control.PopupControl;\n+import javafx.scene.input.KeyEvent;\n@@ -41,1 +37,1 @@\n-\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n@@ -98,2 +94,6 @@\n-        if (event instanceof KeyEvent && event.getEventType() == KeyEvent.KEY_PRESSED) {\n-            if (!((KeyEvent)event).isMetaDown() && !((KeyEvent)event).isControlDown()  && !((KeyEvent)event).isAltDown()) {\n+        if (event instanceof KeyEvent ev && event.getEventType() == KeyEvent.KEY_PRESSED) {\n+            if (\n+                !ev.isMetaDown() &&\n+                !ev.isControlDown() &&\n+                !ev.isAltDown())\n+            {\n@@ -106,37 +106,35 @@\n-\n-                    switch (((KeyEvent)event).getCode()) {\n-                      case TAB :\n-                          if (((KeyEvent)event).isShiftDown()) {\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.PREVIOUS, TraversalMethod.KEY);\n-                          }\n-                          else {\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.NEXT, TraversalMethod.KEY);\n-                          }\n-                          event.consume();\n-                          break;\n-                      case UP :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.UP, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case DOWN :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.DOWN, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case LEFT :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case RIGHT :\n-                          NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n-                          event.consume();\n-                          break;\n-                      case ENTER :\n-                          setExternalFocus(false);\n-                          event.consume();\n-                          break;\n-                      default :\n-                          \/\/ this'll kill mnemonics.... unless!\n-                          Scene s = tlNode.getScene();\n-                          Event.fireEvent(s, event);\n-                          event.consume();\n-                          break;\n+                    switch (ev.getCode()) {\n+                    case TAB:\n+                        if (ev.isShiftDown()) {\n+                            traverse(obj, TraversalDirectionInternal.PREVIOUS);\n+                        } else {\n+                            traverse(obj, TraversalDirectionInternal.NEXT);\n+                        }\n+                        event.consume();\n+                        break;\n+                    case UP:\n+                        traverse(obj, TraversalDirectionInternal.UP);\n+                        event.consume();\n+                        break;\n+                    case DOWN:\n+                        traverse(obj, TraversalDirectionInternal.DOWN);\n+                        event.consume();\n+                        break;\n+                    case LEFT:\n+                        traverse(obj, TraversalDirectionInternal.LEFT);\n+                        event.consume();\n+                        break;\n+                    case RIGHT:\n+                        traverse(obj, TraversalDirectionInternal.RIGHT);\n+                        event.consume();\n+                        break;\n+                    case ENTER:\n+                        setExternalFocus(false);\n+                        event.consume();\n+                        break;\n+                    default:\n+                        \/\/ this'll kill mnemonics.... unless!\n+                        Scene s = tlNode.getScene();\n+                        Event.fireEvent(s, event);\n+                        event.consume();\n+                        break;\n@@ -152,2 +150,6 @@\n-        if (event instanceof KeyEvent && event.getEventType() == KeyEvent.KEY_PRESSED) {\n-            if (!((KeyEvent)event).isMetaDown() && !((KeyEvent)event).isControlDown()  && !((KeyEvent)event).isAltDown()) {\n+        if (event instanceof KeyEvent ev && event.getEventType() == KeyEvent.KEY_PRESSED) {\n+            if (\n+                !ev.isMetaDown() &&\n+                !ev.isControlDown() &&\n+                !ev.isAltDown())\n+            {\n@@ -161,43 +163,41 @@\n-                      case TAB :\n-                      case ENTER :\n-                          event.consume();\n-                          break;\n-                      case UP :\n-                      case DOWN :\n-                          break;\n-                      case LEFT :\n-                          if (obj instanceof Node) {\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n-                              event.consume();\n-                          }\n-                          else if (obj instanceof Scene) {\n-                              Node node = ((Scene)obj).getFocusOwner();\n-                              if (node != null) {\n-                                  NodeHelper.traverse(node, com.sun.javafx.scene.traversal.Direction.LEFT, TraversalMethod.KEY);\n-                                  event.consume();\n-                              }\n-                          }\n-                          break;\n-                      case RIGHT :\n-                          if (obj instanceof Node) {\n-                              NodeHelper.traverse((Node) obj, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n-                              event.consume();\n-                          }\n-                          else if (obj instanceof Scene) {\n-                              Node node = ((Scene)obj).getFocusOwner();\n-                              if (node != null) {\n-                                  NodeHelper.traverse(node, com.sun.javafx.scene.traversal.Direction.RIGHT, TraversalMethod.KEY);\n-                                  event.consume();\n-                              }\n-                          }\n-                          break;\n-\n-                      default :\n-                          \/\/ this'll kill mnemonics.... unless!\n-                          Scene s = null;\n-                          if (tlNode != null) {\n-                              s = tlNode.getScene();\n-                              Event.fireEvent(s, event);\n-                          }\n-                          event.consume();\n-                          break;\n+                    case TAB:\n+                    case ENTER:\n+                        event.consume();\n+                        break;\n+                    case UP:\n+                    case DOWN:\n+                        break;\n+                    case LEFT:\n+                        if (obj instanceof Node n) {\n+                            traverse(n, TraversalDirectionInternal.LEFT);\n+                            event.consume();\n+                        } else if (obj instanceof Scene sc) {\n+                            Node node = sc.getFocusOwner();\n+                            if (node != null) {\n+                                traverse(node, TraversalDirectionInternal.LEFT);\n+                                event.consume();\n+                            }\n+                        }\n+                        break;\n+                    case RIGHT:\n+                        if (obj instanceof Node n) {\n+                            traverse(n, TraversalDirectionInternal.RIGHT);\n+                            event.consume();\n+                        } else if (obj instanceof Scene sc) {\n+                            Node node = sc.getFocusOwner();\n+                            if (node != null) {\n+                                traverse(node, TraversalDirectionInternal.RIGHT);\n+                                event.consume();\n+                            }\n+                        }\n+                        break;\n+\n+                    default:\n+                        \/\/ this'll kill mnemonics.... unless!\n+                        Scene s = null;\n+                        if (tlNode != null) {\n+                            s = tlNode.getScene();\n+                            Event.fireEvent(s, event);\n+                        }\n+                        event.consume();\n+                        break;\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/behavior\/TwoLevelFocusPopupBehavior.java","additions":94,"deletions":94,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import com.sun.javafx.scene.ParentHelper;\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n-\n@@ -37,0 +34,2 @@\n+import javafx.css.PseudoClass;\n+import javafx.css.StyleableProperty;\n@@ -42,2 +41,0 @@\n-import javafx.css.PseudoClass;\n-\n@@ -45,2 +42,2 @@\n-\n-import javafx.css.StyleableProperty;\n+import com.sun.javafx.scene.traversal.OverridableTraversalPolicy;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -213,0 +210,1 @@\n+                private final OverridableTraversalPolicy policy = new OverridableTraversalPolicy();\n@@ -214,2 +212,3 @@\n-                private ChangeListener<Toggle> listener = (o, oV, nV) ->\n-                    ParentHelper.getTraversalEngine(ToggleButton.this).setOverriddenFocusTraversability(nV != null ? isSelected() : null);\n+                private ChangeListener<Toggle> listener = (o, oV, nV) -> {\n+                    policy.setOverriddenFocusTraversability(nV != null ? isSelected() : null);\n+                };\n@@ -224,2 +223,1 @@\n-                        final ParentTraversalEngine parentTraversalEngine = new ParentTraversalEngine(ToggleButton.this);\n-                        ParentHelper.setTraversalEngine(ToggleButton.this, parentTraversalEngine);\n+                        TraversalUtils.setTraversalPolicy(ToggleButton.this, policy);\n@@ -227,1 +225,1 @@\n-                        parentTraversalEngine.setOverriddenFocusTraversability(tg.getSelectedToggle() != null ? isSelected() : null);\n+                        policy.setOverriddenFocusTraversability(tg.getSelectedToggle() != null ? isSelected() : null);\n@@ -232,1 +230,1 @@\n-                        ParentHelper.setTraversalEngine(ToggleButton.this, null);\n+                        TraversalUtils.setTraversalPolicy(ToggleButton.this, null);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/ToggleButton.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,8 +28,2 @@\n-import com.sun.javafx.scene.NodeHelper;\n-import com.sun.javafx.scene.ParentHelper;\n-import com.sun.javafx.scene.control.CustomColorDialog;\n-import com.sun.javafx.scene.control.skin.Utils;\n-import com.sun.javafx.scene.traversal.Algorithm;\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n-import com.sun.javafx.scene.traversal.TraversalContext;\n+import static com.sun.javafx.scene.control.Properties.getColorPickerString;\n+import java.util.List;\n@@ -47,0 +41,1 @@\n+import javafx.scene.Parent;\n@@ -66,4 +61,6 @@\n-\n-import java.util.List;\n-\n-import static com.sun.javafx.scene.control.Properties.getColorPickerString;\n+import com.sun.javafx.scene.NodeHelper;\n+import com.sun.javafx.scene.control.CustomColorDialog;\n+import com.sun.javafx.scene.control.skin.Utils;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n+import com.sun.javafx.scene.traversal.TraversalPolicy;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -302,1 +299,1 @@\n-        ParentHelper.setTraversalEngine(this, new ParentTraversalEngine(this, new Algorithm() {\n+        TraversalUtils.setTraversalPolicy(this, new TraversalPolicy() {\n@@ -304,2 +301,2 @@\n-            public Node select(Node owner, Direction dir, TraversalContext context) {\n-                final Node subsequentNode = context.selectInSubtree(context.getRoot(), owner, dir);\n+            public Node select(Parent root, Node owner, TraversalDirectionInternal dir) {\n+                final Node subsequentNode = TraversalPolicy.getDefault().select(root, owner, dir);\n@@ -329,1 +326,1 @@\n-            private Node processArrow(ColorSquare owner, Direction dir) {\n+            private Node processArrow(ColorSquare owner, TraversalDirectionInternal dir) {\n@@ -358,1 +355,1 @@\n-                                subsequentColumn = (dir == Direction.LEFT)? NUM_OF_COLUMNS - 1 : 0;\n+                                subsequentColumn = (dir == TraversalDirectionInternal.LEFT)? NUM_OF_COLUMNS - 1 : 0;\n@@ -361,2 +358,2 @@\n-                                subsequentRow = Math.floorMod(dir == Direction.LEFT ? row - 1 : row + 1, customColorRows);\n-                                subsequentColumn = dir == Direction.LEFT ? subsequentRow == customColorRows - 1 ?\n+                                subsequentRow = Math.floorMod(dir == TraversalDirectionInternal.LEFT ? row - 1 : row + 1, customColorRows);\n+                                subsequentColumn = dir == TraversalDirectionInternal.LEFT ? subsequentRow == customColorRows - 1 ?\n@@ -365,2 +362,2 @@\n-                                subsequentRow = Math.floorMod(dir == Direction.LEFT ? row - 1 : row + 1, NUM_OF_ROWS);\n-                                subsequentColumn = dir == Direction.LEFT ? NUM_OF_COLUMNS - 1 : 0;\n+                                subsequentRow = Math.floorMod(dir == TraversalDirectionInternal.LEFT ? row - 1 : row + 1, NUM_OF_ROWS);\n+                                subsequentColumn = dir == TraversalDirectionInternal.LEFT ? NUM_OF_COLUMNS - 1 : 0;\n@@ -396,1 +393,1 @@\n-            private boolean isAtBorder(Direction dir, int row, int column, boolean custom) {\n+            private boolean isAtBorder(TraversalDirectionInternal dir, int row, int column, boolean custom) {\n@@ -412,1 +409,1 @@\n-            public Node selectFirst(TraversalContext context) {\n+            public Node selectFirst(Parent root) {\n@@ -417,1 +414,1 @@\n-            public Node selectLast(TraversalContext context) {\n+            public Node selectLast(Parent root) {\n@@ -420,1 +417,1 @@\n-        }));\n+        });\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ColorPalette.java","additions":22,"deletions":25,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import com.sun.javafx.scene.ParentHelper;\n@@ -56,4 +55,1 @@\n-import com.sun.javafx.scene.traversal.Algorithm;\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n-import com.sun.javafx.scene.traversal.TraversalContext;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -194,15 +190,1 @@\n-        ParentHelper.setTraversalEngine(comboBoxBase,\n-                new ParentTraversalEngine(comboBoxBase, new Algorithm() {\n-\n-            @Override public Node select(Node owner, Direction dir, TraversalContext context) {\n-                return null;\n-            }\n-\n-            @Override public Node selectFirst(TraversalContext context) {\n-                return null;\n-            }\n-\n-            @Override public Node selectLast(TraversalContext context) {\n-                return null;\n-            }\n-        }));\n+        TraversalUtils.setTraversalPolicy(comboBoxBase, TraversalUtils.EMPTY_POLICY);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ComboBoxPopupControl.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-\n@@ -83,1 +82,0 @@\n-\n@@ -86,1 +84,0 @@\n-import com.sun.javafx.scene.ParentHelper;\n@@ -92,2 +89,1 @@\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n@@ -277,3 +273,4 @@\n-        ParentTraversalEngine engine = new ParentTraversalEngine(getSkinnable());\n-        engine.addTraverseListener((node, bounds) -> {\n-            if (openMenu != null) openMenu.hide();\n+        lh.addSceneFocusOwnerListener(control, (n) -> {\n+            if (openMenu != null) {\n+                openMenu.hide();\n+            }\n@@ -282,1 +279,0 @@\n-        ParentHelper.setTraversalEngine(getSkinnable(), engine);\n@@ -303,1 +299,1 @@\n-                                        moveToMenu(Direction.NEXT, false); \/\/ just move the selection bar\n+                                        moveToMenu(TraversalDirectionInternal.NEXT, false); \/\/ just move the selection bar\n@@ -305,1 +301,1 @@\n-                                        moveToMenu(Direction.PREVIOUS, false); \/\/ just move the selection bar\n+                                        moveToMenu(TraversalDirectionInternal.PREVIOUS, false); \/\/ just move the selection bar\n@@ -311,1 +307,1 @@\n-                                    moveToMenu(Direction.NEXT, true);\n+                                    moveToMenu(TraversalDirectionInternal.NEXT, true);\n@@ -313,1 +309,1 @@\n-                                    moveToMenu(Direction.PREVIOUS, true);\n+                                    moveToMenu(TraversalDirectionInternal.PREVIOUS, true);\n@@ -324,1 +320,1 @@\n-                                        moveToMenu(Direction.PREVIOUS, false); \/\/ just move the selection bar\n+                                        moveToMenu(TraversalDirectionInternal.PREVIOUS, false); \/\/ just move the selection bar\n@@ -326,1 +322,1 @@\n-                                        moveToMenu(Direction.NEXT, false); \/\/ just move the selection bar\n+                                        moveToMenu(TraversalDirectionInternal.NEXT, false); \/\/ just move the selection bar\n@@ -332,1 +328,1 @@\n-                                    moveToMenu(Direction.PREVIOUS, true);\n+                                    moveToMenu(TraversalDirectionInternal.PREVIOUS, true);\n@@ -334,1 +330,1 @@\n-                                    moveToMenu(Direction.NEXT, true);\n+                                    moveToMenu(TraversalDirectionInternal.NEXT, true);\n@@ -1079,1 +1075,1 @@\n-    private void moveToMenu(Direction dir, boolean doShow) {\n+    private void moveToMenu(TraversalDirectionInternal dir, boolean doShow) {\n@@ -1092,1 +1088,1 @@\n-    private Optional<Pair<Menu,Integer>> findSibling(Direction dir, int startIndex) {\n+    private Optional<Pair<Menu,Integer>> findSibling(TraversalDirectionInternal dir, int startIndex) {\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/MenuBarSkin.java","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-\n@@ -62,1 +61,0 @@\n-\n@@ -64,1 +62,0 @@\n-import com.sun.javafx.scene.ParentHelper;\n@@ -69,1 +66,1 @@\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -635,7 +632,0 @@\n-        ParentTraversalEngine traversalEngine = new ParentTraversalEngine(getSkinnable());\n-        traversalEngine.addTraverseListener((node, bounds) -> {\n-            \/\/ auto-scroll so node is within (0,0),(contentWidth,contentHeight)\n-            scrollBoundsIntoView(bounds);\n-        });\n-        ParentHelper.setTraversalEngine(getSkinnable(), traversalEngine);\n-\n@@ -673,0 +663,8 @@\n+        lh.addSceneFocusOwnerListener(control, (n) -> {\n+            \/\/ auto-scroll node to view\n+            Bounds b = TraversalUtils.getLayoutBounds(n, control);\n+            if (b != null) {\n+                scrollBoundsIntoView(b);\n+            }\n+        });\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ScrollPaneSkin.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-\n@@ -34,1 +33,0 @@\n-import javafx.scene.Node;\n@@ -43,2 +41,0 @@\n-\n-import com.sun.javafx.scene.ParentHelper;\n@@ -48,4 +44,1 @@\n-import com.sun.javafx.scene.traversal.Algorithm;\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n-import com.sun.javafx.scene.traversal.TraversalContext;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -236,19 +229,0 @@\n-        \/\/ Following code borrowed from ComboBoxPopupControl, to resolve the\n-        \/\/ issue initially identified in RT-36902, but specifically (for Spinner)\n-        \/\/ identified in RT-40625\n-        ParentHelper.setTraversalEngine(control,\n-                new ParentTraversalEngine(control, new Algorithm() {\n-\n-            @Override public Node select(Node owner, Direction dir, TraversalContext context) {\n-                return null;\n-            }\n-\n-            @Override public Node selectFirst(TraversalContext context) {\n-                return null;\n-            }\n-\n-            @Override public Node selectLast(TraversalContext context) {\n-                return null;\n-            }\n-        }));\n-\n@@ -277,0 +251,5 @@\n+\n+        \/\/ Following code borrowed from ComboBoxPopupControl, to resolve the\n+        \/\/ issue initially identified in RT-36902, but specifically (for Spinner)\n+        \/\/ identified in RT-40625\n+        TraversalUtils.setTraversalPolicy(getSkinnable(), TraversalUtils.EMPTY_POLICY);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/SpinnerSkin.java","additions":6,"deletions":27,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import com.sun.javafx.scene.NodeHelper;\n-import com.sun.javafx.scene.ParentHelper;\n+import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;\n@@ -33,6 +32,0 @@\n-\n-import com.sun.javafx.scene.control.behavior.BehaviorBase;\n-import com.sun.javafx.scene.traversal.Algorithm;\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n-import com.sun.javafx.scene.traversal.TraversalContext;\n-\n@@ -40,1 +33,0 @@\n-import javafx.beans.property.ObjectProperty;\n@@ -42,0 +34,1 @@\n+import javafx.beans.property.ObjectProperty;\n@@ -46,0 +39,1 @@\n+import javafx.css.CssMetaData;\n@@ -47,0 +41,6 @@\n+import javafx.css.Styleable;\n+import javafx.css.StyleableDoubleProperty;\n+import javafx.css.StyleableObjectProperty;\n+import javafx.css.StyleableProperty;\n+import javafx.css.converter.EnumConverter;\n+import javafx.css.converter.SizeConverter;\n@@ -59,1 +59,0 @@\n-import javafx.scene.control.MenuItem;\n@@ -61,0 +60,1 @@\n+import javafx.scene.control.MenuItem;\n@@ -70,11 +70,0 @@\n-import javafx.css.StyleableDoubleProperty;\n-import javafx.css.StyleableObjectProperty;\n-import javafx.css.StyleableProperty;\n-import javafx.css.CssMetaData;\n-\n-import javafx.css.converter.EnumConverter;\n-import javafx.css.converter.SizeConverter;\n-import com.sun.javafx.scene.control.behavior.ToolBarBehavior;\n-import com.sun.javafx.scene.traversal.Direction;\n-\n-import javafx.css.Styleable;\n@@ -82,2 +71,6 @@\n-\n-import static com.sun.javafx.scene.control.skin.resources.ControlResources.getString;\n+import com.sun.javafx.scene.NodeHelper;\n+import com.sun.javafx.scene.control.behavior.BehaviorBase;\n+import com.sun.javafx.scene.control.behavior.ToolBarBehavior;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n+import com.sun.javafx.scene.traversal.TraversalPolicy;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -114,1 +107,0 @@\n-    private final ParentTraversalEngine engine;\n@@ -142,3 +134,2 @@\n-        engine = new ParentTraversalEngine(getSkinnable(), new Algorithm() {\n-\n-            private Node selectPrev(int from, TraversalContext context) {\n+        TraversalUtils.setTraversalPolicy(getSkinnable(), new TraversalPolicy() {\n+            private Node selectPrev(int from, Parent root) {\n@@ -148,2 +139,2 @@\n-                    if (n instanceof Parent) {\n-                        Node selected = context.selectLastInParent((Parent)n);\n+                    if (n instanceof Parent p) {\n+                        Node selected = TraversalPolicy.getDefault().selectLast(p);\n@@ -159,1 +150,1 @@\n-            private Node selectNext(int from, TraversalContext context) {\n+            private Node selectNext(int from, Parent root) {\n@@ -166,2 +157,2 @@\n-                    if (n instanceof Parent) {\n-                        Node selected = context.selectFirstInParent((Parent)n);\n+                    if (n instanceof Parent p) {\n+                        Node selected = TraversalPolicy.getDefault().selectFirst(p);\n@@ -175,1 +166,1 @@\n-            public Node select(Node owner, Direction dir, TraversalContext context) {\n+            public Node select(Parent root, Node owner, TraversalDirectionInternal dir) {\n@@ -184,1 +175,1 @@\n-                        Node selected = selectPrev(boxChildren.size() - 1, context);\n+                        Node selected = selectPrev(boxChildren.size() - 1, root);\n@@ -197,1 +188,1 @@\n-                    Node selected = context.selectInSubtree(item, owner, dir);\n+                    Node selected = TraversalPolicy.getDefault().select(item, owner, dir);\n@@ -200,1 +191,3 @@\n-                    if (dir == Direction.NEXT) dir = Direction.NEXT_IN_LINE;\n+                    if (dir == TraversalDirectionInternal.NEXT) {\n+                        dir = TraversalDirectionInternal.NEXT_IN_LINE;\n+                    }\n@@ -205,1 +198,1 @@\n-                        Node selected = selectNext(idx + 1, context);\n+                        Node selected = selectNext(idx + 1, root);\n@@ -212,1 +205,1 @@\n-                        Node selected = selectPrev(idx - 1, context);\n+                        Node selected = selectPrev(idx - 1, root);\n@@ -220,2 +213,2 @@\n-            public Node selectFirst(TraversalContext context) {\n-                Node selected = selectNext(0, context);\n+            public Node selectFirst(Parent root) {\n+                Node selected = selectNext(0, root);\n@@ -230,1 +223,1 @@\n-            public Node selectLast(TraversalContext context) {\n+            public Node selectLast(Parent root) {\n@@ -234,1 +227,1 @@\n-                return selectPrev(box.getChildren().size() - 1, context);\n+                return selectPrev(box.getChildren().size() - 1, root);\n@@ -237,1 +230,0 @@\n-        ParentHelper.setTraversalEngine(getSkinnable(), engine);\n@@ -639,4 +631,1 @@\n-                        Node last = engine.selectLast();\n-                        if (last != null) {\n-                            last.requestFocus();\n-                        }\n+                        selectAndFocusLast();\n@@ -654,1 +643,10 @@\n-            Node last = engine.selectLast();\n+            selectAndFocusLast();\n+        }\n+        overflowMenu.setVisible(overflow);\n+        overflowMenu.setManaged(overflow);\n+    }\n+\n+    private void selectAndFocusLast() {\n+        TraversalPolicy p = TraversalUtils.getTraversalPolicy(getSkinnable());\n+        if (p != null) {\n+            Node last = p.selectLast(getSkinnable());\n@@ -659,2 +657,0 @@\n-        overflowMenu.setVisible(overflow);\n-        overflowMenu.setManaged(overflow);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/ToolBarSkin.java","additions":46,"deletions":50,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -28,9 +28,4 @@\n-import com.sun.javafx.scene.ParentHelper;\n-import com.sun.javafx.scene.control.Logging;\n-import com.sun.javafx.scene.control.Properties;\n-import com.sun.javafx.scene.control.VirtualScrollBar;\n-import com.sun.javafx.scene.control.skin.Utils;\n-import com.sun.javafx.scene.traversal.Algorithm;\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n-import com.sun.javafx.scene.traversal.TraversalContext;\n+import java.util.AbstractList;\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.List;\n@@ -71,5 +66,7 @@\n-\n-import java.util.AbstractList;\n-import java.util.ArrayList;\n-import java.util.BitSet;\n-import java.util.List;\n+import com.sun.javafx.scene.control.Logging;\n+import com.sun.javafx.scene.control.Properties;\n+import com.sun.javafx.scene.control.VirtualScrollBar;\n+import com.sun.javafx.scene.control.skin.Utils;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n+import com.sun.javafx.scene.traversal.TraversalPolicy;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -633,3 +630,2 @@\n-        ParentHelper.setTraversalEngine(this, new ParentTraversalEngine(this, new Algorithm() {\n-\n-            Node selectNextAfterIndex(int index, TraversalContext context) {\n+        TraversalUtils.setTraversalPolicy(this, new TraversalPolicy() {\n+            Node selectNextAfterIndex(int index, Parent root) {\n@@ -641,1 +637,1 @@\n-                    Node n = context.selectFirstInParent(nextCell);\n+                    Node n = TraversalPolicy.getDefault().selectFirst(nextCell);\n@@ -649,1 +645,1 @@\n-            Node selectPreviousBeforeIndex(int index, TraversalContext context) {\n+            Node selectPreviousBeforeIndex(int index, Parent root) {\n@@ -652,1 +648,1 @@\n-                    Node prev = context.selectLastInParent(prevCell);\n+                    Node prev = TraversalPolicy.getDefault().selectLast(prevCell);\n@@ -664,1 +660,1 @@\n-            public Node select(Node owner, Direction dir, TraversalContext context) {\n+            public Node select(Parent root, Node owner, TraversalDirectionInternal dir) {\n@@ -671,1 +667,1 @@\n-                    Node next = context.selectInSubtree(cell, owner, dir);\n+                    Node next = TraversalPolicy.getDefault().select(cell, owner, dir);\n@@ -675,1 +671,1 @@\n-                    if (dir == Direction.NEXT) dir = Direction.NEXT_IN_LINE;\n+                    if (dir == TraversalDirectionInternal.NEXT) dir = TraversalDirectionInternal.NEXT_IN_LINE;\n@@ -680,1 +676,1 @@\n-                        return selectPreviousBeforeIndex(cellIndex, context);\n+                        return selectPreviousBeforeIndex(cellIndex, root);\n@@ -682,1 +678,1 @@\n-                        Node n = context.selectFirstInParent(cell);\n+                        Node n = TraversalPolicy.getDefault().selectFirst(cell);\n@@ -688,1 +684,1 @@\n-                        return selectNextAfterIndex(cellIndex, context);\n+                        return selectNextAfterIndex(cellIndex, root);\n@@ -702,1 +698,1 @@\n-            public Node selectFirst(TraversalContext context) {\n+            public Node selectFirst(Parent root) {\n@@ -706,1 +702,1 @@\n-                Node n = context.selectFirstInParent(firstCell);\n+                Node n = TraversalPolicy.getDefault().selectFirst(firstCell);\n@@ -710,1 +706,1 @@\n-                return selectNextAfterIndex(firstCell.getIndex(), context);\n+                return selectNextAfterIndex(firstCell.getIndex(), root);\n@@ -714,1 +710,1 @@\n-            public Node selectLast(TraversalContext context) {\n+            public Node selectLast(Parent root) {\n@@ -717,1 +713,1 @@\n-                Node p = context.selectLastInParent(lastCell);\n+                Node p = TraversalPolicy.getDefault().selectLast(lastCell);\n@@ -722,1 +718,1 @@\n-                return selectPreviousBeforeIndex(lastCell.getIndex(), context);\n+                return selectPreviousBeforeIndex(lastCell.getIndex(), root);\n@@ -724,1 +720,1 @@\n-        }));\n+        });\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/VirtualFlow.java","additions":29,"deletions":33,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-\n-import com.sun.javafx.scene.traversal.Direction;\n@@ -37,0 +35,1 @@\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n@@ -115,1 +114,1 @@\n-    public boolean traverseOut(Direction dir);\n+    public boolean traverseOut(TraversalDirectionInternal dir);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/embed\/EmbeddedSceneInterface.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,0 @@\n-\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -46,1 +44,0 @@\n-\n@@ -51,1 +48,2 @@\n-import com.sun.javafx.scene.traversal.Direction;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -102,2 +100,2 @@\n-    private void traverse(Event event, Node node, Direction dir) {\n-        if (NodeHelper.traverse(node, dir, TraversalMethod.KEY)) {\n+    private void traverse(Event event, Node node, TraversalDirectionInternal dir) {\n+        if (TraversalUtils.traverse(node, dir, true)) {\n@@ -121,1 +119,1 @@\n-                      traverse(event, node, Direction.PREVIOUS);\n+                      traverse(event, node, TraversalDirectionInternal.PREVIOUS);\n@@ -124,1 +122,1 @@\n-                      traverse(event, node, Direction.NEXT);\n+                      traverse(event, node, TraversalDirectionInternal.NEXT);\n@@ -128,1 +126,1 @@\n-                  traverse(event, node, Direction.UP);\n+                  traverse(event, node, TraversalDirectionInternal.UP);\n@@ -131,1 +129,1 @@\n-                  traverse(event, node, Direction.DOWN);\n+                  traverse(event, node, TraversalDirectionInternal.DOWN);\n@@ -134,1 +132,1 @@\n-                  traverse(event, node, Direction.LEFT);\n+                  traverse(event, node, TraversalDirectionInternal.LEFT);\n@@ -137,1 +135,1 @@\n-                  traverse(event, node, Direction.RIGHT);\n+                  traverse(event, node, TraversalDirectionInternal.RIGHT);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/KeyboardShortcutsHandler.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,11 +28,0 @@\n-import com.sun.glass.ui.Accessible;\n-import com.sun.javafx.css.TransitionDefinition;\n-import com.sun.javafx.css.TransitionTimer;\n-import com.sun.javafx.geom.BaseBounds;\n-import com.sun.javafx.geom.PickRay;\n-import com.sun.javafx.geom.transform.BaseTransform;\n-import com.sun.javafx.scene.input.PickResultChooser;\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n-import com.sun.javafx.sg.prism.NGNode;\n-import com.sun.javafx.util.Utils;\n@@ -53,0 +42,9 @@\n+import com.sun.glass.ui.Accessible;\n+import com.sun.javafx.css.TransitionDefinition;\n+import com.sun.javafx.css.TransitionTimer;\n+import com.sun.javafx.geom.BaseBounds;\n+import com.sun.javafx.geom.PickRay;\n+import com.sun.javafx.geom.transform.BaseTransform;\n+import com.sun.javafx.scene.input.PickResultChooser;\n+import com.sun.javafx.sg.prism.NGNode;\n+import com.sun.javafx.util.Utils;\n@@ -239,4 +237,0 @@\n-    public static boolean traverse(Node node, Direction direction, TraversalMethod method) {\n-        return nodeAccessor.traverse(node, direction, method);\n-    }\n-\n@@ -381,1 +375,0 @@\n-        boolean traverse(Node node, Direction direction, TraversalMethod method);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/NodeHelper.java","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.util.List;\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n@@ -32,1 +35,1 @@\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n+import com.sun.javafx.scene.traversal.TraversalPolicy;\n@@ -35,3 +38,0 @@\n-import java.util.List;\n-import javafx.scene.Node;\n-import javafx.scene.Parent;\n@@ -116,8 +116,0 @@\n-    public static void setTraversalEngine(Parent parent, ParentTraversalEngine value) {\n-        parentAccessor.setTraversalEngine(parent, value);\n-    }\n-\n-    public static ParentTraversalEngine getTraversalEngine(Parent parent) {\n-        return parentAccessor.getTraversalEngine(parent);\n-    }\n-\n@@ -132,0 +124,8 @@\n+    public static TraversalPolicy getTraversalPolicy(Parent parent) {\n+        return parentAccessor.getTraversalPolicy(parent);\n+    }\n+\n+    public static void setTraversalPolicy(Parent parent, TraversalPolicy policy) {\n+        parentAccessor.setTraversalPolicy(parent, policy);\n+    }\n+\n@@ -140,2 +140,0 @@\n-        void setTraversalEngine(Parent parent, ParentTraversalEngine value);\n-        ParentTraversalEngine getTraversalEngine(Parent parent);\n@@ -143,0 +141,2 @@\n+        public TraversalPolicy getTraversalPolicy(Parent parent);\n+        public void setTraversalPolicy(Parent parent, TraversalPolicy policy);\n@@ -144,1 +144,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/ParentHelper.java","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import com.sun.glass.ui.Accessible;\n-import com.sun.javafx.tk.TKScene;\n-import com.sun.javafx.util.Utils;\n@@ -38,0 +35,3 @@\n+import com.sun.glass.ui.Accessible;\n+import com.sun.javafx.tk.TKScene;\n+import com.sun.javafx.util.Utils;\n@@ -147,1 +147,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/SceneHelper.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.scene.traversal;\n-\n-import javafx.scene.Node;\n-\n-\/**\n- * An algorithm to be used in a traversal engine.\n- *\n- * Note that in order to avoid cycles or dead-ends in traversal the algorithms should respect the following order:\n- * * for NEXT: node -> node's subtree -> node siblings (first sibling then it's subtree) -> NEXT_IN_LINE for node's parent\n- * * for NEXT_IN_LINE: node -> node siblings (first sibling then it's subtree) -> NEXT_IN_LINE for node's parent\n- * * for PREVIOUS: node -> node siblings ( ! first subtree then the node itself ! ) -> PREVIOUS for node's parent\n- *\n- * Basically it ensures that next direction will traverse the same nodes as previous, in the opposite order.\n- *\n- *\/\n-public interface Algorithm {\n-\n-    \/**\n-     * Traverse from owner, in direction dir.\n-     * Return a the new target Node or null if no suitable target is found.\n-     *\n-     * Typically, the implementation of override algorithm handles only parent's direct children and looks like this:\n-     * 1) Find the nearest parent of the \"owner\" that is handled by this algorithm (i.e. it's a direct child of the root).\n-     * 2) select the next node within this direct child using the context.selectInSubtree() and return it\n-     * 2a) if no such node exists, move to the next direct child in the direction (this is where the different order of direct children is defined)\n-     *     or if direct children are not traversable, the select the first node in the next direct child\n-     *\/\n-    public Node select(Node owner, Direction dir, TraversalContext context);\n-\n-    \/**\n-     * Return the first traversable node for the specified context (root).\n-     * @param context the context that contains the root\n-     * @return the first node\n-     *\/\n-    public Node selectFirst(TraversalContext context);\n-\n-    \/**\n-     * Return the last traversable node for the specified context (root).\n-     * @param context the context that contains the root\n-     * @return the last node\n-     *\/\n-    public Node selectLast(TraversalContext context);\n-\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/Algorithm.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import javafx.scene.Parent;\n@@ -32,3 +33,1 @@\n-import static com.sun.javafx.scene.traversal.Direction.*;\n-\n-public class ContainerTabOrder implements Algorithm {\n+public class ContainerTabOrder extends TraversalPolicy {\n@@ -40,1 +39,1 @@\n-    public Node select(Node node, Direction dir, TraversalContext context) {\n+    public Node select(Parent root, Node node, TraversalDirectionInternal dir) {\n@@ -43,0 +42,1 @@\n+                return findNextFocusableNode(root, node);\n@@ -44,1 +44,1 @@\n-                return TabOrderHelper.findNextFocusablePeer(node, context.getRoot(), dir == NEXT);\n+                return findNextInLineFocusableNode(root, node);\n@@ -46,1 +46,1 @@\n-                return TabOrderHelper.findPreviousFocusablePeer(node, context.getRoot());\n+                return findPreviousFocusableNode(root, node);\n@@ -51,3 +51,2 @@\n-                List<Node> nodes = context.getAllTargetNodes();\n-\n-                int target = trav2D(context.getSceneLayoutBounds(node), dir, nodes, context);\n+                List<Node> nodes = TraversalUtils.getAllTargetNodes(root);\n+                int target = trav2D(TraversalUtils.getLayoutBoundsInSceneCoordinates(node), dir, nodes, root);\n@@ -62,2 +61,2 @@\n-    public Node selectFirst(TraversalContext context) {\n-        return TabOrderHelper.getFirstTargetNode(context.getRoot());\n+    public Node selectFirst(Parent root) {\n+        return TabOrderHelper.getFirstTargetNode(root);\n@@ -67,2 +66,2 @@\n-    public Node selectLast(TraversalContext context) {\n-        return TabOrderHelper.getLastTargetNode(context.getRoot());\n+    public Node selectLast(Parent root) {\n+        return TabOrderHelper.getLastTargetNode(root);\n@@ -71,1 +70,1 @@\n-    private int trav2D(Bounds origin, Direction dir, List<Node> peers, TraversalContext context) {\n+    private int trav2D(Bounds origin, TraversalDirectionInternal dir, List<Node> peers, Parent root) {\n@@ -78,1 +77,1 @@\n-            final Bounds targetBounds = context.getSceneLayoutBounds(peers.get(i));\n+            final Bounds targetBounds = TraversalUtils.getLayoutBoundsInSceneCoordinates(peers.get(i));\n@@ -104,1 +103,1 @@\n-    private boolean isOnAxis(Direction dir, Bounds cur, Bounds tgt) {\n+    private boolean isOnAxis(TraversalDirectionInternal dir, Bounds cur, Bounds tgt) {\n@@ -108,1 +107,1 @@\n-        if (dir == UP || dir == DOWN) {\n+        if (dir == TraversalDirectionInternal.UP || dir == TraversalDirectionInternal.DOWN) {\n@@ -128,1 +127,1 @@\n-    private double outDistance(Direction dir, Bounds cur, Bounds tgt) {\n+    private double outDistance(TraversalDirectionInternal dir, Bounds cur, Bounds tgt) {\n@@ -132,1 +131,1 @@\n-        if (dir == UP) {\n+        if (dir == TraversalDirectionInternal.UP) {\n@@ -135,1 +134,1 @@\n-        else if (dir == DOWN) {\n+        else if (dir == TraversalDirectionInternal.DOWN) {\n@@ -138,1 +137,1 @@\n-        else if (dir == LEFT) {\n+        else if (dir == TraversalDirectionInternal.LEFT) {\n@@ -152,1 +151,1 @@\n-    private double centerSideDistance(Direction dir, Bounds cur, Bounds tgt) {\n+    private double centerSideDistance(TraversalDirectionInternal dir, Bounds cur, Bounds tgt) {\n@@ -157,1 +156,1 @@\n-        if (dir == UP || dir == DOWN) {\n+        if (dir == TraversalDirectionInternal.UP || dir == TraversalDirectionInternal.DOWN) {\n@@ -174,1 +173,1 @@\n-    private double cornerSideDistance(Direction dir, Bounds cur, Bounds tgt) {\n+    private double cornerSideDistance(TraversalDirectionInternal dir, Bounds cur, Bounds tgt) {\n@@ -178,1 +177,1 @@\n-        if (dir == UP || dir == DOWN) {\n+        if (dir == TraversalDirectionInternal.UP || dir == TraversalDirectionInternal.DOWN) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/ContainerTabOrder.java","additions":25,"deletions":26,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.scene.traversal;\n-\n-import javafx.geometry.NodeOrientation;\n-\n-\/**\n- * Specifies the direction of traversal.\n- *\/\n-public enum Direction {\n-\n-    UP(false),\n-    DOWN(true),\n-    LEFT(false),\n-    RIGHT(true),\n-    NEXT(true),\n-    NEXT_IN_LINE(true), \/\/ Like NEXT, but does not traverse into the current parent\n-    PREVIOUS(false);\n-    private final boolean forward;\n-\n-    Direction(boolean forward) {\n-        this.forward = forward;\n-    }\n-\n-    public boolean isForward() {\n-        return forward;\n-    }\n-\n-    \/**\n-     * Returns the direction with respect to the node's orientation. It affect's only arrow keys however, so it's not\n-     * an error to ignore this call if handling only next\/previous traversal.\n-     * @param orientation\n-     * @return\n-     *\/\n-    public Direction getDirectionForNodeOrientation(NodeOrientation orientation) {\n-        if (orientation == NodeOrientation.RIGHT_TO_LEFT) {\n-            switch (this) {\n-                case LEFT:\n-                    return RIGHT;\n-                case RIGHT:\n-                    return LEFT;\n-            }\n-        }\n-        return this;\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/Direction.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+import static com.sun.javafx.scene.traversal.TraversalDirectionInternal.DOWN;\n+import static com.sun.javafx.scene.traversal.TraversalDirectionInternal.LEFT;\n+import static com.sun.javafx.scene.traversal.TraversalDirectionInternal.NEXT;\n+import static com.sun.javafx.scene.traversal.TraversalDirectionInternal.NEXT_IN_LINE;\n+import static com.sun.javafx.scene.traversal.TraversalDirectionInternal.PREVIOUS;\n+import static com.sun.javafx.scene.traversal.TraversalDirectionInternal.RIGHT;\n+import static com.sun.javafx.scene.traversal.TraversalDirectionInternal.UP;\n@@ -30,0 +37,1 @@\n+import java.util.function.Function;\n@@ -34,0 +42,1 @@\n+import javafx.scene.Parent;\n@@ -35,3 +44,1 @@\n-import static com.sun.javafx.scene.traversal.Direction.*;\n-import java.util.function.Function;\n-\n+public class Heuristic2D extends TraversalPolicy {\n@@ -39,3 +46,1 @@\n-public class Hueristic2D implements Algorithm {\n-\n-    Hueristic2D() {\n+    Heuristic2D() {\n@@ -45,1 +50,2 @@\n-    public Node select(Node node, Direction dir, TraversalContext context) {\n+    public Node select(Parent root, Node node, TraversalDirectionInternal dir) {\n+        System.out.println(dir + \" node=\" + node);\n@@ -50,5 +56,6 @@\n-        if (NEXT.equals(dir) || NEXT_IN_LINE.equals(dir)) {\n-            newNode = TabOrderHelper.findNextFocusablePeer(node, context.getRoot(), dir == NEXT);\n-        }\n-        else if (PREVIOUS.equals(dir)) {\n-            newNode = TabOrderHelper.findPreviousFocusablePeer(node, context.getRoot());\n+        if (NEXT.equals(dir)) {\n+            newNode = findNextFocusableNode(root, node);\n+        } else if (NEXT_IN_LINE.equals(dir)) {\n+            newNode = findNextInLineFocusableNode(root, node);\n+        } else if (PREVIOUS.equals(dir)) {\n+            newNode = findPreviousFocusableNode(root, node);\n@@ -76,1 +83,1 @@\n-                            newNode = getNearestNodeUpOrDown(currentB, cachedB, context, dir);\n+                            newNode = getNearestNodeUpOrDown(currentB, cachedB, root, dir);\n@@ -80,1 +87,1 @@\n-                            newNode = getNearestNodeLeftOrRight(currentB, cachedB, context, dir);\n+                            newNode = getNearestNodeLeftOrRight(currentB, cachedB, root, dir);\n@@ -104,2 +111,2 @@\n-    public Node selectFirst(TraversalContext context) {\n-        return TabOrderHelper.getFirstTargetNode(context.getRoot());\n+    public Node selectFirst(Parent root) {\n+        return TabOrderHelper.getFirstTargetNode(root);\n@@ -109,2 +116,2 @@\n-    public Node selectLast(TraversalContext context) {\n-        return TabOrderHelper.getLastTargetNode(context.getRoot());\n+    public Node selectLast(Parent root) {\n+        return TabOrderHelper.getLastTargetNode(root);\n@@ -113,1 +120,1 @@\n-    private boolean isOnAxis(Direction dir, Bounds cur, Bounds tgt) {\n+    private boolean isOnAxis(TraversalDirectionInternal dir, Bounds cur, Bounds tgt) {\n@@ -137,1 +144,1 @@\n-    private double outDistance(Direction dir, Bounds cur, Bounds tgt) {\n+    private double outDistance(TraversalDirectionInternal dir, Bounds cur, Bounds tgt) {\n@@ -159,1 +166,1 @@\n-    private double centerSideDistance(Direction dir, Bounds cur, Bounds tgt) {\n+    private double centerSideDistance(TraversalDirectionInternal dir, Bounds cur, Bounds tgt) {\n@@ -178,1 +185,1 @@\n-    private double cornerSideDistance(Direction dir, Bounds cur, Bounds tgt) {\n+    private double cornerSideDistance(TraversalDirectionInternal dir, Bounds cur, Bounds tgt) {\n@@ -207,1 +214,1 @@\n-    protected Direction cacheStartTraversalDirection = null;\n+    protected TraversalDirectionInternal cacheStartTraversalDirection = null;\n@@ -212,1 +219,1 @@\n-    private void cacheTraversal(Node node, Direction dir) {\n+    private void cacheTraversal(Node node, TraversalDirectionInternal dir) {\n@@ -223,1 +230,1 @@\n-        if (dir == Direction.NEXT || dir == Direction.PREVIOUS) {\n+        if (dir == TraversalDirectionInternal.NEXT || dir == TraversalDirectionInternal.PREVIOUS) {\n@@ -259,1 +266,1 @@\n-    protected Node getNearestNodeUpOrDown(Bounds currentB, Bounds originB, TraversalContext context, Direction dir) {\n+    protected Node getNearestNodeUpOrDown(Bounds currentB, Bounds originB, Parent root, TraversalDirectionInternal dir) {\n@@ -261,1 +268,1 @@\n-        List<Node> nodes = context.getAllTargetNodes();\n+        List<Node> nodes = TraversalUtils.getAllTargetNodes(root);\n@@ -553,1 +560,1 @@\n-    protected Node getNearestNodeLeftOrRight(Bounds currentB, Bounds originB, TraversalContext context, Direction dir) {\n+    protected Node getNearestNodeLeftOrRight(Bounds currentB, Bounds originB, Parent root, TraversalDirectionInternal dir) {\n@@ -555,1 +562,1 @@\n-        List<Node> nodes = context.getAllTargetNodes();\n+        List<Node> nodes = TraversalUtils.getAllTargetNodes(root);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/Heuristic2D.java","additions":37,"deletions":30,"binary":false,"changes":67,"previous_filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/Hueristic2D.java","status":"renamed"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.javafx.scene.traversal;\n+\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+\n+\/**\n+ * Non-traversable policy which allows for overriding of {@link #isParentTraversable(Parent)}.\n+ *\/\n+public class OverridableTraversalPolicy extends TraversalPolicy {\n+    private Boolean overridenTraversability;\n+\n+    public OverridableTraversalPolicy() {\n+    }\n+\n+    @Override\n+    public Node select(Parent root, Node owner, TraversalDirectionInternal dir) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Node selectFirst(Parent root) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Node selectLast(Parent root) {\n+        return null;\n+    }\n+\n+    \/**\n+     * @param value overridden value or null for default value\n+     *\/\n+    public void setOverriddenFocusTraversability(Boolean value) {\n+        overridenTraversability = value;\n+    }\n+\n+    @Override\n+    public boolean isParentTraversable(Parent root) {\n+        \/\/ This means the traversability can be overriden only for traversable root.\n+        \/\/ If user explicitly disabled traversability, we don't set it back to true\n+        return overridenTraversability != null ?\n+            root.isFocusTraversable() && overridenTraversability :\n+            root.isFocusTraversable();\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/OverridableTraversalPolicy.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.scene.traversal;\n-\n-import javafx.scene.Parent;\n-\n-\/**\n- * This traversal engine can be used to change algorithm for some specific parent\/control that needs different traversal.\n- * This can be achieved by setting such engine using {@link Parent#setImpl_traversalEngine(ParentTraversalEngine)}\n- * and providing a special Algorithm implementation.\n- *\n- * Alternatively, the traversal engine can be w\/o an algorithm and used just for listening to focus changes inside the specified parent.\n- *\/\n-public final class ParentTraversalEngine extends TraversalEngine{\n-\n-    private final Parent root;\n-    private Boolean overridenTraversability;\n-\n-    public ParentTraversalEngine(Parent root, Algorithm algorithm) {\n-        super(algorithm);\n-        this.root = root;\n-    }\n-\n-    public ParentTraversalEngine(Parent root) {\n-        super();\n-        this.root = root;\n-    }\n-\n-    \/**\n-     * @param value overridden value or null for default value\n-     *\/\n-    public void setOverriddenFocusTraversability(Boolean value) {\n-        overridenTraversability = value;\n-    }\n-\n-    @Override\n-    protected Parent getRoot() {\n-        return root;\n-    }\n-\n-    public boolean isParentTraversable() {\n-        \/\/ This means the traversability can be overriden only for traversable root.\n-        \/\/ If user explicitly disabled traversability, we don't set it back to true\n-        return overridenTraversability != null ? root.isFocusTraversable() && overridenTraversability : root.isFocusTraversable();\n-    }\n-\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/ParentTraversalEngine.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.scene.traversal;\n-\n-import javafx.scene.Parent;\n-import javafx.scene.Scene;\n-\n-\/**\n- * Traversal engine for Scene.\n- *\/\n-public final class SceneTraversalEngine extends TopMostTraversalEngine{\n-\n-    private final Scene scene;\n-\n-    public SceneTraversalEngine(Scene scene) {\n-        this.scene = scene;\n-    }\n-\n-    @Override\n-    protected Parent getRoot() {\n-        return scene.getRoot();\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/SceneTraversalEngine.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.scene.traversal;\n-\n-import javafx.scene.Parent;\n-import javafx.scene.SubScene;\n-\n-\/**\n- * Traversal engine for subscene\n- *\/\n-public final class SubSceneTraversalEngine extends TopMostTraversalEngine{\n-\n-    private final SubScene subScene;\n-\n-    public SubSceneTraversalEngine(SubScene scene) {\n-        this.subScene = scene;\n-    }\n-\n-    @Override\n-    protected Parent getRoot() {\n-        return subScene.getRoot();\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/SubSceneTraversalEngine.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-import com.sun.javafx.scene.NodeHelper;\n-import com.sun.javafx.scene.ParentHelper;\n+import java.util.List;\n@@ -33,2 +32,1 @@\n-\n-import java.util.List;\n+import com.sun.javafx.scene.NodeHelper;\n@@ -40,7 +38,8 @@\n-            \/\/ ParentTraverEngine can override traversability, so we need to check it first\n-            if (isDisabledOrInvisible(prevNode)) continue;\n-            final ParentTraversalEngine traversalEngine = prevNode instanceof Parent\n-                    ? ParentHelper.getTraversalEngine((Parent) prevNode) : null;\n-            if (prevNode instanceof Parent) {\n-                if (traversalEngine != null && traversalEngine.canTraverse()) {\n-                    Node selected = traversalEngine.selectLast();\n+            \/\/ TraversalPolicy can override traversability, so we need to check it first\n+            if (isDisabledOrInvisible(prevNode)) {\n+                continue;\n+            }\n+            TraversalPolicy policy = prevNode instanceof Parent p ? TraversalUtils.getTraversalPolicy(p) : null;\n+            if (prevNode instanceof Parent p) {\n+                if (policy != null) {\n+                    Node selected = policy.selectLast(p);\n@@ -50,0 +49,3 @@\n+                    if (policy.isParentTraversable(p)) {\n+                        return prevNode;\n+                    }\n@@ -51,1 +53,1 @@\n-                    List<Node> prevNodesList = ((Parent) prevNode).getChildrenUnmodifiable();\n+                    List<Node> prevNodesList = p.getChildrenUnmodifiable();\n@@ -60,3 +62,1 @@\n-            if (traversalEngine != null\n-                    ? traversalEngine.isParentTraversable()\n-                    : prevNode.isFocusTraversable()) {\n+            if (prevNode.isFocusTraversable()) {\n@@ -100,3 +100,2 @@\n-                final ParentTraversalEngine parentEngine\n-                        = ParentHelper.getTraversalEngine(parent);\n-                if (parentEngine != null ? parentEngine.isParentTraversable() : parent.isFocusTraversable()) {\n+                TraversalPolicy policy = TraversalUtils.getTraversalPolicy(parent);\n+                if (policy != null ? policy.isParentTraversable(parent) : parent.isFocusTraversable()) {\n@@ -133,8 +132,2 @@\n-            if (isDisabledOrInvisible(nextNode)) continue;\n-            final ParentTraversalEngine traversalEngine = nextNode instanceof Parent\n-                    ? ParentHelper.getTraversalEngine((Parent) nextNode) : null;\n-            \/\/ ParentTraverEngine can override traversability, so we need to check it first\n-            if (traversalEngine != null\n-                    ? traversalEngine.isParentTraversable()\n-                    : nextNode.isFocusTraversable()) {\n-                return nextNode;\n+            if (isDisabledOrInvisible(nextNode)) {\n+                continue;\n@@ -142,3 +135,7 @@\n-            else if (nextNode instanceof Parent) {\n-                if (traversalEngine!= null && traversalEngine.canTraverse()) {\n-                    Node selected = traversalEngine.selectFirst();\n+            \/\/ TraversalPolicy can override traversability, so we need to check it first\n+            if (isParentTraversable(nextNode)) {\n+                return nextNode;\n+            } else if (nextNode instanceof Parent p) {\n+                TraversalPolicy policy = TraversalUtils.getTraversalPolicy(p);\n+                if (policy != null) {\n+                    Node selected = policy.selectFirst(p);\n@@ -152,1 +149,1 @@\n-                List<Node> nextNodesList = ((Parent)nextNode).getChildrenUnmodifiable();\n+                List<Node> nextNodesList = p.getChildrenUnmodifiable();\n@@ -169,2 +166,2 @@\n-        if (traverseIntoCurrent && node instanceof Parent) {\n-            newNode = findNextFocusableInList(((Parent)node).getChildrenUnmodifiable(), 0);\n+        if (traverseIntoCurrent && node instanceof Parent p) {\n+            newNode = findNextFocusableInList(p.getChildrenUnmodifiable(), 0);\n@@ -207,6 +204,8 @@\n-    public static Node getFirstTargetNode(Parent p) {\n-        if (p == null || isDisabledOrInvisible(p)) return null;\n-        final ParentTraversalEngine traversalEngine\n-                = ParentHelper.getTraversalEngine(p);\n-        if (traversalEngine!= null && traversalEngine.canTraverse()) {\n-            Node selected = traversalEngine.selectFirst();\n+    public static Node getFirstTargetNode(Parent parent) {\n+        if (parent == null || isDisabledOrInvisible(parent)) {\n+            return null;\n+        }\n+\n+        TraversalPolicy policy = TraversalUtils.getTraversalPolicy(parent);\n+        if (policy != null) {\n+            Node selected = policy.selectFirst(parent);\n@@ -217,1 +216,2 @@\n-        List<Node> parentsNodes = p.getChildrenUnmodifiable();\n+\n+        List<Node> parentsNodes = parent.getChildrenUnmodifiable();\n@@ -219,4 +219,4 @@\n-            if (isDisabledOrInvisible(n)) continue;\n-            final ParentTraversalEngine parentEngine = n instanceof Parent\n-                    ? ParentHelper.getTraversalEngine((Parent)n) : null;\n-            if (parentEngine != null ? parentEngine.isParentTraversable() : n.isFocusTraversable()) {\n+            if (isDisabledOrInvisible(n)) {\n+                continue;\n+            }\n+            if (isParentTraversable(n)) {\n@@ -225,3 +225,4 @@\n-            if (n instanceof Parent) {\n-                Node result = getFirstTargetNode((Parent)n);\n-                if (result != null) return result;\n+            if (n instanceof Parent p) {\n+                Node result = getFirstTargetNode(p);\n+                if (result != null)\n+                    return result;\n@@ -233,6 +234,5 @@\n-    public static Node getLastTargetNode(Parent p) {\n-        if (p == null || isDisabledOrInvisible(p)) return null;\n-        final ParentTraversalEngine traversalEngine\n-                = ParentHelper.getTraversalEngine(p);\n-        if (traversalEngine!= null && traversalEngine.canTraverse()) {\n-            Node selected = traversalEngine.selectLast();\n+    public static Node getLastTargetNode(Parent parent) {\n+        if (parent == null || isDisabledOrInvisible(parent)) return null;\n+        TraversalPolicy policy = TraversalUtils.getTraversalPolicy(parent);\n+        if (policy != null) {\n+            Node selected = policy.selectLast(parent);\n@@ -243,1 +243,2 @@\n-        List<Node> parentsNodes = p.getChildrenUnmodifiable();\n+\n+        List<Node> parentsNodes = parent.getChildrenUnmodifiable();\n@@ -246,5 +247,8 @@\n-            if (isDisabledOrInvisible(n)) continue;\n-\n-            if (n instanceof Parent) {\n-                Node result = getLastTargetNode((Parent) n);\n-                if (result != null) return result;\n+            if (isDisabledOrInvisible(n)) {\n+                continue;\n+            }\n+            if (n instanceof Parent p) {\n+                Node result = getLastTargetNode(p);\n+                if (result != null) {\n+                    return result;\n+                }\n@@ -252,3 +256,1 @@\n-            final ParentTraversalEngine parentEngine = n instanceof Parent\n-                    ? ParentHelper.getTraversalEngine((Parent) n) : null;\n-            if (parentEngine != null ? parentEngine.isParentTraversable() : n.isFocusTraversable()) {\n+            if (isParentTraversable(n)) {\n@@ -260,0 +262,10 @@\n+\n+    private static boolean isParentTraversable(Node n) {\n+        if (n instanceof Parent p) {\n+            TraversalPolicy policy = TraversalUtils.getTraversalPolicy(p);\n+            if (policy != null) {\n+                return policy.isParentTraversable(p);\n+            }\n+        }\n+        return n.isFocusTraversable();\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/TabOrderHelper.java","additions":74,"deletions":62,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import com.sun.javafx.scene.NodeHelper;\n-import com.sun.javafx.scene.ParentHelper;\n@@ -32,0 +30,1 @@\n+import com.sun.javafx.scene.NodeHelper;\n@@ -37,1 +36,1 @@\n- * These engines should be used by calling {@link #trav(javafx.scene.Node, Direction)}, {@link #traverseToFirst()} and\n+ * These engines should be used by calling {@link #trav(javafx.scene.Node, TraversalDirectionInternal)}, {@link #traverseToFirst()} and\n@@ -42,21 +41,1 @@\n-public abstract class TopMostTraversalEngine extends TraversalEngine{\n-\n-    protected TopMostTraversalEngine() {\n-        \/*\n-         * for 2d behaviour from TAB use :\n-         *    algorithm = new WeightedClosestCorner();\n-         * for Container sequence TAB behaviour and 2d arrow behaviour use :\n-         *    algorithm = new ContainerTabOrder();\n-         * for 2D arrow behaviour with a target bias and a stack use :\n-         *    algorithm = new Biased2DWithStack();\n-         *\/\n-        super(DEFAULT_ALGORITHM);\n-    }\n-\n-    \/**\n-     * For testing purposes only!\n-     *\/\n-    TopMostTraversalEngine(Algorithm algorithm) {\n-        super(algorithm);\n-    }\n-\n+public final class TopMostTraversalEngine {\n@@ -68,1 +47,1 @@\n-     * @param method the traversal method\n+     * @param focusVisible whether the focused Node should visible indicate focus\n@@ -71,1 +50,1 @@\n-    public final Node trav(Node node, Direction dir, TraversalMethod method) {\n+    public static final Node trav(Parent root, Node node, TraversalDirectionInternal dir, boolean focusVisible) {\n@@ -76,4 +55,4 @@\n-            \/\/ First find the nearest traversal engine override (i.e. a ParentTraversalEngine that is traversable)\n-            ParentTraversalEngine engine = ParentHelper.getTraversalEngine(p);\n-            if (engine != null && engine.canTraverse()) {\n-                newNode = engine.select(node, dir);\n+            \/\/ First find the nearest traversal policy override\n+            TraversalPolicy policy = TraversalUtils.getTraversalPolicy(p);\n+            if (policy != null) {\n+                newNode = policy.select(p, node, dir);\n@@ -87,2 +66,2 @@\n-                    if (dir == Direction.NEXT) {\n-                        dir = Direction.NEXT_IN_LINE;\n+                    if (dir == TraversalDirectionInternal.NEXT) {\n+                        dir = TraversalDirectionInternal.NEXT_IN_LINE;\n@@ -96,1 +75,1 @@\n-            newNode = select(traverseNode, dir);\n+            newNode = TraversalPolicy.getDefault().select(root, traverseNode, dir);\n@@ -99,4 +78,4 @@\n-            if (dir == Direction.NEXT || dir == Direction.NEXT_IN_LINE) {\n-                newNode = selectFirst();\n-            } else if (dir == Direction.PREVIOUS) {\n-                newNode = selectLast();\n+            if (dir == TraversalDirectionInternal.NEXT || dir == TraversalDirectionInternal.NEXT_IN_LINE) {\n+                newNode = TraversalPolicy.getDefault().selectFirst(root);\n+            } else if (dir == TraversalDirectionInternal.PREVIOUS) {\n+                newNode = TraversalPolicy.getDefault().selectLast(root);\n@@ -106,1 +85,1 @@\n-            focusAndNotify(newNode, method);\n+            focusAndNotify(root, newNode, focusVisible);\n@@ -111,3 +90,3 @@\n-    private void focusAndNotify(Node newNode, TraversalMethod method) {\n-        if (method == TraversalMethod.KEY) {\n-            NodeHelper.requestFocusVisible(newNode);\n+    private static void focusAndNotify(Parent root, Node n, boolean focusVisible) {\n+        if (focusVisible) {\n+            NodeHelper.requestFocusVisible(n);\n@@ -115,14 +94,1 @@\n-            newNode.requestFocus();\n-        }\n-\n-        notifyTreeTraversedTo(newNode);\n-    }\n-\n-    private void notifyTreeTraversedTo(Node newNode) {\n-        Parent p = newNode.getParent();\n-        while (p != null) {\n-            final ParentTraversalEngine traversalEngine = ParentHelper.getTraversalEngine(p);\n-            if (traversalEngine != null) {\n-                traversalEngine.notifyTraversedTo(newNode);\n-            }\n-            p = p.getParent();\n+            n.requestFocus();\n@@ -130,1 +96,0 @@\n-        notifyTraversedTo(newNode);\n@@ -137,13 +102,5 @@\n-    public final Node traverseToFirst() {\n-        Node n = selectFirst();\n-        if (n != null) focusAndNotify(n, TraversalMethod.DEFAULT);\n-        return n;\n-    }\n-\n-    \/**\n-     * Set focus on the last Node in this context (if any)\n-     * @return the last node or null if there's none\n-     *\/\n-    public final Node traverseToLast() {\n-        Node n = selectLast();\n-        if (n != null) focusAndNotify(n, TraversalMethod.DEFAULT);\n+    public static final Node traverseToFirst(Parent root) {\n+        Node n = TraversalPolicy.getDefault().selectFirst(root);\n+        if (n != null) {\n+            focusAndNotify(root, n, false);\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/TopMostTraversalEngine.java","additions":27,"deletions":70,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.scene.traversal;\n-\n-import javafx.geometry.Bounds;\n-import javafx.scene.Node;\n-import javafx.scene.Parent;\n-\n-import java.util.List;\n-\n-public interface TraversalContext {\n-\n-    \/**\n-     * Returns all possible targets within the context\n-     *\/\n-    List<Node> getAllTargetNodes();\n-\n-    \/**\n-     * Returns layout bounds of the Node in the relevant (Sub)Scene. Note that these bounds are the most important for traversal\n-     * as they define the final position within the scene.\n-     *\/\n-    Bounds getSceneLayoutBounds(Node node);\n-\n-    \/**\n-     * The root for this context, Traversal should be done only within the root\n-     *\/\n-    Parent getRoot();\n-\n-    \/**\n-     * If the TraversalEngine does not want to handle traversal inside some inner child (Parent), it can use this method to apply\n-     * default algorithm inside that Parent and return the first Node\n-     *\/\n-    Node selectFirstInParent(Parent parent);\n-\n-    \/**\n-     * If the TraversalEngine does not want to handle traversal inside some inner child (Parent), it can use this method to apply\n-     * default algorithm inside that Parent and return the last Node\n-     *\/\n-    Node selectLastInParent(Parent parent);\n-\n-    \/**\n-     * If the TraversalEngine does not want to handle traversal inside some inner child (Parent), it can use this method to apply\n-     * default algorithm inside that Parent and return the next Node within the Parent or null if there's no successor.\n-     * @param  subTreeRoot this will be used as a root of the traversal. Should be a Node that is still handled by the current TraversalEngine,\n-     *                     but it's content is not.\n-     *\/\n-    Node selectInSubtree(Parent subTreeRoot, Node from, Direction dir);\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/TraversalContext.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.javafx.scene.traversal;\n+\n+import javafx.geometry.NodeOrientation;\n+\n+\/**\n+ * Specifies the direction of focus traversal.\n+ *\/\n+public enum TraversalDirectionInternal {\n+    \/** Moves focus downward. *\/\n+    DOWN,\n+    \/** Moves focus left. *\/\n+    LEFT,\n+    \/** Moves focus to the next focusable Node, possibly traversing into the children of the current parent. *\/\n+    NEXT,\n+    \/** Moves focus to the next in line focusable Node, possibly traversing outside of the current parent. *\/\n+    NEXT_IN_LINE,\n+    \/** Moves focus to the previous focusable Node. *\/\n+    PREVIOUS,\n+    \/** Moves focus right. *\/\n+    RIGHT,\n+    \/** Moves focus upward. *\/\n+    UP;\n+\n+    \/**\n+     * Returns true if the traversal is considered a forward movement.\n+     * @return true if forward\n+     *\/\n+    public boolean isForward() {\n+        switch (this) {\n+        case UP:\n+        case LEFT:\n+        case PREVIOUS:\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Returns the direction with respect to the node's orientation. It affect's only arrow keys however, so it's not\n+     * an error to ignore this call if handling only next\/previous traversal.\n+     *\n+     * @param orientation the node orientation\n+     * @return the traverse direction\n+     *\/\n+    public TraversalDirectionInternal getDirectionForNodeOrientation(NodeOrientation orientation) {\n+        if (orientation == NodeOrientation.RIGHT_TO_LEFT) {\n+            switch (this) {\n+            case LEFT:\n+                return RIGHT;\n+            case RIGHT:\n+                return LEFT;\n+            }\n+        }\n+        return this;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/TraversalDirectionInternal.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -1,239 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.scene.traversal;\n-\n-import com.sun.javafx.application.PlatformImpl;\n-import com.sun.javafx.scene.NodeHelper;\n-import javafx.geometry.BoundingBox;\n-import javafx.geometry.Bounds;\n-import javafx.scene.Node;\n-import javafx.scene.Parent;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-\/**\n- * This is abstract class for a traversal engine. There are 2 types : {@link com.sun.javafx.scene.traversal.ParentTraversalEngine}\n- * to be used in {@link Parent#setTraversalEngine(ParentTraversalEngine)} to override default behavior\n- * and {@link com.sun.javafx.scene.traversal.TopMostTraversalEngine} that is the default traversal engine for scene and subscene.\n- *\n- * Every engine is basically a wrapper of an algorithm + some specific parent (or scene\/subscene), which define engine's root.\n- *\/\n-public abstract class TraversalEngine{\n-\n-    \/**\n-     * This is the default algorithm for the running platform. It's the algorithm that's used in TopMostTraversalEngine\n-     *\/\n-    static final Algorithm DEFAULT_ALGORITHM = PlatformImpl.isContextual2DNavigation() ? new Hueristic2D() : new ContainerTabOrder();\n-\n-    private final TraversalContext context = new EngineContext(); \/\/ This is the context used in calls to this engine's algorithm\n-    \/\/ This is a special context that's used when invoking select \"callbacks\" to default algorithm in other contexts\n-    private final TempEngineContext tempEngineContext = new TempEngineContext();\n-    protected final Algorithm algorithm;\n-\n-    private final Bounds initialBounds =  new BoundingBox(0, 0, 1, 1);\n-    private final ArrayList<TraverseListener> listeners = new ArrayList<>();\n-\n-    \/**\n-     * Creates engine with the specified algorithm\n-     * @param algorithm\n-     *\/\n-    protected TraversalEngine(Algorithm algorithm) {\n-        this.algorithm = algorithm;\n-    }\n-\n-    \/**\n-     * Creates engine with no algorithm. This makes all the select* calls invalid.\n-     * @see #canTraverse()\n-     *\/\n-    protected TraversalEngine() {\n-        this.algorithm = null;\n-    }\n-\n-    \/**\n-     * Add a listener to traversal engine. The listener is notified whenever focus is changed by traversal inside the associated scene or parent.\n-     * This can be used with ParentTraversalEngine that has no algorithm to observe changes to the focus inside the parent.\n-     * @param listener\n-     *\/\n-    public final void addTraverseListener(TraverseListener listener) {\n-        listeners.add(listener);\n-    }\n-\n-    \/**\n-     * Fire notifications for listeners. This is called from the TopMostTraversalEngine\n-     * @param newNode the node which has been focused\n-     *\/\n-    final void notifyTraversedTo(Node newNode) {\n-        for (TraverseListener l : listeners) {\n-            l.onTraverse(newNode, getLayoutBounds(newNode, getRoot()));\n-        }\n-    }\n-\n-    \/**\n-     * Returns the node that is in the direction {@code dir} starting from the Node {@code from} using the engine's algorithm.\n-     * Null means there is no Node in that direction\n-     * @param from the node to start traversal from\n-     * @param dir the direction of traversal\n-     * @return the subsequent node in the specified direction or null if none\n-     * @throws java.lang.NullPointerException if there is no algorithm\n-     *\/\n-    public final Node select(Node from, Direction dir) {\n-        return algorithm.select(from, dir, context);\n-    }\n-\n-    \/**\n-     * Returns the first node in this engine's context (scene\/parent) using the engine's algorithm.\n-     * This can be null only if there are no traversable nodes\n-     * @return The first node or null if none exists\n-     * @throws java.lang.NullPointerException if there is no algorithm\n-     *\/\n-    public final Node selectFirst() {\n-        return algorithm.selectFirst(context);\n-    }\n-\n-    \/**\n-     * Returns the last node in this engine's context (scene\/parent) using the engine's algorithm.\n-     * This can be null only if there are no traversable nodes\n-     * @return The last node or null if none exists\n-     * @throws java.lang.NullPointerException if there is no algorithm\n-     *\/\n-    public final Node selectLast() {\n-        return algorithm.selectLast(context);\n-    }\n-\n-    \/**\n-     * The root of this engine's context. This is the node that is the root of the tree that is traversed by this engine.\n-     * @return This engine's root\n-     *\/\n-    protected abstract Parent getRoot();\n-\n-    \/**\n-     * Returns true only if there's specified algorithm for this engine. Otherwise, this engine cannot be used for traversal.\n-     * The engine might be still useful however, e.g. for listening on traversal changes.\n-     * @return\n-     *\/\n-    public final boolean canTraverse() {\n-        return algorithm != null;\n-    }\n-\n-    \/**\n-     * Gets the appropriate bounds for the given node, transformed into\n-     * the scene's or the specified node's coordinates.\n-     * @return bounds of node in {@code forParent} coordinates or scene coordinates if {@code forParent} is null\n-     *\/\n-    private Bounds getLayoutBounds(Node n, Parent forParent) {\n-        final Bounds bounds;\n-        if (n != null) {\n-            if (forParent == null) {\n-                bounds = n.localToScene(n.getLayoutBounds());\n-            } else {\n-                bounds = forParent.sceneToLocal(n.localToScene(n.getLayoutBounds()));\n-            }\n-        } else {\n-            bounds = initialBounds;\n-        }\n-        return bounds;\n-    }\n-\n-    \/\/ This is the engine context passed algorithm on select calls\n-    private final class EngineContext extends BaseEngineContext {\n-        @Override\n-        public Parent getRoot() {\n-            return TraversalEngine.this.getRoot();\n-        }\n-    }\n-\n-    \/\/ This is the engine context passed to algorithm on select callbacks from other contexts.\n-    \/\/ It can change the root to the node defined in \"selectFirstInParent\", \"selectLastInParent\" or\n-    \/\/ \"selectInSubtree\" methods\n-    private final class TempEngineContext extends BaseEngineContext {\n-        private Parent root;\n-\n-        @Override\n-        public Parent getRoot() {\n-            return root;\n-        }\n-\n-        public void setRoot(Parent root) {\n-            this.root = root;\n-        }\n-    }\n-\n-    \/**\n-     * The base class for all engine contexts\n-     *\/\n-    private abstract class BaseEngineContext implements TraversalContext {\n-\n-        \/**\n-         * Returns all traversable nodes in the context's (engine's) root\n-         *\/\n-        @Override\n-        public List<Node> getAllTargetNodes() {\n-            final List<Node> targetNodes = new ArrayList<>();\n-            addFocusableChildrenToList(targetNodes, getRoot());\n-            return targetNodes;\n-        }\n-\n-        @Override\n-        public Bounds getSceneLayoutBounds(Node n) {\n-            return getLayoutBounds(n, null);\n-        }\n-\n-        private void addFocusableChildrenToList(List<Node> list, Parent parent) {\n-            List<Node> parentsNodes = parent.getChildrenUnmodifiable();\n-            for (Node n : parentsNodes) {\n-                if (n.isFocusTraversable() && !n.isFocused() && NodeHelper.isTreeVisible(n) && !n.isDisabled()) {\n-                    list.add(n);\n-                }\n-                if (n instanceof Parent) {\n-                    addFocusableChildrenToList(list, (Parent)n);\n-                }\n-            }\n-        }\n-\n-        \/\/ All of the methods below are callbacks from traversal context to the default algorithm.\n-        \/\/ They can be used to obtain \"default\" result for the specified subtree.\n-        \/\/ This is useful when there is some algorithm that overrides behavior for a Parent but parent's children\n-        \/\/ should be again traversed by default algorithm.\n-        @Override\n-        public Node selectFirstInParent(Parent parent) {\n-            tempEngineContext.setRoot(parent);\n-            return DEFAULT_ALGORITHM.selectFirst(tempEngineContext);\n-        }\n-\n-        @Override\n-        public Node selectLastInParent(Parent parent) {\n-            tempEngineContext.setRoot(parent);\n-            return DEFAULT_ALGORITHM.selectLast(tempEngineContext);\n-        }\n-\n-        @Override\n-        public Node selectInSubtree(Parent subTreeRoot, Node from, Direction dir) {\n-            tempEngineContext.setRoot(subTreeRoot);\n-            return DEFAULT_ALGORITHM.select(from, dir, tempEngineContext);\n-        }\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/TraversalEngine.java","additions":0,"deletions":239,"binary":false,"changes":239,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.scene.traversal;\n-\n-\/**\n- * Specifies the traversal method.\n- *\/\n-public enum TraversalMethod {\n-    \/**\n-     * Traversal was initiated programmatically or by clicking.\n-     *\/\n-    DEFAULT,\n-\n-    \/**\n-     * Traversal was initiated by pressing a key on the keyboard.\n-     *\/\n-    KEY\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/TraversalMethod.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene.traversal;\n+\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+\n+\/**\n+ * The base class for any algorithm that determines focus traversal between elements in the\n+ * JavaFX scene graph.\n+ * <p>\n+ * In addition to the default traversal policy, which can be obtained via {@link #getDefault()}, a custom policy\n+ * can be set on via {@link Parent#setTraversalPolicy(TraversalPolicy)}, thus altering the traversal between\n+ * the children of that {@code Parent} and out of it.\n+ * <p>\n+ * Note that in order to avoid cycles or dead-ends in traversal the algorithms should respect the following order:\n+ * <ul>\n+ *   <li>For {@link TraversalDirectionInternal#NEXT NEXT}:\n+ *       node ->\n+ *       node subtree ->\n+ *       node siblings (first sibling then its subtree) ->\n+ *       {@link TraversalDirectionInternal#NEXT_IN_LINE NEXT_IN_LINE} for node's parent\n+ *   <li>For {@link TraversalDirectionInternal#NEXT_IN_LINE NEXT_IN_LINE}:\n+ *       node ->\n+ *       node siblings (first sibling then its subtree) ->\n+ *       {@link TraversalDirectionInternal#NEXT_IN_LINE NEXT_IN_LINE} for node's parent\n+ *   <li>For {@link TraversalDirectionInternal#PREVIOUS PREVIOUS}:\n+ *       node ->\n+ *       node siblings (first subtree then the node itself) ->\n+ *       {@link TraversalDirectionInternal#PREVIOUS PREVIOUS} for node's parent\n+ * <\/ul>\n+ * <p>\n+ * This ensures that the next direction will traverse the same nodes as previous (in the opposite order).\n+ *\n+ * @see TraversalDirectionInternal\n+ * @since 24\n+ *\/\n+public abstract class TraversalPolicy {\n+    \/**\n+     * Traverses from the specified {@code node}, in the direction {@code dir}.\n+     * Returns the new {@link javafx.scene.Node#isFocusTraversable() focus traversable} Node\n+     * or null if no suitable target is found.\n+     * <p>\n+     * Note: the {@code node} does not have to be focused or focus traversable, as it serves\n+     * only as a reference point.\n+     *\n+     * Typically, the implementation of override TraversalPolicy handles only parent's direct children and looks like this:\n+     * <ol>\n+     * <li>Find the nearest parent of the \"owner\" that is handled by this TraversalPolicy (i.e. it's a direct child of the root).\n+     * <li>select the next node within this direct child and return it\n+     * <li>if no such node exists, move to the next direct child in the direction (this is where the different order of direct children is defined)\n+     *     or if direct children are not traversable, the select the first node in the next direct child\n+     * <\/ol>\n+     *\n+     * @param root the traversal root\n+     * @param node the Node to traverse from\n+     * @param dir the traversal direction\n+     * @return the new focus owner or null if none found (in that case old focus owner is still valid)\n+     *\/\n+    public abstract Node select(Parent root, Node node, TraversalDirectionInternal dir);\n+\n+    \/**\n+     * Return the first {@link javafx.scene.Node#isFocusTraversable() focus traversable}\n+     * node for the specified root.\n+     *\n+     * @param root the traversal root\n+     * @return the first node\n+     *\/\n+    public abstract Node selectFirst(Parent root);\n+\n+    \/**\n+     * Return the last\n+     * {@link javafx.scene.Node#isFocusTraversable() focus traversable} node for the specified root.\n+     *\n+     * @param root the traversal root\n+     * @return the last node\n+     *\/\n+    public abstract Node selectLast(Parent root);\n+\n+    \/**\n+     * Constructor for subclasses to call.\n+     *\/\n+    protected TraversalPolicy() {\n+    }\n+\n+    \/**\n+     * Determines whether the root is traversable.\n+     * This method can be overridden by a subclass.  The base class simply returns the result of calling\n+     * {@code root.isFocusTraversable();}\n+     *\n+     * @param root the traversal root\n+     * @return true if the root is traversable\n+     *\/\n+    public boolean isParentTraversable(Parent root) {\n+        return root.isFocusTraversable();\n+    }\n+\n+    \/**\n+     * Returns the platform's default traversal policy singleton.\n+     *\n+     * @return the default traversal policy\n+     *\/\n+    public static final TraversalPolicy getDefault() {\n+        return TraversalUtils.DEFAULT_POLICY;\n+    }\n+\n+    \/**\n+     * Finds the next focusable Node.\n+     * This method is provided to the policy implementation for handling of the {@link TraversalDirectionInternal#NEXT}\n+     * case when it needs to consider traversing into the parent's nodes.\n+     * <p>\n+     * Example:<pre>     @Override\n+     *     public Node select(Parent root, Node owner, TraversalDirection dir) {\n+     *         switch(dir) {\n+     *         case NEXT:\n+     *             return findNextFocusableNode(root, owner);\n+     *         ...\n+     * <\/pre>\n+     *\n+     * @param root the traversal root\n+     * @param node the Node to traverse from\n+     * @return the new focus owner or null if none found (in that case old focus owner is still valid)\n+     *\/\n+    protected final Node findNextFocusableNode(Parent root, Node node) {\n+        return TraversalUtils.findNextFocusableNode(root, node, true);\n+    }\n+\n+    \/**\n+     * Finds the next in line focusable Node.\n+     * This method is provided to the policy implementation for handling of the {@link TraversalDirectionInternal#NEXT_IN_LINE}\n+     * case when it needs to consider traversing into the parent's nodes.\n+     * <p>\n+     * Example:<pre>     @Override\n+     *     public Node select(Parent root, Node owner, TraversalDirection dir) {\n+     *         switch(dir) {\n+     *         case NEXT_IN_LINE:\n+     *             return findNextInLineFocusableNode(root, owner);\n+     *         ...\n+     * <\/pre>\n+     *\n+     * @param root the traversal root\n+     * @param node the Node to traverse from\n+     * @return the new focus owner or null if none found (in that case old focus owner is still valid)\n+     * @throws IllegalArgumentException if the direction is other than {@code TraversalDirection.NEXT}\n+     *         or {@code TraversalDirection.NEXT_IN_LINE}\n+     *\/\n+    protected final Node findNextInLineFocusableNode(Parent root, Node node) {\n+        return TraversalUtils.findNextFocusableNode(root, node, false);\n+    }\n+\n+    \/**\n+     * Finds the previous focusable Node.\n+     * This method is provided to the policy implementation for handling of the {@link TraversalDirectionInternal#PREVIOUS}\n+     * case when it needs to consider traversing into the parent's nodes.\n+     * <p>\n+     * Example:<pre>     @Override\n+     *     public Node select(Parent root, Node owner, TraversalDirection dir) {\n+     *         switch(dir) {\n+     *         case PREVIOUS:\n+     *             return findPreviousFocusableNode(root, owner);\n+     *         ...\n+     * <\/pre>\n+     *\n+     * @param root the traversal root\n+     * @param node the Node to traverse from\n+     * @return the new focus owner or null if none found (in that case old focus owner is still valid)\n+     *\/\n+    protected final Node findPreviousFocusableNode(Parent root, Node node) {\n+        return TraversalUtils.findPreviousFocusableNode(root, node);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/TraversalPolicy.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.javafx.scene.traversal;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javafx.geometry.BoundingBox;\n+import javafx.geometry.Bounds;\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+import javafx.scene.Scene;\n+import javafx.scene.SubScene;\n+import com.sun.javafx.application.PlatformImpl;\n+import com.sun.javafx.scene.NodeHelper;\n+import com.sun.javafx.scene.ParentHelper;\n+\n+public final class TraversalUtils {\n+    public static final TraversalPolicy DEFAULT_POLICY = PlatformImpl.isContextual2DNavigation() ? new Heuristic2D() : new ContainerTabOrder();\n+    public static final TraversalPolicy EMPTY_POLICY = initEmptyTraversablePolicy();\n+    private static final Bounds INITIAL_BOUNDS = new BoundingBox(0, 0, 1, 1);\n+\n+    private TraversalUtils() {\n+    }\n+\n+    public static TraversalPolicy createDefaultTraversalAlgorithm() {\n+        return PlatformImpl.isContextual2DNavigation() ? new Heuristic2D() : new ContainerTabOrder();\n+    }\n+\n+    \/**\n+     * Gets the appropriate bounds for the given node, transformed into the specified node's coordinates.\n+     * This method returns {@code null} if {@code n} or {@code forParent} is null\n+     * or the node is not a part of the scene graph.\n+     * @return bounds of node in {@code forParent} coordinates, or null\n+     *\/\n+    public static Bounds getLayoutBounds(Node n, Parent forParent) {\n+        if ((n != null) && (forParent != null)) {\n+            Bounds b = n.localToScene(n.getLayoutBounds());\n+            if (b != null) {\n+                return forParent.sceneToLocal(b);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Gets the appropriate bounds for the given node, transformed into the scene's coordinates.\n+     * @return bounds of node in scene coordinates\n+     *\/\n+    public static Bounds getLayoutBoundsInSceneCoordinates(Node n) {\n+        if (n != null) {\n+            return n.localToScene(n.getLayoutBounds());\n+        } else {\n+            return INITIAL_BOUNDS;\n+        }\n+    }\n+\n+    private static TraversalPolicy initEmptyTraversablePolicy() {\n+        return new TraversalPolicy() {\n+            @Override\n+            public Node select(Parent root, Node owner, TraversalDirectionInternal dir) {\n+                return null;\n+            }\n+\n+            @Override\n+            public Node selectFirst(Parent root) {\n+                return null;\n+            }\n+\n+            @Override\n+            public Node selectLast(Parent root) {\n+                return null;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Returns all possible targets within the traversal root.\n+     *\n+     * @param root the traversal root\n+     * @return the List of all possible targets within the traversal root\n+     *\/\n+    public static final List<Node> getAllTargetNodes(Parent root) {\n+        final List<Node> targetNodes = new ArrayList<>();\n+        addFocusableChildrenToList(targetNodes, root);\n+        return targetNodes;\n+    }\n+\n+    private static final void addFocusableChildrenToList(List<Node> list, Parent parent) {\n+        List<Node> parentsNodes = parent.getChildrenUnmodifiable();\n+        for (Node n : parentsNodes) {\n+            if (n.isFocusTraversable() && !n.isFocused() && NodeHelper.isTreeVisible(n) && !n.isDisabled()) {\n+                list.add(n);\n+            }\n+            if (n instanceof Parent p) {\n+                addFocusableChildrenToList(list, p);\n+            }\n+        }\n+    }\n+\n+    public static Node findNextFocusableNode(Parent root, Node node, boolean traverseIntoCurrent) {\n+        return TabOrderHelper.findNextFocusablePeer(node, root, traverseIntoCurrent);\n+    }\n+\n+    public static Node findPreviousFocusableNode(Parent root, Node node) {\n+        return TabOrderHelper.findPreviousFocusablePeer(node, root);\n+    }\n+\n+    \/**\n+     * Traverses focus to the adjacent node as specified by the direction.\n+     *\n+     * @param node the node to traverse focus from\n+     * @param dir the direction of traversal\n+     * @param focusVisible whether the focused Node should visible indicate focus\n+     * @return true if traversal was successful\n+     *\/\n+    public static boolean traverse(Node node, TraversalDirectionInternal dir, boolean focusVisible) {\n+        if (node != null) {\n+            SubScene ss = NodeHelper.getSubScene(node);\n+            if (ss != null) {\n+                return TopMostTraversalEngine.trav(ss.getRoot(), node, dir, focusVisible) != null;\n+            }\n+\n+            Scene sc = node.getScene();\n+            if (sc != null) {\n+                return TopMostTraversalEngine.trav(sc.getRoot(), node, dir, focusVisible) != null;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static TraversalPolicy getTraversalPolicy(Parent parent) {\n+        return ParentHelper.getTraversalPolicy(parent);\n+    }\n+\n+    public static void setTraversalPolicy(Parent parent, TraversalPolicy policy) {\n+        ParentHelper.setTraversalPolicy(parent, policy);\n+    }\n+}\n\\ No newline at end of file\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/TraversalUtils.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.scene.traversal;\n-\n-\n-import javafx.geometry.Bounds;\n-import javafx.scene.Node;\n-\n-\n-public interface TraverseListener {\n-\n-    public void onTraverse(Node node, Bounds bounds);\n-\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/TraverseListener.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,319 +0,0 @@\n-\/*\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.scene.traversal;\n-\n-import java.util.List;\n-import javafx.geometry.Bounds;\n-import javafx.geometry.Point2D;\n-import javafx.scene.Node;\n-\n-import static com.sun.javafx.scene.traversal.Direction.*;\n-\n-\/**\n- * First search for on-axis nodes. A node is on-axis if any part of its\n- * closest edge lies between the pair of rays cast in the traversal direction\n- * from the corners of the originating node.\n- *\n- * If there are multiple on-axis nodes, the closest is chosen.\n- *\n- * If there is a tie for the closest on-axis node, the tie is broken\n- * by choosing the one whose center is closest to the center of the\n- * originating node. TODO: investigate alternative tiebreaker algorithms\n- * (filed as RT-19470).\n- *\n- * If there are no on-axis nodes, compute the distance OUT (in the traversal\n- * direction) and the distance to the SIDE (perpendicular to the traversal\n- * direction) and compute a distance metric OUT + WEIGHT * SIDE. Choose the\n- * node with the smallest distance metric.\n- *\n- * TODO: presumably WEIGHT is greater than one, so that nodes farther OUT\n- * but close (and not on) axis are chosen in preference to nodes that are\n- * physically closer but are farther off to the side. Determine WEIGHT\n- * somehow, possibly empirically (filed as RT-19471).\n- *\/\n-\n-public class WeightedClosestCorner implements Algorithm {\n-\n-\n-    WeightedClosestCorner() {\n-    }\n-\n-    private boolean isOnAxis(Direction dir, Bounds cur, Bounds tgt) {\n-\n-        final double cmin, cmax, tmin, tmax;\n-\n-        if (dir == UP || dir == DOWN) {\n-            cmin = cur.getMinX();\n-            cmax = cur.getMaxX();\n-            tmin = tgt.getMinX();\n-            tmax = tgt.getMaxX();\n-        }\n-        else { \/\/ dir == LEFT || dir == RIGHT\n-            cmin = cur.getMinY();\n-            cmax = cur.getMaxY();\n-            tmin = tgt.getMinY();\n-            tmax = tgt.getMaxY();\n-        }\n-\n-        return tmin <= cmax && tmax >= cmin;\n-    }\n-\n-    \/**\n-     * Compute the out-distance to the near edge of the target in the\n-     * traversal direction. Negative means the near edge is \"behind\".\n-     *\/\n-    private double outDistance(Direction dir, Bounds cur, Bounds tgt) {\n-\n-        final double distance;\n-\n-        if (dir == UP) {\n-            distance = cur.getMinY() - tgt.getMaxY();\n-        }\n-        else if (dir == DOWN) {\n-            distance = tgt.getMinY() - cur.getMaxY();\n-        }\n-        else if (dir == LEFT) {\n-            distance = cur.getMinX() - tgt.getMaxX();\n-        }\n-        else { \/\/ dir == RIGHT\n-            distance = tgt.getMinX() - cur.getMaxX();\n-        }\n-\n-        return distance;\n-    }\n-\n-    \/**\n-     * Computes the side distance from current center to target center.\n-     * Always positive. This is only used for on-axis nodes.\n-     *\/\n-    private double centerSideDistance(Direction dir, Bounds cur, Bounds tgt) {\n-\n-        final double cc; \/\/ current center\n-        final double tc; \/\/ target center\n-\n-        if (dir == UP || dir == DOWN) {\n-            cc = cur.getMinX() + cur.getWidth() \/ 2.0f;\n-            tc = tgt.getMinX() + tgt.getWidth() \/ 2.0f;\n-        }\n-        else { \/\/ dir == LEFT || dir == RIGHT\n-            cc = cur.getMinY() + cur.getHeight() \/ 2.0f;\n-            tc = tgt.getMinY() + tgt.getHeight() \/ 2.0f;\n-        }\n-\n-        return Math.abs(tc - cc);\n-        \/\/return (tc > cc) ? tc - cc : cc - tc;\n-    }\n-\n-    \/**\n-     * Computes the side distance between the closest corners of the current\n-     * and target. Always positive. This is only used for off-axis nodes.\n-     *\/\n-    private double cornerSideDistance(Direction dir, Bounds cur, Bounds tgt) {\n-\n-        final double distance;\n-\n-        if (dir == UP || dir == DOWN) {\n-\n-            if (tgt.getMinX() > cur.getMaxX()) {\n-                \/\/ on the right\n-                distance = tgt.getMinX() - cur.getMaxX();\n-            }\n-            else {\n-                \/\/ on the left\n-                distance = cur.getMinX() - tgt.getMaxX();\n-            }\n-        }\n-        else { \/\/ dir == LEFT or dir == RIGHT\n-\n-            if (tgt.getMinY() > cur.getMaxY()) {\n-                \/\/ below\n-                distance = tgt.getMinY() - cur.getMaxY();\n-            }\n-            else {\n-                \/\/ above\n-                distance = cur.getMinY() - tgt.getMaxY();\n-            }\n-        }\n-        return distance;\n-    }\n-\n-    @Override\n-    public Node select(Node node, Direction dir, TraversalContext context) {\n-        Node newNode = null;\n-        List<Node> nodes = context.getAllTargetNodes();\n-\n-        int target = traverse(context.getSceneLayoutBounds(node), dir, nodes, context);\n-        if (target != -1) {\n-            newNode = nodes.get(target);\n-        }\n-\n-        return newNode;\n-    }\n-\n-    @Override\n-    public Node selectFirst(TraversalContext context) {\n-        List<Node> nodes = context.getAllTargetNodes();\n-        Point2D zeroZero = new Point2D(0,0);\n-\n-        if (nodes.size() > 0) {\n-            int nodeIndex;\n-            Node nearestNode = nodes.get(0);\n-            double nearestDistance = zeroZero.distance(context.getSceneLayoutBounds(nodes.get(0)).getMinX(),\n-                    context.getSceneLayoutBounds(nodes.get(0)).getMinY());\n-            double distance;\n-\n-            for (nodeIndex = 1; nodeIndex < nodes.size(); nodeIndex++) {\n-                distance = zeroZero.distance(context.getSceneLayoutBounds(nodes.get(nodeIndex)).getMinX(),\n-                        context.getSceneLayoutBounds(nodes.get(nodeIndex)).getMinY());\n-                if (nearestDistance > distance) {\n-                    nearestDistance = distance;\n-                    nearestNode = nodes.get(nodeIndex);\n-                }\n-            }\n-            return nearestNode;\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public Node selectLast(TraversalContext context) {\n-        return null;\n-    }\n-\n-    public int traverse(Bounds origin, Direction dir, List<Node> targets, TraversalContext context) {\n-\n-        final int target;\n-\n-        if (dir == NEXT || dir == NEXT_IN_LINE || dir == PREVIOUS) {\n-            target = trav1D(origin, dir, targets, context);\n-        } else {\n-            target = trav2D(origin, dir, targets, context);\n-        }\n-\n-        return target;\n-    }\n-\n-    private int trav2D(Bounds origin, Direction dir, List<Node> targets, TraversalContext context) {\n-\n-        Bounds bestBounds = null;\n-        double bestMetric = 0.0;\n-        int bestIndex = -1;\n-\n-        for (int i = 0; i < targets.size(); i++) {\n-            final Bounds targetBounds = context.getSceneLayoutBounds(targets.get(i));\n-            final double outd = outDistance(dir, origin, targetBounds);\n-            final double metric;\n-\n-            if (isOnAxis(dir, origin, targetBounds)) {\n-                metric = outd + centerSideDistance(dir, origin, targetBounds) \/ 100;\n-            }\n-            else {\n-                final double cosd = cornerSideDistance(dir, origin, targetBounds);\n-                metric = 100000 + outd*outd + 9*cosd*cosd;\n-            }\n-\n-            if (outd < 0.0) {\n-                continue;\n-            }\n-\n-            if (bestBounds == null || metric < bestMetric) {\n-                bestBounds = targetBounds;\n-                bestMetric = metric;\n-                bestIndex = i;\n-            }\n-        }\n-\n-        return bestIndex;\n-    }\n-\n-    \/*\n-     * Consider focus targets to have a total order using values\n-     * (minY, minX, hashCode).\n-     *\/\n-    private int compare1D(Bounds a, Bounds b) {\n-\n-        int res = 0;\n-\n-        \/\/ the following use the node's center\n-        final double metric1a = (a.getMinY() + a.getMaxY()) \/ 2;\n-        final double metric1b = (b.getMinY() + b.getMaxY()) \/ 2;\n-        final double metric2a = (a.getMinX() + a.getMaxX()) \/ 2;\n-        final double metric2b = (b.getMinX() + b.getMaxX()) \/ 2;\n-        final double metric3a = a.hashCode();\n-        final double metric3b = b.hashCode();\n-\n-        if (metric1a < metric1b) {\n-            res = -1;\n-        }\n-        else if (metric1a > metric1b) {\n-            res = 1;\n-        }\n-        else if (metric2a < metric2b) {\n-            res = -1;\n-        }\n-        else if (metric2a > metric2b) {\n-            res = 1;\n-        }\n-        else if (metric3a < metric3b) {\n-            res = -1;\n-        }\n-        else if (metric3a > metric3b) {\n-            res = 1;\n-        }\n-\n-        return res;\n-    }\n-\n-\n-    private int compare1D(Bounds a, Bounds b, Direction dir) {\n-        return (dir != PREVIOUS) ? -compare1D(a, b) : compare1D(a, b);\n-    }\n-\n-    private int trav1D(Bounds origin, Direction dir, List<Node> targets, TraversalContext context) {\n-        int bestSoFar = -1;\n-        int leastSoFar = -1;\n-\n-        for (int i = 0; i < targets.size(); i++) {\n-            if (leastSoFar == -1 ||\n-                    compare1D(context.getSceneLayoutBounds(targets.get(i)),\n-                            context.getSceneLayoutBounds(targets.get(leastSoFar)), dir) < 0) {\n-                leastSoFar = i;\n-            }\n-\n-            if (compare1D(context.getSceneLayoutBounds(targets.get(i)), origin, dir) < 0) {\n-                continue;\n-            }\n-\n-            if (bestSoFar == -1 ||\n-                    compare1D(context.getSceneLayoutBounds(targets.get(i)), context.getSceneLayoutBounds(targets.get(bestSoFar)), dir) < 0) {\n-                bestSoFar = i;\n-            }\n-        }\n-\n-        return (bestSoFar == -1) ? leastSoFar : bestSoFar;\n-    }\n-\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/traversal\/WeightedClosestCorner.java","additions":0,"deletions":319,"binary":false,"changes":319,"status":"deleted"},{"patch":"@@ -47,1 +47,1 @@\n-import com.sun.javafx.scene.traversal.Direction;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n@@ -199,2 +199,2 @@\n-    public boolean traverseOut(Direction dir) {\n-        if (dir == Direction.NEXT) {\n+    public boolean traverseOut(TraversalDirectionInternal dir) {\n+        if (dir == TraversalDirectionInternal.NEXT) {\n@@ -202,1 +202,1 @@\n-        } else if (dir == Direction.PREVIOUS) {\n+        } else if (dir == TraversalDirectionInternal.PREVIOUS) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/EmbeddedScene.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,2 +29,10 @@\n-import com.sun.javafx.geometry.BoundsUtils;\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n+import java.security.AccessControlContext;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n@@ -62,0 +70,2 @@\n+import javafx.css.Selector;\n+import javafx.css.Style;\n@@ -69,0 +79,5 @@\n+import javafx.css.converter.BooleanConverter;\n+import javafx.css.converter.CursorConverter;\n+import javafx.css.converter.EffectConverter;\n+import javafx.css.converter.EnumConverter;\n+import javafx.css.converter.SizeConverter;\n@@ -101,0 +116,1 @@\n+import javafx.scene.shape.Shape3D;\n@@ -106,12 +122,0 @@\n-import java.security.AccessControlContext;\n-\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.EnumSet;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n@@ -120,3 +124,0 @@\n-import com.sun.javafx.util.Logging;\n-import com.sun.javafx.util.TempState;\n-import com.sun.javafx.util.Utils;\n@@ -132,7 +133,0 @@\n-import javafx.css.Selector;\n-import javafx.css.Style;\n-import javafx.css.converter.BooleanConverter;\n-import javafx.css.converter.CursorConverter;\n-import javafx.css.converter.EffectConverter;\n-import javafx.css.converter.EnumConverter;\n-import javafx.css.converter.SizeConverter;\n@@ -149,0 +143,3 @@\n+import com.sun.javafx.geometry.BoundsUtils;\n+import com.sun.javafx.logging.PlatformLogger;\n+import com.sun.javafx.logging.PlatformLogger.Level;\n@@ -163,1 +160,2 @@\n-import com.sun.javafx.scene.traversal.Direction;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -166,0 +164,3 @@\n+import com.sun.javafx.util.Logging;\n+import com.sun.javafx.util.TempState;\n+import com.sun.javafx.util.Utils;\n@@ -169,4 +170,0 @@\n-import javafx.scene.shape.Shape3D;\n-import com.sun.javafx.logging.PlatformLogger;\n-import com.sun.javafx.logging.PlatformLogger.Level;\n-\n@@ -531,5 +528,0 @@\n-            @Override\n-            public boolean traverse(Node node, Direction direction, TraversalMethod method) {\n-                return node.traverse(direction, method);\n-            }\n-\n@@ -8521,13 +8513,0 @@\n-    \/**\n-     * Traverses from this node in the direction indicated. Note that this\n-     * node need not actually have the focus, nor need it be focusTraversable.\n-     * However, the node must be part of a scene, otherwise this request\n-     * is ignored.\n-     *\/\n-    final boolean traverse(Direction dir, TraversalMethod method) {\n-        if (getScene() == null) {\n-            return false;\n-        }\n-        return getScene().traverse(this, dir, method);\n-    }\n-\n@@ -10462,0 +10441,21 @@\n+    \/**\n+     * Tries to move the focus from this {@code Node} in the specified direction.\n+     * A successful traversal results in a new {@code Node} being focused.\n+     * A focused node is the target of key events and has a visual indicator.\n+     *\n+     * @param direction the direction of focus traversal\n+     * @return {@code true} if traversal was successful\n+     * @since 24\n+     *\/\n+    public final boolean requestFocusTraversal(TraversalDirection direction) {\n+        TraversalDirectionInternal d = switch (direction) {\n+        case DOWN -> TraversalDirectionInternal.DOWN;\n+        case LEFT -> TraversalDirectionInternal.LEFT;\n+        case NEXT -> TraversalDirectionInternal.NEXT;\n+        case PREVIOUS -> TraversalDirectionInternal.PREVIOUS;\n+        case RIGHT -> TraversalDirectionInternal.RIGHT;\n+        case UP -> TraversalDirectionInternal.UP;\n+        default -> null;\n+        };\n+        return d == null ? false : TraversalUtils.traverse(this, d, true);\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":47,"deletions":47,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,6 @@\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javafx.beans.property.ObjectProperty;\n@@ -31,0 +36,1 @@\n+import javafx.beans.property.SimpleObjectProperty;\n@@ -34,7 +40,2 @@\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-\n-import com.sun.javafx.util.TempState;\n-import com.sun.javafx.util.Utils;\n+import javafx.css.Selector;\n+import javafx.stage.Window;\n@@ -43,1 +44,0 @@\n-import javafx.css.Selector;\n@@ -53,4 +53,0 @@\n-import com.sun.javafx.scene.input.PickResultChooser;\n-import com.sun.javafx.sg.prism.NGGroup;\n-import com.sun.javafx.sg.prism.NGNode;\n-import com.sun.javafx.tk.Toolkit;\n@@ -60,0 +56,4 @@\n+import com.sun.javafx.scene.input.PickResultChooser;\n+import com.sun.javafx.scene.traversal.TraversalPolicy;\n+import com.sun.javafx.sg.prism.NGGroup;\n+import com.sun.javafx.sg.prism.NGNode;\n@@ -61,2 +61,3 @@\n-import java.util.Collections;\n-import javafx.stage.Window;\n+import com.sun.javafx.tk.Toolkit;\n+import com.sun.javafx.util.TempState;\n+import com.sun.javafx.util.Utils;\n@@ -98,0 +99,2 @@\n+    private TraversalPolicy traversalPolicy;\n+\n@@ -140,2 +143,2 @@\n-            public void setTraversalEngine(Parent parent, ParentTraversalEngine value) {\n-                parent.setTraversalEngine(value);\n+            public List<String> doGetAllParentStylesheets(Parent parent) {\n+                return parent.doGetAllParentStylesheets();\n@@ -145,2 +148,2 @@\n-            public ParentTraversalEngine getTraversalEngine(Parent parent) {\n-                return parent.getTraversalEngine();\n+            public TraversalPolicy getTraversalPolicy(Parent parent) {\n+                return parent.traversalPolicy;\n@@ -150,2 +153,2 @@\n-            public List<String> doGetAllParentStylesheets(Parent parent) {\n-                return parent.doGetAllParentStylesheets();\n+            public void setTraversalPolicy(Parent parent, TraversalPolicy policy) {\n+                parent.traversalPolicy = policy;\n@@ -857,10 +860,0 @@\n-    private ParentTraversalEngine traversalEngine;\n-\n-    private final void setTraversalEngine(ParentTraversalEngine value) {\n-        this.traversalEngine = value;\n-    }\n-\n-    private final ParentTraversalEngine getTraversalEngine() {\n-        return traversalEngine;\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Parent.java","additions":25,"deletions":32,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -28,32 +28,18 @@\n-import com.sun.glass.ui.Application;\n-import com.sun.glass.ui.Accessible;\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n-import com.sun.javafx.util.Logging;\n-import com.sun.javafx.util.Utils;\n-import com.sun.javafx.application.PlatformImpl;\n-import com.sun.javafx.collections.TrackableObservableList;\n-import com.sun.javafx.css.StyleManager;\n-import com.sun.javafx.cursor.CursorFrame;\n-import com.sun.javafx.event.EventQueue;\n-import com.sun.javafx.event.EventUtil;\n-import com.sun.javafx.geom.PickRay;\n-import com.sun.javafx.geom.Vec3d;\n-import com.sun.javafx.geom.transform.BaseTransform;\n-import com.sun.javafx.perf.PerformanceTracker;\n-import com.sun.javafx.scene.CssFlags;\n-import com.sun.javafx.scene.LayoutFlags;\n-import com.sun.javafx.scene.SceneEventDispatcher;\n-import com.sun.javafx.scene.SceneHelper;\n-import com.sun.javafx.scene.input.DragboardHelper;\n-import com.sun.javafx.scene.input.ExtendedInputMethodRequests;\n-import com.sun.javafx.scene.input.InputEventUtils;\n-import com.sun.javafx.scene.input.PickResultChooser;\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.SceneTraversalEngine;\n-import com.sun.javafx.scene.traversal.TopMostTraversalEngine;\n-import com.sun.javafx.stage.EmbeddedWindow;\n-import com.sun.javafx.sg.prism.NGCamera;\n-import com.sun.javafx.sg.prism.NGLightBase;\n-import com.sun.javafx.tk.*;\n-import com.sun.prism.impl.PrismSettings;\n-\n+import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;\n+import java.io.File;\n+import java.lang.ref.WeakReference;\n+import java.security.AccessControlContext;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.stream.Stream;\n@@ -67,1 +53,9 @@\n-import javafx.beans.property.*;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.ObjectPropertyBase;\n+import javafx.beans.property.ReadOnlyBooleanProperty;\n+import javafx.beans.property.ReadOnlyDoubleProperty;\n+import javafx.beans.property.ReadOnlyDoubleWrapper;\n+import javafx.beans.property.ReadOnlyObjectProperty;\n+import javafx.beans.property.ReadOnlyObjectPropertyBase;\n+import javafx.beans.property.ReadOnlyObjectWrapper;\n+import javafx.beans.property.SimpleObjectProperty;\n@@ -75,2 +69,11 @@\n-import javafx.event.*;\n-import javafx.geometry.*;\n+import javafx.event.Event;\n+import javafx.event.EventDispatchChain;\n+import javafx.event.EventDispatcher;\n+import javafx.event.EventHandler;\n+import javafx.event.EventTarget;\n+import javafx.event.EventType;\n+import javafx.geometry.Bounds;\n+import javafx.geometry.NodeOrientation;\n+import javafx.geometry.Orientation;\n+import javafx.geometry.Point2D;\n+import javafx.geometry.Point3D;\n@@ -78,1 +81,23 @@\n-import javafx.scene.input.*;\n+import javafx.scene.input.ContextMenuEvent;\n+import javafx.scene.input.DragEvent;\n+import javafx.scene.input.Dragboard;\n+import javafx.scene.input.GestureEvent;\n+import javafx.scene.input.InputEvent;\n+import javafx.scene.input.InputMethodEvent;\n+import javafx.scene.input.InputMethodRequests;\n+import javafx.scene.input.InputMethodTextRun;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyCombination;\n+import javafx.scene.input.KeyEvent;\n+import javafx.scene.input.Mnemonic;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.input.MouseDragEvent;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.input.PickResult;\n+import javafx.scene.input.RotateEvent;\n+import javafx.scene.input.ScrollEvent;\n+import javafx.scene.input.SwipeEvent;\n+import javafx.scene.input.TouchEvent;\n+import javafx.scene.input.TouchPoint;\n+import javafx.scene.input.TransferMode;\n+import javafx.scene.input.ZoomEvent;\n@@ -87,0 +112,11 @@\n+import com.sun.glass.ui.Accessible;\n+import com.sun.glass.ui.Application;\n+import com.sun.javafx.application.PlatformImpl;\n+import com.sun.javafx.collections.TrackableObservableList;\n+import com.sun.javafx.css.StyleManager;\n+import com.sun.javafx.cursor.CursorFrame;\n+import com.sun.javafx.event.EventQueue;\n+import com.sun.javafx.event.EventUtil;\n+import com.sun.javafx.geom.PickRay;\n+import com.sun.javafx.geom.Vec3d;\n+import com.sun.javafx.geom.transform.BaseTransform;\n@@ -89,9 +125,0 @@\n-\n-import java.io.File;\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.util.*;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.stream.Stream;\n-\n@@ -99,2 +126,3 @@\n-\n-import static com.sun.javafx.logging.PulseLogger.PULSE_LOGGING_ENABLED;\n+import com.sun.javafx.perf.PerformanceTracker;\n+import com.sun.javafx.scene.CssFlags;\n+import com.sun.javafx.scene.LayoutFlags;\n@@ -102,1 +130,2 @@\n-import com.sun.javafx.stage.WindowHelper;\n+import com.sun.javafx.scene.SceneEventDispatcher;\n+import com.sun.javafx.scene.SceneHelper;\n@@ -104,0 +133,4 @@\n+import com.sun.javafx.scene.input.DragboardHelper;\n+import com.sun.javafx.scene.input.ExtendedInputMethodRequests;\n+import com.sun.javafx.scene.input.InputEventUtils;\n+import com.sun.javafx.scene.input.PickResultChooser;\n@@ -105,1 +138,20 @@\n-import java.lang.ref.WeakReference;\n+import com.sun.javafx.scene.traversal.TopMostTraversalEngine;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n+import com.sun.javafx.sg.prism.NGCamera;\n+import com.sun.javafx.sg.prism.NGLightBase;\n+import com.sun.javafx.stage.EmbeddedWindow;\n+import com.sun.javafx.stage.WindowHelper;\n+import com.sun.javafx.tk.TKClipboard;\n+import com.sun.javafx.tk.TKDragGestureListener;\n+import com.sun.javafx.tk.TKDragSourceListener;\n+import com.sun.javafx.tk.TKDropTargetListener;\n+import com.sun.javafx.tk.TKPulseListener;\n+import com.sun.javafx.tk.TKScene;\n+import com.sun.javafx.tk.TKSceneListener;\n+import com.sun.javafx.tk.TKScenePaintListener;\n+import com.sun.javafx.tk.TKStage;\n+import com.sun.javafx.tk.Toolkit;\n+import com.sun.javafx.util.Logging;\n+import com.sun.javafx.util.Utils;\n+import com.sun.prism.impl.PrismSettings;\n@@ -2154,12 +2206,0 @@\n-    private TopMostTraversalEngine traversalEngine = new SceneTraversalEngine(this);\n-\n-    \/**\n-     * Traverses focus from the given node in the given direction.\n-     *\/\n-    boolean traverse(Node node, Direction dir, TraversalMethod method) {\n-        if (node.getSubScene() != null) {\n-            return node.getSubScene().traverse(node, dir, method);\n-        }\n-        return traversalEngine.trav(node, dir, method) != null;\n-    }\n-\n@@ -2172,1 +2212,1 @@\n-        traversalEngine.traverseToFirst();\n+        TopMostTraversalEngine.traverseToFirst(getRoot());\n@@ -2182,1 +2222,1 @@\n-        traverse(node, Direction.NEXT, TraversalMethod.DEFAULT);\n+        TraversalUtils.traverse(node, TraversalDirectionInternal.NEXT, false);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":103,"deletions":63,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -28,5 +28,3 @@\n-import com.sun.javafx.css.StyleManager;\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.SubSceneTraversalEngine;\n-import com.sun.javafx.scene.traversal.TopMostTraversalEngine;\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -36,1 +34,5 @@\n-import javafx.beans.property.*;\n+import javafx.beans.property.DoubleProperty;\n+import javafx.beans.property.DoublePropertyBase;\n+import javafx.beans.property.ObjectProperty;\n+import javafx.beans.property.ObjectPropertyBase;\n+import javafx.beans.property.SimpleObjectProperty;\n@@ -42,5 +44,1 @@\n-\n-import java.io.File;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n+import com.sun.javafx.css.StyleManager;\n@@ -50,0 +48,1 @@\n+import com.sun.javafx.logging.PlatformLogger;\n@@ -61,2 +60,0 @@\n-import com.sun.javafx.logging.PlatformLogger;\n-\n@@ -771,6 +768,0 @@\n-    private TopMostTraversalEngine traversalEngine = new SubSceneTraversalEngine(this);\n-\n-    boolean traverse(Node node, Direction dir, TraversalMethod method) {\n-        return traversalEngine.trav(node, dir, method) != null;\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/SubScene.java","additions":10,"deletions":19,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package javafx.scene;\n+\n+\/**\n+ * Specifies the direction of focus traversal.\n+ *\n+ * @since 24\n+ * @see Node#requestFocusTraversal(TraversalDirection)\n+ *\/\n+public enum TraversalDirection {\n+    \/** Indicates a focus change to the node below the currently focused node. *\/\n+    DOWN,\n+    \/** Indicates a focus change to the node to the left of the currently focused node. *\/\n+    LEFT,\n+    \/** Indicates a focus change to the next focusable node. *\/\n+    NEXT,\n+    \/** Indicates a focus change to the previous focusable node. *\/\n+    PREVIOUS,\n+    \/** Indicates a focus change to the node to the right of the currently focused node. *\/\n+    RIGHT,\n+    \/** Indicates a focus change to the node above the currently focused node. *\/\n+    UP;\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/TraversalDirection.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.scene.traversal;\n-\n-public abstract class TopMostTraversalEngineShim extends TopMostTraversalEngine {\n-\n-    public TopMostTraversalEngineShim(Algorithm algorithm) {\n-        super(algorithm);\n-    }\n-\n-}\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/com\/sun\/javafx\/scene\/traversal\/TopMostTraversalEngineShim.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -28,8 +28,2 @@\n-import com.sun.javafx.scene.ParentHelper;\n-import com.sun.javafx.scene.traversal.Algorithm;\n-import com.sun.javafx.scene.traversal.ContainerTabOrderShim;\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n-import com.sun.javafx.scene.traversal.TopMostTraversalEngineShim;\n-import com.sun.javafx.scene.traversal.TraversalContext;\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -41,1 +35,0 @@\n-\n@@ -44,2 +37,6 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.fail;\n+import com.sun.javafx.scene.traversal.ContainerTabOrderShim;\n+import com.sun.javafx.scene.traversal.OverridableTraversalPolicy;\n+import com.sun.javafx.scene.traversal.TopMostTraversalEngine;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n+import com.sun.javafx.scene.traversal.TraversalPolicy;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -48,1 +45,1 @@\n-    private TopMostTraversalEngineShim engine;\n+    private TraversalPolicy engine;\n@@ -54,6 +51,1 @@\n-        engine = new TopMostTraversalEngineShim(new ContainerTabOrderShim()) {\n-            @Override\n-            protected Parent getRoot() {\n-                return root;\n-            }\n-        };\n+        engine = new ContainerTabOrderShim();\n@@ -68,1 +60,1 @@\n-        assertEquals(focusableNode, engine.selectFirst());\n+        assertEquals(focusableNode, engine.selectFirst(root));\n@@ -77,1 +69,1 @@\n-        assertEquals(n2, engine.selectFirst());\n+        assertEquals(n2, engine.selectFirst(root));\n@@ -83,1 +75,1 @@\n-        ParentHelper.setTraversalEngine(g, new ParentTraversalEngine(g, new Algorithm() {\n+        TraversalUtils.setTraversalPolicy(g, new TraversalPolicy() {\n@@ -85,1 +77,1 @@\n-            public Node select(Node owner, Direction dir, TraversalContext context) {\n+            public Node select(Parent root, Node owner, TraversalDirectionInternal dir) {\n@@ -90,1 +82,1 @@\n-            public Node selectFirst(TraversalContext context) {\n+            public Node selectFirst(Parent root) {\n@@ -95,1 +87,1 @@\n-            public Node selectLast(TraversalContext context) {\n+            public Node selectLast(Parent root) {\n@@ -98,1 +90,1 @@\n-        }));\n+        });\n@@ -104,1 +96,1 @@\n-        ParentHelper.setTraversalEngine(g, new ParentTraversalEngine(g, new Algorithm() {\n+        TraversalUtils.setTraversalPolicy(g, new TraversalPolicy() {\n@@ -106,1 +98,1 @@\n-            public Node select(Node owner, Direction dir, TraversalContext context) {\n+            public Node select(Parent root, Node owner, TraversalDirectionInternal dir) {\n@@ -112,1 +104,1 @@\n-            public Node selectFirst(TraversalContext context) {\n+            public Node selectFirst(Parent root) {\n@@ -117,1 +109,1 @@\n-            public Node selectLast(TraversalContext context) {\n+            public Node selectLast(Parent root) {\n@@ -121,1 +113,1 @@\n-        }));\n+        });\n@@ -125,1 +117,1 @@\n-        assertEquals(focusableNode, engine.selectFirst());\n+        assertEquals(focusableNode, engine.selectFirst(root));\n@@ -134,1 +126,1 @@\n-        assertEquals(g, engine.selectFirst());\n+        assertEquals(g, engine.selectFirst(root));\n@@ -141,3 +133,3 @@\n-        final ParentTraversalEngine pEngine = new ParentTraversalEngine(g);\n-        pEngine.setOverriddenFocusTraversability(false);\n-        ParentHelper.setTraversalEngine(g, pEngine);\n+        OverridableTraversalPolicy policy = new OverridableTraversalPolicy();\n+        policy.setOverriddenFocusTraversability(false);\n+        TraversalUtils.setTraversalPolicy(g, policy);\n@@ -147,1 +139,1 @@\n-        assertEquals(ParentShim.getChildren(g).get(0), engine.selectFirst());\n+        assertEquals(ParentShim.getChildren(g).get(0), engine.selectFirst(root));\n@@ -157,1 +149,1 @@\n-        assertEquals(focusableNode, engine.selectLast());\n+        assertEquals(focusableNode, engine.selectLast(root));\n@@ -166,1 +158,1 @@\n-        assertEquals(n1, engine.selectFirst());\n+        assertEquals(n1, engine.selectFirst(root));\n@@ -173,1 +165,1 @@\n-        ParentHelper.setTraversalEngine(g, new ParentTraversalEngine(g, new Algorithm() {\n+        TraversalUtils.setTraversalPolicy(g, new TraversalPolicy() {\n@@ -175,1 +167,1 @@\n-            public Node select(Node owner, Direction dir, TraversalContext context) {\n+            public Node select(Parent root, Node owner, TraversalDirectionInternal dir) {\n@@ -181,1 +173,1 @@\n-            public Node selectFirst(TraversalContext context) {\n+            public Node selectFirst(Parent root) {\n@@ -187,1 +179,1 @@\n-            public Node selectLast(TraversalContext context) {\n+            public Node selectLast(Parent root) {\n@@ -190,1 +182,1 @@\n-        }));\n+        });\n@@ -196,1 +188,1 @@\n-        ParentHelper.setTraversalEngine(g, new ParentTraversalEngine(g, new Algorithm() {\n+        TraversalUtils.setTraversalPolicy(g, new TraversalPolicy() {\n@@ -198,1 +190,1 @@\n-            public Node select(Node owner, Direction dir, TraversalContext context) {\n+            public Node select(Parent root, Node owner, TraversalDirectionInternal dir) {\n@@ -203,1 +195,1 @@\n-            public Node selectFirst(TraversalContext context) {\n+            public Node selectFirst(Parent root) {\n@@ -208,1 +200,1 @@\n-            public Node selectLast(TraversalContext context) {\n+            public Node selectLast(Parent root) {\n@@ -211,1 +203,1 @@\n-        }));\n+        });\n@@ -216,1 +208,1 @@\n-        assertEquals(focusableNode, engine.selectLast());\n+        assertEquals(focusableNode, engine.selectLast(root));\n@@ -226,1 +218,1 @@\n-        assertEquals(focusableNode, engine.selectLast());\n+        assertEquals(focusableNode, engine.selectLast(root));\n@@ -235,1 +227,1 @@\n-        assertEquals(g, engine.selectLast());\n+        assertEquals(g, engine.selectLast(root));\n@@ -242,3 +234,3 @@\n-        final ParentTraversalEngine pEngine = new ParentTraversalEngine(g);\n-        pEngine.setOverriddenFocusTraversability(false);\n-        ParentHelper.setTraversalEngine(g, pEngine);\n+        OverridableTraversalPolicy policy = new OverridableTraversalPolicy();\n+        policy.setOverriddenFocusTraversability(false);\n+        TraversalUtils.setTraversalPolicy(g, policy);\n@@ -250,1 +242,1 @@\n-        assertEquals(focusableNode, engine.selectLast());\n+        assertEquals(focusableNode, engine.selectLast(root));\n@@ -261,1 +253,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n+        assertEquals(n2, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.NEXT, false));\n@@ -273,1 +265,1 @@\n-        assertEquals(ng1, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n+        assertEquals(ng1, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.NEXT, false));\n@@ -284,1 +276,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n+        assertEquals(n2, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.NEXT, false));\n@@ -295,1 +287,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n+        assertEquals(n2, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.NEXT, false));\n@@ -306,1 +298,1 @@\n-        assertEquals(g, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n+        assertEquals(g, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.NEXT, false));\n@@ -314,1 +306,1 @@\n-        ParentHelper.setTraversalEngine(g, new ParentTraversalEngine(g, new Algorithm() {\n+        TraversalUtils.setTraversalPolicy(g, new TraversalPolicy() {\n@@ -316,2 +308,2 @@\n-            public Node select(Node owner, Direction dir, TraversalContext context) {\n-                assertEquals(Direction.NEXT, dir);\n+            public Node select(Parent root, Node owner, TraversalDirectionInternal dir) {\n+                assertEquals(TraversalDirectionInternal.NEXT, dir);\n@@ -322,1 +314,1 @@\n-            public Node selectFirst(TraversalContext context) {\n+            public Node selectFirst(Parent root) {\n@@ -328,1 +320,1 @@\n-            public Node selectLast(TraversalContext context) {\n+            public Node selectLast(Parent root) {\n@@ -332,1 +324,1 @@\n-        }));\n+        });\n@@ -336,1 +328,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n+        assertEquals(n2, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.NEXT, false));\n@@ -346,1 +338,1 @@\n-        ParentHelper.setTraversalEngine(g, new ParentTraversalEngine(g, new Algorithm() {\n+        TraversalUtils.setTraversalPolicy(g, new TraversalPolicy() {\n@@ -348,2 +340,2 @@\n-            public Node select(Node owner, Direction dir, TraversalContext context) {\n-                assertEquals(Direction.NEXT, dir);\n+            public Node select(Parent root, Node owner, TraversalDirectionInternal dir) {\n+                assertEquals(TraversalDirectionInternal.NEXT, dir);\n@@ -354,1 +346,1 @@\n-            public Node selectFirst(TraversalContext context) {\n+            public Node selectFirst(Parent root) {\n@@ -360,1 +352,1 @@\n-            public Node selectLast(TraversalContext context) {\n+            public Node selectLast(Parent root) {\n@@ -364,1 +356,1 @@\n-        }));\n+        });\n@@ -369,1 +361,1 @@\n-        assertEquals(n3, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n+        assertEquals(n3, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.NEXT, false));\n@@ -381,1 +373,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT_IN_LINE, TraversalMethod.DEFAULT));\n+        assertEquals(n2, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.NEXT_IN_LINE, false));\n@@ -393,1 +385,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n+        assertEquals(n2, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.PREVIOUS, false));\n@@ -405,1 +397,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n+        assertEquals(n2, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.PREVIOUS, false));\n@@ -416,1 +408,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n+        assertEquals(n2, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.PREVIOUS, false));\n@@ -428,1 +420,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n+        assertEquals(n2, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.PREVIOUS, false));\n@@ -440,1 +432,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n+        assertEquals(n2, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.PREVIOUS, false));\n@@ -452,1 +444,1 @@\n-        assertEquals(g, engine.trav(n2, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n+        assertEquals(g, TopMostTraversalEngine.trav(root, n2, TraversalDirectionInternal.PREVIOUS, false));\n@@ -462,1 +454,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.NEXT, TraversalMethod.DEFAULT));\n+        assertEquals(n2, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.NEXT, false));\n@@ -473,1 +465,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n+        assertEquals(n2, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.PREVIOUS, false));\n@@ -482,1 +474,1 @@\n-        ParentHelper.setTraversalEngine(g, new ParentTraversalEngine(g, new Algorithm() {\n+        TraversalUtils.setTraversalPolicy(g, new TraversalPolicy() {\n@@ -484,2 +476,2 @@\n-            public Node select(Node owner, Direction dir, TraversalContext context) {\n-                assertEquals(Direction.PREVIOUS, dir);\n+            public Node select(Parent root, Node owner, TraversalDirectionInternal dir) {\n+                assertEquals(TraversalDirectionInternal.PREVIOUS, dir);\n@@ -490,1 +482,1 @@\n-            public Node selectFirst(TraversalContext context) {\n+            public Node selectFirst(Parent root) {\n@@ -496,1 +488,1 @@\n-            public Node selectLast(TraversalContext context) {\n+            public Node selectLast(Parent root) {\n@@ -500,1 +492,1 @@\n-        }));\n+        });\n@@ -504,1 +496,1 @@\n-        assertEquals(n2, engine.trav(n1, Direction.PREVIOUS, TraversalMethod.DEFAULT));\n+        assertEquals(n2, TopMostTraversalEngine.trav(root, n1, TraversalDirectionInternal.PREVIOUS, false));\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/traversal\/TopMostTraversalEngineTest.java","additions":82,"deletions":90,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -0,0 +1,478 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.com.sun.javafx.scene.traversal;\n+\n+import javafx.scene.Node;\n+import javafx.scene.Parent;\n+import javafx.scene.Scene;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.shape.Rectangle;\n+import javafx.stage.Stage;\n+import org.junit.AfterClass;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n+import com.sun.javafx.scene.traversal.TraversalPolicy;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n+import com.sun.javafx.tk.Toolkit;\n+import test.com.sun.javafx.pgstub.StubToolkit;\n+\n+\/**\n+ * Tests TraversalPolicy APIs using the default and a custom traversal policies.\n+ *\/\n+public final class TraversalPolicyTest {\n+    private static StubToolkit tk;\n+    private static Stage stage;\n+    private static Scene scene;\n+    private static GridPane grid;\n+    private static Node t0;\n+    private static Node t1;\n+    private static Node t2;\n+    private static Node t3;\n+    private static Node b00;\n+    private static Node b01;\n+    private static Node b02;\n+    private static Node b10;\n+    private static Node b11;\n+    private static Node b12;\n+    private static Node b20;\n+    private static Node b21;\n+    private static Node b22;\n+\n+    \/**\n+     * [T.0] [T.1] [T.2] [T.3]\n+     * -----------------------\n+     * [G.0.0] [G.1.0] [G.2.0]\n+     * [G.0.1] [G.1.1] [G.2.1]\n+     * [G.0.2] [G.1.2] [G.2.2]\n+     *\/\n+    @BeforeEach\n+    void beforeClass() {\n+        tk = (StubToolkit)Toolkit.getToolkit();\n+\n+        t0 = b(\"T.0\");\n+        t1 = b(\"T.1\");\n+        t2 = b(\"T.2\");\n+        t3 = b(\"T.3\");\n+\n+        b00 = b(\"b.0.0\");\n+        b01 = b(\"b.0.1\");\n+        b02 = b(\"b.0.2\");\n+        b10 = b(\"b.1.0\");\n+        b11 = b(\"b.1.1\");\n+        b12 = b(\"b.1.2\");\n+        b20 = b(\"b.2.0\");\n+        b21 = b(\"b.2.1\");\n+        b22 = b(\"b.2.2\");\n+\n+        grid = new GridPane();\n+        grid.add(b00, 0, 0);\n+        grid.add(b01, 0, 1);\n+        grid.add(b02, 0, 2);\n+        grid.add(b10, 1, 0);\n+        grid.add(b11, 1, 1);\n+        grid.add(b12, 1, 2);\n+        grid.add(b20, 2, 0);\n+        grid.add(b21, 2, 1);\n+        grid.add(b22, 2, 2);\n+\n+        BorderPane bp = new BorderPane(grid);\n+        bp.setTop(new HBox(\n+            t0,\n+            t1,\n+            t2,\n+            t3\n+        ));\n+\n+        scene = new Scene(bp, 500, 400);\n+        stage = new Stage();\n+        stage.setScene(scene);\n+        stage.show();\n+    }\n+\n+    @BeforeEach\n+    void beforeEach() {\n+        TraversalUtils.setTraversalPolicy(grid, null);\n+        stage.requestFocus();\n+        firePulse();\n+        t0.requestFocus();\n+        firePulse();\n+    }\n+\n+    @AfterEach\n+    void afterEach() {\n+        if (stage != null) {\n+            stage.hide();\n+            stage = null;\n+        }\n+        scene = null;\n+    }\n+\n+    @AfterClass\n+    static void afterClass() {\n+        if (stage != null) {\n+            stage.hide();\n+            stage = null;\n+        }\n+    }\n+\n+    void traverse(Node from, TraversalDirectionInternal dir, Node... nodes) {\n+        from.requestFocus();\n+        firePulse();\n+        checkFocused(from);\n+\n+        for (Node n : nodes) {\n+            boolean success = TraversalUtils.traverse(from, dir, false);\n+            Assertions.assertTrue(success, \"failed to traverse from node: \" + from);\n+            firePulse();\n+            checkFocused(n);\n+            checkEventNode(n);\n+            from = n;\n+        }\n+    }\n+\n+    void checkFocused(Node n) {\n+        Assertions.assertTrue(n.isFocused(), \"expecting focused node: \" + n);\n+    }\n+\n+    void checkEventNode(Node n) {\n+        Node fromEvent = scene.getFocusOwner();\n+        Assertions.assertTrue(fromEvent == n, \"TraversalEvent.node is wrong, expecting=\" + n + \", observed=\" + fromEvent);\n+        \/\/System.out.println(fromEvent);\n+    }\n+\n+    static void setCustomPolicy() {\n+        TraversalUtils.setTraversalPolicy(grid, customTraversalPolicy(\n+            b00,\n+            b10,\n+            b20,\n+            b01,\n+            b11,\n+            b21,\n+            b02,\n+            b12,\n+            b22\n+      ));\n+    }\n+\n+    private static Rectangle b(String text) {\n+        Rectangle b = new Rectangle() {\n+            @Override\n+            public String toString() {\n+                return text;\n+            }\n+        };\n+        b.setWidth(80);\n+        b.setHeight(40);\n+        b.setFocusTraversable(true);\n+        return b;\n+    }\n+\n+    private static void firePulse() {\n+        tk.firePulse();\n+    }\n+\n+    static TraversalPolicy customTraversalPolicy(Node... nodes) {\n+        \/\/ This custom policy differs from default by explicitly specifying the traversal order.\n+        return new TraversalPolicy() {\n+            @Override\n+            public Node select(Parent root, Node owner, TraversalDirectionInternal dir) {\n+                int ix = indexOf(owner);\n+                if (ix < 0) {\n+                    return null;\n+                }\n+\n+                switch (dir) {\n+                case NEXT:\n+                    if (ix >= (nodes.length - 1)) {\n+                        \/\/ traversing up the stack from last node\n+                        return findNextFocusableNode(root, owner);\n+                    }\n+                    ix++;\n+                    break;\n+                case NEXT_IN_LINE:\n+                    if (ix >= (nodes.length - 1)) {\n+                        \/\/ traversing up the stack from last node\n+                        return findNextInLineFocusableNode(root, owner);\n+                    }\n+                    ix++;\n+                    break;\n+                case PREVIOUS:\n+                    if (ix <= 0) {\n+                        \/\/ traversing up the stack from the first node\n+                        return findPreviousFocusableNode(root, owner);\n+                    }\n+                    ix--;\n+                    break;\n+                case LEFT:\n+                case UP:\n+                    ix--;\n+                    break;\n+                case DOWN:\n+                case RIGHT:\n+                default:\n+                    ix++;\n+                }\n+\n+                if (ix < 0) {\n+                    return selectLast(root);\n+                } else if (ix >= nodes.length) {\n+                    return selectFirst(root);\n+                }\n+                return nodes[ix];\n+            }\n+\n+            @Override\n+            public Node selectFirst(Parent root) {\n+                return nodes[0];\n+            }\n+\n+            @Override\n+            public Node selectLast(Parent root) {\n+                int ix = nodes.length - 1;\n+                if (ix < 0) {\n+                    return null;\n+                }\n+                return nodes[ix];\n+            }\n+\n+            private int indexOf(Node n) {\n+                for (int i = nodes.length - 1; i >= 0; --i) {\n+                    if (nodes[i] == n) {\n+                        return i;\n+                    }\n+                }\n+                return -1;\n+            }\n+        };\n+    }\n+\n+    \/\/ direction: DOWN, default policy\n+    @Test\n+    void testDefaultPolicy_DOWN() {\n+        traverse(\n+            t0,\n+            TraversalDirectionInternal.DOWN,\n+            b00, b01, b02\n+        );\n+    }\n+\n+    \/\/ direction: DOWN, custom policy\n+    @Test\n+    void testCustomPolicy_DOWN() {\n+        setCustomPolicy();\n+        traverse(\n+            t0,\n+            TraversalDirectionInternal.DOWN,\n+            b00, b10, b20,\n+            b01, b11, b21,\n+            b02, b12, b22,\n+            b00, b10\n+        );\n+    }\n+\n+    \/\/ direction: LEFT, default policy\n+    @Test\n+    void testDefaultPolicy_LEFT() {\n+        traverse(\n+            t3,\n+            TraversalDirectionInternal.LEFT,\n+            t2, t1, t0\n+        );\n+    }\n+\n+    \/\/ direction: LEFT, default policy\n+    @Test\n+    void testDefaultPolicy_LEFT2() {\n+        traverse(\n+            b20,\n+            TraversalDirectionInternal.LEFT,\n+            b10, b00\n+        );\n+    }\n+\n+    \/\/ direction: LEFT, custom policy, start at B20\n+    @Test\n+    void testCustomPolicy_LEFT() {\n+        setCustomPolicy();\n+        traverse(\n+            b20,\n+            TraversalDirectionInternal.LEFT,\n+            b10, b00,\n+            b22, b12, b02,\n+            b21, b11, b01,\n+            b20, b10, b00,\n+            b22\n+        );\n+    }\n+\n+    \/\/ direction: NEXT, default policy\n+    @Test\n+    void testDefaultPolicy_NEXT() {\n+        traverse(\n+            t0,\n+            TraversalDirectionInternal.NEXT,\n+            t1, t2, t3,\n+            b00, b01, b02,\n+            b10, b11, b12,\n+            b20, b21, b22,\n+            t0, t1, t2, t3\n+        );\n+    }\n+\n+    \/\/ direction: NEXT, custom policy\n+    @Test\n+    void testCustomPolicy_NEXT() {\n+        setCustomPolicy();\n+        traverse(\n+            t0,\n+            TraversalDirectionInternal.NEXT,\n+            t1, t2, t3,\n+            b00, b10, b20,\n+            b01, b11, b21,\n+            b02, b12, b22,\n+            t0, t1, t2, t3\n+        );\n+    }\n+\n+    \/\/ direction: NEXT_IN_LINE, default policy\n+    @Test\n+    void testDefaultPolicy_NEXT_IN_LINE() {\n+        traverse(\n+            t0,\n+            TraversalDirectionInternal.NEXT_IN_LINE,\n+            t1, t2, t3,\n+            b00, b01, b02,\n+            b10, b11, b12,\n+            b20, b21, b22,\n+            t0, t1, t2, t3\n+        );\n+    }\n+\n+    \/\/ direction: NEXT_IN_LINE, custom policy\n+    @Test\n+    void testCustomPolicy_NEXT_IN_LINE() {\n+        setCustomPolicy();\n+        traverse(\n+            t0,\n+            TraversalDirectionInternal.NEXT_IN_LINE,\n+            t1, t2, t3,\n+            b00, b10, b20,\n+            b01, b11, b21,\n+            b02, b12, b22,\n+            t0, t1, t2, t3\n+        );\n+    }\n+\n+    \/\/ direction: PREVIOUS, default policy\n+    @Test\n+    void testDefaultPolicy_PREVIOUS() {\n+        traverse(\n+            t3,\n+            TraversalDirectionInternal.PREVIOUS,\n+            t2, t1, t0,\n+            b22\n+        );\n+    }\n+\n+    \/\/ direction: PREVIOUS, custom policy\n+    @Test\n+    void testCustomPolicy_PREVIOUS() {\n+        setCustomPolicy();\n+        traverse(\n+            t3,\n+            TraversalDirectionInternal.PREVIOUS,\n+            t2, t1, t0,\n+            b22, b12, b02,\n+            b21, b11, b01,\n+            b20, b10, b00,\n+            t3, t2, t1, t0,\n+            b22\n+        );\n+    }\n+\n+    \/\/ direction: RIGHT, default policy\n+    @Test\n+    void testDefaultPolicy_RIGHT() {\n+        traverse(\n+            t0,\n+            TraversalDirectionInternal.RIGHT,\n+            t1, t2, t3\n+        );\n+    }\n+\n+    \/\/ direction: RIGHT, default policy, start at B00\n+    @Test\n+    void testDefaultPolicy_RIGHT2() {\n+        traverse(\n+            b00,\n+            TraversalDirectionInternal.RIGHT,\n+            b10, b20,\n+            t3\n+        );\n+    }\n+\n+    \/\/ direction: RIGHT, custom policy\n+    @Test\n+    void testCustomPolicy_RIGHT() {\n+        setCustomPolicy();\n+        traverse(\n+            b00,\n+            TraversalDirectionInternal.RIGHT,\n+            b10, b20,\n+            b01, b11, b21,\n+            b02, b12, b22,\n+            b00\n+        );\n+    }\n+\n+    \/\/ direction: UP, default policy\n+    @Test\n+    void testDefaultPolicy_UP() {\n+        traverse(\n+            b02,\n+            TraversalDirectionInternal.UP,\n+            b01, b00, t0\n+        );\n+    }\n+\n+    \/\/ direction: UP, custom policy\n+    @Test\n+    void testCustomPolicy_UP() {\n+        setCustomPolicy();\n+        traverse(\n+            b02,\n+            TraversalDirectionInternal.UP,\n+            b21, b11, b01,\n+            b20, b10, b00,\n+            b22, b12, b02\n+        );\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/traversal\/TraversalPolicyTest.java","additions":478,"deletions":0,"binary":false,"changes":478,"status":"added"},{"patch":"@@ -28,6 +28,1 @@\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.SceneTraversalEngine;\n-import com.sun.javafx.scene.traversal.TraversalEngine;\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n-import com.sun.javafx.scene.traversal.TraverseListener;\n-\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -35,2 +30,0 @@\n-\n-import javafx.geometry.Bounds;\n@@ -42,1 +35,0 @@\n-\n@@ -48,3 +40,2 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertSame;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import com.sun.javafx.scene.traversal.TopMostTraversalEngine;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n@@ -53,3 +44,1 @@\n- * Tests for TraversalEngine with the default ContainerTabOrder algorithm,\n- * tests if using the WeightedClosestCorner algorithm have been\n- * left in comments.\n+ * Tests for TraversalEngine with the default ContainerTabOrder policy.\n@@ -78,1 +67,0 @@\n-    private SceneTraversalEngine traversalEngine;\n@@ -81,1 +69,1 @@\n-     * Parameters: [fromNumber], [direction], [toNumber], [toNumberTransformed]\n+     * Parameters: [fromNumber], [traversalDirection], [toNumber], [toNumberTransformed]\n@@ -83,1 +71,1 @@\n-    public static Stream<Arguments> data() {\n+    private static Stream<Arguments> parameters() {\n@@ -86,8 +74,4 @@\n-            Arguments.of( 5, Direction.LEFT, 4, 8 ),\n-            Arguments.of( 5, Direction.RIGHT, 6, 2 ),\n-            Arguments.of( 5, Direction.UP, 2, 4 ),\n-            Arguments.of( 5, Direction.DOWN, 8, 6 ),\n-\n-            \/\/ using WeightedClosestCorner, target varies according to transform\n-            \/\/Arguments.of( 5, Direction.PREVIOUS, 4, 8 ),\n-            \/\/Arguments.of( 5, Direction.NEXT, 6, 2 ),\n+            Arguments.of( 5, TraversalDirectionInternal.LEFT, 4, 8 ),\n+            Arguments.of( 5, TraversalDirectionInternal.RIGHT, 6, 2 ),\n+            Arguments.of( 5, TraversalDirectionInternal.UP, 2, 4 ),\n+            Arguments.of( 5, TraversalDirectionInternal.DOWN, 8, 6 ),\n@@ -96,2 +80,2 @@\n-            Arguments.of( 5, Direction.PREVIOUS, 4, 4 ),\n-            Arguments.of( 5, Direction.NEXT, 6, 6 ),\n+            Arguments.of( 5, TraversalDirectionInternal.PREVIOUS, 4, 4 ),\n+            Arguments.of( 5, TraversalDirectionInternal.NEXT, 6, 6 ),\n@@ -100,10 +84,4 @@\n-            Arguments.of( 4, Direction.LEFT, 4, 7 ),\n-            Arguments.of( 6, Direction.RIGHT, 6, 3 ),\n-            Arguments.of( 2, Direction.UP, 2, 1 ),\n-            Arguments.of( 8, Direction.DOWN, 8, 9 ),\n-\n-            \/\/ using WeightedClosestCorner, target varies according to transform\n-            \/\/Arguments.of( 4, Direction.PREVIOUS, 3, 7 ),\n-            \/\/Arguments.of( 1, Direction.PREVIOUS, 9, 4 ),\n-            \/\/Arguments.of( 6, Direction.NEXT, 7, 3 ),\n-            \/\/Arguments.of( 9, Direction.NEXT, 1, 6 ),\n+            Arguments.of( 4, TraversalDirectionInternal.LEFT, 4, 7 ),\n+            Arguments.of( 6, TraversalDirectionInternal.RIGHT, 6, 3 ),\n+            Arguments.of( 2, TraversalDirectionInternal.UP, 2, 1 ),\n+            Arguments.of( 8, TraversalDirectionInternal.DOWN, 8, 9 ),\n@@ -112,4 +90,4 @@\n-            Arguments.of( 4, Direction.PREVIOUS, 3, 3 ),\n-            Arguments.of( 1, Direction.PREVIOUS, 9, 9 ),\n-            Arguments.of( 6, Direction.NEXT, 7, 7 ),\n-            Arguments.of( 9, Direction.NEXT, 1, 1 ),\n+            Arguments.of( 4, TraversalDirectionInternal.PREVIOUS, 3, 3 ),\n+            Arguments.of( 1, TraversalDirectionInternal.PREVIOUS, 9, 9 ),\n+            Arguments.of( 6, TraversalDirectionInternal.NEXT, 7, 7 ),\n+            Arguments.of( 9, TraversalDirectionInternal.NEXT, 1, 1 ),\n@@ -118,10 +96,4 @@\n-            Arguments.of( 2, Direction.RIGHT, 3, 2 ),\n-            Arguments.of( 8, Direction.LEFT, 7, 8 ),\n-            Arguments.of( 4, Direction.UP, 1, 4 ),\n-            Arguments.of( 6, Direction.DOWN, 9, 6 ),\n-\n-            \/\/ using WeightedClosestCorner, target varies according to transform\n-            \/\/Arguments.of( 8, Direction.PREVIOUS, 7, 1 ),\n-            \/\/Arguments.of( 7, Direction.PREVIOUS, 6, 3 ),\n-            \/\/Arguments.of( 2, Direction.NEXT, 3, 9 ),\n-            \/\/Arguments.of( 3, Direction.NEXT, 4, 7)}\n+            Arguments.of( 2, TraversalDirectionInternal.RIGHT, 3, 2 ),\n+            Arguments.of( 8, TraversalDirectionInternal.LEFT, 7, 8 ),\n+            Arguments.of( 4, TraversalDirectionInternal.UP, 1, 4 ),\n+            Arguments.of( 6, TraversalDirectionInternal.DOWN, 9, 6 ),\n@@ -130,4 +102,4 @@\n-            Arguments.of( 8, Direction.PREVIOUS, 7, 7 ),\n-            Arguments.of( 7, Direction.PREVIOUS, 6, 6 ),\n-            Arguments.of( 2, Direction.NEXT, 3, 3 ),\n-            Arguments.of( 3, Direction.NEXT, 4, 4)\n+            Arguments.of( 8, TraversalDirectionInternal.PREVIOUS, 7, 7 ),\n+            Arguments.of( 7, TraversalDirectionInternal.PREVIOUS, 6, 6 ),\n+            Arguments.of( 2, TraversalDirectionInternal.NEXT, 3, 3 ),\n+            Arguments.of( 3, TraversalDirectionInternal.NEXT, 4, 4)\n@@ -143,3 +115,1 @@\n-        traversalEngine = new SceneTraversalEngine(scene);\n-\n-        keypadNodes = createKeypadNodesInScene(scene, traversalEngine);\n+        keypadNodes = createKeypadNodesInScene(scene);\n@@ -153,0 +123,3 @@\n+        if (stage != null) {\n+            stage.hide();\n+        }\n@@ -156,1 +129,0 @@\n-        traversalEngine = null;\n@@ -160,5 +132,7 @@\n-    @MethodSource(\"data\")\n-    public void untransformedTraversalTest(int fromNumber,\n-                                           Direction direction,\n-                                           int toNumber,\n-                                           int toNumberTransformed) {\n+    @MethodSource(\"parameters\")\n+    public void untransformedTraversalTest(\n+        int fromNumber,\n+        TraversalDirectionInternal direction,\n+        int toNumber,\n+        int toNumberTransformed)\n+    {\n@@ -166,1 +140,1 @@\n-        traversalEngine.trav(keypadNodes[fromNumber - 1], direction, TraversalMethod.DEFAULT);\n+        TopMostTraversalEngine.trav(scene.getRoot(), keypadNodes[fromNumber - 1], direction, false);\n@@ -171,5 +145,7 @@\n-    @MethodSource(\"data\")\n-    public void transformedTraversalTest(int fromNumber,\n-                                         Direction direction,\n-                                         int toNumber,\n-                                         int toNumberTransformed) {\n+    @MethodSource(\"parameters\")\n+    public void transformedTraversalTest(\n+        int fromNumber,\n+        TraversalDirectionInternal direction,\n+        int toNumber,\n+        int toNumberTransformed)\n+    {\n@@ -178,1 +154,1 @@\n-        traversalEngine.trav(keypadNodes[fromNumber - 1], direction, TraversalMethod.DEFAULT);\n+        TopMostTraversalEngine.trav(scene.getRoot(), keypadNodes[fromNumber - 1], direction, false);\n@@ -182,23 +158,1 @@\n-    @ParameterizedTest\n-    @MethodSource(\"data\")\n-    public void traverseListenerTest(int fromNumber,\n-                                     Direction direction,\n-                                     int toNumber,\n-                                     int toNumberTransformed) {\n-        final TraverseListenerImpl traverseListener =\n-                new TraverseListenerImpl();\n-        traversalEngine.addTraverseListener(traverseListener);\n-        keypadNodes[fromNumber - 1].requestFocus();\n-        traversalEngine.trav(keypadNodes[fromNumber - 1], direction, TraversalMethod.DEFAULT);\n-        if (fromNumber != toNumber) {\n-            assertEquals(1, traverseListener.getCallCounter());\n-            assertSame(keypadNodes[toNumber - 1],\n-                       traverseListener.getLastNode());\n-        } else {\n-            assertEquals(0, traverseListener.getCallCounter());\n-        }\n-    }\n-\n-    private static Node[] createKeypadNodesInScene(\n-            final Scene scene,\n-            final TraversalEngine traversalEngine) {\n+    private static Node[] createKeypadNodesInScene(final Scene scene) {\n@@ -222,20 +176,0 @@\n-\n-    private static final class TraverseListenerImpl\n-            implements TraverseListener {\n-        private int callCounter;\n-        private Node lastNode;\n-\n-        public int getCallCounter() {\n-            return callCounter;\n-        }\n-\n-        public Node getLastNode() {\n-            return lastNode;\n-        }\n-\n-        @Override\n-        public void onTraverse(final Node node, final Bounds bounds) {\n-            ++callCounter;\n-            lastNode = node;\n-        }\n-    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/traversal\/TraversalTest.java","additions":49,"deletions":115,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -28,6 +28,1 @@\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.SceneTraversalEngine;\n-import com.sun.javafx.scene.traversal.TraversalEngine;\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n-import com.sun.javafx.scene.traversal.TraverseListener;\n-\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -35,2 +30,0 @@\n-\n-import javafx.geometry.Bounds;\n@@ -42,1 +35,0 @@\n-\n@@ -48,1 +40,2 @@\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import com.sun.javafx.scene.traversal.TopMostTraversalEngine;\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n@@ -57,1 +50,0 @@\n-    private SceneTraversalEngine traversalEngine;\n@@ -60,1 +52,0 @@\n-    **\n@@ -67,1 +58,1 @@\n-    public static Stream<Arguments> data() {\n+    private static Stream<Arguments> parameters() {\n@@ -69,6 +60,6 @@\n-            Arguments.of( 3, Direction.RIGHT, 4, 5),\n-            Arguments.of( 5, Direction.LEFT, 4, 3),\n-            Arguments.of( 4, Direction.NEXT, 5, 6),\n-            Arguments.of( 6, Direction.PREVIOUS, 5, 4),\n-            Arguments.of( 8, Direction.UP, 5, 2 ),\n-            Arguments.of( 2, Direction.DOWN, 5, 8)\n+            Arguments.of( 3, TraversalDirectionInternal.RIGHT, 4, 5),\n+            Arguments.of( 5, TraversalDirectionInternal.LEFT, 4, 3),\n+            Arguments.of( 4, TraversalDirectionInternal.NEXT, 5, 6),\n+            Arguments.of( 6, TraversalDirectionInternal.PREVIOUS, 5, 4),\n+            Arguments.of( 8, TraversalDirectionInternal.UP, 5, 2 ),\n+            Arguments.of( 2, TraversalDirectionInternal.DOWN, 5, 8)\n@@ -84,3 +75,1 @@\n-        traversalEngine = new SceneTraversalEngine(scene);\n-\n-        keypadNodes = createKeypadNodesInScene(scene, traversalEngine);\n+        keypadNodes = createKeypadNodesInScene(scene);\n@@ -96,1 +85,0 @@\n-        traversalEngine = null;\n@@ -100,5 +88,7 @@\n-    @MethodSource(\"data\")\n-    public void traverseOverInvisible(int fromNumber,\n-                                      Direction direction,\n-                                      int invisibleNumber,\n-                                      int toNumber) {\n+    @MethodSource(\"parameters\")\n+    public void traverseOverInvisible(\n+        int fromNumber,\n+        TraversalDirectionInternal direction,\n+        int invisibleNumber,\n+        int toNumber)\n+    {\n@@ -107,1 +97,1 @@\n-        traversalEngine.trav(keypadNodes[fromNumber], direction, TraversalMethod.DEFAULT);\n+        TopMostTraversalEngine.trav(scene.getRoot(), keypadNodes[fromNumber], direction, false);\n@@ -114,5 +104,1 @@\n-\n-\n-    private static Node[] createKeypadNodesInScene(\n-            final Scene scene,\n-            final TraversalEngine traversalEngine) {\n+    private static Node[] createKeypadNodesInScene(final Scene scene) {\n@@ -136,20 +122,0 @@\n-\n-    private static final class TraverseListenerImpl\n-            implements TraverseListener {\n-        private int callCounter;\n-        private Node lastNode;\n-\n-        public int getCallCounter() {\n-            return callCounter;\n-        }\n-\n-        public Node getLastNode() {\n-            return lastNode;\n-        }\n-\n-        @Override\n-        public void onTraverse(final Node node, final Bounds bounds) {\n-            ++callCounter;\n-            lastNode = node;\n-        }\n-    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/traversal\/TraverseInvisibleTest.java","additions":20,"deletions":54,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,5 @@\n-import com.sun.javafx.scene.ParentHelper;\n-import com.sun.javafx.scene.control.behavior.BehaviorBase;\n-import com.sun.javafx.scene.control.inputmap.InputMap;\n-import com.sun.javafx.scene.control.inputmap.KeyBinding;\n+import static javafx.scene.input.KeyCode.B;\n+import static javafx.scene.input.KeyCode.F12;\n+import static javafx.scene.input.KeyCode.I;\n+import static javafx.scene.input.KeyCode.TAB;\n+import static javafx.scene.input.KeyCode.U;\n@@ -34,0 +35,1 @@\n+import com.sun.javafx.scene.control.behavior.BehaviorBase;\n@@ -35,3 +37,4 @@\n-\n-import static javafx.scene.input.KeyCode.*;\n-import static com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;\n+import com.sun.javafx.scene.control.inputmap.InputMap;\n+import com.sun.javafx.scene.control.inputmap.InputMap.KeyMapping;\n+import com.sun.javafx.scene.control.inputmap.KeyBinding;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -54,1 +57,1 @@\n-            new KeyMapping(new KeyBinding(F12), e -> ParentHelper.getTraversalEngine(getNode()).selectFirst().requestFocus()),\n+            new KeyMapping(new KeyBinding(F12), e -> selectFirst()),\n@@ -69,0 +72,5 @@\n+\n+    void selectFirst() {\n+        var n = getNode();\n+        TraversalUtils.getTraversalPolicy(n).selectFirst(n).requestFocus();\n+    }\n","filename":"modules\/javafx.web\/src\/main\/java\/com\/sun\/javafx\/scene\/web\/behavior\/HTMLEditorBehavior.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import com.sun.javafx.scene.NodeHelper;\n@@ -32,3 +31,0 @@\n-\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.TraversalMethod;\n@@ -43,1 +39,2 @@\n-\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -114,2 +111,3 @@\n-    @Override public void transferFocus(boolean forward) {\n-        NodeHelper.traverse(accessor.getView(), forward ? Direction.NEXT : Direction.PREVIOUS, TraversalMethod.DEFAULT);\n+    @Override\n+    public void transferFocus(boolean forward) {\n+        TraversalUtils.traverse(accessor.getView(), forward ? TraversalDirectionInternal.NEXT : TraversalDirectionInternal.PREVIOUS, false);\n","filename":"modules\/javafx.web\/src\/main\/java\/com\/sun\/javafx\/webkit\/WebPageClientImpl.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+import static javafx.geometry.NodeOrientation.RIGHT_TO_LEFT;\n+import static javafx.scene.web.HTMLEditorSkin.Command.*;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n@@ -29,12 +36,0 @@\n-\n-import com.sun.javafx.application.PlatformImpl;\n-import com.sun.javafx.scene.ParentHelper;\n-import com.sun.javafx.scene.traversal.Algorithm;\n-import com.sun.javafx.scene.traversal.Direction;\n-import com.sun.javafx.scene.traversal.ParentTraversalEngine;\n-import com.sun.javafx.scene.traversal.TraversalContext;\n-import javafx.css.PseudoClass;\n-import javafx.geometry.Orientation;\n-import org.w3c.dom.html.HTMLDocument;\n-import org.w3c.dom.html.HTMLElement;\n-\n@@ -44,0 +39,1 @@\n+import javafx.collections.ListChangeListener;\n@@ -45,0 +41,1 @@\n+import javafx.css.PseudoClass;\n@@ -47,0 +44,2 @@\n+import javafx.geometry.Orientation;\n+import javafx.print.PrinterJob;\n@@ -48,0 +47,2 @@\n+import javafx.scene.Parent;\n+import javafx.scene.Scene;\n@@ -49,0 +50,1 @@\n+import javafx.scene.control.ColorPicker;\n@@ -50,0 +52,1 @@\n+import javafx.scene.control.Control;\n@@ -53,0 +56,1 @@\n+import javafx.scene.control.SkinBase;\n@@ -66,0 +70,1 @@\n+import javafx.scene.layout.Region;\n@@ -69,1 +74,3 @@\n-\n+import org.w3c.dom.html.HTMLDocument;\n+import org.w3c.dom.html.HTMLElement;\n+import com.sun.javafx.application.PlatformImpl;\n@@ -71,0 +78,3 @@\n+import com.sun.javafx.scene.traversal.TraversalDirectionInternal;\n+import com.sun.javafx.scene.traversal.TraversalPolicy;\n+import com.sun.javafx.scene.traversal.TraversalUtils;\n@@ -72,1 +82,0 @@\n-import com.sun.webkit.WebPage;\n@@ -74,16 +83,1 @@\n-\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n-import javafx.scene.Scene;\n-import javafx.scene.control.*;\n-import javafx.scene.layout.*;\n-import javafx.collections.ListChangeListener;\n-\n-import static javafx.geometry.NodeOrientation.*;\n-import javafx.print.PrinterJob;\n-\n-import static javafx.scene.web.HTMLEditorSkin.Command.*;\n+import com.sun.webkit.WebPage;\n@@ -152,2 +146,0 @@\n-    private ParentTraversalEngine engine;\n-\n@@ -465,1 +457,1 @@\n-        engine = new ParentTraversalEngine(getSkinnable(), new Algorithm() {\n+        TraversalUtils.setTraversalPolicy(getSkinnable(), new TraversalPolicy() {\n@@ -467,1 +459,1 @@\n-            public Node select(Node owner, Direction dir, TraversalContext context) {\n+            public Node select(Parent root, Node owner, TraversalDirectionInternal dir) {\n@@ -472,1 +464,1 @@\n-            public Node selectFirst(TraversalContext context) {\n+            public Node selectFirst(Parent root) {\n@@ -477,1 +469,1 @@\n-            public Node selectLast(TraversalContext context) {\n+            public Node selectLast(Parent root) {\n@@ -481,1 +473,0 @@\n-        ParentHelper.setTraversalEngine(getSkinnable(), engine);\n","filename":"modules\/javafx.web\/src\/main\/java\/javafx\/scene\/web\/HTMLEditorSkin.java","additions":29,"deletions":38,"binary":false,"changes":67,"status":"modified"}]}