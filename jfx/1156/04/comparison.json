{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import javafx.scene.Scene;\n@@ -32,0 +33,1 @@\n+import javafx.stage.Window;\n@@ -59,1 +61,1 @@\n-        this.target = snap(target);\n+        this.target = snapRound(target);\n@@ -70,1 +72,1 @@\n-            size[i] = c.getWidth();\n+            size[i] = snapCeil(c.getWidth());\n@@ -73,2 +75,2 @@\n-                double cmin = c.getMinWidth();\n-                double cmax = c.getMaxWidth();\n+                double cmin = snapCeil(c.getMinWidth()); \/\/ always honor min width!\n+                double cmax = snapFloor(c.getMaxWidth());\n@@ -77,1 +79,5 @@\n-                pref[i] = clip(c.getPrefWidth(), cmin, cmax);\n+                pref[i] = clip(snapRound(c.getPrefWidth()), cmin, cmax);\n+                \/\/ skip fixed columns\n+                if (cmin == cmax) {\n+                    skip.set(i, true);\n+                }\n@@ -85,8 +91,27 @@\n-        boolean needsAnotherPass;\n-        do {\n-            needsAnotherPass = false;\n-            double sumWidths = 0.0;\n-            double sumMins = 0;\n-            for (int i = 0; i < count; i++) {\n-                sumWidths += size[i];\n-                sumMins += min[i];\n+        if (skip.cardinality() == count) {\n+            return;\n+        }\n+\n+        \/\/ compute delta (snapped)\n+        \/\/ if delta < 0 (and sum(width) < sum(pref)) -> distribute from size to min\n+        \/\/ if delta < 0 (and sum(width) > sum(pref)) -> distribute from size to pref\n+        \/\/ if delta > 0 (and sum(width) < sum(pref)) -> distribute from size to pref\n+        \/\/ else -> distribute from size to max\n+        \/\/\n+        double sumWidths = sum(size);\n+        double sumPrefs = sum(pref);\n+\n+        double delta = target - sumWidths;\n+        if (delta < 0.0) {\n+            \/\/ shrink\n+            if (target < sumPrefs) {\n+                distribute(delta, min);\n+            } else {\n+                distribute(delta, pref);\n+            }\n+        } else if (delta > 0.0) {\n+            \/\/ grow\n+            if (target > sumPrefs) {\n+                distribute(delta, max);\n+            } else {\n+                distribute(delta, pref);\n@@ -94,0 +119,11 @@\n+        }\n+    }\n+\n+    \/** distibuting delta (positive when growing and negative when shrinking) *\/\n+    private void distribute(double delta, double[] desired) {\n+        if (Math.abs(delta) > SMALL_DELTA) {\n+            distributeLargeDelta(delta, desired);\n+        } else {\n+            distributeSmallDelta(delta, desired);\n+        }\n+    }\n@@ -95,2 +131,6 @@\n-            if (sumMins >= target) {\n-                return;\n+    private void distributeLargeDelta(double delta, double[] desired) {\n+        boolean grow = delta > 0.0;\n+        double total = 0.0;\n+        for (int i = 0; i < count; i++) {\n+            if (!skip.get(i)) {\n+                total += avail(grow, desired, i);\n@@ -98,0 +138,1 @@\n+        }\n@@ -99,3 +140,16 @@\n-            double delta = target - snap(sumWidths);\n-            if (isZero(delta)) {\n-                return;\n+        if (isZero(total)) {\n+            return;\n+        }\n+\n+        double unsnapped = 0.0;\n+        double snapped = 0.0;\n+        for (int i = 0; i < count; i++) {\n+            if (!skip.get(i)) {\n+                double d = delta * avail(grow, desired, i) \/ total;\n+                double x = unsnapped + size[i] + d;\n+                double w = snapRound(x) - snapped;\n+\n+                size[i] = w;\n+\n+                unsnapped = x;\n+                snapped += w;\n@@ -103,0 +157,2 @@\n+        }\n+    }\n@@ -104,5 +160,17 @@\n-            \/\/ remove fixed and skipped columns from consideration\n-            double total = 0;\n-            for (int i = 0; i < count; i++) {\n-                if (!skip.get(i)) {\n-                    total += pref[i];\n+    private void distributeSmallDelta(double delta) {\n+        double[] desired = delta < 0 ? min : max;\n+        distributeSmallDelta(delta, desired);\n+    }\n+\n+    \/**\n+     * for small deltas, we use a simpler, but more expensive algorithm to distribute space in small steps,\n+     * each time favoring a column that is further away from its desired width.\n+     *\/\n+    private void distributeSmallDelta(double delta, double[] desired) {\n+        double pixel = 1.0 \/ snapScale();\n+        double halfPixel = pixel \/ 2.0;\n+        if (delta < 0) {\n+            while (delta < -halfPixel) {\n+                double d = -pixel;\n+                if (smallShrink(d, desired)) {\n+                    return;\n@@ -110,0 +178,1 @@\n+                delta -= d;\n@@ -111,3 +180,7 @@\n-\n-            if (isZero(total)) {\n-                return;\n+        } else {\n+            while (delta > halfPixel) {\n+                double d = pixel;\n+                if (smallGrow(d, desired)) {\n+                    return;\n+                }\n+                delta -= d;\n@@ -115,0 +188,2 @@\n+        }\n+    }\n@@ -116,3 +191,15 @@\n-            if (Math.abs(delta) < SMALL_DELTA) {\n-                distributeSmallDelta(delta);\n-                return;\n+    \/**\n+     * Finds the best column to shrink, then reduces its width by delta, which is expected\n+     * to be one display pixel exactly.\n+     * @return true if no candidate has been found and the process should stop\n+     *\/\n+    private boolean smallShrink(double delta, double[] desired) {\n+        double dist = Double.NEGATIVE_INFINITY;\n+        int ix = -1;\n+        for (int i = 0; i < count; i++) {\n+            if (!skip.get(i)) {\n+                double d = size[i] - desired[i];\n+                if (d > dist) {\n+                    dist = d;\n+                    ix = i;\n+                }\n@@ -120,0 +207,1 @@\n+        }\n@@ -121,4 +209,7 @@\n-            for (int i = 0; i < count; i++) {\n-                if (skip.get(i)) {\n-                    continue;\n-                }\n+        if (ix < 0) {\n+            return true;\n+        } else {\n+            size[ix] += delta;\n+            return false;\n+        }\n+    }\n@@ -126,9 +217,14 @@\n-                double w = size[i] + (delta * pref[i] \/ total);\n-                if (w < min[i]) {\n-                    w = min[i];\n-                    skip.set(i, true);\n-                    needsAnotherPass = true;\n-                } else if (w > max[i]) {\n-                    w = max[i];\n-                    skip.set(i, true);\n-                    needsAnotherPass = true;\n+    \/**\n+     * Finds the best column to grow, then increases its width by delta, which is expected\n+     * to be one display pixel exactly.\n+     * @return true if no candidate has been found and the process should stop\n+     *\/\n+    private boolean smallGrow(double delta, double[] desired) {\n+        double dist = Double.NEGATIVE_INFINITY;\n+        int ix = -1;\n+        for (int i = 0; i < count; i++) {\n+            if (!skip.get(i)) {\n+                double d = desired[i] - size[i];\n+                if (d > dist) {\n+                    dist = d;\n+                    ix = i;\n@@ -136,0 +232,2 @@\n+            }\n+        }\n@@ -137,1 +235,7 @@\n-                size[i] = w;\n+        if (ix < 0) {\n+            return true;\n+        } else {\n+            size[ix] += delta;\n+            return false;\n+        }\n+    }\n@@ -139,4 +243,6 @@\n-                if (needsAnotherPass) {\n-                    resetSizeChanges();\n-                    break;\n-                }\n+    private double avail(boolean grow, double[] desired, int ix) {\n+        double d = desired[ix];\n+        double s = size[ix];\n+        if (grow) {\n+            if (d < s) {\n+                return 0.0;\n@@ -144,1 +250,6 @@\n-        } while (needsAnotherPass);\n+        } else {\n+            if (d > s) {\n+                return 0.0;\n+            }\n+        }\n+        return d - s;\n@@ -154,3 +265,1 @@\n-        double pos = 0.0;\n-        double prev = 0.0;\n-\n+        double total = 0.0;\n@@ -159,0 +268,1 @@\n+            double w = size[i];\n@@ -160,2 +270,0 @@\n-                pos = snap(pos + size[i]);\n-                double w = (pos - prev);\n@@ -163,2 +271,0 @@\n-            } else {\n-                pos = pos + size[i];\n@@ -166,1 +272,1 @@\n-            prev = pos;\n+            total += w;\n@@ -169,1 +275,1 @@\n-        return (pos > target);\n+        return (total > target);\n@@ -172,1 +278,1 @@\n-    protected static double clip(double v, double min, double max) {\n+    private static double clip(double v, double min, double max) {\n@@ -211,1 +317,1 @@\n-        allowedDelta = Math.min(Math.abs(delta), Math.min(allowedDelta, d));\n+        allowedDelta = snapRound(Math.min(Math.abs(delta), Math.min(allowedDelta, d)));\n@@ -223,1 +329,1 @@\n-    protected boolean isCornerCase(double delta, int ix) {\n+    private boolean isCornerCase(double delta, int ix) {\n@@ -239,1 +345,1 @@\n-    protected double getAllowedDelta(int ix, boolean expanding) {\n+    private double getAllowedDelta(int ix, boolean expanding) {\n@@ -248,1 +354,1 @@\n-    protected int markOppositeColumns(int ix) {\n+    private int markOppositeColumns(int ix) {\n@@ -272,1 +378,1 @@\n-    protected void setSkip(int from, int toExclusive) {\n+    private void setSkip(int from, int toExclusive) {\n@@ -285,1 +391,1 @@\n-    protected double computeAllowedDelta(boolean expanding) {\n+    private double computeAllowedDelta(boolean expanding) {\n@@ -306,1 +412,1 @@\n-    protected boolean distributeDelta(int ix, double delta) {\n+    private boolean distributeDelta(int ix, double delta) {\n@@ -328,5 +434,1 @@\n-                if (Math.abs(delta) < SMALL_DELTA) {\n-                    distributeSmallDelta(-delta);\n-                } else {\n-                    distributeDeltaRemainingColumns(-delta);\n-                }\n+                distributeDeltaRemainingColumns(-delta);\n@@ -343,1 +445,6 @@\n-    protected double distributeDeltaFlexHead(double delta) {\n+    private void distributeDeltaRemainingColumns(double delta) {\n+        double[] desired = delta < 0 ? min : max;\n+        distribute(delta, desired);\n+    }\n+\n+    private double distributeDeltaFlexHead(double delta) {\n@@ -387,1 +494,1 @@\n-    protected double distributeDeltaFlexTail(double delta) {\n+    private double distributeDeltaFlexTail(double delta) {\n@@ -431,1 +538,1 @@\n-    protected double resize(int ix, double delta) {\n+    private double resize(int ix, double delta) {\n@@ -447,81 +554,2 @@\n-    protected void distributeDeltaRemainingColumns(double delta) {\n-        boolean needsAnotherPass;\n-\n-        do {\n-            double total = 0;\n-            for (int i = 0; i < count; i++) {\n-                if (!skip.get(i)) {\n-                    total += pref[i];\n-                }\n-            }\n-\n-            if (isZero(total)) {\n-                return;\n-            }\n-\n-            needsAnotherPass = false;\n-\n-            for (int i = 0; i < count; i++) {\n-                if (skip.get(i)) {\n-                    continue;\n-                }\n-\n-                double w = size[i] + (delta * pref[i] \/ total);\n-                if (w < min[i]) {\n-                    w = min[i];\n-                    skip.set(i, true);\n-                    needsAnotherPass = true;\n-                    delta -= (w - size[i]);\n-               } else if (w > max[i]) {\n-                    w = max[i];\n-                    skip.set(i, true);\n-                    needsAnotherPass = true;\n-                    delta -= (w - size[i]);\n-                }\n-\n-                size[i] = w;\n-\n-                if (needsAnotherPass) {\n-                    resetSizeChanges();\n-                    break;\n-                }\n-            }\n-        } while (needsAnotherPass);\n-    }\n-\n-    \/**\n-     * for small deltas, we use a simpler, but more expensive algorithm to distribute space in small steps,\n-     * each time favoring a column that is further away from its preferred width.\n-     *\/\n-    protected void distributeSmallDelta(double delta) {\n-        if (delta < 0) {\n-            while (delta < 0.0) {\n-                double d = Math.max(-1.0, delta);\n-                double rem = shrinkSmall(d);\n-                if (Double.isNaN(rem)) {\n-                    return;\n-                }\n-\n-                delta -= (d - rem);\n-            }\n-        } else {\n-            while (delta > 0.0) {\n-                double d = Math.min(1.0, delta);\n-                double rem = expandSmall(d);\n-                if (Double.isNaN(rem)) {\n-                    return;\n-                }\n-\n-                delta -= (d - rem);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Finds the best column to shrink, then reduces its width.\n-     * Adds the column to skip list if the column width hits a constraint after adjustement.\n-     * @return unused portion of delta, or Double.NaN if it did not find a good candidate\n-     *\/\n-    protected double shrinkSmall(double delta) {\n-        double dist = Double.NEGATIVE_INFINITY;\n-        int ix = -1;\n+    private double sumSizes() {\n+        double sum = 0;\n@@ -529,19 +557,1 @@\n-            if (!skip.get(i)) {\n-                double d = size[i] - pref[i];\n-                if (d > dist) {\n-                    dist = d;\n-                    ix = i;\n-                }\n-            }\n-        }\n-\n-        if (ix < 0) {\n-            return Double.NaN;\n-        }\n-\n-        double rem = 0.0;\n-        double w = size[ix] + delta;\n-        if (w < min[ix]) {\n-            rem = (w - min[ix]);\n-            w = min[ix];\n-            skip.set(ix);\n+            sum += size[i];\n@@ -549,2 +559,1 @@\n-        size[ix] = w;\n-        return rem;\n+        return sum;\n@@ -553,8 +562,2 @@\n-    \/**\n-     * Finds the best column to shrink, then reduces its width.\n-     * Adds the column to skip list if the column width hits a constraint after adjustement.\n-     * @return unused portion of delta, or Double.NaN if it did not find a good candidate\n-     *\/\n-    protected double expandSmall(double delta) {\n-        double dist = Double.NEGATIVE_INFINITY;\n-        int ix = -1;\n+    private double sum(double[] widths) {\n+        double sum = 0.0;\n@@ -562,11 +565,1 @@\n-            if (!skip.get(i)) {\n-                double d = pref[i] - size[i];\n-                if (d > dist) {\n-                    dist = d;\n-                    ix = i;\n-                }\n-            }\n-        }\n-\n-        if (ix < 0) {\n-            return Double.NaN;\n+            sum += widths[i];\n@@ -574,0 +567,2 @@\n+        return sum;\n+    }\n@@ -575,9 +570,2 @@\n-        double rem = 0.0;\n-        double w = size[ix] + delta;\n-        if (w > max[ix]) {\n-            rem = (w - max[ix]);\n-            w = max[ix];\n-            skip.set(ix);\n-        }\n-        size[ix] = w;\n-        return rem;\n+    private static boolean isZero(double x) {\n+        return Math.abs(x) < EPSILON;\n@@ -586,5 +574,3 @@\n-    protected void resetSizeChanges() {\n-        for (int i = 0; i < count; i++) {\n-            if (!skip.get(i)) {\n-                size[i] = columns.get(i).getWidth();\n-            }\n+    private double snapCeil(double x) {\n+        if (snap != null) {\n+            return snap.snapSizeX(x);\n@@ -592,0 +578,1 @@\n+        return x;\n@@ -594,4 +581,3 @@\n-    protected double sumSizes() {\n-        double sum = 0;\n-        for (int i = 0; i < count; i++) {\n-            sum += size[i];\n+    private double snapRound(double x) {\n+        if (snap != null) {\n+            return snap.snapPositionX(x);\n@@ -599,1 +585,1 @@\n-        return sum;\n+        return x;\n@@ -602,2 +588,8 @@\n-    protected static boolean isZero(double x) {\n-        return Math.abs(x) < EPSILON;\n+    private double snapFloor(double x) {\n+        if (snap != null) {\n+            \/\/ there is no public equivalent, but we can copy implementation from Region\n+            \/\/ let's try rounding for now\n+            \/\/ TODO we can implement this since we have snapScale now\n+            return snapRound(x);\n+        }\n+        return x;\n@@ -606,3 +598,13 @@\n-    protected double snap(double x) {\n-        if (snap == null) {\n-            return x;\n+    \/**\n+     * implementation copied from {@link Region}.\n+     * @return returns scene render scale x value\n+     *\/\n+    private double snapScale() {\n+        if (snap != null) {\n+            Scene scene = snap.getScene();\n+            if (scene != null) {\n+                Window window = scene.getWindow();\n+                if (window != null) {\n+                    return window.getRenderScaleX();\n+                }\n+            }\n@@ -610,1 +612,1 @@\n-        return snap.snapSpaceX(x);\n+        return 1.0;\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/ResizeHelper.java","additions":221,"deletions":219,"binary":false,"changes":440,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.javafx.scene.layout.RegionHelper;\n@@ -97,2 +98,19 @@\n-  public void setColumnWidth(TableColumnBase<S,?> col, double width) {\n-      col.doSetWidth(width);\n+  public void setColumnWidth(TableColumnBase<S, ?> col, double width) {\n+      Control c = getTableControl();\n+      if (c.isSnapToPixel()) {\n+          double min = c.snapSizeX(col.getMinWidth());\n+          double max = RegionHelper.snapInnerSpaceX(c, col.getMaxWidth());\n+          if (width < min) {\n+              width = min;\n+          } else if (width > max) {\n+              width = max;\n+              if (width < min) {\n+                  \/\/ safety check in case floor(max) < ceil(min)\n+                  width = min;\n+              }\n+          } else {\n+              width = c.snapPositionX(width);\n+          }\n+      }\n+      \/\/ can set width directly because all constraints have been checked\n+      col.setWidth(width);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/ResizeFeaturesBase.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,0 +107,4 @@\n+    public static double snapInnerSpaceX(Node node, double x) {\n+        return regionAccessor.snapInnerSpaceX(node, x);\n+    }\n+\n@@ -124,0 +128,1 @@\n+        double snapInnerSpaceX(Node node, double x);\n@@ -125,1 +130,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/layout\/RegionHelper.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -184,0 +184,5 @@\n+\n+            @Override\n+            public double snapInnerSpaceX(Node node, double x) {\n+                return ((Region)node).snapPortionX(x);\n+            }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Region.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<classpath>\n-\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/base\">\n-\t\t<attributes>\n-\t\t\t<attribute name=\"module\" value=\"true\"\/>\n-\t\t<\/attributes>\n-\t<\/classpathentry>\n-\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/graphics\">\n-\t\t<attributes>\n-\t\t\t<attribute name=\"module\" value=\"true\"\/>\n-\t\t<\/attributes>\n-\t<\/classpathentry>\n-\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/controls\">\n-\t\t<attributes>\n-\t\t\t<attribute name=\"module\" value=\"true\"\/>\n-\t\t<\/attributes>\n-\t<\/classpathentry>\n-\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/swing\">\n-\t\t<attributes>\n-\t\t\t<attribute name=\"module\" value=\"true\"\/>\n-\t\t<\/attributes>\n-\t<\/classpathentry>\n-\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\">\n-\t\t<attributes>\n-\t\t\t<attribute name=\"module\" value=\"true\"\/>\n-\t\t<\/attributes>\n-\t<\/classpathentry>\n-\t<classpathentry excluding=\".classpath|.project|.settings|src\/\" kind=\"src\" output=\"bin\" path=\"\"\/>\n-\t<classpathentry kind=\"src\" path=\"src\"\/>\n-\t<classpathentry kind=\"output\" path=\"bin\"\/>\n-<\/classpath>\n","filename":"tests\/manual\/tester\/.classpath","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,17 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<projectDescription>\n-    <name>manualTests-tester<\/name>\n-    <comment><\/comment>\n-    <projects>\n-    <\/projects>\n-    <buildSpec>\n-        <buildCommand>\n-            <name>org.eclipse.jdt.core.javabuilder<\/name>\n-            <arguments>\n-            <\/arguments>\n-        <\/buildCommand>\n-    <\/buildSpec>\n-    <natures>\n-        <nature>org.eclipse.jdt.core.javanature<\/nature>\n-    <\/natures>\n-<\/projectDescription>\n","filename":"tests\/manual\/tester\/.project","additions":0,"deletions":17,"binary":false,"changes":17,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-eclipse.preferences.version=1\n-encoding\/<project>=UTF-8\n","filename":"tests\/manual\/tester\/.settings\/org.eclipse.core.resources.prefs","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,705 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.oracle.javafx.tester;\n-\n-import java.awt.BorderLayout;\n-import java.awt.Color;\n-import java.awt.EventQueue;\n-import java.util.List;\n-import javax.swing.JComponent;\n-import javax.swing.JPanel;\n-import javax.swing.JScrollPane;\n-import javax.swing.JSplitPane;\n-import javax.swing.JTable;\n-import javax.swing.border.EmptyBorder;\n-import javax.swing.table.DefaultTableModel;\n-import javafx.application.Application;\n-import javafx.beans.property.SimpleStringProperty;\n-import javafx.embed.swing.SwingNode;\n-import javafx.geometry.Orientation;\n-import javafx.scene.Scene;\n-import javafx.scene.control.ComboBox;\n-import javafx.scene.control.ConstrainedColumnResizeBase;\n-import javafx.scene.control.Label;\n-import javafx.scene.control.SelectionMode;\n-import javafx.scene.control.SplitPane;\n-import javafx.scene.control.TableCell;\n-import javafx.scene.control.TableColumn;\n-import javafx.scene.control.TableColumnBase;\n-import javafx.scene.control.TableView;\n-import javafx.scene.control.TableView.ResizeFeatures;\n-import javafx.scene.layout.BorderPane;\n-import javafx.scene.layout.HBox;\n-import javafx.scene.layout.Pane;\n-import javafx.stage.Stage;\n-import javafx.util.Callback;\n-\n-\/**\n- * Tests TableView\/JTable constrained column resize modes.\n- *\/\n-public class ATableViewResizeTester extends Application {\n-\n-    enum Demo {\n-        PREF(\"pref only\"),\n-        ALL(\"all set: min, pref, max\"),\n-        EMPTY(\"empty with pref\"),\n-        MIN_WIDTH(\"min width\"),\n-        MAX_WIDTH(\"max width\"),\n-        MIN_WIDTH2(\"min width (middle)\"),\n-        MAX_WIDTH2(\"max width (middle)\"),\n-        MIN_WIDTH3(\"min width (beginning)\"),\n-        MAX_WIDTH3(\"max width (beginning)\"),\n-        FIXED_MIDDLE(\"fixed in the middle\"),\n-        ALL_FIXED(\"all fixed\"),\n-        ALL_MAX(\"all with maximum width\"),\n-        MIN_IN_CENTER(\"min widths set in middle columns\"),\n-        MAX_IN_CENTER(\"max widths set in middle columns\"),\n-        NO_NESTED(\"no nested columns\"),\n-        NESTED(\"nested columns\"),\n-        MILLION(\"million rows\"),\n-        MANY_COLUMNS(\"many columns\"),\n-        MANY_COLUMNS_SAME(\"many columns, same pref\");\n-\n-        private final String text;\n-        Demo(String text) { this.text = text; }\n-        public String toString() { return text; }\n-    }\n-\n-    public enum Policy {\n-        AUTO_RESIZE_FLEX_NEXT_COLUMN(JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS),\n-        AUTO_RESIZE_FLEX_LAST_COLUMN(JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS),\n-        AUTO_RESIZE_NEXT_COLUMN(JTable.AUTO_RESIZE_NEXT_COLUMN),\n-        AUTO_RESIZE_SUBSEQUENT_COLUMNS(JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS),\n-        AUTO_RESIZE_LAST_COLUMN(JTable.AUTO_RESIZE_LAST_COLUMN),\n-        AUTO_RESIZE_ALL_COLUMNS(JTable.AUTO_RESIZE_ALL_COLUMNS),\n-        USER_DEFINED_EQUAL_WIDTHS(JTable.AUTO_RESIZE_ALL_COLUMNS),\n-        UNCONSTRAINED_RESIZE_POLICY(JTable.AUTO_RESIZE_OFF),\n-        CONSTRAINED_RESIZE_POLICY(JTable.AUTO_RESIZE_SUBSEQUENT_COLUMNS);\n-\n-        private final int value;\n-        Policy(int v) { this.value = v; }\n-        public int getValue() { return value; }\n-    }\n-\n-    public enum Cmd {\n-        ROWS,\n-        COL,\n-        MIN,\n-        PREF,\n-        MAX,\n-        COMBINE\n-    }\n-\n-    protected BorderPane contentPane;\n-    protected ComboBox<Demo> demoSelector;\n-    protected ComboBox<Policy> policySelector;\n-    protected SwingPanel swingPanel;\n-    protected static Callback<TableColumn<String, String>, TableCell<String, String>> CELL_FACTORY = initCellFactory();\n-\n-    public static void main(String[] args) {\n-        Application.launch(ATableViewResizeTester.class, args);\n-    }\n-\n-    @Override\n-    public void start(Stage stage) throws Exception {\n-        contentPane = new BorderPane();\n-\n-        \/\/ selector\n-        demoSelector = new ComboBox<>();\n-        demoSelector.getItems().addAll(Demo.values());\n-        demoSelector.setEditable(false);\n-        demoSelector.getSelectionModel().selectedItemProperty().addListener((s,p,c) -> {\n-            updatePane();\n-        });\n-\n-        policySelector = new ComboBox<>();\n-        policySelector.getItems().addAll(Policy.values());\n-        policySelector.setEditable(false);\n-        policySelector.getSelectionModel().selectedItemProperty().addListener((s,p,c) -> {\n-            updatePane();\n-        });\n-\n-        \/\/ layout\n-\n-        SplitPane split = new SplitPane(contentPane, new BorderPane());\n-\n-        HBox hb = new HBox(\n-            new Label(\"Data:\"),\n-            demoSelector,\n-            new Label(\" Policy:\"),\n-            policySelector\n-        );\n-        hb.setSpacing(5);\n-\n-        BorderPane bp = new BorderPane();\n-        bp.setTop(hb);\n-        bp.setCenter(split);\n-\n-        SwingNode swn = new SwingNode();\n-        EventQueue.invokeLater(() -> {\n-            swingPanel = new SwingPanel();\n-            swn.setContent(swingPanel);\n-        });\n-\n-        SplitPane sp = new SplitPane(bp, new BorderPane(swn));\n-        sp.setOrientation(Orientation.VERTICAL);\n-\n-        stage.setScene(new Scene(sp));\n-        stage.setWidth(1000);\n-        stage.setHeight(500);\n-        stage.show();\n-\n-        stage.renderScaleXProperty().addListener((s,p,c) -> updateTitle(stage));\n-        updateTitle(stage);\n-\n-        demoSelector.getSelectionModel().\n-            selectFirst();\n-            \/\/select(Demo.FIXED_MIDDLE);\n-        policySelector.getSelectionModel().\n-            selectFirst();\n-            \/\/select(Policy.AUTO_RESIZE_SUBSEQUENT_COLUMNS);\n-    }\n-\n-    protected void updateTitle(Stage s) {\n-        s.setTitle(\"TableView\/JTable Resize Tester \" + System.getProperty(\"java.version\") + \" scaleX=\" + s.getRenderScaleX());\n-    }\n-\n-    protected Callback<ResizeFeatures,Boolean> wrap(Callback<ResizeFeatures,Boolean> policy) {\n-        return new Callback<ResizeFeatures,Boolean>() {\n-            @Override\n-            public Boolean call(ResizeFeatures f) {\n-                Boolean rv = policy.call(f);\n-                int ix = f.getTable().getColumns().indexOf(f.getColumn());\n-                System.out.println(\n-                    \"col=\" + (ix < 0 ? f.getColumn() : ix) +\n-                    \" delta=\" + f.getDelta() +\n-                    \" w=\" + f.getTable().getWidth() +\n-                    \" rv=\" + rv\n-                );\n-                return rv;\n-            }\n-        };\n-    }\n-\n-    protected String describe(TableColumn c) {\n-        StringBuilder sb = new StringBuilder();\n-        if(c.getMinWidth() != 10.0) {\n-            sb.append(\"m\");\n-        }\n-        if(c.getPrefWidth() != 80.0) {\n-            sb.append(\"p\");\n-        }\n-        if(c.getMaxWidth() != 5000.0) {\n-            sb.append(\"X\");\n-        }\n-        return sb.toString();\n-    }\n-\n-    protected Callback<ResizeFeatures, Boolean> createPolicy(Policy p) {\n-        switch(p) {\n-        case AUTO_RESIZE_FLEX_NEXT_COLUMN:\n-            return TableView.CONSTRAINED_RESIZE_POLICY_FLEX_NEXT_COLUMN;\n-        case AUTO_RESIZE_FLEX_LAST_COLUMN:\n-            return TableView.CONSTRAINED_RESIZE_POLICY_FLEX_LAST_COLUMN;\n-        case AUTO_RESIZE_ALL_COLUMNS:\n-            return TableView.CONSTRAINED_RESIZE_POLICY_ALL_COLUMNS;\n-        case AUTO_RESIZE_LAST_COLUMN:\n-            return TableView.CONSTRAINED_RESIZE_POLICY_LAST_COLUMN;\n-        case AUTO_RESIZE_NEXT_COLUMN:\n-            return TableView.CONSTRAINED_RESIZE_POLICY_NEXT_COLUMN;\n-        case AUTO_RESIZE_SUBSEQUENT_COLUMNS:\n-            return TableView.CONSTRAINED_RESIZE_POLICY_SUBSEQUENT_COLUMNS;\n-        case CONSTRAINED_RESIZE_POLICY:\n-            return TableView.CONSTRAINED_RESIZE_POLICY;\n-        case UNCONSTRAINED_RESIZE_POLICY:\n-            return TableView.UNCONSTRAINED_RESIZE_POLICY;\n-        case USER_DEFINED_EQUAL_WIDTHS:\n-            return new UserDefinedResizePolicy();\n-        default:\n-            throw new Error(\"?\" + p);\n-        }\n-    }\n-\n-    protected Object[] createSpec(Demo d) {\n-        switch(d) {\n-        case ALL:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL,\n-                Cmd.COL, Cmd.MIN, 20, Cmd.PREF, 20, Cmd.MAX, 20,\n-                Cmd.COL, Cmd.PREF, 200,\n-                Cmd.COL, Cmd.PREF, 300, Cmd.MAX, 400,\n-                Cmd.COL\n-            };\n-        case PREF:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL, Cmd.PREF, 100,\n-                Cmd.COL, Cmd.PREF, 200,\n-                Cmd.COL, Cmd.PREF, 300,\n-                Cmd.COL, Cmd.PREF, 400\n-            };\n-        case EMPTY:\n-            return new Object[] {\n-                Cmd.COL, Cmd.PREF, 100,\n-                Cmd.COL, Cmd.PREF, 200,\n-                Cmd.COL, Cmd.PREF, 300\n-            };\n-        case MIN_WIDTH:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL, Cmd.MIN, 300\n-            };\n-        case MAX_WIDTH:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL, Cmd.MAX, 100\n-            };\n-        case MIN_WIDTH2:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL, Cmd.MIN, 300,\n-                Cmd.COL\n-            };\n-        case MAX_WIDTH2:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL, Cmd.MAX, 100,\n-                Cmd.COL\n-            };\n-        case MIN_WIDTH3:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL, Cmd.MIN, 300,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL\n-            };\n-        case MAX_WIDTH3:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL, Cmd.MAX, 100,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL\n-            };\n-        case MIN_IN_CENTER:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL,\n-                Cmd.COL, Cmd.MIN, 20,\n-                Cmd.COL, Cmd.MIN, 30,\n-                Cmd.COL, Cmd.MIN, 40,\n-                Cmd.COL, Cmd.MIN, 50,\n-                Cmd.COL, Cmd.MIN, 60,\n-                Cmd.COL\n-            };\n-        case MAX_IN_CENTER:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL,\n-                Cmd.COL, Cmd.MAX, 20,\n-                Cmd.COL, Cmd.MAX, 30,\n-                Cmd.COL, Cmd.MAX, 40,\n-                Cmd.COL, Cmd.MAX, 50,\n-                Cmd.COL, Cmd.MAX, 60,\n-                Cmd.COL\n-            };\n-        case FIXED_MIDDLE:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL, Cmd.MIN, 100, Cmd.MAX, 100,\n-                Cmd.COL, Cmd.MIN, 100, Cmd.MAX, 100,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL\n-            };\n-        case ALL_FIXED:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL, Cmd.MIN, 50, Cmd.MAX, 50,\n-                Cmd.COL, Cmd.MIN, 50, Cmd.MAX, 50,\n-                Cmd.COL, Cmd.MIN, 50, Cmd.MAX, 50\n-            };\n-        case ALL_MAX:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL, Cmd.MAX, 50,\n-                Cmd.COL, Cmd.MAX, 50,\n-                Cmd.COL, Cmd.MAX, 50\n-            };\n-       case NO_NESTED:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL, Cmd.PREF, 100,\n-                Cmd.COL, Cmd.PREF, 200,\n-                Cmd.COL, Cmd.PREF, 300,\n-                Cmd.COL, Cmd.MIN, 100, Cmd.MAX, 100,\n-                Cmd.COL, Cmd.PREF, 100,\n-                Cmd.COL, Cmd.MIN, 100,\n-                Cmd.COL, Cmd.MAX, 100,\n-                Cmd.COL, Cmd.PREF, 400,\n-                Cmd.COL\n-            };\n-        case NESTED:\n-            return new Object[] {\n-                Cmd.ROWS, 3,\n-                Cmd.COL, Cmd.PREF, 100,\n-                Cmd.COL, Cmd.PREF, 200,\n-                Cmd.COL, Cmd.PREF, 300,\n-                Cmd.COL, Cmd.MIN, 100, Cmd.MAX, 100,\n-                Cmd.COL, Cmd.PREF, 100,\n-                Cmd.COL, Cmd.MIN, 100,\n-                Cmd.COL, Cmd.MAX, 100,\n-                Cmd.COL, Cmd.PREF, 400,\n-                Cmd.COL,\n-                Cmd.COMBINE, 0, 3,\n-                Cmd.COMBINE, 1, 2\n-            };\n-        case MANY_COLUMNS:\n-            return new Object[] {\n-                Cmd.ROWS, 300,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL,\n-                Cmd.COL\n-            };\n-        case MANY_COLUMNS_SAME:\n-            return new Object[] {\n-                Cmd.ROWS, 300,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30,\n-                Cmd.COL, Cmd.PREF, 30\n-            };\n-        case MILLION:\n-            return new Object[] {\n-                Cmd.ROWS, 1_000_000,\n-                Cmd.COL,\n-                Cmd.COL\n-            };\n-        default:\n-            throw new Error(\"?\" + d);\n-        }\n-    }\n-\n-    protected void updatePane() {\n-        Policy p = policySelector.getSelectionModel().getSelectedItem();\n-        Demo d = demoSelector.getSelectionModel().getSelectedItem();\n-        Object[] spec = createSpec(d);\n-\n-        Pane n = createPane(p, spec);\n-        contentPane.setCenter(n);\n-\n-        EventQueue.invokeLater(() -> {\n-            swingPanel.updatePane(p, spec);\n-        });\n-    }\n-\n-    protected void combineColumns(TableView<String> t, int ix, int count, int name) {\n-        TableColumn<String, String> tc = new TableColumn<>();\n-        tc.setCellFactory(CELL_FACTORY);\n-        tc.setText(\"N\" + name);\n-\n-        for (int i = 0; i < count; i++) {\n-            TableColumn<String,?> c = t.getColumns().remove(ix);\n-            tc.getColumns().add(c);\n-        }\n-        t.getColumns().add(ix, tc);\n-    }\n-\n-    protected Pane createPane(Policy policy, Object[] spec) {\n-        if ((spec == null) || (policy == null)) {\n-            return new BorderPane();\n-        }\n-\n-        TableView<String> table = new TableView<>();\n-        table.getSelectionModel().setCellSelectionEnabled(true);\n-        table.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);\n-\n-        Callback<ResizeFeatures,Boolean> p = createPolicy(policy);\n-        table.setColumnResizePolicy(p);\n-\n-        TableColumn<String,String> lastColumn = null;\n-        int id = 1;\n-\n-        for (int i = 0; i < spec.length;) {\n-            Object x = spec[i++];\n-            if (x instanceof Cmd cmd) {\n-                switch (cmd) {\n-                case COL:\n-                    TableColumn<String, String> c = new TableColumn<>();\n-                    c.setCellFactory(CELL_FACTORY);\n-                    table.getColumns().add(c);\n-                    c.setText(\"C\" + table.getColumns().size());\n-\/\/                    if (table.getColumns().size() == 1) {\n-\/\/                        c.setText(\"Really really really really really really really really really really really really really long\");\n-\/\/                    }\n-                    c.setCellValueFactory((f) -> new SimpleStringProperty(describe(c)));\n-                    lastColumn = c;\n-                    break;\n-                case MAX: {\n-                    int w = (int)(spec[i++]);\n-                    lastColumn.setMaxWidth(w);\n-                }\n-                    break;\n-                case MIN: {\n-                    int w = (int)(spec[i++]);\n-                    lastColumn.setMinWidth(w);\n-                }\n-                    break;\n-                case PREF: {\n-                    int w = (int)(spec[i++]);\n-                    lastColumn.setPrefWidth(w);\n-                }\n-                    break;\n-                case ROWS:\n-                    int n = (int)(spec[i++]);\n-                    for (int j = 0; j < n; j++) {\n-                        table.getItems().add(String.valueOf(n));\n-                    }\n-                    break;\n-                case COMBINE:\n-                    int ix = (int)(spec[i++]);\n-                    int ct = (int)(spec[i++]);\n-                    combineColumns(table, ix, ct, id++);\n-                    break;\n-                default:\n-                    throw new Error(\"?\" + cmd);\n-                }\n-            } else {\n-                throw new Error(\"?\" + x);\n-            }\n-        }\n-\n-        BorderPane bp = new BorderPane();\n-        bp.setCenter(table);\n-        return bp;\n-    }\n-\n-    protected static class SwingPanel extends JPanel {\n-        public SwingPanel() {\n-            super(new BorderLayout());\n-        }\n-\n-        public void updatePane(Policy policy, Object[] spec) {\n-            JComponent p = createPanel(policy, spec);\n-            removeAll();\n-            if (p != null) {\n-                add(p);\n-            }\n-            validate();\n-            repaint();\n-        }\n-\n-        private int createHSBPolicy(Policy p) {\n-            switch (p) {\n-            case UNCONSTRAINED_RESIZE_POLICY:\n-                return JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED;\n-            default:\n-                return JScrollPane.HORIZONTAL_SCROLLBAR_NEVER;\n-            }\n-        }\n-\n-        protected JComponent createPanel(Policy policy, Object[] spec) {\n-            if ((spec == null) || (policy == null)) {\n-                return null;\n-            }\n-\n-            DefaultTableModel m = new DefaultTableModel() {\n-                @Override\n-                public Object getValueAt(int row, int column) {\n-                    return \"\";\n-                }\n-            };\n-\n-            JTable t = new JTable(m);\n-            t.setShowHorizontalLines(true);\n-            t.setShowVerticalLines(true);\n-            t.setGridColor(Color.LIGHT_GRAY);\n-            t.setAutoResizeMode(policy.getValue());\n-\n-            javax.swing.table.TableColumn lastColumn = null;\n-\n-            for (int i = 0; i < spec.length;) {\n-                Object x = spec[i++];\n-                if (x instanceof Cmd cmd) {\n-                    switch (cmd) {\n-                    case COL:\n-                        javax.swing.table.TableColumn c = new javax.swing.table.TableColumn();\n-                        t.getColumnModel().addColumn(c);\n-                        c.setHeaderValue(\"C\" + t.getColumnCount());\n-                        lastColumn = c;\n-                        break;\n-                    case MAX: {\n-                        int w = (int)(spec[i++]);\n-                        lastColumn.setMaxWidth(w);\n-                    }\n-                        break;\n-                    case MIN: {\n-                        int w = (int)(spec[i++]);\n-                        lastColumn.setMinWidth(w);\n-                    }\n-                        break;\n-                    case PREF: {\n-                        int w = (int)(spec[i++]);\n-                        lastColumn.setPreferredWidth(w);\n-                    }\n-                        break;\n-                    case ROWS:\n-                        int n = (int)(spec[i++]);\n-                        for (int j = 0; j < n; j++) {\n-                            m.addRow((Object[])null);\n-                        }\n-                        break;\n-                    case COMBINE:\n-                        \/\/ ignored\n-                        int ix = (int)(spec[i++]);\n-                        int ct = (int)(spec[i++]);\n-                        break;\n-                    default:\n-                        throw new Error(\"?\" + cmd);\n-                    }\n-                } else {\n-                    throw new Error(\"?\" + x);\n-                }\n-            }\n-\n-            EmptyBorder b = new EmptyBorder(0, 0, 0, 0);\n-\n-            int hsp = createHSBPolicy(policy);\n-            JScrollPane scroll = new JScrollPane(t, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, hsp);\n-            scroll.setBorder(b);\n-\n-            JSplitPane split = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, scroll, new JPanel());\n-            split.setContinuousLayout(true);\n-            return split;\n-        }\n-    }\n-\n-    private static Callback<TableColumn<String, String>, TableCell<String, String>> initCellFactory() {\n-        return new Callback<TableColumn<String, String>, TableCell<String, String>>() {\n-            public TableCell call(TableColumn column) {\n-                return new TableCell<String, String>() {\n-                    {\n-                        widthProperty().addListener((s, p, c) -> {\n-                            setStyle(computeStyle());\n-                        });\n-                    }\n-\n-                    @Override\n-                    public void updateItem(String item, boolean empty) {\n-                        super.updateItem(item, empty);\n-                        setText(item);\n-                    }\n-\n-                    private String computeStyle() {\n-                        boolean empty = isEmpty();\n-                        if (!empty) {\n-                            double w = getWidth();\n-                            if (isClose(w, column.getMinWidth())) {\n-                                return \"-fx-background-color:#ffeeee;\";\n-                            } else if (isClose(w, column.getPrefWidth())) {\n-                                return \"-fx-background-color:#eeffee;\";\n-                            } else if (isClose(w, column.getMaxWidth())) {\n-                                return \"-fx-background-color:#eeeeff;\";\n-                            }\n-                        }\n-                        return null;\n-                    }\n-                };\n-            }\n-        };\n-    }\n-\n-    private static boolean isClose(double a, double b) {\n-        return Math.abs(a - b) < 0.00001;\n-    }\n-\n-    \/**\n-     * a user-defined policy demonstrates that we can indeed create a custom policy\n-     * using the new API. this policy simply sizes all columns equally.\n-     *\/\n-    protected static class UserDefinedResizePolicy\n-        extends ConstrainedColumnResizeBase\n-        implements Callback<TableView.ResizeFeatures,Boolean> {\n-\n-        @SuppressWarnings(\"unchecked\")\n-        @Override\n-        public Boolean call(ResizeFeatures rf) {\n-            List<? extends TableColumnBase<?,?>> visibleLeafColumns = rf.getTable().getVisibleLeafColumns();\n-            int sz = visibleLeafColumns.size();\n-            \/\/ using added public method getContentWidth()\n-            double w = rf.getContentWidth() \/ sz;\n-            for (TableColumnBase<?,?> c: visibleLeafColumns) {\n-                \/\/ using added public method setColumnWidth()\n-                rf.setColumnWidth(c, w);\n-            }\n-            return false;\n-        }\n-    }\n-}\n","filename":"tests\/manual\/tester\/src\/com\/oracle\/javafx\/tester\/ATableViewResizeTester.java","additions":0,"deletions":705,"binary":false,"changes":705,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Provides manual test applications.\n- *\/\n-module test.manual {\n-    exports com.oracle.javafx.tester;\n-\n-    requires javafx.base;\n-    requires javafx.controls;\n-    requires javafx.graphics;\n-    requires java.desktop;\n-    requires javafx.swing;\n-}\n","filename":"tests\/manual\/tester\/src\/module-info.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"}]}