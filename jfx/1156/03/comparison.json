{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import javafx.scene.Scene;\n@@ -32,0 +33,1 @@\n+import javafx.stage.Window;\n@@ -59,1 +61,1 @@\n-        this.target = snap(target);\n+        this.target = snapRound(target);\n@@ -70,1 +72,1 @@\n-            size[i] = c.getWidth();\n+            size[i] = snapCeil(c.getWidth());\n@@ -73,2 +75,2 @@\n-                double cmin = c.getMinWidth();\n-                double cmax = c.getMaxWidth();\n+                double cmin = snapCeil(c.getMinWidth()); \/\/ always honor min width!\n+                double cmax = snapFloor(c.getMaxWidth());\n@@ -77,1 +79,5 @@\n-                pref[i] = clip(c.getPrefWidth(), cmin, cmax);\n+                pref[i] = clip(snapRound(c.getPrefWidth()), cmin, cmax);\n+                \/\/ skip fixed columns\n+                if (cmin == cmax) {\n+                    skip.set(i, true);\n+                }\n@@ -85,8 +91,27 @@\n-        boolean needsAnotherPass;\n-        do {\n-            needsAnotherPass = false;\n-            double sumWidths = 0.0;\n-            double sumMins = 0;\n-            for (int i = 0; i < count; i++) {\n-                sumWidths += size[i];\n-                sumMins += min[i];\n+        if (skip.cardinality() == count) {\n+            return;\n+        }\n+\n+        \/\/ compute delta (snapped)\n+        \/\/ if delta < 0 (and sum(width) < sum(pref)) -> distribute from size to min\n+        \/\/ if delta < 0 (and sum(width) > sum(pref)) -> distribute from size to pref\n+        \/\/ if delta > 0 (and sum(width) < sum(pref)) -> distribute from size to pref\n+        \/\/ else -> distribute from size to max\n+        \/\/\n+        double sumWidths = sum(size);\n+        double sumPrefs = sum(pref);\n+\n+        double delta = target - sumWidths;\n+        if (delta < 0.0) {\n+            \/\/ shrink\n+            if (target < sumPrefs) {\n+                distribute(delta, min);\n+            } else {\n+                distribute(delta, pref);\n+            }\n+        } else if (delta > 0.0) {\n+            \/\/ grow\n+            if (target > sumPrefs) {\n+                distribute(delta, max);\n+            } else {\n+                distribute(delta, pref);\n@@ -94,0 +119,11 @@\n+        }\n+    }\n+\n+    \/** distibuting delta (positive when growing and negative when shrinking) *\/\n+    private void distribute(double delta, double[] desired) {\n+        if (Math.abs(delta) > SMALL_DELTA) {\n+            distributeLargeDelta(delta, desired);\n+        } else {\n+            distributeSmallDelta(delta, desired);\n+        }\n+    }\n@@ -95,2 +131,6 @@\n-            if (sumMins >= target) {\n-                return;\n+    private void distributeLargeDelta(double delta, double[] desired) {\n+        boolean grow = delta > 0.0;\n+        double total = 0.0;\n+        for (int i = 0; i < count; i++) {\n+            if (!skip.get(i)) {\n+                total += avail(grow, desired, i);\n@@ -98,0 +138,1 @@\n+        }\n@@ -99,3 +140,16 @@\n-            double delta = target - snap(sumWidths);\n-            if (isZero(delta)) {\n-                return;\n+        if (isZero(total)) {\n+            return;\n+        }\n+\n+        double unsnapped = 0.0;\n+        double snapped = 0.0;\n+        for (int i = 0; i < count; i++) {\n+            if (!skip.get(i)) {\n+                double d = delta * avail(grow, desired, i) \/ total;\n+                double x = unsnapped + size[i] + d;\n+                double w = snapRound(x) - snapped;\n+\n+                size[i] = w;\n+\n+                unsnapped = x;\n+                snapped += w;\n@@ -103,0 +157,2 @@\n+        }\n+    }\n@@ -104,5 +160,17 @@\n-            \/\/ remove fixed and skipped columns from consideration\n-            double total = 0;\n-            for (int i = 0; i < count; i++) {\n-                if (!skip.get(i)) {\n-                    total += pref[i];\n+    private void distributeSmallDelta(double delta) {\n+        double[] desired = delta < 0 ? min : max;\n+        distributeSmallDelta(delta, desired);\n+    }\n+\n+    \/**\n+     * for small deltas, we use a simpler, but more expensive algorithm to distribute space in small steps,\n+     * each time favoring a column that is further away from its desired width.\n+     *\/\n+    private void distributeSmallDelta(double delta, double[] desired) {\n+        double pixel = 1.0 \/ snapScale();\n+        double halfPixel = pixel \/ 2.0;\n+        if (delta < 0) {\n+            while (delta < -halfPixel) {\n+                double d = -pixel;\n+                if (smallShrink(d, desired)) {\n+                    return;\n@@ -110,0 +178,1 @@\n+                delta -= d;\n@@ -111,3 +180,7 @@\n-\n-            if (isZero(total)) {\n-                return;\n+        } else {\n+            while (delta > halfPixel) {\n+                double d = pixel;\n+                if (smallGrow(d, desired)) {\n+                    return;\n+                }\n+                delta -= d;\n@@ -115,0 +188,2 @@\n+        }\n+    }\n@@ -116,3 +191,15 @@\n-            if (Math.abs(delta) < SMALL_DELTA) {\n-                distributeSmallDelta(delta);\n-                return;\n+    \/**\n+     * Finds the best column to shrink, then reduces its width by delta, which is expected\n+     * to be one display pixel exactly.\n+     * @return true if no candidate has been found and the process should stop\n+     *\/\n+    private boolean smallShrink(double delta, double[] desired) {\n+        double dist = Double.NEGATIVE_INFINITY;\n+        int ix = -1;\n+        for (int i = 0; i < count; i++) {\n+            if (!skip.get(i)) {\n+                double d = size[i] - desired[i];\n+                if (d > dist) {\n+                    dist = d;\n+                    ix = i;\n+                }\n@@ -120,0 +207,1 @@\n+        }\n@@ -121,4 +209,7 @@\n-            for (int i = 0; i < count; i++) {\n-                if (skip.get(i)) {\n-                    continue;\n-                }\n+        if (ix < 0) {\n+            return true;\n+        } else {\n+            size[ix] += delta;\n+            return false;\n+        }\n+    }\n@@ -126,9 +217,14 @@\n-                double w = size[i] + (delta * pref[i] \/ total);\n-                if (w < min[i]) {\n-                    w = min[i];\n-                    skip.set(i, true);\n-                    needsAnotherPass = true;\n-                } else if (w > max[i]) {\n-                    w = max[i];\n-                    skip.set(i, true);\n-                    needsAnotherPass = true;\n+    \/**\n+     * Finds the best column to grow, then increases its width by delta, which is expected\n+     * to be one display pixel exactly.\n+     * @return true if no candidate has been found and the process should stop\n+     *\/\n+    private boolean smallGrow(double delta, double[] desired) {\n+        double dist = Double.NEGATIVE_INFINITY;\n+        int ix = -1;\n+        for (int i = 0; i < count; i++) {\n+            if (!skip.get(i)) {\n+                double d = desired[i] - size[i];\n+                if (d > dist) {\n+                    dist = d;\n+                    ix = i;\n@@ -136,0 +232,2 @@\n+            }\n+        }\n@@ -137,1 +235,7 @@\n-                size[i] = w;\n+        if (ix < 0) {\n+            return true;\n+        } else {\n+            size[ix] += delta;\n+            return false;\n+        }\n+    }\n@@ -139,4 +243,6 @@\n-                if (needsAnotherPass) {\n-                    resetSizeChanges();\n-                    break;\n-                }\n+    private double avail(boolean grow, double[] desired, int ix) {\n+        double d = desired[ix];\n+        double s = size[ix];\n+        if (grow) {\n+            if (d < s) {\n+                return 0.0;\n@@ -144,1 +250,6 @@\n-        } while (needsAnotherPass);\n+        } else {\n+            if (d > s) {\n+                return 0.0;\n+            }\n+        }\n+        return d - s;\n@@ -154,3 +265,1 @@\n-        double pos = 0.0;\n-        double prev = 0.0;\n-\n+        double total = 0.0;\n@@ -159,0 +268,1 @@\n+            double w = size[i];\n@@ -160,2 +270,0 @@\n-                pos = snap(pos + size[i]);\n-                double w = (pos - prev);\n@@ -163,2 +271,0 @@\n-            } else {\n-                pos = pos + size[i];\n@@ -166,1 +272,1 @@\n-            prev = pos;\n+            total += c.getWidth();\n@@ -169,1 +275,1 @@\n-        return (pos > target);\n+        return (total > target);\n@@ -172,1 +278,1 @@\n-    protected static double clip(double v, double min, double max) {\n+    private static double clip(double v, double min, double max) {\n@@ -211,1 +317,1 @@\n-        allowedDelta = Math.min(Math.abs(delta), Math.min(allowedDelta, d));\n+        allowedDelta = snapRound(Math.min(Math.abs(delta), Math.min(allowedDelta, d)));\n@@ -223,1 +329,1 @@\n-    protected boolean isCornerCase(double delta, int ix) {\n+    private boolean isCornerCase(double delta, int ix) {\n@@ -239,1 +345,1 @@\n-    protected double getAllowedDelta(int ix, boolean expanding) {\n+    private double getAllowedDelta(int ix, boolean expanding) {\n@@ -248,1 +354,1 @@\n-    protected int markOppositeColumns(int ix) {\n+    private int markOppositeColumns(int ix) {\n@@ -272,1 +378,1 @@\n-    protected void setSkip(int from, int toExclusive) {\n+    private void setSkip(int from, int toExclusive) {\n@@ -285,1 +391,1 @@\n-    protected double computeAllowedDelta(boolean expanding) {\n+    private double computeAllowedDelta(boolean expanding) {\n@@ -306,1 +412,1 @@\n-    protected boolean distributeDelta(int ix, double delta) {\n+    private boolean distributeDelta(int ix, double delta) {\n@@ -328,5 +434,1 @@\n-                if (Math.abs(delta) < SMALL_DELTA) {\n-                    distributeSmallDelta(-delta);\n-                } else {\n-                    distributeDeltaRemainingColumns(-delta);\n-                }\n+                distributeDeltaRemainingColumns(-delta);\n@@ -343,1 +445,6 @@\n-    protected double distributeDeltaFlexHead(double delta) {\n+    private void distributeDeltaRemainingColumns(double delta) {\n+        double[] desired = delta < 0 ? min : max;\n+        distribute(delta, desired);\n+    }\n+\n+    private double distributeDeltaFlexHead(double delta) {\n@@ -387,1 +494,1 @@\n-    protected double distributeDeltaFlexTail(double delta) {\n+    private double distributeDeltaFlexTail(double delta) {\n@@ -431,1 +538,1 @@\n-    protected double resize(int ix, double delta) {\n+    private double resize(int ix, double delta) {\n@@ -447,81 +554,2 @@\n-    protected void distributeDeltaRemainingColumns(double delta) {\n-        boolean needsAnotherPass;\n-\n-        do {\n-            double total = 0;\n-            for (int i = 0; i < count; i++) {\n-                if (!skip.get(i)) {\n-                    total += pref[i];\n-                }\n-            }\n-\n-            if (isZero(total)) {\n-                return;\n-            }\n-\n-            needsAnotherPass = false;\n-\n-            for (int i = 0; i < count; i++) {\n-                if (skip.get(i)) {\n-                    continue;\n-                }\n-\n-                double w = size[i] + (delta * pref[i] \/ total);\n-                if (w < min[i]) {\n-                    w = min[i];\n-                    skip.set(i, true);\n-                    needsAnotherPass = true;\n-                    delta -= (w - size[i]);\n-               } else if (w > max[i]) {\n-                    w = max[i];\n-                    skip.set(i, true);\n-                    needsAnotherPass = true;\n-                    delta -= (w - size[i]);\n-                }\n-\n-                size[i] = w;\n-\n-                if (needsAnotherPass) {\n-                    resetSizeChanges();\n-                    break;\n-                }\n-            }\n-        } while (needsAnotherPass);\n-    }\n-\n-    \/**\n-     * for small deltas, we use a simpler, but more expensive algorithm to distribute space in small steps,\n-     * each time favoring a column that is further away from its preferred width.\n-     *\/\n-    protected void distributeSmallDelta(double delta) {\n-        if (delta < 0) {\n-            while (delta < 0.0) {\n-                double d = Math.max(-1.0, delta);\n-                double rem = shrinkSmall(d);\n-                if (Double.isNaN(rem)) {\n-                    return;\n-                }\n-\n-                delta -= (d - rem);\n-            }\n-        } else {\n-            while (delta > 0.0) {\n-                double d = Math.min(1.0, delta);\n-                double rem = expandSmall(d);\n-                if (Double.isNaN(rem)) {\n-                    return;\n-                }\n-\n-                delta -= (d - rem);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Finds the best column to shrink, then reduces its width.\n-     * Adds the column to skip list if the column width hits a constraint after adjustement.\n-     * @return unused portion of delta, or Double.NaN if it did not find a good candidate\n-     *\/\n-    protected double shrinkSmall(double delta) {\n-        double dist = Double.NEGATIVE_INFINITY;\n-        int ix = -1;\n+    private double sumSizes() {\n+        double sum = 0;\n@@ -529,19 +557,1 @@\n-            if (!skip.get(i)) {\n-                double d = size[i] - pref[i];\n-                if (d > dist) {\n-                    dist = d;\n-                    ix = i;\n-                }\n-            }\n-        }\n-\n-        if (ix < 0) {\n-            return Double.NaN;\n-        }\n-\n-        double rem = 0.0;\n-        double w = size[ix] + delta;\n-        if (w < min[ix]) {\n-            rem = (w - min[ix]);\n-            w = min[ix];\n-            skip.set(ix);\n+            sum += size[i];\n@@ -549,2 +559,1 @@\n-        size[ix] = w;\n-        return rem;\n+        return sum;\n@@ -553,8 +562,2 @@\n-    \/**\n-     * Finds the best column to shrink, then reduces its width.\n-     * Adds the column to skip list if the column width hits a constraint after adjustement.\n-     * @return unused portion of delta, or Double.NaN if it did not find a good candidate\n-     *\/\n-    protected double expandSmall(double delta) {\n-        double dist = Double.NEGATIVE_INFINITY;\n-        int ix = -1;\n+    private double sum(double[] widths) {\n+        double sum = 0.0;\n@@ -562,11 +565,1 @@\n-            if (!skip.get(i)) {\n-                double d = pref[i] - size[i];\n-                if (d > dist) {\n-                    dist = d;\n-                    ix = i;\n-                }\n-            }\n-        }\n-\n-        if (ix < 0) {\n-            return Double.NaN;\n+            sum += widths[i];\n@@ -574,0 +567,2 @@\n+        return sum;\n+    }\n@@ -575,9 +570,2 @@\n-        double rem = 0.0;\n-        double w = size[ix] + delta;\n-        if (w > max[ix]) {\n-            rem = (w - max[ix]);\n-            w = max[ix];\n-            skip.set(ix);\n-        }\n-        size[ix] = w;\n-        return rem;\n+    private static boolean isZero(double x) {\n+        return Math.abs(x) < EPSILON;\n@@ -586,5 +574,3 @@\n-    protected void resetSizeChanges() {\n-        for (int i = 0; i < count; i++) {\n-            if (!skip.get(i)) {\n-                size[i] = columns.get(i).getWidth();\n-            }\n+    private double snapCeil(double x) {\n+        if (snap != null) {\n+            return snap.snapSizeX(x);\n@@ -592,0 +578,1 @@\n+        return x;\n@@ -594,4 +581,3 @@\n-    protected double sumSizes() {\n-        double sum = 0;\n-        for (int i = 0; i < count; i++) {\n-            sum += size[i];\n+    private double snapRound(double x) {\n+        if (snap != null) {\n+            return snap.snapPositionX(x);\n@@ -599,1 +585,1 @@\n-        return sum;\n+        return x;\n@@ -602,2 +588,8 @@\n-    protected static boolean isZero(double x) {\n-        return Math.abs(x) < EPSILON;\n+    private double snapFloor(double x) {\n+        if (snap != null) {\n+            \/\/ there is no public equivalent, but we can copy implementation from Region\n+            \/\/ let's try rounding for now\n+            \/\/ TODO we can implement this since we have snapScale now\n+            return snapRound(x);\n+        }\n+        return x;\n@@ -606,3 +598,13 @@\n-    protected double snap(double x) {\n-        if (snap == null) {\n-            return x;\n+    \/**\n+     * implementation copied from {@link Region}.\n+     * @return returns scene render scale x value\n+     *\/\n+    private double snapScale() {\n+        if (snap != null) {\n+            Scene scene = snap.getScene();\n+            if (scene != null) {\n+                Window window = scene.getWindow();\n+                if (window != null) {\n+                    return window.getRenderScaleX();\n+                }\n+            }\n@@ -610,1 +612,1 @@\n-        return snap.snapSpaceX(x);\n+        return 1.0;\n","filename":"modules\/javafx.controls\/src\/main\/java\/com\/sun\/javafx\/scene\/control\/ResizeHelper.java","additions":221,"deletions":219,"binary":false,"changes":440,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.javafx.scene.layout.RegionHelper;\n@@ -99,2 +100,19 @@\n-  public void setColumnWidth(TableColumnBase<S,?> col, double width) {\n-      col.doSetWidth(width);\n+  public void setColumnWidth(TableColumnBase<S, ?> col, double width) {\n+      Control c = getTableControl();\n+      if (c.isSnapToPixel()) {\n+          double min = c.snapSizeX(col.getMinWidth());\n+          double max = RegionHelper.snapInnerSpaceX(c, col.getMaxWidth());\n+          if (width < min) {\n+              width = min;\n+          } else if (width > max) {\n+              width = max;\n+              if (width < min) {\n+                  \/\/ safety check in case floor(max) < ceil(min)\n+                  width = min;\n+              }\n+          } else {\n+              width = c.snapPositionX(width);\n+          }\n+      }\n+      \/\/ can set width directly because all constraints have been checked\n+      col.setWidth(width);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/ResizeFeaturesBase.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,0 +107,4 @@\n+    public static double snapInnerSpaceX(Node node, double x) {\n+        return regionAccessor.snapInnerSpaceX(node, x);\n+    }\n+\n@@ -124,0 +128,1 @@\n+        double snapInnerSpaceX(Node node, double x);\n@@ -125,1 +130,0 @@\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/layout\/RegionHelper.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -184,0 +184,5 @@\n+\n+            @Override\n+            public double snapInnerSpaceX(Node node, double x) {\n+                return ((Region)node).snapPortionX(x);\n+            }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/layout\/Region.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,31 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<classpath>\n-\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/base\">\n-\t\t<attributes>\n-\t\t\t<attribute name=\"module\" value=\"true\"\/>\n-\t\t<\/attributes>\n-\t<\/classpathentry>\n-\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/graphics\">\n-\t\t<attributes>\n-\t\t\t<attribute name=\"module\" value=\"true\"\/>\n-\t\t<\/attributes>\n-\t<\/classpathentry>\n-\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/controls\">\n-\t\t<attributes>\n-\t\t\t<attribute name=\"module\" value=\"true\"\/>\n-\t\t<\/attributes>\n-\t<\/classpathentry>\n-\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/swing\">\n-\t\t<attributes>\n-\t\t\t<attribute name=\"module\" value=\"true\"\/>\n-\t\t<\/attributes>\n-\t<\/classpathentry>\n-\t<classpathentry kind=\"con\" path=\"org.eclipse.jdt.launching.JRE_CONTAINER\">\n-\t\t<attributes>\n-\t\t\t<attribute name=\"module\" value=\"true\"\/>\n-\t\t<\/attributes>\n-\t<\/classpathentry>\n-\t<classpathentry excluding=\".classpath|.project|.settings|src\/\" kind=\"src\" output=\"bin\" path=\"\"\/>\n-\t<classpathentry kind=\"src\" path=\"src\"\/>\n-\t<classpathentry kind=\"output\" path=\"bin\"\/>\n-<\/classpath>\n","filename":"tests\/manual\/tester\/.classpath","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,17 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<projectDescription>\n-    <name>manualTests-tester<\/name>\n-    <comment><\/comment>\n-    <projects>\n-    <\/projects>\n-    <buildSpec>\n-        <buildCommand>\n-            <name>org.eclipse.jdt.core.javabuilder<\/name>\n-            <arguments>\n-            <\/arguments>\n-        <\/buildCommand>\n-    <\/buildSpec>\n-    <natures>\n-        <nature>org.eclipse.jdt.core.javanature<\/nature>\n-    <\/natures>\n-<\/projectDescription>\n","filename":"tests\/manual\/tester\/.project","additions":0,"deletions":17,"binary":false,"changes":17,"status":"deleted"},{"patch":"@@ -1,2 +0,0 @@\n-eclipse.preferences.version=1\n-encoding\/<project>=UTF-8\n","filename":"tests\/manual\/tester\/.settings\/org.eclipse.core.resources.prefs","additions":0,"deletions":2,"binary":false,"changes":2,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Provides manual test applications.\n- *\/\n-module test.manual {\n-    exports com.oracle.javafx.tester;\n-\n-    requires javafx.base;\n-    requires javafx.controls;\n-    requires javafx.graphics;\n-    requires java.desktop;\n-    requires javafx.swing;\n-}\n","filename":"tests\/manual\/tester\/src\/module-info.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -466,1 +466,2 @@\n-     * When scale cannot be determined it is assumed to be 1.0.\n+     * This amount equals to half of screen pixel converted to logical coordinates.\n+     * When scale cannot be determined it is assumed to be 0.5.\n@@ -481,1 +482,1 @@\n-                    return 1.0 \/ scale;\n+                    return 0.5 \/ scale;\n@@ -484,2 +485,2 @@\n-            \/\/ default to 1 when the scale cannot be determited\n-            return 1.0;\n+            \/\/ when the scale cannot be determited\n+            return 0.5;\n","filename":"tests\/system\/src\/test\/java\/test\/util\/Util.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}