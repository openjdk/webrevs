{"files":[{"patch":"@@ -108,13 +108,1 @@\n-            DoubleProperty fixedCellSizeProperty = tableView.fixedCellSizeProperty();\n-            if (fixedCellSizeProperty != null) {\n-                registerChangeListener(fixedCellSizeProperty, e -> {\n-                    fixedCellSize = fixedCellSizeProperty.get();\n-                    fixedCellSizeEnabled = fixedCellSize > 0;\n-                });\n-                fixedCellSize = fixedCellSizeProperty.get();\n-                fixedCellSizeEnabled = fixedCellSize > 0;\n-\n-                \/\/ JDK-8144500:\n-                \/\/ When in fixed cell size mode, we must listen to the width of the virtual flow, so\n-                \/\/ that when it changes, we can appropriately add \/ remove cells that may or may not\n-                \/\/ be required (because we remove all cells that are not visible).\n+            registerChangeListener(tableView.fixedCellSizeProperty(), e -> {\n@@ -123,1 +111,20 @@\n-                    registerChangeListener(virtualFlow.widthProperty(), e -> tableView.requestLayout());\n+                    unregisterChangeListeners(virtualFlow.widthProperty());\n+                }\n+\n+                updateCachedFixedSize();\n+            });\n+\n+            updateCachedFixedSize();\n+        }\n+    }\n+\n+    private void updateCachedFixedSize() {\n+        TableView<T> tableView = getSkinnable().getTableView();\n+        if (tableView != null) {\n+            fixedCellSize = tableView.getFixedCellSize();\n+            fixedCellSizeEnabled = fixedCellSize > 0;\n+\n+            if (fixedCellSizeEnabled) {\n+                VirtualFlow<TableRow<T>> virtualFlow = getVirtualFlow();\n+                if (virtualFlow != null) {\n+                    registerChangeListener(virtualFlow.widthProperty(), e -> getSkinnable().requestLayout());\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableRowSkin.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import javafx.geometry.Insets;\n@@ -98,5 +97,0 @@\n-    \/\/ Specifies the number of times we will call 'recreateCells()' before we blow\n-    \/\/ out the cellsMap structure and rebuild all cells. This helps to prevent\n-    \/\/ against memory leaks in certain extreme circumstances.\n-    private static final int DEFAULT_FULL_REFRESH_COUNTER = 100;\n-\n@@ -116,5 +110,0 @@\n-     *\n-     * Note that this means that it is possible for this map to therefore be\n-     * a memory leak if an application uses TableView and is creating and removing\n-     * a large number of tableColumns. This is mitigated in the recreateCells()\n-     * function below - refer to that to learn more.\n@@ -127,2 +116,0 @@\n-    private int fullRefreshCounter = DEFAULT_FULL_REFRESH_COUNTER;\n-\n@@ -130,1 +117,0 @@\n-    boolean updateCells = false;\n@@ -155,1 +141,1 @@\n-        updateCells(true);\n+        updateCells();\n@@ -179,1 +165,1 @@\n-    private void updateLeafColumns() {\n+    void updateLeafColumns() {\n@@ -292,1 +278,0 @@\n-                        final int thisIndex = getSkinnable().getIndex();\n@@ -321,0 +306,1 @@\n+        VirtualFlow<C> virtualFlow = getVirtualFlow();\n@@ -325,0 +311,2 @@\n+            width = snapSizeX(tableColumn.getWidth());\n+\n@@ -336,1 +324,1 @@\n-                isVisible = isColumnPartiallyOrFullyVisible(tableColumn);\n+                isVisible = isColumnPartiallyOrFullyVisible(x, width, virtualFlow);\n@@ -345,1 +333,1 @@\n-                if (fixedCellSizeEnabled && tableCell.getParent() == null) {\n+                if (tableCell.getParent() == null) {\n@@ -348,3 +336,0 @@\n-                \/\/ Note: prefWidth() has to be called only after the tableCell is added to the tableRow, if it wasn't\n-                \/\/ already. Otherwise, it might not have its skin yet, and its pref width is therefore 0.\n-                width = tableCell.prefWidth(height);\n@@ -422,5 +407,1 @@\n-                width = tableCell.prefWidth(height);\n-                if (fixedCellSizeEnabled) {\n-                    \/\/ we only add\/remove to the scenegraph if the fixed cell\n-                    \/\/ length support is enabled - otherwise we keep all\n-                    \/\/ TableCells in the scenegraph\n+                if (tableCell.getParent() != null) {\n@@ -476,12 +457,1 @@\n-    void updateCells(boolean resetChildren) {\n-        \/\/ To avoid a potential memory leak (when the TableColumns in the\n-        \/\/ TableView are created\/inserted\/removed\/deleted, we have a 'refresh\n-        \/\/ counter' that when we reach 0 will delete all cells in this row\n-        \/\/ and recreate all of them.\n-        if (resetChildren) {\n-            if (fullRefreshCounter == 0) {\n-                recreateCells();\n-            }\n-            fullRefreshCounter--;\n-        }\n-\n+    void updateCells() {\n@@ -490,1 +460,0 @@\n-        final boolean cellsEmpty = cells.isEmpty();\n@@ -521,17 +490,1 @@\n-        \/\/ update children of each row\n-        if (fixedCellSizeEnabled) {\n-            \/\/ we leave the adding \/ removing up to the layoutChildren method mostly, but here we remove any children\n-            \/\/ cells that refer to columns that are removed or not visible.\n-            List<Node> toRemove = new ArrayList<>();\n-            for (Node cell : getChildren()) {\n-                if (!(cell instanceof IndexedCell)) continue;\n-                TableColumnBase<T, ?> tableColumn = getTableColumn((R) cell);\n-                if (!getVisibleLeafColumns().contains(tableColumn)) {\n-                    toRemove.add(cell);\n-                }\n-            }\n-            getChildren().removeAll(toRemove);\n-        }\n-        if (resetChildren || cellsEmpty) {\n-            getChildren().setAll(cells);\n-        }\n+        getChildren().setAll(cells);\n@@ -633,1 +586,1 @@\n-            updateCells(true);\n+            updateCells();\n@@ -635,4 +588,0 @@\n-            updateCells = false;\n-        } else if (updateCells) {\n-            updateCells(false);\n-            updateCells = false;\n@@ -658,2 +607,2 @@\n-    private boolean isColumnPartiallyOrFullyVisible(TableColumnBase col) {\n-        if (col == null || !col.isVisible()) return false;\n+    private boolean isColumnPartiallyOrFullyVisible(double start, double width, VirtualFlow<C> virtualFlow) {\n+        double end = start + width;\n@@ -661,1 +610,0 @@\n-        final VirtualFlow<?> virtualFlow = getVirtualFlow();\n@@ -663,0 +611,2 @@\n+        double headerWidth = virtualFlow == null ? 0.0 : virtualFlow.getViewportBreadth();\n+        double virtualFlowWidth = headerWidth + scrollX;\n@@ -664,15 +614,1 @@\n-        \/\/ work out where this column header is, and it's width (start -> end)\n-        double start = 0;\n-        final ObservableList<? extends TableColumnBase> visibleLeafColumns = getVisibleLeafColumns();\n-        for (int i = 0, max = visibleLeafColumns.size(); i < max; i++) {\n-            TableColumnBase<?,?> c = visibleLeafColumns.get(i);\n-            if (c.equals(col)) break;\n-            start += c.getWidth();\n-        }\n-        double end = start + col.getWidth();\n-\n-        \/\/ determine the width of the table\n-        final Insets padding = getSkinnable().getPadding();\n-        double headerWidth = getSkinnable().getWidth() - padding.getLeft() + padding.getRight();\n-\n-        return (start >= scrollX || end > scrollX) && (start < (headerWidth + scrollX) || end <= (headerWidth + scrollX));\n+        return (start >= scrollX || end > scrollX) && (start < virtualFlowWidth || end <= virtualFlowWidth);\n@@ -682,1 +618,0 @@\n-        updateCells = true;\n@@ -684,1 +619,0 @@\n-\n@@ -716,1 +650,0 @@\n-        fullRefreshCounter = DEFAULT_FULL_REFRESH_COUNTER;\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TableRowSkinBase.java","additions":16,"deletions":83,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-    private boolean childrenDirty = false;\n@@ -100,4 +99,0 @@\n-        lh.addChangeListener(control.indexProperty(), (ev) -> {\n-            updateCells = true;\n-        });\n-\n@@ -124,7 +119,1 @@\n-                \/\/ Fix for JDK-8124861: Need to set isDirty to true, rather than the\n-                \/\/ cheaper updateCells, as otherwise the text indentation will not\n-                \/\/ be recalculated in TreeTableCellSkin.calculateIndentation()\n-                isDirty = true;\n-                if (getSkinnable() != null) {\n-                    getSkinnable().requestLayout();\n-                }\n+                updateLeafColumns();\n@@ -133,11 +122,1 @@\n-            DoubleProperty fixedCellSizeProperty = getTreeTableView().fixedCellSizeProperty();\n-            if (fixedCellSizeProperty != null) {\n-                registerChangeListener(fixedCellSizeProperty, (x) -> {\n-                    updateCachedFixedSize();\n-                });\n-                updateCachedFixedSize();\n-\n-                \/\/ JDK-8144500:\n-                \/\/ When in fixed cell size mode, we must listen to the width of the virtual flow, so\n-                \/\/ that when it changes, we can appropriately add \/ remove cells that may or may not\n-                \/\/ be required (because we remove all cells that are not visible).\n+            registerChangeListener(getTreeTableView().fixedCellSizeProperty(), e -> {\n@@ -146,6 +125,1 @@\n-                    registerChangeListener(getVirtualFlow().widthProperty(), (x) -> {\n-                        if (getSkinnable() != null) {\n-                            TreeTableView<T> t = getSkinnable().getTreeTableView();\n-                            t.requestLayout();\n-                        }\n-                    });\n+                    unregisterChangeListeners(virtualFlow.widthProperty());\n@@ -153,1 +127,4 @@\n-            }\n+\n+                updateCachedFixedSize();\n+            });\n+            updateCachedFixedSize();\n@@ -163,0 +140,7 @@\n+\n+                if (fixedCellSizeEnabled) {\n+                    VirtualFlow<TreeTableRow<T>> virtualFlow = getTableViewSkin().getVirtualFlow();\n+                    if (virtualFlow != null) {\n+                        registerChangeListener(virtualFlow.widthProperty(), ev -> getSkinnable().requestLayout());\n+                    }\n+                }\n@@ -232,12 +216,0 @@\n-\n-        if (childrenDirty) {\n-            childrenDirty = false;\n-            if (cells.isEmpty()) {\n-                getChildren().clear();\n-            } else {\n-                \/\/ TODO we can optimise this by only showing cells that are\n-                \/\/ visible based on the table width and the amount of horizontal\n-                \/\/ scrolling.\n-                getChildren().addAll(cells);\n-            }\n-        }\n@@ -248,3 +220,3 @@\n-        if (disclosureNodeDirty) {\n-            updateDisclosureNodeAndGraphic();\n-            disclosureNodeDirty = false;\n+        Node disclosureNode = getDisclosureNode();\n+        if (disclosureNode != null && disclosureNode.getParent() == null) {\n+            disclosureNodeDirty = true;\n@@ -253,2 +225,1 @@\n-        Node disclosureNode = getDisclosureNode();\n-        if (disclosureNode != null && disclosureNode.getScene() == null) {\n+        if (disclosureNodeDirty) {\n@@ -280,2 +251,2 @@\n-    @Override void updateCells(boolean resetChildren) {\n-        super.updateCells(resetChildren);\n+    @Override void updateCells() {\n+        super.updateCells();\n@@ -283,4 +254,1 @@\n-        if (resetChildren) {\n-            childrenDirty = true;\n-            updateChildren();\n-        }\n+        updateDisclosureNodeAndGraphic();\n@@ -355,0 +323,2 @@\n+        disclosureNodeDirty = false;\n+\n@@ -378,1 +348,1 @@\n-            boolean disclosureVisible = treeItem != null && ! treeItem.isLeaf();\n+            boolean disclosureVisible = isDisclosureNodeVisible();\n@@ -381,1 +351,1 @@\n-            if (! disclosureVisible) {\n+            if (!disclosureVisible) {\n@@ -385,1 +355,0 @@\n-                disclosureNode.toFront();\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/TreeTableRowSkin.java","additions":25,"deletions":56,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -1084,1 +1084,1 @@\n-            sheet.getChildren().clear();\n+            sheetChildren.clear();\n@@ -1141,0 +1141,7 @@\n+\n+            \/\/ Also request layout for cells in the pile. As soon as those are reused (and therefore added),\n+            \/\/ they will do their layout.\n+            for (T cell : pile) {\n+                cell.requestLayout();\n+            }\n+\n@@ -1919,1 +1926,1 @@\n-    private final double getViewportBreadth() {\n+    final double getViewportBreadth() {\n@@ -2846,0 +2853,5 @@\n+        \/\/ Remove all cells that are in the pile and therefore not relevant anymore.\n+        if (sheetChildren.size() != cells.size()) {\n+            sheetChildren.removeAll(pile);\n+        }\n+\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/skin\/VirtualFlow.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -212,5 +212,0 @@\n-            \/\/ we need to account for TreeTableView having LabeledText node in the TreeTableRow\n-            if (indexedCell instanceof TreeTableRow) {\n-                _column++;\n-            }\n-\n@@ -339,2 +334,0 @@\n-    public static boolean BLOCK_STAGE_LOADER_DISPOSE = false;\n-\n@@ -343,1 +336,0 @@\n-        boolean stageLoaderCreated = false;\n@@ -346,1 +338,0 @@\n-            stageLoaderCreated = true;\n@@ -358,1 +349,1 @@\n-        if (stageLoaderCreated && sl != null && ! BLOCK_STAGE_LOADER_DISPOSE) {\n+        if (sl != null) {\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/com\/sun\/javafx\/scene\/control\/infrastructure\/VirtualFlowTestUtils.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2199,1 +2199,1 @@\n-        VirtualFlowTestUtils.BLOCK_STAGE_LOADER_DISPOSE = true;\n+        stageLoader = new StageLoader(table);\n@@ -2201,1 +2201,0 @@\n-        VirtualFlowTestUtils.BLOCK_STAGE_LOADER_DISPOSE = false;\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TableViewTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,549 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.control;\n+\n+import com.sun.javafx.scene.control.VirtualScrollBar;\n+import com.sun.javafx.tk.Toolkit;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.collections.FXCollections;\n+import javafx.scene.Node;\n+import javafx.scene.control.IndexedCell;\n+import javafx.scene.control.TableCell;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableView;\n+import javafx.scene.control.skin.VirtualFlow;\n+import javafx.scene.control.skin.VirtualFlowShim;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import test.com.sun.javafx.scene.control.infrastructure.StageLoader;\n+import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+\n+class TableViewVirtualizationTest {\n+\n+    private StageLoader stageLoader;\n+    private TableView<String> tableView;\n+\n+    @BeforeEach\n+    void setUp() {\n+        tableView = new TableView<>();\n+        tableView.setFixedCellSize(24);\n+        tableView.setPrefWidth(300);\n+        tableView.setPrefHeight(300);\n+        tableView.setItems(FXCollections.observableArrayList(\"1\", \"2\", \"3\", \"4\"));\n+\n+        for (int index = 0; index < 5; index++) {\n+            TableColumn<String, String> tableColumn = new TableColumn<>(String.valueOf(index));\n+            tableColumn.setPrefWidth(100);\n+            tableView.getColumns().add(tableColumn);\n+        }\n+\n+        stageLoader = new StageLoader(tableView);\n+\n+        Toolkit.getToolkit().firePulse();\n+    }\n+\n+    @AfterEach\n+    void cleanUp() {\n+        if (stageLoader != null) {\n+            stageLoader.dispose();\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationInitial() {\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationClearColumns() {\n+        tableView.getColumns().clear();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 0);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationAddColumnsOneByOne() {\n+        tableView.getColumns().clear();\n+        Toolkit.getToolkit().firePulse();\n+\n+        TableColumn<String, String> tableColumn = new TableColumn<>(\"Column\");\n+        tableColumn.setPrefWidth(100);\n+        tableView.getColumns().add(tableColumn);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 1);\n+        }\n+\n+        tableColumn = new TableColumn<>(\"Column\");\n+        tableColumn.setPrefWidth(100);\n+        tableView.getColumns().add(tableColumn);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 2);\n+        }\n+\n+        tableColumn = new TableColumn<>(\"Column\");\n+        tableColumn.setPrefWidth(100);\n+        tableView.getColumns().add(tableColumn);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+\n+        tableColumn = new TableColumn<>(\"Column\");\n+        tableColumn.setPrefWidth(100);\n+        tableView.getColumns().add(tableColumn);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+\n+        tableColumn = new TableColumn<>(\"Column\");\n+        tableColumn.setPrefWidth(100);\n+        tableView.getColumns().add(tableColumn);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationRemoveFirstColumn() {\n+        tableView.getColumns().removeFirst();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationRemoveLastColumn() {\n+        tableView.getColumns().removeLast();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationAddFirstColumn() {\n+        TableColumn<String, String> tableColumn = new TableColumn<>(\"NEW\");\n+        tableColumn.setPrefWidth(50);\n+        tableView.getColumns().addFirst(tableColumn);\n+\n+        \/\/ Needs a double pulse so that the viewport breadth is correctly calculated.\n+        Toolkit.getToolkit().firePulse();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 4);\n+        }\n+\n+        VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowHorizontalScrollbar(tableView);\n+\n+        scrollBar.setValue(scrollBar.getMax());\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationAddLastColumn() {\n+        TableColumn<String, String> tableColumn = new TableColumn<>(\"NEW\");\n+        tableColumn.setPrefWidth(50);\n+        tableView.getColumns().addLast(tableColumn);\n+\n+        \/\/ Needs a double pulse so that the viewport breadth is correctly calculated.\n+        Toolkit.getToolkit().firePulse();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+\n+        VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowHorizontalScrollbar(tableView);\n+        scrollBar.setValue(scrollBar.getMax());\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 4);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationRemoveAllColumnsFromLast() {\n+        tableView.getColumns().removeLast();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+\n+        tableView.getColumns().removeLast();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+\n+        tableView.getColumns().removeLast();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 2);\n+        }\n+\n+        tableView.getColumns().removeLast();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 1);\n+        }\n+\n+        tableView.getColumns().removeLast();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            assertCellCountInRow(index, 0);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationRemoveAllColumnsFromFirst() {\n+        tableView.getColumns().removeFirst();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(3, getCellCount(row));\n+        }\n+\n+        tableView.getColumns().removeFirst();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(3, getCellCount(row));\n+        }\n+\n+        tableView.getColumns().removeFirst();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(2, getCellCount(row));\n+        }\n+\n+        tableView.getColumns().removeFirst();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(1, getCellCount(row));\n+        }\n+\n+        tableView.getColumns().removeFirst();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(0, getCellCount(row));\n+        }\n+    }\n+\n+    \/**\n+     * This test does the same as JavaFX is doing when reordering a column (via dragging).\n+     * We expect that the cells match with the table columns.\n+     *\/\n+    @Test\n+    void testHorizontalVirtualizationMoveColumn() {\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(3, row.getChildrenUnmodifiable().size());\n+            for (int cellIndex = 0; cellIndex < row.getChildrenUnmodifiable().size(); cellIndex++) {\n+                Node cell = row.getChildrenUnmodifiable().get(cellIndex);\n+                if (cell instanceof TableCell<?, ?> tableCell) {\n+                    assertSame(tableView.getColumns().get(cellIndex), tableCell.getTableColumn());\n+                }\n+            }\n+        }\n+\n+        TableColumn<String, ?> columnToMove = tableView.getColumns().getLast();\n+\n+        List<TableColumn<String, ?>> allColumns = new ArrayList<>(tableView.getColumns());\n+        allColumns.remove(columnToMove);\n+        allColumns.addFirst(columnToMove);\n+\n+        tableView.getColumns().setAll(allColumns);\n+\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(3, row.getChildrenUnmodifiable().size());\n+            for (int cellIndex = 0; cellIndex < row.getChildrenUnmodifiable().size(); cellIndex++) {\n+                Node cell = row.getChildrenUnmodifiable().get(cellIndex);\n+                if (cell instanceof TableCell<?, ?> tableCell) {\n+                    assertSame(tableView.getColumns().get(cellIndex), tableCell.getTableColumn());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationInitialChangeFixedCellSize() {\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(3, row.getChildrenUnmodifiable().size());\n+        }\n+\n+        tableView.setFixedCellSize(-1);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(5, row.getChildrenUnmodifiable().size());\n+        }\n+\n+        tableView.setFixedCellSize(24);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(3, row.getChildrenUnmodifiable().size());\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationScrolledToEnd() {\n+        VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowHorizontalScrollbar(tableView);\n+\n+        scrollBar.setValue(scrollBar.getMax());\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(3, row.getChildrenUnmodifiable().size());\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationScrolledToEndAndStart() {\n+        VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowHorizontalScrollbar(tableView);\n+\n+        scrollBar.setValue(scrollBar.getMax());\n+        Toolkit.getToolkit().firePulse();\n+\n+        scrollBar.setValue(0);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(3, row.getChildrenUnmodifiable().size());\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationScrolledToEndAndNearStartAndStart() {\n+        VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowHorizontalScrollbar(tableView);\n+\n+        scrollBar.setValue(scrollBar.getMax());\n+        Toolkit.getToolkit().firePulse();\n+\n+        scrollBar.setValue(10);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(4, getCellCount(row));\n+        }\n+\n+        scrollBar.setValue(0);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(3, getCellCount(row));\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationIncreaseTableWidth() {\n+        tableView.setPrefWidth(400);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(4, row.getChildrenUnmodifiable().size());\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationDecreaseTableWidth() {\n+        tableView.setPrefWidth(200);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(2, row.getChildrenUnmodifiable().size());\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationIncreaseColumnSize() {\n+        tableView.getColumns().getFirst().setPrefWidth(200);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(2, row.getChildrenUnmodifiable().size());\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationDecreaseColumnSize() {\n+        tableView.getColumns().getFirst().setPrefWidth(50);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < tableView.getItems().size(); index++) {\n+            IndexedCell<?> row = getRow(index);\n+\n+            assertEquals(4, row.getChildrenUnmodifiable().size());\n+        }\n+    }\n+\n+    \/**\n+     * More complex test scenario where we:\n+     * <ul>\n+     *     <li>1. Scroll to the bottom right first<\/li>\n+     *     <li>2. Resize the table<\/li>\n+     *     <li>3. Scroll to the left and a little bit up<\/li>\n+     *     <li>4. Check, that the cells of the rendered rows do not contain outdated items<\/li>\n+     * <\/ul>\n+     *\/\n+    @Test\n+    void testHorizontalVirtualizationDoesNotBreakTableCells() {\n+        tableView.setPrefHeight(500);\n+        tableView.setPrefWidth(500);\n+\n+        final String cellValue = \"NOT VISIBLE\";\n+\n+        for (int index = 0; index < 15; index++) {\n+            TableColumn<String, String> tableColumn = new TableColumn<>(String.valueOf(index));\n+            tableColumn.setPrefWidth(100);\n+            tableColumn.setCellValueFactory(_ -> new SimpleStringProperty(cellValue));\n+            tableView.getColumns().add(tableColumn);\n+        }\n+\n+        for (int index = 0; index < 100; index++) {\n+            tableView.getItems().add(String.valueOf(index));\n+        }\n+\n+        Toolkit.getToolkit().firePulse();\n+\n+        VirtualScrollBar vbar = VirtualFlowTestUtils.getVirtualFlowVerticalScrollbar(tableView);\n+        VirtualScrollBar hbar = VirtualFlowTestUtils.getVirtualFlowHorizontalScrollbar(tableView);\n+\n+        vbar.setValue(vbar.getMax());\n+        Toolkit.getToolkit().firePulse();\n+\n+        hbar.setValue(hbar.getMax());\n+        Toolkit.getToolkit().firePulse();\n+\n+        tableView.setPrefHeight(300);\n+        Toolkit.getToolkit().firePulse();\n+\n+        hbar.setValue(0);\n+        Toolkit.getToolkit().firePulse();\n+\n+        vbar.setValue(0.85);\n+        Toolkit.getToolkit().firePulse();\n+\n+        VirtualFlow<IndexedCell<?>> virtualFlow = VirtualFlowShim.getVirtualFlow(tableView.getSkin());\n+\n+        List<IndexedCell<?>> rows = VirtualFlowShim.getCells(virtualFlow);\n+        for (IndexedCell<?> row : rows) {\n+            for (Node cell : row.getChildrenUnmodifiable()) {\n+                if (cell instanceof TableCell<?, ?> tableCell) {\n+                    assertNotEquals(cellValue, tableCell.getItem());\n+                }\n+            }\n+        }\n+    }\n+\n+    private IndexedCell<?> getRow(int index) {\n+        return VirtualFlowTestUtils.getVirtualFlow(tableView).getVisibleCell(index);\n+    }\n+\n+    private int getCellCount(IndexedCell<?> row) {\n+        return row.getChildrenUnmodifiable().size();\n+    }\n+\n+    private void assertCellCountInRow(int index, int count) {\n+        IndexedCell<?> row = getRow(index);\n+        assertEquals(count, getCellCount(row));\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TableViewVirtualizationTest.java","additions":549,"deletions":0,"binary":false,"changes":549,"status":"added"},{"patch":"@@ -3278,0 +3278,2 @@\n+        stageLoader = new StageLoader(table);\n+\n@@ -3279,1 +3281,0 @@\n-        VirtualFlowTestUtils.BLOCK_STAGE_LOADER_DISPOSE = true;\n@@ -3281,1 +3282,0 @@\n-        VirtualFlowTestUtils.BLOCK_STAGE_LOADER_DISPOSE = false;\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeTableViewTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,519 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.scene.control;\n+\n+import com.sun.javafx.scene.control.VirtualScrollBar;\n+import com.sun.javafx.tk.Toolkit;\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.scene.Node;\n+import javafx.scene.control.IndexedCell;\n+import javafx.scene.control.TreeItem;\n+import javafx.scene.control.TreeTableCell;\n+import javafx.scene.control.TreeTableColumn;\n+import javafx.scene.control.TreeTableView;\n+import javafx.scene.control.skin.VirtualFlow;\n+import javafx.scene.control.skin.VirtualFlowShim;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import test.com.sun.javafx.scene.control.infrastructure.StageLoader;\n+import test.com.sun.javafx.scene.control.infrastructure.VirtualFlowTestUtils;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+\n+class TreeTableViewVirtualizationTest {\n+\n+    private StageLoader stageLoader;\n+    private TreeTableView<String> treeTableView;\n+\n+    @BeforeEach\n+    void setUp() {\n+        treeTableView = new TreeTableView<>();\n+        treeTableView.setFixedCellSize(24);\n+        treeTableView.setPrefWidth(300);\n+        treeTableView.setShowRoot(false);\n+        treeTableView.setRoot(new TreeItem<>());\n+        treeTableView.getRoot().getChildren()\n+                .addAll(new TreeItem<>(\"1\"), new TreeItem<>(\"2\"), new TreeItem<>(\"3\"), new TreeItem<>(\"4\"));\n+\n+        for (int index = 0; index < 5; index++) {\n+            TreeTableColumn<String, String> tableColumn = new TreeTableColumn<>(String.valueOf(index));\n+            tableColumn.setPrefWidth(100);\n+            treeTableView.getColumns().add(tableColumn);\n+        }\n+\n+        stageLoader = new StageLoader(treeTableView);\n+\n+        Toolkit.getToolkit().firePulse();\n+    }\n+\n+    @AfterEach\n+    void cleanUp() {\n+        if (stageLoader != null) {\n+            stageLoader.dispose();\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationInitial() {\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationClearColumns() {\n+        treeTableView.getColumns().clear();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 0);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationAddColumnsOneByOne() {\n+        treeTableView.getColumns().clear();\n+        Toolkit.getToolkit().firePulse();\n+\n+        TreeTableColumn<String, String> tableColumn = new TreeTableColumn<>(\"Column\");\n+        tableColumn.setPrefWidth(100);\n+        treeTableView.getColumns().add(tableColumn);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 1);\n+        }\n+\n+        tableColumn = new TreeTableColumn<>(\"Column\");\n+        tableColumn.setPrefWidth(100);\n+        treeTableView.getColumns().add(tableColumn);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 2);\n+        }\n+\n+        tableColumn = new TreeTableColumn<>(\"Column\");\n+        tableColumn.setPrefWidth(100);\n+        treeTableView.getColumns().add(tableColumn);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+\n+        tableColumn = new TreeTableColumn<>(\"Column\");\n+        tableColumn.setPrefWidth(100);\n+        treeTableView.getColumns().add(tableColumn);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+\n+        tableColumn = new TreeTableColumn<>(\"Column\");\n+        tableColumn.setPrefWidth(100);\n+        treeTableView.getColumns().add(tableColumn);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationRemoveFirstColumn() {\n+        treeTableView.getColumns().removeFirst();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationRemoveLastColumn() {\n+        treeTableView.getColumns().removeLast();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationAddFirstColumn() {\n+        TreeTableColumn<String, String> tableColumn = new TreeTableColumn<>(\"NEW\");\n+        tableColumn.setPrefWidth(50);\n+        treeTableView.getColumns().addFirst(tableColumn);\n+\n+        \/\/ Needs a double pulse so that the viewport breadth is correctly calculated.\n+        Toolkit.getToolkit().firePulse();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 4);\n+        }\n+\n+        VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowHorizontalScrollbar(treeTableView);\n+\n+        scrollBar.setValue(scrollBar.getMax());\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationAddLastColumn() {\n+        TreeTableColumn<String, String> tableColumn = new TreeTableColumn<>(\"NEW\");\n+        tableColumn.setPrefWidth(50);\n+        treeTableView.getColumns().addLast(tableColumn);\n+\n+        \/\/ Needs a double pulse so that the viewport breadth is correctly calculated.\n+        Toolkit.getToolkit().firePulse();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+\n+        VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowHorizontalScrollbar(treeTableView);\n+\n+        scrollBar.setValue(scrollBar.getMax());\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 4);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationRemoveAllColumnsFromLast() {\n+        treeTableView.getColumns().removeLast();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+\n+        treeTableView.getColumns().removeLast();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+\n+        treeTableView.getColumns().removeLast();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 2);\n+        }\n+\n+        treeTableView.getColumns().removeLast();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 1);\n+        }\n+\n+        treeTableView.getColumns().removeLast();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 0);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationRemoveAllColumnsFromFirst() {\n+        treeTableView.getColumns().removeFirst();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+\n+        treeTableView.getColumns().removeFirst();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+\n+        treeTableView.getColumns().removeFirst();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 2);\n+        }\n+\n+        treeTableView.getColumns().removeFirst();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 1);\n+        }\n+\n+        treeTableView.getColumns().removeFirst();\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 0);\n+        }\n+    }\n+\n+    \/**\n+     * This test does the same as JavaFX is doing when reordering a column (via dragging).\n+     * We expect that the cells match with the table columns.\n+     *\/\n+    @Test\n+    void testHorizontalVirtualizationMoveColumn() {\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+\n+            IndexedCell<?> row = getRow(index);\n+            for (int cellIndex = 0; cellIndex < row.getChildrenUnmodifiable().size(); cellIndex++) {\n+                Node cell = row.getChildrenUnmodifiable().get(cellIndex);\n+                if (cell instanceof TreeTableCell<?, ?> tableCell) {\n+                    assertSame(treeTableView.getColumns().get(cellIndex), tableCell.getTableColumn());\n+                }\n+            }\n+        }\n+\n+        TreeTableColumn<String, ?> columnToMove = treeTableView.getColumns().getLast();\n+\n+        List<TreeTableColumn<String, ?>> allColumns = new ArrayList<>(treeTableView.getColumns());\n+        allColumns.remove(columnToMove);\n+        allColumns.addFirst(columnToMove);\n+\n+        treeTableView.getColumns().setAll(allColumns);\n+\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+\n+            IndexedCell<?> row = getRow(index);\n+            for (int cellIndex = 0; cellIndex < row.getChildrenUnmodifiable().size(); cellIndex++) {\n+                Node cell = row.getChildrenUnmodifiable().get(cellIndex);\n+                if (cell instanceof TreeTableCell<?, ?> tableCell) {\n+                    assertSame(treeTableView.getColumns().get(cellIndex), tableCell.getTableColumn());\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationInitialChangeFixedCellSize() {\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+\n+        treeTableView.setFixedCellSize(-1);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 5);\n+        }\n+\n+        treeTableView.setFixedCellSize(24);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationScrolledToEnd() {\n+        VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowHorizontalScrollbar(treeTableView);\n+\n+        scrollBar.setValue(scrollBar.getMax());\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationScrolledToEndAndNearStart() {\n+        VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowHorizontalScrollbar(treeTableView);\n+\n+        scrollBar.setValue(scrollBar.getMax());\n+        Toolkit.getToolkit().firePulse();\n+\n+        scrollBar.setValue(10);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 4);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationScrolledToEndAndNearStartAndStart() {\n+        VirtualScrollBar scrollBar = VirtualFlowTestUtils.getVirtualFlowHorizontalScrollbar(treeTableView);\n+\n+        scrollBar.setValue(scrollBar.getMax());\n+        Toolkit.getToolkit().firePulse();\n+\n+        scrollBar.setValue(10);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 4);\n+        }\n+\n+        scrollBar.setValue(0);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 3);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationIncreaseTableWidth() {\n+        treeTableView.setPrefWidth(400);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 4);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationDecreaseTableWidth() {\n+        treeTableView.setPrefWidth(200);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 2);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationIncreaseColumnSize() {\n+        treeTableView.getColumns().getFirst().setPrefWidth(200);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 2);\n+        }\n+    }\n+\n+    @Test\n+    void testHorizontalVirtualizationDecreaseColumnSize() {\n+        treeTableView.getColumns().getFirst().setPrefWidth(50);\n+        Toolkit.getToolkit().firePulse();\n+\n+        for (int index = 0; index < treeTableView.getRoot().getChildren().size(); index++) {\n+            assertCellCountInRow(index, 4);\n+        }\n+    }\n+\n+    \/**\n+     * More complex test scenario where we:\n+     * <ul>\n+     *     <li>1. Scroll to the bottom right first<\/li>\n+     *     <li>2. Resize the table<\/li>\n+     *     <li>3. Scroll to the left and a little bit up<\/li>\n+     *     <li>4. Check, that the cells of the rendered rows do not contain outdated items<\/li>\n+     * <\/ul>\n+     *\/\n+    @Test\n+    void testHorizontalVirtualizationDoesNotBreakTableCells() {\n+        treeTableView.setPrefHeight(500);\n+        treeTableView.setPrefWidth(500);\n+\n+        final String cellValue = \"NOT VISIBLE\";\n+\n+        for (int index = 0; index < 15; index++) {\n+            TreeTableColumn<String, String> tableColumn = new TreeTableColumn<>(String.valueOf(index));\n+            tableColumn.setPrefWidth(100);\n+            tableColumn.setCellValueFactory(_ -> new SimpleStringProperty(cellValue));\n+            treeTableView.getColumns().add(tableColumn);\n+        }\n+\n+        for (int index = 0; index < 100; index++) {\n+            treeTableView.getRoot().getChildren().add(new TreeItem<>(String.valueOf(index)));\n+        }\n+\n+        Toolkit.getToolkit().firePulse();\n+\n+        VirtualScrollBar vbar = VirtualFlowTestUtils.getVirtualFlowVerticalScrollbar(treeTableView);\n+        VirtualScrollBar hbar = VirtualFlowTestUtils.getVirtualFlowHorizontalScrollbar(treeTableView);\n+\n+        vbar.setValue(vbar.getMax());\n+        Toolkit.getToolkit().firePulse();\n+\n+        hbar.setValue(hbar.getMax());\n+        Toolkit.getToolkit().firePulse();\n+\n+        treeTableView.setPrefHeight(300);\n+        Toolkit.getToolkit().firePulse();\n+\n+        hbar.setValue(0);\n+        Toolkit.getToolkit().firePulse();\n+\n+        vbar.setValue(0.85);\n+        Toolkit.getToolkit().firePulse();\n+\n+        VirtualFlow<IndexedCell<?>> virtualFlow = VirtualFlowShim.getVirtualFlow(treeTableView.getSkin());\n+        List<IndexedCell<?>> rows = VirtualFlowShim.getCells(virtualFlow);\n+        for (IndexedCell<?> row : rows) {\n+            for (Node cell : row.getChildrenUnmodifiable()) {\n+                if (cell instanceof TreeTableCell<?, ?> tableCell) {\n+                    assertNotEquals(cellValue, tableCell.getItem());\n+                }\n+            }\n+        }\n+    }\n+\n+    private IndexedCell<?> getRow(int index) {\n+        return VirtualFlowTestUtils.getVirtualFlow(treeTableView).getVisibleCell(index);\n+    }\n+\n+    private int getCellCount(IndexedCell<?> row) {\n+        return row.getChildrenUnmodifiable().size();\n+    }\n+\n+    private void assertCellCountInRow(int index, int count) {\n+        IndexedCell<?> row = getRow(index);\n+        assertEquals(count, getCellCount(row));\n+    }\n+\n+}\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/TreeTableViewVirtualizationTest.java","additions":519,"deletions":0,"binary":false,"changes":519,"status":"added"},{"patch":"@@ -647,0 +647,1 @@\n+        tableView.setFixedCellSize(24);\n@@ -664,0 +665,1 @@\n+        tableView.setFixedCellSize(24);\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/SkinCleanupTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -325,0 +325,1 @@\n+        tableView.setPrefWidth(800);\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/TableRowSkinTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+\n+import javafx.beans.property.SimpleStringProperty;\n@@ -331,0 +333,22 @@\n+    \/**\n+     * The {@link TreeTableRowSkin} should add new cells after new columns are added.\n+     * See: JDK-8321970\n+     *\/\n+    @Test\n+    public void cellsShouldBeAddedInRowFixedCellSize() {\n+        treeTableView.setPrefWidth(800);\n+        treeTableView.setFixedCellSize(24);\n+\n+        TreeTableColumn<Person, String> otherColumn = new TreeTableColumn<>(\"other\");\n+        otherColumn.setPrefWidth(100);\n+        otherColumn.setCellValueFactory(value -> new SimpleStringProperty(\"other\"));\n+        treeTableView.getColumns().add(otherColumn);\n+\n+        Toolkit.getToolkit().firePulse();\n+        assertEquals(5, treeTableView.getColumns().size());\n+\n+        Toolkit.getToolkit().firePulse();\n+        IndexedCell<?> row = VirtualFlowTestUtils.getCell(treeTableView, 1);\n+        assertEquals(5, row.getChildrenUnmodifiable().stream().filter(TreeTableCell.class::isInstance).count());\n+    }\n+\n@@ -422,1 +446,0 @@\n-        \/\/ Note: TreeTableView has an additional children - the disclosure node - therefore we subtract 1 here.\n@@ -424,1 +447,1 @@\n-                VirtualFlowTestUtils.getCell(treeTableView, 0).getChildrenUnmodifiable().size() - 1);\n+                VirtualFlowTestUtils.getCell(treeTableView, 0).getChildrenUnmodifiable().size());\n@@ -434,1 +457,0 @@\n-        \/\/ Note: TreeTableView has an additional children - the disclosure node - therefore we subtract 1 here.\n@@ -436,1 +458,1 @@\n-                VirtualFlowTestUtils.getCell(treeTableView, 0).getChildrenUnmodifiable().size() - 1);\n+                VirtualFlowTestUtils.getCell(treeTableView, 0).getChildrenUnmodifiable().size());\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/TreeTableRowSkinTest.java","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-        TreeTableCell<String, String> cell = (TreeTableCell<String, String>) row.getChildrenUnmodifiable().get(1);\n+        TreeTableCell<String, String> cell = (TreeTableCell<String, String>) row.getChildrenUnmodifiable().get(0);\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/TreeTableViewIndentationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2095,0 +2095,26 @@\n+    @Test\n+    public void testSheetChildrenAreAlwaysTheAmountOfVisibleCells() {\n+        flow = new VirtualFlowShim<>();\n+        flow.setFixedCellSize(24);\n+        flow.setCellFactory(fw -> new CellStub(flow));\n+        flow.setCellCount(20);\n+\n+        flow.resize(250, 240);\n+        pulse();\n+\n+        assertEquals(10, flow.sheetChildren.size());\n+        assertEquals(flow.cells, flow.sheetChildren);\n+\n+        flow.resize(250, 480);\n+        pulse();\n+\n+        assertEquals(20, flow.sheetChildren.size());\n+        assertEquals(flow.cells, flow.sheetChildren);\n+\n+        flow.resize(250, 240);\n+        pulse();\n+\n+        assertEquals(10, flow.sheetChildren.size());\n+        assertEquals(flow.cells, flow.sheetChildren);\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/skin\/VirtualFlowTest.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"}]}