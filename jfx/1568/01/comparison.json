{"files":[{"patch":"@@ -0,0 +1,2326 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package renderperf;\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.ArrayList;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import javafx.animation.AnimationTimer;\n+import javafx.application.Platform;\n+import javafx.geometry.Point3D;\n+import javafx.scene.control.Button;\n+import javafx.scene.effect.BlendMode;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.CycleMethod;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.PhongMaterial;\n+import javafx.scene.paint.RadialGradient;\n+import javafx.scene.paint.Stop;\n+import javafx.scene.shape.Arc;\n+import javafx.scene.shape.ArcTo;\n+import javafx.scene.shape.ArcType;\n+import javafx.scene.shape.Box;\n+import javafx.scene.shape.Cylinder;\n+import javafx.scene.shape.Circle;\n+import javafx.scene.shape.CubicCurve;\n+import javafx.scene.shape.CubicCurveTo;\n+import javafx.scene.shape.CullFace;\n+import javafx.scene.shape.DrawMode;\n+import javafx.scene.shape.Ellipse;\n+import javafx.scene.shape.Line;\n+import javafx.scene.shape.MeshView;\n+import javafx.scene.shape.MoveTo;\n+import javafx.scene.shape.Path;\n+import javafx.scene.shape.Polygon;\n+import javafx.scene.shape.Rectangle;\n+import javafx.scene.shape.Sphere;\n+import javafx.scene.shape.TriangleMesh;\n+import javafx.scene.shape.QuadCurve;\n+import javafx.scene.shape.QuadCurveTo;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.Text;\n+import javafx.scene.transform.Rotate;\n+import javafx.scene.Group;\n+import javafx.scene.Scene;\n+import javafx.stage.Stage;\n+\n+\/**\n+ * {@link RenderPerfTest} is an application to measure graphic rendering performance\n+ * of JavaFX graphic rendering by calculatiing the Frames per second (FPS) value.\n+ * The application calculates the FPS by creating a JavaFX environment and rendering\n+ * objects such as Circle, Image, Text etc based on the test executed. Rendered objects\n+ * are animated by changing their coordinates every frame which creates animation.\n+ * Each test case is run for a duration of {@link #TEST_TIME} and number of frames rendered\n+ * are tracked to calculate FPS.\n+ *\n+ * <p>\n+ * Steps to run the application:\n+ * <ol>\n+ *  <li>cd RenderPerfTest\/src<\/li>\n+ *  <li>Command to compile the program: javac {@literal @}{@literal <}path_to{@literal >}\/compile.args renderperf\/{@link RenderPerfTest}.java<\/li>\n+ *  <li>Command to execute the program: java {@literal @}{@literal <}path_to{@literal >}\/run.args renderperf\/{@link RenderPerfTest} -t {@literal <}test_name{@literal <} -n {@literal <}number_of_objects{@literal <} -h<\/li>\n+ *  Where:\n+ *  <ul>\n+ *      <li>test_name: Name of the test to be executed. If not specified, all tests are executed.<\/li>\n+ *      <li>number_of_objects: Number of objects to be rendered in the test. If not specified, default value is 1000.<\/li>\n+ *      <li>-h: help: prints application usage.<\/li>\n+ *  <\/ul>\n+ * NOTE: Set JVM command line parameter -Djavafx.animation.fullspeed=true to run animation at full speed\n+ * <\/ol>\n+ * <p>\n+ * Example - Command to execute the Circle test with 10000 circle objects: <br>\n+ * java -Djavafx.animation.fullspeed=true {@literal @}{@literal <}path_to{@literal >}\/run.args renderperf\/{@link RenderPerfTest} -t Circle -n 10000.\n+ *\n+ *\/\n+\n+public class RenderPerfTest {\n+    private static final double WIDTH = 800;\n+    private static final double HEIGHT = 800;\n+    private static final double R = 25;\n+    private static final long SECOND_IN_NANOS = 1_000_000_000L;\n+    private static final long WARMUP_TIME_SECONDS = 5;\n+    private static final long WARMUP_TIME = WARMUP_TIME_SECONDS * SECOND_IN_NANOS;\n+    private static final long DEFAULT_TEST_TIME_SECONDS = 10;\n+    private static final Color[] marker = {Color.RED, Color.BLUE, Color.GREEN, Color.YELLOW, Color.ORANGE, Color.MAGENTA};\n+\n+    private static Stage stage;\n+    private static Scene scene;\n+    private static Group group;\n+    private static Random random = new Random(100);\n+    private static int objectCount = 0;\n+    private static long testDuration = DEFAULT_TEST_TIME_SECONDS;\n+    private static ArrayList<String> testList = null;\n+\n+    interface Renderable {\n+        void addComponents(Group node);\n+        void updateCoordinates();\n+        void updateComponentCoordinates();\n+        void releaseResource();\n+    }\n+\n+    private static int roundUpTo4(int n) {\n+        if (n % 4 != 0) {\n+            n = (n + 3) & ~(0x3);\n+            System.out.println(\"Test requires object count that is a multiple of 4 - rounding up to \" + n);\n+        }\n+        return n;\n+    }\n+\n+    \/**\n+     * This method is used to create object of {@link ParticleRenderable}\n+     * which will be used to call the {@link PerfMeter#exec} method of\n+     * {@link PerfMeter} to render the components or update coordinates.\n+     * This method shall be called for each teast case.\n+     *\n+     * @param renderer object of a particle renderer which inherits from {@link ParticleRenderer}\n+     *\n+     * @return object of {@link ParticleRenderable}\n+     *\/\n+    ParticleRenderable createPR(ParticleRenderer renderer) {\n+        return new ParticleRenderable(renderer, WIDTH, HEIGHT);\n+    }\n+\n+    \/**\n+     * Primary function of {@link ParticleRenderable} class is to invoke\n+     * the methods of {@link Particles} class which in turn invokes\n+     * {@link ParticleRenderable} methods to render components on JavaFX application.\n+     * Object of {@link ParticleRenderable} is created for every {@link ParticleRenderable}\n+     * child class i.e for each test case which makes it easy to reuse the\n+     * coordinates generated for rendering the components.\n+     * This class helps in separating the individual test case component rendering code\n+     * independant of the test execution.\n+     *\/\n+    static class ParticleRenderable implements Renderable {\n+        private ParticleRenderer renderer;\n+\n+        private double[] bx;\n+        private double[] by;\n+        private double[] vx;\n+        private double[] vy;\n+        private double r;\n+        private int n;\n+\n+        private double width;\n+        private double height;\n+\n+        ParticleRenderable(ParticleRenderer renderer, double width, double height) {\n+            this.renderer = renderer;\n+            this.n = renderer.getObjectCount();\n+            this.r = renderer.getParticleRadius();\n+\n+            bx = new double[n];\n+            by = new double[n];\n+            vx = new double[n];\n+            vy = new double[n];\n+            this.width = width;\n+            this.height = height;\n+\n+            for (int i = 0; i < n; i++) {\n+                bx[i] = random.nextDouble(r, (width - r));\n+                by[i] = random.nextDouble(r, (height - r));\n+                vx[i] = random.nextDouble(-2, 2);\n+                vy[i] = random.nextDouble(-2, 2);\n+            }\n+        }\n+\n+        @Override\n+        public void addComponents(Group node) {\n+            renderer.addComponents(node, n, bx, by, vx, vy);\n+        }\n+\n+        @Override\n+        public void updateCoordinates() {\n+            for (int i = 0; i < n; i++) {\n+                bx[i] += vx[i];\n+                if (bx[i] + r > width || bx[i] - r < 0) vx[i] = -vx[i];\n+                by[i] += vy[i];\n+                if (by[i] + r > height || by[i] - r < 0) vy[i] = -vy[i];\n+            }\n+        }\n+\n+        @Override\n+        public void updateComponentCoordinates() {\n+            renderer.updateComponentCoordinates(n, bx, by, vx, vy);\n+        }\n+\n+        @Override\n+        public void releaseResource() {\n+            renderer.releaseResource();\n+        }\n+    }\n+\n+    \/**\n+     * Interface which shall be implemented by all the particle renderer sub-classes\n+     * used in different test cases.\n+     * Methods for adding components, changing location of components and\n+     * releasing resources used for rendering the components are defined.\n+     *\/\n+    interface ParticleRenderer {\n+        void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy);\n+        void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy);\n+        void releaseResource();\n+        int getObjectCount();\n+        double getParticleRadius();\n+    }\n+\n+    static abstract class FlatParticleRenderer implements ParticleRenderer {\n+        Color[] colors;\n+        int n;\n+        double r;\n+\n+        FlatParticleRenderer(int n, double r) {\n+            colors = new Color[n];\n+            this.n = n;\n+            this.r = r;\n+\n+            for (int i = 0; i < n; i++) {\n+                colors[i] = Color.rgb(random.nextInt(256), random.nextInt(256), random.nextInt(256));\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            colors = null;\n+        }\n+\n+        public int getObjectCount() {\n+            return n;\n+        }\n+\n+        public double getParticleRadius() {\n+            return r;\n+        }\n+    }\n+\n+    static class ArcRenderer extends FlatParticleRenderer {\n+        Arc[] arc;\n+\n+        ArcRenderer(int n, double r) {\n+            super(n, r);\n+            arc = new Arc[n];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                arc[id] = new Arc();\n+\n+                arc[id].setCenterX(x[id]);\n+                arc[id].setCenterY(y[id]);\n+                arc[id].setRadiusX(r);\n+                arc[id].setRadiusY(r);\n+                arc[id].setStartAngle(random.nextDouble(100));\n+                arc[id].setLength(random.nextDouble(360));\n+                arc[id].setType(ArcType.ROUND);\n+                arc[id].setFill(colors[id % colors.length]);\n+                node.getChildren().add(arc[id]);\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                arc[id].setCenterX(x[id]);\n+                arc[id].setCenterY(y[id]);\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            super.releaseResource();\n+            arc = null;\n+        }\n+    }\n+\n+    static class OpenArcRenderer extends ArcRenderer {\n+        OpenArcRenderer(int n, double r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id++) {\n+                arc[id].setType(ArcType.OPEN);\n+                arc[id].setFill(null);\n+                arc[id].setStroke(colors[id % colors.length]);\n+            }\n+        }\n+    }\n+\n+    static class CubicCurveRenderer extends FlatParticleRenderer {\n+        CubicCurve[] cubicCurve;\n+\n+        CubicCurveRenderer(int n, double r) {\n+            super(n, r);\n+            cubicCurve = new CubicCurve[n];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                cubicCurve[id] = new CubicCurve();\n+\n+                cubicCurve[id].setStartX(0);\n+                cubicCurve[id].setStartY(50);\n+                cubicCurve[id].setControlX1(25);\n+                cubicCurve[id].setControlY1(0);\n+                cubicCurve[id].setControlX2(75);\n+                cubicCurve[id].setControlY2(100);\n+                cubicCurve[id].setEndX(100);\n+                cubicCurve[id].setEndY(50);\n+                cubicCurve[id].setFill(colors[id % colors.length]);\n+                node.getChildren().add(cubicCurve[id]);\n+            }\n+\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                cubicCurve[id].setTranslateX(x[id] - r);\n+                cubicCurve[id].setTranslateY(y[id] - (2 * r));\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            super.releaseResource();\n+            cubicCurve = null;\n+        }\n+    }\n+\n+    static class QuadCurveRenderer extends FlatParticleRenderer {\n+        QuadCurve[] quadCurve;\n+\n+        QuadCurveRenderer(int n, double r) {\n+            super(n, r);\n+            quadCurve = new QuadCurve[n];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                quadCurve[id] = new QuadCurve();\n+\n+                quadCurve[id].setStartX(0);\n+                quadCurve[id].setStartY(50);\n+                quadCurve[id].setControlX(25);\n+                quadCurve[id].setControlY(0);\n+                quadCurve[id].setEndX(100);\n+                quadCurve[id].setEndY(50);\n+                quadCurve[id].setFill(colors[id % colors.length]);\n+                node.getChildren().add(quadCurve[id]);\n+            }\n+\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                quadCurve[id].setTranslateX(x[id] - r);\n+                quadCurve[id].setTranslateY(y[id] - (2 * r));\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            super.releaseResource();\n+            quadCurve = null;\n+        }\n+    }\n+\n+    static class CircleRenderer extends FlatParticleRenderer {\n+        Circle[] circle;\n+\n+        CircleRenderer(int n, double r) {\n+            super(n, r);\n+            circle = new Circle[n];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                circle[id] = new Circle();\n+\n+                circle[id].setCenterX(x[id]);\n+                circle[id].setCenterY(y[id]);\n+                circle[id].setRadius(r);\n+                circle[id].setFill(colors[id % colors.length]);\n+                node.getChildren().add(circle[id]);\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                circle[id].setCenterX(x[id]);\n+                circle[id].setCenterY(y[id]);\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            super.releaseResource();\n+            circle = null;\n+        }\n+    }\n+\n+    static class CircleRendererRH extends CircleRenderer {\n+\n+        CircleRendererRH(int n, double r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id++) {\n+                circle[id].setSmooth(false);\n+            }\n+        }\n+    }\n+\n+    static class CircleRendererBlendMultiply extends CircleRenderer {\n+\n+        CircleRendererBlendMultiply(int n, double r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id += 10) {\n+                circle[id].setBlendMode(BlendMode.MULTIPLY);\n+            }\n+        }\n+    }\n+\n+    static class CircleRendererBlendAdd extends CircleRenderer {\n+\n+        CircleRendererBlendAdd(int n, double r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id += 10) {\n+                circle[id].setBlendMode(BlendMode.ADD);\n+            }\n+        }\n+    }\n+\n+    static class CircleRendererBlendDarken extends CircleRenderer {\n+\n+        CircleRendererBlendDarken(int n, double r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id += 10) {\n+                circle[id].setBlendMode(BlendMode.DARKEN);\n+            }\n+        }\n+    }\n+\n+    static class StrokedCircleRenderer extends CircleRenderer {\n+\n+        StrokedCircleRenderer(int n, double r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id++) {\n+                circle[id].setFill(null);\n+                circle[id].setStroke(colors[id % colors.length]);\n+            }\n+        }\n+    }\n+\n+    static class LinGradCircleRenderer extends CircleRenderer {\n+        Stop[] stops;\n+        LinearGradient linGradient;\n+\n+        LinGradCircleRenderer(int n, double r) {\n+            super(n, r);\n+            stops = new Stop[] { new Stop(0, Color.BLACK), new Stop(1, Color.RED)};\n+            linGradient = new LinearGradient(0, 0, 1, 0, true, CycleMethod.NO_CYCLE, stops);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id++) {\n+                circle[id].setFill(linGradient);\n+            }\n+        }\n+    }\n+\n+    static class RadGradCircleRenderer extends CircleRenderer {\n+        Stop[] stops;\n+        RadialGradient radGradient;\n+\n+        RadGradCircleRenderer(int n, double r) {\n+            super(n, r);\n+            stops = new Stop[] { new Stop(0.0, Color.WHITE), new Stop(0.1, Color.RED), new Stop(1.0, Color.DARKRED)};\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id++) {\n+                radGradient = new RadialGradient(0, 0, x[id], y[id], 60, false, CycleMethod.NO_CYCLE, stops);\n+                circle[id].setFill(radGradient);\n+            }\n+        }\n+    }\n+\n+    static class EllipseRenderer extends FlatParticleRenderer {\n+        Ellipse[] ellipse;\n+\n+        EllipseRenderer(int n, double r) {\n+            super(n, r);\n+            ellipse = new Ellipse[n];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                ellipse[id] = new Ellipse();\n+\n+                ellipse[id].setCenterX(x[id]);\n+                ellipse[id].setCenterY(y[id]);\n+                ellipse[id].setRadiusX(2 * r);\n+                ellipse[id].setRadiusY(r);\n+                ellipse[id].setFill(colors[id % colors.length]);\n+                node.getChildren().add(ellipse[id]);\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                ellipse[id].setCenterX(x[id]);\n+                ellipse[id].setCenterY(y[id]);\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            super.releaseResource();\n+            ellipse = null;\n+        }\n+    }\n+\n+    static class LineRenderer extends FlatParticleRenderer {\n+        Line[] line;\n+\n+        LineRenderer(int n, double r) {\n+            super(n, r);\n+            line = new Line[n];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                line[id] = new Line();\n+\n+                line[id].setStartX(0);\n+                line[id].setStartY(0);\n+                line[id].setEndX(50);\n+                line[id].setEndY(50);\n+                line[id].setStroke(colors[id % colors.length]);\n+                node.getChildren().add(line[id]);\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                line[id].setTranslateX(x[id] - r);\n+                line[id].setTranslateY(y[id] - r);\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            super.releaseResource();\n+            line = null;\n+        }\n+    }\n+\n+    static class PathRenderer extends FlatParticleRenderer {\n+        Path[] path;\n+\n+        PathRenderer(int n, double r) {\n+            super(n, r);\n+            path = new Path[n];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                MoveTo moveTo = new MoveTo();\n+                moveTo.setX(0);\n+                moveTo.setY(0);\n+\n+                CubicCurveTo cubicCurveTo = new CubicCurveTo();\n+                cubicCurveTo.setX(40);\n+                cubicCurveTo.setY(45);\n+                cubicCurveTo.setControlX1(0);\n+                cubicCurveTo.setControlY1(0);\n+                cubicCurveTo.setControlX2(30);\n+                cubicCurveTo.setControlY2(80);\n+\n+                QuadCurveTo quadCurveTo = new QuadCurveTo();\n+                quadCurveTo.setX(60);\n+                quadCurveTo.setY(45);\n+                quadCurveTo.setControlX(50);\n+                quadCurveTo.setControlY(0);\n+\n+                ArcTo arcTo = new ArcTo();\n+                arcTo.setX(80);\n+                arcTo.setY(45);\n+                arcTo.setRadiusX(20);\n+                arcTo.setRadiusY(40);\n+                arcTo.setLargeArcFlag(true);\n+                arcTo.setSweepFlag(true);\n+\n+                path[id] = new Path();\n+                path[id].setStroke(colors[id % colors.length]);\n+                path[id].getElements().addAll(moveTo, cubicCurveTo, quadCurveTo, arcTo);\n+\n+                node.getChildren().add(path[id]);\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                path[id].setTranslateX(x[id] - r);\n+                path[id].setTranslateY(y[id] - r);\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            super.releaseResource();\n+            path = null;\n+        }\n+    }\n+\n+    static class RectangleRenderer extends FlatParticleRenderer {\n+        Rectangle[] rectangle;\n+\n+        RectangleRenderer(int n, double r) {\n+            super(n, r);\n+            rectangle = new Rectangle[n];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                rectangle[id] = new Rectangle();\n+\n+                rectangle[id].setX(x[id] - r);\n+                rectangle[id].setY(y[id] - r);\n+                rectangle[id].setWidth(2 * r);\n+                rectangle[id].setHeight(2 * r);\n+                rectangle[id].setFill(colors[id % colors.length]);\n+                node.getChildren().add(rectangle[id]);\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                rectangle[id].setX(x[id] - r);\n+                rectangle[id].setY(y[id] - r);\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            super.releaseResource();\n+            rectangle = null;\n+        }\n+    }\n+\n+    static class RectangleRendererRH extends RectangleRenderer {\n+\n+        RectangleRendererRH(int n, double r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id++) {\n+                rectangle[id].setSmooth(false);\n+                rectangle[id].setRotate(45);\n+            }\n+        }\n+    }\n+\n+    static class StrokedRectangleRenderer extends RectangleRenderer {\n+\n+        StrokedRectangleRenderer(int n, double r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id++) {\n+                rectangle[id].setFill(null);\n+                rectangle[id].setStroke(colors[id % colors.length]);\n+            }\n+        }\n+    }\n+\n+    static class PolygonRenderer extends FlatParticleRenderer {\n+        Polygon[] polygon;\n+\n+        PolygonRenderer(int n, double r) {\n+            super(n, r);\n+            polygon = new Polygon[n];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                polygon[id] = new Polygon();\n+\n+                polygon[id].getPoints().addAll(new Double[]{\n+                    0.0, 20.0,\n+                    20.0, 0.0,\n+                    40.0, 20.0,\n+                    40.0, 40.0,\n+                    20.0, 60.0,\n+                    0.0, 40.0\n+                });\n+                polygon[id].setFill(colors[id % colors.length]);\n+                node.getChildren().add(polygon[id]);\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                polygon[id].setTranslateX(x[id] - r);\n+                polygon[id].setTranslateY(y[id] - r);\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            super.releaseResource();\n+            polygon = null;\n+        }\n+    }\n+\n+    static class StrokedPolygonRenderer extends PolygonRenderer {\n+\n+        StrokedPolygonRenderer(int n, double r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id++) {\n+                polygon[id].setFill(null);\n+                polygon[id].setStroke(colors[id % colors.length]);\n+            }\n+        }\n+    }\n+\n+    static class Box3DRenderer extends FlatParticleRenderer {\n+        Box[] box;\n+\n+        Box3DRenderer(int n, double r) {\n+            super(n, r);\n+            box = new Box[n];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                box[id] = new Box(2 * r, 2 * r, 2 * r);\n+\n+                box[id].setTranslateX(x[id]);\n+                box[id].setTranslateY(y[id]);\n+\n+                PhongMaterial material = new PhongMaterial();\n+                material.setDiffuseColor(colors[id % colors.length]);\n+                box[id].setMaterial(material);\n+\n+                box[id].setRotationAxis(new Point3D(1, 1, 1));\n+                box[id].setRotate(45);\n+                node.getChildren().add(box[id]);\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                box[id].setTranslateX(x[id]);\n+                box[id].setTranslateY(y[id]);\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            super.releaseResource();\n+            box = null;\n+        }\n+    }\n+\n+    static class CylinderRenderer extends FlatParticleRenderer {\n+        Cylinder[] cylinder;\n+\n+        CylinderRenderer(int n, double r) {\n+            super(n, r);\n+            cylinder = new Cylinder[n];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                cylinder[id] = new Cylinder(r, 2 * r);\n+\n+                PhongMaterial material = new PhongMaterial();\n+                material.setDiffuseColor(colors[id % colors.length]);\n+                cylinder[id].setMaterial(material);\n+\n+                cylinder[id].setRotationAxis(new Point3D(1, 1, 1));\n+                cylinder[id].setRotate(45);\n+                node.getChildren().add(cylinder[id]);\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                cylinder[id].setTranslateX(x[id]);\n+                cylinder[id].setTranslateY(y[id]);\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            super.releaseResource();\n+            cylinder = null;\n+        }\n+    }\n+\n+    static class SphereRenderer extends FlatParticleRenderer {\n+        Sphere[] sphere;\n+\n+        SphereRenderer(int n, double r) {\n+            super(n, r);\n+            sphere = new Sphere[n];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                sphere[id] = new Sphere(r);\n+\n+                PhongMaterial material = new PhongMaterial();\n+                material.setDiffuseColor(colors[id % colors.length]);\n+                sphere[id].setMaterial(material);\n+\n+                node.getChildren().add(sphere[id]);\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                sphere[id].setTranslateX(x[id]);\n+                sphere[id].setTranslateY(y[id]);\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            super.releaseResource();\n+            sphere = null;\n+        }\n+    }\n+\n+    static class MeshRenderer extends FlatParticleRenderer {\n+        MeshView[] meshView;\n+\n+        final static float minX = -10;\n+        final static float minY = -10;\n+        final static float maxX = 10;\n+        final static float maxY = 10;\n+        final int pointSize = 3;\n+        final int texCoordSize = 2;\n+        final int faceSize = 6;\n+        final int scale = 3;\n+\n+        MeshRenderer(int n, double r) {\n+            super(n, r);\n+            meshView = new MeshView[n];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            int subDivX = 2;\n+            int subDivY = 2;\n+            int numDivX = subDivX + 1;\n+            int numVerts = (subDivY + 1) * numDivX;\n+            float points[] = new float[numVerts * pointSize];\n+            float texCoords[] = new float[numVerts * texCoordSize];\n+            int faceCount = subDivX * subDivY * 2;\n+            int faces[] = new int[ faceCount * faceSize];\n+\n+            \/\/ Create points and texture coordinates\n+            for (int i = 0; i <= subDivY; i++) {\n+                float dy = (float) i \/ subDivY;\n+                double fy = (1 - dy) * minY + dy * maxY;\n+                for (int j = 0; j <= subDivX; j++) {\n+                    float dx = (float) j \/ subDivX;\n+                    double fx = (1 - dx) * minX + dx * maxX;\n+                    int index = i * numDivX * pointSize + (j * pointSize);\n+                    points[index] = (float) fx * scale;\n+                    points[index + 1] = (float) fy * scale;\n+                    points[index + 2] = (float) getSinDivX(fx, fy) * scale;\n+                    index = i * numDivX * texCoordSize + (j * texCoordSize);\n+                    texCoords[index] = dx;\n+                    texCoords[index + 1] = dy;\n+                }\n+            }\n+\n+            \/\/ Create faces\n+            for (int i = 0; i < subDivY; i++) {\n+                for (int j = 0; j < subDivX; j++) {\n+                    int p00 = i * numDivX + j;\n+                    int p01 = p00 + 1;\n+                    int p10 = p00 + numDivX;\n+                    int p11 = p10 + 1;\n+                    int tc00 = i * numDivX + j;\n+                    int tc01 = tc00 + 1;\n+                    int tc10 = tc00 + numDivX;\n+                    int tc11 = tc10 + 1;\n+\n+                    int index = (i * subDivX * faceSize + (j * faceSize)) * 2;\n+                    faces[index + 0] = p00;\n+                    faces[index + 1] = tc00;\n+                    faces[index + 2] = p10;\n+                    faces[index + 3] = tc10;\n+                    faces[index + 4] = p11;\n+                    faces[index + 5] = tc11;\n+                    index += faceSize;\n+                    faces[index + 0] = p11;\n+                    faces[index + 1] = tc11;\n+                    faces[index + 2] = p01;\n+                    faces[index + 3] = tc01;\n+                    faces[index + 4] = p00;\n+                    faces[index + 5] = tc00;\n+                }\n+            }\n+\n+            TriangleMesh triangleMesh = new TriangleMesh();\n+            triangleMesh.getPoints().setAll(points);\n+            triangleMesh.getTexCoords().setAll(texCoords);\n+            triangleMesh.getFaces().setAll(faces);\n+\n+            for (int id = 0; id < n; id++) {\n+                PhongMaterial material = new PhongMaterial();\n+                material.setDiffuseColor(colors[id % colors.length]);\n+                material.setSpecularColor(colors[id % colors.length]);\n+                String url = RenderPerfTest.class.getResource(\"duke.png\").toString();\n+                material.setDiffuseMap(new Image(url));\n+\n+                meshView[id] = new MeshView(triangleMesh);\n+                meshView[id].setMaterial(material);\n+                meshView[id].setDrawMode(DrawMode.FILL);\n+                meshView[id].setCullFace(CullFace.BACK);\n+\n+                node.getChildren().add(meshView[id]);\n+            }\n+        }\n+\n+        private double getSinDivX(double x, double y) {\n+            float funcValue = -30.0f;\n+            double r = Math.sqrt(x*x + y*y);\n+            return funcValue * (r == 0 ? 1 : Math.sin(r) \/ r);\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                meshView[id].setTranslateX(x[id]);\n+                meshView[id].setTranslateY(y[id]);\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            super.releaseResource();\n+            meshView = null;\n+        }\n+    }\n+\n+    static class WhiteTextRenderer implements ParticleRenderer {\n+        int n;\n+        double r;\n+        Text[] text;\n+\n+        WhiteTextRenderer(int n, double r) {\n+            this.n = n;\n+            this.r = r;\n+            text = new Text[n];\n+        }\n+\n+        void setPaint(Text t, int id) {\n+            t.setFill(Color.WHITE);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                text[id] = new Text(x[id], y[id], \"The quick brown fox jumps over the lazy dog\");\n+                setPaint(text[id], id);\n+                node.getChildren().add(text[id]);\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                text[id].setX(x[id]);\n+                text[id].setY(y[id]);\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            text = null;\n+        }\n+\n+        public int getObjectCount() {\n+            return n;\n+        }\n+\n+        public double getParticleRadius() {\n+            return r;\n+        }\n+    }\n+\n+    static class ColorTextRenderer extends WhiteTextRenderer {\n+        Color[] colors;\n+\n+        ColorTextRenderer(int n, double r) {\n+            super(n, r);\n+            colors = new Color[n];\n+\n+            for (int i = 0; i < n; i++) {\n+                colors[i] = Color.rgb(random.nextInt(256), random.nextInt(256), random.nextInt(256));\n+            }\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id++) {\n+                text[id].setFill(colors[id % colors.length]);\n+            }\n+        }\n+    }\n+\n+    static class LargeTextRenderer extends WhiteTextRenderer {\n+        Font font;\n+\n+        LargeTextRenderer(int n, double r) {\n+            super(n, r);\n+            font = new Font(48);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id++) {\n+                text[id].setFont(font);\n+            }\n+        }\n+    }\n+\n+    static class LargeColorTextRenderer extends ColorTextRenderer {\n+        Font font;\n+\n+        LargeColorTextRenderer(int n, double r) {\n+            super(n, r);\n+            font = new Font(48);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id++) {\n+                text[id].setFont(font);\n+            }\n+        }\n+    }\n+\n+    static class ImageRenderer implements ParticleRenderer {\n+        ImageView[] dukeImg;\n+        Image image;\n+        int n;\n+        double r;\n+\n+        ImageRenderer(int n, double r) {\n+            this.n = n;\n+            this.r = r;\n+            try {\n+                String url = RenderPerfTest.class.getResource(\"duke.png\").toString();\n+                image = new Image(url);\n+                dukeImg = new ImageView[n];\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                dukeImg[id] = new ImageView();\n+                dukeImg[id].setImage(image);\n+                dukeImg[id].setX(x[id] - r);\n+                dukeImg[id].setY(y[id] - 2 * r);\n+\n+                node.getChildren().add(dukeImg[id]);\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                dukeImg[id].setX(x[id] - r);\n+                dukeImg[id].setY(y[id] - 2 * r);\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            image = null;\n+            dukeImg = null;\n+        }\n+\n+        public int getObjectCount() {\n+            return n;\n+        }\n+\n+        public double getParticleRadius() {\n+            return r;\n+        }\n+    }\n+\n+    static class ImageRendererRH extends ImageRenderer {\n+\n+        ImageRendererRH(int n, double r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            super.addComponents(node, n, x, y, vx, vy);\n+            for (int id = 0; id < n; id++) {\n+                dukeImg[id].setSmooth(false);\n+            }\n+        }\n+    }\n+\n+    static class MultiShapeRendererInterleaved extends FlatParticleRenderer {\n+        Circle[] circle;\n+        Rectangle[] rectangle;\n+        Arc[] arc;\n+        Ellipse[] ellipse;\n+\n+        MultiShapeRendererInterleaved(int n, double r) {\n+            super((n = roundUpTo4(n)), r);\n+            circle = new Circle[n \/ 4];\n+            rectangle = new Rectangle[n \/ 4];\n+            arc = new Arc[n \/ 4];\n+            ellipse = new Ellipse[n \/ 4];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            int index =0;\n+             for (int id = 0; id < n \/ 4; id++) {\n+                circle[id] = new Circle();\n+\n+                circle[id].setCenterX(x[index]);\n+                circle[id].setCenterY(y[index]);\n+                circle[id].setRadius(r);\n+                circle[id].setFill(colors[index % colors.length]);\n+                node.getChildren().add(circle[id]);\n+                index++;\n+\n+                rectangle[id] = new Rectangle();\n+\n+                rectangle[id].setX(x[index] - r);\n+                rectangle[id].setY(y[index] - r);\n+                rectangle[id].setWidth(2 * r);\n+                rectangle[id].setHeight(2 * r);\n+                rectangle[id].setFill(colors[index % colors.length]);\n+                node.getChildren().add(rectangle[id]);\n+                index++;\n+\n+                arc[id] = new Arc();\n+\n+                arc[id].setCenterX(x[index]);\n+                arc[id].setCenterY(y[index]);\n+                arc[id].setRadiusX(r);\n+                arc[id].setRadiusY(r);\n+                arc[id].setStartAngle(random.nextDouble(100));\n+                arc[id].setLength(random.nextDouble(360));\n+                arc[id].setType(ArcType.ROUND);\n+                arc[id].setFill(colors[index % colors.length]);\n+                node.getChildren().add(arc[id]);\n+                index++;\n+\n+                ellipse[id] = new Ellipse();\n+\n+                ellipse[id].setCenterX(x[index]);\n+                ellipse[id].setCenterY(y[index]);\n+                ellipse[id].setRadiusX(2 * r);\n+                ellipse[id].setRadiusY(r);\n+                ellipse[id].setFill(colors[index % colors.length]);\n+                node.getChildren().add(ellipse[id]);\n+                index++;\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            int index = 0;\n+            for (int id = 0; id < n \/ 4; id++) {\n+                circle[id].setCenterX(x[index]);\n+                circle[id].setCenterY(y[index]);\n+                index++;\n+\n+                rectangle[id].setX(x[index] - r);\n+                rectangle[id].setY(y[index] - r);\n+                index++;\n+\n+                arc[id].setCenterX(x[index]);\n+                arc[id].setCenterY(y[index]);\n+                index++;\n+\n+                ellipse[id].setCenterX(x[index]);\n+                ellipse[id].setCenterY(y[index]);\n+                index++;\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            circle = null;\n+            rectangle = null;\n+            arc = null;\n+            ellipse = null;\n+        }\n+    }\n+\n+    static class MultiShapeRenderer extends MultiShapeRendererInterleaved {\n+\n+        MultiShapeRenderer(int n, double r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            int index =0;\n+             for (int id = 0; id < n \/ 4; id++) {\n+                circle[id] = new Circle();\n+\n+                circle[id].setCenterX(x[index]);\n+                circle[id].setCenterY(y[index]);\n+                circle[id].setRadius(r);\n+                circle[id].setFill(colors[index % colors.length]);\n+                node.getChildren().add(circle[id]);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+\n+                rectangle[id] = new Rectangle();\n+\n+                rectangle[id].setX(x[index] - r);\n+                rectangle[id].setY(y[index] - r);\n+                rectangle[id].setWidth(2 * r);\n+                rectangle[id].setHeight(2 * r);\n+                rectangle[id].setFill(colors[index % colors.length]);\n+                node.getChildren().add(rectangle[id]);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+\n+                arc[id] = new Arc();\n+\n+                arc[id].setCenterX(x[index]);\n+                arc[id].setCenterY(y[index]);\n+                arc[id].setRadiusX(r);\n+                arc[id].setRadiusY(r);\n+                arc[id].setStartAngle(random.nextDouble(100));\n+                arc[id].setLength(random.nextDouble(360));\n+                arc[id].setType(ArcType.ROUND);\n+                arc[id].setFill(colors[index % colors.length]);\n+                node.getChildren().add(arc[id]);\n+                index++;\n+            }\n+            for (int id = 0; id < n \/ 4; id++) {\n+\n+                ellipse[id] = new Ellipse();\n+\n+                ellipse[id].setCenterX(x[index]);\n+                ellipse[id].setCenterY(y[index]);\n+                ellipse[id].setRadiusX(2 * r);\n+                ellipse[id].setRadiusY(r);\n+                ellipse[id].setFill(colors[index % colors.length]);\n+                node.getChildren().add(ellipse[id]);\n+                index++;\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            int index = 0;\n+            for (int id = 0; id < n \/ 4; id++) {\n+                circle[id].setCenterX(x[index]);\n+                circle[id].setCenterY(y[index]);\n+                index++;\n+            }\n+            for (int id = 0; id < n \/ 4; id++) {\n+                rectangle[id].setX(x[index] - r);\n+                rectangle[id].setY(y[index] - r);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+                arc[id].setCenterX(x[index]);\n+                arc[id].setCenterY(y[index]);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+                ellipse[id].setCenterX(x[index]);\n+                ellipse[id].setCenterY(y[index]);\n+                index++;\n+            }\n+        }\n+    }\n+\n+    static class MultiShape2D3DRendererInterleaved extends FlatParticleRenderer {\n+        Circle[] circle;\n+        Sphere[] sphere;\n+        Rectangle[] rectangle;\n+        Box[] box;\n+\n+        MultiShape2D3DRendererInterleaved(int n, double r) {\n+            super((n = roundUpTo4(n)), r);\n+            circle = new Circle[n \/ 4];\n+            sphere = new Sphere[n \/ 4];\n+            rectangle = new Rectangle[n \/ 4];\n+            box = new Box[n \/ 4];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            int index =0;\n+             for (int id = 0; id < n \/ 4; id++) {\n+                circle[id] = new Circle();\n+\n+                circle[id].setCenterX(x[index]);\n+                circle[id].setCenterY(y[index]);\n+                circle[id].setRadius(r);\n+                circle[id].setFill(colors[index % colors.length]);\n+                node.getChildren().add(circle[id]);\n+                index++;\n+\n+                sphere[id] = new Sphere(r);\n+\n+                PhongMaterial materialSphere = new PhongMaterial();\n+                materialSphere.setDiffuseColor(colors[index % colors.length]);\n+                sphere[id].setMaterial(materialSphere);\n+                node.getChildren().add(sphere[id]);\n+                index++;\n+\n+                rectangle[id] = new Rectangle();\n+\n+                rectangle[id].setX(x[index] - r);\n+                rectangle[id].setY(y[index] - r);\n+                rectangle[id].setWidth(2 * r);\n+                rectangle[id].setHeight(2 * r);\n+                rectangle[id].setFill(colors[index % colors.length]);\n+                node.getChildren().add(rectangle[id]);\n+                index++;\n+\n+                box[id] = new Box(2 * r, 2 * r, 2 * r);\n+\n+                box[id].setTranslateX(x[index]);\n+                box[id].setTranslateY(y[index]);\n+\n+                PhongMaterial materialBox = new PhongMaterial();\n+                materialBox.setDiffuseColor(colors[index % colors.length]);\n+                box[id].setMaterial(materialBox);\n+\n+                box[id].setRotationAxis(new Point3D(1, 1, 1));\n+                box[id].setRotate(45);\n+                node.getChildren().add(box[id]);\n+                index++;\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            int index = 0;\n+            for (int id = 0; id < n \/ 4; id++) {\n+                circle[id].setCenterX(x[index]);\n+                circle[id].setCenterY(y[index]);\n+                index++;\n+\n+                sphere[id].setTranslateX(x[index]);\n+                sphere[id].setTranslateY(y[index]);\n+                index++;\n+\n+                rectangle[id].setX(x[index] - r);\n+                rectangle[id].setY(y[index] - r);\n+                index++;\n+\n+                box[id].setTranslateX(x[index]);\n+                box[id].setTranslateY(y[index]);\n+                index++;\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            circle = null;\n+            sphere = null;\n+            rectangle = null;\n+            box = null;\n+        }\n+    }\n+\n+    static class MultiShape2D3DRenderer extends MultiShape2D3DRendererInterleaved {\n+        MultiShape2D3DRenderer(int n, double r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            int index =0;\n+            for (int id = 0; id < n \/ 4; id++) {\n+                circle[id] = new Circle();\n+\n+                circle[id].setCenterX(x[index]);\n+                circle[id].setCenterY(y[index]);\n+                circle[id].setRadius(r);\n+                circle[id].setFill(colors[index % colors.length]);\n+                node.getChildren().add(circle[id]);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+                sphere[id] = new Sphere(r);\n+\n+                PhongMaterial materialSphere = new PhongMaterial();\n+                materialSphere.setDiffuseColor(colors[index % colors.length]);\n+                sphere[id].setMaterial(materialSphere);\n+                node.getChildren().add(sphere[id]);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+\n+                rectangle[id] = new Rectangle();\n+\n+                rectangle[id].setX(x[index] - r);\n+                rectangle[id].setY(y[index] - r);\n+                rectangle[id].setWidth(2 * r);\n+                rectangle[id].setHeight(2 * r);\n+                rectangle[id].setFill(colors[index % colors.length]);\n+                node.getChildren().add(rectangle[id]);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+\n+                box[id] = new Box(2 * r, 2 * r, 2 * r);\n+\n+                box[id].setTranslateX(x[index]);\n+                box[id].setTranslateY(y[index]);\n+\n+                PhongMaterial materialBox = new PhongMaterial();\n+                materialBox.setDiffuseColor(colors[index % colors.length]);\n+                box[id].setMaterial(materialBox);\n+\n+                box[id].setRotationAxis(new Point3D(1, 1, 1));\n+                box[id].setRotate(45);\n+                node.getChildren().add(box[id]);\n+                index++;\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            int index = 0;\n+            for (int id = 0; id < n \/ 4; id++) {\n+                circle[id].setCenterX(x[index]);\n+                circle[id].setCenterY(y[index]);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+                sphere[id].setTranslateX(x[index]);\n+                sphere[id].setTranslateY(y[index]);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+                rectangle[id].setX(x[index] - r);\n+                rectangle[id].setY(y[index] - r);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+                box[id].setTranslateX(x[index]);\n+                box[id].setTranslateY(y[index]);\n+                index++;\n+            }\n+        }\n+    }\n+\n+    static class MultiShape3DRendererInterleaved extends FlatParticleRenderer {\n+        Sphere[] sphere;\n+        Box[] box;\n+        Cylinder[] cylinder;\n+        MeshView[] meshView;\n+\n+        final static float minX = -10;\n+        final static float minY = -10;\n+        final static float maxX = 10;\n+        final static float maxY = 10;\n+        final int pointSize = 3;\n+        final int texCoordSize = 2;\n+        final int faceSize = 6;\n+        final int scale = 3;\n+\n+\n+        MultiShape3DRendererInterleaved(int n, double r) {\n+            super((n = roundUpTo4(n)), r);\n+            sphere = new Sphere[n \/ 4];\n+            box = new Box[n \/ 4];\n+            cylinder = new Cylinder[n \/ 4];\n+            meshView = new MeshView[n \/ 4];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            int index =0;\n+\n+            int subDivX = 2;\n+            int subDivY = 2;\n+            int numDivX = subDivX + 1;\n+            int numVerts = (subDivY + 1) * numDivX;\n+            float points[] = new float[numVerts * pointSize];\n+            float texCoords[] = new float[numVerts * texCoordSize];\n+            int faceCount = subDivX * subDivY * 2;\n+            int faces[] = new int[ faceCount * faceSize];\n+\n+            \/\/ Create points and texture coordinates\n+            for (int i = 0; i <= subDivY; i++) {\n+                float dy = (float) i \/ subDivY;\n+                double fy = (1 - dy) * minY + dy * maxY;\n+                for (int j = 0; j <= subDivX; j++) {\n+                    float dx = (float) j \/ subDivX;\n+                    double fx = (1 - dx) * minX + dx * maxX;\n+                    int idx = i * numDivX * pointSize + (j * pointSize);\n+                    points[idx] = (float) fx * scale;\n+                    points[idx + 1] = (float) fy * scale;\n+                    points[idx + 2] = (float) getSinDivX(fx, fy) * scale;\n+                    idx = i * numDivX * texCoordSize + (j * texCoordSize);\n+                    texCoords[idx] = dx;\n+                    texCoords[idx + 1] = dy;\n+                }\n+            }\n+\n+            \/\/ Create faces\n+            for (int i = 0; i < subDivY; i++) {\n+                for (int j = 0; j < subDivX; j++) {\n+                    int p00 = i * numDivX + j;\n+                    int p01 = p00 + 1;\n+                    int p10 = p00 + numDivX;\n+                    int p11 = p10 + 1;\n+                    int tc00 = i * numDivX + j;\n+                    int tc01 = tc00 + 1;\n+                    int tc10 = tc00 + numDivX;\n+                    int tc11 = tc10 + 1;\n+\n+                    int idx = (i * subDivX * faceSize + (j * faceSize)) * 2;\n+                    faces[idx + 0] = p00;\n+                    faces[idx + 1] = tc00;\n+                    faces[idx + 2] = p10;\n+                    faces[idx + 3] = tc10;\n+                    faces[idx + 4] = p11;\n+                    faces[idx + 5] = tc11;\n+                    idx += faceSize;\n+                    faces[idx + 0] = p11;\n+                    faces[idx + 1] = tc11;\n+                    faces[idx + 2] = p01;\n+                    faces[idx + 3] = tc01;\n+                    faces[idx + 4] = p00;\n+                    faces[idx + 5] = tc00;\n+                }\n+            }\n+\n+            TriangleMesh triangleMesh = new TriangleMesh();\n+            triangleMesh.getPoints().setAll(points);\n+            triangleMesh.getTexCoords().setAll(texCoords);\n+            triangleMesh.getFaces().setAll(faces);\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+                sphere[id] = new Sphere(r);\n+\n+                PhongMaterial materialSphere = new PhongMaterial();\n+                materialSphere.setDiffuseColor(colors[index % colors.length]);\n+                sphere[id].setMaterial(materialSphere);\n+                node.getChildren().add(sphere[id]);\n+                index++;\n+\n+                box[id] = new Box(2 * r, 2 * r, 2 * r);\n+\n+                box[id].setTranslateX(x[index]);\n+                box[id].setTranslateY(y[index]);\n+\n+                PhongMaterial materialBox = new PhongMaterial();\n+                materialBox.setDiffuseColor(colors[index % colors.length]);\n+                box[id].setMaterial(materialBox);\n+\n+                box[id].setRotationAxis(new Point3D(1, 1, 1));\n+                box[id].setRotate(45);\n+                node.getChildren().add(box[id]);\n+                index++;\n+\n+\n+                cylinder[id] = new Cylinder(r, 2 * r);\n+\n+                PhongMaterial materialCylinder = new PhongMaterial();\n+                materialCylinder.setDiffuseColor(colors[id % colors.length]);\n+                cylinder[id].setMaterial(materialCylinder);\n+\n+                cylinder[id].setRotationAxis(new Point3D(1, 1, 1));\n+                cylinder[id].setRotate(45);\n+                node.getChildren().add(cylinder[id]);\n+                index++;\n+\n+                PhongMaterial materialMesh = new PhongMaterial();\n+                materialMesh.setDiffuseColor(colors[id % colors.length]);\n+                materialMesh.setSpecularColor(colors[id % colors.length]);\n+                String url = RenderPerfTest.class.getResource(\"duke.png\").toString();\n+                materialMesh.setDiffuseMap(new Image(url));\n+\n+                meshView[id] = new MeshView(triangleMesh);\n+                meshView[id].setMaterial(materialMesh);\n+                meshView[id].setDrawMode(DrawMode.FILL);\n+                meshView[id].setCullFace(CullFace.BACK);\n+                node.getChildren().add(meshView[id]);\n+                index++;\n+            }\n+        }\n+\n+        private double getSinDivX(double x, double y) {\n+            float funcValue = -30.0f;\n+            double r = Math.sqrt(x*x + y*y);\n+            return funcValue * (r == 0 ? 1 : Math.sin(r) \/ r);\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            int index = 0;\n+            for (int id = 0; id < n \/ 4; id++) {\n+                sphere[id].setTranslateX(x[index]);\n+                sphere[id].setTranslateY(y[index]);\n+                index++;\n+\n+                box[id].setTranslateX(x[index]);\n+                box[id].setTranslateY(y[index]);\n+                index++;\n+\n+                cylinder[id].setTranslateX(x[index]);\n+                cylinder[id].setTranslateY(y[index]);\n+                index++;\n+\n+                meshView[id].setTranslateX(x[index]);\n+                meshView[id].setTranslateY(y[index]);\n+                index++;\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            sphere = null;\n+            box = null;\n+            cylinder = null;\n+            meshView = null;\n+        }\n+    }\n+\n+    static class MultiShape3DRenderer extends MultiShape3DRendererInterleaved {\n+        MultiShape3DRenderer(int n, double r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            int index =0;\n+            for (int id = 0; id < n \/ 4; id++) {\n+                sphere[id] = new Sphere(r);\n+\n+                PhongMaterial materialSphere = new PhongMaterial();\n+                materialSphere.setDiffuseColor(colors[index % colors.length]);\n+                sphere[id].setMaterial(materialSphere);\n+                node.getChildren().add(sphere[id]);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+                box[id] = new Box(2 * r, 2 * r, 2 * r);\n+                box[id].setTranslateX(x[index]);\n+                box[id].setTranslateY(y[index]);\n+\n+                PhongMaterial materialBox = new PhongMaterial();\n+                materialBox.setDiffuseColor(colors[index % colors.length]);\n+                box[id].setMaterial(materialBox);\n+\n+                box[id].setRotationAxis(new Point3D(1, 1, 1));\n+                box[id].setRotate(45);\n+                node.getChildren().add(box[id]);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+                cylinder[id] = new Cylinder(r, 2 * r);\n+\n+                PhongMaterial materialCylinder = new PhongMaterial();\n+                materialCylinder.setDiffuseColor(colors[id % colors.length]);\n+                cylinder[id].setMaterial(materialCylinder);\n+\n+                cylinder[id].setRotationAxis(new Point3D(1, 1, 1));\n+                cylinder[id].setRotate(45);\n+                node.getChildren().add(cylinder[id]);\n+                index++;\n+            }\n+\n+            int subDivX = 2;\n+            int subDivY = 2;\n+            int numDivX = subDivX + 1;\n+            int numVerts = (subDivY + 1) * numDivX;\n+            float points[] = new float[numVerts * pointSize];\n+            float texCoords[] = new float[numVerts * texCoordSize];\n+            int faceCount = subDivX * subDivY * 2;\n+            int faces[] = new int[ faceCount * faceSize];\n+\n+            \/\/ Create points and texture coordinates\n+            for (int i = 0; i <= subDivY; i++) {\n+                float dy = (float) i \/ subDivY;\n+                double fy = (1 - dy) * minY + dy * maxY;\n+                for (int j = 0; j <= subDivX; j++) {\n+                    float dx = (float) j \/ subDivX;\n+                    double fx = (1 - dx) * minX + dx * maxX;\n+                    int idx = i * numDivX * pointSize + (j * pointSize);\n+                    points[idx] = (float) fx * scale;\n+                    points[idx + 1] = (float) fy * scale;\n+                    points[idx + 2] = (float) getSinDivX(fx, fy) * scale;\n+                    idx = i * numDivX * texCoordSize + (j * texCoordSize);\n+                    texCoords[idx] = dx;\n+                    texCoords[idx + 1] = dy;\n+                }\n+            }\n+\n+            \/\/ Create faces\n+            for (int i = 0; i < subDivY; i++) {\n+                for (int j = 0; j < subDivX; j++) {\n+                    int p00 = i * numDivX + j;\n+                    int p01 = p00 + 1;\n+                    int p10 = p00 + numDivX;\n+                    int p11 = p10 + 1;\n+                    int tc00 = i * numDivX + j;\n+                    int tc01 = tc00 + 1;\n+                    int tc10 = tc00 + numDivX;\n+                    int tc11 = tc10 + 1;\n+\n+                    int idx = (i * subDivX * faceSize + (j * faceSize)) * 2;\n+                    faces[idx + 0] = p00;\n+                    faces[idx + 1] = tc00;\n+                    faces[idx + 2] = p10;\n+                    faces[idx + 3] = tc10;\n+                    faces[idx + 4] = p11;\n+                    faces[idx + 5] = tc11;\n+                    idx += faceSize;\n+                    faces[idx + 0] = p11;\n+                    faces[idx + 1] = tc11;\n+                    faces[idx + 2] = p01;\n+                    faces[idx + 3] = tc01;\n+                    faces[idx + 4] = p00;\n+                    faces[idx + 5] = tc00;\n+                }\n+            }\n+\n+            TriangleMesh triangleMesh = new TriangleMesh();\n+            triangleMesh.getPoints().setAll(points);\n+            triangleMesh.getTexCoords().setAll(texCoords);\n+            triangleMesh.getFaces().setAll(faces);\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+                PhongMaterial materialMesh = new PhongMaterial();\n+                materialMesh.setDiffuseColor(colors[id % colors.length]);\n+                materialMesh.setSpecularColor(colors[id % colors.length]);\n+                String url = RenderPerfTest.class.getResource(\"duke.png\").toString();\n+                materialMesh.setDiffuseMap(new Image(url));\n+\n+                meshView[id] = new MeshView(triangleMesh);\n+                meshView[id].setMaterial(materialMesh);\n+                meshView[id].setDrawMode(DrawMode.FILL);\n+                meshView[id].setCullFace(CullFace.BACK);\n+                node.getChildren().add(meshView[id]);\n+                index++;\n+            }\n+        }\n+\n+        private double getSinDivX(double x, double y) {\n+            float funcValue = -30.0f;\n+            double r = Math.sqrt(x*x + y*y);\n+            return funcValue * (r == 0 ? 1 : Math.sin(r) \/ r);\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            int index = 0;\n+            for (int id = 0; id < n \/ 4; id++) {\n+                sphere[id].setTranslateX(x[index]);\n+                sphere[id].setTranslateY(y[index]);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+                box[id].setTranslateX(x[index]);\n+                box[id].setTranslateY(y[index]);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+                cylinder[id].setTranslateX(x[index]);\n+                cylinder[id].setTranslateY(y[index]);\n+                index++;\n+            }\n+\n+            for (int id = 0; id < n \/ 4; id++) {\n+                meshView[id].setTranslateX(x[index]);\n+                meshView[id].setTranslateY(y[index]);\n+                index++;\n+            }\n+        }\n+    }\n+\n+    static class ButtonRenderer implements ParticleRenderer {\n+        int n;\n+        double r;\n+        Button[] button;\n+\n+        ButtonRenderer(int n, double r) {\n+            this.n = n;\n+            this.r = r;\n+            button = new Button[n];\n+        }\n+\n+        @Override\n+        public void addComponents(Group node, int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                button[id] = new Button();\n+                button[id].setText(String.valueOf(id));\n+                button[id].setLayoutX(x[id]);\n+                button[id].setLayoutY(y[id]);\n+                node.getChildren().add(button[id]);\n+            }\n+        }\n+\n+        public void updateComponentCoordinates(int n, double[] x, double[] y, double[] vx, double[] vy) {\n+            for (int id = 0; id < n; id++) {\n+                button[id].setLayoutX(x[id]);\n+                button[id].setLayoutY(y[id]);\n+            }\n+        }\n+\n+        public void releaseResource() {\n+            button = null;\n+        }\n+\n+        public int getObjectCount() {\n+            return n;\n+        }\n+\n+        public double getParticleRadius() {\n+            return r;\n+        }\n+    }\n+\n+    \/**\n+     * {@link PerfMeter} is the class which runs each test.\n+     * This uses the JavaFX applcation environment created and invokes {@link ParticleRenderable}\n+     * methods to render component and animate. The values details required to calculate\n+     * FPS is also tracked in this class.\n+     *\/\n+    static class PerfMeter {\n+        private String name;\n+\n+        private int frames = 0;\n+        private long testTimeSeconds = DEFAULT_TEST_TIME_SECONDS;\n+        private long testTimeNanos = testTimeSeconds * SECOND_IN_NANOS;\n+        AnimationTimer frameRateMeter;\n+\n+        long startTime = 0;\n+        long lastTickTime = 0;\n+        boolean warmUp = true;\n+        boolean completed = false;\n+        boolean stopped = false;\n+\n+        PerfMeter(String name) {\n+            this(name, DEFAULT_TEST_TIME_SECONDS);\n+        }\n+\n+        PerfMeter(String name, long testTimeSeconds) {\n+            this.name = name;\n+            this.testTimeSeconds = testTimeSeconds;\n+            this.testTimeNanos = this.testTimeSeconds * SECOND_IN_NANOS;\n+        }\n+\n+        \/**\n+         * The method which invokes {@link ParticleRenderable} methods for rendering and\n+         * moving the components on the JavaFX application. Same JavaFX application\n+         * environment is used for all the test cases.\n+         * This method warms up the test environment and then runs animation to calculate FPS.\n+         * The overridden {@link AnimationTimer#handle} method, gets invoked for each frame\n+         * which keeps track of the number of frames rendered, duration of the test case\n+         * to calculate FPS value.\n+         *\n+         * @params  renderable\n+         *          object of {@link Renderable}\n+         *\/\n+        void exec(final Renderable renderable) throws Exception {\n+            final CountDownLatch startupLatch = new CountDownLatch(1);\n+            final CountDownLatch stopLatch = new CountDownLatch(1);\n+            final CountDownLatch stageHiddenLatch = new CountDownLatch(1);\n+\n+            Platform.runLater(() -> {\n+                group = new Group();\n+                renderable.addComponents(group);\n+                scene = new Scene(group, WIDTH, HEIGHT);\n+                scene.setFill(Color.BLACK);\n+\n+                stage.setScene(scene);\n+                stage.setAlwaysOnTop(true);\n+                stage.setOnShown(event -> Platform.runLater(startupLatch::countDown));\n+                stage.setOnHidden(event -> Platform.runLater(stageHiddenLatch::countDown));\n+                stage.setOnCloseRequest(event -> {\n+                    Platform.runLater(stopLatch::countDown);\n+                    stopped = true;\n+                });\n+\n+                stage.show();\n+\n+                frameRateMeter = new AnimationTimer() {\n+                    @Override\n+                    public void handle(long now) {\n+                        if (startTime == 0) {\n+                            startTime = now;\n+                        }\n+\n+                        lastTickTime = now;\n+\n+                        if (warmUp && (now >= startTime + WARMUP_TIME)) {\n+                            startTime = now;\n+                            frames = 0;\n+                            warmUp = false;\n+                        }\n+\n+                        if (!stopped) {\n+                            moveComponents(renderable);\n+                        }\n+\n+                        if (!warmUp) {\n+                            frames++;\n+                            if (testTimeSeconds > 0 && now >= startTime + testTimeNanos) {\n+                                completed = true;\n+                                stopLatch.countDown();\n+                            }\n+                        }\n+                    }\n+                };\n+            });\n+\n+            if (!startupLatch.await(20, TimeUnit.SECONDS)) {\n+                throw new RuntimeException(\"Timeout waiting for stage to load.\");\n+            }\n+            Platform.runLater(() -> frameRateMeter.start());\n+\n+            if (testTimeSeconds > 0) {\n+                \/\/ timed run, which means we can also timeout if something goes wrong\n+                if (!stopLatch.await(testTimeSeconds + 10, TimeUnit.SECONDS)) {\n+                    throw new RuntimeException(\"Timeout waiting for test execution completion.\\n\" + name + \": Test workload could be too high. Try running the test with lesser number of objects.\");\n+                }\n+            } else {\n+                \/\/ infinite run, await until the stage is closed\n+                stopLatch.await();\n+            }\n+            Platform.runLater(() -> frameRateMeter.stop());\n+\n+            reportFPS();\n+            Platform.runLater(() -> {\n+                renderable.releaseResource();\n+                stage.hide();\n+            });\n+\n+            if (!stageHiddenLatch.await(20, TimeUnit.SECONDS)) {\n+                throw new RuntimeException(\"Timeout waiting for stage to get hidden.\");\n+            }\n+            startTime = 0;\n+            warmUp = true;\n+        }\n+\n+        void moveComponents(final Renderable renderable){\n+            Platform.runLater(() -> {\n+                renderable.updateCoordinates();\n+                renderable.updateComponentCoordinates();\n+            });\n+        }\n+\n+        void reportFPS() {\n+            if (warmUp) {\n+                System.out.println(String.format(\"Test %s stopped before warm-up was completed. Results not valid.\", name));\n+            } else {\n+                long totalTestTime = testTimeNanos;\n+                if (totalTestTime == 0 || !completed) {\n+                    \/\/ infinite run, we have to get the time from stop-start delta\n+                    totalTestTime = (lastTickTime - startTime);\n+                }\n+                double totalTestTimeSeconds = (double)totalTestTime \/ SECOND_IN_NANOS;\n+                double frameRate = frames \/ totalTestTimeSeconds;\n+                System.out.println(String.format(\"%s (Objects Frames Time FPS): %d, %d, %.2f, %.2f\", name, objectCount, frames, totalTestTimeSeconds, frameRate));\n+            }\n+        }\n+    }\n+\n+\n+\n+    public void testArc() throws Exception {\n+        (new PerfMeter(\"Arc\", testDuration)).exec(createPR(new ArcRenderer(objectCount, R)));\n+    }\n+\n+    public void testOpenArc() throws Exception {\n+        (new PerfMeter(\"OpenArc\", testDuration)).exec(createPR(new OpenArcRenderer(objectCount, R)));\n+    }\n+\n+    public void testCubicCurve() throws Exception {\n+        (new PerfMeter(\"CubicCurve\", testDuration)).exec(createPR(new CubicCurveRenderer(objectCount, R)));\n+    }\n+\n+    public void testQuadCurve() throws Exception {\n+        (new PerfMeter(\"QuadCurve\", testDuration)).exec(createPR(new QuadCurveRenderer(objectCount, R)));\n+    }\n+\n+    public void testCircle() throws Exception {\n+        (new PerfMeter(\"Circle\", testDuration)).exec(createPR(new CircleRenderer(objectCount, R)));\n+    }\n+\n+    public void testCircleRH() throws Exception {\n+        (new PerfMeter(\"CircleRH\", testDuration)).exec(createPR(new CircleRendererRH(objectCount, R)));\n+    }\n+\n+    public void testCircleBlendMultiply() throws Exception {\n+        (new PerfMeter(\"CircleBlendMultiply\", testDuration)).exec(createPR(new CircleRendererBlendMultiply(objectCount, R)));\n+    }\n+\n+    public void testCircleBlendAdd() throws Exception {\n+        (new PerfMeter(\"CircleBlendAdd\", testDuration)).exec(createPR(new CircleRendererBlendAdd(objectCount, R)));\n+    }\n+\n+    public void testCircleBlendDarken() throws Exception {\n+        (new PerfMeter(\"CircleBlendDarken\", testDuration)).exec(createPR(new CircleRendererBlendDarken(objectCount, R)));\n+    }\n+\n+    public void testStrokedCircle() throws Exception {\n+        (new PerfMeter(\"StrokedCircle\", testDuration)).exec(createPR(new StrokedCircleRenderer(objectCount, R)));\n+    }\n+\n+    public void testLinGradCircle() throws Exception {\n+        (new PerfMeter(\"LinGradCircle\", testDuration)).exec(createPR(new LinGradCircleRenderer(objectCount, R)));\n+    }\n+\n+    public void testRadGradCircle() throws Exception {\n+        (new PerfMeter(\"RadGradCircle\", testDuration)).exec(createPR(new RadGradCircleRenderer(objectCount, R)));\n+    }\n+\n+    public void testEllipse() throws Exception {\n+        (new PerfMeter(\"Ellipse\", testDuration)).exec(createPR(new EllipseRenderer(objectCount, R)));\n+    }\n+\n+    public void testLine() throws Exception {\n+        (new PerfMeter(\"Line\", testDuration)).exec(createPR(new LineRenderer(objectCount, R)));\n+    }\n+\n+    public void testPath() throws Exception {\n+        (new PerfMeter(\"Path\", testDuration)).exec(createPR(new PathRenderer(objectCount, R)));\n+    }\n+\n+    public void testRectangle() throws Exception {\n+        (new PerfMeter(\"Rectangle\", testDuration)).exec(createPR(new RectangleRenderer(objectCount, R)));\n+    }\n+\n+    public void testRotatedRectangleRH() throws Exception {\n+        (new PerfMeter(\"RotatedRectangleRH\", testDuration)).exec(createPR(new RectangleRendererRH(objectCount, R)));\n+    }\n+\n+    public void testStrokedRectangle() throws Exception {\n+        (new PerfMeter(\"StrokedRectangle\", testDuration)).exec(createPR(new StrokedRectangleRenderer(objectCount, R)));\n+    }\n+\n+    public void testPolygon() throws Exception {\n+        (new PerfMeter(\"Polygon\", testDuration)).exec(createPR(new PolygonRenderer(objectCount, R)));\n+    }\n+\n+    public void testStrokedPolygon() throws Exception {\n+        (new PerfMeter(\"StrokedPolygon\", testDuration)).exec(createPR(new StrokedPolygonRenderer(objectCount, R)));\n+    }\n+\n+    public void testWhiteText() throws Exception {\n+        (new PerfMeter(\"WhiteText\", testDuration)).exec(createPR(new WhiteTextRenderer(objectCount, R)));\n+    }\n+\n+    public void testColorText() throws Exception {\n+        (new PerfMeter(\"ColorText\", testDuration)).exec(createPR(new ColorTextRenderer(objectCount, R)));\n+    }\n+\n+    public void testLargeText() throws Exception {\n+        (new PerfMeter(\"LargeText\", testDuration)).exec(createPR(new LargeTextRenderer(objectCount, R)));\n+    }\n+\n+    public void testLargeColorText() throws Exception {\n+        (new PerfMeter(\"LargeColorText\", testDuration)).exec(createPR(new LargeColorTextRenderer(objectCount, R)));\n+    }\n+\n+    public void testImage() throws Exception {\n+        (new PerfMeter(\"Image\", testDuration)).exec(createPR(new ImageRenderer(objectCount, R)));\n+    }\n+\n+    public void testImageRH() throws Exception {\n+        (new PerfMeter(\"ImageRH\", testDuration)).exec(createPR(new ImageRendererRH(objectCount, R)));\n+    }\n+\n+    public void test3DBox() throws Exception {\n+        (new PerfMeter(\"3DBox\", testDuration)).exec(createPR(new Box3DRenderer(objectCount, R)));\n+    }\n+\n+    public void test3DCylinder() throws Exception {\n+        (new PerfMeter(\"3DCylinder\", testDuration)).exec(createPR(new CylinderRenderer(objectCount, R)));\n+    }\n+\n+    public void test3DSphere() throws Exception {\n+        (new PerfMeter(\"3DSphere\", testDuration)).exec(createPR(new SphereRenderer(objectCount, R)));\n+    }\n+\n+    public void test3DMesh() throws Exception {\n+        (new PerfMeter(\"3DMesh\", testDuration)).exec(createPR(new MeshRenderer(objectCount, R)));\n+    }\n+\n+    public void testMultiShape2DInterleaved() throws Exception {\n+        (new PerfMeter(\"MultiShape2DInterleaved\", testDuration)).exec(createPR(new MultiShapeRendererInterleaved(objectCount, R)));\n+    }\n+\n+    public void testMultiShape2D() throws Exception {\n+        (new PerfMeter(\"MultiShape2D\", testDuration)).exec(createPR(new MultiShapeRenderer(objectCount, R)));\n+    }\n+\n+    public void testMultiShape3DInterleaved() throws Exception {\n+        (new PerfMeter(\"MultiShape3DInterleaved\", testDuration)).exec(createPR(new MultiShape3DRendererInterleaved(objectCount, R)));\n+    }\n+\n+    public void testMultiShape3D() throws Exception {\n+        (new PerfMeter(\"MultiShape3D\", testDuration)).exec(createPR(new MultiShape3DRenderer(objectCount, R)));\n+    }\n+\n+    public void testMultiShape2D3DInterleaved() throws Exception {\n+        (new PerfMeter(\"MultiShape2D3DInterleaved\", testDuration)).exec(createPR(new MultiShape2D3DRendererInterleaved(objectCount, R)));\n+    }\n+\n+    public void testMultiShape2D3D() throws Exception {\n+        (new PerfMeter(\"MultiShape2D3D\", testDuration)).exec(createPR(new MultiShape2D3DRenderer(objectCount, R)));\n+    }\n+\n+    public void testButton() throws Exception {\n+        (new PerfMeter(\"Button\", testDuration)).exec(createPR(new ButtonRenderer(objectCount, R)));\n+    }\n+\n+    \/**\n+     * Initialize the JavaFX application environment.\n+     * Once the stage is initialized, all tests use\n+     * same environment for execution.\n+     *\/\n+    public void intializeFxEnvironment() {\n+        Platform.startup(() -> {\n+            stage = new Stage();\n+            Platform.setImplicitExit(false);\n+        });\n+    }\n+\n+    public void exitFxEnvironment() {\n+        Platform.exit();\n+    }\n+\n+    public boolean parseCmdOptions(String[] args) {\n+        for (int i = 0; i < args.length; i++) {\n+            String arg = args[i];\n+            switch(arg) {\n+            case \"-t\":\n+                while ((i+1) < args.length && args[i + 1].charAt(0) != '-') {\n+                    testList.add(args[++i]);\n+                }\n+                if (testList.size() == 0) return false;\n+                break;\n+            case \"-n\":\n+                try {\n+                    objectCount = Integer.parseInt(args[++i]);\n+                }\n+                catch (ArrayIndexOutOfBoundsException e) {\n+                    System.out.println(\"\\nnumber_of_objects not provided.\");\n+                    return false;\n+                }\n+                break;\n+            case \"-d\":\n+                try {\n+                    testDuration = Integer.parseInt(args[++i]);\n+                }\n+                catch (ArrayIndexOutOfBoundsException e) {\n+                    System.out.println(\"\\ntest_duration_in_seconds not provided.\");\n+                    return false;\n+                }\n+                break;\n+            case \"-h\":\n+            case \"--help\":\n+            default:\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public static void printTests() {\n+        Method[] methods = RenderPerfTest.class.getDeclaredMethods();\n+        System.out.println(\"\\nSupported tests:\");\n+        for (Method m : methods) {\n+            if (m.getName().startsWith(\"test\")) {\n+                System.out.println(m.getName().replaceFirst(\"test\", \"\"));\n+            }\n+        }\n+    }\n+\n+    public static void printUsage() {\n+        System.out.println(\"Usage: java @<path_to>\/run.args RenderPerfTest [-t <test_name>...] [-n <number_of_objects>] [-d <test_duration_in_seconds>] [-h]\");\n+        System.out.println(\"       Where test_name: Name of the test (or tests) to be executed.\");\n+        System.out.println(\"             number_of_objects: Number of objects to be rendered in the test(s)\");\n+        System.out.println(\"             test_duration_in_seconds: How many seconds should each test take (default 10, set 0 for infinite run)\");\n+        System.out.println(\"                                       NOTE: Tests have extra 5 seconds warmup time where performance is NOT measured.\");\n+        System.out.println(\"             -h: help: print application usage\");\n+        System.out.println(\"NOTE: Set JVM command line parameter -Djavafx.animation.fullspeed=true to run animation at full speed\");\n+\n+        printTests();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        RenderPerfTest test = new RenderPerfTest();\n+\n+        test.intializeFxEnvironment();\n+        testList = new ArrayList<String>();\n+\n+        if (!test.parseCmdOptions(args)) {\n+            printUsage();\n+            test.exitFxEnvironment();\n+            return;\n+        }\n+\n+        if (test.objectCount == 0) {\n+            test.objectCount = 1000;\n+        }\n+\n+        if (test.testDuration == 0) {\n+            System.out.println(\"NOTE: Test length set to 0. Test will run indefinitely until Stage is closed.\");\n+        }\n+\n+        try {\n+            if (testList.size() != 0) {\n+                for(String testName: testList) {\n+                    Method m = RenderPerfTest.class.getDeclaredMethod(\"test\" + testName);\n+                    m.invoke(test);\n+                }\n+            } else {\n+                Method[] methods = RenderPerfTest.class.getDeclaredMethods();\n+                for (Method m : methods) {\n+                    if (m.getName().startsWith(\"test\")) {\n+                        m.invoke(test);\n+                    }\n+                }\n+            }\n+        } catch (NoSuchMethodException e) {\n+            System.out.println(\"\\nIncorrect Test Name!\");\n+            printTests();\n+        } catch (InvocationTargetException e) {\n+            System.out.println(e.getCause().getMessage());\n+        } catch (Exception e) {\n+            System.out.println(\"\\nUnexpected error occurred\");\n+            e.printStackTrace();\n+        }\n+        test.exitFxEnvironment();\n+    }\n+}\n","filename":"tests\/performance\/animation\/RenderPerfTest\/src\/renderperf\/RenderPerfTest.java","additions":2326,"deletions":0,"binary":false,"changes":2326,"status":"added"},{"filename":"tests\/performance\/animation\/RenderPerfTest\/src\/renderperf\/duke.png","binary":true,"status":"added"}]}