{"files":[{"patch":"@@ -41,0 +41,6 @@\n+    default boolean isColorGlyph(int glyphCode) {\n+        int slot = (glyphCode >>> 24);\n+        int slotglyphCode = glyphCode & CompositeGlyphMapper.GLYPHMASK;\n+        FontResource slotResource = getSlotResource(slot);\n+        return slotResource.isColorGlyph(slotglyphCode);\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/CompositeFontResource.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+    public static final int colrTag = 0x434F4C52; \/\/ 'COLR'\n+    public static final int sbixTag = 0x73626978; \/\/ 'sbix'\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/FontConstants.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -119,0 +119,3 @@\n+\n+    public boolean isColorGlyph(int gc);\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/FontResource.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1181,0 +1181,27 @@\n+    @Override\n+    public float getAdvance(int glyphCode, float ptSize) {\n+        if (glyphCode == CharToGlyphMapper.INVISIBLE_GLYPH_ID) {\n+            return 0f;\n+        }\n+\n+        \/*\n+         * Platform-specific but it needs to be explained why this is needed.\n+         * The hmtx table in the Apple Color Emoji font can be woefully off\n+         * compared to the size of emoji glyph CoreText generates and the advance\n+         * CoreText supports. So for macOS at least, we need to get those advances\n+         * another way. Note : I also see \"small\" discrepancies for ordinary\n+         * glyphs in the mac system font between hmtx and CoreText.\n+         * Limit use of this because we aren't caching the result.\n+         *\/\n+        if (PrismFontFactory.isMacOSX && isColorGlyph(glyphCode)) {\n+            return getAdvanceFromPlatform(glyphCode, ptSize);\n+        } else {\n+            return getAdvanceFromHMTX(glyphCode, ptSize);\n+        }\n+    }\n+\n+    \/* REMIND: We can cache here if it is slow *\/\n+    protected float getAdvanceFromPlatform(int glyphCode, float ptSize) {\n+        return getAdvanceFromHMTX(glyphCode, ptSize);\n+    }\n+\n@@ -1211,4 +1238,1 @@\n-    @Override\n-    public float getAdvance(int glyphCode, float ptSize) {\n-        if (glyphCode == CharToGlyphMapper.INVISIBLE_GLYPH_ID)\n-            return 0f;\n+    private float getAdvanceFromHMTX(int glyphCode, float ptSize) {\n@@ -1377,0 +1401,111 @@\n+\n+\n+    private boolean checkedColorTables;\n+    private boolean hasColorTables;\n+    private synchronized boolean fontSupportsColorGlyphs() {\n+       if (checkedColorTables) {\n+           return hasColorTables;\n+       }\n+       hasColorTables =\n+           getDirectoryEntry(sbixTag) != null ||\n+           getDirectoryEntry(colrTag) != null;\n+       checkedColorTables = true;\n+\n+       return hasColorTables;\n+    }\n+\n+    public boolean isColorGlyph(int glyphID) {\n+        if (!fontSupportsColorGlyphs()) {\n+            return false;\n+        }\n+        if (getDirectoryEntry(sbixTag) != null) {\n+            return isSbixGlyph(glyphID);\n+        }\n+        return false;\n+   }\n+\n+\n+   private static final int USHORT_MASK = 0xffff;\n+   private static final int UINT_MASK   = 0xffffffff;\n+\n+   static class ColorGlyphStrike {\n+\n+       private int ppem;\n+       private int ppi;\n+       private int dataOffsets[];\n+\n+       ColorGlyphStrike(int ppem, int ppi, int[] offsets) {\n+           this.ppem = ppem;\n+           this.ppi  = ppi ;\n+           dataOffsets = offsets;\n+       }\n+\n+       boolean hasGlyph(int gid) {\n+           if (gid >= dataOffsets.length) {\n+              return false;\n+           }\n+           \/* The following is correct, per the OpenType sbix spec\n+            * there's one extra offset.\n+            *\/\n+           return dataOffsets[gid] < dataOffsets[gid+1];\n+       }\n+   }\n+\n+   ColorGlyphStrike[] sbixStrikes = null;\n+\n+   private boolean isSbixGlyph(int glyphID) {\n+       if (sbixStrikes == null) {\n+           synchronized (this) {\n+               buildSbixStrikeTables();\n+               if (sbixStrikes == null) {\n+                   sbixStrikes = new ColorGlyphStrike[0];\n+               }\n+           }\n+       }\n+       for (int i=0; i<sbixStrikes.length; i++) {\n+          if (sbixStrikes[i].hasGlyph(glyphID)) {\n+              return true;\n+          }\n+       }\n+       return false;\n+   }\n+\n+   private void buildSbixStrikeTables() {\n+\n+       Buffer sbixTable = readTable(sbixTag);\n+\n+       if (sbixTable == null) {\n+           return;\n+       }\n+       int sz = sbixTable.capacity();\n+       sbixTable.skip(4); \/\/ past version and flags\n+       int numStrikes = sbixTable.getInt() & UINT_MASK;\n+       if (numStrikes <= 0 || numStrikes >= sz) {\n+           return;\n+       }\n+       int[] strikeOffsets = new int[numStrikes];\n+       for (int i=0; i<numStrikes; i++) {\n+           strikeOffsets[i] = sbixTable.getInt() & UINT_MASK;\n+           if (strikeOffsets[i] >= sz) {\n+               return;\n+           }\n+       }\n+       int numGlyphs = getNumGlyphs();\n+       ColorGlyphStrike[] strikes = new ColorGlyphStrike[numStrikes];\n+       for (int i=0; i<numStrikes; i++) {\n+           if (strikeOffsets[i] + 4 + (4*(numGlyphs+1)) > sz) {\n+                return;\n+           }\n+           sbixTable.position(strikeOffsets[i]);\n+\n+           int ppem = sbixTable.getChar() & USHORT_MASK;\n+           int ppi  = sbixTable.getChar() & USHORT_MASK;\n+           int[] glyphDataOffsets = new int[numGlyphs+1];\n+           for (int g=0; g<=numGlyphs; g++) {\n+               glyphDataOffsets[g] = sbixTable.getInt() & UINT_MASK;\n+           }\n+           strikes[i] = new ColorGlyphStrike(ppem, ppi, glyphDataOffsets);\n+       }\n+       sbixStrikes = strikes;\n+   }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/PrismFontFile.java","additions":139,"deletions":4,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -138,1 +138,15 @@\n-    @Override protected int[] createGlyphBoundingBox(int gc) {\n+   @Override protected float getAdvanceFromPlatform(int glyphCode, float ptSize) {\n+      CTFontStrike strike =\n+          (CTFontStrike)getStrike(ptSize, BaseTransform.IDENTITY_TRANSFORM);\n+      long fontRef = strike.getFontRef();\n+      int orientation = OS.kCTFontOrientationDefault;\n+      CGSize size = new CGSize();\n+      return (float)OS.CTFontGetAdvancesForGlyphs(fontRef, orientation, (short)glyphCode, size);\n+   }\n+\n+   @Override protected int[] createGlyphBoundingBox(int gc) {\n+        \/*\n+         * This is being done at size 12 so that the font can cache\n+         * bounds and scale to the required point size. But if the\n+         * bounds do not scale linearly this will fail badly\n+         *\/\n@@ -151,0 +165,2 @@\n+         * However for color (emoji) glyphs this returns the wrong bounds,\n+         * so use CTFontGetBoundingRectsForGlyphs anyway.\n@@ -155,2 +171,7 @@\n-            short format = getIndexToLocFormat();\n-            if (OS.CTFontGetBoundingRectForGlyphUsingTables(fontRef, (short)gc, format, bb)) {\n+            if (isColorGlyph(gc)) {\n+                CGRect rect = OS.CTFontGetBoundingRectForGlyphs(fontRef, (short)gc);\n+                float scale = getUnitsPerEm() \/ size;\n+                bb[0] = (int)(Math.round(rect.origin.x * scale));\n+                bb[1] = (int)(Math.round(rect.origin.y * scale));\n+                bb[2] = (int)(Math.round((rect.origin.x + rect.size.width) * scale));\n+                bb[3] = (int)(Math.round((rect.origin.y + rect.size.height) * scale));\n@@ -158,0 +179,5 @@\n+            } else {\n+                short format = getIndexToLocFormat();\n+                if (OS.CTFontGetBoundingRectForGlyphUsingTables(fontRef, (short)gc, format, bb)) {\n+                    return bb;\n+                }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/coretext\/CTFontFile.java","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -89,2 +89,0 @@\n-        if (drawShapes) return;\n-\n@@ -157,0 +155,35 @@\n+    private synchronized byte[] getColorImage(double x, double y, int w, int h) {\n+\n+        if (w == 0 || h == 0) return new byte[0];\n+\n+        long fontRef = strike.getFontRef();\n+        CGAffineTransform matrix = strike.matrix;\n+        long context = createContext(true, w, h);\n+        if (context == 0) return new byte[0];\n+\n+        double drawX = 0, drawY = 0;\n+        if (matrix != null) {\n+            OS.CGContextTranslateCTM(context, -x, -y);\n+        } else {\n+            drawX = x;\n+            drawY = y;\n+        }\n+\n+        OS.CTFontDrawGlyphs(fontRef, (short)glyphCode, -drawX, -drawY, context);\n+\n+        if (matrix != null) {\n+            OS.CGContextTranslateCTM(context, x, y);\n+        }\n+\n+        byte[] imageData = OS.CGImageContextGetData(context, w, h, 32);\n+        if (imageData == null) {\n+            bounds = new CGRect();\n+            imageData = new byte[0];\n+        }\n+\n+        OS.CGContextRelease(context);\n+\n+        return imageData;\n+    }\n+\n+\n@@ -216,2 +249,8 @@\n-        return getImage(bounds.origin.x, bounds.origin.y,\n-                        (int)bounds.size.width, (int)bounds.size.height, subPixel);\n+        if (isColorGlyph()) {\n+            return getColorImage(bounds.origin.x, bounds.origin.y,\n+                                 (int)bounds.size.width, (int)bounds.size.height);\n+        } else {\n+            return getImage(bounds.origin.x, bounds.origin.y,\n+                            (int)bounds.size.width, (int)bounds.size.height,\n+                            subPixel);\n+        }\n@@ -239,1 +278,5 @@\n-        return isLCDGlyph() ? w * 3 : w;\n+        if (isColorGlyph()) {\n+            return (w * 4); \/\/ has alpha\n+        } else {\n+            return isLCDGlyph() ? w * 3 : w;\n+        }\n@@ -259,0 +302,5 @@\n+    public boolean isColorGlyph() {\n+        CTFontFile fontResource = strike.getFontResource();\n+        return fontResource.isColorGlyph(glyphCode);\n+    }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/coretext\/CTGlyph.java","additions":53,"deletions":5,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+    static final native byte[] CGImageContextGetData(long c, int width, int height, int bpp);\n@@ -69,0 +70,1 @@\n+    static final native CGRect CTFontGetBoundingRectForGlyphs(long font, short glyph);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/coretext\/OS.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -293,0 +293,12 @@\n+    \/*\n+     * drawAsShapes() is used for large glyphs to avoid blowing the cache.\n+     * But emojis aren't (currently) cached and may not be available as shapes.\n+     * So the drawAsShapes path results in blank space instead of a large emoji\n+     * This check is used in renderText() where we would otherwise use shapes\n+     * to prevent that.\n+     *\/\n+    private boolean isEmojiRun(TextRun run, FontStrike strike) {\n+        FontResource res = strike.getFontResource();\n+        return strike.drawAsShapes() && res.isColorGlyph(run.getGlyphCode(0));\n+    }\n+\n@@ -310,1 +322,1 @@\n-                if ((op & FILL) != 0) {\n+                if (((op & FILL) != 0) || isEmojiRun(run, strike)) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/sg\/prism\/NGText.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+import com.sun.javafx.font.CharToGlyphMapper;\n@@ -73,0 +74,1 @@\n+import com.sun.javafx.font.PrismFontFile;\n@@ -206,0 +208,1 @@\n+            int surrogate = 0;\n@@ -207,4 +210,27 @@\n-            \/* special handling for delimiters *\/\n-            if (delimiter) {\n-                if (i != start) {\n-                    run = addTextRun(layout, chars, start, i - start,\n+            if (Character.isHighSurrogate(ch)) {\n+                \/* Only merge surrogate when the pair is in the same span. *\/\n+                if (i + 1 < spanEnd && Character.isLowSurrogate(chars[i + 1])) {\n+                    codePoint = Character.toCodePoint(ch, chars[++i]);\n+                    surrogate = 1;\n+                }\n+            }\n+            \/*\n+             * Since Emojis are usually used one at a time, handle them\n+             * similarly to delimiters - if we have any chars in the current run,\n+             * break the run there. Then (see code later in the method) create\n+             * a new run just for the one emoji and then start the next run.\n+             * Having it in a separate run allows rendering code to more\n+             * efficiently handle it rather than having to switch rendering\n+             * modes in the middle of a drawString.\n+             *\/\n+            boolean isEmoji = false;\n+            if (font != null) {\n+                FontResource fr = font.getFontResource();\n+                int glyphID = fr.getGlyphMapper().charToGlyph(codePoint);\n+                isEmoji = fr.isColorGlyph(glyphID);\n+            }\n+\n+            \/* special handling for delimiters and Emoji *\/\n+            if (delimiter || isEmoji) {\n+                if ((i - surrogate) != start) {\n+                    run = addTextRun(layout, chars, start, i - surrogate - start,\n@@ -216,1 +242,1 @@\n-                    start = i;\n+                    start = i - surrogate;\n@@ -219,0 +245,1 @@\n+\n@@ -222,1 +249,2 @@\n-            if (!delimiter) {\n+\n+            if (!delimiter && !isEmoji) {\n@@ -225,6 +253,0 @@\n-                    if (Character.isHighSurrogate(ch)) {\n-                        \/* Only merge surrogate when the pair is in the same span. *\/\n-                        if (i + 1 < spanEnd && Character.isLowSurrogate(chars[i + 1])) {\n-                            codePoint = Character.toCodePoint(ch, chars[++i]);\n-                        }\n-                    }\n@@ -308,0 +330,8 @@\n+            if (isEmoji) {\n+                i++;\n+                \/* Create Emoji run *\/\n+                run = new TextRun(start, i - start, bidiLevel, false,\n+                                  ScriptMapper.COMMON, span, 0, false);\n+                layout.addTextRun(run);\n+                start = i;\n+            }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/text\/GlyphLayout.java","additions":42,"deletions":12,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.ByteBuffer;\n@@ -30,0 +31,1 @@\n+import com.sun.javafx.font.Glyph;\n@@ -39,0 +41,1 @@\n+import com.sun.prism.Texture.WrapMode;\n@@ -218,0 +221,34 @@\n+\n+\n+    \/*\n+     * Identical in each of BaseShaderGraphics, J2DPrismGraphics and SWGraphics\n+     *\/\n+    default void drawColorGlyph(GlyphList gl, FontStrike strike, float x, float y,\n+                           Color selectColor, int selectStart, int selectEnd) {\n+\n+      int glyphCode = gl.getGlyphCode(0);\n+      Glyph glyph = strike.getGlyph(glyphCode);\n+      if (glyph == null) {\n+          return;\n+      }\n+\n+      byte[] glyphImage = glyph.getPixelData(0);\n+      int ox = glyph.getOriginX();\n+      int oy = glyph.getOriginY();\n+      int height = glyph.getHeight();\n+      int bytesWidth = glyph.getWidth();\n+      \/\/ glyph width is reported in bytes, so code here needs to know\n+      \/\/ that the bytes-per-pixel is grey=1, lcd=3, color=4\n+      int width = bytesWidth \/ 4;\n+\n+      PixelFormat format = PixelFormat.BYTE_BGRA_PRE;\n+      Texture tex = getResourceFactory().createTexture(\n+            format, Texture.Usage.STATIC, WrapMode.CLAMP_NOT_NEEDED, width, height);\n+      ByteBuffer bb = ByteBuffer.wrap(glyphImage);\n+      int scan = width * tex.getPixelFormat().getBytesPerPixelUnit();\n+      \/\/ format arg is the Buffer pixel format. Texture may not be created with the\n+      \/\/ same as requested (ie the software pipeline).\n+      tex.update(bb, format, 0, 0, 0, 0, width, height, scan, false);\n+      drawTexture(tex, x+ox, y+oy, x+ox+width, y+oy+height, 0, 0, width, height);\n+      tex.dispose();\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/Graphics.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1988,0 +1988,4 @@\n+        if (strike.getFontResource().isColorGlyph(gl.getGlyphCode(0))) {\n+            drawColorGlyph(gl, strike, x, y, selectColor, selectStart, selectEnd);\n+            return;\n+        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/impl\/ps\/BaseShaderGraphics.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -878,0 +878,5 @@\n+        if (strike.getFontResource().isColorGlyph(gl.getGlyphCode(0))) {\n+            drawColorGlyph(gl, strike, x, y, selectColor, start, end);\n+            return;\n+        }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/j2d\/J2DPrismGraphics.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+import com.sun.prism.Texture.WrapMode;\n@@ -635,0 +636,5 @@\n+        if (strike.getFontResource().isColorGlyph(gl.getGlyphCode(0))) {\n+            drawColorGlyph(gl, strike, x, y, selectColor, selectStart, selectEnd);\n+            return;\n+        }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/sw\/SWGraphics.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -771,0 +771,49 @@\n+JNIEXPORT jbyteArray JNICALL OS_NATIVE(CGImageContextGetData)\n+    (JNIEnv *env, jclass that, jlong arg0, jint dstWidth, jint dstHeight, jint bpp)\n+{\n+    jbyteArray result = NULL;\n+    if (dstWidth < 0) return NULL;\n+    if (dstHeight < 0) return NULL;\n+    if (bpp != 32) return NULL;\n+\n+    CGContextRef context = (CGContextRef)arg0;\n+    if (context == NULL) return NULL;\n+    jbyte *srcData = (jbyte*)CGBitmapContextGetData(context);\n+\n+    if (srcData) {\n+        size_t srcWidth = CGBitmapContextGetWidth(context);\n+        if (srcWidth < dstWidth) return NULL;\n+        size_t srcHeight =  CGBitmapContextGetHeight(context);\n+        if (srcHeight < dstHeight) return NULL;\n+        size_t srcBytesPerRow = CGBitmapContextGetBytesPerRow(context);\n+        size_t srcStep = CGBitmapContextGetBitsPerPixel(context) \/ 8;\n+        int srcOffset = (srcHeight - dstHeight) * srcBytesPerRow;\n+\n+        int dstStep = bpp \/ 8;\n+        size_t size = dstWidth * dstHeight * dstStep;\n+        jbyte* data = (jbyte*)calloc(size, sizeof(jbyte));\n+        if (data == NULL) return NULL;\n+\n+        int x, y, sx;\n+\n+        int dstOffset = 0;\n+        for (y = 0; y < dstHeight; y++) {\n+            for (x = 0, sx = 0; x < dstWidth; x++, dstOffset += dstStep, sx += srcStep) {\n+                \/* BGRA to BGRA *\/\n+                data[dstOffset + 0] = srcData[srcOffset + sx + 0];\n+                data[dstOffset + 1] = srcData[srcOffset + sx + 1];\n+                data[dstOffset + 2] = srcData[srcOffset + sx + 2];\n+                data[dstOffset + 3] = srcData[srcOffset + sx + 3];\n+            }\n+            srcOffset += srcBytesPerRow;\n+        }\n+\n+        result = (*env)->NewByteArray(env, size);\n+        if (result) {\n+            (*env)->SetByteArrayRegion(env, result, 0, size, data);\n+        }\n+        free(data);\n+    }\n+    return result;\n+}\n+\n@@ -848,0 +897,9 @@\n+JNIEXPORT jobject JNICALL OS_NATIVE(CTFontGetBoundingRectForGlyphs)\n+    (JNIEnv *env, jclass that, jlong arg1, jshort arg2)\n+{\n+    CTFontRef fontRef = (CTFontRef)arg1;\n+    CGGlyph glyphs[] = {arg2};\n+    CGRect bb = CTFontGetBoundingRectsForGlyphs(fontRef, (CTFontOrientation)0, glyphs, NULL, 1);\n+    return newCGRect(env, &bb);\n+}\n+\n","filename":"modules\/javafx.graphics\/src\/main\/native-font\/coretext.c","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javafx.application.Application;\n+import javafx.application.Platform;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.Group;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.TextField;\n+import javafx.stage.Stage;\n+import javafx.scene.text.Font;\n+import javafx.scene.text.Text;\n+\n+public class EmojiTest extends Application {\n+\n+   static String instructions =\n+      \"\"\"\n+        This tests rendering of Emoji glyphs which is only supported on macOS.\n+        On macOS you should see a yellow-coloured smiling face image,\n+        embedded between 'ab' and 'cd'.\n+        On other platforms it may be a missing glyph, or an empty space, or\n+        a similar rendering as a greyscale\/B&W glyph.\n+        Principally, you are checking that the emoji is rendered on macOS in\n+        each of the controls and nodes displayed in the test, and that the\n+        editable text field handles selection of the emoji glyph with the\n+        same background as other glyphs - this presumes the emoji image has\n+        transparent background pixels.\n+        There are 3 different ways it is displayed to verify\n+        1) Text node. 2) Label control, 3) TextFile Control\n+        Press the Pass or Fail button as appropriate and the test will exit.\n+        If what you see is not explained here, ask before filing a bug.\n+\n+\n+        \"\"\";\n+\n+    public static void main(String[] args) {\n+        launch(args);\n+    }\n+\n+    private void quit() {\n+        Platform.exit();\n+    }\n+\n+    @Override\n+    public void start(Stage stage) {\n+        Button passButton = new Button(\"Pass\");\n+        Button failButton = new Button(\"Fail\");\n+        passButton.setOnAction(e -> this.quit());\n+        failButton.setOnAction(e -> {\n+            this.quit();\n+            throw new AssertionError(\"The Emoji was not rendered on macOS\");\n+        });\n+\n+        HBox hbox = new HBox(10, passButton, failButton);\n+\n+        Text instTA = new Text(instructions);\n+        instTA.setWrappingWidth(500);\n+\n+        Font font = new Font(32);\n+        String emojiString = \"ab\\ud83d\\ude00cd\";\n+        Text text = new Text(emojiString);\n+        text.setFont(font);\n+        Label label = new Label(emojiString);\n+        label.setFont(font);\n+        TextField textField = new TextField(emojiString);\n+        textField.setFont(font);\n+\n+        VBox vbox = new VBox();\n+        Scene scene = new Scene(vbox);\n+        vbox.getChildren().add(instTA);\n+        vbox.getChildren().add(hbox);\n+        vbox.getChildren().add(text);\n+        vbox.getChildren().add(label);\n+        vbox.getChildren().add(textField);\n+        stage.setWidth(600);\n+        stage.setHeight(600);\n+        stage.setScene(scene);\n+\n+        stage.show();\n+    }\n+\n+}\n","filename":"tests\/manual\/text\/EmojiTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"}]}