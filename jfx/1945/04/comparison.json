{"files":[{"patch":"@@ -2859,1 +2859,1 @@\n-                    if (p != null && !p.isCurrentLayoutChild(Node.this)) {\n+                    if (p != null && !p.inLayoutChildren()) {\n@@ -2933,1 +2933,1 @@\n-                    if (p != null && !p.isCurrentLayoutChild(Node.this)) {\n+                    if (p != null && !p.inLayoutChildren()) {\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Node.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -987,0 +987,13 @@\n+    private boolean inLayoutChildren;\n+\n+    \/**\n+     * Returns whether this node is currently running its {@link #layoutChildren()}\n+     * method. This is useful to detect if a change to layout properties of a\n+     * direct child should be ignored, or should trigger a layout pass.\n+     *\n+     * @return {@code true} if this node is running {@link #layoutChildren()}, otherwise {@code false}\n+     *\/\n+    boolean inLayoutChildren() {\n+        return inLayoutChildren;\n+    }\n+\n@@ -1246,11 +1259,0 @@\n-    \/**\n-     * It stores the reference to the current child being laid out by its parent.\n-     * This reference is important to differentiate whether a layout is triggered\n-     * by its parent or other events.\n-     *\/\n-    private Node currentLayoutChild = null;\n-\n-    boolean isCurrentLayoutChild(Node node) {\n-        return node == currentLayoutChild;\n-    }\n-\n@@ -1283,1 +1285,9 @@\n-                layoutChildren();\n+                inLayoutChildren = true;\n+\n+                try {\n+                    layoutChildren();\n+                }\n+                finally {\n+                    inLayoutChildren = false;\n+                }\n+\n@@ -1288,1 +1298,1 @@\n-                    currentLayoutChild = child;\n+\n@@ -1295,1 +1305,1 @@\n-                currentLayoutChild = null;\n+\n@@ -1312,1 +1322,1 @@\n-            currentLayoutChild = node;\n+\n@@ -1317,1 +1327,0 @@\n-        currentLayoutChild = null;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Parent.java","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import com.sun.javafx.scene.LayoutFlags;\n@@ -66,0 +67,2 @@\n+import java.util.List;\n+import java.util.Objects;\n@@ -67,0 +70,1 @@\n+import java.util.stream.Stream;\n@@ -72,0 +76,1 @@\n+import javafx.scene.Parent;\n@@ -78,0 +83,1 @@\n+import javafx.scene.layout.HBox;\n@@ -1676,4 +1682,5 @@\n-    public void testLayoutXYTriggersParentSizeChange() {\n-        final Group rootGroup = new Group();\n-        final Group subGroup = new Group();\n-        ParentShim.getChildren(rootGroup).add(subGroup);\n+    public void testLayoutXYTriggersParentSizeChangeForManagedChild() {\n+        Rectangle r1 = new Rectangle(50, 50);\n+        Rectangle r2 = new Rectangle(1, 1);\n+        Group group = new Group(r1, r2);\n+        HBox root = new HBox(group);\n@@ -1681,4 +1688,1 @@\n-        Rectangle r = new Rectangle(50,50);\n-        r.setManaged(false);\n-        Rectangle staticR = new Rectangle(1,1);\n-        ParentShim.getChildren(subGroup).addAll(r, staticR);\n+        r1.setManaged(false);\n@@ -1686,2 +1690,4 @@\n-        assertEquals(50,subGroup.getLayoutBounds().getWidth(), 1e-10);\n-        assertEquals(50,subGroup.getLayoutBounds().getHeight(), 1e-10);\n+        \/\/ Assert expected initial state:\n+        assertLayoutFlags(group, LayoutFlags.NEEDS_LAYOUT, LayoutFlags.NEEDS_LAYOUT);\n+        assertEquals(50, group.getLayoutBounds().getWidth());\n+        assertEquals(50, group.getLayoutBounds().getHeight());\n@@ -1689,1 +1695,12 @@\n-        r.setLayoutX(50);\n+        root.layout();\n+\n+        \/\/ Assert everything is clean after layout:\n+        assertLayoutFlags(group, LayoutFlags.CLEAN, LayoutFlags.CLEAN);\n+        assertEquals(50, group.getLayoutBounds().getWidth());\n+        assertEquals(50, group.getLayoutBounds().getHeight());\n+\n+        \/\/ Test for Layout X change:\n+        r1.setLayoutX(50);\n+\n+        \/\/ Assert layout is required:\n+        assertLayoutFlags(group, LayoutFlags.NEEDS_LAYOUT, LayoutFlags.CLEAN);\n@@ -1691,1 +1708,1 @@\n-        rootGroup.layout();\n+        root.layout();\n@@ -1693,2 +1710,4 @@\n-        assertEquals(100,subGroup.getLayoutBounds().getWidth(), 1e-10);\n-        assertEquals(50,subGroup.getLayoutBounds().getHeight(), 1e-10);\n+        \/\/ Assert that all is clean, and the change has been applied:\n+        assertLayoutFlags(group, LayoutFlags.CLEAN, LayoutFlags.CLEAN);\n+        assertEquals(100, group.getLayoutBounds().getWidth());\n+        assertEquals(50, group.getLayoutBounds().getHeight());\n@@ -1696,0 +1715,12 @@\n+        \/\/ Test for Layout Y change:\n+        r1.setLayoutY(40);\n+\n+        \/\/ Assert layout is required:\n+        assertLayoutFlags(group, LayoutFlags.NEEDS_LAYOUT, LayoutFlags.CLEAN);\n+\n+        root.layout();\n+\n+        \/\/ Assert that all is clean, and the change has been applied:\n+        assertLayoutFlags(group, LayoutFlags.CLEAN, LayoutFlags.CLEAN);\n+        assertEquals(100, group.getLayoutBounds().getWidth());\n+        assertEquals(90, group.getLayoutBounds().getHeight());\n@@ -1699,7 +1730,4 @@\n-    public void testLayoutXYWontBreakLayout() {\n-        final Group rootGroup = new Group();\n-        final AnchorPane pane = new AnchorPane();\n-        ParentShim.getChildren(rootGroup).add(pane);\n-\n-        Rectangle r = new Rectangle(50,50);\n-        ParentShim.getChildren(pane).add(r);\n+    public void testLayoutXYWillRelayoutAndUndoChangesToManagedChild() {\n+        Rectangle r = new Rectangle(50, 50);\n+        AnchorPane pane = new AnchorPane(r);\n+        Group root = new Group(pane);\n@@ -1710,1 +1738,12 @@\n-        rootGroup.layout();\n+        \/\/ Assert expected initial state:\n+        assertLayoutFlags(pane, LayoutFlags.NEEDS_LAYOUT, LayoutFlags.NEEDS_LAYOUT);\n+\n+        root.layout();\n+\n+        \/\/ Assert everything is clean after layout:\n+        assertLayoutFlags(pane, LayoutFlags.DIRTY_BRANCH, LayoutFlags.CLEAN);\n+        assertEquals(10, r.getLayoutX());\n+        assertEquals(10, r.getLayoutY());\n+\n+        \/\/ Note: above we expected all to be clean, but code in width\/height change listeners interferes\n+        \/\/ and draws the wrong conclusions. Relayout and reassert should fix this harmless situation:\n@@ -1712,2 +1751,1 @@\n-        assertEquals(10, r.getLayoutX(), 1e-10);\n-        assertEquals(10, r.getLayoutY(), 1e-10);\n+        root.layout();\n@@ -1715,0 +1753,6 @@\n+        \/\/ Assert everything is clean after layout:\n+        assertLayoutFlags(pane, LayoutFlags.CLEAN, LayoutFlags.CLEAN);\n+        assertEquals(10, r.getLayoutX());\n+        assertEquals(10, r.getLayoutY());\n+\n+        \/\/ Test for Layout X change:\n@@ -1717,2 +1761,14 @@\n-        assertEquals(50, r.getLayoutX(), 1e-10);\n-        assertEquals(10, r.getLayoutY(), 1e-10);\n+        \/\/ Assert layout is required:\n+        assertLayoutFlags(pane, LayoutFlags.NEEDS_LAYOUT, LayoutFlags.NEEDS_LAYOUT);\n+        assertEquals(50, r.getLayoutX());\n+        assertEquals(10, r.getLayoutY());\n+\n+        root.layout();\n+\n+        \/\/ Assert that all is clean, and the change has been reverted:\n+        assertLayoutFlags(pane, LayoutFlags.CLEAN, LayoutFlags.CLEAN);\n+        assertEquals(10, r.getLayoutX());\n+        assertEquals(10, r.getLayoutY());\n+\n+        \/\/ Test for Layout Y change:\n+        r.setLayoutY(40);\n@@ -1720,1 +1776,4 @@\n-        rootGroup.layout();\n+        \/\/ Assert layout is required:\n+        assertLayoutFlags(pane, LayoutFlags.NEEDS_LAYOUT, LayoutFlags.NEEDS_LAYOUT);\n+        assertEquals(10, r.getLayoutX());\n+        assertEquals(40, r.getLayoutY());\n@@ -1722,2 +1781,1 @@\n-        assertEquals(10, r.getLayoutX(), 1e-10);\n-        assertEquals(10, r.getLayoutY(), 1e-10);\n+        root.layout();\n@@ -1725,0 +1783,37 @@\n+        \/\/ Assert that all is clean, and the change has been reverted:\n+        assertLayoutFlags(pane, LayoutFlags.CLEAN, LayoutFlags.CLEAN);\n+        assertEquals(10, r.getLayoutX());\n+        assertEquals(10, r.getLayoutY());\n+    }\n+\n+    @Test\n+    public void shouldOnlyDoSingleLayoutPass() {\n+        Rectangle r = new Rectangle(50, 50);\n+        AnchorPane pane = new AnchorPane(r);\n+        HBox root = new HBox(pane);\n+\n+        AnchorPane.setLeftAnchor(r, 10d);\n+        AnchorPane.setTopAnchor(r, 10d);\n+\n+        \/\/ Assert expected initial state:\n+        assertLayoutFlags(pane, LayoutFlags.NEEDS_LAYOUT, LayoutFlags.NEEDS_LAYOUT);\n+\n+        root.layout();\n+\n+        \/*\n+         * Note: we really expect the layout graph to be \"CLEAN\" after this, however\n+         * there is logic for the width\/height fields that currently is a bit too\n+         * eager (and in this situation doesn't set the flags correct either, but\n+         * its relatively harmless). We assert it below, but if this ever changes,\n+         * these asserts can be removed:\n+         *\/\n+\n+        assertLayoutFlags(pane, LayoutFlags.DIRTY_BRANCH, LayoutFlags.CLEAN);\n+        assertEquals(10, r.getLayoutX());\n+        assertEquals(10, r.getLayoutY());\n+        root.layout();  \/\/ this should \"correct\" the harmless intermediate state\n+\n+        \/\/ Assert expected final state:\n+        assertLayoutFlags(pane, LayoutFlags.CLEAN, LayoutFlags.CLEAN);\n+        assertEquals(10, r.getLayoutX());\n+        assertEquals(10, r.getLayoutY());\n@@ -2138,0 +2233,9 @@\n+\n+    private static void assertLayoutFlags(Parent leaf, LayoutFlags... flags) {\n+        List<Parent> subtree = Stream.iterate(leaf, Objects::nonNull, Parent::getParent).toList().reversed();\n+\n+        for (int i = 0; i < subtree.size(); i++) {\n+            Parent p = subtree.get(i);\n+            assertEquals(flags[i], ParentShim.getLayoutFlag(p), \"\" + p);\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/NodeTest.java","additions":133,"deletions":29,"binary":false,"changes":162,"status":"modified"}]}