{"files":[{"patch":"@@ -31,0 +31,5 @@\n+\t<classpathentry combineaccessrules=\"false\" kind=\"src\" path=\"\/media\">\n+\t\t<attributes>\n+\t\t\t<attribute name=\"module\" value=\"true\"\/>\n+\t\t<\/attributes>\n+\t<\/classpathentry>\n","filename":"tests\/system\/src\/test\/.classpath","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,0 +42,4 @@\n+import javafx.collections.ObservableList;\n+import javafx.geometry.HPos;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Orientation;\n@@ -43,0 +47,1 @@\n+import javafx.geometry.Point3D;\n@@ -44,0 +49,1 @@\n+import javafx.geometry.Rectangle2D;\n@@ -45,0 +51,4 @@\n+import javafx.geometry.VPos;\n+import javafx.scene.AmbientLight;\n+import javafx.scene.DirectionalLight;\n+import javafx.scene.Group;\n@@ -46,0 +56,3 @@\n+import javafx.scene.ParallelCamera;\n+import javafx.scene.PerspectiveCamera;\n+import javafx.scene.PointLight;\n@@ -64,0 +77,2 @@\n+import javafx.scene.control.ButtonBar;\n+import javafx.scene.control.ButtonBar.ButtonData;\n@@ -70,0 +85,1 @@\n+import javafx.scene.control.DialogPane;\n@@ -77,0 +93,1 @@\n+import javafx.scene.control.ProgressIndicator;\n@@ -79,0 +96,1 @@\n+import javafx.scene.control.Separator;\n@@ -98,0 +116,1 @@\n+import javafx.scene.control.skin.ButtonBarSkin;\n@@ -109,0 +128,1 @@\n+import javafx.scene.control.skin.ProgressIndicatorSkin;\n@@ -111,0 +131,1 @@\n+import javafx.scene.control.skin.SeparatorSkin;\n@@ -122,0 +143,4 @@\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+import javafx.scene.layout.AnchorPane;\n+import javafx.scene.layout.Background;\n@@ -124,0 +149,4 @@\n+import javafx.scene.layout.FlowPane;\n+import javafx.scene.layout.GridPane;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.layout.Pane;\n@@ -125,0 +154,2 @@\n+import javafx.scene.layout.StackPane;\n+import javafx.scene.layout.TilePane;\n@@ -126,0 +157,1 @@\n+import javafx.scene.media.MediaView;\n@@ -127,0 +159,36 @@\n+import javafx.scene.paint.PhongMaterial;\n+import javafx.scene.shape.Arc;\n+import javafx.scene.shape.ArcTo;\n+import javafx.scene.shape.ArcType;\n+import javafx.scene.shape.Box;\n+import javafx.scene.shape.Circle;\n+import javafx.scene.shape.ClosePath;\n+import javafx.scene.shape.CubicCurve;\n+import javafx.scene.shape.CubicCurveTo;\n+import javafx.scene.shape.CullFace;\n+import javafx.scene.shape.Cylinder;\n+import javafx.scene.shape.DrawMode;\n+import javafx.scene.shape.Ellipse;\n+import javafx.scene.shape.FillRule;\n+import javafx.scene.shape.HLineTo;\n+import javafx.scene.shape.Line;\n+import javafx.scene.shape.LineTo;\n+import javafx.scene.shape.Mesh;\n+import javafx.scene.shape.MeshView;\n+import javafx.scene.shape.MoveTo;\n+import javafx.scene.shape.Path;\n+import javafx.scene.shape.PathElement;\n+import javafx.scene.shape.Polygon;\n+import javafx.scene.shape.Polyline;\n+import javafx.scene.shape.QuadCurve;\n+import javafx.scene.shape.QuadCurveTo;\n+import javafx.scene.shape.Rectangle;\n+import javafx.scene.shape.SVGPath;\n+import javafx.scene.shape.Shape;\n+import javafx.scene.shape.Shape3D;\n+import javafx.scene.shape.Sphere;\n+import javafx.scene.shape.StrokeLineCap;\n+import javafx.scene.shape.StrokeLineJoin;\n+import javafx.scene.shape.StrokeType;\n+import javafx.scene.shape.TriangleMesh;\n+import javafx.scene.shape.VLineTo;\n@@ -134,0 +202,1 @@\n+import org.junit.jupiter.api.MethodOrderer;\n@@ -135,0 +204,1 @@\n+import org.junit.jupiter.api.TestMethodOrder;\n@@ -153,4 +223,0 @@\n- *\n- * NOTE: I suspect this test might be a bit unstable and\/or platform-dependent, due to its multi-threaded nature.\n- *\n- * TODO add remaining Nodes to the test.\n@@ -158,0 +224,1 @@\n+@TestMethodOrder(MethodOrderer.MethodName.class)\n@@ -159,0 +226,3 @@\n+    \/* debugging aid: set this flag to true and comment out assumeFalse(SKIP_TEST) to run specific test(s). *\/\n+    private static final boolean SKIP_TEST = false;\n+    \/** Determines the amount of time background threads are active during each test. *\/\n@@ -162,3 +232,1 @@\n-    \/\/ for debugging purposes: setting this to true will skip working tests\n-    \/\/ TODO remove once all the tests pass\n-    private static final boolean SKIP_TEST = false;\n+    private static final ThreadLocal<Random> random = ThreadLocal.withInitial(Random::new);\n@@ -182,0 +250,41 @@\n+    @Test\n+    public void anchorPane() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new AnchorPane();\n+        }, (c) -> {\n+            accessPane(c, (n) -> {\n+                AnchorPane.setLeftAnchor(n, nextDouble(100));\n+            });\n+        });\n+    }\n+\n+    @Test\n+    public void ambientLight() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new AmbientLight();\n+        }, (c) -> {\n+            accessNode(c);\n+            c.setColor(nextColor());\n+            c.setLightOn(nextBoolean());\n+        });\n+    }\n+\n+    @Test\n+    public void arc() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new Arc();\n+        }, (c) -> {\n+            accessShape(c);\n+            c.setCenterX(nextDouble(100));\n+            c.setCenterY(nextDouble(100));\n+            c.setLength(nextDouble(100));\n+            c.setRadiusX(nextDouble(100));\n+            c.setRadiusY(nextDouble(100));\n+            c.setStartAngle(nextDouble(720));\n+            c.setType(nextEnum(ArcType.class));\n+        });\n+    }\n+\n@@ -210,0 +319,26 @@\n+    @Test\n+    public void borderPane() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new BorderPane();\n+        }, (c) -> {\n+            Node n = createNode();\n+            c.setCenter(n);\n+            BorderPane.setAlignment(n, nextEnum(Pos.class));\n+            accessNode(c);\n+        });\n+    }\n+\n+    @Test\n+    public void box() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new Box();\n+        }, (c) -> {\n+            accessShape3D(c);\n+            c.setDepth(nextDouble(100));\n+            c.setHeight(nextDouble(100));\n+            c.setWidth(nextDouble(100));\n+        });\n+    }\n+\n@@ -239,0 +374,24 @@\n+    @Test\n+    public void buttonBar() {\n+        assumeFalse(SKIP_TEST);\n+        String[] buttonOrders = {\n+            ButtonBar.BUTTON_ORDER_LINUX,\n+            ButtonBar.BUTTON_ORDER_MAC_OS,\n+            ButtonBar.BUTTON_ORDER_NONE,\n+            ButtonBar.BUTTON_ORDER_WINDOWS\n+        };\n+        test(() -> {\n+            ButtonBar c = new ButtonBar();\n+            c.setSkin(new ButtonBarSkin(c));\n+            return c;\n+        }, (c) -> {\n+            accessControl(c);\n+            c.setButtonMinWidth(10 + nextDouble(100));\n+            c.setButtonOrder(nextItem(buttonOrders));\n+            ButtonData d = nextItem(ButtonData.values());\n+            Button b = new Button(d.toString());\n+            ButtonBar.setButtonData(b, d);\n+            c.getButtons().setAll(b);\n+        });\n+    }\n+\n@@ -282,0 +441,13 @@\n+    @Test\n+    public void circle() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new Circle();\n+        }, (c) -> {\n+            accessShape(c);\n+            c.setCenterX(nextDouble(100));\n+            c.setCenterY(nextDouble(100));\n+            c.setRadius(nextDouble(100));\n+        });\n+    }\n+\n@@ -291,1 +463,0 @@\n-            c.show(); \/\/ does not fail here, unlike DatePicker?\n@@ -297,0 +468,7 @@\n+            if (Platform.isFxApplicationThread()) {\n+                if (nextBoolean()) {\n+                    c.show();\n+                } else {\n+                    c.hide();\n+                }\n+            }\n@@ -313,1 +491,37 @@\n-            c.show(); \/\/ does not fail here\n+            if (Platform.isFxApplicationThread()) {\n+                if (nextBoolean()) {\n+                    c.show();\n+                } else {\n+                    c.hide();\n+                }\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void cubicCurve() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new CubicCurve();\n+        }, (c) -> {\n+            accessShape(c);\n+            c.setControlX1(nextDouble(100));\n+            c.setControlX2(nextDouble(100));\n+            c.setControlY1(nextDouble(100));\n+            c.setControlY2(nextDouble(100));\n+            c.setEndX(nextDouble(100));\n+            c.setEndY(nextDouble(100));\n+            c.setStartX(nextDouble(100));\n+            c.setStartY(nextDouble(100));\n+        });\n+    }\n+\n+    @Test\n+    public void cylinder() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new Cylinder();\n+        }, (c) -> {\n+            accessShape3D(c);\n+            c.setHeight(nextDouble(100));\n+            c.setRadius(nextDouble(100));\n@@ -317,1 +531,0 @@\n-    @Disabled(\"JDK-8349004\") \/\/ FIX\n@@ -326,1 +539,0 @@\n-            c.show(); \/\/ fails here\n@@ -332,0 +544,95 @@\n+            if (Platform.isFxApplicationThread()) {\n+                if (nextBoolean()) {\n+                    c.show();\n+                } else {\n+                    c.hide();\n+                }\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void dialogPane() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new DialogPane();\n+        }, (c) -> {\n+            c.setContent(createNode());\n+            c.setGraphic(createNode());\n+            c.setExpandableContent(createNode());\n+            c.setExpanded(nextBoolean());\n+            accessNode(c);\n+        });\n+    }\n+\n+    @Test\n+    public void directionalLight() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new DirectionalLight();\n+        }, (c) -> {\n+            c.setColor(nextColor());\n+            c.setLightOn(nextBoolean());\n+            Point3D p = new Point3D(nextDouble(100), nextDouble(100), nextDouble(100));\n+            c.setDirection(p);\n+        });\n+    }\n+\n+    @Test\n+    public void ellipse() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new Ellipse();\n+        }, (c) -> {\n+            accessShape(c);\n+            c.setCenterX(nextDouble(100));\n+            c.setCenterY(nextDouble(100));\n+            c.setRadiusX(nextDouble(100));\n+            c.setRadiusY(nextDouble(100));\n+        });\n+    }\n+\n+    @Test\n+    public void flowPane() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new FlowPane();\n+        }, (c) -> {\n+            accessPane(c, (n) -> {\n+                FlowPane.setMargin(n, new Insets(nextDouble(30)));\n+            });\n+        });\n+    }\n+\n+    @Test\n+    public void gridPane() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new GridPane();\n+        }, (c) -> {\n+            accessPane(c, (n) -> {\n+                GridPane.setMargin(n, new Insets(nextDouble(30)));\n+            });\n+        });\n+    }\n+\n+    @Test\n+    public void group() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new Group();\n+        }, (c) -> {\n+            accessNode(c);\n+            c.getChildren().setAll(createNodes());\n+        });\n+    }\n+\n+    @Test\n+    public void hbox() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new HBox();\n+        }, (c) -> {\n+            accessPane(c, (n) -> {\n+                HBox.setMargin(n, new Insets(nextDouble(30)));\n+            });\n@@ -348,0 +655,18 @@\n+    @Test\n+    public void imageView() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new ImageView();\n+        }, (c) -> {\n+            accessNode(c);\n+            c.setFitHeight(nextDouble(200));\n+            c.setFitWidth(nextDouble(200));\n+            c.setImage(nextImage());\n+            c.setPreserveRatio(nextBoolean());\n+            c.setSmooth(nextBoolean());\n+            c.setViewport(new Rectangle2D(nextDouble(100), nextDouble(100), nextDouble(100), nextDouble(100)));\n+            c.setX(nextDouble(100));\n+            c.setY(nextDouble(100));\n+        });\n+    }\n+\n@@ -361,0 +686,14 @@\n+    @Test\n+    public void line() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new Line();\n+        }, (c) -> {\n+            accessShape(c);\n+            c.setEndX(nextDouble(100));\n+            c.setEndY(nextDouble(100));\n+            c.setStartX(nextDouble(100));\n+            c.setStartY(nextDouble(100));\n+        });\n+    }\n+\n@@ -389,1 +728,18 @@\n-    @Disabled(\"JDK-8349096\") \/\/ FIX\n+    @Test\n+    public void mediaView() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new MediaView();\n+        }, (c) -> {\n+            accessNode(c);\n+            c.setFitHeight(nextDouble(200));\n+            c.setFitWidth(nextDouble(200));\n+            \/\/c.setMediaPlayer(new MediaPlayer(new Media(\"no-data-url-support\")));\n+            c.setPreserveRatio(nextBoolean());\n+            c.setSmooth(nextBoolean());\n+            c.setViewport(new Rectangle2D(nextDouble(100), nextDouble(100), nextDouble(100), nextDouble(100)));\n+            c.setX(nextDouble(100));\n+            c.setY(nextDouble(100));\n+        });\n+    }\n+\n@@ -399,1 +755,1 @@\n-            c.setPopupSide(Side.RIGHT);\n+            c.setPopupSide(nextEnum(Side.class));\n@@ -401,1 +757,18 @@\n-            c.show();\n+            if (Platform.isFxApplicationThread()) {\n+                if (nextBoolean()) {\n+                    c.show();\n+                } else {\n+                    c.hide();\n+                }\n+            }\n+        });\n+    }\n+\n+    @Test\n+    public void meshView() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new MeshView();\n+        }, (c) -> {\n+            accessShape3D(c);\n+            c.setMesh(createMesh());\n@@ -423,0 +796,37 @@\n+    @Test\n+    public void pane() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new Pane();\n+        }, (c) -> {\n+            c.getChildren().setAll(createNodes());\n+            accessRegion(c);\n+        });\n+    }\n+\n+    @Test\n+    public void parallelCamera() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new ParallelCamera();\n+        }, (c) -> {\n+            accessNode(c);\n+            double near = nextDouble(100);\n+            c.setFarClip(near + nextDouble(100));\n+            c.setNearClip(near);\n+        });\n+    }\n+\n+    @Test\n+    public void path() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new Path();\n+        }, (c) -> {\n+            accessShape(c);\n+            c.getElements().setAll(createPathElements());\n+            c.getElements().setAll(createPathElements());\n+            c.setFillRule(nextEnum(FillRule.class));\n+        });\n+    }\n+\n@@ -437,0 +847,15 @@\n+    @Test\n+    public void perspectiveCamera() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new PerspectiveCamera();\n+        }, (c) -> {\n+            accessNode(c);\n+            double near = nextDouble(100);\n+            c.setFarClip(near + nextDouble(100));\n+            c.setNearClip(near);\n+            c.setFieldOfView(nextDouble(360));\n+            c.setVerticalFieldOfView(nextBoolean());\n+        });\n+    }\n+\n@@ -451,0 +876,85 @@\n+    @Test\n+    public void pointLight() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new PointLight();\n+        }, (c) -> {\n+            accessNode(c);\n+            c.setColor(nextColor());\n+            c.setLightOn(nextBoolean());\n+            c.setConstantAttenuation(nextDouble(10));\n+            c.setLinearAttenuation(nextDouble(32));\n+            c.setMaxRange(nextDouble(1000));\n+            c.setQuadraticAttenuation(nextDouble(1000));\n+        });\n+    }\n+\n+    @Test\n+    public void polygon() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new Polygon();\n+        }, (c) -> {\n+            accessShape(c);\n+            c.getPoints().setAll(createPoints());\n+            c.getPoints().setAll(createPoints());\n+        });\n+    }\n+\n+    @Test\n+    public void polyline() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new Polyline();\n+        }, (c) -> {\n+            accessShape(c);\n+            c.getPoints().setAll(createPoints());\n+            c.getPoints().setAll(createPoints());\n+        });\n+    }\n+\n+    @Test\n+    public void progressIndicator() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            ProgressIndicator c = new ProgressIndicator();\n+            c.setSkin(new ProgressIndicatorSkin(c));\n+            return c;\n+        }, (c) -> {\n+            accessControl(c);\n+            c.setProgress(nextBoolean() ? -1 : nextDouble(1));\n+        });\n+    }\n+\n+    @Test\n+    public void quadCurve() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new QuadCurve();\n+        }, (c) -> {\n+            accessShape(c);\n+            c.setControlX(nextDouble(100));\n+            c.setControlY(nextDouble(100));\n+            c.setEndX(nextDouble(100));\n+            c.setEndY(nextDouble(100));\n+            c.setStartX(nextDouble(100));\n+            c.setStartY(nextDouble(100));\n+        });\n+    }\n+\n+    @Test\n+    public void rectangle() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new Rectangle();\n+        }, (c) -> {\n+            accessShape(c);\n+            c.setArcHeight(nextDouble(10));\n+            c.setArcWidth(nextDouble(10));\n+            c.setHeight(nextDouble(100));\n+            c.setWidth(nextDouble(100));\n+            c.setX(nextDouble(100));\n+            c.setY(nextDouble(100));\n+        });\n+    }\n+\n@@ -464,0 +974,10 @@\n+    @Test\n+    public void region() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new Region();\n+        }, (c) -> {\n+            accessRegion(c);\n+        });\n+    }\n+\n@@ -491,0 +1011,26 @@\n+    @Test\n+    public void separator() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            Separator c = new Separator();\n+            c.setSkin(new SeparatorSkin(c));\n+            return c;\n+        }, (c) -> {\n+            accessControl(c);\n+            c.setOrientation(nextBoolean() ? Orientation.VERTICAL : Orientation.HORIZONTAL);\n+            c.setHalignment(nextEnum(HPos.class));\n+            c.setValignment(nextEnum(VPos.class));\n+        });\n+    }\n+\n+    @Test\n+    public void sphere() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new Sphere();\n+        }, (c) -> {\n+            accessShape3D(c);\n+            c.setRadius(nextDouble(100));\n+        });\n+    }\n+\n@@ -505,1 +1051,0 @@\n-    @Disabled(\"JDK-8349096\") \/\/ FIX\n@@ -515,1 +1060,1 @@\n-            c.setPopupSide(Side.RIGHT);\n+            c.setPopupSide(nextEnum(Side.class));\n@@ -517,1 +1062,7 @@\n-            c.show();\n+            if (Platform.isFxApplicationThread()) {\n+                if (nextBoolean()) {\n+                    c.show();\n+                } else {\n+                    c.hide();\n+                }\n+            }\n@@ -549,0 +1100,34 @@\n+    @Test\n+    public void stackPane() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new StackPane();\n+        }, (c) -> {\n+            accessPane(c, (n) -> {\n+                StackPane.setMargin(n, new Insets(nextDouble(30)));\n+            });\n+        });\n+    }\n+\n+    @Test\n+    public void svgPath() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new SVGPath();\n+        }, (c) -> {\n+            accessShape(c);\n+            c.setContent(createSvgPath());\n+            c.setFillRule(nextEnum(FillRule.class));\n+        });\n+    }\n+\n+    \/\/@Test disabled because it times out\n+    public void swingNode() {\n+        \/\/assumeFalse(SKIP_TEST);\n+\/\/        test(() -> {\n+\/\/            return new SwingNode();\n+\/\/        }, (c) -> {\n+\/\/            accessNode(c);\n+\/\/        });\n+    }\n+\n@@ -634,0 +1219,12 @@\n+    @Test\n+    public void tilePane() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new TilePane();\n+        }, (c) -> {\n+            accessPane(c, (n) -> {\n+                TilePane.setMargin(n, new Insets(nextDouble(30)));\n+            });\n+        });\n+    }\n+\n@@ -753,1 +1350,13 @@\n-    private void accessTextInputControl(TextInputControl c) {\n+    @Test\n+    public void vbox() {\n+        assumeFalse(SKIP_TEST);\n+        test(() -> {\n+            return new VBox();\n+        }, (c) -> {\n+            accessPane(c, (n) -> {\n+                VBox.setMargin(n, new Insets(nextDouble(30)));\n+            });\n+        });\n+    }\n+\n+    private static void accessTextInputControl(TextInputControl c) {\n@@ -760,1 +1369,1 @@\n-    private void accessChart(Chart c) {\n+    private static void accessChart(Chart c) {\n@@ -767,1 +1376,1 @@\n-    private void accessControl(Control c) {\n+    private static void accessControl(Control c) {\n@@ -772,1 +1381,1 @@\n-    private void accessNode(Node c) {\n+    private static void accessNode(Node c) {\n@@ -778,1 +1387,12 @@\n-    private void accessRegion(Region c) {\n+    private static void accessPane(Pane p, Consumer<Node> onChild) {\n+        ObservableList<Node> children = p.getChildren();\n+        children.setAll(createNodes());\n+        children.setAll(createNodes());\n+        if (children.size() > 0) {\n+            int ix = random().nextInt(children.size());\n+            Node n = children.get(ix);\n+            onChild.accept(n);\n+        }\n+    }\n+\n+    private static void accessRegion(Region c) {\n@@ -784,0 +1404,24 @@\n+        c.setBackground(Background.fill(nextColor()));\n+    }\n+\n+    private static void accessShape(Shape c) {\n+        c.setFill(nextColor());\n+        c.setSmooth(nextBoolean());\n+        c.setStroke(nextColor());\n+        c.setStrokeDashOffset(nextDouble(10));\n+        c.setStrokeLineCap(nextEnum(StrokeLineCap.class));\n+        c.setStrokeLineJoin(nextEnum(StrokeLineJoin.class));\n+        c.setStrokeMiterLimit(nextDouble(10));\n+        c.setStrokeType(nextEnum(StrokeType.class));\n+        c.setStrokeWidth(nextDouble(10));\n+    }\n+\n+    private static void accessShape3D(Shape3D c) {\n+        c.setCullFace(nextEnum(CullFace.class));\n+        c.setDrawMode(nextEnum(DrawMode.class));\n+        PhongMaterial m = new PhongMaterial();\n+        \/\/m.setSelfIlluminationMap(Image); \/\/ what is expected?\n+        m.setSpecularColor(nextColor());\n+        \/\/m.setSpecularMap(Image); \/\/ what is expected?\n+        m.setSpecularPower(nextDouble(100)); \/\/ what is the acceptable range?\n+        c.setMaterial(m);\n@@ -821,1 +1465,0 @@\n-                    Random r = new Random();\n@@ -823,1 +1466,1 @@\n-                        sleep(1 + r.nextInt(20));\n+                        sleep(1 + random().nextInt(20));\n@@ -861,2 +1504,1 @@\n-        \/\/ creating new Random instances each time to avoid additional synchronization\n-        return new Random().nextBoolean();\n+        return random().nextBoolean();\n@@ -871,1 +1513,1 @@\n-        return new Random().nextDouble() < probability;\n+        return random().nextDouble() < probability;\n@@ -875,2 +1517,6 @@\n-        Random r = new Random();\n-        return Color.hsb(360 * r.nextDouble(), r.nextDouble(), r.nextDouble(), r.nextDouble());\n+        Random r = random();\n+        double hue = 360.0 * r.nextDouble();\n+        double saturation = 0.5 + 0.5 * r.nextDouble();\n+        double brightness = r.nextDouble();\n+        double opacity = r.nextDouble();\n+        return Color.hsb(hue, saturation, brightness, opacity);\n@@ -880,1 +1526,1 @@\n-        return min + new Random().nextDouble() * (max - min);\n+        return min + random().nextDouble() * (max - min);\n@@ -884,1 +1530,18 @@\n-        return max * new Random().nextDouble();\n+        return max * random().nextDouble();\n+    }\n+\n+    private static <T extends Enum> T nextEnum(Class<T> type) {\n+        T[] values = type.getEnumConstants();\n+        return nextItem(values);\n+    }\n+\n+    private static Image nextImage() {\n+        \/\/ cannot generate WriteableImage because it's considered \"animated\" and will\n+        \/\/ throw an exception in ImageView:254\n+        \/\/ Toolkit.getImageAccessor().getImageProperty(_image).addListener(platformImageChangeListener.getWeakListener());\n+        switch(nextInt(2)) {\n+        case 0:\n+            return new Image(\"data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAATklEQVR4XsXIIQEAMAwEsfdvuhNwPAMh2Xb3V0JLaAktoSW0hJbQElpCS2gJLaEltISW0BJaQktoCS2hJbSEltASWkJLaAktoSW0hJawHluV+GpNRXH\/AAAAAElFTkSuQmCC\");\n+        default:\n+            return new Image(\"data:image\/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAWUlEQVR4XsXIoQEAAAyDMP5\/uvMcwERM2NgnHDUcNRw1HDUcNRw1HDUcNRw1HDUcNRw1HDUcNRw1HDUcNRw1HDUcNRw1HDUcNRw1HDUcNRw1HDUcNRw1HLUD9Br0ptaWcFoAAAAASUVORK5CYII=\");\n+        }\n@@ -888,1 +1551,6 @@\n-        return new Random().nextInt(max);\n+        return random().nextInt(max);\n+    }\n+\n+    private static <T> T nextItem(T[] items) {\n+        int ix = nextInt(items.length);\n+        return items[ix];\n@@ -896,0 +1564,4 @@\n+    private static Random random() {\n+        return random.get();\n+    }\n+\n@@ -897,1 +1569,1 @@\n-        int sz = new Random().nextInt(5);\n+        int sz = random().nextInt(5);\n@@ -911,0 +1583,58 @@\n+    private static Mesh createMesh() {\n+        \/\/ see Mouse3DTest\n+        switch (nextInt(4)) {\n+        case 0:\n+            \/\/ meshesXY2\n+            return createMesh(\n+                new float[] { 0f, 0f, 0f, 100f, 0f, 0f, 100f, 100f, 0f, 0f, 0f, -7f, 100f, 0f, -7f, 100f, 100f, -7f },\n+                new float[] { 0f, 0f, 1f, 0f, 1f, 1f },\n+                new int[] { 3, 0, 5, 2, 4, 1, 0, 0, 2, 2, 1, 1 });\n+        case 1:\n+            \/\/ meshesXYFacingEachOther\n+            return createMesh(\n+                new float[] { 0f, 0f, 0f, 100f, 0f, 0f, 100f, 100f, 0f, 0f, 0f, -7f, 100f, 0f, -7f, 100f, 100f, -7f },\n+                new float[] { 0f, 0f, 1f, 0f, 1f, 1f },\n+                new int[] { 0, 0, 2, 2, 1, 1, 3, 0, 4, 1, 5, 2, });\n+        case 2:\n+            \/\/ meshXYBack\n+            return createMesh(\n+                new float[] { 0f, 0f, 7f, 100f, 0f, 7f, 100f, 100f, 7f },\n+                new float[] { 0f, 0f, 1f, 0f, 1f, 1f },\n+                new int[] { 0, 0, 1, 1, 2, 2 });\n+        default:\n+            \/\/ meshXYFlippedTexture\n+            return createMesh(\n+                new float[] { 0f, 0f, 7f, 100f, 0f, 7f, 100f, 100f, 7f },\n+                new float[] { 0f, 0f, 0f, 1f, 1f, 1f },\n+                new int[] { 0, 0, 2, 1, 1, 2 });\n+        }\n+    }\n+\n+    private static Mesh createMesh(float[] points, float[] tex, int[] faces) {\n+        TriangleMesh m = new TriangleMesh();\n+        m.getPoints().setAll(points);\n+        m.getTexCoords().setAll(tex);\n+        m.getFaces().setAll(faces);\n+        return m;\n+    }\n+\n+    private static Node createNode() {\n+        switch (random().nextInt(3)) {\n+        case 0:\n+            return new Text(\"Text\");\n+        case 1:\n+            return new Button(\"Button\");\n+        default:\n+            return new Label(\"Label\");\n+        }\n+    }\n+\n+    private static List<Node> createNodes() {\n+        int sz = random().nextInt(5);\n+        ArrayList<Node> nodes = new ArrayList<>(sz);\n+        for (int i = 0; i < sz; i++) {\n+            nodes.add(createNode());\n+        }\n+        return nodes;\n+    }\n+\n@@ -940,0 +1670,55 @@\n+    private static PathElement createPathElement() {\n+            switch (nextInt(7)) {\n+            case 0:\n+            {\n+                double radiusX = nextDouble(100);\n+                double radiusY = nextDouble(100);\n+                double xAxisRotation = nextDouble(1000);\n+                double x = nextDouble(100);\n+                double y = nextDouble(100);\n+                boolean largeArcFlag = nextBoolean();\n+                boolean sweepFlag = nextBoolean();\n+                return new ArcTo(radiusX, radiusY, xAxisRotation, x, y, largeArcFlag, sweepFlag);\n+            }\n+            case 1:\n+            {\n+                double controlX1 = nextDouble(100);\n+                double controlY1 = nextDouble(100);\n+                double controlX2 = nextDouble(100);\n+                double controlY2 = nextDouble(100);\n+                double x = nextDouble(100);\n+                double y = nextDouble(100);\n+                return new CubicCurveTo(controlX1, controlY1, controlX2, controlY2, x, y);\n+            }\n+            case 2:\n+                return new HLineTo(nextDouble(100));\n+            case 3:\n+                return new LineTo(nextDouble(100), nextDouble(100));\n+            case 4:\n+                return new MoveTo(nextDouble(100), nextDouble(100));\n+            case 5:\n+            {\n+                double controlX = nextDouble(100);\n+                double controlY = nextDouble(100);\n+                double x = nextDouble(100);\n+                double y = nextDouble(100);\n+                return new QuadCurveTo(controlX, controlY, x, y);\n+            }\n+            default:\n+                return new VLineTo(nextDouble(100));\n+        }\n+    }\n+\n+    private static List<PathElement> createPathElements() {\n+        int sz = random().nextInt(5);\n+        ArrayList<PathElement> a = new ArrayList<>(sz);\n+        a.add(new MoveTo(nextDouble(100), nextDouble(100)));\n+        for (int i = 0; i < sz; i++) {\n+            a.add(createPathElement());\n+        }\n+        if (nextBoolean()) {\n+            a.add(new ClosePath());\n+        }\n+        return a;\n+    }\n+\n@@ -941,2 +1726,1 @@\n-        Random rnd = new Random();\n-        int sz = 1 + rnd.nextInt(20);\n+        int sz = 1 + random().nextInt(20);\n@@ -945,1 +1729,11 @@\n-            a.add(new PieChart.Data(\"N\" + i, rnd.nextDouble()));\n+            a.add(new PieChart.Data(\"N\" + i, random().nextDouble()));\n+        }\n+        return a;\n+    }\n+\n+    private static List<Double> createPoints() {\n+        int sz = random().nextInt(8);\n+        ArrayList<Double> a = new ArrayList<>(sz);\n+        for (int i = 0; i < sz; i++) {\n+            a.add(nextDouble(200));\n+            a.add(nextDouble(200));\n@@ -952,1 +1746,1 @@\n-        int sz = new Random().nextInt(20);\n+        int sz = random().nextInt(20);\n@@ -960,0 +1754,17 @@\n+    private static String createSvgPath() {\n+        switch(nextInt(4)) {\n+        case 0:\n+            \/\/ Arc\n+            return \"M 5 310 L 100 210 A 25 45 0 0 1 162 164 L 175 155 A 35 45 -40 0 1 210 110 L 310 10\";\n+        case 1:\n+            \/\/ BÃ©zier\n+            return \"M 10 70 C 30 20, 75 15, 90 85 S 140 145, 185 75 T 180 80\";\n+        case 2:\n+            \/\/ quadratic\n+            return \"M 10 80 Q 52.5 10, 95 80 T 180 80\";\n+        default:\n+            \/\/ vertical\/horizontal\n+            return \"M 0 0 H 100 V 100 H 0 L 0 0\";\n+        }\n+    }\n+\n@@ -969,1 +1780,1 @@\n-        int sz = new Random().nextInt(20);\n+        int sz = random().nextInt(20);\n@@ -978,1 +1789,1 @@\n-        int sz = new Random().nextInt(20);\n+        int sz = random().nextInt(20);\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/NodeInitializationStressTest.java","additions":850,"deletions":39,"binary":false,"changes":889,"status":"modified"}]}