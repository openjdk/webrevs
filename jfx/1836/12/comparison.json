{"files":[{"patch":"@@ -2166,2 +2166,1 @@\n-            systemProperty 'glass.platform', 'Monocle'\n-            systemProperty 'monocle.platform', 'Headless'\n+            systemProperty 'glass.platform', 'Headless'\n@@ -3858,2 +3857,1 @@\n-        systemProperty 'glass.platform', 'Monocle'\n-        systemProperty 'monocle.platform', 'Headless'\n+        systemProperty 'glass.platform', 'Headless'\n","filename":"build.gradle","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2025, Gluon. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.events.KeyEvent;\n+import com.sun.glass.ui.Application;\n+import com.sun.glass.ui.CommonDialogs;\n+import com.sun.glass.ui.Cursor;\n+import com.sun.glass.ui.GlassRobot;\n+import com.sun.glass.ui.Pixels;\n+import com.sun.glass.ui.Screen;\n+import com.sun.glass.ui.Size;\n+import com.sun.glass.ui.Timer;\n+import com.sun.glass.ui.View;\n+import com.sun.glass.ui.Window;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+\n+public class HeadlessApplication extends Application {\n+\n+    private final NestedRunnableProcessor processor = new NestedRunnableProcessor();\n+    private final HeadlessWindowManager windowManager = new HeadlessWindowManager();\n+    private Screen[] screens;\n+    private HeadlessRobot activeRobot = null;\n+    ByteBuffer frameBuffer;\n+\n+    private static final int MULTICLICK_MAX_X = 20;\n+    private static final int MULTICLICK_MAX_Y = 20;\n+    private static final long MULTICLICK_TIME = 500;\n+\n+    @Override\n+    protected void runLoop(Runnable launchable) {\n+        processor.invokeLater(launchable);\n+        Thread eventThread = new Thread(processor);\n+        setEventThread(eventThread);\n+        eventThread.start();\n+    }\n+\n+    @Override\n+    protected void _invokeAndWait(Runnable runnable) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected void _invokeLater(Runnable runnable) {\n+        processor.invokeLater(runnable);\n+    }\n+\n+    @Override\n+    protected Object _enterNestedEventLoop() {\n+        return processor.newRunLoop();\n+    }\n+\n+    @Override\n+    protected void _leaveNestedEventLoop(Object retValue) {\n+        processor.leaveCurrentLoop(retValue);\n+    }\n+\n+    @Override\n+    protected int _isKeyLocked(int keyCode) {\n+        return KeyEvent.KEY_LOCK_OFF;\n+    }\n+\n+    @Override\n+    public Window createWindow(Window owner, Screen screen, int styleMask) {\n+        HeadlessWindow window = new HeadlessWindow(windowManager, owner, screen, frameBuffer, styleMask);\n+        if (this.activeRobot != null) {\n+            activeRobot.windowAdded(window);\n+            window.setRobot(this.activeRobot);\n+        }\n+        return window;\n+    }\n+\n+    @Override\n+    public View createView() {\n+        return new HeadlessView();\n+    }\n+\n+    @Override\n+    public Cursor createCursor(int type) {\n+        return new HeadlessCursor(type);\n+    }\n+\n+    @Override\n+    public Cursor createCursor(int x, int y, Pixels pixels) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected void staticCursor_setVisible(boolean visible) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected Size staticCursor_getBestSize(int width, int height) {\n+        return new Size(16, 16);\n+    }\n+\n+    @Override\n+    public Pixels createPixels(int width, int height, ByteBuffer data) {\n+        return new HeadlessPixels(width, height, data);\n+    }\n+\n+    @Override\n+    public Pixels createPixels(int width, int height, ByteBuffer data, float scalex, float scaley) {\n+        return new HeadlessPixels(width, height, data, scalex, scaley);\n+    }\n+\n+    @Override\n+    public Pixels createPixels(int width, int height, IntBuffer data) {\n+        return new HeadlessPixels(width, height, data);\n+    }\n+\n+    @Override\n+    public Pixels createPixels(int width, int height, IntBuffer data, float scalex, float scaley) {\n+        return new HeadlessPixels(width, height, data, scalex, scaley);\n+    }\n+\n+    @Override\n+    protected int staticPixels_getNativeFormat() {\n+        return Pixels.Format.BYTE_BGRA_PRE;\n+    }\n+\n+    @Override\n+    public GlassRobot createRobot() {\n+        this.activeRobot = new HeadlessRobot(this);\n+        return this.activeRobot;\n+    }\n+\n+    @Override\n+    protected double staticScreen_getVideoRefreshPeriod() {\n+        return 0.;\n+    }\n+\n+    @Override\n+    protected Screen[] staticScreen_getScreens() {\n+        final int screenWidth = 1000;\n+        final int screenHeight = 1000;\n+        if (this.screens == null) {\n+            float scaleX = 1.f;\n+            float scaleY = 1.f;\n+            Screen screen = new Screen(0, 32, 0, 0, screenWidth, screenHeight, 0, 0, screenWidth, screenHeight, 0, 0, screenWidth, screenHeight, 100, 100, 1f, 1f, scaleX, scaleY);\n+            this.screens = new Screen[1];\n+            this.screens[0] = screen;\n+            this.frameBuffer = ByteBuffer.allocate(screen.getWidth() * screen.getHeight() * 4);\n+        }\n+        return this.screens;\n+    }\n+\n+    @Override\n+    public Timer createTimer(Runnable runnable) {\n+        return new HeadlessTimer(runnable);\n+    }\n+\n+    @Override\n+    protected int staticTimer_getMinPeriod() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected int staticTimer_getMaxPeriod() {\n+        return 1_000_000;\n+    }\n+\n+    @Override\n+    protected CommonDialogs.FileChooserResult staticCommonDialogs_showFileChooser(Window owner, String folder, String filename, String title, int type,\n+            boolean multipleMode, CommonDialogs.ExtensionFilter[] extensionFilters, int defaultFilterIndex) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected File staticCommonDialogs_showFolderChooser(Window owner, String folder, String title) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected long staticView_getMultiClickTime() {\n+        return MULTICLICK_TIME;\n+    }\n+\n+    @Override\n+    protected int staticView_getMultiClickMaxX() {\n+        return MULTICLICK_MAX_X;\n+    }\n+\n+    @Override\n+    protected int staticView_getMultiClickMaxY() {\n+        return MULTICLICK_MAX_Y;\n+    }\n+\n+    @Override\n+    protected boolean _supportsTransparentWindows() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean _supportsUnifiedWindows() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean _supportsExtendedWindows() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected int _getKeyCodeForChar(char c, int hint) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessApplication.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Gluon. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.ui.Cursor;\n+import com.sun.glass.ui.Pixels;\n+\n+public class HeadlessCursor extends Cursor {\n+\n+     HeadlessCursor(int type) {\n+        super(type);\n+    }\n+\n+    @Override\n+    protected long _createCursor(int x, int y, Pixels pixels) {\n+        return 1;\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessCursor.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Gluon. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.ui.Pixels;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+\n+public class HeadlessPixels extends Pixels {\n+\n+    HeadlessPixels(int width, int height, ByteBuffer data) {\n+        super(width, height, data);\n+    }\n+\n+    HeadlessPixels(int width, int height, ByteBuffer data, float scalex, float scaley) {\n+        super(width, height, data, scalex, scaley);\n+    }\n+\n+    HeadlessPixels(int width, int height, IntBuffer data) {\n+        super(width, height, data);\n+    }\n+\n+    HeadlessPixels(int width, int height, IntBuffer data, float scalex, float scaley) {\n+        super(width, height, data, scalex, scaley);\n+    }\n+\n+    @Override\n+    protected void _fillDirectByteBuffer(ByteBuffer bb) {\n+        bb.put(this.bytes);\n+    }\n+\n+    @Override\n+    protected void _attachInt(long ptr, int w, int h, IntBuffer ints, int[] array, int offset) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected void _attachByte(long ptr, int w, int h, ByteBuffer bytes, byte[] array, int offset) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessPixels.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025, Gluon. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.ui.Application;\n+import com.sun.glass.ui.Clipboard;\n+import com.sun.glass.ui.Menu;\n+import com.sun.glass.ui.MenuBar;\n+import com.sun.glass.ui.MenuItem;\n+import com.sun.glass.ui.PlatformFactory;\n+import com.sun.glass.ui.SystemClipboard;\n+import com.sun.glass.ui.delegate.ClipboardDelegate;\n+import com.sun.glass.ui.delegate.MenuBarDelegate;\n+import com.sun.glass.ui.delegate.MenuDelegate;\n+import com.sun.glass.ui.delegate.MenuItemDelegate;\n+import java.util.HashMap;\n+\n+public class HeadlessPlatformFactory extends PlatformFactory {\n+\n+    @Override\n+    public Application createApplication() {\n+        return new HeadlessApplication();\n+    }\n+\n+    @Override\n+    public MenuBarDelegate createMenuBarDelegate(MenuBar menubar) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public MenuDelegate createMenuDelegate(Menu menu) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public MenuItemDelegate createMenuItemDelegate(MenuItem menuItem) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ClipboardDelegate createClipboardDelegate() {\n+        return (String clipboardName) -> {\n+            if (Clipboard.SYSTEM.equals(clipboardName)) {\n+                return new HeadlessSystemClipboard();\n+            } else if (Clipboard.DND.equals(clipboardName)) {\n+                return new HeadlessDnDClipboard();\n+            } else {\n+                throw new IllegalArgumentException(\"No support for \" + clipboardName + \" clipboard in headless\");\n+            }\n+        };\n+\n+    }\n+\n+    static class HeadlessSystemClipboard extends SystemClipboard {\n+\n+        HashMap<String, Object> cacheData;\n+        int supportedActions;\n+\n+        HeadlessSystemClipboard() {\n+            super(Clipboard.SYSTEM);\n+        }\n+\n+        @Override\n+        protected boolean isOwner() {\n+            return true;\n+        }\n+\n+        @Override\n+        protected void pushToSystem(HashMap<String, Object> cacheData, int supportedActions) {\n+            this.cacheData = cacheData;\n+            this.supportedActions = supportedActions;\n+        }\n+\n+        @Override\n+        protected void pushTargetActionToSystem(int actionDone) {\n+        }\n+\n+        @Override\n+        protected Object popFromSystem(String mimeType) {\n+            return null;\n+        }\n+\n+        @Override\n+        protected int supportedSourceActionsFromSystem() {\n+            return Clipboard.ACTION_NONE;\n+        }\n+\n+        @Override\n+        protected String[] mimesFromSystem() {\n+            return new String[0];\n+        }\n+    }\n+\n+    static class HeadlessDnDClipboard extends SystemClipboard {\n+\n+        HeadlessDnDClipboard() {\n+            super(Clipboard.DND);\n+        }\n+\n+        @Override\n+        protected boolean isOwner() {\n+            throw new UnsupportedOperationException(\"Not supported yet.\");\n+        }\n+\n+        @Override\n+        protected void pushToSystem(HashMap<String, Object> cacheData, int supportedActions) {\n+            throw new UnsupportedOperationException(\"Not supported yet.\");\n+        }\n+\n+        @Override\n+        protected void pushTargetActionToSystem(int actionDone) {\n+            throw new UnsupportedOperationException(\"Not supported yet.\");\n+        }\n+\n+        @Override\n+        protected Object popFromSystem(String mimeType) {\n+            throw new UnsupportedOperationException(\"Not supported yet.\");\n+        }\n+\n+        @Override\n+        protected int supportedSourceActionsFromSystem() {\n+            throw new UnsupportedOperationException(\"Not supported yet.\");\n+        }\n+\n+        @Override\n+        protected String[] mimesFromSystem() {\n+            throw new UnsupportedOperationException(\"Not supported yet.\");\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessPlatformFactory.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,421 @@\n+\/*\n+ * Copyright (c) 2025, Gluon. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.events.KeyEvent;\n+import com.sun.glass.events.MouseEvent;\n+import com.sun.glass.ui.Application;\n+import com.sun.glass.ui.GlassRobot;\n+import com.sun.glass.ui.Window;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import javafx.scene.image.WritableImage;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.paint.Color;\n+\n+public class HeadlessRobot extends GlassRobot {\n+\n+    final int multiplierX = 40;\n+    final int multiplierY = 40;\n+    private final HeadlessApplication application;\n+    private HeadlessWindow activeWindow = null;\n+\n+    private double mouseX, mouseY;\n+\n+    private final SpecialKeys specialKeys = new SpecialKeys();\n+    private final MouseState mouseState = new MouseState();\n+    private final char[] NO_CHAR = { };\n+\n+    public HeadlessRobot(HeadlessApplication application) {\n+        this.application = application;\n+    }\n+\n+    void windowAdded(HeadlessWindow window) {\n+        if (this.activeWindow == null) activeWindow = window;\n+    }\n+\n+    void windowRemoved(HeadlessWindow window) {\n+        if (this.activeWindow == window) activeWindow = null;\n+    }\n+\n+    @Override\n+    public void create() {\n+    }\n+\n+    @Override\n+    public void destroy() {\n+    }\n+\n+    @Override\n+    public void keyPress(KeyCode keyCode) {\n+        checkWindowFocused();\n+        if (activeWindow == null) return;\n+        HeadlessView view = (HeadlessView)activeWindow.getView();\n+        int code = keyCode.getCode();\n+        processSpecialKeys(code, true);\n+        char[] keyval = getKeyChars(code);\n+        int mods = getKeyModifiers();\n+        if (view != null) {\n+            view.notifyKey(KeyEvent.PRESS, code, keyval, mods);\n+            if (keyval.length > 0) {\n+                view.notifyKey(KeyEvent.TYPED, 0, keyval, mods);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void keyRelease(KeyCode keyCode) {\n+        checkWindowFocused();\n+        if (activeWindow == null) return;\n+        HeadlessView view = (HeadlessView)activeWindow.getView();\n+        int code = keyCode.getCode();\n+        processSpecialKeys(code, false);\n+        int mods = getKeyModifiers();\n+        char[] keyval = new char[1];\n+        keyval[0] = (char) code;\n+        if (view != null) {\n+            view.notifyKey(KeyEvent.RELEASE, code, keyval, mods);\n+        }\n+    }\n+\n+    @Override\n+    public double getMouseX() {\n+        return this.mouseX;\n+    }\n+\n+    @Override\n+    public double getMouseY() {\n+        return this.mouseY;\n+    }\n+\n+    @Override\n+    public void mouseMove(double x, double y) {\n+        this.mouseX = x;\n+        this.mouseY = y;\n+        checkWindowEnterExit();\n+        if (activeWindow == null) return;\n+        HeadlessView view = (HeadlessView)activeWindow.getView();\n+        if (view == null) return;\n+        int wx = activeWindow.getX();\n+        int wy = activeWindow.getY();\n+        int buttonEvent = MouseEvent.BUTTON_NONE;\n+        int mouseEvent = MouseEvent.MOVE;\n+        if (mouseState.pressedButtons.size() > 0) {\n+            MouseButton button = mouseState.pressedButtons.stream().findFirst().get();\n+            buttonEvent = getGlassEventButton(button);\n+            mouseEvent = MouseEvent.DRAG;\n+        }\n+        int modifiers = 0;\n+        view.notifyMouse(mouseEvent, buttonEvent, (int)mouseX-wx, (int)mouseY-wy, (int)mouseX, (int)mouseY, modifiers, false, false);\n+    }\n+\n+    @Override\n+    public void mousePress(MouseButton... buttons) {\n+        Application.checkEventThread();\n+        mouseState.pressedButtons.addAll(Arrays.asList(buttons));\n+        checkWindowEnterExit();\n+        HeadlessView view = (HeadlessView)activeWindow.getView();\n+        if (view == null) {\n+            view = (HeadlessView)activeWindow.getView();\n+            if (view == null) {\n+                return;\n+            }\n+        }\n+        int wx = activeWindow.getX();\n+        int wy = activeWindow.getY();\n+        int modifiers = getModifiers(buttons);\n+        int buttonCode = getGlassEventButton(buttons);\n+        view.notifyMouse(MouseEvent.DOWN, buttonCode, (int)mouseX-wx, (int)mouseY-wy, (int)mouseX, (int)mouseY, modifiers, true, true);\n+        if (buttonCode == MouseEvent.BUTTON_RIGHT) {\n+            view.notifyMenu((int)mouseX-wx, (int)mouseY-wy, (int)mouseX, (int)mouseY, false);\n+        }\n+    }\n+\n+    @Override\n+    public void mouseRelease(MouseButton... buttons) {\n+        Application.checkEventThread();\n+        mouseState.pressedButtons.removeAll(Arrays.asList(buttons));\n+        checkWindowEnterExit();\n+        if (this.activeWindow == null) {\n+            return;\n+        }\n+        HeadlessView view = (HeadlessView) activeWindow.getView();\n+        int wx = activeWindow.getX();\n+        int wy = activeWindow.getY();\n+        int modifiers = getModifiers(buttons);\n+        view.notifyMouse(MouseEvent.UP, getGlassEventButton(buttons), (int) mouseX - wx, (int) mouseY - wy, (int) mouseX, (int) mouseY, modifiers, true, true);\n+    }\n+\n+    @Override\n+    public void mouseWheel(int wheelAmt) {\n+        checkWindowFocused();\n+\n+        final int dff = wheelAmt > 0 ? -1 : 1;\n+        HeadlessView view = (HeadlessView) activeWindow.getView();\n+\n+        int wx = activeWindow.getX();\n+        int wy = activeWindow.getY();\n+        int repeat = Math.abs(wheelAmt);\n+        for (int i = 0; i < repeat; i++) {\n+            view.notifyScroll((int) mouseX, (int) mouseY, wx, wy, 0, dff, 0, 0, 0, 0, 0, multiplierX, multiplierY);\n+        }\n+    }\n+\n+    @Override\n+    public Color getPixelColor(double x, double y) {\n+        HeadlessWindow topWindow = getTopWindow();\n+        return topWindow.getColor((int)x, (int) y);\n+    }\n+\n+    @Override\n+    public WritableImage getScreenCapture(WritableImage image, double x, double y, double width, double height, boolean scaleToFit) {\n+        return super.getScreenCapture(image, x, y, width, height, scaleToFit);\n+    }\n+\n+    @Override\n+    public void getScreenCapture(int x, int y, int width, int height, int[] data, boolean scaleToFit) {\n+        checkWindowFocused();\n+        activeWindow.getScreenCapture(x, y, width, height, data, scaleToFit);\n+    }\n+\n+    private void checkActiveWindowExists() {\n+        if ((this.activeWindow != null) && (!this.activeWindow.isVisible())) {\n+            this.activeWindow = null;\n+        }\n+    }\n+    private void checkWindowFocused() {\n+        checkActiveWindowExists();\n+        this.activeWindow = getFocusedWindow();\n+    }\n+\n+    private void checkWindowEnterExit() {\n+        checkActiveWindowExists();\n+        Window oldWindow = activeWindow;\n+        this.activeWindow = getTargetWindow(this.mouseX, this.mouseY);\n+\n+        if (this.activeWindow == null) {\n+            if (oldWindow != null) {\n+                HeadlessView oldView = (HeadlessView)oldWindow.getView();\n+                if (oldView != null) {\n+                    oldView.notifyMouse(MouseEvent.EXIT, MouseEvent.BUTTON_NONE, 0, 0,0,0, 0, true, true);\n+                }\n+            }\n+            return;\n+        }\n+        int wx = activeWindow.getX();\n+        int wy = activeWindow.getY();\n+\n+        if (activeWindow != oldWindow) {\n+            HeadlessView view = (HeadlessView)activeWindow.getView();\n+            int modifiers = 0;\n+            view.notifyMouse(MouseEvent.ENTER, MouseEvent.BUTTON_NONE, (int) mouseX - wx, (int) mouseY - wy, (int) mouseX, (int) mouseY, modifiers, true, true);\n+            if (oldWindow != null) {\n+                HeadlessView oldView = (HeadlessView)oldWindow.getView();\n+                if (oldView != null) {\n+                    int owx = oldWindow.getX();\n+                    int owy = oldWindow.getY();\n+                    oldView.notifyMouse(MouseEvent.EXIT, MouseEvent.BUTTON_NONE, (int) mouseX - owx, (int) mouseY - owy, (int) mouseX, (int) mouseY, modifiers, true, true);\n+                }\n+            }\n+        }\n+    }\n+\n+    private HeadlessWindow getTopWindow() {\n+        List<Window> windows = Window.getWindows().stream()\n+                .filter(win -> win.getView() != null)\n+                .filter(win -> !win.isClosed())\n+                .filter(win -> !win.isMinimized()).toList();\n+        if (windows.isEmpty()) return null;\n+        if (windows.size() == 1) return (HeadlessWindow)windows.get(0);\n+        return (HeadlessWindow)windows.get(windows.size() -1);\n+    }\n+\n+    private HeadlessWindow getFocusedWindow() {\n+        List<Window> windows = Window.getWindows().stream()\n+                .filter(win -> win.getView()!= null)\n+                .filter(win -> !win.isClosed())\n+                .filter(win -> win.isFocused()).toList();\n+        if (windows.isEmpty()) return null;\n+        if (windows.size() == 1) return (HeadlessWindow)windows.get(0);\n+        return (HeadlessWindow)windows.get(windows.size() -1);\n+    }\n+\n+    private HeadlessWindow getTargetWindow(double x, double y) {\n+        List<Window> windows = Window.getWindows().stream()\n+                .filter(win -> win.getView()!= null)\n+                .filter(win -> !win.isClosed())\n+                .filter(win -> (x >= win.getX() && x <= win.getX() + win.getWidth()\n+                        && y >= win.getY() && y <= win.getY()+ win.getHeight())).toList();\n+        if (windows.isEmpty()) {\n+            return null;\n+        }\n+        if (windows.size() == 1) return (HeadlessWindow)windows.get(0);\n+        return (HeadlessWindow)windows.get(windows.size() -1);\n+    }\n+\n+    int getModifiers(MouseButton... buttons) {\n+        int modifiers = KeyEvent.MODIFIER_NONE;\n+        for (int i = 0; i < buttons.length; i++) {\n+            modifiers |= switch (buttons[i]) {\n+                case NONE -> KeyEvent.MODIFIER_NONE;\n+                case PRIMARY -> KeyEvent.MODIFIER_BUTTON_PRIMARY;\n+                case MIDDLE -> KeyEvent.MODIFIER_BUTTON_MIDDLE;\n+                case SECONDARY -> KeyEvent.MODIFIER_BUTTON_SECONDARY;\n+                case BACK -> KeyEvent.MODIFIER_BUTTON_BACK;\n+                case FORWARD -> KeyEvent.MODIFIER_BUTTON_FORWARD;\n+            };\n+        }\n+        return modifiers;\n+    }\n+\n+    int getGlassEventButton(MouseButton[] buttons) {\n+        if ((buttons == null) || (buttons.length == 0)) return 0;\n+        return getGlassEventButton(buttons[0]);\n+    }\n+\n+    int getGlassEventButton(MouseButton button) {\n+        return switch (button) {\n+            case NONE -> MouseEvent.BUTTON_NONE;\n+            case PRIMARY -> MouseEvent.BUTTON_LEFT;\n+            case MIDDLE -> MouseEvent.BUTTON_OTHER;\n+            case SECONDARY -> MouseEvent.BUTTON_RIGHT;\n+            case BACK -> MouseEvent.BUTTON_BACK;\n+            case FORWARD -> MouseEvent.BUTTON_FORWARD;\n+        };\n+    }\n+\n+    private void processSpecialKeys(int c, boolean on) {\n+        if (c == KeyEvent.VK_CONTROL) {\n+            this.specialKeys.keyControl = on;\n+        }\n+        if (c == KeyEvent.VK_SHIFT) {\n+            this.specialKeys.keyShift = on;\n+        }\n+        if (c == KeyEvent.VK_COMMAND) {\n+            this.specialKeys.keyCommand = on;\n+        }\n+        if (c == KeyEvent.VK_ALT) {\n+            this.specialKeys.keyAlt = on;\n+        }\n+    }\n+    private char[] getKeyChars(int key) {\n+        char c = '\\000';\n+        boolean shifted = this.specialKeys.keyShift;\n+        \/\/ TODO: implement configurable keyboard mappings.\n+        \/\/ The following is only for US keyboards\n+        if (key >= KeyEvent.VK_A && key <= KeyEvent.VK_Z) {\n+            shifted ^= this.specialKeys.capsLock;\n+            if (shifted) {\n+                c = (char) (key - KeyEvent.VK_A + 'A');\n+            } else {\n+                c = (char) (key - KeyEvent.VK_A + 'a');\n+            }\n+        } else if (key >= KeyEvent.VK_NUMPAD0 && key <= KeyEvent.VK_NUMPAD9) {\n+            if (this.specialKeys.numLock) {\n+                c = (char) (key - KeyEvent.VK_NUMPAD0 + '0');\n+            }\n+        } else if (key >= KeyEvent.VK_0 && key <= KeyEvent.VK_9) {\n+            if (shifted) {\n+                switch (key) {\n+                    case KeyEvent.VK_0: c = ')'; break;\n+                    case KeyEvent.VK_1: c = '!'; break;\n+                    case KeyEvent.VK_2: c = '@'; break;\n+                    case KeyEvent.VK_3: c = '#'; break;\n+                    case KeyEvent.VK_4: c = '$'; break;\n+                    case KeyEvent.VK_5: c = '%'; break;\n+                    case KeyEvent.VK_6: c = '^'; break;\n+                    case KeyEvent.VK_7: c = '&'; break;\n+                    case KeyEvent.VK_8: c = '*'; break;\n+                    case KeyEvent.VK_9: c = '('; break;\n+                }\n+            } else {\n+                c = (char) (key - KeyEvent.VK_0 + '0');\n+            }\n+        } else if (key == KeyEvent.VK_SPACE) {\n+            c = ' ';\n+        } else if (key == KeyEvent.VK_TAB) {\n+            c = '\\t';\n+        } else if (key == KeyEvent.VK_ENTER) {\n+            c = (char)13;\n+        } else if (key == KeyEvent.VK_MULTIPLY) {\n+            c = '*';\n+        } else if (key == KeyEvent.VK_DIVIDE) {\n+            c = '\/';\n+        } else if (shifted) {\n+            switch (key) {\n+                case KeyEvent.VK_BACK_QUOTE: c = '~'; break;\n+                case KeyEvent.VK_COMMA: c = '<'; break;\n+                case KeyEvent.VK_PERIOD: c = '>'; break;\n+                case KeyEvent.VK_SLASH: c = '?'; break;\n+                case KeyEvent.VK_SEMICOLON: c = ':'; break;\n+                case KeyEvent.VK_QUOTE: c = '\\\"'; break;\n+                case KeyEvent.VK_BRACELEFT: c = '{'; break;\n+                case KeyEvent.VK_BRACERIGHT: c = '}'; break;\n+                case KeyEvent.VK_BACK_SLASH: c = '|'; break;\n+                case KeyEvent.VK_MINUS: c = '_'; break;\n+                case KeyEvent.VK_EQUALS: c = '+'; break;\n+            }        } else {\n+            switch (key) {\n+                case KeyEvent.VK_BACK_QUOTE: c = '`'; break;\n+                case KeyEvent.VK_COMMA: c = ','; break;\n+                case KeyEvent.VK_PERIOD: c = '.'; break;\n+                case KeyEvent.VK_SLASH: c = '\/'; break;\n+                case KeyEvent.VK_SEMICOLON: c = ';'; break;\n+                case KeyEvent.VK_QUOTE: c = '\\''; break;\n+                case KeyEvent.VK_BRACELEFT: c = '['; break;\n+                case KeyEvent.VK_BRACERIGHT: c = ']'; break;\n+                case KeyEvent.VK_BACK_SLASH: c = '\\\\'; break;\n+                case KeyEvent.VK_MINUS: c = '-'; break;\n+                case KeyEvent.VK_EQUALS: c = '='; break;\n+            }\n+        }\n+        return c == '\\000' ? NO_CHAR : new char[] { c };\n+    }\n+\n+\n+    private int getKeyModifiers() {\n+        int answer = 0;\n+        if (this.specialKeys.keyControl) answer |= KeyEvent.MODIFIER_CONTROL;\n+        if (this.specialKeys.keyShift) answer |= KeyEvent.MODIFIER_SHIFT;\n+        if (this.specialKeys.keyCommand) answer |= KeyEvent.MODIFIER_COMMAND;\n+        if (this.specialKeys.keyAlt) answer |= KeyEvent.MODIFIER_ALT;\n+        return answer;\n+    }\n+\n+    class SpecialKeys {\n+        boolean keyControl;\n+        boolean keyShift;\n+        boolean keyCommand;\n+        boolean keyAlt;\n+        boolean capsLock;\n+        boolean numLock;\n+    }\n+\n+    class MouseState {\n+        final HashSet<MouseButton> pressedButtons = new HashSet<>();\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessRobot.java","additions":421,"deletions":0,"binary":false,"changes":421,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2025, Gluon. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.ui.Timer;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+public class HeadlessTimer extends Timer {\n+\n+    private static ScheduledThreadPoolExecutor scheduler;\n+    private ScheduledFuture<?> task;\n+\n+    HeadlessTimer(final Runnable runnable) {\n+        super(runnable);\n+    }\n+\n+    @Override\n+    protected long _start(Runnable runnable) {\n+        throw new RuntimeException(\"vsync timer not supported\");\n+    }\n+\n+    @Override\n+    protected long _start(Runnable runnable, int period) {\n+        if (scheduler == null) {\n+            scheduler = new ScheduledThreadPoolExecutor(1, target -> {\n+                Thread thread = new Thread(target, \"Headless Timer\");\n+                thread.setDaemon(true);\n+                return thread;\n+            });\n+        }\n+        task = scheduler.scheduleAtFixedRate(runnable, 0, period, TimeUnit.MILLISECONDS);\n+        return 1;\n+\n+    }\n+\n+    @Override\n+    protected void _stop(long timer) {\n+        if (task != null) {\n+            task.cancel(false);\n+            task = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void _pause(long timer) {\n+    }\n+\n+    @Override\n+    protected void _resume(long timer) {\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessTimer.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2025, Gluon. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.events.ViewEvent;\n+import com.sun.glass.ui.Pixels;\n+import com.sun.glass.ui.View;\n+import java.util.Map;\n+\n+public class HeadlessView extends View {\n+\n+    private int x = 0;\n+    private int y = 0;\n+    private long parentPtr = 0;\n+    private Pixels pixels;\n+\n+    @Override\n+    protected void _enableInputMethodEvents(long ptr, boolean enable) {\n+    }\n+\n+    @Override\n+    protected long _create(Map capabilities) {\n+        return 1;\n+    }\n+\n+    @Override\n+    protected long _getNativeView(long ptr) {\n+        return ptr;\n+    }\n+\n+    @Override\n+    protected int _getX(long ptr) {\n+        return x;\n+    }\n+\n+    @Override\n+    protected int _getY(long ptr) {\n+        return y;\n+    }\n+\n+    @Override\n+    protected void _setParent(long ptr, long parentPtr) {\n+        this.parentPtr = parentPtr;\n+    }\n+\n+    @Override\n+    protected boolean _close(long ptr) {\n+        return true;\n+    }\n+\n+    @Override\n+    protected void _scheduleRepaint(long ptr) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected void _begin(long ptr) {\n+    }\n+\n+    @Override\n+    protected void _end(long ptr) {\n+    }\n+\n+    @Override\n+    protected int _getNativeFrameBuffer(long ptr) {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected void _uploadPixels(long ptr, Pixels pixels) {\n+        HeadlessWindow window = (HeadlessWindow)this.getWindow();\n+        this.pixels = pixels;\n+        window.blit(pixels);\n+    }\n+\n+    @Override\n+    protected boolean _enterFullscreen(long ptr, boolean animate, boolean keepRatio, boolean hideCursor) {\n+        HeadlessWindow window = (HeadlessWindow)this.getWindow();\n+        window.setFullscreen(true);\n+        notifyView(ViewEvent.FULLSCREEN_ENTER);\n+        return true;\n+    }\n+\n+    @Override\n+    protected void _exitFullscreen(long ptr, boolean animate) {\n+        HeadlessWindow window = (HeadlessWindow)this.getWindow();\n+        if (window != null) {\n+            window.setFullscreen(false);\n+        }\n+        notifyView(ViewEvent.FULLSCREEN_EXIT);\n+    }\n+\n+    @Override\n+    protected void notifyResize(int width, int height) {\n+        super.notifyResize(width, height);\n+    }\n+\n+    @Override\n+    protected void notifyMouse(int type, int button, int x, int y, int xAbs, int yAbs, int modifiers, boolean isPopupTrigger, boolean isSynthesized) {\n+        super.notifyMouse(type, button, x, y, xAbs, yAbs, modifiers, isPopupTrigger, isSynthesized);\n+    }\n+\n+    @Override\n+    protected void notifyMenu(int x, int y, int xAbs, int yAbs, boolean isKeyboardTrigger) {\n+        super.notifyMenu(x, y, xAbs, yAbs, isKeyboardTrigger);\n+    }\n+\n+    @Override\n+    protected void notifyScroll(int x, int y, int xAbs, int yAbs, double deltaX, double deltaY, int modifiers, int lines, int chars, int defaultLines, int defaultChars, double xMultiplier, double yMultiplier) {\n+        super.notifyScroll(x, y, xAbs, yAbs, deltaX, deltaY, modifiers, lines, chars, defaultLines, defaultChars, xMultiplier, yMultiplier);\n+    }\n+\n+    @Override\n+    protected void notifyKey(int type, int keyCode, char[] keyChars, int modifiers) {\n+        super.notifyKey(type, keyCode, keyChars, modifiers);\n+    }\n+\n+    @Override\n+    protected void notifyRepaint(int x, int y, int width, int height) {\n+        super.notifyRepaint(x, y, width, height);\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessView.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,351 @@\n+\/*\n+ * Copyright (c) 2025, Gluon. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.events.MouseEvent;\n+import com.sun.glass.events.WindowEvent;\n+import com.sun.glass.ui.Cursor;\n+import com.sun.glass.ui.Pixels;\n+import com.sun.glass.ui.Screen;\n+import com.sun.glass.ui.View;\n+import com.sun.glass.ui.Window;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javafx.scene.paint.Color;\n+\n+public class HeadlessWindow extends Window {\n+\n+    private static final AtomicLong ptrCount = new AtomicLong(0);\n+    private long ptr;\n+    private final HeadlessWindowManager windowManager;\n+\n+    private int minWidth;\n+    private int minHeight;\n+    private int maxWidth = -1;\n+    private int maxHeight = -1;\n+    private int originalX, originalY, originalWidth, originalHeight;\n+    private boolean visible;\n+\n+    private final ByteBuffer frameBuffer;\n+    private HeadlessView currentView;\n+    private HeadlessRobot robot;\n+\n+    private final int stride = 1000;\n+\n+    public HeadlessWindow(HeadlessWindowManager wm, Window owner, Screen screen, ByteBuffer frameBuffer, int styleMask) {\n+        super(owner, screen, styleMask);\n+        this.frameBuffer = frameBuffer;\n+        this.windowManager = wm;\n+    }\n+\n+    @Override\n+    protected long _createWindow(long ownerPtr, long screenPtr, int mask) {\n+        this.ptr = ptrCount.incrementAndGet();\n+        return ptr;\n+    }\n+\n+    @Override\n+    protected boolean _close(long ptr) {\n+        this.notifyDestroy();\n+        if (this.robot != null) {\n+            this.robot.windowRemoved(this);\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean _setView(long ptr, View view) {\n+        if (currentView != null) {\n+            currentView.notifyMouse(MouseEvent.EXIT, MouseEvent.BUTTON_NONE, 0, 0, 0, 0, 0, false, false);\n+        }\n+        this.currentView = (HeadlessView) view;\n+        if (currentView != null) {\n+            currentView.notifyMouse(MouseEvent.ENTER, MouseEvent.BUTTON_NONE, 0, 0, 0, 0, 0, false, false);\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    protected void _updateViewSize(long ptr) {\n+        if (this.isVisible()) {\n+            currentView.notifyResize(width, height);\n+        }\n+    }\n+\n+    @Override\n+    protected boolean _setMenubar(long ptr, long menubarPtr) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected boolean _minimize(long ptr, boolean minimize) {\n+        notifyResize(minimize ? WindowEvent.MINIMIZE : WindowEvent.RESTORE, width, height);\n+        windowManager.repaintAll();\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean _maximize(long ptr, boolean maximize, boolean wasMaximized) {\n+        int newX = 0;\n+        int newY = 0;\n+        int newWidth = 0;\n+        int newHeight = 0;\n+        if (maximize && !wasMaximized) {\n+            this.originalHeight = this.height;\n+            this.originalWidth = this.width;\n+            this.originalX = this.x;\n+            this.originalY = this.y;\n+            newWidth = screen.getWidth();\n+            newHeight = screen.getHeight();\n+            setState(State.MAXIMIZED);\n+        } else if (!maximize && wasMaximized) {\n+            newHeight = this.originalHeight;\n+            newWidth = this.originalWidth;\n+            newX = this.originalX;\n+            newY = this.originalY;\n+            setState(State.NORMAL);\n+        }\n+        notifyResizeAndMove(newX, newY, newWidth, newHeight);\n+        if (maximize) {\n+            notifyResize(WindowEvent.MAXIMIZE, newWidth, newHeight);\n+        }\n+\n+        return maximize;\n+    }\n+\n+    @Override\n+    protected void _setBounds(long ptr, int x, int y, boolean xSet, boolean ySet, int w, int h, int cw, int ch, float xGravity, float yGravity) {\n+        int newWidth = w > 0 ? w : cw > 0 ? cw : getWidth();\n+        int newHeight = h > 0 ? h : ch > 0 ? ch : getHeight();\n+        if (!xSet) {\n+            x = getX();\n+        }\n+        if (!ySet) {\n+            y = getY();\n+        }\n+        if (maxWidth >= 0) {\n+            newWidth = Math.min(newWidth, maxWidth);\n+        }\n+        if (maxHeight >= 0) {\n+            newHeight = Math.min(newHeight, maxHeight);\n+        }\n+        newWidth = Math.max(newWidth, minWidth);\n+        newHeight = Math.max(newHeight, minHeight);\n+        if (newWidth < getWidth()) {\n+            clearRect(getX() + newWidth, getWidth() - newWidth, getY(), getHeight());\n+        }\n+        if (newHeight < getHeight()) {\n+            clearRect(getX(), getWidth(), getY() + newHeight, getHeight() - newHeight);\n+        }\n+        notifyResizeAndMove(x, y, newWidth, newHeight);\n+    }\n+\n+    @Override\n+    protected boolean _setVisible(long ptr, boolean v) {\n+        this.visible = v;\n+        return this.visible;\n+    }\n+\n+    @Override\n+    protected boolean _setResizable(long ptr, boolean resizable) {\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean _requestFocus(long ptr, int event) {\n+        this.notifyFocus(event);\n+        return this.isFocused();\n+    }\n+\n+    @Override\n+    protected void _setFocusable(long ptr, boolean isFocusable) {\n+    }\n+\n+    @Override\n+    protected boolean _grabFocus(long ptr) {\n+        return true;\n+    }\n+\n+    @Override\n+    protected void _ungrabFocus(long ptr) {\n+    }\n+\n+    @Override\n+    protected boolean _setTitle(long ptr, String title) {\n+        return true;\n+    }\n+\n+    @Override\n+    protected void _setLevel(long ptr, int level) {\n+    }\n+\n+    @Override\n+    protected void _setAlpha(long ptr, float alpha) {\n+    }\n+\n+    @Override\n+    protected boolean _setBackground(long ptr, float r, float g, float b) {\n+        return true;\n+    }\n+\n+    @Override\n+    protected void _setEnabled(long ptr, boolean enabled) {\n+    }\n+\n+    @Override\n+    protected boolean _setMinimumSize(long ptr, int width, int height) {\n+        this.minWidth = width;\n+        this.minHeight = height;\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean _setMaximumSize(long ptr, int width, int height) {\n+        this.maxWidth = width;\n+        this.maxHeight = height;\n+        return true;\n+    }\n+\n+    @Override\n+    protected void _setIcon(long ptr, Pixels pixels) {\n+    }\n+\n+    @Override\n+    protected void _setCursor(long ptr, Cursor cursor) {\n+    }\n+\n+    @Override\n+    protected void _toFront(long ptr) {\n+    }\n+\n+    @Override\n+    protected void _toBack(long ptr) {\n+    }\n+\n+    @Override\n+    protected void _requestInput(long ptr, String text, int type, double width, double height,\n+            double Mxx, double Mxy, double Mxz, double Mxt,\n+            double Myx, double Myy, double Myz, double Myt,\n+            double Mzx, double Mzy, double Mzz, double Mzt) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected void _releaseInput(long ptr) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    void setFullscreen(boolean full) {\n+        int newX = 0;\n+        int newY = 0;\n+        int newWidth = 0;\n+        int newHeight = 0;\n+        if (full) {\n+            this.originalHeight = this.height;\n+            this.originalWidth = this.width;\n+            this.originalX = this.x;\n+            this.originalY = this.y;\n+            newX = 0;\n+            newY = 0;\n+            newWidth = screen.getWidth();\n+            newHeight = screen.getHeight();\n+        } else {\n+            newHeight = this.originalHeight;\n+            newWidth = this.originalWidth;\n+            newX = this.originalX;\n+            newY = this.originalY;\n+        }\n+        notifyResizeAndMove(newX, newY, newWidth, newHeight);\n+    }\n+\n+    private void notifyResizeAndMove(int x, int y, int width, int height) {\n+        HeadlessView view = (HeadlessView) getView();\n+        notifyResize(WindowEvent.RESIZE, width, height);\n+        if (view != null) {\n+            view.notifyResize(width, height);\n+        }\n+        if (getX() != x || getY() != y) {\n+            notifyMove(x, y);\n+        }\n+    }\n+\n+    public Color getColor(int lx, int ly) {\n+        int mx = lx;\n+        int my = ly;\n+        int idx = stride * my + mx;\n+        int rgba = frameBuffer.asIntBuffer().get(idx);\n+        int a = (rgba >> 24) & 0xFF;\n+        int r = (rgba >> 16) & 0xFF;\n+        int g = (rgba >> 8) & 0xFF;\n+        int b = rgba & 0xFF;\n+\n+        Color color = Color.rgb(r, g, b, a\/255.);\n+        return color;\n+    }\n+\n+    public void getScreenCapture(int x, int y, int width, int height, int[] data, boolean scaleToFit) {\n+        for (int i = 0; i < height; i++) {\n+            for (int j = 0; j < width; j++) {\n+                int idx = i * width + j;\n+                int fidx = (y + i) * stride + x + j;\n+                int val = frameBuffer.asIntBuffer().get(fidx);\n+                data[idx] = val;\n+            }\n+        }\n+    }\n+\n+    void blit(Pixels pixels) {\n+        int pW = pixels.getWidth();\n+        int pH = pixels.getHeight();\n+        int offsetX = this.getX();\n+        int offsetY = this.getY();\n+\n+        IntBuffer intBuffer = (IntBuffer) pixels.getBuffer();\n+\n+        for (int i = 0; i < pixels.getHeight(); i++) {\n+            int rowIdx = offsetY + i;\n+            for (int j = 0; j < pixels.getWidth(); j++) {\n+                int idx = rowIdx * stride + offsetX + j;\n+                int val = intBuffer.get(i * pixels.getWidth() + j);\n+                frameBuffer.asIntBuffer().put(idx, val);\n+            }\n+        }\n+    }\n+\n+    void clearRect(int x0, int w0, int y0, int h0) {\n+        for (int i = 0; i < h0; i++) {\n+            int rowIdx = y0 + i;\n+            for (int j = 0; j < w0; j++) {\n+                int idx = rowIdx * stride + x0 + j;\n+                frameBuffer.asIntBuffer().put(idx, 0);\n+            }\n+        }\n+    }\n+\n+    void setRobot(HeadlessRobot activeRobot) {\n+        this.robot = activeRobot;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessWindow.java","additions":351,"deletions":0,"binary":false,"changes":351,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2025, Gluon. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.ui.Window;\n+import java.util.List;\n+\n+public class HeadlessWindowManager {\n+\n+    void repaintAll() {\n+        List<Window> windows = Window.getWindows().stream()\n+                .filter(win -> win.getView() != null)\n+                .filter(win -> !win.isClosed())\n+                .filter(win -> win.isVisible()).toList();\n+        for (Window win : windows) {\n+            if (win.isVisible() && (!win.isMinimized())) {\n+                HeadlessWindow hw = (HeadlessWindow) win;\n+                HeadlessView hv = (HeadlessView) hw.getView();\n+                hv.notifyRepaint(hw.getX(), hw.getY(), hw.getWidth(), hw.getHeight());\n+            }\n+        }\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessWindowManager.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Gluon. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.ui.Application;\n+import java.util.LinkedList;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+public class NestedRunnableProcessor implements Runnable {\n+\n+    private final LinkedList<RunLoopEntry> activeRunLoops = new LinkedList<>();\n+\n+    private final BlockingQueue<Runnable> runnableQueue = new LinkedBlockingQueue<>();\n+\n+    @Override\n+    public void run() {\n+        newRunLoop();\n+    }\n+\n+    void invokeLater(final Runnable r) {\n+        runnableQueue.add(r);\n+    }\n+\n+    public Object newRunLoop() {\n+        RunLoopEntry entry = new RunLoopEntry();\n+\n+        activeRunLoops.push(entry);\n+\n+        entry.active = true;\n+        while (entry.active) {\n+            try {\n+                runnableQueue.take().run();\n+            } catch (Throwable e) {\n+                Application.reportException(e);\n+            }\n+        }\n+        return entry.returnValue;\n+    }\n+\n+    public void leaveCurrentLoop(Object returnValue) {\n+        RunLoopEntry entry = activeRunLoops.pop();\n+        entry.active = false;\n+        entry.returnValue = returnValue;\n+    }\n+\n+    private static class RunLoopEntry {\n+\n+        boolean active;\n+        Object returnValue;\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/NestedRunnableProcessor.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}