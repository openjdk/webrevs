{"files":[{"patch":"@@ -2166,2 +2166,1 @@\n-            systemProperty 'glass.platform', 'Monocle'\n-            systemProperty 'monocle.platform', 'Headless'\n+            systemProperty 'glass.platform', 'Headless'\n@@ -3858,2 +3857,1 @@\n-        systemProperty 'glass.platform', 'Monocle'\n-        systemProperty 'monocle.platform', 'Headless'\n+        systemProperty 'glass.platform', 'Headless'\n","filename":"build.gradle","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,217 @@\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.events.KeyEvent;\n+import com.sun.glass.ui.Application;\n+import com.sun.glass.ui.CommonDialogs;\n+import com.sun.glass.ui.Cursor;\n+import com.sun.glass.ui.GlassRobot;\n+import com.sun.glass.ui.Pixels;\n+import com.sun.glass.ui.Screen;\n+import com.sun.glass.ui.Size;\n+import com.sun.glass.ui.Timer;\n+import com.sun.glass.ui.View;\n+import com.sun.glass.ui.Window;\n+import java.io.File;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+\n+public class HeadlessApplication extends Application {\n+\n+    private final NestedRunnableProcessor processor = new NestedRunnableProcessor();\n+    private final HeadlessWindowManager windowManager = new HeadlessWindowManager();\n+    private Screen[] screens = null;\n+    private HeadlessCursor cursor;\n+    private HeadlessRobot activeRobot = null;\n+    ByteBuffer frameBuffer;\n+\n+    private final int MULTICLICK_MAX_X = 20;\n+    private final int MULTICLICK_MAX_Y = 20;\n+    private final long MULTICLICK_TIME = 500;\n+\n+    @Override\n+    protected void runLoop(Runnable launchable) {\n+        processor.invokeLater(launchable);\n+        Thread eventThread = new Thread(processor);\n+        setEventThread(eventThread);\n+        eventThread.start();\n+    }\n+\n+    @Override\n+    protected void _invokeAndWait(Runnable runnable) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected void _invokeLater(Runnable runnable) {\n+        processor.invokeLater(runnable);\n+    }\n+\n+    @Override\n+    protected Object _enterNestedEventLoop() {\n+        return processor.newRunLoop();\n+    }\n+\n+    @Override\n+    protected void _leaveNestedEventLoop(Object retValue) {\n+        processor.leaveCurrentLoop(retValue);\n+    }\n+\n+    @Override\n+    protected int _isKeyLocked(int keyCode) {\n+        return KeyEvent.KEY_LOCK_OFF;\n+    }\n+\n+    @Override\n+    public Window createWindow(Window owner, Screen screen, int styleMask) {\n+        HeadlessWindow window = new HeadlessWindow(windowManager, owner, screen, frameBuffer, styleMask);\n+        if (this.activeRobot != null) {\n+            activeRobot.windowAdded(window);\n+            window.setRobot(this.activeRobot);\n+        }\n+        return window;\n+    }\n+\n+    @Override\n+    public View createView() {\n+        return new HeadlessView();\n+    }\n+\n+    @Override\n+    public Cursor createCursor(int type) {\n+        this.cursor = new HeadlessCursor(type);\n+        return this.cursor;\n+    }\n+\n+    @Override\n+    public Cursor createCursor(int x, int y, Pixels pixels) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected void staticCursor_setVisible(boolean visible) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected Size staticCursor_getBestSize(int width, int height) {\n+        return new Size(16, 16);\n+    }\n+\n+    @Override\n+    public Pixels createPixels(int width, int height, ByteBuffer data) {\n+        return new HeadlessPixels(width, height, data);\n+    }\n+\n+    @Override\n+    public Pixels createPixels(int width, int height, ByteBuffer data, float scalex, float scaley) {\n+        return new HeadlessPixels(width, height, data, scalex, scaley);\n+    }\n+\n+    @Override\n+    public Pixels createPixels(int width, int height, IntBuffer data) {\n+        return new HeadlessPixels(width, height, data);\n+    }\n+\n+    @Override\n+    public Pixels createPixels(int width, int height, IntBuffer data, float scalex, float scaley) {\n+        return new HeadlessPixels(width, height, data, scalex, scaley);\n+    }\n+\n+    @Override\n+    protected int staticPixels_getNativeFormat() {\n+        return Pixels.Format.BYTE_BGRA_PRE;\n+    }\n+\n+    @Override\n+    public GlassRobot createRobot() {\n+        this.activeRobot = new HeadlessRobot(this);\n+        return this.activeRobot;\n+    }\n+\n+    @Override\n+    protected double staticScreen_getVideoRefreshPeriod() {\n+        return 0.;\n+    }\n+\n+    @Override\n+    protected Screen[] staticScreen_getScreens() {\n+        final int screenWidth = 1000;\n+        final int screenHeight = 1000;\n+        if (this.screens == null) {\n+            float scaleX = 1.f;\n+            float scaleY = 1.f;\n+            String scale = System.getProperty(\"glass.gtk.uiScale\");\n+            if (scale != null && !scale.isBlank()) {\n+                float scaleFloat = Float.parseFloat(scale);\n+                scaleX = scaleFloat;\n+                scaleY = scaleFloat;\n+            }\n+            Screen screen = new Screen(0, 32, 0, 0, screenWidth, screenHeight, 0, 0, screenWidth, screenHeight, 0, 0, screenWidth, screenHeight, 100, 100, 1f, 1f, scaleX, scaleY);\n+            this.screens = new Screen[1];\n+            this.screens[0] = screen;\n+            this.frameBuffer = ByteBuffer.allocate(screen.getWidth() * screen.getHeight() * 4);\n+        }\n+        return this.screens;\n+    }\n+\n+    @Override\n+    public Timer createTimer(Runnable runnable) {\n+        return new HeadlessTimer(runnable);\n+    }\n+\n+    @Override\n+    protected int staticTimer_getMinPeriod() {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected int staticTimer_getMaxPeriod() {\n+        return 1_000_000;\n+    }\n+\n+    @Override\n+    protected CommonDialogs.FileChooserResult staticCommonDialogs_showFileChooser(Window owner, String folder, String filename, String title, int type, boolean multipleMode, CommonDialogs.ExtensionFilter[] extensionFilters, int defaultFilterIndex) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected File staticCommonDialogs_showFolderChooser(Window owner, String folder, String title) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected long staticView_getMultiClickTime() {\n+        return MULTICLICK_TIME;\n+    }\n+\n+    @Override\n+    protected int staticView_getMultiClickMaxX() {\n+        return MULTICLICK_MAX_X;\n+    }\n+\n+    @Override\n+    protected int staticView_getMultiClickMaxY() {\n+        return MULTICLICK_MAX_Y;\n+    }\n+\n+    @Override\n+    protected boolean _supportsTransparentWindows() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean _supportsUnifiedWindows() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean _supportsExtendedWindows() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected int _getKeyCodeForChar(char c, int hint) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessApplication.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.ui.Cursor;\n+import com.sun.glass.ui.Pixels;\n+\n+public class HeadlessCursor extends Cursor {\n+\n+     HeadlessCursor(int type) {\n+        super(type);\n+    }\n+\n+    @Override\n+    protected long _createCursor(int x, int y, Pixels pixels) {\n+        return 1;\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessCursor.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.ui.Pixels;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+\n+public class HeadlessPixels extends Pixels {\n+\n+    HeadlessPixels(int width, int height, ByteBuffer data) {\n+        super(width, height, data);\n+    }\n+\n+    HeadlessPixels(int width, int height, ByteBuffer data, float scalex, float scaley) {\n+        super(width, height, data, scalex, scaley);\n+    }\n+\n+    HeadlessPixels(int width, int height, IntBuffer data) {\n+        super(width, height, data);\n+    }\n+\n+    HeadlessPixels(int width, int height, IntBuffer data, float scalex, float scaley) {\n+        super(width, height, data, scalex, scaley);\n+    }\n+\n+    @Override\n+    protected void _fillDirectByteBuffer(ByteBuffer bb) {\n+        bb.put(this.bytes);\n+    }\n+\n+    @Override\n+    protected void _attachInt(long ptr, int w, int h, IntBuffer ints, int[] array, int offset) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected void _attachByte(long ptr, int w, int h, ByteBuffer bytes, byte[] array, int offset) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessPixels.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.ui.Application;\n+import com.sun.glass.ui.Clipboard;\n+import com.sun.glass.ui.Menu;\n+import com.sun.glass.ui.MenuBar;\n+import com.sun.glass.ui.MenuItem;\n+import com.sun.glass.ui.PlatformFactory;\n+import com.sun.glass.ui.SystemClipboard;\n+import com.sun.glass.ui.delegate.ClipboardDelegate;\n+import com.sun.glass.ui.delegate.MenuBarDelegate;\n+import com.sun.glass.ui.delegate.MenuDelegate;\n+import com.sun.glass.ui.delegate.MenuItemDelegate;\n+import java.util.HashMap;\n+\n+public class HeadlessPlatformFactory extends PlatformFactory {\n+\n+    @Override\n+    public Application createApplication() {\n+        return new HeadlessApplication();\n+    }\n+\n+    @Override\n+    public MenuBarDelegate createMenuBarDelegate(MenuBar menubar) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public MenuDelegate createMenuDelegate(Menu menu) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public MenuItemDelegate createMenuItemDelegate(MenuItem menuItem) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    public ClipboardDelegate createClipboardDelegate() {\n+        return (String clipboardName) -> {\n+            if (Clipboard.SYSTEM.equals(clipboardName)) {\n+                return new HeadlessSystemClipboard();\n+            } else if (Clipboard.DND.equals(clipboardName)) {\n+                return new HeadlessDnDClipboard();\n+            } else {\n+                throw new IllegalArgumentException(\"No support for \" + clipboardName + \" clipboard in headless\");\n+            }\n+        };\n+\n+    }\n+\n+    class HeadlessSystemClipboard extends SystemClipboard {\n+\n+        HashMap<String, Object> cacheData;\n+        int supportedActions;\n+\n+        HeadlessSystemClipboard() {\n+            super(Clipboard.SYSTEM);\n+        }\n+\n+        @Override\n+        protected boolean isOwner() {\n+            return true;\n+        }\n+\n+        @Override\n+        protected void pushToSystem(HashMap<String, Object> cacheData, int supportedActions) {\n+            this.cacheData = cacheData;\n+            this.supportedActions = supportedActions;\n+        }\n+\n+        @Override\n+        protected void pushTargetActionToSystem(int actionDone) {\n+        }\n+\n+        @Override\n+        protected Object popFromSystem(String mimeType) {\n+            return null;\n+        }\n+\n+        @Override\n+        protected int supportedSourceActionsFromSystem() {\n+            return Clipboard.ACTION_NONE;\n+        }\n+\n+        @Override\n+        protected String[] mimesFromSystem() {\n+            return new String[0];\n+        }\n+    }\n+\n+    class HeadlessDnDClipboard extends SystemClipboard {\n+\n+        HeadlessDnDClipboard() {\n+            super(Clipboard.DND);\n+        }\n+\n+        @Override\n+        protected boolean isOwner() {\n+            throw new UnsupportedOperationException(\"Not supported yet.\");\n+        }\n+\n+        @Override\n+        protected void pushToSystem(HashMap<String, Object> cacheData, int supportedActions) {\n+            throw new UnsupportedOperationException(\"Not supported yet.\");\n+        }\n+\n+        @Override\n+        protected void pushTargetActionToSystem(int actionDone) {\n+            throw new UnsupportedOperationException(\"Not supported yet.\");\n+        }\n+\n+        @Override\n+        protected Object popFromSystem(String mimeType) {\n+            throw new UnsupportedOperationException(\"Not supported yet.\");\n+        }\n+\n+        @Override\n+        protected int supportedSourceActionsFromSystem() {\n+            throw new UnsupportedOperationException(\"Not supported yet.\");\n+        }\n+\n+        @Override\n+        protected String[] mimesFromSystem() {\n+            throw new UnsupportedOperationException(\"Not supported yet.\");\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessPlatformFactory.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,399 @@\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.events.KeyEvent;\n+import com.sun.glass.events.MouseEvent;\n+import com.sun.glass.ui.Application;\n+import com.sun.glass.ui.GlassRobot;\n+import com.sun.glass.ui.Window;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import javafx.scene.image.WritableImage;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.MouseButton;\n+import javafx.scene.paint.Color;\n+\n+public class HeadlessRobot extends GlassRobot {\n+\n+    final int multiplierX = 40;\n+    final int multiplierY = 40;\n+    private final HeadlessApplication application;\n+    private Window activeWindow = null;\n+\n+    private double mouseX, mouseY;\n+\n+    private final SpecialKeys specialKeys = new SpecialKeys();\n+    private final MouseState mouseState = new MouseState();\n+    private final char[] NO_CHAR = { };\n+\n+    public HeadlessRobot(HeadlessApplication application) {\n+        this.application = application;\n+    }\n+\n+    void windowAdded(HeadlessWindow window) {\n+        if (this.activeWindow == null) activeWindow = window;\n+    }\n+\n+    void windowRemoved(HeadlessWindow window) {\n+        if (this.activeWindow == window) activeWindow = null;\n+    }\n+\n+    @Override\n+    public void create() {\n+    }\n+\n+    @Override\n+    public void destroy() {\n+    }\n+\n+    @Override\n+    public void keyPress(KeyCode keyCode) {\n+        checkWindowFocused();\n+        if (activeWindow == null) return;\n+        HeadlessView view = (HeadlessView)activeWindow.getView();\n+        int code = keyCode.getCode();\n+        processSpecialKeys(code, true);\n+        char[] keyval = getKeyChars(code);\n+        int mods = getKeyModifiers();\n+        if (view != null) {\n+            view.notifyKey(KeyEvent.PRESS, code, keyval, mods);\n+            if (keyval.length > 0) {\n+                view.notifyKey(KeyEvent.TYPED, 0, keyval, mods);\n+            }\n+\n+        }\n+    }\n+\n+    @Override\n+    public void keyRelease(KeyCode keyCode) {\n+        checkWindowFocused();\n+        if (activeWindow == null) return;\n+        HeadlessView view = (HeadlessView)activeWindow.getView();\n+        int code = keyCode.getCode();\n+        processSpecialKeys(code, false);\n+        int mods = getKeyModifiers();\n+        char[] keyval = new char[1];\n+        keyval[0] = (char) code;\n+        if (view != null) {\n+            view.notifyKey(KeyEvent.RELEASE, code, keyval, mods);\n+        }\n+    }\n+\n+    @Override\n+    public double getMouseX() {\n+        return this.mouseX;\n+    }\n+\n+    @Override\n+    public double getMouseY() {\n+        return this.mouseY;\n+    }\n+\n+    @Override\n+    public void mouseMove(double x, double y) {\n+        this.mouseX = x;\n+        this.mouseY = y;\n+        checkWindowEnterExit();\n+        if (activeWindow == null) return;\n+        HeadlessView view = (HeadlessView)activeWindow.getView();\n+        if (view == null) return;\n+        int wx = activeWindow.getX();\n+        int wy = activeWindow.getY();\n+        int buttonEvent = MouseEvent.BUTTON_NONE;\n+        int mouseEvent = MouseEvent.MOVE;\n+        if (mouseState.pressedButtons.size() > 0) {\n+            MouseButton button = mouseState.pressedButtons.stream().findFirst().get();\n+            buttonEvent = getGlassEventButton(button);\n+            mouseEvent = MouseEvent.DRAG;\n+        }\n+        int modifiers = 0;\n+        view.notifyMouse(mouseEvent, buttonEvent, (int)mouseX-wx, (int)mouseY-wy, (int)mouseX, (int)mouseY, modifiers, false, false);\n+    }\n+\n+    @Override\n+    public void mousePress(MouseButton... buttons) {\n+        Application.checkEventThread();\n+        mouseState.pressedButtons.addAll(Arrays.asList(buttons));\n+        checkWindowEnterExit();\n+        HeadlessView view = (HeadlessView)activeWindow.getView();\n+        if (view == null) {\n+            view = (HeadlessView)activeWindow.getView();\n+            if (view == null) {\n+                return;\n+            }\n+        }\n+        int wx = activeWindow.getX();\n+        int wy = activeWindow.getY();\n+        int modifiers = getModifiers(buttons);\n+        view.notifyMouse(MouseEvent.DOWN, getGlassEventButton(buttons), (int)mouseX-wx, (int)mouseY-wy, (int)mouseX, (int)mouseY, modifiers, true, true);\n+        int buttonCode = getGlassEventButton(buttons);\n+        view.notifyMouse(MouseEvent.DOWN, buttonCode, (int)mouseX-wx, (int)mouseY-wy, (int)mouseX, (int)mouseY, modifiers, true, true);\n+        if (buttonCode == MouseEvent.BUTTON_RIGHT) {\n+            view.notifyMenu((int)mouseX-wx, (int)mouseY-wy, (int)mouseX, (int)mouseY, false);\n+        }\n+    }\n+\n+    @Override\n+    public void mouseRelease(MouseButton... buttons) {\n+        Application.checkEventThread();\n+        mouseState.pressedButtons.removeAll(Arrays.asList(buttons));\n+        checkWindowEnterExit();\n+        if (this.activeWindow == null) {\n+            return;\n+        }\n+        HeadlessView view = (HeadlessView) activeWindow.getView();\n+        int wx = activeWindow.getX();\n+        int wy = activeWindow.getY();\n+        int modifiers = getModifiers(buttons);\n+        view.notifyMouse(MouseEvent.UP, getGlassEventButton(buttons), (int) mouseX - wx, (int) mouseY - wy, (int) mouseX, (int) mouseY, modifiers, true, true);\n+    }\n+\n+    @Override\n+    public void mouseWheel(int wheelAmt) {\n+        checkWindowFocused();\n+\n+        final int dff = wheelAmt > 0 ? -1 : 1;\n+        HeadlessView view = (HeadlessView) activeWindow.getView();\n+\n+        int wx = activeWindow.getX();\n+        int wy = activeWindow.getY();\n+        int repeat = Math.abs(wheelAmt);\n+        for (int i = 0; i < repeat; i++) {\n+            view.notifyScroll((int) mouseX, (int) mouseY, wx, wy, 0, dff, 0, 0, 0, 0, 0, multiplierX, multiplierY);\n+        }\n+    }\n+\n+    @Override\n+    public Color getPixelColor(double x, double y) {\n+        HeadlessWindow topWindow = getTopWindow();\n+        return topWindow.getColor((int)x, (int) y);\n+    }\n+\n+    @Override\n+    public WritableImage getScreenCapture(WritableImage image, double x, double y, double width, double height, boolean scaleToFit) {\n+        return super.getScreenCapture(image, x, y, width, height, scaleToFit);\n+    }\n+\n+    @Override\n+    public void getScreenCapture(int x, int y, int width, int height, int[] data, boolean scaleToFit) {\n+        checkWindowFocused();\n+        ((HeadlessWindow)activeWindow).getScreenCapture(x, y, width, height, data, scaleToFit);\n+    }\n+\n+    private void checkActiveWindowExists() {\n+        if ((this.activeWindow != null) && (!this.activeWindow.isVisible())) {\n+            this.activeWindow = null;\n+        }\n+    }\n+    private void checkWindowFocused() {\n+        checkActiveWindowExists();\n+        this.activeWindow = getFocusedWindow();\n+    }\n+\n+    private void checkWindowEnterExit() {\n+        checkActiveWindowExists();\n+        Window oldWindow = activeWindow;\n+        this.activeWindow = getTargetWindow(this.mouseX, this.mouseY);\n+\n+        if (this.activeWindow == null) {\n+            if (oldWindow != null) {\n+                HeadlessView oldView = (HeadlessView)oldWindow.getView();\n+                if (oldView != null) {\n+                    oldView.notifyMouse(MouseEvent.EXIT, MouseEvent.BUTTON_NONE, 0, 0,0,0, 0, true, true);\n+                }\n+            }\n+            return;\n+        }\n+        int wx = activeWindow.getX();\n+        int wy = activeWindow.getY();\n+\n+        if (activeWindow != oldWindow) {\n+            HeadlessView view = (HeadlessView)activeWindow.getView();\n+            int modifiers = 0;\n+            view.notifyMouse(MouseEvent.ENTER, MouseEvent.BUTTON_NONE, (int)mouseX-wx, (int)mouseY-wy, (int)mouseX, (int)mouseY, modifiers, true, true);\n+            if (oldWindow != null) {\n+                HeadlessView oldView = (HeadlessView)oldWindow.getView();\n+                if (oldView != null) {\n+                    int owx = oldWindow.getX();\n+                    int owy = oldWindow.getY();\n+                    oldView.notifyMouse(MouseEvent.EXIT, MouseEvent.BUTTON_NONE, (int)mouseX-owx, (int)mouseY-owy, (int)mouseX, (int)mouseY, modifiers, true, true);\n+                }\n+            }\n+        }\n+    }\n+\n+    private HeadlessWindow getTopWindow() {\n+        List<Window> windows = Window.getWindows().stream()\n+                .filter(win -> win.getView() != null)\n+                .filter(win -> !win.isClosed())\n+                .filter(win -> !win.isMinimized()).toList();\n+        if (windows.isEmpty()) return null;\n+        if (windows.size() == 1) return (HeadlessWindow)windows.get(0);\n+        return (HeadlessWindow)windows.get(windows.size() -1);\n+    }\n+\n+    private HeadlessWindow getFocusedWindow() {\n+        List<Window> windows = Window.getWindows().stream()\n+                .filter(win -> win.getView()!= null)\n+                .filter(win -> !win.isClosed())\n+                .filter(win -> win.isFocused()).toList();\n+        if (windows.isEmpty()) return null;\n+        if (windows.size() == 1) return (HeadlessWindow)windows.get(0);\n+        return (HeadlessWindow)windows.get(windows.size() -1);\n+    }\n+\n+    private HeadlessWindow getTargetWindow(double x, double y) {\n+        List<Window> windows = Window.getWindows().stream()\n+                .filter(win -> win.getView()!= null)\n+                .filter(win -> !win.isClosed())\n+                .filter(win -> (x >= win.getX() && x <= win.getX() + win.getWidth()\n+                        && y >= win.getY() && y <= win.getY()+ win.getHeight())).toList();\n+        if (windows.isEmpty()) {\n+            return null;\n+        }\n+        if (windows.size() == 1) return (HeadlessWindow)windows.get(0);\n+        return (HeadlessWindow)windows.get(windows.size() -1);\n+    }\n+\n+    int getModifiers(MouseButton... buttons) {\n+        int modifiers = KeyEvent.MODIFIER_NONE;\n+        for (int i = 0; i < buttons.length; i++) {\n+            modifiers |= switch (buttons[i]) {\n+                case NONE -> KeyEvent.MODIFIER_NONE;\n+                case PRIMARY -> KeyEvent.MODIFIER_BUTTON_PRIMARY;\n+                case MIDDLE -> KeyEvent.MODIFIER_BUTTON_MIDDLE;\n+                case SECONDARY -> KeyEvent.MODIFIER_BUTTON_SECONDARY;\n+                case BACK -> KeyEvent.MODIFIER_BUTTON_BACK;\n+                case FORWARD -> KeyEvent.MODIFIER_BUTTON_FORWARD;\n+            };\n+        }\n+        return modifiers;\n+    }\n+\n+    int getGlassEventButton(MouseButton[] buttons) {\n+        if ((buttons == null) || (buttons.length == 0)) return 0;\n+        return getGlassEventButton(buttons[0]);\n+    }\n+\n+    int getGlassEventButton(MouseButton button) {\n+        return switch (button) {\n+            case NONE -> MouseEvent.BUTTON_NONE;\n+            case PRIMARY -> MouseEvent.BUTTON_LEFT;\n+            case MIDDLE -> MouseEvent.BUTTON_OTHER;\n+            case SECONDARY -> MouseEvent.BUTTON_RIGHT;\n+            case BACK -> MouseEvent.BUTTON_BACK;\n+            case FORWARD -> MouseEvent.BUTTON_FORWARD;\n+        };\n+    }\n+\n+    private void processSpecialKeys(int c, boolean on) {\n+        if (c == KeyEvent.VK_CONTROL) {\n+            this.specialKeys.keyControl = on;\n+        }\n+        if (c == KeyEvent.VK_SHIFT) {\n+            this.specialKeys.keyShift = on;\n+        }\n+        if (c == KeyEvent.VK_COMMAND) {\n+            this.specialKeys.keyCommand = on;\n+        }\n+        if (c == KeyEvent.VK_ALT) {\n+            this.specialKeys.keyAlt = on;\n+        }\n+    }\n+    private char[] getKeyChars(int key) {\n+        char c = '\\000';\n+        boolean shifted = this.specialKeys.keyShift;\n+        \/\/ TODO: implement configurable keyboard mappings.\n+        \/\/ The following is only for US keyboards\n+        if (key >= KeyEvent.VK_A && key <= KeyEvent.VK_Z) {\n+            shifted ^= this.specialKeys.capsLock;\n+            if (shifted) {\n+                c = (char) (key - KeyEvent.VK_A + 'A');\n+            } else {\n+                c = (char) (key - KeyEvent.VK_A + 'a');\n+            }\n+        } else if (key >= KeyEvent.VK_NUMPAD0 && key <= KeyEvent.VK_NUMPAD9) {\n+            if (this.specialKeys.numLock) {\n+                c = (char) (key - KeyEvent.VK_NUMPAD0 + '0');\n+            }\n+        } else if (key >= KeyEvent.VK_0 && key <= KeyEvent.VK_9) {\n+            if (shifted) {\n+                switch (key) {\n+                    case KeyEvent.VK_0: c = ')'; break;\n+                    case KeyEvent.VK_1: c = '!'; break;\n+                    case KeyEvent.VK_2: c = '@'; break;\n+                    case KeyEvent.VK_3: c = '#'; break;\n+                    case KeyEvent.VK_4: c = '$'; break;\n+                    case KeyEvent.VK_5: c = '%'; break;\n+                    case KeyEvent.VK_6: c = '^'; break;\n+                    case KeyEvent.VK_7: c = '&'; break;\n+                    case KeyEvent.VK_8: c = '*'; break;\n+                    case KeyEvent.VK_9: c = '('; break;\n+                }\n+            } else {\n+                c = (char) (key - KeyEvent.VK_0 + '0');\n+            }\n+        } else if (key == KeyEvent.VK_SPACE) {\n+            c = ' ';\n+        } else if (key == KeyEvent.VK_TAB) {\n+            c = '\\t';\n+        } else if (key == KeyEvent.VK_ENTER) {\n+            c = (char)13;\n+        } else if (key == KeyEvent.VK_MULTIPLY) {\n+            c = '*';\n+        } else if (key == KeyEvent.VK_DIVIDE) {\n+            c = '\/';\n+        } else if (shifted) {\n+            switch (key) {\n+                case KeyEvent.VK_BACK_QUOTE: c = '~'; break;\n+                case KeyEvent.VK_COMMA: c = '<'; break;\n+                case KeyEvent.VK_PERIOD: c = '>'; break;\n+                case KeyEvent.VK_SLASH: c = '?'; break;\n+                case KeyEvent.VK_SEMICOLON: c = ':'; break;\n+                case KeyEvent.VK_QUOTE: c = '\\\"'; break;\n+                case KeyEvent.VK_BRACELEFT: c = '{'; break;\n+                case KeyEvent.VK_BRACERIGHT: c = '}'; break;\n+                case KeyEvent.VK_BACK_SLASH: c = '|'; break;\n+                case KeyEvent.VK_MINUS: c = '_'; break;\n+                case KeyEvent.VK_EQUALS: c = '+'; break;\n+            }        } else {\n+            switch (key) {\n+                case KeyEvent.VK_BACK_QUOTE: c = '`'; break;\n+                case KeyEvent.VK_COMMA: c = ','; break;\n+                case KeyEvent.VK_PERIOD: c = '.'; break;\n+                case KeyEvent.VK_SLASH: c = '\/'; break;\n+                case KeyEvent.VK_SEMICOLON: c = ';'; break;\n+                case KeyEvent.VK_QUOTE: c = '\\''; break;\n+                case KeyEvent.VK_BRACELEFT: c = '['; break;\n+                case KeyEvent.VK_BRACERIGHT: c = ']'; break;\n+                case KeyEvent.VK_BACK_SLASH: c = '\\\\'; break;\n+                case KeyEvent.VK_MINUS: c = '-'; break;\n+                case KeyEvent.VK_EQUALS: c = '='; break;\n+            }\n+        }\n+        return c == '\\000' ? NO_CHAR : new char[] { c };\n+    }\n+\n+\n+    private int getKeyModifiers() {\n+        int answer = 0;\n+        if (this.specialKeys.keyControl) answer = answer | KeyEvent.MODIFIER_CONTROL;\n+        if (this.specialKeys.keyShift) answer = answer | KeyEvent.MODIFIER_SHIFT;\n+        if (this.specialKeys.keyCommand) answer = answer | KeyEvent.MODIFIER_COMMAND;\n+        if (this.specialKeys.keyAlt) answer = answer | KeyEvent.MODIFIER_ALT;\n+        return answer;\n+    }\n+\n+    class SpecialKeys {\n+        boolean keyControl;\n+        boolean keyShift;\n+        boolean keyCommand;\n+        boolean keyAlt;\n+        boolean capsLock;\n+        boolean numLock;\n+    }\n+\n+    class MouseState {\n+        final HashSet<MouseButton> pressedButtons = new HashSet<>();\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessRobot.java","additions":399,"deletions":0,"binary":false,"changes":399,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.ui.Timer;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+public class HeadlessTimer extends Timer {\n+\n+    private static ScheduledThreadPoolExecutor scheduler;\n+    private ScheduledFuture task;\n+\n+    HeadlessTimer(final Runnable runnable) {\n+        super(runnable);\n+    }\n+\n+    @Override\n+    protected long _start(Runnable runnable) {\n+        throw new RuntimeException(\"vsync timer not supported\");\n+    }\n+\n+    @Override\n+    protected long _start(Runnable runnable, int period) {\n+        if (scheduler == null) {\n+            scheduler = new ScheduledThreadPoolExecutor(1, target -> {\n+                Thread thread = new Thread(target, \"Headless Timer\");\n+                thread.setDaemon(true);\n+                return thread;\n+            });\n+        }\n+        task = scheduler.scheduleAtFixedRate(runnable, 0, period, TimeUnit.MILLISECONDS);\n+        return 1;\n+\n+    }\n+\n+    @Override\n+    protected void _stop(long timer) {\n+        if (task != null) {\n+            task.cancel(false);\n+            task = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void _pause(long timer) {\n+    }\n+\n+    @Override\n+    protected void _resume(long timer) {\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessTimer.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.events.ViewEvent;\n+import com.sun.glass.ui.Pixels;\n+import com.sun.glass.ui.View;\n+import java.util.Map;\n+\n+public class HeadlessView extends View {\n+\n+    private Map capabilities;\n+    private int x = 0;\n+    private int y = 0;\n+    private long parentPtr = 0;\n+    private Pixels pixels;\n+\n+    private boolean imeEnabled;\n+\n+    @Override\n+    protected void _enableInputMethodEvents(long ptr, boolean enable) {\n+        this.imeEnabled = enable;\n+    }\n+\n+    @Override\n+    protected long _create(Map capabilities) {\n+        this.capabilities = capabilities;\n+        return 1;\n+    }\n+\n+    @Override\n+    protected long _getNativeView(long ptr) {\n+        return ptr;\n+    }\n+\n+    @Override\n+    protected int _getX(long ptr) {\n+        return x;\n+    }\n+\n+    @Override\n+    protected int _getY(long ptr) {\n+        return y;\n+    }\n+\n+    @Override\n+    protected void _setParent(long ptr, long parentPtr) {\n+        parentPtr = parentPtr;\n+    }\n+\n+    @Override\n+    protected boolean _close(long ptr) {\n+        return true;\n+    }\n+\n+    @Override\n+    protected void _scheduleRepaint(long ptr) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected void _begin(long ptr) {\n+    }\n+\n+    @Override\n+    protected void _end(long ptr) {\n+    }\n+\n+    @Override\n+    protected int _getNativeFrameBuffer(long ptr) {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected void _uploadPixels(long ptr, Pixels pixels) {\n+        HeadlessWindow window = (HeadlessWindow)this.getWindow();\n+        this.pixels = pixels;\n+        window.blit(pixels);\n+    }\n+\n+    Pixels getPixels() {\n+        return this.pixels;\n+    }\n+\n+    @Override\n+    protected boolean _enterFullscreen(long ptr, boolean animate, boolean keepRatio, boolean hideCursor) {\n+        HeadlessWindow window = (HeadlessWindow)this.getWindow();\n+        window.setFullscreen(true);\n+        notifyView(ViewEvent.FULLSCREEN_ENTER);\n+        return true;\n+    }\n+\n+    @Override\n+    protected void _exitFullscreen(long ptr, boolean animate) {\n+        HeadlessWindow window = (HeadlessWindow)this.getWindow();\n+        if (window != null) {\n+            window.setFullscreen(false);\n+        }\n+        notifyView(ViewEvent.FULLSCREEN_EXIT);\n+    }\n+\n+    @Override\n+    protected void notifyResize(int width, int height) {\n+        super.notifyResize(width, height);\n+    }\n+\n+    @Override\n+    protected void notifyMouse(int type, int button, int x, int y, int xAbs, int yAbs, int modifiers, boolean isPopupTrigger, boolean isSynthesized) {\n+        super.notifyMouse(type, button, x, y, xAbs, yAbs, modifiers, isPopupTrigger, isSynthesized);\n+    }\n+\n+    @Override\n+    protected void notifyMenu(int x, int y, int xAbs, int yAbs, boolean isKeyboardTrigger) {\n+        super.notifyMenu(x, y, xAbs, yAbs, isKeyboardTrigger);\n+    }\n+\n+    @Override\n+    protected void notifyScroll(int x, int y, int xAbs, int yAbs, double deltaX, double deltaY, int modifiers, int lines, int chars, int defaultLines, int defaultChars, double xMultiplier, double yMultiplier) {\n+        super.notifyScroll(x, y, xAbs, yAbs, deltaX, deltaY, modifiers, lines, chars, defaultLines, defaultChars, xMultiplier, yMultiplier);\n+    }\n+\n+    @Override\n+    protected void notifyKey(int type, int keyCode, char[] keyChars, int modifiers) {\n+        super.notifyKey(type, keyCode, keyChars, modifiers);\n+    }\n+\n+    @Override\n+    protected void notifyRepaint(int x, int y, int width, int height) {\n+        super.notifyRepaint(x, y, width, height);\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessView.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,370 @@\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.events.MouseEvent;\n+import com.sun.glass.events.WindowEvent;\n+import com.sun.glass.ui.Cursor;\n+import com.sun.glass.ui.Pixels;\n+import com.sun.glass.ui.Screen;\n+import com.sun.glass.ui.View;\n+import com.sun.glass.ui.Window;\n+import java.nio.Buffer;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javafx.scene.paint.Color;\n+\n+public class HeadlessWindow extends Window {\n+\n+    private static final AtomicInteger ptrCount = new AtomicInteger(0);\n+    private long ptr;\n+    private final HeadlessWindowManager windowManager;\n+\n+    private int minWidth;\n+    private int minHeight;\n+    private int maxWidth = -1;\n+    private int maxHeight = -1;\n+    private int originalX, originalY, originalWidth, originalHeight;\n+\n+    private boolean resizable;\n+    private boolean visible;\n+    private boolean isFocusable;\n+    private boolean enabled;\n+    private boolean closed;\n+    private float bg_r, bg_g, bg_b;\n+    private float alpha;\n+    private Pixels icon;\n+    private Cursor cursor;\n+    private final ByteBuffer frameBuffer;\n+    private HeadlessView currentView;\n+    private HeadlessRobot robot;\n+\n+    public HeadlessWindow(HeadlessWindowManager wm, Window owner, Screen screen, ByteBuffer frameBuffer, int styleMask) {\n+        super(owner, screen, styleMask);\n+        this.frameBuffer = frameBuffer;\n+        this.windowManager = wm;\n+    }\n+\n+    @Override\n+    protected long _createWindow(long ownerPtr, long screenPtr, int mask) {\n+        this.ptr = ptrCount.incrementAndGet();\n+        return ptr;\n+    }\n+\n+    @Override\n+    protected boolean _close(long ptr) {\n+        this.closed = true;\n+        this.notifyDestroy();\n+        if (this.robot != null) {\n+            this.robot.windowRemoved(this);\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean _setView(long ptr, View view) {\n+        if (currentView != null) {\n+            currentView.notifyMouse(MouseEvent.EXIT, MouseEvent.BUTTON_NONE, 0, 0, 0, 0, 0, false, false);\n+        }\n+        this.currentView = (HeadlessView) view;\n+        if (currentView != null) {\n+            currentView.notifyMouse(MouseEvent.ENTER, MouseEvent.BUTTON_NONE, 0, 0, 0, 0, 0, false, false);\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    protected void _updateViewSize(long ptr) {\n+        if (this.isVisible()) {\n+            currentView.notifyResize(width, height);\n+        }\n+    }\n+\n+    @Override\n+    protected boolean _setMenubar(long ptr, long menubarPtr) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected boolean _minimize(long ptr, boolean minimize) {\n+        notifyResize(minimize ? WindowEvent.MINIMIZE : WindowEvent.RESTORE, width, height);\n+        windowManager.repaintAll();\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean _maximize(long ptr, boolean maximize, boolean wasMaximized) {\n+        int newX = 0;\n+        int newY = 0;\n+        int newWidth = 0;\n+        int newHeight = 0;\n+        if (maximize && !wasMaximized) {\n+            this.originalHeight = this.height;\n+            this.originalWidth = this.width;\n+            this.originalX = this.x;\n+            this.originalY = this.y;\n+            newX = 0;\n+            newY = 0;\n+            newWidth = screen.getWidth();\n+            newHeight = screen.getHeight();\n+            setState(State.MAXIMIZED);\n+        } else if (!maximize && wasMaximized) {\n+            newHeight = this.originalHeight;\n+            newWidth = this.originalWidth;\n+            newX = this.originalX;\n+            newY = this.originalY;\n+            setState(State.NORMAL);\n+        }\n+        notifyResizeAndMove(newX, newY, newWidth, newHeight);\n+        if (maximize) {\n+            notifyResize(WindowEvent.MAXIMIZE, newWidth, newHeight);\n+        }\n+\n+        return maximize;\n+    }\n+\n+    @Override\n+    protected void _setBounds(long ptr, int x, int y, boolean xSet, boolean ySet, int w, int h, int cw, int ch, float xGravity, float yGravity) {\n+        int newWidth = w > 0 ? w : cw > 0 ? cw : getWidth();\n+        int newHeight = h > 0 ? h : ch > 0 ? ch : getHeight();\n+        if (!xSet) {\n+            x = getX();\n+        }\n+        if (!ySet) {\n+            y = getY();\n+        }\n+        if (maxWidth >= 0) {\n+            newWidth = Math.min(newWidth, maxWidth);\n+        }\n+        if (maxHeight >= 0) {\n+            newHeight = Math.min(newHeight, maxHeight);\n+        }\n+        newWidth = Math.max(newWidth, minWidth);\n+        newHeight = Math.max(newHeight, minHeight);\n+        if (newWidth < getWidth()) {\n+            clearRect(getX() + newWidth, getWidth() - newWidth, getY(), getHeight());\n+        }\n+        if (newHeight < getHeight()) {\n+            clearRect(getX(), getWidth(), getY() + newHeight, getHeight() - newHeight);\n+        }\n+        notifyResizeAndMove(x, y, newWidth, newHeight);\n+    }\n+\n+    @Override\n+    protected boolean _setVisible(long ptr, boolean v) {\n+        this.visible = v;\n+        return this.visible;\n+    }\n+\n+    @Override\n+    protected boolean _setResizable(long ptr, boolean resizable) {\n+        this.resizable = resizable;\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean _requestFocus(long ptr, int event) {\n+        this.notifyFocus(event);\n+        return this.isFocused();\n+    }\n+\n+    @Override\n+    protected void _setFocusable(long ptr, boolean isFocusable) {\n+        this.isFocusable = isFocusable;\n+    }\n+\n+    @Override\n+    protected boolean _grabFocus(long ptr) {\n+        return true;\n+    }\n+\n+    @Override\n+    protected void _ungrabFocus(long ptr) {\n+    }\n+\n+    @Override\n+    protected boolean _setTitle(long ptr, String title) {\n+        return true;\n+    }\n+\n+    @Override\n+    protected void _setLevel(long ptr, int level) {\n+    }\n+\n+    @Override\n+    protected void _setAlpha(long ptr, float alpha) {\n+        this.alpha = alpha;\n+    }\n+\n+    @Override\n+    protected boolean _setBackground(long ptr, float r, float g, float b) {\n+        this.bg_r = r;\n+        this.bg_g = g;\n+        this.bg_b = b;\n+        return true;\n+    }\n+\n+    @Override\n+    protected void _setEnabled(long ptr, boolean enabled) {\n+        this.enabled = enabled;\n+    }\n+\n+    @Override\n+    protected boolean _setMinimumSize(long ptr, int width, int height) {\n+        this.minWidth = width;\n+        this.minHeight = height;\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean _setMaximumSize(long ptr, int width, int height) {\n+        this.maxWidth = width;\n+        this.maxHeight = height;\n+        return true;\n+    }\n+\n+    @Override\n+    protected void _setIcon(long ptr, Pixels pixels) {\n+        this.icon = pixels;\n+    }\n+\n+    @Override\n+    protected void _setCursor(long ptr, Cursor cursor) {\n+        this.cursor = cursor;\n+    }\n+\n+    @Override\n+    protected void _toFront(long ptr) {\n+    }\n+\n+    @Override\n+    protected void _toBack(long ptr) {\n+    }\n+\n+    @Override\n+    protected void _enterModal(long ptr) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected void _enterModalWithWindow(long dialog, long window) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected void _exitModal(long ptr) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected void _requestInput(long ptr, String text, int type, double width, double height, double Mxx, double Mxy, double Mxz, double Mxt, double Myx, double Myy, double Myz, double Myt, double Mzx, double Mzy, double Mzz, double Mzt) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    @Override\n+    protected void _releaseInput(long ptr) {\n+        throw new UnsupportedOperationException(\"Not supported yet.\");\n+    }\n+\n+    boolean setFullscreen(boolean full) {\n+        int newX = 0;\n+        int newY = 0;\n+        int newWidth = 0;\n+        int newHeight = 0;\n+        if (full) {\n+            this.originalHeight = this.height;\n+            this.originalWidth = this.width;\n+            this.originalX = this.x;\n+            this.originalY = this.y;\n+            newX = 0;\n+            newY = 0;\n+            newWidth = screen.getWidth();\n+            newHeight = screen.getHeight();\n+        } else {\n+            newHeight = this.originalHeight;\n+            newWidth = this.originalWidth;\n+            newX = this.originalX;\n+            newY = this.originalY;\n+        }\n+        notifyResizeAndMove(newX, newY, newWidth, newHeight);\n+        return full;\n+    }\n+\n+    private void notifyResizeAndMove(int x, int y, int width, int height) {\n+        HeadlessView view = (HeadlessView) getView();\n+        \/\/   if (getWidth() != width || getHeight() != height) {\n+        notifyResize(WindowEvent.RESIZE, width, height);\n+        if (view != null) {\n+            view.notifyResize(width, height);\n+        }\n+        \/\/  }\n+        if (getX() != x || getY() != y) {\n+            notifyMove(x, y);\n+        }\n+    }\n+\n+    public Color getColor(int lx, int ly) {\n+        int mx = lx;\/\/ + getX();\n+        int my = ly;\/\/ + getY();\n+        int idx = 1000 * my + mx;\n+        int rgba = frameBuffer.asIntBuffer().get(idx);\n+        int a = (rgba >> 24) & 0xFF;\n+        int r = (rgba >> 16) & 0xFF;\n+        int g = (rgba >> 8) & 0xFF;\n+        int b = rgba & 0xFF;\n+\n+        Color color = Color.color(\n+                r \/ 255.0,\n+                g \/ 255.0,\n+                b \/ 255.0,\n+                a \/ 255.0\n+        );\n+        return color;\n+    }\n+\n+    public void getScreenCapture(int x, int y, int width, int height, int[] data, boolean scaleToFit) {\n+        for (int i = 0; i < height; i++) {\n+            for (int j = 0; j < width; j++) {\n+                int idx = i * width + j;\n+                int fidx = (y + i) * 1000 + x + j;\n+                int val = frameBuffer.asIntBuffer().get(fidx);\n+                data[idx] = val;\n+            }\n+        }\n+    }\n+\n+    void blit(Pixels pixels) {\n+        int pW = pixels.getWidth();\n+        int pH = pixels.getHeight();\n+        int offsetX = this.getX();\n+        int offsetY = this.getY();\n+        int stride = 1000;\n+\n+        IntBuffer intBuffer = (IntBuffer) pixels.getBuffer();\n+\n+        for (int i = 0; i < pixels.getHeight(); i++) {\n+            int rowIdx = offsetY + i;\n+            for (int j = 0; j < pixels.getWidth(); j++) {\n+                int idx = rowIdx * stride + offsetX + j;\n+                int val = intBuffer.get(i * pixels.getWidth() + j);\n+                if (val != 0) {\n+                }\n+                frameBuffer.asIntBuffer().put(idx, val);\n+            }\n+        }\n+    }\n+\n+    void clearRect(int x0, int w0, int y0, int h0) {\n+        int stride = 1000;\n+        for (int i = 0; i < h0; i++) {\n+            int rowIdx = y0 + i;\n+            for (int j = 0; j < w0; j++) {\n+                int idx = rowIdx * stride + x0 + j;\n+                frameBuffer.asIntBuffer().put(idx, 0);\n+            }\n+        }\n+    }\n+\n+    void setRobot(HeadlessRobot activeRobot) {\n+        this.robot = activeRobot;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessWindow.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.ui.Window;\n+import java.util.List;\n+\n+public class HeadlessWindowManager {\n+\n+    void repaintAll() {\n+        List<Window> windows = Window.getWindows().stream()\n+                .filter(win -> win.getView() != null)\n+                .filter(win -> !win.isClosed())\n+                .filter(win -> win.isVisible()).toList();\n+        for (Window win : windows) {\n+            if (win.isVisible() && (!win.isMinimized())) {\n+                HeadlessWindow hw = (HeadlessWindow) win;\n+                HeadlessView hv = (HeadlessView) hw.getView();\n+                hv.notifyRepaint(hw.getX(), hw.getY(), hw.getWidth(), hw.getHeight());\n+            }\n+        }\n+    }\n+\n+    private HeadlessWindow getFocusedWindow() {\n+        List<Window> windows = Window.getWindows().stream()\n+                .filter(win -> win.getView()!= null)\n+                .filter(win -> !win.isClosed())\n+                .filter(win -> win.isFocused()).toList();\n+        if (windows.isEmpty()) return null;\n+        if (windows.size() == 1) return (HeadlessWindow)windows.get(0);\n+        return (HeadlessWindow)windows.get(windows.size() -1);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/HeadlessWindowManager.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+package com.sun.glass.ui.headless;\n+\n+import com.sun.glass.ui.Application;\n+import java.util.LinkedList;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.LinkedBlockingQueue;\n+\n+public class NestedRunnableProcessor implements Runnable {\n+\n+    private final LinkedList<RunLoopEntry> activeRunLoops = new LinkedList<>();\n+\n+    private final BlockingQueue<Runnable> runnableQueue = new LinkedBlockingQueue<>();\n+\n+    @Override\n+    public void run() {\n+        newRunLoop();\n+    }\n+\n+    void invokeLater(final Runnable r) {\n+        runnableQueue.add(r);\n+    }\n+\n+    void runLater(Runnable r) {\n+        invokeLater(r);\n+    }\n+\n+    void invokeAndWait(final Runnable r) {\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        runnableQueue.add(() -> {\n+            try {\n+                r.run();\n+            } finally {\n+                latch.countDown();\n+            }\n+        });\n+        try {\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    void stopProcessing() {\n+        for (RunLoopEntry entry : activeRunLoops) {\n+            runnableQueue.add(() -> entry.active = false);\n+        }\n+    }\n+\n+    public Object newRunLoop() {\n+        RunLoopEntry entry = new RunLoopEntry();\n+\n+        activeRunLoops.push(entry);\n+\n+        entry.active = true;\n+        while (entry.active) {\n+            try {\n+                runnableQueue.take().run();\n+            } catch (Throwable e) {\n+                e.printStackTrace();\n+                Application.reportException(e);\n+            }\n+        }\n+        return entry.returnValue;\n+    }\n+\n+    public void leaveCurrentLoop(Object returnValue) {\n+        RunLoopEntry entry = activeRunLoops.pop();\n+        entry.active = false;\n+        entry.returnValue = returnValue;\n+    }\n+\n+    private static class RunLoopEntry {\n+\n+        boolean active;\n+        Object returnValue;\n+    }\n+\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/headless\/NestedRunnableProcessor.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}