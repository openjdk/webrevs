{"files":[{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"mfgstbuffer.h\"\n+\n+CMFGSTBuffer::CMFGSTBuffer(DWORD cbMaxLength)\n+{\n+    m_ulRefCount = 0;\n+\n+    m_ulLockCount = 0;\n+    InitializeCriticalSection(&m_csBufferLock);\n+\n+    m_cbMaxLength = cbMaxLength;\n+    m_cbCurrentLength = 0;\n+    m_pbBuffer = NULL;\n+\n+    m_pGstBuffer = NULL;\n+    m_bUnmapGstBuffer = FALSE;\n+\n+    ZeroMemory(&m_CallbackData, sizeof(sCallbackData));\n+    GetGstBufferCallback = NULL;\n+}\n+\n+CMFGSTBuffer::~CMFGSTBuffer()\n+{\n+    if (m_pbBuffer != NULL)\n+    {\n+        delete [] m_pbBuffer;\n+        m_pbBuffer = NULL;\n+    }\n+\n+    if (m_bUnmapGstBuffer)\n+    {\n+        gst_buffer_unmap(m_pGstBuffer, &m_GstMapInfo);\n+        m_bUnmapGstBuffer = FALSE;\n+    }\n+\n+    if (m_pGstBuffer != NULL)\n+    {\n+        \/\/ INLINE - gst_buffer_unref()\n+        gst_buffer_unref(m_pGstBuffer);\n+        m_pGstBuffer = NULL;\n+    }\n+\n+    DeleteCriticalSection(&m_csBufferLock);\n+}\n+\n+ \/\/ IMFMediaBuffer\n+HRESULT CMFGSTBuffer::GetCurrentLength(DWORD *pcbCurrentLength)\n+{\n+    if (pcbCurrentLength == NULL)\n+        return E_INVALIDARG;\n+\n+    (*pcbCurrentLength) = m_cbCurrentLength;\n+\n+    return S_OK;\n+}\n+\n+HRESULT CMFGSTBuffer::GetMaxLength(DWORD *pcbMaxLength)\n+{\n+    if (pcbMaxLength == NULL)\n+        return E_INVALIDARG;\n+\n+    (*pcbMaxLength) = m_cbMaxLength;\n+\n+    return S_OK;\n+}\n+\n+HRESULT CMFGSTBuffer::SetCurrentLength(DWORD cbCurrentLength)\n+{\n+    if (cbCurrentLength > m_cbMaxLength)\n+        return E_INVALIDARG;\n+\n+    m_cbCurrentLength = cbCurrentLength;\n+\n+    if (m_pGstBuffer)\n+        gst_buffer_set_size(m_pGstBuffer, cbCurrentLength);\n+\n+    return S_OK;\n+}\n+\n+HRESULT CMFGSTBuffer::Lock(BYTE **ppbBuffer, DWORD *pcbMaxLength, DWORD *pcbCurrentLength)\n+{\n+    HRESULT hr = E_FAIL;\n+\n+    if (ppbBuffer == NULL)\n+        return E_INVALIDARG;\n+\n+    if (m_cbMaxLength == 0)\n+        return E_INVALIDARG;\n+\n+    EnterCriticalSection(&m_csBufferLock);\n+    \/\/ Unlikely Lock() will be called in infinite loop.\n+    if (m_ulLockCount != ULONG_MAX)\n+    {\n+        hr = AllocateOrGetBuffer(ppbBuffer);\n+        if (SUCCEEDED(hr))\n+        {\n+           if (pcbMaxLength != NULL)\n+                (*pcbMaxLength) = m_cbMaxLength;\n+\n+            if (pcbCurrentLength != NULL)\n+                (*pcbCurrentLength) = m_cbCurrentLength;\n+\n+            \/\/ Increment lock count when we provided buffer. Lock() can be called\n+            \/\/ multiple times and memory pointer should stay valid until last\n+            \/\/ Unlock() called. The caller MUST match Lock() \/ Unlock() calls\n+            \/\/ based on documentation.\n+            m_ulLockCount++;\n+        }\n+    }\n+\n+    LeaveCriticalSection(&m_csBufferLock);\n+\n+    return hr;\n+}\n+\n+HRESULT CMFGSTBuffer::Unlock()\n+{\n+    HRESULT hr = E_FAIL;\n+\n+    EnterCriticalSection(&m_csBufferLock);\n+    \/\/ If Unlock() called without Lock() we should fail.\n+    if (m_ulLockCount > 0)\n+    {\n+        m_ulLockCount--;\n+        if (m_ulLockCount == 0 && m_bUnmapGstBuffer)\n+        {\n+            gst_buffer_unmap(m_pGstBuffer, &m_GstMapInfo);\n+            m_bUnmapGstBuffer = FALSE;\n+        }\n+        hr = S_OK;\n+    }\n+    LeaveCriticalSection(&m_csBufferLock);\n+\n+    return hr;\n+}\n+\n+\/\/ IUnknown\n+HRESULT CMFGSTBuffer::QueryInterface(REFIID riid, void **ppvObject)\n+{\n+    if (!ppvObject)\n+    {\n+        return E_POINTER;\n+    }\n+    else if (riid == IID_IUnknown)\n+    {\n+        (*ppvObject) = static_cast<IUnknown *>(static_cast<IMFMediaBuffer *>(this));\n+    }\n+    else if (riid == IID_IMFMediaBuffer)\n+    {\n+        (*ppvObject) = static_cast<IMFMediaBuffer *>(this);\n+    }\n+    else\n+    {\n+        (*ppvObject) = NULL;\n+        return E_NOINTERFACE;\n+    }\n+    AddRef();\n+    return S_OK;\n+}\n+\n+ULONG CMFGSTBuffer::AddRef()\n+{\n+    return InterlockedIncrement(&m_ulRefCount);\n+}\n+\n+ULONG CMFGSTBuffer::Release()\n+{\n+    ULONG uCount = InterlockedDecrement(&m_ulRefCount);\n+    if (uCount == 0)\n+    {\n+        delete this;\n+    }\n+    return uCount;\n+}\n+\n+\/\/ GStreamer interface\n+HRESULT CMFGSTBuffer::GetGstBuffer(GstBuffer **ppBuffer)\n+{\n+    if (ppBuffer == NULL)\n+        return E_INVALIDARG;\n+\n+    \/\/ If we do not have GStreamer buffer or if it is still locked\n+    \/\/ return E_UNEXPECTED. Such condition should not happen, but\n+    \/\/ just in case we need to check for it.\n+    if (m_pGstBuffer == NULL || m_bUnmapGstBuffer)\n+        return E_UNEXPECTED;\n+\n+    (*ppBuffer) = m_pGstBuffer;\n+\n+    m_pGstBuffer = NULL;\n+\n+    return S_OK;\n+}\n+\n+HRESULT CMFGSTBuffer::SetCallbackData(sCallbackData *pCallbackData)\n+{\n+    if (pCallbackData == NULL)\n+        ZeroMemory(&m_CallbackData, sizeof(sCallbackData));\n+    else\n+        m_CallbackData = (*pCallbackData);\n+\n+    return S_OK;\n+}\n+\n+HRESULT CMFGSTBuffer::SetGetGstBufferCallback(void (*function)(GstBuffer **ppBuffer,\n+            long lSize, sCallbackData *pCallbackData))\n+{\n+    if (function == NULL)\n+        return E_INVALIDARG;\n+\n+    GetGstBufferCallback = function;\n+\n+    return S_OK;\n+}\n+\n+HRESULT CMFGSTBuffer::AllocateOrGetBuffer(BYTE **ppbBuffer)\n+{\n+    if (ppbBuffer == NULL)\n+        return E_INVALIDARG;\n+\n+    \/\/ If we have GStreamer get buffer callback set, then call it to get\n+    \/\/ buffer. Otherwise allocate memory internally.\n+    if (GetGstBufferCallback != NULL)\n+    {\n+        \/\/ Get buffer if needed\n+        if (m_pGstBuffer == NULL)\n+        {\n+            GetGstBufferCallback(&m_pGstBuffer, (long)m_cbMaxLength, &m_CallbackData);\n+            if (m_pGstBuffer == NULL)\n+                return E_OUTOFMEMORY;\n+        }\n+\n+        \/\/ Lock can be called multiple times, so if we have GStreamer buffer\n+        \/\/ allocated and mapped just return it.\n+        if (m_bUnmapGstBuffer)\n+        {\n+            (*ppbBuffer) = m_GstMapInfo.data;\n+        }\n+        else\n+        {\n+            \/\/ Map buffer and return it.\n+            if (!gst_buffer_map(m_pGstBuffer, &m_GstMapInfo, GST_MAP_READWRITE))\n+                return E_FAIL;\n+\n+            \/\/ Just in case check that we got right buffer size.\n+            \/\/ GStreamer buffer can be bigger due to alligment.\n+            if (m_GstMapInfo.maxsize < m_cbMaxLength)\n+            {\n+                gst_buffer_unmap(m_pGstBuffer, &m_GstMapInfo);\n+                \/\/ INLINE - gst_buffer_unref()\n+                gst_buffer_unref(m_pGstBuffer);\n+                m_pGstBuffer = NULL;\n+                return E_FAIL;\n+            }\n+\n+            m_bUnmapGstBuffer = TRUE;\n+\n+            (*ppbBuffer) = m_GstMapInfo.data;\n+        }\n+    }\n+    else\n+    {\n+        \/\/ Allocate new buffer if needed\n+        if (m_pbBuffer == NULL)\n+        {\n+            m_pbBuffer = new (nothrow) BYTE[m_cbMaxLength];\n+            if (m_pbBuffer == NULL)\n+                return E_OUTOFMEMORY;\n+\n+            (*ppbBuffer) = m_pbBuffer;\n+        }\n+        else if (m_pbBuffer != NULL)\n+        {\n+            (*ppbBuffer) = m_pbBuffer;\n+        }\n+    }\n+\n+    return S_OK;\n+}\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfgstbuffer.cpp","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef __MF_GST_BUFFER_H__\n+#define __MF_GST_BUFFER_H__\n+\n+#include <gst\/gst.h>\n+\n+#include <new>\n+\n+#include <mfidl.h>\n+\n+using namespace std;\n+\n+struct sCallbackData\n+{\n+    void *pCallbackData;\n+};\n+\n+class CMFGSTBuffer : public IMFMediaBuffer\n+{\n+public:\n+    CMFGSTBuffer(DWORD cbMaxLength);\n+    ~CMFGSTBuffer();\n+\n+    \/\/ IMFMediaBuffer\n+    HRESULT GetCurrentLength(DWORD *pcbCurrentLength);\n+    HRESULT GetMaxLength(DWORD *pcbMaxLength);\n+    HRESULT SetCurrentLength(DWORD cbCurrentLength);\n+    HRESULT Lock(BYTE **ppbBuffer, DWORD *pcbMaxLength, DWORD *pcbCurrentLength);\n+    HRESULT Unlock();\n+\n+    \/\/ IUnknown\n+    HRESULT QueryInterface(REFIID riid, void **ppvObject);\n+    ULONG AddRef();\n+    ULONG Release();\n+\n+    \/\/ GStreamer interface\n+    HRESULT GetGstBuffer(GstBuffer **ppBuffer);\n+    HRESULT SetCallbackData(sCallbackData *pCallbackData);\n+    HRESULT SetGetGstBufferCallback(void (*function)(GstBuffer **ppBuffer,\n+            long lSize, sCallbackData *pCallbackData));\n+\n+private:\n+    HRESULT AllocateOrGetBuffer(BYTE **ppbBuffer);\n+\n+    ULONG m_ulRefCount;\n+\n+    \/\/ Used to unlock buffer with last Unlock() call. Lock() \/ Unlock() can be\n+    \/\/ called multiple times, but the caller should match calls for\n+    \/\/ Lock() \/ Unlock().\n+    ULONG m_ulLockCount;\n+    \/\/ Used to protect Lock() \/ Unlock() which can be called by\n+    \/\/ multiple threads.\n+    CRITICAL_SECTION m_csBufferLock;\n+\n+    DWORD m_cbMaxLength;\n+    DWORD m_cbCurrentLength;\n+    BYTE *m_pbBuffer;\n+\n+    GstBuffer *m_pGstBuffer;\n+    BOOL m_bUnmapGstBuffer;\n+    GstMapInfo m_GstMapInfo;\n+\n+    sCallbackData m_CallbackData;\n+    void (*GetGstBufferCallback)(GstBuffer **ppBuffer, long lSize,\n+            sCallbackData *pCallbackData);\n+};\n+\n+#endif \/\/ __MF_GST_BUFFER_H__\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfgstbuffer.h","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,2 @@\n-#include <mfwrapper.h>\n+#include \"mfwrapper.h\"\n+\n@@ -44,0 +45,6 @@\n+\/\/ 3 buffers is enough for rendering. During testing 2 buffers is actually\n+\/\/ enough, but in some case 3 were allocated.\n+#define MIN_BUFFERS 3\n+\/\/ 6 buffers max, just in case.\n+#define MAX_BUFFERS 6\n+\n@@ -193,0 +200,1 @@\n+    decoder->is_decoder_error = FALSE;\n@@ -199,1 +207,1 @@\n-    if (FAILED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE)))\n+    if (FAILED(CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE)))\n@@ -209,0 +217,1 @@\n+    decoder->pDecoderBuffer = NULL;\n@@ -214,0 +223,1 @@\n+        decoder->pColorConvertBuffer[i] = NULL;\n@@ -216,0 +226,2 @@\n+    decoder->pool = NULL;\n+\n@@ -233,0 +245,2 @@\n+    \/\/ No need to free pDecoderBuffer, it will be release when interface is\n+    \/\/ release by MF.\n@@ -238,0 +252,2 @@\n+        \/\/ No need to free pColorConvertBuffer, it will be release when interface is\n+        \/\/ release by MF.\n@@ -242,0 +258,9 @@\n+    if (decoder->pool)\n+    {\n+        if (gst_buffer_pool_is_active(decoder->pool))\n+            gst_buffer_pool_set_active(decoder->pool, FALSE);\n+\n+        gst_object_unref(decoder->pool);\n+        decoder->pool = NULL;\n+    }\n+\n@@ -299,0 +324,27 @@\n+static HRESULT mfwrapper_create_sample(IMFSample **ppSample, DWORD dwSize, CMFGSTBuffer **ppMFGSTBuffer)\n+{\n+    if (ppSample == NULL || dwSize == 0 || ppMFGSTBuffer == NULL)\n+        return E_INVALIDARG;\n+\n+    HRESULT hr = MFCreateSample(ppSample);\n+    if (SUCCEEDED(hr))\n+    {\n+        (*ppMFGSTBuffer) = new (nothrow) CMFGSTBuffer(dwSize);\n+        if ((*ppMFGSTBuffer) == NULL)\n+            return E_OUTOFMEMORY;\n+\n+        IMFMediaBuffer *pBuffer = NULL;\n+        hr = (*ppMFGSTBuffer)->QueryInterface(IID_IMFMediaBuffer, (void **)&pBuffer);\n+        if (FAILED(hr) || pBuffer == NULL)\n+        {\n+            delete (*ppMFGSTBuffer);\n+            return E_NOINTERFACE;\n+        }\n+\n+        (*ppSample)->AddBuffer(pBuffer);\n+        SafeRelease(&pBuffer);\n+    }\n+\n+    return S_OK;\n+}\n+\n@@ -356,1 +408,2 @@\n-        if (!((outputStreamInfo.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) || (outputStreamInfo.dwFlags & MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES)))\n+        if (!((outputStreamInfo.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) ||\n+              (outputStreamInfo.dwFlags & MFT_OUTPUT_STREAM_CAN_PROVIDE_SAMPLES)))\n@@ -358,9 +411,2 @@\n-            hr = MFCreateSample(&decoder->pDecoderOutput);\n-            if (SUCCEEDED(hr))\n-            {\n-                IMFMediaBuffer *pBuffer = NULL;\n-                hr = MFCreateMemoryBuffer(outputStreamInfo.cbSize, &pBuffer);\n-                if (SUCCEEDED(hr))\n-                    hr = decoder->pDecoderOutput->AddBuffer(pBuffer);\n-                SafeRelease(&pBuffer);\n-            }\n+            hr = mfwrapper_create_sample(&decoder->pDecoderOutput,\n+                    outputStreamInfo.cbSize, &decoder->pDecoderBuffer);\n@@ -785,1 +831,2 @@\n-\/\/ outputType - Will be set to color convert output type (IYUV or NV12)\n+\/\/ outputType - Will be set to color convert output type (IYUV or NV12).\n+\/\/ ppMFGSTBuffer - Receives CMFGSTBuffer object related to ppColorConvertOutput.\n@@ -790,1 +837,2 @@\n-                                           GUID *outputType)\n+                                           GUID *outputType,\n+                                           CMFGSTBuffer **ppMFGSTBuffer)\n@@ -796,1 +844,2 @@\n-        ppColorConvertOutput == NULL || outputType == NULL)\n+        ppColorConvertOutput == NULL || outputType == NULL ||\n+        ppMFGSTBuffer == NULL)\n@@ -816,9 +865,2 @@\n-            hr = MFCreateSample(ppColorConvertOutput);\n-            if (SUCCEEDED(hr))\n-            {\n-                IMFMediaBuffer *pBuffer = NULL;\n-                hr = MFCreateMemoryBuffer(outputStreamInfo.cbSize, &pBuffer);\n-                if (SUCCEEDED(hr))\n-                    hr = (*ppColorConvertOutput)->AddBuffer(pBuffer);\n-                SafeRelease(&pBuffer);\n-            }\n+            hr = mfwrapper_create_sample(ppColorConvertOutput,\n+                outputStreamInfo.cbSize, ppMFGSTBuffer);\n@@ -847,0 +889,112 @@\n+static void mfwrapper_get_gst_buffer_src(GstBuffer **ppBuffer, long lSize,\n+        sCallbackData *pCallbackData)\n+{\n+    GstFlowReturn ret = GST_FLOW_OK;\n+    GstMFWrapper *decoder = (GstMFWrapper*)pCallbackData->pCallbackData;\n+    if (decoder == NULL || decoder->pool == NULL)\n+    {\n+        (*ppBuffer) = NULL;\n+        return;\n+    }\n+\n+    ret = gst_buffer_pool_acquire_buffer(decoder->pool, ppBuffer, NULL);\n+    if (ret == GST_FLOW_OK)\n+        return;\n+\n+    \/\/ Pool might fail in case of flushing, but MF still might want buffer.\n+    \/\/ It is better to give buffer to MF just in case, then fail\n+    \/\/ CMFGSTBuffer::Lock().\n+    (*ppBuffer) = gst_buffer_new_allocate(NULL, lSize, NULL);\n+}\n+\n+\/\/ Gets max length of configured media buffer we using for final rendering from\n+\/\/ decoder or color convert.\n+static HRESULT mfwrapper_get_media_buffer_max_length(GstMFWrapper *decoder, DWORD *pdwMaxLength)\n+{\n+    HRESULT hr = S_OK;\n+\n+    if (decoder == NULL || pdwMaxLength == NULL)\n+        return E_INVALIDARG;\n+\n+    CMFGSTBuffer *pBuffer = NULL;\n+    if (decoder->pColorConvertOutput[COLOR_CONVERT_IYUV] != NULL)\n+        pBuffer = decoder->pColorConvertBuffer[COLOR_CONVERT_IYUV];\n+    else if (decoder->pDecoderOutput != NULL)\n+        pBuffer = decoder->pDecoderBuffer;\n+\n+    if (pBuffer == NULL)\n+        return E_FAIL;\n+\n+    return pBuffer->GetMaxLength(pdwMaxLength);\n+}\n+\n+static HRESULT mfwrapper_configure_media_buffer(GstMFWrapper *decoder)\n+{\n+    HRESULT hr = S_OK;\n+\n+    CMFGSTBuffer *pBuffer = NULL;\n+    if (decoder->pColorConvertOutput[COLOR_CONVERT_IYUV] != NULL)\n+        pBuffer = decoder->pColorConvertBuffer[COLOR_CONVERT_IYUV];\n+    else if (decoder->pDecoderOutput != NULL)\n+        pBuffer = decoder->pDecoderBuffer;\n+\n+    if (pBuffer == NULL)\n+        return E_FAIL;\n+\n+    sCallbackData callbackData;\n+    ZeroMemory(&callbackData, sizeof(sCallbackData));\n+    callbackData.pCallbackData = (void*)decoder;\n+    hr = pBuffer->SetCallbackData(&callbackData);\n+    if (FAILED(hr))\n+        return hr;\n+\n+    hr = pBuffer->SetGetGstBufferCallback(&mfwrapper_get_gst_buffer_src);\n+    if (FAILED(hr))\n+        return hr;\n+\n+    return hr;\n+}\n+\n+static HRESULT mfwrapper_configure_buffer_pool(GstMFWrapper *decoder)\n+{\n+    \/\/ Free old pool. We might be called during format change.\n+    if (decoder->pool)\n+    {\n+        if (gst_buffer_pool_is_active(decoder->pool))\n+            gst_buffer_pool_set_active(decoder->pool, FALSE);\n+\n+        gst_object_unref(decoder->pool);\n+        decoder->pool = NULL;\n+    }\n+\n+    DWORD dwMaxLength = 0;\n+    HRESULT hr = mfwrapper_get_media_buffer_max_length(decoder, &dwMaxLength);\n+    \/\/ Pool only supports upto unsigned int, but buffer can be unsigned long.\n+    if (FAILED(hr) || dwMaxLength > G_MAXUINT)\n+        return E_FAIL;\n+\n+    decoder->pool = gst_buffer_pool_new();\n+    if (decoder->pool == NULL)\n+        return E_FAIL;\n+\n+    GstStructure *config = gst_buffer_pool_get_config(decoder->pool);\n+    if (config == NULL)\n+        return E_FAIL;\n+\n+    \/\/ By now we should caps configured on pad, so just use it.\n+    GstCaps *caps = gst_pad_get_current_caps(decoder->srcpad);\n+    if (caps == NULL)\n+        return E_FAIL;\n+\n+    gst_buffer_pool_config_set_params(config, caps,\n+            (guint)dwMaxLength, MIN_BUFFERS, MAX_BUFFERS);\n+    gst_caps_unref(caps); \/\/ INLINE - gst_caps_unref()\n+\n+    if (!gst_buffer_pool_set_config(decoder->pool, config))\n+        return E_FAIL;\n+\n+    gst_buffer_pool_set_active(decoder->pool, TRUE);\n+\n+    return S_OK;\n+}\n+\n@@ -935,0 +1089,1 @@\n+        CMFGSTBuffer *pMFGSTBuffer = NULL;\n@@ -937,1 +1092,1 @@\n-                    &pColorConvert, &pColorConvertOutput, &outputType);\n+                    &pColorConvert, &pColorConvertOutput, &outputType, &pMFGSTBuffer);\n@@ -941,0 +1096,1 @@\n+            decoder->pColorConvertBuffer[COLOR_CONVERT_NV12] = pMFGSTBuffer;\n@@ -945,1 +1101,1 @@\n-                    &pColorConvertOutput, &outputType);\n+                    &pColorConvertOutput, &outputType, &pMFGSTBuffer);\n@@ -951,0 +1107,1 @@\n+            decoder->pColorConvertBuffer[COLOR_CONVERT_IYUV] = pMFGSTBuffer;\n@@ -958,0 +1115,11 @@\n+    \/\/ By now we should have output sample created. Figure out which one we\n+    \/\/ will use to deliver frames and update media buffer in this sample to\n+    \/\/ use GStreamer memory directly.\n+    if (SUCCEEDED(hr))\n+        hr = mfwrapper_configure_media_buffer(decoder);\n+\n+    \/\/ Configure GStreamer buffer pool to avoid memory allocation for each\n+    \/\/ buffer.\n+    if (SUCCEEDED(hr))\n+        hr = mfwrapper_configure_buffer_pool(decoder);\n+\n@@ -1123,1 +1291,2 @@\n-static GstFlowReturn mfwrapper_deliver_sample(GstMFWrapper *decoder, IMFSample *pSample)\n+static GstFlowReturn mfwrapper_deliver_sample(GstMFWrapper *decoder,\n+        IMFSample *pSample, CMFGSTBuffer *pMFGSTBuffer)\n@@ -1126,0 +1295,1 @@\n+    GstBuffer *pGstBuffer = NULL;\n@@ -1128,5 +1298,0 @@\n-    IMFMediaBuffer *pMediaBuffer = NULL;\n-    BYTE *pBuffer = NULL;\n-    DWORD cbMaxLength = 0;\n-    DWORD cbCurrentLength = 0;\n-    GstMapInfo info;\n@@ -1134,1 +1299,2 @@\n-    HRESULT hr = pSample->ConvertToContiguousBuffer(&pMediaBuffer);\n+    if (decoder == NULL || pSample == NULL || pMFGSTBuffer == NULL)\n+        return GST_FLOW_ERROR;\n@@ -1136,2 +1302,3 @@\n-    if (SUCCEEDED(hr))\n-        hr = pMediaBuffer->Lock(&pBuffer, &cbMaxLength, &cbCurrentLength);\n+    HRESULT hr = pMFGSTBuffer->GetGstBuffer(&pGstBuffer);\n+    if (FAILED(hr))\n+        return GST_FLOW_ERROR;\n@@ -1139,43 +1306,2 @@\n-    if (SUCCEEDED(hr) && cbCurrentLength > 0)\n-    {\n-        GstBuffer *pGstBuffer = gst_buffer_new_allocate(NULL, cbCurrentLength, NULL);\n-        if (pGstBuffer == NULL || !gst_buffer_map(pGstBuffer, &info, GST_MAP_WRITE))\n-        {\n-            pMediaBuffer->Unlock();\n-             if (pGstBuffer != NULL)\n-                gst_buffer_unref(pGstBuffer); \/\/ INLINE - gst_buffer_unref()\n-            return GST_FLOW_ERROR;\n-        }\n-\n-        memcpy(info.data, pBuffer, cbCurrentLength);\n-        gst_buffer_unmap(pGstBuffer, &info);\n-        gst_buffer_set_size(pGstBuffer, cbCurrentLength);\n-\n-        hr = pMediaBuffer->Unlock();\n-        if (SUCCEEDED(hr))\n-        {\n-            hr = pSample->GetSampleTime(&llTimestamp);\n-            GST_BUFFER_TIMESTAMP(pGstBuffer) = llTimestamp * 100;\n-        }\n-\n-        if (SUCCEEDED(hr))\n-        {\n-            hr = pSample->GetSampleDuration(&llDuration);\n-            GST_BUFFER_DURATION(pGstBuffer) = llDuration * 100;\n-        }\n-\n-        if (SUCCEEDED(hr) && decoder->force_output_discontinuity)\n-        {\n-            pGstBuffer = gst_buffer_make_writable(pGstBuffer);\n-            GST_BUFFER_FLAG_SET(pGstBuffer, GST_BUFFER_FLAG_DISCONT);\n-            decoder->force_output_discontinuity = FALSE;\n-        }\n-\n-#if PTS_DEBUG\n-        if (GST_BUFFER_TIMESTAMP_IS_VALID(pGstBuffer) && GST_BUFFER_DURATION_IS_VALID(pGstBuffer))\n-            g_print(\"JFXMEDIA H265 %I64u %I64u\\n\", GST_BUFFER_TIMESTAMP(pGstBuffer), GST_BUFFER_DURATION(pGstBuffer));\n-        else if (GST_BUFFER_TIMESTAMP_IS_VALID(pGstBuffer) && !GST_BUFFER_DURATION_IS_VALID(pGstBuffer))\n-            g_print(\"JFXMEDIA H265 %I64u -1\\n\", GST_BUFFER_TIMESTAMP(pGstBuffer));\n-        else\n-            g_print(\"JFXMEDIA H265 -1\\n\");\n-#endif\n+    hr = pSample->GetSampleTime(&llTimestamp);\n+    GST_BUFFER_TIMESTAMP(pGstBuffer) = llTimestamp * 100;\n@@ -1183,1 +1309,4 @@\n-        ret = gst_pad_push(decoder->srcpad, pGstBuffer);\n+    if (SUCCEEDED(hr))\n+    {\n+        hr = pSample->GetSampleDuration(&llDuration);\n+        GST_BUFFER_DURATION(pGstBuffer) = llDuration * 100;\n@@ -1185,1 +1314,2 @@\n-    else if (SUCCEEDED(hr))\n+\n+    if (SUCCEEDED(hr) && decoder->force_output_discontinuity)\n@@ -1187,1 +1317,3 @@\n-        pMediaBuffer->Unlock();\n+        pGstBuffer = gst_buffer_make_writable(pGstBuffer);\n+        GST_BUFFER_FLAG_SET(pGstBuffer, GST_BUFFER_FLAG_DISCONT);\n+        decoder->force_output_discontinuity = FALSE;\n@@ -1190,1 +1322,8 @@\n-    SafeRelease(&pMediaBuffer);\n+#if PTS_DEBUG\n+    if (GST_BUFFER_TIMESTAMP_IS_VALID(pGstBuffer) && GST_BUFFER_DURATION_IS_VALID(pGstBuffer))\n+        g_print(\"JFXMEDIA H265 %I64u %I64u\\n\", GST_BUFFER_TIMESTAMP(pGstBuffer), GST_BUFFER_DURATION(pGstBuffer));\n+    else if (GST_BUFFER_TIMESTAMP_IS_VALID(pGstBuffer) && !GST_BUFFER_DURATION_IS_VALID(pGstBuffer))\n+        g_print(\"JFXMEDIA H265 %I64u -1\\n\", GST_BUFFER_TIMESTAMP(pGstBuffer));\n+    else\n+        g_print(\"JFXMEDIA H265 -1\\n\");\n+#endif\n@@ -1192,1 +1331,1 @@\n-    return ret;\n+    return gst_pad_push(decoder->srcpad, pGstBuffer);\n@@ -1241,1 +1380,2 @@\n-                                decoder->pColorConvertOutput[COLOR_CONVERT_IYUV]);\n+                                decoder->pColorConvertOutput[COLOR_CONVERT_IYUV],\n+                                decoder->pColorConvertBuffer[COLOR_CONVERT_IYUV]);\n@@ -1246,1 +1386,2 @@\n-                ret = mfwrapper_deliver_sample(decoder, decoder->pDecoderOutput);\n+                ret = mfwrapper_deliver_sample(decoder, decoder->pDecoderOutput,\n+                            decoder->pDecoderBuffer);\n@@ -1250,0 +1391,8 @@\n+    else\n+    {\n+        decoder->is_decoder_error = TRUE;\n+        gst_element_message_full(GST_ELEMENT(decoder), GST_MESSAGE_ERROR,\n+                GST_STREAM_ERROR, GST_STREAM_ERROR_DECODE,\n+                g_strdup_printf(\"Failed to decode stream (0x%X)\", hr), NULL,\n+                (\"mfwrapper.c\"), (\"mfwrapper_process_output\"), 0);\n+    }\n@@ -1323,2 +1472,1 @@\n-        decoder->pDecoder->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n-        for (int i = 0; i < MAX_COLOR_CONVERT; i++)\n+        if (!decoder->is_decoder_error)\n@@ -1326,1 +1474,3 @@\n-            if (decoder->pColorConvert[i])\n+            decoder->pDecoder->\n+                    ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n+            for (int i = 0; i < MAX_COLOR_CONVERT; i++)\n@@ -1328,2 +1478,5 @@\n-                decoder->pColorConvert[i]->\n-                        ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n+                if (decoder->pColorConvert[i])\n+                {\n+                    decoder->pColorConvert[i]->\n+                            ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n+                }\n@@ -1342,2 +1495,4 @@\n-        \/\/ Let decoder know that we got end of stream\n-        hr = decoder->pDecoder->\n+        if (!decoder->is_decoder_error)\n+        {\n+            \/\/ Let decoder know that we got end of stream\n+            hr = decoder->pDecoder->\n@@ -1346,6 +1501,6 @@\n-        \/\/ Ask decoder to produce all remaining data\n-        if (SUCCEEDED(hr))\n-        {\n-            decoder->pDecoder->\n-                    ProcessMessage(MFT_MESSAGE_COMMAND_DRAIN, 0);\n-        }\n+            \/\/ Ask decoder to produce all remaining data\n+            if (SUCCEEDED(hr))\n+            {\n+                decoder->pDecoder->\n+                        ProcessMessage(MFT_MESSAGE_COMMAND_DRAIN, 0);\n+            }\n@@ -1353,6 +1508,6 @@\n-        \/\/ Deliver remaining data\n-        gint po_ret;\n-        do\n-        {\n-            po_ret = mfwrapper_process_output(decoder);\n-        } while (po_ret == PO_DELIVERED);\n+            \/\/ Deliver remaining data\n+            gint po_ret;\n+            do\n+            {\n+                po_ret = mfwrapper_process_output(decoder);\n+            } while (po_ret == PO_DELIVERED);\n@@ -1360,3 +1515,1 @@\n-        for (int i = 0; i < MAX_COLOR_CONVERT; i++)\n-        {\n-            if (decoder->pColorConvert[i])\n+            for (int i = 0; i < MAX_COLOR_CONVERT; i++)\n@@ -1364,3 +1517,2 @@\n-                hr = decoder->pColorConvert[i]->\n-                        ProcessMessage(MFT_MESSAGE_NOTIFY_END_OF_STREAM, 0);\n-                if (SUCCEEDED(hr))\n+                if (decoder->pColorConvert[i])\n+                {\n@@ -1368,1 +1520,5 @@\n-                            ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n+                            ProcessMessage(MFT_MESSAGE_NOTIFY_END_OF_STREAM, 0);\n+                    if (SUCCEEDED(hr))\n+                        hr = decoder->pColorConvert[i]->\n+                                ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, 0);\n+                }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfwrapper.cpp","additions":268,"deletions":112,"binary":false,"changes":380,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+#include \"mfgstbuffer.h\"\n+\n@@ -74,0 +76,3 @@\n+    \/\/ If set to true do not call decoder it might hang.\n+    \/\/ This flag should be set if decoder calls failed.\n+    gboolean is_decoder_error;\n@@ -82,0 +87,1 @@\n+    CMFGSTBuffer *pDecoderBuffer;\n@@ -85,0 +91,3 @@\n+    CMFGSTBuffer *pColorConvertBuffer[MAX_COLOR_CONVERT];\n+\n+    GstBufferPool *pool;\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfwrapper.h","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-              mfwrapper\/mfwrapper.cpp\n+              mfwrapper\/mfwrapper.cpp \\\n+              mfwrapper\/mfgstbuffer.cpp\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/win\/fxplugins\/Makefile","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -13,136 +13,143 @@\n-gst_bin_remove\t@12\tNONAME\n-gst_buffer_fill\t@13\tNONAME\n-gst_buffer_get_size\t@14\tNONAME\n-gst_buffer_map\t@15\tNONAME\n-gst_buffer_new_allocate\t@16\tNONAME\n-gst_buffer_new_wrapped_full\t@17\tNONAME\n-gst_buffer_resize\t@18\tNONAME\n-gst_buffer_set_size\t@19\tNONAME\n-gst_buffer_unmap\t@20\tNONAME\n-gst_bus_create_watch\t@21\tNONAME\n-gst_bus_post\t@22\tNONAME\n-gst_caps_get_size\t@23\tNONAME\n-gst_caps_get_structure\t@24\tNONAME\n-gst_caps_new_simple\t@25\tNONAME\n-gst_caps_set_simple\t@26\tNONAME\n-gst_child_proxy_get_child_by_index\t@27\tNONAME\n-gst_child_proxy_get_type\t@28\tNONAME\n-gst_core_error_quark\t@29\tNONAME\n-gst_element_add_pad\t@30\tNONAME\n-gst_element_class_add_pad_template\t@31\tNONAME\n-gst_element_class_get_pad_template\t@32\tNONAME\n-gst_element_class_set_metadata\t@33\tNONAME\n-gst_element_class_set_static_metadata\t@34\tNONAME\n-gst_element_factory_make\t@35\tNONAME\n-gst_element_get_factory\t@36\tNONAME\n-gst_element_get_state\t@37\tNONAME\n-gst_element_get_static_pad\t@38\tNONAME\n-gst_element_get_type\t@39\tNONAME\n-gst_element_link\t@40\tNONAME\n-gst_element_link_many\t@41\tNONAME\n-gst_element_message_full\t@42\tNONAME\n-gst_element_no_more_pads\t@43\tNONAME\n-gst_element_post_message\t@44\tNONAME\n-gst_element_provide_clock\t@45\tNONAME\n-gst_element_query_duration\t@46\tNONAME\n-gst_element_query_position\t@47\tNONAME\n-gst_element_register\t@48\tNONAME\n-gst_element_remove_pad\t@49\tNONAME\n-gst_element_seek\t@50\tNONAME\n-gst_element_set_state\t@51\tNONAME\n-gst_element_sync_state_with_parent\t@52\tNONAME\n-gst_event_copy_segment\t@53\tNONAME\n-gst_event_get_seqnum\t@54\tNONAME\n-gst_event_new_caps\t@55\tNONAME\n-gst_event_new_custom\t@56\tNONAME\n-gst_event_new_eos\t@57\tNONAME\n-gst_event_new_flush_start\t@58\tNONAME\n-gst_event_new_flush_stop\t@59\tNONAME\n-gst_event_new_seek\t@60\tNONAME\n-gst_event_new_segment\t@61\tNONAME\n-gst_event_new_stream_start\t@62\tNONAME\n-gst_event_parse_caps\t@63\tNONAME\n-gst_event_parse_seek\t@64\tNONAME\n-gst_event_set_group_id\t@65\tNONAME\n-gst_event_set_seqnum\t@66\tNONAME\n-gst_ghost_pad_new\t@67\tNONAME\n-gst_init_check\t@68\tNONAME\n-gst_iterator_free\t@69\tNONAME\n-gst_iterator_next\t@70\tNONAME\n-gst_iterator_resync\t@71\tNONAME\n-gst_message_get_structure\t@72\tNONAME\n-gst_message_new_application\t@73\tNONAME\n-gst_message_new_error\t@74\tNONAME\n-gst_message_parse_error\t@75\tNONAME\n-gst_message_parse_info\t@76\tNONAME\n-gst_message_parse_state_changed\t@77\tNONAME\n-gst_message_parse_warning\t@78\tNONAME\n-gst_mini_object_copy\t@79\tNONAME\n-gst_mini_object_make_writable\t@80\tNONAME\n-gst_mini_object_ref\t@81\tNONAME\n-gst_mini_object_unref\t@82\tNONAME\n-gst_object_get_type\t@83\tNONAME\n-gst_object_ref\t@84\tNONAME\n-gst_object_unref\t@85\tNONAME\n-gst_pad_activate_mode\t@86\tNONAME\n-gst_pad_add_probe\t@87\tNONAME\n-gst_pad_create_stream_id\t@88\tNONAME\n-gst_pad_event_default\t@89\tNONAME\n-gst_pad_get_current_caps\t@90\tNONAME\n-gst_pad_is_active\t@91\tNONAME\n-gst_pad_is_linked\t@92\tNONAME\n-gst_pad_link\t@93\tNONAME\n-gst_pad_new_from_static_template\t@94\tNONAME\n-gst_pad_new_from_template\t@95\tNONAME\n-gst_pad_pause_task\t@96\tNONAME\n-gst_pad_peer_query_convert\t@97\tNONAME\n-gst_pad_peer_query_duration\t@98\tNONAME\n-gst_pad_push\t@99\tNONAME\n-gst_pad_push_event\t@100\tNONAME\n-gst_pad_query_default\t@101\tNONAME\n-gst_pad_remove_probe\t@102\tNONAME\n-gst_pad_set_activate_function_full\t@103\tNONAME\n-gst_pad_set_activatemode_function_full\t@104\tNONAME\n-gst_pad_set_active\t@105\tNONAME\n-gst_pad_set_chain_function_full\t@106\tNONAME\n-gst_pad_set_event_function_full\t@107\tNONAME\n-gst_pad_set_getrange_function_full\t@108\tNONAME\n-gst_pad_set_query_function_full\t@109\tNONAME\n-gst_pad_start_task\t@110\tNONAME\n-gst_pad_stop_task\t@111\tNONAME\n-gst_pad_use_fixed_caps\t@112\tNONAME\n-gst_pipeline_get_bus\t@113\tNONAME\n-gst_pipeline_get_type\t@114\tNONAME\n-gst_pipeline_new\t@115\tNONAME\n-gst_pipeline_set_clock\t@116\tNONAME\n-gst_query_add_scheduling_mode\t@117\tNONAME\n-gst_query_parse_duration\t@118\tNONAME\n-gst_query_parse_position\t@119\tNONAME\n-gst_query_parse_seeking\t@120\tNONAME\n-gst_query_set_duration\t@121\tNONAME\n-gst_query_set_position\t@122\tNONAME\n-gst_query_set_scheduling\t@123\tNONAME\n-gst_query_set_seeking\t@124\tNONAME\n-gst_resource_error_quark\t@125\tNONAME\n-gst_sample_get_buffer\t@126\tNONAME\n-gst_sample_get_caps\t@127\tNONAME\n-gst_sample_new\t@128\tNONAME\n-gst_segment_copy_into\t@129\tNONAME\n-gst_segment_init\t@130\tNONAME\n-gst_segtrap_set_enabled\t@131\tNONAME\n-gst_static_pad_template_get\t@132\tNONAME\n-gst_stream_error_quark\t@133\tNONAME\n-gst_structure_get_boolean\t@134\tNONAME\n-gst_structure_get_clock_time\t@135\tNONAME\n-gst_structure_get_fraction\t@136\tNONAME\n-gst_structure_get_int\t@137\tNONAME\n-gst_structure_get_name\t@138\tNONAME\n-gst_structure_get_string\t@139\tNONAME\n-gst_structure_get_value\t@140\tNONAME\n-gst_structure_has_name\t@141\tNONAME\n-gst_structure_new\t@142\tNONAME\n-gst_structure_new_empty\t@143\tNONAME\n-gst_structure_set\t@144\tNONAME\n-gst_util_group_id_next\t@145\tNONAME\n-gst_value_list_get_value\t@146\tNONAME\n-gst_bin_recalculate_latency\t@148\tNONAME\n+gst_bin_recalculate_latency\t@12\tNONAME\n+gst_bin_remove\t@13\tNONAME\n+gst_buffer_fill\t@14\tNONAME\n+gst_buffer_get_size\t@15\tNONAME\n+gst_buffer_map\t@16\tNONAME\n+gst_buffer_new_allocate\t@17\tNONAME\n+gst_buffer_new_wrapped_full\t@18\tNONAME\n+gst_buffer_pool_acquire_buffer\t@19\tNONAME\n+gst_buffer_pool_config_set_params\t@20\tNONAME\n+gst_buffer_pool_get_config\t@21\tNONAME\n+gst_buffer_pool_is_active\t@22\tNONAME\n+gst_buffer_pool_new\t@23\tNONAME\n+gst_buffer_pool_set_active\t@24\tNONAME\n+gst_buffer_pool_set_config\t@25\tNONAME\n+gst_buffer_resize\t@26\tNONAME\n+gst_buffer_set_size\t@27\tNONAME\n+gst_buffer_unmap\t@28\tNONAME\n+gst_bus_create_watch\t@29\tNONAME\n+gst_bus_post\t@30\tNONAME\n+gst_caps_get_size\t@31\tNONAME\n+gst_caps_get_structure\t@32\tNONAME\n+gst_caps_new_simple\t@33\tNONAME\n+gst_caps_set_simple\t@34\tNONAME\n+gst_child_proxy_get_child_by_index\t@35\tNONAME\n+gst_child_proxy_get_type\t@36\tNONAME\n+gst_core_error_quark\t@37\tNONAME\n+gst_element_add_pad\t@38\tNONAME\n+gst_element_class_add_pad_template\t@39\tNONAME\n+gst_element_class_get_pad_template\t@40\tNONAME\n+gst_element_class_set_metadata\t@41\tNONAME\n+gst_element_class_set_static_metadata\t@42\tNONAME\n+gst_element_factory_make\t@43\tNONAME\n+gst_element_get_factory\t@44\tNONAME\n+gst_element_get_state\t@45\tNONAME\n+gst_element_get_static_pad\t@46\tNONAME\n+gst_element_get_type\t@47\tNONAME\n+gst_element_link\t@48\tNONAME\n+gst_element_link_many\t@49\tNONAME\n+gst_element_message_full\t@50\tNONAME\n+gst_element_no_more_pads\t@51\tNONAME\n+gst_element_post_message\t@52\tNONAME\n+gst_element_provide_clock\t@53\tNONAME\n+gst_element_query_duration\t@54\tNONAME\n+gst_element_query_position\t@55\tNONAME\n+gst_element_register\t@56\tNONAME\n+gst_element_remove_pad\t@57\tNONAME\n+gst_element_seek\t@58\tNONAME\n+gst_element_set_state\t@59\tNONAME\n+gst_element_sync_state_with_parent\t@60\tNONAME\n+gst_event_copy_segment\t@61\tNONAME\n+gst_event_get_seqnum\t@62\tNONAME\n+gst_event_new_caps\t@63\tNONAME\n+gst_event_new_custom\t@64\tNONAME\n+gst_event_new_eos\t@65\tNONAME\n+gst_event_new_flush_start\t@66\tNONAME\n+gst_event_new_flush_stop\t@67\tNONAME\n+gst_event_new_seek\t@68\tNONAME\n+gst_event_new_segment\t@69\tNONAME\n+gst_event_new_stream_start\t@70\tNONAME\n+gst_event_parse_caps\t@71\tNONAME\n+gst_event_parse_seek\t@72\tNONAME\n+gst_event_set_group_id\t@73\tNONAME\n+gst_event_set_seqnum\t@74\tNONAME\n+gst_ghost_pad_new\t@75\tNONAME\n+gst_init_check\t@76\tNONAME\n+gst_iterator_free\t@77\tNONAME\n+gst_iterator_next\t@78\tNONAME\n+gst_iterator_resync\t@79\tNONAME\n+gst_message_get_structure\t@80\tNONAME\n+gst_message_new_application\t@81\tNONAME\n+gst_message_new_error\t@82\tNONAME\n+gst_message_parse_error\t@83\tNONAME\n+gst_message_parse_info\t@84\tNONAME\n+gst_message_parse_state_changed\t@85\tNONAME\n+gst_message_parse_warning\t@86\tNONAME\n+gst_mini_object_copy\t@87\tNONAME\n+gst_mini_object_make_writable\t@88\tNONAME\n+gst_mini_object_ref\t@89\tNONAME\n+gst_mini_object_unref\t@90\tNONAME\n+gst_object_get_type\t@91\tNONAME\n+gst_object_ref\t@92\tNONAME\n+gst_object_unref\t@93\tNONAME\n+gst_pad_activate_mode\t@94\tNONAME\n+gst_pad_add_probe\t@95\tNONAME\n+gst_pad_create_stream_id\t@96\tNONAME\n+gst_pad_event_default\t@97\tNONAME\n+gst_pad_get_current_caps\t@98\tNONAME\n+gst_pad_is_active\t@99\tNONAME\n+gst_pad_is_linked\t@100\tNONAME\n+gst_pad_link\t@101\tNONAME\n+gst_pad_new_from_static_template\t@102\tNONAME\n+gst_pad_new_from_template\t@103\tNONAME\n+gst_pad_pause_task\t@104\tNONAME\n+gst_pad_peer_query_convert\t@105\tNONAME\n+gst_pad_peer_query_duration\t@106\tNONAME\n+gst_pad_push\t@107\tNONAME\n+gst_pad_push_event\t@108\tNONAME\n+gst_pad_query_default\t@109\tNONAME\n+gst_pad_remove_probe\t@110\tNONAME\n+gst_pad_set_activate_function_full\t@111\tNONAME\n+gst_pad_set_activatemode_function_full\t@112\tNONAME\n+gst_pad_set_active\t@113\tNONAME\n+gst_pad_set_chain_function_full\t@114\tNONAME\n+gst_pad_set_event_function_full\t@115\tNONAME\n+gst_pad_set_getrange_function_full\t@116\tNONAME\n+gst_pad_set_query_function_full\t@117\tNONAME\n+gst_pad_start_task\t@118\tNONAME\n+gst_pad_stop_task\t@119\tNONAME\n+gst_pad_use_fixed_caps\t@120\tNONAME\n+gst_pipeline_get_bus\t@121\tNONAME\n+gst_pipeline_get_type\t@122\tNONAME\n+gst_pipeline_new\t@123\tNONAME\n+gst_pipeline_set_clock\t@124\tNONAME\n+gst_query_add_scheduling_mode\t@125\tNONAME\n+gst_query_parse_duration\t@126\tNONAME\n+gst_query_parse_position\t@127\tNONAME\n+gst_query_parse_seeking\t@128\tNONAME\n+gst_query_set_duration\t@129\tNONAME\n+gst_query_set_position\t@130\tNONAME\n+gst_query_set_scheduling\t@131\tNONAME\n+gst_query_set_seeking\t@132\tNONAME\n+gst_resource_error_quark\t@133\tNONAME\n+gst_sample_get_buffer\t@134\tNONAME\n+gst_sample_get_caps\t@135\tNONAME\n+gst_sample_new\t@136\tNONAME\n+gst_segment_copy_into\t@137\tNONAME\n+gst_segment_init\t@138\tNONAME\n+gst_segtrap_set_enabled\t@139\tNONAME\n+gst_static_pad_template_get\t@140\tNONAME\n+gst_stream_error_quark\t@141\tNONAME\n+gst_structure_get_boolean\t@142\tNONAME\n+gst_structure_get_clock_time\t@143\tNONAME\n+gst_structure_get_fraction\t@144\tNONAME\n+gst_structure_get_int\t@145\tNONAME\n+gst_structure_get_name\t@146\tNONAME\n+gst_structure_get_string\t@147\tNONAME\n+gst_structure_get_value\t@148\tNONAME\n+gst_structure_has_name\t@149\tNONAME\n+gst_structure_new\t@150\tNONAME\n+gst_structure_new_empty\t@151\tNONAME\n+gst_structure_set\t@152\tNONAME\n+gst_util_group_id_next\t@153\tNONAME\n+gst_value_list_get_value\t@154\tNONAME\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/projects\/win\/gstreamer-lite.def","additions":143,"deletions":136,"binary":false,"changes":279,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\plugins\\mfwrapper\\mfgstbuffer.cpp\" \/>\r\n@@ -47,0 +48,1 @@\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\mfwrapper\\mfgstbuffer.h\" \/>\r\n","filename":"modules\/javafx.media\/src\/main\/native\/vs_project\/plugins\/plugins.vcxproj","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,3 @@\n+    <ClCompile Include=\"..\\..\\gstreamer\\plugins\\mfwrapper\\mfgstbuffer.cpp\">\r\n+      <Filter>mfwrapper<\/Filter>\r\n+    <\/ClCompile>\r\n@@ -67,0 +70,3 @@\n+    <ClInclude Include=\"..\\..\\gstreamer\\plugins\\mfwrapper\\mfgstbuffer.h\">\r\n+      <Filter>mfwrapper<\/Filter>\r\n+    <\/ClInclude>\r\n","filename":"modules\/javafx.media\/src\/main\/native\/vs_project\/plugins\/plugins.vcxproj.filters","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}