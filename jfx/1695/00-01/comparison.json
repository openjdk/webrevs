{"files":[{"patch":"@@ -32,0 +32,3 @@\n+    m_ulLockCount = 0;\n+    InitializeCriticalSection(&m_csBufferLock);\n+\n@@ -63,0 +66,2 @@\n+\n+    DeleteCriticalSection(&m_csBufferLock);\n@@ -101,0 +106,2 @@\n+    HRESULT hr = E_FAIL;\n+\n@@ -107,3 +114,9 @@\n-    HRESULT hr = AllocateOrGetBuffer(ppbBuffer);\n-    if (FAILED(hr))\n-        return hr;\n+    EnterCriticalSection(&m_csBufferLock);\n+    \/\/ Unlikely Lock() will be called in infinite loop.\n+    if (m_ulLockCount != ULONG_MAX)\n+    {\n+        hr = AllocateOrGetBuffer(ppbBuffer);\n+        if (SUCCEEDED(hr))\n+        {\n+           if (pcbMaxLength != NULL)\n+                (*pcbMaxLength) = m_cbMaxLength;\n@@ -111,2 +124,2 @@\n-    if (pcbMaxLength != NULL)\n-        (*pcbMaxLength) = m_cbMaxLength;\n+            if (pcbCurrentLength != NULL)\n+                (*pcbCurrentLength) = m_cbCurrentLength;\n@@ -114,2 +127,7 @@\n-    if (pcbCurrentLength != NULL)\n-        (*pcbCurrentLength) = m_cbCurrentLength;\n+            \/\/ Increment lock count when we provided buffer. Lock() can be called\n+            \/\/ multiple times and memory pointer should stay valid until last\n+            \/\/ Unlock() called. The caller MUST match Lock() \/ Unlock() calls\n+            \/\/ based on documentation.\n+            m_ulLockCount++;\n+        }\n+    }\n@@ -117,1 +135,3 @@\n-    return S_OK;\n+    LeaveCriticalSection(&m_csBufferLock);\n+\n+    return hr;\n@@ -122,1 +142,5 @@\n-    if (m_bUnmapGstBuffer)\n+    HRESULT hr = E_FAIL;\n+\n+    EnterCriticalSection(&m_csBufferLock);\n+    \/\/ If Unlock() called without Lock() we should fail.\n+    if (m_ulLockCount > 0)\n@@ -124,2 +148,7 @@\n-        gst_buffer_unmap(m_pGstBuffer, &m_GstMapInfo);\n-        m_bUnmapGstBuffer = FALSE;\n+        m_ulLockCount--;\n+        if (m_ulLockCount == 0 && m_bUnmapGstBuffer)\n+        {\n+            gst_buffer_unmap(m_pGstBuffer, &m_GstMapInfo);\n+            m_bUnmapGstBuffer = FALSE;\n+        }\n+        hr = S_OK;\n@@ -127,0 +156,1 @@\n+    LeaveCriticalSection(&m_csBufferLock);\n@@ -128,1 +158,1 @@\n-    return S_OK;\n+    return hr;\n@@ -176,1 +206,1 @@\n-    \/\/ If we do not have GStreamer buffer or it is still locked\n+    \/\/ If we do not have GStreamer buffer or if it is still locked\n@@ -215,3 +245,3 @@\n-    \/\/ If we have GStreamer get buffer cllback set, then call it to get\n-    \/\/ buffer. Otherwsie allocate memory internally.\n-    if (GetGstBufferCallback != NULL && m_pGstBuffer == NULL)\n+    \/\/ If we have GStreamer get buffer callback set, then call it to get\n+    \/\/ buffer. Otherwise allocate memory internally.\n+    if (GetGstBufferCallback != NULL)\n@@ -219,1 +249,1 @@\n-        GetGstBufferCallback(&m_pGstBuffer, (long)m_cbMaxLength, &m_CallbackData);\n+        \/\/ Get buffer if needed\n@@ -221,8 +251,0 @@\n-            return E_OUTOFMEMORY;\n-\n-        if (!gst_buffer_map(m_pGstBuffer, &m_GstMapInfo, GST_MAP_READWRITE))\n-            return E_FAIL;\n-\n-        \/\/ Just in case check that we got right buffer size.\n-        \/\/ GStreamer buffer can be bigger due to alligment.\n-        if (m_GstMapInfo.maxsize < m_cbMaxLength)\n@@ -230,5 +252,3 @@\n-            gst_buffer_unmap(m_pGstBuffer, &m_GstMapInfo);\n-            \/\/ INLINE - gst_buffer_unref()\n-            gst_buffer_unref(m_pGstBuffer);\n-            m_pGstBuffer = NULL;\n-            return E_FAIL;\n+            GetGstBufferCallback(&m_pGstBuffer, (long)m_cbMaxLength, &m_CallbackData);\n+            if (m_pGstBuffer == NULL)\n+                return E_OUTOFMEMORY;\n@@ -237,9 +257,27 @@\n-        m_bUnmapGstBuffer = TRUE;\n-\n-        (*ppbBuffer) = m_GstMapInfo.data;\n-    }\n-    \/\/ Lock can be called multiple times, so if we have GStreamer buffer\n-    \/\/ allocated just return it.\n-    else if (GetGstBufferCallback != NULL && m_pGstBuffer != NULL && m_bUnmapGstBuffer)\n-    {\n-        (*ppbBuffer) = m_GstMapInfo.data;\n+        \/\/ Lock can be called multiple times, so if we have GStreamer buffer\n+        \/\/ allocated and mapped just return it.\n+        if (m_bUnmapGstBuffer)\n+        {\n+            (*ppbBuffer) = m_GstMapInfo.data;\n+        }\n+        else\n+        {\n+            \/\/ Map buffer and return it.\n+            if (!gst_buffer_map(m_pGstBuffer, &m_GstMapInfo, GST_MAP_READWRITE))\n+                return E_FAIL;\n+\n+            \/\/ Just in case check that we got right buffer size.\n+            \/\/ GStreamer buffer can be bigger due to alligment.\n+            if (m_GstMapInfo.maxsize < m_cbMaxLength)\n+            {\n+                gst_buffer_unmap(m_pGstBuffer, &m_GstMapInfo);\n+                \/\/ INLINE - gst_buffer_unref()\n+                gst_buffer_unref(m_pGstBuffer);\n+                m_pGstBuffer = NULL;\n+                return E_FAIL;\n+            }\n+\n+            m_bUnmapGstBuffer = TRUE;\n+\n+            (*ppbBuffer) = m_GstMapInfo.data;\n+        }\n@@ -247,2 +285,1 @@\n-    \/\/ Allocate new buffer if needed\n-    else if (m_pbBuffer == NULL)\n+    else\n@@ -250,1 +287,1 @@\n-        m_pbBuffer = new (nothrow) BYTE[m_cbMaxLength];\n+        \/\/ Allocate new buffer if needed\n@@ -252,1 +289,4 @@\n-            return E_OUTOFMEMORY;\n+        {\n+            m_pbBuffer = new (nothrow) BYTE[m_cbMaxLength];\n+            if (m_pbBuffer == NULL)\n+                return E_OUTOFMEMORY;\n@@ -254,5 +294,6 @@\n-        (*ppbBuffer) = m_pbBuffer;\n-    }\n-    else if (m_pbBuffer != NULL)\n-    {\n-        (*ppbBuffer) = m_pbBuffer;\n+            (*ppbBuffer) = m_pbBuffer;\n+        }\n+        else if (m_pbBuffer != NULL)\n+        {\n+            (*ppbBuffer) = m_pbBuffer;\n+        }\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfgstbuffer.cpp","additions":89,"deletions":48,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-private:\n@@ -72,0 +71,8 @@\n+    \/\/ Used to unlock buffer with last Unlock() call. Lock() \/ Unlock() can be\n+    \/\/ called multiple times, but the caller should match calls for\n+    \/\/ Lock() \/ Unlock().\n+    ULONG m_ulLockCount;\n+    \/\/ Used to protect Lock() \/ Unlock() which can be called by\n+    \/\/ multiple threads.\n+    CRITICAL_SECTION m_csBufferLock;\n+\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfgstbuffer.h","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -911,1 +911,1 @@\n-\/\/ decoder ot color convert.\n+\/\/ decoder or color convert.\n","filename":"modules\/javafx.media\/src\/main\/native\/gstreamer\/plugins\/mfwrapper\/mfwrapper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}