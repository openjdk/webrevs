{"files":[{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.css;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javafx.css.PseudoClass;\n+import javafx.css.Selector;\n+import javafx.css.StyleConverter;\n+import javafx.geometry.NodeOrientation;\n+\n+import static javafx.geometry.NodeOrientation.LEFT_TO_RIGHT;\n+import static javafx.geometry.NodeOrientation.RIGHT_TO_LEFT;\n+\n+\/**\n+ * Class which can read and write selectors in a binary format.\n+ *\/\n+public class BinarySerializer {\n+    private static final int TYPE_SIMPLE = 1;\n+    private static final int TYPE_COMPOUND = 2;\n+\n+    public static Selector read(DataInputStream is, String[] strings) throws IOException {\n+        int type = is.readByte();\n+\n+        if (type == TYPE_SIMPLE) {\n+            return readSimpleSelector(is, strings);\n+        }\n+\n+        \/\/ Backwards compatible, if it is not TYPE_SIMPLE any other value is considered TYPE_COMPOUND\n+        return readCompoundSelector(is, strings);\n+    }\n+\n+    public static void write(Selector selector, DataOutputStream os, StyleConverter.StringStore stringStore) throws IOException {\n+        if (selector instanceof SimpleSelector s) {\n+            writeSimpleSelector(s, os, stringStore);\n+        }\n+        else if(selector instanceof CompoundSelector s) {\n+            writeCompoundSelector(s, os, stringStore);\n+        }\n+        else {\n+            throw new IllegalStateException(\"support missing for selector type: \" + (selector == null ? \"null\" : selector.getClass()));\n+        }\n+    }\n+\n+    private static SimpleSelector readSimpleSelector(DataInputStream is, String[] strings) throws IOException {\n+        String name = strings[is.readShort()];\n+        int nStyleClasses = is.readShort();\n+        List<String> styleClasses = new ArrayList<>();\n+\n+        for (int n = 0; n < nStyleClasses; n++) {\n+            styleClasses.add(strings[is.readShort()]);\n+        }\n+\n+        String id = strings[is.readShort()];\n+        int nPseudoclasses = is.readShort();\n+        List<String> pseudoclasses = new ArrayList<>();\n+\n+        for (int n = 0; n < nPseudoclasses; n++) {\n+            pseudoclasses.add(strings[is.readShort()]);\n+        }\n+\n+        return new SimpleSelector(name, styleClasses, pseudoclasses, id);\n+    }\n+\n+    private static CompoundSelector readCompoundSelector(DataInputStream is, String[] strings) throws IOException {\n+        int nSelectors = is.readShort();\n+        List<SimpleSelector> selectors = new ArrayList<>();\n+\n+        for (int n = 0; n < nSelectors; n++) {\n+\n+            \/*\n+             * An extra byte is part of the binary format containing TYPE_SIMPLE that\n+             * isn't strictly needed. However, to remain backwards compatible with the\n+             * first (and only) supported binary format, this byte must be skipped over\n+             * before attempting to read what is known to be a simple selector.\n+             *\/\n+\n+            byte type = is.readByte();\n+\n+            if (type != TYPE_SIMPLE) {\n+                throw new IllegalStateException(\"Expected compound selector to consist of simple selectors only, but found type: \" + type);\n+            }\n+\n+            selectors.add(readSimpleSelector(is, strings));\n+        }\n+\n+        int nRelationships = is.readShort();\n+\n+        List<Combinator> relationships = new ArrayList<>();\n+\n+        for (int n = 0; n < nRelationships; n++) {\n+            int ordinal = is.readByte();\n+\n+            if (ordinal == Combinator.CHILD.ordinal()) {\n+                relationships.add(Combinator.CHILD);\n+            }\n+            else if (ordinal == Combinator.DESCENDANT.ordinal()) {\n+                relationships.add(Combinator.DESCENDANT);\n+            }\n+            else {\n+                assert false : \"error deserializing CompoundSelector: Combinator = \" + ordinal;\n+                relationships.add(Combinator.DESCENDANT);\n+            }\n+        }\n+\n+        return new CompoundSelector(selectors, relationships);\n+    }\n+\n+    private static void writeCompoundSelector(CompoundSelector selector, DataOutputStream os, StyleConverter.StringStore stringStore) throws IOException {\n+        os.writeByte(TYPE_COMPOUND);\n+\n+        List<SimpleSelector> selectors = selector.getSelectors();\n+\n+        os.writeShort(selectors.size());\n+\n+        for (int n = 0; n < selectors.size(); n++) {\n+            writeSimpleSelector(selectors.get(n), os, stringStore);\n+        }\n+\n+        List<Combinator> relationships = selector.getRelationships();\n+\n+        os.writeShort(relationships.size());\n+\n+        for (int n = 0; n < relationships.size(); n++) {\n+            os.writeByte(relationships.get(n).ordinal());\n+        }\n+    }\n+\n+    private static void writeSimpleSelector(SimpleSelector selector, DataOutputStream os, StyleConverter.StringStore stringStore) throws IOException {\n+        os.writeByte(TYPE_SIMPLE);\n+\n+        List<String> selectorStyleClassNames = selector.getStyleClasses();\n+\n+        os.writeShort(stringStore.addString(selector.getName()));\n+        os.writeShort(selectorStyleClassNames.size());\n+\n+        for (String sc : selectorStyleClassNames) {\n+            os.writeShort(stringStore.addString(sc));\n+        }\n+\n+        os.writeShort(stringStore.addString(selector.getId()));\n+\n+        Set<PseudoClass> pseudoClassStates = selector.getPseudoClassStates();\n+        NodeOrientation nodeOrientation = selector.getNodeOrientation();\n+\n+        int pclassSize = pseudoClassStates.size()\n+                + (nodeOrientation == RIGHT_TO_LEFT || nodeOrientation == LEFT_TO_RIGHT ? 1 : 0);\n+\n+        os.writeShort(pclassSize);\n+\n+        for (PseudoClass pc : pseudoClassStates) {\n+            os.writeShort(stringStore.addString(pc.getPseudoClassName()));\n+        }\n+\n+        if (nodeOrientation == RIGHT_TO_LEFT) {\n+            os.writeShort(stringStore.addString(\"dir(rtl)\"));\n+        }\n+        else if (nodeOrientation == LEFT_TO_RIGHT) {\n+            os.writeShort(stringStore.addString(\"dir(ltr)\"));\n+        }\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/BinarySerializer.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.css;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javafx.css.PseudoClass;\n+import javafx.css.Selector;\n+import javafx.css.Styleable;\n+\n+\/**\n+ * A compound selector which behaves according to the CSS standard. The selector is\n+ * composed of one or more <code>Selectors<\/code>, along with an array of\n+ * <code>CompoundSelectorRelationships<\/code> indicating the required relationship at each\n+ * stage.  There must be exactly one less <code>Combinator<\/code> than\n+ * there are selectors.\n+ * <p>\n+ * For example, the parameters <code>[selector1, selector2, selector3]<\/code>\n+ * and <code>[Combinator.CHILD, Combinator.DESCENDANT]<\/code> will match\n+ * a component when all of the following conditions hold:\n+ * <ol>\n+ * <li>The component itself is matched by selector3\n+ * <li>The component has an ancestor which is matched by selector2\n+ * <li>The ancestor matched in step 2 is a direct CHILD of a component\n+ * matched by selector1\n+ * <\/ol>\n+ * In other words, the compound selector specified above is (in CSS syntax)\n+ * <code>selector1 &gt; selector2 selector3<\/code>.  The greater-than (&gt;)\n+ * between selector1 and selector2 specifies a direct CHILD, whereas the\n+ * whitespace between selector2 and selector3 corresponds to\n+ * <code>Combinator.DESCENDANT<\/code>.\n+ *\/\n+final public class CompoundSelector extends Selector {\n+\n+    private final List<SimpleSelector> selectors;\n+    \/**\n+     * The selectors that make up this compound selector\n+     * @return Immutable List&lt;SimpleSelector&gt;\n+     *\/\n+    public List<SimpleSelector> getSelectors() {\n+        return selectors;\n+    }\n+\n+    private final List<Combinator> relationships;\n+\n+    \/**\n+     * The relationships between the selectors\n+     * @return Immutable {@code List<Combinator>}\n+     *\/\n+    List<Combinator> getRelationships() {\n+        return relationships;\n+    }\n+\n+    \/**\n+     * Creates a <code>CompoundSelector<\/code> from a list of selectors and a\n+     * list of <code>Combinator<\/code> relationships.  There must be exactly one\n+     * less <code>Combinator<\/code> than there are selectors.\n+     *\/\n+    public CompoundSelector(List<SimpleSelector> selectors, List<Combinator> relationships) {\n+        this.selectors =\n+            (selectors != null)\n+                ? Collections.unmodifiableList(selectors)\n+                : Collections.EMPTY_LIST;\n+        this.relationships =\n+            (relationships != null)\n+                ? Collections.unmodifiableList(relationships)\n+                : Collections.EMPTY_LIST;\n+    }\n+\n+    @Override\n+    public Set<String> getStyleClassNames() {\n+        return selectors.stream()\n+            .map(Selector::getStyleClassNames)\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toUnmodifiableSet());\n+    }\n+\n+    @Override public boolean applies(final Styleable styleable) {\n+        return applies(styleable, selectors.size()-1, null, 0);\n+    }\n+\n+    @Override public boolean applies(final Styleable styleable, Set<PseudoClass>[] triggerStates, int depth) {\n+\n+        assert (triggerStates == null || depth < triggerStates.length);\n+        if (triggerStates != null && triggerStates.length <= depth) {\n+            return false;\n+        }\n+\n+        \/\/\n+        \/\/ We only care about pseudo-class if the selector applies. But in\n+        \/\/ the case of a compound selector, we don't know whether it applies\n+        \/\/ until all the selectors have been checked (in the worse case). So\n+        \/\/ the setting of pseudo-class has to be deferred until we know\n+        \/\/ that this compound selector applies. So we'll send a new\n+        \/\/ PseudoClassSet[] and if the compound selector applies,\n+        \/\/ just copy the state back.\n+        \/\/\n+        final Set<PseudoClass>[] tempStates = triggerStates != null\n+                ? new PseudoClassState[triggerStates.length] : null;\n+\n+        final boolean applies = applies(styleable, selectors.size()-1, tempStates, depth);\n+\n+        if (applies && tempStates != null) {\n+\n+            for(int n=0; n<triggerStates.length; n++) {\n+\n+                final Set<PseudoClass> pseudoClassOut = triggerStates[n];\n+                final Set<PseudoClass> pseudoClassIn = tempStates[n];\n+\n+                if (pseudoClassOut != null) {\n+                    if (pseudoClassIn != null) {\n+                        pseudoClassOut.addAll(pseudoClassIn);\n+                    }\n+                } else {\n+                    triggerStates[n] = pseudoClassIn;\n+                }\n+\n+            }\n+        }\n+        return applies;\n+    }\n+\n+    private boolean applies(final Styleable styleable, final int index, Set<PseudoClass>[] triggerStates, int depth) {\n+        \/\/ If the index is < 0 then we know we don't apply\n+        if (index < 0) return false;\n+\n+        \/\/ Simply check the selector associated with this index and see if it\n+        \/\/ applies to the Node\n+        if (! selectors.get(index).applies(styleable, triggerStates, depth)) return false;\n+\n+        \/\/ If there are no more selectors to check (ie: index == 0) then we\n+        \/\/ know we know we apply\n+        if (index == 0) return true;\n+\n+        \/\/ We have not yet checked all the selectors in this CompoundSelector,\n+        \/\/ so now we need to find the next parent and try again. If the\n+        \/\/ relationship between this selector and its ancestor selector is\n+        \/\/ \"CHILD\" then it is required that the parent scenegraph node match\n+        \/\/ the ancestor selector. Otherwise, we just walk up the scenegraph\n+        \/\/ until we find an ancestor node that matches the selector. If we\n+        \/\/ manage to walk all the way to the top without having satisfied all\n+        \/\/ of the selectors, then we know it doesn't apply.\n+        final Combinator relationship = relationships.get(index-1);\n+        if (relationship == Combinator.CHILD) {\n+            final Styleable parent = styleable.getStyleableParent();\n+            if (parent == null) return false;\n+            \/\/ If this call succeeds, then all preceding selectors will have\n+            \/\/ matched due to the recursive nature of the call\n+            return applies(parent, index - 1, triggerStates, ++depth);\n+        } else {\n+             Styleable parent = styleable.getStyleableParent();\n+            while (parent != null) {\n+                boolean answer = applies(parent, index - 1, triggerStates, ++depth);\n+                \/\/ If a call to stateMatches succeeded, then we know that\n+                \/\/ all preceding selectors will have also matched.\n+                if (answer) return true;\n+                \/\/ Otherwise we need to get the next parent and try again\n+                parent = parent.getStyleableParent();\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override public boolean stateMatches(final Styleable styleable, Set<PseudoClass> states) {\n+        return stateMatches(styleable, states, selectors.size()-1);\n+    }\n+\n+    private boolean stateMatches(Styleable styleable, Set<PseudoClass> states, int index) {\n+        \/\/ If the index is < 0 then we know we don't match\n+        if (index < 0) return false;\n+\n+        \/\/ Simply check the selector associated with this index and see if it\n+        \/\/ matches the Node and states provided.\n+        if (! selectors.get(index).stateMatches(styleable, states)) return false;\n+\n+        \/\/ If there are no more selectors to match (ie: index == 0) then we\n+        \/\/ know we have successfully matched\n+        if (index == 0) return true;\n+\n+        \/\/ We have not yet checked all the selectors in this CompoundSelector,\n+        \/\/ so now we need to find the next parent and try again. If the\n+        \/\/ relationship between this selector and its ancestor selector is\n+        \/\/ \"CHILD\" then it is required that the parent scenegraph node match\n+        \/\/ the ancestor selector. Otherwise, we just walk up the scenegraph\n+        \/\/ until we find an ancestor node that matches the selector. If we\n+        \/\/ manage to walk all the way to the top without having satisfied all\n+        \/\/ of the selectors, then we know it doesn't match.\n+        final Combinator relationship = relationships.get(index - 1);\n+        if (relationship == Combinator.CHILD) {\n+            final Styleable parent = styleable.getStyleableParent();\n+            if (parent == null) return false;\n+            if (selectors.get(index-1).applies(parent)) {\n+                \/\/ If this call succeeds, then all preceding selectors will have\n+                \/\/ matched due to the recursive nature of the call\n+                Set<PseudoClass> parentStates = parent.getPseudoClassStates();\n+                return stateMatches(parent, parentStates, index - 1);\n+            }\n+        } else {\n+            Styleable parent = styleable.getStyleableParent();\n+            while (parent != null) {\n+                if (selectors.get(index-1).applies(parent)) {\n+                    Set<PseudoClass> parentStates = parent.getPseudoClassStates();\n+                    return stateMatches(parent, parentStates, index - 1);\n+                }\n+                \/\/ Otherwise we need to get the next parent and try again\n+                parent = parent.getStyleableParent();\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    private  int hash = -1;\n+\n+    \/* Hash code is used in Style's hash code and Style's hash\n+       code is used by StyleHelper *\/\n+    @Override public int hashCode() {\n+        if (hash == -1) {\n+            for (int i = 0, max=selectors.size(); i<max; i++)\n+                hash = 31 * (hash + selectors.get(i).hashCode());\n+            for (int i = 0, max=relationships.size(); i<max; i++)\n+                hash = 31 * (hash + relationships.get(i).hashCode());\n+        }\n+        return hash;\n+    }\n+\n+    @Override public boolean equals(Object obj) {\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        final CompoundSelector other = (CompoundSelector) obj;\n+        if (other.selectors.size() != selectors.size()) return false;\n+        \/\/ Avoid ArrayList equals since it uses enhanced for loop\n+        for (int i = 0, max=selectors.size(); i<max; i++) {\n+            if (!other.selectors.get(i).equals(selectors.get(i))) return false;\n+        }\n+        \/\/ Avoid ArrayList equals since it uses enhanced for loop\n+        if (other.relationships.size() != relationships.size()) return false;\n+        for (int i = 0, max=relationships.size(); i<max; i++) {\n+            if (!other.relationships.get(i).equals(relationships.get(i))) return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override public String toString() {\n+        StringBuilder sbuf = new StringBuilder();\n+        sbuf.append(selectors.get(0));\n+        for(int n=1; n<selectors.size(); n++) {\n+            sbuf.append(relationships.get(n-1));\n+            sbuf.append(selectors.get(n));\n+        }\n+        return sbuf.toString();\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/CompoundSelector.java","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import javafx.css.CompoundSelector;\n@@ -30,1 +29,0 @@\n-import javafx.css.SimpleSelector;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/SelectorPartitioning.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,391 @@\n+\/*\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.css;\n+\n+import javafx.css.PseudoClass;\n+import javafx.css.Selector;\n+import javafx.css.StyleClass;\n+import javafx.css.Styleable;\n+import javafx.geometry.NodeOrientation;\n+import javafx.scene.Node;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import static javafx.geometry.NodeOrientation.INHERIT;\n+import static javafx.geometry.NodeOrientation.LEFT_TO_RIGHT;\n+import static javafx.geometry.NodeOrientation.RIGHT_TO_LEFT;\n+\n+\/**\n+ * A simple selector which behaves according to the CSS standard.\n+ *\/\n+final public class SimpleSelector extends Selector {\n+\n+    \/**\n+     * If specified in the CSS file, the name of the java class to which\n+     * this selector is applied. For example, if the CSS file had:\n+     * <code><pre>\n+     *   Rectangle { }\n+     * <\/pre><\/code>\n+     * then name would be \"Rectangle\".\n+     *\/\n+    final private String name;\n+\n+    \/**\n+     * Gets the name of the java class to which this selector is applied, or *.\n+     * @return the name of the java class\n+     *\/\n+    public String getName() {\n+        return name;\n+    }\n+\n+    \/**\n+     * Gets an immutable list of style-classes of the {@code Selector}.\n+     * @return an immutable list of style-classes of the {@code Selector}\n+     *\/\n+    public List<String> getStyleClasses() {\n+        return List.copyOf(selectorStyleClassNames);\n+    }\n+\n+    \/**\n+     * Gets the immutable {@code Set} of {@code StyleClass}es of the {@code Selector}.\n+     * @return the {@code Set} of {@code StyleClass}es\n+     *\/\n+    public Set<StyleClass> getStyleClassSet() {\n+        if (cachedStyleClasses == null) {\n+            cachedStyleClasses = getStyleClassNames().stream().map(SimpleSelector::getStyleClass).collect(Collectors.toUnmodifiableSet());\n+        }\n+\n+        return cachedStyleClasses;\n+    }\n+\n+    \/*\n+     * Copied from removed StyleClassSet to give StyleClasses a fixed index when\n+     * first encountered. No longer needed once StyleClass is removed.\n+     *\/\n+\n+    private static final Map<String, Integer> styleClassMap = new HashMap<>(64);\n+    private static final List<StyleClass> styleClasses = new ArrayList<>();\n+\n+    private static StyleClass getStyleClass(String styleClass) {\n+\n+        if (styleClass == null || styleClass.trim().isEmpty()) {\n+            throw new IllegalArgumentException(\"styleClass cannot be null or empty String\");\n+        }\n+\n+        StyleClass instance = null;\n+\n+        final Integer value = styleClassMap.get(styleClass);\n+        final int index = value != null ? value.intValue() : -1;\n+\n+        final int size = styleClasses.size();\n+        assert index < size;\n+\n+        if (index != -1 && index < size) {\n+            instance = styleClasses.get(index);\n+        }\n+\n+        if (instance == null) {\n+            instance = new StyleClass(styleClass, size);\n+            styleClasses.add(instance);\n+            styleClassMap.put(styleClass, Integer.valueOf(size));\n+        }\n+\n+        return instance;\n+    }\n+\n+    \/**\n+     * Style class names (immutable).\n+     *\/\n+    private final FixedCapacitySet<String> selectorStyleClassNames;\n+\n+    \/**\n+     * Cache to avoid having to recreate this set on each call.\n+     *\/\n+    private transient Set<StyleClass> cachedStyleClasses;\n+\n+    private final String id;\n+\n+    \/**\n+     * Gets the value of the selector id.\n+     * @return the value of the selector id, which may be an empty string\n+     *\/\n+    public String getId() {\n+        return id;\n+    }\n+\n+    \/\/ a mask of bits corresponding to the pseudoclasses (immutable)\n+    private final Set<PseudoClass> pseudoClassState;\n+\n+    \/\/ for test purposes\n+    public Set<PseudoClass> getPseudoClassStates() {\n+        return pseudoClassState;\n+    }\n+\n+    \/\/ true if name is not a wildcard\n+    final private boolean matchOnName;\n+\n+    \/\/ true if id given\n+    final private boolean matchOnId;\n+\n+    \/\/ true if style class given\n+    final private boolean matchOnStyleClass;\n+\n+    \/\/ dir(ltr) or dir(rtl), otherwise inherit\n+    final private NodeOrientation nodeOrientation;\n+\n+    \/\/ Used in Match. If nodeOrientation is ltr or rtl,\n+    \/\/ then count it as a pseudoclass\n+    \/**\n+     * Gets the {@code NodeOrientation} of this {@code Selector}.\n+     * @return the {@code NodeOrientation}\n+     *\/\n+    public NodeOrientation getNodeOrientation() {\n+        return nodeOrientation;\n+    }\n+\n+    \/\/ TODO: The parser passes styleClasses as a List. Should be array?\n+    public SimpleSelector(final String name, final List<String> styleClasses,\n+            final List<String> pseudoClasses, final String id)\n+    {\n+        this.name = name == null ? \"*\" : name;\n+        \/\/ if name is not null and not empty or wildcard,\n+        \/\/ then match needs to check name\n+        this.matchOnName = (name != null && !(\"\".equals(name)) && !(\"*\".equals(name)));\n+\n+        this.selectorStyleClassNames = styleClasses == null ? FixedCapacitySet.of(0) : convertStyleClassNamesToSet(styleClasses);\n+        this.selectorStyleClassNames.freeze();  \/\/ turns it read only without having to wrap it\n+\n+        this.matchOnStyleClass = (this.selectorStyleClassNames.size() > 0);\n+\n+        PseudoClassState pcs = new PseudoClassState();\n+        NodeOrientation dir = NodeOrientation.INHERIT;\n+\n+        if (pseudoClasses != null) {\n+            for (int n = 0; n < pseudoClasses.size(); n++) {\n+\n+                final String pclass = pseudoClasses.get(n);\n+                if (pclass == null || pclass.isEmpty()) continue;\n+\n+                \/\/ TODO: This is not how we should handle functional pseudo-classes in the long-run!\n+                if (\"dir(\".regionMatches(true, 0, pclass, 0, 4)) {\n+                    final boolean rtl = \"dir(rtl)\".equalsIgnoreCase(pclass);\n+                    dir = rtl ? RIGHT_TO_LEFT : LEFT_TO_RIGHT;\n+                    continue;\n+                }\n+\n+                pcs.add(PseudoClassState.getPseudoClass(pclass));\n+            }\n+        }\n+\n+        this.pseudoClassState = ImmutablePseudoClassSetsCache.of(pcs);\n+        this.nodeOrientation = dir;\n+        this.id = id == null ? \"\" : id;\n+        \/\/ if id is not null and not empty, then match needs to check id\n+        this.matchOnId = (id != null && !(\"\".equals(id)));\n+\n+    }\n+\n+    @Override\n+    public Set<String> getStyleClassNames() {\n+        return selectorStyleClassNames;\n+    }\n+\n+    private FixedCapacitySet<String> convertStyleClassNamesToSet(List<String> styleClasses) {\n+        FixedCapacitySet<String> scs = FixedCapacitySet.of(styleClasses.size());\n+\n+        for (int n = 0, nMax = styleClasses.size(); n < nMax; n++) {\n+            String styleClassName = styleClasses.get(n);\n+\n+            if (styleClassName == null || styleClassName.isEmpty()) {\n+                continue;\n+            }\n+\n+            scs.add(styleClassName);\n+        }\n+\n+        return scs;\n+    }\n+\n+    @Override public boolean applies(Styleable styleable) {\n+\n+        \/\/ handle functional pseudo-class :dir()\n+        \/\/ INHERIT applies to both :dir(rtl) and :dir(ltr)\n+        if (nodeOrientation != INHERIT && styleable instanceof Node) {\n+            final Node node = (Node)styleable;\n+            final NodeOrientation orientation = node.getNodeOrientation();\n+\n+            if (orientation == INHERIT\n+                    ? node.getEffectiveNodeOrientation() != nodeOrientation\n+                    : orientation != nodeOrientation)\n+            {\n+                return false;\n+            }\n+        }\n+\n+        \/\/ if the selector has an id,\n+        \/\/ then bail if it doesn't match the node's id\n+        \/\/ (do this first since it is potentially the cheapest check)\n+        if (matchOnId) {\n+            final String otherId = styleable.getId();\n+            final boolean idMatch = id.equals(otherId);\n+            if (!idMatch) return false;\n+        }\n+\n+        \/\/ If name is not a wildcard,\n+        \/\/ then bail if it doesn't match the node's class name\n+        \/\/ if not wildcard, then match name with node's class name\n+        if (matchOnName) {\n+            final String otherName = styleable.getTypeSelector();\n+            final boolean classMatch = this.name.equals(otherName);\n+            if (!classMatch) return false;\n+        }\n+\n+        if (matchOnStyleClass) {\n+            if (!matchesStyleClasses(styleable.getStyleClass())) {\n+                return false;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    @Override public boolean applies(Styleable styleable, Set<PseudoClass>[] pseudoClasses, int depth) {\n+\n+\n+        final boolean applies = applies(styleable);\n+\n+        \/\/\n+        \/\/ We only need the pseudo-classes if the selector applies to the node.\n+        \/\/\n+        if (applies && pseudoClasses != null && depth < pseudoClasses.length) {\n+\n+            if (pseudoClasses[depth] == null) {\n+                pseudoClasses[depth] = new PseudoClassState();\n+            }\n+\n+            pseudoClasses[depth].addAll(pseudoClassState);\n+\n+        }\n+        return applies;\n+    }\n+\n+    @Override public boolean stateMatches(final Styleable styleable, Set<PseudoClass> states) {\n+        \/\/ [foo bar] matches [foo bar bang],\n+        \/\/ but [foo bar bang] doesn't match [foo bar]\n+        return states != null ? states.containsAll(pseudoClassState) : false;\n+    }\n+\n+    \/\/ Are the Selector's style classes a subset of the Node's style classes?\n+    \/\/\n+    \/\/ http:\/\/www.w3.org\/TR\/css3-selectors\/#class-html\n+    \/\/ The following selector matches any P element whose class attribute has been\n+    \/\/ assigned a list of whitespace-separated values that includes both\n+    \/\/ pastoral and marine:\n+    \/\/\n+    \/\/     p.pastoral.marine { color: green }\n+    \/\/\n+    \/\/ This selector matches when class=\"pastoral blue aqua marine\" but does not\n+    \/\/ match for class=\"pastoral blue\".\n+    private boolean matchesStyleClasses(List<String> styleClassNames) {\n+\n+        \/*\n+         * Exit early if the input list is too small to possibly match all the styles\n+         * of this selector:\n+         *\/\n+\n+        if (styleClassNames.size() < selectorStyleClassNames.size()) {\n+            return false;\n+        }\n+\n+        return selectorStyleClassNames.isSuperSetOf(styleClassNames);\n+    }\n+\n+    @Override public boolean equals(Object obj) {\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        final SimpleSelector other = (SimpleSelector) obj;\n+        if ((this.name == null) ? (other.name != null) : !this.name.equals(other.name)) {\n+            return false;\n+        }\n+        if ((this.id == null) ? (other.id != null) : !this.id.equals(other.id)) {\n+            return false;\n+        }\n+        if (this.selectorStyleClassNames.equals(other.selectorStyleClassNames) == false) {\n+            return false;\n+        }\n+        if (this.pseudoClassState.equals(other.pseudoClassState) == false) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    \/* Hash code is used in Style's hash code and Style's hash\n+       code is used by StyleHelper *\/\n+    @Override public int hashCode() {\n+        int hash = 7;\n+        hash = 31 * (hash + name.hashCode());\n+        hash = 31 * (hash + selectorStyleClassNames.hashCode());\n+        hash = 31 * (hash + selectorStyleClassNames.hashCode());\n+        hash = (id != null) ? 31 * (hash + id.hashCode()) : 0;\n+        hash = 31 * (hash + pseudoClassState.hashCode());\n+        return hash;\n+    }\n+\n+    \/** Converts this object to a string. *\/\n+    @Override public String toString() {\n+\n+        StringBuilder sbuf = new StringBuilder();\n+        if (name != null && name.isEmpty() == false) sbuf.append(name);\n+        else sbuf.append(\"*\");\n+        Iterator<String> iter1 = selectorStyleClassNames.iterator();\n+        while(iter1.hasNext()) {\n+            final String styleClass = iter1.next();\n+            sbuf.append('.').append(styleClass);\n+        }\n+        if (id != null && id.isEmpty() == false) {\n+            sbuf.append('#');\n+            sbuf.append(id);\n+        }\n+        Iterator<PseudoClass> iter2 = pseudoClassState.iterator();\n+        while(iter2.hasNext()) {\n+            final PseudoClass pseudoClass = iter2.next();\n+            sbuf.append(':').append(pseudoClass.getPseudoClassName());\n+        }\n+\n+        return sbuf.toString();\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/css\/SimpleSelector.java","additions":391,"deletions":0,"binary":false,"changes":391,"status":"added"},{"patch":"@@ -1,345 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javafx.css;\n-\n-import com.sun.javafx.css.Combinator;\n-import com.sun.javafx.css.PseudoClassState;\n-\n-import java.io.DataInputStream;\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-\n-\/**\n- * A compound selector which behaves according to the CSS standard. The selector is\n- * composed of one or more <code>Selectors<\/code>, along with an array of\n- * <code>CompoundSelectorRelationships<\/code> indicating the required relationship at each\n- * stage.  There must be exactly one less <code>Combinator<\/code> than\n- * there are selectors.\n- * <p>\n- * For example, the parameters <code>[selector1, selector2, selector3]<\/code>\n- * and <code>[Combinator.CHILD, Combinator.DESCENDANT]<\/code> will match\n- * a component when all of the following conditions hold:\n- * <ol>\n- * <li>The component itself is matched by selector3\n- * <li>The component has an ancestor which is matched by selector2\n- * <li>The ancestor matched in step 2 is a direct CHILD of a component\n- * matched by selector1\n- * <\/ol>\n- * In other words, the compound selector specified above is (in CSS syntax)\n- * <code>selector1 &gt; selector2 selector3<\/code>.  The greater-than (&gt;)\n- * between selector1 and selector2 specifies a direct CHILD, whereas the\n- * whitespace between selector2 and selector3 corresponds to\n- * <code>Combinator.DESCENDANT<\/code>.\n- *\n- * @since 9\n- * @deprecated This class was exposed erroneously and will be removed in a future version\n- *\/\n-@Deprecated(since = \"23\", forRemoval = true)\n-@SuppressWarnings(\"removal\")\n-final public class CompoundSelector extends Selector {\n-\n-    private final List<SimpleSelector> selectors;\n-    \/**\n-     * The selectors that make up this compound selector\n-     * @return Immutable List&lt;SimpleSelector&gt;\n-     *\/\n-    public List<SimpleSelector> getSelectors() {\n-        return selectors;\n-    }\n-\n-    private final List<Combinator> relationships;\n-    \/\/ \/**\n-    \/\/  * The relationships between the selectors\n-    \/\/  * @return Immutable List&lt;Combinator&gt;\n-    \/\/  *\/\n-    \/\/ public List<Combinator> getRelationships() {\n-    \/\/     return relationships;\n-    \/\/ }\n-\n-    \/**\n-     * Creates a <code>CompoundSelector<\/code> from a list of selectors and a\n-     * list of <code>Combinator<\/code> relationships.  There must be exactly one\n-     * less <code>Combinator<\/code> than there are selectors.\n-     *\/\n-    CompoundSelector(List<SimpleSelector> selectors, List<Combinator> relationships) {\n-        this.selectors =\n-            (selectors != null)\n-                ? Collections.unmodifiableList(selectors)\n-                : Collections.EMPTY_LIST;\n-        this.relationships =\n-            (relationships != null)\n-                ? Collections.unmodifiableList(relationships)\n-                : Collections.EMPTY_LIST;\n-    }\n-\n-    @Override\n-    public Set<String> getStyleClassNames() {\n-        return selectors.stream()\n-            .map(Selector::getStyleClassNames)\n-            .flatMap(Collection::stream)\n-            .collect(Collectors.toUnmodifiableSet());\n-    }\n-\n-    @Override public Match createMatch() {\n-        final PseudoClassState allPseudoClasses = new PseudoClassState();\n-        int idCount = 0;\n-        int styleClassCount = 0;\n-\n-        for(int n=0, nMax=selectors.size(); n<nMax; n++) {\n-            Selector sel = selectors.get(n);\n-            Match match = sel.createMatch();\n-            allPseudoClasses.addAll(match.getPseudoClasses());\n-            idCount += match.idCount;\n-            styleClassCount += match.styleClassCount;\n-        }\n-\n-        return new Match(this, allPseudoClasses, idCount, styleClassCount);\n-    }\n-\n-    @Override public boolean applies(final Styleable styleable) {\n-        return applies(styleable, selectors.size()-1, null, 0);\n-    }\n-\n-    @Override public boolean applies(final Styleable styleable, Set<PseudoClass>[] triggerStates, int depth) {\n-\n-        assert (triggerStates == null || depth < triggerStates.length);\n-        if (triggerStates != null && triggerStates.length <= depth) {\n-            return false;\n-        }\n-\n-        \/\/\n-        \/\/ We only care about pseudo-class if the selector applies. But in\n-        \/\/ the case of a compound selector, we don't know whether it applies\n-        \/\/ until all the selectors have been checked (in the worse case). So\n-        \/\/ the setting of pseudo-class has to be deferred until we know\n-        \/\/ that this compound selector applies. So we'll send a new\n-        \/\/ PseudoClassSet[] and if the compound selector applies,\n-        \/\/ just copy the state back.\n-        \/\/\n-        final Set<PseudoClass>[] tempStates = triggerStates != null\n-                ? new PseudoClassState[triggerStates.length] : null;\n-\n-        final boolean applies = applies(styleable, selectors.size()-1, tempStates, depth);\n-\n-        if (applies && tempStates != null) {\n-\n-            for(int n=0; n<triggerStates.length; n++) {\n-\n-                final Set<PseudoClass> pseudoClassOut = triggerStates[n];\n-                final Set<PseudoClass> pseudoClassIn = tempStates[n];\n-\n-                if (pseudoClassOut != null) {\n-                    if (pseudoClassIn != null) {\n-                        pseudoClassOut.addAll(pseudoClassIn);\n-                    }\n-                } else {\n-                    triggerStates[n] = pseudoClassIn;\n-                }\n-\n-            }\n-        }\n-        return applies;\n-    }\n-\n-    private boolean applies(final Styleable styleable, final int index, Set<PseudoClass>[] triggerStates, int depth) {\n-        \/\/ If the index is < 0 then we know we don't apply\n-        if (index < 0) return false;\n-\n-        \/\/ Simply check the selector associated with this index and see if it\n-        \/\/ applies to the Node\n-        if (! selectors.get(index).applies(styleable, triggerStates, depth)) return false;\n-\n-        \/\/ If there are no more selectors to check (ie: index == 0) then we\n-        \/\/ know we know we apply\n-        if (index == 0) return true;\n-\n-        \/\/ We have not yet checked all the selectors in this CompoundSelector,\n-        \/\/ so now we need to find the next parent and try again. If the\n-        \/\/ relationship between this selector and its ancestor selector is\n-        \/\/ \"CHILD\" then it is required that the parent scenegraph node match\n-        \/\/ the ancestor selector. Otherwise, we just walk up the scenegraph\n-        \/\/ until we find an ancestor node that matches the selector. If we\n-        \/\/ manage to walk all the way to the top without having satisfied all\n-        \/\/ of the selectors, then we know it doesn't apply.\n-        final Combinator relationship = relationships.get(index-1);\n-        if (relationship == Combinator.CHILD) {\n-            final Styleable parent = styleable.getStyleableParent();\n-            if (parent == null) return false;\n-            \/\/ If this call succeeds, then all preceding selectors will have\n-            \/\/ matched due to the recursive nature of the call\n-            return applies(parent, index - 1, triggerStates, ++depth);\n-        } else {\n-             Styleable parent = styleable.getStyleableParent();\n-            while (parent != null) {\n-                boolean answer = applies(parent, index - 1, triggerStates, ++depth);\n-                \/\/ If a call to stateMatches succeeded, then we know that\n-                \/\/ all preceding selectors will have also matched.\n-                if (answer) return true;\n-                \/\/ Otherwise we need to get the next parent and try again\n-                parent = parent.getStyleableParent();\n-            }\n-        }\n-        return false;\n-    }\n-\n-    @Override public boolean stateMatches(final Styleable styleable, Set<PseudoClass> states) {\n-        return stateMatches(styleable, states, selectors.size()-1);\n-    }\n-\n-    private boolean stateMatches(Styleable styleable, Set<PseudoClass> states, int index) {\n-        \/\/ If the index is < 0 then we know we don't match\n-        if (index < 0) return false;\n-\n-        \/\/ Simply check the selector associated with this index and see if it\n-        \/\/ matches the Node and states provided.\n-        if (! selectors.get(index).stateMatches(styleable, states)) return false;\n-\n-        \/\/ If there are no more selectors to match (ie: index == 0) then we\n-        \/\/ know we have successfully matched\n-        if (index == 0) return true;\n-\n-        \/\/ We have not yet checked all the selectors in this CompoundSelector,\n-        \/\/ so now we need to find the next parent and try again. If the\n-        \/\/ relationship between this selector and its ancestor selector is\n-        \/\/ \"CHILD\" then it is required that the parent scenegraph node match\n-        \/\/ the ancestor selector. Otherwise, we just walk up the scenegraph\n-        \/\/ until we find an ancestor node that matches the selector. If we\n-        \/\/ manage to walk all the way to the top without having satisfied all\n-        \/\/ of the selectors, then we know it doesn't match.\n-        final Combinator relationship = relationships.get(index - 1);\n-        if (relationship == Combinator.CHILD) {\n-            final Styleable parent = styleable.getStyleableParent();\n-            if (parent == null) return false;\n-            if (selectors.get(index-1).applies(parent)) {\n-                \/\/ If this call succeeds, then all preceding selectors will have\n-                \/\/ matched due to the recursive nature of the call\n-                Set<PseudoClass> parentStates = parent.getPseudoClassStates();\n-                return stateMatches(parent, parentStates, index - 1);\n-            }\n-        } else {\n-            Styleable parent = styleable.getStyleableParent();\n-            while (parent != null) {\n-                if (selectors.get(index-1).applies(parent)) {\n-                    Set<PseudoClass> parentStates = parent.getPseudoClassStates();\n-                    return stateMatches(parent, parentStates, index - 1);\n-                }\n-                \/\/ Otherwise we need to get the next parent and try again\n-                parent = parent.getStyleableParent();\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    private  int hash = -1;\n-\n-    \/* Hash code is used in Style's hash code and Style's hash\n-       code is used by StyleHelper *\/\n-    @Override public int hashCode() {\n-        if (hash == -1) {\n-            for (int i = 0, max=selectors.size(); i<max; i++)\n-                hash = 31 * (hash + selectors.get(i).hashCode());\n-            for (int i = 0, max=relationships.size(); i<max; i++)\n-                hash = 31 * (hash + relationships.get(i).hashCode());\n-        }\n-        return hash;\n-    }\n-\n-    @Override public boolean equals(Object obj) {\n-        if (obj == null) {\n-            return false;\n-        }\n-        if (getClass() != obj.getClass()) {\n-            return false;\n-        }\n-        final CompoundSelector other = (CompoundSelector) obj;\n-        if (other.selectors.size() != selectors.size()) return false;\n-        \/\/ Avoid ArrayList equals since it uses enhanced for loop\n-        for (int i = 0, max=selectors.size(); i<max; i++) {\n-            if (!other.selectors.get(i).equals(selectors.get(i))) return false;\n-        }\n-        \/\/ Avoid ArrayList equals since it uses enhanced for loop\n-        if (other.relationships.size() != relationships.size()) return false;\n-        for (int i = 0, max=relationships.size(); i<max; i++) {\n-            if (!other.relationships.get(i).equals(relationships.get(i))) return false;\n-        }\n-        return true;\n-    }\n-\n-    @Override public String toString() {\n-        StringBuilder sbuf = new StringBuilder();\n-        sbuf.append(selectors.get(0));\n-        for(int n=1; n<selectors.size(); n++) {\n-            sbuf.append(relationships.get(n-1));\n-            sbuf.append(selectors.get(n));\n-        }\n-        return sbuf.toString();\n-    }\n-\n-    @Override protected final void writeBinary(final DataOutputStream os, final StyleConverter.StringStore stringStore)\n-            throws IOException\n-    {\n-        super.writeBinary(os, stringStore);\n-        os.writeShort(selectors.size());\n-        for (int n=0; n< selectors.size(); n++) selectors.get(n).writeBinary(os,stringStore);\n-        os.writeShort(relationships.size());\n-        for (int n=0; n< relationships.size(); n++) os.writeByte(relationships.get(n).ordinal());\n-    }\n-\n-    static CompoundSelector readBinary(int bssVersion, final DataInputStream is, final String[] strings)\n-            throws IOException\n-    {\n-\n-        final int nSelectors = is.readShort();\n-        final List<SimpleSelector> selectors = new ArrayList<>();\n-        for (int n=0; n<nSelectors; n++) {\n-            selectors.add((SimpleSelector)Selector.readBinary(bssVersion, is,strings));\n-        }\n-\n-        final int nRelationships = is.readShort();\n-\n-        final List<Combinator> relationships = new ArrayList<>();\n-        for (int n=0; n<nRelationships; n++) {\n-            final int ordinal = is.readByte();\n-            if (ordinal == Combinator.CHILD.ordinal())\n-                relationships.add(Combinator.CHILD);\n-            else if (ordinal == Combinator.DESCENDANT.ordinal())\n-                relationships.add(Combinator.DESCENDANT);\n-            else {\n-                assert false : \"error deserializing CompoundSelector: Combinator = \" + ordinal;\n-                relationships.add(Combinator.DESCENDANT);\n-            }\n-        }\n-        return new CompoundSelector(selectors, relationships);\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/CompoundSelector.java","additions":0,"deletions":345,"binary":false,"changes":345,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.javafx.css.CompoundSelector;\n@@ -32,0 +33,1 @@\n+import com.sun.javafx.css.SimpleSelector;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/CssParser.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import com.sun.javafx.css.CompoundSelector;\n@@ -31,0 +32,2 @@\n+import com.sun.javafx.css.PseudoClassState;\n+import com.sun.javafx.css.SimpleSelector;\n@@ -32,0 +35,1 @@\n+import java.util.List;\n@@ -45,0 +49,31 @@\n+    static Match of(Selector selector) {\n+        return switch(selector) {\n+            case SimpleSelector s -> ofSimpleSelector(s);\n+            case CompoundSelector cs -> ofCompoundSelector(cs);\n+        };\n+    }\n+\n+    private static Match ofCompoundSelector(CompoundSelector selector) {\n+        PseudoClassState pseudoClasses = new PseudoClassState();\n+        int idCount = 0;\n+        int styleClassCount = 0;\n+        List<SimpleSelector> containedSelectors = selector.getSelectors();\n+\n+        for (int n = 0, max = containedSelectors.size(); n < max; n++) {\n+            Match match = ofSimpleSelector(containedSelectors.get(n));\n+\n+            pseudoClasses.addAll(match.getPseudoClasses());\n+            idCount += match.idCount;\n+            styleClassCount += match.styleClassCount;\n+        }\n+\n+        return new Match(selector, pseudoClasses, idCount, styleClassCount);\n+    }\n+\n+    private static Match ofSimpleSelector(SimpleSelector selector) {\n+        int idCount = selector.getId().isEmpty() ? 0 : 1;\n+        int styleClassCount = selector.getStyleClassSet().size();\n+\n+        return new Match(selector, selector.getPseudoClassStates(), idCount, styleClassCount);\n+    }\n+\n@@ -48,2 +83,2 @@\n-    final int styleClassCount;\n-    final int idCount;\n+    private final int styleClassCount;\n+    private final int idCount;\n@@ -53,1 +88,1 @@\n-    final int specificity;\n+    private final int specificity;\n@@ -55,1 +90,0 @@\n-    @SuppressWarnings(\"removal\")\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/Match.java","additions":38,"deletions":4,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import com.sun.javafx.css.BinarySerializer;\n@@ -334,1 +335,1 @@\n-            sel.writeBinary(os, stringStore);\n+            BinarySerializer.write(sel, os, stringStore);\n@@ -366,1 +367,1 @@\n-            Selector s = Selector.readBinary(bssVersion, is, strings);\n+            Selector s = BinarySerializer.read(is, strings);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/Rule.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import com.sun.javafx.css.CompoundSelector;\n+import com.sun.javafx.css.SimpleSelector;\n@@ -30,3 +32,0 @@\n-import java.io.DataInputStream;\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n@@ -43,1 +42,1 @@\n-abstract public class Selector {\n+public abstract sealed class Selector permits SimpleSelector, CompoundSelector {\n@@ -46,1 +45,3 @@\n-     * Package scoped constructor.\n+     * Constructor for subclasses to call.\n+     *\n+     * @since 24\n@@ -48,1 +49,1 @@\n-    Selector() {\n+    protected Selector() {\n@@ -52,1 +53,0 @@\n-        @SuppressWarnings(\"removal\")\n@@ -109,1 +109,3 @@\n-    public abstract Match createMatch();\n+    public final Match createMatch() {\n+        return Match.of(this);\n+    }\n@@ -140,36 +142,0 @@\n-    private static final int TYPE_SIMPLE = 1;\n-    private static final int TYPE_COMPOUND = 2;\n-\n-    \/**\n-     * Writes {@code Selector} data in binary form to given {@code DataOutputStream}.\n-     * @param os {@code DataOutputStream} to write {@code Selector} data to\n-     * @param stringStore unused\n-     * @throws IOException if writing to {@code DataOutputStream} fails\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    protected void writeBinary(DataOutputStream os, StyleConverter.StringStore stringStore)\n-        throws IOException {\n-        if (this instanceof SimpleSelector) {\n-            os.writeByte(TYPE_SIMPLE);\n-        } else {\n-            os.writeByte(TYPE_COMPOUND);\n-        }\n-    }\n-\n-    \/**\n-     * Reads binary {@code Selector} data from a given {@code DataInputStream}.\n-     * @param bssVersion bss version identifier\n-     * @param is {@code DataInputStream} to read {@code Selector} data from\n-     * @param strings string array containing selector details\n-     * @throws IOException if reading from {@code DataInputStream} fails\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    static Selector readBinary(int bssVersion, DataInputStream is, String[] strings)\n-        throws IOException {\n-        final int type = is.readByte();\n-        if (type == TYPE_SIMPLE)\n-            return SimpleSelector.readBinary(bssVersion, is,strings);\n-        else\n-            return CompoundSelector.readBinary(bssVersion, is,strings);\n-    }\n-\n@@ -181,1 +147,0 @@\n-    @SuppressWarnings(\"removal\")\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/Selector.java","additions":10,"deletions":45,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1,450 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package javafx.css;\n-\n-import javafx.geometry.NodeOrientation;\n-import javafx.scene.Node;\n-\n-import java.io.DataInputStream;\n-import java.io.DataOutputStream;\n-import java.io.IOException;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import com.sun.javafx.css.FixedCapacitySet;\n-import com.sun.javafx.css.ImmutablePseudoClassSetsCache;\n-import com.sun.javafx.css.PseudoClassState;\n-\n-import static javafx.geometry.NodeOrientation.INHERIT;\n-import static javafx.geometry.NodeOrientation.LEFT_TO_RIGHT;\n-import static javafx.geometry.NodeOrientation.RIGHT_TO_LEFT;\n-\n-\/**\n- * A simple selector which behaves according to the CSS standard.\n- *\n- * @since 9\n- * @deprecated This class was exposed erroneously and will be removed in a future version\n- *\/\n-@Deprecated(since = \"23\", forRemoval = true)\n-@SuppressWarnings(\"removal\")\n-final public class SimpleSelector extends Selector {\n-\n-    \/**\n-     * If specified in the CSS file, the name of the java class to which\n-     * this selector is applied. For example, if the CSS file had:\n-     * <code><pre>\n-     *   Rectangle { }\n-     * <\/pre><\/code>\n-     * then name would be \"Rectangle\".\n-     *\/\n-    final private String name;\n-\n-    \/**\n-     * Gets the name of the java class to which this selector is applied, or *.\n-     * @return the name of the java class\n-     *\/\n-    public String getName() {\n-        return name;\n-    }\n-\n-    \/**\n-     * Gets an immutable list of style-classes of the {@code Selector}.\n-     * @return an immutable list of style-classes of the {@code Selector}\n-     *\/\n-    public List<String> getStyleClasses() {\n-        return List.copyOf(selectorStyleClassNames);\n-    }\n-\n-    \/**\n-     * Gets the immutable {@code Set} of {@code StyleClass}es of the {@code Selector}.\n-     * @return the {@code Set} of {@code StyleClass}es\n-     *\/\n-    public Set<StyleClass> getStyleClassSet() {\n-        if (cachedStyleClasses == null) {\n-            cachedStyleClasses = getStyleClassNames().stream().map(SimpleSelector::getStyleClass).collect(Collectors.toUnmodifiableSet());\n-        }\n-\n-        return cachedStyleClasses;\n-    }\n-\n-    \/*\n-     * Copied from removed StyleClassSet to give StyleClasses a fixed index when\n-     * first encountered. No longer needed once StyleClass is removed.\n-     *\/\n-\n-    private static final Map<String, Integer> styleClassMap = new HashMap<>(64);\n-    private static final List<StyleClass> styleClasses = new ArrayList<>();\n-\n-    private static StyleClass getStyleClass(String styleClass) {\n-\n-        if (styleClass == null || styleClass.trim().isEmpty()) {\n-            throw new IllegalArgumentException(\"styleClass cannot be null or empty String\");\n-        }\n-\n-        StyleClass instance = null;\n-\n-        final Integer value = styleClassMap.get(styleClass);\n-        final int index = value != null ? value.intValue() : -1;\n-\n-        final int size = styleClasses.size();\n-        assert index < size;\n-\n-        if (index != -1 && index < size) {\n-            instance = styleClasses.get(index);\n-        }\n-\n-        if (instance == null) {\n-            instance = new StyleClass(styleClass, size);\n-            styleClasses.add(instance);\n-            styleClassMap.put(styleClass, Integer.valueOf(size));\n-        }\n-\n-        return instance;\n-    }\n-\n-    \/**\n-     * Style class names (immutable).\n-     *\/\n-    private final FixedCapacitySet<String> selectorStyleClassNames;\n-\n-    \/**\n-     * Cache to avoid having to recreate this set on each call.\n-     *\/\n-    private transient Set<StyleClass> cachedStyleClasses;\n-\n-    private final String id;\n-\n-    \/**\n-     * Gets the value of the selector id.\n-     * @return the value of the selector id, which may be an empty string\n-     *\/\n-    public String getId() {\n-        return id;\n-    }\n-\n-    \/\/ a mask of bits corresponding to the pseudoclasses (immutable)\n-    private final Set<PseudoClass> pseudoClassState;\n-\n-    \/\/ for test purposes\n-    Set<PseudoClass> getPseudoClassStates() {\n-        return pseudoClassState;\n-    }\n-\n-    \/\/ true if name is not a wildcard\n-    final private boolean matchOnName;\n-\n-    \/\/ true if id given\n-    final private boolean matchOnId;\n-\n-    \/\/ true if style class given\n-    final private boolean matchOnStyleClass;\n-\n-    \/\/ dir(ltr) or dir(rtl), otherwise inherit\n-    final private NodeOrientation nodeOrientation;\n-\n-    \/\/ Used in Match. If nodeOrientation is ltr or rtl,\n-    \/\/ then count it as a pseudoclass\n-    \/**\n-     * Gets the {@code NodeOrientation} of this {@code Selector}.\n-     * @return the {@code NodeOrientation}\n-     *\/\n-    public NodeOrientation getNodeOrientation() {\n-        return nodeOrientation;\n-    }\n-\n-    \/\/ TODO: The parser passes styleClasses as a List. Should be array?\n-    SimpleSelector(final String name, final List<String> styleClasses,\n-            final List<String> pseudoClasses, final String id)\n-    {\n-        this.name = name == null ? \"*\" : name;\n-        \/\/ if name is not null and not empty or wildcard,\n-        \/\/ then match needs to check name\n-        this.matchOnName = (name != null && !(\"\".equals(name)) && !(\"*\".equals(name)));\n-\n-        this.selectorStyleClassNames = styleClasses == null ? FixedCapacitySet.of(0) : convertStyleClassNamesToSet(styleClasses);\n-        this.selectorStyleClassNames.freeze();  \/\/ turns it read only without having to wrap it\n-\n-        this.matchOnStyleClass = (this.selectorStyleClassNames.size() > 0);\n-\n-        PseudoClassState pcs = new PseudoClassState();\n-        NodeOrientation dir = NodeOrientation.INHERIT;\n-\n-        if (pseudoClasses != null) {\n-            for (int n = 0; n < pseudoClasses.size(); n++) {\n-\n-                final String pclass = pseudoClasses.get(n);\n-                if (pclass == null || pclass.isEmpty()) continue;\n-\n-                \/\/ TODO: This is not how we should handle functional pseudo-classes in the long-run!\n-                if (\"dir(\".regionMatches(true, 0, pclass, 0, 4)) {\n-                    final boolean rtl = \"dir(rtl)\".equalsIgnoreCase(pclass);\n-                    dir = rtl ? RIGHT_TO_LEFT : LEFT_TO_RIGHT;\n-                    continue;\n-                }\n-\n-                pcs.add(PseudoClassState.getPseudoClass(pclass));\n-            }\n-        }\n-\n-        this.pseudoClassState = ImmutablePseudoClassSetsCache.of(pcs);\n-        this.nodeOrientation = dir;\n-        this.id = id == null ? \"\" : id;\n-        \/\/ if id is not null and not empty, then match needs to check id\n-        this.matchOnId = (id != null && !(\"\".equals(id)));\n-\n-    }\n-\n-    @Override\n-    public Set<String> getStyleClassNames() {\n-        return selectorStyleClassNames;\n-    }\n-\n-    private FixedCapacitySet<String> convertStyleClassNamesToSet(List<String> styleClasses) {\n-        FixedCapacitySet<String> scs = FixedCapacitySet.of(styleClasses.size());\n-\n-        for (int n = 0, nMax = styleClasses.size(); n < nMax; n++) {\n-            String styleClassName = styleClasses.get(n);\n-\n-            if (styleClassName == null || styleClassName.isEmpty()) {\n-                continue;\n-            }\n-\n-            scs.add(styleClassName);\n-        }\n-\n-        return scs;\n-    }\n-\n-    @Override public Match createMatch() {\n-        final int idCount = (matchOnId) ? 1 : 0;\n-        int styleClassCount = selectorStyleClassNames.size();\n-        return new Match(this, pseudoClassState, idCount, styleClassCount);\n-    }\n-\n-    @Override public boolean applies(Styleable styleable) {\n-\n-        \/\/ handle functional pseudo-class :dir()\n-        \/\/ INHERIT applies to both :dir(rtl) and :dir(ltr)\n-        if (nodeOrientation != INHERIT && styleable instanceof Node) {\n-            final Node node = (Node)styleable;\n-            final NodeOrientation orientation = node.getNodeOrientation();\n-\n-            if (orientation == INHERIT\n-                    ? node.getEffectiveNodeOrientation() != nodeOrientation\n-                    : orientation != nodeOrientation)\n-            {\n-                return false;\n-            }\n-        }\n-\n-        \/\/ if the selector has an id,\n-        \/\/ then bail if it doesn't match the node's id\n-        \/\/ (do this first since it is potentially the cheapest check)\n-        if (matchOnId) {\n-            final String otherId = styleable.getId();\n-            final boolean idMatch = id.equals(otherId);\n-            if (!idMatch) return false;\n-        }\n-\n-        \/\/ If name is not a wildcard,\n-        \/\/ then bail if it doesn't match the node's class name\n-        \/\/ if not wildcard, then match name with node's class name\n-        if (matchOnName) {\n-            final String otherName = styleable.getTypeSelector();\n-            final boolean classMatch = this.name.equals(otherName);\n-            if (!classMatch) return false;\n-        }\n-\n-        if (matchOnStyleClass) {\n-            if (!matchesStyleClasses(styleable.getStyleClass())) {\n-                return false;\n-            }\n-        }\n-\n-        return true;\n-    }\n-\n-    @Override public boolean applies(Styleable styleable, Set<PseudoClass>[] pseudoClasses, int depth) {\n-\n-\n-        final boolean applies = applies(styleable);\n-\n-        \/\/\n-        \/\/ We only need the pseudo-classes if the selector applies to the node.\n-        \/\/\n-        if (applies && pseudoClasses != null && depth < pseudoClasses.length) {\n-\n-            if (pseudoClasses[depth] == null) {\n-                pseudoClasses[depth] = new PseudoClassState();\n-            }\n-\n-            pseudoClasses[depth].addAll(pseudoClassState);\n-\n-        }\n-        return applies;\n-    }\n-\n-    @Override public boolean stateMatches(final Styleable styleable, Set<PseudoClass> states) {\n-        \/\/ [foo bar] matches [foo bar bang],\n-        \/\/ but [foo bar bang] doesn't match [foo bar]\n-        return states != null ? states.containsAll(pseudoClassState) : false;\n-    }\n-\n-    \/\/ Are the Selector's style classes a subset of the Node's style classes?\n-    \/\/\n-    \/\/ http:\/\/www.w3.org\/TR\/css3-selectors\/#class-html\n-    \/\/ The following selector matches any P element whose class attribute has been\n-    \/\/ assigned a list of whitespace-separated values that includes both\n-    \/\/ pastoral and marine:\n-    \/\/\n-    \/\/     p.pastoral.marine { color: green }\n-    \/\/\n-    \/\/ This selector matches when class=\"pastoral blue aqua marine\" but does not\n-    \/\/ match for class=\"pastoral blue\".\n-    private boolean matchesStyleClasses(List<String> styleClassNames) {\n-\n-        \/*\n-         * Exit early if the input list is too small to possibly match all the styles\n-         * of this selector:\n-         *\/\n-\n-        if (styleClassNames.size() < selectorStyleClassNames.size()) {\n-            return false;\n-        }\n-\n-        return selectorStyleClassNames.isSuperSetOf(styleClassNames);\n-    }\n-\n-    @Override public boolean equals(Object obj) {\n-        if (obj == null) {\n-            return false;\n-        }\n-        if (getClass() != obj.getClass()) {\n-            return false;\n-        }\n-        final SimpleSelector other = (SimpleSelector) obj;\n-        if ((this.name == null) ? (other.name != null) : !this.name.equals(other.name)) {\n-            return false;\n-        }\n-        if ((this.id == null) ? (other.id != null) : !this.id.equals(other.id)) {\n-            return false;\n-        }\n-        if (this.selectorStyleClassNames.equals(other.selectorStyleClassNames) == false) {\n-            return false;\n-        }\n-        if (this.pseudoClassState.equals(other.pseudoClassState) == false) {\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-    \/* Hash code is used in Style's hash code and Style's hash\n-       code is used by StyleHelper *\/\n-    @Override public int hashCode() {\n-        int hash = 7;\n-        hash = 31 * (hash + name.hashCode());\n-        hash = 31 * (hash + selectorStyleClassNames.hashCode());\n-        hash = 31 * (hash + selectorStyleClassNames.hashCode());\n-        hash = (id != null) ? 31 * (hash + id.hashCode()) : 0;\n-        hash = 31 * (hash + pseudoClassState.hashCode());\n-        return hash;\n-    }\n-\n-    \/** Converts this object to a string. *\/\n-    @Override public String toString() {\n-\n-        StringBuilder sbuf = new StringBuilder();\n-        if (name != null && name.isEmpty() == false) sbuf.append(name);\n-        else sbuf.append(\"*\");\n-        Iterator<String> iter1 = selectorStyleClassNames.iterator();\n-        while(iter1.hasNext()) {\n-            final String styleClass = iter1.next();\n-            sbuf.append('.').append(styleClass);\n-        }\n-        if (id != null && id.isEmpty() == false) {\n-            sbuf.append('#');\n-            sbuf.append(id);\n-        }\n-        Iterator<PseudoClass> iter2 = pseudoClassState.iterator();\n-        while(iter2.hasNext()) {\n-            final PseudoClass pseudoClass = iter2.next();\n-            sbuf.append(':').append(pseudoClass.getPseudoClassName());\n-        }\n-\n-        return sbuf.toString();\n-    }\n-\n-    @Override protected final void writeBinary(final DataOutputStream os, final StyleConverter.StringStore stringStore)\n-        throws IOException\n-    {\n-        super.writeBinary(os, stringStore);\n-        os.writeShort(stringStore.addString(name));\n-        os.writeShort(selectorStyleClassNames.size());\n-        Iterator<String> iter1 = selectorStyleClassNames.iterator();\n-        while(iter1.hasNext()) {\n-            final String sc = iter1.next();\n-            os.writeShort(stringStore.addString(sc));\n-        }\n-        os.writeShort(stringStore.addString(id));\n-        int pclassSize = pseudoClassState.size()\n-                + (nodeOrientation == RIGHT_TO_LEFT || nodeOrientation == LEFT_TO_RIGHT ? 1 : 0);\n-        os.writeShort(pclassSize);\n-        Iterator<PseudoClass> iter2 = pseudoClassState.iterator();\n-        while(iter2.hasNext()) {\n-            final PseudoClass pc = iter2.next();\n-            os.writeShort(stringStore.addString(pc.getPseudoClassName()));\n-        }\n-        if (nodeOrientation == RIGHT_TO_LEFT) {\n-            os.writeShort(stringStore.addString(\"dir(rtl)\"));\n-        } else if (nodeOrientation == LEFT_TO_RIGHT) {\n-            os.writeShort(stringStore.addString(\"dir(ltr)\"));\n-        }\n-    }\n-\n-    static SimpleSelector readBinary(int bssVersion, final DataInputStream is, final String[] strings)\n-        throws IOException\n-    {\n-        final String name = strings[is.readShort()];\n-        final int nStyleClasses = is.readShort();\n-        final List<String> styleClasses = new ArrayList<>();\n-        for (int n=0; n < nStyleClasses; n++) {\n-            styleClasses.add(strings[is.readShort()]);\n-        }\n-        final String id = strings[is.readShort()];\n-        final int nPseudoclasses = is.readShort();\n-        final List<String> pseudoclasses = new ArrayList<>();\n-        for(int n=0; n < nPseudoclasses; n++) {\n-            pseudoclasses.add(strings[is.readShort()]);\n-        }\n-        return new SimpleSelector(name, styleClasses, pseudoclasses, id);\n-    }\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/SimpleSelector.java","additions":0,"deletions":450,"binary":false,"changes":450,"status":"deleted"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package javafx.css;\n-\n-import java.util.List;\n-import java.util.Set;\n-\n-public class SimpleSelectorShim {\n-\n-    public static SimpleSelector getSimpleSelector(\n-            final String name, final List<String> styleClasses,\n-            final List<String> pseudoClasses, final String id) {\n-        return new SimpleSelector(name, styleClasses, pseudoClasses, id);\n-    }\n-\n-    public static Set<PseudoClass> getPseudoClassStates(SimpleSelector ss) {\n-        return ss.getPseudoClassStates();\n-    }\n-\n-}\n","filename":"modules\/javafx.graphics\/src\/shims\/java\/javafx\/css\/SimpleSelectorShim.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -57,1 +57,2 @@\n-import javafx.css.CompoundSelector;\n+import com.sun.javafx.css.CompoundSelector;\n+import com.sun.javafx.css.SimpleSelector;\n@@ -70,2 +71,0 @@\n-import javafx.css.SimpleSelector;\n-import javafx.css.SimpleSelectorShim;\n@@ -255,1 +254,1 @@\n-        if (selector instanceof SimpleSelector) {\n+        if (selector instanceof SimpleSelector s) {\n@@ -257,2 +256,1 @@\n-            pseudoClasses =\n-                    SimpleSelectorShim.getPseudoClassStates((SimpleSelector)selector);\n+            pseudoClasses = s.getPseudoClassStates();\n@@ -264,1 +262,1 @@\n-                Set<PseudoClass> selectorPseudoClasses = SimpleSelectorShim.getPseudoClassStates(sel);\n+                Set<PseudoClass> selectorPseudoClasses = sel.getPseudoClassStates();\n@@ -294,1 +292,1 @@\n-        Selector root = SimpleSelectorShim.getSimpleSelector(\"*\", rootStyleClass, null, null);\n+        Selector root = new SimpleSelector(\"*\", rootStyleClass, null, null);\n@@ -317,1 +315,1 @@\n-        Selector rect = SimpleSelectorShim.getSimpleSelector(\"*\", rectStyleClass, null, null);\n+        Selector rect = new SimpleSelector(\"*\", rectStyleClass, null, null);\n@@ -335,1 +333,1 @@\n-        Selector rectHover = SimpleSelectorShim.getSimpleSelector(\"*\", rectStyleClass, pseudoclasses, null);\n+        Selector rectHover = new SimpleSelector(\"*\", rectStyleClass, pseudoclasses, null);\n@@ -399,1 +397,1 @@\n-        Selector root = SimpleSelectorShim.getSimpleSelector(\"*\", rootStyleClass, null, null);\n+        Selector root = new SimpleSelector(\"*\", rootStyleClass, null, null);\n@@ -422,1 +420,1 @@\n-        Selector rect = SimpleSelectorShim.getSimpleSelector(\"*\", rectStyleClass, null, null);\n+        Selector rect = new SimpleSelector(\"*\", rectStyleClass, null, null);\n@@ -440,1 +438,1 @@\n-        Selector rectHover = SimpleSelectorShim.getSimpleSelector(\"*\", rectStyleClass, pseudoclasses, null);\n+        Selector rectHover = new SimpleSelector(\"*\", rectStyleClass, pseudoclasses, null);\n@@ -523,1 +521,1 @@\n-        Selector root = SimpleSelectorShim.getSimpleSelector(\"*\", rootStyleClass, null, null);\n+        Selector root = new SimpleSelector(\"*\", rootStyleClass, null, null);\n@@ -546,1 +544,1 @@\n-        Selector rect = SimpleSelectorShim.getSimpleSelector(\"*\", rectStyleClass, null, null);\n+        Selector rect = new SimpleSelector(\"*\", rectStyleClass, null, null);\n@@ -564,1 +562,1 @@\n-        Selector rectHover = SimpleSelectorShim.getSimpleSelector(\"*\", rectStyleClass, pseudoclasses, null);\n+        Selector rectHover = new SimpleSelector(\"*\", rectStyleClass, pseudoclasses, null);\n@@ -647,1 +645,1 @@\n-        Selector root = SimpleSelectorShim.getSimpleSelector(\"*\", rootStyleClass, null, null);\n+        Selector root = new SimpleSelector(\"*\", rootStyleClass, null, null);\n@@ -670,1 +668,1 @@\n-        Selector rect = SimpleSelectorShim.getSimpleSelector(\"*\", rectStyleClass, null, null);\n+        Selector rect = new SimpleSelector(\"*\", rectStyleClass, null, null);\n@@ -688,1 +686,1 @@\n-        Selector rectHover = SimpleSelectorShim.getSimpleSelector(\"*\", rectStyleClass, pseudoclasses, null);\n+        Selector rectHover = new SimpleSelector(\"*\", rectStyleClass, pseudoclasses, null);\n@@ -775,1 +773,1 @@\n-        Selector root = SimpleSelectorShim.getSimpleSelector(\"*\", rootStyleClass, null, null);\n+        Selector root = new SimpleSelector(\"*\", rootStyleClass, null, null);\n@@ -801,1 +799,1 @@\n-        Selector rect = SimpleSelectorShim.getSimpleSelector(\"*\", rectStyleClass, null, null);\n+        Selector rect = new SimpleSelector(\"*\", rectStyleClass, null, null);\n@@ -819,1 +817,1 @@\n-        Selector rectHover = SimpleSelectorShim.getSimpleSelector(\"*\", rectStyleClass, pseudoclasses, null);\n+        Selector rectHover = new SimpleSelector(\"*\", rectStyleClass, pseudoclasses, null);\n@@ -886,1 +884,1 @@\n-        Selector root = SimpleSelectorShim.getSimpleSelector(\"*\", rootStyleClass, null, null);\n+        Selector root = new SimpleSelector(\"*\", rootStyleClass, null, null);\n@@ -909,1 +907,1 @@\n-        Selector rect = SimpleSelectorShim.getSimpleSelector(\"*\", rectStyleClass, null, null);\n+        Selector rect = new SimpleSelector(\"*\", rectStyleClass, null, null);\n@@ -927,1 +925,1 @@\n-        Selector rectHover = SimpleSelectorShim.getSimpleSelector(\"*\", rectStyleClass, pseudoclasses, null);\n+        Selector rectHover = new SimpleSelector(\"*\", rectStyleClass, pseudoclasses, null);\n@@ -989,1 +987,1 @@\n-        Selector root = SimpleSelectorShim.getSimpleSelector(\"*\", rootStyleClass, null, null);\n+        Selector root = new SimpleSelector(\"*\", rootStyleClass, null, null);\n@@ -1009,1 +1007,1 @@\n-        Selector textSelector = SimpleSelectorShim.getSimpleSelector(\"*\", textStyleClass, null, null);\n+        Selector textSelector = new SimpleSelector(\"*\", textStyleClass, null, null);\n@@ -1070,1 +1068,1 @@\n-        Selector root = SimpleSelectorShim.getSimpleSelector(\"*\", rootStyleClass, null, null);\n+        Selector root = new SimpleSelector(\"*\", rootStyleClass, null, null);\n@@ -1090,1 +1088,1 @@\n-        Selector textSelector = SimpleSelectorShim.getSimpleSelector(\"*\", rectStyleClass, null, null);\n+        Selector textSelector = new SimpleSelector(\"*\", rectStyleClass, null, null);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/css\/CssMetaDataTest.java","additions":27,"deletions":29,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.javafx.css.SimpleSelector;\n@@ -39,2 +40,0 @@\n-import javafx.css.SimpleSelector;\n-import javafx.css.SimpleSelectorShim;\n@@ -91,2 +90,1 @@\n-            this.selector =\n-                SimpleSelectorShim.getSimpleSelector(type, styleClasses, null, id);\n+            this.selector = new SimpleSelector(type, styleClasses, null, id);\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/css\/SelectorPartitioningTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.javafx.css.SimpleSelector;\n@@ -52,1 +53,0 @@\n-import javafx.css.SimpleSelector;\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/css\/StylesheetTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}