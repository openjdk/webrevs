{"files":[{"patch":"@@ -42,4 +42,0 @@\n-        if (ALPHA_MAP == null) {\n-            initAlphaMaps();\n-        }\n-\n@@ -101,2 +97,2 @@\n-    static byte[] ALPHA_MAP;\n-    static OffHeapArray ALPHA_MAP_OFF_HEAP;\n+    static final byte[] ALPHA_MAP;\n+    static final OffHeapArray ALPHA_MAP_OFF_HEAP;\n@@ -104,2 +100,2 @@\n-    static byte[] ALPHA_MAP_NO_AA;\n-    static OffHeapArray ALPHA_MAP_OFF_HEAP_NO_AA;\n+    static final byte[] ALPHA_MAP_NO_AA;\n+    static final OffHeapArray ALPHA_MAP_OFF_HEAP_NO_AA;\n@@ -107,1 +103,1 @@\n-    static void initAlphaMaps() {\n+    static {\n@@ -111,1 +107,1 @@\n-        ALPHA_MAP_OFF_HEAP = new OffHeapArray(ALPHA_MAP, ALPHA_MAP.length); \/\/ 1K\n+        ALPHA_MAP_OFF_HEAP = new OffHeapArray(ALPHA_MAP, ALPHA_MAP.length, true); \/\/ 1K\n@@ -120,1 +116,1 @@\n-        ALPHA_MAP_OFF_HEAP_NO_AA = new OffHeapArray(ALPHA_MAP_NO_AA, ALPHA_MAP_NO_AA.length);\n+        ALPHA_MAP_OFF_HEAP_NO_AA = new OffHeapArray(ALPHA_MAP_NO_AA, ALPHA_MAP_NO_AA.length, true);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/MaskMarlinAlphaConsumer.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+    private final boolean global;\n@@ -49,0 +50,8 @@\n+    \/**\n+     * Creates an OffHeapArray of the specified length using a confined arena.\n+     * All access to this array must be done on the same thread that constructed it.\n+     *\n+     * @param parent the object that will be used to register a cleaner to\n+     * free the off-heap array when {@code parent} becomes phantom reachable\n+     * @param len the number of bytes to allocate\n+     *\/\n@@ -50,1 +59,25 @@\n-        arena = Arena.ofConfined();\n+        this(parent, len, false);\n+    }\n+\n+    \/**\n+     * Creates an OffHeapArray of the specified length using either the global\n+     * arena or a confined arena. If the global arena is specified, the array\n+     * may be accessed on any thread, but it must not be resized or freed.\n+     * If a confined arena is specified, all access to this array must be done\n+     * on the same thread that constructed it.\n+     *\n+     * @param parent the object that will be used to register a cleaner to\n+     * free the off-heap array when {@code parent} becomes phantom reachable;\n+     * this is unused if the global arena is specified\n+     * @param len the number of bytes to allocate\n+     * @param global if {@code true} use the global arena, otherwise use a\n+     * confined arena\n+     *\/\n+    OffHeapArray(final Object parent, final long len, boolean global) {\n+        this.global = global;\n+\n+        if (global) {\n+            arena = Arena.global();\n+        } else {\n+            arena = Arena.ofConfined();\n+        }\n@@ -61,2 +94,4 @@\n-        \/\/ Register a cleaning function to ensure freeing off-heap memory:\n-        MarlinUtils.getCleaner().register(parent, this::free);\n+        if (!global) {\n+            \/\/ Register a cleaning function to ensure freeing off-heap memory:\n+            MarlinUtils.getCleaner().register(parent, this::free);\n+        }\n@@ -104,0 +139,4 @@\n+        if (global) {\n+            throw new UnsupportedOperationException(\"Cannot resize a global OffHeapArray\");\n+        }\n+\n@@ -126,0 +165,4 @@\n+        if (global) {\n+            throw new UnsupportedOperationException(\"Cannot free a global OffHeapArray\");\n+        }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/marlin\/OffHeapArray.java","additions":46,"deletions":3,"binary":false,"changes":49,"status":"modified"}]}