{"files":[{"patch":"@@ -80,0 +80,2 @@\n+\n+        self.colorspace = CGColorSpaceCreateWithName(kCGColorSpaceSRGB);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassLayer3D.m","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -639,1 +639,1 @@\n-                        CGColorSpaceRef space = CGColorSpaceCreateDeviceRGB();\n+                        CGColorSpaceRef space = CGColorSpaceCreateWithName(kCGColorSpaceSRGB);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassPasteboard.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-        CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();\n+        CGColorSpaceRef colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceSRGB);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassPixels.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -399,0 +399,1 @@\n+    CGColorRef origColor = NULL;\n@@ -418,0 +419,6 @@\n+                        CGFloat components[4];\n+                        components[0] = (CGFloat)((color & 0x00FF0000) >> 16) \/ 255.0;\n+                        components[1] = (CGFloat)((color & 0x0000FF00) >> 8) \/ 255.0;\n+                        components[2] = (CGFloat)((color & 0x000000FF)) \/ 255.0;\n+                        components[3] = (CGFloat)((color & 0xFF000000) >> 24) \/ 255.0;\n+                        origColor = CGColorCreate(CGImageGetColorSpace(screenImage), components);\n@@ -425,0 +432,13 @@\n+\n+    if (origColor != NULL) {\n+        CGColorSpaceRef sRGBSpace = CGColorSpaceCreateWithName(kCGColorSpaceSRGB);\n+        CGColorRef correctedColor = CGColorCreateCopyByMatchingToColorSpace(sRGBSpace, kCGRenderingIntentAbsoluteColorimetric, origColor, NULL);\n+        const CGFloat* components = CGColorGetComponents(correctedColor);\n+        color  = ((jint)(round(components[3] * 255)) & 0xFF) << 24;\n+        color |= ((jint)(round(components[0] * 255)) & 0xFF) << 16;\n+        color |= ((jint)(round(components[1] * 255)) & 0xFF) << 8;\n+        color |= ((jint)(round(components[2] * 255)) & 0xFF);\n+        CGColorSpaceRelease(sRGBSpace);\n+        CGColorRelease(correctedColor);\n+        CGColorRelease(origColor);\n+    }\n@@ -479,1 +499,1 @@\n-                            kCGColorSpaceGenericRGB);\n+                            kCGColorSpaceSRGB);\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassRobot.m","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-#pragma clang diagnostic ignored \"-Wdeprecated-declarations\"\n-\n@@ -333,1 +331,1 @@\n-        [[layer getPainterOffscreen] setBackgroundColor:[[[self window] backgroundColor] colorUsingColorSpaceName:NSDeviceRGBColorSpace]];\n+        [[layer getPainterOffscreen] setBackgroundColor:[[[self window] backgroundColor] colorUsingColorSpace:NSColorSpace.sRGBColorSpace]];\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassView3D.m","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -783,1 +783,1 @@\n-        [window->nsWindow setBackgroundColor:[NSColor colorWithCalibratedRed:r green:g blue:b alpha:1.0f]];\n+        [window->nsWindow setBackgroundColor:[NSColor colorWithSRGBRed:r green:g blue:b alpha:1.0f]];\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/GlassWindow.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-    NSColor* c = [color colorUsingColorSpace:[NSColorSpace deviceRGBColorSpace]];\n+    NSColor* c = [color colorUsingColorSpace:[NSColorSpace sRGBColorSpace]];\n@@ -271,1 +271,1 @@\n-        NSColor* c = [colors[i] colorUsingColorSpace:[NSColorSpace deviceRGBColorSpace]];\n+        NSColor* c = [colors[i] colorUsingColorSpace:[NSColorSpace sRGBColorSpace]];\n","filename":"modules\/javafx.graphics\/src\/main\/native-glass\/mac\/PlatformSupport.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.robot.javafx.scene;\n+\n+import javafx.geometry.Bounds;\n+import javafx.geometry.Point2D;\n+import javafx.geometry.Rectangle2D;\n+import javafx.scene.Scene;\n+import javafx.scene.image.PixelReader;\n+import javafx.scene.image.WritableImage;\n+import javafx.scene.layout.HBox;\n+import javafx.scene.paint.Color;\n+import javafx.scene.robot.Robot;\n+import javafx.scene.shape.Rectangle;\n+import javafx.stage.Screen;\n+import javafx.stage.Stage;\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.GraphicsEnvironment;\n+import javax.swing.SwingUtilities;\n+\n+import com.sun.glass.ui.Application;\n+import com.sun.glass.ui.Window;\n+import com.sun.javafx.PlatformUtil;\n+\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.Test;\n+import static org.junit.Assume.assumeTrue;\n+\n+import test.robot.testharness.VisualTestBase;\n+\n+public class SRGBTest extends VisualTestBase {\n+\n+    private static final int SWATCH_SIZE = 200;\n+\n+    \/\/ Avoid testing colors out near the edge of the gamut to avoid clipping\n+    \/\/ when converting between spaces.\n+    static final float LOW = 0.25f;\n+    static final float MID = 0.50f;\n+    static final float HIGH = 0.75f;\n+\n+    \/\/ The component tolerance allows one bit of rounding when writing a color\n+    \/\/ out and another bit when reading it back in.\n+    static final double COMPONENT_TOLERANCE = 2.0 \/ 255.0;\n+\n+    private enum TestColor {\n+        COLOR_01(LOW, MID, HIGH),\n+        COLOR_02(LOW, HIGH, MID),\n+        COLOR_03(MID, LOW, HIGH),\n+        COLOR_04(MID, HIGH, LOW),\n+        COLOR_05(HIGH, LOW, MID),\n+        COLOR_06(HIGH, MID, LOW);\n+\n+        public final float red;\n+        public final float green;\n+        public final float blue;\n+\n+        TestColor(float r, float g, float b) {\n+            red = r;\n+            green = g;\n+            blue = b;\n+        }\n+    };\n+\n+    \/\/ We center windows in the visual bounds of the screen to make it easy\n+    \/\/ for both JavaFX and AWT to sample from the same point.\n+    private Point2D getJFXScreenCenter() {\n+        Rectangle2D screenBounds = Screen.getPrimary().getVisualBounds();\n+        double centerX = screenBounds.getMinX() + screenBounds.getWidth() \/ 2.0;\n+        double centerY = screenBounds.getMinY() + screenBounds.getHeight() \/ 2.0;\n+        return new Point2D(centerX, centerY);\n+    }\n+\n+    \/\/ An AWT Robot is color space aware and will correctly convert from the\n+    \/\/ screeen's color space to sRGB. We use one to verify that the JavaFX\n+    \/\/ Robot is performing the same conversions.\n+    private Color getSRGBColorAtScreenCenter() throws Exception {\n+        float[] sRGB = {1.0f, 1,0f, 1.0f};\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                GraphicsEnvironment environment = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+                java.awt.Rectangle bounds = environment.getMaximumWindowBounds();\n+                int centerX = (int) (bounds.getMinX() + bounds.getWidth() \/ 2.0);\n+                int centerY = (int) (bounds.getMinY() + bounds.getHeight() \/ 2.0);\n+\n+                java.awt.Robot awtRobot = new java.awt.Robot();\n+                java.awt.Color awtColor = awtRobot.getPixelColor(centerX, centerY);\n+                ColorSpace colorSpace = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+                awtColor.getColorComponents(colorSpace, sRGB);\n+            }\n+            catch (final Exception ex)\n+            {\n+                throw new RuntimeException(ex);\n+            }\n+        });\n+        return new Color(sRGB[0], sRGB[1], sRGB[2], 1.0);\n+    }\n+\n+    \/\/ Create a stage in the center of the visual bounds and return a swatch\n+    \/\/ to hold the color.\n+    private Rectangle prepareStage() {\n+        AtomicReference<Rectangle> rectangle = new AtomicReference<>();\n+\n+        runAndWait(() -> {\n+            Stage stage = getStage();\n+\n+            Rectangle swatch = new Rectangle(SWATCH_SIZE, SWATCH_SIZE);\n+            rectangle.set(swatch);\n+\n+            HBox root = new HBox(swatch);\n+            Scene scene = new Scene(root);\n+            stage.setScene(scene);\n+            stage.setOnShown(e -> {\n+                stage.sizeToScene();\n+                Point2D center = getJFXScreenCenter();\n+                stage.setX(center.getX() - stage.getWidth() \/ 2.0);\n+                stage.setY(center.getY() - stage.getHeight() \/ 2.0);\n+            });\n+            stage.show();\n+        });\n+\n+        waitFirstFrame();\n+        return rectangle.get();\n+    }\n+\n+    \/\/ Change the color of the swatch and wait for it to be drawn.\n+    private Color prepareSwatch(Rectangle swatch, TestColor testColor) {\n+        float r = testColor.red;\n+        float g = testColor.green;\n+        float b = testColor.blue;\n+        Color expected = new Color(r, g, b, 1.0);\n+        runAndWait(() -> {\n+            swatch.setFill(expected);\n+        });\n+        waitNextFrame();\n+        return expected;\n+    }\n+\n+    \/\/ Find the center of the swatch.\n+    private Point2D findCenter(Rectangle swatch) {\n+        Bounds screenBounds = swatch.localToScreen(swatch.getBoundsInLocal());\n+        double centerX = screenBounds.getMinX() + screenBounds.getWidth() \/ 2.0;\n+        double centerY = screenBounds.getMinY() + screenBounds.getHeight() \/ 2.0;\n+        return new Point2D(centerX, centerY);\n+    }\n+\n+    \/\/ Tests that a color can be written out and then retrieved using a JavaFX\n+    \/\/ Robot's getPixelColor call. This can fail if the drawing code and the\n+    \/\/ Robot have mismatched policies for handling color space conversions.\n+    @Test\n+    public void singlePixelTest() {\n+        Rectangle swatch = prepareStage();\n+        Robot robot = getRobot();\n+\n+        for (TestColor testColor : TestColor.values()) {\n+            Color expected = prepareSwatch(swatch, testColor);\n+            AtomicReference<Color> actual = new AtomicReference<>();\n+            runAndWait(() -> {\n+                Point2D center = findCenter(swatch);\n+                actual.set(robot.getPixelColor(center));\n+            });\n+            assertColorEquals(expected, actual.get(), COMPONENT_TOLERANCE);\n+        }\n+    }\n+\n+    \/\/ Tests that a color can be written out and then retrieved using a JavaFX\n+    \/\/ Robot's getScreenCapture call. This can fail if the drawing code and\n+    \/\/ the Robot have mismatched policies for handling color space\n+    \/\/ conversions.\n+    @Test\n+    public void screenCaptureTest() {\n+        Rectangle swatch = prepareStage();\n+        Robot robot = getRobot();\n+\n+        for (TestColor testColor : TestColor.values()) {\n+            Color expected = prepareSwatch(swatch, testColor);\n+            AtomicReference<Color> actual = new AtomicReference<>();\n+            runAndWait(() -> {\n+                Point2D center = findCenter(swatch);\n+                WritableImage image = robot.getScreenCapture(null, center.getX(), center.getY(), 5, 5);\n+                PixelReader reader = image.getPixelReader();\n+                actual.set(reader.getColor(3, 3));\n+            });\n+            assertColorEquals(expected, actual.get(), COMPONENT_TOLERANCE);\n+        }\n+    }\n+\n+    \/\/ Tests that pixels are correctly written out as sRGB using an AWT Robot\n+    \/\/ that is color space aware. The singlePixel and screenCapture tests\n+    \/\/ only verify that the JavaFX renderer and JavaFX Robot can round-trip\n+    \/\/ colors but they might both be working in the wrong space. We use an\n+    \/\/ AWT Robot to verify that they are working in sRGB.\n+    @Test\n+    public void sRGBPixelTest() throws Exception {\n+        Rectangle swatch = prepareStage();\n+\n+        for (TestColor testColor : TestColor.values()) {\n+            Color expected = prepareSwatch(swatch, testColor);\n+            Color actual = getSRGBColorAtScreenCenter();\n+            assertColorEquals(expected, actual, COMPONENT_TOLERANCE);\n+        }\n+    }\n+\n+    \/\/ Test that Glass is correctly interpreting the window's background\n+    \/\/ color as sRGB (only applies to Mac).\n+    @Test\n+    public void windowBackgroundTest() throws Exception {\n+        assumeTrue(PlatformUtil.isMac());\n+        AtomicReference<Window> window = new AtomicReference<>();\n+        runAndWait(() -> {\n+            Point2D center = getJFXScreenCenter();\n+            int positionX = (int)(center.getX() - SWATCH_SIZE \/ 2.0);\n+            int positionY = (int)(center.getY() - SWATCH_SIZE \/ 2.0);\n+            Application app = Application.GetApplication();\n+            Window w = app.createWindow(null, com.sun.glass.ui.Screen.getMainScreen(), Window.UNTITLED);\n+            w.setLevel(Window.Level.TOPMOST);\n+            w.setSize(SWATCH_SIZE, SWATCH_SIZE);\n+            w.setPosition(positionX, positionY);\n+            w.setVisible(true);\n+            window.set(w);\n+        });\n+\n+        \/\/ Ensure the window gets cleaned up.\n+        try {\n+            for (TestColor testColor : TestColor.values()) {\n+                runAndWait(() -> {\n+                    window.get().setBackground(testColor.red, testColor.green, testColor.blue);\n+                });\n+                waitNextFrame();\n+\n+                Color expected = new Color(testColor.red, testColor.green, testColor.blue, 1.0f);\n+                Color actual = getSRGBColorAtScreenCenter();\n+                assertColorEquals(expected, actual, COMPONENT_TOLERANCE);\n+            }\n+        } finally {\n+            runAndWait(() -> {\n+                window.get().close();\n+            });\n+        }\n+    }\n+}\n","filename":"tests\/system\/src\/test\/java\/test\/robot\/javafx\/scene\/SRGBTest.java","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"}]}