{"files":[{"patch":"@@ -45,0 +45,1 @@\n+import javafx.scene.layout.HeaderBar;\n@@ -463,4 +464,4 @@\n-     * Specifies the style for this dialog. This must be done prior to making\n-     * the dialog visible. The style is one of: StageStyle.DECORATED,\n-     * StageStyle.UNDECORATED, StageStyle.TRANSPARENT, StageStyle.UTILITY,\n-     * or StageStyle.UNIFIED.\n+     * Specifies the style for this dialog. This must be done prior to making the dialog visible.\n+     * <p>\n+     * Note that a dialog with the {@link StageStyle#EXTENDED} style should also specify a {@link HeaderBar} with\n+     * the {@link DialogPane#setHeaderBar(HeaderBar)} method, as otherwise the dialog window will not be draggable.\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/Dialog.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import com.sun.javafx.PreviewFeature;\n+import com.sun.javafx.css.StyleManager;\n@@ -54,0 +56,1 @@\n+import javafx.css.converter.StringConverter;\n@@ -55,0 +58,1 @@\n+import javafx.geometry.HPos;\n@@ -56,0 +60,1 @@\n+import javafx.geometry.VPos;\n@@ -63,0 +68,1 @@\n+import javafx.scene.layout.HeaderBar;\n@@ -67,3 +73,1 @@\n-\n-import com.sun.javafx.css.StyleManager;\n-import javafx.css.converter.StringConverter;\n+import javafx.stage.StageStyle;\n@@ -433,0 +437,68 @@\n+    \/\/ --- header bar\n+    private ObjectProperty<HeaderBar> headerBar;\n+\n+    \/**\n+     * Specifies the {@link HeaderBar} for the dialog. The {@code HeaderBar} will be placed at the\n+     * top of the dialog window, and extend the entire width of the window. This property will only\n+     * be used if the dialog window is configured with the {@link StageStyle#EXTENDED} style; it has\n+     * no effect for other styles.\n+     *\n+     * @return the {@code headerBar} property\n+     * @defaultValue {@code null}\n+     * @since 26\n+     * @deprecated This is a preview feature which may be changed or removed in a future release.\n+     *\/\n+    @Deprecated(since = \"26\")\n+    public final ObjectProperty<HeaderBar> headerBarProperty() {\n+        if (headerBar == null) {\n+            PreviewFeature.HEADER_BAR.checkEnabled();\n+            headerBar = new SimpleObjectProperty<>(this, \"headerBar\") {\n+                WeakReference<HeaderBar> wref = new WeakReference<>(null);\n+\n+                @Override\n+                protected void invalidated() {\n+                    HeaderBar oldValue = wref.get();\n+                    if (oldValue != null) {\n+                        getChildren().remove(oldValue);\n+                    }\n+\n+                    HeaderBar newValue = get();\n+                    if (newValue != null) {\n+                        getChildren().add(newValue);\n+                    }\n+\n+                    wref = new WeakReference<>(newValue);\n+                }\n+            };\n+        }\n+\n+        return headerBar;\n+    }\n+\n+    \/**\n+     * Gets the value of the {@link #headerBarProperty() headerBar} property.\n+     *\n+     * @return the {@code HeaderBar}\n+     * @since 26\n+     * @deprecated This is a preview feature which may be changed or removed in a future release.\n+     *\/\n+    @Deprecated(since = \"26\")\n+    public final HeaderBar getHeaderBar() {\n+        PreviewFeature.HEADER_BAR.checkEnabled();\n+        return headerBar != null ? headerBar.get() : null;\n+    }\n+\n+    \/**\n+     * Sets the value of the {@link #headerBarProperty() headerBar} property.\n+     *\n+     * @param value the new value\n+     * @since 26\n+     * @deprecated This is a preview feature which may be changed or removed in a future release.\n+     *\/\n+    @Deprecated(since = \"26\")\n+    public final void setHeaderBar(HeaderBar value) {\n+        PreviewFeature.HEADER_BAR.checkEnabled();\n+        if (headerBar != null || value != null) {\n+            headerBarProperty().set(value);\n+        }\n+    }\n@@ -881,0 +953,1 @@\n+        final HeaderBar headerBar = getHeaderBar();\n@@ -886,0 +959,3 @@\n+        final double headerBarPrefHeight = headerBar != null\n+            ? Utils.boundedSize(headerBar.prefHeight(w), headerBar.minHeight(w), headerBar.maxHeight(w))\n+            : 0;\n@@ -897,1 +973,1 @@\n-            expandableContentPrefHeight = h - (headerPrefHeight + contentAndGraphicHeight + buttonBarPrefHeight);\n+            expandableContentPrefHeight = h - (headerBarPrefHeight + headerPrefHeight + contentAndGraphicHeight + buttonBarPrefHeight);\n@@ -901,1 +977,1 @@\n-            contentAreaHeight = h - (headerPrefHeight + expandableContentPrefHeight + buttonBarPrefHeight);\n+            contentAreaHeight = h - (headerBarPrefHeight + headerPrefHeight + expandableContentPrefHeight + buttonBarPrefHeight);\n@@ -905,0 +981,4 @@\n+        if (headerBar != null) {\n+            layoutInArea(headerBar, 0, 0, w, headerBarPrefHeight, 0, HPos.LEFT, VPos.TOP);\n+        }\n+\n@@ -906,1 +986,1 @@\n-        double y = topPadding;\n+        double y = topPadding + headerBarPrefHeight;\n@@ -936,0 +1016,1 @@\n+        double headerBarMinWidth = getHeaderBar() instanceof HeaderBar hb ? hb.minWidth(height) : 0;\n@@ -952,1 +1033,1 @@\n-        return snapSizeX(minWidth);\n+        return snapSizeX(Math.max(minWidth, headerBarMinWidth));\n@@ -959,0 +1040,1 @@\n+        double headerBarMinHeight = getHeaderBar() instanceof HeaderBar hb ? hb.minHeight(width) : 0;\n@@ -979,0 +1061,1 @@\n+                headerBarMinHeight +\n@@ -994,0 +1077,2 @@\n+        double headerBarPrefWidth = getHeaderBar() instanceof HeaderBar hb\n+            ? Utils.boundedSize(hb.prefWidth(height), hb.minWidth(height), hb.maxWidth(height)) : 0;\n@@ -1006,1 +1091,1 @@\n-        return snapSizeX(prefWidth);\n+        return snapSizeX(Math.max(prefWidth, headerBarPrefWidth));\n@@ -1015,0 +1100,2 @@\n+        double headerBarPrefHeight = getHeaderBar() instanceof HeaderBar hb\n+            ? Utils.boundedSize(hb.prefHeight(width), hb.minHeight(width), hb.maxHeight(width)) : 0;\n@@ -1032,0 +1119,1 @@\n+               headerBarPrefHeight +\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/DialogPane.java","additions":97,"deletions":9,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -31,0 +32,1 @@\n+import javafx.geometry.BoundingBox;\n@@ -40,0 +42,1 @@\n+import javafx.scene.layout.HeaderBar;\n@@ -164,0 +167,23 @@\n+\n+    @Test\n+    public void headerBarIsLocatedAtTopOfDialogPane() {\n+        var headerBar = new HeaderBar();\n+        headerBar.setMinHeight(20);\n+        headerBar.setPrefHeight(20);\n+        dialogPane.setHeaderBar(headerBar);\n+        dialogPane.resize(1000, 1000);\n+        dialogPane.applyCss();\n+        dialogPane.layout();\n+\n+        assertEquals(\n+            new BoundingBox(0, 0, 1000, 20),\n+            dialogPane.lookup(\"HeaderBar\").getLayoutBounds());\n+\n+        dialogPane.getChildren().stream()\n+            .filter(Node::isVisible)\n+            .filter(c -> c != headerBar)\n+            .forEach(child ->\n+                assertTrue(child.getLayoutY() >= headerBar.getHeight(), () ->\n+                    child.getClass().getSimpleName() + \" must be located below HeaderBar, layoutY = \" + child.getLayoutBounds())\n+            );\n+    }\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/DialogPaneTest.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,0 +105,11 @@\n+    @Test\n+    public void testInitialDialogPaneIsAttachedToScene() {\n+        class TestDialog extends Dialog<ButtonType> {\n+            TestDialog() {\n+                assertNotNull(getDialogPane().getScene());\n+            }\n+        }\n+\n+        assertDoesNotThrow(TestDialog::new);\n+    }\n+\n","filename":"modules\/javafx.controls\/src\/test\/java\/test\/javafx\/scene\/control\/DialogTest.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -151,0 +151,20 @@\n+    \/\/ The size and placement of the window button area depends on many variables, most of which\n+    \/\/ are CSS-styleable properties of HeaderButtonOverlay and HeaderButtonOverlay#ButtonRegion.\n+    \/\/ Detecting when the window button area has changed is quite difficult, and doing so manually\n+    \/\/ would require adding listeners to all properties that can affect it. This not only includes\n+    \/\/ all properties declared in this class, but also properties like button borders, padding, etc.\n+    \/\/ Instead of doing that, we always recompute the window button area after a CSS processing pass\n+    \/\/ for HeaderButtonOverlay has completed and notify potential listeners if it has changed.\n+    static {\n+        HeaderButtonOverlayHelper.setAccessor(new HeaderButtonOverlayHelper.Accessor() {\n+            @Override\n+            public void afterProcessCSS(HeaderButtonOverlay overlay) {\n+                overlay.updateButtonMetrics();\n+            }\n+        });\n+    }\n+\n+    {\n+        HeaderButtonOverlayHelper.initHelper(this);\n+    }\n+\n@@ -220,1 +240,7 @@\n-        this, \"prefButtonHeight\", HeaderBar.USE_DEFAULT_SIZE);\n+        this, \"prefButtonHeight\", HeaderBar.USE_DEFAULT_SIZE) {\n+            @Override\n+            protected void invalidated() {\n+                updateButtonMetrics(); \/\/ needed here because this property is not CSS-styleable\n+                requestLayout();\n+            }\n+        };\n@@ -227,2 +253,9 @@\n-    private final StyleableDoubleProperty buttonDefaultHeight = new SimpleStyleableDoubleProperty(\n-        BUTTON_DEFAULT_HEIGHT_METADATA, this, \"buttonDefaultHeight\");\n+    private final StyleableDoubleProperty buttonDefaultHeight =\n+        new SimpleStyleableDoubleProperty(\n+                BUTTON_DEFAULT_HEIGHT_METADATA, this, \"buttonDefaultHeight\") {\n+            @Override\n+            protected void invalidated() {\n+                \/\/ updateButtonMetrics() not needed here, see afterProcessCSS()\n+                requestLayout();\n+            }\n+        };\n@@ -240,0 +273,1 @@\n+                \/\/ updateButtonMetrics() not needed here, see afterProcessCSS()\n@@ -255,0 +289,1 @@\n+                \/\/ updateButtonMetrics() not needed here, see afterProcessCSS()\n@@ -264,0 +299,1 @@\n+    private final ButtonLayoutInfo layoutInfo = new ButtonLayoutInfo();\n@@ -310,3 +346,1 @@\n-            stylesheet.subscribe(this::updateStylesheet),\n-            prefButtonHeight.subscribe(this::requestLayout),\n-            buttonDefaultHeight.subscribe(this::requestLayout));\n+            stylesheet.subscribe(this::updateStylesheet));\n@@ -321,0 +355,2 @@\n+\n+        updateButtonMetrics();\n@@ -507,2 +543,1 @@\n-    @Override\n-    protected void layoutChildren() {\n+    private boolean updateButtonLayoutInfo() {\n@@ -533,1 +568,0 @@\n-        double width = getWidth();\n@@ -540,3 +574,0 @@\n-        double button1X = snapPositionX(left ? 0 : width - button1Width - button2Width - button3Width);\n-        double button2X = snapPositionX(left ? button1Width : width - button3Width - button2Width);\n-        double button3X = snapPositionX(left ? button1Width + button2Width : width - button3Width);\n@@ -552,3 +583,0 @@\n-                button1X = snapPositionX(button1X + offset);\n-                button2X = snapPositionX(button2X + offset);\n-                button3X = snapPositionX(button3X + offset);\n@@ -558,3 +586,0 @@\n-                button1X = snapPositionX(button1X - offset);\n-                button2X = snapPositionX(button2X - offset);\n-                button3X = snapPositionX(button3X - offset);\n@@ -569,1 +594,13 @@\n-        Dimension2D currentSize = left ? metrics.get().leftInset() : metrics.get().rightInset();\n+        return layoutInfo.update(\n+            button1, button1Width, button1Height,\n+            button2, button2Width, button2Height,\n+            button3, button3Width, button3Height,\n+            totalWidth, totalHeight, left);\n+    }\n+\n+    private void updateButtonMetrics() {\n+        if (!updateButtonLayoutInfo()) {\n+            return;\n+        }\n+\n+        Dimension2D currentSize = layoutInfo.left() ? metrics.get().leftInset() : metrics.get().rightInset();\n@@ -572,1 +609,1 @@\n-        if (currentSize.getWidth() != totalWidth || currentSize.getHeight() != totalHeight) {\n+        if (currentSize.getWidth() != layoutInfo.totalWidth() || currentSize.getHeight() != layoutInfo.totalHeight()) {\n@@ -574,2 +611,2 @@\n-            var size = new Dimension2D(totalWidth, totalHeight);\n-            HeaderButtonMetrics newMetrics = left\n+            var size = new Dimension2D(layoutInfo.totalWidth(), layoutInfo.totalHeight());\n+            HeaderButtonMetrics newMetrics = layoutInfo.left()\n@@ -580,0 +617,1 @@\n+    }\n@@ -581,11 +619,11 @@\n-        layoutInArea(button1, button1X, getButtonOffsetY(button1Height), button1Width, button1Height,\n-                     BASELINE_OFFSET_SAME_AS_HEIGHT, Insets.EMPTY, true, true,\n-                     HPos.LEFT, VPos.TOP, false);\n-\n-        layoutInArea(button2, button2X, getButtonOffsetY(button2Height), button2Width, button2Height,\n-                     BASELINE_OFFSET_SAME_AS_HEIGHT, Insets.EMPTY, true, true,\n-                     HPos.LEFT, VPos.TOP, false);\n-\n-        layoutInArea(button3, button3X, getButtonOffsetY(button3Height), button3Width, button3Height,\n-                     BASELINE_OFFSET_SAME_AS_HEIGHT, Insets.EMPTY, true, true,\n-                     HPos.LEFT, VPos.TOP, false);\n+    @Override\n+    protected void layoutChildren() {\n+        double[] offsets = layoutInfo.getLayoutOffsetsForWidth(getWidth());\n+\n+        for (int i = 0; i < 3; ++i) {\n+            ButtonSizeInfo sizeInfo = layoutInfo.buttonSizeAt(i);\n+            layoutInArea(sizeInfo.button(), offsets[i], getButtonOffsetY(sizeInfo.height()),\n+                         sizeInfo.width(), sizeInfo.height(),\n+                         BASELINE_OFFSET_SAME_AS_HEIGHT, Insets.EMPTY, true, true,\n+                         HPos.LEFT, VPos.TOP, false);\n+        }\n@@ -689,0 +727,111 @@\n+\n+    \/**\n+     * Contains the computed size for a window button.\n+     *\/\n+    private static final class ButtonSizeInfo {\n+\n+        private Region button;\n+        private double width;\n+        private double height;\n+\n+        public Region button() {\n+            return button;\n+        }\n+\n+        public double width() {\n+            return width;\n+        }\n+\n+        public double height() {\n+            return height;\n+        }\n+\n+        boolean update(Region button, double width, double height) {\n+            if (this.button != button || this.width != width || this.height != height) {\n+                this.button = button;\n+                this.width = width;\n+                this.height = height;\n+                return true;\n+            }\n+\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * Contains the sizes of the window buttons, the total width and height of the window button area,\n+     * and its placement. The horizontal layout offsets of the window buttons are not precomputed, as\n+     * they depend on the window width.\n+     *\/\n+    private final class ButtonLayoutInfo {\n+\n+        private final double[] temp = new double[3];\n+        private final ButtonSizeInfo[] buttonSizes = new ButtonSizeInfo[] {\n+            new ButtonSizeInfo(), new ButtonSizeInfo(), new ButtonSizeInfo()\n+        };\n+\n+        private boolean left;\n+        private double totalWidth;\n+        private double totalHeight;\n+\n+        public ButtonSizeInfo buttonSizeAt(int i) {\n+            return buttonSizes[i];\n+        }\n+\n+        public boolean left() {\n+            return left;\n+        }\n+\n+        public double totalWidth() {\n+            return totalWidth;\n+        }\n+\n+        public double totalHeight() {\n+            return totalHeight;\n+        }\n+\n+        public double[] getLayoutOffsetsForWidth(double width) {\n+            double button1X = snapPositionX(left ? 0 : width - buttonSizes[0].width - buttonSizes[1].width - buttonSizes[2].width);\n+            double button2X = snapPositionX(left ? buttonSizes[0].width : width - buttonSizes[2].width - buttonSizes[1].width);\n+            double button3X = snapPositionX(left ? buttonSizes[0].width + buttonSizes[1].width : width - buttonSizes[2].width);\n+\n+            if (buttonVerticalAlignment.get() == ButtonVerticalAlignment.CENTER) {\n+                if (left) {\n+                    double offset = getButtonOffsetY(buttonSizes[0].height);\n+                    button1X = snapPositionX(button1X + offset);\n+                    button2X = snapPositionX(button2X + offset);\n+                    button3X = snapPositionX(button3X + offset);\n+                } else {\n+                    double offset = getButtonOffsetY(buttonSizes[2].height);\n+                    button1X = snapPositionX(button1X - offset);\n+                    button2X = snapPositionX(button2X - offset);\n+                    button3X = snapPositionX(button3X - offset);\n+                }\n+            }\n+\n+            temp[0] = button1X;\n+            temp[1] = button2X;\n+            temp[2] = button3X;\n+            return temp;\n+        }\n+\n+        boolean update(Region button1, double width1, double height1,\n+                       Region button2, double width2, double height2,\n+                       Region button3, double width3, double height3,\n+                       double totalWidth, double totalHeight, boolean left) {\n+            \/\/ Note: the following disjunction operators are NOT short-circuiting:\n+            boolean changed =\n+                this.buttonSizes[0].update(button1, width1, height1) |\n+                this.buttonSizes[1].update(button2, width2, height2) |\n+                this.buttonSizes[2].update(button3, width3, height3);\n+\n+            if (this.totalWidth != totalWidth || this.totalHeight != totalHeight || this.left != left || changed) {\n+                this.totalWidth = totalWidth;\n+                this.totalHeight = totalHeight;\n+                this.left = left;\n+                return true;\n+            }\n+\n+            return false;\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/HeaderButtonOverlay.java","additions":182,"deletions":33,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui;\n+\n+import com.sun.javafx.scene.layout.RegionHelper;\n+import com.sun.javafx.util.Utils;\n+import javafx.scene.Node;\n+\n+final class HeaderButtonOverlayHelper extends RegionHelper {\n+\n+    private static final HeaderButtonOverlayHelper theInstance = new HeaderButtonOverlayHelper();\n+    private static Accessor theAccessor;\n+\n+    private HeaderButtonOverlayHelper() {}\n+\n+    static {\n+        Utils.forceInit(HeaderButtonOverlay.class);\n+    }\n+\n+    public static void setAccessor(Accessor accessor) {\n+        theAccessor = accessor;\n+    }\n+\n+    public static void initHelper(HeaderButtonOverlay overlay) {\n+        setHelper(overlay, theInstance);\n+    }\n+\n+    @Override\n+    protected void processCSSImpl(Node node) {\n+        super.processCSSImpl(node);\n+        theAccessor.afterProcessCSS((HeaderButtonOverlay)node);\n+    }\n+\n+    public interface Accessor {\n+        void afterProcessCSS(HeaderButtonOverlay overlay);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/HeaderButtonOverlayHelper.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}