{"files":[{"patch":"@@ -220,2 +220,0 @@\n-        headerTextPanel.setVisible(false);\n-        headerTextPanel.setManaged(false);\n@@ -227,2 +225,0 @@\n-        contentLabel.setVisible(false);\n-        contentLabel.setManaged(false);\n","filename":"modules\/javafx.controls\/src\/main\/java\/javafx\/scene\/control\/DialogPane.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -151,0 +151,20 @@\n+    \/\/ The size and placement of the window button area depends on many variables, most of which\n+    \/\/ are CSS-styleable properties of HeaderButtonOverlay and HeaderButtonOverlay#ButtonRegion.\n+    \/\/ Detecting when the window button area has changed is quite difficult, and doing so manually\n+    \/\/ would require adding listeners to all properties that can affect it. This not only includes\n+    \/\/ all properties declared in this class, but also properties like button borders, padding, etc.\n+    \/\/ Instead of doing that, we always recompute the window button area after a CSS processing pass\n+    \/\/ for HeaderButtonOverlay has completed and notify potential listeners if it has changed.\n+    static {\n+        HeaderButtonOverlayHelper.setAccessor(new HeaderButtonOverlayHelper.Accessor() {\n+            @Override\n+            public void afterProcessCSS(HeaderButtonOverlay overlay) {\n+                overlay.updateButtonMetrics();\n+            }\n+        });\n+    }\n+\n+    {\n+        HeaderButtonOverlayHelper.initHelper(this);\n+    }\n+\n@@ -220,1 +240,7 @@\n-        this, \"prefButtonHeight\", HeaderBar.USE_DEFAULT_SIZE);\n+        this, \"prefButtonHeight\", HeaderBar.USE_DEFAULT_SIZE) {\n+            @Override\n+            protected void invalidated() {\n+                updateButtonMetrics(); \/\/ needed here because this property is not CSS-styleable\n+                requestLayout();\n+            }\n+        };\n@@ -227,2 +253,9 @@\n-    private final StyleableDoubleProperty buttonDefaultHeight = new SimpleStyleableDoubleProperty(\n-        BUTTON_DEFAULT_HEIGHT_METADATA, this, \"buttonDefaultHeight\");\n+    private final StyleableDoubleProperty buttonDefaultHeight =\n+        new SimpleStyleableDoubleProperty(\n+                BUTTON_DEFAULT_HEIGHT_METADATA, this, \"buttonDefaultHeight\") {\n+            @Override\n+            protected void invalidated() {\n+                \/\/ updateButtonMetrics() not needed here, see afterProcessCSS()\n+                requestLayout();\n+            }\n+        };\n@@ -240,0 +273,1 @@\n+                \/\/ updateButtonMetrics() not needed here, see afterProcessCSS()\n@@ -255,0 +289,1 @@\n+                \/\/ updateButtonMetrics() not needed here, see afterProcessCSS()\n@@ -264,0 +299,1 @@\n+    private final ButtonLayoutInfo layoutInfo = new ButtonLayoutInfo();\n@@ -310,3 +346,1 @@\n-            stylesheet.subscribe(this::updateStylesheet),\n-            prefButtonHeight.subscribe(this::requestLayout),\n-            buttonDefaultHeight.subscribe(this::requestLayout));\n+            stylesheet.subscribe(this::updateStylesheet));\n@@ -321,0 +355,2 @@\n+\n+        updateButtonMetrics();\n@@ -507,2 +543,1 @@\n-    @Override\n-    protected void layoutChildren() {\n+    private boolean updateButtonLayoutInfo() {\n@@ -533,1 +568,0 @@\n-        double width = getWidth();\n@@ -540,3 +574,0 @@\n-        double button1X = snapPositionX(left ? 0 : width - button1Width - button2Width - button3Width);\n-        double button2X = snapPositionX(left ? button1Width : width - button3Width - button2Width);\n-        double button3X = snapPositionX(left ? button1Width + button2Width : width - button3Width);\n@@ -552,3 +583,0 @@\n-                button1X = snapPositionX(button1X + offset);\n-                button2X = snapPositionX(button2X + offset);\n-                button3X = snapPositionX(button3X + offset);\n@@ -558,3 +586,0 @@\n-                button1X = snapPositionX(button1X - offset);\n-                button2X = snapPositionX(button2X - offset);\n-                button3X = snapPositionX(button3X - offset);\n@@ -569,1 +594,13 @@\n-        Dimension2D currentSize = left ? metrics.get().leftInset() : metrics.get().rightInset();\n+        return layoutInfo.update(\n+            button1, button1Width, button1Height,\n+            button2, button2Width, button2Height,\n+            button3, button3Width, button3Height,\n+            totalWidth, totalHeight, left);\n+    }\n+\n+    private void updateButtonMetrics() {\n+        if (!updateButtonLayoutInfo()) {\n+            return;\n+        }\n+\n+        Dimension2D currentSize = layoutInfo.left() ? metrics.get().leftInset() : metrics.get().rightInset();\n@@ -572,1 +609,1 @@\n-        if (currentSize.getWidth() != totalWidth || currentSize.getHeight() != totalHeight) {\n+        if (currentSize.getWidth() != layoutInfo.totalWidth() || currentSize.getHeight() != layoutInfo.totalHeight()) {\n@@ -574,2 +611,2 @@\n-            var size = new Dimension2D(totalWidth, totalHeight);\n-            HeaderButtonMetrics newMetrics = left\n+            var size = new Dimension2D(layoutInfo.totalWidth(), layoutInfo.totalHeight());\n+            HeaderButtonMetrics newMetrics = layoutInfo.left()\n@@ -580,0 +617,1 @@\n+    }\n@@ -581,11 +619,11 @@\n-        layoutInArea(button1, button1X, getButtonOffsetY(button1Height), button1Width, button1Height,\n-                     BASELINE_OFFSET_SAME_AS_HEIGHT, Insets.EMPTY, true, true,\n-                     HPos.LEFT, VPos.TOP, false);\n-\n-        layoutInArea(button2, button2X, getButtonOffsetY(button2Height), button2Width, button2Height,\n-                     BASELINE_OFFSET_SAME_AS_HEIGHT, Insets.EMPTY, true, true,\n-                     HPos.LEFT, VPos.TOP, false);\n-\n-        layoutInArea(button3, button3X, getButtonOffsetY(button3Height), button3Width, button3Height,\n-                     BASELINE_OFFSET_SAME_AS_HEIGHT, Insets.EMPTY, true, true,\n-                     HPos.LEFT, VPos.TOP, false);\n+    @Override\n+    protected void layoutChildren() {\n+        double[] offsets = layoutInfo.getLayoutOffsetsForWidth(getWidth());\n+\n+        for (int i = 0; i < 3; ++i) {\n+            ButtonSizeInfo sizeInfo = layoutInfo.buttonSizeAt(i);\n+            layoutInArea(sizeInfo.button(), offsets[i], getButtonOffsetY(sizeInfo.height()),\n+                         sizeInfo.width(), sizeInfo.height(),\n+                         BASELINE_OFFSET_SAME_AS_HEIGHT, Insets.EMPTY, true, true,\n+                         HPos.LEFT, VPos.TOP, false);\n+        }\n@@ -689,0 +727,111 @@\n+\n+    \/**\n+     * Contains the computed size for a window button.\n+     *\/\n+    private static final class ButtonSizeInfo {\n+\n+        private Region button;\n+        private double width;\n+        private double height;\n+\n+        public Region button() {\n+            return button;\n+        }\n+\n+        public double width() {\n+            return width;\n+        }\n+\n+        public double height() {\n+            return height;\n+        }\n+\n+        boolean update(Region button, double width, double height) {\n+            if (this.button != button || this.width != width || this.height != height) {\n+                this.button = button;\n+                this.width = width;\n+                this.height = height;\n+                return true;\n+            }\n+\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * Contains the sizes of the window buttons, the total width and height of the window button area,\n+     * and its placement. The horizontal layout offsets of the window buttons are not precomputed, as\n+     * they depend on the window width.\n+     *\/\n+    private final class ButtonLayoutInfo {\n+\n+        private final double[] temp = new double[3];\n+        private final ButtonSizeInfo[] buttonSizes = new ButtonSizeInfo[] {\n+            new ButtonSizeInfo(), new ButtonSizeInfo(), new ButtonSizeInfo()\n+        };\n+\n+        private boolean left;\n+        private double totalWidth;\n+        private double totalHeight;\n+\n+        public ButtonSizeInfo buttonSizeAt(int i) {\n+            return buttonSizes[i];\n+        }\n+\n+        public boolean left() {\n+            return left;\n+        }\n+\n+        public double totalWidth() {\n+            return totalWidth;\n+        }\n+\n+        public double totalHeight() {\n+            return totalHeight;\n+        }\n+\n+        public double[] getLayoutOffsetsForWidth(double width) {\n+            double button1X = snapPositionX(left ? 0 : width - buttonSizes[0].width - buttonSizes[1].width - buttonSizes[2].width);\n+            double button2X = snapPositionX(left ? buttonSizes[0].width : width - buttonSizes[2].width - buttonSizes[1].width);\n+            double button3X = snapPositionX(left ? buttonSizes[0].width + buttonSizes[1].width : width - buttonSizes[2].width);\n+\n+            if (buttonVerticalAlignment.get() == ButtonVerticalAlignment.CENTER) {\n+                if (left) {\n+                    double offset = getButtonOffsetY(buttonSizes[0].height);\n+                    button1X = snapPositionX(button1X + offset);\n+                    button2X = snapPositionX(button2X + offset);\n+                    button3X = snapPositionX(button3X + offset);\n+                } else {\n+                    double offset = getButtonOffsetY(buttonSizes[2].height);\n+                    button1X = snapPositionX(button1X - offset);\n+                    button2X = snapPositionX(button2X - offset);\n+                    button3X = snapPositionX(button3X - offset);\n+                }\n+            }\n+\n+            temp[0] = button1X;\n+            temp[1] = button2X;\n+            temp[2] = button3X;\n+            return temp;\n+        }\n+\n+        boolean update(Region button1, double width1, double height1,\n+                       Region button2, double width2, double height2,\n+                       Region button3, double width3, double height3,\n+                       double totalWidth, double totalHeight, boolean left) {\n+            \/\/ Note: the following disjunction operators are NOT short-circuiting:\n+            boolean changed =\n+                this.buttonSizes[0].update(button1, width1, height1) |\n+                this.buttonSizes[1].update(button2, width2, height2) |\n+                this.buttonSizes[2].update(button3, width3, height3);\n+\n+            if (this.totalWidth != totalWidth || this.totalHeight != totalHeight || this.left != left || changed) {\n+                this.totalWidth = totalWidth;\n+                this.totalHeight = totalHeight;\n+                this.left = left;\n+                return true;\n+            }\n+\n+            return false;\n+        }\n+    }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/HeaderButtonOverlay.java","additions":182,"deletions":33,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.glass.ui;\n+\n+import com.sun.javafx.scene.layout.RegionHelper;\n+import com.sun.javafx.util.Utils;\n+import javafx.scene.Node;\n+\n+final class HeaderButtonOverlayHelper extends RegionHelper {\n+\n+    private static final HeaderButtonOverlayHelper theInstance = new HeaderButtonOverlayHelper();\n+    private static Accessor theAccessor;\n+\n+    private HeaderButtonOverlayHelper() {}\n+\n+    static {\n+        Utils.forceInit(HeaderButtonOverlay.class);\n+    }\n+\n+    public static void setAccessor(Accessor accessor) {\n+        theAccessor = accessor;\n+    }\n+\n+    public static void initHelper(HeaderButtonOverlay overlay) {\n+        setHelper(overlay, theInstance);\n+    }\n+\n+    @Override\n+    protected void processCSSImpl(Node node) {\n+        super.processCSSImpl(node);\n+        theAccessor.afterProcessCSS((HeaderButtonOverlay)node);\n+    }\n+\n+    public interface Accessor {\n+        void afterProcessCSS(HeaderButtonOverlay overlay);\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/HeaderButtonOverlayHelper.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"}]}