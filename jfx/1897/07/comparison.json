{"files":[{"patch":"@@ -28,8 +28,4 @@\n-import com.sun.javafx.binding.BidirectionalBinding;\n-import javafx.beans.binding.Bindings;\n-import javafx.beans.property.*;\n-\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -38,0 +34,16 @@\n+import javafx.beans.binding.Bindings;\n+import javafx.beans.property.Property;\n+import javafx.beans.property.ReadOnlyBooleanWrapper;\n+import javafx.beans.property.ReadOnlyDoubleWrapper;\n+import javafx.beans.property.ReadOnlyFloatWrapper;\n+import javafx.beans.property.ReadOnlyIntegerWrapper;\n+import javafx.beans.property.ReadOnlyLongWrapper;\n+import javafx.beans.property.ReadOnlyObjectWrapper;\n+import javafx.beans.property.ReadOnlyStringWrapper;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleDoubleProperty;\n+import javafx.beans.property.SimpleFloatProperty;\n+import javafx.beans.property.SimpleIntegerProperty;\n+import javafx.beans.property.SimpleLongProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+import javafx.beans.property.SimpleStringProperty;\n@@ -39,2 +51,6 @@\n-\n-import static org.junit.jupiter.api.Assertions.*;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import com.sun.javafx.binding.BidirectionalBinding;\n+import test.javafx.util.OutputRedirect;\n@@ -72,0 +88,10 @@\n+    @BeforeEach\n+    public void beforeEach() {\n+        OutputRedirect.suppressStderr();\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        OutputRedirect.checkAndRestoreStderr();\n+    }\n+\n@@ -308,0 +334,2 @@\n+\n+        OutputRedirect.checkAndRestoreStderr(RuntimeException.class);\n@@ -328,0 +356,2 @@\n+\n+        OutputRedirect.checkAndRestoreStderr(RuntimeException.class);\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/BidirectionalBindingTest.java","additions":40,"deletions":10,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -32,2 +31,1 @@\n-\n-\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -39,7 +37,0 @@\n-\n-import org.junit.jupiter.api.BeforeEach;\n-import org.junit.jupiter.api.Test;\n-\n-import com.sun.javafx.binding.ExpressionHelper;\n-import com.sun.javafx.binding.ExpressionHelperShim;\n-\n@@ -55,0 +46,4 @@\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import com.sun.javafx.binding.ExpressionHelper;\n+import com.sun.javafx.binding.ExpressionHelperShim;\n@@ -59,0 +54,1 @@\n+import test.javafx.util.OutputRedirect;\n@@ -569,1 +565,7 @@\n-        ExpressionHelperShim.fireValueChangedEvent(helper);\n+\n+        OutputRedirect.suppressStderr();\n+        try {\n+            ExpressionHelperShim.fireValueChangedEvent(helper);\n+        } finally {\n+            OutputRedirect.checkAndRestoreStderr(RuntimeException.class);\n+        }\n@@ -579,1 +581,7 @@\n-        ExpressionHelperShim.fireValueChangedEvent(helper);\n+\n+        OutputRedirect.suppressStderr();\n+        try {\n+            ExpressionHelperShim.fireValueChangedEvent(helper);\n+        } finally {\n+            OutputRedirect.checkAndRestoreStderr(RuntimeException.class, RuntimeException.class);\n+        }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/ExpressionHelperTest.java","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,5 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n@@ -33,1 +38,0 @@\n-import test.javafx.beans.Person;\n@@ -42,1 +46,0 @@\n-import test.javafx.binding.Variable;\n@@ -44,0 +47,1 @@\n+import org.junit.jupiter.api.AfterEach;\n@@ -47,2 +51,3 @@\n-\n-import static org.junit.jupiter.api.Assertions.*;\n+import test.javafx.beans.Person;\n+import test.javafx.binding.Variable;\n+import test.javafx.util.OutputRedirect;\n@@ -105,2 +110,1 @@\n-    public static void setUpClass() {\n-        System.err.println(\"SelectBindingTest : log messages are expected from these tests.\");\n+    public void setUpClass() throws Exception {\n@@ -112,0 +116,2 @@\n+        OutputRedirect.suppressStderr();\n+\n@@ -122,0 +128,5 @@\n+    @AfterEach\n+    public void afterEach() {\n+        OutputRedirect.checkAndRestoreStderr();\n+    }\n+\n@@ -400,0 +411,1 @@\n+        OutputRedirect.checkAndRestoreStderr(NullPointerException.class);\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/com\/sun\/javafx\/binding\/SelectBindingTest.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -42,2 +44,1 @@\n-import test.com.sun.javafx.binding.ErrorLoggingUtiltity;\n-\n+import org.junit.jupiter.api.AfterEach;\n@@ -45,1 +46,1 @@\n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeEach;\n@@ -48,2 +49,2 @@\n-\n-import static org.junit.jupiter.api.Assertions.*;\n+import test.com.sun.javafx.binding.ErrorLoggingUtiltity;\n+import test.javafx.util.OutputRedirect;\n@@ -75,0 +76,10 @@\n+    @BeforeEach\n+    public void beforeEach() {\n+        OutputRedirect.suppressStderr();\n+    }\n+\n+    @AfterEach\n+    public void afterEach() {\n+        OutputRedirect.checkAndRestoreStderr();\n+    }\n+\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/binding\/BindingsCreateBindingTest.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.util;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+\n+\/**\n+ * PrintStream that accumulates output in memory.\n+ *\/\n+public class AccumulatingPrintStream extends PrintStream {\n+\n+    private final ByteArrayOutputStream out;\n+\n+    private AccumulatingPrintStream(ByteArrayOutputStream out) {\n+        super(out);\n+        this.out = out;\n+    }\n+\n+    public static AccumulatingPrintStream create() {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        return new AccumulatingPrintStream(out);\n+    }\n+\n+    public String getAccumulatedOutput() {\n+        byte[] b = out.toByteArray();\n+        return new String(b, charset());\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/AccumulatingPrintStream.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.javafx.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import java.io.PrintStream;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.junit.jupiter.api.Test;\n+\n+\/\/\/ This facility is used in the tests to redirect stderr output to an in-memory buffer\n+\/\/\/ for two reasons:\n+\/\/\/ 1. to suppress unrelated output in the logs\n+\/\/\/ 2. to check for the presence of expected exceptions and patterns\n+\/\/\/\n+public class OutputRedirect {\n+    private static PrintStream stderr;\n+    private static AccumulatingPrintStream stderrCapture;\n+\n+    \/\/\/ Redirects the stderr to an internal buffer, for the purpose of avoiding polluting the test logs.\n+    \/\/\/ This method is typically placed inside of the `@BeforeEach` block.\n+    \/\/\/\n+    \/\/\/ Once the test is finished, the output can be checked for thrown exceptions using {@link #checkStderr(Class...)}.\n+    \/\/\/ or {@link #checkAndRestoreStderr(Class...)}.\n+    \/\/\/\n+    \/\/\/ The redirection needs to be undone by calling either {@link #restoreStderr()} or\n+    \/\/\/ {@link #checkAndRestoreStderr(Class...)} method.\n+    \/\/\/\n+    public static void suppressStderr() {\n+        if (stderrCapture == null) {\n+            stderr = System.err;\n+            stderrCapture = AccumulatingPrintStream.create();\n+            System.setErr(stderrCapture);\n+        }\n+    }\n+\n+    \/\/\/ Restores stderr redirection (typically done inside of a `@AfterEach` block).\n+    \/\/\/ It is safe to call this method multiple times.\n+    public static void restoreStderr() {\n+        if (stderr != null) {\n+            System.setErr(stderr);\n+            stderr = null;\n+            stderrCapture = null;\n+        }\n+    }\n+\n+    \/\/\/ Checks the accumulated stderr buffer for the expected exceptions and string patterns.\n+    \/\/\/\n+    \/\/\/ This method expects the arguments to contain either instances of `Class<? extends Throwable>`,\n+    \/\/\/ or `String` patterns.  For exceptions, multiple instances of the same type are allowed so both the type\n+    \/\/\/ and a number of exceptions can be verified.\n+    \/\/\/\n+    \/\/\/ For `String` patterns, the check is done via `String.contains()` on the entire captured output.\n+    \/\/\/\n+    \/\/\/ When mismatch occurs, the accumulated output is dumped to the actual stderr, and the test `fail()`s.\n+    \/\/\/\n+    \/\/\/ @param expected the expected exception classes (duplicates allowed), and\/or string patterns\n+    \/\/\/\n+    public static void checkStderr(Object ... expected) {\n+        if (stderrCapture != null) {\n+            boolean err = false;\n+            String text = stderrCapture.getAccumulatedOutput();\n+\n+            \/\/ exceptions\n+            Map<String, Integer> errors = findErrors(text);\n+            Map<String, Integer> exp = toMap(expected);\n+            if (!errors.equals(exp)) {\n+                stderr.println(\"Mismatch in thrown exceptions:\\n  expected=\" + exp + \"\\n  observed=\" + errors);\n+                err = true;\n+            }\n+\n+            \/\/ patterns\n+            for (Object x : expected) {\n+                if (x instanceof String s) {\n+                    if (!text.contains(s)) {\n+                        stderr.println(\"Expected pattern not found: \" + s);\n+                        err = true;\n+                    }\n+                }\n+            }\n+\n+            if (err) {\n+                stderr.println(text);\n+                \/\/ mismatch fails the test\n+                fail(\"Unexpected stderr output\");\n+            }\n+        }\n+    }\n+\n+    \/\/\/ Checks the accumulated stderr buffer for the expected exceptions and string patterns,\n+    \/\/\/ then restores the redirection.\n+    \/\/\/\n+    \/\/\/ This method is equivalent to calling {@link #checkStderr(Object...)} followed by\n+    \/\/\/ {@link #restoreStderr()}.\n+    \/\/\/\n+    \/\/\/ @param expected the expected exception classes (duplicates allowed), and\/or string patterns\n+    \/\/\/\n+    public static void checkAndRestoreStderr(Object ... expected) {\n+        try {\n+            checkStderr(expected);\n+        } finally {\n+            restoreStderr();\n+        }\n+    }\n+\n+    private static Map<String, Integer> toMap(Object... expected) {\n+        HashMap<String, Integer> m = new HashMap<>();\n+        for (Object x : expected) {\n+            if (x instanceof Class c) {\n+                if (Throwable.class.isAssignableFrom(c)) {\n+                    String name = c.getName();\n+                    Integer v = m.get(name);\n+                    if (v == null) {\n+                        m.put(name, Integer.valueOf(1));\n+                    } else {\n+                        m.put(name, Integer.valueOf(v + 1));\n+                    }\n+                } else {\n+                    throw new IllegalArgumentException(\"must specify Class<? extends Throwable>: \" + c);\n+                }\n+            } else if(x instanceof String) {\n+                \/\/ ok\n+            } else {\n+                throw new IllegalArgumentException(\"must specify either Class<? extends Throwable> or String: \" + x);\n+            }\n+        }\n+        return m;\n+    }\n+\n+    private static Map<String, Integer> findErrors(String text) {\n+        HashMap<String, Integer> m = new HashMap<>();\n+        text.\n+            lines().\n+            map((s) -> findException(s)).\n+            forEach((c) -> {\n+                if (c != null) {\n+                    Integer v = m.get(c);\n+                    if (v == null) {\n+                        m.put(c, Integer.valueOf(1));\n+                    } else {\n+                        m.put(c, Integer.valueOf(v + 1));\n+                    }\n+                }\n+            });\n+        return m;\n+    }\n+\n+    \/\/\/ This regex matches either of the two patterns which might appear in the output:\n+    \/\/\/\n+    \/\/\/ `Exception in thread \"main\" java.lang.RuntimeException:`\n+    \/\/\/\n+    \/\/\/ or\n+    \/\/\/\n+    \/\/\/ `java.lang.NullPointerException: ...`\n+    private static final Pattern EXCEPTION_PATTERN = Pattern.compile(\n+        \"(?:\" +\n+            \/\/ catches lines starting with things like \"Exception in thread \"main\" java.lang.RuntimeException:\"\n+            \"^\" + \/\/ start of line\n+            \"(?:\" + \/\/ non-capturing group\n+                \"Exception in thread\\s+\\\"[^\\\"]*\\\"\\\\s+\" +\n+                \"(\" + \/\/ capture group 1\n+                    \"(?:[a-zA-Z_][a-zA-Z0-9_]*\\\\.)*\" +\n+                    \"(?:\" +\n+                        \"(?:[A-Z][a-zA-Z0-9]*)*\" +\n+                        \"(?:Exception|Error)\" +\n+                    \")\" +\n+                \")\" +\n+            \")\" +\n+        \")\" +\n+        \"|\" + \/\/ or\n+        \"(?:\" +\n+            \/\/ catches lines starting with things like \"java.lang.NullPointerException: Cannot invoke...\"\n+            \"^\" +\n+            \"(\" + \/\/ capture group 2\n+                \"(?:[a-zA-Z_][a-zA-Z0-9_]*\\\\.)*\" +\n+                \"(?:[A-Z][a-zA-Z0-9]*)*\" +\n+                \"(?:Exception|Error)\" +\n+            \")\" +\n+        \")\");\n+\n+    private static String findException(String text) {\n+        Matcher m = EXCEPTION_PATTERN.matcher(text);\n+        String name;\n+        if (m.find()) {\n+            name = m.group(1);\n+            if (name == null) {\n+                name = m.group(2);\n+            }\n+            return name;\n+        }\n+        return null;\n+    }\n+\n+    \/\/ should I leave this test here?  to test the test?\n+    @Test\n+    public void testFindException() {\n+        t(\"Exception in thread \\\"main\\\" java.lang.Error\", \"java.lang.Error\");\n+        t(\"Exception in thread \\\"main\\\" java.lang.RuntimeException: blah blah\", \"java.lang.RuntimeException\");\n+        t(\"java.lang.NullPointerException: Cannot invoke \\\"Object.toString(\", \"java.lang.NullPointerException\");\n+        t(\"    at javafx.base\/com.sun.javafx.binding.SelectBinding$AsString.computeValue(SelectBinding.java:392)\", null);\n+    }\n+\n+    private void t(String text, String expected) {\n+        String s = findException(text);\n+        assertEquals(expected, s);\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/OutputRedirect.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package test.util;\n+package test.javafx.util;\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/util\/ReflectionUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"modules\/javafx.base\/src\/test\/java\/test\/util\/ReflectionUtils.java","status":"renamed"},{"patch":"@@ -35,1 +35,1 @@\n-\t\t\t<attribute name=\"add-exports\" value=\"javafx.base\/com.sun.javafx.collections=javafx.fxml\"\/>\n+\t\t\t<attribute name=\"add-exports\" value=\"javafx.base\/com.sun.javafx.collections=javafx.fxml:javafx.base\/test.javafx.util=javafx.fxml\"\/>\n","filename":"modules\/javafx.fxml\/.classpath","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n@@ -34,0 +36,1 @@\n+import test.javafx.util.OutputRedirect;\n@@ -35,3 +38,3 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n+\/**\n+ * https:\/\/bugs.openjdk.org\/browse\/JDK-8119985\n+ *\/\n@@ -53,4 +56,5 @@\n-        System.err.println(\"Below warnings about - deprecated escape sequence - are expected from this test.\");\n-        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(\"rt_27529_2.fxml\"),\n-            ResourceBundle.getBundle(\"test\/javafx\/fxml\/rt_27529\"));\n-        fxmlLoader.load();\n+        OutputRedirect.suppressStderr();\n+        try {\n+            FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(\"rt_27529_2.fxml\"),\n+                ResourceBundle.getBundle(\"test\/javafx\/fxml\/rt_27529\"));\n+            fxmlLoader.load();\n@@ -58,3 +62,14 @@\n-        Widget widget = (Widget)fxmlLoader.getNamespace().get(\"widget1\");\n-        assertEquals(Arrays.asList(new String[]{\"@a\", \"%b\", \"$c\", \"@c\", \"%d\", \"$e\"}), widget.getStyles());\n-        assertTrue(Arrays.equals(  new String[]{\"@a\", \"%b\", \"$c\", \"@c\", \"%d\", \"$e\"}, widget.getNames()));\n+            Widget widget = (Widget)fxmlLoader.getNamespace().get(\"widget1\");\n+            assertEquals(Arrays.asList(new String[]{\"@a\", \"%b\", \"$c\", \"@c\", \"%d\", \"$e\"}), widget.getStyles());\n+            assertTrue(Arrays.equals(  new String[]{\"@a\", \"%b\", \"$c\", \"@c\", \"%d\", \"$e\"}, widget.getNames()));\n+            OutputRedirect.checkStderr(\n+                \"@@ is a deprecated escape sequence. Please use \\\\@ instead.\",\n+                \"%% is a deprecated escape sequence. Please use \\\\% instead.\",\n+                \"$$ is a deprecated escape sequence. Please use \\\\$ instead.\",\n+                \"@@ is a deprecated escape sequence. Please use \\\\@ instead.\",\n+                \"%% is a deprecated escape sequence. Please use \\\\% instead.\",\n+                \"$$ is a deprecated escape sequence. Please use \\\\$ instead.\"\n+                );\n+        } finally {\n+            OutputRedirect.restoreStderr();\n+        }\n","filename":"modules\/javafx.fxml\/src\/test\/java\/test\/javafx\/fxml\/RT_27529Test.java","additions":26,"deletions":11,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-\t\t\t<attribute name=\"add-exports\" value=\"javafx.base\/com.sun.javafx.property=javafx.graphics:javafx.base\/test.javafx.collections=javafx.graphics:javafx.base\/test.util.memory=javafx.graphics:javafx.base\/test.util=javafx.graphics\"\/>\n+\t\t\t<attribute name=\"add-exports\" value=\"javafx.base\/com.sun.javafx.property=javafx.graphics:javafx.base\/test.javafx.collections=javafx.graphics:javafx.base\/test.util.memory=javafx.graphics:javafx.base\/test.javafx.util=javafx.graphics\"\/>\n","filename":"modules\/javafx.graphics\/.classpath","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import test.javafx.util.ReflectionUtils;\n@@ -43,1 +44,0 @@\n-import test.util.ReflectionUtils;\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/glass\/ui\/HeaderButtonOverlayTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-import static test.util.ReflectionUtils.*;\n+import static test.javafx.util.ReflectionUtils.*;\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/css\/StyleableProperty_transition_Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-import test.util.ReflectionUtils;\n-\n+import test.javafx.util.ReflectionUtils;\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/javafx\/scene\/layout\/HeaderBarTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -11,1 +11,1 @@\n-\t\t\t<attribute name=\"add-exports\" value=\"javafx.base\/com.sun.javafx=ALL-UNNAMED:javafx.base\/test.util.memory=ALL-UNNAMED\"\/>\n+\t\t\t<attribute name=\"add-exports\" value=\"javafx.base\/com.sun.javafx=ALL-UNNAMED:javafx.base\/test.util.memory=ALL-UNNAMED:javafx.base\/test.javafx.util=ALL-UNNAMED\"\/>\n","filename":"tests\/system\/src\/test\/.classpath","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import test.javafx.util.OutputRedirect;\n@@ -161,2 +162,18 @@\n-    public void doTestIdleImplicit(final boolean implicit,\n-            final ThrowableType throwableType) {\n+    public void doTestIdleImplicit(boolean implicit, ThrowableType throwableType) {\n+        Object[] expected = switch(throwableType) {\n+        case ERROR ->\n+            new Object[] { InternalError.class };\n+        case EXCEPTION ->\n+            new Object[] { RuntimeException.class };\n+        case NONE ->\n+            new Object[0];\n+        };\n+        OutputRedirect.suppressStderr();\n+        try {\n+            doTestIdleImplicit2(implicit, throwableType);\n+        } finally {\n+            OutputRedirect.checkAndRestoreStderr(expected);\n+        }\n+    }\n+\n+    private void doTestIdleImplicit2(boolean implicit, ThrowableType throwableType) {\n","filename":"tests\/system\/src\/test\/java\/test\/com\/sun\/javafx\/application\/ListenerTestCommon.java","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import test.javafx.util.OutputRedirect;\n@@ -72,1 +73,10 @@\n-    private void doTestCommon(final boolean implicitExit) {\n+    private void doTestCommon(boolean implicitExit) {\n+        OutputRedirect.suppressStderr();\n+        try {\n+            doTestCommon2(implicitExit);\n+        } finally {\n+            OutputRedirect.checkAndRestoreStderr(RuntimeException.class);\n+        }\n+    }\n+\n+    private void doTestCommon2(boolean implicitExit) {\n","filename":"tests\/system\/src\/test\/java\/test\/com\/sun\/javafx\/application\/PlatformStartupCommon.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+import test.javafx.util.OutputRedirect;\n@@ -145,0 +146,20 @@\n+        boolean reEnableImplicitExit, boolean stageShown,\n+        ThrowableType throwableType, boolean appShouldExit) {\n+\n+        Object[] expected = switch(throwableType) {\n+        case ERROR ->\n+            new Object[] { InternalError.class };\n+        case EXCEPTION ->\n+            new Object[] { RuntimeException.class };\n+        case NONE ->\n+            new Object[0];\n+        };\n+        OutputRedirect.suppressStderr();\n+        try {\n+            doTestCommon2(implicitExit, reEnableImplicitExit, stageShown, throwableType, appShouldExit);\n+        } finally {\n+            OutputRedirect.checkAndRestoreStderr(expected);\n+        }\n+    }\n+\n+    private void doTestCommon2(boolean implicitExit,\n@@ -146,1 +167,1 @@\n-            final ThrowableType throwableType, boolean appShouldExit) {\n+            ThrowableType throwableType, boolean appShouldExit) {\n","filename":"tests\/system\/src\/test\/java\/test\/com\/sun\/javafx\/application\/SingleExitCommon.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import test.javafx.util.OutputRedirect;\n@@ -224,14 +225,20 @@\n-            \/\/ NOTE: cannot use a lambda expression for the following callback\n-            Callback<SnapshotResult, Void> cb = new Callback() {\n-                @Override public Object call(Object param) {\n-                    assertNotNull(param);\n-\n-                    latch.countDown();\n-                    \/\/ The following will cause a ClassCastException warning\n-                    \/\/ message to be printed.\n-                    return \"\";\n-                }\n-            };\n-\n-            tmpScene.snapshot(cb, null);\n-            Util.sleep(SLEEP_TIME);\n+            OutputRedirect.suppressStderr();\n+            try {\n+                \/\/ NOTE: cannot use a lambda expression for the following callback\n+                Callback<SnapshotResult, Void> cb = new Callback() {\n+                    @Override\n+                    public Object call(Object param) {\n+                        assertNotNull(param);\n+\n+                        latch.countDown();\n+                        \/\/ The following will cause a ClassCastException warning\n+                        \/\/ message to be printed.\n+                        return \"\";\n+                    }\n+                };\n+\n+                tmpScene.snapshot(cb, null);\n+                Util.sleep(SLEEP_TIME);\n+            } finally {\n+                OutputRedirect.checkAndRestoreStderr(ClassCastException.class);\n+            }\n@@ -239,1 +246,0 @@\n-            System.err.println(\"testBadSceneCallback1: a ClassCastException warning message is expected here\");\n@@ -262,5 +268,7 @@\n-            Callback cb = (Callback<String, Integer>) param -> {\n-                \/\/ Should not get here\n-                latch.countDown();\n-                throw new AssertionError(\"Should never get here\");\n-            };\n+            OutputRedirect.suppressStderr();\n+            try {\n+                Callback cb = (Callback<String, Integer>) param -> {\n+                    \/\/ Should not get here\n+                    latch.countDown();\n+                    throw new AssertionError(\"Should never get here\");\n+                };\n@@ -268,2 +276,5 @@\n-            tmpScene.snapshot(cb, null);\n-            Util.sleep(SLEEP_TIME);\n+                tmpScene.snapshot(cb, null);\n+                Util.sleep(SLEEP_TIME);\n+            } finally {\n+                OutputRedirect.checkAndRestoreStderr(ClassCastException.class);\n+            }\n@@ -271,1 +282,0 @@\n-            System.err.println(\"testBadSceneCallback2: a ClassCastException warning message is expected here\");\n@@ -346,14 +356,20 @@\n-            \/\/ NOTE: cannot use a lambda expression for the following callback\n-            Callback<SnapshotResult, Void> cb = new Callback() {\n-                @Override public Object call(Object param) {\n-                    assertNotNull(param);\n-\n-                    latch.countDown();\n-                    \/\/ The following will cause a ClassCastException warning\n-                    \/\/ message to be printed.\n-                    return \"\";\n-                }\n-            };\n-\n-            tmpNode.snapshot(cb, null, null);\n-            Util.sleep(SLEEP_TIME);\n+            OutputRedirect.suppressStderr();\n+            try {\n+                \/\/ NOTE: cannot use a lambda expression for the following callback\n+                Callback<SnapshotResult, Void> cb = new Callback() {\n+                    @Override\n+                    public Object call(Object param) {\n+                        assertNotNull(param);\n+\n+                        latch.countDown();\n+                        \/\/ The following will cause a ClassCastException warning\n+                        \/\/ message to be printed.\n+                        return \"\";\n+                    }\n+                };\n+\n+                tmpNode.snapshot(cb, null, null);\n+                Util.sleep(SLEEP_TIME);\n+            } finally {\n+                OutputRedirect.checkAndRestoreStderr(ClassCastException.class);\n+            }\n@@ -361,1 +377,0 @@\n-            System.err.println(\"testBadNodeCallback1: a ClassCastException warning message is expected here\");\n@@ -384,5 +399,7 @@\n-            Callback cb = (Callback<String, Integer>) param -> {\n-                \/\/ Should not get here\n-                latch.countDown();\n-                throw new AssertionError(\"Should never get here\");\n-            };\n+            OutputRedirect.suppressStderr();\n+            try {\n+                Callback cb = (Callback<String, Integer>) param -> {\n+                    \/\/ Should not get here\n+                    latch.countDown();\n+                    throw new AssertionError(\"Should never get here\");\n+                };\n@@ -390,2 +407,5 @@\n-            tmpNode.snapshot(cb, null, null);\n-            Util.sleep(SLEEP_TIME);\n+                tmpNode.snapshot(cb, null, null);\n+                Util.sleep(SLEEP_TIME);\n+            } finally {\n+                OutputRedirect.checkAndRestoreStderr(ClassCastException.class);\n+            }\n@@ -393,1 +413,0 @@\n-            System.err.println(\"testBadNodeCallback2: a ClassCastException warning message is expected here\");\n","filename":"tests\/system\/src\/test\/java\/test\/javafx\/scene\/Snapshot1Test.java","additions":66,"deletions":47,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import test.javafx.util.OutputRedirect;\n@@ -60,0 +61,9 @@\n+        OutputRedirect.suppressStderr();\n+        try {\n+            doTestLaunchModule2(appModulePath, testAppName);\n+        } finally {\n+            OutputRedirect.checkAndRestoreStderr();\n+        }\n+    }\n+\n+    private void doTestLaunchModule2(String appModulePath, String testAppName) throws Exception {\n","filename":"tests\/system\/src\/test\/java\/test\/launchertest\/ModuleLauncherTest.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"}]}