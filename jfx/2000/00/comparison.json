{"files":[{"patch":"@@ -278,0 +278,9 @@\n+\n+        \/\/ Null out out-of-range array elements to avoid maintaining object references\n+        for (int i = size; i < sorted.length; i++) {\n+            if (sorted[i] == null) {\n+                \/\/ Already null, stop checking further\n+                break;\n+            }\n+            sorted[i] = null;\n+        }\n@@ -334,0 +343,1 @@\n+        tempElement.e = null;\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/collections\/transformation\/SortedList.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -13,1 +13,2 @@\n-#\n+--add-opens=javafx.base\/javafx.collections.transformation=ALL-UNNAMED\n+#\n\\ No newline at end of file\n","filename":"modules\/javafx.base\/src\/test\/addExports","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n@@ -48,0 +50,4 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import test.javafx.util.ReflectionUtils;\n@@ -612,0 +618,145 @@\n+\n+    \/\/ Tests that there are no unnecessary object references retained in SortedList's internal sorted array\n+    @ParameterizedTest\n+    @MethodSource(\"parametersRefsNull\")\n+    public void testNoReferencesRetained(List<String> immutableInitialSourceList,\n+                                         Comparator<String> comparator) {\n+        ObservableList<String> source = FXCollections.observableArrayList(immutableInitialSourceList);\n+        SortedList<String> testSortedList = new SortedList<>(source, comparator);\n+\n+        \/\/ Make a mutable copy; it will be used and manipulated for comparisons with the SortedList\n+        ArrayList<String> expectedList = new ArrayList<>(immutableInitialSourceList);\n+\n+        \/\/ Sorts the list if comparator is non-null\n+        Consumer<List<String>> sortIf = (list) -> {\n+            if (comparator != null) {\n+                list.sort(comparator);\n+            }\n+        };\n+\n+        \/\/ Ensure initial state is as expected\n+        sortIf.accept(expectedList);\n+        assertEquals(expectedList, testSortedList);\n+        checkElementsBeyondSizeAreNull(testSortedList.size(), ReflectionUtils.getFieldValue(testSortedList, \"sorted\"));\n+\n+        \/\/ Remove some elements, ensure no unnecessary references were retained after reduction in size\n+        source.removeAll(\"b\", \"c\");\n+        expectedList.remove(\"b\");\n+        expectedList.remove(\"c\");\n+        assertEquals(expectedList, testSortedList);\n+        checkElementsBeyondSizeAreNull(testSortedList.size(), ReflectionUtils.getFieldValue(testSortedList, \"sorted\"));\n+\n+        \/\/ Set some elements, ensure no unnecessary references were retained\n+        source.setAll(\"x\", \"y\");\n+        expectedList.clear();\n+        expectedList.addAll(List.of(\"x\", \"y\"));\n+        sortIf.accept(expectedList);\n+\n+        assertEquals(expectedList, testSortedList);\n+        checkElementsBeyondSizeAreNull(source.size(), ReflectionUtils.getFieldValue(testSortedList, \"sorted\"));\n+\n+        \/\/ Reset and remove null elements while ensuring list size is as expected and no unnecessary references are retained\n+        source.setAll(immutableInitialSourceList);\n+        expectedList.clear();\n+        expectedList.addAll(immutableInitialSourceList);\n+        sortIf.accept(expectedList);\n+        assertEquals(expectedList, testSortedList);\n+\n+        while (source.contains(null)) {\n+            source.remove(null);\n+            expectedList.remove(null);\n+            assertEquals(expectedList, testSortedList);\n+            checkElementsBeyondSizeAreNull(source.size(), ReflectionUtils.getFieldValue(testSortedList, \"sorted\"));\n+        }\n+    }\n+\n+    \/\/ Similar to testNoReferencesRetained() but specifically tests the code path where comparator is set from existing\n+    \/\/ to null, which triggers different sorting logic in SortedList (doSortWithPermutationChange())\n+    @ParameterizedTest\n+    @MethodSource(\"parametersRefsNull\")\n+    public void testNoReferencesRetainedWhenComparatorNulled(List<String> immutableInitialSourceList,\n+                                                             Comparator<String> comparator) {\n+        if (comparator == null) {\n+            \/\/ This test is for non-null comparators only\n+            return;\n+        }\n+\n+        ObservableList<String> source = FXCollections.observableArrayList(immutableInitialSourceList);\n+        SortedList<String> testSortedList = new SortedList<>(source, comparator);\n+\n+        \/\/ Make a mutable copy, sort it; will be used and manipulated for comparisons\n+        ArrayList<String> expectedList = new ArrayList<>(immutableInitialSourceList);\n+        expectedList.sort(comparator);\n+\n+        source.remove(\"b\");\n+        expectedList.remove(\"b\");\n+        assertEquals(expectedList, testSortedList);\n+        checkElementsBeyondSizeAreNull(testSortedList.size(), ReflectionUtils.getFieldValue(testSortedList, \"sorted\"));\n+\n+        \/\/ Set the comparator to null, ensure no unnecessary references were retained (covers SortedList's doSortWithPermutationChange() logic)\n+        testSortedList.setComparator(null);\n+        source.remove(\"c\");\n+\n+        \/\/ We must re-create to unsort expected list\n+        expectedList = new ArrayList<>(immutableInitialSourceList);\n+        expectedList.remove(\"b\");\n+        expectedList.remove(\"c\");\n+        assertEquals(expectedList, testSortedList);\n+        checkElementsBeyondSizeAreNull(testSortedList.size(), ReflectionUtils.getFieldValue(testSortedList, \"sorted\"));\n+    }\n+\n+    private static Stream<Arguments> parametersRefsNull() {\n+        List<String> listSurroundNulls =\n+                Collections.unmodifiableList(Arrays.asList(null, null, null, null, \"b\", \"c\", null, null, null, null));\n+        List<String> listWithNulls = Collections.unmodifiableList(\n+                Arrays.asList(null, null, \"a\", \"b\", \"c\", \"d\", null, \"e\", null, null, null, \"f\"));\n+        List<String> listWithoutNulls =\n+                Collections.unmodifiableList(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\"));\n+\n+        Comparator<String> natural = Comparator.naturalOrder();\n+        Comparator<String> reverse = Comparator.reverseOrder();\n+        Comparator<String> nullsFirstNatural = Comparator.nullsFirst(natural);\n+        Comparator<String> nullsFirstReverse = Comparator.nullsFirst(reverse);\n+        Comparator<String> nullsLastNatural = Comparator.nullsLast(natural);\n+        Comparator<String> nullsLastReverse = Comparator.nullsLast(reverse);\n+\n+        return Stream.of(\n+                Arguments.of(listSurroundNulls, null),\n+                Arguments.of(listSurroundNulls, nullsFirstNatural),\n+                Arguments.of(listSurroundNulls, nullsFirstReverse),\n+                Arguments.of(listSurroundNulls, nullsLastNatural),\n+                Arguments.of(listSurroundNulls, nullsLastReverse),\n+\n+                Arguments.of(listWithoutNulls, null),\n+                Arguments.of(listWithoutNulls, natural),\n+                Arguments.of(listWithoutNulls, nullsFirstNatural),\n+                Arguments.of(listWithoutNulls, nullsFirstReverse),\n+                Arguments.of(listWithoutNulls, nullsLastNatural),\n+                Arguments.of(listWithoutNulls, nullsLastReverse),\n+                Arguments.of(listWithoutNulls, reverse),\n+\n+                Arguments.of(listWithNulls, null),\n+                Arguments.of(listWithNulls, nullsFirstNatural),\n+                Arguments.of(listWithNulls, nullsFirstReverse),\n+                Arguments.of(listWithNulls, nullsLastNatural),\n+                Arguments.of(listWithNulls, nullsLastReverse)\n+        );\n+    }\n+\n+    private void checkElementsBeyondSizeAreNull(int relevantSize, Object[] array) {\n+        \/\/ Anything at index >= relevantSize should be null\n+        for (int i = relevantSize; i < array.length; i++) {\n+            assertNull(array[i], \"Element at index \" + i + \" should be null\");\n+        }\n+    }\n+\n+    \/\/ Tests that there is no unnecessary object reference retained by SortedList's tempElement.e\n+    @Test\n+    public void testTempElementReferencesAreNull() {\n+        \/\/ This will trigger SortedList.tempElement assignment (tempElement.e = e)\n+        list.set(3, \"3\");\n+\n+        \/\/ Ensure tempElement.e is set to null after the operation\n+        assertNull(ReflectionUtils.getFieldValue(ReflectionUtils.getFieldValue(sortedList, \"tempElement\"), \"e\"),\n+                \"tempElement.e property should be null after set operation has completed\");\n+    }\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/collections\/SortedListTest.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"}]}