{"files":[{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.scene;\n+\n+import com.sun.javafx.scene.SceneHelper;\n+import java.lang.ref.WeakReference;\n+import java.util.LinkedList;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.WeakChangeListener;\n+import javafx.event.EventHandler;\n+import javafx.scene.Node;\n+import javafx.scene.Scene;\n+import javafx.scene.input.InputMethodEvent;\n+import javafx.scene.input.InputMethodRequests;\n+\n+\/**\n+ * Used to manage a collection of scenes which must coordinate enabling input\n+ * method events and retrieving InputMethodRequests. PopupWindows do not have\n+ * the OS focus and rely on events being posted first to a root\n+ * (non-popup) scene and then routed through the PopupWindow stack. If any\n+ * PopupWindow requires input method events they must be enabled on the root\n+ * scene and input method requests from that scene must be routed to the\n+ * PopupWindow.\n+ *\/\n+public class InputMethodStateManager {\n+    \/**\n+     * The root non-popup scene which the OS sends input method\n+     * events to.\n+     *\/\n+    private final WeakReference<Scene> rootScene;\n+\n+    \/**\n+     * The scene for which we enabled input method events.\n+     *\/\n+    private Scene currentEventScene;\n+\n+    \/**\n+     * The scene stack including the root.\n+     *\/\n+    private final LinkedList<Scene> scenes = new LinkedList<Scene>();\n+\n+    \/**\n+     * We listen for changes to the input method requests configuration\n+     * on every scene in the stack.\n+     *\/\n+    private final ChangeListener<InputMethodRequests> inputMethodRequestsChangedListener =\n+        (obs, old, current) -> updateInputMethodEventEnableState();\n+    private final ChangeListener<EventHandler<? super InputMethodEvent>> onInputMethodTextChangedListener =\n+        (obs, old, current) -> updateInputMethodEventEnableState();\n+\n+    private final WeakChangeListener<InputMethodRequests> weakInputMethodRequestsChangedListener =\n+        new WeakChangeListener(inputMethodRequestsChangedListener);\n+    private final WeakChangeListener<EventHandler<? super InputMethodEvent>> weakOnInputMethodTextChangedListener =\n+        new WeakChangeListener(onInputMethodTextChangedListener);\n+\n+    \/**\n+     * Constructs a new instance. Only root (non-popup) scenes should do this.\n+     *\n+     * @param scene the root {@link Scene} for which input methods should be enabled and disabled\n+     *\/\n+    public InputMethodStateManager(Scene scene) {\n+        this.rootScene = new WeakReference<>(scene);\n+        this.scenes.add(scene);\n+        this.currentEventScene = scene;\n+    }\n+\n+    \/**\n+     * Add a new Scene to the stack.\n+     *\/\n+    public void addScene(Scene scene) {\n+        scenes.addFirst(scene);\n+        updateInputMethodEventEnableState();\n+    }\n+\n+    \/**\n+     * Remove a Scene from the stack.\n+     *\/\n+    public void removeScene(Scene scene) {\n+        \/**\n+         * If this scene is going away we should cleanup any composition\n+         * state. Hiding a window doesn't ensure proper cleanup.\n+         *\/\n+        SceneHelper.finishInputMethodComposition(rootScene.get());\n+\n+        Node focusOwner = scene.getFocusOwner();\n+        if (focusOwner != null) {\n+            focusOwner.inputMethodRequestsProperty().removeListener(weakInputMethodRequestsChangedListener);\n+            focusOwner.onInputMethodTextChangedProperty().removeListener(weakOnInputMethodTextChangedListener);\n+        }\n+\n+        scenes.remove(scene);\n+        updateInputMethodEventEnableState();\n+    }\n+\n+    \/**\n+     * Every Scene must call this before the focusOwner changes.\n+     *\/\n+    public void focusOwnerWillChangeForScene(Scene scene) {\n+        \/**\n+         * Calling finishInputMethodComposition is only necessary if there's a\n+         * node that accepts IM events. But there's a system test that\n+         * expects finishInputMethodComposition to be called whenever the\n+         * focusOwner changes. To satisfy this test we call\n+         * finishInputMethodComposition even if no IM is enabled\n+         * (so currentEventScene will be null). This will be no-op as far as\n+         * the OS is concerned.\n+         *\/\n+        if (scene == currentEventScene || currentEventScene == null) {\n+            Scene root = rootScene.get();\n+            if (root != null) {\n+                SceneHelper.finishInputMethodComposition(root);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Every Scene must call this when the focusOwner changes.\n+     *\/\n+    public void focusOwnerChanged(Node oldFocusOwner, Node newFocusOwner) {\n+        if (oldFocusOwner != null) {\n+            oldFocusOwner.inputMethodRequestsProperty().removeListener(weakInputMethodRequestsChangedListener);\n+            oldFocusOwner.onInputMethodTextChangedProperty().removeListener(weakOnInputMethodTextChangedListener);\n+        }\n+        if (newFocusOwner != null) {\n+            newFocusOwner.inputMethodRequestsProperty().addListener(weakInputMethodRequestsChangedListener);\n+            newFocusOwner.onInputMethodTextChangedProperty().addListener(weakOnInputMethodTextChangedListener);\n+        }\n+        updateInputMethodEventEnableState();\n+    }\n+\n+    public Scene getRootScene() {\n+        return rootScene.get();\n+    }\n+\n+    private void updateInputMethodEventEnableState() {\n+        currentEventScene = null;\n+        \/\/ Visit Scenes in order from top to bottom.\n+        for (Scene scene : scenes) {\n+            Node focusOwner = scene.getFocusOwner();\n+            if ((focusOwner != null) &&\n+                (focusOwner.getInputMethodRequests() != null) &&\n+                (focusOwner.getOnInputMethodTextChanged() != null)) {\n+                currentEventScene = scene;\n+                break;\n+            }\n+        }\n+        Scene root = rootScene.get();\n+        if (root != null) {\n+            SceneHelper.enableInputMethodEvents(root, currentEventScene != null);\n+        }\n+    }\n+\n+    public InputMethodRequests getInputMethodRequests() {\n+        if (currentEventScene != null) {\n+            Node focusOwner = currentEventScene.getFocusOwner();\n+            if (focusOwner != null) {\n+                return focusOwner.getInputMethodRequests();\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/InputMethodStateManager.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -56,0 +56,8 @@\n+    public static InputMethodStateManager getInputMethodStateManager(Scene scene) {\n+        return sceneAccessor.getInputMethodStateManager(scene);\n+    }\n+\n+    public static void finishInputMethodComposition(Scene scene) {\n+        sceneAccessor.finishInputMethodComposition(scene);\n+    }\n+\n@@ -121,0 +129,4 @@\n+        InputMethodStateManager getInputMethodStateManager(Scene scene);\n+\n+        void finishInputMethodComposition(Scene scene);\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/scene\/SceneHelper.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import com.sun.javafx.scene.InputMethodStateManager;\n@@ -401,0 +402,13 @@\n+                        @Override\n+                        public InputMethodStateManager getInputMethodStateManager(Scene scene) {\n+                            return scene.getInputMethodStateManager();\n+                        }\n+\n+                        @Override\n+                        public void finishInputMethodComposition(Scene scene) {\n+                            final TKScene peer = scene.getPeer();\n+                            if (peer != null) {\n+                                peer.finishInputMethodComposition();\n+                            }\n+                        }\n+\n@@ -467,0 +481,12 @@\n+\n+                                       @Override\n+                                       protected InputMethodStateManager getInputMethodStateManager() {\n+                                            Window rootWindow = getWindow();\n+                                            while ((rootWindow != null) && (rootWindow instanceof PopupWindow)) {\n+                                                rootWindow = ((PopupWindow)rootWindow).getOwnerWindow();\n+                                            }\n+                                            if (rootWindow != null) {\n+                                                return rootWindow.getScene().getInputMethodStateManager();\n+                                            }\n+                                            return null;\n+                                       }\n@@ -2203,0 +2229,14 @@\n+    \/**\n+     * A non-popup scene creates a state manager to coordinate input method\n+     * handling with popups. Popups do not create their own state manager\n+     * but use the root scene's manager.\n+     *\/\n+    private InputMethodStateManager inputMethodStateManager = null;\n+\n+    InputMethodStateManager getInputMethodStateManager() {\n+        if (inputMethodStateManager == null) {\n+            inputMethodStateManager = new InputMethodStateManager(this);\n+        }\n+        return inputMethodStateManager;\n+    }\n+\n@@ -2240,3 +2280,4 @@\n-                    value.getScene().enableInputMethodEvents(\n-                            value.getInputMethodRequests() != null\n-                            && value.getOnInputMethodTextChanged() != null);\n+                    InputMethodStateManager manager = value.getScene().getInputMethodStateManager();\n+                    if (manager != null) {\n+                        manager.focusOwnerChanged(oldFocusOwner, value);\n+                    }\n@@ -2286,7 +2327,1 @@\n-            final Scene s = focusOwner.oldFocusOwner.getScene();\n-            if (s != null) {\n-                final TKScene peer = s.getPeer();\n-                if (peer != null) {\n-                    peer.finishInputMethodComposition();\n-                }\n-            }\n+            getInputMethodStateManager().focusOwnerWillChangeForScene(this);\n@@ -4228,5 +4263,1 @@\n-            Node focusOwner = getFocusOwner();\n-            if (focusOwner != null) {\n-                return focusOwner.getInputMethodRequests();\n-            }\n-            return null;\n+            return getInputMethodStateManager().getInputMethodRequests();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/Scene.java","additions":46,"deletions":15,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -77,0 +77,1 @@\n+import javafx.scene.input.InputMethodEvent;\n@@ -558,0 +559,1 @@\n+        Scene scene = getScene();\n@@ -562,0 +564,1 @@\n+            SceneHelper.getInputMethodStateManager(scene).addScene(scene);\n@@ -572,0 +575,3 @@\n+            \/\/ This may generate events so it must be done while we're\n+            \/\/ still monitoring owner events.\n+            SceneHelper.getInputMethodStateManager(scene).removeScene(scene);\n@@ -1007,0 +1013,3 @@\n+            else if (event instanceof InputMethodEvent) {\n+                handleInputMethodEvent((InputMethodEvent) event);\n+            }\n@@ -1045,0 +1054,18 @@\n+        private void handleInputMethodEvent(final InputMethodEvent event) {\n+            if (event.isConsumed()) {\n+                return;\n+            }\n+\n+            final Scene scene = popupWindow.getScene();\n+            if (scene != null) {\n+                final Node sceneFocusOwner = scene.getFocusOwner();\n+                final EventTarget eventTarget =\n+                        (sceneFocusOwner != null) ? sceneFocusOwner : scene;\n+                if (EventUtil.fireEvent(eventTarget, new DirectEvent(event.copyFor(popupWindow, eventTarget)))\n+                        == null) {\n+                    event.consume();\n+                    return;\n+                }\n+            }\n+        }\n+\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/PopupWindow.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"}]}