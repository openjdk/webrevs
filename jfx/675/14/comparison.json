{"files":[{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javafx.binding;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+\/**\n+ * A subscription encapsulates how to cancel it without having\n+ * to keep track of how it was created.\n+ *\n+ * <p>For example:\n+ *\n+ * <p>{@code Subscription s = property.subscribe(System.out::println)}\n+ *\n+ * <p>The function passed in to {@code subscribe} does not need to be stored\n+ * in order to clean up the subscription later.\n+ *\/\n+@FunctionalInterface\n+public interface Subscription {\n+\n+    \/**\n+     * An empty subscription. Does nothing when cancelled.\n+     *\/\n+    static final Subscription EMPTY = () -> {};\n+\n+    \/**\n+     * Cancels this subscription.\n+     *\/\n+    void unsubscribe();\n+\n+    \/**\n+     * Combines this {@link Subscription} with the given {@code Subscription}\n+     * and returns a new {@code Subscription} which will cancel both when\n+     * cancelled.\n+     *\n+     * @param other another {@link Subscription}, cannot be {@code null}\n+     * @return a combined {@link Subscription} which will cancel both when\n+     *     cancelled, never {@code null}\n+     * @throws NullPointerException when {@code other} is {@code null}\n+     *\/\n+    default Subscription and(Subscription other) {\n+        Objects.requireNonNull(other);\n+\n+        return () -> {\n+            unsubscribe();\n+            other.unsubscribe();\n+        };\n+    }\n+\n+    \/**\n+     * Creates a {@link Subscription} on this {@link ObservableValue} which\n+     * immediately provides its current value to the given {@code subscriber},\n+     * followed by any subsequent changes in value.\n+     *\n+     * @param subscriber a {@link Consumer} to supply with the values of this\n+     *     {@link ObservableValue}, cannot be {@code null}\n+     * @return a {@link Subscription} which can be used to cancel this\n+     *     subscription, never {@code null}\n+     * @throws NullPointerException when {@code observableValue} or {@code subscriber} is {@code null}\n+     *\/\n+    static <T> Subscription subscribe(ObservableValue<T> observableValue, Consumer<? super T> subscriber) {\n+        ChangeListener<T> listener = (obs, old, current) -> subscriber.accept(current);\n+\n+        subscriber.accept(observableValue.getValue());  \/\/ eagerly send current value\n+        observableValue.addListener(listener);\n+\n+        return () -> observableValue.removeListener(listener);\n+    }\n+\n+    \/**\n+     * Creates a {@link Subscription} on this {@link ObservableValue} which\n+     * calls the given {@code runnable} whenever this {@code ObservableValue}\n+     * becomes invalid.\n+     *\n+     * @param runnable a {@link Runnable} to call whenever this\n+     *     {@link ObservableValue} becomes invalid, cannot be @{code null}\n+     * @return a {@link Subscription} which can be used to cancel this\n+     *     subscription, never @{code null}\n+     * @throws NullPointerException when {@code observableValue} or {@code runnable} is {@code null}\n+     *\/\n+    static Subscription subscribeInvalidations(ObservableValue<?> observableValue, Runnable runnable) {\n+        Objects.requireNonNull(runnable);\n+\n+        InvalidationListener listener = obs -> runnable.run();\n+\n+        observableValue.addListener(listener);\n+\n+        return () -> observableValue.removeListener(listener);\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/binding\/Subscription.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,7 @@\n-            value = computeValue();\n+            T computed = computeValue();\n+\n+            if (!allowValidation()) {\n+                return computed;\n+            }\n+\n+            value = computed;\n@@ -177,0 +183,1 @@\n+            value = null;  \/\/ clear cached value to avoid hard reference to stale data\n@@ -185,0 +192,29 @@\n+    \/**\n+     * Checks if the binding has at least one listener registered on it. This\n+     * is useful for subclasses which want to conserve resources when not observed.\n+     *\n+     * @return {@code true} if this binding currently has one or more\n+     *     listeners registered on it, otherwise {@code false}\n+     * @since 19\n+     *\/\n+    protected final boolean isObserved() {\n+        return helper != null;\n+    }\n+\n+    \/**\n+     * Checks if the binding is allowed to become valid. Overriding classes can\n+     * prevent a binding from becoming valid. This is useful in subclasses which\n+     * do not always listen for invalidations of their dependencies and prefer to\n+     * recompute the current value instead. This can also be useful if caching of\n+     * the current computed value is not desirable.\n+     * <p>\n+     * The default implementation always allows bindings to become valid.\n+     *\n+     * @return {@code true} if this binding is allowed to become valid, otherwise\n+     *     {@code false}\n+     * @since 19\n+     *\/\n+    protected boolean allowValidation() {\n+        return true;\n+    }\n+\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/binding\/ObjectBinding.java","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.beans.value;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import com.sun.javafx.binding.Subscription;\n+\n+class FlatMappedBinding<S, T> extends LazyObjectBinding<T> {\n+\n+    private final ObservableValue<S> source;\n+    private final Function<? super S, ? extends ObservableValue<? extends T>> mapper;\n+\n+    private Subscription mappedSubscription = Subscription.EMPTY;\n+\n+    public FlatMappedBinding(ObservableValue<S> source, Function<? super S, ? extends ObservableValue<? extends T>> mapper) {\n+        this.source = Objects.requireNonNull(source, \"source cannot be null\");\n+        this.mapper = Objects.requireNonNull(mapper, \"mapper cannot be null\");\n+    }\n+\n+    @Override\n+    protected T computeValue() {\n+        S value = source.getValue();\n+        ObservableValue<? extends T> mapped = value == null ? null : mapper.apply(value);\n+\n+        if (isObserved()) {\n+            mappedSubscription.unsubscribe();\n+            mappedSubscription = mapped == null ? Subscription.EMPTY : Subscription.subscribeInvalidations(mapped, this::invalidate);\n+        }\n+\n+        return mapped == null ? null : mapped.getValue();\n+    }\n+\n+    @Override\n+    protected Subscription observeInputs() {\n+        Subscription subscription = Subscription.subscribeInvalidations(source, this::invalidate);\n+\n+        return () -> {\n+            subscription.unsubscribe();\n+            mappedSubscription.unsubscribe();\n+            mappedSubscription = Subscription.EMPTY;\n+        };\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/FlatMappedBinding.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.beans.value;\n+\n+import com.sun.javafx.binding.Subscription;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.binding.ObjectBinding;\n+\n+\/**\n+ * Extends {@link ObjectBinding} with the ability to lazily register and eagerly unregister listeners on its\n+ * dependencies.\n+ *\n+ * @param <T> the type of the wrapped {@code Object}\n+ *\/\n+abstract class LazyObjectBinding<T> extends ObjectBinding<T> {\n+\n+    private Subscription subscription;\n+    private boolean wasObserved;\n+\n+    @Override\n+    public void addListener(ChangeListener<? super T> listener) {\n+        super.addListener(listener);\n+\n+        updateSubcriptionAfterAdd();\n+    }\n+\n+    @Override\n+    public void removeListener(ChangeListener<? super T> listener) {\n+        super.removeListener(listener);\n+\n+        updateSubcriptionAfterRemove();\n+    }\n+\n+    @Override\n+    public void addListener(InvalidationListener listener) {\n+        super.addListener(listener);\n+\n+        updateSubcriptionAfterAdd();\n+    }\n+\n+    @Override\n+    public void removeListener(InvalidationListener listener) {\n+        super.removeListener(listener);\n+\n+        updateSubcriptionAfterRemove();\n+    }\n+\n+    @Override\n+    protected boolean allowValidation() {\n+        return isObserved();\n+    }\n+\n+    \/**\n+     * Called after a listener was added to start observing inputs if they're not observed already.\n+     *\/\n+    private void updateSubcriptionAfterAdd() {\n+        if (!wasObserved) { \/\/ was first observer registered?\n+            subscription = observeInputs(); \/\/ start observing source\n+\n+            \/*\n+             * Although the act of registering a listener already attempts to make\n+             * this binding valid, allowValidation won't allow it as the binding is\n+             * not observed yet. This is because isObserved will not yet return true\n+             * when the process of registering the listener hasn't completed yet.\n+             *\n+             * As the binding must be valid after it becomes observed the first time\n+             * 'get' is called again.\n+             *\n+             * See com.sun.javafx.binding.ExpressionHelper (which is used\n+             * by ObjectBinding) where it will do a call to ObservableValue#getValue\n+             * BEFORE adding the actual listener. This results in ObjectBinding#get\n+             * to be called in which the #allowValidation call will block it from\n+             * becoming valid as the condition is \"isObserved()\"; this is technically\n+             * correct as the listener wasn't added yet, but means we must call\n+             * #get again to make this binding valid.\n+             *\/\n+\n+            get(); \/\/ make binding valid as source wasn't tracked until now\n+            wasObserved = true;\n+        }\n+    }\n+\n+    \/**\n+     * Called after a listener was removed to stop observing inputs if this was the last listener\n+     * observing this binding.\n+     *\/\n+    private void updateSubcriptionAfterRemove() {\n+        if (wasObserved && !isObserved()) { \/\/ was last observer unregistered?\n+            subscription.unsubscribe();\n+            subscription = null;\n+            invalidate(); \/\/ make binding invalid as source is no longer tracked\n+            wasObserved = false;\n+        }\n+    }\n+\n+    \/**\n+     * Called when this binding was previously not observed and a new observer was added. Implementors must return a\n+     * {@link Subscription} which will be cancelled when this binding no longer has any observers.\n+     *\n+     * @return a {@link Subscription} which will be cancelled when this binding no longer has any observers, never null\n+     *\/\n+    protected abstract Subscription observeInputs();\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/LazyObjectBinding.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.beans.value;\n+\n+import java.util.Objects;\n+import java.util.function.Function;\n+\n+import com.sun.javafx.binding.Subscription;\n+\n+class MappedBinding<S, T> extends LazyObjectBinding<T> {\n+\n+    private final ObservableValue<S> source;\n+    private final Function<? super S, ? extends T> mapper;\n+\n+    public MappedBinding(ObservableValue<S> source, Function<? super S, ? extends T> mapper) {\n+        this.source = Objects.requireNonNull(source, \"source cannot be null\");\n+        this.mapper = Objects.requireNonNull(mapper, \"mapper cannot be null\");\n+    }\n+\n+    @Override\n+    protected T computeValue() {\n+        S value = source.getValue();\n+\n+        return value == null ? null : mapper.apply(value);\n+    }\n+\n+    @Override\n+    protected Subscription observeInputs() {\n+        return Subscription.subscribeInvalidations(source, this::invalidate); \/\/ start observing source\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/MappedBinding.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import java.util.function.Function;\n+\n@@ -140,0 +142,108 @@\n+\n+    \/**\n+     * Returns an {@code ObservableValue} that holds the result of applying the\n+     * given mapping function on this value. The result is updated when this\n+     * {@code ObservableValue} changes. If this value is {@code null}, no\n+     * mapping is applied and the resulting value is also {@code null}.\n+     * <p>\n+     * For example, mapping a string to an upper case string:\n+     * <pre>{@code\n+     * var text = new SimpleStringProperty(\"abcd\");\n+     * ObservableValue<String> upperCase = text.map(String::toUpperCase);\n+     *\n+     * upperCase.getValue();  \/\/ Returns \"ABCD\"\n+     * text.set(\"xyz\");\n+     * upperCase.getValue();  \/\/ Returns \"XYZ\"\n+     * text.set(null);\n+     * upperCase.getValue();  \/\/ Returns null\n+     * }<\/pre>\n+     *\n+     * @param <U> the type of values held by the resulting {@code ObservableValue}\n+     * @param mapper the mapping function to apply to a value, cannot be {@code null}\n+     * @return an {@code ObservableValue} that holds the result of applying the given\n+     *     mapping function on this value, or {@code null} when it\n+     *     is {@code null}; never returns {@code null}\n+     * @throws NullPointerException if the mapping function is {@code null}\n+     * @since 19\n+     *\/\n+    default <U> ObservableValue<U> map(Function<? super T, ? extends U> mapper) {\n+        return new MappedBinding<>(this, mapper);\n+    }\n+\n+    \/**\n+     * Returns an {@code ObservableValue} that holds this value, or the given constant if\n+     * it is {@code null}. The result is updated when this {@code ObservableValue} changes. This\n+     * method, when combined with {@link #map(Function)}, allows handling of all values\n+     * including {@code null} values.\n+     * <p>\n+     * For example, mapping a string to an upper case string, but leaving it blank\n+     * if the input is {@code null}:\n+     * <pre>{@code\n+     * var text = new SimpleStringProperty(\"abcd\");\n+     * ObservableValue<String> upperCase = text.map(String::toUpperCase).orElse(\"\");\n+     *\n+     * upperCase.getValue();  \/\/ Returns \"ABCD\"\n+     * text.set(null);\n+     * upperCase.getValue();  \/\/ Returns \"\"\n+     * }<\/pre>\n+     *\n+     * @param constant the value to use when this {@code ObservableValue}\n+     *     holds {@code null}; can be {@code null}\n+     * @return an {@code ObservableValue} that holds this value, or the given constant if\n+     *     it is {@code null}; never returns {@code null}\n+     * @since 19\n+     *\/\n+    default ObservableValue<T> orElse(T constant) {\n+        return new OrElseBinding<>(this, constant);\n+    }\n+\n+    \/**\n+     * Returns an {@code ObservableValue} that holds the value of an {@code ObservableValue}\n+     * produced by applying the given mapping function on this value. The result is updated\n+     * when either this {@code ObservableValue} or the {@code ObservableValue} produced by\n+     * the mapping changes. If this value is {@code null}, no mapping is applied and the\n+     * resulting value is {@code null}. If the mapping resulted in {@code null}, then the\n+     * resulting value is also {@code null}.\n+     * <p>\n+     * This method is similar to {@link #map(Function)}, but the mapping function is\n+     * one whose result is already an {@code ObservableValue}, and if invoked, {@code flatMap} does\n+     * not wrap it within an additional {@code ObservableValue}.\n+     * <p>\n+     * For example, a property that is only {@code true} when a UI element is part of a {@code Scene}\n+     * that is part of a {@code Window} that is currently shown on screen:\n+     * <pre>{@code\n+     * ObservableValue<Boolean> isShowing = listView.sceneProperty()\n+     *     .flatMap(Scene::windowProperty)\n+     *     .flatMap(Window::showingProperty)\n+     *     .orElse(false);\n+     *\n+     * \/\/ Assuming the listView is currently shown to the user, then:\n+     *\n+     * isShowing().getValue();  \/\/ Returns true\n+     *\n+     * listView.getScene().getWindow().hide();\n+     * isShowing().getValue();  \/\/ Returns false\n+     *\n+     * listView.getScene().getWindow().show();\n+     * isShowing().getValue();  \/\/ Returns true\n+     *\n+     * listView.getParent().getChildren().remove(listView);\n+     * isShowing().getValue();  \/\/ Returns false\n+     * }<\/pre>\n+     * Changes in any of the values of: the scene of {@code listView}, the window of that scene, or\n+     * the showing of that window, will update the boolean value {@code isShowing}.\n+     * <p>\n+     * This method is preferred over {@link javafx.beans.binding.Bindings#select Bindings} methods\n+     * since it is type safe.\n+     *\n+     * @param <U> the type of values held by the resulting {@code ObservableValue}\n+     * @param mapper the mapping function to apply to a value, cannot be {@code null}\n+     * @return an {@code ObservableValue} that holds the value of an {@code ObservableValue}\n+     *     produced by applying the given mapping function on this value, or\n+     *     {@code null} when the value is {@code null}; never returns {@code null}\n+     * @throws NullPointerException if the mapping function is {@code null}\n+     * @since 19\n+     *\/\n+    default <U> ObservableValue<U> flatMap(Function<? super T, ? extends ObservableValue<? extends U>> mapper) {\n+        return new FlatMappedBinding<>(this, mapper);\n+    }\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/ObservableValue.java","additions":111,"deletions":1,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.beans.value;\n+\n+import java.util.Objects;\n+\n+import com.sun.javafx.binding.Subscription;\n+\n+class OrElseBinding<T> extends LazyObjectBinding<T> {\n+\n+    private final ObservableValue<T> source;\n+    private final T constant;\n+\n+    public OrElseBinding(ObservableValue<T> source, T constant) {\n+        this.source = Objects.requireNonNull(source, \"source cannot be null\");\n+        this.constant = constant;\n+    }\n+\n+    @Override\n+    protected T computeValue() {\n+        T value = source.getValue();\n+\n+        return value == null ? constant : value;\n+    }\n+\n+    @Override\n+    protected Subscription observeInputs() {\n+        return Subscription.subscribeInvalidations(source, this::invalidate); \/\/ start observing source\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/main\/java\/javafx\/beans\/value\/OrElseBinding.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javafx.beans.value;\n+\n+import com.sun.javafx.binding.Subscription;\n+\n+\/**\n+ * Stub to allow testing of package private LazyObjectBinding.\n+ *\/\n+public class LazyObjectBindingStub<T> extends LazyObjectBinding<T> {\n+\n+    public int computeValueCalls;\n+    public int startObservingCalls;\n+    public int stopObservingCalls;\n+\n+    @Override\n+    protected T computeValue() {\n+        computeValueCalls++;\n+\n+        return null;\n+    }\n+\n+    @Override\n+    protected Subscription observeInputs() {\n+        startObservingCalls++;\n+\n+        return () -> {\n+            stopObservingCalls++;\n+        };\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/shims\/java\/javafx\/beans\/value\/LazyObjectBindingStub.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.beans.value;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import javafx.beans.InvalidationListener;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.LazyObjectBindingStub;\n+\n+public class LazyObjectBindingTest {\n+\n+    private LazyObjectBindingStub<String> binding = new LazyObjectBindingStub<>();\n+\n+    void resetCounters() {\n+        binding.startObservingCalls = 0;\n+        binding.computeValueCalls = 0;\n+        binding.stopObservingCalls = 0;\n+    }\n+\n+    @Test\n+    void shouldBeInvalidInitially() {\n+        assertFalse(binding.isValid());\n+    }\n+\n+    @Nested\n+    class WhenObservedWithInvalidationListener {\n+        private InvalidationListener invalidationListener = obs -> {};\n+\n+        {\n+            binding.addListener(invalidationListener);\n+        }\n+\n+        @Test\n+        void shouldBeValid() {\n+            assertTrue(binding.isValid());\n+        }\n+\n+        @Test\n+        void shouldStartObservingSource() {\n+            assertEquals(1, binding.startObservingCalls);\n+        }\n+\n+        @Test\n+        void shouldNotStopObservingSource() {\n+            assertEquals(0, binding.stopObservingCalls);\n+        }\n+\n+        @Test\n+        void shouldCallComputeValueOneOrTwoTimes() {\n+\n+            \/*\n+             * The binding is made valid twice currently, once when\n+             * the listener is registered, and again after the observing of\n+             * inputs starts. The first time the binding does not become\n+             * valid because it is not yet considered \"observed\" as the\n+             * computeValue call occurs in the middle of the listener\n+             * registration process.\n+             *\n+             * See also the explanation in LazyObjectBinding#updateSubcriptionAfterAdd\n+             *\/\n+\n+            assertTrue(binding.computeValueCalls >= 1 && binding.computeValueCalls <= 2);\n+        }\n+\n+        @Nested\n+        class AndWhenObservedAgain {\n+            private ChangeListener<String> changeListener = (obs, old, current) -> {};\n+\n+            {\n+                resetCounters();\n+                binding.addListener(changeListener);\n+            }\n+\n+            @Test\n+            void shouldStillBeValid() {\n+                assertTrue(binding.isValid());\n+            }\n+\n+            @Test\n+            void shouldNotStartObservingSourceAgain() {\n+                assertEquals(0, binding.startObservingCalls);\n+            }\n+\n+            @Test\n+            void shouldNotStopObservingSource() {\n+                assertEquals(0, binding.stopObservingCalls);\n+            }\n+\n+            @Test\n+            void shouldNotComputeValueAgain() {\n+                assertEquals(0, binding.computeValueCalls);\n+            }\n+\n+            @Nested\n+            class AndThenOneObserverIsRemoved {\n+                {\n+                    resetCounters();\n+                    binding.removeListener(changeListener);\n+                }\n+\n+                @Test\n+                void shouldStillBeValid() {\n+                    assertTrue(binding.isValid());\n+                }\n+\n+                @Test\n+                void shouldNotStartObservingSourceAgain() {\n+                    assertEquals(0, binding.startObservingCalls);\n+                }\n+\n+                @Test\n+                void shouldNotStopObservingSource() {\n+                    assertEquals(0, binding.stopObservingCalls);\n+                }\n+\n+                @Test\n+                void shouldNotComputeValueAgain() {\n+                    assertEquals(0, binding.computeValueCalls);\n+                }\n+\n+                @Nested\n+                class AndThenTheLastObserverIsRemoved {\n+                    {\n+                        resetCounters();\n+                        binding.removeListener(invalidationListener);\n+                    }\n+\n+                    @Test\n+                    void shouldNotStartObservingSource() {\n+                        assertEquals(0, binding.startObservingCalls);\n+                    }\n+\n+                    @Test\n+                    void shouldStopObservingSource() {\n+                        assertEquals(1, binding.stopObservingCalls);\n+                    }\n+\n+                    @Test\n+                    void shouldNotComputeValue() {\n+                        assertEquals(0, binding.computeValueCalls);\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeValid() {\n+                        assertFalse(binding.isValid());\n+                    }\n+\n+                    @Nested\n+                    class AndTheListenerIsRemovedAgain {\n+                        {\n+                            resetCounters();\n+                            binding.removeListener(invalidationListener);\n+                        }\n+\n+                        @Test\n+                        void shouldNotStartObservingSource() {\n+                            assertEquals(0, binding.startObservingCalls);\n+                        }\n+\n+                        @Test\n+                        void shouldNotStopObservingSource() {\n+                            assertEquals(0, binding.stopObservingCalls);\n+                        }\n+\n+                        @Test\n+                        void shouldNotComputeValue() {\n+                            assertEquals(0, binding.computeValueCalls);\n+                        }\n+\n+                        @Test\n+                        void shouldNotBeValid() {\n+                            assertFalse(binding.isValid());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/LazyObjectBindingTest.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -0,0 +1,718 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.beans.value;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Nested;\n+import org.junit.jupiter.api.Test;\n+\n+import javafx.beans.property.SimpleStringProperty;\n+import javafx.beans.property.StringProperty;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+\n+public class ObservableValueFluentBindingsTest {\n+\n+    private final StringProperty property = new SimpleStringProperty(\"Initial\");\n+    private final List<String> values = new ArrayList<>();\n+    private final ChangeListener<String> changeListener = (obs, old, current) -> values.add(current);\n+\n+    @Nested\n+    class When_map_Called {\n+\n+        @Nested\n+        class WithNull {\n+\n+            @Test\n+            void shouldThrowNullPointerException() {\n+                assertThrows(NullPointerException.class, () -> property.map(null));\n+            }\n+        }\n+\n+        @Nested\n+        class WithNotNullReturns_ObservableValue_Which {\n+            private ObservableValue<String> observableValue = property.map(v -> v + \"+map\");\n+\n+            @Test\n+            void shouldNotBeNull() {\n+                assertNotNull(observableValue);\n+            }\n+\n+            @Test\n+            void shouldNotBeStronglyReferenced() {\n+                ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+            }\n+\n+            @Nested\n+            class When_getValue_Called {\n+\n+                @Test\n+                void shouldReturnPropertyValuesWithOperationApplied() {\n+                    assertEquals(\"Initial+map\", observableValue.getValue());\n+\n+                    property.set(\"Left\");\n+\n+                    assertEquals(\"Left+map\", observableValue.getValue());\n+                }\n+\n+                @Test\n+                void shouldNotOperateOnNull() {\n+                    property.set(null);\n+\n+                    assertEquals((String) null, observableValue.getValue());\n+                }\n+            }\n+\n+            @Nested\n+            class WhenObserved {\n+                {\n+                    startObserving(observableValue);\n+                }\n+\n+                @Test\n+                void shouldApplyOperation() {\n+                    assertNothingIsObserved();\n+\n+                    property.set(\"Right\");\n+\n+                    assertObserved(\"Right+map\");\n+                }\n+\n+                @Test\n+                void shouldNotOperateOnNull() {\n+                    property.set(null);\n+\n+                    assertObserved((String) null);  \/\/ map operation is skipped (as it would NPE otherwise) and the resulting value is null\n+                }\n+\n+                @Test\n+                void shouldBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> observableValue = null);\n+                }\n+\n+                @Nested\n+                class AndWhenUnobserved {\n+                    {\n+                        stopObserving(observableValue);\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeCalled() {\n+                        assertNothingIsObserved();\n+\n+                        property.set(\"Right\");\n+\n+                        assertNothingIsObserved();\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeStronglyReferenced() {\n+                        ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                    }\n+                }\n+            }\n+\n+            @Nested\n+            class When_orElse_CalledReturns_ObservableValue_Which {\n+                {\n+                    observableValue = observableValue.orElse(\"Empty\");\n+                }\n+\n+                @Test\n+                void shouldNotBeNull() {\n+                    assertNotNull(observableValue);\n+                }\n+\n+                @Test\n+                void shouldNotBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                }\n+\n+                @Nested\n+                class WhenObserved {\n+                    {\n+                        startObserving(observableValue);\n+                    }\n+\n+                    @Test\n+                    void shouldApplyMapThenOrElseOperation() {\n+                        assertNothingIsObserved();\n+\n+                        property.set(\"Left\");\n+\n+                        assertObserved(\"Left+map\");\n+\n+                        property.set(null);\n+\n+                        assertObserved(\"Empty\");\n+                    }\n+\n+                    @Test\n+                    void shouldBeStronglyReferenced() {\n+                        ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> observableValue = null);\n+                    }\n+\n+                    @Nested\n+                    class AndWhenUnobserved {\n+                        {\n+                            stopObserving(observableValue);\n+                        }\n+\n+                        @Test\n+                        void shouldNoLongerBeCalled() {\n+                            assertNothingIsObserved();\n+\n+                            property.set(\"Left\");\n+\n+                            assertNothingIsObserved();\n+                        }\n+\n+                        @Test\n+                        void shouldNoLongerBeStronglyReferenced() {\n+                            ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            @Nested\n+            class When_map_CalledAgainReturns_ObservableValue_Which {\n+                {\n+                    observableValue = observableValue.map(v -> v + \"+map2\");\n+                }\n+\n+                @Test\n+                void shouldNotBeNull() {\n+                    assertNotNull(observableValue);\n+                }\n+\n+                @Test\n+                void shouldNotBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                }\n+\n+                @Nested\n+                class WhenObserved {\n+                    {\n+                        startObserving(observableValue);\n+                    }\n+\n+                    @Test\n+                    void shouldApplyMapThenSecondMapOperation() {\n+                        assertNothingIsObserved();\n+\n+                        property.set(\"Left\");\n+\n+                        assertObserved(\"Left+map+map2\");\n+\n+                        property.set(null);\n+\n+                        assertObserved((String) null);\n+                    }\n+\n+                    @Test\n+                    void shouldBeStronglyReferenced() {\n+                        ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> observableValue = null);\n+                    }\n+\n+                    @Nested\n+                    class AndWhenUnobserved {\n+                        {\n+                            stopObserving(observableValue);\n+                        }\n+\n+                        @Test\n+                        void shouldNoLongerBeCalled() {\n+                            assertNothingIsObserved();\n+\n+                            property.set(\"Left\");\n+\n+                            assertNothingIsObserved();\n+                        }\n+\n+                        @Test\n+                        void shouldNoLongerBeStronglyReferenced() {\n+                            ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Nested\n+    class When_orElse_CalledReturns_ObservableValue_Which {\n+        private ObservableValue<String> observableValue = property.orElse(\"Empty\");\n+\n+        @Test\n+        void shouldNotBeNull() {\n+            assertNotNull(observableValue);\n+        }\n+\n+        @Test\n+        void shouldNotBeStronglyReferenced() {\n+            ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+        }\n+\n+        @Nested\n+        class When_getValue_Called {\n+\n+            @Test\n+            void shouldReturnPropertyValuesWithOperationApplied() {\n+                assertEquals(\"Initial\", observableValue.getValue());\n+\n+                property.set(null);\n+\n+                assertEquals(\"Empty\", observableValue.getValue());\n+            }\n+        }\n+\n+        @Nested\n+        class WhenObserved {\n+            {\n+                startObserving(observableValue);\n+            }\n+\n+            @Test\n+            void shouldApplyOperation() {\n+                assertNothingIsObserved();\n+\n+                property.set(\"Left\");\n+\n+                assertObserved(\"Left\");\n+\n+                property.set(null);\n+\n+                assertObserved(\"Empty\");\n+            }\n+\n+            @Test\n+            void shouldBeStronglyReferenced() {\n+                ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> observableValue = null);\n+            }\n+\n+            @Nested\n+            class AndWhenUnobserved {\n+                {\n+                    stopObserving(observableValue);\n+                }\n+\n+                @Test\n+                void shouldNoLongerBeCalled() {\n+                    assertNothingIsObserved();\n+\n+                    property.set(\"Left\");\n+\n+                    assertNothingIsObserved();\n+                }\n+\n+                @Test\n+                void shouldNoLongerBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Nested\n+    class When_flatMap_Called {\n+\n+        @Nested\n+        class WithNull {\n+\n+            @Test\n+            void shouldThrowNullPointerException() {\n+                assertThrows(NullPointerException.class, () -> property.flatMap(null));\n+            }\n+        }\n+\n+        @Nested\n+        class WithNotNullReturns_ObservableValue_Which {\n+            private StringProperty left = new SimpleStringProperty(\"LEFT\");\n+            private StringProperty right = new SimpleStringProperty(\"RIGHT\");\n+            private StringProperty unknown = new SimpleStringProperty(\"UNKNOWN\");\n+            private ObservableValue<String> observableValue =\n+                    property.flatMap(v -> \"Left\".equals(v) ? left : \"Right\".equals(v) ? right : unknown);\n+\n+            @Test\n+            void shouldNotBeNull() {\n+                assertNotNull(observableValue);\n+            }\n+\n+            @Test\n+            void shouldNotBeStronglyReferenced() {\n+                ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+            }\n+\n+            @Nested\n+            class When_getValue_Called {\n+\n+                @Test\n+                void shouldReturnPropertyValuesWithOperationApplied() {\n+                    assertEquals(\"UNKNOWN\", observableValue.getValue());  \/\/ initially it is not left or right, so unknown\n+\n+                    property.set(\"Right\");\n+\n+                    assertEquals(\"RIGHT\", observableValue.getValue());\n+\n+                    right.setValue(\"RIGHT+1\");\n+\n+                    assertEquals(\"RIGHT+1\", observableValue.getValue());\n+\n+                    left.setValue(\"LEFT+1\");\n+                    unknown.setValue(\"UNKNOWN+1\");\n+\n+                    assertEquals(\"RIGHT+1\", observableValue.getValue());  \/\/ changing left or unknown value should have no effect\n+\n+                    property.set(\"Left\");\n+\n+                    assertEquals(\"LEFT+1\", observableValue.getValue());  \/\/ after switching to left, it switches to the left value\n+                }\n+\n+                @Test\n+                void shouldNotOperateOnNull() {\n+                    property.set(null);\n+\n+                    assertNull(observableValue.getValue());\n+                }\n+\n+                @Test\n+                void shouldIgnoreFlatMapsToNull() {\n+                    unknown = null;\n+\n+                    assertNull(observableValue.getValue());\n+                }\n+            }\n+\n+            @Nested\n+            class WhenObserved {\n+                {\n+                    startObserving(observableValue);\n+                }\n+\n+                @Test\n+                void shouldApplyOperation() {\n+                    assertNothingIsObserved();\n+\n+                    unknown.set(\"UNKNOWN+1\");\n+\n+                    assertObserved(\"UNKNOWN+1\");  \/\/ as it initially is unknown, changing the unknown property results in a change\n+\n+                    property.set(\"Right\");\n+\n+                    assertObserved(\"RIGHT\");  \/\/ switching to right gives the value of the right property\n+\n+                    unknown.set(\"UNKNOWN+2\");\n+                    left.set(\"LEFT+1\");\n+\n+                    assertNothingIsObserved();  \/\/ changing left or unknown has no effect when currently observing right\n+\n+                    right.set(\"RIGHT+1\");\n+\n+                    assertObserved(\"RIGHT+1\");  \/\/ changing right value has an effect as right is observed\n+\n+                    property.set(\"Left\");\n+\n+                    assertObserved(\"LEFT+1\");  \/\/ switching to left sees latest left value\n+                }\n+\n+                @Test\n+                void shouldNotOperateOnNull() {\n+                    property.set(null);\n+\n+                    assertObserved((String)null);  \/\/ flatMap operation is skipped (as it would NPE otherwise) and the resulting value is null\n+                }\n+\n+                @Test\n+                void shouldIgnoreFlatMapsToNull() {\n+                    right = null;\n+\n+                    property.set(\"Right\");\n+\n+                    assertObserved((String)null);  \/\/ flatMap maps to right property which is now null, this results in null\n+                }\n+\n+                @Test\n+                void shouldObserveNullWhenFlatMappedPropertyIsSetToNull() {\n+                    property.set(\"Right\");\n+\n+                    assertObserved(\"RIGHT\");\n+\n+                    property.set(null);\n+\n+                    assertObserved((String)null);\n+                }\n+\n+                @Test\n+                void shouldBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> observableValue = null);\n+                }\n+\n+                @Nested\n+                class AndWhenUnobserved {\n+                    {\n+                        stopObserving(observableValue);\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeCalled() {\n+                        assertNothingIsObserved();\n+\n+                        property.set(\"Left\");\n+                        property.set(\"Right\");\n+                        property.set(\"Unknown\");\n+\n+                        assertNothingIsObserved();\n+                    }\n+\n+                    @Test\n+                    void shouldNoLongerBeStronglyReferenced() {\n+                        ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                    }\n+                }\n+            }\n+\n+            @Nested\n+            class When_map_CalledReturns_ObservableValue_Which {\n+                {\n+                    observableValue = observableValue.map(v -> v + \"+map\");\n+                }\n+\n+                @Test\n+                void shouldNotBeNull() {\n+                    assertNotNull(observableValue);\n+                }\n+\n+                @Test\n+                void shouldNotBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                }\n+\n+                @Nested\n+                class WhenObserved {\n+                    {\n+                        startObserving(observableValue);\n+                    }\n+\n+                    @Test\n+                    void shouldApplyFlatMapThenMapOperation() {\n+                        assertNothingIsObserved();\n+\n+                        property.set(\"Left\");\n+\n+                        assertObserved(\"LEFT+map\");\n+\n+                        property.set(\"Right\");\n+\n+                        assertObserved(\"RIGHT+map\");\n+\n+                        left.set(\"LEFT-LEFT\");  \/\/ should have no effect\n+\n+                        assertNothingIsObserved();\n+\n+                        right.set(\"RIGHT-RIGHT\");\n+\n+                        assertObserved(\"RIGHT-RIGHT+map\");\n+                    }\n+\n+                    @Test\n+                    void shouldBeStronglyReferenced() {\n+                        ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> observableValue = null);\n+                    }\n+\n+                    @Nested\n+                    class AndWhenUnobserved {\n+                        {\n+                            stopObserving(observableValue);\n+                        }\n+\n+                        @Test\n+                        void shouldNoLongerBeCalled() {\n+                            assertNothingIsObserved();\n+\n+                            property.set(\"Left\");\n+\n+                            assertNothingIsObserved();\n+                        }\n+\n+                        @Test\n+                        void shouldNoLongerBeStronglyReferenced() {\n+                            ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            @Nested\n+            class When_orElse_CalledReturns_ObservableValue_Which {\n+                {\n+                    observableValue = observableValue.orElse(\"Empty\");\n+                }\n+\n+                @Test\n+                void shouldNotBeNull() {\n+                    assertNotNull(observableValue);\n+                }\n+\n+                @Test\n+                void shouldNotBeStronglyReferenced() {\n+                    ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                }\n+\n+                @Nested\n+                class WhenObserved {\n+                    {\n+                        startObserving(observableValue);\n+                    }\n+\n+                    @Test\n+                    void shouldApplyFlatMapThenMapOperation() {\n+                        assertNothingIsObserved();\n+\n+                        property.set(\"Left\");\n+\n+                        assertObserved(\"LEFT\");\n+\n+                        property.set(\"Right\");\n+\n+                        assertObserved(\"RIGHT\");\n+\n+                        left.set(\"LEFT-LEFT\");  \/\/ should have no effect as right branch is observed\n+\n+                        assertNothingIsObserved();\n+\n+                        right.set(\"RIGHT-RIGHT\");\n+\n+                        assertObserved(\"RIGHT-RIGHT\");\n+\n+                        right.set(null);\n+\n+                        assertObserved(\"Empty\");\n+\n+                        property.set(\"Left\");\n+\n+                        assertObserved(\"LEFT-LEFT\");\n+\n+                        property.set(null);\n+\n+                        assertObserved(\"Empty\");\n+                    }\n+\n+                    @Test\n+                    void shouldBeStronglyReferenced() {\n+                        ReferenceAsserts.testIfStronglyReferenced(observableValue, () -> observableValue = null);\n+                    }\n+\n+                    @Nested\n+                    class AndWhenUnobserved {\n+                        {\n+                            stopObserving(observableValue);\n+                        }\n+\n+                        @Test\n+                        void shouldNoLongerBeCalled() {\n+                            assertNothingIsObserved();\n+\n+                            property.set(\"Left\");\n+\n+                            assertNothingIsObserved();\n+                        }\n+\n+                        @Test\n+                        void shouldNoLongerBeStronglyReferenced() {\n+                            ReferenceAsserts.testIfNotStronglyReferenced(observableValue, () -> observableValue = null);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Ensures nothing has been observed since the last check.\n+     *\/\n+    private void assertNothingIsObserved() {\n+        assertObserved();\n+    }\n+\n+    \/**\n+     * Ensures that given values have been observed since last call.\n+     *\n+     * @param expectedValues an array of expected values\n+     *\/\n+    private void assertObserved(String... expectedValues) {\n+        assertEquals(values, Arrays.asList(expectedValues));\n+        values.clear();\n+    }\n+\n+    \/**\n+     * Starts observing the given observable value. This will do\n+     * a sanity check that the observer is currently not working\n+     * before adding it.\n+     *\n+     * @param observableValue an {@code ObservableValue}, cannot be {@code null}\n+     *\/\n+    private void startObserving(ObservableValue<String> observableValue) {\n+        values.clear();\n+\n+        property.setValue(\"Left\");\n+        property.setValue(\"Right\");\n+        property.setValue(\"Initial\");\n+\n+        assertTrue(values.isEmpty());\n+\n+        observableValue.addListener(changeListener);\n+    }\n+\n+    \/**\n+     * Stops observing the given observable value. This will do a\n+     * sanity check that the observer is currently working before\n+     * removing it.\n+     *\n+     * @param observableValue an {@code ObservableValue}, cannot be {@code null}\n+     *\/\n+    private void stopObserving(ObservableValue<String> observableValue) {\n+        values.clear();\n+\n+        property.setValue(\"Left\");\n+        property.setValue(\"Right\");\n+\n+        assertEquals(2, values.size());\n+\n+        values.clear();\n+\n+        observableValue.removeListener(changeListener);\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/ObservableValueFluentBindingsTest.java","additions":718,"deletions":0,"binary":false,"changes":718,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2022 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.javafx.beans.value;\n+\n+import java.lang.ref.WeakReference;\n+\n+import test.util.memory.JMemoryBuddy;\n+\n+public class ReferenceAsserts {\n+\n+    public static void testIfStronglyReferenced(Object obj, Runnable clearRefs) {\n+        WeakReference<Object> ref = new WeakReference<>(obj);\n+\n+        clearRefs.run();\n+        obj = null;\n+\n+        JMemoryBuddy.assertNotCollectable(ref);\n+    }\n+\n+    public static void testIfNotStronglyReferenced(Object obj, Runnable clearRefs) {\n+        WeakReference<Object> ref = new WeakReference<>(obj);\n+\n+        clearRefs.run();\n+        obj = null;\n+\n+        JMemoryBuddy.assertCollectable(ref);\n+    }\n+}\n","filename":"modules\/javafx.base\/src\/test\/java\/test\/javafx\/beans\/value\/ReferenceAsserts.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"}]}