{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,0 @@\n-\/*\n- * StubToolkit.java\n- *\/\n-\n@@ -32,0 +28,35 @@\n+import java.io.File;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import javafx.application.ConditionalFeature;\n+import javafx.geometry.Dimension2D;\n+import javafx.scene.image.Image;\n+import javafx.scene.input.DataFormat;\n+import javafx.scene.input.DragEvent;\n+import javafx.scene.input.Dragboard;\n+import javafx.scene.input.InputMethodRequests;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.KeyEvent;\n+import javafx.scene.input.TransferMode;\n+import javafx.scene.paint.Color;\n+import javafx.scene.paint.ImagePattern;\n+import javafx.scene.paint.LinearGradient;\n+import javafx.scene.paint.RadialGradient;\n+import javafx.scene.shape.FillRule;\n+import javafx.scene.shape.PathElement;\n+import javafx.scene.shape.SVGPath;\n+import javafx.scene.shape.StrokeLineCap;\n+import javafx.scene.shape.StrokeLineJoin;\n+import javafx.scene.shape.StrokeType;\n+import javafx.stage.FileChooser.ExtensionFilter;\n+import javafx.stage.Modality;\n+import javafx.stage.StageStyle;\n+import javafx.stage.Window;\n+import javafx.util.Pair;\n@@ -45,1 +76,15 @@\n-import com.sun.javafx.tk.*;\n+import com.sun.javafx.tk.FileChooserType;\n+import com.sun.javafx.tk.FontLoader;\n+import com.sun.javafx.tk.ImageLoader;\n+import com.sun.javafx.tk.PlatformImage;\n+import com.sun.javafx.tk.RenderJob;\n+import com.sun.javafx.tk.ScreenConfigurationAccessor;\n+import com.sun.javafx.tk.TKClipboard;\n+import com.sun.javafx.tk.TKDragGestureListener;\n+import com.sun.javafx.tk.TKDragSourceListener;\n+import com.sun.javafx.tk.TKDropTargetListener;\n+import com.sun.javafx.tk.TKScene;\n+import com.sun.javafx.tk.TKScreenConfigurationListener;\n+import com.sun.javafx.tk.TKStage;\n+import com.sun.javafx.tk.TKSystemMenu;\n+import com.sun.javafx.tk.Toolkit;\n@@ -51,19 +96,0 @@\n-import javafx.application.ConditionalFeature;\n-import javafx.geometry.Dimension2D;\n-import javafx.scene.image.Image;\n-import javafx.scene.input.*;\n-import javafx.scene.paint.Color;\n-import javafx.scene.paint.ImagePattern;\n-import javafx.scene.paint.LinearGradient;\n-import javafx.scene.paint.RadialGradient;\n-import javafx.scene.shape.*;\n-import javafx.stage.FileChooser.ExtensionFilter;\n-import javafx.stage.Modality;\n-import javafx.stage.StageStyle;\n-import javafx.stage.Window;\n-import javafx.util.Pair;\n-\n-import java.io.File;\n-import java.io.InputStream;\n-import java.util.*;\n-import java.util.concurrent.Future;\n@@ -382,2 +408,3 @@\n-        @Override public boolean putContent(Pair<DataFormat, Object>... content) {\n-            boolean good;\n+        @Override\n+        public boolean putContent(Pair<DataFormat, Object>... content) {\n+            map.clear();\n@@ -385,2 +412,1 @@\n-                good = map.put(pair.getKey(), pair.getValue()) == pair.getValue();\n-                if (!good) return false;\n+                map.put(pair.getKey(), pair.getValue());\n","filename":"modules\/javafx.graphics\/src\/test\/java\/test\/com\/sun\/javafx\/pgstub\/StubToolkit.java","additions":55,"deletions":29,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+\t\t\t<attribute name=\"add-exports\" value=\"javafx.graphics\/com.sun.javafx.tk=jfx.incubator.richtext\"\/>\n","filename":"modules\/jfx.incubator.richtext\/.classpath","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,8 @@\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import java.util.List;\n+import javafx.css.CssMetaData;\n+import javafx.css.Styleable;\n+import javafx.scene.Scene;\n+import javafx.scene.text.Font;\n@@ -30,1 +38,0 @@\n-import org.junit.jupiter.api.Assertions;\n@@ -34,0 +41,1 @@\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n@@ -37,0 +45,1 @@\n+import test.jfx.incubator.scene.util.TUtil;\n@@ -39,1 +48,1 @@\n- * Tests CodeArea.\n+ * Tests the CodeArea control.\n@@ -46,1 +55,1 @@\n-        setUncaughtExceptionHandler();\n+        TUtil.setUncaughtExceptionHandler();\n@@ -53,1 +62,1 @@\n-        removeUncaughtExceptionHandler();\n+        TUtil.removeUncaughtExceptionHandler();\n@@ -56,7 +65,37 @@\n-    private void setUncaughtExceptionHandler() {\n-        Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -> {\n-            if (throwable instanceof RuntimeException) {\n-                throw (RuntimeException)throwable;\n-            } else {\n-                Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);\n-            }\n+    \/\/ constructors\n+\n+    @Test\n+    public void defaultModelIsCodeTextModel() {\n+        assertTrue(control.getModel() instanceof CodeTextModel);\n+    }\n+\n+    @Test\n+    public void nullModelInConstructor() {\n+        control = new CodeArea(null);\n+        assertTrue(control.getModel() == null);\n+\n+        control = new CodeArea(null);\n+        CodeTextModel m = new CodeTextModel() { };\n+        control.setModel(m);\n+        assertSame(m, control.getModel());\n+    }\n+\n+    \/\/ properties\n+\n+    @Test\n+    public void propertiesSettersAndGetters() {\n+        TUtil.testProperty(control.fontProperty(), control::getFont, control::setFont, new Font(\"Bogus\", 22));\n+        TUtil.testBooleanProperty(control.lineNumbersEnabledProperty(), control::isLineNumbersEnabled, control::setLineNumbersEnabled);\n+        TUtil.testProperty(control.lineSpacingProperty(), control::getLineSpacing, (n) -> control.setLineSpacing(n.doubleValue()), 10.0, 22.0);\n+        TUtil.testProperty(control.tabSizeProperty(), control::getTabSize, (n) -> control.setTabSize(n.intValue()), 1, 2);\n+    }\n+\n+    \/\/ default values\n+\n+    @Test\n+    public void defaultPropertyValues() {\n+        TUtil.checkDefaultValue(control.fontProperty(), control::getFont, (f) -> {\n+            Font expected = new Font(\"Monospace\", -1);\n+            assertEquals(f.getFamily(), expected.getFamily());\n+            assertEquals(f.getSize(), expected.getSize());\n+            return true;\n@@ -64,0 +103,3 @@\n+        TUtil.testDefaultValue(control.lineNumbersEnabledProperty(), control::isLineNumbersEnabled, false);\n+        TUtil.testDefaultValue(control.lineSpacingProperty(), control::getLineSpacing, 0.0);\n+        TUtil.testDefaultValue(control.tabSizeProperty(), control::getTabSize, 8);\n@@ -66,2 +108,44 @@\n-    private void removeUncaughtExceptionHandler() {\n-        Thread.currentThread().setUncaughtExceptionHandler(null);\n+    \/\/ css\n+\n+    @Test\n+    public void testFontCSS() {\n+        Scene s = new Scene(control);\n+        control.setStyle(\"-fx-font: 24 Amble\");\n+        control.applyCss();\n+        assertEquals(Font.font(\"Amble\", 24), control.getFont());\n+    }\n+\n+    @Test\n+    public void testLineSpacingCSS() {\n+        Scene s = new Scene(control);\n+        control.setStyle(\"-fx-line-spacing: 5.55\");\n+        control.applyCss();\n+        assertEquals(5.55, control.getLineSpacing());\n+    }\n+\n+    @Test\n+    public void testTabSizeCSS() {\n+        Scene s = new Scene(control);\n+        control.setStyle(\"-fx-tab-size: 17\");\n+        control.applyCss();\n+        assertEquals(17, control.getTabSize());\n+    }\n+\n+    \/\/ property binding\n+\n+    @Test\n+    public void testPropertyBinding() {\n+        TUtil.testBinding(control.fontProperty(), control::getFont, new Font(\"Bogus\", 22));\n+        TUtil.testBinding(control.lineNumbersEnabledProperty(), control::isLineNumbersEnabled);\n+        TUtil.testBinding(control.lineSpacingProperty(), control::getLineSpacing, 10.0, 22.0);\n+        TUtil.testBinding(control.tabSizeProperty(), control::getTabSize, 1, 2, 5, 17);\n+    }\n+\n+    \/\/ functional API tests\n+\n+    @Test\n+    public void getControlCssMetaData() {\n+        List<CssMetaData<? extends Styleable, ?>> md = control.getControlCssMetaData();\n+        \/\/ CodeArea:395\n+        int styleablesCount = 3;\n+        assertEquals(md.size(), RichTextArea.getClassCssMetaData().size() + styleablesCount);\n@@ -95,5 +179,3 @@\n-    public void nullModel() {\n-        CodeArea t = new CodeArea();\n-        t.setModel(null);\n-        t.setModel(new CodeTextModel());\n-\n+    public void modelNull() {\n+        control.setModel(null);\n+        control.setModel(new CodeTextModel());\n@@ -104,4 +186,4 @@\n-    public void wrongModel() {\n-        CodeArea t = new CodeArea();\n-        Assertions.assertThrows(IllegalArgumentException.class, () -> {\n-            t.setModel(new RichTextModel());\n+    public void modelWrong() {\n+        var m = control.getModel();\n+        assertThrows(IllegalArgumentException.class, () -> {\n+            control.setModel(new RichTextModel());\n@@ -109,1 +191,1 @@\n-        Assertions.assertTrue(t.getModel() instanceof CodeTextModel);\n+        assertTrue(control.getModel() == m);\n@@ -114,6 +196,4 @@\n-    public void acceptableModel() {\n-        class M extends CodeTextModel { }\n-        M custom = new M();\n-        CodeArea t = new CodeArea();\n-        t.setModel(custom);\n-        Assertions.assertTrue(t.getModel() instanceof M);\n+    public void modelAcceptable() {\n+        CustomCodeTextModel m = new CustomCodeTextModel();\n+        control.setModel(m);\n+        assertTrue(control.getModel() == m);\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/jfx\/incubator\/scene\/control\/richtext\/CodeAreaTest.java","additions":109,"deletions":29,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.jfx.incubator.scene.control.richtext;\n+\n+import jfx.incubator.scene.control.richtext.model.CodeTextModel;\n+\n+public class CustomCodeTextModel extends CodeTextModel {\n+    public CustomCodeTextModel() {\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/jfx\/incubator\/scene\/control\/richtext\/CustomCodeTextModel.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.jfx.incubator.scene.control.richtext;\n+\n+import javafx.scene.Node;\n+import javafx.scene.control.Label;\n+import jfx.incubator.scene.control.richtext.SideDecorator;\n+\n+\/**\n+ * \"Custom\" SideDecorator for testing.\n+ *\/\n+public class CustomSideDecorator implements SideDecorator {\n+    public CustomSideDecorator() {\n+    }\n+\n+    @Override\n+    public double getPrefWidth(double viewWidth) {\n+        return 100;\n+    }\n+\n+    @Override\n+    public Node getMeasurementNode(int index) {\n+        return new Label();\n+    }\n+\n+    @Override\n+    public Node getNode(int index) {\n+        return new Label();\n+    }\n+\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/jfx\/incubator\/scene\/control\/richtext\/CustomSideDecorator.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.jfx.incubator.scene.control.richtext;\n+\n+import java.util.function.Supplier;\n+import javafx.scene.layout.Region;\n+import jfx.incubator.scene.control.richtext.StyleResolver;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+import jfx.incubator.scene.control.richtext.model.RichParagraph;\n+import jfx.incubator.scene.control.richtext.model.StyleAttributeMap;\n+import jfx.incubator.scene.control.richtext.model.StyledTextModel;\n+\n+\/**\n+ * \"Custom\" StyledTextModel for testing.\n+ *\/\n+public class CustomStyledTextModel extends StyledTextModel {\n+    public CustomStyledTextModel() {\n+    }\n+\n+    @Override\n+    public boolean isWritable() {\n+        return false;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return 0;\n+    }\n+\n+    @Override\n+    public String getPlainText(int index) {\n+        return null;\n+    }\n+\n+    @Override\n+    public RichParagraph getParagraph(int index) {\n+        return null;\n+    }\n+\n+    @Override\n+    protected void removeRange(TextPos start, TextPos end) {\n+    }\n+\n+    @Override\n+    protected int insertTextSegment(int index, int offset, String text, StyleAttributeMap attrs) {\n+        return 0;\n+    }\n+\n+    @Override\n+    protected void insertLineBreak(int index, int offset) {\n+    }\n+\n+    @Override\n+    protected void insertParagraph(int index, Supplier<Region> generator) {\n+    }\n+\n+    @Override\n+    protected void setParagraphStyle(int index, StyleAttributeMap paragraphAttrs) {\n+    }\n+\n+    @Override\n+    protected void applyStyle(int index, int start, int end, StyleAttributeMap a, boolean merge) {\n+    }\n+\n+    @Override\n+    public StyleAttributeMap getStyleAttributeMap(StyleResolver resolver, TextPos pos) {\n+        return null;\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/jfx\/incubator\/scene\/control\/richtext\/CustomStyledTextModel.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n@@ -30,0 +31,15 @@\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import javafx.css.CssMetaData;\n+import javafx.css.Styleable;\n+import javafx.geometry.Insets;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Control;\n+import javafx.scene.input.Clipboard;\n+import javafx.scene.input.ClipboardContent;\n+import javafx.scene.input.DataFormat;\n+import javafx.util.Duration;\n@@ -32,0 +48,1 @@\n+import org.junit.jupiter.api.Disabled;\n@@ -37,0 +54,1 @@\n+import jfx.incubator.scene.control.richtext.StyleHandlerRegistry;\n@@ -38,0 +56,3 @@\n+import jfx.incubator.scene.control.richtext.model.CodeTextModel;\n+import jfx.incubator.scene.control.richtext.model.RichTextFormatHandler;\n+import jfx.incubator.scene.control.richtext.model.RichTextModel;\n@@ -40,0 +61,3 @@\n+import test.jfx.incubator.scene.control.richtext.support.RTUtil;\n+import test.jfx.incubator.scene.control.richtext.support.TestStyledInput;\n+import test.jfx.incubator.scene.util.TUtil;\n@@ -42,1 +66,8 @@\n- * Tests RichTextArea control.\n+ * Tests the RichTextArea control.\n+ *\n+ * NOTES:\n+ * 1. methods that involve moving the caret (backspace, delete, move*, select*, etc.) needs a real\n+ * text layout and therefore need to be headful (or wait for JDK-8342565).\n+ * 2. operations with models that contain more than one paragraph might also fail due to scrollCaretToVisible().\n+ *\n+ * TODO accessibility APIs\n@@ -46,0 +77,1 @@\n+    private static final StyleAttributeMap BOLD = StyleAttributeMap.builder().setBold(true).build();\n@@ -49,0 +81,2 @@\n+        TUtil.setUncaughtExceptionHandler();\n+\n@@ -55,0 +89,284 @@\n+        TUtil.removeUncaughtExceptionHandler();\n+    }\n+\n+    private String text() {\n+        return RTUtil.getText(control);\n+    }\n+\n+    \/\/ constructors\n+\n+    @Test\n+    public void defaultModelIsRichTextModel() {\n+        assertTrue(control.getModel() instanceof RichTextModel);\n+    }\n+\n+    @Test\n+    public void nullModelInConstructor() {\n+        control = new RichTextArea(null);\n+        assertTrue(control.getModel() == null);\n+\n+        CustomStyledTextModel m = new CustomStyledTextModel();\n+        control = new RichTextArea(null);\n+        control.setModel(m);\n+        assertSame(m, control.getModel());\n+    }\n+\n+    \/\/ properties\n+\n+    @Test\n+    public void propertiesSettersAndGetters() {\n+        TUtil.testProperty(control.caretBlinkPeriodProperty(), control::getCaretBlinkPeriod, control::setCaretBlinkPeriod, Duration.millis(10));\n+        TUtil.testProperty(control.contentPaddingProperty(), control::getContentPadding, control::setContentPadding, null, new Insets(40));\n+        TUtil.testBooleanProperty(control.displayCaretProperty(), control::isDisplayCaret, control::setDisplayCaret);\n+        TUtil.testBooleanProperty(control.editableProperty(), control::isEditable, control::setEditable);\n+        TUtil.testBooleanProperty(control.highlightCurrentParagraphProperty(), control::isHighlightCurrentParagraph, control::setHighlightCurrentParagraph);\n+        TUtil.testProperty(control.leftDecoratorProperty(), control::getLeftDecorator, control::setLeftDecorator, null, new CustomSideDecorator());\n+        TUtil.testProperty(control.modelProperty(), control::getModel, control::setModel, null, new RichTextModel(), new CodeTextModel());\n+        TUtil.testProperty(control.rightDecoratorProperty(), control::getRightDecorator, control::setRightDecorator, null, new CustomSideDecorator());\n+        TUtil.testBooleanProperty(control.useContentHeightProperty(), control::isUseContentHeight, control::setUseContentHeight);\n+        TUtil.testBooleanProperty(control.useContentWidthProperty(), control::isUseContentWidth, control::setUseContentWidth);\n+        TUtil.testBooleanProperty(control.wrapTextProperty(), control::isWrapText, control::setWrapText);\n+    }\n+\n+    @Test\n+    public void nonNullableProperties() {\n+        TUtil.testNonNullable(control.caretBlinkPeriodProperty(), control::setCaretBlinkPeriod);\n+    }\n+\n+    \/\/ default values\n+\n+    @Test\n+    public void defaultPropertyValues() {\n+        TUtil.testDefaultValue(control.caretBlinkPeriodProperty(), control::getCaretBlinkPeriod, Duration.millis(1000));\n+        TUtil.testDefaultValue(control.contentPaddingProperty(), control::getContentPadding, null);\n+        TUtil.testDefaultValue(control.displayCaretProperty(), control::isDisplayCaret, true);\n+        TUtil.testDefaultValue(control.editableProperty(), control::isEditable, true);\n+        TUtil.testDefaultValue(control.highlightCurrentParagraphProperty(), control::isHighlightCurrentParagraph, false);\n+        TUtil.testDefaultValue(control.leftDecoratorProperty(), control::getLeftDecorator, null);\n+        TUtil.checkDefaultValue(control.modelProperty(), control::getModel, (v) -> (v instanceof RichTextModel));\n+        TUtil.testDefaultValue(control.rightDecoratorProperty(), control::getRightDecorator, null);\n+        TUtil.testDefaultValue(control.useContentHeightProperty(), control::isUseContentHeight, false);\n+        TUtil.testDefaultValue(control.useContentWidthProperty(), control::isUseContentWidth, false);\n+        TUtil.testDefaultValue(control.wrapTextProperty(), control::isWrapText, false);\n+    }\n+\n+    \/\/ css\n+\n+    @Test\n+    public void testCaretBlinkPeriodCSS() {\n+        Scene s = new Scene(control);\n+        control.setStyle(\"-fx-caret-blink-period: 1ms\");\n+        control.applyCss();\n+        assertEquals(Duration.millis(1), control.getCaretBlinkPeriod());\n+\n+        control.setStyle(\"-fx-caret-blink-period: 99ms\");\n+        control.applyCss();\n+        assertEquals(Duration.millis(99), control.getCaretBlinkPeriod());\n+    }\n+\n+    @Test\n+    public void testContentPaddingCSS() {\n+        Scene s = new Scene(control);\n+        control.setStyle(\"-fx-content-padding: 99\");\n+        control.applyCss();\n+        assertEquals(new Insets(99), control.getContentPadding());\n+\n+        control.setStyle(\"-fx-content-padding: null\");\n+        control.applyCss();\n+        assertEquals(null, control.getContentPadding());\n+    }\n+\n+    @Test\n+    public void testDisplayCaretCSS() {\n+        Scene s = new Scene(control);\n+        control.setStyle(\"-fx-display-caret: false\");\n+        control.applyCss();\n+        assertFalse(control.isDisplayCaret());\n+\n+        control.setStyle(\"-fx-display-caret: true\");\n+        control.applyCss();\n+        assertTrue(control.isDisplayCaret());\n+    }\n+\n+    @Test\n+    public void testHighlightCurrentParagraphCSS() {\n+        Scene s = new Scene(control);\n+        control.setStyle(\"-fx-highlight-current-paragraph: false\");\n+        control.applyCss();\n+        assertFalse(control.isHighlightCurrentParagraph());\n+\n+        control.setStyle(\"-fx-highlight-current-paragraph: true\");\n+        control.applyCss();\n+        assertTrue(control.isHighlightCurrentParagraph());\n+    }\n+\n+    @Test\n+    public void testUseContentHeightCSS() {\n+        Scene s = new Scene(control);\n+        control.setStyle(\"-fx-use-content-height: false\");\n+        control.applyCss();\n+        assertFalse(control.isUseContentHeight());\n+\n+        control.setStyle(\"-fx-use-content-height: true\");\n+        control.applyCss();\n+        assertTrue(control.isUseContentHeight());\n+    }\n+\n+    @Test\n+    public void testUseContentWidthCSS() {\n+        Scene s = new Scene(control);\n+        control.setStyle(\"-fx-use-content-width: false\");\n+        control.applyCss();\n+        assertFalse(control.isUseContentWidth());\n+\n+        control.setStyle(\"-fx-use-content-width: true\");\n+        control.applyCss();\n+        assertTrue(control.isUseContentWidth());\n+    }\n+\n+    @Test\n+    public void testWrapTextCSS() {\n+        Scene s = new Scene(control);\n+        control.setStyle(\"-fx-wrap-text: false\");\n+        control.applyCss();\n+        assertFalse(control.isWrapText());\n+\n+        control.setStyle(\"-fx-wrap-text: true\");\n+        control.applyCss();\n+        assertTrue(control.isWrapText());\n+    }\n+\n+    \/\/ property binding\n+\n+    @Test\n+    public void testPropertyBinding() {\n+        \/\/ caret blink period property is internally constrained and cannot be bound\n+        \/\/TUtil.testBinding(control.caretBlinkPeriodProperty(), control::getCaretBlinkPeriod, Duration.millis(10));\n+        TUtil.testBinding(control.contentPaddingProperty(), control::getContentPadding, null, new Insets(40));\n+        TUtil.testBinding(control.displayCaretProperty(), control::isDisplayCaret);\n+        TUtil.testBinding(control.editableProperty(), control::isEditable);\n+        TUtil.testBinding(control.highlightCurrentParagraphProperty(), control::isHighlightCurrentParagraph);\n+        TUtil.testBinding(control.leftDecoratorProperty(), control::getLeftDecorator, null, new CustomSideDecorator());\n+        TUtil.testBinding(control.modelProperty(), control::getModel, null, new RichTextModel(), new CodeTextModel());\n+        TUtil.testBinding(control.rightDecoratorProperty(), control::getRightDecorator, null, new CustomSideDecorator());\n+        TUtil.testBinding(control.useContentHeightProperty(), control::isUseContentHeight);\n+        TUtil.testBinding(control.useContentWidthProperty(), control::isUseContentWidth);\n+        TUtil.testBinding(control.wrapTextProperty(), control::isWrapText);\n+    }\n+\n+    \/\/ functional API tests\n+\n+    @Test\n+    public void appendText() {\n+        TextPos p = control.appendText(\"a\");\n+        assertEquals(TextPos.ofLeading(0, 1), p);\n+        assertEquals(\"a\", text());\n+    }\n+\n+    @Test\n+    public void appendTextWithStyles() {\n+        TextPos p = control.appendText(\"a\", BOLD);\n+        assertEquals(TextPos.ofLeading(0, 1), p);\n+        control.select(p);\n+        assertEquals(BOLD, control.getActiveStyleAttributeMap());\n+        assertEquals(\"a\", text());\n+    }\n+\n+    @Test\n+    public void appendTextFromStyledInput() {\n+        TestStyledInput in = TestStyledInput.plainText(\"a\\nb\");\n+        TextPos p = control.appendText(in);\n+        assertEquals(TextPos.ofLeading(1, 1), p);\n+    }\n+\n+    @Test\n+    public void applyStyle() {\n+        TestStyledInput in = TestStyledInput.plainText(\"a\\nb\");\n+        TextPos p = control.appendText(in);\n+        control.applyStyle(TextPos.ZERO, TextPos.ofLeading(0, 1), BOLD);\n+        assertEquals(TextPos.ofLeading(1, 1), p);\n+    }\n+\n+    @Test\n+    public void clear() {\n+        control.appendText(\"a\");\n+        control.clear();\n+        TextPos p = control.getDocumentEnd();\n+        assertEquals(TextPos.ZERO, p);\n+    }\n+\n+    @Test\n+    public void clearSelection() {\n+        control.appendText(\"a\");\n+        control.selectAll();\n+        control.clearSelection();\n+        assertEquals(null, control.getSelection());\n+    }\n+\n+    @Test\n+    public void clearUndoRedo() {\n+        control.appendText(\"a\");\n+        control.clearUndoRedo();\n+    }\n+\n+    @Test\n+    public void copy() {\n+        RTUtil.copyToClipboard(\"\");\n+        control.appendText(\"ax\");\n+        control.selectAll();\n+        control.copy();\n+        assertEquals(\"ax\", Clipboard.getSystemClipboard().getString());\n+    }\n+\n+    @Disabled(\"JDK-8355415\")\n+    \/\/ TODO combine with copy()\n+    @Test\n+    public void copyExt() {\n+        RTUtil.copyToClipboard(\"\");\n+        control.appendText(\"ax\");\n+        control.selectAll();\n+        control.copy();\n+        assertEquals(\"ax\", Clipboard.getSystemClipboard().getString());\n+\n+        \/\/ copying an empty selection should not modify the clipboard content\n+        control.clearSelection();\n+        assertEquals(\"ax\", Clipboard.getSystemClipboard().getString());\n+\n+        \/\/ the following code fails due to JDK-8355415\n+        control.appendText(\"\\n1\");\n+        control.select(new TextPos(0, 2, 1, false), control.getDocumentEnd());\n+        control.copy();\n+        assertEquals(\"\\n1\", Clipboard.getSystemClipboard().getString());\n+    }\n+\n+    @Test\n+    public void copyDataFormat() {\n+        RTUtil.copyToClipboard(\"\");\n+        control.appendText(\"a\");\n+        control.selectAll();\n+        DataFormat fmt = RichTextFormatHandler.DATA_FORMAT;\n+        control.copy(fmt);\n+        String s = Clipboard.getSystemClipboard().getString();\n+        assertEquals(null, s);\n+        Object v = Clipboard.getSystemClipboard().getContent(fmt);\n+        assertEquals(\"a{!}\", v);\n+    }\n+\n+    @Test\n+    public void cut() {\n+        control.appendText(\"123\");\n+        control.selectAll();\n+        control.cut();\n+        assertEquals(\"\", text());\n+    }\n+\n+    @Test\n+    public void deselect() {\n+        control.appendText(\"123\");\n+        control.selectAll();\n+        control.deselect();\n+        SelectionSegment sel = control.getSelection();\n+        TextPos p = control.getCaretPosition();\n+        assertNotNull(p);\n+        assertEquals(p, sel.getMin());\n+        assertEquals(p, sel.getMax());\n@@ -69,0 +387,251 @@\n+    @Test\n+    public void executeDefault() {\n+        \/\/ map SELECT_ALL to no-op\n+        control.getInputMap().registerFunction(RichTextArea.Tag.SELECT_ALL, () -> { });\n+\n+        control.appendText(\"123\");\n+        control.selectAll();\n+        \/\/ remapped function is a no-op\n+        assertEquals(null, control.getSelection());\n+        \/\/ default function is still there\n+        control.executeDefault(RichTextArea.Tag.SELECT_ALL);\n+        assertTrue(control.getSelection() != null);\n+    }\n+\n+    @Test\n+    public void getActiveStyleAttributeMap() {\n+        control.appendText(\"1234\", BOLD);\n+        control.appendText(\"5678\", StyleAttributeMap.EMPTY);\n+\n+        control.select(TextPos.ofLeading(0, 2));\n+        StyleAttributeMap a = control.getActiveStyleAttributeMap();\n+        assertTrue(a.contains(StyleAttributeMap.BOLD));\n+\n+        control.select(TextPos.ofLeading(0, 6));\n+        a = control.getActiveStyleAttributeMap();\n+        assertFalse(a.contains(StyleAttributeMap.BOLD));\n+    }\n+\n+    @Test\n+    public void getControlCssMetaData() {\n+        List<CssMetaData<? extends Styleable, ?>> md = control.getControlCssMetaData();\n+        \/\/ RichTextArea:1019\n+        int styleablesCount = 7;\n+        assertEquals(md.size(), Control.getClassCssMetaData().size() + styleablesCount);\n+    }\n+\n+    @Test\n+    public void getParagraphCount() {\n+        assertEquals(1, control.getParagraphCount());\n+\n+        control.appendText(\"1\\n2\\n3\");\n+        assertEquals(3, control.getParagraphCount());\n+\n+        control.setModel(null);\n+        assertEquals(0, control.getParagraphCount());\n+    }\n+\n+    @Test\n+    public void getParagraphEnd() {\n+        control.appendText(\"1\\n22\\n333\");\n+        assertEquals(new TextPos(0, 1, 0, false), control.getParagraphEnd(0));\n+        assertEquals(new TextPos(1, 2, 1, false), control.getParagraphEnd(1));\n+        assertEquals(new TextPos(2, 3, 2, false), control.getParagraphEnd(2));\n+\n+        control.setModel(null);\n+        \/\/ TODO this should throw an IOOBE\n+        assertEquals(TextPos.ZERO, control.getParagraphEnd(0));\n+    }\n+\n+    @Test\n+    public void getPlainText() {\n+        control.appendText(\"1\\n22\\n333\");\n+        assertEquals(\"1\", control.getPlainText(0));\n+        assertEquals(\"22\", control.getPlainText(1));\n+        assertEquals(\"333\", control.getPlainText(2));\n+    }\n+\n+    @Test\n+    public void getSelection() {\n+        control.appendText(\"123\");\n+        control.selectAll();\n+        SelectionSegment sel = control.getSelection();\n+        assertNotNull(sel);\n+    }\n+\n+    @Test\n+    public void getStyleHandlerRegistry() {\n+        StyleHandlerRegistry r = control.getStyleHandlerRegistry();\n+        assertNotNull(r);\n+    }\n+\n+    @Test\n+    public void hasNonEmptySelection() {\n+        control.appendText(\"123\");\n+        assertFalse(control.hasNonEmptySelection());\n+        control.selectAll();\n+        assertTrue(control.hasNonEmptySelection());\n+    }\n+\n+    @Disabled(\"JDK-8355415\") \/\/ FIX\n+    @Test\n+    public void insertLineBreak() {\n+        control.appendText(\"123\");\n+        control.select(TextPos.ofLeading(0, 1));\n+        control.insertLineBreak();\n+    }\n+\n+    @Test\n+    public void isRedoable() {\n+        assertFalse(control.isRedoable());\n+        control.appendText(\"123\");\n+        control.undo();\n+        assertTrue(control.isRedoable());\n+    }\n+\n+    @Test\n+    public void isUndoable() {\n+        assertFalse(control.isUndoable());\n+        control.appendText(\"123\");\n+        assertTrue(control.isUndoable());\n+    }\n+\n+    @Test\n+    public void modelChangeClearsSelection() {\n+        control.insertText(TextPos.ZERO, \"1234\", null);\n+        control.selectAll();\n+        SelectionSegment sel = control.getSelection();\n+        assertFalse(sel.isCollapsed());\n+        control.setModel(new RichTextModel());\n+        sel = control.getSelection();\n+        assertEquals(null, sel);\n+        assertEquals(\"\", text());\n+    }\n+\n+    @Test\n+    public void paste() {\n+        RTUtil.copyToClipboard(\"-\");\n+        control.appendText(\"123\");\n+        control.select(TextPos.ofLeading(0, 1));\n+        control.paste();\n+        assertEquals(\"1-23\", text());\n+    }\n+\n+    @Test\n+    public void pasteDataFormat() {\n+        DataFormat fmt = RichTextFormatHandler.DATA_FORMAT;\n+        ClipboardContent cc = new ClipboardContent();\n+        cc.putString(\"plain\");\n+        cc.put(fmt, \"a{!}\");\n+        Clipboard.getSystemClipboard().setContent(cc);\n+\n+        control.appendText(\"123\");\n+        control.select(TextPos.ofLeading(0, 1));\n+        control.paste(fmt);\n+        assertEquals(\"1a23\", text());\n+    }\n+\n+    @Test\n+    public void pastePlainText() {\n+        DataFormat fmt = RichTextFormatHandler.DATA_FORMAT;\n+        ClipboardContent cc = new ClipboardContent();\n+        cc.putString(\"plain\");\n+        cc.put(fmt, \"a{!}\");\n+        Clipboard.getSystemClipboard().setContent(cc);\n+\n+        control.appendText(\"123\");\n+        control.select(TextPos.ofLeading(0, 1));\n+        control.pastePlainText();\n+        assertEquals(\"1plain23\", text());\n+    }\n+\n+    @Test\n+    public void read() throws Exception {\n+        control.appendText(\"1 bold\");\n+        control.applyStyle(TextPos.ofLeading(0, 2), TextPos.ofLeading(0, 6), BOLD);\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        control.write(out);\n+        byte[] b = out.toByteArray();\n+        String text1 = text();\n+\n+        control = new RichTextArea();\n+        ByteArrayInputStream in = new ByteArrayInputStream(b);\n+        control.read(in);\n+        String text2 = text();\n+        assertEquals(text1, text2);\n+    }\n+\n+    @Test\n+    public void readDataFormat() throws Exception {\n+        DataFormat fmt = DataFormat.PLAIN_TEXT;\n+        control.appendText(\"1 bold\");\n+        control.applyStyle(TextPos.ofLeading(0, 2), TextPos.ofLeading(0, 6), BOLD);\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        control.write(fmt, out);\n+        byte[] b = out.toByteArray();\n+        String text1 = text();\n+\n+        control = new RichTextArea();\n+        ByteArrayInputStream in = new ByteArrayInputStream(b);\n+        control.read(fmt, in);\n+        String text2 = text();\n+        assertEquals(text1, text2);\n+    }\n+\n+    @Test\n+    public void redo() {\n+        control.appendText(\"123\");\n+        control.undo();\n+        assertEquals(\"\", text());\n+        control.redo();\n+        assertEquals(\"123\", text());\n+        \/\/ test undo\/redo stack\n+        control.appendText(\"4\");\n+        control.appendText(\"5\");\n+        assertEquals(\"12345\", text());\n+        control.undo();\n+        control.undo();\n+        control.undo();\n+        assertEquals(\"\", text());\n+        control.redo();\n+        control.redo();\n+        control.redo();\n+        assertEquals(\"12345\", text());\n+    }\n+\n+    @Test\n+    public void replaceText() {\n+        control.appendText(\"1234\");\n+        control.replaceText(TextPos.ofLeading(0, 1), TextPos.ofLeading(0, 3), \"-\", false);\n+        assertEquals(\"1-4\", text());\n+    }\n+\n+    @Test\n+    public void replaceTextFromStyledInput() {\n+        TestStyledInput in = TestStyledInput.plainText(\"-\");\n+        control.appendText(\"1234\");\n+        control.replaceText(TextPos.ofLeading(0, 1), TextPos.ofLeading(0, 3), in, false);\n+        assertEquals(\"1-4\", text());\n+    }\n+\n+    @Test\n+    public void select() {\n+        TextPos p = TextPos.ofLeading(0, 1);\n+        control.appendText(\"1234\");\n+        control.select(p);\n+        SelectionSegment sel = control.getSelection();\n+        assertEquals(sel.getMin(), p);\n+        assertEquals(sel.getMax(), p);\n+    }\n+\n+    @Test\n+    public void selectRange() {\n+        TextPos p1 = TextPos.ofLeading(0, 1);\n+        TextPos p2 = TextPos.ofLeading(0, 2);\n+        control.appendText(\"1234\");\n+        control.select(p1, p2);\n+        SelectionSegment sel = control.getSelection();\n+        assertEquals(sel.getMin(), p1);\n+        assertEquals(sel.getMax(), p2);\n+    }\n+\n@@ -81,0 +650,37 @@\n+    @Test\n+    public void undo() {\n+        control.appendText(\"1\");\n+        control.undo();\n+        assertEquals(\"\", text());\n+        \/\/ test undo\/redo stack\n+        control.appendText(\"2\");\n+        control.appendText(\"3\");\n+        control.appendText(\"4\");\n+        assertEquals(\"234\", text());\n+        control.undo();\n+        control.undo();\n+        control.undo();\n+        assertEquals(\"\", text());\n+    }\n+\n+    @Test\n+    public void write() throws Exception {\n+        control.appendText(\"1 bold\");\n+        control.applyStyle(TextPos.ofLeading(0, 2), TextPos.ofLeading(0, 6), BOLD);\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        control.write(out);\n+        byte[] b = out.toByteArray();\n+        assertEquals(\"1 {b}bold{!}\", new String(b, StandardCharsets.US_ASCII));\n+    }\n+\n+    @Test\n+    public void writeDataFormat() throws Exception {\n+        DataFormat fmt = DataFormat.PLAIN_TEXT;\n+        control.appendText(\"1 bold\");\n+        control.applyStyle(TextPos.ofLeading(0, 2), TextPos.ofLeading(0, 6), BOLD);\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        control.write(fmt, out);\n+        byte[] b = out.toByteArray();\n+        assertEquals(\"1 bold\", new String(b, StandardCharsets.US_ASCII));\n+    }\n+\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/jfx\/incubator\/scene\/control\/richtext\/RichTextAreaTest.java","additions":607,"deletions":1,"binary":false,"changes":608,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.jfx.incubator.scene.control.richtext.support;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import javafx.scene.input.Clipboard;\n+import javafx.scene.input.ClipboardContent;\n+import javafx.scene.input.DataFormat;\n+import com.sun.javafx.tk.Toolkit;\n+import jfx.incubator.scene.control.richtext.RichTextArea;\n+import jfx.incubator.scene.control.richtext.TextPos;\n+\n+\/**\n+ * Utilities for RichTextArea-based tests.\n+ *\/\n+public class RTUtil {\n+\n+    private RTUtil() {\n+    }\n+\n+    \/**\n+     * Replaces existing content with the specified non-styled text string.\n+     *\n+     * @param control the rich text area\n+     * @param text the text\n+     *\/\n+    public static void setText(RichTextArea control, String text) {\n+        TextPos end = control.getDocumentEnd();\n+        control.replaceText(TextPos.ZERO, end, text, false);\n+    }\n+\n+    \/**\n+     * Extracts plain text from the supplied RichTextArea, using {@code write(DataFormat.PLAIN_TEXT)} method.\n+     *\n+     * @param control the rich text area\n+     * @return the plain text\n+     *\/\n+    public static String getText(RichTextArea control) {\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try {\n+            try {\n+                control.write(DataFormat.PLAIN_TEXT, out);\n+                byte[] b = out.toByteArray();\n+                return new String(b, StandardCharsets.UTF_8);\n+            } finally {\n+                out.close();\n+            }\n+        } catch (IOException e) {\n+            throw new AssertionError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Clears the system Clipboard.\n+     *\/\n+    public static void copyToClipboard(String text) {\n+        ClipboardContent cc = new ClipboardContent();\n+        cc.putString(text);\n+        Clipboard.getSystemClipboard().setContent(cc);\n+        firePulse();\n+    }\n+\n+    \/**\n+     * Fires a pulse.\n+     *\/\n+    public static void firePulse() {\n+        Toolkit.getToolkit().firePulse();\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/jfx\/incubator\/scene\/control\/richtext\/support\/RTUtil.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.jfx.incubator.scene.control.richtext.support;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import com.sun.jfx.incubator.scene.control.richtext.SegmentStyledInput;\n+import jfx.incubator.scene.control.richtext.model.StyledInput;\n+import jfx.incubator.scene.control.richtext.model.StyledSegment;\n+\n+public class TestStyledInput implements StyledInput {\n+    private final StyledSegment[] segments;\n+    private int index;\n+\n+    private TestStyledInput(StyledSegment[] segments) {\n+        this.segments = segments;\n+    }\n+\n+    public static TestStyledInput plainText(String text) {\n+        String[] lines = text.split(\"\\n\");\n+        ArrayList<StyledSegment> ss = new ArrayList<>();\n+        for (int i = 0; i < lines.length; i++) {\n+            if (i > 0) {\n+                ss.add(StyledSegment.LINE_BREAK);\n+            }\n+            ss.add(StyledSegment.of(lines[i]));\n+        }\n+        return new TestStyledInput(ss.toArray(StyledSegment[]::new));\n+    }\n+\n+    public static SegmentStyledInput of(List<StyledSegment> segments) {\n+        StyledSegment[] ss = segments.toArray(new StyledSegment[segments.size()]);\n+        return new SegmentStyledInput(ss);\n+    }\n+\n+    @Override\n+    public StyledSegment nextSegment() {\n+        if (index < segments.length) {\n+            return segments[index++];\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/jfx\/incubator\/scene\/control\/richtext\/support\/TestStyledInput.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.jfx.incubator.scene.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+import javafx.beans.property.BooleanProperty;\n+import javafx.beans.property.Property;\n+import javafx.beans.property.SimpleBooleanProperty;\n+import javafx.beans.property.SimpleObjectProperty;\n+\n+\/**\n+ * There should be a common place for module-agnostic test utilities.\n+ *\/\n+public class TUtil {\n+    private static final Boolean[] BOOLEAN_VALUES = { null, Boolean.TRUE, Boolean.FALSE };\n+\n+    private TUtil() {\n+    }\n+\n+    \/** Sets the uncaught exception handler to forward to the thread group *\/\n+    public static void setUncaughtExceptionHandler() {\n+        Thread.currentThread().setUncaughtExceptionHandler((thread, throwable) -> {\n+            if (throwable instanceof RuntimeException) {\n+                \/\/ needed for junit framework to fail the test\n+                throw (RuntimeException)throwable;\n+            } else {\n+                Thread.currentThread().getThreadGroup().uncaughtException(thread, throwable);\n+            }\n+        });\n+    }\n+\n+    \/** Sets the uncaught exception handler to null. *\/\n+    public static void removeUncaughtExceptionHandler() {\n+        Thread.currentThread().setUncaughtExceptionHandler(null);\n+    }\n+\n+    \/**\n+     * Verifies that the boolean property can be set to {@code null}, {@code Boolean.TRUE}, and {@code Boolean.FALSE}\n+     * using the property's direct {@code setValue()} method, as well as the provided setter method (when not null).\n+     * The property value is read back using the property's direct {@code getValue()} method as well as the provided\n+     * getter (when not null).\n+     * This method restores the initial value afterward.\n+     *\n+     * @param prop the boolean property\n+     * @param getter the getter (or null)\n+     * @param setter the setter (or null)\n+     *\/\n+    public static void testBooleanProperty(BooleanProperty prop, Supplier<Boolean> getter, Consumer<Boolean> setter) {\n+        Boolean initialValue = prop.get();\n+\n+        \/\/ directly using the property\n+        try {\n+            for (Boolean val : BOOLEAN_VALUES) {\n+                prop.setValue(val);\n+                Boolean v = prop.get();\n+                if (val == null) {\n+                    val = Boolean.FALSE;\n+                }\n+                assertEquals(val, v);\n+            }\n+        } finally {\n+            prop.setValue(initialValue);\n+        }\n+\n+        \/\/ using the getter\n+        if (getter != null) {\n+            try {\n+                for (Boolean val : BOOLEAN_VALUES) {\n+                    prop.setValue(val);\n+                    Boolean v = getter.get();\n+                    if (val == null) {\n+                        val = Boolean.FALSE;\n+                    }\n+                    assertEquals(val, v);\n+                }\n+            } finally {\n+                prop.setValue(initialValue);\n+            }\n+        }\n+\n+        \/\/ using the setter\n+        if (setter != null) {\n+            try {\n+                \/\/ BooleanProperty operates with a primitive\n+                for (Boolean val : new Boolean[] { Boolean.FALSE, Boolean.TRUE }) {\n+                    setter.accept(val);\n+                    Boolean v = prop.get();\n+                    assertEquals(val, v);\n+                }\n+            } finally {\n+                prop.setValue(initialValue);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that the specified property can be set to the specified values\n+     * using the property's direct {@code setValue()} method, as well as the provided setter method (when not null).\n+     * The property value is read back using the property's direct {@code getValue()} method as well as the provided\n+     * getter (when not null).\n+     * This method restores the initial value afterward.\n+     * @param <T> the value type\n+     * @param prop the property\n+     * @param getter the getter (or null)\n+     * @param setter the setter (or null)\n+     * @param values the values to be used\n+     *\/\n+    public static <T> void testProperty(Property<T> prop, Supplier<T> getter, Consumer<T> setter, T... values) {\n+        T initialValue = prop.getValue();\n+\n+        \/\/ directly using the property\n+        try {\n+            for (T val : values) {\n+                prop.setValue(val);\n+                T v = prop.getValue();\n+                assertEquals(val, v);\n+            }\n+        } finally {\n+            prop.setValue(initialValue);\n+        }\n+\n+        \/\/ using the getter\n+        if (getter != null) {\n+            try {\n+                for (T val : values) {\n+                    prop.setValue(val);\n+                    T v = getter.get();\n+                    assertEquals(val, v);\n+                }\n+            } finally {\n+                prop.setValue(initialValue);\n+            }\n+        }\n+\n+        \/\/ using the setter\n+        if (setter != null) {\n+            try {\n+                for (T val : values) {\n+                    setter.accept(val);\n+                    T v = prop.getValue();\n+                    assertEquals(val, v);\n+                }\n+            } finally {\n+                prop.setValue(initialValue);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests that the specified property is non-nullable by setting a null value and verifyting that\n+     * a {@code NullPointerException} is thrown, using {@code setValue()} method of the property, and the provided\n+     * {@code setter} if the latter is not {@code null}.\n+     *\n+     * @param <T> the value type\n+     * @param prop the property\n+     *\/\n+    public static <T> void testNonNullable(Property<T> prop, Consumer<T> setter) {\n+        T initialValue = prop.getValue();\n+\n+        try {\n+            assertThrows(NullPointerException.class, () -> {\n+                prop.setValue(null);\n+            });\n+        } finally {\n+            prop.setValue(initialValue);\n+        }\n+\n+        if (setter != null) {\n+            try {\n+                assertThrows(NullPointerException.class, () -> {\n+                    setter.accept(null);\n+                });\n+            } finally {\n+                prop.setValue(initialValue);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests whether the current value of the property equals to the expected value, using both\n+     * {@code getValue()} method of the property and the provided getter (when the latter is not {@code null}).\n+     *\n+     * @param <T> the value type\n+     * @param prop the property\n+     * @param getter the value getter, can be null\n+     * @param expected the expected value\n+     *\/\n+    public static <T> void testDefaultValue(Property<T> prop, Supplier<T> getter, T expected) {\n+        T v = prop.getValue();\n+        assertEquals(expected, v);\n+\n+        if (getter != null) {\n+            T v2 = getter.get();\n+            assertEquals(expected, v2);\n+        }\n+    }\n+\n+    \/**\n+     * Tests whether the current value of the property satisfies some criteria supplied by the {@code checker},\n+     * using both\n+     * {@code getValue()} method of the property and the provided getter (when the latter is not {@code null}).\n+     * @param <T>\n+     * @param prop\n+     * @param getter\n+     * @param checker\n+     *\/\n+    public static <T> void checkDefaultValue(Property<T> prop, Supplier<T> getter, Predicate<T> checker) {\n+        T v = prop.getValue();\n+        assertTrue(checker.test(v));\n+\n+        if (getter != null) {\n+            T v2 = getter.get();\n+            assertTrue(checker.test(v2));\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that the specified property can be bound and the corresponding getter\n+     * reflects the source property values.\n+     *\n+     * @param <T> the value type\n+     * @param prop the property to be tested\n+     * @param getter the getter for the property value, cannot be null\n+     * @param values the values to test with\n+     *\/\n+    public static <T> void testBinding(Property<T> prop, Supplier<T> getter, T... values) {\n+        T initialValue = prop.getValue();\n+        try {\n+            Property<T> p = new SimpleObjectProperty<T>();\n+            prop.bind(p);\n+\n+            \/\/ this code does not check for the initial value of the bound property\n+            for (T value : values) {\n+                p.setValue(value);\n+                T v = getter.get();\n+                assertEquals(value, v);\n+            }\n+        } finally {\n+            prop.unbind();\n+            prop.setValue(initialValue);\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that the specified boolean property can be bound and the corresponding getter\n+     * reflects the source property values.  The property is tested with the values\n+     * {@code null, Boolean.TRUE, Boolean.FALSE}.\n+     *\n+     * @param prop the property to be tested\n+     * @param getter the getter for the property value, cannot be null\n+     *\/\n+    public static void testBinding(BooleanProperty prop, Supplier<Boolean> getter) {\n+        Boolean initialValue = prop.getValue();\n+        try {\n+            SimpleBooleanProperty p = new SimpleBooleanProperty();\n+            prop.bind(p);\n+\n+            \/\/ this code does not check for the initial value of the bound property\n+            for (Boolean value : BOOLEAN_VALUES) {\n+                p.setValue(value);\n+                Boolean v = getter.get();\n+                if (value == null && v != null) {\n+                    value = Boolean.FALSE;\n+                }\n+                assertEquals(value, v);\n+            }\n+        } finally {\n+            prop.unbind();\n+            prop.setValue(initialValue);\n+        }\n+    }\n+}\n","filename":"modules\/jfx.incubator.richtext\/src\/test\/java\/test\/jfx\/incubator\/scene\/util\/TUtil.java","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"}]}