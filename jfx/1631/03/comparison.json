{"files":[{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx;\n-\n-import javafx.util.FXPermission;\n-\n-\/**\n- * Constants used for permission checks.\n- *\/\n-public final class FXPermissions {\n-\n-    \/\/ Prevent instantiation\n-    private FXPermissions() {\n-    }\n-\n-    public static final FXPermission ACCESS_CLIPBOARD_PERMISSION =\n-            new FXPermission(\"accessClipboard\");\n-\n-    public static final FXPermission ACCESS_WINDOW_LIST_PERMISSION =\n-            new FXPermission(\"accessWindowList\");\n-\n-    public static final FXPermission CREATE_ROBOT_PERMISSION =\n-            new FXPermission(\"createRobot\");\n-\n-    public static final FXPermission CREATE_TRANSPARENT_WINDOW_PERMISSION =\n-            new FXPermission(\"createTransparentWindow\");\n-\n-    public static final FXPermission UNRESTRICTED_FULL_SCREEN_PERMISSION =\n-            new FXPermission(\"unrestrictedFullScreen\");\n-\n-    public static final FXPermission LOAD_FONT_PERMISSION =\n-            new FXPermission(\"loadFont\");\n-\n-    public static final FXPermission MODIFY_FXML_CLASS_LOADER_PERMISSION =\n-            new FXPermission(\"modifyFXMLClassLoader\");\n-\n-    public static final FXPermission SET_WINDOW_ALWAYS_ON_TOP_PERMISSION =\n-            new FXPermission(\"setWindowAlwaysOnTop\");\n-\n-}\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/FXPermissions.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import java.security.AccessController;\n@@ -38,4 +37,0 @@\n-import java.lang.reflect.Modifier;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -56,1 +51,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -61,2 +55,1 @@\n-        if (clazz.equals(AccessController.class) ||\n-            clazz.equals(Method.class) ||\n+        if (clazz.equals(Method.class) ||\n@@ -105,157 +98,0 @@\n-    \/*\n-     * Discover the public methods on public classes\n-     * and interfaces accessible to any caller by calling\n-     * Class.getMethods() and walking towards Object until\n-     * we're done.\n-     *\/\n-    \/*public*\/\n-    @SuppressWarnings(\"removal\")\n-    static Method[] getPublicMethods(Class<?> cls) {\n-        \/\/ compatibility for update release\n-        if (System.getSecurityManager() == null) {\n-            return cls.getMethods();\n-        }\n-        Map<Signature, Method> sigs = new HashMap<>();\n-        while (cls != null) {\n-            boolean done = getInternalPublicMethods(cls, sigs);\n-            if (done) {\n-                break;\n-            }\n-            getInterfaceMethods(cls, sigs);\n-            cls = cls.getSuperclass();\n-        }\n-        return sigs.values().toArray(new Method[sigs.size()]);\n-    }\n-\n-    \/*\n-     * Process the immediate interfaces of this class or interface.\n-     *\/\n-    private static void getInterfaceMethods(Class<?> cls,\n-                                            Map<Signature, Method> sigs) {\n-        Class<?>[] intfs = cls.getInterfaces();\n-        for (int i=0; i < intfs.length; i++) {\n-            Class<?> intf = intfs[i];\n-            boolean done = getInternalPublicMethods(intf, sigs);\n-            if (!done) {\n-                getInterfaceMethods(intf, sigs);\n-            }\n-        }\n-    }\n-\n-    \/*\n-     *\n-     * Process the methods in this class or interface\n-     *\/\n-    private static boolean getInternalPublicMethods(Class<?> cls,\n-                                                    Map<Signature, Method> sigs) {\n-        Method[] methods = null;\n-        try {\n-            \/*\n-             * This class or interface is non-public so we\n-             * can't use any of it's methods. Go back and\n-             * try again with a superclass or superinterface.\n-             *\/\n-            if (!Modifier.isPublic(cls.getModifiers())) {\n-                return false;\n-            }\n-            if (!ReflectUtil.isPackageAccessible(cls)) {\n-                return false;\n-            }\n-\n-            methods = cls.getMethods();\n-        } catch (SecurityException se) {\n-            return false;\n-        }\n-\n-        \/*\n-         * Check for inherited methods with non-public\n-         * declaring classes. They might override and hide\n-         * methods from their superclasses or\n-         * superinterfaces.\n-         *\/\n-        boolean done = true;\n-        for (int i=0; i < methods.length; i++) {\n-            Class<?> dc = methods[i].getDeclaringClass();\n-            if (!Modifier.isPublic(dc.getModifiers())) {\n-                done = false;\n-                break;\n-            }\n-        }\n-\n-        if (done) {\n-            \/*\n-             * We're done. Spray all the methods into\n-             * the list and then we're out of here.\n-             *\/\n-            for (int i=0; i < methods.length; i++) {\n-                addMethod(sigs, methods[i]);\n-            }\n-        } else {\n-            \/*\n-             * Simulate cls.getDeclaredMethods() by\n-             * stripping away inherited methods.\n-             *\/\n-            for (int i=0; i < methods.length; i++) {\n-                Class<?> dc = methods[i].getDeclaringClass();\n-                if (cls.equals(dc)) {\n-                    addMethod(sigs, methods[i]);\n-                }\n-            }\n-        }\n-        return done;\n-    }\n-\n-    private static void addMethod(Map<Signature, Method> sigs, Method method) {\n-        Signature signature = new Signature(method);\n-        if (!sigs.containsKey(signature)) {\n-            sigs.put(signature, method);\n-        } else if (!method.getDeclaringClass().isInterface()){\n-            \/*\n-             * Superclasses beat interfaces.\n-             *\/\n-            Method old = sigs.get(signature);\n-            if (old.getDeclaringClass().isInterface()) {\n-                sigs.put(signature, method);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * A class that represents the unique elements of a method that will be a\n-     * key in the method cache.\n-     *\/\n-    private static class Signature {\n-        private final String methodName;\n-        private final Class<?>[] argClasses;\n-        private final int hashCode;\n-\n-        Signature(Method m) {\n-            this.methodName = m.getName();\n-            this.argClasses = m.getParameterTypes();\n-            this.hashCode = methodName.hashCode() + Arrays.hashCode(argClasses);\n-        }\n-\n-        @Override public int hashCode() {\n-            return hashCode;\n-        }\n-\n-        @Override public boolean equals(Object o2) {\n-            if (this == o2) {\n-                return true;\n-            }\n-            Signature that = (Signature)o2;\n-            if (!(methodName.equals(that.methodName))) {\n-                return false;\n-            }\n-            if (argClasses.length != that.argClasses.length) {\n-                return false;\n-            }\n-            for (int i = 0; i < argClasses.length; i++) {\n-                if (!(argClasses[i] == that.argClasses[i])) {\n-                  return false;\n-                }\n-            }\n-            return true;\n-        }\n-    }\n-\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/reflect\/MethodUtil.java","additions":1,"deletions":165,"binary":false,"changes":166,"status":"modified"},{"patch":"@@ -50,23 +50,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager s = System.getSecurityManager();\n-        if (s != null) {\n-            privateCheckPackageAccess(s, clazz);\n-        }\n-    }\n-\n-    \/**\n-     * NOTE: should only be called if a SecurityManager is installed\n-     *\/\n-    private static void privateCheckPackageAccess(@SuppressWarnings(\"removal\") SecurityManager s, Class<?> clazz) {\n-        while (clazz.isArray()) {\n-            clazz = clazz.getComponentType();\n-        }\n-\n-        String pkg = clazz.getPackageName();\n-        if (pkg != null && !pkg.isEmpty()) {\n-            s.checkPackageAccess(pkg);\n-        }\n-\n-        if (isNonPublicProxyClass(clazz)) {\n-            privateCheckProxyPackageAccess(s, clazz);\n-        }\n@@ -82,15 +59,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager s = System.getSecurityManager();\n-        if (s != null) {\n-            String cname = name.replace('\/', '.');\n-            if (cname.startsWith(\"[\")) {\n-                int b = cname.lastIndexOf('[') + 2;\n-                if (b > 1 && b < cname.length()) {\n-                    cname = cname.substring(b);\n-                }\n-            }\n-            int i = cname.lastIndexOf('.');\n-            if (i != -1) {\n-                s.checkPackageAccess(cname.substring(0, i));\n-            }\n-        }\n@@ -100,5 +62,0 @@\n-        try {\n-            checkPackageAccess(clazz);\n-        } catch (SecurityException e) {\n-            return false;\n-        }\n@@ -107,29 +64,0 @@\n-\n-    \/**\n-     * NOTE: should only be called if a SecurityManager is installed\n-     *\/\n-    private static void privateCheckProxyPackageAccess(@SuppressWarnings(\"removal\") SecurityManager s, Class<?> clazz) {\n-        \/\/ check proxy interfaces if the given class is a proxy class\n-        if (Proxy.isProxyClass(clazz)) {\n-            for (Class<?> intf : clazz.getInterfaces()) {\n-                privateCheckPackageAccess(s, intf);\n-            }\n-        }\n-    }\n-\n-    \/\/ Note that bytecode instrumentation tools may exclude 'sun.*'\n-    \/\/ classes but not generated proxy classes and so keep it in com.sun.*\n-    public static final String PROXY_PACKAGE = \"com.sun.proxy\";\n-\n-    \/**\n-     * Test if the given class is a proxy class that implements\n-     * non-public interface.  Such proxy class may be in a non-restricted\n-     * package that bypasses checkPackageAccess.\n-     *\/\n-    public static boolean isNonPublicProxyClass(Class<?> cls) {\n-        if (!Proxy.isProxyClass(cls)) {\n-            return false;\n-        }\n-        String pkg = cls.getPackageName();\n-        return pkg == null || !pkg.startsWith(PROXY_PACKAGE);\n-    }\n","filename":"modules\/javafx.base\/src\/main\/java\/com\/sun\/javafx\/reflect\/ReflectUtil.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-import static com.sun.javafx.FXPermissions.MODIFY_FXML_CLASS_LOADER_PERMISSION;\n@@ -107,7 +106,0 @@\n-    \/\/ Indicates permission to get the ClassLoader\n-    private static final RuntimePermission GET_CLASSLOADER_PERMISSION =\n-        new RuntimePermission(\"getClassLoader\");\n-\n-    \/\/ Instance of StackWalker used to get caller class (must be private)\n-    private static final StackWalker walker = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n-\n@@ -2435,6 +2427,1 @@\n-            @SuppressWarnings(\"removal\")\n-            final SecurityManager sm = System.getSecurityManager();\n-            final Class caller = (sm != null) ?\n-                    walker.getCallerClass() :\n-                    null;\n-            return getDefaultClassLoader(caller);\n+            return getDefaultClassLoader(null);\n@@ -2515,1 +2502,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -2517,3 +2503,1 @@\n-        return loadImpl((System.getSecurityManager() != null)\n-                            ? walker.getCallerClass()\n-                            : null);\n+        return loadImpl(null);\n@@ -2531,1 +2515,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -2533,3 +2516,1 @@\n-        return loadImpl(inputStream, (System.getSecurityManager() != null)\n-                                         ? walker.getCallerClass()\n-                                         : null);\n+        return loadImpl(inputStream, null);\n@@ -2538,0 +2519,3 @@\n+    \/\/ TODO: JDK-8344109: Consider removing this field and all\n+    \/\/ occurrences of callerClass arguments from the various load* methods\n+    \/\/ (callerClass is always null now)\n@@ -3161,7 +3145,0 @@\n-    private static boolean needsClassLoaderPermissionCheck(Class caller) {\n-        if (caller == null) {\n-            return false;\n-        }\n-        return !FXMLLoader.class.getModule().equals(caller.getModule());\n-    }\n-\n@@ -3170,7 +3147,0 @@\n-            @SuppressWarnings(\"removal\")\n-            final SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                if (needsClassLoaderPermissionCheck(caller)) {\n-                    sm.checkPermission(GET_CLASSLOADER_PERMISSION);\n-                }\n-            }\n@@ -3188,6 +3158,1 @@\n-        @SuppressWarnings(\"removal\")\n-        final SecurityManager sm = System.getSecurityManager();\n-        final Class caller = (sm != null) ?\n-                walker.getCallerClass() :\n-                null;\n-        return getDefaultClassLoader(caller);\n+        return getDefaultClassLoader(null);\n@@ -3207,5 +3172,0 @@\n-        @SuppressWarnings(\"removal\")\n-        final SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);\n-        }\n@@ -3225,1 +3185,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -3227,3 +3186,1 @@\n-        return loadImpl(location, (System.getSecurityManager() != null)\n-                                      ? walker.getCallerClass()\n-                                      : null);\n+        return loadImpl(location, null);\n@@ -3247,1 +3204,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -3250,4 +3206,1 @@\n-        return loadImpl(location, resources,\n-                        (System.getSecurityManager() != null)\n-                            ? walker.getCallerClass()\n-                            : null);\n+        return loadImpl(location, resources, null);\n@@ -3273,1 +3226,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -3277,4 +3229,1 @@\n-        return loadImpl(location, resources, builderFactory,\n-                        (System.getSecurityManager() != null)\n-                            ? walker.getCallerClass()\n-                            : null);\n+        return loadImpl(location, resources, builderFactory, null);\n@@ -3303,1 +3252,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -3309,3 +3257,1 @@\n-                        (System.getSecurityManager() != null)\n-                            ? walker.getCallerClass()\n-                            : null);\n+                        null);\n@@ -3337,1 +3283,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -3343,4 +3288,1 @@\n-                        charset,\n-                        (System.getSecurityManager() != null)\n-                            ? walker.getCallerClass()\n-                            : null);\n+                        charset, null);\n@@ -3443,8 +3385,0 @@\n-    private static void checkClassLoaderPermission() {\n-        @SuppressWarnings(\"removal\")\n-        final SecurityManager securityManager = System.getSecurityManager();\n-        if (securityManager != null) {\n-            securityManager.checkPermission(MODIFY_FXML_CLASS_LOADER_PERMISSION);\n-        }\n-    }\n-\n@@ -3499,5 +3433,0 @@\n-                if (callerClassLoader == null) {\n-                    \/\/ allow null class loader only with permission check\n-                    checkClassLoaderPermission();\n-                }\n-\n@@ -3520,5 +3449,0 @@\n-                if (callerClassLoader == null) {\n-                    \/\/ allow null class loader only with permission check\n-                    checkClassLoaderPermission();\n-                }\n-\n","filename":"modules\/javafx.fxml\/src\/main\/java\/javafx\/fxml\/FXMLLoader.java","additions":12,"deletions":88,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.security.AllPermission;\n@@ -135,5 +134,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPermission(new AllPermission());\n-        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/monocle\/AndroidInputDeviceRegistry.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.security.Permission;\n@@ -35,2 +34,1 @@\n- * C is a singleton. Its instance is obtained by calling C.getC(). This\n- * requires the RuntimePermission \"loadLibrary.*\".\n+ * C is a singleton. Its instance is obtained by calling C.getC().\n@@ -40,2 +38,0 @@\n-    private static Permission permission = new RuntimePermission(\"loadLibrary.*\");\n-\n@@ -45,2 +41,1 @@\n-     * Obtains the single instance of LinuxSystem. Calling this method requires\n-     * the RuntimePermission \"loadLibrary.*\".\n+     * Obtains the single instance of LinuxSystem.\n@@ -49,1 +44,0 @@\n-        checkPermissions();\n@@ -53,8 +47,0 @@\n-    private static void checkPermissions() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPermission(permission);\n-        }\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/monocle\/C.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.security.Permission;\n@@ -151,2 +150,0 @@\n-    private static Permission permission = new RuntimePermission(\"loadLibrary.*\");\n-\n@@ -158,2 +155,1 @@\n-     * Obtains the single instance of EGL. Calling this method requires\n-     * the RuntimePermission \"loadLibrary.*\".\n+     * Obtains the single instance of EGL.\n@@ -163,1 +159,0 @@\n-        checkPermissions();\n@@ -167,8 +162,0 @@\n-    private static void checkPermissions() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPermission(permission);\n-        }\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/monocle\/EGL.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.security.Permission;\n@@ -244,1 +243,0 @@\n-    private static final Permission PERMISSION = new RuntimePermission(\"loadLibrary.*\");\n@@ -248,14 +246,1 @@\n-     * Checks for permission to load native libraries if running under a\n-     * security manager.\n-     *\/\n-    private static void checkPermissions() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPermission(PERMISSION);\n-        }\n-    }\n-\n-    \/**\n-     * Obtains the single instance of {@code EPDSystem}. Calling this method\n-     * requires the \"loadLibrary.*\" {@code RuntimePermission}. The\n+     * Obtains the single instance of {@code EPDSystem}. The\n@@ -268,1 +253,0 @@\n-        checkPermissions();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/monocle\/EPDSystem.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.security.AllPermission;\n@@ -87,5 +86,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPermission(new AllPermission());\n-        }\n@@ -111,5 +105,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPermission(new AllPermission());\n-        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/monocle\/LinuxInputDeviceRegistry.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.security.Permission;\n@@ -43,2 +42,0 @@\n-    private static Permission permission = new RuntimePermission(\"loadLibrary.*\");\n-\n@@ -48,2 +45,1 @@\n-     * Obtains the single instance of LinuxSystem. Calling this method requires\n-     * the RuntimePermission \"loadLibrary.*\".\n+     * Obtains the single instance of LinuxSystem.\n@@ -55,1 +51,0 @@\n-        checkPermissions();\n@@ -59,8 +54,0 @@\n-    private static void checkPermissions() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPermission(permission);\n-        }\n-    }\n-\n@@ -203,1 +190,0 @@\n-            checkPermissions();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/monocle\/LinuxSystem.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.security.Permission;\n@@ -44,2 +43,0 @@\n-    private static Permission permission = new RuntimePermission(\"loadLibrary.*\");\n-\n@@ -49,2 +46,1 @@\n-     * Obtains the single instance of X. Calling this method requires\n-     * the RuntimePermission \"loadLibrary.*\".\n+     * Obtains the single instance of X.\n@@ -54,1 +50,0 @@\n-        checkPermissions();\n@@ -58,8 +53,0 @@\n-    private static void checkPermissions() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPermission(permission);\n-        }\n-    }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/glass\/ui\/monocle\/X.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import static com.sun.javafx.FXPermissions.CREATE_TRANSPARENT_WINDOW_PERMISSION;\n@@ -617,20 +616,1 @@\n-        final boolean supported = isSupportedImpl(feature);\n-        if (supported && (feature == ConditionalFeature.TRANSPARENT_WINDOW)) {\n-            \/\/ some features require the application to have the corresponding\n-            \/\/ permissions, if the application doesn't have them, the platform\n-            \/\/ will behave as if the feature wasn't supported\n-            @SuppressWarnings(\"removal\")\n-            final SecurityManager securityManager =\n-                    System.getSecurityManager();\n-            if (securityManager != null) {\n-                try {\n-                    securityManager.checkPermission(CREATE_TRANSPARENT_WINDOW_PERMISSION);\n-                } catch (final SecurityException e) {\n-                    return false;\n-                }\n-            }\n-\n-            return true;\n-        }\n-\n-        return supported;\n+        return isSupportedImpl(feature);\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/application\/PlatformImpl.java","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    \/\/ TODO: JDK-8344114: Consider removing this obsolete method\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/FontFactory.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -234,0 +234,1 @@\n+    \/\/ TODO: JDK-8344114: Consider removing this obsolete method\n@@ -239,1 +240,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -241,14 +241,1 @@\n-        if (System.getSecurityManager() == null) {\n-            return true;\n-        }\n-        File f = null;\n-        boolean hasPerm = false;\n-        try {\n-            f = Files.createTempFile(\"+JXF\", \".tmp\").toFile();\n-            f.delete();\n-            f = null;\n-            hasPerm = true;\n-        } catch (Throwable t) {\n-            \/* inc. any kind of SecurityException *\/\n-        }\n-        return hasPerm;\n+        return true;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/FontFileWriter.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import static com.sun.javafx.FXPermissions.LOAD_FONT_PERMISSION;\n@@ -1754,1 +1753,0 @@\n-    @SuppressWarnings(\"removal\")\n@@ -1756,9 +1754,1 @@\n-        try {\n-            SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                sm.checkPermission(LOAD_FONT_PERMISSION);\n-            }\n-            return true;\n-        } catch (SecurityException ex) {\n-            return false;\n-        }\n+        return true;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/font\/PrismFontFactory.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    \/\/ TODO: JDK-8344111: Consider removing this obsolete method\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/stage\/StageHelper.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.javafx.tk;\n-\n-import java.lang.reflect.Constructor;\n-import java.security.Permission;\n-import static com.sun.javafx.FXPermissions.ACCESS_CLIPBOARD_PERMISSION;\n-import java.security.AccessControlContext;\n-import java.security.AccessControlException;\n-\n-public class PermissionHelper {\n-\n-    private static boolean awtInitialized = false;\n-    private static Permission awtClipboardPermission;\n-\n-    \/\/ Method to get the AWT access clipboard permission. It should\n-    \/\/ only be called if the FXPermission check fails, since it will load\n-    \/\/ and initialize an AWT class from the java.desktop module.\n-    private static synchronized Permission getAWTClipboardPermission() {\n-        if (!awtInitialized) {\n-            \/\/ Use refelction to avoid hard dependency on AWT.\n-            \/\/ If the class cannot be loaded, then no fallback is possible, so\n-            \/\/ just set it to null\n-\n-            try {\n-                Class clazz = Class.forName(\"java.awt.AWTPermission\",\n-                        false, PermissionHelper.class.getClassLoader());\n-                \/\/ FIXME JIGSAW: add read edge\n-                Constructor c = clazz.getConstructor(String.class);\n-                awtClipboardPermission = (Permission) c.newInstance(\"accessClipboard\");\n-            } catch (Exception ex) {\n-                awtClipboardPermission = null;\n-            }\n-\n-            awtInitialized = true;\n-        }\n-\n-        return awtClipboardPermission;\n-    }\n-\n-    public static void checkClipboardPermission() {\n-        @SuppressWarnings(\"removal\")\n-        final SecurityManager securityManager = System.getSecurityManager();\n-\n-        \/\/ Always succeed if no security manager installed\n-        if (securityManager == null) return;\n-\n-        \/\/ Check for FXPermission, using AWTPermission as fallback for compatibility\n-        try {\n-            securityManager.checkPermission(ACCESS_CLIPBOARD_PERMISSION);\n-        } catch (SecurityException ex) {\n-            \/\/ Try fallback if available\n-            final Permission perm = getAWTClipboardPermission();\n-            if (perm == null) throw ex;\n-\n-            try {\n-                securityManager.checkPermission(perm);\n-            } catch (SecurityException ex2) {\n-                \/\/ Rethrow original exception\n-                throw ex;\n-            }\n-        }\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    public static void checkClipboardPermission(AccessControlContext context) {\n-        final SecurityManager securityManager = System.getSecurityManager();\n-\n-        \/\/ Always succeed if no security manager installed\n-        if (securityManager == null) return;\n-\n-        if (context == null) {\n-            throw new AccessControlException(\"AccessControlContext is null\");\n-        }\n-\n-        \/\/ Check for FXPermission, using AWTPermission as fallback for compatibility\n-        try {\n-            \/\/\n-            securityManager.checkPermission(ACCESS_CLIPBOARD_PERMISSION, context);\n-        } catch (SecurityException ex) {\n-            \/\/ Try fallback if available\n-            final Permission perm = getAWTClipboardPermission();\n-            if (perm == null) throw ex;\n-\n-            try {\n-                securityManager.checkPermission(perm, context);\n-            } catch (SecurityException ex2) {\n-                \/\/ Rethrow original exception\n-                throw ex;\n-            }\n-        }\n-    }\n-\n-    \/\/ Static helper class; do not construct an instance\n-    private PermissionHelper() {}\n-}\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/PermissionHelper.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -100,0 +100,1 @@\n+    \/\/ TODO: JDK-8344111: Consider removing this obsolete method\n@@ -122,0 +123,1 @@\n+    \/\/ TODO: JDK-8344111: Consider removing this obsolete method\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/GlassViewEventHandler.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.io.FilePermission;\n@@ -39,3 +38,0 @@\n-import java.net.MalformedURLException;\n-import java.net.SocketPermission;\n-import java.net.URL;\n@@ -63,1 +59,0 @@\n-import com.sun.javafx.tk.PermissionHelper;\n@@ -374,33 +369,1 @@\n-                    try {\n-                        @SuppressWarnings(\"removal\")\n-                        SecurityManager sm = System.getSecurityManager();\n-                        if (sm != null) {\n-                            @SuppressWarnings(\"removal\")\n-                            AccessControlContext context = getAccessControlContext();\n-                            URL u = new URL(url);\n-                            String protocol = u.getProtocol();\n-                            if (protocol.equalsIgnoreCase(\"jar\")) {\n-                                String file = u.getFile();\n-                                u = new URL(file);\n-                                protocol = u.getProtocol();\n-                            }\n-                            if (protocol.equalsIgnoreCase(\"file\")) {\n-                                FilePermission fp = new FilePermission(u.getFile(), \"read\");\n-                                sm.checkPermission(fp, context);\n-                            } else if (protocol.equalsIgnoreCase(\"ftp\") ||\n-                                       protocol.equalsIgnoreCase(\"http\") ||\n-                                       protocol.equalsIgnoreCase(\"https\")) {\n-                                int port = u.getPort();\n-                                String hoststr = (port == -1 ? u.getHost() : u.getHost() + \":\" + port);\n-                                SocketPermission sp = new SocketPermission(hoststr, \"connect\");\n-                                sm.checkPermission(sp, context);\n-                            } else {\n-                                PermissionHelper.checkClipboardPermission(context);\n-                            }\n-                        }\n-                        return (new Image(url));\n-                    } catch (MalformedURLException mue) {\n-                        return null;\n-                    } catch (SecurityException se) {\n-                        return null;\n-                    }\n+                    return (new Image(url));\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/QuantumClipboard.java","additions":1,"deletions":38,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.security.Permission;\n@@ -54,1 +53,0 @@\n-import static com.sun.javafx.FXPermissions.*;\n@@ -575,8 +573,1 @@\n-            if (hasPermission(SET_WINDOW_ALWAYS_ON_TOP_PERMISSION)) {\n-                platformWindow.setLevel(Level.FLOATING);\n-            } else {\n-                alwaysOnTop = false;\n-                if (stageListener != null) {\n-                    stageListener.changedAlwaysOnTop(alwaysOnTop);\n-                }\n-            }\n+            platformWindow.setLevel(Level.FLOATING);\n@@ -594,3 +585,2 @@\n-    \/\/ Return true if this stage is trusted for full screen - doesn't have a\n-    \/\/ security manager, or a permission check doesn't result in a security\n-    \/\/ exeception.\n+    \/\/ TODO: JDK-8344111: Consider removing this obsolete method\n+    \/\/ Return true if this stage is trusted for full screen (it always is)\n@@ -598,1 +588,1 @@\n-        return hasPermission(UNRESTRICTED_FULL_SCREEN_PERMISSION);\n+        return true;\n@@ -606,13 +596,1 @@\n-    private boolean hasPermission(Permission perm) {\n-        try {\n-            @SuppressWarnings(\"removal\")\n-            final SecurityManager sm = System.getSecurityManager();\n-            if (sm != null) {\n-                sm.checkPermission(perm, getAccessControlContext());\n-            }\n-            return true;\n-        } catch (SecurityException se) {\n-            return false;\n-        }\n-    }\n-\n+    \/\/ TODO: JDK-8344111: Consider removing this obsolete method\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/javafx\/tk\/quantum\/WindowStage.java","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -814,17 +814,0 @@\n-    \/*\n-     * Permissions were already checked when creating the job,\n-     * and when setting output file, but this is a final check\n-     * to be made before we start the underlying native job.\n-     *\/\n-    private void checkPermissions() {\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPrintJobAccess();\n-            String file = settings.getOutputFile();\n-            if (file != null && !file.isEmpty()) {\n-                security.checkWrite(file);\n-            }\n-        }\n-    }\n-\n@@ -853,1 +836,0 @@\n-            checkPermissions();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/com\/sun\/prism\/j2d\/print\/J2DPrinterJob.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import javafx.application.Application;\n@@ -39,2 +38,0 @@\n-import java.security.CodeSource;\n-import java.security.ProtectionDomain;\n@@ -182,56 +179,5 @@\n-            @SuppressWarnings(\"removal\")\n-            final SecurityManager sm = System.getSecurityManager();\n-            if (sm == null) {\n-                \/\/ If the SecurityManager is not null, then just look up the resource on the class-path.\n-                \/\/ If there is a SecurityManager, the URLClassPath getResource call will return null,\n-                \/\/ so fall through and create a URL from the code-source URI\n-                final ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n-                \/\/ FIXME: JIGSAW -- use Class.getResource if resource is in a module\n-                final URL resolved = contextClassLoader.getResource(resourcePath);\n-                return resolved;\n-            }\n-\n-            \/\/ check whether the path is file from our runtime jar\n-            try {\n-                \/\/ getProtectionDomain either throws a SecurityException or returns a non-null value\n-                final ProtectionDomain protectionDomain = Application.class.getProtectionDomain();\n-                \/\/ If we're running with a SecurityManager, then the ProtectionDomain will have a CodeSource\n-                final CodeSource codeSource = protectionDomain.getCodeSource();\n-                \/\/ The CodeSource location will be our runtime jar\n-                final URL rtJarURL = codeSource.getLocation();\n-\n-                final URI rtJarURI = rtJarURL.toURI();\n-\n-                String scheme = rtJarURI.getScheme();\n-                String rtJarPath = rtJarURI.getPath();\n-\n-                \/\/\n-                \/\/ Just because we're running with a SecurityManager doesn't mean the jfxrt jar path is\n-                \/\/ a jar: URL. But the code in StyleManager wants it to be. So if we have\n-                \/\/ file:\/blah\/lib\/jfxrt.jar make it jar:file:\/blah\/lib\/jfxrt.jar!\/\n-                \/\/\n-                \/\/ If the path doesn't end with .jar, then we are just dealing with a normal file: path\n-                \/\/\n-                if (\"file\".equals(scheme) && rtJarPath.endsWith(\".jar\")) {\n-                    if (\"file\".equals(scheme)) {\n-                        scheme = \"jar:file\";\n-                        rtJarPath = rtJarPath.concat(\"!\/\");\n-                    }\n-                }\n-                rtJarPath = rtJarPath.concat(resourcePath);\n-\n-                final String rtJarUserInfo = rtJarURI.getUserInfo();\n-                final String rtJarHost = rtJarURI.getHost();\n-                final int rtJarPort = rtJarURI.getPort();\n-\n-                \/\/\n-                \/\/ Put together a new URI from the pieces of rtJarURI. We cannot use resolve here since\n-                \/\/ the scheme and path may have been munged.\n-                \/\/\n-                URI resolved = new URI(scheme, rtJarUserInfo, rtJarHost, rtJarPort, rtJarPath, null, null);\n-                return resolved.toURL();\n-\n-            } catch (URISyntaxException | MalformedURLException ignored) {\n-                \/\/ Allow this method to return null so the caller will try to further resolve the path.\n-                \/\/ If nothing else, an error message will result when the converted URL is consumed.\n-            }\n+            \/\/ Look up the resource on the class-path.\n+            final ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n+            \/\/ FIXME: JIGSAW -- use Class.getResource if resource is in a module\n+            final URL resolved = contextClassLoader.getResource(resourcePath);\n+            return resolved;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/css\/converter\/URLConverter.java","additions":5,"deletions":59,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -71,5 +71,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPrintJobAccess();\n-        }\n@@ -82,5 +77,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPrintJobAccess();\n-        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/print\/Printer.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -112,5 +112,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPrintJobAccess();\n-        }\n@@ -134,5 +129,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPrintJobAccess();\n-        }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/print\/PrinterJob.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import com.sun.javafx.tk.PermissionHelper;\n@@ -190,6 +189,1 @@\n-        try {\n-            PermissionHelper.checkClipboardPermission();\n-            return getSystemClipboardImpl();\n-        } catch (final SecurityException e) {\n-            return getLocalClipboardImpl();\n-        }\n+        return getSystemClipboardImpl();\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/input\/Clipboard.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import com.sun.javafx.tk.PermissionHelper;\n@@ -41,5 +40,0 @@\n-    \/**\n-     * Whether access to the data requires a permission.\n-     *\/\n-    private boolean dataAccessRestricted = true;\n-\n@@ -50,8 +44,0 @@\n-    @Override\n-    Object getContentImpl(DataFormat dataFormat) {\n-        if (dataAccessRestricted) {\n-            PermissionHelper.checkClipboardPermission();\n-        }\n-        return super.getContentImpl(dataFormat);\n-    }\n-\n@@ -169,0 +155,1 @@\n+            \/\/ TODO: JDK-8344111: Consider removing this obsolete method\n@@ -171,1 +158,0 @@\n-                dragboard.dataAccessRestricted = restricted;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/input\/Dragboard.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import static com.sun.javafx.FXPermissions.CREATE_ROBOT_PERMISSION;\n-\n@@ -67,7 +65,0 @@\n-        \/\/ Ensure we have proper permission for creating a robot.\n-        @SuppressWarnings(\"removal\")\n-        final SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            sm.checkPermission(CREATE_ROBOT_PERMISSION);\n-        }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/robot\/Robot.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.io.FilePermission;\n@@ -458,11 +457,0 @@\n-            try {\n-                @SuppressWarnings(\"removal\")\n-                SecurityManager sm = System.getSecurityManager();\n-                if (sm != null) {\n-                    FilePermission filePermission =\n-                        new FilePermission(path, \"read\");\n-                    sm.checkPermission(filePermission);\n-                }\n-            } catch (Exception e) {\n-                return null;\n-            }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/scene\/text\/Font.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-import static com.sun.javafx.FXPermissions.CREATE_TRANSPARENT_WINDOW_PERMISSION;\n@@ -534,11 +533,1 @@\n-            try {\n-                @SuppressWarnings(\"removal\")\n-                final SecurityManager securityManager =\n-                        System.getSecurityManager();\n-                if (securityManager != null) {\n-                    securityManager.checkPermission(CREATE_TRANSPARENT_WINDOW_PERMISSION);\n-                }\n-                popupStyle = StageStyle.TRANSPARENT;\n-            } catch (final SecurityException e) {\n-                popupStyle = StageStyle.UNDECORATED;\n-            }\n+            popupStyle = StageStyle.TRANSPARENT;\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/PopupWindow.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-import static com.sun.javafx.FXPermissions.CREATE_TRANSPARENT_WINDOW_PERMISSION;\n@@ -287,0 +286,1 @@\n+    \/\/ TODO: JDK-8344111: Consider removing this obsolete method\n@@ -290,2 +290,1 @@\n-     * on top, regardless of the setting of the alwaysOnTop property, and\n-     * whether or not permissions are granted when the dialog is shown.\n+     * on top, regardless of the setting of the alwaysOnTop property.\n@@ -1129,12 +1128,0 @@\n-            if (stageStyle == StageStyle.TRANSPARENT) {\n-                @SuppressWarnings(\"removal\")\n-                final SecurityManager securityManager =\n-                        System.getSecurityManager();\n-                if (securityManager != null) {\n-                    try {\n-                        securityManager.checkPermission(CREATE_TRANSPARENT_WINDOW_PERMISSION);\n-                    } catch (final SecurityException e) {\n-                        stageStyle = StageStyle.UNDECORATED;\n-                    }\n-                }\n-            }\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/Stage.java","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-import static com.sun.javafx.FXPermissions.ACCESS_WINDOW_LIST_PERMISSION;\n@@ -228,6 +227,0 @@\n-        @SuppressWarnings(\"removal\")\n-        final SecurityManager securityManager = System.getSecurityManager();\n-        if (securityManager != null) {\n-            securityManager.checkPermission(ACCESS_WINDOW_LIST_PERMISSION);\n-        }\n-\n","filename":"modules\/javafx.graphics\/src\/main\/java\/javafx\/stage\/Window.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.security.Permission;\n@@ -231,4 +230,1 @@\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            group = (sm != null) ? sm.getThreadGroup()\n-                    : Thread.currentThread().getThreadGroup();\n+            group = Thread.currentThread().getThreadGroup();\n","filename":"modules\/javafx.web\/src\/main\/java\/com\/sun\/webkit\/network\/NetworkContext.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -192,6 +192,0 @@\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager securityManager = System.getSecurityManager();\n-        if (securityManager != null) {\n-            securityManager.checkConnect(host, port);\n-        }\n-\n@@ -414,4 +408,1 @@\n-            @SuppressWarnings(\"removal\")\n-            SecurityManager sm = System.getSecurityManager();\n-            group = (sm != null) ? sm.getThreadGroup()\n-                    : Thread.currentThread().getThreadGroup();\n+            group = Thread.currentThread().getThreadGroup();\n","filename":"modules\/javafx.web\/src\/main\/java\/com\/sun\/webkit\/network\/SocketStreamHandle.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"}]}