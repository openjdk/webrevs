{"files":[{"patch":"@@ -200,7 +200,0 @@\n-inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n-  return _top_frame.sp();\n-}\n-\n-inline void AnchorMark::anchor_mark_clear_pd() {\n-}\n-\n@@ -217,0 +210,31 @@\n+inline intptr_t* AnchorMark::anchor_mark_set_pd() {\n+  intptr_t* sp = _top_frame.sp();\n+  if (_top_frame.is_interpreted_frame()) {\n+    \/\/ In case the top frame is interpreted we need to set up the anchor using\n+    \/\/ the last_sp saved in the frame (remove possible alignment added while\n+    \/\/ thawing, see ThawBase::finish_thaw()). We also need to clear the last_sp\n+    \/\/ saved in the frame as it is not expected to be set in case we preempt again.\n+    _last_sp_from_frame = _top_frame.interpreter_frame_last_sp();\n+    assert(_last_sp_from_frame != nullptr, \"\");\n+    _top_frame.interpreter_frame_set_last_sp(nullptr);\n+    if (sp != _last_sp_from_frame) {\n+      _last_sp_from_frame[-1] = (intptr_t)_top_frame.pc();\n+      _last_sp_from_frame[-2] = (intptr_t)_top_frame.fp();\n+    }\n+    _is_interpreted = true;\n+    sp = _last_sp_from_frame;\n+  }\n+  return sp;\n+}\n+\n+inline void AnchorMark::anchor_mark_clear_pd() {\n+  if (_is_interpreted) {\n+    \/\/ Restore last_sp_from_frame and possibly overwritten pc.\n+    _top_frame.interpreter_frame_set_last_sp(_last_sp_from_frame);\n+    intptr_t* sp = _top_frame.sp();\n+    if (sp != _last_sp_from_frame) {\n+      sp[-1] = (intptr_t)_top_frame.pc();\n+    }\n+  }\n+}\n+\n@@ -317,2 +341,0 @@\n-\n-  log_develop_trace(continuations, preempt)(\"push_cleanup_continuation initial sp: \" INTPTR_FORMAT \" final sp: \" INTPTR_FORMAT, p2i(sp + 2 * frame::metadata_words), p2i(sp));\n@@ -323,2 +345,5 @@\n-  Unimplemented();\n-  return nullptr;\n+  frame enterSpecial = new_entry_frame();\n+  intptr_t* sp = enterSpecial.sp();\n+\n+  sp[-1] = (intptr_t)StubRoutines::cont_preempt_stub();\n+  return sp;\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":36,"deletions":11,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+    DEBUG_ONLY(Method* m = f.is_interpreted_frame() ? f.interpreter_frame_method() : f.cb()->as_nmethod()->method();)\n+    assert(m->is_object_wait0() || thread->interp_at_preemptable_vmcall_cnt() > 0,\n+           \"preemptable VM call not using call_VM_preemptable\");\n","filename":"src\/hotspot\/cpu\/riscv\/continuationHelper_riscv.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -521,0 +521,8 @@\n+#ifdef ASSERT\n+  Label not_preempted;\n+  ld(t0, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n+  beqz(t0, not_preempted);\n+  stop(\"remove_activation: should not have alternate return address set\");\n+  bind(not_preempted);\n+#endif \/* ASSERT *\/\n+\n@@ -1444,0 +1452,1 @@\n+                                             Label*   return_pc,\n@@ -1466,3 +1475,3 @@\n-                               entry_point, number_of_arguments,\n-                               check_exceptions);\n-\/\/ interpreter specific\n+                               return_pc, entry_point,\n+                               number_of_arguments, check_exceptions);\n+  \/\/ interpreter specific\n@@ -1473,4 +1482,6 @@\n-void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n-                                                    address entry_point,\n-                                                    Register arg_1) {\n-  assert(arg_1 == c_rarg1, \"\");\n+void InterpreterMacroAssembler::call_VM_preemptable_helper(Register oop_result,\n+                                                           address entry_point,\n+                                                           int number_of_arguments,\n+                                                           bool check_exceptions) {\n+  assert(InterpreterRuntime::is_preemptable_call(entry_point),\n+         \"VM call not preemptable, should use call_VM()\");\n@@ -1481,1 +1492,1 @@\n-    Label L;\n+    Label L1, L2;\n@@ -1483,3 +1494,9 @@\n-    beqz(t0, L);\n-    stop(\"Should not have alternate return address set\");\n-    bind(L);\n+    beqz(t0, L1);\n+    stop(\"call_VM_preemptable_helper: Should not have alternate return address set\");\n+    bind(L1);\n+    \/\/ We check this counter in patch_return_pc_with_preempt_stub() during freeze.\n+    incrementw(Address(xthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    lw(t0, Address(xthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    bgtz(t0, L2);\n+    stop(\"call_VM_preemptable_helper: should be > 0\");\n+    bind(L2);\n@@ -1493,3 +1510,2 @@\n-  la(t0, resume_pc);\n-  sd(t0, Address(xthread, JavaThread::last_Java_pc_offset()));\n-  call_VM_base(oop_result, noreg, noreg, entry_point, 1, false \/*check_exceptions*\/);\n+  \/\/ Note: call_VM_base will use resume_pc label to set last_Java_pc.\n+  call_VM_base(noreg, noreg, noreg, &resume_pc, entry_point, number_of_arguments, false \/*check_exceptions*\/);\n@@ -1499,0 +1515,11 @@\n+#ifdef ASSERT\n+  {\n+    Label L;\n+    decrementw(Address(xthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    lw(t0, Address(xthread, JavaThread::interp_at_preemptable_vmcall_cnt_offset()));\n+    bgez(t0, L);\n+    stop(\"call_VM_preemptable_helper: should be >= 0\");\n+    bind(L);\n+  }\n+#endif \/* ASSERT *\/\n+\n@@ -1510,0 +1537,45 @@\n+  if (check_exceptions) {\n+    \/\/ check for pending exceptions\n+    ld(t0, Address(xthread, in_bytes(Thread::pending_exception_offset())));\n+    Label ok;\n+    beqz(t0, ok);\n+    la(t1, RuntimeAddress(StubRoutines::forward_exception_entry()));\n+    jr(t1);\n+    bind(ok);\n+  }\n+\n+  \/\/ get oop result if there is one and reset the value in the thread\n+  if (oop_result->is_valid()) {\n+    get_vm_result_oop(oop_result, xthread);\n+  }\n+}\n+\n+static void pass_arg1(MacroAssembler* masm, Register arg) {\n+  if (c_rarg1 != arg) {\n+    masm->mv(c_rarg1, arg);\n+  }\n+}\n+\n+static void pass_arg2(MacroAssembler* masm, Register arg) {\n+  if (c_rarg2 != arg) {\n+    masm->mv(c_rarg2, arg);\n+  }\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                         address entry_point,\n+                                         Register arg_1,\n+                                         bool check_exceptions) {\n+  pass_arg1(this, arg_1);\n+  call_VM_preemptable_helper(oop_result, entry_point, 1, check_exceptions);\n+}\n+\n+void InterpreterMacroAssembler::call_VM_preemptable(Register oop_result,\n+                                         address entry_point,\n+                                         Register arg_1,\n+                                         Register arg_2,\n+                                         bool check_exceptions) {\n+  LP64_ONLY(assert_different_registers(arg_1, c_rarg2));\n+  pass_arg2(this, arg_2);\n+  pass_arg1(this, arg_1);\n+  call_VM_preemptable_helper(oop_result, entry_point, 2, check_exceptions);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":86,"deletions":14,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+                            Label*   return_pc,\n@@ -62,0 +63,1 @@\n+  \/\/ Use for vthread preemption\n@@ -64,1 +66,9 @@\n-                           Register arg_1);\n+                           Register arg_1,\n+                           bool check_exceptions = true);\n+\n+  void call_VM_preemptable(Register oop_result,\n+                           address entry_point,\n+                           Register arg_1,\n+                           Register arg_2,\n+                           bool check_exceptions = true);\n+\n@@ -67,0 +77,7 @@\n+ private:\n+  void call_VM_preemptable_helper(Register oop_result,\n+                                  address entry_point,\n+                                  int number_of_arguments,\n+                                  bool check_exceptions);\n+\n+ public:\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-  call_VM_base(oop_result, noreg, noreg, entry_point, number_of_arguments, check_exceptions);\n+  call_VM_base(oop_result, noreg, noreg, nullptr, entry_point, number_of_arguments, check_exceptions);\n@@ -287,1 +287,1 @@\n-  call_VM_base(oop_result, xthread, last_java_sp, entry_point, number_of_arguments, check_exceptions);\n+  call_VM_base(oop_result, xthread, last_java_sp, nullptr, entry_point, number_of_arguments, check_exceptions);\n@@ -410,4 +410,0 @@\n-static bool is_preemptable(address entry_point) {\n-  return entry_point == CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter);\n-}\n-\n@@ -417,0 +413,1 @@\n+                                  Label*   return_pc,\n@@ -424,0 +421,1 @@\n+\n@@ -443,6 +441,1 @@\n-  if (is_preemptable(entry_point)) {\n-    \/\/ skip setting last_pc since we already set it to desired value.\n-    set_last_Java_frame(last_java_sp, fp, noreg);\n-  } else {\n-    set_last_Java_frame(last_java_sp, fp, l, t0);\n-  }\n+  set_last_Java_frame(last_java_sp, fp, return_pc != nullptr ? *return_pc : l, t0);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+    Label*   return_pc,                \/\/ to set up last_Java_frame; use nullptr otherwise\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/smallRegisterMap_riscv.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,1 +113,0 @@\n-  InterpreterOopMap mask;\n@@ -115,6 +114,3 @@\n-  f.interpreted_frame_oop_map(&mask);\n-  return mask.num_oops()\n-        + 1 \/\/ for the mirror oop\n-        + (f.interpreter_frame_method()->is_native() ? 1 : 0) \/\/ temp oop slot\n-        + pointer_delta_as_int((intptr_t*)f.interpreter_frame_monitor_begin(),\n-              (intptr_t*)f.interpreter_frame_monitor_end()) \/ BasicObjectLock::size();\n+  InterpreterOopCount closure;\n+  f.oops_interpreted_do(&closure, map);\n+  return closure.count();\n","filename":"src\/hotspot\/cpu\/riscv\/stackChunkFrameStream_riscv.inline.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2196,1 +2196,1 @@\n-  __ call_VM(noreg, entry, temp);\n+  __ call_VM_preemptable(noreg, entry, temp);\n@@ -2243,1 +2243,1 @@\n-  __ call_VM(noreg, entry, temp);\n+  __ call_VM_preemptable(noreg, entry, temp);\n@@ -3591,1 +3591,1 @@\n-  call_VM(x10, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n+  __ call_VM_preemptable(x10, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -646,1 +646,1 @@\n-#if defined(AARCH64) || defined(AMD64)\n+#if defined(AARCH64) || defined(AMD64) || defined(RISCV64)\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -36,1 +36,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -44,1 +44,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -52,1 +52,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -60,1 +60,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -68,1 +68,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/KlassInit.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}