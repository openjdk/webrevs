{"files":[{"patch":"@@ -2222,0 +2222,86 @@\n+class jdk_internal_vm_ThreadLock: AllStatic {\n+  static bool _inited;\n+  static int _depth_offset;\n+  static int _typeOrdinal_offset;\n+  static int _obj_offset;\n+\n+  static void compute_offsets(InstanceKlass * klass, TRAPS) {\n+    JavaClasses::compute_offset(_depth_offset, klass, \"depth\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_typeOrdinal_offset, klass, \"typeOrdinal\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_obj_offset, klass, \"obj\", vmSymbols::object_signature(), false);\n+  }\n+public:\n+  static void init(InstanceKlass* klass, TRAPS) {\n+    if (!_inited) {\n+      compute_offsets(klass, CHECK);\n+      _inited = true;\n+    }\n+  }\n+\n+  static Handle allocate(InstanceKlass* klass, TRAPS) {\n+    init(klass, CHECK_NH);\n+    return klass->allocate_instance_handle(CHECK_NH);\n+  }\n+\n+  static void set_depth(oop thread_lock, int depth) {\n+    thread_lock->int_field_put(_depth_offset, depth);\n+  }\n+  static void set_type(oop thread_lock, int type_ordinal) {\n+    thread_lock->int_field_put(_typeOrdinal_offset, type_ordinal);\n+  }\n+  static void set_lock_object(oop thread_lock, oop obj) {\n+    thread_lock->obj_field_put(_obj_offset, obj);\n+  }\n+};\n+\n+bool jdk_internal_vm_ThreadLock::_inited = false;\n+int jdk_internal_vm_ThreadLock::_depth_offset;\n+int jdk_internal_vm_ThreadLock::_typeOrdinal_offset;\n+int jdk_internal_vm_ThreadLock::_obj_offset;\n+\n+class jdk_internal_vm_ThreadSnapshot: AllStatic {\n+  static bool _inited;\n+  static int _name_offset;\n+  static int _threadStatus_offset;\n+  static int _stackTrace_offset;\n+  static int _locks_offset;\n+\n+  static void compute_offsets(InstanceKlass* klass, TRAPS) {\n+    JavaClasses::compute_offset(_name_offset, klass, \"name\", vmSymbols::string_signature(), false);\n+    JavaClasses::compute_offset(_threadStatus_offset, klass, \"threadStatus\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_stackTrace_offset, klass, \"stackTrace\", vmSymbols::java_lang_StackTraceElement_array(), false);\n+    JavaClasses::compute_offset(_locks_offset, klass, \"locks\", vmSymbols::jdk_internal_vm_ThreadLock_array(), false);\n+  }\n+public:\n+  static void init(InstanceKlass* klass, TRAPS) {\n+    if (!_inited) {\n+      compute_offsets(klass, CHECK);\n+      _inited = true;\n+    }\n+  }\n+\n+  static Handle allocate(InstanceKlass* klass, TRAPS) {\n+    init(klass, CHECK_NH);\n+    return klass->allocate_instance_handle(CHECK_NH);\n+  }\n+\n+  static void set_name(oop snapshot, oop name) {\n+    snapshot->obj_field_put(_name_offset, name);\n+  }\n+  static void set_thread_status(oop snapshot, int status) {\n+    snapshot->int_field_put(_threadStatus_offset, status);\n+  }\n+  static void set_stack_trace(oop snapshot, oop trace) {\n+    snapshot->obj_field_put(_stackTrace_offset, trace);\n+  }\n+  static void set_locks(oop snapshot, oop locks) {\n+    snapshot->obj_field_put(_locks_offset, locks);\n+  }\n+};\n+\n+bool jdk_internal_vm_ThreadSnapshot::_inited = false;\n+int jdk_internal_vm_ThreadSnapshot::_name_offset;\n+int jdk_internal_vm_ThreadSnapshot::_threadStatus_offset;\n+int jdk_internal_vm_ThreadSnapshot::_stackTrace_offset;\n+int jdk_internal_vm_ThreadSnapshot::_locks_offset;\n+\n@@ -2300,12 +2386,0 @@\n-  \/\/ call static StackTraceElement[] of(StackTraceElement[] stackTrace)\n-  \/\/ to properly initialize STE.\n-  {\n-    JavaValue result(T_OBJECT);\n-    JavaCalls::call_static(&result,\n-                           ste_klass,\n-                           vmSymbols::java_lang_StackTraceElement_of_name(),\n-                           vmSymbols::java_lang_StackTraceElement_of_signature(),\n-                           trace,\n-                           CHECK_NULL);\n-    \/\/ the method return the same trace object\n-  }\n@@ -2319,10 +2393,1 @@\n-      oop o = lock_info->_obj;\n-      Handle lock_object = Handle(THREAD, o);\n-\n-      \/\/ TODO: allocate and fill in the VM\n-      JavaCallArguments args;\n-      args.push_int(lock_info->_depth);\n-      args.push_int(lock_info->_type);\n-      args.push_oop(lock_object);\n-      Handle lock = JavaCalls::construct_new_instance(lock_klass,\n-          vmSymbols::jdk_internal_vm_ThreadLock_ctor_signature(), &args, CHECK_NULL);\n+      Handle lock_object = Handle(THREAD, lock_info->_obj);\n@@ -2330,0 +2395,4 @@\n+      Handle lock = jdk_internal_vm_ThreadLock::allocate(lock_klass, CHECK_NULL);\n+      jdk_internal_vm_ThreadLock::set_depth(lock(), lock_info->_depth);\n+      jdk_internal_vm_ThreadLock::set_type(lock(), lock_info->_type);\n+      jdk_internal_vm_ThreadLock::set_lock_object(lock(), lock_object());\n@@ -2334,0 +2403,13 @@\n+  \/\/ call static StackTraceElement[] StackTraceElement.of(StackTraceElement[] stackTrace)\n+  \/\/ to properly initialize STE.\n+  {\n+    JavaValue result(T_OBJECT);\n+    JavaCalls::call_static(&result,\n+                           ste_klass,\n+                           vmSymbols::java_lang_StackTraceElement_of_name(),\n+                           vmSymbols::java_lang_StackTraceElement_of_signature(),\n+                           trace,\n+                           CHECK_NULL);\n+    \/\/ the method return the same trace object\n+  }\n+\n@@ -2343,8 +2425,5 @@\n-  \/\/ TODO: allocate and fill in the VM\n-  JavaCallArguments args;\n-  args.push_oop(trace);\n-  args.push_oop(locks);\n-  args.push_oop(thread_name);\n-  args.push_int((int)cl._thread_status);\n-  Handle snapshot = JavaCalls::construct_new_instance(InstanceKlass::cast(snapshot_klass),\n-      vmSymbols::jdk_internal_vm_ThreadSnapshot_ctor_signature(), &args, CHECK_NULL);\n+  Handle snapshot = jdk_internal_vm_ThreadSnapshot::allocate(InstanceKlass::cast(snapshot_klass), CHECK_NULL);\n+  jdk_internal_vm_ThreadSnapshot::set_name(snapshot(), thread_name());\n+  jdk_internal_vm_ThreadSnapshot::set_thread_status(snapshot(), (int)cl._thread_status);\n+  jdk_internal_vm_ThreadSnapshot::set_stack_trace(snapshot(), trace());\n+  jdk_internal_vm_ThreadSnapshot::set_locks(snapshot(), locks());\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":109,"deletions":30,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -750,1 +750,0 @@\n-  template(jdk_internal_vm_ThreadSnapshot_ctor_signature, \"([Ljava\/lang\/StackTraceElement;[Ljdk\/internal\/vm\/ThreadSnapshot$ThreadLock;Ljava\/lang\/String;I)V\") \\\n@@ -752,1 +751,1 @@\n-  template(jdk_internal_vm_ThreadLock_ctor_signature, \"(IILjava\/lang\/Object;)V\")                                  \\\n+  template(jdk_internal_vm_ThreadLock_array,       \"[Ljdk\/internal\/vm\/ThreadSnapshot$ThreadLock;\")                \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,11 +42,0 @@\n-    \/\/ called by the VM\n-    private ThreadSnapshot(StackTraceElement[] stackTrace,\n-                           ThreadLock[] locks,\n-                           String name,\n-                           int threadStatus) {\n-        this.stackTrace = stackTrace;\n-        this.locks = locks;\n-        this.name = name;\n-        this.threadStatus = threadStatus;\n-    }\n-\n@@ -61,3 +50,3 @@\n-        if (snapshot.locks == null) {\n-            snapshot.locks = EMPTY_LOCKS;\n-        }\n+        snapshot.locks = snapshot.locks == null\n+                         ? snapshot.locks = EMPTY_LOCKS\n+                         : ThreadLock.of(snapshot.locks);\n@@ -130,1 +119,1 @@\n-                .anyMatch(lock -> lock.type == LockType.LOCKED);\n+                .anyMatch(lock -> lock.type() == LockType.LOCKED);\n@@ -142,1 +131,1 @@\n-                .filter(lock -> lock.depth == depth\n+                .filter(lock -> lock.depth() == depth\n@@ -168,1 +157,1 @@\n-    private record ThreadLock(int depth, LockType type, Object obj) {\n+    private class ThreadLock {\n@@ -171,3 +160,20 @@\n-        \/\/ called by the VM\n-        private ThreadLock(int depth, int typeOrdinal, Object obj) {\n-            this(depth, lockTypeValues[typeOrdinal], obj);\n+        \/\/ set by the VM\n+        private int depth;\n+        private int typeOrdinal;\n+        private Object obj;\n+\n+        private LockType type;\n+\n+        static ThreadLock[] of(ThreadLock[] locks) {\n+            for (ThreadLock lock: locks) {\n+                lock.type = lockTypeValues[lock.typeOrdinal];\n+            }\n+            return locks;\n+        }\n+\n+        int depth() {\n+            return depth;\n+        }\n+\n+        LockType type() {\n+            return type;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadSnapshot.java","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"}]}