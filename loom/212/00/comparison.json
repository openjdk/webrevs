{"files":[{"patch":"@@ -86,1 +86,0 @@\n-    cmpxchgptr(hdr, disp_hdr, temp, t1, done, \/*fallthough*\/nullptr);\n@@ -88,0 +87,1 @@\n+    cmpxchgptr(hdr, disp_hdr, temp, t1, done, \/*fallthough*\/nullptr);\n@@ -109,0 +109,1 @@\n+\n@@ -111,0 +112,1 @@\n+    inc_held_monitor_count();\n@@ -113,1 +115,0 @@\n-  increment(Address(xthread, JavaThread::held_monitor_count_offset()));\n@@ -149,0 +150,1 @@\n+\n@@ -151,0 +153,1 @@\n+    dec_held_monitor_count();\n@@ -152,2 +155,0 @@\n-\n-  decrement(Address(xthread, JavaThread::held_monitor_count_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  bool _use_pop_on_epilogue;\n@@ -179,2 +180,7 @@\n-  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, return_state_t return_state=requires_return);\n-  void load_argument(int offset_in_words, Register reg);\n+  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments,\n+            return_state_t return_state, bool use_pop_on_epilogue);\n+\n+ public:\n+  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, bool use_pop_on_epilogue);\n+  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, return_state_t return_state);\n+  StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments);\n@@ -183,0 +189,2 @@\n+\n+  void load_argument(int offset_in_words, Register reg);\n@@ -191,1 +199,11 @@\n-  leave();\n+  \/\/ Avoid using a leave instruction when this frame may\n+  \/\/ have been frozen, since the current value of fp\n+  \/\/ restored from the stub would be invalid. We still\n+  \/\/ must restore the fp value saved on enter though.\n+  if (use_pop) {\n+    ld(fp, Address(sp));\n+    ld(ra, Address(sp, wordSize));\n+    addi(sp, sp, 2 * wordSize);\n+  } else {\n+    leave();\n+  }\n@@ -197,3 +215,3 @@\n-StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments, return_state_t return_state) {\n-  _sasm = sasm;\n-  _return_state = return_state;\n+StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments,\n+                     return_state_t return_state, bool use_pop_on_epilogue)\n+  : _sasm(sasm), _return_state(return_state), _use_pop_on_epilogue(use_pop_on_epilogue) {\n@@ -203,0 +221,11 @@\n+StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments,\n+                     bool use_pop_on_epilogue) :\n+  StubFrame(sasm, name, must_gc_arguments, requires_return, use_pop_on_epilogue) {}\n+\n+StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments,\n+                     return_state_t return_state) :\n+  StubFrame(sasm, name, must_gc_arguments, return_state, \/*use_pop_on_epilogue*\/false) {}\n+\n+StubFrame::StubFrame(StubAssembler* sasm, const char* name, bool must_gc_arguments) :\n+  StubFrame(sasm, name, must_gc_arguments, requires_return, \/*use_pop_on_epilogue*\/false) {}\n+\n@@ -209,1 +238,0 @@\n-\n@@ -211,6 +239,1 @@\n-  if (_return_state == requires_return) {\n-    __ epilogue();\n-  } else {\n-    __ should_not_reach_here();\n-  }\n-  _sasm = nullptr;\n+  __ epilogue(_use_pop_on_epilogue);\n@@ -271,0 +294,4 @@\n+  int sp_offset = cpu_reg_save_offsets[xthread->encoding()];\n+  oop_map->set_callee_saved(VMRegImpl::stack2reg(sp_offset),\n+                            xthread->as_VMReg());\n+\n@@ -359,0 +386,1 @@\n+\/\/ return: offset in 64-bit words.\n@@ -360,2 +388,6 @@\n-  Unimplemented();\n-  return 0;\n+  CodeBlob* cb = f.cb();\n+  assert(cb == Runtime1::blob_for(Runtime1::monitorenter_id) ||\n+         cb == Runtime1::blob_for(Runtime1::monitorenter_nofpu_id), \"must be\");\n+  assert(cb != nullptr && cb->is_runtime_stub(), \"invalid frame\");\n+  int offset = cpu_reg_save_offsets[xthread->encoding()];\n+  return offset \/ 2;   \/\/ SP offsets are in halfwords\n@@ -889,1 +921,1 @@\n-        StubFrame f(sasm, \"monitorenter\", dont_gc_arguments);\n+        StubFrame f(sasm, \"monitorenter\", dont_gc_arguments, \/*use_pop_on_epilogue*\/true);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_Runtime1_riscv.cpp","additions":48,"deletions":16,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -73,31 +73,0 @@\n-\n-int C2HandleAnonOMOwnerStub::max_size() const {\n-  \/\/ Max size of stub has been determined by testing with 0 without using RISC-V compressed\n-  \/\/ instruction-set extension, in which case C2CodeStubList::emit() will throw an assertion\n-  \/\/ and report the actual size that is needed.\n-  return 24 DEBUG_ONLY(+8);\n-}\n-\n-void C2HandleAnonOMOwnerStub::emit(C2_MacroAssembler& masm) {\n-  __ bind(entry());\n-  Register mon = monitor();\n-  Register t = tmp();\n-  assert(t != noreg, \"need tmp register\");\n-\n-  \/\/ Fix owner to be the current thread.\n-  __ mv(t, Address(xthread, JavaThread::lock_id_offset()));\n-  __ sd(t, Address(mon, ObjectMonitor::owner_offset()));\n-\n-  \/\/ Pop owner object from lock-stack.\n-  __ lwu(t, Address(xthread, JavaThread::lock_stack_top_offset()));\n-  __ subw(t, t, oopSize);\n-#ifdef ASSERT\n-  __ add(t0, xthread, t);\n-  __ sd(zr, Address(t0, 0));\n-#endif\n-  __ sw(t, Address(xthread, JavaThread::lock_stack_top_offset()));\n-\n-  __ j(continuation());\n-}\n-\n-#undef __\n","filename":"src\/hotspot\/cpu\/riscv\/c2_CodeStubs_riscv.cpp","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -76,4 +76,0 @@\n-  \/\/ Check for existing monitor\n-  test_bit(tmp, disp_hdr, exact_log2(markWord::monitor_value));\n-  bnez(tmp, object_has_monitor);\n-\n@@ -84,0 +80,5 @@\n+\n+    \/\/ Check for existing monitor\n+    test_bit(tmp, disp_hdr, exact_log2(markWord::monitor_value));\n+    bnez(tmp, object_has_monitor);\n+\n@@ -107,3 +108,3 @@\n-    \/\/ If (mark & lock_mask) == 0 and mark - sp < page_size, we are stack-locking and goto label locked,\n-    \/\/ hence we can store 0 as the displaced header in the box, which indicates that it is a\n-    \/\/ recursive lock.\n+    \/\/ If (mark & lock_mask) == 0 and mark - sp < page_size, we are stack-locking and goto label\n+    \/\/ locked, hence we can store 0 as the displaced header in the box, which indicates that it\n+    \/\/ is a recursive lock.\n@@ -118,0 +119,1 @@\n+\n@@ -119,1 +121,2 @@\n-  \/\/ otherwise m->owner may contain a thread or a stack address.\n+  \/\/ otherwise m->owner may contain a thread id, a stack address for LM_LEGACY,\n+  \/\/ the ANONYMOUS_OWNER constant for LM_LIGHTWEIGHT.\n@@ -122,2 +125,0 @@\n-  Register tid = flag;\n-  mv(tid, Address(xthread, JavaThread::lock_id_offset()));\n@@ -125,0 +126,2 @@\n+  Register tid = disp_hdr;\n+  ld(tid, Address(xthread, JavaThread::lock_id_offset()));\n@@ -140,0 +143,2 @@\n+  \/\/ Reload markWord from object into displaced_header.\n+  ld(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n@@ -144,1 +149,1 @@\n-  increment(Address(xthread, JavaThread::held_monitor_count_offset()), 1, tmp2Reg, tmp3Reg);\n+  inc_held_monitor_count();\n@@ -182,6 +187,4 @@\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    ld(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-    \/\/ If the displaced header is 0, we have a recursive unlock.\n-    beqz(disp_hdr, unlocked);\n+  if (LockingMode == LM_MONITOR) {\n+    j(slow_path);\n+  } else {\n+    assert(LockingMode == LM_LEGACY, \"must be\");\n@@ -190,0 +193,6 @@\n+  \/\/ Find the lock address and load the displaced header from the stack.\n+  ld(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+  \/\/ If the displaced header is 0, we have a recursive unlock.\n+  beqz(disp_hdr, unlocked);\n+\n@@ -195,13 +204,7 @@\n-  if (LockingMode == LM_MONITOR) {\n-    j(slow_path);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Check if it is still a light weight lock, this is true if we\n-    \/\/ see the stack address of the basicLock in the markWord of the\n-    \/\/ object.\n-\n-    cmpxchg(\/*memory address*\/oop, \/*expected value*\/box, \/*new value*\/disp_hdr, Assembler::int64,\n-            Assembler::relaxed, Assembler::rl, \/*result*\/tmp);\n-    beq(box, tmp, unlocked); \/\/ box == tmp if cas succeeds\n-    j(slow_path);\n-  }\n+  \/\/ Check if it is still a light weight lock, this is true if we\n+  \/\/ see the stack address of the basicLock in the markWord of the\n+  \/\/ object.\n+  cmpxchg(\/*memory address*\/oop, \/*expected value*\/box, \/*new value*\/disp_hdr, Assembler::int64,\n+          Assembler::relaxed, Assembler::rl, \/*result*\/tmp);\n+  beq(box, tmp, unlocked); \/\/ box == tmp if cas succeeds\n+  j(slow_path);\n@@ -239,1 +242,1 @@\n-  decrement(Address(xthread, JavaThread::held_monitor_count_offset()), 1, tmp1Reg, tmp2Reg);\n+  dec_held_monitor_count();\n@@ -259,1 +262,1 @@\n-                                              Register tmp1, Register tmp2, Register tmp3) {\n+                                              Register tmp1, Register tmp2, Register tmp3, Register tmp4) {\n@@ -264,1 +267,1 @@\n-  assert_different_registers(obj, box, tmp1, tmp2, tmp3, flag, t0);\n+  assert_different_registers(obj, box, tmp1, tmp2, tmp3, tmp4, flag, t0);\n@@ -335,0 +338,1 @@\n+\n@@ -381,4 +385,3 @@\n-    \/\/ CAS owner (null => current thread id).\n-    Register tid = flag;\n-    mv(tid, Address(xthread, JavaThread::lock_id_offset()));\n-    cmpxchg(\/*addr*\/ tmp2_owner_addr, \/*expected*\/ zr, \/*new*\/ tid, Assembler::int64,\n+    \/\/ CAS owner (null => current thread).\n+    ld(tmp4, Address(xthread, JavaThread::lock_id_offset()));\n+    cmpxchg(\/*addr*\/ tmp2_owner_addr, \/*expected*\/ zr, \/*new*\/ tmp4, Assembler::int64,\n@@ -389,1 +392,1 @@\n-    bne(tmp3_owner, tid, slow_path);\n+    bne(tmp3_owner, tmp4, slow_path);\n@@ -402,1 +405,0 @@\n-  increment(Address(xthread, JavaThread::held_monitor_count_offset()), 1, tmp2, tmp3);\n@@ -555,4 +557,3 @@\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    Register tid = flag;\n-    mv(tid, Address(xthread, JavaThread::lock_id_offset()));\n-    sd(tid, Address(tmp2_owner_addr));\n+    \/\/ Write the thread id to the owner field so the runtime knows the owner.\n+    ld(tmp3_t, Address(xthread, JavaThread::lock_id_offset()));\n+    sd(tmp3_t, Address(tmp2_owner_addr));\n@@ -569,1 +570,0 @@\n-  decrement(Address(xthread, JavaThread::held_monitor_count_offset()), 1, tmp2, tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+\n@@ -50,2 +51,4 @@\n-  void fast_lock_lightweight(Register object, Register box, Register tmp1, Register tmp2, Register tmp3);\n-  void fast_unlock_lightweight(Register object, Register box, Register tmp1, Register tmp2, Register tmp3);\n+  void fast_lock_lightweight(Register object, Register box,\n+                             Register tmp1, Register tmp2, Register tmp3, Register tmp4);\n+  void fast_unlock_lightweight(Register object, Register box,\n+                               Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -131,1 +131,3 @@\n-  Unimplemented();\n+  assert(*f.addr_at(frame::interpreter_frame_last_sp_offset) == 0, \"should be null for top frame\");\n+  intptr_t* lspp = f.addr_at(frame::interpreter_frame_last_sp_offset);\n+  *lspp = f.unextended_sp() - f.fp();\n@@ -154,0 +156,6 @@\n+  \/\/ The interpreter native wrapper code adds space in the stack equal to size_of_parameters()\n+  \/\/ after the fixed part of the frame. For wait0 this is equal to 3 words (this + long parameter).\n+  \/\/ We adjust by this size since otherwise the saved last sp will be less than the extended_sp.\n+  DEBUG_ONLY(Method* m = hf.interpreter_frame_method();)\n+  DEBUG_ONLY(int extra_space = m->is_object_wait0() ? m->size_of_parameters() : 0;)\n+\n@@ -157,1 +165,1 @@\n-  assert(hf.unextended_sp() >  (intptr_t*)hf.at(frame::interpreter_frame_extended_sp_offset), \"\");\n+  assert(hf.unextended_sp() + extra_space >  (intptr_t*)hf.at(frame::interpreter_frame_extended_sp_offset), \"\");\n@@ -210,1 +218,2 @@\n-  return frame(sp, sp, _cont.entryFP(), _cont.entryPC()); \/\/ TODO PERF: This finds code blob and computes deopt state\n+  \/\/ TODO PERF: This finds code blob and computes deopt state\n+  return frame(sp, sp, _cont.entryFP(), _cont.entryPC());\n@@ -222,1 +231,0 @@\n-    const int locals = hf.interpreter_frame_method()->max_locals();\n@@ -244,1 +252,1 @@\n-      int argsize = hf.compiled_frame_stack_argsize();\n+      int argsize = FKind::stack_argsize(hf);\n@@ -259,1 +267,1 @@\n-      fp = frame_sp + FKind::size(hf) - 2;\n+      fp = frame_sp + FKind::size(hf) - frame::sender_sp_offset;\n@@ -261,3 +269,5 @@\n-      fp = FKind::stub\n-        ? frame_sp + fsize - 2 \/\/ On RISCV, this value is used for the safepoint stub\n-        : *(intptr_t**)(hf.sp() - 2); \/\/ we need to re-read fp because it may be an oop and we might have fixed the frame.\n+      fp = FKind::stub || FKind::native\n+        \/\/ fp always points to the address above the pushed return pc. We need correct address.\n+        ? frame_sp + fsize - frame::sender_sp_offset\n+        \/\/ we need to re-read fp because it may be an oop and we might have fixed the frame.\n+        : *(intptr_t**)(hf.sp() - 2);\n@@ -265,1 +275,2 @@\n-    return frame(frame_sp, frame_sp, fp, hf.pc(), hf.cb(), hf.oop_map(), false); \/\/ TODO PERF : this computes deopt state; is it necessary?\n+    \/\/ TODO PERF : this computes deopt state; is it necessary?\n+    return frame(frame_sp, frame_sp, fp, hf.pc(), hf.cb(), hf.oop_map(), false);\n@@ -287,1 +298,12 @@\n-  Unimplemented();\n+  intptr_t* fp = caller_sp - frame::sender_sp_offset;\n+  patch_callee_link(f, fp);\n+}\n+\n+inline void ThawBase::fix_native_wrapper_return_pc_pd(frame& top) {\n+  \/\/ Nothing to do since the last pc saved before making the call to\n+  \/\/ JVM_MonitorWait() was already set to the correct resume pc. Just\n+  \/\/ do some sanity check.\n+#ifdef ASSERT\n+  Method* method = top.is_interpreted_frame() ? top.interpreter_frame_method() : CodeCache::find_blob(top.pc())->as_nmethod()->method();\n+  assert(method->is_object_wait0(), \"\");\n+#endif\n@@ -290,3 +312,43 @@\n-inline intptr_t* ThawBase::push_resume_adapter(frame& top, bool is_interpreted_frame) {\n-  Unimplemented();\n-  return nullptr;\n+inline intptr_t* ThawBase::push_resume_adapter(frame& top) {\n+  intptr_t* sp = top.sp();\n+  CodeBlob* cb = top.cb();\n+\n+#ifdef ASSERT\n+  RegisterMap map(JavaThread::current(),\n+                  RegisterMap::UpdateMap::skip,\n+                  RegisterMap::ProcessFrames::skip,\n+                  RegisterMap::WalkContinuation::skip);\n+  frame caller = top.sender(&map);\n+  intptr_t link_addr = (intptr_t)ContinuationHelper::Frame::callee_link_address(caller);\n+  assert(sp[-2] == link_addr + 16, \"wrong link address: \" INTPTR_FORMAT \" != \" INTPTR_FORMAT, sp[-2], link_addr + 16);\n+#endif\n+\n+  bool interpreted = top.is_interpreted_frame();\n+  if (!interpreted && cb->frame_size() == 2) {\n+    \/\/ C2 runtime stub case. For riscv64 the real size of the c2 runtime stub is 2 words bigger\n+    \/\/ than what we think, i.e. size is 4. This is because the _last_Java_sp is not set to the\n+    \/\/ sp right before making the call to the VM, but rather it is artificially set 2 words above\n+    \/\/ this real sp so that we can store the return address at last_Java_sp[-1], and keep this\n+    \/\/ property where we can retrieve the last_Java_pc from the last_Java_sp. But that means that\n+    \/\/ once we return to the runtime stub, the code will adjust sp according to this real size.\n+    \/\/ So we must adjust the frame size back here. We just copy ra\/fp again. These 2 top words\n+    \/\/ will be the ones popped in generate_cont_resume_compiler_adapter(). The other 2 words\n+    \/\/ will just be discarded once back in the runtime stub (add sp, sp, #0x10).\n+    sp -= 2;\n+    sp[-2] = sp[0];\n+    sp[-1] = sp[1];\n+  }\n+\n+  intptr_t* fp = sp - frame::sender_sp_offset;\n+  address pc = interpreted ? Interpreter::cont_resume_interpreter_adapter()\n+                           : StubRoutines::cont_resume_compiler_adapter();\n+\n+  sp -= frame::metadata_words;\n+  *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n+  *(intptr_t**)(sp - 2) = fp;\n+\n+  log_develop_trace(continuations, preempt)(\n+    \"push_resume_%s_adapter() initial sp: \" INTPTR_FORMAT \" final sp: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT,\n+    interpreted ? \"interpreter\" : \"compiler\", p2i(sp + frame::metadata_words), p2i(sp), p2i(fp));\n+\n+  return sp;\n@@ -296,2 +358,22 @@\n-  Unimplemented();\n-  return nullptr;\n+  frame enterSpecial = new_entry_frame();\n+  intptr_t* sp = enterSpecial.sp();\n+\n+  \/\/ First push the return barrier frame\n+  sp -= frame::metadata_words;\n+  sp[1] = (intptr_t)StubRoutines::cont_returnBarrier();\n+  sp[0] = (intptr_t)enterSpecial.fp();\n+\n+  \/\/ Now push the ObjectWaiter*\n+  sp -= frame::metadata_words;\n+  sp[1] = (intptr_t)chunk->object_waiter(); \/\/ alignment\n+  sp[0] = (intptr_t)chunk->object_waiter();\n+\n+  \/\/ Finally arrange to return to the resume_monitor_operation stub\n+  sp[-1] = (intptr_t)StubRoutines::cont_resume_monitor_operation();\n+  sp[-2] = (intptr_t)enterSpecial.fp();\n+\n+  log_develop_trace(continuations, preempt)(\n+    \"push_resume_monitor_operation initial sp: \" INTPTR_FORMAT \" final sp: \" INTPTR_FORMAT,\n+    p2i(sp + 2 * frame::metadata_words), p2i(sp));\n+\n+  return sp;\n@@ -307,0 +389,3 @@\n+  DEBUG_ONLY(Method* m = hf.interpreter_frame_method();)\n+  DEBUG_ONLY(int extra_space = m->is_object_wait0() ? m->size_of_parameters() : 0;) \/\/ see comment in relativize_interpreted_frame_metadata()\n+\n@@ -308,1 +393,1 @@\n-  assert((intptr_t*)f.at_relative(frame::interpreter_frame_extended_sp_offset) < f.unextended_sp(), \"\");\n+  assert((intptr_t*)f.at_relative(frame::interpreter_frame_extended_sp_offset) < f.unextended_sp() + extra_space, \"\");\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":102,"deletions":17,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -44,1 +44,13 @@\n-  Unimplemented();\n+  if (f.is_runtime_frame()) {\n+    \/\/ Unlike x86 we don't know where in the callee frame the return pc is\n+    \/\/ saved so we can't patch the return from the VM call back to Java.\n+    \/\/ Instead, we will patch the return from the runtime stub back to the\n+    \/\/ compiled method so that the target returns to the preempt cleanup stub.\n+    intptr_t* caller_sp = f.sp() + f.cb()->frame_size();\n+    caller_sp[-1] = (intptr_t)StubRoutines::cont_preempt_stub();\n+  } else {\n+    \/\/ The target will check for preemption once it returns to the interpreter\n+    \/\/ or the native wrapper code and will manually jump to the preempt stub.\n+    JavaThread *thread = JavaThread::current();\n+    thread->set_preempt_alternate_return(StubRoutines::cont_preempt_stub());\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/continuationHelper_riscv.inline.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -114,1 +114,2 @@\n-    interpreter_frame_oop_temp_offset                =  1, \/\/ for native calls only\n+    interpreter_frame_result_handler_offset          =  1, \/\/ for native calls only\n+    interpreter_frame_oop_temp_offset                =  0, \/\/ for native calls only\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -729,0 +729,1 @@\n+    push_cont_fastpath();\n@@ -732,0 +733,1 @@\n+    pop_cont_fastpath();\n@@ -760,1 +762,1 @@\n-      j(count);\n+      j(done);\n@@ -789,1 +791,5 @@\n-      beqz(swap_reg, count);\n+      bnez(swap_reg, slow_case);\n+\n+      bind(count);\n+      inc_held_monitor_count();\n+      j(done);\n@@ -795,0 +801,1 @@\n+    push_cont_fastpath();\n@@ -798,4 +805,1 @@\n-    j(done);\n-\n-    bind(count);\n-    increment(Address(xthread, JavaThread::held_monitor_count_offset()));\n+    pop_cont_fastpath();\n@@ -847,0 +851,1 @@\n+    Label slow_case;\n@@ -848,1 +853,0 @@\n-      Label slow_case;\n@@ -850,3 +854,1 @@\n-      j(count);\n-\n-      bind(slow_case);\n+      j(done);\n@@ -862,1 +864,5 @@\n-      cmpxchg_obj_header(swap_reg, header_reg, obj_reg, tmp_reg, count, \/*fallthrough*\/nullptr);\n+      cmpxchg_obj_header(swap_reg, header_reg, obj_reg, tmp_reg, count, &slow_case);\n+\n+      bind(count);\n+      dec_held_monitor_count();\n+      j(done);\n@@ -865,0 +871,1 @@\n+    bind(slow_case);\n@@ -869,5 +876,0 @@\n-    j(done);\n-\n-    bind(count);\n-    decrement(Address(xthread, JavaThread::held_monitor_count_offset()));\n-\n@@ -875,1 +877,0 @@\n-\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"interpreter\/interpreterRuntime.hpp\"\n@@ -241,0 +242,30 @@\n+void MacroAssembler::inc_held_monitor_count(Register tmp) {\n+  Address dst = Address(xthread, JavaThread::held_monitor_count_offset());\n+  ld(tmp, dst);\n+  addi(tmp, tmp, 1);\n+  sd(tmp, dst);\n+#ifdef ASSERT\n+  Label ok;\n+  test_bit(tmp, tmp, 63);\n+  beqz(tmp, ok);\n+  STOP(\"assert(held monitor count overflow)\");\n+  should_not_reach_here();\n+  bind(ok);\n+#endif\n+}\n+\n+void MacroAssembler::dec_held_monitor_count(Register tmp) {\n+  Address dst = Address(xthread, JavaThread::held_monitor_count_offset());\n+  ld(tmp, dst);\n+  addi(tmp, tmp, -1);\n+  sd(tmp, dst);\n+#ifdef ASSERT\n+  Label ok;\n+  test_bit(tmp, tmp, 63);\n+  beqz(tmp, ok);\n+  STOP(\"assert(held monitor count underflow)\");\n+  should_not_reach_here();\n+  bind(ok);\n+#endif\n+}\n+\n@@ -783,0 +814,1 @@\n+\n@@ -788,0 +820,10 @@\n+\n+  Label not_preempted;\n+  if (entry_point == CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter)) {\n+    ld(t0, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n+    beqz(t0, not_preempted);\n+    sd(zr, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n+    jr(t0);\n+  }\n+  bind(not_preempted);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -787,2 +787,5 @@\n-  void push_cont_fastpath(Register java_thread);\n-  void pop_cont_fastpath(Register java_thread);\n+  void push_cont_fastpath(Register java_thread = xthread);\n+  void pop_cont_fastpath(Register java_thread = xthread);\n+\n+  void inc_held_monitor_count(Register tmp = t0);\n+  void dec_held_monitor_count(Register tmp = t0);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -10556,1 +10556,2 @@\n-instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP box,\n+                                iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3, iRegPNoSp tmp4)\n@@ -10560,1 +10561,1 @@\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4);\n@@ -10563,1 +10564,1 @@\n-  format %{ \"fastlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3 #@cmpFastLockLightweight\" %}\n+  format %{ \"fastlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3,$tmp4 #@cmpFastLockLightweight\" %}\n@@ -10566,1 +10567,2 @@\n-    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n+    __ fast_lock_lightweight($object$$Register, $box$$Register,\n+                             $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register);\n@@ -10572,1 +10574,2 @@\n-instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n+instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP box,\n+                                  iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -10582,1 +10585,2 @@\n-    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n+    __ fast_unlock_lightweight($object$$Register, $box$$Register,\n+                               $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1041,0 +1041,1 @@\n+  ContinuationEntry::_thaw_call_pc_offset = __ pc() - start;\n@@ -1141,0 +1142,4 @@\n+void SharedRuntime::continuation_enter_cleanup(MacroAssembler* masm) {\n+  ::continuation_enter_cleanup(masm);\n+}\n+\n@@ -1703,0 +1708,3 @@\n+\n+      __ bind(count);\n+      __ inc_held_monitor_count();\n@@ -1708,3 +1716,0 @@\n-    __ bind(count);\n-    __ increment(Address(xthread, JavaThread::held_monitor_count_offset()));\n-\n@@ -1729,5 +1734,0 @@\n-  __ bind(native_return);\n-\n-  intptr_t return_pc = (intptr_t) __ pc();\n-  oop_maps->add_gc_map(return_pc - start, map);\n-\n@@ -1784,0 +1784,14 @@\n+  if (LockingMode != LM_LEGACY && method->is_object_wait0()) {\n+    \/\/ Check preemption for Object.wait()\n+    Label not_preempted;\n+    __ ld(t0, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n+    __ beqz(t0, not_preempted);\n+    __ sd(zr, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n+    __ jr(t0);\n+    __ bind(not_preempted);\n+  }\n+  __ bind(native_return);\n+\n+  intptr_t the_pc = (intptr_t) __ pc();\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n@@ -1807,1 +1821,1 @@\n-      __ decrement(Address(xthread, JavaThread::held_monitor_count_offset()));\n+      __ dec_held_monitor_count();\n@@ -1830,1 +1844,1 @@\n-      __ decrement(Address(xthread, JavaThread::held_monitor_count_offset()));\n+      __ dec_held_monitor_count();\n@@ -1834,1 +1848,0 @@\n-      __ decrement(Address(xthread, JavaThread::held_monitor_count_offset()));\n@@ -1903,0 +1916,3 @@\n+    \/\/ Force freeze slow path in case we try to preempt. We will pin the\n+    \/\/ vthread to the carrier (see FreezeBase::recurse_freeze_native_frame()).\n+    __ push_cont_fastpath();\n@@ -1904,0 +1920,1 @@\n+    __ pop_cont_fastpath();\n@@ -2434,2 +2451,1 @@\n-  Unimplemented();\n-  return nullptr;\n+  return xthread->as_VMReg();\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":29,"deletions":13,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+        + (f.interpreter_frame_method()->is_native() ? 1 : 0) \/\/ temp oop slot\n","filename":"src\/hotspot\/cpu\/riscv\/stackChunkFrameStream_riscv.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3868,0 +3868,97 @@\n+  address generate_cont_preempt_stub() {\n+    if (!Continuations::enabled()) return nullptr;\n+    StubCodeMark mark(this, \"StubRoutines\",\"Continuation preempt stub\");\n+    address start = __ pc();\n+\n+    __ reset_last_Java_frame(true);\n+\n+    \/\/ reset the flag\n+    __ sb(zr, Address(xthread, JavaThread::preempting_offset()));\n+\n+    \/\/ Set sp to enterSpecial frame and then remove it from the stack\n+    __ ld(sp, Address(xthread, JavaThread::cont_entry_offset()));\n+\n+    Label preemption_cancelled;\n+    __ lbu(t0, Address(xthread, JavaThread::preemption_cancelled_offset()));\n+    __ bnez(t0, preemption_cancelled);\n+\n+    \/\/ Remove enterSpecial frame from the stack and return to Continuation.run()\n+    SharedRuntime::continuation_enter_cleanup(_masm);\n+    __ leave();\n+    __ ret();\n+\n+    __ bind(preemption_cancelled);\n+    __ sb(zr, Address(xthread, JavaThread::preemption_cancelled_offset()));\n+    __ la(fp, Address(sp, checked_cast<int32_t>(ContinuationEntry::size() + 2 * wordSize)));\n+    __ la(t0, ExternalAddress((address)&ContinuationEntry::_thaw_call_pc));\n+    __ ld(t0, Address(t0));\n+    __ jr(t0);\n+\n+    return start;\n+  }\n+\n+  address generate_cont_resume_compiler_adapter() {\n+    if (!Continuations::enabled()) return nullptr;\n+    StubCodeMark mark(this, \"StubRoutines\", \"Continuation resume compiler adapter\");\n+    address start = __ pc();\n+\n+    \/\/ The safepoint blob handler expects that x18, being a callee saved register, will be preserved\n+    \/\/ during the VM call. It is used to check if the return pc back to Java was modified in the runtime.\n+    \/\/ If it wasn't, the return pc is modified so on return the poll instruction is skipped. Saving this\n+    \/\/ additional value of x18 during freeze will complicate too much the code, so we just zero it here\n+    \/\/ so that the comparison fails and the skip is not attempted in case the pc was indeed changed.\n+    __ movptr(x18, (uintptr_t)NULL_WORD);\n+\n+    __ leave();\n+    __ ret();\n+\n+    return start;\n+  }\n+\n+  address generate_cont_resume_monitor_operation() {\n+    if (!Continuations::enabled()) return nullptr;\n+    StubCodeMark mark(this, \"StubRoutines\",\"Continuation resume monitor operation\");\n+    address start = __ pc();\n+\n+    const Register waiter_reg = c_rarg1;\n+    __ ld(waiter_reg, Address(sp));\n+    __ addi(sp, sp, 2 * wordSize);\n+\n+#ifdef ASSERT\n+    { Label L;\n+      __ bnez(waiter_reg, L);\n+      __ stop(\"ObjectMonitor to use is null\");\n+      __ bind(L);\n+    }\n+#endif \/\/ ASSERT\n+\n+    __ set_last_Java_frame(sp, fp, ra);\n+    __ mv(c_rarg0, xthread);\n+    __ rt_call(CAST_FROM_FN_PTR(address, SharedRuntime::resume_monitor_operation));\n+    __ reset_last_Java_frame(true);\n+\n+    Label failAcquire;\n+    __ lbu(t0, Address(xthread, JavaThread::preempting_offset()));\n+    __ bnez(t0, failAcquire);\n+    \/\/ We have the lock now, just return to caller (we will actually hit the\n+    \/\/ return barrier to thaw more frames)\n+\n+    \/\/ ThawBase::push_resume_monitor_operation set things up so that\n+    \/\/ SP now points to {fp, ra}.\n+    __ ld(fp, Address(sp));\n+    __ ld(ra, Address(sp, wordSize));\n+    __ addi(sp, sp, 2 * wordSize);\n+    __ ret();\n+\n+    __ bind(failAcquire);\n+    __ sb(\/*false*\/zr, Address(xthread, JavaThread::preempting_offset()));\n+    \/\/ Set sp to enterSpecial frame\n+    __ ld(sp, Address(xthread, JavaThread::cont_entry_offset()));\n+    \/\/ Remove enterSpecial frame from the stack and return to Continuation.run()\n+    SharedRuntime::continuation_enter_cleanup(_masm);\n+    __ leave();\n+    __ ret();\n+\n+    return start;\n+  }\n+\n@@ -5887,0 +5984,3 @@\n+    StubRoutines::_cont_preempt_stub     = generate_cont_preempt_stub();\n+    StubRoutines::_cont_resume_monitor_operation = generate_cont_resume_monitor_operation();\n+    StubRoutines::_cont_resume_compiler_adapter  = generate_cont_resume_compiler_adapter();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":100,"deletions":0,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -543,1 +543,31 @@\n-  return nullptr;\n+  if (!Continuations::enabled()) return nullptr;\n+  address start = __ pc();\n+\n+  \/\/ Restore fp first since we need it to restore rest of registers\n+  __ leave();\n+\n+  \/\/ Restore constant pool cache\n+  __ ld(xcpool, Address(fp, frame::interpreter_frame_cache_offset * wordSize));\n+\n+  \/\/ Restore Java expression stack pointer\n+  __ ld(t0, Address(fp, frame::interpreter_frame_last_sp_offset * wordSize));\n+  __ shadd(esp, t0, fp, t0, Interpreter::logStackElementSize);\n+  \/\/ and NULL it as marker that esp is now tos until next java call\n+  __ sd(zr, Address(fp, frame::interpreter_frame_last_sp_offset * wordSize));\n+\n+  \/\/ Restore machine SP\n+  __ ld(t0, Address(fp, frame::interpreter_frame_extended_sp_offset * wordSize));\n+  __ shadd(sp, t0, fp, t0, LogBytesPerWord);\n+\n+  \/\/ Prepare for adjustment on return to call_VM_leaf_base()\n+  __ ld(xmethod, Address(fp, frame::interpreter_frame_method_offset * wordSize));\n+  __ addi(sp, sp, -2 * wordSize);\n+  __ sd(t0, Address(sp));\n+  __ sd(xmethod, Address(sp, 8));\n+\n+  \/\/ Restore dispatch\n+  __ la(xdispatch, ExternalAddress((address)Interpreter::dispatch_table()));\n+\n+  __ ret();\n+\n+  return start;\n@@ -1100,0 +1130,2 @@\n+  __ sd(x10, Address(fp, frame::interpreter_frame_result_handler_offset * wordSize));\n+\n@@ -1136,2 +1168,3 @@\n-  \/\/ It is enough that the pc() points into the right code\n-  \/\/ segment. It does not have to be the correct return pc.\n+  \/\/ Set the last Java PC in the frame anchor to be the return address from\n+  \/\/ the call to the native method: this will allow the debugger to\n+  \/\/ generate an accurate stack trace.\n@@ -1159,0 +1192,2 @@\n+  __ push_cont_fastpath();\n+\n@@ -1161,1 +1196,3 @@\n-  __ bind(native_return);\n+\n+  __ pop_cont_fastpath();\n+\n@@ -1227,0 +1264,17 @@\n+  if (LockingMode != LM_LEGACY) {\n+    \/\/ Check preemption for Object.wait()\n+    Label not_preempted;\n+    __ ld(t0, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n+    __ beqz(t0, not_preempted);\n+    __ sd(zr, Address(xthread, JavaThread::preempt_alternate_return_offset()));\n+    __ jr(t0);\n+    __ bind(native_return);\n+    \/\/ On resume we need to set up stack as expected\n+    __ push(dtos);\n+    __ push(ltos);\n+    __ bind(not_preempted);\n+  } else {\n+    \/\/ any pc will do so just use this one for LM_LEGACY to keep code together.\n+    __ bind(native_return);\n+  }\n+\n@@ -1245,0 +1299,1 @@\n+    __ ld(result_handler, Address(fp, frame::interpreter_frame_result_handler_offset * wordSize));\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":59,"deletions":4,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -3907,0 +3907,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2985,1 +2985,1 @@\n-#ifdef AARCH64\n+#if defined (AARCH64) || defined (RISCV64)\n@@ -2988,1 +2988,1 @@\n-        \/\/ adjustment on aarch64 (see push_preempt_rerun_adapter()).\n+        \/\/ adjustment on aarch64 and riscv64 (see push_resume_adapter()).\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1361,1 +1361,1 @@\n-#if defined(AMD64) || defined (AARCH64)\n+#if defined(AMD64) || defined (AARCH64) || defined (RISCV64)\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-        return is_virtual && !isBoundVThread && !legacyLockingMode && (Platform.isX64() || Platform.isAArch64());\n+        return is_virtual && !isBoundVThread && !legacyLockingMode && (Platform.isX64() || Platform.isAArch64() || Platform.isRISCV64());\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/StopThreadTest\/StopThreadTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -36,1 +36,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -45,1 +45,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -54,1 +54,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -63,1 +63,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -72,1 +72,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -81,1 +81,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -90,1 +90,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -107,1 +107,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -116,1 +116,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorEnterExit.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -36,1 +36,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -45,1 +45,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -54,1 +54,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -63,1 +63,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -72,1 +72,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -81,1 +81,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -90,1 +90,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -107,1 +107,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -116,1 +116,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/MonitorWaitNotify.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n@@ -35,1 +35,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch==\"riscv64\"\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/LotsOfContendedMonitorEnter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -283,1 +283,1 @@\n-        if (Platform.isX64() || Platform.isAArch64()) return;\n+        if (Platform.isX64() || Platform.isAArch64() || Platform.isRISCV64()) return;\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Basic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -476,1 +476,1 @@\n-        return traceHas(Op.PIN::contains) && (legacyLockingMode() || !(Platform.isX64() || Platform.isAArch64()));\n+        return traceHas(Op.PIN::contains) && (legacyLockingMode() || !(Platform.isX64() || Platform.isAArch64() || Platform.isRISCV64()));\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Fuzz.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}