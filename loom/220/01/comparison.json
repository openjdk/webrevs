{"files":[{"patch":"@@ -1881,1 +1881,8 @@\n-  enum { \/\/ should be synced with jdk.internal.vm.ThreadSnapshot.ThreadLock constants\n+  \/\/ should be synced with jdk.internal.vm.ThreadSnapshot.OwnedLockType constants\n+  enum OwnedLockType {\n+    ELIMINATED_SCALAR_REPLACED = 0,\n+    ELIMINATED_MONITOR = 1,\n+    LOCKED = 2,\n+  };\n+  \/\/ should be synced with jdk.internal.vm.ThreadSnapshot.BlockerLockType constants\n+  enum BlockerLockType {\n@@ -1883,7 +1890,2 @@\n-    ELIMINATED_SCALAR_REPLACED = 1,\n-    ELIMINATED_MONITOR = 2,\n-    LOCKED = 3,\n-    WAITING_TO_LOCK = 4,\n-    WAITING_ON = 5,\n-    WAITING_TO_RELOCK = 6,\n-    OWNABLE_SYNCHRONIZER = 7,\n+    WAITING_TO_LOCK = 1,\n+    WAITING_ON = 2,\n@@ -1894,1 +1896,5 @@\n-  oop _obj;\n+  OopHandle _obj;\n+\n+  LockInfo(int depth, OwnedLockType type, OopHandle obj) : _depth(depth), _type(type), _obj(obj) {}\n+  LockInfo(BlockerLockType type, OopHandle obj): _depth(0), _type(type), _obj(obj) {}\n+  LockInfo() : _depth(-1), _type(0), _obj(nullptr) {}\n@@ -1896,2 +1902,3 @@\n-  LockInfo(int depth, int type, oop obj) : _depth(depth), _type(type), _obj(obj) {}\n-  LockInfo() : _depth(0), _type(0), _obj(nullptr) {}\n+  bool is_empty() const {\n+    return _obj.is_empty();\n+  }\n@@ -1902,0 +1909,1 @@\n+  JavaThread* _calling_thread;\n@@ -1909,3 +1917,1 @@\n-  oop _name;\n-  bool _with_locks;\n-  bool _found_first_lock;\n+  OopHandle _name;\n@@ -1913,0 +1919,2 @@\n+  LockInfo _blocker;\n+  OopHandle _blocker_owner;\n@@ -1914,2 +1922,4 @@\n-  GetThreadSnapshotClosure(Handle java_thread, JavaThread* thread, bool with_locks) :\n-      HandshakeClosure(\"GetThreadSnapshotClosure\"), _java_thread(java_thread), _thread(thread),\n+  GetThreadSnapshotClosure(JavaThread* calling_thread, Handle java_thread, JavaThread* thread) :\n+      HandshakeClosure(\"GetThreadSnapshotClosure\"),\n+      _calling_thread(calling_thread),\n+      _java_thread(java_thread), _thread(thread),\n@@ -1919,1 +1929,1 @@\n-      _with_locks(with_locks), _found_first_lock(false), _locks(nullptr) { }\n+      _locks(nullptr), _blocker(), _blocker_owner(nullptr) { }\n@@ -1923,0 +1933,1 @@\n+    _name.release(Universe::vm_global());\n@@ -1924,0 +1935,3 @@\n+      for (int i = 0; i < _locks->length(); i++) {\n+        _locks->at(i)._obj.release(Universe::vm_global());\n+      }\n@@ -1926,0 +1940,2 @@\n+    _blocker._obj.release(Universe::vm_global());\n+    _blocker_owner.release(Universe::vm_global());\n@@ -1936,0 +1952,1 @@\n+private:\n@@ -1939,4 +1956,1 @@\n-    if (depth == 0 && !_found_first_lock) {\n-      \/\/ See javaVFrame::print_lock_info_on() for some other cases:\n-      \/\/ \"waiting to re-lock in wait\", \"waiting on the Class initialization monitor\".\n-\n+    if (depth == 0 && _blocker.is_empty()) {\n@@ -1949,1 +1963,1 @@\n-          _locks->push(LockInfo(depth, LockInfo::WAITING_ON, nullptr));\n+          _blocker = LockInfo(LockInfo::WAITING_ON, OopHandle());\n@@ -1951,1 +1965,0 @@\n-          int type = LockInfo::WAITING_ON;\n@@ -1955,4 +1968,1 @@\n-            if (_thread_status == JavaThreadStatus::BLOCKED_ON_MONITOR_ENTER) {\n-              type = LockInfo::WAITING_TO_RELOCK;;\n-            }\n-            _locks->push(LockInfo(depth, type, o()));\n+            _blocker = LockInfo(LockInfo::WAITING_ON, OopHandle(Universe::vm_global(), o()));\n@@ -1961,1 +1971,0 @@\n-        _found_first_lock = true;\n@@ -1965,1 +1974,1 @@\n-          _locks->push(LockInfo(depth, LockInfo::PARKING_TO_WAIT, park_blocker));\n+          _blocker = LockInfo(LockInfo::PARKING_TO_WAIT, OopHandle(Universe::vm_global(), park_blocker));\n@@ -1967,4 +1976,2 @@\n-            oop owner = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(park_blocker);\n-            if (owner != nullptr) {\n-              _locks->push(LockInfo(depth, LockInfo::OWNABLE_SYNCHRONIZER, owner));\n-            }\n+            oop blocker_owner = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(park_blocker);\n+            _blocker_owner = OopHandle(Universe::vm_global(), blocker_owner);\n@@ -1972,1 +1979,0 @@\n-          _found_first_lock = true;\n@@ -1984,1 +1990,1 @@\n-            _locks->push(LockInfo(depth, LockInfo::ELIMINATED_SCALAR_REPLACED, k->klass_holder()));\n+            _locks->push(LockInfo(depth, LockInfo::ELIMINATED_SCALAR_REPLACED, OopHandle(Universe::vm_global(), k->klass_holder())));\n@@ -1986,3 +1992,3 @@\n-            Handle obj(current, monitor->owner());\n-            if (obj() != nullptr) {\n-              _locks->push(LockInfo(depth, LockInfo::ELIMINATED_MONITOR, obj()));\n+            oop owner = monitor->owner();\n+            if (owner != nullptr) {\n+              _locks->push(LockInfo(depth, LockInfo::ELIMINATED_MONITOR, OopHandle(Universe::vm_global(), owner)));\n@@ -1995,1 +2001,0 @@\n-          int type = LockInfo::LOCKED;\n@@ -1997,1 +2002,1 @@\n-          if (depth == 0 && !_found_first_lock) {\n+          if (depth == 0 && _blocker.is_empty()) {\n@@ -2013,1 +2018,2 @@\n-                type = LockInfo::WAITING_TO_LOCK;\n+                _blocker = LockInfo(LockInfo::WAITING_TO_LOCK, OopHandle(Universe::vm_global(), monitor->owner()));\n+                continue; \/\/ go to next monitor\n@@ -2017,3 +2023,1 @@\n-          _locks->push(LockInfo(depth, type, monitor->owner()));\n-\n-          _found_first_lock = true;\n+          _locks->push(LockInfo(depth, LockInfo::LOCKED, OopHandle(Universe::vm_global(), monitor->owner())));\n@@ -2025,0 +2029,1 @@\n+public:\n@@ -2026,1 +2031,2 @@\n-    if (!Thread::current()->is_Java_thread()) {\n+    Thread* current = Thread::current();\n+    if (!current->is_Java_thread()) {\n@@ -2045,1 +2051,1 @@\n-    _name = java_lang_Thread::name(_java_thread());\n+    _name = OopHandle(Universe::vm_global(), java_lang_Thread::name(_java_thread()));\n@@ -2066,1 +2072,2 @@\n-    ResourceMark rm(Thread::current());\n+    ResourceMark rm(current);\n+    HandleMark hm(current);\n@@ -2075,4 +2082,1 @@\n-\n-    if (_with_locks) {\n-      _locks = new (mtInternal) GrowableArray<LockInfo>(init_length, mtInternal);\n-    }\n+    _locks = new (mtInternal) GrowableArray<LockInfo>(init_length, mtInternal);\n@@ -2082,1 +2086,1 @@\n-        ? vframeStream(_thread, false, false, walk_cont)\n+        ? vframeStream(_thread, false, true, walk_cont)\n@@ -2088,3 +2092,3 @@\n-      if (_with_locks) {\n-        detect_locks(vfst.asJavaVFrame(), total_count);\n-      }\n+\n+      detect_locks(vfst.asJavaVFrame(), total_count);\n+\n@@ -2247,1 +2251,1 @@\n-  static Handle allocate(InstanceKlass* klass, TRAPS) {\n+  static Handle create(InstanceKlass* klass, int depth, int type_ordinal, OopHandle obj, TRAPS) {\n@@ -2249,11 +2253,5 @@\n-    return klass->allocate_instance_handle(CHECK_NH);\n-  }\n-\n-  static void set_depth(oop thread_lock, int depth) {\n-    thread_lock->int_field_put(_depth_offset, depth);\n-  }\n-  static void set_type(oop thread_lock, int type_ordinal) {\n-    thread_lock->int_field_put(_typeOrdinal_offset, type_ordinal);\n-  }\n-  static void set_lock_object(oop thread_lock, oop obj) {\n-    thread_lock->obj_field_put(_obj_offset, obj);\n+    Handle result = klass->allocate_instance_handle(CHECK_NH);\n+    result->int_field_put(_depth_offset, depth);\n+    result->int_field_put(_typeOrdinal_offset, type_ordinal);\n+    result->obj_field_put(_obj_offset, obj.resolve());\n+    return result;\n@@ -2274,0 +2272,2 @@\n+  static int _blockerLock_offset;\n+  static int _blockerOwner_offset;\n@@ -2280,0 +2280,2 @@\n+    JavaClasses::compute_offset(_blockerLock_offset, klass, \"blockerLock\", vmSymbols::jdk_internal_vm_ThreadLock_signature(), false);\n+    JavaClasses::compute_offset(_blockerOwner_offset, klass, \"blockerOwner\", vmSymbols::object_signature(), false);\n@@ -2306,0 +2308,6 @@\n+  static void set_blocker_lock(oop snapshot, oop lock) {\n+    snapshot->obj_field_put(_blockerLock_offset, lock);\n+  }\n+  static void set_blocker_owner(oop snapshot, oop owner) {\n+    snapshot->obj_field_put(_blockerOwner_offset, owner);\n+  }\n@@ -2313,0 +2321,2 @@\n+int jdk_internal_vm_ThreadSnapshot::_blockerLock_offset;\n+int jdk_internal_vm_ThreadSnapshot::_blockerOwner_offset;\n@@ -2314,2 +2324,2 @@\n-oop java_lang_Thread::get_thread_snapshot(jobject jthread, bool with_locks, TRAPS) {\n-  ThreadsListHandle tlh(JavaThread::current());\n+oop java_lang_Thread::get_thread_snapshot(jobject jthread, TRAPS) {\n+  ThreadsListHandle tlh(THREAD);\n@@ -2356,1 +2366,1 @@\n-  GetThreadSnapshotClosure cl(java_thread, thread, with_locks);\n+  GetThreadSnapshotClosure cl(THREAD, java_thread, thread);\n@@ -2366,2 +2376,2 @@\n-  \/\/ Handle thread name\n-  Handle thread_name(THREAD, cl._name);\n+  \/\/ all info is collected, can enable transitions.\n+  transition_disabler.reset();\n@@ -2369,1 +2379,1 @@\n-  \/\/ Convert to StackTraceElement array\n+  \/\/ StackTrace\n@@ -2376,9 +2386,0 @@\n-  int max_locks = cl._locks != nullptr ? cl._locks->length() : 0;\n-\n-  InstanceKlass* lock_klass = nullptr;\n-  if (with_locks) {\n-    Symbol* sym = vmSymbols::jdk_internal_vm_ThreadLock();\n-    Klass* k = SystemDictionary::resolve_or_fail(sym, true, CHECK_NULL);\n-    lock_klass = InstanceKlass::cast(k);\n-  }\n-\n@@ -2393,0 +2394,5 @@\n+  \/\/ Locks\n+  Symbol* lock_sym = vmSymbols::jdk_internal_vm_ThreadLock();\n+  Klass* lock_k = SystemDictionary::resolve_or_fail(lock_sym, true, CHECK_NULL);\n+  InstanceKlass* lock_klass = InstanceKlass::cast(lock_k);\n+\n@@ -2394,11 +2400,7 @@\n-  int lock_index = 0;\n-  if (with_locks && max_locks > 0) {\n-    locks = oopFactory::new_objArray_handle(lock_klass, max_locks, CHECK_NULL);\n-    for (int n = 0; n < max_locks; n++) {\n-      LockInfo* lock_info = cl._locks->adr_at(lock_index++);\n-      Handle lock_object = Handle(THREAD, lock_info->_obj);\n-\n-      Handle lock = jdk_internal_vm_ThreadLock::allocate(lock_klass, CHECK_NULL);\n-      jdk_internal_vm_ThreadLock::set_depth(lock(), lock_info->_depth);\n-      jdk_internal_vm_ThreadLock::set_type(lock(), lock_info->_type);\n-      jdk_internal_vm_ThreadLock::set_lock_object(lock(), lock_object());\n+  if (cl._locks != nullptr && cl._locks->length() > 0) {\n+    locks = oopFactory::new_objArray_handle(lock_klass, cl._locks->length(), CHECK_NULL);\n+    for (int n = 0; n < cl._locks->length(); n++) {\n+      LockInfo* lock_info = cl._locks->adr_at(n);\n+\n+      Handle lock = jdk_internal_vm_ThreadLock::create(lock_klass,\n+        lock_info->_depth, lock_info->_type, lock_info->_obj, CHECK_NULL);\n@@ -2422,2 +2424,6 @@\n-  \/\/ all oops are handled, can enable transitions.\n-  transition_disabler.reset();\n+  Handle blocker_lock;\n+  if (!cl._blocker.is_empty()) {\n+    blocker_lock = jdk_internal_vm_ThreadLock::create(lock_klass,\n+      0, cl._blocker._type, cl._blocker._obj, CHECK_NULL);\n+  }\n+\n@@ -2432,1 +2438,1 @@\n-  jdk_internal_vm_ThreadSnapshot::set_name(snapshot(), thread_name());\n+  jdk_internal_vm_ThreadSnapshot::set_name(snapshot(), cl._name.resolve());\n@@ -2436,0 +2442,2 @@\n+  jdk_internal_vm_ThreadSnapshot::set_blocker_lock(snapshot(), blocker_lock());\n+  jdk_internal_vm_ThreadSnapshot::set_blocker_owner(snapshot(), cl._blocker_owner.resolve());\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":104,"deletions":96,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-  static oop get_thread_snapshot(jobject jthread, bool with_locks, TRAPS);\n+  static oop get_thread_snapshot(jobject jthread, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -750,0 +750,1 @@\n+  template(jdk_internal_vm_ThreadLock_signature,   \"Ljdk\/internal\/vm\/ThreadSnapshot$ThreadLock;\")                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-JVM_CreateThreadSnapshot(JNIEnv* env, jobject thread, jboolean withLocks);\n+JVM_CreateThreadSnapshot(JNIEnv* env, jobject thread);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2964,2 +2964,2 @@\n-JVM_ENTRY(jobject, JVM_CreateThreadSnapshot(JNIEnv* env, jobject jthread, jboolean withLocks))\n-  oop snapshot = java_lang_Thread::get_thread_snapshot(jthread, withLocks != JNI_FALSE, THREAD);\n+JVM_ENTRY(jobject, JVM_CreateThreadSnapshot(JNIEnv* env, jobject jthread))\n+  oop snapshot = java_lang_Thread::get_thread_snapshot(jthread, THREAD);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+    \/\/ filled by VM\n@@ -40,0 +41,1 @@\n+    \/\/ owned monitors\n@@ -41,0 +43,6 @@\n+    \/\/ an object the thread is blocked\/waiting on, converted to ThreadBlocker by ThreadSnapshot.of()\n+    private ThreadLock blockerLock;\n+    private Object blockerOwner;\n+\n+    \/\/ set by ThreadSnapshot.of()\n+    private ThreadBlocker blocker;\n@@ -46,1 +54,1 @@\n-        ThreadSnapshot snapshot = create(thread, true);\n+        ThreadSnapshot snapshot = create(thread);\n@@ -53,0 +61,2 @@\n+        snapshot.blocker = snapshot.blockerLock == null ? null : ThreadBlocker.of(snapshot.blockerLock);\n+        snapshot.blockerLock = null; \/\/ release blockerLock\n@@ -82,3 +92,1 @@\n-        return findLockObject(0, LockType.PARKING_TO_WAIT)\n-                .findAny()\n-                .orElse(null);\n+        return getBlocker(BlockerLockType.PARKING_TO_WAIT);\n@@ -91,3 +99,1 @@\n-        return findLockObject(0, LockType.OWNABLE_SYNCHRONIZER)\n-                .findAny()\n-                .orElse(null);\n+        return parkBlocker() != null ? blockerOwner : null;\n@@ -104,3 +110,1 @@\n-        return findLockObject(0, LockType.WAITING_TO_LOCK)\n-                .findAny()\n-                .orElse(null);\n+        return getBlocker(BlockerLockType.WAITING_TO_LOCK);\n@@ -118,3 +122,1 @@\n-        return findLockObject(0, LockType.WAITING_ON)\n-                .findAny()\n-                .orElse(null);\n+        return getBlocker(BlockerLockType.WAITING_ON);\n@@ -128,1 +130,1 @@\n-                .anyMatch(lock -> lock.type() == LockType.LOCKED);\n+                .anyMatch(lock -> lock.type() == OwnedLockType.LOCKED);\n@@ -135,1 +137,1 @@\n-        return findLockObject(depth, LockType.LOCKED);\n+        return findLockObject(depth, OwnedLockType.LOCKED);\n@@ -138,1 +140,1 @@\n-    private Stream<Object> findLockObject(int depth, LockType type) {\n+    private Stream<Object> findLockObject(int depth, OwnedLockType type) {\n@@ -146,0 +148,4 @@\n+    private Object getBlocker(BlockerLockType type) {\n+        return blocker != null && blocker.type == type ? blocker.obj : null;\n+    }\n+\n@@ -156,3 +162,1 @@\n-    private enum LockType {\n-        \/\/ Park blocker\n-        PARKING_TO_WAIT,\n+    private enum OwnedLockType {\n@@ -163,0 +167,5 @@\n+    }\n+\n+    private enum BlockerLockType {\n+        \/\/ Park blocker\n+        PARKING_TO_WAIT,\n@@ -164,0 +173,1 @@\n+        \/\/ Object.wait()\n@@ -165,3 +175,0 @@\n-        WAITING_TO_RELOCK,\n-        \/\/ No corresponding stack frame, depth is always == -1\n-        OWNABLE_SYNCHRONIZER\n@@ -174,1 +181,1 @@\n-        private static final LockType[] lockTypeValues = LockType.values(); \/\/ cache\n+        private static final OwnedLockType[] lockTypeValues = OwnedLockType.values(); \/\/ cache\n@@ -178,0 +185,1 @@\n+        \/\/ type depends on the lock type: OwnedLockType for owned monitors, BlockerLockType for ThreadBlocker\n@@ -181,1 +189,2 @@\n-        private LockType type;\n+        \/\/ set by ThreadLock.of(), not used by ThreadBlocker\n+        private OwnedLockType type;\n@@ -194,1 +203,1 @@\n-        LockType type() {\n+        OwnedLockType type() {\n@@ -199,1 +208,1 @@\n-            if (type == LockType.ELIMINATED_SCALAR_REPLACED) {\n+            if (type == OwnedLockType.ELIMINATED_SCALAR_REPLACED) {\n@@ -207,1 +216,9 @@\n-    private static native ThreadSnapshot create(Thread thread, boolean withLocks);\n+    private record ThreadBlocker(BlockerLockType type, Object obj) {\n+        private static final BlockerLockType[] lockTypeValues = BlockerLockType.values(); \/\/ cache\n+\n+        static ThreadBlocker of(ThreadLock blockerLock) {\n+            return new ThreadBlocker(lockTypeValues[blockerLock.typeOrdinal], blockerLock.obj);\n+        }\n+    }\n+\n+    private static native ThreadSnapshot create(Thread thread);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadSnapshot.java","additions":44,"deletions":27,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-Java_jdk_internal_vm_ThreadSnapshot_create(JNIEnv *env, jclass cls, jobject thread, jboolean withLocks)\n+Java_jdk_internal_vm_ThreadSnapshot_create(JNIEnv *env, jclass cls, jobject thread)\n@@ -35,1 +35,1 @@\n-  return JVM_CreateThreadSnapshot(env, thread, withLocks);\n+  return JVM_CreateThreadSnapshot(env, thread);\n","filename":"src\/java.base\/share\/native\/libjava\/ThreadSnapshot.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}