{"files":[{"patch":"@@ -1880,10 +1880,17 @@\n-struct LockInfo {\n-  enum { \/\/ should be synced with jdk.internal.vm.ThreadSnapshot.ThreadLock constants\n-    PARKING_TO_WAIT = 0,\n-    ELIMINATED_SCALAR_REPLACED = 1,\n-    ELIMINATED_MONITOR = 2,\n-    LOCKED = 3,\n-    WAITING_TO_LOCK = 4,\n-    WAITING_ON = 5,\n-    WAITING_TO_RELOCK = 6,\n-    OWNABLE_SYNCHRONIZER = 7,\n+class GetThreadSnapshotClosure : public HandshakeClosure {\n+public:\n+  struct OwnedLock {\n+    \/\/ should be synced with ordinals of jdk.internal.vm.ThreadSnapshot.OwnedLockType enum\n+    enum Type {\n+      NOTHING = -1,\n+      ELIMINATED_SCALAR_REPLACED = 0,\n+      ELIMINATED_MONITOR = 1,\n+      LOCKED = 2,\n+    };\n+\n+    int _depth;\n+    Type _type;\n+    OopHandle _obj;\n+\n+    OwnedLock(int depth, Type type, OopHandle obj): _depth(depth), _type(type), _obj(obj) {}\n+    OwnedLock(): _depth(0), _type(NOTHING), _obj(nullptr) {}\n@@ -1892,3 +1899,8 @@\n-  int _depth;\n-  int _type;\n-  oop _obj;\n+  struct Blocker {\n+    \/\/ should be synced with ordinals of jdk.internal.vm.ThreadSnapshot.BlockerLockType enum\n+    enum Type {\n+      NOTHING = -1,\n+      PARK_BLOCKER = 0,\n+      WAITING_TO_LOCK = 1,\n+      WAITING_ON = 2,\n+    };\n@@ -1896,3 +1908,10 @@\n-  LockInfo(int depth, int type, oop obj) : _depth(depth), _type(type), _obj(obj) {}\n-  LockInfo() : _depth(0), _type(0), _obj(nullptr) {}\n-};\n+    Type _type;\n+    OopHandle _obj;\n+\n+    Blocker(Type type, OopHandle obj): _type(type), _obj(obj) {}\n+    Blocker(): _type(NOTHING), _obj(nullptr) {}\n+\n+    bool is_empty() const {\n+      return _type == NOTHING;\n+    }\n+  };\n@@ -1900,2 +1919,0 @@\n-class GetThreadSnapshotClosure : public HandshakeClosure {\n-public:\n@@ -1909,7 +1926,8 @@\n-  oop _name;\n-  bool _with_locks;\n-  bool _found_first_lock;\n-  GrowableArray<LockInfo>* _locks;\n-\n-  GetThreadSnapshotClosure(Handle java_thread, JavaThread* thread, bool with_locks) :\n-      HandshakeClosure(\"GetThreadSnapshotClosure\"), _java_thread(java_thread), _thread(thread),\n+  OopHandle _name;\n+  GrowableArray<OwnedLock>* _locks;\n+  Blocker _blocker;\n+  OopHandle _blocker_owner;\n+\n+  GetThreadSnapshotClosure(JavaThread* calling_thread, Handle java_thread, JavaThread* thread) :\n+      HandshakeClosure(\"GetThreadSnapshotClosure\"),\n+      _java_thread(java_thread), _thread(thread),\n@@ -1919,1 +1937,1 @@\n-      _with_locks(with_locks), _found_first_lock(false), _locks(nullptr) { }\n+      _locks(nullptr), _blocker(), _blocker_owner(nullptr) { }\n@@ -1923,0 +1941,1 @@\n+    _name.release(Universe::vm_global());\n@@ -1924,0 +1943,3 @@\n+      for (int i = 0; i < _locks->length(); i++) {\n+        _locks->at(i)._obj.release(Universe::vm_global());\n+      }\n@@ -1926,0 +1948,2 @@\n+    _blocker._obj.release(Universe::vm_global());\n+    _blocker_owner.release(Universe::vm_global());\n@@ -1936,0 +1960,1 @@\n+private:\n@@ -1939,4 +1964,1 @@\n-    if (depth == 0 && !_found_first_lock) {\n-      \/\/ See javaVFrame::print_lock_info_on() for some other cases:\n-      \/\/ \"waiting to re-lock in wait\", \"waiting on the Class initialization monitor\".\n-\n+    if (depth == 0 && _blocker.is_empty()) {\n@@ -1947,0 +1969,1 @@\n+        OopHandle lock_object;\n@@ -1948,4 +1971,1 @@\n-        if (locs->is_empty()) {\n-          _locks->push(LockInfo(depth, LockInfo::WAITING_ON, nullptr));\n-        } else {\n-          int type = LockInfo::WAITING_ON;\n+        if (!locs->is_empty()) {\n@@ -1955,16 +1975,1 @@\n-            if (_thread_status == JavaThreadStatus::BLOCKED_ON_MONITOR_ENTER) {\n-              type = LockInfo::WAITING_TO_RELOCK;;\n-            }\n-            _locks->push(LockInfo(depth, type, o()));\n-          }\n-        }\n-        _found_first_lock = true;\n-      } else {\n-        oop park_blocker = java_lang_Thread::park_blocker(_java_thread());\n-        if (park_blocker != nullptr) {\n-          _locks->push(LockInfo(depth, LockInfo::PARKING_TO_WAIT, park_blocker));\n-          if (park_blocker->is_a(vmClasses::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {\n-            oop owner = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(park_blocker);\n-            if (owner != nullptr) {\n-              _locks->push(LockInfo(depth, LockInfo::OWNABLE_SYNCHRONIZER, owner));\n-            }\n+            lock_object = OopHandle(Universe::vm_global(), o());\n@@ -1972,1 +1977,0 @@\n-          _found_first_lock = true;\n@@ -1974,0 +1978,2 @@\n+\n+        _blocker = Blocker(Blocker::WAITING_ON, lock_object);\n@@ -1984,1 +1990,1 @@\n-            _locks->push(LockInfo(depth, LockInfo::ELIMINATED_SCALAR_REPLACED, k->klass_holder()));\n+            _locks->push(OwnedLock(depth, OwnedLock::ELIMINATED_SCALAR_REPLACED, OopHandle(Universe::vm_global(), k->klass_holder())));\n@@ -1986,3 +1992,3 @@\n-            Handle obj(current, monitor->owner());\n-            if (obj() != nullptr) {\n-              _locks->push(LockInfo(depth, LockInfo::ELIMINATED_MONITOR, obj()));\n+            oop owner = monitor->owner();\n+            if (owner != nullptr) {\n+              _locks->push(OwnedLock(depth, OwnedLock::ELIMINATED_MONITOR, OopHandle(Universe::vm_global(), owner)));\n@@ -1995,1 +2001,0 @@\n-          int type = LockInfo::LOCKED;\n@@ -1997,1 +2002,1 @@\n-          if (depth == 0 && !_found_first_lock) {\n+          if (depth == 0 && _blocker.is_empty()) {\n@@ -2013,1 +2018,2 @@\n-                type = LockInfo::WAITING_TO_LOCK;\n+                _blocker = Blocker(Blocker::WAITING_TO_LOCK, OopHandle(Universe::vm_global(), monitor->owner()));\n+                continue; \/\/ go to next monitor\n@@ -2017,3 +2023,1 @@\n-          _locks->push(LockInfo(depth, type, monitor->owner()));\n-\n-          _found_first_lock = true;\n+          _locks->push(OwnedLock(depth, OwnedLock::LOCKED, OopHandle(Universe::vm_global(), monitor->owner())));\n@@ -2025,0 +2029,1 @@\n+public:\n@@ -2026,1 +2031,2 @@\n-    if (!Thread::current()->is_Java_thread()) {\n+    Thread* current = Thread::current();\n+    if (!current->is_Java_thread()) {\n@@ -2045,1 +2051,1 @@\n-    _name = java_lang_Thread::name(_java_thread());\n+    _name = OopHandle(Universe::vm_global(), java_lang_Thread::name(_java_thread()));\n@@ -2066,1 +2072,11 @@\n-    ResourceMark rm(Thread::current());\n+    oop park_blocker = java_lang_Thread::park_blocker(_java_thread());\n+    if (park_blocker != nullptr) {\n+      _blocker = Blocker(Blocker::PARK_BLOCKER, OopHandle(Universe::vm_global(), park_blocker));\n+      if (park_blocker->is_a(vmClasses::java_util_concurrent_locks_AbstractOwnableSynchronizer_klass())) {\n+        oop blocker_owner = java_util_concurrent_locks_AbstractOwnableSynchronizer::get_owner_threadObj(park_blocker);\n+        _blocker_owner = OopHandle(Universe::vm_global(), blocker_owner);\n+      }\n+    }\n+\n+    ResourceMark rm(current);\n+    HandleMark hm(current);\n@@ -2075,4 +2091,1 @@\n-\n-    if (_with_locks) {\n-      _locks = new (mtInternal) GrowableArray<LockInfo>(init_length, mtInternal);\n-    }\n+    _locks = new (mtInternal) GrowableArray<OwnedLock>(init_length, mtInternal);\n@@ -2082,1 +2095,1 @@\n-        ? vframeStream(_thread, false, false, walk_cont)\n+        ? vframeStream(_thread, false, true, walk_cont)\n@@ -2088,3 +2101,3 @@\n-      if (_with_locks) {\n-        detect_locks(vfst.asJavaVFrame(), total_count);\n-      }\n+\n+      detect_locks(vfst.asJavaVFrame(), total_count);\n+\n@@ -2247,1 +2260,1 @@\n-  static Handle allocate(InstanceKlass* klass, TRAPS) {\n+  static Handle create(InstanceKlass* klass, int depth, int type_ordinal, OopHandle obj, TRAPS) {\n@@ -2249,11 +2262,5 @@\n-    return klass->allocate_instance_handle(CHECK_NH);\n-  }\n-\n-  static void set_depth(oop thread_lock, int depth) {\n-    thread_lock->int_field_put(_depth_offset, depth);\n-  }\n-  static void set_type(oop thread_lock, int type_ordinal) {\n-    thread_lock->int_field_put(_typeOrdinal_offset, type_ordinal);\n-  }\n-  static void set_lock_object(oop thread_lock, oop obj) {\n-    thread_lock->obj_field_put(_obj_offset, obj);\n+    Handle result = klass->allocate_instance_handle(CHECK_NH);\n+    result->int_field_put(_depth_offset, depth);\n+    result->int_field_put(_typeOrdinal_offset, type_ordinal);\n+    result->obj_field_put(_obj_offset, obj.resolve());\n+    return result;\n@@ -2272,0 +2279,1 @@\n+  static int _carrierThread_offset;\n@@ -2274,0 +2282,3 @@\n+  static int _blockerTypeOrdinal_offset;\n+  static int _blockerObject_offset;\n+  static int _blockerOwner_offset;\n@@ -2278,0 +2289,1 @@\n+    JavaClasses::compute_offset(_carrierThread_offset, klass, \"carrierThread\", vmSymbols::thread_signature(), false);\n@@ -2280,0 +2292,3 @@\n+    JavaClasses::compute_offset(_blockerTypeOrdinal_offset, klass, \"blockerTypeOrdinal\", vmSymbols::int_signature(), false);\n+    JavaClasses::compute_offset(_blockerObject_offset, klass, \"blockerObject\", vmSymbols::object_signature(), false);\n+    JavaClasses::compute_offset(_blockerOwner_offset, klass, \"blockerOwner\", vmSymbols::object_signature(), false);\n@@ -2300,0 +2315,3 @@\n+  static void set_carrier_thread(oop snapshot, oop carrier_thread) {\n+    snapshot->obj_field_put(_carrierThread_offset, carrier_thread);\n+  }\n@@ -2306,0 +2324,7 @@\n+  static void set_blocker(oop snapshot, int type_ordinal, oop lock) {\n+    snapshot->int_field_put(_blockerTypeOrdinal_offset, type_ordinal);\n+    snapshot->obj_field_put(_blockerObject_offset, lock);\n+  }\n+  static void set_blocker_owner(oop snapshot, oop owner) {\n+    snapshot->obj_field_put(_blockerOwner_offset, owner);\n+  }\n@@ -2311,0 +2336,1 @@\n+int jdk_internal_vm_ThreadSnapshot::_carrierThread_offset;\n@@ -2313,0 +2339,3 @@\n+int jdk_internal_vm_ThreadSnapshot::_blockerTypeOrdinal_offset;\n+int jdk_internal_vm_ThreadSnapshot::_blockerObject_offset;\n+int jdk_internal_vm_ThreadSnapshot::_blockerOwner_offset;\n@@ -2314,2 +2343,2 @@\n-oop java_lang_Thread::get_thread_snapshot(jobject jthread, bool with_locks, TRAPS) {\n-  ThreadsListHandle tlh(JavaThread::current());\n+oop java_lang_Thread::get_thread_snapshot(jobject jthread, TRAPS) {\n+  ThreadsListHandle tlh(THREAD);\n@@ -2342,1 +2371,1 @@\n-\n+  Handle carrier_thread;\n@@ -2347,1 +2376,1 @@\n-    oop carrier_thread = java_lang_VirtualThread::carrier_thread(java_thread());\n+    carrier_thread = Handle(THREAD, java_lang_VirtualThread::carrier_thread(java_thread()));\n@@ -2349,1 +2378,1 @@\n-      thread = java_lang_Thread::thread(carrier_thread);\n+      thread = java_lang_Thread::thread(carrier_thread());\n@@ -2356,1 +2385,1 @@\n-  GetThreadSnapshotClosure cl(java_thread, thread, with_locks);\n+  GetThreadSnapshotClosure cl(THREAD, java_thread, thread);\n@@ -2366,2 +2395,2 @@\n-  \/\/ Handle thread name\n-  Handle thread_name(THREAD, cl._name);\n+  \/\/ all info is collected, can enable transitions.\n+  transition_disabler.reset();\n@@ -2369,1 +2398,1 @@\n-  \/\/ Convert to StackTraceElement array\n+  \/\/ StackTrace\n@@ -2376,9 +2405,0 @@\n-  int max_locks = cl._locks != nullptr ? cl._locks->length() : 0;\n-\n-  InstanceKlass* lock_klass = nullptr;\n-  if (with_locks) {\n-    Symbol* sym = vmSymbols::jdk_internal_vm_ThreadLock();\n-    Klass* k = SystemDictionary::resolve_or_fail(sym, true, CHECK_NULL);\n-    lock_klass = InstanceKlass::cast(k);\n-  }\n-\n@@ -2393,0 +2413,5 @@\n+  \/\/ Locks\n+  Symbol* lock_sym = vmSymbols::jdk_internal_vm_ThreadLock();\n+  Klass* lock_k = SystemDictionary::resolve_or_fail(lock_sym, true, CHECK_NULL);\n+  InstanceKlass* lock_klass = InstanceKlass::cast(lock_k);\n+\n@@ -2394,11 +2419,7 @@\n-  int lock_index = 0;\n-  if (with_locks && max_locks > 0) {\n-    locks = oopFactory::new_objArray_handle(lock_klass, max_locks, CHECK_NULL);\n-    for (int n = 0; n < max_locks; n++) {\n-      LockInfo* lock_info = cl._locks->adr_at(lock_index++);\n-      Handle lock_object = Handle(THREAD, lock_info->_obj);\n-\n-      Handle lock = jdk_internal_vm_ThreadLock::allocate(lock_klass, CHECK_NULL);\n-      jdk_internal_vm_ThreadLock::set_depth(lock(), lock_info->_depth);\n-      jdk_internal_vm_ThreadLock::set_type(lock(), lock_info->_type);\n-      jdk_internal_vm_ThreadLock::set_lock_object(lock(), lock_object());\n+  if (cl._locks != nullptr && cl._locks->length() > 0) {\n+    locks = oopFactory::new_objArray_handle(lock_klass, cl._locks->length(), CHECK_NULL);\n+    for (int n = 0; n < cl._locks->length(); n++) {\n+      GetThreadSnapshotClosure::OwnedLock* lock_info = cl._locks->adr_at(n);\n+\n+      Handle lock = jdk_internal_vm_ThreadLock::create(lock_klass,\n+        lock_info->_depth, lock_info->_type, lock_info->_obj, CHECK_NULL);\n@@ -2422,5 +2443,2 @@\n-  \/\/ all oops are handled, can enable transitions.\n-  transition_disabler.reset();\n-\n-  Symbol* snapshot_name = vmSymbols::jdk_internal_vm_ThreadSnapshot();\n-  Klass* snapshot_klass = SystemDictionary::resolve_or_fail(snapshot_name, true, CHECK_NULL);\n+  Symbol* snapshot_klass_name = vmSymbols::jdk_internal_vm_ThreadSnapshot();\n+  Klass* snapshot_klass = SystemDictionary::resolve_or_fail(snapshot_klass_name, true, CHECK_NULL);\n@@ -2432,1 +2450,1 @@\n-  jdk_internal_vm_ThreadSnapshot::set_name(snapshot(), thread_name());\n+  jdk_internal_vm_ThreadSnapshot::set_name(snapshot(), cl._name.resolve());\n@@ -2434,0 +2452,1 @@\n+  jdk_internal_vm_ThreadSnapshot::set_carrier_thread(snapshot(), carrier_thread());\n@@ -2436,0 +2455,4 @@\n+  if (!cl._blocker.is_empty()) {\n+    jdk_internal_vm_ThreadSnapshot::set_blocker(snapshot(), cl._blocker._type, cl._blocker._obj.resolve());\n+    jdk_internal_vm_ThreadSnapshot::set_blocker_owner(snapshot(), cl._blocker_owner.resolve());\n+  }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":142,"deletions":119,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -464,1 +464,1 @@\n-  static oop get_thread_snapshot(jobject jthread, bool with_locks, TRAPS);\n+  static oop get_thread_snapshot(jobject jthread, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -750,0 +750,1 @@\n+  template(jdk_internal_vm_ThreadLock_signature,   \"Ljdk\/internal\/vm\/ThreadSnapshot$ThreadLock;\")                 \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-JVM_CreateThreadSnapshot(JNIEnv* env, jobject thread, jboolean withLocks);\n+JVM_CreateThreadSnapshot(JNIEnv* env, jobject thread);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2964,2 +2964,2 @@\n-JVM_ENTRY(jobject, JVM_CreateThreadSnapshot(JNIEnv* env, jobject jthread, jboolean withLocks))\n-  oop snapshot = java_lang_Thread::get_thread_snapshot(jthread, withLocks != JNI_FALSE, THREAD);\n+JVM_ENTRY(jobject, JVM_CreateThreadSnapshot(JNIEnv* env, jobject jthread))\n+  oop snapshot = java_lang_Thread::get_thread_snapshot(jthread, THREAD);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+    \/\/ filled by VM\n@@ -39,0 +40,1 @@\n+    private Thread carrierThread;\n@@ -40,0 +42,1 @@\n+    \/\/ owned monitors\n@@ -41,0 +44,8 @@\n+    \/\/ an object the thread is blocked\/waiting on, converted to ThreadBlocker by ThreadSnapshot.of()\n+    private int blockerTypeOrdinal;\n+    private Object blockerObject;\n+    \/\/ blocker owner (if known)\n+    private Object blockerOwner;\n+\n+    \/\/ set by ThreadSnapshot.of()\n+    private ThreadBlocker blocker;\n@@ -46,1 +57,1 @@\n-        ThreadSnapshot snapshot = create(thread, true);\n+        ThreadSnapshot snapshot = create(thread);\n@@ -53,0 +64,4 @@\n+        if (snapshot.blockerObject != null) {\n+            snapshot.blocker = new ThreadBlocker(snapshot.blockerTypeOrdinal, snapshot.blockerObject);\n+            snapshot.blockerObject = null; \/\/ release\n+        }\n@@ -82,3 +97,1 @@\n-        return findLockObject(0, LockType.PARKING_TO_WAIT)\n-                .findAny()\n-                .orElse(null);\n+        return getBlocker(BlockerLockType.PARK_BLOCKER);\n@@ -91,3 +104,1 @@\n-        return findLockObject(0, LockType.OWNABLE_SYNCHRONIZER)\n-                .findAny()\n-                .orElse(null);\n+        return parkBlocker() != null ? blockerOwner : null;\n@@ -104,3 +115,1 @@\n-        return findLockObject(0, LockType.WAITING_TO_LOCK)\n-                .findAny()\n-                .orElse(null);\n+        return getBlocker(BlockerLockType.WAITING_TO_LOCK);\n@@ -118,3 +127,1 @@\n-        return findLockObject(0, LockType.WAITING_ON)\n-                .findAny()\n-                .orElse(null);\n+        return getBlocker(BlockerLockType.WAITING_ON);\n@@ -128,1 +135,1 @@\n-                .anyMatch(lock -> lock.type() == LockType.LOCKED);\n+                .anyMatch(lock -> lock.type() == OwnedLockType.LOCKED);\n@@ -135,1 +142,1 @@\n-        return findLockObject(depth, LockType.LOCKED);\n+        return findLockObject(depth, OwnedLockType.LOCKED);\n@@ -138,1 +145,1 @@\n-    private Stream<Object> findLockObject(int depth, LockType type) {\n+    private Stream<Object> findLockObject(int depth, OwnedLockType type) {\n@@ -146,0 +153,4 @@\n+    private Object getBlocker(BlockerLockType type) {\n+        return blocker != null && blocker.type == type ? blocker.obj : null;\n+    }\n+\n@@ -150,1 +161,1 @@\n-        return null;\n+        return carrierThread;\n@@ -156,3 +167,1 @@\n-    private enum LockType {\n-        \/\/ Park blocker\n-        PARKING_TO_WAIT,\n+    private enum OwnedLockType {\n@@ -163,0 +172,5 @@\n+    }\n+\n+    private enum BlockerLockType {\n+        \/\/ Park blocker\n+        PARK_BLOCKER,\n@@ -164,0 +178,1 @@\n+        \/\/ Object.wait()\n@@ -165,3 +180,0 @@\n-        WAITING_TO_RELOCK,\n-        \/\/ No corresponding stack frame, depth is always == -1\n-        OWNABLE_SYNCHRONIZER\n@@ -174,1 +186,1 @@\n-        private static final LockType[] lockTypeValues = LockType.values(); \/\/ cache\n+        private static final OwnedLockType[] lockTypeValues = OwnedLockType.values(); \/\/ cache\n@@ -181,1 +193,2 @@\n-        private LockType type;\n+        \/\/ set by ThreadLock.of()\n+        private OwnedLockType type;\n@@ -194,1 +207,1 @@\n-        LockType type() {\n+        OwnedLockType type() {\n@@ -199,1 +212,1 @@\n-            if (type == LockType.ELIMINATED_SCALAR_REPLACED) {\n+            if (type == OwnedLockType.ELIMINATED_SCALAR_REPLACED) {\n@@ -207,1 +220,9 @@\n-    private static native ThreadSnapshot create(Thread thread, boolean withLocks);\n+    private record ThreadBlocker(BlockerLockType type, Object obj) {\n+        private static final BlockerLockType[] lockTypeValues = BlockerLockType.values(); \/\/ cache\n+\n+        ThreadBlocker(int typeOrdinal, Object obj) {\n+            this(lockTypeValues[typeOrdinal], obj);\n+        }\n+    }\n+\n+    private static native ThreadSnapshot create(Thread thread);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadSnapshot.java","additions":49,"deletions":28,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-Java_jdk_internal_vm_ThreadSnapshot_create(JNIEnv *env, jclass cls, jobject thread, jboolean withLocks)\n+Java_jdk_internal_vm_ThreadSnapshot_create(JNIEnv *env, jclass cls, jobject thread)\n@@ -35,1 +35,1 @@\n-  return JVM_CreateThreadSnapshot(env, thread, withLocks);\n+  return JVM_CreateThreadSnapshot(env, thread);\n","filename":"src\/java.base\/share\/native\/libjava\/ThreadSnapshot.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -426,1 +426,0 @@\n-    @Disabled\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/DumpThreads.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}